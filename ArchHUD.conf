name: ArchHud - Archaegeo v1.5201 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 0 --export:
        OrbitMapY = 25 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5201;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=""local aC=true;local aD=ResolutionX;local aE=ResolutionY;local aF={}local aG={}local aH={}local aI=0;local aJ=false;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=false;local aU=false;local aV=autoRollPreference;local aW=LandingGearGroundHeight;local aX=false;local aY=0;local aZ=AtmoSpeedLimit;local a_=0;local b0=nil;local b1={VectorToTarget=false}local b2=0;local b3=false;local b4=false;local b5=false;local b6=false;local b7=vec3(core.getConstructWorldOrientationUp())local b8=vec3(core.getConstructWorldOrientationForward())local b9=vec3(core.getConstructWorldOrientationRight())local ba=vec3(core.getVelocity())local bb=vec3(core.getWorldVelocity())local bc=vec3(bb):len()local bd=vec3(core.getWorldVertical())local be=-bd:dot(bb)local bf=vec3(core.getConstructWorldPos())local bg=false;local bh=false;local bi=nil;local bj=true;local bk=0;local bl=0;local bm={}local bn=false;local bo=50000;local bp=nil;local bq={}local br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bs=false;local bt=nil;local bu={}local bv="Atmo"local bw=false;local bx=0;local by={}local bz=nil;local bA=nil;local bB={}local bC=90;local bD=showHud;function p(bE)system.print(E..": "..bE)end;local function bF(bG)local D=1;if bG then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bH=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bH<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then aZ=r(aZ+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bx=bx+1*D*-1;if bx>#bm then bx=1 end;if bx<1 then bx=#bm end else if not bG then D=1 else D=nil end;aQ.adjustAutopilotTargetIndex(D)end end end;local function bI(bJ,bK,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)end end;local function bL(bM,bN)for i=1,#bN do bM[#bM+1]=bN[i]end;return bM end;local function bO(bP)local bQ={}local bR={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local bS={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bT={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bU={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bP then bL(bQ,bR)bL(bQ,bS)bL(bQ,bT)bL(bQ,bU)return bQ elseif bP=="boolean"then return bR elseif bP=="handling"then return bS elseif bP=="hud"then return bT elseif bP=="physics"then return bU end end;local function bV(bW,bX,bY,bZ,b_)if bZ==nil then bZ=""end;if b_==nil then b_=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bZ,bW,bX,b_,bY)end;local function c0(c1,c2)if c1==0 then return d(c2)<1e-09 end;if c2==0 then return d(c1)<1e-09 end;return d(c1-c2)<math.max(d(c1),d(c2))*epsilon end;local function c3(aj,c4)local c5=aj>100000;if c4==nil then c4=1 end;if c5 then return A(aj/1000/200,c4).."SU"elseif aj<1000 then return A(aj,c4).."M"else return A(aj/1000,c4).."KM"end end;local function c6(c7)local c8=0;local c9=0;local ca=0;if c7<60 then c7=e(c7)elseif c7<3600 then c8=e(c7/60)c7=e(c7%60)elseif c7<86400 then c9=e(c7/3600)c8=e(c7%3600/60)else ca=e(c7/86400)c9=e(c7%86400/3600)end;if ca>0 then return ca.."d "..c9 .."h "elseif c9>0 then return c9 .."h "..c8 .."m "elseif c8>0 then return c8 .."m "..c7 .."s"elseif c7>0 then return c7 .."s"else return"0s"end end;local function cb(cc)local function cd(ce)for cf,cg in pairs(ce)do dbHud_1.setStringValue(cg,h(_G[cg]))if cc and dbHud_2 then dbHud_2.setStringValue(cg,h(_G[cg]))end end end;if dbHud_1 then cd(c)cd(bO())system.print("Saved Variables to Datacore")if cc and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function ch()local function ci(cj)return type(cj)=='number'end;local function ck(cj)return type(z(cj))=='number'end;local function cl(cm)return type(cm)=='table'end;local function cn(co)return type(co)=='string'end;local function cp(cg)return cl(cg)and ci(cg.x and cg.y and cg.z)end;local function cq(cr)return cl(cr)and ci(cr.latitude and cr.longitude and cr.altitude and cr.id and cr.systemId)end;local cs=math.pi/180;local ct=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cv(cj)local cw=string.gsub(string.reverse(f('%.4f',cj)),'^0*%.?','')return cw==''and'0'or string.reverse(cw)end;local function cx(cy)if cp(cy)then return f('{x=%.3f,y=%.3f,z=%.3f}',cy.x,cy.y,cy.z)end;if cl(cy)and not getmetatable(cy)then local cz={}local cA=next(cy)if type(cA)=='nil'or cA==1 then cz=cy else for cf,cg in pairs(cy)do local cB=cx(cg)if type(cf)=='number'then table.insert(cz,f('[%s]=%s',cf,cB))else table.insert(cz,f('%s=%s',cf,cB))end end end;return f('{%s}',table.concat(cz,','))end;if cn(cy)then return f("'%s'",cy:gsub("'",[[\']]))end;return tostring(cy)end;local cC={}cC.__index=cC;cC.__tostring=function(cy,cD)local cE={}for cf in pairs(cy)do table.insert(cE,cf)end;table.sort(cE)local cz={}for _,cf in ipairs(cE)do local cB=cx(cy[cf])if type(cf)=='number'then table.insert(cz,f('[%s]=%s',cf,cB))else table.insert(cz,f('%s=%s',cf,cB))end end;if cD then return f('%s%s',cD,table.concat(cz,',\n'..cD))end;return f('{%s}',table.concat(cz,','))end;cC.__eq=function(cF,cG)return cF.systemId==cG.systemId and cF.id==cG.id and c0(cF.radius,cG.radius)and c0(cF.center.x,cG.center.x)and c0(cF.center.y,cG.center.y)and c0(cF.center.z,cG.center.z)and c0(cF.GM,cG.GM)end;local function cH(cI,cJ,cK,cL,cM)assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(cK),'Argument 3 (radius) must be a number:'..type(cK))assert(cl(cL),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cL))assert(ck(cM),'Argument 5 (GM) must be a number:'..type(cM))return setmetatable({systemId=z(cI),id=z(cJ),radius=z(cK),center=vec3(cL),GM=z(cM)},cC)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cv(p.latitude*ct),cv(p.longitude*ct),cv(p.altitude))end;MapPosition.__eq=function(cF,cG)return cF.id==cG.id and cF.systemId==cG.systemId and c0(cF.latitude,cG.latitude)and c0(cF.altitude,cG.altitude)and(c0(cF.longitude,cG.longitude)or c0(cF.latitude,math.pi/2)or c0(cF.latitude,-math.pi/2))end;local function cN(cO,cJ,cP,cQ,cR)local cI=cO;if cn(cO)and not cQ and not cR and not cJ and not cP then cI,cJ,cP,cQ,cR=o(cO,cu)assert(cI,'Argument 1 (position string) is malformed.')else assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(cP),'Argument 3 (latitude) must be in degrees:'..type(cP))assert(ck(cQ),'Argument 4 (longitude) must be in degrees:'..type(cQ))assert(ck(cR),'Argument 5 (altitude) must be in meters:'..type(cR))end;cI=z(cI)cJ=z(cJ)cP=z(cP)cQ=z(cQ)cR=z(cR)if cJ==0 then return setmetatable({latitude=cP,longitude=cQ,altitude=cR,id=cJ,systemId=cI},MapPosition)end;return setmetatable({latitude=cs*r(cP,-90,90),longitude=cs*(cQ%360),altitude=cR,id=cJ,systemId=cI},MapPosition)end;local cS={}cS.__index=cS;cS.__tostring=function(cy,cD)local cT=cD and cD..'  'local cU={}local cE={}for cf in pairs(cy)do table.insert(cE,cf)end;table.sort(cE)for _,cV in ipairs(cE)do bdy=cy[cV]local cW=cC.__tostring(bdy,cT)if cD then table.insert(cU,f('[%s]={\n%s\n%s}',cV,cW,cD))else table.insert(cU,f('  [%s]=%s',cV,cW))end end;if cD then return f('\n%s%s%s',cD,table.concat(cU,',\n'..cD),cD)end;return f('{\n%s\n}',table.concat(cU,',\n'))end;local function cX(cY)local b={}local pid;for _,cg in pairs(cY)do local cJ=cg.planetarySystemId;if type(cJ)~='number'then error('Invalid planetary system ID: '..tostring(cJ))elseif pid and cJ~=pid then error('Mistringmatch planetary system IDs: '..cJ..' and '..pid)end;local cZ=cg.bodyId;if type(cZ)~='number'then error('Invalid body ID: '..tostring(cZ))elseif b[cZ]then error('Duplicate body ID: '..tostring(cZ))end;setmetatable(cg.center,getmetatable(vec3.unit_x))b[cZ]=setmetatable(cg,cC)pid=cJ end;return setmetatable(b,cS)end;aK={}local function c_(cY)return setmetatable({galaxyAtlas=cY or{}},aK)end;aK.__index=function(cm,i)if type(i)=='number'then local system=cm.galaxyAtlas[i]return cX(system)end;return rawget(aK,i)end;aK.__pairs=function(cy)return function(cm,cf)local d0,nv=next(cm,cf)return d0,nv and cX(nv)end,cy.galaxyAtlas,nil end;aK.__tostring=function(cy)local d1={}for _,d2 in pairs(cy or{})do local d3=d2:getPlanetarySystemId()local d4=cS.__tostring(d2,'    ')table.insert(d1,f('  [%s]={%s\n  }',d3,d4))end;return f('{\n%s\n}\n',table.concat(d1,',\n'))end;aK.BodyParameters=cH;aK.MapPosition=cN;aK.PlanetarySystem=cX;function aK.createBodyParameters(cI,cJ,d5,d6,d7,d8,d9)assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(d5),'Argument 3 (surfaceArea) must be a number:'..type(d5))assert(cl(d6),'Argument 4 (aPosition) must be an array or vec3:'..type(d6))assert(cl(d7),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(d7))assert(ck(d8),'Argument 6 (altitude) must be in meters:'..type(d8))assert(ck(d9),'Argument 7 (gravityAtPosition) must be number:'..type(d9))local cK=y(d5/4/math.pi)local aj=cK+d8;local da=vec3(d6)+aj*vec3(d7)local cM=d9*aj*aj;return cH(cI,cJ,cK,da,cM)end;aK.isMapPosition=cq;function aK:getPlanetarySystem(cO)if i==nil then i=0 end;if nv==nil then nv=0 end;local cI=cO;if cq(cO)then cI=cO.systemId end;if type(cI)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=cS then system=cX(system)end;return system end end end;function cS:sizeCalculator(db)return 1.05*db.radius end;function cS:castIntersections(dc,dd,de,df,dg,dh)local di={}if dg then for _,db in pairs(dg)do table.insert(di,db)end else di=bB end;if not dh then table.sort(di,function(dj,dk)local c1=dj.center;local c2=dk.center;return(c1.x-dc.x)^2+(c1.y-dc.y)^2+(c1.z-dc.z)^2<(c2.x-dc.x)^2+(c2.y-dc.y)^2+(c2.z-dc.z)^2 end)end;local dl=dd:normalize()for _,db in ipairs(di)do local dm=db.center-dc;local cK=self:sizeCalculator(db)local dn=dm:dot(dl)local dp=dn^2-(dm:len2()-cK^2)if dp>=0 then local dq=y(dp)local dr=dn+dq;local ds=dn-dq;if ds>0 then return db,dr,ds elseif dr>0 then return db,dr,nil end end end;return nil,nil,nil end;function cS:closestBody(dt)assert(type(dt)=='table','Invalid coordinates.')local du,db;local dv=vec3(dt)for _,dw in pairs(self)do local dx=(dw.center-dv):len2()if(not db or dx<du)and dw.name~="Space"then db=dw;du=dx end end;return db end;function cS:convertToBodyIdAndWorldCoordinates(cO)local dy=cO;if cn(cO)then dy=cN(cO)end;if dy.id==0 then return 0,vec3(dy.latitude,dy.longitude,dy.altitude)end;local dw=self:getBodyParameters(dy)if dw then return dy.id,dw:convertToWorldCoordinates(dy)end end;function cS:getBodyParameters(cO)local cJ=cO;if cq(cO)then cJ=cO.id end;assert(ck(cJ),'Argument 1 (id) must be a number:'..type(cJ))return self[cJ]end;function cS:getPlanetarySystemId()local _,cg=next(self)return cg and cg.systemId end;function cC:convertToMapPosition(cL)assert(cl(cL),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cL))local dz=vec3(cL)if self.id==0 then return setmetatable({latitude=dz.x,longitude=dz.y,altitude=dz.z,id=0,systemId=self.systemId},MapPosition)end;local dA=dz-self.center;local aj=dA:len()local cR=aj-self.radius;local cP=0;local cQ=0;if not c0(aj,0)then local dB=n(dA.y,dA.x)cQ=dB>=0 and dB or 2*math.pi+dB;cP=math.pi/2-math.acos(dA.z/aj)end;return setmetatable({latitude=cP,longitude=cQ,altitude=cR,id=self.id,systemId=self.systemId},MapPosition)end;function cC:convertToWorldCoordinates(cO)local dy=cn(cO)and cN(cO)or cO;if dy.id==0 then return vec3(dy.latitude,dy.longitude,dy.altitude)end;assert(cq(dy),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dy.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dy.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dC=math.cos(dy.latitude)return self.center+(self.radius+dy.altitude)*vec3(dC*math.cos(dy.longitude),dC*math.sin(dy.longitude),math.sin(dy.latitude))end;function cC:getAltitude(cL)return(vec3(cL)-self.center):len()-self.radius end;function cC:getDistance(cL)return(vec3(cL)-self.center):len()end;function cC:getGravity(cL)local dD=self.center-vec3(cL)local dE=dD:len2()return self.GM/dE*dD/y(dE)end;return setmetatable(aK,{__call=function(_,...)return c_(...)end})end;local function dF()local aM={}local dG=30000000/3600;local dH=dG*dG;local dI=100;function aM.computeAccelerationTime(dJ,dK,dL)local dM=dG*math.asin(dJ/dG)return(dG*math.asin(dL/dG)-dM)/dK end;function aM.computeDistanceAndTime(dJ,dL,dN,dO,dP,dQ)dP=dP or 0;dQ=dQ or 0;local dR=dJ<=dL;local dS=dO*(dR and 1 or-1)/dN;local dT=-dQ/dN;local dU=dS+dT;if dR and dU<=0 or not dR and dU>=0 then return-1,-1 end;local dV,dW=0,0;if dS~=0 and dP>0 then local dM=math.asin(dJ/dG)local dX=math.pi*(dS/2+dT)local dY=dS*dP;local dZ=dG*math.pi;local cg=function(cm)local d_=(dX*cm-dY*math.sin(math.pi*cm/2/dP)+dZ*dM)/dZ;local e0=math.tan(d_)return dG*e0/y(e0*e0+1)end;local e1=dR and function(co)return co>=dL end or function(co)return co<=dL end;dW=2*dP;if e1(cg(dW))then local e2=0;while d(dW-e2)>0.5 do local cm=(dW+e2)/2;if e1(cg(cm))then dW=cm else e2=cm end end end;local e3=dJ;local e4=dW/dI;for e5=1,dI do local e6=cg(e5*e4)dV=dV+(e6+e3)*e4/2;e3=e6 end;if dW<2*dP then return dV,dW end;dJ=e3 end;local dM=dG*math.asin(dJ/dG)local E=(dG*math.asin(dL/dG)-dM)/dU;local e7=dH*math.cos(dM/dG)/dU;local aj=e7-dH*math.cos((dU*E+dM)/dG)/dU;return aj+dV,E+dW end;function aM.computeTravelTime(dJ,dK,aj)if aj==0 then return 0 end;if dK>0 then local dM=dG*math.asin(dJ/dG)local e7=dH*math.cos(dM/dG)/dK;return(dG*math.acos(dK*(e7-aj)/dH)-dM)/dK end;if dJ==0 then return-1 end;assert(dJ>0,'Acceleration and initial speed are both zero.')return aj/dJ end;return aM end;local function e8()local vec3=require('cpml.vec3')local ch=ch()local function cn(co)return type(co)=='string'end;local function cl(cm)return type(cm)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cR)assert(self.body)local aj=cR+self.body.radius;if not c0(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cO,e9)assert(self.body)assert(cl(cO)or cn(cO))assert(cl(e9))local ea=(cn(cO)or ch.isMapPosition(cO))and self.body:convertToWorldCoordinates(cO)or vec3(cO)local cg=vec3(e9)local eb=ea-self.body.center;local ec=cg:len2()local ed=eb:len()local ee=self.body.GM;local ef=((ec-ee/ed)*eb-eb:dot(cg)*cg)/ee;local c1=ee/(2*ee/ed-ec)local eg=ef:len()local dl=ef:normalize()local eh=c1*(1-eg)local ei=c1*(1+eg)local ej=eh*dl+self.body.center;local ek=eg<=1 and-ei*dl+self.body.center or nil;local el=y(c1*ee*(1-eg*eg))local em=ek and 2*math.pi*y(c1^3/ee)local en=math.acos(ef:dot(eb)/(eg*ed))if eb:dot(cg)<0 then en=-(en-2*math.pi)end;local eo=math.acos((math.cos(en)+eg)/(1+eg*math.cos(en)))local ep=eo;if ep<0 then ep=ep+2*math.pi end;local eq=ep-eg*math.sin(ep)local er=0;local es=0;local et=0;if em~=nil then er=eq/(2*math.pi/em)es=em-er;et=es+em/2;if en-math.pi>0 then es=er;et=es+em/2 end;if et>em then et=et-em end end;return{periapsis={position=ej,speed=el/eh,circularOrbitSpeed=y(ee/eh),altitude=eh-self.body.radius},apoapsis=ek and{position=ek,speed=el/ei,circularOrbitSpeed=y(ee/ei),altitude=ei-self.body.radius},currentVelocity=cg,currentPosition=ea,eccentricity=eg,period=em,eccentricAnomaly=eo,meanAnomaly=eq,timeToPeriapsis=es,timeToApoapsis=et,trueAnomaly=en}end;local function eu(ev)local dw=ch.BodyParameters(ev.systemId,ev.id,ev.radius,ev.center,ev.GM)return setmetatable({body=dw},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eu(...)end})end;local function ew()local ex={}local ey={}local ez={XS=13,S=27,M=55,L=110,XL=221}local eA={}local eB;local eC;local eD;local eE;local eF;local function eG()local function eH(eI,eJ,eK,eL,eM,eN,eO,eP)eJ,eL,eN,eP=vec3(eJ),vec3(eL),vec3(eN),vec3(eP)local eQ,eR,eS=eI*eI,eK*eK,eM*eM;local ec=eL-eJ;local eT=ec:normalize()local eU=ec:len()local eV=eN-eJ;local eW=(eV-eV:project_on(eT)):normalize()local eX,eY=eV:dot(eT),eV:dot(eW)local eZ=eX*eX+eY*eY;local e_=eT:cross(eW)local bW=(eQ-eR+eU*eU)/(2*eU)local bX=(eQ-eS+eZ-2*eX*bW)/(2*eY)local cr=eQ-bW^2-bX^2;local f0=y(cr)local f1=eJ+eT*bW+eW*bX+e_*f0;local f2=eJ+eT*bW+eW*bX-e_*f0;if d((eP-f1):len()-eO)<d((eP-f2):len()-eO)then return f1 else return f2 end end;local function f3()local function f4()local f5=core.getConstructWorldOrientationRight()local ec=core.getConstructWorldOrientationForward()local eV=core.getConstructWorldOrientationUp()local f6=library.systemResolution3(f5,ec,eV,{1,0,0})local f7=library.systemResolution3(f5,ec,eV,{0,1,0})local f8=library.systemResolution3(f5,ec,eV,{0,0,1})return function(f9)return library.systemResolution3(f6,f7,f8,f9)end end;local fa=f4()local fb=core.getConstructWorldPos()local ea=core.getElementPositionById(1)local fc={ea[1],ea[2],ea[3]}local fd=fa(fc)local fe={fb[1]-fd[1],fb[2]-fd[2],fb[3]-fd[3]}return fe end;local function ff(fg,ed,fh)local fi=fg.pts;local fj=#fi;local fk=fg.ref;if fj>3 then local fl,fm,fn,fo=fi[fj],fi[fj-1],fi[fj-2],fi[fj-3]fg.ref=fh;local ea=eH(fl[1],fl[2],fm[1],fm[2],fn[1],fn[2],fo[1],fo[2])local bW,bX,f0=ea.x,ea.y,ea.z;if bW==bW and bX==bX and f0==f0 then bW=bW+fk[1]bX=bX+fk[2]f0=f0+fk[3]local fp=vec3(bW,bX,f0)if not fg.lastPos then fg.center=fp elseif(fg.lastPos-fp):len()<2 then fg.center=fp;fg.skipCalc=true end;fg.lastPos=fp end;fg.pts={}else local fq={fh[1]-fk[1],fh[2]-fk[2],fh[3]-fk[3]}fi[fj+1]={ed,fq}end end;if bu[1]then eB=#bu[1].getConstructIds()local fr=bu[1].getData()local fs=fr:gmatch('{"constructId[^}]*}[^}]*}')if eB>0 then local fh=f3()local ft,fu=0,0;eF,eE=0,0;for cg in fs do local cJ,aj,fv=cg:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fw=ez[fv]aj=z(aj)if bu[1].hasMatchingTransponder(cJ)==1 then table.insert(ey,cJ)end;local fx=bu[1].getConstructType(cJ)if CollisionSystem then if fw>27 or fx=="static"or fx=="space"then eF=eF+1;local fy=bu[1].getConstructName(cJ)local fg=bq[cJ]if fg==nil then fw=fw+G;bq[cJ]={pts={},ref=fh,name=fy,i=0,radius=fw,skipCalc=false}fg=bq[cJ]end;if not fg.skipCalc then ff(fg,aj,fh)fu=fu+1 end;if fg.center then table.insert(eA,fg)end end;ft=ft+1;if br and ft>700 or fu>70 or(not br and ft>300 or fu>30)then coroutine.yield()ft,fu=0,0 end end end;eE=#eA;if eE>0 and bc>20 then local db,fz,fA,fB;local fC=0;local fD=aL:getPlanetarySystem(0)fB=bb:normalize()while fC<eE do coroutine.yield()local fE={table.unpack(eA,fC,math.min(fC+75,eE))}db,fz,fA=fD:castIntersections(bf,fB,nil,nil,fE,true)if db and fA then bt={db,fz,fA}break end;fC=fC+75 end;if not db then bt=nil end else bt=nil end;eA={}eC=fr:find('identifiedConstructs":%[%]')else eD=fr:find('worksInEnvironment":false')end end end;local function fF()if bu[1]then bv="Atmo"if bu[1].getData():find('worksInAtmosphere":false')then bv="Space"end end end;function ex.pickType()fF()end;function ex.assignRadar()if radar_1 and bu[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bu[1]=radar_2 end;if bu[1]==radar_2 then fF()end elseif radar_2 and bu[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bu[1]=radar_1 end;if bu[1]==radar_1 then fF()end end end;function ex.UpdateRadar()local fG=coroutine.status(UpdateRadarCoroutine)if fG=="suspended"then local cB,fH=coroutine.resume(UpdateRadarCoroutine)if fH then system.print("ERROR UPDATE RADAR: "..fH)end elseif fG=="dead"then UpdateRadarCoroutine=coroutine.create(eG)local cB,fH=coroutine.resume(UpdateRadarCoroutine)end end;function ex.GetRadarHud()local fI=ey;ey={}return eC,eD,eB,eE,eF,fI end;UpdateRadarCoroutine=coroutine.create(eG)return ex end;local function fJ()local fK=9.80665;local fL={}local fM={}local fN={}local by={}local fO=nil;local fP=nil;local fQ=nil;local fR=false;local fS={}local fT=""local fU=vec3({13771471,7435803,-128971})local fV=18000000;local fW=500000;local fX,fY=math.huge;local fZ;local function f_(g0)fX=vec3(g0):dist(fU)if fX<fV then return true,d(fX-fV)end;fY=vec3(g0):dist(vec3(planet.center))if fY<fW then fZ=true else fZ=false end;if d(fY-fW)<d(fX-fV)then return fZ,d(fY-fW)else return fZ,d(fX-fV)end end;local function g1(cg)if aD==1920 then return cg else return A(aD*cg/1920,0)end end;local function g2(cg)if aE==1080 then return cg else return A(aE*cg/1080,0)end end;local function g3()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function g4()local g5="TRAVEL"if not bj then g5="CRUISE"end;if Autopilot then g5="AUTOPILOT"end;return g5 end;local g6={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local g7=""local g8=""local g9=""local ga=1;local gb=2;local gc=3;local gd=4;local ge=5;local gf=6;local gg=""local gh=0;local gi=e(1/apTickRate)*2*hudTickRate;local gj={}local gk={}local gl={}local gm={}local gn={}local go={}local function gp(bW,gq,gr,gs,gt,gu)local gv=tankY;local gw=tankY+5;if not BarFuelDisplay then gw=gw+5 end;if m()==1 and not RemoteHud then gv=gv-50;gw=gw-50 end;if gr=="ATMO"then gg="atmofueltank"elseif gr=="SPACE"then gg="spacefueltank"else gg="rocketfueltank"end;gh=_G[gg.."_size"]if#gs>0 then for i=1,#gs do local fy=string.sub(gs[i][gb],1,12)local gx=0;for gy=1,gh do if gs[i][gb]==g(unit[gg.."_"..gy].getData()).name then gx=gy;break end end;local gz=q()if gt[i]==nil or gu[i]==nil or gz-gs[i][gf]>gi then local gA;local gB=0;if gx~=0 then gu[i]=g(unit[gg.."_"..gx].getData()).percentage;gt[i]=g(unit[gg.."_"..gx].getData()).timeLeft;if gt[i]=="n/a"then gt[i]=0 end else gB=l(gs[i][ga])-gs[i][gd]gu[i]=e(0.5+gB*100/gs[i][gc])gA=gs[i][ge]if gA<=gB then gt[i]=0 else gt[i]=e(0.5+gB/((gA-gB)/(gz-gs[i][gf])))end;gs[i][ge]=gB;gs[i][gf]=gz end end;if fy==gq then fy=f("%s %d",gr,i)end;if gx==0 then fy=fy.." *"end;local gC;if gt[i]==0 then gC=""else gC=c6(gt[i])end;if gu[i]~=nil then local gD=e(gu[i]*2.55)local gE=f("rgb(%d,%d,%d)",255-gD,gD,0)local bZ=""if gC~=""and gt[i]<120 or gu[i]<5 then bZ="red "end;local gF=f("rgb(%d,%d,%d)",r(e((255-gD)/2.55),50,100),r(e(gD/2.55),0,50),50)local gG="rgb(196,0,255)"if gr=="ATMO"then gG="rgb(0,188,255)"elseif gr=="SPACE"then gG="rgb(239,255,0)"end;local gH=false;if previous~=gG then gH=true end;previous=gG;if BarFuelDisplay then if gH then gv=gv-5;gw=gw-5 end;g8=g8 ..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gF,gG,bW,gw,gE,e(gu[i]*1.7+0.5)-2,bW+1,gw+1,bW+5,gw+14,fy,gu[i],gC)gv=gv-22;gw=gw-22 else g8=g8 ..bV(bW,gv,fy,bZ.."pdim txtfuel")g8=g8 ..bV(bW,gw,f("%d%% %s",gu[i],gC),"pdim txtfuel","fill:"..gE)gv=gv+30;gw=gw+30 end end end end;tankY=gv end;local function gI(gJ,cR)if cR<200000 and not aq or cR and aq then local gK=0;if d(be)>1 then gK=45*math.log(d(be),10)if be<0 then gK=-gK end end;gJ[#gJ+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(be),e(gK))end;return gJ end;local function gL(gM)local gN=-bd;gM=gM-gM:project_on(gN)local gO=vec3(0,0,1)gO=gO-gO:project_on(gN)local gP=gO:cross(gN)local gK=gO:angle_between(gM)*constants.rad2deg;if gM:dot(gP)<0 then gK=360-gK end;return gK end;local function gQ(gJ,centerX,centerY,gR,gS,br)local gT=circleRad;local gU=20;local gV=e(gR)if br then for i=-45,45,5 do local gW=i;gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],gW,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gJ[#gJ+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gT+gU-len,centerX,centerY+gT+gU)end;gJ[#gJ+1]=bV(centerX,centerY+gT+gU-35,gS,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY+gT+gU-25,gV.." deg","pdim txt txtmid")gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gR,centerX,centerY)gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gT+gU-20,centerX+5,centerY+gT+gU-20,centerX,centerY+gT+gU-15)gJ[#gJ+1]="</g>"end;gJ[#gJ+1]=[[<g style="clip-path: url(#headingClip);">]]local gX=gV;if br then gX=gL(b8)end;local gY=20;local gZ=e(gX)local g_=0;local h0=centerY+gT+gU+20;local h1=centerX;if gS~="YAW"then h0=g2(130)h1=g1(960)end;local h2=[[<path class="txttick line" d="]]local h3=e(gZ-(gY+10)-gZ%5+0.5)for i=h3+70,h3,-5 do local bW=h1-(-i*5+gX*5)if i%10==0 then g_=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gJ[#gJ+1]=bV(bW,h0+15,B,"txtmid bright")elseif i%5==0 then g_=5 end;if g_==10 then h2=f([[%s M %f %f v %d]],h2,bW,h0-5,g_)else h2=f([[%s M %f %f v %d]],h2,bW,h0-2.5,g_)end end;gJ[#gJ+1]=h2 ..[["/>]]gJ[#gJ+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],h1-5,h0-20,h1+5,h0-20,h1,h0-10)if br then gS="HDG"end;gJ[#gJ+1]=bV(g1(960),g2(100),gZ.."Â°","dim txt txtmid size14","")gJ[#gJ+1]=bV(g1(960),g2(85),gS,"dim txt txtmid size20","")gJ[#gJ+1]=[[</g>]]end;local function h4(gJ,h5,gR,centerX,centerY,br,h6,e6)local gT=circleRad;local h7=e(gT*3/5)if gT>0 then local h8=e(h5)local len=0;local h2=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gR,centerX,centerY)if not aq then h2=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gJ[#gJ+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gT-1,centerX,centerY)gJ[#gJ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(h8-30-h8%5+0.5),e(h8+30+h8%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bX=centerY+-i*5+h5*5;if len==30 then h2=f([[%s M %d %f h %d]],h2,centerX-h7-len,bX,len)if aq then gJ[#gJ+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gR,centerX,centerY,centerX-h7+10,bX+4,i)gJ[#gJ+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gR,centerX,centerY,centerX+h7-10,bX+4,i)if i==0 or i==180 or i==-180 then gJ[#gJ+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gR,centerX,centerY,centerX-h7+20,bX,h7*2-40)end else gJ[#gJ+1]=bV(centerX-h7+10,bX,i,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX+h7-10,bX,i,"pdim txt txtmid")end;h2=f([[%s M %d %f h %d]],h2,centerX+h7,bX,len)else h2=f([[%s M %d %f h %d]],h2,centerX-h7-len,bX,len)h2=f([[%s M %d %f h %d]],h2,centerX+h7,bX,len)end end;gJ[#gJ+1]=h2 ..[["/>]]local h9="PITCH"if not br then h9="REL PITCH"end;if h5>90 and not aq then h5=90-(h5-90)elseif h5<-90 and not aq then h5=-90-(h5+90)end;if gT>200 then if aq then if e6>Q then gJ[#gJ+1]=bV(centerX,centerY-15,"Yaw","pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY+20,h6,"pdim txt txtmid")end;gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gR,centerX,centerY)else gJ[#gJ+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-h7+25,centerY-5,centerX-h7+20,centerY,centerX-h7+25,centerY+5,centerX-h7+50,centerY+4,h8)gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+h7-25,centerY-5,centerX+h7-20,centerY,centerX+h7-25,centerY+5,centerX+h7-30,centerY+4,h8)gJ[#gJ+1]="</g>"end;local ha=e(gT/3)gJ[#gJ+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-ha,centerY,gT-ha)if not aq and br then gJ[#gJ+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gR,centerX,centerY,centerX-h7+10,centerY,h7*2-20)end;gJ[#gJ+1]="</g>"if gT<200 then if aq and e6>Q then gJ[#gJ+1]=bV(centerX,centerY-gT,h9,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY-gT+10,h8,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY-15,"Yaw","pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY+20,h6,"pdim txt txtmid")else gJ[#gJ+1]=bV(centerX,centerY-gT,h9,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY-gT+15,h8,"pdim txt txtmid")end end end end;local function hb(gJ,cR,br)local hc=altMeterX;local hd=altMeterY;local he=78;local hf=19;local hg=ao;if ao~=-1 then gJ[#gJ+1]=bV(hc+he,hd+hf+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if br and(cR<200000 and not aq or cR and aq)then table.insert(gJ,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hc-1,hd-4,he+2,hf+6,hc+1,hd-1,he-4,hf))local fj=0;local hh=1;local hi=0;local hj=cR<0;local hk=cR<planet.surfaceMaxAltitude;local hl=9;if hj then hl=0 end;local cR=d(cR)while fj<6 do local hm=11;local hn=16;local ho=9;local hp=14;local bZ="altsm"if fj>2 then hn=hn+3;hm=hm+2;hp=hp+2;ho=ho-6;bZ="altbig"end;if hj then bZ=bZ.." red"elseif hk then bZ=bZ.." orange"end;local hq=cR/hh%10;local hr=e(hq)local hs=e((hr+1)%10)local ht=hi;if fj==0 then ht=hq-hr;if hj then ht=1-ht end end;if hj and(fj==0 or hi~=0)then local hu=hs;hs=hr;hr=hu end;local hv=hn*(ht-1)local hw=hv+hn;local bW=hc+ho+(6-fj)*hm;local bX=hd+hp;gJ[#gJ+1]=bV(bW,bX+hv,hs,bZ)gJ[#gJ+1]=bV(bW,bX+hw,hr,bZ)fj=fj+1;hh=hh*10;if hr==hl then hi=ht else hi=0 end end;table.insert(gJ,[[</g></g>]])end end;local function hx(e9)local hy=-math.deg(n(e9.y,e9.z))+180;hy=hy-90;if hy<0 then hy=360+hy end;if hy>180 then hy=-180+hy-180 end;return-hy end;local function hz(e9)local gX=math.deg(n(e9.y,e9.x))-90;if gX<-180 then gX=360+gX end;return gX end;local function hA(gJ,e9,e6,centerX,centerY)if e6>5 and not aq or e6>Q then local gT=circleRad;local hB=20;local hC=20;local hD=hx(e9)local hE=hz(e9)local hF=14;local hG=hF/2;local hH=-hE/hC*gT;local hI=hD/hB*gT;local bW=centerX+hH;local bX=centerY+hI;local aj=y(hH^2+hI^2)local hJ=[[<circle
                            cx="]]..bW..[["
                            cy="]]..bX..[["
                            r="]]..hG/hF..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bW..[["
                            cy="]]..bX..[["
                            r="]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bW-hF..[[,]]..bX..[[ h ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bW+hG..[[,]]..bX..[[ h ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bW..[[,]]..bX-hF..[[ v ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<gT then gJ[#gJ+1]=hJ else local gK=n(hI,hH)local hK=4;local hL=centerX+gT*math.cos(gK)local hM=centerY+gT*math.sin(gK)gJ[#gJ+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gK*180/math.pi,hL,hM,hL-hK,hM-hK/2,hK*2,hK,hL+hK,hM-hK,hK,hK,-hK,hK)end;if not aq then local hN=vec3(e9)hD=hx(-hN)hE=hz(-hN)hH=-hE/hC*gT;hI=hD/hB*gT;bW=centerX+hH;bX=centerY+hI;aj=y(hH^2+hI^2)if aj<gT then local hO=[[<circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bW..[[,]]..bX-hF..[[ v ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bW..[[,]]..bX..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bW..[[,]]..bX..[[)" />
                                <path
                                    d="M ]]..bW-hG..[[,]]..bX..[[ h ]]..hF..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bW..[[,]]..bX..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bW..[[,]]..bX..[[)"/>]]gJ[#gJ+1]=hO end end end end;local function hP(gJ,g5,hQ,hR)hQ=e(hQ+0.5)local gv=throtPosY+10;local gw=throtPosY+20;if m()==1 and not RemoteHud then gv=55;gw=65 end;local hS="CRUISE"local unit="km/h"local cB=hR;if g5=="TRAVEL"or g5=="AUTOPILOT"then hS="THROT"unit="%"cB=hQ;local hT="dim"if hQ<0 then hT="red"end;gJ[#gJ+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hT,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(hQ),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gJ[#gJ+1]=bV(throtPosX+10,gv,hS,"pbright txtstart")gJ[#gJ+1]=bV(throtPosX+10,gw,f("%.0f %s",cB,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bj and M then hQ=e(N*100+0.5)local hT="red"if hQ<0 then hT="red"end;gJ[#gJ+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hT,1-d(hQ),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gJ[#gJ+1]=bV(throtPosX+10,gv+40,"LIMIT","pbright txtstart")gJ[#gJ+1]=bV(throtPosX+10,gw+40,hQ.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gJ[#gJ+1]=bV(throtPosX+10,gv-40,"LIMIT: "..aZ.." km/h","dim txtstart")elseif not aq and Autopilot then gJ[#gJ+1]=bV(throtPosX+10,gv-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hU(gJ,hV)local hW=throtPosY-10;local hX=throtPosX+10;gJ[#gJ+1]=bV(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then hW=75 end;gJ[#gJ+1]=bV(hX,hW,e(hV).." km/h","pbright txtbig txtstart")end;local function hY(gJ)gJ[#gJ+1]=bV(g1(1900),g2(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gJ[#gJ+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gJ[#gJ+1]=bV(g1(960),g2(550),"Warning: Invalid Control Scheme Detected","warnings")gJ[#gJ+1]=bV(g1(960),g2(600),"Keyboard Scheme must be selected","warnings")gJ[#gJ+1]=bV(g1(960),g2(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hZ=g1(960)local h_=g2(860)local i0=g2(880)local i1=g2(900)local i2=g2(960)local i3=g2(200)local i4=g2(250)local i5=g2(960)if m()==1 and not RemoteHud then h_=g2(135)i0=g2(155)i1=g2(175)i3=g2(115)i4=g2(95)end;local i6="#222222"local i7="white"local i8="dimmer"local i9="pbright"local ia="#110000"local ib=i6;local ic=i8;if BrakeIsOn then gJ[#gJ+1]=bV(hZ,h_,"Brake Engaged","warnings")ia="#440000"ib=i7;ic=i9 elseif L>0 then gJ[#gJ+1]=bV(hZ,h_,"Auto-Brake Engaged","warnings","opacity:"..L)end;local id="#110000"local ie=i6;local ig=i8;if aq and aX and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bh and not VertTakeOff and not AutoTakeoff then gJ[#gJ+1]=bV(hZ,i3+50,"** STALL WARNING **","warnings")id="#ff0000"ie=i7;ig=i9;bI("stall","SW",2)end end;if bp then gJ[#gJ+1]=bV(hZ,i3+90,"Flight Assist in Progress","warnings")end;if ax then gJ[#gJ+1]=bV(hZ,i5,"Gyro Enabled","warnings")end;local ih="#111100"local ii=i6;local ij=i8;if GearExtended then ih="#775500"ii=i7;ij=i9;if S then gJ[#gJ+1]=bV(hZ,i0,"Gear Extended","warn")else gJ[#gJ+1]=bV(hZ,i0,"Landed (G: Takeoff)","warnings")end;local ik=c3(a:getTargetGroundAltitude())gJ[#gJ+1]=bV(hZ,i1,"Hover Height: "..ik,"warn")end;local il="#000011"local im=i6;local io=i8;if a7 then il="#0000DD"im=i7;io=i9;gJ[#gJ+1]=bV(hZ,i2+20,"ROCKET BOOST ENABLED","warn")end;local ip="#001100"local iq=i6;local ir=i8;if antigrav and not ExternalAGG and bh and AntigravTargetAltitude~=nil then ip="#00DD00"iq=i7;ir=i9;if d(as-antigrav.getBaseAltitude())<501 then gJ[#gJ+1]=bV(hZ,i3+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gJ[#gJ+1]=bV(hZ,i3+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gJ[#gJ+1]=bV(hZ,i3+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gJ[#gJ+1]=bV(hZ,i3+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gJ[#gJ+1]=bV(hZ,i3+20,"Follow Mode Engaged","warn")elseif Reentry or an then gJ[#gJ+1]=bV(hZ,i3+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ik=c3(HoldAltitude,2)if VertTakeOff then if bh then ik=c3(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gJ[#gJ+1]=bV(hZ,i3,"VTO to "..ik,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gJ[#gJ+1]=bV(hZ,i3,"Takeoff to "..AutopilotTargetName,"warn")else gJ[#gJ+1]=bV(hZ,i3,"Takeoff to "..ik,"warn")end;if BrakeIsOn and not VertTakeOff then gJ[#gJ+1]=bV(hZ,i3+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gJ[#gJ+1]=bV(hZ,i3,"Altitude Hold: "..ik,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gJ[#gJ+1]=bV(hZ,i3+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gJ[#gJ+1]=bV(hZ,i3+20,"Aligning trajectory","warn")elseif ar<0.05 then gJ[#gJ+1]=bV(hZ,i3+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b0~=nil then gJ[#gJ+1]=bV(hZ,i3,b0,"warn")end end;if BrakeLanding then if StrongBrakes then gJ[#gJ+1]=bV(hZ,i3,"Brake-Landing","warnings")else gJ[#gJ+1]=bV(hZ,i3,"Coast-Landing","warnings")end end;if ProgradeIsOn then gJ[#gJ+1]=bV(hZ,i3,"Prograde Alignment","crit")end;if RetrogradeIsOn then gJ[#gJ+1]=bV(hZ,i3,"Retrograde Alignment","crit")end;local is="#110000"local it=i6;local iu=i8;if bs then is="#FF0000"it=i7;iu=i9;local type;if string.find(bs,"COLLISION")then type="warnings"else type="crit"end;gJ[#gJ+1]=bV(hZ,i4+20,bs,type)elseif ar==0 then local iv,iw=aR.checkLOS(bb:normalize())if iw~=nil then iu=i9;is="#FF0000"it=i7;local ik=c3(iw)local travelTime=aM.computeTravelTime(bc,0,iw)local ix="Collision"if iv.noAtmosphericDensityAltitude>0 then ix="Atmosphere"end;gJ[#gJ+1]=bV(hZ,i4+20,iv.name.." "..ix.." "..c6(travelTime).." In "..ik,"crit")end end;if VectorToTarget and not IntoOrbit then gJ[#gJ+1]=bV(hZ,i3+35,VectorStatus,"warn")end;local iy="#111100"local iz=i6;local iA=i8;if bz and#bz>1 then iy="#DDDD00"iz=i7;iA=i9 end;local iB=g1;local iC=g2;local i8="topButton"local iD="topButtonActive"local iE=i8;if Autopilot or VectorToTarget or am or IntoOrbit then iE=iD end;local iF=i8;if ProgradeIsOn then iF=iD end;local iG=i8;if BrakeLanding or GearExtended then iG=iD end;local iH=i8;if AltitudeHold or VectorToTarget then iH=iD end;local iI=i8;if RetrogradeIsOn then iI=iD end;local iJ=i8;if IntoOrbit or b3 and Autopilot then iJ=iD end;local iK=iC(30)gJ[#gJ+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iE,iB(960),iC(54),iC(-53),iB(-120),iB(25),iC(50))gJ[#gJ+1]=bV(iB(910),iK,"AUTOPILOT")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iF,iB(865),iC(51),iB(-25),iC(-50),iB(-110),iB(25),iC(46))gJ[#gJ+1]=bV(iB(800),iK,"PROGRADE")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iG,iB(755),iC(47),iB(-25),iC(-46),iB(-98),iB(44),iC(44))gJ[#gJ+1]=bV(iB(700),iK,"LAND")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iH,iB(960),iC(54),iC(-53),iB(120),iB(-25),iC(50))gJ[#gJ+1]=bV(iB(1010),iK,"ALT HOLD")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iI,iB(1055),iC(51),iB(25),iC(-50),iB(110),iB(-25),iC(46))gJ[#gJ+1]=bV(iB(1122),iK,"RETROGRADE")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iJ,iB(1165),iC(47),iB(25),iC(-46),iB(98),iB(-44),iC(44))gJ[#gJ+1]=bV(iB(1220),iK,"ORBIT")gJ[#gJ+1]=[[
                                </g>
                            </g>]]gJ[#gJ+1]="</g>"return gJ end;local function iL(e6)return e(A(e6*3.6,0)+0.5).." km/h"end;local function iM(gJ)local bW=OrbitMapX+10;local bX=OrbitMapY+20;local iN={}local iO={"Alt-4: AutoTakeoff to Target"}local iP={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iQ={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iR={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iN,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then bL(iN,iO)if ac and planet and ac.name==planet.name then table.insert(iN,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bh then table.insert(iN,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iN,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iN,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iN,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iN,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iN,"G: Takeoff to hover height, raise gear")else table.insert(iN,"G: Lowergear and Land")end else bL(iN,iP)table.insert(iN,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iN,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bL(iN,iQ)if shield_1 then table.insert(iN,"Alt-Shift-5: Toggle shield off and on")table.insert(iN,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iN,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iN,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iN,"Alt-Spacebar/C will raise/lower target height")table.insert(iN,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iN,"LALT+Mousewheel will lower/raise speed limit")end;bL(iN,iR)for i=1,#iN do bX=bX+12;gJ[#gJ+1]=bV(bW,bX,iN[i],"pdim txtbig txtstart")end end;local function iS(gJ)local iT=OrbitMapX;local iU=OrbitMapY;local iV=OrbitMapSize;local iW=4;local iX=15;local bW=0;local bX=0;local iY,iZ,i_,j0;local j1;local function j2(type)local j3,E,e6,j4,bZ,j5;if type=="Periapsis"then j3=j1.periapsis.altitude;E=j1.timeToPeriapsis;e6=j1.periapsis.speed;bZ="txtend"j4=12;j5=math.min(bW,iT+iV-planet.radius/i_-iW*2)else j3=j1.apoapsis.altitude;E=j1.timeToApoapsis;e6=j1.apoapsis.speed;j4=-12;bZ="txtstart"j5=bW end;if bc<1 then E=0 end;gJ[#gJ+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j5+j4,bX-5,bW,bX-5)gJ[#gJ+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j5-j4*4,bX+2,bW,bX+2)gJ[#gJ+1]=bV(j5,bX,type,bZ)bW=j5-j4*2;bX=bX+iX;local ik=c3(j3)gJ[#gJ+1]=bV(bW,bX,ik,bZ)bX=bX+iX;gJ[#gJ+1]=bV(bW,bX,c6(E),bZ)bX=bX+iX;gJ[#gJ+1]=bV(bW,bX,iL(e6),bZ)end;local j6=iV*1.5;if SelectedTab=="INFO"then j6=25*7 end;if SelectedTab~="HIDE"then gJ[#gJ+1]=[[<g class="pbright txtorb txtmid">]]gJ[#gJ+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',iV*2,j6,iT,iU)gJ[#gJ+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],iV*2,j6,iT,iU)end;local j7=iV*1.5;local j8=iV*2;local j9=j7/2;local ja=iV;local jb=iT+ja;local jc=iU+j9;local jd=iT+j8;local je=iU+j7;if SelectedTab=="ORBIT"then iU=iU+iW;iY=iV/2;j0=0;j1={}j1.periapsis={}j1.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then j1.periapsis.altitude=orbit.periapsis.altitude;j1.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then j1.apoapsis.altitude=orbit.apoapsis.altitude;j1.apoapsis.speed=orbit.apoapsis.speed end;j1.period=orbit.period;j1.eccentricity=orbit.eccentricity;j1.timeToApoapsis=orbit.timeToApoapsis;j1.timeToPeriapsis=orbit.timeToPeriapsis;j1.eccentricAnomaly=orbit.eccentricAnomaly;j1.trueAnomaly=orbit.trueAnomaly end;if j1.periapsis==nil then j1.periapsis={}j1.periapsis.altitude=-planet.radius;j1.periapsis.speed=MaxGameVelocity end;if j1.eccentricity==nil then j1.eccentricity=1 end;if j1.apoapsis==nil then j1.apoapsis={}j1.apoapsis.altitude=as;j1.apoapsis.speed=0 end;if bc<1 then j1.apoapsis.altitude=as;j1.apoapsis.speed=0 end;if j1.apoapsis.altitude then i_=(j1.apoapsis.altitude+j1.periapsis.altitude+planet.radius*2)/(iY*2)iZ=(planet.radius+j1.apoapsis.altitude)/i_*(1-j1.eccentricity)j0=iY-j1.periapsis.altitude/i_-planet.radius/i_;local jf=math.pi;if j1.period~=nil and j1.period>0 and j1.timeToApoapsis~=nil then jf=j1.eccentricAnomaly;if j1.timeToPeriapsis<j1.timeToApoapsis then jf=2*math.pi-jf end end;if bc<1 or jf~=jf then jf=math.pi end;local jg=-iY*math.cos(jf)+iT+ja+iW;local jh=iZ*math.sin(jf)+iU+j9+iW;local ji=""gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'gJ[#gJ+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ji,iT+iV+iW,iU+iV*1.5/2+iW,iY,iZ)if iZ<1 then gJ[#gJ+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iT+iV+iW-j0,iU+iV*1.5/2+iW,jg,jh)end;gJ[#gJ+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iT+iV+iW-j0,iU+iV*1.5/2+iW,(planet.radius+planet.noAtmosphericDensityAltitude)/i_)gJ[#gJ+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iT+iV+iW-j0,iU+iV*1.5/2+iW,(planet.radius+planet.noAtmosphericDensityAltitude)/i_)gJ[#gJ+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iT+iV+iW,iU+iV*1.5/2+iW,iY,iZ)gJ[#gJ+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iT+iV+iW-j0,iU+iV*1.5/2+iW,planet.radius/i_)gJ[#gJ+1]='</g>'local jj=math.floor(planet.radius/i_+0.5)local jk=g6.Generic_Moon;if g6[planet.name]then jk=g6[planet.name]end;bW=iT+iV+iW*4+iY;bX=iU+iV*1.5/2+5+iW;if j1.apoapsis~=nil and j1.apoapsis.speed<MaxGameVelocity then j2("Apoapsis")end;bX=iU+iV*1.5/2+5+iW;bW=iT+iV-iW*2-iY;if j1.periapsis~=nil and j1.periapsis.speed<MaxGameVelocity and j1.periapsis.altitude>0 then j2("Periapsis")end;gJ[#gJ+1]=bV(iT+iV+iW,iU+20+iW,planet.name,"txtorbbig")gJ[#gJ+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jg,jh)gJ[#gJ+1]=[[</g>]]return gJ else gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'local jl=""local jm=1.2*(maxAtlasX-minAtlasX)/(iV*2)local jn=1.4*(maxAtlasY-minAtlasY)/(iV*1.5)for cf,cg in pairs(b[0])do if cg.center then local bW=iT+iV+cg.center.x/jm;local bX=iU+iV*1.5/2+cg.center.y/jn;jl=jl..'<circle cx="'..bW..'" cy="'..bX..'" r="'..cg.radius/jm*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(cg.name,"Moon")and not string.match(cg.name,"Sanctuary")and not string.match(cg.name,"Space")then jl=jl.."<text x='"..bW.."' y='"..bX+cg.radius/jm*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..cg.name.."</text>"end end end;local ea=vec3(core.getConstructWorldPos())local bW=iT+iV+ea.x/jm;local bX=iU+iV*1.5/2+ea.y/jn;jl=jl..'<circle cx="'..bW..'" cy="'..bX..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jl=jl.."<text x='"..bW.."' y='"..bX-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fO=jm;fP=jn;local jo=ea+bb*1000000;local jp=iT+iV+jo.x/jm;local gw=iU+iV*1.5/2+jo.y/jn;jl=jl..'<line x1="'..bW..'" y1="'..bX..'" x2="'..jp..'" y2="'..gw..'" stroke="purple" stroke-width="1"/>'gJ[#gJ+1]=jl;gJ[#gJ+1]='</g>'end elseif SelectedTab=="INFO"then gJ=aP.DrawOdometer(gJ,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then gJ=iM(gJ)elseif SelectedTab=="SCOPE"then gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'local jq=bC;if ar>0 then table.sort(bB,function(dj,dk)local c1,c2=dj.center,dk.center;return(c1.x-bf.x)^2+(c1.y-bf.y)^2+(c1.z-bf.z)^2<(c2.x-bf.x)^2+(c2.y-bf.y)^2+(c2.z-bf.z)^2 end)end;local eD={}local jr={}local js=120;local jt=nil;local ju=nil;for i,cg in ipairs(bB)do local eC=cg.center-bf;local jv=eC:len()local jw=eC:normalize()local jx=eC:cross(b8):normalize()local jy=math.acos(jx:dot(b9))if jy~=jy then jy=0 end;if jx:cross(b9):dot(b8)<0 then jy=-jy end;local jz=eC:project_on_plane(b8):len()local jA=math.sin(jy)*math.asin(jz/jv)*constants.rad2deg;local jB=math.cos(jy)*math.asin(jz/jv)*constants.rad2deg;if jw:dot(b8)<0 then jB=90*math.cos(jy)+90*math.cos(jy)-jB;jA=90*math.sin(jy)+90*math.sin(jy)-jA end;local bW=jb+jA/jq*j7;local bX=jc+jB/jq*j7;local jC=(bW-jb)*(bW-jb)+(bX-jc)*(bX-jc)local jD=math.asin((cg.radius+cg.surfaceMaxAltitude)/jv)*constants.rad2deg;if jD~=jD then jD=jq end;local fv=jD/jq*j7;local jE=math.asin(cg.atmosphereRadius/jv)*constants.rad2deg;if jE~=jE then jE=jD end;local jF=jE/jq*j7;local aj=c3(jv,1)local jG=cg.name;local jH=false;if bX>iU then if bX>je then if bX-jF<=je then jH=true end else jH=true end else if bX+jF>=iU then jH=true end end;local jI=false;local jJ=bW;if cg.systemId==0 then jJ=bW+js else jJ=bW-js end;if jJ+js>iT then if jJ+js>jd then if jJ-jF-js<=jd then jI=true end else jI=true end else if jJ+jF+js>=iT then jI=true end end;local jK={}jK.x=bW;jK.y=bX;jK.planet=cg;jK.atmoSize=jF;if not jt or jC<jt then jt=jC;ju=jK end;if jI and jH then local jL=math.max(jF,5)if jC<jL*jL then jG=jG.." - "..aj end;jK.size=fv;jK.i=i;jK.displayString=jG;jK.distance=aj;jK.visible=true;jr[#jr+1]=jK else jK.visible=false end end;local jM=false;table.sort(jr,function(c1,c2)return c1.y<c2.y end)for cf,ed in ipairs(jr)do local cg,fv,i,jF,bW,bX,jG,aj=ed.planet,ed.size,ed.i,ed.atmoSize,ed.x,ed.y,ed.displayString,ed.distance;local j5,jN,jO,jP;local jQ=15;local bZ="pdim"if cg.systemId~=0 then jO=g1(string.len(jG)*5)jQ=-(15+jO)jP=g2(10)bZ="pdimfill"else jO=g1(string.len(jG)*9)jP=g2(15)end;if fv*2>jO then j5=r(bW,iT+jO/2,jd-jO/2)jN=r(bX,iU+jP,je-5)j5=r(j5,bW-fv+jO/2,bW+fv-jO/2)jN=r(jN,bX-fv+jP,bX+fv)else j5=bW+jQ;jN=bX end;for jR,ed in pairs(eD)do local jS=ed.textPositions;local jT=jS.y-jN;if jR~=i and d(jT)<jS.height and jS.x+jS.width>j5 and jS.x<j5+jO then if fv>jO then jN=r(jN+jP,iU+15,je-5)else jN=jS.y+jS.height+1 end end end;local jU=jG~=cg.name or j5<=jb and j5+jO>=jb and jN-jP<=jc and jN>=jc;ed.hovered=jU;local jV=1;if jU then jV=2;if fv*2<jO then jV=10 end;if jG==cg.name then jG=jG.." - "..aj end;bZ="pbright"if cg.systemId~=0 then jO=g1(string.len(jG)*5)jQ=-(15+jO)else jO=g1(string.len(jG)*7)end;if fv*2>jO then j5=r(bW,iT+jO/2,jd-jO/2)j5=r(j5,bW-fv+jO/2,bW+fv-jO/2)else j5=bW+jQ end;if not Autopilot and not VectorToTarget and not am and not IntoOrbit and not Reentry and not an and not jM then jM=true;if AutopilotTargetName~=cg.name then for jW,cJ in ipairs(bm)do if cJ.index==cg.id then AutopilotTargetIndex=jW;aQ.UpdateAutopilotTarget()break end end end end end;eD[i]={}eD[i].textPositions={}eD[i].textPositions.y=jN;eD[i].textPositions.x=j5;eD[i].textPositions.width=jO;eD[i].textPositions.height=jP;eD[i].output=""if fv*2>jO then bZ=bZ.." txtmid"else bZ=bZ.." txtstart"end;if jF-fv>2 then eD[i].output=f('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',bW,bX,jF,az,0.1*jV)end;eD[i].output=eD[i].output..f('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',bW,bX,fv,az,0.2*jV)if cg.systemId==0 then eD[i].output=eD[i].output..f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j5,jN,ay,bZ,jG)if fv*2<=jO then eD[i].output=eD[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j5+jO,jN+2,j5,jN+2,bW,bX)end else eD[i].output=eD[i].output..f([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j5,jN,az,bZ,jG)if fv*2<=jO then eD[i].output=eD[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j5,jN+2,j5+jO,jN+2,bW,bX)end end end;for cf=#bB,1,-1 do if eD[cf]then gJ[#gJ+1]=eD[cf].output end end;if ju~=nil and bC<90 and not ju.hovered then local jX=ju.planet.atmosphereRadius/ju.atmoSize;local jY=y(jt)*jX;local jZ=c3(jY,1)local jO=g1(math.max(string.len(jZ)*7,string.len(ju.planet.name)*7))local jP=g2(12)local j5=r(ju.x+(jb-ju.x)/2,iT+jO/2,jd-jO/2)local jN=r(ju.y+(jc-ju.y)/2,iU+jP*2,je-5)gJ[#gJ+1]=f("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",ju.x,ju.y,jb,jc)gJ[#gJ+1]=f([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j5,jN,"white",jZ)if not ju.visible then gJ[#gJ+1]=f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j5,jN-jP,"white",ju.planet.name)end end;if bc>1 then local eC=bb;local jw=eC:normalize()local jz=eC:project_on_plane(b8):len()local jx=eC:cross(b8):normalize()local jy=math.acos(jx:dot(b9))if jy~=jy then jy=0 end;if jx:cross(b9):dot(b8)<0 then jy=-jy end;local jA=math.sin(jy)*math.asin(jz/eC:len())*constants.rad2deg;local jB=math.cos(jy)*math.asin(jz/eC:len())*constants.rad2deg;if jw:dot(b8)<0 then jB=90*math.cos(jy)+90*math.cos(jy)-jB;jA=90*math.sin(jy)+90*math.sin(jy)-jA end;local bW=jb+jA/jq*j7;local bX=jc+jB/jq*j7;local hF=14;local hG=hF/2;local hJ=[[<circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hG/hF..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bW-hF..[[,]]..bX..[[ h ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bW+hG..[[,]]..bX..[[ h ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bW..[[,]]..bX-hF..[[ v ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]gJ[#gJ+1]=hJ end;gJ[#gJ+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jb,jc-10,jb,jc+10)gJ[#gJ+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jb-10,jc,jb+10,jc)gJ[#gJ+1]='</g>'else return gJ end end;local function j_(k0,k1)local k2;local k3=(k1-k0):normalize()local eb=(bf-k0):dot(k3)/k3:dot(k3)if eb<=0.then return(bf-k0):len()elseif eb>=(k1-k0):len()then return(bf-k1):len()end;local k4=k0+eb*k3;k2=(k4-bf):len()return k2 end;local function k5()local k2;local k6=nil;local k7=nil;local k8=nil;for cf,k9 in pairs(b[0])do if k9.hasAtmosphere then local aj=j_(planet.center,k9.center)if k6==nil or aj<k6 then k7=k9;k6=aj;k8=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dx=j_(ac.center,k9.center)if dx<k6 then k7=k9;k6=dx;k8=ac end end end end;local ka=g1(1770)local kb=g2(330)if k6 then local kc="txttick "local kd=500000;if k6<k7.radius+kd or k6<k8.radius+kd then if bn then kc="txttick red "else kc="txttick orange "end end;k2=c3(k6,2)fT=bV(ka,kb,"Pipe ("..k8.name.."--"..k7.name.."): "..k2,kc.."pbright txtmid")end end;local function ke(bW,bX,kf,kg,hS)local kh={x=bW,y=bX,width=kf,height=kg,label=hS}by[hS]=kh;return kh end;local function ki(kj,kk,kf,kg,bW,bX,kl,km,kn,ko,bZ)local kh={enableName=kj,disableName=kk,width=kf,height=kg,x=bW,y=bX,toggleVar=kl,toggleFunction=km,drawCondition=kn,hovered=false,class=bZ}if ko then table.insert(fN,kh)else table.insert(fM,kh)end;return kh end;local function kp(kq)if not fR then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif kq=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif kq=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif kq=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fS=bO(kq)showHud=false else fS={}showHud=true end end;local function kr()fR=not fR;if fR then fL=fN;a2="Hold SHIFT to see Settings"bD=showHud else fL=fM;a2="Hold SHIFT to see Control Buttons"kp()showHud=bD end end;local function ks()local function kt(cg)_G[cg]=not _G[cg]if _G[cg]then a2=cg.." set to true"else a2=cg.." set to false"end;if cg=="showHud"then bD=_G[cg]elseif cg=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local ku=50;local kv=340;local bW=500;local bX=aE/2-400;local kw=0;for cf,cg in pairs(bO("boolean"))do if type(_G[cg])=="boolean"then ki(cg,cg,kv,ku,bW,bX,function()return _G[cg]end,function()kt(cg)end,function()return true end,true)bX=bX+ku+20;if kw==9 then bW=bW+kv+20;bX=aE/2-400;kw=0 else kw=kw+1 end end end;ki("Control View","Control View",kv,ku,10,aE/2-500,function()return true end,kr,function()return true end,true)ki("View Handling Settings",'Hide Handling Settings',kv,ku,10,aE/2-(500-ku),function()return showHandlingVariables end,function()kp("handling")end,function()return true end,true)ki("View Hud Settings",'Hide Hud Settings',kv,ku,10,aE/2-(500-ku*2),function()return showHudVariables end,function()kp("hud")end,function()return true end,true)ki("View Physics Settings",'Hide Physics Settings',kv,ku,10,aE/2-(500-ku*3),function()return showPhysicsVariables end,function()kp("physics")end,function()return true end,true)end;local function kx()local function ky()local position=bf;local fy=planet.name..". "..#SavedLocations;if bu[1]then local cJ,_=bu[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cJ~=nil and cJ~=""then fy=fy.." "..bu[1].getConstructName(cJ)end end;return aQ.AddNewLocation(fy,position,false,true)end;local function kz()TurnBurn=not TurnBurn end;local function kA(kB)if kB==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kC()aQ.UpdatePosition()end;local function kD()aQ.ClearCurrentPosition()end;local function kE(fj)local fy=AutopilotTargetName;if fj~=nil and type(fj)=="number"then if fj==0 then return"None"end;fy=bm[fj].name end;if fy==nil then fy=CustomTarget.name end;if fy==nil then fy="None"end;return fy end;local function kF(fj)return"Engage Autopilot: "..kE(fj)end;local function kG(fj)return"Disable Autopilot: "..kE(fj)end;local function kH()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bI("folOn","F")else bI("folOff","F")BrakeIsOn=true;aV=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local ku=50;local kv=260;local kI=g1(30)local kJ=OrbitMapX+OrbitMapSize*2+2;local kK=OrbitMapY+1;ki("+","+",kI,kI,kJ,kK+kI+1,function()return false end,function()bC=bC/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")ki("-","-",kI,kI,kJ,kK,function()return false end,function()bC=math.min(bC*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")ki("0","0",kI,kI,kJ,kK+kI*2+2,function()return false end,function()bC=90 end,function()return SelectedTab=="SCOPE"and bC~=90 end,nil,"ZoomButton")local kL=ki("Enable Brake Toggle","Disable Brake Toggle",kv,ku,aD/2-kv/2,aE/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)ki("Align Prograde","Disable Prograde",kv,ku,aD/2-kv/2-50-kL.width,aE/2-ku+380,function()return ProgradeIsOn end,function()kA(1)end)ki("Align Retrograde","Disable Retrograde",kv,ku,aD/2-kv/2+kL.width+50,aE/2-ku+380,function()return RetrogradeIsOn end,kA,function()return ar==0 end)apbutton=ki(kF,kG,600,60,aD/2-600/2,aE/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function kM(kN)local fj=bx+kN;if fj>#bm then fj=fj-#bm-1 end;if fj<0 then fj=#bm+fj end;return fj end;apExtraButtons={}for i=0,10 do local button=ki(function(c2)local fj=kM(c2.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..kE(fj)end;return kF(fj)end,function(c2)local fj=kM(c2.apExtraIndex)return kG(fj)end,600,60,aD/2-600/2,aE/2-60/2-330+60*i,function(c2)local fj=kM(c2.apExtraIndex)return fj==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(c2)local fj=kM(c2.apExtraIndex)local kO=AutopilotTargetIndex==fj;AutopilotTargetIndex=fj;aQ.UpdateAutopilotTarget()aR.ToggleAutopilot()if not kO and not(Autopilot or VectorToTarget or am or IntoOrbit)then aR.ToggleAutopilot()end end,function()return bw end)button.apExtraIndex=i;apExtraButtons[i]=button end;ki("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,ky,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)ki("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kC,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ki("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kD,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ku=60;kv=300;local bW=0;local bX=aE/2-150;ki("View Settings","View Settings",kv,ku,bW,bX,function()return true end,kr)bX=bX+ku+20;ki("Enable Turn and Burn","Disable Turn and Burn",kv,ku,bW,bX,function()return TurnBurn end,kz)bW=10;bX=aE/2-300;ki("Horizontal Takeoff Mode","Vertical Takeoff Mode",kv,ku,bW+kv+20,bX,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bg end)bX=bX+ku+20;ki("Engage Orbiting","Cancel Orbiting",kv,ku,bW+kv+20,bX,function()return IntoOrbit end,aR.ToggleIntoOrbit,function()return ar==0 and br end)bX=aE/2-150;ki("Glide Re-Entry","Cancel Glide Re-Entry",kv,ku,bW+kv+20,bX,function()return Reentry end,function()al=1;kA(1)end,function()return planet.hasAtmosphere and not aq end)bX=bX+ku+20;ki("Parachute Re-Entry","Cancel Parachute Re-Entry",kv,ku,bW+kv+20,bX,function()return Reentry end,aR.BeginReentry,function()return planet.hasAtmosphere and not aq end)bX=bX+ku+20;ki("Engage Follow Mode","Disable Follow Mode",kv,ku,bW,bX,function()return a0 end,kH,function()return m()==1 end)ki("Enable Repair Arrows","Disable Repair Arrows",kv,ku,bW+kv+20,bX,function()return aJ end,function()aJ=not aJ;if aJ then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)bX=bX+ku+20;if not ExternalAGG then ki("Enable AGG","Disable AGG",kv,ku,bW,bX,function()return bh end,aR.ToggleAntigrav,function()return antigrav~=nil end)end;ki(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,kv*2,ku,bW,bX,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)bX=bX+ku+20;ki(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,kv*2,ku,bW,bX,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local kP=g2(20)local button=ke(0,0,g1(70),kP,"HELP")button=ke(button.x+button.width,button.y,g1(80),kP,"INFO")button=ke(button.x+button.width,button.y,g1(70),kP,"ORBIT")button=ke(button.x+button.width,button.y,g1(70),kP,"SCOPE")ke(button.x+button.width,button.y,g1(70),kP,"HIDE")end;local kQ={}local kR=nil;function kQ.HUDPrologue(gJ)bn,bo=f_(bf)if not bn then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.6)..","..e(J+0.6)..","..e(I+0.6)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kS=ay;local kT=az;local kU=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.4+0.5)..[[)]]local kV=ay;local kW=az;local kX=kU;if g3()and not brightHud then kS=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kT=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]kU=[[rgb(]]..e(H*0.2+0.5)..","..e(J*0.2+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iB=g1;local iC=g2;gJ[#gJ+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .pdimfill {fill: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                    <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="1"/>
                                    </radialGradient>
                                    <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="66%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/>
                                    </radialGradient>                            
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kS,kS,kS,kV,kV,kT,kT,kW,kW,kT,kS,kU,kW,kS,kS,kU,kU,kX,kU,aD,aE,kT,kT,kT,kT,kT,kV,kT,kW,kX,kW,kW,kX)if not kR then kR=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iB(630),iC(0),iB(675),iC(45),iB(960),iC(55),iB(1245),iC(45),iB(1290),iC(0),iB(1000),iC(105),iB(1040),iC(59),iB(1250),iC(51),iB(1300),iC(0),iB(1920),iC(0),iB(1920),iC(20),iB(1400),iC(20),iB(1300),iC(105),iB(920),iC(105),iB(880),iC(59),iB(670),iC(51),iB(620),iC(0),iB(0),iC(0),iB(0),iC(20),iB(520),iC(20),iB(620),iC(105),iB(890),iC(59),iB(960),iC(62),iB(1030),iC(59),iB(985),iC(112),iB(1150),iC(112),iB(1100),iC(152),iB(820),iC(152),iB(780),iC(112),iB(935),iC(112),iB(890),iC(59),iB(960),iC(62),iB(1030),iC(59),iB(985),iC(112),iB(1150),iC(112),iB(1100),iC(152),iB(820),iC(152),iB(780),iC(112),iB(935),iC(112))end;gJ[#gJ+1]=kR;return gJ end;function kQ.DrawVerticalSpeed(gJ,cR)gI(gJ,cR)end;function kQ.UpdateHud(gJ)local hy=bk;local kY=bl;local gR=kY;local h5=hy;local hQ=e(unit.getThrottle())local hV=bc*3.6;local hR=unit.getAxisCommandValue(0)local kZ=g1(1770)local k_=g2(310)if AtmoSpeedAssist and bj then hR=K;hQ=K*100 end;local g5=g4()local gS="ROLL"if hQ==nil then hQ=0 end;if not br then if bc>5 then hy=hx(ba)kY=hz(ba)else hy=0;kY=0 end;gS="YAW"end;if bo>50000 and not aq then local l0;l0=c3(bo)gJ[#gJ+1]=bV(kZ,k_,"PvP Boundary: "..l0,"pbright txtbig txtmid")end;gJ[#gJ+1]=ak;gJ[#gJ+1]=aB;gJ[#gJ+1]=g7;if fT~=""then gJ[#gJ+1]=fT end;if g8~=""then gJ[#gJ+1]=g8 end;if g9~=""then gJ[#gJ+1]=g9 end;gI(gJ,as)if m()==0 or RemoteHud then if br then gQ(gJ,centerX,centerY,gR,gS,br)else gQ(gJ,centerX,centerY,kY,gS,br)end;if not g3()or brightHud then if br then gQ(gJ,centerX,centerY,gR,gS,br)h4(gJ,h5,gR,centerX,centerY,br,e(hz(ba)),bc)else gQ(gJ,centerX,centerY,kY,gS,br)h4(gJ,hy,kY,centerX,centerY,br,e(kY),bc)end;hb(gJ,as,br)hA(gJ,ba,bc,centerX,centerY)end end;hP(gJ,g5,hQ,hR)hU(gJ,hV)hY(gJ)iS(gJ)return gJ end;function kQ.HUDEpilogue(gJ)gJ[#gJ+1]="</svg>"return gJ end;function kQ.ExtraData(gJ)local l1=g1(1240)local l2=g2(55)local l3=l2+10;local l4;local iB=g1;local iC=g2;local l5=0;local g5=g4()if VertTakeOffEngine then g5=g5 .."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bc>20 then g5=g5 .."-COLLISION ON"end;if UseExtra~="Off"then g5="("..UseExtra..")-"..g5 end;if TurnBurn then g5="TB-"..g5 end;if not stablized then g5=g5 .."-DeCoupled"end;local l6=iC(99)local l7=iC(80)local l8=iC(85)local l9=iC(31)local la=0;local lb=0;local lc=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then l5=LastMaxBrakeInAtmo else l5=LastMaxBrake end;local ld,le=aM.computeDistanceAndTime(bc,0,av,0,0,l5)if ld<0 then ld=0 end;l5=A(l5/(av*fK),2).."g"local lf=a:maxForceForward()l4=core.g()if l4>0.1 then lb=av*l4;lb=A(lb/(av*fK),2).."g"la=0.5*lf/l4;la=la>1000000 and A(la/1000000,2).."kT"or A(la/1000,2).."T"end;lf=A(lf/(av*fK),2).."g"local lg=vec3(core.getWorldAcceleration()):len()/9.80665;l4=core.g()gJ[#gJ+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then l1=g1(1120)l2=g2(55)l3=l2+10 elseif aq then local lh=g1(770)gJ[#gJ+1]=bV(iB(895),l6,"ATMO","")gJ[#gJ+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iB(895),l8,iB(-80))gJ[#gJ+1]=bV(iB(815),l7,f("%.1f%%",ar*100),"txtstart size20")end;gJ[#gJ+1]=bV(iB(1025),l6,"GRAVITY","txtstart")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1025),l8,iB(80))gJ[#gJ+1]=bV(iB(1105),l7,f("%.2fg",l4/9.80665),"size20")gJ[#gJ+1]=bV(iB(1125),l6,"ACCEL","txtstart")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1125),l8,iB(80))gJ[#gJ+1]=bV(iB(1205),l7,f("%.2fg",lg),"size20")gJ[#gJ+1]=bV(iB(695),l6,"BRK TIME","")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(695),l8,iB(-80))gJ[#gJ+1]=bV(iB(615),l7,f("%s",c6(le)),"txtstart size20")gJ[#gJ+1]=bV(iB(635),iC(45),"TRIP","")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(635),iC(31),iB(-90))if travelTime then gJ[#gJ+1]=bV(iB(532),iC(23),f("%s",c6(travelTime)),"txtstart size20")end;gJ[#gJ+1]=bV(iB(795),l6,"BRK DIST","")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(795),l8,iB(-80))gJ[#gJ+1]=bV(iB(715),l7,f("%s",c3(ld)),"txtstart size20")gJ[#gJ+1]=bV(iB(1285),iC(45),"MASS","txtstart")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1285),iC(31),iB(90))gJ[#gJ+1]=bV(iB(1388),iC(23),f("%s",lc),"size20")gJ[#gJ+1]=bV(iB(1220),l6,"THRUST","txtstart")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1220),l8,iB(80))gJ[#gJ+1]=bV(iB(1300),l7,f("%s",lf),"size20")gJ[#gJ+1]=bV(g1(960),g2(175),g5,"pbright txtbig txtmid size20")gJ[#gJ+1]="</g>"end;function kQ.DrawOdometer(gJ,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return gJ end;local l4;local la=0;local lb=0;local l5=0;local lc=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then l5=LastMaxBrakeInAtmo else l5=LastMaxBrake end;local ld,le=aM.computeDistanceAndTime(bc,0,av,0,0,l5)l5=A(l5/(av*fK),2).." g"local lf=a:maxForceForward()l4=core.g()if l4>0.1 then lb=av*l4;lb=A(lb/(av*fK),2).." g"la=0.5*lf/l4;la=la>1000000 and A(la/1000000,2).." kTons"or A(la/1000,2).." Tons"end;lf=A(lf/(av*fK),2).." g"if m()==0 or RemoteHud then local li=g1(OrbitMapX+10)local lj=g2(OrbitMapY+20)local lk=g1(OrbitMapX+10+OrbitMapSize/1.25)local kg=25;gJ[#gJ+1]="<g class='txtstart size14 bright'>"gJ[#gJ+1]=bV(li,lj,f("BrkTime: %s",c6(le)))gJ[#gJ+1]=bV(lk,lj,f("Trip: %.2f km",ad))gJ[#gJ+1]=bV(li,lj+kg,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gJ[#gJ+1]=bV(lk,lj+kg,f("BrkDist: %s",c3(ld)))gJ[#gJ+1]=bV(li,lj+kg*2,"Trip Time: "..c6(ae))gJ[#gJ+1]=bV(lk,lj+kg*2,"Total Time: "..c6(TotalFlightTime))gJ[#gJ+1]=bV(li,lj+kg*3,f("Mass: %s",lc))gJ[#gJ+1]=bV(lk,lj+kg*3,f("Max Brake: %s",l5))gJ[#gJ+1]=bV(li,lj+kg*4,f("Max Thrust: %s",lf))if l4>0.1 then gJ[#gJ+1]=bV(lk,lj+kg*4,f("Max Thrust Mass: %s",la))gJ[#gJ+1]=bV(li,lj+kg*5,f("Req Thrust: %s",lb))else gJ[#gJ+1]=bV(lk,lj+kg*5,"Max Mass: n/a")gJ[#gJ+1]=bV(li,lj+kg*6,"Req Thrust: n/a")end end;gJ[#gJ+1]="</g></g>"return gJ end;function kQ.DrawWarnings(gJ)return hY(gJ)end;function kQ.DisplayOrbitScreen(gJ)return iS(gJ)end;function kQ.DisplayMessage(gJ,ik)if ik~="empty"then local bX=310;for ll in string.gmatch(ik,"([^\n]+)")do bX=bX+35;gJ[#gJ+1]=bV("50%",bX,ll,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function kQ.DrawDeadZone(gJ)gJ[#gJ+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kQ.UpdatePipe()if aq then fT=""return end;k5()end;function kQ.DrawSettings(gJ)if#fS>0 then local bW=g1(640)local bX=g2(200)gJ[#gJ+1]=[[<g class="pbright txtvspd txtstart">]]for cf,cg in pairs(fS)do gJ[#gJ+1]=bV(bW,bX,cg..": ".._G[cg])bX=bX+20;if cf%12==0 then bW=bW+g1(350)bX=g2(200)end end;gJ[#gJ+1]=bV(g1(640),g2(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gJ[#gJ+1]="</g>"end;return gJ end;local lm;local ln=g1(1770)local lo=g2(350)local lp=g2(15)local lq=g1(1370)local bE,lr;local ls=0;function kQ.DrawRadarInfo()local function lt()if radarPanelID~=nil and ls==0 then t(radarPanelID)radarPanelID=nil;if lm~=nil then t(lm)lm=nil end else if ls==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bu,1,"Periscope","periscope")lm=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bu,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;ls=0 end end;local eC,eD,eB,eE,eF,ey=aS.GetRadarHud()local B=eE or 0;if eB>0 then if CollisionSystem then bE=B.."/"..eF.." Plotted : "..eB-eF.." Ignored"else bE="Radar Contacts: "..eB end;g7=bV(ln,lo,bE,"pbright txtbig txtmid")if#ey>0 then g7=g7 ..bV(lq,lp,"Friendlies In Range","pbright txtbig txtmid")for cf,cg in pairs(ey)do lp=lp+20;g7=g7 ..bV(lq,lp,bu[1].getConstructName(cg),"pdim txtmid")end end;if eC==nil and lm==nil then ls=1;lt()end;if eC~=nil and lm~=nil then lt()end;if radarPanelID==nil then lt()end else if eD then g7=bV(ln,lo,bv.." Radar: Jammed","pbright txtbig txtmid")else g7=bV(ln,lo,"Radar: No "..bv.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ls=0;lt()end end end;function kQ.DrawTanks()if fuelX~=0 and fuelY~=0 then g8=bV(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gp(fuelX,"Atmospheric ","ATMO",aF,gn,go)gp(fuelX,"Space Fuel T","SPACE",aG,gl,gm)gp(fuelX,"Rocket Fuel ","ROCKET",aH,gj,gk)end end;function kQ.DrawShield()local lu=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local lv=core.getPvPTimer()local lw=shield_1.getResistances()local lx="A: "..10+lw[1]*100 .."% / E: "..10+lw[2]*100 .."% / K:"..10+lw[3]*100 .."% / T: "..10+lw[4]*100 .."%"local bW,bX=shieldX-60,shieldY+30;local ly=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gD=e(ly*2.55)local gE=f("rgb(%d,%d,%d)",255-gD,gD,0)local bZ=""g9=bV(bW,bX,"","txtmid pdim txtfuel")if ly<10 and lu~="Shield Disabled"then bZ="red "end;lv=lv>0 and"   PvPTime: "..c6(lv)or""g9=g9 ..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bW,bX,gE,ly*2,bW,bX,bW+2,bX+10,ly,lv)g9=g9 ..bV(bW,bX-5,lu,bZ.."txtstart pbright txtbig")g9=g9 ..bV(bW,bX+30,lx,bZ.."txtstart pbright txtsmall")end;function kQ.hudtick()if not planet then return end;local function lz(gJ)local gG=e(r(aj/(aD/4)*255,0,255))gJ[#gJ+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+gG,e(J+0.5)-gG,e(I+0.5)-gG)end;local function lA()for _,cg in pairs(fL)do if cg.hovered then if not cg.drawCondition or cg.drawCondition(cg)then cg.toggleFunction(cg)end;cg.hovered=false end end;for _,cg in pairs(by)do if cg.hovered then SelectedTab=cg.label;cg.hovered=false end end end;local function lB()local function lC(lD,lE,bW,bX,kf,kg)if lD>=bW and lD<=bW+kf and lE>=bX and lE<=bX+kg then return true else return false end end;local bW=ag+aD/2;local bX=ah+aE/2;for _,cg in pairs(fL)do cg.hovered=lC(bW,bX,cg.x,cg.y,cg.width,cg.height)end;for _,cg in pairs(by)do cg.hovered=lC(bW,bX,cg.x,cg.y,cg.width,cg.height)end;if bw then local jU=false;for _,c2 in ipairs(apExtraButtons)do if c2.hovered then jU=true;break end end;if apbutton.hovered then jU=true end;bw=jU else bw=apbutton.hovered;if not bw then bx=AutopilotTargetIndex end end end;local function lF(gJ)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;for cf,cg in pairs(by)do local bZ="dim brightstroke"local lG=0.2;if SelectedTab==cf then bZ="pbright dimstroke"lG=0.6 end;local lH=""if cg.hovered then lG=0.8;lH=";stroke:white"end;gJ[#gJ+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cg.width,cg.height,cg.x,cg.y,bZ,lG,lH)gJ[#gJ+1]=bV(cg.x+cg.width/2,cg.y+cg.height/2+5,cg.label,"txt txtmid pdim")end end;local function lI(gJ)local function lJ(gJ,lK,hover,bW,bX,d_,lL,lM,lN,lO,lP,button)if type(lO)=="function"then lO=lO(button)end;if type(lP)=="function"then lP=lP(button)end;gJ[#gJ+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bW,bX,d_,lL)if lK then gJ[#gJ+1]=f("%s'",lM)else gJ[#gJ+1]=lN end;if hover then gJ[#gJ+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gJ[#gJ+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gJ[#gJ+1]=" rx='5'></rect>"gJ[#gJ+1]=f("<text x='%f' y='%f' font-size='24' fill='",bW+d_/2,bX+lL/2+5)if lK then gJ[#gJ+1]="black"else gJ[#gJ+1]="white"end;gJ[#gJ+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lK then gJ[#gJ+1]=f("%s</text>",lO)else gJ[#gJ+1]=f("%s</text>",lP)end end;local lQ=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local lR=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local lS=lJ;for _,cg in pairs(fL)do local kk=cg.disableName;local kj=cg.enableName;if type(kk)=="function"then kk=kk(cg)end;if type(kj)=="function"then kj=kj(cg)end;if not cg.drawCondition or cg.drawCondition(cg)then lS(gJ,cg.toggleVar(cg),cg.hovered,cg.x,cg.y,cg.width,cg.height,lR,lQ,kk,kj,cg)end end end;local lT=A(aD/2,0)local lU=A(aE/2,0)local gJ={}aP.HUDPrologue(gJ)if showHud then aP.UpdateHud(gJ)else if AlwaysVSpd then aP.DrawVerticalSpeed(gJ,as)end;aP.DisplayOrbitScreen(gJ)aP.DrawWarnings(gJ)end;if fR and fS~={}then aP.DrawSettings(gJ)end;if radar_1 or radar_2 then aS.assignRadar()end;if bu[1]then aP.DrawRadarInfo()end;aP.HUDEpilogue(gJ)gJ[#gJ+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aD,aE)if a2~="empty"then aP.DisplayMessage(gJ,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aP.DrawDeadZone(gJ)end end;lF(gJ)if x()==0 then if m()==1 and a1 then if not AltIsOn then lB()lI(gJ)end;if not aT and not aU then local lV=table.concat(gJ,"")gJ={}gJ[#gJ+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gJ[#gJ+1]=lV;gJ[#gJ+1]="</body>"aT=true;gJ[#gJ+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gJ,"")system.setScreen(content)elseif aU then local lV=table.concat(gJ,"")gJ={}gJ[#gJ+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gJ[#gJ+1]=lV;gJ[#gJ+1]="</body>"end;if not aT then gJ[#gJ+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lT,lU,ag,ah)end else lA()end else if not a1 and m()==0 then lA()if aj>DeadZone then if DisplayDeadZone then lz(gJ)end end elseif a1 and(not AltIsOn or not freeLookToggle)then lB()lI(gJ)end;gJ[#gJ+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lT,lU,ag,ah)end;gJ[#gJ+1]=[[</svg></body>]]content=table.concat(gJ,"")end;function kQ.TenthTick()aP.DrawTanks()if shield_1 then aP.DrawShield()end end;function kQ.OneSecond(gJ)local function lW()local gz=q()local hV=bc;local lX=gz-au;if hV>1.38889 then hV=hV/1000;local lY=hV*(gz-au)TotalDistanceTravelled=TotalDistanceTravelled+lY;ad=ad+lY end;ae=ae+lX;TotalFlightTime=TotalFlightTime+lX;au=gz end;lW()aP.UpdatePipe()aP.ExtraData(gJ)end;function kQ.ButtonSetup()ks()kx()fL=fM end;return kQ end;local function lZ()local function l_(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function m0()local function m1(m2,m3)return m2.name<m3.name end;bm={}for cf,cg in pairs(b[0])do bm[#bm+1]={name=cg.name,index=cf}end;table.sort(bm,m1)end;local function m4(m5)for cf,cg in pairs(m5)do if cg.name and cg.name==CustomTarget.name then return cf end end;return-1 end;local function m6()bx=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local m7=bm[AutopilotTargetIndex].index;local m8=b[0][m7]if m8.center then AutopilotTargetName=m8.name;ac=aL[0][m7]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=m8;for _,cg in pairs(aL[0])do if cg.name==CustomTarget.planetname then ac=cg;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function m9(gN)if not Autopilot and not VectorToTarget and not am and not IntoOrbit and not Reentry and not an then if gN==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bm end end;if AutopilotTargetIndex==0 then m6()else local m7=bm[AutopilotTargetIndex].index;local m8=b[0][m7]if m8~=nil and m8.name=="Space"or iphCondition=="Custom Only"and m8.center or iphCondition=="No Moons"and string.find(m8.name,"Moon")~=nil then if gN==nil then m9()else m9(1)end else m6()end end else a2="Disengage autopilot before changing Interplanetary Helper"bI("iph","AP")end end;local function kD()local fj=-1;fj=m4(b[0])if fj>-1 then table.remove(b[0],fj)end;fj=-1;fj=m4(SavedLocations)if fj~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fj)end;m9()m0()end;local function ky(fy,position,hu,ma)if dbHud_1 or hu then local p=l_(position)local l4=p.gravity;if ma then l4=unit.getClosestPlanetInfluence()end;local mb={position=position,name=fy,planetname=p.name,gravity=l4,safe=ma}if not hu then SavedLocations[#SavedLocations+1]=mb else for cf,cg in pairs(b[0])do if cg.name and fy==cg.name then table.remove(b[0],cf)end end end;table.insert(b[0],mb)m0()m6()a2="Location saved as "..fy.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local mc={}function mc.UpdateAtlasLocationsList()m0()end;function mc.UpdateAutopilotTarget()m6()end;function mc.adjustAutopilotTargetIndex(gN)m9(gN)end;function mc.findAtlasIndex(m5)m4(m5)end;function mc.UpdatePosition(md)local fj=m4(SavedLocations)if fj~=-1 then if md~=nil then SavedLocations[fj].name=md;AutopilotTargetIndex=AutopilotTargetIndex-1;m9()else local me=SavedLocations[fj]me.gravity=unit.getClosestPlanetInfluence()me.position=bf;me.safe=true end;a2=SavedLocations[fj].name.." position updated ("..SavedLocations[fj].planetname..")"else a2="Name Not Found"end end;function mc.AddNewLocation(fy,position,hu,ma)ky(fy,position,hu,ma)end;function mc.ClearCurrentPosition()kD()end;for cf,cg in pairs(SavedLocations)do table.insert(b[0],cg)end;m0()if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end;mc.UpdateAutopilotTarget()return mc end;local function mf()local mg={}local function mh(e6)local mi=AutopilotEndSpeed;if not Autopilot then mi=0 end;if not aq then return aM.computeDistanceAndTime(e6,mi,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aM.computeDistanceAndTime(e6,mi,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function mj(e6)local mi=AutopilotEndSpeed;if not Autopilot then mi=0 end;return aM.computeDistanceAndTime(e6,mi,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local mk=false;local ml=0;local mm=0;local mn=0;local mo=q()local mp=0;local mq=0;local mr=0;local ms=0;local mt=false;local mu=false;local mv=false;local mw=nil;local mx=0;function mg.GetAutopilotBrakeDistanceAndTime(e6)return mh(e6)end;function mg.GetAutopilotTBBrakeDistanceAndTime(e6)return mj(e6)end;local function my(mz,mA,mB)mA=mA:project_on_plane(mz)mB=mB:project_on_plane(mz)return n(mA:cross(mB):dot(mz),mA:dot(mB))end;local function mC()local function mD()local mE=-1;local mF=-1;if vBooster then mE=vBooster.getDistance()end;if hover then mF=hover.getDistance()end;if mE~=-1 and mF~=-1 then if mE<mF then return mE else return mF end elseif mE~=-1 then return mE elseif mF~=-1 then return mF else return-1 end end;local mG=mD()local mH=-1;if telemeter_1 then mH=telemeter_1.getDistance()end;if mG~=-1 and mH~=-1 then if mG<mH then return mG else return mH end elseif mG~=-1 then return mG else return mH end end;local function mI(planet,dt,mJ)local function mK(mL,cL)local dz=vec3(cL)if mL.id==0 then return setmetatable({latitude=dz.x,longitude=dz.y,altitude=dz.z,id=0,systemId=mL.systemId},MapPosition)end;local dA=dz-mL.center;local aj=dA:len()local cR=aj-mL.radius;local cP=0;local cQ=0;if not c0(aj,0)then local dB=n(dA.y,dA.x)cQ=dB>=0 and dB or 2*math.pi+dB;cP=math.pi/2-math.acos(dA.z/aj)end;return setmetatable({latitude=math.deg(cP),longitude=math.deg(cQ),altitude=cR,id=mL.id,systemId=mL.systemId},MapPosition)end;local mM=mK(planet,dt)mM="::pos{"..mM.systemId..","..mM.id..","..mM.latitude..","..mM.longitude..","..mM.altitude.."}"if mJ then return mM else system.setWaypoint(mM)return true end end;local mN=false;function mg.showWayPoint(planet,dt,mJ)return mI(planet,dt,mJ)end;function mg.APTick()local function mO()if bt and not BrakeLanding then local db=bt[1]local fz,fA=bt[2],bt[3]local mP=math.min(fz,fA or fz)local mQ=mP/bc;local mR=AutoTakeoff and(bc<42 or ao~=-1)local mS=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mS and not mR and(a8*1.5>mP or mQ<1)then BrakeIsOn=true;aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()end;if LockPitch then aR.ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then aR.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aV=true end;if mQ<11 then bs=db.name.." COLLISION "..c6(mQ).." / "..c3(mP,2)else bs=db.name.." collision "..c6(mQ)end;if mQ<6 then bI("alarm","AL",2)end else bs=false end end;local function mT(mU,mV,mW)local function mX(mU,dd)mU=vec3(mU)dd=vec3(dd):normalize()local cw=mU*dd;return cw.x+cw.y+cw.z end;local mY=0.001;local mZ=1;if not aq or not aX or ao~=-1 or bc<Q then if mW==nil then mW=DampingMultiplier end;if mV==nil then mV=mY end;mU=vec3(mU):normalize()local m_=vec3()-mU;local n0=-mX(m_,core.getConstructWorldOrientationRight())*mZ;local n1=-mX(m_,core.getConstructWorldOrientationUp())*mZ;if mm==0 then mm=n0/2 end;if mn==0 then mn=n1/2 end;if d(n0)<0.1 then V=V-n0*2 else V=V-(n0+(n0-mm)*mW)end;if d(n1)<0.1 then U=U+n1*2 else U=U+n1+(n1-mn)*mW end;mm=n0;mn=n1;if d(n0)<mV and d(n1)<mV then return true end;return false elseif aX and ao==-1 then mU=bb;if mW==nil then mW=DampingMultiplier end;if mV==nil then mV=mY end;mU=vec3(mU):normalize()local m_=b8-mU;local n0=-mX(m_,core.getConstructWorldOrientationRight())*mZ;local n1=-mX(m_,core.getConstructWorldOrientationUp())*mZ;if mm==0 then mm=n0/2 end;if mn==0 then mn=n1/2 end;if d(n0)<0.1 then V=V-n0*5 else V=V-(n0+(n0-mm)*mW)end;if d(n1)<0.1 then U=U+n1*5 else U=U+n1+(n1-mn)*mW end;mm=n0;mn=n1;if d(n0)<mV and d(n1)<mV then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=mC()E=q()mo=E;if CollisionSystem then mO()end;if antigrav then bh=antigrav.getState()==1 end;local n2=1;local n3=1;local n4=E-mo;local n5=-math.deg(my(b7,bb,b8))local n6=math.deg(my(b9,bb,b8))local gN=bd*-1;aX=aq and n5<-YawStallAngle or n5>YawStallAngle or n6<-PitchStallAngle or n6>PitchStallAngle;local n7=system.getMouseDeltaX()local n8=system.getMouseDeltaY()if InvertMouse and not a1 then n8=-n8 end;V=0;Z=0;U=0;sys=aL[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aO(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bb)if as==0 then as=(bf-planet.center):len()-planet.radius end;br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local l4=planet:getGravity(core.getConstructWorldPos()):len()*av;aY=0;aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aT then ag=r(ag+n7,-aD/2,aD/2)ah=r(ah+n8,-aE/2,aE/2)end else ag=0;ah=0 end else ag=r(ag+n7,-aD/2,aD/2)ah=r(ah+n8,-aE/2,aE/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then local hH,hI=n7,n8;if SelectedTab=="SCOPE"then hH,hI=bC/90,bC/90 end;if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity*hH elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity*hH else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity*hI elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity*hI else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(n8,-100,100)+0.5)*2*n2;V=(-utils.smoothstep(n7,-100,100)+0.5)*2*n3 end end end end;local n9=bc>8334;if bc>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not n9 then a2="Space Speed Engine Shutoff reached"aR.cmdThrottle(0)end;if not n9 and LastIsWarping then if not BrakeIsOn then aR.BrakeToggle()end;if Autopilot then aR.ToggleAutopilot()end end;LastIsWarping=n9;if aq and ar>0.09 then if bc>aZ/3.6 and not AtmoSpeedAssist and not mk then BrakeIsOn=true;mk=true elseif not AtmoSpeedAssist and mk then if bc<aZ/3.6 then BrakeIsOn=false;mk=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local na=false;if CustomTarget and al~=1 then na=mT(CustomTarget.position-bf,0.1)else na=mT(vec3(bb),0.01)end;aV=true;if na then aR.cmdCruise(e(aZ))if(d(bl)<2 or d(bk)>85)and bc>=aZ/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;aR.BeginReentry()end elseif aq and AtmoSpeedAssist then aR.cmdThrottle(1)end elseif bc>Q then mT(vec3(bb),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bc>Q then mT(-vec3(bb))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;aR.BeginReentry()al=false;an=true else al=false;aR.ToggleAutopilot()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bc*3.6>aZ-250 and d(be)<25 and ar>=0.1 and(CustomTarget.position-bf):len()>2000+as then aR.ToggleAutopilot()an=false end;if VertTakeOff then aV=true;local nb=HoldAltitude;if be<-30 then a2="Unable to achieve lift. Safety Landing."af=0;aV=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bh or HoldAltitude<planet.spaceEngineMinAltitude then if bh then nb=antigrav.getBaseAltitude()end;if as<nb-100 then a_=0;af=15;BrakeIsOn=false elseif be>0 then BrakeIsOn=true;af=0 elseif be<-30 then BrakeIsOn=true;af=15 elseif as>=nb then if bh then if Autopilot or VectorToTarget then aR.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bI("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bI("vtoc","VT")aR.ToggleVerticalTakeoff()end;af=0 end else if ar>0.08 then a_=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if b5 then a_=0;af=20 else af=0;a_=36;aR.cmdCruise(3500)end else aV=autoRollPreference;IntoOrbit=true;b3=false;CancelIntoOrbit=false;mt=false;mr=nil;ms=nil;if mw==nil then mw=planet end;b2=nb;mv=true;VertTakeOff=false end end;if a_~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local nc=r(a_-bk,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(nc)local nd=r(vTpitchPID:get(),-1,1)U=nd end end;if IntoOrbit then local m_;local ne=false;local nf=c3(b2)if mw==nil then mw=planet;if VectorToTarget then mw=ac end end;if not mv then b2=e(mw.radius+mw.surfaceMaxAltitude+LowOrbitHeight)if mw.hasAtmosphere then b2=e(mw.radius+mw.noAtmosphericDensityAltitude+LowOrbitHeight)end;mv=true end;if b1.VectorToTarget and CustomTarget then m_=CustomTarget.position-bf end;local ng,nh=aO(mw):escapeAndOrbitalSpeed((bf-mw.center):len()-mw.radius)local ni=bl;if not mt then local nj=false;local nk=false;aR.cmdThrottle(0)ms=0;b0="Aligning to orbital path - OrbitHeight: "..nf;if b1.VectorToTarget then mT(m_:normalize():project_on_plane(bd))ne=b8:dot(m_:project_on_plane(b7):normalize())>0.95 else mT(bb)ne=n5<0.5;if bc<150 then ne=true end end;U=0;mr=0;if bk<=mr+1 and bk>=mr-1 then nj=true else nj=false end;if ni<=ms+1 and ni>=ms-1 then nk=true else nk=false end;if nj and nk and ne then mr=nil;ms=nil;mt=true end else if b1.VectorToTarget then mT(m_:normalize():project_on_plane(bd))elseif bc>150 then mT(bb)end;U=0;if b1.VectorToTarget and CustomTarget then local a8,_=aM.computeDistanceAndTime(bc,aZ/3.6,av,0,0,LastMaxBrake)if b3 and m_:len()>15000+a8+as then b0="Orbiting to Target"if as-100<=mw.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<mw.noAtmosphericDensityAltitude then b3=false end elseif b3 or m_:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bI("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;b1.VectorToTarget,b1.AutopilotAlign=false,false;aR.ToggleIntoOrbit()aR.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>b2*0.9 and as<b2*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=b2*0.99 and orbit.apoapsis.altitude>=b2*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or b3 then if b3 then BrakeIsOn=false;aR.cmdThrottle(0)mr=0;if not b1.VectorToTarget then a2="Orbit complete"bI("orCom","OB")aR.ToggleIntoOrbit()end else mx=mx+1;if mx>=2 then b3=true end end else b0="Adjusting Orbit - OrbitHeight: "..nf;mu=true;aR.cmdCruise(nh*3.6+1)local nl=b2-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(nl-be*r(utils.smoothstep(2000-nl,-2000,2000)^6*10,1,10))mr=r(VSpdPID:get(),-60,60)end end else local nm=2.75;local nn=d(A(ng*nm))local no=nn%50;if no>0 then nn=nn-no+50 end;BrakeIsOn=false;if as<b2*0.8 then b0="Escaping planet gravity - OrbitHeight: "..nf;mr=utils.map(be,200,0,-15,80)elseif as>=b2*0.8 and as<b2*1.15 then b0="Approaching orbital corridor - OrbitHeight: "..nf;nn=nn*0.75;mr=utils.map(be,100,-100,-15,65)elseif as>=b2*1.15 and as<b2*1.5 then b0="Approaching orbital corridor - OrbitHeight: "..nf;nn=nn*0.75;if be<0 or mu then mr=utils.map(as,b2*1.5,b2*1.01,-30,0)else mr=utils.map(as,b2*0.99,b2*1.5,0,30)end elseif as>b2*1.5 then b0="Reentering orbital corridor - OrbitHeight: "..nf;mr=-65;local np=utils.map(be,-150,-400,1,0.55)nn=nn*np end;aR.cmdCruise(e(nn))end end;if mr~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local nq=mr-bk;OrbitPitchPID:inject(nq)local nr=r(OrbitPitchPID:get(),-0.5,0.5)U=nr end end;if Autopilot and ar==0 and not al then local function ns(bE,orbit)system.print(bE)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aR.cmdThrottle(0)P=false;a2=bE;bI("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;b2=as;mv=true end;aR.ToggleIntoOrbit()end end;local nt,nu=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local nw=(CustomTarget.position-ac.center):normalize()local nx=nw:project_on_plane((ac.center-bf):normalize()):normalize()local ny=ac.center+nx*(ac.radius+AutopilotTargetOrbit)local nz=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bf-ny):len()<(bf-nz):len()then nt=ny else nt=nz;AutopilotEndSpeed=0 end;AutopilotTargetCoords=nt;aR.showWayPoint(ac,AutopilotTargetCoords)nu=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;nu=true;AutopilotRealigned=true;TargetSet=true;nt=CustomTarget.position+(bf-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=nt end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local nw=(bf+bb*100000-ac.center):normalize()local nx=nw:project_on_plane((ac.center-bf):normalize()):normalize()if nx:len()<1 then nw=(bf+b8*100000-ac.center):normalize()nx=nw:project_on_plane((ac.center-bf):normalize()):normalize()end;nt=ac.center+nx*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=nt;TargetSet=true;nu=true;AutopilotRealigned=true;aR.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(nt)-bf):len()local iv,dr,ds=aL:getPlanetarySystem(0):castIntersections(bf,bb:normalize(),function(db)if db.noAtmosphericDensityAltitude>0 then return db.radius+db.noAtmosphericDensityAltitude else return db.radius+db.surfaceMaxAltitude*1.5 end end)local iw=dr;if ds~=nil and dr~=nil then iw=math.min(ds,dr)end;if iw~=nil and iw<AutopilotDistance and iv.name==ac.name then AutopilotDistance=iw end;local na=true;local nA=(ac.center-(bf+vec3(bb):normalize()*AutopilotDistance)):len()-ac.radius;local ik=c3(nA)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ik..'"}')local a8,a9;if not TurnBurn then a8,a9=mh(bc)else a8,a9=mj(bc)end;if bc>50 and AutopilotAccelerating then local m_=vec3(nt)-bf;local nB=r(math.deg(my(b7,bb:normalize(),m_:normalize()))*bc/500,-90,90)local nC=r(math.deg(my(b9,bb:normalize(),m_:normalize()))*bc/500,-90,90)if d(nB)<20 and d(nC)<20 then nB=nB*2;nC=nC*2 end;if d(nB)<2 and d(nC)<2 then nB=nB*2;nC=nC*2 end;local n5=-math.deg(my(b7,b8,bb:normalize()))local n6=-math.deg(my(b9,b8,bb:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(nC-n6)local nD=r(apPitchPID:get(),-1,1)U=U+nD;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(nB-n5)local nE=r(apYawPID:get(),-1,1)V=V+nE;nu=true;if d(nB)>2 or d(nC)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bI("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end end elseif AutopilotAccelerating and bc<=50 then mT((nt-bf):normalize())end;if nA<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(nA)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local iv,iw=aR.checkLOS((AutopilotTargetCoords-bf):normalize())if ac.name~=planet.name then if iv~=nil and ac.name~=iv.name and iw<AutopilotDistance then a2="Collision with "..iv.name.." in "..c3(iw).."\nClear LOS to continue."ai=5;mN=true else mN=false;a2=""end end end;if not mN then if not AutopilotCruising and not AutopilotBraking and not nu then na=mT((nt-bf):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then na=mT(-vec3(bb):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aR.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local nF=unit.getThrottle()if AtmoSpeedAssist then nF=K end;local nG=99999;local lg=-vec3(core.getWorldAcceleration()):dot(bb:normalize())local nH=r(bb:dot((nt-bf):normalize()),0,bc)if nH>0 or lg>0 then nG=aM.computeTravelTime(nH,lg,AutopilotDistance-a8)end;if ba:len()>=MaxGameVelocity or nF==0 and P or warmup/4>nG then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bI("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aR.cmdThrottle(0)end;local nI=AutopilotDistance;if nI<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<ml and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;ml=bo else ml=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bI("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aR.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aR.cmdThrottle(1,true)end;local _,nh=aO(ac):escapeAndOrbitalSpeed((bf-planet.center):len()-planet.radius)local m_;if CustomTarget then m_=CustomTarget.position-bf end;if CustomTarget and CustomTarget.planetname=="Space"and bc<50 then ns("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bc<=nh and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then ns("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bI("apCir","AP")AutopilotStatus="Circularizing"end;if bc<=nh then if CustomTarget then if bb:normalize():dot(m_:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bI("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else ns("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else ns("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then ns("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nI=AutopilotDistance;if nI<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<ml and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;ml=bo else ml=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bI("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local nF=unit.getThrottle()if AtmoSpeedAssist then nF=K end;if nF>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end;AutopilotCruising=false end else if na then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*b9;AutopilotShipUp=b7;AutopilotShipRight=b9 end;AutopilotRealigned=true elseif na and not mN then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end;if not P then aR.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bI("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aR.cmdThrottle(0)P=false;ProgradeIsOn=true;al=true;aR.showWayPoint(ac,CustomTarget.position)end;if a0 then aV=true;local nC=0;local ea=bf+vec3(unit.getMasterPlayerRelativePosition())local nJ=ea-bf;local nK=vec3(nJ):project_on(b8):len()local nL=vec3(nJ):project_on(b9):len()local aj=y(nK*nK+nL*nL)mT(nJ:normalize())local jv=40;local nM=aj<jv;local nN=100;local nO=r((aj-jv)/2,10,nN)U=0;local na=d(V)<0.1;if na and bc<nO and not nM then BrakeIsOn=false;nC=-20 else BrakeIsOn=true;nC=0 end;local nP=0;if d(nC-bk)>nP then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(nC-bk)local nD=pitchPID:get()U=nD end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local nQ=LastMaxBrakeInAtmo;if nQ then nQ=nQ*r(bc/100,0.1,1)*ar else nQ=LastMaxBrake end;if ar<0.01 then nQ=LastMaxBrake end;local nR=b8:project_on_plane(bd):normalize():dot(bb)local nS=vec3(core.getWorldAirFrictionAcceleration())local nT=nS:len()*av;if nR>100 then a8,a9=aM.computeDistanceAndTime(nR,100,av,0,0,nQ)local nU,nV=aM.computeDistanceAndTime(100,0,av,0,0,nQ*0.55)a8=a8+nU else a8,a9=aM.computeDistanceAndTime(nR,0,av,0,0,nQ*0.55)end;local nl=HoldAltitude-as-be;local nW=200+bc;if Reentry or al then minMax=2000+bc end;local nX=1;if AutoTakeoff then nX=r(bc/100,0.1,1)end;local nC=(utils.smoothstep(nl,-nW,nW)-0.5)*2*MaxPitch*nX;if not Reentry and not al and not VectorToTarget and b8:dot(bb:normalize())<0.99 then nC=(utils.smoothstep(nl,-nW*r(20-19*ar*10,1,20),nW*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*nX end;if not AltitudeHold then nC=0 end;if LockPitch~=nil then if br and not IntoOrbit then nC=LockPitch else LockPitch=nil end end;aV=true;local nY=U;if Reentry then local nZ=e(aZ)local n_,o0=aM.computeDistanceAndTime(bc,nZ/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)n_=n_==-1 and 5000 or n_;local o1=as-(planet.noAtmosphericDensityAltitude+n_)local o2=as>planet.noAtmosphericDensityAltitude+n_*1.35;if o2 then nC=ReEntryPitch;if bc<=nZ/3.6 and bc>nZ/3.6-10 and d(bb:normalize():dot(b8))>0.9 and not bj then O=false;aR.cmdThrottle(1)end elseif bj and not o2 and not aq then aR.cmdCruise(nZ,true)end;if bj then if bc>nZ/3.6 and not o2 then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if be>0 then BrakeIsOn=true end;if not R then nC=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;nC=0;aV=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and o2 then aV=true elseif not o2 then if not aq and(bj or s:getTargetSpeed(axisCommandId.longitudinal)~=nZ)then aR.cmdCruise(nZ)end;if bc<nZ/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;aV=true end end end;if bc>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then mT(vec3(bb))end;if bp or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local m_;if bp then if type(bp)=="table"then m_=bp elseif bp<3 and bp>0 then m_=-bd:cross(bb)*5000 elseif bp>=3 then m_=bd:cross(bb)*5000 elseif bp<0 then m_=bb*25000 end elseif CustomTarget~=nil then m_=CustomTarget.position-bf else m_=ac.center-bf end;local nB=math.deg(my(bd:normalize(),bb,m_))*2;local jy=math.rad(d(bl))if bc>minRollVelocity and ar>0.01 then local o3=1000+bc;local o4=(utils.smoothstep(nl-be*10,-o3,o3)-0.5)*2*MaxPitch;local o5=r(90-o4,0,180)aY=r(nB*2,-o5,o5)local o6=nB;nB=r(r(nB,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jy)+4*(bk-nC)*math.sin(math.rad(bl)),-YawStallAngle*0.80,YawStallAngle*0.80)local o7=1;if aY~=0 then o7=d(jy/aY)end;o7=(90-r(d(aY-bl),0,90))/90;local o8=nC;if d(bl)>90 then o8=-o8 end;nC=o7*r(r(o8*math.cos(jy),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(o6)*math.sin(jy),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aY=0;nB=r(nB,-YawStallAngle*0.80,YawStallAngle*0.80)end;local o9=n5-nB;if bp and d(o9)<=0.0001 and(type(bp)=="table"or type(bp)~="table"and bp<0 and d(bl)<1)then if bp==-2 then aR.ToggleAltitudeHold()end;bp=nil;bI("180Off","BR")return end;if not aX and bc>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(o9)local nE=r(yawPID:get(),-1,1)V=V+nE elseif aq and ao>-1 or bc<minRollVelocity then mT(m_)elseif aX and ar>0.01 then if(n5<-YawStallAngle or n5>YawStallAngle)and ar>0.01 then mT(bb)end;if(n6<-PitchStallAngle or n6>PitchStallAngle)and ar>0.01 then nC=r(bk-n6,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local nb=planet:getAltitude(CustomTarget.position)local o1=m_:project_on_plane(bd):len()StrongBrakes=true;if not am and not Reentry and o1<=a8 and(bb:project_on_plane(bd):normalize():dot(m_:project_on_plane(bd):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(nR<0.1 or o1<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<o1)then if not bh then bI("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bs=false end;LastDistanceToTarget=o1 end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local m_=CustomTarget.position-bf;local nb=planet:getAltitude(CustomTarget.position)local o1=y(m_:len()^2-(as-nb)^2)local nQ=LastMaxBrakeInAtmo;if nQ then a8,a9=aM.computeDistanceAndTime(bc,0,av,0,0,nQ/2)StrongBrakes=true;if o1<=a8+bc*n4/2 and bb:project_on_plane(bd):normalize():dot(m_:project_on_plane(bd):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;aR.BeginReentry()end end;LastDistanceToTarget=o1 end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not b3 and not IntoOrbit then b2=HoldAltitude;mv=true;if VectorToTarget then b1.VectorToTarget=true end;aR.ToggleIntoOrbit()VectorToTarget=false;mt=true end end;if aX and ar>0.01 and ao==-1 and bc>minRollVelocity and VectorStatus~="Finalizing Approach"then mT(bb)nC=r(bk-n6,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end;U=nY;local mH=-1;if BrakeLanding then nC=0;local oa=false;local ob=30;if aN~=nil and aN>0 then local oc=r(ar,0.4,2)local nQ=LastMaxBrakeInAtmo*r(bc/100,0.1,1)*oc;local od=aN*oc+nQ-l4;local oe=nQ/2-l4;local of=bc-y(d(oe/2)*20/(0.5*av))*utils.sign(oe)if of<0 then of=0 end;local og;if bc>100 then local oh,_=aM.computeDistanceAndTime(bc,100,av,0,0,nQ)local oi,_=aM.computeDistanceAndTime(100,0,av,0,0,y(nQ))og=oh+oi else og=aM.computeDistanceAndTime(bc,0,av,0,0,y(nQ))end;if og<20 then BrakeIsOn=false else local oj=0;if of>100 then local ok,_=aM.computeDistanceAndTime(of,100,av,0,0,od)local ol,_=aM.computeDistanceAndTime(100,0,av,0,0,aN*oc+y(nQ)-l4)oj=ok+ol else oj,_=aM.computeDistanceAndTime(of,0,av,0,0,aN*oc+y(nQ)-l4)end;oj=(oj+15+bc*n4)*1.1;local om=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if om then local nb=planet:getAltitude(CustomTarget.position)local on=as-nb-100;local m_=CustomTarget.position-bf;local oo=y(m_:len()^2-(as-nb)^2)if oo>100 then om=false elseif on<=oj or oj==-1 then BrakeIsOn=true;oa=true else BrakeIsOn=false;oa=true end end;if not om and CalculateBrakeLandingSpeed then if oj>=ob then BrakeIsOn=true else BrakeIsOn=false end;oa=true end end end;if not bj then aR.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;mH=ao;if mH>-1 then aV=autoRollPreference;if bc<1 or bb:normalize():dot(bd)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bI("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bb:normalize():dot(-gN)<0.999 then BrakeIsOn=true elseif be<-brakeLandingRate and not oa then BrakeIsOn=true elseif not oa then BrakeIsOn=false end end;if AutoTakeoff or am then local iv,ds,dr;if AutopilotTargetCoords~=nil then iv,ds,dr=aL:getPlanetarySystem(0):castIntersections(bf,(AutopilotTargetCoords-bf):normalize(),function(db)return db.radius+db.noAtmosphericDensityAltitude end)end;if bh then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aR.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(nC)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bj and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bc<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;aR.cmdThrottle(0)elseif am then aR.cmdThrottle(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(iv==nil or iv.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bj then aR.cmdThrottle(0)end;AutopilotAccelerating=true end end;local op=ao>-1;local oq=bk;if(VectorToTarget or am or bp)and not op and bc>minRollVelocity and ar>0.01 then local jy=math.rad(d(bl))oq=bk*d(math.cos(jy))+n6*math.sin(jy)end;local os=r(nC-oq,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then os=r(nC-oq,-85,MaxPitch)elseif ar<0.01 then os=r(nC-oq,-MaxPitch,MaxPitch)end;if d(bl)<5 or VectorToTarget or bp or BrakeLanding or op or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(os)local nD=pitchPID:get()U=U+nD end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function mg.ToggleIntoOrbit()b3=false;mr=nil;ms=nil;mx=0;if ar==0 then if IntoOrbit then bI("orOff","AP")IntoOrbit=false;mt=false;mw=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mv=false elseif br then bI("orOn","AP")IntoOrbit=true;aV=true;if mw==nil then mw=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;mt=false;mw=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mv=false end end;function mg.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aV=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aR.cmdCruise(e(aZ))end else b3=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function mg.checkLOS(mU)local iv,dr,ds=aL:getPlanetarySystem(0):castIntersections(bf,mU,function(db)if db.noAtmosphericDensityAltitude>0 then return db.radius+db.noAtmosphericDensityAltitude else return db.radius+db.surfaceMaxAltitude*1.5 end end)local iw=dr;if ds~=nil and dr~=nil then iw=math.min(ds,dr)end;if iw~=nil then return iv,iw else return nil,nil end end;function mg.ToggleAutopilot()local function ot(SpaceTarget)bs=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aR.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if E-mq<1.5 and ar>0 then if not b6 then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bI("orH","OH")end;mq=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else mq=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aQ.UpdateAutopilotTarget()aR.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bI("apSpc","AP")if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bI("vtt","AP")ot(SpaceTarget)end else bI("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then b3=false;Autopilot=true elseif not aq then if IntoOrbit then aR.ToggleIntoOrbit()end;b2=planet.noAtmosphericDensityAltitude+LowOrbitHeight;mv=true;b1.AutopilotAlign=true;b1.VectorToTarget=true;mt=false;if not IntoOrbit then aR.ToggleIntoOrbit()end end end else bI("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and br)and not IntoOrbit then WaypointSet=false;b3=false;mt=false;aR.ToggleIntoOrbit()else bI("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bI("apP","AP")am=true;aR.ToggleAltitudeHold()end else bI("apOff","AP")aR.ResetAutopilots(1)end end;function mg.cmdThrottle(cB,ou)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ou then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cB)K=r(A(cB*100,0)/100,-1,1)bi=nil end;function mg.cmdCruise(cB,ou)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ou then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cB)bi=cB end;function mg.ToggleLockPitch()if LockPitch==nil then bI("lkPOn","LP")if not a1 then LockPitch=bk else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bI("lkPOff","LP")LockPitch=nil end end;function mg.ToggleAltitudeHold()if E-mp<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bI("11","EP")else if br then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b2=HoldAltitude;mv=true;if not IntoOrbit then aR.ToggleIntoOrbit()end;mt=true end end;mp=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else mp=E end;if br and ar==0 then b2=as;mv=true;mt=true;aR.ToggleIntoOrbit()if IntoOrbit then mp=E else mp=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;aV=true;LockPitch=nil;b3=false;if ao~=-1 and bc<20 then bI("lfs","LS")AutoTakeoff=true;if mp>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bg then aR.ToggleVerticalTakeoff()end else bI("altOn","AH")AutoTakeoff=false;if mp>-1 then if br then HoldAltitude=as end end;if VertTakeOff then aR.ToggleVerticalTakeoff()end end;if am then HoldAltitude=100000 end else bI("altOff","AH")if IntoOrbit then aR.ToggleIntoOrbit()end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;aV=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;mp=0 end end;function mg.ResetAutopilots(mg)if mg then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bp=nil;if not bh then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;if IntoOrbit then aR.ToggleIntoOrbit()end;aV=autoRollPreference;al=false;an=false;af=0 end;function mg.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aV=autoRollPreference end;if BrakeIsOn then bI("bkOn","B",1)aR.ResetAutopilots()else bI("bkOff","B",1)end end;function mg.BeginReentry()if Reentry then a2="Re-Entry cancelled"bI("reOff","RE")Reentry=false;aV=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;aV=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aZ;bI("par","RE")else Reentry=true;AltitudeHold=true;aV=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bY=c3(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..aZ.." Target Altitude: "..bY;bI("glide","RE")aR.cmdCruise(e(aZ))end;AutoTakeoff=false end;function mg.ToggleAntigrav()if antigrav and not ExternalAGG then if bh then bI("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bI("aggOn","AG")antigrav.activate()antigrav.show()end end end;ao=mC()return mg end;function script.onStart()local ov=false;local function ow()local function ox(oy)local oz=dbHud_1.hasKey;for cf,cg in pairs(oy)do if oz(cg)then local cw=g(dbHud_1.getStringValue(cg))if cw~=nil then _G[cg]=cw;ov=true end end end end;if dbHud_1 then if not useTheseSettings then ox(bO())coroutine.yield()ox(c)else ox(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;ov=false end;coroutine.yield()if ov then a2="Loaded Saved Variables"aD=ResolutionX;aE=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aV=autoRollPreference;aZ=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function oA()local function oB(oC,oD)if oC>oD then oD=oC end;local oE,oF=0,0;if ContainerOptimization>0 then oE=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then oF=FuelTankOptimization*0.05 end;oD=oD*(1-(oE+oF))return oD end;local oG=core.getElementNameById;local oH=fuelX~=0 and fuelY~=0;for cf in pairs(at)do local type=core.getElementTypeById(at[cf])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cf])),'^.*vertical.*$')and core.getElementForwardById(at[cf])[3]>0 then bg=true end end;if o(type,'^.*Space Engine$')then b6=true;if o(tostring(core.getElementTagsById(at[cf])),'^.*vertical.*$')then local oI=core.getElementForwardById(at[cf])if oI[3]<0 then b4=true else b5=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local oJ=j(at[cf])if oJ>10000 then G=110 elseif oJ>1000 then G=55 elseif oJ>150 then G=27 end end;aI=aI+j(at[cf])if oH and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local oJ=j(at[cf])local lc=l(at[cf])local oC=0;local gz=q()if type=="Atmospheric Fuel Tank"then local oD=400;local oK=35.03;if oJ>10000 then oD=51200;oK=5480 elseif oJ>1300 then oD=6400;oK=988.67 elseif oJ>150 then oD=1600;oK=182.67 end;oC=lc-oK;if fuelTankHandlingAtmo>0 then oD=oD+oD*fuelTankHandlingAtmo*0.2 end;oD=oB(oC,oD)aF[#aF+1]={at[cf],oG(at[cf]),oD,oK,oC,gz}end;if type=="Rocket Fuel Tank"then local oD=320;local oK=173.42;if oJ>65000 then oD=40000;oK=25740 elseif oJ>6000 then oD=5120;oK=4720 elseif oJ>700 then oD=640;oK=886.72 end;oC=lc-oK;if fuelTankHandlingRocket>0 then oD=oD+oD*fuelTankHandlingRocket*0.1 end;oD=oB(oC,oD)aH[#aH+1]={at[cf],oG(at[cf]),oD,oK,oC,gz}end;if type=="Space Fuel Tank"then local oD=600;local oK=35.03;if oJ>10000 then oD=76800;oK=5480 elseif oJ>1300 then oD=9600;oK=988.67 elseif oJ>150 then oD=2400;oK=182.67 end;oC=lc-oK;if fuelTankHandlingSpace>0 then oD=oD+oD*fuelTankHandlingSpace*0.2 end;oD=oB(oC,oD)aG[#aG+1]={at[cf],oG(at[cf]),oD,oK,oC,gz}end end end;if not bg then VertTakeOff,VertTakeOffEngine=false,false end end;local function oL()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cg in pairs(door)do cg.toggle()end end;if switch then for _,cg in pairs(switch)do cg.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cg in pairs(forcefield)do cg.toggle()end end;if antigrav then bh=antigrav.getState()==1;if bh and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and ba:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(aW)if aq and ao~=-1 then aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function oM()local oN={}local function oO()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local oP={[1]=4480,[6]=4480,[7]=6270}for oQ,oR in pairs(b)do b[oQ][0]=oO()b[oQ][0].systemId=oQ;oN[oQ]={}for oS,planet in pairs(b[oQ])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=oP[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=oQ;planet.bodyId=planet.id;oN[oQ][oS]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bB[#bB+1]=planet end end end;aK=ch()aL=aK(oN)aM=dF()aO=e8()aQ=lZ()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})ow()coroutine.yield()oA()coroutine.yield()aR=mf()oL()coroutine.yield()oM()aS=ew()aP=fJ()aP.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bu[1]=nil;if radar_1 then bu[1]=radar_1;aS.pickType()end;bI("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cg in pairs(door)do cg.toggle()end end;if switch then for _,cg in pairs(switch)do cg.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cg in pairs(forcefield)do cg.toggle()end end;showHud=bD;cb()if button then button.activate()end;if SetWaypointOnExit then aR.showWayPoint(planet,bf)end;bI("stop","SU")end;function script.onTick(oT)local oU=nil;if oT=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bI("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif oT=="tenthSecond"then local function oV()local oW=system.createData;local oX=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=oX(panelInterplanetary,"value")interplanetaryHeaderText=oW('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=oX(panelInterplanetary,"value")widgetDistanceText=oW('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=oX(panelInterplanetary,"value")widgetTravelTimeText=oW('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=oX(panelInterplanetary,"value")widgetMaxMassText=oW('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=oX(panelInterplanetary,"value")widgetTargetOrbitText=oW('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=oX(panelInterplanetary,"value")widgetCurBrakeDistanceText=oW('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=oX(panelInterplanetary,"value")widgetCurBrakeTimeText=oW('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=oX(panelInterplanetary,"value")widgetMaxBrakeDistanceText=oW('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=oX(panelInterplanetary,"value")widgetMaxBrakeTimeText=oW('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=oX(panelInterplanetary,"value")widgetTrajectoryAltitudeText=oW('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function oY()t(panelInterplanetary)panelInterplanetary=nil end;local function oZ()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bf):len()else AutopilotDistance=(CustomTarget.position-bf):len()end end;local e6=bc;local nF=unit.getThrottle()/100;if AtmoSpeedAssist then nF=K end;local o_,p0=aM.computeDistanceAndTime(bc,MaxGameVelocity,av,a:maxForceForward()*nF,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,p1;if not TurnBurn and e6>0 then _,p1=aR.GetAutopilotBrakeDistanceAndTime(e6)else _,p1=aR.GetAutopilotTBBrakeDistanceAndTime(e6)end;local p2=0;local p3=0;if AutopilotCruising or not Autopilot and e6>5 then p3=aM.computeTravelTime(e6,0,AutopilotDistance)elseif a8+o_<AutopilotDistance then p2=AutopilotDistance-(a8+o_)p3=aM.computeTravelTime(8333.0556,0,p2)else local p4=(AutopilotDistance-a8)/o_;o_=AutopilotDistance-a8;p0=p0*p4 end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return p3 elseif AutopilotBraking then return p1 elseif AutopilotCruising then return p3+p1 else return p0+a9+p3 end end;local function p5(l4,p6)if l4==nil then l4=core.g()end;l4=A(l4,5)if p6~=nil and p6 or(oU==nil or oU~=l4)then local e6=ba:len()local p7=g(unit.getData()).maxBrake;if p7~=nil and p7>0 and aq then p7=p7/r(e6/100,0.1,1)p7=p7/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+p7)/2 else LastMaxBrakeInAtmo=p7 end end end;if p7~=nil and p7>0 then LastMaxBrake=p7 end;oU=l4 end end;p5(nil,true)if bi~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bi then aR.cmdCruise(bi)else bi=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then oV()end;if AutopilotTargetName~=nil then local p8=CustomTarget~=nil;local p9=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()p9=p9>1000000 and A(p9/1000000,2).." kTons"or A(p9/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=oZ()if p8 and not Autopilot then aj=(bf-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bf):len()end;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ik=c3(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ik..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..c6(travelTime)..'", "unit":""}')ik=c3(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ik..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..c6(a9)..'", "unit":""}')ik=c3(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ik..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..c6(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",p9)..'", "unit":""}')ik=c3(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ik..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bj and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then aR.cmdThrottle(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else oY()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aP.TenthTick()elseif oT=="oneSecond"then local function pa(gJ)local pb=0;aB=""local pc=aI;local pd=0;local pe=0;local pf=0;local gD=0;local gE=""local pg=core.getElementHitPointsById;for cf in pairs(at)do local oJ=0;local ph=0;ph=j(at[cf])oJ=pg(at[cf])pd=pd+oJ;if oJ<ph then if oJ==0 then pf=pf+1 else pe=pe+1 end;if aJ and#aA==0 then position=vec3(core.getElementPositionById(at[cf]))local bW=position.x;local bX=position.y;local f0=position.z;table.insert(aA,core.spawnArrowSticker(bW,bX,f0+1,"down"))table.insert(aA,core.spawnArrowSticker(bW,bX,f0+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(bW+1,bX,f0,"north"))table.insert(aA,core.spawnArrowSticker(bW+1,bX,f0,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(bW-1,bX,f0,"south"))table.insert(aA,core.spawnArrowSticker(bW-1,bX,f0,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(bW,bX-1,f0,"east"))table.insert(aA,core.spawnArrowSticker(bW,bX-1,f0,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(bW,bX+1,f0,"west"))table.insert(aA,core.spawnArrowSticker(bW,bX+1,f0,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cf])end elseif aJ and#aA>0 and aA[11]==at[cf]then for gy in pairs(aA)do core.deleteSticker(aA[gy])end;aA={}end end;pb=e(pd/pc*100)if pb<100 then gJ[#gJ+1]=bV(0,0,"","pbright txt")gD=e(pb*2.55)gE=f("rgb(%d,%d,%d)",255-gD,gD,0)if pb<100 then gJ[#gJ+1]=bV("50%",1035,"Elemental Integrity: "..pb.."%","txtbig txtmid","fill:"..gE)if pf>0 then gJ[#gJ+1]=bV("50%",1055,"Disabled Modules: "..pf.." Damaged Modules: "..pe,"txtbig txtmid","fill:"..gE)elseif pe>0 then gJ[#gJ+1]=bV("50%",1055,"Damaged Modules: "..pe,"txtbig txtmid","fill:"..gE)end end end end;local function pi()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bz=core.getPlayersOnBoard()bA=core.getDockedConstructs()pi()local gJ={}aP.OneSecond(gJ)if ShouldCheckDamage then pa(gJ)end;ak=table.concat(gJ,"")collectgarbage("collect")elseif oT=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cw=g(dbHud_1.getStringValue("SavedLocations"))if cw~=nil then _G["SavedLocations"]=cw;local fj=-1;local mb;for cf,cg in pairs(SavedLocations)do if cg.name and cg.name=="SatNav Location"then fj=cf;break end end;if fj~=-1 then mb=SavedLocations[fj]fj=-1;for cf,cg in pairs(b[0])do if cg.name and cg.name=="SatNav Location"then fj=cf;break end end;if fj>-1 then b[0][fj]=mb end;aQ.UpdateAtlasLocationsList()a2=mb.name.." position updated"end end;for i=1,#bm do if bm[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bm[i].name)aQ.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif oT=="msgTick"then local gJ={}aP.DisplayMessage(gJ,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif oT=="animateTick"then aU=true;aT=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif oT=="hudTick"then aP.hudtick()elseif oT=="apTick"then aR.APTick()elseif oT=="radarTick"then aS.UpdateRadar()elseif oT=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function pj(pk,nO)local pl=vec3()local pm=vec3()if pk==axisCommandId.longitudinal then pl=vec3(core.getConstructOrientationForward())pm=b8 elseif pk==axisCommandId.vertical then pl=vec3(core.getConstructOrientationUp())pm=b7 elseif pk==axisCommandId.lateral then pl=vec3(core.getConstructOrientationRight())pm=b9 else return vec3()end;local pn=vec3(core.getWorldGravity())local po=pn:dot(pm)local pp=vec3(core.getWorldAirFrictionAcceleration())local pq=pp:dot(pm)local pr=ba:dot(pl)local ps=nO*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(ps-pr)local pt=targetSpeedPID2:get()local pu=(pt-pq-po)*pm;return pu end;local function pv(pk,nO)local pl=vec3()local pm=vec3()if pk==axisCommandId.longitudinal then pl=vec3(core.getConstructOrientationForward())pm=b8 elseif pk==axisCommandId.vertical then pl=vec3(core.getConstructOrientationUp())pm=b7 elseif pk==axisCommandId.lateral then pl=vec3(core.getConstructOrientationRight())pm=b9 else return vec3()end;local pn=vec3(core.getWorldGravity())local po=pn:dot(pm)local pp=vec3(core.getWorldAirFrictionAcceleration())local pq=pp:dot(pm)local pr=ba:dot(pl)local ps=nO*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(ps-pr)local pt=targetSpeedPID:get()local pu=(pt-pq-po)*pm;return pu end;local function pw(px,gM,m3)local py=px:cross(m3):normalize_inplace()local hy=math.acos(r(py:dot(-gM),-1,1))*constants.rad2deg;if py:cross(-gM):dot(m3)<0 then hy=-hy end;return hy end;if antigrav and not ExternalAGG then if not bh and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bj=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bj and O then aR.cmdThrottle(0)O=false elseif not bj and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local pz=r(T+U+system.getControlDeviceForwardInput(),-1,1)local pA=r(W+Z+system.getControlDeviceYawInput(),-1,1)local pB=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local pC=Y;bd=vec3(core.getWorldVertical())if bd==nil or bd:len()==0 then bd=(planet.center-bf):normalize()end;b7=vec3(core.getConstructWorldOrientationUp())b8=vec3(core.getConstructWorldOrientationForward())b9=vec3(core.getConstructWorldOrientationRight())bb=vec3(core.getWorldVelocity())ba=vec3(core.getVelocity())bf=vec3(core.getConstructWorldPos())av=core.getConstructMass()bc=vec3(bb):len()be=-bd:dot(bb)bl=getRoll(bd,b8,b9)local pD=bl/180*math.pi;local pE=math.cos(pD)local pF=math.sin(pD)bk=pw(bd,b8,b9*pE+b7*pF)local pG=bb:normalize()local pH=d(bl)local pI=utils.sign(bl)local pJ=vec3(core.getWorldAngularVelocity())local pK=pz*pitchSpeedFactor*b9+pA*rollSpeedFactor*b8+pB*yawSpeedFactor*b7;if aV==true and bd:len()>0.01 then local pL=d(aY-bl)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and pL>0 or ar>0.0 and pL<autoRollRollThreshold and autoRollPreference)and pA==0 and d(bk)<85 then local pM=aY;local pN=autoRollFactor;if ar==0 then pN=pN/4;aY=0;pM=0 end;if rollPID==nil then rollPID=pid.new(pN*0.01,0,pN*0.1)end;rollPID:inject(pM-bl)local pO=rollPID:get()pK=pK+pO*b8 end end;local pP=1;local pQ=0;local pR=1;local pS=system.getMouseWheel()if pS>0 then bF()elseif pS<0 then bF(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bj then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aZ/3.6-bb:dot(b8))local pT=throttlePID:get()N=r(pT,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-aZ/3.6)local pU=r(brakePID:get(),0,1)if ar>0 and be<-80 or ar>0.005 then L=pU end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pV=''local pW=vec3()local pX=pj(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pX,pQ)local pY='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pY=pY..ExtraLongitudeTags end;local pZ=s:getAxisCommandType(axisCommandId.longitudinal)local p_=s:composeAxisAccelerationFromThrottle(pY,axisCommandId.longitudinal)local q0=pv(axisCommandId.lateral,LeftAmount*1000)pV=pV..' , '.."lateral airfoil , lateral ground "pW=pW+q0;if pW:len()>constants.epsilon then a:setEngineForceCommand(pV,pW,pQ,'','','',pR)end;a:setEngineForceCommand(pY,p_,pP)local q1='thrust analog vertical fueled 'local q2='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then q2=q2 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then q1=q1 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(q1,pX,pP)else a:setEngineForceCommand(q1,vec3(),pP)end;if LeftAmount~=0 then a:setEngineForceCommand(q2,q0,pP)else a:setEngineForceCommand(q2,vec3(),pP)end;if pC==0 then pC=L end;local q3=-pC*(brakeSpeedFactor*bb+brakeFlatFactor*pG)a:setEngineForceCommand('brake',q3)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local nO=unit.getAxisCommandValue(0)if not bj then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-nO/3.6)local pU=r(brakePID:get(),0,1)pC=r(pC+pU,0,1)end;local q3=-pC*(brakeSpeedFactor*bb+brakeFlatFactor*pG)a:setEngineForceCommand('brake',q3)local pV=''local pW=vec3()local q4=false;local pY='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pY=pY..ExtraLongitudeTags end;local pZ=s:getAxisCommandType(axisCommandId.longitudinal)if pZ==axisCommandType.byThrottle then local p_=s:composeAxisAccelerationFromThrottle(pY,axisCommandId.longitudinal)a:setEngineForceCommand(pY,p_,pP)elseif pZ==axisCommandType.byTargetSpeed then local p_=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pV=pV..' , '..pY;pW=pW+p_;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then q4=true end end;local q2='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then q2=q2 ..ExtraLateralTags end;local q5=s:getAxisCommandType(axisCommandId.lateral)if q5==axisCommandType.byThrottle then local q6=s:composeAxisAccelerationFromThrottle(q2,axisCommandId.lateral)a:setEngineForceCommand(q2,q6,pP)elseif q5==axisCommandType.byTargetSpeed then local q0=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pV=pV..' , '..q2;pW=pW+q0 end;local q1='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then q1=q1 ..ExtraVerticalTags end;local q7=s:getAxisCommandType(axisCommandId.vertical)if q7==axisCommandType.byThrottle then local pX=s:composeAxisAccelerationFromThrottle(q1,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(q1,pX,pP,'airfoil','ground','',pR)else a:setEngineForceCommand(q1,vec3(),pP)a:setEngineForceCommand('airfoil vertical',pX,pP,'airfoil','','',pR)a:setEngineForceCommand('ground vertical',pX,pP,'ground','','',pR)end elseif q7==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),pP)end;local q8=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pV=pV..' , '..q1;pW=pW+q8 end;if pW:len()>constants.epsilon then if Y~=0 or q4 or d(pG:dot(b8))<0.5 then pV=pV..', brake'end;a:setEngineForceCommand(pV,pW,pQ,'','','',pR)end end;local q9=torqueFactor*(pK-pJ)local qa=vec3(core.getWorldAirFrictionAngularAcceleration())q9=q9-qa;a:setEngineTorqueCommand('torque',q9,pP,'airfoil','','',pR)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local e6=ba:len()local qb=0.15;if not bj then local qc=s:getTargetSpeed(axisCommandId.longitudinal)if e6*3.6>qc*(1-qb)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e6*3.6<qc*(1-qb)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nF=unit.getThrottle()if AtmoSpeedAssist then nF=K*100 end;local nO=nF/100;if k==0 then nO=nO*MaxGameVelocity;if e6>=nO*(1-qb)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e6<nO*(1-qb)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nZ=e(aZ)nO=nO*nZ/3.6;if e6>=nO*(1-qb)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e6<nO*(1-qb)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fG=coroutine.status(beginSetup)if fG=="suspended"then local cB,fH=coroutine.resume(beginSetup)if fH then system.print("ERROR STARTUP: "..fH)end elseif fG=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aT and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(qd)local function qe(bG)local D=1;local function qf(qg,bG)local qh={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local qi=qg;for _,cg in ipairs(qh)do if bG and qi>cg then qg=cg elseif qg<cg and not bG then qg=cg;break end end;return qg end;if bG then D=-1 end;if not ExternalAGG and bh then if a1 and bG then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then b2=qf(b2,bG)else b2=b2+D*a3 end;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=qf(HoldAltitude,bG)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function qj(qk)if not aq then a2="Flight Assist in Atmo only"return end;local cm=type(qk)if bp==nil then if cm=="table"then if Autopilot or VectorToTarget then aR.ToggleAutopilot()end;bI("180On","BR")elseif qk==1 then bI("bnkLft","BR")else bI("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aR.ToggleAltitudeHold()if cm~="table"then qk=qk+1 end end;bp=qk else bI("180Off","BR")bp=nil end end;if qd=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aR.cmdThrottle(0)if vBooster or hover then if aq and ao==-1 then bI("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aV=true;GearExtended=false else if S then bI("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bI("grOut","LG",1)a.control.extendLandingGears()end else if S then bI("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif qd=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif qd=="forward"then T=T-1 elseif qd=="backward"then if AltIsOn then qj(-bb*5000)else T=T+1 end elseif qd=="left"then if AltIsOn then qj(1)else W=W-1 end elseif qd=="right"then if AltIsOn then qj(3)else W=W+1 end elseif qd=="yawright"then X=X-1 elseif qd=="yawleft"then X=X+1 elseif qd=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif qd=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif qd=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif qd=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif qd=="groundaltitudeup"then qe()elseif qd=="groundaltitudedown"then qe(true)elseif qd=="option1"then toggleView=false;if AltIsOn and a1 then local ql=""for i=1,#bz do ql=ql.."| Name: "..system.getPlayerName(bz[i]).." Mass: "..A(core.getBoardedPlayerMass(bz[i])/1000,1).."t "end;system.print("Onboard: "..ql)return end;aQ.adjustAutopilotTargetIndex()elseif qd=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bz do core.forceDeboard(bz[i])end;a2="Deboarded All Passengers"return end;aQ.adjustAutopilotTargetIndex(1)elseif qd=="option3"then local function qm()aC=not aC;if not aC then bI("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bI("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local ql=""for i=1,#bA do ql=ql.."| ID: "..bA[i].." Mass: "..A(core.getDockedConstructMass(bA[i])/1000,1).."t "end;system.print("Docked Ships: "..ql)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;qm()toggleView=false elseif qd=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#bA do core.forceUndock(bA[i])end;a2="Undocked all ships"return end;bp=nil;aR.ToggleAutopilot()elseif qd=="option5"then toggleView=false;aR.ToggleLockPitch()elseif qd=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local qn=shield_1.getVentingCooldown()if qn>0 then a2="Cannot vent again for "..qn.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aR.ToggleAltitudeHold()elseif qd=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif qd=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bI("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bI("gsOn","GS")end;toggleView=false elseif qd=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aR.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bI("gyOn","GA")else bI("gyOff","GA")end end;toggleView=false elseif qd=="lshift"then bw=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;aU=false;aT=false end elseif qd=="brake"then if BrakeToggleStatus or AltIsOn then aR.BrakeToggle()elseif not BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=true end elseif qd=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif qd=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif qd=="stopengines"then local function qo()if E-F<1.5 then bI("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bp=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;aV=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;qo()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aR.cmdThrottle(0)else aR.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then aR.cmdCruise(AtmoSpeedLimit)else aR.cmdCruise(MaxGameVelocity*3.6)end end end elseif qd=="speedup"then bF()elseif qd=="speeddown"then bF(true)elseif qd=="antigravity"and not ExternalAGG then if antigrav~=nil then aR.ToggleAntigrav()end end end;function script.onActionStop(qd)local function qp()if not ExternalAGG and bh then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if qd=="forward"then T=0 elseif qd=="backward"then T=0 elseif qd=="left"then if bp then if bp==2 then bp=-2 else bp=-1 end end;W=0 elseif qd=="right"then if bp then if bp==4 then bp=-2 else bp=-1 end end;W=0 elseif qd=="yawright"then X=0 elseif qd=="yawleft"then X=0 elseif qd=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif qd=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif qd=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qd=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qd=="groundaltitudeup"then qp()toggleView=false elseif qd=="groundaltitudedown"then qp()toggleView=false elseif qd=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then aU=false;aT=false end;a1=false elseif qd=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=false end end elseif qd=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(qd)local function qq(bG)local D=1;if bG then D=-1 end;if not ExternalAGG and bh then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then b2=b2+D*a5;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function qr(bG)local D=1;if bG then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if qd=="groundaltitudeup"then if not a1 then qq()end elseif qd=="groundaltitudedown"then if not a1 then qq(true)end elseif qd=="speedup"then qr()elseif qd=="speeddown"then qr(true)end end;function script.onInputText(bY)local function qs(qt,ea,hu)local function qu(ea)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu='::pos{'..B..','..B..','..B..','..B..','..B..'}'local cI,cJ,cP,cQ,cR=o(ea,cu)if cI=="0"and cJ=="0"then return vec3(z(cP),z(cQ),z(cR))end;cQ=math.rad(cQ)cP=math.rad(cP)local planet=b[z(cI)][z(cJ)]local dC=math.cos(cP)local qv=vec3(dC*math.cos(cQ),dC*math.sin(cQ),math.sin(cP))return planet.center+(planet.radius+cR)*qv end;local position=qu(ea)return aQ.AddNewLocation(qt,position,hu)end;local i;local qw,qx=nil,nil;local qy="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(bY," ")qw=bY;if i~=nil then qw=string.sub(bY,0,i-1)qx=string.sub(bY,i+1)end;if qw=="/help"or qw=="/commands"then for ll in string.gmatch(qy,"([^\n]+)")do system.print(ll)end;return elseif qw=="/setname"then if qx==nil or qx==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aQ.UpdatePosition(qx)else a2="Select a saved target to rename first"end elseif shield_1 and qw=="/resist"then if qx==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu=B..', '..B..', '..B..', '..B;local qz,qA,qB,qC=o(qx,cu)if qC==nil or qz+qA+qB+qC>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(qz,qA,qB,qC)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif qw=="/addlocation"or string.find(bY,"::pos")~=nil then local hu=false;local qt="0-Temp"if qx==nil or qx==""then qx=qw;hu=true end;i=string.find(qx,"::")if not hu then qt=string.sub(qx,1,i-2)end;local ea=string.sub(qx,i)qs(qt,ea,hu)elseif qw=="/agg"then if qx==nil or qx==""then a2="Usage: /agg targetheight"return end;qx=z(qx)if qx<1000 then qx=1000 end;AntigravTargetAltitude=qx;a2="AGG Target Height set to "..qx elseif qw=="/G"then if qx==nil or qx==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if qx=="dump"then for cf,cg in pairs(bO())do if type(_G[cg])=="boolean"then if _G[cg]==true then system.print(cg.." true")else system.print(cg.." false")end elseif _G[cg]==nil then system.print(cg.." nil")else system.print(cg.." ".._G[cg])end end;return end;i=string.find(qx," ")local qD=string.sub(qx,0,i-1)local qE=string.sub(qx,i+1)for cf,cg in pairs(bO())do if cg==qD then a2="Variable "..qD.." changed to "..qE;local qF=type(_G[cg])if qF=="number"then qE=z(qE)if cg=="AtmoSpeedLimit"then aZ=qE end elseif qF=="boolean"then if string.lower(qE)=="true"then qE=true else qE=false end end;_G[cg]=qE;return end end;a2="No such global variable: "..qD elseif qw=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aQ.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif qw=="/copydatabank"then if dbHud_2 then cb(true)else a2="Spare Databank required to copy databank"end elseif qw=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aR.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(cJ)if bu[1]and not aq and not bn then unit.setTimer("contact",0.1)end end;function script.onLeave(cJ)if bu[1]and CollisionSystem then if#bq>650 then cJ=tostring(cJ)bq[cJ]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
