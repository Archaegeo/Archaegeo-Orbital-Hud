name: ArchHud - Archaegeo v1.516 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        WipeDamage = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 0 --export:
        OrbitMapY = 25 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.516;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local z=math.sqrt;local A=tonumber;local core=core;local function B(C,D)local E=10^(D or 0)return e(C*E+0.5)/E end;local F=q()local G=q()local H=13;local I=SafeR;local J=SafeB;local K=SafeG;local L=0;local M=0;local N=false;local O=0;local P=false;local Q=false;local R=55;local S=false;local T=false;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=0;local a1=false;local a2=false;local a3="empty"local a4=5;local a5=5;local a6=a4;local a7=a5;local a8=false;local a9=0;local aa=0;local ab=0;local ac=0;local ad=nil;local ae=0;local af=0;local ag=0;local ah=0;local ai=0;local aj=3;local ak=0;local al=""local am=false;local an=false;local ao=false;local ap=-1;local aq=""local ar=k()>0;local as=k()local at=core.getAltitude()local au=core.getElementIdList()local av=q()local aw=core.getConstructMass()local ax=false;local ay=nil;local az=[[rgb(]]..e(I+0.5)..","..e(K+0.5)..","..e(J+0.5)..[[)]]local aA=[[rgb(]]..e(I*0.9+0.5)..","..e(K*0.9+0.5)..","..e(J*0.9+0.5)..[[)]]local aB={}local aC=0;local aD=0;local aE=""local aF=true;local aG={}local aH=ResolutionX;local aI=ResolutionY;local aJ={}local aK={}local aL={}local aM=0;local aN=false;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=nil;local a_=false;local b0=false;local b1=autoRollPreference;local b2=LandingGearGroundHeight;local b3=false;local b4=q()local b5=0;local b6=0;local b7=0;local b8=AtmoSpeedLimit;local b9=0;local ba=nil;local bb=0;local bc=0;local bd=false;local be=false;local bf={VectorToTarget=false}local bg=false;local bh=0;local bi=nil;local bj=false;local bk=false;local bl=false;local bm=false;local bn=0;local bo=vec3(core.getConstructWorldOrientationUp())local bp=vec3(core.getConstructWorldOrientationForward())local bq=vec3(core.getConstructWorldOrientationRight())local br=vec3(core.getVelocity())local bs=vec3(core.getWorldVelocity())local bt=vec3(bs):len()local bu=vec3(core.getWorldVertical())local bv=-bu:dot(bs)local bw=vec3(core.getConstructWorldPos())local bx=0;local by=false;local bz=false;local bA=nil;local bB=true;local bC=0;local bD=0;local bE=false;local bF={}local bG=showHud;local bH={}local bI=false;local bJ=50000;local bK=""local bL=nil;local bM={}local bN=unit.getClosestPlanetInfluence()>0 or at>0 and at<200000;local bO=false;local bP=nil;local bQ={}local bR="Atmo"local bS=false;local bT=0;local bU={}function p(bV)system.print(F..": "..bV)end;local function bW(bX)local E=1;if bX then E=-1 end;if not a2 then if AtmoSpeedAssist and not AltIsOn and ax then local bY=L;L=B(r(L+E*speedChangeLarge/100,-1,1),2)if L>=0 and bY<0 then L=0;ax=false end elseif AltIsOn then if as>0 or Reentry then b8=r(b8+E*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+E*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,E*speedChangeLarge)end else if Autopilot or VectorToTarget or an or IntoOrbit then bT=bT+1*E*-1;if bT>#bH then bT=1 end;if bT<1 then bT=#bH end else if not bX then E=1 else E=nil end;aX.adjustAutopilotTargetIndex(E)end end end;local function bZ(b_)local c0,c1,c2=aS:getPlanetarySystem(0):castIntersections(bw,b_,function(c3)if c3.noAtmosphericDensityAltitude>0 then return c3.radius+c3.noAtmosphericDensityAltitude else return c3.radius+c3.surfaceMaxAltitude*1.5 end end)local c4=c1;if c2~=nil and c1~=nil then c4=math.min(c2,c1)end;if c4~=nil then return c0,c4 else return nil,nil end end;local function c5(c6,c7,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..c6 .."|"..c7 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..c6 .."|"..c7 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..c6 .."|"..c7 .."|"..soundVolume)end end;local function c8(c9,ca)for i=1,#ca do c9[#c9+1]=ca[i]end;return c9 end;local function cb(cc)local cd={}local ce={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local cf={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization","WipeDamage"}local cg={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local ch={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not cc then c8(cd,ce)c8(cd,cf)c8(cd,cg)c8(cd,ch)return cd elseif cc=="boolean"then return ce elseif cc=="handling"then return cf elseif cc=="hud"then return cg elseif cc=="physics"then return ch end end;local function ci(cj,y,ck,cl,cm)if cl==nil then cl=""end;if cm==nil then cm=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cl,cj,y,cm,ck)end;local function cn(co,cp)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not cp then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,co)L=r(B(co*100,0)/100,-1,1)bA=nil end;local function cq(co,cp)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cp then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,co)bA=co end;local function cs(ct,cu)if ct==0 then return d(cu)<1e-09 end;if cu==0 then return d(ct)<1e-09 end;return d(ct-cu)<math.max(d(ct),d(cu))*epsilon end;local function cv(ak,cw)local cx=ak>100000;if cw==nil then cw=1 end;if cx then return B(ak/1000/200,cw).."SU"elseif ak<1000 then return B(ak,cw).."M"else return B(ak/1000,cw).."KM"end end;local function cy()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b1=true;ag=0;if ar and ap==-1 then BrakeLanding=false;AltitudeHold=true;ag=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cq(e(b8))end else bj=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cz()bj=false;bb=nil;bc=nil;bn=0;if as==0 then if IntoOrbit then c5("orOff","AP")IntoOrbit=false;bd=false;bi=nil;b1=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bf.VectorToTarget=false;bf.AutopilotAlign=false;bg=false elseif bN then c5("orOn","AP")IntoOrbit=true;b1=true;if bi==nil then bi=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a3="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bd=false;bi=nil;b1=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bf.VectorToTarget=false;bf.AutopilotAlign=false;bg=false end end;local function cA()if F-b6<1.5 then if planet.hasAtmosphere then if as>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;c5("11","EP")else if bN then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bh=HoldAltitude;bg=true;if not IntoOrbit then cz()end;bd=true end end;b6=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b6=F end;if bN and as==0 then bh=at;bg=true;bd=true;cz()if IntoOrbit then b6=F else b6=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a1=false;b1=true;LockPitch=nil;bj=false;if ap~=-1 and bt<20 then c5("lfs","LS")AutoTakeoff=true;if b6>-1 then HoldAltitude=at+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and by then cy()end else c5("altOn","AH")AutoTakeoff=false;if b6>-1 then if bN then HoldAltitude=at end end;if VertTakeOff then cy()end end;if an then HoldAltitude=100000 end else c5("altOff","AH")if IntoOrbit then cz()end;if VertTakeOff then cy()end;b1=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b6=0 end end;local function cB(cC)if cC then an=false;Autopilot=false;AutopilotRealigned=false;Q=false;HoldAltitude=at;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bL=nil;if not bz then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cy()end;if IntoOrbit then cz()end;b1=autoRollPreference;am=false;ao=false;ag=0 end;local function cD()local function cE(SpaceTarget)bO=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cA()end end;VectorStatus="Proceeding to Waypoint"end;if F-b7<1.5 and as>0 then if not bm then a3="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if as>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;c5("orH","OH")end;b7=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b7=F end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not an and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<aw then a3="WARNING: Heavy Loads may affect autopilot performance."aj=5 end;aX.UpdateAutopilotTarget()aY.showWayPoint(ad,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then c5("apSpc","AP")if as~=0 then an=true;cA()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if as>0 then if not VectorToTarget then c5("vtt","AP")cE(SpaceTarget)end else c5("apOn","AP")if not(ad.name==planet.name and at<AutopilotTargetOrbit*1.5)then bj=false;Autopilot=true elseif not ar then if IntoOrbit then cz()end;bh=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=true;bf.AutopilotAlign=true;bf.VectorToTarget=true;bd=false;if not IntoOrbit then cz()end end end else c5("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if as~=0 then an=true;cA()else Autopilot=true end end elseif as==0 then if CustomTarget==nil and(ad.name==planet.name and bN)and not IntoOrbit then WaypointSet=false;bj=false;bd=false;cz()else c5("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a1=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;Q=false;LockPitch=nil;WaypointSet=false end else c5("apP","AP")an=true;cA()end else c5("apOff","AP")cB(1)end end;local function cF()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b1=autoRollPreference end;if BrakeIsOn then c5("bkOn","B",1)cB()else c5("bkOff","B",1)end end;local function cG()if Reentry then a3="Re-Entry cancelled"c5("reOff","RE")Reentry=false;b1=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a3="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"aj=5 elseif not S then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b1=true;BrakeIsOn=false;a3="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b8;c5("par","RE")else Reentry=true;AltitudeHold=true;b1=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local ck=cv(HoldAltitude)a3="Beginning Re-entry.  Target speed: "..b8 .." Target Altitude: "..ck;c5("glide","RE")cq(e(b8))end;AutoTakeoff=false end;local function cH()if antigrav and not ExternalAGG then if bz then c5("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=at end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;c5("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cI(cJ)local cK=0;local cL=0;local cM=0;if cJ<60 then cJ=e(cJ)elseif cJ<3600 then cK=e(cJ/60)cJ=e(cJ%60)elseif cJ<86400 then cL=e(cJ/3600)cK=e(cJ%3600/60)else cM=e(cJ/86400)cL=e(cJ%86400/3600)end;if cM>0 then return cM.."d "..cL.."h "elseif cL>0 then return cL.."h "..cK.."m "elseif cK>0 then return cK.."m "..cJ.."s"elseif cJ>0 then return cJ.."s"else return"0s"end end;local function cN(cO)local function cP(cQ)for cR,cS in pairs(cQ)do dbHud_1.setStringValue(cS,h(_G[cS]))if cO and dbHud_2 then dbHud_2.setStringValue(cS,h(_G[cS]))end end end;if dbHud_1 then cP(c)cP(cb())system.print("Saved Variables to Datacore")if cO and dbHud_2 then a3="Databank copied.  Remove copy when ready."end end end;local function cT()local function cU(cV)return type(cV)=='number'end;local function cW(cV)return type(A(cV))=='number'end;local function cX(cY)return type(cY)=='table'end;local function cZ(c_)return type(c_)=='string'end;local function d0(cS)return cX(cS)and cU(cS.x and cS.y and cS.z)end;local function d1(d2)return cX(d2)and cU(d2.latitude and d2.longitude and d2.altitude and d2.id and d2.systemId)end;local d3=math.pi/180;local d4=180/math.pi;local epsilon=1e-10;local C=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d5='::pos{'..C..','..C..','..C..','..C..','..C..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function d6(cV)local d7=string.gsub(string.reverse(f('%.4f',cV)),'^0*%.?','')return d7==''and'0'or string.reverse(d7)end;local function d8(d9)if d0(d9)then return f('{x=%.3f,y=%.3f,z=%.3f}',d9.x,d9.y,d9.z)end;if cX(d9)and not getmetatable(d9)then local da={}local db=next(d9)if type(db)=='nil'or db==1 then da=d9 else for cR,cS in pairs(d9)do local co=d8(cS)if type(cR)=='number'then table.insert(da,f('[%s]=%s',cR,co))else table.insert(da,f('%s=%s',cR,co))end end end;return f('{%s}',table.concat(da,','))end;if cZ(d9)then return f("'%s'",d9:gsub("'",[[\']]))end;return tostring(d9)end;local dc={}dc.__index=dc;dc.__tostring=function(d9,dd)local de={}for cR in pairs(d9)do table.insert(de,cR)end;table.sort(de)local da={}for _,cR in ipairs(de)do local co=d8(d9[cR])if type(cR)=='number'then table.insert(da,f('[%s]=%s',cR,co))else table.insert(da,f('%s=%s',cR,co))end end;if dd then return f('%s%s',dd,table.concat(da,',\n'..dd))end;return f('{%s}',table.concat(da,','))end;dc.__eq=function(df,dg)return df.systemId==dg.systemId and df.id==dg.id and cs(df.radius,dg.radius)and cs(df.center.x,dg.center.x)and cs(df.center.y,dg.center.y)and cs(df.center.z,dg.center.z)and cs(df.GM,dg.GM)end;local function dh(di,dj,dk,dl,dm)assert(cW(di),'Argument 1 (systemId) must be a number:'..type(di))assert(cW(dj),'Argument 2 (id) must be a number:'..type(dj))assert(cW(dk),'Argument 3 (radius) must be a number:'..type(dk))assert(cX(dl),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dl))assert(cW(dm),'Argument 5 (GM) must be a number:'..type(dm))return setmetatable({systemId=A(di),id=A(dj),radius=A(dk),center=vec3(dl),GM=A(dm)},dc)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,d6(p.latitude*d4),d6(p.longitude*d4),d6(p.altitude))end;MapPosition.__eq=function(df,dg)return df.id==dg.id and df.systemId==dg.systemId and cs(df.latitude,dg.latitude)and cs(df.altitude,dg.altitude)and(cs(df.longitude,dg.longitude)or cs(df.latitude,math.pi/2)or cs(df.latitude,-math.pi/2))end;local function dn(dp,dj,dq,dr,ds)local di=dp;if cZ(dp)and not dr and not ds and not dj and not dq then di,dj,dq,dr,ds=o(dp,d5)assert(di,'Argument 1 (position string) is malformed.')else assert(cW(di),'Argument 1 (systemId) must be a number:'..type(di))assert(cW(dj),'Argument 2 (id) must be a number:'..type(dj))assert(cW(dq),'Argument 3 (latitude) must be in degrees:'..type(dq))assert(cW(dr),'Argument 4 (longitude) must be in degrees:'..type(dr))assert(cW(ds),'Argument 5 (altitude) must be in meters:'..type(ds))end;di=A(di)dj=A(dj)dq=A(dq)dr=A(dr)ds=A(ds)if dj==0 then return setmetatable({latitude=dq,longitude=dr,altitude=ds,id=dj,systemId=di},MapPosition)end;return setmetatable({latitude=d3*r(dq,-90,90),longitude=d3*(dr%360),altitude=ds,id=dj,systemId=di},MapPosition)end;local dt={}dt.__index=dt;dt.__tostring=function(d9,dd)local du=dd and dd..'  'local dv={}local de={}for cR in pairs(d9)do table.insert(de,cR)end;table.sort(de)for _,dw in ipairs(de)do bdy=d9[dw]local dx=dc.__tostring(bdy,du)if dd then table.insert(dv,f('[%s]={\n%s\n%s}',dw,dx,dd))else table.insert(dv,f('  [%s]=%s',dw,dx))end end;if dd then return f('\n%s%s%s',dd,table.concat(dv,',\n'..dd),dd)end;return f('{\n%s\n}',table.concat(dv,',\n'))end;local function dy(dz)local b={}local pid;for _,cS in pairs(dz)do local dj=cS.planetarySystemId;if type(dj)~='number'then error('Invalid planetary system ID: '..tostring(dj))elseif pid and dj~=pid then error('Mistringmatch planetary system IDs: '..dj..' and '..pid)end;local dA=cS.bodyId;if type(dA)~='number'then error('Invalid body ID: '..tostring(dA))elseif b[dA]then error('Duplicate body ID: '..tostring(dA))end;setmetatable(cS.center,getmetatable(vec3.unit_x))b[dA]=setmetatable(cS,dc)pid=dj end;return setmetatable(b,dt)end;aR={}local function dB(dz)return setmetatable({galaxyAtlas=dz or{}},aR)end;aR.__index=function(cY,i)if type(i)=='number'then local system=cY.galaxyAtlas[i]return dy(system)end;return rawget(aR,i)end;aR.__pairs=function(d9)return function(cY,cR)local dC,nv=next(cY,cR)return dC,nv and dy(nv)end,d9.galaxyAtlas,nil end;aR.__tostring=function(d9)local dD={}for _,dE in pairs(d9 or{})do local dF=dE:getPlanetarySystemId()local dG=dt.__tostring(dE,'    ')table.insert(dD,f('  [%s]={%s\n  }',dF,dG))end;return f('{\n%s\n}\n',table.concat(dD,',\n'))end;aR.BodyParameters=dh;aR.MapPosition=dn;aR.PlanetarySystem=dy;function aR.createBodyParameters(di,dj,dH,dI,dJ,dK,dL)assert(cW(di),'Argument 1 (systemId) must be a number:'..type(di))assert(cW(dj),'Argument 2 (id) must be a number:'..type(dj))assert(cW(dH),'Argument 3 (surfaceArea) must be a number:'..type(dH))assert(cX(dI),'Argument 4 (aPosition) must be an array or vec3:'..type(dI))assert(cX(dJ),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dJ))assert(cW(dK),'Argument 6 (altitude) must be in meters:'..type(dK))assert(cW(dL),'Argument 7 (gravityAtPosition) must be number:'..type(dL))local dk=z(dH/4/math.pi)local ak=dk+dK;local dM=vec3(dI)+ak*vec3(dJ)local dm=dL*ak*ak;return dh(di,dj,dk,dM,dm)end;aR.isMapPosition=d1;function aR:getPlanetarySystem(dp)if i==nil then i=0 end;if nv==nil then nv=0 end;local di=dp;if d1(dp)then di=dp.systemId end;if type(di)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dt then system=dy(system)end;return system end end end;function dt:sizeCalculator(c3)return 1.05*c3.radius end;function dt:castIntersections(dN,dO,dP,dQ,dR,dS)local dT={}local dU=dR or self;for _,c3 in pairs(dU)do table.insert(dT,c3)end;if not dS then table.sort(dT,function(dV,dW)return(dV.center-dN):len()<(dW.center-dN):len()end)end;local dX=dO:normalize()for _,c3 in ipairs(dT)do local dY=c3.center-dN;local dk=self:sizeCalculator(c3)local dZ=dY:dot(dX)local d_=dZ^2-(dY:len2()-dk^2)if d_>=0 then local e0=z(d_)local c1=dZ+e0;local c2=dZ-e0;if c2>0 then return c3,c1,c2 elseif c1>0 then return c3,c1,nil end end end;return nil,nil,nil end;function dt:closestBody(e1)assert(type(e1)=='table','Invalid coordinates.')local e2,c3;local e3=vec3(e1)for _,e4 in pairs(self)do local e5=(e4.center-e3):len2()if(not c3 or e5<e2)and e4.name~="Space"then c3=e4;e2=e5 end end;return c3 end;function dt:convertToBodyIdAndWorldCoordinates(dp)local e6=dp;if cZ(dp)then e6=dn(dp)end;if e6.id==0 then return 0,vec3(e6.latitude,e6.longitude,e6.altitude)end;local e4=self:getBodyParameters(e6)if e4 then return e6.id,e4:convertToWorldCoordinates(e6)end end;function dt:getBodyParameters(dp)local dj=dp;if d1(dp)then dj=dp.id end;assert(cW(dj),'Argument 1 (id) must be a number:'..type(dj))return self[dj]end;function dt:getPlanetarySystemId()local _,cS=next(self)return cS and cS.systemId end;function dc:convertToMapPosition(dl)assert(cX(dl),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dl))local e7=vec3(dl)if self.id==0 then return setmetatable({latitude=e7.x,longitude=e7.y,altitude=e7.z,id=0,systemId=self.systemId},MapPosition)end;local e8=e7-self.center;local ak=e8:len()local ds=ak-self.radius;local dq=0;local dr=0;if not cs(ak,0)then local e9=n(e8.y,e8.x)dr=e9>=0 and e9 or 2*math.pi+e9;dq=math.pi/2-math.acos(e8.z/ak)end;return setmetatable({latitude=dq,longitude=dr,altitude=ds,id=self.id,systemId=self.systemId},MapPosition)end;function dc:convertToWorldCoordinates(dp)local e6=cZ(dp)and dn(dp)or dp;if e6.id==0 then return vec3(e6.latitude,e6.longitude,e6.altitude)end;assert(d1(e6),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(e6.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(e6.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local ea=math.cos(e6.latitude)return self.center+(self.radius+e6.altitude)*vec3(ea*math.cos(e6.longitude),ea*math.sin(e6.longitude),math.sin(e6.latitude))end;function dc:getAltitude(dl)return(vec3(dl)-self.center):len()-self.radius end;function dc:getDistance(dl)return(vec3(dl)-self.center):len()end;function dc:getGravity(dl)local eb=self.center-vec3(dl)local ec=eb:len2()return self.GM/ec*eb/z(ec)end;return setmetatable(aR,{__call=function(_,...)return dB(...)end})end;local function ed()local aT={}local ee=30000000/3600;local ef=ee*ee;local eg=100;function aT.computeAccelerationTime(eh,ei,ej)local ek=ee*math.asin(eh/ee)return(ee*math.asin(ej/ee)-ek)/ei end;function aT.computeDistanceAndTime(eh,ej,el,em,en,eo)en=en or 0;eo=eo or 0;local ep=eh<=ej;local eq=em*(ep and 1 or-1)/el;local er=-eo/el;local es=eq+er;if ep and es<=0 or not ep and es>=0 then return-1,-1 end;local et,eu=0,0;if eq~=0 and en>0 then local ek=math.asin(eh/ee)local ev=math.pi*(eq/2+er)local ew=eq*en;local ex=ee*math.pi;local cS=function(cY)local ey=(ev*cY-ew*math.sin(math.pi*cY/2/en)+ex*ek)/ex;local ez=math.tan(ey)return ee*ez/z(ez*ez+1)end;local eA=ep and function(c_)return c_>=ej end or function(c_)return c_<=ej end;eu=2*en;if eA(cS(eu))then local eB=0;while d(eu-eB)>0.5 do local cY=(eu+eB)/2;if eA(cS(cY))then eu=cY else eB=cY end end end;local eC=eh;local eD=eu/eg;for eE=1,eg do local eF=cS(eE*eD)et=et+(eF+eC)*eD/2;eC=eF end;if eu<2*en then return et,eu end;eh=eC end;local ek=ee*math.asin(eh/ee)local F=(ee*math.asin(ej/ee)-ek)/es;local eG=ef*math.cos(ek/ee)/es;local ak=eG-ef*math.cos((es*F+ek)/ee)/es;return ak+et,F+eu end;function aT.computeTravelTime(eh,ei,ak)if ak==0 then return 0 end;if ei>0 then local ek=ee*math.asin(eh/ee)local eG=ef*math.cos(ek/ee)/ei;return(ee*math.acos(ei*(eG-ak)/ef)-ek)/ei end;if eh==0 then return-1 end;assert(eh>0,'Acceleration and initial speed are both zero.')return ak/eh end;return aT end;local function eH()local vec3=require('cpml.vec3')local cT=cT()local function cZ(c_)return type(c_)=='string'end;local function cX(cY)return type(cY)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(ds)assert(self.body)local ak=ds+self.body.radius;if not cs(ak,0)then local orbit=z(self.body.GM/ak)return z(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dp,eI)assert(self.body)assert(cX(dp)or cZ(dp))assert(cX(eI))local eJ=(cZ(dp)or cT.isMapPosition(dp))and self.body:convertToWorldCoordinates(dp)or vec3(dp)local cS=vec3(eI)local eK=eJ-self.body.center;local eL=cS:len2()local eM=eK:len()local eN=self.body.GM;local eO=((eL-eN/eM)*eK-eK:dot(cS)*cS)/eN;local ct=eN/(2*eN/eM-eL)local eP=eO:len()local dX=eO:normalize()local eQ=ct*(1-eP)local eR=ct*(1+eP)local eS=eQ*dX+self.body.center;local eT=eP<=1 and-eR*dX+self.body.center or nil;local eU=z(ct*eN*(1-eP*eP))local eV=eT and 2*math.pi*z(ct^3/eN)local eW=math.acos(eO:dot(eK)/(eP*eM))if eK:dot(cS)<0 then eW=-(eW-2*math.pi)end;local eX=math.acos((math.cos(eW)+eP)/(1+eP*math.cos(eW)))local eY=eX;if eY<0 then eY=eY+2*math.pi end;local eZ=eY-eP*math.sin(eY)local e_=0;local f0=0;local f1=0;if eV~=nil then e_=eZ/(2*math.pi/eV)f0=eV-e_;f1=f0+eV/2;if eW-math.pi>0 then f0=e_;f1=f0+eV/2 end;if f1>eV then f1=f1-eV end end;return{periapsis={position=eS,speed=eU/eQ,circularOrbitSpeed=z(eN/eQ),altitude=eQ-self.body.radius},apoapsis=eT and{position=eT,speed=eU/eR,circularOrbitSpeed=z(eN/eR),altitude=eR-self.body.radius},currentVelocity=cS,currentPosition=eJ,eccentricity=eP,period=eV,eccentricAnomaly=eX,meanAnomaly=eZ,timeToPeriapsis=f0,timeToApoapsis=f1}end;local function f2(f3)local e4=cT.BodyParameters(f3.systemId,f3.id,f3.radius,f3.center,f3.GM)return setmetatable({body=e4},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return f2(...)end})end;local function f4()local f5={}local f6={}local f7={XS=13,S=27,M=55,L=110,XL=221}local f8={}local f9;local fa;local fb;local fc;local fd;local function fe()local function ff(fg,fh,fi,fj,fk,fl,fm,fn)fh,fj,fl,fn=vec3(fh),vec3(fj),vec3(fl),vec3(fn)local fo,fp,fq=fg*fg,fi*fi,fk*fk;local eL=fj-fh;local fr=eL:normalize()local fs=eL:len()local ft=fl-fh;local fu=(ft-ft:project_on(fr)):normalize()local fv,fw=ft:dot(fr),ft:dot(fu)local fx=fv*fv+fw*fw;local fy=fr:cross(fu)local cj=(fo-fp+fs*fs)/(2*fs)local y=(fo-fq+fx-2*fv*cj)/(2*fw)local d2=fo-cj^2-y^2;local fz=z(d2)local fA=fh+fr*cj+fu*y+fy*fz;local fB=fh+fr*cj+fu*y-fy*fz;if d((fn-fA):len()-fm)<d((fn-fB):len()-fm)then return fA else return fB end end;local function fC()local function fD()local fE=core.getConstructWorldOrientationRight()local eL=core.getConstructWorldOrientationForward()local ft=core.getConstructWorldOrientationUp()local fF=library.systemResolution3(fE,eL,ft,{1,0,0})local fG=library.systemResolution3(fE,eL,ft,{0,1,0})local fH=library.systemResolution3(fE,eL,ft,{0,0,1})return function(fI)return library.systemResolution3(fF,fG,fH,fI)end end;local fJ=fD()local fK=core.getConstructWorldPos()local eJ=core.getElementPositionById(1)local fL={eJ[1],eJ[2],eJ[3]}local fM=fJ(fL)local fN={fK[1]-fM[1],fK[2]-fM[2],fK[3]-fM[3]}return fN end;local function fO(fP,eM,fQ)local fR=fP.pts;local fS=#fR;local fT=fP.ref;if fS>3 then local fU,fV,fW,fX=fR[fS],fR[fS-1],fR[fS-2],fR[fS-3]fP.ref=fQ;local eJ=ff(fU[1],fU[2],fV[1],fV[2],fW[1],fW[2],fX[1],fX[2])local cj,y,fz=eJ.x,eJ.y,eJ.z;if cj==cj and y==y and fz==fz then cj=cj+fT[1]y=y+fT[2]fz=fz+fT[3]local fY=vec3(cj,y,fz)if not fP.lastPos then fP.center=fY elseif(fP.lastPos-fY):len()<2 then fP.center=fY;fP.skipCalc=true end;fP.lastPos=fY end;fP.pts={}else local fZ={fQ[1]-fT[1],fQ[2]-fT[2],fQ[3]-fT[3]}fR[fS+1]={eM,fZ}end end;if bQ[1]then f9=#bQ[1].getConstructIds()local f_=bQ[1].getData()local g0=f_:gmatch('{"constructId[^}]*}[^}]*}')if f9>0 then local fQ=fC()local g1,g2=0,0;fd,fc=0,0;for cS in g0 do local dj,ak,g3=cS:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local g4=f7[g3]ak=A(ak)if bQ[1].hasMatchingTransponder(dj)==1 then table.insert(f6,dj)end;local g5=bQ[1].getConstructType(dj)if CollisionSystem then if g4>27 or g5=="static"or g5=="space"then fd=fd+1;local g6=bQ[1].getConstructName(dj)local fP=bM[dj]if fP==nil then g4=g4+H;bM[dj]={pts={},ref=fQ,name=g6,i=0,radius=g4,skipCalc=false}fP=bM[dj]end;if not fP.skipCalc then fO(fP,ak,fQ)g2=g2+1 end;if fP.center then table.insert(f8,fP)end end;g1=g1+1;if bN and g1>700 or g2>70 or(not bN and g1>300 or g2>30)then coroutine.yield()g1,g2=0,0 end end end;fc=#f8;if fc>0 and bt>20 then local c3,g7,g8,g9;local ga=0;local gb=aS:getPlanetarySystem(0)g9=bs:normalize()while ga<fc do coroutine.yield()local gc={table.unpack(f8,ga,math.min(ga+75,fc))}c3,g7,g8=gb:castIntersections(bw,g9,nil,nil,gc,true)if c3 and g8 then bP={c3,g7,g8}break end;ga=ga+75 end;if not c3 then bP=nil end else bP=nil end;f8={}fa=f_:find('identifiedConstructs":%[%]')else fb=f_:find('worksInEnvironment":false')end end end;local function gd()if bQ[1]then bR="Atmo"if bQ[1].getData():find('worksInAtmosphere":false')then bR="Space"end end end;function f5.pickType()gd()end;function f5.assignRadar()if radar_1 and bQ[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bQ[1]=radar_2 end;if bQ[1]==radar_2 then gd()end elseif radar_2 and bQ[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bQ[1]=radar_1 end;if bQ[1]==radar_1 then gd()end end end;function f5.UpdateRadar()local ge=coroutine.status(UpdateRadarCoroutine)if ge=="suspended"then local co,gf=coroutine.resume(UpdateRadarCoroutine)if gf then system.print("ERROR UPDATE RADAR: "..gf)end elseif ge=="dead"then UpdateRadarCoroutine=coroutine.create(fe)local co,gf=coroutine.resume(UpdateRadarCoroutine)end end;function f5.GetRadarHud()local gg=f6;f6={}return fa,fb,f9,fc,fd,gg end;UpdateRadarCoroutine=coroutine.create(fe)return f5 end;local function gh(cS)if aH==1920 then return cS else return B(aH*cS/1920,0)end end;local function gi(cS)if aI==1080 then return cS else return B(aI*cS/1080,0)end end;local function gj()local gk=9.80665;local gl=vec3({13771471,7435803,-128971})local gm=18000000;local gn=500000;local go,gp=math.huge;local gq;local function gr(gs)go=vec3(gs):dist(gl)if go<gm then return true,d(go-gm)end;gp=vec3(gs):dist(vec3(planet.center))if gp<gn then gq=true else gq=false end;if d(gp-gn)<d(go-gm)then return gq,d(gp-gn)else return gq,d(go-gm)end end;local function gt()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gu()local gv="TRAVEL"if not bB then gv="CRUISE"end;if Autopilot then gv="AUTOPILOT"end;return gv end;local gw=""local gx=""local gy=""local gz=1;local gA=2;local gB=3;local gC=4;local gD=5;local gE=6;local gF=""local gG=0;local gH=e(1/apTickRate)*2*hudTickRate;local gI={}local gJ={}local gK={}local gL={}local gM={}local gN={}local function gO(cj,gP,gQ,gR,gS,gT)local gU=tankY;local gV=tankY+5;if not BarFuelDisplay then gV=gV+5 end;if m()==1 and not RemoteHud then gU=gU-50;gV=gV-50 end;if gQ=="ATMO"then gF="atmofueltank"elseif gQ=="SPACE"then gF="spacefueltank"else gF="rocketfueltank"end;gG=_G[gF.."_size"]if#gR>0 then for i=1,#gR do local g6=string.sub(gR[i][gA],1,12)local gW=0;for gX=1,gG do if gR[i][gA]==g(unit[gF.."_"..gX].getData()).name then gW=gX;break end end;local gY=q()if gS[i]==nil or gT[i]==nil or gY-gR[i][gE]>gH then local gZ;local g_=0;if gW~=0 then gT[i]=g(unit[gF.."_"..gW].getData()).percentage;gS[i]=g(unit[gF.."_"..gW].getData()).timeLeft;if gS[i]=="n/a"then gS[i]=0 end else g_=l(gR[i][gz])-gR[i][gC]gT[i]=e(0.5+g_*100/gR[i][gB])gZ=gR[i][gD]if gZ<=g_ then gS[i]=0 else gS[i]=e(0.5+g_/((gZ-g_)/(gY-gR[i][gE])))end;gR[i][gD]=g_;gR[i][gE]=gY end end;if g6==gP then g6=f("%s %d",gQ,i)end;if gW==0 then g6=g6 .." *"end;local h0;if gS[i]==0 then h0=""else h0=cI(gS[i])end;if gT[i]~=nil then local h1=e(gT[i]*2.55)local h2=f("rgb(%d,%d,%d)",255-h1,h1,0)local cl=""if h0~=""and gS[i]<120 or gT[i]<5 then cl="red "end;local h3=f("rgb(%d,%d,%d)",r(e((255-h1)/2.55),50,100),r(e(h1/2.55),0,50),50)if BarFuelDisplay then gx=gx..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="20" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%% %s</text>
                                            </g>]],h3,cj,gV,h2,e(gT[i]*1.7+0.5),cj,gV,cj+5,gV+14,g6,gT[i],h0)gU=gU-22;gV=gV-22 else gx=gx..ci(cj,gU,g6,cl.."pdim txtfuel")gx=gx..ci(cj,gV,f("%d%% %s",gT[i],h0),"pdim txtfuel","fill:"..h2)gU=gU+30;gV=gV+30 end end end end;tankY=gU end;local function h4(h5,ds)if ds<200000 and not ar or ds and ar then local h6=0;if d(bv)>1 then h6=45*math.log(d(bv),10)if bv<0 then h6=-h6 end end;h5[#h5+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bv),e(h6))end;return h5 end;local function h7(h8)local h9=-bu;h8=h8-h8:project_on(h9)local ha=vec3(0,0,1)ha=ha-ha:project_on(h9)local hb=ha:cross(h9)local h6=ha:angle_between(h8)*constants.rad2deg;if h8:dot(hb)<0 then h6=360-h6 end;return h6 end;local function hc(h5,centerX,centerY,hd,he,bN)local hf=circleRad;local hg=20;local hh=e(hd)if bN then for i=-45,45,5 do local hi=i;h5[#h5+1]=f([[<g transform="rotate(%f,%d,%d)">]],hi,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;h5[#h5+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+hf+hg-len,centerX,centerY+hf+hg)end;h5[#h5+1]=ci(centerX,centerY+hf+hg-35,he,"pdim txt txtmid")h5[#h5+1]=ci(centerX,centerY+hf+hg-25,hh.." deg","pdim txt txtmid")h5[#h5+1]=f([[<g transform="rotate(%f,%d,%d)">]],-hd,centerX,centerY)h5[#h5+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+hf+hg-20,centerX+5,centerY+hf+hg-20,centerX,centerY+hf+hg-15)h5[#h5+1]="</g>"end;h5[#h5+1]=[[<g style="clip-path: url(#headingClip);">]]local hj=hh;if bN then hj=h7(bp)end;local hk=20;local hl=e(hj)local hm=0;local hn=centerY+hf+hg+20;local ho=centerX;if he~="YAW"then hn=gi(130)ho=gh(960)end;local hp=[[<path class="txttick line" d="]]local hq=e(hl-(hk+10)-hl%5+0.5)for i=hq+70,hq,-5 do local cj=ho-(-i*5+hj*5)if i%10==0 then hm=10;local C=i;if C==360 then C=0 elseif C>360 then C=C-360 elseif C<0 then C=C+360 end;h5[#h5+1]=ci(cj,hn+15,C,"txtmid bright")elseif i%5==0 then hm=5 end;if hm==10 then hp=f([[%s M %f %f v %d]],hp,cj,hn-5,hm)else hp=f([[%s M %f %f v %d]],hp,cj,hn-2.5,hm)end end;h5[#h5+1]=hp..[["/>]]h5[#h5+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],ho-5,hn-20,ho+5,hn-20,ho,hn-10)if bN then he="HDG"end;h5[#h5+1]=ci(gh(960),gi(100),hl.."°","dim txt txtmid size14","")h5[#h5+1]=ci(gh(960),gi(85),he,"dim txt txtmid size20","")h5[#h5+1]=[[</g>]]end;local function hr(h5,hs,hd,centerX,centerY,bN,ht,eF)local hf=circleRad;local hu=e(hf*3/5)if hf>0 then local hv=e(hs)local len=0;local hp=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*hd,centerX,centerY)if not ar then hp=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;h5[#h5+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],hf-1,centerX,centerY)h5[#h5+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hv-30-hv%5+0.5),e(hv+30+hv%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local y=centerY+-i*5+hs*5;if len==30 then hp=f([[%s M %d %f h %d]],hp,centerX-hu-len,y,len)if ar then h5[#h5+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hd,centerX,centerY,centerX-hu+10,y+4,i)h5[#h5+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hd,centerX,centerY,centerX+hu-10,y+4,i)if i==0 or i==180 or i==-180 then h5[#h5+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hd,centerX,centerY,centerX-hu+20,y,hu*2-40)end else h5[#h5+1]=ci(centerX-hu+10,y,i,"pdim txt txtmid")h5[#h5+1]=ci(centerX+hu-10,y,i,"pdim txt txtmid")end;hp=f([[%s M %d %f h %d]],hp,centerX+hu,y,len)else hp=f([[%s M %d %f h %d]],hp,centerX-hu-len,y,len)hp=f([[%s M %d %f h %d]],hp,centerX+hu,y,len)end end;h5[#h5+1]=hp..[["/>]]local hw="PITCH"if not bN then hw="REL PITCH"end;if hs>90 and not ar then hs=90-(hs-90)elseif hs<-90 and not ar then hs=-90-(hs+90)end;if hf>200 then if ar then if eF>R then h5[#h5+1]=ci(centerX,centerY-15,"Yaw","pdim txt txtmid")h5[#h5+1]=ci(centerX,centerY+20,ht,"pdim txt txtmid")end;h5[#h5+1]=f([[<g transform="rotate(%f,%d,%d)">]],-hd,centerX,centerY)else h5[#h5+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;h5[#h5+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hu+25,centerY-5,centerX-hu+20,centerY,centerX-hu+25,centerY+5,centerX-hu+50,centerY+4,hv)h5[#h5+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hu-25,centerY-5,centerX+hu-20,centerY,centerX+hu-25,centerY+5,centerX+hu-30,centerY+4,hv)h5[#h5+1]="</g>"end;local hx=e(hf/3)h5[#h5+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hx,centerY,hf-hx)if not ar and bN then h5[#h5+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hd,centerX,centerY,centerX-hu+10,centerY,hu*2-20)end;h5[#h5+1]="</g>"if hf<200 then if ar and eF>R then h5[#h5+1]=ci(centerX,centerY-hf,hw,"pdim txt txtmid")h5[#h5+1]=ci(centerX,centerY-hf+10,hv,"pdim txt txtmid")h5[#h5+1]=ci(centerX,centerY-15,"Yaw","pdim txt txtmid")h5[#h5+1]=ci(centerX,centerY+20,ht,"pdim txt txtmid")else h5[#h5+1]=ci(centerX,centerY-hf,hw,"pdim txt txtmid")h5[#h5+1]=ci(centerX,centerY-hf+15,hv,"pdim txt txtmid")end end end end;local function hy(h5,ds,bN)local hz=altMeterX;local hA=altMeterY;local hB=78;local hC=19;local hD=ap;if ap~=-1 then h5[#h5+1]=ci(hz+hB,hA+hC+20,f("AGL: %.1fm",ap),"pdim altsm txtend")end;if bN and(ds<200000 and not ar or ds and ar)then table.insert(h5,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hz-1,hA-4,hB+2,hC+6,hz+1,hA-1,hB-4,hC))local fS=0;local hE=1;local hF=0;local hG=ds<0;local hH=ds<planet.surfaceMaxAltitude;local hI=9;if hG then hI=0 end;local ds=d(ds)while fS<6 do local hJ=11;local hK=16;local hL=9;local hM=14;local cl="altsm"if fS>2 then hK=hK+3;hJ=hJ+2;hM=hM+2;hL=hL-6;cl="altbig"end;if hG then cl=cl.." red"elseif hH then cl=cl.." orange"end;local hN=ds/hE%10;local hO=e(hN)local hP=e((hO+1)%10)local hQ=hF;if fS==0 then hQ=hN-hO;if hG then hQ=1-hQ end end;if hG and(fS==0 or hF~=0)then local hR=hP;hP=hO;hO=hR end;local hS=hK*(hQ-1)local hT=hS+hK;local cj=hz+hL+(6-fS)*hJ;local y=hA+hM;h5[#h5+1]=ci(cj,y+hS,hP,cl)h5[#h5+1]=ci(cj,y+hT,hO,cl)fS=fS+1;hE=hE*10;if hO==hI then hF=hQ else hF=0 end end;table.insert(h5,[[</g></g>]])end end;local function hU(eI)local hV=-math.deg(n(eI.y,eI.z))+180;hV=hV-90;if hV<0 then hV=360+hV end;if hV>180 then hV=-180+hV-180 end;return-hV end;local function hW(eI)local hj=math.deg(n(eI.y,eI.x))-90;if hj<-180 then hj=360+hj end;return hj end;local function hX(h5,eI,eF,centerX,centerY)if eF>5 and not ar or eF>R then local hf=circleRad;local hY=20;local hZ=20;local h_=hU(eI)local i0=hW(eI)local i1=14;local i2=i1/2;local i3=-i0/hZ*hf;local i4=h_/hY*hf;local cj=centerX+i3;local y=centerY+i4;local ak=z(i3^2+i4^2)local i5=[[<circle
                            cx="]]..cj..[["
                            cy="]]..y..[["
                            r="]]..i2/i1 ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cj..[["
                            cy="]]..y..[["
                            r="]]..i2 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cj-i1 ..[[,]]..y..[[ h ]]..i2 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cj+i2 ..[[,]]..y..[[ h ]]..i2 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cj..[[,]]..y-i1 ..[[ v ]]..i2 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ak<hf then h5[#h5+1]=i5 else local h6=n(i4,i3)local i6=4;local i7=centerX+hf*math.cos(h6)local i8=centerY+hf*math.sin(h6)h5[#h5+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',h6*180/math.pi,i7,i8,i7-i6,i8-i6/2,i6*2,i6,i7+i6,i8-i6,i6,i6,-i6,i6)end;if not ar then local i9=vec3(eI)h_=hU(-i9)i0=hW(-i9)i3=-i0/hZ*hf;i4=h_/hY*hf;cj=centerX+i3;y=centerY+i4;ak=z(i3^2+i4^2)if ak<hf then local ia=[[<circle
                                    cx="]]..cj..[["
                                    cy="]]..y..[["
                                    r="]]..i2 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cj..[[,]]..y-i1 ..[[ v ]]..i2 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cj..[[,]]..y..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cj..[[,]]..y..[[)" />
                                <path
                                    d="M ]]..cj-i2 ..[[,]]..y..[[ h ]]..i1 ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cj..[[,]]..y..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cj..[[,]]..y..[[)"/>]]h5[#h5+1]=ia end end end end;local function ib(h5,gv,ic,id)ic=e(ic+0.5)local gU=throtPosY+10;local gV=throtPosY+20;if m()==1 and not RemoteHud then gU=55;gV=65 end;local ie="CRUISE"local unit="km/h"local co=id;if gv=="TRAVEL"or gv=="AUTOPILOT"then ie="THROT"unit="%"co=ic;local ig="dim"if ic<0 then ig="red"end;h5[#h5+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],ig,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(ic),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;h5[#h5+1]=ci(throtPosX+10,gU,ie,"pbright txtstart")h5[#h5+1]=ci(throtPosX+10,gV,f("%.0f %s",co,unit),"pbright txtstart")if ar and AtmoSpeedAssist and bB and N then ic=e(O*100+0.5)local ig="red"if ic<0 then ig="red"end;h5[#h5+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],ig,1-d(ic),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)h5[#h5+1]=ci(throtPosX+10,gU+40,"LIMIT","pbright txtstart")h5[#h5+1]=ci(throtPosX+10,gV+40,ic.."%","pbright txtstart")end;if ar and AtmoSpeedAssist or Reentry then h5[#h5+1]=ci(throtPosX+10,gU-40,"LIMIT: "..b8 .." km/h","dim txtstart")elseif not ar and Autopilot then h5[#h5+1]=ci(throtPosX+10,gU-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function ih(h5,ii)local ij=throtPosY-10;local ik=throtPosX+10;h5[#h5+1]=ci(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then ij=75 end;h5[#h5+1]=ci(ik,ij,e(ii).." km/h","pbright txtbig txtstart")end;local function il(h5)h5[#h5+1]=ci(gh(1900),gi(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")h5[#h5+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then h5[#h5+1]=ci(gh(960),gi(550),"Warning: Invalid Control Scheme Detected","warnings")h5[#h5+1]=ci(gh(960),gi(600),"Keyboard Scheme must be selected","warnings")h5[#h5+1]=ci(gh(960),gi(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local im=gh(960)local io=gi(860)local ip=gi(880)local iq=gi(900)local ir=gi(960)local is=gi(200)local it=gi(250)local iu=gi(960)if m()==1 and not RemoteHud then io=gi(135)ip=gi(155)iq=gi(175)is=gi(115)it=gi(95)end;local iv="#222222"local iw="white"local ix="dimmer"local iy="pbright"local iz="#110000"local iA=iv;local iB=ix;if BrakeIsOn then h5[#h5+1]=ci(im,io,"Brake Engaged","warnings")iz="#440000"iA=iw;iB=iy elseif M>0 then h5[#h5+1]=ci(im,io,"Auto-Brake Engaged","warnings","opacity:"..M)end;local iC="#110000"local iD=iv;local iE=ix;if ar and b3 and ap==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bz and not VertTakeOff and not AutoTakeoff then h5[#h5+1]=ci(im,is+50,"** STALL WARNING **","warnings")iC="#ff0000"iD=iw;iE=iy;c5("stall","SW",2)end end;if bL then h5[#h5+1]=ci(im,is+90,"Flight Assist in Progress","warnings")end;if ay then h5[#h5+1]=ci(im,iu,"Gyro Enabled","warnings")end;local iF="#111100"local iG=iv;local iH=ix;if GearExtended then iF="#775500"iG=iw;iH=iy;if T then h5[#h5+1]=ci(im,ip,"Gear Extended","warn")else h5[#h5+1]=ci(im,ip,"Landed (G: Takeoff)","warnings")end;local iI=cv(a:getTargetGroundAltitude())h5[#h5+1]=ci(im,iq,"Hover Height: "..iI,"warn")end;local iJ="#000011"local iK=iv;local iL=ix;if a8 then iJ="#0000DD"iK=iw;iL=iy;h5[#h5+1]=ci(im,ir+20,"ROCKET BOOST ENABLED","warn")end;local iM="#001100"local iN=iv;local iO=ix;if antigrav and not ExternalAGG and bz and AntigravTargetAltitude~=nil then iM="#00DD00"iN=iw;iO=iy;if d(at-antigrav.getBaseAltitude())<501 then h5[#h5+1]=ci(im,is+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else h5[#h5+1]=ci(im,is+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then h5[#h5+1]=ci(im,is+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then h5[#h5+1]=ci(im,is+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a1 then h5[#h5+1]=ci(im,is+20,"Follow Mode Engaged","warn")elseif Reentry or ao then h5[#h5+1]=ci(im,is+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local iI=cv(HoldAltitude,2)if VertTakeOff then if bz then iI=cv(antigrav.getBaseAltitude(),2).." AGG singularity height"end;h5[#h5+1]=ci(im,is,"VTO to "..iI,"warn")elseif AutoTakeoff and not IntoOrbit then if an then h5[#h5+1]=ci(im,is,"Takeoff to "..AutopilotTargetName,"warn")else h5[#h5+1]=ci(im,is,"Takeoff to "..iI,"warn")end;if BrakeIsOn and not VertTakeOff then h5[#h5+1]=ci(im,is+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else h5[#h5+1]=ci(im,is,"Altitude Hold: "..iI,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if as>0.1 then h5[#h5+1]=ci(im,is+20,"Beginning ascent","warn")elseif as<0.09 and as>0.05 then h5[#h5+1]=ci(im,is+20,"Aligning trajectory","warn")elseif as<0.05 then h5[#h5+1]=ci(im,is+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if ba~=nil then h5[#h5+1]=ci(im,is,ba,"warn")end end;if BrakeLanding then if StrongBrakes then h5[#h5+1]=ci(im,is,"Brake-Landing","warnings")else h5[#h5+1]=ci(im,is,"Coast-Landing","warnings")end end;if ProgradeIsOn then h5[#h5+1]=ci(im,is,"Prograde Alignment","crit")end;if RetrogradeIsOn then h5[#h5+1]=ci(im,is,"Retrograde Alignment","crit")end;local iP="#110000"local iQ=iv;local iR=ix;if bO then iP="#FF0000"iQ=iw;iR=iy;local type;if string.find(bO,"COLLISION")then type="warnings"else type="crit"end;h5[#h5+1]=ci(im,it+20,bO,type)elseif as==0 then local c0,c4=bZ(bs:normalize())if c4~=nil then iR=iy;iP="#FF0000"iQ=iw;local iI=cv(c4)local travelTime=aT.computeTravelTime(bt,0,c4)local iS="Collision"if c0.noAtmosphericDensityAltitude>0 then iS="Atmosphere"end;h5[#h5+1]=ci(im,it+20,c0.name.." "..iS.." "..cI(travelTime).." In "..iI,"crit")end end;if VectorToTarget and not IntoOrbit then h5[#h5+1]=ci(im,is+35,VectorStatus,"warn")end;local iT="#111100"local iU=iv;local iV=ix;if passengers and#passengers>1 then iT="#DDDD00"iU=iw;iV=iy end;local iW=gh;local iX=gi;local ix="topButton"local iY="topButtonActive"local iZ=ix;if Autopilot or VectorToTarget or an or IntoOrbit then iZ=iY end;local i_=ix;if ProgradeIsOn then i_=iY end;local j0=ix;if BrakeLanding or GearExtended then j0=iY end;local j1=ix;if AltitudeHold or VectorToTarget then j1=iY end;local j2=ix;if RetrogradeIsOn then j2=iY end;local j3=ix;if IntoOrbit or bj and Autopilot then j3=iY end;local j4=iX(30)h5[#h5+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iZ,iW(960),iX(54),iX(-53),iW(-120),iW(25),iX(50))h5[#h5+1]=ci(iW(910),j4,"AUTOPILOT")h5[#h5+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],i_,iW(865),iX(51),iW(-25),iX(-50),iW(-110),iW(25),iX(46))h5[#h5+1]=ci(iW(800),j4,"PROGRADE")h5[#h5+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j0,iW(755),iX(47),iW(-25),iX(-46),iW(-98),iW(44),iX(44))h5[#h5+1]=ci(iW(700),j4,"LAND")h5[#h5+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],j1,iW(960),iX(54),iX(-53),iW(120),iW(-25),iX(50))h5[#h5+1]=ci(iW(1010),j4,"ALT HOLD")h5[#h5+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j2,iW(1055),iX(51),iW(25),iX(-50),iW(110),iW(-25),iX(46))h5[#h5+1]=ci(iW(1122),j4,"RETROGRADE")h5[#h5+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j3,iW(1165),iX(47),iW(25),iX(-46),iW(98),iW(-44),iX(44))h5[#h5+1]=ci(iW(1220),j4,"ORBIT")h5[#h5+1]=[[
                                </g>
                            </g>]]h5[#h5+1]="</g>"return h5 end;local function j5(eF)return e(B(eF*3.6,0)+0.5).." km/h"end;local function j6(h5)local cj=OrbitMapX+10;local y=OrbitMapY+20;local j7={}local j8={"Alt-4: AutoTakeoff to Target"}local j9={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local ja={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local jb={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(j7,"--------------DYNAMIC-----------------")if ar then if ap~=-1 then c8(j7,j8)if ad and planet and ad.name==planet.name then table.insert(j7,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bz then table.insert(j7,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(j7,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(j7,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(j7,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(j7,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(j7,"G: Takeoff to hover height, raise gear")else table.insert(j7,"G: Lowergear and Land")end else c8(j7,j9)table.insert(j7,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(j7,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else c8(j7,ja)if shield_1 then table.insert(j7,"Alt-Shift-5: Toggle shield off and on")table.insert(j7,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(j7,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(j7,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(j7,"Alt-Spacebar/C will raise/lower target height")table.insert(j7,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not ar then table.insert(j7,"LALT+Mousewheel will lower/raise speed limit")end;c8(j7,jb)for i=1,#j7 do y=y+12;h5[#h5+1]=ci(cj,y,j7[i],"pdim txtbig txtstart")end end;local function jc(h5)local jd=gh(OrbitMapX)local je=gi(OrbitMapY)local jf=OrbitMapSize;local jg=4;local jh=15;local cj=0;local y=0;local ji,jj,jk,jl;local function jm(type)local jn,F,eF,jo;if type=="Periapsis"then jn=orbit.periapsis.altitude;F=orbit.timeToPeriapsis;eF=orbit.periapsis.speed;jo=35 else jn=orbit.apoapsis.altitude;F=orbit.timeToApoapsis;eF=orbit.apoapsis.speed;jo=-35 end;h5[#h5+1]=ci(cj,y,type)y=y+jh;local iI=cv(jn)h5[#h5+1]=ci(cj,y,iI)y=y+jh;h5[#h5+1]=ci(cj,y,cI(F))y=y+jh;h5[#h5+1]=ci(cj,y,j5(eF))end;local jp=jf*1.5;if SelectedTab=="INFO"then jp=25*8 end;if SelectedTab~="HIDE"then h5[#h5+1]=[[<g class="pbright txtorb txtmid">]]h5[#h5+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',jf*2,jp,jd,je)end;if SelectedTab=="ORBIT"then je=je+jg;cj=jd+jf+jg;y=je+jf*1.5/2+5+jg;ji=jf/4;jl=0;if orbit.periapsis~=nil and orbit.apoapsis~=nil then jk=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(ji*2)jj=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/jk*(1-orbit.eccentricity)jl=ji-orbit.periapsis.altitude/jk-planet.radius/jk;local jq=""if orbit.periapsis.altitude<=0 then jq='redout'end;h5[#h5+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jq,jd+jf+jl+jg,je+jf*1.5/2+jg,ji,jj)h5[#h5+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',jd+jf+jg,je+jf*1.5/2+jg,planet.radius/jk)end;y=je+jf*1.5/2+5+jg;cj=jd+jf*1.5+jg;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then jm("Apoapsis")end;y=je+jf*1.5/2+5+jg;cj=jd+jf/2+jg;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then jm("Periapsis")end;h5[#h5+1]=ci(jd+jf+jg,je+20+jg,planet.name,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local jr=orbit.timeToApoapsis/orbit.period*2*math.pi;local js=ji*math.cos(jr)local jt=jj*math.sin(jr)h5[#h5+1]=f('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',jd+jf+js+jl+jg,je+jf*1.5/2+jt+jg)end;h5[#h5+1]=[[</g>]]return h5 elseif SelectedTab=="INFO"then h5=aW.DrawOdometer(h5,ae,TotalDistanceTravelled,af)elseif SelectedTab=="HELP"then h5=j6(h5)else return h5 end end;local function ju(jv,jw)local jx;local jy=(jw-jv):normalize()local eK=(bw-jv):dot(jy)/jy:dot(jy)if eK<=0.then return(bw-jv):len()elseif eK>=(jw-jv):len()then return(bw-jw):len()end;local jz=jv+eK*jy;jx=(jz-bw):len()return jx end;local function jA()local jx;local jB=nil;local jC=nil;local jD=nil;for cR,jE in pairs(b[0])do if jE.hasAtmosphere then local ak=ju(planet.center,jE.center)if jB==nil or ak<jB then jC=jE;jB=ak;jD=planet end;if ad and ad.hasAtmosphere and ad.name~=planet.name then local e5=ju(ad.center,jE.center)if e5<jB then jC=jE;jB=e5;jD=ad end end end end;local jF=gh(1770)local jG=gi(330)if jB then local jH="txttick "local jI=500000;if jB<jC.radius+jI or jB<jD.radius+jI then if bI then jH="txttick red "else jH="txttick orange "end end;jx=cv(jB,2)bK=ci(jF,jG,"Pipe ("..jD.name.."--"..jC.name.."): "..jx,jH.."pbright txtmid")end end;local jJ={}local jK=nil;function jJ.HUDPrologue(h5)bI,bJ=gr(bw)if not bI then I=PvPR;K=PvPG;J=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else I=SafeR;K=SafeG;J=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;az=[[rgb(]]..e(I+0.5)..","..e(K+0.5)..","..e(J+0.5)..[[)]]aA=[[rgb(]]..e(I*0.8+0.5)..","..e(K*0.8+0.5)..","..e(J*0.8+0.5)..[[)]]local jL=az;local jM=aA;local jN=[[rgb(]]..e(I*0.3+0.5)..","..e(K*0.3+0.5)..","..e(J*0.3+0.5)..[[)]]local jO=az;local jP=aA;if gt()and not brightHud then jL=[[rgb(]]..e(I*0.5+0.5)..","..e(K*0.5+0.5)..","..e(J*0.5+0.5)..[[)]]jM=[[rgb(]]..e(I*0.3+0.5)..","..e(K*0.3+0.5)..","..e(J*0.2+0.5)..[[)]]end;local iW=gh;local iX=gi;h5[#h5+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],jL,jL,jL,jO,jO,jM,jM,jP,jP,jM,jL,jN,jP,jL,jL,jN,jN,jN,aH,aI,jM,jM,jM,jM,jM,jO,jM)if not jK then jK=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iW(630),iX(0),iW(675),iX(45),iW(960),iX(55),iW(1245),iX(45),iW(1290),iX(0),iW(1000),iX(105),iW(1040),iX(59),iW(1250),iX(51),iW(1300),iX(0),iW(1920),iX(0),iW(1920),iX(20),iW(1400),iX(20),iW(1300),iX(105),iW(920),iX(105),iW(880),iX(59),iW(670),iX(51),iW(620),iX(0),iW(0),iX(0),iW(0),iX(20),iW(520),iX(20),iW(620),iX(105),iW(890),iX(59),iW(960),iX(62),iW(1030),iX(59),iW(985),iX(112),iW(1150),iX(112),iW(1100),iX(152),iW(820),iX(152),iW(780),iX(112),iW(935),iX(112),iW(890),iX(59),iW(960),iX(62),iW(1030),iX(59),iW(985),iX(112),iW(1150),iX(112),iW(1100),iX(152),iW(820),iX(152),iW(780),iX(112),iW(935),iX(112))end;h5[#h5+1]=jK;return h5 end;function jJ.DrawVerticalSpeed(h5,ds)h4(h5,ds)end;function jJ.UpdateHud(h5)local hV=bC;local jQ=bD;local hd=jQ;local hs=hV;local ic=e(unit.getThrottle())local ii=bt*3.6;local id=unit.getAxisCommandValue(0)local jR=gh(1770)local jS=gi(310)if AtmoSpeedAssist and bB then id=L;ic=L*100 end;local gv=gu()local he="ROLL"if ic==nil then ic=0 end;if not bN then if bt>5 then hV=hU(br)jQ=hW(br)else hV=0;jQ=0 end;he="YAW"end;if bJ>50000 and not ar then local jT;jT=cv(bJ)h5[#h5+1]=ci(jR,jS,"PvP Boundary: "..jT,"pbright txtbig txtmid")end;h5[#h5+1]=al;h5[#h5+1]=aE;h5[#h5+1]=gw;if bK~=""then h5[#h5+1]=bK end;if gx~=""then h5[#h5+1]=gx end;if gy~=""then h5[#h5+1]=gy end;h4(h5,at)if m()==0 or RemoteHud then if bN then hc(h5,centerX,centerY,hd,he,bN)else hc(h5,centerX,centerY,jQ,he,bN)end;if not gt()or brightHud then if bN then hc(h5,centerX,centerY,hd,he,bN)hr(h5,hs,hd,centerX,centerY,bN,e(hW(br)),bt)else hc(h5,centerX,centerY,jQ,he,bN)hr(h5,hV,jQ,centerX,centerY,bN,e(jQ),bt)end;hy(h5,at,bN)hX(h5,br,bt,centerX,centerY)end end;ib(h5,gv,ic,id)ih(h5,ii)il(h5)jc(h5)return h5 end;function jJ.HUDEpilogue(h5)h5[#h5+1]="</svg>"return h5 end;function jJ.ExtraData(h5)local jU=gh(1240)local jV=gi(55)local jW=jV+10;local jX;local iW=gh;local iX=gi;local jY=0;local gv=gu()local jZ=iX(99)local j_=iX(80)local k0=cr;y(85)local k1=iX(31)local k2=0;local k3=0;local k4=aw>1000000 and B(aw/1000000,2).."kT"or B(aw/1000,2).."T"if ar then jY=LastMaxBrakeInAtmo else jY=LastMaxBrake end;local k5,k6=aT.computeDistanceAndTime(bt,0,aw,0,0,jY)if k5<0 then k5=0 end;jY=B(jY/(aw*gk),2).."g"local k7=a:maxForceForward()jX=core.g()if jX>0.1 then k3=aw*jX;k3=B(k3/(aw*gk),2).."g"k2=0.5*k7/jX;k2=k2>1000000 and B(k2/1000000,2).."kT"or B(k2/1000,2).."T"end;k7=B(k7/(aw*gk),2).."g"local k8=vec3(core.getWorldAcceleration()):len()/9.80665;jX=core.g()h5[#h5+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then jU=gh(1120)jV=gi(55)jW=jV+10 elseif ar then local k9=gh(770)h5[#h5+1]=ci(iW(895),jZ,"ATMO","")h5[#h5+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iW(895),k0,iW(-80))h5[#h5+1]=ci(iW(815),j_,f("%.1f%%",as*100),"txtstart size20")end;h5[#h5+1]=ci(iW(1025),jZ,"GRAVITY","txtstart")h5[#h5+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iW(1025),k0,iW(80))h5[#h5+1]=ci(iW(1105),j_,f("%.2fg",jX/9.80665),"size20")h5[#h5+1]=ci(iW(1125),jZ,"ACCEL","txtstart")h5[#h5+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iW(1125),k0,iW(80))h5[#h5+1]=ci(iW(1205),j_,f("%.2fg",k8),"size20")h5[#h5+1]=ci(iW(695),jZ,"BRK TIME","")h5[#h5+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iW(695),k0,iW(-80))h5[#h5+1]=ci(iW(615),j_,f("%s",cI(k6)),"txtstart size20")h5[#h5+1]=ci(iW(635),iX(45),"TRIP","")h5[#h5+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iW(635),iX(31),iW(-90))if travelTime then h5[#h5+1]=ci(iW(532),iX(23),f("%s",cI(travelTime)),"txtstart size20")end;h5[#h5+1]=ci(iW(795),jZ,"BRK DIST","")h5[#h5+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iW(795),k0,iW(-80))h5[#h5+1]=ci(iW(715),j_,f("%s",cv(k5)),"txtstart size20")h5[#h5+1]=ci(iW(1285),iX(45),"MASS","txtstart")h5[#h5+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iW(1285),iX(31),iW(90))h5[#h5+1]=ci(iW(1388),iX(23),f("%s",k4),"size20")h5[#h5+1]=ci(iW(1220),jZ,"THRUST","txtstart")h5[#h5+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iW(1220),k0,iW(80))h5[#h5+1]=ci(iW(1300),j_,f("%s",k7),"size20")h5[#h5+1]=ci(gh(960),gi(175),gv,"pbright txtbig txtmid size20")h5[#h5+1]="</g>"end;function jJ.DrawOdometer(h5,ae,TotalDistanceTravelled,af)if SelectedTab~="INFO"then return h5 end;local jX;local k2=0;local k3=0;local jY=0;local k4=aw>1000000 and B(aw/1000000,2).." kTons"or B(aw/1000,2).." Tons"if ar then jY=LastMaxBrakeInAtmo else jY=LastMaxBrake end;local k5,k6=aT.computeDistanceAndTime(bt,0,aw,0,0,jY)jY=B(jY/(aw*gk),2).." g"local k7=a:maxForceForward()jX=core.g()if jX>0.1 then k3=aw*jX;k3=B(k3/(aw*gk),2).." g"k2=0.5*k7/jX;k2=k2>1000000 and B(k2/1000000,2).." kTons"or B(k2/1000,2).." Tons"end;k7=B(k7/(aw*gk),2).." g"if m()==0 or RemoteHud then local ka=gh(OrbitMapX+10)local kb=gi(OrbitMapY+20)local kc=gh(OrbitMapX+10+OrbitMapSize/1.25)local kd=25;h5[#h5+1]="<g class='txtstart size14 bright'>"h5[#h5+1]=ci(ka,kb,f("BrkTime: %s",cI(k6)))h5[#h5+1]=ci(kc,kb,f("Trip: %.2f km",ae))h5[#h5+1]=ci(ka,kb+kd,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))h5[#h5+1]=ci(kc,kb+kd,f("BrkDist: %s",cv(k5)))h5[#h5+1]=ci(ka,kb+kd*2,"Trip Time: "..cI(af))h5[#h5+1]=ci(kc,kb+kd*2,"Total Time: "..cI(TotalFlightTime))h5[#h5+1]=ci(ka,kb+kd*3,f("Mass: %s",k4))h5[#h5+1]=ci(kc,kb+kd*3,f("Max Brake: %s",jY))h5[#h5+1]=ci(ka,kb+kd*4,f("Max Thrust: %s",k7))if jX>0.1 then h5[#h5+1]=ci(kc,kb+kd*4,f("Max Thrust Mass: %s",k2))h5[#h5+1]=ci(ka,kb+kd*5,f("Req Thrust: %s",k3))else h5[#h5+1]=ci(kc,kb+kd*5,"Max Mass: n/a")h5[#h5+1]=ci(ka,kb+kd*6,"Req Thrust: n/a")end end;h5[#h5+1]="</g></g>"return h5 end;function jJ.DrawWarnings(h5)return il(h5)end;function jJ.DisplayOrbitScreen(h5)return jc(h5)end;function jJ.DisplayMessage(h5,iI)if iI~="empty"then local y=310;for ke in string.gmatch(iI,"([^\n]+)")do y=y+35;h5[#h5+1]=ci("50%",y,ke,"msg")end end;if aj~=0 then unit.setTimer("msgTick",aj)aj=0 end end;function jJ.DrawDeadZone(h5)h5[#h5+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function jJ.UpdatePipe()if ar then bK=""return end;jA()end;function jJ.DrawSettings(h5)if#bF>0 then local cj=gh(640)local y=gi(200)h5[#h5+1]=[[<g class="pbright txtvspd txtstart">]]for cR,cS in pairs(bF)do h5[#h5+1]=ci(cj,y,cS..": ".._G[cS])y=y+20;if cR%12==0 then cj=cj+gh(350)y=gi(200)end end;h5[#h5+1]=ci(gh(640),gi(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")h5[#h5+1]="</g>"end;return h5 end;local kf;local kg=gh(1770)local kh=gi(350)local ki=gi(15)local kj=gh(1370)local bV,kk;local kl=0;function jJ.DrawRadarInfo()local function km()if radarPanelID~=nil and kl==0 then t(radarPanelID)radarPanelID=nil;if kf~=nil then t(kf)kf=nil end else if kl==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bQ,1,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")kf=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bQ,1,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;kl=0 end end;local fa,fb,f9,fc,fd,f6=aZ.GetRadarHud()local C=fc or 0;if f9>0 then if CollisionSystem then bV=C.."/"..fd.." Plotted : "..f9-fd.." Ignored"else bV="Radar Contacts: "..f9 end;gw=ci(kg,kh,bV,"pbright txtbig txtmid")if#f6>0 then gw=gw..ci(kj,ki,"Friendlies In Range","pbright txtbig txtmid")for cR,cS in pairs(f6)do ki=ki+20;gw=gw..ci(kj,ki,bQ[1].getConstructName(cS),"pdim txtmid")end end;if fa==nil and kf==nil then kl=1;km()end;if fa~=nil and kf~=nil then km()end;if radarPanelID==nil then km()end else if fb then gw=ci(kg,kh,bR.." Radar: Jammed","pbright txtbig txtmid")else gw=ci(kg,kh,"Radar: No "..bR.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then kl=0;km()end end end;function jJ.DrawTanks()if fuelX~=0 and fuelY~=0 then gx=ci(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gO(fuelX,"Atmospheric ","ATMO",aJ,gM,gN)gO(fuelX,"Space Fuel T","SPACE",aK,gK,gL)gO(fuelX,"Rocket Fuel ","ROCKET",aL,gI,gJ)end end;function jJ.DrawShield()local kn=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local ko=core.getPvPTimer()local kp=shield_1.getResistances()local kq="A: "..10+kp[1]*100 .."% / E: "..10+kp[2]*100 .."% / K:"..10+kp[3]*100 .."% / T: "..10+kp[4]*100 .."%"local cj,y=shieldX-60,shieldY+30;local kr=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local h1=e(kr*2.55)local h2=f("rgb(%d,%d,%d)",255-h1,h1,0)local cl=""gy=ci(cj,y,"","txtmid pdim txtfuel")if kr<10 and kn~="Shield Disabled"then cl="red "end;ko=ko>0 and"   PvPTime: "..cI(ko)or""gy=gy..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],cj,y,h2,kr*2,cj,y,cj+2,y+10,kr,ko)gy=gy..ci(cj,y-5,kn,cl.."txtstart pbright txtbig")gy=gy..ci(cj,y+30,kq,cl.."txtstart pbright txtsmall")end;function jJ.hudtick()if not planet then return end;local function ks(h5)local kt=e(r(ak/(aH/4)*255,0,255))h5[#h5+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ah,ai,e(I+0.5)+kt,e(K+0.5)-kt,e(J+0.5)-kt)end;local function ku()for _,cS in pairs(aG)do if cS.hovered then if not cS.drawCondition or cS.drawCondition(cS)then cS.toggleFunction(cS)end;cS.hovered=false end end;for _,cS in pairs(bU)do if cS.hovered then SelectedTab=cS.label;cS.hovered=false end end end;local function kv()local function kw(kx,ky,cj,y,kz,kd)if kx>=cj and kx<=cj+kz and ky>=y and ky<=y+kd then return true else return false end end;local cj=ah+aH/2;local y=ai+aI/2;for _,cS in pairs(aG)do cS.hovered=kw(cj,y,cS.x,cS.y,cS.width,cS.height)end;for _,cS in pairs(bU)do cS.hovered=kw(cj,y,cS.x,cS.y,cS.width,cS.height)end;if bS then local kA=false;for _,cu in ipairs(apExtraButtons)do if cu.hovered then kA=true;break end end;if apbutton.hovered then kA=true end;bS=kA else bS=apbutton.hovered;if not bS then bT=AutopilotTargetIndex end end end;local function kB(h5)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;for cR,cS in pairs(bU)do local cl="dim brightstroke"local kC=0.2;if SelectedTab==cR then cl="pbright dimstroke"kC=0.6 end;local kD=""if cS.hovered then kC=0.8;kD=";stroke:white"end;h5[#h5+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cS.width,cS.height,cS.x,cS.y,cl,kC,kD)h5[#h5+1]=ci(cS.x+cS.width/2,cS.y+cS.height/2+5,cS.label,"txt txtmid pdim")end end;local function kE(h5)local function kF(h5,kG,hover,cj,y,ey,kH,kI,kJ,kK,kL,button)if type(kK)=="function"then kK=kK(button)end;if type(kL)=="function"then kL=kL(button)end;h5[#h5+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",cj,y,ey,kH)if kG then h5[#h5+1]=f("%s'",kI)else h5[#h5+1]=kJ end;if hover then h5[#h5+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else h5[#h5+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",B(SafeR*0.5,0),B(SafeG*0.5,0),B(SafeB*0.5,0))end;h5[#h5+1]=" rx='5'></rect>"h5[#h5+1]=f("<text x='%f' y='%f' font-size='24' fill='",cj+ey/2,y+kH/2+5)if kG then h5[#h5+1]="black"else h5[#h5+1]="white"end;h5[#h5+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if kG then h5[#h5+1]=f("%s</text>",kK)else h5[#h5+1]=f("%s</text>",kL)end end;local kM=f("rgb(%d,%d,%d)'",B(SafeR*0.1,0),B(SafeG*0.1,0),B(SafeB*0.1,0))local kN=f("rgb(%d,%d,%d)",B(SafeR*0.8,0),B(SafeG*0.8,0),B(SafeB*0.8,0))local kO=kF;for _,cS in pairs(aG)do local kP=cS.disableName;local kQ=cS.enableName;if type(kP)=="function"then kP=kP(cS)end;if type(kQ)=="function"then kQ=kQ(cS)end;if not cS.drawCondition or cS.drawCondition(cS)then kO(h5,cS.toggleVar(cS),cS.hovered,cS.x,cS.y,cS.width,cS.height,kN,kM,kP,kQ,cS)end end end;local kR=B(ResolutionX/2,0)local kS=B(ResolutionY/2,0)local h5={}aW.HUDPrologue(h5)if showHud then aW.UpdateHud(h5)else if AlwaysVSpd then aW.DrawVerticalSpeed(h5,at)end;aW.DisplayOrbitScreen(h5)aW.DrawWarnings(h5)end;if bE and bF~={}then aW.DrawSettings(h5)end;if radar_1 or radar_2 then aZ.assignRadar()end;if bQ[1]then aW.DrawRadarInfo()end;aW.HUDEpilogue(h5)h5[#h5+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aH,aI)if a3~="empty"then aW.DisplayMessage(h5,a3)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aW.DrawDeadZone(h5)end end;kB(h5)if x()==0 then if m()==1 and a2 then if not AltIsOn then kv()kE(h5)end;if not a_ and not b0 then local kT=table.concat(h5,"")h5={}h5[#h5+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aH,aI)h5[#h5+1]=kT;h5[#h5+1]="</body>"a_=true;h5[#h5+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(h5,"")system.setScreen(content)elseif b0 then local kT=table.concat(h5,"")h5={}h5[#h5+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aH,aI)h5[#h5+1]=kT;h5[#h5+1]="</body>"end;if not a_ then h5[#h5+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],kR,kS,ah,ai)end else ku()end else if not a2 and m()==0 then ku()if ak>DeadZone then if DisplayDeadZone then ks(h5)end end elseif not AltIsOn and a2 then kv()kE(h5)end;h5[#h5+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],kR,kS,ah,ai)end;h5[#h5+1]=[[</svg></body>]]content=table.concat(h5,"")end;return jJ end;local function kU()local function kV(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function kW()local function kX(kY,kZ)return kY.name<kZ.name end;bH={}for cR,cS in pairs(b[0])do bH[#bH+1]={name=cS.name,index=cR}end;table.sort(bH,kX)end;local function k_(l0)for cR,cS in pairs(l0)do if cS.name and cS.name==CustomTarget.name then return cR end end;return-1 end;local function l1()bT=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ad=nil;CustomTarget=nil;return true end;local l2=bH[AutopilotTargetIndex].index;local l3=b[0][l2]if l3.center then AutopilotTargetName=l3.name;ad=aS[0][l2]if CustomTarget~=nil then if as==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=l3;for _,cS in pairs(aS[0])do if cS.name==CustomTarget.planetname then ad=cS;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ad.center)else AutopilotTargetCoords=CustomTarget.position end;if ad.planetname~="Space"then if ad.hasAtmosphere then AutopilotTargetOrbit=e(ad.radius*(TargetOrbitRadius-1)+ad.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ad.radius*(TargetOrbitRadius-1)+ad.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aV(ad):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function l4(h9)if not Autopilot and not VectorToTarget and not an and not IntoOrbit then if h9==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bH then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bH end end;if AutopilotTargetIndex==0 then l1()else local l2=bH[AutopilotTargetIndex].index;local l3=b[0][l2]if l3~=nil and l3.name=="Space"or iphCondition=="Custom Only"and l3.center or iphCondition=="No Moons"and string.find(l3.name,"Moon")~=nil then if h9==nil then l4()else l4(1)end else l1()end end else a3="Disengage autopilot before changing Interplanetary Helper"c5("iph","AP")end end;local function l5()local fS=-1;fS=k_(b[0])if fS>-1 then table.remove(b[0],fS)end;fS=-1;fS=k_(SavedLocations)if fS~=-1 then a3=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fS)end;l4()kW()end;local function l6(g6,position,hR,l7)if dbHud_1 or hR then local p=kV(position)local jX=p.gravity;if l7 then jX=unit.getClosestPlanetInfluence()end;local l8={position=position,name=g6,planetname=p.name,gravity=jX,safe=l7}if not hR then SavedLocations[#SavedLocations+1]=l8 else for cR,cS in pairs(b[0])do if cS.name and g6==cS.name then table.remove(b[0],cR)end end end;table.insert(b[0],l8)kW()l1()a3="Location saved as "..g6 .."("..p.name..")"else a3="Databank must be installed to save permanent locations"end end;local l9={}function l9.UpdateAtlasLocationsList()kW()end;function l9.UpdateAutopilotTarget()l1()end;function l9.adjustAutopilotTargetIndex(h9)l4(h9)end;function l9.findAtlasIndex(l0)k_(l0)end;function l9.UpdatePosition(la)local fS=k_(SavedLocations)if fS~=-1 then if la~=nil then SavedLocations[fS].name=la;AutopilotTargetIndex=AutopilotTargetIndex-1;l4()else local lb=SavedLocations[fS]lb.gravity=unit.getClosestPlanetInfluence()lb.position=bw;lb.safe=true end;a3=SavedLocations[fS].name.." position updated ("..SavedLocations[fS].planetname..")"else a3="Name Not Found"end end;function l9.AddNewLocation(g6,position,hR,l7)l6(g6,position,hR,l7)end;function l9.ClearCurrentPosition()l5()end;for cR,cS in pairs(SavedLocations)do table.insert(b[0],cS)end;kW()if AutopilotTargetIndex>#bH then AutopilotTargetIndex=0 end;l9.UpdateAutopilotTarget()return l9 end;local function lc()local cC={}local function ld(eF)local le=AutopilotEndSpeed;if not Autopilot then le=0 end;if not ar then return aT.computeDistanceAndTime(eF,le,aw,0,0,LastMaxBrake-AutopilotPlanetGravity*aw)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aT.computeDistanceAndTime(eF,le,aw,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*aw)else return 0,0 end end end;local function lf(eF)local le=AutopilotEndSpeed;if not Autopilot then le=0 end;return aT.computeDistanceAndTime(eF,le,aw,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*aw)end;local lg=false;local lh=0;function cC.GetAutopilotBrakeDistanceAndTime(eF)return ld(eF)end;function cC.GetAutopilotTBBrakeDistanceAndTime(eF)return lf(eF)end;local function li(lj,lk,ll)lk=lk:project_on_plane(lj)ll=ll:project_on_plane(lj)return n(lk:cross(ll):dot(lj),lk:dot(ll))end;local function lm()local function ln()local lo=-1;local lp=-1;if vBooster then lo=vBooster.getDistance()end;if hover then lp=hover.getDistance()end;if lo~=-1 and lp~=-1 then if lo<lp then return lo else return lp end elseif lo~=-1 then return lo elseif lp~=-1 then return lp else return-1 end end;local lq=ln()local lr=-1;if telemeter_1 then lr=telemeter_1.getDistance()end;if lq~=-1 and lr~=-1 then if lq<lr then return lq else return lr end elseif lq~=-1 then return lq else return lr end end;local function ls(planet,e1,lt)local function lu(lv,dl)local e7=vec3(dl)if lv.id==0 then return setmetatable({latitude=e7.x,longitude=e7.y,altitude=e7.z,id=0,systemId=lv.systemId},MapPosition)end;local e8=e7-lv.center;local ak=e8:len()local ds=ak-lv.radius;local dq=0;local dr=0;if not cs(ak,0)then local e9=n(e8.y,e8.x)dr=e9>=0 and e9 or 2*math.pi+e9;dq=math.pi/2-math.acos(e8.z/ak)end;return setmetatable({latitude=math.deg(dq),longitude=math.deg(dr),altitude=ds,id=lv.id,systemId=lv.systemId},MapPosition)end;local lw=lu(planet,e1)lw="::pos{"..lw.systemId..","..lw.id..","..lw.latitude..","..lw.longitude..","..lw.altitude.."}"if lt then return lw else system.setWaypoint(lw)return true end end;local lx=false;function cC.showWayPoint(planet,e1,lt)return ls(planet,e1,lt)end;function cC.APTick()local function ly()if bP and not BrakeLanding then local c3=bP[1]local g7,g8=bP[2],bP[3]local lz=math.min(g7,g8 or g7)local lA=lz/bt;local lB=AutoTakeoff and(bt<42 or ap~=-1)local lC=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if lC and not lB and(a9*1.5>lz or lA<1)then BrakeIsOn=true;cn(0)if AltitudeHold then cA()end;if LockPitch then ToggleLockPitch()end;a3="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cD()end;StrongBrakes=true;BrakeLanding=true;b1=true end;if lA<11 then bO=c3.name.." COLLISION "..cI(lA).." / "..cv(lz,2)else bO=c3.name.." collision "..cI(lA)end;if lA<6 then c5("alarm","AL",2)end else bO=false end end;local function lD(b_,lE,lF)local function lG(b_,dO)b_=vec3(b_)dO=vec3(dO):normalize()local d7=b_*dO;return d7.x+d7.y+d7.z end;local lH=0.001;local lI=1;if not ar or not b3 or ap~=-1 or bt<R then if lF==nil then lF=DampingMultiplier end;if lE==nil then lE=lH end;b_=vec3(b_):normalize()local lJ=vec3()-b_;local lK=-lG(lJ,core.getConstructWorldOrientationRight())*lI;local lL=-lG(lJ,core.getConstructWorldOrientationUp())*lI;if aC==0 then aC=lK/2 end;if aD==0 then aD=lL/2 end;if d(lK)<0.1 then W=W-lK*2 else W=W-(lK+(lK-aC)*lF)end;if d(lL)<0.1 then V=V+lL*2 else V=V+lL+(lL-aD)*lF end;aC=lK;aD=lL;if d(lK)<lE and d(lL)<lE then return true end;return false elseif b3 and ap==-1 then b_=bs;if lF==nil then lF=DampingMultiplier end;if lE==nil then lE=lH end;b_=vec3(b_):normalize()local lJ=bp-b_;local lK=-lG(lJ,core.getConstructWorldOrientationRight())*lI;local lL=-lG(lJ,core.getConstructWorldOrientationUp())*lI;if aC==0 then aC=lK/2 end;if aD==0 then aD=lL/2 end;if d(lK)<0.1 then W=W-lK*5 else W=W-(lK+(lK-aC)*lF)end;if d(lL)<0.1 then V=V+lL*5 else V=V+lL+(lL-aD)*lF end;aC=lK;aD=lL;if d(lK)<lE and d(lL)<lE then return true end;return false end end;ar=k()>0;as=k()at=core.getAltitude()ap=lm()F=q()b4=F;if CollisionSystem then ly()end;if antigrav then bz=antigrav.getState()==1 end;local lM=1;local lN=1;local lO=F-b4;local lP=-math.deg(li(bo,bs,bp))local lQ=math.deg(li(bq,bs,bp))local h9=bu*-1;b3=ar and lP<-YawStallAngle or lP>YawStallAngle or lQ<-PitchStallAngle or lQ>PitchStallAngle;local lR=system.getMouseDeltaX()local lS=system.getMouseDeltaY()if InvertMouse and not a2 then lS=-lS end;W=0;a0=0;V=0;sys=aS[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aV(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bs)if at==0 then at=(bw-planet.center):len()-planet.radius end;bN=unit.getClosestPlanetInfluence()>0 or at>0 and at<200000;local jX=planet:getGravity(core.getConstructWorldPos()):len()*aw;b5=0;aU=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a2 then if not a_ then ah=ah+lR;ai=ai+lS end else ah=0;ai=0 end else ah=ah+lR;ai=ai+lS;ak=z(ah*ah+ai*ai)if not a2 and m()==0 then if userControlScheme=="virtual joystick"then if ah>0 and ah>DeadZone then W=W-(ah-DeadZone)*MouseXSensitivity elseif ah<0 and ah<DeadZone*-1 then W=W-(ah+DeadZone)*MouseXSensitivity else W=0 end;if ai>0 and ai>DeadZone then V=V-(ai-DeadZone)*MouseYSensitivity elseif ai<0 and ai<DeadZone*-1 then V=V-(ai+DeadZone)*MouseYSensitivity else V=0 end else ah=0;ai=0;if userControlScheme=="mouse"then V=(-utils.smoothstep(lS,-100,100)+0.5)*2*lM;W=(-utils.smoothstep(lR,-100,100)+0.5)*2*lN end end end end;local lT=bt>8334;if bt>SpaceSpeedLimit/3.6 and not ar and not Autopilot and not lT then a3="Space Speed Engine Shutoff reached"cn(0)end;if not lT and LastIsWarping then if not BrakeIsOn then cF()end;if Autopilot then cD()end end;LastIsWarping=lT;if ar and as>0.09 then if bt>b8/3.6 and not AtmoSpeedAssist and not lg then BrakeIsOn=true;lg=true elseif not AtmoSpeedAssist and lg then if bt<b8/3.6 then BrakeIsOn=false;lg=false end end end;if BrakeIsOn then Z=1 else Z=0 end;if ProgradeIsOn then if am then BrakeIsOn=false;local lU=false;if CustomTarget and am~=1 then lU=lD(CustomTarget.position-bw,0.1)else lU=lD(vec3(bs),0.01)end;b1=true;if lU then cq(e(b8))if(d(bD)<2 or d(bC)>85)and bt>=b8/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;S=true;if am~=1 then ao=true end;am=false;Autopilot=false;cG()end elseif ar and AtmoSpeedAssist then cn(1)end elseif bt>R then lD(vec3(bs),0.01)end end;if RetrogradeIsOn then if ar then RetrogradeIsOn=false elseif bt>R then lD(-vec3(bs))end end;if not ProgradeIsOn and am and not IntoOrbit then if as==0 then S=true;cG()am=false;ao=true else am=false;cD()end end;if ao and CustomTarget and(at<HoldAltitude+250 and at>HoldAltitude-250)and bt*3.6>b8-250 and d(bv)<25 and as>=0.1 and(CustomTarget.position-bw):len()>2000+at then cD()ao=false end;if VertTakeOff then b1=true;local lV=HoldAltitude;if bv<-30 then a3="Unable to achieve lift. Safety Landing."ag=0;b1=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bz or HoldAltitude<planet.spaceEngineMinAltitude then if bz then lV=antigrav.getBaseAltitude()end;if at<lV-100 then b9=0;ag=15;BrakeIsOn=false elseif bv>0 then BrakeIsOn=true;ag=0 elseif bv<-30 then BrakeIsOn=true;ag=15 elseif at>=lV then if bz then if Autopilot or VectorToTarget then cy()else BrakeIsOn=true;VertTakeOff=false end;a3="Takeoff complete. Singularity engaged"c5("aggLk","AG")else BrakeIsOn=false;a3="VTO complete. Engaging Horizontal Flight"c5("vtoc","VT")cy()end;ag=0 end else if as>0.08 then b9=0;BrakeIsOn=false;ag=20 elseif as<0.08 and as>0 then BrakeIsOn=false;if bl then b9=0;ag=20 else ag=0;b9=36;cq(3500)end else b1=autoRollPreference;IntoOrbit=true;bj=false;CancelIntoOrbit=false;bd=false;bb=nil;bc=nil;if bi==nil then bi=planet end;bh=lV;bg=true;VertTakeOff=false end end;if b9~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local lW=r(b9-bC,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(lW)local lX=r(vTpitchPID:get(),-1,1)V=lX end end;if IntoOrbit then local lJ;local lY=false;local lZ=cv(bh)if bi==nil then bi=planet;if VectorToTarget then bi=ad end end;if not bg then bh=e(bi.radius+bi.surfaceMaxAltitude+LowOrbitHeight)if bi.hasAtmosphere then bh=e(bi.radius+bi.noAtmosphericDensityAltitude+LowOrbitHeight)end;bg=true end;if bf.VectorToTarget and CustomTarget then lJ=CustomTarget.position-bw end;local l_,m0=aV(bi):escapeAndOrbitalSpeed((bw-bi.center):len()-bi.radius)local m1=bD;if not bd then local m2=false;local m3=false;cn(0)bc=0;ba="Aligning to orbital path - OrbitHeight: "..lZ;if bf.VectorToTarget then lD(lJ:normalize():project_on_plane(bu))lY=bp:dot(lJ:project_on_plane(bo):normalize())>0.95 else lD(bs)lY=lP<0.5;if bt<150 then lY=true end end;V=0;bb=0;if bC<=bb+1 and bC>=bb-1 then m2=true else m2=false end;if m1<=bc+1 and m1>=bc-1 then m3=true else m3=false end;if m2 and m3 and lY then bb=nil;bc=nil;bd=true end else if bf.VectorToTarget then lD(lJ:normalize():project_on_plane(bu))elseif bt>150 then lD(bs)end;V=0;if bf.VectorToTarget and CustomTarget then local a9,_=aT.computeDistanceAndTime(bt,b8/3.6,aw,0,0,LastMaxBrake)if bj and lJ:len()>15000+a9+at then ba="Orbiting to Target"if at-100<=bi.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bi.noAtmosphericDensityAltitude then bj=false end elseif bj or lJ:len()<15000+a9+at then a3="Orbit complete, proceeding with reentry"c5("orCom","OB")AutopilotTargetCoords=CustomTarget.position;S=true;ao=true;bf.VectorToTarget,bf.AutopilotAlign=false,false;cz()cG()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and at>bh*0.9 and at<bh*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bh*0.99 and orbit.apoapsis.altitude>=bh*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bj then if bj then BrakeIsOn=false;cn(0)bb=0;if not bf.VectorToTarget then a3="Orbit complete"c5("orCom","OB")cz()end else bn=bn+1;if bn>=2 then bj=true end end else ba="Adjusting Orbit - OrbitHeight: "..lZ;be=true;cq(m0*3.6+1)local m4=bh-at;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(m4-bv*r(utils.smoothstep(2000-m4,-2000,2000)^6*10,1,10))bb=r(VSpdPID:get(),-60,60)end end else local m5=2.75;local m6=d(B(l_*m5))local m7=m6%50;if m7>0 then m6=m6-m7+50 end;BrakeIsOn=false;if at<bh*0.8 then ba="Escaping planet gravity - OrbitHeight: "..lZ;bb=utils.map(bv,200,0,-15,80)elseif at>=bh*0.8 and at<bh*1.15 then ba="Approaching orbital corridor - OrbitHeight: "..lZ;m6=m6*0.75;bb=utils.map(bv,100,-100,-15,65)elseif at>=bh*1.15 and at<bh*1.5 then ba="Approaching orbital corridor - OrbitHeight: "..lZ;m6=m6*0.75;if bv<0 or be then bb=utils.map(at,bh*1.5,bh*1.01,-30,0)else bb=utils.map(at,bh*0.99,bh*1.5,0,30)end elseif at>bh*1.5 then ba="Reentering orbital corridor - OrbitHeight: "..lZ;bb=-65;local m8=utils.map(bv,-150,-400,1,0.55)m6=m6*m8 end;cq(e(m6))end end;if bb~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local m9=bb-bC;OrbitPitchPID:inject(m9)local ma=r(OrbitPitchPID:get(),-0.5,0.5)V=ma end end;if Autopilot and as==0 and not am then local function mb(bV,orbit)system.print(bV)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cn(0)Q=false;a3=bV;c5("apCom","AP")if orbit or am then if orbit and AutopilotTargetOrbit~=nil and not am then if not at or at==0 then return end;bh=at;bg=true end;cz()end end;local mc,md=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local me=(CustomTarget.position-ad.center):normalize()local mf=me:project_on_plane((ad.center-bw):normalize()):normalize()local mg=ad.center+mf*(ad.radius+AutopilotTargetOrbit)local mh=CustomTarget.position+(CustomTarget.position-ad.center):normalize()*(AutopilotTargetOrbit-ad:getAltitude(CustomTarget.position))if(bw-mg):len()<(bw-mh):len()then mc=mg else mc=mh;AutopilotEndSpeed=0 end;AutopilotTargetCoords=mc;aY.showWayPoint(ad,AutopilotTargetCoords)md=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;md=true;AutopilotRealigned=true;TargetSet=true;mc=CustomTarget.position+(bw-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=mc end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local me=(bw+bs*100000-ad.center):normalize()local mf=me:project_on_plane((ad.center-bw):normalize()):normalize()if mf:len()<1 then me=(bw+bp*100000-ad.center):normalize()mf=me:project_on_plane((ad.center-bw):normalize()):normalize()end;mc=ad.center+mf*(ad.radius+AutopilotTargetOrbit)AutopilotTargetCoords=mc;TargetSet=true;md=true;AutopilotRealigned=true;aY.showWayPoint(ad,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(mc)-bw):len()local c0,c1,c2=aS:getPlanetarySystem(0):castIntersections(bw,bs:normalize(),function(c3)if c3.noAtmosphericDensityAltitude>0 then return c3.radius+c3.noAtmosphericDensityAltitude else return c3.radius+c3.surfaceMaxAltitude*1.5 end end)local c4=c1;if c2~=nil and c1~=nil then c4=math.min(c2,c1)end;if c4~=nil and c4<AutopilotDistance and c0.name==ad.name then AutopilotDistance=c4 end;local lU=true;local mi=(ad.center-(bw+vec3(bs):normalize()*AutopilotDistance)):len()-ad.radius;local iI=cv(mi)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..iI..'"}')local a9,aa;if not TurnBurn then a9,aa=ld(bt)else a9,aa=lf(bt)end;if bt>50 and AutopilotAccelerating then local lJ=vec3(mc)-bw;local mj=r(math.deg(li(bo,bs:normalize(),lJ:normalize()))*bt/500,-90,90)local mk=r(math.deg(li(bq,bs:normalize(),lJ:normalize()))*bt/500,-90,90)if d(mj)<20 and d(mk)<20 then mj=mj*2;mk=mk*2 end;if d(mj)<2 and d(mk)<2 then mj=mj*2;mk=mk*2 end;local lP=-math.deg(li(bo,bp,bs:normalize()))local lQ=-math.deg(li(bq,bp,bs:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(mk-lQ)local ml=r(apPitchPID:get(),-1,1)V=V+ml;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(mj-lP)local mm=r(apYawPID:get(),-1,1)W=W+mm;md=true;if d(mj)>2 or d(mk)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"c5("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c5("apAcc","AP")end end elseif AutopilotAccelerating and bt<=50 then lD((mc-bw):normalize())end;if mi<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aV(ad):escapeAndOrbitalSpeed(mi)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local c0,c4=bZ((AutopilotTargetCoords-bw):normalize())if ad.name~=planet.name then if c0~=nil and ad.name~=c0.name and c4<AutopilotDistance then a3="Collision with "..c0.name.." in "..cv(c4).."\nClear LOS to continue."aj=5;lx=true else lx=false;a3=""end end end;if not lx then if not AutopilotCruising and not AutopilotBraking and not md then lU=lD((mc-bw):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then lU=lD(-vec3(bs):normalize())end end;if AutopilotAccelerating then if not Q then BrakeIsOn=false;cn(AutopilotInterplanetaryThrottle)L=B(AutopilotInterplanetaryThrottle,2)Q=true end;local mn=unit.getThrottle()if AtmoSpeedAssist then mn=L end;local mo=99999;local k8=-vec3(core.getWorldAcceleration()):dot(bs:normalize())local mp=r(bs:dot((mc-bw):normalize()),0,bt)if mp>0 or k8>0 then mo=aT.computeTravelTime(mp,k8,AutopilotDistance-a9)end;if br:len()>=MaxGameVelocity or mn==0 and Q or warmup/4>mo then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then c5("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cn(0)end;local mq=AutopilotDistance;if mq<=a9 or PreventPvP and bJ<=a9+10000 and bI then if PreventPvP and bJ<=a9+10000 and bI then if bJ<lh and bJ>2000 then cD()a3="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lh=bJ else lh=bJ;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c5("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cn(0)Q=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Z=1 end;if TurnBurn then cn(1,true)end;local _,m0=aV(ad):escapeAndOrbitalSpeed((bw-planet.center):len()-planet.radius)local lJ;if CustomTarget then lJ=CustomTarget.position-bw end;if CustomTarget and CustomTarget.planetname=="Space"and bt<50 then mb("Autopilot complete, arrived at space location")BrakeIsOn=true;Z=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bt<=m0 and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then mb("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;am=true;aY.showWayPoint(ad,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then c5("apCir","AP")AutopilotStatus="Circularizing"end;if bt<=m0 then if CustomTarget then if bs:normalize():dot(lJ:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then c5("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aY.showWayPoint(ad,CustomTarget.position)WaypointSet=true end else mb("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;am=true;aY.showWayPoint(ad,CustomTarget.position)WaypointSet=false end else mb("Autopilot completed, setting orbit",true)Z=0 end end elseif AutopilotStatus=="Circularizing"then mb("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local mq=AutopilotDistance;if mq<=a9 or PreventPvP and bJ<=a9+10000 and bI then if PreventPvP and bJ<=a9+10000 and bI then if bJ<lh and bJ>2000 then cD()a3="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lh=bJ else lh=bJ;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c5("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local mn=unit.getThrottle()if AtmoSpeedAssist then mn=L end;if mn>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c5("apAcc","AP")end;AutopilotCruising=false end else if lU then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not am then AutopilotTargetCoords=vec3(ad.center)+(AutopilotTargetOrbit+ad.radius)*bq;AutopilotShipUp=bo;AutopilotShipRight=bq end;AutopilotRealigned=true elseif lU and not lx then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c5("apAcc","AP")end;if not Q then cn(AutopilotInterplanetaryThrottle,true)L=B(AutopilotInterplanetaryThrottle,2)Q=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and as>0)then a3="Autopilot complete, starting reentry"c5("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Z=0;cn(0)Q=false;ProgradeIsOn=true;am=true;aY.showWayPoint(ad,CustomTarget.position)end;if a1 then b1=true;local mk=0;local eJ=bw+vec3(unit.getMasterPlayerRelativePosition())local mr=eJ-bw;local ms=vec3(mr):project_on(bp):len()local mt=vec3(mr):project_on(bq):len()local ak=z(ms*ms+mt*mt)lD(mr:normalize())local mu=40;local mv=ak<mu;local mw=100;local mx=r((ak-mu)/2,10,mw)V=0;local lU=d(W)<0.1;if lU and bt<mx and not mv then BrakeIsOn=false;mk=-20 else BrakeIsOn=true;mk=0 end;local my=0;if d(mk-bC)>my then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(mk-bC)local ml=pitchPID:get()V=ml end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local mz=LastMaxBrakeInAtmo;if mz then mz=mz*r(bt/100,0.1,1)*as else mz=LastMaxBrake end;if as<0.01 then mz=LastMaxBrake end;local mA=bp:project_on_plane(bu):normalize():dot(bs)local mB=vec3(core.getWorldAirFrictionAcceleration())local mC=mB:len()*aw;if mA>100 then a9,aa=aT.computeDistanceAndTime(mA,100,aw,0,0,mz)local mD,mE=aT.computeDistanceAndTime(100,0,aw,0,0,mz*0.55)a9=a9+mD else a9,aa=aT.computeDistanceAndTime(mA,0,aw,0,0,mz*0.55)end;local m4=HoldAltitude-at-bv;local mF=200+bt;if Reentry or am then minMax=2000+bt end;local mG=1;if AutoTakeoff then mG=r(bt/100,0.1,1)end;local mk=(utils.smoothstep(m4,-mF,mF)-0.5)*2*MaxPitch*mG;if not Reentry and not am and not VectorToTarget and bp:dot(bs:normalize())<0.99 then mk=(utils.smoothstep(m4,-mF*r(20-19*as*10,1,20),mF*r(20-19*as*10,1,20))-0.5)*2*MaxPitch*r(2-as*10,1,2)*mG end;if not AltitudeHold then mk=0 end;if LockPitch~=nil then if bN and not IntoOrbit then mk=LockPitch else LockPitch=nil end end;b1=true;local mH=V;if Reentry then local mI=e(b8)local mJ,mK=aT.computeDistanceAndTime(bt,mI/3.6,aw,0,0,LastMaxBrake-planet.gravity*9.8*aw)mJ=mJ==-1 and 5000 or mJ;local mL=at-(planet.noAtmosphericDensityAltitude+mJ)local mM=at>planet.noAtmosphericDensityAltitude+mJ*1.35;if mM then mk=ReEntryPitch;if bt<=mI/3.6 and bt>mI/3.6-10 and d(bs:normalize():dot(bp))>0.9 and not bB then P=false;cn(1)end elseif bB and not mM and not ar then cq(mI,true)end;if bB then if bt>mI/3.6 and not mM then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bv>0 then BrakeIsOn=true end;if not S then mk=-80;if as>0.02 then a3="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;mk=0;b1=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and mM then b1=true elseif not mM then if not ar and(bB or s:getTargetSpeed(axisCommandId.longitudinal)~=mI)then cq(mI)end;if bt<mI/3.6+1 then BrakeIsOn=false;S=false;Reentry=false;b1=true end end end;if bt>R and not an and not VectorToTarget and not BrakeLanding and ForceAlignment then lD(vec3(bs))end;if bL or(VectorToTarget or an)and AutopilotTargetIndex>0 and as>0.01 then local lJ;if bL then if type(bL)=="table"then lJ=bL elseif bL<3 and bL>0 then lJ=-bu:cross(bs)*5000 elseif bL>=3 then lJ=bu:cross(bs)*5000 elseif bL<0 then lJ=bs*25000 end elseif CustomTarget~=nil then lJ=CustomTarget.position-bw else lJ=ad.center-bw end;local mj=math.deg(li(bu:normalize(),bs,lJ))*2;local mN=math.rad(d(bD))if bt>minRollVelocity and as>0.01 then local mO=1000+bt;local mP=(utils.smoothstep(m4-bv*10,-mO,mO)-0.5)*2*MaxPitch;local mQ=r(90-mP,0,180)b5=r(mj*2,-mQ,mQ)local mR=mj;mj=r(r(mj,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(mN)+4*(bC-mk)*math.sin(math.rad(bD)),-YawStallAngle*0.80,YawStallAngle*0.80)local mS=1;if b5~=0 then mS=d(mN/b5)end;mS=(90-r(d(b5-bD),0,90))/90;local mT=mk;if d(bD)>90 then mT=-mT end;mk=mS*r(r(mT*math.cos(mN),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(mR)*math.sin(mN),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b5=0;mj=r(mj,-YawStallAngle*0.80,YawStallAngle*0.80)end;local mU=lP-mj;if bL and d(mU)<=0.0001 and(type(bL)=="table"or type(bL)~="table"and bL<0 and d(bD)<1)then if bL==-2 then cA()end;bL=nil;c5("180Off","BR")return end;if not b3 and bt>minRollVelocity and as>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(mU)local mm=r(yawPID:get(),-1,1)W=W+mm elseif ar and ap>-1 or bt<minRollVelocity then lD(lJ)elseif b3 and as>0.01 then if(lP<-YawStallAngle or lP>YawStallAngle)and as>0.01 then lD(bs)end;if(lQ<-PitchStallAngle or lQ>PitchStallAngle)and as>0.01 then mk=r(bC-lQ,bC-PitchStallAngle*0.80,bC+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not an then local lV=planet:getAltitude(CustomTarget.position)local mL=lJ:project_on_plane(bu):len()StrongBrakes=true;if not an and not Reentry and mL<=a9 and(bs:project_on_plane(bu):normalize():dot(lJ:project_on_plane(bu):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cn(0)if AltitudeHold then cA()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(mA<0.1 or mL<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<mL)then if not bz then c5("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bO=false end;LastDistanceToTarget=mL end elseif VectorToTarget and as==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(an or Reentry)then if CustomTarget~=nil and ad.name==planet.name then local lJ=CustomTarget.position-bw;local lV=planet:getAltitude(CustomTarget.position)local mL=z(lJ:len()^2-(at-lV)^2)local mz=LastMaxBrakeInAtmo;if mz then a9,aa=aT.computeDistanceAndTime(bt,0,aw,0,0,mz/2)StrongBrakes=true;if mL<=a9+bt*lO/2 and bs:project_on_plane(bu):normalize():dot(lJ:project_on_plane(bu):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;S=true;am=false;ao=true;Autopilot=false;cG()end end;LastDistanceToTarget=mL end end end;if as==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(an or IntoOrbit or Reentry)then if not bj and not IntoOrbit then bh=HoldAltitude;bg=true;if VectorToTarget then bf.VectorToTarget=true end;cz()VectorToTarget=false;bd=true end end;if b3 and as>0.01 and ap==-1 and bt>minRollVelocity and VectorStatus~="Finalizing Approach"then lD(bs)mk=r(bC-lQ,bC-PitchStallAngle*0.80,bC+PitchStallAngle*0.80)end;V=mH;local lr=-1;if BrakeLanding then mk=0;local mV=false;local mW=30;if aU~=nil and aU>0 then local mX=r(as,0.4,2)local mz=LastMaxBrakeInAtmo*r(bt/100,0.1,1)*mX;local mY=aU*mX+mz-jX;local mZ=mz/2-jX;local m_=bt-z(d(mZ/2)*20/(0.5*aw))*utils.sign(mZ)if m_<0 then m_=0 end;local n0;if bt>100 then local n1,_=aT.computeDistanceAndTime(bt,100,aw,0,0,mz)local n2,_=aT.computeDistanceAndTime(100,0,aw,0,0,z(mz))n0=n1+n2 else n0=aT.computeDistanceAndTime(bt,0,aw,0,0,z(mz))end;if n0<20 then BrakeIsOn=false else local n3=0;if m_>100 then local n4,_=aT.computeDistanceAndTime(m_,100,aw,0,0,mY)local n5,_=aT.computeDistanceAndTime(100,0,aw,0,0,aU*mX+z(mz)-jX)n3=n4+n5 else n3,_=aT.computeDistanceAndTime(m_,0,aw,0,0,aU*mX+z(mz)-jX)end;n3=(n3+15+bt*lO)*1.1;local n6=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if n6 then local lV=planet:getAltitude(CustomTarget.position)local n7=at-lV-100;local lJ=CustomTarget.position-bw;local n8=z(lJ:len()^2-(at-lV)^2)if n8>100 then n6=false elseif n7<=n3 or n3==-1 then BrakeIsOn=true;mV=true else BrakeIsOn=false;mV=true end end;if not n6 and CalculateBrakeLandingSpeed then if n3>=mW then BrakeIsOn=true else BrakeIsOn=false end;mV=true end end end;if not bB then cn(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;lr=ap;if lr>-1 then b1=autoRollPreference;if bt<1 or bs:normalize():dot(bu)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if T then a.control.extendLandingGears()c5("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)ag=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bs:normalize():dot(-h9)<0.999 then BrakeIsOn=true elseif bv<-brakeLandingRate and not mV then BrakeIsOn=true elseif not mV then BrakeIsOn=false end end;if AutoTakeoff or an then local c0,c2,c1;if AutopilotTargetCoords~=nil then c0,c2,c1=aS:getPlanetarySystem(0):castIntersections(bw,(AutopilotTargetCoords-bw):normalize(),function(c3)return c3.radius+c3.noAtmosphericDensityAltitude end)end;if bz then if at>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cn(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(mk)<15 and at/HoldAltitude>0.75 then AutoTakeoff=false;if not an then if bB and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif an and bt<R then Autopilot=true;an=false;AltitudeHold=false;AutoTakeoff=false;cn(0)elseif an then cn(0)BrakeIsOn=true end elseif an and as==0 and ad~=nil and(c0==nil or c0.name==ad.name)then Autopilot=true;an=false;AltitudeHold=false;AutoTakeoff=false;if not bB then cn(0)end;AutopilotAccelerating=true end end;local n9=ap>-1;local na=bC;if(VectorToTarget or an or bL)and not n9 and bt>minRollVelocity and as>0.01 then local mN=math.rad(d(bD))na=bC*d(math.cos(mN))+lQ*math.sin(mN)end;local nb=r(mk-na,-PitchStallAngle*0.80,PitchStallAngle*0.80)if as<0.01 and VectorToTarget then nb=r(mk-na,-85,MaxPitch)elseif as<0.01 then nb=r(mk-na,-MaxPitch,MaxPitch)end;if d(bD)<5 or VectorToTarget or bL or BrakeLanding or n9 or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(nb)local ml=pitchPID:get()V=V+ml end end;if antigrav~=nil and(antigrav and not ExternalAGG and at<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ap=lm()return cC end;function script.onStart()local nc={}local nd={}local ne=false;local function nf()local function ng(nh)local ni=dbHud_1.hasKey;for cR,cS in pairs(nh)do if ni(cS)then local d7=g(dbHud_1.getStringValue(cS))if d7~=nil then _G[cS]=d7;ne=true end end end end;if dbHud_1 then if not useTheseSettings then ng(cb())coroutine.yield()ng(c)else ng(c)a3="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"aj=5;ne=false end;coroutine.yield()if ne then a3="Loaded Saved Variables"aH=ResolutionX;aI=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b1=autoRollPreference;b8=AtmoSpeedLimit;az=[[rgb(]]..e(I+0.5)..","..e(K+0.5)..","..e(J+0.5)..[[)]]aA=[[rgb(]]..e(I*0.9+0.5)..","..e(K*0.9+0.5)..","..e(J*0.9+0.5)..[[)]]elseif not useTheseSettings then a3="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a3="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a3="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<F then LastMaxBrakeInAtmo=0 end;LastStartTime=F;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a3="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"aj=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=at end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function nj()local function nk(nl,nm)if nl>nm then nm=nl end;local nn,no=0,0;if ContainerOptimization>0 then nn=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then no=FuelTankOptimization*0.05 end;nm=nm*(1-(nn+no))return nm end;local np=core.getElementNameById;local nq=fuelX~=0 and fuelY~=0;for cR in pairs(au)do local type=core.getElementTypeById(au[cR])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(au[cR])),'^.*vertical.*$')and core.getElementForwardById(au[cR])[3]>0 then by=true end end;if o(type,'^.*Space Engine$')then bm=true;if o(tostring(core.getElementTagsById(au[cR])),'^.*vertical.*$')then local nr=core.getElementForwardById(au[cR])if nr[3]<0 then bk=true else bl=true end end end;if type=="Landing Gear"then T=true end;if type=="Dynamic Core Unit"then local ns=j(au[cR])if ns>10000 then H=110 elseif ns>1000 then H=55 elseif ns>150 then H=27 end end;aM=aM+j(au[cR])if nq and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local ns=j(au[cR])local k4=l(au[cR])local nl=0;local gY=q()if type=="Atmospheric Fuel Tank"then local nm=400;local nt=35.03;if ns>10000 then nm=51200;nt=5480 elseif ns>1300 then nm=6400;nt=988.67 elseif ns>150 then nm=1600;nt=182.67 end;nl=k4-nt;if fuelTankHandlingAtmo>0 then nm=nm+nm*fuelTankHandlingAtmo*0.2 end;nm=nk(nl,nm)aJ[#aJ+1]={au[cR],np(au[cR]),nm,nt,nl,gY}end;if type=="Rocket Fuel Tank"then local nm=320;local nt=173.42;if ns>65000 then nm=40000;nt=25740 elseif ns>6000 then nm=5120;nt=4720 elseif ns>700 then nm=640;nt=886.72 end;nl=k4-nt;if fuelTankHandlingRocket>0 then nm=nm+nm*fuelTankHandlingRocket*0.1 end;nm=nk(nl,nm)aL[#aL+1]={au[cR],np(au[cR]),nm,nt,nl,gY}end;if type=="Space Fuel Tank"then local nm=600;local nt=35.03;if ns>10000 then nm=76800;nt=5480 elseif ns>1300 then nm=9600;nt=988.67 elseif ns>150 then nm=2400;nt=182.67 end;nl=k4-nt;if fuelTankHandlingSpace>0 then nm=nm+nm*fuelTankHandlingSpace*0.2 end;nm=nk(nl,nm)aK[#aK+1]={au[cR],np(au[cR]),nm,nt,nl,gY}end end end;if not by then VertTakeOff,VertTakeOffEngine=false,false end end;local function nu()if gyro~=nil then ay=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(ar or not ar and at<10000)then for _,cS in pairs(door)do cS.toggle()end end;if switch then for _,cS in pairs(switch)do cS.toggle()end end;if forcefield and(ar or not ar==0 and at<10000)then for _,cS in pairs(forcefield)do cS.toggle()end end;if antigrav then bz=antigrav.getState()==1;if bz and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if T then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ap~=-1 or not ar and br:len()<50 then BrakeIsOn=true;GearExtended=true;if T then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b2)if ar and ap~=-1 then aU=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ar end;local function nw(cj,y,kz,kd,ie)local nx={x=cj,y=y,width=kz,height=kd,label=ie}bU[ie]=nx;return nx end;local function ny(kQ,kP,kz,kd,cj,y,nz,nA,nB,nC)local nx={enableName=kQ,disableName=kP,width=kz,height=kd,x=cj,y=y,toggleVar=nz,toggleFunction=nA,drawCondition=nB,hovered=false}if nC then table.insert(nd,nx)else table.insert(nc,nx)end;return nx end;local function nD(nE)if not bE then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif nE=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif nE=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif nE=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bF=cb(nE)showHud=false else bF={}showHud=true end end;local function nF()bE=not bE;if bE then aG=nd;a3="Hold SHIFT to see Settings"bG=showHud else aG=nc;a3="Hold SHIFT to see Control Buttons"nD()showHud=bG end end;local function nG()local function nH(cS)_G[cS]=not _G[cS]if _G[cS]then a3=cS.." set to true"else a3=cS.." set to false"end;if cS=="showHud"then bG=_G[cS]elseif cS=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local nI=50;local nJ=340;local cj=500;local y=aI/2-400;local nK=0;for cR,cS in pairs(cb("boolean"))do if type(_G[cS])=="boolean"then ny(cS,cS,nJ,nI,cj,y,function()return _G[cS]end,function()nH(cS)end,function()return true end,true)y=y+nI+20;if nK==9 then cj=cj+nJ+20;y=aI/2-400;nK=0 else nK=nK+1 end end end;ny("Control View","Control View",nJ,nI,10,aI/2-500,function()return true end,nF,function()return true end,true)ny("View Handling Settings",'Hide Handling Settings',nJ,nI,10,aI/2-(500-nI),function()return showHandlingVariables end,function()nD("handling")end,function()return true end,true)ny("View Hud Settings",'Hide Hud Settings',nJ,nI,10,aI/2-(500-nI*2),function()return showHudVariables end,function()nD("hud")end,function()return true end,true)ny("View Physics Settings",'Hide Physics Settings',nJ,nI,10,aI/2-(500-nI*3),function()return showPhysicsVariables end,function()nD("physics")end,function()return true end,true)end;local function nL()local function l6()local position=bw;local g6=planet.name..". "..#SavedLocations;if bQ[1]then local dj,_=bQ[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dj~=nil and dj~=""then g6=g6 .." "..bQ[1].getConstructName(dj)end end;return aX.AddNewLocation(g6,position,false,true)end;local function nM()TurnBurn=not TurnBurn end;local function nN(nO)if nO==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a1=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function nP()aX.UpdatePosition()end;local function l5()aX.ClearCurrentPosition()end;local function nQ(fS)local g6=AutopilotTargetName;if fS~=nil and type(fS)=="number"then if fS==0 then return"None"end;g6=bH[fS].name end;if g6==nil then g6=CustomTarget.name end;if g6==nil then g6="None"end;return g6 end;local function nR(fS)return"Engage Autopilot: "..nQ(fS)end;local function nS(fS)return"Disable Autopilot: "..nQ(fS)end;local function nT()if m()==1 then a1=not a1;if a1 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)c5("folOn","F")else c5("folOff","F")BrakeIsOn=true;b1=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a3="Follow Mode only works with Remote controller"a1=false end end;local nI=50;local nJ=260;local nU=ny("Enable Brake Toggle","Disable Brake Toggle",nJ,nI,aH/2-nJ/2,aI/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a3="Brakes in Toggle Mode"else a3="Brakes in Default Mode"end end)ny("Align Prograde","Disable Prograde",nJ,nI,aH/2-nJ/2-50-nU.width,aI/2-nI+380,function()return ProgradeIsOn end,function()nN(1)end)ny("Align Retrograde","Disable Retrograde",nJ,nI,aH/2-nJ/2+nU.width+50,aI/2-nI+380,function()return RetrogradeIsOn end,nN,function()return as==0 end)apbutton=ny(nR,nS,600,60,aH/2-600/2,aI/2-60/2-330,function()return Autopilot or VectorToTarget or an or IntoOrbit end,function()end)local i;local function nV(nW)local fS=bT+nW;if fS>#bH then fS=fS-#bH-1 end;if fS<0 then fS=#bH+fS end;return fS end;apExtraButtons={}for i=0,10 do local button=ny(function(cu)local fS=nV(cu.apExtraIndex)if Autopilot or VectorToTarget or an or IntoOrbit then return"Redirect: "..nQ(fS)end;return nR(fS)end,function(cu)local fS=nV(cu.apExtraIndex)return nS(fS)end,600,60,aH/2-600/2,aI/2-60/2-330+60*i,function(cu)local fS=nV(cu.apExtraIndex)return fS==AutopilotTargetIndex and(Autopilot or VectorToTarget or an or IntoOrbit)end,function(cu)local fS=nV(cu.apExtraIndex)local nX=AutopilotTargetIndex==fS;AutopilotTargetIndex=fS;aX.UpdateAutopilotTarget()cD()if not nX and not(Autopilot or VectorToTarget or an or IntoOrbit)then cD()end end,function()return bS end)button.apExtraIndex=i;apExtraButtons[i]=button end;ny("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,l6,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)ny("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,nP,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ny("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,l5,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)nI=60;nJ=300;local cj=0;local y=aI/2-150;ny("View Settings","View Settings",nJ,nI,cj,y,function()return true end,nF)y=y+nI+20;ny("Enable Turn and Burn","Disable Turn and Burn",nJ,nI,cj,y,function()return TurnBurn end,nM)cj=10;y=aI/2-300;ny("Horizontal Takeoff Mode","Vertical Takeoff Mode",nJ,nI,cj+nJ+20,y,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a3="Vertical Takeoff Mode"else a3="Horizontal Takeoff Mode"end end,function()return by end)y=y+nI+20;ny("Engage Orbiting","Cancel Orbiting",nJ,nI,cj+nJ+20,y,function()return IntoOrbit end,cz,function()return as==0 and bN end)y=y+nI+20;ny("Glide Re-Entry","Cancel Glide Re-Entry",nJ,nI,cj,y,function()return Reentry end,function()am=1;nN(1)end,function()return planet.hasAtmosphere and not ar end)ny("Parachute Re-Entry","Cancel Parachute Re-Entry",nJ,nI,cj+nJ+20,y,function()return Reentry end,cG,function()return planet.hasAtmosphere and not ar end)y=y+nI+20;ny("Engage Follow Mode","Disable Follow Mode",nJ,nI,cj,y,function()return a1 end,nT,function()return m()==1 end)ny("Enable Repair Arrows","Disable Repair Arrows",nJ,nI,cj+nJ+20,y,function()return aN end,function()aN=not aN;if aN then a3="Repair Arrows Enabled"else a3="Repair Arrows Diabled"end end,function()return m()==1 end)y=y+nI+20;if not ExternalAGG then ny("Enable AGG","Disable AGG",nJ,nI,cj,y,function()return bz end,cH,function()return antigrav~=nil end)end;ny(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,nJ*2,nI,cj,y,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a3="IPH Mode: "..iphCondition end)y=y+nI+20;ny(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,nJ*2,nI,cj,y,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a3="New Control Scheme: "..userControlScheme end)local nY=gi(20)local button=nw(0,0,gh(70),nY,"INFO")button=nw(button.x+button.width,button.y,gh(80),nY,"ORBIT")button=nw(button.x+button.width,button.y,gh(70),nY,"HELP")nw(button.x+button.width,button.y,gh(70),nY,"HIDE")end;local function nZ()local n_={}local function o0()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local o1={[1]=4480,[6]=4480,[7]=6270}for o2,o3 in pairs(b)do b[o2][0]=o0()b[o2][0].systemId=o2;n_[o2]={}for o4,planet in pairs(b[o2])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=o1[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=o2;planet.bodyId=planet.id;n_[o2][o4]=planet end end;aR=cT()aS=aR(n_)aT=ed()aV=eH()aX=kU()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})nf()coroutine.yield()nj()coroutine.yield()aY=lc()nu()nG()nL()aG=nc;coroutine.yield()nZ()aZ=f4()aW=gj()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bQ[1]=nil;if radar_1 then bQ[1]=radar_1;aZ.pickType()end;c5("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(as>0 or as==0 and at<10000)then for _,cS in pairs(door)do cS.toggle()end end;if switch then for _,cS in pairs(switch)do cS.toggle()end end;if forcefield and(as>0 or as==0 and at<10000)then for _,cS in pairs(forcefield)do cS.toggle()end end;cN()if button then button.activate()end;if SetWaypointOnExit then aY.showWayPoint(planet,bw)end;c5("stop","SU")end;function script.onTick(o5)local o6=nil;if o5=="contact"then if not contactTimer then contactTimer=0 end;if F>contactTimer+10 then a3="Radar Contact"c5("rdrCon","RC")contactTimer=F end;unit.stopTimer("contact")elseif o5=="tenthSecond"then local function o7()local o8=system.createData;local o9=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=o9(panelInterplanetary,"value")interplanetaryHeaderText=o8('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=o9(panelInterplanetary,"value")widgetDistanceText=o8('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=o9(panelInterplanetary,"value")widgetTravelTimeText=o8('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=o9(panelInterplanetary,"value")widgetMaxMassText=o8('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=o9(panelInterplanetary,"value")widgetTargetOrbitText=o8('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=o9(panelInterplanetary,"value")widgetCurBrakeDistanceText=o8('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=o9(panelInterplanetary,"value")widgetCurBrakeTimeText=o8('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=o9(panelInterplanetary,"value")widgetMaxBrakeDistanceText=o8('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=o9(panelInterplanetary,"value")widgetMaxBrakeTimeText=o8('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=o9(panelInterplanetary,"value")widgetTrajectoryAltitudeText=o8('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ar then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function oa()t(panelInterplanetary)panelInterplanetary=nil end;local function ob()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ad.center-bw):len()else AutopilotDistance=(CustomTarget.position-bw):len()end end;local eF=bt;local mn=unit.getThrottle()/100;if AtmoSpeedAssist then mn=L end;local oc,od=aT.computeDistanceAndTime(bt,MaxGameVelocity,aw,a:maxForceForward()*mn,warmup,0)local a9,aa;if not TurnBurn then a9,aa=aY.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a9,aa=aY.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,oe;if not TurnBurn and eF>0 then _,oe=aY.GetAutopilotBrakeDistanceAndTime(eF)else _,oe=aY.GetAutopilotTBBrakeDistanceAndTime(eF)end;local of=0;local og=0;if AutopilotCruising or not Autopilot and eF>5 then og=aT.computeTravelTime(eF,0,AutopilotDistance)elseif a9+oc<AutopilotDistance then of=AutopilotDistance-(a9+oc)og=aT.computeTravelTime(8333.0556,0,of)else local oh=(AutopilotDistance-a9)/oc;oc=AutopilotDistance-a9;od=od*oh end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return og elseif AutopilotBraking then return oe elseif AutopilotCruising then return og+oe else return od+aa+og end end;local function oi(jX,oj)if jX==nil then jX=core.g()end;jX=B(jX,5)if oj~=nil and oj or(o6==nil or o6~=jX)then local eF=br:len()local ok=g(unit.getData()).maxBrake;if ok~=nil and ok>0 and ar then ok=ok/r(eF/100,0.1,1)ok=ok/as;if as>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+ok)/2 else LastMaxBrakeInAtmo=ok end end end;if ok~=nil and ok>0 then LastMaxBrake=ok end;o6=jX end end;oi(nil,true)if bA~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bA then cq(bA)else bA=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then o7()end;if AutopilotTargetName~=nil then local ol=CustomTarget~=nil;local om=0.5*LastMaxBrakeInAtmo/ad:getGravity(ad.center+vec3(0,0,1)*ad.radius):len()om=om>1000000 and B(om/1000000,2).." kTons"or B(om/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=ob()if ol and not Autopilot then ak=(bw-CustomTarget.position):len()else ak=(AutopilotTargetCoords-bw):len()end;if not TurnBurn then a9,aa=aY.GetAutopilotBrakeDistanceAndTime(bt)ab,ac=aY.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a9,aa=aY.GetAutopilotTBBrakeDistanceAndTime(bt)ab,ac=aY.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local iI=cv(ak)u(widgetDistanceText,'{"label": "distance", "value": "'..iI..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cI(travelTime)..'", "unit":""}')iI=cv(a9)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..iI..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cI(aa)..'", "unit":""}')iI=cv(ab)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..iI..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cI(ac)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",om)..'", "unit":""}')iI=cv(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..iI..'"}')if as>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bB and AtmoSpeedAssist and(AltitudeHold or Reentry or ao)then cn(1)BrakeIsOn=false;P=false end end;if as==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else oa()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aW.DrawTanks()if shield_1 then aW.DrawShield()end elseif o5=="oneSecond"then local function on(h5)local oo=0;aE=""local op=aM;local oq=0;local os=0;local ot=0;local h1=0;local h2=""local ou=core.getElementHitPointsById;for cR in pairs(au)do local ns=0;local ov=0;ov=j(au[cR])ns=ou(au[cR])oq=oq+ns;if ns<ov then if ns==0 then ot=ot+1 else os=os+1 end;if aN and#aB==0 then position=vec3(core.getElementPositionById(au[cR]))local cj=position.x;local y=position.y;local fz=position.z;table.insert(aB,core.spawnArrowSticker(cj,y,fz+1,"down"))table.insert(aB,core.spawnArrowSticker(cj,y,fz+1,"down"))core.rotateSticker(aB[2],0,0,90)table.insert(aB,core.spawnArrowSticker(cj+1,y,fz,"north"))table.insert(aB,core.spawnArrowSticker(cj+1,y,fz,"north"))core.rotateSticker(aB[4],90,90,0)table.insert(aB,core.spawnArrowSticker(cj-1,y,fz,"south"))table.insert(aB,core.spawnArrowSticker(cj-1,y,fz,"south"))core.rotateSticker(aB[6],90,-90,0)table.insert(aB,core.spawnArrowSticker(cj,y-1,fz,"east"))table.insert(aB,core.spawnArrowSticker(cj,y-1,fz,"east"))core.rotateSticker(aB[8],90,0,90)table.insert(aB,core.spawnArrowSticker(cj,y+1,fz,"west"))table.insert(aB,core.spawnArrowSticker(cj,y+1,fz,"west"))core.rotateSticker(aB[10],-90,0,90)table.insert(aB,au[cR])end elseif aN and#aB>0 and aB[11]==au[cR]then for gX in pairs(aB)do core.deleteSticker(aB[gX])end;aB={}end end;oo=e(oq/op*100)if oo<100 then if oo>0 and oo<WipeDamage then SavedLocations={}aX.UpdateAtlasLocationsList()aX.UpdateAutopilotTarget()cN()end;h5[#h5+1]=ci(0,0,"","pbright txt")h1=e(oo*2.55)h2=f("rgb(%d,%d,%d)",255-h1,h1,0)if oo<100 then h5[#h5+1]=ci("50%",1035,"Elemental Integrity: "..oo.."%","txtbig txtmid","fill:"..h2)if ot>0 then h5[#h5+1]=ci("50%",1055,"Disabled Modules: "..ot.." Damaged Modules: "..os,"txtbig txtmid","fill:"..h2)elseif os>0 then h5[#h5+1]=ci("50%",1055,"Damaged Modules: "..os,"txtbig txtmid","fill:"..h2)end end end end;local function ow()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function ox()local gY=q()local ii=bt;local oy=gY-av;if ii>1.38889 then ii=ii/1000;local oz=ii*(gY-av)TotalDistanceTravelled=TotalDistanceTravelled+oz;ae=ae+oz end;af=af+oy;TotalFlightTime=TotalFlightTime+oy;av=gY end;ox()aW.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()ow()local h5={}aW.ExtraData(h5)if ShouldCheckDamage then on(h5)end;al=table.concat(h5,"")collectgarbage("collect")elseif o5=="fiveSecond"then if not UseSatNav then return end;aq=dbHud_1.getStringValue("SPBAutopilotTargetName")if aq~=nil and aq~=""and aq~="SatNavNotChanged"then local d7=g(dbHud_1.getStringValue("SavedLocations"))if d7~=nil then _G["SavedLocations"]=d7;local fS=-1;local l8;for cR,cS in pairs(SavedLocations)do if cS.name and cS.name=="SatNav Location"then fS=cR;break end end;if fS~=-1 then l8=SavedLocations[fS]fS=-1;for cR,cS in pairs(b[0])do if cS.name and cS.name=="SatNav Location"then fS=cR;break end end;if fS>-1 then b[0][fS]=l8 end;aX.UpdateAtlasLocationsList()a3=l8.name.." position updated"end end;for i=1,#bH do if bH[i].name==aq then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bH[i].name)aX.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif o5=="msgTick"then local h5={}aW.DisplayMessage(h5,"empty")a3="empty"unit.stopTimer("msgTick")aj=3 elseif o5=="animateTick"then b0=true;a_=false;ah=0;ai=0;unit.stopTimer("animateTick")elseif o5=="hudTick"then aW.hudtick()elseif o5=="apTick"then aY.APTick()elseif o5=="radarTick"then aZ.UpdateRadar()elseif o5=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a3="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function oA(oB,mx)local oC=vec3()local oD=vec3()if oB==axisCommandId.longitudinal then oC=vec3(core.getConstructOrientationForward())oD=bp elseif oB==axisCommandId.vertical then oC=vec3(core.getConstructOrientationUp())oD=bo elseif oB==axisCommandId.lateral then oC=vec3(core.getConstructOrientationRight())oD=bq else return vec3()end;local oE=vec3(core.getWorldGravity())local oF=oE:dot(oD)local oG=vec3(core.getWorldAirFrictionAcceleration())local oH=oG:dot(oD)local oI=br:dot(oC)local oJ=mx*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(oJ-oI)local oK=targetSpeedPID2:get()local oL=(oK-oH-oF)*oD;return oL end;local function oM(oB,mx)local oC=vec3()local oD=vec3()if oB==axisCommandId.longitudinal then oC=vec3(core.getConstructOrientationForward())oD=bp elseif oB==axisCommandId.vertical then oC=vec3(core.getConstructOrientationUp())oD=bo elseif oB==axisCommandId.lateral then oC=vec3(core.getConstructOrientationRight())oD=bq else return vec3()end;local oE=vec3(core.getWorldGravity())local oF=oE:dot(oD)local oG=vec3(core.getWorldAirFrictionAcceleration())local oH=oG:dot(oD)local oI=br:dot(oC)local oJ=mx*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(oJ-oI)local oK=targetSpeedPID:get()local oL=(oK-oH-oF)*oD;return oL end;local function oN(oO,h8,kZ)local oP=oO:cross(kZ):normalize_inplace()local hV=math.acos(r(oP:dot(-h8),-1,1))*constants.rad2deg;if oP:cross(-h8):dot(kZ)<0 then hV=-hV end;return hV end;if antigrav and not ExternalAGG then if not bz and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bB=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bB and P then cn(0)P=false elseif not bB and not P then L=0;P=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local oQ=r(U+V+system.getControlDeviceForwardInput(),-1,1)local oR=r(X+a0+system.getControlDeviceYawInput(),-1,1)local oS=r(Y+W-system.getControlDeviceLeftRightInput(),-1,1)local oT=Z;bu=vec3(core.getWorldVertical())if bu==nil or bu:len()==0 then bu=(planet.center-bw):normalize()end;bo=vec3(core.getConstructWorldOrientationUp())bp=vec3(core.getConstructWorldOrientationForward())bq=vec3(core.getConstructWorldOrientationRight())bs=vec3(core.getWorldVelocity())br=vec3(core.getVelocity())bw=vec3(core.getConstructWorldPos())aw=core.getConstructMass()bt=vec3(bs):len()bv=-bu:dot(bs)bD=getRoll(bu,bp,bq)local oU=bD/180*math.pi;local oV=math.cos(oU)local oW=math.sin(oU)bC=oN(bu,bp,bq*oV+bo*oW)local oX=bs:normalize()local oY=d(bD)local oZ=utils.sign(bD)local o_=vec3(core.getWorldAngularVelocity())local p0=oQ*pitchSpeedFactor*bq+oR*rollSpeedFactor*bp+oS*yawSpeedFactor*bo;if b1==true and bu:len()>0.01 then local p1=d(b5-bD)if((ProgradeIsOn or Reentry or BrakeLanding or am or AltitudeHold or IntoOrbit)and p1>0 or as>0.0 and p1<autoRollRollThreshold and autoRollPreference)and oR==0 and d(bC)<85 then local p2=b5;local p3=autoRollFactor;if as==0 then p3=p3/4;b5=0;p2=0 end;if rollPID==nil then rollPID=pid.new(p3*0.01,0,p3*0.1)end;rollPID:inject(p2-bD)local p4=rollPID:get()p0=p0+p4*bp end end;local p5=1;local p6=0;local p7=1;local p8=system.getMouseWheel()if p8>0 then bW()elseif p8<0 then bW(true)else ax=true end;M=0;if ar and AtmoSpeedAssist and bB then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b8/3.6-bs:dot(bp))local p9=throttlePID:get()O=r(p9,-1,1)if O<L and as>0.005 then N=true;s:setThrottleCommand(axisCommandId.longitudinal,r(O,0.01,1))else N=false;s:setThrottleCommand(axisCommandId.longitudinal,L)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bs:len()-b8/3.6)local pa=r(brakePID:get(),0,1)if as>0 and bv<-80 or as>0.005 then M=pa end;if M>0 then if N and O==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else O=r(O,0.01,1)end;local pb=''local pc=vec3()local pd=oA(axisCommandId.vertical,ag*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pd,p6)local pe='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pe=pe..ExtraLongitudeTags end;local pf=s:getAxisCommandType(axisCommandId.longitudinal)local pg=s:composeAxisAccelerationFromThrottle(pe,axisCommandId.longitudinal)local ph=oM(axisCommandId.lateral,LeftAmount*1000)pb=pb..' , '.."lateral airfoil , lateral ground "pc=pc+ph;if pc:len()>constants.epsilon then a:setEngineForceCommand(pb,pc,p6,'','','',p7)end;a:setEngineForceCommand(pe,pg,p5)local pi='thrust analog vertical fueled 'local pj='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then pj=pj..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then pi=pi..ExtraVerticalTags end;if ag~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(pi,pd,p5)else a:setEngineForceCommand(pi,vec3(),p5)end;if LeftAmount~=0 then a:setEngineForceCommand(pj,ph,p5)else a:setEngineForceCommand(pj,vec3(),p5)end;if oT==0 then oT=M end;local pk=-oT*(brakeSpeedFactor*bs+brakeFlatFactor*oX)a:setEngineForceCommand('brake',pk)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,L)end;local mx=unit.getAxisCommandValue(0)if not bB then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bs:len()-mx/3.6)local pa=r(brakePID:get(),0,1)oT=r(oT+pa,0,1)end;local pk=-oT*(brakeSpeedFactor*bs+brakeFlatFactor*oX)a:setEngineForceCommand('brake',pk)local pb=''local pc=vec3()local pl=false;local pe='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pe=pe..ExtraLongitudeTags end;local pf=s:getAxisCommandType(axisCommandId.longitudinal)if pf==axisCommandType.byThrottle then local pg=s:composeAxisAccelerationFromThrottle(pe,axisCommandId.longitudinal)a:setEngineForceCommand(pe,pg,p5)elseif pf==axisCommandType.byTargetSpeed then local pg=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pb=pb..' , '..pe;pc=pc+pg;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then pl=true end end;local pj='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then pj=pj..ExtraLateralTags end;local pm=s:getAxisCommandType(axisCommandId.lateral)if pm==axisCommandType.byThrottle then local pn=s:composeAxisAccelerationFromThrottle(pj,axisCommandId.lateral)a:setEngineForceCommand(pj,pn,p5)elseif pm==axisCommandType.byTargetSpeed then local ph=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pb=pb..' , '..pj;pc=pc+ph end;local pi='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then pi=pi..ExtraVerticalTags end;local po=s:getAxisCommandType(axisCommandId.vertical)if po==axisCommandType.byThrottle then local pd=s:composeAxisAccelerationFromThrottle(pi,axisCommandId.vertical)if ag~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(pi,pd,p5,'airfoil','ground','',p7)else a:setEngineForceCommand(pi,vec3(),p5)a:setEngineForceCommand('airfoil vertical',pd,p5,'airfoil','','',p7)a:setEngineForceCommand('ground vertical',pd,p5,'ground','','',p7)end elseif po==axisCommandType.byTargetSpeed then if ag<0 then a:setEngineForceCommand('hover',vec3(),p5)end;local pp=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pb=pb..' , '..pi;pc=pc+pp end;if pc:len()>constants.epsilon then if Z~=0 or pl or d(oX:dot(bp))<0.5 then pb=pb..', brake'end;a:setEngineForceCommand(pb,pc,p6,'','','',p7)end end;local pq=torqueFactor*(p0-o_)local pr=vec3(core.getWorldAirFrictionAngularAcceleration())pq=pq-pr;a:setEngineTorqueCommand('torque',pq,p5,'airfoil','','',p7)a:setBoosterCommand('rocket_engine')if a8 and not VanillaRockets then local eF=br:len()local ps=0.15;if not bB then local pt=s:getTargetSpeed(axisCommandId.longitudinal)if eF*3.6>pt*(1-ps)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eF*3.6<pt*(1-ps)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local mn=unit.getThrottle()if AtmoSpeedAssist then mn=L*100 end;local mx=mn/100;if k==0 then mx=mx*MaxGameVelocity;if eF>=mx*(1-ps)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eF<mx*(1-ps)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local mI=e(b8)mx=mx*mI/3.6;if eF>=mx*(1-ps)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eF<mx*(1-ps)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local ge=coroutine.status(beginSetup)if ge=="suspended"then local co,gf=coroutine.resume(beginSetup)if gf then system.print("ERROR STARTUP: "..gf)end elseif ge=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not a_ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(pu)local function pv(bX)local E=1;local function pw(px,bX)local py={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local pz=px;for _,cS in ipairs(py)do if bX and pz>cS then px=cS elseif px<cS and not bX then px=cS;break end end;return px end;if bX then E=-1 end;if not ExternalAGG and bz then if a2 and bX then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+E*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+E*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a2 then bh=pw(bh,bX)else bh=bh+E*a4 end;if bh<planet.noAtmosphericDensityAltitude then bh=planet.noAtmosphericDensityAltitude end else if a2 and ar then HoldAltitude=pw(HoldAltitude,bX)else HoldAltitude=HoldAltitude+E*a4 end end else s:updateTargetGroundAltitudeFromActionStart(E*1.0)end end;local function pA(pB)if not ar then a3="Flight Assist in Atmo only"return end;local cY=type(pB)if bL==nil then if cY=="table"then if Autopilot or VectorToTarget then cD()end;c5("180On","BR")elseif pB==1 then c5("bnkLft","BR")else c5("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cA()if cY~="table"then pB=pB+1 end end;bL=pB else c5("180Off","BR")bL=nil end end;if pu=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cn(0)if vBooster or hover then if ar and ap==-1 then c5("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b1=true;GearExtended=false else if T then c5("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if ar then BrakeIsOn=true end end end;if T and not BrakeLanding and not(vBooster or hover)then c5("grOut","LG",1)a.control.extendLandingGears()end else if T then c5("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif pu=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif pu=="forward"then U=U-1 elseif pu=="backward"then if AltIsOn then pA(-bs*5000)else U=U+1 end elseif pu=="left"then if AltIsOn then pA(1)else X=X-1 end elseif pu=="right"then if AltIsOn then pA(3)else X=X+1 end elseif pu=="yawright"then Y=Y-1 elseif pu=="yawleft"then Y=Y+1 elseif pu=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif pu=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif pu=="up"then ag=ag+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif pu=="down"then ag=ag-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif pu=="groundaltitudeup"then pv()elseif pu=="groundaltitudedown"then pv(true)elseif pu=="option1"then toggleView=false;if AltIsOn and a2 then local pC=""for i=1,#passengers do pC=pC.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..B(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..pC)return end;aX.adjustAutopilotTargetIndex()elseif pu=="option2"then toggleView=false;if AltIsOn and a2 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a3="Deboarded All Passengers"return end;aX.adjustAutopilotTargetIndex(1)elseif pu=="option3"then local function pD()aF=not aF;if not aF then c5("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else c5("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a2 then local pC=""for i=1,#ships do pC=pC.."| ID: "..ships[i].." Mass: "..B(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..pC)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;pD()toggleView=false elseif pu=="option4"then toggleView=false;if AltIsOn and a2 then for i=1,#ships do core.forceUndock(ships[i])end;a3="Undocked all ships"return end;bL=nil;cD()elseif pu=="option5"then toggleView=false;function ToggleLockPitch()if LockPitch==nil then c5("lkPOn","LP")if not a2 then LockPitch=bC else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else c5("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif pu=="option6"then toggleView=false;if AltIsOn and a2 then if shield_1 then local pE=shield_1.getVentingCooldown()if pE>0 then a3="Cannot vent again for "..pE.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a3="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a3="Shields already at max hitpoints"end;return else a3="No shield found"return end end;cA()elseif pu=="option7"then toggleView=false;if AltIsOn and a2 then if shield_1 then shield_1.toggle()return else a3="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a3="Collision System Enabled"else a3="Collision System Secured"end elseif pu=="option8"then stablized=not stablized;if not stablized then a3="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()c5("gsOff","GS")else a3="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)c5("gsOn","GS")end;toggleView=false elseif pu=="option9"then if AltIsOn and a2 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)cn(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ay=gyro.getState()==1;if ay then c5("gyOn","GA")else c5("gyOff","GA")end end;toggleView=false elseif pu=="lshift"then bS=false;if AltIsOn then a2=true end;if x()==1 then a2=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a2=true;b0=false;a_=false end elseif pu=="brake"then if BrakeToggleStatus or AltIsOn then cF()elseif not BrakeIsOn then cF()else BrakeIsOn=true end elseif pu=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif pu=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a8 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a8=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a8=false end elseif pu=="stopengines"then local function pF()if F-G<1.5 then c5("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bL=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a1=false;Q=false;am=false;an=false;S=false;b1=autoRollPreference;VectorToTarget=false;TurnBurn=false;ay=false;LockPitch=nil;IntoOrbit=false end end;pF()G=F;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if L~=0 then s:resetCommand(axisCommandId.longitudinal)cn(0)else cn(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if ar then cq(AtmoSpeedLimit)else cq(MaxGameVelocity*3.6)end end end elseif pu=="speedup"then bW()elseif pu=="speeddown"then bW(true)elseif pu=="antigravity"and not ExternalAGG then if antigrav~=nil then cH()end end end;function script.onActionStop(pu)local function pG()if not ExternalAGG and bz then a7=a5 end;if AltitudeHold or VertTakeOff or IntoOrbit then a6=a4 end end;if pu=="forward"then U=0 elseif pu=="backward"then U=0 elseif pu=="left"then if bL then if bL==2 then bL=-2 else bL=-1 end end;X=0 elseif pu=="right"then if bL then if bL==4 then bL=-2 else bL=-1 end end;X=0 elseif pu=="yawright"then Y=0 elseif pu=="yawleft"then Y=0 elseif pu=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif pu=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif pu=="up"then ag=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pu=="down"then ag=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pu=="groundaltitudeup"then pG()toggleView=false elseif pu=="groundaltitudedown"then pG()toggleView=false elseif pu=="lshift"then if x()==1 then ah=0;ai=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then b0=false;a_=false end;a2=false elseif pu=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then cF()else BrakeIsOn=false end end elseif pu=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(pu)local function pH(bX)local E=1;if bX then E=-1 end;if not ExternalAGG and bz then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+E*a7;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a7=r(a7*1.05,a5,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+E*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bh=bh+E*a6;if bh<planet.noAtmosphericDensityAltitude then bh=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+E*a6 end;a6=r(a6*1.05,a4,50)else s:updateTargetGroundAltitudeFromActionLoop(E*1.0)end end;local function pI(bX)local E=1;if bX then E=-1 end;if not a2 then if AtmoSpeedAssist and not AltIsOn then L=r(L+E*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,E*speedChangeSmall)end end end;if pu=="groundaltitudeup"then if not a2 then pH()end elseif pu=="groundaltitudedown"then if not a2 then pH(true)end elseif pu=="speedup"then pI()elseif pu=="speeddown"then pI(true)end end;function script.onInputText(ck)local function pJ(pK,eJ,hR)local function pL(eJ)local C=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d5='::pos{'..C..','..C..','..C..','..C..','..C..'}'local di,dj,dq,dr,ds=o(eJ,d5)if di=="0"and dj=="0"then return vec3(A(dq),A(dr),A(ds))end;dr=math.rad(dr)dq=math.rad(dq)local planet=b[A(di)][A(dj)]local ea=math.cos(dq)local pM=vec3(ea*math.cos(dr),ea*math.sin(dr),math.sin(dq))return planet.center+(planet.radius+ds)*pM end;local position=pL(eJ)return aX.AddNewLocation(pK,position,hR)end;local i;local pN,pO=nil,nil;local pP="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(ck," ")pN=ck;if i~=nil then pN=string.sub(ck,0,i-1)pO=string.sub(ck,i+1)end;if pN=="/help"or pN=="/commands"then for ke in string.gmatch(pP,"([^\n]+)")do system.print(ke)end;return elseif pN=="/setname"then if pO==nil or pO==""then a3="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aX.UpdatePosition(pO)else a3="Select a saved target to rename first"end elseif shield_1 and pN=="/resist"then if pO==nil or shield_1.getResistancesCooldown()>0 then a3="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local C=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d5=C..', '..C..', '..C..', '..C;local pQ,pR,pS,pT=o(pO,d5)if pT==nil or pQ+pR+pS+pT>0.6 then a3="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(pQ,pR,pS,pT)==1 then a3="Shield Resistances set"else a3="Resistance setting failed."end elseif pN=="/addlocation"or string.find(ck,"::pos")~=nil then local hR=false;local pK="0-Temp"if pO==nil or pO==""then pO=pN;hR=true end;i=string.find(pO,"::")if not hR then pK=string.sub(pO,1,i-2)end;local eJ=string.sub(pO,i)pJ(pK,eJ,hR)elseif pN=="/agg"then if pO==nil or pO==""then a3="Usage: /agg targetheight"return end;pO=A(pO)if pO<1000 then pO=1000 end;AntigravTargetAltitude=pO;a3="AGG Target Height set to "..pO elseif pN=="/G"then if pO==nil or pO==""then a3="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if pO=="dump"then for cR,cS in pairs(cb())do if type(_G[cS])=="boolean"then if _G[cS]==true then system.print(cS.." true")else system.print(cS.." false")end elseif _G[cS]==nil then system.print(cS.." nil")else system.print(cS.." ".._G[cS])end end;return end;i=string.find(pO," ")local pU=string.sub(pO,0,i-1)local pV=string.sub(pO,i+1)for cR,cS in pairs(cb())do if cS==pU then a3="Variable "..pU.." changed to "..pV;local pW=type(_G[cS])if pW=="number"then pV=A(pV)if cS=="AtmoSpeedLimit"then b8=pV end elseif pW=="boolean"then if string.lower(pV)=="true"then pV=true else pV=false end end;_G[cS]=pV;return end end;a3="No such global variable: "..pU elseif pN=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aX.ClearCurrentPosition()else a3="Select a custom wp to delete first in IPH"end elseif pN=="/copydatabank"then if dbHud_2 then cN(true)else a3="Spare Databank required to copy databank"end elseif pN=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aY.showWayPoint(ad,AutopilotTargetCoords,true))a3="::pos waypoint shown in lua chat"else a3="No target selected in IPH"end end end;function script.onEnter(dj)if bQ[1]and not ar and not bI then unit.setTimer("contact",0.1)end end;function script.onLeave(dj)if bQ[1]and CollisionSystem then if#bM>650 then dj=tostring(dj)bM[dj]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
