name: ArchHud - Archaegeo v1.410 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.410;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local x=math.sqrt;local y=tonumber;local core=core;local function z(A,B)local C=10^(B or 0)return d(A*C+0.5)/C end;local D=o()local E=o()local F=16;local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8,a9=0;local aa,ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=j()>0;local ar=j()local as=core.getAltitude()local at=core.getElementIdList()local au=o()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..d(H+0.5)..","..d(J+0.5)..","..d(I+0.5)..[[)]]local az=[[rgb(]]..d(H*0.9+0.5)..","..d(J*0.9+0.5)..","..d(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=nil;local a_=false;local b0=false;local b1=autoRollPreference;local b2=LandingGearGroundHeight;local b3=false;local b4=o()local b5=0;local b6=0;local b7=0;local b8=AtmoSpeedLimit;local b9=0;local ba=nil;local bb=0;local bc=0;local bd=false;local be=false;local bf={VectorToTarget=false}local bg=false;local bh=0;local bi=nil;local bj=false;local bk=false;local bl=false;local bm=false;local bn=0;local bo=vec3(core.getConstructWorldOrientationUp())local bp=vec3(core.getConstructWorldOrientationForward())local bq=vec3(core.getConstructWorldOrientationRight())local br=vec3(core.getVelocity())local bs=vec3(core.getWorldVelocity())local bt=vec3(bs):len()local bu=vec3(core.getWorldVertical())local bv=-bu:dot(bs)local bw=vec3(core.getConstructWorldPos())local bx=0;local by=false;local bz=false;local bA=nil;local bB=true;local bC=0;local bD=0;local bE=false;local bF={}local bG=showHud;local bH={}local bI=false;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;function p(bP)system.print(D..": "..bP)end;local function bQ(bR)local bS,bT,bU=aS:getPlanetarySystem(0):castIntersections(bw,bR,function(bV)if bV.noAtmosphericDensityAltitude>0 then return bV.radius+bV.noAtmosphericDensityAltitude else return bV.radius+bV.surfaceMaxAltitude*1.5 end end)local bW=bT;if bU~=nil and bT~=nil then bW=math.min(bU,bT)end;if bW~=nil then return bS,bW else return nil,nil end end;local function bX(bY,bZ,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bY.."|"..bZ.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bY.."|"..bZ.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bY.."|"..bZ.."|"..soundVolume)end end;local function b_(c0,c1)for i=1,#c1 do c0[#c0+1]=c1[i]end;return c0 end;local function c2(c3)local c4={}local c5={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local c6={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c7={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local c8={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c3 then b_(c4,c5)b_(c4,c6)b_(c4,c7)b_(c4,c8)return c4 elseif c3=="boolean"then return c5 elseif c3=="handling"then return c6 elseif c3=="hud"then return c7 elseif c3=="physics"then return c8 end end;local function c9(ca,cb,cc,cd,ce)if cd==nil then cd=""end;if ce==nil then ce=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cd,ca,cb,ce,cc)end;local function cf(cg,ch)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not ch then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,cg)K=q(z(cg*100,0)/100,-1,1)end;local function ci(cg,ch)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ch then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,cg)bA=cg end;local function cj(ck,cl)if ck==0 then return c(cl)<1e-09 end;if cl==0 then return c(ck)<1e-09 end;return c(ck-cl)<math.max(c(ck),c(cl))*epsilon end;local function cm(aj,cn)local co=aj>100000;if cn==nil then cn=1 end;if co then return z(aj/1000/200,cn).."SU"elseif aj<1000 then return z(aj,cn).."M"else return z(aj/1000,cn).."KM"end end;local function cp()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b1=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ci(d(b8))end else bj=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cq()bj=false;bb=nil;bc=nil;bn=0;if ar==0 then if IntoOrbit then bX("orOff","AP")IntoOrbit=false;bd=false;bi=nil;b1=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bf.VectorToTarget=false;bf.AutopilotAlign=false;bg=false elseif bM then bX("orOn","AP")IntoOrbit=true;b1=true;if bi==nil then bi=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bd=false;bi=nil;b1=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bf.VectorToTarget=false;bf.AutopilotAlign=false;bg=false end end;local function cr()if D-b6<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bX("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bh=HoldAltitude;bg=true;if not IntoOrbit then cq()end;bd=true end end;b6=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b6=D end;if bM and ar==0 then bh=as;bg=true;bd=true;cq()if IntoOrbit then b6=D else b6=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b1=true;LockPitch=nil;bj=false;if ao~=-1 and bt<20 then bX("lfs","LS")AutoTakeoff=true;if b6>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and by then cp()end else bX("altOn","AH")AutoTakeoff=false;if b6>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cp()end end;if am then HoldAltitude=100000 end else bX("altOff","AH")if IntoOrbit then cq()end;if VertTakeOff then cp()end;b1=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b6=0 end end;local function cs()local function ct(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cr()end end;VectorStatus="Proceeding to Waypoint"end;if D-b7<1.5 and ar>0 then if not bm then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bX("orH","OH")end;b7=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b7=D end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aX.UpdateAutopilotTarget()aY.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bX("apSpc","AP")if ar~=0 then am=true;cr()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bX("vtt","AP")ct(SpaceTarget)end else bX("apOn","AP")if not(ac.name==planet.name and bM)then bj=false;Autopilot=true elseif not aq then if IntoOrbit then cq()end;bh=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=true;bf.AutopilotAlign=true;bf.VectorToTarget=true;bd=false;if not IntoOrbit then cq()end end end else bX("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cr()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bj=false;bd=false;cq()else bX("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bX("apP","AP")am=true;cr()end else bX("apOff","AP")am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;P=false;AutoTakeoff=false;AltitudeHold=false;HoldAltitude=as;TargetSet=false;Reentry=false;if IntoOrbit then cq()end end end;local function cu()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b1=autoRollPreference end;if BrakeIsOn then bX("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not bz then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cp()end;if IntoOrbit then cq()end;b1=autoRollPreference;al=false;an=false;af=0 else bX("bkOff","B",1)end end;local function cv()if Reentry then a2="Re-Entry cancelled"bX("reOff","RE")Reentry=false;b1=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b1=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b8;bX("par","RE")else Reentry=true;AltitudeHold=true;b1=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local cc=cm(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b8 .." Target Altitude: "..cc;bX("glide","RE")ci(d(b8))end;AutoTakeoff=false end;local function cw()if antigrav and not ExternalAGG then if bz then bX("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bX("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cx(cy)local cz=0;local cA=0;local cB=0;if cy<60 then cy=d(cy)elseif cy<3600 then cz=d(cy/60)cy=d(cy%60)elseif cy<86400 then cA=d(cy/3600)cz=d(cy%3600/60)else cB=d(cy/86400)cA=d(cy%86400/3600)end;if cB>0 then return cB.."d "..cA.."h "elseif cA>0 then return cA.."h "..cz.."m "elseif cz>0 then return cz.."m "..cy.."s"elseif cy>0 then return cy.."s"else return"0s"end end;local function cC(cD)local function cE(cF)for cG,cH in pairs(cF)do dbHud_1.setStringValue(cH,g(_G[cH]))if cD and dbHud_2 then dbHud_2.setStringValue(cH,g(_G[cH]))end end end;if dbHud_1 then cE(b)cE(c2())system.print("Saved Variables to Datacore")if cD and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cI()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function cJ()local function cK(cL)return type(cL)=='number'end;local function cM(cL)return type(y(cL))=='number'end;local function cN(cO)return type(cO)=='table'end;local function cP(cQ)return type(cQ)=='string'end;local function cR(cH)return cN(cH)and cK(cH.x and cH.y and cH.z)end;local function cS(cT)return cN(cT)and cK(cT.latitude and cT.longitude and cT.altitude and cT.bodyId and cT.systemId)end;local cU=math.pi/180;local cV=180/math.pi;local epsilon=1e-10;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cW='::pos{'..A..','..A..','..A..','..A..','..A..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cX(cL)local cY=string.gsub(string.reverse(e('%.4f',cL)),'^0*%.?','')return cY==''and'0'or string.reverse(cY)end;local function cZ(c_)if cR(c_)then return e('{x=%.3f,y=%.3f,z=%.3f}',c_.x,c_.y,c_.z)end;if cN(c_)and not getmetatable(c_)then local d0={}local d1=next(c_)if type(d1)=='nil'or d1==1 then d0=c_ else for cG,cH in pairs(c_)do local cg=cZ(cH)if type(cG)=='number'then table.insert(d0,e('[%s]=%s',cG,cg))else table.insert(d0,e('%s=%s',cG,cg))end end end;return e('{%s}',table.concat(d0,','))end;if cP(c_)then return e("'%s'",c_:gsub("'",[[\']]))end;return tostring(c_)end;local d2={}d2.__index=d2;d2.__tostring=function(c_,d3)local d4={}for cG in pairs(c_)do table.insert(d4,cG)end;table.sort(d4)local d0={}for _,cG in ipairs(d4)do local cg=cZ(c_[cG])if type(cG)=='number'then table.insert(d0,e('[%s]=%s',cG,cg))else table.insert(d0,e('%s=%s',cG,cg))end end;if d3 then return e('%s%s',d3,table.concat(d0,',\n'..d3))end;return e('{%s}',table.concat(d0,','))end;d2.__eq=function(d5,d6)return d5.planetarySystemId==d6.planetarySystemId and d5.bodyId==d6.bodyId and cj(d5.radius,d6.radius)and cj(d5.center.x,d6.center.x)and cj(d5.center.y,d6.center.y)and cj(d5.center.z,d6.center.z)and cj(d5.GM,d6.GM)end;local function d7(d8,d9,da,db,dc)assert(cM(d8),'Argument 1 (planetarySystemId) must be a number:'..type(d8))assert(cM(d9),'Argument 2 (bodyId) must be a number:'..type(d9))assert(cM(da),'Argument 3 (radius) must be a number:'..type(da))assert(cN(db),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(db))assert(cM(dc),'Argument 5 (GM) must be a number:'..type(dc))return setmetatable({planetarySystemId=y(d8),bodyId=y(d9),radius=y(da),center=vec3(db),GM=y(dc)},d2)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return e('::pos{%d,%d,%s,%s,%s}',p.systemId,p.bodyId,cX(p.latitude*cV),cX(p.longitude*cV),cX(p.altitude))end;MapPosition.__eq=function(d5,d6)return d5.bodyId==d6.bodyId and d5.systemId==d6.systemId and cj(d5.latitude,d6.latitude)and cj(d5.altitude,d6.altitude)and(cj(d5.longitude,d6.longitude)or cj(d5.latitude,math.pi/2)or cj(d5.latitude,-math.pi/2))end;local function dd(de,d9,df,dg,dh)local d8=de;if cP(de)and not dg and not dh and not d9 and not df then d8,d9,df,dg,dh=n(de,cW)assert(d8,'Argument 1 (position string) is malformed.')else assert(cM(d8),'Argument 1 (systemId) must be a number:'..type(d8))assert(cM(d9),'Argument 2 (bodyId) must be a number:'..type(d9))assert(cM(df),'Argument 3 (latitude) must be in degrees:'..type(df))assert(cM(dg),'Argument 4 (longitude) must be in degrees:'..type(dg))assert(cM(dh),'Argument 5 (altitude) must be in meters:'..type(dh))end;d8=y(d8)d9=y(d9)df=y(df)dg=y(dg)dh=y(dh)if d9==0 then return setmetatable({latitude=df,longitude=dg,altitude=dh,bodyId=d9,systemId=d8},MapPosition)end;return setmetatable({latitude=cU*q(df,-90,90),longitude=cU*(dg%360),altitude=dh,bodyId=d9,systemId=d8},MapPosition)end;local di={}di.__index=di;di.__tostring=function(c_,d3)local dj=d3 and d3 ..'  'local dk={}local d4={}for cG in pairs(c_)do table.insert(d4,cG)end;table.sort(d4)for _,dl in ipairs(d4)do bdy=c_[dl]local dm=d2.__tostring(bdy,dj)if d3 then table.insert(dk,e('[%s]={\n%s\n%s}',dl,dm,d3))else table.insert(dk,e('  [%s]=%s',dl,dm))end end;if d3 then return e('\n%s%s%s',d3,table.concat(dk,',\n'..d3),d3)end;return e('{\n%s\n}',table.concat(dk,',\n'))end;local function dn(dp)local aN={}local pid;for _,cH in pairs(dp)do local dq=cH.planetarySystemId;if type(dq)~='number'then error('Invalid planetary system ID: '..tostring(dq))elseif pid and dq~=pid then error('Mistringmatch planetary system IDs: '..dq..' and '..pid)end;local dr=cH.bodyId;if type(dr)~='number'then error('Invalid body ID: '..tostring(dr))elseif aN[dr]then error('Duplicate body ID: '..tostring(dr))end;setmetatable(cH.center,getmetatable(vec3.unit_x))aN[dr]=setmetatable(cH,d2)pid=dq end;return setmetatable(aN,di)end;aR={}local function ds(dp)return setmetatable({galaxyAtlas=dp or{}},aR)end;aR.__index=function(cO,i)if type(i)=='number'then local system=cO.galaxyAtlas[i]return dn(system)end;return rawget(aR,i)end;aR.__pairs=function(c_)return function(cO,cG)local dt,nv=next(cO,cG)return dt,nv and dn(nv)end,c_.galaxyAtlas,nil end;aR.__tostring=function(c_)local du={}for _,dv in pairs(c_ or{})do local dw=dv:getPlanetarySystemId()local dx=di.__tostring(dv,'    ')table.insert(du,e('  [%s]={%s\n  }',dw,dx))end;return e('{\n%s\n}\n',table.concat(du,',\n'))end;aR.BodyParameters=d7;aR.MapPosition=dd;aR.PlanetarySystem=dn;function aR.createBodyParameters(dy,d9,dz,dA,dB,dC,dD)assert(cM(dy),'Argument 1 (planetarySystemId) must be a number:'..type(dy))assert(cM(d9),'Argument 2 (bodyId) must be a number:'..type(d9))assert(cM(dz),'Argument 3 (surfaceArea) must be a number:'..type(dz))assert(cN(dA),'Argument 4 (aPosition) must be an array or vec3:'..type(dA))assert(cN(dB),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dB))assert(cM(dC),'Argument 6 (altitude) must be in meters:'..type(dC))assert(cM(dD),'Argument 7 (gravityAtPosition) must be number:'..type(dD))local da=x(dz/4/math.pi)local aj=da+dC;local dE=vec3(dA)+aj*vec3(dB)local dc=dD*aj*aj;return d7(dy,d9,da,dE,dc)end;aR.isMapPosition=cS;function aR:getPlanetarySystem(de)if i==nil then i=0 end;if nv==nil then nv=0 end;local dy=de;if cS(de)then dy=de.systemId end;if type(dy)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=di then system=dn(system)end;return system end end end;function di:sizeCalculator(bV)return 1.05*bV.radius end;function di:castIntersections(dF,dG,dH,dI,dJ,dK)local dL={}local dM=dJ or self;for _,bV in pairs(dM)do table.insert(dL,bV)end;if not dK then table.sort(dL,function(dN,dO)return(dN.center-dF):len()<(dO.center-dF):len()end)end;local dP=dG:normalize()for _,bV in ipairs(dL)do local dQ=bV.center-dF;local da=self:sizeCalculator(bV)local dR=dQ:dot(dP)local dS=dR^2-(dQ:len2()-da^2)if dS>=0 then local dT=x(dS)local bT=dR+dT;local bU=dR-dT;if bU>0 then return bV,bT,bU elseif bT>0 then return bV,bT,nil end end end;return nil,nil,nil end;function di:closestBody(dU)assert(type(dU)=='table','Invalid coordinates.')local dV,bV;local dW=vec3(dU)for _,dX in pairs(self)do local dY=(dX.center-dW):len2()if(not bV or dY<dV)and dX.name~="Space"then bV=dX;dV=dY end end;return bV end;function di:convertToBodyIdAndWorldCoordinates(de)local dZ=de;if cP(de)then dZ=dd(de)end;if dZ.bodyId==0 then return 0,vec3(dZ.latitude,dZ.longitude,dZ.altitude)end;local dX=self:getBodyParameters(dZ)if dX then return dZ.bodyId,dX:convertToWorldCoordinates(dZ)end end;function di:getBodyParameters(de)local d9=de;if cS(de)then d9=de.bodyId end;assert(cM(d9),'Argument 1 (bodyId) must be a number:'..type(d9))return self[d9]end;function di:getPlanetarySystemId()local _,cH=next(self)return cH and cH.planetarySystemId end;function d2:convertToMapPosition(db)assert(cN(db),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(db))local d_=vec3(db)if self.bodyId==0 then return setmetatable({latitude=d_.x,longitude=d_.y,altitude=d_.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local e0=d_-self.center;local aj=e0:len()local dh=aj-self.radius;local df=0;local dg=0;if not cj(aj,0)then local e1=m(e0.y,e0.x)dg=e1>=0 and e1 or 2*math.pi+e1;df=math.pi/2-math.acos(e0.z/aj)end;return setmetatable({latitude=df,longitude=dg,altitude=dh,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function d2:convertToWorldCoordinates(de)local dZ=cP(de)and dd(de)or de;if dZ.bodyId==0 then return vec3(dZ.latitude,dZ.longitude,dZ.altitude)end;assert(cS(dZ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dZ.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dZ.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local e2=math.cos(dZ.latitude)return self.center+(self.radius+dZ.altitude)*vec3(e2*math.cos(dZ.longitude),e2*math.sin(dZ.longitude),math.sin(dZ.latitude))end;function d2:getAltitude(db)return(vec3(db)-self.center):len()-self.radius end;function d2:getDistance(db)return(vec3(db)-self.center):len()end;function d2:getGravity(db)local e3=self.center-vec3(db)local e4=e3:len2()return self.GM/e4*e3/x(e4)end;return setmetatable(aR,{__call=function(_,...)return ds(...)end})end;local function e5()local aT={}local e6=30000000/3600;local e7=e6*e6;local e8=100;function aT.computeAccelerationTime(e9,ea,eb)local ec=e6*math.asin(e9/e6)return(e6*math.asin(eb/e6)-ec)/ea end;function aT.computeDistanceAndTime(e9,eb,ed,ee,ef,eg)ef=ef or 0;eg=eg or 0;local eh=e9<=eb;local ei=ee*(eh and 1 or-1)/ed;local ej=-eg/ed;local ek=ei+ej;if eh and ek<=0 or not eh and ek>=0 then return-1,-1 end;local el,em=0,0;if ei~=0 and ef>0 then local ec=math.asin(e9/e6)local en=math.pi*(ei/2+ej)local eo=ei*ef;local ep=e6*math.pi;local cH=function(cO)local eq=(en*cO-eo*math.sin(math.pi*cO/2/ef)+ep*ec)/ep;local er=math.tan(eq)return e6*er/x(er*er+1)end;local es=eh and function(cQ)return cQ>=eb end or function(cQ)return cQ<=eb end;em=2*ef;if es(cH(em))then local et=0;while c(em-et)>0.5 do local cO=(em+et)/2;if es(cH(cO))then em=cO else et=cO end end end;local eu=e9;local ev=em/e8;for ew=1,e8 do local ex=cH(ew*ev)el=el+(ex+eu)*ev/2;eu=ex end;if em<2*ef then return el,em end;e9=eu end;local ec=e6*math.asin(e9/e6)local D=(e6*math.asin(eb/e6)-ec)/ek;local ey=e7*math.cos(ec/e6)/ek;local aj=ey-e7*math.cos((ek*D+ec)/e6)/ek;return aj+el,D+em end;function aT.computeTravelTime(e9,ea,aj)if aj==0 then return 0 end;if ea>0 then local ec=e6*math.asin(e9/e6)local ey=e7*math.cos(ec/e6)/ea;return(e6*math.acos(ea*(ey-aj)/e7)-ec)/ea end;if e9==0 then return-1 end;assert(e9>0,'Acceleration and initial speed are both zero.')return aj/e9 end;return aT end;local function ez()local vec3=require('cpml.vec3')local cJ=cJ()local function cP(cQ)return type(cQ)=='string'end;local function cN(cO)return type(cO)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dh)assert(self.body)local aj=dh+self.body.radius;if not cj(aj,0)then local orbit=x(self.body.GM/aj)return x(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(de,eA)assert(self.body)assert(cN(de)or cP(de))assert(cN(eA))local eB=(cP(de)or cJ.isMapPosition(de))and self.body:convertToWorldCoordinates(de)or vec3(de)local cH=vec3(eA)local eC=eB-self.body.center;local eD=cH:len2()local eE=eC:len()local eF=self.body.GM;local eG=((eD-eF/eE)*eC-eC:dot(cH)*cH)/eF;local ck=eF/(2*eF/eE-eD)local eH=eG:len()local dP=eG:normalize()local eI=ck*(1-eH)local eJ=ck*(1+eH)local eK=eI*dP+self.body.center;local eL=eH<=1 and-eJ*dP+self.body.center or nil;local eM=x(ck*eF*(1-eH*eH))local eN=eL and 2*math.pi*x(ck^3/eF)local eO=math.acos(eG:dot(eC)/(eH*eE))if eC:dot(cH)<0 then eO=-(eO-2*math.pi)end;local eP=math.acos((math.cos(eO)+eH)/(1+eH*math.cos(eO)))local eQ=eP;if eQ<0 then eQ=eQ+2*math.pi end;local eR=eQ-eH*math.sin(eQ)local eS=0;local eT=0;local eU=0;if eN~=nil then eS=eR/(2*math.pi/eN)eT=eN-eS;eU=eT+eN/2;if eO-math.pi>0 then eT=eS;eU=eT+eN/2 end;if eU>eN then eU=eU-eN end end;return{periapsis={position=eK,speed=eM/eI,circularOrbitSpeed=x(eF/eI),altitude=eI-self.body.radius},apoapsis=eL and{position=eL,speed=eM/eJ,circularOrbitSpeed=x(eF/eJ),altitude=eJ-self.body.radius},currentVelocity=cH,currentPosition=eB,eccentricity=eH,period=eN,eccentricAnomaly=eP,meanAnomaly=eR,timeToPeriapsis=eT,timeToApoapsis=eU}end;local function eV(eW)local dX=cJ.BodyParameters(eW.planetarySystemId,eW.bodyId,eW.radius,eW.center,eW.GM)return setmetatable({body=dX},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eV(...)end})end;local function eX()local eY={}local eZ={}local e_={XS=13,S=27,M=55,L=110,XL=221}local f0={}local f1;local f2;local f3;local f4;local f5;local function f6()local function f7(f8,f9,fa,fb,fc,fd,fe,ff)f9,fb,fd,ff=vec3(f9),vec3(fb),vec3(fd),vec3(ff)local fg,fh,fi=f8*f8,fa*fa,fc*fc;local eD=fb-f9;local fj=eD:normalize()local fk=eD:len()local fl=fd-f9;local fm=(fl-fl:project_on(fj)):normalize()local fn,fo=fl:dot(fj),fl:dot(fm)local fp=fn*fn+fo*fo;local fq=fj:cross(fm)local ca=(fg-fh+fk*fk)/(2*fk)local cb=(fg-fi+fp-2*fn*ca)/(2*fo)local cT=fg-ca^2-cb^2;local fr=x(cT)local fs=f9+fj*ca+fm*cb+fq*fr;local ft=f9+fj*ca+fm*cb-fq*fr;if c((ff-fs):len()-fe)<c((ff-ft):len()-fe)then return fs else return ft end end;local function fu()local function fv()local fw=core.getConstructWorldOrientationRight()local eD=core.getConstructWorldOrientationForward()local fl=core.getConstructWorldOrientationUp()local fx=library.systemResolution3(fw,eD,fl,{1,0,0})local fy=library.systemResolution3(fw,eD,fl,{0,1,0})local fz=library.systemResolution3(fw,eD,fl,{0,0,1})return function(fA)return library.systemResolution3(fx,fy,fz,fA)end end;local fB=fv()local fC=core.getConstructWorldPos()local eB=core.getElementPositionById(1)local fD={eB[1]-F,eB[2]-F,eB[3]-F}local fE=fB(fD)local fF={fC[1]-fE[1],fC[2]-fE[2],fC[3]-fE[3]}return fF end;local function fG(fH,eE,fI)local fJ=fH.pts;local fK=#fJ;local fL=fH.ref;if fK>3 then local fM,fN,fO,fP=fJ[fK],fJ[fK-1],fJ[fK-2],fJ[fK-3]fH.ref=fI;local eB=f7(fM[1],fM[2],fN[1],fN[2],fO[1],fO[2],fP[1],fP[2])local ca,cb,fr=eB.x,eB.y,eB.z;if ca==ca and cb==cb and fr==fr then ca=ca+fL[1]cb=cb+fL[2]fr=fr+fL[3]local fQ=vec3(ca,cb,fr)if not fH.lastPos then fH.center=fQ elseif(fH.lastPos-fQ):len()<2 then fH.center=fQ;fH.skipCalc=true end;fH.lastPos=fQ end;fH.pts={}else local fR={fI[1]-fL[1],fI[2]-fL[2],fI[3]-fL[3]}fJ[fK+1]={eE,fR}end end;if radar_1 then f1=#radar_1.getEntries()local fS=radar_1.getData()local fT=fS:gmatch('{"constructId[^}]*}[^}]*}')if f1>0 then local fI=fu()local fU,fV=0,0;f5,f4=0,0;for cH in fT do local dq,aj,fW=cH:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fX=e_[fW]aj=y(aj)if radar_1.hasMatchingTransponder(dq)==1 then table.insert(eZ,dq)end;local fY=radar_1.getConstructType(dq)if CollisionSystem then if fX>27 or fY=="static"or fY=="space"then f5=f5+1;local fZ=radar_1.getConstructName(dq)local fH=bL[dq]if fH==nil then fX=fX+G;bL[dq]={pts={},ref=fI,name=fZ,i=0,radius=fX,skipCalc=false}fH=bL[dq]end;if not fH.skipCalc then fG(fH,aj,fI)fV=fV+1 end;if fH.center then table.insert(f0,fH)end end;fU=fU+1;if bM and fU>700 or fV>70 or(not bM and fU>300 or fV>30)then coroutine.yield()fU,fV=0,0 end end end;f4=#f0;if f4>0 and bt>20 then local bV,f_,g0,g1;local g2=0;local g3=aS:getPlanetarySystem(0)g1=bs:normalize()while g2<f4 do coroutine.yield()local g4={table.unpack(f0,g2,math.min(g2+75,f4))}bV,f_,g0=g3:castIntersections(bw,g1,nil,nil,g4,true)if bV and g0 then bO={bV,f_,g0}break end;g2=g2+75 end;if not bV then bO=nil end else bO=nil end;f0={}f2=fS:find('identifiedConstructs":%[%]')else f3=fS:find('worksInEnvironment":false')end end end;function eY.UpdateRadar()local g5=coroutine.status(UpdateRadarCoroutine)if g5=="suspended"then local cg,g6=coroutine.resume(UpdateRadarCoroutine)if g6 then system.print("ERROR UPDATE RADAR: "..g6)end elseif g5=="dead"then UpdateRadarCoroutine=coroutine.create(f6)local cg,g6=coroutine.resume(UpdateRadarCoroutine)end end;function eY.GetRadarHud()local g7=eZ;eZ={}return f2,f3,f1,f4,f5,g7 end;UpdateRadarCoroutine=coroutine.create(f6)return eY end;local function g8()local g9=0;local ga=9.80665;local gb=vec3({13771471,7435803,-128971})local gc=18000000;local gd=500000;local ge,gf=math.huge;local gg;local function gh(gi)ge=vec3(gi):dist(gb)if ge<gc then return true,c(ge-gc)end;gf=vec3(gi):dist(vec3(planet.center))if gf<gd then gg=true else gg=false end;if c(gf-gd)<c(ge-gc)then return gg,c(gf-gd)else return gg,c(ge-gc)end end;local function gj(cH)if aG==1920 then return cH else return z(aG*cH/1920,0)end end;local function gk(cH)if aH==1080 then return cH else return z(aH*cH/1080,0)end end;local function gl()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function gm()local gn="TRAVEL"if not bB then gn="CRUISE"end;if Autopilot then gn="AUTOPILOT"end;return gn end;local go=""local gp=""local gq=""local gr=1;local gs=2;local gt=3;local gu=4;local gv=5;local gw=6;local gx=""local gy=0;local gz=d(1/apTickRate)*2*hudTickRate;local gA={}local gB={}local gC={}local gD={}local gE={}local gF={}local function gG(ca,gH,gI,gJ,gK,gL)local gM=fuelY;local gN=fuelY+5;if not BarFuelDisplay then gN=gN+5 end;if l()==1 and not RemoteHud then gM=gM-50;gN=gN-50 end;if gI=="ATMO"then gx="atmofueltank"elseif gI=="SPACE"then gx="spacefueltank"else gx="rocketfueltank"end;gy=_G[gx.."_size"]if#gJ>0 then for i=1,#gJ do local fZ=string.sub(gJ[i][gs],1,12)local gO=0;for gP=1,gy do if gJ[i][gs]==f(unit[gx.."_"..gP].getData()).name then gO=gP;break end end;local gQ=o()if gK[i]==nil or gL[i]==nil or gQ-gJ[i][gw]>gz then local gR;local gS=0;if gO~=0 then gL[i]=f(unit[gx.."_"..gO].getData()).percentage;gK[i]=f(unit[gx.."_"..gO].getData()).timeLeft;if gK[i]=="n/a"then gK[i]=0 end else gS=k(gJ[i][gr])-gJ[i][gu]gL[i]=d(0.5+gS*100/gJ[i][gt])gR=gJ[i][gv]if gR<=gS then gK[i]=0 else gK[i]=d(0.5+gS/((gR-gS)/(gQ-gJ[i][gw])))end;gJ[i][gv]=gS;gJ[i][gw]=gQ end end;if fZ==gH then fZ=e("%s %d",gI,i)end;if gO==0 then fZ=fZ.." *"end;local gT;if gK[i]==0 then gT=""else gT=cx(gK[i])end;if gL[i]~=nil then local gU=d(gL[i]*2.55)local gV=e("rgb(%d,%d,%d)",255-gU,gU,0)local cd=""if gT~=""and gK[i]<120 or gL[i]<5 then cd="red "end;if BarFuelDisplay then gp=gp..e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],ca,gN,gV,gL[i],ca,gN,ca+2,gN+10,gL[i],gT)gp=gp..c9(ca,gM,fZ,cd.."txtstart pdim txtfuel")gM=gM-30;gN=gN-30 else gp=gp..c9(ca,gM,fZ,cd.."pdim txtfuel")gp=gp..c9(ca,gN,e("%d%% %s",gL[i],gT),"pdim txtfuel","fill:"..gV)gM=gM+30;gN=gN+30 end end end end end;local function gW(gX,dh)if dh<200000 and not aq or dh and aq then local gY=0;if c(bv)>1 then gY=45*math.log(c(bv),10)if bv<0 then gY=-gY end end;gX[#gX+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bv),d(gY))end;return gX end;local function gZ(g_)local h0=-bu;g_=g_-g_:project_on(h0)local h1=vec3(0,0,1)h1=h1-h1:project_on(h0)local h2=h1:cross(h0)local gY=h1:angle_between(g_)*constants.rad2deg;if g_:dot(h2)<0 then gY=360-gY end;return gY end;local function h3(gX,centerX,centerY,h4,h5,bM)local h6=circleRad;local h7=20;local h8=d(h4)if bM then for i=-45,45,5 do local h9=i;gX[#gX+1]=e([[<g transform="rotate(%f,%d,%d)">]],h9,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gX[#gX+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h6+h7-len,centerX,centerY+h6+h7)end;gX[#gX+1]=c9(centerX,centerY+h6+h7-35,h5,"pdim txt txtmid")gX[#gX+1]=c9(centerX,centerY+h6+h7-25,h8 .." deg","pdim txt txtmid")gX[#gX+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h4,centerX,centerY)gX[#gX+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h6+h7-20,centerX+5,centerY+h6+h7-20,centerX,centerY+h6+h7-15)gX[#gX+1]="</g>"end;local ha=h8;if bM then ha=gZ(bp)end;local hb=20;local hc=d(ha)local hd=0;local he=centerY+h6+h7+20;local hf=centerX;if h5~="YAW"then he=gk(130)hf=gj(960)end;local hg=[[<path class="txttick line" d="]]local hh=d(hc-(hb+10)-hc%5+0.5)for i=hh+60,hh,-5 do local ca=hf-(-i*5+ha*5)if i%10==0 then hd=10;local A=i;if A==360 then A=0 elseif A>360 then A=A-360 elseif A<0 then A=A+360 end;gX[#gX+1]=c9(ca+5,he-12,A)elseif i%5==0 then hd=5 end;if hd==10 then hg=e([[%s M %f %f v %d]],hg,ca,he-5,hd)else hg=e([[%s M %f %f v %d]],hg,ca,he-2.5,hd)end end;gX[#gX+1]=hg..[["/>]]gX[#gX+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],hf-5,he+10,hf+5,he+10,hf,he+5)if bM then h5="HDG"end;gX[#gX+1]=c9(hf,he+25,hc.."deg","pdim txt txtmid","")gX[#gX+1]=c9(hf,he+35,h5,"pdim txt txtmid","")end;local function hi(gX,hj,h4,centerX,centerY,bM,hk,ex)local h6=circleRad;local hl=d(h6*3/5)if h6>0 then local hm=d(hj)local len=0;local hg=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h4,centerX,centerY)if not aq then hg=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gX[#gX+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h6-1,centerX,centerY)gX[#gX+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(hm-30-hm%5+0.5),d(hm+30+hm%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cb=centerY+-i*5+hj*5;if len==30 then hg=e([[%s M %d %f h %d]],hg,centerX-hl-len,cb,len)if aq then gX[#gX+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h4,centerX,centerY,centerX-hl+10,cb,i)gX[#gX+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h4,centerX,centerY,centerX+hl-10,cb,i)if i==0 or i==180 or i==-180 then gX[#gX+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h4,centerX,centerY,centerX-hl+20,cb,hl*2-40)end else gX[#gX+1]=c9(centerX-hl+10,cb,i,"pdim txt txtmid")gX[#gX+1]=c9(centerX+hl-10,cb,i,"pdim txt txtmid")end;hg=e([[%s M %d %f h %d]],hg,centerX+hl,cb,len)else hg=e([[%s M %d %f h %d]],hg,centerX-hl-len,cb,len)hg=e([[%s M %d %f h %d]],hg,centerX+hl,cb,len)end end;gX[#gX+1]=hg..[["/>]]local hn="PITCH"if not bM then hn="REL PITCH"end;if hj>90 and not aq then hj=90-(hj-90)elseif hj<-90 and not aq then hj=-90-(hj+90)end;if h6>200 then if aq then if ex>Q then gX[#gX+1]=c9(centerX,centerY-15,"Yaw","pdim txt txtmid")gX[#gX+1]=c9(centerX,centerY+20,hk,"pdim txt txtmid")end;gX[#gX+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h4,centerX,centerY)else gX[#gX+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gX[#gX+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hl+25,centerY-5,centerX-hl+20,centerY,centerX-hl+25,centerY+5,centerX-hl+50,centerY+4,hm)gX[#gX+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hl-25,centerY-5,centerX+hl-20,centerY,centerX+hl-25,centerY+5,centerX+hl-30,centerY+4,hm)gX[#gX+1]="</g>"end;local ho=d(h6/3)gX[#gX+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-ho,centerY,h6-ho)if not aq and bM then gX[#gX+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h4,centerX,centerY,centerX-hl+10,centerY,hl*2-20)end;gX[#gX+1]="</g>"if h6<200 then if aq and ex>Q then gX[#gX+1]=c9(centerX,centerY-h6,hn,"pdim txt txtmid")gX[#gX+1]=c9(centerX,centerY-h6+10,hm,"pdim txt txtmid")gX[#gX+1]=c9(centerX,centerY-15,"Yaw","pdim txt txtmid")gX[#gX+1]=c9(centerX,centerY+20,hk,"pdim txt txtmid")else gX[#gX+1]=c9(centerX,centerY-h6,hn,"pdim txt txtmid")gX[#gX+1]=c9(centerX,centerY-h6+15,hm,"pdim txt txtmid")end end end end;local function hp(gX,dh,bM)local hq=altMeterX;local hr=altMeterY;local hs=78;local ht=19;local hu=ao;if ao~=-1 then gX[#gX+1]=c9(hq+hs,hr+ht+20,e("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dh<200000 and not aq or dh and aq)then table.insert(gX,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hq-1,hr-4,hs+2,ht+6,hq+1,hr-1,hs-4,ht))local fK=0;local hv=1;local hw=0;local hx=dh<0;local hy=dh<planet.surfaceMaxAltitude;local hz=9;if hx then hz=0 end;local dh=c(dh)while fK<6 do local hA=11;local hB=16;local hC=9;local hD=14;local cd="altsm"if fK>2 then hB=hB+3;hA=hA+2;hD=hD+2;hC=hC-6;cd="altbig"end;if hx then cd=cd.." red"elseif hy then cd=cd.." orange"end;local hE=dh/hv%10;local hF=d(hE)local hG=d((hF+1)%10)local hH=hw;if fK==0 then hH=hE-hF;if hx then hH=1-hH end end;if hx and(fK==0 or hw~=0)then local hI=hG;hG=hF;hF=hI end;local hJ=hB*(hH-1)local hK=hJ+hB;local ca=hq+hC+(6-fK)*hA;local cb=hr+hD;gX[#gX+1]=c9(ca,cb+hJ,hG,cd)gX[#gX+1]=c9(ca,cb+hK,hF,cd)fK=fK+1;hv=hv*10;if hF==hz then hw=hH else hw=0 end end;table.insert(gX,[[</g></g>]])end end;local function hL(eA)local hM=-math.deg(m(eA.y,eA.z))+180;hM=hM-90;if hM<0 then hM=360+hM end;if hM>180 then hM=-180+hM-180 end;return-hM end;local function hN(eA)local ha=math.deg(m(eA.y,eA.x))-90;if ha<-180 then ha=360+ha end;return ha end;local function hO(gX,eA,ex,centerX,centerY)if ex>5 and not aq or ex>Q then local h6=circleRad;local hP=20;local hQ=20;local hR=hL(eA)local hS=hN(eA)local hT=14;local hU=hT/2;local hV=-hS/hQ*h6;local hW=hR/hP*h6;local ca=centerX+hV;local cb=centerY+hW;local aj=x(hV^2+hW^2)local hX=[[<circle
                            cx="]]..ca..[["
                            cy="]]..cb..[["
                            r="]]..hU/hT..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..ca..[["
                            cy="]]..cb..[["
                            r="]]..hU..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..ca-hT..[[,]]..cb..[[ h ]]..hU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ca+hU..[[,]]..cb..[[ h ]]..hU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ca..[[,]]..cb-hT..[[ v ]]..hU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<h6 then gX[#gX+1]=hX else local gY=m(hW,hV)local hY=4;local hZ=centerX+h6*math.cos(gY)local h_=centerY+h6*math.sin(gY)gX[#gX+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gY*180/math.pi,hZ,h_,hZ-hY,h_-hY/2,hY*2,hY,hZ+hY,h_-hY,hY,hY,-hY,hY)end;if not aq then local i0=vec3(eA)hR=hL(-i0)hS=hN(-i0)hV=-hS/hQ*h6;hW=hR/hP*h6;ca=centerX+hV;cb=centerY+hW;aj=x(hV^2+hW^2)if aj<h6 then local i1=[[<circle
                                    cx="]]..ca..[["
                                    cy="]]..cb..[["
                                    r="]]..hU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ca..[[,]]..cb-hT..[[ v ]]..hU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..ca..[[,]]..cb..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..ca..[[,]]..cb..[[)" />
                                <path
                                    d="M ]]..ca-hU..[[,]]..cb..[[ h ]]..hT..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..ca..[[,]]..cb..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..ca..[[,]]..cb..[[)"/>]]gX[#gX+1]=i1 end end end end;local function i2(gX,gn,i3,i4)i3=d(i3+0.5)local gM=throtPosY+10;local gN=throtPosY+20;if l()==1 and not RemoteHud then gM=55;gN=65 end;local i5="CRUISE"local unit="km/h"local cg=i4;if gn=="TRAVEL"or gn=="AUTOPILOT"then i5="THROT"unit="%"cg=i3;local i6="dim"if i3<0 then i6="red"end;gX[#gX+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i6,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(i3),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gX[#gX+1]=c9(throtPosX+10,gM,i5,"pbright txtstart")gX[#gX+1]=c9(throtPosX+10,gN,e("%.0f %s",cg,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bB and M then i3=d(N*100+0.5)local i6="red"if i3<0 then i6="red"end;gX[#gX+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i6,1-c(i3),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gX[#gX+1]=c9(throtPosX+10,gM+40,"LIMIT","pbright txtstart")gX[#gX+1]=c9(throtPosX+10,gN+40,i3 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gX[#gX+1]=c9(throtPosX+10,gM-40,"LIMIT: "..b8 .." km/h","dim txtstart")elseif not aq and Autopilot then gX[#gX+1]=c9(throtPosX+10,gM-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i7(gX,i8)local i9=throtPosY-10;local ia=throtPosX+10;gX[#gX+1]=c9(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then i9=75 end;gX[#gX+1]=c9(ia,i9,d(i8).." km/h","pbright txtbig txtstart")end;local function ib(gX)gX[#gX+1]=c9(gj(1900),gk(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gX[#gX+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gX[#gX+1]=c9(gj(960),gk(550),"Warning: Invalid Control Scheme Detected","warnings")gX[#gX+1]=c9(gj(960),gk(600),"Keyboard Scheme must be selected","warnings")gX[#gX+1]=c9(gj(960),gk(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ic=gj(960)local id=gk(860)local ie=gk(880)local ig=gk(900)local ih=gk(960)local ii=gk(200)local ij=gk(250)local ik=gk(960)if l()==1 and not RemoteHud then id=gk(135)ie=gk(155)ig=gk(175)ii=gk(115)ij=gk(95)end;if BrakeIsOn then gX[#gX+1]=c9(ic,id,"Brake Engaged","warnings")elseif L>0 then gX[#gX+1]=c9(ic,id,"Auto-Brake Engaged","warnings","opacity:"..L)end;if aq and b3 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bz and not VertTakeOff and not AutoTakeoff then gX[#gX+1]=c9(ic,ii+50,"** STALL WARNING **","warnings")bX("stall","SW",2)end end;if bK then gX[#gX+1]=c9(ic,ii+90,"Flight Assist in Progress","warnings")end;if ax then gX[#gX+1]=c9(ic,ik,"Gyro Enabled","warnings")end;if GearExtended then if S then gX[#gX+1]=c9(ic,ie,"Gear Extended","warn")else gX[#gX+1]=c9(ic,ie,"Landed (G: Takeoff)","warnings")end;local il=cm(a:getTargetGroundAltitude())gX[#gX+1]=c9(ic,ig,"Hover Height: "..il,"warn")end;if a7 then gX[#gX+1]=c9(ic,ih+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bz and AntigravTargetAltitude~=nil then if c(as-antigrav.getBaseAltitude())<501 then gX[#gX+1]=c9(ic,ii+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else gX[#gX+1]=c9(ic,ii+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gX[#gX+1]=c9(ic,ii+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gX[#gX+1]=c9(ic,ii+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif a0 then gX[#gX+1]=c9(ic,ii+20,"Follow Mode Engaged","warn")elseif Reentry or an then gX[#gX+1]=c9(ic,ii+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local il=cm(HoldAltitude,2)if VertTakeOff then if bz then il=cm(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gX[#gX+1]=c9(ic,ii,"VTO to "..il,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gX[#gX+1]=c9(ic,ii,"Takeoff to "..AutopilotTargetName,"warn")else gX[#gX+1]=c9(ic,ii,"Takeoff to "..il,"warn")end;if BrakeIsOn and not VertTakeOff then gX[#gX+1]=c9(ic,ii+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gX[#gX+1]=c9(ic,ii,"Altitude Hold: "..il,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gX[#gX+1]=c9(ic,ii+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gX[#gX+1]=c9(ic,ii+20,"Aligning trajectory","warn")elseif ar<0.05 then gX[#gX+1]=c9(ic,ii+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if ba~=nil then gX[#gX+1]=c9(ic,ii,ba,"warn")end end;if BrakeLanding then if StrongBrakes then gX[#gX+1]=c9(ic,ii,"Brake-Landing","warnings")else gX[#gX+1]=c9(ic,ii,"Coast-Landing","warnings")end end;if ProgradeIsOn then gX[#gX+1]=c9(ic,ii,"Prograde Alignment","crit")end;if RetrogradeIsOn then gX[#gX+1]=c9(ic,ii,"Retrograde Alignment","crit")end;if bN then local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;gX[#gX+1]=c9(ic,ij+20,bN,type)elseif ar==0 then local bS,bW=bQ(bs:normalize())if bW~=nil then local il=cm(bW)local travelTime=aT.computeTravelTime(bt,0,bW)local im="Collision"if bS.noAtmosphericDensityAltitude>0 then im="Atmosphere"end;gX[#gX+1]=c9(ic,ij+20,bS.name.." "..im.." "..cx(travelTime).." In "..il,"crit")end end;if VectorToTarget and not IntoOrbit then gX[#gX+1]=c9(ic,ii+35,VectorStatus,"warn")end;gX[#gX+1]="</g>"return gX end;local function io(ex)return d(z(ex*3.6,0)+0.5).." km/h"end;local function ip(gX)local iq=OrbitMapX;local ir=OrbitMapY;local is=OrbitMapSize;local it=4;local iu=15;local ca=0;local cb=0;local iv,iw,ix,iy;local function iz(type)local iA,D,ex,iB;if type=="Periapsis"then iA=orbit.periapsis.altitude;D=orbit.timeToPeriapsis;ex=orbit.periapsis.speed;iB=35 else iA=orbit.apoapsis.altitude;D=orbit.timeToApoapsis;ex=orbit.apoapsis.speed;iB=-35 end;gX[#gX+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],ca+iB,cb-5,iq+is/2-iv+iy,cb-5)gX[#gX+1]=c9(ca,cb,type)cb=cb+iu;local il=cm(iA)gX[#gX+1]=c9(ca,cb,il)cb=cb+iu;gX[#gX+1]=c9(ca,cb,cx(D))cb=cb+iu;gX[#gX+1]=c9(ca,cb,io(ex))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then ir=ir+it;ca=iq+is+iq/2+it;cb=ir+is/2+5+it;iv=is/4;iy=0;gX[#gX+1]=[[<g class="pbright txtorb txtmid">]]gX[#gX+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',is+iq*2,is+ir,it,it)if orbit.periapsis~=nil and orbit.apoapsis~=nil then ix=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(iv*2)iw=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/ix*(1-orbit.eccentricity)iy=iv-orbit.periapsis.altitude/ix-planet.radius/ix;local iC=""if orbit.periapsis.altitude<=0 then iC='redout'end;gX[#gX+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iC,iq+is/2+iy+it,ir+is/2+it,iv,iw)gX[#gX+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',iq+is/2+it,ir+is/2+it,planet.radius/ix)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iz("Apoapsis")end;cb=ir+is/2+5+it;ca=iq-iq/2+10+it;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iz("Periapsis")end;gX[#gX+1]=c9(iq+is/2+it,planet.name,20+it,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iD=orbit.timeToApoapsis/orbit.period*2*math.pi;local iE=iv*math.cos(iD)local iF=iw*math.sin(iD)gX[#gX+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',iq+is/2+iE+iy+it,ir+is/2+iF+it)end;gX[#gX+1]=[[</g>]]return gX else return gX end end;local function iG(gX)local ca=30;local cb=275;local iH={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local iI={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iJ={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iK={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and offset","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if aq then b_(iH,iI)table.insert(iH,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(iH,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ao~=-1 then if antigrav then if bz then table.insert(iH,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iH,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iH,"Alt-6: Begins Vertical Takeoff.")else table.insert(iH,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(iH,"G: Begin BrakeLanding or Land")end else b_(iH,iJ)end;if AltitudeHold then table.insert(iH,"Alt-Spacebar/Alt-C will raise/lower target height")end;b_(iH,iK)for i=1,#iH do cb=cb+12;gX[#gX+1]=c9(ca,cb,iH[i],"pdim txttick txtstart")end end;local function iL(iM,iN)local iO;local iP=(iN-iM):normalize()local eC=(bw-iM):dot(iP)/iP:dot(iP)if eC<=0.then return(bw-iM):len()elseif eC>=(iN-iM):len()then return(bw-iN):len()end;local iQ=iM+eC*iP;iO=(iQ-bw):len()return iO end;local function iR()local iO;local iS=nil;local iT=nil;local iU=nil;for cG,iV in pairs(aN[0])do if iV.hasAtmosphere then local aj=iL(planet.center,iV.center)if iS==nil or aj<iS then iT=iV;iS=aj;iU=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dY=iL(ac.center,iV.center)if dY<iS then iT=iV;iS=dY;iU=ac end end end end;local iW=gj(1770)local iX=gk(330)if iS then local iY="txttick "local iZ=500000;if iS<iT.radius+iZ or iS<iU.radius+iZ then if bI then iY="txttick red "else iY="txttick orange "end end;iO=cm(iS,2)bJ=c9(iW,iX,"Pipe ("..iU.name.."--"..iT.name.."): "..iO,iY.."pbright txtmid")end end;local i_={}function i_.HUDPrologue(gX)bI,g9=gh(bw)if not bI then H=PvPR;J=PvPG;I=PvPB else H=SafeR;J=SafeG;I=SafeB end;ay=[[rgb(]]..d(H+0.5)..","..d(J+0.5)..","..d(I+0.5)..[[)]]az=[[rgb(]]..d(H*0.9+0.5)..","..d(J*0.9+0.5)..","..d(I*0.9+0.5)..[[)]]local j0=ay;local j1=az;local j2=ay;local j3=az;if gl()and not brightHud then j0=[[rgb(]]..d(H*0.4+0.5)..","..d(J*0.4+0.5)..","..d(I*0.3+0.5)..[[)]]j1=[[rgb(]]..d(H*0.3+0.5)..","..d(J*0.3+0.5)..","..d(I*0.2+0.5)..[[)]]end;gX[#gX+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],j0,j0,j2,j2,j1,j1,j3,j3,aG,aH)return gX end;function i_.DrawVerticalSpeed(gX,dh)gW(gX,dh)end;function i_.UpdateHud(gX)local hM=bC;local j4=bD;local h4=j4;local hj=hM;local i3=d(unit.getThrottle())local i8=bt*3.6;local i4=unit.getAxisCommandValue(0)local j5=gj(1770)local j6=gk(310)if AtmoSpeedAssist and bB then i4=K;i3=K*100 end;local gn=gm()local h5="ROLL"if i3==nil then i3=0 end;if not bM then if bt>5 then hM=hL(br)j4=hN(br)else hM=0;j4=0 end;h5="YAW"end;if g9>50000 and not aq then local j7;j7=cm(g9)gX[#gX+1]=c9(j5,j6,"PvP Boundary: "..j7,"pbright txtbig txtmid")end;gX[#gX+1]=ak;gX[#gX+1]=aD;gX[#gX+1]=go;if bJ~=""then gX[#gX+1]=bJ end;if gp~=""then gX[#gX+1]=gp end;if gq~=""then gX[#gX+1]=gq end;gW(gX,as)if l()==0 or RemoteHud then if not gl()or brightHud then if bM then h3(gX,centerX,centerY,h4,h5,bM)hi(gX,hj,h4,centerX,centerY,bM,d(hN(br)),bt)else h3(gX,centerX,centerY,j4,h5,bM)hi(gX,hM,j4,centerX,centerY,bM,d(j4),bt)end;hp(gX,as,bM)hO(gX,br,bt,centerX,centerY)end end;i2(gX,gn,i3,i4)i7(gX,i8)ib(gX)ip(gX)if showHelp then iG(gX)end;return gX end;function i_.HUDEpilogue(gX)gX[#gX+1]="</svg>"return gX end;function i_.ExtraData(gX)local j8=gj(1240)local j9=gk(55)local ja=j9+10;local jb;local jc=0;local gn=gm()if VertTakeOffEngine then gn=gn.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bt>20 then gn=gn.."-COLLISION ON"end;if UseExtra~="Off"then gn="("..UseExtra..")-"..gn end;if TurnBurn then gn="TB-"..gn end;if not stablized then gn=gn.."-DeCoupled"end;local jd=vec3(core.getWorldAcceleration()):len()/9.80665;jb=core.g()gX[#gX+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then j8=gj(1120)j9=gk(55)ja=j9+10 elseif aq then local je=gj(770)gX[#gX+1]=c9(je,j9,"ATMOSPHERE","pdim txt txtend")gX[#gX+1]=c9(je,ja,e("%.2f",ar),"pdim txt txtend","")end;gX[#gX+1]=c9(j8,j9,"GRAVITY","pdim txt txtend")gX[#gX+1]=c9(j8,ja,e("%.2f",jb/9.80665),"pdim txt txtend")gX[#gX+1]=c9(j8,j9+20,"ACCEL","pdim txt txtend")gX[#gX+1]=c9(j8,ja+20,e("%.2f",jd),"pdim txt txtend")gX[#gX+1]=c9(gj(960),gk(180),gn,"txtbig txtmid")end;function i_.DrawOdometer(gX,ad,TotalDistanceTravelled,ae)local jb;local jf=0;local jg=0;local jc=0;local jh=av>1000000 and z(av/1000000,2).." kTons"or z(av/1000,2).." Tons"if aq then jc=LastMaxBrakeInAtmo else jc=LastMaxBrake end;jc=z(jc/(av*ga),2).." g"local ji=a:maxForceForward()jb=core.g()if jb>0.1 then jg=av*jb;jg=z(jg/(av*ga),2).." g"jf=0.5*ji/jb;jf=jf>1000000 and z(jf/1000000,2).." kTons"or z(jf/1000,2).." Tons"end;ji=z(ji/(av*ga),2).." g"gX[#gX+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gj(660),gj(700),gk(35),gj(960),gk(55),gj(1240),gk(35),gj(1280))if l()==0 or RemoteHud then gX[#gX+1]=c9(gj(700),gk(20),e("Trip: %.2f km",ad),"txtstart")gX[#gX+1]=c9(gj(700),gk(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gX[#gX+1]=c9(gj(830),gk(20),"Trip Time: "..cx(ae),"txtstart")gX[#gX+1]=c9(gj(830),gk(30),"Total Time: "..cx(TotalFlightTime),"txtstart")gX[#gX+1]=c9(gj(970),gk(20),e("Mass: %s",jh),"txtstart")gX[#gX+1]=c9(gj(1240),gk(10),e("Max Brake: %s",jc),"txtend")gX[#gX+1]=c9(gj(1240),gk(30),e("Max Thrust: %s",ji),"txtend")if jb>0.1 then gX[#gX+1]=c9(gj(970),gk(30),e("Max Thrust Mass: %s",jf),"txtstart")gX[#gX+1]=c9(gj(1240),gk(20),e("Req Thrust: %s",jg),"txtend")else gX[#gX+1]=c9(gj(970),gk(30),"Max Mass: n/a","txtstart")gX[#gX+1]=c9(gj(1240),gk(20),"Req Thrust: n/a","txtend")end end;gX[#gX+1]="</g>"return gX end;function i_.DrawWarnings(gX)return ib(gX)end;function i_.DisplayOrbitScreen(gX)return ip(gX)end;function i_.DisplayMessage(gX,il)if il~="empty"then local cb=310;for jj in string.gmatch(il,"([^\n]+)")do cb=cb+35;gX[#gX+1]=c9("50%",cb,jj,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function i_.DrawDeadZone(gX)gX[#gX+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function i_.UpdatePipe()if aq then bJ=""return end;iR()end;function i_.DrawSettings(gX)if#bF>0 then local ca=gj(640)local cb=gk(200)gX[#gX+1]=[[<g class="pbright txtvspd txtstart">]]for cG,cH in pairs(bF)do gX[#gX+1]=c9(ca,cb,cH..": ".._G[cH])cb=cb+20;if cG%12==0 then ca=ca+gj(350)cb=gk(200)end end;gX[#gX+1]=c9(gj(640),gk(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gX[#gX+1]="</g>"end;return gX end;local jk;local jl=gj(1770)local jm=gk(350)local jn=gk(15)local jo=gj(1370)local bP,jp;local jq=0;function i_.DrawRadarInfo()local function jr()if radarPanelID~=nil and jq==0 then s(radarPanelID)radarPanelID=nil;if jk~=nil then s(jk)jk=nil end else if jq==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jk=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;jq=0 end end;local f2,f3,f1,f4,f5,eZ=aZ.GetRadarHud()local A=f4 or 0;if f1>0 then if CollisionSystem then bP=A.."/"..f5 .." Plotted : "..f1-f5 .." Ignored"else bP="Radar Contacts: "..f1 end;go=c9(jl,jm,bP,"pbright txtbig txtmid")if#eZ>0 then go=go..c9(jo,jn,"Friendlies In Range","pbright txtbig txtmid")for cG,cH in pairs(eZ)do jn=jn+20;go=go..c9(jo,jn,radar_1.getConstructName(cH),"pdim txtmid")end end;if f2==nil and jk==nil then jq=1;jr()end;if f2~=nil and jk~=nil then jr()end;if radarPanelID==nil then jr()end else if f3 then go=c9(jl,jm,"Radar: Jammed","pbright txtbig txtmid")else go=c9(jl,jm,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then jq=0;jr()end end end;function i_.DrawTanks()if fuelX~=0 and fuelY~=0 then gp=c9(fuelX,fuelY,"","txtstart pdim txtfuel")gG(fuelX,"Atmospheric ","ATMO",aI,gE,gF)gG(fuelX+120,"Space fuel t","SPACE",aJ,gC,gD)gG(fuelX+240,"Rocket fuel ","ROCKET",aK,gA,gB)end end;function i_.DrawShield()local js=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local jt=core.getPvPTimer()local ca,cb=shieldX-60,shieldY+30;local ju=d(0.5+shield_1.getShieldHitPoints()*100/shield_1.getMaxShieldHitPoints())local gU=d(ju*2.55)local gV=e("rgb(%d,%d,%d)",255-gU,gU,0)local cd=""gq=c9(ca,cb,"","txtmid pdim txtfuel")if ju<10 and js~="Shield Disabled"then cd="red "end;jt=jt>0 and"   PvPTime: "..cx(jt)or""gq=gq..e([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],ca,cb,gV,ju*2,ca,cb,ca+2,cb+10,ju,jt)gq=gq..c9(ca,cb-5,js,cd.."txtstart pbright txtbig")end;return i_ end;local function jv()local function jw(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=aN[0][0]end;return p end;local function jx()local function jy(jz,jA)return jz.name<jA.name end;bH={}for cG,cH in pairs(aN[0])do bH[#bH+1]={name=cH.name,index=cG}end;table.sort(bH,jy)end;local function jB(jC)for cG,cH in pairs(jC)do if cH.name and cH.name==CustomTarget.name then return cG end end;return-1 end;local function jD()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local jE=bH[AutopilotTargetIndex].index;local jF=aN[0][jE]if jF.center then AutopilotTargetName=jF.name;ac=aS[0][jE]if CustomTarget~=nil then if ar==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jF;for _,cH in pairs(aS[0])do if cH.name==CustomTarget.planetname then ac=cH;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=d(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aV(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jG(h0)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if h0==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bH then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bH end end;if AutopilotTargetIndex==0 then jD()else local jE=bH[AutopilotTargetIndex].index;local jF=aN[0][jE]if jF~=nil and jF.name=="Space"or iphCondition=="Custom Only"and jF.center or iphCondition=="No Moons"and string.find(jF.name,"Moon")~=nil then if h0==nil then jG()else jG(1)end else jD()end end else a2="Disengage autopilot before changing Interplanetary Helper"bX("iph","AP")end end;local function jH()local fK=-1;fK=jB(aN[0])if fK>-1 then table.remove(aN[0],fK)end;fK=-1;fK=jB(SavedLocations)if fK~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fK)end;jG()jx()end;local function jI(fZ,position,hI,jJ)if dbHud_1 or hI then local p=jw(position)local jb=p.gravity;local jK=p.atmosphericDensityAboveSurface;if jJ then jK=ar;jb=unit.getClosestPlanetInfluence()end;local jL={position=position,name=fZ,atmosphere=jK,planetname=p.name,gravity=jb,safe=jJ}if not hI then SavedLocations[#SavedLocations+1]=jL else for cG,cH in pairs(aN[0])do if cH.name and fZ==cH.name then table.remove(aN[0],cG)end end end;table.insert(aN[0],jL)jx()jD()a2="Location saved as "..fZ.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local cI={}function cI.UpdateAtlasLocationsList()jx()end;function cI.UpdateAutopilotTarget()jD()end;function cI.adjustAutopilotTargetIndex(h0)jG(h0)end;function cI.findAtlasIndex(jC)jB(jC)end;function cI.UpdatePosition(jM)local fK=jB(SavedLocations)if fK~=-1 then if jM~=nil then SavedLocations[fK].name=jM;AutopilotTargetIndex=AutopilotTargetIndex-1;jG()else local jN=SavedLocations[fK]jN.atmosphere=ar;jN.gravity=unit.getClosestPlanetInfluence()jN.position=bw;jN.safe=true end;a2=SavedLocations[fK].name.." position updated ("..SavedLocations[fK].planetname..")"else a2="Name Not Found"end end;function cI.AddNewLocation(fZ,position,hI,jJ)jI(fZ,position,hI,jJ)end;function cI.ClearCurrentPosition()jH()end;for cG,cH in pairs(SavedLocations)do table.insert(aN[0],cH)end;jx()cI.UpdateAutopilotTarget()return cI end;local function jO()local jP={}local function jQ(ex)local jR=AutopilotEndSpeed;if not Autopilot then jR=0 end;if not aq then return aT.computeDistanceAndTime(ex,jR,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aT.computeDistanceAndTime(ex,jR,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jS(ex)local jR=AutopilotEndSpeed;if not Autopilot then jR=0 end;return aT.computeDistanceAndTime(ex,jR,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local jT=false;function jP.GetAutopilotBrakeDistanceAndTime(ex)return jQ(ex)end;function jP.GetAutopilotTBBrakeDistanceAndTime(ex)return jS(ex)end;local function jU(jV,jW,jX)jW=jW:project_on_plane(jV)jX=jX:project_on_plane(jV)return m(jW:cross(jX):dot(jV),jW:dot(jX))end;local function jY()local function jZ()local j_=-1;local k0=-1;if vBooster then j_=vBooster.distance()end;if hover then k0=hover.distance()end;if j_~=-1 and k0~=-1 then if j_<k0 then return j_ else return k0 end elseif j_~=-1 then return j_ elseif k0~=-1 then return k0 else return-1 end end;local k1=jZ()local k2=-1;if telemeter_1 then k2=telemeter_1.getDistance()end;if k1~=-1 and k2~=-1 then if k1<k2 then return k1 else return k2 end elseif k1~=-1 then return k1 else return k2 end end;local function k3(planet,dU,k4)local function k5(k6,db)local d_=vec3(db)if k6.bodyId==0 then return setmetatable({latitude=d_.x,longitude=d_.y,altitude=d_.z,bodyId=0,systemId=k6.planetarySystemId},MapPosition)end;local e0=d_-k6.center;local aj=e0:len()local dh=aj-k6.radius;local df=0;local dg=0;if not cj(aj,0)then local e1=m(e0.y,e0.x)dg=e1>=0 and e1 or 2*math.pi+e1;df=math.pi/2-math.acos(e0.z/aj)end;return setmetatable({latitude=math.deg(df),longitude=math.deg(dg),altitude=dh,bodyId=k6.bodyId,systemId=k6.planetarySystemId},MapPosition)end;local k7=k5(planet,dU)k7="::pos{"..k7.systemId..","..k7.bodyId..","..k7.latitude..","..k7.longitude..","..k7.altitude.."}"if k4 then return k7 else system.setWaypoint(k7)return true end end;local k8=false;function jP.showWayPoint(planet,dU,k4)return k3(planet,dU,k4)end;function jP.APTick()local function k9()if bO and not BrakeLanding then local bV=bO[1]local f_,g0=bO[2],bO[3]local ka=math.min(f_,g0 or f_)local kb=ka/bt;local kc=AutoTakeoff and(bt<42 or ao~=-1)local kd=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if kd and not kc and(a8*1.5>ka or kb<1)then BrakeIsOn=true;cf(0)if AltitudeHold then cr()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cs()end;StrongBrakes=true;BrakeLanding=true;b1=true end;if kb<11 then bN=bV.name.." COLLISION "..cx(kb).." / "..cm(ka,2)else bN=bV.name.." collision "..cx(kb)end;if kb<6 then bX("alarm","AL",2)end else bN=false end end;local function ke(bR,kf,kg)local function kh(bR,dG)bR=vec3(bR)dG=vec3(dG):normalize()local cY=bR*dG;return cY.x+cY.y+cY.z end;local ki=0.001;local kj=1;if not aq or not b3 or ao~=-1 or bt<Q then if kg==nil then kg=DampingMultiplier end;if kf==nil then kf=ki end;bR=vec3(bR):normalize()local kk=vec3()-bR;local kl=-kh(kk,core.getConstructWorldOrientationRight())*kj;local km=-kh(kk,core.getConstructWorldOrientationUp())*kj;if aB==0 then aB=kl/2 end;if aC==0 then aC=km/2 end;if c(kl)<0.1 then V=V-kl*2 else V=V-(kl+(kl-aB)*kg)end;if c(km)<0.1 then U=U+km*2 else U=U+km+(km-aC)*kg end;aB=kl;aC=km;if c(kl)<kf and c(km)<kf then return true end;return false elseif b3 and ao==-1 then bR=bs;if kg==nil then kg=DampingMultiplier end;if kf==nil then kf=ki end;bR=vec3(bR):normalize()local kk=bp-bR;local kl=-kh(kk,core.getConstructWorldOrientationRight())*kj;local km=-kh(kk,core.getConstructWorldOrientationUp())*kj;if aB==0 then aB=kl/2 end;if aC==0 then aC=km/2 end;if c(kl)<0.1 then V=V-kl*5 else V=V-(kl+(kl-aB)*kg)end;if c(km)<0.1 then U=U+km*5 else U=U+km+(km-aC)*kg end;aB=kl;aC=km;if c(kl)<kf and c(km)<kf then return true end;return false end end;aq=j()>0;ar=j()as=core.getAltitude()ao=jY()D=o()b4=D;if CollisionSystem then k9()end;if antigrav then bz=antigrav.getState()==1 end;local kn=1;local ko=1;local kp=D-b4;local kq=-math.deg(jU(bo,bs,bp))local kr=math.deg(jU(bq,bs,bp))local h0=bu*-1;b3=aq and kq<-YawStallAngle or kq>YawStallAngle or kr<-PitchStallAngle or kr>PitchStallAngle;local ks=system.getMouseDeltaX()local kt=system.getMouseDeltaY()if InvertMouse and not a1 then kt=-kt end;V=0;Z=0;U=0;sys=aS[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aV(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bs)if as==0 then as=(bw-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local jb=planet:getGravity(core.getConstructWorldPos()):len()*av;b5=0;aU=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and a1 then if not a_ then ag=ag+ks;ah=ah+kt end else ag=0;ah=0 end else ag=ag+ks;ah=ah+kt;aj=x(ag*ag+ah*ah)if not a1 and l()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(kt,-100,100)+0.5)*2*kn;V=(-utils.smoothstep(ks,-100,100)+0.5)*2*ko end end end end;local ku=bt>8334;if bt>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not ku then a2="Space Speed Engine Shutoff reached"cf(0)end;if not ku and LastIsWarping then if not BrakeIsOn then cu()end;if Autopilot then cs()end end;LastIsWarping=ku;if aq and ar>0.09 then if bt>b8/3.6 and not AtmoSpeedAssist and not jT then BrakeIsOn=true;jT=true elseif not AtmoSpeedAssist and jT then if bt<b8/3.6 then BrakeIsOn=false;jT=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local kv=false;if CustomTarget~=nil and al~=1 then kv=ke(CustomTarget.position-bw,0.1)else kv=ke(vec3(bs),0.01)end;b1=true;if kv then ci(d(b8))if(c(bD)<2 or c(bC)>85)and bt>=b8/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cv()end elseif aq and AtmoSpeedAssist then cf(1)end elseif bt>Q then ke(vec3(bs),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bt>Q then ke(-vec3(bs))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cv()al=false;an=true else al=false;cs()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bt*3.6>b8-250 and c(bv)<25 and ar>=0.1 and(CustomTarget.position-bw):len()>2000+as then cs()an=false end;if VertTakeOff then b1=true;local kw=HoldAltitude;if bv<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b1=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bz or HoldAltitude<planet.spaceEngineMinAltitude then if bz then kw=antigrav.getBaseAltitude()end;if as<kw-100 then b9=0;af=15;BrakeIsOn=false elseif bv>0 then BrakeIsOn=true;af=0 elseif bv<-30 then BrakeIsOn=true;af=15 elseif as>=kw then if bz then if Autopilot or VectorToTarget then cp()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bX("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bX("vtoc","VT")cp()end;af=0 end else if ar>0.08 then b9=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bl then b9=0;af=20 else af=0;b9=36;ci(3500)end else b1=autoRollPreference;IntoOrbit=true;bj=false;CancelIntoOrbit=false;bd=false;bb=nil;bc=nil;if bi==nil then bi=planet end;bh=kw;bg=true;VertTakeOff=false end end;if b9~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kx=q(b9-bC,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kx)local ky=q(vTpitchPID:get(),-1,1)U=ky end end;if IntoOrbit then local kk;local kz=false;local kA=cm(bh)if bi==nil then bi=planet;if VectorToTarget then bi=ac end end;if not bg then bh=d(bi.radius+bi.surfaceMaxAltitude+LowOrbitHeight)if bi.hasAtmosphere then bh=d(bi.radius+bi.noAtmosphericDensityAltitude+LowOrbitHeight)end;bg=true end;if bf.VectorToTarget then kk=CustomTarget.position-bw end;local kB,kC=aV(bi):escapeAndOrbitalSpeed((bw-bi.center):len()-bi.radius)local kD=bD;if not bd then local kE=false;local kF=false;cf(0)bc=0;ba="Aligning to orbital path - OrbitHeight: "..kA;if bf.VectorToTarget then ke(kk:normalize():project_on_plane(bu))kz=bp:dot(kk:project_on_plane(bo):normalize())>0.95 else ke(bs)kz=kq<0.5;if bt<150 then kz=true end end;U=0;bb=0;if bC<=bb+1 and bC>=bb-1 then kE=true else kE=false end;if kD<=bc+1 and kD>=bc-1 then kF=true else kF=false end;if kE and kF and kz then bb=nil;bc=nil;bd=true end else if bf.VectorToTarget then ke(kk:normalize():project_on_plane(bu))elseif bt>150 then ke(bs)end;U=0;if bf.VectorToTarget then local a8,_=aT.computeDistanceAndTime(bt,b8/3.6,av,0,0,LastMaxBrake)if bj and kk:len()>15000+a8+as then ba="Orbiting to Target"if as-100<=bi.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bi.noAtmosphericDensityAltitude then bj=false end elseif bj or kk:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bX("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;bf.VectorToTarget,bf.AutopilotAlign=false,false;cq()cv()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bh*0.9 and as<bh*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bh*0.99 and orbit.apoapsis.altitude>=bh*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bj then if bj then BrakeIsOn=false;cf(0)bb=0;if not bf.VectorToTarget then a2="Orbit complete"bX("orCom","OB")cq()end else bn=bn+1;if bn>=2 then bj=true end end else ba="Adjusting Orbit - OrbitHeight: "..kA;be=true;ci(kC*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kG=bv;local kH=as-bh;local kI=c(kH)if bv<10 and c(bC)<10 and kI<100 then kG=bv*2 end;if kG<10 and c(bC)<10 and kI<100 then kG=kG*2 end;if kG<5 and c(bC)<5 and kI<100 then kG=kG*4 end;VSpdPID:inject(kG)bb=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kH)bb=q(bb-q(OrbitAltPID:get(),-15,15),-90,90)end end else local kJ=2.75;local kK=c(z(kB*kJ))local kL=kK%50;if kL>0 then kK=kK-kL+50 end;BrakeIsOn=false;if as<bh*0.8 then ba="Escaping planet gravity - OrbitHeight: "..kA;bb=utils.map(bv,200,0,-15,80)elseif as>=bh*0.8 and as<bh*1.15 then ba="Approaching orbital corridor - OrbitHeight: "..kA;kK=kK*0.75;bb=utils.map(bv,100,-100,-15,65)elseif as>=bh*1.15 and as<bh*1.5 then ba="Approaching orbital corridor - OrbitHeight: "..kA;kK=kK*0.75;if bv<0 or be then bb=utils.map(as,bh*1.5,bh*1.01,-30,0)else bb=utils.map(as,bh*0.99,bh*1.5,0,30)end elseif as>bh*1.5 then ba="Reentering orbital corridor - OrbitHeight: "..kA;bb=-65;local kM=utils.map(bv,-150,-400,1,0.55)kK=kK*kM end;ci(d(kK))end end;if bb~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kN=bb-bC;OrbitPitchPID:inject(kN)local kO=q(OrbitPitchPID:get(),-0.5,0.5)U=kO end end;if Autopilot and ar==0 and not al then local function kP(bP,orbit)system.print(bP)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cf(0)P=false;a2=bP;bX("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bh=as;bg=true end;cq()end end;local kQ,kR=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kS=(CustomTarget.position-ac.center):normalize()local kT=kS:project_on_plane((ac.center-bw):normalize()):normalize()local kU=ac.center+kT*(ac.radius+AutopilotTargetOrbit)local kV=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bw-kU):len()<(bw-kV):len()then kQ=kU else kQ=kV;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kQ;aY.showWayPoint(ac,AutopilotTargetCoords)kR=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kR=true;TargetSet=true;AutopilotRealigned=true;kQ=CustomTarget.position+(bw-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kS=(bw+bs*100000-ac.center):normalize()local kT=kS:project_on_plane((ac.center-bw):normalize()):normalize()if kT:len()<1 then kS=(bw+bp*100000-ac.center):normalize()kT=kS:project_on_plane((ac.center-bw):normalize()):normalize()end;kQ=ac.center+kT*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kQ;TargetSet=true;kR=true;AutopilotRealigned=true;aY.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kQ)-bw):len()local bS,bT,bU=aS:getPlanetarySystem(0):castIntersections(bw,bs:normalize(),function(bV)if bV.noAtmosphericDensityAltitude>0 then return bV.radius+bV.noAtmosphericDensityAltitude else return bV.radius+bV.surfaceMaxAltitude*1.5 end end)local bW=bT;if bU~=nil and bT~=nil then bW=math.min(bU,bT)end;if bW~=nil and bW<AutopilotDistance and bS.name==ac.name then AutopilotDistance=bW end;local kv=true;local kW=(ac.center-(bw+vec3(bs):normalize()*AutopilotDistance)):len()-ac.radius;local il=cm(kW)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..il..'"}')local a8,a9;if not TurnBurn then a8,a9=jQ(bt)else a8,a9=jS(bt)end;if bt>300 and AutopilotAccelerating then local kk=vec3(kQ)-bw;local kX=q(math.deg(jU(bo,bs:normalize(),kk:normalize()))*bt/500,-90,90)local kY=q(math.deg(jU(bq,bs:normalize(),kk:normalize()))*bt/500,-90,90)if c(kX)<20 and c(kY)<20 then kX=kX*2;kY=kY*2 end;if c(kX)<2 and c(kY)<2 then kX=kX*2;kY=kY*2 end;local kq=-math.deg(jU(bo,bp,bs:normalize()))local kr=-math.deg(jU(bq,bp,bs:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kY-kr)local kZ=q(apPitchPID:get(),-1,1)U=U+kZ;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kX-kq)local k_=q(apYawPID:get(),-1,1)V=V+k_;kR=true;if c(kX)>2 or c(kY)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bX("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bX("apAcc","AP")end end end;if kW<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aV(ac):escapeAndOrbitalSpeed(kW)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bS,bW=bQ((AutopilotTargetCoords-bw):normalize())if ac.name~=planet.name then if bS~=nil and ac.name~=bS.name then a2="Collision with "..bS.name.." in "..cm(bW).."\nClear LOS to continue."ai=5;k8=true else k8=false;a2=""end end end;if not k8 then if not AutopilotCruising and not AutopilotBraking and not kR then kv=ke((kQ-bw):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kv=ke(-vec3(bs):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;cf(AutopilotInterplanetaryThrottle)K=z(AutopilotInterplanetaryThrottle,2)P=true end;local l0=unit.getThrottle()if AtmoSpeedAssist then l0=K end;if br:len()>=MaxGameVelocity or l0==0 and P then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bX("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cf(0)end;if AutopilotDistance<=a8 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bX("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cf(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then cf(1,true)end;local _,kC=aV(ac):escapeAndOrbitalSpeed((bw-planet.center):len()-planet.radius)local kk;if CustomTarget~=nil then kk=CustomTarget.position-bw end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bt<50 then kP("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bt<=kC and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kP("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aY.showWayPoint(ac,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bX("apCir","AP")AutopilotStatus="Circularizing"end;if bt<=kC then if CustomTarget~=nil then if bs:normalize():dot(kk:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bX("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aY.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else kP("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aY.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else kP("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then kP("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a8 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bX("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local l0=unit.getThrottle()if AtmoSpeedAssist then l0=K end;if l0>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bX("apAcc","AP")end;AutopilotCruising=false end else if kv then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bq;AutopilotShipUp=bo;AutopilotShipRight=bq end;AutopilotRealigned=true elseif kv and not k8 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bX("apAcc","AP")end;if not P then cf(AutopilotInterplanetaryThrottle,true)K=z(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bX("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;cf(0)P=false;ProgradeIsOn=true;al=true;aY.showWayPoint(ac,CustomTarget.position)end;if a0 then b1=true;local kY=0;local eB=bw+vec3(unit.getMasterPlayerRelativePosition())local l1=eB-bw;local l2=vec3(l1):project_on(bp):len()local l3=vec3(l1):project_on(bq):len()local aj=x(l2*l2+l3*l3)ke(l1:normalize())local l4=40;local l5=aj<l4;local l6=100;local l7=q((aj-l4)/2,10,l6)U=0;local kv=c(V)<0.1;if kv and bt<l7 and not l5 then BrakeIsOn=false;kY=-20 else BrakeIsOn=true;kY=0 end;local l8=0;if c(kY-bC)>l8 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kY-bC)local kZ=pitchPID:get()U=kZ end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l9=LastMaxBrakeInAtmo;if l9 then l9=l9*q(bt/100,0.1,1)*ar else l9=LastMaxBrake end;if ar<0.01 then l9=LastMaxBrake end;local la=vec3(core.getWorldAirFrictionAcceleration())local lb=x(la:len()-la:project_on(h0):len())*av;if bt>100 then a8,a9=aT.computeDistanceAndTime(bt,100,av,0,0,l9+lb)local lc,ld=aT.computeDistanceAndTime(100,0,av,0,0,l9/2)a8=a8+lc else a8,a9=aT.computeDistanceAndTime(bt,0,av,0,0,l9/2)end;local le=HoldAltitude-as;local lf=500+bt;local lg=1;if AutoTakeoff then lg=q(bt/100,0.1,1)end;local kY=(utils.smoothstep(le,-lf,lf)-0.5)*2*MaxPitch*lg;if not Reentry and not al and not VectorToTarget and bp:dot(bs:normalize())<0.99 then kY=(utils.smoothstep(le,-lf*q(20-19*ar*10,1,20),lf*q(20-19*ar*10,1,20))-0.5)*2*MaxPitch*q(2-ar*10,1,2)*lg end;if not AltitudeHold then kY=0 end;if LockPitch~=nil then if bM and not IntoOrbit then kY=LockPitch else LockPitch=nil end end;b1=true;local lh=U;if Reentry then local li=d(b8)local lj,lk=aT.computeDistanceAndTime(bt,li/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)lj=lj==-1 and 5000 or lj;local ll=as-(planet.noAtmosphericDensityAltitude+lj)local lm=as>planet.noAtmosphericDensityAltitude+lj*1.35;if lm then kY=ReEntryPitch;if bt<=li/3.6 and bt>li/3.6-10 and c(bs:normalize():dot(bp))>0.9 and not bB then O=false;cf(1)end elseif bB and not lm and not aq then ci(li,true)end;if bB then if bt>li/3.6 and not lm then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bv>0 then BrakeIsOn=true end;if not R then kY=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kY=0;b1=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and lm then b1=true elseif not lm then BrakeIsOn=false;if not aq and(bB or r:getTargetSpeed(axisCommandId.longitudinal)~=li)then ci(li)end;if bt<li/3.6+1 then R=false;Reentry=false;b1=true end end end;if bt>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then ke(vec3(bs))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local kk;if bK then if type(bK)=="table"then kk=bK elseif bK<3 and bK>0 then kk=-bu:cross(bs)*5000 elseif bK>=3 then kk=bu:cross(bs)*5000 elseif bK<0 then kk=bs*25000 end elseif CustomTarget~=nil then kk=CustomTarget.position-bw else kk=ac.center-bw end;local kX=math.deg(jU(bu:normalize(),bs,kk))*2;local ln=math.rad(c(bD))if bt>minRollVelocity and ar>0.01 then local lo=q(90-kY*2,-90,90)b5=q(kX*2,-lo,lo)local lp=kX;kX=q(q(kX,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(ln)+4*(bC-kY)*math.sin(math.rad(bD)),-YawStallAngle*0.80,YawStallAngle*0.80)kY=q(q(kY*math.cos(ln),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(lp)*math.sin(ln),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b5=0;kX=q(kX,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lq=kq-kX;if bK and c(lq)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and c(bD)<1)then if bK==-2 then cr()end;bK=nil;bX("180Off","BR")return end;if not b3 and bt>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lq)local k_=q(yawPID:get(),-1,1)V=V+k_ elseif aq and ao>-1 or bt<minRollVelocity then ke(kk)elseif b3 and ar>0.01 then if(kq<-YawStallAngle or kq>YawStallAngle)and ar>0.01 then ke(bs)end;if(kr<-PitchStallAngle or kr>PitchStallAngle)and ar>0.01 then kY=q(bC-kr,bC-PitchStallAngle*0.80,bC+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local kw=planet:getAltitude(CustomTarget.position)local ll=x(kk:len()^2-(as-kw)^2)local lr=bs:len()-c(bv)StrongBrakes=true;if not am and not Reentry and ll<=a8+bt*kp/2 and(bs:project_on_plane(bu):normalize():dot(kk:project_on_plane(bu):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cf(0)if AltitudeHold then cr()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(lr<0.1 or ll<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<ll)then if not bz then bX("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=ll end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local kk=CustomTarget.position-bw;local kw=planet:getAltitude(CustomTarget.position)local ll=x(kk:len()^2-(as-kw)^2)local l9=LastMaxBrakeInAtmo;if l9 then a8,a9=aT.computeDistanceAndTime(bt,0,av,0,0,l9/2)StrongBrakes=true;if ll<=a8+bt*kp/2 and bs:project_on_plane(bu):normalize():dot(kk:project_on_plane(bu):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cv()end end;LastDistanceToTarget=ll end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bj and not IntoOrbit then bh=HoldAltitude;bg=true;if VectorToTarget then bf.VectorToTarget=true end;cq()VectorToTarget=false;bd=true end end;if b3 and ar>0.01 and ao==-1 and bt>minRollVelocity and VectorStatus~="Finalizing Approach"then ke(bs)kY=q(bC-kr,bC-PitchStallAngle*0.80,bC+PitchStallAngle*0.80)end;U=lh;local k2=-1;if BrakeLanding then kY=0;local ls=false;local lt=30;if aU~=nil and aU>0 then local lu=q(ar,0.4,2)local l9=LastMaxBrakeInAtmo*q(bt/100,0.1,1)*lu;local lv=aU*lu+l9-jb;local lw=l9/2-jb;local lx=bt-x(c(lw/2)*20/(0.5*av))*utils.sign(lw)if lx<0 then lx=0 end;local ly;if bt>100 then local lz,_=aT.computeDistanceAndTime(bt,100,av,0,0,l9)local lA,_=aT.computeDistanceAndTime(100,0,av,0,0,x(l9))ly=lz+lA else ly=aT.computeDistanceAndTime(bt,0,av,0,0,x(l9))end;if ly<20 then BrakeIsOn=false else local lB=0;if lx>100 then local lC,_=aT.computeDistanceAndTime(lx,100,av,0,0,lv)local lD,_=aT.computeDistanceAndTime(100,0,av,0,0,aU*lu+x(l9)-jb)lB=lC+lD else lB,_=aT.computeDistanceAndTime(lx,0,av,0,0,aU*lu+x(l9)-jb)end;lB=(lB+15+bt*kp)*1.1;local lE=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lE then local kw=planet:getAltitude(CustomTarget.position)local lF=as-kw-100;local kk=CustomTarget.position-bw;local lG=x(kk:len()^2-(as-kw)^2)if lG>100 then lE=false elseif lF<=lB or lB==-1 then BrakeIsOn=true;ls=true else BrakeIsOn=false;ls=true end end;if not lE and CalculateBrakeLandingSpeed then if lB>=lt then BrakeIsOn=true else BrakeIsOn=false end;ls=true end end end;if not bB then cf(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)stablized=true;k2=ao;if k2>-1 then b1=autoRollPreference;if bt<1 or bs:normalize():dot(bu)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bX("grOut","LG",1)end;r:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bs:normalize():dot(-h0)<0.999 then BrakeIsOn=true elseif bv<-brakeLandingRate and not ls then BrakeIsOn=true elseif not ls then BrakeIsOn=false end end;if AutoTakeoff or am then local bS,bU,bT;if AutopilotTargetCoords~=nil then bS,bU,bT=aS:getPlanetarySystem(0):castIntersections(bw,(AutopilotTargetCoords-bw):normalize(),function(bV)return bV.radius+bV.noAtmosphericDensityAltitude end)end;if bz then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cf(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kY)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bB and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bt<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cf(0)elseif am then cf(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(bS==nil or bS.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bB then cf(0)end;AutopilotAccelerating=true end end;local lH=ao>-1;local lI=bC;if(VectorToTarget or am or bK)and not lH and bt>minRollVelocity and ar>0.01 then local ln=math.rad(c(bD))lI=bC*c(math.cos(ln))+kr*math.sin(ln)end;local lJ=q(kY-lI,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then lJ=q(kY-lI,-85,MaxPitch)elseif ar<0.01 then lJ=q(kY-lI,-MaxPitch,MaxPitch)end;if c(bD)<5 or VectorToTarget or bK or BrakeLanding or lH or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lJ)local kZ=pitchPID:get()U=U+kZ end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=jY()return jP end;function script.onStart()local lK={}local lL={}local lM=false;local function lN()local function lO(lP)local lQ=dbHud_1.hasKey;for cG,cH in pairs(lP)do if lQ(cH)then local cY=f(dbHud_1.getStringValue(cH))if cY~=nil then _G[cH]=cY;lM=true end end end end;if dbHud_1 then if not useTheseSettings then lO(c2())coroutine.yield()lO(b)else lO(b)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;lM=false end;coroutine.yield()if lM then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b1=autoRollPreference;b8=AtmoSpeedLimit;ay=[[rgb(]]..d(H+0.5)..","..d(J+0.5)..","..d(I+0.5)..[[)]]az=[[rgb(]]..d(H*0.9+0.5)..","..d(J*0.9+0.5)..","..d(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<D then LastMaxBrakeInAtmo=0 end;LastStartTime=D;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function lR()local function lS(lT,lU)if lT>lU then lU=lT end;local lV,lW=0,0;if ContainerOptimization>0 then lV=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lW=FuelTankOptimization*0.05 end;lU=lU*(1-(lV+lW))return lU end;local lX=core.getElementNameById;local lY=fuelX~=0 and fuelY~=0;for cG in pairs(at)do local type=core.getElementTypeById(at[cG])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(at[cG])),'^.*vertical.*$')then by=true end end;if n(type,'^.*Space Engine$')then bm=true;if n(tostring(core.getElementTagsById(at[cG])),'^.*vertical.*$')then local lZ=core.getElementRotationById(at[cG])if lZ[4]<0 then if z(-lZ[4],0.1)==0.5 then bk=true end else if z(lZ[4],0.1)==0.5 then bl=true end end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local l_=h(at[cG])if l_>10000 then F=128;G=110 elseif l_>1000 then F=64;G=55 elseif l_>150 then F=32;G=27 end end;aL=aL+h(at[cG])if lY and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local l_=h(at[cG])local jh=k(at[cG])local lT=0;local gQ=o()if type=="Atmospheric Fuel Tank"then local lU=400;local m0=35.03;if l_>10000 then lU=51200;m0=5480 elseif l_>1300 then lU=6400;m0=988.67 elseif l_>150 then lU=1600;m0=182.67 end;lT=jh-m0;if fuelTankHandlingAtmo>0 then lU=lU+lU*fuelTankHandlingAtmo*0.2 end;lU=lS(lT,lU)aI[#aI+1]={at[cG],lX(at[cG]),lU,m0,lT,gQ}end;if type=="Rocket Fuel Tank"then local lU=320;local m0=173.42;if l_>65000 then lU=40000;m0=25740 elseif l_>6000 then lU=5120;m0=4720 elseif l_>700 then lU=640;m0=886.72 end;lT=jh-m0;if fuelTankHandlingRocket>0 then lU=lU+lU*fuelTankHandlingRocket*0.1 end;lU=lS(lT,lU)aK[#aK+1]={at[cG],lX(at[cG]),lU,m0,lT,gQ}end;if type=="Space Fuel Tank"then local lU=2400;local m0=182.67;if l_>10000 then lU=76800;m0=5480 elseif l_>1300 then lU=9600;m0=988.67 end;lT=jh-m0;if fuelTankHandlingSpace>0 then lU=lU+lU*fuelTankHandlingSpace*0.2 end;lU=lS(lT,lU)aJ[#aJ+1]={at[cG],lX(at[cG]),lU,m0,lT,gQ}end end end;if not by then VertTakeOff,VertTakeOffEngine=false,false end end;local function m1()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(aq or not aq and as<10000)then for _,cH in pairs(door)do cH.toggle()end end;if switch then for _,cH in pairs(switch)do cH.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cH in pairs(forcefield)do cH.toggle()end end;if antigrav then bz=antigrav.getState()==1;if bz and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and br:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(b2)if aq and ao~=-1 then aU=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function m2(m3,m4,m5,m6,ca,cb,m7,m8,m9,ma)local mb={enableName=m3,disableName=m4,width=m5,height=m6,x=ca,y=cb,toggleVar=m7,toggleFunction=m8,drawCondition=m9,hovered=false}if ma then table.insert(lL,mb)else table.insert(lK,mb)end;return mb end;local function mc(md)if not bE then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif md=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif md=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif md=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bF=c2(md)showHud=false else bF={}showHud=true end end;local function me()bE=not bE;if bE then aF=lL;a2="Hold SHIFT to see Settings"bG=showHud else aF=lK;a2="Hold SHIFT to see Control Buttons"mc()showHud=bG end end;local function mf(cH)_G[cH]=not _G[cH]if _G[cH]then a2=cH.." set to true"else a2=cH.." set to false"end;if cH=="showHud"then bG=_G[cH]elseif cH=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif cH=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function mg()local mh=50;local mi=340;local ca=500;local cb=aH/2-400;local mj=0;for cG,cH in pairs(c2("boolean"))do if type(_G[cH])=="boolean"then m2(cH,cH,mi,mh,ca,cb,function()return _G[cH]end,function()mf(cH)end,function()return true end,true)cb=cb+mh+20;if mj==9 then ca=ca+mi+20;cb=aH/2-400;mj=0 else mj=mj+1 end end end;m2("Control View","Control View",mi,mh,10,aH/2-500,function()return true end,me,function()return true end,true)m2("View Handling Settings",'Hide Handling Settings',mi,mh,10,aH/2-(500-mh),function()return showHandlingVariables end,function()mc("handling")end,function()return true end,true)m2("View Hud Settings",'Hide Hud Settings',mi,mh,10,aH/2-(500-mh*2),function()return showHudVariables end,function()mc("hud")end,function()return true end,true)m2("View Physics Settings",'Hide Physics Settings',mi,mh,10,aH/2-(500-mh*3),function()return showPhysicsVariables end,function()mc("physics")end,function()return true end,true)end;local function mk()local function jI()local position=bw;local fZ=planet.name..". "..#SavedLocations;if radar_1 then local dq,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dq~=nil and dq~=""then fZ=fZ.." "..radar_1.getConstructName(dq)end end;return aX.AddNewLocation(fZ,position,false,true)end;local function ml()TurnBurn=not TurnBurn end;local function mm(mn)if mn==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function mo()aX.UpdatePosition()end;local function jH()aX.ClearCurrentPosition()end;local function mp()local fZ=AutopilotTargetName;if fZ==nil then local il=cm((bw-CustomTarget.position):len())fZ=CustomTarget.name.." "..il end;if fZ==nil then fZ="None"end;return"Engage Autopilot: "..fZ end;local function mq()local fZ=AutopilotTargetName;if fZ==nil then fZ=CustomTarget.name end;if fZ==nil then fZ="None"end;return"Disable Autopilot: "..fZ end;local function mr()if l()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)bX("folOn","F")else bX("folOff","F")BrakeIsOn=true;b1=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local mh=50;local mi=260;local ms=m2("Enable Brake Toggle","Disable Brake Toggle",mi,mh,aG/2-mi/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)m2("Align Prograde","Disable Prograde",mi,mh,aG/2-mi/2-50-ms.width,aH/2-mh+380,function()return ProgradeIsOn end,function()mm(1)end)m2("Align Retrograde","Disable Retrograde",mi,mh,aG/2-mi/2+ms.width+50,aH/2-mh+380,function()return RetrogradeIsOn end,mm,function()return ar==0 end)local mt=m2(mp,mq,600,60,aG/2-600/2,aH/2-60/2-400,function()return Autopilot end,cs)m2("Save Position","Save Position",200,mt.height,mt.x+mt.width+30,mt.y,function()return false end,jI,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)m2("Update Position","Update Position",200,mt.height,mt.x+mt.width+30,mt.y,function()return false end,mo,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)m2("Clear Position","Clear Position",200,mt.height,mt.x-200-30,mt.y,function()return true end,jH,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mh=60;mi=300;local ca=10;local cb=aH/2-500;m2("Show Help","Hide Help",mi,mh,ca,cb,function()return showHelp end,function()showHelp=not showHelp end)cb=cb+mh+20;m2("View Settings","View Settings",mi,mh,ca,cb,function()return true end,me)local cb=aH/2-300;m2("Enable Turn and Burn","Disable Turn and Burn",mi,mh,ca,cb,function()return TurnBurn end,ml)m2("Horizontal Takeoff Mode","Vertical Takeoff Mode",mi,mh,ca+mi+20,cb,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return by end)cb=cb+mh+20;m2("Show Orbit Display","Hide Orbit Display",mi,mh,ca,cb,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a2="Orbit Display Enabled"else a2="Orbit Display Disabled"end end)m2("Engage Orbiting","Cancel Orbiting",mi,mh,ca+mi+20,cb,function()return IntoOrbit end,cq,function()return ar==0 and bM end)cb=cb+mh+20;m2("Glide Re-Entry","Cancel Glide Re-Entry",mi,mh,ca,cb,function()return Reentry end,function()al=1;mm(1)end,function()return planet.hasAtmosphere and not aq end)m2("Parachute Re-Entry","Cancel Parachute Re-Entry",mi,mh,ca+mi+20,cb,function()return Reentry end,cv,function()return planet.hasAtmosphere and not aq end)cb=cb+mh+20;m2("Engage Follow Mode","Disable Follow Mode",mi,mh,ca,cb,function()return a0 end,mr,function()return l()==1 end)m2("Enable Repair Arrows","Disable Repair Arrows",mi,mh,ca+mi+20,cb,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return l()==1 end)cb=cb+mh+20;if not ExternalAGG then m2("Enable AGG","Disable AGG",mi,mh,ca,cb,function()return bz end,cw,function()return antigrav~=nil end)end;m2(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,mi*2,mh,ca,cb,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)cb=cb+mh+20;m2(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,mi*2,mh,ca,cb,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lN()coroutine.yield()lR()coroutine.yield()aY=jO()m1()mg()mk()aF=lK;coroutine.yield()aN=cI()aR=cJ()aS=aR(cI())aT=e5()aV=ez()aZ=eX()aW=g8()aX=jv()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bX("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cH in pairs(door)do cH.toggle()end end;if switch then for _,cH in pairs(switch)do cH.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cH in pairs(forcefield)do cH.toggle()end end;cC()if button then button.activate()end;if SetWaypointOnExit then aY.showWayPoint(planet,bw)end;bX("stop","SU")end;function script.onTick(mu)local mv=nil;if mu=="contact"then if not contactTimer then contactTimer=0 end;if D>contactTimer+10 then a2="Radar Contact"bX("rdrCon","RC")contactTimer=D end;unit.stopTimer("contact")elseif mu=="tenthSecond"then local function mw()local mx=system.createData;local my=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=my(panelInterplanetary,"value")interplanetaryHeaderText=mx('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=my(panelInterplanetary,"value")widgetDistanceText=mx('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=my(panelInterplanetary,"value")widgetTravelTimeText=mx('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=my(panelInterplanetary,"value")widgetMaxMassText=mx('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=my(panelInterplanetary,"value")widgetTargetOrbitText=mx('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=my(panelInterplanetary,"value")widgetCurBrakeDistanceText=mx('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=my(panelInterplanetary,"value")widgetCurBrakeTimeText=mx('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=my(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mx('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=my(panelInterplanetary,"value")widgetMaxBrakeTimeText=mx('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=my(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mx('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mz()s(panelInterplanetary)panelInterplanetary=nil end;local function mA()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bw):len()else AutopilotDistance=(CustomTarget.position-bw):len()end end;local ex=bt;local l0=unit.getThrottle()/100;if AtmoSpeedAssist then l0=K end;local mB,mC=aT.computeDistanceAndTime(bt,MaxGameVelocity,av,a:maxForceForward()*l0,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aY.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aY.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mD;if not TurnBurn and ex>0 then _,mD=aY.GetAutopilotBrakeDistanceAndTime(ex)else _,mD=aY.GetAutopilotTBBrakeDistanceAndTime(ex)end;local mE=0;local mF=0;if AutopilotCruising or not Autopilot and ex>5 then mF=aT.computeTravelTime(ex,0,AutopilotDistance)elseif a8+mB<AutopilotDistance then mE=AutopilotDistance-(a8+mB)mF=aT.computeTravelTime(8333.0556,0,mE)else local mG=(AutopilotDistance-a8)/mB;mB=AutopilotDistance-a8;mC=mC*mG end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mF elseif AutopilotBraking then return mD elseif AutopilotCruising then return mF+mD else return mC+a9+mF end end;local function mH(jb,mI)if jb==nil then jb=core.g()end;jb=z(jb,5)if mI~=nil and mI or(mv==nil or mv~=jb)then local ex=br:len()local mJ=f(unit.getData()).maxBrake;if mJ~=nil and mJ>0 and aq then mJ=mJ/q(ex/100,0.1,1)mJ=mJ/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mJ)/2 else LastMaxBrakeInAtmo=mJ end end end;if mJ~=nil and mJ>0 then LastMaxBrake=mJ end;mv=jb end end;mH(nil,true)if bA~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bA then ci(bA,TRUE)else bA=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mw()end;if AutopilotTargetName~=nil then local mK=CustomTarget~=nil;local mL=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()mL=mL>1000000 and z(mL/1000000,2).." kTons"or z(mL/1000,2).." Tons"t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mA()if mK and not Autopilot then aj=(bw-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bw):len()end;if not TurnBurn then a8,a9=aY.GetAutopilotBrakeDistanceAndTime(bt)aa,ab=aY.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aY.GetAutopilotTBBrakeDistanceAndTime(bt)aa,ab=aY.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local il=cm(aj)t(widgetDistanceText,'{"label": "distance", "value": "'..il..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cx(travelTime)..'", "unit":""}')il=cm(a8)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..il..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cx(a9)..'", "unit":""}')il=cm(aa)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..il..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cx(ab)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..e("%s",mL)..'", "unit":""}')il=cm(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..il..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bB and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then cf(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mz()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aW.DrawTanks()if shield_1 then aW.DrawShield()end elseif mu=="oneSecond"then local function mM(gX)local mN=0;aD=""local mO=aL;local mP=0;local mQ=0;local mR=0;local gU=0;local gV=""local mS=core.getElementHitPointsById;for cG in pairs(at)do local l_=0;local mT=0;mT=h(at[cG])l_=mS(at[cG])mP=mP+l_;if l_<mT then if l_==0 then mR=mR+1 else mQ=mQ+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cG]))local ca=position.x-F;local cb=position.y-F;local fr=position.z-F;table.insert(aA,core.spawnArrowSticker(ca,cb,fr+1,"down"))table.insert(aA,core.spawnArrowSticker(ca,cb,fr+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(ca+1,cb,fr,"north"))table.insert(aA,core.spawnArrowSticker(ca+1,cb,fr,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(ca-1,cb,fr,"south"))table.insert(aA,core.spawnArrowSticker(ca-1,cb,fr,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(ca,cb-1,fr,"east"))table.insert(aA,core.spawnArrowSticker(ca,cb-1,fr,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(ca,cb+1,fr,"west"))table.insert(aA,core.spawnArrowSticker(ca,cb+1,fr,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cG])end elseif aM and#aA>0 and aA[11]==at[cG]then for gP in pairs(aA)do core.deleteSticker(aA[gP])end;aA={}end end;mN=d(mP/mO*100)if mN<100 then gX[#gX+1]=c9(0,0,"","pbright txt")gU=d(mN*2.55)gV=e("rgb(%d,%d,%d)",255-gU,gU,0)if mN<100 then gX[#gX+1]=c9("50%",1035,"Elemental Integrity: "..mN.."%","txtbig txtmid","fill:"..gV)if mR>0 then gX[#gX+1]=c9("50%",1055,"Disabled Modules: "..mR.." Damaged Modules: "..mQ,"txtbig txtmid","fill:"..gV)elseif mQ>0 then gX[#gX+1]=c9("50%",1055,"Damaged Modules: "..mQ,"txtbig txtmid","fill:"..gV)end end end end;local function mU()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function mV()local gQ=o()local i8=bt;local mW=gQ-au;if i8>1.38889 then i8=i8/1000;local mX=i8*(gQ-au)TotalDistanceTravelled=TotalDistanceTravelled+mX;ad=ad+mX end;ae=ae+mW;TotalFlightTime=TotalFlightTime+mW;au=gQ end;mV()aW.UpdatePipe()mU()local gX={}aW.ExtraData(gX)if ShowOdometer then gX=aW.DrawOdometer(gX,ad,TotalDistanceTravelled,ae)end;if ShouldCheckDamage then mM(gX)end;ak=table.concat(gX,"")collectgarbage("collect")elseif mu=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cY=f(dbHud_1.getStringValue("SavedLocations"))if cY~=nil then _G["SavedLocations"]=cY;local fK=-1;local jL;for cG,cH in pairs(SavedLocations)do if cH.name and cH.name=="SatNav Location"then fK=cG;break end end;if fK~=-1 then jL=SavedLocations[fK]fK=-1;for cG,cH in pairs(aN[0])do if cH.name and cH.name=="SatNav Location"then fK=cG;break end end;if fK>-1 then aN[0][fK]=jL end;aX.UpdateAtlasLocationsList()a2=jL.name.." position updated"end end;for i=1,#bH do if bH[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bH[i].name)aX.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mu=="msgTick"then local gX={}aW.DisplayMessage(gX,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif mu=="animateTick"then b0=true;a_=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif mu=="hudTick"then local function mY(gX)local mZ=d(q(aj/(aG/4)*255,0,255))gX[#gX+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,d(H+0.5)+mZ,d(J+0.5)-mZ,d(I+0.5)-mZ)end;local function m_()for _,cH in pairs(aF)do if cH.hovered then if not cH.drawCondition or cH.drawCondition()then cH.toggleFunction()end;cH.hovered=false end end end;local function n0()local function n1(n2,n3,ca,cb,m5,m6)if n2>ca and n2<ca+m5 and n3>cb and n3<cb+m6 then return true else return false end end;local ca=ag+aG/2;local cb=ah+aH/2;for _,cH in pairs(aF)do cH.hovered=n1(ca,cb,cH.x,cH.y,cH.width,cH.height)end end;local function n4(gX)local function n5(gX,n6,hover,ca,cb,eq,n7,n8,n9,na,nb)if type(na)=="function"then na=na()end;if type(nb)=="function"then nb=nb()end;gX[#gX+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",ca,cb,eq,n7)if n6 then gX[#gX+1]=e("%s'",n8)else gX[#gX+1]=n9 end;if hover then gX[#gX+1]=" style='stroke:white; stroke-width:2'"else gX[#gX+1]=" style='stroke:black; stroke-width:1'"end;gX[#gX+1]="></rect>"gX[#gX+1]=e("<text x='%f' y='%f' font-size='24' fill='",ca+eq/2,cb+n7/2+5)if n6 then gX[#gX+1]="black"else gX[#gX+1]="white"end;gX[#gX+1]="' text-anchor='middle' font-family='Montserrat'>"if n6 then gX[#gX+1]=e("%s</text>",na)else gX[#gX+1]=e("%s</text>",nb)end end;local nc="rgb(50,50,50)'"local nd="rgb(210,200,200)"local ne=n5;for _,cH in pairs(aF)do local m4=cH.disableName;local m3=cH.enableName;if type(m4)=="function"then m4=m4()end;if type(m3)=="function"then m3=m3()end;if not cH.drawCondition or cH.drawCondition()then ne(gX,cH.toggleVar(),cH.hovered,cH.x,cH.y,cH.width,cH.height,nd,nc,m4,m3)end end end;local nf=z(ResolutionX/2,0)local ng=z(ResolutionY/2,0)local gX={}aW.HUDPrologue(gX)if showHud then aW.UpdateHud(gX)else if AlwaysVSpd then aW.DrawVerticalSpeed(gX,as)end;aW.DisplayOrbitScreen(gX)aW.DrawWarnings(gX)end;if bE and bF~={}then aW.DrawSettings(gX)end;if radar_1 then aW.DrawRadarInfo()end;aW.HUDEpilogue(gX)gX[#gX+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aW.DisplayMessage(gX,a2)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aW.DrawDeadZone(gX)end end;if w()==0 then if l()==1 and a1 then if not AltIsOn then n0()n4(gX)end;if not a_ and not b0 then local nh=table.concat(gX,"")gX={}gX[#gX+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gX[#gX+1]=nh;gX[#gX+1]="</body>"a_=true;gX[#gX+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gX,"")system.setScreen(content)elseif b0 then local nh=table.concat(gX,"")gX={}gX[#gX+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gX[#gX+1]=nh;gX[#gX+1]="</body>"end;if not a_ then gX[#gX+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nf,ng,ag,ah)end else m_()end else if not a1 and l()==0 then m_()if aj>DeadZone then if DisplayDeadZone then mY(gX)end end elseif not AltIsOn or AltIsOn and a1 then n0()n4(gX)end;gX[#gX+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nf,ng,ag,ah)end;gX[#gX+1]=[[</svg></body>]]content=table.concat(gX,"")elseif mu=="apTick"then aY.APTick()elseif mu=="radarTick"then aZ.UpdateRadar()elseif mu=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function ni(nj,l7)local nk=vec3()local nl=vec3()if nj==axisCommandId.longitudinal then nk=vec3(core.getConstructOrientationForward())nl=bp elseif nj==axisCommandId.vertical then nk=vec3(core.getConstructOrientationUp())nl=bo elseif nj==axisCommandId.lateral then nk=vec3(core.getConstructOrientationRight())nl=bq else return vec3()end;local nm=vec3(core.getWorldGravity())local nn=nm:dot(nl)local no=vec3(core.getWorldAirFrictionAcceleration())local np=no:dot(nl)local nq=br:dot(nk)local nr=l7*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nr-nq)local ns=targetSpeedPID2:get()local nt=(ns-np-nn)*nl;return nt end;local function nu(nj,l7)local nk=vec3()local nl=vec3()if nj==axisCommandId.longitudinal then nk=vec3(core.getConstructOrientationForward())nl=bp elseif nj==axisCommandId.vertical then nk=vec3(core.getConstructOrientationUp())nl=bo elseif nj==axisCommandId.lateral then nk=vec3(core.getConstructOrientationRight())nl=bq else return vec3()end;local nm=vec3(core.getWorldGravity())local nn=nm:dot(nl)local no=vec3(core.getWorldAirFrictionAcceleration())local np=no:dot(nl)local nq=br:dot(nk)local nr=l7*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nr-nq)local ns=targetSpeedPID:get()local nt=(ns-np-nn)*nl;return nt end;local function nw(nx,g_,jA)local ny=nx:cross(jA):normalize_inplace()local hM=math.acos(q(ny:dot(-g_),-1,1))*constants.rad2deg;if ny:cross(-g_):dot(jA)<0 then hM=-hM end;return hM end;if antigrav and not ExternalAGG then if not bz and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bB=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bB and O then cf(0)O=false elseif not bB and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local nz=q(T+U+system.getControlDeviceForwardInput(),-1,1)local nA=q(W+Z+system.getControlDeviceYawInput(),-1,1)local nB=q(X+V-system.getControlDeviceLeftRightInput(),-1,1)local nC=Y;bu=vec3(core.getWorldVertical())if bu==nil or bu:len()==0 then bu=(planet.center-bw):normalize()end;bo=vec3(core.getConstructWorldOrientationUp())bp=vec3(core.getConstructWorldOrientationForward())bq=vec3(core.getConstructWorldOrientationRight())bs=vec3(core.getWorldVelocity())br=vec3(core.getVelocity())bw=vec3(core.getConstructWorldPos())av=core.getConstructMass()bt=vec3(bs):len()bv=-bu:dot(bs)bD=getRoll(bu,bp,bq)local nD=bD/180*math.pi;local nE=math.cos(nD)local nF=math.sin(nD)bC=nw(bu,bp,bq*nE+bo*nF)local nG=bs:normalize()local nH=c(bD)local nI=utils.sign(bD)local nJ=vec3(core.getWorldAngularVelocity())local nK=nz*pitchSpeedFactor*bq+nA*rollSpeedFactor*bp+nB*yawSpeedFactor*bo;if b1==true and bu:len()>0.01 then local nL=c(b5-bD)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and nL>0 or ar>0.0 and nL<autoRollRollThreshold and autoRollPreference)and nA==0 and c(bC)<85 then local nM=b5;local nN=autoRollFactor;if ar==0 then nN=nN/4;b5=0;nM=0 end;if rollPID==nil then rollPID=pid.new(nN*0.01,0,nN*0.1)end;rollPID:inject(nM-bD)local nO=rollPID:get()nK=nK+nO*bp end end;local nP=1;local nQ=0;local nR=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then b8=q(b8+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nS=K;K=z(q(K+speedChangeLarge/100,-1,1),2)if K>=0 and nS<0 then K=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then b8=q(b8-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nS=K;K=z(q(K-speedChangeLarge/100,-1,1),2)if K<=0 and nS>0 then K=0;aw=false end end else aw=true end;L=0;if aq and AtmoSpeedAssist and bB then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b8/3.6-bs:dot(bp))local nT=throttlePID:get()N=q(nT,-1,1)if N<K and ar>0.005 then M=true;r:setThrottleCommand(axisCommandId.longitudinal,q(N,0.01,1))else M=false;r:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bs:len()-b8/3.6)local nU=q(brakePID:get(),0,1)if ar>0 and bv<-80 or ar>0.005 then L=nU end;if L>0 then if M and N==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else N=q(N,0.01,1)end;local nV=''local nW=vec3()local nX=ni(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",nX,nQ)local nY='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then nY=nY..ExtraLongitudeTags end;local nZ=r:getAxisCommandType(axisCommandId.longitudinal)local n_=r:composeAxisAccelerationFromThrottle(nY,axisCommandId.longitudinal)local o0=nu(axisCommandId.lateral,LeftAmount*1000)nV=nV..' , '.."lateral airfoil , lateral ground "nW=nW+o0;if nW:len()>constants.epsilon then a:setEngineForceCommand(nV,nW,nQ,'','','',nR)end;a:setEngineForceCommand(nY,n_,nP)local o1='thrust analog vertical fueled 'local o2='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then o2=o2 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then o1=o1 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(o1,nX,nP)else a:setEngineForceCommand(o1,vec3(),nP)end;if LeftAmount~=0 then a:setEngineForceCommand(o2,o0,nP)else a:setEngineForceCommand(o2,vec3(),nP)end;if nC==0 then nC=L end;local o3=-nC*(brakeSpeedFactor*bs+brakeFlatFactor*nG)a:setEngineForceCommand('brake',o3)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,K)end;local l7=unit.getAxisCommandValue(0)if not bB then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bs:len()-l7/3.6)local nU=q(brakePID:get(),0,1)nC=q(nC+nU,0,1)end;local o3=-nC*(brakeSpeedFactor*bs+brakeFlatFactor*nG)a:setEngineForceCommand('brake',o3)local nV=''local nW=vec3()local o4=false;local nY='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then nY=nY..ExtraLongitudeTags end;local nZ=r:getAxisCommandType(axisCommandId.longitudinal)if nZ==axisCommandType.byThrottle then local n_=r:composeAxisAccelerationFromThrottle(nY,axisCommandId.longitudinal)a:setEngineForceCommand(nY,n_,nP)elseif nZ==axisCommandType.byTargetSpeed then local n_=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)nV=nV..' , '..nY;nW=nW+n_;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then o4=true end end;local o2='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then o2=o2 ..ExtraLateralTags end;local o5=r:getAxisCommandType(axisCommandId.lateral)if o5==axisCommandType.byThrottle then local o6=r:composeAxisAccelerationFromThrottle(o2,axisCommandId.lateral)a:setEngineForceCommand(o2,o6,nP)elseif o5==axisCommandType.byTargetSpeed then local o0=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)nV=nV..' , '..o2;nW=nW+o0 end;local o1='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then o1=o1 ..ExtraVerticalTags end;local o7=r:getAxisCommandType(axisCommandId.vertical)if o7==axisCommandType.byThrottle then local nX=r:composeAxisAccelerationFromThrottle(o1,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(o1,nX,nP,'airfoil','ground','',nR)else a:setEngineForceCommand(o1,vec3(),nP)a:setEngineForceCommand('airfoil vertical',nX,nP,'airfoil','','',nR)a:setEngineForceCommand('ground vertical',nX,nP,'ground','','',nR)end elseif o7==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),nP)end;local o8=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)nV=nV..' , '..o1;nW=nW+o8 end;if nW:len()>constants.epsilon then if Y~=0 or o4 or c(nG:dot(bp))<0.8 then nV=nV..', brake'end;a:setEngineForceCommand(nV,nW,nQ,'','','',nR)end end;local o9=torqueFactor*(nK-nJ)local oa=vec3(core.getWorldAirFrictionAngularAcceleration())o9=o9-oa;a:setEngineTorqueCommand('torque',o9,nP,'airfoil','','',nR)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local ex=br:len()local ob=0.15;if not bB then local oc=r:getTargetSpeed(axisCommandId.longitudinal)if ex*3.6>oc*(1-ob)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ex*3.6<oc*(1-ob)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local l0=unit.getThrottle()if AtmoSpeedAssist then l0=K*100 end;local l7=l0/100;if j==0 then l7=l7*MaxGameVelocity;if ex>=l7*(1-ob)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ex<l7*(1-ob)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local li=d(b8)l7=l7*li/3.6;if ex>=l7*(1-ob)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ex<l7*(1-ob)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g5=coroutine.status(beginSetup)if g5=="suspended"then local cg,g6=coroutine.resume(beginSetup)if g6 then system.print("ERROR STARTUP: "..g6)end elseif g5=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not a_ and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(od)local function oe(of)local C=1;local function og(oh,of)local oi={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local oj=oh;for _,cH in ipairs(oi)do if of and oj>cH then oh=cH elseif oh<cH and not of then oh=cH;break end end;return oh end;if of then C=-1 end;if not ExternalAGG and bz then if a1 and of then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+C*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bh=og(bh,of)else bh=bh+C*a3 end;if bh<planet.noAtmosphericDensityAltitude then bh=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=og(HoldAltitude,of)else HoldAltitude=HoldAltitude+C*a3 end end else r:updateTargetGroundAltitudeFromActionStart(C*1.0)end end;local function ok(of)local C=1;if of then C=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=q(K+C*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,C*speedChangeLarge)end else if of then C=1 else C=nil end;aX.adjustAutopilotTargetIndex(C)end end;local function ol(om)if not aq then a2="Flight Assist in Atmo only"return end;local cO=type(om)if bK==nil then if cO=="table"then if Autopilot or VectorToTarget then cs()end;bX("180On","BR")elseif om==1 then bX("bnkLft","BR")else bX("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cr()if cO~="table"then om=om+1 end end;bK=om else bX("180Off","BR")bK=nil end end;if od=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cf(0)if vBooster or hover then if aq and ao==-1 then bX("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b1=true;GearExtended=false else if S then bX("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bX("grOut","LG",1)a.control.extendLandingGears()end else if S then bX("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif od=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif od=="forward"then T=T-1 elseif od=="backward"then if AltIsOn then ol(-bs*5000)else T=T+1 end elseif od=="left"then if AltIsOn then ol(1)else W=W-1 end elseif od=="right"then if AltIsOn then ol(3)else W=W+1 end elseif od=="yawright"then X=X-1 elseif od=="yawleft"then X=X+1 elseif od=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif od=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif od=="up"then af=af+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif od=="down"then af=af-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif od=="groundaltitudeup"then oe()elseif od=="groundaltitudedown"then oe(true)elseif od=="option1"then aX.adjustAutopilotTargetIndex()toggleView=false elseif od=="option2"then aX.adjustAutopilotTargetIndex(1)toggleView=false elseif od=="option3"then local function on()aE=not aE;if not aE then bX("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if shield_1~=nil then shield_1.show()end else bX("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;on()toggleView=false elseif od=="option4"then bK=nil;cs()toggleView=false elseif od=="option5"then if AltIsOn and a1 and shield_1 then shield_1.toggle()toggleView=false;return end;function ToggleLockPitch()if LockPitch==nil then bX("lkPOn","LP")if not a1 then LockPitch=bC else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bX("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif od=="option6"then cr()toggleView=false elseif od=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end;toggleView=false elseif od=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()bX("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bX("gsOn","GS")end;toggleView=false elseif od=="option9"then if AltIsOn and a1 then r:resetCommand(axisCommandId.longitudinal)r:resetCommand(axisCommandId.lateral)r:resetCommand(axisCommandId.vertical)cf(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bX("gyOn","GA")else bX("gyOff","GA")end end;toggleView=false elseif od=="lshift"then if AltIsOn then a1=true end;if w()==1 then a1=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then a1=true;b0=false;a_=false end elseif od=="brake"then if BrakeToggleStatus then cu()elseif not BrakeIsOn then cu()else BrakeIsOn=true end elseif od=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif od=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif od=="stopengines"then local function oo()if D-E<1.5 then bX("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b1=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;oo()E=D;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then r:resetCommand(axisCommandId.longitudinal)cf(0)else cf(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if aq then ci(AtmoSpeedLimit)else ci(MaxGameVelocity*3.6)end end end elseif od=="speedup"then ok()elseif od=="speeddown"then ok(true)elseif od=="antigravity"and not ExternalAGG then if antigrav~=nil then cw()end end end;function script.onActionStop(od)local function op()if not ExternalAGG and bz then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if od=="forward"then T=0 elseif od=="backward"then T=0 elseif od=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif od=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif od=="yawright"then X=0 elseif od=="yawleft"then X=0 elseif od=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif od=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif od=="up"then af=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif od=="down"then af=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif od=="groundaltitudeup"then op()toggleView=false elseif od=="groundaltitudedown"then op()toggleView=false elseif od=="lshift"then if w()==1 then ag=0;ah=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then b0=false;a_=false end;a1=false elseif od=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cu()else BrakeIsOn=false end end elseif od=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(od)local function oq(of)local C=1;if of then C=-1 end;if not ExternalAGG and bz then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=q(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+C*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bh=bh+C*a5;if bh<planet.noAtmosphericDensityAltitude then bh=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+C*a5 end;a5=q(a5*1.05,a3,50)else r:updateTargetGroundAltitudeFromActionLoop(C*1.0)end end;local function os(of)local C=1;if of then C=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=q(K+C*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,C*speedChangeSmall)end end end;if od=="groundaltitudeup"then if not a1 then oq()end elseif od=="groundaltitudedown"then if not a1 then oq(true)end elseif od=="speedup"then os()elseif od=="speeddown"then os(true)end end;function script.onInputText(cc)local function ot()for cG,cH in pairs(c2())do dbHud_1.setStringValue(cH,g(nil))end;for cG,cH in pairs(b)do if cH~="SavedLocations"then dbHud_1.setStringValue(cH,g(nil))end end;a2="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5 end;local function ou(ov,eB,hI)local function ow(eB)local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cW='::pos{'..A..','..A..','..A..','..A..','..A..'}'local d8,d9,df,dg,dh=n(eB,cW)if d8=="0"and d9=="0"then return vec3(y(df),y(dg),y(dh))end;dg=math.rad(dg)df=math.rad(df)local planet=aN[y(d8)][y(d9)]local e2=math.cos(df)local ox=vec3(e2*math.cos(dg),e2*math.sin(dg),math.sin(df))return planet.center+(planet.radius+dh)*ox end;local position=ow(eB)return aX.AddNewLocation(ov,position,hI)end;local i;local oy,oz=nil,nil;local oA="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cc," ")oy=cc;if i~=nil then oy=string.sub(cc,0,i-1)oz=string.sub(cc,i+1)end;if oy=="/help"or oy=="/commands"then for jj in string.gmatch(oA,"([^\n]+)")do system.print(jj)end;return elseif oy=="/setname"then if oz==nil or oz==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aX.UpdatePosition(oz)else a2="Select a saved target to rename first"end elseif oy=="/addlocation"or string.find(cc,"::pos")~=nil then local hI=false;local ov="0-Temp"if oz==nil or oz==""then oz=oy;hI=true end;i=string.find(oz,"::")if not hI then ov=string.sub(oz,1,i-2)end;local eB=string.sub(oz,i)ou(ov,eB,hI)elseif oy=="/agg"then if oz==nil or oz==""then a2="Usage: /agg targetheight"return end;oz=y(oz)if oz<1000 then oz=1000 end;AntigravTargetAltitude=oz;a2="AGG Target Height set to "..oz elseif oy=="/G"then if oz==nil or oz==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oz=="dump"then for cG,cH in pairs(c2())do if type(_G[cH])=="boolean"then if _G[cH]==true then system.print(cH.." true")else system.print(cH.." false")end elseif _G[cH]==nil then system.print(cH.." nil")else system.print(cH.." ".._G[cH])end end;return end;i=string.find(oz," ")local oB=string.sub(oz,0,i-1)local oC=string.sub(oz,i+1)for cG,cH in pairs(c2())do if cH==oB then a2="Variable "..oB.." changed to "..oC;local oD=type(_G[cH])if oD=="number"then oC=y(oC)elseif oD=="boolean"then if string.lower(oC)=="true"then oC=true else oC=false end end;_G[cH]=oC;return end end;a2="No such global variable: "..oB elseif oy=="/copydatabank"then if dbHud_2 then cC(true)else a2="Spare Databank required to copy databank"end elseif oy=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aY.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(dq)if radar_1 and not aq and not bI then unit.setTimer("contact",0.1)end end;function script.onLeave(dq)if radar_1 and CollisionSystem then if#bL>650 then dq=tostring(dq)bL[dq]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
