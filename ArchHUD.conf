name: ArchHud - Archaegeo v0.7071 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.7071;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=true;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(K)t=K end,get=function()return t end},AtmoSpeedAssist={set=function(K)u=K end,get=function()return u end},ForceAlignment={set=function(K)v=K end,get=function()return v end},DisplayDeadZone={set=function(K)w=K end,get=function()return w end},showHud={set=function(K)x=K end,get=function()return x end},hideHudOnToggleWidgets={set=function(K)y=K end,get=function()return y end},ShiftShowsRemoteButtons={set=function(K)z=K end,get=function()return z end},SetWaypointOnExit={set=function(K)A=K end,get=function()return A end},AlwaysVSpd={set=function(K)B=K end,get=function()return B end},BarFuelDisplay={set=function(K)C=K end,get=function()return C end},voices={set=function(K)D=K end,get=function()return D end},alerts={set=function(K)E=K end,get=function()return E end},CollisionSystem={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end}}a8=1920;a9=1080;aa=400;ab=130;ac=224;ad=255;ae=255;af=0;ag=0;ah=960;ai=540;aj=1300;ak=540;al=1525;am=325;an=550;ao=540;ap=30;aq=700;ar=1750;as=250;at=50;au=250;av=0;aw=30;ax=100;ay={ResolutionX={set=function(K)a8=K end,get=function()return a8 end},ResolutionY={set=function(K)a9=K end,get=function()return a9 end},circleRad={set=function(K)aa=K end,get=function()return aa end},SafeR={set=function(K)ab=K end,get=function()return ab end},SafeG={set=function(K)ac=K end,get=function()return ac end},SafeB={set=function(K)ad=K end,get=function()return ad end},PvPR={set=function(K)ae=K end,get=function()return ae end},PvPG={set=function(K)af=K end,get=function()return af end},PvPB={set=function(K)ag=K end,get=function()return ag end},centerX={set=function(K)ah=K end,get=function()return ah end},centerY={set=function(K)ai=K end,get=function()return ai end},throtPosX={set=function(K)aj=K end,get=function()return aj end},throtPosY={set=function(K)ak=K end,get=function()return ak end},vSpdMeterX={set=function(K)al=K end,get=function()return al end},vSpdMeterY={set=function(K)am=K end,get=function()return am end},altMeterX={set=function(K)an=K end,get=function()return an end},altMeterY={set=function(K)ao=K end,get=function()return ao end},fuelX={set=function(K)ap=K end,get=function()return ap end},fuelY={set=function(K)aq=K end,get=function()return aq end},shieldX={set=function(K)ar=K end,get=function()return ar end},shieldY={set=function(K)as=K end,get=function()return as end},DeadZone={set=function(K)at=K end,get=function()return at end},OrbitMapSize={set=function(K)au=K end,get=function()return au end},OrbitMapX={set=function(K)av=K end,get=function()return av end},OrbitMapY={set=function(K)aw=K end,get=function()return aw end},soundVolume={set=function(K)ax=K end,get=function()return ax end}}az=5;aA=1;aB=0.003;aC=0.003;aD=2;aE=1.5;aF=180;aG=150;aH=0.002;aI=2;aJ=0.8;aK=1;aL=3;aM=1;aN=40;aO=0.0166667;aP=0.0666667;aQ="none"aR="none"aS="none"aT={speedChangeLarge={set=function(K)az=K end,get=function()return az end},speedChangeSmall={set=function(K)aA=K end,get=function()return aA end},MouseXSensitivity={set=function(K)aB=K end,get=function()return aB end},MouseYSensitivity={set=function(K)aC=K end,get=function()return aC end},autoRollFactor={set=function(K)aD=K end,get=function()return aD end},rollSpeedFactor={set=function(K)aE=K end,get=function()return aE end},autoRollRollThreshold={set=function(K)aF=K end,get=function()return aF end},minRollVelocity={set=function(K)aG=K end,get=function()return aG end},TrajectoryAlignmentStrength={set=function(K)aH=K end,get=function()return aH end},torqueFactor={set=function(K)aI=K end,get=function()return aI end},pitchSpeedFactor={set=function(K)aJ=K end,get=function()return aJ end},yawSpeedFactor={set=function(K)aK=K end,get=function()return aK end},brakeSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeFlatFactor={set=function(K)aM=K end,get=function()return aM end},DampingMultiplier={set=function(K)aN=K end,get=function()return aN end},apTickRate={set=function(K)aO=K end,get=function()return aO end},hudTickRate={set=function(K)aP=K end,get=function()return aP end},ExtraLongitudeTags={set=function(K)aQ=K end,get=function()return aQ end},ExtraLateralTags={set=function(K)aR=K end,get=function()return aR end},ExtraVerticalTags={set=function(K)aS=K end,get=function()return aS end}}aU=j;aV=false;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=1000;b6=false;b7=false;b8=false;b9=false;ba=0;bb="Aligning"bc=0;bd=1;be="None"bf=nil;bg=0;bh=nil;bi=0.0;bj=0;bk={}bl=false;bm=0;bn=0;bo=nil;bp=0;bq=1000;br=0;bs=false;bt=0;bu=false;bv="All"bw=true;bx="Off"by=0.000;bz={}bA={VertTakeOff={set=function(K)b4=K end,get=function()return b4 end},VertTakeOffEngine={set=function(K)aV=K end,get=function()return aV end},SpaceTarget={set=function(K)bs=K end,get=function()return bs end},BrakeToggleStatus={set=function(K)aU=K end,get=function()return aU end},BrakeIsOn={set=function(K)aW=K end,get=function()return aW end},RetrogradeIsOn={set=function(K)aX=K end,get=function()return aX end},ProgradeIsOn={set=function(K)aY=K end,get=function()return aY end},Autopilot={set=function(K)aZ=K end,get=function()return aZ end},TurnBurn={set=function(K)a_=K end,get=function()return a_ end},AltitudeHold={set=function(K)b0=K end,get=function()return b0 end},BrakeLanding={set=function(K)b1=K end,get=function()return b1 end},Reentry={set=function(K)b3=K end,get=function()return b3 end},AutoTakeoff={set=function(K)b2=K end,get=function()return b2 end},HoldAltitude={set=function(K)b5=K end,get=function()return b5 end},AutopilotAccelerating={set=function(K)b6=K end,get=function()return b6 end},AutopilotBraking={set=function(K)b8=K end,get=function()return b8 end},AutopilotCruising={set=function(K)b9=K end,get=function()return b9 end},AutopilotRealigned={set=function(K)b7=K end,get=function()return b7 end},AutopilotEndSpeed={set=function(K)ba=K end,get=function()return ba end},AutopilotStatus={set=function(K)bb=K end,get=function()return bb end},AutopilotPlanetGravity={set=function(K)bc=K end,get=function()return bc end},PrevViewLock={set=function(K)bd=K end,get=function()return bd end},AutopilotTargetName={set=function(K)be=K end,get=function()return be end},AutopilotTargetCoords={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetIndex={set=function(K)bg=K end,get=function()return bg end},TotalDistanceTravelled={set=function(K)bi=K end,get=function()return bi end},TotalFlightTime={set=function(K)bj=K end,get=function()return bj end},SavedLocations={set=function(K)bk=K end,get=function()return bk end},VectorToTarget={set=function(K)bl=K end,get=function()return bl end},LocationIndex={set=function(K)bm=K end,get=function()return bm end},LastMaxBrake={set=function(K)bn=K end,get=function()return bn end},LockPitch={set=function(K)bo=K end,get=function()return bo end},LastMaxBrakeInAtmo={set=function(K)bp=K end,get=function()return bp end},AntigravTargetAltitude={set=function(K)bq=K end,get=function()return bq end},LastStartTime={set=function(K)br=K end,get=function()return br end},iphCondition={set=function(K)bv=K end,get=function()return bv end},stablized={set=function(K)bw=K end,get=function()return bw end},UseExtra={set=function(K)bx=K end,get=function()return bx end},SelectedTab={set=function(K)bB=K end,get=function()return bB end},saveRoute={set=function(K)bz=K end,get=function()return bz end}}local function bC(a,b,c,bD,bE,bF)bG=bD()bH=ab;bI=ad;bJ=ac;bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=false;bR=false;bS=0;bT=0;bU=0;bV=0;bW=0;bX=0;bY=0;bZ=false;b_=false;bZ=false;b_=false;c0="empty"c1=false;c2=0;c3=0;c4=nil;c5=0;c6=0;c7=0;c8=0;c9=0;ca=3;cb=0;cc=""cd=false;ce=false;cf=false;cg=-1;ch=bF()>0;ci=bF()cj=b.getAltitude()ck=bD()cl=b.getConstructMass()cm=false;cn=nil;co=[[rgb(]]..bE(bH+0.5)..","..bE(bJ+0.5)..","..bE(bI+0.5)..[[)]]cp=[[rgb(]]..bE(bH*0.9+0.5)..","..bE(bJ*0.9+0.5)..","..bE(bI*0.9+0.5)..[[)]]cq=""cr=a8;cs=a9;ct={}cu={}cv={}cw=false;cx=nil;cy=nil;cz=nil;cA=nil;cB=nil;cC=nil;cD=nil;cE=nil;cF=nil;cG=false;cH=false;cI=p;cJ=false;cK=0;cL=U;cM=0;cN=nil;cO={VectorToTarget=false}cP=0;cQ=false;cR=false;cS=false;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cW=vec3(b.getVelocity())cX=vec3(b.getWorldVelocity())cY=vec3(cX):len()cZ=vec3(b.getWorldVertical())c_=-cZ:dot(cX)d0=vec3(b.getConstructWorldPos())d1=false;d2=false;d3=nil;d4=true;d5=0;d6=0;d7={}d8=false;d9=50000;da=nil;db={}dc=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;dd=false;de=nil;df=false;dg=0;dh=nil;di=nil;dj={}dk=90;dl=x end;local function dm(d,b,c,a,dn,dp,dq,dr,ds)local function dt(du)return type(du)=='number'end;local function dv(du)return type(dq(du))=='number'end;local function dw(dx)return type(dx)=='table'end;local function dy(a)return type(a)=='string'end;local function dz(dA)return dw(dA)and dt(dA.x and dA.y and dA.z)end;local function dB(dC)return dw(dC)and dt(dC.latitude and dC.longitude and dC.altitude and dC.id and dC.systemId)end;local dD=math.pi/180;local dE=180/math.pi;local dF=1e-10;local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH='::pos{'..dG..','..dG..','..dG..','..dG..','..dG..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function dI(du)local dJ=string.gsub(string.reverse(dn('%.4f',du)),'^0*%.?','')return dJ==''and'0'or string.reverse(dJ)end;local function dK(dL)if dz(dL)then return dn('{x=%.3f,y=%.3f,z=%.3f}',dL.x,dL.y,dL.z)end;if dw(dL)and not getmetatable(dL)then local dM={}local dN=next(dL)if type(dN)=='nil'or dN==1 then dM=dL else for dO,dA in pairs(dL)do local dP=dK(dA)if type(dO)=='number'then table.insert(dM,dn('[%s]=%s',dO,dP))else table.insert(dM,dn('%s=%s',dO,dP))end end end;return dn('{%s}',table.concat(dM,','))end;if dy(dL)then return dn("'%s'",dL:gsub("'",[[\']]))end;return tostring(dL)end;local dQ={}dQ.__index=dQ;dQ.__tostring=function(dL,dR)local dS={}for dO in pairs(dL)do table.insert(dS,dO)end;table.sort(dS)local dM={}for dT,dO in ipairs(dS)do local dP=dK(dL[dO])if type(dO)=='number'then table.insert(dM,dn('[%s]=%s',dO,dP))else table.insert(dM,dn('%s=%s',dO,dP))end end;if dR then return dn('%s%s',dR,table.concat(dM,',\n'..dR))end;return dn('{%s}',table.concat(dM,','))end;dQ.__eq=function(dU,dV)return dU.systemId==dV.systemId and dU.id==dV.id and ds(dU.radius,dV.radius)and ds(dU.center.x,dV.center.x)and ds(dU.center.y,dV.center.y)and ds(dU.center.z,dV.center.z)and ds(dU.GM,dV.GM)end;local function dW(dX,dY,dZ,d_,e0)assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(dZ),'Argument 3 (radius) must be a number:'..type(dZ))assert(dw(d_),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(d_))assert(dv(e0),'Argument 5 (GM) must be a number:'..type(e0))return setmetatable({systemId=dq(dX),id=dq(dY),radius=dq(dZ),center=vec3(d_),GM=dq(e0)},dQ)end;local e1={}e1.__index=e1;e1.__tostring=function(e2)return dn('::pos{%d,%d,%s,%s,%s}',e2.systemId,e2.id,dI(e2.latitude*dE),dI(e2.longitude*dE),dI(e2.altitude))end;e1.__eq=function(dU,dV)return dU.id==dV.id and dU.systemId==dV.systemId and ds(dU.latitude,dV.latitude)and ds(dU.altitude,dV.altitude)and(ds(dU.longitude,dV.longitude)or ds(dU.latitude,math.pi/2)or ds(dU.latitude,-math.pi/2))end;local function e3(e4,dY,e5,e6,e7)local dX=e4;if dy(e4)and not e6 and not e7 and not dY and not e5 then dX,dY,e5,e6,e7=e8(e4,dH)assert(dX,'Argument 1 (position string) is malformed.')else assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(e5),'Argument 3 (latitude) must be in degrees:'..type(e5))assert(dv(e6),'Argument 4 (longitude) must be in degrees:'..type(e6))assert(dv(e7),'Argument 5 (altitude) must be in meters:'..type(e7))end;dX=dq(dX)dY=dq(dY)e5=dq(e5)e6=dq(e6)e7=dq(e7)if dY==0 then return setmetatable({latitude=e5,longitude=e6,altitude=e7,id=dY,systemId=dX},e1)end;return setmetatable({latitude=dD*dp(e5,-90,90),longitude=dD*(e6%360),altitude=e7,id=dY,systemId=dX},e1)end;local e9={}e9.__index=e9;e9.__tostring=function(dL,dR)local ea=dR and dR..'  'local eb={}local dS={}for dO in pairs(dL)do table.insert(dS,dO)end;table.sort(dS)for dT,ec in ipairs(dS)do ed=dL[ec]local ee=dQ.__tostring(ed,ea)if dR then table.insert(eb,dn('[%s]={\n%s\n%s}',ec,ee,dR))else table.insert(eb,dn('  [%s]=%s',ec,ee))end end;if dR then return dn('\n%s%s%s',dR,table.concat(eb,',\n'..dR),dR)end;return dn('{\n%s\n}',table.concat(eb,',\n'))end;local function ef(eg)local e={}local pid;for dT,dA in pairs(eg)do local dY=dA.planetarySystemId;if type(dY)~='number'then error('Invalid planetary s ID: '..tostring(dY))elseif pid and dY~=pid then error('Mistringmatch planetary s IDs: '..dY..' and '..pid)end;local eh=dA.bodyId;if type(eh)~='number'then error('Invalid body ID: '..tostring(eh))elseif e[eh]then error('Duplicate body ID: '..tostring(eh))end;setmetatable(dA.center,getmetatable(vec3.unit_x))e[eh]=setmetatable(dA,dQ)pid=dY end;return setmetatable(e,e9)end;ei={}local function ej(eg)return setmetatable({galaxyAtlas=eg or{}},ei)end;ei.__index=function(dx,K)if type(K)=='number'then local a=dx.galaxyAtlas[K]return ef(a)end;return rawget(ei,K)end;ei.__pairs=function(dL)return function(dx,dO)local ek,el=next(dx,dO)return ek,el and ef(el)end,dL.galaxyAtlas,nil end;ei.__tostring=function(dL)local em={}for dT,en in pairs(dL or{})do local eo=en:getPlanetarySystemId()local ep=e9.__tostring(en,'    ')table.insert(em,dn('  [%s]={%s\n  }',eo,ep))end;return dn('{\n%s\n}\n',table.concat(em,',\n'))end;ei.BodyParameters=dW;ei.MapPosition=e3;ei.PlanetarySystem=ef;function ei.createBodyParameters(dX,dY,eq,er,es,et,eu)assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(eq),'Argument 3 (surfaceArea) must be a number:'..type(eq))assert(dw(er),'Argument 4 (aPosition) must be an array or vec3:'..type(er))assert(dw(es),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(es))assert(dv(et),'Argument 6 (altitude) must be in meters:'..type(et))assert(dv(eu),'Argument 7 (gravityAtPosition) must be number:'..type(eu))local dZ=dr(eq/4/math.pi)local cb=dZ+et;local ev=vec3(er)+cb*vec3(es)local e0=eu*cb*cb;return dW(dX,dY,dZ,ev,e0)end;ei.isMapPosition=dB;function ei:getPlanetarySystem(e4)if K==nil then K=0 end;if el==nil then el=0 end;local dX=e4;if dB(e4)then dX=e4.systemId end;if type(dX)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(el)~=e9 then a=ef(a)end;return a end end end;function e9:sizeCalculator(ew)return 1.05*ew.radius end;function e9:castIntersections(ex,ey,ez,eA,eB,eC)local eD={}if eB then for dT,ew in pairs(eB)do table.insert(eD,ew)end else eD=dj end;if not eC then table.sort(eD,function(eE,eF)local eG=eE.center;local eH=eF.center;return(eG.x-ex.x)^2+(eG.y-ex.y)^2+(eG.z-ex.z)^2<(eH.x-ex.x)^2+(eH.y-ex.y)^2+(eH.z-ex.z)^2 end)end;local eI=ey:normalize()for dT,ew in ipairs(eD)do local eJ=ew.center-ex;local dZ=self:sizeCalculator(ew)local eK=eJ:dot(eI)local eL=eK^2-(eJ:len2()-dZ^2)if eL>=0 then local eM=dr(eL)local eN=eK+eM;local eO=eK-eM;if eO>0 then return ew,eN,eO elseif eN>0 then return ew,eN,nil end end end;return nil,nil,nil end;function e9:closestBody(eP)assert(type(eP)=='table','Invalid coordinates.')local eQ,ew;local eR=vec3(eP)for dT,eS in pairs(self)do local eT=(eS.center-eR):len2()if(not ew or eT<eQ)and eS.name~="Space"then ew=eS;eQ=eT end end;return ew end;function e9:convertToBodyIdAndWorldCoordinates(e4)local eU=e4;if dy(e4)then eU=e3(e4)end;if eU.id==0 then return 0,vec3(eU.latitude,eU.longitude,eU.altitude)end;local eS=self:getBodyParameters(eU)if eS then return eU.id,eS:convertToWorldCoordinates(eU)end end;function e9:getBodyParameters(e4)local dY=e4;if dB(e4)then dY=e4.id end;assert(dv(dY),'Argument 1 (id) must be a number:'..type(dY))return self[dY]end;function e9:getPlanetarySystemId()local dT,dA=next(self)return dA and dA.systemId end;function dQ:convertToMapPosition(d_)assert(dw(d_),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(d_))local eV=vec3(d_)if self.id==0 then return setmetatable({latitude=eV.x,longitude=eV.y,altitude=eV.z,id=0,systemId=self.systemId},e1)end;local eW=eV-self.center;local cb=eW:len()local e7=cb-self.radius;local e5=0;local e6=0;if not ds(cb,0)then local eX=eY(eW.y,eW.x)e6=eX>=0 and eX or 2*math.pi+eX;e5=math.pi/2-math.acos(eW.z/cb)end;return setmetatable({latitude=e5,longitude=e6,altitude=e7,id=self.id,systemId=self.systemId},e1)end;function dQ:convertToWorldCoordinates(e4)local eU=dy(e4)and e3(e4)or e4;if eU.id==0 then return vec3(eU.latitude,eU.longitude,eU.altitude)end;assert(dB(eU),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eU.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eU.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eZ=math.cos(eU.latitude)return self.center+(self.radius+eU.altitude)*vec3(eZ*math.cos(eU.longitude),eZ*math.sin(eU.longitude),math.sin(eU.latitude))end;function dQ:getAltitude(d_)return(vec3(d_)-self.center):len()-self.radius end;function dQ:getDistance(d_)return(vec3(d_)-self.center):len()end;function dQ:getGravity(d_)local e_=self.center-vec3(d_)local f0=e_:len2()return self.GM/f0*e_/dr(f0)end;return setmetatable(ei,{__call=function(dT,...)return ej(...)end})end;local function f1(d,b,c,a,dr,f2)local cy={}local f3=30000000/3600;local f4=f3*f3;local f5=100;function cy.computeAccelerationTime(f6,f7,f8)local f9=f3*math.asin(f6/f3)return(f3*math.asin(f8/f3)-f9)/f7 end;function cy.computeDistanceAndTime(f6,f8,fa,fb,fc,fd)fc=fc or 0;fd=fd or 0;local fe=f6<=f8;local ff=fb*(fe and 1 or-1)/fa;local fg=-fd/fa;local fh=ff+fg;if fe and fh<=0 or not fe and fh>=0 then return-1,-1 end;local fi,fj=0,0;if ff~=0 and fc>0 then local f9=math.asin(f6/f3)local fk=math.pi*(ff/2+fg)local fl=ff*fc;local fm=f3*math.pi;local dA=function(dx)local fn=(fk*dx-fl*math.sin(math.pi*dx/2/fc)+fm*f9)/fm;local fo=math.tan(fn)return f3*fo/dr(fo*fo+1)end;local fp=fe and function(a)return a>=f8 end or function(a)return a<=f8 end;fj=2*fc;if fp(dA(fj))then local fq=0;while f2(fj-fq)>0.5 do local dx=(fj+fq)/2;if fp(dA(dx))then fj=dx else fq=dx end end end;local fr=f6;local fs=fj/f5;for ft=1,f5 do local fu=dA(ft*fs)fi=fi+(fu+fr)*fs/2;fr=fu end;if fj<2*fc then return fi,fj end;f6=fr end;local f9=f3*math.asin(f6/f3)local bG=(f3*math.asin(f8/f3)-f9)/fh;local fv=f4*math.cos(f9/f3)/fh;local cb=fv-f4*math.cos((fh*bG+f9)/f3)/fh;return cb+fi,bG+fj end;function cy.computeTravelTime(f6,f7,cb)if cb==0 then return 0 end;if f7>0 then local f9=f3*math.asin(f6/f3)local fv=f4*math.cos(f9/f3)/f7;return(f3*math.acos(f7*(fv-cb)/f4)-f9)/f7 end;if f6==0 then return-1 end;assert(f6>0,'Acceleration and initial speed are both zero.')return cb/f6 end;return cy end;local function fw(d,b,c,a,dn,dp,dq,dr,ds)local vec3=require('cpml.vec3')local dm=dm(d,b,c,a,dn,dp,dq,dr,ds)local function dy(a)return type(a)=='string'end;local function dw(dx)return type(dx)=='table'end;fx={}fx.__index=fx;function fx:escapeAndOrbitalSpeed(e7)assert(self.body)local cb=e7+self.body.radius;if not ds(cb,0)then local fy=dr(self.body.GM/cb)return dr(2)*fy,fy end;return nil,nil end;function fx:orbitalParameters(e4,fz)assert(self.body)assert(dw(e4)or dy(e4))assert(dw(fz))local fA=(dy(e4)or dm.isMapPosition(e4))and self.body:convertToWorldCoordinates(e4)or vec3(e4)local dA=vec3(fz)local fB=fA-self.body.center;local fC=dA:len2()local fD=fB:len()local fE=self.body.GM;local fF=((fC-fE/fD)*fB-fB:dot(dA)*dA)/fE;local eG=fE/(2*fE/fD-fC)local fG=fF:len()local eI=fF:normalize()local fH=eG*(1-fG)local fI=eG*(1+fG)local fJ=fH*eI+self.body.center;local fK=fG<=1 and-fI*eI+self.body.center or nil;local fL=dr(eG*fE*(1-fG*fG))local fM=fK and 2*math.pi*dr(eG^3/fE)local fN=math.acos(fF:dot(fB)/(fG*fD))if fB:dot(dA)<0 then fN=-(fN-2*math.pi)end;local fO=math.acos((math.cos(fN)+fG)/(1+fG*math.cos(fN)))local fP=fO;if fP<0 then fP=fP+2*math.pi end;local fQ=fP-fG*math.sin(fP)local fR=0;local fS=0;local fT=0;if fM~=nil then fR=fQ/(2*math.pi/fM)fS=fM-fR;fT=fS+fM/2;if fN-math.pi>0 then fS=fR;fT=fS+fM/2 end;if fT>fM then fT=fT-fM end end;return{periapsis={position=fJ,speed=fL/fH,circularOrbitSpeed=dr(fE/fH),altitude=fH-self.body.radius},apoapsis=fK and{position=fK,speed=fL/fI,circularOrbitSpeed=dr(fE/fI),altitude=fI-self.body.radius},currentVelocity=dA,currentPosition=fA,eccentricity=fG,period=fM,eccentricAnomaly=fO,meanAnomaly=fQ,timeToPeriapsis=fS,timeToApoapsis=fT,trueAnomaly=fN}end;local function fU(fV)local eS=dm.BodyParameters(fV.systemId,fV.id,fV.radius,fV.center,fV.GM)return setmetatable({body=eS},fx)end;return setmetatable(fx,{__call=function(dT,...)return fU(...)end})end;local function fW(d,b,c,a,dbHud_1,e,fX,fY,bE,dq,dr,fZ)local function f_(g0)local e2=g1:closestBody(g0)if(g0-e2.center):len()>e2.radius+e2.noAtmosphericDensityAltitude then e2=e[0][0]end;return e2 end;local function g2()local function g3(g4,g5)return g4.name<g5.name end;d7={}for dO,dA in pairs(e[0])do d7[#d7+1]={name=dA.name,index=dO}end;table.sort(d7,g3)end;local function g6(g7)for dO,dA in pairs(g7)do if dA.name and dA.name==g8.name then return dO end end;return-1 end;local function g9()dg=bg;if bg==0 then be="None"c4=nil;g8=nil;return true end;local ga=d7[bg].index;local gb=e[0][ga]if gb.center then be=gb.name;c4=cx[0][ga]if g8~=nil then if ci==0 then if fX(gc,gd)~=1 then fY(gc,gd)end;if fX(ge,gf)~=1 then fY(ge,gf)end;if fX(gg,gh)~=1 then fY(gg,gh)end;if fX(gi,gj)~=1 then fY(gi,gj)end;if fX(gk,gl)~=1 then fY(gk,gl)end end;if fX(gm,gn)~=1 then fY(gm,gn)end;if fX(go,gp)~=1 then fY(go,gp)end;if fX(gq,gr)~=1 then fY(gq,gr)end end;g8=nil else g8=gb;for dT,dA in pairs(cx[0])do if dA.name==g8.planetname then c4=dA;be=g8.name;break end end;if fX(gm,gn)~=1 then fY(gm,gn)end;if fX(go,gp)~=1 then fY(go,gp)end end;if g8==nil then bf=vec3(c4.center)else bf=g8.position end;if c4.planetname~="Space"then if c4.hasAtmosphere then gs=bE(c4.radius*(S-1)+c4.noAtmosphericDensityAltitude)else gs=bE(c4.radius*(S-1)+c4.surfaceMaxAltitude)end else gs=R end;if g8~=nil and g8.planetname=="Space"then ba=0 else dT,ba=cA(c4):escapeAndOrbitalSpeed(gs)end;bc=0;b6=false;b8=false;b9=false;aZ=false;b7=false;bb="Aligning"return true end;local function gt(gu)if not aZ and not bl and not ce and not bu and not b3 and not cf then if gu==nil then bg=bg+1;if bg>#d7 then bg=0 end else bg=bg-1;if bg<0 then bg=#d7 end end;if bg==0 then g9()else local ga=d7[bg].index;local gb=e[0][ga]if gb~=nil and gb.name=="Space"or bv=="Custom Only"and gb.center or bv=="No Moons"and string.find(gb.name,"Moon")~=nil then if gu==nil then gt()else gt(1)end else g9()end end else c0="Disengage autopilot before changing Interplanetary Helper"fZ("iph","AP")end end;local function gv()local gw=-1;gw=g6(e[0])if gw>-1 then table.remove(e[0],gw)end;gw=-1;gw=g6(bk)if gw~=-1 then c0=g8.name.." saved location cleared"table.remove(bk,gw)end;gt()g2()end;local function gx(gy,g0,gz,gA)if dbHud_1 or gz then local e2=f_(g0)local gB=e2.gravity;if gA then gB=c.getClosestPlanetInfluence()end;local gC={position=g0,name=gy,planetname=e2.name,gravity=gB,safe=gA}if not gz then bk[#bk+1]=gC else for dO,dA in pairs(e[0])do if dA.name and gy==dA.name then table.remove(e[0],dO)end end end;table.insert(e[0],gC)g2()g9()c0="Location saved as "..gy.."("..e2.name..")"else c0="Databank must be installed to save permanent locations"end end;local gD={}function gD.UpdateAtlasLocationsList()g2()end;function gD.UpdateAutopilotTarget()g9()end;function gD.adjustAutopilotTargetIndex(gu)gt(gu)end;function gD.findAtlasIndex(g7)g6(g7)end;function gD.UpdatePosition(gE)local gw=g6(bk)if gw~=-1 then if gE~=nil then bk[gw].name=gE;bg=bg-1;gt()else local gF=bk[gw]gF.gravity=c.getClosestPlanetInfluence()gF.position=d0;gF.safe=true end;c0=bk[gw].name.." position updated ("..bk[gw].planetname..")"else c0="Name Not Found"end end;function gD.AddNewLocation(gy,g0,gz,gA)gx(gy,g0,gz,gA)end;function gD.ClearCurrentPosition()gv()end;for dO,dA in pairs(bk)do table.insert(e[0],dA)end;g2()if bg>#d7 then bg=0 end;gD.UpdateAutopilotTarget()return gD end;local function gG(b,a,c,library,radar_1,radar_2,f2,gH,dr,gI,dq,gJ,fZ)local gK={}local gL={}local gM={XS=13,S=27,M=55,L=110,XL=221}local gN={}local gO;local gP;local gQ;local gR;local gS;local gT={}local gU="Atmo"local gV;local function gW()local function gX(gY,gZ,g_,h0,h1,h2,h3,h4)gZ,h0,h2,h4=vec3(gZ),vec3(h0),vec3(h2),vec3(h4)local h5,h6,h7=gY*gY,g_*g_,h1*h1;local fC=h0-gZ;local h8=fC:normalize()local h9=fC:len()local ha=h2-gZ;local hb=(ha-ha:project_on(h8)):normalize()local hc,hd=ha:dot(h8),ha:dot(hb)local he=hc*hc+hd*hd;local hf=h8:cross(hb)local hg=(h5-h6+h9*h9)/(2*h9)local hh=(h5-h7+he-2*hc*hg)/(2*hd)local dC=h5-hg^2-hh^2;local hi=dr(dC)local hj=gZ+h8*hg+hb*hh+hf*hi;local hk=gZ+h8*hg+hb*hh-hf*hi;if f2((h4-hj):len()-h3)<f2((h4-hk):len()-h3)then return hj else return hk end end;local function hl()local function hm()local hn=b.getConstructWorldOrientationRight()local fC=b.getConstructWorldOrientationForward()local ha=b.getConstructWorldOrientationUp()local ho=library.systemResolution3(hn,fC,ha,{1,0,0})local hp=library.systemResolution3(hn,fC,ha,{0,1,0})local hq=library.systemResolution3(hn,fC,ha,{0,0,1})return function(hr)return library.systemResolution3(ho,hp,hq,hr)end end;local hs=hm()local ht=b.getConstructWorldPos()local fA=b.getElementPositionById(1)local hu={fA[1],fA[2],fA[3]}local hv=hs(hu)local hw={ht[1]-hv[1],ht[2]-hv[2],ht[3]-hv[3]}return hw end;local function hx(hy,fD,hz)local hA=hy.pts;local gw=#hA;local hB=hy.ref;if gw>3 then local hC,hD,hE,hF=hA[gw],hA[gw-1],hA[gw-2],hA[gw-3]hy.ref=hz;local fA=gX(hC[1],hC[2],hD[1],hD[2],hE[1],hE[2],hF[1],hF[2])local hg,hh,hi=fA.x,fA.y,fA.z;if hg==hg and hh==hh and hi==hi then hg=hg+hB[1]hh=hh+hB[2]hi=hi+hB[3]local hG=vec3(hg,hh,hi)if not hy.lastPos then hy.center=hG elseif(hy.lastPos-hG):len()<2 then hy.center=hG;hy.skipCalc=true end;hy.lastPos=hG end;hy.pts={}else local hH={hz[1]-hB[1],hz[2]-hB[2],hz[3]-hB[3]}hA[gw+1]={fD,hH}end end;if radar_1 or radar_2 then cE.assignRadar()end;if gT[1]then gO=#gT[1].getConstructIds()local hI=gT[1].getData()local hJ=hI:gmatch('{"constructId[^}]*}[^}]*}')if gO>0 then local hz=hl()local hK,hL=0,0;gS,gR=0,0;for dA in hJ do local dY,cb,hM=dA:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hN=gM[hM]cb=dq(cb)if gT[1].hasMatchingTransponder(dY)==1 then table.insert(gL,dY)end;local hO=gT[1].getConstructType(dY)if F then if hN>27 or hO=="static"or hO=="space"then gS=gS+1;local gy=gT[1].getConstructName(dY)local hy=db[dY]if hy==nil then hN=hN+gJ;db[dY]={pts={},ref=hz,name=gy,i=0,radius=hN,skipCalc=false}hy=db[dY]end;if not hy.skipCalc then hx(hy,cb,hz)hL=hL+1 end;if hy.center then table.insert(gN,hy)end end;hK=hK+1;if dc and hK>700 or hL>70 or(not dc and hK>300 or hL>30)then coroutine.yield()hK,hL=0,0 end end end;gR=#gN;if gR>0 and cY>20 then local ew,hP,hQ,hR;local hS=0;local hT=cx:getPlanetarySystem(0)hR=cX:normalize()while hS<gR do coroutine.yield()local hU={table.unpack(gN,hS,math.min(hS+75,gR))}ew,hP,hQ=hT:castIntersections(d0,hR,nil,nil,hU,true)if ew and hQ then de={ew,hP,hQ}break end;hS=hS+75 end;if not ew then de=nil end else de=nil end;gN={}gP=hI:find('identifiedConstructs":%[%]')else gQ=hI:find('worksInEnvironment":false')end end end;local function hV()if gT[1]then gU="Atmo"if gT[1].getData():find('worksInAtmosphere":false')then gU="Space"end end end;function gK.pickType()hV()end;function gK.assignRadar()if radar_1 and gT[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gT[1]=radar_2 end;if gT[1]==radar_2 then hV()end elseif radar_2 and gT[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gT[1]=radar_1 end;if gT[1]==radar_1 then hV()end end end;function gK.UpdateRadar()local hW=coroutine.status(gV)if hW=="suspended"then local dP,hX=coroutine.resume(gV)if hX then a.print("ERROR UPDATE RADAR: "..hX)end elseif hW=="dead"then gV=coroutine.create(gW)local dP,hX=coroutine.resume(gV)end end;function gK.GetRadarHud(hY,hZ,h_,i0)local i1=gL;local i2,i3;gL={}local dG=gR or 0;if gO>0 then if F then i3=dG.."/"..gS.." Plotted : "..gO-gS.." Ignored"else i3="Radar Contacts: "..gO end;i2=gI(h_,i0,i3,"pbright txtbig txtmid")if#gL>0 then i2=i2 ..gI(hY,hZ,"Friendlies In Range","pbright txtbig txtmid")for dO,dA in pairs(gL)do hZ=hZ+20;i2=i2 ..gI(hY,hZ,gT[1].getConstructName(dA),"pdim txtmid")end end;if gP==nil and i4==nil then i5=1;cE.ToggleRadarPanel()end;if gP~=nil and i4~=nil then cE.ToggleRadarPanel()end;if i6==nil then cE.ToggleRadarPanel()end else if gQ then i2=gI(h_,i0,gU.." Radar: Jammed","pbright txtbig txtmid")else i2=gI(h_,i0,"Radar: No "..gU.." Contacts","pbright txtbig txtmid")end;if i6~=nil then i5=0;cE.ToggleRadarPanel()end end;return i2 end;function gK.GetClosestName(gy)if gT[1]then local dY,dT=gT[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dY~=nil and dY~=""then gy=gy.." "..gT[1].getConstructName(dY)end end;return gy end;function gK.ToggleRadarPanel()if i6~=nil and i5==0 then gH(i6)i6=nil;if i4~=nil then gH(i4)i4=nil end else if i5==1 then gH(i6)i6=nil;_autoconf.displayCategoryPanel(gT,1,"Periscope","periscope")i4=_autoconf.panels[_autoconf.panels_size]end;if i6==nil then _autoconf.displayCategoryPanel(gT,1,"Radar","radar")i6=_autoconf.panels[_autoconf.panels_size]end;i5=0 end end;function gK.ContactTick()if not i7 then i7=0 end;if bG>i7+10 then c0="Radar Contact"fZ("rdrCon","RC")i7=bG end;c.stopTimer("contact")end;function gK.onEnter(dY)if radar_1 and not ch and not d8 then c.setTimer("contact",0.1)end end;function gK.onLeave(dY)if radar_1 and F then if#db>650 then dY=tostring(dY)db[dY]=nil end end end;gT[1]=nil;if radar_1 then gT[1]=radar_1;hV()end;gV=coroutine.create(gW)return gK end;local function i8(d,b,c,a,e,radar_1,radar_2,antigrav,hover,i9,warpdrive,f2,bE,dn,ia,bF,ib,ic,eY,bD,dp,id,fY,fX,gH,ie,dr,ig,gI,fZ,ih,ii,ij,ik)local il=9.80665;local im={}local io={}local ip={}local iq={}local ir=nil;local is=nil;local it=nil;local iu=false;local iv="none"local iw=""local ix=55;local iy=0;local iz=0;local iA=vec3({13771471,7435803,-128971})local iB=18000000;local iC=500000;local iD,iE=math.huge;local iF;local function iG(iH)iD=vec3(iH):dist(iA)if iD<iB then return true,f2(iD-iB)end;iE=vec3(iH):dist(vec3(iI.center))if iE<iC then iF=true else iF=false end;if f2(iE-iC)<f2(iD-iB)then return iF,f2(iE-iC)else return iF,f2(iD-iB)end end;local function iJ(dA)if cr==1920 then return dA else return ig(cr*dA/1920,0)end end;local function iK(dA)if cs==1080 then return dA else return ig(cs*dA/1080,0)end end;local function iL()return ie()==0 and g~="keyboard"and ic()==0 end;local function iM()local iN="TRAVEL"if not d4 then iN="CRUISE"end;if aZ then iN="AUTOPILOT"end;return iN end;local i2=""local iO=""local iP=""local iQ=1;local iR=2;local iS=3;local iT=4;local iU=5;local iV=6;local iW=""local iX=0;local iY=bE(1/aO)*2*aP;local iZ={}local i_={}local j0={}local j1={}local j2={}local j3={}local function j4(hg,j5,j6,j7,j8,j9)local ja=jb;local jc=jb+5;if not C then jc=jc+5 end;if ic()==1 and not l then ja=ja-50;jc=jc-50 end;if j6=="ATMO"then iW="atmofueltank"elseif j6=="SPACE"then iW="spacefueltank"else iW="rocketfueltank"end;iX=_G[iW.."_size"]if#j7>0 then for K=1,#j7 do local gy=string.sub(j7[K][iR],1,12)local jd=0;for je=1,iX do if j7[K][iR]==ia(c[iW.."_"..je].getData()).name then jd=je;break end end;local jf=bD()if j8[K]==nil or j9[K]==nil or jf-j7[K][iV]>iY then local jg;local jh=0;if jd~=0 then j9[K]=ia(c[iW.."_"..jd].getData()).percentage;j8[K]=ia(c[iW.."_"..jd].getData()).timeLeft;if j8[K]=="n/a"then j8[K]=0 end else jh=ib(j7[K][iQ])-j7[K][iT]j9[K]=bE(0.5+jh*100/j7[K][iS])jg=j7[K][iU]if jg<=jh then j8[K]=0 else j8[K]=bE(0.5+jh/((jg-jh)/(jf-j7[K][iV])))end;j7[K][iU]=jh;j7[K][iV]=jf end end;if gy==j5 then gy=dn("%s %d",j6,K)end;if jd==0 then gy=gy.." *"end;local ji;if j8[K]==0 then ji=""else ji=ik(j8[K])end;if j9[K]~=nil then local jj=bE(j9[K]*2.55)local jk=dn("rgb(%d,%d,%d)",255-jj,jj,0)local jl=""if ji~=""and j8[K]<120 or j9[K]<5 then jl="red "end;local jm=dn("rgb(%d,%d,%d)",dp(bE((255-jj)/2.55),50,100),dp(bE(jj/2.55),0,50),50)local jn="rgb(196,0,255)"if j6=="ATMO"then jn="rgb(0,188,255)"elseif j6=="SPACE"then jn="rgb(239,255,0)"end;local jo=false;if jp~=jn then jo=true end;jp=jn;if C then if jo then ja=ja-5;jc=jc-5 end;iO=iO..dn([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jm,jn,hg,jc,jk,bE(j9[K]*1.7+0.5)-2,hg+1,jc+1,hg+5,jc+14,gy,j9[K],ji)ja=ja-22;jc=jc-22 else iO=iO..gI(hg,ja,gy,jl.."pdim txtfuel")iO=iO..gI(hg,jc,dn("%d%% %s",j9[K],ji),"pdim txtfuel","fill:"..jk)ja=ja+30;jc=jc+30 end end end end;jb=ja end;local function jq(jr,e7)if al==0 and am==0 then return end;if e7<200000 and not ch or e7 and ch then local js=0;if f2(c_)>1 then js=45*math.log(f2(c_),10)if c_<0 then js=-js end end;jr[#jr+1]=dn([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],al,am,bE(c_),bE(js))end;return jr end;local function jt(ju)local gu=-cZ;ju=ju-ju:project_on(gu)local jv=vec3(0,0,1)jv=jv-jv:project_on(gu)local jw=jv:cross(gu)local js=jv:angle_between(ju)*constants.rad2deg;if ju:dot(jw)<0 then js=360-js end;return js end;local function jx(jr,ah,ai,jy,jz,dc)if aa==0 then return end;local jA=aa;local jB=20;local jC=bE(jy)if dc then for K=-45,45,5 do local jD=K;jr[#jr+1]=dn([[<g transform="rotate(%f,%d,%d)">]],jD,ah,ai)jE=5;if K%15==0 then jE=15 elseif K%10==0 then jE=10 end;jr[#jr+1]=dn([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ah,ai+jA+jB-jE,ah,ai+jA+jB)end;jr[#jr+1]=gI(ah,ai+jA+jB-35,jz,"pdim txt txtmid")jr[#jr+1]=gI(ah,ai+jA+jB-25,jC.." deg","pdim txt txtmid")jr[#jr+1]=dn([[<g transform="rotate(%f,%d,%d)">]],-jy,ah,ai)jr[#jr+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ah-5,ai+jA+jB-20,ah+5,ai+jA+jB-20,ah,ai+jA+jB-15)jr[#jr+1]="</g>"end;jr[#jr+1]=[[<g style="clip-path: url(#headingClip);">]]local jF=jC;if dc then jF=jt(cU)end;local jG=20;local jH=bE(jF)local jI=0;local jJ=ai+jA+jB+20;local jK=ah;if jz~="YAW"then jJ=iK(130)jK=iJ(960)end;local jL=[[<path class="txttick line" d="]]local jM=bE(jH-(jG+10)-jH%5+0.5)for K=jM+70,jM,-5 do local hg=jK-(-K*5+jF*5)if K%10==0 then jI=10;local dG=K;if dG==360 then dG=0 elseif dG>360 then dG=dG-360 elseif dG<0 then dG=dG+360 end;jr[#jr+1]=gI(hg,jJ+15,dG,"txtmid bright")elseif K%5==0 then jI=5 end;if jI==10 then jL=dn([[%s M %f %f v %d]],jL,hg,jJ-5,jI)else jL=dn([[%s M %f %f v %d]],jL,hg,jJ-2.5,jI)end end;jr[#jr+1]=jL..[["/>]]jr[#jr+1]=dn([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jK-5,jJ-20,jK+5,jJ-20,jK,jJ-10)if I then if dc then jz="HDG"end;jr[#jr+1]=gI(iJ(960),iK(100),jH.."°","dim txt txtmid size14","")jr[#jr+1]=gI(iJ(960),iK(85),jz,"dim txt txtmid size20","")end;jr[#jr+1]=[[</g>]]end;local function jN(jr,jO,jy,ah,ai,dc,jP,fu)if aa==0 then return end;local jA=aa;local jQ=bE(jA*3/5)if jA>0 then local jR=bE(jO)local jE=0;local jL=dn([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jy,ah,ai)if not ch then jL=dn([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ah,ai)end;jr[#jr+1]=dn([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jA-1,ah,ai)jr[#jr+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bE(jR-30-jR%5+0.5),bE(jR+30+jR%5+0.5),5 do if K%10==0 then jE=30 elseif K%5==0 then jE=20 end;local hh=ai+-K*5+jO*5;if jE==30 then jL=dn([[%s M %d %f h %d]],jL,ah-jQ-jE,hh,jE)if ch then jr[#jr+1]=dn([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jy,ah,ai,ah-jQ+10,hh+4,K)jr[#jr+1]=dn([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jy,ah,ai,ah+jQ-10,hh+4,K)if K==0 or K==180 or K==-180 then jr[#jr+1]=dn([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jy,ah,ai,ah-jQ+20,hh,jQ*2-40)end else jr[#jr+1]=gI(ah-jQ+10,hh,K,"pdim txt txtmid")jr[#jr+1]=gI(ah+jQ-10,hh,K,"pdim txt txtmid")end;jL=dn([[%s M %d %f h %d]],jL,ah+jQ,hh,jE)else jL=dn([[%s M %d %f h %d]],jL,ah-jQ-jE,hh,jE)jL=dn([[%s M %d %f h %d]],jL,ah+jQ,hh,jE)end end;jr[#jr+1]=jL..[["/>]]local jS="PITCH"if not dc then jS="REL PITCH"end;if jO>90 and not ch then jO=90-(jO-90)elseif jO<-90 and not ch then jO=-90-(jO+90)end;if jA>200 then if ch then if fu>ix then jr[#jr+1]=gI(ah,ai-15,"Yaw","pdim txt txtmid")jr[#jr+1]=gI(ah,ai+20,jP,"pdim txt txtmid")end;jr[#jr+1]=dn([[<g transform="rotate(%f,%d,%d)">]],-jy,ah,ai)else jr[#jr+1]=dn([[<g transform="rotate(0,%d,%d)">]],ah,ai)end;jr[#jr+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah-jQ+25,ai-5,ah-jQ+20,ai,ah-jQ+25,ai+5,ah-jQ+50,ai+4,jR)jr[#jr+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah+jQ-25,ai-5,ah+jQ-20,ai,ah+jQ-25,ai+5,ah+jQ-30,ai+4,jR)jr[#jr+1]="</g>"end;local jT=bE(jA/3)jr[#jr+1]=dn([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ah-jT,ai,jA-jT)if not ch and dc then jr[#jr+1]=dn([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jy,ah,ai,ah-jQ+10,ai,jQ*2-20)end;jr[#jr+1]="</g>"if jA<200 then if ch and fu>ix then jr[#jr+1]=gI(ah,ai-jA,jS,"pdim txt txtmid")jr[#jr+1]=gI(ah,ai-jA+10,jR,"pdim txt txtmid")jr[#jr+1]=gI(ah,ai-15,"Yaw","pdim txt txtmid")jr[#jr+1]=gI(ah,ai+20,jP,"pdim txt txtmid")else jr[#jr+1]=gI(ah,ai-jA,jS,"pdim txt txtmid")jr[#jr+1]=gI(ah,ai-jA+15,jR,"pdim txt txtmid")end end end end;local function jU(jr,e7,dc)local jV=an;local jW=ao;if jV==0 and jW==0 then return end;local jX=78;local jY=19;local jZ=cg;if cg~=-1 then jr[#jr+1]=gI(jV+jX,jW+jY+20,dn("AGL: %.1fm",cg),"pdim altsm txtend")end;if dc and(e7<200000 and not ch or e7 and ch)then table.insert(jr,dn([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],jV-1,jW-4,jX+2,jY+6,jV+1,jW-1,jX-4,jY))local gw=0;local j_=1;local k0=0;local k1=e7<0;local k2=e7<iI.surfaceMaxAltitude;local k3=9;if k1 then k3=0 end;local e7=f2(e7)while gw<6 do local k4=11;local k5=16;local k6=9;local k7=14;local jl="altsm"if gw>2 then k5=k5+3;k4=k4+2;k7=k7+2;k6=k6-6;jl="altbig"end;if k1 then jl=jl.." red"elseif k2 then jl=jl.." orange"end;local k8=e7/j_%10;local k9=bE(k8)local ka=bE((k9+1)%10)local kb=k0;if gw==0 then kb=k8-k9;if k1 then kb=1-kb end end;if k1 and(gw==0 or k0~=0)then local gz=ka;ka=k9;k9=gz end;local kc=k5*(kb-1)local kd=kc+k5;local hg=jV+k6+(6-gw)*k4;local hh=jW+k7;jr[#jr+1]=gI(hg,hh+kc,ka,jl)jr[#jr+1]=gI(hg,hh+kd,k9,jl)gw=gw+1;j_=j_*10;if k9==k3 then k0=kb else k0=0 end end;table.insert(jr,[[</g></g>]])end end;local function ke(fz)local kf=-math.deg(eY(fz.y,fz.z))+180;kf=kf-90;if kf<0 then kf=360+kf end;if kf>180 then kf=-180+kf-180 end;return-kf end;local function kg(fz)local jF=math.deg(eY(fz.y,fz.x))-90;if jF<-180 then jF=360+jF end;return jF end;local function kh(jr,fz,fu,ah,ai)if fu>5 and not ch or fu>ix then local jA=aa;local ki=20;local kj=20;local kk=ke(fz)local kl=kg(fz)local km=14;local kn=km/2;local ko=-kl/kj*jA;local kp=kk/ki*jA;local hg=ah+ko;local hh=ai+kp;local cb=dr(ko^2+kp^2)local kq=[[<circle
                            cx="]]..hg..[["
                            cy="]]..hh..[["
                            r="]]..kn/km..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hg..[["
                            cy="]]..hh..[["
                            r="]]..kn..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hg-km..[[,]]..hh..[[ h ]]..kn..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hg+kn..[[,]]..hh..[[ h ]]..kn..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hg..[[,]]..hh-km..[[ v ]]..kn..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<jA then jr[#jr+1]=kq else local js=eY(kp,ko)local kr=4;local ks=ah+jA*math.cos(js)local kt=ai+jA*math.sin(js)jr[#jr+1]=dn('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',js*180/math.pi,ks,kt,ks-kr,kt-kr/2,kr*2,kr,ks+kr,kt-kr,kr,kr,-kr,kr)end;if not ch then local ku=vec3(fz)kk=ke(-ku)kl=kg(-ku)ko=-kl/kj*jA;kp=kk/ki*jA;hg=ah+ko;hh=ai+kp;cb=dr(ko^2+kp^2)if cb<jA then local kv=[[<circle
                                    cx="]]..hg..[["
                                    cy="]]..hh..[["
                                    r="]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hg..[[,]]..hh-km..[[ v ]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hg..[[,]]..hh..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hg..[[,]]..hh..[[)" />
                                <path
                                    d="M ]]..hg-kn..[[,]]..hh..[[ h ]]..km..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hg..[[,]]..hh..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hg..[[,]]..hh..[[)"/>]]jr[#jr+1]=kv end end end end;local function kw(jr,iN,kx,ky)if aj==0 and ak==0 then return end;kx=bE(kx+0.5)local ja=ak+10;local jc=ak+20;if ic()==1 and not l then ja=55;jc=65 end;local kz="CRUISE"local c="km/h"local dP=ky;if iN=="TRAVEL"or iN=="AUTOPILOT"then kz="THROT"c="%"dP=kx;local kA="dim"if kx<0 then kA="red"end;jr[#jr+1]=dn([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kA,aj-7,ak-50,aj,ak-50,aj,ak+50,aj-7,ak+50,1-f2(kx),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)end;jr[#jr+1]=gI(aj+10,ja,kz,"pbright txtstart")jr[#jr+1]=gI(aj+10,jc,dn("%.0f %s",dP,c),"pbright txtstart")if ch and u and d4 and bM then kx=bE(bN*100+0.5)local kA="red"if kx<0 then kA="red"end;jr[#jr+1]=dn([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kA,1-f2(kx),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)jr[#jr+1]=gI(aj+10,ja+40,"LIMIT","pbright txtstart")jr[#jr+1]=gI(aj+10,jc+40,kx.."%","pbright txtstart")end;if ch and u or b3 then jr[#jr+1]=gI(aj+10,ja-40,"LIMIT: "..cL.." km/h","dim txtstart")elseif not ch and aZ then jr[#jr+1]=gI(aj+10,ja-40,"LIMIT: "..bE(_*3.6+0.5).." km/h","dim txtstart")end end;local function kB(jr,kC)if aj==0 and ak==0 then return end;local kD=ak-10;local kE=aj+10;jr[#jr+1]=gI(0,0,"","pdim txt txtend")if ic()==1 and not l then kD=75 end;jr[#jr+1]=gI(kE,kD,bE(kC).." km/h","pbright txtbig txtstart")end;local function kF(jr)jr[#jr+1]=gI(iJ(1900),iK(1070),dn("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jr[#jr+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jr[#jr+1]=gI(iJ(960),iK(550),"Warning: Invalid Control Scheme Detected","warnings")jr[#jr+1]=gI(iJ(960),iK(600),"Keyboard Scheme must be selected","warnings")jr[#jr+1]=gI(iJ(960),iK(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kG=iJ(960)local kH=iK(860)local kI=iK(880)local kJ=iK(900)local kK=iK(960)local kL=iK(200)local kM=iK(250)local kN=iK(960)if ic()==1 and not l then kH=iK(135)kI=iK(155)kJ=iK(175)kL=iK(115)kM=iK(95)end;local kO="#222222"local kP="white"local kQ="dimmer"local kR="pbright"local kS="#110000"local kT=kO;local kU=kQ;if aW then jr[#jr+1]=gI(kG,kH,"Brake Engaged","warnings")kS="#440000"kT=kP;kU=kR elseif bL>0 then jr[#jr+1]=gI(kG,kH,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local kV="#110000"local kW=kO;local kX=kQ;if ch and cJ and cg==-1 then if not aZ and not bl and not b1 and not d2 and not b4 and not b2 then jr[#jr+1]=gI(kG,kL+50,"** STALL WARNING **","warnings")kV="#ff0000"kW=kP;kX=kR;fZ("stall","SW",2)end end;if da then jr[#jr+1]=gI(kG,kL+90,"Flight Assist in Progress","warnings")end;if cn then jr[#jr+1]=gI(kG,kN,"Gyro Enabled","warnings")end;local kY="#111100"local kZ=kO;local k_=kQ;if bh then kY="#775500"kZ=kP;k_=kR;if bR then jr[#jr+1]=gI(kG,kI,"Gear Extended","warn")else jr[#jr+1]=gI(kG,kI,"Landed (G: Takeoff)","warnings")end;local l0=ij(d:getTargetGroundAltitude())jr[#jr+1]=gI(kG,kJ,"Hover Height: "..l0,"warn")end;local l1="#000011"local l2=kO;local l3=kQ;if c1 then l1="#0000DD"l2=kP;l3=kR;jr[#jr+1]=gI(kG,kK+20,"ROCKET BOOST ENABLED","warn")end;local l4="#001100"local l5=kO;local l6=kQ;if antigrav and not q and d2 and bq~=nil then l4="#00DD00"l5=kP;l6=kR;if f2(cj-antigrav.getBaseAltitude())<501 then jr[#jr+1]=gI(kG,kL+15,dn("Target Altitude: %d Singularity Altitude: %d",bE(bq),bE(antigrav.getBaseAltitude())),"warn")else jr[#jr+1]=gI(kG,kL+15,dn("Target Altitude: %d Singluarity Altitude: %d",bE(bq),bE(antigrav.getBaseAltitude())),"warnings")end elseif aZ and be~="None"then jr[#jr+1]=gI(kG,kL+20,"Autopilot "..bb,"warn")elseif bo~=nil then jr[#jr+1]=gI(kG,kL+20,dn("LockedPitch: %d",bE(bo)),"warn")elseif bZ then jr[#jr+1]=gI(kG,kL+20,"Follow Mode Engaged","warn")elseif b3 or cf then jr[#jr+1]=gI(kG,kL+20,"Re-entry in Progress","warn")end;if b0 or b4 then local l0=ij(b5,2)if b4 then if d2 then l0=ij(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jr[#jr+1]=gI(kG,kL,"VTO to "..l0,"warn")elseif b2 and not bu then if ce then jr[#jr+1]=gI(kG,kL,"Takeoff to "..be,"warn")else jr[#jr+1]=gI(kG,kL,"Takeoff to "..l0,"warn")end;if aW and not b4 then jr[#jr+1]=gI(kG,kL+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jr[#jr+1]=gI(kG,kL,"Altitude Hold: "..l0,"warn")end end;if b4 and(antigrav~=nil and antigrav)then if ci>0.1 then jr[#jr+1]=gI(kG,kL+20,"Beginning ascent","warn")elseif ci<0.09 and ci>0.05 then jr[#jr+1]=gI(kG,kL+20,"Aligning trajectory","warn")elseif ci<0.05 then jr[#jr+1]=gI(kG,kL+20,"Leaving atmosphere","warn")end end;if bu then if cN~=nil then jr[#jr+1]=gI(kG,kL,cN,"warn")end end;if b1 then if l7 then jr[#jr+1]=gI(kG,kL,"Brake-Landing","warnings")else jr[#jr+1]=gI(kG,kL,"Coast-Landing","warnings")end end;if aY then jr[#jr+1]=gI(kG,kL,"Prograde Alignment","crit")end;if aX then jr[#jr+1]=gI(kG,kL,"Retrograde Alignment","crit")end;local l8="#110000"local l9=kO;local la=kQ;if dd then l8="#FF0000"l9=kP;la=kR;local type;if string.find(dd,"COLLISION")then type="warnings"else type="crit"end;jr[#jr+1]=gI(kG,kM+20,dd,type)elseif ci==0 then local lb,lc=cD.checkLOS(cX:normalize())if lc~=nil then la=kR;l8="#FF0000"l9=kP;local l0=ij(lc)local ld=cy.computeTravelTime(cY,0,lc)local le="Collision"if lb.noAtmosphericDensityAltitude>0 then le="Atmosphere"end;jr[#jr+1]=gI(kG,kM+20,lb.name.." "..le.." "..ik(ld).." In "..l0,"crit")end end;if bl and not bu then jr[#jr+1]=gI(kG,kL+35,lf,"warn")end;local lg="#111100"local lh=kO;local li=kQ;if dh and#dh>1 then lg="#DDDD00"lh=kP;li=kR end;local lj=iJ;local lk=iK;local kQ="topButton"local ll="topButtonActive"local lm=kQ;if aZ or bl or ce or bu then lm=ll end;local ln=kQ;if aY then ln=ll end;local lo=kQ;if b1 or bh then lo=ll end;local lp=kQ;if b0 or bl then lp=ll end;local lq=kQ;if aX then lq=ll end;local lr=kQ;if bu or cQ and aZ then lr=ll end;if x and I then local ls=lk(30)jr[#jr+1]=dn([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lm,lj(960),lk(54),lk(-53),lj(-120),lj(25),lk(50))jr[#jr+1]=gI(lj(910),ls,"AUTOPILOT")jr[#jr+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ln,lj(865),lk(51),lj(-25),lk(-50),lj(-110),lj(25),lk(46))jr[#jr+1]=gI(lj(800),ls,"PROGRADE")jr[#jr+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lo,lj(755),lk(47),lj(-25),lk(-46),lj(-98),lj(44),lk(44))jr[#jr+1]=gI(lj(700),ls,"LAND")jr[#jr+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lp,lj(960),lk(54),lk(-53),lj(120),lj(-25),lk(50))jr[#jr+1]=gI(lj(1010),ls,"ALT HOLD")jr[#jr+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lq,lj(1055),lk(51),lj(25),lk(-50),lj(110),lj(-25),lk(46))jr[#jr+1]=gI(lj(1122),ls,"RETROGRADE")jr[#jr+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lr,lj(1165),lk(47),lj(25),lk(-46),lj(98),lj(-44),lk(44))jr[#jr+1]=gI(lj(1220),ls,"ORBIT")jr[#jr+1]=[[
                                    </g>
                                </g>]]jr[#jr+1]="</g>"end;return jr end;local function lt(fu)return bE(ig(fu*3.6,0)+0.5).." km/h"end;local function lu(gw)local gy=be;if gw~=nil and type(gw)=="number"then if gw==0 then return"None"end;gy=d7[gw].name end;if gy==nil then gy=g8.name end;if gy==nil then gy="None"end;return gy end;local function lv(jr)local lw=cD.routeWP(true)if not lw or#lw==0 then return end;local hg=iJ(750)local hh=iK(360)if aZ or bl then jr[#jr+1]=gI(hg,hh,"REMAINING ROUTE","pdim txtstart size20")else jr[#jr+1]=gI(hg,hh,"LOADED ROUTE","pdim txtstart size20")end;for dO,K in pairs(lw)do hh=hh+20;jr[#jr+1]=gI(hg,hh,dO..". "..lu(lw[dO]),"pdim txtstart size20")end end;local function lx(jr)local hg=av+10;local hh=aw+20;local ly={}local lz={"Alt-4: AutoTakeoff to Target"}local lA={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lB={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lC={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(ly,"--------------DYNAMIC-----------------")if ch then if cg~=-1 then ih(ly,lz)if c4 and iI and c4.name==iI.name then table.insert(ly,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aV then if antigrav then if d2 then table.insert(ly,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(ly,"Turn on AGG to takeoff to AGG Height")end end;if aV then table.insert(ly,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(ly,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(ly,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bh then table.insert(ly,"G: Takeoff to hover height, raise gear")else table.insert(ly,"G: Lowergear and Land")end else ih(ly,lA)table.insert(ly,"G: Begin BrakeLanding or Land")end;if b4 then table.insert(ly,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ih(ly,lB)if i9 then table.insert(ly,"Alt-Shift-6: Vent shields")table.insert(ly,"Alt-Shift-7: Toggle shied off/on")end end;if g8~=nil then table.insert(ly,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(ly,"Alt-9: Activate Gyroscope")end;if aR~="none"or aQ~="none"or aS~="none"then table.insert(ly,"Alt-Shift-9: Cycles engines with Extra tags")end;if b0 then table.insert(ly,"Alt-Spacebar/C will raise/lower target height")table.insert(ly,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not ch then table.insert(ly,"LALT+Mousewheel will lower/raise speed limit")end;ih(ly,lC)for K=1,#ly do hh=hh+12;jr[#jr+1]=gI(hg,hh,ly[K],"pdim txtbig txtstart")end end;local function lD(jr)local lE=av;local lF=aw;local lG=au;local lH=4;local lI=15;local hg=0;local hh=0;local lJ,lK,lL,lM;local lN;local function lO(type)local lP,bG,fu,lQ,jl,lR;if type=="Periapsis"then lP=lN.periapsis.altitude;bG=lN.timeToPeriapsis;fu=lN.periapsis.speed;jl="txtend"lQ=12;lR=math.min(hg,lE+lG-iI.radius/lL-lH*2)else lP=lN.apoapsis.altitude;bG=lN.timeToApoapsis;fu=lN.apoapsis.speed;lQ=-12;jl="txtstart"lR=hg end;if cY<1 then bG=0 end;jr[#jr+1]=dn([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lR+lQ,hh-5,hg,hh-5)jr[#jr+1]=dn([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lR-lQ*4,hh+2,hg,hh+2)jr[#jr+1]=gI(lR,hh,type,jl)hg=lR-lQ*2;hh=hh+lI;local l0=ij(lP)jr[#jr+1]=gI(hg,hh,l0,jl)hh=hh+lI;jr[#jr+1]=gI(hg,hh,ik(bG),jl)hh=hh+lI;jr[#jr+1]=gI(hg,hh,lt(fu),jl)end;local lS=lG*1.5;if bB=="INFO"then lS=25*7 end;if bB~="HIDE"then jr[#jr+1]=[[<g class="pbright txtorb txtmid">]]jr[#jr+1]=dn('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lG*2,lS,lE,lF)jr[#jr+1]=dn([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lG*2,lS,lE,lF)end;local lT=lG*1.5;local lU=lG*2;local lV=lT/2;local lW=lG;local lX=lE+lW;local lY=lF+lV;local lZ=lE+lU;local l_=lF+lT;if bB=="ORBIT"then lF=lF+lH;lJ=lG/2;lM=0;lN={}lN.periapsis={}lN.apoapsis={}if fy~=nil then if fy.periapsis~=nil then lN.periapsis.altitude=fy.periapsis.altitude;lN.periapsis.speed=fy.periapsis.speed end;if fy.apoapsis~=nil then lN.apoapsis.altitude=fy.apoapsis.altitude;lN.apoapsis.speed=fy.apoapsis.speed end;lN.period=fy.period;lN.eccentricity=fy.eccentricity;lN.timeToApoapsis=fy.timeToApoapsis;lN.timeToPeriapsis=fy.timeToPeriapsis;lN.eccentricAnomaly=fy.eccentricAnomaly;lN.trueAnomaly=fy.trueAnomaly end;if lN.periapsis==nil then lN.periapsis={}lN.periapsis.altitude=-iI.radius;lN.periapsis.speed=_ end;if lN.eccentricity==nil then lN.eccentricity=1 end;if lN.apoapsis==nil then lN.apoapsis={}lN.apoapsis.altitude=cj;lN.apoapsis.speed=0 end;if cY<1 then lN.apoapsis.altitude=cj;lN.apoapsis.speed=0 end;if lN.apoapsis.altitude then lL=(lN.apoapsis.altitude+lN.periapsis.altitude+iI.radius*2)/(lJ*2)lK=(iI.radius+lN.apoapsis.altitude)/lL*(1-lN.eccentricity)lM=lJ-lN.periapsis.altitude/lL-iI.radius/lL;local m0=math.pi;if lN.period~=nil and lN.period>0 and lN.timeToApoapsis~=nil then m0=lN.eccentricAnomaly;if lN.timeToPeriapsis<lN.timeToApoapsis then m0=2*math.pi-m0 end end;if cY<1 or m0~=m0 then m0=math.pi end;local m1=-lJ*math.cos(m0)+lE+lW+lH;local m2=lK*math.sin(m0)+lF+lV+lH;local m3=""jr[#jr+1]='<g clip-path="url(#orbitRect)">'jr[#jr+1]=dn([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],m3,lE+lG+lH,lF+lG*1.5/2+lH,lJ,lK)if lK<1 then jr[#jr+1]=dn([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lE+lG+lH-lM,lF+lG*1.5/2+lH,m1,m2)end;jr[#jr+1]=dn('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lE+lG+lH-lM,lF+lG*1.5/2+lH,(iI.radius+iI.noAtmosphericDensityAltitude)/lL)jr[#jr+1]=dn('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lE+lG+lH-lM,lF+lG*1.5/2+lH,(iI.radius+iI.noAtmosphericDensityAltitude)/lL)jr[#jr+1]=dn([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lE+lG+lH,lF+lG*1.5/2+lH,lJ,lK)jr[#jr+1]=dn('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lE+lG+lH-lM,lF+lG*1.5/2+lH,iI.radius/lL)jr[#jr+1]='</g>'local m4=math.floor(iI.radius/lL+0.5)hg=lE+lG+lH*4+lJ;hh=lF+lG*1.5/2+5+lH;if lN.apoapsis~=nil and lN.apoapsis.speed<_ then lO("Apoapsis")end;hh=lF+lG*1.5/2+5+lH;hg=lE+lG-lH*2-lJ;if lN.periapsis~=nil and lN.periapsis.speed<_ and lN.periapsis.altitude>0 then lO("Periapsis")end;jr[#jr+1]=gI(lE+lG+lH,lF+20+lH,iI.name,"txtorbbig")jr[#jr+1]=dn('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m1,m2)jr[#jr+1]=[[</g>]]return jr else jr[#jr+1]='<g clip-path="url(#orbitRect)">'local m5=""local m6=1.2*(m7-m8)/(lG*2)local m9=1.4*(ma-mb)/(lG*1.5)for dO,dA in pairs(e[0])do if dA.center then local hg=lE+lG+dA.center.x/m6;local hh=lF+lG*1.5/2+dA.center.y/m9;m5=m5 ..'<circle cx="'..hg..'" cy="'..hh..'" r="'..dA.radius/m6*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dA.name,"Moon")and not string.match(dA.name,"Sanctuary")and not string.match(dA.name,"Space")then m5=m5 .."<text x='"..hg.."' y='"..hh+dA.radius/m6*30+20 .."' font-size='12' fill="..co.." text-anchor='middle' font-family='Montserrat'>"..dA.name.."</text>"end end end;local fA=vec3(b.getConstructWorldPos())local hg=lE+lG+fA.x/m6;local hh=lF+lG*1.5/2+fA.y/m9;m5=m5 ..'<circle cx="'..hg..'" cy="'..hh..'" r="2" stroke="white" stroke-width="1" fill="red"/>'m5=m5 .."<text x='"..hg.."' y='"..hh-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"ir=m6;is=m9;local mc=fA+cX*1000000;local md=lE+lG+mc.x/m6;local jc=lF+lG*1.5/2+mc.y/m9;m5=m5 ..'<line x1="'..hg..'" y1="'..hh..'" x2="'..md..'" y2="'..jc..'" stroke="purple" stroke-width="1"/>'jr[#jr+1]=m5;jr[#jr+1]='</g>'end elseif bB=="INFO"then jr=cB.DrawOdometer(jr,c5,bi,c6)elseif bB=="HELP"then jr=lx(jr)elseif bB=="SCOPE"then jr[#jr+1]='<g clip-path="url(#orbitRect)">'local me=dk;if ci>0 then table.sort(dj,function(eE,eF)local eG,eH=eE.center,eF.center;return(eG.x-d0.x)^2+(eG.y-d0.y)^2+(eG.z-d0.z)^2<(eH.x-d0.x)^2+(eH.y-d0.y)^2+(eH.z-d0.z)^2 end)end;local gQ={}local mf={}local mg=120;local mh=nil;local mi=nil;for K,dA in ipairs(dj)do local gP=dA.center-d0;local mj=gP:len()local mk=gP:normalize()local ml=gP:cross(cU):normalize()local mm=math.acos(ml:dot(cV))if mm~=mm then mm=0 end;if ml:cross(cV):dot(cU)<0 then mm=-mm end;local mn=gP:project_on_plane(cU):len()local mo=math.sin(mm)*math.asin(mn/mj)*constants.rad2deg;local mp=math.cos(mm)*math.asin(mn/mj)*constants.rad2deg;if mk:dot(cU)<0 then mp=90*math.cos(mm)+90*math.cos(mm)-mp;mo=90*math.sin(mm)+90*math.sin(mm)-mo end;local hg=lX+mo/me*lT;local hh=lY+mp/me*lT;local mq=(hg-lX)*(hg-lX)+(hh-lY)*(hh-lY)local mr=math.asin((dA.radius+dA.surfaceMaxAltitude)/mj)*constants.rad2deg;if mr~=mr then mr=me end;local hM=mr/me*lT;local ms=math.asin(dA.atmosphereRadius/mj)*constants.rad2deg;if ms~=ms then ms=mr end;local mt=ms/me*lT;local cb=ij(mj,1)local mu=dA.name;local mv=false;if hh>lF then if hh>l_ then if hh-mt<=l_ then mv=true end else mv=true end else if hh+mt>=lF then mv=true end end;local mw=false;local mx=hg;if dA.systemId==0 then mx=hg+mg else mx=hg-mg end;if mx+mg>lE then if mx+mg>lZ then if mx-mt-mg<=lZ then mw=true end else mw=true end else if mx+mt+mg>=lE then mw=true end end;local my={}my.x=hg;my.y=hh;my.planet=dA;my.atmoSize=mt;if not mh or mq<mh then mh=mq;mi=my end;if mw and mv then local mz=math.max(mt,5)if mq<mz*mz then mu=mu.." - "..cb end;my.size=hM;my.i=K;my.displayString=mu;my.distance=cb;my.visible=true;mf[#mf+1]=my else my.visible=false end end;local mA=false;table.sort(mf,function(eG,eH)return eG.y<eH.y end)for dO,fD in ipairs(mf)do local dA,hM,K,mt,hg,hh,mu,cb=fD.planet,fD.size,fD.i,fD.atmoSize,fD.x,fD.y,fD.displayString,fD.distance;local lR,mB,mC,mD;local mE=15;local jl="pdim"if dA.systemId~=0 then mC=iJ(string.len(mu)*5)mE=-(15+mC)mD=iK(10)jl="pdimfill"else mC=iJ(string.len(mu)*9)mD=iK(15)end;if hM*2>mC then lR=dp(hg,lE+mC/2,lZ-mC/2)mB=dp(hh,lF+mD,l_-5)lR=dp(lR,hg-hM+mC/2,hg+hM-mC/2)mB=dp(mB,hh-hM+mD,hh+hM)else lR=hg+mE;mB=hh end;for mF,fD in pairs(gQ)do local mG=fD.textPositions;local mH=mG.y-mB;if mF~=K and f2(mH)<mG.height and mG.x+mG.width>lR and mG.x<lR+mC then if hM>mC then mB=dp(mB+mD,lF+15,l_-5)else mB=mG.y+mG.height+1 end end end;local mI=mu~=dA.name or lR<=lX and lR+mC>=lX and mB-mD<=lY and mB>=lY;fD.hovered=mI;local mJ=1;if mI then mJ=2;if hM*2<mC then mJ=10 end;if mu==dA.name then mu=mu.." - "..cb end;jl="pbright"if dA.systemId~=0 then mC=iJ(string.len(mu)*5)mE=-(15+mC)else mC=iJ(string.len(mu)*7)end;if hM*2>mC then lR=dp(hg,lE+mC/2,lZ-mC/2)lR=dp(lR,hg-hM+mC/2,hg+hM-mC/2)else lR=hg+mE end end;gQ[K]={}gQ[K].textPositions={}gQ[K].textPositions.y=mB;gQ[K].textPositions.x=lR;gQ[K].textPositions.width=mC;gQ[K].textPositions.height=mD;gQ[K].output=""if hM*2>mC then jl=jl.." txtmid"else jl=jl.." txtstart"end;if mt-hM>2 then gQ[K].output=dn('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hg,hh,mt,cp,0.1*mJ)end;gQ[K].output=gQ[K].output..dn('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hg,hh,hM,cp,0.2*mJ)if dA.systemId==0 then gQ[K].output=gQ[K].output..dn([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lR,mB,co,jl,mu)if hM*2<=mC then gQ[K].output=gQ[K].output..dn("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lR+mC,mB+2,lR,mB+2,hg,hh)end else gQ[K].output=gQ[K].output..dn([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lR,mB,cp,jl,mu)if hM*2<=mC then gQ[K].output=gQ[K].output..dn("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lR,mB+2,lR+mC,mB+2,hg,hh)end end end;for dO=#dj,1,-1 do if gQ[dO]then jr[#jr+1]=gQ[dO].output end end;if mi~=nil and dk<90 and not mi.hovered then local mK=mi.planet.atmosphereRadius/mi.atmoSize;local mL=dr(mh)*mK;local mM=ij(mL,1)local mC=iJ(math.max(string.len(mM)*7,string.len(mi.planet.name)*7))local mD=iK(12)local lR=dp(mi.x+(lX-mi.x)/2,lE+mC/2,lZ-mC/2)local mB=dp(mi.y+(lY-mi.y)/2,lF+mD*2,l_-5)jr[#jr+1]=dn("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mi.x,mi.y,lX,lY)jr[#jr+1]=dn([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lR,mB,"white",mM)if not mi.visible then jr[#jr+1]=dn([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lR,mB-mD,"white",mi.planet.name)end end;if cY>1 then local gP=cX;local mk=gP:normalize()local mn=gP:project_on_plane(cU):len()local ml=gP:cross(cU):normalize()local mm=math.acos(ml:dot(cV))if mm~=mm then mm=0 end;if ml:cross(cV):dot(cU)<0 then mm=-mm end;local mo=math.sin(mm)*math.asin(mn/gP:len())*constants.rad2deg;local mp=math.cos(mm)*math.asin(mn/gP:len())*constants.rad2deg;if mk:dot(cU)<0 then mp=90*math.cos(mm)+90*math.cos(mm)-mp;mo=90*math.sin(mm)+90*math.sin(mm)-mo end;local hg=lX+mo/me*lT;local hh=lY+mp/me*lT;local km=14;local kn=km/2;local kq=[[<circle
                                    cx="]]..hg..[["
                                    cy="]]..hh..[["
                                    r="]]..kn/km..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hg..[["
                                    cy="]]..hh..[["
                                    r="]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hg-km..[[,]]..hh..[[ h ]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hg+kn..[[,]]..hh..[[ h ]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hg..[[,]]..hh-km..[[ v ]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jr[#jr+1]=kq end;jr[#jr+1]=dn("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",lX,lY-10,lX,lY+10)jr[#jr+1]=dn("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",lX-10,lY,lX+10,lY)jr[#jr+1]='</g>'else return jr end end;local function mN(mO,mP)local mQ;local mR=(mP-mO):normalize()local fB=(d0-mO):dot(mR)/mR:dot(mR)if fB<=0. then return(d0-mO):len()elseif fB>=(mP-mO):len()then return(d0-mP):len()end;local mS=mO+fB*mR;mQ=(mS-d0):len()return mQ end;local function mT()local mQ;local mU=nil;local mV=nil;local mW=nil;for dO,mX in pairs(e[0])do if mX.hasAtmosphere then local cb=mN(iI.center,mX.center)if mU==nil or cb<mU then mV=mX;mU=cb;mW=iI end;if c4 and c4.hasAtmosphere and c4.name~=iI.name then local eT=mN(c4.center,mX.center)if eT<mU then mV=mX;mU=eT;mW=c4 end end end end;local mY=iJ(1770)local mZ=iK(330)if mU then local m_="txttick "local n0=500000;if mU<mV.radius+n0 or mU<mW.radius+n0 then if d8 then m_="txttick red "else m_="txttick orange "end end;mQ=ij(mU,2)iw=gI(mY,mZ,"Pipe ("..mW.name.."--"..mV.name.."): "..mQ,m_.."pbright txtmid")end end;local function n1(hg,hh,n2,n3,kz)local n4={x=hg,y=hh,width=n2,height=n3,label=kz}iq[kz]=n4;return n4 end;local function n5(n6,n7,n2,n3,hg,hh,n8,n9,na,nb,jl)local n4={enableName=n6,disableName=n7,width=n2,height=n3,x=hg,y=hh,toggleVar=n8,toggleFunction=n9,drawCondition=na,hovered=false,class=jl}if nb then table.insert(ip,n4)else table.insert(io,n4)end;return n4 end;local function nc(nd)if not iu then ne=false;nf=false;ng=false;x=true;return elseif nd=="handling"then ne=not ne;nf=false;ng=false elseif nd=="hud"then nf=not nf;ne=false;ng=false elseif nd=="physics"then ng=not ng;ne=false;nf=false end;if ng or nf or ne then iv=ii(nd)x=false else iv="none"x=true end end;local function nh()iu=not iu;if iu then im=ip;c0="Hold SHIFT to see Settings"dl=x else im=io;c0="Hold SHIFT to see Control Buttons"nc()x=dl end end;local function ni()local function nj(dA,dO)dA.set(not dA.get())if dA.get()then c0=dO.." set to true"else c0=dO.." set to false"end;if dO=="showHud"then dl=dA.get()elseif dO=="BrakeToggleDefault"then aU=j end end;local nk=50;local nl=340;local hg=500;local hh=cs/2-400;local nm=0;for dO,dA in pairs(ii("boolean"))do if type(dA.get())=="boolean"then n5(dO,dO,nl,nk,hg,hh,function()return dA.get()end,function()nj(dA,dO)end,function()return true end,true)hh=hh+nk+20;if nm==9 then hg=hg+nl+20;hh=cs/2-400;nm=0 else nm=nm+1 end end end;n5("Control View","Control View",nl,nk,10,cs/2-500,function()return true end,nh,function()return true end,true)n5("View Handling Settings",'Hide Handling Settings',nl,nk,10,cs/2-(500-nk),function()return ne end,function()nc("handling")end,function()return true end,true)n5("View Hud Settings",'Hide Hud Settings',nl,nk,10,cs/2-(500-nk*2),function()return nf end,function()nc("hud")end,function()return true end,true)n5("View Physics Settings",'Hide Physics Settings',nl,nk,10,cs/2-(500-nk*3),function()return ng end,function()nc("physics")end,function()return true end,true)end;local function nn()local function gx()local g0=d0;local gy=iI.name..". "..#bk;if radar_1 then gy=cE.GetClosestName(gy)end;return cC.AddNewLocation(gy,g0,false,true)end;local function no()a_=not a_ end;local function np(nq)if nq==1 then aY=not aY;aX=false else aX=not aX;aY=false end;aZ=false;b0=false;bZ=false;b1=false;bo=nil;b3=false;b2=false end;local function nr()cC.UpdatePosition()end;local function gv()cC.ClearCurrentPosition()end;local function ns(gw)local lw=cD.routeWP(true)if lw and#lw>0 then return"Engage Route: "..lu(lw[1])end;return"Engage Autopilot: "..lu(gw)end;local function nt(gw)local lw=cD.routeWP(true)if lw and#lw>0 then return"Next Route Point: "..lu(lw[1])end;return"Disable Autopilot: "..lu(gw)end;local function nu()if ic()==1 then bZ=not bZ;if bZ then aZ=false;aX=false;aY=false;b0=false;b3=false;b1=false;b2=false;nv=bh;bh=false;d.control.retractLandingGears()id:setTargetGroundAltitude(X)fZ("folOn","F")else fZ("folOff","F")aW=true;cI=p;bh=nv;if bh then d.control.extendLandingGears()id:setTargetGroundAltitude(Y)end end else c0="Follow Mode only works with Remote controller"bZ=false end end;local nk=50;local nl=260;local nw=iJ(30)local nx=av+au*2+2;local ny=aw+1;n5("+","+",nw,nw,nx,ny+nw+1,function()return false end,function()dk=dk/8 end,function()return bB=="SCOPE"end,nil,"ZoomButton")n5("-","-",nw,nw,nx,ny,function()return false end,function()dk=math.min(dk*8,90)end,function()return bB=="SCOPE"end,nil,"ZoomButton")n5("0","0",nw,nw,nx,ny+nw*2+2,function()return false end,function()dk=90 end,function()return bB=="SCOPE"and dk~=90 end,nil,"ZoomButton")local nz=n5("Enable Brake Toggle","Disable Brake Toggle",nl,nk,cr/2-nl/2,cs/2+350,function()return aU end,function()aU=not aU;if aU then c0="Brakes in Toggle Mode"else c0="Brakes in Default Mode"end end)n5("Align Prograde","Disable Prograde",nl,nk,cr/2-nl/2-50-nz.width,cs/2-nk+380,function()return aY end,function()np(1)end)n5("Align Retrograde","Disable Retrograde",nl,nk,cr/2-nl/2+nz.width+50,cs/2-nk+380,function()return aX end,np,function()return ci==0 end)nA=n5(ns,nt,600,60,cr/2-600/2,cs/2-60/2-330,function()return aZ or bl or ce or bu end,function()end)local K;local function nB(nC)local lw=cD.routeWP(true)if lw and#lw>0 then return lw[1]end;local gw=dg+nC;if gw>#d7 then gw=gw-#d7-1 end;if gw<0 then gw=#d7+gw end;return gw end;nD={}for K=0,10 do local nE=n5(function(eH)local gw=nB(eH.apExtraIndex)if aZ or bl or ce or bu then return"Redirect: "..lu(gw)end;return ns(gw)end,function(eH)local gw=nB(eH.apExtraIndex)return nt(gw)end,600,60,cr/2-600/2,cs/2-60/2-330+60*K,function(eH)local gw=nB(eH.apExtraIndex)return gw==bg and(aZ or bl or ce or bu)end,function(eH)local gw=nB(eH.apExtraIndex)local nF=bg==gw;bg=gw;cC.UpdateAutopilotTarget()cD.ToggleAutopilot()if not nF and not(aZ or bl or ce or bu)then cD.ToggleAutopilot()end end,function()return df and(#cD.routeWP(true)==0 or K==0)end)nE.apExtraIndex=K;nD[K]=nE end;n5("Save Position","Save Position",200,nA.height,nA.x+nA.width+30,nA.y,function()return false end,gx,function()return bg==0 or g8==nil end)n5("Update Position","Update Position",200,nA.height,nA.x+nA.width+30,nA.y,function()return false end,nr,function()return bg>0 and g8~=nil end)n5("Clear Position","Clear Position",200,nA.height,nA.x-200-30,nA.y,function()return true end,gv,function()return bg>0 and g8~=nil end)n5("Save Route","Save Route",200,nA.height,nA.x+nA.width+30,nA.y+nA.height+20,function()return false end,function()cD.routeWP(false,false,2)end,function()return#cD.routeWP(true)>0 end)n5("Load Route","Clear Route",200,nA.height,nA.x-200-30,nA.y+nA.height+20,function()return#cD.routeWP(true)>0 end,function()if#cD.routeWP(true)>0 then cD.routeWP(false,true)elseif aZ or bl then c0="Disable Autopilot before loading route"return else cD.routeWP(false,false,1)end end,function()return true end)nk=60;nl=300;local hg=0;local hh=cs/2-150;n5("View Settings","View Settings",nl,nk,hg,hh,function()return true end,nh)hh=hh+nk+20;n5("Enable Turn and Burn","Disable Turn and Burn",nl,nk,hg,hh,function()return a_ end,no)hg=10;hh=cs/2-300;n5("Horizontal Takeoff Mode","Vertical Takeoff Mode",nl,nk,hg+nl+20,hh,function()return aV end,function()aV=not aV;if aV then c0="Vertical Takeoff Mode"else c0="Horizontal Takeoff Mode"end end,function()return d1 end)hh=hh+nk+20;n5("Engage Orbiting","Cancel Orbiting",nl,nk,hg+nl+20,hh,function()return bu end,cD.ToggleIntoOrbit,function()return ci==0 and dc end)hh=cs/2-150;n5("Glide Re-Entry","Cancel Glide Re-Entry",nl,nk,hg+nl+20,hh,function()return b3 end,function()cd=1;np(1)end,function()return iI.hasAtmosphere and not ch end)hh=hh+nk+20;n5("Parachute Re-Entry","Cancel Parachute Re-Entry",nl,nk,hg+nl+20,hh,function()return b3 end,function()cd=2;np(1)end,function()return iI.hasAtmosphere and not ch end)hh=hh+nk+20;n5("Engage Follow Mode","Disable Follow Mode",nl,nk,hg,hh,function()return bZ end,nu,function()return ic()==1 end)n5("Enable Repair Arrows","Disable Repair Arrows",nl,nk,hg+nl+20,hh,function()return cw end,function()cw=not cw;if cw then c0="Repair Arrows Enabled"else c0="Repair Arrows Diabled"end end,function()return ic()==1 end)hh=hh+nk+20;if not q then n5("Enable AGG","Disable AGG",nl,nk,hg,hh,function()return d2 end,cD.ToggleAntigrav,function()return antigrav~=nil end)end;n5(function()return dn("Switch IPH Mode - Current: %s",bv)end,function()return dn("IPH Mode: %s",bv)end,nl*2,nk,hg,hh,function()return false end,function()if bv=="All"then bv="Custom Only"elseif bv=="Custom Only"then bv="No Moons"else bv="All"end;c0="IPH Mode: "..bv end)hh=hh+nk+20;n5(function()return dn("Toggle Control Scheme - Current: %s",g)end,function()return dn("Control Scheme: %s",g)end,nl*2,nk,hg,hh,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c0="New Control Scheme: "..g end)local nG=iK(20)local nE=n1(0,0,iJ(70),nG,"HELP")nE=n1(nE.x+nE.width,nE.y,iJ(80),nG,"INFO")nE=n1(nE.x+nE.width,nE.y,iJ(70),nG,"ORBIT")nE=n1(nE.x+nE.width,nE.y,iJ(70),nG,"SCOPE")n1(nE.x+nE.width,nE.y,iJ(70),nG,"HIDE")end;local nH={}local nI=nil;function nH.HUDPrologue(jr)d8,d9=iG(d0)if not d8 then bH=ae;bJ=af;bI=ag;if i9 and G and i9.getState()==0 then i9.toggle()end else bH=ab;bJ=ac;bI=ad;if i9 and G and i9.getState()==1 then i9.toggle()end end;co=[[rgb(]]..bE(bH+0.6)..","..bE(bJ+0.6)..","..bE(bI+0.6)..[[)]]cp=[[rgb(]]..bE(bH*0.8+0.5)..","..bE(bJ*0.8+0.5)..","..bE(bI*0.8+0.5)..[[)]]local nJ=co;local nK=cp;local nL=[[rgb(]]..bE(bH*0.4+0.5)..","..bE(bJ*0.4+0.5)..","..bE(bI*0.4+0.5)..[[)]]local nM=co;local nN=cp;local nO=nL;if iL()and not m then nJ=[[rgb(]]..bE(bH*0.5+0.5)..","..bE(bJ*0.5+0.5)..","..bE(bI*0.5+0.5)..[[)]]nK=[[rgb(]]..bE(bH*0.3+0.5)..","..bE(bJ*0.3+0.5)..","..bE(bI*0.2+0.5)..[[)]]nL=[[rgb(]]..bE(bH*0.2+0.5)..","..bE(bJ*0.2+0.5)..","..bE(bI*0.2+0.5)..[[)]]end;local lj=iJ;local lk=iK;jr[#jr+1]=dn([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nJ,nJ,nJ,nM,nM,nK,nK,nN,nN,nK,nJ,nL,nN,nJ,nJ,nL,nL,nO,nL,cr,cs,nK,nK,nK,nK,nK,nM,nK,nN,nO,nN,nN,nO)if not nI then nI=dn([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lj(630),lk(0),lj(675),lk(45),lj(960),lk(55),lj(1245),lk(45),lj(1290),lk(0),lj(1000),lk(105),lj(1040),lk(59),lj(1250),lk(51),lj(1300),lk(0),lj(1920),lk(0),lj(1920),lk(20),lj(1400),lk(20),lj(1300),lk(105),lj(920),lk(105),lj(880),lk(59),lj(670),lk(51),lj(620),lk(0),lj(0),lk(0),lj(0),lk(20),lj(520),lk(20),lj(620),lk(105),lj(890),lk(59),lj(960),lk(62),lj(1030),lk(59),lj(985),lk(112),lj(1150),lk(112),lj(1100),lk(152),lj(820),lk(152),lj(780),lk(112),lj(935),lk(112),lj(890),lk(59),lj(960),lk(62),lj(1030),lk(59),lj(985),lk(112),lj(1150),lk(112),lj(1100),lk(152),lj(820),lk(152),lj(780),lk(112),lj(935),lk(112))end;if x and I then jr[#jr+1]=nI end;return jr end;function nH.DrawVerticalSpeed(jr,e7)jq(jr,e7)end;function nH.UpdateHud(jr)local kf=d5;local nP=d6;local jy=nP;local jO=kf;local kx=bE(c.getThrottle())local kC=cY*3.6;local ky=c.getAxisCommandValue(0)local nQ=iJ(1770)local nR=iK(310)if u and d4 then ky=bK;kx=bK*100 end;local iN=iM()local jz="ROLL"if kx==nil then kx=0 end;if not dc then if cY>5 then kf=ke(cW)nP=kg(cW)else kf=0;nP=0 end;jz="YAW"end;if d9>50000 and not ch then local nS;nS=ij(d9)jr[#jr+1]=gI(nQ,nR,"PvP Boundary: "..nS,"pbright txtbig txtmid")end;jr[#jr+1]=cc;jr[#jr+1]=cq;jr[#jr+1]=i2;if iw~=""then jr[#jr+1]=iw end;if iO~=""then jr[#jr+1]=iO end;if iP~=""then jr[#jr+1]=iP end;jq(jr,cj)if ic()==0 or l then if dc then jx(jr,ah,ai,jy,jz,dc)else jx(jr,ah,ai,nP,jz,dc)end;if not iL()or m then if dc then jx(jr,ah,ai,jy,jz,dc)jN(jr,jO,jy,ah,ai,dc,bE(kg(cW)),cY)else jx(jr,ah,ai,nP,jz,dc)jN(jr,kf,nP,ah,ai,dc,bE(nP),cY)end;jU(jr,cj,dc)kh(jr,cW,cY,ah,ai)end end;kw(jr,iN,kx,ky)kB(jr,kC)kF(jr)lD(jr)if not iu and b_ then lv(jr)end;return jr end;function nH.HUDEpilogue(jr)jr[#jr+1]="</svg>"return jr end;function nH.ExtraData(jr)local nT=iJ(1240)local nU=iK(55)local nV=nU+10;local gB;local lj=iJ;local lk=iK;local nW=0;local iN=iM()if aV then iN=iN.."-VERTICAL"end;if F and not b2 and not b1 and cY>20 then iN=iN.."-COLLISION ON"end;if bx~="Off"then iN="("..bx..")-"..iN end;if a_ then iN="TB-"..iN end;if not bw then iN=iN.."-DeCoupled"end;local nX=lk(99)local nY=lk(80)local nZ=lk(85)local n_=lk(31)local o0=0;local o1=0;local o2=cl>1000000 and ig(cl/1000000,2).."kT"or ig(cl/1000,2).."T"if ch then nW=bp else nW=bn end;local o3,o4=cy.computeDistanceAndTime(cY,0,cl,0,0,nW)if o3<0 then o3=0 end;nW=ig(nW/(cl*il),2).."g"local o5=d:maxForceForward()gB=b.g()if gB>0.1 then o1=cl*gB;o1=ig(o1/(cl*il),2).."g"o0=0.5*o5/gB;o0=o0>1000000 and ig(o0/1000000,2).."kT"or ig(o0/1000,2).."T"end;o5=ig(o5/(cl*il),2).."g"local o6=vec3(b.getWorldAcceleration()):len()/9.80665;gB=b.g()jr[#jr+1]=[[<g class="dim txt txtend size14">]]if ic()==1 and not l then nT=iJ(1120)nU=iK(55)nV=nU+10 elseif ch and I then local o7=iJ(770)jr[#jr+1]=gI(lj(895),nX,"ATMO","")jr[#jr+1]=dn([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lj(895),nZ,lj(-80))jr[#jr+1]=gI(lj(815),nY,dn("%.1f%%",ci*100),"txtstart size20")end;if I then jr[#jr+1]=gI(lj(1025),nX,"GRAVITY","txtstart")jr[#jr+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(1025),nZ,lj(80))jr[#jr+1]=gI(lj(1105),nY,dn("%.2fg",gB/9.80665),"size20")jr[#jr+1]=gI(lj(1125),nX,"ACCEL","txtstart")jr[#jr+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(1125),nZ,lj(80))jr[#jr+1]=gI(lj(1205),nY,dn("%.2fg",o6),"size20")jr[#jr+1]=gI(lj(695),nX,"BRK TIME","")jr[#jr+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(695),nZ,lj(-80))jr[#jr+1]=gI(lj(615),nY,dn("%s",ik(o4)),"txtstart size20")jr[#jr+1]=gI(lj(635),lk(45),"TRIP","")jr[#jr+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(635),lk(31),lj(-90))if ld then jr[#jr+1]=gI(lj(532),lk(23),dn("%s",ik(ld)),"txtstart size20")end;jr[#jr+1]=gI(lj(795),nX,"BRK DIST","")jr[#jr+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(795),nZ,lj(-80))jr[#jr+1]=gI(lj(715),nY,dn("%s",ij(o3)),"txtstart size20")jr[#jr+1]=gI(lj(1285),lk(45),"MASS","txtstart")jr[#jr+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(1285),lk(31),lj(90))jr[#jr+1]=gI(lj(1388),lk(23),dn("%s",o2),"size20")jr[#jr+1]=gI(lj(1220),nX,"THRUST","txtstart")jr[#jr+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(1220),nZ,lj(80))jr[#jr+1]=gI(lj(1300),nY,dn("%s",o5),"size20")jr[#jr+1]=gI(iJ(960),iK(175),iN,"pbright txtbig txtmid size20")end;jr[#jr+1]="</g>"end;function nH.DrawOdometer(jr,c5,bi,c6)if bB~="INFO"then return jr end;local gB;local o0=0;local o1=0;local nW=0;local o2=cl>1000000 and ig(cl/1000000,2).." kTons"or ig(cl/1000,2).." Tons"if ch then nW=bp else nW=bn end;local o3,o4=cy.computeDistanceAndTime(cY,0,cl,0,0,nW)nW=ig(nW/(cl*il),2).." g"local o5=d:maxForceForward()gB=b.g()if gB>0.1 then o1=cl*gB;o1=ig(o1/(cl*il),2).." g"o0=0.5*o5/gB;o0=o0>1000000 and ig(o0/1000000,2).." kTons"or ig(o0/1000,2).." Tons"end;o5=ig(o5/(cl*il),2).." g"if ic()==0 or l then local o8=iJ(av+10)local o9=iK(aw+20)local oa=iJ(av+10+au/1.25)local n3=25;jr[#jr+1]="<g class='txtstart size14 bright'>"jr[#jr+1]=gI(o8,o9,dn("BrkTime: %s",ik(o4)))jr[#jr+1]=gI(oa,o9,dn("Trip: %.2f km",c5))jr[#jr+1]=gI(o8,o9+n3,dn("Lifetime: %.2f kSU",bi/200000))jr[#jr+1]=gI(oa,o9+n3,dn("BrkDist: %s",ij(o3)))jr[#jr+1]=gI(o8,o9+n3*2,"Trip Time: "..ik(c6))jr[#jr+1]=gI(oa,o9+n3*2,"Total Time: "..ik(bj))jr[#jr+1]=gI(o8,o9+n3*3,dn("Mass: %s",o2))jr[#jr+1]=gI(oa,o9+n3*3,dn("Max Brake: %s",nW))jr[#jr+1]=gI(o8,o9+n3*4,dn("Max Thrust: %s",o5))if gB>0.1 then jr[#jr+1]=gI(oa,o9+n3*4,dn("Max Thrust Mass: %s",o0))jr[#jr+1]=gI(o8,o9+n3*5,dn("Req Thrust: %s",o1))else jr[#jr+1]=gI(oa,o9+n3*5,"Max Mass: n/a")jr[#jr+1]=gI(o8,o9+n3*6,"Req Thrust: n/a")end end;jr[#jr+1]="</g></g>"return jr end;function nH.DrawWarnings(jr)return kF(jr)end;function nH.DisplayOrbitScreen(jr)return lD(jr)end;function nH.DisplayMessage(jr,l0)if l0~="empty"then local hh=310;for ob in string.gmatch(l0,"([^\n]+)")do hh=hh+35;jr[#jr+1]=gI("50%",hh,ob,"msg")end end;if ca~=0 then c.setTimer("msgTick",ca)ca=0 end end;function nH.DrawDeadZone(jr)jr[#jr+1]=dn([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],at)end;function nH.UpdatePipe()if ch then iw=""return end;mT()end;function nH.DrawSettings(jr)local hg=iJ(640)local hh=iK(200)jr[#jr+1]=[[<g class="pbright txtvspd txtstart">]]local hK=0;for dO,dA in pairs(iv)do hK=hK+1;jr[#jr+1]=gI(hg,hh,dO..": "..dA.get())hh=hh+20;if hK%12==0 then hg=hg+iJ(350)hh=iK(200)end end;jr[#jr+1]=gI(iJ(640),iK(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jr[#jr+1]="</g>"return jr end;local i4;local h_=iJ(1770)local i0=iK(350)local hZ=iK(15)local hY=iJ(1370)local i3,oc;local i5=0;function nH.DrawRadarInfo()i2=cE.GetRadarHud(hY,hZ,h_,i0)end;function nH.DrawTanks()if ap~=0 and aq~=0 then iO=gI(ap,aq,"","txtstart pdim txtfuel")jb=aq;j4(ap,"Atmospheric ","ATMO",ct,j2,j3)j4(ap,"Space Fuel T","SPACE",cu,j0,j1)j4(ap,"Rocket Fuel ","ROCKET",cv,iZ,i_)end end;function nH.DrawShield()local od=i9.getState()==1 and"Shield Active"or"Shield Disabled"local oe=b.getPvPTimer()local of=i9.getResistances()local og="A: "..10+of[1]*100 .."% / E: "..10+of[2]*100 .."% / K:"..10+of[3]*100 .."% / T: "..10+of[4]*100 .."%"local hg,hh=ar-60,as+30;local oh=bE(0.5+i9.getShieldHitpoints()*100/i9.getMaxShieldHitpoints())local jj=bE(oh*2.55)local jk=dn("rgb(%d,%d,%d)",255-jj,jj,0)local jl=""iP=gI(hg,hh,"","txtmid pdim txtfuel")if oh<10 and od~="Shield Disabled"then jl="red "end;oe=oe>0 and"   PvPTime: "..ik(oe)or""iP=iP..dn([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hg,hh,jk,oh*2,hg,hh,hg+2,hh+10,oh,oe)iP=iP..gI(hg,hh-5,od,jl.."txtstart pbright txtbig")iP=iP..gI(hg,hh+30,og,jl.."txtstart pbright txtsmall")end;function nH.hudtick()if not iI then return end;local function oi(jr)local jn=bE(dp(cb/(cr/4)*255,0,255))jr[#jr+1]=dn("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c8,c9,bE(bH+0.5)+jn,bE(bJ+0.5)-jn,bE(bI+0.5)-jn)end;local function oj()for dT,dA in pairs(im)do if dA.hovered then if not dA.drawCondition or dA.drawCondition(dA)then dA.toggleFunction(dA)end;dA.hovered=false end end;for dT,dA in pairs(iq)do if dA.hovered then bB=dA.label;dA.hovered=false end end end;local function ok()local function ol(om,on,hg,hh,n2,n3)if om>=hg and om<=hg+n2 and on>=hh and on<=hh+n3 then return true else return false end end;local hg=c8+cr/2;local hh=c9+cs/2;for dT,dA in pairs(im)do dA.hovered=ol(hg,hh,dA.x,dA.y,dA.width,dA.height)end;for dT,dA in pairs(iq)do dA.hovered=ol(hg,hh,dA.x,dA.y,dA.width,dA.height)end;if df then local mI=false;for dT,eH in ipairs(nD)do if eH.hovered then mI=true;break end end;if nA.hovered then mI=true end;df=mI else df=nA.hovered;if not df then dg=bg end end end;local function oo(jr)if not bB or bB==""then bB="HELP"end;if x then for dO,dA in pairs(iq)do local jl="dim brightstroke"local op=0.2;if bB==dO then jl="pbright dimstroke"op=0.6 end;local oq=""if dA.hovered then op=0.8;oq=";stroke:white"end;jr[#jr+1]=dn([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dA.width,dA.height,dA.x,dA.y,jl,op,oq)jr[#jr+1]=gI(dA.x+dA.width/2,dA.y+dA.height/2+5,dA.label,"txt txtmid pdim")end end end;local function os(jr)local function ot(jr,ou,hover,hg,hh,fn,ov,ow,ox,oy,oz,nE)if type(oy)=="function"then oy=oy(nE)end;if type(oz)=="function"then oz=oz(nE)end;jr[#jr+1]=dn("<rect x='%f' y='%f' width='%f' height='%f' fill='",hg,hh,fn,ov)if ou then jr[#jr+1]=dn("%s'",ow)else jr[#jr+1]=ox end;if hover then jr[#jr+1]=dn(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ab,ac,ad)else jr[#jr+1]=dn(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",ig(ab*0.5,0),ig(ac*0.5,0),ig(ad*0.5,0))end;jr[#jr+1]=" rx='5'></rect>"jr[#jr+1]=dn("<text x='%f' y='%f' font-size='24' fill='",hg+fn/2,hh+ov/2+5)if ou then jr[#jr+1]="black"else jr[#jr+1]="white"end;jr[#jr+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if ou then jr[#jr+1]=dn("%s</text>",oy)else jr[#jr+1]=dn("%s</text>",oz)end end;local oA=dn("rgb(%d,%d,%d)'",ig(ab*0.1,0),ig(ac*0.1,0),ig(ad*0.1,0))local oB=dn("rgb(%d,%d,%d)",ig(ab*0.8,0),ig(ac*0.8,0),ig(ad*0.8,0))local oC=ot;for dT,dA in pairs(im)do local n7=dA.disableName;local n6=dA.enableName;if type(n7)=="function"then n7=n7(dA)end;if type(n6)=="function"then n6=n6(dA)end;if not dA.drawCondition or dA.drawCondition(dA)then oC(jr,dA.toggleVar(dA),dA.hovered,dA.x,dA.y,dA.width,dA.height,oB,oA,n7,n6,dA)end end end;local oD=ig(cr/2,0)local oE=ig(cs/2,0)local jr={}cB.HUDPrologue(jr)if x then cB.UpdateHud(jr)else if B then cB.DrawVerticalSpeed(jr,cj)end;cB.DrawWarnings(jr)end;if iu and iv~="none"then cB.DrawSettings(jr)end;if radar_1 then cB.DrawRadarInfo()end;cB.HUDEpilogue(jr)jr[#jr+1]=dn([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cr,cs)if c0~="empty"then cB.DisplayMessage(jr,c0)end;if ic()==0 and g=="virtual joystick"then if w then cB.DrawDeadZone(jr)end end;oo(jr)if ie()==0 then if ic()==1 and b_ then if not oF then ok()os(jr)end;if not cG and not cH then local oG=table.concat(jr,"")jr={}jr[#jr+1]=dn("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jr[#jr+1]=oG;jr[#jr+1]="</body>"cG=true;jr[#jr+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local oH=table.concat(jr,"")a.setScreen(oH)elseif cH then local oG=table.concat(jr,"")jr={}jr[#jr+1]=dn("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jr[#jr+1]=oG;jr[#jr+1]="</body>"end;if not cG then jr[#jr+1]=dn([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oD,oE,c8,c9)end else oj()end else if not b_ and ic()==0 then oj()if cb>at then if w then oi(jr)end end elseif b_ and(not oF or not i)then ok()os(jr)end;jr[#jr+1]=dn([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oD,oE,c8,c9)end;jr[#jr+1]=[[</svg></body>]]oH=table.concat(jr,"")end;function nH.TenthTick()local function oI()local oJ=a.createData;local oK=a.createWidget;oL=a.createWidgetPanel("Interplanetary Helper")oM=oK(oL,"value")oN=oJ('{"label": "Target Planet", "value": "N/A", "unit":""}')fY(oN,oM)oO=oK(oL,"value")oP=oJ('{"label": "distance", "value": "N/A", "unit":""}')fY(oP,oO)gp=oK(oL,"value")go=oJ('{"label": "Travel Time", "value": "N/A", "unit":""}')fY(go,gp)gn=oK(oL,"value")gm=oJ('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fY(gm,gn)gr=oK(oL,"value")gq=oJ('{"label": "Target Altitude", "value": "N/A", "unit":""}')fY(gq,gr)gj=oK(oL,"value")gi=oJ('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gh=oK(oL,"value")gg=oJ('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gf=oK(oL,"value")ge=oJ('{"label": "Max Brake distance", "value": "N/A", "unit":""}')gd=oK(oL,"value")gc=oJ('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gl=oK(oL,"value")gk=oJ('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ch then fY(gi,gj)fY(gg,gh)fY(ge,gf)fY(gc,gd)fY(gk,gl)end end;local function oQ()gH(oL)oL=nil end;local function oR()if not aZ then if g8==nil or g8.planetname~=iI.name then oS=(c4.center-d0):len()else oS=(g8.position-d0):len()end end;local fu=cY;local oT=c.getThrottle()/100;if u then oT=bK end;local oU,oV=cy.computeDistanceAndTime(cY,_,cl,d:maxForceForward()*oT,a1,0)local c2,c3;if not a_ then c2,c3=cD.GetAutopilotBrakeDistanceAndTime(_)else c2,c3=cD.GetAutopilotTBBrakeDistanceAndTime(_)end;local dT,oW;if not a_ and fu>0 then dT,oW=cD.GetAutopilotBrakeDistanceAndTime(fu)else dT,oW=cD.GetAutopilotTBBrakeDistanceAndTime(fu)end;local oX=0;local oY=0;if b9 or not aZ and fu>5 then oY=cy.computeTravelTime(fu,0,oS)elseif c2+oU<oS then oX=oS-(c2+oU)oY=cy.computeTravelTime(8333.0556,0,oX)else local oZ=(oS-c2)/oU;oU=oS-c2;oV=oV*oZ end;if g8~=nil and g8.planetname==iI.name and not aZ then return oY elseif b8 then return oW elseif b9 then return oY+oW else return oV+c3+oY end end;cB.DrawTanks()if i9 then cB.DrawShield()end;if be~="None"then if oL==nil then oI()end;if be~=nil then local o_=g8~=nil;local p0=0.5*bp/c4:getGravity(c4.center+vec3(0,0,1)*c4.radius):len()p0=p0>1000000 and ig(p0/1000000,2).." kTons"or ig(p0/1000,2).." Tons"fX(oN,'{"label": "Target", "value": "'..be..'", "unit":""}')ld=oR()if o_ and not aZ then cb=(d0-g8.position):len()else cb=(bf-d0):len()end;if not a_ then c2,c3=cD.GetAutopilotBrakeDistanceAndTime(cY)iy,iz=cD.GetAutopilotBrakeDistanceAndTime(_)else c2,c3=cD.GetAutopilotTBBrakeDistanceAndTime(cY)iy,iz=cD.GetAutopilotTBBrakeDistanceAndTime(_)end;local l0=ij(cb)fX(oP,'{"label": "distance", "value": "'..l0 ..'"}')fX(go,'{"label": "Travel Time", "value": "'..ik(ld)..'", "unit":""}')l0=ij(c2)fX(gi,'{"label": "Cur Brake distance", "value": "'..l0 ..'"}')fX(gg,'{"label": "Cur Brake Time", "value": "'..ik(c3)..'", "unit":""}')l0=ij(iy)fX(ge,'{"label": "Max Brake distance", "value": "'..l0 ..'"}')fX(gc,'{"label": "Max Brake Time", "value": "'..ik(iz)..'", "unit":""}')fX(gm,'{"label": "Max Brake Mass", "value": "'..dn("%s",p0)..'", "unit":""}')l0=ij(gs)fX(gq,'{"label": "Target Orbit", "value": "'..l0 ..'"}')if ci>0 and not p1 then a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)a.removeDataFromWidget(gi,gj)a.removeDataFromWidget(gk,gl)p1=true;if not d4 and u and(b0 or b3 or cf)then cD.cmdThrottle(1)aW=false;bO=false end end;if ci==0 and p1 then if fX(gc,gd)==1 then fY(gc,gd)end;if fX(ge,gf)==1 then fY(ge,gf)end;if fX(gg,gh)==1 then fY(gg,gh)end;if fX(gi,gj)==1 then fY(gi,gj)end;if fX(gk,gl)==1 then fY(gk,gl)end;p1=false end end else oQ()end;if warpdrive~=nil then if ia(warpdrive.getData()).destination~="Unknown"and ia(warpdrive.getData()).distance>400000 then warpdrive.show()p2=true else warpdrive.hide()p2=false end end end;function nH.OneSecondTick(jr)local function p3()local jf=bD()local kC=cY;local p4=jf-ck;if kC>1.38889 then kC=kC/1000;local p5=kC*(jf-ck)bi=bi+p5;c5=c5+p5 end;c6=c6+p4;bj=bj+p4;ck=jf end;p3()cB.UpdatePipe()cB.ExtraData(jr)end;function nH.AnimateTick()cH=true;cG=false;c8=0;c9=0;c.stopTimer("animateTick")end;function nH.MsgTick()local jr={}cB.DisplayMessage(jr,"empty")c0="empty"c.stopTimer("msgTick")ca=3 end;function nH.ButtonSetup()ni()nn()im=io end;return nH end;local function p6(d,b,c,a,e,vBooster,hover,p7,antigrav,warpdrive,dbHud_1,f2,bE,bF,ic,eY,bD,dp,id,fX,ie,dr,ig,fZ,ih,ds,ij,ik,p8,ia,dn,fY)local p9={}local function pa(fu)local pb=ba;if not aZ then pb=0 end;if not ch then return cy.computeDistanceAndTime(fu,pb,cl,0,0,bn-bc*cl)else if bp and bp>0 then return cy.computeDistanceAndTime(fu,pb,cl,0,0,bp-bc*cl)else return 0,0 end end end;local function pc(fu)local pb=ba;if not aZ then pb=0 end;return cy.computeDistanceAndTime(fu,pb,cl,d:maxForceForward(),a1,bn-bc*cl)end;local pd=false;local pe=0;local pf=0;local pg=0;local ph=bD()local pi=0;local pj=0;local pk=0;local pl=0;local pm=false;local pn=false;local po=false;local pp=nil;local pq=0;local pr={}local ix=55;local ps=nil;local pt=""function p9.GetAutopilotBrakeDistanceAndTime(fu)return pa(fu)end;function p9.GetAutopilotTBBrakeDistanceAndTime(fu)return pc(fu)end;local function pu(pv,pw,px)pw=pw:project_on_plane(pv)px=px:project_on_plane(pv)return eY(pw:cross(px):dot(pv),pw:dot(px))end;local function py()local function pz()local pA=-1;local pB=-1;if vBooster then pA=vBooster.getDistance()end;if hover then pB=hover.getDistance()end;if pA~=-1 and pB~=-1 then if pA<pB then return pA else return pB end elseif pA~=-1 then return pA elseif pB~=-1 then return pB else return-1 end end;local pC=pz()local pD=-1;if p7 then pD=p7.getDistance()end;if pC~=-1 and pD~=-1 then if pC<pD then return pC else return pD end elseif pC~=-1 then return pC else return pD end end;local function pE(iI,eP,pF)local function pG(pH,d_)local eV=vec3(d_)if pH.id==0 then return setmetatable({latitude=eV.x,longitude=eV.y,altitude=eV.z,id=0,systemId=pH.systemId},e1)end;local eW=eV-pH.center;local cb=eW:len()local e7=cb-pH.radius;local e5=0;local e6=0;if not ds(cb,0)then local eX=eY(eW.y,eW.x)e6=eX>=0 and eX or 2*math.pi+eX;e5=math.pi/2-math.acos(eW.z/cb)end;return setmetatable({latitude=math.deg(e5),longitude=math.deg(e6),altitude=e7,id=pH.id,systemId=pH.systemId},e1)end;local pI=pG(iI,eP)pI="::pos{"..pI.systemId..","..pI.id..","..pI.latitude..","..pI.longitude..","..pI.altitude.."}"if pF then return pI else a.setWaypoint(pI)return true end end;local pJ=false;function p9.showWayPoint(iI,eP,pF)return pE(iI,eP,pF)end;function p9.APTick()local function pK()if de and not b1 then local ew=de[1]local hP,hQ=de[2],de[3]local pL=math.min(hP,hQ or hP)local pM=pL/cY;local pN=b2 and(cY<42 or cg~=-1)local pO=b0 or bl or bo or aZ;if pO and not pN and(c2*1.5>pL or pM<1)then aW=true;pr={}cD.cmdThrottle(0)if b0 then cD.ToggleAltitudeHold()end;if bo then cD.ToggleLockPitch()end;c0="Autopilot Cancelled due to possible collision"if bl or aZ then cD.ToggleAutopilot()end;l7=true;b1=true;cI=true end;if pM<11 then dd=ew.name.." COLLISION "..ik(pM).." / "..ij(pL,2)else dd=ew.name.." collision "..ik(pM)end;if pM<6 then fZ("alarm","AL",2)end else dd=false end end;local function pP(pQ,pR,pS)local function pT(pQ,ey)pQ=vec3(pQ)ey=vec3(ey):normalize()local dJ=pQ*ey;return dJ.x+dJ.y+dJ.z end;local pU=0.001;local pV=1;if not ch or not cJ or cg~=-1 or cY<ix then if pS==nil then pS=aN end;if pR==nil then pR=pU end;pQ=vec3(pQ):normalize()local pW=vec3()-pQ;local pX=-pT(pW,b.getConstructWorldOrientationRight())*pV;local pY=-pT(pW,b.getConstructWorldOrientationUp())*pV;if pf==0 then pf=pX/2 end;if pg==0 then pg=pY/2 end;if f2(pX)<0.1 then bU=bU-pX*2 else bU=bU-(pX+(pX-pf)*pS)end;if f2(pY)<0.1 then bT=bT+pY*2 else bT=bT+pY+(pY-pg)*pS end;pf=pX;pg=pY;if f2(pX)<pR and f2(pY)<pR then return true end;return false elseif cJ and cg==-1 then pQ=cX;if pS==nil then pS=aN end;if pR==nil then pR=pU end;pQ=vec3(pQ):normalize()local pW=cU-pQ;local pX=-pT(pW,b.getConstructWorldOrientationRight())*pV;local pY=-pT(pW,b.getConstructWorldOrientationUp())*pV;if pf==0 then pf=pX/2 end;if pg==0 then pg=pY/2 end;if f2(pX)<0.1 then bU=bU-pX*5 else bU=bU-(pX+(pX-pf)*pS)end;if f2(pY)<0.1 then bT=bT+pY*5 else bT=bT+pY+(pY-pg)*pS end;pf=pX;pg=pY;if f2(pX)<pR and f2(pY)<pR then return true end;return false end end;ch=bF()>0;ci=bF()cj=b.getAltitude()cg=py()bG=bD()ph=bG;if F then pK()end;if antigrav then d2=antigrav.getState()==1 end;local pZ=a.getMouseWheel()if pZ>0 then cD.changeSpd()elseif pZ<0 then cD.changeSpd(true)else cm=true end;local p_=1;local q0=1;local q1=bG-ph;local q2=-math.deg(pu(cT,cX,cU))local q3=math.deg(pu(cV,cX,cU))local gu=cZ*-1;cJ=ch and q2<-L or q2>L or q3<-M or q3>M;local q4=a.getMouseDeltaX()local q5=a.getMouseDeltaY()if o and not b_ then q5=-q5 end;bU=0;bY=0;bT=0;g1=cx[0]iI=g1:closestBody(b.getConstructWorldPos())q6=cA(iI)fy=q6:orbitalParameters(b.getConstructWorldPos(),cX)if cj==0 then cj=(d0-iI.center):len()-iI.radius end;dc=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;local gB=iI:getGravity(b.getConstructWorldPos()):len()*cl;cK=0;cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if ie()==0 then if ic()==1 and b_ then if not cG then c8=dp(c8+q4,-cr/2,cr/2)c9=dp(c9+q5,-cs/2,cs/2)end else c8=0;c9=0 end else c8=dp(c8+q4,-cr/2,cr/2)c9=dp(c9+q5,-cs/2,cs/2)cb=dr(c8*c8+c9*c9)if not b_ and ic()==0 then local ko,kp=1,1;if bB=="SCOPE"then ko,kp=dk/90,dk/90 end;if g=="virtual joystick"then if c8>0 and c8>at then bU=bU-(c8-at)*aB*ko elseif c8<0 and c8<at*-1 then bU=bU-(c8+at)*aB*ko else bU=0 end;if c9>0 and c9>at then bT=bT-(c9-at)*aC*kp elseif c9<0 and c9<at*-1 then bT=bT-(c9+at)*aC*kp else bT=0 end else c8=0;c9=0;if g=="mouse"then bT=(-utils.smoothstep(q5,-100,100)+0.5)*2*p_;bU=(-utils.smoothstep(q4,-100,100)+0.5)*2*q0 end end end end;local q7=cY>8334;if cY>V/3.6 and not ch and not aZ and not q7 then c0="Space Speed Engine Shutoff reached"cD.cmdThrottle(0)end;if not q7 and q8 then if not aW then cD.BrakeToggle()end;if aZ then cD.ToggleAutopilot()end end;q8=q7;if ch and ci>0.09 then if cY>cL/3.6 and not u and not pd then aW=true;pd=true elseif not u and pd then if cY<cL/3.6 then aW=false;pd=false end end end;if aW then bX=1 else bX=0 end;if aY then if cd then aW=false;local q9=false;if g8 and cd==true then q9=pP(g8.position-d0,0.1)else q9=pP(vec3(cX),0.01)end;cI=true;if q9 then cD.cmdCruise(bE(cL))if(f2(d6)<2 or f2(d5)>85)and cY>=cL/3.6-1 then aW=false;aY=false;if cd~=2 then bQ=true end;if cd==true then cf=true end;cd=false;aZ=false;cD.BeginReentry()end elseif ch and u then cD.cmdThrottle(1)end elseif cY>ix then pP(vec3(cX),0.01)end end;if aX then if ch then aX=false elseif cY>ix then pP(-vec3(cX))end end;if not aY and cd and not bu then if ci==0 then if cd~=2 then bQ=true end;cD.BeginReentry()cd=false;cf=true else cd=false;cD.ToggleAutopilot()end end;if cf and g8 and(cj<b5+250 and cj>b5-250)and cY*3.6>cL-250 and f2(c_)<25 and ci>=0.1 and(g8.position-d0):len()>2000+cj then cD.ToggleAutopilot()cf=false end;if b4 then cI=true;local qa=b5;if c_<-30 then c0="Unable to achieve lift. Safety Landing."c7=0;cI=p;b4=false;b1=true elseif not q and d2 or b5<iI.spaceEngineMinAltitude then if d2 then qa=antigrav.getBaseAltitude()end;if cj<qa-100 then cM=0;c7=15;aW=false elseif c_>0 then aW=true;c7=0 elseif c_<-30 then aW=true;c7=15 elseif cj>=qa then if d2 then if aZ or bl then cD.ToggleVerticalTakeoff()else aW=true;b4=false end;c0="Takeoff complete. Singularity engaged"fZ("aggLk","AG")else aW=false;c0="VTO complete. Engaging Horizontal Flight"fZ("vtoc","VT")cD.ToggleVerticalTakeoff()end;c7=0 end else if ci>0.08 then cM=0;aW=false;c7=20 elseif ci<0.08 and ci>0 then aW=false;if cR then cM=0;c7=20 else c7=0;cM=36;cD.cmdCruise(3500)end else cI=p;bu=true;cQ=false;qb=false;pm=false;pk=nil;pl=nil;if pp==nil then pp=iI end;cP=qa;po=true;b4=false end end;if cM~=nil then if qc==nil then qc=pid.new(2*0.01,0,2*0.1)end;local qd=dp(cM-d5,-M*0.80,M*0.80)qc:inject(qd)local qe=dp(qc:get(),-1,1)bT=qe end end;if bu then local pW;local qf=false;local qg=ij(cP)if pp==nil then pp=iI;if bl then pp=c4 end end;if not po then cP=bE(pp.radius+pp.surfaceMaxAltitude+T)if pp.hasAtmosphere then cP=bE(pp.radius+pp.noAtmosphericDensityAltitude+T)end;po=true end;if cO.VectorToTarget and g8 then pW=g8.position-d0 end;local qh,qi=cA(pp):escapeAndOrbitalSpeed((d0-pp.center):len()-pp.radius)local qj=d6;if not pm then local qk=false;local ql=false;cD.cmdThrottle(0)pl=0;cN="Aligning to orbital path - OrbitHeight: "..qg;if cO.VectorToTarget then pP(pW:normalize():project_on_plane(cZ))qf=cU:dot(pW:project_on_plane(cT):normalize())>0.95 else pP(cX)qf=q2<0.5;if cY<150 then qf=true end end;bT=0;pk=0;if d5<=pk+1 and d5>=pk-1 then qk=true else qk=false end;if qj<=pl+1 and qj>=pl-1 then ql=true else ql=false end;if qk and ql and qf then pk=nil;pl=nil;pm=true end else if cO.VectorToTarget then pP(pW:normalize():project_on_plane(cZ))elseif cY>150 then pP(cX)end;bT=0;if cO.VectorToTarget and g8 then local c2,dT=cy.computeDistanceAndTime(cY,cL/3.6,cl,0,0,bn)if cQ and pW:len()>15000+c2+cj then cN="Orbiting to Target"if cj-100<=pp.noAtmosphericDensityAltitude or ld>fy.timeToPeriapsis and fy.periapsis.altitude<pp.noAtmosphericDensityAltitude then cQ=false end elseif cQ or pW:len()<15000+c2+cj then c0="Orbit complete, proceeding with reentry"fZ("orCom","OB")bf=g8.position;bQ=true;cf=true;cO.VectorToTarget,cO.AutopilotAlign=false,false;cD.ToggleIntoOrbit()cD.BeginReentry()return end end;if fy.periapsis~=nil and fy.apoapsis~=nil and fy.eccentricity<1 and cj>cP*0.9 and cj<cP*1.4 then if fy.apoapsis~=nil then if fy.periapsis.altitude>=cP*0.99 and fy.apoapsis.altitude>=cP*0.99 and fy.periapsis.altitude<fy.apoapsis.altitude and fy.periapsis.altitude*1.05>=fy.apoapsis.altitude or cQ then if cQ then aW=false;cD.cmdThrottle(0)pk=0;if not cO.VectorToTarget then c0="Orbit complete"fZ("orCom","OB")cD.ToggleIntoOrbit()end else pq=pq+1;if pq>=2 then cQ=true end end else cN="Adjusting Orbit - OrbitHeight: "..qg;pn=true;cD.cmdCruise(qi*3.6+1)local qm=cP-cj;if qn==nil then qn=pid.new(0.1,0,1*0.1)end;qn:inject(qm-c_*dp(utils.smoothstep(2000-qm,-2000,2000)^6*10,1,10))pk=dp(qn:get(),-60,60)end end else local qo=2.75;local qp=f2(ig(qh*qo))local qq=qp%50;if qq>0 then qp=qp-qq+50 end;aW=false;if cj<cP*0.8 then cN="Escaping planet gravity - OrbitHeight: "..qg;pk=utils.map(c_,200,0,-15,80)elseif cj>=cP*0.8 and cj<cP*1.15 then cN="Approaching orbital corridor - OrbitHeight: "..qg;qp=qp*0.75;pk=utils.map(c_,100,-100,-15,65)elseif cj>=cP*1.15 and cj<cP*1.5 then cN="Approaching orbital corridor - OrbitHeight: "..qg;qp=qp*0.75;if c_<0 or pn then pk=utils.map(cj,cP*1.5,cP*1.01,-30,0)else pk=utils.map(cj,cP*0.99,cP*1.5,0,30)end elseif cj>cP*1.5 then cN="Reentering orbital corridor - OrbitHeight: "..qg;pk=-65;local qr=utils.map(c_,-150,-400,1,0.55)qp=qp*qr end;cD.cmdCruise(bE(qp))end end;if pk~=nil then if qs==nil then qs=pid.new(1*0.01,0,5*0.1)end;local qt=pk-d5;qs:inject(qt)local qu=dp(qs:get(),-0.5,0.5)bT=qu end end;if aZ and ci==0 and not cd then local function qv(i3,fy)a.print(i3)aW=false;b8=false;aZ=false;qw=false;bb="Aligning"cD.cmdThrottle(0)bP=false;c0=i3;fZ("apCom","AP")if fy or cd then if fy and gs~=nil and not cd then if not cj or cj==0 then return end;cP=cj;po=true end;cD.ToggleIntoOrbit()end end;local qx,qy=bf,false;if g8 and g8.planetname~="Space"then b7=true;if not qw then local qz=(g8.position-c4.center):normalize()local qA=qz:project_on_plane((c4.center-d0):normalize()):normalize()local qB=c4.center+qA*(c4.radius+gs)local qC=g8.position+(g8.position-c4.center):normalize()*(gs-c4:getAltitude(g8.position))if(d0-qB):len()<(d0-qC):len()then qx=qB else qx=qC;ba=0 end;bf=qx;cD.showWayPoint(c4,bf)qy=true;qw=true end;bc=0 elseif g8 and g8.planetname=="Space"then if not qw then bc=0;qy=true;b7=true;qw=true;qx=g8.position+(d0-g8.position):normalize()*R;bf=qx end elseif g8==nil then bc=0;if not qw then local qz=(d0+cX*100000-c4.center):normalize()local qA=qz:project_on_plane((c4.center-d0):normalize()):normalize()if qA:len()<1 then qz=(d0+cU*100000-c4.center):normalize()qA=qz:project_on_plane((c4.center-d0):normalize()):normalize()end;qx=c4.center+qA*(c4.radius+gs)bf=qx;qw=true;qy=true;b7=true;cD.showWayPoint(c4,bf)end end;oS=(vec3(qx)-d0):len()local lb,eN,eO=cx:getPlanetarySystem(0):castIntersections(d0,cX:normalize(),function(ew)if ew.noAtmosphericDensityAltitude>0 then return ew.radius+ew.noAtmosphericDensityAltitude else return ew.radius+ew.surfaceMaxAltitude*1.5 end end)local lc=eN;if eO~=nil and eN~=nil then lc=math.min(eO,eN)end;if lc~=nil and lc<oS and lb.name==c4.name then oS=lc end;local q9=true;local qD=(c4.center-(d0+vec3(cX):normalize()*oS)):len()-c4.radius;local l0=ij(qD)fX(gk,'{"label": "Projected Altitude", "value": "'..l0 ..'"}')local c2,c3;if not a_ then c2,c3=pa(cY)else c2,c3=pc(cY)end;if cY>50 and b6 then local pW=vec3(qx)-d0;local qE=dp(math.deg(pu(cT,cX:normalize(),pW:normalize()))*cY/500,-90,90)local qF=dp(math.deg(pu(cV,cX:normalize(),pW:normalize()))*cY/500,-90,90)if f2(qE)<20 and f2(qF)<20 then qE=qE*2;qF=qF*2 end;if f2(qE)<2 and f2(qF)<2 then qE=qE*2;qF=qF*2 end;local q2=-math.deg(pu(cT,cU,cX:normalize()))local q3=-math.deg(pu(cV,cU,cX:normalize()))if qG==nil then qG=pid.new(2*0.01,0,2*0.1)end;qG:inject(qF-q3)local qH=dp(qG:get(),-1,1)bT=bT+qH;if qI==nil then qI=pid.new(2*0.01,0,2*0.1)end;qI:inject(qE-q2)local qJ=dp(qI:get(),-1,1)bU=bU+qJ;qy=true;if f2(qE)>2 or f2(qF)>2 then if bb~="Adjusting Trajectory"then bb="Adjusting Trajectory"fZ("apAdj","AP")end else if bb~="Accelerating"then bb="Accelerating"fZ("apAcc","AP")end end elseif b6 and cY<=50 then pP((qx-d0):normalize())end;if qD<gs*1.5 then if g8 and g8.planetname=="Space"then ba=0 elseif g8==nil then dT,ba=cA(c4):escapeAndOrbitalSpeed(qD)end end;if aZ and not b6 and not b9 and not b8 then local lb,lc=cD.checkLOS((bf-d0):normalize())if c4.name~=iI.name then if lb~=nil and c4.name~=lb.name and lc<oS then c0="Collision with "..lb.name.." in "..ij(lc).."\nClear LOS to continue."ca=5;pJ=true else pJ=false;c0=""end end end;if not pJ then if not b9 and not b8 and not qy then q9=pP((qx-d0):normalize())elseif a_ and(b8 or b9)then q9=pP(-vec3(cX):normalize())end end;if b6 then if not bP then aW=false;cD.cmdThrottle(a0)bK=ig(a0,2)bP=true end;local oT=c.getThrottle()if u then oT=bK end;local qK=99999;local o6=-vec3(b.getWorldAcceleration()):dot(cX:normalize())local qL=dp(cX:dot((qx-d0):normalize()),0,cY)if qL>0 or o6>0 then qK=cy.computeTravelTime(qL,o6,oS-c2)end;if cW:len()>=_ or oT==0 and bP or a1/4>qK then b6=false;if bb~="Cruising"then fZ("apCru","AP")bb="Cruising"end;b9=true;cD.cmdThrottle(0)end;local qM=oS;if qM<=c2 or H and d9<=c2+10000 and d8 then if H and d9<=c2+10000 and d8 then if d9<pe and d9>2000 then cD.ToggleAutopilot()c0="Autopilot cancelled to prevent crossing PvP Line"aW=true;pe=d9 else pe=d9;return end end;b6=false;if bb~="Braking"then fZ("apBrk","AP")bb="Braking"end;b8=true;cD.cmdThrottle(0)bP=false end elseif b8 then if bb~="Orbiting to Target"then aW=true;bX=1 end;if a_ then cD.cmdThrottle(1,true)end;local dT,qi=cA(c4):escapeAndOrbitalSpeed((d0-iI.center):len()-iI.radius)local pW;if g8 then pW=g8.position-d0 end;if g8 and g8.planetname=="Space"and cY<50 then if#pr>0 then aW=false;cD.ToggleAutopilot()cD.ToggleAutopilot()return end;qv("Autopilot complete, arrived at space location")aW=true;bX=1 elseif g8 and g8.planetname~="Space"and cY<=qi and(fy.apoapsis==nil or fy.periapsis==nil or fy.apoapsis.altitude<=0 or fy.periapsis.altitude<=0)then qv("Autopilot complete, commencing reentry")bf=g8.position;cd=true;cD.showWayPoint(c4,bf)elseif(g8 and g8.planetname~="Space"or g8==nil)and fy.periapsis~=nil and fy.periapsis.altitude>0 and fy.eccentricity<1 or bb=="Circularizing"then if bb~="Circularizing"then fZ("apCir","AP")bb="Circularizing"end;if cY<=qi then if g8 then if cX:normalize():dot(pW:normalize())>0.4 then if bb~="Orbiting to Target"then fZ("apOrb","OB")bb="Orbiting to Target"end;if not qN then aW=false;cD.showWayPoint(c4,g8.position)qN=true end else qv("Autopilot complete, proceeding with reentry")bf=g8.position;cd=true;cD.showWayPoint(c4,g8.position)qN=false end else qv("Autopilot completed, setting orbit",true)bX=0 end end elseif bb=="Circularizing"then qv("Autopilot complete, fixing Orbit",true)end elseif b9 then local qM=oS;if qM<=c2 or H and d9<=c2+10000 and d8 then if H and d9<=c2+10000 and d8 then if d9<pe and d9>2000 then cD.ToggleAutopilot()c0="Autopilot cancelled to prevent crossing PvP Line"aW=true;pe=d9 else pe=d9;return end end;b6=false;if bb~="Braking"then fZ("apBrk","AP")bb="Braking"end;b8=true end;local oT=c.getThrottle()if u then oT=bK end;if oT>0 then b6=true;if bb~="Accelerating"then bb="Accelerating"fZ("apAcc","AP")end;b9=false end else if q9 then if not b7 and g8==nil or not b7 and g8 and g8.planetname~="Space"then if not cd then bf=vec3(c4.center)+(gs+c4.radius)*cV;qO=cT;qP=cV end;b7=true elseif q9 and not pJ then b6=true;if bb~="Accelerating"then bb="Accelerating"fZ("apAcc","AP")end;if not bP then cD.cmdThrottle(a0,true)bK=ig(a0,2)bP=true;aW=false end end end end elseif aZ and(g8~=nil and g8.planetname~="Space"and ci>0)then c0="Autopilot complete, starting reentry"fZ("apCom","AP")bf=g8.position;aW=false;b8=false;aZ=false;qw=false;bb="Aligning"bX=0;cD.cmdThrottle(0)bP=false;aY=true;cd=true;cD.showWayPoint(c4,g8.position)end;if bZ then cI=true;local qF=0;local fA=d0+vec3(c.getMasterPlayerRelativePosition())local qQ=fA-d0;local qR=vec3(qQ):project_on(cU):len()local qS=vec3(qQ):project_on(cV):len()local cb=dr(qR*qR+qS*qS)pP(qQ:normalize())local mj=40;local qT=cb<mj;local qU=100;local qV=dp((cb-mj)/2,10,qU)bT=0;local q9=f2(bU)<0.1;if q9 and cY<qV and not qT then aW=false;qF=-20 else aW=true;qF=0 end;local qW=0;if f2(qF-d5)>qW then if qX==nil then qX=pid.new(2*0.01,0,2*0.1)end;qX:inject(qF-d5)local qH=qX:get()bT=qH end end;if b0 or b1 or b3 or bl or bo~=nil then local qY=bp;if qY then qY=qY*dp(cY/100,0.1,1)*ci else qY=bn end;if ci<0.01 then qY=bn end;local qZ=cU:project_on_plane(cZ):normalize():dot(cX)local q_=vec3(b.getWorldAirFrictionAcceleration())local r0=q_:len()*cl;if qZ>100 then c2,c3=cy.computeDistanceAndTime(qZ,100,cl,0,0,qY)local r1,r2=cy.computeDistanceAndTime(100,0,cl,0,0,qY*0.55)c2=c2+r1 else c2,c3=cy.computeDistanceAndTime(qZ,0,cl,0,0,qY*0.55)end;local qm=b5-cj-c_;local r3=200+cY;if b3 or cd then r4=2000+cY end;local r5=1;if b2 then r5=dp(cY/100,0.1,1)end;local qF=(utils.smoothstep(qm,-r3,r3)-0.5)*2*O*r5;if not b3 and not cd and not bl and cU:dot(cX:normalize())<0.99 then qF=(utils.smoothstep(qm,-r3*dp(20-19*ci*10,1,20),r3*dp(20-19*ci*10,1,20))-0.5)*2*O*dp(2-ci*10,1,2)*r5 end;if not b0 then qF=0 end;if bo~=nil then if dc and not bu then qF=bo else bo=nil end end;cI=true;local r6=bT;if b3 then local r7=bE(cL)local r8,r9=cy.computeDistanceAndTime(cY,r7/3.6,cl,0,0,bn-iI.gravity*9.8*cl)r8=r8==-1 and 5000 or r8;local ra=cj-(iI.noAtmosphericDensityAltitude+r8)local rb=cj>iI.noAtmosphericDensityAltitude+r8*1.35;if rb then qF=P;if cY<=r7/3.6 and cY>r7/3.6-10 and f2(cX:normalize():dot(cU))>0.9 and not d4 then bO=false;cD.cmdThrottle(1)end elseif(d4 or id:getTargetSpeed(axisCommandId.longitudinal)~=r7)and not rb and not ch then cD.cmdCruise(r7,true)end;if d4 then if cY>r7/3.6 and not rb then aW=true else aW=false end else aW=false end;if c_>0 then aW=true end;if not bQ then qF=-80;if cj<iI.surfaceMaxAltitude+(iI.atmosphereThickness-iI.surfaceMaxAltitude)*0.25 then c0="PARACHUTE DEPLOYED at "..ig(cj,0)b3=false;b1=true;l7=true;cD.cmdThrottle(0)qF=0;cI=p end elseif iI.noAtmosphericDensityAltitude>0 and rb then cI=true elseif not rb then if not ch and(d4 or id:getTargetSpeed(axisCommandId.longitudinal)~=r7)then cD.cmdCruise(r7)end;if cY<r7/3.6+1 then aW=false;bQ=false;b3=false;cI=true end end end;if cY>ix and not ce and not bl and not b1 and v then pP(vec3(cX))end;if da or(bl or ce)and bg>0 and ci>0.01 then local pW;if da then if type(da)=="table"then pW=da elseif da<3 and da>0 then pW=-cZ:cross(cX)*5000 elseif da>=3 then pW=cZ:cross(cX)*5000 elseif da<0 then pW=cX*25000 end elseif g8~=nil then pW=g8.position-d0 else pW=c4.center-d0 end;local qE=math.deg(pu(cZ:normalize(),cX,pW))*2;local mm=math.rad(f2(d6))if cY>aG and ci>0.01 then local rc=1000+cY;local rd=(utils.smoothstep(qm-c_*10,-rc,rc)-0.5)*2*O;local re=dp(90-rd,0,180)cK=dp(qE*2,-re,re)local rf=qE;qE=dp(dp(qE,-L*0.80,L*0.80)*math.cos(mm)+4*(d5-qF)*math.sin(math.rad(d6)),-L*0.80,L*0.80)local rg=1;if cK~=0 then rg=f2(mm/cK)end;rg=(90-dp(f2(cK-d6),0,90))/90;local rh=qF;if f2(d6)>90 then rh=-rh end;qF=rg*dp(dp(rh*math.cos(mm),-M*0.8,M*0.8)+f2(dp(f2(rf)*math.sin(mm),-M*0.80,M*0.80)),-M*0.80,M*0.80)else cK=0;qE=dp(qE,-L*0.80,L*0.80)end;local ri=q2-qE;if da and f2(ri)<=0.0001 and(type(da)=="table"or type(da)~="table"and da<0 and f2(d6)<1)then if da==-2 then cD.ToggleAltitudeHold()end;da=nil;fZ("180Off","BR")return end;if not cJ and cY>aG and ci>0.01 then if rj==nil then rj=pid.new(2*0.01,0,2*0.1)end;rj:inject(ri)local qJ=dp(rj:get(),-1,1)bU=bU+qJ elseif ch and cg>-1 or cY<aG then pP(pW)elseif cJ and ci>0.01 then if(q2<-L or q2>L)and ci>0.01 then pP(cX)end;if(q3<-M or q3>M)and ci>0.01 then qF=dp(d5-q3,d5-M*0.80,d5+M*0.80)end end;if g8~=nil and not ce then local qa=iI:getAltitude(g8.position)local ra=pW:project_on_plane(cZ):len()l7=true;if not ce and not b3 and ra<=c2 and(cX:project_on_plane(cZ):normalize():dot(pW:project_on_plane(cZ):normalize())>0.99 or lf=="Finalizing Approach")then lf="Finalizing Approach"if#pr>0 then cD.ToggleAutopilot()cD.ToggleAutopilot()return end;cD.cmdThrottle(0)if b0 then cD.ToggleAltitudeHold()bl=true end;aW=true elseif not b2 then aW=false end;if lf=="Finalizing Approach"and(qZ<0.1 or ra<0.1 or rk~=nil and rk<ra)then if not d2 then fZ("bklOn","BL")b1=true end;bl=false;lf="Proceeding to Waypoint"dd=false end;rk=ra end elseif bl and ci==0 and b5>iI.noAtmosphericDensityAltitude and not(ce or b3)then if g8~=nil and c4.name==iI.name then local pW=g8.position-d0;local qa=iI:getAltitude(g8.position)local ra=dr(pW:len()^2-(cj-qa)^2)local qY=bp;if qY then c2,c3=cy.computeDistanceAndTime(cY,0,cl,0,0,qY/2)l7=true;if ra<=c2+cY*q1/2 and cX:project_on_plane(cZ):normalize():dot(pW:project_on_plane(cZ):normalize())>0.99 then if iI.hasAtmosphere then aW=false;aY=false;bQ=true;cd=false;cf=true;aZ=false;cD.BeginReentry()end end;rk=ra end end end;if ci==0 and(b0 and b5>iI.noAtmosphericDensityAltitude)and not(ce or bu or b3)then if not cQ and not bu then cP=b5;po=true;if bl then cO.VectorToTarget=true end;cD.ToggleIntoOrbit()bl=false;pm=true end end;if cJ and ci>0.01 and cg==-1 and cY>aG and lf~="Finalizing Approach"then pP(cX)qF=dp(d5-q3,d5-M*0.80,d5+M*0.80)end;bT=r6;local pD=-1;if b1 then qF=0;local rl=false;local rm=30;if cz~=nil and cz>0 then local rn=dp(ci,0.4,2)local qY=bp*dp(cY/100,0.1,1)*rn;local ro=cz*rn+qY-gB;local rp=qY/2-gB;local rq=cY-dr(f2(rp/2)*20/(0.5*cl))*utils.sign(rp)if rq<0 then rq=0 end;local rr;if cY>100 then local rs,dT=cy.computeDistanceAndTime(cY,100,cl,0,0,qY)local rt,dT=cy.computeDistanceAndTime(100,0,cl,0,0,dr(qY))rr=rs+rt else rr=cy.computeDistanceAndTime(cY,0,cl,0,0,dr(qY))end;if rr<20 then aW=false else local ru=0;if rq>100 then local rv,dT=cy.computeDistanceAndTime(rq,100,cl,0,0,ro)local rw,dT=cy.computeDistanceAndTime(100,0,cl,0,0,cz*rn+dr(qY)-gB)ru=rv+rw else ru,dT=cy.computeDistanceAndTime(rq,0,cl,0,0,cz*rn+dr(qY)-gB)end;ru=(ru+15+cY*q1)*1.1;local rx=g8~=nil and iI:getAltitude(g8.position)>0 and g8.safe;if rx then local qa=iI:getAltitude(g8.position)local ry=cj-qa-100;local pW=g8.position-d0;local rz=dr(pW:len()^2-(cj-qa)^2)if rz>100 then rx=false elseif ry<=ru or ru==-1 then aW=true;rl=true else aW=false;rl=true end end;if not rx and t then if ru>=rm then aW=true else aW=false end;rl=true end end end;if not d4 then cD.cmdThrottle(0)end;id:setTargetGroundAltitude(500)id:activateGroundEngineAltitudeStabilization(500)bw=true;pD=cg;if pD>-1 then cI=p;if cY<1 or cX:normalize():dot(cZ)<0 then b1=false;b0=false;bh=true;if bR then d.control.extendLandingGears()fZ("grOut","LG",1)end;id:setTargetGroundAltitude(Y)c7=0;aW=true else aW=true end elseif l7 and cX:normalize():dot(-gu)<0.999 then aW=true elseif c_<-N and not rl then aW=true elseif not rl then aW=false end end;if b2 or ce then local lb,eO,eN;if bf~=nil then lb,eO,eN=cx:getPlanetarySystem(0):castIntersections(d0,(bf-d0):normalize(),function(ew)return ew.radius+ew.noAtmosphericDensityAltitude end)end;if d2 then if cj>=b5-50 then b2=false;if not aZ and not bl then aW=true;cD.cmdThrottle(0)end else b5=antigrav.getBaseAltitude()end elseif f2(qF)<15 and cj/b5>0.75 then b2=false;if not ce then if d4 and not u then d.control.cancelCurrentControlMasterMode()end elseif ce and cY<ix then aZ=true;ce=false;b0=false;b2=false;cD.cmdThrottle(0)elseif ce then cD.cmdThrottle(0)aW=true end elseif ce and ci==0 and c4~=nil and(lb==nil or lb.name==c4.name)then aZ=true;ce=false;b0=false;b2=false;if not d4 then cD.cmdThrottle(0)end;b6=true end end;local rA=cg>-1;local rB=d5;if(bl or ce or da)and not rA and cY>aG and ci>0.01 then local mm=math.rad(f2(d6))rB=d5*f2(math.cos(mm))+q3*math.sin(mm)end;local rC=dp(qF-rB,-M*0.80,M*0.80)if ci<0.01 and bl then rC=dp(qF-rB,-85,O)elseif ci<0.01 then rC=dp(qF-rB,-O,O)end;if f2(d6)<5 or bl or da or b1 or rA or b0 then if qX==nil then qX=pid.new(5*0.01,0,5*0.1)end;qX:inject(rC)local qH=qX:get()bT=bT+qH end end;if antigrav~=nil and(antigrav and not q and cj<200000)then if bq==nil or bq<1000 then bq=1000 end;if rD~=bq then rD=bq;antigrav.setBaseAltitude(rD)end end end;function p9.ToggleIntoOrbit()cQ=false;pk=nil;pl=nil;pq=0;if ci==0 then if bu then fZ("orOff","AP")bu=false;pm=false;pp=nil;cI=p;if b0 then b0=false;b2=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;po=false elseif dc then fZ("orOn","AP")bu=true;cI=true;if pp==nil then pp=iI end;if b0 then b0=false;b2=false end else c0="Unable to engage auto-orbit, not near a planet"end else bu=false;pm=false;pp=nil;cI=p;if b0 then b0=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;po=false end end;function p9.ToggleVerticalTakeoff()b0=false;if b4 then l7=true;b3=false;b2=false;b1=true;cI=true;c7=0;if ch and cg==-1 then b1=false;b0=true;c7=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cD.cmdCruise(bE(cL))end else cQ=false;bh=false;d.control.retractLandingGears()id:setTargetGroundAltitude(X)aW=true end;b4=not b4 end;function p9.checkLOS(pQ)local lb,eN,eO=cx:getPlanetarySystem(0):castIntersections(d0,pQ,function(ew)if ew.noAtmosphericDensityAltitude>0 then return ew.radius+ew.noAtmosphericDensityAltitude else return ew.radius+ew.surfaceMaxAltitude*1.5 end end)local lc=eN;if eO~=nil and eN~=nil then lc=math.min(eO,eN)end;if lc~=nil then return lb,lc else return nil,nil end end;function p9.ToggleAutopilot()local function rE(bs)dd=false;bl=not bl;if bl then a_=false;if not b0 and not bs then cD.ToggleAltitudeHold()end end;lf="Proceeding to Waypoint"end;local rF=false;if bG-pj<1.5 and ci>0 then if not cS then c0="No space engines detected, Orbital Hop not supported"return end;if iI.hasAtmosphere then if ci>0 then b5=iI.noAtmosphericDensityAltitude+T;fZ("orH","OH")end;pj=-1;if aZ or bl or bu then return end end else pj=bG end;qw=false;if(bg>0 or#pr>0)and not aZ and not bl and not ce and not bu then if 0.5*d:maxForceForward()/b.g()<cl then c0="WARNING: Heavy Loads may affect autopilot performance."ca=5 end;if#pr>0 and not cf then bg=pr[1]cC.UpdateAutopilotTarget()table.remove(pr,1)c0="Route Autopilot in Progress"local pW=g8.position-d0;local ra=pW:project_on_plane(cZ):len()if ra>50000 and g8.planetname==iI.name then rF=true end end;cC.UpdateAutopilotTarget()cD.showWayPoint(c4,bf)if g8~=nil then bo=nil;bs=g8.planetname=="Space"if bs then fZ("apSpc","AP")if ci~=0 then ce=true;cD.ToggleAltitudeHold()else aZ=true end elseif iI.name==g8.planetname then l7=true;if ci>0 then if not bl then fZ("vtt","AP")rE(bs)if rF then b5=iI.noAtmosphericDensityAltitude+T end end else fZ("apOn","AP")if not(c4.name==iI.name and cj<gs*1.5)then cQ=false;aZ=true elseif not ch then if bu then cD.ToggleIntoOrbit()end;cP=iI.noAtmosphericDensityAltitude+T;po=true;cO.AutopilotAlign=true;cO.VectorToTarget=true;pm=false;if not bu then cD.ToggleIntoOrbit()end end end else fZ("apP","AP")aX=false;aY=false;if ci~=0 then ce=true;cD.ToggleAltitudeHold()else aZ=true end end elseif ci==0 then if g8==nil and(c4.name==iI.name and dc)and not bu then qN=false;cQ=false;pm=false;cD.ToggleIntoOrbit()else fZ("apP","AP")aZ=true;aX=false;aY=false;b7=false;bZ=false;b0=false;b1=false;b3=false;b2=false;bP=false;bo=nil;qN=false end else fZ("apP","AP")ce=true;cD.ToggleAltitudeHold()end else fZ("apOff","AP")cD.ResetAutopilots(1)end end;function p9.routeWP(rG,rH,rI)if rI then if rI==1 then pr={}pr=ih(pr,bz)if#pr>0 then c0="Route Loaded"else c0="No Saved Route found on Databank"end;return pr else bz={}bz=ih(bz,pr)c0="Route Saved"p8()return end end;if rG then return pr end;if rH then pr={}c0="Current Route Cleared"else pr[#pr+1]=bg;c0="Added "..g8.name.." to route. "end;return pr end;function p9.cmdThrottle(dP,rJ)if id:getAxisCommandType(0)~=axisCommandType.byThrottle and not rJ then d.control.cancelCurrentControlMasterMode()end;id:setThrottleCommand(axisCommandId.longitudinal,dP)bK=dp(ig(dP*100,0)/100,-1,1)d3=nil end;function p9.cmdCruise(dP,rJ)if id:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rJ then d.control.cancelCurrentControlMasterMode()end;id:setTargetSpeedCommand(axisCommandId.longitudinal,dP)d3=dP end;function p9.ToggleLockPitch()if bo==nil then fZ("lkPOn","LP")if not b_ then bo=d5 else bo=Q end;b2=false;b0=false;b1=false else fZ("lkPOff","LP")bo=nil end end;function p9.ToggleAltitudeHold()if bG-pi<1.5 then if iI.hasAtmosphere then if ci>0 then b5=iI.spaceEngineMinAltitude-0.01*iI.noAtmosphericDensityAltitude;fZ("11","EP")else if dc then b5=iI.noAtmosphericDensityAltitude+T;cP=b5;po=true;if not bu then cD.ToggleIntoOrbit()end;pm=true end end;pi=-1;if b0 or bu or b4 then return end end else pi=bG end;if dc and ci==0 then cP=cj;po=true;pm=true;cD.ToggleIntoOrbit()if bu then pi=bG else pi=0 end;return end;b0=not b0;b1=false;b3=false;if b0 then aZ=false;aY=false;aX=false;bZ=false;cI=true;bo=nil;cQ=false;if cg~=-1 and cY<20 then fZ("lfs","LS")b2=true;if pi>-1 then b5=cj+W end;bh=false;d.control.retractLandingGears()aW=true;id:setTargetGroundAltitude(X)if aV and d1 then cD.ToggleVerticalTakeoff()end else fZ("altOn","AH")b2=false;if pi>-1 then if dc then b5=cj end end;if b4 then cD.ToggleVerticalTakeoff()end end;if ce then b5=100000 end else fZ("altOff","AH")if bu then cD.ToggleIntoOrbit()end;if b4 then cD.ToggleVerticalTakeoff()end;cI=p;b2=false;bl=false;pi=0 end end;function p9.ResetAutopilots(p9)if p9 then ce=false;aZ=false;b7=false;bP=false;b5=cj;qw=false end;bl=false;b2=false;b3=false;aY=false;b1=false;rK=false;da=nil;if not d2 then b0=false;bo=nil end;if b4 then cD.ToggleVerticalTakeoff()end;if bu then cD.ToggleIntoOrbit()end;cI=p;cd=false;cf=false;c7=0 end;function p9.BrakeToggle()aW=not aW;if b1 then b1=false;cI=p end;if aW then fZ("bkOn","B",1)cD.ResetAutopilots()else fZ("bkOff","B",1)end end;function p9.BeginReentry()if b3 then c0="Re-Entry cancelled"fZ("reOff","RE")b3=false;cI=p;b0=false elseif not iI.hasAtmosphere then c0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ca=5 elseif not bQ then b3=true;if id:getAxisCommandType(0)~=rL.cruise then d.control.cancelCurrentControlMasterMode()end;cI=true;aW=false;c0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cL;fZ("par","RE")else b3=true;b0=true;cI=true;aW=false;b5=iI.surfaceMaxAltitude+Z;if b5>iI.spaceEngineMinAltitude then b5=iI.spaceEngineMinAltitude-0.01*iI.noAtmosphericDensityAltitude end;local rM=ij(b5)c0="Beginning Re-entry.  Target speed: "..cL.." Target Altitude: "..rM;fZ("glide","RE")cD.cmdCruise(bE(cL))end;b2=false end;function p9.ToggleAntigrav()if antigrav and not q then if d2 then fZ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bq==nil then bq=cj end;if bq<1000 then bq=1000 end;fZ("aggOn","AG")antigrav.activate()antigrav.show()end end end;function p9.changeSpd(rN)local rO=1;if rN then rO=-1 end;if not b_ then if u and not oF and cm then local rP=bK;bK=ig(dp(bK+rO*az/100,-1,1),2)if bK>=0 and rP<0 then bK=0;cm=false end elseif oF then if ci>0 or b3 then cL=dp(cL+rO*az,0,U)elseif aZ then _=dp(_+rO*az/3.6*100,0,8333.00)end else id:updateCommandFromActionStart(axisCommandId.longitudinal,rO*az)end else if aZ or bl or ce or bu then dg=dg+1*rO*-1;if dg>#d7 then dg=1 end;if dg<1 then dg=#d7 end else if not rN then rO=1 else rO=nil end;cC.adjustAutopilotTargetIndex(rO)end end end;function p9.TenthTick()local function rQ(gB,rR)if gB==nil then gB=b.g()end;gB=ig(gB,5)if rR~=nil and rR or(ps==nil or ps~=gB)then local fu=cW:len()local rS=ia(c.getData()).maxBrake;if rS~=nil and rS>0 and ch then rS=rS/dp(fu/100,0.1,1)rS=rS/ci;if ci>0.10 then if bp then bp=(bp+rS)/2 else bp=rS end end end;if rS~=nil and rS>0 then bn=rS end;ps=gB end end;rQ(nil,true)if d3~=nil then if id:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or id:getTargetSpeed(axisCommandId.longitudinal)~=d3 then cD.cmdCruise(d3)else d3=nil end end end;function p9.SatNavTick()if not r then return end;pt=dbHud_1.getStringValue("SPBAutopilotTargetName")if pt~=nil and pt~=""and pt~="SatNavNotChanged"then local dJ=ia(dbHud_1.getStringValue("SavedLocations"))if dJ~=nil then bk=dJ;local gw=-1;local gC;for dO,dA in pairs(bk)do if dA.name and dA.name=="SatNav Location"then gw=dO;break end end;if gw~=-1 then gC=bk[gw]gw=-1;for dO,dA in pairs(e[0])do if dA.name and dA.name=="SatNav Location"then gw=dO;break end end;if gw>-1 then e[0][gw]=gC end;cC.UpdateAtlasLocationsList()c0=gC.name.." position updated"end end;for K=1,#d7 do if d7[K].name==pt then bg=K;a.print("Index = "..bg.." "..d7[K].name)cC.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;cg=py()return p9 end;local function rT(d,b,c,a,e,vBooster,hover,antigrav,i9,dbHud_2,gyro,ic,id,ie,rU,gH,ig,e8,dq,dp,fZ,ii,p8)local rV={}local rW=true;local rX=5;local rY=5;local rZ=rX;local r_=rY;local s0=bG;function rV.startControl(s1)local function s2(rN)local rO=1;local function s3(s4,rN)local s5={iI.surfaceMaxAltitude+100,iI.spaceEngineMinAltitude-0.01*iI.noAtmosphericDensityAltitude,iI.noAtmosphericDensityAltitude+T,iI.radius*(S-1)+iI.noAtmosphericDensityAltitude}local s6=s4;for dT,dA in ipairs(s5)do if rN and s6>dA then s4=dA elseif s4<dA and not rN then s4=dA;break end end;return s4 end;if rN then rO=-1 end;if not q and d2 then if b_ and rN then bq=1000 elseif bq~=nil then bq=bq+rO*rY;if bq<1000 then bq=1000 end;if b0 and bq<b5+10 and bq>b5-10 then b5=bq end else bq=rD+rO*100 end elseif b0 or b4 or bu then if bu then if b_ then cP=s3(cP,rN)else cP=cP+rO*rX end;if cP<iI.noAtmosphericDensityAltitude then cP=iI.noAtmosphericDensityAltitude end else if b_ and ch then b5=s3(b5,rN)else b5=b5+rO*rX end end else id:updateTargetGroundAltitudeFromActionStart(rO*1.0)end end;local function s7(s8)if not ch then c0="Flight Assist in Atmo only"return end;local dx=type(s8)if da==nil then if dx=="table"then if aZ or bl then cD.ToggleAutopilot()end;fZ("180On","BR")elseif s8==1 then fZ("bnkLft","BR")else fZ("bnkRht","BR")end;if not b0 and not aZ and not bl then cD.ToggleAltitudeHold()if dx~="table"then s8=s8+1 end end;da=s8 else fZ("180Off","BR")da=nil end end;if s1=="gear"then bh=not bh;if bh then bl=false;bo=nil;cD.cmdThrottle(0)if vBooster or hover then if ch and cg==-1 then fZ("bklOn","BL")l7=true;b3=false;b2=false;b4=false;b0=false;b1=true;cI=true;bh=false else if bR then fZ("grOut","LG",1)d.control.extendLandingGears()end;id:setTargetGroundAltitude(Y)if ch then aW=true end end end;if bR and not b1 and not(vBooster or hover)then fZ("grOut","LG",1)d.control.extendLandingGears()end else if bR then fZ("grIn","LG",1)d.control.retractLandingGears()end;id:setTargetGroundAltitude(X)end elseif s1=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif s1=="forward"then bS=bS-1 elseif s1=="backward"then if oF then s7(-cX*5000)else bS=bS+1 end elseif s1=="left"then if oF then s7(1)else bV=bV-1 end elseif s1=="right"then if oF then s7(3)else bV=bV+1 end elseif s1=="yawright"then bW=bW-1 elseif s1=="yawleft"then bW=bW+1 elseif s1=="straferight"then id:updateCommandFromActionStart(axisCommandId.lateral,1.0)bt=1 elseif s1=="strafeleft"then id:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bt=-1 elseif s1=="up"then c7=c7+1;id:deactivateGroundEngineAltitudeStabilization()id:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif s1=="down"then c7=c7-1;id:deactivateGroundEngineAltitudeStabilization()id:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif s1=="groundaltitudeup"then s2()elseif s1=="groundaltitudedown"then s2(true)elseif s1=="option1"then s9=false;if oF and b_ then local sa=""for K=1,#dh do sa=sa.."| Name: "..a.getPlayerName(dh[K]).." Mass: "..ig(b.getBoardedPlayerMass(dh[K])/1000,1).."t "end;a.print("Onboard: "..sa)return end;cC.adjustAutopilotTargetIndex()elseif s1=="option2"then s9=false;if oF and b_ then for K=1,#dh do b.forceDeboard(dh[K])end;c0="Deboarded All Passengers"return end;cC.adjustAutopilotTargetIndex(1)elseif s1=="option3"then local function sb()rW=not rW;if not rW then fZ("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(sc,atmofueltank_size,"Atmo Fuel","fuel_container")sd=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(se,spacefueltank_size,"Space Fuel","fuel_container")sf=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(sg,rocketfueltank_size,"Rocket Fuel","fuel_container")sh=_autoconf.panels[_autoconf.panels_size]end;si=a.createWidgetPanel("Docking")sj=a.createWidget(si,"parenting")a.addDataToWidget(c.getDataId(),sj)sk=a.createWidgetPanel("Core combat stress")sl=a.createWidget(sk,"core_stress")a.addDataToWidget(b.getDataId(),sl)if i9~=nil then i9.show()end else fZ("hud","DH")c.hide()b.hide()if sd~=nil then gH(sd)sd=nil end;if si~=nil then gH(si)si=nil end;if sk~=nil then gH(sk)sk=nil end;if sf~=nil then gH(sf)sf=nil end;if sh~=nil then gH(sh)sh=nil end;if i9~=nil then i9.hide()end end end;s9=false;if oF and b_ then local sa=""for K=1,#di do sa=sa.."| ID: "..di[K].." Mass: "..ig(b.getDockedConstructMass(di[K])/1000,1).."t "end;a.print("Docked Ships: "..sa)return end;if y then if x then x=false else x=true end end;sb()elseif s1=="option4"then s9=false;if oF and b_ then for K=1,#di do b.forceUndock(di[K])end;c0="Undocked all ships"return end;da=nil;cD.ToggleAutopilot()elseif s1=="option5"then s9=false;cD.ToggleLockPitch()elseif s1=="option6"then s9=false;if oF and b_ then if i9 then local sm=i9.getVentingCooldown()if sm>0 then c0="Cannot vent again for "..sm.." seconds"return end;if i9.getShieldHitpoints()<i9.getMaxShieldHitpoints()then i9.startVenting()c0="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c0="Shields already at max hitpoints"end;return else c0="No shield found"return end end;cD.ToggleAltitudeHold()elseif s1=="option7"then s9=false;if oF and b_ then if i9 then i9.toggle()return else c0="No shield found"return end end;F=not F;if F then c0="Collision System Enabled"else c0="Collision System Secured"end elseif s1=="option8"then s9=false;if oF and b_ then if bg>0 and g8~=nil then cD.routeWP()else c0="Select a saved wp on IPH to add to or remove from route"end;return end;bw=not bw;if not bw then c0="DeCoupled Mode - Ground Stabilization off"id:deactivateGroundEngineAltitudeStabilization()fZ("gsOff","GS")else c0="Coupled Mode - Ground Stabilization on"id:activateGroundEngineAltitudeStabilization(sn)d:setEngineForceCommand('hover',vec3(),1)fZ("gsOn","GS")end elseif s1=="option9"then s9=false;if oF and b_ then id:resetCommand(axisCommandId.longitudinal)id:resetCommand(axisCommandId.lateral)id:resetCommand(axisCommandId.vertical)cD.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cn=gyro.getState()==1;if cn then fZ("gyOn","GA")else fZ("gyOff","GA")end else c0="No gyro found"end elseif s1=="lshift"then df=false;if oF then b_=true end;if ie()==1 then b_=true;bd=ie()rU(1)elseif ic()==1 and z then b_=true;cH=false;cG=false end elseif s1=="brake"then if aU or oF then cD.BrakeToggle()elseif not aW then cD.BrakeToggle()else aW=true end elseif s1=="lalt"then s9=true;oF=true;if ic()==0 and not i and g=="keyboard"then rU(1)end elseif s1=="booster"then if n then d:toggleBoosters()elseif not c1 then if not so then d:toggleBoosters()so=true end;c1=true else if so then d:toggleBoosters()so=false end;c1=false end elseif s1=="stopengines"then local function sp()if bG-s0<1.5 then fZ("clear","CA")b6=false;b8=false;b9=false;aZ=false;b7=false;bb="Aligning"aX=false;aY=false;da=nil;b0=false;b3=false;b1=false;aW=false;b2=false;b4=false;bZ=false;bP=false;cd=false;ce=false;bQ=false;cI=p;bl=false;a_=false;cn=false;bo=nil;bu=false end end;sp()s0=bG;if id:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then id:resetCommand(axisCommandId.longitudinal)cD.cmdThrottle(0)else cD.cmdThrottle(100)end else if id:getTargetSpeed(axisCommandId.longitudinal)~=0 then id:resetCommand(axisCommandId.longitudinal)else if ch then cD.cmdCruise(U)else cD.cmdCruise(_*3.6)end end end elseif s1=="speedup"then cD.changeSpd()elseif s1=="speeddown"then cD.changeSpd(true)elseif s1=="antigravity"and not q then if antigrav~=nil then cD.ToggleAntigrav()else c0="No antigrav found"end end end;function rV.stopControl(s1)local function sq()if not q and d2 then r_=rY end;if b0 or b4 or bu then rZ=rX end end;if s1=="forward"then bS=0 elseif s1=="backward"then bS=0 elseif s1=="left"then if da then if da==2 then da=-2 else da=-1 end end;bV=0 elseif s1=="right"then if da then if da==4 then da=-2 else da=-1 end end;bV=0 elseif s1=="yawright"then bW=0 elseif s1=="yawleft"then bW=0 elseif s1=="straferight"then id:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bt=0 elseif s1=="strafeleft"then id:updateCommandFromActionStop(axisCommandId.lateral,1.0)bt=0 elseif s1=="up"then c7=0;id:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bw then id:activateGroundEngineAltitudeStabilization(sn)d:setEngineForceCommand('hover',vec3(),1)end elseif s1=="down"then c7=0;id:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bw then id:activateGroundEngineAltitudeStabilization(sn)d:setEngineForceCommand('hover',vec3(),1)end elseif s1=="groundaltitudeup"then sq()s9=false elseif s1=="groundaltitudedown"then sq()s9=false elseif s1=="lshift"then if ie()==1 then c8=0;c9=0;rU(bd)elseif ic()==1 and z then cH=false;cG=false end;b_=false elseif s1=="brake"then if not aU and not oF then if aW then cD.BrakeToggle()else aW=false end end elseif s1=="lalt"then if ic()==0 and i then if s9 then if ie()==1 then rU(0)else rU(1)end else s9=true end elseif ic()==0 and not i and g=="keyboard"then rU(0)end;oF=false end end;function rV.loopControl(s1)local function sr(rN)local rO=1;if rN then rO=-1 end;if not q and d2 then if bq~=nil then bq=bq+rO*r_;if bq<1000 then bq=1000 end;if b0 and bq<b5+10 and bq>b5-10 then b5=bq end;r_=dp(r_*1.05,rY,50)aW=false else bq=rD+rO*100;aW=false end elseif b0 or b4 or bu then if bu then cP=cP+rO*rZ;if cP<iI.noAtmosphericDensityAltitude then cP=iI.noAtmosphericDensityAltitude end else b5=b5+rO*rZ end;rZ=dp(rZ*1.05,rX,50)else id:updateTargetGroundAltitudeFromActionLoop(rO*1.0)end end;local function ss(rN)local rO=1;if rN then rO=-1 end;if not b_ then if u and not oF then bK=dp(bK+rO*aA/100,-1,1)else id:updateCommandFromActionLoop(axisCommandId.longitudinal,rO*aA)end end end;if s1=="groundaltitudeup"then if not b_ then sr()end elseif s1=="groundaltitudedown"then if not b_ then sr(true)end elseif s1=="speedup"then ss()elseif s1=="speeddown"then ss(true)end end;function rV.inputTextControl(rM)local function st(su,fA,gz)local function sv(fA)local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH='::pos{'..dG..','..dG..','..dG..','..dG..','..dG..'}'local dX,dY,e5,e6,e7=e8(fA,dH)if dX=="0"and dY=="0"then return vec3(dq(e5),dq(e6),dq(e7))end;e6=math.rad(e6)e5=math.rad(e5)local iI=e[dq(dX)][dq(dY)]local eZ=math.cos(e5)local sw=vec3(eZ*math.cos(e6),eZ*math.sin(e6),math.sin(e5))return iI.center+(iI.radius+e7)*sw end;local g0=sv(fA)return cC.AddNewLocation(su,g0,gz)end;local K;local sx,sy=nil,nil;local sz="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp"K=string.find(rM," ")sx=rM;if K~=nil then sx=string.sub(rM,0,K-1)sy=string.sub(rM,K+1)end;if sx=="/help"or sx=="/commands"then for ob in string.gmatch(sz,"([^\n]+)")do a.print(ob)end;return elseif sx=="/setname"then if sy==nil or sy==""then c0="Usage: ah-setname Newname"return end;if bg>0 and g8~=nil then cC.UpdatePosition(sy)else c0="Select a saved target to rename first"end elseif i9 and sx=="/resist"then if not i9 then c0="No shield found"return elseif sy==nil or i9.getResistancesCooldown()>0 then c0="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH=dG..', '..dG..', '..dG..', '..dG;local sA,sB,sC,sD=e8(sy,dH)if sD==nil or sA+sB+sC+sD>0.6 then c0="Improperly formatted or total exceeds 0.6"return end;if i9.setResistances(sA,sB,sC,sD)==1 then c0="Shield Resistances set"else c0="Resistance setting failed."end elseif sx=="/addlocation"or string.find(rM,"::pos")~=nil then local gz=false;local su="0-Temp"if sy==nil or sy==""then sy=sx;gz=true end;K=string.find(sy,"::")if not gz then su=string.sub(sy,1,K-2)end;local fA=string.sub(sy,K)st(su,fA,gz)elseif sx=="/agg"then if sy==nil or sy==""then c0="Usage: /agg targetheight"return end;sy=dq(sy)if sy<1000 then sy=1000 end;bq=sy;c0="AGG Target Height set to "..sy elseif sx=="/G"then if sy==nil or sy==""then c0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if sy=="dump"then for dO,dA in pairs(ii())do if type(dA.get())=="boolean"then if dA.get()==true then a.print(dO.." true")else a.print(dO.." false")end elseif dA.get()==nil then a.print(dO.." nil")else a.print(dO.." "..dA.get())end end;return end;K=string.find(sy," ")local sE=string.sub(sy,0,K-1)local sF=string.sub(sy,K+1)for dO,dA in pairs(ii())do if dO==sE then c0="Variable "..sE.." changed to "..sF;local sG=type(dA.get())if sG=="number"then sF=dq(sF)if dO=="AtmoSpeedLimit"then cL=sF end elseif sG=="boolean"then if string.lower(sF)=="true"then sF=true else sF=false end end;dA.set(sF)return end end;c0="No such global variable: "..sE elseif sx=="/deletewp"then if bg>0 and g8~=nil then cC.ClearCurrentPosition()else c0="Select a custom wp to delete first in IPH"end elseif sx=="/copydatabank"then if dbHud_2 then p8(true)else c0="Spare Databank required to copy databank"end elseif sx=="/iphWP"then if bg>0 then a.print(cD.showWayPoint(c4,bf,true))c0="::pos waypoint shown in lua chat"else c0="No target selected in IPH"end end end;function rV.tagTick()if bx=="Off"then bx="All"elseif bx=="All"then bx="Longitude"elseif bx=="Longitude"then bx="Lateral"elseif bx=="Lateral"then bx="Vertical"else bx="Off"end;c0="Extra Engine Tags: "..bx;c.stopTimer("tagTick")end;return rV end;local function sH(d,b,c,a,library,e,vBooster,hover,p7,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,i9,gyro,warpdrive,sI)local sJ={}local dn=string.format;local ia=json.decode;local sK=json.encode;local sL=b.getElementMaxHitPointsById;local ib=b.getElementMassById;local ic=d.control.isRemoteControlled;local e8=string.match;local gH=a.destroyWidgetPanel;local fX=a.updateData;local fY=a.addDataToWidget;local rU=a.lockView;local ie=a.isViewLocked;local dr=math.sqrt;local dq=tonumber;local f2=math.abs;local bE=math.floor;local bF=c.getAtmosphereDensity;local eY=math.atan;local bD=a.getTime;local dp=utils.clamp;local id=d.axisCommandManager;local sM=Y;local gJ=13;local sN=b.getElementIdList()local sO={}local sP=0;local function ds(eG,eH)if eG==0 then return f2(eH)<1e-09 end;if eH==0 then return f2(eG)<1e-09 end;return f2(eG-eH)<math.max(f2(eG),f2(eH))*dF end;local function ig(dG,sQ)local rO=10^(sQ or 0)return bE(dG*rO+0.5)/rO end;local function ih(sR,sS)for dO,dA in pairs(sS)do if type(dO)=="string"then sR[dO]=dA else sR[#sR+1]=sS[dO]end end;return sR end;local function ii(sT)local sU={}if not sT then ih(sU,J)ih(sU,a7)ih(sU,ay)ih(sU,aT)return sU elseif sT=="boolean"then return J elseif sT=="handling"then return a7 elseif sT=="hud"then return ay elseif sT=="physics"then return aT end end;local function p8(sV)local function sW(sX)for dO,dA in pairs(sX)do dbHud_1.setStringValue(dO,sK(dA.get()))if sV and dbHud_2 then dbHud_2.setStringValue(dO,sK(dA.get()))end end end;if dbHud_1 then sW(bA)sW(ii())a.print("Saved Variables to Datacore")if sV and dbHud_2 then c0="Databank copied.  Remove copy when ready."end end end;local function fZ(sY,sZ,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..sY.."|"..sZ.."|"..ax)else a.logInfo("sound_notification|audiopacks/"..h.."/"..sY.."|"..sZ.."|"..ax)end else a.logInfo("sound_q|audiopacks/"..h.."/"..sY.."|"..sZ.."|"..ax)end end;local function gI(hg,hh,rM,jl,s_)if jl==nil then jl=""end;if s_==nil then s_=""end;return dn([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jl,hg,hh,s_,rM)end;local function ij(cb,t0)local t1=cb>100000;if t0==nil then t0=1 end;if t1 then return ig(cb/1000/200,t0).."SU"elseif cb<1000 then return ig(cb,t0).."M"else return ig(cb/1000,t0).."KM"end end;local function ik(t2)local t3=0;local t4=0;local t5=0;if t2<60 then t2=bE(t2)elseif t2<3600 then t3=bE(t2/60)t2=bE(t2%60)elseif t2<86400 then t4=bE(t2/3600)t3=bE(t2%3600/60)else t5=bE(t2/86400)t4=bE(t2%86400/3600)end;if t5>0 then return t5 .."d "..t4 .."h "elseif t4>0 then return t4 .."h "..t3 .."m "elseif t3>0 then return t3 .."m "..t2 .."s"elseif t2>0 then return t2 .."s"else return"0s"end end;function sJ.onStart()local t6=false;local function t7()local function t8(t9)local ta=dbHud_1.hasKey;for dO,dA in pairs(t9)do if ta(dO)then local dJ=ia(dbHud_1.getStringValue(dO))if dJ~=nil then dA.set(dJ)t6=true end end end end;if dbHud_1 then if not f then t8(ii())coroutine.yield()t8(bA)else t8(bA)c0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ca=5;t6=false end;coroutine.yield()if t6 then c0="Loaded Saved Variables"cr=a8;cs=a9;aU=j;g=string.lower(g)cI=p;cL=U;co=[[rgb(]]..bE(bH+0.5)..","..bE(bJ+0.5)..","..bE(bI+0.5)..[[)]]cp=[[rgb(]]..bE(bH*0.9+0.5)..","..bE(bJ*0.9+0.5)..","..bE(bI*0.9+0.5)..[[)]]elseif not f then c0="No Saved Variables Found - Exit HUD to save settings"end;if by<1.500 then if T<2000 then c0="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;by=VERSION_NUMBER else c0="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if br+180<bG then bp=0 end;br=bG;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ca=7 end;if antigrav and not q then if bq==nil then bq=cj end;antigrav.setBaseAltitude(bq)end;lf="Proceeding to Waypoint"end;local function tb()local function tc(td,te)if td>te then te=td end;local tf,tg=0,0;if a5>0 then tf=a5*0.05 end;if a6>0 then tg=a6*0.05 end;te=te*(1-(tf+tg))return te end;local th=b.getElementNameById;local ti=ap~=0 and aq~=0;for dO in pairs(sN)do local type=b.getElementTypeById(sN[dO])if e8(type,'^.*Atmospheric Engine$')then if e8(tostring(b.getElementTagsById(sN[dO])),'^.*vertical.*$')and b.getElementForwardById(sN[dO])[3]>0 then d1=true end end;if e8(type,'^.*Space Engine$')then cS=true;if e8(tostring(b.getElementTagsById(sN[dO])),'^.*vertical.*$')then local tj=b.getElementForwardById(sN[dO])if tj[3]<0 then tk=true else cR=true end end end;if type=="Landing Gear"then bR=true end;if type=="Dynamic Core Unit"then local tl=sL(sN[dO])if tl>10000 then gJ=110 elseif tl>1000 then gJ=55 elseif tl>150 then gJ=27 end end;sP=sP+sL(sN[dO])if ti and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local tl=sL(sN[dO])local o2=ib(sN[dO])local td=0;local jf=bD()if type=="Atmospheric Fuel Tank"then local te=400;local tm=35.03;if tl>10000 then te=51200;tm=5480 elseif tl>1300 then te=6400;tm=988.67 elseif tl>150 then te=1600;tm=182.67 end;td=o2-tm;if a2>0 then te=te+te*a2*0.2 end;te=tc(td,te)ct[#ct+1]={sN[dO],th(sN[dO]),te,tm,td,jf}end;if type=="Rocket Fuel Tank"then local te=320;local tm=173.42;if tl>65000 then te=40000;tm=25740 elseif tl>6000 then te=5120;tm=4720 elseif tl>700 then te=640;tm=886.72 end;td=o2-tm;if a4>0 then te=te+te*a4*0.1 end;te=tc(td,te)cv[#cv+1]={sN[dO],th(sN[dO]),te,tm,td,jf}end;if type=="Space Fuel Tank"then local te=600;local tm=35.03;if tl>10000 then te=76800;tm=5480 elseif tl>1300 then te=9600;tm=988.67 elseif tl>150 then te=2400;tm=182.67 end;td=o2-tm;if a3>0 then te=te+te*a3*0.2 end;te=tc(td,te)cu[#cu+1]={sN[dO],th(sN[dO]),te,tm,td,jf}end end end;if not d1 then b4,aV=false,false end end;local function tn()if gyro~=nil then cn=gyro.getState()==1 end;if not bw then id:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then rU(1)else rU(0)end;if door and(ch or not ch and cj<10000)then for dT,dA in pairs(door)do dA.toggle()end end;if switch then for dT,dA in pairs(switch)do dA.toggle()end end;if forcefield and(ch or not ch==0 and cj<10000)then for dT,dA in pairs(forcefield)do dA.toggle()end end;if antigrav then d2=antigrav.getState()==1;if d2 and not q then antigrav.show()end end;if ic()==1 and k then a.freeze(1)else a.freeze(0)end;if bR then bh=d.control.isAnyLandingGearExtended()==1;if bh then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if cg~=-1 or not ch and cW:len()<50 then aW=true;bh=true;if bR then d.control.extendLandingGears()end else aW=false end;id:setTargetGroundAltitude(sM)if ch and cg~=-1 then cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;p1=ch end;local function to()local tp={}local function tq()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local tr={[1]=4480,[6]=4480,[7]=6270}for ts,tt in pairs(e)do e[ts][0]=tq()e[ts][0].systemId=ts;tp[ts]={}for tu,iI in pairs(e[ts])do iI.gravity=iI.gravity/9.8;iI.center=vec3(iI.center)iI.name=iI.name[1]iI.noAtmosphericDensityAltitude=iI.atmosphereThickness or iI.atmosphereRadius-iI.radius;iI.spaceEngineMinAltitude=tr[iI.id]or 0.68377*(iI.atmosphereThickness or iI.atmosphereRadius-iI.radius)iI.planetarySystemId=ts;iI.bodyId=iI.id;tp[ts][tu]=iI;if m8==nil or iI.center.x<m8 then m8=iI.center.x end;if m7==nil or iI.center.x>m7 then m7=iI.center.x end;if mb==nil or iI.center.y<mb then mb=iI.center.y end;if ma==nil or iI.center.y>ma then ma=iI.center.y end;if iI.center and iI.name~="Space"then dj[#dj+1]=iI end end end;ei=dm(d,b,c,a,dn,dp,dq,dr,ds)cx=ei(tp)cy=f1(d,b,c,a,dr,f2)cA=fw(d,b,c,a,dn,dp,dq,dr,ds)cC=fW(d,b,c,a,dbHud_1,e,fX,fY,bE,dq,dr,fZ)end;tv=false;tw=coroutine.create(function()id:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})t7()coroutine.yield()tb()coroutine.yield()cD=p6(d,b,c,a,e,vBooster,hover,p7,antigrav,warpdrive,dbHud_1,f2,bE,bF,ic,eY,bD,dp,id,fX,ie,dr,ig,fZ,ih,ds,ij,ik,p8,ia,dn,fY)tn()coroutine.yield()to()cE=gG(b,a,c,library,radar_1,radar_2,f2,gH,dr,gI,dq,gJ,fZ)cB=i8(d,b,c,a,e,radar_1,radar_2,antigrav,hover,i9,warpdrive,f2,bE,dn,ia,bF,ib,ic,eY,bD,dp,id,fY,fX,gH,ie,dr,ig,gI,fZ,ih,ii,ij,ik)cB.ButtonSetup()cF=rT(d,b,c,a,e,vBooster,hover,antigrav,i9,dbHud_2,gyro,ic,id,ie,rU,gH,ig,e8,dq,dp,fZ,ii,p8)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aO)c.setTimer("radarTick",aO)c.setTimer("hudTick",aP)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)fZ("start","SU")end)coroutine.resume(tw)end;function sJ.onUpdate()if not tv then local hW=coroutine.status(tw)if hW=="suspended"then local dP,hX=coroutine.resume(tw)if hX then a.print("ERROR STARTUP: "..hX)end elseif hW=="dead"then tv=true end end;if tv then d:update()if not cG and oH~=tx then a.setScreen(oH)end;tx=oH end end;function sJ.onFlush()local function ty(tz,qV)local tA=vec3()local tB=vec3()if tz==axisCommandId.longitudinal then tA=vec3(b.getConstructOrientationForward())tB=cU elseif tz==axisCommandId.vertical then tA=vec3(b.getConstructOrientationUp())tB=cT elseif tz==axisCommandId.lateral then tA=vec3(b.getConstructOrientationRight())tB=cV else return vec3()end;local tC=vec3(b.getWorldGravity())local tD=tC:dot(tB)local tE=vec3(b.getWorldAirFrictionAcceleration())local tF=tE:dot(tB)local tG=cW:dot(tA)local tH=qV*constants.kph2m;if tI==nil then tI=pid.new(10,0,10.0)end;tI:inject(tH-tG)local tJ=tI:get()local tK=(tJ-tF-tD)*tB;return tK end;local function tL(tz,qV)local tA=vec3()local tB=vec3()if tz==axisCommandId.longitudinal then tA=vec3(b.getConstructOrientationForward())tB=cU elseif tz==axisCommandId.vertical then tA=vec3(b.getConstructOrientationUp())tB=cT elseif tz==axisCommandId.lateral then tA=vec3(b.getConstructOrientationRight())tB=cV else return vec3()end;local tC=vec3(b.getWorldGravity())local tD=tC:dot(tB)local tE=vec3(b.getWorldAirFrictionAcceleration())local tF=tE:dot(tB)local tG=cW:dot(tA)local tH=qV*constants.kph2m;if tM==nil then tM=pid.new(10,0,10.0)end;tM:inject(tH-tG)local tJ=tM:get()local tK=(tJ-tF-tD)*tB;return tK end;local function tN(tO,ju,g5)local tP=tO:cross(g5):normalize_inplace()local kf=math.acos(dp(tP:dot(-ju),-1,1))*constants.rad2deg;if tP:cross(-ju):dot(g5)<0 then kf=-kf end;return kf end;if antigrav and not q then if not d2 and antigrav.getBaseAltitude()~=bq then antigrav.setBaseAltitude(bq)end end;d4=id:getAxisCommandType(0)==axisCommandType.byThrottle;aJ=math.max(aJ,0.01)aK=math.max(aK,0.01)aE=math.max(aE,0.01)aI=math.max(aI,0.01)aL=math.max(aL,0.01)aM=math.max(aM,0.01)aD=math.max(aD,0.01)local tQ=dp(bS+bT+a.getControlDeviceForwardInput(),-1,1)local tR=dp(bV+bY+a.getControlDeviceYawInput(),-1,1)local tS=dp(bW+bU-a.getControlDeviceLeftRightInput(),-1,1)local tT=bX;cZ=vec3(b.getWorldVertical())if cZ==nil or cZ:len()==0 then cZ=(iI.center-d0):normalize()end;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cX=vec3(b.getWorldVelocity())cW=vec3(b.getVelocity())d0=vec3(b.getConstructWorldPos())cl=b.getConstructMass()cY=vec3(cX):len()c_=-cZ:dot(cX)d6=getRoll(cZ,cU,cV)local tU=d6/180*math.pi;local tV=math.cos(tU)local tW=math.sin(tU)d5=tN(cZ,cU,cV*tV+cT*tW)local tX=cX:normalize()local tY=f2(d6)local tZ=utils.sign(d6)local t_=vec3(b.getWorldAngularVelocity())local u0=tQ*aJ*cV+tR*aE*cU+tS*aK*cT;if cI==true and cZ:len()>0.01 then local u1=f2(cK-d6)if((aY or b3 or b1 or cd or b0 or bu)and u1>0 or ci>0.0 and u1<aF and p)and tR==0 and f2(d5)<85 then local u2=cK;local u3=aD;if ci==0 then u3=u3/4;cK=0;u2=0 end;if u4==nil then u4=pid.new(u3*0.01,0,u3*0.1)end;u4:inject(u2-d6)local u5=u4:get()u0=u0+u5*cU end end;local u6=1;local u7=0;local u8=1;bL=0;if ch and u and d4 then if d4 and bO then cD.cmdThrottle(0)bO=false elseif not d4 and not bO then bK=0;bO=true end;if u9==nil then u9=pid.new(0.5,0,1)end;u9:inject(cL/3.6-cX:dot(cU))local ua=u9:get()bN=dp(ua,-1,1)if bN<bK and ci>0.005 then bM=true;id:setThrottleCommand(axisCommandId.longitudinal,dp(bN,0.01,1))else bM=false;id:setThrottleCommand(axisCommandId.longitudinal,bK)end;if ub==nil then ub=pid.new(1*0.01,0,1*0.1)end;ub:inject(cX:len()-cL/3.6)local uc=dp(ub:get(),0,1)if ci>0 and c_<-80 or ci>0.005 then bL=uc end;if bL>0 then if bM and bN==0.01 then id:setThrottleCommand(axisCommandId.longitudinal,0)end else bN=dp(bN,0.01,1)end;local ud=''local ue=vec3()local uf=ty(axisCommandId.vertical,c7*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",uf,u7)local ug='thrust analog longitudinal 'if bx=="All"or bx=="Longitude"then ug=ug..aQ end;local uh=id:getAxisCommandType(axisCommandId.longitudinal)local ui=id:composeAxisAccelerationFromThrottle(ug,axisCommandId.longitudinal)local uj=tL(axisCommandId.lateral,bt*1000)ud=ud..' , '.."lateral airfoil , lateral ground "ue=ue+uj;if ue:len()>constants.epsilon then d:setEngineForceCommand(ud,ue,u7,'','','',u8)end;d:setEngineForceCommand(ug,ui,u6)local uk='thrust analog vertical fueled 'local ul='thrust analog lateral fueled 'if bx=="All"or bx=="Lateral"then ul=ul..aR end;if bx=="All"or bx=="Vertical"then uk=uk..aS end;if c7~=0 or b1 and aW or not bh and not bw then d:setEngineForceCommand(uk,uf,u6)else d:setEngineForceCommand(uk,vec3(),u6)end;if bt~=0 then d:setEngineForceCommand(ul,uj,u6)else d:setEngineForceCommand(ul,vec3(),u6)end;if tT==0 then tT=bL end;local um=-tT*(aL*cX+aM*tX)d:setEngineForceCommand('brake',um)else if u then id:setThrottleCommand(axisCommandId.longitudinal,bK)end;local qV=c.getAxisCommandValue(0)if not d4 then if ub==nil then ub=pid.new(1*0.01,0,1*0.1)end;ub:inject(cX:len()-qV/3.6)local uc=dp(ub:get(),0,1)tT=dp(tT+uc,0,1)end;local um=-tT*(aL*cX+aM*tX)d:setEngineForceCommand('brake',um)local ud=''local ue=vec3()local un=false;local ug='thrust analog longitudinal 'if bx=="All"or bx=="Longitude"then ug=ug..aQ end;local uh=id:getAxisCommandType(axisCommandId.longitudinal)if uh==axisCommandType.byThrottle then local ui=id:composeAxisAccelerationFromThrottle(ug,axisCommandId.longitudinal)d:setEngineForceCommand(ug,ui,u6)elseif uh==axisCommandType.byTargetSpeed then local ui=id:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ud=ud..' , '..ug;ue=ue+ui;if id:getTargetSpeed(axisCommandId.longitudinal)==0 or id:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-id:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then un=true end end;local ul='thrust analog lateral 'if bx=="All"or bx=="Lateral"then ul=ul..aR end;local uo=id:getAxisCommandType(axisCommandId.lateral)if uo==axisCommandType.byThrottle then local up=id:composeAxisAccelerationFromThrottle(ul,axisCommandId.lateral)d:setEngineForceCommand(ul,up,u6)elseif uo==axisCommandType.byTargetSpeed then local uj=id:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ud=ud..' , '..ul;ue=ue+uj end;local uk='thrust analog vertical 'if bx=="All"or bx=="Vertical"then uk=uk..aS end;local uq=id:getAxisCommandType(axisCommandId.vertical)if uq==axisCommandType.byThrottle then local uf=id:composeAxisAccelerationFromThrottle(uk,axisCommandId.vertical)if c7~=0 or b1 and aW then d:setEngineForceCommand(uk,uf,u6,'airfoil','ground','',u8)else d:setEngineForceCommand(uk,vec3(),u6)d:setEngineForceCommand('airfoil vertical',uf,u6,'airfoil','','',u8)d:setEngineForceCommand('ground vertical',uf,u6,'ground','','',u8)end elseif uq==axisCommandType.byTargetSpeed then if c7<0 then d:setEngineForceCommand('hover',vec3(),u6)end;local ur=id:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ud=ud..' , '..uk;ue=ue+ur end;if ue:len()>constants.epsilon then if bX~=0 or un or f2(tX:dot(cU))<0.5 then ud=ud..', brake'end;d:setEngineForceCommand(ud,ue,u7,'','','',u8)end end;local us=aI*(u0-t_)local ut=vec3(b.getWorldAirFrictionAngularAcceleration())us=us-ut;d:setEngineTorqueCommand('torque',us,u6,'airfoil','','',u8)d:setBoosterCommand('rocket_engine')if c1 and not n then local fu=cW:len()local uu=0.15;if not d4 then local uv=id:getTargetSpeed(axisCommandId.longitudinal)if fu*3.6>uv*(1-uu)and so then so=false;d:toggleBoosters()elseif fu*3.6<uv*(1-uu)and not so then so=true;d:toggleBoosters()end else local oT=c.getThrottle()if u then oT=bK*100 end;local qV=oT/100;if bF==0 then qV=qV*_;if fu>=qV*(1-uu)and so then so=false;d:toggleBoosters()elseif fu<qV*(1-uu)and not so then so=true;d:toggleBoosters()end else local r7=bE(cL)qV=qV*r7/3.6;if fu>=qV*(1-uu)and so then so=false;d:toggleBoosters()elseif fu<qV*(1-uu)and not so then so=true;d:toggleBoosters()end end end end end;function sJ.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ci>0 or ci==0 and cj<10000)then for dT,dA in pairs(door)do dA.toggle()end end;if switch then for dT,dA in pairs(switch)do dA.toggle()end end;if forcefield and(ci>0 or ci==0 and cj<10000)then for dT,dA in pairs(forcefield)do dA.toggle()end end;x=dl;p8()if nE then nE.activate()end;if A then cD.showWayPoint(iI,d0)end;fZ("stop","SU")end;function sJ.OneSecondTick()local function uw(jr)local ux=0;cq=""local uy=sP;local uz=0;local uA=0;local uB=0;local jj=0;local jk=""local uC=b.getElementHitPointsById;for dO in pairs(sN)do local tl=0;local uD=0;uD=sL(sN[dO])tl=uC(sN[dO])uz=uz+tl;if tl<uD then if tl==0 then uB=uB+1 else uA=uA+1 end;if cw and#sO==0 then g0=vec3(b.getElementPositionById(sN[dO]))local hg=g0.x;local hh=g0.y;local hi=g0.z;table.insert(sO,b.spawnArrowSticker(hg,hh,hi+1,"down"))table.insert(sO,b.spawnArrowSticker(hg,hh,hi+1,"down"))b.rotateSticker(sO[2],0,0,90)table.insert(sO,b.spawnArrowSticker(hg+1,hh,hi,"north"))table.insert(sO,b.spawnArrowSticker(hg+1,hh,hi,"north"))b.rotateSticker(sO[4],90,90,0)table.insert(sO,b.spawnArrowSticker(hg-1,hh,hi,"south"))table.insert(sO,b.spawnArrowSticker(hg-1,hh,hi,"south"))b.rotateSticker(sO[6],90,-90,0)table.insert(sO,b.spawnArrowSticker(hg,hh-1,hi,"east"))table.insert(sO,b.spawnArrowSticker(hg,hh-1,hi,"east"))b.rotateSticker(sO[8],90,0,90)table.insert(sO,b.spawnArrowSticker(hg,hh+1,hi,"west"))table.insert(sO,b.spawnArrowSticker(hg,hh+1,hi,"west"))b.rotateSticker(sO[10],-90,0,90)table.insert(sO,sN[dO])end elseif cw and#sO>0 and sO[11]==sN[dO]then for je in pairs(sO)do b.deleteSticker(sO[je])end;sO={}end end;ux=bE(uz/uy*100)if ux<100 then jr[#jr+1]=gI(0,0,"","pbright txt")jj=bE(ux*2.55)jk=dn("rgb(%d,%d,%d)",255-jj,jj,0)if ux<100 then jr[#jr+1]=gI("50%",1035,"Elemental Integrity: "..ux.."%","txtbig txtmid","fill:"..jk)if uB>0 then jr[#jr+1]=gI("50%",1055,"Disabled Modules: "..uB.." Damaged Modules: "..uA,"txtbig txtmid","fill:"..jk)elseif uA>0 then jr[#jr+1]=gI("50%",1055,"Damaged Modules: "..uA,"txtbig txtmid","fill:"..jk)end end end end;local function uE()if sI then if uF==nil and(i6~=nil or bh)then _autoconf.displayCategoryPanel(sI,weapon_size,"Weapons","weapon",true)uF=_autoconf.panels[_autoconf.panels_size]elseif uF~=nil and i6==nil and not bh then gH(uF)uF=nil end end end;local function p3()local jf=bD()local kC=cY;local p4=jf-ck;if kC>1.38889 then kC=kC/1000;local p5=kC*(jf-ck)bi=bi+p5;c5=c5+p5 end;c6=c6+p4;bj=bj+p4;ck=jf end;p3()dh=b.getPlayersOnBoard()di=b.getDockedConstructs()uE()local jr={}cB.OneSecondTick(jr)if s then uw(jr)end;cc=table.concat(jr,"")collectgarbage("collect")end;function sJ.controlStart(s1)cF.startControl(s1)end;function sJ.controlStop(s1)cF.stopControl(s1)end;function sJ.controlLoop(s1)cF.loopControl(s1)end;function sJ.controlInput(rM)cF.inputTextControl(rM)end;function sJ.radarEnter(dY)cE.onEnter(dY)end;function sJ.radarLeave(dY)cE.onLeave(dY)end;function sJ.onTick(uG)if uG=="tenthSecond"then cD.TenthTick()cB.TenthTick()elseif uG=="oneSecond"then uH.OneSecondTick()elseif uG=="fiveSecond"then cD.SatNavTick()elseif uG=="msgTick"then cB.MsgTick()elseif uG=="animateTick"then cB.AnimateTick()elseif uG=="hudTick"then cB.hudtick()elseif uG=="apTick"then cD.APTick()elseif uG=="radarTick"then cE.UpdateRadar()elseif uG=="tagTick"then cF.tagTick()elseif uG=="contact"then cE.ContactTick()end end;return sJ end;function script.onStart()uH.onStart()end;function script.onStop()uH.onStop()end;function script.onTick(uG)uH.onTick(uG)end;function script.onFlush()uH.onFlush()end;function script.onUpdate()uH.onUpdate()end;function script.onActionStart(s1)uH.controlStart(s1)end;function script.onActionStop(s1)uH.controlStop(s1)end;function script.onActionLoop(s1)uH.controlLoop(s1)end;function script.onInputText(rM)uH.controlInput(rM)end;function script.onEnter(dY)uH.radarEnter(dY)end;function script.onLeave(dY)uH.radarLeave(dY)end;bC(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)uH=sH(d,b,c,a,library,e,vBooster,hover,p7,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,i9,gyro,warpdrive,sI)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
