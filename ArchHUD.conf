name: ArchHud - Archaegeo v1.702 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        require("autoconf/custom/archhud/globals")local a=Navigator.new(system,core,unit)local b=require("atlas")require("autoconf/custom/archhud/hudclass")require("autoconf/custom/archhud/apclass")script={}VERSION_NUMBER=1.702;local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=system.getTime;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local x=math.sqrt;local y=tonumber;local function z(A,B)local C=10^(B or 0)return d(A*C+0.5)/C end;time=o()local D=o()local E=13;PrimaryR=SafeR;PrimaryB=SafeB;PrimaryG=SafeG;PlayerThrottle=0;brakeInput2=0;ThrottleLimited=false;calculatedThrottle=0;WasInCruise=false;apThrottleSet=false;minAutopilotSpeed=55;reentryMode=false;hasGear=false;local F=0;pitchInput2=0;yawInput2=0;local G=0;local H=0;brakeInput=0;rollInput2=0;followMode=false;holdingShift=false;msgText="empty"local I=5;local J=5;local K=I;local L=J;isBoosting=false;brakeDistance=0;brakeTime=0;local M=0;local N=0;autopilotTargetPlanet=nil;totalDistanceTrip=0;flightTime=0;upAmount=0;simulatedX=0;simulatedY=0;msgTimer=3;distance=0;lastOdometerOutput=""spaceLand=false;spaceLaunch=false;finalLand=false;abvGndDet=-1;local O=""inAtmo=j()>0;atmosDensity=j()coreAltitude=core.getAltitude()local P=core.getElementIdList()lastTravelTime=o()coreMass=core.getConstructMass()local Q=false;gyroIsOn=nil;rgb=[[rgb(]]..d(PrimaryR+0.5)..","..d(PrimaryG+0.5)..","..d(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..d(PrimaryR*0.9+0.5)..","..d(PrimaryG*0.9+0.5)..","..d(PrimaryB*0.9+0.5)..[[)]]local R={}damageMessage=""local S=true;resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;atmoTanks={}spaceTanks={}rocketTanks={}local T=0;repairArrows=false;local U=nil;galaxyReference=nil;Kinematic=nil;maxKinematicUp=nil;Kep=nil;HUD=nil;ATLAS=nil;AP=nil;RADAR=nil;Animating=false;Animated=false;autoRoll=autoRollPreference;local V=LandingGearGroundHeight;stalling=false;targetRoll=0;adjustedAtmoSpeedLimit=AtmoSpeedLimit;VtPitch=0;orbitMsg=nil;orbitalParams={VectorToTarget=false}OrbitTargetOrbit=0;OrbitAchieved=false;local W=false;SpaceEngineVertDn=false;SpaceEngines=false;constructUp=vec3(core.getConstructWorldOrientationUp())constructForward=vec3(core.getConstructWorldOrientationForward())constructRight=vec3(core.getConstructWorldOrientationRight())coreVelocity=vec3(core.getVelocity())constructVelocity=vec3(core.getWorldVelocity())velMag=vec3(constructVelocity):len()worldVertical=vec3(core.getWorldVertical())vSpd=-worldVertical:dot(constructVelocity)worldPos=vec3(core.getConstructWorldPos())UpVertAtmoEngine=false;antigravOn=false;setCruiseSpeed=nil;throttleMode=true;adjustedPitch=0;adjustedRoll=0;AtlasOrdered={}notPvPZone=false;pvpDist=50000;ReversalIsOn=nil;local X={}nearPlanet=unit.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;collisionAlertStatus=false;collisionTarget=nil;rType="Atmo"apButtonsHovered=false;apScrollIndex=0;passengers=nil;ships=nil;planetAtlas={}scopeFOV=90;oldShowHud=showHud;function p(Y)system.print(time..": "..Y)end;local function Z(a0)local C=1;if a0 then C=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn and Q then local a1=PlayerThrottle;PlayerThrottle=z(q(PlayerThrottle+C*speedChangeLarge/100,-1,1),2)if PlayerThrottle>=0 and a1<0 then PlayerThrottle=0;Q=false end elseif AltIsOn then if atmosDensity>0 or Reentry then adjustedAtmoSpeedLimit=q(adjustedAtmoSpeedLimit+C*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+C*speedChangeLarge/3.6*100,0,8333.00)end else r:updateCommandFromActionStart(axisCommandId.longitudinal,C*speedChangeLarge)end else if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then apScrollIndex=apScrollIndex+1*C*-1;if apScrollIndex>#AtlasOrdered then apScrollIndex=1 end;if apScrollIndex<1 then apScrollIndex=#AtlasOrdered end else if not a0 then C=1 else C=nil end;ATLAS.adjustAutopilotTargetIndex(C)end end end;function play(a2,a3,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..a2 .."|"..a3 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..a2 .."|"..a3 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..a2 .."|"..a3 .."|"..soundVolume)end end;function addTable(a4,a5)for i=1,#a5 do a4[#a4+1]=a5[i]end;return a4 end;function saveableVariables(a6)local a7={}if not a6 then addTable(a7,saveableVariablesBoolean)addTable(a7,savableVariablesHandling)addTable(a7,savableVariablesHud)addTable(a7,savableVariablesPhysics)return a7 elseif a6=="boolean"then return saveableVariablesBoolean elseif a6=="handling"then return savableVariablesHandling elseif a6=="hud"then return savableVariablesHud elseif a6=="physics"then return savableVariablesPhysics end end;local function a8(a9,aa,ab,ac,ad)if ac==nil then ac=""end;if ad==nil then ad=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ac,a9,aa,ad,ab)end;function float_eq(ae,af)if ae==0 then return c(af)<1e-09 end;if af==0 then return c(ae)<1e-09 end;return c(ae-af)<math.max(c(ae),c(af))*epsilon end;function getDistanceDisplayString(distance,ag)local ah=distance>100000;if ag==nil then ag=1 end;if ah then return z(distance/1000/200,ag).."SU"elseif distance<1000 then return z(distance,ag).."M"else return z(distance/1000,ag).."KM"end end;function FormatTimeString(ai)local aj=0;local ak=0;local al=0;if ai<60 then ai=d(ai)elseif ai<3600 then aj=d(ai/60)ai=d(ai%60)elseif ai<86400 then ak=d(ai/3600)aj=d(ai%3600/60)else al=d(ai/86400)ak=d(ai%86400/3600)end;if al>0 then return al.."d "..ak.."h "elseif ak>0 then return ak.."h "..aj.."m "elseif aj>0 then return aj.."m "..ai.."s"elseif ai>0 then return ai.."s"else return"0s"end end;local function am(an)local function ao(ap)for aq,ar in pairs(ap)do dbHud_1.setStringValue(ar,g(_G[ar]))if an and dbHud_2 then dbHud_2.setStringValue(ar,g(_G[ar]))end end end;if dbHud_1 then ao(autoVariables)ao(saveableVariables())system.print("Saved Variables to Datacore")if an and dbHud_2 then msgText="Databank copied.  Remove copy when ready."end end end;local function as()local function at(au)return type(au)=='number'end;local function av(au)return type(y(au))=='number'end;local function aw(ax)return type(ax)=='table'end;local function ay(az)return type(az)=='string'end;local function aA(ar)return aw(ar)and at(ar.x and ar.y and ar.z)end;local function aB(aC)return aw(aC)and at(aC.latitude and aC.longitude and aC.altitude and aC.id and aC.systemId)end;local aD=math.pi/180;local aE=180/math.pi;local epsilon=1e-10;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aF='::pos{'..A..','..A..','..A..','..A..','..A..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function aG(au)local aH=string.gsub(string.reverse(e('%.4f',au)),'^0*%.?','')return aH==''and'0'or string.reverse(aH)end;local function aI(aJ)if aA(aJ)then return e('{x=%.3f,y=%.3f,z=%.3f}',aJ.x,aJ.y,aJ.z)end;if aw(aJ)and not getmetatable(aJ)then local aK={}local aL=next(aJ)if type(aL)=='nil'or aL==1 then aK=aJ else for aq,ar in pairs(aJ)do local aM=aI(ar)if type(aq)=='number'then table.insert(aK,e('[%s]=%s',aq,aM))else table.insert(aK,e('%s=%s',aq,aM))end end end;return e('{%s}',table.concat(aK,','))end;if ay(aJ)then return e("'%s'",aJ:gsub("'",[[\']]))end;return tostring(aJ)end;local aN={}aN.__index=aN;aN.__tostring=function(aJ,aO)local aP={}for aq in pairs(aJ)do table.insert(aP,aq)end;table.sort(aP)local aK={}for _,aq in ipairs(aP)do local aM=aI(aJ[aq])if type(aq)=='number'then table.insert(aK,e('[%s]=%s',aq,aM))else table.insert(aK,e('%s=%s',aq,aM))end end;if aO then return e('%s%s',aO,table.concat(aK,',\n'..aO))end;return e('{%s}',table.concat(aK,','))end;aN.__eq=function(aQ,aR)return aQ.systemId==aR.systemId and aQ.id==aR.id and float_eq(aQ.radius,aR.radius)and float_eq(aQ.center.x,aR.center.x)and float_eq(aQ.center.y,aR.center.y)and float_eq(aQ.center.z,aR.center.z)and float_eq(aQ.GM,aR.GM)end;local function aS(aT,aU,aV,aW,aX)assert(av(aT),'Argument 1 (systemId) must be a number:'..type(aT))assert(av(aU),'Argument 2 (id) must be a number:'..type(aU))assert(av(aV),'Argument 3 (radius) must be a number:'..type(aV))assert(aw(aW),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(aW))assert(av(aX),'Argument 5 (GM) must be a number:'..type(aX))return setmetatable({systemId=y(aT),id=y(aU),radius=y(aV),center=vec3(aW),GM=y(aX)},aN)end;local aY={}aY.__index=aY;aY.__tostring=function(p)return e('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,aG(p.latitude*aE),aG(p.longitude*aE),aG(p.altitude))end;aY.__eq=function(aQ,aR)return aQ.id==aR.id and aQ.systemId==aR.systemId and float_eq(aQ.latitude,aR.latitude)and float_eq(aQ.altitude,aR.altitude)and(float_eq(aQ.longitude,aR.longitude)or float_eq(aQ.latitude,math.pi/2)or float_eq(aQ.latitude,-math.pi/2))end;local function aZ(a_,aU,b0,b1,b2)local aT=a_;if ay(a_)and not b1 and not b2 and not aU and not b0 then aT,aU,b0,b1,b2=n(a_,aF)assert(aT,'Argument 1 (position string) is malformed.')else assert(av(aT),'Argument 1 (systemId) must be a number:'..type(aT))assert(av(aU),'Argument 2 (id) must be a number:'..type(aU))assert(av(b0),'Argument 3 (latitude) must be in degrees:'..type(b0))assert(av(b1),'Argument 4 (longitude) must be in degrees:'..type(b1))assert(av(b2),'Argument 5 (altitude) must be in meters:'..type(b2))end;aT=y(aT)aU=y(aU)b0=y(b0)b1=y(b1)b2=y(b2)if aU==0 then return setmetatable({latitude=b0,longitude=b1,altitude=b2,id=aU,systemId=aT},aY)end;return setmetatable({latitude=aD*q(b0,-90,90),longitude=aD*(b1%360),altitude=b2,id=aU,systemId=aT},aY)end;local b3={}b3.__index=b3;b3.__tostring=function(aJ,aO)local b4=aO and aO..'  'local b5={}local aP={}for aq in pairs(aJ)do table.insert(aP,aq)end;table.sort(aP)for _,b6 in ipairs(aP)do bdy=aJ[b6]local b7=aN.__tostring(bdy,b4)if aO then table.insert(b5,e('[%s]={\n%s\n%s}',b6,b7,aO))else table.insert(b5,e('  [%s]=%s',b6,b7))end end;if aO then return e('\n%s%s%s',aO,table.concat(b5,',\n'..aO),aO)end;return e('{\n%s\n}',table.concat(b5,',\n'))end;local function b8(b9)local b={}local pid;for _,ar in pairs(b9)do local aU=ar.planetarySystemId;if type(aU)~='number'then error('Invalid planetary system ID: '..tostring(aU))elseif pid and aU~=pid then error('Mistringmatch planetary system IDs: '..aU..' and '..pid)end;local ba=ar.bodyId;if type(ba)~='number'then error('Invalid body ID: '..tostring(ba))elseif b[ba]then error('Duplicate body ID: '..tostring(ba))end;setmetatable(ar.center,getmetatable(vec3.unit_x))b[ba]=setmetatable(ar,aN)pid=aU end;return setmetatable(b,b3)end;U={}local function bb(b9)return setmetatable({galaxyAtlas=b9 or{}},U)end;U.__index=function(ax,i)if type(i)=='number'then local system=ax.galaxyAtlas[i]return b8(system)end;return rawget(U,i)end;U.__pairs=function(aJ)return function(ax,aq)local bc,nv=next(ax,aq)return bc,nv and b8(nv)end,aJ.galaxyAtlas,nil end;U.__tostring=function(aJ)local bd={}for _,be in pairs(aJ or{})do local bf=be:getPlanetarySystemId()local bg=b3.__tostring(be,'    ')table.insert(bd,e('  [%s]={%s\n  }',bf,bg))end;return e('{\n%s\n}\n',table.concat(bd,',\n'))end;U.BodyParameters=aS;U.MapPosition=aZ;U.PlanetarySystem=b8;function U.createBodyParameters(aT,aU,bh,bi,bj,bk,bl)assert(av(aT),'Argument 1 (systemId) must be a number:'..type(aT))assert(av(aU),'Argument 2 (id) must be a number:'..type(aU))assert(av(bh),'Argument 3 (surfaceArea) must be a number:'..type(bh))assert(aw(bi),'Argument 4 (aPosition) must be an array or vec3:'..type(bi))assert(aw(bj),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(bj))assert(av(bk),'Argument 6 (altitude) must be in meters:'..type(bk))assert(av(bl),'Argument 7 (gravityAtPosition) must be number:'..type(bl))local aV=x(bh/4/math.pi)local distance=aV+bk;local bm=vec3(bi)+distance*vec3(bj)local aX=bl*distance*distance;return aS(aT,aU,aV,bm,aX)end;U.isMapPosition=aB;function U:getPlanetarySystem(a_)if i==nil then i=0 end;if nv==nil then nv=0 end;local aT=a_;if aB(a_)then aT=a_.systemId end;if type(aT)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=b3 then system=b8(system)end;return system end end end;function b3:sizeCalculator(bn)return 1.05*bn.radius end;function b3:castIntersections(bo,bp,bq,br,bs,bt)local bu={}if bs then for _,bn in pairs(bs)do table.insert(bu,bn)end else bu=planetAtlas end;if not bt then table.sort(bu,function(bv,bw)local ae=bv.center;local af=bw.center;return(ae.x-bo.x)^2+(ae.y-bo.y)^2+(ae.z-bo.z)^2<(af.x-bo.x)^2+(af.y-bo.y)^2+(af.z-bo.z)^2 end)end;local bx=bp:normalize()for _,bn in ipairs(bu)do local by=bn.center-bo;local aV=self:sizeCalculator(bn)local bz=by:dot(bx)local bA=bz^2-(by:len2()-aV^2)if bA>=0 then local bB=x(bA)local bC=bz+bB;local bD=bz-bB;if bD>0 then return bn,bC,bD elseif bC>0 then return bn,bC,nil end end end;return nil,nil,nil end;function b3:closestBody(bE)assert(type(bE)=='table','Invalid coordinates.')local bF,bn;local bG=vec3(bE)for _,bH in pairs(self)do local bI=(bH.center-bG):len2()if(not bn or bI<bF)and bH.name~="Space"then bn=bH;bF=bI end end;return bn end;function b3:convertToBodyIdAndWorldCoordinates(a_)local bJ=a_;if ay(a_)then bJ=aZ(a_)end;if bJ.id==0 then return 0,vec3(bJ.latitude,bJ.longitude,bJ.altitude)end;local bH=self:getBodyParameters(bJ)if bH then return bJ.id,bH:convertToWorldCoordinates(bJ)end end;function b3:getBodyParameters(a_)local aU=a_;if aB(a_)then aU=a_.id end;assert(av(aU),'Argument 1 (id) must be a number:'..type(aU))return self[aU]end;function b3:getPlanetarySystemId()local _,ar=next(self)return ar and ar.systemId end;function aN:convertToMapPosition(aW)assert(aw(aW),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(aW))local bK=vec3(aW)if self.id==0 then return setmetatable({latitude=bK.x,longitude=bK.y,altitude=bK.z,id=0,systemId=self.systemId},aY)end;local bL=bK-self.center;local distance=bL:len()local b2=distance-self.radius;local b0=0;local b1=0;if not float_eq(distance,0)then local bM=m(bL.y,bL.x)b1=bM>=0 and bM or 2*math.pi+bM;b0=math.pi/2-math.acos(bL.z/distance)end;return setmetatable({latitude=b0,longitude=b1,altitude=b2,id=self.id,systemId=self.systemId},aY)end;function aN:convertToWorldCoordinates(a_)local bJ=ay(a_)and aZ(a_)or a_;if bJ.id==0 then return vec3(bJ.latitude,bJ.longitude,bJ.altitude)end;assert(aB(bJ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(bJ.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(bJ.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local bN=math.cos(bJ.latitude)return self.center+(self.radius+bJ.altitude)*vec3(bN*math.cos(bJ.longitude),bN*math.sin(bJ.longitude),math.sin(bJ.latitude))end;function aN:getAltitude(aW)return(vec3(aW)-self.center):len()-self.radius end;function aN:getDistance(aW)return(vec3(aW)-self.center):len()end;function aN:getGravity(aW)local bO=self.center-vec3(aW)local bP=bO:len2()return self.GM/bP*bO/x(bP)end;return setmetatable(U,{__call=function(_,...)return bb(...)end})end;local function bQ()local Kinematic={}local bR=30000000/3600;local bS=bR*bR;local bT=100;function Kinematic.computeAccelerationTime(bU,bV,bW)local bX=bR*math.asin(bU/bR)return(bR*math.asin(bW/bR)-bX)/bV end;function Kinematic.computeDistanceAndTime(bU,bW,bY,bZ,b_,c0)b_=b_ or 0;c0=c0 or 0;local c1=bU<=bW;local c2=bZ*(c1 and 1 or-1)/bY;local c3=-c0/bY;local c4=c2+c3;if c1 and c4<=0 or not c1 and c4>=0 then return-1,-1 end;local c5,c6=0,0;if c2~=0 and b_>0 then local bX=math.asin(bU/bR)local c7=math.pi*(c2/2+c3)local c8=c2*b_;local c9=bR*math.pi;local ar=function(ax)local ca=(c7*ax-c8*math.sin(math.pi*ax/2/b_)+c9*bX)/c9;local cb=math.tan(ca)return bR*cb/x(cb*cb+1)end;local cc=c1 and function(az)return az>=bW end or function(az)return az<=bW end;c6=2*b_;if cc(ar(c6))then local cd=0;while c(c6-cd)>0.5 do local ax=(c6+cd)/2;if cc(ar(ax))then c6=ax else cd=ax end end end;local ce=bU;local cf=c6/bT;for cg=1,bT do local ch=ar(cg*cf)c5=c5+(ch+ce)*cf/2;ce=ch end;if c6<2*b_ then return c5,c6 end;bU=ce end;local bX=bR*math.asin(bU/bR)local time=(bR*math.asin(bW/bR)-bX)/c4;local ci=bS*math.cos(bX/bR)/c4;local distance=ci-bS*math.cos((c4*time+bX)/bR)/c4;return distance+c5,time+c6 end;function Kinematic.computeTravelTime(bU,bV,distance)if distance==0 then return 0 end;if bV>0 then local bX=bR*math.asin(bU/bR)local ci=bS*math.cos(bX/bR)/bV;return(bR*math.acos(bV*(ci-distance)/bS)-bX)/bV end;if bU==0 then return-1 end;assert(bU>0,'Acceleration and initial speed are both zero.')return distance/bU end;return Kinematic end;local function cj()local vec3=require('cpml.vec3')local as=as()local function ay(az)return type(az)=='string'end;local function aw(ax)return type(ax)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(b2)assert(self.body)local distance=b2+self.body.radius;if not float_eq(distance,0)then local ck=x(self.body.GM/distance)return x(2)*ck,ck end;return nil,nil end;function Kepler:orbitalParameters(a_,cl)assert(self.body)assert(aw(a_)or ay(a_))assert(aw(cl))local cm=(ay(a_)or as.isMapPosition(a_))and self.body:convertToWorldCoordinates(a_)or vec3(a_)local ar=vec3(cl)local cn=cm-self.body.center;local co=ar:len2()local cp=cn:len()local cq=self.body.GM;local cr=((co-cq/cp)*cn-cn:dot(ar)*ar)/cq;local ae=cq/(2*cq/cp-co)local cs=cr:len()local bx=cr:normalize()local ct=ae*(1-cs)local cu=ae*(1+cs)local cv=ct*bx+self.body.center;local cw=cs<=1 and-cu*bx+self.body.center or nil;local cx=x(ae*cq*(1-cs*cs))local cy=cw and 2*math.pi*x(ae^3/cq)local cz=math.acos(cr:dot(cn)/(cs*cp))if cn:dot(ar)<0 then cz=-(cz-2*math.pi)end;local cA=math.acos((math.cos(cz)+cs)/(1+cs*math.cos(cz)))local cB=cA;if cB<0 then cB=cB+2*math.pi end;local cC=cB-cs*math.sin(cB)local cD=0;local cE=0;local cF=0;if cy~=nil then cD=cC/(2*math.pi/cy)cE=cy-cD;cF=cE+cy/2;if cz-math.pi>0 then cE=cD;cF=cE+cy/2 end;if cF>cy then cF=cF-cy end end;return{periapsis={position=cv,speed=cx/ct,circularOrbitSpeed=x(cq/ct),altitude=ct-self.body.radius},apoapsis=cw and{position=cw,speed=cx/cu,circularOrbitSpeed=x(cq/cu),altitude=cu-self.body.radius},currentVelocity=ar,currentPosition=cm,eccentricity=cs,period=cy,eccentricAnomaly=cA,meanAnomaly=cC,timeToPeriapsis=cE,timeToApoapsis=cF,trueAnomaly=cz}end;local function cG(cH)local bH=as.BodyParameters(cH.systemId,cH.id,cH.radius,cH.center,cH.GM)return setmetatable({body=bH},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return cG(...)end})end;local function cI()local cJ={}local cK={}local cL={XS=13,S=27,M=55,L=110,XL=221}local cM={}local cN;local cO;local cP;local cQ;local cR;local cS={}local function cT()local function cU(cV,cW,cX,cY,cZ,c_,d0,d1)cW,cY,c_,d1=vec3(cW),vec3(cY),vec3(c_),vec3(d1)local d2,d3,d4=cV*cV,cX*cX,cZ*cZ;local co=cY-cW;local d5=co:normalize()local d6=co:len()local d7=c_-cW;local d8=(d7-d7:project_on(d5)):normalize()local d9,da=d7:dot(d5),d7:dot(d8)local db=d9*d9+da*da;local dc=d5:cross(d8)local a9=(d2-d3+d6*d6)/(2*d6)local aa=(d2-d4+db-2*d9*a9)/(2*da)local aC=d2-a9^2-aa^2;local dd=x(aC)local de=cW+d5*a9+d8*aa+dc*dd;local df=cW+d5*a9+d8*aa-dc*dd;if c((d1-de):len()-d0)<c((d1-df):len()-d0)then return de else return df end end;local function dg()local function dh()local di=core.getConstructWorldOrientationRight()local co=core.getConstructWorldOrientationForward()local d7=core.getConstructWorldOrientationUp()local dj=library.systemResolution3(di,co,d7,{1,0,0})local dk=library.systemResolution3(di,co,d7,{0,1,0})local dl=library.systemResolution3(di,co,d7,{0,0,1})return function(dm)return library.systemResolution3(dj,dk,dl,dm)end end;local dn=dh()local dp=core.getConstructWorldPos()local cm=core.getElementPositionById(1)local dq={cm[1],cm[2],cm[3]}local dr=dn(dq)local ds={dp[1]-dr[1],dp[2]-dr[2],dp[3]-dr[3]}return ds end;local function dt(du,cp,dv)local dw=du.pts;local dx=#dw;local dy=du.ref;if dx>3 then local dz,dA,dB,dC=dw[dx],dw[dx-1],dw[dx-2],dw[dx-3]du.ref=dv;local cm=cU(dz[1],dz[2],dA[1],dA[2],dB[1],dB[2],dC[1],dC[2])local a9,aa,dd=cm.x,cm.y,cm.z;if a9==a9 and aa==aa and dd==dd then a9=a9+dy[1]aa=aa+dy[2]dd=dd+dy[3]local dD=vec3(a9,aa,dd)if not du.lastPos then du.center=dD elseif(du.lastPos-dD):len()<2 then du.center=dD;du.skipCalc=true end;du.lastPos=dD end;du.pts={}else local dE={dv[1]-dy[1],dv[2]-dy[2],dv[3]-dy[3]}dw[dx+1]={cp,dE}end end;if radar_1 or radar_2 then RADAR.assignRadar()end;if cS[1]then cN=#cS[1].getConstructIds()local dF=cS[1].getData()local dG=dF:gmatch('{"constructId[^}]*}[^}]*}')if cN>0 then local dv=dg()local dH,dI=0,0;cR,cQ=0,0;for ar in dG do local aU,distance,dJ=ar:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local dK=cL[dJ]distance=y(distance)if cS[1].hasMatchingTransponder(aU)==1 then table.insert(cK,aU)end;local dL=cS[1].getConstructType(aU)if CollisionSystem then if dK>27 or dL=="static"or dL=="space"then cR=cR+1;local dM=cS[1].getConstructName(aU)local du=X[aU]if du==nil then dK=dK+E;X[aU]={pts={},ref=dv,name=dM,i=0,radius=dK,skipCalc=false}du=X[aU]end;if not du.skipCalc then dt(du,distance,dv)dI=dI+1 end;if du.center then table.insert(cM,du)end end;dH=dH+1;if nearPlanet and dH>700 or dI>70 or(not nearPlanet and dH>300 or dI>30)then coroutine.yield()dH,dI=0,0 end end end;cQ=#cM;if cQ>0 and velMag>20 then local bn,dN,dO,dP;local dQ=0;local dR=galaxyReference:getPlanetarySystem(0)dP=constructVelocity:normalize()while dQ<cQ do coroutine.yield()local dS={table.unpack(cM,dQ,math.min(dQ+75,cQ))}bn,dN,dO=dR:castIntersections(worldPos,dP,nil,nil,dS,true)if bn and dO then collisionTarget={bn,dN,dO}break end;dQ=dQ+75 end;if not bn then collisionTarget=nil end else collisionTarget=nil end;cM={}cO=dF:find('identifiedConstructs":%[%]')else cP=dF:find('worksInEnvironment":false')end end end;local function dT()if cS[1]then rType="Atmo"if cS[1].getData():find('worksInAtmosphere":false')then rType="Space"end end end;function cJ.pickType()dT()end;function cJ.assignRadar()if radar_1 and cS[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then cS[1]=radar_2 end;if cS[1]==radar_2 then dT()end elseif radar_2 and cS[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then cS[1]=radar_1 end;if cS[1]==radar_1 then dT()end end end;function cJ.UpdateRadar()local dU=coroutine.status(UpdateRadarCoroutine)if dU=="suspended"then local aM,dV=coroutine.resume(UpdateRadarCoroutine)if dV then system.print("ERROR UPDATE RADAR: "..dV)end elseif dU=="dead"then UpdateRadarCoroutine=coroutine.create(cT)local aM,dV=coroutine.resume(UpdateRadarCoroutine)end end;function cJ.GetRadarHud(dW,dX,dY,dZ)local d_=cK;local e0,Y;cK={}local A=cQ or 0;if cN>0 then if CollisionSystem then Y=A.."/"..cR.." Plotted : "..cN-cR.." Ignored"else Y="Radar Contacts: "..cN end;e0=a8(dY,dZ,Y,"pbright txtbig txtmid")if#cK>0 then e0=e0 ..a8(dW,dX,"Friendlies In Range","pbright txtbig txtmid")for aq,ar in pairs(cK)do dX=dX+20;e0=e0 ..a8(dW,dX,cS[1].getConstructName(ar),"pdim txtmid")end end;if cO==nil and perisPanelID==nil then peris=1;RADAR.ToggleRadarPanel()end;if cO~=nil and perisPanelID~=nil then RADAR.ToggleRadarPanel()end;if radarPanelID==nil then RADAR.ToggleRadarPanel()end else if cP then e0=a8(dY,dZ,rType.." Radar: Jammed","pbright txtbig txtmid")else e0=a8(dY,dZ,"Radar: No "..rType.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then peris=0;RADAR.ToggleRadarPanel()end end;return e0 end;function cJ.GetClosestName(dM)if cS[1]then local aU,_=cS[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if aU~=nil and aU~=""then dM=dM.." "..cS[1].getConstructName(aU)end end;return dM end;function cJ.ToggleRadarPanel()if radarPanelID~=nil and peris==0 then s(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then s(perisPanelID)perisPanelID=nil end else if peris==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(cS,1,"Periscope","periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(cS,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;peris=0 end end;cS[1]=nil;if radar_1 then cS[1]=radar_1;dT()end;UpdateRadarCoroutine=coroutine.create(cT)return cJ end;local function e1()local function e2(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function e3()local function e4(e5,e6)return e5.name<e6.name end;AtlasOrdered={}for aq,ar in pairs(b[0])do AtlasOrdered[#AtlasOrdered+1]={name=ar.name,index=aq}end;table.sort(AtlasOrdered,e4)end;local function e7(e8)for aq,ar in pairs(e8)do if ar.name and ar.name==CustomTarget.name then return aq end end;return-1 end;local function e9()apScrollIndex=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"autopilotTargetPlanet=nil;CustomTarget=nil;return true end;local ea=AtlasOrdered[AutopilotTargetIndex].index;local eb=b[0][ea]if eb.center then AutopilotTargetName=eb.name;autopilotTargetPlanet=galaxyReference[0][ea]if CustomTarget~=nil then if atmosDensity==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=eb;for _,ar in pairs(galaxyReference[0])do if ar.name==CustomTarget.planetname then autopilotTargetPlanet=ar;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)else AutopilotTargetCoords=CustomTarget.position end;if autopilotTargetPlanet.planetname~="Space"then if autopilotTargetPlanet.hasAtmosphere then AutopilotTargetOrbit=d(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function ec(ed)if not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit and not Reentry and not finalLand then if ed==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then e9()else local ea=AtlasOrdered[AutopilotTargetIndex].index;local eb=b[0][ea]if eb~=nil and eb.name=="Space"or iphCondition=="Custom Only"and eb.center or iphCondition=="No Moons"and string.find(eb.name,"Moon")~=nil then if ed==nil then ec()else ec(1)end else e9()end end else msgText="Disengage autopilot before changing Interplanetary Helper"play("iph","AP")end end;local function ee()local dx=-1;dx=e7(b[0])if dx>-1 then table.remove(b[0],dx)end;dx=-1;dx=e7(SavedLocations)if dx~=-1 then msgText=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,dx)end;ec()e3()end;local function ef(dM,position,eg,eh)if dbHud_1 or eg then local p=e2(position)local ei=p.gravity;if eh then ei=unit.getClosestPlanetInfluence()end;local ej={position=position,name=dM,planetname=p.name,gravity=ei,safe=eh}if not eg then SavedLocations[#SavedLocations+1]=ej else for aq,ar in pairs(b[0])do if ar.name and dM==ar.name then table.remove(b[0],aq)end end end;table.insert(b[0],ej)e3()e9()msgText="Location saved as "..dM.."("..p.name..")"else msgText="Databank must be installed to save permanent locations"end end;local ek={}function ek.UpdateAtlasLocationsList()e3()end;function ek.UpdateAutopilotTarget()e9()end;function ek.adjustAutopilotTargetIndex(ed)ec(ed)end;function ek.findAtlasIndex(e8)e7(e8)end;function ek.UpdatePosition(el)local dx=e7(SavedLocations)if dx~=-1 then if el~=nil then SavedLocations[dx].name=el;AutopilotTargetIndex=AutopilotTargetIndex-1;ec()else local em=SavedLocations[dx]em.gravity=unit.getClosestPlanetInfluence()em.position=worldPos;em.safe=true end;msgText=SavedLocations[dx].name.." position updated ("..SavedLocations[dx].planetname..")"else msgText="Name Not Found"end end;function ek.AddNewLocation(dM,position,eg,eh)ef(dM,position,eg,eh)end;function ek.ClearCurrentPosition()ee()end;for aq,ar in pairs(SavedLocations)do table.insert(b[0],ar)end;e3()if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end;ek.UpdateAutopilotTarget()return ek end;function script.onStart()local en=false;local function eo()local function ep(eq)local er=dbHud_1.hasKey;for aq,ar in pairs(eq)do if er(ar)then local aH=f(dbHud_1.getStringValue(ar))if aH~=nil then _G[ar]=aH;en=true end end end end;if dbHud_1 then if not useTheseSettings then ep(saveableVariables())coroutine.yield()ep(autoVariables)else ep(autoVariables)msgText="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"msgTimer=5;en=false end;coroutine.yield()if en then msgText="Loaded Saved Variables"resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)autoRoll=autoRollPreference;adjustedAtmoSpeedLimit=AtmoSpeedLimit;rgb=[[rgb(]]..d(PrimaryR+0.5)..","..d(PrimaryG+0.5)..","..d(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..d(PrimaryR*0.9+0.5)..","..d(PrimaryG*0.9+0.5)..","..d(PrimaryB*0.9+0.5)..[[)]]elseif not useTheseSettings then msgText="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then msgText="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else msgText="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<time then LastMaxBrakeInAtmo=0 end;LastStartTime=time;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then msgText="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"msgTimer=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function es()local function et(eu,ev)if eu>ev then ev=eu end;local ew,ex=0,0;if ContainerOptimization>0 then ew=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then ex=FuelTankOptimization*0.05 end;ev=ev*(1-(ew+ex))return ev end;local ey=core.getElementNameById;local ez=fuelX~=0 and fuelY~=0;for aq in pairs(P)do local type=core.getElementTypeById(P[aq])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(P[aq])),'^.*vertical.*$')and core.getElementForwardById(P[aq])[3]>0 then UpVertAtmoEngine=true end end;if n(type,'^.*Space Engine$')then SpaceEngines=true;if n(tostring(core.getElementTagsById(P[aq])),'^.*vertical.*$')then local eA=core.getElementForwardById(P[aq])if eA[3]<0 then W=true else SpaceEngineVertDn=true end end end;if type=="Landing Gear"then hasGear=true end;if type=="Dynamic Core Unit"then local eB=h(P[aq])if eB>10000 then E=110 elseif eB>1000 then E=55 elseif eB>150 then E=27 end end;T=T+h(P[aq])if ez and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local eB=h(P[aq])local eC=k(P[aq])local eu=0;local eD=o()if type=="Atmospheric Fuel Tank"then local ev=400;local eE=35.03;if eB>10000 then ev=51200;eE=5480 elseif eB>1300 then ev=6400;eE=988.67 elseif eB>150 then ev=1600;eE=182.67 end;eu=eC-eE;if fuelTankHandlingAtmo>0 then ev=ev+ev*fuelTankHandlingAtmo*0.2 end;ev=et(eu,ev)atmoTanks[#atmoTanks+1]={P[aq],ey(P[aq]),ev,eE,eu,eD}end;if type=="Rocket Fuel Tank"then local ev=320;local eE=173.42;if eB>65000 then ev=40000;eE=25740 elseif eB>6000 then ev=5120;eE=4720 elseif eB>700 then ev=640;eE=886.72 end;eu=eC-eE;if fuelTankHandlingRocket>0 then ev=ev+ev*fuelTankHandlingRocket*0.1 end;ev=et(eu,ev)rocketTanks[#rocketTanks+1]={P[aq],ey(P[aq]),ev,eE,eu,eD}end;if type=="Space Fuel Tank"then local ev=600;local eE=35.03;if eB>10000 then ev=76800;eE=5480 elseif eB>1300 then ev=9600;eE=988.67 elseif eB>150 then ev=2400;eE=182.67 end;eu=eC-eE;if fuelTankHandlingSpace>0 then ev=ev+ev*fuelTankHandlingSpace*0.2 end;ev=et(eu,ev)spaceTanks[#spaceTanks+1]={P[aq],ey(P[aq]),ev,eE,eu,eD}end end end;if not UpVertAtmoEngine then VertTakeOff,VertTakeOffEngine=false,false end end;local function eF()if gyro~=nil then gyroIsOn=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(inAtmo or not inAtmo and coreAltitude<10000)then for _,ar in pairs(door)do ar.toggle()end end;if switch then for _,ar in pairs(switch)do ar.toggle()end end;if forcefield and(inAtmo or not inAtmo==0 and coreAltitude<10000)then for _,ar in pairs(forcefield)do ar.toggle()end end;if antigrav then antigravOn=antigrav.getState()==1;if antigravOn and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if hasGear then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if abvGndDet~=-1 or not inAtmo and coreVelocity:len()<50 then BrakeIsOn=true;GearExtended=true;if hasGear then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(V)if inAtmo and abvGndDet~=-1 then maxKinematicUp=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=inAtmo end;local function eG()local eH={}local function eI()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local eJ={[1]=4480,[6]=4480,[7]=6270}for eK,eL in pairs(b)do b[eK][0]=eI()b[eK][0].systemId=eK;eH[eK]={}for eM,planet in pairs(b[eK])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=eJ[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=eK;planet.bodyId=planet.id;eH[eK][eM]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then planetAtlas[#planetAtlas+1]=planet end end end;U=as()galaxyReference=U(eH)Kinematic=bQ()Kep=cj()ATLAS=e1()end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})eo()coroutine.yield()es()coroutine.yield()AP=APClass(a,core,unit,system,b,vBooster,hover,telemeter_1,antigrav,c,d,j,l,m,o,q,r,t,w,x,z)eF()coroutine.yield()eG()RADAR=cI()HUD=HudClass(a,core,unit,system,b,radar_1,radar_2,antigrav,hover,shield_1,c,d,e,f,j,k,l,m,o,q,r,s,w,x,z,a8)HUD.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)play("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,ar in pairs(door)do ar.toggle()end end;if switch then for _,ar in pairs(switch)do ar.toggle()end end;if forcefield and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,ar in pairs(forcefield)do ar.toggle()end end;showHud=oldShowHud;am()if button then button.activate()end;if SetWaypointOnExit then AP.showWayPoint(planet,worldPos)end;play("stop","SU")end;function script.onTick(eN)local eO=nil;if eN=="contact"then if not contactTimer then contactTimer=0 end;if time>contactTimer+10 then msgText="Radar Contact"play("rdrCon","RC")contactTimer=time end;unit.stopTimer("contact")elseif eN=="tenthSecond"then local function eP()local eQ=system.createData;local eR=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=eR(panelInterplanetary,"value")interplanetaryHeaderText=eQ('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=eR(panelInterplanetary,"value")widgetDistanceText=eQ('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=eR(panelInterplanetary,"value")widgetTravelTimeText=eQ('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=eR(panelInterplanetary,"value")widgetMaxMassText=eQ('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=eR(panelInterplanetary,"value")widgetTargetOrbitText=eQ('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=eR(panelInterplanetary,"value")widgetCurBrakeDistanceText=eQ('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=eR(panelInterplanetary,"value")widgetCurBrakeTimeText=eQ('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=eR(panelInterplanetary,"value")widgetMaxBrakeDistanceText=eQ('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=eR(panelInterplanetary,"value")widgetMaxBrakeTimeText=eQ('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=eR(panelInterplanetary,"value")widgetTrajectoryAltitudeText=eQ('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not inAtmo then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function eS()s(panelInterplanetary)panelInterplanetary=nil end;local function eT()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(autopilotTargetPlanet.center-worldPos):len()else AutopilotDistance=(CustomTarget.position-worldPos):len()end end;local ch=velMag;local eU=unit.getThrottle()/100;if AtmoSpeedAssist then eU=PlayerThrottle end;local eV,eW=Kinematic.computeDistanceAndTime(velMag,MaxGameVelocity,coreMass,a:maxForceForward()*eU,warmup,0)local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,eX;if not TurnBurn and ch>0 then _,eX=AP.GetAutopilotBrakeDistanceAndTime(ch)else _,eX=AP.GetAutopilotTBBrakeDistanceAndTime(ch)end;local eY=0;local eZ=0;if AutopilotCruising or not Autopilot and ch>5 then eZ=Kinematic.computeTravelTime(ch,0,AutopilotDistance)elseif brakeDistance+eV<AutopilotDistance then eY=AutopilotDistance-(brakeDistance+eV)eZ=Kinematic.computeTravelTime(8333.0556,0,eY)else local e_=(AutopilotDistance-brakeDistance)/eV;eV=AutopilotDistance-brakeDistance;eW=eW*e_ end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return eZ elseif AutopilotBraking then return eX elseif AutopilotCruising then return eZ+eX else return eW+brakeTime+eZ end end;local function f0(ei,f1)if ei==nil then ei=core.g()end;ei=z(ei,5)if f1~=nil and f1 or(eO==nil or eO~=ei)then local ch=coreVelocity:len()local f2=f(unit.getData()).maxBrake;if f2~=nil and f2>0 and inAtmo then f2=f2/q(ch/100,0.1,1)f2=f2/atmosDensity;if atmosDensity>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+f2)/2 else LastMaxBrakeInAtmo=f2 end end end;if f2~=nil and f2>0 then LastMaxBrake=f2 end;eO=ei end end;f0(nil,true)if setCruiseSpeed~=nil then if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or r:getTargetSpeed(axisCommandId.longitudinal)~=setCruiseSpeed then AP.cmdCruise(setCruiseSpeed)else setCruiseSpeed=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then eP()end;if AutopilotTargetName~=nil then local f3=CustomTarget~=nil;local f4=0.5*LastMaxBrakeInAtmo/autopilotTargetPlanet:getGravity(autopilotTargetPlanet.center+vec3(0,0,1)*autopilotTargetPlanet.radius):len()f4=f4>1000000 and z(f4/1000000,2).." kTons"or z(f4/1000,2).." Tons"t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=eT()if f3 and not Autopilot then distance=(worldPos-CustomTarget.position):len()else distance=(AutopilotTargetCoords-worldPos):len()end;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(velMag)M,N=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(velMag)M,N=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local f5=getDistanceDisplayString(distance)t(widgetDistanceText,'{"label": "distance", "value": "'..f5 ..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..FormatTimeString(travelTime)..'", "unit":""}')f5=getDistanceDisplayString(brakeDistance)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..f5 ..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..FormatTimeString(brakeTime)..'", "unit":""}')f5=getDistanceDisplayString(M)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..f5 ..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..FormatTimeString(N)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..e("%s",f4)..'", "unit":""}')f5=getDistanceDisplayString(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..f5 ..'"}')if atmosDensity>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not throttleMode and AtmoSpeedAssist and(AltitudeHold or Reentry or finalLand)then AP.cmdThrottle(1)BrakeIsOn=false;WasInCruise=false end end;if atmosDensity==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else eS()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;HUD.TenthTick()elseif eN=="oneSecond"then local function f6(f7)local f8=0;damageMessage=""local f9=T;local fa=0;local fb=0;local fc=0;local fd=0;local fe=""local ff=core.getElementHitPointsById;for aq in pairs(P)do local eB=0;local fg=0;fg=h(P[aq])eB=ff(P[aq])fa=fa+eB;if eB<fg then if eB==0 then fc=fc+1 else fb=fb+1 end;if repairArrows and#R==0 then position=vec3(core.getElementPositionById(P[aq]))local a9=position.x;local aa=position.y;local dd=position.z;table.insert(R,core.spawnArrowSticker(a9,aa,dd+1,"down"))table.insert(R,core.spawnArrowSticker(a9,aa,dd+1,"down"))core.rotateSticker(R[2],0,0,90)table.insert(R,core.spawnArrowSticker(a9+1,aa,dd,"north"))table.insert(R,core.spawnArrowSticker(a9+1,aa,dd,"north"))core.rotateSticker(R[4],90,90,0)table.insert(R,core.spawnArrowSticker(a9-1,aa,dd,"south"))table.insert(R,core.spawnArrowSticker(a9-1,aa,dd,"south"))core.rotateSticker(R[6],90,-90,0)table.insert(R,core.spawnArrowSticker(a9,aa-1,dd,"east"))table.insert(R,core.spawnArrowSticker(a9,aa-1,dd,"east"))core.rotateSticker(R[8],90,0,90)table.insert(R,core.spawnArrowSticker(a9,aa+1,dd,"west"))table.insert(R,core.spawnArrowSticker(a9,aa+1,dd,"west"))core.rotateSticker(R[10],-90,0,90)table.insert(R,P[aq])end elseif repairArrows and#R>0 and R[11]==P[aq]then for fh in pairs(R)do core.deleteSticker(R[fh])end;R={}end end;f8=d(fa/f9*100)if f8<100 then f7[#f7+1]=a8(0,0,"","pbright txt")fd=d(f8*2.55)fe=e("rgb(%d,%d,%d)",255-fd,fd,0)if f8<100 then f7[#f7+1]=a8("50%",1035,"Elemental Integrity: "..f8 .."%","txtbig txtmid","fill:"..fe)if fc>0 then f7[#f7+1]=a8("50%",1055,"Disabled Modules: "..fc.." Damaged Modules: "..fb,"txtbig txtmid","fill:"..fe)elseif fb>0 then f7[#f7+1]=a8("50%",1055,"Damaged Modules: "..fb,"txtbig txtmid","fill:"..fe)end end end end;local function fi()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function fj()local eD=o()local fk=velMag;local fl=eD-lastTravelTime;if fk>1.38889 then fk=fk/1000;local fm=fk*(eD-lastTravelTime)TotalDistanceTravelled=TotalDistanceTravelled+fm;totalDistanceTrip=totalDistanceTrip+fm end;flightTime=flightTime+fl;TotalFlightTime=TotalFlightTime+fl;lastTravelTime=eD end;fj()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()fi()local f7={}HUD.OneSecond(f7)if ShouldCheckDamage then f6(f7)end;lastOdometerOutput=table.concat(f7,"")collectgarbage("collect")elseif eN=="fiveSecond"then if not UseSatNav then return end;O=dbHud_1.getStringValue("SPBAutopilotTargetName")if O~=nil and O~=""and O~="SatNavNotChanged"then local aH=f(dbHud_1.getStringValue("SavedLocations"))if aH~=nil then _G["SavedLocations"]=aH;local dx=-1;local ej;for aq,ar in pairs(SavedLocations)do if ar.name and ar.name=="SatNav Location"then dx=aq;break end end;if dx~=-1 then ej=SavedLocations[dx]dx=-1;for aq,ar in pairs(b[0])do if ar.name and ar.name=="SatNav Location"then dx=aq;break end end;if dx>-1 then b[0][dx]=ej end;ATLAS.UpdateAtlasLocationsList()msgText=ej.name.." position updated"end end;for i=1,#AtlasOrdered do if AtlasOrdered[i].name==O then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..AtlasOrdered[i].name)ATLAS.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif eN=="msgTick"then local f7={}HUD.DisplayMessage(f7,"empty")msgText="empty"unit.stopTimer("msgTick")msgTimer=3 elseif eN=="animateTick"then Animated=true;Animating=false;simulatedX=0;simulatedY=0;unit.stopTimer("animateTick")elseif eN=="hudTick"then HUD.hudtick()elseif eN=="apTick"then AP.APTick()elseif eN=="radarTick"then RADAR.UpdateRadar()elseif eN=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;msgText="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function fn(fo,fp)local fq=vec3()local fr=vec3()if fo==axisCommandId.longitudinal then fq=vec3(core.getConstructOrientationForward())fr=constructForward elseif fo==axisCommandId.vertical then fq=vec3(core.getConstructOrientationUp())fr=constructUp elseif fo==axisCommandId.lateral then fq=vec3(core.getConstructOrientationRight())fr=constructRight else return vec3()end;local fs=vec3(core.getWorldGravity())local ft=fs:dot(fr)local fu=vec3(core.getWorldAirFrictionAcceleration())local fv=fu:dot(fr)local fw=coreVelocity:dot(fq)local fx=fp*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(fx-fw)local fy=targetSpeedPID2:get()local fz=(fy-fv-ft)*fr;return fz end;local function fA(fo,fp)local fq=vec3()local fr=vec3()if fo==axisCommandId.longitudinal then fq=vec3(core.getConstructOrientationForward())fr=constructForward elseif fo==axisCommandId.vertical then fq=vec3(core.getConstructOrientationUp())fr=constructUp elseif fo==axisCommandId.lateral then fq=vec3(core.getConstructOrientationRight())fr=constructRight else return vec3()end;local fs=vec3(core.getWorldGravity())local ft=fs:dot(fr)local fu=vec3(core.getWorldAirFrictionAcceleration())local fv=fu:dot(fr)local fw=coreVelocity:dot(fq)local fx=fp*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(fx-fw)local fy=targetSpeedPID:get()local fz=(fy-fv-ft)*fr;return fz end;local function fB(fC,fD,e6)local fE=fC:cross(e6):normalize_inplace()local fF=math.acos(q(fE:dot(-fD),-1,1))*constants.rad2deg;if fE:cross(-fD):dot(e6)<0 then fF=-fF end;return fF end;if antigrav and not ExternalAGG then if not antigravOn and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;throttleMode=r:getAxisCommandType(0)==axisCommandType.byThrottle;if throttleMode and WasInCruise then AP.cmdThrottle(0)WasInCruise=false elseif not throttleMode and not WasInCruise then PlayerThrottle=0;WasInCruise=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local fG=q(F+pitchInput2+system.getControlDeviceForwardInput(),-1,1)local fH=q(G+rollInput2+system.getControlDeviceYawInput(),-1,1)local fI=q(H+yawInput2-system.getControlDeviceLeftRightInput(),-1,1)local fJ=brakeInput;worldVertical=vec3(core.getWorldVertical())if worldVertical==nil or worldVertical:len()==0 then worldVertical=(planet.center-worldPos):normalize()end;constructUp=vec3(core.getConstructWorldOrientationUp())constructForward=vec3(core.getConstructWorldOrientationForward())constructRight=vec3(core.getConstructWorldOrientationRight())constructVelocity=vec3(core.getWorldVelocity())coreVelocity=vec3(core.getVelocity())worldPos=vec3(core.getConstructWorldPos())coreMass=core.getConstructMass()velMag=vec3(constructVelocity):len()vSpd=-worldVertical:dot(constructVelocity)adjustedRoll=getRoll(worldVertical,constructForward,constructRight)local fK=adjustedRoll/180*math.pi;local fL=math.cos(fK)local fM=math.sin(fK)adjustedPitch=fB(worldVertical,constructForward,constructRight*fL+constructUp*fM)local fN=constructVelocity:normalize()local fO=c(adjustedRoll)local fP=utils.sign(adjustedRoll)local fQ=vec3(core.getWorldAngularVelocity())local fR=fG*pitchSpeedFactor*constructRight+fH*rollSpeedFactor*constructForward+fI*yawSpeedFactor*constructUp;if autoRoll==true and worldVertical:len()>0.01 then local fS=c(targetRoll-adjustedRoll)if((ProgradeIsOn or Reentry or BrakeLanding or spaceLand or AltitudeHold or IntoOrbit)and fS>0 or atmosDensity>0.0 and fS<autoRollRollThreshold and autoRollPreference)and fH==0 and c(adjustedPitch)<85 then local fT=targetRoll;local fU=autoRollFactor;if atmosDensity==0 then fU=fU/4;targetRoll=0;fT=0 end;if rollPID==nil then rollPID=pid.new(fU*0.01,0,fU*0.1)end;rollPID:inject(fT-adjustedRoll)local fV=rollPID:get()fR=fR+fV*constructForward end end;local fW=1;local fX=0;local fY=1;local fZ=system.getMouseWheel()if fZ>0 then Z()elseif fZ<0 then Z(true)else Q=true end;brakeInput2=0;if inAtmo and AtmoSpeedAssist and throttleMode then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(adjustedAtmoSpeedLimit/3.6-constructVelocity:dot(constructForward))local f_=throttlePID:get()calculatedThrottle=q(f_,-1,1)if calculatedThrottle<PlayerThrottle and atmosDensity>0.005 then ThrottleLimited=true;r:setThrottleCommand(axisCommandId.longitudinal,q(calculatedThrottle,0.01,1))else ThrottleLimited=false;r:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-adjustedAtmoSpeedLimit/3.6)local g0=q(brakePID:get(),0,1)if atmosDensity>0 and vSpd<-80 or atmosDensity>0.005 then brakeInput2=g0 end;if brakeInput2>0 then if ThrottleLimited and calculatedThrottle==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else calculatedThrottle=q(calculatedThrottle,0.01,1)end;local g1=''local g2=vec3()local g3=fn(axisCommandId.vertical,upAmount*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",g3,fX)local g4='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then g4=g4 ..ExtraLongitudeTags end;local g5=r:getAxisCommandType(axisCommandId.longitudinal)local g6=r:composeAxisAccelerationFromThrottle(g4,axisCommandId.longitudinal)local g7=fA(axisCommandId.lateral,LeftAmount*1000)g1=g1 ..' , '.."lateral airfoil , lateral ground "g2=g2+g7;if g2:len()>constants.epsilon then a:setEngineForceCommand(g1,g2,fX,'','','',fY)end;a:setEngineForceCommand(g4,g6,fW)local g8='thrust analog vertical fueled 'local g9='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then g9=g9 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then g8=g8 ..ExtraVerticalTags end;if upAmount~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(g8,g3,fW)else a:setEngineForceCommand(g8,vec3(),fW)end;if LeftAmount~=0 then a:setEngineForceCommand(g9,g7,fW)else a:setEngineForceCommand(g9,vec3(),fW)end;if fJ==0 then fJ=brakeInput2 end;local ga=-fJ*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*fN)a:setEngineForceCommand('brake',ga)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;local fp=unit.getAxisCommandValue(0)if not throttleMode then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-fp/3.6)local g0=q(brakePID:get(),0,1)fJ=q(fJ+g0,0,1)end;local ga=-fJ*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*fN)a:setEngineForceCommand('brake',ga)local g1=''local g2=vec3()local gb=false;local g4='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then g4=g4 ..ExtraLongitudeTags end;local g5=r:getAxisCommandType(axisCommandId.longitudinal)if g5==axisCommandType.byThrottle then local g6=r:composeAxisAccelerationFromThrottle(g4,axisCommandId.longitudinal)a:setEngineForceCommand(g4,g6,fW)elseif g5==axisCommandType.byTargetSpeed then local g6=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)g1=g1 ..' , '..g4;g2=g2+g6;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then gb=true end end;local g9='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then g9=g9 ..ExtraLateralTags end;local gc=r:getAxisCommandType(axisCommandId.lateral)if gc==axisCommandType.byThrottle then local gd=r:composeAxisAccelerationFromThrottle(g9,axisCommandId.lateral)a:setEngineForceCommand(g9,gd,fW)elseif gc==axisCommandType.byTargetSpeed then local g7=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)g1=g1 ..' , '..g9;g2=g2+g7 end;local g8='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then g8=g8 ..ExtraVerticalTags end;local ge=r:getAxisCommandType(axisCommandId.vertical)if ge==axisCommandType.byThrottle then local g3=r:composeAxisAccelerationFromThrottle(g8,axisCommandId.vertical)if upAmount~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(g8,g3,fW,'airfoil','ground','',fY)else a:setEngineForceCommand(g8,vec3(),fW)a:setEngineForceCommand('airfoil vertical',g3,fW,'airfoil','','',fY)a:setEngineForceCommand('ground vertical',g3,fW,'ground','','',fY)end elseif ge==axisCommandType.byTargetSpeed then if upAmount<0 then a:setEngineForceCommand('hover',vec3(),fW)end;local gf=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)g1=g1 ..' , '..g8;g2=g2+gf end;if g2:len()>constants.epsilon then if brakeInput~=0 or gb or c(fN:dot(constructForward))<0.5 then g1=g1 ..', brake'end;a:setEngineForceCommand(g1,g2,fX,'','','',fY)end end;local gg=torqueFactor*(fR-fQ)local gh=vec3(core.getWorldAirFrictionAngularAcceleration())gg=gg-gh;a:setEngineTorqueCommand('torque',gg,fW,'airfoil','','',fY)a:setBoosterCommand('rocket_engine')if isBoosting and not VanillaRockets then local ch=coreVelocity:len()local gi=0.15;if not throttleMode then local gj=r:getTargetSpeed(axisCommandId.longitudinal)if ch*3.6>gj*(1-gi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ch*3.6<gj*(1-gi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local eU=unit.getThrottle()if AtmoSpeedAssist then eU=PlayerThrottle*100 end;local fp=eU/100;if j==0 then fp=fp*MaxGameVelocity;if ch>=fp*(1-gi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ch<fp*(1-gi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local gk=d(adjustedAtmoSpeedLimit)fp=fp*gk/3.6;if ch>=fp*(1-gi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ch<fp*(1-gi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local dU=coroutine.status(beginSetup)if dU=="suspended"then local aM,dV=coroutine.resume(beginSetup)if dV then system.print("ERROR STARTUP: "..dV)end elseif dU=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not Animating and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(gl)local function gm(a0)local C=1;local function gn(go,a0)local gp={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local gq=go;for _,ar in ipairs(gp)do if a0 and gq>ar then go=ar elseif go<ar and not a0 then go=ar;break end end;return go end;if a0 then C=-1 end;if not ExternalAGG and antigravOn then if holdingShift and a0 then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*J;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+C*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if holdingShift then OrbitTargetOrbit=gn(OrbitTargetOrbit,a0)else OrbitTargetOrbit=OrbitTargetOrbit+C*I end;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else if holdingShift and inAtmo then HoldAltitude=gn(HoldAltitude,a0)else HoldAltitude=HoldAltitude+C*I end end else r:updateTargetGroundAltitudeFromActionStart(C*1.0)end end;local function gr(gs)if not inAtmo then msgText="Flight Assist in Atmo only"return end;local ax=type(gs)if ReversalIsOn==nil then if ax=="table"then if Autopilot or VectorToTarget then AP.ToggleAutopilot()end;play("180On","BR")elseif gs==1 then play("bnkLft","BR")else play("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then AP.ToggleAltitudeHold()if ax~="table"then gs=gs+1 end end;ReversalIsOn=gs else play("180Off","BR")ReversalIsOn=nil end end;if gl=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;AP.cmdThrottle(0)if vBooster or hover then if inAtmo and abvGndDet==-1 then play("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;autoRoll=true;GearExtended=false else if hasGear then play("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if inAtmo then BrakeIsOn=true end end end;if hasGear and not BrakeLanding and not(vBooster or hover)then play("grOut","LG",1)a.control.extendLandingGears()end else if hasGear then play("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif gl=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif gl=="forward"then F=F-1 elseif gl=="backward"then if AltIsOn then gr(-constructVelocity*5000)else F=F+1 end elseif gl=="left"then if AltIsOn then gr(1)else G=G-1 end elseif gl=="right"then if AltIsOn then gr(3)else G=G+1 end elseif gl=="yawright"then H=H-1 elseif gl=="yawleft"then H=H+1 elseif gl=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif gl=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif gl=="up"then upAmount=upAmount+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif gl=="down"then upAmount=upAmount-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif gl=="groundaltitudeup"then gm()elseif gl=="groundaltitudedown"then gm(true)elseif gl=="option1"then toggleView=false;if AltIsOn and holdingShift then local gt=""for i=1,#passengers do gt=gt.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..z(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..gt)return end;ATLAS.adjustAutopilotTargetIndex()elseif gl=="option2"then toggleView=false;if AltIsOn and holdingShift then for i=1,#passengers do core.forceDeboard(passengers[i])end;msgText="Deboarded All Passengers"return end;ATLAS.adjustAutopilotTargetIndex(1)elseif gl=="option3"then local function gu()S=not S;if not S then play("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else play("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then s(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then s(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and holdingShift then local gt=""for i=1,#ships do gt=gt.."| ID: "..ships[i].." Mass: "..z(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..gt)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;gu()toggleView=false elseif gl=="option4"then toggleView=false;if AltIsOn and holdingShift then for i=1,#ships do core.forceUndock(ships[i])end;msgText="Undocked all ships"return end;ReversalIsOn=nil;AP.ToggleAutopilot()elseif gl=="option5"then toggleView=false;AP.ToggleLockPitch()elseif gl=="option6"then toggleView=false;if AltIsOn and holdingShift then if shield_1 then local gv=shield_1.getVentingCooldown()if gv>0 then msgText="Cannot vent again for "..gv.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()msgText="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else msgText="Shields already at max hitpoints"end;return else msgText="No shield found"return end end;AP.ToggleAltitudeHold()elseif gl=="option7"then toggleView=false;if AltIsOn and holdingShift then if shield_1 then shield_1.toggle()return else msgText="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then msgText="Collision System Enabled"else msgText="Collision System Secured"end elseif gl=="option8"then stablized=not stablized;if not stablized then msgText="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()play("gsOff","GS")else msgText="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)play("gsOn","GS")end;toggleView=false elseif gl=="option9"then if AltIsOn and holdingShift then r:resetCommand(axisCommandId.longitudinal)r:resetCommand(axisCommandId.lateral)r:resetCommand(axisCommandId.vertical)AP.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()gyroIsOn=gyro.getState()==1;if gyroIsOn then play("gyOn","GA")else play("gyOff","GA")end end;toggleView=false elseif gl=="lshift"then apButtonsHovered=false;if AltIsOn then holdingShift=true end;if w()==1 then holdingShift=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then holdingShift=true;Animated=false;Animating=false end elseif gl=="brake"then if BrakeToggleStatus or AltIsOn then AP.BrakeToggle()elseif not BrakeIsOn then AP.BrakeToggle()else BrakeIsOn=true end elseif gl=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif gl=="booster"then if VanillaRockets then a:toggleBoosters()elseif not isBoosting then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;isBoosting=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;isBoosting=false end elseif gl=="stopengines"then local function gw()if time-D<1.5 then play("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;ReversalIsOn=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;followMode=false;apThrottleSet=false;spaceLand=false;spaceLaunch=false;reentryMode=false;autoRoll=autoRollPreference;VectorToTarget=false;TurnBurn=false;gyroIsOn=false;LockPitch=nil;IntoOrbit=false end end;gw()D=time;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if PlayerThrottle~=0 then r:resetCommand(axisCommandId.longitudinal)AP.cmdThrottle(0)else AP.cmdThrottle(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if inAtmo then AP.cmdCruise(AtmoSpeedLimit)else AP.cmdCruise(MaxGameVelocity*3.6)end end end elseif gl=="speedup"then Z()elseif gl=="speeddown"then Z(true)elseif gl=="antigravity"and not ExternalAGG then if antigrav~=nil then AP.ToggleAntigrav()end end end;function script.onActionStop(gl)local function gx()if not ExternalAGG and antigravOn then L=J end;if AltitudeHold or VertTakeOff or IntoOrbit then K=I end end;if gl=="forward"then F=0 elseif gl=="backward"then F=0 elseif gl=="left"then if ReversalIsOn then if ReversalIsOn==2 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;G=0 elseif gl=="right"then if ReversalIsOn then if ReversalIsOn==4 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;G=0 elseif gl=="yawright"then H=0 elseif gl=="yawleft"then H=0 elseif gl=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif gl=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif gl=="up"then upAmount=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif gl=="down"then upAmount=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif gl=="groundaltitudeup"then gx()toggleView=false elseif gl=="groundaltitudedown"then gx()toggleView=false elseif gl=="lshift"then if w()==1 then simulatedX=0;simulatedY=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then Animated=false;Animating=false end;holdingShift=false elseif gl=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then AP.BrakeToggle()else BrakeIsOn=false end end elseif gl=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(gl)local function gy(a0)local C=1;if a0 then C=-1 end;if not ExternalAGG and antigravOn then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*L;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;L=q(L*1.05,J,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+C*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then OrbitTargetOrbit=OrbitTargetOrbit+C*K;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+C*K end;K=q(K*1.05,I,50)else r:updateTargetGroundAltitudeFromActionLoop(C*1.0)end end;local function gz(a0)local C=1;if a0 then C=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn then PlayerThrottle=q(PlayerThrottle+C*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,C*speedChangeSmall)end end end;if gl=="groundaltitudeup"then if not holdingShift then gy()end elseif gl=="groundaltitudedown"then if not holdingShift then gy(true)end elseif gl=="speedup"then gz()elseif gl=="speeddown"then gz(true)end end;function script.onInputText(ab)local function gA(gB,cm,eg)local function gC(cm)local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aF='::pos{'..A..','..A..','..A..','..A..','..A..'}'local aT,aU,b0,b1,b2=n(cm,aF)if aT=="0"and aU=="0"then return vec3(y(b0),y(b1),y(b2))end;b1=math.rad(b1)b0=math.rad(b0)local planet=b[y(aT)][y(aU)]local bN=math.cos(b0)local gD=vec3(bN*math.cos(b1),bN*math.sin(b1),math.sin(b0))return planet.center+(planet.radius+b2)*gD end;local position=gC(cm)return ATLAS.AddNewLocation(gB,position,eg)end;local i;local gE,gF=nil,nil;local gG="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(ab," ")gE=ab;if i~=nil then gE=string.sub(ab,0,i-1)gF=string.sub(ab,i+1)end;if gE=="/help"or gE=="/commands"then for gH in string.gmatch(gG,"([^\n]+)")do system.print(gH)end;return elseif gE=="/setname"then if gF==nil or gF==""then msgText="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.UpdatePosition(gF)else msgText="Select a saved target to rename first"end elseif shield_1 and gE=="/resist"then if gF==nil or shield_1.getResistancesCooldown()>0 then msgText="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aF=A..', '..A..', '..A..', '..A;local gI,gJ,gK,gL=n(gF,aF)if gL==nil or gI+gJ+gK+gL>0.6 then msgText="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(gI,gJ,gK,gL)==1 then msgText="Shield Resistances set"else msgText="Resistance setting failed."end elseif gE=="/addlocation"or string.find(ab,"::pos")~=nil then local eg=false;local gB="0-Temp"if gF==nil or gF==""then gF=gE;eg=true end;i=string.find(gF,"::")if not eg then gB=string.sub(gF,1,i-2)end;local cm=string.sub(gF,i)gA(gB,cm,eg)elseif gE=="/agg"then if gF==nil or gF==""then msgText="Usage: /agg targetheight"return end;gF=y(gF)if gF<1000 then gF=1000 end;AntigravTargetAltitude=gF;msgText="AGG Target Height set to "..gF elseif gE=="/G"then if gF==nil or gF==""then msgText="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if gF=="dump"then for aq,ar in pairs(saveableVariables())do if type(_G[ar])=="boolean"then if _G[ar]==true then system.print(ar.." true")else system.print(ar.." false")end elseif _G[ar]==nil then system.print(ar.." nil")else system.print(ar.." ".._G[ar])end end;return end;i=string.find(gF," ")local gM=string.sub(gF,0,i-1)local gN=string.sub(gF,i+1)for aq,ar in pairs(saveableVariables())do if ar==gM then msgText="Variable "..gM.." changed to "..gN;local gO=type(_G[ar])if gO=="number"then gN=y(gN)if ar=="AtmoSpeedLimit"then adjustedAtmoSpeedLimit=gN end elseif gO=="boolean"then if string.lower(gN)=="true"then gN=true else gN=false end end;_G[ar]=gN;return end end;msgText="No such global variable: "..gM elseif gE=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.ClearCurrentPosition()else msgText="Select a custom wp to delete first in IPH"end elseif gE=="/copydatabank"then if dbHud_2 then am(true)else msgText="Spare Databank required to copy databank"end elseif gE=="/iphWP"then if AutopilotTargetIndex>0 then system.print(AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords,true))msgText="::pos waypoint shown in lua chat"else msgText="No target selected in IPH"end end end;function script.onEnter(aU)if radar_1 and not inAtmo and not notPvPZone then unit.setTimer("contact",0.1)end end;function script.onLeave(aU)if radar_1 and CollisionSystem then if#X>650 then aU=tostring(aU)X[aU]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
