name: ArchHud - Archaegeo v0.805 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaintainOrbit = true --export: (Default: true) If true, ship will attempt to maintain orbit if it decays (when not autopiloting to a landing point) till fuel runs out.
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        ExtraEscapeThrust = 1.0 --export: (Default: 1.0) Set this to 1 to use friction burn speed as your max speed when escaping atmosphere. Setting other than 1 will be a the value multiplied by your friction burn speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.805;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=true;K=false;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},freeLookToggle={set=function(M)i=M end,get=function()return i end},BrakeToggleDefault={set=function(M)j=M end,get=function()return j end},RemoteFreeze={set=function(M)k=M end,get=function()return k end},brightHud={set=function(M)m=M end,get=function()return m end},RemoteHud={set=function(M)l=M end,get=function()return l end},VanillaRockets={set=function(M)n=M end,get=function()return n end},InvertMouse={set=function(M)o=M end,get=function()return o end},autoRollPreference={set=function(M)p=M end,get=function()return p end},ExternalAGG={set=function(M)q=M end,get=function()return q end},UseSatNav={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},FullRadar={set=function(M)J=M end,get=function()return J end},ECUHud={set=function(M)K=M end,get=function()return K end},MaintainOrbit={set=function(M)N=M end,get=function()return N end}}O=35;P=35;Q=30;R=30;S=-30;T=0;U=5000;V=1.2;W=2000;X=1175;Y=66000;Z=1000;_=50;a0=0;a1=100000;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab={YawStallAngle={set=function(M)O=M end,get=function()return O end},PitchStallAngle={set=function(M)P=M end,get=function()return P end},brakeLandingRate={set=function(M)Q=M end,get=function()return Q end},MaxPitch={set=function(M)R=M end,get=function()return R end},ReEntryPitch={set=function(M)S=M end,get=function()return S end},LockPitchTarget={set=function(M)T=M end,get=function()return T end},AutopilotSpaceDistance={set=function(M)U=M end,get=function()return U end},TargetOrbitRadius={set=function(M)V=M end,get=function()return V end},LowOrbitHeight={set=function(M)W=M end,get=function()return W end},AtmoSpeedLimit={set=function(M)X=M end,get=function()return X end},SpaceSpeedLimit={set=function(M)Y=M end,get=function()return Y end},AutoTakeoffAltitude={set=function(M)Z=M end,get=function()return Z end},TargetHoverHeight={set=function(M)_=M end,get=function()return _ end},LandingGearGroundHeight={set=function(M)a0=M end,get=function()return a0 end},ReEntryHeight={set=function(M)a1=M end,get=function()return a1 end},MaxGameVelocity={set=function(M)ac=M end,get=function()return ac end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV="none"aW="none"aX="none"aY={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aZ=M end,get=function()return aZ end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end}}a_=j;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=1000;bc=false;bd=false;be=false;bf=false;bg=0;bh="Aligning"bi=0;bj=1;bk="None"bl=nil;bm=0;bn=nil;bo=0.0;bp=0;bq={}br=false;bs=0;bt=0;bu=nil;bv=0;bw=1000;bx=0;by=false;bz=0;bA=false;bB="All"bC=true;bD="Off"bE=0.000;bF={}bG={}bH={}bI=false;bJ={VertTakeOff={set=function(M)ba=M end,get=function()return ba end},VertTakeOffEngine={set=function(M)b0=M end,get=function()return b0 end},SpaceTarget={set=function(M)by=M end,get=function()return by end},BrakeToggleStatus={set=function(M)a_=M end,get=function()return a_ end},BrakeIsOn={set=function(M)b1=M end,get=function()return b1 end},RetrogradeIsOn={set=function(M)b2=M end,get=function()return b2 end},ProgradeIsOn={set=function(M)b3=M end,get=function()return b3 end},Autopilot={set=function(M)b4=M end,get=function()return b4 end},TurnBurn={set=function(M)b5=M end,get=function()return b5 end},AltitudeHold={set=function(M)b6=M end,get=function()return b6 end},BrakeLanding={set=function(M)b7=M end,get=function()return b7 end},Reentry={set=function(M)b9=M end,get=function()return b9 end},AutoTakeoff={set=function(M)b8=M end,get=function()return b8 end},HoldAltitude={set=function(M)bb=M end,get=function()return bb end},AutopilotAccelerating={set=function(M)bc=M end,get=function()return bc end},AutopilotBraking={set=function(M)be=M end,get=function()return be end},AutopilotCruising={set=function(M)bf=M end,get=function()return bf end},AutopilotRealigned={set=function(M)bd=M end,get=function()return bd end},AutopilotEndSpeed={set=function(M)bg=M end,get=function()return bg end},AutopilotStatus={set=function(M)bh=M end,get=function()return bh end},AutopilotPlanetGravity={set=function(M)bi=M end,get=function()return bi end},PrevViewLock={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetName={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetCoords={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetIndex={set=function(M)bm=M end,get=function()return bm end},TotalDistanceTravelled={set=function(M)bo=M end,get=function()return bo end},TotalFlightTime={set=function(M)bp=M end,get=function()return bp end},SavedLocations={set=function(M)bq=M end,get=function()return bq end},VectorToTarget={set=function(M)br=M end,get=function()return br end},LocationIndex={set=function(M)bs=M end,get=function()return bs end},LastMaxBrake={set=function(M)bt=M end,get=function()return bt end},LockPitch={set=function(M)bu=M end,get=function()return bu end},LastMaxBrakeInAtmo={set=function(M)bv=M end,get=function()return bv end},AntigravTargetAltitude={set=function(M)bw=M end,get=function()return bw end},LastStartTime={set=function(M)bx=M end,get=function()return bx end},iphCondition={set=function(M)bB=M end,get=function()return bB end},stablized={set=function(M)bC=M end,get=function()return bC end},UseExtra={set=function(M)bD=M end,get=function()return bD end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bF=M end,get=function()return bF end},apRoute={set=function(M)bG=M end,get=function()return bG end},ecuThrottle={set=function(M)bH=M end,get=function()return bH end},HoverMode={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=p;cA=false;cB=X;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2=nil;d3=nil;d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()if shield then dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dh(di)a.print(bQ..": "..di)end;local function dj(d,b,c,a,dk,dl,dm,dn,dp)local function dq(dr)return type(dr)=='number'end;local function ds(dr)return type(dm(dr))=='number'end;local function dt(du)return type(du)=='table'end;local function dv(a)return type(a)=='string'end;local function dw(dx)return dt(dx)and dq(dx.x and dx.y and dx.z)end;local function dy(dz)return dt(dz)and dq(dz.latitude and dz.longitude and dz.altitude and dz.id and dz.systemId)end;local dA=math.pi/180;local dB=180/math.pi;local dC=1e-10;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local utils=utils;local vec3=vec3;local function dF(dr)local dG=string.gsub(string.reverse(dk('%.4f',dr)),'^0*%.?','')return dG==''and'0'or string.reverse(dG)end;local function dH(dI)if dw(dI)then return dk('{x=%.3f,y=%.3f,z=%.3f}',dI.x,dI.y,dI.z)end;if dt(dI)and not getmetatable(dI)then local dJ={}local dK=next(dI)if type(dK)=='nil'or dK==1 then dJ=dI else for dL,dx in pairs(dI)do local dM=dH(dx)if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end end;return dk('{%s}',table.concat(dJ,','))end;if dv(dI)then return dk("'%s'",dI:gsub("'",[[\']]))end;return tostring(dI)end;local dN={}dN.__index=dN;dN.__tostring=function(dI,dO)local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)local dJ={}for dQ,dL in ipairs(dP)do local dM=dH(dI[dL])if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end;if dO then return dk('%s%s',dO,table.concat(dJ,',\n'..dO))end;return dk('{%s}',table.concat(dJ,','))end;dN.__eq=function(dR,dS)return dR.systemId==dS.systemId and dR.id==dS.id and dp(dR.radius,dS.radius)and dp(dR.center.x,dS.center.x)and dp(dR.center.y,dS.center.y)and dp(dR.center.z,dS.center.z)and dp(dR.GM,dS.GM)end;local function dT(dU,dV,dW,dX,dY)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(dW),'Argument 3 (radius) must be a number:'..type(dW))assert(dt(dX),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dX))assert(ds(dY),'Argument 5 (GM) must be a number:'..type(dY))return setmetatable({systemId=dm(dU),id=dm(dV),radius=dm(dW),center=vec3(dX),GM=dm(dY)},dN)end;local dZ={}dZ.__index=dZ;dZ.__tostring=function(dh)return dk('::pos{%d,%d,%s,%s,%s}',dh.systemId,dh.id,dF(dh.latitude*dB),dF(dh.longitude*dB),dF(dh.altitude))end;dZ.__eq=function(dR,dS)return dR.id==dS.id and dR.systemId==dS.systemId and dp(dR.latitude,dS.latitude)and dp(dR.altitude,dS.altitude)and(dp(dR.longitude,dS.longitude)or dp(dR.latitude,math.pi/2)or dp(dR.latitude,-math.pi/2))end;local function d_(e0,dV,e1,e2,e3)local dU=e0;if dv(e0)and not e2 and not e3 and not dV and not e1 then dU,dV,e1,e2,e3=e4(e0,dE)assert(dU,'Argument 1 (position string) is malformed.')else assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(e1),'Argument 3 (latitude) must be in degrees:'..type(e1))assert(ds(e2),'Argument 4 (longitude) must be in degrees:'..type(e2))assert(ds(e3),'Argument 5 (altitude) must be in meters:'..type(e3))end;dU=dm(dU)dV=dm(dV)e1=dm(e1)e2=dm(e2)e3=dm(e3)if dV==0 then return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=dV,systemId=dU},dZ)end;return setmetatable({latitude=dA*dl(e1,-90,90),longitude=dA*(e2%360),altitude=e3,id=dV,systemId=dU},dZ)end;local e5={}e5.__index=e5;e5.__tostring=function(dI,dO)local e6=dO and dO..'  'local e7={}local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)for dQ,e8 in ipairs(dP)do e9=dI[e8]local ea=dN.__tostring(e9,e6)if dO then table.insert(e7,dk('[%s]={\n%s\n%s}',e8,ea,dO))else table.insert(e7,dk('  [%s]=%s',e8,ea))end end;if dO then return dk('\n%s%s%s',dO,table.concat(e7,',\n'..dO),dO)end;return dk('{\n%s\n}',table.concat(e7,',\n'))end;local function eb(ec)local e={}local pid;for dQ,dx in pairs(ec)do local dV=dx.planetarySystemId;if type(dV)~='number'then error('Invalid planetary s ID: '..tostring(dV))elseif pid and dV~=pid then error('Mistringmatch planetary s IDs: '..dV..' and '..pid)end;local ed=dx.bodyId;if type(ed)~='number'then error('Invalid body ID: '..tostring(ed))elseif e[ed]then error('Duplicate body ID: '..tostring(ed))end;setmetatable(dx.center,getmetatable(vec3.unit_x))e[ed]=setmetatable(dx,dN)pid=dV end;return setmetatable(e,e5)end;ee={}local function ef(ec)return setmetatable({galaxyAtlas=ec or{}},ee)end;ee.__index=function(du,M)if type(M)=='number'then local a=du.galaxyAtlas[M]return eb(a)end;return rawget(ee,M)end;ee.__pairs=function(dI)return function(du,dL)local eg,eh=next(du,dL)return eg,eh and eb(eh)end,dI.galaxyAtlas,nil end;ee.__tostring=function(dI)local ei={}for dQ,ej in pairs(dI or{})do local ek=ej:getPlanetarySystemId()local el=e5.__tostring(ej,'    ')table.insert(ei,dk('  [%s]={%s\n  }',ek,el))end;return dk('{\n%s\n}\n',table.concat(ei,',\n'))end;ee.BodyParameters=dT;ee.MapPosition=d_;ee.PlanetarySystem=eb;function ee.createBodyParameters(dU,dV,em,en,eo,ep,eq)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(em),'Argument 3 (surfaceArea) must be a number:'..type(em))assert(dt(en),'Argument 4 (aPosition) must be an array or vec3:'..type(en))assert(dt(eo),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eo))assert(ds(ep),'Argument 6 (altitude) must be in meters:'..type(ep))assert(ds(eq),'Argument 7 (gravityAtPosition) must be number:'..type(eq))local dW=dn(em/4/math.pi)local cb=dW+ep;local er=vec3(en)+cb*vec3(eo)local dY=eq*cb*cb;return dT(dU,dV,dW,er,dY)end;ee.isMapPosition=dy;function ee:getPlanetarySystem(e0)if M==nil then M=0 end;if eh==nil then eh=0 end;local dU=e0;if dy(e0)then dU=e0.systemId end;if type(dU)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eh)~=e5 then a=eb(a)end;return a end end end;function e5:sizeCalculator(es)return 1.05*es.radius end;function e5:castIntersections(et,eu,ev,ew,ex,ey)local ez={}if ex then for dQ,es in pairs(ex)do table.insert(ez,es)end else ez=d4 end;if not ey then table.sort(ez,function(eA,eB)local eC=eA.center;local eD=eB.center;return(eC.x-et.x)^2+(eC.y-et.y)^2+(eC.z-et.z)^2<(eD.x-et.x)^2+(eD.y-et.y)^2+(eD.z-et.z)^2 end)end;local eE=eu:normalize()for dQ,es in ipairs(ez)do local eF=es.center-et;local dW;if ev then dW=ev(es)else dW=self:sizeCalculator(es)end;local eG=eF:dot(eE)local eH=eG^2-(eF:len2()-dW^2)if eH>=0 then local eI=dn(eH)local eJ=eG+eI;local eK=eG-eI;if eK>0 then return es,eJ,eK elseif eJ>0 then return es,eJ,nil end end end;return nil,nil,nil end;function e5:closestBody(eL)assert(type(eL)=='table','Invalid coordinates.')local eM,es;local eN=vec3(eL)for dQ,eO in pairs(self)do local eP=(eO.center-eN):len2()if(not es or eP<eM)and eO.name~="Space"then es=eO;eM=eP end end;return es end;function e5:convertToBodyIdAndWorldCoordinates(e0)local eQ=e0;if dv(e0)then eQ=d_(e0)end;if eQ.id==0 then return 0,vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;local eO=self:getBodyParameters(eQ)if eO then return eQ.id,eO:convertToWorldCoordinates(eQ)end end;function e5:getBodyParameters(e0)local dV=e0;if dy(e0)then dV=e0.id end;assert(ds(dV),'Argument 1 (id) must be a number:'..type(dV))return self[dV]end;function e5:getPlanetarySystemId()local dQ,dx=next(self)return dx and dx.systemId end;function dN:convertToMapPosition(dX)assert(dt(dX),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dX))local eR=vec3(dX)if self.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=self.systemId},dZ)end;local eS=eR-self.center;local cb=eS:len()local e3=cb-self.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=self.id,systemId=self.systemId},dZ)end;function dN:convertToWorldCoordinates(e0)local eQ=dv(e0)and d_(e0)or e0;if eQ.id==0 then return vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;assert(dy(eQ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eQ.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eQ.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eV=math.cos(eQ.latitude)return self.center+(self.radius+eQ.altitude)*vec3(eV*math.cos(eQ.longitude),eV*math.sin(eQ.longitude),math.sin(eQ.latitude))end;function dN:getAltitude(dX)return(vec3(dX)-self.center):len()-self.radius end;function dN:getDistance(dX)return(vec3(dX)-self.center):len()end;function dN:getGravity(dX)local eW=self.center-vec3(dX)local eX=eW:len2()return self.GM/eX*eW/dn(eX)end;return setmetatable(ee,{__call=function(dQ,...)return ef(...)end})end;local function eY(d,b,c,a,dn,eZ)local cp={}local bP=100000000/3600;local e_=bP*bP;local f0=100;function cp.computeAccelerationTime(f1,f2,f3)local f4=bP*math.asin(f1/bP)return(bP*math.asin(f3/bP)-f4)/f2 end;function cp.computeDistanceAndTime(f1,f3,f5,f6,f7,f8)f7=f7 or 0;f8=f8 or 0;local f9=f1<=f3;local fa=f6*(f9 and 1 or-1)/f5;local fb=-f8/f5;local fc=fa+fb;if f9 and fc<=0 or not f9 and fc>=0 then return-1,-1 end;local fd,fe=0,0;if fa~=0 and f7>0 then local f4=math.asin(f1/bP)local ff=math.pi*(fa/2+fb)local fg=fa*f7;local fh=bP*math.pi;local dx=function(du)local fi=(ff*du-fg*math.sin(math.pi*du/2/f7)+fh*f4)/fh;local fj=math.tan(fi)return bP*fj/dn(fj*fj+1)end;local fk=f9 and function(a)return a>=f3 end or function(a)return a<=f3 end;fe=2*f7;if fk(dx(fe))then local fl=0;while eZ(fe-fl)>0.5 do local du=(fe+fl)/2;if fk(dx(du))then fe=du else fl=du end end end;local fm=f1;local fn=fe/f0;for fo=1,f0 do local fp=dx(fo*fn)fd=fd+(fp+fm)*fn/2;fm=fp end;if fe<2*f7 then return fd,fe end;f1=fm end;local f4=bP*math.asin(f1/bP)local bQ=(bP*math.asin(f3/bP)-f4)/fc;local fq=e_*math.cos(f4/bP)/fc;local cb=fq-e_*math.cos((fc*bQ+f4)/bP)/fc;return cb+fd,bQ+fe end;function cp.computeTravelTime(f1,f2,cb)if cb==0 then return 0 end;if f2>0 then local f4=bP*math.asin(f1/bP)local fq=e_*math.cos(f4/bP)/f2;return(bP*math.acos(f2*(fq-cb)/e_)-f4)/f2 end;if f1==0 then return-1 end;assert(f1>0,'Acceleration and initial speed are both zero.')return cb/f1 end;return cp end;local function fr(d,b,c,a,dk,dl,dm,dn,dp)local vec3=vec3;local dj=dj(d,b,c,a,dk,dl,dm,dn,dp)local function dv(a)return type(a)=='string'end;local function dt(du)return type(du)=='table'end;fs={}fs.__index=fs;function fs:escapeAndOrbitalSpeed(e3)assert(self.body)local cb=e3+self.body.radius;if not dp(cb,0)then local ft=dn(self.body.GM/cb)return dn(2)*ft,ft end;return nil,nil end;function fs:orbitalParameters(e0,fu)assert(self.body)assert(dt(e0)or dv(e0))assert(dt(fu))local fv=(dv(e0)or dj.isMapPosition(e0))and self.body:convertToWorldCoordinates(e0)or vec3(e0)local dx=vec3(fu)local fw=fv-self.body.center;local fx=dx:len2()local fy=fw:len()local fz=self.body.GM;local fA=((fx-fz/fy)*fw-fw:dot(dx)*dx)/fz;local eC=fz/(2*fz/fy-fx)local fB=fA:len()local eE=fA:normalize()local fC=eC*(1-fB)local fD=eC*(1+fB)local fE=fC*eE+self.body.center;local fF=fB<=1 and-fD*eE+self.body.center or nil;local fG=dn(eC*fz*(1-fB*fB))local fH=fF and 2*math.pi*dn(eC^3/fz)local fI=math.acos(fA:dot(fw)/(fB*fy))if fw:dot(dx)<0 then fI=-(fI-2*math.pi)end;local fJ=math.acos((math.cos(fI)+fB)/(1+fB*math.cos(fI)))local fK=fJ;if fK<0 then fK=fK+2*math.pi end;local fL=fK-fB*math.sin(fK)local fM=0;local fN=0;local fO=0;if fH~=nil then fM=fL/(2*math.pi/fH)fN=fH-fM;fO=fN+fH/2;if fI-math.pi>0 then fN=fM;fO=fN+fH/2 end;if fO>fH then fO=fO-fH end end;return{periapsis={position=fE,speed=fG/fC,circularOrbitSpeed=dn(fz/fC),altitude=fC-self.body.radius},apoapsis=fF and{position=fF,speed=fG/fD,circularOrbitSpeed=dn(fz/fD),altitude=fD-self.body.radius},currentVelocity=dx,currentPosition=fv,eccentricity=fB,period=fH,eccentricAnomaly=fJ,meanAnomaly=fL,timeToPeriapsis=fN,timeToApoapsis=fO,trueAnomaly=fI}end;local function fP(fQ)local eO=dj.BodyParameters(fQ.systemId,fQ.id,fQ.radius,fQ.center,fQ.GM)return setmetatable({body=eO},fs)end;return setmetatable(fs,{__call=function(dQ,...)return fP(...)end})end;local function fR(d,b,c,a,dbHud_1,e,fS,fT,bN,dm,dn,fU,fV)local function fW(fX)local dh=fY:closestBody(fX)if(fX-dh.center):len()>dh.radius+dh.noAtmosphericDensityAltitude then dh=e[0][0]end;return dh end;local function fZ()local function f_(g0,g1)return g0.name<g1.name end;cU={}for dL,dx in pairs(e[0])do cU[#cU+1]={name=dx.name,index=dL}end;table.sort(cU,f_)end;local function g2(g3,g4)if not g4 then g4=g5.name end;for dL,dx in pairs(g3)do if dx.name and dx.name==g4 then return dL end end;return-1 end;local function g6()d1=bm;if bm==0 then bk="None"c8=nil;g5=nil;return true end;local g7=cU[bm].index;local g8=e[0][g7]if g8.center then bk=g8.name;c8=co[0][g7]if g5~=nil then if ch==0 then if fS(g9,ga)~=1 then fT(g9,ga)end;if fS(gb,gc)~=1 then fT(gb,gc)end;if fS(gd,ge)~=1 then fT(gd,ge)end;if fS(gf,gg)~=1 then fT(gf,gg)end;if fS(gh,gi)~=1 then fT(gh,gi)end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end;if fS(gn,go)~=1 then fT(gn,go)end end;g5=nil else g5=g8;for dQ,dx in pairs(co[0])do if dx.name==g5.planetname then c8=dx;bk=g5.name;break end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end end;if g5==nil then bl=vec3(c8.center)else bl=g5.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gp=bN(c8.radius*(V-1)+c8.noAtmosphericDensityAltitude)else gp=bN(c8.radius*(V-1)+c8.surfaceMaxAltitude)end else gp=U end;if g5~=nil and g5.planetname=="Space"then bg=0 else dQ,bg=cq(c8):escapeAndOrbitalSpeed(gp)end;bi=0;bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"return true end;local function gq(gr)if not b4 and not br and not cd and not bA and not b9 and not ce then if gr==nil then bm=bm+1;if bm>#cU then bm=0 end else bm=bm-1;if bm<0 then bm=#cU end end;if bm==0 then g6()else local g7=cU[bm].index;local g8=e[0][g7]if g8 and(g8~=nil and g8.name=="Space"or bB=="Custom Only"and g8.center or bB=="No Moons-Asteroids"and(string.find(g8.name,"Moon")~=nil or string.find(g8.name,"Asteroid")~=nil))then if gr==nil then gq()else gq(1)end else g6()end end else c3="Disengage autopilot before changing Interplanetary Helper"fU("iph","AP")end end;local function gs()local function gt(gu)local gv;if gu then gv=d9 else gv=bq end;local gw=-1;gw=g2(e[0])if gw>-1 then table.remove(e[0],gw)end;gw=-1;gw=g2(gv)if gw~=-1 then c3=g5.name.." saved location cleared"table.remove(gv,gw)end;gq()fZ()return gv end;if string.sub(bk,1,1)=="*"then d9=gt(true)else bq=gt(false)end end;local function gx(gy,fX,gz,gA)local function gB(gu)if gu then gv=d9 else gv=bq end;if dbHud_1 or gz or gu then local dh=fW(fX)local gC={position=fX,name=gy,planetname=dh.name,gravity=b.getGravityIntensity(),safe=gA}if not gz then gv[#gv+1]=gC else for dL,dx in pairs(e[0])do if dx.name and gy==dx.name then table.remove(e[0],dL)end end end;table.insert(e[0],gC)fZ()g6()c3="Location saved as "..gy.."("..dh.name..")"return gv else c3="Databank must be installed to save permanent locations"end end;if string.sub(gy,1,1)=="*"then d9=gB(true)else bq=gB(false)end end;local gD={}function gD.UpdateAtlasLocationsList()fZ()end;function gD.UpdateAutopilotTarget()g6()end;function gD.adjustAutopilotTargetIndex(gr)gq(gr)end;function gD.findAtlasIndex(g3,g4)return g2(g3,g4)end;function gD.UpdatePosition(gE,gF,gG)local function gH(gu)local gv;if gu then gv=d9 else gv=bq end;local gw=g2(gv)if gw~=-1 then if gE~=nil then if gu then gE="*"..gE end;gv[gw].name=gE;bm=bm-1;gq()elseif gG~=nil then if gG then local gI=ci;if gI<1000 then gI=1000 end;gv[gw].agg=fV(gI,0)c3=gv[gw].name.." AGG Altitude:"..gv[gw].agg.." saved ("..gv[gw].planetname..")"return elseif gG==false then gv[gw].agg=nil;c3=gv[gw].name.." AGG Altitude cleared ("..gv[gw].planetname..")"return end else local gJ=gv[gw]if gF then gJ.heading=cI:cross(cM)*5000;c3=gv[gw].name.." heading saved ("..gv[gw].planetname..")"return elseif gF==false then gJ.heading=nil;c3=gv[gw].name.." heading cleared ("..gv[gw].planetname..")"return end;gJ.gravity=b.getGravityIntensity()gJ.position=cO;gJ.safe=true end;c3=gv[gw].name.." position updated ("..gv[gw].planetname..")"else c3="Name Not Found"end end;if string.sub(bk,1,1)=="*"then gH(true)else gH(false)end end;function gD.AddNewLocation(gy,fX,gz,gA)gx(gy,fX,gz,gA)end;function gD.ClearCurrentPosition()gs()end;for dL,dx in pairs(da)do table.insert(e[0],dx)end;if gK then for dL,dx in pairs(gK)do gD[dL]=dx end end;fZ()if bm>#cU then bm=0 end;gD.UpdateAutopilotTarget()return gD end;local function gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU)local gP={}local gQ={}local gR={XS=13,S=27,M=55,L=110,XL=221}local gS={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gT={}local gU=0;local gV;local gW;local gX;local gY;local gZ={gY}local g_="Atmo"local h0;local h1;local h2=0;local h3={}local h4;local h5=0;local h6=table.insert;local h7=-4;local h8={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h9,ha;local hb,hc;local hd;local he;local hf;local hg;local hh;local hi;local hj;local function hk()if hl~=nil and h2==0 then gM(hl)a.destroyWidget(h9)a.destroyData(hb)h9,hb,hl=nil,nil,nil;if h1~=nil then gM(h1)a.destroyWidget(ha)a.destroyData(hc)h1,ha,hc=nil,nil,nil end elseif J then if h2==1 then gM(hl)hl=nil;h1=a.createWidgetPanel("PeriWinkle")ha=a.createWidget(h1,'periscope')hc=gY.getWidgetDataId()a.addDataToWidget(hc,ha)end;if hl==nil and gU>0 then hl=a.createWidgetPanel(g_)h9=a.createWidget(hl,'radar')hb=gY.getWidgetDataId()a.addDataToWidget(hb,h9)end;h2=0 end end;local function hm()local function hn(ho,hp,hq,hr,hs,ht,hu,hv)hp,hr,ht,hv=vec3(hp),vec3(hr),vec3(ht),vec3(hv)local hw,hx,hy=ho*ho,hq*hq,hs*hs;local fx=hr-hp;local hz=fx:normalize()local hA=fx:len()local hB=ht-hp;local hC=(hB-hB:project_on(hz)):normalize()local hD,hE=hB:dot(hz),hB:dot(hC)local hF=hD*hD+hE*hE;local hG=hz:cross(hC)local hH=(hw-hx+hA*hA)/(2*hA)local hI=(hw-hy+hF-2*hD*hH)/(2*hE)local dz=hw-hH^2-hI^2;local hJ=dn(dz)local hK=hp+hz*hH+hC*hI+hG*hJ;local hL=hp+hz*hH+hC*hI-hG*hJ;if eZ((hv-hK):len()-hu)<eZ((hv-hL):len()-hu)then return hK else return hL end end;local function hM(hN,fy,hO)local hP=hN.pts;local gw=#hP;local hQ=hN.ref;if gw>3 then local hR,hS,hT,hU=hP[gw],hP[gw-1],hP[gw-2],hP[gw-3]hN.ref=hO;local fv=hn(hR[1],hR[2],hS[1],hS[2],hT[1],hT[2],hU[1],hU[2])local hH,hI,hJ=fv.x,fv.y,fv.z;if hH==hH and hI==hI and hJ==hJ then hH=hH+hQ[1]hI=hI+hQ[2]hJ=hJ+hQ[3]local hV=vec3(hH,hI,hJ)hN.center=hV;if hN.lastPos then if(hN.lastPos-hV):len()<2 then local hW=(hV-vec3(hO)):len()if eZ(hW-fy)<10 then hN.skipCalc=true end end end;hN.lastPos=hV end;hN.pts={}else local hX={hO[1]-hQ[1],hO[2]-hQ[2],hO[3]-hQ[3]}hP[gw+1]={fy,hX}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gY then if#h4>0 then local hY,hZ=0,0;local h_=cL*10;local cY=cY;gX,gW=0,0;gQ={}for dQ,dx in pairs(h4)do local cb=hh(dx)if cb>0.0 then if hd(dx)==1 then h6(gQ,dx)end;if not cV and warpdrive and cb<aa and warpdrive.getStatus()==15 then c3="INITIATING WARP"c4=7;warpdrive.initiate()end;local i0=F and hf(dx)==1;if E or i0 then local i1=hi(dx)local i2=gR[i1]local i3=he(dx)if i0 or cb<h_ and(i2>27 or i3==4 or i3==6)then gX=gX+1;local hO={cO["x"],cO["y"],cO["z"]}local hN=h3[dx]if hN==nil then i2=i2+gO;h3[dx]={pts={},ref=hO,name=hg(dx),i=0,radius=i2,skipCalc=false}hN=h3[dx]end;if not hN.skipCalc then if i0 or i3==4 or i3==6 then hN.center=vec3(hj(dx))hN.skipCalc=true else hM(hN,cb,hO)hZ=hZ+1 end;if i0 and not hN.abandoned then local bQ=a.getArkTime()if h5+5<bQ then h5=bQ;fU("abRdr","RD")end;a.print("Abandoned Construct: "..hN.name.." ("..i1 .." "..gS[i3]..") at ::pos{0,0,"..hN.center.x..","..hN.center.y..","..hN.center.z.."}")c3="Abandoned Radar Contact ("..i1 .." "..gS[i3]..") detected"hN.abandoned=true end else h6(gT,hN)end end;hY=hY+1;if hY>300 or hZ>30 then coroutine.yield()hY,hZ=0,0 end end end end;gW=#gT;if gW>0 and(cL>20 or b7)then local es,i4,i5,i6;local i7=0;local i8=co:getPlanetarySystem(0)i6=cK:normalize()while i7<gW do coroutine.yield()local i9={table.unpack(gT,i7,math.min(i7+75,gW))}es,i4,i5=i8:castIntersections(cO,i6,nil,nil,i9,true)if es and i5 then c_={es,i4,i5}break end;i7=i7+75 end;if not es then c_=nil end else c_=nil end;gT={}gV=gY.getTargetId()end end end;local function ia()if gY then g_="Atmo"if gY.getRange()>10000 then g_="Space"end end end;function gP.pickType()ia()end;function gP.assignRadar()if radar_2 and h7~=1 then if h7==-1 then if gY==radar_2 then gY=radar_1 else gY=radar_2 end end;gZ={gY}hd=gY.hasMatchingTransponder;he=gY.getConstructKind;hf=gY.isConstructAbandoned;hg=gY.getConstructName;hh=gY.getConstructDistance;hi=gY.getConstructCoreSize;hj=gY.getConstructWorldPos;h4=gY.getConstructIds()ia()else h4=gY.getConstructIds()end;h7=gY.getOperationalState()end;function gP.UpdateRadar()local ib=coroutine.status(h0)if ib=="suspended"then local dM,ic=coroutine.resume(h0)if ic then a.print("ERROR UPDATE RADAR: "..ic)end elseif ib=="dead"then h0=coroutine.create(hm)local dM,ic=coroutine.resume(h0)end end;function gP.GetRadarHud(id,ie,ay,az)local ig,di;local dD=gW or 0;gU=#h4;if gU>0 then if E then di=dD.."/"..gX.." Known/InRange : "..gU.." Total"else di="Radar Contacts: "..gU end;ig=gN(ay,az,di,"pbright txtbig txtmid")if#gQ>0 then ig=ig..gN(id,ie,"Friendlies In Range","pbright txtbig txtmid")for dL,dx in pairs(gQ)do ie=ie+20;ig=ig..gN(id,ie,gY.getConstructName(dx),"pdim txtmid")end end;if gV==nil and h1==nil then h2=1;cu.ToggleRadarPanel()end;if gV~=nil and h1~=nil then cu.ToggleRadarPanel()end;if hl==nil then if w then cu.ToggleRadarPanel()end end else if h7~=1 then ig=gN(ay,az,g_.." Radar: "..h8[h7],"pbright txtbig txtmid")else ig=gN(ay,az,"Radar: No "..g_.." Contacts","pbright txtbig txtmid")end;if hl~=nil then h2=0;cu.ToggleRadarPanel()end end;return ig end;function gP.GetClosestName(gy)if gY then local ih=gY.getConstructName(gY.getConstructIds()[1])if ih then gy=gy.." "..ih end end;return gy end;function gP.ToggleRadarPanel()hk()end;function gP.ContactTick()if not ii then ii=0 end;if bQ>ii+10 then c3="Radar Contact"fU("rdrCon","RC")ii=bQ end;c.stopTimer("contact")end;function gP.onEnter(dV)if gY and not cg and not cV then c.setTimer("contact",0.1)end end;function gP.onLeave(dV)if gY and E then if#h3>650 then dV=tostring(dV)h3[dV]=nil end end end;local function ij()gY=nil;if radar_2 and radar_2.getOperationalState()==1 then gY=radar_2 else gY=radar_1 end;h7=gY.getOperationalState()hd=gY.hasMatchingTransponder;he=gY.getConstructKind;hf=gY.isConstructAbandoned;hg=gY.getConstructName;hh=gY.getConstructDistance;hi=gY.getConstructCoreSize;hj=gY.getConstructWorldPos;gZ={gY}h4=gY.getConstructIds()ia()h0=coroutine.create(hm)if ik then for dL,dx in pairs(ik)do gP[dL]=dx end end end;ij()return gP end;local function il(shield,e4,bN)local im={}local io=shield.getResistancesCooldown()local function ip()local iq=shield.isActive()if G then if not cV and iq==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and iq==1 then shield.toggle()end end end;local function ir()local is=shield.getStressRatioRaw()local it=0.5999;if is[1]==0.0 and is[2]==0.0 and is[3]==0.0 and is[4]==0.0 then return end;local iu=shield.setResistances(it*is[1],it*is[2],it*is[3],it*is[4])if iu==1 then c3="Shield Resistances updated"else c3="Value Exceeded. Failed to update Shield Resistances"end end;function im.shieldTick()dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ip()io=shield.getResistancesCooldown()if io==0 and dg<a9 then ir()end end;function im.setResist(iv)if not shield then c3="No shield found"return elseif iv==nil or io>0 then c3="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE=dD..', '..dD..', '..dD..', '..dD;local iw,ix,iy,iz=e4(iv,dE)if iz==nil or iw+ix+iy+iz>0.6 then c3="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(iw,ix,iy,iz)==1 then c3="Shield Resistances set"else c3="Resistance setting failed."end end;function im.ventShield()local iA=shield.getVentingCooldown()if iA>0 then c3="Cannot vent again for "..iA.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c3="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c3="Shields already at max hitpoints"end end;if iB then for dL,dx in pairs(iB)do im[dL]=dx end end;return im end;local function iC(d,b,c,a,e,antigrav,hover,shield,warpdrive,iD,eZ,bN,dk,iE,bO,iF,iG,eU,bM,dl,iH,fT,fS,gM,iI,dn,fV,gN,fU,iJ,iK,iL,iM,iN,iO)local bP=DUConstruct;local iP=9.80665;local iQ={}local iR={}local iS={}local iT={}local iU=nil;local iV=nil;local iW=nil;local iX=false;local iY="none"local iZ=""local i_=55;local j0=0;local j1=0;local j2=nil;local j3=ag;local j4=ah;local j5=ai;local j6=[[rgb(]]..bN(j3+0.5)..","..bN(j4+0.5)..","..bN(j5+0.5)..[[)]]local j7=[[rgb(]]..bN(j3*0.9+0.5)..","..bN(j4*0.9+0.5)..","..bN(j5*0.9+0.5)..[[)]]local j8=0;local j9=0;local ja=""local jb=bM()local jc=false;local jd=false;local function je(dx)if ad==1920 then return dx else return fV(ad*dx/1920,0)end end;local function jf(dx)if ae==1080 then return dx else return fV(ae*dx/1080,0)end end;local function jg()return iI()==0 and g~="keyboard"and iG()==0 end;local function jh()local ji="TRAVEL"if not cR then ji="CRUISE"end;if b4 then ji="AUTOPILOT"end;return ji end;local ig=""local jj=""local jk=""local jl=1;local jm=2;local jn=3;local jo=4;local jp=5;local jq=6;local jr=7;local js=""local jt=0;local ju=120.0*aU;local jv={}local jw={}local jx={}local jy={}local jz={}local jA={}local jB={}jB["atmofueltank"],jB["spacefueltank"],jB["rocketfueltank"]=0,0,0;local jC=0;local function jD(hH,jE,jF,jG,jH,jI)local jJ=jC;local jK=jC+5;if not B then jK=jK+5 end;if iG()==1 and not l then jJ=jJ-50;jK=jK-50 end;if jF=="ATMO"then js="atmofueltank"elseif jF=="SPACE"then js="spacefueltank"else js="rocketfueltank"end;jt=_G[js.."_size"]if#jG>0 then for M=1,#jG do local gy=jG[M][jm]local jL=jG[M][jr]for jM=1,jt do if jG[M][jm]==iE(c[js.."_"..jM].getWidgetData()).name then jL=jM;break end end;local jN=bM()if jH[M]==nil or jI[M]==nil or jN-jG[M][jq]>ju then local jO;local jP=0;jP=iF(jG[M][jl])-jG[M][jo]jO=jG[M][jp]if jO>jP then jB[js]=jB[js]+jO-jP end;if jL~=0 then local jQ=iE(c[js.."_"..jL].getWidgetData())jI[M]=jQ.percentage;jH[M]=jQ.timeLeft;if jH[M]=="n/a"then jH[M]=0 end else jI[M]=bN(0.5+jP*100/jG[M][jn])if jO<=jP then jH[M]=0 else jH[M]=bN(0.5+jP/((jO-jP)/(jN-jG[M][jq])))end end;jG[M][jq]=jN;jG[M][jp]=jP end;if gy==jE then gy=dk("%s %d",jF,M)end;if jL==0 then gy=gy.." *"end;local jR;if jH[M]==0 then jR=""else jR=iM(jH[M])end;if jI[M]~=nil then local jS=bN(jI[M]*2.55)local jT=dk("rgb(%d,%d,%d)",255-jS,jS,0)local jU=""if jR~=""and jH[M]<120 or jI[M]<5 then jU="red "end;local jV=dk("rgb(%d,%d,%d)",dl(bN((255-jS)/2.55),50,100),dl(bN(jS/2.55),0,50),50)local jW="rgb(196,0,255)"if jF=="ATMO"then jW="rgb(0,188,255)"elseif jF=="SPACE"then jW="rgb(239,255,0)"end;local jX=false;if jY~=jW then jX=true end;jY=jW;if B then if jX then jJ=jJ-5;jK=jK-5 end;jj=jj..dk([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jV,jW,hH,jK,jT,bN(jI[M]*1.7+0.5)-2,hH+1,jK+1,hH+5,jK+14,gy,jI[M],jR)jJ=jJ-22;jK=jK-22 else jj=jj..gN(hH,jJ,gy,jU.."pdim txtfuel")jj=jj..gN(hH,jK,dk("%d%% %s",jI[M],jR),"pdim txtfuel","fill:"..jT)jJ=jJ+30;jK=jK+30 end end end end;jC=jJ end;local function jZ(j_,e3)if aq==0 and ar==0 then return end;if e3<200000 and not cg or e3 and cg then local k0=0;if eZ(cN)>1 then k0=45*math.log(eZ(cN),10)if cN<0 then k0=-k0 end end;j_[#j_+1]=dk([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bN(cN),bN(k0))end;return j_ end;local function k1(k2)local gr=-cM;k2=k2-k2:project_on(gr)local k3=vec3(0,0,1)k3=k3-k3:project_on(gr)local k4=k3:cross(gr)local k0=k3:angle_between(k2)*constants.rad2deg;if k2:dot(k4)<0 then k0=360-k0 end;return k0 end;local function k5(j_,am,an,k6,k7,cY)if af==0 then return end;local k8=af;local k9=20;local ka=bN(k6)if cY then for M=-45,45,5 do local kb=M;j_[#j_+1]=dk([[<g transform="rotate(%f,%d,%d)">]],kb,am,an)kc=5;if M%15==0 then kc=15 elseif M%10==0 then kc=10 end;j_[#j_+1]=dk([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+k8+k9-kc,am,an+k8+k9)end;j_[#j_+1]=gN(am,an+k8+k9-35,k7,"pdim txt txtmid")j_[#j_+1]=gN(am,an+k8+k9-25,ka.." deg","pdim txt txtmid")j_[#j_+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k6,am,an)j_[#j_+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+k8+k9-20,am+5,an+k8+k9-20,am,an+k8+k9-15)j_[#j_+1]="</g>"end;j_[#j_+1]=[[<g style="clip-path: url(#headingClip);">]]local kd=ka;if cY then kd=k1(cH)end;local ke=20;local kf=bN(kd)local kg=0;local kh=an+k8+k9+20;local ki=am;if k7~="YAW"then kh=jf(130)ki=je(960)end;local kj=[[<path class="txttick line" d="]]local kk=bN(kf-(ke+10)-kf%5+0.5)for M=kk+70,kk,-5 do local hH=ki-(-M*5+kd*5)if M%10==0 then kg=10;local dD=M;if dD==360 then dD=0 elseif dD>360 then dD=dD-360 elseif dD<0 then dD=dD+360 end;j_[#j_+1]=gN(hH,kh+15,dD,"txtmid bright")elseif M%5==0 then kg=5 end;if kg==10 then kj=dk([[%s M %f %f v %d]],kj,hH,kh-5,kg)else kj=dk([[%s M %f %f v %d]],kj,hH,kh-2.5,kg)end end;j_[#j_+1]=kj..[["/>]]j_[#j_+1]=dk([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],ki-5,kh-20,ki+5,kh-20,ki,kh-10)if cY then k7="HDG"end;j_[#j_+1]=gN(je(960),jf(100),kf.."Â°","dim txt txtmid size14","")j_[#j_+1]=gN(je(960),jf(85),k7,"dim txt txtmid size20","")j_[#j_+1]=[[</g>]]end;local function kl(j_,km,k6,am,an,cY,kn,fp)if af==0 then return end;local k8=af;local ko=bN(k8*3/5)if k8>0 then local kp=bN(km)local kc=0;local kj=dk([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k6,am,an)if not cg then kj=dk([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;j_[#j_+1]=dk([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k8-1,am,an)j_[#j_+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(kp-30-kp%5+0.5),bN(kp+30+kp%5+0.5),5 do if M%10==0 then kc=30 elseif M%5==0 then kc=20 end;local hI=an+-M*5+km*5;if kc==30 then kj=dk([[%s M %d %f h %d]],kj,am-ko-kc,hI,kc)if cg then j_[#j_+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k6,am,an,am-ko+10,hI+4,M)j_[#j_+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k6,am,an,am+ko-10,hI+4,M)if M==0 or M==180 or M==-180 then j_[#j_+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k6,am,an,am-ko+20,hI,ko*2-40)end else j_[#j_+1]=gN(am-ko+10,hI,M,"pdim txt txtmid")j_[#j_+1]=gN(am+ko-10,hI,M,"pdim txt txtmid")end;kj=dk([[%s M %d %f h %d]],kj,am+ko,hI,kc)else kj=dk([[%s M %d %f h %d]],kj,am-ko-kc,hI,kc)kj=dk([[%s M %d %f h %d]],kj,am+ko,hI,kc)end end;j_[#j_+1]=kj..[["/>]]local kq="PITCH"if not cY then kq="REL PITCH"end;if km>90 and not cg then km=90-(km-90)elseif km<-90 and not cg then km=-90-(km+90)end;if k8>200 then if cg then if fp>i_ then j_[#j_+1]=gN(am,an-15,"Yaw","pdim txt txtmid")j_[#j_+1]=gN(am,an+20,kn,"pdim txt txtmid")end;j_[#j_+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k6,am,an)else j_[#j_+1]=dk([[<g transform="rotate(0,%d,%d)">]],am,an)end;j_[#j_+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-ko+25,an-5,am-ko+20,an,am-ko+25,an+5,am-ko+50,an+4,kp)j_[#j_+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+ko-25,an-5,am+ko-20,an,am+ko-25,an+5,am+ko-30,an+4,kp)j_[#j_+1]="</g>"end;local kr=bN(k8/3)j_[#j_+1]=dk([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-kr,an,k8-kr)if not cg and cY then j_[#j_+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k6,am,an,am-ko+10,an,ko*2-20)end;j_[#j_+1]="</g>"if k8<200 then if cg and fp>i_ then j_[#j_+1]=gN(am,an-k8,kq,"pdim txt txtmid")j_[#j_+1]=gN(am,an-k8+10,kp,"pdim txt txtmid")j_[#j_+1]=gN(am,an-15,"Yaw","pdim txt txtmid")j_[#j_+1]=gN(am,an+20,kn,"pdim txt txtmid")else j_[#j_+1]=gN(am,an-k8,kq,"pdim txt txtmid")j_[#j_+1]=gN(am,an-k8+15,kp,"pdim txt txtmid")end end end end;local function ks(j_,e3,cY)local kt=as;local ku=at;if kt==0 and ku==0 then return end;local kv=78;local kw=19;local kx=cf;if cf~=-1 then j_[#j_+1]=gN(kt+kv,ku+kw+20,dk("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(e3<200000 and not cg or e3 and cg)then table.insert(j_,dk([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kt-1,ku-4,kv+2,kw+6,kt+1,ku-1,kv-4,kw))local gw=0;local ky=1;local kz=0;local kA=e3<0;local kB=e3<kC.surfaceMaxAltitude;local kD=9;if kA then kD=0 end;local e3=eZ(e3)while gw<6 do local kE=11;local kF=16;local kG=9;local kH=14;local jU="altsm"if gw>2 then kF=kF+3;kE=kE+2;kH=kH+2;kG=kG-6;jU="altbig"end;if kA then jU=jU.." red"elseif kB then jU=jU.." orange"end;local kI=e3/ky%10;local kJ=bN(kI)local kK=bN((kJ+1)%10)local kL=kz;if gw==0 then kL=kI-kJ;if kA then kL=1-kL end end;if kA and(gw==0 or kz~=0)then local gz=kK;kK=kJ;kJ=gz end;local kM=kF*(kL-1)local kN=kM+kF;local hH=kt+kG+(6-gw)*kE;local hI=ku+kH;j_[#j_+1]=gN(hH,hI+kM,kK,jU)j_[#j_+1]=gN(hH,hI+kN,kJ,jU)gw=gw+1;ky=ky*10;if kJ==kD then kz=kL else kz=0 end end;table.insert(j_,[[</g></g>]])end end;local function kO(fu)local kP=-math.deg(eU(fu.y,fu.z))+180;kP=kP-90;if kP<0 then kP=360+kP end;if kP>180 then kP=-180+kP-180 end;return-kP end;local function kQ(fu)local kd=math.deg(eU(fu.y,fu.x))-90;if kd<-180 then kd=360+kd end;return kd end;local function kR(j_,fu,fp,am,an)if fp>5 and not cg or fp>i_ then local k8=af;local kS=20;local kT=20;local kU=kO(fu)local kV=kQ(fu)local kW=14;local kX=kW/2;local kY=-kV/kT*k8;local kZ=kU/kS*k8;local hH=am+kY;local hI=an+kZ;local cb=dn(kY^2+kZ^2)local k_=[[<circle
                            cx="]]..hH..[["
                            cy="]]..hI..[["
                            r="]]..kX/kW..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hH..[["
                            cy="]]..hI..[["
                            r="]]..kX..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hH-kW..[[,]]..hI..[[ h ]]..kX..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hH+kX..[[,]]..hI..[[ h ]]..kX..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hH..[[,]]..hI-kW..[[ v ]]..kX..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<k8 then j_[#j_+1]=k_ else local k0=eU(kZ,kY)local l0=4;local l1=am+k8*math.cos(k0)local l2=an+k8*math.sin(k0)j_[#j_+1]=dk('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',k0*180/math.pi,l1,l2,l1-l0,l2-l0/2,l0*2,l0,l1+l0,l2-l0,l0,l0,-l0,l0)end;if not cg then local l3=vec3(fu)kU=kO(-l3)kV=kQ(-l3)kY=-kV/kT*k8;kZ=kU/kS*k8;hH=am+kY;hI=an+kZ;cb=dn(kY^2+kZ^2)if cb<k8 then local l4=[[<circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kX..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hH..[[,]]..hI-kW..[[ v ]]..kX..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hH..[[,]]..hI..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hH..[[,]]..hI..[[)" />
                                <path
                                    d="M ]]..hH-kX..[[,]]..hI..[[ h ]]..kW..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hH..[[,]]..hI..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hH..[[,]]..hI..[[)"/>]]j_[#j_+1]=l4 end end end end;local function l5(j_,ji,l6,l7)if ao==0 and ap==0 then return end;l6=bN(l6+0.5)local jJ=ap+10;local jK=ap+20;if iG()==1 and not l then jJ=55;jK=65 end;local l8="CRUISE"local c="km/h"local dM=l7;if ji=="TRAVEL"or ji=="AUTOPILOT"then l8="THROT"c="%"dM=l6;local l9="dim"if l6<0 then l9="red"end;j_[#j_+1]=dk([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l9,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-eZ(l6),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;j_[#j_+1]=gN(ao+10,jJ,l8,"pbright txtstart")j_[#j_+1]=gN(ao+10,jK,dk("%.0f %s",dM,c),"pbright txtstart")if cg and t and cR and bT then l6=bN(bU*100+0.5)local l9="red"if l6<0 then l9="red"end;j_[#j_+1]=dk([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l9,1-eZ(l6),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)j_[#j_+1]=gN(ao+10,jJ+40,"LIMIT","pbright txtstart")j_[#j_+1]=gN(ao+10,jK+40,l6 .."%","pbright txtstart")end;if cg and t or b9 then j_[#j_+1]=gN(ao+10,jJ-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b4 then j_[#j_+1]=gN(ao+10,jJ-40,"LIMIT: "..bN(ac*3.6+0.5).." km/h","dim txtstart")end end;local function la(j_,lb)if ao==0 and ap==0 then return end;local lc=ap-10;local ld=ao+10;j_[#j_+1]=gN(0,0,"","pdim txt txtend")if iG()==1 and not l then lc=75 end;j_[#j_+1]=gN(ld,lc,bN(lb).." km/h","pbright txtbig txtstart")end;local le=40;local function lf(j_)j_[#j_+1]=gN(je(150),jf(1070),dk("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")j_[#j_+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then j_[#j_+1]=gN(je(960),jf(550),"Warning: Invalid Control Scheme Detected","warnings")j_[#j_+1]=gN(je(960),jf(600),"Keyboard Scheme must be selected","warnings")j_[#j_+1]=gN(je(960),jf(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lg=je(960)local lh=jf(860)local li=jf(880)local lj=jf(900)local lk=jf(960)local ll=jf(200)local lm=jf(250)local ln=jf(960)if iG()==1 and not l then lh=jf(135)li=jf(155)lj=jf(175)ll=jf(115)lm=jf(95)end;if b1 then local lo=""if type(b1)=="string"then lo="-"..b1 end;j_[#j_+1]=gN(lg,lh,"Brake Engaged"..lo,"warnings")elseif bS>0 then j_[#j_+1]=gN(lg,lh,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b4 and not br and not b7 and not cQ and not ba and not b8 then j_[#j_+1]=gN(lg,ll+50,"** STALL WARNING **","warnings")fU("stall","SW",2)end end;if cX then j_[#j_+1]=gN(lg,ll+90,"Flight Assist in Progress","warnings")end;if ck then j_[#j_+1]=gN(lg,ln,"Gyro Enabled","warnings")end;if lp then le=le-1;if le>20 then j_[#j_+1]=gN(lg,ln-20,"ECU Enabled","warnings")elseif le<0 then le=40 end end;if bn then if bW then j_[#j_+1]=gN(lg,li,"Gear Extended","warn")else j_[#j_+1]=gN(lg,li,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local lq=iL(d:getTargetGroundAltitude())j_[#j_+1]=gN(lg,lj,"Hover Height: "..lq,"warn")end;if c5 then j_[#j_+1]=gN(lg,lk+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not q and cQ and bw~=nil then local lr="warnings"if eZ(ci-antigrav.getBaseAltitude())<501 then lr="warn"end;j_[#j_+1]=gN(lg,ll+40,dk("Target Altitude: %d Singularity Altitude: %d",bN(bw),bN(antigrav.getBaseAltitude())),lr)end;if b4 and bk~="None"then j_[#j_+1]=gN(lg,ll,"Autopilot "..bh,"warn")elseif bu~=nil then j_[#j_+1]=gN(lg,ll+20,dk("LockedPitch: %d",bN(bu)),"warn")elseif c0 then j_[#j_+1]=gN(lg,ll+20,"Follow Mode Engaged","warn")elseif b9 or ce then j_[#j_+1]=gN(lg,ll+20,"Re-entry in Progress","warn")end;if b6 or ba then local lq=iL(bb,2)if ba then if cQ then lq=iL(antigrav.getBaseAltitude(),2).." AGG singularity height"end;j_[#j_+1]=gN(lg,ll,"VTO to "..lq,"warn")elseif b8 and not bA then if cd then j_[#j_+1]=gN(lg,ll,"Takeoff to "..bk,"warn")else j_[#j_+1]=gN(lg,ll,"Takeoff to "..lq,"warn")end;if b1 and not ba then j_[#j_+1]=gN(lg,ll+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else j_[#j_+1]=gN(lg,ll,"Altitude Hold: "..dk("%.1fm",bb),"warn")end end;if ba and(antigrav~=nil and antigrav)then if ch>0.1 then j_[#j_+1]=gN(lg,ll+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then j_[#j_+1]=gN(lg,ll+20,"Aligning trajectory","warn")elseif ch<0.05 then j_[#j_+1]=gN(lg,ll+20,"Leaving atmosphere","warn")end end;if bA then if cC~=nil then j_[#j_+1]=gN(lg,ll,cC,"warn")end end;if b7 then if ls then local lt="Brake Landing"if dc then lt=lt.."-Aligning"end;if db then lt=lt.."-Drift Limited"end;j_[#j_+1]=gN(lg,ll,lt,"warnings")else j_[#j_+1]=gN(lg,ll,"Coast-Landing","warnings")end end;if b3 then j_[#j_+1]=gN(lg,ll,"Prograde Alignment","crit")end;if b2 then j_[#j_+1]=gN(lg,ll,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;j_[#j_+1]=gN(lg,lm+20,cZ,type)elseif ch==0 then local lu,lv=ct.checkLOS(cK:normalize())if lv~=nil then local lq=iL(lv)local lw=cp.computeTravelTime(cL,0,lv)local lx="Collision"if lu.noAtmosphericDensityAltitude>0 then lx="Atmosphere"end;j_[#j_+1]=gN(lg,lm+20,lu.name.." "..lx.." "..iM(lw).." In "..lq,"crit")end end;if br and not bA then j_[#j_+1]=gN(lg,ll+60,ly,"warn")end;if d2 and#d2>1 then end;local lz=je;local lA=jf;local lB="topButton"local lC="topButtonActive"local lD=lB;if b4 or br or cd or bA then lD=lC end;local lE=lB;if b3 then lE=lC end;local lF=lB;if b7 or bn then lF=lC end;local lG=lB;if b6 or br then lG=lC end;local lH=lB;if b2 then lH=lC end;local lI=lB;if bA or cE and b4 then lI=lC end;if w and I then local lJ=lA(30)j_[#j_+1]=dk([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lD,lz(960),lA(54),lA(-53),lz(-120),lz(25),lA(50))j_[#j_+1]=gN(lz(910),lJ,"AUTOPILOT")j_[#j_+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,lz(865),lA(51),lz(-25),lA(-50),lz(-110),lz(25),lA(46))j_[#j_+1]=gN(lz(800),lJ,"PROGRADE")j_[#j_+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lz(755),lA(47),lz(-25),lA(-46),lz(-98),lz(44),lA(44))j_[#j_+1]=gN(lz(700),lJ,"LAND")j_[#j_+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lG,lz(960),lA(54),lA(-53),lz(120),lz(-25),lA(50))j_[#j_+1]=gN(lz(1010),lJ,"ALT HOLD")j_[#j_+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,lz(1055),lA(51),lz(25),lA(-50),lz(110),lz(-25),lA(46))j_[#j_+1]=gN(lz(1122),lJ,"RETROGRADE")j_[#j_+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lI,lz(1165),lA(47),lz(25),lA(-46),lz(98),lz(-44),lA(44))j_[#j_+1]=gN(lz(1220),lJ,"ORBIT")j_[#j_+1]=[[
                                    </g>
                                </g>]]j_[#j_+1]="</g>"end;return j_ end;local function lK(fp)return bN(fV(fp*3.6,0)+0.5).." km/h"end;local function lL(gw)local gy=bk;if gw~=nil and type(gw)=="number"then if gw==0 then return"None"end;gy=cU[gw].name end;if gy==nil then gy=g5.name end;if gy==nil then gy="None"end;return gy end;local function lM(j_)local lN=ct.routeWP(true)if not lN or#lN==0 then return end;local hH=je(750)local hI=jf(360)if b4 or br then j_[#j_+1]=gN(hH,hI,"REMAINING ROUTE","pdim txtstart size20")else j_[#j_+1]=gN(hH,hI,"LOADED ROUTE","pdim txtstart size20")end;for dL,M in pairs(lN)do hI=hI+20;j_[#j_+1]=gN(hH,hI,dL..". "..lN[dL],"pdim txtstart size20")end end;local function lO(j_)local hH=aC+10;local hI=aD+20;local lP={}local lQ={"Alt-4: AutoTakeoff to Target"}local lR={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lS={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lT={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lP,"--------------DYNAMIC-----------------")if cg then if cf~=-1 then iJ(lP,lQ)if c8 and kC and c8.name==kC.name then table.insert(lP,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b0 then if antigrav then if cQ then table.insert(lP,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lP,"Turn on AGG to takeoff to AGG Height")end end;if b0 then table.insert(lP,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lP,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lP,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bn then table.insert(lP,"G: Takeoff to hover height, raise gear")else table.insert(lP,"G: Lowergear and Land")end else iJ(lP,lR)table.insert(lP,"G: Begin BrakeLanding or Land")end;if ba then table.insert(lP,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iJ(lP,lS)if shield then table.insert(lP,"Alt-Shift-6: Vent shields")if not G then table.insert(lP,"Alt-Shift-7: Toggle shield off/on")end end end;if g5~=nil then table.insert(lP,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lP,"Alt-9: Activate Gyroscope")end;if aW~="none"or aV~="none"or aX~="none"then table.insert(lP,"Alt-Shift-9: Cycles engines with Extra tags")end;if b6 then table.insert(lP,"Alt-Spacebar/C will raise/lower target height")table.insert(lP,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cg then table.insert(lP,"LALT+Mousewheel will lower/raise speed limit")end;iJ(lP,lT)for M=1,#lP do hI=hI+12;j_[#j_+1]=gN(hH,hI,lP[M],"pdim txtbig txtstart")end end;local function lU(j_)local lV=aC;local lW=aD;local lX=aB;local lY=4;local lZ=15;local hH=0;local hI=0;local l_,m0,m1,m2;local m3;local function m4(type)local gI,bQ,fp,m5,jU,m6;if type=="Periapsis"then gI=m3.periapsis.altitude;bQ=m3.timeToPeriapsis;fp=m3.periapsis.speed;jU="txtend"m5=12;m6=math.min(hH,lV+lX-kC.radius/m1-lY*2)else gI=m3.apoapsis.altitude;bQ=m3.timeToApoapsis;fp=m3.apoapsis.speed;m5=-12;jU="txtstart"m6=hH end;if cL<1 then bQ=0 end;j_[#j_+1]=dk([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m6+m5,hI-5,hH,hI-5)j_[#j_+1]=dk([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m6-m5*4,hI+2,hH,hI+2)j_[#j_+1]=gN(m6,hI,type,jU)hH=m6-m5*2;hI=hI+lZ;local lq=iL(gI)j_[#j_+1]=gN(hH,hI,lq,jU)hI=hI+lZ;j_[#j_+1]=gN(hH,hI,iM(bQ),jU)hI=hI+lZ;j_[#j_+1]=gN(hH,hI,lK(fp),jU)end;local m7=lX*1.5;if bK=="INFO"then m7=25*10 end;if bK=="ORBIT"and ci<kC.spaceEngineMinAltitude then return j_ end;if bK~="HIDE"then j_[#j_+1]=[[<g class="pbright txtorb txtmid">]]j_[#j_+1]=dk('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lX*2,m7,lV,lW)j_[#j_+1]=dk([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lX*2,m7,lV,lW)end;local m8=lX*1.5;local m9=lX*2;local ma=m8/2;local mb=lX;local mc=lV+mb;local md=lW+ma;local me=lV+m9;local mf=lW+m8;if bK=="ORBIT"then lW=lW+lY;l_=lX/2;m2=0;m3={}m3.periapsis={}m3.apoapsis={}if ft~=nil then if ft.periapsis~=nil then m3.periapsis.altitude=ft.periapsis.altitude;m3.periapsis.speed=ft.periapsis.speed end;if ft.apoapsis~=nil then m3.apoapsis.altitude=ft.apoapsis.altitude;m3.apoapsis.speed=ft.apoapsis.speed end;m3.period=ft.period;m3.eccentricity=ft.eccentricity;m3.timeToApoapsis=ft.timeToApoapsis;m3.timeToPeriapsis=ft.timeToPeriapsis;m3.eccentricAnomaly=ft.eccentricAnomaly;m3.trueAnomaly=ft.trueAnomaly end;if m3.periapsis==nil then m3.periapsis={}m3.periapsis.altitude=-kC.radius;m3.periapsis.speed=ac end;if m3.eccentricity==nil then m3.eccentricity=1 end;if m3.apoapsis==nil then m3.apoapsis={}m3.apoapsis.altitude=ci;m3.apoapsis.speed=0 end;if cL<1 then m3.apoapsis.altitude=ci;m3.apoapsis.speed=0 end;if m3.apoapsis.altitude then m1=(m3.apoapsis.altitude+m3.periapsis.altitude+kC.radius*2)/(l_*2)m0=(kC.radius+m3.apoapsis.altitude)/m1*(1-m3.eccentricity)m2=l_-m3.periapsis.altitude/m1-kC.radius/m1;local mg=math.pi;if m3.period~=nil and m3.period>0 and m3.timeToApoapsis~=nil then mg=m3.eccentricAnomaly;if m3.timeToPeriapsis<m3.timeToApoapsis then mg=2*math.pi-mg end end;if cL<1 or mg~=mg then mg=math.pi end;local mh=-l_*math.cos(mg)+lV+mb+lY;local mi=m0*math.sin(mg)+lW+ma+lY;local mj=""j_[#j_+1]='<g clip-path="url(#orbitRect)">'j_[#j_+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mj,lV+lX+lY,lW+lX*1.5/2+lY,l_,m0)if m0<1 then j_[#j_+1]=dk([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lV+lX+lY-m2,lW+lX*1.5/2+lY,mh,mi)end;j_[#j_+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lV+lX+lY-m2,lW+lX*1.5/2+lY,(kC.radius+kC.noAtmosphericDensityAltitude)/m1)j_[#j_+1]=dk('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lV+lX+lY-m2,lW+lX*1.5/2+lY,(kC.radius+kC.noAtmosphericDensityAltitude)/m1)j_[#j_+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lV+lX+lY,lW+lX*1.5/2+lY,l_,m0)j_[#j_+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lV+lX+lY-m2,lW+lX*1.5/2+lY,kC.radius/m1)j_[#j_+1]='</g>'local mk=math.floor(kC.radius/m1+0.5)hH=lV+lX+lY*4+l_;hI=lW+lX*1.5/2+5+lY;if m3.apoapsis~=nil and m3.apoapsis.speed<ac then m4("Apoapsis")end;hI=lW+lX*1.5/2+5+lY;hH=lV+lX-lY*2-l_;if m3.periapsis~=nil and m3.periapsis.speed<ac and m3.periapsis.altitude>0 then m4("Periapsis")end;j_[#j_+1]=gN(lV+lX+lY,lW+20+lY,kC.name,"txtorbbig")j_[#j_+1]=dk('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mh,mi)j_[#j_+1]=[[</g>]]return j_ else j_[#j_+1]='<g clip-path="url(#orbitRect)">'local ml=""local mm=1.2*(mn-mo)/(lX*2)local mp=1.4*(mq-mr)/(lX*1.5)for dL,dx in pairs(e[0])do if dx.center then local hH=lV+lX+dx.center.x/mm;local hI=lW+lX*1.5/2+dx.center.y/mp;ml=ml..'<circle cx="'..hH..'" cy="'..hI..'" r="'..dx.radius/mm*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dx.name,"Moon")and not string.match(dx.name,"Sanctuary")and not string.match(dx.name,"Space")then ml=ml.."<text x='"..hH.."' y='"..hI+dx.radius/mm*30+20 .."' font-size='12' fill="..j6 .." text-anchor='middle' font-family='Montserrat'>"..dx.name.."</text>"end end end;local fv=vec3(bP.getWorldPosition())local hH=lV+lX+fv.x/mm;local hI=lW+lX*1.5/2+fv.y/mp;ml=ml..'<circle cx="'..hH..'" cy="'..hI..'" r="2" stroke="white" stroke-width="1" fill="red"/>'ml=ml.."<text x='"..hH.."' y='"..hI-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iU=mm;iV=mp;local ms=fv+cK*1000000;local mt=lV+lX+ms.x/mm;local jK=lW+lX*1.5/2+ms.y/mp;ml=ml..'<line x1="'..hH..'" y1="'..hI..'" x2="'..mt..'" y2="'..jK..'" stroke="purple" stroke-width="1"/>'j_[#j_+1]=ml;j_[#j_+1]='</g>'end elseif bK=="INFO"then j_=cr.DrawOdometer(j_,j8,bo,j9)elseif bK=="HELP"then j_=lO(j_)elseif bK=="SCOPE"then j_[#j_+1]='<g clip-path="url(#orbitRect)">'local mu=d5;if ch>0 then table.sort(d4,function(eA,eB)local eC,eD=eA.center,eB.center;return(eC.x-cO.x)^2+(eC.y-cO.y)^2+(eC.z-cO.z)^2<(eD.x-cO.x)^2+(eD.y-cO.y)^2+(eD.z-cO.z)^2 end)end;local mv={}local mw={}local mx=120;local my=nil;local mz=nil;for M,dx in ipairs(d4)do local gV=dx.center-cO;local mA=gV:len()local mB=gV:normalize()local mC=gV:cross(cH):normalize()local mD=math.acos(mC:dot(cI))if mD~=mD then mD=0 end;if mC:cross(cI):dot(cH)<0 then mD=-mD end;local mE=gV:project_on_plane(cH):len()local mF=math.sin(mD)*math.asin(mE/mA)*constants.rad2deg;local mG=math.cos(mD)*math.asin(mE/mA)*constants.rad2deg;if mB:dot(cH)<0 then mG=90*math.cos(mD)+90*math.cos(mD)-mG;mF=90*math.sin(mD)+90*math.sin(mD)-mF end;local hH=mc+mF/mu*m8;local hI=md+mG/mu*m8;local mH=(hH-mc)*(hH-mc)+(hI-md)*(hI-md)local mI=math.asin((dx.radius+dx.surfaceMaxAltitude)/mA)*constants.rad2deg;if mI~=mI then mI=mu end;local i1=mI/mu*m8;local mJ=math.asin(dx.atmosphereRadius/mA)*constants.rad2deg;if mJ~=mJ then mJ=mI end;local mK=mJ/mu*m8;local cb=iL(mA,1)local mL=dx.name;local mM=false;if hI>lW then if hI>mf then if hI-mK<=mf then mM=true end else mM=true end else if hI+mK>=lW then mM=true end end;local mN=false;local mO=hH;if dx.systemId==0 then mO=hH+mx else mO=hH-mx end;if mO+mx>lV then if mO+mx>me then if mO-mK-mx<=me then mN=true end else mN=true end else if mO+mK+mx>=lV then mN=true end end;local mP={}mP.x=hH;mP.y=hI;mP.planet=dx;mP.atmoSize=mK;if not my or mH<my then my=mH;mz=mP end;if mN and mM then local mQ=math.max(mK,5)if mH<mQ*mQ then mL=mL.." - "..cb end;mP.size=i1;mP.i=M;mP.displayString=mL;mP.distance=cb;mP.visible=true;mw[#mw+1]=mP else mP.visible=false end end;local mR=false;table.sort(mw,function(eC,eD)return eC.y<eD.y end)for dL,fy in ipairs(mw)do local dx,i1,M,mK,hH,hI,mL,cb=fy.planet,fy.size,fy.i,fy.atmoSize,fy.x,fy.y,fy.displayString,fy.distance;local m6,mS,mT,mU;local mV=15;local jU="pdim"if dx.systemId~=0 then mT=je(string.len(mL)*5)mV=-(15+mT)mU=jf(10)jU="pdimfill"else mT=je(string.len(mL)*9)mU=jf(15)end;if i1*2>mT then m6=dl(hH,lV+mT/2,me-mT/2)mS=dl(hI,lW+mU,mf-5)m6=dl(m6,hH-i1+mT/2,hH+i1-mT/2)mS=dl(mS,hI-i1+mU,hI+i1)else m6=hH+mV;mS=hI end;for mW,fy in pairs(mv)do local mX=fy.textPositions;local mY=mX.y-mS;if mW~=M and eZ(mY)<mX.height and mX.x+mX.width>m6 and mX.x<m6+mT then if i1>mT then mS=dl(mS+mU,lW+15,mf-5)else mS=mX.y+mX.height+1 end end end;local mZ=mL~=dx.name or m6<=mc and m6+mT>=mc and mS-mU<=md and mS>=md;fy.hovered=mZ;local m_=1;if mZ then m_=2;if i1*2<mT then m_=10 end;if mL==dx.name then mL=mL.." - "..cb end;jU="pbright"if dx.systemId~=0 then mT=je(string.len(mL)*5)mV=-(15+mT)else mT=je(string.len(mL)*7)end;if i1*2>mT then m6=dl(hH,lV+mT/2,me-mT/2)m6=dl(m6,hH-i1+mT/2,hH+i1-mT/2)else m6=hH+mV end end;mv[M]={}mv[M].textPositions={}mv[M].textPositions.y=mS;mv[M].textPositions.x=m6;mv[M].textPositions.width=mT;mv[M].textPositions.height=mU;mv[M].output=""if i1*2>mT then jU=jU.." txtmid"else jU=jU.." txtstart"end;if mK-i1>2 then mv[M].output=dk('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hH,hI,mK,j7,0.1*m_)end;mv[M].output=mv[M].output..dk('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hH,hI,i1,j7,0.2*m_)if dx.systemId==0 then mv[M].output=mv[M].output..dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m6,mS,j6,jU,mL)if i1*2<=mT then mv[M].output=mv[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m6+mT,mS+2,m6,mS+2,hH,hI)end else mv[M].output=mv[M].output..dk([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m6,mS,j7,jU,mL)if i1*2<=mT then mv[M].output=mv[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m6,mS+2,m6+mT,mS+2,hH,hI)end end end;for dL=#d4,1,-1 do if mv[dL]then j_[#j_+1]=mv[dL].output end end;if mz~=nil and d5<90 and not mz.hovered then local n0=mz.planet.atmosphereRadius/mz.atmoSize;local n1=dn(my)*n0;local n2=iL(n1,1)local mT=je(math.max(string.len(n2)*7,string.len(mz.planet.name)*7))local mU=jf(12)local m6=dl(mz.x+(mc-mz.x)/2,lV+mT/2,me-mT/2)local mS=dl(mz.y+(md-mz.y)/2,lW+mU*2,mf-5)j_[#j_+1]=dk("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mz.x,mz.y,mc,md)j_[#j_+1]=dk([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m6,mS,"white",n2)if not mz.visible then j_[#j_+1]=dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m6,mS-mU,"white",mz.planet.name)end end;if cL>1 then local gV=cK;local mB=gV:normalize()local mE=gV:project_on_plane(cH):len()local mC=gV:cross(cH):normalize()local mD=math.acos(mC:dot(cI))if mD~=mD then mD=0 end;if mC:cross(cI):dot(cH)<0 then mD=-mD end;local mF=math.sin(mD)*math.asin(mE/gV:len())*constants.rad2deg;local mG=math.cos(mD)*math.asin(mE/gV:len())*constants.rad2deg;if mB:dot(cH)<0 then mG=90*math.cos(mD)+90*math.cos(mD)-mG;mF=90*math.sin(mD)+90*math.sin(mD)-mF end;local hH=mc+mF/mu*m8;local hI=md+mG/mu*m8;local kW=14;local kX=kW/2;local k_=[[<circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kX/kW..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kX..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hH-kW..[[,]]..hI..[[ h ]]..kX..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hH+kX..[[,]]..hI..[[ h ]]..kX..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hH..[[,]]..hI-kW..[[ v ]]..kX..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]j_[#j_+1]=k_ end;j_[#j_+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mc,md-10,mc,md+10)j_[#j_+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mc-10,md,mc+10,md)j_[#j_+1]='</g>'else return j_ end end;local function n3(n4,n5)local n6;local n7=(n5-n4):normalize()local fw=(cO-n4):dot(n7)/n7:dot(n7)if fw<=0. then return(cO-n4):len()elseif fw>=(n5-n4):len()then return(cO-n5):len()end;local n8=n4+fw*n7;n6=(n8-cO):len()return n6 end;local function n9()local n6;local na=nil;local nb=nil;local nc=nil;for dL,nd in pairs(e[0])do if nd.hasAtmosphere then local cb=n3(kC.center,nd.center)if na==nil or cb<na then nb=nd;na=cb;nc=kC end;if c8 and c8.hasAtmosphere and c8.name~=kC.name then local eP=n3(c8.center,nd.center)if eP<na then nb=nd;na=eP;nc=c8 end end end end;local ne=je(1770)local nf=jf(330)if na then local ng="txttick "local nh=500000;if na<nb.radius+nh or na<nc.radius+nh then if cV then ng="txttick red "else ng="txttick orange "end end;n6=iL(na,2)iZ=gN(ne,nf,"Pipe ("..nc.name.."--"..nb.name.."): "..n6,ng.."pbright txtmid")end end;local function ni(hH,hI,nj,nk,l8)local nl={x=hH,y=hI,width=nj,height=nk,label=l8}iT[l8]=nl;return nl end;local function nm(nn,no,nj,nk,hH,hI,np,nq,nr,ns,jU)local nl={enableName=nn,disableName=no,width=nj,height=nk,x=hH,y=hI,toggleVar=np,toggleFunction=nq,drawCondition=nr,hovered=false,class=jU}if ns then table.insert(iS,nl)else table.insert(iR,nl)end;return nl end;local function nt(nu)if not iX then nv=false;nw=false;nx=false;w=true;return elseif nu=="handling"then nv=not nv;nw=false;nx=false elseif nu=="hud"then nw=not nw;nv=false;nx=false elseif nu=="physics"then nx=not nx;nv=false;nw=false end;if nx or nw or nv then iY=iK(nu)w=false else iY="none"w=true end end;local function ny()iX=not iX;if iX then iQ=iS;c3="Tap SHIFT to see Settings"d6=w else iQ=iR;c3="Tap SHIFT to see Control Buttons"nt()w=d6 end end;local function nz()local function nA(dx,dL)dx.set(not dx.get())if dx.get()then c3=dL.." set to true"else c3=dL.." set to false"end;if dL=="showHud"then d6=dx.get()elseif dL=="BrakeToggleDefault"then a_=j elseif dL=="FullRadar"then if not J then cu.ToggleRadarPanel()J=false else J=true;nB.radarSetup()end end end;local nC=50;local nD=340;local hH=500;local hI=ae/2-400;local nE=0;for dL,dx in pairs(iK("boolean"))do if type(dx.get())=="boolean"then nm(dL,dL,nD,nC,hH,hI,function()return dx.get()end,function()nA(dx,dL)end,function()return true end,true)hI=hI+nC+20;if nE==9 then hH=hH+nD+20;hI=ae/2-400;nE=0 else nE=nE+1 end end end;nm("Control View","Control View",nD,nC,10,ae/2-500,function()return true end,ny,function()return true end,true)nm("View Handling Settings",'Hide Handling Settings',nD,nC,10,ae/2-(500-nC),function()return nv end,function()nt("handling")end,function()return true end,true)nm("View Hud Settings",'Hide Hud Settings',nD,nC,10,ae/2-(500-nC*2),function()return nw end,function()nt("hud")end,function()return true end,true)nm("View Physics Settings",'Hide Physics Settings',nD,nC,10,ae/2-(500-nC*3),function()return nx end,function()nt("physics")end,function()return true end,true)end;local function nF()local function gx()local fX=cO;local gy=kC.name..". "..#bq;if cu then gy=cu.GetClosestName(gy)end;return cs.AddNewLocation(gy,fX,false,true)end;local function nG()b5=not b5 end;local function nH(nI)if nI==1 then b3=not b3;b2=false else b2=not b2;b3=false end;b4=false;b6=false;c0=false;b7=false;bu=nil;b9=false;b8=false end;local function nJ(nK,nL)cs.UpdatePosition(nil,nK,nL)end;local function gs()cs.ClearCurrentPosition()end;local function nM(gw)local lN=ct.routeWP(true)if lN and#lN>0 then return"Engage Route: "..lN[1]end;return"Engage Autopilot: "..lL(gw)end;local function nN(gw)local lN=ct.routeWP(true)if lN and#lN>0 then return"Next Route Point: "..lN[1]end;return"Disable Autopilot: "..lL(gw)end;local function nO()if iG()==1 then c0=not c0;if c0 then b4=false;b2=false;b3=false;b6=false;b9=false;b7=false;b8=false;nP=bn;bn=false;d.control.retractLandingGears()iH:setTargetGroundAltitude(_)fU("folOn","F")else fU("folOff","F")b1="Follow Off"cz=p;bn=nP;if bn then d.control.deployLandingGears()iH:setTargetGroundAltitude(a0)end end else c3="Follow Mode only works with Remote controller"c0=false end end;local nC=50;local nD=260;local nQ=je(30)local nR=aC+aB*2+2;local nS=aD+1;nm("+","+",nQ,nQ,nR,nS+nQ+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")nm("-","-",nQ,nQ,nR,nS,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")nm("0","0",nQ,nQ,nR,nS+nQ*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nT=nm("Enable Brake Toggle","Disable Brake Toggle",nD,nC,ad/2-nD/2,ae/2+350,function()return a_ end,function()a_=not a_;if a_ then c3="Brakes in Toggle Mode"else c3="Brakes in Default Mode"end end)nm("Align Prograde","Disable Prograde",nD,nC,ad/2-nD/2-50-nT.width,ae/2-nC+380,function()return b3 end,function()nH(1)end)nm("Align Retrograde","Disable Retrograde",nD,nC,ad/2-nD/2+nT.width+50,ae/2-nC+380,function()return b2 end,nH,function()return ch==0 end)nU=nm(nM,nN,600,60,ad/2-600/2,ae/2-60/2-330,function()return b4 or br or cd or bA end,function()end)local M;local function nV(nW)local gw=d1+nW;if gw>#cU then gw=gw-#cU-1 end;if gw<0 then gw=#cU+gw end;return gw end;nX={}for M=0,10 do local nY=nm(function(eD)local gw=nV(eD.apExtraIndex)if b4 or br or cd or bA then return"Redirect: "..lL(gw)end;return nM(gw)end,function(eD)local gw=nV(eD.apExtraIndex)return nN(gw)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eD)local gw=nV(eD.apExtraIndex)return gw==bm and(b4 or br or cd or bA)end,function(eD)local gw=nV(eD.apExtraIndex)local nZ=bm==gw;bm=gw;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not nZ and not(b4 or br or cd or bA)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nY.apExtraIndex=M;nX[M]=nY end;nm("Save Position","Save Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,gx,function()return bm==0 or g5==nil end)nm("Update Position","Update Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,function()nJ(nil)end,function()return bm>0 and g5~=nil end)nm("Save Heading","Clear Heading",200,nU.height,nU.x+nU.width+30,nU.y+nU.height+20,function()return g5.heading~=nil end,function()if g5.heading~=nil then nJ(false)else nJ(true)end end,function()return bm>0 and g5~=nil end)nm("Save AGG Alt","Clear AGG Alt",200,nU.height,nU.x+nU.width+30,nU.y+nU.height*2+40,function()return g5.agg~=nil end,function()if g5.agg~=nil then nJ(nil,false)else nJ(nil,true)end end,function()return bm>0 and g5~=nil and antigrav end)nm("Clear Position","Clear Position",200,nU.height,nU.x-200-30,nU.y,function()return true end,gs,function()return bm>0 and g5~=nil end)nm("Save Route","Save Route",200,nU.height,nU.x-200-30,nU.y+nU.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)nm("Load Route","Clear Route",200,nU.height,nU.x-200-30,nU.y+nU.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b4 or br then c3="Disable Autopilot before loading route"return else ct.routeWP(false,false,1)end end,function()return true end)nC=60;nD=300;local hH=0;local hI=ae/2-150;nm("Enable Check Damage","Disable Check Damage",nD,nC,hH,hI-nC-20,function()return s end,function()s=not s end)nm("View Settings","View Settings",nD,nC,hH,hI,function()return true end,ny)hI=hI+nC+20;nm("Enable Turn and Burn","Disable Turn and Burn",nD,nC,hH,hI,function()return b5 end,nG)hH=10;hI=ae/2-300;nm("Horizontal Takeoff Mode","Vertical Takeoff Mode",nD,nC,ad/2-nD/2,hI+20,function()return b0 end,function()b0=not b0;if b0 then c3="Vertical Takeoff Mode"else c3="Horizontal Takeoff Mode"end end,function()return cP end)hI=hI+nC+20;nm("Engage Orbiting","Cancel Orbiting",nD,nC,hH+nD+20,hI,function()return bA end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hI=ae/2-150;nm("Glide Re-Entry","Cancel Glide Re-Entry",nD,nC,hH+nD+20,hI,function()return b9 end,function()cc=1;nH(1)end,function()return kC.hasAtmosphere and not cg end)hI=hI+nC+20;nm("Parachute Re-Entry","Cancel Parachute Re-Entry",nD,nC,hH+nD+20,hI,function()return b9 end,function()cc=2;nH(1)end,function()return kC.hasAtmosphere and not cg end)hI=hI+nC+20;nm("Engage Follow Mode","Disable Follow Mode",nD,nC,hH,hI,function()return c0 end,nO,function()return iG()==1 end)nm("Enable Repair Arrows","Disable Repair Arrows",nD,nC,hH+nD+20,hI,function()return jc end,function()jc=not jc;if jc then c3="Repair Arrows Enabled"else c3="Repair Arrows Diabled"end end,function()return iG()==1 end)hI=hI+nC+20;if not q then nm("Enable AGG","Disable AGG",nD,nC,hH,hI,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;nm(function()return dk("Switch IPH Mode - Current: %s",bB)end,function()return dk("IPH Mode: %s",bB)end,nD*2,nC,hH,hI,function()return false end,function()if bB=="All"then bB="Custom Only"elseif bB=="Custom Only"then bB="No Moons-Asteroids"else bB="All"end;c3="IPH Mode: "..bB end)hI=hI+nC+20;nm(function()return dk("Toggle Control Scheme - Current: %s",g)end,function()return dk("Control Scheme: %s",g)end,nD*2,nC,hH,hI,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c3="New Control Scheme: "..g end)local n_=jf(20)local nY=ni(0,0,je(70),n_,"HELP")nY=ni(nY.x+nY.width,nY.y,je(80),n_,"INFO")nY=ni(nY.x+nY.width,nY.y,je(70),n_,"ORBIT")nY=ni(nY.x+nY.width,nY.y,je(70),n_,"SCOPE")ni(nY.x+nY.width,nY.y,je(70),n_,"HIDE")end;local o0={}local o1=nil;function o0.HUDPrologue(j_)if not cV then j3=aj;j4=ak;j5=al else j3=ag;j4=ah;j5=ai end;j6=[[rgb(]]..bN(j3+0.6)..","..bN(j4+0.6)..","..bN(j5+0.6)..[[)]]j7=[[rgb(]]..bN(j3*0.8+0.5)..","..bN(j4*0.8+0.5)..","..bN(j5*0.8+0.5)..[[)]]local o2=j6;local o3=j7;local o4=[[rgb(]]..bN(j3*0.4+0.5)..","..bN(j4*0.4+0.5)..","..bN(j5*0.4+0.5)..[[)]]local o5=j6;local o6=j7;local o7=o4;if jg()and not m then o2=[[rgb(]]..bN(j3*0.5+0.5)..","..bN(j4*0.5+0.5)..","..bN(j5*0.5+0.5)..[[)]]o3=[[rgb(]]..bN(j3*0.3+0.5)..","..bN(j4*0.3+0.5)..","..bN(j5*0.2+0.5)..[[)]]o4=[[rgb(]]..bN(j3*0.2+0.5)..","..bN(j4*0.2+0.5)..","..bN(j5*0.2+0.5)..[[)]]end;local lz=je;local lA=jf;j_[#j_+1]=dk([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o2,o2,o2,o5,o5,o3,o3,o6,o6,o3,o2,o4,o6,o2,o2,o4,o4,o7,o4,ad,ae,o3,o3,o3,o3,o3,o5,o3,o6,o7,o6,o6,o7)if not o1 then o1=dk([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lz(630),lA(0),lz(675),lA(45),lz(960),lA(55),lz(1245),lA(45),lz(1290),lA(0),lz(1000),lA(105),lz(1040),lA(59),lz(1250),lA(51),lz(1300),lA(0),lz(1920),lA(0),lz(1920),lA(20),lz(1400),lA(20),lz(1300),lA(105),lz(920),lA(105),lz(880),lA(59),lz(670),lA(51),lz(620),lA(0),lz(0),lA(0),lz(0),lA(20),lz(520),lA(20),lz(620),lA(105),lz(890),lA(59),lz(960),lA(62),lz(1030),lA(59),lz(985),lA(112),lz(1150),lA(112),lz(1100),lA(152),lz(820),lA(152),lz(780),lA(112),lz(935),lA(112),lz(890),lA(59),lz(960),lA(62),lz(1030),lA(59),lz(985),lA(112),lz(1150),lA(112),lz(1100),lA(152),lz(820),lA(152),lz(780),lA(112),lz(935),lA(112))end;if w and I then j_[#j_+1]=o1 end;return j_ end;function o0.DrawVerticalSpeed(j_,e3)jZ(j_,e3)end;function o0.UpdateHud(j_)local kP=cS;local o8=cT;local k6=o8;local km=kP;local l6=bN(c.getThrottle())local lb=cL*3.6;local l7=c.getAxisCommandValue(0)local o9=je(1770)local oa=jf(310)if t and cR then l7=bR;l6=bR*100 end;local ji=jh()local k7="ROLL"if l6==nil then l6=0 end;if not cY then if cL>5 then kP=kO(cJ)o8=kQ(cJ)else kP=0;o8=0 end;k7="YAW"end;if cW>50000 and not cg then local ob;ob=iL(cW)j_[#j_+1]=gN(o9,oa,"PvP Boundary: "..ob,"pbright txtbig txtmid")end;j_[#j_+1]=ja;j_[#j_+1]=ig;if iZ~=""then j_[#j_+1]=iZ end;if jj~=""then j_[#j_+1]=jj end;if jk~=""then j_[#j_+1]=jk end;jZ(j_,ci)if iG()==0 or l then if not jg()or m then if cY then k5(j_,am,an,k6,k7,cY)kl(j_,km,k6,am,an,cY,bN(kQ(cJ)),cL)else k5(j_,am,an,o8,k7,cY)kl(j_,kP,o8,am,an,cY,bN(o8),cL)end;ks(j_,ci,cY)kR(j_,cJ,cL,am,an)end end;l5(j_,ji,l6,l7)la(j_,lb)lf(j_)lU(j_)if not iX and c1 then lM(j_)end;return j_ end;function o0.HUDEpilogue(j_)j_[#j_+1]="</svg>"return j_ end;function o0.ExtraData(j_)local oc=je(1240)local od=jf(55)local oe=od+10;local of;local lz=je;local lA=jf;local og=0;local ji=jh()if b0 then ji=ji.."-VERTICAL"end;if E and not b8 and not b7 and cL>20 then ji=ji.."-COLLISION ON"end;if bD~="Off"then ji="("..bD..")-"..ji end;if b5 then ji="TB-"..ji end;if bI then ji="HOVERMODE-"..ji end;if not bC then ji=ji.."-DeCoupled"end;local oh=lA(99)local oi=lA(80)local oj=lA(85)local ok=lA(31)local ol=0;local om=0;local on=cj>1000000 and fV(cj/1000000,2).."kT"or fV(cj/1000,2).."T"if cg then og=bv else og=bt end;local oo,op=cp.computeDistanceAndTime(cL,0,cj,0,0,og)if oo<0 then oo=0 end;og=fV(og/(cj*iP),2).."g"local oq=d:maxForceForward()of=b.getGravityIntensity()if of>0.1 then om=cj*of;om=fV(om/(cj*iP),2).."g"ol=0.5*oq/of;ol=ol>1000000 and fV(ol/1000000,2).."kT"or fV(ol/1000,2).."T"end;oq=fV(oq/(cj*iP),2).."g"local os=vec3(bP.getWorldAcceleration()):len()/9.80665;of=b.getGravityIntensity()j_[#j_+1]=[[<g class="dim txt txtend size14">]]if iG()==1 and not l then oc=je(1120)od=jf(55)oe=od+10 elseif cg and I then local ot=je(770)j_[#j_+1]=gN(lz(895),oh,"ATMO","")j_[#j_+1]=dk([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lz(895),oj,lz(-80))j_[#j_+1]=gN(lz(815),oi,dk("%.1f%%",ch*100),"txtstart size20")end;if I then j_[#j_+1]=gN(lz(1025),oh,"GRAVITY","txtstart")j_[#j_+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(1025),oj,lz(80))j_[#j_+1]=gN(lz(1105),oi,dk("%.2fg",of/9.80665),"size20")j_[#j_+1]=gN(lz(1125),oh,"ACCEL","txtstart")j_[#j_+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(1125),oj,lz(80))j_[#j_+1]=gN(lz(1205),oi,dk("%.2fg",os),"size20")j_[#j_+1]=gN(lz(695),oh,"BRK TIME","")j_[#j_+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(695),oj,lz(-80))j_[#j_+1]=gN(lz(615),oi,dk("%s",iM(op)),"txtstart size20")j_[#j_+1]=gN(lz(635),lA(45),"TRIP","")j_[#j_+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(635),lA(31),lz(-90))if lw then j_[#j_+1]=gN(lz(545),lA(26),dk("%s",iM(lw)),"txtstart size20")end;j_[#j_+1]=gN(lz(795),oh,"BRK DIST","")j_[#j_+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(795),oj,lz(-80))j_[#j_+1]=gN(lz(715),oi,dk("%s",iL(oo)),"txtstart size20")j_[#j_+1]=gN(lz(1285),lA(45),"MASS","txtstart")j_[#j_+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(1285),lA(31),lz(90))j_[#j_+1]=gN(lz(1375),lA(26),dk("%s",on),"size20")j_[#j_+1]=gN(lz(1220),oh,"THRUST","txtstart")j_[#j_+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(1220),oj,lz(80))j_[#j_+1]=gN(lz(1300),oi,dk("%s",oq),"size20")j_[#j_+1]=gN(je(960),jf(175),ji,"pbright txtbig txtmid size20")end;j_[#j_+1]="</g>"end;local ou=1-(a7*0.05+a8*0.05)function o0.FuelUsed(ov)local ow;if ov=="atmofueltank"then ow=dk("Atmo Fuel Used: %.1f L",jB[ov]/(4*ou))elseif ov=="spacefueltank"then ow=dk("Space Fuel Used: %.1f L",jB[ov]/(6*ou))else ow=dk("Rocket Fuel Used: %.1f L",jB[ov]/(0.8*ou))end;return ow end;local ox,oy,oz,oA,oB=0,0,0,{},0;function o0.DrawOdometer(j_,j8,bo,j9)if bK~="INFO"then return j_ end;local of;local ol=0;local om=0;local og=0;local on=cj>1000000 and fV(cj/1000000,2).." kTons"or fV(cj/1000,2).." Tons"if cg then og=bv else og=bt end;local oo,op=cp.computeDistanceAndTime(cL,0,cj,0,0,og)og=fV(og/(cj*iP),2).." g"local oq=d:maxForceForward()of=b.getGravityIntensity()if of>0.1 then om=cj*of;om=fV(om/(cj*iP),2).." g"ol=0.5*oq/of;ol=ol>1000000 and fV(ol/1000000,2).." kTons"or fV(ol/1000,2).." Tons"end;oq=fV(oq/(cj*iP),2).." g"if iG()==0 or l then local oC=je(aC+10)local oD=jf(aD+20)local oE=je(aC+10+aB/1.25)local nk=25;local oF=bN(1/aU)if oz<oF then oB=oB+a.getActionUpdateDeltaTime()oz=oz+1 else ox=1/(oB/oF)table.insert(oA,ox)oz,oB=0,0 end;oy=0;for dL,dx in pairs(oA)do oy=oy+dx end;if#oA>0 then oy=bN(oy/#oA)end;if#oA>29 then table.remove(oA,1)end;j_[#j_+1]="<g class='txtstart size14 bright'>"j_[#j_+1]=gN(oC,oD,dk("BrkTime: %s",iM(op)))j_[#j_+1]=gN(oE,oD,dk("Trip: %.2f km",j8))j_[#j_+1]=gN(oC,oD+nk,dk("Lifetime: %.2f kSU",bo/200000))j_[#j_+1]=gN(oE,oD+nk,dk("BrkDist: %s",iL(oo)))j_[#j_+1]=gN(oC,oD+nk*2,"Trip Time: "..iM(j9))j_[#j_+1]=gN(oE,oD+nk*2,"Total Time: "..iM(bp))j_[#j_+1]=gN(oC,oD+nk*3,dk("Mass: %s",on))j_[#j_+1]=gN(oE,oD+nk*3,dk("Max Brake: %s",og))j_[#j_+1]=gN(oC,oD+nk*4,dk("Max Thrust: %s",oq))if of>0.1 then j_[#j_+1]=gN(oE,oD+nk*4,dk("Max Thrust Mass: %s",ol))j_[#j_+1]=gN(oC,oD+nk*5,dk("Req Thrust: %s",om))else j_[#j_+1]=gN(oE,oD+nk*4,"Max Mass: n/a")j_[#j_+1]=gN(oC,oD+nk*5,"Req Thrust: n/a")end;j_[#j_+1]=gN(oE,oD+nk*5,cr.FuelUsed("atmofueltank"))j_[#j_+1]=gN(oC,oD+nk*6,cr.FuelUsed("spacefueltank"))j_[#j_+1]=gN(oE,oD+nk*6,cr.FuelUsed("rocketfueltank"))j_[#j_+1]=gN(oC,oD+nk*7,dk("Set Max Speed: %s",bN(ac*3.6+0.5)))j_[#j_+1]=gN(oE,oD+nk*7,dk("Actual Max Speed: %s",bN(df*3.6+0.5)))j_[#j_+1]=gN(oC,oD+nk*8,dk("Friction Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))j_[#j_+1]=gN(oE,oD+nk*8,dk("FPS (Avg): %s (%s)",bN(ox),oy))end;j_[#j_+1]="</g></g>"return j_ end;function o0.DrawWarnings(j_)return lf(j_)end;function o0.DisplayOrbitScreen(j_)return lU(j_)end;function o0.DisplayMessage(j_,lq)if lq~="empty"then local hI=310;for lt in string.gmatch(lq,"([^\n]+)")do hI=hI+35;j_[#j_+1]=gN("50%",hI,lt,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;function o0.DrawDeadZone(j_)j_[#j_+1]=dk([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function o0.UpdatePipe()if cg then iZ=""return end;n9()end;function o0.DrawSettings(j_)local hH=je(640)local hI=jf(200)j_[#j_+1]=[[<g class="pbright txtvspd txtstart">]]local hY=0;for dL,dx in pairs(iY)do hY=hY+1;j_[#j_+1]=gN(hH,hI,dL..": "..dx.get())hI=hI+20;if hY%12==0 then hH=hH+je(350)hI=jf(200)end end;j_[#j_+1]=gN(je(640),jf(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")j_[#j_+1]="</g>"return j_ end;local ie=jf(125)local id=je(1225)function o0.DrawRadarInfo()ig=cu.GetRadarHud(id,ie,ay,az)end;function o0.DrawTanks()if au~=0 and av~=0 then jj=gN(au,av,"","txtstart pdim txtfuel")jC=av;jD(au,"Atmospheric ","ATMO",cl,jz,jA)jD(au,"Space Fuel T","SPACE",cm,jx,jy)jD(au,"Rocket Fuel ","ROCKET",cn,jv,jw)end end;function o0.DrawShield()local iq=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oG=bP.getPvPTimer()local oH=shield.getResistances()local oI="A: "..10+oH[1]*100 .."% / E: "..10+oH[2]*100 .."% / K:"..10+oH[3]*100 .."% / T: "..10+oH[4]*100 .."%"local hH,hI=aw-60,ax+30;local jS=bN(dg*2.55)local jT=dk("rgb(%d,%d,%d)",255-jS,jS,0)local jU=""jk=gN(hH,hI,"","txtmid pdim txtfuel")if dg<10 and iq~="Shield Disabled"then jU="red "end;oG=oG>0 and"   PvPTime: "..iM(oG)or""jk=jk..dk([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hH,hI,jT,dg*2,hH,hI,hH+2,hI+10,dg,oG)jk=jk..gN(hH,hI-5,iq,jU.."txtstart pbright txtbig")jk=jk..gN(hH,hI+30,oI,jU.."txtstart pbright txtsmall")end;function o0.hudtick()if not kC then return end;local function oJ(j_)local jW=bN(dl(dd/(ad/4)*255,0,255))j_[#j_+1]=dk("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(j3+0.5)+jW,bN(j4+0.5)-jW,bN(j5+0.5)-jW)end;local function oK()if c2 then for dQ,dx in pairs(iQ)do if dx.hovered then if not dx.drawCondition or dx.drawCondition(dx)then dx.toggleFunction(dx)end;dx.hovered=false end end;for dQ,dx in pairs(iT)do if dx.hovered then bK=dx.label;dx.hovered=false end end;c2=false end end;local function oL()local function oM(oN,oO,hH,hI,nj,nk)if oN>=hH and oN<=hH+nj and oO>=hI and oO<=hI+nk then return true else return false end end;local hH=c9+ad/2;local hI=ca+ae/2;for dQ,dx in pairs(iQ)do dx.hovered=oM(hH,hI,dx.x,dx.y,dx.width,dx.height)end;for dQ,dx in pairs(iT)do dx.hovered=oM(hH,hI,dx.x,dx.y,dx.width,dx.height)end;if d0 then local mZ=false;for dQ,eD in ipairs(nX)do if eD.hovered then mZ=true;break end end;if nU.hovered then mZ=true end;d0=mZ else d0=nU.hovered;if not d0 then d1=bm end end end;local function oP(j_)if not bK or bK==""then bK="HELP"end;if w then for dL,dx in pairs(iT)do local jU="dim brightstroke"local oQ=0.2;if bK==dL then jU="pbright dimstroke"oQ=0.6 end;local oR=""if dx.hovered then oQ=0.8;oR=";stroke:white"end;j_[#j_+1]=dk([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dx.width,dx.height,dx.x,dx.y,jU,oQ,oR)j_[#j_+1]=gN(dx.x+dx.width/2,dx.y+dx.height/2+5,dx.label,"txt txtmid pdim")end end end;local function oS(j_)local function oT(j_,oU,hover,hH,hI,fi,oV,oW,oX,oY,oZ,nY)if type(oY)=="function"then oY=oY(nY)end;if type(oZ)=="function"then oZ=oZ(nY)end;j_[#j_+1]=dk("<rect x='%f' y='%f' width='%f' height='%f' fill='",hH,hI,fi,oV)if oU then j_[#j_+1]=dk("%s'",oW)else j_[#j_+1]=oX end;if hover then j_[#j_+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else j_[#j_+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fV(ag*0.5,0),fV(ah*0.5,0),fV(ai*0.5,0))end;j_[#j_+1]=" rx='5'></rect>"j_[#j_+1]=dk("<text x='%f' y='%f' font-size='24' fill='",hH+fi/2,hI+oV/2+5)if oU then j_[#j_+1]="black"else j_[#j_+1]="white"end;j_[#j_+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oU then j_[#j_+1]=dk("%s</text>",oY)else j_[#j_+1]=dk("%s</text>",oZ)end end;local o_=dk("rgb(%d,%d,%d)'",fV(ag*0.1,0),fV(ah*0.1,0),fV(ai*0.1,0))local p0=dk("rgb(%d,%d,%d)",fV(ag*0.8,0),fV(ah*0.8,0),fV(ai*0.8,0))local p1=oT;for dQ,dx in pairs(iQ)do local no=dx.disableName;local nn=dx.enableName;if type(no)=="function"then no=no(dx)end;if type(nn)=="function"then nn=nn(dx)end;if not dx.drawCondition or dx.drawCondition(dx)then p1(j_,dx.toggleVar(dx),dx.hovered,dx.x,dx.y,dx.width,dx.height,p0,o_,no,nn,dx)end end end;local p2=fV(ad/2,0)local p3=fV(ae/2,0)local j_={}if p4 then j_[#j_+1]=p4 end;cr.HUDPrologue(j_)if w then cr.UpdateHud(j_)else if A then cr.DrawVerticalSpeed(j_,ci)end;cr.DrawWarnings(j_)end;if iX and iY~="none"then cr.DrawSettings(j_)end;if cu then cr.DrawRadarInfo()else ig=""end;cr.HUDEpilogue(j_)j_[#j_+1]=dk([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c3~="empty"then cr.DisplayMessage(j_,c3)end;if iG()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(j_)end end;oP(j_)if iI()==0 then if iG()==1 and c1 then if not p5 then oL()oS(j_)end;if not cx and not cy then local p6=table.concat(j_,"")j_={}j_[#j_+1]=dk("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)j_[#j_+1]=p6;j_[#j_+1]="</body>"cx=true;j_[#j_+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local p6=table.concat(j_,"")j_={}j_[#j_+1]=dk("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)j_[#j_+1]=p6;j_[#j_+1]="</body>"end;if not cx then j_[#j_+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,c9,ca)end else oK()end else if not c1 and iG()==0 then oK()if dd>aA then if v then oJ(j_)end end elseif c1 and(not p5 or not i)then oL()oS(j_)end;j_[#j_+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,c9,ca)end;j_[#j_+1]=[[</svg></body>]]p7=table.concat(j_,"")end;function o0.TenthTick()local function p8()local p9=a.createData;local pa=a.createWidget;pb=a.createWidgetPanel("Interplanetary Helper")pc=pa(pb,"value")pd=p9('{"label": "Target Planet", "value": "N/A", "unit":""}')fT(pd,pc)pe=pa(pb,"value")pf=p9('{"label": "distance", "value": "N/A", "unit":""}')fT(pf,pe)gm=pa(pb,"value")gl=p9('{"label": "Travel Time", "value": "N/A", "unit":""}')fT(gl,gm)gk=pa(pb,"value")gj=p9('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fT(gj,gk)go=pa(pb,"value")gn=p9('{"label": "Target Altitude", "value": "N/A", "unit":""}')fT(gn,go)gg=pa(pb,"value")gf=p9('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ge=pa(pb,"value")gd=p9('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gc=pa(pb,"value")gb=p9('{"label": "Max Brake distance", "value": "N/A", "unit":""}')ga=pa(pb,"value")g9=p9('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gi=pa(pb,"value")gh=p9('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fT(gf,gg)fT(gd,ge)fT(gb,gc)fT(g9,ga)fT(gh,gi)end end;local function pg()gM(pb)pb=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bk~="None"then if pb==nil then p8()end;if bk~=nil then local mA;local ph=g5~=nil;local pi=0.5*bv/c8:getGravity(c8.center+vec3(0,0,1)*c8.radius):len()pi=pi>1000000 and fV(pi/1000000,2).." kTons"or fV(pi/1000,2).." Tons"fS(pd,'{"label": "Target", "value": "'..bk..'", "unit":""}')if ph and not b4 then mA=(cO-g5.position):len()else mA=(bl-cO):len()end;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)j0,j1=ct.GetAutopilotBrakeDistanceAndTime(ac)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)j0,j1=ct.GetAutopilotTBBrakeDistanceAndTime(ac)end;local lq=iL(mA)fS(pf,'{"label": "distance", "value": "'..lq..'"}')fS(gl,'{"label": "Travel Time", "value": "'..iM(lw)..'", "unit":""}')lq=iL(c6)fS(gf,'{"label": "Cur Brake distance", "value": "'..lq..'"}')fS(gd,'{"label": "Cur Brake Time", "value": "'..iM(c7)..'", "unit":""}')lq=iL(j0)fS(gb,'{"label": "Max Brake distance", "value": "'..lq..'"}')fS(g9,'{"label": "Max Brake Time", "value": "'..iM(j1)..'", "unit":""}')fS(gj,'{"label": "Max Brake Mass", "value": "'..dk("%s",pi)..'", "unit":""}')lq=iL(gp)fS(gn,'{"label": "Target Orbit", "value": "'..lq..'"}')if cg and not pj then a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)a.removeDataFromWidget(gf,gg)a.removeDataFromWidget(gh,gi)pj=true;if not cR and t and(b6 or b9 or ce)then ct.cmdThrottle(1)b1=false;bV=false end end;if not cg and pj then if fS(g9,ga)==1 then fT(g9,ga)end;if fS(gb,gc)==1 then fT(gb,gc)end;if fS(gd,ge)==1 then fT(gd,ge)end;if fS(gf,gg)==1 then fT(gf,gg)end;if fS(gh,gi)==1 then fT(gh,gi)end;pj=false end end else pg()end;if warpdrive~=nil then local pk=iE(warpdrive.getWidgetData())if pk.destination~="Unknown"and pk.distance>400000 then if not jd then warpdrive.showWidget()jd=true end elseif jd then warpdrive.hideWidget()jd=false end end end;function o0.OneSecondTick()local function pl()local jN=bM()local lb=cL;local pm=jN-jb;if lb>1.38889 then lb=lb/1000;local pn=lb*(jN-jb)bo=bo+pn;j8=j8+pn end;j9=j9+pm;bp=bp+pm;jb=jN end;local function po(j_)local pp=0;local pq=iO;local pr=0;local ps=0;local pt=0;local jS=0;local jT=""local pu=b.getElementHitPointsById;local pv=b.getElementMaxHitPointsById;local pw={}for dL in pairs(iN)do local px=0;local py=0;py=pv(iN[dL])px=pu(iN[dL])pr=pr+px;if px+1<py then if px==0 then pt=pt+1 else ps=ps+1 end;if jc and#pw==0 then fX=vec3(b.getElementPositionById(iN[dL]))local hH=fX.x;local hI=fX.y;local hJ=fX.z;table.insert(pw,b.spawnArrowSticker(hH,hI,hJ+1,"down"))table.insert(pw,b.spawnArrowSticker(hH,hI,hJ+1,"down"))b.rotateSticker(pw[2],0,0,90)table.insert(pw,b.spawnArrowSticker(hH+1,hI,hJ,"north"))table.insert(pw,b.spawnArrowSticker(hH+1,hI,hJ,"north"))b.rotateSticker(pw[4],90,90,0)table.insert(pw,b.spawnArrowSticker(hH-1,hI,hJ,"south"))table.insert(pw,b.spawnArrowSticker(hH-1,hI,hJ,"south"))b.rotateSticker(pw[6],90,-90,0)table.insert(pw,b.spawnArrowSticker(hH,hI-1,hJ,"east"))table.insert(pw,b.spawnArrowSticker(hH,hI-1,hJ,"east"))b.rotateSticker(pw[8],90,0,90)table.insert(pw,b.spawnArrowSticker(hH,hI+1,hJ,"west"))table.insert(pw,b.spawnArrowSticker(hH,hI+1,hJ,"west"))b.rotateSticker(pw[10],-90,0,90)table.insert(pw,iN[dL])end elseif jc and#pw>0 and pw[11]==iN[dL]then for jM in pairs(pw)do b.deleteSticker(pw[jM])end;pw={}end end;pp=fV(pr/pq*100,2)if pt>0 or ps>0 then j_[#j_+1]=gN(0,0,"","pbright txt")jS=bN(pp*2.55)jT=dk("rgb(%d,%d,%d)",255-jS,jS,0)j_[#j_+1]=gN("50%",1035,"Elemental Integrity: "..pp.."%","txtbig txtmid","fill:"..jT)if pt>0 then j_[#j_+1]=gN("50%",1055,"Disabled Modules: "..pt.." Damaged Modules: "..ps,"txtbig txtmid","fill:"..jT)elseif ps>0 then j_[#j_+1]=gN("50%",1055,"Damaged Modules: "..ps,"txtbig txtmid","fill:"..jT)end end end;local function pz()if iD then if j2==nil and(hl~=nil or bn)then _autoconf.displayCategoryPanel(iD,weapon_size,"Weapons","weapon",true)j2=_autoconf.panels[_autoconf.panels_size]elseif j2~=nil and hl==nil and not bn then gM(j2)j2=nil end end end;d2=bP.getPlayersOnBoard()d3=bP.getDockedConstructs()local j_={}pl()if s then po(j_)end;pz()cr.UpdatePipe()cr.ExtraData(j_)ja=table.concat(j_,"")end;function o0.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function o0.MsgTick()local j_={}cr.DisplayMessage(j_,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function o0.ButtonSetup()nz()nF()iQ=iR end;if pA then for dL,dx in pairs(pA)do o0[dL]=dx end end;return o0 end;local function pB(d,b,c,e,vBooster,hover,pC,antigrav,dbHud_1,eZ,bN,bO,iG,eU,bM,dl,iH,fS,iI,dn,fV,fU,iJ,dp,iL,iM,pD,iE)local a=DUSystem;local bP=DUConstruct;local pE={}local pF=false;local pG=0;local pH=0;local pI=0;local pJ=bM()local pK=0;local pL=0;local pM=0;local pN=0;local pO=false;local pP=false;local pQ=false;local pR=nil;local pS=0;local i_=55;local pT=nil;local pU=false;local pV=false;local pW=false;local pX=0;local pY=0;local pZ=0;local p_=0;local q0=0;local q1={VectorToTarget=false}local q2=vec3(bP.getWorldOrientationUp())local q3=nil;local q4=0;local q5=-1;local q6=-1;local q7=false;local q8=false;local q9=0;local qa=false;local qb=false;local qc=false;local qd=false;local qe=""local qf=false;local qg=false;local qh=""local qi=false;local qj=0;local function qk()return bP.isInPvPZone()~=1,eZ(bP.getDistanceToSafeZone())end;local function ql(fp)local qm=bg;if not b4 then qm=0 end;local qn=bt;if cg then if bv and bv>0 then qn=bv else return 0,0 end end;return cp.computeDistanceAndTime(fp,qm,cj,0,0,qn-bi*cj)end;local function qo(fp)local qm=bg;if not b4 then qm=0 end;return cp.computeDistanceAndTime(fp,qm,cj,d:maxForceForward(),a3,bt-bi*cj)end;local function qp(qq,qr,qs)qr=qr:project_on_plane(qq)qs=qs:project_on_plane(qq)return eU(qr:cross(qs):dot(qq),qr:dot(qs))end;local function qt()local function qu()local qv=-1;local qw=-1;if vBooster then qv=vBooster.getDistance()end;if hover then qw=hover.getDistance()end;if qv~=-1 and qw~=-1 then if qv<qw then return qv else return qw end elseif qv~=-1 then return qv elseif qw~=-1 then return qw else return-1 end end;local qx=qu()local qy=-1;if antigrav and antigrav.isActive()==1 and not q and cL<i_ then local qz=eZ(ci-antigrav.getBaseAltitude())if qz<50 then return qz end end;if pC then qy=pC.raycast().distance end;if qx~=-1 and qy~=-1 then if qx<qy then return qx else return qy end elseif qx~=-1 then return qx else return qy end end;local function qA(kC,eL,qB)local function qC(qD,dX)local eR=vec3(dX)if qD.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=qD.systemId},dZ)end;local eS=eR-qD.center;local cb=eS:len()local e3=cb-qD.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=math.deg(e1),longitude=math.deg(e2),altitude=e3,id=qD.id,systemId=qD.systemId},dZ)end;local qE=qC(kC,eL)qE="::pos{"..qE.systemId..","..qE.id..","..qE.latitude..","..qE.longitude..","..qE.altitude.."}"if qB then return qE else qc=qE;return true end end;local function qF(qG,qH,qI)local function qJ(qG,eu)qG=vec3(qG)eu=vec3(eu):normalize()local dG=qG*eu;return dG.x+dG.y+dG.z end;local qK=0.001;local qL=1;if not cg or not cA or cf~=-1 or cL<i_ then if qI==nil then qI=aT end;if qH==nil then qH=qK end;qG=vec3(qG):normalize()local qM=vec3()-qG;local qN=-qJ(qM,bP.getWorldOrientationRight())*qL;local qO=-qJ(qM,bP.getWorldOrientationUp())*qL;if pH==0 then pH=qN/2 end;if pI==0 then pI=qO/2 end;if eZ(qN)<0.1 then pY=pY-qN*2 else pY=pY-(qN+(qN-pH)*qI)end;if eZ(qO)<0.1 then pX=pX+qO*2 else pX=pX+qO+(qO-pI)*qI end;pH=qN;pI=qO;if eZ(qN)<qH and eZ(qO)<qH then return true end;return false elseif cA and cf==-1 then qG=cK;if qI==nil then qI=aT end;if qH==nil then qH=qK end;qG=vec3(qG):normalize()local qM=cH-qG;local qN=-qJ(qM,bP.getWorldOrientationRight())*qL;local qO=-qJ(qM,bP.getWorldOrientationUp())*qL;if pH==0 then pH=qN/2 end;if pI==0 then pI=qO/2 end;if eZ(qN)<0.1 then pY=pY-qN*5 else pY=pY-(qN+(qN-pH)*qI)end;if eZ(qO)<0.1 then pX=pX+qO*5 else pX=pX+qO+(qO-pI)*qI end;pH=qN;pI=qO;if eZ(qN)<qH and eZ(qO)<qH then return true end;return false end end;function pE.clearAll()bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"b2=false;b3=false;cX=nil;b6=false;b9=false;b7=false;b8=false;ba=false;c0=false;pV=false;cc=false;cd=false;pW=false;cz=p;br=false;b5=false;ck=false;bu=nil;bA=false;db=false;dc=nil end;function pE.GetAutopilotBrakeDistanceAndTime(fp)return ql(fp)end;function pE.GetAutopilotTBBrakeDistanceAndTime(fp)return qo(fp)end;function pE.showWayPoint(kC,eL,qB)return qA(kC,eL,qB)end;function pE.APTick()local qP=a.getMouseWheel()if qP>0 then ct.changeSpd()elseif qP<0 then ct.changeSpd(true)else pU=true end;q9=iI()if qc then a.setWaypoint(qc)qc=false end;if qf then antigrav.setTargetAltitude(qf)qf=false end;if qd then fS(qd,qe)qd=false;qe=""end;if q6~=-1 then ct.cmdCruise(q6,q7)q7=false;q6=-1 end;if q3~=nil then if iH:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iH:getTargetSpeed(axisCommandId.longitudinal)~=q3 then iH:setTargetSpeedCommand(axisCommandId.longitudinal,q3)else q3=nil end end;if q5~=-1 then ct.cmdThrottle(q5,q7)q7=false;q5=-1 end;if q8 then cv.landingGear(q8)q8=false end;if qg then ct.ToggleAutopilot()end end;function pE.ToggleIntoOrbit()cE=false;pM=nil;pN=nil;pS=0;if not cg then if bA then fU("orOff","AP")bA=false;pO=false;pR=nil;cz=p;if b6 then b6=false;b8=false end;q1.VectorToTarget=false;q1.AutopilotAlign=false;pQ=false elseif cY then fU("orOn","AP")bA=true;cz=true;if pR==nil then pR=kC end;if b6 then b6=false;b8=false end else c3="Unable to engage auto-orbit, not near a planet"end else bA=false;pO=false;pR=nil;cz=p;if b6 then b6=false end;q1.VectorToTarget=false;q1.AutopilotAlign=false;pQ=false end end;function pE.ToggleVerticalTakeoff()b6=false;if ba then ls=true;b9=false;b8=false;b7=true;cz=true;b_=0;if cg and cf==-1 then b7=false;b6=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q6=bN(cB)end else cE=false;bn=false;d.control.retractLandingGears()iH:setTargetGroundAltitude(_)b1="VTO Takeoff"end;ba=not ba end;function pE.checkLOS(qG)local lu,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,qG,function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local lv=eJ;if eK~=nil and eJ~=nil then lv=math.min(eK,eJ)end;if lv~=nil then return lu,lv else return nil,nil end end;local function qQ(qR,qS)if qS then b_=0;iH:updateCommandFromActionStop(axisCommandId.vertical,qS)if bC then iH:activateGroundEngineAltitudeStabilization(qT)de=true end else b_=b_+qR;iH:deactivateGroundEngineAltitudeStabilization()iH:updateCommandFromActionStart(axisCommandId.vertical,qR)end end;function pE.vertical(qR,qS)qQ(qR,qS)end;function pE.ToggleAutopilot()local function qU(by)cZ=false;br=not br;if br then b5=false;if not b6 and not by then ct.ToggleAltitudeHold()end end;ly="Proceeding to Waypoint"end;local function qV(gy)if gy then for M,dL in pairs(cU)do if dL.name and dL.name==gy then return M end end else return 0 end end;local qW=false;bI=false;if bQ-pL<1.5 and cg then if not cG then if cg then bb=kC.spaceEngineMinAltitude-0.01*kC.noAtmosphericDensityAltitude;fU("11","EP")pL=-1;if b4 or br or bA then return end else c3="No space engines detected, Orbital Hop not supported"return end elseif kC.hasAtmosphere then if cg then bb=kC.noAtmosphericDensityAltitude+W;fU("orH","OH")end;pL=-1;if b4 or br or bA then return end end else pL=bQ end;qX=false;if(bm>0 or#bG>0)and not b4 and not br and not cd and not bA then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then c3="WARNING: Heavy Loads may affect autopilot performance."c4=5 end;if#bG>0 and not ce then bm=qV(bG[1])cs.UpdateAutopilotTarget()c3="Route Autopilot in Progress"local qM=g5.position-cO;local qY=qM:project_on_plane(cM):len()if qY>50000 and g5.planetname==kC.name then qW=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c8,bl)if g5~=nil then if g5.agg and not q and antigrav then if not cQ then ct.ToggleAntigrav()end;bw=g5.agg end;bu=nil;by=g5.planetname=="Space"if by then fU("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end elseif kC.name==g5.planetname then ls=true;if cg then if not br then fU("vtt","AP")qU(by)if qW then bb=kC.noAtmosphericDensityAltitude+W end end else fU("apOn","AP")if not(c8.name==kC.name and ci<gp*1.5)then cE=false;b4=true elseif not cg then if bA then ct.ToggleIntoOrbit()end;cD=kC.noAtmosphericDensityAltitude+W;pQ=true;q1.AutopilotAlign=true;q1.VectorToTarget=true;pO=false;if not bA then ct.ToggleIntoOrbit()end end end else fU("apP","AP")b2=false;b3=false;if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end end elseif not cg then if g5==nil and(c8.name==kC.name and cY)and not bA then qZ=false;cE=false;pO=false;ct.ToggleIntoOrbit()else fU("apP","AP")b4=true;b2=false;b3=false;bd=false;c0=false;b6=false;b7=false;b9=false;b8=false;pV=false;bu=nil;qZ=false end else fU("apP","AP")cd=true;ct.ToggleAltitudeHold()end;qg=false else fU("apOff","AP")ct.ResetAutopilots(1)if qg==2 then qg=true end end end;function pE.routeWP(q_,r0,r1)if r1 then if r1==1 then bG={}bG=iJ(bG,bF)if#bG>0 then c3="Route Loaded"else c3="No Saved Route found on Databank"end;return bG else bF={}bF=iJ(bF,bG)c3="Route Saved"pD()return end end;if q_ then return bG end;if r0 then bG={}c3="Current Route Cleared"else bG[#bG+1]=g5.name;c3="Added "..g5.name.." to route. "end;return bG end;function pE.cmdThrottle(dM,r2)if iH:getAxisCommandType(0)~=axisCommandType.byThrottle and not r2 then d.control.cancelCurrentControlMasterMode()end;iH:setThrottleCommand(axisCommandId.longitudinal,dM)bR=dl(fV(dM*100,0)/100,-1,1)q3=nil end;function pE.cmdCruise(dM,r2)if iH:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r2 then d.control.cancelCurrentControlMasterMode()end;iH:setTargetSpeedCommand(axisCommandId.longitudinal,dM)q3=dM end;function pE.ToggleLockPitch()if bu==nil then fU("lkPOn","LP")if not c1 then bu=cS else bu=T end;b8=false;b6=false;b7=false else fU("lkPOff","LP")bu=nil end end;function pE.ToggleAltitudeHold()if bQ-pK<1.5 then bI=false;if kC.hasAtmosphere then if cg then bb=kC.spaceEngineMinAltitude-0.01*kC.noAtmosphericDensityAltitude;fU("11","EP")else if cY then bb=kC.noAtmosphericDensityAltitude+W;cD=bb;pQ=true;if not bA then ct.ToggleIntoOrbit()end;pO=true end end;pK=-1;if b6 or bA or ba then return end end else pK=bQ end;if cY and not cg and cf==-1 then cD=ci;pQ=true;pO=true;ct.ToggleIntoOrbit()if bA then pK=bQ else pK=0 end;return end;b6=not b6;b7=false;b9=false;if b6 then b4=false;b3=false;b2=false;c0=false;cz=true;bu=nil;cE=false;if cf~=-1 then if not bn and not br then bb=ci;bI=cf;iH:setTargetGroundAltitude(bI)elseif cL<20 then if bn then cv.landingGear()end;fU("lfs","LS")b8=true;if cg then bb=ci+Z else bb=kC.surfaceMaxAltitude+100 end;b1="ATO Hold"iH:setTargetGroundAltitude(_)if b0 and cP then ct.ToggleVerticalTakeoff()end end else fU("altOn","AH")b8=false;if pK>-1 then if cY then bb=ci end end;if ba then ct.ToggleVerticalTakeoff()end end;if cQ and not q then local r3=antigrav.getBaseAltitude()if br and g5.agg and g5.agg>ci then bb=g5.agg elseif b8 then bb=r3 end;if eZ(ci-r3)<100 and cL<20 then bb=r3;b1="AGG Hold"q5=0 end end;if cd then bb=200000 end else fU("altOff","AH")if bA then ct.ToggleIntoOrbit()end;if ba then ct.ToggleVerticalTakeoff()end;cz=p;b8=false;br=false;pK=0;bI=false end end;function pE.ResetAutopilots(pE)if pE then cd=false;b4=false;bd=false;pV=false;bb=ci;qX=false;db=false;bh="Aligning"end;br=false;b8=false;b9=false;b3=false;b7=false;dc=nil;r4=false;cX=nil;db=false;if not cQ then b6=false;bu=nil end;if ba then ct.ToggleVerticalTakeoff()end;if bA then ct.ToggleIntoOrbit()end;cz=p;cc=false;ce=false;b_=0 end;function pE.BrakeToggle(r5)if not b1 then if r5 then b1=r5 else b1=true end else b1=false end;if b7 then b7=false;cz=p;db=false end;if b1 then fU("bkOn","B",1)ct.ResetAutopilots()else fU("bkOff","B",1)end end;function pE.BeginReentry()if b9 then c3="Re-Entry cancelled"fU("reOff","RE")b9=false;cz=p;b6=false elseif not kC.hasAtmosphere then c3="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c4=5 elseif not pW then b9=true;if iH:getAxisCommandType(0)~=r6.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b1=false;c3="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB;fU("par","RE")else b9=true;b6=true;cz=true;b1=false;bb=kC.surfaceMaxAltitude+a1;if bb>kC.spaceEngineMinAltitude then bb=kC.spaceEngineMinAltitude-0.01*kC.noAtmosphericDensityAltitude end;local r7=iL(bb)c3="Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..r7;fU("glide","RE")q6=bN(cB)end;b8=false end;function pE.ToggleAntigrav()if antigrav and not q then if cQ then fU("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bw==nil then bw=ci end;if bw<1000 then bw=1000 end;fU("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pE.changeSpd(r8)local r9=1;if r8 then r9=-1 end;if not c1 then if t and not p5 and pU then local ra=bR;bR=fV(dl(bR+r9*aF/100,-1,1),2)if bR>=0 and ra<0 then bR=0;pU=false end elseif p5 then if cg or b9 then cB=dl(cB+r9*aF,0,X)elseif b4 then ac=dl(ac+r9*aF/3.6*100,0,df-0.2)end else iH:updateCommandFromActionStart(axisCommandId.longitudinal,r9*aF/10)end else if b4 or br or cd or bA then d1=d1+1*r9*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not r8 then r9=1 else r9=nil end;cs.adjustAutopilotTargetIndex(r9)end end end;function pE.TenthTick()local function rb()if not b4 then if g5==nil or g5.planetname~=kC.name then rc=(c8.center-cO):len()else rc=(g5.position-cO):len()end end;local fp=cL;local rd=c.getThrottle()/100;if t then rd=bR end;local re,rf=cp.computeDistanceAndTime(cL,ac,cj,d:maxForceForward()*rd,a3,0)local c6,c7;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(ac)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(ac)end;local dQ,rg;if not b5 and fp>0 then dQ,rg=ct.GetAutopilotBrakeDistanceAndTime(fp)else dQ,rg=ct.GetAutopilotTBBrakeDistanceAndTime(fp)end;local rh=0;local ri=0;if bf or not b4 and fp>5 then ri=cp.computeTravelTime(fp,0,rc)elseif c6+re<rc then rh=rc-(c6+re)ri=cp.computeTravelTime(8333.0556,0,rh)else local rj=(rc-c6)/re;re=rc-c6;rf=rf*rj end;if g5~=nil and g5.planetname==kC.name and not b4 then return ri elseif be then return rg elseif bf then return ri+rg else return rf+c7+ri end end;local function rk(of,rl)if of==nil then of=b.getGravityIntensity()end;of=fV(of,5)if rl~=nil and rl or(pT==nil or pT~=of)then local fp=cJ:len()local rm=iE(c.getWidgetData()).maxBrake;if rm~=nil and rm>0 and cg then rm=rm/dl(fp/100,0.1,1)rm=rm/ch;if ch>0.10 then if bv then bv=(bv+rm)/2 else bv=rm end end end;if rm~=nil and rm>0 then bt=rm end;pT=of end end;cV,cW=qk()df=bP.getMaxSpeed()if bk~="None"and(c8 or g5)then lw=rb()end;rk(nil,true)end;function pE.SatNavTick()if not r then return end;qh=dbHud_1.getStringValue("SPBAutopilotTargetName")if qh~=nil and qh~=""and qh~="SatNavNotChanged"then local dG=iE(dbHud_1.getStringValue("SavedLocations"))if dG~=nil then bq=dG;local gw=-1;local gC;for dL,dx in pairs(bq)do if dx.name and dx.name=="SatNav Location"then gw=dL;break end end;if gw~=-1 then gC=bq[gw]gw=-1;for dL,dx in pairs(e[0])do if dx.name and dx.name=="SatNav Location"then gw=dL;break end end;if gw>-1 then e[0][gw]=gC end;cs.UpdateAtlasLocationsList()c3=gC.name.." position updated"end end;for M=1,#cU do if cU[M].name==qh then bm=M;a.print("Index = "..bm.." "..cU[M].name)cs.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;local function rn(ro,rp)local rq=vec3()local rr=vec3()if ro==axisCommandId.longitudinal then rq=vec3(bP.getOrientationForward())rr=cH elseif ro==axisCommandId.vertical then rq=vec3(bP.getOrientationUp())rr=q2 elseif ro==axisCommandId.lateral then rq=vec3(bP.getOrientationRight())rr=cI else return vec3()end;local rs=vec3(b.getWorldGravity())local rt=rs:dot(rr)local ru=vec3(bP.getWorldAirFrictionAcceleration())local rv=ru:dot(rr)local rw=cJ:dot(rq)local rx=rp*constants.kph2m;if ry==nil then ry=pid.new(10,0,10.0)end;ry:inject(rx-rw)local rz=ry:get()local rA=(rz-rv-rt)*rr;return rA end;local function rB(ro,rp)local rq=vec3()local rr=vec3()if ro==axisCommandId.longitudinal then rq=vec3(bP.getOrientationForward())rr=cH elseif ro==axisCommandId.vertical then rq=vec3(bP.getOrientationUp())rr=q2 elseif ro==axisCommandId.lateral then rq=vec3(bP.getOrientationRight())rr=cI else return vec3()end;local rs=vec3(b.getWorldGravity())local rt=rs:dot(rr)local ru=vec3(bP.getWorldAirFrictionAcceleration())local rv=ru:dot(rr)local rw=cJ:dot(rq)local rx=rp*constants.kph2m;if rC==nil then rC=pid.new(10,0,10.0)end;rC:inject(rx-rw)local rz=rC:get()local rA=(rz-rv-rt)*rr;return rA end;local function rD(rE,k2,g1)local rF=rE:cross(g1):normalize_inplace()local kP=math.acos(dl(rF:dot(-k2),-1,1))*constants.rad2deg;if rF:cross(-k2):dot(g1)<0 then kP=-kP end;return kP end;local function rG()if c_ and not b7 then local es=c_[1]local i4,i5=c_[2],c_[3]local rH=math.min(i4,i5 or i4)local rI=rH/cL;local rJ=b8 and(cL<42 or cf~=-1)local rK=b6 or br or bu or b4;if rK and not rJ and(c6*1.5>rH or rI<1)then b1="Collision"bG={}q5=0;if b6 then ct.ToggleAltitudeHold()end;if bu then ct.ToggleLockPitch()end;c3="Autopilot Cancelled due to possible collision"a.print(es.name.." COLLISION "..iM(rI).." / "..iL(rH,2))ct.ResetAutopilots(1)ls=true;if cg then b7=true end;cz=true end;if rI<11 then cZ=es.name.." COLLISION "..iM(rI).." / "..iL(rH,2)else cZ=es.name.." collision "..iM(rI)end;if rI<6 then fU("alarm","AL",2)end else cZ=false end end;local rL=1;local rM=0;local rN=1;local rO=1;local rP=1;local rQ=false;function pE.onFlush()if antigrav and not q and not cQ and antigrav.getBaseAltitude()~=bw then qf=bw end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iH:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local rR=dl(bX+pX+a.getControlDeviceForwardInput(),-1,1)local rS=dl(bY+pZ+a.getControlDeviceYawInput(),-1,1)local rT=dl(bZ+pY-a.getControlDeviceLeftRightInput(),-1,1)local rU=b1 and 1 or 0;cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(kC.center-cO):normalize()end;q2=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local rV=cT/180*math.pi;local rW=math.cos(rV)local rX=math.sin(rV)cS=rD(cM,cH,cI*rW+q2*rX)local rY=cK:normalize()local rZ=eZ(cT)local r_=utils.sign(cT)local s0=vec3(bP.getWorldAngularVelocity())local s1=rR*aP*cI+rS*aK*cH+rT*aQ*q2;if cz==true and cM:len()>0.01 then local s2=eZ(p_-cT)if((b3 or b9 or b7 or cc or b6 or bA)and s2>0 or cg and s2<aL and p)and rS==0 and eZ(cS)<85 then local s3=p_;local s4=aJ;if not cg then s4=s4/4;p_=0;s3=0 end;if s5==nil then s5=pid.new(s4*0.01,0,s4*0.1)end;s5:inject(s3-cT)local s6=s5:get()s1=s1+s6*cH end end;bS=0;ch=bO()cg=false or ci<kC.noAtmosphericDensityAltitude and ch>0.00001;ci=b.getAltitude()cf=qt()bQ=bM()pJ=bQ;if bn and cf>-1 and cf-3<a0 then if iH.targetGroundAltitudeActivated then iH:deactivateGroundEngineAltitudeStabilization()end end;if cu then qi=not qi;if qi then cu.UpdateRadar()end;if E then rG()end end;if antigrav then cQ=antigrav.isActive()==1 end;local s7=bQ-pJ;local s8=-math.deg(qp(q2,cK,cH))local s9=math.deg(qp(cI,cK,cH))local gr=cM*-1;cA=cg and s8<-O or s8>O or s9<-P or s9>P;local sa=a.getMouseDeltaX()local sb=a.getMouseDeltaY()if qj then local sc=bM()-qj;sa=sa*sc/0.016;sb=sb*sc/0.016 end;qj=bM()if o and not c1 then sb=-sb end;pY=0;pZ=0;pX=0;local sd=bP.getWorldPosition()kC=fY:closestBody(sd)se=cq(kC)ft=se:orbitalParameters(sd,cK)if ci==0 then ci=(cO-kC.center):len()-kC.radius end;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local of=kC:getGravity(sd):len()*cj;p_=0;local sf=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if q9==0 then if iG()==1 and c1 then if not cx then c9=dl(c9+sa/2,-ad/2,ad/2)ca=dl(ca+sb/2,-ae/2,ae/2)end else c9=0;ca=0 end else c9=dl(c9+sa/2,-ad/2,ad/2)ca=dl(ca+sb/2,-ae/2,ae/2)dd=dn(c9*c9+ca*ca)if not c1 and iG()==0 then local kY,kZ=1,1;if bK=="SCOPE"then kY,kZ=d5/90,d5/90 end;if g=="virtual joystick"then if dd>aA then pY=pY-dl(eZ(c9)-aA,0,ad/2)*utils.sign(c9)*aH*kY;pX=pX-dl(eZ(ca)-aA,0,ae/2)*utils.sign(ca)*aI*kZ end else c9=0;ca=0;if g=="mouse"then pX=(-utils.smoothstep(sb,-100,100)+0.5)*2*rO;pY=(-utils.smoothstep(sa,-100,100)+0.5)*2*rP end end end end;local sg=cL>27777;if cL>Y/3.6 and not cg and not b4 and not sg then c3="Space Speed Engine Shutoff reached"q5=0 end;if not sg and sh then if not b1 then ct.BrakeToggle()end;if b4 then ct.ResetAutopilots(1)end;q5=0 end;sh=sg;if ch>0.09 then if cL>cB/3.6 and not t and not pF then b1="SpdLmt"pF=true elseif not t and pF then if cL<cB/3.6 then b1=false;pF=false end end end;if b3 then if cc then b1=false;local si=false;if g5 and cc==true then si=qF(g5.position-cO,0.1)else si=qF(vec3(cK),0.01)end;cz=true;if si then q6=bN(cB)if(eZ(cT)<2 or eZ(cS)>85)and cL>=cB/3.6-1 then b1=false;b3=false;if cc~=2 then pW=true end;if cc==true then ce=true end;cc=false;b4=false;ct.BeginReentry()end elseif cg and t then q5=1 end elseif cL>i_ then qF(vec3(cK),0.01)end end;if b2 then if cg then b2=false elseif cL>i_ then qF(-vec3(cK))end end;if not b3 and cc and not bA then if not cg then if cc~=2 then pW=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not qg then qg=true end end end;if ce and g5 and(ci<bb+250 and ci>bb-250)and cL*3.6>cB-250 and eZ(cN)<25 and ch>=0.1 and(g5.position-cO):len()>2000+ci then if not qg then qg=true end;ce=false end;if ba then cz=true;local sj=bb;if cN<-30 then c3="Unable to achieve lift. Safety Landing."b_=0;cz=p;ba=false;b7=true elseif not q and cQ or bb<kC.spaceEngineMinAltitude then if cQ then sj=antigrav.getBaseAltitude()end;if ci<sj-100 then q0=0;b_=15;b1=false elseif cN>0 then b1="VTO Limit"b_=0 elseif cN<-30 then b1="VTO Fall"b_=15 elseif ci>=sj then if cQ then if b4 or br then ct.ToggleVerticalTakeoff()else b1="VTO Complete"ba=false end;c3="Takeoff complete. Singularity engaged"fU("aggLk","AG")else b1=false;c3="VTO complete. Engaging Horizontal Flight"fU("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then q0=0;b1=false;b_=20 elseif ch<0.08 and cg then b1=false;if cF then q0=0;b_=20 else b_=0;q0=36;q6=3500 end else cz=p;bA=true;cE=false;sk=false;pO=false;pM=nil;pN=nil;if pR==nil then pR=kC end;cD=sj;pQ=true;ba=false end end;if q0~=nil then if sl==nil then sl=pid.new(2*0.01,0,2*0.1)end;local sm=dl(q0-cS,-P*0.80,P*0.80)sl:inject(sm)local sn=dl(sl:get(),-1,1)pX=sn end end;if bA then local function so()if ft.periapsis.altitude>=cD*0.99 and ft.apoapsis.altitude>=cD*0.99 and ft.periapsis.altitude<ft.apoapsis.altitude and ft.periapsis.altitude*1.05>=ft.apoapsis.altitude and eZ(cD-ci)<1000 then return true else return false end end;local qM;local sp=false;local sq=iL(cD,3)if pR==nil then pR=kC;if br then pR=c8 end end;if not pQ then cD=bN(pR.radius+pR.surfaceMaxAltitude+W)if pR.hasAtmosphere then cD=bN(pR.radius+pR.noAtmosphericDensityAltitude+W)end;pQ=true end;if q1.VectorToTarget and g5 then qM=g5.position-cO end;local sr,ss=cq(pR):escapeAndOrbitalSpeed((cO-pR.center):len()-pR.radius)local st=cT;if not pO then local su=false;local sv=false;q5=0;pN=0;cC="Aligning to orbital path - OrbitHeight: "..sq;if q1.VectorToTarget then qF(qM:normalize():project_on_plane(cM))sp=cH:dot(qM:project_on_plane(q2):normalize())>0.95 else qF(cK)sp=s8<0.5;if cL<150 then sp=true end end;pX=0;pM=0;if cS<=pM+2 and cS>=pM-2 then su=true else su=false end;if st<=pN+2 and st>=pN-2 then sv=true else sv=false end;if su and sv and sp then pM=nil;pN=nil;pO=true end else if q1.VectorToTarget then qF(qM:normalize():project_on_plane(cM))elseif cL>150 then qF(cK)end;pX=0;if q1.VectorToTarget and g5 then local c6,dQ=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bt)if cE and qM:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pR.noAtmosphericDensityAltitude or lw>ft.timeToPeriapsis and ft.periapsis.altitude<pR.noAtmosphericDensityAltitude or not so()and ft.eccentricity>0.1 then c3="Re-Aligning Orbit"cE=false end elseif cE or qM:len()<15000+c6+ci then c3="Orbit complete, proceeding with reentry"fU("orCom","OB")bl=g5.position;pW=true;ce=true;q1.VectorToTarget,q1.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if ft.periapsis~=nil and ft.apoapsis~=nil and ft.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if ft.apoapsis~=nil then if(so()or cE)and not N then if cE then b1=false;q5=0;pM=0;if not q1.VectorToTarget then c3="Orbit complete"fU("orCom","OB")ct.ToggleIntoOrbit()end else pS=pS+1;if pS>=2 then cE=true end end else if so()then cC="Maintaining "else cC="Adjusting "pP=true;q6=ss*3.6+1;local sw=cD-ci;if sx==nil then sx=pid.new(0.1,0,1*0.1)end;sx:inject(sw-cN*dl(utils.smoothstep(2000-sw,-2000,2000)^6*10,1,10))pM=dl(sx:get(),-60,60)end;cC=cC.." - OrbitHeight: "..sq end end else local sy=2.75;local sz=eZ(fV(sr*sy))local ou=sz%50;if ou>0 then sz=sz-ou+50 end;b1=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sq;pM=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sq;sz=sz*0.75;pM=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sq;sz=sz*0.75;if cN<0 or pP then pM=utils.map(ci,cD*1.5,cD*1.01,-30,0)else pM=utils.map(ci,cD*0.99,cD*1.5,0,30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sq;pM=-65;local sA=utils.map(cN,-150,-400,1,0.55)sz=sz*sA end;q6=bN(sz)end end;if pM~=nil then if sB==nil then sB=pid.new(1*0.01,0,5*0.1)end;local sC=pM-cS;sB:inject(sC)local sD=dl(sB:get(),-0.5,0.5)pX=sD end end;if b4 and not cg and not cc then local function sE(di,ft)a.print(di)b1=false;be=false;b4=false;qX=false;bh="Aligning"q5=0;pV=false;c3=di;fU("apCom","AP")if ft or cc then if ft and gp~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pQ=true end;ct.ToggleIntoOrbit()end end;local sF,sG=bl,false;if g5 and g5.planetname~="Space"then bd=true;if not qX then local sH=(g5.position-c8.center):normalize()local sI=sH:project_on_plane((c8.center-cO):normalize()):normalize()local sJ=c8.center+sI*(c8.radius+gp)local sK=g5.position+(g5.position-c8.center):normalize()*(gp-c8:getAltitude(g5.position))if(cO-sJ):len()<(cO-sK):len()then sF=sJ else sF=sK;bg=0 end;bl=sF;ct.showWayPoint(c8,bl)sG=true;qX=true end;bi=0 elseif g5 and g5.planetname=="Space"then if not qX then bi=0;sG=true;bd=true;qX=true;sF=g5.position+(cO-g5.position):normalize()*U;bl=sF end elseif g5==nil then bi=0;if not qX then local sH=(cO+cK*100000-c8.center):normalize()local sI=sH:project_on_plane((c8.center-cO):normalize()):normalize()if sI:len()<1 then sH=(cO+cH*100000-c8.center):normalize()sI=sH:project_on_plane((c8.center-cO):normalize()):normalize()end;sF=c8.center+sI*(c8.radius+gp)bl=sF;qX=true;sG=true;bd=true;ct.showWayPoint(c8,bl)end end;rc=(vec3(sF)-cO):len()local lu,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local lv=eJ;if eK~=nil and eJ~=nil then lv=math.min(eK,eJ)end;if lv~=nil and lv<rc and lu.name==c8.name then rc=lv end;local si=true;local sL=(c8.center-(cO+vec3(cK):normalize()*rc)):len()-c8.radius;local lq=iL(sL)qd=gh;qe='{"label": "Projected Altitude", "value": "'..lq..'"}'if cL>50 and bc then local qM=vec3(sF)-cO;local sM=dl(math.deg(qp(q2,cK:normalize(),qM:normalize()))*cL/500,-90,90)local sN=dl(math.deg(qp(cI,cK:normalize(),qM:normalize()))*cL/500,-90,90)if eZ(sM)<20 and eZ(sN)<20 then sM=sM*2;sN=sN*2 end;if eZ(sM)<2 and eZ(sN)<2 then sM=sM*2;sN=sN*2 end;local s8=-math.deg(qp(q2,cH,cK:normalize()))local s9=-math.deg(qp(cI,cH,cK:normalize()))if sO==nil then sO=pid.new(2*0.01,0,2*0.1)end;sO:inject(sN-s9)local sP=dl(sO:get(),-1,1)pX=pX+sP;if sQ==nil then sQ=pid.new(2*0.01,0,2*0.1)end;sQ:inject(sM-s8)local sR=dl(sQ:get(),-1,1)pY=pY+sR;sG=true;if eZ(sM)>2 or eZ(sN)>2 then if bh~="Adjusting Trajectory"then bh="Adjusting Trajectory"fU("apAdj","AP")end else if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end end elseif bc and cL<=50 then qF((sF-cO):normalize())end;if sL<gp*1.5 then bg=cB/3.6;if g5==nil then dQ,bg=cq(c8):escapeAndOrbitalSpeed(sL)end end;local c6,c7;if not b5 then c6,c7=ql(cL)else c6,c7=qo(cL)end;if b4 and not bc and not bf and not be then local lu,lv=ct.checkLOS((bl-cO):normalize())if c8.name~=kC.name then if lu~=nil and c8.name~=lu.name and lv<rc then c3="Collision with "..lu.name.." in "..iL(lv).."\nClear LOS to continue."c4=5;qa=true else qa=false;c3=""end end end;if not qa then if not bf and not be and not sG then si=qF((sF-cO):normalize())elseif b5 and(be or bf)then si=qF(-vec3(cK):normalize())end end;if bc then if not pV then b1=false;q5=a2;bR=fV(a2,2)pV=true end;local rd=c.getThrottle()if t then rd=bR end;local sS=99999;local os=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local sT=dl(cK:dot((sF-cO):normalize()),0,cL)if sT>0 or os>0 then sS=cp.computeTravelTime(sT,os,rc-c6)end;if ac>df then ac=df-0.2 end;if cJ:len()>=ac or rd==0 and pV or a3/4>sS then bc=false;if bh~="Cruising"then fU("apCru","AP")bh="Cruising"end;bf=true;q5=0 end;local sU=rc;if sU<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pG and cW>2000 then ct.ResetAutopilots(1)c3="Autopilot cancelled to prevent crossing PvP Line"b1="PvP Prevent"pG=cW else pG=cW;return end end;bc=false;if bh~="Braking"then fU("apBrk","AP")bh="Braking"end;be=true;q5=0;pV=false end elseif be then if bh~="Orbiting to Target"then b1="AP Brk"end;if b5 then q5=1;q7=true end;local dQ,ss=cq(c8):escapeAndOrbitalSpeed((cO-kC.center):len()-kC.radius)local qM;if g5 then qM=g5.position-cO end;if g5 and g5.planetname=="Space"and cL<50 then if#bG>0 then if not qg then table.remove(bG,1)end;if#bG>0 then b1=false;if not qg then qg=2 end;return end end;sE("Autopilot complete, arrived at space location")b1="Space Arrival"elseif g5 and g5.planetname~="Space"and cL<=ss and(ft.apoapsis==nil or ft.periapsis==nil or ft.apoapsis.altitude<=0 or ft.periapsis.altitude<=0)then sE("Autopilot complete, commencing reentry")bl=g5.position;cc=true;ct.showWayPoint(c8,bl)elseif(g5 and g5.planetname~="Space"or g5==nil)and ft.periapsis~=nil and ft.periapsis.altitude>0 and ft.eccentricity<1 or bh=="Circularizing"then if bh~="Circularizing"then fU("apCir","AP")bh="Circularizing"end;if cL<=ss then if g5 then if cK:normalize():dot(qM:normalize())>0.4 then if bh~="Orbiting to Target"then fU("apOrb","OB")bh="Orbiting to Target"end;if not qZ then b1=false;ct.showWayPoint(c8,g5.position)qZ=true end else sE("Autopilot complete, proceeding with reentry")bl=g5.position;cc=true;ct.showWayPoint(c8,g5.position)qZ=false end else sE("Autopilot completed, setting orbit",true)b1=false end end elseif bh=="Circularizing"then sE("Autopilot complete, fixing Orbit",true)end elseif bf then local sU=rc;if sU<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pG and cW>2000 then if not qg then qg=true end;c3="Autopilot cancelled to prevent crossing PvP Line"b1="Prevent PvP"pG=cW else pG=cW;return end end;bc=false;if bh~="Braking"then fU("apBrk","AP")bh="Braking"end;be=true end;local rd=c.getThrottle()if t then rd=bR end;if rd>0 then bc=true;if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end;bf=false end else if si then if not bd and g5==nil or not bd and g5 and g5.planetname~="Space"then if not cc then bl=vec3(c8.center)+(gp+c8.radius)*cI;sV=q2;sW=cI end;bd=true elseif si and not qa then bc=true;if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end;if not pV then q5=a2;q7=true;bR=fV(a2,2)pV=true;b1=false end end end end elseif b4 and(g5~=nil and g5.planetname~="Space"and cg)then c3="Autopilot complete, starting reentry"fU("apCom","AP")bl=g5.position;b1=false;be=false;b4=false;qX=false;bh="Aligning"q5=0;pV=false;b3=true;cc=true;ct.showWayPoint(c8,g5.position)end;if c0 then cz=true;local sN=0;local fv=vec3(DUPlayer.getWorldPosition())local sX=fv-cO;local sY=vec3(sX):project_on(cH):len()local sZ=vec3(sX):project_on(cI):len()local cb=dn(sY*sY+sZ*sZ)qF(sX:normalize())local mA=40;local s_=cb<mA;local t0=100;local rp=dl((cb-mA)/2,10,t0)pX=0;local si=eZ(pY)<0.1;if si and cL<rp and not s_ then b1=false;sN=-20 else b1="Follow"sN=0 end;local t1=0;if eZ(sN-cS)>t1 then if t2==nil then t2=pid.new(2*0.01,0,2*0.1)end;t2:inject(sN-cS)local sP=t2:get()pX=sP end end;if b6 or b7 or b9 or br or bu~=nil then if bI then if cf==-1 then bb=bb-0.2 else bb=ci+bI-cf end end;local t3=bv;if t3 then t3=t3*dl(cL/100,0.1,1)*ch else t3=bt end;if not cg then t3=bt end;q4=cH:project_on_plane(cM):normalize():dot(cK)if q4>100 then c6,c7=cp.computeDistanceAndTime(q4,100,cj,0,0,t3)local t4,t5=cp.computeDistanceAndTime(100,0,cj,0,0,t3*0.55)c6=c6+t4 else c6,c7=cp.computeDistanceAndTime(q4,0,cj,0,0,t3*0.55)end;local sw=bb-ci-cN;local t6=200+cL;if b9 or cc then t7=2000+cL end;local t8=1;if b8 then t8=dl(cL/100,0.1,1)end;local sN=(utils.smoothstep(sw,-t6,t6)-0.5)*2*R*t8;if not b9 and not cc and not br and cH:dot(cK:normalize())<0.99 then sN=(utils.smoothstep(sw,-t6*dl(20-19*ch*10,1,20),t6*dl(20-19*ch*10,1,20))-0.5)*2*R*dl(2-ch*10,1,2)*t8 end;if not b6 then sN=0 end;if bu~=nil then if cY and not bA then sN=bu else bu=nil end end;cz=true;local t9=pX;if b9 then local ta=bN(cB)local tb,tc=cp.computeDistanceAndTime(cL,ta/3.6,cj,0,0,bt-kC.gravity*9.8*cj)tb=tb==-1 and 5000 or tb;local qY=ci-(kC.noAtmosphericDensityAltitude+tb)local td=ci>kC.noAtmosphericDensityAltitude+tb*1.35;if td then sN=S;if cL<=ta/3.6 and cL>ta/3.6-10 and eZ(cK:normalize():dot(cH))>0.9 and not cR then bV=false;q5=1 end elseif(cR or iH:getTargetSpeed(axisCommandId.longitudinal)~=ta)and not td and not cg then q6=ta;q7=true end;if cR then if cL>ta/3.6 and not td then b1="Reentry Limit"if bR>0 then q5=0 end else b1=false end else b1=false end;if cN>0 then b1="Reentry vSpd"end;if not pW then sN=-80;if ci<kC.surfaceMaxAltitude+(kC.atmosphereThickness-kC.surfaceMaxAltitude)*0.25 then c3="PARACHUTE DEPLOYED at "..fV(ci,0)b9=false;b7=true;ls=true;q5=0;sN=0;cz=p end elseif kC.noAtmosphericDensityAltitude>0 and td then cz=true elseif not td then if not cg and(cR or iH:getTargetSpeed(axisCommandId.longitudinal)~=ta)then q6=ta end;if cL<ta/3.6+1 then b1=false;pW=false;b9=false;cz=true;q5=1 end end end;if cL>i_ and not cd and not br and not b7 and u then qF(vec3(cK))end;if cX or(br or cd)and bm>0 and cg then local qM;if cX then if type(cX)=="table"then qM=cX elseif cX<3 and cX>0 then qM=-cM:cross(cK)*5000 elseif cX>=3 then qM=cM:cross(cK)*5000 elseif cX<0 then qM=cK*25000 end elseif g5~=nil then qM=g5.position-cO else qM=c8.center-cO end;local sM=math.deg(qp(cM:normalize(),cK,qM))*2;local mD=math.rad(eZ(cT))if cL>aM and cg then local te=1000+cL;local tf=(utils.smoothstep(sw-cN*10,-te,te)-0.5)*2*R;local tg=dl(90-tf,0,180)p_=dl(sM*2,-tg,tg)local th=sM;sM=dl(dl(sM,-O*0.80,O*0.80)*math.cos(mD)+4*(cS-sN)*math.sin(math.rad(cT)),-O*0.80,O*0.80)local ti=1;if p_~=0 then ti=eZ(mD/p_)end;ti=(90-dl(eZ(p_-cT),0,90))/90;local tj=sN;if eZ(cT)>90 then tj=-tj end;sN=ti*dl(dl(tj*math.cos(mD),-P*0.8,P*0.8)+eZ(dl(eZ(th)*math.sin(mD),-P*0.80,P*0.80)),-P*0.80,P*0.80)else p_=0;sM=dl(sM,-O*0.80,O*0.80)end;local tk=s8-sM;if cX and eZ(tk)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and eZ(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fU("180Off","BR")return end;if not cA and cL>aM and cg then if tl==nil then tl=pid.new(2*0.01,0,2*0.1)end;tl:inject(tk)local sR=dl(tl:get(),-1,1)pY=pY+sR elseif cg and cf>-1 or cL<aM then qF(qM)elseif cA and cg then if(s8<-O or s8>O)and cg then qF(cK)end;if(s9<-P or s9>P)and cg then sN=dl(cS-s9,cS-P*0.80,cS+P*0.80)end end;if g5~=nil and not cd then local sj=kC:getAltitude(g5.position)local qY=qM:project_on_plane(cM):len()ls=true;if bb<kC.noAtmosphericDensityAltitude and not cd and not b8 and not b9 and(qY<=c6 and qM:len()<kC.radius)and(cK:project_on_plane(cM):normalize():dot(qM:project_on_plane(cM):normalize())>0.99 or ly=="Finalizing Approach")then ly="Finalizing Approach"if#bG>0 then if not qg then table.remove(bG,1)end;if#bG>0 then if not qg then qg=2 end;return end end;q5=0;if b6 then ct.ToggleAltitudeHold()br=true end;b1="AP Finalizing"elseif not b8 then b1=false end;if ly=="Finalizing Approach"and(q4<0.1 or qY<0.1 or tm~=nil and tm<qY)then fU("bklOn","BL")b7=true;db=true;if g5.heading then dc=g5.heading else dc=nil end;br=false;ly="Proceeding to Waypoint"cZ=false end;tm=qY end elseif br and not cg and bb>kC.noAtmosphericDensityAltitude and not(cd or b9)then if g5~=nil and c8.name==kC.name then local qM=g5.position-cO;local sj=kC:getAltitude(g5.position)local qY=dn(qM:len()^2-(ci-sj)^2)local t3=bv;if t3 then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,t3/2)ls=true;if qY<=c6+cL*s7/2 and cK:project_on_plane(cM):normalize():dot(qM:project_on_plane(cM):normalize())>0.99 then if kC.hasAtmosphere then b1=false;b3=false;pW=true;cc=false;ce=true;b4=false;ct.BeginReentry()end end;tm=qY end end end;if not cg and cf==-1 and(b6 and bb>kC.noAtmosphericDensityAltitude)and not(cd or bA or b9)then if not cE and not bA then cD=bb;pQ=true;if br then q1.VectorToTarget=true end;ct.ToggleIntoOrbit()br=false;pO=true end end;if cA and cg and cf==-1 and cL>aM and ly~="Finalizing Approach"then qF(cK)sN=dl(cS-s9,cS-P*0.80,cS+P*0.80)end;pX=t9;local qy=-1;if b7 then if not qb then rQ=false;if not cR then q5=0 end;iH:setTargetGroundAltitude(500)iH:activateGroundEngineAltitudeStabilization(500)bC=true;if not cg then rQ=true end;qb=true end;sN=0;local tn=false;local to=math.abs(q4)if not q and cQ then tn=antigrav.getBaseAltitude()if tn<kC.surfaceMaxAltitude and g5==nil or g5~=nil and kC:getAltitude(g5.position)>tn then tn=false end else tn=false end;if dc then if to<0.05 then if cN>-Q then b1=false else b1="BL Align BLR"end;if qF(dc,0.001)then dc=nil;cz=p else pX=0;cz=true end else b1="BL Align Hzn"end;if tn and eZ(ci-tn)<250 then b1="AGG Align"end else local tp=false;local tq=30;if to<10 and sf~=nil and sf>0 then local tr=dl(ch,0.4,2)local t3=bv*dl(cL/100,0.1,1)*tr;local ts=sf*tr+t3-of;local tt=t3/2-of;local tu=cL-dn(eZ(tt/2)*20/(0.5*cj))*utils.sign(tt)if tu<0 then tu=0 end;local tv;if cL>100 then local tw,dQ=cp.computeDistanceAndTime(cL,100,cj,0,0,t3)local tx,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,dn(t3))tv=tw+tx else tv=cp.computeDistanceAndTime(cL,0,cj,0,0,dn(t3))end;if tv<20 then b1=false else local ty=0;if tu>100 then local tz,dQ=cp.computeDistanceAndTime(tu,100,cj,0,0,ts)local tA,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,sf*tr+dn(t3)-of)ty=tz+tA else ty,dQ=cp.computeDistanceAndTime(tu,0,cj,0,0,sf*tr+dn(t3)-of)end;ty=(ty+15+cL*s7)*1.1;local tB=db and g5~=nil and kC:getAltitude(g5.position)>0 and g5.safe;local sj=nil;if tn and tn<ci then sj=tn elseif tB then sj=kC:getAltitude(g5.position)+250 elseif ci>kC.surfaceMaxAltitude then sj=kC.surfaceMaxAltitude end;if c_ then local tC=kC:getAltitude(c_[1].center)if sj then if tC>sj then sj=tC end else sj=tC end end;if sj~=nil then local tD=ci-sj;tp=true;if tD<=ty or ty==-1 or to>0.05 and db then if to>0.05 and db then b1="BL AP Hzn"else b1="BL Stop Dist"end else b1=false end end end end;qy=cf;if qy>-1 then if not tn and not bn then q8=true;iH:setTargetGroundAltitude(a0)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qy-5<a0 then b7=false;b6=false;b_=0;if rQ then qQ(0,1)end;b1="BL Complete"cz=p;db=false;qb=false else if cN<-5 or to>0.05 then b1="BL Slowing"else b1=false end end elseif not tp then if ls and cK:normalize():dot(-gr)<0.999 then b1="BL Strong"qF()elseif to>10 or to>0.05 and db then b1="BL hSpd"elseif cN<-Q then b1="BL BLR"if rQ then qQ(0,1)end else if rQ then qQ(-1)end;b1=false end end end else qb=false end;if b8 or cd then local lu,eK,eJ;if bl~=nil then lu,eK,eJ=co:getPlanetarySystem(0):castIntersections(cO,(bl-cO):normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)end;if cQ and not cd then if ci>=bb-50 and cL>i_ then b8=false;if not b4 and not br then b1="ATO Agg Arrive"q5=0 end end elseif eZ(sN)<15 and ci/bb>0.75 then b8=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<i_ then b4=true;cd=false;b6=false;b8=false;q5=0 elseif cd then q5=0;b1="ATO Space"end elseif cd and not cg and c8~=nil and(lu==nil or lu.name==c8.name)then b4=true;cd=false;b6=false;b8=false;if not cR then q5=0 end;bc=true end end;local tE=cf>-1;local tF=cS;if(br or cd or cX)and not tE and cL>aM and cg then local mD=math.rad(eZ(cT))tF=cS*eZ(math.cos(mD))+s9*math.sin(mD)end;local tG=dl(sN-tF,-P*0.80,P*0.80)if not cg and br then tG=dl(sN-tF,-85,R)elseif not cg then tG=dl(sN-tF,-R,R)end;if eZ(cT)<5 or br or cX or b7 or tE or b6 then if t2==nil then t2=pid.new(5*0.01,0,5*0.1)end;t2:inject(tG)local sP=t2:get()pX=pX+sP end end;if antigrav~=nil and(antigrav and not q and ci<200000)then if bw==nil or bw<1000 then bw=1000 end;if tH~=bw then tH=bw;qf=tH end end;if(cg or b9 or ce)and t and cR then if tI==nil then tI=pid.new(0.1,0,1)end;local tJ=0;if aZ>0 and not b9 and ch>0.005 and ch<0.1 and cN>-10 then local tK=bP.getFrictionBurnSpeed()*aZ;local tL=cB/3.6;if tK>tL then tJ=tK-tL-1 end end;tI:inject(cB/3.6+tJ-cK:dot(cH))local tM=tI:get()bU=dl(tM,-1,1)if not d7 then if bU<bR and(ch>0.005 or b9 or ce)then bT=true;d7=dl(bU,0.01,1)else bT=false;d7=bR end end;if tN==nil then tN=pid.new(1*0.01,0,1*0.1)end;tN:inject(cK:len()-cB/3.6-tJ)local tO=dl(tN:get(),0,1)if cg and cN<-80 or(ch>0.005 or b9 or ce)then bS=tO end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dl(bU,0.01,1)end;local tP=''local tQ=vec3()local tR=rn(axisCommandId.vertical,b_*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tR,rM)local tS='thrust analog longitudinal 'if bD=="All"or bD=="Longitude"then tS=tS..aV end;local tT=iH:getAxisCommandType(axisCommandId.longitudinal)local tU=iH:composeAxisAccelerationFromThrottle(tS,axisCommandId.longitudinal)local tV=rB(axisCommandId.lateral,bz*1000)tP=tP..' , '.."lateral airfoil , lateral ground "tQ=tQ+tV;if tQ:len()>constants.epsilon then d:setEngineForceCommand(tP,tQ,rM,'','','',rN)end;d:setEngineForceCommand(tS,tU,rL)local tW='thrust analog vertical fueled 'local tX='thrust analog lateral fueled 'if bD=="All"or bD=="Lateral"then tX=tX..aW end;if bD=="All"or bD=="Vertical"then tW=tW..aX end;if b_~=0 or b7 and b1 or not bn and not bC then d:setEngineForceCommand(tW,tR,rL)else d:setEngineForceCommand(tW,vec3(),rL)end;if bz~=0 then d:setEngineForceCommand(tX,tV,rL)else d:setEngineForceCommand(tX,vec3(),rL)end;if rU==0 then rU=bS end;local tY=-rU*(aR*cK+aS*rY)d:setEngineForceCommand('brake',tY)else if t then if not d7 then d7=bR end end;local rp=c.getAxisCommandValue(0)if not cR then if tN==nil then tN=pid.new(1*0.01,0,1*0.1)end;tN:inject(cK:len()-rp/3.6)local tO=dl(tN:get(),0,1)rU=dl(rU+tO,0,1)end;local tY=-rU*(aR*cK+aS*rY)d:setEngineForceCommand('brake',tY)local tP=''local tQ=vec3()local tZ=false;local tS='thrust analog longitudinal 'if aV~="none"and(bD=="All"or bD=="Longitude")then tS=tS..aV end;local tT=iH:getAxisCommandType(axisCommandId.longitudinal)if tT==axisCommandType.byThrottle then local tU=iH:composeAxisAccelerationFromThrottle(tS,axisCommandId.longitudinal)d:setEngineForceCommand(tS,tU,rL)elseif tT==axisCommandType.byTargetSpeed then local tU=iH:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tP=tP..' , '..tS;tQ=tQ+tU;if iH:getTargetSpeed(axisCommandId.longitudinal)==0 or iH:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iH:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tZ=true end end;local tX='thrust analog lateral 'if aW~="none"and(bD=="All"or bD=="Lateral")then tX=tX..aW end;local t_=iH:getAxisCommandType(axisCommandId.lateral)if t_==axisCommandType.byThrottle then local u0=iH:composeAxisAccelerationFromThrottle(tX,axisCommandId.lateral)d:setEngineForceCommand(tX,u0,rL)elseif t_==axisCommandType.byTargetSpeed then local tV=iH:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tP=tP..' , '..tX;tQ=tQ+tV end;local tW='thrust analog vertical 'if aX~="none"and(bD=="All"or bD=="Vertical")then tW=tW..aX end;local u1=iH:getAxisCommandType(axisCommandId.vertical)if u1==axisCommandType.byThrottle then local tR=iH:composeAxisAccelerationFromThrottle(tW,axisCommandId.vertical)if b_~=0 or b7 and b1 then d:setEngineForceCommand(tW,tR,rL,'airfoil','ground','',rN)else d:setEngineForceCommand(tW,vec3(),rL)d:setEngineForceCommand('airfoil vertical',tR,rL,'airfoil','','',rN)d:setEngineForceCommand('ground vertical',tR,rL,'ground','','',rN)end elseif u1==axisCommandType.byTargetSpeed then if b_<0 then d:setEngineForceCommand('hover',vec3(),rL)end;local u2=iH:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tP=tP..' , '..tW;tQ=tQ+u2 end;if tQ:len()>constants.epsilon then if rU~=0 or tZ or eZ(rY:dot(cH))<0.5 then tP=tP..', brake'end;d:setEngineForceCommand(tP,tQ,rM,'','','',rN)end end;local u3=aO*(s1-s0)local u4=vec3(bP.getWorldAirFrictionAngularAcceleration())u3=u3-u4;d:setEngineTorqueCommand('torque',u3,rL,'airfoil','','',rN)d:setBoosterCommand('rocket_engine')if c5 and not n then local fp=cJ:len()local u5=0.15;if not cR then local u6=iH:getTargetSpeed(axisCommandId.longitudinal)if fp*3.6>u6*(1-u5)and u7 then u7=false;d:toggleBoosters()elseif fp*3.6<u6*(1-u5)and not u7 then u7=true;d:toggleBoosters()end else local rd=c.getThrottle()if t then rd=bR*100 end;local rp=rd/100;if not cg then rp=rp*ac;if fp>=rp*(1-u5)and u7 then u7=false;d:toggleBoosters()elseif fp<rp*(1-u5)and not u7 then u7=true;d:toggleBoosters()end else local ta=bN(cB)rp=rp*ta/3.6;if fp>=rp*(1-u5)and u7 then u7=false;d:toggleBoosters()elseif fp<rp*(1-u5)and not u7 then u7=true;d:toggleBoosters()end end end end end;if u8 then for dL,dx in pairs(u8)do pE[dL]=dx end end;cf=qt()return pE end;local function u9(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ua,iG,iH,iI,ub,gM,fV,e4,dm,dl,fU,iK,pD)local bP=DUConstruct;local uc={}local ud=true;local ue=5;local uf=5;local ug=ue;local uh=uf;local ui=bQ;function uc.landingGear(q8)bn=not bn;if bn then br=false;bu=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not q8 then fU("bklOn","BL")ls=true;b9=false;b8=false;ba=false;if bA then ct.ToggleIntoOrbit()end;if b7 then db=not db end;b7=true;cz=true;bn=false else if bW then fU("grOut","LG",1)d.control.deployLandingGears()end;db=false;iH:setTargetGroundAltitude(a0)if cg then b1="Landing"end end;b6=false;bI=false elseif bW and not b7 then fU("grOut","LG",1)d.control.deployLandingGears()end else if bW then fU("grIn","LG",1)d.control.retractLandingGears()end;iH:activateGroundEngineAltitudeStabilization(qT)if bC then if a0<iH.targetGroundAltitude then iH:setTargetGroundAltitude(iH.targetGroundAltitude)else iH:setTargetGroundAltitude(_)end end end end;function uc.startControl(uj)local function uk(r8)local r9=1;local function ul(um,r8)local un={kC.surfaceMaxAltitude+100,kC.spaceEngineMinAltitude-0.01*kC.noAtmosphericDensityAltitude,kC.noAtmosphericDensityAltitude+W,kC.radius*(V-1)+kC.noAtmosphericDensityAltitude}local uo=um;for dQ,dx in ipairs(un)do if r8 and uo>dx then um=dx elseif um<dx and not r8 then um=dx;break end end;return um end;if r8 then r9=-1 end;if not q and cQ then if c1 and r8 then bw=1000 elseif bw~=nil then bw=bw+r9*uf;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end else bw=tH+r9*100 end elseif b6 or ba or bA then if bA then if c1 then cD=ul(cD,r8)else cD=cD+r9*ue end;if cD<kC.noAtmosphericDensityAltitude then cD=kC.noAtmosphericDensityAltitude end else if c1 and cg then bb=ul(bb,r8)bI=false else bb=bb+r9*ue;if bI then if bb>100 then bI=false else iH:updateTargetGroundAltitudeFromActionStart(r9*1.0)bI=d:getTargetGroundAltitude()end end end end else iH:updateTargetGroundAltitudeFromActionStart(r9*1.0)end end;local function up(uq)if not cg then c3="Flight Assist in Atmo only"return end;local du=type(uq)if cX==nil then if du=="table"then if b4 or br then ct.ToggleAutopilot()end;fU("180On","BR")elseif uq==1 then fU("bnkLft","BR")else fU("bnkRht","BR")end;if not b6 and not b4 and not br then ct.ToggleAltitudeHold()if du~="table"then uq=uq+1 end end;cX=uq else fU("180Off","BR")cX=nil end end;local function ur()if iI()==1 then c9=0;ca=0;ub(bj)elseif iG()==1 and y then cy=false;cx=false end;c1=false end;if uj=="gear"then cv.landingGear()elseif uj=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uj=="forward"then if p5 and not cg and not b4 then b3=not b3;b2=false else bX=bX-1 end elseif uj=="backward"then if p5 then if not cg then if not b4 then b2=not b2;b3=false else b5=not b5 end else up(-cK*5000)end else bX=bX+1 end elseif uj=="left"then if p5 then up(1)else bY=bY-1 end elseif uj=="right"then if p5 then up(3)else bY=bY+1 end elseif uj=="yawright"then bZ=bZ-1;dc=nil elseif uj=="yawleft"then bZ=bZ+1;dc=nil elseif uj=="straferight"then iH:updateCommandFromActionStart(axisCommandId.lateral,1.0)bz=1 elseif uj=="strafeleft"then iH:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bz=-1 elseif uj=="up"then ct.vertical(1)if cf-3<a0 and ci>0 and bn then cv.landingGear()end elseif uj=="down"then ct.vertical(-1)elseif uj=="groundaltitudeup"then uk()elseif uj=="groundaltitudedown"then uk(true)elseif uj=="option1"then us=false;if p5 and c1 then local ut=""for M=1,#d2 do ut=ut.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fV(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..ut)return end;cs.adjustAutopilotTargetIndex()elseif uj=="option2"then us=false;if p5 and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;c3="Deboarded All Passengers"return end;cs.adjustAutopilotTargetIndex(1)elseif uj=="option3"then us=false;if p5 and c1 then local ut=""for M=1,#d3 do ut=ut.."| ID: "..d3[M].." Mass: "..fV(b.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..ut)return end;if x then if w then w=false else w=true end;if cu then cu.ToggleRadarPanel()end end elseif uj=="option4"then us=false;if p5 and c1 then for M=1,#d3 do b.forceUndock(d3[M])end;c3="Undocked all ships"return end;cX=nil;ct.ToggleAutopilot()elseif uj=="option5"then us=false;ct.ToggleLockPitch()elseif uj=="option6"then us=false;if p5 and c1 then if shield then cw.ventShield()else c3="No shield found"end;return end;ct.ToggleAltitudeHold()elseif uj=="option7"then us=false;if p5 and c1 then if shield then shield.toggle()return else c3="No shield found"return end end;E=not E;if E then c3="Collision System Enabled"else c3="Collision System Secured"end elseif uj=="option8"then us=false;if p5 and c1 then if bm>0 and g5~=nil then ct.routeWP()else c3="Select a saved wp on IPH to add to or remove from route"end;return end;bC=not bC;if not bC then c3="DeCoupled Mode - Ground Stabilization off"iH:deactivateGroundEngineAltitudeStabilization()fU("gsOff","GS")else c3="Coupled Mode - Ground Stabilization on"iH:activateGroundEngineAltitudeStabilization(qT)de=true;fU("gsOn","GS")end elseif uj=="option9"then us=false;if p5 and c1 then iH:resetCommand(axisCommandId.longitudinal)iH:resetCommand(axisCommandId.lateral)iH:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()==1;if ck then fU("gyOn","GA")else fU("gyOff","GA")end else c3="No gyro found"end elseif uj=="lshift"then d0=false;if p5 then c1=true elseif c1 then ur()else if iI()==1 then c1=true;bj=iI()ub(1)elseif iG()==1 and y then c1=true;cy=false;cx=false end end elseif uj=="brake"then if a_ or p5 then ct.BrakeToggle("Manual")elseif not b1 then ct.BrakeToggle("Manual")else b1="Manual"end elseif uj=="lalt"then us=true;p5=true;if iG()==0 and not i and g=="keyboard"then ub(1)end elseif uj=="booster"then if n then d:toggleBoosters()elseif not c5 then if not u7 then d:toggleBoosters()u7=true end;c5=true else if u7 then d:toggleBoosters()u7=false end;c5=false end elseif uj=="stopengines"then local function uu()if bQ-ui<1.5 then fU("clear","CA")ct.clearAll()end end;uu()ui=bQ;if iH:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p5 then if cB>0 then cB=0 else cB=X end elseif bR~=0 then iH:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iH:getTargetSpeed(axisCommandId.longitudinal)~=0 then iH:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(ac*3.6)end end end elseif uj=="speedup"then ct.changeSpd()elseif uj=="speeddown"then ct.changeSpd(true)elseif uj=="antigravity"and not q then if antigrav~=nil then ct.ToggleAntigrav()else c3="No antigrav found"end elseif uj=="leftmouse"then c2=true;ur()us=false end end;function uc.stopControl(uj)local function uv()if not q and cQ then uh=uf end;if b6 or ba or bA then ug=ue end end;if uj=="forward"then bX=0 elseif uj=="backward"then bX=0 elseif uj=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif uj=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif uj=="yawright"then bZ=0 elseif uj=="yawleft"then bZ=0 elseif uj=="straferight"then iH:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bz=0 elseif uj=="strafeleft"then iH:updateCommandFromActionStop(axisCommandId.lateral,1.0)bz=0 elseif uj=="up"then ct.vertical(0,-1)elseif uj=="down"then ct.vertical(0,1)elseif uj=="groundaltitudeup"then uv()us=false elseif uj=="groundaltitudedown"then uv()us=false elseif uj=="brake"then if not a_ and not p5 then if b1 then ct.BrakeToggle()else b1=false end end elseif uj=="lalt"then if c1 then c1=false end;if iG()==0 and i then if us then if iI()==1 then ub(0)else ub(1)end else us=true end elseif iG()==0 and not i and g=="keyboard"then ub(0)end;p5=false end end;function uc.loopControl(uj)local function uw(r8)local r9=1;if r8 then r9=-1 end;if not q and cQ then if bw~=nil then bw=bw+r9*uh;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end;uh=dl(uh*1.05,uf,50)else bw=tH+r9*100 end elseif b6 or ba or bA then if bA then cD=cD+r9*ug;if cD<kC.noAtmosphericDensityAltitude then cD=kC.noAtmosphericDensityAltitude end else bb=bb+r9*ug end;ug=dl(ug*1.05,ue,50)else iH:updateTargetGroundAltitudeFromActionLoop(r9*1.0)end end;local function ux(r8)local r9=1;if r8 then r9=-1 end;if not c1 then if t and not p5 then bR=dl(bR+r9*aG/100,-1,1)else iH:updateCommandFromActionLoop(axisCommandId.longitudinal,r9*aG)end end end;if uj=="groundaltitudeup"then if not c1 then uw()end elseif uj=="groundaltitudedown"then if not c1 then uw(true)end elseif uj=="speedup"then ux()elseif uj=="speeddown"then ux(true)end end;function uc.inputTextControl(r7)local function uy(uz,fv,gz)local function uA(fv)local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local dU,dV,e1,e2,e3=e4(fv,dE)if dU=="0"and dV=="0"then return vec3(dm(e1),dm(e2),dm(e3))end;e2=math.rad(e2)e1=math.rad(e1)local kC=e[dm(dU)][dm(dV)]local eV=math.cos(e1)local uB=vec3(eV*math.cos(e2),eV*math.sin(e2),math.sin(e1))return kC.center+(kC.radius+e3)*uB end;local fX=uA(fv)return cs.AddNewLocation(uz,fX,gz)end;local M;local uC,iv=nil,nil;local uD="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(r7," ")uC=r7;if M~=nil then uC=string.sub(r7,0,M-1)iv=string.sub(r7,M+1)end;if uC=="/help"or uC=="/commands"then for lt in string.gmatch(uD,"([^\n]+)")do a.print(lt)end;return elseif uC=="/setname"then if iv==nil or iv==""then c3="Usage: ah-setname Newname"return end;if bm>0 and g5~=nil then cs.UpdatePosition(iv)else c3="Select a saved target to rename first"end elseif shield and uC=="/resist"then cw.setResist(iv)elseif uC=="/addlocation"or string.find(r7,"::pos")~=nil then local gz=false;local uz="0-Temp"if iv==nil or iv==""or uC~="/addlocation"then iv=uC;gz=true end;M=string.find(iv,"::")if not gz then uz=string.sub(iv,1,M-2)end;local fv=string.sub(iv,M)uy(uz,fv,gz)elseif uC=="/agg"then if iv==nil or iv==""then c3="Usage: /agg targetheight"return end;iv=dm(iv)if iv<1000 then iv=1000 end;bw=iv;c3="AGG Target Height set to "..iv elseif uC=="/G"then if iv==nil or iv==""then c3="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if iv=="dump"then for dL,dx in pairs(iK())do if type(dx.get())=="boolean"then if dx.get()==true then a.print(dL.." true")else a.print(dL.." false")end elseif dx.get()==nil then a.print(dL.." nil")else a.print(dL.." "..dx.get())end end;return end;M=string.find(iv," ")local uE=string.sub(iv,0,M-1)local uF=string.sub(iv,M+1)for dL,dx in pairs(iK())do if dL==uE then local uG=type(dx.get())if uG=="number"then uF=dm(uF)if dL=="AtmoSpeedLimit"then cB=uF end end;c3="Variable "..uE.." changed to "..uF;if dL=="MaxGameVelocity"then uF=uF/3.6;if uF>df-0.2 then uF=df-0.2;c3="Variable "..uE.." changed to "..fV(uF*3.6,1)end end;if uG=="boolean"then if string.lower(uF)=="true"then uF=true else uF=false end end;dx.set(uF)return end end;c3="No such global variable: "..uE elseif uC=="/deletewp"then if bm>0 and g5~=nil then cs.ClearCurrentPosition()else c3="Select a custom wp to delete first in IPH"end elseif uC=="/copydatabank"then if dbHud_2 then pD(true)else c3="Spare Databank required to copy databank"end elseif uC=="/iphWP"then if bm>0 then a.print(ct.showWayPoint(c8,bl,true))a.print(json.encode(bl))c3="::pos waypoint shown in lua chat in local and world format"else c3="No target selected in IPH"end elseif uC=="/createPrivate"then local uH="privatelocations = {\n"local uI=""if#d9>0 then for dL,dx in pairs(d9)do uH=uH.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uH=uH.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uH=uH.."safe = true},\n"else uH=uH.."safe = false},\n"end end end;uI=#d9 .."-Private "if iv=="all"then for dL,dx in pairs(bq)do uH=uH.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '*"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uH=uH.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uH=uH.." safe = true},\n"else uH=uH.."safe = false},\n"end end;uI=uI..#bq.."-Public "end;uH=uH.."}\n return privatelocations"if ua then ua.setHTML(uH)end;c3=uI.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c4=7 end end;function uc.tagTick()if bD=="Off"then bD="All"elseif bD=="All"then bD="Longitude"elseif bD=="Longitude"then bD="Lateral"elseif bD=="Lateral"then bD="Vertical"else bD="Off"end;c3="Extra Engine Tags: "..bD;c.stopTimer("tagTick")end;if uJ then for dL,dx in pairs(uJ)do uc[dL]=dx end end;return uc end;local function uK(d,b,c,e,vBooster,hover,pC,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iD,ua)local a=DUSystem;local bP=DUConstruct;local uL=DUPlayer;local uM=DULibrary;local uN={}local dk=string.format;local iE=json.decode;local uO=json.encode;local pv=b.getElementMaxHitPointsById;local iF=b.getElementMassById;local iG=d.control.isRemoteControlled;local e4=string.match;local gM=a.destroyWidgetPanel;local fS=a.updateData;local fT=a.addDataToWidget;local ub=a.lockView;local iI=a.isViewLocked;local dn=math.sqrt;local dm=tonumber;local eZ=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local eU=math.atan;local bM=a.getArkTime;local dl=utils.clamp;local iH=d.axisCommandManager;local gO=13;local iN=b.getElementIdList()local iO=0;local function dp(eC,eD)if eC==0 then return eZ(eD)<1e-09 elseif eD==0 then return eZ(eC)<1e-09 else return eZ(eC-eD)<math.max(eZ(eC),eZ(eD))*dC end end;local function fV(dD,uP)local r9=10^(uP or 0)return bN(dD*r9+0.5)/r9 end;local function iJ(uQ,uR)for dL,dx in pairs(uR)do if type(dL)=="string"then uQ[dL]=dx else uQ[#uQ+1]=uR[dL]end end;return uQ end;local function iK(uS)local uT={}if not uS then iJ(uT,L)iJ(uT,ab)iJ(uT,aE)iJ(uT,aY)return uT elseif uS=="boolean"then return L elseif uS=="handling"then return ab elseif uS=="hud"then return aE elseif uS=="physics"then return aY end end;local function pD(uU)local function uV(uW)for dL,dx in pairs(uW)do dbHud_1.setStringValue(dL,uO(dx.get()))if uU and dbHud_2 then dbHud_2.setStringValue(dL,uO(dx.get()))end end end;if dbHud_1 then uV(bJ)uV(iK())a.print("Saved Variables to Datacore")if uU and dbHud_2 then c3="Databank copied.  Remove copy when ready."end end end;local function fU(uX,uY,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uX..".mp3")end;local function gN(hH,hI,r7,jU,uZ)return dk([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jU or"",hH,hI,uZ or"",r7)end;local function iL(cb,u_)u_=u_ or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fV(cb,u_)..unit end;local function iM(v0)local v1=0;local v2=0;local v3=0;if v0<60 then v0=bN(v0)elseif v0<3600 then v1=bN(v0/60)v0=bN(v0%60)elseif v0<86400 then v2=bN(v0/3600)v1=bN(v0%3600/60)else v3=bN(v0/86400)v2=bN(v0%86400/3600)end;if v3>0 then return v3 .."d "..v2 .."h "elseif v2>0 then return v2 .."h "..v1 .."m "elseif v1>0 then return v1 .."m "..v0 .."s"elseif v0>0 then return v0 .."s"else return"0s"end end;local function v4()if radar_1 then cu=gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU)end end;function uN.radarSetup()v4()end;function uN.onStart()local v5=false;local function v6()local function v7(v8)local v9=dbHud_1.hasKey;for dL,dx in pairs(v8)do if v9(dL)then local dG=iE(dbHud_1.getStringValue(dL))if dG~=nil then dx.set(dG)v5=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then v7(iK())coroutine.yield()v7(bJ)else v7(bJ)c3="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values"c4=5;v5=false end;coroutine.yield()if v5 then c3="Loaded Saved Variables"elseif not f then c3="No Databank Saved Variables Found\nVariables will save to Databank on standing"c4=5 end;if#bq>0 then da=iJ(da,bq)end else c3="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;a_=j;g=string.lower(g)cz=p;cB=X;if bx+180<bQ then bv=0 end;bx=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c3="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c4=7 end;if antigrav and not q then if bw==nil then bw=ci end;antigrav.setTargetAltitude(bw)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d9>0 then da=iJ(da,d9)end end;ly="Proceeding to Waypoint"if not ac or ac<0 then ac=bP.getMaxSpeed()-0.1 end end;local function va()local function vb(vc,vd)if vc>vd then vd=vc end;local ve,vf=0,0;if a7>0 then ve=a7*0.05 end;if a8>0 then vf=a8*0.05 end;vd=vd*(1-(ve+vf))return vd end;local vg=b.getElementNameById;local vh=au~=0 and av~=0;local vi=_G["atmofueltank_size"]local vj=_G["spacefueltank_size"]local vk=_G["rocketfueltank_size"]for dL in pairs(iN)do local type=b.getElementDisplayNameById(iN[dL])if e4(type,'^.*Atmospheric Engine$')then if e4(tostring(b.getElementTagsById(iN[dL])),'^.*vertical.*$')and b.getElementForwardById(iN[dL])[3]>0 then cP=true end end;if e4(type,'^.*Space Engine$')then cG=true;if e4(tostring(b.getElementTagsById(iN[dL])),'^.*vertical.*$')then local vl=b.getElementForwardById(iN[dL])if vl[3]<0 then vm=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local px=pv(iN[dL])if px>10000 then gO=110 elseif px>1000 then gO=55 elseif px>150 then gO=27 end end;iO=iO+pv(iN[dL])if vh and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local px=pv(iN[dL])local on=iF(iN[dL])local vc=0;local jN=bM()if type=="Atmospheric Fuel Tank"then local vd=400;local vn=35.03;if px>10000 then vd=51200;vn=5480 elseif px>1300 then vd=6400;vn=988.67 elseif px>150 then vd=1600;vn=182.67 end;vc=on-vn;if a4>0 then vd=vd+vd*a4*0.2 end;vd=vb(vc,vd)local gy=vg(iN[dL])local jL=0;for jM=1,vi do if gy==iE(c["atmofueltank_"..jM].getWidgetData()).name then jL=jM;break end end;local vo={iN[dL],string.sub(gy,1,12),vd,vn,vc,jN,jL}cl[#cl+1]=vo end;if type=="Rocket Fuel Tank"then local vd=320;local vn=173.42;if px>65000 then vd=40000;vn=25740 elseif px>6000 then vd=5120;vn=4720 elseif px>700 then vd=640;vn=886.72 end;vc=on-vn;if a6>0 then vd=vd+vd*a6*0.1 end;vd=vb(vc,vd)local gy=vg(iN[dL])local jL=0;for jM=1,vk do if gy==iE(c["rocketfueltank_"..jM].getWidgetData()).name then jL=jM;break end end;local vo={iN[dL],string.sub(gy,1,12),vd,vn,vc,jN,jL}cn[#cn+1]=vo end;if type=="Space Fuel Tank"then local vd=600;local vn=35.03;if px>10000 then vd=76800;vn=5480 elseif px>1300 then vd=9600;vn=988.67 elseif px>150 then vd=2400;vn=182.67 end;vc=on-vn;if a5>0 then vd=vd+vd*a5*0.2 end;vd=vb(vc,vd)local gy=vg(iN[dL])local jL=0;for jM=1,vj do if gy==iE(c["spacefueltank_"..jM].getWidgetData()).name then jL=jM;break end end;local vo={iN[dL],string.sub(gy,1,12),vd,vn,vc,jN,jL}cm[#cm+1]=vo end end end;if not cP then ba,b0=false,false end end;local function vp()if gyro~=nil then ck=gyro.isActive()==1 end;if not bC then iH:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ub(1)else ub(0)end;if door and(cg or not cg and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not q then antigrav.showWidget()end end;if iG()==1 and k then uL.freeze(1)else uL.freeze(0)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bn=d.control.isAnyLandingGearDeployed()==1 or cf~=-1 and cf-3<a0;if cf~=-1 or not cg and cJ:len()<50 then b1="Startup"else b1=false end;iH:setTargetGroundAltitude(a0)pj=cg end;local function vq()local vr={}local function vs()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vt={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}local vu={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=7700,[100]=12511,[110]=7792,[120]=11766}for vv,vw in pairs(e)do e[vv][0]=vs()e[vv][0].systemId=vv;vr[vv]={}for vx,kC in pairs(e[vv])do kC.gravity=kC.gravity/9.8;kC.center=vec3(kC.center)kC.name=kC.name[1]kC.noAtmosphericDensityAltitude=vu[kC.id]or kC.atmosphereThickness;kC.spaceEngineMinAltitude=vt[kC.id]or 0.5353125*kC.atmosphereThickness;kC.planetarySystemId=vv;kC.bodyId=kC.id;vr[vv][vx]=kC;if mo==nil or kC.center.x<mo then mo=kC.center.x end;if mn==nil or kC.center.x>mn then mn=kC.center.x end;if mr==nil or kC.center.y<mr then mr=kC.center.y end;if mq==nil or kC.center.y>mq then mq=kC.center.y end;if kC.center and kC.name~="Space"then d4[#d4+1]=kC end end end;ee=dj(d,b,c,a,dk,dl,dm,dn,dp)co=ee(vr)fY=co[0]cp=eY(d,b,c,a,dn,eZ)cq=fr(d,b,c,a,dk,dl,dm,dn,dp)cs=fR(d,b,c,a,dbHud_1,e,fS,fT,bN,dm,dn,fU,fV)kC=co[0]:closestBody(bP.getWorldPosition())end;vy=false;vz=coroutine.create(function()iH:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v6()coroutine.yield()va()coroutine.yield()ct=pB(d,b,c,e,vBooster,hover,pC,antigrav,dbHud_1,eZ,bN,bO,iG,eU,bM,dl,iH,fS,iI,dn,fV,fU,iJ,dp,iL,iM,pD,iE)vp()coroutine.yield()vq()v4()if iC then cr=iC(d,b,c,a,e,antigrav,hover,shield,warpdrive,iD,eZ,bN,dk,iE,bO,iF,iG,eU,bM,dl,iH,fT,fS,gM,iI,dn,fV,gN,fU,iJ,iK,iL,iM,iN,iO)end;if cr then cr.ButtonSetup()end;cv=u9(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ua,iG,iH,iI,ub,gM,fV,e4,dm,dl,fU,iK,pD)if shield then cw=il(shield,e4,bN)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if ua then ua.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vA then nB.ExtraOnStart()end;fU("start","SU")local function vB()if bH[1]==0 then ct.cmdThrottle(bH[2])else if ch>0 then cB=bH[2]ct.cmdThrottle(1)end end end;lp=string.find(c.getName(),"Emergency")or false;if lp then if cf>-1 and cL<1 and cf-3<a0 then c.exit()else if K then vB()else if ch==0 then b1="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif K and bH[3]+3>bM()then vB()end end)coroutine.resume(vz)end;function uN.onUpdate()if vy then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iH:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and p7~=vC then a.setScreen(p7)end;vC=p7;if lp and not K and ch>0 and cf==-1 then cv.landingGear()end;if lp and cf>-1 and cL<1 and cf-3<a0 then c.exit()end;if vA then nB.ExtraOnUpdate()end else local ib=coroutine.status(vz)if ib=="suspended"then local dM,ic=coroutine.resume(vz)if ic then a.print("ERROR STARTUP: "..ic)end elseif ib=="dead"then vy=true end end end;function uN.onFlush()if vy then ct.onFlush()if vA then nB.ExtraOnFlush()end end end;function uN.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;w=d6;local vD=0;if lp then vD=bM()end;if iH:getAxisCommandType(0)==0 then bH={0,bR,vD}else bH={1,iH:getTargetSpeed(axisCommandId.longitudinal),vD}end;pD()if nY then nY.activate()end;if z then ct.showWayPoint(kC,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vA then nB.ExtraOnStop()end;fU("stop","SU")end;function uN.controlStart(uj)if vy then cv.startControl(uj)end end;function uN.controlStop(uj)if vy then cv.stopControl(uj)end end;function uN.controlLoop(uj)if vy then cv.loopControl(uj)end end;function uN.controlInput(r7)if vy then cv.inputTextControl(r7)end end;function uN.radarEnter(dV)if cu then cu.onEnter(dV)end end;function uN.radarLeave(dV)if cu then cu.onLeave(dV)end end;function uN.onTick(vE)if vE=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vE=="oneSecond"then if cr then cr.OneSecondTick()end elseif vE=="fiveSecond"then ct.SatNavTick()elseif vE=="msgTick"then if cr then cr.MsgTick()end elseif vE=="animateTick"then if cr then cr.AnimateTick()end elseif vE=="hudTick"then if cr then cr.hudtick()end elseif vE=="apTick"then if ct then ct.APTick()end elseif vE=="shieldTick"then cw.shieldTick()elseif vE=="tagTick"then cv.tagTick()elseif vE=="contact"then cu.ContactTick()end end;if vA then for dL,dx in pairs(vA)do uN[dL]=dx end end;return uN end;function script.onStart()nB.onStart()end;function script.onOnStop()nB.onStop()end;function script.onTick(vE)nB.onTick(vE)end;function script.onOnFlush()nB.onFlush()end;function script.onOnUpdate()nB.onUpdate()end;function script.onActionStart(uj)nB.controlStart(uj)end;function script.onActionStop(uj)nB.controlStop(uj)end;function script.onActionLoop(uj)nB.controlLoop(uj)end;function script.onInputText(r7)nB.controlInput(r7)end;function script.onEnter(dV)nB.radarEnter(dV)end;function script.onLeave(dV)nB.radarLeave(dV)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)nB=uK(d,core,unit,e,vBooster,hover,pC,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iD,ua)script.onStart()
        MaintainOrbit = true --export: (Default: true) If true, ship will attempt to maintain orbit if it decays (when not autopiloting to a landing point) till fuel runs out.
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        ExtraEscapeThrust = 1.0 --export: (Default: 1.0) Set this to 1 to use friction burn speed as your max speed when escaping atmosphere. Setting other than 1 will be a the value multiplied by your friction burn speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
