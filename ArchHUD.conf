name: ArchHud - Archaegeo v1.358 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        LockPitchTarget = 0 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.358;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=utils.round;local p=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local z=math.sqrt;local A=tonumber;local core=core;local function B(C,D)local mult=10^(D or 0)return d(C*mult+0.5)/mult end;local E=p()local F=p()local G=16;local H=13;local I=SafeR;local J=SafeB;local K=SafeG;local L=0;local M=0;local N=false;local O=0;local P=false;local Q=false;local R=55;local S=false;local T=false;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=0;local a1=false;local a2=false;local a3="empty"local a4=5;local a5=5;local a6=a4;local a7=a5;local a8=false;local a9,aa=0;local ab,ac=0;local ad=nil;local ae=0;local af=0;local ag=0;local ah=0;local ai=0;local aj=3;local ak=0;local al=""local am=0;local an=false;local ao=false;local ap=false;local aq=-1;local ar=""local as=j()>0;local at=j()local au=core.getAltitude()local av=core.getElementIdList()local aw=p()local ax=core.getConstructMass()local ay=false;local az=nil;local aA=[[rgb(]]..d(I+0.5)..","..d(K+0.5)..","..d(J+0.5)..[[)]]local aB=[[rgb(]]..d(I*0.9+0.5)..","..d(K*0.9+0.5)..","..d(J*0.9+0.5)..[[)]]local aC={}local aD=0;local aE=0;local aF=""local aG=true;local aH={}local aI=ResolutionX;local aJ=ResolutionY;local aK={}local aL={}local aM={}local aN=0;local aO=false;local aP={}local aQ={}local aR=d(1/apTickRate)*2;local aS={}local aT={}local aU={}local aV={}local aW=false;local aX=0;local aY=nil;local aZ=nil;local a_=nil;local b0=nil;local b1=nil;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=false;local ba=false;local bb=autoRollPreference;local bc=LandingGearGroundHeight;local bd=false;local be=p()local bf=0;local bg=0;local bh=0;local bi=AtmoSpeedLimit;local bj=0;local bk=nil;local bl=0;local bm=0;local bn=false;local bo=false;local bp={VectorToTarget=false}local bq=false;local br=0;local bs=nil;local bt=false;local bu=false;local bv=false;local bw=false;local bx=0;local by=vec3(core.getConstructWorldOrientationUp())local bz=vec3(core.getConstructWorldOrientationForward())local bA=vec3(core.getConstructWorldOrientationRight())local bB=vec3(core.getWorldVelocity())local bC=vec3(bB):len()local bD=vec3(core.getWorldVertical())local bE=-bD:dot(bB)local bF=vec3(core.getConstructWorldPos())local bG=0;local bH=false;local bI=false;local bJ=nil;local bK=true;local bL=0;local bM=0;local bN=false;local bO={}local bP=showHud;local bQ={}local bR=false;local bS=""local bT=""local bU=nil;local bV={}local bW=unit.getClosestPlanetInfluence()>0;local bX=false;local bY=nil;timeCount=0;totalTime=0;local function bZ(b_,c0,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)end end;local function c1(c2,c3)for i=1,#c3 do c2[#c2+1]=c3[i]end;return c2 end;local function c4(c5)local c6={}local c7={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local c8={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","LockPitchTarget","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c9={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local ca={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c5 then c1(c6,c7)c1(c6,c8)c1(c6,c9)c1(c6,ca)return c6 elseif c5=="boolean"then return c7 elseif c5=="handling"then return c8 elseif c5=="hud"then return c9 elseif c5=="physics"then return ca end end;local function cb(x,y,cc,cd,ce)if cd==nil then cd=""end;if ce==nil then ce=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cd,x,y,ce,cc)end;local function cf(cg,ch)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not ch then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,cg)L=q(B(cg*100,0)/100,-1,1)end;local function ci(cg,ch)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ch then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,cg)bJ=cg end;local function cj(ck,cl)if ck==0 then return c(cl)<1e-09 end;if cl==0 then return c(ck)<1e-09 end;return c(ck-cl)<math.max(c(ck),c(cl))*epsilon end;local function cm(ak,cn)local co=ak>100000;if cn==nil then cn=1 end;if co then return B(ak/1000/200,cn).."SU"elseif ak<1000 then return B(ak,cn).."M"else return B(ak/1000,cn).."KM"end end;local function cp()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;bb=true;ag=0;if as and aq==-1 then BrakeLanding=false;AltitudeHold=true;ag=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ci(d(bi))end else bt=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cq()bt=false;bl=nil;bm=nil;bx=0;if at==0 then if IntoOrbit then bZ("orOff","AP")IntoOrbit=false;bn=false;bs=nil;bb=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bp.VectorToTarget=false;bp.AutopilotAlign=false;bq=false elseif bW then bZ("orOn","AP")IntoOrbit=true;bb=true;if bs==nil then bs=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a3="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bn=false;bs=nil;bb=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bp.VectorToTarget=false;bp.AutopilotAlign=false;bq=false end end;local function cr()if E-bg<1.5 then if planet.hasAtmosphere then if at>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;bZ("11","EP")else if bW then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;br=HoldAltitude;bq=true;if not IntoOrbit then cq()end;bn=true end end;bg=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bg=E end;if bW and at==0 then br=au;bq=true;bn=true;cq()if IntoOrbit then bg=E else bg=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a1=false;bb=true;LockPitch=nil;bt=false;if aq==-1 then bZ("altOn","AH")AutoTakeoff=false;if bg>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=au end end;if VertTakeOff then cp()end else bZ("lfs","LS")AutoTakeoff=true;if bg>-1 then HoldAltitude=au+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bH then cp()end end;if ao then HoldAltitude=100000 end else bZ("altOff","AH")if IntoOrbit then cq()end;if VertTakeOff then cp()end;bb=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bg=0 end end;local function cs()local function ct(SpaceTarget)bX=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cr()end end;VectorStatus="Proceeding to Waypoint"end;if E-bh<1.5 and at>0 then if not bw then a3="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if at>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bZ("orH","OH")end;bh=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bh=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not ao and not IntoOrbit then b7.UpdateAutopilotTarget()b8.showWayPoint(ad,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bZ("apSpc","AP")if at~=0 then ao=true;cr()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if at>0 then if not VectorToTarget then bZ("vtt","AP")ct(SpaceTarget)end else bZ("apOn","AP")if not(ad.name==planet.name and bW)then bt=false;Autopilot=true elseif not as then if IntoOrbit then cq()end;br=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bq=true;bp.AutopilotAlign=true;bp.VectorToTarget=true;bn=false;if not IntoOrbit then cq()end end end else bZ("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if at~=0 then ao=true;cr()else Autopilot=true end end elseif at==0 then if CustomTarget==nil and(ad.name==planet.name and bW)and not IntoOrbit then WaypointSet=false;bt=false;bn=false;cq()else bZ("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a1=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;Q=false;LockPitch=nil;WaypointSet=false end else bZ("apP","AP")ao=true;cr()end else bZ("apOff","AP")ao=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;Q=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=au;TargetSet=false;Reentry=false;if IntoOrbit then cq()end end end;local function cu()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bb=autoRollPreference end;if BrakeIsOn then bZ("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bU=nil;if not bI then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cp()end;if IntoOrbit then cq()end;bb=autoRollPreference;an=false;ap=false;ag=0 else bZ("bkOff","B",1)end end;local function cv(cw,cx,cy)local function cz(cw,cA)cw=vec3(cw)cA=vec3(cA):normalize()local cB=cw*cA;return cB.x+cB.y+cB.z end;local cC=0.001;local cD=1;if not as or not bd or aq~=-1 or bC<R then if cy==nil then cy=DampingMultiplier end;if cx==nil then cx=cC end;cw=vec3(cw):normalize()local cE=vec3()-cw;local cF=-cz(cE,core.getConstructWorldOrientationRight())*cD;local cG=-cz(cE,core.getConstructWorldOrientationUp())*cD;if aD==0 then aD=cF/2 end;if aE==0 then aE=cG/2 end;if c(cF)<0.1 then W=W-cF*2 else W=W-(cF+(cF-aD)*cy)end;if c(cG)<0.1 then V=V+cG*2 else V=V+cG+(cG-aE)*cy end;aD=cF;aE=cG;if c(cF)<cx and c(cG)<cx then return true end;return false elseif bd and aq==-1 then cw=bB;if cy==nil then cy=DampingMultiplier end;if cx==nil then cx=cC end;cw=vec3(cw):normalize()local cE=bz-cw;local cF=-cz(cE,core.getConstructWorldOrientationRight())*cD;local cG=-cz(cE,core.getConstructWorldOrientationUp())*cD;if aD==0 then aD=cF/2 end;if aE==0 then aE=cG/2 end;if c(cF)<0.1 then W=W-cF*5 else W=W-(cF+(cF-aD)*cy)end;if c(cG)<0.1 then V=V+cG*5 else V=V+cG+(cG-aE)*cy end;aD=cF;aE=cG;if c(cF)<cx and c(cG)<cx then return true end;return false end end;local function cH()if Reentry then a3="Re-Entry cancelled"bZ("reOff","RE")Reentry=false;bb=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a3="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"aj=5 elseif not S then Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bb=true;BrakeIsOn=false;a3="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bi;bZ("par","RE")else Reentry=true;AltitudeHold=true;bb=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local cc=cm(HoldAltitude)a3="Beginning Re-entry.  Target speed: "..bi.." Target Altitude: "..cc;bZ("glide","RE")ci(d(bi))end;AutoTakeoff=false end;local function cI()if antigrav and not ExternalAGG then if bI then bZ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=au end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bZ("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cJ(cK)local cL=0;local cM=0;local cN=0;if cK<60 then cK=d(cK)elseif cK<3600 then cL=d(cK/60)cK=d(cK%60)elseif cK<86400 then cM=d(cK/3600)cL=d(cK%3600/60)else cN=d(cK/86400)cM=d(cK%86400/3600)end;if cN>0 then return cN.."d "..cM.."h "elseif cM>0 then return cM.."h "..cL.."m "elseif cL>0 then return cL.."m "..cK.."s"elseif cK>0 then return cK.."s"else return"0s"end end;local function cO(cP)local function cQ(cR)for cS,cT in pairs(cR)do dbHud_1.setStringValue(cT,g(_G[cT]))if cP and dbHud_2 then dbHud_2.setStringValue(cT,g(_G[cT]))end end end;if dbHud_1 then cQ(b)cQ(c4())system.print("Saved Variables to Datacore")if cP and dbHud_2 then a3="Databank copied.  Remove copy when ready."end end end;local function cU()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function cV()local function cW(cX)return type(cX)=='number'end;local function cY(cX)return type(A(cX))=='number'end;local function cZ(c_)return type(c_)=='table'end;local function d0(d1)return type(d1)=='string'end;local function d2(cT)return cZ(cT)and cW(cT.x and cT.y and cT.z)end;local function d3(d4)return cZ(d4)and cW(d4.latitude and d4.longitude and d4.altitude and d4.bodyId and d4.systemId)end;local d5=math.pi/180;local d6=180/math.pi;local epsilon=1e-10;local C=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d7='::pos{'..C..','..C..','..C..','..C..','..C..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function d8(cX)local cB=string.gsub(string.reverse(e('%.4f',cX)),'^0*%.?','')return cB==''and'0'or string.reverse(cB)end;local function d9(da)if d2(da)then return e('{x=%.3f,y=%.3f,z=%.3f}',da.x,da.y,da.z)end;if cZ(da)and not getmetatable(da)then local db={}local dc=next(da)if type(dc)=='nil'or dc==1 then db=da else for cS,cT in pairs(da)do local cg=d9(cT)if type(cS)=='number'then table.insert(db,e('[%s]=%s',cS,cg))else table.insert(db,e('%s=%s',cS,cg))end end end;return e('{%s}',table.concat(db,','))end;if d0(da)then return e("'%s'",da:gsub("'",[[\']]))end;return tostring(da)end;local dd={}dd.__index=dd;dd.__tostring=function(da,de)local df={}for cS in pairs(da)do table.insert(df,cS)end;table.sort(df)local db={}for _,cS in ipairs(df)do local cg=d9(da[cS])if type(cS)=='number'then table.insert(db,e('[%s]=%s',cS,cg))else table.insert(db,e('%s=%s',cS,cg))end end;if de then return e('%s%s',de,table.concat(db,',\n'..de))end;return e('{%s}',table.concat(db,','))end;dd.__eq=function(dg,dh)return dg.planetarySystemId==dh.planetarySystemId and dg.bodyId==dh.bodyId and cj(dg.radius,dh.radius)and cj(dg.center.x,dh.center.x)and cj(dg.center.y,dh.center.y)and cj(dg.center.z,dh.center.z)and cj(dg.GM,dh.GM)end;local function di(dj,dk,dl,dm,dn)assert(cY(dj),'Argument 1 (planetarySystemId) must be a number:'..type(dj))assert(cY(dk),'Argument 2 (bodyId) must be a number:'..type(dk))assert(cY(dl),'Argument 3 (radius) must be a number:'..type(dl))assert(cZ(dm),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dm))assert(cY(dn),'Argument 5 (GM) must be a number:'..type(dn))return setmetatable({planetarySystemId=A(dj),bodyId=A(dk),radius=A(dl),center=vec3(dm),GM=A(dn)},dd)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dp)return e('::pos{%d,%d,%s,%s,%s}',dp.systemId,dp.bodyId,d8(dp.latitude*d6),d8(dp.longitude*d6),d8(dp.altitude))end;MapPosition.__eq=function(dg,dh)return dg.bodyId==dh.bodyId and dg.systemId==dh.systemId and cj(dg.latitude,dh.latitude)and cj(dg.altitude,dh.altitude)and(cj(dg.longitude,dh.longitude)or cj(dg.latitude,math.pi/2)or cj(dg.latitude,-math.pi/2))end;local function dq(dr,dk,ds,dt,du)local dj=dr;if d0(dr)and not dt and not du and not dk and not ds then dj,dk,ds,dt,du=n(dr,d7)assert(dj,'Argument 1 (position string) is malformed.')else assert(cY(dj),'Argument 1 (systemId) must be a number:'..type(dj))assert(cY(dk),'Argument 2 (bodyId) must be a number:'..type(dk))assert(cY(ds),'Argument 3 (latitude) must be in degrees:'..type(ds))assert(cY(dt),'Argument 4 (longitude) must be in degrees:'..type(dt))assert(cY(du),'Argument 5 (altitude) must be in meters:'..type(du))end;dj=A(dj)dk=A(dk)ds=A(ds)dt=A(dt)du=A(du)if dk==0 then return setmetatable({latitude=ds,longitude=dt,altitude=du,bodyId=dk,systemId=dj},MapPosition)end;return setmetatable({latitude=d5*q(ds,-90,90),longitude=d5*(dt%360),altitude=du,bodyId=dk,systemId=dj},MapPosition)end;local dv={}dv.__index=dv;dv.__tostring=function(da,de)local dw=de and de..'  'local dx={}local df={}for cS in pairs(da)do table.insert(df,cS)end;table.sort(df)for _,dy in ipairs(df)do bdy=da[dy]local dz=dd.__tostring(bdy,dw)if de then table.insert(dx,e('[%s]={\n%s\n%s}',dy,dz,de))else table.insert(dx,e('  [%s]=%s',dy,dz))end end;if de then return e('\n%s%s%s',de,table.concat(dx,',\n'..de),de)end;return e('{\n%s\n}',table.concat(dx,',\n'))end;local function dA(dB)local aY={}local pid;for _,cT in pairs(dB)do local dC=cT.planetarySystemId;if type(dC)~='number'then error('Invalid planetary system ID: '..tostring(dC))elseif pid and dC~=pid then error('Mistringmatch planetary system IDs: '..dC..' and '..pid)end;local dD=cT.bodyId;if type(dD)~='number'then error('Invalid body ID: '..tostring(dD))elseif aY[dD]then error('Duplicate body ID: '..tostring(dD))end;setmetatable(cT.center,getmetatable(vec3.unit_x))aY[dD]=setmetatable(cT,dd)pid=dC end;return setmetatable(aY,dv)end;b1={}local function dE(dB)return setmetatable({galaxyAtlas=dB or{}},b1)end;b1.__index=function(c_,i)if type(i)=='number'then local system=c_.galaxyAtlas[i]return dA(system)end;return rawget(b1,i)end;b1.__pairs=function(da)return function(c_,cS)local dF,nv=next(c_,cS)return dF,nv and dA(nv)end,da.galaxyAtlas,nil end;b1.__tostring=function(da)local dG={}for _,dH in pairs(da or{})do local dI=dH:getPlanetarySystemId()local dJ=dv.__tostring(dH,'    ')table.insert(dG,e('  [%s]={%s\n  }',dI,dJ))end;return e('{\n%s\n}\n',table.concat(dG,',\n'))end;b1.BodyParameters=di;b1.MapPosition=dq;b1.PlanetarySystem=dA;function b1.createBodyParameters(dK,dk,dL,dM,dN,dO,dP)assert(cY(dK),'Argument 1 (planetarySystemId) must be a number:'..type(dK))assert(cY(dk),'Argument 2 (bodyId) must be a number:'..type(dk))assert(cY(dL),'Argument 3 (surfaceArea) must be a number:'..type(dL))assert(cZ(dM),'Argument 4 (aPosition) must be an array or vec3:'..type(dM))assert(cZ(dN),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dN))assert(cY(dO),'Argument 6 (altitude) must be in meters:'..type(dO))assert(cY(dP),'Argument 7 (gravityAtPosition) must be number:'..type(dP))local dl=z(dL/4/math.pi)local ak=dl+dO;local dQ=vec3(dM)+ak*vec3(dN)local dn=dP*ak*ak;return di(dK,dk,dl,dQ,dn)end;b1.isMapPosition=d3;function b1:getPlanetarySystem(dr)if i==nil then i=0 end;if nv==nil then nv=0 end;local dK=dr;if d3(dr)then dK=dr.systemId end;if type(dK)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dv then system=dA(system)end;return system end end end;function dv:sizeCalculator(dR)return 1.05*dR.radius end;function dv:castIntersections(dS,cA,dT,dU,dV,dW)local dX={}local dY=dV or self;for _,dR in pairs(dY)do table.insert(dX,dR)end;if not dW then table.sort(dX,function(dZ,d_)return(dZ.center-dS):len()<(d_.center-dS):len()end)end;local e0=cA:normalize()for _,dR in ipairs(dX)do local e1=dR.center-dS;local dl=self:sizeCalculator(dR)local e2=e1:dot(e0)local e3=e2^2-(e1:len2()-dl^2)if e3>=0 then local e4=z(e3)local e5=e2+e4;local e6=e2-e4;if e6>0 then return dR,e5,e6 elseif e5>0 then return dR,e5,nil end end end;return nil,nil,nil end;function dv:closestBody(e7)assert(type(e7)=='table','Invalid coordinates.')local e8,dR;local e9=vec3(e7)for _,ea in pairs(self)do local eb=(ea.center-e9):len2()if(not dR or eb<e8)and ea.name~="Space"then dR=ea;e8=eb end end;return dR end;function dv:convertToBodyIdAndWorldCoordinates(dr)local ec=dr;if d0(dr)then ec=dq(dr)end;if ec.bodyId==0 then return 0,vec3(ec.latitude,ec.longitude,ec.altitude)end;local ea=self:getBodyParameters(ec)if ea then return ec.bodyId,ea:convertToWorldCoordinates(ec)end end;function dv:getBodyParameters(dr)local dk=dr;if d3(dr)then dk=dr.bodyId end;assert(cY(dk),'Argument 1 (bodyId) must be a number:'..type(dk))return self[dk]end;function dv:getPlanetarySystemId()local _,cT=next(self)return cT and cT.planetarySystemId end;function dd:convertToMapPosition(dm)assert(cZ(dm),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dm))local ed=vec3(dm)if self.bodyId==0 then return setmetatable({latitude=ed.x,longitude=ed.y,altitude=ed.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local ee=ed-self.center;local ak=ee:len()local du=ak-self.radius;local ds=0;local dt=0;if not cj(ak,0)then local ef=m(ee.y,ee.x)dt=ef>=0 and ef or 2*math.pi+ef;ds=math.pi/2-math.acos(ee.z/ak)end;return setmetatable({latitude=ds,longitude=dt,altitude=du,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dd:convertToWorldCoordinates(dr)local ec=d0(dr)and dq(dr)or dr;if ec.bodyId==0 then return vec3(ec.latitude,ec.longitude,ec.altitude)end;assert(d3(ec),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(ec.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(ec.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local eg=math.cos(ec.latitude)return self.center+(self.radius+ec.altitude)*vec3(eg*math.cos(ec.longitude),eg*math.sin(ec.longitude),math.sin(ec.latitude))end;function dd:getAltitude(dm)return(vec3(dm)-self.center):len()-self.radius end;function dd:getDistance(dm)return(vec3(dm)-self.center):len()end;function dd:getGravity(dm)local eh=self.center-vec3(dm)local ei=eh:len2()return self.GM/ei*eh/z(ei)end;return setmetatable(b1,{__call=function(_,...)return dE(...)end})end;local function ej()local b3={}local ek=30000000/3600;local el=ek*ek;local em=100;local function en(cT)return 1/z(1-cT*cT/el)end;function b3.computeAccelerationTime(eo,ep,eq)local er=ek*math.asin(eo/ek)return(ek*math.asin(eq/ek)-er)/ep end;function b3.computeDistanceAndTime(eo,eq,es,et,eu,ev)eu=eu or 0;ev=ev or 0;local ew=eo<=eq;local ex=et*(ew and 1 or-1)/es;local ey=-ev/es;local ez=ex+ey;if ew and ez<=0 or not ew and ez>=0 then return-1,-1 end;local eA,eB=0,0;if ex~=0 and eu>0 then local er=math.asin(eo/ek)local eC=math.pi*(ex/2+ey)local eD=ex*eu;local eE=ek*math.pi;local cT=function(c_)local eF=(eC*c_-eD*math.sin(math.pi*c_/2/eu)+eE*er)/eE;local eG=math.tan(eF)return ek*eG/z(eG*eG+1)end;local eH=ew and function(d1)return d1>=eq end or function(d1)return d1<=eq end;eB=2*eu;if eH(cT(eB))then local eI=0;while c(eB-eI)>0.5 do local c_=(eB+eI)/2;if eH(cT(c_))then eB=c_ else eI=c_ end end end;local eJ=eo;local eK=eB/em;for eL=1,em do local eM=cT(eL*eK)eA=eA+(eM+eJ)*eK/2;eJ=eM end;if eB<2*eu then return eA,eB end;eo=eJ end;local er=ek*math.asin(eo/ek)local E=(ek*math.asin(eq/ek)-er)/ez;local eN=el*math.cos(er/ek)/ez;local ak=eN-el*math.cos((ez*E+er)/ek)/ez;return ak+eA,E+eB end;function b3.computeTravelTime(eo,ep,ak)if ak==0 then return 0 end;if ep>0 then local er=ek*math.asin(eo/ek)local eN=el*math.cos(er/ek)/ep;return(ek*math.acos(ep*(eN-ak)/el)-er)/ep end;if eo==0 then return-1 end;assert(eo>0,'Acceleration and initial speed are both zero.')return ak/eo end;function b3.lorentz(cT)return en(cT)end;return b3 end;local function eO()local vec3=require('cpml.vec3')local cV=cV()local function d0(d1)return type(d1)=='string'end;local function cZ(c_)return type(c_)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(du)assert(self.body)local ak=du+self.body.radius;if not cj(ak,0)then local orbit=z(self.body.GM/ak)return z(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dr,eP)assert(self.body)assert(cZ(dr)or d0(dr))assert(cZ(eP))local eQ=(d0(dr)or cV.isMapPosition(dr))and self.body:convertToWorldCoordinates(dr)or vec3(dr)local cT=vec3(eP)local eR=eQ-self.body.center;local eS=cT:len2()local eT=eR:len()local eU=self.body.GM;local eV=((eS-eU/eT)*eR-eR:dot(cT)*cT)/eU;local ck=eU/(2*eU/eT-eS)local eW=eV:len()local e0=eV:normalize()local eX=ck*(1-eW)local eY=ck*(1+eW)local eZ=eX*e0+self.body.center;local e_=eW<=1 and-eY*e0+self.body.center or nil;local f0=z(ck*eU*(1-eW*eW))local f1=e_ and 2*math.pi*z(ck^3/eU)local f2=math.acos(eV:dot(eR)/(eW*eT))if eR:dot(cT)<0 then f2=-(f2-2*math.pi)end;local f3=math.acos((math.cos(f2)+eW)/(1+eW*math.cos(f2)))local f4=f3;if f4<0 then f4=f4+2*math.pi end;local f5=f4-eW*math.sin(f4)local f6=0;local f7=0;local f8=0;if f1~=nil then f6=f5/(2*math.pi/f1)f7=f1-f6;f8=f7+f1/2;if f2-math.pi>0 then f7=f6;f8=f7+f1/2 end;if f8>f1 then f8=f8-f1 end end;return{periapsis={position=eZ,speed=f0/eX,circularOrbitSpeed=z(eU/eX),altitude=eX-self.body.radius},apoapsis=e_ and{position=e_,speed=f0/eY,circularOrbitSpeed=z(eU/eY),altitude=eY-self.body.radius},currentVelocity=cT,currentPosition=eQ,eccentricity=eW,period=f1,eccentricAnomaly=f3,meanAnomaly=f5,timeToPeriapsis=f7,timeToApoapsis=f8}end;local function f9(fa)local ea=cV.BodyParameters(fa.planetarySystemId,fa.bodyId,fa.radius,fa.center,fa.GM)return setmetatable({body=ea},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return f9(...)end})end;local function fb()local fc=0;local function fd(fe)local dl=500000;local ff,fg,fh=math.huge;local fi=false;local fj=vec3({13771471,7435803,-128971})local fk=18000000;ff=vec3(fe):dist(fj)if ff<fk then return true,c(ff-fk),"Safe Zone",0 end;fg=vec3(fe):dist(vec3(planet.center))if fg<dl then fi=true end;if c(fg-dl)<c(ff-fk)then return fi,c(fg-dl),planet.name,planet.bodyId else return fi,c(ff-fk),"Safe Zone",0 end end;local function fl(cT)if aI==1920 then return cT else return B(aI*cT/1920,0)end end;local function fm(cT)if aJ==1080 then return cT else return B(aJ*cT/1080,0)end end;local function fn()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function fo()local fp="TRAVEL"if not bK then fp="CRUISE"end;if Autopilot then fp="AUTOPILOT"end;return fp end;local function fq(fr,aW,x,fs,ft,fu,fv,fw)local fx=1;local fy=2;local fz=3;local fA=4;local fB=5;local fC=6;local fD=""local fE=0;local fF=fuelY;local fG=fuelY+5;if not BarFuelDisplay then fG=fG+5 end;if l()==1 and not RemoteHud then fF=fF-50;fG=fG-50 end;if ft=="ATMO"then fD="atmofueltank"elseif ft=="SPACE"then fD="spacefueltank"else fD="rocketfueltank"end;fE=_G[fD.."_size"]if#fu>0 then for i=1,#fu do local fH=string.sub(fu[i][fy],1,12)local fI=0;for fJ=1,fE do if fu[i][fy]==f(unit[fD.."_"..fJ].getData()).name then fI=fJ;break end end;if aW or fv[i]==nil or fw[i]==nil then local fK=0;local fL=0;local fM=0;local fN=0;local fO=p()if fI~=0 then fw[i]=f(unit[fD.."_"..fI].getData()).percentage;fv[i]=f(unit[fD.."_"..fI].getData()).timeLeft;if fv[i]=="n/a"then fv[i]=0 end else fM=k(fu[i][fx])-fu[i][fA]fK=fu[i][fz]fw[i]=d(0.5+fM*100/fK)fL=fu[i][fB]fN=fu[i][fC]if fL<=fM then fv[i]=0 else fv[i]=d(0.5+fM/((fL-fM)/(fO-fN)))end;fu[i][fB]=fM;fu[i][fC]=fO end end;if fH==fs then fH=e("%s %d",ft,i)end;if fI==0 then fH=fH.." *"end;local fP;if fv[i]==0 then fP=""else fP=cJ(fv[i])end;if fw[i]~=nil then local fQ=d(fw[i]*2.55)local fR=e("rgb(%d,%d,%d)",255-fQ,fQ,0)local cd=""if fP~=""and fv[i]<120 or fw[i]<5 then if aW then cd=[[class="red"]]end end;if BarFuelDisplay then table.insert(fr,e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],x,fG,fR,fw[i],x,fG,x+2,fG+10,fw[i],fP))fr[#fr+1]=cb(x,fF,fH,cd.."txtstart pdim txtfuel")fF=fF-30;fG=fG-30 else fr[#fr+1]=cb(x,fF,fH,cd.." pdim txtfuel")fr[#fr+1]=cb(x,fG,e("%d%% %s",fw[i],fP),"pdim txtfuel","fill:"..fR)fF=fF+30;fG=fG+30 end end end end end;local function fS(fr,du)if du<200000 and not as or du and as then local fT=0;if c(bE)>1 then fT=45*math.log(c(bE),10)if bE<0 then fT=-fT end end;fr[#fr+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bE),d(fT))end;return fr end;local function fU(fV)local fW=-bD;fV=fV-fV:project_on(fW)local fX=vec3(0,0,1)fX=fX-fX:project_on(fW)local fY=fX:cross(fW)local fT=fX:angle_between(fV)*constants.rad2deg;if fV:dot(fY)<0 then fT=360-fT end;return fT end;local function fZ(fr,centerX,centerY,f_,g0,bW)local g1=circleRad;local g2=20;local g3=d(f_)if bW then for i=-45,45,5 do local g4=i;fr[#fr+1]=e([[<g transform="rotate(%f,%d,%d)">]],g4,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fr[#fr+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+g1+g2-len,centerX,centerY+g1+g2)end;fr[#fr+1]=cb(centerX,centerY+g1+g2-35,g0,"pdim txt txtmid")fr[#fr+1]=cb(centerX,centerY+g1+g2-25,g3 .." deg","pdim txt txtmid")fr[#fr+1]=e([[<g transform="rotate(%f,%d,%d)">]],-f_,centerX,centerY)fr[#fr+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+g1+g2-20,centerX+5,centerY+g1+g2-20,centerX,centerY+g1+g2-15)fr[#fr+1]="</g>"end;local g5=g3;if bW then g5=fU(bz)end;local g6=20;local g7=d(g5)local g8=0;local g9=centerY+g1+g2+20;local ga=centerX;if g0~="YAW"then g9=fm(130)ga=fl(960)end;local gb=[[<path class="txttick line" d="]]local gc=d(g7-(g6+10)-g7%5+0.5)for i=gc+60,gc,-5 do local x=ga-(-i*5+g5*5)if i%10==0 then g8=10;local C=i;if C==360 then C=0 elseif C>360 then C=C-360 elseif C<0 then C=C+360 end;fr[#fr+1]=cb(x+5,g9-12,C)elseif i%5==0 then g8=5 end;if g8==10 then gb=e([[%s M %f %f v %d]],gb,x,g9-5,g8)else gb=e([[%s M %f %f v %d]],gb,x,g9-2.5,g8)end end;fr[#fr+1]=gb..[["/>]]fr[#fr+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ga-5,g9+10,ga+5,g9+10,ga,g9+5)if bW then g0="HDG"end;fr[#fr+1]=cb(ga,g9+25,g7 .."deg","pdim txt txtmid","")fr[#fr+1]=cb(ga,g9+35,g0,"pdim txt txtmid","")end;local function gd(fr,ge,f_,centerX,centerY,bW,gf,eM)local g1=circleRad;local gg=d(g1*3/5)if g1>0 then local gh=d(ge)local len=0;local gb=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*f_,centerX,centerY)if not as then gb=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fr[#fr+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],g1-1,centerX,centerY)fr[#fr+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gh-30-gh%5+0.5),d(gh+30+gh%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local y=centerY+-i*5+ge*5;if len==30 then gb=e([[%s M %d %f h %d]],gb,centerX-gg-len,y,len)if as then fr[#fr+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*f_,centerX,centerY,centerX-gg+10,y,i)fr[#fr+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*f_,centerX,centerY,centerX+gg-10,y,i)if i==0 or i==180 or i==-180 then fr[#fr+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*f_,centerX,centerY,centerX-gg+20,y,gg*2-40)end else fr[#fr+1]=cb(centerX-gg+10,y,i,"pdim txt txtmid")fr[#fr+1]=cb(centerX+gg-10,y,i,"pdim txt txtmid")end;gb=e([[%s M %d %f h %d]],gb,centerX+gg,y,len)else gb=e([[%s M %d %f h %d]],gb,centerX-gg-len,y,len)gb=e([[%s M %d %f h %d]],gb,centerX+gg,y,len)end end;fr[#fr+1]=gb..[["/>]]local gi="PITCH"if not bW then gi="REL PITCH"end;if ge>90 and not as then ge=90-(ge-90)elseif ge<-90 and not as then ge=-90-(ge+90)end;if g1>200 then if as then if eM>R then fr[#fr+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")fr[#fr+1]=cb(centerX,centerY+20,gf,"pdim txt txtmid")end;fr[#fr+1]=e([[<g transform="rotate(%f,%d,%d)">]],-f_,centerX,centerY)else fr[#fr+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fr[#fr+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gg+25,centerY-5,centerX-gg+20,centerY,centerX-gg+25,centerY+5,centerX-gg+50,centerY+4,gh)fr[#fr+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gg-25,centerY-5,centerX+gg-20,centerY,centerX+gg-25,centerY+5,centerX+gg-30,centerY+4,gh)fr[#fr+1]="</g>"end;local gj=d(g1/3)fr[#fr+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gj,centerY,g1-gj)if not as and bW then fr[#fr+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*f_,centerX,centerY,centerX-gg+10,centerY,gg*2-20)end;fr[#fr+1]="</g>"if g1<200 then if as and eM>R then fr[#fr+1]=cb(centerX,centerY-g1,gi,"pdim txt txtmid")fr[#fr+1]=cb(centerX,centerY-g1+10,gh,"pdim txt txtmid")fr[#fr+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")fr[#fr+1]=cb(centerX,centerY+20,gf,"pdim txt txtmid")else fr[#fr+1]=cb(centerX,centerY-g1,gi,"pdim txt txtmid")fr[#fr+1]=cb(centerX,centerY-g1+15,gh,"pdim txt txtmid")end end end end;local function gk(fr,du,bW)local gl=altMeterX;local gm=altMeterY;local gn=78;local go=19;local gp=aq;if aq~=-1 then fr[#fr+1]=cb(gl+gn,gm+go+20,e("AGL: %.1fm",aq),"pdim altsm txtend")end;if bW and(du<200000 and not as or du and as)then table.insert(fr,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gl-1,gm-4,gn+2,go+6,gl+1,gm-1,gn-4,go))local gq=0;local gr=1;local gs=0;local gt=du<0;local gu=du<planet.surfaceMaxAltitude;local gv=9;if gt then gv=0 end;local du=c(du)while gq<6 do local gw=11;local gx=16;local gy=9;local gz=14;local cd="altsm"if gq>2 then gx=gx+3;gw=gw+2;gz=gz+2;gy=gy-6;cd="altbig"end;if gt then cd=cd.." red"elseif gu then cd=cd.." orange"end;local gA=du/gr%10;local gB=d(gA)local gC=d((gB+1)%10)local gD=gs;if gq==0 then gD=gA-gB;if gt then gD=1-gD end end;if gt and(gq==0 or gs~=0)then local gE=gC;gC=gB;gB=gE end;local gF=gx*(gD-1)local gG=gF+gx;local x=gl+gy+(6-gq)*gw;local y=gm+gz;fr[#fr+1]=cb(x,y+gF,gC,cd)fr[#fr+1]=cb(x,y+gG,gB,cd)gq=gq+1;gr=gr*10;if gB==gv then gs=gD else gs=0 end end;table.insert(fr,[[</g></g>]])end end;local function gH(eP)eP=vec3(eP)local gI=-math.deg(m(eP.y,eP.z))+180;gI=gI-90;if gI<0 then gI=360+gI end;if gI>180 then gI=-180+gI-180 end;return-gI end;local function gJ(eP)eP=vec3(eP)local g5=math.deg(m(eP.y,eP.x))-90;if g5<-180 then g5=360+g5 end;return g5 end;local function gK(fr,eP,eM,centerX,centerY)if eM>5 and not as or eM>R then local g1=circleRad;local gL=20;local gM=20;local gN=vec3(eP)local gO=gH(gN)local gP=gJ(gN)local gQ=14;local gR=gQ/2;local gS=-gP/gM*g1;local gT=gO/gL*g1;local x=centerX+gS;local y=centerY+gT;local ak=z(gS^2+gT^2)local gU=[[<circle
                            cx="]]..x..[["
                            cy="]]..y..[["
                            r="]]..gR/gQ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..x..[["
                            cy="]]..y..[["
                            r="]]..gR..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..x-gQ..[[,]]..y..[[ h ]]..gR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..x+gR..[[,]]..y..[[ h ]]..gR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..x..[[,]]..y-gQ..[[ v ]]..gR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ak<g1 then fr[#fr+1]=gU else local fT=m(gT,gS)local gV=4;local gW=centerX+g1*math.cos(fT)local gX=centerY+g1*math.sin(fT)fr[#fr+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',fT*180/math.pi,gW,gX,gW-gV,gX-gV/2,gV*2,gV,gW+gV,gX-gV,gV,gV,-gV,gV)end;if not as then gO=gH(-gN)gP=gJ(-gN)gS=-gP/gM*g1;gT=gO/gL*g1;x=centerX+gS;y=centerY+gT;ak=z(gS^2+gT^2)if ak<g1 then local gY=[[<circle
                                    cx="]]..x..[["
                                    cy="]]..y..[["
                                    r="]]..gR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..x..[[,]]..y-gQ..[[ v ]]..gR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..x..[[,]]..y..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..x..[[,]]..y..[[)" />
                                <path
                                    d="M ]]..x-gR..[[,]]..y..[[ h ]]..gQ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..x..[[,]]..y..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..x..[[,]]..y..[[)"/>]]fr[#fr+1]=gY end end end end;local function gZ(fr,fp,g_,h0)g_=d(g_+0.5)local fF=throtPosY+10;local fG=throtPosY+20;if l()==1 and not RemoteHud then fF=55;fG=65 end;local h1="CRUISE"local unit="km/h"local cg=h0;if fp=="TRAVEL"or fp=="AUTOPILOT"then h1="THROT"unit="%"cg=g_;local h2="dim"if g_<0 then h2="red"end;fr[#fr+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],h2,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(g_),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fr[#fr+1]=cb(throtPosX+10,fF,h1,"pbright txtstart")fr[#fr+1]=cb(throtPosX+10,fG,e("%.0f %s",cg,unit),"pbright txtstart")if as and AtmoSpeedAssist and bK and N then g_=d(O*100+0.5)local h2="red"if g_<0 then h2="red"end;fr[#fr+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],h2,1-c(g_),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fr[#fr+1]=cb(throtPosX+10,fF+40,"LIMIT","pbright txtstart")fr[#fr+1]=cb(throtPosX+10,fG+40,g_.."%","pbright txtstart")end;if as and AtmoSpeedAssist or Reentry then fr[#fr+1]=cb(throtPosX+10,fF-40,"LIMIT: "..bi.." km/h","dim txtstart")elseif not as and Autopilot then fr[#fr+1]=cb(throtPosX+10,fF-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function h3(fr,h4)local h5=throtPosY-10;local h6=throtPosX+10;fr[#fr+1]=cb(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then h5=75 end;fr[#fr+1]=cb(h6,h5,d(h4).." km/h","pbright txtbig txtstart")end;local function h7(fr)fr[#fr+1]=cb(fl(1900),fm(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fr[#fr+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fr[#fr+1]=cb(fl(960),fm(550),"Warning: Invalid Control Scheme Detected","warnings")fr[#fr+1]=cb(fl(960),fm(600),"Keyboard Scheme must be selected","warnings")fr[#fr+1]=cb(fl(960),fm(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local h8=fl(960)local h9=fm(860)local ha=fm(880)local hb=fm(900)local hc=fm(960)local hd=fm(200)local he=fm(250)local hf=fm(960)if l()==1 and not RemoteHud then h9=fm(135)ha=fm(155)hb=fm(175)hd=fm(115)he=fm(95)end;if BrakeIsOn then fr[#fr+1]=cb(h8,h9,"Brake Engaged","warnings")elseif M>0 then fr[#fr+1]=cb(h8,h9,"Auto-Brake Engaged","warnings","opacity:"..M)end;if as and bd and aq==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bI and not VertTakeOff and not AutoTakeoff then fr[#fr+1]=cb(h8,hd+50,"** STALL WARNING **","warnings")bZ("stall","SW",2)end end;if bU then fr[#fr+1]=cb(h8,hd+90,"Flight Assist in Progress","warnings")end;if az then fr[#fr+1]=cb(h8,hf,"Gyro Enabled","warnings")end;if GearExtended then if T then fr[#fr+1]=cb(h8,ha,"Gear Extended","warn")else fr[#fr+1]=cb(h8,ha,"Landed (G: Takeoff)","warnings")end;local hg=cm(a:getTargetGroundAltitude())fr[#fr+1]=cb(h8,hb,"Hover Height: "..hg,"warn")end;if a8 then fr[#fr+1]=cb(h8,hc+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bI and AntigravTargetAltitude~=nil then if c(au-antigrav.getBaseAltitude())<501 then fr[#fr+1]=cb(h8,hd+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fr[#fr+1]=cb(h8,hd+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fr[#fr+1]=cb(h8,hd+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fr[#fr+1]=cb(h8,hd+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif a1 then fr[#fr+1]=cb(h8,hd+20,"Follow Mode Engaged","warn")elseif Reentry then fr[#fr+1]=cb(h8,hd+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local hg=cm(HoldAltitude,2)if VertTakeOff then if bI then hg=cm(antigrav.getBaseAltitude(),2).." AGG singularity height"end;fr[#fr+1]=cb(h8,hd,"VTO to "..hg,"warn")elseif AutoTakeoff and not IntoOrbit then if ao then fr[#fr+1]=cb(h8,hd,"Takeoff to "..AutopilotTargetName,"warn")else fr[#fr+1]=cb(h8,hd,"Takeoff to "..hg,"warn")end;if BrakeIsOn and not VertTakeOff then fr[#fr+1]=cb(h8,hd+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fr[#fr+1]=cb(h8,hd,"Altitude Hold: "..hg,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if at>0.1 then fr[#fr+1]=cb(h8,hd+20,"Beginning ascent","warn")elseif at<0.09 and at>0.05 then fr[#fr+1]=cb(h8,hd+20,"Aligning trajectory","warn")elseif at<0.05 then fr[#fr+1]=cb(h8,hd+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bk~=nil then fr[#fr+1]=cb(h8,hd,bk,"warn")end end;if IntruderAlertSystem and safeMass==-1 then fr[#fr+1]=cb(h8,hd+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bG.."kg DETECTED","warnings")bZ("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then fr[#fr+1]=cb(h8,hd,"Brake-Landing","warnings")else fr[#fr+1]=cb(h8,hd,"Coast-Landing","warnings")end end;if ProgradeIsOn then fr[#fr+1]=cb(h8,hd,"Prograde Alignment","crit")end;if RetrogradeIsOn then fr[#fr+1]=cb(h8,hd,"Retrograde Alignment","crit")end;if bX then local type;if string.find(bX,"COLLISION")then type="warnings"else type="crit"end;fr[#fr+1]=cb(h8,he+20,bX,type)elseif at==0 then local hh,e5,e6=b2:getPlanetarySystem(0):castIntersections(bF,bB:normalize(),function(dR)if dR.noAtmosphericDensityAltitude>0 then return dR.radius+dR.noAtmosphericDensityAltitude else return dR.radius+dR.surfaceMaxAltitude*1.5 end end)local hi=e5;if e6~=nil and e5~=nil then hi=math.min(e6,e5)end;if hi~=nil then local hg=cm(hi)local travelTime=b3.computeTravelTime(bC,0,hi)local hj="Collision"if hh.noAtmosphericDensityAltitude>0 then hj="Atmosphere"end;fr[#fr+1]=cb(h8,he+20,hh.name.." "..hj.." "..cJ(travelTime).." In "..hg,"crit")end end;if VectorToTarget and not IntoOrbit then fr[#fr+1]=cb(h8,hd+35,VectorStatus,"warn")end;fr[#fr+1]="</g>"return fr end;local function hk(eM)return d(B(eM*3.6,0)+0.5).." km/h"end;local function hl(fr)local hm=OrbitMapX;local hn=OrbitMapY;local ho=OrbitMapSize;local hp=4;local hq=15;local x=0;local y=0;local hr,hs,ht,hu;local function hv(type)local hw,E,eM,hx;if type=="Periapsis"then hw=orbit.periapsis.altitude;E=orbit.timeToPeriapsis;eM=orbit.periapsis.speed;hx=35 else hw=orbit.apoapsis.altitude;E=orbit.timeToApoapsis;eM=orbit.apoapsis.speed;hx=-35 end;fr[#fr+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],x+hx,y-5,hm+ho/2-hr+hu,y-5)fr[#fr+1]=cb(x,y,type)y=y+hq;local hg=cm(hw)fr[#fr+1]=cb(x,y,hg)y=y+hq;fr[#fr+1]=cb(x,y,cJ(E))y=y+hq;fr[#fr+1]=cb(x,y,hk(eM))end;if orbit~=nil and at<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hn=hn+hp;x=hm+ho+hm/2+hp;y=hn+ho/2+5+hp;hr=ho/4;hu=0;fr[#fr+1]=[[<g class="pbright txtorb txtmid">]]fr[#fr+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',ho+hm*2,ho+hn,hp,hp)if orbit.periapsis~=nil and orbit.apoapsis~=nil then ht=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hr*2)hs=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/ht*(1-orbit.eccentricity)hu=hr-orbit.periapsis.altitude/ht-planet.radius/ht;local hy=""if orbit.periapsis.altitude<=0 then hy='redout'end;fr[#fr+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hy,hm+ho/2+hu+hp,hn+ho/2+hp,hr,hs)fr[#fr+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hm+ho/2+hp,hn+ho/2+hp,planet.radius/ht)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hv("Apoapsis")end;y=hn+ho/2+5+hp;x=hm-hm/2+10+hp;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hv("Periapsis")end;fr[#fr+1]=cb(hm+ho/2+hp,planet.name,20+hp,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hz=orbit.timeToApoapsis/orbit.period*2*math.pi;local hA=hr*math.cos(hz)local hB=hs*math.sin(hz)fr[#fr+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hm+ho/2+hA+hu+hp,hn+ho/2+hB+hp)end;fr[#fr+1]=[[</g>]]return fr else return fr end end;local hC;local function hD()if radarPanelID~=nil and am==0 then s(radarPanelID)radarPanelID=nil;if hC~=nil then s(hC)hC=nil end else if am==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")hC=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;am=0 end end;local function hE(fr)local x=30;local y=275;local hF={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hG={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local hH={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local hI={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and offset","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if as then c1(hF,hG)table.insert(hF,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(hF,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if aq~=-1 then if antigrav then if bI then table.insert(hF,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hF,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hF,"Alt-6: Begins Vertical Takeoff.")else table.insert(hF,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hF,"G: Begin BrakeLanding or Land")end else c1(hF,hH)end;if AltitudeHold then table.insert(hF,"Alt-Spacebar/Alt-C will raise/lower target height")end;c1(hF,hI)for i=1,#hF do y=y+12;fr[#fr+1]=cb(x,y,hF[i],"pdim txttick txtstart")end end;local function hJ(hK,hL)local hM;local hN=(hL-hK):normalize()local eR=(bF-hK):dot(hN)/hN:dot(hN)if eR<=0.then return(bF-hK):len()elseif eR>=(hL-hK):len()then return(bF-hL):len()end;local hO=hK+eR*hN;hM=(hO-bF):len()return hM end;local function hP()local hM;local hQ=nil;local hR=nil;local hS=nil;for cS,hT in pairs(aY[0])do if hT.hasAtmosphere then local ak=hJ(planet.center,hT.center)if hQ==nil or ak<hQ then hR=hT;hQ=ak;hS=planet end;if ad and ad.hasAtmosphere and ad.name~=planet.name then local eb=hJ(ad.center,hT.center)if eb<hQ then hR=hT;hQ=eb;hS=ad end end end end;local hU=fl(1770)local hV=fm(330)if hQ then local hW="txttick "local hX=500000;if hQ<hR.radius+hX or hQ<hS.radius+hX then if bR then hW="txttick red "else hW="txttick orange "end end;hM=cm(hQ,2)bT=cb(hU,hV,"Pipe ("..hS.name.."--"..hR.name.."): "..hM,hW.."pbright txtmid")end end;local hY=fl(1770)local hZ=fm(350)local h_=fm(15)local i0=fl(1370)local i1,i2;local i3={}local i4={XS=13,S=27,M=55,L=110,XL=221}local i5={}local i6={}function i6.HUDPrologue(fr)bR,fc,_,_=fd(bF)if not bR then I=PvPR;K=PvPG;J=PvPB else I=SafeR;K=SafeG;J=SafeB end;aA=[[rgb(]]..d(I+0.5)..","..d(K+0.5)..","..d(J+0.5)..[[)]]aB=[[rgb(]]..d(I*0.9+0.5)..","..d(K*0.9+0.5)..","..d(J*0.9+0.5)..[[)]]local i7=aA;local i8=aB;local i9=aA;local ia=aB;if fn()and not brightHud then i7=[[rgb(]]..d(I*0.4+0.5)..","..d(K*0.4+0.5)..","..d(J*0.3+0.5)..[[)]]i8=[[rgb(]]..d(I*0.3+0.5)..","..d(K*0.3+0.5)..","..d(J*0.2+0.5)..[[)]]end;fr[#fr+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],i7,i7,i9,i9,i8,i8,ia,ia,aI,aJ)return fr end;function i6.DrawVerticalSpeed(fr,du)fS(fr,du)end;function i6.UpdateHud(fr)local du=au;local eP=core.getVelocity()local eM=vec3(eP):len()local gI=bL;local ib=bM;local f_=ib;local ge=bL;local g_=d(unit.getThrottle())local h4=eM*3.6;local h0=unit.getAxisCommandValue(0)local ic=fl(1770)local id=fm(310)if AtmoSpeedAssist and bK then h0=L;g_=L*100 end;local fp=fo()local g0="ROLL"if g_==nil then g_=0 end;if not bW then if eM>5 then gI=gH(eP)ib=gJ(eP)else gI=0;ib=0 end;g0="YAW"end;if fc>50000 and not as then local ie;if fc>200000 then ie=B(fc/200000,2).." su"else ie=B(fc/1000,1).." km"end;fr[#fr+1]=cb(ic,id,"PvP Boundary: "..ie,"pbright txtbig txtmid")end;fr[#fr+1]=al;fr[#fr+1]=aF;fr[#fr+1]=bS;if bT~=""then fr[#fr+1]=bT end;if aX%aR==0 then aW=true end;if fuelX~=0 and fuelY~=0 then fq(fr,aW,fuelX,"Atmospheric ","ATMO",aK,aU,aV)fq(fr,aW,fuelX+120,"Space fuel t","SPACE",aL,aS,aT)fq(fr,aW,fuelX+240,"Rocket fuel ","ROCKET",aM,aP,aQ)end;if aW then aW=false;aX=0 end;aX=aX+1;fS(fr,du)if l()==0 or RemoteHud then if not fn()or brightHud then if bW then fZ(fr,centerX,centerY,f_,g0,bW)gd(fr,ge,f_,centerX,centerY,bW,d(gJ(eP)),eM)else fZ(fr,centerX,centerY,ib,g0,bW)gd(fr,gI,ib,centerX,centerY,bW,d(ib),eM)end;gk(fr,du,bW)gK(fr,eP,eM,centerX,centerY)end end;gZ(fr,fp,g_,h0)h3(fr,h4)h7(fr)hl(fr)if showHelp then hE(fr)end;return fr end;function i6.HUDEpilogue(fr)fr[#fr+1]="</svg>"return fr end;function i6.ExtraData(fr)local ig=fl(1240)local ih=fm(55)local ii=ih+10;local ij;local ik=0;local fp=fo()if VertTakeOffEngine then fp=fp.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bC>20 then fp=fp.."-COLLISION ON"end;if TurnBurn then fp="TB-"..fp end;if not stablized then fp=fp.."-DeCoupled"end;local il=vec3(core.getWorldAcceleration()):len()/9.80665;ij=core.g()fr[#fr+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then ig=fl(1120)ih=fm(55)ii=ih+10 elseif as then local im=fl(770)fr[#fr+1]=cb(im,ih,"ATMOSPHERE","pdim txt txtend")fr[#fr+1]=cb(im,ii,e("%.2f",at),"pdim txt txtend","")end;fr[#fr+1]=cb(ig,ih,"GRAVITY","pdim txt txtend")fr[#fr+1]=cb(ig,ii,e("%.2f",ij/9.80665),"pdim txt txtend")fr[#fr+1]=cb(ig,ih+20,"ACCEL","pdim txt txtend")fr[#fr+1]=cb(ig,ii+20,e("%.2f",il),"pdim txt txtend")fr[#fr+1]=cb(fl(960),fm(180),fp,"txtbig txtmid")end;function i6.DrawOdometer(fr,ae,TotalDistanceTravelled,af)local ij;local io=0;local ip=0;local ik=0;if as then ik=LastMaxBrakeInAtmo else ik=LastMaxBrake end;maxThrust=a:maxForceForward()ij=core.g()if ij>0.1 then ip=ax*ij;io=maxThrust/ij end;fr[#fr+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fl(660),fl(700),fm(35),fl(960),fm(55),fl(1240),fm(35),fl(1280))if l()==0 or RemoteHud then fr[#fr+1]=cb(fl(700),fm(20),e("Trip: %.2f km",ae),"txtstart")fr[#fr+1]=cb(fl(700),fm(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fr[#fr+1]=cb(fl(830),fm(20),"Trip Time: "..cJ(af),"txtstart")fr[#fr+1]=cb(fl(830),fm(30),"Total Time: "..cJ(TotalFlightTime),"txtstart")fr[#fr+1]=cb(fl(970),fm(20),e("Mass: %.2f Tons",ax/1000),"txtstart")fr[#fr+1]=cb(fl(1240),fm(10),e("Max Brake: %.2f kN",ik/1000),"txtend")fr[#fr+1]=cb(fl(1240),fm(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if ij>0.1 then fr[#fr+1]=cb(fl(970),fm(30),e("Max Mass: %.2f Tons",io/1000),"txtstart")fr[#fr+1]=cb(fl(1240),fm(20),e("Req Thrust: %.2f kN",ip/1000),"txtend")else fr[#fr+1]=cb(fl(970),fm(30),"Max Mass: n/a","txtstart")fr[#fr+1]=cb(fl(1240),fm(20),"Req Thrust: n/a","txtend")end end;fr[#fr+1]="</g>"return fr end;function i6.DrawWarnings(fr)return h7(fr)end;function i6.DisplayOrbitScreen(fr)return hl(fr)end;function i6.DisplayMessage(fr,hg)if hg~="empty"then local y=310;for iq in string.gmatch(hg,"([^\n]+)")do y=y+35;fr[#fr+1]=cb("50%",y,iq,"msg")end end;if aj~=0 then unit.setTimer("msgTick",aj)aj=0 end end;function i6.DrawDeadZone(fr)fr[#fr+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function i6.UpdatePipe()if as then bT=""return end;hP()end;function i6.UpdateRadarRoutine()local function ir(is,it,iu,iv,iw,ix,iy,iz)it,iv,ix,iz=vec3(it),vec3(iv),vec3(ix),vec3(iz)local iA,iB,iC=is*is,iu*iu,iw*iw;local eS=iv-it;local iD=eS:normalize()local iE=eS:len()local iF=ix-it;local iG=(iF-iF:project_on(iD)):normalize()local iH,iI=iF:dot(iD),iF:dot(iG)local iJ=iH*iH+iI*iI;local iK=iD:cross(iG)local x=(iA-iB+iE*iE)/(2*iE)local y=(iA-iC+iJ-2*iH*x)/(2*iI)local d4=iA-x^2-y^2;local iL=z(d4)local iM=it+iD*x+iG*y+iK*iL;local iN=it+iD*x+iG*y-iK*iL;if c((iz-iM):len()-iy)<c((iz-iN):len()-iy)then return iM else return iN end end;local function iO()local function iP()local iQ=core.getConstructWorldOrientationRight()local eS=core.getConstructWorldOrientationForward()local iF=core.getConstructWorldOrientationUp()local iR=library.systemResolution3(iQ,eS,iF,{1,0,0})local iS=library.systemResolution3(iQ,eS,iF,{0,1,0})local iT=library.systemResolution3(iQ,eS,iF,{0,0,1})return function(iU)return library.systemResolution3(iR,iS,iT,iU)end end;local iV=iP()local iW=core.getConstructWorldPos()local eQ=core.getElementPositionById(1)local iX={eQ[1]-G,eQ[2]-G,eQ[3]-G}local iY=iV(iX)local iZ={iW[1]-iY[1],iW[2]-iY[2],iW[3]-iY[3]}return iZ end;local function i_(j0,eT,j1)local j2=j0.pts;local gq=#j2;local j3=j0.ref;if gq>3 then local j4,j5,j6,j7=j2[gq],j2[gq-1],j2[gq-2],j2[gq-3]j0.ref=j1;local eQ=ir(j4[1],j4[2],j5[1],j5[2],j6[1],j6[2],j7[1],j7[2])local x,y,iL=eQ.x,eQ.y,eQ.z;if x==x and y==y and iL==iL then x=x+j3[1]y=y+j3[2]iL=iL+j3[3]local j8=vec3(x,y,iL)if not j0.lastPos then j0.center=j8 elseif(j0.lastPos-j8):len()<2 then j0.center=j8;j0.skipCalc=true end;j0.lastPos=j8 end;j0.pts={}else local j9={j1[1]-j3[1],j1[2]-j3[2],j1[3]-j3[3]}j2[gq+1]={eT,j9}end end;if radar_1 then local ja=#radar_1.getEntries()local jb=radar_1.getData()local jc=jb:gmatch('{"constructId[^}]*}[^}]*}')if ja>0 then local j1=iO()local jd,je,jf=0,0,0;for cT in jc do local dC,ak,jg=cT:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local jh=i4[jg]ak=A(ak)if radar_1.hasMatchingTransponder(dC)==1 then table.insert(i3,dC)end;local ji=radar_1.getConstructType(dC)if CollisionSystem then if jh>27 or ji=="static"or ji=="space"then jf=jf+1;local fH=radar_1.getConstructName(dC)local j0=bV[dC]if j0==nil then jh=jh+H;bV[dC]={pts={},ref=j1,name=fH,i=0,radius=jh,skipCalc=false}j0=bV[dC]end;if not j0.skipCalc then i_(j0,ak,j1)je=je+1 end;if j0.center then table.insert(i5,j0)end end;jd=jd+1;if bW and jd>700 or je>70 or(not bW and jd>300 or je>30)then coroutine.yield()jd,je=0,0 end end end;local jj=#i5;if jj>0 and bC>20 then local dR,jk,jl,jm;local jn=0;local jo=b2:getPlanetarySystem(0)jm=bB:normalize()while jn<jj do coroutine.yield()local jp={table.unpack(i5,jn,math.min(jn+75,jj))}dR,jk,jl=jo:castIntersections(bF,jm,nil,nil,jp,true)if dR and jl then bY={dR,jk,jl}break end;jn=jn+75 end;if not dR then bY=nil end else bY=nil end;i5={}local jq=jb:find('identifiedConstructs":%[%]')if jq==nil and hC==nil then am=1;hD()end;if jq~=nil and hC~=nil then hD()end;if radarPanelID==nil then hD()end;if CollisionSystem then i1=jj.."/"..jf.." Plotted : "..ja-jf.." Ignored"else i1="Radar Contacts: "..ja end;bS=cb(hY,hZ,i1,"pbright txtbig txtmid")if#i3>0 then bS=bS..cb(x,y,"Friendlies In Range","pbright txtbig txtmid")for cS,cT in pairs(i3)do h_=h_+20;bS=bS..cb(i0,h_,radar_1.getConstructName(cT),"pdim txtmid")end;i3={}end else local jr;jr=jb:find('worksInEnvironment":false')if jr then bS=cb(hY,hZ,"Radar: Jammed","pbright txtbig txtmid")else bS=cb(hY,hZ,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then am=0;hD()end end end end;function i6.UpdateRadar()local js=coroutine.status(UpdateRadarCoroutine)if js=="suspended"then local cg,jt=coroutine.resume(UpdateRadarCoroutine)if jt then system.print("ERROR UPDATE RADAR: "..jt)end elseif js=="dead"then UpdateRadarCoroutine=coroutine.create(i6.UpdateRadarRoutine)local cg,jt=coroutine.resume(UpdateRadarCoroutine)end end;function i6.DrawSettings(fr)if#bO>0 then local x=fl(640)local y=fm(200)fr[#fr+1]=[[<g class="pbright txtvspd txtstart">]]for cS,cT in pairs(bO)do fr[#fr+1]=cb(x,y,cT..": ".._G[cT])y=y+20;if cS%12==0 then x=x+fl(350)y=fm(200)end end;fr[#fr+1]=cb(fl(640),fm(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fr[#fr+1]="</g>"end;return fr end;UpdateRadarCoroutine=coroutine.create(i6.UpdateRadarRoutine)return i6 end;local function ju()local function jv(position)local dp=sys:closestBody(position)if(position-dp.center):len()<dp.radius+dp.noAtmosphericDensityAltitude then dp=planet else dp=aY[0][0]end;return dp,position end;local function jw()local function jx(jy,jz)return jy.name<jz.name end;bQ={}for cS,cT in pairs(aY[0])do bQ[#bQ+1]={name=cT.name,index=cS}end;table.sort(bQ,jx)end;local function jA(jB)for cS,cT in pairs(jB)do if cT.name and cT.name==CustomTarget.name then return cS end end;return-1 end;local function jC()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ad=nil;CustomTarget=nil;return true end;local jD=bQ[AutopilotTargetIndex].index;local jE=aY[0][jD]if jE.center then AutopilotTargetName=jE.name;ad=b2[0][jD]if CustomTarget~=nil then if at==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jE;for _,cT in pairs(b2[0])do if cT.name==CustomTarget.planetname then ad=cT;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ad.center)else AutopilotTargetCoords=CustomTarget.position end;if ad.planetname~="Space"then if ad.hasAtmosphere then AutopilotTargetOrbit=d(ad.radius*(TargetOrbitRadius-1)+ad.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ad.radius*(TargetOrbitRadius-1)+ad.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=b5(ad):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jF(fW)if not Autopilot and not VectorToTarget and not ao and not IntoOrbit then if fW==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bQ then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bQ end end;if AutopilotTargetIndex==0 then jC()else local jD=bQ[AutopilotTargetIndex].index;local jE=aY[0][jD]if jE.name=="Space"or iphCondition=="Custom Only"and jE.center or iphCondition=="No Moons"and string.find(jE.name,"Moon")~=nil then if fW==nil then jF()else jF(1)end else jC()end end else a3="Disengage autopilot before changing Interplanetary Helper"bZ("iph","AP")end end;local cU={}function cU.UpdateAtlasLocationsList()jw()end;function cU.UpdateAutopilotTarget()jC()end;function cU.adjustAutopilotTargetIndex(fW)jF(fW)end;function cU.findAtlasIndex(jB)jA(jB)end;function cU.UpdatePosition(jG)local gq=-1;local jH;gq=jA(SavedLocations)if gq~=-1 then local jI;if jG~=nil then jH={position=SavedLocations[gq].position,name=jG,atmosphere=SavedLocations[gq].atmosphere,planetname=SavedLocations[gq].planetname,gravity=SavedLocations[gq].gravity}else local dp,eQ=jv(bF)jH={position=eQ,name=SavedLocations[gq].name,atmosphere=at,planetname=dp.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[gq]=jH;gq=-1;gq=jA(aY[0])if gq>-1 then aY[0][gq]=jH end;jw()a3=jH.name.." position updated ("..jH.planetname..")"jC()else a3="Name Not Found"end end;function cU.AddNewLocation()if dbHud_1 then local dp,position=jv(bF)local fH=dp.name..". "..#SavedLocations;if radar_1 then local dC,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dC~=nil and dC~=""then fH=fH.." "..radar_1.getConstructName(dC)end end;local jH={}jH={position=position,name=fH,atmosphere=dp.atmosphericDensityAboveSurface,planetname=dp.name,gravity=dp.gravity,safe=true}SavedLocations[#SavedLocations+1]=jH;table.insert(aY[0],jH)jw()a3="Location saved as "..fH.."("..dp.name..")"else a3="Databank must be installed to save locations"end end;function cU.ClearCurrentPosition()local gq=-1;gq=jA(aY[0])if gq>-1 then table.remove(aY[0],gq)end;gq=-1;gq=b7.findAtlasIndex(SavedLocations)if gq~=-1 then a3=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,gq)end;jF()jw()end;for cS,cT in pairs(SavedLocations)do table.insert(aY[0],cT)end;jw()cU.UpdateAutopilotTarget()return cU end;local function jJ()local jK={}local function jL(eM)local jM=AutopilotEndSpeed;if not Autopilot then jM=0 end;if not as then return b3.computeDistanceAndTime(eM,jM,ax,0,0,LastMaxBrake-AutopilotPlanetGravity*ax)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b3.computeDistanceAndTime(eM,jM,ax,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*ax)else return 0,0 end end end;local function jN(eM)local jM=AutopilotEndSpeed;if not Autopilot then jM=0 end;return b3.computeDistanceAndTime(eM,jM,ax,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*ax)end;local jO=false;function jK.GetAutopilotBrakeDistanceAndTime(eM)return jL(eM)end;function jK.GetAutopilotTBBrakeDistanceAndTime(eM)return jN(eM)end;local function jP(jQ,jR,jS)jR=jR:project_on_plane(jQ)jS=jS:project_on_plane(jQ)return m(jR:cross(jS):dot(jQ),jR:dot(jS))end;local function jT()local function jU()local jV=-1;local jW=-1;if vBooster then jV=vBooster.distance()end;if hover then jW=hover.distance()end;if jV~=-1 and jW~=-1 then if jV<jW then return jV else return jW end elseif jV~=-1 then return jV elseif jW~=-1 then return jW else return-1 end end;local jX=jU()local jY=-1;if telemeter_1 then jY=telemeter_1.getDistance()end;if jX~=-1 and jY~=-1 then if jX<jY then return jX else return jY end elseif jX~=-1 then return jX else return jY end end;local function jZ(planet,e7,j_)local function k0(k1,dm)local ed=vec3(dm)if k1.bodyId==0 then return setmetatable({latitude=ed.x,longitude=ed.y,altitude=ed.z,bodyId=0,systemId=k1.planetarySystemId},MapPosition)end;local ee=ed-k1.center;local ak=ee:len()local du=ak-k1.radius;local ds=0;local dt=0;if not cj(ak,0)then local ef=m(ee.y,ee.x)dt=ef>=0 and ef or 2*math.pi+ef;ds=math.pi/2-math.acos(ee.z/ak)end;return setmetatable({latitude=math.deg(ds),longitude=math.deg(dt),altitude=du,bodyId=k1.bodyId,systemId=k1.planetarySystemId},MapPosition)end;local k2=k0(planet,e7)k2="::pos{"..k2.systemId..","..k2.bodyId..","..k2.latitude..","..k2.longitude..","..k2.altitude.."}"if j_ then return k2 else system.setWaypoint(k2)return true end end;function jK.showWayPoint(planet,e7,j_)return jZ(planet,e7,j_)end;function jK.APTick()local function k3()if bY and not BrakeLanding then local dR=bY[1]local jk,jl=bY[2],bY[3]local k4=math.min(jk,jl or jk)local k5=k4/bC;if(AltitudeHold or VectorToTarget or LockPitch or Autopilot)and not AutoTakeoff and(a9*1.5>k4 or k5<1)then BrakeIsOn=true;cf(0)if AltitudeHold then cr()end;if LockPitch then ToggleLockPitch()end;a3="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cs()end;StrongBrakes=true;BrakeLanding=true;bb=true end;if k5<11 then bX=dR.name.." COLLISION "..cJ(k5).." / "..cm(k4,2)else bX=dR.name.." collision "..cJ(k5)end;if k5<6 then bZ("alarm","AL",2)end else bX=false end end;as=j()>0;at=j()au=core.getAltitude()aq=jT()E=p()be=E;bW=unit.getClosestPlanetInfluence()>0;if CollisionSystem then k3()end;if antigrav then bI=antigrav.getState()==1 end;local k6=1;local k7=1;local k8=E-be;local k9=-math.deg(jP(by,bB,bz))local ka=math.deg(jP(bA,bB,bz))local fW=bD*-1;bd=as and k9<-YawStallAngle or k9>YawStallAngle or ka<-PitchStallAngle or ka>PitchStallAngle;local kb=system.getMouseDeltaX()local kc=system.getMouseDeltaY()if InvertMouse and not a2 then kc=-kc end;W=0;a0=0;V=0;sys=b2[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=b5(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bB)if au==0 then au=(bF-planet.center):len()-planet.radius end;local ij=planet:getGravity(core.getConstructWorldPos()):len()*ax;bf=0;b4=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and a2 then if not b9 then ah=ah+kb;ai=ai+kc end else ah=0;ai=0 end else ah=ah+kb;ai=ai+kc;ak=z(ah*ah+ai*ai)if not a2 and l()==0 then if userControlScheme=="virtual joystick"then if ah>0 and ah>DeadZone then W=W-(ah-DeadZone)*MouseXSensitivity elseif ah<0 and ah<DeadZone*-1 then W=W-(ah+DeadZone)*MouseXSensitivity else W=0 end;if ai>0 and ai>DeadZone then V=V-(ai-DeadZone)*MouseYSensitivity elseif ai<0 and ai<DeadZone*-1 then V=V-(ai+DeadZone)*MouseYSensitivity else V=0 end else ah=0;ai=0;if userControlScheme=="mouse"then V=(-utils.smoothstep(kc,-100,100)+0.5)*2*k6;W=(-utils.smoothstep(kb,-100,100)+0.5)*2*k7 end end end end;local kd=bC>8334;if bC>SpaceSpeedLimit/3.6 and not as and not Autopilot and not kd then a3="Space Speed Engine Shutoff reached"cf(0)end;if not kd and LastIsWarping then if not BrakeIsOn then cu()end;if Autopilot then cs()end end;LastIsWarping=kd;if as and at>0.09 then if bC>bi/3.6 and not AtmoSpeedAssist and not jO then BrakeIsOn=true;jO=true elseif not AtmoSpeedAssist and jO then if bC<bi/3.6 then BrakeIsOn=false;jO=false end end end;if BrakeIsOn then Z=1 else Z=0 end;if ProgradeIsOn then if an then BrakeIsOn=false;local ke=false;if CustomTarget~=nil then ke=cv(CustomTarget.position-bF,0.1)else ke=cv(vec3(bB),0.01)end;bb=true;if ke then ci(d(bi))if(c(bM)<2 or c(bL)>85)and bC>=bi/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;S=true;an=false;ap=true;Autopilot=false;cH()end elseif as and AtmoSpeedAssist then cf(1)end elseif bC>R then cv(vec3(bB),0.01)end end;if RetrogradeIsOn then if as then RetrogradeIsOn=false elseif bC>R then cv(-vec3(bB))end end;if not ProgradeIsOn and an and not IntoOrbit then if at==0 then S=true;cH()an=false;ap=true else an=false;cs()end end;if ap and CustomTarget~=nil and(au<HoldAltitude+250 and au>HoldAltitude-250)and bC*3.6>bi-250 and c(bE)<25 and at>=0.1 and(CustomTarget.position-bF):len()>2000+au then cs()ap=false end;if VertTakeOff then bb=true;local kf=HoldAltitude;if bE<-30 then a3="Unable to achieve lift. Safety Landing."ag=0;bb=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bI or HoldAltitude<planet.spaceEngineMinAltitude then if bI then kf=antigrav.getBaseAltitude()end;if au<kf-100 then bj=0;ag=15;BrakeIsOn=false elseif bE>0 then BrakeIsOn=true;ag=0 elseif bE<-30 then BrakeIsOn=true;ag=15 elseif au>=kf then if bI then if Autopilot or VectorToTarget then cp()else BrakeIsOn=true;VertTakeOff=false end;a3="Takeoff complete. Singularity engaged"bZ("aggLk","AG")else BrakeIsOn=false;a3="VTO complete. Engaging Horizontal Flight"bZ("vtoc","VT")cp()end;ag=0 end else if at>0.08 then bj=0;BrakeIsOn=false;ag=20 elseif at<0.08 and at>0 then BrakeIsOn=false;if bv then bj=0;ag=20 else ag=0;bj=36;ci(3500)end else bb=autoRollPreference;IntoOrbit=true;bt=false;CancelIntoOrbit=false;bn=false;bl=nil;bm=nil;if bs==nil then bs=planet end;br=kf;bq=true;VertTakeOff=false end end;if bj~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kg=q(bj-bL,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kg)local kh=q(vTpitchPID:get(),-1,1)V=kh end end;if IntoOrbit then local cE;local ki=false;local kj=cm(br)if bs==nil then bs=planet;if VectorToTarget then bs=ad end end;if not bq then br=d(bs.radius+bs.surfaceMaxAltitude+LowOrbitHeight)if bs.hasAtmosphere then br=d(bs.radius+bs.noAtmosphericDensityAltitude+LowOrbitHeight)end;bq=true end;if bp.VectorToTarget then cE=CustomTarget.position-bF end;local kk,kl=b5(bs):escapeAndOrbitalSpeed((bF-bs.center):len()-bs.radius)local km=bM;if not bn then local kn=false;local ko=false;cf(0)bm=0;bk="Aligning to orbital path - OrbitHeight: "..kj;if bp.VectorToTarget then cv(cE:normalize():project_on_plane(bD))ki=bz:dot(cE:project_on_plane(by):normalize())>0.95 else cv(bB)ki=k9<0.5;if bC<150 then ki=true end end;V=0;bl=0;if bL<=bl+1 and bL>=bl-1 then kn=true else kn=false end;if km<=bm+1 and km>=bm-1 then ko=true else ko=false end;if kn and ko and ki then bl=nil;bm=nil;bn=true end else if bp.VectorToTarget then cv(cE:normalize():project_on_plane(bD))elseif bC>150 then cv(bB)end;V=0;if bp.VectorToTarget then local a9,_=b3.computeDistanceAndTime(bC,bi/3.6,ax,0,0,LastMaxBrake)if bt and cE:len()>15000+a9+au then bk="Orbiting to Target"if au-100<=bs.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bs.noAtmosphericDensityAltitude then bt=false end elseif bt or cE:len()<15000+a9+au then a3="Orbit complete, proceeding with reentry"bZ("orCom","OB")AutopilotTargetCoords=CustomTarget.position;S=true;ap=true;bp.VectorToTarget,bp.AutopilotAlign=false,false;cq()cH()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and au>br*0.9 and au<br*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=br*0.99 and orbit.apoapsis.altitude>=br*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bt then if bt then BrakeIsOn=false;cf(0)bl=0;if not bp.VectorToTarget then a3="Orbit complete"bZ("orCom","OB")cq()end else bx=bx+1;if bx>=2 then bt=true end end else bk="Adjusting Orbit - OrbitHeight: "..kj;bo=true;ci(kl*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kp=bE;local kq=au-br;local kr=c(kq)if bE<10 and c(bL)<10 and kr<100 then kp=bE*2 end;if kp<10 and c(bL)<10 and kr<100 then kp=kp*2 end;if kp<5 and c(bL)<5 and kr<100 then kp=kp*4 end;VSpdPID:inject(kp)bl=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kq)bl=q(bl-q(OrbitAltPID:get(),-15,15),-90,90)end end else local ks=2.75;local kt=c(o(kk*ks))local ku=kt%50;if ku>0 then kt=kt-ku+50 end;BrakeIsOn=false;if au<br*0.8 then bk="Escaping planet gravity - OrbitHeight: "..kj;bl=utils.map(bE,200,0,-15,80)elseif au>=br*0.8 and au<br*1.15 then bk="Approaching orbital corridor - OrbitHeight: "..kj;kt=kt*0.75;bl=utils.map(bE,100,-100,-15,65)elseif au>=br*1.15 and au<br*1.5 then bk="Approaching orbital corridor - OrbitHeight: "..kj;kt=kt*0.75;if bE<0 or bo then bl=utils.map(au,br*1.5,br*1.01,-30,0)else bl=utils.map(au,br*0.99,br*1.5,0,30)end elseif au>br*1.5 then bk="Reentering orbital corridor - OrbitHeight: "..kj;bl=-65;local kv=utils.map(bE,-150,-400,1,0.55)kt=kt*kv end;ci(d(kt))end end;if bl~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kw=bl-bL;OrbitPitchPID:inject(kw)local kx=q(OrbitPitchPID:get(),-0.5,0.5)V=kx end end;if Autopilot and at==0 and not an then local function ky(i1,orbit)system.print(i1)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cf(0)Q=false;a3=i1;bZ("apCom","AP")if orbit or an then if orbit and AutopilotTargetOrbit~=nil and not an then if not au or au==0 then return end;br=au;bq=true end;cq()end end;local kz,kA=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kB=(CustomTarget.position-ad.center):normalize()local kC=kB:project_on_plane((ad.center-bF):normalize()):normalize()local kD=ad.center+kC*(ad.radius+AutopilotTargetOrbit)local kE=CustomTarget.position+(CustomTarget.position-ad.center):normalize()*(AutopilotTargetOrbit-ad:getAltitude(CustomTarget.position))if(bF-kD):len()<(bF-kE):len()then kz=kD else kz=kE;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kz;b8.showWayPoint(ad,AutopilotTargetCoords)kA=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kA=true;TargetSet=true;AutopilotRealigned=true;kz=CustomTarget.position+(bF-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kB=(bF+bB*100000-ad.center):normalize()local kC=kB:project_on_plane((ad.center-bF):normalize()):normalize()if kC:len()<1 then kB=(bF+bz*100000-ad.center):normalize()kC=kB:project_on_plane((ad.center-bF):normalize()):normalize()end;kz=ad.center+kC*(ad.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kz;TargetSet=true;kA=true;AutopilotRealigned=true;b8.showWayPoint(ad,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kz)-bF):len()local hh,e5,e6=b2:getPlanetarySystem(0):castIntersections(bF,bB:normalize(),function(dR)if dR.noAtmosphericDensityAltitude>0 then return dR.radius+dR.noAtmosphericDensityAltitude else return dR.radius+dR.surfaceMaxAltitude*1.5 end end)local hi=e5;if e6~=nil and e5~=nil then hi=math.min(e6,e5)end;if hi~=nil and hi<AutopilotDistance and hh.name==ad.name then AutopilotDistance=hi end;local ke=true;local kF=(ad.center-(bF+vec3(bB):normalize()*AutopilotDistance)):len()-ad.radius;local hg=cm(kF)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hg..'"}')local a9,aa;if not TurnBurn then a9,aa=jL(bC)else a9,aa=jN(bC)end;if bC>300 and AutopilotAccelerating then local cE=vec3(kz)-bF;local kG=q(math.deg(jP(by,bB:normalize(),cE:normalize()))*bC/500,-90,90)local kH=q(math.deg(jP(bA,bB:normalize(),cE:normalize()))*bC/500,-90,90)if c(kG)<20 and c(kH)<20 then kG=kG*2;kH=kH*2 end;if c(kG)<2 and c(kH)<2 then kG=kG*2;kH=kH*2 end;local k9=-math.deg(jP(by,bz,bB:normalize()))local ka=-math.deg(jP(bA,bz,bB:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kH-ka)local kI=q(apPitchPID:get(),-1,1)V=V+kI;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kG-k9)local kJ=q(apYawPID:get(),-1,1)W=W+kJ;kA=true;if c(kG)>2 or c(kH)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bZ("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end end end;if kF<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=b5(ad):escapeAndOrbitalSpeed(kF)end end;if not AutopilotCruising and not AutopilotBraking and not kA then ke=cv((kz-bF):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then ke=cv(-vec3(bB):normalize())end;if AutopilotAccelerating then if not Q then BrakeIsOn=false;cf(AutopilotInterplanetaryThrottle)L=B(AutopilotInterplanetaryThrottle,2)Q=true end;local kK=unit.getThrottle()if AtmoSpeedAssist then kK=L end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or kK==0 and Q then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bZ("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cf(0)end;if AutopilotDistance<=a9 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bZ("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cf(0)Q=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Z=1 end;if TurnBurn then cf(1,true)end;local _,kl=b5(ad):escapeAndOrbitalSpeed((bF-planet.center):len()-planet.radius)local cE;if CustomTarget~=nil then cE=CustomTarget.position-bF end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bC<50 then ky("Autopilot complete, arrived at space location")BrakeIsOn=true;Z=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bC<=kl and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then ky("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;an=true;b8.showWayPoint(ad,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bZ("apCir","AP")AutopilotStatus="Circularizing"end;if bC<=kl then if CustomTarget~=nil then if bB:normalize():dot(cE:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bZ("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;b8.showWayPoint(ad,CustomTarget.position)WaypointSet=true end else ky("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;an=true;b8.showWayPoint(ad,CustomTarget.position)WaypointSet=false end else ky("Autopilot completed, setting orbit",true)Z=0 end end elseif AutopilotStatus=="Circularizing"then ky("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a9 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bZ("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kK=unit.getThrottle()if AtmoSpeedAssist then kK=L end;if kK>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end;AutopilotCruising=false end else if ke then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not an then AutopilotTargetCoords=vec3(ad.center)+(AutopilotTargetOrbit+ad.radius)*bA;AutopilotShipUp=by;AutopilotShipRight=bA end;AutopilotRealigned=true elseif ke then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end;if not Q then cf(AutopilotInterplanetaryThrottle,true)L=B(AutopilotInterplanetaryThrottle,2)Q=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and at>0)then a3="Autopilot complete, proceeding with reentry"bZ("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Z=0;cf(0)Q=false;ProgradeIsOn=true;an=true;b8.showWayPoint(ad,CustomTarget.position)end;if a1 then bb=true;local kH=0;local eQ=bF+vec3(unit.getMasterPlayerRelativePosition())local kL=eQ-bF;local kM=vec3(kL):project_on(bz):len()local kN=vec3(kL):project_on(bA):len()local ak=z(kM*kM+kN*kN)cv(kL:normalize())local kO=40;local kP=ak<kO;local kQ=100;local kR=q((ak-kO)/2,10,kQ)V=0;local ke=c(W)<0.1;if ke and bC<kR and not kP then BrakeIsOn=false;kH=-20 else BrakeIsOn=true;kH=0 end;local kS=0;if c(kH-bL)>kS then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kH-bL)local kI=pitchPID:get()V=kI end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local kT=LastMaxBrakeInAtmo;if kT then kT=kT*q(bC/100,0.1,1)*at else kT=LastMaxBrake end;if at<0.01 then kT=LastMaxBrake end;local kU=vec3(core.getWorldAirFrictionAcceleration())local kV=z(kU:len()-kU:project_on(fW):len())*ax;if bC>100 then a9,aa=b3.computeDistanceAndTime(bC,100,ax,0,0,kT+kV)local kW,kX=b3.computeDistanceAndTime(100,0,ax,0,0,kT/2)a9=a9+kW else a9,aa=b3.computeDistanceAndTime(bC,0,ax,0,0,kT/2)end;local kY=HoldAltitude-au;local kZ=500+bC;local k_=1;if AutoTakeoff then k_=q(bC/100,0.1,1)end;local kH=(utils.smoothstep(kY,-kZ,kZ)-0.5)*2*MaxPitch*k_;if not Reentry and not an and not VectorToTarget and bz:dot(bB:normalize())<0.99 then kH=(utils.smoothstep(kY,-kZ*q(20-19*at*10,1,20),kZ*q(20-19*at*10,1,20))-0.5)*2*MaxPitch*q(2-at*10,1,2)*k_ end;if not AltitudeHold then kH=0 end;if LockPitch~=nil then if bW and not IntoOrbit then kH=LockPitch else LockPitch=nil end end;bb=true;local l0=V;if Reentry then local l1=d(bi)local l2,l3=b3.computeDistanceAndTime(bC,l1/3.6,ax,0,0,LastMaxBrake-planet.gravity*9.8*ax)local l4=au-(planet.noAtmosphericDensityAltitude+5000)if not bK and au>planet.noAtmosphericDensityAltitude+5000 and bC<=l1/3.6 and bC>l1/3.6-10 and c(bB:normalize():dot(bz))>0.9 then cf(0)elseif bK and bC>l1/3.6 and(l2>-1 and l4<=l2 or au<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;ci(l1,true)if not S then kH=-80;if at>0.02 then a3="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kH=0;bb=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and au>planet.noAtmosphericDensityAltitude+5000 then bb=true elseif au<=planet.noAtmosphericDensityAltitude+5000 then ci(l1)if not bK and r:getTargetSpeed(axisCommandId.longitudinal)==bi then S=false;Reentry=false;bb=true end end end;if bC>R and not ao and not VectorToTarget and not BrakeLanding and ForceAlignment then cv(vec3(bB))end;if bU or(VectorToTarget or ao)and AutopilotTargetIndex>0 and at>0.01 then local cE;if bU then if type(bU)=="table"then cE=bU elseif bU<3 and bU>0 then cE=-bD:cross(bB)*5000 elseif bU>=3 then cE=bD:cross(bB)*5000 elseif bU<0 then cE=bB*25000 end elseif CustomTarget~=nil then cE=CustomTarget.position-bF else cE=ad.center-bF end;local kG=math.deg(jP(bD:normalize(),bB,cE))*2;local l5=math.rad(c(bM))if bC>minRollVelocity and at>0.01 then local l6=q(90-kH*2,-90,90)bf=q(kG*2,-l6,l6)local l7=kG;kG=q(q(kG,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(l5)+4*(bL-kH)*math.sin(math.rad(bM)),-YawStallAngle*0.80,YawStallAngle*0.80)kH=q(q(kH*math.cos(l5),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(l7)*math.sin(l5),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bf=0;kG=q(kG,-YawStallAngle*0.80,YawStallAngle*0.80)end;local l8=k9-kG;if bU and c(l8)<=0.0001 and(type(bU)=="table"or type(bU)~="table"and bU<0 and c(bM)<1)then if bU==-2 then cr()end;bU=nil;bZ("180Off","BR")return end;if not bd and bC>minRollVelocity and at>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(l8)local kJ=q(yawPID:get(),-1,1)W=W+kJ elseif as and aq>-1 or bC<minRollVelocity then cv(cE)elseif bd and at>0.01 then if(k9<-YawStallAngle or k9>YawStallAngle)and at>0.01 then cv(bB)end;if(ka<-PitchStallAngle or ka>PitchStallAngle)and at>0.01 then kH=q(bL-ka,bL-PitchStallAngle*0.80,bL+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ao then local kf=planet:getAltitude(CustomTarget.position)local l4=z(cE:len()^2-(au-kf)^2)local l9=bB:len()-c(bE)StrongBrakes=true;if not ao and not Reentry and l4<=a9+bC*k8/2 and(bB:project_on_plane(bD):normalize():dot(cE:project_on_plane(bD):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cf(0)if AltitudeHold then cr()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l9<0.1 or l4<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<l4)then if not bI then bZ("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bX=false end;LastDistanceToTarget=l4 end elseif VectorToTarget and at==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ao or Reentry)then if CustomTarget~=nil and ad.name==planet.name then local cE=CustomTarget.position-bF;local kf=planet:getAltitude(CustomTarget.position)local l4=z(cE:len()^2-(au-kf)^2)local kT=LastMaxBrakeInAtmo;if kT then a9,aa=b3.computeDistanceAndTime(bC,0,ax,0,0,kT/2)StrongBrakes=true;if l4<=a9+bC*k8/2 and bB:project_on_plane(bD):normalize():dot(cE:project_on_plane(bD):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;S=true;an=false;ap=true;Autopilot=false;cH()end end;LastDistanceToTarget=l4 end end end;if at==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ao or IntoOrbit or Reentry)then if not bt and not IntoOrbit then br=HoldAltitude;bq=true;if VectorToTarget then bp.VectorToTarget=true end;cq()VectorToTarget=false;bn=true end end;if bd and at>0.01 and aq==-1 and bC>minRollVelocity and VectorStatus~="Finalizing Approach"then cv(bB)kH=q(bL-ka,bL-PitchStallAngle*0.80,bL+PitchStallAngle*0.80)end;V=l0;local jY=-1;if BrakeLanding then kH=0;local la=false;local lb=30;if b4~=nil and b4>0 then local lc=q(at,0.4,2)local kT=LastMaxBrakeInAtmo*q(bC/100,0.1,1)*lc;local ld=b4*lc+kT-ij;local le=kT/2-ij;local lf=bC-z(c(le/2)*20/(0.5*ax))*utils.sign(le)if lf<0 then lf=0 end;local lg;if bC>100 then local lh,_=b3.computeDistanceAndTime(bC,100,ax,0,0,kT)local li,_=b3.computeDistanceAndTime(100,0,ax,0,0,z(kT))lg=lh+li else lg=b3.computeDistanceAndTime(bC,0,ax,0,0,z(kT))end;if lg<20 then BrakeIsOn=false else local lj=0;if lf>100 then local lk,_=b3.computeDistanceAndTime(lf,100,ax,0,0,ld)local ll,_=b3.computeDistanceAndTime(100,0,ax,0,0,b4*lc+z(kT)-ij)lj=lk+ll else lj,_=b3.computeDistanceAndTime(lf,0,ax,0,0,b4*lc+z(kT)-ij)end;lj=(lj+15+bC*k8)*1.1;local lm=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lm then local kf=planet:getAltitude(CustomTarget.position)local ln=au-kf-100;local cE=CustomTarget.position-bF;local lo=z(cE:len()^2-(au-kf)^2)if lo>100 then lm=false elseif ln<=lj or lj==-1 then BrakeIsOn=true;la=true else BrakeIsOn=false;la=true end end;if not lm and CalculateBrakeLandingSpeed then if lj>=lb then BrakeIsOn=true else BrakeIsOn=false end;la=true end end end;if not bK then cf(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)stablized=true;jY=aq;if jY>-1 then bb=autoRollPreference;if bC<1 or bB:normalize():dot(bD)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if T then a.control.extendLandingGears()bZ("grOut","LG",1)end;r:setTargetGroundAltitude(LandingGearGroundHeight)ag=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bB:normalize():dot(-fW)<0.999 then BrakeIsOn=true elseif bE<-brakeLandingRate and not la then BrakeIsOn=true elseif not la then BrakeIsOn=false end end;if AutoTakeoff or ao then local hh,e6,e5;if AutopilotTargetCoords~=nil then hh,e6,e5=b2:getPlanetarySystem(0):castIntersections(bF,(AutopilotTargetCoords-bF):normalize(),function(dR)return dR.radius+dR.noAtmosphericDensityAltitude end)end;if bI then if au>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cf(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kH)<15 and au/HoldAltitude>0.75 then AutoTakeoff=false;if not ao then if bK and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ao and bC<R then Autopilot=true;ao=false;AltitudeHold=false;AutoTakeoff=false;cf(0)elseif ao then cf(0)BrakeIsOn=true end elseif ao and at==0 and ad~=nil and(hh==nil or hh.name==ad.name)then Autopilot=true;ao=false;AltitudeHold=false;AutoTakeoff=false;if not bK then cf(0)end;AutopilotAccelerating=true end end;local lp=aq>-1;local lq=bL;if(VectorToTarget or ao or bU)and not lp and bC>minRollVelocity and at>0.01 then local l5=math.rad(c(bM))lq=bL*c(math.cos(l5))+ka*math.sin(l5)end;local lr=q(kH-lq,-PitchStallAngle*0.80,PitchStallAngle*0.80)if at<0.01 and VectorToTarget then lr=q(kH-lq,-85,MaxPitch)elseif at<0.01 then lr=q(kH-lq,-MaxPitch,MaxPitch)end;if c(bM)<5 or VectorToTarget or bU or BrakeLanding or lp or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lr)local kI=pitchPID:get()V=V+kI end end;if antigrav~=nil and(antigrav and not ExternalAGG and au<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;aq=jT()return jK end;function script.onStart()local ls={}local lt={}local lu=false;local function lv()local function lw(lx)local ly=dbHud_1.hasKey;for cS,cT in pairs(lx)do if ly(cT)then local cB=f(dbHud_1.getStringValue(cT))if cB~=nil then _G[cT]=cB;lu=true end end end end;if dbHud_1 then if not useTheseSettings then lw(c4())coroutine.yield()lw(b)else lw(b)a3="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"aj=5;lu=false end;coroutine.yield()if lu then a3="Loaded Saved Variables"aI=ResolutionX;aJ=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bb=autoRollPreference;bi=AtmoSpeedLimit;aA=[[rgb(]]..d(I+0.5)..","..d(K+0.5)..","..d(J+0.5)..[[)]]aB=[[rgb(]]..d(I*0.9+0.5)..","..d(K*0.9+0.5)..","..d(J*0.9+0.5)..[[)]]elseif not useTheseSettings then a3="No Saved Variables Found - Exit HUD to save settings"end else a3="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a3="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"aj=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=au end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=ax end;VectorStatus="Proceeding to Waypoint"end;local function lz()local function lA(lB,lC)if lB>lC then lC=lB end;local lD,lE=0,0;if ContainerOptimization>0 then lD=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lE=FuelTankOptimization*0.05 end;lC=lC*(1-(lD+lE))return lC end;local lF=core.getElementNameById;local lG=fuelX~=0 and fuelY~=0;for cS in pairs(av)do local type=core.getElementTypeById(av[cS])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(av[cS])),'^.*vertical.*$')then bH=true end end;if n(type,'^.*Space Engine$')then bw=true;if n(tostring(core.getElementTagsById(av[cS])),'^.*vertical.*$')then local lH=core.getElementRotationById(av[cS])if lH[4]<0 then if o(-lH[4],0.1)==0.5 then bu=true end else if o(lH[4],0.1)==0.5 then bv=true end end end end;if type=="Landing Gear"then T=true end;if type=="Dynamic Core Unit"then local lI=h(av[cS])if lI>10000 then G=128;H=110 elseif lI>1000 then G=64;H=55 elseif lI>150 then G=32;H=27 end end;aN=aN+h(av[cS])if lG and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lI=h(av[cS])local lJ=k(av[cS])local lB=0;local fO=p()if type=="Atmospheric Fuel Tank"then local lC=400;local lK=35.03;if lI>10000 then lC=51200;lK=5480 elseif lI>1300 then lC=6400;lK=988.67 elseif lI>150 then lC=1600;lK=182.67 end;lB=lJ-lK;if fuelTankHandlingAtmo>0 then lC=lC+lC*fuelTankHandlingAtmo*0.2 end;lC=lA(lB,lC)aK[#aK+1]={av[cS],lF(av[cS]),lC,lK,lB,fO}end;if type=="Rocket Fuel Tank"then local lC=320;local lK=173.42;if lI>65000 then lC=40000;lK=25740 elseif lI>6000 then lC=5120;lK=4720 elseif lI>700 then lC=640;lK=886.72 end;lB=lJ-lK;if fuelTankHandlingRocket>0 then lC=lC+lC*fuelTankHandlingRocket*0.1 end;lC=lA(lB,lC)aM[#aM+1]={av[cS],lF(av[cS]),lC,lK,lB,fO}end;if type=="Space Fuel Tank"then local lC=2400;local lK=182.67;if lI>10000 then lC=76800;lK=5480 elseif lI>1300 then lC=9600;lK=988.67 end;lB=lJ-lK;if fuelTankHandlingSpace>0 then lC=lC+lC*fuelTankHandlingSpace*0.2 end;lC=lA(lB,lC)aL[#aL+1]={av[cS],lF(av[cS]),lC,lK,lB,fO}end end end;if not bH then VertTakeOff,VertTakeOffEngine=false,false end end;local function lL()if gyro~=nil then az=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(as or not as and au<10000)then for _,cT in pairs(door)do cT.toggle()end end;if switch then for _,cT in pairs(switch)do cT.toggle()end end;if forcefield and(as or not as==0 and au<10000)then for _,cT in pairs(forcefield)do cT.toggle()end end;if antigrav then bI=antigrav.getState()==1;if bI and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if T then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if aq~=-1 or not as and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;GearExtended=true;if T then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(bc)if as and aq~=-1 then b4=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=as end;local function lM(lN,lO,lP,lQ,x,y,lR,lS,lT,lU)local lV={enableName=lN,disableName=lO,width=lP,height=lQ,x=x,y=y,toggleVar=lR,toggleFunction=lS,drawCondition=lT,hovered=false}if lU then table.insert(lt,lV)else table.insert(ls,lV)end;return lV end;local function lW(lX)if not bN then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif lX=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif lX=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif lX=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bO=c4(lX)showHud=false else bO={}showHud=true end end;local function lY()bN=not bN;if bN then aH=lt;a3="Hold SHIFT to see Settings"bP=showHud else aH=ls;a3="Hold SHIFT to see Control Buttons"lW()showHud=bP end end;local function lZ(cT)_G[cT]=not _G[cT]if _G[cT]then a3=cT.." set to true"else a3=cT.." set to false"end;if cT=="showHud"then bP=_G[cT]elseif cT=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif cT=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function l_()local m0=50;local m1=340;local x=500;local y=aJ/2-400;local m2=0;for cS,cT in pairs(c4("boolean"))do if type(_G[cT])=="boolean"then lM(cT,cT,m1,m0,x,y,function()return _G[cT]end,function()lZ(cT)end,function()return true end,true)y=y+m0+20;if m2==9 then x=x+m1+20;y=aJ/2-400;m2=0 else m2=m2+1 end end end;lM("Control View","Control View",m1,m0,10,aJ/2-500,function()return true end,lY,function()return true end,true)lM("View Handling Settings",'Hide Handling Settings',m1,m0,10,aJ/2-(500-m0),function()return showHandlingVariables end,function()lW("handling")end,function()return true end,true)lM("View Hud Settings",'Hide Hud Settings',m1,m0,10,aJ/2-(500-m0*2),function()return showHudVariables end,function()lW("hud")end,function()return true end,true)lM("View Physics Settings",'Hide Physics Settings',m1,m0,10,aJ/2-(500-m0*3),function()return showPhysicsVariables end,function()lW("physics")end,function()return true end,true)end;local function m3()local function m4()b7.AddNewLocation()end;local function m5()TurnBurn=not TurnBurn end;local function m6(m7)if m7==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a1=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function m8()m6(1)end;local function m9()b7.UpdatePosition()end;local function ma()b7.ClearCurrentPosition()end;local function mb()local fH=AutopilotTargetName;if fH==nil then local hg=cm((bF-CustomTarget.position):len())fH=CustomTarget.name.." "..hg end;if fH==nil then fH="None"end;return"Engage Autopilot: "..fH end;local function mc()local fH=AutopilotTargetName;if fH==nil then fH=CustomTarget.name end;if fH==nil then fH="None"end;return"Disable Autopilot: "..fH end;local function md()if safeMass>0 then a3="Safe Mass set to "..B(ax,2).." kg"else a3="Intruder Detection reset\nSafe Mass set to "..B(ax,2).." kg"aj=5;bG=0 end;safeMass=ax end;local function me()if l()==1 then a1=not a1;if a1 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)bZ("folOn","F")else bZ("folOff","F")BrakeIsOn=true;bb=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else a3="Follow Mode only works with Remote controller"a1=false end end;local m0=50;local m1=260;local mf=lM("Enable Brake Toggle","Disable Brake Toggle",m1,m0,aI/2-m1/2,aJ/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a3="Brakes in Toggle Mode"else a3="Brakes in Default Mode"end end)lM("Align Prograde","Disable Prograde",m1,m0,aI/2-m1/2-50-mf.width,aJ/2-m0+380,function()return ProgradeIsOn end,m8)lM("Align Retrograde","Disable Retrograde",m1,m0,aI/2-m1/2+mf.width+50,aJ/2-m0+380,function()return RetrogradeIsOn end,m6,function()return at==0 end)local mg=lM(mb,mc,600,60,aI/2-600/2,aJ/2-60/2-400,function()return Autopilot end,cs)lM("Save Position","Save Position",200,mg.height,mg.x+mg.width+30,mg.y,function()return false end,m4,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)lM("Update Position","Update Position",200,mg.height,mg.x+mg.width+30,mg.y,function()return false end,m9,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lM("Clear Position","Clear Position",200,mg.height,mg.x-200-30,mg.y,function()return true end,ma,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)m0=60;m1=300;local x=10;local y=aJ/2-500;lM("Show Help","Hide Help",m1,m0,x,y,function()return showHelp end,function()showHelp=not showHelp end)y=y+m0+20;lM("View Settings","View Settings",m1,m0,x,y,function()return true end,lY)local y=aJ/2-300;lM("Enable Turn and Burn","Disable Turn and Burn",m1,m0,x,y,function()return TurnBurn end,m5)lM("Horizontal Takeoff Mode","Vertical Takeoff Mode",m1,m0,x+m1+20,y,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a3="Vertical Takeoff Mode"else a3="Horizontal Takeoff Mode"end end,function()return bH end)y=y+m0+20;lM("Show Orbit Display","Hide Orbit Display",m1,m0,x,y,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a3="Orbit Display Enabled"else a3="Orbit Display Disabled"end end)lM("Engage Orbiting","Cancel Orbiting",m1,m0,x+m1+20,y,function()return IntoOrbit end,cq,function()return at==0 and bW end)y=y+m0+20;lM("Glide Re-Entry","Cancel Glide Re-Entry",m1,m0,x,y,function()return Reentry end,function()an=true;m8()end,function()return planet.hasAtmosphere and not as end)lM("Parachute Re-Entry","Cancel Parachute Re-Entry",m1,m0,x+m1+20,y,function()return Reentry end,cH,function()return planet.hasAtmosphere and not as end)y=y+m0+20;lM("Engage Follow Mode","Disable Follow Mode",m1,m0,x,y,function()return a1 end,me,function()return l()==1 end)lM("Enable Repair Arrows","Disable Repair Arrows",m1,m0,x+m1+20,y,function()return aO end,function()aO=not aO;if aO then a3="Repair Arrows Enabled"else a3="Repair Arrows Diabled"end end,function()return l()==1 end)y=y+m0+20;if not ExternalAGG then lM("Enable AGG","Disable AGG",m1,m0,x,y,function()return bI end,cI,function()return antigrav~=nil end)end;lM("Reset Intruder Alert","Set Safe Mass",m1,m0,x+m1+20,y,function()return safeMass>0 end,md,function()return IntruderAlertSystem end)y=y+m0+20;lM(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,m1*2,m0,x,y,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a3="IPH Mode: "..iphCondition end)y=y+m0+20;lM(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,m1*2,m0,x,y,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a3="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lv()coroutine.yield()lz()coroutine.yield()b8=jJ()lL()l_()m3()aH=ls;coroutine.yield()aY=cU()b1=cV()b2=b1(cU())b3=ej()b5=eO()b6=fb()b7=ju()b8=jJ()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bZ("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(at>0 or at==0 and au<10000)then for _,cT in pairs(door)do cT.toggle()end end;if switch then for _,cT in pairs(switch)do cT.toggle()end end;if forcefield and(at>0 or at==0 and au<10000)then for _,cT in pairs(forcefield)do cT.toggle()end end;safeMass=ax;cO()if button then button.activate()end;if SetWaypointOnExit then b8.showWayPoint(planet,bF)end;bZ("stop","SU")end;function script.onTick(mh)local mi=nil;if mh=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a3="Radar Contact"bZ("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif mh=="tenthSecond"then local function mj()local mk=system.createData;local ml=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=ml(panelInterplanetary,"value")interplanetaryHeaderText=mk('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=ml(panelInterplanetary,"value")widgetDistanceText=mk('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=ml(panelInterplanetary,"value")widgetTravelTimeText=mk('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=ml(panelInterplanetary,"value")widgetMaxMassText=mk('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=ml(panelInterplanetary,"value")widgetTargetOrbitText=mk('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=ml(panelInterplanetary,"value")widgetCurBrakeDistanceText=mk('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=ml(panelInterplanetary,"value")widgetCurBrakeTimeText=mk('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=ml(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mk('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=ml(panelInterplanetary,"value")widgetMaxBrakeTimeText=mk('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=ml(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mk('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not as then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mm()s(panelInterplanetary)panelInterplanetary=nil end;local function mn()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ad.center-bF):len()else AutopilotDistance=(CustomTarget.position-bF):len()end end;local eM=bC;local kK=unit.getThrottle()/100;if AtmoSpeedAssist then kK=L end;local mo,mp=b3.computeDistanceAndTime(bC,MaxGameVelocity,ax,a:maxForceForward()*kK,warmup,0)local a9,aa;if not TurnBurn then a9,aa=b8.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a9,aa=b8.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mq;if not TurnBurn and eM>0 then _,mq=b8.GetAutopilotBrakeDistanceAndTime(eM)else _,mq=b8.GetAutopilotTBBrakeDistanceAndTime(eM)end;local mr=0;local ms=0;if AutopilotCruising or not Autopilot and eM>5 then ms=b3.computeTravelTime(eM,0,AutopilotDistance)elseif a9+mo<AutopilotDistance then mr=AutopilotDistance-(a9+mo)ms=b3.computeTravelTime(8333.0556,0,mr)else local mt=(AutopilotDistance-a9)/mo;mo=AutopilotDistance-a9;mp=mp*mt end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return ms elseif AutopilotBraking then return mq elseif AutopilotCruising then return ms+mq else return mp+aa+ms end end;local function mu(ij,mv)if ij==nil then ij=core.g()end;ij=B(ij,5)if mv~=nil and mv or(mi==nil or mi~=ij)then local eP=core.getVelocity()local eM=vec3(eP):len()local mw=f(unit.getData()).maxBrake;if mw~=nil and mw>0 and as then mw=mw/q(eM/100,0.1,1)mw=mw/at;if at>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mw)/2 else LastMaxBrakeInAtmo=mw end end end;if mw~=nil and mw>0 then LastMaxBrake=mw end;mi=ij end end;mu(nil,true)if at>0 and not WasInAtmo then if not bK and AtmoSpeedAssist and(AltitudeHold or Reentry)then cf(1)P=false end end;if bJ~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bJ then ci(bJ,TRUE)else bJ=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mj()end;if AutopilotTargetName~=nil then local mx=CustomTarget~=nil;local my=LastMaxBrakeInAtmo/ad:getGravity(ad.center+vec3(0,0,1)*ad.radius):len()t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mn()if mx and not Autopilot then ak=(bF-CustomTarget.position):len()else ak=(AutopilotTargetCoords-bF):len()end;if not TurnBurn then a9,aa=b8.GetAutopilotBrakeDistanceAndTime(bC)ab,ac=b8.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a9,aa=b8.GetAutopilotTBBrakeDistanceAndTime(bC)ab,ac=b8.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hg=cm(ak)t(widgetDistanceText,'{"label": "distance", "value": "'..hg..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cJ(travelTime)..'", "unit":""}')hg=cm(a9)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hg..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cJ(aa)..'", "unit":""}')hg=cm(ab)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hg..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cJ(ac)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",my/1000)..'", "unit":" Tons"}')hg=cm(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..hg..'"}')if at>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if at==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mm()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif mh=="oneSecond"then local function mz(fr)local mA=0;aF=""local mB=aN;local mC=0;local mD=0;local mE=0;local fQ=0;local fR=""local mF=core.getElementHitPointsById;for cS in pairs(av)do local lI=0;local mG=0;mG=h(av[cS])lI=mF(av[cS])mC=mC+lI;if lI<mG then if lI==0 then mE=mE+1 else mD=mD+1 end;if aO and#aC==0 then position=vec3(core.getElementPositionById(av[cS]))local x=position.x-G;local y=position.y-G;local iL=position.z-G;table.insert(aC,core.spawnArrowSticker(x,y,iL+1,"down"))table.insert(aC,core.spawnArrowSticker(x,y,iL+1,"down"))core.rotateSticker(aC[2],0,0,90)table.insert(aC,core.spawnArrowSticker(x+1,y,iL,"north"))table.insert(aC,core.spawnArrowSticker(x+1,y,iL,"north"))core.rotateSticker(aC[4],90,90,0)table.insert(aC,core.spawnArrowSticker(x-1,y,iL,"south"))table.insert(aC,core.spawnArrowSticker(x-1,y,iL,"south"))core.rotateSticker(aC[6],90,-90,0)table.insert(aC,core.spawnArrowSticker(x,y-1,iL,"east"))table.insert(aC,core.spawnArrowSticker(x,y-1,iL,"east"))core.rotateSticker(aC[8],90,0,90)table.insert(aC,core.spawnArrowSticker(x,y+1,iL,"west"))table.insert(aC,core.spawnArrowSticker(x,y+1,iL,"west"))core.rotateSticker(aC[10],-90,0,90)table.insert(aC,av[cS])end elseif aO and#aC>0 and aC[11]==av[cS]then for fJ in pairs(aC)do core.deleteSticker(aC[fJ])end;aC={}end end;mA=d(mC/mB*100)if mA<100 then fr[#fr+1]=cb(0,0,"","pbright txt")fQ=d(mA*2.55)fR=e("rgb(%d,%d,%d)",255-fQ,fQ,0)if mA<100 then fr[#fr+1]=cb("50%",1035,"Elemental Integrity: "..mA.."%","txtbig txtmid","fill:"..fR)if mE>0 then fr[#fr+1]=cb("50%",1055,"Disabled Modules: "..mE.." Damaged Modules: "..mD,"txtbig txtmid","fill:"..fR)elseif mD>0 then fr[#fr+1]=cb("50%",1055,"Damaged Modules: "..mD,"txtbig txtmid","fill:"..fR)end end end end;local function mH()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function mI()local fO=p()local h4=bC;local mJ=fO-aw;if h4>1.38889 then h4=h4/1000;local mK=h4*(fO-aw)TotalDistanceTravelled=TotalDistanceTravelled+mK;ae=ae+mK end;af=af+mJ;TotalFlightTime=TotalFlightTime+mJ;aw=fO end;local function mL()if safeMass>0 then if ax>safeMass+50 then bG=d(ax-safeMass)safeMass=-1 elseif ax<safeMass then safeMass=ax end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mL()end;mI()b6.UpdatePipe()mH()local fr={}b6.ExtraData(fr)if ShowOdometer then fr=b6.DrawOdometer(fr,ae,TotalDistanceTravelled,af)end;if ShouldCheckDamage then mz(fr)end;al=table.concat(fr,"")collectgarbage("collect")elseif mh=="fiveSecond"then if not UseSatNav then return end;ar=dbHud_1.getStringValue("SPBAutopilotTargetName")if ar~=nil and ar~=""and ar~="SatNavNotChanged"then local cB=f(dbHud_1.getStringValue("SavedLocations"))if cB~=nil then _G["SavedLocations"]=cB;local gq=-1;local jH;for cS,cT in pairs(SavedLocations)do if cT.name and cT.name=="SatNav Location"then gq=cS;break end end;if gq~=-1 then jH=SavedLocations[gq]gq=-1;for cS,cT in pairs(aY[0])do if cT.name and cT.name=="SatNav Location"then gq=cS;break end end;if gq>-1 then aY[0][gq]=jH end;b7.UpdateAtlasLocationsList()a3=jH.name.." position updated"end end;for i=1,#bQ do if bQ[i].name==ar then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bQ[i].name)b7.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mh=="msgTick"then local fr={}b6.DisplayMessage(fr,"empty")a3="empty"unit.stopTimer("msgTick")aj=3 elseif mh=="animateTick"then ba=true;b9=false;ah=0;ai=0;unit.stopTimer("animateTick")elseif mh=="hudTick"then local function mM(fr)local mN=d(q(ak/(aI/4)*255,0,255))fr[#fr+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ah,ai,d(I+0.5)+mN,d(K+0.5)-mN,d(J+0.5)-mN)end;local function mO()for _,cT in pairs(aH)do if cT.hovered then if not cT.drawCondition or cT.drawCondition()then cT.toggleFunction()end;cT.hovered=false end end end;local function mP()local function mQ(mR,mS,x,y,lP,lQ)if mR>x and mR<x+lP and mS>y and mS<y+lQ then return true else return false end end;local x=ah+aI/2;local y=ai+aJ/2;for _,cT in pairs(aH)do cT.hovered=mQ(x,y,cT.x,cT.y,cT.width,cT.height)end end;local function mT(fr)local function mU(fr,mV,hover,x,y,eF,mW,mX,mY,mZ,m_)if type(mZ)=="function"then mZ=mZ()end;if type(m_)=="function"then m_=m_()end;fr[#fr+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",x,y,eF,mW)if mV then fr[#fr+1]=e("%s'",mX)else fr[#fr+1]=mY end;if hover then fr[#fr+1]=" style='stroke:white; stroke-width:2'"else fr[#fr+1]=" style='stroke:black; stroke-width:1'"end;fr[#fr+1]="></rect>"fr[#fr+1]=e("<text x='%f' y='%f' font-size='24' fill='",x+eF/2,y+mW/2+5)if mV then fr[#fr+1]="black"else fr[#fr+1]="white"end;fr[#fr+1]="' text-anchor='middle' font-family='Montserrat'>"if mV then fr[#fr+1]=e("%s</text>",mZ)else fr[#fr+1]=e("%s</text>",m_)end end;local n0="rgb(50,50,50)'"local n1="rgb(210,200,200)"local n2=mU;for _,cT in pairs(aH)do local lO=cT.disableName;local lN=cT.enableName;if type(lO)=="function"then lO=lO()end;if type(lN)=="function"then lN=lN()end;if not cT.drawCondition or cT.drawCondition()then n2(fr,cT.toggleVar(),cT.hovered,cT.x,cT.y,cT.width,cT.height,n1,n0,lO,lN)end end end;local n3=B(ResolutionX/2,0)local n4=B(ResolutionY/2,0)local fr={}b6.HUDPrologue(fr)if showHud then b6.UpdateHud(fr)else if AlwaysVSpd then b6.DrawVerticalSpeed(fr,au)end;b6.DisplayOrbitScreen(fr)b6.DrawWarnings(fr)end;if bN and bO~={}then b6.DrawSettings(fr)end;b6.HUDEpilogue(fr)fr[#fr+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aI,aJ)if a3~="empty"then b6.DisplayMessage(fr,a3)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then b6.DrawDeadZone(fr)end end;if w()==0 then if l()==1 and a2 then if not AltIsOn then mP()mT(fr)end;if not b9 and not ba then local n5=table.concat(fr,"")fr={}fr[#fr+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aI,aJ)fr[#fr+1]=n5;fr[#fr+1]="</body>"b9=true;fr[#fr+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fr,"")system.setScreen(content)elseif ba then local n5=table.concat(fr,"")fr={}fr[#fr+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aI,aJ)fr[#fr+1]=n5;fr[#fr+1]="</body>"end;if not b9 then fr[#fr+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],n3,n4,ah,ai)end else mO()end else if not a2 and l()==0 then mO()if ak>DeadZone then if DisplayDeadZone then mM(fr)end end elseif not AltIsOn or AltIsOn and a2 then mP()mT(fr)end;fr[#fr+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],n3,n4,ah,ai)end;fr[#fr+1]=[[</svg></body>]]content=table.concat(fr,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif mh=="apTick"then b8.APTick()b6.UpdateRadar()end end;function script.onFlush()local function n6(n7,kR)local n8=vec3()local n9=vec3()if n7==axisCommandId.longitudinal then n8=vec3(core.getConstructOrientationForward())n9=bz elseif n7==axisCommandId.vertical then n8=vec3(core.getConstructOrientationUp())n9=by elseif n7==axisCommandId.lateral then n8=vec3(core.getConstructOrientationRight())n9=bA else return vec3()end;local na=vec3(core.getWorldGravity())local nb=na:dot(n9)local nc=vec3(core.getWorldAirFrictionAcceleration())local nd=nc:dot(n9)local ne=vec3(core.getVelocity())local nf=ne:dot(n8)local ng=kR*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(ng-nf)local nh=targetSpeedPID2:get()local ni=(nh-nd-nb)*n9;return ni end;local function nj(n7,kR)local n8=vec3()local n9=vec3()if n7==axisCommandId.longitudinal then n8=vec3(core.getConstructOrientationForward())n9=bz elseif n7==axisCommandId.vertical then n8=vec3(core.getConstructOrientationUp())n9=by elseif n7==axisCommandId.lateral then n8=vec3(core.getConstructOrientationRight())n9=bA else return vec3()end;local na=vec3(core.getWorldGravity())local nb=na:dot(n9)local nc=vec3(core.getWorldAirFrictionAcceleration())local nd=nc:dot(n9)local ne=vec3(core.getVelocity())local nf=ne:dot(n8)local ng=kR*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(ng-nf)local nh=targetSpeedPID:get()local ni=(nh-nd-nb)*n9;return ni end;local function nk(nl,fV,jz)local nm=nl:cross(jz):normalize_inplace()local gI=math.acos(q(nm:dot(-fV),-1,1))*constants.rad2deg;if nm:cross(-fV):dot(jz)<0 then gI=-gI end;return gI end;if antigrav and not ExternalAGG then if not bI and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bK=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bK and P then cf(0)P=false elseif not bK and not P then L=0;P=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local nn=q(U+V+system.getControlDeviceForwardInput(),-1,1)local no=q(X+a0+system.getControlDeviceYawInput(),-1,1)local np=q(Y+W-system.getControlDeviceLeftRightInput(),-1,1)local nq=Z;bD=vec3(core.getWorldVertical())if bD==nil or bD:len()==0 then bD=(planet.center-bF):normalize()end;by=vec3(core.getConstructWorldOrientationUp())bz=vec3(core.getConstructWorldOrientationForward())bA=vec3(core.getConstructWorldOrientationRight())bB=vec3(core.getWorldVelocity())bF=vec3(core.getConstructWorldPos())ax=core.getConstructMass()bC=vec3(bB):len()bE=-bD:dot(bB)bM=getRoll(bD,bz,bA)local nr=bM/180*math.pi;local ns=math.cos(nr)local nt=math.sin(nr)bL=nk(bD,bz,bA*ns+by*nt)local nu=bB:normalize()local nw=c(bM)local nx=utils.sign(bM)local ny=vec3(core.getWorldAngularVelocity())local nz=nn*pitchSpeedFactor*bA+no*rollSpeedFactor*bz+np*yawSpeedFactor*by;if bb==true and bD:len()>0.01 then local nA=c(bf-bM)if((ProgradeIsOn or Reentry or BrakeLanding or an or AltitudeHold or IntoOrbit)and nA>0 or at>0.0 and nA<autoRollRollThreshold and autoRollPreference)and no==0 and c(bL)<85 then local nB=bf;local nC=autoRollFactor;if at==0 then nC=nC/4;bf=0;nB=0 end;if rollPID==nil then rollPID=pid.new(nC*0.01,0,nC*0.1)end;rollPID:inject(nB-bM)local nD=rollPID:get()nz=nz+nD*bz end end;if bD:len()>0.01 and at>0.0 then local nE=20.0;if turnAssist==true and nw>nE and nn==0 and np==0 then local nF=turnAssistFactor*0.1;local nG=turnAssistFactor*0.025;local nH=(nw-nE)/(180-nE)*180;local nI=0;if nH<90 then nI=nH/90 elseif nH<180 then nI=(180-nH)/90 end;nI=nI*nI;local nJ=-nx*nG*(1.0-nI)local nK=nF*nI;nz=nz+nK*bA+nJ*by end end;local nL=1;local nM=0;local nN=1;if system.getMouseWheel()>0 then if AltIsOn then if at>0 or Reentry then bi=q(bi+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif ay then local nO=L;L=B(q(L+speedChangeLarge/100,-1,1),2)if L>=0 and nO<0 then L=0;ay=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if at>0 or Reentry then bi=q(bi-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif ay then local nO=L;L=B(q(L-speedChangeLarge/100,-1,1),2)if L<=0 and nO>0 then L=0;ay=false end end else ay=true end;M=0;if as and AtmoSpeedAssist and bK then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bi/3.6-bB:dot(bz))local nP=throttlePID:get()O=q(nP,-1,1)if O<L and at>0.005 then N=true;r:setThrottleCommand(axisCommandId.longitudinal,q(O,0.01,1))else N=false;r:setThrottleCommand(axisCommandId.longitudinal,L)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bB:len()-bi/3.6)local nQ=q(brakePID:get(),0,1)if at>0 and bE<-80 or at>0.005 then M=nQ end;if M>0 then if N and O==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else O=q(O,0.01,1)end;local nR=''local nS=vec3()local nT=n6(axisCommandId.vertical,ag*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",nT,nM)local nU='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nU=nU..ExtraLongitudeTags end;local nV=r:getAxisCommandType(axisCommandId.longitudinal)local nW=r:composeAxisAccelerationFromThrottle(nU,axisCommandId.longitudinal)local nX=nj(axisCommandId.lateral,LeftAmount*1000)nR=nR..' , '.."lateral airfoil , lateral ground "nS=nS+nX;if nS:len()>constants.epsilon then a:setEngineForceCommand(nR,nS,nM,'','','',nN)end;a:setEngineForceCommand(nU,nW,nL)local nY='thrust analog vertical fueled 'local nZ='thrust analog lateral fueled 'if ExtraLateralTags~="none"then nZ=nZ..ExtraLateralTags end;if ExtraVerticalTags~="none"then nY=nY..ExtraVerticalTags end;if ag~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(nY,nT,nL)else a:setEngineForceCommand(nY,vec3(),nL)end;if LeftAmount~=0 then a:setEngineForceCommand(nZ,nX,nL)else a:setEngineForceCommand(nZ,vec3(),nL)end;if nq==0 then nq=M end;local n_=-nq*(brakeSpeedFactor*bB+brakeFlatFactor*nu)a:setEngineForceCommand('brake',n_)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,L)end;local kR=unit.getAxisCommandValue(0)if not bK then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bB:len()-kR/3.6)local nQ=q(brakePID:get(),0,1)nq=q(nq+nQ,0,1)end;local n_=-nq*(brakeSpeedFactor*bB+brakeFlatFactor*nu)a:setEngineForceCommand('brake',n_)local nR=''local nS=vec3()local o0=false;local nU='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nU=nU..ExtraLongitudeTags end;local nV=r:getAxisCommandType(axisCommandId.longitudinal)if nV==axisCommandType.byThrottle then local nW=r:composeAxisAccelerationFromThrottle(nU,axisCommandId.longitudinal)a:setEngineForceCommand(nU,nW,nL)elseif nV==axisCommandType.byTargetSpeed then local nW=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)nR=nR..' , '..nU;nS=nS+nW;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then o0=true end end;local nZ='thrust analog lateral 'if ExtraLateralTags~="none"then nZ=nZ..ExtraLateralTags end;local o1=r:getAxisCommandType(axisCommandId.lateral)if o1==axisCommandType.byThrottle then local o2=r:composeAxisAccelerationFromThrottle(nZ,axisCommandId.lateral)a:setEngineForceCommand(nZ,o2,nL)elseif o1==axisCommandType.byTargetSpeed then local nX=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)nR=nR..' , '..nZ;nS=nS+nX end;local nY='thrust analog vertical 'if ExtraVerticalTags~="none"then nY=nY..ExtraVerticalTags end;local o3=r:getAxisCommandType(axisCommandId.vertical)if o3==axisCommandType.byThrottle then local nT=r:composeAxisAccelerationFromThrottle(nY,axisCommandId.vertical)if ag~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(nY,nT,nL,'airfoil','ground','',nN)else a:setEngineForceCommand(nY,vec3(),nL)a:setEngineForceCommand('airfoil vertical',nT,nL,'airfoil','','',nN)a:setEngineForceCommand('ground vertical',nT,nL,'ground','','',nN)end elseif o3==axisCommandType.byTargetSpeed then if ag<0 then a:setEngineForceCommand('hover',vec3(),nL)end;local o4=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)nR=nR..' , '..nY;nS=nS+o4 end;if nS:len()>constants.epsilon then if Z~=0 or o0 or c(nu:dot(bz))<0.8 then nR=nR..', brake'end;a:setEngineForceCommand(nR,nS,nM,'','','',nN)end end;local o5=torqueFactor*(nz-ny)local o6=vec3(core.getWorldAirFrictionAngularAcceleration())o5=o5-o6;a:setEngineTorqueCommand('torque',o5,nL,'airfoil','','',nN)a:setBoosterCommand('rocket_engine')if a8 and not VanillaRockets then local eM=vec3(core.getVelocity()):len()local o7=0.15;if not bK then local o8=r:getTargetSpeed(axisCommandId.longitudinal)if eM*3.6>o8*(1-o7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eM*3.6<o8*(1-o7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kK=unit.getThrottle()if AtmoSpeedAssist then kK=L*100 end;local kR=kK/100;if j==0 then kR=kR*MaxGameVelocity;if eM>=kR*(1-o7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eM<kR*(1-o7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local l1=d(bi)kR=kR*l1/3.6;if eM>=kR*(1-o7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eM<kR*(1-o7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local js=coroutine.status(beginSetup)if js=="suspended"then local cg,jt=coroutine.resume(beginSetup)if jt then system.print("ERROR STARTUP: "..jt)end elseif js=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not b9 and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(o9)local mult=1;local function oa(ob)local function oc(od,ob)local oe={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local of=od;for _,cT in ipairs(oe)do if ob and of>cT then od=cT elseif od<cT and not ob then od=cT;break end end;return od end;if ob then mult=-1 end;if not ExternalAGG and bI then if a2 and ob then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+mult*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+mult*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a2 then br=oc(br,ob)else br=br+mult*a4 end;if br<planet.noAtmosphericDensityAltitude then br=planet.noAtmosphericDensityAltitude end else if a2 and as then HoldAltitude=oc(HoldAltitude,ob)else HoldAltitude=HoldAltitude+mult*a4 end end else r:updateTargetGroundAltitudeFromActionStart(mult*1.0)end end;local function og(ob)if ob then mult=-1 end;if not a2 then if AtmoSpeedAssist and not AltIsOn then L=q(L+mult*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,mult*speedChangeLarge)end else if ob then mult=1 else mult=nil end;b7.adjustAutopilotTargetIndex(mult)end end;local function oh(oi)if not as then a3="Flight Assist in Atmo only"return end;local c_=type(oi)if bU==nil then if c_=="table"then if Autopilot or VectorToTarget then cs()end;bZ("180On","BR")elseif oi==1 then bZ("bnkLft","BR")else bZ("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cr()if c_~="table"then oi=oi+1 end end;bU=oi else bZ("180Off","BR")bU=nil end end;if o9=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cf(0)if vBooster or hover then if as and aq==-1 then bZ("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bb=true;GearExtended=false else if T then bZ("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if as then BrakeIsOn=true end end end;if T and not BrakeLanding and not(vBooster or hover)then bZ("grOut","LG",1)a.control.extendLandingGears()end else if T then bZ("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif o9=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif o9=="forward"then U=U-1 elseif o9=="backward"then if AltIsOn then oh(-bB*5000)else U=U+1 end elseif o9=="left"then if AltIsOn then oh(1)else X=X-1 end elseif o9=="right"then if AltIsOn then oh(3)else X=X+1 end elseif o9=="yawright"then Y=Y-1 elseif o9=="yawleft"then Y=Y+1 elseif o9=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif o9=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif o9=="up"then ag=ag+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif o9=="down"then ag=ag-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif o9=="groundaltitudeup"then oa()elseif o9=="groundaltitudedown"then oa(true)elseif o9=="option1"then b7.adjustAutopilotTargetIndex()toggleView=false elseif o9=="option2"then b7.adjustAutopilotTargetIndex(1)toggleView=false elseif o9=="option3"then local function oj()aG=not aG;if not aG then bZ("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else bZ("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oj()toggleView=false elseif o9=="option4"then bU=nil;cs()toggleView=false elseif o9=="option5"then function ToggleLockPitch()if LockPitch==nil then bZ("lkPOn","LP")if not a2 then LockPitch=bL else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bZ("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif o9=="option6"then cr()toggleView=false elseif o9=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a3="Collision System Enabled"else a3="Collision System Secured"end;toggleView=false elseif o9=="option8"then stablized=not stablized;if not stablized then a3="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()bZ("gsOff","GS")else a3="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bZ("gsOn","GS")end;toggleView=false elseif o9=="option9"then if gyro~=nil then gyro.toggle()az=gyro.getState()==1;if az then bZ("gyOn","GA")else bZ("gyOff","GA")end end;toggleView=false elseif o9=="lshift"then if AltIsOn then a2=true end;if w()==1 then a2=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then a2=true;ba=false;b9=false end elseif o9=="brake"then if BrakeToggleStatus then cu()elseif not BrakeIsOn then cu()else BrakeIsOn=true end elseif o9=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif o9=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a8 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a8=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a8=false end elseif o9=="stopengines"then local function ok()if E-F<1.5 then bZ("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bU=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a1=false;Q=false;an=false;ao=false;S=false;bb=autoRollPreference;VectorToTarget=false;TurnBurn=false;az=false;LockPitch=nil;IntoOrbit=false end end;ok()F=E;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if L~=0 then r:resetCommand(axisCommandId.longitudinal)cf(0)else cf(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if as then ci(AtmoSpeedLimit)else ci(MaxGameVelocity*3.6)end end end elseif o9=="speedup"then og()elseif o9=="speeddown"then og(true)elseif o9=="antigravity"and not ExternalAGG then if antigrav~=nil then cI()end end end;function script.onActionStop(o9)local function ol()if not ExternalAGG and bI then a7=a5 end;if AltitudeHold or VertTakeOff or IntoOrbit then a6=a4 end end;if o9=="forward"then U=0 elseif o9=="backward"then U=0 elseif o9=="left"then if bU then if bU==2 then bU=-2 else bU=-1 end end;X=0 elseif o9=="right"then if bU then if bU==4 then bU=-2 else bU=-1 end end;X=0 elseif o9=="yawright"then Y=0 elseif o9=="yawleft"then Y=0 elseif o9=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif o9=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif o9=="up"then ag=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif o9=="down"then ag=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif o9=="groundaltitudeup"then ol()toggleView=false elseif o9=="groundaltitudedown"then ol()toggleView=false elseif o9=="lshift"then if w()==1 then ah=0;ai=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then ba=false;b9=false end;a2=false elseif o9=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cu()else BrakeIsOn=false end end elseif o9=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(o9)local function om(ob)local mult=1;if ob then mult=-1 end;if not ExternalAGG and bI then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+mult*a7;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a7=q(a7*1.05,a5,500)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+mult*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then br=br+mult*a6;if br<planet.noAtmosphericDensityAltitude then br=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+mult*a6 end;a6=q(a6*1.05,a4,500)else r:updateTargetGroundAltitudeFromActionLoop(mult*1.0)end end;local function on(ob)if ob then mult=-1 end;if not a2 then if AtmoSpeedAssist and not AltIsOn then L=q(L+mult*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,mult*speedChangeSmall)end end end;if o9=="groundaltitudeup"then if not a2 then om()end elseif o9=="groundaltitudedown"then if not a2 then om(true)end elseif o9=="speedup"then on()elseif o9=="speeddown"then on(true)end end;function script.onInputText(cc)local function oo()for cS,cT in pairs(c4())do dbHud_1.setStringValue(cT,g(nil))end;for cS,cT in pairs(b)do if cT~="SavedLocations"then dbHud_1.setStringValue(cT,g(nil))end end;a3="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"aj=5 end;local function op(oq,planet,eQ,gE)local function os(eQ)local C=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d7='::pos{'..C..','..C..','..C..','..C..','..C..'}'local dj,dk,ds,dt,du=n(eQ,d7)if dj=="0"and dk=="0"then return vec3(A(ds),A(dt),A(du))end;dt=math.rad(dt)ds=math.rad(ds)local planet=aY[A(dj)][A(dk)]local eg=math.cos(ds)local ot=vec3(eg*math.cos(dt),eg*math.sin(dt),math.sin(ds))return planet.center+(planet.radius+du)*ot end;if dbHud_1 or gE then local jH={}local position=os(eQ)if planet.name=="Space"then jH={position=position,name=oq,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else jH={position=position,name=oq,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;if not gE then SavedLocations[#SavedLocations+1]=jH else for cS,cT in pairs(aY[0])do if cT.name and oq==cT.name then table.remove(aY[0],cS)end end end;table.insert(aY[0],jH)b7.UpdateAtlasLocationsList()else a3="Databank must be installed to save permanent locations"end end;local i;local ou,ov=nil,nil;local ow="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cc," ")ou=cc;if i~=nil then ou=string.sub(cc,0,i-1)ov=string.sub(cc,i+1)end;if ou=="/help"or ou=="/commands"then for iq in string.gmatch(ow,"([^\n]+)")do system.print(iq)end;return elseif ou=="/setname"then if ov==nil or ov==""then a3="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then b7.UpdatePosition(ov)else a3="Select a saved target to rename first"end elseif ou=="/addlocation"or string.find(cc,"::pos")~=nil then local gE=false;local oq="0-Temp"if ov==nil or ov==""then ov=ou;gE=true end;i=string.find(ov,"::")if not gE then oq=string.sub(ov,1,i-2)end;local eQ=string.sub(ov,i)local C=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d7='::pos{'..C..','..C..','..C..','..C..','..C..'}'local dj,dk,ds,dt,du=n(eQ,d7)local planet=aY[A(dj)][A(dk)]if planet.name=="Space"then local j8=vec3(A(ds),A(dt),A(du))local dp=sys:closestBody(j8)if(j8-dp.center):len()<dp.radius+dp.noAtmosphericDensityAltitude then system.print(eQ.." recognized as: "..dp.name)planet=dp end end;op(oq,planet,eQ,gE)a3="Added "..oq.." to saved locations,\nplanet "..planet.name.." at "..eQ;aj=5 elseif ou=="/agg"then if ov==nil or ov==""then a3="Usage: /agg targetheight"return end;ov=A(ov)if ov<1000 then ov=1000 end;AntigravTargetAltitude=ov;a3="AGG Target Height set to "..ov elseif ou=="/G"then if ov==nil or ov==""then a3="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ov=="dump"then for cS,cT in pairs(c4())do if type(_G[cT])=="boolean"then if _G[cT]==true then system.print(cT.." true")else system.print(cT.." false")end elseif _G[cT]==nil then system.print(cT.." nil")else system.print(cT.." ".._G[cT])end end;return end;i=string.find(ov," ")local ox=string.sub(ov,0,i-1)local oy=string.sub(ov,i+1)for cS,cT in pairs(c4())do if cT==ox then a3="Variable "..ox.." changed to "..oy;local oz=type(_G[cT])if oz=="number"then oy=A(oy)elseif oz=="boolean"then if string.lower(oy)=="true"then oy=true else oy=false end end;_G[cT]=oy;return end end;a3="No such global variable: "..ox elseif ou=="/copydatabank"then if dbHud_2 then cO(true)else a3="Spare Databank required to copy databank"end elseif ou=="/iphWP"then if AutopilotTargetIndex>0 then system.print(b8.showWayPoint(ad,AutopilotTargetCoords,true))a3="::pos waypoint shown in lua chat"else a3="No target selected in IPH"end end end;function script.onEnter(dC)if radar_1 and not as and not bR then unit.setTimer("contact",0.1)end end;function script.onLeave(dC)if radar_1 and CollisionSystem then if#bV>650 then dC=tostring(dC)bV[dC]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
