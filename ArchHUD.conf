name: ArchHud - Archaegeo v1.706 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        require("autoconf/custom/archhud/globals")local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")require("autoconf/custom/archhud/hudclass")require("autoconf/custom/archhud/apclass")require("autoconf/custom/archhud/radarclass")require("autoconf/custom/archhud/controlclass")script={}VERSION_NUMBER=1.706;local f=math.abs;local g=math.floor;local h=string.format;local i=json.decode;local j=json.encode;local k=b.getElementMaxHitPointsById;local l=c.getAtmosphereDensity;local m=b.getElementMassById;local n=d.control.isRemoteControlled;local o=math.atan;local p=string.match;local q=a.getTime;local r=utils.clamp;local s=d.axisCommandManager;local t=a.destroyWidgetPanel;local u=a.updateData;local v=a.addDataToWidget;local w=a.lockView;local x=a.isViewLocked;local y=math.sqrt;local z=tonumber;local function A(B,C)local D=10^(C or 0)return g(B*D+0.5)/D end;E=q()F=q()local G=13;H=I;J=K;L=M;N=0;O=0;P=false;Q=0;R=false;S=false;T=55;U=false;V=false;W=0;X=0;Y=0;Z=0;_=0;a0=0;a1=0;a2=false;a3=false;a4="empty"a5=false;a6=0;a7=0;local a8=0;local a9=0;aa=nil;ab=0;ac=0;ad=0;ae=0;af=0;ag=3;ah=0;ai=""aj=false;ak=false;al=false;am=-1;local an=""ao=l()>0;ap=l()aq=b.getAltitude()local ar=b.getElementIdList()as=q()at=b.getConstructMass()au=false;av=nil;aw=[[rgb(]]..g(H+0.5)..","..g(L+0.5)..","..g(J+0.5)..[[)]]ax=[[rgb(]]..g(H*0.9+0.5)..","..g(L*0.9+0.5)..","..g(J*0.9+0.5)..[[)]]local ay={}az=""aA=aB;aC=aD;aE={}aF={}aG={}local aH=0;aI=false;local aJ=nil;aK=nil;aL=nil;aM=nil;aN=nil;aO=nil;aP=nil;aQ=nil;aR=nil;aS=nil;aT=false;aU=false;aV=aW;local aX=aY;aZ=false;a_=0;b0=b1;b2=0;b3=nil;b4={VectorToTarget=false}b5=0;b6=false;local b7=false;b8=false;b9=false;ba=vec3(b.getConstructWorldOrientationUp())bb=vec3(b.getConstructWorldOrientationForward())bc=vec3(b.getConstructWorldOrientationRight())bd=vec3(b.getVelocity())be=vec3(b.getWorldVelocity())bf=vec3(be):len()bg=vec3(b.getWorldVertical())bh=-bg:dot(be)bi=vec3(b.getConstructWorldPos())bj=false;bk=false;bl=nil;bm=true;bn=0;bo=0;bp={}bq=false;br=50000;bs=nil;bt={}bu=c.getClosestPlanetInfluence()>0 or aq>0 and aq<200000;bv=false;bw=nil;bx=false;by=0;bz=nil;bA=nil;bB={}bC=90;bD=bE;function bF(bG)a.print(E..": "..bG)end;function bH(bI,bJ,type)if type==nil and not bK or type~=nil and not bL or bM=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..bM.."/"..bI.."|"..bJ.."|"..bN)else a.logInfo("sound_notification|audiopacks/"..bM.."/"..bI.."|"..bJ.."|"..bN)end else a.logInfo("sound_q|audiopacks/"..bM.."/"..bI.."|"..bJ.."|"..bN)end end;function bO(bP,bQ)for bR=1,#bQ do bP[#bP+1]=bQ[bR]end;return bP end;function bS(bT)local bU={}if not bT then bO(bU,bV)bO(bU,bW)bO(bU,bX)bO(bU,bY)return bU elseif bT=="boolean"then return bV elseif bT=="handling"then return bW elseif bT=="hud"then return bX elseif bT=="physics"then return bY end end;local function bZ(b_,c0,c1,c2,c3)if c2==nil then c2=""end;if c3==nil then c3=""end;return h([[<text class="%s" x=%s y=%s style="%s">%s</text>]],c2,b_,c0,c3,c1)end;function c4(c5,c6)if c5==0 then return f(c6)<1e-09 end;if c6==0 then return f(c5)<1e-09 end;return f(c5-c6)<math.max(f(c5),f(c6))*c7 end;function c8(ah,c9)local ca=ah>100000;if c9==nil then c9=1 end;if ca then return A(ah/1000/200,c9).."SU"elseif ah<1000 then return A(ah,c9).."M"else return A(ah/1000,c9).."KM"end end;function cb(cc)local cd=0;local ce=0;local cf=0;if cc<60 then cc=g(cc)elseif cc<3600 then cd=g(cc/60)cc=g(cc%60)elseif cc<86400 then ce=g(cc/3600)cd=g(cc%3600/60)else cf=g(cc/86400)ce=g(cc%86400/3600)end;if cf>0 then return cf.."d "..ce.."h "elseif ce>0 then return ce.."h "..cd.."m "elseif cd>0 then return cd.."m "..cc.."s"elseif cc>0 then return cc.."s"else return"0s"end end;function cg(ch)local function ci(cj)for ck,cl in pairs(cj)do dbHud_1.setStringValue(ck,j(cl.get()))if ch and dbHud_2 then dbHud_2.setStringValue(ck,j(cl.get()))end end end;if dbHud_1 then ci(cm)ci(bS())a.print("Saved Variables to Datacore")if ch and dbHud_2 then a4="Databank copied.  Remove copy when ready."end end end;local function cn()local function co(cp)return type(cp)=='number'end;local function cq(cp)return type(z(cp))=='number'end;local function cr(cs)return type(cs)=='table'end;local function ct(a)return type(a)=='string'end;local function cu(cl)return cr(cl)and co(cl.x and cl.y and cl.z)end;local function cv(cw)return cr(cw)and co(cw.latitude and cw.longitude and cw.altitude and cw.id and cw.systemId)end;local cx=math.pi/180;local cy=180/math.pi;local c7=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cz='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cA(cp)local cB=string.gsub(string.reverse(h('%.4f',cp)),'^0*%.?','')return cB==''and'0'or string.reverse(cB)end;local function cC(cD)if cu(cD)then return h('{x=%.3f,y=%.3f,z=%.3f}',cD.x,cD.y,cD.z)end;if cr(cD)and not getmetatable(cD)then local cE={}local cF=next(cD)if type(cF)=='nil'or cF==1 then cE=cD else for ck,cl in pairs(cD)do local cG=cC(cl)if type(ck)=='number'then table.insert(cE,h('[%s]=%s',ck,cG))else table.insert(cE,h('%s=%s',ck,cG))end end end;return h('{%s}',table.concat(cE,','))end;if ct(cD)then return h("'%s'",cD:gsub("'",[[\']]))end;return tostring(cD)end;local cH={}cH.__index=cH;cH.__tostring=function(cD,cI)local cJ={}for ck in pairs(cD)do table.insert(cJ,ck)end;table.sort(cJ)local cE={}for cK,ck in ipairs(cJ)do local cG=cC(cD[ck])if type(ck)=='number'then table.insert(cE,h('[%s]=%s',ck,cG))else table.insert(cE,h('%s=%s',ck,cG))end end;if cI then return h('%s%s',cI,table.concat(cE,',\n'..cI))end;return h('{%s}',table.concat(cE,','))end;cH.__eq=function(cL,cM)return cL.systemId==cM.systemId and cL.id==cM.id and c4(cL.radius,cM.radius)and c4(cL.center.x,cM.center.x)and c4(cL.center.y,cM.center.y)and c4(cL.center.z,cM.center.z)and c4(cL.GM,cM.GM)end;local function cN(cO,cP,cQ,cR,cS)assert(cq(cO),'Argument 1 (systemId) must be a number:'..type(cO))assert(cq(cP),'Argument 2 (id) must be a number:'..type(cP))assert(cq(cQ),'Argument 3 (radius) must be a number:'..type(cQ))assert(cr(cR),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cR))assert(cq(cS),'Argument 5 (GM) must be a number:'..type(cS))return setmetatable({systemId=z(cO),id=z(cP),radius=z(cQ),center=vec3(cR),GM=z(cS)},cH)end;local cT={}cT.__index=cT;cT.__tostring=function(bF)return h('::pos{%d,%d,%s,%s,%s}',bF.systemId,bF.id,cA(bF.latitude*cy),cA(bF.longitude*cy),cA(bF.altitude))end;cT.__eq=function(cL,cM)return cL.id==cM.id and cL.systemId==cM.systemId and c4(cL.latitude,cM.latitude)and c4(cL.altitude,cM.altitude)and(c4(cL.longitude,cM.longitude)or c4(cL.latitude,math.pi/2)or c4(cL.latitude,-math.pi/2))end;local function cU(cV,cP,cW,cX,cY)local cO=cV;if ct(cV)and not cX and not cY and not cP and not cW then cO,cP,cW,cX,cY=p(cV,cz)assert(cO,'Argument 1 (position string) is malformed.')else assert(cq(cO),'Argument 1 (systemId) must be a number:'..type(cO))assert(cq(cP),'Argument 2 (id) must be a number:'..type(cP))assert(cq(cW),'Argument 3 (latitude) must be in degrees:'..type(cW))assert(cq(cX),'Argument 4 (longitude) must be in degrees:'..type(cX))assert(cq(cY),'Argument 5 (altitude) must be in meters:'..type(cY))end;cO=z(cO)cP=z(cP)cW=z(cW)cX=z(cX)cY=z(cY)if cP==0 then return setmetatable({latitude=cW,longitude=cX,altitude=cY,id=cP,systemId=cO},cT)end;return setmetatable({latitude=cx*r(cW,-90,90),longitude=cx*(cX%360),altitude=cY,id=cP,systemId=cO},cT)end;local cZ={}cZ.__index=cZ;cZ.__tostring=function(cD,cI)local c_=cI and cI..'  'local d0={}local cJ={}for ck in pairs(cD)do table.insert(cJ,ck)end;table.sort(cJ)for cK,d1 in ipairs(cJ)do d2=cD[d1]local d3=cH.__tostring(d2,c_)if cI then table.insert(d0,h('[%s]={\n%s\n%s}',d1,d3,cI))else table.insert(d0,h('  [%s]=%s',d1,d3))end end;if cI then return h('\n%s%s%s',cI,table.concat(d0,',\n'..cI),cI)end;return h('{\n%s\n}',table.concat(d0,',\n'))end;local function d4(d5)local e={}local pid;for cK,cl in pairs(d5)do local cP=cl.planetarySystemId;if type(cP)~='number'then error('Invalid planetary s ID: '..tostring(cP))elseif pid and cP~=pid then error('Mistringmatch planetary s IDs: '..cP..' and '..pid)end;local d6=cl.bodyId;if type(d6)~='number'then error('Invalid body ID: '..tostring(d6))elseif e[d6]then error('Duplicate body ID: '..tostring(d6))end;setmetatable(cl.center,getmetatable(vec3.unit_x))e[d6]=setmetatable(cl,cH)pid=cP end;return setmetatable(e,cZ)end;aJ={}local function d7(d5)return setmetatable({galaxyAtlas=d5 or{}},aJ)end;aJ.__index=function(cs,bR)if type(bR)=='number'then local a=cs.galaxyAtlas[bR]return d4(a)end;return rawget(aJ,bR)end;aJ.__pairs=function(cD)return function(cs,ck)local d8,d9=next(cs,ck)return d8,d9 and d4(d9)end,cD.galaxyAtlas,nil end;aJ.__tostring=function(cD)local da={}for cK,db in pairs(cD or{})do local dc=db:getPlanetarySystemId()local dd=cZ.__tostring(db,'    ')table.insert(da,h('  [%s]={%s\n  }',dc,dd))end;return h('{\n%s\n}\n',table.concat(da,',\n'))end;aJ.BodyParameters=cN;aJ.MapPosition=cU;aJ.PlanetarySystem=d4;function aJ.createBodyParameters(cO,cP,de,df,dg,dh,di)assert(cq(cO),'Argument 1 (systemId) must be a number:'..type(cO))assert(cq(cP),'Argument 2 (id) must be a number:'..type(cP))assert(cq(de),'Argument 3 (surfaceArea) must be a number:'..type(de))assert(cr(df),'Argument 4 (aPosition) must be an array or vec3:'..type(df))assert(cr(dg),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dg))assert(cq(dh),'Argument 6 (altitude) must be in meters:'..type(dh))assert(cq(di),'Argument 7 (gravityAtPosition) must be number:'..type(di))local cQ=y(de/4/math.pi)local ah=cQ+dh;local dj=vec3(df)+ah*vec3(dg)local cS=di*ah*ah;return cN(cO,cP,cQ,dj,cS)end;aJ.isMapPosition=cv;function aJ:getPlanetarySystem(cV)if bR==nil then bR=0 end;if d9==nil then d9=0 end;local cO=cV;if cv(cV)then cO=cV.systemId end;if type(cO)=='number'then local a=self.galaxyAtlas[bR]if a then if getmetatable(d9)~=cZ then a=d4(a)end;return a end end end;function cZ:sizeCalculator(dk)return 1.05*dk.radius end;function cZ:castIntersections(dl,dm,dn,dp,dq,dr)local ds={}if dq then for cK,dk in pairs(dq)do table.insert(ds,dk)end else ds=bB end;if not dr then table.sort(ds,function(dt,du)local c5=dt.center;local c6=du.center;return(c5.x-dl.x)^2+(c5.y-dl.y)^2+(c5.z-dl.z)^2<(c6.x-dl.x)^2+(c6.y-dl.y)^2+(c6.z-dl.z)^2 end)end;local dv=dm:normalize()for cK,dk in ipairs(ds)do local dw=dk.center-dl;local cQ=self:sizeCalculator(dk)local dx=dw:dot(dv)local dy=dx^2-(dw:len2()-cQ^2)if dy>=0 then local dz=y(dy)local dA=dx+dz;local dB=dx-dz;if dB>0 then return dk,dA,dB elseif dA>0 then return dk,dA,nil end end end;return nil,nil,nil end;function cZ:closestBody(dC)assert(type(dC)=='table','Invalid coordinates.')local dD,dk;local dE=vec3(dC)for cK,dF in pairs(self)do local dG=(dF.center-dE):len2()if(not dk or dG<dD)and dF.name~="Space"then dk=dF;dD=dG end end;return dk end;function cZ:convertToBodyIdAndWorldCoordinates(cV)local dH=cV;if ct(cV)then dH=cU(cV)end;if dH.id==0 then return 0,vec3(dH.latitude,dH.longitude,dH.altitude)end;local dF=self:getBodyParameters(dH)if dF then return dH.id,dF:convertToWorldCoordinates(dH)end end;function cZ:getBodyParameters(cV)local cP=cV;if cv(cV)then cP=cV.id end;assert(cq(cP),'Argument 1 (id) must be a number:'..type(cP))return self[cP]end;function cZ:getPlanetarySystemId()local cK,cl=next(self)return cl and cl.systemId end;function cH:convertToMapPosition(cR)assert(cr(cR),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cR))local dI=vec3(cR)if self.id==0 then return setmetatable({latitude=dI.x,longitude=dI.y,altitude=dI.z,id=0,systemId=self.systemId},cT)end;local dJ=dI-self.center;local ah=dJ:len()local cY=ah-self.radius;local cW=0;local cX=0;if not c4(ah,0)then local dK=o(dJ.y,dJ.x)cX=dK>=0 and dK or 2*math.pi+dK;cW=math.pi/2-math.acos(dJ.z/ah)end;return setmetatable({latitude=cW,longitude=cX,altitude=cY,id=self.id,systemId=self.systemId},cT)end;function cH:convertToWorldCoordinates(cV)local dH=ct(cV)and cU(cV)or cV;if dH.id==0 then return vec3(dH.latitude,dH.longitude,dH.altitude)end;assert(cv(dH),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dH.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(dH.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dL=math.cos(dH.latitude)return self.center+(self.radius+dH.altitude)*vec3(dL*math.cos(dH.longitude),dL*math.sin(dH.longitude),math.sin(dH.latitude))end;function cH:getAltitude(cR)return(vec3(cR)-self.center):len()-self.radius end;function cH:getDistance(cR)return(vec3(cR)-self.center):len()end;function cH:getGravity(cR)local dM=self.center-vec3(cR)local dN=dM:len2()return self.GM/dN*dM/y(dN)end;return setmetatable(aJ,{__call=function(cK,...)return d7(...)end})end;local function dO()local aL={}local dP=30000000/3600;local dQ=dP*dP;local dR=100;function aL.computeAccelerationTime(dS,dT,dU)local dV=dP*math.asin(dS/dP)return(dP*math.asin(dU/dP)-dV)/dT end;function aL.computeDistanceAndTime(dS,dU,dW,dX,dY,dZ)dY=dY or 0;dZ=dZ or 0;local d_=dS<=dU;local e0=dX*(d_ and 1 or-1)/dW;local e1=-dZ/dW;local e2=e0+e1;if d_ and e2<=0 or not d_ and e2>=0 then return-1,-1 end;local e3,e4=0,0;if e0~=0 and dY>0 then local dV=math.asin(dS/dP)local e5=math.pi*(e0/2+e1)local e6=e0*dY;local e7=dP*math.pi;local cl=function(cs)local e8=(e5*cs-e6*math.sin(math.pi*cs/2/dY)+e7*dV)/e7;local e9=math.tan(e8)return dP*e9/y(e9*e9+1)end;local ea=d_ and function(a)return a>=dU end or function(a)return a<=dU end;e4=2*dY;if ea(cl(e4))then local eb=0;while f(e4-eb)>0.5 do local cs=(e4+eb)/2;if ea(cl(cs))then e4=cs else eb=cs end end end;local ec=dS;local ed=e4/dR;for ee=1,dR do local ef=cl(ee*ed)e3=e3+(ef+ec)*ed/2;ec=ef end;if e4<2*dY then return e3,e4 end;dS=ec end;local dV=dP*math.asin(dS/dP)local E=(dP*math.asin(dU/dP)-dV)/e2;local eg=dQ*math.cos(dV/dP)/e2;local ah=eg-dQ*math.cos((e2*E+dV)/dP)/e2;return ah+e3,E+e4 end;function aL.computeTravelTime(dS,dT,ah)if ah==0 then return 0 end;if dT>0 then local dV=dP*math.asin(dS/dP)local eg=dQ*math.cos(dV/dP)/dT;return(dP*math.acos(dT*(eg-ah)/dQ)-dV)/dT end;if dS==0 then return-1 end;assert(dS>0,'Acceleration and initial speed are both zero.')return ah/dS end;return aL end;local function eh()local vec3=require('cpml.vec3')local cn=cn()local function ct(a)return type(a)=='string'end;local function cr(cs)return type(cs)=='table'end;ei={}ei.__index=ei;function ei:escapeAndOrbitalSpeed(cY)assert(self.body)local ah=cY+self.body.radius;if not c4(ah,0)then local ej=y(self.body.GM/ah)return y(2)*ej,ej end;return nil,nil end;function ei:orbitalParameters(cV,ek)assert(self.body)assert(cr(cV)or ct(cV))assert(cr(ek))local el=(ct(cV)or cn.isMapPosition(cV))and self.body:convertToWorldCoordinates(cV)or vec3(cV)local cl=vec3(ek)local em=el-self.body.center;local en=cl:len2()local eo=em:len()local ep=self.body.GM;local eq=((en-ep/eo)*em-em:dot(cl)*cl)/ep;local c5=ep/(2*ep/eo-en)local er=eq:len()local dv=eq:normalize()local es=c5*(1-er)local et=c5*(1+er)local eu=es*dv+self.body.center;local ev=er<=1 and-et*dv+self.body.center or nil;local ew=y(c5*ep*(1-er*er))local ex=ev and 2*math.pi*y(c5^3/ep)local ey=math.acos(eq:dot(em)/(er*eo))if em:dot(cl)<0 then ey=-(ey-2*math.pi)end;local ez=math.acos((math.cos(ey)+er)/(1+er*math.cos(ey)))local eA=ez;if eA<0 then eA=eA+2*math.pi end;local eB=eA-er*math.sin(eA)local eC=0;local eD=0;local eE=0;if ex~=nil then eC=eB/(2*math.pi/ex)eD=ex-eC;eE=eD+ex/2;if ey-math.pi>0 then eD=eC;eE=eD+ex/2 end;if eE>ex then eE=eE-ex end end;return{periapsis={position=eu,speed=ew/es,circularOrbitSpeed=y(ep/es),altitude=es-self.body.radius},apoapsis=ev and{position=ev,speed=ew/et,circularOrbitSpeed=y(ep/et),altitude=et-self.body.radius},currentVelocity=cl,currentPosition=el,eccentricity=er,period=ex,eccentricAnomaly=ez,meanAnomaly=eB,timeToPeriapsis=eD,timeToApoapsis=eE,trueAnomaly=ey}end;local function eF(eG)local dF=cn.BodyParameters(eG.systemId,eG.id,eG.radius,eG.center,eG.GM)return setmetatable({body=dF},ei)end;return setmetatable(ei,{__call=function(cK,...)return eF(...)end})end;local function eH()local function eI(eJ)local bF=eK:closestBody(eJ)if(eJ-bF.center):len()>bF.radius+bF.noAtmosphericDensityAltitude then bF=e[0][0]end;return bF end;local function eL()local function eM(eN,eO)return eN.name<eO.name end;bp={}for ck,cl in pairs(e[0])do bp[#bp+1]={name=cl.name,index=ck}end;table.sort(bp,eM)end;local function eP(eQ)for ck,cl in pairs(eQ)do if cl.name and cl.name==eR.name then return ck end end;return-1 end;local function eS()by=eT;if eT==0 then eU="None"aa=nil;eR=nil;return true end;local eV=bp[eT].index;local eW=e[0][eV]if eW.center then eU=eW.name;aa=aK[0][eV]if eR~=nil then if ap==0 then if u(eX,eY)~=1 then v(eX,eY)end;if u(eZ,e_)~=1 then v(eZ,e_)end;if u(f0,f1)~=1 then v(f0,f1)end;if u(f2,f3)~=1 then v(f2,f3)end;if u(f4,f5)~=1 then v(f4,f5)end end;if u(f6,f7)~=1 then v(f6,f7)end;if u(f8,f9)~=1 then v(f8,f9)end;if u(fa,fb)~=1 then v(fa,fb)end end;eR=nil else eR=eW;for cK,cl in pairs(aK[0])do if cl.name==eR.planetname then aa=cl;eU=eR.name;break end end;if u(f6,f7)~=1 then v(f6,f7)end;if u(f8,f9)~=1 then v(f8,f9)end end;if eR==nil then fc=vec3(aa.center)else fc=eR.position end;if aa.planetname~="Space"then if aa.hasAtmosphere then fd=g(aa.radius*(fe-1)+aa.noAtmosphericDensityAltitude)else fd=g(aa.radius*(fe-1)+aa.surfaceMaxAltitude)end else fd=ff end;if eR~=nil and eR.planetname=="Space"then fg=0 else cK,fg=aN(aa):escapeAndOrbitalSpeed(fd)end;fh=0;fi=false;fj=false;fk=false;fl=false;fm=false;fn="Aligning"return true end;local function fo(fp)if not fl and not fq and not ak and not fr and not fs and not al then if fp==nil then eT=eT+1;if eT>#bp then eT=0 end else eT=eT-1;if eT<0 then eT=#bp end end;if eT==0 then eS()else local eV=bp[eT].index;local eW=e[0][eV]if eW~=nil and eW.name=="Space"or ft=="Custom Only"and eW.center or ft=="No Moons"and string.find(eW.name,"Moon")~=nil then if fp==nil then fo()else fo(1)end else eS()end end else a4="Disengage autopilot before changing Interplanetary Helper"bH("iph","AP")end end;local function fu()local fv=-1;fv=eP(e[0])if fv>-1 then table.remove(e[0],fv)end;fv=-1;fv=eP(fw)if fv~=-1 then a4=eR.name.." saved location cleared"table.remove(fw,fv)end;fo()eL()end;local function fx(fy,eJ,fz,fA)if dbHud_1 or fz then local bF=eI(eJ)local fB=bF.gravity;if fA then fB=c.getClosestPlanetInfluence()end;local fC={position=eJ,name=fy,planetname=bF.name,gravity=fB,safe=fA}if not fz then fw[#fw+1]=fC else for ck,cl in pairs(e[0])do if cl.name and fy==cl.name then table.remove(e[0],ck)end end end;table.insert(e[0],fC)eL()eS()a4="Location saved as "..fy.."("..bF.name..")"else a4="Databank must be installed to save permanent locations"end end;local fD={}function fD.UpdateAtlasLocationsList()eL()end;function fD.UpdateAutopilotTarget()eS()end;function fD.adjustAutopilotTargetIndex(fp)fo(fp)end;function fD.findAtlasIndex(eQ)eP(eQ)end;function fD.UpdatePosition(fE)local fv=eP(fw)if fv~=-1 then if fE~=nil then fw[fv].name=fE;eT=eT-1;fo()else local fF=fw[fv]fF.gravity=c.getClosestPlanetInfluence()fF.position=bi;fF.safe=true end;a4=fw[fv].name.." position updated ("..fw[fv].planetname..")"else a4="Name Not Found"end end;function fD.AddNewLocation(fy,eJ,fz,fA)fx(fy,eJ,fz,fA)end;function fD.ClearCurrentPosition()fu()end;for ck,cl in pairs(fw)do table.insert(e[0],cl)end;eL()if eT>#bp then eT=0 end;fD.UpdateAutopilotTarget()return fD end;function script.onStart()local fG=false;local function fH()local function fI(fJ)local fK=dbHud_1.hasKey;for ck,cl in pairs(fJ)do if fK(ck)then local cB=i(dbHud_1.getStringValue(ck))if cB~=nil then cl.set(cB)fG=true end end end end;if dbHud_1 then if not fL then fI(bS())coroutine.yield()fI(cm)else fI(cm)a4="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ag=5;fG=false end;coroutine.yield()if fG then a4="Loaded Saved Variables"aA=aB;aC=aD;fM=fN;fO=string.lower(fO)aV=aW;b0=b1;aw=[[rgb(]]..g(H+0.5)..","..g(L+0.5)..","..g(J+0.5)..[[)]]ax=[[rgb(]]..g(H*0.9+0.5)..","..g(L*0.9+0.5)..","..g(J*0.9+0.5)..[[)]]elseif not fL then a4="No Saved Variables Found - Exit HUD to save settings"end;if fP<1.500 then if fQ<2000 then a4="Updating LowOrbitHeight to new minimum default of 2000."fQ=2000 end end;fP=VERSION_NUMBER else a4="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if fR+180<E then fS=0 end;fR=E;fO=string.lower(fO)if string.find("keyboard virtual joystick mouse",fO)==nil then a4="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ag=7 end;if antigrav and not fT then if fU==nil then fU=aq end;antigrav.setBaseAltitude(fU)end;fV="Proceeding to Waypoint"end;local function fW()local function fX(fY,fZ)if fY>fZ then fZ=fY end;local f_,g0=0,0;if g1>0 then f_=g1*0.05 end;if g2>0 then g0=g2*0.05 end;fZ=fZ*(1-(f_+g0))return fZ end;local g3=b.getElementNameById;local g4=g5~=0 and g6~=0;for ck in pairs(ar)do local type=b.getElementTypeById(ar[ck])if p(type,'^.*Atmospheric Engine$')then if p(tostring(b.getElementTagsById(ar[ck])),'^.*vertical.*$')and b.getElementForwardById(ar[ck])[3]>0 then bj=true end end;if p(type,'^.*Space Engine$')then b9=true;if p(tostring(b.getElementTagsById(ar[ck])),'^.*vertical.*$')then local g7=b.getElementForwardById(ar[ck])if g7[3]<0 then b7=true else b8=true end end end;if type=="Landing Gear"then V=true end;if type=="Dynamic Core Unit"then local g8=k(ar[ck])if g8>10000 then G=110 elseif g8>1000 then G=55 elseif g8>150 then G=27 end end;aH=aH+k(ar[ck])if g4 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local g8=k(ar[ck])local g9=m(ar[ck])local fY=0;local ga=q()if type=="Atmospheric Fuel Tank"then local fZ=400;local gb=35.03;if g8>10000 then fZ=51200;gb=5480 elseif g8>1300 then fZ=6400;gb=988.67 elseif g8>150 then fZ=1600;gb=182.67 end;fY=g9-gb;if gc>0 then fZ=fZ+fZ*gc*0.2 end;fZ=fX(fY,fZ)aE[#aE+1]={ar[ck],g3(ar[ck]),fZ,gb,fY,ga}end;if type=="Rocket Fuel Tank"then local fZ=320;local gb=173.42;if g8>65000 then fZ=40000;gb=25740 elseif g8>6000 then fZ=5120;gb=4720 elseif g8>700 then fZ=640;gb=886.72 end;fY=g9-gb;if gd>0 then fZ=fZ+fZ*gd*0.1 end;fZ=fX(fY,fZ)aG[#aG+1]={ar[ck],g3(ar[ck]),fZ,gb,fY,ga}end;if type=="Space Fuel Tank"then local fZ=600;local gb=35.03;if g8>10000 then fZ=76800;gb=5480 elseif g8>1300 then fZ=9600;gb=988.67 elseif g8>150 then fZ=2400;gb=182.67 end;fY=g9-gb;if ge>0 then fZ=fZ+fZ*ge*0.2 end;fZ=fX(fY,fZ)aF[#aF+1]={ar[ck],g3(ar[ck]),fZ,gb,fY,ga}end end end;if not bj then gf,gg=false,false end end;local function gh()if gyro~=nil then av=gyro.getState()==1 end;if not gi then s:deactivateGroundEngineAltitudeStabilization()end;if fO~="keyboard"then w(1)else w(0)end;if door and(ao or not ao and aq<10000)then for cK,cl in pairs(door)do cl.toggle()end end;if switch then for cK,cl in pairs(switch)do cl.toggle()end end;if forcefield and(ao or not ao==0 and aq<10000)then for cK,cl in pairs(forcefield)do cl.toggle()end end;if antigrav then bk=antigrav.getState()==1;if bk and not fT then antigrav.show()end end;if n()==1 and gj then a.freeze(1)else a.freeze(0)end;if V then gk=d.control.isAnyLandingGearExtended()==1;if gk then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if am~=-1 or not ao and bd:len()<50 then gl=true;gk=true;if V then d.control.extendLandingGears()end else gl=false end;s:setTargetGroundAltitude(aX)if ao and am~=-1 then aM=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;gm=ao end;local function gn()local go={}local function gp()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local gq={[1]=4480,[6]=4480,[7]=6270}for gr,gs in pairs(e)do e[gr][0]=gp()e[gr][0].systemId=gr;go[gr]={}for gt,gu in pairs(e[gr])do gu.gravity=gu.gravity/9.8;gu.center=vec3(gu.center)gu.name=gu.name[1]gu.noAtmosphericDensityAltitude=gu.atmosphereThickness or gu.atmosphereRadius-gu.radius;gu.spaceEngineMinAltitude=gq[gu.id]or 0.68377*(gu.atmosphereThickness or gu.atmosphereRadius-gu.radius)gu.planetarySystemId=gr;gu.bodyId=gu.id;go[gr][gt]=gu;if gv==nil or gu.center.x<gv then gv=gu.center.x end;if gw==nil or gu.center.x>gw then gw=gu.center.x end;if gx==nil or gu.center.y<gx then gx=gu.center.y end;if gy==nil or gu.center.y>gy then gy=gu.center.y end;if gu.center and gu.name~="Space"then bB[#bB+1]=gu end end end;aJ=cn()aK=aJ(go)aL=dO()aN=eh()aP=eH()end;gz=false;gA=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})fH()coroutine.yield()fW()coroutine.yield()aQ=gB(d,b,c,a,e,vBooster,hover,gC,antigrav,f,g,l,n,o,q,r,s,u,x,y,A)gh()coroutine.yield()gn()aR=gD(b,a,library,radar_1,radar_2,f,t,y,bZ,z,G)aO=gE(d,b,c,a,e,radar_1,radar_2,antigrav,hover,gF,f,g,h,i,l,m,n,o,q,r,s,t,x,y,A,bZ)aO.ButtonSetup()aS=gG(d,b,c,a,e,vBooster,hover,antigrav,gF,dbHud_2,n,s,x,w,t,A,p,z,r)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",gH)c.setTimer("radarTick",gH)c.setTimer("hudTick",gI)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)bH("start","SU")end)coroutine.resume(gA)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not fT then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ap>0 or ap==0 and aq<10000)then for cK,cl in pairs(door)do cl.toggle()end end;if switch then for cK,cl in pairs(switch)do cl.toggle()end end;if forcefield and(ap>0 or ap==0 and aq<10000)then for cK,cl in pairs(forcefield)do cl.toggle()end end;bE=bD;cg()if gJ then gJ.activate()end;if gK then aQ.showWayPoint(gu,bi)end;bH("stop","SU")end;function script.onTick(gL)local gM=nil;if gL=="contact"then if not gN then gN=0 end;if E>gN+10 then a4="Radar Contact"bH("rdrCon","RC")gN=E end;c.stopTimer("contact")elseif gL=="tenthSecond"then local function gO()local gP=a.createData;local gQ=a.createWidget;gR=a.createWidgetPanel("Interplanetary Helper")gS=gQ(gR,"value")gT=gP('{"label": "Target Planet", "value": "N/A", "u":""}')v(gT,gS)gU=gQ(gR,"value")gV=gP('{"label": "distance", "value": "N/A", "u":""}')v(gV,gU)f9=gQ(gR,"value")f8=gP('{"label": "Travel Time", "value": "N/A", "u":""}')v(f8,f9)f7=gQ(gR,"value")f6=gP('{"label": "Maximum Mass", "value": "N/A", "u":""}')v(f6,f7)fb=gQ(gR,"value")fa=gP('{"label": "Target Altitude", "value": "N/A", "u":""}')v(fa,fb)f3=gQ(gR,"value")f2=gP('{"label": "Cur Brake distance", "value": "N/A", "u":""}')f1=gQ(gR,"value")f0=gP('{"label": "Cur Brake Time", "value": "N/A", "u":""}')e_=gQ(gR,"value")eZ=gP('{"label": "Max Brake distance", "value": "N/A", "u":""}')eY=gQ(gR,"value")eX=gP('{"label": "Max Brake Time", "value": "N/A", "u":""}')f5=gQ(gR,"value")f4=gP('{"label": "Projected Altitude", "value": "N/A", "u":""}')if not ao then v(f2,f3)v(f0,f1)v(eZ,e_)v(eX,eY)v(f4,f5)end end;local function gW()t(gR)gR=nil end;local function gX()if not fl then if eR==nil or eR.planetname~=gu.name then gY=(aa.center-bi):len()else gY=(eR.position-bi):len()end end;local ef=bf;local gZ=c.getThrottle()/100;if g_ then gZ=N end;local h0,h1=aL.computeDistanceAndTime(bf,h2,at,d:maxForceForward()*gZ,h3,0)local a6,a7;if not h4 then a6,a7=aQ.GetAutopilotBrakeDistanceAndTime(h2)else a6,a7=aQ.GetAutopilotTBBrakeDistanceAndTime(h2)end;local cK,h5;if not h4 and ef>0 then cK,h5=aQ.GetAutopilotBrakeDistanceAndTime(ef)else cK,h5=aQ.GetAutopilotTBBrakeDistanceAndTime(ef)end;local h6=0;local h7=0;if fk or not fl and ef>5 then h7=aL.computeTravelTime(ef,0,gY)elseif a6+h0<gY then h6=gY-(a6+h0)h7=aL.computeTravelTime(8333.0556,0,h6)else local h8=(gY-a6)/h0;h0=gY-a6;h1=h1*h8 end;if eR~=nil and eR.planetname==gu.name and not fl then return h7 elseif fj then return h5 elseif fk then return h7+h5 else return h1+a7+h7 end end;local function h9(fB,ha)if fB==nil then fB=b.g()end;fB=A(fB,5)if ha~=nil and ha or(gM==nil or gM~=fB)then local ef=bd:len()local hb=i(c.getData()).maxBrake;if hb~=nil and hb>0 and ao then hb=hb/r(ef/100,0.1,1)hb=hb/ap;if ap>0.10 then if fS then fS=(fS+hb)/2 else fS=hb end end end;if hb~=nil and hb>0 then hc=hb end;gM=fB end end;h9(nil,true)if bl~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bl then aQ.cmdCruise(bl)else bl=nil end end;if eU~="None"then if gR==nil then gO()end;if eU~=nil then local hd=eR~=nil;local he=0.5*fS/aa:getGravity(aa.center+vec3(0,0,1)*aa.radius):len()he=he>1000000 and A(he/1000000,2).." kTons"or A(he/1000,2).." Tons"u(gT,'{"label": "Target", "value": "'..eU..'", "u":""}')hf=gX()if hd and not fl then ah=(bi-eR.position):len()else ah=(fc-bi):len()end;if not h4 then a6,a7=aQ.GetAutopilotBrakeDistanceAndTime(bf)a8,a9=aQ.GetAutopilotBrakeDistanceAndTime(h2)else a6,a7=aQ.GetAutopilotTBBrakeDistanceAndTime(bf)a8,a9=aQ.GetAutopilotTBBrakeDistanceAndTime(h2)end;local hg=c8(ah)u(gV,'{"label": "distance", "value": "'..hg..'"}')u(f8,'{"label": "Travel Time", "value": "'..cb(hf)..'", "u":""}')hg=c8(a6)u(f2,'{"label": "Cur Brake distance", "value": "'..hg..'"}')u(f0,'{"label": "Cur Brake Time", "value": "'..cb(a7)..'", "u":""}')hg=c8(a8)u(eZ,'{"label": "Max Brake distance", "value": "'..hg..'"}')u(eX,'{"label": "Max Brake Time", "value": "'..cb(a9)..'", "u":""}')u(f6,'{"label": "Max Brake Mass", "value": "'..h("%s",he)..'", "u":""}')hg=c8(fd)u(fa,'{"label": "Target Orbit", "value": "'..hg..'"}')if ap>0 and not gm then a.removeDataFromWidget(eX,eY)a.removeDataFromWidget(eZ,e_)a.removeDataFromWidget(f0,f1)a.removeDataFromWidget(f2,f3)a.removeDataFromWidget(f4,f5)gm=true;if not bm and g_ and(hh or fs or al)then aQ.cmdThrottle(1)gl=false;R=false end end;if ap==0 and gm then if u(eX,eY)==1 then v(eX,eY)end;if u(eZ,e_)==1 then v(eZ,e_)end;if u(f0,f1)==1 then v(f0,f1)end;if u(f2,f3)==1 then v(f2,f3)end;if u(f4,f5)==1 then v(f4,f5)end;gm=false end end else gW()end;if warpdrive~=nil then if i(warpdrive.getData()).destination~="Unknown"and i(warpdrive.getData()).distance>400000 then warpdrive.show()hi=true else warpdrive.hide()hi=false end end;aO.TenthTick()elseif gL=="oneSecond"then local function hj(hk)local hl=0;az=""local hm=aH;local hn=0;local ho=0;local hp=0;local hq=0;local hr=""local hs=b.getElementHitPointsById;for ck in pairs(ar)do local g8=0;local ht=0;ht=k(ar[ck])g8=hs(ar[ck])hn=hn+g8;if g8<ht then if g8==0 then hp=hp+1 else ho=ho+1 end;if aI and#ay==0 then eJ=vec3(b.getElementPositionById(ar[ck]))local b_=eJ.x;local c0=eJ.y;local hu=eJ.z;table.insert(ay,b.spawnArrowSticker(b_,c0,hu+1,"down"))table.insert(ay,b.spawnArrowSticker(b_,c0,hu+1,"down"))b.rotateSticker(ay[2],0,0,90)table.insert(ay,b.spawnArrowSticker(b_+1,c0,hu,"north"))table.insert(ay,b.spawnArrowSticker(b_+1,c0,hu,"north"))b.rotateSticker(ay[4],90,90,0)table.insert(ay,b.spawnArrowSticker(b_-1,c0,hu,"south"))table.insert(ay,b.spawnArrowSticker(b_-1,c0,hu,"south"))b.rotateSticker(ay[6],90,-90,0)table.insert(ay,b.spawnArrowSticker(b_,c0-1,hu,"east"))table.insert(ay,b.spawnArrowSticker(b_,c0-1,hu,"east"))b.rotateSticker(ay[8],90,0,90)table.insert(ay,b.spawnArrowSticker(b_,c0+1,hu,"west"))table.insert(ay,b.spawnArrowSticker(b_,c0+1,hu,"west"))b.rotateSticker(ay[10],-90,0,90)table.insert(ay,ar[ck])end elseif aI and#ay>0 and ay[11]==ar[ck]then for hv in pairs(ay)do b.deleteSticker(ay[hv])end;ay={}end end;hl=g(hn/hm*100)if hl<100 then hk[#hk+1]=bZ(0,0,"","pbright txt")hq=g(hl*2.55)hr=h("rgb(%d,%d,%d)",255-hq,hq,0)if hl<100 then hk[#hk+1]=bZ("50%",1035,"Elemental Integrity: "..hl.."%","txtbig txtmid","fill:"..hr)if hp>0 then hk[#hk+1]=bZ("50%",1055,"Disabled Modules: "..hp.." Damaged Modules: "..ho,"txtbig txtmid","fill:"..hr)elseif ho>0 then hk[#hk+1]=bZ("50%",1055,"Damaged Modules: "..ho,"txtbig txtmid","fill:"..hr)end end end end;local function hw()if hx then if hy==nil and(hz~=nil or gk)then _autoconf.displayCategoryPanel(hx,weapon_size,"Weapons","weapon",true)hy=_autoconf.panels[_autoconf.panels_size]elseif hy~=nil and hz==nil and not gk then t(hy)hy=nil end end end;local function hA()local ga=q()local hB=bf;local hC=ga-as;if hB>1.38889 then hB=hB/1000;local hD=hB*(ga-as)hE=hE+hD;ab=ab+hD end;ac=ac+hC;hF=hF+hC;as=ga end;hA()bz=b.getPlayersOnBoard()bA=b.getDockedConstructs()hw()local hk={}aO.OneSecond(hk)if hG then hj(hk)end;ai=table.concat(hk,"")collectgarbage("collect")elseif gL=="fiveSecond"then if not hH then return end;an=dbHud_1.getStringValue("SPBAutopilotTargetName")if an~=nil and an~=""and an~="SatNavNotChanged"then local cB=i(dbHud_1.getStringValue("SavedLocations"))if cB~=nil then _G["SavedLocations"]=cB;local fv=-1;local fC;for ck,cl in pairs(fw)do if cl.name and cl.name=="SatNav Location"then fv=ck;break end end;if fv~=-1 then fC=fw[fv]fv=-1;for ck,cl in pairs(e[0])do if cl.name and cl.name=="SatNav Location"then fv=ck;break end end;if fv>-1 then e[0][fv]=fC end;aP.UpdateAtlasLocationsList()a4=fC.name.." position updated"end end;for bR=1,#bp do if bp[bR].name==an then eT=bR;a.print("Index = "..eT.." "..bp[bR].name)aP.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif gL=="msgTick"then local hk={}aO.DisplayMessage(hk,"empty")a4="empty"c.stopTimer("msgTick")ag=3 elseif gL=="animateTick"then aU=true;aT=false;ae=0;af=0;c.stopTimer("animateTick")elseif gL=="hudTick"then aO.hudtick()elseif gL=="apTick"then aQ.APTick()elseif gL=="radarTick"then aR.UpdateRadar()elseif gL=="tagTick"then if hI=="Off"then hI="All"elseif hI=="All"then hI="Longitude"elseif hI=="Longitude"then hI="Lateral"elseif hI=="Lateral"then hI="Vertical"else hI="Off"end;a4="Extra Engine Tags: "..hI;c.stopTimer("tagTick")end end;function script.onFlush()local function hJ(hK,hL)local hM=vec3()local hN=vec3()if hK==axisCommandId.longitudinal then hM=vec3(b.getConstructOrientationForward())hN=bb elseif hK==axisCommandId.vertical then hM=vec3(b.getConstructOrientationUp())hN=ba elseif hK==axisCommandId.lateral then hM=vec3(b.getConstructOrientationRight())hN=bc else return vec3()end;local hO=vec3(b.getWorldGravity())local hP=hO:dot(hN)local hQ=vec3(b.getWorldAirFrictionAcceleration())local hR=hQ:dot(hN)local hS=bd:dot(hM)local hT=hL*constants.kph2m;if hU==nil then hU=pid.new(10,0,10.0)end;hU:inject(hT-hS)local hV=hU:get()local hW=(hV-hR-hP)*hN;return hW end;local function hX(hK,hL)local hM=vec3()local hN=vec3()if hK==axisCommandId.longitudinal then hM=vec3(b.getConstructOrientationForward())hN=bb elseif hK==axisCommandId.vertical then hM=vec3(b.getConstructOrientationUp())hN=ba elseif hK==axisCommandId.lateral then hM=vec3(b.getConstructOrientationRight())hN=bc else return vec3()end;local hO=vec3(b.getWorldGravity())local hP=hO:dot(hN)local hQ=vec3(b.getWorldAirFrictionAcceleration())local hR=hQ:dot(hN)local hS=bd:dot(hM)local hT=hL*constants.kph2m;if hY==nil then hY=pid.new(10,0,10.0)end;hY:inject(hT-hS)local hV=hY:get()local hW=(hV-hR-hP)*hN;return hW end;local function hZ(h_,i0,eO)local i1=h_:cross(eO):normalize_inplace()local i2=math.acos(r(i1:dot(-i0),-1,1))*constants.rad2deg;if i1:cross(-i0):dot(eO)<0 then i2=-i2 end;return i2 end;if antigrav and not fT then if not bk and antigrav.getBaseAltitude()~=fU then antigrav.setBaseAltitude(fU)end end;bm=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bm and R then aQ.cmdThrottle(0)R=false elseif not bm and not R then N=0;R=true end;i3=math.max(i3,0.01)i4=math.max(i4,0.01)i5=math.max(i5,0.01)i6=math.max(i6,0.01)i7=math.max(i7,0.01)i8=math.max(i8,0.01)i9=math.max(i9,0.01)local ia=r(W+X+a.getControlDeviceForwardInput(),-1,1)local ib=r(Z+a1+a.getControlDeviceYawInput(),-1,1)local ic=r(_+Y-a.getControlDeviceLeftRightInput(),-1,1)local id=a0;bg=vec3(b.getWorldVertical())if bg==nil or bg:len()==0 then bg=(gu.center-bi):normalize()end;ba=vec3(b.getConstructWorldOrientationUp())bb=vec3(b.getConstructWorldOrientationForward())bc=vec3(b.getConstructWorldOrientationRight())be=vec3(b.getWorldVelocity())bd=vec3(b.getVelocity())bi=vec3(b.getConstructWorldPos())at=b.getConstructMass()bf=vec3(be):len()bh=-bg:dot(be)bo=getRoll(bg,bb,bc)local ie=bo/180*math.pi;local ig=math.cos(ie)local ih=math.sin(ie)bn=hZ(bg,bb,bc*ig+ba*ih)local ii=be:normalize()local ij=f(bo)local ik=utils.sign(bo)local il=vec3(b.getWorldAngularVelocity())local im=ia*i3*bc+ib*i5*bb+ic*i4*ba;if aV==true and bg:len()>0.01 then local io=f(a_-bo)if((ip or fs or iq or aj or hh or fr)and io>0 or ap>0.0 and io<ir and aW)and ib==0 and f(bn)<85 then local is=a_;local it=i9;if ap==0 then it=it/4;a_=0;is=0 end;if iu==nil then iu=pid.new(it*0.01,0,it*0.1)end;iu:inject(is-bo)local iv=iu:get()im=im+iv*bb end end;local iw=1;local ix=0;local iy=1;local iz=a.getMouseWheel()if iz>0 then bF("HERE1")aQ.changeSpd()elseif iz<0 then aQ.changeSpd(true)else au=true end;O=0;if ao and g_ and bm then if iA==nil then iA=pid.new(0.5,0,1)end;iA:inject(b0/3.6-be:dot(bb))local iB=iA:get()Q=r(iB,-1,1)if Q<N and ap>0.005 then P=true;s:setThrottleCommand(axisCommandId.longitudinal,r(Q,0.01,1))else P=false;s:setThrottleCommand(axisCommandId.longitudinal,N)end;if iC==nil then iC=pid.new(1*0.01,0,1*0.1)end;iC:inject(be:len()-b0/3.6)local iD=r(iC:get(),0,1)if ap>0 and bh<-80 or ap>0.005 then O=iD end;if O>0 then if P and Q==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else Q=r(Q,0.01,1)end;local iE=''local iF=vec3()local iG=hJ(axisCommandId.vertical,ad*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",iG,ix)local iH='thrust analog longitudinal 'if hI=="All"or hI=="Longitude"then iH=iH..iI end;local iJ=s:getAxisCommandType(axisCommandId.longitudinal)local iK=s:composeAxisAccelerationFromThrottle(iH,axisCommandId.longitudinal)local iL=hX(axisCommandId.lateral,iM*1000)iE=iE..' , '.."lateral airfoil , lateral ground "iF=iF+iL;if iF:len()>constants.epsilon then d:setEngineForceCommand(iE,iF,ix,'','','',iy)end;d:setEngineForceCommand(iH,iK,iw)local iN='thrust analog vertical fueled 'local iO='thrust analog lateral fueled 'if hI=="All"or hI=="Lateral"then iO=iO..iP end;if hI=="All"or hI=="Vertical"then iN=iN..iQ end;if ad~=0 or iq and gl or not gk and not gi then d:setEngineForceCommand(iN,iG,iw)else d:setEngineForceCommand(iN,vec3(),iw)end;if iM~=0 then d:setEngineForceCommand(iO,iL,iw)else d:setEngineForceCommand(iO,vec3(),iw)end;if id==0 then id=O end;local iR=-id*(i7*be+i8*ii)d:setEngineForceCommand('brake',iR)else if g_ then s:setThrottleCommand(axisCommandId.longitudinal,N)end;local hL=c.getAxisCommandValue(0)if not bm then if iC==nil then iC=pid.new(1*0.01,0,1*0.1)end;iC:inject(be:len()-hL/3.6)local iD=r(iC:get(),0,1)id=r(id+iD,0,1)end;local iR=-id*(i7*be+i8*ii)d:setEngineForceCommand('brake',iR)local iE=''local iF=vec3()local iS=false;local iH='thrust analog longitudinal 'if hI=="All"or hI=="Longitude"then iH=iH..iI end;local iJ=s:getAxisCommandType(axisCommandId.longitudinal)if iJ==axisCommandType.byThrottle then local iK=s:composeAxisAccelerationFromThrottle(iH,axisCommandId.longitudinal)d:setEngineForceCommand(iH,iK,iw)elseif iJ==axisCommandType.byTargetSpeed then local iK=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)iE=iE..' , '..iH;iF=iF+iK;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then iS=true end end;local iO='thrust analog lateral 'if hI=="All"or hI=="Lateral"then iO=iO..iP end;local iT=s:getAxisCommandType(axisCommandId.lateral)if iT==axisCommandType.byThrottle then local iU=s:composeAxisAccelerationFromThrottle(iO,axisCommandId.lateral)d:setEngineForceCommand(iO,iU,iw)elseif iT==axisCommandType.byTargetSpeed then local iL=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)iE=iE..' , '..iO;iF=iF+iL end;local iN='thrust analog vertical 'if hI=="All"or hI=="Vertical"then iN=iN..iQ end;local iV=s:getAxisCommandType(axisCommandId.vertical)if iV==axisCommandType.byThrottle then local iG=s:composeAxisAccelerationFromThrottle(iN,axisCommandId.vertical)if ad~=0 or iq and gl then d:setEngineForceCommand(iN,iG,iw,'airfoil','ground','',iy)else d:setEngineForceCommand(iN,vec3(),iw)d:setEngineForceCommand('airfoil vertical',iG,iw,'airfoil','','',iy)d:setEngineForceCommand('ground vertical',iG,iw,'ground','','',iy)end elseif iV==axisCommandType.byTargetSpeed then if ad<0 then d:setEngineForceCommand('hover',vec3(),iw)end;local iW=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)iE=iE..' , '..iN;iF=iF+iW end;if iF:len()>constants.epsilon then if a0~=0 or iS or f(ii:dot(bb))<0.5 then iE=iE..', brake'end;d:setEngineForceCommand(iE,iF,ix,'','','',iy)end end;local iX=i6*(im-il)local iY=vec3(b.getWorldAirFrictionAngularAcceleration())iX=iX-iY;d:setEngineTorqueCommand('torque',iX,iw,'airfoil','','',iy)d:setBoosterCommand('rocket_engine')if a5 and not iZ then local ef=bd:len()local i_=0.15;if not bm then local j0=s:getTargetSpeed(axisCommandId.longitudinal)if ef*3.6>j0*(1-i_)and j1 then j1=false;d:toggleBoosters()elseif ef*3.6<j0*(1-i_)and not j1 then j1=true;d:toggleBoosters()end else local gZ=c.getThrottle()if g_ then gZ=N*100 end;local hL=gZ/100;if l==0 then hL=hL*h2;if ef>=hL*(1-i_)and j1 then j1=false;d:toggleBoosters()elseif ef<hL*(1-i_)and not j1 then j1=true;d:toggleBoosters()end else local j2=g(b0)hL=hL*j2/3.6;if ef>=hL*(1-i_)and j1 then j1=false;d:toggleBoosters()elseif ef<hL*(1-i_)and not j1 then j1=true;d:toggleBoosters()end end end end end;function script.onUpdate()if not gz then local j3=coroutine.status(gA)if j3=="suspended"then local cG,j4=coroutine.resume(gA)if j4 then a.print("ERROR STARTUP: "..j4)end elseif j3=="dead"then gz=true end end;if gz then d:update()if not aT and j5~=j6 then a.setScreen(j5)end;j6=j5 end end;function script.onActionStart(j7)aS.startControl(j7)end;function script.onActionStop(j7)aS.stopControl(j7)end;function script.onActionLoop(j7)aS.loopControl(j7)end;function script.onInputText(c1)aS.inputTextControl(c1)end;function script.onEnter(cP)if radar_1 and not ao and not bq then c.setTimer("contact",0.1)end end;function script.onLeave(cP)if radar_1 and j8 then if#bt>650 then cP=tostring(cP)bt[cP]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
