name: ArchHud - Archaegeo v0.735 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.735;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=66000;W=1000;X=50;Y=0;Z=100000;_=13888.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=1750;av=350;aw=50;ax=250;ay=0;az=30;aA=100;aB={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},radarX={set=function(K)au=K end,get=function()return au end},radarY={set=function(K)av=K end,get=function()return av end},DeadZone={set=function(K)aw=K end,get=function()return aw end},OrbitMapSize={set=function(K)ax=K end,get=function()return ax end},OrbitMapX={set=function(K)ay=K end,get=function()return ay end},OrbitMapY={set=function(K)az=K end,get=function()return az end},soundVolume={set=function(K)aA=K end,get=function()return aA end}}aC=5.0;aD=1.0;aE=0.003;aF=0.003;aG=2;aH=1.5;aI=180;aJ=150;aK=0.002;aL=2;aM=0.8;aN=1;aO=3;aP=1;aQ=40;aR=0.0666667;aS=0.0;aT="none"aU="none"aV="none"aW={speedChangeLarge={set=function(K)aC=K end,get=function()return aC end},speedChangeSmall={set=function(K)aD=K end,get=function()return aD end},MouseXSensitivity={set=function(K)aE=K end,get=function()return aE end},MouseYSensitivity={set=function(K)aF=K end,get=function()return aF end},autoRollFactor={set=function(K)aG=K end,get=function()return aG end},rollSpeedFactor={set=function(K)aH=K end,get=function()return aH end},autoRollRollThreshold={set=function(K)aI=K end,get=function()return aI end},minRollVelocity={set=function(K)aJ=K end,get=function()return aJ end},TrajectoryAlignmentStrength={set=function(K)aK=K end,get=function()return aK end},torqueFactor={set=function(K)aL=K end,get=function()return aL end},pitchSpeedFactor={set=function(K)aM=K end,get=function()return aM end},yawSpeedFactor={set=function(K)aN=K end,get=function()return aN end},brakeSpeedFactor={set=function(K)aO=K end,get=function()return aO end},brakeFlatFactor={set=function(K)aP=K end,get=function()return aP end},DampingMultiplier={set=function(K)aQ=K end,get=function()return aQ end},hudTickRate={set=function(K)aR=K end,get=function()return aR end},ExtraEscapeThrust={set=function(K)aS=K end,get=function()return aS end},ExtraLongitudeTags={set=function(K)aT=K end,get=function()return aT end},ExtraLateralTags={set=function(K)aU=K end,get=function()return aU end},ExtraVerticalTags={set=function(K)aV=K end,get=function()return aV end}}aX=j;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=1000;b9=false;ba=false;bb=false;bc=false;bd=0;be="Aligning"bf=0;bg=1;bh="None"bi=nil;bj=0;bk=nil;bl=0.0;bm=0;bn={}bo=false;bp=0;bq=0;br=nil;bs=0;bt=1000;bu=0;bv=false;bw=0;bx=false;by="All"bz=true;bA="Off"bB=0.000;bC={}bD={}bE={VertTakeOff={set=function(K)b7=K end,get=function()return b7 end},VertTakeOffEngine={set=function(K)aY=K end,get=function()return aY end},SpaceTarget={set=function(K)bv=K end,get=function()return bv end},BrakeToggleStatus={set=function(K)aX=K end,get=function()return aX end},BrakeIsOn={set=function(K)aZ=K end,get=function()return aZ end},RetrogradeIsOn={set=function(K)a_=K end,get=function()return a_ end},ProgradeIsOn={set=function(K)b0=K end,get=function()return b0 end},Autopilot={set=function(K)b1=K end,get=function()return b1 end},TurnBurn={set=function(K)b2=K end,get=function()return b2 end},AltitudeHold={set=function(K)b3=K end,get=function()return b3 end},BrakeLanding={set=function(K)b4=K end,get=function()return b4 end},Reentry={set=function(K)b6=K end,get=function()return b6 end},AutoTakeoff={set=function(K)b5=K end,get=function()return b5 end},HoldAltitude={set=function(K)b8=K end,get=function()return b8 end},AutopilotAccelerating={set=function(K)b9=K end,get=function()return b9 end},AutopilotBraking={set=function(K)bb=K end,get=function()return bb end},AutopilotCruising={set=function(K)bc=K end,get=function()return bc end},AutopilotRealigned={set=function(K)ba=K end,get=function()return ba end},AutopilotEndSpeed={set=function(K)bd=K end,get=function()return bd end},AutopilotStatus={set=function(K)be=K end,get=function()return be end},AutopilotPlanetGravity={set=function(K)bf=K end,get=function()return bf end},PrevViewLock={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetName={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetCoords={set=function(K)bi=K end,get=function()return bi end},AutopilotTargetIndex={set=function(K)bj=K end,get=function()return bj end},TotalDistanceTravelled={set=function(K)bl=K end,get=function()return bl end},TotalFlightTime={set=function(K)bm=K end,get=function()return bm end},SavedLocations={set=function(K)bn=K end,get=function()return bn end},VectorToTarget={set=function(K)bo=K end,get=function()return bo end},LocationIndex={set=function(K)bp=K end,get=function()return bp end},LastMaxBrake={set=function(K)bq=K end,get=function()return bq end},LockPitch={set=function(K)br=K end,get=function()return br end},LastMaxBrakeInAtmo={set=function(K)bs=K end,get=function()return bs end},AntigravTargetAltitude={set=function(K)bt=K end,get=function()return bt end},LastStartTime={set=function(K)bu=K end,get=function()return bu end},iphCondition={set=function(K)by=K end,get=function()return by end},stablized={set=function(K)bz=K end,get=function()return bz end},UseExtra={set=function(K)bA=K end,get=function()return bA end},SelectedTab={set=function(K)bF=K end,get=function()return bF end},saveRoute={set=function(K)bC=K end,get=function()return bC end},apRoute={set=function(K)bD=K end,get=function()return bD end}}local function bG(a,b,c,bH,bI,bJ)bK=bH()bL=0;bM=0;bN=false;bO=0;bP=false;bQ=false;bR=0;bS=0;bT=0;bU=0;bV=false;bW=false;bX="empty"bY=3;bZ=false;b_=0;c0=0;c1=nil;c2=0;c3=0;c4=0;c5=false;c6=false;c7=false;c8=-1;c9=bJ()>0;ca=bJ()cb=b.getAltitude()cc=b.getConstructMass()cd=nil;ce=a9;cf=aa;cg={}ch={}ci={}cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=false;ct=false;cu=p;cv=false;cw=U;cx=nil;cy=0;cz=false;cA=false;cB=false;cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getVelocity())cF=vec3(b.getWorldVelocity())cG=vec3(cF):len()cH=vec3(b.getWorldVertical())cI=-cH:dot(cF)cJ=vec3(b.getConstructWorldPos())cK=false;cL=false;cM=true;cN=0;cO=0;cP={}cQ=false;cR=50000;cS=nil;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;cU=false;cV=nil;cW=false;cX=0;cY=nil;cZ=nil;c_={}d0=90;d1=w;d2=nil;d3=nil;d4={}d5={}d6=false;d7=nil;d8=0;d9=false;da=b.getMaxSpeed()if db then dc=bI(0.5+db.getShieldHitpoints()*100/db.getMaxShieldHitpoints())end end;local function dd(d,b,c,a,de,df,dg,dh,di)local function dj(dk)return type(dk)=='number'end;local function dl(dk)return type(dg(dk))=='number'end;local function dm(dn)return type(dn)=='table'end;local function dp(a)return type(a)=='string'end;local function dq(dr)return dm(dr)and dj(dr.x and dr.y and dr.z)end;local function ds(dt)return dm(dt)and dj(dt.latitude and dt.longitude and dt.altitude and dt.id and dt.systemId)end;local du=math.pi/180;local dv=180/math.pi;local dw=1e-10;local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy='::pos{'..dx..','..dx..','..dx..','..dx..','..dx..'}'local utils=utils;local vec3=vec3;local function dz(dk)local dA=string.gsub(string.reverse(de('%.4f',dk)),'^0*%.?','')return dA==''and'0'or string.reverse(dA)end;local function dB(dC)if dq(dC)then return de('{x=%.3f,y=%.3f,z=%.3f}',dC.x,dC.y,dC.z)end;if dm(dC)and not getmetatable(dC)then local dD={}local dE=next(dC)if type(dE)=='nil'or dE==1 then dD=dC else for dF,dr in pairs(dC)do local dG=dB(dr)if type(dF)=='number'then table.insert(dD,de('[%s]=%s',dF,dG))else table.insert(dD,de('%s=%s',dF,dG))end end end;return de('{%s}',table.concat(dD,','))end;if dp(dC)then return de("'%s'",dC:gsub("'",[[\']]))end;return tostring(dC)end;local dH={}dH.__index=dH;dH.__tostring=function(dC,dI)local dJ={}for dF in pairs(dC)do table.insert(dJ,dF)end;table.sort(dJ)local dD={}for dK,dF in ipairs(dJ)do local dG=dB(dC[dF])if type(dF)=='number'then table.insert(dD,de('[%s]=%s',dF,dG))else table.insert(dD,de('%s=%s',dF,dG))end end;if dI then return de('%s%s',dI,table.concat(dD,',\n'..dI))end;return de('{%s}',table.concat(dD,','))end;dH.__eq=function(dL,dM)return dL.systemId==dM.systemId and dL.id==dM.id and di(dL.radius,dM.radius)and di(dL.center.x,dM.center.x)and di(dL.center.y,dM.center.y)and di(dL.center.z,dM.center.z)and di(dL.GM,dM.GM)end;local function dN(dO,dP,dQ,dR,dS)assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(dQ),'Argument 3 (radius) must be a number:'..type(dQ))assert(dm(dR),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dR))assert(dl(dS),'Argument 5 (GM) must be a number:'..type(dS))return setmetatable({systemId=dg(dO),id=dg(dP),radius=dg(dQ),center=vec3(dR),GM=dg(dS)},dH)end;local dT={}dT.__index=dT;dT.__tostring=function(dU)return de('::pos{%d,%d,%s,%s,%s}',dU.systemId,dU.id,dz(dU.latitude*dv),dz(dU.longitude*dv),dz(dU.altitude))end;dT.__eq=function(dL,dM)return dL.id==dM.id and dL.systemId==dM.systemId and di(dL.latitude,dM.latitude)and di(dL.altitude,dM.altitude)and(di(dL.longitude,dM.longitude)or di(dL.latitude,math.pi/2)or di(dL.latitude,-math.pi/2))end;local function dV(dW,dP,dX,dY,dZ)local dO=dW;if dp(dW)and not dY and not dZ and not dP and not dX then dO,dP,dX,dY,dZ=d_(dW,dy)assert(dO,'Argument 1 (position string) is malformed.')else assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(dX),'Argument 3 (latitude) must be in degrees:'..type(dX))assert(dl(dY),'Argument 4 (longitude) must be in degrees:'..type(dY))assert(dl(dZ),'Argument 5 (altitude) must be in meters:'..type(dZ))end;dO=dg(dO)dP=dg(dP)dX=dg(dX)dY=dg(dY)dZ=dg(dZ)if dP==0 then return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=dP,systemId=dO},dT)end;return setmetatable({latitude=du*df(dX,-90,90),longitude=du*(dY%360),altitude=dZ,id=dP,systemId=dO},dT)end;local e0={}e0.__index=e0;e0.__tostring=function(dC,dI)local e1=dI and dI..'  'local e2={}local dJ={}for dF in pairs(dC)do table.insert(dJ,dF)end;table.sort(dJ)for dK,e3 in ipairs(dJ)do e4=dC[e3]local e5=dH.__tostring(e4,e1)if dI then table.insert(e2,de('[%s]={\n%s\n%s}',e3,e5,dI))else table.insert(e2,de('  [%s]=%s',e3,e5))end end;if dI then return de('\n%s%s%s',dI,table.concat(e2,',\n'..dI),dI)end;return de('{\n%s\n}',table.concat(e2,',\n'))end;local function e6(e7)local e={}local pid;for dK,dr in pairs(e7)do local dP=dr.planetarySystemId;if type(dP)~='number'then error('Invalid planetary s ID: '..tostring(dP))elseif pid and dP~=pid then error('Mistringmatch planetary s IDs: '..dP..' and '..pid)end;local e8=dr.bodyId;if type(e8)~='number'then error('Invalid body ID: '..tostring(e8))elseif e[e8]then error('Duplicate body ID: '..tostring(e8))end;setmetatable(dr.center,getmetatable(vec3.unit_x))e[e8]=setmetatable(dr,dH)pid=dP end;return setmetatable(e,e0)end;e9={}local function ea(e7)return setmetatable({galaxyAtlas=e7 or{}},e9)end;e9.__index=function(dn,K)if type(K)=='number'then local a=dn.galaxyAtlas[K]return e6(a)end;return rawget(e9,K)end;e9.__pairs=function(dC)return function(dn,dF)local eb,ec=next(dn,dF)return eb,ec and e6(ec)end,dC.galaxyAtlas,nil end;e9.__tostring=function(dC)local ed={}for dK,ee in pairs(dC or{})do local ef=ee:getPlanetarySystemId()local eg=e0.__tostring(ee,'    ')table.insert(ed,de('  [%s]={%s\n  }',ef,eg))end;return de('{\n%s\n}\n',table.concat(ed,',\n'))end;e9.BodyParameters=dN;e9.MapPosition=dV;e9.PlanetarySystem=e6;function e9.createBodyParameters(dO,dP,eh,ei,ej,ek,el)assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(eh),'Argument 3 (surfaceArea) must be a number:'..type(eh))assert(dm(ei),'Argument 4 (aPosition) must be an array or vec3:'..type(ei))assert(dm(ej),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ej))assert(dl(ek),'Argument 6 (altitude) must be in meters:'..type(ek))assert(dl(el),'Argument 7 (gravityAtPosition) must be number:'..type(el))local dQ=dh(eh/4/math.pi)local c4=dQ+ek;local em=vec3(ei)+c4*vec3(ej)local dS=el*c4*c4;return dN(dO,dP,dQ,em,dS)end;e9.isMapPosition=ds;function e9:getPlanetarySystem(dW)if K==nil then K=0 end;if ec==nil then ec=0 end;local dO=dW;if ds(dW)then dO=dW.systemId end;if type(dO)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(ec)~=e0 then a=e6(a)end;return a end end end;function e0:sizeCalculator(en)return 1.05*en.radius end;function e0:castIntersections(eo,ep,eq,er,es,et)local eu={}if es then for dK,en in pairs(es)do table.insert(eu,en)end else eu=c_ end;if not et then table.sort(eu,function(ev,ew)local ex=ev.center;local ey=ew.center;return(ex.x-eo.x)^2+(ex.y-eo.y)^2+(ex.z-eo.z)^2<(ey.x-eo.x)^2+(ey.y-eo.y)^2+(ey.z-eo.z)^2 end)end;local ez=ep:normalize()for dK,en in ipairs(eu)do local eA=en.center-eo;local dQ=self:sizeCalculator(en)local eB=eA:dot(ez)local eC=eB^2-(eA:len2()-dQ^2)if eC>=0 then local eD=dh(eC)local eE=eB+eD;local eF=eB-eD;if eF>0 then return en,eE,eF elseif eE>0 then return en,eE,nil end end end;return nil,nil,nil end;function e0:closestBody(eG)assert(type(eG)=='table','Invalid coordinates.')local eH,en;local eI=vec3(eG)for dK,eJ in pairs(self)do local eK=(eJ.center-eI):len2()if(not en or eK<eH)and eJ.name~="Space"then en=eJ;eH=eK end end;return en end;function e0:convertToBodyIdAndWorldCoordinates(dW)local eL=dW;if dp(dW)then eL=dV(dW)end;if eL.id==0 then return 0,vec3(eL.latitude,eL.longitude,eL.altitude)end;local eJ=self:getBodyParameters(eL)if eJ then return eL.id,eJ:convertToWorldCoordinates(eL)end end;function e0:getBodyParameters(dW)local dP=dW;if ds(dW)then dP=dW.id end;assert(dl(dP),'Argument 1 (id) must be a number:'..type(dP))return self[dP]end;function e0:getPlanetarySystemId()local dK,dr=next(self)return dr and dr.systemId end;function dH:convertToMapPosition(dR)assert(dm(dR),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dR))local eM=vec3(dR)if self.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=self.systemId},dT)end;local eN=eM-self.center;local c4=eN:len()local dZ=c4-self.radius;local dX=0;local dY=0;if not di(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=self.id,systemId=self.systemId},dT)end;function dH:convertToWorldCoordinates(dW)local eL=dp(dW)and dV(dW)or dW;if eL.id==0 then return vec3(eL.latitude,eL.longitude,eL.altitude)end;assert(ds(eL),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eL.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eL.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eQ=math.cos(eL.latitude)return self.center+(self.radius+eL.altitude)*vec3(eQ*math.cos(eL.longitude),eQ*math.sin(eL.longitude),math.sin(eL.latitude))end;function dH:getAltitude(dR)return(vec3(dR)-self.center):len()-self.radius end;function dH:getDistance(dR)return(vec3(dR)-self.center):len()end;function dH:getGravity(dR)local eR=self.center-vec3(dR)local eS=eR:len2()return self.GM/eS*eR/dh(eS)end;return setmetatable(e9,{__call=function(dK,...)return ea(...)end})end;local function eT(d,b,c,a,dh,eU)local ck={}local eV=100000000/3600;local eW=eV*eV;local eX=100;function ck.computeAccelerationTime(eY,eZ,e_)local f0=eV*math.asin(eY/eV)return(eV*math.asin(e_/eV)-f0)/eZ end;function ck.computeDistanceAndTime(eY,e_,f1,f2,f3,f4)f3=f3 or 0;f4=f4 or 0;local f5=eY<=e_;local f6=f2*(f5 and 1 or-1)/f1;local f7=-f4/f1;local f8=f6+f7;if f5 and f8<=0 or not f5 and f8>=0 then return-1,-1 end;local f9,fa=0,0;if f6~=0 and f3>0 then local f0=math.asin(eY/eV)local fb=math.pi*(f6/2+f7)local fc=f6*f3;local fd=eV*math.pi;local dr=function(dn)local fe=(fb*dn-fc*math.sin(math.pi*dn/2/f3)+fd*f0)/fd;local ff=math.tan(fe)return eV*ff/dh(ff*ff+1)end;local fg=f5 and function(a)return a>=e_ end or function(a)return a<=e_ end;fa=2*f3;if fg(dr(fa))then local fh=0;while eU(fa-fh)>0.5 do local dn=(fa+fh)/2;if fg(dr(dn))then fa=dn else fh=dn end end end;local fi=eY;local fj=fa/eX;for fk=1,eX do local fl=dr(fk*fj)f9=f9+(fl+fi)*fj/2;fi=fl end;if fa<2*f3 then return f9,fa end;eY=fi end;local f0=eV*math.asin(eY/eV)local bK=(eV*math.asin(e_/eV)-f0)/f8;local fm=eW*math.cos(f0/eV)/f8;local c4=fm-eW*math.cos((f8*bK+f0)/eV)/f8;return c4+f9,bK+fa end;function ck.computeTravelTime(eY,eZ,c4)if c4==0 then return 0 end;if eZ>0 then local f0=eV*math.asin(eY/eV)local fm=eW*math.cos(f0/eV)/eZ;return(eV*math.acos(eZ*(fm-c4)/eW)-f0)/eZ end;if eY==0 then return-1 end;assert(eY>0,'Acceleration and initial speed are both zero.')return c4/eY end;return ck end;local function fn(d,b,c,a,de,df,dg,dh,di)local vec3=vec3;local dd=dd(d,b,c,a,de,df,dg,dh,di)local function dp(a)return type(a)=='string'end;local function dm(dn)return type(dn)=='table'end;fo={}fo.__index=fo;function fo:escapeAndOrbitalSpeed(dZ)assert(self.body)local c4=dZ+self.body.radius;if not di(c4,0)then local fp=dh(self.body.GM/c4)return dh(2)*fp,fp end;return nil,nil end;function fo:orbitalParameters(dW,fq)assert(self.body)assert(dm(dW)or dp(dW))assert(dm(fq))local fr=(dp(dW)or dd.isMapPosition(dW))and self.body:convertToWorldCoordinates(dW)or vec3(dW)local dr=vec3(fq)local fs=fr-self.body.center;local ft=dr:len2()local fu=fs:len()local fv=self.body.GM;local fw=((ft-fv/fu)*fs-fs:dot(dr)*dr)/fv;local ex=fv/(2*fv/fu-ft)local fx=fw:len()local ez=fw:normalize()local fy=ex*(1-fx)local fz=ex*(1+fx)local fA=fy*ez+self.body.center;local fB=fx<=1 and-fz*ez+self.body.center or nil;local fC=dh(ex*fv*(1-fx*fx))local fD=fB and 2*math.pi*dh(ex^3/fv)local fE=math.acos(fw:dot(fs)/(fx*fu))if fs:dot(dr)<0 then fE=-(fE-2*math.pi)end;local fF=math.acos((math.cos(fE)+fx)/(1+fx*math.cos(fE)))local fG=fF;if fG<0 then fG=fG+2*math.pi end;local fH=fG-fx*math.sin(fG)local fI=0;local fJ=0;local fK=0;if fD~=nil then fI=fH/(2*math.pi/fD)fJ=fD-fI;fK=fJ+fD/2;if fE-math.pi>0 then fJ=fI;fK=fJ+fD/2 end;if fK>fD then fK=fK-fD end end;return{periapsis={position=fA,speed=fC/fy,circularOrbitSpeed=dh(fv/fy),altitude=fy-self.body.radius},apoapsis=fB and{position=fB,speed=fC/fz,circularOrbitSpeed=dh(fv/fz),altitude=fz-self.body.radius},currentVelocity=dr,currentPosition=fr,eccentricity=fx,period=fD,eccentricAnomaly=fF,meanAnomaly=fH,timeToPeriapsis=fJ,timeToApoapsis=fK,trueAnomaly=fE}end;local function fL(fM)local eJ=dd.BodyParameters(fM.systemId,fM.id,fM.radius,fM.center,fM.GM)return setmetatable({body=eJ},fo)end;return setmetatable(fo,{__call=function(dK,...)return fL(...)end})end;local function fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dg,dh,fQ,fR)local function fS(fT)local dU=fU:closestBody(fT)if(fT-dU.center):len()>dU.radius+dU.noAtmosphericDensityAltitude then dU=e[0][0]end;return dU end;local function fV()local function fW(fX,fY)return fX.name<fY.name end;cP={}for dF,dr in pairs(e[0])do cP[#cP+1]={name=dr.name,index=dF}end;table.sort(cP,fW)end;local function fZ(f_,g0)if not g0 then g0=g1.name end;for dF,dr in pairs(f_)do if dr.name and dr.name==g0 then return dF end end;return-1 end;local function g2()cX=bj;if bj==0 then bh="None"c1=nil;g1=nil;return true end;local g3=cP[bj].index;local g4=e[0][g3]if g4.center then bh=g4.name;c1=cj[0][g3]if g1~=nil then if ca==0 then if fO(g5,g6)~=1 then fP(g5,g6)end;if fO(g7,g8)~=1 then fP(g7,g8)end;if fO(g9,ga)~=1 then fP(g9,ga)end;if fO(gb,gc)~=1 then fP(gb,gc)end;if fO(gd,ge)~=1 then fP(gd,ge)end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end;if fO(gj,gk)~=1 then fP(gj,gk)end end;g1=nil else g1=g4;for dK,dr in pairs(cj[0])do if dr.name==g1.planetname then c1=dr;bh=g1.name;break end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end end;if g1==nil then bi=vec3(c1.center)else bi=g1.position end;if c1.planetname~="Space"then if c1.hasAtmosphere then gl=bI(c1.radius*(S-1)+c1.noAtmosphericDensityAltitude)else gl=bI(c1.radius*(S-1)+c1.surfaceMaxAltitude)end else gl=R end;if g1~=nil and g1.planetname=="Space"then bd=0 else dK,bd=cl(c1):escapeAndOrbitalSpeed(gl)end;bf=0;b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"return true end;local function gm(gn)if not b1 and not bo and not c6 and not bx and not b6 and not c7 then if gn==nil then bj=bj+1;if bj>#cP then bj=0 end else bj=bj-1;if bj<0 then bj=#cP end end;if bj==0 then g2()else local g3=cP[bj].index;local g4=e[0][g3]if g4 and(g4~=nil and g4.name=="Space"or by=="Custom Only"and g4.center or by=="No Moons"and string.find(g4.name,"Moon")~=nil)then if gn==nil then gm()else gm(1)end else g2()end end else bX="Disengage autopilot before changing Interplanetary Helper"fQ("iph","AP")end end;local function go()local function gp(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=-1;gs=fZ(e[0])if gs>-1 then table.remove(e[0],gs)end;gs=-1;gs=fZ(gr)if gs~=-1 then bX=g1.name.." saved location cleared"table.remove(gr,gs)end;gm()fV()return gr end;if string.sub(bh,1,1)=="*"then d4=gp(true)else bn=gp(false)end end;local function gt(gu,fT,gv,gw)local function gx(gq)if gq then gr=d4 else gr=bn end;if dbHud_1 or gv or gq then local dU=fS(fT)local gy={position=fT,name=gu,planetname=dU.name,gravity=b.g(),safe=gw}if not gv then gr[#gr+1]=gy else for dF,dr in pairs(e[0])do if dr.name and gu==dr.name then table.remove(e[0],dF)end end end;table.insert(e[0],gy)fV()g2()bX="Location saved as "..gu.."("..dU.name..")"return gr else bX="Databank must be installed to save permanent locations"end end;if string.sub(gu,1,1)=="*"then d4=gx(true)else bn=gx(false)end end;local gz={}function gz.UpdateAtlasLocationsList()fV()end;function gz.UpdateAutopilotTarget()g2()end;function gz.adjustAutopilotTargetIndex(gn)gm(gn)end;function gz.findAtlasIndex(f_,g0)return fZ(f_,g0)end;function gz.UpdatePosition(gA,gB,gC)local function gD(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=fZ(gr)if gs~=-1 then if gA~=nil then if gq then gA="*"..gA end;gr[gs].name=gA;bj=bj-1;gm()elseif gC~=nil then if gC then local gE=cb;if gE<1000 then gE=1000 end;gr[gs].agg=fR(gE,0)bX=gr[gs].name.." AGG Altitude:"..gr[gs].agg.." saved ("..gr[gs].planetname..")"return elseif gC==false then gr[gs].agg=nil;bX=gr[gs].name.." AGG Altitude cleared ("..gr[gs].planetname..")"return end else local gF=gr[gs]if gB then gF.heading=cD:cross(cH)*5000;bX=gr[gs].name.." heading saved ("..gr[gs].planetname..")"return elseif gB==false then gF.heading=nil;bX=gr[gs].name.." heading cleared ("..gr[gs].planetname..")"return end;gF.gravity=b.g()gF.position=cJ;gF.safe=true end;bX=gr[gs].name.." position updated ("..gr[gs].planetname..")"else bX="Name Not Found"end end;if string.sub(bh,1,1)=="*"then gD(true)else gD(false)end end;function gz.AddNewLocation(gu,fT,gv,gw)gt(gu,fT,gv,gw)end;function gz.ClearCurrentPosition()go()end;for dF,dr in pairs(d5)do table.insert(e[0],dr)end;if gG then for dF,dr in pairs(gG)do gz[dF]=dr end end;fV()if bj>#cP then bj=0 end;gz.UpdateAutopilotTarget()return gz end;local function gH(b,a,c,library,radar_1,radar_2,eU,gI,dh,gJ,dg,gK,fQ)local gL={}local gM={}local gN={XS=13,S=27,M=55,L=110,XL=221}local gO={}local gP=0;local gQ;local gR;local gS;local gT;local gU={}local gV="Atmo"local gW;local gX;local gY=0;local gZ={}local function g_()local function h0(h1,h2,h3,h4,h5,h6,h7,h8)h2,h4,h6,h8=vec3(h2),vec3(h4),vec3(h6),vec3(h8)local h9,ha,hb=h1*h1,h3*h3,h5*h5;local ft=h4-h2;local hc=ft:normalize()local hd=ft:len()local he=h6-h2;local hf=(he-he:project_on(hc)):normalize()local hg,hh=he:dot(hc),he:dot(hf)local hi=hg*hg+hh*hh;local hj=hc:cross(hf)local hk=(h9-ha+hd*hd)/(2*hd)local hl=(h9-hb+hi-2*hg*hk)/(2*hh)local dt=h9-hk^2-hl^2;local hm=dh(dt)local hn=h2+hc*hk+hf*hl+hj*hm;local ho=h2+hc*hk+hf*hl-hj*hm;if eU((h8-hn):len()-h7)<eU((h8-ho):len()-h7)then return hn else return ho end end;local function hp(hq,fu,hr)local hs=hq.pts;local gs=#hs;local ht=hq.ref;if gs>3 then local hu,hv,hw,hx=hs[gs],hs[gs-1],hs[gs-2],hs[gs-3]hq.ref=hr;local fr=h0(hu[1],hu[2],hv[1],hv[2],hw[1],hw[2],hx[1],hx[2])local hk,hl,hm=fr.x,fr.y,fr.z;if hk==hk and hl==hl and hm==hm then hk=hk+ht[1]hl=hl+ht[2]hm=hm+ht[3]local hy=vec3(hk,hl,hm)hq.center=hy;if hq.lastPos then if(hq.lastPos-hy):len()<2 then local hz=(hy-vec3(hr)):len()if eU(hz-fu)<10 then hq.skipCalc=true end end end;hq.lastPos=hy end;hq.pts={}else local hA={hr[1]-ht[1],hr[2]-ht[2],hr[3]-ht[3]}hs[gs+1]={fu,hA}end end;if radar_1 or radar_2 then cp.assignRadar()end;if gU[1]then gP=#gU[1].getConstructIds()local hB=gU[1].getData()local hC=hB:gmatch('{"constructId[^}]*}[^}]*}')if gP>0 then local hr={cJ["x"],cJ["y"],cJ["z"]}local hD,hE=0,0;local hF=cG*10;gT,gS=0,0;for dr in hC do local dP,c4,hG=dr:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hH=gN[hG]c4=dg(c4)if gU[1].hasMatchingTransponder(dP)==1 then table.insert(gM,dP)end;if E then local hI=gU[1].getConstructType(dP)if F and gU[1].isConstructAbandoned(dP)==1 or c4<hF and(hH>27 or hI=="static"or hI=="space")then gT=gT+1;local gu=gU[1].getConstructName(dP)local hq=gZ[dP]if hq==nil then hH=hH+gK;gZ[dP]={pts={},ref=hr,name=gu,i=0,radius=hH,skipCalc=false}hq=gZ[dP]end;if not hq.skipCalc then hp(hq,c4,hr)if F and not hq.abandoned and gU[1].isConstructAbandoned(dP)==1 and hq.center then fQ("abRdr","RD")a.print("Abandoned Construct: "..gu.." ("..hI..") rough ::pos{0,0,"..hq.center.x..","..hq.center.y..","..hq.center.z.."}")bX="Abandoned Radar Contact ("..hI..") detected"hq.abandoned=true end;hE=hE+1 else table.insert(gO,hq)end end;hD=hD+1;if cT and hD>700 or hE>70 or(not cT and hD>300 or hE>30)then coroutine.yield()hD,hE=0,0 end end end;gS=#gO;if gS>0 and(cG>20 or b4)then local en,hJ,hK,hL;local hM=0;local hN=cj:getPlanetarySystem(0)hL=cF:normalize()while hM<gS do coroutine.yield()local hO={table.unpack(gO,hM,math.min(hM+75,gS))}en,hJ,hK=hN:castIntersections(cJ,hL,nil,nil,hO,true)if en and hK then cV={en,hJ,hK}break end;hM=hM+75 end;if not en then cV=nil end else cV=nil end;gO={}gQ=hB:find('identifiedConstructs":%[%]')else gR=hB:find('worksInEnvironment":false')end end end;local function hP()if gU[1]then gV="Atmo"if gU[1].getData():find('worksInAtmosphere":false')then gV="Space"end end end;function gL.pickType()hP()end;function gL.assignRadar()if radar_1 and gU[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gU[1]=radar_2 end;if gU[1]==radar_2 then hP()end elseif radar_2 and gU[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gU[1]=radar_1 end;if gU[1]==radar_1 then hP()end end end;function gL.UpdateRadar()local hQ=coroutine.status(gW)if hQ=="suspended"then local dG,hR=coroutine.resume(gW)if hR then a.print("ERROR UPDATE RADAR: "..hR)end elseif hQ=="dead"then gW=coroutine.create(g_)local dG,hR=coroutine.resume(gW)end end;function gL.GetRadarHud(hS,hT,au,av)local hU=gM;local hV,hW;gM={}local dx=gS or 0;if gP>0 then if E then hW=dx.."/"..gT.." Plotted : "..gP-gT.." Ignored"else hW="Radar Contacts: "..gP end;hV=gJ(au,av,hW,"pbright txtbig txtmid")if#gM>0 then hV=hV..gJ(hS,hT,"Friendlies In Range","pbright txtbig txtmid")for dF,dr in pairs(gM)do hT=hT+20;hV=hV..gJ(hS,hT,gU[1].getConstructName(dr),"pdim txtmid")end end;if gQ==nil and gX==nil then gY=1;cp.ToggleRadarPanel()end;if gQ~=nil and gX~=nil then cp.ToggleRadarPanel()end;if d3==nil then cp.ToggleRadarPanel()end else if gR then hV=gJ(au,av,gV.." Radar: Jammed","pbright txtbig txtmid")else hV=gJ(au,av,"Radar: No "..gV.." Contacts","pbright txtbig txtmid")end;if d3~=nil then gY=0;cp.ToggleRadarPanel()end end;return hV end;function gL.GetClosestName(gu)if gU[1]then local dP,dK=gU[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dP~=nil and dP~=""then gu=gu.." "..gU[1].getConstructName(dP)end end;return gu end;function gL.ToggleRadarPanel()if d3~=nil and gY==0 then gI(d3)d3=nil;if gX~=nil then gI(gX)gX=nil end else if gY==1 then gI(d3)d3=nil;_autoconf.displayCategoryPanel(gU,1,"Periscope","periscope")gX=_autoconf.panels[_autoconf.panels_size]end;if d3==nil then _autoconf.displayCategoryPanel(gU,1,"Radar","radar")d3=_autoconf.panels[_autoconf.panels_size]end;gY=0 end end;function gL.ContactTick()if not hX then hX=0 end;if bK>hX+10 then bX="Radar Contact"fQ("rdrCon","RC")hX=bK end;c.stopTimer("contact")end;function gL.onEnter(dP)if radar_1 and not c9 and not cQ then c.setTimer("contact",0.1)end end;function gL.onLeave(dP)if radar_1 and E then if#gZ>650 then dP=tostring(dP)gZ[dP]=nil end end end;gU[1]=nil;if radar_1 then gU[1]=radar_1;hP()end;gW=coroutine.create(g_)if hY then for dF,dr in pairs(hY)do gL[dF]=dr end end;return gL end;local function hZ(db,d_,bI)local h_={}local i0=db.getResistancesCooldown()local function i1()local i2=db.getState()if G then if not cQ and i2==0 then db.toggle()elseif cQ and i2==1 then db.toggle()end end end;local function i3()local i4=db.getStressRatioRaw()local i5=0.5999;if i4[1]==0.0 and i4[2]==0.0 and i4[3]==0.0 and i4[4]==0.0 then return end;local i6=db.setResistances(i5*i4[1],i5*i4[2],i5*i4[3],i5*i4[4])if i6==1 then bX="Shield Resistances updated"else bX="Value Exceeded. Failed to update Shield Resistances"end end;function h_.shieldTick()dc=bI(0.5+db.getShieldHitpoints()*100/db.getMaxShieldHitpoints())i1()i0=db.getResistancesCooldown()if i0==0 and dc<a7 then i3()end end;function h_.setResist(i7)if not db then bX="No shield found"return elseif i7==nil or i0>0 then bX="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy=dx..', '..dx..', '..dx..', '..dx;local i8,i9,ia,ib=d_(i7,dy)if ib==nil or i8+i9+ia+ib>0.6 then bX="Improperly formatted or total exceeds 0.6"return end;if db.setResistances(i8,i9,ia,ib)==1 then bX="Shield Resistances set"else bX="Resistance setting failed."end end;function h_.ventShield()local ic=db.getVentingCooldown()if ic>0 then bX="Cannot vent again for "..ic.." seconds"return end;if db.getShieldHitpoints()<db.getMaxShieldHitpoints()then db.startVenting()bX="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bX="Shields already at max hitpoints"end end;if id then for dF,dr in pairs(id)do h_[dF]=dr end end;return h_ end;local function ie(d,b,c,a,e,radar_1,radar_2,antigrav,hover,db,warpdrive,ig,eU,bI,de,ih,bJ,ii,ij,eP,bH,df,ik,fP,fO,gI,il,dh,fR,gJ,fQ,im,io,ip,iq,ir,is)local it=9.80665;local iu={}local iv={}local iw={}local ix={}local iy=nil;local iz=nil;local iA=nil;local iB=false;local iC="none"local iD=""local iE=55;local iF=0;local iG=0;local iH=""local iI=nil;local iJ=ac;local iK=ad;local iL=ae;local iM=[[rgb(]]..bI(iJ+0.5)..","..bI(iK+0.5)..","..bI(iL+0.5)..[[)]]local iN=[[rgb(]]..bI(iJ*0.9+0.5)..","..bI(iK*0.9+0.5)..","..bI(iL*0.9+0.5)..[[)]]local iO=0;local iP=0;local iQ=""local iR=bH()local iS=false;local iT=false;local function iU(dr)if ce==1920 then return dr else return fR(ce*dr/1920,0)end end;local function iV(dr)if cf==1080 then return dr else return fR(cf*dr/1080,0)end end;local function iW()return il()==0 and g~="keyboard"and ij()==0 end;local function iX()local iY="TRAVEL"if not cM then iY="CRUISE"end;if b1 then iY="AUTOPILOT"end;return iY end;local hV=""local iZ=""local i_=""local j0=1;local j1=2;local j2=3;local j3=4;local j4=5;local j5=6;local j6=7;local j7=""local j8=0;local j9=120.0*aR;local ja={}local jb={}local jc={}local jd={}local je={}local jf={}local jg={}jg["atmofueltank"],jg["spacefueltank"],jg["rocketfueltank"]=0,0,0;local jh=0;local function ji(hk,jj,jk,jl,jm,jn)local jo=jh;local jp=jh+5;if not B then jp=jp+5 end;if ij()==1 and not l then jo=jo-50;jp=jp-50 end;if jk=="ATMO"then j7="atmofueltank"elseif jk=="SPACE"then j7="spacefueltank"else j7="rocketfueltank"end;j8=_G[j7 .."_size"]if#jl>0 then for K=1,#jl do local gu=jl[K][j1]local jq=jl[K][j6]for jr=1,j8 do if jl[K][j1]==ih(c[j7 .."_"..jr].getData()).name then jq=jr;break end end;local js=bH()if jm[K]==nil or jn[K]==nil or js-jl[K][j5]>j9 then local jt;local ju=0;ju=ii(jl[K][j0])-jl[K][j3]jt=jl[K][j4]if jt>ju then jg[j7]=jg[j7]+jt-ju end;if jq~=0 then local jv=ih(c[j7 .."_"..jq].getData())jn[K]=jv.percentage;jm[K]=jv.timeLeft;if jm[K]=="n/a"then jm[K]=0 end else jn[K]=bI(0.5+ju*100/jl[K][j2])if jt<=ju then jm[K]=0 else jm[K]=bI(0.5+ju/((jt-ju)/(js-jl[K][j5])))end end;jl[K][j5]=js;jl[K][j4]=ju end;if gu==jj then gu=de("%s %d",jk,K)end;if jq==0 then gu=gu.." *"end;local jw;if jm[K]==0 then jw=""else jw=iq(jm[K])end;if jn[K]~=nil then local jx=bI(jn[K]*2.55)local jy=de("rgb(%d,%d,%d)",255-jx,jx,0)local jz=""if jw~=""and jm[K]<120 or jn[K]<5 then jz="red "end;local jA=de("rgb(%d,%d,%d)",df(bI((255-jx)/2.55),50,100),df(bI(jx/2.55),0,50),50)local jB="rgb(196,0,255)"if jk=="ATMO"then jB="rgb(0,188,255)"elseif jk=="SPACE"then jB="rgb(239,255,0)"end;local jC=false;if jD~=jB then jC=true end;jD=jB;if B then if jC then jo=jo-5;jp=jp-5 end;iZ=iZ..de([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jA,jB,hk,jp,jy,bI(jn[K]*1.7+0.5)-2,hk+1,jp+1,hk+5,jp+14,gu,jn[K],jw)jo=jo-22;jp=jp-22 else iZ=iZ..gJ(hk,jo,gu,jz.."pdim txtfuel")iZ=iZ..gJ(hk,jp,de("%d%% %s",jn[K],jw),"pdim txtfuel","fill:"..jy)jo=jo+30;jp=jp+30 end end end end;jh=jo end;local function jE(jF,dZ)if am==0 and an==0 then return end;if dZ<200000 and not c9 or dZ and c9 then local jG=0;if eU(cI)>1 then jG=45*math.log(eU(cI),10)if cI<0 then jG=-jG end end;jF[#jF+1]=de([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bI(cI),bI(jG))end;return jF end;local function jH(jI)local gn=-cH;jI=jI-jI:project_on(gn)local jJ=vec3(0,0,1)jJ=jJ-jJ:project_on(gn)local jK=jJ:cross(gn)local jG=jJ:angle_between(jI)*constants.rad2deg;if jI:dot(jK)<0 then jG=360-jG end;return jG end;local function jL(jF,ai,aj,jM,jN,cT)if ab==0 then return end;local jO=ab;local jP=20;local jQ=bI(jM)if cT then for K=-45,45,5 do local jR=K;jF[#jF+1]=de([[<g transform="rotate(%f,%d,%d)">]],jR,ai,aj)jS=5;if K%15==0 then jS=15 elseif K%10==0 then jS=10 end;jF[#jF+1]=de([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jO+jP-jS,ai,aj+jO+jP)end;jF[#jF+1]=gJ(ai,aj+jO+jP-35,jN,"pdim txt txtmid")jF[#jF+1]=gJ(ai,aj+jO+jP-25,jQ.." deg","pdim txt txtmid")jF[#jF+1]=de([[<g transform="rotate(%f,%d,%d)">]],-jM,ai,aj)jF[#jF+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jO+jP-20,ai+5,aj+jO+jP-20,ai,aj+jO+jP-15)jF[#jF+1]="</g>"end;jF[#jF+1]=[[<g style="clip-path: url(#headingClip);">]]local jT=jQ;if cT then jT=jH(cC)end;local jU=20;local jV=bI(jT)local jW=0;local jX=aj+jO+jP+20;local jY=ai;if jN~="YAW"then jX=iV(130)jY=iU(960)end;local jZ=[[<path class="txttick line" d="]]local j_=bI(jV-(jU+10)-jV%5+0.5)for K=j_+70,j_,-5 do local hk=jY-(-K*5+jT*5)if K%10==0 then jW=10;local dx=K;if dx==360 then dx=0 elseif dx>360 then dx=dx-360 elseif dx<0 then dx=dx+360 end;jF[#jF+1]=gJ(hk,jX+15,dx,"txtmid bright")elseif K%5==0 then jW=5 end;if jW==10 then jZ=de([[%s M %f %f v %d]],jZ,hk,jX-5,jW)else jZ=de([[%s M %f %f v %d]],jZ,hk,jX-2.5,jW)end end;jF[#jF+1]=jZ..[["/>]]jF[#jF+1]=de([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jY-5,jX-20,jY+5,jX-20,jY,jX-10)if I then if cT then jN="HDG"end;jF[#jF+1]=gJ(iU(960),iV(100),jV.."°","dim txt txtmid size14","")jF[#jF+1]=gJ(iU(960),iV(85),jN,"dim txt txtmid size20","")end;jF[#jF+1]=[[</g>]]end;local function k0(jF,k1,jM,ai,aj,cT,k2,fl)if ab==0 then return end;local jO=ab;local k3=bI(jO*3/5)if jO>0 then local k4=bI(k1)local jS=0;local jZ=de([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jM,ai,aj)if not c9 then jZ=de([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jF[#jF+1]=de([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jO-1,ai,aj)jF[#jF+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bI(k4-30-k4%5+0.5),bI(k4+30+k4%5+0.5),5 do if K%10==0 then jS=30 elseif K%5==0 then jS=20 end;local hl=aj+-K*5+k1*5;if jS==30 then jZ=de([[%s M %d %f h %d]],jZ,ai-k3-jS,hl,jS)if c9 then jF[#jF+1]=de([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jM,ai,aj,ai-k3+10,hl+4,K)jF[#jF+1]=de([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jM,ai,aj,ai+k3-10,hl+4,K)if K==0 or K==180 or K==-180 then jF[#jF+1]=de([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jM,ai,aj,ai-k3+20,hl,k3*2-40)end else jF[#jF+1]=gJ(ai-k3+10,hl,K,"pdim txt txtmid")jF[#jF+1]=gJ(ai+k3-10,hl,K,"pdim txt txtmid")end;jZ=de([[%s M %d %f h %d]],jZ,ai+k3,hl,jS)else jZ=de([[%s M %d %f h %d]],jZ,ai-k3-jS,hl,jS)jZ=de([[%s M %d %f h %d]],jZ,ai+k3,hl,jS)end end;jF[#jF+1]=jZ..[["/>]]local k5="PITCH"if not cT then k5="REL PITCH"end;if k1>90 and not c9 then k1=90-(k1-90)elseif k1<-90 and not c9 then k1=-90-(k1+90)end;if jO>200 then if c9 then if fl>iE then jF[#jF+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jF[#jF+1]=gJ(ai,aj+20,k2,"pdim txt txtmid")end;jF[#jF+1]=de([[<g transform="rotate(%f,%d,%d)">]],-jM,ai,aj)else jF[#jF+1]=de([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jF[#jF+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k3+25,aj-5,ai-k3+20,aj,ai-k3+25,aj+5,ai-k3+50,aj+4,k4)jF[#jF+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k3-25,aj-5,ai+k3-20,aj,ai+k3-25,aj+5,ai+k3-30,aj+4,k4)jF[#jF+1]="</g>"end;local k6=bI(jO/3)jF[#jF+1]=de([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-k6,aj,jO-k6)if not c9 and cT then jF[#jF+1]=de([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jM,ai,aj,ai-k3+10,aj,k3*2-20)end;jF[#jF+1]="</g>"if jO<200 then if c9 and fl>iE then jF[#jF+1]=gJ(ai,aj-jO,k5,"pdim txt txtmid")jF[#jF+1]=gJ(ai,aj-jO+10,k4,"pdim txt txtmid")jF[#jF+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jF[#jF+1]=gJ(ai,aj+20,k2,"pdim txt txtmid")else jF[#jF+1]=gJ(ai,aj-jO,k5,"pdim txt txtmid")jF[#jF+1]=gJ(ai,aj-jO+15,k4,"pdim txt txtmid")end end end end;local function k7(jF,dZ,cT)local k8=ao;local k9=ap;if k8==0 and k9==0 then return end;local ka=78;local kb=19;local kc=c8;if c8~=-1 then jF[#jF+1]=gJ(k8+ka,k9+kb+20,de("AGL: %.1fm",c8),"pdim altsm txtend")end;if cT and(dZ<200000 and not c9 or dZ and c9)then table.insert(jF,de([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],k8-1,k9-4,ka+2,kb+6,k8+1,k9-1,ka-4,kb))local gs=0;local kd=1;local ke=0;local kf=dZ<0;local kg=dZ<kh.surfaceMaxAltitude;local ki=9;if kf then ki=0 end;local dZ=eU(dZ)while gs<6 do local kj=11;local kk=16;local kl=9;local km=14;local jz="altsm"if gs>2 then kk=kk+3;kj=kj+2;km=km+2;kl=kl-6;jz="altbig"end;if kf then jz=jz.." red"elseif kg then jz=jz.." orange"end;local kn=dZ/kd%10;local ko=bI(kn)local kp=bI((ko+1)%10)local kq=ke;if gs==0 then kq=kn-ko;if kf then kq=1-kq end end;if kf and(gs==0 or ke~=0)then local gv=kp;kp=ko;ko=gv end;local kr=kk*(kq-1)local ks=kr+kk;local hk=k8+kl+(6-gs)*kj;local hl=k9+km;jF[#jF+1]=gJ(hk,hl+kr,kp,jz)jF[#jF+1]=gJ(hk,hl+ks,ko,jz)gs=gs+1;kd=kd*10;if ko==ki then ke=kq else ke=0 end end;table.insert(jF,[[</g></g>]])end end;local function kt(fq)local ku=-math.deg(eP(fq.y,fq.z))+180;ku=ku-90;if ku<0 then ku=360+ku end;if ku>180 then ku=-180+ku-180 end;return-ku end;local function kv(fq)local jT=math.deg(eP(fq.y,fq.x))-90;if jT<-180 then jT=360+jT end;return jT end;local function kw(jF,fq,fl,ai,aj)if fl>5 and not c9 or fl>iE then local jO=ab;local kx=20;local ky=20;local kz=kt(fq)local kA=kv(fq)local kB=14;local kC=kB/2;local kD=-kA/ky*jO;local kE=kz/kx*jO;local hk=ai+kD;local hl=aj+kE;local c4=dh(kD^2+kE^2)local kF=[[<circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kC/kB..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kC..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hk-kB..[[,]]..hl..[[ h ]]..kC..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk+kC..[[,]]..hl..[[ h ]]..kC..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk..[[,]]..hl-kB..[[ v ]]..kC..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c4<jO then jF[#jF+1]=kF else local jG=eP(kE,kD)local kG=4;local kH=ai+jO*math.cos(jG)local kI=aj+jO*math.sin(jG)jF[#jF+1]=de('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jG*180/math.pi,kH,kI,kH-kG,kI-kG/2,kG*2,kG,kH+kG,kI-kG,kG,kG,-kG,kG)end;if not c9 then local kJ=vec3(fq)kz=kt(-kJ)kA=kv(-kJ)kD=-kA/ky*jO;kE=kz/kx*jO;hk=ai+kD;hl=aj+kE;c4=dh(kD^2+kE^2)if c4<jO then local kK=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kC..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kB..[[ v ]]..kC..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hk..[[,]]..hl..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hk..[[,]]..hl..[[)" />
                                <path
                                    d="M ]]..hk-kC..[[,]]..hl..[[ h ]]..kB..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hk..[[,]]..hl..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hk..[[,]]..hl..[[)"/>]]jF[#jF+1]=kK end end end end;local function kL(jF,iY,kM,kN)if ak==0 and al==0 then return end;kM=bI(kM+0.5)local jo=al+10;local jp=al+20;if ij()==1 and not l then jo=55;jp=65 end;local kO="CRUISE"local c="km/h"local dG=kN;if iY=="TRAVEL"or iY=="AUTOPILOT"then kO="THROT"c="%"dG=kM;local kP="dim"if kM<0 then kP="red"end;jF[#jF+1]=de([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kP,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eU(kM),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jF[#jF+1]=gJ(ak+10,jo,kO,"pbright txtstart")jF[#jF+1]=gJ(ak+10,jp,de("%.0f %s",dG,c),"pbright txtstart")if c9 and t and cM and bN then kM=bI(bO*100+0.5)local kP="red"if kM<0 then kP="red"end;jF[#jF+1]=de([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kP,1-eU(kM),ak-10,al+50,ak-15,al+53,ak-15,al+47)jF[#jF+1]=gJ(ak+10,jo+40,"LIMIT","pbright txtstart")jF[#jF+1]=gJ(ak+10,jp+40,kM.."%","pbright txtstart")end;if c9 and t or b6 then jF[#jF+1]=gJ(ak+10,jo-40,"LIMIT: "..cw.." km/h","dim txtstart")elseif not c9 and b1 then jF[#jF+1]=gJ(ak+10,jo-40,"LIMIT: "..bI(_*3.6+0.5).." km/h","dim txtstart")end end;local function kQ(jF,kR)if ak==0 and al==0 then return end;local kS=al-10;local kT=ak+10;jF[#jF+1]=gJ(0,0,"","pdim txt txtend")if ij()==1 and not l then kS=75 end;jF[#jF+1]=gJ(kT,kS,bI(kR).." km/h","pbright txtbig txtstart")end;local function kU(jF)jF[#jF+1]=gJ(iU(150),iV(1070),de("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jF[#jF+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jF[#jF+1]=gJ(iU(960),iV(550),"Warning: Invalid Control Scheme Detected","warnings")jF[#jF+1]=gJ(iU(960),iV(600),"Keyboard Scheme must be selected","warnings")jF[#jF+1]=gJ(iU(960),iV(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kV=iU(960)local kW=iV(860)local kX=iV(880)local kY=iV(900)local kZ=iV(960)local k_=iV(200)local l0=iV(250)local l1=iV(960)if ij()==1 and not l then kW=iV(135)kX=iV(155)kY=iV(175)k_=iV(115)l0=iV(95)end;local l2="#222222"local l3="white"local l4="dimmer"local l5="pbright"local l6="#110000"local l7=l2;local l8=l4;if aZ then local l9=""if type(aZ)=="string"then l9="-"..aZ end;jF[#jF+1]=gJ(kV,kW,"Brake Engaged"..l9,"warnings")l6="#440000"l7=l3;l8=l5 elseif bM>0 then jF[#jF+1]=gJ(kV,kW,"Auto-Brake Engaged","warnings","opacity:"..bM)end;local la="#110000"local lb=l2;local lc=l4;if c9 and cv and c8==-1 then if not b1 and not bo and not b4 and not cL and not b7 and not b5 then jF[#jF+1]=gJ(kV,k_+50,"** STALL WARNING **","warnings")la="#ff0000"lb=l3;lc=l5;fQ("stall","SW",2)end end;if cS then jF[#jF+1]=gJ(kV,k_+90,"Flight Assist in Progress","warnings")end;if cd then jF[#jF+1]=gJ(kV,l1,"Gyro Enabled","warnings")end;local ld="#111100"local le=l2;local lf=l4;if bk then ld="#775500"le=l3;lf=l5;if bQ then jF[#jF+1]=gJ(kV,kX,"Gear Extended","warn")else jF[#jF+1]=gJ(kV,kX,"Landed (G: Takeoff)","warnings")end end;if c8>-1 and(not cL or cb<100)then local lg=ip(d:getTargetGroundAltitude())jF[#jF+1]=gJ(kV,kY,"Hover Height: "..lg,"warn")end;local lh="#000011"local li=l2;local lj=l4;if bZ then lh="#0000DD"li=l3;lj=l5;jF[#jF+1]=gJ(kV,kZ+20,"ROCKET BOOST ENABLED","warn")end;local lk="#001100"local ll=l2;local lm=l4;if antigrav and not q and cL and bt~=nil then lk="#00DD00"ll=l3;lm=l5;local ln="warnings"if eU(cb-antigrav.getBaseAltitude())<501 then ln="warn"end;jF[#jF+1]=gJ(kV,k_+40,de("Target Altitude: %d Singularity Altitude: %d",bI(bt),bI(antigrav.getBaseAltitude())),ln)end;if b1 and bh~="None"then jF[#jF+1]=gJ(kV,k_,"Autopilot "..be,"warn")elseif br~=nil then jF[#jF+1]=gJ(kV,k_+20,de("LockedPitch: %d",bI(br)),"warn")elseif bV then jF[#jF+1]=gJ(kV,k_+20,"Follow Mode Engaged","warn")elseif b6 or c7 then jF[#jF+1]=gJ(kV,k_+20,"Re-entry in Progress","warn")end;if b3 or b7 then local lg=ip(b8,2)if b7 then if cL then lg=ip(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jF[#jF+1]=gJ(kV,k_,"VTO to "..lg,"warn")elseif b5 and not bx then if c6 then jF[#jF+1]=gJ(kV,k_,"Takeoff to "..bh,"warn")else jF[#jF+1]=gJ(kV,k_,"Takeoff to "..lg,"warn")end;if aZ and not b7 then jF[#jF+1]=gJ(kV,k_+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jF[#jF+1]=gJ(kV,k_,"Altitude Hold: "..de("%.1fm",b8),"warn")end end;if b7 and(antigrav~=nil and antigrav)then if ca>0.1 then jF[#jF+1]=gJ(kV,k_+20,"Beginning ascent","warn")elseif ca<0.09 and ca>0.05 then jF[#jF+1]=gJ(kV,k_+20,"Aligning trajectory","warn")elseif ca<0.05 then jF[#jF+1]=gJ(kV,k_+20,"Leaving atmosphere","warn")end end;if bx then if cx~=nil then jF[#jF+1]=gJ(kV,k_,cx,"warn")end end;if b4 then if lo then local lp="Brake Landing"if d7 then lp=lp.."-Aligning"end;if d6 then lp=lp.."-Drift Limited"end;jF[#jF+1]=gJ(kV,k_,lp,"warnings")else jF[#jF+1]=gJ(kV,k_,"Coast-Landing","warnings")end end;if b0 then jF[#jF+1]=gJ(kV,k_,"Prograde Alignment","crit")end;if a_ then jF[#jF+1]=gJ(kV,k_,"Retrograde Alignment","crit")end;local lq="#110000"local lr=l2;local ls=l4;if cU then lq="#FF0000"lr=l3;ls=l5;local type;if string.find(cU,"COLLISION")then type="warnings"else type="crit"end;jF[#jF+1]=gJ(kV,l0+20,cU,type)elseif ca==0 then local lt,lu=co.checkLOS(cF:normalize())if lu~=nil then ls=l5;lq="#FF0000"lr=l3;local lg=ip(lu)local lv=ck.computeTravelTime(cG,0,lu)local lw="Collision"if lt.noAtmosphericDensityAltitude>0 then lw="Atmosphere"end;jF[#jF+1]=gJ(kV,l0+20,lt.name.." "..lw.." "..iq(lv).." In "..lg,"crit")end end;if bo and not bx then jF[#jF+1]=gJ(kV,k_+60,lx,"warn")end;local ly="#111100"local lz=l2;local lA=l4;if cY and#cY>1 then ly="#DDDD00"lz=l3;lA=l5 end;local lB=iU;local lC=iV;local l4="topButton"local lD="topButtonActive"local lE=l4;if b1 or bo or c6 or bx then lE=lD end;local lF=l4;if b0 then lF=lD end;local lG=l4;if b4 or bk then lG=lD end;local lH=l4;if b3 or bo then lH=lD end;local lI=l4;if a_ then lI=lD end;local lJ=l4;if bx or cz and b1 then lJ=lD end;if w and I then local lK=lC(30)jF[#jF+1]=de([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lE,lB(960),lC(54),lC(-53),lB(-120),lB(25),lC(50))jF[#jF+1]=gJ(lB(910),lK,"AUTOPILOT")jF[#jF+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lB(865),lC(51),lB(-25),lC(-50),lB(-110),lB(25),lC(46))jF[#jF+1]=gJ(lB(800),lK,"PROGRADE")jF[#jF+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lB(755),lC(47),lB(-25),lC(-46),lB(-98),lB(44),lC(44))jF[#jF+1]=gJ(lB(700),lK,"LAND")jF[#jF+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lH,lB(960),lC(54),lC(-53),lB(120),lB(-25),lC(50))jF[#jF+1]=gJ(lB(1010),lK,"ALT HOLD")jF[#jF+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lI,lB(1055),lC(51),lB(25),lC(-50),lB(110),lB(-25),lC(46))jF[#jF+1]=gJ(lB(1122),lK,"RETROGRADE")jF[#jF+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lB(1165),lC(47),lB(25),lC(-46),lB(98),lB(-44),lC(44))jF[#jF+1]=gJ(lB(1220),lK,"ORBIT")jF[#jF+1]=[[
                                    </g>
                                </g>]]jF[#jF+1]="</g>"end;return jF end;local function lL(fl)return bI(fR(fl*3.6,0)+0.5).." km/h"end;local function lM(gs)local gu=bh;if gs~=nil and type(gs)=="number"then if gs==0 then return"None"end;gu=cP[gs].name end;if gu==nil then gu=g1.name end;if gu==nil then gu="None"end;return gu end;local function lN(jF)local lO=co.routeWP(true)if not lO or#lO==0 then return end;local hk=iU(750)local hl=iV(360)if b1 or bo then jF[#jF+1]=gJ(hk,hl,"REMAINING ROUTE","pdim txtstart size20")else jF[#jF+1]=gJ(hk,hl,"LOADED ROUTE","pdim txtstart size20")end;for dF,K in pairs(lO)do hl=hl+20;jF[#jF+1]=gJ(hk,hl,dF..". "..lO[dF],"pdim txtstart size20")end end;local function lP(jF)local hk=ay+10;local hl=az+20;local lQ={}local lR={"Alt-4: AutoTakeoff to Target"}local lS={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lT={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lU={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lQ,"--------------DYNAMIC-----------------")if c9 then if c8~=-1 then im(lQ,lR)if c1 and kh and c1.name==kh.name then table.insert(lQ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aY then if antigrav then if cL then table.insert(lQ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lQ,"Turn on AGG to takeoff to AGG Height")end end;if aY then table.insert(lQ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lQ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lQ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bk then table.insert(lQ,"G: Takeoff to hover height, raise gear")else table.insert(lQ,"G: Lowergear and Land")end else im(lQ,lS)table.insert(lQ,"G: Begin BrakeLanding or Land")end;if b7 then table.insert(lQ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else im(lQ,lT)if db then table.insert(lQ,"Alt-Shift-6: Vent shields")if not G then table.insert(lQ,"Alt-Shift-7: Toggle shield off/on")end end end;if g1~=nil then table.insert(lQ,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lQ,"Alt-9: Activate Gyroscope")end;if aU~="none"or aT~="none"or aV~="none"then table.insert(lQ,"Alt-Shift-9: Cycles engines with Extra tags")end;if b3 then table.insert(lQ,"Alt-Spacebar/C will raise/lower target height")table.insert(lQ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c9 then table.insert(lQ,"LALT+Mousewheel will lower/raise speed limit")end;im(lQ,lU)for K=1,#lQ do hl=hl+12;jF[#jF+1]=gJ(hk,hl,lQ[K],"pdim txtbig txtstart")end end;local function lV(jF)local lW=ay;local lX=az;local lY=ax;local lZ=4;local l_=15;local hk=0;local hl=0;local m0,m1,m2,m3;local m4;local function m5(type)local gE,bK,fl,m6,jz,m7;if type=="Periapsis"then gE=m4.periapsis.altitude;bK=m4.timeToPeriapsis;fl=m4.periapsis.speed;jz="txtend"m6=12;m7=math.min(hk,lW+lY-kh.radius/m2-lZ*2)else gE=m4.apoapsis.altitude;bK=m4.timeToApoapsis;fl=m4.apoapsis.speed;m6=-12;jz="txtstart"m7=hk end;if cG<1 then bK=0 end;jF[#jF+1]=de([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m7+m6,hl-5,hk,hl-5)jF[#jF+1]=de([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m7-m6*4,hl+2,hk,hl+2)jF[#jF+1]=gJ(m7,hl,type,jz)hk=m7-m6*2;hl=hl+l_;local lg=ip(gE)jF[#jF+1]=gJ(hk,hl,lg,jz)hl=hl+l_;jF[#jF+1]=gJ(hk,hl,iq(bK),jz)hl=hl+l_;jF[#jF+1]=gJ(hk,hl,lL(fl),jz)end;local m8=lY*1.5;if bF=="INFO"then m8=25*9 end;if bF~="HIDE"then jF[#jF+1]=[[<g class="pbright txtorb txtmid">]]jF[#jF+1]=de('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lY*2,m8,lW,lX)jF[#jF+1]=de([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lY*2,m8,lW,lX)end;local m9=lY*1.5;local ma=lY*2;local mb=m9/2;local mc=lY;local md=lW+mc;local me=lX+mb;local mf=lW+ma;local mg=lX+m9;if bF=="ORBIT"then lX=lX+lZ;m0=lY/2;m3=0;m4={}m4.periapsis={}m4.apoapsis={}if fp~=nil then if fp.periapsis~=nil then m4.periapsis.altitude=fp.periapsis.altitude;m4.periapsis.speed=fp.periapsis.speed end;if fp.apoapsis~=nil then m4.apoapsis.altitude=fp.apoapsis.altitude;m4.apoapsis.speed=fp.apoapsis.speed end;m4.period=fp.period;m4.eccentricity=fp.eccentricity;m4.timeToApoapsis=fp.timeToApoapsis;m4.timeToPeriapsis=fp.timeToPeriapsis;m4.eccentricAnomaly=fp.eccentricAnomaly;m4.trueAnomaly=fp.trueAnomaly end;if m4.periapsis==nil then m4.periapsis={}m4.periapsis.altitude=-kh.radius;m4.periapsis.speed=_ end;if m4.eccentricity==nil then m4.eccentricity=1 end;if m4.apoapsis==nil then m4.apoapsis={}m4.apoapsis.altitude=cb;m4.apoapsis.speed=0 end;if cG<1 then m4.apoapsis.altitude=cb;m4.apoapsis.speed=0 end;if m4.apoapsis.altitude then m2=(m4.apoapsis.altitude+m4.periapsis.altitude+kh.radius*2)/(m0*2)m1=(kh.radius+m4.apoapsis.altitude)/m2*(1-m4.eccentricity)m3=m0-m4.periapsis.altitude/m2-kh.radius/m2;local mh=math.pi;if m4.period~=nil and m4.period>0 and m4.timeToApoapsis~=nil then mh=m4.eccentricAnomaly;if m4.timeToPeriapsis<m4.timeToApoapsis then mh=2*math.pi-mh end end;if cG<1 or mh~=mh then mh=math.pi end;local mi=-m0*math.cos(mh)+lW+mc+lZ;local mj=m1*math.sin(mh)+lX+mb+lZ;local mk=""jF[#jF+1]='<g clip-path="url(#orbitRect)">'jF[#jF+1]=de([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mk,lW+lY+lZ,lX+lY*1.5/2+lZ,m0,m1)if m1<1 then jF[#jF+1]=de([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lW+lY+lZ-m3,lX+lY*1.5/2+lZ,mi,mj)end;jF[#jF+1]=de('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,(kh.radius+kh.noAtmosphericDensityAltitude)/m2)jF[#jF+1]=de('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,(kh.radius+kh.noAtmosphericDensityAltitude)/m2)jF[#jF+1]=de([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lW+lY+lZ,lX+lY*1.5/2+lZ,m0,m1)jF[#jF+1]=de('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,kh.radius/m2)jF[#jF+1]='</g>'local ml=math.floor(kh.radius/m2+0.5)hk=lW+lY+lZ*4+m0;hl=lX+lY*1.5/2+5+lZ;if m4.apoapsis~=nil and m4.apoapsis.speed<_ then m5("Apoapsis")end;hl=lX+lY*1.5/2+5+lZ;hk=lW+lY-lZ*2-m0;if m4.periapsis~=nil and m4.periapsis.speed<_ and m4.periapsis.altitude>0 then m5("Periapsis")end;jF[#jF+1]=gJ(lW+lY+lZ,lX+20+lZ,kh.name,"txtorbbig")jF[#jF+1]=de('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mi,mj)jF[#jF+1]=[[</g>]]return jF else jF[#jF+1]='<g clip-path="url(#orbitRect)">'local mm=""local mn=1.2*(mo-mp)/(lY*2)local mq=1.4*(mr-ms)/(lY*1.5)for dF,dr in pairs(e[0])do if dr.center then local hk=lW+lY+dr.center.x/mn;local hl=lX+lY*1.5/2+dr.center.y/mq;mm=mm..'<circle cx="'..hk..'" cy="'..hl..'" r="'..dr.radius/mn*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dr.name,"Moon")and not string.match(dr.name,"Sanctuary")and not string.match(dr.name,"Space")then mm=mm.."<text x='"..hk.."' y='"..hl+dr.radius/mn*30+20 .."' font-size='12' fill="..iM.." text-anchor='middle' font-family='Montserrat'>"..dr.name.."</text>"end end end;local fr=vec3(b.getConstructWorldPos())local hk=lW+lY+fr.x/mn;local hl=lX+lY*1.5/2+fr.y/mq;mm=mm..'<circle cx="'..hk..'" cy="'..hl..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mm=mm.."<text x='"..hk.."' y='"..hl-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iy=mn;iz=mq;local mt=fr+cF*1000000;local mu=lW+lY+mt.x/mn;local jp=lX+lY*1.5/2+mt.y/mq;mm=mm..'<line x1="'..hk..'" y1="'..hl..'" x2="'..mu..'" y2="'..jp..'" stroke="purple" stroke-width="1"/>'jF[#jF+1]=mm;jF[#jF+1]='</g>'end elseif bF=="INFO"then jF=cm.DrawOdometer(jF,iO,bl,iP)elseif bF=="HELP"then jF=lP(jF)elseif bF=="SCOPE"then jF[#jF+1]='<g clip-path="url(#orbitRect)">'local mv=d0;if ca>0 then table.sort(c_,function(ev,ew)local ex,ey=ev.center,ew.center;return(ex.x-cJ.x)^2+(ex.y-cJ.y)^2+(ex.z-cJ.z)^2<(ey.x-cJ.x)^2+(ey.y-cJ.y)^2+(ey.z-cJ.z)^2 end)end;local gR={}local mw={}local mx=120;local my=nil;local mz=nil;for K,dr in ipairs(c_)do local gQ=dr.center-cJ;local mA=gQ:len()local mB=gQ:normalize()local mC=gQ:cross(cC):normalize()local mD=math.acos(mC:dot(cD))if mD~=mD then mD=0 end;if mC:cross(cD):dot(cC)<0 then mD=-mD end;local mE=gQ:project_on_plane(cC):len()local mF=math.sin(mD)*math.asin(mE/mA)*constants.rad2deg;local mG=math.cos(mD)*math.asin(mE/mA)*constants.rad2deg;if mB:dot(cC)<0 then mG=90*math.cos(mD)+90*math.cos(mD)-mG;mF=90*math.sin(mD)+90*math.sin(mD)-mF end;local hk=md+mF/mv*m9;local hl=me+mG/mv*m9;local mH=(hk-md)*(hk-md)+(hl-me)*(hl-me)local mI=math.asin((dr.radius+dr.surfaceMaxAltitude)/mA)*constants.rad2deg;if mI~=mI then mI=mv end;local hG=mI/mv*m9;local mJ=math.asin(dr.atmosphereRadius/mA)*constants.rad2deg;if mJ~=mJ then mJ=mI end;local mK=mJ/mv*m9;local c4=ip(mA,1)local mL=dr.name;local mM=false;if hl>lX then if hl>mg then if hl-mK<=mg then mM=true end else mM=true end else if hl+mK>=lX then mM=true end end;local mN=false;local mO=hk;if dr.systemId==0 then mO=hk+mx else mO=hk-mx end;if mO+mx>lW then if mO+mx>mf then if mO-mK-mx<=mf then mN=true end else mN=true end else if mO+mK+mx>=lW then mN=true end end;local mP={}mP.x=hk;mP.y=hl;mP.planet=dr;mP.atmoSize=mK;if not my or mH<my then my=mH;mz=mP end;if mN and mM then local mQ=math.max(mK,5)if mH<mQ*mQ then mL=mL.." - "..c4 end;mP.size=hG;mP.i=K;mP.displayString=mL;mP.distance=c4;mP.visible=true;mw[#mw+1]=mP else mP.visible=false end end;local mR=false;table.sort(mw,function(ex,ey)return ex.y<ey.y end)for dF,fu in ipairs(mw)do local dr,hG,K,mK,hk,hl,mL,c4=fu.planet,fu.size,fu.i,fu.atmoSize,fu.x,fu.y,fu.displayString,fu.distance;local m7,mS,mT,mU;local mV=15;local jz="pdim"if dr.systemId~=0 then mT=iU(string.len(mL)*5)mV=-(15+mT)mU=iV(10)jz="pdimfill"else mT=iU(string.len(mL)*9)mU=iV(15)end;if hG*2>mT then m7=df(hk,lW+mT/2,mf-mT/2)mS=df(hl,lX+mU,mg-5)m7=df(m7,hk-hG+mT/2,hk+hG-mT/2)mS=df(mS,hl-hG+mU,hl+hG)else m7=hk+mV;mS=hl end;for mW,fu in pairs(gR)do local mX=fu.textPositions;local mY=mX.y-mS;if mW~=K and eU(mY)<mX.height and mX.x+mX.width>m7 and mX.x<m7+mT then if hG>mT then mS=df(mS+mU,lX+15,mg-5)else mS=mX.y+mX.height+1 end end end;local mZ=mL~=dr.name or m7<=md and m7+mT>=md and mS-mU<=me and mS>=me;fu.hovered=mZ;local m_=1;if mZ then m_=2;if hG*2<mT then m_=10 end;if mL==dr.name then mL=mL.." - "..c4 end;jz="pbright"if dr.systemId~=0 then mT=iU(string.len(mL)*5)mV=-(15+mT)else mT=iU(string.len(mL)*7)end;if hG*2>mT then m7=df(hk,lW+mT/2,mf-mT/2)m7=df(m7,hk-hG+mT/2,hk+hG-mT/2)else m7=hk+mV end end;gR[K]={}gR[K].textPositions={}gR[K].textPositions.y=mS;gR[K].textPositions.x=m7;gR[K].textPositions.width=mT;gR[K].textPositions.height=mU;gR[K].output=""if hG*2>mT then jz=jz.." txtmid"else jz=jz.." txtstart"end;if mK-hG>2 then gR[K].output=de('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hk,hl,mK,iN,0.1*m_)end;gR[K].output=gR[K].output..de('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hk,hl,hG,iN,0.2*m_)if dr.systemId==0 then gR[K].output=gR[K].output..de([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m7,mS,iM,jz,mL)if hG*2<=mT then gR[K].output=gR[K].output..de("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m7+mT,mS+2,m7,mS+2,hk,hl)end else gR[K].output=gR[K].output..de([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m7,mS,iN,jz,mL)if hG*2<=mT then gR[K].output=gR[K].output..de("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m7,mS+2,m7+mT,mS+2,hk,hl)end end end;for dF=#c_,1,-1 do if gR[dF]then jF[#jF+1]=gR[dF].output end end;if mz~=nil and d0<90 and not mz.hovered then local n0=mz.planet.atmosphereRadius/mz.atmoSize;local n1=dh(my)*n0;local n2=ip(n1,1)local mT=iU(math.max(string.len(n2)*7,string.len(mz.planet.name)*7))local mU=iV(12)local m7=df(mz.x+(md-mz.x)/2,lW+mT/2,mf-mT/2)local mS=df(mz.y+(me-mz.y)/2,lX+mU*2,mg-5)jF[#jF+1]=de("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mz.x,mz.y,md,me)jF[#jF+1]=de([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m7,mS,"white",n2)if not mz.visible then jF[#jF+1]=de([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m7,mS-mU,"white",mz.planet.name)end end;if cG>1 then local gQ=cF;local mB=gQ:normalize()local mE=gQ:project_on_plane(cC):len()local mC=gQ:cross(cC):normalize()local mD=math.acos(mC:dot(cD))if mD~=mD then mD=0 end;if mC:cross(cD):dot(cC)<0 then mD=-mD end;local mF=math.sin(mD)*math.asin(mE/gQ:len())*constants.rad2deg;local mG=math.cos(mD)*math.asin(mE/gQ:len())*constants.rad2deg;if mB:dot(cC)<0 then mG=90*math.cos(mD)+90*math.cos(mD)-mG;mF=90*math.sin(mD)+90*math.sin(mD)-mF end;local hk=md+mF/mv*m9;local hl=me+mG/mv*m9;local kB=14;local kC=kB/2;local kF=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kC/kB..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kC..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk-kB..[[,]]..hl..[[ h ]]..kC..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk+kC..[[,]]..hl..[[ h ]]..kC..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kB..[[ v ]]..kC..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jF[#jF+1]=kF end;jF[#jF+1]=de("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",md,me-10,md,me+10)jF[#jF+1]=de("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",md-10,me,md+10,me)jF[#jF+1]='</g>'else return jF end end;local function n3(n4,n5)local n6;local n7=(n5-n4):normalize()local fs=(cJ-n4):dot(n7)/n7:dot(n7)if fs<=0. then return(cJ-n4):len()elseif fs>=(n5-n4):len()then return(cJ-n5):len()end;local n8=n4+fs*n7;n6=(n8-cJ):len()return n6 end;local function n9()local n6;local na=nil;local nb=nil;local nc=nil;for dF,nd in pairs(e[0])do if nd.hasAtmosphere then local c4=n3(kh.center,nd.center)if na==nil or c4<na then nb=nd;na=c4;nc=kh end;if c1 and c1.hasAtmosphere and c1.name~=kh.name then local eK=n3(c1.center,nd.center)if eK<na then nb=nd;na=eK;nc=c1 end end end end;local ne=iU(1770)local nf=iV(330)if na then local ng="txttick "local nh=500000;if na<nb.radius+nh or na<nc.radius+nh then if cQ then ng="txttick red "else ng="txttick orange "end end;n6=ip(na,2)iD=gJ(ne,nf,"Pipe ("..nc.name.."--"..nb.name.."): "..n6,ng.."pbright txtmid")end end;local function ni(hk,hl,nj,nk,kO)local nl={x=hk,y=hl,width=nj,height=nk,label=kO}ix[kO]=nl;return nl end;local function nm(nn,no,nj,nk,hk,hl,np,nq,nr,ns,jz)local nl={enableName=nn,disableName=no,width=nj,height=nk,x=hk,y=hl,toggleVar=np,toggleFunction=nq,drawCondition=nr,hovered=false,class=jz}if ns then table.insert(iw,nl)else table.insert(iv,nl)end;return nl end;local function nt(nu)if not iB then nv=false;nw=false;nx=false;w=true;return elseif nu=="handling"then nv=not nv;nw=false;nx=false elseif nu=="hud"then nw=not nw;nv=false;nx=false elseif nu=="physics"then nx=not nx;nv=false;nw=false end;if nx or nw or nv then iC=io(nu)w=false else iC="none"w=true end end;local function ny()iB=not iB;if iB then iu=iw;bX="Hold SHIFT to see Settings"d1=w else iu=iv;bX="Hold SHIFT to see Control Buttons"nt()w=d1 end end;local function nz()local function nA(dr,dF)dr.set(not dr.get())if dr.get()then bX=dF.." set to true"else bX=dF.." set to false"end;if dF=="showHud"then d1=dr.get()elseif dF=="BrakeToggleDefault"then aX=j end end;local nB=50;local nC=340;local hk=500;local hl=cf/2-400;local nD=0;for dF,dr in pairs(io("boolean"))do if type(dr.get())=="boolean"then nm(dF,dF,nC,nB,hk,hl,function()return dr.get()end,function()nA(dr,dF)end,function()return true end,true)hl=hl+nB+20;if nD==9 then hk=hk+nC+20;hl=cf/2-400;nD=0 else nD=nD+1 end end end;nm("Control View","Control View",nC,nB,10,cf/2-500,function()return true end,ny,function()return true end,true)nm("View Handling Settings",'Hide Handling Settings',nC,nB,10,cf/2-(500-nB),function()return nv end,function()nt("handling")end,function()return true end,true)nm("View Hud Settings",'Hide Hud Settings',nC,nB,10,cf/2-(500-nB*2),function()return nw end,function()nt("hud")end,function()return true end,true)nm("View Physics Settings",'Hide Physics Settings',nC,nB,10,cf/2-(500-nB*3),function()return nx end,function()nt("physics")end,function()return true end,true)end;local function nE()local function gt()local fT=cJ;local gu=kh.name..". "..#bn;if radar_1 then gu=cp.GetClosestName(gu)end;return cn.AddNewLocation(gu,fT,false,true)end;local function nF()b2=not b2 end;local function nG(nH)if nH==1 then b0=not b0;a_=false else a_=not a_;b0=false end;b1=false;b3=false;bV=false;b4=false;br=nil;b6=false;b5=false end;local function nI(nJ,nK)cn.UpdatePosition(nil,nJ,nK)end;local function go()cn.ClearCurrentPosition()end;local function nL(gs)local lO=co.routeWP(true)if lO and#lO>0 then return"Engage Route: "..lO[1]end;return"Engage Autopilot: "..lM(gs)end;local function nM(gs)local lO=co.routeWP(true)if lO and#lO>0 then return"Next Route Point: "..lO[1]end;return"Disable Autopilot: "..lM(gs)end;local function nN()if ij()==1 then bV=not bV;if bV then b1=false;a_=false;b0=false;b3=false;b6=false;b4=false;b5=false;nO=bk;bk=false;d.control.retractLandingGears()ik:setTargetGroundAltitude(X)fQ("folOn","F")else fQ("folOff","F")aZ="Follow Off"cu=p;bk=nO;if bk then d.control.extendLandingGears()ik:setTargetGroundAltitude(Y)end end else bX="Follow Mode only works with Remote controller"bV=false end end;local nB=50;local nC=260;local nP=iU(30)local nQ=ay+ax*2+2;local nR=az+1;nm("+","+",nP,nP,nQ,nR+nP+1,function()return false end,function()d0=d0/8 end,function()return bF=="SCOPE"end,nil,"ZoomButton")nm("-","-",nP,nP,nQ,nR,function()return false end,function()d0=math.min(d0*8,90)end,function()return bF=="SCOPE"end,nil,"ZoomButton")nm("0","0",nP,nP,nQ,nR+nP*2+2,function()return false end,function()d0=90 end,function()return bF=="SCOPE"and d0~=90 end,nil,"ZoomButton")local nS=nm("Enable Brake Toggle","Disable Brake Toggle",nC,nB,ce/2-nC/2,cf/2+350,function()return aX end,function()aX=not aX;if aX then bX="Brakes in Toggle Mode"else bX="Brakes in Default Mode"end end)nm("Align Prograde","Disable Prograde",nC,nB,ce/2-nC/2-50-nS.width,cf/2-nB+380,function()return b0 end,function()nG(1)end)nm("Align Retrograde","Disable Retrograde",nC,nB,ce/2-nC/2+nS.width+50,cf/2-nB+380,function()return a_ end,nG,function()return ca==0 end)nT=nm(nL,nM,600,60,ce/2-600/2,cf/2-60/2-330,function()return b1 or bo or c6 or bx end,function()end)local K;local function nU(nV)local gs=cX+nV;if gs>#cP then gs=gs-#cP-1 end;if gs<0 then gs=#cP+gs end;return gs end;nW={}for K=0,10 do local nX=nm(function(ey)local gs=nU(ey.apExtraIndex)if b1 or bo or c6 or bx then return"Redirect: "..lM(gs)end;return nL(gs)end,function(ey)local gs=nU(ey.apExtraIndex)return nM(gs)end,600,60,ce/2-600/2,cf/2-60/2-330+60*K,function(ey)local gs=nU(ey.apExtraIndex)return gs==bj and(b1 or bo or c6 or bx)end,function(ey)local gs=nU(ey.apExtraIndex)local nY=bj==gs;bj=gs;cn.UpdateAutopilotTarget()co.ToggleAutopilot()if not nY and not(b1 or bo or c6 or bx)then co.ToggleAutopilot()end end,function()return cW and(#co.routeWP(true)==0 or K==0)end)nX.apExtraIndex=K;nW[K]=nX end;nm("Save Position","Save Position",200,nT.height,nT.x+nT.width+30,nT.y,function()return false end,gt,function()return bj==0 or g1==nil end)nm("Update Position","Update Position",200,nT.height,nT.x+nT.width+30,nT.y,function()return false end,function()nI(nil)end,function()return bj>0 and g1~=nil end)nm("Save Heading","Clear Heading",200,nT.height,nT.x+nT.width+30,nT.y+nT.height+20,function()return g1.heading~=nil end,function()if g1.heading~=nil then nI(false)else nI(true)end end,function()return bj>0 and g1~=nil end)nm("Save AGG Alt","Clear AGG Alt",200,nT.height,nT.x+nT.width+30,nT.y+nT.height*2+40,function()return g1.agg~=nil end,function()if g1.agg~=nil then nI(nil,false)else nI(nil,true)end end,function()return bj>0 and g1~=nil and antigrav end)nm("Clear Position","Clear Position",200,nT.height,nT.x-200-30,nT.y,function()return true end,go,function()return bj>0 and g1~=nil end)nm("Save Route","Save Route",200,nT.height,nT.x-200-30,nT.y+nT.height*2+40,function()return false end,function()co.routeWP(false,false,2)end,function()return#co.routeWP(true)>0 end)nm("Load Route","Clear Route",200,nT.height,nT.x-200-30,nT.y+nT.height+20,function()return#co.routeWP(true)>0 end,function()if#co.routeWP(true)>0 then co.routeWP(false,true)elseif b1 or bo then bX="Disable Autopilot before loading route"return else co.routeWP(false,false,1)end end,function()return true end)nB=60;nC=300;local hk=0;local hl=cf/2-150;nm("Enable Check Damage","Disable Check Damage",nC,nB,hk,hl-nB-20,function()return s end,function()s=not s end)nm("View Settings","View Settings",nC,nB,hk,hl,function()return true end,ny)hl=hl+nB+20;nm("Enable Turn and Burn","Disable Turn and Burn",nC,nB,hk,hl,function()return b2 end,nF)hk=10;hl=cf/2-300;nm("Horizontal Takeoff Mode","Vertical Takeoff Mode",nC,nB,hk+nC+20,hl,function()return aY end,function()aY=not aY;if aY then bX="Vertical Takeoff Mode"else bX="Horizontal Takeoff Mode"end end,function()return cK end)hl=hl+nB+20;nm("Engage Orbiting","Cancel Orbiting",nC,nB,hk+nC+20,hl,function()return bx end,co.ToggleIntoOrbit,function()return ca==0 and cT end)hl=cf/2-150;nm("Glide Re-Entry","Cancel Glide Re-Entry",nC,nB,hk+nC+20,hl,function()return b6 end,function()c5=1;nG(1)end,function()return kh.hasAtmosphere and not c9 end)hl=hl+nB+20;nm("Parachute Re-Entry","Cancel Parachute Re-Entry",nC,nB,hk+nC+20,hl,function()return b6 end,function()c5=2;nG(1)end,function()return kh.hasAtmosphere and not c9 end)hl=hl+nB+20;nm("Engage Follow Mode","Disable Follow Mode",nC,nB,hk,hl,function()return bV end,nN,function()return ij()==1 end)nm("Enable Repair Arrows","Disable Repair Arrows",nC,nB,hk+nC+20,hl,function()return iS end,function()iS=not iS;if iS then bX="Repair Arrows Enabled"else bX="Repair Arrows Diabled"end end,function()return ij()==1 end)hl=hl+nB+20;if not q then nm("Enable AGG","Disable AGG",nC,nB,hk,hl,function()return cL end,co.ToggleAntigrav,function()return antigrav~=nil end)end;nm(function()return de("Switch IPH Mode - Current: %s",by)end,function()return de("IPH Mode: %s",by)end,nC*2,nB,hk,hl,function()return false end,function()if by=="All"then by="Custom Only"elseif by=="Custom Only"then by="No Moons"else by="All"end;bX="IPH Mode: "..by end)hl=hl+nB+20;nm(function()return de("Toggle Control Scheme - Current: %s",g)end,function()return de("Control Scheme: %s",g)end,nC*2,nB,hk,hl,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bX="New Control Scheme: "..g end)local nZ=iV(20)local nX=ni(0,0,iU(70),nZ,"HELP")nX=ni(nX.x+nX.width,nX.y,iU(80),nZ,"INFO")nX=ni(nX.x+nX.width,nX.y,iU(70),nZ,"ORBIT")nX=ni(nX.x+nX.width,nX.y,iU(70),nZ,"SCOPE")ni(nX.x+nX.width,nX.y,iU(70),nZ,"HIDE")end;local n_={}local o0=nil;function n_.HUDPrologue(jF)if not cQ then iJ=af;iK=ag;iL=ah else iJ=ac;iK=ad;iL=ae end;iM=[[rgb(]]..bI(iJ+0.6)..","..bI(iK+0.6)..","..bI(iL+0.6)..[[)]]iN=[[rgb(]]..bI(iJ*0.8+0.5)..","..bI(iK*0.8+0.5)..","..bI(iL*0.8+0.5)..[[)]]local o1=iM;local o2=iN;local o3=[[rgb(]]..bI(iJ*0.4+0.5)..","..bI(iK*0.4+0.5)..","..bI(iL*0.4+0.5)..[[)]]local o4=iM;local o5=iN;local o6=o3;if iW()and not m then o1=[[rgb(]]..bI(iJ*0.5+0.5)..","..bI(iK*0.5+0.5)..","..bI(iL*0.5+0.5)..[[)]]o2=[[rgb(]]..bI(iJ*0.3+0.5)..","..bI(iK*0.3+0.5)..","..bI(iL*0.2+0.5)..[[)]]o3=[[rgb(]]..bI(iJ*0.2+0.5)..","..bI(iK*0.2+0.5)..","..bI(iL*0.2+0.5)..[[)]]end;local lB=iU;local lC=iV;jF[#jF+1]=de([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o1,o1,o1,o4,o4,o2,o2,o5,o5,o2,o1,o3,o5,o1,o1,o3,o3,o6,o3,ce,cf,o2,o2,o2,o2,o2,o4,o2,o5,o6,o5,o5,o6)if not o0 then o0=de([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lB(630),lC(0),lB(675),lC(45),lB(960),lC(55),lB(1245),lC(45),lB(1290),lC(0),lB(1000),lC(105),lB(1040),lC(59),lB(1250),lC(51),lB(1300),lC(0),lB(1920),lC(0),lB(1920),lC(20),lB(1400),lC(20),lB(1300),lC(105),lB(920),lC(105),lB(880),lC(59),lB(670),lC(51),lB(620),lC(0),lB(0),lC(0),lB(0),lC(20),lB(520),lC(20),lB(620),lC(105),lB(890),lC(59),lB(960),lC(62),lB(1030),lC(59),lB(985),lC(112),lB(1150),lC(112),lB(1100),lC(152),lB(820),lC(152),lB(780),lC(112),lB(935),lC(112),lB(890),lC(59),lB(960),lC(62),lB(1030),lC(59),lB(985),lC(112),lB(1150),lC(112),lB(1100),lC(152),lB(820),lC(152),lB(780),lC(112),lB(935),lC(112))end;if w and I then jF[#jF+1]=o0 end;return jF end;function n_.DrawVerticalSpeed(jF,dZ)jE(jF,dZ)end;function n_.UpdateHud(jF)local ku=cN;local o7=cO;local jM=o7;local k1=ku;local kM=bI(c.getThrottle())local kR=cG*3.6;local kN=c.getAxisCommandValue(0)local o8=iU(1770)local o9=iV(310)if t and cM then kN=bL;kM=bL*100 end;local iY=iX()local jN="ROLL"if kM==nil then kM=0 end;if not cT then if cG>5 then ku=kt(cE)o7=kv(cE)else ku=0;o7=0 end;jN="YAW"end;if cR>50000 and not c9 then local oa;oa=ip(cR)jF[#jF+1]=gJ(o8,o9,"PvP Boundary: "..oa,"pbright txtbig txtmid")end;jF[#jF+1]=iQ;jF[#jF+1]=iH;jF[#jF+1]=hV;if iD~=""then jF[#jF+1]=iD end;if iZ~=""then jF[#jF+1]=iZ end;if i_~=""then jF[#jF+1]=i_ end;jE(jF,cb)if ij()==0 or l then if not iW()or m then if cT then jL(jF,ai,aj,jM,jN,cT)k0(jF,k1,jM,ai,aj,cT,bI(kv(cE)),cG)else jL(jF,ai,aj,o7,jN,cT)k0(jF,ku,o7,ai,aj,cT,bI(o7),cG)end;k7(jF,cb,cT)kw(jF,cE,cG,ai,aj)end end;kL(jF,iY,kM,kN)kQ(jF,kR)kU(jF)lV(jF)if not iB and bW then lN(jF)end;return jF end;function n_.HUDEpilogue(jF)jF[#jF+1]="</svg>"return jF end;function n_.ExtraData(jF)local ob=iU(1240)local oc=iV(55)local od=oc+10;local oe;local lB=iU;local lC=iV;local of=0;local iY=iX()if aY then iY=iY.."-VERTICAL"end;if E and not b5 and not b4 and cG>20 then iY=iY.."-COLLISION ON"end;if bA~="Off"then iY="("..bA..")-"..iY end;if b2 then iY="TB-"..iY end;if not bz then iY=iY.."-DeCoupled"end;local og=lC(99)local oh=lC(80)local oi=lC(85)local oj=lC(31)local ok=0;local ol=0;local om=cc>1000000 and fR(cc/1000000,2).."kT"or fR(cc/1000,2).."T"if c9 then of=bs else of=bq end;local on,oo=ck.computeDistanceAndTime(cG,0,cc,0,0,of)if on<0 then on=0 end;of=fR(of/(cc*it),2).."g"local op=d:maxForceForward()oe=b.g()if oe>0.1 then ol=cc*oe;ol=fR(ol/(cc*it),2).."g"ok=0.5*op/oe;ok=ok>1000000 and fR(ok/1000000,2).."kT"or fR(ok/1000,2).."T"end;op=fR(op/(cc*it),2).."g"local oq=vec3(b.getWorldAcceleration()):len()/9.80665;oe=b.g()jF[#jF+1]=[[<g class="dim txt txtend size14">]]if ij()==1 and not l then ob=iU(1120)oc=iV(55)od=oc+10 elseif c9 and I then local os=iU(770)jF[#jF+1]=gJ(lB(895),og,"ATMO","")jF[#jF+1]=de([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lB(895),oi,lB(-80))jF[#jF+1]=gJ(lB(815),oh,de("%.1f%%",ca*100),"txtstart size20")end;if I then jF[#jF+1]=gJ(lB(1025),og,"GRAVITY","txtstart")jF[#jF+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1025),oi,lB(80))jF[#jF+1]=gJ(lB(1105),oh,de("%.2fg",oe/9.80665),"size20")jF[#jF+1]=gJ(lB(1125),og,"ACCEL","txtstart")jF[#jF+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1125),oi,lB(80))jF[#jF+1]=gJ(lB(1205),oh,de("%.2fg",oq),"size20")jF[#jF+1]=gJ(lB(695),og,"BRK TIME","")jF[#jF+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(695),oi,lB(-80))jF[#jF+1]=gJ(lB(615),oh,de("%s",iq(oo)),"txtstart size20")jF[#jF+1]=gJ(lB(635),lC(45),"TRIP","")jF[#jF+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(635),lC(31),lB(-90))if lv then jF[#jF+1]=gJ(lB(545),lC(26),de("%s",iq(lv)),"txtstart size20")end;jF[#jF+1]=gJ(lB(795),og,"BRK DIST","")jF[#jF+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(795),oi,lB(-80))jF[#jF+1]=gJ(lB(715),oh,de("%s",ip(on)),"txtstart size20")jF[#jF+1]=gJ(lB(1285),lC(45),"MASS","txtstart")jF[#jF+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1285),lC(31),lB(90))jF[#jF+1]=gJ(lB(1375),lC(26),de("%s",om),"size20")jF[#jF+1]=gJ(lB(1220),og,"THRUST","txtstart")jF[#jF+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1220),oi,lB(80))jF[#jF+1]=gJ(lB(1300),oh,de("%s",op),"size20")jF[#jF+1]=gJ(iU(960),iV(175),iY,"pbright txtbig txtmid size20")end;jF[#jF+1]="</g>"end;local ot=1-(a5*0.05+a6*0.05)function n_.FuelUsed(ou)local ov;if ou=="atmofueltank"then ov=de("Atmo Fuel Used: %.1f L",jg[ou]/(4*ot))elseif ou=="spacefueltank"then ov=de("Space Fuel Used: %.1f L",jg[ou]/(6*ot))else ov=de("Rocket Fuel Used: %.1f L",jg[ou]/(0.8*ot))end;return ov end;function n_.DrawOdometer(jF,iO,bl,iP)if bF~="INFO"then return jF end;local oe;local ok=0;local ol=0;local of=0;local om=cc>1000000 and fR(cc/1000000,2).." kTons"or fR(cc/1000,2).." Tons"if c9 then of=bs else of=bq end;local on,oo=ck.computeDistanceAndTime(cG,0,cc,0,0,of)of=fR(of/(cc*it),2).." g"local op=d:maxForceForward()oe=b.g()if oe>0.1 then ol=cc*oe;ol=fR(ol/(cc*it),2).." g"ok=0.5*op/oe;ok=ok>1000000 and fR(ok/1000000,2).." kTons"or fR(ok/1000,2).." Tons"end;op=fR(op/(cc*it),2).." g"if ij()==0 or l then local ow=iU(ay+10)local ox=iV(az+20)local oy=iU(ay+10+ax/1.25)local nk=25;jF[#jF+1]="<g class='txtstart size14 bright'>"jF[#jF+1]=gJ(ow,ox,de("BrkTime: %s",iq(oo)))jF[#jF+1]=gJ(oy,ox,de("Trip: %.2f km",iO))jF[#jF+1]=gJ(ow,ox+nk,de("Lifetime: %.2f kSU",bl/200000))jF[#jF+1]=gJ(oy,ox+nk,de("BrkDist: %s",ip(on)))jF[#jF+1]=gJ(ow,ox+nk*2,"Trip Time: "..iq(iP))jF[#jF+1]=gJ(oy,ox+nk*2,"Total Time: "..iq(bm))jF[#jF+1]=gJ(ow,ox+nk*3,de("Mass: %s",om))jF[#jF+1]=gJ(oy,ox+nk*3,de("Max Brake: %s",of))jF[#jF+1]=gJ(ow,ox+nk*4,de("Max Thrust: %s",op))if oe>0.1 then jF[#jF+1]=gJ(oy,ox+nk*4,de("Max Thrust Mass: %s",ok))jF[#jF+1]=gJ(ow,ox+nk*5,de("Req Thrust: %s",ol))else jF[#jF+1]=gJ(oy,ox+nk*4,"Max Mass: n/a")jF[#jF+1]=gJ(ow,ox+nk*5,"Req Thrust: n/a")end;jF[#jF+1]=gJ(oy,ox+nk*5,cm.FuelUsed("atmofueltank"))jF[#jF+1]=gJ(ow,ox+nk*6,cm.FuelUsed("spacefueltank"))jF[#jF+1]=gJ(oy,ox+nk*6,cm.FuelUsed("rocketfueltank"))jF[#jF+1]=gJ(ow,ox+nk*7,de("Set Max Speed: %s",bI(_*3.6+0.5)))jF[#jF+1]=gJ(oy,ox+nk*7,de("Actual Max Speed: %s",bI(da*3.6+0.5)))end;jF[#jF+1]="</g></g>"return jF end;function n_.DrawWarnings(jF)return kU(jF)end;function n_.DisplayOrbitScreen(jF)return lV(jF)end;function n_.DisplayMessage(jF,lg)if lg~="empty"then local hl=310;for lp in string.gmatch(lg,"([^\n]+)")do hl=hl+35;jF[#jF+1]=gJ("50%",hl,lp,"msg")end end;if bY~=0 then c.setTimer("msgTick",bY)bY=0 end end;function n_.DrawDeadZone(jF)jF[#jF+1]=de([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aw)end;function n_.UpdatePipe()if c9 then iD=""return end;n9()end;function n_.DrawSettings(jF)local hk=iU(640)local hl=iV(200)jF[#jF+1]=[[<g class="pbright txtvspd txtstart">]]local hD=0;for dF,dr in pairs(iC)do hD=hD+1;jF[#jF+1]=gJ(hk,hl,dF..": "..dr.get())hl=hl+20;if hD%12==0 then hk=hk+iU(350)hl=iV(200)end end;jF[#jF+1]=gJ(iU(640),iV(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jF[#jF+1]="</g>"return jF end;local hT=iV(15)local hS=iU(1370)local hW,oz;function n_.DrawRadarInfo()hV=cp.GetRadarHud(hS,hT,au,av)end;function n_.DrawTanks()if aq~=0 and ar~=0 then iZ=gJ(aq,ar,"","txtstart pdim txtfuel")jh=ar;ji(aq,"Atmospheric ","ATMO",cg,je,jf)ji(aq,"Space Fuel T","SPACE",ch,jc,jd)ji(aq,"Rocket Fuel ","ROCKET",ci,ja,jb)end end;function n_.DrawShield()local i2=db.getState()==1 and"Shield Active"or"Shield Disabled"local oA=b.getPvPTimer()local oB=db.getResistances()local oC="A: "..10+oB[1]*100 .."% / E: "..10+oB[2]*100 .."% / K:"..10+oB[3]*100 .."% / T: "..10+oB[4]*100 .."%"local hk,hl=as-60,at+30;local jx=bI(dc*2.55)local jy=de("rgb(%d,%d,%d)",255-jx,jx,0)local jz=""i_=gJ(hk,hl,"","txtmid pdim txtfuel")if dc<10 and i2~="Shield Disabled"then jz="red "end;oA=oA>0 and"   PvPTime: "..iq(oA)or""i_=i_..de([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hk,hl,jy,dc*2,hk,hl,hk+2,hl+10,dc,oA)i_=i_..gJ(hk,hl-5,i2,jz.."txtstart pbright txtbig")i_=i_..gJ(hk,hl+30,oC,jz.."txtstart pbright txtsmall")end;function n_.hudtick()if not kh then return end;local function oD(jF)local jB=bI(df(d8/(ce/4)*255,0,255))jF[#jF+1]=de("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c2,c3,bI(iJ+0.5)+jB,bI(iK+0.5)-jB,bI(iL+0.5)-jB)end;local function oE()for dK,dr in pairs(iu)do if dr.hovered then if not dr.drawCondition or dr.drawCondition(dr)then dr.toggleFunction(dr)end;dr.hovered=false end end;for dK,dr in pairs(ix)do if dr.hovered then bF=dr.label;dr.hovered=false end end end;local function oF()local function oG(oH,oI,hk,hl,nj,nk)if oH>=hk and oH<=hk+nj and oI>=hl and oI<=hl+nk then return true else return false end end;local hk=c2+ce/2;local hl=c3+cf/2;for dK,dr in pairs(iu)do dr.hovered=oG(hk,hl,dr.x,dr.y,dr.width,dr.height)end;for dK,dr in pairs(ix)do dr.hovered=oG(hk,hl,dr.x,dr.y,dr.width,dr.height)end;if cW then local mZ=false;for dK,ey in ipairs(nW)do if ey.hovered then mZ=true;break end end;if nT.hovered then mZ=true end;cW=mZ else cW=nT.hovered;if not cW then cX=bj end end end;local function oJ(jF)if not bF or bF==""then bF="HELP"end;if w then for dF,dr in pairs(ix)do local jz="dim brightstroke"local oK=0.2;if bF==dF then jz="pbright dimstroke"oK=0.6 end;local oL=""if dr.hovered then oK=0.8;oL=";stroke:white"end;jF[#jF+1]=de([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dr.width,dr.height,dr.x,dr.y,jz,oK,oL)jF[#jF+1]=gJ(dr.x+dr.width/2,dr.y+dr.height/2+5,dr.label,"txt txtmid pdim")end end end;local function oM(jF)local function oN(jF,oO,hover,hk,hl,fe,oP,oQ,oR,oS,oT,nX)if type(oS)=="function"then oS=oS(nX)end;if type(oT)=="function"then oT=oT(nX)end;jF[#jF+1]=de("<rect x='%f' y='%f' width='%f' height='%f' fill='",hk,hl,fe,oP)if oO then jF[#jF+1]=de("%s'",oQ)else jF[#jF+1]=oR end;if hover then jF[#jF+1]=de(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jF[#jF+1]=de(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fR(ac*0.5,0),fR(ad*0.5,0),fR(ae*0.5,0))end;jF[#jF+1]=" rx='5'></rect>"jF[#jF+1]=de("<text x='%f' y='%f' font-size='24' fill='",hk+fe/2,hl+oP/2+5)if oO then jF[#jF+1]="black"else jF[#jF+1]="white"end;jF[#jF+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oO then jF[#jF+1]=de("%s</text>",oS)else jF[#jF+1]=de("%s</text>",oT)end end;local oU=de("rgb(%d,%d,%d)'",fR(ac*0.1,0),fR(ad*0.1,0),fR(ae*0.1,0))local oV=de("rgb(%d,%d,%d)",fR(ac*0.8,0),fR(ad*0.8,0),fR(ae*0.8,0))local oW=oN;for dK,dr in pairs(iu)do local no=dr.disableName;local nn=dr.enableName;if type(no)=="function"then no=no(dr)end;if type(nn)=="function"then nn=nn(dr)end;if not dr.drawCondition or dr.drawCondition(dr)then oW(jF,dr.toggleVar(dr),dr.hovered,dr.x,dr.y,dr.width,dr.height,oV,oU,no,nn,dr)end end end;local oX=fR(ce/2,0)local oY=fR(cf/2,0)local jF={}if oZ then jF[#jF+1]=oZ end;cm.HUDPrologue(jF)if w then cm.UpdateHud(jF)else if A then cm.DrawVerticalSpeed(jF,cb)end;cm.DrawWarnings(jF)end;if iB and iC~="none"then cm.DrawSettings(jF)end;if radar_1 then cm.DrawRadarInfo()end;cm.HUDEpilogue(jF)jF[#jF+1]=de([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ce,cf)if bX~="empty"then cm.DisplayMessage(jF,bX)end;if ij()==0 and g=="virtual joystick"then if v then cm.DrawDeadZone(jF)end end;oJ(jF)if il()==0 then if ij()==1 and bW then if not o_ then oF()oM(jF)end;if not cs and not ct then local p0=table.concat(jF,"")jF={}jF[#jF+1]=de("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jF[#jF+1]=p0;jF[#jF+1]="</body>"cs=true;jF[#jF+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif ct then local p0=table.concat(jF,"")jF={}jF[#jF+1]=de("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jF[#jF+1]=p0;jF[#jF+1]="</body>"end;if not cs then jF[#jF+1]=de([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oX,oY,c2,c3)end else oE()end else if not bW and ij()==0 then oE()if d8>aw then if v then oD(jF)end end elseif bW and(not o_ or not i)then oF()oM(jF)end;jF[#jF+1]=de([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oX,oY,c2,c3)end;jF[#jF+1]=[[</svg></body>]]p1=table.concat(jF,"")end;function n_.TenthTick()local function p2()local p3=a.createData;local p4=a.createWidget;p5=a.createWidgetPanel("Interplanetary Helper")p6=p4(p5,"value")p7=p3('{"label": "Target Planet", "value": "N/A", "unit":""}')fP(p7,p6)p8=p4(p5,"value")p9=p3('{"label": "distance", "value": "N/A", "unit":""}')fP(p9,p8)gi=p4(p5,"value")gh=p3('{"label": "Travel Time", "value": "N/A", "unit":""}')fP(gh,gi)gg=p4(p5,"value")gf=p3('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fP(gf,gg)gk=p4(p5,"value")gj=p3('{"label": "Target Altitude", "value": "N/A", "unit":""}')fP(gj,gk)gc=p4(p5,"value")gb=p3('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ga=p4(p5,"value")g9=p3('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g8=p4(p5,"value")g7=p3('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g6=p4(p5,"value")g5=p3('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ge=p4(p5,"value")gd=p3('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c9 then fP(gb,gc)fP(g9,ga)fP(g7,g8)fP(g5,g6)fP(gd,ge)end end;local function pa()gI(p5)p5=nil end;cm.DrawTanks()if db then cm.DrawShield()end;if bh~="None"then if p5==nil then p2()end;if bh~=nil then local mA;local pb=g1~=nil;local pc=0.5*bs/c1:getGravity(c1.center+vec3(0,0,1)*c1.radius):len()pc=pc>1000000 and fR(pc/1000000,2).." kTons"or fR(pc/1000,2).." Tons"fO(p7,'{"label": "Target", "value": "'..bh..'", "unit":""}')if pb and not b1 then mA=(cJ-g1.position):len()else mA=(bi-cJ):len()end;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(cG)iF,iG=co.GetAutopilotBrakeDistanceAndTime(_)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(cG)iF,iG=co.GetAutopilotTBBrakeDistanceAndTime(_)end;local lg=ip(mA)fO(p9,'{"label": "distance", "value": "'..lg..'"}')fO(gh,'{"label": "Travel Time", "value": "'..iq(lv)..'", "unit":""}')lg=ip(b_)fO(gb,'{"label": "Cur Brake distance", "value": "'..lg..'"}')fO(g9,'{"label": "Cur Brake Time", "value": "'..iq(c0)..'", "unit":""}')lg=ip(iF)fO(g7,'{"label": "Max Brake distance", "value": "'..lg..'"}')fO(g5,'{"label": "Max Brake Time", "value": "'..iq(iG)..'", "unit":""}')fO(gf,'{"label": "Max Brake Mass", "value": "'..de("%s",pc)..'", "unit":""}')lg=ip(gl)fO(gj,'{"label": "Target Orbit", "value": "'..lg..'"}')if c9 and not pd then a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)pd=true;if not cM and t and(b3 or b6 or c7)then co.cmdThrottle(1)aZ=false;bP=false end end;if not c9 and pd then if fO(g5,g6)==1 then fP(g5,g6)end;if fO(g7,g8)==1 then fP(g7,g8)end;if fO(g9,ga)==1 then fP(g9,ga)end;if fO(gb,gc)==1 then fP(gb,gc)end;if fO(gd,ge)==1 then fP(gd,ge)end;pd=false end end else pa()end;if warpdrive~=nil then local pe=ih(warpdrive.getData())if pe.destination~="Unknown"and pe.distance>400000 then if not iT then warpdrive.show()iT=true end elseif iT then warpdrive.hide()iT=false end end end;function n_.OneSecondTick()local function pf()local js=bH()local kR=cG;local pg=js-iR;if kR>1.38889 then kR=kR/1000;local ph=kR*(js-iR)bl=bl+ph;iO=iO+ph end;iP=iP+pg;bm=bm+pg;iR=js end;local function pi(jF)local pj=0;iH=""local pk=is;local pl=0;local pm=0;local pn=0;local jx=0;local jy=""local po=b.getElementHitPointsById;local pp=b.getElementMaxHitPointsById;local pq={}for dF in pairs(ir)do local pr=0;local ps=0;ps=pp(ir[dF])pr=po(ir[dF])pl=pl+pr;if pr<ps then if pr==0 then pn=pn+1 else pm=pm+1 end;if iS and#pq==0 then fT=vec3(b.getElementPositionById(ir[dF]))local hk=fT.x;local hl=fT.y;local hm=fT.z;table.insert(pq,b.spawnArrowSticker(hk,hl,hm+1,"down"))table.insert(pq,b.spawnArrowSticker(hk,hl,hm+1,"down"))b.rotateSticker(pq[2],0,0,90)table.insert(pq,b.spawnArrowSticker(hk+1,hl,hm,"north"))table.insert(pq,b.spawnArrowSticker(hk+1,hl,hm,"north"))b.rotateSticker(pq[4],90,90,0)table.insert(pq,b.spawnArrowSticker(hk-1,hl,hm,"south"))table.insert(pq,b.spawnArrowSticker(hk-1,hl,hm,"south"))b.rotateSticker(pq[6],90,-90,0)table.insert(pq,b.spawnArrowSticker(hk,hl-1,hm,"east"))table.insert(pq,b.spawnArrowSticker(hk,hl-1,hm,"east"))b.rotateSticker(pq[8],90,0,90)table.insert(pq,b.spawnArrowSticker(hk,hl+1,hm,"west"))table.insert(pq,b.spawnArrowSticker(hk,hl+1,hm,"west"))b.rotateSticker(pq[10],-90,0,90)table.insert(pq,ir[dF])end elseif iS and#pq>0 and pq[11]==ir[dF]then for jr in pairs(pq)do b.deleteSticker(pq[jr])end;pq={}end end;pj=math.ceil(pl/pk*100)if pj<100 then jF[#jF+1]=gJ(0,0,"","pbright txt")jx=bI(pj*2.55)jy=de("rgb(%d,%d,%d)",255-jx,jx,0)if pj<100 then jF[#jF+1]=gJ("50%",1035,"Elemental Integrity: "..pj.."%","txtbig txtmid","fill:"..jy)if pn>0 then jF[#jF+1]=gJ("50%",1055,"Disabled Modules: "..pn.." Damaged Modules: "..pm,"txtbig txtmid","fill:"..jy)elseif pm>0 then jF[#jF+1]=gJ("50%",1055,"Damaged Modules: "..pm,"txtbig txtmid","fill:"..jy)end end end end;local function pt()if ig then if iI==nil and(d3~=nil or bk)then _autoconf.displayCategoryPanel(ig,weapon_size,"Weapons","weapon",true)iI=_autoconf.panels[_autoconf.panels_size]elseif iI~=nil and d3==nil and not bk then gI(iI)iI=nil end end end;cY=b.getPlayersOnBoard()cZ=b.getDockedConstructs()local jF={}pf()if s then pi(jF)end;pt()cm.UpdatePipe()cm.ExtraData(jF)iQ=table.concat(jF,"")end;function n_.AnimateTick()ct=true;cs=false;c2=0;c3=0;c.stopTimer("animateTick")end;function n_.MsgTick()local jF={}cm.DisplayMessage(jF,"empty")bX="empty"c.stopTimer("msgTick")bY=3 end;function n_.ButtonSetup()nz()nE()iu=iv end;if pu then for dF,dr in pairs(pu)do n_[dF]=dr end end;return n_ end;local function pv(d,b,c,a,e,vBooster,hover,pw,antigrav,warpdrive,dbHud_1,radar_1,eU,bI,bJ,ij,eP,bH,df,ik,fO,il,dh,fR,fQ,im,di,ip,iq,px,ih,de,fP)local py={}local pz=false;local pA=0;local pB=0;local pC=0;local pD=bH()local pE=0;local pF=0;local pG=0;local pH=0;local pI=false;local pJ=false;local pK=false;local pL=nil;local pM=0;local iE=55;local pN=nil;local pO=false;local pP=false;local pQ=false;local pR=0;local pS=0;local pT=0;local pU=0;local pV=0;local pW={VectorToTarget=false}local pX=vec3(b.getConstructWorldOrientationUp())local pY=nil;local pZ=0;local p_=-1;local q0=-1;local q1=false;local q2=false;local q3=0;local q4=false;local q5=false;local q6=false;local q7=false;local q8=""local q9=false;local qa=false;local qb=""local qc=false;local qd=0;local qe=vec3({13771471,7435803,-128971})local qf=18000000;local qg=500000;local qh,qi=math.huge;local qj;local function qk(ql)qh=vec3(ql):dist(qe)if qh<qf then return true,eU(qh-qf)end;qi=vec3(ql):dist(vec3(kh.center))if qi<qg then qj=true else qj=false end;if eU(qi-qg)<eU(qh-qf)then return qj,eU(qi-qg)else return qj,eU(qh-qf)end end;local function qm(fl)local qn=bd;if not b1 then qn=0 end;local qo=bq;if c9 then if bs and bs>0 then qo=bs else return 0,0 end end;return ck.computeDistanceAndTime(fl,qn,cc,0,0,qo-bf*cc)end;local function qp(fl)local qn=bd;if not b1 then qn=0 end;return ck.computeDistanceAndTime(fl,qn,cc,d:maxForceForward(),a1,bq-bf*cc)end;local function qq(qr,qs,qt)qs=qs:project_on_plane(qr)qt=qt:project_on_plane(qr)return eP(qs:cross(qt):dot(qr),qs:dot(qt))end;local function qu()local function qv()local qw=-1;local qx=-1;if vBooster then qw=vBooster.getDistance()end;if hover then qx=hover.getDistance()end;if qw~=-1 and qx~=-1 then if qw<qx then return qw else return qx end elseif qw~=-1 then return qw elseif qx~=-1 then return qx else return-1 end end;local qy=qv()local qz=-1;if antigrav and antigrav.getState()==1 and not q and cG<iE then local qA=eU(cb-antigrav.getBaseAltitude())if qA<50 then return qA end end;if pw then qz=pw.getDistance()end;if qy~=-1 and qz~=-1 then if qy<qz then return qy else return qz end elseif qy~=-1 then return qy else return qz end end;local function qB(kh,eG,qC)local function qD(qE,dR)local eM=vec3(dR)if qE.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=qE.systemId},dT)end;local eN=eM-qE.center;local c4=eN:len()local dZ=c4-qE.radius;local dX=0;local dY=0;if not di(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=math.deg(dX),longitude=math.deg(dY),altitude=dZ,id=qE.id,systemId=qE.systemId},dT)end;local qF=qD(kh,eG)qF="::pos{"..qF.systemId..","..qF.id..","..qF.latitude..","..qF.longitude..","..qF.altitude.."}"if qC then return qF else q6=qF;return true end end;local function qG(qH,qI,qJ)local function qK(qH,ep)qH=vec3(qH)ep=vec3(ep):normalize()local dA=qH*ep;return dA.x+dA.y+dA.z end;local qL=0.001;local qM=1;if not c9 or not cv or c8~=-1 or cG<iE then if qJ==nil then qJ=aQ end;if qI==nil then qI=qL end;qH=vec3(qH):normalize()local qN=vec3()-qH;local qO=-qK(qN,b.getConstructWorldOrientationRight())*qM;local qP=-qK(qN,b.getConstructWorldOrientationUp())*qM;if pB==0 then pB=qO/2 end;if pC==0 then pC=qP/2 end;if eU(qO)<0.1 then pS=pS-qO*2 else pS=pS-(qO+(qO-pB)*qJ)end;if eU(qP)<0.1 then pR=pR+qP*2 else pR=pR+qP+(qP-pC)*qJ end;pB=qO;pC=qP;if eU(qO)<qI and eU(qP)<qI then return true end;return false elseif cv and c8==-1 then qH=cF;if qJ==nil then qJ=aQ end;if qI==nil then qI=qL end;qH=vec3(qH):normalize()local qN=cC-qH;local qO=-qK(qN,b.getConstructWorldOrientationRight())*qM;local qP=-qK(qN,b.getConstructWorldOrientationUp())*qM;if pB==0 then pB=qO/2 end;if pC==0 then pC=qP/2 end;if eU(qO)<0.1 then pS=pS-qO*5 else pS=pS-(qO+(qO-pB)*qJ)end;if eU(qP)<0.1 then pR=pR+qP*5 else pR=pR+qP+(qP-pC)*qJ end;pB=qO;pC=qP;if eU(qO)<qI and eU(qP)<qI then return true end;return false end end;function py.clearAll()b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"a_=false;b0=false;cS=nil;b3=false;b6=false;b4=false;b5=false;b7=false;bV=false;pP=false;c5=false;c6=false;pQ=false;cu=p;bo=false;b2=false;cd=false;br=nil;bx=false;d6=false;d7=nil end;function py.GetAutopilotBrakeDistanceAndTime(fl)return qm(fl)end;function py.GetAutopilotTBBrakeDistanceAndTime(fl)return qp(fl)end;function py.showWayPoint(kh,eG,qC)return qB(kh,eG,qC)end;function py.APTick()local qQ=a.getMouseWheel()if qQ>0 then co.changeSpd()elseif qQ<0 then co.changeSpd(true)else pO=true end;q3=il()if q6 then a.setWaypoint(q6)q6=false end;if q9 then antigrav.setBaseAltitude(q9)q9=false end;if q7 then fO(q7,q8)q7=false;q8=""end;if q0~=-1 then co.cmdCruise(q0,q1)q1=false;q0=-1 end;if pY~=nil then if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ik:getTargetSpeed(axisCommandId.longitudinal)~=pY then ik:setTargetSpeedCommand(axisCommandId.longitudinal,pY)else pY=nil end end;if p_~=-1 then co.cmdThrottle(p_,q1)q1=false;p_=-1 end;if q2 then cq.landingGear()q2=false end;if qa then co.ToggleAutopilot()end end;function py.ToggleIntoOrbit()cz=false;pG=nil;pH=nil;pM=0;if not c9 then if bx then fQ("orOff","AP")bx=false;pI=false;pL=nil;cu=p;if b3 then b3=false;b5=false end;pW.VectorToTarget=false;pW.AutopilotAlign=false;pK=false elseif cT then fQ("orOn","AP")bx=true;cu=true;if pL==nil then pL=kh end;if b3 then b3=false;b5=false end else bX="Unable to engage auto-orbit, not near a planet"end else bx=false;pI=false;pL=nil;cu=p;if b3 then b3=false end;pW.VectorToTarget=false;pW.AutopilotAlign=false;pK=false end end;function py.ToggleVerticalTakeoff()b3=false;if b7 then lo=true;b6=false;b5=false;b4=true;cu=true;bU=0;if c9 and c8==-1 then b4=false;b3=true;bU=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q0=bI(cw)end else cz=false;bk=false;d.control.retractLandingGears()ik:setTargetGroundAltitude(X)aZ="VTO Takeoff"end;b7=not b7 end;function py.checkLOS(qH)local lt,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,qH,function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local lu=eE;if eF~=nil and eE~=nil then lu=math.min(eF,eE)end;if lu~=nil then return lt,lu else return nil,nil end end;function py.ToggleAutopilot()local function qR(bv)cU=false;bo=not bo;if bo then b2=false;if not b3 and not bv then co.ToggleAltitudeHold()end end;lx="Proceeding to Waypoint"end;local function qS(gu)if gu then for K,dF in pairs(cP)do if dF.name and dF.name==gu then return K end end else return 0 end end;local qT=false;if bK-pF<1.5 and c9 then if not cB then if c9 then b8=kh.spaceEngineMinAltitude-0.01*kh.noAtmosphericDensityAltitude;fQ("11","EP")pF=-1;if b1 or bo or bx then return end else bX="No space engines detected, Orbital Hop not supported"return end elseif kh.hasAtmosphere then if c9 then b8=kh.noAtmosphericDensityAltitude+T;fQ("orH","OH")end;pF=-1;if b1 or bo or bx then return end end else pF=bK end;qU=false;if(bj>0 or#bD>0)and not b1 and not bo and not c6 and not bx then if 0.5*d:maxForceForward()/b.g()<cc then bX="WARNING: Heavy Loads may affect autopilot performance."bY=5 end;if#bD>0 and not c7 then bj=qS(bD[1])cn.UpdateAutopilotTarget()bX="Route Autopilot in Progress"local qN=g1.position-cJ;local qV=qN:project_on_plane(cH):len()if qV>50000 and g1.planetname==kh.name then qT=true end end;cn.UpdateAutopilotTarget()co.showWayPoint(c1,bi)if g1~=nil then if g1.agg and not q and antigrav then if not cL then co.ToggleAntigrav()end;bt=g1.agg end;br=nil;bv=g1.planetname=="Space"if bv then fQ("apSpc","AP")if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end elseif kh.name==g1.planetname then lo=true;if c9 then if not bo then fQ("vtt","AP")qR(bv)if qT then b8=kh.noAtmosphericDensityAltitude+T end end else fQ("apOn","AP")if not(c1.name==kh.name and cb<gl*1.5)then cz=false;b1=true elseif not c9 then if bx then co.ToggleIntoOrbit()end;cy=kh.noAtmosphericDensityAltitude+T;pK=true;pW.AutopilotAlign=true;pW.VectorToTarget=true;pI=false;if not bx then co.ToggleIntoOrbit()end end end else fQ("apP","AP")a_=false;b0=false;if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end end elseif not c9 then if g1==nil and(c1.name==kh.name and cT)and not bx then qW=false;cz=false;pI=false;co.ToggleIntoOrbit()else fQ("apP","AP")b1=true;a_=false;b0=false;ba=false;bV=false;b3=false;b4=false;b6=false;b5=false;pP=false;br=nil;qW=false end else fQ("apP","AP")c6=true;co.ToggleAltitudeHold()end;qa=false else fQ("apOff","AP")co.ResetAutopilots(1)if qa==2 then qa=true end end end;function py.routeWP(qX,qY,qZ)if qZ then if qZ==1 then bD={}bD=im(bD,bC)if#bD>0 then bX="Route Loaded"else bX="No Saved Route found on Databank"end;return bD else bC={}bC=im(bC,bD)bX="Route Saved"px()return end end;if qX then return bD end;if qY then bD={}bX="Current Route Cleared"else bD[#bD+1]=g1.name;bX="Added "..g1.name.." to route. "end;return bD end;function py.cmdThrottle(dG,q_)if ik:getAxisCommandType(0)~=axisCommandType.byThrottle and not q_ then d.control.cancelCurrentControlMasterMode()end;ik:setThrottleCommand(axisCommandId.longitudinal,dG)bL=df(fR(dG*100,0)/100,-1,1)pY=nil end;function py.cmdCruise(dG,q_)if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not q_ then d.control.cancelCurrentControlMasterMode()end;ik:setTargetSpeedCommand(axisCommandId.longitudinal,dG)pY=dG end;function py.ToggleLockPitch()if br==nil then fQ("lkPOn","LP")if not bW then br=cN else br=Q end;b5=false;b3=false;b4=false else fQ("lkPOff","LP")br=nil end end;function py.ToggleAltitudeHold()if bK-pE<1.5 then if kh.hasAtmosphere then if c9 then b8=kh.spaceEngineMinAltitude-0.01*kh.noAtmosphericDensityAltitude;fQ("11","EP")else if cT then b8=kh.noAtmosphericDensityAltitude+T;cy=b8;pK=true;if not bx then co.ToggleIntoOrbit()end;pI=true end end;pE=-1;if b3 or bx or b7 then return end end else pE=bK end;if cT and not c9 then cy=cb;pK=true;pI=true;co.ToggleIntoOrbit()if bx then pE=bK else pE=0 end;return end;b3=not b3;b4=false;b6=false;if b3 then b1=false;b0=false;a_=false;bV=false;cu=true;br=nil;cz=false;if c8~=-1 and cG<20 then if bk then cq.landingGear()end;fQ("lfs","LS")b5=true;if pE>-1 then b8=cb+W end;aZ="ATO Hold"ik:setTargetGroundAltitude(X)if aY and cK then co.ToggleVerticalTakeoff()end else fQ("altOn","AH")b5=false;if pE>-1 then if cT then b8=cb end end;if b7 then co.ToggleVerticalTakeoff()end end;if cL and not q then local r0=antigrav.getBaseAltitude()if bo and g1.agg and g1.agg>cb then b8=g1.agg elseif b5 then b8=r0 end;if eU(cb-r0)<100 and cG<20 then b8=r0;aZ="AGG Hold"p_=0 end end;if c6 then b8=200000 end else fQ("altOff","AH")if bx then co.ToggleIntoOrbit()end;if b7 then co.ToggleVerticalTakeoff()end;cu=p;b5=false;bo=false;pE=0 end end;function py.ResetAutopilots(py)if py then c6=false;b1=false;ba=false;pP=false;b8=cb;qU=false;d6=false;be="Aligning"end;bo=false;b5=false;b6=false;b0=false;b4=false;d7=nil;r1=false;cS=nil;d6=false;if not cL then b3=false;br=nil end;if b7 then co.ToggleVerticalTakeoff()end;if bx then co.ToggleIntoOrbit()end;cu=p;c5=false;c7=false;bU=0 end;function py.BrakeToggle(r2)if not aZ then if r2 then aZ=r2 else aZ=true end else aZ=false end;if b4 then b4=false;cu=p;d6=false end;if aZ then fQ("bkOn","B",1)co.ResetAutopilots()else fQ("bkOff","B",1)end end;function py.BeginReentry()if b6 then bX="Re-Entry cancelled"fQ("reOff","RE")b6=false;cu=p;b3=false elseif not kh.hasAtmosphere then bX="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bY=5 elseif not pQ then b6=true;if ik:getAxisCommandType(0)~=r3.cruise then d.control.cancelCurrentControlMasterMode()end;cu=true;aZ=false;bX="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cw;fQ("par","RE")else b6=true;b3=true;cu=true;aZ=false;b8=kh.surfaceMaxAltitude+Z;if b8>kh.spaceEngineMinAltitude then b8=kh.spaceEngineMinAltitude-0.01*kh.noAtmosphericDensityAltitude end;local r4=ip(b8)bX="Beginning Re-entry.  Target speed: "..cw.." Target Altitude: "..r4;fQ("glide","RE")q0=bI(cw)end;b5=false end;function py.ToggleAntigrav()if antigrav and not q then if cL then fQ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bt==nil then bt=cb end;if bt<1000 then bt=1000 end;fQ("aggOn","AG")antigrav.activate()antigrav.show()end end end;function py.changeSpd(r5)local r6=1;if r5 then r6=-1 end;if not bW then if t and not o_ and pO then local r7=bL;bL=fR(df(bL+r6*aC/100,-1,1),2)if bL>=0 and r7<0 then bL=0;pO=false end elseif o_ then if c9 or b6 then cw=df(cw+r6*aC,0,U)elseif b1 then _=df(_+r6*aC/3.6*100,0,da-0.2)end else ik:updateCommandFromActionStart(axisCommandId.longitudinal,r6*aC/10)end else if b1 or bo or c6 or bx then cX=cX+1*r6*-1;if cX>#cP then cX=1 end;if cX<1 then cX=#cP end else if not r5 then r6=1 else r6=nil end;cn.adjustAutopilotTargetIndex(r6)end end end;function py.TenthTick()local function r8()if not b1 then if g1==nil or g1.planetname~=kh.name then r9=(c1.center-cJ):len()else r9=(g1.position-cJ):len()end end;local fl=cG;local ra=c.getThrottle()/100;if t then ra=bL end;local rb,rc=ck.computeDistanceAndTime(cG,_,cc,d:maxForceForward()*ra,a1,0)local b_,c0;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(_)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(_)end;local dK,rd;if not b2 and fl>0 then dK,rd=co.GetAutopilotBrakeDistanceAndTime(fl)else dK,rd=co.GetAutopilotTBBrakeDistanceAndTime(fl)end;local re=0;local rf=0;if bc or not b1 and fl>5 then rf=ck.computeTravelTime(fl,0,r9)elseif b_+rb<r9 then re=r9-(b_+rb)rf=ck.computeTravelTime(8333.0556,0,re)else local rg=(r9-b_)/rb;rb=r9-b_;rc=rc*rg end;if g1~=nil and g1.planetname==kh.name and not b1 then return rf elseif bb then return rd elseif bc then return rf+rd else return rc+c0+rf end end;cQ,cR=qk(cJ)da=b.getMaxSpeed()lv=r8()local function rh(oe,ri)if oe==nil then oe=b.g()end;oe=fR(oe,5)if ri~=nil and ri or(pN==nil or pN~=oe)then local fl=cE:len()local rj=ih(c.getData()).maxBrake;if rj~=nil and rj>0 and c9 then rj=rj/df(fl/100,0.1,1)rj=rj/ca;if ca>0.10 then if bs then bs=(bs+rj)/2 else bs=rj end end end;if rj~=nil and rj>0 then bq=rj end;pN=oe end end;rh(nil,true)end;function py.SatNavTick()if not r then return end;qb=dbHud_1.getStringValue("SPBAutopilotTargetName")if qb~=nil and qb~=""and qb~="SatNavNotChanged"then local dA=ih(dbHud_1.getStringValue("SavedLocations"))if dA~=nil then bn=dA;local gs=-1;local gy;for dF,dr in pairs(bn)do if dr.name and dr.name=="SatNav Location"then gs=dF;break end end;if gs~=-1 then gy=bn[gs]gs=-1;for dF,dr in pairs(e[0])do if dr.name and dr.name=="SatNav Location"then gs=dF;break end end;if gs>-1 then e[0][gs]=gy end;cn.UpdateAtlasLocationsList()bX=gy.name.." position updated"end end;for K=1,#cP do if cP[K].name==qb then bj=K;a.print("Index = "..bj.." "..cP[K].name)cn.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function py.onFlush()local function rk(rl,rm)local rn=vec3()local ro=vec3()if rl==axisCommandId.longitudinal then rn=vec3(b.getConstructOrientationForward())ro=cC elseif rl==axisCommandId.vertical then rn=vec3(b.getConstructOrientationUp())ro=pX elseif rl==axisCommandId.lateral then rn=vec3(b.getConstructOrientationRight())ro=cD else return vec3()end;local rp=vec3(b.getWorldGravity())local rq=rp:dot(ro)local rr=vec3(b.getWorldAirFrictionAcceleration())local rs=rr:dot(ro)local rt=cE:dot(rn)local ru=rm*constants.kph2m;if rv==nil then rv=pid.new(10,0,10.0)end;rv:inject(ru-rt)local rw=rv:get()local rx=(rw-rs-rq)*ro;return rx end;local function ry(rl,rm)local rn=vec3()local ro=vec3()if rl==axisCommandId.longitudinal then rn=vec3(b.getConstructOrientationForward())ro=cC elseif rl==axisCommandId.vertical then rn=vec3(b.getConstructOrientationUp())ro=pX elseif rl==axisCommandId.lateral then rn=vec3(b.getConstructOrientationRight())ro=cD else return vec3()end;local rp=vec3(b.getWorldGravity())local rq=rp:dot(ro)local rr=vec3(b.getWorldAirFrictionAcceleration())local rs=rr:dot(ro)local rt=cE:dot(rn)local ru=rm*constants.kph2m;if rz==nil then rz=pid.new(10,0,10.0)end;rz:inject(ru-rt)local rw=rz:get()local rx=(rw-rs-rq)*ro;return rx end;local function rA(rB,jI,fY)local rC=rB:cross(fY):normalize_inplace()local ku=math.acos(df(rC:dot(-jI),-1,1))*constants.rad2deg;if rC:cross(-jI):dot(fY)<0 then ku=-ku end;return ku end;local function rD()if cV and not b4 then local en=cV[1]local hJ,hK=cV[2],cV[3]local rE=math.min(hJ,hK or hJ)local rF=rE/cG;local rG=b5 and(cG<42 or c8~=-1)local rH=b3 or bo or br or b1;if rH and not rG and(b_*1.5>rE or rF<1)then aZ="Collision"bD={}p_=0;if b3 then co.ToggleAltitudeHold()end;if br then co.ToggleLockPitch()end;bX="Autopilot Cancelled due to possible collision"a.print(en.name.." COLLISION "..iq(rF).." / "..ip(rE,2))co.ResetAutopilots(1)lo=true;if c9 then b4=true end;cu=true end;if rF<11 then cU=en.name.." COLLISION "..iq(rF).." / "..ip(rE,2)else cU=en.name.." collision "..iq(rF)end;if rF<6 then fQ("alarm","AL",2)end else cU=false end end;if antigrav and not q then if not cL and antigrav.getBaseAltitude()~=bt then q9=bt end end;if d9 then d:setEngineForceCommand('hover',vec3(),1)d9=false end;cM=ik:getAxisCommandType(0)==axisCommandType.byThrottle;aM=math.max(aM,0.01)aN=math.max(aN,0.01)aH=math.max(aH,0.01)aL=math.max(aL,0.01)aO=math.max(aO,0.01)aP=math.max(aP,0.01)aG=math.max(aG,0.01)local rI=df(bR+pR+a.getControlDeviceForwardInput(),-1,1)local rJ=df(bS+pT+a.getControlDeviceYawInput(),-1,1)local rK=df(bT+pS-a.getControlDeviceLeftRightInput(),-1,1)local rL=aZ and 1 or 0;cH=vec3(b.getWorldVertical())if cH==nil or cH:len()==0 then cH=(kh.center-cJ):normalize()end;pX=vec3(b.getConstructWorldOrientationUp())cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cF=vec3(b.getWorldVelocity())cE=vec3(b.getVelocity())cJ=vec3(b.getConstructWorldPos())cc=b.getConstructMass()cG=vec3(cF):len()cI=-cH:dot(cF)cO=getRoll(cH,cC,cD)local rM=cO/180*math.pi;local rN=math.cos(rM)local rO=math.sin(rM)cN=rA(cH,cC,cD*rN+pX*rO)local rP=cF:normalize()local rQ=eU(cO)local rR=utils.sign(cO)local rS=vec3(b.getWorldAngularVelocity())local rT=rI*aM*cD+rJ*aH*cC+rK*aN*pX;if cu==true and cH:len()>0.01 then local rU=eU(pU-cO)if((b0 or b6 or b4 or c5 or b3 or bx)and rU>0 or c9 and rU<aI and p)and rJ==0 and eU(cN)<85 then local rV=pU;local rW=aG;if not c9 then rW=rW/4;pU=0;rV=0 end;if rX==nil then rX=pid.new(rW*0.01,0,rW*0.1)end;rX:inject(rV-cO)local rY=rX:get()rT=rT+rY*cC end end;local rZ=1;local r_=0;local s0=1;bM=0;ca=bJ()c9=false or cb<kh.noAtmosphericDensityAltitude and ca>0.00001;cb=b.getAltitude()c8=qu()bK=bH()pD=bK;if bk and c8>-1 and c8-3<Y then if ik.targetGroundAltitudeActivated then ik:deactivateGroundEngineAltitudeStabilization()end end;if radar_1 then qc=not qc;if qc then cp.UpdateRadar()end;if E then rD()end end;if antigrav then cL=antigrav.getState()==1 end;local s1=1;local s2=1;local s3=bK-pD;local s4=-math.deg(qq(pX,cF,cC))local s5=math.deg(qq(cD,cF,cC))local gn=cH*-1;cv=c9 and s4<-L or s4>L or s5<-M or s5>M;local s6=a.getMouseDeltaX()local s7=a.getMouseDeltaY()if qd then local s8=bH()-qd;s6=s6*s8/0.016;s7=s7*s8/0.016 end;qd=bH()if o and not bW then s7=-s7 end;pS=0;pT=0;pR=0;fU=cj[0]kh=fU:closestBody(b.getConstructWorldPos())s9=cl(kh)fp=s9:orbitalParameters(b.getConstructWorldPos(),cF)if cb==0 then cb=(cJ-kh.center):len()-kh.radius end;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;local oe=kh:getGravity(b.getConstructWorldPos()):len()*cc;pU=0;local sa=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if q3==0 then if ij()==1 and bW then if not cs then c2=df(c2+s6/2,-ce/2,ce/2)c3=df(c3+s7/2,-cf/2,cf/2)end else c2=0;c3=0 end else c2=df(c2+s6/2,-ce/2,ce/2)c3=df(c3+s7/2,-cf/2,cf/2)d8=dh(c2*c2+c3*c3)if not bW and ij()==0 then local kD,kE=1,1;if bF=="SCOPE"then kD,kE=d0/90,d0/90 end;if g=="virtual joystick"then if d8>aw then pS=pS-df(eU(c2)-aw,0,ce/2)*utils.sign(c2)*aE*kD;pR=pR-df(eU(c3)-aw,0,cf/2)*utils.sign(c3)*aF*kE end else c2=0;c3=0;if g=="mouse"then pR=(-utils.smoothstep(s7,-100,100)+0.5)*2*s1;pS=(-utils.smoothstep(s6,-100,100)+0.5)*2*s2 end end end end;local sb=cG>27777;if cG>V/3.6 and not c9 and not b1 and not sb then bX="Space Speed Engine Shutoff reached"p_=0 end;if not sb and sc then if not aZ then co.BrakeToggle()end;if b1 then co.ResetAutopilots(1)end;p_=0 end;sc=sb;if ca>0.09 then if cG>cw/3.6 and not t and not pz then aZ="SpdLmt"pz=true elseif not t and pz then if cG<cw/3.6 then aZ=false;pz=false end end end;if b0 then if c5 then aZ=false;local sd=false;if g1 and c5==true then sd=qG(g1.position-cJ,0.1)else sd=qG(vec3(cF),0.01)end;cu=true;if sd then q0=bI(cw)if(eU(cO)<2 or eU(cN)>85)and cG>=cw/3.6-1 then aZ=false;b0=false;if c5~=2 then pQ=true end;if c5==true then c7=true end;c5=false;b1=false;co.BeginReentry()end elseif c9 and t then p_=1 end elseif cG>iE then qG(vec3(cF),0.01)end end;if a_ then if c9 then a_=false elseif cG>iE then qG(-vec3(cF))end end;if not b0 and c5 and not bx then if not c9 then if c5~=2 then pQ=true end;co.BeginReentry()c5=false;c7=true else c5=false;if not qa then qa=true end end end;if c7 and g1 and(cb<b8+250 and cb>b8-250)and cG*3.6>cw-250 and eU(cI)<25 and ca>=0.1 and(g1.position-cJ):len()>2000+cb then if not qa then qa=true end;c7=false end;if b7 then cu=true;local se=b8;if cI<-30 then bX="Unable to achieve lift. Safety Landing."bU=0;cu=p;b7=false;b4=true elseif not q and cL or b8<kh.spaceEngineMinAltitude then if cL then se=antigrav.getBaseAltitude()end;if cb<se-100 then pV=0;bU=15;aZ=false elseif cI>0 then aZ="VTO Limit"bU=0 elseif cI<-30 then aZ="VTO Fall"bU=15 elseif cb>=se then if cL then if b1 or bo then co.ToggleVerticalTakeoff()else aZ="VTO Complete"b7=false end;bX="Takeoff complete. Singularity engaged"fQ("aggLk","AG")else aZ=false;bX="VTO complete. Engaging Horizontal Flight"fQ("vtoc","VT")co.ToggleVerticalTakeoff()end;bU=0 end else if ca>0.08 then pV=0;aZ=false;bU=20 elseif ca<0.08 and c9 then aZ=false;if cA then pV=0;bU=20 else bU=0;pV=36;q0=3500 end else cu=p;bx=true;cz=false;sf=false;pI=false;pG=nil;pH=nil;if pL==nil then pL=kh end;cy=se;pK=true;b7=false end end;if pV~=nil then if sg==nil then sg=pid.new(2*0.01,0,2*0.1)end;local sh=df(pV-cN,-M*0.80,M*0.80)sg:inject(sh)local si=df(sg:get(),-1,1)pR=si end end;if bx then local function sj()if fp.periapsis.altitude>=cy*0.99 and fp.apoapsis.altitude>=cy*0.99 and fp.periapsis.altitude<fp.apoapsis.altitude and fp.periapsis.altitude*1.05>=fp.apoapsis.altitude and eU(cy-cb)<1000 then return true else return false end end;local qN;local sk=false;local sl=ip(cy)if pL==nil then pL=kh;if bo then pL=c1 end end;if not pK then cy=bI(pL.radius+pL.surfaceMaxAltitude+T)if pL.hasAtmosphere then cy=bI(pL.radius+pL.noAtmosphericDensityAltitude+T)end;pK=true end;if pW.VectorToTarget and g1 then qN=g1.position-cJ end;local sm,sn=cl(pL):escapeAndOrbitalSpeed((cJ-pL.center):len()-pL.radius)local so=cO;if not pI then local sp=false;local sq=false;p_=0;pH=0;cx="Aligning to orbital path - OrbitHeight: "..sl;if pW.VectorToTarget then qG(qN:normalize():project_on_plane(cH))sk=cC:dot(qN:project_on_plane(pX):normalize())>0.95 else qG(cF)sk=s4<0.5;if cG<150 then sk=true end end;pR=0;pG=0;if cN<=pG+2 and cN>=pG-2 then sp=true else sp=false end;if so<=pH+2 and so>=pH-2 then sq=true else sq=false end;if sp and sq and sk then pG=nil;pH=nil;pI=true end else if pW.VectorToTarget then qG(qN:normalize():project_on_plane(cH))elseif cG>150 then qG(cF)end;pR=0;if pW.VectorToTarget and g1 then local b_,dK=ck.computeDistanceAndTime(cG,cw/3.6,cc,0,0,bq)if cz and qN:len()>15000+b_+cb then cx="Orbiting to Target"if cb-100<=pL.noAtmosphericDensityAltitude or lv>fp.timeToPeriapsis and fp.periapsis.altitude<pL.noAtmosphericDensityAltitude or not sj()and fp.eccentricity>0.1 then bX="Re-Aligning Orbit"cz=false end elseif cz or qN:len()<15000+b_+cb then bX="Orbit complete, proceeding with reentry"fQ("orCom","OB")bi=g1.position;pQ=true;c7=true;pW.VectorToTarget,pW.AutopilotAlign=false,false;co.ToggleIntoOrbit()co.BeginReentry()return end end;if fp.periapsis~=nil and fp.apoapsis~=nil and fp.eccentricity<1 and cb>cy*0.9 and cb<cy*1.4 then if fp.apoapsis~=nil then if sj()or cz then if cz then aZ=false;p_=0;pG=0;if not pW.VectorToTarget then bX="Orbit complete"fQ("orCom","OB")co.ToggleIntoOrbit()end else pM=pM+1;if pM>=2 then cz=true end end else cx="Adjusting Orbit - OrbitHeight: "..sl;pJ=true;q0=sn*3.6+1;local sr=cy-cb;if ss==nil then ss=pid.new(0.1,0,1*0.1)end;ss:inject(sr-cI*df(utils.smoothstep(2000-sr,-2000,2000)^6*10,1,10))pG=df(ss:get(),-60,60)end end else local st=2.75;local su=eU(fR(sm*st))local ot=su%50;if ot>0 then su=su-ot+50 end;aZ=false;if cb<cy*0.8 then cx="Escaping planet gravity - OrbitHeight: "..sl;pG=utils.map(cI,200,0,-15,80)elseif cb>=cy*0.8 and cb<cy*1.15 then cx="Approaching orbital corridor - OrbitHeight: "..sl;su=su*0.75;pG=utils.map(cI,100,-100,-15,65)elseif cb>=cy*1.15 and cb<cy*1.5 then cx="Approaching orbital corridor - OrbitHeight: "..sl;su=su*0.75;if cI<0 or pJ then pG=utils.map(cb,cy*1.5,cy*1.01,-30,0)else pG=utils.map(cb,cy*0.99,cy*1.5,0,30)end elseif cb>cy*1.5 then cx="Reentering orbital corridor - OrbitHeight: "..sl;pG=-65;local sv=utils.map(cI,-150,-400,1,0.55)su=su*sv end;q0=bI(su)end end;if pG~=nil then if sw==nil then sw=pid.new(1*0.01,0,5*0.1)end;local sx=pG-cN;sw:inject(sx)local sy=df(sw:get(),-0.5,0.5)pR=sy end end;if b1 and not c9 and not c5 then local function sz(hW,fp)a.print(hW)aZ=false;bb=false;b1=false;qU=false;be="Aligning"p_=0;pP=false;bX=hW;fQ("apCom","AP")if fp or c5 then if fp and gl~=nil and not c5 then if not cb or cb==0 then return end;cy=cb;pK=true end;co.ToggleIntoOrbit()end end;local sA,sB=bi,false;if g1 and g1.planetname~="Space"then ba=true;if not qU then local sC=(g1.position-c1.center):normalize()local sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()local sE=c1.center+sD*(c1.radius+gl)local sF=g1.position+(g1.position-c1.center):normalize()*(gl-c1:getAltitude(g1.position))if(cJ-sE):len()<(cJ-sF):len()then sA=sE else sA=sF;bd=0 end;bi=sA;co.showWayPoint(c1,bi)sB=true;qU=true end;bf=0 elseif g1 and g1.planetname=="Space"then if not qU then bf=0;sB=true;ba=true;qU=true;sA=g1.position+(cJ-g1.position):normalize()*R;bi=sA end elseif g1==nil then bf=0;if not qU then local sC=(cJ+cF*100000-c1.center):normalize()local sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()if sD:len()<1 then sC=(cJ+cC*100000-c1.center):normalize()sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()end;sA=c1.center+sD*(c1.radius+gl)bi=sA;qU=true;sB=true;ba=true;co.showWayPoint(c1,bi)end end;r9=(vec3(sA)-cJ):len()local lt,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,cF:normalize(),function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local lu=eE;if eF~=nil and eE~=nil then lu=math.min(eF,eE)end;if lu~=nil and lu<r9 and lt.name==c1.name then r9=lu end;local sd=true;local sG=(c1.center-(cJ+vec3(cF):normalize()*r9)):len()-c1.radius;local lg=ip(sG)q7=gd;q8='{"label": "Projected Altitude", "value": "'..lg..'"}'if cG>50 and b9 then local qN=vec3(sA)-cJ;local sH=df(math.deg(qq(pX,cF:normalize(),qN:normalize()))*cG/500,-90,90)local sI=df(math.deg(qq(cD,cF:normalize(),qN:normalize()))*cG/500,-90,90)if eU(sH)<20 and eU(sI)<20 then sH=sH*2;sI=sI*2 end;if eU(sH)<2 and eU(sI)<2 then sH=sH*2;sI=sI*2 end;local s4=-math.deg(qq(pX,cC,cF:normalize()))local s5=-math.deg(qq(cD,cC,cF:normalize()))if sJ==nil then sJ=pid.new(2*0.01,0,2*0.1)end;sJ:inject(sI-s5)local sK=df(sJ:get(),-1,1)pR=pR+sK;if sL==nil then sL=pid.new(2*0.01,0,2*0.1)end;sL:inject(sH-s4)local sM=df(sL:get(),-1,1)pS=pS+sM;sB=true;if eU(sH)>2 or eU(sI)>2 then if be~="Adjusting Trajectory"then be="Adjusting Trajectory"fQ("apAdj","AP")end else if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end end elseif b9 and cG<=50 then qG((sA-cJ):normalize())end;if sG<gl*1.5 then bd=cw/3.6;if g1==nil then dK,bd=cl(c1):escapeAndOrbitalSpeed(sG)end end;local b_,c0;if not b2 then b_,c0=qm(cG)else b_,c0=qp(cG)end;if b1 and not b9 and not bc and not bb then local lt,lu=co.checkLOS((bi-cJ):normalize())if c1.name~=kh.name then if lt~=nil and c1.name~=lt.name and lu<r9 then bX="Collision with "..lt.name.." in "..ip(lu).."\nClear LOS to continue."bY=5;q4=true else q4=false;bX=""end end end;if not q4 then if not bc and not bb and not sB then sd=qG((sA-cJ):normalize())elseif b2 and(bb or bc)then sd=qG(-vec3(cF):normalize())end end;if b9 then if not pP then aZ=false;p_=a0;bL=fR(a0,2)pP=true end;local ra=c.getThrottle()if t then ra=bL end;local sN=99999;local oq=-vec3(b.getWorldAcceleration()):dot(cF:normalize())local sO=df(cF:dot((sA-cJ):normalize()),0,cG)if sO>0 or oq>0 then sN=ck.computeTravelTime(sO,oq,r9-b_)end;if cE:len()>=_ or ra==0 and pP or a1/4>sN then b9=false;if be~="Cruising"then fQ("apCru","AP")be="Cruising"end;bc=true;p_=0 end;local sP=r9;if sP<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<pA and cR>2000 then co.ResetAutopilots(1)bX="Autopilot cancelled to prevent crossing PvP Line"aZ="PvP Prevent"pA=cR else pA=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true;p_=0;pP=false end elseif bb then if be~="Orbiting to Target"then aZ="AP Brk"end;if b2 then p_=1;q1=true end;local dK,sn=cl(c1):escapeAndOrbitalSpeed((cJ-kh.center):len()-kh.radius)local qN;if g1 then qN=g1.position-cJ end;if g1 and g1.planetname=="Space"and cG<50 then if#bD>0 then if not qa then table.remove(bD,1)end;if#bD>0 then aZ=false;if not qa then qa=2 end;return end end;sz("Autopilot complete, arrived at space location")aZ="Space Arrival"elseif g1 and g1.planetname~="Space"and cG<=sn and(fp.apoapsis==nil or fp.periapsis==nil or fp.apoapsis.altitude<=0 or fp.periapsis.altitude<=0)then sz("Autopilot complete, commencing reentry")bi=g1.position;c5=true;co.showWayPoint(c1,bi)elseif(g1 and g1.planetname~="Space"or g1==nil)and fp.periapsis~=nil and fp.periapsis.altitude>0 and fp.eccentricity<1 or be=="Circularizing"then if be~="Circularizing"then fQ("apCir","AP")be="Circularizing"end;if cG<=sn then if g1 then if cF:normalize():dot(qN:normalize())>0.4 then if be~="Orbiting to Target"then fQ("apOrb","OB")be="Orbiting to Target"end;if not qW then aZ=false;co.showWayPoint(c1,g1.position)qW=true end else sz("Autopilot complete, proceeding with reentry")bi=g1.position;c5=true;co.showWayPoint(c1,g1.position)qW=false end else sz("Autopilot completed, setting orbit",true)aZ=false end end elseif be=="Circularizing"then sz("Autopilot complete, fixing Orbit",true)end elseif bc then local sP=r9;if sP<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<pA and cR>2000 then if not qa then qa=true end;bX="Autopilot cancelled to prevent crossing PvP Line"aZ="Prevent PvP"pA=cR else pA=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true end;local ra=c.getThrottle()if t then ra=bL end;if ra>0 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;bc=false end else if sd then if not ba and g1==nil or not ba and g1 and g1.planetname~="Space"then if not c5 then bi=vec3(c1.center)+(gl+c1.radius)*cD;sQ=pX;sR=cD end;ba=true elseif sd and not q4 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;if not pP then p_=a0;q1=true;bL=fR(a0,2)pP=true;aZ=false end end end end elseif b1 and(g1~=nil and g1.planetname~="Space"and c9)then bX="Autopilot complete, starting reentry"fQ("apCom","AP")bi=g1.position;aZ=false;bb=false;b1=false;qU=false;be="Aligning"p_=0;pP=false;b0=true;c5=true;co.showWayPoint(c1,g1.position)end;if bV then cu=true;local sI=0;local fr=cJ+vec3(c.getMasterPlayerRelativePosition())local sS=fr-cJ;local sT=vec3(sS):project_on(cC):len()local sU=vec3(sS):project_on(cD):len()local c4=dh(sT*sT+sU*sU)qG(sS:normalize())local mA=40;local sV=c4<mA;local sW=100;local rm=df((c4-mA)/2,10,sW)pR=0;local sd=eU(pS)<0.1;if sd and cG<rm and not sV then aZ=false;sI=-20 else aZ="Follow"sI=0 end;local sX=0;if eU(sI-cN)>sX then if sY==nil then sY=pid.new(2*0.01,0,2*0.1)end;sY:inject(sI-cN)local sK=sY:get()pR=sK end end;if b3 or b4 or b6 or bo or br~=nil then local sZ=bs;if sZ then sZ=sZ*df(cG/100,0.1,1)*ca else sZ=bq end;if not c9 then sZ=bq end;pZ=cC:project_on_plane(cH):normalize():dot(cF)if pZ>100 then b_,c0=ck.computeDistanceAndTime(pZ,100,cc,0,0,sZ)local s_,t0=ck.computeDistanceAndTime(100,0,cc,0,0,sZ*0.55)b_=b_+s_ else b_,c0=ck.computeDistanceAndTime(pZ,0,cc,0,0,sZ*0.55)end;local sr=b8-cb-cI;local t1=200+cG;if b6 or c5 then t2=2000+cG end;local t3=1;if b5 then t3=df(cG/100,0.1,1)end;local sI=(utils.smoothstep(sr,-t1,t1)-0.5)*2*O*t3;if not b6 and not c5 and not bo and cC:dot(cF:normalize())<0.99 then sI=(utils.smoothstep(sr,-t1*df(20-19*ca*10,1,20),t1*df(20-19*ca*10,1,20))-0.5)*2*O*df(2-ca*10,1,2)*t3 end;if not b3 then sI=0 end;if br~=nil then if cT and not bx then sI=br else br=nil end end;cu=true;local t4=pR;if b6 then local t5=bI(cw)local t6,t7=ck.computeDistanceAndTime(cG,t5/3.6,cc,0,0,bq-kh.gravity*9.8*cc)t6=t6==-1 and 5000 or t6;local qV=cb-(kh.noAtmosphericDensityAltitude+t6)local t8=cb>kh.noAtmosphericDensityAltitude+t6*1.35;if t8 then sI=P;if cG<=t5/3.6 and cG>t5/3.6-10 and eU(cF:normalize():dot(cC))>0.9 and not cM then bP=false;p_=1 end elseif(cM or ik:getTargetSpeed(axisCommandId.longitudinal)~=t5)and not t8 and not c9 then q0=t5;q1=true end;if cM then if cG>t5/3.6 and not t8 then aZ="Reentry Limit"if bL>0 then p_=0 end else aZ=false end else aZ=false end;if cI>0 then aZ="Reentry vSpd"end;if not pQ then sI=-80;if cb<kh.surfaceMaxAltitude+(kh.atmosphereThickness-kh.surfaceMaxAltitude)*0.25 then bX="PARACHUTE DEPLOYED at "..fR(cb,0)b6=false;b4=true;lo=true;p_=0;sI=0;cu=p end elseif kh.noAtmosphericDensityAltitude>0 and t8 then cu=true elseif not t8 then if not c9 and(cM or ik:getTargetSpeed(axisCommandId.longitudinal)~=t5)then q0=t5 end;if cG<t5/3.6+1 then aZ=false;pQ=false;b6=false;cu=true;p_=1 end end end;if cG>iE and not c6 and not bo and not b4 and u then qG(vec3(cF))end;if cS or(bo or c6)and bj>0 and c9 then local qN;if cS then if type(cS)=="table"then qN=cS elseif cS<3 and cS>0 then qN=-cH:cross(cF)*5000 elseif cS>=3 then qN=cH:cross(cF)*5000 elseif cS<0 then qN=cF*25000 end elseif g1~=nil then qN=g1.position-cJ else qN=c1.center-cJ end;local sH=math.deg(qq(cH:normalize(),cF,qN))*2;local mD=math.rad(eU(cO))if cG>aJ and c9 then local t9=1000+cG;local ta=(utils.smoothstep(sr-cI*10,-t9,t9)-0.5)*2*O;local tb=df(90-ta,0,180)pU=df(sH*2,-tb,tb)local tc=sH;sH=df(df(sH,-L*0.80,L*0.80)*math.cos(mD)+4*(cN-sI)*math.sin(math.rad(cO)),-L*0.80,L*0.80)local td=1;if pU~=0 then td=eU(mD/pU)end;td=(90-df(eU(pU-cO),0,90))/90;local te=sI;if eU(cO)>90 then te=-te end;sI=td*df(df(te*math.cos(mD),-M*0.8,M*0.8)+eU(df(eU(tc)*math.sin(mD),-M*0.80,M*0.80)),-M*0.80,M*0.80)else pU=0;sH=df(sH,-L*0.80,L*0.80)end;local tf=s4-sH;if cS and eU(tf)<=0.0001 and(type(cS)=="table"or type(cS)~="table"and cS<0 and eU(cO)<1)then if cS==-2 then co.ToggleAltitudeHold()end;cS=nil;fQ("180Off","BR")return end;if not cv and cG>aJ and c9 then if tg==nil then tg=pid.new(2*0.01,0,2*0.1)end;tg:inject(tf)local sM=df(tg:get(),-1,1)pS=pS+sM elseif c9 and c8>-1 or cG<aJ then qG(qN)elseif cv and c9 then if(s4<-L or s4>L)and c9 then qG(cF)end;if(s5<-M or s5>M)and c9 then sI=df(cN-s5,cN-M*0.80,cN+M*0.80)end end;if g1~=nil and not c6 then local se=kh:getAltitude(g1.position)local qV=qN:project_on_plane(cH):len()lo=true;if b8<kh.noAtmosphericDensityAltitude and not c6 and not b5 and not b6 and(qV<=b_ and qN:len()<kh.radius)and(cF:project_on_plane(cH):normalize():dot(qN:project_on_plane(cH):normalize())>0.99 or lx=="Finalizing Approach")then lx="Finalizing Approach"if#bD>0 then if not qa then table.remove(bD,1)end;if#bD>0 then if not qa then qa=2 end;return end end;p_=0;if b3 then co.ToggleAltitudeHold()bo=true end;aZ="AP Finalizing"elseif not b5 then aZ=false end;if lx=="Finalizing Approach"and(pZ<0.1 or qV<0.1 or th~=nil and th<qV)then fQ("bklOn","BL")b4=true;d6=true;if g1.heading then d7=g1.heading else d7=nil end;bo=false;lx="Proceeding to Waypoint"cU=false end;th=qV end elseif bo and not c9 and b8>kh.noAtmosphericDensityAltitude and not(c6 or b6)then if g1~=nil and c1.name==kh.name then local qN=g1.position-cJ;local se=kh:getAltitude(g1.position)local qV=dh(qN:len()^2-(cb-se)^2)local sZ=bs;if sZ then b_,c0=ck.computeDistanceAndTime(cG,0,cc,0,0,sZ/2)lo=true;if qV<=b_+cG*s3/2 and cF:project_on_plane(cH):normalize():dot(qN:project_on_plane(cH):normalize())>0.99 then if kh.hasAtmosphere then aZ=false;b0=false;pQ=true;c5=false;c7=true;b1=false;co.BeginReentry()end end;th=qV end end end;if not c9 and(b3 and b8>kh.noAtmosphericDensityAltitude)and not(c6 or bx or b6)then if not cz and not bx then cy=b8;pK=true;if bo then pW.VectorToTarget=true end;co.ToggleIntoOrbit()bo=false;pI=true end end;if cv and c9 and c8==-1 and cG>aJ and lx~="Finalizing Approach"then qG(cF)sI=df(cN-s5,cN-M*0.80,cN+M*0.80)end;pR=t4;local qz=-1;if b4 then if not q5 then if not cM then p_=0 end;ik:setTargetGroundAltitude(500)ik:activateGroundEngineAltitudeStabilization(500)bz=true;q5=true end;sI=0;local ti=false;local tj=math.abs(pZ)if not q and cL then ti=antigrav.getBaseAltitude()if ti<kh.surfaceMaxAltitude and g1==nil or g1~=nil and kh:getAltitude(g1.position)>ti then ti=false end else ti=false end;if d7 then if tj<0.05 then if cI>-N then aZ=false else aZ="BL Align BLR"end;if qG(d7,0.001)then d7=nil;cu=p else pR=0;cu=true end else aZ="BL Align Hzn"end;if ti and eU(cb-ti)<250 then aZ="AGG Align"end else local tk=false;local tl=30;if tj<10 and sa~=nil and sa>0 then local tm=df(ca,0.4,2)local sZ=bs*df(cG/100,0.1,1)*tm;local tn=sa*tm+sZ-oe;local to=sZ/2-oe;local tp=cG-dh(eU(to/2)*20/(0.5*cc))*utils.sign(to)if tp<0 then tp=0 end;local tq;if cG>100 then local tr,dK=ck.computeDistanceAndTime(cG,100,cc,0,0,sZ)local ts,dK=ck.computeDistanceAndTime(100,0,cc,0,0,dh(sZ))tq=tr+ts else tq=ck.computeDistanceAndTime(cG,0,cc,0,0,dh(sZ))end;if tq<20 then aZ=false else local tt=0;if tp>100 then local tu,dK=ck.computeDistanceAndTime(tp,100,cc,0,0,tn)local tv,dK=ck.computeDistanceAndTime(100,0,cc,0,0,sa*tm+dh(sZ)-oe)tt=tu+tv else tt,dK=ck.computeDistanceAndTime(tp,0,cc,0,0,sa*tm+dh(sZ)-oe)end;tt=(tt+15+cG*s3)*1.1;local tw=d6 and g1~=nil and kh:getAltitude(g1.position)>0 and g1.safe;local se=nil;if ti and ti<cb then se=ti elseif tw then se=kh:getAltitude(g1.position)+250 elseif cb>kh.surfaceMaxAltitude then se=kh.surfaceMaxAltitude end;if cV then local tx=kh:getAltitude(cV[1].center)if se then if tx>se then se=tx end else se=tx end end;if se~=nil then local ty=cb-se;tk=true;if ty<=tt or tt==-1 or tj>0.05 and d6 then if tj>0.05 and d6 then aZ="BL AP Hzn"else aZ="BL Stop Dist"end else aZ=false end end end end;qz=c8;if qz>-1 then if(cG<1 or cF:normalize():dot(cH)<0)and not d7 then b4=false;b3=false;if not ti then q2=true;ik:setTargetGroundAltitude(Y)end;bU=0;aZ="BL Complete"cu=p;d6=false else aZ="BL Slowing"end elseif not tk then if lo and cF:normalize():dot(-gn)<0.999 then aZ="BL Strong"qG()elseif tj>10 or tj>0.05 and d6 then aZ="BL hSpd"elseif cI<-N then aZ="BL BLR"else aZ=false end end end else q5=false end;if b5 or c6 then local lt,eF,eE;if bi~=nil then lt,eF,eE=cj:getPlanetarySystem(0):castIntersections(cJ,(bi-cJ):normalize(),function(en)return en.radius+en.noAtmosphericDensityAltitude end)end;if cL and not c6 then if cb>=b8-50 and cG>iE then b5=false;if not b1 and not bo then aZ="ATO Agg Arrive"p_=0 end end elseif eU(sI)<15 and cb/b8>0.75 then b5=false;if not c6 then if cM and not t then d.control.cancelCurrentControlMasterMode()end elseif c6 and cG<iE then b1=true;c6=false;b3=false;b5=false;p_=0 elseif c6 then p_=0;aZ="ATO Space"end elseif c6 and not c9 and c1~=nil and(lt==nil or lt.name==c1.name)then b1=true;c6=false;b3=false;b5=false;if not cM then p_=0 end;b9=true end end;local tz=c8>-1;local tA=cN;if(bo or c6 or cS)and not tz and cG>aJ and c9 then local mD=math.rad(eU(cO))tA=cN*eU(math.cos(mD))+s5*math.sin(mD)end;local tB=df(sI-tA,-M*0.80,M*0.80)if not c9 and bo then tB=df(sI-tA,-85,O)elseif not c9 then tB=df(sI-tA,-O,O)end;if eU(cO)<5 or bo or cS or b4 or tz or b3 then if sY==nil then sY=pid.new(5*0.01,0,5*0.1)end;sY:inject(tB)local sK=sY:get()pR=pR+sK end end;if antigrav~=nil and(antigrav and not q and cb<200000)then if bt==nil or bt<1000 then bt=1000 end;if tC~=bt then tC=bt;q9=tC end end;if(c9 or b6 or c7)and t and cM then if tD==nil then tD=pid.new(0.1,0,1)end;local tE=0;if aS>0 and not b6 and ca>0.005 and ca<0.1 and cI>-50 then tE=(0.1-ca)*cw*aS end;tD:inject(cw/3.6+tE-cF:dot(cC))local tF=tD:get()bO=df(tF,-1,1)if not d2 then if bO<bL and(ca>0.005 or b6 or c7)then bN=true;d2=df(bO,0.01,1)else bN=false;d2=bL end end;if tG==nil then tG=pid.new(1*0.01,0,1*0.1)end;tG:inject(cF:len()-cw/3.6-tE)local tH=df(tG:get(),0,1)if c9 and cI<-80 or(ca>0.005 or b6 or c7)then bM=tH end;if bM>0 then if bN and bO==0.01 and not d2 then d2=0 end else bO=df(bO,0.01,1)end;local tI=''local tJ=vec3()local tK=rk(axisCommandId.vertical,bU*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tK,r_)local tL='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tL=tL..aT end;local tM=ik:getAxisCommandType(axisCommandId.longitudinal)local tN=ik:composeAxisAccelerationFromThrottle(tL,axisCommandId.longitudinal)local tO=ry(axisCommandId.lateral,bw*1000)tI=tI..' , '.."lateral airfoil , lateral ground "tJ=tJ+tO;if tJ:len()>constants.epsilon then d:setEngineForceCommand(tI,tJ,r_,'','','',s0)end;d:setEngineForceCommand(tL,tN,rZ)local tP='thrust analog vertical fueled 'local tQ='thrust analog lateral fueled 'if bA=="All"or bA=="Lateral"then tQ=tQ..aU end;if bA=="All"or bA=="Vertical"then tP=tP..aV end;if bU~=0 or b4 and aZ or not bk and not bz then d:setEngineForceCommand(tP,tK,rZ)else d:setEngineForceCommand(tP,vec3(),rZ)end;if bw~=0 then d:setEngineForceCommand(tQ,tO,rZ)else d:setEngineForceCommand(tQ,vec3(),rZ)end;if rL==0 then rL=bM end;local tR=-rL*(aO*cF+aP*rP)d:setEngineForceCommand('brake',tR)else if t then if not d2 then d2=bL end end;local rm=c.getAxisCommandValue(0)if not cM then if tG==nil then tG=pid.new(1*0.01,0,1*0.1)end;tG:inject(cF:len()-rm/3.6)local tH=df(tG:get(),0,1)rL=df(rL+tH,0,1)end;local tR=-rL*(aO*cF+aP*rP)d:setEngineForceCommand('brake',tR)local tI=''local tJ=vec3()local tS=false;local tL='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tL=tL..aT end;local tM=ik:getAxisCommandType(axisCommandId.longitudinal)if tM==axisCommandType.byThrottle then local tN=ik:composeAxisAccelerationFromThrottle(tL,axisCommandId.longitudinal)d:setEngineForceCommand(tL,tN,rZ)elseif tM==axisCommandType.byTargetSpeed then local tN=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tI=tI..' , '..tL;tJ=tJ+tN;if ik:getTargetSpeed(axisCommandId.longitudinal)==0 or ik:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ik:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tS=true end end;local tQ='thrust analog lateral 'if bA=="All"or bA=="Lateral"then tQ=tQ..aU end;local tT=ik:getAxisCommandType(axisCommandId.lateral)if tT==axisCommandType.byThrottle then local tU=ik:composeAxisAccelerationFromThrottle(tQ,axisCommandId.lateral)d:setEngineForceCommand(tQ,tU,rZ)elseif tT==axisCommandType.byTargetSpeed then local tO=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tI=tI..' , '..tQ;tJ=tJ+tO end;local tP='thrust analog vertical 'if bA=="All"or bA=="Vertical"then tP=tP..aV end;local tV=ik:getAxisCommandType(axisCommandId.vertical)if tV==axisCommandType.byThrottle then local tK=ik:composeAxisAccelerationFromThrottle(tP,axisCommandId.vertical)if bU~=0 or b4 and aZ then d:setEngineForceCommand(tP,tK,rZ,'airfoil','ground','',s0)else d:setEngineForceCommand(tP,vec3(),rZ)d:setEngineForceCommand('airfoil vertical',tK,rZ,'airfoil','','',s0)d:setEngineForceCommand('ground vertical',tK,rZ,'ground','','',s0)end elseif tV==axisCommandType.byTargetSpeed then if bU<0 then d:setEngineForceCommand('hover',vec3(),rZ)end;local tW=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tI=tI..' , '..tP;tJ=tJ+tW end;if tJ:len()>constants.epsilon then if rL~=0 or tS or eU(rP:dot(cC))<0.5 then tI=tI..', brake'end;d:setEngineForceCommand(tI,tJ,r_,'','','',s0)end end;local tX=aL*(rT-rS)local tY=vec3(b.getWorldAirFrictionAngularAcceleration())tX=tX-tY;d:setEngineTorqueCommand('torque',tX,rZ,'airfoil','','',s0)d:setBoosterCommand('rocket_engine')if bZ and not n then local fl=cE:len()local tZ=0.15;if not cM then local t_=ik:getTargetSpeed(axisCommandId.longitudinal)if fl*3.6>t_*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl*3.6<t_*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end else local ra=c.getThrottle()if t then ra=bL*100 end;local rm=ra/100;if not c9 then rm=rm*_;if fl>=rm*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl<rm*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end else local t5=bI(cw)rm=rm*t5/3.6;if fl>=rm*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl<rm*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end end end end end;if u1 then for dF,dr in pairs(u1)do py[dF]=dr end end;c8=qu()return py end;local function u2(d,b,c,a,e,vBooster,hover,antigrav,db,dbHud_2,gyro,u3,ij,ik,il,u4,gI,fR,d_,dg,df,fQ,io,px)local u5={}local u6=true;local u7=5;local u8=5;local u9=u7;local ua=u8;local ub=bK;function u5.landingGear()bk=not bk;if bk then bo=false;br=nil;co.cmdThrottle(0)if vBooster or hover then if c9 and c8==-1 then fQ("bklOn","BL")lo=true;b6=false;b5=false;b7=false;b3=false;if b4 then d6=not d6 end;b4=true;cu=true;bk=false else if bQ then fQ("grOut","LG",1)d.control.extendLandingGears()end;d6=false;ik:setTargetGroundAltitude(Y)if c9 then aZ="Landing"end end end;if bQ and not b4 and not(vBooster or hover)then fQ("grOut","LG",1)d.control.extendLandingGears()end else if bQ then fQ("grIn","LG",1)d.control.retractLandingGears()end;ik:activateGroundEngineAltitudeStabilization(uc)if bz then ik:setTargetGroundAltitude(X)end end end;function u5.startControl(ud)local function ue(r5)local r6=1;local function uf(ug,r5)local uh={kh.surfaceMaxAltitude+100,kh.spaceEngineMinAltitude-0.01*kh.noAtmosphericDensityAltitude,kh.noAtmosphericDensityAltitude+T,kh.radius*(S-1)+kh.noAtmosphericDensityAltitude}local ui=ug;for dK,dr in ipairs(uh)do if r5 and ui>dr then ug=dr elseif ug<dr and not r5 then ug=dr;break end end;return ug end;if r5 then r6=-1 end;if not q and cL then if bW and r5 then bt=1000 elseif bt~=nil then bt=bt+r6*u8;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end else bt=tC+r6*100 end elseif b3 or b7 or bx then if bx then if bW then cy=uf(cy,r5)else cy=cy+r6*u7 end;if cy<kh.noAtmosphericDensityAltitude then cy=kh.noAtmosphericDensityAltitude end else if bW and c9 then b8=uf(b8,r5)else b8=b8+r6*u7 end end else if not r5 and c8-3<Y and cb>0 and bk then cq.landingGear()end;ik:updateTargetGroundAltitudeFromActionStart(r6*1.0)end end;local function uj(uk)if not c9 then bX="Flight Assist in Atmo only"return end;local dn=type(uk)if cS==nil then if dn=="table"then if b1 or bo then co.ToggleAutopilot()end;fQ("180On","BR")elseif uk==1 then fQ("bnkLft","BR")else fQ("bnkRht","BR")end;if not b3 and not b1 and not bo then co.ToggleAltitudeHold()if dn~="table"then uk=uk+1 end end;cS=uk else fQ("180Off","BR")cS=nil end end;if ud=="gear"then cq.landingGear()elseif ud=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ud=="forward"then if o_ and not c9 and not b1 then b0=not b0;a_=false else bR=bR-1 end elseif ud=="backward"then if o_ then if not c9 then if not b1 then a_=not a_;b0=false else b2=not b2 end else uj(-cF*5000)end else bR=bR+1 end elseif ud=="left"then if o_ then uj(1)else bS=bS-1 end elseif ud=="right"then if o_ then uj(3)else bS=bS+1 end elseif ud=="yawright"then bT=bT-1;d7=nil elseif ud=="yawleft"then bT=bT+1;d7=nil elseif ud=="straferight"then ik:updateCommandFromActionStart(axisCommandId.lateral,1.0)bw=1 elseif ud=="strafeleft"then ik:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bw=-1 elseif ud=="up"then bU=bU+1;if c8-3<Y and cb>0 and bk then cq.landingGear()end;ik:deactivateGroundEngineAltitudeStabilization()ik:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ud=="down"then bU=bU-1;ik:deactivateGroundEngineAltitudeStabilization()ik:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ud=="groundaltitudeup"then ue()elseif ud=="groundaltitudedown"then ue(true)elseif ud=="option1"then ul=false;if o_ and bW then local um=""for K=1,#cY do um=um.."| Name: "..a.getPlayerName(cY[K]).." Mass: "..fR(b.getBoardedPlayerMass(cY[K])/1000,1).."t "end;a.print("Onboard: "..um)return end;cn.adjustAutopilotTargetIndex()elseif ud=="option2"then ul=false;if o_ and bW then for K=1,#cY do b.forceDeboard(cY[K])end;bX="Deboarded All Passengers"return end;cn.adjustAutopilotTargetIndex(1)elseif ud=="option3"then local function un()u6=not u6;if not u6 then fQ("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(uo,atmofueltank_size,"Atmo Fuel","fuel_container")up=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uq,spacefueltank_size,"Space Fuel","fuel_container")ur=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(us,rocketfueltank_size,"Rocket Fuel","fuel_container")ut=_autoconf.panels[_autoconf.panels_size]end;uu=a.createWidgetPanel("Docking")uv=a.createWidget(uu,"parenting")a.addDataToWidget(c.getDataId(),uv)uw=a.createWidgetPanel("Core combat stress")ux=a.createWidget(uw,"core_stress")a.addDataToWidget(b.getDataId(),ux)if db~=nil then db.show()end else fQ("hud","DH")c.hide()b.hide()if up~=nil then gI(up)up=nil end;if uu~=nil then gI(uu)uu=nil end;if uw~=nil then gI(uw)uw=nil end;if ur~=nil then gI(ur)ur=nil end;if ut~=nil then gI(ut)ut=nil end;if db~=nil then db.hide()end end end;ul=false;if o_ and bW then local um=""for K=1,#cZ do um=um.."| ID: "..cZ[K].." Mass: "..fR(b.getDockedConstructMass(cZ[K])/1000,1).."t "end;a.print("Docked Ships: "..um)return end;if x then if w then w=false else w=true end end;un()elseif ud=="option4"then ul=false;if o_ and bW then for K=1,#cZ do b.forceUndock(cZ[K])end;bX="Undocked all ships"return end;cS=nil;co.ToggleAutopilot()elseif ud=="option5"then ul=false;co.ToggleLockPitch()elseif ud=="option6"then ul=false;if o_ and bW then if db then cr.ventShield()else bX="No shield found"end;return end;co.ToggleAltitudeHold()elseif ud=="option7"then ul=false;if o_ and bW then if db then db.toggle()return else bX="No shield found"return end end;E=not E;if E then bX="Collision System Enabled"else bX="Collision System Secured"end elseif ud=="option8"then ul=false;if o_ and bW then if bj>0 and g1~=nil then co.routeWP()else bX="Select a saved wp on IPH to add to or remove from route"end;return end;bz=not bz;if not bz then bX="DeCoupled Mode - Ground Stabilization off"ik:deactivateGroundEngineAltitudeStabilization()fQ("gsOff","GS")else bX="Coupled Mode - Ground Stabilization on"ik:activateGroundEngineAltitudeStabilization(uc)d9=true;fQ("gsOn","GS")end elseif ud=="option9"then ul=false;if o_ and bW then ik:resetCommand(axisCommandId.longitudinal)ik:resetCommand(axisCommandId.lateral)ik:resetCommand(axisCommandId.vertical)co.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cd=gyro.getState()==1;if cd then fQ("gyOn","GA")else fQ("gyOff","GA")end else bX="No gyro found"end elseif ud=="lshift"then cW=false;if o_ then bW=true end;if il()==1 then bW=true;bg=il()u4(1)elseif ij()==1 and y then bW=true;ct=false;cs=false end elseif ud=="brake"then if aX or o_ then co.BrakeToggle("Manual")elseif not aZ then co.BrakeToggle("Manual")else aZ="Manual"end elseif ud=="lalt"then ul=true;o_=true;if ij()==0 and not i and g=="keyboard"then u4(1)end elseif ud=="booster"then if n then d:toggleBoosters()elseif not bZ then if not u0 then d:toggleBoosters()u0=true end;bZ=true else if u0 then d:toggleBoosters()u0=false end;bZ=false end elseif ud=="stopengines"then local function uy()if bK-ub<1.5 then fQ("clear","CA")co.clearAll()end end;uy()ub=bK;if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bL~=0 then ik:resetCommand(axisCommandId.longitudinal)co.cmdThrottle(0)else co.cmdThrottle(100)end else if ik:getTargetSpeed(axisCommandId.longitudinal)~=0 then ik:resetCommand(axisCommandId.longitudinal)else if c9 then co.cmdCruise(cw)else co.cmdCruise(_*3.6)end end end elseif ud=="speedup"then co.changeSpd()elseif ud=="speeddown"then co.changeSpd(true)elseif ud=="antigravity"and not q then if antigrav~=nil then co.ToggleAntigrav()else bX="No antigrav found"end end end;function u5.stopControl(ud)local function uz()if not q and cL then ua=u8 end;if b3 or b7 or bx then u9=u7 end end;if ud=="forward"then bR=0 elseif ud=="backward"then bR=0 elseif ud=="left"then if cS then if cS==2 then cS=-2 else cS=-1 end end;bS=0 elseif ud=="right"then if cS then if cS==4 then cS=-2 else cS=-1 end end;bS=0 elseif ud=="yawright"then bT=0 elseif ud=="yawleft"then bT=0 elseif ud=="straferight"then ik:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bw=0 elseif ud=="strafeleft"then ik:updateCommandFromActionStop(axisCommandId.lateral,1.0)bw=0 elseif ud=="up"then bU=0;ik:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bz then ik:activateGroundEngineAltitudeStabilization(uc)d9=true end elseif ud=="down"then bU=0;ik:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bz then ik:activateGroundEngineAltitudeStabilization(uc)d9=true end elseif ud=="groundaltitudeup"then uz()ul=false elseif ud=="groundaltitudedown"then uz()ul=false elseif ud=="lshift"then if il()==1 then c2=0;c3=0;u4(bg)elseif ij()==1 and y then ct=false;cs=false end;bW=false elseif ud=="brake"then if not aX and not o_ then if aZ then co.BrakeToggle()else aZ=false end end elseif ud=="lalt"then if ij()==0 and i then if ul then if il()==1 then u4(0)else u4(1)end else ul=true end elseif ij()==0 and not i and g=="keyboard"then u4(0)end;o_=false end end;function u5.loopControl(ud)local function uA(r5)local r6=1;if r5 then r6=-1 end;if not q and cL then if bt~=nil then bt=bt+r6*ua;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end;ua=df(ua*1.05,u8,50)else bt=tC+r6*100 end elseif b3 or b7 or bx then if bx then cy=cy+r6*u9;if cy<kh.noAtmosphericDensityAltitude then cy=kh.noAtmosphericDensityAltitude end else b8=b8+r6*u9 end;u9=df(u9*1.05,u7,50)else ik:updateTargetGroundAltitudeFromActionLoop(r6*1.0)end end;local function uB(r5)local r6=1;if r5 then r6=-1 end;if not bW then if t and not o_ then bL=df(bL+r6*aD/100,-1,1)else ik:updateCommandFromActionLoop(axisCommandId.longitudinal,r6*aD)end end end;if ud=="groundaltitudeup"then if not bW then uA()end elseif ud=="groundaltitudedown"then if not bW then uA(true)end elseif ud=="speedup"then uB()elseif ud=="speeddown"then uB(true)end end;function u5.inputTextControl(r4)local function uC(uD,fr,gv)local function uE(fr)local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy='::pos{'..dx..','..dx..','..dx..','..dx..','..dx..'}'local dO,dP,dX,dY,dZ=d_(fr,dy)if dO=="0"and dP=="0"then return vec3(dg(dX),dg(dY),dg(dZ))end;dY=math.rad(dY)dX=math.rad(dX)local kh=e[dg(dO)][dg(dP)]local eQ=math.cos(dX)local uF=vec3(eQ*math.cos(dY),eQ*math.sin(dY),math.sin(dX))return kh.center+(kh.radius+dZ)*uF end;local fT=uE(fr)return cn.AddNewLocation(uD,fT,gv)end;local K;local uG,i7=nil,nil;local uH="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(r4," ")uG=r4;if K~=nil then uG=string.sub(r4,0,K-1)i7=string.sub(r4,K+1)end;if uG=="/help"or uG=="/commands"then for lp in string.gmatch(uH,"([^\n]+)")do a.print(lp)end;return elseif uG=="/setname"then if i7==nil or i7==""then bX="Usage: ah-setname Newname"return end;if bj>0 and g1~=nil then cn.UpdatePosition(i7)else bX="Select a saved target to rename first"end elseif db and uG=="/resist"then cr.setResist(i7)elseif uG=="/addlocation"or string.find(r4,"::pos")~=nil then local gv=false;local uD="0-Temp"if i7==nil or i7==""or uG~="/addlocation"then i7=uG;gv=true end;K=string.find(i7,"::")if not gv then uD=string.sub(i7,1,K-2)end;local fr=string.sub(i7,K)uC(uD,fr,gv)elseif uG=="/agg"then if i7==nil or i7==""then bX="Usage: /agg targetheight"return end;i7=dg(i7)if i7<1000 then i7=1000 end;bt=i7;bX="AGG Target Height set to "..i7 elseif uG=="/G"then if i7==nil or i7==""then bX="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if i7=="dump"then for dF,dr in pairs(io())do if type(dr.get())=="boolean"then if dr.get()==true then a.print(dF.." true")else a.print(dF.." false")end elseif dr.get()==nil then a.print(dF.." nil")else a.print(dF.." "..dr.get())end end;return end;K=string.find(i7," ")local uI=string.sub(i7,0,K-1)local uJ=string.sub(i7,K+1)for dF,dr in pairs(io())do if dF==uI then local uK=type(dr.get())if uK=="number"then uJ=dg(uJ)if dF=="AtmoSpeedLimit"then cw=uJ end end;bX="Variable "..uI.." changed to "..uJ;if dF=="MaxGameVelocity"then uJ=uJ/3.6;if uJ>da-0.2 then uJ=da-0.2;bX="Variable "..uI.." changed to "..fR(uJ*3.6,1)end end;if uK=="boolean"then if string.lower(uJ)=="true"then uJ=true else uJ=false end end;dr.set(uJ)return end end;bX="No such global variable: "..uI elseif uG=="/deletewp"then if bj>0 and g1~=nil then cn.ClearCurrentPosition()else bX="Select a custom wp to delete first in IPH"end elseif uG=="/copydatabank"then if dbHud_2 then px(true)else bX="Spare Databank required to copy databank"end elseif uG=="/iphWP"then if bj>0 then a.print(co.showWayPoint(c1,bi,true))a.print(json.encode(bi))bX="::pos waypoint shown in lua chat in local and world format"else bX="No target selected in IPH"end elseif uG=="/createPrivate"then local uL="privatelocations = {\n"local uM=""if#d4>0 then for dF,dr in pairs(d4)do uL=uL.."{position = {x = "..dr.position.x..", y = "..dr.position.y..", z = "..dr.position.z.."},\n ".."name = '"..dr.name.."',\n planetname = '"..dr.planetname.."',\n gravity = "..dr.gravity..",\n"if dr.heading then uL=uL.."heading = {x = "..dr.heading.x..", y = "..dr.heading.y..", z = "..dr.heading.z.."},\n"end;if dr.safe then uL=uL.."safe = true},\n"else uL=uL.."safe = false},\n"end end end;uM=#d4 .."-Private "if i7=="all"then for dF,dr in pairs(bn)do uL=uL.."{position = {x = "..dr.position.x..", y = "..dr.position.y..", z = "..dr.position.z.."},\n ".."name = '*"..dr.name.."',\n planetname = '"..dr.planetname.."',\n gravity = "..dr.gravity..",\n"if dr.heading then uL=uL.."heading = {x = "..dr.heading.x..", y = "..dr.heading.y..", z = "..dr.heading.z.."},\n"end;if dr.safe then uL=uL.." safe = true},\n"else uL=uL.."safe = false},\n"end end;uM=uM..#bn.."-Public "end;uL=uL.."}\n return privatelocations"if u3 then u3.setHTML(uL)end;bX=uM.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bY=7 end end;function u5.tagTick()if bA=="Off"then bA="All"elseif bA=="All"then bA="Longitude"elseif bA=="Longitude"then bA="Lateral"elseif bA=="Lateral"then bA="Vertical"else bA="Off"end;bX="Extra Engine Tags: "..bA;c.stopTimer("tagTick")end;if uN then for dF,dr in pairs(uN)do u5[dF]=dr end end;return u5 end;local function uO(d,b,c,a,library,e,vBooster,hover,pw,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,db,gyro,warpdrive,ig,u3)local uP={}local de=string.format;local ih=json.decode;local uQ=json.encode;local pp=b.getElementMaxHitPointsById;local ii=b.getElementMassById;local ij=d.control.isRemoteControlled;local d_=string.match;local gI=a.destroyWidgetPanel;local fO=a.updateData;local fP=a.addDataToWidget;local u4=a.lockView;local il=a.isViewLocked;local dh=math.sqrt;local dg=tonumber;local eU=math.abs;local bI=math.floor;local bJ=c.getAtmosphereDensity;local eP=math.atan;local bH=a.getArkTime;local df=utils.clamp;local ik=d.axisCommandManager;local uR=Y;local gK=13;local ir=b.getElementIdList()local is=0;local function di(ex,ey)if ex==0 then return eU(ey)<1e-09 end;if ey==0 then return eU(ex)<1e-09 end;return eU(ex-ey)<math.max(eU(ex),eU(ey))*dw end;local function fR(dx,uS)local r6=10^(uS or 0)return bI(dx*r6+0.5)/r6 end;local function im(uT,uU)for dF,dr in pairs(uU)do if type(dF)=="string"then uT[dF]=dr else uT[#uT+1]=uU[dF]end end;return uT end;local function io(uV)local uW={}if not uV then im(uW,J)im(uW,a8)im(uW,aB)im(uW,aW)return uW elseif uV=="boolean"then return J elseif uV=="handling"then return a8 elseif uV=="hud"then return aB elseif uV=="physics"then return aW end end;local function px(uX)local function uY(uZ)for dF,dr in pairs(uZ)do dbHud_1.setStringValue(dF,uQ(dr.get()))if uX and dbHud_2 then dbHud_2.setStringValue(dF,uQ(dr.get()))end end end;if dbHud_1 then uY(bE)uY(io())a.print("Saved Variables to Datacore")if uX and dbHud_2 then bX="Databank copied.  Remove copy when ready."end end end;local function fQ(u_,v0,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..u_..".mp3")end;local function gJ(hk,hl,r4,jz,v1)if jz==nil then jz=""end;if v1==nil then v1=""end;return de([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jz,hk,hl,v1,r4)end;local function ip(c4,v2)local v3=c4>100000;if v2==nil then v2=1 end;if v3 then return fR(c4/1000/200,v2).."SU"elseif c4<1000 then return fR(c4,v2).."M"else return fR(c4/1000,v2).."KM"end end;local function iq(v4)local v5=0;local v6=0;local v7=0;if v4<60 then v4=bI(v4)elseif v4<3600 then v5=bI(v4/60)v4=bI(v4%60)elseif v4<86400 then v6=bI(v4/3600)v5=bI(v4%3600/60)else v7=bI(v4/86400)v6=bI(v4%86400/3600)end;if v7>0 then return v7 .."d "..v6 .."h "elseif v6>0 then return v6 .."h "..v5 .."m "elseif v5>0 then return v5 .."m "..v4 .."s"elseif v4>0 then return v4 .."s"else return"0s"end end;function uP.onStart()local v8=false;local function v9()local function va(vb)local vc=dbHud_1.hasKey;for dF,dr in pairs(vb)do if vc(dF)then local dA=ih(dbHud_1.getStringValue(dF))if dA~=nil then dr.set(dA)v8=true end end end end;if dbHud_1 then if not f then va(io())coroutine.yield()va(bE)else va(bE)bX="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bY=5;v8=false end;coroutine.yield()if v8 then bX="Loaded Saved Variables"ce=a9;cf=aa;aX=j;g=string.lower(g)cu=p;cw=U elseif not f then bX="No Saved Variables Found - Exit HUD to save settings"end;if bB<1.500 then if T<2000 then bX="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bB=VERSION_NUMBER;if#bn>0 then d5=im(d5,bn)end else bX="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bu+180<bK then bs=0 end;bu=bK;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bX="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bY=7 end;if antigrav and not q then if bt==nil then bt=cb end;antigrav.setBaseAltitude(bt)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d4>0 then d5=im(d5,d4)end end;lx="Proceeding to Waypoint"end;local function vd()local function ve(vf,vg)if vf>vg then vg=vf end;local vh,vi=0,0;if a5>0 then vh=a5*0.05 end;if a6>0 then vi=a6*0.05 end;vg=vg*(1-(vh+vi))return vg end;local vj=b.getElementNameById;local vk=aq~=0 and ar~=0;local vl=_G["atmofueltank_size"]local vm=_G["spacefueltank_size"]local vn=_G["rocketfueltank_size"]for dF in pairs(ir)do local type=b.getElementTypeById(ir[dF])if d_(type,'^.*Atmospheric Engine$')then if d_(tostring(b.getElementTagsById(ir[dF])),'^.*vertical.*$')and b.getElementForwardById(ir[dF])[3]>0 then cK=true end end;if d_(type,'^.*Space Engine$')then cB=true;if d_(tostring(b.getElementTagsById(ir[dF])),'^.*vertical.*$')then local vo=b.getElementForwardById(ir[dF])if vo[3]<0 then vp=true else cA=true end end end;if type=="Landing Gear"then bQ=true end;if type=="Dynamic Core Unit"then local pr=pp(ir[dF])if pr>10000 then gK=110 elseif pr>1000 then gK=55 elseif pr>150 then gK=27 end end;is=is+pp(ir[dF])if vk and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pr=pp(ir[dF])local om=ii(ir[dF])local vf=0;local js=bH()if type=="Atmospheric Fuel Tank"then local vg=400;local vq=35.03;if pr>10000 then vg=51200;vq=5480 elseif pr>1300 then vg=6400;vq=988.67 elseif pr>150 then vg=1600;vq=182.67 end;vf=om-vq;if a2>0 then vg=vg+vg*a2*0.2 end;vg=ve(vf,vg)local gu=vj(ir[dF])local jq=0;for jr=1,vl do if gu==ih(c["atmofueltank_"..jr].getData()).name then jq=jr;break end end;local vr={ir[dF],string.sub(gu,1,12),vg,vq,vf,js,jq}cg[#cg+1]=vr end;if type=="Rocket Fuel Tank"then local vg=320;local vq=173.42;if pr>65000 then vg=40000;vq=25740 elseif pr>6000 then vg=5120;vq=4720 elseif pr>700 then vg=640;vq=886.72 end;vf=om-vq;if a4>0 then vg=vg+vg*a4*0.1 end;vg=ve(vf,vg)local gu=vj(ir[dF])local jq=0;for jr=1,vn do if gu==ih(c["rocketfueltank_"..jr].getData()).name then jq=jr;break end end;local vr={ir[dF],string.sub(gu,1,12),vg,vq,vf,js,jq}ci[#ci+1]=vr end;if type=="Space Fuel Tank"then local vg=600;local vq=35.03;if pr>10000 then vg=76800;vq=5480 elseif pr>1300 then vg=9600;vq=988.67 elseif pr>150 then vg=2400;vq=182.67 end;vf=om-vq;if a3>0 then vg=vg+vg*a3*0.2 end;vg=ve(vf,vg)local gu=vj(ir[dF])local jq=0;for jr=1,vm do if gu==ih(c["spacefueltank_"..jr].getData()).name then jq=jr;break end end;local vr={ir[dF],string.sub(gu,1,12),vg,vq,vf,js,jq}ch[#ch+1]=vr end end end;if not cK then b7,aY=false,false end end;local function vs()if gyro~=nil then cd=gyro.getState()==1 end;if not bz then ik:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u4(1)else u4(0)end;if door and(c9 or not c9 and cb<10000)then for dK,dr in pairs(door)do dr.toggle()end end;if switch then for dK,dr in pairs(switch)do dr.toggle()end end;if forcefield and(c9 or not c9==0 and cb<10000)then for dK,dr in pairs(forcefield)do dr.toggle()end end;if antigrav then cL=antigrav.getState()==1;if cL and not q then antigrav.show()end end;if ij()==1 and k then a.freeze(1)else a.freeze(0)end;if bQ then if c8~=-1 and not cL then d.control.extendLandingGears()else d.control.retractLandingGears()end end;bk=d.control.isAnyLandingGearExtended()==1 or c8~=-1 and c8-3<Y;if c8~=-1 or not c9 and cE:len()<50 then aZ="Startup"else aZ=false end;ik:setTargetGroundAltitude(uR)pd=c9 end;local function vt()local vu={}local function vv()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vw={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vx={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vy,vz in pairs(e)do e[vy][0]=vv()e[vy][0].systemId=vy;vu[vy]={}for vA,kh in pairs(e[vy])do kh.gravity=kh.gravity/9.8;kh.center=vec3(kh.center)kh.name=kh.name[1]kh.noAtmosphericDensityAltitude=vx[kh.id]or kh.atmosphereThickness or kh.atmosphereRadius-kh.radius;kh.spaceEngineMinAltitude=vw[kh.id]or 0.68377*kh.atmosphereThickness;kh.planetarySystemId=vy;kh.bodyId=kh.id;vu[vy][vA]=kh;if mp==nil or kh.center.x<mp then mp=kh.center.x end;if mo==nil or kh.center.x>mo then mo=kh.center.x end;if ms==nil or kh.center.y<ms then ms=kh.center.y end;if mr==nil or kh.center.y>mr then mr=kh.center.y end;if kh.center and kh.name~="Space"then c_[#c_+1]=kh end end end;e9=dd(d,b,c,a,de,df,dg,dh,di)cj=e9(vu)ck=eT(d,b,c,a,dh,eU)cl=fn(d,b,c,a,de,df,dg,dh,di)cn=fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dg,dh,fQ,fR)kh=cj[0]:closestBody(b.getConstructWorldPos())end;vB=false;vC=coroutine.create(function()ik:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v9()coroutine.yield()vd()coroutine.yield()co=pv(d,b,c,a,e,vBooster,hover,pw,antigrav,warpdrive,dbHud_1,radar_1,eU,bI,bJ,ij,eP,bH,df,ik,fO,il,dh,fR,fQ,im,di,ip,iq,px,ih,de,fP)vs()coroutine.yield()vt()if radar_1 then cp=gH(b,a,c,library,radar_1,radar_2,eU,gI,dh,gJ,dg,gK,fQ)end;if ie then cm=ie(d,b,c,a,e,radar_1,radar_2,antigrav,hover,db,warpdrive,ig,eU,bI,de,ih,bJ,ii,ij,eP,bH,df,ik,fP,fO,gI,il,dh,fR,gJ,fQ,im,io,ip,iq,ir,is)end;if cm then cm.ButtonSetup()end;cq=u2(d,b,c,a,e,vBooster,hover,antigrav,db,dbHud_2,gyro,u3,ij,ik,il,u4,gI,fR,d_,dg,df,fQ,io,px)if db then cr=hZ(db,d_,bI)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if u3 then u3.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aR)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if db then c.setTimer("shieldTick",0.0166667)end;if vD then vE.ExtraOnStart()end;fQ("start","SU")end)coroutine.resume(vC)end;function uP.onUpdate()if not vB then local hQ=coroutine.status(vC)if hQ=="suspended"then local dG,hR=coroutine.resume(vC)if hR then a.print("ERROR STARTUP: "..hR)end elseif hQ=="dead"then vB=true end end;if vB then d:update()if c9 and t and cM then if cM and bP then co.cmdThrottle(0)bP=false elseif not cM and not bP then bL=0;bP=true end end;if d2 then ik:setThrottleCommand(axisCommandId.longitudinal,d2)d2=nil end;if not cs and p1~=vF then a.setScreen(p1)end;vF=p1;if vD then vE.ExtraOnUpdate()end end end;function uP.onFlush()if vB then co.onFlush()if vD then vE.ExtraOnFlush()end end end;function uP.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ca>0 or ca==0 and cb<10000)then for dK,dr in pairs(door)do dr.toggle()end end;if switch then for dK,dr in pairs(switch)do dr.toggle()end end;if forcefield and(ca>0 or ca==0 and cb<10000)then for dK,dr in pairs(forcefield)do dr.toggle()end end;w=d1;px()if nX then nX.activate()end;if z then co.showWayPoint(kh,cJ)end;if cm then a.print(cm.FuelUsed("atmofueltank")..", "..cm.FuelUsed("spacefueltank")..", "..cm.FuelUsed("rocketfueltank"))end;if vD then vE.ExtraOnStop()end;fQ("stop","SU")end;function uP.controlStart(ud)if vB then cq.startControl(ud)end end;function uP.controlStop(ud)if vB then cq.stopControl(ud)end end;function uP.controlLoop(ud)if vB then cq.loopControl(ud)end end;function uP.controlInput(r4)if vB then cq.inputTextControl(r4)end end;function uP.radarEnter(dP)cp.onEnter(dP)end;function uP.radarLeave(dP)cp.onLeave(dP)end;function uP.onTick(vG)if vG=="tenthSecond"then co.TenthTick()if cm then cm.TenthTick()end elseif vG=="oneSecond"then if cm then cm.OneSecondTick()end elseif vG=="fiveSecond"then co.SatNavTick()elseif vG=="msgTick"then if cm then cm.MsgTick()end elseif vG=="animateTick"then if cm then cm.AnimateTick()end elseif vG=="hudTick"then if cm then cm.hudtick()end elseif vG=="apTick"then co.APTick()elseif vG=="shieldTick"then cr.shieldTick()elseif vG=="tagTick"then cq.tagTick()elseif vG=="contact"then cp.ContactTick()end end;if vD then for dF,dr in pairs(vD)do uP[dF]=dr end end;return uP end;function script.onStart()vE.onStart()end;function script.onStop()vE.onStop()end;function script.onTick(vG)vE.onTick(vG)end;function script.onFlush()vE.onFlush()end;function script.onUpdate()vE.onUpdate()end;function script.onActionStart(ud)vE.controlStart(ud)end;function script.onActionStop(ud)vE.controlStop(ud)end;function script.onActionLoop(ud)vE.controlLoop(ud)end;function script.onInputText(r4)vE.controlInput(r4)end;function script.onEnter(dP)vE.radarEnter(dP)end;function script.onLeave(dP)vE.radarLeave(dP)end;bG(a,b,c,a.getArkTime,math.floor,c.getAtmosphereDensity)vE=uO(d,b,c,a,library,e,vBooster,hover,pw,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,db,gyro,warpdrive,ig,u3)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua:       if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua:       if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua:       if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
