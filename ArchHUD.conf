name: ArchHud - Archaegeo v1.5202 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5202;useTheseSettings=false;userControlScheme="virtual joystick"soundFolder="archHUD"freeLookToggle=true;BrakeToggleDefault=true;RemoteFreeze=false;RemoteHud=true;brightHud=false;VanillaRockets=false;InvertMouse=false;autoRollPreference=false;ExternalAGG=false;UseSatNav=false;ShouldCheckDamage=true;CalculateBrakeLandingSpeed=false;AtmoSpeedAssist=true;ForceAlignment=false;DisplayDeadZone=true;showHud=true;hideHudOnToggleWidgets=true;ShiftShowsRemoteButtons=true;SetWaypointOnExit=false;AlwaysVSpd=false;BarFuelDisplay=true;voices=true;alerts=true;CollisionSystem=true;AutoShieldToggle=true;PreventPvP=true;DisplayOdometer=true;YawStallAngle=35;PitchStallAngle=35;brakeLandingRate=30;MaxPitch=30;ReEntryPitch=-30;LockPitchTarget=0;AutopilotSpaceDistance=5000;TargetOrbitRadius=1.2;LowOrbitHeight=2000;AtmoSpeedLimit=1050;SpaceSpeedLimit=30000;AutoTakeoffAltitude=1000;TargetHoverHeight=50;LandingGearGroundHeight=0;ReEntryHeight=100000;MaxGameVelocity=8333.00;AutopilotInterplanetaryThrottle=1.0;warmup=32;fuelTankHandlingAtmo=0;fuelTankHandlingSpace=0;fuelTankHandlingRocket=0;ContainerOptimization=0;FuelTankOptimization=0;ResolutionX=1920;ResolutionY=1080;circleRad=400;SafeR=130;SafeG=224;SafeB=255;PvPR=255;PvPG=0;PvPB=0;centerX=960;centerY=540;throtPosX=1300;throtPosY=540;vSpdMeterX=1525;vSpdMeterY=325;altMeterX=550;altMeterY=540;fuelX=30;fuelY=700;shieldX=1750;shieldY=250;DeadZone=50;OrbitMapSize=250;OrbitMapX=0;OrbitMapY=25;soundVolume=100;speedChangeLarge=5;speedChangeSmall=1;MouseXSensitivity=0.003;MouseYSensitivity=0.003;autoRollFactor=2;rollSpeedFactor=1.5;autoRollRollThreshold=180;minRollVelocity=150;TrajectoryAlignmentStrength=0.002;torqueFactor=2;pitchSpeedFactor=0.8;yawSpeedFactor=1;brakeSpeedFactor=3;brakeFlatFactor=1;DampingMultiplier=40;apTickRate=0.0166667;hudTickRate=0.0666667;ExtraLongitudeTags="none"ExtraLateralTags="none"ExtraVerticalTags="none"BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=""local aC=true;local aD=ResolutionX;local aE=ResolutionY;local aF={}local aG={}local aH={}local aI=0;local aJ=false;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=false;local aU=false;local aV=autoRollPreference;local aW=LandingGearGroundHeight;local aX=false;local aY=0;local aZ=AtmoSpeedLimit;local a_=0;local b0=nil;local b1={VectorToTarget=false}local b2=0;local b3=false;local b4=false;local b5=false;local b6=false;local b7=vec3(core.getConstructWorldOrientationUp())local b8=vec3(core.getConstructWorldOrientationForward())local b9=vec3(core.getConstructWorldOrientationRight())local ba=vec3(core.getVelocity())local bb=vec3(core.getWorldVelocity())local bc=vec3(bb):len()local bd=vec3(core.getWorldVertical())local be=-bd:dot(bb)local bf=vec3(core.getConstructWorldPos())local bg=false;local bh=false;local bi=nil;local bj=true;local bk=0;local bl=0;local bm={}local bn=false;local bo=50000;local bp=nil;local bq={}local br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bs=false;local bt=nil;local bu=false;local bv=0;local bw={}local bx=nil;local by=nil;local bz={}local bA=90;local bB=showHud;function p(bC)system.print(E..": "..bC)end;local function bD(bE)local D=1;if bE then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bF=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bF<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then aZ=r(aZ+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bv=bv+1*D*-1;if bv>#bm then bv=1 end;if bv<1 then bv=#bm end else if not bE then D=1 else D=nil end;aQ.adjustAutopilotTargetIndex(D)end end end;local function bG(bH,bI,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)end end;local function bJ(bK,bL)for i=1,#bL do bK[#bK+1]=bL[i]end;return bK end;local function bM(bN)local bO={}local bP={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP","DisplayOdometer"}local bQ={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bR={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bS={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bN then bJ(bO,bP)bJ(bO,bQ)bJ(bO,bR)bJ(bO,bS)return bO elseif bN=="boolean"then return bP elseif bN=="handling"then return bQ elseif bN=="hud"then return bR elseif bN=="physics"then return bS end end;local function bT(bU,bV,bW,bX,bY)if bX==nil then bX=""end;if bY==nil then bY=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bX,bU,bV,bY,bW)end;local function bZ(b_,c0)if b_==0 then return d(c0)<1e-09 end;if c0==0 then return d(b_)<1e-09 end;return d(b_-c0)<math.max(d(b_),d(c0))*epsilon end;local function c1(aj,c2)local c3=aj>100000;if c2==nil then c2=1 end;if c3 then return A(aj/1000/200,c2).."SU"elseif aj<1000 then return A(aj,c2).."M"else return A(aj/1000,c2).."KM"end end;local function c4(c5)local c6=0;local c7=0;local c8=0;if c5<60 then c5=e(c5)elseif c5<3600 then c6=e(c5/60)c5=e(c5%60)elseif c5<86400 then c7=e(c5/3600)c6=e(c5%3600/60)else c8=e(c5/86400)c7=e(c5%86400/3600)end;if c8>0 then return c8 .."d "..c7 .."h "elseif c7>0 then return c7 .."h "..c6 .."m "elseif c6>0 then return c6 .."m "..c5 .."s"elseif c5>0 then return c5 .."s"else return"0s"end end;local function c9(ca)local function cb(cc)for cd,ce in pairs(cc)do dbHud_1.setStringValue(ce,h(_G[ce]))if ca and dbHud_2 then dbHud_2.setStringValue(ce,h(_G[ce]))end end end;if dbHud_1 then cb(c)cb(bM())system.print("Saved Variables to Datacore")if ca and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cf()local function cg(ch)return type(ch)=='number'end;local function ci(ch)return type(z(ch))=='number'end;local function cj(ck)return type(ck)=='table'end;local function cl(cm)return type(cm)=='string'end;local function cn(ce)return cj(ce)and cg(ce.x and ce.y and ce.z)end;local function co(cp)return cj(cp)and cg(cp.latitude and cp.longitude and cp.altitude and cp.id and cp.systemId)end;local cq=math.pi/180;local cr=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function ct(ch)local cu=string.gsub(string.reverse(f('%.4f',ch)),'^0*%.?','')return cu==''and'0'or string.reverse(cu)end;local function cv(cw)if cn(cw)then return f('{x=%.3f,y=%.3f,z=%.3f}',cw.x,cw.y,cw.z)end;if cj(cw)and not getmetatable(cw)then local cx={}local cy=next(cw)if type(cy)=='nil'or cy==1 then cx=cw else for cd,ce in pairs(cw)do local cz=cv(ce)if type(cd)=='number'then table.insert(cx,f('[%s]=%s',cd,cz))else table.insert(cx,f('%s=%s',cd,cz))end end end;return f('{%s}',table.concat(cx,','))end;if cl(cw)then return f("'%s'",cw:gsub("'",[[\']]))end;return tostring(cw)end;local cA={}cA.__index=cA;cA.__tostring=function(cw,cB)local cC={}for cd in pairs(cw)do table.insert(cC,cd)end;table.sort(cC)local cx={}for _,cd in ipairs(cC)do local cz=cv(cw[cd])if type(cd)=='number'then table.insert(cx,f('[%s]=%s',cd,cz))else table.insert(cx,f('%s=%s',cd,cz))end end;if cB then return f('%s%s',cB,table.concat(cx,',\n'..cB))end;return f('{%s}',table.concat(cx,','))end;cA.__eq=function(cD,cE)return cD.systemId==cE.systemId and cD.id==cE.id and bZ(cD.radius,cE.radius)and bZ(cD.center.x,cE.center.x)and bZ(cD.center.y,cE.center.y)and bZ(cD.center.z,cE.center.z)and bZ(cD.GM,cE.GM)end;local function cF(cG,cH,cI,cJ,cK)assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(cI),'Argument 3 (radius) must be a number:'..type(cI))assert(cj(cJ),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cJ))assert(ci(cK),'Argument 5 (GM) must be a number:'..type(cK))return setmetatable({systemId=z(cG),id=z(cH),radius=z(cI),center=vec3(cJ),GM=z(cK)},cA)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,ct(p.latitude*cr),ct(p.longitude*cr),ct(p.altitude))end;MapPosition.__eq=function(cD,cE)return cD.id==cE.id and cD.systemId==cE.systemId and bZ(cD.latitude,cE.latitude)and bZ(cD.altitude,cE.altitude)and(bZ(cD.longitude,cE.longitude)or bZ(cD.latitude,math.pi/2)or bZ(cD.latitude,-math.pi/2))end;local function cL(cM,cH,cN,cO,cP)local cG=cM;if cl(cM)and not cO and not cP and not cH and not cN then cG,cH,cN,cO,cP=o(cM,cs)assert(cG,'Argument 1 (position string) is malformed.')else assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(cN),'Argument 3 (latitude) must be in degrees:'..type(cN))assert(ci(cO),'Argument 4 (longitude) must be in degrees:'..type(cO))assert(ci(cP),'Argument 5 (altitude) must be in meters:'..type(cP))end;cG=z(cG)cH=z(cH)cN=z(cN)cO=z(cO)cP=z(cP)if cH==0 then return setmetatable({latitude=cN,longitude=cO,altitude=cP,id=cH,systemId=cG},MapPosition)end;return setmetatable({latitude=cq*r(cN,-90,90),longitude=cq*(cO%360),altitude=cP,id=cH,systemId=cG},MapPosition)end;local cQ={}cQ.__index=cQ;cQ.__tostring=function(cw,cB)local cR=cB and cB..'  'local cS={}local cC={}for cd in pairs(cw)do table.insert(cC,cd)end;table.sort(cC)for _,cT in ipairs(cC)do bdy=cw[cT]local cU=cA.__tostring(bdy,cR)if cB then table.insert(cS,f('[%s]={\n%s\n%s}',cT,cU,cB))else table.insert(cS,f('  [%s]=%s',cT,cU))end end;if cB then return f('\n%s%s%s',cB,table.concat(cS,',\n'..cB),cB)end;return f('{\n%s\n}',table.concat(cS,',\n'))end;local function cV(cW)local b={}local pid;for _,ce in pairs(cW)do local cH=ce.planetarySystemId;if type(cH)~='number'then error('Invalid planetary system ID: '..tostring(cH))elseif pid and cH~=pid then error('Mistringmatch planetary system IDs: '..cH..' and '..pid)end;local cX=ce.bodyId;if type(cX)~='number'then error('Invalid body ID: '..tostring(cX))elseif b[cX]then error('Duplicate body ID: '..tostring(cX))end;setmetatable(ce.center,getmetatable(vec3.unit_x))b[cX]=setmetatable(ce,cA)pid=cH end;return setmetatable(b,cQ)end;aK={}local function cY(cW)return setmetatable({galaxyAtlas=cW or{}},aK)end;aK.__index=function(ck,i)if type(i)=='number'then local system=ck.galaxyAtlas[i]return cV(system)end;return rawget(aK,i)end;aK.__pairs=function(cw)return function(ck,cd)local cZ,nv=next(ck,cd)return cZ,nv and cV(nv)end,cw.galaxyAtlas,nil end;aK.__tostring=function(cw)local c_={}for _,d0 in pairs(cw or{})do local d1=d0:getPlanetarySystemId()local d2=cQ.__tostring(d0,'    ')table.insert(c_,f('  [%s]={%s\n  }',d1,d2))end;return f('{\n%s\n}\n',table.concat(c_,',\n'))end;aK.BodyParameters=cF;aK.MapPosition=cL;aK.PlanetarySystem=cV;function aK.createBodyParameters(cG,cH,d3,d4,d5,d6,d7)assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(d3),'Argument 3 (surfaceArea) must be a number:'..type(d3))assert(cj(d4),'Argument 4 (aPosition) must be an array or vec3:'..type(d4))assert(cj(d5),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(d5))assert(ci(d6),'Argument 6 (altitude) must be in meters:'..type(d6))assert(ci(d7),'Argument 7 (gravityAtPosition) must be number:'..type(d7))local cI=y(d3/4/math.pi)local aj=cI+d6;local d8=vec3(d4)+aj*vec3(d5)local cK=d7*aj*aj;return cF(cG,cH,cI,d8,cK)end;aK.isMapPosition=co;function aK:getPlanetarySystem(cM)if i==nil then i=0 end;if nv==nil then nv=0 end;local cG=cM;if co(cM)then cG=cM.systemId end;if type(cG)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=cQ then system=cV(system)end;return system end end end;function cQ:sizeCalculator(d9)return 1.05*d9.radius end;function cQ:castIntersections(da,db,dc,dd,de,df)local dg={}if de then for _,d9 in pairs(de)do table.insert(dg,d9)end else dg=bz end;if not df then table.sort(dg,function(dh,di)local b_=dh.center;local c0=di.center;return(b_.x-da.x)^2+(b_.y-da.y)^2+(b_.z-da.z)^2<(c0.x-da.x)^2+(c0.y-da.y)^2+(c0.z-da.z)^2 end)end;local dj=db:normalize()for _,d9 in ipairs(dg)do local dk=d9.center-da;local cI=self:sizeCalculator(d9)local dl=dk:dot(dj)local dm=dl^2-(dk:len2()-cI^2)if dm>=0 then local dn=y(dm)local dp=dl+dn;local dq=dl-dn;if dq>0 then return d9,dp,dq elseif dp>0 then return d9,dp,nil end end end;return nil,nil,nil end;function cQ:closestBody(dr)assert(type(dr)=='table','Invalid coordinates.')local ds,d9;local dt=vec3(dr)for _,du in pairs(self)do local dv=(du.center-dt):len2()if(not d9 or dv<ds)and du.name~="Space"then d9=du;ds=dv end end;return d9 end;function cQ:convertToBodyIdAndWorldCoordinates(cM)local dw=cM;if cl(cM)then dw=cL(cM)end;if dw.id==0 then return 0,vec3(dw.latitude,dw.longitude,dw.altitude)end;local du=self:getBodyParameters(dw)if du then return dw.id,du:convertToWorldCoordinates(dw)end end;function cQ:getBodyParameters(cM)local cH=cM;if co(cM)then cH=cM.id end;assert(ci(cH),'Argument 1 (id) must be a number:'..type(cH))return self[cH]end;function cQ:getPlanetarySystemId()local _,ce=next(self)return ce and ce.systemId end;function cA:convertToMapPosition(cJ)assert(cj(cJ),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cJ))local dx=vec3(cJ)if self.id==0 then return setmetatable({latitude=dx.x,longitude=dx.y,altitude=dx.z,id=0,systemId=self.systemId},MapPosition)end;local dy=dx-self.center;local aj=dy:len()local cP=aj-self.radius;local cN=0;local cO=0;if not bZ(aj,0)then local dz=n(dy.y,dy.x)cO=dz>=0 and dz or 2*math.pi+dz;cN=math.pi/2-math.acos(dy.z/aj)end;return setmetatable({latitude=cN,longitude=cO,altitude=cP,id=self.id,systemId=self.systemId},MapPosition)end;function cA:convertToWorldCoordinates(cM)local dw=cl(cM)and cL(cM)or cM;if dw.id==0 then return vec3(dw.latitude,dw.longitude,dw.altitude)end;assert(co(dw),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dw.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dw.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dA=math.cos(dw.latitude)return self.center+(self.radius+dw.altitude)*vec3(dA*math.cos(dw.longitude),dA*math.sin(dw.longitude),math.sin(dw.latitude))end;function cA:getAltitude(cJ)return(vec3(cJ)-self.center):len()-self.radius end;function cA:getDistance(cJ)return(vec3(cJ)-self.center):len()end;function cA:getGravity(cJ)local dB=self.center-vec3(cJ)local dC=dB:len2()return self.GM/dC*dB/y(dC)end;return setmetatable(aK,{__call=function(_,...)return cY(...)end})end;local function dD()local aM={}local dE=30000000/3600;local dF=dE*dE;local dG=100;function aM.computeAccelerationTime(dH,dI,dJ)local dK=dE*math.asin(dH/dE)return(dE*math.asin(dJ/dE)-dK)/dI end;function aM.computeDistanceAndTime(dH,dJ,dL,dM,dN,dO)dN=dN or 0;dO=dO or 0;local dP=dH<=dJ;local dQ=dM*(dP and 1 or-1)/dL;local dR=-dO/dL;local dS=dQ+dR;if dP and dS<=0 or not dP and dS>=0 then return-1,-1 end;local dT,dU=0,0;if dQ~=0 and dN>0 then local dK=math.asin(dH/dE)local dV=math.pi*(dQ/2+dR)local dW=dQ*dN;local dX=dE*math.pi;local ce=function(ck)local dY=(dV*ck-dW*math.sin(math.pi*ck/2/dN)+dX*dK)/dX;local dZ=math.tan(dY)return dE*dZ/y(dZ*dZ+1)end;local d_=dP and function(cm)return cm>=dJ end or function(cm)return cm<=dJ end;dU=2*dN;if d_(ce(dU))then local e0=0;while d(dU-e0)>0.5 do local ck=(dU+e0)/2;if d_(ce(ck))then dU=ck else e0=ck end end end;local e1=dH;local e2=dU/dG;for e3=1,dG do local e4=ce(e3*e2)dT=dT+(e4+e1)*e2/2;e1=e4 end;if dU<2*dN then return dT,dU end;dH=e1 end;local dK=dE*math.asin(dH/dE)local E=(dE*math.asin(dJ/dE)-dK)/dS;local e5=dF*math.cos(dK/dE)/dS;local aj=e5-dF*math.cos((dS*E+dK)/dE)/dS;return aj+dT,E+dU end;function aM.computeTravelTime(dH,dI,aj)if aj==0 then return 0 end;if dI>0 then local dK=dE*math.asin(dH/dE)local e5=dF*math.cos(dK/dE)/dI;return(dE*math.acos(dI*(e5-aj)/dF)-dK)/dI end;if dH==0 then return-1 end;assert(dH>0,'Acceleration and initial speed are both zero.')return aj/dH end;return aM end;local function e6()local vec3=require('cpml.vec3')local cf=cf()local function cl(cm)return type(cm)=='string'end;local function cj(ck)return type(ck)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cP)assert(self.body)local aj=cP+self.body.radius;if not bZ(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cM,e7)assert(self.body)assert(cj(cM)or cl(cM))assert(cj(e7))local e8=(cl(cM)or cf.isMapPosition(cM))and self.body:convertToWorldCoordinates(cM)or vec3(cM)local ce=vec3(e7)local e9=e8-self.body.center;local ea=ce:len2()local eb=e9:len()local ec=self.body.GM;local ed=((ea-ec/eb)*e9-e9:dot(ce)*ce)/ec;local b_=ec/(2*ec/eb-ea)local ee=ed:len()local dj=ed:normalize()local ef=b_*(1-ee)local eg=b_*(1+ee)local eh=ef*dj+self.body.center;local ei=ee<=1 and-eg*dj+self.body.center or nil;local ej=y(b_*ec*(1-ee*ee))local ek=ei and 2*math.pi*y(b_^3/ec)local el=math.acos(ed:dot(e9)/(ee*eb))if e9:dot(ce)<0 then el=-(el-2*math.pi)end;local em=math.acos((math.cos(el)+ee)/(1+ee*math.cos(el)))local en=em;if en<0 then en=en+2*math.pi end;local eo=en-ee*math.sin(en)local ep=0;local eq=0;local er=0;if ek~=nil then ep=eo/(2*math.pi/ek)eq=ek-ep;er=eq+ek/2;if el-math.pi>0 then eq=ep;er=eq+ek/2 end;if er>ek then er=er-ek end end;return{periapsis={position=eh,speed=ej/ef,circularOrbitSpeed=y(ec/ef),altitude=ef-self.body.radius},apoapsis=ei and{position=ei,speed=ej/eg,circularOrbitSpeed=y(ec/eg),altitude=eg-self.body.radius},currentVelocity=ce,currentPosition=e8,eccentricity=ee,period=ek,eccentricAnomaly=em,meanAnomaly=eo,timeToPeriapsis=eq,timeToApoapsis=er,trueAnomaly=el}end;local function es(et)local du=cf.BodyParameters(et.systemId,et.id,et.radius,et.center,et.GM)return setmetatable({body=du},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return es(...)end})end;local function eu()local ev={}local ew={}local ex={XS=13,S=27,M=55,L=110,XL=221}local ey={}local ez;local eA;local eB;local eC;local eD;local eE={}local eF="Atmo"local function eG()local function eH(eI,eJ,eK,eL,eM,eN,eO,eP)eJ,eL,eN,eP=vec3(eJ),vec3(eL),vec3(eN),vec3(eP)local eQ,eR,eS=eI*eI,eK*eK,eM*eM;local ea=eL-eJ;local eT=ea:normalize()local eU=ea:len()local eV=eN-eJ;local eW=(eV-eV:project_on(eT)):normalize()local eX,eY=eV:dot(eT),eV:dot(eW)local eZ=eX*eX+eY*eY;local e_=eT:cross(eW)local bU=(eQ-eR+eU*eU)/(2*eU)local bV=(eQ-eS+eZ-2*eX*bU)/(2*eY)local cp=eQ-bU^2-bV^2;local f0=y(cp)local f1=eJ+eT*bU+eW*bV+e_*f0;local f2=eJ+eT*bU+eW*bV-e_*f0;if d((eP-f1):len()-eO)<d((eP-f2):len()-eO)then return f1 else return f2 end end;local function f3()local function f4()local f5=core.getConstructWorldOrientationRight()local ea=core.getConstructWorldOrientationForward()local eV=core.getConstructWorldOrientationUp()local f6=library.systemResolution3(f5,ea,eV,{1,0,0})local f7=library.systemResolution3(f5,ea,eV,{0,1,0})local f8=library.systemResolution3(f5,ea,eV,{0,0,1})return function(f9)return library.systemResolution3(f6,f7,f8,f9)end end;local fa=f4()local fb=core.getConstructWorldPos()local e8=core.getElementPositionById(1)local fc={e8[1],e8[2],e8[3]}local fd=fa(fc)local fe={fb[1]-fd[1],fb[2]-fd[2],fb[3]-fd[3]}return fe end;local function ff(fg,eb,fh)local fi=fg.pts;local fj=#fi;local fk=fg.ref;if fj>3 then local fl,fm,fn,fo=fi[fj],fi[fj-1],fi[fj-2],fi[fj-3]fg.ref=fh;local e8=eH(fl[1],fl[2],fm[1],fm[2],fn[1],fn[2],fo[1],fo[2])local bU,bV,f0=e8.x,e8.y,e8.z;if bU==bU and bV==bV and f0==f0 then bU=bU+fk[1]bV=bV+fk[2]f0=f0+fk[3]local fp=vec3(bU,bV,f0)if not fg.lastPos then fg.center=fp elseif(fg.lastPos-fp):len()<2 then fg.center=fp;fg.skipCalc=true end;fg.lastPos=fp end;fg.pts={}else local fq={fh[1]-fk[1],fh[2]-fk[2],fh[3]-fk[3]}fi[fj+1]={eb,fq}end end;if radar_1 or radar_2 then aS.assignRadar()end;if eE[1]then ez=#eE[1].getConstructIds()local fr=eE[1].getData()local fs=fr:gmatch('{"constructId[^}]*}[^}]*}')if ez>0 then local fh=f3()local ft,fu=0,0;eD,eC=0,0;for ce in fs do local cH,aj,fv=ce:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fw=ex[fv]aj=z(aj)if eE[1].hasMatchingTransponder(cH)==1 then table.insert(ew,cH)end;local fx=eE[1].getConstructType(cH)if CollisionSystem then if fw>27 or fx=="static"or fx=="space"then eD=eD+1;local fy=eE[1].getConstructName(cH)local fg=bq[cH]if fg==nil then fw=fw+G;bq[cH]={pts={},ref=fh,name=fy,i=0,radius=fw,skipCalc=false}fg=bq[cH]end;if not fg.skipCalc then ff(fg,aj,fh)fu=fu+1 end;if fg.center then table.insert(ey,fg)end end;ft=ft+1;if br and ft>700 or fu>70 or(not br and ft>300 or fu>30)then coroutine.yield()ft,fu=0,0 end end end;eC=#ey;if eC>0 and bc>20 then local d9,fz,fA,fB;local fC=0;local fD=aL:getPlanetarySystem(0)fB=bb:normalize()while fC<eC do coroutine.yield()local fE={table.unpack(ey,fC,math.min(fC+75,eC))}d9,fz,fA=fD:castIntersections(bf,fB,nil,nil,fE,true)if d9 and fA then bt={d9,fz,fA}break end;fC=fC+75 end;if not d9 then bt=nil end else bt=nil end;ey={}eA=fr:find('identifiedConstructs":%[%]')else eB=fr:find('worksInEnvironment":false')end end end;local function fF()if eE[1]then eF="Atmo"if eE[1].getData():find('worksInAtmosphere":false')then eF="Space"end end end;function ev.pickType()fF()end;function ev.assignRadar()if radar_1 and eE[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then eE[1]=radar_2 end;if eE[1]==radar_2 then fF()end elseif radar_2 and eE[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then eE[1]=radar_1 end;if eE[1]==radar_1 then fF()end end end;function ev.UpdateRadar()local fG=coroutine.status(UpdateRadarCoroutine)if fG=="suspended"then local cz,fH=coroutine.resume(UpdateRadarCoroutine)if fH then system.print("ERROR UPDATE RADAR: "..fH)end elseif fG=="dead"then UpdateRadarCoroutine=coroutine.create(eG)local cz,fH=coroutine.resume(UpdateRadarCoroutine)end end;function ev.GetRadarHud(fI,fJ,fK,fL)local fM=ew;local fN,bC;ew={}local B=eC or 0;if ez>0 then if CollisionSystem then bC=B.."/"..eD.." Plotted : "..ez-eD.." Ignored"else bC="Radar Contacts: "..ez end;fN=bT(fK,fL,bC,"pbright txtbig txtmid")if#ew>0 then fN=fN..bT(fI,fJ,"Friendlies In Range","pbright txtbig txtmid")for cd,ce in pairs(ew)do fJ=fJ+20;fN=fN..bT(fI,fJ,eE[1].getConstructName(ce),"pdim txtmid")end end;if eA==nil and perisPanelID==nil then peris=1;aS.ToggleRadarPanel()end;if eA~=nil and perisPanelID~=nil then aS.ToggleRadarPanel()end;if radarPanelID==nil then aS.ToggleRadarPanel()end else if eB then fN=bT(fK,fL,eF.." Radar: Jammed","pbright txtbig txtmid")else fN=bT(fK,fL,"Radar: No "..eF.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then peris=0;aS.ToggleRadarPanel()end end;return fN end;function ev.GetClosestName(fy)if eE[1]then local cH,_=eE[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cH~=nil and cH~=""then fy=fy.." "..eE[1].getConstructName(cH)end end;return fy end;function ev.ToggleRadarPanel()if radarPanelID~=nil and peris==0 then t(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then t(perisPanelID)perisPanelID=nil end else if peris==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(eE,1,"Periscope","periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(eE,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;peris=0 end end;eE[1]=nil;if radar_1 then eE[1]=radar_1;fF()end;UpdateRadarCoroutine=coroutine.create(eG)return ev end;local function fO()local fP=9.80665;local fQ={}local fR={}local fS={}local bw={}local fT=nil;local fU=nil;local fV=nil;local fW=false;local fX={}local fY=""local fZ=vec3({13771471,7435803,-128971})local f_=18000000;local g0=500000;local g1,g2=math.huge;local g3;local function g4(g5)g1=vec3(g5):dist(fZ)if g1<f_ then return true,d(g1-f_)end;g2=vec3(g5):dist(vec3(planet.center))if g2<g0 then g3=true else g3=false end;if d(g2-g0)<d(g1-f_)then return g3,d(g2-g0)else return g3,d(g1-f_)end end;local function g6(ce)if aD==1920 then return ce else return A(aD*ce/1920,0)end end;local function g7(ce)if aE==1080 then return ce else return A(aE*ce/1080,0)end end;local function g8()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function g9()local ga="TRAVEL"if not bj then ga="CRUISE"end;if Autopilot then ga="AUTOPILOT"end;return ga end;local gb={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local fN=""local gc=""local gd=""local ge=1;local gf=2;local gg=3;local gh=4;local gi=5;local gj=6;local gk=""local gl=0;local gm=e(1/apTickRate)*2*hudTickRate;local gn={}local go={}local gp={}local gq={}local gr={}local gs={}local function gt(bU,gu,gv,gw,gx,gy)local gz=tankY;local gA=tankY+5;if not BarFuelDisplay then gA=gA+5 end;if m()==1 and not RemoteHud then gz=gz-50;gA=gA-50 end;if gv=="ATMO"then gk="atmofueltank"elseif gv=="SPACE"then gk="spacefueltank"else gk="rocketfueltank"end;gl=_G[gk.."_size"]if#gw>0 then for i=1,#gw do local fy=string.sub(gw[i][gf],1,12)local gB=0;for gC=1,gl do if gw[i][gf]==g(unit[gk.."_"..gC].getData()).name then gB=gC;break end end;local gD=q()if gx[i]==nil or gy[i]==nil or gD-gw[i][gj]>gm then local gE;local gF=0;if gB~=0 then gy[i]=g(unit[gk.."_"..gB].getData()).percentage;gx[i]=g(unit[gk.."_"..gB].getData()).timeLeft;if gx[i]=="n/a"then gx[i]=0 end else gF=l(gw[i][ge])-gw[i][gh]gy[i]=e(0.5+gF*100/gw[i][gg])gE=gw[i][gi]if gE<=gF then gx[i]=0 else gx[i]=e(0.5+gF/((gE-gF)/(gD-gw[i][gj])))end;gw[i][gi]=gF;gw[i][gj]=gD end end;if fy==gu then fy=f("%s %d",gv,i)end;if gB==0 then fy=fy.." *"end;local gG;if gx[i]==0 then gG=""else gG=c4(gx[i])end;if gy[i]~=nil then local gH=e(gy[i]*2.55)local gI=f("rgb(%d,%d,%d)",255-gH,gH,0)local bX=""if gG~=""and gx[i]<120 or gy[i]<5 then bX="red "end;local gJ=f("rgb(%d,%d,%d)",r(e((255-gH)/2.55),50,100),r(e(gH/2.55),0,50),50)local gK="rgb(196,0,255)"if gv=="ATMO"then gK="rgb(0,188,255)"elseif gv=="SPACE"then gK="rgb(239,255,0)"end;local gL=false;if previous~=gK then gL=true end;previous=gK;if BarFuelDisplay then if gL then gz=gz-5;gA=gA-5 end;gc=gc..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gJ,gK,bU,gA,gI,e(gy[i]*1.7+0.5)-2,bU+1,gA+1,bU+5,gA+14,fy,gy[i],gG)gz=gz-22;gA=gA-22 else gc=gc..bT(bU,gz,fy,bX.."pdim txtfuel")gc=gc..bT(bU,gA,f("%d%% %s",gy[i],gG),"pdim txtfuel","fill:"..gI)gz=gz+30;gA=gA+30 end end end end;tankY=gz end;local function gM(gN,cP)if vSpdMeterX==0 and vSpdMeterY==0 then return end;if cP<200000 and not aq or cP and aq then local gO=0;if d(be)>1 then gO=45*math.log(d(be),10)if be<0 then gO=-gO end end;gN[#gN+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(be),e(gO))end;return gN end;local function gP(gQ)local gR=-bd;gQ=gQ-gQ:project_on(gR)local gS=vec3(0,0,1)gS=gS-gS:project_on(gR)local gT=gS:cross(gR)local gO=gS:angle_between(gQ)*constants.rad2deg;if gQ:dot(gT)<0 then gO=360-gO end;return gO end;local function gU(gN,centerX,centerY,gV,gW,br)if circleRad==0 then return end;local gX=circleRad;local gY=20;local gZ=e(gV)if br then for i=-45,45,5 do local g_=i;gN[#gN+1]=f([[<g transform="rotate(%f,%d,%d)">]],g_,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gN[#gN+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gX+gY-len,centerX,centerY+gX+gY)end;gN[#gN+1]=bT(centerX,centerY+gX+gY-35,gW,"pdim txt txtmid")gN[#gN+1]=bT(centerX,centerY+gX+gY-25,gZ.." deg","pdim txt txtmid")gN[#gN+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gV,centerX,centerY)gN[#gN+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gX+gY-20,centerX+5,centerY+gX+gY-20,centerX,centerY+gX+gY-15)gN[#gN+1]="</g>"end;gN[#gN+1]=[[<g style="clip-path: url(#headingClip);">]]local h0=gZ;if br then h0=gP(b8)end;local h1=20;local h2=e(h0)local h3=0;local h4=centerY+gX+gY+20;local h5=centerX;if gW~="YAW"then h4=g7(130)h5=g6(960)end;local h6=[[<path class="txttick line" d="]]local h7=e(h2-(h1+10)-h2%5+0.5)for i=h7+70,h7,-5 do local bU=h5-(-i*5+h0*5)if i%10==0 then h3=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gN[#gN+1]=bT(bU,h4+15,B,"txtmid bright")elseif i%5==0 then h3=5 end;if h3==10 then h6=f([[%s M %f %f v %d]],h6,bU,h4-5,h3)else h6=f([[%s M %f %f v %d]],h6,bU,h4-2.5,h3)end end;gN[#gN+1]=h6 ..[["/>]]gN[#gN+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],h5-5,h4-20,h5+5,h4-20,h5,h4-10)if DisplayOdometer then if br then gW="HDG"end;gN[#gN+1]=bT(g6(960),g7(100),h2 .."Â°","dim txt txtmid size14","")gN[#gN+1]=bT(g6(960),g7(85),gW,"dim txt txtmid size20","")end;gN[#gN+1]=[[</g>]]end;local function h8(gN,h9,gV,centerX,centerY,br,ha,e4)if circleRad==0 then return end;local gX=circleRad;local hb=e(gX*3/5)if gX>0 then local hc=e(h9)local len=0;local h6=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gV,centerX,centerY)if not aq then h6=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gN[#gN+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gX-1,centerX,centerY)gN[#gN+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hc-30-hc%5+0.5),e(hc+30+hc%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bV=centerY+-i*5+h9*5;if len==30 then h6=f([[%s M %d %f h %d]],h6,centerX-hb-len,bV,len)if aq then gN[#gN+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gV,centerX,centerY,centerX-hb+10,bV+4,i)gN[#gN+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gV,centerX,centerY,centerX+hb-10,bV+4,i)if i==0 or i==180 or i==-180 then gN[#gN+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gV,centerX,centerY,centerX-hb+20,bV,hb*2-40)end else gN[#gN+1]=bT(centerX-hb+10,bV,i,"pdim txt txtmid")gN[#gN+1]=bT(centerX+hb-10,bV,i,"pdim txt txtmid")end;h6=f([[%s M %d %f h %d]],h6,centerX+hb,bV,len)else h6=f([[%s M %d %f h %d]],h6,centerX-hb-len,bV,len)h6=f([[%s M %d %f h %d]],h6,centerX+hb,bV,len)end end;gN[#gN+1]=h6 ..[["/>]]local hd="PITCH"if not br then hd="REL PITCH"end;if h9>90 and not aq then h9=90-(h9-90)elseif h9<-90 and not aq then h9=-90-(h9+90)end;if gX>200 then if aq then if e4>Q then gN[#gN+1]=bT(centerX,centerY-15,"Yaw","pdim txt txtmid")gN[#gN+1]=bT(centerX,centerY+20,ha,"pdim txt txtmid")end;gN[#gN+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gV,centerX,centerY)else gN[#gN+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gN[#gN+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hb+25,centerY-5,centerX-hb+20,centerY,centerX-hb+25,centerY+5,centerX-hb+50,centerY+4,hc)gN[#gN+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hb-25,centerY-5,centerX+hb-20,centerY,centerX+hb-25,centerY+5,centerX+hb-30,centerY+4,hc)gN[#gN+1]="</g>"end;local he=e(gX/3)gN[#gN+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-he,centerY,gX-he)if not aq and br then gN[#gN+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gV,centerX,centerY,centerX-hb+10,centerY,hb*2-20)end;gN[#gN+1]="</g>"if gX<200 then if aq and e4>Q then gN[#gN+1]=bT(centerX,centerY-gX,hd,"pdim txt txtmid")gN[#gN+1]=bT(centerX,centerY-gX+10,hc,"pdim txt txtmid")gN[#gN+1]=bT(centerX,centerY-15,"Yaw","pdim txt txtmid")gN[#gN+1]=bT(centerX,centerY+20,ha,"pdim txt txtmid")else gN[#gN+1]=bT(centerX,centerY-gX,hd,"pdim txt txtmid")gN[#gN+1]=bT(centerX,centerY-gX+15,hc,"pdim txt txtmid")end end end end;local function hf(gN,cP,br)local hg=altMeterX;local hh=altMeterY;if hg==0 and hh==0 then return end;local hi=78;local hj=19;local hk=ao;if ao~=-1 then gN[#gN+1]=bT(hg+hi,hh+hj+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if br and(cP<200000 and not aq or cP and aq)then table.insert(gN,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hg-1,hh-4,hi+2,hj+6,hg+1,hh-1,hi-4,hj))local fj=0;local hl=1;local hm=0;local hn=cP<0;local ho=cP<planet.surfaceMaxAltitude;local hp=9;if hn then hp=0 end;local cP=d(cP)while fj<6 do local hq=11;local hr=16;local hs=9;local ht=14;local bX="altsm"if fj>2 then hr=hr+3;hq=hq+2;ht=ht+2;hs=hs-6;bX="altbig"end;if hn then bX=bX.." red"elseif ho then bX=bX.." orange"end;local hu=cP/hl%10;local hv=e(hu)local hw=e((hv+1)%10)local hx=hm;if fj==0 then hx=hu-hv;if hn then hx=1-hx end end;if hn and(fj==0 or hm~=0)then local hy=hw;hw=hv;hv=hy end;local hz=hr*(hx-1)local hA=hz+hr;local bU=hg+hs+(6-fj)*hq;local bV=hh+ht;gN[#gN+1]=bT(bU,bV+hz,hw,bX)gN[#gN+1]=bT(bU,bV+hA,hv,bX)fj=fj+1;hl=hl*10;if hv==hp then hm=hx else hm=0 end end;table.insert(gN,[[</g></g>]])end end;local function hB(e7)local hC=-math.deg(n(e7.y,e7.z))+180;hC=hC-90;if hC<0 then hC=360+hC end;if hC>180 then hC=-180+hC-180 end;return-hC end;local function hD(e7)local h0=math.deg(n(e7.y,e7.x))-90;if h0<-180 then h0=360+h0 end;return h0 end;local function hE(gN,e7,e4,centerX,centerY)if e4>5 and not aq or e4>Q then local gX=circleRad;local hF=20;local hG=20;local hH=hB(e7)local hI=hD(e7)local hJ=14;local hK=hJ/2;local hL=-hI/hG*gX;local hM=hH/hF*gX;local bU=centerX+hL;local bV=centerY+hM;local aj=y(hL^2+hM^2)local hN=[[<circle
                            cx="]]..bU..[["
                            cy="]]..bV..[["
                            r="]]..hK/hJ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bU..[["
                            cy="]]..bV..[["
                            r="]]..hK..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bU-hJ..[[,]]..bV..[[ h ]]..hK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bU+hK..[[,]]..bV..[[ h ]]..hK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bU..[[,]]..bV-hJ..[[ v ]]..hK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<gX then gN[#gN+1]=hN else local gO=n(hM,hL)local hO=4;local hP=centerX+gX*math.cos(gO)local hQ=centerY+gX*math.sin(gO)gN[#gN+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gO*180/math.pi,hP,hQ,hP-hO,hQ-hO/2,hO*2,hO,hP+hO,hQ-hO,hO,hO,-hO,hO)end;if not aq then local hR=vec3(e7)hH=hB(-hR)hI=hD(-hR)hL=-hI/hG*gX;hM=hH/hF*gX;bU=centerX+hL;bV=centerY+hM;aj=y(hL^2+hM^2)if aj<gX then local hS=[[<circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bU..[[,]]..bV-hJ..[[ v ]]..hK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bU..[[,]]..bV..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bU..[[,]]..bV..[[)" />
                                <path
                                    d="M ]]..bU-hK..[[,]]..bV..[[ h ]]..hJ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bU..[[,]]..bV..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bU..[[,]]..bV..[[)"/>]]gN[#gN+1]=hS end end end end;local function hT(gN,ga,hU,hV)if throtPosX==0 and throtPosY==0 then return end;hU=e(hU+0.5)local gz=throtPosY+10;local gA=throtPosY+20;if m()==1 and not RemoteHud then gz=55;gA=65 end;local hW="CRUISE"local unit="km/h"local cz=hV;if ga=="TRAVEL"or ga=="AUTOPILOT"then hW="THROT"unit="%"cz=hU;local hX="dim"if hU<0 then hX="red"end;gN[#gN+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hX,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(hU),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gN[#gN+1]=bT(throtPosX+10,gz,hW,"pbright txtstart")gN[#gN+1]=bT(throtPosX+10,gA,f("%.0f %s",cz,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bj and M then hU=e(N*100+0.5)local hX="red"if hU<0 then hX="red"end;gN[#gN+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hX,1-d(hU),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gN[#gN+1]=bT(throtPosX+10,gz+40,"LIMIT","pbright txtstart")gN[#gN+1]=bT(throtPosX+10,gA+40,hU.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gN[#gN+1]=bT(throtPosX+10,gz-40,"LIMIT: "..aZ.." km/h","dim txtstart")elseif not aq and Autopilot then gN[#gN+1]=bT(throtPosX+10,gz-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hY(gN,hZ)if throtPosX==0 and throtPosY==0 then return end;local h_=throtPosY-10;local i0=throtPosX+10;gN[#gN+1]=bT(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then h_=75 end;gN[#gN+1]=bT(i0,h_,e(hZ).." km/h","pbright txtbig txtstart")end;local function i1(gN)gN[#gN+1]=bT(g6(1900),g7(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gN[#gN+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gN[#gN+1]=bT(g6(960),g7(550),"Warning: Invalid Control Scheme Detected","warnings")gN[#gN+1]=bT(g6(960),g7(600),"Keyboard Scheme must be selected","warnings")gN[#gN+1]=bT(g6(960),g7(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local i2=g6(960)local i3=g7(860)local i4=g7(880)local i5=g7(900)local i6=g7(960)local i7=g7(200)local i8=g7(250)local i9=g7(960)if m()==1 and not RemoteHud then i3=g7(135)i4=g7(155)i5=g7(175)i7=g7(115)i8=g7(95)end;local ia="#222222"local ib="white"local ic="dimmer"local id="pbright"local ie="#110000"local ig=ia;local ih=ic;if BrakeIsOn then gN[#gN+1]=bT(i2,i3,"Brake Engaged","warnings")ie="#440000"ig=ib;ih=id elseif L>0 then gN[#gN+1]=bT(i2,i3,"Auto-Brake Engaged","warnings","opacity:"..L)end;local ii="#110000"local ij=ia;local ik=ic;if aq and aX and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bh and not VertTakeOff and not AutoTakeoff then gN[#gN+1]=bT(i2,i7+50,"** STALL WARNING **","warnings")ii="#ff0000"ij=ib;ik=id;bG("stall","SW",2)end end;if bp then gN[#gN+1]=bT(i2,i7+90,"Flight Assist in Progress","warnings")end;if ax then gN[#gN+1]=bT(i2,i9,"Gyro Enabled","warnings")end;local il="#111100"local im=ia;local io=ic;if GearExtended then il="#775500"im=ib;io=id;if S then gN[#gN+1]=bT(i2,i4,"Gear Extended","warn")else gN[#gN+1]=bT(i2,i4,"Landed (G: Takeoff)","warnings")end;local ip=c1(a:getTargetGroundAltitude())gN[#gN+1]=bT(i2,i5,"Hover Height: "..ip,"warn")end;local iq="#000011"local ir=ia;local is=ic;if a7 then iq="#0000DD"ir=ib;is=id;gN[#gN+1]=bT(i2,i6+20,"ROCKET BOOST ENABLED","warn")end;local it="#001100"local iu=ia;local iv=ic;if antigrav and not ExternalAGG and bh and AntigravTargetAltitude~=nil then it="#00DD00"iu=ib;iv=id;if d(as-antigrav.getBaseAltitude())<501 then gN[#gN+1]=bT(i2,i7+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gN[#gN+1]=bT(i2,i7+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gN[#gN+1]=bT(i2,i7+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gN[#gN+1]=bT(i2,i7+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gN[#gN+1]=bT(i2,i7+20,"Follow Mode Engaged","warn")elseif Reentry or an then gN[#gN+1]=bT(i2,i7+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ip=c1(HoldAltitude,2)if VertTakeOff then if bh then ip=c1(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gN[#gN+1]=bT(i2,i7,"VTO to "..ip,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gN[#gN+1]=bT(i2,i7,"Takeoff to "..AutopilotTargetName,"warn")else gN[#gN+1]=bT(i2,i7,"Takeoff to "..ip,"warn")end;if BrakeIsOn and not VertTakeOff then gN[#gN+1]=bT(i2,i7+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gN[#gN+1]=bT(i2,i7,"Altitude Hold: "..ip,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gN[#gN+1]=bT(i2,i7+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gN[#gN+1]=bT(i2,i7+20,"Aligning trajectory","warn")elseif ar<0.05 then gN[#gN+1]=bT(i2,i7+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b0~=nil then gN[#gN+1]=bT(i2,i7,b0,"warn")end end;if BrakeLanding then if StrongBrakes then gN[#gN+1]=bT(i2,i7,"Brake-Landing","warnings")else gN[#gN+1]=bT(i2,i7,"Coast-Landing","warnings")end end;if ProgradeIsOn then gN[#gN+1]=bT(i2,i7,"Prograde Alignment","crit")end;if RetrogradeIsOn then gN[#gN+1]=bT(i2,i7,"Retrograde Alignment","crit")end;local iw="#110000"local ix=ia;local iy=ic;if bs then iw="#FF0000"ix=ib;iy=id;local type;if string.find(bs,"COLLISION")then type="warnings"else type="crit"end;gN[#gN+1]=bT(i2,i8+20,bs,type)elseif ar==0 then local iz,iA=aR.checkLOS(bb:normalize())if iA~=nil then iy=id;iw="#FF0000"ix=ib;local ip=c1(iA)local travelTime=aM.computeTravelTime(bc,0,iA)local iB="Collision"if iz.noAtmosphericDensityAltitude>0 then iB="Atmosphere"end;gN[#gN+1]=bT(i2,i8+20,iz.name.." "..iB.." "..c4(travelTime).." In "..ip,"crit")end end;if VectorToTarget and not IntoOrbit then gN[#gN+1]=bT(i2,i7+35,VectorStatus,"warn")end;local iC="#111100"local iD=ia;local iE=ic;if bx and#bx>1 then iC="#DDDD00"iD=ib;iE=id end;local iF=g6;local iG=g7;local ic="topButton"local iH="topButtonActive"local iI=ic;if Autopilot or VectorToTarget or am or IntoOrbit then iI=iH end;local iJ=ic;if ProgradeIsOn then iJ=iH end;local iK=ic;if BrakeLanding or GearExtended then iK=iH end;local iL=ic;if AltitudeHold or VectorToTarget then iL=iH end;local iM=ic;if RetrogradeIsOn then iM=iH end;local iN=ic;if IntoOrbit or b3 and Autopilot then iN=iH end;if showHud and DisplayOdometer then local iO=iG(30)gN[#gN+1]=f([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],iI,iF(960),iG(54),iG(-53),iF(-120),iF(25),iG(50))gN[#gN+1]=bT(iF(910),iO,"AUTOPILOT")gN[#gN+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iJ,iF(865),iG(51),iF(-25),iG(-50),iF(-110),iF(25),iG(46))gN[#gN+1]=bT(iF(800),iO,"PROGRADE")gN[#gN+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iK,iF(755),iG(47),iF(-25),iG(-46),iF(-98),iF(44),iG(44))gN[#gN+1]=bT(iF(700),iO,"LAND")gN[#gN+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],iL,iF(960),iG(54),iG(-53),iF(120),iF(-25),iG(50))gN[#gN+1]=bT(iF(1010),iO,"ALT HOLD")gN[#gN+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iM,iF(1055),iG(51),iF(25),iG(-50),iF(110),iF(-25),iG(46))gN[#gN+1]=bT(iF(1122),iO,"RETROGRADE")gN[#gN+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iN,iF(1165),iG(47),iF(25),iG(-46),iF(98),iF(-44),iG(44))gN[#gN+1]=bT(iF(1220),iO,"ORBIT")gN[#gN+1]=[[
                                    </g>
                                </g>]]gN[#gN+1]="</g>"end;return gN end;local function iP(e4)return e(A(e4*3.6,0)+0.5).." km/h"end;local function iQ(gN)local bU=OrbitMapX+10;local bV=OrbitMapY+20;local iR={}local iS={"Alt-4: AutoTakeoff to Target"}local iT={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iU={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iV={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iR,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then bJ(iR,iS)if ac and planet and ac.name==planet.name then table.insert(iR,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bh then table.insert(iR,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iR,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iR,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iR,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iR,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iR,"G: Takeoff to hover height, raise gear")else table.insert(iR,"G: Lowergear and Land")end else bJ(iR,iT)table.insert(iR,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iR,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bJ(iR,iU)if shield_1 then table.insert(iR,"Alt-Shift-5: Toggle shield off and on")table.insert(iR,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iR,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iR,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iR,"Alt-Spacebar/C will raise/lower target height")table.insert(iR,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iR,"LALT+Mousewheel will lower/raise speed limit")end;bJ(iR,iV)for i=1,#iR do bV=bV+12;gN[#gN+1]=bT(bU,bV,iR[i],"pdim txtbig txtstart")end end;local function iW(gN)local iX=OrbitMapX;local iY=OrbitMapY;local iZ=OrbitMapSize;local i_=4;local j0=15;local bU=0;local bV=0;local j1,j2,j3,j4;local j5;local function j6(type)local j7,E,e4,j8,bX,j9;if type=="Periapsis"then j7=j5.periapsis.altitude;E=j5.timeToPeriapsis;e4=j5.periapsis.speed;bX="txtend"j8=12;j9=math.min(bU,iX+iZ-planet.radius/j3-i_*2)else j7=j5.apoapsis.altitude;E=j5.timeToApoapsis;e4=j5.apoapsis.speed;j8=-12;bX="txtstart"j9=bU end;if bc<1 then E=0 end;gN[#gN+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j9+j8,bV-5,bU,bV-5)gN[#gN+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j9-j8*4,bV+2,bU,bV+2)gN[#gN+1]=bT(j9,bV,type,bX)bU=j9-j8*2;bV=bV+j0;local ip=c1(j7)gN[#gN+1]=bT(bU,bV,ip,bX)bV=bV+j0;gN[#gN+1]=bT(bU,bV,c4(E),bX)bV=bV+j0;gN[#gN+1]=bT(bU,bV,iP(e4),bX)end;local ja=iZ*1.5;if SelectedTab=="INFO"then ja=25*7 end;if SelectedTab~="HIDE"then gN[#gN+1]=[[<g class="pbright txtorb txtmid">]]gN[#gN+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',iZ*2,ja,iX,iY)gN[#gN+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],iZ*2,ja,iX,iY)end;local jb=iZ*1.5;local jc=iZ*2;local jd=jb/2;local je=iZ;local jf=iX+je;local jg=iY+jd;local jh=iX+jc;local ji=iY+jb;if SelectedTab=="ORBIT"then iY=iY+i_;j1=iZ/2;j4=0;j5={}j5.periapsis={}j5.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then j5.periapsis.altitude=orbit.periapsis.altitude;j5.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then j5.apoapsis.altitude=orbit.apoapsis.altitude;j5.apoapsis.speed=orbit.apoapsis.speed end;j5.period=orbit.period;j5.eccentricity=orbit.eccentricity;j5.timeToApoapsis=orbit.timeToApoapsis;j5.timeToPeriapsis=orbit.timeToPeriapsis;j5.eccentricAnomaly=orbit.eccentricAnomaly;j5.trueAnomaly=orbit.trueAnomaly end;if j5.periapsis==nil then j5.periapsis={}j5.periapsis.altitude=-planet.radius;j5.periapsis.speed=MaxGameVelocity end;if j5.eccentricity==nil then j5.eccentricity=1 end;if j5.apoapsis==nil then j5.apoapsis={}j5.apoapsis.altitude=as;j5.apoapsis.speed=0 end;if bc<1 then j5.apoapsis.altitude=as;j5.apoapsis.speed=0 end;if j5.apoapsis.altitude then j3=(j5.apoapsis.altitude+j5.periapsis.altitude+planet.radius*2)/(j1*2)j2=(planet.radius+j5.apoapsis.altitude)/j3*(1-j5.eccentricity)j4=j1-j5.periapsis.altitude/j3-planet.radius/j3;local jj=math.pi;if j5.period~=nil and j5.period>0 and j5.timeToApoapsis~=nil then jj=j5.eccentricAnomaly;if j5.timeToPeriapsis<j5.timeToApoapsis then jj=2*math.pi-jj end end;if bc<1 or jj~=jj then jj=math.pi end;local jk=-j1*math.cos(jj)+iX+je+i_;local jl=j2*math.sin(jj)+iY+jd+i_;local jm=""gN[#gN+1]='<g clip-path="url(#orbitRect)">'gN[#gN+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jm,iX+iZ+i_,iY+iZ*1.5/2+i_,j1,j2)if j2<1 then gN[#gN+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iX+iZ+i_-j4,iY+iZ*1.5/2+i_,jk,jl)end;gN[#gN+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iX+iZ+i_-j4,iY+iZ*1.5/2+i_,(planet.radius+planet.noAtmosphericDensityAltitude)/j3)gN[#gN+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iX+iZ+i_-j4,iY+iZ*1.5/2+i_,(planet.radius+planet.noAtmosphericDensityAltitude)/j3)gN[#gN+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iX+iZ+i_,iY+iZ*1.5/2+i_,j1,j2)gN[#gN+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iX+iZ+i_-j4,iY+iZ*1.5/2+i_,planet.radius/j3)gN[#gN+1]='</g>'local jn=math.floor(planet.radius/j3+0.5)local jo=gb.Generic_Moon;if gb[planet.name]then jo=gb[planet.name]end;bU=iX+iZ+i_*4+j1;bV=iY+iZ*1.5/2+5+i_;if j5.apoapsis~=nil and j5.apoapsis.speed<MaxGameVelocity then j6("Apoapsis")end;bV=iY+iZ*1.5/2+5+i_;bU=iX+iZ-i_*2-j1;if j5.periapsis~=nil and j5.periapsis.speed<MaxGameVelocity and j5.periapsis.altitude>0 then j6("Periapsis")end;gN[#gN+1]=bT(iX+iZ+i_,iY+20+i_,planet.name,"txtorbbig")gN[#gN+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jk,jl)gN[#gN+1]=[[</g>]]return gN else gN[#gN+1]='<g clip-path="url(#orbitRect)">'local jp=""local jq=1.2*(maxAtlasX-minAtlasX)/(iZ*2)local jr=1.4*(maxAtlasY-minAtlasY)/(iZ*1.5)for cd,ce in pairs(b[0])do if ce.center then local bU=iX+iZ+ce.center.x/jq;local bV=iY+iZ*1.5/2+ce.center.y/jr;jp=jp..'<circle cx="'..bU..'" cy="'..bV..'" r="'..ce.radius/jq*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(ce.name,"Moon")and not string.match(ce.name,"Sanctuary")and not string.match(ce.name,"Space")then jp=jp.."<text x='"..bU.."' y='"..bV+ce.radius/jq*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..ce.name.."</text>"end end end;local e8=vec3(core.getConstructWorldPos())local bU=iX+iZ+e8.x/jq;local bV=iY+iZ*1.5/2+e8.y/jr;jp=jp..'<circle cx="'..bU..'" cy="'..bV..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jp=jp.."<text x='"..bU.."' y='"..bV-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fT=jq;fU=jr;local js=e8+bb*1000000;local jt=iX+iZ+js.x/jq;local gA=iY+iZ*1.5/2+js.y/jr;jp=jp..'<line x1="'..bU..'" y1="'..bV..'" x2="'..jt..'" y2="'..gA..'" stroke="purple" stroke-width="1"/>'gN[#gN+1]=jp;gN[#gN+1]='</g>'end elseif SelectedTab=="INFO"then gN=aP.DrawOdometer(gN,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then gN=iQ(gN)elseif SelectedTab=="SCOPE"then gN[#gN+1]='<g clip-path="url(#orbitRect)">'local ju=bA;if ar>0 then table.sort(bz,function(dh,di)local b_,c0=dh.center,di.center;return(b_.x-bf.x)^2+(b_.y-bf.y)^2+(b_.z-bf.z)^2<(c0.x-bf.x)^2+(c0.y-bf.y)^2+(c0.z-bf.z)^2 end)end;local eB={}local jv={}local jw=120;local jx=nil;local jy=nil;for i,ce in ipairs(bz)do local eA=ce.center-bf;local jz=eA:len()local jA=eA:normalize()local jB=eA:cross(b8):normalize()local jC=math.acos(jB:dot(b9))if jC~=jC then jC=0 end;if jB:cross(b9):dot(b8)<0 then jC=-jC end;local jD=eA:project_on_plane(b8):len()local jE=math.sin(jC)*math.asin(jD/jz)*constants.rad2deg;local jF=math.cos(jC)*math.asin(jD/jz)*constants.rad2deg;if jA:dot(b8)<0 then jF=90*math.cos(jC)+90*math.cos(jC)-jF;jE=90*math.sin(jC)+90*math.sin(jC)-jE end;local bU=jf+jE/ju*jb;local bV=jg+jF/ju*jb;local jG=(bU-jf)*(bU-jf)+(bV-jg)*(bV-jg)local jH=math.asin((ce.radius+ce.surfaceMaxAltitude)/jz)*constants.rad2deg;if jH~=jH then jH=ju end;local fv=jH/ju*jb;local jI=math.asin(ce.atmosphereRadius/jz)*constants.rad2deg;if jI~=jI then jI=jH end;local jJ=jI/ju*jb;local aj=c1(jz,1)local jK=ce.name;local jL=false;if bV>iY then if bV>ji then if bV-jJ<=ji then jL=true end else jL=true end else if bV+jJ>=iY then jL=true end end;local jM=false;local jN=bU;if ce.systemId==0 then jN=bU+jw else jN=bU-jw end;if jN+jw>iX then if jN+jw>jh then if jN-jJ-jw<=jh then jM=true end else jM=true end else if jN+jJ+jw>=iX then jM=true end end;local jO={}jO.x=bU;jO.y=bV;jO.planet=ce;jO.atmoSize=jJ;if not jx or jG<jx then jx=jG;jy=jO end;if jM and jL then local jP=math.max(jJ,5)if jG<jP*jP then jK=jK.." - "..aj end;jO.size=fv;jO.i=i;jO.displayString=jK;jO.distance=aj;jO.visible=true;jv[#jv+1]=jO else jO.visible=false end end;local jQ=false;table.sort(jv,function(b_,c0)return b_.y<c0.y end)for cd,eb in ipairs(jv)do local ce,fv,i,jJ,bU,bV,jK,aj=eb.planet,eb.size,eb.i,eb.atmoSize,eb.x,eb.y,eb.displayString,eb.distance;local j9,jR,jS,jT;local jU=15;local bX="pdim"if ce.systemId~=0 then jS=g6(string.len(jK)*5)jU=-(15+jS)jT=g7(10)bX="pdimfill"else jS=g6(string.len(jK)*9)jT=g7(15)end;if fv*2>jS then j9=r(bU,iX+jS/2,jh-jS/2)jR=r(bV,iY+jT,ji-5)j9=r(j9,bU-fv+jS/2,bU+fv-jS/2)jR=r(jR,bV-fv+jT,bV+fv)else j9=bU+jU;jR=bV end;for jV,eb in pairs(eB)do local jW=eb.textPositions;local jX=jW.y-jR;if jV~=i and d(jX)<jW.height and jW.x+jW.width>j9 and jW.x<j9+jS then if fv>jS then jR=r(jR+jT,iY+15,ji-5)else jR=jW.y+jW.height+1 end end end;local jY=jK~=ce.name or j9<=jf and j9+jS>=jf and jR-jT<=jg and jR>=jg;eb.hovered=jY;local jZ=1;if jY then jZ=2;if fv*2<jS then jZ=10 end;if jK==ce.name then jK=jK.." - "..aj end;bX="pbright"if ce.systemId~=0 then jS=g6(string.len(jK)*5)jU=-(15+jS)else jS=g6(string.len(jK)*7)end;if fv*2>jS then j9=r(bU,iX+jS/2,jh-jS/2)j9=r(j9,bU-fv+jS/2,bU+fv-jS/2)else j9=bU+jU end end;eB[i]={}eB[i].textPositions={}eB[i].textPositions.y=jR;eB[i].textPositions.x=j9;eB[i].textPositions.width=jS;eB[i].textPositions.height=jT;eB[i].output=""if fv*2>jS then bX=bX.." txtmid"else bX=bX.." txtstart"end;if jJ-fv>2 then eB[i].output=f('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',bU,bV,jJ,az,0.1*jZ)end;eB[i].output=eB[i].output..f('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',bU,bV,fv,az,0.2*jZ)if ce.systemId==0 then eB[i].output=eB[i].output..f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j9,jR,ay,bX,jK)if fv*2<=jS then eB[i].output=eB[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j9+jS,jR+2,j9,jR+2,bU,bV)end else eB[i].output=eB[i].output..f([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j9,jR,az,bX,jK)if fv*2<=jS then eB[i].output=eB[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j9,jR+2,j9+jS,jR+2,bU,bV)end end end;for cd=#bz,1,-1 do if eB[cd]then gN[#gN+1]=eB[cd].output end end;if jy~=nil and bA<90 and not jy.hovered then local j_=jy.planet.atmosphereRadius/jy.atmoSize;local k0=y(jx)*j_;local k1=c1(k0,1)local jS=g6(math.max(string.len(k1)*7,string.len(jy.planet.name)*7))local jT=g7(12)local j9=r(jy.x+(jf-jy.x)/2,iX+jS/2,jh-jS/2)local jR=r(jy.y+(jg-jy.y)/2,iY+jT*2,ji-5)gN[#gN+1]=f("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",jy.x,jy.y,jf,jg)gN[#gN+1]=f([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j9,jR,"white",k1)if not jy.visible then gN[#gN+1]=f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j9,jR-jT,"white",jy.planet.name)end end;if bc>1 then local eA=bb;local jA=eA:normalize()local jD=eA:project_on_plane(b8):len()local jB=eA:cross(b8):normalize()local jC=math.acos(jB:dot(b9))if jC~=jC then jC=0 end;if jB:cross(b9):dot(b8)<0 then jC=-jC end;local jE=math.sin(jC)*math.asin(jD/eA:len())*constants.rad2deg;local jF=math.cos(jC)*math.asin(jD/eA:len())*constants.rad2deg;if jA:dot(b8)<0 then jF=90*math.cos(jC)+90*math.cos(jC)-jF;jE=90*math.sin(jC)+90*math.sin(jC)-jE end;local bU=jf+jE/ju*jb;local bV=jg+jF/ju*jb;local hJ=14;local hK=hJ/2;local hN=[[<circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hK/hJ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bU-hJ..[[,]]..bV..[[ h ]]..hK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bU+hK..[[,]]..bV..[[ h ]]..hK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bU..[[,]]..bV-hJ..[[ v ]]..hK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]gN[#gN+1]=hN end;gN[#gN+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jf,jg-10,jf,jg+10)gN[#gN+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jf-10,jg,jf+10,jg)gN[#gN+1]='</g>'else return gN end end;local function k2(k3,k4)local k5;local k6=(k4-k3):normalize()local e9=(bf-k3):dot(k6)/k6:dot(k6)if e9<=0.then return(bf-k3):len()elseif e9>=(k4-k3):len()then return(bf-k4):len()end;local k7=k3+e9*k6;k5=(k7-bf):len()return k5 end;local function k8()local k5;local k9=nil;local ka=nil;local kb=nil;for cd,kc in pairs(b[0])do if kc.hasAtmosphere then local aj=k2(planet.center,kc.center)if k9==nil or aj<k9 then ka=kc;k9=aj;kb=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dv=k2(ac.center,kc.center)if dv<k9 then ka=kc;k9=dv;kb=ac end end end end;local kd=g6(1770)local ke=g7(330)if k9 then local kf="txttick "local kg=500000;if k9<ka.radius+kg or k9<kb.radius+kg then if bn then kf="txttick red "else kf="txttick orange "end end;k5=c1(k9,2)fY=bT(kd,ke,"Pipe ("..kb.name.."--"..ka.name.."): "..k5,kf.."pbright txtmid")end end;local function kh(bU,bV,ki,kj,hW)local kk={x=bU,y=bV,width=ki,height=kj,label=hW}bw[hW]=kk;return kk end;local function kl(km,kn,ki,kj,bU,bV,ko,kp,kq,kr,bX)local kk={enableName=km,disableName=kn,width=ki,height=kj,x=bU,y=bV,toggleVar=ko,toggleFunction=kp,drawCondition=kq,hovered=false,class=bX}if kr then table.insert(fS,kk)else table.insert(fR,kk)end;return kk end;local function ks(kt)if not fW then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif kt=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif kt=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif kt=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fX=bM(kt)showHud=false else fX={}showHud=true end end;local function ku()fW=not fW;if fW then fQ=fS;a2="Hold SHIFT to see Settings"bB=showHud else fQ=fR;a2="Hold SHIFT to see Control Buttons"ks()showHud=bB end end;local function kv()local function kw(ce)_G[ce]=not _G[ce]if _G[ce]then a2=ce.." set to true"else a2=ce.." set to false"end;if ce=="showHud"then bB=_G[ce]elseif ce=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local kx=50;local ky=340;local bU=500;local bV=aE/2-400;local kz=0;for cd,ce in pairs(bM("boolean"))do if type(_G[ce])=="boolean"then kl(ce,ce,ky,kx,bU,bV,function()return _G[ce]end,function()kw(ce)end,function()return true end,true)bV=bV+kx+20;if kz==9 then bU=bU+ky+20;bV=aE/2-400;kz=0 else kz=kz+1 end end end;kl("Control View","Control View",ky,kx,10,aE/2-500,function()return true end,ku,function()return true end,true)kl("View Handling Settings",'Hide Handling Settings',ky,kx,10,aE/2-(500-kx),function()return showHandlingVariables end,function()ks("handling")end,function()return true end,true)kl("View Hud Settings",'Hide Hud Settings',ky,kx,10,aE/2-(500-kx*2),function()return showHudVariables end,function()ks("hud")end,function()return true end,true)kl("View Physics Settings",'Hide Physics Settings',ky,kx,10,aE/2-(500-kx*3),function()return showPhysicsVariables end,function()ks("physics")end,function()return true end,true)end;local function kA()local function kB()local position=bf;local fy=planet.name..". "..#SavedLocations;if radar_1 then fy=aS.GetClosestName(fy)end;return aQ.AddNewLocation(fy,position,false,true)end;local function kC()TurnBurn=not TurnBurn end;local function kD(kE)if kE==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kF()aQ.UpdatePosition()end;local function kG()aQ.ClearCurrentPosition()end;local function kH(fj)local fy=AutopilotTargetName;if fj~=nil and type(fj)=="number"then if fj==0 then return"None"end;fy=bm[fj].name end;if fy==nil then fy=CustomTarget.name end;if fy==nil then fy="None"end;return fy end;local function kI(fj)return"Engage Autopilot: "..kH(fj)end;local function kJ(fj)return"Disable Autopilot: "..kH(fj)end;local function kK()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bG("folOn","F")else bG("folOff","F")BrakeIsOn=true;aV=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local kx=50;local ky=260;local kL=g6(30)local kM=OrbitMapX+OrbitMapSize*2+2;local kN=OrbitMapY+1;kl("+","+",kL,kL,kM,kN+kL+1,function()return false end,function()bA=bA/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")kl("-","-",kL,kL,kM,kN,function()return false end,function()bA=math.min(bA*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")kl("0","0",kL,kL,kM,kN+kL*2+2,function()return false end,function()bA=90 end,function()return SelectedTab=="SCOPE"and bA~=90 end,nil,"ZoomButton")local kO=kl("Enable Brake Toggle","Disable Brake Toggle",ky,kx,aD/2-ky/2,aE/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)kl("Align Prograde","Disable Prograde",ky,kx,aD/2-ky/2-50-kO.width,aE/2-kx+380,function()return ProgradeIsOn end,function()kD(1)end)kl("Align Retrograde","Disable Retrograde",ky,kx,aD/2-ky/2+kO.width+50,aE/2-kx+380,function()return RetrogradeIsOn end,kD,function()return ar==0 end)apbutton=kl(kI,kJ,600,60,aD/2-600/2,aE/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function kP(kQ)local fj=bv+kQ;if fj>#bm then fj=fj-#bm-1 end;if fj<0 then fj=#bm+fj end;return fj end;apExtraButtons={}for i=0,10 do local button=kl(function(c0)local fj=kP(c0.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..kH(fj)end;return kI(fj)end,function(c0)local fj=kP(c0.apExtraIndex)return kJ(fj)end,600,60,aD/2-600/2,aE/2-60/2-330+60*i,function(c0)local fj=kP(c0.apExtraIndex)return fj==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(c0)local fj=kP(c0.apExtraIndex)local kR=AutopilotTargetIndex==fj;AutopilotTargetIndex=fj;aQ.UpdateAutopilotTarget()aR.ToggleAutopilot()if not kR and not(Autopilot or VectorToTarget or am or IntoOrbit)then aR.ToggleAutopilot()end end,function()return bu end)button.apExtraIndex=i;apExtraButtons[i]=button end;kl("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kB,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)kl("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kF,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kl("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kG,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kx=60;ky=300;local bU=0;local bV=aE/2-150;kl("View Settings","View Settings",ky,kx,bU,bV,function()return true end,ku)bV=bV+kx+20;kl("Enable Turn and Burn","Disable Turn and Burn",ky,kx,bU,bV,function()return TurnBurn end,kC)bU=10;bV=aE/2-300;kl("Horizontal Takeoff Mode","Vertical Takeoff Mode",ky,kx,bU+ky+20,bV,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bg end)bV=bV+kx+20;kl("Engage Orbiting","Cancel Orbiting",ky,kx,bU+ky+20,bV,function()return IntoOrbit end,aR.ToggleIntoOrbit,function()return ar==0 and br end)bV=aE/2-150;kl("Glide Re-Entry","Cancel Glide Re-Entry",ky,kx,bU+ky+20,bV,function()return Reentry end,function()al=1;kD(1)end,function()return planet.hasAtmosphere and not aq end)bV=bV+kx+20;kl("Parachute Re-Entry","Cancel Parachute Re-Entry",ky,kx,bU+ky+20,bV,function()return Reentry end,aR.BeginReentry,function()return planet.hasAtmosphere and not aq end)bV=bV+kx+20;kl("Engage Follow Mode","Disable Follow Mode",ky,kx,bU,bV,function()return a0 end,kK,function()return m()==1 end)kl("Enable Repair Arrows","Disable Repair Arrows",ky,kx,bU+ky+20,bV,function()return aJ end,function()aJ=not aJ;if aJ then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)bV=bV+kx+20;if not ExternalAGG then kl("Enable AGG","Disable AGG",ky,kx,bU,bV,function()return bh end,aR.ToggleAntigrav,function()return antigrav~=nil end)end;kl(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,ky*2,kx,bU,bV,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)bV=bV+kx+20;kl(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,ky*2,kx,bU,bV,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local kS=g7(20)local button=kh(0,0,g6(70),kS,"HELP")button=kh(button.x+button.width,button.y,g6(80),kS,"INFO")button=kh(button.x+button.width,button.y,g6(70),kS,"ORBIT")button=kh(button.x+button.width,button.y,g6(70),kS,"SCOPE")kh(button.x+button.width,button.y,g6(70),kS,"HIDE")end;local kT={}local kU=nil;function kT.HUDPrologue(gN)bn,bo=g4(bf)if not bn then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.6)..","..e(J+0.6)..","..e(I+0.6)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kV=ay;local kW=az;local kX=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.4+0.5)..[[)]]local kY=ay;local kZ=az;local k_=kX;if g8()and not brightHud then kV=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kW=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]kX=[[rgb(]]..e(H*0.2+0.5)..","..e(J*0.2+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iF=g6;local iG=g7;gN[#gN+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .pdimfill {fill: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                    <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="1"/>
                                    </radialGradient>
                                    <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="66%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/>
                                    </radialGradient>                            
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kV,kV,kV,kY,kY,kW,kW,kZ,kZ,kW,kV,kX,kZ,kV,kV,kX,kX,k_,kX,aD,aE,kW,kW,kW,kW,kW,kY,kW,kZ,k_,kZ,kZ,k_)if not kU then kU=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iF(630),iG(0),iF(675),iG(45),iF(960),iG(55),iF(1245),iG(45),iF(1290),iG(0),iF(1000),iG(105),iF(1040),iG(59),iF(1250),iG(51),iF(1300),iG(0),iF(1920),iG(0),iF(1920),iG(20),iF(1400),iG(20),iF(1300),iG(105),iF(920),iG(105),iF(880),iG(59),iF(670),iG(51),iF(620),iG(0),iF(0),iG(0),iF(0),iG(20),iF(520),iG(20),iF(620),iG(105),iF(890),iG(59),iF(960),iG(62),iF(1030),iG(59),iF(985),iG(112),iF(1150),iG(112),iF(1100),iG(152),iF(820),iG(152),iF(780),iG(112),iF(935),iG(112),iF(890),iG(59),iF(960),iG(62),iF(1030),iG(59),iF(985),iG(112),iF(1150),iG(112),iF(1100),iG(152),iF(820),iG(152),iF(780),iG(112),iF(935),iG(112))end;if showHud and DisplayOdometer then gN[#gN+1]=kU end;return gN end;function kT.DrawVerticalSpeed(gN,cP)gM(gN,cP)end;function kT.UpdateHud(gN)local hC=bk;local l0=bl;local gV=l0;local h9=hC;local hU=e(unit.getThrottle())local hZ=bc*3.6;local hV=unit.getAxisCommandValue(0)local l1=g6(1770)local l2=g7(310)if AtmoSpeedAssist and bj then hV=K;hU=K*100 end;local ga=g9()local gW="ROLL"if hU==nil then hU=0 end;if not br then if bc>5 then hC=hB(ba)l0=hD(ba)else hC=0;l0=0 end;gW="YAW"end;if bo>50000 and not aq then local l3;l3=c1(bo)gN[#gN+1]=bT(l1,l2,"PvP Boundary: "..l3,"pbright txtbig txtmid")end;gN[#gN+1]=ak;gN[#gN+1]=aB;gN[#gN+1]=fN;if fY~=""then gN[#gN+1]=fY end;if gc~=""then gN[#gN+1]=gc end;if gd~=""then gN[#gN+1]=gd end;gM(gN,as)if m()==0 or RemoteHud then if br then gU(gN,centerX,centerY,gV,gW,br)else gU(gN,centerX,centerY,l0,gW,br)end;if not g8()or brightHud then if br then gU(gN,centerX,centerY,gV,gW,br)h8(gN,h9,gV,centerX,centerY,br,e(hD(ba)),bc)else gU(gN,centerX,centerY,l0,gW,br)h8(gN,hC,l0,centerX,centerY,br,e(l0),bc)end;hf(gN,as,br)hE(gN,ba,bc,centerX,centerY)end end;hT(gN,ga,hU,hV)hY(gN,hZ)i1(gN)iW(gN)return gN end;function kT.HUDEpilogue(gN)gN[#gN+1]="</svg>"return gN end;function kT.ExtraData(gN)local l4=g6(1240)local l5=g7(55)local l6=l5+10;local l7;local iF=g6;local iG=g7;local l8=0;local ga=g9()if VertTakeOffEngine then ga=ga.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bc>20 then ga=ga.."-COLLISION ON"end;if UseExtra~="Off"then ga="("..UseExtra..")-"..ga end;if TurnBurn then ga="TB-"..ga end;if not stablized then ga=ga.."-DeCoupled"end;local l9=iG(99)local la=iG(80)local lb=iG(85)local lc=iG(31)local ld=0;local le=0;local lf=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then l8=LastMaxBrakeInAtmo else l8=LastMaxBrake end;local lg,lh=aM.computeDistanceAndTime(bc,0,av,0,0,l8)if lg<0 then lg=0 end;l8=A(l8/(av*fP),2).."g"local li=a:maxForceForward()l7=core.g()if l7>0.1 then le=av*l7;le=A(le/(av*fP),2).."g"ld=0.5*li/l7;ld=ld>1000000 and A(ld/1000000,2).."kT"or A(ld/1000,2).."T"end;li=A(li/(av*fP),2).."g"local lj=vec3(core.getWorldAcceleration()):len()/9.80665;l7=core.g()gN[#gN+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then l4=g6(1120)l5=g7(55)l6=l5+10 elseif aq and DisplayOdometer then local lk=g6(770)gN[#gN+1]=bT(iF(895),l9,"ATMO","")gN[#gN+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iF(895),lb,iF(-80))gN[#gN+1]=bT(iF(815),la,f("%.1f%%",ar*100),"txtstart size20")end;if DisplayOdometer then gN[#gN+1]=bT(iF(1025),l9,"GRAVITY","txtstart")gN[#gN+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iF(1025),lb,iF(80))gN[#gN+1]=bT(iF(1105),la,f("%.2fg",l7/9.80665),"size20")gN[#gN+1]=bT(iF(1125),l9,"ACCEL","txtstart")gN[#gN+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iF(1125),lb,iF(80))gN[#gN+1]=bT(iF(1205),la,f("%.2fg",lj),"size20")gN[#gN+1]=bT(iF(695),l9,"BRK TIME","")gN[#gN+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iF(695),lb,iF(-80))gN[#gN+1]=bT(iF(615),la,f("%s",c4(lh)),"txtstart size20")gN[#gN+1]=bT(iF(635),iG(45),"TRIP","")gN[#gN+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iF(635),iG(31),iF(-90))if travelTime then gN[#gN+1]=bT(iF(532),iG(23),f("%s",c4(travelTime)),"txtstart size20")end;gN[#gN+1]=bT(iF(795),l9,"BRK DIST","")gN[#gN+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iF(795),lb,iF(-80))gN[#gN+1]=bT(iF(715),la,f("%s",c1(lg)),"txtstart size20")gN[#gN+1]=bT(iF(1285),iG(45),"MASS","txtstart")gN[#gN+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iF(1285),iG(31),iF(90))gN[#gN+1]=bT(iF(1388),iG(23),f("%s",lf),"size20")gN[#gN+1]=bT(iF(1220),l9,"THRUST","txtstart")gN[#gN+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iF(1220),lb,iF(80))gN[#gN+1]=bT(iF(1300),la,f("%s",li),"size20")gN[#gN+1]=bT(g6(960),g7(175),ga,"pbright txtbig txtmid size20")end;gN[#gN+1]="</g>"end;function kT.DrawOdometer(gN,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return gN end;local l7;local ld=0;local le=0;local l8=0;local lf=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then l8=LastMaxBrakeInAtmo else l8=LastMaxBrake end;local lg,lh=aM.computeDistanceAndTime(bc,0,av,0,0,l8)l8=A(l8/(av*fP),2).." g"local li=a:maxForceForward()l7=core.g()if l7>0.1 then le=av*l7;le=A(le/(av*fP),2).." g"ld=0.5*li/l7;ld=ld>1000000 and A(ld/1000000,2).." kTons"or A(ld/1000,2).." Tons"end;li=A(li/(av*fP),2).." g"if m()==0 or RemoteHud then local ll=g6(OrbitMapX+10)local lm=g7(OrbitMapY+20)local ln=g6(OrbitMapX+10+OrbitMapSize/1.25)local kj=25;gN[#gN+1]="<g class='txtstart size14 bright'>"gN[#gN+1]=bT(ll,lm,f("BrkTime: %s",c4(lh)))gN[#gN+1]=bT(ln,lm,f("Trip: %.2f km",ad))gN[#gN+1]=bT(ll,lm+kj,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gN[#gN+1]=bT(ln,lm+kj,f("BrkDist: %s",c1(lg)))gN[#gN+1]=bT(ll,lm+kj*2,"Trip Time: "..c4(ae))gN[#gN+1]=bT(ln,lm+kj*2,"Total Time: "..c4(TotalFlightTime))gN[#gN+1]=bT(ll,lm+kj*3,f("Mass: %s",lf))gN[#gN+1]=bT(ln,lm+kj*3,f("Max Brake: %s",l8))gN[#gN+1]=bT(ll,lm+kj*4,f("Max Thrust: %s",li))if l7>0.1 then gN[#gN+1]=bT(ln,lm+kj*4,f("Max Thrust Mass: %s",ld))gN[#gN+1]=bT(ll,lm+kj*5,f("Req Thrust: %s",le))else gN[#gN+1]=bT(ln,lm+kj*5,"Max Mass: n/a")gN[#gN+1]=bT(ll,lm+kj*6,"Req Thrust: n/a")end end;gN[#gN+1]="</g></g>"return gN end;function kT.DrawWarnings(gN)return i1(gN)end;function kT.DisplayOrbitScreen(gN)return iW(gN)end;function kT.DisplayMessage(gN,ip)if ip~="empty"then local bV=310;for lo in string.gmatch(ip,"([^\n]+)")do bV=bV+35;gN[#gN+1]=bT("50%",bV,lo,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function kT.DrawDeadZone(gN)gN[#gN+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kT.UpdatePipe()if aq then fY=""return end;k8()end;function kT.DrawSettings(gN)if#fX>0 then local bU=g6(640)local bV=g7(200)gN[#gN+1]=[[<g class="pbright txtvspd txtstart">]]for cd,ce in pairs(fX)do gN[#gN+1]=bT(bU,bV,ce..": ".._G[ce])bV=bV+20;if cd%12==0 then bU=bU+g6(350)bV=g7(200)end end;gN[#gN+1]=bT(g6(640),g7(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gN[#gN+1]="</g>"end;return gN end;local perisPanelID;local fK=g6(1770)local fL=g7(350)local fJ=g7(15)local fI=g6(1370)local bC,lp;local peris=0;function kT.DrawRadarInfo()fN=aS.GetRadarHud(fI,fJ,fK,fL)end;function kT.DrawTanks()if fuelX~=0 and fuelY~=0 then gc=bT(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gt(fuelX,"Atmospheric ","ATMO",aF,gr,gs)gt(fuelX,"Space Fuel T","SPACE",aG,gp,gq)gt(fuelX,"Rocket Fuel ","ROCKET",aH,gn,go)end end;function kT.DrawShield()local lq=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local lr=core.getPvPTimer()local ls=shield_1.getResistances()local lt="A: "..10+ls[1]*100 .."% / E: "..10+ls[2]*100 .."% / K:"..10+ls[3]*100 .."% / T: "..10+ls[4]*100 .."%"local bU,bV=shieldX-60,shieldY+30;local lu=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gH=e(lu*2.55)local gI=f("rgb(%d,%d,%d)",255-gH,gH,0)local bX=""gd=bT(bU,bV,"","txtmid pdim txtfuel")if lu<10 and lq~="Shield Disabled"then bX="red "end;lr=lr>0 and"   PvPTime: "..c4(lr)or""gd=gd..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bU,bV,gI,lu*2,bU,bV,bU+2,bV+10,lu,lr)gd=gd..bT(bU,bV-5,lq,bX.."txtstart pbright txtbig")gd=gd..bT(bU,bV+30,lt,bX.."txtstart pbright txtsmall")end;function kT.hudtick()if not planet then return end;local function lv(gN)local gK=e(r(aj/(aD/4)*255,0,255))gN[#gN+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+gK,e(J+0.5)-gK,e(I+0.5)-gK)end;local function lw()for _,ce in pairs(fQ)do if ce.hovered then if not ce.drawCondition or ce.drawCondition(ce)then ce.toggleFunction(ce)end;ce.hovered=false end end;for _,ce in pairs(bw)do if ce.hovered then SelectedTab=ce.label;ce.hovered=false end end end;local function lx()local function ly(lz,lA,bU,bV,ki,kj)if lz>=bU and lz<=bU+ki and lA>=bV and lA<=bV+kj then return true else return false end end;local bU=ag+aD/2;local bV=ah+aE/2;for _,ce in pairs(fQ)do ce.hovered=ly(bU,bV,ce.x,ce.y,ce.width,ce.height)end;for _,ce in pairs(bw)do ce.hovered=ly(bU,bV,ce.x,ce.y,ce.width,ce.height)end;if bu then local jY=false;for _,c0 in ipairs(apExtraButtons)do if c0.hovered then jY=true;break end end;if apbutton.hovered then jY=true end;bu=jY else bu=apbutton.hovered;if not bu then bv=AutopilotTargetIndex end end end;local function lB(gN)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;if showHud then for cd,ce in pairs(bw)do local bX="dim brightstroke"local lC=0.2;if SelectedTab==cd then bX="pbright dimstroke"lC=0.6 end;local lD=""if ce.hovered then lC=0.8;lD=";stroke:white"end;gN[#gN+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],ce.width,ce.height,ce.x,ce.y,bX,lC,lD)gN[#gN+1]=bT(ce.x+ce.width/2,ce.y+ce.height/2+5,ce.label,"txt txtmid pdim")end end end;local function lE(gN)local function lF(gN,lG,hover,bU,bV,dY,lH,lI,lJ,lK,lL,button)if type(lK)=="function"then lK=lK(button)end;if type(lL)=="function"then lL=lL(button)end;gN[#gN+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bU,bV,dY,lH)if lG then gN[#gN+1]=f("%s'",lI)else gN[#gN+1]=lJ end;if hover then gN[#gN+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gN[#gN+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gN[#gN+1]=" rx='5'></rect>"gN[#gN+1]=f("<text x='%f' y='%f' font-size='24' fill='",bU+dY/2,bV+lH/2+5)if lG then gN[#gN+1]="black"else gN[#gN+1]="white"end;gN[#gN+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lG then gN[#gN+1]=f("%s</text>",lK)else gN[#gN+1]=f("%s</text>",lL)end end;local lM=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local lN=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local lO=lF;for _,ce in pairs(fQ)do local kn=ce.disableName;local km=ce.enableName;if type(kn)=="function"then kn=kn(ce)end;if type(km)=="function"then km=km(ce)end;if not ce.drawCondition or ce.drawCondition(ce)then lO(gN,ce.toggleVar(ce),ce.hovered,ce.x,ce.y,ce.width,ce.height,lN,lM,kn,km,ce)end end end;local lP=A(aD/2,0)local lQ=A(aE/2,0)local gN={}aP.HUDPrologue(gN)if showHud then aP.UpdateHud(gN)else if AlwaysVSpd then aP.DrawVerticalSpeed(gN,as)end;aP.DrawWarnings(gN)end;if fW and fX~={}then aP.DrawSettings(gN)end;if radar_1 then aP.DrawRadarInfo()end;aP.HUDEpilogue(gN)gN[#gN+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aD,aE)if a2~="empty"then aP.DisplayMessage(gN,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aP.DrawDeadZone(gN)end end;lB(gN)if x()==0 then if m()==1 and a1 then if not AltIsOn then lx()lE(gN)end;if not aT and not aU then local lR=table.concat(gN,"")gN={}gN[#gN+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gN[#gN+1]=lR;gN[#gN+1]="</body>"aT=true;gN[#gN+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gN,"")system.setScreen(content)elseif aU then local lR=table.concat(gN,"")gN={}gN[#gN+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gN[#gN+1]=lR;gN[#gN+1]="</body>"end;if not aT then gN[#gN+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lP,lQ,ag,ah)end else lw()end else if not a1 and m()==0 then lw()if aj>DeadZone then if DisplayDeadZone then lv(gN)end end elseif a1 and(not AltIsOn or not freeLookToggle)then lx()lE(gN)end;gN[#gN+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lP,lQ,ag,ah)end;gN[#gN+1]=[[</svg></body>]]content=table.concat(gN,"")end;function kT.TenthTick()aP.DrawTanks()if shield_1 then aP.DrawShield()end end;function kT.OneSecond(gN)local function lS()local gD=q()local hZ=bc;local lT=gD-au;if hZ>1.38889 then hZ=hZ/1000;local lU=hZ*(gD-au)TotalDistanceTravelled=TotalDistanceTravelled+lU;ad=ad+lU end;ae=ae+lT;TotalFlightTime=TotalFlightTime+lT;au=gD end;lS()aP.UpdatePipe()aP.ExtraData(gN)end;function kT.ButtonSetup()kv()kA()fQ=fR end;return kT end;local function lV()local function lW(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function lX()local function lY(lZ,l_)return lZ.name<l_.name end;bm={}for cd,ce in pairs(b[0])do bm[#bm+1]={name=ce.name,index=cd}end;table.sort(bm,lY)end;local function m0(m1)for cd,ce in pairs(m1)do if ce.name and ce.name==CustomTarget.name then return cd end end;return-1 end;local function m2()bv=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local m3=bm[AutopilotTargetIndex].index;local m4=b[0][m3]if m4.center then AutopilotTargetName=m4.name;ac=aL[0][m3]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=m4;for _,ce in pairs(aL[0])do if ce.name==CustomTarget.planetname then ac=ce;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function m5(gR)if not Autopilot and not VectorToTarget and not am and not IntoOrbit and not Reentry and not an then if gR==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bm end end;if AutopilotTargetIndex==0 then m2()else local m3=bm[AutopilotTargetIndex].index;local m4=b[0][m3]if m4~=nil and m4.name=="Space"or iphCondition=="Custom Only"and m4.center or iphCondition=="No Moons"and string.find(m4.name,"Moon")~=nil then if gR==nil then m5()else m5(1)end else m2()end end else a2="Disengage autopilot before changing Interplanetary Helper"bG("iph","AP")end end;local function kG()local fj=-1;fj=m0(b[0])if fj>-1 then table.remove(b[0],fj)end;fj=-1;fj=m0(SavedLocations)if fj~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fj)end;m5()lX()end;local function kB(fy,position,hy,m6)if dbHud_1 or hy then local p=lW(position)local l7=p.gravity;if m6 then l7=unit.getClosestPlanetInfluence()end;local m7={position=position,name=fy,planetname=p.name,gravity=l7,safe=m6}if not hy then SavedLocations[#SavedLocations+1]=m7 else for cd,ce in pairs(b[0])do if ce.name and fy==ce.name then table.remove(b[0],cd)end end end;table.insert(b[0],m7)lX()m2()a2="Location saved as "..fy.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local m8={}function m8.UpdateAtlasLocationsList()lX()end;function m8.UpdateAutopilotTarget()m2()end;function m8.adjustAutopilotTargetIndex(gR)m5(gR)end;function m8.findAtlasIndex(m1)m0(m1)end;function m8.UpdatePosition(m9)local fj=m0(SavedLocations)if fj~=-1 then if m9~=nil then SavedLocations[fj].name=m9;AutopilotTargetIndex=AutopilotTargetIndex-1;m5()else local ma=SavedLocations[fj]ma.gravity=unit.getClosestPlanetInfluence()ma.position=bf;ma.safe=true end;a2=SavedLocations[fj].name.." position updated ("..SavedLocations[fj].planetname..")"else a2="Name Not Found"end end;function m8.AddNewLocation(fy,position,hy,m6)kB(fy,position,hy,m6)end;function m8.ClearCurrentPosition()kG()end;for cd,ce in pairs(SavedLocations)do table.insert(b[0],ce)end;lX()if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end;m8.UpdateAutopilotTarget()return m8 end;local function mb()local mc={}local function md(e4)local me=AutopilotEndSpeed;if not Autopilot then me=0 end;if not aq then return aM.computeDistanceAndTime(e4,me,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aM.computeDistanceAndTime(e4,me,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function mf(e4)local me=AutopilotEndSpeed;if not Autopilot then me=0 end;return aM.computeDistanceAndTime(e4,me,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local mg=false;local mh=0;local mi=0;local mj=0;local mk=q()local ml=0;local mm=0;local mn=0;local mo=0;local mp=false;local mq=false;local mr=false;local ms=nil;local mt=0;function mc.GetAutopilotBrakeDistanceAndTime(e4)return md(e4)end;function mc.GetAutopilotTBBrakeDistanceAndTime(e4)return mf(e4)end;local function mu(mv,mw,mx)mw=mw:project_on_plane(mv)mx=mx:project_on_plane(mv)return n(mw:cross(mx):dot(mv),mw:dot(mx))end;local function my()local function mz()local mA=-1;local mB=-1;if vBooster then mA=vBooster.getDistance()end;if hover then mB=hover.getDistance()end;if mA~=-1 and mB~=-1 then if mA<mB then return mA else return mB end elseif mA~=-1 then return mA elseif mB~=-1 then return mB else return-1 end end;local mC=mz()local mD=-1;if telemeter_1 then mD=telemeter_1.getDistance()end;if mC~=-1 and mD~=-1 then if mC<mD then return mC else return mD end elseif mC~=-1 then return mC else return mD end end;local function mE(planet,dr,mF)local function mG(mH,cJ)local dx=vec3(cJ)if mH.id==0 then return setmetatable({latitude=dx.x,longitude=dx.y,altitude=dx.z,id=0,systemId=mH.systemId},MapPosition)end;local dy=dx-mH.center;local aj=dy:len()local cP=aj-mH.radius;local cN=0;local cO=0;if not bZ(aj,0)then local dz=n(dy.y,dy.x)cO=dz>=0 and dz or 2*math.pi+dz;cN=math.pi/2-math.acos(dy.z/aj)end;return setmetatable({latitude=math.deg(cN),longitude=math.deg(cO),altitude=cP,id=mH.id,systemId=mH.systemId},MapPosition)end;local mI=mG(planet,dr)mI="::pos{"..mI.systemId..","..mI.id..","..mI.latitude..","..mI.longitude..","..mI.altitude.."}"if mF then return mI else system.setWaypoint(mI)return true end end;local mJ=false;function mc.showWayPoint(planet,dr,mF)return mE(planet,dr,mF)end;function mc.APTick()local function mK()if bt and not BrakeLanding then local d9=bt[1]local fz,fA=bt[2],bt[3]local mL=math.min(fz,fA or fz)local mM=mL/bc;local mN=AutoTakeoff and(bc<42 or ao~=-1)local mO=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mO and not mN and(a8*1.5>mL or mM<1)then BrakeIsOn=true;aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()end;if LockPitch then aR.ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then aR.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aV=true end;if mM<11 then bs=d9.name.." COLLISION "..c4(mM).." / "..c1(mL,2)else bs=d9.name.." collision "..c4(mM)end;if mM<6 then bG("alarm","AL",2)end else bs=false end end;local function mP(mQ,mR,mS)local function mT(mQ,db)mQ=vec3(mQ)db=vec3(db):normalize()local cu=mQ*db;return cu.x+cu.y+cu.z end;local mU=0.001;local mV=1;if not aq or not aX or ao~=-1 or bc<Q then if mS==nil then mS=DampingMultiplier end;if mR==nil then mR=mU end;mQ=vec3(mQ):normalize()local mW=vec3()-mQ;local mX=-mT(mW,core.getConstructWorldOrientationRight())*mV;local mY=-mT(mW,core.getConstructWorldOrientationUp())*mV;if mi==0 then mi=mX/2 end;if mj==0 then mj=mY/2 end;if d(mX)<0.1 then V=V-mX*2 else V=V-(mX+(mX-mi)*mS)end;if d(mY)<0.1 then U=U+mY*2 else U=U+mY+(mY-mj)*mS end;mi=mX;mj=mY;if d(mX)<mR and d(mY)<mR then return true end;return false elseif aX and ao==-1 then mQ=bb;if mS==nil then mS=DampingMultiplier end;if mR==nil then mR=mU end;mQ=vec3(mQ):normalize()local mW=b8-mQ;local mX=-mT(mW,core.getConstructWorldOrientationRight())*mV;local mY=-mT(mW,core.getConstructWorldOrientationUp())*mV;if mi==0 then mi=mX/2 end;if mj==0 then mj=mY/2 end;if d(mX)<0.1 then V=V-mX*5 else V=V-(mX+(mX-mi)*mS)end;if d(mY)<0.1 then U=U+mY*5 else U=U+mY+(mY-mj)*mS end;mi=mX;mj=mY;if d(mX)<mR and d(mY)<mR then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=my()E=q()mk=E;if CollisionSystem then mK()end;if antigrav then bh=antigrav.getState()==1 end;local mZ=1;local m_=1;local n0=E-mk;local n1=-math.deg(mu(b7,bb,b8))local n2=math.deg(mu(b9,bb,b8))local gR=bd*-1;aX=aq and n1<-YawStallAngle or n1>YawStallAngle or n2<-PitchStallAngle or n2>PitchStallAngle;local n3=system.getMouseDeltaX()local n4=system.getMouseDeltaY()if InvertMouse and not a1 then n4=-n4 end;V=0;Z=0;U=0;sys=aL[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aO(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bb)if as==0 then as=(bf-planet.center):len()-planet.radius end;br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local l7=planet:getGravity(core.getConstructWorldPos()):len()*av;aY=0;aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aT then ag=r(ag+n3,-aD/2,aD/2)ah=r(ah+n4,-aE/2,aE/2)end else ag=0;ah=0 end else ag=r(ag+n3,-aD/2,aD/2)ah=r(ah+n4,-aE/2,aE/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then local hL,hM=1,1;if SelectedTab=="SCOPE"then hL,hM=bA/90,bA/90 end;if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity*hL elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity*hL else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity*hM elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity*hM else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(n4,-100,100)+0.5)*2*mZ;V=(-utils.smoothstep(n3,-100,100)+0.5)*2*m_ end end end end;local n5=bc>8334;if bc>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not n5 then a2="Space Speed Engine Shutoff reached"aR.cmdThrottle(0)end;if not n5 and LastIsWarping then if not BrakeIsOn then aR.BrakeToggle()end;if Autopilot then aR.ToggleAutopilot()end end;LastIsWarping=n5;if aq and ar>0.09 then if bc>aZ/3.6 and not AtmoSpeedAssist and not mg then BrakeIsOn=true;mg=true elseif not AtmoSpeedAssist and mg then if bc<aZ/3.6 then BrakeIsOn=false;mg=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local n6=false;if CustomTarget and al~=1 then n6=mP(CustomTarget.position-bf,0.1)else n6=mP(vec3(bb),0.01)end;aV=true;if n6 then aR.cmdCruise(e(aZ))if(d(bl)<2 or d(bk)>85)and bc>=aZ/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;aR.BeginReentry()end elseif aq and AtmoSpeedAssist then aR.cmdThrottle(1)end elseif bc>Q then mP(vec3(bb),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bc>Q then mP(-vec3(bb))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;aR.BeginReentry()al=false;an=true else al=false;aR.ToggleAutopilot()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bc*3.6>aZ-250 and d(be)<25 and ar>=0.1 and(CustomTarget.position-bf):len()>2000+as then aR.ToggleAutopilot()an=false end;if VertTakeOff then aV=true;local n7=HoldAltitude;if be<-30 then a2="Unable to achieve lift. Safety Landing."af=0;aV=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bh or HoldAltitude<planet.spaceEngineMinAltitude then if bh then n7=antigrav.getBaseAltitude()end;if as<n7-100 then a_=0;af=15;BrakeIsOn=false elseif be>0 then BrakeIsOn=true;af=0 elseif be<-30 then BrakeIsOn=true;af=15 elseif as>=n7 then if bh then if Autopilot or VectorToTarget then aR.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bG("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bG("vtoc","VT")aR.ToggleVerticalTakeoff()end;af=0 end else if ar>0.08 then a_=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if b5 then a_=0;af=20 else af=0;a_=36;aR.cmdCruise(3500)end else aV=autoRollPreference;IntoOrbit=true;b3=false;CancelIntoOrbit=false;mp=false;mn=nil;mo=nil;if ms==nil then ms=planet end;b2=n7;mr=true;VertTakeOff=false end end;if a_~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local n8=r(a_-bk,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(n8)local n9=r(vTpitchPID:get(),-1,1)U=n9 end end;if IntoOrbit then local mW;local na=false;local nb=c1(b2)if ms==nil then ms=planet;if VectorToTarget then ms=ac end end;if not mr then b2=e(ms.radius+ms.surfaceMaxAltitude+LowOrbitHeight)if ms.hasAtmosphere then b2=e(ms.radius+ms.noAtmosphericDensityAltitude+LowOrbitHeight)end;mr=true end;if b1.VectorToTarget and CustomTarget then mW=CustomTarget.position-bf end;local nc,nd=aO(ms):escapeAndOrbitalSpeed((bf-ms.center):len()-ms.radius)local ne=bl;if not mp then local nf=false;local ng=false;aR.cmdThrottle(0)mo=0;b0="Aligning to orbital path - OrbitHeight: "..nb;if b1.VectorToTarget then mP(mW:normalize():project_on_plane(bd))na=b8:dot(mW:project_on_plane(b7):normalize())>0.95 else mP(bb)na=n1<0.5;if bc<150 then na=true end end;U=0;mn=0;if bk<=mn+1 and bk>=mn-1 then nf=true else nf=false end;if ne<=mo+1 and ne>=mo-1 then ng=true else ng=false end;if nf and ng and na then mn=nil;mo=nil;mp=true end else if b1.VectorToTarget then mP(mW:normalize():project_on_plane(bd))elseif bc>150 then mP(bb)end;U=0;if b1.VectorToTarget and CustomTarget then local a8,_=aM.computeDistanceAndTime(bc,aZ/3.6,av,0,0,LastMaxBrake)if b3 and mW:len()>15000+a8+as then b0="Orbiting to Target"if as-100<=ms.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<ms.noAtmosphericDensityAltitude then b3=false end elseif b3 or mW:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bG("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;b1.VectorToTarget,b1.AutopilotAlign=false,false;aR.ToggleIntoOrbit()aR.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>b2*0.9 and as<b2*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=b2*0.99 and orbit.apoapsis.altitude>=b2*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or b3 then if b3 then BrakeIsOn=false;aR.cmdThrottle(0)mn=0;if not b1.VectorToTarget then a2="Orbit complete"bG("orCom","OB")aR.ToggleIntoOrbit()end else mt=mt+1;if mt>=2 then b3=true end end else b0="Adjusting Orbit - OrbitHeight: "..nb;mq=true;aR.cmdCruise(nd*3.6+1)local nh=b2-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(nh-be*r(utils.smoothstep(2000-nh,-2000,2000)^6*10,1,10))mn=r(VSpdPID:get(),-60,60)end end else local ni=2.75;local nj=d(A(nc*ni))local nk=nj%50;if nk>0 then nj=nj-nk+50 end;BrakeIsOn=false;if as<b2*0.8 then b0="Escaping planet gravity - OrbitHeight: "..nb;mn=utils.map(be,200,0,-15,80)elseif as>=b2*0.8 and as<b2*1.15 then b0="Approaching orbital corridor - OrbitHeight: "..nb;nj=nj*0.75;mn=utils.map(be,100,-100,-15,65)elseif as>=b2*1.15 and as<b2*1.5 then b0="Approaching orbital corridor - OrbitHeight: "..nb;nj=nj*0.75;if be<0 or mq then mn=utils.map(as,b2*1.5,b2*1.01,-30,0)else mn=utils.map(as,b2*0.99,b2*1.5,0,30)end elseif as>b2*1.5 then b0="Reentering orbital corridor - OrbitHeight: "..nb;mn=-65;local nl=utils.map(be,-150,-400,1,0.55)nj=nj*nl end;aR.cmdCruise(e(nj))end end;if mn~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local nm=mn-bk;OrbitPitchPID:inject(nm)local nn=r(OrbitPitchPID:get(),-0.5,0.5)U=nn end end;if Autopilot and ar==0 and not al then local function no(bC,orbit)system.print(bC)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aR.cmdThrottle(0)P=false;a2=bC;bG("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;b2=as;mr=true end;aR.ToggleIntoOrbit()end end;local np,nq=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local nr=(CustomTarget.position-ac.center):normalize()local ns=nr:project_on_plane((ac.center-bf):normalize()):normalize()local nt=ac.center+ns*(ac.radius+AutopilotTargetOrbit)local nu=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bf-nt):len()<(bf-nu):len()then np=nt else np=nu;AutopilotEndSpeed=0 end;AutopilotTargetCoords=np;aR.showWayPoint(ac,AutopilotTargetCoords)nq=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;nq=true;AutopilotRealigned=true;TargetSet=true;np=CustomTarget.position+(bf-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=np end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local nr=(bf+bb*100000-ac.center):normalize()local ns=nr:project_on_plane((ac.center-bf):normalize()):normalize()if ns:len()<1 then nr=(bf+b8*100000-ac.center):normalize()ns=nr:project_on_plane((ac.center-bf):normalize()):normalize()end;np=ac.center+ns*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=np;TargetSet=true;nq=true;AutopilotRealigned=true;aR.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(np)-bf):len()local iz,dp,dq=aL:getPlanetarySystem(0):castIntersections(bf,bb:normalize(),function(d9)if d9.noAtmosphericDensityAltitude>0 then return d9.radius+d9.noAtmosphericDensityAltitude else return d9.radius+d9.surfaceMaxAltitude*1.5 end end)local iA=dp;if dq~=nil and dp~=nil then iA=math.min(dq,dp)end;if iA~=nil and iA<AutopilotDistance and iz.name==ac.name then AutopilotDistance=iA end;local n6=true;local nw=(ac.center-(bf+vec3(bb):normalize()*AutopilotDistance)):len()-ac.radius;local ip=c1(nw)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ip..'"}')local a8,a9;if not TurnBurn then a8,a9=md(bc)else a8,a9=mf(bc)end;if bc>50 and AutopilotAccelerating then local mW=vec3(np)-bf;local nx=r(math.deg(mu(b7,bb:normalize(),mW:normalize()))*bc/500,-90,90)local ny=r(math.deg(mu(b9,bb:normalize(),mW:normalize()))*bc/500,-90,90)if d(nx)<20 and d(ny)<20 then nx=nx*2;ny=ny*2 end;if d(nx)<2 and d(ny)<2 then nx=nx*2;ny=ny*2 end;local n1=-math.deg(mu(b7,b8,bb:normalize()))local n2=-math.deg(mu(b9,b8,bb:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(ny-n2)local nz=r(apPitchPID:get(),-1,1)U=U+nz;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(nx-n1)local nA=r(apYawPID:get(),-1,1)V=V+nA;nq=true;if d(nx)>2 or d(ny)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bG("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end end elseif AutopilotAccelerating and bc<=50 then mP((np-bf):normalize())end;if nw<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(nw)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local iz,iA=aR.checkLOS((AutopilotTargetCoords-bf):normalize())if ac.name~=planet.name then if iz~=nil and ac.name~=iz.name and iA<AutopilotDistance then a2="Collision with "..iz.name.." in "..c1(iA).."\nClear LOS to continue."ai=5;mJ=true else mJ=false;a2=""end end end;if not mJ then if not AutopilotCruising and not AutopilotBraking and not nq then n6=mP((np-bf):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then n6=mP(-vec3(bb):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aR.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local nB=unit.getThrottle()if AtmoSpeedAssist then nB=K end;local nC=99999;local lj=-vec3(core.getWorldAcceleration()):dot(bb:normalize())local nD=r(bb:dot((np-bf):normalize()),0,bc)if nD>0 or lj>0 then nC=aM.computeTravelTime(nD,lj,AutopilotDistance-a8)end;if ba:len()>=MaxGameVelocity or nB==0 and P or warmup/4>nC then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bG("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aR.cmdThrottle(0)end;local nE=AutopilotDistance;if nE<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mh and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mh=bo else mh=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bG("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aR.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aR.cmdThrottle(1,true)end;local _,nd=aO(ac):escapeAndOrbitalSpeed((bf-planet.center):len()-planet.radius)local mW;if CustomTarget then mW=CustomTarget.position-bf end;if CustomTarget and CustomTarget.planetname=="Space"and bc<50 then no("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bc<=nd and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then no("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bG("apCir","AP")AutopilotStatus="Circularizing"end;if bc<=nd then if CustomTarget then if bb:normalize():dot(mW:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bG("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else no("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else no("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then no("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nE=AutopilotDistance;if nE<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mh and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mh=bo else mh=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bG("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local nB=unit.getThrottle()if AtmoSpeedAssist then nB=K end;if nB>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end;AutopilotCruising=false end else if n6 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*b9;AutopilotShipUp=b7;AutopilotShipRight=b9 end;AutopilotRealigned=true elseif n6 and not mJ then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end;if not P then aR.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bG("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aR.cmdThrottle(0)P=false;ProgradeIsOn=true;al=true;aR.showWayPoint(ac,CustomTarget.position)end;if a0 then aV=true;local ny=0;local e8=bf+vec3(unit.getMasterPlayerRelativePosition())local nF=e8-bf;local nG=vec3(nF):project_on(b8):len()local nH=vec3(nF):project_on(b9):len()local aj=y(nG*nG+nH*nH)mP(nF:normalize())local jz=40;local nI=aj<jz;local nJ=100;local nK=r((aj-jz)/2,10,nJ)U=0;local n6=d(V)<0.1;if n6 and bc<nK and not nI then BrakeIsOn=false;ny=-20 else BrakeIsOn=true;ny=0 end;local nL=0;if d(ny-bk)>nL then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(ny-bk)local nz=pitchPID:get()U=nz end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local nM=LastMaxBrakeInAtmo;if nM then nM=nM*r(bc/100,0.1,1)*ar else nM=LastMaxBrake end;if ar<0.01 then nM=LastMaxBrake end;local nN=b8:project_on_plane(bd):normalize():dot(bb)local nO=vec3(core.getWorldAirFrictionAcceleration())local nP=nO:len()*av;if nN>100 then a8,a9=aM.computeDistanceAndTime(nN,100,av,0,0,nM)local nQ,nR=aM.computeDistanceAndTime(100,0,av,0,0,nM*0.55)a8=a8+nQ else a8,a9=aM.computeDistanceAndTime(nN,0,av,0,0,nM*0.55)end;local nh=HoldAltitude-as-be;local nS=200+bc;if Reentry or al then minMax=2000+bc end;local nT=1;if AutoTakeoff then nT=r(bc/100,0.1,1)end;local ny=(utils.smoothstep(nh,-nS,nS)-0.5)*2*MaxPitch*nT;if not Reentry and not al and not VectorToTarget and b8:dot(bb:normalize())<0.99 then ny=(utils.smoothstep(nh,-nS*r(20-19*ar*10,1,20),nS*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*nT end;if not AltitudeHold then ny=0 end;if LockPitch~=nil then if br and not IntoOrbit then ny=LockPitch else LockPitch=nil end end;aV=true;local nU=U;if Reentry then local nV=e(aZ)local nW,nX=aM.computeDistanceAndTime(bc,nV/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)nW=nW==-1 and 5000 or nW;local nY=as-(planet.noAtmosphericDensityAltitude+nW)local nZ=as>planet.noAtmosphericDensityAltitude+nW*1.35;if nZ then ny=ReEntryPitch;if bc<=nV/3.6 and bc>nV/3.6-10 and d(bb:normalize():dot(b8))>0.9 and not bj then O=false;aR.cmdThrottle(1)end elseif bj and not nZ and not aq then aR.cmdCruise(nV,true)end;if bj then if bc>nV/3.6 and not nZ then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if be>0 then BrakeIsOn=true end;if not R then ny=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;ny=0;aV=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and nZ then aV=true elseif not nZ then if not aq and(bj or s:getTargetSpeed(axisCommandId.longitudinal)~=nV)then aR.cmdCruise(nV)end;if bc<nV/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;aV=true end end end;if bc>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then mP(vec3(bb))end;if bp or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local mW;if bp then if type(bp)=="table"then mW=bp elseif bp<3 and bp>0 then mW=-bd:cross(bb)*5000 elseif bp>=3 then mW=bd:cross(bb)*5000 elseif bp<0 then mW=bb*25000 end elseif CustomTarget~=nil then mW=CustomTarget.position-bf else mW=ac.center-bf end;local nx=math.deg(mu(bd:normalize(),bb,mW))*2;local jC=math.rad(d(bl))if bc>minRollVelocity and ar>0.01 then local n_=1000+bc;local o0=(utils.smoothstep(nh-be*10,-n_,n_)-0.5)*2*MaxPitch;local o1=r(90-o0,0,180)aY=r(nx*2,-o1,o1)local o2=nx;nx=r(r(nx,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jC)+4*(bk-ny)*math.sin(math.rad(bl)),-YawStallAngle*0.80,YawStallAngle*0.80)local o3=1;if aY~=0 then o3=d(jC/aY)end;o3=(90-r(d(aY-bl),0,90))/90;local o4=ny;if d(bl)>90 then o4=-o4 end;ny=o3*r(r(o4*math.cos(jC),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(o2)*math.sin(jC),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aY=0;nx=r(nx,-YawStallAngle*0.80,YawStallAngle*0.80)end;local o5=n1-nx;if bp and d(o5)<=0.0001 and(type(bp)=="table"or type(bp)~="table"and bp<0 and d(bl)<1)then if bp==-2 then aR.ToggleAltitudeHold()end;bp=nil;bG("180Off","BR")return end;if not aX and bc>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(o5)local nA=r(yawPID:get(),-1,1)V=V+nA elseif aq and ao>-1 or bc<minRollVelocity then mP(mW)elseif aX and ar>0.01 then if(n1<-YawStallAngle or n1>YawStallAngle)and ar>0.01 then mP(bb)end;if(n2<-PitchStallAngle or n2>PitchStallAngle)and ar>0.01 then ny=r(bk-n2,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local n7=planet:getAltitude(CustomTarget.position)local nY=mW:project_on_plane(bd):len()StrongBrakes=true;if not am and not Reentry and nY<=a8 and(bb:project_on_plane(bd):normalize():dot(mW:project_on_plane(bd):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(nN<0.1 or nY<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<nY)then if not bh then bG("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bs=false end;LastDistanceToTarget=nY end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local mW=CustomTarget.position-bf;local n7=planet:getAltitude(CustomTarget.position)local nY=y(mW:len()^2-(as-n7)^2)local nM=LastMaxBrakeInAtmo;if nM then a8,a9=aM.computeDistanceAndTime(bc,0,av,0,0,nM/2)StrongBrakes=true;if nY<=a8+bc*n0/2 and bb:project_on_plane(bd):normalize():dot(mW:project_on_plane(bd):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;aR.BeginReentry()end end;LastDistanceToTarget=nY end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not b3 and not IntoOrbit then b2=HoldAltitude;mr=true;if VectorToTarget then b1.VectorToTarget=true end;aR.ToggleIntoOrbit()VectorToTarget=false;mp=true end end;if aX and ar>0.01 and ao==-1 and bc>minRollVelocity and VectorStatus~="Finalizing Approach"then mP(bb)ny=r(bk-n2,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end;U=nU;local mD=-1;if BrakeLanding then ny=0;local o6=false;local o7=30;if aN~=nil and aN>0 then local o8=r(ar,0.4,2)local nM=LastMaxBrakeInAtmo*r(bc/100,0.1,1)*o8;local o9=aN*o8+nM-l7;local oa=nM/2-l7;local ob=bc-y(d(oa/2)*20/(0.5*av))*utils.sign(oa)if ob<0 then ob=0 end;local oc;if bc>100 then local od,_=aM.computeDistanceAndTime(bc,100,av,0,0,nM)local oe,_=aM.computeDistanceAndTime(100,0,av,0,0,y(nM))oc=od+oe else oc=aM.computeDistanceAndTime(bc,0,av,0,0,y(nM))end;if oc<20 then BrakeIsOn=false else local of=0;if ob>100 then local og,_=aM.computeDistanceAndTime(ob,100,av,0,0,o9)local oh,_=aM.computeDistanceAndTime(100,0,av,0,0,aN*o8+y(nM)-l7)of=og+oh else of,_=aM.computeDistanceAndTime(ob,0,av,0,0,aN*o8+y(nM)-l7)end;of=(of+15+bc*n0)*1.1;local oi=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if oi then local n7=planet:getAltitude(CustomTarget.position)local oj=as-n7-100;local mW=CustomTarget.position-bf;local ok=y(mW:len()^2-(as-n7)^2)if ok>100 then oi=false elseif oj<=of or of==-1 then BrakeIsOn=true;o6=true else BrakeIsOn=false;o6=true end end;if not oi and CalculateBrakeLandingSpeed then if of>=o7 then BrakeIsOn=true else BrakeIsOn=false end;o6=true end end end;if not bj then aR.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;mD=ao;if mD>-1 then aV=autoRollPreference;if bc<1 or bb:normalize():dot(bd)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bG("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bb:normalize():dot(-gR)<0.999 then BrakeIsOn=true elseif be<-brakeLandingRate and not o6 then BrakeIsOn=true elseif not o6 then BrakeIsOn=false end end;if AutoTakeoff or am then local iz,dq,dp;if AutopilotTargetCoords~=nil then iz,dq,dp=aL:getPlanetarySystem(0):castIntersections(bf,(AutopilotTargetCoords-bf):normalize(),function(d9)return d9.radius+d9.noAtmosphericDensityAltitude end)end;if bh then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aR.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(ny)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bj and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bc<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;aR.cmdThrottle(0)elseif am then aR.cmdThrottle(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(iz==nil or iz.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bj then aR.cmdThrottle(0)end;AutopilotAccelerating=true end end;local ol=ao>-1;local om=bk;if(VectorToTarget or am or bp)and not ol and bc>minRollVelocity and ar>0.01 then local jC=math.rad(d(bl))om=bk*d(math.cos(jC))+n2*math.sin(jC)end;local on=r(ny-om,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then on=r(ny-om,-85,MaxPitch)elseif ar<0.01 then on=r(ny-om,-MaxPitch,MaxPitch)end;if d(bl)<5 or VectorToTarget or bp or BrakeLanding or ol or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(on)local nz=pitchPID:get()U=U+nz end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function mc.ToggleIntoOrbit()b3=false;mn=nil;mo=nil;mt=0;if ar==0 then if IntoOrbit then bG("orOff","AP")IntoOrbit=false;mp=false;ms=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mr=false elseif br then bG("orOn","AP")IntoOrbit=true;aV=true;if ms==nil then ms=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;mp=false;ms=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mr=false end end;function mc.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aV=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aR.cmdCruise(e(aZ))end else b3=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function mc.checkLOS(mQ)local iz,dp,dq=aL:getPlanetarySystem(0):castIntersections(bf,mQ,function(d9)if d9.noAtmosphericDensityAltitude>0 then return d9.radius+d9.noAtmosphericDensityAltitude else return d9.radius+d9.surfaceMaxAltitude*1.5 end end)local iA=dp;if dq~=nil and dp~=nil then iA=math.min(dq,dp)end;if iA~=nil then return iz,iA else return nil,nil end end;function mc.ToggleAutopilot()local function oo(SpaceTarget)bs=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aR.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if E-mm<1.5 and ar>0 then if not b6 then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bG("orH","OH")end;mm=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else mm=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aQ.UpdateAutopilotTarget()aR.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bG("apSpc","AP")if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bG("vtt","AP")oo(SpaceTarget)end else bG("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then b3=false;Autopilot=true elseif not aq then if IntoOrbit then aR.ToggleIntoOrbit()end;b2=planet.noAtmosphericDensityAltitude+LowOrbitHeight;mr=true;b1.AutopilotAlign=true;b1.VectorToTarget=true;mp=false;if not IntoOrbit then aR.ToggleIntoOrbit()end end end else bG("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and br)and not IntoOrbit then WaypointSet=false;b3=false;mp=false;aR.ToggleIntoOrbit()else bG("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bG("apP","AP")am=true;aR.ToggleAltitudeHold()end else bG("apOff","AP")aR.ResetAutopilots(1)end end;function mc.cmdThrottle(cz,op)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not op then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cz)K=r(A(cz*100,0)/100,-1,1)bi=nil end;function mc.cmdCruise(cz,op)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not op then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cz)bi=cz end;function mc.ToggleLockPitch()if LockPitch==nil then bG("lkPOn","LP")if not a1 then LockPitch=bk else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bG("lkPOff","LP")LockPitch=nil end end;function mc.ToggleAltitudeHold()if E-ml<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bG("11","EP")else if br then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b2=HoldAltitude;mr=true;if not IntoOrbit then aR.ToggleIntoOrbit()end;mp=true end end;ml=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else ml=E end;if br and ar==0 then b2=as;mr=true;mp=true;aR.ToggleIntoOrbit()if IntoOrbit then ml=E else ml=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;aV=true;LockPitch=nil;b3=false;if ao~=-1 and bc<20 then bG("lfs","LS")AutoTakeoff=true;if ml>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bg then aR.ToggleVerticalTakeoff()end else bG("altOn","AH")AutoTakeoff=false;if ml>-1 then if br then HoldAltitude=as end end;if VertTakeOff then aR.ToggleVerticalTakeoff()end end;if am then HoldAltitude=100000 end else bG("altOff","AH")if IntoOrbit then aR.ToggleIntoOrbit()end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;aV=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;ml=0 end end;function mc.ResetAutopilots(mc)if mc then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bp=nil;if not bh then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;if IntoOrbit then aR.ToggleIntoOrbit()end;aV=autoRollPreference;al=false;an=false;af=0 end;function mc.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aV=autoRollPreference end;if BrakeIsOn then bG("bkOn","B",1)aR.ResetAutopilots()else bG("bkOff","B",1)end end;function mc.BeginReentry()if Reentry then a2="Re-Entry cancelled"bG("reOff","RE")Reentry=false;aV=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;aV=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aZ;bG("par","RE")else Reentry=true;AltitudeHold=true;aV=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bW=c1(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..aZ.." Target Altitude: "..bW;bG("glide","RE")aR.cmdCruise(e(aZ))end;AutoTakeoff=false end;function mc.ToggleAntigrav()if antigrav and not ExternalAGG then if bh then bG("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bG("aggOn","AG")antigrav.activate()antigrav.show()end end end;ao=my()return mc end;function script.onStart()local oq=false;local function os()local function ot(ou)local ov=dbHud_1.hasKey;for cd,ce in pairs(ou)do if ov(ce)then local cu=g(dbHud_1.getStringValue(ce))if cu~=nil then _G[ce]=cu;oq=true end end end end;if dbHud_1 then if not useTheseSettings then ot(bM())coroutine.yield()ot(c)else ot(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;oq=false end;coroutine.yield()if oq then a2="Loaded Saved Variables"aD=ResolutionX;aE=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aV=autoRollPreference;aZ=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function ow()local function ox(oy,oz)if oy>oz then oz=oy end;local oA,oB=0,0;if ContainerOptimization>0 then oA=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then oB=FuelTankOptimization*0.05 end;oz=oz*(1-(oA+oB))return oz end;local oC=core.getElementNameById;local oD=fuelX~=0 and fuelY~=0;for cd in pairs(at)do local type=core.getElementTypeById(at[cd])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cd])),'^.*vertical.*$')and core.getElementForwardById(at[cd])[3]>0 then bg=true end end;if o(type,'^.*Space Engine$')then b6=true;if o(tostring(core.getElementTagsById(at[cd])),'^.*vertical.*$')then local oE=core.getElementForwardById(at[cd])if oE[3]<0 then b4=true else b5=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local oF=j(at[cd])if oF>10000 then G=110 elseif oF>1000 then G=55 elseif oF>150 then G=27 end end;aI=aI+j(at[cd])if oD and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local oF=j(at[cd])local lf=l(at[cd])local oy=0;local gD=q()if type=="Atmospheric Fuel Tank"then local oz=400;local oG=35.03;if oF>10000 then oz=51200;oG=5480 elseif oF>1300 then oz=6400;oG=988.67 elseif oF>150 then oz=1600;oG=182.67 end;oy=lf-oG;if fuelTankHandlingAtmo>0 then oz=oz+oz*fuelTankHandlingAtmo*0.2 end;oz=ox(oy,oz)aF[#aF+1]={at[cd],oC(at[cd]),oz,oG,oy,gD}end;if type=="Rocket Fuel Tank"then local oz=320;local oG=173.42;if oF>65000 then oz=40000;oG=25740 elseif oF>6000 then oz=5120;oG=4720 elseif oF>700 then oz=640;oG=886.72 end;oy=lf-oG;if fuelTankHandlingRocket>0 then oz=oz+oz*fuelTankHandlingRocket*0.1 end;oz=ox(oy,oz)aH[#aH+1]={at[cd],oC(at[cd]),oz,oG,oy,gD}end;if type=="Space Fuel Tank"then local oz=600;local oG=35.03;if oF>10000 then oz=76800;oG=5480 elseif oF>1300 then oz=9600;oG=988.67 elseif oF>150 then oz=2400;oG=182.67 end;oy=lf-oG;if fuelTankHandlingSpace>0 then oz=oz+oz*fuelTankHandlingSpace*0.2 end;oz=ox(oy,oz)aG[#aG+1]={at[cd],oC(at[cd]),oz,oG,oy,gD}end end end;if not bg then VertTakeOff,VertTakeOffEngine=false,false end end;local function oH()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,ce in pairs(door)do ce.toggle()end end;if switch then for _,ce in pairs(switch)do ce.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,ce in pairs(forcefield)do ce.toggle()end end;if antigrav then bh=antigrav.getState()==1;if bh and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and ba:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(aW)if aq and ao~=-1 then aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function oI()local oJ={}local function oK()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local oL={[1]=4480,[6]=4480,[7]=6270}for oM,oN in pairs(b)do b[oM][0]=oK()b[oM][0].systemId=oM;oJ[oM]={}for oO,planet in pairs(b[oM])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=oL[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=oM;planet.bodyId=planet.id;oJ[oM][oO]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bz[#bz+1]=planet end end end;aK=cf()aL=aK(oJ)aM=dD()aO=e6()aQ=lV()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})os()coroutine.yield()ow()coroutine.yield()aR=mb()oH()coroutine.yield()oI()aS=eu()aP=fO()aP.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bG("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,ce in pairs(door)do ce.toggle()end end;if switch then for _,ce in pairs(switch)do ce.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,ce in pairs(forcefield)do ce.toggle()end end;showHud=bB;c9()if button then button.activate()end;if SetWaypointOnExit then aR.showWayPoint(planet,bf)end;bG("stop","SU")end;function script.onTick(oP)local oQ=nil;if oP=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bG("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif oP=="tenthSecond"then local function oR()local oS=system.createData;local oT=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=oT(panelInterplanetary,"value")interplanetaryHeaderText=oS('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=oT(panelInterplanetary,"value")widgetDistanceText=oS('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=oT(panelInterplanetary,"value")widgetTravelTimeText=oS('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=oT(panelInterplanetary,"value")widgetMaxMassText=oS('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=oT(panelInterplanetary,"value")widgetTargetOrbitText=oS('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=oT(panelInterplanetary,"value")widgetCurBrakeDistanceText=oS('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=oT(panelInterplanetary,"value")widgetCurBrakeTimeText=oS('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=oT(panelInterplanetary,"value")widgetMaxBrakeDistanceText=oS('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=oT(panelInterplanetary,"value")widgetMaxBrakeTimeText=oS('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=oT(panelInterplanetary,"value")widgetTrajectoryAltitudeText=oS('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function oU()t(panelInterplanetary)panelInterplanetary=nil end;local function oV()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bf):len()else AutopilotDistance=(CustomTarget.position-bf):len()end end;local e4=bc;local nB=unit.getThrottle()/100;if AtmoSpeedAssist then nB=K end;local oW,oX=aM.computeDistanceAndTime(bc,MaxGameVelocity,av,a:maxForceForward()*nB,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,oY;if not TurnBurn and e4>0 then _,oY=aR.GetAutopilotBrakeDistanceAndTime(e4)else _,oY=aR.GetAutopilotTBBrakeDistanceAndTime(e4)end;local oZ=0;local o_=0;if AutopilotCruising or not Autopilot and e4>5 then o_=aM.computeTravelTime(e4,0,AutopilotDistance)elseif a8+oW<AutopilotDistance then oZ=AutopilotDistance-(a8+oW)o_=aM.computeTravelTime(8333.0556,0,oZ)else local p0=(AutopilotDistance-a8)/oW;oW=AutopilotDistance-a8;oX=oX*p0 end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return o_ elseif AutopilotBraking then return oY elseif AutopilotCruising then return o_+oY else return oX+a9+o_ end end;local function p1(l7,p2)if l7==nil then l7=core.g()end;l7=A(l7,5)if p2~=nil and p2 or(oQ==nil or oQ~=l7)then local e4=ba:len()local p3=g(unit.getData()).maxBrake;if p3~=nil and p3>0 and aq then p3=p3/r(e4/100,0.1,1)p3=p3/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+p3)/2 else LastMaxBrakeInAtmo=p3 end end end;if p3~=nil and p3>0 then LastMaxBrake=p3 end;oQ=l7 end end;p1(nil,true)if bi~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bi then aR.cmdCruise(bi)else bi=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then oR()end;if AutopilotTargetName~=nil then local p4=CustomTarget~=nil;local p5=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()p5=p5>1000000 and A(p5/1000000,2).." kTons"or A(p5/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=oV()if p4 and not Autopilot then aj=(bf-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bf):len()end;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ip=c1(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ip..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..c4(travelTime)..'", "unit":""}')ip=c1(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ip..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..c4(a9)..'", "unit":""}')ip=c1(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ip..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..c4(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",p5)..'", "unit":""}')ip=c1(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ip..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bj and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then aR.cmdThrottle(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else oU()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aP.TenthTick()elseif oP=="oneSecond"then local function p6(gN)local p7=0;aB=""local p8=aI;local p9=0;local pa=0;local pb=0;local gH=0;local gI=""local pc=core.getElementHitPointsById;for cd in pairs(at)do local oF=0;local pd=0;pd=j(at[cd])oF=pc(at[cd])p9=p9+oF;if oF<pd then if oF==0 then pb=pb+1 else pa=pa+1 end;if aJ and#aA==0 then position=vec3(core.getElementPositionById(at[cd]))local bU=position.x;local bV=position.y;local f0=position.z;table.insert(aA,core.spawnArrowSticker(bU,bV,f0+1,"down"))table.insert(aA,core.spawnArrowSticker(bU,bV,f0+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(bU+1,bV,f0,"north"))table.insert(aA,core.spawnArrowSticker(bU+1,bV,f0,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(bU-1,bV,f0,"south"))table.insert(aA,core.spawnArrowSticker(bU-1,bV,f0,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(bU,bV-1,f0,"east"))table.insert(aA,core.spawnArrowSticker(bU,bV-1,f0,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(bU,bV+1,f0,"west"))table.insert(aA,core.spawnArrowSticker(bU,bV+1,f0,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cd])end elseif aJ and#aA>0 and aA[11]==at[cd]then for gC in pairs(aA)do core.deleteSticker(aA[gC])end;aA={}end end;p7=e(p9/p8*100)if p7<100 then gN[#gN+1]=bT(0,0,"","pbright txt")gH=e(p7*2.55)gI=f("rgb(%d,%d,%d)",255-gH,gH,0)if p7<100 then gN[#gN+1]=bT("50%",1035,"Elemental Integrity: "..p7 .."%","txtbig txtmid","fill:"..gI)if pb>0 then gN[#gN+1]=bT("50%",1055,"Disabled Modules: "..pb.." Damaged Modules: "..pa,"txtbig txtmid","fill:"..gI)elseif pa>0 then gN[#gN+1]=bT("50%",1055,"Damaged Modules: "..pa,"txtbig txtmid","fill:"..gI)end end end end;local function pe()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bx=core.getPlayersOnBoard()by=core.getDockedConstructs()pe()local gN={}aP.OneSecond(gN)if ShouldCheckDamage then p6(gN)end;ak=table.concat(gN,"")collectgarbage("collect")elseif oP=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cu=g(dbHud_1.getStringValue("SavedLocations"))if cu~=nil then _G["SavedLocations"]=cu;local fj=-1;local m7;for cd,ce in pairs(SavedLocations)do if ce.name and ce.name=="SatNav Location"then fj=cd;break end end;if fj~=-1 then m7=SavedLocations[fj]fj=-1;for cd,ce in pairs(b[0])do if ce.name and ce.name=="SatNav Location"then fj=cd;break end end;if fj>-1 then b[0][fj]=m7 end;aQ.UpdateAtlasLocationsList()a2=m7.name.." position updated"end end;for i=1,#bm do if bm[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bm[i].name)aQ.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif oP=="msgTick"then local gN={}aP.DisplayMessage(gN,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif oP=="animateTick"then aU=true;aT=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif oP=="hudTick"then aP.hudtick()elseif oP=="apTick"then aR.APTick()elseif oP=="radarTick"then aS.UpdateRadar()elseif oP=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function pf(pg,nK)local ph=vec3()local pi=vec3()if pg==axisCommandId.longitudinal then ph=vec3(core.getConstructOrientationForward())pi=b8 elseif pg==axisCommandId.vertical then ph=vec3(core.getConstructOrientationUp())pi=b7 elseif pg==axisCommandId.lateral then ph=vec3(core.getConstructOrientationRight())pi=b9 else return vec3()end;local pj=vec3(core.getWorldGravity())local pk=pj:dot(pi)local pl=vec3(core.getWorldAirFrictionAcceleration())local pm=pl:dot(pi)local pn=ba:dot(ph)local po=nK*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(po-pn)local pp=targetSpeedPID2:get()local pq=(pp-pm-pk)*pi;return pq end;local function pr(pg,nK)local ph=vec3()local pi=vec3()if pg==axisCommandId.longitudinal then ph=vec3(core.getConstructOrientationForward())pi=b8 elseif pg==axisCommandId.vertical then ph=vec3(core.getConstructOrientationUp())pi=b7 elseif pg==axisCommandId.lateral then ph=vec3(core.getConstructOrientationRight())pi=b9 else return vec3()end;local pj=vec3(core.getWorldGravity())local pk=pj:dot(pi)local pl=vec3(core.getWorldAirFrictionAcceleration())local pm=pl:dot(pi)local pn=ba:dot(ph)local po=nK*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(po-pn)local pp=targetSpeedPID:get()local pq=(pp-pm-pk)*pi;return pq end;local function ps(pt,gQ,l_)local pu=pt:cross(l_):normalize_inplace()local hC=math.acos(r(pu:dot(-gQ),-1,1))*constants.rad2deg;if pu:cross(-gQ):dot(l_)<0 then hC=-hC end;return hC end;if antigrav and not ExternalAGG then if not bh and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bj=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bj and O then aR.cmdThrottle(0)O=false elseif not bj and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local pv=r(T+U+system.getControlDeviceForwardInput(),-1,1)local pw=r(W+Z+system.getControlDeviceYawInput(),-1,1)local px=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local py=Y;bd=vec3(core.getWorldVertical())if bd==nil or bd:len()==0 then bd=(planet.center-bf):normalize()end;b7=vec3(core.getConstructWorldOrientationUp())b8=vec3(core.getConstructWorldOrientationForward())b9=vec3(core.getConstructWorldOrientationRight())bb=vec3(core.getWorldVelocity())ba=vec3(core.getVelocity())bf=vec3(core.getConstructWorldPos())av=core.getConstructMass()bc=vec3(bb):len()be=-bd:dot(bb)bl=getRoll(bd,b8,b9)local pz=bl/180*math.pi;local pA=math.cos(pz)local pB=math.sin(pz)bk=ps(bd,b8,b9*pA+b7*pB)local pC=bb:normalize()local pD=d(bl)local pE=utils.sign(bl)local pF=vec3(core.getWorldAngularVelocity())local pG=pv*pitchSpeedFactor*b9+pw*rollSpeedFactor*b8+px*yawSpeedFactor*b7;if aV==true and bd:len()>0.01 then local pH=d(aY-bl)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and pH>0 or ar>0.0 and pH<autoRollRollThreshold and autoRollPreference)and pw==0 and d(bk)<85 then local pI=aY;local pJ=autoRollFactor;if ar==0 then pJ=pJ/4;aY=0;pI=0 end;if rollPID==nil then rollPID=pid.new(pJ*0.01,0,pJ*0.1)end;rollPID:inject(pI-bl)local pK=rollPID:get()pG=pG+pK*b8 end end;local pL=1;local pM=0;local pN=1;local pO=system.getMouseWheel()if pO>0 then bD()elseif pO<0 then bD(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bj then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aZ/3.6-bb:dot(b8))local pP=throttlePID:get()N=r(pP,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-aZ/3.6)local pQ=r(brakePID:get(),0,1)if ar>0 and be<-80 or ar>0.005 then L=pQ end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pR=''local pS=vec3()local pT=pf(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pT,pM)local pU='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pU=pU..ExtraLongitudeTags end;local pV=s:getAxisCommandType(axisCommandId.longitudinal)local pW=s:composeAxisAccelerationFromThrottle(pU,axisCommandId.longitudinal)local pX=pr(axisCommandId.lateral,LeftAmount*1000)pR=pR..' , '.."lateral airfoil , lateral ground "pS=pS+pX;if pS:len()>constants.epsilon then a:setEngineForceCommand(pR,pS,pM,'','','',pN)end;a:setEngineForceCommand(pU,pW,pL)local pY='thrust analog vertical fueled 'local pZ='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then pZ=pZ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then pY=pY..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(pY,pT,pL)else a:setEngineForceCommand(pY,vec3(),pL)end;if LeftAmount~=0 then a:setEngineForceCommand(pZ,pX,pL)else a:setEngineForceCommand(pZ,vec3(),pL)end;if py==0 then py=L end;local p_=-py*(brakeSpeedFactor*bb+brakeFlatFactor*pC)a:setEngineForceCommand('brake',p_)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local nK=unit.getAxisCommandValue(0)if not bj then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-nK/3.6)local pQ=r(brakePID:get(),0,1)py=r(py+pQ,0,1)end;local p_=-py*(brakeSpeedFactor*bb+brakeFlatFactor*pC)a:setEngineForceCommand('brake',p_)local pR=''local pS=vec3()local q0=false;local pU='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pU=pU..ExtraLongitudeTags end;local pV=s:getAxisCommandType(axisCommandId.longitudinal)if pV==axisCommandType.byThrottle then local pW=s:composeAxisAccelerationFromThrottle(pU,axisCommandId.longitudinal)a:setEngineForceCommand(pU,pW,pL)elseif pV==axisCommandType.byTargetSpeed then local pW=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pR=pR..' , '..pU;pS=pS+pW;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then q0=true end end;local pZ='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then pZ=pZ..ExtraLateralTags end;local q1=s:getAxisCommandType(axisCommandId.lateral)if q1==axisCommandType.byThrottle then local q2=s:composeAxisAccelerationFromThrottle(pZ,axisCommandId.lateral)a:setEngineForceCommand(pZ,q2,pL)elseif q1==axisCommandType.byTargetSpeed then local pX=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pR=pR..' , '..pZ;pS=pS+pX end;local pY='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then pY=pY..ExtraVerticalTags end;local q3=s:getAxisCommandType(axisCommandId.vertical)if q3==axisCommandType.byThrottle then local pT=s:composeAxisAccelerationFromThrottle(pY,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(pY,pT,pL,'airfoil','ground','',pN)else a:setEngineForceCommand(pY,vec3(),pL)a:setEngineForceCommand('airfoil vertical',pT,pL,'airfoil','','',pN)a:setEngineForceCommand('ground vertical',pT,pL,'ground','','',pN)end elseif q3==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),pL)end;local q4=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pR=pR..' , '..pY;pS=pS+q4 end;if pS:len()>constants.epsilon then if Y~=0 or q0 or d(pC:dot(b8))<0.5 then pR=pR..', brake'end;a:setEngineForceCommand(pR,pS,pM,'','','',pN)end end;local q5=torqueFactor*(pG-pF)local q6=vec3(core.getWorldAirFrictionAngularAcceleration())q5=q5-q6;a:setEngineTorqueCommand('torque',q5,pL,'airfoil','','',pN)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local e4=ba:len()local q7=0.15;if not bj then local q8=s:getTargetSpeed(axisCommandId.longitudinal)if e4*3.6>q8*(1-q7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4*3.6<q8*(1-q7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nB=unit.getThrottle()if AtmoSpeedAssist then nB=K*100 end;local nK=nB/100;if k==0 then nK=nK*MaxGameVelocity;if e4>=nK*(1-q7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4<nK*(1-q7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nV=e(aZ)nK=nK*nV/3.6;if e4>=nK*(1-q7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4<nK*(1-q7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fG=coroutine.status(beginSetup)if fG=="suspended"then local cz,fH=coroutine.resume(beginSetup)if fH then system.print("ERROR STARTUP: "..fH)end elseif fG=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aT and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(q9)local function qa(bE)local D=1;local function qb(qc,bE)local qd={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local qe=qc;for _,ce in ipairs(qd)do if bE and qe>ce then qc=ce elseif qc<ce and not bE then qc=ce;break end end;return qc end;if bE then D=-1 end;if not ExternalAGG and bh then if a1 and bE then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then b2=qb(b2,bE)else b2=b2+D*a3 end;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=qb(HoldAltitude,bE)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function qf(qg)if not aq then a2="Flight Assist in Atmo only"return end;local ck=type(qg)if bp==nil then if ck=="table"then if Autopilot or VectorToTarget then aR.ToggleAutopilot()end;bG("180On","BR")elseif qg==1 then bG("bnkLft","BR")else bG("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aR.ToggleAltitudeHold()if ck~="table"then qg=qg+1 end end;bp=qg else bG("180Off","BR")bp=nil end end;if q9=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aR.cmdThrottle(0)if vBooster or hover then if aq and ao==-1 then bG("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aV=true;GearExtended=false else if S then bG("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bG("grOut","LG",1)a.control.extendLandingGears()end else if S then bG("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif q9=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif q9=="forward"then T=T-1 elseif q9=="backward"then if AltIsOn then qf(-bb*5000)else T=T+1 end elseif q9=="left"then if AltIsOn then qf(1)else W=W-1 end elseif q9=="right"then if AltIsOn then qf(3)else W=W+1 end elseif q9=="yawright"then X=X-1 elseif q9=="yawleft"then X=X+1 elseif q9=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif q9=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif q9=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif q9=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif q9=="groundaltitudeup"then qa()elseif q9=="groundaltitudedown"then qa(true)elseif q9=="option1"then toggleView=false;if AltIsOn and a1 then local qh=""for i=1,#bx do qh=qh.."| Name: "..system.getPlayerName(bx[i]).." Mass: "..A(core.getBoardedPlayerMass(bx[i])/1000,1).."t "end;system.print("Onboard: "..qh)return end;aQ.adjustAutopilotTargetIndex()elseif q9=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bx do core.forceDeboard(bx[i])end;a2="Deboarded All Passengers"return end;aQ.adjustAutopilotTargetIndex(1)elseif q9=="option3"then local function qi()aC=not aC;if not aC then bG("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bG("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local qh=""for i=1,#by do qh=qh.."| ID: "..by[i].." Mass: "..A(core.getDockedConstructMass(by[i])/1000,1).."t "end;system.print("Docked Ships: "..qh)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;qi()toggleView=false elseif q9=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#by do core.forceUndock(by[i])end;a2="Undocked all ships"return end;bp=nil;aR.ToggleAutopilot()elseif q9=="option5"then toggleView=false;aR.ToggleLockPitch()elseif q9=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local qj=shield_1.getVentingCooldown()if qj>0 then a2="Cannot vent again for "..qj.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aR.ToggleAltitudeHold()elseif q9=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif q9=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bG("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bG("gsOn","GS")end;toggleView=false elseif q9=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aR.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bG("gyOn","GA")else bG("gyOff","GA")end end;toggleView=false elseif q9=="lshift"then bu=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;aU=false;aT=false end elseif q9=="brake"then if BrakeToggleStatus or AltIsOn then aR.BrakeToggle()elseif not BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=true end elseif q9=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif q9=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif q9=="stopengines"then local function qk()if E-F<1.5 then bG("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bp=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;aV=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;qk()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aR.cmdThrottle(0)else aR.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then aR.cmdCruise(AtmoSpeedLimit)else aR.cmdCruise(MaxGameVelocity*3.6)end end end elseif q9=="speedup"then bD()elseif q9=="speeddown"then bD(true)elseif q9=="antigravity"and not ExternalAGG then if antigrav~=nil then aR.ToggleAntigrav()end end end;function script.onActionStop(q9)local function ql()if not ExternalAGG and bh then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if q9=="forward"then T=0 elseif q9=="backward"then T=0 elseif q9=="left"then if bp then if bp==2 then bp=-2 else bp=-1 end end;W=0 elseif q9=="right"then if bp then if bp==4 then bp=-2 else bp=-1 end end;W=0 elseif q9=="yawright"then X=0 elseif q9=="yawleft"then X=0 elseif q9=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif q9=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif q9=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif q9=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif q9=="groundaltitudeup"then ql()toggleView=false elseif q9=="groundaltitudedown"then ql()toggleView=false elseif q9=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then aU=false;aT=false end;a1=false elseif q9=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=false end end elseif q9=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(q9)local function qm(bE)local D=1;if bE then D=-1 end;if not ExternalAGG and bh then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then b2=b2+D*a5;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function qn(bE)local D=1;if bE then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if q9=="groundaltitudeup"then if not a1 then qm()end elseif q9=="groundaltitudedown"then if not a1 then qm(true)end elseif q9=="speedup"then qn()elseif q9=="speeddown"then qn(true)end end;function script.onInputText(bW)local function qo(qp,e8,hy)local function qq(e8)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs='::pos{'..B..','..B..','..B..','..B..','..B..'}'local cG,cH,cN,cO,cP=o(e8,cs)if cG=="0"and cH=="0"then return vec3(z(cN),z(cO),z(cP))end;cO=math.rad(cO)cN=math.rad(cN)local planet=b[z(cG)][z(cH)]local dA=math.cos(cN)local qr=vec3(dA*math.cos(cO),dA*math.sin(cO),math.sin(cN))return planet.center+(planet.radius+cP)*qr end;local position=qq(e8)return aQ.AddNewLocation(qp,position,hy)end;local i;local qs,qt=nil,nil;local qu="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(bW," ")qs=bW;if i~=nil then qs=string.sub(bW,0,i-1)qt=string.sub(bW,i+1)end;if qs=="/help"or qs=="/commands"then for lo in string.gmatch(qu,"([^\n]+)")do system.print(lo)end;return elseif qs=="/setname"then if qt==nil or qt==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aQ.UpdatePosition(qt)else a2="Select a saved target to rename first"end elseif shield_1 and qs=="/resist"then if qt==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs=B..', '..B..', '..B..', '..B;local qv,qw,qx,qy=o(qt,cs)if qy==nil or qv+qw+qx+qy>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(qv,qw,qx,qy)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif qs=="/addlocation"or string.find(bW,"::pos")~=nil then local hy=false;local qp="0-Temp"if qt==nil or qt==""then qt=qs;hy=true end;i=string.find(qt,"::")if not hy then qp=string.sub(qt,1,i-2)end;local e8=string.sub(qt,i)qo(qp,e8,hy)elseif qs=="/agg"then if qt==nil or qt==""then a2="Usage: /agg targetheight"return end;qt=z(qt)if qt<1000 then qt=1000 end;AntigravTargetAltitude=qt;a2="AGG Target Height set to "..qt elseif qs=="/G"then if qt==nil or qt==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if qt=="dump"then for cd,ce in pairs(bM())do if type(_G[ce])=="boolean"then if _G[ce]==true then system.print(ce.." true")else system.print(ce.." false")end elseif _G[ce]==nil then system.print(ce.." nil")else system.print(ce.." ".._G[ce])end end;return end;i=string.find(qt," ")local qz=string.sub(qt,0,i-1)local qA=string.sub(qt,i+1)for cd,ce in pairs(bM())do if ce==qz then a2="Variable "..qz.." changed to "..qA;local qB=type(_G[ce])if qB=="number"then qA=z(qA)if ce=="AtmoSpeedLimit"then aZ=qA end elseif qB=="boolean"then if string.lower(qA)=="true"then qA=true else qA=false end end;_G[ce]=qA;return end end;a2="No such global variable: "..qz elseif qs=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aQ.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif qs=="/copydatabank"then if dbHud_2 then c9(true)else a2="Spare Databank required to copy databank"end elseif qs=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aR.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(cH)if radar_1 and not aq and not bn then unit.setTimer("contact",0.1)end end;function script.onLeave(cH)if radar_1 and CollisionSystem then if#bq>650 then cH=tostring(cH)bq[cH]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
