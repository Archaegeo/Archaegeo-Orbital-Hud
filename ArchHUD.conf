name: ArchHud - Archaegeo v0.017 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
  transponder:
    class: TransponderUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.017;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=5000;T=1.3;U=2000;V=1175;W=66000;X=1000;Y=50;Z=0;_=100000;a0=-1.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=1;ab={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},AutopilotSpaceDistance={set=function(M)S=M end,get=function()return S end},TargetOrbitRadius={set=function(M)T=M end,get=function()return T end},LowOrbitHeight={set=function(M)U=M end,get=function()return U end},AtmoSpeedLimit={set=function(M)V=M end,get=function()return V end},SpaceSpeedLimit={set=function(M)W=M end,get=function()return W end},AutoTakeoffAltitude={set=function(M)X=M end,get=function()return X end},TargetHoverHeight={set=function(M)Y=M end,get=function()return Y end},LandingGearGroundHeight={set=function(M)Z=M end,get=function()return Z end},ReEntryHeight={set=function(M)_=M end,get=function()return _ end},MaxGameVelocity={set=function(M)a0=M end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(M)a1=M end,get=function()return a1 end},warmup={set=function(M)a2=M end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingSpace={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingRocket={set=function(M)a5=M end,get=function()return a5 end},ContainerOptimization={set=function(M)a6=M end,get=function()return a6 end},FuelTankOptimization={set=function(M)a7=M end,get=function()return a7 end},AutoShieldPercent={set=function(M)a8=M end,get=function()return a8 end},EmergencyWarp={set=function(M)a9=M end,get=function()return a9 end},DockingMode={set=function(M)aa=M end,get=function()return aa end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=1.0;aV="none"aW="none"aX="none"aY=0.05;aZ=0.0;a_={speedChangeLarge={set=function(M)aE=M end,get=function()return aE end},speedChangeSmall={set=function(M)aF=M end,get=function()return aF end},MouseXSensitivity={set=function(M)aG=M end,get=function()return aG end},MouseYSensitivity={set=function(M)aH=M end,get=function()return aH end},autoRollFactor={set=function(M)aI=M end,get=function()return aI end},rollSpeedFactor={set=function(M)aJ=M end,get=function()return aJ end},autoRollRollThreshold={set=function(M)aK=M end,get=function()return aK end},minRollVelocity={set=function(M)aL=M end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(M)aM=M end,get=function()return aM end},torqueFactor={set=function(M)aN=M end,get=function()return aN end},pitchSpeedFactor={set=function(M)aO=M end,get=function()return aO end},yawSpeedFactor={set=function(M)aP=M end,get=function()return aP end},brakeSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeFlatFactor={set=function(M)aR=M end,get=function()return aR end},DampingMultiplier={set=function(M)aS=M end,get=function()return aS end},hudTickRate={set=function(M)aT=M end,get=function()return aT end},ExtraEscapeThrust={set=function(M)aU=M end,get=function()return aU end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end},allowedHorizontalDrift={set=function(M)aY=M end,get=function()return aY end},FastOrbit={set=function(M)aZ=M end,get=function()return aZ end}}b0=k;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=false;bc=1000;bd=false;be=false;bf=false;bg=false;bh=0;bi="Aligning"bj=0;bk=1;bl="None"bm=nil;bn=0;bo=nil;bp=0.0;bq=0;br={}bs=false;bt=0;bu=0;bv=nil;bw=0;bx=1000;by=0;bz=false;bA=0;bB=false;bC="All"bD=true;bE="Off"bF=0.000;bG={}bH={}bI={}bJ={VertTakeOff={set=function(M)bb=M end,get=function()return bb end},VertTakeOffEngine={set=function(M)b1=M end,get=function()return b1 end},SpaceTarget={set=function(M)bz=M end,get=function()return bz end},BrakeToggleStatus={set=function(M)b0=M end,get=function()return b0 end},BrakeIsOn={set=function(M)b2=M end,get=function()return b2 end},RetrogradeIsOn={set=function(M)b3=M end,get=function()return b3 end},ProgradeIsOn={set=function(M)b4=M end,get=function()return b4 end},Autopilot={set=function(M)b5=M end,get=function()return b5 end},TurnBurn={set=function(M)b6=M end,get=function()return b6 end},AltitudeHold={set=function(M)b7=M end,get=function()return b7 end},BrakeLanding={set=function(M)b8=M end,get=function()return b8 end},Reentry={set=function(M)ba=M end,get=function()return ba end},AutoTakeoff={set=function(M)b9=M end,get=function()return b9 end},HoldAltitude={set=function(M)bc=M end,get=function()return bc end},AutopilotAccelerating={set=function(M)bd=M end,get=function()return bd end},AutopilotBraking={set=function(M)bf=M end,get=function()return bf end},AutopilotCruising={set=function(M)bg=M end,get=function()return bg end},AutopilotRealigned={set=function(M)be=M end,get=function()return be end},AutopilotEndSpeed={set=function(M)bh=M end,get=function()return bh end},AutopilotStatus={set=function(M)bi=M end,get=function()return bi end},AutopilotPlanetGravity={set=function(M)bj=M end,get=function()return bj end},PrevViewLock={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetName={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetCoords={set=function(M)bm=M end,get=function()return bm end},AutopilotTargetIndex={set=function(M)bn=M end,get=function()return bn end},TotalDistanceTravelled={set=function(M)bp=M end,get=function()return bp end},TotalFlightTime={set=function(M)bq=M end,get=function()return bq end},SavedLocations={set=function(M)br=M end,get=function()return br end},VectorToTarget={set=function(M)bs=M end,get=function()return bs end},LocationIndex={set=function(M)bt=M end,get=function()return bt end},LastMaxBrake={set=function(M)bu=M end,get=function()return bu end},LockPitch={set=function(M)bv=M end,get=function()return bv end},LastMaxBrakeInAtmo={set=function(M)bw=M end,get=function()return bw end},AntigravTargetAltitude={set=function(M)bx=M end,get=function()return bx end},LastStartTime={set=function(M)by=M end,get=function()return by end},iphCondition={set=function(M)bC=M end,get=function()return bC end},stablized={set=function(M)bD=M end,get=function()return bD end},UseExtra={set=function(M)bE=M end,get=function()return bE end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bG=M end,get=function()return bG end},apRoute={set=function(M)bH=M end,get=function()return bH end},ecuThrottle={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=q;cA=false;cB=V;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2={}d3={}d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()dg=nil;dh=false;if shield then di=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dj(dk)a.print(bQ..": "..dk)end;local function dl(d,b,c,a,dm,dn,dp,dq,dr)local function ds(dt)return type(dt)=='number'end;local function du(dt)return type(dp(dt))=='number'end;local function dv(dw)return type(dw)=='table'end;local function dx(a)return type(a)=='string'end;local function dy(dz)return dv(dz)and ds(dz.x and dz.y and dz.z)end;local function dA(dB)return dv(dB)and ds(dB.latitude and dB.longitude and dB.altitude and dB.id and dB.systemId)end;local dC=math.pi/180;local dD=180/math.pi;local dE=1e-10;local dF=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dG='::pos{'..dF..','..dF..','..dF..','..dF..','..dF..'}'local utils=utils;local vec3=vec3;local function dH(dt)local dI=string.gsub(string.reverse(dm('%.4f',dt)),'^0*%.?','')return dI==''and'0'or string.reverse(dI)end;local function dJ(dK)if dy(dK)then return dm('{x=%.3f,y=%.3f,z=%.3f}',dK.x,dK.y,dK.z)end;if dv(dK)and not getmetatable(dK)then local dL={}local dM=next(dK)if type(dM)=='nil'or dM==1 then dL=dK else for dN,dz in pairs(dK)do local dO=dJ(dz)if type(dN)=='number'then table.insert(dL,dm('[%s]=%s',dN,dO))else table.insert(dL,dm('%s=%s',dN,dO))end end end;return dm('{%s}',table.concat(dL,','))end;if dx(dK)then return dm("'%s'",dK:gsub("'",[[\']]))end;return tostring(dK)end;local dP={}dP.__index=dP;dP.__tostring=function(dK,dQ)local dR={}for dN in pairs(dK)do table.insert(dR,dN)end;table.sort(dR)local dL={}for dS,dN in ipairs(dR)do local dO=dJ(dK[dN])if type(dN)=='number'then table.insert(dL,dm('[%s]=%s',dN,dO))else table.insert(dL,dm('%s=%s',dN,dO))end end;if dQ then return dm('%s%s',dQ,table.concat(dL,',\n'..dQ))end;return dm('{%s}',table.concat(dL,','))end;dP.__eq=function(dT,dU)return dT.systemId==dU.systemId and dT.id==dU.id and dr(dT.radius,dU.radius)and dr(dT.center.x,dU.center.x)and dr(dT.center.y,dU.center.y)and dr(dT.center.z,dU.center.z)and dr(dT.GM,dU.GM)end;local function dV(dW,dX,dY,dZ,d_)assert(du(dW),'Argument 1 (systemId) must be a number:'..type(dW))assert(du(dX),'Argument 2 (id) must be a number:'..type(dX))assert(du(dY),'Argument 3 (radius) must be a number:'..type(dY))assert(dv(dZ),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dZ))assert(du(d_),'Argument 5 (GM) must be a number:'..type(d_))return setmetatable({systemId=dp(dW),id=dp(dX),radius=dp(dY),center=vec3(dZ),GM=dp(d_)},dP)end;local e0={}e0.__index=e0;e0.__tostring=function(dj)return dm('::pos{%d,%d,%s,%s,%s}',dj.systemId,dj.id,dH(dj.latitude*dD),dH(dj.longitude*dD),dH(dj.altitude))end;e0.__eq=function(dT,dU)return dT.id==dU.id and dT.systemId==dU.systemId and dr(dT.latitude,dU.latitude)and dr(dT.altitude,dU.altitude)and(dr(dT.longitude,dU.longitude)or dr(dT.latitude,math.pi/2)or dr(dT.latitude,-math.pi/2))end;local function e1(e2,dX,e3,e4,e5)local dW=e2;if dx(e2)and not e4 and not e5 and not dX and not e3 then dW,dX,e3,e4,e5=e6(e2,dG)assert(dW,'Argument 1 (position string) is malformed.')else assert(du(dW),'Argument 1 (systemId) must be a number:'..type(dW))assert(du(dX),'Argument 2 (id) must be a number:'..type(dX))assert(du(e3),'Argument 3 (latitude) must be in degrees:'..type(e3))assert(du(e4),'Argument 4 (longitude) must be in degrees:'..type(e4))assert(du(e5),'Argument 5 (altitude) must be in meters:'..type(e5))end;dW=dp(dW)dX=dp(dX)e3=dp(e3)e4=dp(e4)e5=dp(e5)if dX==0 then return setmetatable({latitude=e3,longitude=e4,altitude=e5,id=dX,systemId=dW},e0)end;return setmetatable({latitude=dC*dn(e3,-90,90),longitude=dC*(e4%360),altitude=e5,id=dX,systemId=dW},e0)end;local e7={}e7.__index=e7;e7.__tostring=function(dK,dQ)local e8=dQ and dQ..'  'local e9={}local dR={}for dN in pairs(dK)do table.insert(dR,dN)end;table.sort(dR)for dS,ea in ipairs(dR)do eb=dK[ea]local ec=dP.__tostring(eb,e8)if dQ then table.insert(e9,dm('[%s]={\n%s\n%s}',ea,ec,dQ))else table.insert(e9,dm('  [%s]=%s',ea,ec))end end;if dQ then return dm('\n%s%s%s',dQ,table.concat(e9,',\n'..dQ),dQ)end;return dm('{\n%s\n}',table.concat(e9,',\n'))end;local function ed(ee)local e={}local pid;for dS,dz in pairs(ee)do local dX=dz.planetarySystemId;if type(dX)~='number'then error('Invalid planetary s ID: '..tostring(dX))elseif pid and dX~=pid then error('Mistringmatch planetary s IDs: '..dX..' and '..pid)end;local ef=dz.bodyId;if type(ef)~='number'then error('Invalid body ID: '..tostring(ef))elseif e[ef]then error('Duplicate body ID: '..tostring(ef))end;setmetatable(dz.center,getmetatable(vec3.unit_x))e[ef]=setmetatable(dz,dP)pid=dX end;return setmetatable(e,e7)end;eg={}local function eh(ee)return setmetatable({galaxyAtlas=ee or{}},eg)end;eg.__index=function(dw,M)if type(M)=='number'then local a=dw.galaxyAtlas[M]return ed(a)end;return rawget(eg,M)end;eg.__pairs=function(dK)return function(dw,dN)local ei,ej=next(dw,dN)return ei,ej and ed(ej)end,dK.galaxyAtlas,nil end;eg.__tostring=function(dK)local ek={}for dS,el in pairs(dK or{})do local em=el:getPlanetarySystemId()local en=e7.__tostring(el,'    ')table.insert(ek,dm('  [%s]={%s\n  }',em,en))end;return dm('{\n%s\n}\n',table.concat(ek,',\n'))end;eg.BodyParameters=dV;eg.MapPosition=e1;eg.PlanetarySystem=ed;function eg.createBodyParameters(dW,dX,eo,ep,eq,er,es)assert(du(dW),'Argument 1 (systemId) must be a number:'..type(dW))assert(du(dX),'Argument 2 (id) must be a number:'..type(dX))assert(du(eo),'Argument 3 (surfaceArea) must be a number:'..type(eo))assert(dv(ep),'Argument 4 (aPosition) must be an array or vec3:'..type(ep))assert(dv(eq),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eq))assert(du(er),'Argument 6 (altitude) must be in meters:'..type(er))assert(du(es),'Argument 7 (gravityAtPosition) must be number:'..type(es))local dY=dq(eo/4/math.pi)local cb=dY+er;local et=vec3(ep)+cb*vec3(eq)local d_=es*cb*cb;return dV(dW,dX,dY,et,d_)end;eg.isMapPosition=dA;function eg:getPlanetarySystem(e2)if M==nil then M=0 end;if ej==nil then ej=0 end;local dW=e2;if dA(e2)then dW=e2.systemId end;if type(dW)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(ej)~=e7 then a=ed(a)end;return a end end end;function e7:sizeCalculator(eu)return 1.05*eu.radius end;function e7:castIntersections(ev,ew,ex,ey,ez,eA)local eB={}if ez then for dS,eu in pairs(ez)do table.insert(eB,eu)end else eB=d4 end;if not eA then table.sort(eB,function(eC,eD)local eE=eC.center;local eF=eD.center;return(eE.x-ev.x)^2+(eE.y-ev.y)^2+(eE.z-ev.z)^2<(eF.x-ev.x)^2+(eF.y-ev.y)^2+(eF.z-ev.z)^2 end)end;local eG=ew:normalize()for dS,eu in ipairs(eB)do local eH=eu.center-ev;local dY;if ex then dY=ex(eu)else dY=self:sizeCalculator(eu)end;local eI=eH:dot(eG)local eJ=eI^2-(eH:len2()-dY^2)if eJ>=0 then local eK=dq(eJ)local eL=eI+eK;local eM=eI-eK;if eM>0 then return eu,eL,eM elseif eL>0 then return eu,eL,nil end end end;return nil,nil,nil end;function e7:closestBody(eN)assert(type(eN)=='table','Invalid coordinates.')local eO,eu;local eP=vec3(eN)for dS,eQ in pairs(self)do local eR=(eQ.center-eP):len2()if(not eu or eR<eO)and eQ.name~="Space"then eu=eQ;eO=eR end end;return eu end;function e7:convertToBodyIdAndWorldCoordinates(e2)local eS=e2;if dx(e2)then eS=e1(e2)end;if eS.id==0 then return 0,vec3(eS.latitude,eS.longitude,eS.altitude)end;local eQ=self:getBodyParameters(eS)if eQ then return eS.id,eQ:convertToWorldCoordinates(eS)end end;function e7:getBodyParameters(e2)local dX=e2;if dA(e2)then dX=e2.id end;assert(du(dX),'Argument 1 (id) must be a number:'..type(dX))return self[dX]end;function e7:getPlanetarySystemId()local dS,dz=next(self)return dz and dz.systemId end;function dP:convertToMapPosition(dZ)assert(dv(dZ),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dZ))local eT=vec3(dZ)if self.id==0 then return setmetatable({latitude=eT.x,longitude=eT.y,altitude=eT.z,id=0,systemId=self.systemId},e0)end;local eU=eT-self.center;local cb=eU:len()local e5=cb-self.radius;local e3=0;local e4=0;if not dr(cb,0)then local eV=eW(eU.y,eU.x)e4=eV>=0 and eV or 2*math.pi+eV;e3=math.pi/2-math.acos(eU.z/cb)end;return setmetatable({latitude=e3,longitude=e4,altitude=e5,id=self.id,systemId=self.systemId},e0)end;function dP:convertToWorldCoordinates(e2)local eS=dx(e2)and e1(e2)or e2;if eS.id==0 then return vec3(eS.latitude,eS.longitude,eS.altitude)end;assert(dA(eS),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eS.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eS.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eX=math.cos(eS.latitude)return self.center+(self.radius+eS.altitude)*vec3(eX*math.cos(eS.longitude),eX*math.sin(eS.longitude),math.sin(eS.latitude))end;function dP:getAltitude(dZ)return(vec3(dZ)-self.center):len()-self.radius end;function dP:getDistance(dZ)return(vec3(dZ)-self.center):len()end;function dP:getGravity(dZ)local eY=self.center-vec3(dZ)local eZ=eY:len2()return self.GM/eZ*eY/dq(eZ)end;return setmetatable(eg,{__call=function(dS,...)return eh(...)end})end;local function e_(d,b,c,a,dq,f0)local cp={}local f1=100;function cp.computeAccelerationTime(f2,f3,f4)return(f4-f2)/f3 end;function cp.computeDistanceAndTime(f2,f4,f5,f6,f7,f8)f7=f7 or 0;f8=f8 or 0;local f9=f2<f4;local fa=f6/(f9 and f5 or-f5)local fb=-f8/f5;local fc=fa+fb;if f2==f4 then return 0,0 elseif f9 and fc<=0 or not f9 and fc>=0 then return-1,-1 end;local fd,fe=0,0;if fa~=0 and f7>0 then local ff=math.pi/f7/2;local dz=function(dw)return fa*(dw/2-f7*math.sin(ff*dw)/math.pi)+fb*dw+f2 end;local fg=f9 and function(a)return a>=f4 end or function(a)return a<=f4 end;fe=2*f7;if fg(dz(fe))then local fh=0;while math.abs(fe-fh)>0.25 do local dw=(fe+fh)/2;if fg(dz(dw))then fe=dw else fh=dw end end end;local fi=2*fa*f7^2/math.pi^2;fd=fi*(math.cos(ff*fe)-1)+(fa+2*fb)*fe^2/4+f2*fe;if fe<2*f7 then return fd,fe end;f2=dz(fe)end;local eE=fa+fb;local dw=cp.computeAccelerationTime(f2,eE,f4)local fj=f2*dw+eE*dw*dw/2;return fd+fj,fe+dw end;function cp.computeTravelTime(f2,f3,cb)if cb==0 then return 0 end;if f3~=0 then return(math.sqrt(2*f3*cb+f2^2)-f2)/f3 end;assert(f2>0,'Acceleration and initial speed are both zero.')return cb/f2 end;return cp end;local function fk(d,b,c,a,dm,dn,dp,dq,dr)local vec3=vec3;local dl=dl(d,b,c,a,dm,dn,dp,dq,dr)local function dx(a)return type(a)=='string'end;local function dv(dw)return type(dw)=='table'end;fl={}fl.__index=fl;function fl:escapeAndOrbitalSpeed(e5)assert(self.body)local cb=e5+self.body.radius;if not dr(cb,0)then local fm=dq(self.body.GM/cb)return dq(2)*fm,fm end;return nil,nil end;function fl:orbitalParameters(e2,fn)assert(self.body)assert(dv(e2)or dx(e2))assert(dv(fn))local fo=(dx(e2)or dl.isMapPosition(e2))and self.body:convertToWorldCoordinates(e2)or vec3(e2)local dz=vec3(fn)local fp=fo-self.body.center;local fq=dz:len2()local fj=fp:len()local fr=self.body.GM;local fs=((fq-fr/fj)*fp-fp:dot(dz)*dz)/fr;local eE=fr/(2*fr/fj-fq)local ft=fs:len()local eG=fs:normalize()local fu=eE*(1-ft)local fv=eE*(1+ft)local fw=fu*eG+self.body.center;local fx=ft<=1 and-fv*eG+self.body.center or nil;local fy=dq(eE*fr*(1-ft*ft))local fz=fx and 2*math.pi*dq(eE^3/fr)local fA=math.acos(fs:dot(fp)/(ft*fj))if fp:dot(dz)<0 then fA=-(fA-2*math.pi)end;local fB=math.acos((math.cos(fA)+ft)/(1+ft*math.cos(fA)))local fC=fB;if fC<0 then fC=fC+2*math.pi end;local fD=fC-ft*math.sin(fC)local fE=0;local fF=0;local fG=0;if fz~=nil then fE=fD/(2*math.pi/fz)fF=fz-fE;fG=fF+fz/2;if fA-math.pi>0 then fF=fE;fG=fF+fz/2 end;if fG>fz then fG=fG-fz end end;return{periapsis={position=fw,speed=fy/fu,circularOrbitSpeed=dq(fr/fu),altitude=fu-self.body.radius},apoapsis=fx and{position=fx,speed=fy/fv,circularOrbitSpeed=dq(fr/fv),altitude=fv-self.body.radius},currentVelocity=dz,currentPosition=fo,eccentricity=ft,period=fz,eccentricAnomaly=fB,meanAnomaly=fD,timeToPeriapsis=fF,timeToApoapsis=fG,trueAnomaly=fA}end;local function fH(fI)local eQ=dl.BodyParameters(fI.systemId,fI.id,fI.radius,fI.center,fI.GM)return setmetatable({body=eQ},fl)end;return setmetatable(fl,{__call=function(dS,...)return fH(...)end})end;local function fJ(d,b,c,a,dbHud_1,e,fK,fL,bN,dp,dq,fM,fN,dk)local function fO(fP)local dj=fQ:closestBody(fP)if(fP-dj.center):len()>dj.radius+dj.noAtmosphericDensityAltitude then dj=e[0][0]end;return dj end;local function fR()local function fS(fT,fU)return fT.name<fU.name end;cU={}for dN,dz in pairs(e[0])do cU[#cU+1]={name=dz.name,index=dN}end;table.sort(cU,fS)end;local function fV(fW,fX)if not fX then fX=fY.name end;for dN,dz in pairs(fW)do if dz.name and dz.name==fX then return dN end end;return-1 end;local function fZ()d1=bn;if bn==0 then bl="None"c8=nil;fY=nil;return true end;local f_=cU[bn].index;local g0=e[0][f_]if g0.center then bl=g0.name;c8=co[0][f_]if fY~=nil then if ch==0 then if fK(g1,g2)~=1 then fL(g1,g2)end;if fK(g3,g4)~=1 then fL(g3,g4)end;if fK(g5,g6)~=1 then fL(g5,g6)end;if fK(g7,g8)~=1 then fL(g7,g8)end;if fK(g9,ga)~=1 then fL(g9,ga)end end;if fK(gb,gc)~=1 then fL(gb,gc)end;if fK(gd,ge)~=1 then fL(gd,ge)end;if fK(gf,gg)~=1 then fL(gf,gg)end end;fY=nil else fY=g0;for dS,dz in pairs(co[0])do if dz.name==fY.planetname then c8=dz;bl=fY.name;break end end;if fK(gb,gc)~=1 then fL(gb,gc)end;if fK(gd,ge)~=1 then fL(gd,ge)end end;if fY==nil then bm=vec3(c8.center)else bm=fY.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gh=bN(c8.radius*(T-1)+c8.noAtmosphericDensityAltitude)else gh=bN(U+c8.surfaceMaxAltitude)end else gh=S end;if fY~=nil and fY.planetname=="Space"then bh=0 else dS,bh=cq(c8):escapeAndOrbitalSpeed(gh)end;bj=0;bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"return true end;local function gi(gj)if not dh and not b5 and not bs and not cd and not bB and not ba and not ce then if gj==nil then bn=bn+1;if bn>#cU then bn=0 end else bn=bn-1;if bn<0 then bn=#cU end end;if bn==0 then fZ()else local f_=cU[bn].index;local g0=e[0][f_]if g0 and(g0~=nil and g0.name=="Space"or bC=="Custom Only"and g0.center or bC=="No Moons-Asteroids"and(string.find(g0.name,"Moon")~=nil or string.find(g0.name,"Asteroid")~=nil))then if gj==nil then gi()else gi(1)end else fZ()end end else dk("Disengage autopilot before changing Interplanetary Helper")fM("iph","AP")end end;local function gk()local function gl(gm)local gn;if gm then gn=d9 else gn=br end;local go=-1;go=fV(e[0])if go>-1 then table.remove(e[0],go)end;go=-1;go=fV(gn)if go~=-1 then dk(fY.name.." saved location cleared")table.remove(gn,go)end;gi()fR()return gn end;if string.sub(bl,1,1)=="*"then d9=gl(true)else br=gl(false)end end;local function gp(gq,fP,gr,gs)local function gt(gm)if gm then gn=d9 else gn=br end;if dbHud_1 or gr or gm then local dj=fO(fP)local gu={position=fP,name=gq,planetname=dj.name,gravity=b.getGravityIntensity(),safe=gs}if not gr then gn[#gn+1]=gu else for dN,dz in pairs(e[0])do if dz.name and gq==dz.name then table.remove(e[0],dN)end end end;table.insert(e[0],gu)fR()fZ()dk("Location saved as "..gq.."("..dj.name..")")return gn else dk("Databank must be installed to save permanent locations")end end;if string.sub(gq,1,1)=="*"then d9=gt(true)else br=gt(false)end end;local gv={}function gv.UpdateAtlasLocationsList()fR()end;function gv.UpdateAutopilotTarget()fZ()end;function gv.adjustAutopilotTargetIndex(gj)gi(gj)end;function gv.findAtlasIndex(fW,fX)return fV(fW,fX)end;function gv.UpdatePosition(gw,gx,gy)local function gz(gm)local gn;if gm then gn=d9 else gn=br end;local go=fV(gn)if go~=-1 then if gw~=nil then if gm then gw="*"..gw end;gn[go].name=gw;bn=bn-1;gi()elseif gy~=nil then if gy then local gA=ci;if gA<1000 then gA=1000 end;gn[go].agg=fN(gA,0)dk(gn[go].name.." AGG Altitude:"..gn[go].agg.." saved ("..gn[go].planetname..")")return elseif gy==false then gn[go].agg=nil;dk(gn[go].name.." AGG Altitude cleared ("..gn[go].planetname..")")return end else local gB=gn[go]if gx then gB.heading=cI:cross(cM)*5000;dk(gn[go].name.." heading saved ("..gn[go].planetname..")")return elseif gx==false then gB.heading=nil;dk(gn[go].name.." heading cleared ("..gn[go].planetname..")")return end;gB.gravity=b.getGravityIntensity()gB.position=cO;gB.safe=true end;dk(gn[go].name.." position updated ("..gn[go].planetname..")")else dk("Name Not Found")end end;if string.sub(bl,1,1)=="*"then gz(true)else gz(false)end end;function gv.AddNewLocation(gq,fP,gr,gs)gp(gq,fP,gr,gs)end;function gv.ClearCurrentPosition()gk()end;for dN,dz in pairs(da)do table.insert(e[0],dz)end;if gC then for dN,dz in pairs(gC)do gv[dN]=dz end end;fR()if bn>#cU then bn=0 end;gv.UpdateAutopilotTarget()return gv end;local function gD(b,a,c,radar_1,radar_2,warpdrive,f0,gE,dq,gF,dp,gG,fM,dk)local gH={}local gI={}local gJ={XS=13,S=27,M=55,L=110,XL=221}local gK={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gL={}local gM=0;local gN;local gO;local gP=0;local gQ;local gR={gQ}local gS="Atmo"local gT;local gU;local gV=0;local gW={}local gX;local gY=0;local gZ=table.insert;local g_=-4;local h0={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h1,h2;local h3,h4;local h5;local h6;local h7;local h8;local h9;local ha;local hb;local function hc()if hd~=nil and gV==0 then gE(hd)a.destroyWidget(h1)a.destroyData(h3)h1,h3,hd=nil,nil,nil;if gU~=nil then gE(gU)a.destroyWidget(h2)a.destroyData(h4)gU,h2,h4=nil,nil,nil end else if gV==1 then gU=a.createWidgetPanel("PeriWinkle")h2=a.createWidget(gU,'periscope')h4=gQ.getWidgetDataId()a.addDataToWidget(h4,h2)end;if hd==nil and gM>0 then hd=a.createWidgetPanel(gS)h1=a.createWidget(hd,'radar')h3=gQ.getWidgetDataId()a.addDataToWidget(h3,h1)end;gV=0 end end;local function he()local function hf(hg,hh,hi,hj,hk,hl,hm,hn)hh,hj,hl,hn=vec3(hh),vec3(hj),vec3(hl),vec3(hn)local ho,hp,hq=hg*hg,hi*hi,hk*hk;local fq=hj-hh;local hr=fq:normalize()local hs=fq:len()local ht=hl-hh;local hu=(ht-ht:project_on(hr)):normalize()local hv,hw=ht:dot(hr),ht:dot(hu)local hx=hv*hv+hw*hw;local hy=hr:cross(hu)local hz=(ho-hp+hs*hs)/(2*hs)local hA=(ho-hq+hx-2*hv*hz)/(2*hw)local dB=ho-hz^2-hA^2;local hB=dq(dB)local hC=hh+hr*hz+hu*hA+hy*hB;local hD=hh+hr*hz+hu*hA-hy*hB;if f0((hn-hC):len()-hm)<f0((hn-hD):len()-hm)then return hC else return hD end end;local function hE(hF,fj,hG)local hH=hF.pts;local go=#hH;local hI=hF.ref;if go>3 then local hJ,hK,hL,hM=hH[go],hH[go-1],hH[go-2],hH[go-3]hF.ref=hG;local fo=hf(hJ[1],hJ[2],hK[1],hK[2],hL[1],hL[2],hM[1],hM[2])local hz,hA,hB=fo.x,fo.y,fo.z;if hz==hz and hA==hA and hB==hB then hz=hz+hI[1]hA=hA+hI[2]hB=hB+hI[3]local hN=vec3(hz,hA,hB)hF.center=hN;if hF.lastPos then if(hF.lastPos-hN):len()<2 then local hO=(hN-vec3(hG)):len()if f0(hO-fj)<10 then hF.skipCalc=true end end end;hF.lastPos=hN end;hF.pts={}else local hP={hG[1]-hI[1],hG[2]-hI[2],hG[3]-hI[3]}hH[go+1]={fj,hP}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gQ then if#gX>0 then local hQ,hR=0,0;local hS=cL*10;local cY=cY;gP,gO=0,0;gI={}for dS,dz in pairs(gX)do local cb=h9(dz)if cb>0.0 then if h5(dz)==1 then gZ(gI,dz)end;if not cV and warpdrive and cb<a9 and warpdrive.getStatus()==15 then dk("INITIATING WARP")c4=7;warpdrive.initiate()end;local hT=F and h7(dz)==1;if E or hT then local hU=ha(dz)local hV=gJ[hU]local hW=h6(dz)if hT or cb<hS and(hV>27 or hW==4 or hW==6)then gP=gP+1;local hG={cO["x"],cO["y"],cO["z"]}local hF=gW[dz]if hF==nil then hV=hV+gG;gW[dz]={pts={},ref=hG,name=h8(dz),i=0,radius=hV,skipCalc=false}hF=gW[dz]end;if not hF.skipCalc then if hT or hW==4 or hW==6 then hF.center=vec3(hb(dz))hF.skipCalc=true else hE(hF,cb,hG)hR=hR+1 end;if hT and not hF.abandoned then local bQ=a.getArkTime()if gY+5<bQ then gY=bQ;fM("abRdr","RD")end;a.print("Abandoned Construct: "..hF.name.." ("..hU.." "..gK[hW]..") at ::pos{0,0,"..hF.center.x..","..hF.center.y..","..hF.center.z.."}")dk("Abandoned Radar Contact ("..hU.." "..gK[hW]..") detected")hF.abandoned=true end else gZ(gL,hF)end end;hQ=hQ+1;if hQ>300 or hR>30 then coroutine.yield()hQ,hR=0,0 end end end end;gO=#gL;if gO>0 and(cL>20 or b8)then local eu,hX,hY,hZ;local h_=0;local i0=co:getPlanetarySystem(0)hZ=cK:normalize()while h_<gO do coroutine.yield()local i1={table.unpack(gL,h_,math.min(h_+75,gO))}eu,hX,hY=i0:castIntersections(cO,hZ,nil,nil,i1,true)if eu and hY then c_={eu,hX,hY}break end;h_=h_+75 end;if not eu then c_=nil end else c_=nil end;gL={}gN=gQ.getTargetId()end end end;local function i2()if gQ then gS="Atmo"if string.find(gQ.getName(),"Space")then gS="Space"end end end;function gH.pickType()i2()end;function gH.assignRadar()if radar_2 and g_~=1 then if g_==-1 then if gQ==radar_2 then gQ=radar_1 else gQ=radar_2 end end;gR={gQ}h5=gQ.hasMatchingTransponder;h6=gQ.getConstructKind;h7=gQ.isConstructAbandoned;h8=gQ.getConstructName;h9=gQ.getConstructDistance;ha=gQ.getConstructCoreSize;hb=gQ.getConstructWorldPos;gX=gQ.getConstructIds()i2()else gX=gQ.getConstructIds()end;g_=gQ.getOperationalState()end;function gH.UpdateRadar()local i3=coroutine.status(gT)if i3=="suspended"then local dO,i4=coroutine.resume(gT)if i4 then a.print("ERROR UPDATE RADAR: "..i4)end elseif i3=="dead"then gT=coroutine.create(he)local dO,i4=coroutine.resume(gT)end end;function gH.GetRadarHud(i5,i6,ax,ay)local i7,dk;local dF=gO or 0;gM=#gX;if gM>0 then if E then dk=dF.."/"..gP.." Known/InRange : "..gM.." Total"else dk="Radar Contacts: "..gM end;i7=gF(ax,ay,dk,"pbright txtbig txtmid")if#gI>0 then i7=i7 ..gF(i5,i6,"Friendlies In Range","pbright txtbig txtmid")for dN,dz in pairs(gI)do i6=i6+20;i7=i7 ..gF(i5,i6,gQ.getConstructName(dz),"pdim txtmid")end end;local i8=#gQ.getIdentifiedConstructIds()if gU==nil and i8>0 then gV=1;cu.ToggleRadarPanel()end;if gU~=nil and i8==0 then cu.ToggleRadarPanel()end;if hd==nil then if w then cu.ToggleRadarPanel()end end else if g_~=1 then i7=gF(ax,ay,gS.." Radar: "..h0[g_],"pbright txtbig txtmid")else i7=gF(ax,ay,"Radar: No "..gS.." Contacts","pbright txtbig txtmid")end;if hd~=nil then gV=0;cu.ToggleRadarPanel()end end;return i7 end;function gH.GetClosestName(gq)if gQ then local i9=gQ.getConstructName(gQ.getConstructIds()[1])if i9 then gq=gq.." "..i9 end end;return gq end;function gH.ToggleRadarPanel()hc()end;function gH.ContactTick()if not ia then ia=0 end;if bQ>ia+10 then dk("Radar Contact")fM("rdrCon","RC")ia=bQ end;c.stopTimer("contact")end;function gH.onEnter(dX)if gQ and not cg and not cV then c.setTimer("contact",0.1)end end;function gH.onLeave(dX)if gQ and E then if#gW>650 then dX=tostring(dX)gW[dX]=nil end end end;local function ib()gQ=nil;if radar_2 and radar_2.getOperationalState()==1 then gQ=radar_2 else gQ=radar_1 end;g_=gQ.getOperationalState()h5=gQ.hasMatchingTransponder;h6=gQ.getConstructKind;h7=gQ.isConstructAbandoned;h8=gQ.getConstructName;h9=gQ.getConstructDistance;ha=gQ.getConstructCoreSize;hb=gQ.getConstructWorldPos;gR={gQ}gX=gQ.getConstructIds()i2()gT=coroutine.create(he)if ic then for dN,dz in pairs(ic)do gH[dN]=dz end end end;ib()return gH end;local function id(shield,e6,bN,dk)local ie={}local ig=shield.getResistancesCooldown()local function ih()local ii=shield.isActive()if G then if not cV and ii==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and ii==1 then shield.toggle()end end end;local function ij()local ik=shield.getStressRatioRaw()local il=0.5999;if ik[1]==0.0 and ik[2]==0.0 and ik[3]==0.0 and ik[4]==0.0 then return end;local im=shield.setResistances(il*ik[1],il*ik[2],il*ik[3],il*ik[4])if im==1 then dk("Shield Resistances updated")else dk("Value Exceeded. Failed to update Shield Resistances")end end;function ie.shieldTick()di=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ih()ig=shield.getResistancesCooldown()if ig==0 and di<a8 then ij()end end;function ie.setResist(io)if not shield then dk("No shield found")return elseif io==nil or ig>0 then dk("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dF=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dG=dF..', '..dF..', '..dF..', '..dF;local ip,iq,ir,is=e6(io,dG)if is==nil or ip+iq+ir+is>0.6 then dk("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(ip,iq,ir,is)==1 then dk("Shield Resistances set")else dk("Resistance setting failed.")end end;function ie.ventShield()local it=shield.getVentingCooldown()if it>0 then dk("Cannot vent again for "..it.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()dk("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else dk("Shields already at max hitpoints")end end;if iu then for dN,dz in pairs(iu)do ie[dN]=dz end end;return ie end;local function iv(d,b,c,a,e,antigrav,hover,shield,warpdrive,iw,f0,bN,dm,ix,bO,iy,iz,eW,bM,dn,iA,fL,fK,gE,iB,dq,fN,gF,fM,iC,iD,iE,iF,iG,iH,dk)local bP=DUConstruct;local iI=9.80665;local iJ={}local iK={}local iL={}local iM={}local iN=nil;local iO=nil;local iP=nil;local iQ=false;local iR="none"local iS=""local iT=55;local iU=0;local iV=0;local iW=nil;local iX=af;local iY=ag;local iZ=ah;local i_=[[rgb(]]..bN(iX+0.5)..","..bN(iY+0.5)..","..bN(iZ+0.5)..[[)]]local j0=[[rgb(]]..bN(iX*0.9+0.5)..","..bN(iY*0.9+0.5)..","..bN(iZ*0.9+0.5)..[[)]]local j1=0;local j2=0;local j3=""local j4=bM()local j5=false;local j6=false;local gQ=false;local function j7(dz)if ac==1920 then return dz else return fN(ac*dz/1920,0)end end;local function j8(dz)if ad==1080 then return dz else return fN(ad*dz/1080,0)end end;local function j9()return iB()==0 and g~="keyboard"and iz()==0 end;local function ja()local jb="TRAVEL"if not cR then jb="CRUISE"end;if b5 then jb="AUTOPILOT"end;return jb end;local i7=""local jc=""local jd=""local je=1;local jf=2;local jg=3;local jh=4;local ji=5;local jj=6;local jk=7;local jl=""local jm=0;local jn=90.0*aT;local jo={}local jp={}local jq={}local jr={}local js={}local jt={}local ju={}ju["atmofueltank"],ju["spacefueltank"],ju["rocketfueltank"]=0,0,0;local jv=0;local function jw(hz,jx,jy,jz,jA,jB)local jC=jv;local jD=jv+5;if not B then jD=jD+5 end;if iz()==1 and not m then jC=jC-50;jD=jD-50 end;if jy=="ATMO"then jl="atmofueltank"elseif jy=="SPACE"then jl="spacefueltank"else jl="rocketfueltank"end;jm=_G[jl.."_size"]if#jz>0 then for M=1,#jz do local gq=jz[M][jf]local jE=jz[M][jk]for jF=1,jm do if jz[M][jf]==ix(c[jl.."_"..jF].getWidgetData()).name then jE=jF;break end end;local jG=bM()if jA[M]==nil or jB[M]==nil or jG-jz[M][jj]>jn then local jH;local jI=0;jI=iy(jz[M][je])-jz[M][jh]jH=jz[M][ji]local jJ=jH>jI or false;if jJ then ju[jl]=ju[jl]+jH-jI end;if jE~=0 then local jK=ix(c[jl.."_"..jE].getWidgetData())jB[M]=jK.percentage;jA[M]=jK.timeLeft;if jA[M]=="n/a"then jA[M]=0 end else jB[M]=bN(0.5+jI*100/jz[M][jg])if jJ then jA[M]=bN(0.5+jI/((jH-jI)/(jG-jz[M][jj])))else jA[M]=0 end end;jz[M][jj]=jG;jz[M][ji]=jI end;if gq==jx then gq=dm("%s %d",jy,M)end;if jE==0 then gq=gq.." *"end;local jL;jL=iF(jA[M])if jA[M]==0 or jL==">1y"then jL=""end;if jB[M]~=nil then local jM=bN(jB[M]*2.55)local jN=dm("rgb(%d,%d,%d)",255-jM,jM,0)local jO=""if jL~=""and jA[M]<120 or jB[M]<5 then jO="red "end;local jP=dm("rgb(%d,%d,%d)",dn(bN((255-jM)/2.55),50,100),dn(bN(jM/2.55),0,50),50)local jQ="rgb(196,0,255)"if jy=="ATMO"then jQ="rgb(0,188,255)"elseif jy=="SPACE"then jQ="rgb(239,255,0)"end;local jR=false;if jS~=jQ then jR=true end;jS=jQ;if B then if jR then jC=jC-5;jD=jD-5 end;jc=jc..dm([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jP,jQ,hz,jD,jN,bN(jB[M]*1.7+0.5)-2,hz+1,jD+1,hz+5,jD+14,gq,jB[M],jL)jC=jC-22;jD=jD-22 else jc=jc..gF(hz,jC,gq,jO.."pdim txtfuel")jc=jc..gF(hz,jD,dm("%d%% %s",jB[M],jL),"pdim txtfuel","fill:"..jN)jC=jC+30;jD=jD+30 end end end end;jv=jC end;local function jT(jU,e5)if ap==0 and aq==0 then return end;if e5<200000 and not cg or e5 and cg then local jV=0;if f0(cN)>1 then jV=45*math.log(f0(cN),10)if cN<0 then jV=-jV end end;jU[#jU+1]=dm([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bN(cN),bN(jV))end;return jU end;local function jW(jX)local gj=-cM;jX=jX-jX:project_on(gj)local jY=vec3(0,0,1)jY=jY-jY:project_on(gj)local jZ=jY:cross(gj)local jV=jY:angle_between(jX)*constants.rad2deg;if jX:dot(jZ)<0 then jV=360-jV end;return jV end;local function j_(jU,al,am,k0,k1,cY)if ae==0 then return end;local k2=ae;local k3=20;local k4=bN(k0)if cY then for M=-45,45,5 do local k5=M;jU[#jU+1]=dm([[<g transform="rotate(%f,%d,%d)">]],k5,al,am)k6=5;if M%15==0 then k6=15 elseif M%10==0 then k6=10 end;jU[#jU+1]=dm([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+k2+k3-k6,al,am+k2+k3)end;jU[#jU+1]=gF(al,am+k2+k3-35,k1,"pdim txt txtmid")jU[#jU+1]=gF(al,am+k2+k3-25,k4 .." deg","pdim txt txtmid")jU[#jU+1]=dm([[<g transform="rotate(%f,%d,%d)">]],-k0,al,am)jU[#jU+1]=dm([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+k2+k3-20,al+5,am+k2+k3-20,al,am+k2+k3-15)jU[#jU+1]="</g>"end;jU[#jU+1]=[[<g style="clip-path: url(#headingClip);">]]local k7=k4;if cY then k7=jW(cH)end;local k8=20;local k9=bN(k7)local ka=0;local kb=am+k2+k3+20;local kc=al;if k1~="YAW"then kb=j8(130)kc=j7(960)end;local kd=[[<path class="txttick line" d="]]local ke=bN(k9-(k8+10)-k9%5+0.5)for M=ke+70,ke,-5 do local hz=kc-(-M*5+k7*5)if M%10==0 then ka=10;local dF=M;if dF==360 then dF=0 elseif dF>360 then dF=dF-360 elseif dF<0 then dF=dF+360 end;jU[#jU+1]=gF(hz,kb+15,dF,"txtmid bright")elseif M%5==0 then ka=5 end;if ka==10 then kd=dm([[%s M %f %f v %d]],kd,hz,kb-5,ka)else kd=dm([[%s M %f %f v %d]],kd,hz,kb-2.5,ka)end end;jU[#jU+1]=kd..[["/>]]jU[#jU+1]=dm([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kc-5,kb-20,kc+5,kb-20,kc,kb-10)if cY then k1="HDG"end;jU[#jU+1]=gF(j7(960),j8(100),k9 .."°","dim txt txtmid size14","")jU[#jU+1]=gF(j7(960),j8(85),k1,"dim txt txtmid size20","")jU[#jU+1]=[[</g>]]end;local function kf(jU,kg,k0,al,am,cY,kh,ki)if ae==0 then return end;local k2=ae;local kj=bN(k2*3/5)if k2>0 then local kk=bN(kg)local k6=0;local kd=dm([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k0,al,am)if not cg then kd=dm([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;jU[#jU+1]=dm([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k2-1,al,am)jU[#jU+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(kk-30-kk%5+0.5),bN(kk+30+kk%5+0.5),5 do if M%10==0 then k6=30 elseif M%5==0 then k6=20 end;local hA=am+-M*5+kg*5;if k6==30 then kd=dm([[%s M %d %f h %d]],kd,al-kj-k6,hA,k6)if cg then jU[#jU+1]=dm([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k0,al,am,al-kj+10,hA+4,M)jU[#jU+1]=dm([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k0,al,am,al+kj-10,hA+4,M)if M==0 or M==180 or M==-180 then jU[#jU+1]=dm([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k0,al,am,al-kj+20,hA,kj*2-40)end else jU[#jU+1]=gF(al-kj+10,hA,M,"pdim txt txtmid")jU[#jU+1]=gF(al+kj-10,hA,M,"pdim txt txtmid")end;kd=dm([[%s M %d %f h %d]],kd,al+kj,hA,k6)else kd=dm([[%s M %d %f h %d]],kd,al-kj-k6,hA,k6)kd=dm([[%s M %d %f h %d]],kd,al+kj,hA,k6)end end;jU[#jU+1]=kd..[["/>]]local kl="PITCH"if not cY then kl="REL PITCH"end;if kg>90 and not cg then kg=90-(kg-90)elseif kg<-90 and not cg then kg=-90-(kg+90)end;if k2>200 then if cg then if ki>iT then jU[#jU+1]=gF(al,am-15,"Yaw","pdim txt txtmid")jU[#jU+1]=gF(al,am+20,kh,"pdim txt txtmid")end;jU[#jU+1]=dm([[<g transform="rotate(%f,%d,%d)">]],-k0,al,am)else jU[#jU+1]=dm([[<g transform="rotate(0,%d,%d)">]],al,am)end;jU[#jU+1]=dm([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-kj+25,am-5,al-kj+20,am,al-kj+25,am+5,al-kj+50,am+4,kk)jU[#jU+1]=dm([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+kj-25,am-5,al+kj-20,am,al+kj-25,am+5,al+kj-30,am+4,kk)jU[#jU+1]="</g>"end;local km=bN(k2/3)jU[#jU+1]=dm([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-km,am,k2-km)if not cg and cY then jU[#jU+1]=dm([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k0,al,am,al-kj+10,am,kj*2-20)end;jU[#jU+1]="</g>"if k2<200 then if cg and ki>iT then jU[#jU+1]=gF(al,am-k2,kl,"pdim txt txtmid")jU[#jU+1]=gF(al,am-k2+10,kk,"pdim txt txtmid")jU[#jU+1]=gF(al,am-15,"Yaw","pdim txt txtmid")jU[#jU+1]=gF(al,am+20,kh,"pdim txt txtmid")else jU[#jU+1]=gF(al,am-k2,kl,"pdim txt txtmid")jU[#jU+1]=gF(al,am-k2+15,kk,"pdim txt txtmid")end end end end;local function kn(jU,e5,cY)local ko=ar;local kp=as;if ko==0 and kp==0 then return end;local kq=78;local kr=19;local ks=cf;if cf~=-1 then jU[#jU+1]=gF(ko+kq,kp+kr+20,dm("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(e5<200000 and not cg or e5 and cg)then jU[#jU+1]=gF(ko+kq,kp-10,dm("%s",kt.name),"pdim altsm txtend")table.insert(jU,dm([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ko-1,kp-4,kq+2,kr+6,ko+1,kp-1,kq-4,kr))local go=0;local ku=1;local kv=0;local kw=e5<0;local kx=e5<kt.surfaceMaxAltitude;local ky=9;if kw then ky=0 end;local e5=f0(e5)while go<6 do local kz=11;local kA=16;local kB=9;local kC=14;local jO="altsm"if go>2 then kA=kA+3;kz=kz+2;kC=kC+2;kB=kB-6;jO="altbig"end;if kw then jO=jO.." red"elseif kx then jO=jO.." orange"end;local kD=e5/ku%10;local kE=bN(kD)local kF=bN((kE+1)%10)local kG=kv;if go==0 then kG=kD-kE;if kw then kG=1-kG end end;if kw and(go==0 or kv~=0)then local gr=kF;kF=kE;kE=gr end;local kH=kA*(kG-1)local kI=kH+kA;local hz=ko+kB+(6-go)*kz;local hA=kp+kC;jU[#jU+1]=gF(hz,hA+kH,kF,jO)jU[#jU+1]=gF(hz,hA+kI,kE,jO)go=go+1;ku=ku*10;if kE==ky then kv=kG else kv=0 end end;table.insert(jU,[[</g></g>]])end end;local function kJ(fn)local kK=-math.deg(eW(fn.y,fn.z))+180;kK=kK-90;if kK<0 then kK=360+kK end;if kK>180 then kK=-180+kK-180 end;return-kK end;local function kL(fn)local k7=math.deg(eW(fn.y,fn.x))-90;if k7<-180 then k7=360+k7 end;return k7 end;local function kM(jU,fn,ki,al,am)if ki>5 and not cg or ki>iT then local k2=ae;local kN=20;local kO=20;local kP=kJ(fn)local kQ=kL(fn)local kR=14;local kS=kR/2;local kT=-kQ/kO*k2;local kU=kP/kN*k2;local hz=al+kT;local hA=am+kU;local cb=dq(kT^2+kU^2)local kV=[[<circle
                            cx="]]..hz..[["
                            cy="]]..hA..[["
                            r="]]..kS/kR..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hz..[["
                            cy="]]..hA..[["
                            r="]]..kS..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hz-kR..[[,]]..hA..[[ h ]]..kS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hz+kS..[[,]]..hA..[[ h ]]..kS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hz..[[,]]..hA-kR..[[ v ]]..kS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<k2 then jU[#jU+1]=kV else local jV=eW(kU,kT)local kW=4;local kX=al+k2*math.cos(jV)local kY=am+k2*math.sin(jV)jU[#jU+1]=dm('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jV*180/math.pi,kX,kY,kX-kW,kY-kW/2,kW*2,kW,kX+kW,kY-kW,kW,kW,-kW,kW)end;if not cg then local kZ=vec3(fn)kP=kJ(-kZ)kQ=kL(-kZ)kT=-kQ/kO*k2;kU=kP/kN*k2;hz=al+kT;hA=am+kU;cb=dq(kT^2+kU^2)if cb<k2 then local k_=[[<circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hz..[[,]]..hA-kR..[[ v ]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hz..[[,]]..hA..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hz..[[,]]..hA..[[)" />
                                <path
                                    d="M ]]..hz-kS..[[,]]..hA..[[ h ]]..kR..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hz..[[,]]..hA..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hz..[[,]]..hA..[[)"/>]]jU[#jU+1]=k_ end end end end;local function l0(jU,jb,l1,l2)if an==0 and ao==0 then return end;l1=bN(l1+0.5)local jC=ao+10;local jD=ao+20;if iz()==1 and not m then jC=55;jD=65 end;local l3="CRUISE"local c="km/h"local dO=l2;if jb=="TRAVEL"or jb=="AUTOPILOT"then l3="THROT"c="%"dO=l1;local l4="dim"if l1<0 then l4="red"end;jU[#jU+1]=dm([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l4,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-f0(l1),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;jU[#jU+1]=gF(an+10,jC,l3,"pbright txtstart")jU[#jU+1]=gF(an+10,jD,dm("%.0f %s",dO,c),"pbright txtstart")if cg and t and cR and bT then l1=bN(bU*100+0.5)local l4="red"if l1<0 then l4="red"end;jU[#jU+1]=dm([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l4,1-f0(l1),an-10,ao+50,an-15,ao+53,an-15,ao+47)jU[#jU+1]=gF(an+10,jC+40,"LIMIT","pbright txtstart")jU[#jU+1]=gF(an+10,jD+40,l1 .."%","pbright txtstart")end;if cg and t or ba then jU[#jU+1]=gF(an+10,jC-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b5 then jU[#jU+1]=gF(an+10,jC-40,"LIMIT: "..bN(a0*3.6+0.5).." km/h","dim txtstart")end end;local function l5(jU,l6)if an==0 and ao==0 then return end;local l7=ao-10;local l8=an+10;jU[#jU+1]=gF(0,0,"","pdim txt txtend")if iz()==1 and not m then l7=75 end;jU[#jU+1]=gF(l8,l7,bN(l6).." km/h","pbright txtbig txtstart")end;local l9=40;local function la(jU)jU[#jU+1]=gF(j7(150),j8(1070),dm("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jU[#jU+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jU[#jU+1]=gF(j7(960),j8(550),"Warning: Invalid Control Scheme Detected","warnings")jU[#jU+1]=gF(j7(960),j8(600),"Keyboard Scheme must be selected","warnings")jU[#jU+1]=gF(j7(960),j8(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lb=j7(960)local lc=j8(860)local ld=j8(880)local le=j8(900)local lf=j8(960)local lg=j8(200)local lh=j8(250)local li=j8(960)if iz()==1 and not m then lc=j8(135)ld=j8(155)le=j8(175)lg=j8(115)lh=j8(95)end;if b2 then local lj=""if type(b2)=="string"then lj="-"..b2 end;jU[#jU+1]=gF(lb,lc,"Brake Engaged"..lj,"warnings")elseif bS>0 then jU[#jU+1]=gF(lb,lc,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b5 and not bs and not b8 and not cQ and not bb and not b9 then jU[#jU+1]=gF(lb,lg+50,"** STALL WARNING **","warnings")fM("stall","SW",2)end end;if cX then jU[#jU+1]=gF(lb,lg+90,"Flight Assist in Progress","warnings")end;if ck then jU[#jU+1]=gF(lb,li,"Gyro Enabled","warnings")end;if lk then l9=l9-1;if l9>20 then jU[#jU+1]=gF(lb,li-20,"ECU Enabled","warnings")elseif l9<0 then l9=40 end end;if bo then if bW then jU[#jU+1]=gF(lb,ld,"Gear Extended","warn")else jU[#jU+1]=gF(lb,ld,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local ll=iE(d:getTargetGroundAltitude())jU[#jU+1]=gF(lb,le,"Hover Height: "..ll,"warn")end;if c5 then jU[#jU+1]=gF(lb,lf+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cQ and bx~=nil then local lm="warnings"if f0(ci-antigrav.getBaseAltitude())<501 then lm="warn"end;jU[#jU+1]=gF(lb,lg+40,dm("Target Altitude: %d Singularity Altitude: %d",bN(bx),bN(antigrav.getBaseAltitude())),lm)end;if b5 and bl~="None"then jU[#jU+1]=gF(lb,lg,"Autopilot "..bi,"warn")elseif bv~=nil then jU[#jU+1]=gF(lb,lg+20,dm("LockedPitch: %d",bN(bv)),"warn")elseif c0 then jU[#jU+1]=gF(lb,lg+20,"Follow Mode Engaged","warn")elseif ba or ce then jU[#jU+1]=gF(lb,lg+20,"Re-entry in Progress","warn")end;if b7 or bb then local ll=iE(bc,2)if bb then if cQ then ll=iE(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jU[#jU+1]=gF(lb,lg,"VTO to "..ll,"warn")elseif(b9 or cd)and not bB then if cd then jU[#jU+1]=gF(lb,lg,"Takeoff to "..bl,"warn")else jU[#jU+1]=gF(lb,lg,"Takeoff to "..ll,"warn")end;if b2 and not bb then jU[#jU+1]=gF(lb,lg+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jU[#jU+1]=gF(lb,lg,"Altitude Hold: "..dm("%.1fm",bc),"warn")end end;if bb and(antigrav~=nil and antigrav)then if ch>0.1 then jU[#jU+1]=gF(lb,lg+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then jU[#jU+1]=gF(lb,lg+20,"Aligning trajectory","warn")elseif ch<0.05 then jU[#jU+1]=gF(lb,lg+20,"Leaving atmosphere","warn")end end;if bB then if cC~=nil then jU[#jU+1]=gF(lb,lg,cC,"warn")end end;if b8 then local ln="Brake Landing"if dc then ln=ln.."-Aligning"end;if db then ln=ln.."-Drift Limited"end;jU[#jU+1]=gF(lb,lg,ln,"warnings")end;if b4 then jU[#jU+1]=gF(lb,lg+20,"Prograde Alignment","crit")end;if b3 then jU[#jU+1]=gF(lb,lg,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;jU[#jU+1]=gF(lb,lh+20,cZ,type)elseif ch==0 then local lo,lp=ct.checkLOS(cK:normalize())if lp~=nil and cL>0 then local ll=iE(lp)local lq=cp.computeTravelTime(cL,0,lp)local lr="Collision"if lo.noAtmosphericDensityAltitude>0 then lr="Atmosphere"end;jU[#jU+1]=gF(lb,lh+20,lo.name.." "..lr.." "..iF(lq).." In "..ll,"crit")end end;if bs and not bB then jU[#jU+1]=gF(lb,lg+60,ls,"warn")end;if d2 and#d2>1 then end;local lt=j7;local lu=j8;local lv="topButton"local lw="topButtonActive"local lx=lv;if b5 or bs or cd or bB then lx=lw end;local ly=lv;if b4 then ly=lw end;local lz=lv;if b8 or bo then lz=lw end;local lA=lv;if b7 or bs then lA=lw end;local lB=lv;if b3 then lB=lw end;local lC=lv;if bB or cE and b5 then lC=lw end;if w and I then local lD=lu(30)jU[#jU+1]=dm([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lx,lt(960),lu(54),lu(-53),lt(-120),lt(25),lu(50))jU[#jU+1]=gF(lt(910),lD,"AUTOPILOT")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ly,lt(865),lu(51),lt(-25),lu(-50),lt(-110),lt(25),lu(46))jU[#jU+1]=gF(lt(800),lD,"PROGRADE")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lz,lt(755),lu(47),lt(-25),lu(-46),lt(-98),lt(44),lu(44))jU[#jU+1]=gF(lt(700),lD,"LAND")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lA,lt(960),lu(54),lu(-53),lt(120),lt(-25),lu(50))jU[#jU+1]=gF(lt(1010),lD,"ALT HOLD")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lB,lt(1055),lu(51),lt(25),lu(-50),lt(110),lt(-25),lu(46))jU[#jU+1]=gF(lt(1122),lD,"RETROGRADE")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lC,lt(1165),lu(47),lt(25),lu(-46),lt(98),lt(-44),lu(44))jU[#jU+1]=gF(lt(1220),lD,"ORBIT")jU[#jU+1]=[[
                                    </g>
                                </g>]]jU[#jU+1]="</g>"end;return jU end;local function lE(ki)return bN(fN(ki*3.6,0)+0.5).." km/h"end;local function lF(go)local gq=bl;if go~=nil and type(go)=="number"then if go==0 then return"None"end;gq=cU[go].name end;if gq==nil then gq=fY.name end;if gq==nil then gq="None"end;return gq end;local function lG(jU)local lH=ct.routeWP(true)if not lH or#lH==0 then return end;local hz=j7(750)local hA=j8(360)if b5 or bs then jU[#jU+1]=gF(hz,hA,"REMAINING ROUTE","pdim txtstart size20")else jU[#jU+1]=gF(hz,hA,"LOADED ROUTE","pdim txtstart size20")end;for dN,M in pairs(lH)do hA=hA+20;jU[#jU+1]=gF(hz,hA,dN..". "..lH[dN],"pdim txtstart size20")end end;local function lI(jU)local lJ=aB;local lK=aC;local lL=aA;local lM=4;local lN=15;local hz=0;local hA=0;local lO,lP,lQ,lR;local lS;local function lT(type)local gA,bQ,ki,lU,jO,lV;if type=="Periapsis"then gA=lS.periapsis.altitude;bQ=lS.timeToPeriapsis;ki=lS.periapsis.speed;jO="txtend"lU=12;lV=math.min(hz,lJ+lL-kt.radius/lQ-lM*2)else gA=lS.apoapsis.altitude;bQ=lS.timeToApoapsis;ki=lS.apoapsis.speed;lU=-12;jO="txtstart"lV=hz end;if cL<1 then bQ=0 end;jU[#jU+1]=dm([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lV+lU,hA-5,hz,hA-5)jU[#jU+1]=dm([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lV-lU*4,hA+2,hz,hA+2)jU[#jU+1]=gF(lV,hA,type,jO)hz=lV-lU*2;hA=hA+lN;local ll=iE(gA)jU[#jU+1]=gF(hz,hA,ll,jO)hA=hA+lN;jU[#jU+1]=gF(hz,hA,iF(bQ),jO)hA=hA+lN;jU[#jU+1]=gF(hz,hA,lE(ki),jO)end;local lW=lL*1.5;if bK=="INFO"then lW=25*10 end;if bK=="ORBIT"and ci<kt.spaceEngineMinAltitude then return jU end;if bK~="HIDE"then jU[#jU+1]=[[<g class="pbright txtorb txtmid">]]jU[#jU+1]=dm('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lL*2,lW,lJ,lK)jU[#jU+1]=dm([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lL*2,lW,lJ,lK)end;local lX=lL*1.5;local lY=lL*2;local lZ=lX/2;local l_=lL;local m0=lJ+l_;local m1=lK+lZ;local m2=lJ+lY;local m3=lK+lX;if bK=="ORBIT"then lK=lK+lM;lO=lL/2;lR=0;lS={}lS.periapsis={}lS.apoapsis={}if fm~=nil then if fm.periapsis~=nil then lS.periapsis.altitude=fm.periapsis.altitude;lS.periapsis.speed=fm.periapsis.speed end;if fm.apoapsis~=nil then lS.apoapsis.altitude=fm.apoapsis.altitude;lS.apoapsis.speed=fm.apoapsis.speed end;lS.period=fm.period;lS.eccentricity=fm.eccentricity;lS.timeToApoapsis=fm.timeToApoapsis;lS.timeToPeriapsis=fm.timeToPeriapsis;lS.eccentricAnomaly=fm.eccentricAnomaly;lS.trueAnomaly=fm.trueAnomaly end;if lS.periapsis==nil then lS.periapsis={}lS.periapsis.altitude=-kt.radius;lS.periapsis.speed=a0 end;if lS.eccentricity==nil then lS.eccentricity=1 end;if lS.apoapsis==nil then lS.apoapsis={}lS.apoapsis.altitude=ci;lS.apoapsis.speed=0 end;if cL<1 then lS.apoapsis.altitude=ci;lS.apoapsis.speed=0 end;if lS.apoapsis.altitude then lQ=(lS.apoapsis.altitude+lS.periapsis.altitude+kt.radius*2)/(lO*2)lP=(kt.radius+lS.apoapsis.altitude)/lQ*(1-lS.eccentricity)lR=lO-lS.periapsis.altitude/lQ-kt.radius/lQ;local m4=math.pi;if lS.period~=nil and lS.period>0 and lS.timeToApoapsis~=nil then m4=lS.eccentricAnomaly;if lS.timeToPeriapsis<lS.timeToApoapsis then m4=2*math.pi-m4 end end;if cL<1 or m4~=m4 then m4=math.pi end;local m5=-lO*math.cos(m4)+lJ+l_+lM;local m6=lP*math.sin(m4)+lK+lZ+lM;local m7=""jU[#jU+1]='<g clip-path="url(#orbitRect)">'jU[#jU+1]=dm([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],m7,lJ+lL+lM,lK+lL*1.5/2+lM,lO,lP)if lP<1 then jU[#jU+1]=dm([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lJ+lL+lM-lR,lK+lL*1.5/2+lM,m5,m6)end;jU[#jU+1]=dm('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lJ+lL+lM-lR,lK+lL*1.5/2+lM,(kt.radius+kt.noAtmosphericDensityAltitude)/lQ)jU[#jU+1]=dm('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lJ+lL+lM-lR,lK+lL*1.5/2+lM,(kt.radius+kt.noAtmosphericDensityAltitude)/lQ)jU[#jU+1]=dm([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lJ+lL+lM,lK+lL*1.5/2+lM,lO,lP)jU[#jU+1]=dm('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lJ+lL+lM-lR,lK+lL*1.5/2+lM,kt.radius/lQ)jU[#jU+1]='</g>'local m8=math.floor(kt.radius/lQ+0.5)hz=lJ+lL+lM*4+lO;hA=lK+lL*1.5/2+5+lM;if lS.apoapsis~=nil and lS.apoapsis.speed<a0 then lT("Apoapsis")end;hA=lK+lL*1.5/2+5+lM;hz=lJ+lL-lM*2-lO;if lS.periapsis~=nil and lS.periapsis.speed<a0 and lS.periapsis.altitude>0 then lT("Periapsis")end;jU[#jU+1]=gF(lJ+lL+lM,lK+20+lM,kt.name,"txtorbbig")jU[#jU+1]=dm('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m5,m6)jU[#jU+1]=[[</g>]]return jU else jU[#jU+1]='<g clip-path="url(#orbitRect)">'local m9=""local ma=1.2*(mb-mc)/(lL*2)local md=1.4*(me-mf)/(lL*1.5)for dN,dz in pairs(e[0])do if dz.center then local hz=lJ+lL+dz.center.x/ma;local hA=lK+lL*1.5/2+dz.center.y/md;m9=m9 ..'<circle cx="'..hz..'" cy="'..hA..'" r="'..dz.radius/ma*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dz.name,"Moon")and not string.match(dz.name,"Sanctuary")and not string.match(dz.name,"Space")then m9=m9 .."<text x='"..hz.."' y='"..hA+dz.radius/ma*30+20 .."' font-size='12' fill="..i_.." text-anchor='middle' font-family='Montserrat'>"..dz.name.."</text>"end end end;local fo=vec3(bP.getWorldPosition())local hz=lJ+lL+fo.x/ma;local hA=lK+lL*1.5/2+fo.y/md;m9=m9 ..'<circle cx="'..hz..'" cy="'..hA..'" r="2" stroke="white" stroke-width="1" fill="red"/>'m9=m9 .."<text x='"..hz.."' y='"..hA-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iN=ma;iO=md;local mg=fo+cK*1000000;local mh=lJ+lL+mg.x/ma;local jD=lK+lL*1.5/2+mg.y/md;m9=m9 ..'<line x1="'..hz..'" y1="'..hA..'" x2="'..mh..'" y2="'..jD..'" stroke="purple" stroke-width="1"/>'jU[#jU+1]=m9;jU[#jU+1]='</g>'end elseif bK=="INFO"then jU=cr.DrawOdometer(jU,j1,bp,j2)elseif bK=="SCOPE"then jU[#jU+1]='<g clip-path="url(#orbitRect)">'local mi=d5;local mj=vec3(DUSystem.getCameraWorldPos())local mk=vec3(DUSystem.getCameraWorldRight())local ml=vec3(DUSystem.getCameraWorldForward())if iB()==1 then mj=cO;mk=cI;ml=cH end;if ch>0 then table.sort(d4,function(eC,eD)local eE,eF=eC.center,eD.center;return(eE.x-mj.x)^2+(eE.y-mj.y)^2+(eE.z-mj.z)^2<(eF.x-mj.x)^2+(eF.y-mj.y)^2+(eF.z-mj.z)^2 end)end;local mm={}local mn={}local mo=120;local mp=nil;local mq=nil;for M,dz in ipairs(d4)do local gN=dz.center-mj;local mr=gN:len()local ms=gN:normalize()local mt=gN:cross(ml):normalize()local mu=math.acos(mt:dot(mk))if mu~=mu then mu=0 end;if mt:cross(mk):dot(ml)<0 then mu=-mu end;local mv=gN:project_on_plane(ml):len()local mw=math.sin(mu)*math.asin(mv/mr)*constants.rad2deg;local mx=math.cos(mu)*math.asin(mv/mr)*constants.rad2deg;if ms:dot(ml)<0 then mx=90*math.cos(mu)+90*math.cos(mu)-mx;mw=90*math.sin(mu)+90*math.sin(mu)-mw end;local hz=m0+mw/mi*lX;local hA=m1+mx/mi*lX;local my=(hz-m0)*(hz-m0)+(hA-m1)*(hA-m1)local mz=math.asin((dz.radius+dz.surfaceMaxAltitude)/mr)*constants.rad2deg;if mz~=mz then mz=mi end;local hU=mz/mi*lX;local mA=math.asin(dz.atmosphereRadius/mr)*constants.rad2deg;if mA~=mA then mA=mz end;local mB=mA/mi*lX;local cb=iE(mr,1)local mC=dz.name;local mD=false;if hA>lK then if hA>m3 then if hA-mB<=m3 then mD=true end else mD=true end else if hA+mB>=lK then mD=true end end;local mE=false;local mF=hz;if dz.systemId==0 then mF=hz+mo else mF=hz-mo end;if mF+mo>lJ then if mF+mo>m2 then if mF-mB-mo<=m2 then mE=true end else mE=true end else if mF+mB+mo>=lJ then mE=true end end;local mG={}mG.x=hz;mG.y=hA;mG.planet=dz;mG.atmoSize=mB;if not mp or my<mp then mp=my;mq=mG end;if mE and mD then local mH=math.max(mB,5)if my<mH*mH then mC=mC.." - "..cb end;mG.size=hU;mG.i=M;mG.displayString=mC;mG.distance=cb;mG.visible=true;mn[#mn+1]=mG else mG.visible=false end end;local mI=false;table.sort(mn,function(eE,eF)return eE.y<eF.y end)for dN,fj in ipairs(mn)do local dz,hU,M,mB,hz,hA,mC,cb=fj.planet,fj.size,fj.i,fj.atmoSize,fj.x,fj.y,fj.displayString,fj.distance;local lV,mJ,mK,mL;local mM=15;local jO="pdim"if dz.systemId~=0 then mK=j7(string.len(mC)*5)mM=-(15+mK)mL=j8(10)jO="pdimfill"else mK=j7(string.len(mC)*9)mL=j8(15)end;if hU*2>mK then lV=dn(hz,lJ+mK/2,m2-mK/2)mJ=dn(hA,lK+mL,m3-5)lV=dn(lV,hz-hU+mK/2,hz+hU-mK/2)mJ=dn(mJ,hA-hU+mL,hA+hU)else lV=hz+mM;mJ=hA end;for mN,fj in pairs(mm)do local mO=fj.textPositions;local mP=mO.y-mJ;if mN~=M and f0(mP)<mO.height and mO.x+mO.width>lV and mO.x<lV+mK then if hU>mK then mJ=dn(mJ+mL,lK+15,m3-5)else mJ=mO.y+mO.height+1 end end end;local mQ=mC~=dz.name or lV<=m0 and lV+mK>=m0 and mJ-mL<=m1 and mJ>=m1;fj.hovered=mQ;local mR=1;if mQ then mR=2;if hU*2<mK then mR=10 end;if mC==dz.name then mC=mC.." - "..cb end;jO="pbright"if dz.systemId~=0 then mK=j7(string.len(mC)*5)mM=-(15+mK)else mK=j7(string.len(mC)*7)end;if hU*2>mK then lV=dn(hz,lJ+mK/2,m2-mK/2)lV=dn(lV,hz-hU+mK/2,hz+hU-mK/2)else lV=hz+mM end end;mm[M]={}mm[M].textPositions={}mm[M].textPositions.y=mJ;mm[M].textPositions.x=lV;mm[M].textPositions.width=mK;mm[M].textPositions.height=mL;mm[M].output=""if hU*2>mK then jO=jO.." txtmid"else jO=jO.." txtstart"end;if mB-hU>2 then mm[M].output=dm('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hz,hA,mB,j0,0.1*mR)end;mm[M].output=mm[M].output..dm('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hz,hA,hU,j0,0.2*mR)if dz.systemId==0 then mm[M].output=mm[M].output..dm([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lV,mJ,i_,jO,mC)if hU*2<=mK then mm[M].output=mm[M].output..dm("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lV+mK,mJ+2,lV,mJ+2,hz,hA)end else mm[M].output=mm[M].output..dm([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lV,mJ,j0,jO,mC)if hU*2<=mK then mm[M].output=mm[M].output..dm("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lV,mJ+2,lV+mK,mJ+2,hz,hA)end end end;for dN=#d4,1,-1 do if mm[dN]then jU[#jU+1]=mm[dN].output end end;if mq~=nil and d5<90 and not mq.hovered then local mS=mq.planet.atmosphereRadius/mq.atmoSize;local mT=dq(mp)*mS;local mU=iE(mT,1)local mK=j7(math.max(string.len(mU)*7,string.len(mq.planet.name)*7))local mL=j8(12)local lV=dn(mq.x+(m0-mq.x)/2,lJ+mK/2,m2-mK/2)local mJ=dn(mq.y+(m1-mq.y)/2,lK+mL*2,m3-5)jU[#jU+1]=dm("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mq.x,mq.y,m0,m1)jU[#jU+1]=dm([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lV,mJ,"white",mU)if not mq.visible then jU[#jU+1]=dm([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lV,mJ-mL,"white",mq.planet.name)end end;if cL>1 then local gN=cK;local ms=gN:normalize()local mv=gN:project_on_plane(ml):len()local mt=gN:cross(ml):normalize()local mu=math.acos(mt:dot(mk))if mu~=mu then mu=0 end;if mt:cross(mk):dot(ml)<0 then mu=-mu end;local mw=math.sin(mu)*math.asin(mv/gN:len())*constants.rad2deg;local mx=math.cos(mu)*math.asin(mv/gN:len())*constants.rad2deg;if ms:dot(ml)<0 then mx=90*math.cos(mu)+90*math.cos(mu)-mx;mw=90*math.sin(mu)+90*math.sin(mu)-mw end;local hz=m0+mw/mi*lX;local hA=m1+mx/mi*lX;local kR=14;local kS=kR/2;local kV=[[<circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kS/kR..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hz-kR..[[,]]..hA..[[ h ]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hz+kS..[[,]]..hA..[[ h ]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hz..[[,]]..hA-kR..[[ v ]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jU[#jU+1]=kV end;jU[#jU+1]=dm("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m0,m1-10,m0,m1+10)jU[#jU+1]=dm("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m0-10,m1,m0+10,m1)jU[#jU+1]='</g>'else return jU end end;local function mV(mW,mX)local mY;local mZ=(mX-mW):normalize()local fp=(cO-mW):dot(mZ)/mZ:dot(mZ)if fp<=0. then return(cO-mW):len(),nil elseif fp>=(mX-mW):len()then return(cO-mX):len(),nil end;local m_=mW+fp*mZ;mY=(m_-cO):len()return mY,m_ end;local function n0()local mY;local n1=nil;local n2=nil;local n3=nil;local n4=nil;for dN,n5 in pairs(e[0])do if n5.hasAtmosphere then local cb,n1=mV(kt.center,n5.center)if n2==nil or cb<n2 then n3=n5;n2=cb;if n1 then dg=n1 end;n4=kt end;if c8 and c8.hasAtmosphere and c8.name~=kt.name then local eR,n1=mV(c8.center,n5.center)if eR<n2 then n3=n5;n2=eR;if n1 then dg=n1 end;n4=c8 end end end end;local n6=j7(1770)local n7=j8(330)if n2 then local n8="txttick "local n9=500000;if n2<n3.radius+n9 or n2<n4.radius+n9 then if cV then n8="txttick red "else n8="txttick orange "end end;mY=iE(n2,2)iS=gF(n6,n7,"Pipe ("..n4.name.."--"..n3.name.."): "..mY,n8 .."pbright txtmid")end end;local function na(hz,hA,nb,nc,l3)local nd={x=hz,y=hA,width=nb,height=nc,label=l3}iM[l3]=nd;return nd end;local function ne(nf,ng,nb,nc,hz,hA,nh,ni,nj,nk,jO)local nd={enableName=nf,disableName=ng,width=nb,height=nc,x=hz,y=hA,toggleVar=nh,toggleFunction=ni,drawCondition=nj,hovered=false,class=jO}if nk then table.insert(iL,nd)else table.insert(iK,nd)end;return nd end;local function nl(nm)if not iQ then nn=false;no=false;np=false;w=true;return elseif nm=="handling"then nn=not nn;no=false;np=false elseif nm=="hud"then no=not no;nn=false;np=false elseif nm=="physics"then np=not np;nn=false;no=false end;if np or no or nn then iR=iD(nm)w=false else iR="none"w=true end end;local function nq()iQ=not iQ;if iQ then iJ=iL;dk("Tap LMB to see Settings")d6=w else iJ=iK;dk("Tap LMB to see Control Buttons")nl()w=d6 end end;local function nr()local function ns(dz,dN)dz.set(not dz.get())if dz.get()then dk(dN.." set to true")else dk(dN.." set to false")end;if dN=="showHud"then d6=dz.get()elseif dN=="BrakeToggleDefault"then b0=k end end;local nt=50;local nu=340;local hz=ac/2-530;local hA=ad/2-330+nt/2;local nv=0;for dN,dz in pairs(iD("boolean"))do if type(dz.get())=="boolean"then ne(dN,dN,nu,nt,hz,hA,function()return dz.get()end,function()ns(dz,dN)end,function()return true end,true)hA=hA+nt+20;if nv==9 then hz=hz+nu+20;hA=ad/2-330+nt/2;nv=0 else if hz>ac/2-nu and hz<ac/2+nu/2 and hA>ad/2-nt and hA<ad/2+nt then hA=hA+nt+20;nv=nv+1 end;nv=nv+1 end end end;ne("Control View","Control View",nu,nt,10,ad/2-500,function()return true end,nq,function()return true end,true)ne("View Handling Settings",'Hide Handling Settings',nu,nt,10,ad/2-(500-nt),function()return nn end,function()nl("handling")end,function()return true end,true)ne("View Hud Settings",'Hide Hud Settings',nu,nt,10,ad/2-(500-nt*2),function()return no end,function()nl("hud")end,function()return true end,true)ne("View Physics Settings",'Hide Physics Settings',nu,nt,10,ad/2-(500-nt*3),function()return np end,function()nl("physics")end,function()return true end,true)end;local function nw()local function gp()local fP=cO;local gq=kt.name..". "..#br;if cu then gq=cu.GetClosestName(gq)end;return cs.AddNewLocation(gq,fP,false,true)end;local function nx()b6=not b6 end;local function ny(nz)if nz==1 then b4=not b4;b3=false else b3=not b3;b4=false end;b5=false;b7=false;c0=false;b8=false;bv=nil;ba=false;b9=false end;local function nA(nB,nC)cs.UpdatePosition(nil,nB,nC)end;local function gk()cs.ClearCurrentPosition()end;local function nD(go)local lH=ct.routeWP(true)if lH and#lH>0 then return"Engage Route: "..lH[1]end;return"Engage Autopilot: "..lF(go)end;local function nE(go)local lH=ct.routeWP(true)if lH and#lH>0 then return"Next Route Point: "..lH[1]end;return"Disable Autopilot: "..lF(go)end;local function nF()if iz()==1 then c0=not c0;if c0 then b5=false;b3=false;b4=false;b7=false;ba=false;b8=false;b9=false;nG=bo;bo=false;d.control.retractLandingGears()iA:setTargetGroundAltitude(Y)fM("folOn","F")else fM("folOff","F")b2="Follow Off"cz=q;bo=nG;if bo then d.control.deployLandingGears()iA:setTargetGroundAltitude(Z)end end else dk("Follow Mode only works with Remote controller")c0=false end end;local nt=50;local nu=260;local nH=j7(30)local nI=aB+aA*2+2;local nJ=aC+1;ne("+","+",nH,nH,nI,nJ+nH+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")ne("-","-",nH,nH,nI,nJ,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")ne("0","0",nH,nH,nI,nJ+nH*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nK=ne("Enable Brake Toggle","Disable Brake Toggle",nu,nt,ac/2-nu/2,ad/2+350,function()return b0 end,function()b0=not b0;if b0 then dk("Brakes in Toggle Mode")else dk("Brakes in Default Mode")end end)ne("Align Prograde","Disable Prograde",nu,nt,ac/2-nu/2-50-nK.width,ad/2-nt+380,function()return b4 end,function()ny(1)end)ne("Align Retrograde","Disable Retrograde",nu,nt,ac/2-nu/2+nK.width+50,ad/2-nt+380,function()return b3 end,ny,function()return ch==0 end)nL=ne(nD,nE,600,60,ac/2-600/2,ad/2-60/2-330,function()return b5 or bs or cd or bB end,function()end)local M;local function nM(nN)local go=d1+nN;if go>#cU then go=go-#cU-1 end;if go<0 then go=#cU+go end;return go end;nO={}for M=0,10 do local nP=ne(function(eF)local go=nM(eF.apExtraIndex)if b5 or bs or cd or bB then return"Redirect: "..lF(go)end;return nD(go)end,function(eF)local go=nM(eF.apExtraIndex)return nE(go)end,600,60,ac/2-600/2,ad/2-60/2-330+60*M,function(eF)local go=nM(eF.apExtraIndex)return go==bn and(b5 or bs or cd or bB)end,function(eF)local go=nM(eF.apExtraIndex)local nQ=bn==go;bn=go;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not nQ and not(b5 or bs or cd or bB)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nP.apExtraIndex=M;nO[M]=nP end;ne("Save Position","Save Position",200,nL.height,nL.x+nL.width+30,nL.y,function()return false end,gp,function()return bn==0 or fY==nil end)ne("Update Position","Update Position",200,nL.height,nL.x+nL.width+30,nL.y,function()return false end,function()nA(nil)end,function()return bn>0 and fY~=nil end)ne("Save Heading","Clear Heading",200,nL.height,nL.x+nL.width+30,nL.y+nL.height+20,function()return fY.heading~=nil end,function()if fY.heading~=nil then nA(false)else nA(true)end end,function()return bn>0 and fY~=nil end)ne("Save AGG Alt","Clear AGG Alt",200,nL.height,nL.x+nL.width+30,nL.y+nL.height*2+40,function()return fY.agg~=nil end,function()if fY.agg~=nil then nA(nil,false)else nA(nil,true)end end,function()return bn>0 and fY~=nil and antigrav end)ne("Clear Position","Clear Position",200,nL.height,nL.x-200-30,nL.y,function()return true end,gk,function()return bn>0 and fY~=nil end)ne("Save Route","Save Route",200,nL.height,nL.x-200-30,nL.y+nL.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)ne("Load Route","Clear Route",200,nL.height,nL.x-200-30,nL.y+nL.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b5 or bs then dk("Disable Autopilot before loading route")return else ct.routeWP(false,false,1)end end,function()return true end)nt=60;nu=300;local hz=0;local hA=ad/2-150;ne("Enable Check Damage","Disable Check Damage",nu,nt,hz,hA-nt-20,function()return s end,function()s=not s end)ne("View Settings","View Settings",nu,nt,hz,hA,function()return true end,nq)hA=hA+nt+20;ne("Enable Turn and Burn","Disable Turn and Burn",nu,nt,hz,hA,function()return b6 end,nx)hz=10;hA=ad/2-300;ne("Horizontal Takeoff Mode","Vertical Takeoff Mode",nu,nt,ac/2-nu/2,hA+20,function()return b1 end,function()b1=not b1;if b1 then dk("Vertical Takeoff Mode")else dk("Horizontal Takeoff Mode")end end,function()return cP end)hA=hA+nt+20;ne("Engage Orbiting","Cancel Orbiting",nu,nt,hz+nu+20,hA,function()return bB end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hA=ad/2-150;ne("Glide Re-Entry","Cancel Glide Re-Entry",nu,nt,hz+nu+20,hA,function()return ba end,function()cc=1;ny(1)end,function()return kt.hasAtmosphere and not cg end)hA=hA+nt+20;ne("Parachute Re-Entry","Cancel Parachute Re-Entry",nu,nt,hz+nu+20,hA,function()return ba end,function()cc=2;ny(1)end,function()return kt.hasAtmosphere and not cg end)hA=hA+nt+20;ne("Engage Follow Mode","Disable Follow Mode",nu,nt,hz,hA,function()return c0 end,nF,function()return iz()==1 end)ne("Enable Repair Arrows","Disable Repair Arrows",nu,nt,hz+nu+20,hA,function()return j5 end,function()j5=not j5;if j5 then dk("Repair Arrows Enabled")else dk("Repair Arrows Diabled")end end,function()return iz()==1 end)hA=hA+nt+20;if not r then ne("Enable AGG","Disable AGG",nu,nt,hz,hA,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;ne(function()return dm("Switch IPH Mode - Current: %s",bC)end,function()return dm("IPH Mode: %s",bC)end,nu*2,nt,hz,hA,function()return false end,function()if bC=="All"then bC="Custom Only"elseif bC=="Custom Only"then bC="No Moons-Asteroids"else bC="All"end;dk("IPH Mode: "..bC)end)hA=hA+nt+20;ne(function()return dm("Toggle Control Scheme - Current: %s",g)end,function()return dm("Control Scheme: %s",g)end,nu*2,nt,hz,hA,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;dk("New Control Scheme: "..g)end)local nR=j8(20)local nP=na(0,0,j7(80),nR,"INFO")nP=na(nP.x+nP.width,nP.y,j7(70),nR,"ORBIT")nP=na(nP.x+nP.width,nP.y,j7(70),nR,"SCOPE")na(nP.x+nP.width,nP.y,j7(70),nR,"HIDE")end;local nS={}local nT=nil;function nS.HUDPrologue(jU)if not cV then iX=ai;iY=aj;iZ=ak else iX=af;iY=ag;iZ=ah end;i_=[[rgb(]]..bN(iX+0.6)..","..bN(iY+0.6)..","..bN(iZ+0.6)..[[)]]j0=[[rgb(]]..bN(iX*0.8+0.5)..","..bN(iY*0.8+0.5)..","..bN(iZ*0.8+0.5)..[[)]]local nU=i_;local nV=j0;local nW=[[rgb(]]..bN(iX*0.4+0.5)..","..bN(iY*0.4+0.5)..","..bN(iZ*0.4+0.5)..[[)]]local nX=i_;local nY=j0;local nZ=nW;if j9()and not n then nU=[[rgb(]]..bN(iX*0.5+0.5)..","..bN(iY*0.5+0.5)..","..bN(iZ*0.5+0.5)..[[)]]nV=[[rgb(]]..bN(iX*0.3+0.5)..","..bN(iY*0.3+0.5)..","..bN(iZ*0.2+0.5)..[[)]]nW=[[rgb(]]..bN(iX*0.2+0.5)..","..bN(iY*0.2+0.5)..","..bN(iZ*0.2+0.5)..[[)]]end;local lt=j7;local lu=j8;jU[#jU+1]=dm([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nU,nU,nU,nX,nX,nV,nV,nY,nY,nV,nU,nW,nY,nU,nU,nW,nW,nZ,nW,ac,ad,nV,nV,nV,nV,nV,nX,nV,nY,nZ,nY,nY,nZ)if not nT then nT=dm([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lt(630),lu(0),lt(675),lu(45),lt(960),lu(55),lt(1245),lu(45),lt(1290),lu(0),lt(1000),lu(105),lt(1040),lu(59),lt(1250),lu(51),lt(1300),lu(0),lt(1920),lu(0),lt(1920),lu(20),lt(1400),lu(20),lt(1300),lu(105),lt(920),lu(105),lt(880),lu(59),lt(670),lu(51),lt(620),lu(0),lt(0),lu(0),lt(0),lu(20),lt(520),lu(20),lt(620),lu(105),lt(890),lu(59),lt(960),lu(62),lt(1030),lu(59),lt(985),lu(112),lt(1150),lu(112),lt(1100),lu(152),lt(820),lu(152),lt(780),lu(112),lt(935),lu(112),lt(890),lu(59),lt(960),lu(62),lt(1030),lu(59),lt(985),lu(112),lt(1150),lu(112),lt(1100),lu(152),lt(820),lu(152),lt(780),lu(112),lt(935),lu(112))end;if w and I then jU[#jU+1]=nT end;return jU end;function nS.DrawVerticalSpeed(jU,e5)jT(jU,e5)end;function nS.UpdateHud(jU)local kK=cS;local n_=cT;local k0=n_;local kg=kK;local l1=bN(c.getThrottle())local l6=cL*3.6;local l2=c.getAxisCommandValue(0)local o0=j7(1770)local o1=j8(310)if t and cR then l2=bR;l1=bR*100 end;local jb=ja()local k1="ROLL"if l1==nil then l1=0 end;if not cY then if cL>5 then kK=kJ(cJ)n_=kL(cJ)else kK=0;n_=0 end;k1="YAW"end;if cW>50000 and not cg then local o2;o2=iE(cW)jU[#jU+1]=gF(o0,o1,"PvP Boundary: "..o2,"pbright txtbig txtmid")end;jU[#jU+1]=j3;jU[#jU+1]=i7;if iS~=""then jU[#jU+1]=iS end;if jc~=""then jU[#jU+1]=jc end;if jd~=""then jU[#jU+1]=jd end;jT(jU,ci)if iz()==0 or m then if not j9()or n then if cY then j_(jU,al,am,k0,k1,cY)kf(jU,kg,k0,al,am,cY,bN(kL(cJ)),cL)else j_(jU,al,am,n_,k1,cY)kf(jU,kK,n_,al,am,cY,bN(n_),cL)end;kn(jU,ci,cY)kM(jU,cJ,cL,al,am)end end;l0(jU,jb,l1,l2)l5(jU,l6)la(jU)lI(jU)if not iQ and c1 then lG(jU)end;return jU end;function nS.HUDEpilogue(jU)jU[#jU+1]="</svg>"return jU end;function nS.ExtraData(jU)local o3=j7(1240)local o4=j8(55)local o5=o4+10;local o6;local lt=j7;local lu=j8;local o7=0;local jb=ja()if b1 then jb=jb.."-VERTICAL"end;if E and gQ and not b9 and not b8 and cL>20 then jb=jb.."-COLLISION ON"end;if bE~="Off"then jb="("..bE..")-"..jb end;if b6 then jb="TB-"..jb end;if not bD then jb=jb.."-DeCoupled"end;if dh then jb="Alignment Lock-"..jb end;local o8=lu(99)local o9=lu(80)local oa=lu(85)local ob=lu(31)local oc=0;local od=0;local f5=cj>1000000 and fN(cj/1000000,2).."kT"or fN(cj/1000,2).."T"if cg then o7=bw else o7=bu end;local oe,of=cp.computeDistanceAndTime(cL,0,cj,0,0,o7)if oe<0 then oe=0 end;o7=fN(o7/(cj*iI),2).."g"local og=d:maxForceForward()o6=b.getGravityIntensity()if o6>0.1 then od=cj*o6;od=fN(od/(cj*iI),2).."g"oc=0.5*og/o6;oc=oc>1000000 and fN(oc/1000000,2).."kT"or fN(oc/1000,2).."T"end;og=fN(og/(cj*iI),2).."g"local oh=vec3(bP.getWorldAcceleration()):len()/9.80665;o6=b.getGravityIntensity()jU[#jU+1]=[[<g class="dim txt txtend size14">]]if iz()==1 and not m then o3=j7(1120)o4=j8(55)o5=o4+10 elseif cg and I then local oi=j7(770)jU[#jU+1]=gF(lt(895),o8,"ATMO","")jU[#jU+1]=dm([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lt(895),oa,lt(-80))jU[#jU+1]=gF(lt(815),o9,dm("%.1f%%",ch*100),"txtstart size20")end;if I then jU[#jU+1]=gF(lt(1025),o8,"GRAVITY","txtstart")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(1025),oa,lt(80))jU[#jU+1]=gF(lt(1105),o9,dm("%.2fg",o6/9.80665),"size20")jU[#jU+1]=gF(lt(1125),o8,"ACCEL","txtstart")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(1125),oa,lt(80))jU[#jU+1]=gF(lt(1205),o9,dm("%.2fg",oh),"size20")jU[#jU+1]=gF(lt(695),o8,"BRK TIME","")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(695),oa,lt(-80))jU[#jU+1]=gF(lt(615),o9,dm("%s",iF(of)),"txtstart size20")jU[#jU+1]=gF(lt(635),lu(45),"TRIP","")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(635),lu(31),lt(-90))if lq then jU[#jU+1]=gF(lt(545),lu(26),dm("%s",iF(lq)),"txtstart size20")end;jU[#jU+1]=gF(lt(795),o8,"BRK DIST","")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(795),oa,lt(-80))jU[#jU+1]=gF(lt(715),o9,dm("%s",iE(oe)),"txtstart size20")jU[#jU+1]=gF(lt(1285),lu(45),"MASS","txtstart")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(1285),lu(31),lt(90))jU[#jU+1]=gF(lt(1375),lu(26),dm("%s",f5),"size20")jU[#jU+1]=gF(lt(1220),o8,"THRUST","txtstart")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(1220),oa,lt(80))jU[#jU+1]=gF(lt(1300),o9,dm("%s",og),"size20")jU[#jU+1]=gF(j7(960),j8(175),jb,"pbright txtbig txtmid size20")end;jU[#jU+1]="</g>"end;local oj=1-(a6*0.05+a7*0.05)function nS.FuelUsed(ok)local ol;if ok=="atmofueltank"then ol=dm("Atmo Fuel Used: %.1f L",ju[ok]/(4*oj))elseif ok=="spacefueltank"then ol=dm("Space Fuel Used: %.1f L",ju[ok]/(6*oj))else ol=dm("Rocket Fuel Used: %.1f L",ju[ok]/(0.8*oj))end;return ol end;local om,on,oo,op,oq=0,0,0,{},0;local os=0;local ot=0;local ou=0;local ov=0;function nS.DrawOdometer(jU,j1,bp,j2)if bK~="INFO"then return jU end;local o6;local o7=0;local od=0;local f5=cj>1000000 and fN(cj/1000000,2).." kTons"or fN(cj/1000,2).." Tons"if cg then o7=bw else o7=bu end;local oe,of=cp.computeDistanceAndTime(cL,0,cj,0,0,o7)local og=d:maxForceForward()o6=b.getGravityIntensity()if cL<5 and cf~=-1 then local ow=vec3(bP.getOrientationForward())local ox=bP.getMaxThrustAlongAxis('thrust analog longitudinal ',{ow:unpack()})os=0.5*ox[1]/o6;os=os>1000000 and fN(os/1000000,1).." kTons"or fN(os/1000,1).." Tons"ot=0.5*ox[3]/o6;ot=ot>1000000 and fN(ot/1000000,1).." kTons"or fN(ot/1000,1).." Tons"ow=vec3(bP.getOrientationUp())ox=bP.getMaxThrustAlongAxis('hover_engine, booster_engine',{ow:unpack()})ou=0.5*ox[1]/o6;ou=ou>1000000 and fN(ou/1000000,1).." kTons"or fN(ou/1000,1).." Tons"ov=0.5*o7/o6;ov=ov>1000000 and fN(ov/1000000,1).." kTons"or fN(ov/1000,1).." Tons"end;o7=fN(o7/(cj*iI),2).." g"if o6>0.1 then od=cj*o6;od=fN(od/(cj*iI),2).." g"else od="n/a"end;og=fN(og/(cj*iI),2).." g"if iz()==0 or m then local oy=j7(aB+10)local oz=j8(aC+20)local oA=j7(aB+10+aA/1.25)local nc=25;local oB=bN(1/aT)if oo<oB then oq=oq+a.getActionUpdateDeltaTime()oo=oo+1 else om=1/(oq/oB)table.insert(op,om)oo,oq=0,0 end;on=0;for dN,dz in pairs(op)do on=on+dz end;if#op>0 then on=bN(on/#op)end;if#op>29 then table.remove(op,1)end;jU[#jU+1]="<g class='txtstart size14 bright'>"jU[#jU+1]=gF(oy,oz,dm("BrkTime: %s",iF(of)))jU[#jU+1]=gF(oA,oz,dm("Trip: %.2f km",j1))jU[#jU+1]=gF(oy,oz+nc,dm("Lifetime: %.2f kSU",bp/200000))jU[#jU+1]=gF(oA,oz+nc,dm("BrkDist: %s",iE(oe)))jU[#jU+1]=gF(oy,oz+nc*2,"Trip Time: "..iF(j2))jU[#jU+1]=gF(oA,oz+nc*2,"Total Time: "..iF(bq))jU[#jU+1]=gF(oy,oz+nc*3,dm("Mass: %s",f5))jU[#jU+1]=gF(oA,oz+nc*3,dm("Safe Brake Mass: %s",ov))jU[#jU+1]=gF(oy,oz+nc*4,dm("Max Thrust: %s",og))jU[#jU+1]=gF(oA,oz+nc*4,dm("Safe Atmo Mass: %s",os))jU[#jU+1]=gF(oy,oz+nc*5,dm("Max Brake: %s",o7))jU[#jU+1]=gF(oA,oz+nc*5,dm("Safe Space Mass: %s",ot))jU[#jU+1]=gF(oA,oz+nc*6,dm("Safe Hover Mass: %s",ou))jU[#jU+1]=gF(oy,oz+nc*6,dm("Influence: %s",kt.name))jU[#jU+1]=gF(oy,oz+nc*7,dm("Set Max Speed: %s",bN(a0*3.6+0.5)))jU[#jU+1]=gF(oA,oz+nc*7,dm("Actual Max Speed: %s",bN(df*3.6+0.5)))jU[#jU+1]=gF(oy,oz+nc*8,dm("Friction Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))jU[#jU+1]=gF(oA,oz+nc*8,dm("FPS (Avg): %s (%s)",bN(om),on))end;jU[#jU+1]="</g></g>"return jU end;function nS.DrawWarnings(jU)return la(jU)end;function nS.DisplayOrbitScreen(jU)return lI(jU)end;function nS.DisplayMessage(jU,ll)if ll~="empty"then local hA=310;for ln in string.gmatch(ll,"([^\n]+)")do hA=hA+35;jU[#jU+1]=gF("50%",hA,ln,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;function nS.DrawDeadZone(jU)jU[#jU+1]=dm([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;function nS.UpdatePipe()if cg then iS=""return end;n0()end;function nS.DrawSettings(jU)local hz=j7(640)local hA=j8(200)jU[#jU+1]=[[<g class="pbright txtvspd txtstart">]]local hQ=0;for dN,dz in pairs(iR)do hQ=hQ+1;jU[#jU+1]=gF(hz,hA,dN..": "..dz.get())hA=hA+20;if hQ%12==0 then hz=hz+j7(350)hA=j8(200)end end;jU[#jU+1]=gF(j7(640),j8(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jU[#jU+1]="</g>"return jU end;local i6=j8(125)local i5=j7(1225)function nS.DrawRadarInfo()i7=cu.GetRadarHud(i5,i6,ax,ay)if i7 then gQ=true end end;function nS.DrawTanks()if at~=0 and au~=0 then jc=gF(at,au,"","txtstart pdim txtfuel")jv=au;jw(at,"Atmospheric ","ATMO",cl,js,jt)jw(at,"Space Fuel T","SPACE",cm,jq,jr)jw(at,"Rocket Fuel ","ROCKET",cn,jo,jp)end end;function nS.DrawShield()local ii=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oC=bP.getPvPTimer()local oD=shield.getResistances()local oE="A: "..10+oD[1]*100 .."% / E: "..10+oD[2]*100 .."% / K:"..10+oD[3]*100 .."% / T: "..10+oD[4]*100 .."%"local hz,hA=av-60,aw+30;local jM=bN(di*2.55)local jN=dm("rgb(%d,%d,%d)",255-jM,jM,0)local jO=""jd=gF(hz,hA,"","txtmid pdim txtfuel")if di<10 and ii~="Shield Disabled"then jO="red "end;oC=oC>0 and"   PvPTime: "..iF(oC)or""jd=jd..dm([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hz,hA,jN,di*2,hz,hA,hz+2,hA+10,di,oC)jd=jd..gF(hz,hA-5,ii,jO.."txtstart pbright txtbig")jd=jd..gF(hz,hA+30,oE,jO.."txtstart pbright txtsmall")end;function nS.hudtick()if not kt then return end;local function oF(jU)local jQ=bN(dn(dd/(ac/4)*255,0,255))jU[#jU+1]=dm("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(iX+0.5)+jQ,bN(iY+0.5)-jQ,bN(iZ+0.5)-jQ)end;local function oG()if c2 then for dS,dz in pairs(iJ)do if dz.hovered then if not dz.drawCondition or dz.drawCondition(dz)then dz.toggleFunction(dz)end;dz.hovered=false end end;for dS,dz in pairs(iM)do if dz.hovered then bK=dz.label;dz.hovered=false end end;c2=false end end;local function oH()local function oI(oJ,oK,hz,hA,nb,nc)if oJ>=hz and oJ<=hz+nb and oK>=hA and oK<=hA+nc then return true else return false end end;local hz=c9+ac/2;local hA=ca+ad/2;for dS,dz in pairs(iJ)do dz.hovered=oI(hz,hA,dz.x,dz.y,dz.width,dz.height)end;for dS,dz in pairs(iM)do dz.hovered=oI(hz,hA,dz.x,dz.y,dz.width,dz.height)end;if d0 then local mQ=false;for dS,eF in ipairs(nO)do if eF.hovered then mQ=true;break end end;if nL.hovered then mQ=true end;d0=mQ else d0=nL.hovered;if not d0 then d1=bn end end end;local function oL(jU)if not bK or bK==""then bK="INFO"end;if w then for dN,dz in pairs(iM)do local jO="dim brightstroke"local oM=0.2;if bK==dN then jO="pbright dimstroke"oM=0.6 end;local oN=""if dz.hovered then oM=0.8;oN=";stroke:white"end;jU[#jU+1]=dm([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dz.width,dz.height,dz.x,dz.y,jO,oM,oN)jU[#jU+1]=gF(dz.x+dz.width/2,dz.y+dz.height/2+5,dz.label,"txt txtmid pdim")end end end;local function oO(jU)local function oP(jU,oQ,hover,hz,hA,oR,oS,oT,oU,oV,oW,nP)if type(oV)=="function"then oV=oV(nP)end;if type(oW)=="function"then oW=oW(nP)end;jU[#jU+1]=dm("<rect x='%f' y='%f' width='%f' height='%f' fill='",hz,hA,oR,oS)if oQ then jU[#jU+1]=dm("%s'",oT)else jU[#jU+1]=oU end;if hover then jU[#jU+1]=dm(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else jU[#jU+1]=dm(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fN(af*0.5,0),fN(ag*0.5,0),fN(ah*0.5,0))end;jU[#jU+1]=" rx='5'></rect>"jU[#jU+1]=dm("<text x='%f' y='%f' font-size='24' fill='",hz+oR/2,hA+oS/2+5)if oQ then jU[#jU+1]="black"else jU[#jU+1]="white"end;jU[#jU+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oQ then jU[#jU+1]=dm("%s</text>",oV)else jU[#jU+1]=dm("%s</text>",oW)end end;local oX=dm("rgb(%d,%d,%d)'",fN(af*0.1,0),fN(ag*0.1,0),fN(ah*0.1,0))local oY=dm("rgb(%d,%d,%d)",fN(af*0.8,0),fN(ag*0.8,0),fN(ah*0.8,0))local oZ=oP;for dS,dz in pairs(iJ)do local ng=dz.disableName;local nf=dz.enableName;if type(ng)=="function"then ng=ng(dz)end;if type(nf)=="function"then nf=nf(dz)end;if not dz.drawCondition or dz.drawCondition(dz)then oZ(jU,dz.toggleVar(dz),dz.hovered,dz.x,dz.y,dz.width,dz.height,oY,oX,ng,nf,dz)end end end;local o_=fN(ac/2,0)local p0=fN(ad/2,0)local jU={}if p1 then jU[#jU+1]=p1 end;cr.HUDPrologue(jU)if w then cr.UpdateHud(jU)else if A then cr.DrawVerticalSpeed(jU,ci)end;cr.DrawWarnings(jU)end;if iQ and iR~="none"then cr.DrawSettings(jU)end;if cu then cr.DrawRadarInfo()else i7=""end;cr.HUDEpilogue(jU)jU[#jU+1]=dm([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ac,ad)if c3~="empty"then cr.DisplayMessage(jU,c3)end;if iz()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(jU)end end;oL(jU)if iB()==0 then if iz()==1 and c1 then if not p2 then oH()oO(jU)end;if not cx and not cy then local p3=table.concat(jU,"")jU={}jU[#jU+1]=dm("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jU[#jU+1]=p3;jU[#jU+1]="</body>"cx=true;jU[#jU+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local p3=table.concat(jU,"")jU={}jU[#jU+1]=dm("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jU[#jU+1]=p3;jU[#jU+1]="</body>"end;if not cx then jU[#jU+1]=dm([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],o_,p0,c9,ca)end else oG()end else if not c1 and iz()==0 then oG()if dd>az then if v then oF(jU)end end elseif c1 and(not p2 or not j)then oH()oO(jU)end;jU[#jU+1]=dm([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],o_,p0,c9,ca)end;jU[#jU+1]=[[</svg></body>]]p4=table.concat(jU,"")end;function nS.TenthTick()local function p5()local p6=a.createData;local p7=a.createWidget;p8=a.createWidgetPanel("Interplanetary Helper")p9=p7(p8,"value")pa=p6('{"label": "Target Planet", "value": "N/A", "unit":""}')fL(pa,p9)pb=p7(p8,"value")pc=p6('{"label": "distance", "value": "N/A", "unit":""}')fL(pc,pb)ge=p7(p8,"value")gd=p6('{"label": "Travel Time", "value": "N/A", "unit":""}')fL(gd,ge)gg=p7(p8,"value")gf=p6('{"label": "Target Altitude", "value": "N/A", "unit":""}')fL(gf,gg)pd=p7(p8,"value")pe=p6('{"label": "Space Engine", "value": "N/A", "unit":""}')fL(pe,pd)pf=p7(p8,"value")pg=p6('{"label": "End Speed", "value": "N/A", "unit":""}')g8=p7(p8,"value")g7=p6('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g6=p7(p8,"value")g5=p6('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g4=p7(p8,"value")g3=p6('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g2=p7(p8,"value")g1=p6('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ga=p7(p8,"value")g9=p6('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fL(pg,pf)fL(g7,g8)fL(g5,g6)fL(g3,g4)fL(g1,g2)fL(g9,ga)end end;local function ph()gE(p8)p8=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bl~="None"then if p8==nil then p5()end;if bl~=nil then local mr;local pi=fY~=nil;local pj=b5 and bh*3.6 or 0;fK(pa,'{"label": "Target", "value": "'..bl..'", "unit":""}')if pi and not b5 then mr=(cO-fY.position):len()else mr=(bm-cO):len()end;if not b6 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)iU,iV=ct.GetAutopilotBrakeDistanceAndTime(a0)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)iU,iV=ct.GetAutopilotTBBrakeDistanceAndTime(a0)end;local ll=iE(mr)fK(pc,'{"label": "distance", "value": "'..ll..'"}')fK(gd,'{"label": "Travel Time", "value": "'..iF(lq)..'", "unit":""}')ll=iE(c6)fK(g7,'{"label": "Cur Brake distance", "value": "'..ll..'"}')fK(g5,'{"label": "Cur Brake Time", "value": "'..iF(c7)..'", "unit":""}')ll=iE(iU)fK(g3,'{"label": "Max Brake distance", "value": "'..ll..'"}')fK(g1,'{"label": "Max Brake Time", "value": "'..iF(iV)..'", "unit":""}')fK(pg,'{"label": "End Speed", "value": "'..dm("%.0fkph",pj)..'", "unit":""}')ll=iE(gh)fK(gf,'{"label": "High Orbit", "value": "'..ll..'"}')fK(pe,'{"label": "Space Engine Alt", "value": "'..c8.spaceEngineMinAltitude..'m"}')if cg and not pk then a.removeDataFromWidget(g1,g2)a.removeDataFromWidget(pg,pf)a.removeDataFromWidget(g3,g4)a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)pk=true;if not cR and t and(b7 or ba or ce)then ct.cmdThrottle(1)b2=false;bV=false end end;if not cg and pk then if fK(g1,g2)==1 then fL(g1,g2)end;if fK(g1,pf)==1 then fL(pg,pf)end;if fK(g3,g4)==1 then fL(g3,g4)end;if fK(g5,g6)==1 then fL(g5,g6)end;if fK(g7,g8)==1 then fL(g7,g8)end;if fK(g9,ga)==1 then fL(g9,ga)end;pk=false end end else ph()end;if warpdrive~=nil then local pl=ix(warpdrive.getWidgetData())if pl.destination~="Unknown"and pl.distance>400000 then if not j6 then warpdrive.showWidget()j6=true end elseif j6 then warpdrive.hideWidget()j6=false end end end;function nS.OneSecondTick()local function pm()local jG=bM()local l6=cL;local pn=jG-j4;if l6>1.38889 then l6=l6/1000;local po=l6*(jG-j4)bp=bp+po;j1=j1+po end;j2=j2+pn;bq=bq+pn;j4=jG end;local function pp(jU)local pq=0;local pr=iH;local ps=0;local pt=0;local pu=0;local jM=0;local jN=""local pv=b.getElementHitPointsById;local pw=b.getElementMaxHitPointsById;local px={}for dN in pairs(iG)do local py=0;local pz=0;pz=pw(iG[dN])py=pv(iG[dN])ps=ps+py;if py+1<pz then if py==0 then pu=pu+1 else pt=pt+1 end;if j5 and#px==0 then fP=vec3(b.getElementPositionById(iG[dN]))local hz=fP.x;local hA=fP.y;local hB=fP.z;table.insert(px,b.spawnArrowSticker(hz,hA,hB+1,"down"))table.insert(px,b.spawnArrowSticker(hz,hA,hB+1,"down"))b.rotateSticker(px[2],0,0,90)table.insert(px,b.spawnArrowSticker(hz+1,hA,hB,"north"))table.insert(px,b.spawnArrowSticker(hz+1,hA,hB,"north"))b.rotateSticker(px[4],90,90,0)table.insert(px,b.spawnArrowSticker(hz-1,hA,hB,"south"))table.insert(px,b.spawnArrowSticker(hz-1,hA,hB,"south"))b.rotateSticker(px[6],90,-90,0)table.insert(px,b.spawnArrowSticker(hz,hA-1,hB,"east"))table.insert(px,b.spawnArrowSticker(hz,hA-1,hB,"east"))b.rotateSticker(px[8],90,0,90)table.insert(px,b.spawnArrowSticker(hz,hA+1,hB,"west"))table.insert(px,b.spawnArrowSticker(hz,hA+1,hB,"west"))b.rotateSticker(px[10],-90,0,90)table.insert(px,iG[dN])end elseif j5 and#px>0 and px[11]==iG[dN]then for jF in pairs(px)do b.deleteSticker(px[jF])end;px={}end end;pq=fN(ps/pr*100,2)if pu>0 or pt>0 then jU[#jU+1]=gF(0,0,"","pbright txt")jM=bN(pq*2.55)jN=dm("rgb(%d,%d,%d)",255-jM,jM,0)jU[#jU+1]=gF("50%",1035,"Elemental Integrity: "..pq.."%","txtbig txtmid","fill:"..jN)if pu>0 then jU[#jU+1]=gF("50%",1055,"Disabled Modules: "..pu.." Damaged Modules: "..pt,"txtbig txtmid","fill:"..jN)elseif pt>0 then jU[#jU+1]=gF("50%",1055,"Damaged Modules: "..pt,"txtbig txtmid","fill:"..jN)end end end;local function pA()if iw then if iW==nil and(hd~=nil or bo)then _autoconf.displayCategoryPanel(iw,weapon_size,"Weapons","weapon",true)iW=_autoconf.panels[_autoconf.panels_size]elseif iW~=nil and hd==nil and not bo then gE(iW)iW=nil end end end;local jU={}pm()if s then pp(jU)end;pA()cr.UpdatePipe()cr.ExtraData(jU)j3=table.concat(jU,"")end;function nS.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function nS.MsgTick()local jU={}cr.DisplayMessage(jU,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function nS.ButtonSetup()nr()nw()iJ=iK end;if pB then for dN,dz in pairs(pB)do nS[dN]=dz end end;return nS end;local function pC(d,b,c,e,vBooster,hover,pD,antigrav,dbHud_1,f0,bN,bO,iz,eW,bM,dn,iA,fK,iB,dq,fN,fM,iC,dr,iE,iF,pE,ix,dk)local a=DUSystem;local bP=DUConstruct;local pF={}local pG=false;local pH=0;local pI=0;local pJ=0;local pK=bM()local pL=0;local pM=0;local pN=0;local pO=0;local pP=false;local pQ=false;local pR=false;local pS=nil;local pT=0;local iT=55;local pU=nil;local pV=false;local pW=false;local pX=false;local pY=0;local pZ=0;local p_=0;local q0=0;local q1=0;local q2={VectorToTarget=false}local q3=vec3(bP.getWorldOrientationUp())local q4=nil;local q5=0;local q6=-1;local q7=-1;local q8=false;local q9=false;local qa=0;local qb=false;local qc=false;local qd=false;local qe=false;local qf=""local qg=false;local qh=false;local qi=""local qj=false;local qk=0;local ql=0;local function qm()return bP.isInPvPZone()~=1,f0(bP.getDistanceToSafeZone())end;local function qn(ki)local qo=bh;if not b5 then qo=0 end;local qp=bu;if cg then if bw and bw>0 then qp=bw else return 0,0 end end;return cp.computeDistanceAndTime(ki,qo,cj,0,0,qp-bj*cj)end;local function qq(ki)local qo=bh;if not b5 then qo=0 end;return cp.computeDistanceAndTime(ki,qo,cj,d:maxForceForward(),a2,bu-bj*cj)end;local function qr(qs,qt,qu)qt=qt:project_on_plane(qs)qu=qu:project_on_plane(qs)return eW(qt:cross(qu):dot(qs),qt:dot(qu))end;local qv=-1;local qw=-1;local function qx()local function qy()local qz=-1;local qA=-1;if vBooster then qz=vBooster.getDistance()if qz>-1 and qz<0.01 then qz=qv else qv=qz end end;if hover then qA=hover.getDistance()if qA>-1 and qA<0.01 then qA=qw else qw=qA end end;if qz~=-1 and qA~=-1 then if qz<qA then return qz else return qA end elseif qz~=-1 then return qz elseif qA~=-1 then return qA else return-1 end end;local qB=qy()local qC=-1;if antigrav and antigrav.isActive()==1 and not r and cL<iT then local qD=f0(ci-antigrav.getBaseAltitude())if qD<50 then return qD end end;if pD then qC=pD.raycast().distance;if qC==0 then qC=-1 end end;if qB~=-1 and qC~=-1 then if qB<qC then return qB else return qC end elseif qB~=-1 then return qB else return qC end end;local function qE(kt,eN,qF)local function qG(qH,dZ)local eT=vec3(dZ)if qH.id==0 then return setmetatable({latitude=eT.x,longitude=eT.y,altitude=eT.z,id=0,systemId=qH.systemId},e0)end;local eU=eT-qH.center;local cb=eU:len()local e5=cb-qH.radius;local e3=0;local e4=0;if not dr(cb,0)then local eV=eW(eU.y,eU.x)e4=eV>=0 and eV or 2*math.pi+eV;e3=math.pi/2-math.acos(eU.z/cb)end;return setmetatable({latitude=math.deg(e3),longitude=math.deg(e4),altitude=e5,id=qH.id,systemId=qH.systemId},e0)end;local qI=qG(kt,eN)qI="::pos{"..qI.systemId..","..qI.id..","..qI.latitude..","..qI.longitude..","..qI.altitude.."}"if qF then return qI else qd=qI;return true end end;local function qJ(qK,qL,qM)local function qN(qK,ew)qK=vec3(qK)ew=vec3(ew):normalize()local dI=qK*ew;return dI.x+dI.y+dI.z end;local qO=0.001;local qP=1;if not cg or not cA or cf~=-1 or cL<iT then if qM==nil then qM=aS end;if qL==nil then qL=qO end;qK=vec3(qK):normalize()local qQ=vec3()-qK;local qR=-qN(qQ,bP.getWorldOrientationRight())*qP;local qS=-qN(qQ,bP.getWorldOrientationUp())*qP;if pI==0 then pI=qR/2 end;if pJ==0 then pJ=qS/2 end;if f0(qR)<0.1 then pZ=pZ-qR*2 else pZ=pZ-(qR+(qR-pI)*qM)end;if f0(qS)<0.1 then pY=pY+qS*2 else pY=pY+qS+(qS-pJ)*qM end;pI=qR;pJ=qS;if f0(qR)<qL and f0(qS)<qL then return true end;return false elseif cA and cf==-1 then qK=cK;if qM==nil then qM=aS end;if qL==nil then qL=qO end;qK=vec3(qK):normalize()local qQ=cH-qK;local qR=-qN(qQ,bP.getWorldOrientationRight())*qP;local qS=-qN(qQ,bP.getWorldOrientationUp())*qP;if pI==0 then pI=qR/2 end;if pJ==0 then pJ=qS/2 end;if f0(qR)<0.1 then pZ=pZ-qR*5 else pZ=pZ-(qR+(qR-pI)*qM)end;if f0(qS)<0.1 then pY=pY+qS*5 else pY=pY+qS+(qS-pJ)*qM end;pI=qR;pJ=qS;if f0(qR)<qL and f0(qS)<qL then return true end;return false end end;function pF.clearAll()bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"b3=false;b4=false;cX=nil;b7=false;ba=false;b8=false;b9=false;bb=false;c0=false;pW=false;cc=false;cd=false;pX=false;cz=q;bs=false;b6=false;ck=false;bv=nil;bB=false;db=false;dc=nil;ce=false end;function pF.GetAutopilotBrakeDistanceAndTime(ki)return qn(ki)end;function pF.GetAutopilotTBBrakeDistanceAndTime(ki)return qq(ki)end;function pF.showWayPoint(kt,eN,qF)return qE(kt,eN,qF)end;function pF.APTick()local qT=a.getMouseWheel()if qT>0 then ct.changeSpd()elseif qT<0 then ct.changeSpd(true)else pV=true end;qa=iB()if qd then a.setWaypoint(qd)qd=false end;if qg then antigrav.setTargetAltitude(qg)qg=false end;if qe then fK(qe,qf)qe=false;qf=""end;if q7~=-1 then ct.cmdCruise(q7,q8)q8=false;q7=-1 end;if q4~=nil then if iA:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iA:getTargetSpeed(axisCommandId.longitudinal)~=q4 then iA:setTargetSpeedCommand(axisCommandId.longitudinal,q4)else q4=nil end end;if q6~=-1 then ct.cmdThrottle(q6,q8)q8=false;q6=-1 end;if q9 then cv.landingGear(q9)q9=false end;if qh then ct.ToggleAutopilot()end end;function pF.ToggleIntoOrbit()cE=false;pN=nil;pO=nil;pT=0;pQ=false;if not cg then if bB then fM("orOff","AP")bB=false;pP=false;pS=nil;cz=q;if b7 then b7=false;b9=false end;q2.VectorToTarget=false;q2.AutopilotAlign=false;pR=false elseif cY then fM("orOn","AP")bB=true;cz=true;if pS==nil then pS=kt end;if b7 then b7=false;b9=false end else dk("Unable to engage auto-orbit, not near a planet")end else bB=false;pP=false;pS=nil;cz=q;if b7 then b7=false end;q2.VectorToTarget=false;q2.AutopilotAlign=false;pR=false end end;function pF.ToggleVerticalTakeoff()b7=false;if bb then qU=true;ba=false;b9=false;b8=true;cz=true;b_=0;if cg and cf==-1 then b8=false;b7=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q7=bN(cB)end else cE=false;bo=false;d.control.retractLandingGears()iA:setTargetGroundAltitude(Y)b2="VTO Takeoff"end;bb=not bb end;function pF.checkLOS(qK)local lo,eL,eM=co:getPlanetarySystem(0):castIntersections(cO,qK,function(eu)if eu.noAtmosphericDensityAltitude>0 then return eu.radius+eu.noAtmosphericDensityAltitude else return eu.radius+eu.surfaceMaxAltitude*1.5 end end)local lp=eL;if eM~=nil and eL~=nil then lp=math.min(eM,eL)end;if lp~=nil then return lo,lp else return nil,nil end end;local function qV(qW,qX)if qX then b_=0;iA:updateCommandFromActionStop(axisCommandId.vertical,qX)if bD then iA:activateGroundEngineAltitudeStabilization(qY)de=true end else b_=b_+qW;iA:deactivateGroundEngineAltitudeStabilization()iA:updateCommandFromActionStart(axisCommandId.vertical,qW)end end;function pF.vertical(qW,qX)qV(qW,qX)end;function pF.ToggleAutopilot()local function qZ(bz)cZ=false;bs=not bs;if bs then b6=false;if not b7 and not bz then ct.ToggleAltitudeHold()end end;ls="Proceeding to Waypoint"end;local function q_(gq)if gq then for M,dN in pairs(cU)do if dN.name and dN.name==gq then return M end end else return 0 end end;local r0=false;if bQ-pM<1.5 and cg then if not cG then if cg then bc=kt.spaceEngineMinAltitude-0.01*kt.noAtmosphericDensityAltitude;fM("11","EP")pM=-1;if b5 or bs or bB then return end else dk("No space engines detected, Orbital Hop not supported")return end elseif kt.hasAtmosphere then if cg then bc=kt.noAtmosphericDensityAltitude+U;fM("orH","OH")end;pM=-1;if b5 or bs or bB then return end end else pM=bQ end;r1=false;dh=false;if(bn>0 or#bH>0)and not b5 and not bs and not cd and not bB then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then dk("WARNING: Heavy Loads may affect autopilot performance.")end;if#bH>0 and not ce then bn=q_(bH[1])cs.UpdateAutopilotTarget()dk("Route Autopilot in Progress")local qQ=fY.position-cO;local r2=qQ:project_on_plane(cM):len()if r2>50000 and fY.planetname==kt.name then r0=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c8,bm)if fY~=nil then if fY.agg and not r and antigrav then if not cQ then ct.ToggleAntigrav()end;bx=fY.agg end;bv=nil;bz=fY.planetname=="Space"if bz then fM("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b5=true end elseif kt.name==fY.planetname then qU=true;if cg then if not bs then fM("vtt","AP")qZ(bz)if r0 then bc=kt.noAtmosphericDensityAltitude+U end end else fM("apOn","AP")if not(c8.name==kt.name and ci<gh*1.5)then cE=false;b5=true elseif not cg then if bB then ct.ToggleIntoOrbit()end;cD=(kt.noAtmosphericDensityAltitude>0 and kt.noAtmosphericDensityAltitude or kt.surfaceMaxAltitude)+U;pR=true;q2.AutopilotAlign=true;q2.VectorToTarget=true;pP=false;if not bB then ct.ToggleIntoOrbit()end end end else fM("apP","AP")b3=false;b4=false;if cg then cd=true;ct.ToggleAltitudeHold()else b5=true end end elseif not cg then if fY==nil and(c8.name==kt.name and cY)and not bB then r3=false;cE=false;pP=false;cD=(kt.noAtmosphericDensityAltitude>0 and kt.noAtmosphericDensityAltitude or kt.surfaceMaxAltitude)+U;pR=true;ct.ToggleIntoOrbit()else fM("apP","AP")b5=true;b3=false;b4=false;be=false;c0=false;b7=false;b8=false;ba=false;b9=false;pW=false;bv=nil;r3=false end else fM("apP","AP")cd=true;ct.ToggleAltitudeHold()end;qh=false else fM("apOff","AP")ct.ResetAutopilots(1)if qh==2 then qh=true end end end;function pF.routeWP(r4,r5,r6)if r6 then if r6==1 then bH={}bH=iC(bH,bG)if#bH>0 then dk("Route Loaded")else dk("No Saved Route found on Databank")end;return bH else bG={}bG=iC(bG,bH)dk("Route Saved")pE()return end end;if r4 then return bH end;if r5 then bH={}dk("Current Route Cleared")else bH[#bH+1]=fY.name;dk("Added "..fY.name.." to route. ")end;return bH end;function pF.cmdThrottle(dO,r7)if iA:getAxisCommandType(0)~=axisCommandType.byThrottle and not r7 then d.control.cancelCurrentControlMasterMode()end;iA:setThrottleCommand(axisCommandId.longitudinal,dO)bR=dn(fN(dO*100,0)/100,-1,1)q4=nil end;function pF.cmdCruise(dO,r7)if iA:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r7 then d.control.cancelCurrentControlMasterMode()end;iA:setTargetSpeedCommand(axisCommandId.longitudinal,dO)q4=dO end;function pF.ToggleLockPitch()if bv==nil then fM("lkPOn","LP")if not c1 then bv=cS else bv=r8 end;b9=false;b7=false;b8=false else fM("lkPOff","LP")bv=nil end end;function pF.ToggleAltitudeHold()if bQ-pL<1.5 then if kt.hasAtmosphere then if cg then bc=kt.spaceEngineMinAltitude-0.01*kt.noAtmosphericDensityAltitude;fM("11","EP")else if cY then bc=kt.noAtmosphericDensityAltitude+U;cD=bc;pR=true;if not bB then ct.ToggleIntoOrbit()end;pP=true end end;pL=-1;if b7 or bB or bb then return end end else pL=bQ end;if cY and not cg and cf==-1 then cD=ci;pR=true;pP=true;ct.ToggleIntoOrbit()if bB then pL=bQ else pL=0 end;return end;b7=not b7;b8=false;ba=false;dh=false;if b7 then b5=false;b4=false;b3=false;c0=false;cz=true;bv=nil;cE=false;if cf~=-1 then if cL<20 then if bo then cv.landingGear()end;fM("lfs","LS")b9=true;if cg then bc=ci+X else bc=kt.surfaceMaxAltitude+100 end;b2="ATO Hold"iA:setTargetGroundAltitude(Y)if b1 and cP then ct.ToggleVerticalTakeoff()end end else fM("altOn","AH")b9=false;if pL>-1 then if cY then bc=ci end end;if bb then ct.ToggleVerticalTakeoff()end end;if cQ and not r then local r9=antigrav.getBaseAltitude()if bs and fY.agg and fY.agg>ci then bc=fY.agg elseif b9 then bc=r9 end;if f0(ci-r9)<100 and cL<20 then bc=r9;b2="AGG Hold"q6=0 end end;if cd then bc=200000 end else fM("altOff","AH")if bB then ct.ToggleIntoOrbit()end;if bb then ct.ToggleVerticalTakeoff()end;cz=q;b9=false;bs=false;pL=0 end end;function pF.ResetAutopilots(pF)if pF then cd=false;b5=false;be=false;pW=false;bc=ci;r1=false;db=false;bi="Aligning"end;bs=false;b9=false;ba=false;dh=false;b4=false;b8=false;dc=nil;ra=false;cX=nil;db=false;if not cQ then b7=false;bv=nil end;if bb then ct.ToggleVerticalTakeoff()end;if bB then ct.ToggleIntoOrbit()end;cz=q;cc=false;ce=false;b_=0 end;function pF.BrakeToggle(rb)if not b2 then if rb then b2=rb else b2=true end else b2=false end;if b8 then b8=false;cz=q;db=false end;if b2 then fM("bkOn","B",1)ct.ResetAutopilots()else fM("bkOff","B",1)end end;function pF.BeginReentry()if ba then dk("Re-Entry cancelled")fM("reOff","RE")ba=false;cz=q;b7=false elseif not kt.hasAtmosphere then dk("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c4=5 elseif not pX then ba=true;if iA:getAxisCommandType(0)~=rc.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b2=false;dk("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB)fM("par","RE")else ba=true;b7=true;cz=true;b2=false;bc=kt.surfaceMaxAltitude+_;if bc>kt.spaceEngineMinAltitude then bc=kt.spaceEngineMinAltitude-0.01*kt.noAtmosphericDensityAltitude end;local rd=iE(bc)dk("Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..rd)fM("glide","RE")q7=bN(cB)end;b9=false end;function pF.ToggleAntigrav()if antigrav and not r then if cQ then fM("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bx==nil then bx=ci end;if bx<1000 then bx=1000 end;fM("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pF.changeSpd(re)local rf=1;if re then rf=-1 end;if not c1 then if t and not p2 and pV then local rg=bR;bR=fN(dn(bR+rf*aE/100,-1,1),2)if bR>=0 and rg<0 then bR=0;pV=false end elseif p2 then if cg or ba then cB=dn(cB+rf*aE,0,V)elseif b5 then a0=dn(a0+rf*aE/3.6*100,0,df-0.2)end else iA:updateCommandFromActionStart(axisCommandId.longitudinal,rf*aE/10)end else if b5 or bs or cd or bB then d1=d1+1*rf*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not re then rf=1 else rf=nil end;cs.adjustAutopilotTargetIndex(rf)end end end;function pF.TenthTick()local function rh()if not b5 then if fY==nil or fY.planetname~=kt.name then ri=(c8.center-cO):len()else ri=(fY.position-cO):len()end end;local ki=cL;local rj=c.getThrottle()/100;if t then rj=bR end;local rk,rl=cp.computeDistanceAndTime(cL,a0,cj,d:maxForceForward()*rj,a2,0)local c6,c7;if not b6 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(a0)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dS,rm;if not b6 and ki>0 then dS,rm=ct.GetAutopilotBrakeDistanceAndTime(ki)else dS,rm=ct.GetAutopilotTBBrakeDistanceAndTime(ki)end;local rn=0;local ro=0;if bg or not b5 and ki>5 then ro=cp.computeTravelTime(ki,0,ri)elseif c6+rk<ri then rn=ri-(c6+rk)ro=cp.computeTravelTime(a0,0,rn)else local rp=(ri-c6)/rk;rk=ri-c6;rl=rl*rp end;if fY~=nil and fY.planetname==kt.name and not b5 then return ro elseif bf then return rm elseif bg then return ro+rm else return rl+c7+ro end end;local function rq()local o6=b.getGravityIntensity()o6=fN(o6,5)if pU==nil or pU~=o6 then local ki=cJ:len()local rr=bP.getMaxBrake()if rr~=nil and rr>0 and cg then rr=rr/dn(ki/100,0.1,1)rr=rr/ch;if ch>0.10 then bw=rr end end;if rr~=nil and rr>0 then bu=rr end;pU=o6 end end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()ql=0;for M=1,#d3 do ql=ql+bP.getDockedConstructMass(d3[M])end;local rs=0;for M=1,#d2 do rs=rs+bP.getBoardedPlayerMass(d2[M])end;if rs>20000 then ql=ql+rs-20000 end;cV,cW=qm()df=bP.getMaxSpeed()if bl~="None"and(c8 or fY)then lq=rh()end;rq()end;local rt=pid.new(10,0,10.0)local function ru(rv,rw)local ow=vec3()local rx=vec3()if rv==axisCommandId.longitudinal then ow=vec3(bP.getOrientationForward())rx=cH elseif rv==axisCommandId.vertical then ow=vec3(bP.getOrientationUp())rx=q3 elseif rv==axisCommandId.lateral then ow=vec3(bP.getOrientationRight())rx=cI else return vec3()end;local ry=vec3(b.getWorldGravity())local rz=ry:dot(rx)local rA=vec3(bP.getWorldAirFrictionAcceleration())local rB=rA:dot(rx)local rC=cJ:dot(ow)local rD=rw*constants.kph2m;rt:inject(rD-rC)local rE=rt:get()local rF=(rE-rB-rz)*rx;return rF end;local rG=pid.new(10,0,10.0)local function rH(rv,rw)local ow=vec3()local rx=vec3()if rv==axisCommandId.longitudinal then ow=vec3(bP.getOrientationForward())rx=cH elseif rv==axisCommandId.vertical then ow=vec3(bP.getOrientationUp())rx=q3 elseif rv==axisCommandId.lateral then ow=vec3(bP.getOrientationRight())rx=cI else return vec3()end;local ry=vec3(b.getWorldGravity())local rz=ry:dot(rx)local rA=vec3(bP.getWorldAirFrictionAcceleration())local rB=rA:dot(rx)local rC=cJ:dot(ow)local rD=rw*constants.kph2m;rG:inject(rD-rC)local rE=rG:get()local rF=(rE-rB-rz)*rx;return rF end;local function rI(rJ,jX,fU)local rK=rJ:cross(fU):normalize_inplace()local kK=math.acos(dn(rK:dot(-jX),-1,1))*constants.rad2deg;if rK:cross(-jX):dot(fU)<0 then kK=-kK end;return kK end;local function rL()if c_ and not b8 then local eu=c_[1]local hX,hY=c_[2],c_[3]local rM=math.min(hX,hY or hX)local rN=rM/cL;local rO=b9 and(cL<42 or cf~=-1)local rP=b7 or bs or bv or b5;if rP and not rO and(c6*1.5>rM or rN<1)then b2="Collision"bH={}q6=0;if b7 then ct.ToggleAltitudeHold()end;if bv then ct.ToggleLockPitch()end;dk("Autopilot Cancelled due to possible collision")a.print(eu.name.." COLLISION "..iF(rN).." / "..iE(rM,2))ct.ResetAutopilots(1)qU=true;if cg then b8=true end;cz=true end;if rN<11 then cZ=eu.name.." COLLISION "..iF(rN).." / "..iE(rM,2)else cZ=eu.name.." collision "..iF(rN)end;if rN<6 then fM("alarm","AL",2)end else cZ=false end end;local rQ=1;local rR=0;local rS=1;local rT=1;local rU=1;local rV=false;local rW=pid.new(0.1,0,1*0.1)local rX=pid.new(1*0.01,0,5*0.1)local rY=pid.new(aI*0.01,0,aI*0.1)local rZ=pid.new(2*0.01,0,2*0.1)local rX=pid.new(1*0.01,0,5*0.1)local r_=pid.new(2*0.01,0,2*0.1)local s0=pid.new(2*0.01,0,2*0.1)local s1=pid.new(2*0.01,0,2*0.1)local s2=pid.new(2*0.01,0,2*0.1)local s3=pid.new(0.1,0,1)local s4=pid.new(1*0.01,0,1*0.1)function pF.onFlush()if antigrav and not r and not cQ and antigrav.getBaseAltitude()~=bx then qg=bx end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iA:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local s5=dn(bX+pY+a.getControlDeviceForwardInput(),-1,1)local s6=dn(bY+p_+a.getControlDeviceYawInput(),-1,1)local s7=dn(bZ+pZ-a.getControlDeviceLeftRightInput(),-1,1)local s8=b2 and 1 or 0;if cg then cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(kt.center-cO):normalize()end else cM=(kt.center-cO):normalize()end;q3=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()+ql;cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local s9=cT/180*math.pi;local sa=math.cos(s9)local sb=math.sin(s9)cS=rI(cM,cH,cI*sa+q3*sb)local sc=cK:normalize()local sd=f0(cT)local se=utils.sign(cT)local sf=vec3(bP.getWorldAngularVelocity())local sg=s5*aO*cI+s6*aJ*cH+s7*aP*q3;if cz==true and cM:len()>0.01 then local sh=f0(q0-cT)if((b4 or ba or b8 or cc or b7 or bB)and sh>0 or cg and sh<aK and q)and s6==0 and f0(cS)<85 then local si=q0;if not cg then q0=0;si=0 end;rY:inject(si-cT)local sj=rY:get()sg=sg+sj*cH end end;bS=0;ch=bO()cg=false or ci<kt.noAtmosphericDensityAltitude and ch>0.00001;ci=(cO-kt.center):len()-kt.radius;cf=qx()bQ=bM()pK=bQ;if bo and cf>-1 and cf-3<Z then if iA.targetGroundAltitudeActivated then iA:deactivateGroundEngineAltitudeStabilization()end;iA:updateCommandFromActionStart(axisCommandId.vertical,-1)end;if cu then qj=not qj;if qj then cu.UpdateRadar()end;if E then rL()end end;if antigrav then cQ=antigrav.isActive()==1 end;local sk=bQ-pK;local sl=-math.deg(qr(q3,cK,cH))local sm=math.deg(qr(cI,cK,cH))local gj=cM*-1;cA=cg and sl<-N or sl>N or sm<-O or sm>O;local sn=a.getMouseDeltaX()local so=a.getMouseDeltaY()if qk then local sp=bM()-qk;sn=sn*sp/0.016;so=so*sp/0.016 end;qk=bM()if p and not c1 then so=-so end;pZ=0;p_=0;pY=0;local sq=bP.getWorldPosition()kt=fQ:closestBody(sq)sr=cq(kt)fm=sr:orbitalParameters(sq,cK)cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local o6=kt:getGravity(sq):len()*cj;q0=0;local ss=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if qa==0 then if iz()==1 and c1 then if not cx then c9=dn(c9+sn/2,-ac/2,ac/2)ca=dn(ca+so/2,-ad/2,ad/2)end else c9=0;ca=0 end else c9=dn(c9+sn/2,-ac/2,ac/2)ca=dn(ca+so/2,-ad/2,ad/2)dd=dq(c9*c9+ca*ca)if not c1 and iz()==0 then local kT,kU=1,1;if bK=="SCOPE"then kT,kU=d5/90,d5/90 end;if g=="virtual joystick"then if dd>az then pZ=pZ-dn(f0(c9)-az,0,ac/2)*utils.sign(c9)*aG*kT;pY=pY-dn(f0(ca)-az,0,ad/2)*utils.sign(ca)*aH*kU end else c9=0;ca=0;if g=="mouse"then pY=(-utils.smoothstep(so,-100,100)+0.5)*2*rT;pZ=(-utils.smoothstep(sn,-100,100)+0.5)*2*rU end end end end;local st=cL>27777;if cL>W/3.6 and not cg and not b5 and not st then dk("Space Speed Engine Shutoff reached")q6=0 end;if not st and su then if not b2 then ct.BrakeToggle()end;if b5 then ct.ResetAutopilots(1)end;q6=0 end;su=st;if ch>0.09 then if cL>cB/3.6 and not t and not pG then b2="SpdLmt"pG=true elseif not t and pG then if cL<cB/3.6 then b2=false;pG=false end end end;if b4 then if cc then b2=false;local sv=false;sv=qJ(fY.position-cO,0.1)cz=true;if sv then q7=bN(cB)if(f0(cT)<2 or f0(cS)>85)and cL>=cB/3.6-1 then b2=false;b4=false;if cc~=2 then pX=true end;if cc==true then ce=true end;cc=false;b5=false;ct.BeginReentry()end elseif cg and t then q6=1 end elseif cL>iT then qJ(vec3(cK),0.01)end end;if b3 then if cg then b3=false elseif cL>iT then qJ(-vec3(cK))end end;if not b4 and cc and not bB then if not cg then if cc~=2 then pX=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not qh then qh=true end end end;if ce and fY and(ci<bc+250 and ci>bc-250)and f0(cN)<25 and ch>=0.1 and(fY.position-cO):len()>2000+ci then if not qh then qh=true end;ce=false end;if bb then cz=true;local sw=bc;if cN<-30 then dk("Unable to achieve lift. Safety Landing.")b_=0;cz=q;bb=false;b8=true elseif not r and cQ or bc<kt.spaceEngineMinAltitude then if cQ then sw=antigrav.getBaseAltitude()end;if ci<sw-100 then q1=0;b_=15;b2=false elseif cN>0 then b2="VTO Limit"b_=0 elseif cN<-30 then b2="VTO Fall"b_=15 elseif ci>=sw then if cQ then if b5 or bs then ct.ToggleVerticalTakeoff()else b2="VTO Complete"bb=false end;dk("Takeoff complete. Singularity engaged")fM("aggLk","AG")else b2=false;dk("VTO complete. Engaging Horizontal Flight")fM("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then q1=0;b2=false;b_=20 elseif ch<0.08 and cg then b2=false;if cF then q1=0;b_=20 else b_=0;q1=36;q7=3500 end else cz=q;bB=true;cE=false;sx=false;pP=false;pN=nil;pO=nil;if pS==nil then pS=kt end;cD=sw;pR=true;bb=false end end;if q1~=nil then local sy=dn(q1-cS,-O*0.80,O*0.80)rZ:inject(sy)local sz=dn(rZ:get(),-1,1)pY=sz end end;if dh then local gN=dh*(bm-cO)qJ(gN,0.1)end;if bB then local function sA()if not fm.apoapsis or not fm.periapsis then return false end;if fm.periapsis.altitude>=cD*0.99 and fm.apoapsis.altitude>=cD*0.99 and fm.periapsis.altitude<fm.apoapsis.altitude and fm.periapsis.altitude*1.05>=fm.apoapsis.altitude and f0(cD-ci)<1000 then return true else return false end end;local qQ;local sB=false;local sC=iE(cD,4)if pS==nil then pS=kt;if bs then pS=c8 end end;if not pR then cD=bN(pS.radius+pS.surfaceMaxAltitude+U)if pS.hasAtmosphere then cD=bN(pS.radius+pS.noAtmosphericDensityAltitude+U)end;pR=true end;if q2.VectorToTarget and fY then qQ=fY.position-cO end;local sD,sE=cq(pS):escapeAndOrbitalSpeed((cO-pS.center):len()-pS.radius)sE=sE*3.6+1+(K and aZ*sE*3.6 or 0)local sF=cT;if not pP then local sG=false;local sH=false;q6=0;pO=0;cC="Aligning to orbital path - OrbitHeight: "..sC;if q2.VectorToTarget then qJ(qQ:normalize():project_on_plane(cM))sB=cH:dot(qQ:project_on_plane(q3):normalize())>0.95 else qJ(cK)sB=sl<0.5;if cL<150 then sB=true end end;pY=0;pN=0;if cS<=pN+2 and cS>=pN-2 then sG=true else sG=false end;if sF<=pO+2 and sF>=pO-2 then sH=true else sH=false end;if sG and sH and sB then pN=nil;pO=nil;pP=true end else if q2.VectorToTarget then qJ(qQ:normalize():project_on_plane(cM))elseif cL>150 then qJ(cK)end;pY=0;if q2.VectorToTarget and fY then local c6,dS=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bu)if cE and qQ:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pS.noAtmosphericDensityAltitude or lq>fm.timeToPeriapsis and fm.periapsis.altitude<pS.noAtmosphericDensityAltitude or not sA()and fm.eccentricity>0.1 then dk("Re-Aligning Orbit")cE=false end elseif cE or qQ:len()<15000+c6+ci then dk("Orbit complete, proceeding with reentry")fM("orCom","OB")bm=fY.position;pX=true;ce=true;q2.VectorToTarget,q2.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if pQ or fm.periapsis~=nil and fm.apoapsis~=nil and fm.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if fm.apoapsis~=nil or pQ then if(sA()or cE)and not K then if cE then b2=false;q6=0;pN=0;if not q2.VectorToTarget then dk("Orbit complete")fM("orCom","OB")ct.ToggleIntoOrbit()end else pT=pT+1;if pT>=2 then cE=true end end else if sA()then cC="Maintaining "else cC="Adjusting "pQ=true;q7=sE;local sI=cD-ci;rW:inject(sI-cN*dn(utils.smoothstep(2000-sI,-2000,2000)^6*10,1,10))pN=dn(rW:get(),-75,75)end;cC=cC.." - OrbitHeight: "..sC end end else local sJ=2.75;local sK=f0(fN(sD*sJ))local oj=sK%50;if oj>0 then sK=sK-oj+50 end;b2=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sC;pN=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sC;sK=sK*0.75;pN=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sC;sK=sK*0.75;if cN<0 or pQ then pN=utils.map(ci,cD*1.5,cD*1.01,-30,0)else pN=utils.map(ci,cD*0.99,cD*1.5,0,30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sC;pN=-65;local sL=utils.map(cN,-150,-400,1,0.55)sK=sK*sL end;q7=bN(sK)end end;if pN~=nil then local sM=pN-cS;rX:inject(sM)local sN=dn(rX:get(),-0.5,0.5)pY=sN end end;if b5 and not cg and not cc then local function sO(sP,fm)a.print(sP)b4=false;b2=false;bf=false;b5=false;r1=false;bi="Aligning"q6=0;pW=false;dk(sP)fM("apCom","AP")if fm or cc then if fm and gh~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pR=true end;ct.ToggleIntoOrbit()end end;local sQ,sR=bm,false;if fY and fY.planetname~="Space"then be=true;if not r1 then local sS=(fY.position-c8.center):normalize()local sT=sS:project_on_plane((c8.center-cO):normalize()):normalize()local sU=c8.center+sT*(c8.radius+gh)local sV=fY.position+(fY.position-c8.center):normalize()*(gh-c8:getAltitude(fY.position))if(cO-sU):len()<(cO-sV):len()then sQ=sU else sQ=sV;bh=0 end;bm=sQ;ct.showWayPoint(c8,bm)sR=true;r1=true end;bj=0 elseif fY and fY.planetname=="Space"then if not r1 then bj=0;sR=true;be=true;r1=true;sQ=fY.position+(cO-fY.position):normalize()*S;bm=sQ end elseif fY==nil then bj=0;if not r1 then local sS=(cO+cK*100000-c8.center):normalize()local sT=sS:project_on_plane((c8.center-cO):normalize()):normalize()if sT:len()<1 then sS=(cO+cH*100000-c8.center):normalize()sT=sS:project_on_plane((c8.center-cO):normalize()):normalize()end;sQ=c8.center+sT*(c8.radius+gh)bm=sQ;r1=true;sR=true;be=true;ct.showWayPoint(c8,bm)end end;ri=(vec3(sQ)-cO):len()local lo,eL,eM=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(eu)if eu.noAtmosphericDensityAltitude>0 then return eu.radius+eu.noAtmosphericDensityAltitude else return eu.radius+eu.surfaceMaxAltitude*1.5 end end)local lp=eL;if eM~=nil and eL~=nil then lp=math.min(eM,eL)end;if lp~=nil and lp<ri and lo.name==c8.name then ri=lp end;local sv=true;local sW=(c8.center-(cO+vec3(cK):normalize()*ri)):len()-c8.radius;local ll=iE(sW)qe=g9;qf='{"label": "Projected Altitude", "value": "'..ll..'"}'if cL>50 and bd then local qQ=vec3(sQ)-cO;local sX=dn(math.deg(qr(q3,cK:normalize(),qQ:normalize()))*cL/500,-90,90)local sY=dn(math.deg(qr(cI,cK:normalize(),qQ:normalize()))*cL/500,-90,90)if f0(sX)<20 and f0(sY)<20 then sX=sX*2;sY=sY*2 end;if f0(sX)<2 and f0(sY)<2 then sX=sX*2;sY=sY*2 end;local sl=-math.deg(qr(q3,cH,cK:normalize()))local sm=-math.deg(qr(cI,cH,cK:normalize()))r_:inject(sY-sm)local sZ=dn(r_:get(),-1,1)pY=pY+sZ;s0:inject(sX-sl)local s_=dn(s0:get(),-1,1)pZ=pZ+s_;sR=true;if f0(sX)>2 or f0(sY)>2 then if bi~="Adjusting Trajectory"then bi="Adjusting Trajectory"fM("apAdj","AP")end else if bi~="Accelerating"then bi="Accelerating"fM("apAcc","AP")end end elseif bd and cL<=50 then qJ((sQ-cO):normalize())end;if sW<gh*1.5 then bh=cB/3.6;if fY==nil then dS,bh=cq(c8):escapeAndOrbitalSpeed(sW)end end;local c6,c7;if not b6 then c6,c7=qn(cL)else c6,c7=qq(cL)end;if b5 and not bd and not bg and not bf then local lo,lp=ct.checkLOS((bm-cO):normalize())if c8.name~=kt.name then if lo~=nil and c8.name~=lo.name and lp<ri then cZ="Attempting to clear LOS between "..lo.name.." and waypoint."qb=true else qb=false;cZ=false end end end;if not qb then if not bg and not bf and not sR then sv=qJ((sQ-cO):normalize())elseif b6 and(bf or bg)then sv=qJ(-vec3(cK):normalize())end end;if bd then if not pW then b2=false;q6=a1;bR=fN(a1,2)pW=true end;local rj=c.getThrottle()if t then rj=bR end;local t0=99999;local oh=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local t1=dn(cK:dot((sQ-cO):normalize()),0,cL)if t1>0 or oh>0 then t0=cp.computeTravelTime(t1,oh,ri-c6)end;if a0>df then a0=df-0.2 end;if cJ:len()>=a0 or rj==0 and pW or a2/4>t0 then bd=false;if bi~="Cruising"then fM("apCru","AP")bi="Cruising"end;bg=true;q6=0 end;local t2=ri;if t2<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV and not st then if cW<pH and cW>2000 then ct.ResetAutopilots(1)dk("Autopilot cancelled to prevent crossing PvP Line")b2="PvP Prevent"pH=cW else pH=cW;return end end;bd=false;if bi~="Braking"then fM("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cz=true end;q6=0;pW=false end elseif bf then if bi~="Orbiting to Target"then b2="AP Brk"end;if b6 then q6=1;q8=true end;local dS,sE=cq(c8):escapeAndOrbitalSpeed((cO-kt.center):len()-kt.radius)local qQ;if fY then qQ=fY.position-cO end;if fY and fY.planetname=="Space"and cL<50 then if#bH>0 then if not qh then table.remove(bH,1)end;if#bH>0 then b2=false;if not qh then qh=2 end;return end end;sO("Autopilot complete, arrived at space location")b2="Space Arrival"elseif fY and fY.planetname~="Space"and cL<=sE and(fm.apoapsis==nil or fm.periapsis==nil or fm.apoapsis.altitude<=0 or fm.periapsis.altitude<=0)then sO("Autopilot complete, commencing reentry")bm=fY.position;cc=true;ct.showWayPoint(c8,bm)elseif(fY and fY.planetname~="Space"or fY==nil)and fm.periapsis~=nil and fm.periapsis.altitude>0 and fm.eccentricity<1 or bi=="Circularizing"then if bi~="Circularizing"then fM("apCir","AP")bi="Circularizing"end;if cL<=sE then if fY then if cK:normalize():dot(qQ:normalize())>0.4 then if bi~="Orbiting to Target"then fM("apOrb","OB")bi="Orbiting to Target"end;if not r3 then b2=false;ct.showWayPoint(c8,fY.position)r3=true end else sO("Autopilot complete, proceeding with reentry")bm=fY.position;cc=true;ct.showWayPoint(c8,fY.position)r3=false end else sO("Autopilot completed, setting orbit",true)b2=false end end elseif bi=="Circularizing"then sO("Autopilot complete, fixing Orbit",true)end elseif bg then local t2=ri;if t2<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pH and cW>2000 then if not qh then qh=true end;dk("Autopilot cancelled to prevent crossing PvP Line")b2="Prevent PvP"pH=cW else pH=cW;return end end;bd=false;if bi~="Braking"then fM("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cz=true end end;local rj=c.getThrottle()if t then rj=bR end;if rj>0 then bd=true;if bi~="Accelerating"then bi="Accelerating"fM("apAcc","AP")end;bg=false end else if sv then if not be and fY==nil or not be and fY and fY.planetname~="Space"then if not cc then bm=vec3(c8.center)+(gh+c8.radius)*cI;t3=q3;t4=cI end;be=true elseif sv and not qb then bd=true;if bi~="Accelerating"then bi="Accelerating"fM("apAcc","AP")end;if not pW then q6=a1;q8=true;bR=fN(a1,2)pW=true;b2=false end end end end elseif b5 and(fY~=nil and fY.planetname~="Space"and cg)then dk("Autopilot complete, starting reentry")fM("apCom","AP")bm=fY.position;b2=false;bf=false;b5=false;r1=false;bi="Aligning"q6=0;pW=false;b4=true;cc=true;ct.showWayPoint(c8,fY.position)end;if c0 then cz=true;local sY=0;local fo=vec3(DUPlayer.getWorldPosition())local t5=fo-cO;local t6=vec3(t5):project_on(cH):len()local t7=vec3(t5):project_on(cI):len()local cb=dq(t6*t6+t7*t7)qJ(t5:normalize())local mr=40;local t8=cb<mr;local t9=100;local rw=dn((cb-mr)/2,10,t9)pY=0;local sv=f0(pZ)<0.1;if sv and cL<rw and not t8 then b2=false;sY=-20 else b2="Follow"sY=0 end;local ta=0;if f0(sY-cS)>ta then s1:inject(sY-cS)local sZ=s1:get()pY=sZ end end;if b7 or b8 or ba or bs or bv~=nil then local tb=bw;if tb then tb=tb*dn(cL/100,0.1,1)*ch else tb=bu end;if not cg then tb=bu end;q5=cH:project_on_plane(cM):normalize():dot(cK)if q5>100 then c6,c7=cp.computeDistanceAndTime(q5,100,cj,0,0,tb)local tc,dS=cp.computeDistanceAndTime(100,0,cj,0,0,tb*0.55)c6=c6+tc else c6,c7=cp.computeDistanceAndTime(q5,0,cj,0,0,tb*0.55)end;local sI=bc-ci-cN;local td=200+cL;if ba or cc then te=2000+cL end;local tf=1;if b9 then tf=dn(cL/100,0.1,1)end;local sY=(utils.smoothstep(sI,-td,td)-0.5)*2*Q*tf;if not ba and not cc and not bs and cH:dot(cK:normalize())<0.99 then sY=(utils.smoothstep(sI,-td*dn(20-19*ch*10,1,20),td*dn(20-19*ch*10,1,20))-0.5)*2*Q*dn(2-ch*10,1,2)*tf end;if not b7 then sY=0 end;if bv~=nil then if cY and not bB then sY=bv else bv=nil end end;cz=true;local tg=pY;if ba then local th=bN(cB)local ti,tj=cp.computeDistanceAndTime(cL,th/3.6,cj,0,0,bu-kt.gravity*9.8*cj)ti=ti==-1 and 5000 or ti;local r2=ci-(kt.noAtmosphericDensityAltitude+ti)local tk=ci>kt.noAtmosphericDensityAltitude+ti*1.35;if tk then sY=R;if cL<=th/3.6 and cL>th/3.6-10 and f0(cK:normalize():dot(cH))>0.9 and not cR then bV=false;q6=1 end elseif(cR or iA:getTargetSpeed(axisCommandId.longitudinal)~=th)and not tk and not cg then q7=th;q8=true end;if cR then if cL>th/3.6 and not tk then b2="Reentry Limit"if bR>0 then q6=0 end else b2=false end else b2=false end;if cN>0 then b2="Reentry vSpd"end;if not pX then sY=-80;if ci<kt.surfaceMaxAltitude+(kt.atmosphereThickness-kt.surfaceMaxAltitude)*0.25 then dk("PARACHUTE DEPLOYED at "..fN(ci,0))ba=false;b8=true;qU=true;q6=0;sY=0;cz=q end elseif kt.noAtmosphericDensityAltitude>0 and tk then cz=true elseif not tk then if not cg and(cR or iA:getTargetSpeed(axisCommandId.longitudinal)~=th)then q7=th end;if cL<th/3.6+1 then b2=false;pX=false;ba=false;cz=true;q6=1 end end end;if cL>iT and not cd and not bs and not b8 and u then qJ(vec3(cK))end;if cX or(bs or cd)and bn>0 and cg then local qQ;if cX then if type(cX)=="table"then qQ=cX elseif cX<3 and cX>0 then qQ=-cM:cross(cK)*5000 elseif cX>=3 then qQ=cM:cross(cK)*5000 elseif cX<0 then qQ=cK*25000 end elseif fY~=nil then qQ=fY.position-cO else qQ=c8.center-cO end;local sX=math.deg(qr(cM:normalize(),cK,qQ))*2;local mu=math.rad(f0(cT))if cL>aL and cg then local tl=1000+cL;local tm=(utils.smoothstep(sI-cN*10,-tl,tl)-0.5)*2*Q;local tn=dn(90-tm,0,180)q0=dn(sX*2,-tn,tn)local to=sX;sX=dn(dn(sX,-N*0.80,N*0.80)*math.cos(mu)+4*(cS-sY)*math.sin(math.rad(cT)),-N*0.80,N*0.80)local tp=1;if q0~=0 then tp=f0(mu/q0)end;tp=(90-dn(f0(q0-cT),0,90))/90;local tq=sY;if f0(cT)>90 then tq=-tq end;sY=tp*dn(dn(tq*math.cos(mu),-O*0.8,O*0.8)+f0(dn(f0(to)*math.sin(mu),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q0=0;sX=dn(sX,-N*0.80,N*0.80)end;local tr=sl-sX;if cX and f0(tr)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and f0(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fM("180Off","BR")return end;if not cA and cL>aL and cg then s2:inject(tr)local s_=dn(s2:get(),-1,1)pZ=pZ+s_ elseif cg and cf>-1 or cL<aL then qJ(qQ)elseif cA and cg then if(sl<-N or sl>N)and cg then qJ(cK)end;if(sm<-O or sm>O)and cg then sY=dn(cS-sm,cS-O*0.80,cS+O*0.80)end end;if fY~=nil and not cd then local sw=kt:getAltitude(fY.position)local r2=qQ:project_on_plane(cM):len()qU=true;if bc<kt.noAtmosphericDensityAltitude and not cd and not b9 and not ba and(r2<=c6 and qQ:len()<kt.radius)and(cK:project_on_plane(cM):normalize():dot(qQ:project_on_plane(cM):normalize())>0.99 or ls=="Finalizing Approach")then ls="Finalizing Approach"if#bH>0 then if not qh then table.remove(bH,1)end;if#bH>0 then if not qh then qh=2 end;return end end;q6=0;if b7 then ct.ToggleAltitudeHold()bs=true end;b2="AP Finalizing"elseif not b9 then b2=false end;if ls=="Finalizing Approach"and(q5<0.1 or r2<0.1 or ts~=nil and ts<r2)then fM("bklOn","BL")b8=true;db=true;if fY.heading then dc=fY.heading else dc=nil end;bs=false;ls="Proceeding to Waypoint"cZ=false end;ts=r2 end elseif bs and not cg and bc>kt.noAtmosphericDensityAltitude and not(cd or ba)then if fY~=nil and c8.name==kt.name then local qQ=fY.position-cO;local sw=kt:getAltitude(fY.position)local r2=dq(qQ:len()^2-(ci-sw)^2)local tb=bw;if tb then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,tb/2)qU=true;if r2<=c6+cL*sk/2 and cK:project_on_plane(cM):normalize():dot(qQ:project_on_plane(cM):normalize())>0.99 then if kt.hasAtmosphere then b2=false;b4=false;pX=true;cc=false;ce=true;b5=false;ct.BeginReentry()end end;ts=r2 end end end;if not cg and cf==-1 and(b7 and bc>kt.noAtmosphericDensityAltitude)and not(cd or bB or ba)then if not cE and not bB then cD=bc;pR=true;if bs then q2.VectorToTarget=true end;ct.ToggleIntoOrbit()bs=false;pP=true end end;if cA and cg and cf==-1 and cL>aL and ls~="Finalizing Approach"then qJ(cK)sY=dn(cS-sm,cS-O*0.80,cS+O*0.80)end;pY=tg;local qC=-1;if b8 then local tt=aY or 0.05;if not qc then rV=false;if not cR then q6=0 end;if cf==-1 then iA:setTargetGroundAltitude(500)iA:activateGroundEngineAltitudeStabilization(500)end;if not cg then rV=true end;qc=true end;sY=0;local tu=false;local tv=math.abs(q5)if not r and cQ then tu=antigrav.getBaseAltitude()if tu<kt.surfaceMaxAltitude and fY==nil or fY~=nil and kt:getAltitude(fY.position)>tu then tu=false end else tu=false end;if dc then if tv<tt then if cN>-P then b2=false else b2="BL Align BLR"end;if qJ(dc,0.001)then dc=nil;cz=q else pY=0;cz=true end else b2="BL Align Hzn"end;if tu and f0(ci-tu)<250 then b2="AGG Align"end else local tw=false;local tx=30;if tv<10 and ss~=nil and ss>0 then local ty=dn(ch,0.4,2)local tb=bw*dn(cL/100,0.1,1)*ty;local tz=ss*ty+tb-o6;local tA=tb/2-o6;local tB=cL-dq(f0(tA/2)*20/(0.5*cj))*utils.sign(tA)if tB<0 then tB=0 end;local tC;if cL>100 then local tD,dS=cp.computeDistanceAndTime(cL,100,cj,0,0,tb)local tE,dS=cp.computeDistanceAndTime(100,0,cj,0,0,dq(tb))tC=tD+tE else tC=cp.computeDistanceAndTime(cL,0,cj,0,0,dq(tb))end;if tC<20 then b2=false else local tF=0;if tB>100 then local tG,dS=cp.computeDistanceAndTime(tB,100,cj,0,0,tz)local tH,dS=cp.computeDistanceAndTime(100,0,cj,0,0,ss*ty+dq(tb)-o6)tF=tG+tH else tF,dS=cp.computeDistanceAndTime(tB,0,cj,0,0,ss*ty+dq(tb)-o6)end;tF=(tF+15+cL*sk)*1.1;local tI=db and fY~=nil and kt:getAltitude(fY.position)>0 and fY.safe;local sw=nil;if tu and tu<ci then sw=tu elseif tI then sw=kt:getAltitude(fY.position)+250 elseif ci>kt.surfaceMaxAltitude then sw=kt.surfaceMaxAltitude end;if c_ then local tJ=kt:getAltitude(c_[1].center)if sw then if tJ>sw then sw=tJ end else sw=tJ end end;if sw~=nil then local tK=ci-sw;tw=true;if tK<=tF or tF==-1 or tv>tt and db then if sw==kt.surfaceMaxAltitude and cN<-P then b2="BL Stop BLR"elseif tv>tt and db then b2="BL AP Hzn"else b2="BL Stop Dist"end else b2=false end end end end;qC=cf;if qC>-1 then b2=false;if not tu and not bo then q9=true;iA:setTargetGroundAltitude(Z)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qC-3<Z and(bD or cL==0)then b8=false;b7=false;b_=0;qV(0,1)b2="BL Complete"cz=q;db=false;qc=false else if cN<-5 or tv>tt*10 then qV(0,1)b2="BL Slowing"else b2=false;qV(-1)end end elseif not tw then if qU and cK:normalize():dot(-gj)<0.999 then b2="BL Strong"qJ()elseif tv>10 or tv>tt and db then b2="BL hSpd"elseif cN<-P then b2="BL BLR"qV(0,1)else qV(-1)b2=false end end end else qc=false end;if b9 or cd then local lo,eM,eL;if bm~=nil then lo,eM,eL=co:getPlanetarySystem(0):castIntersections(cO,(bm-cO):normalize(),function(eu)if eu.noAtmosphericDensityAltitude>0 then return eu.radius+eu.noAtmosphericDensityAltitude else return eu.radius+eu.surfaceMaxAltitude*1.5 end end)end;if lo~=nil then if lo.name~=c8.name and not cg then cZ="Clearing LOS between "..lo.name.." and waypoint."end end;if cQ and not cd then if ci>=bc-50 and cL>iT then b9=false;if not b5 and not bs then b2="ATO Agg Arrive"q6=0 end end elseif f0(sY)<15 and ci/bc>0.75 then b9=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<iT then b5=true;cd=false;b7=false;b9=false;q6=0 elseif cd then q6=0;b2="ATO Space"end elseif cd and not cg and c8~=nil and(lo==nil or lo.name==c8.name)then b5=true;cZ=false;cd=false;b7=false;b9=false;if not cR then q6=0 end;bd=true end end;local tL=cf>-1;local tM=cS;if(bs or cd or cX)and not tL and cL>aL and cg then local mu=math.rad(f0(cT))tM=cS*f0(math.cos(mu))+sm*math.sin(mu)end;local tN=dn(sY-tM,-O*0.80,O*0.80)if not cg and bs then tN=dn(sY-tM,-85,Q)elseif not cg then tN=dn(sY-tM,-Q,Q)end;if f0(cT)<5 or bs or cX or b8 or tL or b7 then s1:inject(tN)local sZ=s1:get()pY=pY+sZ end end;if antigrav~=nil and(antigrav and not r and ci<200000)then if bx==nil or bx<1000 then bx=1000 end;if tO~=bx then tO=bx;qg=tO end end;if(cg or ba or ce)and t and cR then local tP=0;if aU>0 and not ba and ch>0.005 and ch<0.1 and cN>-50 then local tQ=bP.getFrictionBurnSpeed()*aU;local tR=cB/3.6;if tQ>tR then tP=tQ-tR-1 end end;s3:inject(cB/3.6+tP-cK:dot(cH))local tS=s3:get()bU=dn(tS,-1,1)if not d7 then if bU<bR and(ch>0.005 or ba or ce)then bT=true;d7=dn(bU,0.01,1)else bT=false;d7=bR end end;s4:inject(cK:len()-cB/3.6-tP)local tT=dn(s4:get(),0,1)if cg and cN<-80 or(ch>0.005 or ba or ce)then bS=tT end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dn(bU,0.01,1)end;local tU=''local tV=vec3()local tW=ru(axisCommandId.vertical,b_*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tW,rR)local tX='thrust analog longitudinal 'if bE=="All"or bE=="Longitude"then tX=tX..aV end;local tY=iA:getAxisCommandType(axisCommandId.longitudinal)local tZ=iA:composeAxisAccelerationFromThrottle(tX,axisCommandId.longitudinal)local t_=rH(axisCommandId.lateral,bA*1000)tU=tU..' , '.."lateral airfoil , lateral ground "tV=tV+t_;if tV:len()>constants.epsilon then d:setEngineForceCommand(tU,tV,rR,'','','',rS)end;d:setEngineForceCommand(tX,tZ,rQ)local u0='thrust analog vertical fueled 'local u1='thrust analog lateral fueled 'if bE=="All"or bE=="Lateral"then u1=u1 ..aW end;if bE=="All"or bE=="Vertical"then u0=u0 ..aX end;if b_~=0 or b8 and b2 or not bo and not bD then d:setEngineForceCommand(u0,tW,rQ)else d:setEngineForceCommand(u0,vec3(),rQ)end;if bA~=0 then d:setEngineForceCommand(u1,t_,rQ)else d:setEngineForceCommand(u1,vec3(),rQ)end;if s8==0 then s8=bS end;local u2=-s8*(aQ*cK+aR*sc)d:setEngineForceCommand('brake',u2)else if t then if not d7 then d7=bR end end;local rw=c.getAxisCommandValue(0)if not cR then s4:inject(cK:len()-rw/3.6)local tT=dn(s4:get(),0,1)s8=dn(s8+tT,0,1)end;local u2=-s8*(aQ*cK+aR*sc)d:setEngineForceCommand('brake',u2)local tU=''local tV=vec3()local u3=false;local tX='thrust analog longitudinal 'if aV~="none"and(bE=="All"or bE=="Longitude")then tX=tX..aV end;local tY=iA:getAxisCommandType(axisCommandId.longitudinal)if tY==axisCommandType.byThrottle then local tZ=iA:composeAxisAccelerationFromThrottle(tX,axisCommandId.longitudinal)d:setEngineForceCommand(tX,tZ,rQ)elseif tY==axisCommandType.byTargetSpeed then local tZ=iA:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tU=tU..' , '..tX;tV=tV+tZ;if iA:getTargetSpeed(axisCommandId.longitudinal)==0 or iA:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iA:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u3=true end end;local u1='thrust analog lateral 'if aW~="none"and(bE=="All"or bE=="Lateral")then u1=u1 ..aW end;local u4=iA:getAxisCommandType(axisCommandId.lateral)if u4==axisCommandType.byThrottle then local u5=iA:composeAxisAccelerationFromThrottle(u1,axisCommandId.lateral)d:setEngineForceCommand(u1,u5,rQ)elseif u4==axisCommandType.byTargetSpeed then local t_=iA:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tU=tU..' , '..u1;tV=tV+t_ end;local u0='thrust analog vertical 'if aX~="none"and(bE=="All"or bE=="Vertical")then u0=u0 ..aX end;local u6=iA:getAxisCommandType(axisCommandId.vertical)if u6==axisCommandType.byThrottle then local tW=iA:composeAxisAccelerationFromThrottle(u0,axisCommandId.vertical)if b_~=0 or b8 and b2 then d:setEngineForceCommand(u0,tW,rQ,'airfoil','ground','',rS)else d:setEngineForceCommand(u0,vec3(),rQ)d:setEngineForceCommand('airfoil vertical',tW,rQ,'airfoil','','',rS)d:setEngineForceCommand('ground vertical',tW,rQ,'ground','','',rS)end elseif u6==axisCommandType.byTargetSpeed then if b_<0 then d:setEngineForceCommand('hover',vec3(),rQ)end;local u7=iA:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tU=tU..' , '..u0;tV=tV+u7 end;if tV:len()>constants.epsilon then if s8~=0 or u3 or f0(sc:dot(cH))<0.5 then tU=tU..', brake'end;d:setEngineForceCommand(tU,tV,rR,'','','',rS)end end;local u8=aN*(sg-sf)local u9=vec3(bP.getWorldAirFrictionAngularAcceleration())u8=u8-u9;d:setEngineTorqueCommand('torque',u8,rQ,'airfoil','','',rS)d:setBoosterCommand('rocket_engine')if c5 and not o then local ki=cJ:len()local ua=0.15;if not cR then local ub=iA:getTargetSpeed(axisCommandId.longitudinal)if ki*3.6>ub*(1-ua)and uc then uc=false;d:toggleBoosters()elseif ki*3.6<ub*(1-ua)and not uc then uc=true;d:toggleBoosters()end else local rj=c.getThrottle()if t then rj=bR*100 end;local rw=rj/100;if not cg then rw=rw*a0;if ki>=rw*(1-ua)and uc then uc=false;d:toggleBoosters()elseif ki<rw*(1-ua)and not uc then uc=true;d:toggleBoosters()end else local th=bN(cB)rw=rw*th/3.6;if ki>=rw*(1-ua)and uc then uc=false;d:toggleBoosters()elseif ki<rw*(1-ua)and not uc then uc=true;d:toggleBoosters()end end end end end;if ud then for dN,dz in pairs(ud)do pF[dN]=dz end end;cf=qx()return pF end;local function ue(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uf,iz,iA,iB,ug,gE,fN,e6,dp,dn,fM,iD,pE,dk,uh,ui)local bP=DUConstruct;local uj={}local uk=true;local ul=5;local um=5;local un=ul;local uo=um;local up=bQ;local uq=bQ;function uj.landingGear(q9)bo=not bo;if bo then if b5 or bs or cd or bB then ct.ResetAutopilots(true)end;bv=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not q9 and cf==-1 then fM("bklOn","BL")qU=true;ba=false;b9=false;bb=false;if b8 then db=not db end;cz=true;bo=false;b8=true else if bW then fM("grOut","LG",1)d.control.deployLandingGears()end;db=false;if cg then cz=q;b2="Landing"end end;if q9 or cf~=-1 and cf>Z-3 or not bD then b8=true end;iA:activateGroundEngineAltitudeStabilization(qY)iA:setTargetGroundAltitude(Z)b7=false elseif bW and not b8 then fM("grOut","LG",1)d.control.deployLandingGears()end else if b8 then b8=false end;if bW then fM("grIn","LG",1)d.control.retractLandingGears()end;iA:activateGroundEngineAltitudeStabilization(qY)if bD then if Z<iA.targetGroundAltitude then iA:setTargetGroundAltitude(iA.targetGroundAltitude)else iA:setTargetGroundAltitude(Y)end else iA:setTargetGroundAltitude(Y)end end end;function uj.startControl(ur)local function us(re)local rf=1;local function ut(uu,re)local uv={kt.surfaceMaxAltitude+100,kt.spaceEngineMinAltitude-0.01*kt.noAtmosphericDensityAltitude,kt.noAtmosphericDensityAltitude+U,kt.radius*(T-1)+kt.noAtmosphericDensityAltitude}local uw=uu;for dS,dz in ipairs(uv)do if re and uw>dz then uu=dz elseif uu<dz and not re then uu=dz;break end end;return uu end;if re then rf=-1 end;if not r and cQ then if c1 and re then bx=1000 elseif bx~=nil then bx=bx+rf*um;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end else bx=tO+rf*100 end elseif b7 or bb or bB then if bB then if c1 then cD=ut(cD,re)else cD=cD+rf*ul end;if cD<kt.noAtmosphericDensityAltitude then cD=kt.noAtmosphericDensityAltitude end else if c1 and cg then bc=ut(bc,re)else bc=bc+rf*ul end end else iA:updateTargetGroundAltitudeFromActionStart(rf*1.0)end end;local function ux(uy)if not cg then dk("Flight Assist in Atmo only")return end;local dw=type(uy)if cX==nil then if dw=="table"then if b5 or bs then ct.ToggleAutopilot()end;fM("180On","BR")elseif uy==1 then fM("bnkLft","BR")else fM("bnkRht","BR")end;if not b7 and not b5 and not bs then ct.ToggleAltitudeHold()if dw~="table"then uy=uy+1 end end;cX=uy else fM("180Off","BR")cX=nil end end;local function uz()if iB()==1 then c9=0;ca=0;ug(bk)elseif iz()==1 and y then cy=false;cx=false end;c1=false end;if ur=="gear"then cv.landingGear()elseif ur=="light"then if p2 then if iz()==1 then if DUPlayer.isFrozen()==1 then DUPlayer.freeze(0)dk("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(1)dk("Player Frozen, pitch/yaw/roll enabled")end else dk("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ur=="forward"then if p2 and not cg and not b5 then b4=not b4;b3=false else bX=bX-1 end elseif ur=="backward"then if p2 then if not cg then if not b5 then b3=not b3;b4=false else b6=not b6 end else ux(-cK*5000)end else bX=bX+1 end elseif ur=="left"then if p2 then ux(1)else bY=bY-1 end elseif ur=="right"then if p2 then ux(3)else bY=bY+1 end elseif ur=="yawright"then bZ=bZ-1;dc=nil elseif ur=="yawleft"then bZ=bZ+1;dc=nil elseif ur=="straferight"then iA:updateCommandFromActionStart(axisCommandId.lateral,1.0)bA=1 elseif ur=="strafeleft"then iA:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bA=-1 elseif ur=="up"then ct.vertical(1)if cf-3<Z and ci>0 and bo then cv.landingGear()end elseif ur=="down"then ct.vertical(-1)elseif ur=="groundaltitudeup"then us()elseif ur=="groundaltitudedown"then us(true)elseif ur=="option1"then uA=false;if p2 and c1 then local uB=""for M=1,#d2 do uB=uB.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fN(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..uB)return end;cs.adjustAutopilotTargetIndex()elseif ur=="option2"then uA=false;if p2 and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;dk("Deboarded All Passengers")return end;cs.adjustAutopilotTargetIndex(1)elseif ur=="option3"then uA=false;if p2 and c1 then local uB=""for M=1,#d3 do uB=uB.."| ID: "..d3[M].." Mass: "..fN(bP.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..uB)return end;if x then if w then w=false else w=true end;if cu then cu.ToggleRadarPanel()end end elseif ur=="option4"then uA=false;if p2 and c1 then for M=1,#d3 do bP.forceUndock(d3[M])end;dk("Undocked all ships")return end;cX=nil;ct.ToggleAutopilot()elseif ur=="option5"then uA=false;if p2 and c1 then dh=false;ct.ToggleLockPitch()return end;if bQ-uq<1.5 then if dh then dh=-1;dk("Retrograde Alignment lock to "..bl)return end end;uq=bQ;if dh then dh=false;dk("Alignment cancelled")elseif not b5 and not bs and not cd and not bB and not ba and not ce and not b7 then dh=1;dk("Alignment lock to "..bl)else dk("Disengage autopilot before using Alignment Lock")end elseif ur=="option6"then uA=false;if p2 and c1 then if shield then cw.ventShield()else dk("No shield found")end;return end;ct.ToggleAltitudeHold()elseif ur=="option7"then uA=false;if p2 and c1 then if shield then shield.toggle()return else dk("No shield found")return end end;E=not E;if E then dk("Collision System Enabled")else dk("Collision System Secured")end elseif ur=="option8"then uA=false;if p2 and c1 then if bn>0 and fY~=nil then ct.routeWP()else dk("Select a saved wp on IPH to add to or remove from route")end;return end;bD=not bD;if not bD then dk("DeCoupled Mode - Ground Stabilization off")iA:deactivateGroundEngineAltitudeStabilization()fM("gsOff","GS")else dk("Coupled Mode - Ground Stabilization on")iA:activateGroundEngineAltitudeStabilization(qY)de=true;fM("gsOn","GS")end elseif ur=="option9"then uA=false;if p2 and c1 then iA:resetCommand(axisCommandId.longitudinal)iA:resetCommand(axisCommandId.lateral)iA:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()==1;if ck then fM("gyOn","GA")else fM("gyOff","GA")end else dk("No gyro found")end elseif ur=="lshift"then if p2 then c1=true end elseif ur=="brake"then if b0 or p2 then ct.BrakeToggle("Manual")elseif not b2 then ct.BrakeToggle("Manual")else b2="Manual"end elseif ur=="lalt"then uA=true;p2=true;if iz()==0 and not j and g=="keyboard"then ug(1)end elseif ur=="booster"then if p2 then if uh then uh.toggle()if uh.isActive()==1 then dk("Transponder On")else dk("Transponder Off")end else dk("No transponder found")end else if o then d:toggleBoosters()elseif not c5 then if not uc then d:toggleBoosters()uc=true end;c5=true else if uc then d:toggleBoosters()uc=false end;c5=false end end elseif ur=="stopengines"then local function uC()if bQ-up<1.5 then fM("clear","CA")ct.clearAll()end end;uC()up=bQ;if iA:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p2 then if cB>0 then cB=0 else cB=V end elseif bR~=0 then iA:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iA:getTargetSpeed(axisCommandId.longitudinal)~=0 then iA:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(a0*3.6)end end end elseif ur=="speedup"then ct.changeSpd()elseif ur=="speeddown"then ct.changeSpd(true)elseif ur=="antigravity"and not r then if antigrav~=nil then ct.ToggleAntigrav()else dk("No antigrav found")end elseif ur=="leftmouse"then c2=true;if c1 then uz()uA=false else c1=true;bk=iB()ug(1)end end end;function uj.stopControl(ur)local function uD()if not r and cQ then uo=um end;if b7 or bb or bB then un=ul end end;if ur=="forward"then bX=0 elseif ur=="backward"then bX=0 elseif ur=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif ur=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif ur=="yawright"then bZ=0 elseif ur=="yawleft"then bZ=0 elseif ur=="straferight"then iA:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bA=0 elseif ur=="strafeleft"then iA:updateCommandFromActionStop(axisCommandId.lateral,1.0)bA=0 elseif ur=="up"then ct.vertical(0,-1)elseif ur=="down"then ct.vertical(0,1)elseif ur=="groundaltitudeup"then uD()uA=false elseif ur=="groundaltitudedown"then uD()uA=false elseif ur=="brake"then if not b0 and not p2 then if b2 then ct.BrakeToggle()else b2=false end end elseif ur=="lalt"then if c1 then c1=false end;if iz()==0 and j then if uA then if iB()==1 then ug(0)else ug(1)end else uA=true end elseif iz()==0 and not j and g=="keyboard"then ug(0)end;p2=false end end;function uj.loopControl(ur)local function uE(re)local rf=1;if re then rf=-1 end;if not r and cQ then if bx~=nil then bx=bx+rf*uo;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end;uo=dn(uo*1.05,um,50)else bx=tO+rf*100 end elseif b7 or bb or bB then if bB then cD=cD+rf*un;if cD<kt.noAtmosphericDensityAltitude then cD=kt.noAtmosphericDensityAltitude end else bc=bc+rf*un end;un=dn(un*1.05,ul,50)else iA:updateTargetGroundAltitudeFromActionLoop(rf*1.0)end end;local function uF(re)local rf=1;if re then rf=-1 end;if not c1 then if t and not p2 then bR=dn(bR+rf*aF/100,-1,1)else iA:updateCommandFromActionLoop(axisCommandId.longitudinal,rf*aF)end end end;if ur=="groundaltitudeup"then if not c1 then uE()end elseif ur=="groundaltitudedown"then if not c1 then uE(true)end elseif ur=="speedup"then uF()elseif ur=="speeddown"then uF(true)end end;function uj.inputTextControl(rd)local function uG(uH,fo,gr)local function uI(fo)local dF=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dG='::pos{'..dF..','..dF..','..dF..','..dF..','..dF..'}'local dW,dX,e3,e4,e5=e6(fo,dG)if dW=="0"and dX=="0"then return vec3(dp(e3),dp(e4),dp(e5))end;e4=math.rad(e4)e3=math.rad(e3)local kt=e[dp(dW)][dp(dX)]local eX=math.cos(e3)local uJ=vec3(eX*math.cos(e4),eX*math.sin(e4),math.sin(e3))return kt.center+(kt.radius+e5)*uJ end;local fP=uI(fo)return cs.AddNewLocation(uH,fP,gr)end;local M;local uK,io=nil,nil;local uL="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations.\n".."/trans (whatever) - shows the current transponder setting, whatever, if present, is the new tag that is set.\n".."/pipecenter - Shows a waypoint to closest pipe center and prints loc in lua chat and sets it to 1-Temp in IPH for use with autopilot"M=string.find(rd," ")uK=rd;if M~=nil and string.find(rd,"::")~=1 then uK=string.sub(rd,0,M-1)io=string.sub(rd,M+1)end;if uK=="/help"or uK=="/commands"then for ln in string.gmatch(uL,"([^\n]+)")do a.print(ln)end;return elseif uK=="/setname"then if io==nil or io==""then dk("Usage: ah-setname Newname")return end;if bn>0 and fY~=nil then cs.UpdatePosition(io)else dk("Select a saved target to rename first")end elseif shield and uK=="/resist"then cw.setResist(io)elseif uK=="/addlocation"or string.find(rd,"::pos")~=nil then local gr=false;local uH="0-Temp"if io==nil or io==""or uK~="/addlocation"then io=uK;gr=true end;M=string.find(io,"::")if not gr then uH=string.sub(io,1,M-2)end;local fo=string.sub(io,M)fo=fo:gsub("%s+","")uG(uH,fo,gr)elseif uK=="/agg"then if io==nil or io==""then dk("Usage: /agg targetheight")return end;io=dp(io)if io<1000 then io=1000 end;bx=io;dk("AGG Target Height set to "..io)elseif uK=="/G"then if io==nil or io==""then dk("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if io=="dump"then for dN,dz in pairs(iD())do if type(dz.get())=="boolean"then if dz.get()==true then a.print(dN.." true")else a.print(dN.." false")end elseif dz.get()==nil then a.print(dN.." nil")else a.print(dN.." "..dz.get())end end;return end;M=string.find(io," ")local uM=string.sub(io,0,M-1)local uN=string.sub(io,M+1)for dN,dz in pairs(iD())do if dN==uM then local uO=type(dz.get())if uO=="number"then uN=dp(uN)if dN=="AtmoSpeedLimit"then cB=uN end end;dk("Variable "..uM.." changed to "..uN)if dN=="MaxGameVelocity"then uN=uN/3.6;if uN>df-0.2 then uN=df-0.2;dk("Variable "..uM.." changed to "..fN(uN*3.6,1))end end;if uO=="boolean"then if string.lower(uN)=="true"then uN=true else uN=false end end;dz.set(uN)return end end;dk("No such global variable: "..uM)elseif uK=="/deletewp"then if bn>0 and fY~=nil then cs.ClearCurrentPosition()else dk("Select a custom wp to delete first in IPH")end elseif uK=="/copydatabank"then if dbHud_2 then pE(true)else dk("Spare Databank required to copy databank")end elseif uK=="/iphWP"then if bn>0 then a.print(ct.showWayPoint(c8,bm,true))a.print(json.encode(bm))dk("::pos waypoint shown in lua chat in local and world format")else dk("No target selected in IPH")end elseif uK=="/trans"then if uh then if io==nil or io==""then dk("Current tag: "..ui(uh.getTags()))return else uh.setTags({io})dk("Transponder tag set to: "..io)end else dk("No transponder found.")end elseif uK=="/createPrivate"then local uP="privatelocations = {\n"local uQ=""if#d9>0 then for dN,dz in pairs(d9)do uP=uP.."{position = {x = "..dz.position.x..", y = "..dz.position.y..", z = "..dz.position.z.."},\n ".."name = '"..dz.name.."',\n planetname = '"..dz.planetname.."',\n gravity = "..dz.gravity..",\n"if dz.heading then uP=uP.."heading = {x = "..dz.heading.x..", y = "..dz.heading.y..", z = "..dz.heading.z.."},\n"end;if dz.safe then uP=uP.."safe = true},\n"else uP=uP.."safe = false},\n"end end end;uQ=#d9 .."-Private "if io=="all"then for dN,dz in pairs(br)do uP=uP.."{position = {x = "..dz.position.x..", y = "..dz.position.y..", z = "..dz.position.z.."},\n ".."name = '*"..dz.name.."',\n planetname = '"..dz.planetname.."',\n gravity = "..dz.gravity..",\n"if dz.heading then uP=uP.."heading = {x = "..dz.heading.x..", y = "..dz.heading.y..", z = "..dz.heading.z.."},\n"end;if dz.safe then uP=uP.." safe = true},\n"else uP=uP.."safe = false},\n"end end;uQ=uQ..#br.."-Public "end;uP=uP.."}\n return privatelocations"if uf then uf.setHTML(uP)end;dk(uQ.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c4=7 elseif uK=="/pipecenter"then if dg~=nil then local fo="::pos{0,0,"..dg["x"]..","..dg["y"]..","..dg["z"].."}"dj("Closest Pipe: "..fo)a.setWaypoint(fo)uG("1-Temp",fo,true)else dk("No Pipe Center known")end end end;function uj.tagTick()if bE=="Off"then bE="All"elseif bE=="All"then bE="Longitude"elseif bE=="Longitude"then bE="Lateral"elseif bE=="Lateral"then bE="Vertical"else bE="Off"end;dk("Extra Engine Tags: "..bE)c.stopTimer("tagTick")end;if uR then for dN,dz in pairs(uR)do uj[dN]=dz end end;return uj end;local function uS(d,b,c,e,vBooster,hover,pD,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iw,uf,uh)local a=DUSystem;local bP=DUConstruct;local uT=DUPlayer;local uU=DULibrary;local uV={}local dm=string.format;local ix=json.decode;local ui=json.encode;local pw=b.getElementMaxHitPointsById;local iy=b.getElementMassById;local iz=d.control.isRemoteControlled;local e6=string.match;local gE=a.destroyWidgetPanel;local fK=a.updateData;local fL=a.addDataToWidget;local ug=a.lockView;local iB=a.isViewLocked;local dq=math.sqrt;local dp=tonumber;local f0=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local eW=math.atan;local bM=a.getArkTime;local dn=utils.clamp;local iA=d.axisCommandManager;local gG=13;local iG=b.getElementIdList()local iH=0;local function dr(eE,eF)if eE==0 then return f0(eF)<1e-09 elseif eF==0 then return f0(eE)<1e-09 else return f0(eE-eF)<math.max(f0(eE),f0(eF))*dE end end;local function fN(dF,uW)local rf=10^(uW or 0)return bN(dF*rf+0.5)/rf end;local function iC(uX,uY)for dN,dz in pairs(uY)do if type(dN)=="string"then uX[dN]=dz else uX[#uX+1]=uY[dN]end end;return uX end;local function iD(uZ)local u_={}if not uZ then iC(u_,L)iC(u_,ab)iC(u_,aD)iC(u_,a_)return u_ elseif uZ=="boolean"then return L elseif uZ=="handling"then return ab elseif uZ=="hud"then return aD elseif uZ=="physics"then return a_ end end;local function dk(sP)if not sP then return end;if c3~="empty"then if not string.find(c3,sP)then c3=c3 .."\n"..sP;c4=7 end else c3=sP end end;local function pE(v0)local function v1(v2)for dN,dz in pairs(v2)do dbHud_1.setStringValue(dN,ui(dz.get()))if v0 and dbHud_2 then dbHud_2.setStringValue(dN,ui(dz.get()))end end end;if dbHud_1 then v1(bJ)v1(iD())a.print("Saved Variables to Datacore")if v0 and dbHud_2 then dk("Databank copied.  Remove copy when ready.")end end end;local function fM(v3,v4,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v3 ..".mp3")end;local function gF(hz,hA,rd,jO,v5)return dm([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jO or"",hz,hA,v5 or"",rd)end;local function iE(cb,v6)v6=v6 or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fN(cb,v6)..unit end;local function iF(v7)local v8=0;local v9=0;local va=0;if v7<60 then v7=bN(v7)elseif v7<3600 then v8=bN(v7/60)v7=bN(v7%60)elseif v7<86400 then v9=bN(v7/3600)v8=bN(v7%3600/60)else va=bN(v7/86400)v9=bN(v7%86400/3600)end;if va>365 then return">1y"elseif va>0 then return va.."d "..v9 .."h "elseif v9>0 then return v9 .."h "..v8 .."m "elseif v8>0 then return v8 .."m "..v7 .."s"elseif v7>0 then return v7 .."s"else return"0s"end end;local function vb()if radar_1 then cu=gD(b,a,c,radar_1,radar_2,warpdrive,f0,gE,dq,gF,dp,gG,fM,dk)end end;function uV.radarSetup()vb()end;function uV.onStart()local vc=false;local function vd()local function ve(vf)local vg=dbHud_1.hasKey;for dN,dz in pairs(vf)do if vg(dN)then local dI=ix(dbHud_1.getStringValue(dN))if dI~=nil then dz.set(dI)vc=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then ve(iD())coroutine.yield()ve(bJ)else ve(bJ)dk("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c4=5;vc=false end;coroutine.yield()if vc then dk("Loaded Saved Variables")elseif not f then dk("No Databank Saved Variables Found\nVariables will save to Databank on standing")c4=5 end;if#br>0 then da=iC(da,br)end else dk("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;b0=k;g=string.lower(g)cz=q;cB=V;if by+180<bQ then bw=0 end;by=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then dk("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c4=7 end;if antigrav and not r then if bx==nil then bx=ci end;antigrav.setTargetAltitude(bx)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d9>0 then da=iC(da,d9)end end;ls="Proceeding to Waypoint"if not a0 or a0<0 then a0=bP.getMaxSpeed()-0.1 end end;local function vh()local function vi(vj,vk)if vj>vk then vk=vj end;local vl,vm=0,0;if a6>0 then vl=a6*0.05 end;if a7>0 then vm=a7*0.05 end;vk=vk*(1-(vl+vm))return vk end;local vn=b.getElementNameById;local vo=at~=0 and au~=0;local vp=_G["atmofueltank_size"]local vq=_G["spacefueltank_size"]local vr=_G["rocketfueltank_size"]for dN in pairs(iG)do local type=b.getElementDisplayNameById(iG[dN])if e6(type,'^.*Atmospheric Engine$')then if e6(tostring(b.getElementTagsById(iG[dN])),'^.*vertical.*$')and b.getElementForwardById(iG[dN])[3]>0 then cP=true end end;if e6(type,'^.*Space Engine$')then cG=true;if e6(tostring(b.getElementTagsById(iG[dN])),'^.*vertical.*$')then local vs=b.getElementForwardById(iG[dN])if vs[3]<0 then vt=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local py=pw(iG[dN])if py>10000 then gG=110 elseif py>1000 then gG=55 elseif py>150 then gG=27 end end;iH=iH+pw(iG[dN])if vo and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local py=pw(iG[dN])local f5=iy(iG[dN])local vj=0;local jG=bM()if type=="Atmospheric Fuel Tank"then local vk=400;local vu=35.03;if py>10000 then vk=51200;vu=5480 elseif py>1300 then vk=6400;vu=988.67 elseif py>150 then vk=1600;vu=182.67 end;vj=f5-vu;if a3>0 then vk=vk+vk*a3*0.2 end;vk=vi(vj,vk)local gq=vn(iG[dN])local jE=0;for jF=1,vp do if gq==ix(c["atmofueltank_"..jF].getWidgetData()).name then jE=jF;break end end;local vv={iG[dN],string.sub(gq,1,12),vk,vu,vj,jG,jE}cl[#cl+1]=vv end;if type=="Rocket Fuel Tank"then local vk=320;local vu=173.42;if py>65000 then vk=40000;vu=25740 elseif py>6000 then vk=5120;vu=4720 elseif py>700 then vk=640;vu=886.72 end;vj=f5-vu;if a5>0 then vk=vk+vk*a5*0.1 end;vk=vi(vj,vk)local gq=vn(iG[dN])local jE=0;for jF=1,vr do if gq==ix(c["rocketfueltank_"..jF].getWidgetData()).name then jE=jF;break end end;local vv={iG[dN],string.sub(gq,1,12),vk,vu,vj,jG,jE}cn[#cn+1]=vv end;if type=="Space Fuel Tank"then local vk=600;local vu=35.03;if py>10000 then vk=76800;vu=5480 elseif py>1300 then vk=9600;vu=988.67 elseif py>150 then vk=2400;vu=182.67 end;vj=f5-vu;if a4>0 then vk=vk+vk*a4*0.2 end;vk=vi(vj,vk)local gq=vn(iG[dN])local jE=0;for jF=1,vq do if gq==ix(c["spacefueltank_"..jF].getWidgetData()).name then jE=jF;break end end;local vv={iG[dN],string.sub(gq,1,12),vk,vu,vj,jG,jE}cm[#cm+1]=vv end end end;if not cP then bb,b1=false,false end end;local function vw()if gyro~=nil then ck=gyro.isActive()==1 end;if not bD then iA:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ug(1)else ug(0)end;if door and(cg or not cg and ci<10000)then for dS,dz in pairs(door)do dz.toggle()end end;if switch then for dS,dz in pairs(switch)do dz.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dS,dz in pairs(forcefield)do dz.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not r then antigrav.showWidget()end end;if iz()==1 and l then uT.freeze(1)else uT.freeze(0)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bo=d.control.isAnyLandingGearDeployed()==1 or not bD or cf~=-1 and cf-3<Z;local vx=cJ:len()<30;if cf~=-1 and vy or(not cg or not vy)and vx then b2="Startup"else b2=false end;iA:setTargetGroundAltitude(Z)pk=cg end;local function vz()local vA={}local function vB()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vC={[1]=6637,[2]=3426,[4]=7580,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vD,vE in pairs(e)do e[vD][0]=vB()e[vD][0].systemId=vD;vA[vD]={}for vF,kt in pairs(e[vD])do kt.gravity=kt.gravity/9.8;kt.center=vec3(kt.center)kt.name=kt.name[1]kt.noAtmosphericDensityAltitude=kt.atmosphereThickness;kt.spaceEngineMinAltitude=vC[kt.id]or 0.5353125*kt.atmosphereThickness;kt.planetarySystemId=vD;kt.bodyId=kt.id;vA[vD][vF]=kt;if mc==nil or kt.center.x<mc then mc=kt.center.x end;if mb==nil or kt.center.x>mb then mb=kt.center.x end;if mf==nil or kt.center.y<mf then mf=kt.center.y end;if me==nil or kt.center.y>me then me=kt.center.y end;if kt.center and kt.name~="Space"then d4[#d4+1]=kt end end end;eg=dl(d,b,c,a,dm,dn,dp,dq,dr)co=eg(vA)fQ=co[0]cp=e_(d,b,c,a,dq,f0)cq=fk(d,b,c,a,dm,dn,dp,dq,dr)cs=fJ(d,b,c,a,dbHud_1,e,fK,fL,bN,dp,dq,fM,fN,dk)kt=co[0]:closestBody(bP.getWorldPosition())end;vG=false;vH=coroutine.create(function()iA:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vd()coroutine.yield()vh()coroutine.yield()ct=pC(d,b,c,e,vBooster,hover,pD,antigrav,dbHud_1,f0,bN,bO,iz,eW,bM,dn,iA,fK,iB,dq,fN,fM,iC,dr,iE,iF,pE,ix,dk)vw()coroutine.yield()vz()vb()if iv then cr=iv(d,b,c,a,e,antigrav,hover,shield,warpdrive,iw,f0,bN,dm,ix,bO,iy,iz,eW,bM,dn,iA,fL,fK,gE,iB,dq,fN,gF,fM,iC,iD,iE,iF,iG,iH,dk)end;if cr then cr.ButtonSetup()end;cv=ue(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uf,iz,iA,iB,ug,gE,fN,e6,dp,dn,fM,iD,pE,dk,uh,ui)if shield then cw=id(shield,e6,bN,dk)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uf then uf.setCenteredText("")end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bP.setDockingMode(aa)if shield then c.setTimer("shieldTick",0.0166667)end;if vI then vJ.ExtraOnStart()end;local function vK()if bI[1]==0 then ct.cmdThrottle(bI[2])else if ch>0 then cB=bI[2]ct.cmdThrottle(1)end end end;lk=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if lk then if cf>-1 and cL<1 and cf-3<Z then c.exit()else if J then vK()else if ch==0 then b2="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bI[3]+3>bM()then vK()end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()local vL;vL=#d2>1 and"Passengers: "..#d2-1 .." "or""vL=vL..(#d3>0 and"Ships: "..#d3 or"")if vL~=""then dk("NOTICE: Docked "..vL)end;fM("start","SU")end)coroutine.resume(vH)end;function uV.onUpdate()if vG then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iA:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and p4~=vM then a.setScreen(p4)end;vM=p4;if lk and not J and ch>0 and cf==-1 then cv.landingGear()end;if lk and cf>-1 and cL<1 and cf-3<Z then c.exit()end;if vI then vJ.ExtraOnUpdate()end else local i3=coroutine.status(vH)if i3=="suspended"then local dO,i4=coroutine.resume(vH)if i4 then a.print("ERROR STARTUP: "..i4)end elseif i3=="dead"then vG=true end end end;function uV.onFlush()if vG then ct.onFlush()if vI then vJ.ExtraOnFlush()end end end;function uV.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dS,dz in pairs(door)do dz.toggle()end end;if switch then for dS,dz in pairs(switch)do dz.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dS,dz in pairs(forcefield)do dz.toggle()end end;w=d6;local vN=0;if lk then vN=bM()end;if iA:getAxisCommandType(0)==0 then bI={0,bR,vN}else bI={1,iA:getTargetSpeed(axisCommandId.longitudinal),vN}end;pE()if nP then nP.activate()end;if z then ct.showWayPoint(kt,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vI then vJ.ExtraOnStop()end;fM("stop","SU")end;function uV.controlStart(ur)if vG then cv.startControl(ur)end end;function uV.controlStop(ur)if vG then cv.stopControl(ur)end end;function uV.controlLoop(ur)if vG then cv.loopControl(ur)end end;function uV.controlInput(rd)if vG then cv.inputTextControl(rd)end end;function uV.radarEnter(dX)if cu then cu.onEnter(dX)end end;function uV.radarLeave(dX)if cu then cu.onLeave(dX)end end;function uV.onTick(vO)if vO=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vO=="oneSecond"then if cr then cr.OneSecondTick()end elseif vO=="msgTick"then if cr then cr.MsgTick()end elseif vO=="animateTick"then if cr then cr.AnimateTick()end elseif vO=="hudTick"then if cr then cr.hudtick()end elseif vO=="apTick"then if ct then ct.APTick()end elseif vO=="shieldTick"then cw.shieldTick()elseif vO=="tagTick"then cv.tagTick()elseif vO=="contact"then cu.ContactTick()end end;if vI then for dN,dz in pairs(vI)do uV[dN]=dz end end;return uV end;function script.onStart()vJ.onStart()end;function script.onOnStop()vJ.onStop()end;function script.onTick(vO)vJ.onTick(vO)end;function script.onOnFlush()vJ.onFlush()end;function script.onOnUpdate()vJ.onUpdate()end;function script.onActionStart(ur)vJ.controlStart(ur)end;function script.onActionStop(ur)vJ.controlStop(ur)end;function script.onActionLoop(ur)vJ.controlLoop(ur)end;function script.onInputText(rd)vJ.controlInput(rd)end;function script.onEnter(dX)vJ.radarEnter(dX)end;function script.onLeave(dX)vJ.radarLeave(dX)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vJ=uS(d,core,unit,e,vBooster,hover,pD,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iw,uf,vP)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
