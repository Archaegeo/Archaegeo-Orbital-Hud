name: ArchHud - Archaegeo v1.504 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.504;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8,a9=0;local aa,ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=0;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local bP={}function p(bQ)system.print(E..": "..bQ)end;local function bR(bS)local bT,bU,bV=aR:getPlanetarySystem(0):castIntersections(bv,bS,function(bW)if bW.noAtmosphericDensityAltitude>0 then return bW.radius+bW.noAtmosphericDensityAltitude else return bW.radius+bW.surfaceMaxAltitude*1.5 end end)local bX=bU;if bV~=nil and bU~=nil then bX=math.min(bV,bU)end;if bX~=nil then return bT,bX else return nil,nil end end;local function bY(bZ,b_,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bZ.."|"..b_.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bZ.."|"..b_.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bZ.."|"..b_.."|"..soundVolume)end end;local function c0(c1,c2)for i=1,#c2 do c1[#c1+1]=c2[i]end;return c1 end;local function c3(c4)local c5={}local c6={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local c7={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c8={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local c9={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c4 then c0(c5,c6)c0(c5,c7)c0(c5,c8)c0(c5,c9)return c5 elseif c4=="boolean"then return c6 elseif c4=="handling"then return c7 elseif c4=="hud"then return c8 elseif c4=="physics"then return c9 end end;local function ca(cb,cc,cd,ce,cf)if ce==nil then ce=""end;if cf==nil then cf=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ce,cb,cc,cf,cd)end;local function cg(ch,ci)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ci then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,ch)K=r(A(ch*100,0)/100,-1,1)end;local function cj(ch,ci)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ci then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,ch)bz=ch end;local function ck(cl,cm)if cl==0 then return d(cm)<1e-09 end;if cm==0 then return d(cl)<1e-09 end;return d(cl-cm)<math.max(d(cl),d(cm))*epsilon end;local function cn(aj,co)local cp=aj>100000;if co==nil then co=1 end;if cp then return A(aj/1000/200,co).."SU"elseif aj<1000 then return A(aj,co).."M"else return A(aj/1000,co).."KM"end end;local function cq()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cj(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cr()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then bY("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then bY("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function cs()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bY("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cr()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;cr()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then bY("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cq()end else bY("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cq()end end;if am then HoldAltitude=100000 end else bY("altOff","AH")if IntoOrbit then cr()end;if VertTakeOff then cq()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function ct()local function cu(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cs()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bY("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bY("apSpc","AP")if ar~=0 then am=true;cs()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bY("vtt","AP")cu(SpaceTarget)end else bY("apOn","AP")if not(ac.name==planet.name and bM)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then cr()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cr()end end end else bY("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cs()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cr()else bY("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bY("apP","AP")am=true;cs()end else bY("apOff","AP")am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;P=false;AutoTakeoff=false;AltitudeHold=false;HoldAltitude=as;TargetSet=false;Reentry=false;if IntoOrbit then cr()end end end;local function cv()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then bY("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cq()end;if IntoOrbit then cr()end;b0=autoRollPreference;al=false;an=false;af=0 else bY("bkOff","B",1)end end;local function cw()if Reentry then a2="Re-Entry cancelled"bY("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;bY("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local cd=cn(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..cd;bY("glide","RE")cj(e(b7))end;AutoTakeoff=false end;local function cx()if antigrav and not ExternalAGG then if by then bY("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bY("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cy(cz)local cA=0;local cB=0;local cC=0;if cz<60 then cz=e(cz)elseif cz<3600 then cA=e(cz/60)cz=e(cz%60)elseif cz<86400 then cB=e(cz/3600)cA=e(cz%3600/60)else cC=e(cz/86400)cB=e(cz%86400/3600)end;if cC>0 then return cC.."d "..cB.."h "elseif cB>0 then return cB.."h "..cA.."m "elseif cA>0 then return cA.."m "..cz.."s"elseif cz>0 then return cz.."s"else return"0s"end end;local function cD(cE)local function cF(cG)for cH,cI in pairs(cG)do dbHud_1.setStringValue(cI,h(_G[cI]))if cE and dbHud_2 then dbHud_2.setStringValue(cI,h(_G[cI]))end end end;if dbHud_1 then cF(c)cF(c3())system.print("Saved Variables to Datacore")if cE and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cJ()local function cK(cL)return type(cL)=='number'end;local function cM(cL)return type(z(cL))=='number'end;local function cN(cO)return type(cO)=='table'end;local function cP(cQ)return type(cQ)=='string'end;local function cR(cI)return cN(cI)and cK(cI.x and cI.y and cI.z)end;local function cS(cT)return cN(cT)and cK(cT.latitude and cT.longitude and cT.altitude and cT.id and cT.systemId)end;local cU=math.pi/180;local cV=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cW='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cX(cL)local cY=string.gsub(string.reverse(f('%.4f',cL)),'^0*%.?','')return cY==''and'0'or string.reverse(cY)end;local function cZ(c_)if cR(c_)then return f('{x=%.3f,y=%.3f,z=%.3f}',c_.x,c_.y,c_.z)end;if cN(c_)and not getmetatable(c_)then local d0={}local d1=next(c_)if type(d1)=='nil'or d1==1 then d0=c_ else for cH,cI in pairs(c_)do local ch=cZ(cI)if type(cH)=='number'then table.insert(d0,f('[%s]=%s',cH,ch))else table.insert(d0,f('%s=%s',cH,ch))end end end;return f('{%s}',table.concat(d0,','))end;if cP(c_)then return f("'%s'",c_:gsub("'",[[\']]))end;return tostring(c_)end;local d2={}d2.__index=d2;d2.__tostring=function(c_,d3)local d4={}for cH in pairs(c_)do table.insert(d4,cH)end;table.sort(d4)local d0={}for _,cH in ipairs(d4)do local ch=cZ(c_[cH])if type(cH)=='number'then table.insert(d0,f('[%s]=%s',cH,ch))else table.insert(d0,f('%s=%s',cH,ch))end end;if d3 then return f('%s%s',d3,table.concat(d0,',\n'..d3))end;return f('{%s}',table.concat(d0,','))end;d2.__eq=function(d5,d6)return d5.systemId==d6.systemId and d5.id==d6.id and ck(d5.radius,d6.radius)and ck(d5.center.x,d6.center.x)and ck(d5.center.y,d6.center.y)and ck(d5.center.z,d6.center.z)and ck(d5.GM,d6.GM)end;local function d7(d8,d9,da,db,dc)assert(cM(d8),'Argument 1 (systemId) must be a number:'..type(d8))assert(cM(d9),'Argument 2 (id) must be a number:'..type(d9))assert(cM(da),'Argument 3 (radius) must be a number:'..type(da))assert(cN(db),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(db))assert(cM(dc),'Argument 5 (GM) must be a number:'..type(dc))return setmetatable({systemId=z(d8),id=z(d9),radius=z(da),center=vec3(db),GM=z(dc)},d2)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cX(p.latitude*cV),cX(p.longitude*cV),cX(p.altitude))end;MapPosition.__eq=function(d5,d6)return d5.id==d6.id and d5.systemId==d6.systemId and ck(d5.latitude,d6.latitude)and ck(d5.altitude,d6.altitude)and(ck(d5.longitude,d6.longitude)or ck(d5.latitude,math.pi/2)or ck(d5.latitude,-math.pi/2))end;local function dd(de,d9,df,dg,dh)local d8=de;if cP(de)and not dg and not dh and not d9 and not df then d8,d9,df,dg,dh=o(de,cW)assert(d8,'Argument 1 (position string) is malformed.')else assert(cM(d8),'Argument 1 (systemId) must be a number:'..type(d8))assert(cM(d9),'Argument 2 (id) must be a number:'..type(d9))assert(cM(df),'Argument 3 (latitude) must be in degrees:'..type(df))assert(cM(dg),'Argument 4 (longitude) must be in degrees:'..type(dg))assert(cM(dh),'Argument 5 (altitude) must be in meters:'..type(dh))end;d8=z(d8)d9=z(d9)df=z(df)dg=z(dg)dh=z(dh)if d9==0 then return setmetatable({latitude=df,longitude=dg,altitude=dh,id=d9,systemId=d8},MapPosition)end;return setmetatable({latitude=cU*r(df,-90,90),longitude=cU*(dg%360),altitude=dh,id=d9,systemId=d8},MapPosition)end;local di={}di.__index=di;di.__tostring=function(c_,d3)local dj=d3 and d3 ..'  'local dk={}local d4={}for cH in pairs(c_)do table.insert(d4,cH)end;table.sort(d4)for _,dl in ipairs(d4)do bdy=c_[dl]local dm=d2.__tostring(bdy,dj)if d3 then table.insert(dk,f('[%s]={\n%s\n%s}',dl,dm,d3))else table.insert(dk,f('  [%s]=%s',dl,dm))end end;if d3 then return f('\n%s%s%s',d3,table.concat(dk,',\n'..d3),d3)end;return f('{\n%s\n}',table.concat(dk,',\n'))end;local function dn(dp)local b={}local pid;for _,cI in pairs(dp)do local d9=cI.planetarySystemId;if type(d9)~='number'then error('Invalid planetary system ID: '..tostring(d9))elseif pid and d9~=pid then error('Mistringmatch planetary system IDs: '..d9 ..' and '..pid)end;local dq=cI.bodyId;if type(dq)~='number'then error('Invalid body ID: '..tostring(dq))elseif b[dq]then error('Duplicate body ID: '..tostring(dq))end;setmetatable(cI.center,getmetatable(vec3.unit_x))b[dq]=setmetatable(cI,d2)pid=d9 end;return setmetatable(b,di)end;aQ={}local function dr(dp)return setmetatable({galaxyAtlas=dp or{}},aQ)end;aQ.__index=function(cO,i)if type(i)=='number'then local system=cO.galaxyAtlas[i]return dn(system)end;return rawget(aQ,i)end;aQ.__pairs=function(c_)return function(cO,cH)local ds,nv=next(cO,cH)return ds,nv and dn(nv)end,c_.galaxyAtlas,nil end;aQ.__tostring=function(c_)local dt={}for _,du in pairs(c_ or{})do local dv=du:getPlanetarySystemId()local dw=di.__tostring(du,'    ')table.insert(dt,f('  [%s]={%s\n  }',dv,dw))end;return f('{\n%s\n}\n',table.concat(dt,',\n'))end;aQ.BodyParameters=d7;aQ.MapPosition=dd;aQ.PlanetarySystem=dn;function aQ.createBodyParameters(d8,d9,dx,dy,dz,dA,dB)assert(cM(d8),'Argument 1 (systemId) must be a number:'..type(d8))assert(cM(d9),'Argument 2 (id) must be a number:'..type(d9))assert(cM(dx),'Argument 3 (surfaceArea) must be a number:'..type(dx))assert(cN(dy),'Argument 4 (aPosition) must be an array or vec3:'..type(dy))assert(cN(dz),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dz))assert(cM(dA),'Argument 6 (altitude) must be in meters:'..type(dA))assert(cM(dB),'Argument 7 (gravityAtPosition) must be number:'..type(dB))local da=y(dx/4/math.pi)local aj=da+dA;local dC=vec3(dy)+aj*vec3(dz)local dc=dB*aj*aj;return d7(d8,d9,da,dC,dc)end;aQ.isMapPosition=cS;function aQ:getPlanetarySystem(de)if i==nil then i=0 end;if nv==nil then nv=0 end;local d8=de;if cS(de)then d8=de.systemId end;if type(d8)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=di then system=dn(system)end;return system end end end;function di:sizeCalculator(bW)return 1.05*bW.radius end;function di:castIntersections(dD,dE,dF,dG,dH,dI)local dJ={}local dK=dH or self;for _,bW in pairs(dK)do table.insert(dJ,bW)end;if not dI then table.sort(dJ,function(dL,dM)return(dL.center-dD):len()<(dM.center-dD):len()end)end;local dN=dE:normalize()for _,bW in ipairs(dJ)do local dO=bW.center-dD;local da=self:sizeCalculator(bW)local dP=dO:dot(dN)local dQ=dP^2-(dO:len2()-da^2)if dQ>=0 then local dR=y(dQ)local bU=dP+dR;local bV=dP-dR;if bV>0 then return bW,bU,bV elseif bU>0 then return bW,bU,nil end end end;return nil,nil,nil end;function di:closestBody(dS)assert(type(dS)=='table','Invalid coordinates.')local dT,bW;local dU=vec3(dS)for _,dV in pairs(self)do local dW=(dV.center-dU):len2()if(not bW or dW<dT)and dV.name~="Space"then bW=dV;dT=dW end end;return bW end;function di:convertToBodyIdAndWorldCoordinates(de)local dX=de;if cP(de)then dX=dd(de)end;if dX.id==0 then return 0,vec3(dX.latitude,dX.longitude,dX.altitude)end;local dV=self:getBodyParameters(dX)if dV then return dX.id,dV:convertToWorldCoordinates(dX)end end;function di:getBodyParameters(de)local d9=de;if cS(de)then d9=de.id end;assert(cM(d9),'Argument 1 (id) must be a number:'..type(d9))return self[d9]end;function di:getPlanetarySystemId()local _,cI=next(self)return cI and cI.systemId end;function d2:convertToMapPosition(db)assert(cN(db),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(db))local dY=vec3(db)if self.id==0 then return setmetatable({latitude=dY.x,longitude=dY.y,altitude=dY.z,id=0,systemId=self.systemId},MapPosition)end;local dZ=dY-self.center;local aj=dZ:len()local dh=aj-self.radius;local df=0;local dg=0;if not ck(aj,0)then local d_=n(dZ.y,dZ.x)dg=d_>=0 and d_ or 2*math.pi+d_;df=math.pi/2-math.acos(dZ.z/aj)end;return setmetatable({latitude=df,longitude=dg,altitude=dh,id=self.id,systemId=self.systemId},MapPosition)end;function d2:convertToWorldCoordinates(de)local dX=cP(de)and dd(de)or de;if dX.id==0 then return vec3(dX.latitude,dX.longitude,dX.altitude)end;assert(cS(dX),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dX.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dX.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local e0=math.cos(dX.latitude)return self.center+(self.radius+dX.altitude)*vec3(e0*math.cos(dX.longitude),e0*math.sin(dX.longitude),math.sin(dX.latitude))end;function d2:getAltitude(db)return(vec3(db)-self.center):len()-self.radius end;function d2:getDistance(db)return(vec3(db)-self.center):len()end;function d2:getGravity(db)local e1=self.center-vec3(db)local e2=e1:len2()return self.GM/e2*e1/y(e2)end;return setmetatable(aQ,{__call=function(_,...)return dr(...)end})end;local function e3()local aS={}local e4=30000000/3600;local e5=e4*e4;local e6=100;function aS.computeAccelerationTime(e7,e8,e9)local ea=e4*math.asin(e7/e4)return(e4*math.asin(e9/e4)-ea)/e8 end;function aS.computeDistanceAndTime(e7,e9,eb,ec,ed,ee)ed=ed or 0;ee=ee or 0;local ef=e7<=e9;local eg=ec*(ef and 1 or-1)/eb;local eh=-ee/eb;local ei=eg+eh;if ef and ei<=0 or not ef and ei>=0 then return-1,-1 end;local ej,ek=0,0;if eg~=0 and ed>0 then local ea=math.asin(e7/e4)local el=math.pi*(eg/2+eh)local em=eg*ed;local en=e4*math.pi;local cI=function(cO)local eo=(el*cO-em*math.sin(math.pi*cO/2/ed)+en*ea)/en;local ep=math.tan(eo)return e4*ep/y(ep*ep+1)end;local eq=ef and function(cQ)return cQ>=e9 end or function(cQ)return cQ<=e9 end;ek=2*ed;if eq(cI(ek))then local er=0;while d(ek-er)>0.5 do local cO=(ek+er)/2;if eq(cI(cO))then ek=cO else er=cO end end end;local es=e7;local et=ek/e6;for eu=1,e6 do local ev=cI(eu*et)ej=ej+(ev+es)*et/2;es=ev end;if ek<2*ed then return ej,ek end;e7=es end;local ea=e4*math.asin(e7/e4)local E=(e4*math.asin(e9/e4)-ea)/ei;local ew=e5*math.cos(ea/e4)/ei;local aj=ew-e5*math.cos((ei*E+ea)/e4)/ei;return aj+ej,E+ek end;function aS.computeTravelTime(e7,e8,aj)if aj==0 then return 0 end;if e8>0 then local ea=e4*math.asin(e7/e4)local ew=e5*math.cos(ea/e4)/e8;return(e4*math.acos(e8*(ew-aj)/e5)-ea)/e8 end;if e7==0 then return-1 end;assert(e7>0,'Acceleration and initial speed are both zero.')return aj/e7 end;return aS end;local function ex()local vec3=require('cpml.vec3')local cJ=cJ()local function cP(cQ)return type(cQ)=='string'end;local function cN(cO)return type(cO)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dh)assert(self.body)local aj=dh+self.body.radius;if not ck(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(de,ey)assert(self.body)assert(cN(de)or cP(de))assert(cN(ey))local ez=(cP(de)or cJ.isMapPosition(de))and self.body:convertToWorldCoordinates(de)or vec3(de)local cI=vec3(ey)local eA=ez-self.body.center;local eB=cI:len2()local eC=eA:len()local eD=self.body.GM;local eE=((eB-eD/eC)*eA-eA:dot(cI)*cI)/eD;local cl=eD/(2*eD/eC-eB)local eF=eE:len()local dN=eE:normalize()local eG=cl*(1-eF)local eH=cl*(1+eF)local eI=eG*dN+self.body.center;local eJ=eF<=1 and-eH*dN+self.body.center or nil;local eK=y(cl*eD*(1-eF*eF))local eL=eJ and 2*math.pi*y(cl^3/eD)local eM=math.acos(eE:dot(eA)/(eF*eC))if eA:dot(cI)<0 then eM=-(eM-2*math.pi)end;local eN=math.acos((math.cos(eM)+eF)/(1+eF*math.cos(eM)))local eO=eN;if eO<0 then eO=eO+2*math.pi end;local eP=eO-eF*math.sin(eO)local eQ=0;local eR=0;local eS=0;if eL~=nil then eQ=eP/(2*math.pi/eL)eR=eL-eQ;eS=eR+eL/2;if eM-math.pi>0 then eR=eQ;eS=eR+eL/2 end;if eS>eL then eS=eS-eL end end;return{periapsis={position=eI,speed=eK/eG,circularOrbitSpeed=y(eD/eG),altitude=eG-self.body.radius},apoapsis=eJ and{position=eJ,speed=eK/eH,circularOrbitSpeed=y(eD/eH),altitude=eH-self.body.radius},currentVelocity=cI,currentPosition=ez,eccentricity=eF,period=eL,eccentricAnomaly=eN,meanAnomaly=eP,timeToPeriapsis=eR,timeToApoapsis=eS}end;local function eT(eU)local dV=cJ.BodyParameters(eU.systemId,eU.id,eU.radius,eU.center,eU.GM)return setmetatable({body=dV},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eT(...)end})end;local function eV()local eW={}local eX={}local eY={XS=13,S=27,M=55,L=110,XL=221}local eZ={}local e_;local f0;local f1;local f2;local f3;local function f4()local function f5(f6,f7,f8,f9,fa,fb,fc,fd)f7,f9,fb,fd=vec3(f7),vec3(f9),vec3(fb),vec3(fd)local fe,ff,fg=f6*f6,f8*f8,fa*fa;local eB=f9-f7;local fh=eB:normalize()local fi=eB:len()local fj=fb-f7;local fk=(fj-fj:project_on(fh)):normalize()local fl,fm=fj:dot(fh),fj:dot(fk)local fn=fl*fl+fm*fm;local fo=fh:cross(fk)local cb=(fe-ff+fi*fi)/(2*fi)local cc=(fe-fg+fn-2*fl*cb)/(2*fm)local cT=fe-cb^2-cc^2;local fp=y(cT)local fq=f7+fh*cb+fk*cc+fo*fp;local fr=f7+fh*cb+fk*cc-fo*fp;if d((fd-fq):len()-fc)<d((fd-fr):len()-fc)then return fq else return fr end end;local function fs()local function ft()local fu=core.getConstructWorldOrientationRight()local eB=core.getConstructWorldOrientationForward()local fj=core.getConstructWorldOrientationUp()local fv=library.systemResolution3(fu,eB,fj,{1,0,0})local fw=library.systemResolution3(fu,eB,fj,{0,1,0})local fx=library.systemResolution3(fu,eB,fj,{0,0,1})return function(fy)return library.systemResolution3(fv,fw,fx,fy)end end;local fz=ft()local fA=core.getConstructWorldPos()local ez=core.getElementPositionById(1)local fB={ez[1],ez[2],ez[3]}local fC=fz(fB)local fD={fA[1]-fC[1],fA[2]-fC[2],fA[3]-fC[3]}return fD end;local function fE(fF,eC,fG)local fH=fF.pts;local fI=#fH;local fJ=fF.ref;if fI>3 then local fK,fL,fM,fN=fH[fI],fH[fI-1],fH[fI-2],fH[fI-3]fF.ref=fG;local ez=f5(fK[1],fK[2],fL[1],fL[2],fM[1],fM[2],fN[1],fN[2])local cb,cc,fp=ez.x,ez.y,ez.z;if cb==cb and cc==cc and fp==fp then cb=cb+fJ[1]cc=cc+fJ[2]fp=fp+fJ[3]local fO=vec3(cb,cc,fp)if not fF.lastPos then fF.center=fO elseif(fF.lastPos-fO):len()<2 then fF.center=fO;fF.skipCalc=true end;fF.lastPos=fO end;fF.pts={}else local fP={fG[1]-fJ[1],fG[2]-fJ[2],fG[3]-fJ[3]}fH[fI+1]={eC,fP}end end;if bP[1]then e_=#bP[1].getConstructIds()local fQ=bP[1].getData()local fR=fQ:gmatch('{"constructId[^}]*}[^}]*}')if e_>0 then local fG=fs()local fS,fT=0,0;f3,f2=0,0;for cI in fR do local d9,aj,fU=cI:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fV=eY[fU]aj=z(aj)if bP[1].hasMatchingTransponder(d9)==1 then table.insert(eX,d9)end;local fW=bP[1].getConstructType(d9)if CollisionSystem then if fV>27 or fW=="static"or fW=="space"then f3=f3+1;local fX=bP[1].getConstructName(d9)local fF=bL[d9]if fF==nil then fV=fV+G;bL[d9]={pts={},ref=fG,name=fX,i=0,radius=fV,skipCalc=false}fF=bL[d9]end;if not fF.skipCalc then fE(fF,aj,fG)fT=fT+1 end;if fF.center then table.insert(eZ,fF)end end;fS=fS+1;if bM and fS>700 or fT>70 or(not bM and fS>300 or fT>30)then coroutine.yield()fS,fT=0,0 end end end;f2=#eZ;if f2>0 and bs>20 then local bW,fY,fZ,f_;local g0=0;local g1=aR:getPlanetarySystem(0)f_=br:normalize()while g0<f2 do coroutine.yield()local g2={table.unpack(eZ,g0,math.min(g0+75,f2))}bW,fY,fZ=g1:castIntersections(bv,f_,nil,nil,g2,true)if bW and fZ then bO={bW,fY,fZ}break end;g0=g0+75 end;if not bW then bO=nil end else bO=nil end;eZ={}f0=fQ:find('identifiedConstructs":%[%]')else f1=fQ:find('worksInEnvironment":false')end end end;function eW.assignRadar()if bP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 else bP[1]=nil end elseif bP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 else bP[1]=nil end end end;function eW.UpdateRadar()local g3=coroutine.status(UpdateRadarCoroutine)if g3=="suspended"then local ch,g4=coroutine.resume(UpdateRadarCoroutine)if g4 then system.print("ERROR UPDATE RADAR: "..g4)end elseif g3=="dead"then UpdateRadarCoroutine=coroutine.create(f4)local ch,g4=coroutine.resume(UpdateRadarCoroutine)end end;function eW.GetRadarHud()local g5=eX;eX={}return f0,f1,e_,f2,f3,g5 end;UpdateRadarCoroutine=coroutine.create(f4)return eW end;local function g6()local g7=9.80665;local g8=vec3({13771471,7435803,-128971})local g9=18000000;local ga=500000;local gb,gc=math.huge;local gd;local function ge(gf)gb=vec3(gf):dist(g8)if gb<g9 then return true,d(gb-g9)end;gc=vec3(gf):dist(vec3(planet.center))if gc<ga then gd=true else gd=false end;if d(gc-ga)<d(gb-g9)then return gd,d(gc-ga)else return gd,d(gb-g9)end end;local function gg(cI)if aG==1920 then return cI else return A(aG*cI/1920,0)end end;local function gh(cI)if aH==1080 then return cI else return A(aH*cI/1080,0)end end;local function gi()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gj()local gk="TRAVEL"if not bA then gk="CRUISE"end;if Autopilot then gk="AUTOPILOT"end;return gk end;local gl=""local gm=""local gn=""local go=1;local gp=2;local gq=3;local gr=4;local gs=5;local gt=6;local gu=""local gv=0;local gw=e(1/apTickRate)*2*hudTickRate;local gx={}local gy={}local gz={}local gA={}local gB={}local gC={}local function gD(cb,gE,gF,gG,gH,gI)local gJ=fuelY;local gK=fuelY+5;if not BarFuelDisplay then gK=gK+5 end;if m()==1 and not RemoteHud then gJ=gJ-50;gK=gK-50 end;if gF=="ATMO"then gu="atmofueltank"elseif gF=="SPACE"then gu="spacefueltank"else gu="rocketfueltank"end;gv=_G[gu.."_size"]if#gG>0 then for i=1,#gG do local fX=string.sub(gG[i][gp],1,12)local gL=0;for gM=1,gv do if gG[i][gp]==g(unit[gu.."_"..gM].getData()).name then gL=gM;break end end;local gN=q()if gH[i]==nil or gI[i]==nil or gN-gG[i][gt]>gw then local gO;local gP=0;if gL~=0 then gI[i]=g(unit[gu.."_"..gL].getData()).percentage;gH[i]=g(unit[gu.."_"..gL].getData()).timeLeft;if gH[i]=="n/a"then gH[i]=0 end else gP=l(gG[i][go])-gG[i][gr]gI[i]=e(0.5+gP*100/gG[i][gq])gO=gG[i][gs]if gO<=gP then gH[i]=0 else gH[i]=e(0.5+gP/((gO-gP)/(gN-gG[i][gt])))end;gG[i][gs]=gP;gG[i][gt]=gN end end;if fX==gE then fX=f("%s %d",gF,i)end;if gL==0 then fX=fX.." *"end;local gQ;if gH[i]==0 then gQ=""else gQ=cy(gH[i])end;if gI[i]~=nil then local gR=e(gI[i]*2.55)local gS=f("rgb(%d,%d,%d)",255-gR,gR,0)local ce=""if gQ~=""and gH[i]<120 or gI[i]<5 then ce="red "end;if BarFuelDisplay then gm=gm..f([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cb,gK,gS,gI[i],cb,gK,cb+2,gK+10,gI[i],gQ)gm=gm..ca(cb,gJ,fX,ce.."txtstart pdim txtfuel")gJ=gJ-30;gK=gK-30 else gm=gm..ca(cb,gJ,fX,ce.."pdim txtfuel")gm=gm..ca(cb,gK,f("%d%% %s",gI[i],gQ),"pdim txtfuel","fill:"..gS)gJ=gJ+30;gK=gK+30 end end end end end;local function gT(gU,dh)if dh<200000 and not aq or dh and aq then local gV=0;if d(bu)>1 then gV=45*math.log(d(bu),10)if bu<0 then gV=-gV end end;gU[#gU+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(gV))end;return gU end;local function gW(gX)local gY=-bt;gX=gX-gX:project_on(gY)local gZ=vec3(0,0,1)gZ=gZ-gZ:project_on(gY)local g_=gZ:cross(gY)local gV=gZ:angle_between(gX)*constants.rad2deg;if gX:dot(g_)<0 then gV=360-gV end;return gV end;local function h0(gU,centerX,centerY,h1,h2,bM)local h3=circleRad;local h4=20;local h5=e(h1)if bM then for i=-45,45,5 do local h6=i;gU[#gU+1]=f([[<g transform="rotate(%f,%d,%d)">]],h6,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gU[#gU+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h3+h4-len,centerX,centerY+h3+h4)end;gU[#gU+1]=ca(centerX,centerY+h3+h4-35,h2,"pdim txt txtmid")gU[#gU+1]=ca(centerX,centerY+h3+h4-25,h5 .." deg","pdim txt txtmid")gU[#gU+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h1,centerX,centerY)gU[#gU+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h3+h4-20,centerX+5,centerY+h3+h4-20,centerX,centerY+h3+h4-15)gU[#gU+1]="</g>"end;local h7=h5;if bM then h7=gW(bo)end;local h8=20;local h9=e(h7)local ha=0;local hb=centerY+h3+h4+20;local hc=centerX;if h2~="YAW"then hb=gh(130)hc=gg(960)end;local hd=[[<path class="txttick line" d="]]local he=e(h9-(h8+10)-h9%5+0.5)for i=he+60,he,-5 do local cb=hc-(-i*5+h7*5)if i%10==0 then ha=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gU[#gU+1]=ca(cb+5,hb-12,B)elseif i%5==0 then ha=5 end;if ha==10 then hd=f([[%s M %f %f v %d]],hd,cb,hb-5,ha)else hd=f([[%s M %f %f v %d]],hd,cb,hb-2.5,ha)end end;gU[#gU+1]=hd..[["/>]]gU[#gU+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],hc-5,hb+10,hc+5,hb+10,hc,hb+5)if bM then h2="HDG"end;gU[#gU+1]=ca(hc,hb+25,h9 .."deg","pdim txt txtmid","")gU[#gU+1]=ca(hc,hb+35,h2,"pdim txt txtmid","")end;local function hf(gU,hg,h1,centerX,centerY,bM,hh,ev)local h3=circleRad;local hi=e(h3*3/5)if h3>0 then local hj=e(hg)local len=0;local hd=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h1,centerX,centerY)if not aq then hd=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gU[#gU+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h3-1,centerX,centerY)gU[#gU+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hj-30-hj%5+0.5),e(hj+30+hj%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cc=centerY+-i*5+hg*5;if len==30 then hd=f([[%s M %d %f h %d]],hd,centerX-hi-len,cc,len)if aq then gU[#gU+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h1,centerX,centerY,centerX-hi+10,cc,i)gU[#gU+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h1,centerX,centerY,centerX+hi-10,cc,i)if i==0 or i==180 or i==-180 then gU[#gU+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h1,centerX,centerY,centerX-hi+20,cc,hi*2-40)end else gU[#gU+1]=ca(centerX-hi+10,cc,i,"pdim txt txtmid")gU[#gU+1]=ca(centerX+hi-10,cc,i,"pdim txt txtmid")end;hd=f([[%s M %d %f h %d]],hd,centerX+hi,cc,len)else hd=f([[%s M %d %f h %d]],hd,centerX-hi-len,cc,len)hd=f([[%s M %d %f h %d]],hd,centerX+hi,cc,len)end end;gU[#gU+1]=hd..[["/>]]local hk="PITCH"if not bM then hk="REL PITCH"end;if hg>90 and not aq then hg=90-(hg-90)elseif hg<-90 and not aq then hg=-90-(hg+90)end;if h3>200 then if aq then if ev>Q then gU[#gU+1]=ca(centerX,centerY-15,"Yaw","pdim txt txtmid")gU[#gU+1]=ca(centerX,centerY+20,hh,"pdim txt txtmid")end;gU[#gU+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h1,centerX,centerY)else gU[#gU+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gU[#gU+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hi+25,centerY-5,centerX-hi+20,centerY,centerX-hi+25,centerY+5,centerX-hi+50,centerY+4,hj)gU[#gU+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hi-25,centerY-5,centerX+hi-20,centerY,centerX+hi-25,centerY+5,centerX+hi-30,centerY+4,hj)gU[#gU+1]="</g>"end;local hl=e(h3/3)gU[#gU+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hl,centerY,h3-hl)if not aq and bM then gU[#gU+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h1,centerX,centerY,centerX-hi+10,centerY,hi*2-20)end;gU[#gU+1]="</g>"if h3<200 then if aq and ev>Q then gU[#gU+1]=ca(centerX,centerY-h3,hk,"pdim txt txtmid")gU[#gU+1]=ca(centerX,centerY-h3+10,hj,"pdim txt txtmid")gU[#gU+1]=ca(centerX,centerY-15,"Yaw","pdim txt txtmid")gU[#gU+1]=ca(centerX,centerY+20,hh,"pdim txt txtmid")else gU[#gU+1]=ca(centerX,centerY-h3,hk,"pdim txt txtmid")gU[#gU+1]=ca(centerX,centerY-h3+15,hj,"pdim txt txtmid")end end end end;local function hm(gU,dh,bM)local hn=altMeterX;local ho=altMeterY;local hp=78;local hq=19;local hr=ao;if ao~=-1 then gU[#gU+1]=ca(hn+hp,ho+hq+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dh<200000 and not aq or dh and aq)then table.insert(gU,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hn-1,ho-4,hp+2,hq+6,hn+1,ho-1,hp-4,hq))local fI=0;local hs=1;local ht=0;local hu=dh<0;local hv=dh<planet.surfaceMaxAltitude;local hw=9;if hu then hw=0 end;local dh=d(dh)while fI<6 do local hx=11;local hy=16;local hz=9;local hA=14;local ce="altsm"if fI>2 then hy=hy+3;hx=hx+2;hA=hA+2;hz=hz-6;ce="altbig"end;if hu then ce=ce.." red"elseif hv then ce=ce.." orange"end;local hB=dh/hs%10;local hC=e(hB)local hD=e((hC+1)%10)local hE=ht;if fI==0 then hE=hB-hC;if hu then hE=1-hE end end;if hu and(fI==0 or ht~=0)then local hF=hD;hD=hC;hC=hF end;local hG=hy*(hE-1)local hH=hG+hy;local cb=hn+hz+(6-fI)*hx;local cc=ho+hA;gU[#gU+1]=ca(cb,cc+hG,hD,ce)gU[#gU+1]=ca(cb,cc+hH,hC,ce)fI=fI+1;hs=hs*10;if hC==hw then ht=hE else ht=0 end end;table.insert(gU,[[</g></g>]])end end;local function hI(ey)local hJ=-math.deg(n(ey.y,ey.z))+180;hJ=hJ-90;if hJ<0 then hJ=360+hJ end;if hJ>180 then hJ=-180+hJ-180 end;return-hJ end;local function hK(ey)local h7=math.deg(n(ey.y,ey.x))-90;if h7<-180 then h7=360+h7 end;return h7 end;local function hL(gU,ey,ev,centerX,centerY)if ev>5 and not aq or ev>Q then local h3=circleRad;local hM=20;local hN=20;local hO=hI(ey)local hP=hK(ey)local hQ=14;local hR=hQ/2;local hS=-hP/hN*h3;local hT=hO/hM*h3;local cb=centerX+hS;local cc=centerY+hT;local aj=y(hS^2+hT^2)local hU=[[<circle
                            cx="]]..cb..[["
                            cy="]]..cc..[["
                            r="]]..hR/hQ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cb..[["
                            cy="]]..cc..[["
                            r="]]..hR..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cb-hQ..[[,]]..cc..[[ h ]]..hR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cb+hR..[[,]]..cc..[[ h ]]..hR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cb..[[,]]..cc-hQ..[[ v ]]..hR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<h3 then gU[#gU+1]=hU else local gV=n(hT,hS)local hV=4;local hW=centerX+h3*math.cos(gV)local hX=centerY+h3*math.sin(gV)gU[#gU+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gV*180/math.pi,hW,hX,hW-hV,hX-hV/2,hV*2,hV,hW+hV,hX-hV,hV,hV,-hV,hV)end;if not aq then local hY=vec3(ey)hO=hI(-hY)hP=hK(-hY)hS=-hP/hN*h3;hT=hO/hM*h3;cb=centerX+hS;cc=centerY+hT;aj=y(hS^2+hT^2)if aj<h3 then local hZ=[[<circle
                                    cx="]]..cb..[["
                                    cy="]]..cc..[["
                                    r="]]..hR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cb..[[,]]..cc-hQ..[[ v ]]..hR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cb..[[,]]..cc..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cb..[[,]]..cc..[[)" />
                                <path
                                    d="M ]]..cb-hR..[[,]]..cc..[[ h ]]..hQ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cb..[[,]]..cc..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cb..[[,]]..cc..[[)"/>]]gU[#gU+1]=hZ end end end end;local function h_(gU,gk,i0,i1)i0=e(i0+0.5)local gJ=throtPosY+10;local gK=throtPosY+20;if m()==1 and not RemoteHud then gJ=55;gK=65 end;local i2="CRUISE"local unit="km/h"local ch=i1;if gk=="TRAVEL"or gk=="AUTOPILOT"then i2="THROT"unit="%"ch=i0;local i3="dim"if i0<0 then i3="red"end;gU[#gU+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i3,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(i0),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gU[#gU+1]=ca(throtPosX+10,gJ,i2,"pbright txtstart")gU[#gU+1]=ca(throtPosX+10,gK,f("%.0f %s",ch,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then i0=e(N*100+0.5)local i3="red"if i0<0 then i3="red"end;gU[#gU+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i3,1-d(i0),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gU[#gU+1]=ca(throtPosX+10,gJ+40,"LIMIT","pbright txtstart")gU[#gU+1]=ca(throtPosX+10,gK+40,i0 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gU[#gU+1]=ca(throtPosX+10,gJ-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then gU[#gU+1]=ca(throtPosX+10,gJ-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i4(gU,i5)local i6=throtPosY-10;local i7=throtPosX+10;gU[#gU+1]=ca(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then i6=75 end;gU[#gU+1]=ca(i7,i6,e(i5).." km/h","pbright txtbig txtstart")end;local function i8(gU)gU[#gU+1]=ca(gg(1900),gh(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gU[#gU+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gU[#gU+1]=ca(gg(960),gh(550),"Warning: Invalid Control Scheme Detected","warnings")gU[#gU+1]=ca(gg(960),gh(600),"Keyboard Scheme must be selected","warnings")gU[#gU+1]=ca(gg(960),gh(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local i9=gg(960)local ia=gh(860)local ib=gh(880)local ic=gh(900)local id=gh(960)local ie=gh(200)local ig=gh(250)local ih=gh(960)if m()==1 and not RemoteHud then ia=gh(135)ib=gh(155)ic=gh(175)ie=gh(115)ig=gh(95)end;if BrakeIsOn then gU[#gU+1]=ca(i9,ia,"Brake Engaged","warnings")elseif L>0 then gU[#gU+1]=ca(i9,ia,"Auto-Brake Engaged","warnings","opacity:"..L)end;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then gU[#gU+1]=ca(i9,ie+50,"** STALL WARNING **","warnings")bY("stall","SW",2)end end;if bK then gU[#gU+1]=ca(i9,ie+90,"Flight Assist in Progress","warnings")end;if ax then gU[#gU+1]=ca(i9,ih,"Gyro Enabled","warnings")end;if GearExtended then if S then gU[#gU+1]=ca(i9,ib,"Gear Extended","warn")else gU[#gU+1]=ca(i9,ib,"Landed (G: Takeoff)","warnings")end;local ii=cn(a:getTargetGroundAltitude())gU[#gU+1]=ca(i9,ic,"Hover Height: "..ii,"warn")end;if a7 then gU[#gU+1]=ca(i9,id+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then if d(as-antigrav.getBaseAltitude())<501 then gU[#gU+1]=ca(i9,ie+15,f("AGG On - Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gU[#gU+1]=ca(i9,ie+15,f("AGG On - Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gU[#gU+1]=ca(i9,ie+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gU[#gU+1]=ca(i9,ie+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gU[#gU+1]=ca(i9,ie+20,"Follow Mode Engaged","warn")elseif Reentry or an then gU[#gU+1]=ca(i9,ie+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ii=cn(HoldAltitude,2)if VertTakeOff then if by then ii=cn(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gU[#gU+1]=ca(i9,ie,"VTO to "..ii,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gU[#gU+1]=ca(i9,ie,"Takeoff to "..AutopilotTargetName,"warn")else gU[#gU+1]=ca(i9,ie,"Takeoff to "..ii,"warn")end;if BrakeIsOn and not VertTakeOff then gU[#gU+1]=ca(i9,ie+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gU[#gU+1]=ca(i9,ie,"Altitude Hold: "..ii,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gU[#gU+1]=ca(i9,ie+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gU[#gU+1]=ca(i9,ie+20,"Aligning trajectory","warn")elseif ar<0.05 then gU[#gU+1]=ca(i9,ie+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then gU[#gU+1]=ca(i9,ie,b9,"warn")end end;if BrakeLanding then if StrongBrakes then gU[#gU+1]=ca(i9,ie,"Brake-Landing","warnings")else gU[#gU+1]=ca(i9,ie,"Coast-Landing","warnings")end end;if ProgradeIsOn then gU[#gU+1]=ca(i9,ie,"Prograde Alignment","crit")end;if RetrogradeIsOn then gU[#gU+1]=ca(i9,ie,"Retrograde Alignment","crit")end;if bN then local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;gU[#gU+1]=ca(i9,ig+20,bN,type)elseif ar==0 then local bT,bX=bR(br:normalize())if bX~=nil then local ii=cn(bX)local travelTime=aS.computeTravelTime(bs,0,bX)local ij="Collision"if bT.noAtmosphericDensityAltitude>0 then ij="Atmosphere"end;gU[#gU+1]=ca(i9,ig+20,bT.name.." "..ij.." "..cy(travelTime).." In "..ii,"crit")end end;if VectorToTarget and not IntoOrbit then gU[#gU+1]=ca(i9,ie+35,VectorStatus,"warn")end;gU[#gU+1]="</g>"return gU end;local function ik(ev)return e(A(ev*3.6,0)+0.5).." km/h"end;local function il(gU)local im=OrbitMapX;local io=OrbitMapY;local ip=OrbitMapSize;local iq=4;local ir=15;local cb=0;local cc=0;local is,it,iu,iv;local function iw(type)local ix,E,ev,iy;if type=="Periapsis"then ix=orbit.periapsis.altitude;E=orbit.timeToPeriapsis;ev=orbit.periapsis.speed;iy=35 else ix=orbit.apoapsis.altitude;E=orbit.timeToApoapsis;ev=orbit.apoapsis.speed;iy=-35 end;gU[#gU+1]=f([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cb+iy,cc-5,im+ip/2-is+iv,cc-5)gU[#gU+1]=ca(cb,cc,type)cc=cc+ir;local ii=cn(ix)gU[#gU+1]=ca(cb,cc,ii)cc=cc+ir;gU[#gU+1]=ca(cb,cc,cy(E))cc=cc+ir;gU[#gU+1]=ca(cb,cc,ik(ev))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then io=io+iq;cb=im+ip+im/2+iq;cc=io+ip/2+5+iq;is=ip/4;iv=0;gU[#gU+1]=[[<g class="pbright txtorb txtmid">]]gU[#gU+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',ip+im*2,ip+io,iq,iq)if orbit.periapsis~=nil and orbit.apoapsis~=nil then iu=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(is*2)it=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/iu*(1-orbit.eccentricity)iv=is-orbit.periapsis.altitude/iu-planet.radius/iu;local iz=""if orbit.periapsis.altitude<=0 then iz='redout'end;gU[#gU+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iz,im+ip/2+iv+iq,io+ip/2+iq,is,it)gU[#gU+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',im+ip/2+iq,io+ip/2+iq,planet.radius/iu)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iw("Apoapsis")end;cc=io+ip/2+5+iq;cb=im-im/2+10+iq;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iw("Periapsis")end;gU[#gU+1]=ca(im+ip/2+iq,planet.name,20+iq,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iA=orbit.timeToApoapsis/orbit.period*2*math.pi;local iB=is*math.cos(iA)local iC=it*math.sin(iA)gU[#gU+1]=f('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',im+ip/2+iB+iv+iq,io+ip/2+iC+iq)end;gU[#gU+1]=[[</g>]]return gU else return gU end end;local function iD(iE,iF)local iG;local iH=(iF-iE):normalize()local eA=(bv-iE):dot(iH)/iH:dot(iH)if eA<=0.then return(bv-iE):len()elseif eA>=(iF-iE):len()then return(bv-iF):len()end;local iI=iE+eA*iH;iG=(iI-bv):len()return iG end;local function iJ()local iG;local iK=nil;local iL=nil;local iM=nil;for cH,iN in pairs(b[0])do if iN.hasAtmosphere then local aj=iD(planet.center,iN.center)if iK==nil or aj<iK then iL=iN;iK=aj;iM=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dW=iD(ac.center,iN.center)if dW<iK then iL=iN;iK=dW;iM=ac end end end end;local iO=gg(1770)local iP=gh(330)if iK then local iQ="txttick "local iR=500000;if iK<iL.radius+iR or iK<iM.radius+iR then if bH then iQ="txttick red "else iQ="txttick orange "end end;iG=cn(iK,2)bJ=ca(iO,iP,"Pipe ("..iM.name.."--"..iL.name.."): "..iG,iQ.."pbright txtmid")end end;local iS={}function iS.HUDPrologue(gU)bH,bI=ge(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local iT=ay;local iU=az;local iV=ay;local iW=az;if gi()and not brightHud then iT=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.3+0.5)..[[)]]iU=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;gU[#gU+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],iT,iT,iV,iV,iU,iU,iW,iW,aG,aH)return gU end;function iS.DrawVerticalSpeed(gU,dh)gT(gU,dh)end;function iS.UpdateHud(gU)local hJ=bB;local iX=bC;local h1=iX;local hg=hJ;local i0=e(unit.getThrottle())local i5=bs*3.6;local i1=unit.getAxisCommandValue(0)local iY=gg(1770)local iZ=gh(310)if AtmoSpeedAssist and bA then i1=K;i0=K*100 end;local gk=gj()local h2="ROLL"if i0==nil then i0=0 end;if not bM then if bs>5 then hJ=hI(bq)iX=hK(bq)else hJ=0;iX=0 end;h2="YAW"end;if bI>50000 and not aq then local i_;i_=cn(bI)gU[#gU+1]=ca(iY,iZ,"PvP Boundary: "..i_,"pbright txtbig txtmid")end;gU[#gU+1]=ak;gU[#gU+1]=aD;gU[#gU+1]=gl;if bJ~=""then gU[#gU+1]=bJ end;if gm~=""then gU[#gU+1]=gm end;if gn~=""then gU[#gU+1]=gn end;gT(gU,as)if m()==0 or RemoteHud then if not gi()or brightHud then if bM then h0(gU,centerX,centerY,h1,h2,bM)hf(gU,hg,h1,centerX,centerY,bM,e(hK(bq)),bs)else h0(gU,centerX,centerY,iX,h2,bM)hf(gU,hJ,iX,centerX,centerY,bM,e(iX),bs)end;hm(gU,as,bM)hL(gU,bq,bs,centerX,centerY)end end;h_(gU,gk,i0,i1)i4(gU,i5)i8(gU)il(gU)return gU end;function iS.HUDEpilogue(gU)gU[#gU+1]="</svg>"return gU end;function iS.ExtraData(gU)local j0=gg(1240)local j1=gh(55)local j2=j1+10;local j3;local j4=0;local gk=gj()if VertTakeOffEngine then gk=gk.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bs>20 then gk=gk.."-COLLISION ON"end;if UseExtra~="Off"then gk="("..UseExtra..")-"..gk end;if TurnBurn then gk="TB-"..gk end;if not stablized then gk=gk.."-DeCoupled"end;local j5=vec3(core.getWorldAcceleration()):len()/9.80665;j3=core.g()gU[#gU+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then j0=gg(1120)j1=gh(55)j2=j1+10 elseif aq then local j6=gg(770)gU[#gU+1]=ca(j6,j1,"ATMOSPHERE","pdim txt txtend")gU[#gU+1]=ca(j6,j2,f("%.2f",ar),"pdim txt txtend","")end;gU[#gU+1]=ca(j0,j1,"GRAVITY","pdim txt txtend")gU[#gU+1]=ca(j0,j2,f("%.2f",j3/9.80665),"pdim txt txtend")gU[#gU+1]=ca(j0,j1+20,"ACCEL","pdim txt txtend")gU[#gU+1]=ca(j0,j2+20,f("%.2f",j5),"pdim txt txtend")gU[#gU+1]=ca(gg(960),gh(180),gk,"txtbig txtmid")end;function iS.DrawOdometer(gU,ad,TotalDistanceTravelled,ae)local j3;local j7=0;local j8=0;local j4=0;local j9=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then j4=LastMaxBrakeInAtmo else j4=LastMaxBrake end;local ja,jb=aS.computeDistanceAndTime(bs,0,av,0,0,j4)j4=A(j4/(av*g7),2).." g"local jc=a:maxForceForward()j3=core.g()if j3>0.1 then j8=av*j3;j8=A(j8/(av*g7),2).." g"j7=0.5*jc/j3;j7=j7>1000000 and A(j7/1000000,2).." kTons"or A(j7/1000,2).." Tons"end;jc=A(jc/(av*g7),2).." g"gU[#gU+1]=f([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gg(660),gg(700),gh(35),gg(960),gh(55),gg(1240),gh(35),gg(1280))if m()==0 or RemoteHud then gU[#gU+1]=ca(gg(700),gh(10),f("BrkTime: %s",cy(jb)),"txtstart")gU[#gU+1]=ca(gg(700),gh(20),f("Trip: %.2f km",ad),"txtstart")gU[#gU+1]=ca(gg(700),gh(30),f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gU[#gU+1]=ca(gg(830),gh(10),f("BrkDist: %s",cn(ja)),"txtstart")gU[#gU+1]=ca(gg(830),gh(20),"Trip Time: "..cy(ae),"txtstart")gU[#gU+1]=ca(gg(830),gh(30),"Total Time: "..cy(TotalFlightTime),"txtstart")gU[#gU+1]=ca(gg(970),gh(20),f("Mass: %s",j9),"txtstart")gU[#gU+1]=ca(gg(1240),gh(10),f("Max Brake: %s",j4),"txtend")gU[#gU+1]=ca(gg(1240),gh(30),f("Max Thrust: %s",jc),"txtend")if j3>0.1 then gU[#gU+1]=ca(gg(970),gh(30),f("Max Thrust Mass: %s",j7),"txtstart")gU[#gU+1]=ca(gg(1240),gh(20),f("Req Thrust: %s",j8),"txtend")else gU[#gU+1]=ca(gg(970),gh(30),"Max Mass: n/a","txtstart")gU[#gU+1]=ca(gg(1240),gh(20),"Req Thrust: n/a","txtend")end end;gU[#gU+1]="</g>"return gU end;function iS.DrawWarnings(gU)return i8(gU)end;function iS.DisplayOrbitScreen(gU)return il(gU)end;function iS.DisplayMessage(gU,ii)if ii~="empty"then local cc=310;for jd in string.gmatch(ii,"([^\n]+)")do cc=cc+35;gU[#gU+1]=ca("50%",cc,jd,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function iS.DrawDeadZone(gU)gU[#gU+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function iS.UpdatePipe()if aq then bJ=""return end;iJ()end;function iS.DrawSettings(gU)if#bE>0 then local cb=gg(640)local cc=gh(200)gU[#gU+1]=[[<g class="pbright txtvspd txtstart">]]for cH,cI in pairs(bE)do gU[#gU+1]=ca(cb,cc,cI..": ".._G[cI])cc=cc+20;if cH%12==0 then cb=cb+gg(350)cc=gh(200)end end;gU[#gU+1]=ca(gg(640),gh(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gU[#gU+1]="</g>"end;return gU end;local je;local jf=gg(1770)local jg=gh(350)local jh=gh(15)local ji=gg(1370)local bQ,jj;local jk=0;function iS.DrawRadarInfo()local function jl()if radarPanelID~=nil and jk==0 then t(radarPanelID)radarPanelID=nil;if je~=nil then t(je)je=nil end else if jk==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")je=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;jk=0 end end;local f0,f1,e_,f2,f3,eX=aY.GetRadarHud()local B=f2 or 0;if e_>0 then if CollisionSystem then bQ=B.."/"..f3 .." Plotted : "..e_-f3 .." Ignored"else bQ="Radar Contacts: "..e_ end;gl=ca(jf,jg,bQ,"pbright txtbig txtmid")if#eX>0 then gl=gl..ca(ji,jh,"Friendlies In Range","pbright txtbig txtmid")for cH,cI in pairs(eX)do jh=jh+20;gl=gl..ca(ji,jh,bP[1].getConstructName(cI),"pdim txtmid")end end;if f0==nil and je==nil then jk=1;jl()end;if f0~=nil and je~=nil then jl()end;if radarPanelID==nil then jl()end else if f1 then gl=ca(jf,jg,"Radar: Jammed","pbright txtbig txtmid")else gl=ca(jf,jg,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then jk=0;jl()end end end;function iS.DrawTanks()if fuelX~=0 and fuelY~=0 then gm=ca(fuelX,fuelY,"","txtstart pdim txtfuel")gD(fuelX,"Atmospheric ","ATMO",aI,gB,gC)gD(fuelX+120,"Space fuel t","SPACE",aJ,gz,gA)gD(fuelX+240,"Rocket fuel ","ROCKET",aK,gx,gy)end end;function iS.DrawShield()local jm=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local jn=core.getPvPTimer()local jo=shield_1.getResistances()local jp="A: "..10+jo[1]*100 .."% / E: "..10+jo[2]*100 .."% / K:"..10+jo[3]*100 .."% / T: "..10+jo[4]*100 .."%"local cb,cc=shieldX-60,shieldY+30;local jq=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gR=e(jq*2.55)local gS=f("rgb(%d,%d,%d)",255-gR,gR,0)local ce=""gn=ca(cb,cc,"","txtmid pdim txtfuel")if jq<10 and jm~="Shield Disabled"then ce="red "end;jn=jn>0 and"   PvPTime: "..cy(jn)or""gn=gn..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],cb,cc,gS,jq*2,cb,cc,cb+2,cc+10,jq,jn)gn=gn..ca(cb,cc-5,jm,ce.."txtstart pbright txtbig")gn=gn..ca(cb,cc+30,jp,ce.."txtstart pbright txtsmall")end;return iS end;local function jr()local function js(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function jt()local function ju(jv,jw)return jv.name<jw.name end;bG={}for cH,cI in pairs(b[0])do bG[#bG+1]={name=cI.name,index=cH}end;table.sort(bG,ju)end;local function jx(jy)for cH,cI in pairs(jy)do if cI.name and cI.name==CustomTarget.name then return cH end end;return-1 end;local function jz()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local jA=bG[AutopilotTargetIndex].index;local jB=b[0][jA]if jB.center then AutopilotTargetName=jB.name;ac=aR[0][jA]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jB;for _,cI in pairs(aR[0])do if cI.name==CustomTarget.planetname then ac=cI;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jC(gY)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if gY==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then jz()else local jA=bG[AutopilotTargetIndex].index;local jB=b[0][jA]if jB~=nil and jB.name=="Space"or iphCondition=="Custom Only"and jB.center or iphCondition=="No Moons"and string.find(jB.name,"Moon")~=nil then if gY==nil then jC()else jC(1)end else jz()end end else a2="Disengage autopilot before changing Interplanetary Helper"bY("iph","AP")end end;local function jD()local fI=-1;fI=jx(b[0])if fI>-1 then table.remove(b[0],fI)end;fI=-1;fI=jx(SavedLocations)if fI~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fI)end;jC()jt()end;local function jE(fX,position,hF,jF)if dbHud_1 or hF then local p=js(position)local j3=p.gravity;if jF then j3=unit.getClosestPlanetInfluence()end;local jG={position=position,name=fX,planetname=p.name,gravity=j3,safe=jF}if not hF then SavedLocations[#SavedLocations+1]=jG else for cH,cI in pairs(b[0])do if cI.name and fX==cI.name then table.remove(b[0],cH)end end end;table.insert(b[0],jG)jt()jz()a2="Location saved as "..fX.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local jH={}function jH.UpdateAtlasLocationsList()jt()end;function jH.UpdateAutopilotTarget()jz()end;function jH.adjustAutopilotTargetIndex(gY)jC(gY)end;function jH.findAtlasIndex(jy)jx(jy)end;function jH.UpdatePosition(jI)local fI=jx(SavedLocations)if fI~=-1 then if jI~=nil then SavedLocations[fI].name=jI;AutopilotTargetIndex=AutopilotTargetIndex-1;jC()else local jJ=SavedLocations[fI]jJ.gravity=unit.getClosestPlanetInfluence()jJ.position=bv;jJ.safe=true end;a2=SavedLocations[fI].name.." position updated ("..SavedLocations[fI].planetname..")"else a2="Name Not Found"end end;function jH.AddNewLocation(fX,position,hF,jF)jE(fX,position,hF,jF)end;function jH.ClearCurrentPosition()jD()end;for cH,cI in pairs(SavedLocations)do table.insert(b[0],cI)end;jt()jH.UpdateAutopilotTarget()return jH end;local function jK()local jL={}local function jM(ev)local jN=AutopilotEndSpeed;if not Autopilot then jN=0 end;if not aq then return aS.computeDistanceAndTime(ev,jN,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(ev,jN,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jO(ev)local jN=AutopilotEndSpeed;if not Autopilot then jN=0 end;return aS.computeDistanceAndTime(ev,jN,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local jP=false;function jL.GetAutopilotBrakeDistanceAndTime(ev)return jM(ev)end;function jL.GetAutopilotTBBrakeDistanceAndTime(ev)return jO(ev)end;local function jQ(jR,jS,jT)jS=jS:project_on_plane(jR)jT=jT:project_on_plane(jR)return n(jS:cross(jT):dot(jR),jS:dot(jT))end;local function jU()local function jV()local jW=-1;local jX=-1;if vBooster then jW=vBooster.getDistance()end;if hover then jX=hover.getDistance()end;if jW~=-1 and jX~=-1 then if jW<jX then return jW else return jX end elseif jW~=-1 then return jW elseif jX~=-1 then return jX else return-1 end end;local jY=jV()local jZ=-1;if telemeter_1 then jZ=telemeter_1.getDistance()end;if jY~=-1 and jZ~=-1 then if jY<jZ then return jY else return jZ end elseif jY~=-1 then return jY else return jZ end end;local function j_(planet,dS,k0)local function k1(k2,db)local dY=vec3(db)if k2.id==0 then return setmetatable({latitude=dY.x,longitude=dY.y,altitude=dY.z,id=0,systemId=k2.systemId},MapPosition)end;local dZ=dY-k2.center;local aj=dZ:len()local dh=aj-k2.radius;local df=0;local dg=0;if not ck(aj,0)then local d_=n(dZ.y,dZ.x)dg=d_>=0 and d_ or 2*math.pi+d_;df=math.pi/2-math.acos(dZ.z/aj)end;return setmetatable({latitude=math.deg(df),longitude=math.deg(dg),altitude=dh,id=k2.id,systemId=k2.systemId},MapPosition)end;local k3=k1(planet,dS)k3="::pos{"..k3.systemId..","..k3.id..","..k3.latitude..","..k3.longitude..","..k3.altitude.."}"if k0 then return k3 else system.setWaypoint(k3)return true end end;local k4=false;function jL.showWayPoint(planet,dS,k0)return j_(planet,dS,k0)end;function jL.APTick()local function k5()if bO and not BrakeLanding then local bW=bO[1]local fY,fZ=bO[2],bO[3]local k6=math.min(fY,fZ or fY)local k7=k6/bs;local k8=AutoTakeoff and(bs<42 or ao~=-1)local k9=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if k9 and not k8 and(a8*1.5>k6 or k7<1)then BrakeIsOn=true;cg(0)if AltitudeHold then cs()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then ct()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if k7<11 then bN=bW.name.." COLLISION "..cy(k7).." / "..cn(k6,2)else bN=bW.name.." collision "..cy(k7)end;if k7<6 then bY("alarm","AL",2)end else bN=false end end;local function ka(bS,kb,kc)local function kd(bS,dE)bS=vec3(bS)dE=vec3(dE):normalize()local cY=bS*dE;return cY.x+cY.y+cY.z end;local ke=0.001;local kf=1;if not aq or not b2 or ao~=-1 or bs<Q then if kc==nil then kc=DampingMultiplier end;if kb==nil then kb=ke end;bS=vec3(bS):normalize()local kg=vec3()-bS;local kh=-kd(kg,core.getConstructWorldOrientationRight())*kf;local ki=-kd(kg,core.getConstructWorldOrientationUp())*kf;if aB==0 then aB=kh/2 end;if aC==0 then aC=ki/2 end;if d(kh)<0.1 then V=V-kh*2 else V=V-(kh+(kh-aB)*kc)end;if d(ki)<0.1 then U=U+ki*2 else U=U+ki+(ki-aC)*kc end;aB=kh;aC=ki;if d(kh)<kb and d(ki)<kb then return true end;return false elseif b2 and ao==-1 then bS=br;if kc==nil then kc=DampingMultiplier end;if kb==nil then kb=ke end;bS=vec3(bS):normalize()local kg=bo-bS;local kh=-kd(kg,core.getConstructWorldOrientationRight())*kf;local ki=-kd(kg,core.getConstructWorldOrientationUp())*kf;if aB==0 then aB=kh/2 end;if aC==0 then aC=ki/2 end;if d(kh)<0.1 then V=V-kh*5 else V=V-(kh+(kh-aB)*kc)end;if d(ki)<0.1 then U=U+ki*5 else U=U+ki+(ki-aC)*kc end;aB=kh;aC=ki;if d(kh)<kb and d(ki)<kb then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=jU()E=q()b3=E;if CollisionSystem then k5()end;if antigrav then by=antigrav.getState()==1 end;local kj=1;local kk=1;local kl=E-b3;local km=-math.deg(jQ(bn,br,bo))local kn=math.deg(jQ(bp,br,bo))local gY=bt*-1;b2=aq and km<-YawStallAngle or km>YawStallAngle or kn<-PitchStallAngle or kn>PitchStallAngle;local ko=system.getMouseDeltaX()local kp=system.getMouseDeltaY()if InvertMouse and not a1 then kp=-kp end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local j3=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=ag+ko;ah=ah+kp end else ag=0;ah=0 end else ag=ag+ko;ah=ah+kp;aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(kp,-100,100)+0.5)*2*kj;V=(-utils.smoothstep(ko,-100,100)+0.5)*2*kk end end end end;local kq=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not kq then a2="Space Speed Engine Shutoff reached"cg(0)end;if not kq and LastIsWarping then if not BrakeIsOn then cv()end;if Autopilot then ct()end end;LastIsWarping=kq;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not jP then BrakeIsOn=true;jP=true elseif not AtmoSpeedAssist and jP then if bs<b7/3.6 then BrakeIsOn=false;jP=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local kr=false;if CustomTarget~=nil and al~=1 then kr=ka(CustomTarget.position-bv,0.1)else kr=ka(vec3(br),0.01)end;b0=true;if kr then cj(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cw()end elseif aq and AtmoSpeedAssist then cg(1)end elseif bs>Q then ka(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then ka(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cw()al=false;an=true else al=false;ct()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then ct()an=false end;if VertTakeOff then b0=true;local ks=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then ks=antigrav.getBaseAltitude()end;if as<ks-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=ks then if by then if Autopilot or VectorToTarget then cq()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bY("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bY("vtoc","VT")cq()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;cj(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=ks;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kt=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kt)local ku=r(vTpitchPID:get(),-1,1)U=ku end end;if IntoOrbit then local kg;local kv=false;local kw=cn(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget then kg=CustomTarget.position-bv end;local kx,ky=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local kz=bC;if not bc then local kA=false;local kB=false;cg(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..kw;if be.VectorToTarget then ka(kg:normalize():project_on_plane(bt))kv=bo:dot(kg:project_on_plane(bn):normalize())>0.95 else ka(br)kv=km<0.5;if bs<150 then kv=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then kA=true else kA=false end;if kz<=bb+1 and kz>=bb-1 then kB=true else kB=false end;if kA and kB and kv then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then ka(kg:normalize():project_on_plane(bt))elseif bs>150 then ka(br)end;U=0;if be.VectorToTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and kg:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or kg:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bY("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;cr()cw()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bg*0.9 and as<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;cg(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"bY("orCom","OB")cr()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..kw;bd=true;cj(ky*3.6+1)local kC=bg-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(kC-bu*r(utils.smoothstep(2000-kC,-2000,2000)^6*10,1,10))ba=r(VSpdPID:get(),-60,60)end end else local kD=2.75;local kE=d(A(kx*kD))local kF=kE%50;if kF>0 then kE=kE-kF+50 end;BrakeIsOn=false;if as<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..kw;ba=utils.map(bu,200,0,-15,80)elseif as>=bg*0.8 and as<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..kw;kE=kE*0.75;ba=utils.map(bu,100,-100,-15,65)elseif as>=bg*1.15 and as<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..kw;kE=kE*0.75;if bu<0 or bd then ba=utils.map(as,bg*1.5,bg*1.01,-30,0)else ba=utils.map(as,bg*0.99,bg*1.5,0,30)end elseif as>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..kw;ba=-65;local kG=utils.map(bu,-150,-400,1,0.55)kE=kE*kG end;cj(e(kE))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kH=ba-bB;OrbitPitchPID:inject(kH)local kI=r(OrbitPitchPID:get(),-0.5,0.5)U=kI end end;if Autopilot and ar==0 and not al then local function kJ(bQ,orbit)system.print(bQ)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cg(0)P=false;a2=bQ;bY("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;cr()end end;local kK,kL=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kM=(CustomTarget.position-ac.center):normalize()local kN=kM:project_on_plane((ac.center-bv):normalize()):normalize()local kO=ac.center+kN*(ac.radius+AutopilotTargetOrbit)local kP=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-kO):len()<(bv-kP):len()then kK=kO else kK=kP;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kK;aX.showWayPoint(ac,AutopilotTargetCoords)kL=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kL=true;TargetSet=true;AutopilotRealigned=true;kK=CustomTarget.position+(bv-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kM=(bv+br*100000-ac.center):normalize()local kN=kM:project_on_plane((ac.center-bv):normalize()):normalize()if kN:len()<1 then kM=(bv+bo*100000-ac.center):normalize()kN=kM:project_on_plane((ac.center-bv):normalize()):normalize()end;kK=ac.center+kN*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kK;TargetSet=true;kL=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kK)-bv):len()local bT,bU,bV=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(bW)if bW.noAtmosphericDensityAltitude>0 then return bW.radius+bW.noAtmosphericDensityAltitude else return bW.radius+bW.surfaceMaxAltitude*1.5 end end)local bX=bU;if bV~=nil and bU~=nil then bX=math.min(bV,bU)end;if bX~=nil and bX<AutopilotDistance and bT.name==ac.name then AutopilotDistance=bX end;local kr=true;local kQ=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local ii=cn(kQ)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ii..'"}')local a8,a9;if not TurnBurn then a8,a9=jM(bs)else a8,a9=jO(bs)end;if bs>300 and AutopilotAccelerating then local kg=vec3(kK)-bv;local kR=r(math.deg(jQ(bn,br:normalize(),kg:normalize()))*bs/500,-90,90)local kS=r(math.deg(jQ(bp,br:normalize(),kg:normalize()))*bs/500,-90,90)if d(kR)<20 and d(kS)<20 then kR=kR*2;kS=kS*2 end;if d(kR)<2 and d(kS)<2 then kR=kR*2;kS=kS*2 end;local km=-math.deg(jQ(bn,bo,br:normalize()))local kn=-math.deg(jQ(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kS-kn)local kT=r(apPitchPID:get(),-1,1)U=U+kT;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kR-km)local kU=r(apYawPID:get(),-1,1)V=V+kU;kL=true;if d(kR)>2 or d(kS)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bY("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bY("apAcc","AP")end end end;if kQ<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(kQ)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bT,bX=bR((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if bT~=nil and ac.name~=bT.name then a2="Collision with "..bT.name.." in "..cn(bX).."\nClear LOS to continue."ai=5;k4=true else k4=false;a2=""end end end;if not k4 then if not AutopilotCruising and not AutopilotBraking and not kL then kr=ka((kK-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kr=ka(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;cg(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local kV=unit.getThrottle()if AtmoSpeedAssist then kV=K end;if bq:len()>=MaxGameVelocity or kV==0 and P then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bY("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cg(0)end;local kW=AutopilotDistance;if ac.name=="Space"then kW=kW-AutopilotSpaceDistance end;if kW<=a8 or PreventPvP and bI<=a8+10000 then if PreventPvP and bI<=a8+10000 then ct()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bY("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cg(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then cg(1,true)end;local _,ky=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local kg;if CustomTarget~=nil then kg=CustomTarget.position-bv end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bs<50 then kJ("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bs<=ky and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kJ("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bY("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=ky then if CustomTarget~=nil then if br:normalize():dot(kg:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bY("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else kJ("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else kJ("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then kJ("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local kW=AutopilotDistance;if ac.name=="Space"then kW=kW-AutopilotSpaceDistance end;if kW<=a8 or PreventPvP and bI<=a8+10000 then if PreventPvP and bI<=a8+10000 then ct()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bY("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kV=unit.getThrottle()if AtmoSpeedAssist then kV=K end;if kV>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bY("apAcc","AP")end;AutopilotCruising=false end else if kr then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif kr and not k4 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bY("apAcc","AP")end;if not P then cg(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bY("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;cg(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local kS=0;local ez=bv+vec3(unit.getMasterPlayerRelativePosition())local kX=ez-bv;local kY=vec3(kX):project_on(bo):len()local kZ=vec3(kX):project_on(bp):len()local aj=y(kY*kY+kZ*kZ)ka(kX:normalize())local k_=40;local l0=aj<k_;local l1=100;local l2=r((aj-k_)/2,10,l1)U=0;local kr=d(V)<0.1;if kr and bs<l2 and not l0 then BrakeIsOn=false;kS=-20 else BrakeIsOn=true;kS=0 end;local l3=0;if d(kS-bB)>l3 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kS-bB)local kT=pitchPID:get()U=kT end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l4=LastMaxBrakeInAtmo;if l4 then l4=l4*r(bs/100,0.1,1)*ar else l4=LastMaxBrake end;if ar<0.01 then l4=LastMaxBrake end;local l5=bo:project_on_plane(bt):normalize():dot(br)local l6=vec3(core.getWorldAirFrictionAcceleration())local l7=l6:len()*av;if l5>100 then a8,a9=aS.computeDistanceAndTime(l5,100,av,0,0,l4)local l8,l9=aS.computeDistanceAndTime(100,0,av,0,0,l4*0.55)a8=a8+l8 else a8,a9=aS.computeDistanceAndTime(l5,0,av,0,0,l4*0.55)end;local kC=HoldAltitude-as-bu;local la=200+bs;if Reentry or al then minMax=2000+bs end;local lb=1;if AutoTakeoff then lb=r(bs/100,0.1,1)end;local kS=(utils.smoothstep(kC,-la,la)-0.5)*2*MaxPitch*lb;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then kS=(utils.smoothstep(kC,-la*r(20-19*ar*10,1,20),la*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*lb end;if not AltitudeHold then kS=0 end;if LockPitch~=nil then if bM and not IntoOrbit then kS=LockPitch else LockPitch=nil end end;b0=true;local lc=U;if Reentry then local ld=e(b7)local le,lf=aS.computeDistanceAndTime(bs,ld/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)le=le==-1 and 5000 or le;local lg=as-(planet.noAtmosphericDensityAltitude+le)local lh=as>planet.noAtmosphericDensityAltitude+le*1.35;if lh then kS=ReEntryPitch;if bs<=ld/3.6 and bs>ld/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;cg(1)end elseif bA and not lh and not aq then cj(ld,true)end;if bA then if bs>ld/3.6 and not lh then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then kS=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kS=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and lh then b0=true elseif not lh then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=ld)then cj(ld)end;if bs<ld/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then ka(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local kg;if bK then if type(bK)=="table"then kg=bK elseif bK<3 and bK>0 then kg=-bt:cross(br)*5000 elseif bK>=3 then kg=bt:cross(br)*5000 elseif bK<0 then kg=br*25000 end elseif CustomTarget~=nil then kg=CustomTarget.position-bv else kg=ac.center-bv end;local kR=math.deg(jQ(bt:normalize(),br,kg))*2;local li=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local lj=1000+bs;local lk=(utils.smoothstep(kC-bu*10,-lj,lj)-0.5)*2*MaxPitch;local ll=r(90-lk,0,180)b4=r(kR*2,-ll,ll)local lm=kR;kR=r(r(kR,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(li)+4*(bB-kS)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local ln=1;if b4~=0 then ln=d(li/b4)end;ln=(90-r(d(b4-bC),0,90))/90;local lo=kS;if d(bC)>90 then lo=-lo end;kS=ln*r(r(lo*math.cos(li),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(lm)*math.sin(li),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;kR=r(kR,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lp=km-kR;if bK and d(lp)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then cs()end;bK=nil;bY("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lp)local kU=r(yawPID:get(),-1,1)V=V+kU elseif aq and ao>-1 or bs<minRollVelocity then ka(kg)elseif b2 and ar>0.01 then if(km<-YawStallAngle or km>YawStallAngle)and ar>0.01 then ka(br)end;if(kn<-PitchStallAngle or kn>PitchStallAngle)and ar>0.01 then kS=r(bB-kn,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local ks=planet:getAltitude(CustomTarget.position)local lg=kg:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and lg<=a8 and(br:project_on_plane(bt):normalize():dot(kg:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cg(0)if AltitudeHold then cs()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l5<0.1 or lg<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<lg)then if not by then bY("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=lg end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local kg=CustomTarget.position-bv;local ks=planet:getAltitude(CustomTarget.position)local lg=y(kg:len()^2-(as-ks)^2)local l4=LastMaxBrakeInAtmo;if l4 then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,l4/2)StrongBrakes=true;if lg<=a8+bs*kl/2 and br:project_on_plane(bt):normalize():dot(kg:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cw()end end;LastDistanceToTarget=lg end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cr()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then ka(br)kS=r(bB-kn,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=lc;local jZ=-1;if BrakeLanding then kS=0;local lq=false;local lr=30;if aT~=nil and aT>0 then local ls=r(ar,0.4,2)local l4=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*ls;local lt=aT*ls+l4-j3;local lu=l4/2-j3;local lv=bs-y(d(lu/2)*20/(0.5*av))*utils.sign(lu)if lv<0 then lv=0 end;local lw;if bs>100 then local lx,_=aS.computeDistanceAndTime(bs,100,av,0,0,l4)local ly,_=aS.computeDistanceAndTime(100,0,av,0,0,y(l4))lw=lx+ly else lw=aS.computeDistanceAndTime(bs,0,av,0,0,y(l4))end;if lw<20 then BrakeIsOn=false else local lz=0;if lv>100 then local lA,_=aS.computeDistanceAndTime(lv,100,av,0,0,lt)local lB,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*ls+y(l4)-j3)lz=lA+lB else lz,_=aS.computeDistanceAndTime(lv,0,av,0,0,aT*ls+y(l4)-j3)end;lz=(lz+15+bs*kl)*1.1;local lC=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lC then local ks=planet:getAltitude(CustomTarget.position)local lD=as-ks-100;local kg=CustomTarget.position-bv;local lE=y(kg:len()^2-(as-ks)^2)if lE>100 then lC=false elseif lD<=lz or lz==-1 then BrakeIsOn=true;lq=true else BrakeIsOn=false;lq=true end end;if not lC and CalculateBrakeLandingSpeed then if lz>=lr then BrakeIsOn=true else BrakeIsOn=false end;lq=true end end end;if not bA then cg(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;jZ=ao;if jZ>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bY("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-gY)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not lq then BrakeIsOn=true elseif not lq then BrakeIsOn=false end end;if AutoTakeoff or am then local bT,bV,bU;if AutopilotTargetCoords~=nil then bT,bV,bU=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(bW)return bW.radius+bW.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cg(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(kS)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cg(0)elseif am then cg(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(bT==nil or bT.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then cg(0)end;AutopilotAccelerating=true end end;local lF=ao>-1;local lG=bB;if(VectorToTarget or am or bK)and not lF and bs>minRollVelocity and ar>0.01 then local li=math.rad(d(bC))lG=bB*d(math.cos(li))+kn*math.sin(li)end;local lH=r(kS-lG,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then lH=r(kS-lG,-85,MaxPitch)elseif ar<0.01 then lH=r(kS-lG,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or lF or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lH)local kT=pitchPID:get()U=U+kT end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=jU()return jL end;function script.onStart()local lI={}local lJ={}local lK=false;local function lL()local function lM(lN)local lO=dbHud_1.hasKey;for cH,cI in pairs(lN)do if lO(cI)then local cY=g(dbHud_1.getStringValue(cI))if cY~=nil then _G[cI]=cY;lK=true end end end end;if dbHud_1 then if not useTheseSettings then lM(c3())coroutine.yield()lM(c)else lM(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;lK=false end;coroutine.yield()if lK then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function lP()local function lQ(lR,lS)if lR>lS then lS=lR end;local lT,lU=0,0;if ContainerOptimization>0 then lT=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lU=FuelTankOptimization*0.05 end;lS=lS*(1-(lT+lU))return lS end;local lV=core.getElementNameById;local lW=fuelX~=0 and fuelY~=0;for cH in pairs(at)do local type=core.getElementTypeById(at[cH])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cH])),'^.*vertical.*$')and core.getElementForwardById(at[cH])[3]>0 then bx=true;p("UpEngine")end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cH])),'^.*vertical.*$')then local lX=core.getElementForwardById(at[cH])if lX[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local lY=j(at[cH])if lY>10000 then G=110 elseif lY>1000 then G=55 elseif lY>150 then G=27 end end;aL=aL+j(at[cH])if lW and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lY=j(at[cH])local j9=l(at[cH])local lR=0;local gN=q()if type=="Atmospheric Fuel Tank"then local lS=400;local lZ=35.03;if lY>10000 then lS=51200;lZ=5480 elseif lY>1300 then lS=6400;lZ=988.67 elseif lY>150 then lS=1600;lZ=182.67 end;lR=j9-lZ;if fuelTankHandlingAtmo>0 then lS=lS+lS*fuelTankHandlingAtmo*0.2 end;lS=lQ(lR,lS)aI[#aI+1]={at[cH],lV(at[cH]),lS,lZ,lR,gN}end;if type=="Rocket Fuel Tank"then local lS=320;local lZ=173.42;if lY>65000 then lS=40000;lZ=25740 elseif lY>6000 then lS=5120;lZ=4720 elseif lY>700 then lS=640;lZ=886.72 end;lR=j9-lZ;if fuelTankHandlingRocket>0 then lS=lS+lS*fuelTankHandlingRocket*0.1 end;lS=lQ(lR,lS)aK[#aK+1]={at[cH],lV(at[cH]),lS,lZ,lR,gN}end;if type=="Space Fuel Tank"then local lS=600;local lZ=35.03;if lY>10000 then lS=76800;lZ=5480 elseif lY>1300 then lS=9600;lZ=988.67 elseif lY>150 then lS=2400;lZ=182.67 end;lR=j9-lZ;if fuelTankHandlingSpace>0 then lS=lS+lS*fuelTankHandlingSpace*0.2 end;lS=lQ(lR,lS)aJ[#aJ+1]={at[cH],lV(at[cH]),lS,lZ,lR,gN}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function l_()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cI in pairs(door)do cI.toggle()end end;if switch then for _,cI in pairs(switch)do cI.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cI in pairs(forcefield)do cI.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function m0(m1,m2,m3,m4,cb,cc,m5,m6,m7,m8)local m9={enableName=m1,disableName=m2,width=m3,height=m4,x=cb,y=cc,toggleVar=m5,toggleFunction=m6,drawCondition=m7,hovered=false}if m8 then table.insert(lJ,m9)else table.insert(lI,m9)end;return m9 end;local function ma(mb)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif mb=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif mb=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif mb=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=c3(mb)showHud=false else bE={}showHud=true end end;local function mc()bD=not bD;if bD then aF=lJ;a2="Hold SHIFT to see Settings"bF=showHud else aF=lI;a2="Hold SHIFT to see Control Buttons"ma()showHud=bF end end;local function md(cI)_G[cI]=not _G[cI]if _G[cI]then a2=cI.." set to true"else a2=cI.." set to false"end;if cI=="showHud"then bF=_G[cI]elseif cI=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function me()local mf=50;local mg=340;local cb=500;local cc=aH/2-400;local mh=0;for cH,cI in pairs(c3("boolean"))do if type(_G[cI])=="boolean"then m0(cI,cI,mg,mf,cb,cc,function()return _G[cI]end,function()md(cI)end,function()return true end,true)cc=cc+mf+20;if mh==9 then cb=cb+mg+20;cc=aH/2-400;mh=0 else mh=mh+1 end end end;m0("Control View","Control View",mg,mf,10,aH/2-500,function()return true end,mc,function()return true end,true)m0("View Handling Settings",'Hide Handling Settings',mg,mf,10,aH/2-(500-mf),function()return showHandlingVariables end,function()ma("handling")end,function()return true end,true)m0("View Hud Settings",'Hide Hud Settings',mg,mf,10,aH/2-(500-mf*2),function()return showHudVariables end,function()ma("hud")end,function()return true end,true)m0("View Physics Settings",'Hide Physics Settings',mg,mf,10,aH/2-(500-mf*3),function()return showPhysicsVariables end,function()ma("physics")end,function()return true end,true)end;local function mi()local function jE()local position=bv;local fX=planet.name..". "..#SavedLocations;if bP[1]then local d9,_=bP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if d9~=nil and d9~=""then fX=fX.." "..bP[1].getConstructName(d9)end end;return aW.AddNewLocation(fX,position,false,true)end;local function mj()TurnBurn=not TurnBurn end;local function mk(ml)if ml==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function mm()aW.UpdatePosition()end;local function jD()aW.ClearCurrentPosition()end;local function mn()local fX=AutopilotTargetName;if fX==nil then local ii=cn((bv-CustomTarget.position):len())fX=CustomTarget.name.." "..ii end;if fX==nil then fX="None"end;return"Engage Autopilot: "..fX end;local function mo()local fX=AutopilotTargetName;if fX==nil then fX=CustomTarget.name end;if fX==nil then fX="None"end;return"Disable Autopilot: "..fX end;local function mp()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bY("folOn","F")else bY("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local mf=50;local mg=260;local mq=m0("Enable Brake Toggle","Disable Brake Toggle",mg,mf,aG/2-mg/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)m0("Align Prograde","Disable Prograde",mg,mf,aG/2-mg/2-50-mq.width,aH/2-mf+380,function()return ProgradeIsOn end,function()mk(1)end)m0("Align Retrograde","Disable Retrograde",mg,mf,aG/2-mg/2+mq.width+50,aH/2-mf+380,function()return RetrogradeIsOn end,mk,function()return ar==0 end)local mr=m0(mn,mo,600,60,aG/2-600/2,aH/2-60/2-400,function()return Autopilot end,ct)m0("Save Position","Save Position",200,mr.height,mr.x+mr.width+30,mr.y,function()return false end,jE,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)m0("Update Position","Update Position",200,mr.height,mr.x+mr.width+30,mr.y,function()return false end,mm,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)m0("Clear Position","Clear Position",200,mr.height,mr.x-200-30,mr.y,function()return true end,jD,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mf=60;mg=300;local cb=10;local cc=aH/2-500;cc=cc+mf+20;m0("View Settings","View Settings",mg,mf,cb,cc,function()return true end,mc)local cc=aH/2-300;m0("Enable Turn and Burn","Disable Turn and Burn",mg,mf,cb,cc,function()return TurnBurn end,mj)m0("Horizontal Takeoff Mode","Vertical Takeoff Mode",mg,mf,cb+mg+20,cc,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)cc=cc+mf+20;m0("Show Orbit Display","Hide Orbit Display",mg,mf,cb,cc,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a2="Orbit Display Enabled"else a2="Orbit Display Disabled"end end)m0("Engage Orbiting","Cancel Orbiting",mg,mf,cb+mg+20,cc,function()return IntoOrbit end,cr,function()return ar==0 and bM end)cc=cc+mf+20;m0("Glide Re-Entry","Cancel Glide Re-Entry",mg,mf,cb,cc,function()return Reentry end,function()al=1;mk(1)end,function()return planet.hasAtmosphere and not aq end)m0("Parachute Re-Entry","Cancel Parachute Re-Entry",mg,mf,cb+mg+20,cc,function()return Reentry end,cw,function()return planet.hasAtmosphere and not aq end)cc=cc+mf+20;m0("Engage Follow Mode","Disable Follow Mode",mg,mf,cb,cc,function()return a0 end,mp,function()return m()==1 end)m0("Enable Repair Arrows","Disable Repair Arrows",mg,mf,cb+mg+20,cc,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)cc=cc+mf+20;if not ExternalAGG then m0("Enable AGG","Disable AGG",mg,mf,cb,cc,function()return by end,cx,function()return antigrav~=nil end)end;m0(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,mg*2,mf,cb,cc,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)cc=cc+mf+20;m0(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,mg*2,mf,cb,cc,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)end;local function ms()local mt={}local function mu()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local mv={[1]=4480,[6]=4480,[7]=6270}for mw,mx in pairs(b)do b[mw][0]=mu()b[mw][0].systemId=mw;mt[mw]={}for my,planet in pairs(b[mw])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]if planet.name=="Lacobus"then planet.surfaceMaxAltitude=1660 end;planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=mv[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=mw;planet.bodyId=planet.id;mt[mw][my]=planet end end;aQ=cJ()aR=aQ(mt)aS=e3()aU=ex()aY=eV()aV=g6()aW=jr()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lL()coroutine.yield()lP()coroutine.yield()aX=jK()l_()me()mi()aF=lI;coroutine.yield()ms()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bP[1]=nil;if radar_1 or radar_2 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 elseif radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 end;aY.assignRadar()end;bY("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cI in pairs(door)do cI.toggle()end end;if switch then for _,cI in pairs(switch)do cI.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cI in pairs(forcefield)do cI.toggle()end end;cD()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;bY("stop","SU")end;function script.onTick(mz)local mA=nil;if mz=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bY("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif mz=="tenthSecond"then local function mB()local mC=system.createData;local mD=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mD(panelInterplanetary,"value")interplanetaryHeaderText=mC('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mD(panelInterplanetary,"value")widgetDistanceText=mC('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=mD(panelInterplanetary,"value")widgetTravelTimeText=mC('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mD(panelInterplanetary,"value")widgetMaxMassText=mC('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mD(panelInterplanetary,"value")widgetTargetOrbitText=mC('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mD(panelInterplanetary,"value")widgetCurBrakeDistanceText=mC('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mD(panelInterplanetary,"value")widgetCurBrakeTimeText=mC('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mD(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mC('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mD(panelInterplanetary,"value")widgetMaxBrakeTimeText=mC('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mD(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mC('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mE()t(panelInterplanetary)panelInterplanetary=nil end;local function mF()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local ev=bs;local kV=unit.getThrottle()/100;if AtmoSpeedAssist then kV=K end;local mG,mH=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*kV,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mI;if not TurnBurn and ev>0 then _,mI=aX.GetAutopilotBrakeDistanceAndTime(ev)else _,mI=aX.GetAutopilotTBBrakeDistanceAndTime(ev)end;local mJ=0;local mK=0;if AutopilotCruising or not Autopilot and ev>5 then mK=aS.computeTravelTime(ev,0,AutopilotDistance)elseif a8+mG<AutopilotDistance then mJ=AutopilotDistance-(a8+mG)mK=aS.computeTravelTime(8333.0556,0,mJ)else local mL=(AutopilotDistance-a8)/mG;mG=AutopilotDistance-a8;mH=mH*mL end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mK elseif AutopilotBraking then return mI elseif AutopilotCruising then return mK+mI else return mH+a9+mK end end;local function mM(j3,mN)if j3==nil then j3=core.g()end;j3=A(j3,5)if mN~=nil and mN or(mA==nil or mA~=j3)then local ev=bq:len()local mO=g(unit.getData()).maxBrake;if mO~=nil and mO>0 and aq then mO=mO/r(ev/100,0.1,1)mO=mO/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mO)/2 else LastMaxBrakeInAtmo=mO end end end;if mO~=nil and mO>0 then LastMaxBrake=mO end;mA=j3 end end;mM(nil,true)if bz~=nil then if s:getTargetSpeed(axisCommandId.longitudinal)~=bz then cj(bz,TRUE)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mB()end;if AutopilotTargetName~=nil then local mP=CustomTarget~=nil;local mQ=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()mQ=mQ>1000000 and A(mQ/1000000,2).." kTons"or A(mQ/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mF()if mP and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ii=cn(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ii..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cy(travelTime)..'", "unit":""}')ii=cn(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ii..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cy(a9)..'", "unit":""}')ii=cn(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ii..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cy(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",mQ)..'", "unit":""}')ii=cn(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ii..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then cg(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mE()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()if shield_1 then aV.DrawShield()end elseif mz=="oneSecond"then local function mR(gU)local mS=0;aD=""local mT=aL;local mU=0;local mV=0;local mW=0;local gR=0;local gS=""local mX=core.getElementHitPointsById;for cH in pairs(at)do local lY=0;local mY=0;mY=j(at[cH])lY=mX(at[cH])mU=mU+lY;if lY<mY then if lY==0 then mW=mW+1 else mV=mV+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cH]))local cb=position.x;local cc=position.y;local fp=position.z;table.insert(aA,core.spawnArrowSticker(cb,cc,fp+1,"down"))table.insert(aA,core.spawnArrowSticker(cb,cc,fp+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(cb+1,cc,fp,"north"))table.insert(aA,core.spawnArrowSticker(cb+1,cc,fp,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(cb-1,cc,fp,"south"))table.insert(aA,core.spawnArrowSticker(cb-1,cc,fp,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(cb,cc-1,fp,"east"))table.insert(aA,core.spawnArrowSticker(cb,cc-1,fp,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(cb,cc+1,fp,"west"))table.insert(aA,core.spawnArrowSticker(cb,cc+1,fp,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cH])end elseif aM and#aA>0 and aA[11]==at[cH]then for gM in pairs(aA)do core.deleteSticker(aA[gM])end;aA={}end end;mS=e(mU/mT*100)if mS<100 then gU[#gU+1]=ca(0,0,"","pbright txt")gR=e(mS*2.55)gS=f("rgb(%d,%d,%d)",255-gR,gR,0)if mS<100 then gU[#gU+1]=ca("50%",1035,"Elemental Integrity: "..mS.."%","txtbig txtmid","fill:"..gS)if mW>0 then gU[#gU+1]=ca("50%",1055,"Disabled Modules: "..mW.." Damaged Modules: "..mV,"txtbig txtmid","fill:"..gS)elseif mV>0 then gU[#gU+1]=ca("50%",1055,"Damaged Modules: "..mV,"txtbig txtmid","fill:"..gS)end end end end;local function mZ()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function m_()local gN=q()local i5=bs;local n0=gN-au;if i5>1.38889 then i5=i5/1000;local n1=i5*(gN-au)TotalDistanceTravelled=TotalDistanceTravelled+n1;ad=ad+n1 end;ae=ae+n0;TotalFlightTime=TotalFlightTime+n0;au=gN end;m_()aV.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()mZ()local gU={}aV.ExtraData(gU)if ShowOdometer then gU=aV.DrawOdometer(gU,ad,TotalDistanceTravelled,ae)end;if ShouldCheckDamage then mR(gU)end;ak=table.concat(gU,"")collectgarbage("collect")elseif mz=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cY=g(dbHud_1.getStringValue("SavedLocations"))if cY~=nil then _G["SavedLocations"]=cY;local fI=-1;local jG;for cH,cI in pairs(SavedLocations)do if cI.name and cI.name=="SatNav Location"then fI=cH;break end end;if fI~=-1 then jG=SavedLocations[fI]fI=-1;for cH,cI in pairs(b[0])do if cI.name and cI.name=="SatNav Location"then fI=cH;break end end;if fI>-1 then b[0][fI]=jG end;aW.UpdateAtlasLocationsList()a2=jG.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mz=="msgTick"then local gU={}aV.DisplayMessage(gU,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif mz=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif mz=="hudTick"then if not planet then return end;local function n2(gU)local n3=e(r(aj/(aG/4)*255,0,255))gU[#gU+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+n3,e(J+0.5)-n3,e(I+0.5)-n3)end;local function n4()for _,cI in pairs(aF)do if cI.hovered then if not cI.drawCondition or cI.drawCondition()then cI.toggleFunction()end;cI.hovered=false end end end;local function n5()local function n6(n7,n8,cb,cc,m3,m4)if n7>cb and n7<cb+m3 and n8>cc and n8<cc+m4 then return true else return false end end;local cb=ag+aG/2;local cc=ah+aH/2;for _,cI in pairs(aF)do cI.hovered=n6(cb,cc,cI.x,cI.y,cI.width,cI.height)end end;local function n9(gU)local function na(gU,nb,hover,cb,cc,eo,nc,nd,ne,nf,ng)if type(nf)=="function"then nf=nf()end;if type(ng)=="function"then ng=ng()end;gU[#gU+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",cb,cc,eo,nc)if nb then gU[#gU+1]=f("%s'",nd)else gU[#gU+1]=ne end;if hover then gU[#gU+1]=" style='stroke:white; stroke-width:2'"else gU[#gU+1]=" style='stroke:black; stroke-width:1'"end;gU[#gU+1]="></rect>"gU[#gU+1]=f("<text x='%f' y='%f' font-size='24' fill='",cb+eo/2,cc+nc/2+5)if nb then gU[#gU+1]="black"else gU[#gU+1]="white"end;gU[#gU+1]="' text-anchor='middle' font-family='Montserrat'>"if nb then gU[#gU+1]=f("%s</text>",nf)else gU[#gU+1]=f("%s</text>",ng)end end;local nh="rgb(50,50,50)'"local ni="rgb(210,200,200)"local nj=na;for _,cI in pairs(aF)do local m2=cI.disableName;local m1=cI.enableName;if type(m2)=="function"then m2=m2()end;if type(m1)=="function"then m1=m1()end;if not cI.drawCondition or cI.drawCondition()then nj(gU,cI.toggleVar(),cI.hovered,cI.x,cI.y,cI.width,cI.height,ni,nh,m2,m1)end end end;local nk=A(ResolutionX/2,0)local nl=A(ResolutionY/2,0)local gU={}aV.HUDPrologue(gU)if showHud then aV.UpdateHud(gU)else if AlwaysVSpd then aV.DrawVerticalSpeed(gU,as)end;aV.DisplayOrbitScreen(gU)aV.DrawWarnings(gU)end;if bD and bE~={}then aV.DrawSettings(gU)end;if radar_1 or radar_2 then aY.assignRadar()end;if bP[1]then aV.DrawRadarInfo()end;aV.HUDEpilogue(gU)gU[#gU+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(gU,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(gU)end end;if x()==0 then if m()==1 and a1 then if not AltIsOn then n5()n9(gU)end;if not aZ and not a_ then local nm=table.concat(gU,"")gU={}gU[#gU+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gU[#gU+1]=nm;gU[#gU+1]="</body>"aZ=true;gU[#gU+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gU,"")system.setScreen(content)elseif a_ then local nm=table.concat(gU,"")gU={}gU[#gU+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gU[#gU+1]=nm;gU[#gU+1]="</body>"end;if not aZ then gU[#gU+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nk,nl,ag,ah)end else n4()end else if not a1 and m()==0 then n4()if aj>DeadZone then if DisplayDeadZone then n2(gU)end end elseif not AltIsOn or AltIsOn and a1 then n5()n9(gU)end;gU[#gU+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nk,nl,ag,ah)end;gU[#gU+1]=[[</svg></body>]]content=table.concat(gU,"")elseif mz=="apTick"then aX.APTick()elseif mz=="radarTick"then aY.UpdateRadar()elseif mz=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function nn(no,l2)local np=vec3()local nq=vec3()if no==axisCommandId.longitudinal then np=vec3(core.getConstructOrientationForward())nq=bo elseif no==axisCommandId.vertical then np=vec3(core.getConstructOrientationUp())nq=bn elseif no==axisCommandId.lateral then np=vec3(core.getConstructOrientationRight())nq=bp else return vec3()end;local nr=vec3(core.getWorldGravity())local ns=nr:dot(nq)local nt=vec3(core.getWorldAirFrictionAcceleration())local nu=nt:dot(nq)local nw=bq:dot(np)local nx=l2*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nx-nw)local ny=targetSpeedPID2:get()local nz=(ny-nu-ns)*nq;return nz end;local function nA(no,l2)local np=vec3()local nq=vec3()if no==axisCommandId.longitudinal then np=vec3(core.getConstructOrientationForward())nq=bo elseif no==axisCommandId.vertical then np=vec3(core.getConstructOrientationUp())nq=bn elseif no==axisCommandId.lateral then np=vec3(core.getConstructOrientationRight())nq=bp else return vec3()end;local nr=vec3(core.getWorldGravity())local ns=nr:dot(nq)local nt=vec3(core.getWorldAirFrictionAcceleration())local nu=nt:dot(nq)local nw=bq:dot(np)local nx=l2*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nx-nw)local ny=targetSpeedPID:get()local nz=(ny-nu-ns)*nq;return nz end;local function nB(nC,gX,jw)local nD=nC:cross(jw):normalize_inplace()local hJ=math.acos(r(nD:dot(-gX),-1,1))*constants.rad2deg;if nD:cross(-gX):dot(jw)<0 then hJ=-hJ end;return hJ end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then cg(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local nE=r(T+U+system.getControlDeviceForwardInput(),-1,1)local nF=r(W+Z+system.getControlDeviceYawInput(),-1,1)local nG=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local nH=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local nI=bC/180*math.pi;local nJ=math.cos(nI)local nK=math.sin(nI)bB=nB(bt,bo,bp*nJ+bn*nK)local nL=br:normalize()local nM=d(bC)local nN=utils.sign(bC)local nO=vec3(core.getWorldAngularVelocity())local nP=nE*pitchSpeedFactor*bp+nF*rollSpeedFactor*bo+nG*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local nQ=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and nQ>0 or ar>0.0 and nQ<autoRollRollThreshold and autoRollPreference)and nF==0 and d(bB)<85 then local nR=b4;local nS=autoRollFactor;if ar==0 then nS=nS/4;b4=0;nR=0 end;if rollPID==nil then rollPID=pid.new(nS*0.01,0,nS*0.1)end;rollPID:inject(nR-bC)local nT=rollPID:get()nP=nP+nT*bo end end;local nU=1;local nV=0;local nW=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then b7=r(b7+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nX=K;K=A(r(K+speedChangeLarge/100,-1,1),2)if K>=0 and nX<0 then K=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then b7=r(b7-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nX=K;K=A(r(K-speedChangeLarge/100,-1,1),2)if K<=0 and nX>0 then K=0;aw=false end end else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local nY=throttlePID:get()N=r(nY,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local nZ=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=nZ end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local n_=''local o0=vec3()local o1=nn(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",o1,nV)local o2='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then o2=o2 ..ExtraLongitudeTags end;local o3=s:getAxisCommandType(axisCommandId.longitudinal)local o4=s:composeAxisAccelerationFromThrottle(o2,axisCommandId.longitudinal)local o5=nA(axisCommandId.lateral,LeftAmount*1000)n_=n_..' , '.."lateral airfoil , lateral ground "o0=o0+o5;if o0:len()>constants.epsilon then a:setEngineForceCommand(n_,o0,nV,'','','',nW)end;a:setEngineForceCommand(o2,o4,nU)local o6='thrust analog vertical fueled 'local o7='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then o7=o7 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then o6=o6 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(o6,o1,nU)else a:setEngineForceCommand(o6,vec3(),nU)end;if LeftAmount~=0 then a:setEngineForceCommand(o7,o5,nU)else a:setEngineForceCommand(o7,vec3(),nU)end;if nH==0 then nH=L end;local o8=-nH*(brakeSpeedFactor*br+brakeFlatFactor*nL)a:setEngineForceCommand('brake',o8)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local l2=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-l2/3.6)local nZ=r(brakePID:get(),0,1)nH=r(nH+nZ,0,1)end;local o8=-nH*(brakeSpeedFactor*br+brakeFlatFactor*nL)a:setEngineForceCommand('brake',o8)local n_=''local o0=vec3()local o9=false;local o2='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then o2=o2 ..ExtraLongitudeTags end;local o3=s:getAxisCommandType(axisCommandId.longitudinal)if o3==axisCommandType.byThrottle then local o4=s:composeAxisAccelerationFromThrottle(o2,axisCommandId.longitudinal)a:setEngineForceCommand(o2,o4,nU)elseif o3==axisCommandType.byTargetSpeed then local o4=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)n_=n_..' , '..o2;o0=o0+o4;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then o9=true end end;local o7='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then o7=o7 ..ExtraLateralTags end;local oa=s:getAxisCommandType(axisCommandId.lateral)if oa==axisCommandType.byThrottle then local ob=s:composeAxisAccelerationFromThrottle(o7,axisCommandId.lateral)a:setEngineForceCommand(o7,ob,nU)elseif oa==axisCommandType.byTargetSpeed then local o5=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)n_=n_..' , '..o7;o0=o0+o5 end;local o6='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then o6=o6 ..ExtraVerticalTags end;local oc=s:getAxisCommandType(axisCommandId.vertical)if oc==axisCommandType.byThrottle then local o1=s:composeAxisAccelerationFromThrottle(o6,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(o6,o1,nU,'airfoil','ground','',nW)else a:setEngineForceCommand(o6,vec3(),nU)a:setEngineForceCommand('airfoil vertical',o1,nU,'airfoil','','',nW)a:setEngineForceCommand('ground vertical',o1,nU,'ground','','',nW)end elseif oc==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),nU)end;local od=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)n_=n_..' , '..o6;o0=o0+od end;if o0:len()>constants.epsilon then if Y~=0 or o9 or d(nL:dot(bo))<0.5 then n_=n_..', brake'end;a:setEngineForceCommand(n_,o0,nV,'','','',nW)end end;local oe=torqueFactor*(nP-nO)local of=vec3(core.getWorldAirFrictionAngularAcceleration())oe=oe-of;a:setEngineTorqueCommand('torque',oe,nU,'airfoil','','',nW)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local ev=bq:len()local og=0.15;if not bA then local oh=s:getTargetSpeed(axisCommandId.longitudinal)if ev*3.6>oh*(1-og)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ev*3.6<oh*(1-og)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kV=unit.getThrottle()if AtmoSpeedAssist then kV=K*100 end;local l2=kV/100;if k==0 then l2=l2*MaxGameVelocity;if ev>=l2*(1-og)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ev<l2*(1-og)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local ld=e(b7)l2=l2*ld/3.6;if ev>=l2*(1-og)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ev<l2*(1-og)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g3=coroutine.status(beginSetup)if g3=="suspended"then local ch,g4=coroutine.resume(beginSetup)if g4 then system.print("ERROR STARTUP: "..g4)end elseif g3=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(oi)local function oj(ok)local D=1;local function ol(om,ok)local on={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local oo=om;for _,cI in ipairs(on)do if ok and oo>cI then om=cI elseif om<cI and not ok then om=cI;break end end;return om end;if ok then D=-1 end;if not ExternalAGG and by then if a1 and ok then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=ol(bg,ok)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=ol(HoldAltitude,ok)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function op(ok)local D=1;if ok then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if ok then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end;local function oq(os)if not aq then a2="Flight Assist in Atmo only"return end;local cO=type(os)if bK==nil then if cO=="table"then if Autopilot or VectorToTarget then ct()end;bY("180On","BR")elseif os==1 then bY("bnkLft","BR")else bY("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cs()if cO~="table"then os=os+1 end end;bK=os else bY("180Off","BR")bK=nil end end;if oi=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cg(0)if vBooster or hover then if aq and ao==-1 then bY("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then bY("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bY("grOut","LG",1)a.control.extendLandingGears()end else if S then bY("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif oi=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif oi=="forward"then T=T-1 elseif oi=="backward"then if AltIsOn then oq(-br*5000)else T=T+1 end elseif oi=="left"then if AltIsOn then oq(1)else W=W-1 end elseif oi=="right"then if AltIsOn then oq(3)else W=W+1 end elseif oi=="yawright"then X=X-1 elseif oi=="yawleft"then X=X+1 elseif oi=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif oi=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif oi=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif oi=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif oi=="groundaltitudeup"then oj()elseif oi=="groundaltitudedown"then oj(true)elseif oi=="option1"then toggleView=false;if AltIsOn and a1 then local ot=""for i=1,#passengers do ot=ot.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..A(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..ot)return end;aW.adjustAutopilotTargetIndex()elseif oi=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif oi=="option3"then local function ou()aE=not aE;if not aE then bY("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bY("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local ot=""for i=1,#ships do ot=ot.."| ID: "..ships[i].." Mass: "..A(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..ot)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ou()toggleView=false elseif oi=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;ct()elseif oi=="option5"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;function ToggleLockPitch()if LockPitch==nil then bY("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bY("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif oi=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local ov=shield_1.getVentingCooldown()if ov>0 then a2="Cannot vent again for "..ov.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;cs()elseif oi=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end;toggleView=false elseif oi=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bY("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bY("gsOn","GS")end;toggleView=false elseif oi=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)cg(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bY("gyOn","GA")else bY("gyOff","GA")end end;toggleView=false elseif oi=="lshift"then if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif oi=="brake"then if BrakeToggleStatus then cv()elseif not BrakeIsOn then cv()else BrakeIsOn=true end elseif oi=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif oi=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif oi=="stopengines"then local function ow()if E-F<1.5 then bY("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;ow()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)cg(0)else cg(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then cj(AtmoSpeedLimit)else cj(MaxGameVelocity*3.6)end end end elseif oi=="speedup"then op()elseif oi=="speeddown"then op(true)elseif oi=="antigravity"and not ExternalAGG then if antigrav~=nil then cx()end end end;function script.onActionStop(oi)local function ox()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if oi=="forward"then T=0 elseif oi=="backward"then T=0 elseif oi=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif oi=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif oi=="yawright"then X=0 elseif oi=="yawleft"then X=0 elseif oi=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif oi=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif oi=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif oi=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif oi=="groundaltitudeup"then ox()toggleView=false elseif oi=="groundaltitudedown"then ox()toggleView=false elseif oi=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif oi=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cv()else BrakeIsOn=false end end elseif oi=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(oi)local function oy(ok)local D=1;if ok then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function oz(ok)local D=1;if ok then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if oi=="groundaltitudeup"then if not a1 then oy()end elseif oi=="groundaltitudedown"then if not a1 then oy(true)end elseif oi=="speedup"then oz()elseif oi=="speeddown"then oz(true)end end;function script.onInputText(cd)local function oA()for cH,cI in pairs(c3())do dbHud_1.setStringValue(cI,h(nil))end;for cH,cI in pairs(c)do if cI~="SavedLocations"then dbHud_1.setStringValue(cI,h(nil))end end;a2="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5 end;local function oB(oC,ez,hF)local function oD(ez)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cW='::pos{'..B..','..B..','..B..','..B..','..B..'}'local d8,d9,df,dg,dh=o(ez,cW)if d8=="0"and d9=="0"then return vec3(z(df),z(dg),z(dh))end;dg=math.rad(dg)df=math.rad(df)local planet=b[z(d8)][z(d9)]local e0=math.cos(df)local oE=vec3(e0*math.cos(dg),e0*math.sin(dg),math.sin(df))return planet.center+(planet.radius+dh)*oE end;local position=oD(ez)return aW.AddNewLocation(oC,position,hF)end;local i;local oF,oG=nil,nil;local oH="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(cd," ")oF=cd;if i~=nil then oF=string.sub(cd,0,i-1)oG=string.sub(cd,i+1)end;if oF=="/help"or oF=="/commands"then for jd in string.gmatch(oH,"([^\n]+)")do system.print(jd)end;return elseif oF=="/setname"then if oG==nil or oG==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(oG)else a2="Select a saved target to rename first"end elseif shield_1 and oF=="/resist"then if oG==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cW=B..', '..B..', '..B..', '..B;local oI,oJ,oK,oL=o(oG,cW)if oL==nil or oI+oJ+oK+oL>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(oI,oJ,oK,oL)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif oF=="/addlocation"or string.find(cd,"::pos")~=nil then local hF=false;local oC="0-Temp"if oG==nil or oG==""then oG=oF;hF=true end;i=string.find(oG,"::")if not hF then oC=string.sub(oG,1,i-2)end;local ez=string.sub(oG,i)oB(oC,ez,hF)elseif oF=="/agg"then if oG==nil or oG==""then a2="Usage: /agg targetheight"return end;oG=z(oG)if oG<1000 then oG=1000 end;AntigravTargetAltitude=oG;a2="AGG Target Height set to "..oG elseif oF=="/G"then if oG==nil or oG==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oG=="dump"then for cH,cI in pairs(c3())do if type(_G[cI])=="boolean"then if _G[cI]==true then system.print(cI.." true")else system.print(cI.." false")end elseif _G[cI]==nil then system.print(cI.." nil")else system.print(cI.." ".._G[cI])end end;return end;i=string.find(oG," ")local oM=string.sub(oG,0,i-1)local oN=string.sub(oG,i+1)for cH,cI in pairs(c3())do if cI==oM then a2="Variable "..oM.." changed to "..oN;local oO=type(_G[cI])if oO=="number"then oN=z(oN)elseif oO=="boolean"then if string.lower(oN)=="true"then oN=true else oN=false end end;_G[cI]=oN;return end end;a2="No such global variable: "..oM elseif oF=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif oF=="/copydatabank"then if dbHud_2 then cD(true)else a2="Spare Databank required to copy databank"end elseif oF=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(d9)if bP[1]and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(d9)if bP[1]and CollisionSystem then if#bL>650 then d9=tostring(d9)bL[d9]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
