name: ArchHud - Archaegeo v1.602 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        require("autoconf/custom/archhud/globals")local a=Navigator.new(system,core,unit)local b=require("atlas")navGlobal=a;atlasGlobal=b;coreGlobal=core;unitGlobal=unit;systemGlobal=system;vBoosterGlobal=vBooster;hoverGlobal=hover;telmeter_1Global=telemeter_1;radar_1Global=radar_1;radar_2Global=radar_2;antigravGlobal=antigrav;shield_1Global=shield_1;require("autoconf/custom/archhud/hudclass")require("autoconf/custom/archhud/apclass")script={}VERSION_NUMBER=1.602;mabs=math.abs;mfloor=math.floor;stringf=string.format;jdecode=json.decode;jencode=json.encode;eleMaxHp=core.getElementMaxHitPointsById;atmosphere=unit.getAtmosphereDensity;eleMass=core.getElementMassById;isRemote=a.control.isRemoteControlled;atan=math.atan;stringmatch=string.match;systime=system.getTime;uclamp=utils.clamp;navCom=a.axisCommandManager;sysDestWid=system.destroyWidgetPanel;sysUpData=system.updateData;sysAddData=system.addDataToWidget;sysLockVw=system.lockView;sysIsVwLock=system.isViewLocked;msqrt=math.sqrt;tonum=tonumber;function round(c,d)local e=10^(d or 0)return mfloor(c*e+0.5)/e end;time=systime()clearAllCheck=systime()coreHalfDiag=13;PrimaryR=SafeR;PrimaryB=SafeB;PrimaryG=SafeG;PlayerThrottle=0;brakeInput2=0;ThrottleLimited=false;calculatedThrottle=0;WasInCruise=false;apThrottleSet=false;minAutopilotSpeed=55;reentryMode=false;hasGear=false;pitchInput=0;pitchInput2=0;yawInput2=0;rollInput=0;yawInput=0;brakeInput=0;rollInput2=0;followMode=false;holdingShift=false;msgText="empty"holdAltitudeButtonModifier=5;antiGravButtonModifier=5;currentHoldAltModifier=holdAltitudeButtonModifier;currentAggModifier=antiGravButtonModifier;isBoosting=false;brakeDistance=0;brakeTime=0;maxBrakeDistance=0;maxBrakeTime=0;autopilotTargetPlanet=nil;totalDistanceTrip=0;flightTime=0;upAmount=0;simulatedX=0;simulatedY=0;msgTimer=3;distance=0;lastOdometerOutput=""spaceLand=false;spaceLaunch=false;finalLand=false;abvGndDet=-1;myAutopilotTarget=""inAtmo=atmosphere()>0;atmosDensity=atmosphere()coreAltitude=core.getAltitude()elementsID=core.getElementIdList()lastTravelTime=systime()coreMass=core.getConstructMass()mousePause=false;gyroIsOn=nil;rgb=[[rgb(]]..mfloor(PrimaryR+0.5)..","..mfloor(PrimaryG+0.5)..","..mfloor(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..mfloor(PrimaryR*0.9+0.5)..","..mfloor(PrimaryG*0.9+0.5)..","..mfloor(PrimaryB*0.9+0.5)..[[)]]markers={}previousYawAmount=0;previousPitchAmount=0;damageMessage=""UnitHidden=true;Buttons={}resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;atmoTanks={}spaceTanks={}rocketTanks={}eleTotalMaxHp=0;repairArrows=false;MapXRatio=nil;MapYRatio=nil;YouAreHere=nil;PlanetaryReference=nil;galaxyReference=nil;Kinematic=nil;maxKinematicUp=nil;Kep=nil;HUD=nil;ATLAS=nil;AP=nil;RADAR=nil;Animating=false;Animated=false;autoRoll=autoRollPreference;targetGroundAltitude=LandingGearGroundHeight;stalling=false;lastApTickTime=systime()targetRoll=0;ahDoubleClick=0;apDoubleClick=0;adjustedAtmoSpeedLimit=AtmoSpeedLimit;VtPitch=0;orbitMsg=nil;orbitPitch=0;orbitRoll=0;orbitAligned=false;orbitalRecover=false;orbitalParams={VectorToTarget=false}OrbitTargetSet=false;OrbitTargetOrbit=0;OrbitTargetPlanet=nil;OrbitAchieved=false;SpaceEngineVertUp=false;SpaceEngineVertDn=false;SpaceEngines=false;OrbitTicks=0;constructUp=vec3(core.getConstructWorldOrientationUp())constructForward=vec3(core.getConstructWorldOrientationForward())constructRight=vec3(core.getConstructWorldOrientationRight())coreVelocity=vec3(core.getVelocity())constructVelocity=vec3(core.getWorldVelocity())velMag=vec3(constructVelocity):len()worldVertical=vec3(core.getWorldVertical())vSpd=-worldVertical:dot(constructVelocity)worldPos=vec3(core.getConstructWorldPos())soundAlarm=0;UpVertAtmoEngine=false;antigravOn=false;setCruiseSpeed=nil;throttleMode=true;adjustedPitch=0;adjustedRoll=0;showSettings=false;settingsVariables={}oldShowHud=showHud;AtlasOrdered={}notPvPZone=false;pvpDist=50000;pipeMessage=""ReversalIsOn=nil;contacts={}nearPlanet=unit.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;collisionAlertStatus=false;collisionTarget=nil;radars={}rType="Atmo"apButtonsHovered=false;apScrollIndex=0;TabButtons={}function p(f)system.print(time..": "..f)end;function changeSpd(g)local e=1;if g then e=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn and mousePause then local h=PlayerThrottle;PlayerThrottle=round(uclamp(PlayerThrottle+e*speedChangeLarge/100,-1,1),2)if PlayerThrottle>=0 and h<0 then PlayerThrottle=0;mousePause=false end elseif AltIsOn then if atmosDensity>0 or Reentry then adjustedAtmoSpeedLimit=uclamp(adjustedAtmoSpeedLimit+e*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=uclamp(MaxGameVelocity+e*speedChangeLarge/3.6*100,0,8333.00)end else navCom:updateCommandFromActionStart(axisCommandId.longitudinal,e*speedChangeLarge)end else if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then apScrollIndex=apScrollIndex+1*e*-1;if apScrollIndex>#AtlasOrdered then apScrollIndex=1 end;if apScrollIndex<1 then apScrollIndex=#AtlasOrdered end else if not g then e=1 else e=nil end;ATLAS.adjustAutopilotTargetIndex(e)end end end;function checkLOS(j)local k,l,m=galaxyReference:getPlanetarySystem(0):castIntersections(worldPos,j,function(n)if n.noAtmosphericDensityAltitude>0 then return n.radius+n.noAtmosphericDensityAltitude else return n.radius+n.surfaceMaxAltitude*1.5 end end)local o=l;if m~=nil and l~=nil then o=math.min(m,l)end;if o~=nil then return k,o else return nil,nil end end;function play(q,r,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..q.."|"..r.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..q.."|"..r.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..q.."|"..r.."|"..soundVolume)end end;function addTable(s,t)for i=1,#t do s[#s+1]=t[i]end;return s end;function saveableVariables(u)local v={}if not u then addTable(v,saveableVariablesBoolean)addTable(v,savableVariablesHandling)addTable(v,savableVariablesHud)addTable(v,savableVariablesPhysics)return v elseif u=="boolean"then return saveableVariablesBoolean elseif u=="handling"then return savableVariablesHandling elseif u=="hud"then return savableVariablesHud elseif u=="physics"then return savableVariablesPhysics end end;function svgText(w,x,y,z,A)if z==nil then z=""end;if A==nil then A=""end;return stringf([[<text class="%s" x=%s y=%s style="%s">%s</text>]],z,w,x,A,y)end;function cmdThrottle(B,C)if navCom:getAxisCommandType(0)~=axisCommandType.byThrottle and not C then a.control.cancelCurrentControlMasterMode()end;navCom:setThrottleCommand(axisCommandId.longitudinal,B)PlayerThrottle=uclamp(round(B*100,0)/100,-1,1)setCruiseSpeed=nil end;function cmdCruise(B,C)if navCom:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not C then a.control.cancelCurrentControlMasterMode()end;navCom:setTargetSpeedCommand(axisCommandId.longitudinal,B)setCruiseSpeed=B end;function float_eq(D,E)if D==0 then return mabs(E)<1e-09 end;if E==0 then return mabs(D)<1e-09 end;return mabs(D-E)<math.max(mabs(D),mabs(E))*epsilon end;function getDistanceDisplayString(distance,F)local G=distance>100000;if F==nil then F=1 end;if G then return round(distance/1000/200,F).."SU"elseif distance<1000 then return round(distance,F).."M"else return round(distance/1000,F).."KM"end end;function ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;autoRoll=true;upAmount=0;if inAtmo and abvGndDet==-1 then BrakeLanding=false;AltitudeHold=true;upAmount=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cmdCruise(mfloor(adjustedAtmoSpeedLimit))end else OrbitAchieved=false;GearExtended=false;a.control.retractLandingGears()navCom:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function ToggleIntoOrbit()OrbitAchieved=false;orbitPitch=nil;orbitRoll=nil;OrbitTicks=0;if atmosDensity==0 then if IntoOrbit then play("orOff","AP")IntoOrbit=false;orbitAligned=false;OrbitTargetPlanet=nil;autoRoll=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;orbitalParams.VectorToTarget=false;orbitalParams.AutopilotAlign=false;OrbitTargetSet=false elseif nearPlanet then play("orOn","AP")IntoOrbit=true;autoRoll=true;if OrbitTargetPlanet==nil then OrbitTargetPlanet=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else msgText="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;orbitAligned=false;OrbitTargetPlanet=nil;autoRoll=autoRollPreference;if AltitudeHold then AltitudeHold=false end;orbitalParams.VectorToTarget=false;orbitalParams.AutopilotAlign=false;OrbitTargetSet=false end end;function ToggleAltitudeHold()if time-ahDoubleClick<1.5 then if planet.hasAtmosphere then if atmosDensity>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;play("11","EP")else if nearPlanet then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;OrbitTargetOrbit=HoldAltitude;OrbitTargetSet=true;if not IntoOrbit then ToggleIntoOrbit()end;orbitAligned=true end end;ahDoubleClick=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else ahDoubleClick=time end;if nearPlanet and atmosDensity==0 then OrbitTargetOrbit=coreAltitude;OrbitTargetSet=true;orbitAligned=true;ToggleIntoOrbit()if IntoOrbit then ahDoubleClick=time else ahDoubleClick=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;followMode=false;autoRoll=true;LockPitch=nil;OrbitAchieved=false;if abvGndDet~=-1 and velMag<20 then play("lfs","LS")AutoTakeoff=true;if ahDoubleClick>-1 then HoldAltitude=coreAltitude+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;navCom:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and UpVertAtmoEngine then ToggleVerticalTakeoff()end else play("altOn","AH")AutoTakeoff=false;if ahDoubleClick>-1 then if nearPlanet then HoldAltitude=coreAltitude end end;if VertTakeOff then ToggleVerticalTakeoff()end end;if spaceLaunch then HoldAltitude=100000 end else play("altOff","AH")if IntoOrbit then ToggleIntoOrbit()end;if VertTakeOff then ToggleVerticalTakeoff()end;autoRoll=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;ahDoubleClick=0 end end;function ResetAutopilots(H)if H then spaceLaunch=false;Autopilot=false;AutopilotRealigned=false;apThrottleSet=false;HoldAltitude=coreAltitude;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;ReversalIsOn=nil;if not antigravOn then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then ToggleVerticalTakeoff()end;if IntoOrbit then ToggleIntoOrbit()end;autoRoll=autoRollPreference;spaceLand=false;finalLand=false;upAmount=0 end;function ToggleAutopilot()local function I(SpaceTarget)collisionAlertStatus=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if time-apDoubleClick<1.5 and atmosDensity>0 then if not SpaceEngines then msgText="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if atmosDensity>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;play("orH","OH")end;apDoubleClick=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else apDoubleClick=time end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<coreMass then msgText="WARNING: Heavy Loads may affect autopilot performance."msgTimer=5 end;ATLAS.UpdateAutopilotTarget()AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then play("apSpc","AP")if atmosDensity~=0 then spaceLaunch=true;ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if atmosDensity>0 then if not VectorToTarget then play("vtt","AP")I(SpaceTarget)end else play("apOn","AP")if not(autopilotTargetPlanet.name==planet.name and coreAltitude<AutopilotTargetOrbit*1.5)then OrbitAchieved=false;Autopilot=true elseif not inAtmo then if IntoOrbit then ToggleIntoOrbit()end;OrbitTargetOrbit=planet.noAtmosphericDensityAltitude+LowOrbitHeight;OrbitTargetSet=true;orbitalParams.AutopilotAlign=true;orbitalParams.VectorToTarget=true;orbitAligned=false;if not IntoOrbit then ToggleIntoOrbit()end end end else play("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if atmosDensity~=0 then spaceLaunch=true;ToggleAltitudeHold()else Autopilot=true end end elseif atmosDensity==0 then if CustomTarget==nil and(autopilotTargetPlanet.name==planet.name and nearPlanet)and not IntoOrbit then WaypointSet=false;OrbitAchieved=false;orbitAligned=false;ToggleIntoOrbit()else play("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;followMode=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;apThrottleSet=false;LockPitch=nil;WaypointSet=false end else play("apP","AP")spaceLaunch=true;ToggleAltitudeHold()end else play("apOff","AP")ResetAutopilots(1)end end;function BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;autoRoll=autoRollPreference end;if BrakeIsOn then play("bkOn","B",1)ResetAutopilots()else play("bkOff","B",1)end end;function BeginReentry()if Reentry then msgText="Re-Entry cancelled"play("reOff","RE")Reentry=false;autoRoll=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then msgText="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"msgTimer=5 elseif not reentryMode then Reentry=true;if navCom:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;autoRoll=true;BrakeIsOn=false;msgText="Beginning Parachute Re-Entry - Strap In.  Target speed: "..adjustedAtmoSpeedLimit;play("par","RE")else Reentry=true;AltitudeHold=true;autoRoll=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local y=getDistanceDisplayString(HoldAltitude)msgText="Beginning Re-entry.  Target speed: "..adjustedAtmoSpeedLimit.." Target Altitude: "..y;play("glide","RE")cmdCruise(mfloor(adjustedAtmoSpeedLimit))end;AutoTakeoff=false end;function ToggleAntigrav()if antigrav and not ExternalAGG then if antigravOn then play("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;play("aggOn","AG")antigrav.activate()antigrav.show()end end end;function FormatTimeString(J)local K=0;local L=0;local M=0;if J<60 then J=mfloor(J)elseif J<3600 then K=mfloor(J/60)J=mfloor(J%60)elseif J<86400 then L=mfloor(J/3600)K=mfloor(J%3600/60)else M=mfloor(J/86400)L=mfloor(J%86400/3600)end;if M>0 then return M.."d "..L.."h "elseif L>0 then return L.."h "..K.."m "elseif K>0 then return K.."m "..J.."s"elseif J>0 then return J.."s"else return"0s"end end;function SaveDataBank(N)local function O(P)for Q,R in pairs(P)do dbHud_1.setStringValue(R,jencode(_G[R]))if N and dbHud_2 then dbHud_2.setStringValue(R,jencode(_G[R]))end end end;if dbHud_1 then O(autoVariables)O(saveableVariables())system.print("Saved Variables to Datacore")if N and dbHud_2 then msgText="Databank copied.  Remove copy when ready."end end end;function ConvertResolutionX(R)if resolutionWidth==1920 then return R else return round(resolutionWidth*R/1920,0)end end;function ConvertResolutionY(R)if resolutionHeight==1080 then return R else return round(resolutionHeight*R/1080,0)end end;local function S()local function T(U)return type(U)=='number'end;local function V(U)return type(tonum(U))=='number'end;local function W(X)return type(X)=='table'end;local function Y(Z)return type(Z)=='string'end;local function a0(R)return W(R)and T(R.x and R.y and R.z)end;local function a1(a2)return W(a2)and T(a2.latitude and a2.longitude and a2.altitude and a2.id and a2.systemId)end;local a3=math.pi/180;local a4=180/math.pi;local epsilon=1e-10;local c=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local a5='::pos{'..c..','..c..','..c..','..c..','..c..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function a6(U)local a7=string.gsub(string.reverse(stringf('%.4f',U)),'^0*%.?','')return a7==''and'0'or string.reverse(a7)end;local function a8(a9)if a0(a9)then return stringf('{x=%.3f,y=%.3f,z=%.3f}',a9.x,a9.y,a9.z)end;if W(a9)and not getmetatable(a9)then local aa={}local ab=next(a9)if type(ab)=='nil'or ab==1 then aa=a9 else for Q,R in pairs(a9)do local B=a8(R)if type(Q)=='number'then table.insert(aa,stringf('[%s]=%s',Q,B))else table.insert(aa,stringf('%s=%s',Q,B))end end end;return stringf('{%s}',table.concat(aa,','))end;if Y(a9)then return stringf("'%s'",a9:gsub("'",[[\']]))end;return tostring(a9)end;local ac={}ac.__index=ac;ac.__tostring=function(a9,ad)local ae={}for Q in pairs(a9)do table.insert(ae,Q)end;table.sort(ae)local aa={}for _,Q in ipairs(ae)do local B=a8(a9[Q])if type(Q)=='number'then table.insert(aa,stringf('[%s]=%s',Q,B))else table.insert(aa,stringf('%s=%s',Q,B))end end;if ad then return stringf('%s%s',ad,table.concat(aa,',\n'..ad))end;return stringf('{%s}',table.concat(aa,','))end;ac.__eq=function(af,ag)return af.systemId==ag.systemId and af.id==ag.id and float_eq(af.radius,ag.radius)and float_eq(af.center.x,ag.center.x)and float_eq(af.center.y,ag.center.y)and float_eq(af.center.z,ag.center.z)and float_eq(af.GM,ag.GM)end;local function ah(ai,aj,ak,al,am)assert(V(ai),'Argument 1 (systemId) must be a number:'..type(ai))assert(V(aj),'Argument 2 (id) must be a number:'..type(aj))assert(V(ak),'Argument 3 (radius) must be a number:'..type(ak))assert(W(al),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(al))assert(V(am),'Argument 5 (GM) must be a number:'..type(am))return setmetatable({systemId=tonum(ai),id=tonum(aj),radius=tonum(ak),center=vec3(al),GM=tonum(am)},ac)end;local an={}an.__index=an;an.__tostring=function(p)return stringf('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,a6(p.latitude*a4),a6(p.longitude*a4),a6(p.altitude))end;an.__eq=function(af,ag)return af.id==ag.id and af.systemId==ag.systemId and float_eq(af.latitude,ag.latitude)and float_eq(af.altitude,ag.altitude)and(float_eq(af.longitude,ag.longitude)or float_eq(af.latitude,math.pi/2)or float_eq(af.latitude,-math.pi/2))end;local function ao(ap,aj,aq,ar,as)local ai=ap;if Y(ap)and not ar and not as and not aj and not aq then ai,aj,aq,ar,as=stringmatch(ap,a5)assert(ai,'Argument 1 (position string) is malformed.')else assert(V(ai),'Argument 1 (systemId) must be a number:'..type(ai))assert(V(aj),'Argument 2 (id) must be a number:'..type(aj))assert(V(aq),'Argument 3 (latitude) must be in degrees:'..type(aq))assert(V(ar),'Argument 4 (longitude) must be in degrees:'..type(ar))assert(V(as),'Argument 5 (altitude) must be in meters:'..type(as))end;ai=tonum(ai)aj=tonum(aj)aq=tonum(aq)ar=tonum(ar)as=tonum(as)if aj==0 then return setmetatable({latitude=aq,longitude=ar,altitude=as,id=aj,systemId=ai},an)end;return setmetatable({latitude=a3*uclamp(aq,-90,90),longitude=a3*(ar%360),altitude=as,id=aj,systemId=ai},an)end;local at={}at.__index=at;at.__tostring=function(a9,ad)local au=ad and ad..'  'local av={}local ae={}for Q in pairs(a9)do table.insert(ae,Q)end;table.sort(ae)for _,aw in ipairs(ae)do bdy=a9[aw]local ax=ac.__tostring(bdy,au)if ad then table.insert(av,stringf('[%s]={\n%s\n%s}',aw,ax,ad))else table.insert(av,stringf('  [%s]=%s',aw,ax))end end;if ad then return stringf('\n%s%s%s',ad,table.concat(av,',\n'..ad),ad)end;return stringf('{\n%s\n}',table.concat(av,',\n'))end;local function ay(az)local b={}local pid;for _,R in pairs(az)do local aj=R.planetarySystemId;if type(aj)~='number'then error('Invalid planetary system ID: '..tostring(aj))elseif pid and aj~=pid then error('Mistringmatch planetary system IDs: '..aj..' and '..pid)end;local aA=R.bodyId;if type(aA)~='number'then error('Invalid body ID: '..tostring(aA))elseif b[aA]then error('Duplicate body ID: '..tostring(aA))end;setmetatable(R.center,getmetatable(vec3.unit_x))b[aA]=setmetatable(R,ac)pid=aj end;return setmetatable(b,at)end;PlanetaryReference={}local function aB(az)return setmetatable({galaxyAtlas=az or{}},PlanetaryReference)end;PlanetaryReference.__index=function(X,i)if type(i)=='number'then local system=X.galaxyAtlas[i]return ay(system)end;return rawget(PlanetaryReference,i)end;PlanetaryReference.__pairs=function(a9)return function(X,Q)local aC,nv=next(X,Q)return aC,nv and ay(nv)end,a9.galaxyAtlas,nil end;PlanetaryReference.__tostring=function(a9)local aD={}for _,aE in pairs(a9 or{})do local aF=aE:getPlanetarySystemId()local aG=at.__tostring(aE,'    ')table.insert(aD,stringf('  [%s]={%s\n  }',aF,aG))end;return stringf('{\n%s\n}\n',table.concat(aD,',\n'))end;PlanetaryReference.BodyParameters=ah;PlanetaryReference.MapPosition=ao;PlanetaryReference.PlanetarySystem=ay;function PlanetaryReference.createBodyParameters(ai,aj,aH,aI,aJ,aK,aL)assert(V(ai),'Argument 1 (systemId) must be a number:'..type(ai))assert(V(aj),'Argument 2 (id) must be a number:'..type(aj))assert(V(aH),'Argument 3 (surfaceArea) must be a number:'..type(aH))assert(W(aI),'Argument 4 (aPosition) must be an array or vec3:'..type(aI))assert(W(aJ),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(aJ))assert(V(aK),'Argument 6 (altitude) must be in meters:'..type(aK))assert(V(aL),'Argument 7 (gravityAtPosition) must be number:'..type(aL))local ak=msqrt(aH/4/math.pi)local distance=ak+aK;local aM=vec3(aI)+distance*vec3(aJ)local am=aL*distance*distance;return ah(ai,aj,ak,aM,am)end;PlanetaryReference.isMapPosition=a1;function PlanetaryReference:getPlanetarySystem(ap)if i==nil then i=0 end;if nv==nil then nv=0 end;local ai=ap;if a1(ap)then ai=ap.systemId end;if type(ai)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=at then system=ay(system)end;return system end end end;function at:sizeCalculator(n)return 1.05*n.radius end;function at:castIntersections(aN,aO,aP,aQ,aR,aS)local aT={}local aU=aR or self;for _,n in pairs(aU)do table.insert(aT,n)end;if not aS then table.sort(aT,function(aV,aW)return(aV.center-aN):len()<(aW.center-aN):len()end)end;local aX=aO:normalize()for _,n in ipairs(aT)do local aY=n.center-aN;local ak=self:sizeCalculator(n)local aZ=aY:dot(aX)local a_=aZ^2-(aY:len2()-ak^2)if a_>=0 then local b0=msqrt(a_)local l=aZ+b0;local m=aZ-b0;if m>0 then return n,l,m elseif l>0 then return n,l,nil end end end;return nil,nil,nil end;function at:closestBody(b1)assert(type(b1)=='table','Invalid coordinates.')local b2,n;local b3=vec3(b1)for _,b4 in pairs(self)do local b5=(b4.center-b3):len2()if(not n or b5<b2)and b4.name~="Space"then n=b4;b2=b5 end end;return n end;function at:convertToBodyIdAndWorldCoordinates(ap)local b6=ap;if Y(ap)then b6=ao(ap)end;if b6.id==0 then return 0,vec3(b6.latitude,b6.longitude,b6.altitude)end;local b4=self:getBodyParameters(b6)if b4 then return b6.id,b4:convertToWorldCoordinates(b6)end end;function at:getBodyParameters(ap)local aj=ap;if a1(ap)then aj=ap.id end;assert(V(aj),'Argument 1 (id) must be a number:'..type(aj))return self[aj]end;function at:getPlanetarySystemId()local _,R=next(self)return R and R.systemId end;function ac:convertToMapPosition(al)assert(W(al),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(al))local b7=vec3(al)if self.id==0 then return setmetatable({latitude=b7.x,longitude=b7.y,altitude=b7.z,id=0,systemId=self.systemId},an)end;local b8=b7-self.center;local distance=b8:len()local as=distance-self.radius;local aq=0;local ar=0;if not float_eq(distance,0)then local b9=atan(b8.y,b8.x)ar=b9>=0 and b9 or 2*math.pi+b9;aq=math.pi/2-math.acos(b8.z/distance)end;return setmetatable({latitude=aq,longitude=ar,altitude=as,id=self.id,systemId=self.systemId},an)end;function ac:convertToWorldCoordinates(ap)local b6=Y(ap)and ao(ap)or ap;if b6.id==0 then return vec3(b6.latitude,b6.longitude,b6.altitude)end;assert(a1(b6),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(b6.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(b6.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local ba=math.cos(b6.latitude)return self.center+(self.radius+b6.altitude)*vec3(ba*math.cos(b6.longitude),ba*math.sin(b6.longitude),math.sin(b6.latitude))end;function ac:getAltitude(al)return(vec3(al)-self.center):len()-self.radius end;function ac:getDistance(al)return(vec3(al)-self.center):len()end;function ac:getGravity(al)local bb=self.center-vec3(al)local bc=bb:len2()return self.GM/bc*bb/msqrt(bc)end;return setmetatable(PlanetaryReference,{__call=function(_,...)return aB(...)end})end;local function bd()local Kinematic={}local be=30000000/3600;local bf=be*be;local bg=100;function Kinematic.computeAccelerationTime(bh,bi,bj)local bk=be*math.asin(bh/be)return(be*math.asin(bj/be)-bk)/bi end;function Kinematic.computeDistanceAndTime(bh,bj,bl,bm,bn,bo)bn=bn or 0;bo=bo or 0;local bp=bh<=bj;local bq=bm*(bp and 1 or-1)/bl;local br=-bo/bl;local bs=bq+br;if bp and bs<=0 or not bp and bs>=0 then return-1,-1 end;local bt,bu=0,0;if bq~=0 and bn>0 then local bk=math.asin(bh/be)local bv=math.pi*(bq/2+br)local bw=bq*bn;local bx=be*math.pi;local R=function(X)local by=(bv*X-bw*math.sin(math.pi*X/2/bn)+bx*bk)/bx;local bz=math.tan(by)return be*bz/msqrt(bz*bz+1)end;local bA=bp and function(Z)return Z>=bj end or function(Z)return Z<=bj end;bu=2*bn;if bA(R(bu))then local bB=0;while mabs(bu-bB)>0.5 do local X=(bu+bB)/2;if bA(R(X))then bu=X else bB=X end end end;local bC=bh;local bD=bu/bg;for bE=1,bg do local bF=R(bE*bD)bt=bt+(bF+bC)*bD/2;bC=bF end;if bu<2*bn then return bt,bu end;bh=bC end;local bk=be*math.asin(bh/be)local time=(be*math.asin(bj/be)-bk)/bs;local bG=bf*math.cos(bk/be)/bs;local distance=bG-bf*math.cos((bs*time+bk)/be)/bs;return distance+bt,time+bu end;function Kinematic.computeTravelTime(bh,bi,distance)if distance==0 then return 0 end;if bi>0 then local bk=be*math.asin(bh/be)local bG=bf*math.cos(bk/be)/bi;return(be*math.acos(bi*(bG-distance)/bf)-bk)/bi end;if bh==0 then return-1 end;assert(bh>0,'Acceleration and initial speed are both zero.')return distance/bh end;return Kinematic end;local function bH()local vec3=require('cpml.vec3')local S=S()local function Y(Z)return type(Z)=='string'end;local function W(X)return type(X)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(as)assert(self.body)local distance=as+self.body.radius;if not float_eq(distance,0)then local bI=msqrt(self.body.GM/distance)return msqrt(2)*bI,bI end;return nil,nil end;function Kepler:orbitalParameters(ap,bJ)assert(self.body)assert(W(ap)or Y(ap))assert(W(bJ))local bK=(Y(ap)or S.isMapPosition(ap))and self.body:convertToWorldCoordinates(ap)or vec3(ap)local R=vec3(bJ)local bL=bK-self.body.center;local bM=R:len2()local bN=bL:len()local bO=self.body.GM;local bP=((bM-bO/bN)*bL-bL:dot(R)*R)/bO;local D=bO/(2*bO/bN-bM)local bQ=bP:len()local aX=bP:normalize()local bR=D*(1-bQ)local bS=D*(1+bQ)local bT=bR*aX+self.body.center;local bU=bQ<=1 and-bS*aX+self.body.center or nil;local bV=msqrt(D*bO*(1-bQ*bQ))local bW=bU and 2*math.pi*msqrt(D^3/bO)local bX=math.acos(bP:dot(bL)/(bQ*bN))if bL:dot(R)<0 then bX=-(bX-2*math.pi)end;local bY=math.acos((math.cos(bX)+bQ)/(1+bQ*math.cos(bX)))local bZ=bY;if bZ<0 then bZ=bZ+2*math.pi end;local b_=bZ-bQ*math.sin(bZ)local c0=0;local c1=0;local c2=0;if bW~=nil then c0=b_/(2*math.pi/bW)c1=bW-c0;c2=c1+bW/2;if bX-math.pi>0 then c1=c0;c2=c1+bW/2 end;if c2>bW then c2=c2-bW end end;return{periapsis={position=bT,speed=bV/bR,circularOrbitSpeed=msqrt(bO/bR),altitude=bR-self.body.radius},apoapsis=bU and{position=bU,speed=bV/bS,circularOrbitSpeed=msqrt(bO/bS),altitude=bS-self.body.radius},currentVelocity=R,currentPosition=bK,eccentricity=bQ,period=bW,eccentricAnomaly=bY,meanAnomaly=b_,timeToPeriapsis=c1,timeToApoapsis=c2}end;local function c3(c4)local b4=S.BodyParameters(c4.systemId,c4.id,c4.radius,c4.center,c4.GM)return setmetatable({body=b4},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return c3(...)end})end;local function c5()local c6={}local c7={}local c8={XS=13,S=27,M=55,L=110,XL=221}local c9={}local ca;local cb;local cc;local cd;local ce;local function cf()local function cg(ch,ci,cj,ck,cl,cm,cn,co)ci,ck,cm,co=vec3(ci),vec3(ck),vec3(cm),vec3(co)local cp,cq,cr=ch*ch,cj*cj,cl*cl;local bM=ck-ci;local cs=bM:normalize()local ct=bM:len()local cu=cm-ci;local cv=(cu-cu:project_on(cs)):normalize()local cw,cx=cu:dot(cs),cu:dot(cv)local cy=cw*cw+cx*cx;local cz=cs:cross(cv)local w=(cp-cq+ct*ct)/(2*ct)local x=(cp-cr+cy-2*cw*w)/(2*cx)local a2=cp-w^2-x^2;local cA=msqrt(a2)local cB=ci+cs*w+cv*x+cz*cA;local cC=ci+cs*w+cv*x-cz*cA;if mabs((co-cB):len()-cn)<mabs((co-cC):len()-cn)then return cB else return cC end end;local function cD()local function cE()local cF=core.getConstructWorldOrientationRight()local bM=core.getConstructWorldOrientationForward()local cu=core.getConstructWorldOrientationUp()local cG=library.systemResolution3(cF,bM,cu,{1,0,0})local cH=library.systemResolution3(cF,bM,cu,{0,1,0})local cI=library.systemResolution3(cF,bM,cu,{0,0,1})return function(cJ)return library.systemResolution3(cG,cH,cI,cJ)end end;local cK=cE()local cL=core.getConstructWorldPos()local bK=core.getElementPositionById(1)local cM={bK[1],bK[2],bK[3]}local cN=cK(cM)local cO={cL[1]-cN[1],cL[2]-cN[2],cL[3]-cN[3]}return cO end;local function cP(cQ,bN,cR)local cS=cQ.pts;local cT=#cS;local cU=cQ.ref;if cT>3 then local cV,cW,cX,cY=cS[cT],cS[cT-1],cS[cT-2],cS[cT-3]cQ.ref=cR;local bK=cg(cV[1],cV[2],cW[1],cW[2],cX[1],cX[2],cY[1],cY[2])local w,x,cA=bK.x,bK.y,bK.z;if w==w and x==x and cA==cA then w=w+cU[1]x=x+cU[2]cA=cA+cU[3]local cZ=vec3(w,x,cA)if not cQ.lastPos then cQ.center=cZ elseif(cQ.lastPos-cZ):len()<2 then cQ.center=cZ;cQ.skipCalc=true end;cQ.lastPos=cZ end;cQ.pts={}else local c_={cR[1]-cU[1],cR[2]-cU[2],cR[3]-cU[3]}cS[cT+1]={bN,c_}end end;if radars[1]then ca=#radars[1].getConstructIds()local d0=radars[1].getData()local d1=d0:gmatch('{"constructId[^}]*}[^}]*}')if ca>0 then local cR=cD()local d2,d3=0,0;ce,cd=0,0;for R in d1 do local aj,distance,d4=R:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local d5=c8[d4]distance=tonum(distance)if radars[1].hasMatchingTransponder(aj)==1 then table.insert(c7,aj)end;local d6=radars[1].getConstructType(aj)if CollisionSystem then if d5>27 or d6=="static"or d6=="space"then ce=ce+1;local d7=radars[1].getConstructName(aj)local cQ=contacts[aj]if cQ==nil then d5=d5+coreHalfDiag;contacts[aj]={pts={},ref=cR,name=d7,i=0,radius=d5,skipCalc=false}cQ=contacts[aj]end;if not cQ.skipCalc then cP(cQ,distance,cR)d3=d3+1 end;if cQ.center then table.insert(c9,cQ)end end;d2=d2+1;if nearPlanet and d2>700 or d3>70 or(not nearPlanet and d2>300 or d3>30)then coroutine.yield()d2,d3=0,0 end end end;cd=#c9;if cd>0 and velMag>20 then local n,d8,d9,da;local db=0;local dc=galaxyReference:getPlanetarySystem(0)da=constructVelocity:normalize()while db<cd do coroutine.yield()local dd={table.unpack(c9,db,math.min(db+75,cd))}n,d8,d9=dc:castIntersections(worldPos,da,nil,nil,dd,true)if n and d9 then collisionTarget={n,d8,d9}break end;db=db+75 end;if not n then collisionTarget=nil end else collisionTarget=nil end;c9={}cb=d0:find('identifiedConstructs":%[%]')else cc=d0:find('worksInEnvironment":false')end end end;local function de()if radars[1]then rType="Atmo"if radars[1].getData():find('worksInAtmosphere":false')then rType="Space"end end end;function c6.pickType()de()end;function c6.assignRadar()if radar_1 and radars[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then radars[1]=radar_2 end;if radars[1]==radar_2 then de()end elseif radar_2 and radars[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then radars[1]=radar_1 end;if radars[1]==radar_1 then de()end end end;function c6.UpdateRadar()local df=coroutine.status(UpdateRadarCoroutine)if df=="suspended"then local B,dg=coroutine.resume(UpdateRadarCoroutine)if dg then system.print("ERROR UPDATE RADAR: "..dg)end elseif df=="dead"then UpdateRadarCoroutine=coroutine.create(cf)local B,dg=coroutine.resume(UpdateRadarCoroutine)end end;function c6.GetRadarHud()local dh=c7;c7={}return cb,cc,ca,cd,ce,dh end;UpdateRadarCoroutine=coroutine.create(cf)return c6 end;local function di()local function dj(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function dk()local function dl(dm,dn)return dm.name<dn.name end;AtlasOrdered={}for Q,R in pairs(b[0])do AtlasOrdered[#AtlasOrdered+1]={name=R.name,index=Q}end;table.sort(AtlasOrdered,dl)end;local function dp(dq)for Q,R in pairs(dq)do if R.name and R.name==CustomTarget.name then return Q end end;return-1 end;local function dr()apScrollIndex=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"autopilotTargetPlanet=nil;CustomTarget=nil;return true end;local ds=AtlasOrdered[AutopilotTargetIndex].index;local dt=b[0][ds]if dt.center then AutopilotTargetName=dt.name;autopilotTargetPlanet=galaxyReference[0][ds]if CustomTarget~=nil then if atmosDensity==0 then if sysUpData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then sysAddData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if sysUpData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then sysAddData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if sysUpData(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then sysAddData(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if sysUpData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then sysAddData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if sysUpData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then sysAddData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if sysUpData(widgetMaxMassText,widgetMaxMass)~=1 then sysAddData(widgetMaxMassText,widgetMaxMass)end;if sysUpData(widgetTravelTimeText,widgetTravelTime)~=1 then sysAddData(widgetTravelTimeText,widgetTravelTime)end;if sysUpData(widgetTargetOrbitText,widgetTargetOrbit)~=1 then sysAddData(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=dt;for _,R in pairs(galaxyReference[0])do if R.name==CustomTarget.planetname then autopilotTargetPlanet=R;AutopilotTargetName=CustomTarget.name;break end end;if sysUpData(widgetMaxMassText,widgetMaxMass)~=1 then sysAddData(widgetMaxMassText,widgetMaxMass)end;if sysUpData(widgetTravelTimeText,widgetTravelTime)~=1 then sysAddData(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)else AutopilotTargetCoords=CustomTarget.position end;if autopilotTargetPlanet.planetname~="Space"then if autopilotTargetPlanet.hasAtmosphere then AutopilotTargetOrbit=mfloor(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=mfloor(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function du(dv)if not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit then if dv==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then dr()else local ds=AtlasOrdered[AutopilotTargetIndex].index;local dt=b[0][ds]if dt~=nil and dt.name=="Space"or iphCondition=="Custom Only"and dt.center or iphCondition=="No Moons"and string.find(dt.name,"Moon")~=nil then if dv==nil then du()else du(1)end else dr()end end else msgText="Disengage autopilot before changing Interplanetary Helper"play("iph","AP")end end;local function dw()local cT=-1;cT=dp(b[0])if cT>-1 then table.remove(b[0],cT)end;cT=-1;cT=dp(SavedLocations)if cT~=-1 then msgText=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cT)end;du()dk()end;local function dx(d7,position,dy,dz)if dbHud_1 or dy then local p=dj(position)local dA=p.gravity;if dz then dA=unit.getClosestPlanetInfluence()end;local dB={position=position,name=d7,planetname=p.name,gravity=dA,safe=dz}if not dy then SavedLocations[#SavedLocations+1]=dB else for Q,R in pairs(b[0])do if R.name and d7==R.name then table.remove(b[0],Q)end end end;table.insert(b[0],dB)dk()dr()msgText="Location saved as "..d7 .."("..p.name..")"else msgText="Databank must be installed to save permanent locations"end end;local dC={}function dC.UpdateAtlasLocationsList()dk()end;function dC.UpdateAutopilotTarget()dr()end;function dC.adjustAutopilotTargetIndex(dv)du(dv)end;function dC.findAtlasIndex(dq)dp(dq)end;function dC.UpdatePosition(dD)local cT=dp(SavedLocations)if cT~=-1 then if dD~=nil then SavedLocations[cT].name=dD;AutopilotTargetIndex=AutopilotTargetIndex-1;du()else local dE=SavedLocations[cT]dE.gravity=unit.getClosestPlanetInfluence()dE.position=worldPos;dE.safe=true end;msgText=SavedLocations[cT].name.." position updated ("..SavedLocations[cT].planetname..")"else msgText="Name Not Found"end end;function dC.AddNewLocation(d7,position,dy,dz)dx(d7,position,dy,dz)end;function dC.ClearCurrentPosition()dw()end;for Q,R in pairs(SavedLocations)do table.insert(b[0],R)end;dk()if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end;dC.UpdateAutopilotTarget()return dC end;function script.onStart()local dF=false;local function dG()local function dH(dI)local dJ=dbHud_1.hasKey;for Q,R in pairs(dI)do if dJ(R)then local a7=jdecode(dbHud_1.getStringValue(R))if a7~=nil then _G[R]=a7;dF=true end end end end;if dbHud_1 then if not useTheseSettings then dH(saveableVariables())coroutine.yield()dH(autoVariables)else dH(autoVariables)msgText="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"msgTimer=5;dF=false end;coroutine.yield()if dF then msgText="Loaded Saved Variables"resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)autoRoll=autoRollPreference;adjustedAtmoSpeedLimit=AtmoSpeedLimit;rgb=[[rgb(]]..mfloor(PrimaryR+0.5)..","..mfloor(PrimaryG+0.5)..","..mfloor(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..mfloor(PrimaryR*0.9+0.5)..","..mfloor(PrimaryG*0.9+0.5)..","..mfloor(PrimaryB*0.9+0.5)..[[)]]elseif not useTheseSettings then msgText="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then msgText="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else msgText="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<time then LastMaxBrakeInAtmo=0 end;LastStartTime=time;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then msgText="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"msgTimer=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function dK()local function dL(dM,dN)if dM>dN then dN=dM end;local dO,dP=0,0;if ContainerOptimization>0 then dO=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then dP=FuelTankOptimization*0.05 end;dN=dN*(1-(dO+dP))return dN end;local dQ=core.getElementNameById;local dR=fuelX~=0 and fuelY~=0;for Q in pairs(elementsID)do local type=core.getElementTypeById(elementsID[Q])if stringmatch(type,'^.*Atmospheric Engine$')then if stringmatch(tostring(core.getElementTagsById(elementsID[Q])),'^.*vertical.*$')and core.getElementForwardById(elementsID[Q])[3]>0 then UpVertAtmoEngine=true end end;if stringmatch(type,'^.*Space Engine$')then SpaceEngines=true;if stringmatch(tostring(core.getElementTagsById(elementsID[Q])),'^.*vertical.*$')then local dS=core.getElementForwardById(elementsID[Q])if dS[3]<0 then SpaceEngineVertUp=true else SpaceEngineVertDn=true end end end;if type=="Landing Gear"then hasGear=true end;if type=="Dynamic Core Unit"then local dT=eleMaxHp(elementsID[Q])if dT>10000 then coreHalfDiag=110 elseif dT>1000 then coreHalfDiag=55 elseif dT>150 then coreHalfDiag=27 end end;eleTotalMaxHp=eleTotalMaxHp+eleMaxHp(elementsID[Q])if dR and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local dT=eleMaxHp(elementsID[Q])local dU=eleMass(elementsID[Q])local dM=0;local dV=systime()if type=="Atmospheric Fuel Tank"then local dN=400;local dW=35.03;if dT>10000 then dN=51200;dW=5480 elseif dT>1300 then dN=6400;dW=988.67 elseif dT>150 then dN=1600;dW=182.67 end;dM=dU-dW;if fuelTankHandlingAtmo>0 then dN=dN+dN*fuelTankHandlingAtmo*0.2 end;dN=dL(dM,dN)atmoTanks[#atmoTanks+1]={elementsID[Q],dQ(elementsID[Q]),dN,dW,dM,dV}end;if type=="Rocket Fuel Tank"then local dN=320;local dW=173.42;if dT>65000 then dN=40000;dW=25740 elseif dT>6000 then dN=5120;dW=4720 elseif dT>700 then dN=640;dW=886.72 end;dM=dU-dW;if fuelTankHandlingRocket>0 then dN=dN+dN*fuelTankHandlingRocket*0.1 end;dN=dL(dM,dN)rocketTanks[#rocketTanks+1]={elementsID[Q],dQ(elementsID[Q]),dN,dW,dM,dV}end;if type=="Space Fuel Tank"then local dN=600;local dW=35.03;if dT>10000 then dN=76800;dW=5480 elseif dT>1300 then dN=9600;dW=988.67 elseif dT>150 then dN=2400;dW=182.67 end;dM=dU-dW;if fuelTankHandlingSpace>0 then dN=dN+dN*fuelTankHandlingSpace*0.2 end;dN=dL(dM,dN)spaceTanks[#spaceTanks+1]={elementsID[Q],dQ(elementsID[Q]),dN,dW,dM,dV}end end end;if not UpVertAtmoEngine then VertTakeOff,VertTakeOffEngine=false,false end end;local function dX()if gyro~=nil then gyroIsOn=gyro.getState()==1 end;if not stablized then navCom:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then sysLockVw(1)else sysLockVw(0)end;if door and(inAtmo or not inAtmo and coreAltitude<10000)then for _,R in pairs(door)do R.toggle()end end;if switch then for _,R in pairs(switch)do R.toggle()end end;if forcefield and(inAtmo or not inAtmo==0 and coreAltitude<10000)then for _,R in pairs(forcefield)do R.toggle()end end;if antigrav then antigravOn=antigrav.getState()==1;if antigravOn and not ExternalAGG then antigrav.show()end end;if isRemote()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if hasGear then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if abvGndDet~=-1 or not inAtmo and coreVelocity:len()<50 then BrakeIsOn=true;GearExtended=true;if hasGear then a.control.extendLandingGears()end else BrakeIsOn=false end;navCom:setTargetGroundAltitude(targetGroundAltitude)if inAtmo and abvGndDet~=-1 then maxKinematicUp=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=inAtmo end;local function dY()local dZ={}local function d_()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local e0={[1]=4480,[6]=4480,[7]=6270}for e1,e2 in pairs(b)do b[e1][0]=d_()b[e1][0].systemId=e1;dZ[e1]={}for e3,planet in pairs(b[e1])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=e0[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=e1;planet.bodyId=planet.id;dZ[e1][e3]=planet end end;PlanetaryReference=S()galaxyReference=PlanetaryReference(dZ)Kinematic=bd()Kep=bH()ATLAS=di()end;SetupComplete=false;beginSetup=coroutine.create(function()navCom:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})dG()coroutine.yield()dK()coroutine.yield()AP=APClass()dX()coroutine.yield()dY()RADAR=c5()HUD=HudClass()HUD.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)radars[1]=nil;if radar_1 then radars[1]=radar_1;RADAR.pickType()end;play("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,R in pairs(door)do R.toggle()end end;if switch then for _,R in pairs(switch)do R.toggle()end end;if forcefield and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,R in pairs(forcefield)do R.toggle()end end;SaveDataBank()if button then button.activate()end;if SetWaypointOnExit then AP.showWayPoint(planet,worldPos)end;play("stop","SU")end;function script.onTick(e4)local e5=nil;if e4=="contact"then if not contactTimer then contactTimer=0 end;if time>contactTimer+10 then msgText="Radar Contact"play("rdrCon","RC")contactTimer=time end;unit.stopTimer("contact")elseif e4=="tenthSecond"then local function e6()local e7=system.createData;local e8=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=e8(panelInterplanetary,"value")interplanetaryHeaderText=e7('{"label": "Target Planet", "value": "N/A", "unit":""}')sysAddData(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=e8(panelInterplanetary,"value")widgetDistanceText=e7('{"label": "distance", "value": "N/A", "unit":""}')sysAddData(widgetDistanceText,widgetDistance)widgetTravelTime=e8(panelInterplanetary,"value")widgetTravelTimeText=e7('{"label": "Travel Time", "value": "N/A", "unit":""}')sysAddData(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=e8(panelInterplanetary,"value")widgetMaxMassText=e7('{"label": "Maximum Mass", "value": "N/A", "unit":""}')sysAddData(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=e8(panelInterplanetary,"value")widgetTargetOrbitText=e7('{"label": "Target Altitude", "value": "N/A", "unit":""}')sysAddData(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=e8(panelInterplanetary,"value")widgetCurBrakeDistanceText=e7('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=e8(panelInterplanetary,"value")widgetCurBrakeTimeText=e7('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=e8(panelInterplanetary,"value")widgetMaxBrakeDistanceText=e7('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=e8(panelInterplanetary,"value")widgetMaxBrakeTimeText=e7('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=e8(panelInterplanetary,"value")widgetTrajectoryAltitudeText=e7('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not inAtmo then sysAddData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)sysAddData(widgetCurBrakeTimeText,widgetCurBrakeTime)sysAddData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)sysAddData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)sysAddData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function e9()sysDestWid(panelInterplanetary)panelInterplanetary=nil end;local function ea()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(autopilotTargetPlanet.center-worldPos):len()else AutopilotDistance=(CustomTarget.position-worldPos):len()end end;local bF=velMag;local eb=unit.getThrottle()/100;if AtmoSpeedAssist then eb=PlayerThrottle end;local ec,ed=Kinematic.computeDistanceAndTime(velMag,MaxGameVelocity,coreMass,a:maxForceForward()*eb,warmup,0)local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,ee;if not TurnBurn and bF>0 then _,ee=AP.GetAutopilotBrakeDistanceAndTime(bF)else _,ee=AP.GetAutopilotTBBrakeDistanceAndTime(bF)end;local ef=0;local eg=0;if AutopilotCruising or not Autopilot and bF>5 then eg=Kinematic.computeTravelTime(bF,0,AutopilotDistance)elseif brakeDistance+ec<AutopilotDistance then ef=AutopilotDistance-(brakeDistance+ec)eg=Kinematic.computeTravelTime(8333.0556,0,ef)else local eh=(AutopilotDistance-brakeDistance)/ec;ec=AutopilotDistance-brakeDistance;ed=ed*eh end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return eg elseif AutopilotBraking then return ee elseif AutopilotCruising then return eg+ee else return ed+brakeTime+eg end end;local function ei(dA,ej)if dA==nil then dA=core.g()end;dA=round(dA,5)if ej~=nil and ej or(e5==nil or e5~=dA)then local bF=coreVelocity:len()local ek=jdecode(unit.getData()).maxBrake;if ek~=nil and ek>0 and inAtmo then ek=ek/uclamp(bF/100,0.1,1)ek=ek/atmosDensity;if atmosDensity>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+ek)/2 else LastMaxBrakeInAtmo=ek end end end;if ek~=nil and ek>0 then LastMaxBrake=ek end;e5=dA end end;ei(nil,true)if setCruiseSpeed~=nil then if navCom:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or navCom:getTargetSpeed(axisCommandId.longitudinal)~=setCruiseSpeed then cmdCruise(setCruiseSpeed)else setCruiseSpeed=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then e6()end;if AutopilotTargetName~=nil then local el=CustomTarget~=nil;local em=0.5*LastMaxBrakeInAtmo/autopilotTargetPlanet:getGravity(autopilotTargetPlanet.center+vec3(0,0,1)*autopilotTargetPlanet.radius):len()em=em>1000000 and round(em/1000000,2).." kTons"or round(em/1000,2).." Tons"sysUpData(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=ea()if el and not Autopilot then distance=(worldPos-CustomTarget.position):len()else distance=(AutopilotTargetCoords-worldPos):len()end;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(velMag)maxBrakeDistance,maxBrakeTime=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(velMag)maxBrakeDistance,maxBrakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local en=getDistanceDisplayString(distance)sysUpData(widgetDistanceText,'{"label": "distance", "value": "'..en..'"}')sysUpData(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..FormatTimeString(travelTime)..'", "unit":""}')en=getDistanceDisplayString(brakeDistance)sysUpData(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..en..'"}')sysUpData(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..FormatTimeString(brakeTime)..'", "unit":""}')en=getDistanceDisplayString(maxBrakeDistance)sysUpData(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..en..'"}')sysUpData(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..FormatTimeString(maxBrakeTime)..'", "unit":""}')sysUpData(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..stringf("%s",em)..'", "unit":""}')en=getDistanceDisplayString(AutopilotTargetOrbit)sysUpData(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..en..'"}')if atmosDensity>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not throttleMode and AtmoSpeedAssist and(AltitudeHold or Reentry or finalLand)then cmdThrottle(1)BrakeIsOn=false;WasInCruise=false end end;if atmosDensity==0 and WasInAtmo then if sysUpData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then sysAddData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if sysUpData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then sysAddData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if sysUpData(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then sysAddData(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if sysUpData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then sysAddData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if sysUpData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then sysAddData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else e9()end;if warpdrive~=nil then if jdecode(warpdrive.getData()).destination~="Unknown"and jdecode(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;HUD.TenthTick()elseif e4=="oneSecond"then local function eo(ep)local eq=0;damageMessage=""local er=eleTotalMaxHp;local es=0;local et=0;local eu=0;local ev=0;local ew=""local ex=core.getElementHitPointsById;for Q in pairs(elementsID)do local dT=0;local ey=0;ey=eleMaxHp(elementsID[Q])dT=ex(elementsID[Q])es=es+dT;if dT<ey then if dT==0 then eu=eu+1 else et=et+1 end;if repairArrows and#markers==0 then position=vec3(core.getElementPositionById(elementsID[Q]))local w=position.x;local x=position.y;local cA=position.z;table.insert(markers,core.spawnArrowSticker(w,x,cA+1,"down"))table.insert(markers,core.spawnArrowSticker(w,x,cA+1,"down"))core.rotateSticker(markers[2],0,0,90)table.insert(markers,core.spawnArrowSticker(w+1,x,cA,"north"))table.insert(markers,core.spawnArrowSticker(w+1,x,cA,"north"))core.rotateSticker(markers[4],90,90,0)table.insert(markers,core.spawnArrowSticker(w-1,x,cA,"south"))table.insert(markers,core.spawnArrowSticker(w-1,x,cA,"south"))core.rotateSticker(markers[6],90,-90,0)table.insert(markers,core.spawnArrowSticker(w,x-1,cA,"east"))table.insert(markers,core.spawnArrowSticker(w,x-1,cA,"east"))core.rotateSticker(markers[8],90,0,90)table.insert(markers,core.spawnArrowSticker(w,x+1,cA,"west"))table.insert(markers,core.spawnArrowSticker(w,x+1,cA,"west"))core.rotateSticker(markers[10],-90,0,90)table.insert(markers,elementsID[Q])end elseif repairArrows and#markers>0 and markers[11]==elementsID[Q]then for ez in pairs(markers)do core.deleteSticker(markers[ez])end;markers={}end end;eq=mfloor(es/er*100)if eq<100 then if eq>0 and eq<WipeDamage then SavedLocations={}ATLAS.UpdateAtlasLocationsList()ATLAS.UpdateAutopilotTarget()SaveDataBank()end;ep[#ep+1]=svgText(0,0,"","pbright txt")ev=mfloor(eq*2.55)ew=stringf("rgb(%d,%d,%d)",255-ev,ev,0)if eq<100 then ep[#ep+1]=svgText("50%",1035,"Elemental Integrity: "..eq.."%","txtbig txtmid","fill:"..ew)if eu>0 then ep[#ep+1]=svgText("50%",1055,"Disabled Modules: "..eu.." Damaged Modules: "..et,"txtbig txtmid","fill:"..ew)elseif et>0 then ep[#ep+1]=svgText("50%",1055,"Damaged Modules: "..et,"txtbig txtmid","fill:"..ew)end end end end;local function eA()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then sysDestWid(WeaponPanelID)WeaponPanelID=nil end end end;local function eB()local dV=systime()local eC=velMag;local eD=dV-lastTravelTime;if eC>1.38889 then eC=eC/1000;local eE=eC*(dV-lastTravelTime)TotalDistanceTravelled=TotalDistanceTravelled+eE;totalDistanceTrip=totalDistanceTrip+eE end;flightTime=flightTime+eD;TotalFlightTime=TotalFlightTime+eD;lastTravelTime=dV end;eB()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()eA()local ep={}HUD.OneSecond(ep)if ShouldCheckDamage then eo(ep)end;lastOdometerOutput=table.concat(ep,"")collectgarbage("collect")elseif e4=="fiveSecond"then if not UseSatNav then return end;myAutopilotTarget=dbHud_1.getStringValue("SPBAutopilotTargetName")if myAutopilotTarget~=nil and myAutopilotTarget~=""and myAutopilotTarget~="SatNavNotChanged"then local a7=jdecode(dbHud_1.getStringValue("SavedLocations"))if a7~=nil then _G["SavedLocations"]=a7;local cT=-1;local dB;for Q,R in pairs(SavedLocations)do if R.name and R.name=="SatNav Location"then cT=Q;break end end;if cT~=-1 then dB=SavedLocations[cT]cT=-1;for Q,R in pairs(b[0])do if R.name and R.name=="SatNav Location"then cT=Q;break end end;if cT>-1 then b[0][cT]=dB end;ATLAS.UpdateAtlasLocationsList()msgText=dB.name.." position updated"end end;for i=1,#AtlasOrdered do if AtlasOrdered[i].name==myAutopilotTarget then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..AtlasOrdered[i].name)ATLAS.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif e4=="msgTick"then local ep={}HUD.DisplayMessage(ep,"empty")msgText="empty"unit.stopTimer("msgTick")msgTimer=3 elseif e4=="animateTick"then Animated=true;Animating=false;simulatedX=0;simulatedY=0;unit.stopTimer("animateTick")elseif e4=="hudTick"then HUD.hudtick()elseif e4=="apTick"then AP.APTick()elseif e4=="radarTick"then RADAR.UpdateRadar()elseif e4=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;msgText="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function eF(eG,eH)local eI=vec3()local eJ=vec3()if eG==axisCommandId.longitudinal then eI=vec3(core.getConstructOrientationForward())eJ=constructForward elseif eG==axisCommandId.vertical then eI=vec3(core.getConstructOrientationUp())eJ=constructUp elseif eG==axisCommandId.lateral then eI=vec3(core.getConstructOrientationRight())eJ=constructRight else return vec3()end;local eK=vec3(core.getWorldGravity())local eL=eK:dot(eJ)local eM=vec3(core.getWorldAirFrictionAcceleration())local eN=eM:dot(eJ)local eO=coreVelocity:dot(eI)local eP=eH*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(eP-eO)local eQ=targetSpeedPID2:get()local eR=(eQ-eN-eL)*eJ;return eR end;local function eS(eG,eH)local eI=vec3()local eJ=vec3()if eG==axisCommandId.longitudinal then eI=vec3(core.getConstructOrientationForward())eJ=constructForward elseif eG==axisCommandId.vertical then eI=vec3(core.getConstructOrientationUp())eJ=constructUp elseif eG==axisCommandId.lateral then eI=vec3(core.getConstructOrientationRight())eJ=constructRight else return vec3()end;local eK=vec3(core.getWorldGravity())local eL=eK:dot(eJ)local eM=vec3(core.getWorldAirFrictionAcceleration())local eN=eM:dot(eJ)local eO=coreVelocity:dot(eI)local eP=eH*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(eP-eO)local eQ=targetSpeedPID:get()local eR=(eQ-eN-eL)*eJ;return eR end;local function eT(eU,eV,dn)local eW=eU:cross(dn):normalize_inplace()local eX=math.acos(uclamp(eW:dot(-eV),-1,1))*constants.rad2deg;if eW:cross(-eV):dot(dn)<0 then eX=-eX end;return eX end;if antigrav and not ExternalAGG then if not antigravOn and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;throttleMode=navCom:getAxisCommandType(0)==axisCommandType.byThrottle;if throttleMode and WasInCruise then cmdThrottle(0)WasInCruise=false elseif not throttleMode and not WasInCruise then PlayerThrottle=0;WasInCruise=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local eY=uclamp(pitchInput+pitchInput2+system.getControlDeviceForwardInput(),-1,1)local eZ=uclamp(rollInput+rollInput2+system.getControlDeviceYawInput(),-1,1)local e_=uclamp(yawInput+yawInput2-system.getControlDeviceLeftRightInput(),-1,1)local f0=brakeInput;worldVertical=vec3(core.getWorldVertical())if worldVertical==nil or worldVertical:len()==0 then worldVertical=(planet.center-worldPos):normalize()end;constructUp=vec3(core.getConstructWorldOrientationUp())constructForward=vec3(core.getConstructWorldOrientationForward())constructRight=vec3(core.getConstructWorldOrientationRight())constructVelocity=vec3(core.getWorldVelocity())coreVelocity=vec3(core.getVelocity())worldPos=vec3(core.getConstructWorldPos())coreMass=core.getConstructMass()velMag=vec3(constructVelocity):len()vSpd=-worldVertical:dot(constructVelocity)adjustedRoll=getRoll(worldVertical,constructForward,constructRight)local f1=adjustedRoll/180*math.pi;local f2=math.cos(f1)local f3=math.sin(f1)adjustedPitch=eT(worldVertical,constructForward,constructRight*f2+constructUp*f3)local f4=constructVelocity:normalize()local f5=mabs(adjustedRoll)local f6=utils.sign(adjustedRoll)local f7=vec3(core.getWorldAngularVelocity())local f8=eY*pitchSpeedFactor*constructRight+eZ*rollSpeedFactor*constructForward+e_*yawSpeedFactor*constructUp;if autoRoll==true and worldVertical:len()>0.01 then local f9=mabs(targetRoll-adjustedRoll)if((ProgradeIsOn or Reentry or BrakeLanding or spaceLand or AltitudeHold or IntoOrbit)and f9>0 or atmosDensity>0.0 and f9<autoRollRollThreshold and autoRollPreference)and eZ==0 and mabs(adjustedPitch)<85 then local fa=targetRoll;local fb=autoRollFactor;if atmosDensity==0 then fb=fb/4;targetRoll=0;fa=0 end;if rollPID==nil then rollPID=pid.new(fb*0.01,0,fb*0.1)end;rollPID:inject(fa-adjustedRoll)local fc=rollPID:get()f8=f8+fc*constructForward end end;local fd=1;local fe=0;local ff=1;local fg=system.getMouseWheel()if fg>0 then changeSpd()elseif fg<0 then changeSpd(true)else mousePause=true end;brakeInput2=0;if inAtmo and AtmoSpeedAssist and throttleMode then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(adjustedAtmoSpeedLimit/3.6-constructVelocity:dot(constructForward))local fh=throttlePID:get()calculatedThrottle=uclamp(fh,-1,1)if calculatedThrottle<PlayerThrottle and atmosDensity>0.005 then ThrottleLimited=true;navCom:setThrottleCommand(axisCommandId.longitudinal,uclamp(calculatedThrottle,0.01,1))else ThrottleLimited=false;navCom:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-adjustedAtmoSpeedLimit/3.6)local fi=uclamp(brakePID:get(),0,1)if atmosDensity>0 and vSpd<-80 or atmosDensity>0.005 then brakeInput2=fi end;if brakeInput2>0 then if ThrottleLimited and calculatedThrottle==0.01 then navCom:setThrottleCommand(axisCommandId.longitudinal,0)end else calculatedThrottle=uclamp(calculatedThrottle,0.01,1)end;local fj=''local fk=vec3()local fl=eF(axisCommandId.vertical,upAmount*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",fl,fe)local fm='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then fm=fm..ExtraLongitudeTags end;local fn=navCom:getAxisCommandType(axisCommandId.longitudinal)local fo=navCom:composeAxisAccelerationFromThrottle(fm,axisCommandId.longitudinal)local fp=eS(axisCommandId.lateral,LeftAmount*1000)fj=fj..' , '.."lateral airfoil , lateral ground "fk=fk+fp;if fk:len()>constants.epsilon then a:setEngineForceCommand(fj,fk,fe,'','','',ff)end;a:setEngineForceCommand(fm,fo,fd)local fq='thrust analog vertical fueled 'local fr='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then fr=fr..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then fq=fq..ExtraVerticalTags end;if upAmount~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(fq,fl,fd)else a:setEngineForceCommand(fq,vec3(),fd)end;if LeftAmount~=0 then a:setEngineForceCommand(fr,fp,fd)else a:setEngineForceCommand(fr,vec3(),fd)end;if f0==0 then f0=brakeInput2 end;local fs=-f0*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*f4)a:setEngineForceCommand('brake',fs)else if AtmoSpeedAssist then navCom:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;local eH=unit.getAxisCommandValue(0)if not throttleMode then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-eH/3.6)local fi=uclamp(brakePID:get(),0,1)f0=uclamp(f0+fi,0,1)end;local fs=-f0*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*f4)a:setEngineForceCommand('brake',fs)local fj=''local fk=vec3()local ft=false;local fm='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then fm=fm..ExtraLongitudeTags end;local fn=navCom:getAxisCommandType(axisCommandId.longitudinal)if fn==axisCommandType.byThrottle then local fo=navCom:composeAxisAccelerationFromThrottle(fm,axisCommandId.longitudinal)a:setEngineForceCommand(fm,fo,fd)elseif fn==axisCommandType.byTargetSpeed then local fo=navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)fj=fj..' , '..fm;fk=fk+fo;if navCom:getTargetSpeed(axisCommandId.longitudinal)==0 or navCom:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-navCom:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ft=true end end;local fr='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then fr=fr..ExtraLateralTags end;local fu=navCom:getAxisCommandType(axisCommandId.lateral)if fu==axisCommandType.byThrottle then local fv=navCom:composeAxisAccelerationFromThrottle(fr,axisCommandId.lateral)a:setEngineForceCommand(fr,fv,fd)elseif fu==axisCommandType.byTargetSpeed then local fp=navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)fj=fj..' , '..fr;fk=fk+fp end;local fq='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then fq=fq..ExtraVerticalTags end;local fw=navCom:getAxisCommandType(axisCommandId.vertical)if fw==axisCommandType.byThrottle then local fl=navCom:composeAxisAccelerationFromThrottle(fq,axisCommandId.vertical)if upAmount~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(fq,fl,fd,'airfoil','ground','',ff)else a:setEngineForceCommand(fq,vec3(),fd)a:setEngineForceCommand('airfoil vertical',fl,fd,'airfoil','','',ff)a:setEngineForceCommand('ground vertical',fl,fd,'ground','','',ff)end elseif fw==axisCommandType.byTargetSpeed then if upAmount<0 then a:setEngineForceCommand('hover',vec3(),fd)end;local fx=navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)fj=fj..' , '..fq;fk=fk+fx end;if fk:len()>constants.epsilon then if brakeInput~=0 or ft or mabs(f4:dot(constructForward))<0.5 then fj=fj..', brake'end;a:setEngineForceCommand(fj,fk,fe,'','','',ff)end end;local fy=torqueFactor*(f8-f7)local fz=vec3(core.getWorldAirFrictionAngularAcceleration())fy=fy-fz;a:setEngineTorqueCommand('torque',fy,fd,'airfoil','','',ff)a:setBoosterCommand('rocket_engine')if isBoosting and not VanillaRockets then local bF=coreVelocity:len()local fA=0.15;if not throttleMode then local fB=navCom:getTargetSpeed(axisCommandId.longitudinal)if bF*3.6>fB*(1-fA)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif bF*3.6<fB*(1-fA)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local eb=unit.getThrottle()if AtmoSpeedAssist then eb=PlayerThrottle*100 end;local eH=eb/100;if atmosphere==0 then eH=eH*MaxGameVelocity;if bF>=eH*(1-fA)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif bF<eH*(1-fA)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local fC=mfloor(adjustedAtmoSpeedLimit)eH=eH*fC/3.6;if bF>=eH*(1-fA)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif bF<eH*(1-fA)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local df=coroutine.status(beginSetup)if df=="suspended"then local B,dg=coroutine.resume(beginSetup)if dg then system.print("ERROR STARTUP: "..dg)end elseif df=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not Animating and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(fD)local function fE(g)local e=1;local function fF(fG,g)local fH={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local fI=fG;for _,R in ipairs(fH)do if g and fI>R then fG=R elseif fG<R and not g then fG=R;break end end;return fG end;if g then e=-1 end;if not ExternalAGG and antigravOn then if holdingShift and g then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+e*antiGravButtonModifier;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+e*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if holdingShift then OrbitTargetOrbit=fF(OrbitTargetOrbit,g)else OrbitTargetOrbit=OrbitTargetOrbit+e*holdAltitudeButtonModifier end;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else if holdingShift and inAtmo then HoldAltitude=fF(HoldAltitude,g)else HoldAltitude=HoldAltitude+e*holdAltitudeButtonModifier end end else navCom:updateTargetGroundAltitudeFromActionStart(e*1.0)end end;local function fJ(fK)if not inAtmo then msgText="Flight Assist in Atmo only"return end;local X=type(fK)if ReversalIsOn==nil then if X=="table"then if Autopilot or VectorToTarget then ToggleAutopilot()end;play("180On","BR")elseif fK==1 then play("bnkLft","BR")else play("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then ToggleAltitudeHold()if X~="table"then fK=fK+1 end end;ReversalIsOn=fK else play("180Off","BR")ReversalIsOn=nil end end;if fD=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cmdThrottle(0)if vBooster or hover then if inAtmo and abvGndDet==-1 then play("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;autoRoll=true;GearExtended=false else if hasGear then play("grOut","LG",1)a.control.extendLandingGears()end;navCom:setTargetGroundAltitude(LandingGearGroundHeight)if inAtmo then BrakeIsOn=true end end end;if hasGear and not BrakeLanding and not(vBooster or hover)then play("grOut","LG",1)a.control.extendLandingGears()end else if hasGear then play("grIn","LG",1)a.control.retractLandingGears()end;navCom:setTargetGroundAltitude(TargetHoverHeight)end elseif fD=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif fD=="forward"then pitchInput=pitchInput-1 elseif fD=="backward"then if AltIsOn then fJ(-constructVelocity*5000)else pitchInput=pitchInput+1 end elseif fD=="left"then if AltIsOn then fJ(1)else rollInput=rollInput-1 end elseif fD=="right"then if AltIsOn then fJ(3)else rollInput=rollInput+1 end elseif fD=="yawright"then yawInput=yawInput-1 elseif fD=="yawleft"then yawInput=yawInput+1 elseif fD=="straferight"then navCom:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif fD=="strafeleft"then navCom:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif fD=="up"then upAmount=upAmount+1;navCom:deactivateGroundEngineAltitudeStabilization()navCom:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif fD=="down"then upAmount=upAmount-1;navCom:deactivateGroundEngineAltitudeStabilization()navCom:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif fD=="groundaltitudeup"then fE()elseif fD=="groundaltitudedown"then fE(true)elseif fD=="option1"then toggleView=false;if AltIsOn and holdingShift then local fL=""for i=1,#passengers do fL=fL.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..round(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..fL)return end;ATLAS.adjustAutopilotTargetIndex()elseif fD=="option2"then toggleView=false;if AltIsOn and holdingShift then for i=1,#passengers do core.forceDeboard(passengers[i])end;msgText="Deboarded All Passengers"return end;ATLAS.adjustAutopilotTargetIndex(1)elseif fD=="option3"then local function fM()UnitHidden=not UnitHidden;if not UnitHidden then play("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else play("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then sysDestWid(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then sysDestWid(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then sysDestWid(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then sysDestWid(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then sysDestWid(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and holdingShift then local fL=""for i=1,#ships do fL=fL.."| ID: "..ships[i].." Mass: "..round(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..fL)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;fM()toggleView=false elseif fD=="option4"then toggleView=false;if AltIsOn and holdingShift then for i=1,#ships do core.forceUndock(ships[i])end;msgText="Undocked all ships"return end;ReversalIsOn=nil;ToggleAutopilot()elseif fD=="option5"then toggleView=false;function ToggleLockPitch()if LockPitch==nil then play("lkPOn","LP")if not holdingShift then LockPitch=adjustedPitch else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else play("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif fD=="option6"then toggleView=false;if AltIsOn and holdingShift then if shield_1 then local fN=shield_1.getVentingCooldown()if fN>0 then msgText="Cannot vent again for "..fN.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()msgText="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else msgText="Shields already at max hitpoints"end;return else msgText="No shield found"return end end;ToggleAltitudeHold()elseif fD=="option7"then toggleView=false;if AltIsOn and holdingShift then if shield_1 then shield_1.toggle()return else msgText="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then msgText="Collision System Enabled"else msgText="Collision System Secured"end elseif fD=="option8"then stablized=not stablized;if not stablized then msgText="DeCoupled Mode - Ground Stabilization off"navCom:deactivateGroundEngineAltitudeStabilization()play("gsOff","GS")else msgText="Coupled Mode - Ground Stabilization on"navCom:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)play("gsOn","GS")end;toggleView=false elseif fD=="option9"then if AltIsOn and holdingShift then navCom:resetCommand(axisCommandId.longitudinal)navCom:resetCommand(axisCommandId.lateral)navCom:resetCommand(axisCommandId.vertical)cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()gyroIsOn=gyro.getState()==1;if gyroIsOn then play("gyOn","GA")else play("gyOff","GA")end end;toggleView=false elseif fD=="lshift"then apButtonsHovered=false;if AltIsOn then holdingShift=true end;if sysIsVwLock()==1 then holdingShift=true;PrevViewLock=sysIsVwLock()sysLockVw(1)elseif isRemote()==1 and ShiftShowsRemoteButtons then holdingShift=true;Animated=false;Animating=false end elseif fD=="brake"then if BrakeToggleStatus or AltIsOn then BrakeToggle()elseif not BrakeIsOn then BrakeToggle()else BrakeIsOn=true end elseif fD=="lalt"then toggleView=true;AltIsOn=true;if isRemote()==0 and not freeLookToggle and userControlScheme=="keyboard"then sysLockVw(1)end elseif fD=="booster"then if VanillaRockets then a:toggleBoosters()elseif not isBoosting then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;isBoosting=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;isBoosting=false end elseif fD=="stopengines"then local function fO()if time-clearAllCheck<1.5 then play("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;ReversalIsOn=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;followMode=false;apThrottleSet=false;spaceLand=false;spaceLaunch=false;reentryMode=false;autoRoll=autoRollPreference;VectorToTarget=false;TurnBurn=false;gyroIsOn=false;LockPitch=nil;IntoOrbit=false end end;fO()clearAllCheck=time;if navCom:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if PlayerThrottle~=0 then navCom:resetCommand(axisCommandId.longitudinal)cmdThrottle(0)else cmdThrottle(100)end else if navCom:getTargetSpeed(axisCommandId.longitudinal)~=0 then navCom:resetCommand(axisCommandId.longitudinal)else if inAtmo then cmdCruise(AtmoSpeedLimit)else cmdCruise(MaxGameVelocity*3.6)end end end elseif fD=="speedup"then changeSpd()elseif fD=="speeddown"then changeSpd(true)elseif fD=="antigravity"and not ExternalAGG then if antigrav~=nil then ToggleAntigrav()end end end;function script.onActionStop(fD)local function fP()if not ExternalAGG and antigravOn then currentAggModifier=antiGravButtonModifier end;if AltitudeHold or VertTakeOff or IntoOrbit then currentHoldAltModifier=holdAltitudeButtonModifier end end;if fD=="forward"then pitchInput=0 elseif fD=="backward"then pitchInput=0 elseif fD=="left"then if ReversalIsOn then if ReversalIsOn==2 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;rollInput=0 elseif fD=="right"then if ReversalIsOn then if ReversalIsOn==4 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;rollInput=0 elseif fD=="yawright"then yawInput=0 elseif fD=="yawleft"then yawInput=0 elseif fD=="straferight"then navCom:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif fD=="strafeleft"then navCom:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif fD=="up"then upAmount=0;navCom:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then navCom:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif fD=="down"then upAmount=0;navCom:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then navCom:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif fD=="groundaltitudeup"then fP()toggleView=false elseif fD=="groundaltitudedown"then fP()toggleView=false elseif fD=="lshift"then if sysIsVwLock()==1 then simulatedX=0;simulatedY=0;sysLockVw(PrevViewLock)elseif isRemote()==1 and ShiftShowsRemoteButtons then Animated=false;Animating=false end;holdingShift=false elseif fD=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then BrakeToggle()else BrakeIsOn=false end end elseif fD=="lalt"then if isRemote()==0 and freeLookToggle then if toggleView then if sysIsVwLock()==1 then sysLockVw(0)else sysLockVw(1)end else toggleView=true end elseif isRemote()==0 and not freeLookToggle and userControlScheme=="keyboard"then sysLockVw(0)end;AltIsOn=false end end;function script.onActionLoop(fD)local function fQ(g)local e=1;if g then e=-1 end;if not ExternalAGG and antigravOn then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+e*currentAggModifier;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;currentAggModifier=uclamp(currentAggModifier*1.05,antiGravButtonModifier,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+e*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then OrbitTargetOrbit=OrbitTargetOrbit+e*currentHoldAltModifier;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+e*currentHoldAltModifier end;currentHoldAltModifier=uclamp(currentHoldAltModifier*1.05,holdAltitudeButtonModifier,50)else navCom:updateTargetGroundAltitudeFromActionLoop(e*1.0)end end;local function fR(g)local e=1;if g then e=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn then PlayerThrottle=uclamp(PlayerThrottle+e*speedChangeSmall/100,-1,1)else navCom:updateCommandFromActionLoop(axisCommandId.longitudinal,e*speedChangeSmall)end end end;if fD=="groundaltitudeup"then if not holdingShift then fQ()end elseif fD=="groundaltitudedown"then if not holdingShift then fQ(true)end elseif fD=="speedup"then fR()elseif fD=="speeddown"then fR(true)end end;function script.onInputText(y)local function fS(fT,bK,dy)local function fU(bK)local c=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local a5='::pos{'..c..','..c..','..c..','..c..','..c..'}'local ai,aj,aq,ar,as=stringmatch(bK,a5)if ai=="0"and aj=="0"then return vec3(tonum(aq),tonum(ar),tonum(as))end;ar=math.rad(ar)aq=math.rad(aq)local planet=b[tonum(ai)][tonum(aj)]local ba=math.cos(aq)local fV=vec3(ba*math.cos(ar),ba*math.sin(ar),math.sin(aq))return planet.center+(planet.radius+as)*fV end;local position=fU(bK)return ATLAS.AddNewLocation(fT,position,dy)end;local i;local fW,fX=nil,nil;local fY="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(y," ")fW=y;if i~=nil then fW=string.sub(y,0,i-1)fX=string.sub(y,i+1)end;if fW=="/help"or fW=="/commands"then for fZ in string.gmatch(fY,"([^\n]+)")do system.print(fZ)end;return elseif fW=="/setname"then if fX==nil or fX==""then msgText="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.UpdatePosition(fX)else msgText="Select a saved target to rename first"end elseif shield_1 and fW=="/resist"then if fX==nil or shield_1.getResistancesCooldown()>0 then msgText="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local c=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local a5=c..', '..c..', '..c..', '..c;local f_,g0,g1,g2=stringmatch(fX,a5)if g2==nil or f_+g0+g1+g2>0.6 then msgText="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(f_,g0,g1,g2)==1 then msgText="Shield Resistances set"else msgText="Resistance setting failed."end elseif fW=="/addlocation"or string.find(y,"::pos")~=nil then local dy=false;local fT="0-Temp"if fX==nil or fX==""then fX=fW;dy=true end;i=string.find(fX,"::")if not dy then fT=string.sub(fX,1,i-2)end;local bK=string.sub(fX,i)fS(fT,bK,dy)elseif fW=="/agg"then if fX==nil or fX==""then msgText="Usage: /agg targetheight"return end;fX=tonum(fX)if fX<1000 then fX=1000 end;AntigravTargetAltitude=fX;msgText="AGG Target Height set to "..fX elseif fW=="/G"then if fX==nil or fX==""then msgText="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if fX=="dump"then for Q,R in pairs(saveableVariables())do if type(_G[R])=="boolean"then if _G[R]==true then system.print(R.." true")else system.print(R.." false")end elseif _G[R]==nil then system.print(R.." nil")else system.print(R.." ".._G[R])end end;return end;i=string.find(fX," ")local g3=string.sub(fX,0,i-1)local g4=string.sub(fX,i+1)for Q,R in pairs(saveableVariables())do if R==g3 then msgText="Variable "..g3 .." changed to "..g4;local g5=type(_G[R])if g5=="number"then g4=tonum(g4)if R=="AtmoSpeedLimit"then adjustedAtmoSpeedLimit=g4 end elseif g5=="boolean"then if string.lower(g4)=="true"then g4=true else g4=false end end;_G[R]=g4;return end end;msgText="No such global variable: "..g3 elseif fW=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.ClearCurrentPosition()else msgText="Select a custom wp to delete first in IPH"end elseif fW=="/copydatabank"then if dbHud_2 then SaveDataBank(true)else msgText="Spare Databank required to copy databank"end elseif fW=="/iphWP"then if AutopilotTargetIndex>0 then system.print(AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords,true))msgText="::pos waypoint shown in lua chat"else msgText="No target selected in IPH"end end end;function script.onEnter(aj)if radars[1]and not inAtmo and not notPvPZone then unit.setTimer("contact",0.1)end end;function script.onLeave(aj)if radars[1]and CollisionSystem then if#contacts>650 then aj=tostring(aj)contacts[aj]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
