name: ArchHud - Archaegeo v0.729 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.729;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},DeadZone={set=function(K)au=K end,get=function()return au end},OrbitMapSize={set=function(K)av=K end,get=function()return av end},OrbitMapX={set=function(K)aw=K end,get=function()return aw end},OrbitMapY={set=function(K)ax=K end,get=function()return ax end},soundVolume={set=function(K)ay=K end,get=function()return ay end}}aA=5.0;aB=1.0;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0666667;aQ=0.0;aR="none"aS="none"aT="none"aU={speedChangeLarge={set=function(K)aA=K end,get=function()return aA end},speedChangeSmall={set=function(K)aB=K end,get=function()return aB end},MouseXSensitivity={set=function(K)aC=K end,get=function()return aC end},MouseYSensitivity={set=function(K)aD=K end,get=function()return aD end},autoRollFactor={set=function(K)aE=K end,get=function()return aE end},rollSpeedFactor={set=function(K)aF=K end,get=function()return aF end},autoRollRollThreshold={set=function(K)aG=K end,get=function()return aG end},minRollVelocity={set=function(K)aH=K end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(K)aI=K end,get=function()return aI end},torqueFactor={set=function(K)aJ=K end,get=function()return aJ end},pitchSpeedFactor={set=function(K)aK=K end,get=function()return aK end},yawSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeSpeedFactor={set=function(K)aM=K end,get=function()return aM end},brakeFlatFactor={set=function(K)aN=K end,get=function()return aN end},DampingMultiplier={set=function(K)aO=K end,get=function()return aO end},hudTickRate={set=function(K)aP=K end,get=function()return aP end},ExtraEscapeThrust={set=function(K)aQ=K end,get=function()return aQ end},ExtraLongitudeTags={set=function(K)aR=K end,get=function()return aR end},ExtraLateralTags={set=function(K)aS=K end,get=function()return aS end},ExtraVerticalTags={set=function(K)aT=K end,get=function()return aT end}}aV=j;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=1000;b7=false;b8=false;b9=false;ba=false;bb=0;bc="Aligning"bd=0;be=1;bf="None"bg=nil;bh=0;bi=nil;bj=0.0;bk=0;bl={}bm=false;bn=0;bo=0;bp=nil;bq=0;br=1000;bs=0;bt=false;bu=0;bv=false;bw="All"bx=true;by="Off"bz=0.000;bA={}bB={}bC={VertTakeOff={set=function(K)b5=K end,get=function()return b5 end},VertTakeOffEngine={set=function(K)aW=K end,get=function()return aW end},SpaceTarget={set=function(K)bt=K end,get=function()return bt end},BrakeToggleStatus={set=function(K)aV=K end,get=function()return aV end},BrakeIsOn={set=function(K)aX=K end,get=function()return aX end},RetrogradeIsOn={set=function(K)aY=K end,get=function()return aY end},ProgradeIsOn={set=function(K)aZ=K end,get=function()return aZ end},Autopilot={set=function(K)a_=K end,get=function()return a_ end},TurnBurn={set=function(K)b0=K end,get=function()return b0 end},AltitudeHold={set=function(K)b1=K end,get=function()return b1 end},BrakeLanding={set=function(K)b2=K end,get=function()return b2 end},Reentry={set=function(K)b4=K end,get=function()return b4 end},AutoTakeoff={set=function(K)b3=K end,get=function()return b3 end},HoldAltitude={set=function(K)b6=K end,get=function()return b6 end},AutopilotAccelerating={set=function(K)b7=K end,get=function()return b7 end},AutopilotBraking={set=function(K)b9=K end,get=function()return b9 end},AutopilotCruising={set=function(K)ba=K end,get=function()return ba end},AutopilotRealigned={set=function(K)b8=K end,get=function()return b8 end},AutopilotEndSpeed={set=function(K)bb=K end,get=function()return bb end},AutopilotStatus={set=function(K)bc=K end,get=function()return bc end},AutopilotPlanetGravity={set=function(K)bd=K end,get=function()return bd end},PrevViewLock={set=function(K)be=K end,get=function()return be end},AutopilotTargetName={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetCoords={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetIndex={set=function(K)bh=K end,get=function()return bh end},TotalDistanceTravelled={set=function(K)bj=K end,get=function()return bj end},TotalFlightTime={set=function(K)bk=K end,get=function()return bk end},SavedLocations={set=function(K)bl=K end,get=function()return bl end},VectorToTarget={set=function(K)bm=K end,get=function()return bm end},LocationIndex={set=function(K)bn=K end,get=function()return bn end},LastMaxBrake={set=function(K)bo=K end,get=function()return bo end},LockPitch={set=function(K)bp=K end,get=function()return bp end},LastMaxBrakeInAtmo={set=function(K)bq=K end,get=function()return bq end},AntigravTargetAltitude={set=function(K)br=K end,get=function()return br end},LastStartTime={set=function(K)bs=K end,get=function()return bs end},iphCondition={set=function(K)bw=K end,get=function()return bw end},stablized={set=function(K)bx=K end,get=function()return bx end},UseExtra={set=function(K)by=K end,get=function()return by end},SelectedTab={set=function(K)bD=K end,get=function()return bD end},saveRoute={set=function(K)bA=K end,get=function()return bA end},apRoute={set=function(K)bB=K end,get=function()return bB end}}local function bE(a,b,c,bF,bG,bH)bI=bF()bJ=0;bK=0;bL=false;bM=0;bN=false;bO=false;bP=0;bQ=0;bR=0;bS=0;bT=false;bU=false;bV="empty"bW=3;bX=false;bY=0;bZ=0;b_=nil;c0=0;c1=0;c2=0;c3=false;c4=false;c5=false;c6=-1;c7=bH()>0;c8=bH()c9=b.getAltitude()ca=b.getConstructMass()cb=nil;cc=a9;cd=aa;ce={}cf={}cg={}ch=nil;ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=false;cr=false;cs=p;ct=false;cu=U;cv=nil;cw=0;cx=false;cy=false;cz=false;cA=vec3(b.getConstructWorldOrientationForward())cB=vec3(b.getConstructWorldOrientationRight())cC=vec3(b.getVelocity())cD=vec3(b.getWorldVelocity())cE=vec3(cD):len()cF=vec3(b.getWorldVertical())cG=-cF:dot(cD)cH=vec3(b.getConstructWorldPos())cI=false;cJ=false;cK=true;cL=0;cM=0;cN={}cO=false;cP=50000;cQ=nil;cR=c.getClosestPlanetInfluence()>0 or c9>0 and c9<200000;cS=false;cT=nil;cU=false;cV=0;cW=nil;cX=nil;cY={}cZ=90;c_=w;d0=nil;d1=nil;d2={}d3={}d4=false;d5=nil;d6=0;d7=false;if d8 then d9=bG(0.5+d8.getShieldHitpoints()*100/d8.getMaxShieldHitpoints())end end;local function da(d,b,c,a,db,dc,dd,de,df)local function dg(dh)return type(dh)=='number'end;local function di(dh)return type(dd(dh))=='number'end;local function dj(dk)return type(dk)=='table'end;local function dl(a)return type(a)=='string'end;local function dm(dn)return dj(dn)and dg(dn.x and dn.y and dn.z)end;local function dp(dq)return dj(dq)and dg(dq.latitude and dq.longitude and dq.altitude and dq.id and dq.systemId)end;local dr=math.pi/180;local ds=180/math.pi;local dt=1e-10;local du=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dv='::pos{'..du..','..du..','..du..','..du..','..du..'}'local utils=utils;local vec3=vec3;local function dw(dh)local dx=string.gsub(string.reverse(db('%.4f',dh)),'^0*%.?','')return dx==''and'0'or string.reverse(dx)end;local function dy(dz)if dm(dz)then return db('{x=%.3f,y=%.3f,z=%.3f}',dz.x,dz.y,dz.z)end;if dj(dz)and not getmetatable(dz)then local dA={}local dB=next(dz)if type(dB)=='nil'or dB==1 then dA=dz else for dC,dn in pairs(dz)do local dD=dy(dn)if type(dC)=='number'then table.insert(dA,db('[%s]=%s',dC,dD))else table.insert(dA,db('%s=%s',dC,dD))end end end;return db('{%s}',table.concat(dA,','))end;if dl(dz)then return db("'%s'",dz:gsub("'",[[\']]))end;return tostring(dz)end;local dE={}dE.__index=dE;dE.__tostring=function(dz,dF)local dG={}for dC in pairs(dz)do table.insert(dG,dC)end;table.sort(dG)local dA={}for dH,dC in ipairs(dG)do local dD=dy(dz[dC])if type(dC)=='number'then table.insert(dA,db('[%s]=%s',dC,dD))else table.insert(dA,db('%s=%s',dC,dD))end end;if dF then return db('%s%s',dF,table.concat(dA,',\n'..dF))end;return db('{%s}',table.concat(dA,','))end;dE.__eq=function(dI,dJ)return dI.systemId==dJ.systemId and dI.id==dJ.id and df(dI.radius,dJ.radius)and df(dI.center.x,dJ.center.x)and df(dI.center.y,dJ.center.y)and df(dI.center.z,dJ.center.z)and df(dI.GM,dJ.GM)end;local function dK(dL,dM,dN,dO,dP)assert(di(dL),'Argument 1 (systemId) must be a number:'..type(dL))assert(di(dM),'Argument 2 (id) must be a number:'..type(dM))assert(di(dN),'Argument 3 (radius) must be a number:'..type(dN))assert(dj(dO),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dO))assert(di(dP),'Argument 5 (GM) must be a number:'..type(dP))return setmetatable({systemId=dd(dL),id=dd(dM),radius=dd(dN),center=vec3(dO),GM=dd(dP)},dE)end;local dQ={}dQ.__index=dQ;dQ.__tostring=function(dR)return db('::pos{%d,%d,%s,%s,%s}',dR.systemId,dR.id,dw(dR.latitude*ds),dw(dR.longitude*ds),dw(dR.altitude))end;dQ.__eq=function(dI,dJ)return dI.id==dJ.id and dI.systemId==dJ.systemId and df(dI.latitude,dJ.latitude)and df(dI.altitude,dJ.altitude)and(df(dI.longitude,dJ.longitude)or df(dI.latitude,math.pi/2)or df(dI.latitude,-math.pi/2))end;local function dS(dT,dM,dU,dV,dW)local dL=dT;if dl(dT)and not dV and not dW and not dM and not dU then dL,dM,dU,dV,dW=dX(dT,dv)assert(dL,'Argument 1 (position string) is malformed.')else assert(di(dL),'Argument 1 (systemId) must be a number:'..type(dL))assert(di(dM),'Argument 2 (id) must be a number:'..type(dM))assert(di(dU),'Argument 3 (latitude) must be in degrees:'..type(dU))assert(di(dV),'Argument 4 (longitude) must be in degrees:'..type(dV))assert(di(dW),'Argument 5 (altitude) must be in meters:'..type(dW))end;dL=dd(dL)dM=dd(dM)dU=dd(dU)dV=dd(dV)dW=dd(dW)if dM==0 then return setmetatable({latitude=dU,longitude=dV,altitude=dW,id=dM,systemId=dL},dQ)end;return setmetatable({latitude=dr*dc(dU,-90,90),longitude=dr*(dV%360),altitude=dW,id=dM,systemId=dL},dQ)end;local dY={}dY.__index=dY;dY.__tostring=function(dz,dF)local dZ=dF and dF..'  'local d_={}local dG={}for dC in pairs(dz)do table.insert(dG,dC)end;table.sort(dG)for dH,e0 in ipairs(dG)do e1=dz[e0]local e2=dE.__tostring(e1,dZ)if dF then table.insert(d_,db('[%s]={\n%s\n%s}',e0,e2,dF))else table.insert(d_,db('  [%s]=%s',e0,e2))end end;if dF then return db('\n%s%s%s',dF,table.concat(d_,',\n'..dF),dF)end;return db('{\n%s\n}',table.concat(d_,',\n'))end;local function e3(e4)local e={}local pid;for dH,dn in pairs(e4)do local dM=dn.planetarySystemId;if type(dM)~='number'then error('Invalid planetary s ID: '..tostring(dM))elseif pid and dM~=pid then error('Mistringmatch planetary s IDs: '..dM..' and '..pid)end;local e5=dn.bodyId;if type(e5)~='number'then error('Invalid body ID: '..tostring(e5))elseif e[e5]then error('Duplicate body ID: '..tostring(e5))end;setmetatable(dn.center,getmetatable(vec3.unit_x))e[e5]=setmetatable(dn,dE)pid=dM end;return setmetatable(e,dY)end;e6={}local function e7(e4)return setmetatable({galaxyAtlas=e4 or{}},e6)end;e6.__index=function(dk,K)if type(K)=='number'then local a=dk.galaxyAtlas[K]return e3(a)end;return rawget(e6,K)end;e6.__pairs=function(dz)return function(dk,dC)local e8,e9=next(dk,dC)return e8,e9 and e3(e9)end,dz.galaxyAtlas,nil end;e6.__tostring=function(dz)local ea={}for dH,eb in pairs(dz or{})do local ec=eb:getPlanetarySystemId()local ed=dY.__tostring(eb,'    ')table.insert(ea,db('  [%s]={%s\n  }',ec,ed))end;return db('{\n%s\n}\n',table.concat(ea,',\n'))end;e6.BodyParameters=dK;e6.MapPosition=dS;e6.PlanetarySystem=e3;function e6.createBodyParameters(dL,dM,ee,ef,eg,eh,ei)assert(di(dL),'Argument 1 (systemId) must be a number:'..type(dL))assert(di(dM),'Argument 2 (id) must be a number:'..type(dM))assert(di(ee),'Argument 3 (surfaceArea) must be a number:'..type(ee))assert(dj(ef),'Argument 4 (aPosition) must be an array or vec3:'..type(ef))assert(dj(eg),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eg))assert(di(eh),'Argument 6 (altitude) must be in meters:'..type(eh))assert(di(ei),'Argument 7 (gravityAtPosition) must be number:'..type(ei))local dN=de(ee/4/math.pi)local c2=dN+eh;local ej=vec3(ef)+c2*vec3(eg)local dP=ei*c2*c2;return dK(dL,dM,dN,ej,dP)end;e6.isMapPosition=dp;function e6:getPlanetarySystem(dT)if K==nil then K=0 end;if e9==nil then e9=0 end;local dL=dT;if dp(dT)then dL=dT.systemId end;if type(dL)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(e9)~=dY then a=e3(a)end;return a end end end;function dY:sizeCalculator(ek)return 1.05*ek.radius end;function dY:castIntersections(el,em,en,eo,ep,eq)local er={}if ep then for dH,ek in pairs(ep)do table.insert(er,ek)end else er=cY end;if not eq then table.sort(er,function(es,et)local eu=es.center;local ev=et.center;return(eu.x-el.x)^2+(eu.y-el.y)^2+(eu.z-el.z)^2<(ev.x-el.x)^2+(ev.y-el.y)^2+(ev.z-el.z)^2 end)end;local ew=em:normalize()for dH,ek in ipairs(er)do local ex=ek.center-el;local dN=self:sizeCalculator(ek)local ey=ex:dot(ew)local ez=ey^2-(ex:len2()-dN^2)if ez>=0 then local eA=de(ez)local eB=ey+eA;local eC=ey-eA;if eC>0 then return ek,eB,eC elseif eB>0 then return ek,eB,nil end end end;return nil,nil,nil end;function dY:closestBody(eD)assert(type(eD)=='table','Invalid coordinates.')local eE,ek;local eF=vec3(eD)for dH,eG in pairs(self)do local eH=(eG.center-eF):len2()if(not ek or eH<eE)and eG.name~="Space"then ek=eG;eE=eH end end;return ek end;function dY:convertToBodyIdAndWorldCoordinates(dT)local eI=dT;if dl(dT)then eI=dS(dT)end;if eI.id==0 then return 0,vec3(eI.latitude,eI.longitude,eI.altitude)end;local eG=self:getBodyParameters(eI)if eG then return eI.id,eG:convertToWorldCoordinates(eI)end end;function dY:getBodyParameters(dT)local dM=dT;if dp(dT)then dM=dT.id end;assert(di(dM),'Argument 1 (id) must be a number:'..type(dM))return self[dM]end;function dY:getPlanetarySystemId()local dH,dn=next(self)return dn and dn.systemId end;function dE:convertToMapPosition(dO)assert(dj(dO),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dO))local eJ=vec3(dO)if self.id==0 then return setmetatable({latitude=eJ.x,longitude=eJ.y,altitude=eJ.z,id=0,systemId=self.systemId},dQ)end;local eK=eJ-self.center;local c2=eK:len()local dW=c2-self.radius;local dU=0;local dV=0;if not df(c2,0)then local eL=eM(eK.y,eK.x)dV=eL>=0 and eL or 2*math.pi+eL;dU=math.pi/2-math.acos(eK.z/c2)end;return setmetatable({latitude=dU,longitude=dV,altitude=dW,id=self.id,systemId=self.systemId},dQ)end;function dE:convertToWorldCoordinates(dT)local eI=dl(dT)and dS(dT)or dT;if eI.id==0 then return vec3(eI.latitude,eI.longitude,eI.altitude)end;assert(dp(eI),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eI.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eI.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eN=math.cos(eI.latitude)return self.center+(self.radius+eI.altitude)*vec3(eN*math.cos(eI.longitude),eN*math.sin(eI.longitude),math.sin(eI.latitude))end;function dE:getAltitude(dO)return(vec3(dO)-self.center):len()-self.radius end;function dE:getDistance(dO)return(vec3(dO)-self.center):len()end;function dE:getGravity(dO)local eO=self.center-vec3(dO)local eP=eO:len2()return self.GM/eP*eO/de(eP)end;return setmetatable(e6,{__call=function(dH,...)return e7(...)end})end;local function eQ(d,b,c,a,de,eR)local ci={}local eS=30000000/3600;local eT=eS*eS;local eU=100;function ci.computeAccelerationTime(eV,eW,eX)local eY=eS*math.asin(eV/eS)return(eS*math.asin(eX/eS)-eY)/eW end;function ci.computeDistanceAndTime(eV,eX,eZ,e_,f0,f1)f0=f0 or 0;f1=f1 or 0;local f2=eV<=eX;local f3=e_*(f2 and 1 or-1)/eZ;local f4=-f1/eZ;local f5=f3+f4;if f2 and f5<=0 or not f2 and f5>=0 then return-1,-1 end;local f6,f7=0,0;if f3~=0 and f0>0 then local eY=math.asin(eV/eS)local f8=math.pi*(f3/2+f4)local f9=f3*f0;local fa=eS*math.pi;local dn=function(dk)local fb=(f8*dk-f9*math.sin(math.pi*dk/2/f0)+fa*eY)/fa;local fc=math.tan(fb)return eS*fc/de(fc*fc+1)end;local fd=f2 and function(a)return a>=eX end or function(a)return a<=eX end;f7=2*f0;if fd(dn(f7))then local fe=0;while eR(f7-fe)>0.5 do local dk=(f7+fe)/2;if fd(dn(dk))then f7=dk else fe=dk end end end;local ff=eV;local fg=f7/eU;for fh=1,eU do local fi=dn(fh*fg)f6=f6+(fi+ff)*fg/2;ff=fi end;if f7<2*f0 then return f6,f7 end;eV=ff end;local eY=eS*math.asin(eV/eS)local bI=(eS*math.asin(eX/eS)-eY)/f5;local fj=eT*math.cos(eY/eS)/f5;local c2=fj-eT*math.cos((f5*bI+eY)/eS)/f5;return c2+f6,bI+f7 end;function ci.computeTravelTime(eV,eW,c2)if c2==0 then return 0 end;if eW>0 then local eY=eS*math.asin(eV/eS)local fj=eT*math.cos(eY/eS)/eW;return(eS*math.acos(eW*(fj-c2)/eT)-eY)/eW end;if eV==0 then return-1 end;assert(eV>0,'Acceleration and initial speed are both zero.')return c2/eV end;return ci end;local function fk(d,b,c,a,db,dc,dd,de,df)local vec3=vec3;local da=da(d,b,c,a,db,dc,dd,de,df)local function dl(a)return type(a)=='string'end;local function dj(dk)return type(dk)=='table'end;fl={}fl.__index=fl;function fl:escapeAndOrbitalSpeed(dW)assert(self.body)local c2=dW+self.body.radius;if not df(c2,0)then local fm=de(self.body.GM/c2)return de(2)*fm,fm end;return nil,nil end;function fl:orbitalParameters(dT,fn)assert(self.body)assert(dj(dT)or dl(dT))assert(dj(fn))local fo=(dl(dT)or da.isMapPosition(dT))and self.body:convertToWorldCoordinates(dT)or vec3(dT)local dn=vec3(fn)local fp=fo-self.body.center;local fq=dn:len2()local fr=fp:len()local fs=self.body.GM;local ft=((fq-fs/fr)*fp-fp:dot(dn)*dn)/fs;local eu=fs/(2*fs/fr-fq)local fu=ft:len()local ew=ft:normalize()local fv=eu*(1-fu)local fw=eu*(1+fu)local fx=fv*ew+self.body.center;local fy=fu<=1 and-fw*ew+self.body.center or nil;local fz=de(eu*fs*(1-fu*fu))local fA=fy and 2*math.pi*de(eu^3/fs)local fB=math.acos(ft:dot(fp)/(fu*fr))if fp:dot(dn)<0 then fB=-(fB-2*math.pi)end;local fC=math.acos((math.cos(fB)+fu)/(1+fu*math.cos(fB)))local fD=fC;if fD<0 then fD=fD+2*math.pi end;local fE=fD-fu*math.sin(fD)local fF=0;local fG=0;local fH=0;if fA~=nil then fF=fE/(2*math.pi/fA)fG=fA-fF;fH=fG+fA/2;if fB-math.pi>0 then fG=fF;fH=fG+fA/2 end;if fH>fA then fH=fH-fA end end;return{periapsis={position=fx,speed=fz/fv,circularOrbitSpeed=de(fs/fv),altitude=fv-self.body.radius},apoapsis=fy and{position=fy,speed=fz/fw,circularOrbitSpeed=de(fs/fw),altitude=fw-self.body.radius},currentVelocity=dn,currentPosition=fo,eccentricity=fu,period=fA,eccentricAnomaly=fC,meanAnomaly=fE,timeToPeriapsis=fG,timeToApoapsis=fH,trueAnomaly=fB}end;local function fI(fJ)local eG=da.BodyParameters(fJ.systemId,fJ.id,fJ.radius,fJ.center,fJ.GM)return setmetatable({body=eG},fl)end;return setmetatable(fl,{__call=function(dH,...)return fI(...)end})end;local function fK(d,b,c,a,dbHud_1,e,fL,fM,bG,dd,de,fN,fO)local function fP(fQ)local dR=fR:closestBody(fQ)if(fQ-dR.center):len()>dR.radius+dR.noAtmosphericDensityAltitude then dR=e[0][0]end;return dR end;local function fS()local function fT(fU,fV)return fU.name<fV.name end;cN={}for dC,dn in pairs(e[0])do cN[#cN+1]={name=dn.name,index=dC}end;table.sort(cN,fT)end;local function fW(fX,fY)if not fY then fY=fZ.name end;for dC,dn in pairs(fX)do if dn.name and dn.name==fY then return dC end end;return-1 end;local function f_()cV=bh;if bh==0 then bf="None"b_=nil;fZ=nil;return true end;local g0=cN[bh].index;local g1=e[0][g0]if g1.center then bf=g1.name;b_=ch[0][g0]if fZ~=nil then if c8==0 then if fL(g2,g3)~=1 then fM(g2,g3)end;if fL(g4,g5)~=1 then fM(g4,g5)end;if fL(g6,g7)~=1 then fM(g6,g7)end;if fL(g8,g9)~=1 then fM(g8,g9)end;if fL(ga,gb)~=1 then fM(ga,gb)end end;if fL(gc,gd)~=1 then fM(gc,gd)end;if fL(ge,gf)~=1 then fM(ge,gf)end;if fL(gg,gh)~=1 then fM(gg,gh)end end;fZ=nil else fZ=g1;for dH,dn in pairs(ch[0])do if dn.name==fZ.planetname then b_=dn;bf=fZ.name;break end end;if fL(gc,gd)~=1 then fM(gc,gd)end;if fL(ge,gf)~=1 then fM(ge,gf)end end;if fZ==nil then bg=vec3(b_.center)else bg=fZ.position end;if b_.planetname~="Space"then if b_.hasAtmosphere then gi=bG(b_.radius*(S-1)+b_.noAtmosphericDensityAltitude)else gi=bG(b_.radius*(S-1)+b_.surfaceMaxAltitude)end else gi=R end;if fZ~=nil and fZ.planetname=="Space"then bb=0 else dH,bb=cj(b_):escapeAndOrbitalSpeed(gi)end;bd=0;b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"return true end;local function gj(gk)if not a_ and not bm and not c4 and not bv and not b4 and not c5 then if gk==nil then bh=bh+1;if bh>#cN then bh=0 end else bh=bh-1;if bh<0 then bh=#cN end end;if bh==0 then f_()else local g0=cN[bh].index;local g1=e[0][g0]if g1 and(g1~=nil and g1.name=="Space"or bw=="Custom Only"and g1.center or bw=="No Moons"and string.find(g1.name,"Moon")~=nil)then if gk==nil then gj()else gj(1)end else f_()end end else bV="Disengage autopilot before changing Interplanetary Helper"fN("iph","AP")end end;local function gl()local function gm(gn)local go;if gn then go=d2 else go=bl end;local gp=-1;gp=fW(e[0])if gp>-1 then table.remove(e[0],gp)end;gp=-1;gp=fW(go)if gp~=-1 then bV=fZ.name.." saved location cleared"table.remove(go,gp)end;gj()fS()return go end;if string.sub(bf,1,1)=="*"then d2=gm(true)else bl=gm(false)end end;local function gq(gr,fQ,gs,gt)local function gu(gn)if gn then go=d2 else go=bl end;if dbHud_1 or gs or gn then local dR=fP(fQ)local gv={position=fQ,name=gr,planetname=dR.name,gravity=b.g(),safe=gt}if not gs then go[#go+1]=gv else for dC,dn in pairs(e[0])do if dn.name and gr==dn.name then table.remove(e[0],dC)end end end;table.insert(e[0],gv)fS()f_()bV="Location saved as "..gr.."("..dR.name..")"return go else bV="Databank must be installed to save permanent locations"end end;if string.sub(gr,1,1)=="*"then d2=gu(true)else bl=gu(false)end end;local gw={}function gw.UpdateAtlasLocationsList()fS()end;function gw.UpdateAutopilotTarget()f_()end;function gw.adjustAutopilotTargetIndex(gk)gj(gk)end;function gw.findAtlasIndex(fX,fY)return fW(fX,fY)end;function gw.UpdatePosition(gx,gy,gz)local function gA(gn)local go;if gn then go=d2 else go=bl end;local gp=fW(go)if gp~=-1 then if gx~=nil then if gn then gx="*"..gx end;go[gp].name=gx;bh=bh-1;gj()elseif gz~=nil then if gz then local gB=c9;if gB<1000 then gB=1000 end;go[gp].agg=fO(gB,0)bV=go[gp].name.." AGG Altitude:"..go[gp].agg.." saved ("..go[gp].planetname..")"return elseif gz==false then go[gp].agg=nil;bV=go[gp].name.." AGG Altitude cleared ("..go[gp].planetname..")"return end else local gC=go[gp]if gy then gC.heading=cB:cross(cF)*5000;bV=go[gp].name.." heading saved ("..go[gp].planetname..")"return elseif gy==false then gC.heading=nil;bV=go[gp].name.." heading cleared ("..go[gp].planetname..")"return end;gC.gravity=b.g()gC.position=cH;gC.safe=true end;bV=go[gp].name.." position updated ("..go[gp].planetname..")"else bV="Name Not Found"end end;if string.sub(bf,1,1)=="*"then gA(true)else gA(false)end end;function gw.AddNewLocation(gr,fQ,gs,gt)gq(gr,fQ,gs,gt)end;function gw.ClearCurrentPosition()gl()end;for dC,dn in pairs(d3)do table.insert(e[0],dn)end;if gD then for dC,dn in pairs(gD)do gw[dC]=dn end end;fS()if bh>#cN then bh=0 end;gw.UpdateAutopilotTarget()return gw end;local function gE(b,a,c,library,radar_1,radar_2,eR,gF,de,gG,dd,gH,fN)local gI={}local gJ={}local gK={XS=13,S=27,M=55,L=110,XL=221}local gL={}local gM=0;local gN;local gO;local gP;local gQ;local gR={}local gS="Atmo"local gT;local gU;local gV=0;local gW={}local function gX()local function gY(gZ,g_,h0,h1,h2,h3,h4,h5)g_,h1,h3,h5=vec3(g_),vec3(h1),vec3(h3),vec3(h5)local h6,h7,h8=gZ*gZ,h0*h0,h2*h2;local fq=h1-g_;local h9=fq:normalize()local ha=fq:len()local hb=h3-g_;local hc=(hb-hb:project_on(h9)):normalize()local hd,he=hb:dot(h9),hb:dot(hc)local hf=hd*hd+he*he;local hg=h9:cross(hc)local hh=(h6-h7+ha*ha)/(2*ha)local hi=(h6-h8+hf-2*hd*hh)/(2*he)local dq=h6-hh^2-hi^2;local hj=de(dq)local hk=g_+h9*hh+hc*hi+hg*hj;local hl=g_+h9*hh+hc*hi-hg*hj;if eR((h5-hk):len()-h4)<eR((h5-hl):len()-h4)then return hk else return hl end end;local function hm(hn,fr,ho)local hp=hn.pts;local gp=#hp;local hq=hn.ref;if gp>3 then local hr,hs,ht,hu=hp[gp],hp[gp-1],hp[gp-2],hp[gp-3]hn.ref=ho;local fo=gY(hr[1],hr[2],hs[1],hs[2],ht[1],ht[2],hu[1],hu[2])local hh,hi,hj=fo.x,fo.y,fo.z;if hh==hh and hi==hi and hj==hj then hh=hh+hq[1]hi=hi+hq[2]hj=hj+hq[3]local hv=vec3(hh,hi,hj)hn.center=hv;if hn.lastPos then if(hn.lastPos-hv):len()<2 then local hw=(hv-vec3(ho)):len()if eR(hw-fr)<10 then hn.skipCalc=true end end end;hn.lastPos=hv end;hn.pts={}else local hx={ho[1]-hq[1],ho[2]-hq[2],ho[3]-hq[3]}hp[gp+1]={fr,hx}end end;if radar_1 or radar_2 then cn.assignRadar()end;if gR[1]then gM=#gR[1].getConstructIds()local hy=gR[1].getData()local hz=hy:gmatch('{"constructId[^}]*}[^}]*}')if gM>0 then local ho={cH["x"],cH["y"],cH["z"]}local hA,hB=0,0;gQ,gP=0,0;for dn in hz do local dM,c2,hC=dn:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hD=gK[hC]c2=dd(c2)if gR[1].hasMatchingTransponder(dM)==1 then table.insert(gJ,dM)end;if E then local hE=gR[1].getConstructType(dM)if hD>27 or F or hE=="static"or hE=="space"then gQ=gQ+1;local gr=gR[1].getConstructName(dM)local hn=gW[dM]if hn==nil then hD=hD+gH;gW[dM]={pts={},ref=ho,name=gr,i=0,radius=hD,skipCalc=false}hn=gW[dM]end;if not hn.skipCalc then hm(hn,c2,ho)if F and not hn.abandoned and gR[1].isConstructAbandoned(dM)==1 and hn.center then fN("abRdr","RD")a.print("Abandoned Construct: "..gr.." ("..hE..") rough ::pos{0,0,"..hn.center.x..","..hn.center.y..","..hn.center.z.."}")bV="Abandoned Radar Contact ("..hE..") detected"hn.abandoned=true end;hB=hB+1 else table.insert(gL,hn)end end;hA=hA+1;if cR and hA>700 or hB>70 or(not cR and hA>300 or hB>30)then coroutine.yield()hA,hB=0,0 end end end;gP=#gL;if gP>0 and(cE>20 or b2)then local ek,hF,hG,hH;local hI=0;local hJ=ch:getPlanetarySystem(0)hH=cD:normalize()while hI<gP do coroutine.yield()local hK={table.unpack(gL,hI,math.min(hI+75,gP))}ek,hF,hG=hJ:castIntersections(cH,hH,nil,nil,hK,true)if ek and hG then cT={ek,hF,hG}break end;hI=hI+75 end;if not ek then cT=nil end else cT=nil end;gL={}gN=hy:find('identifiedConstructs":%[%]')else gO=hy:find('worksInEnvironment":false')end end end;local function hL()if gR[1]then gS="Atmo"if gR[1].getData():find('worksInAtmosphere":false')then gS="Space"end end end;function gI.pickType()hL()end;function gI.assignRadar()if radar_1 and gR[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gR[1]=radar_2 end;if gR[1]==radar_2 then hL()end elseif radar_2 and gR[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gR[1]=radar_1 end;if gR[1]==radar_1 then hL()end end end;function gI.UpdateRadar()local hM=coroutine.status(gT)if hM=="suspended"then local dD,hN=coroutine.resume(gT)if hN then a.print("ERROR UPDATE RADAR: "..hN)end elseif hM=="dead"then gT=coroutine.create(gX)local dD,hN=coroutine.resume(gT)end end;function gI.GetRadarHud(hO,hP,hQ,hR)local hS=gJ;local hT,hU;gJ={}local du=gP or 0;if gM>0 then if E then hU=du.."/"..gQ.." Plotted : "..gM-gQ.." Ignored"else hU="Radar Contacts: "..gM end;hT=gG(hQ,hR,hU,"pbright txtbig txtmid")if#gJ>0 then hT=hT..gG(hO,hP,"Friendlies In Range","pbright txtbig txtmid")for dC,dn in pairs(gJ)do hP=hP+20;hT=hT..gG(hO,hP,gR[1].getConstructName(dn),"pdim txtmid")end end;if gN==nil and gU==nil then gV=1;cn.ToggleRadarPanel()end;if gN~=nil and gU~=nil then cn.ToggleRadarPanel()end;if d1==nil then cn.ToggleRadarPanel()end else if gO then hT=gG(hQ,hR,gS.." Radar: Jammed","pbright txtbig txtmid")else hT=gG(hQ,hR,"Radar: No "..gS.." Contacts","pbright txtbig txtmid")end;if d1~=nil then gV=0;cn.ToggleRadarPanel()end end;return hT end;function gI.GetClosestName(gr)if gR[1]then local dM,dH=gR[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dM~=nil and dM~=""then gr=gr.." "..gR[1].getConstructName(dM)end end;return gr end;function gI.ToggleRadarPanel()if d1~=nil and gV==0 then gF(d1)d1=nil;if gU~=nil then gF(gU)gU=nil end else if gV==1 then gF(d1)d1=nil;_autoconf.displayCategoryPanel(gR,1,"Periscope","periscope")gU=_autoconf.panels[_autoconf.panels_size]end;if d1==nil then _autoconf.displayCategoryPanel(gR,1,"Radar","radar")d1=_autoconf.panels[_autoconf.panels_size]end;gV=0 end end;function gI.ContactTick()if not hV then hV=0 end;if bI>hV+10 then bV="Radar Contact"fN("rdrCon","RC")hV=bI end;c.stopTimer("contact")end;function gI.onEnter(dM)if radar_1 and not c7 and not cO then c.setTimer("contact",0.1)end end;function gI.onLeave(dM)if radar_1 and E then if#gW>650 then dM=tostring(dM)gW[dM]=nil end end end;gR[1]=nil;if radar_1 then gR[1]=radar_1;hL()end;gT=coroutine.create(gX)if hW then for dC,dn in pairs(hW)do gI[dC]=dn end end;return gI end;local function hX(d8,dX,bG)local hY={}local hZ=d8.getResistancesCooldown()local function h_()local i0=d8.getState()if G then if not cO and i0==0 then d8.toggle()elseif cO and i0==1 then d8.toggle()end end end;local function i1()local i2=d8.getStressRatioRaw()local i3=0.5999;if i2[1]==0.0 and i2[2]==0.0 and i2[3]==0.0 and i2[4]==0.0 then return end;local i4=d8.setResistances(i3*i2[1],i3*i2[2],i3*i2[3],i3*i2[4])if i4==1 then bV="Shield Resistances updated"else bV="Value Exceeded. Failed to update Shield Resistances"end end;function hY.shieldTick()d9=bG(0.5+d8.getShieldHitpoints()*100/d8.getMaxShieldHitpoints())h_()hZ=d8.getResistancesCooldown()if hZ==0 and d9<a7 then i1()end end;function hY.setResist(i5)if not d8 then bV="No shield found"return elseif i5==nil or hZ>0 then bV="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local du=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dv=du..', '..du..', '..du..', '..du;local i6,i7,i8,i9=dX(i5,dv)if i9==nil or i6+i7+i8+i9>0.6 then bV="Improperly formatted or total exceeds 0.6"return end;if d8.setResistances(i6,i7,i8,i9)==1 then bV="Shield Resistances set"else bV="Resistance setting failed."end end;function hY.ventShield()local ia=d8.getVentingCooldown()if ia>0 then bV="Cannot vent again for "..ia.." seconds"return end;if d8.getShieldHitpoints()<d8.getMaxShieldHitpoints()then d8.startVenting()bV="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bV="Shields already at max hitpoints"end end;if ib then for dC,dn in pairs(ib)do hY[dC]=dn end end;return hY end;local function ic(d,b,c,a,e,radar_1,radar_2,antigrav,hover,d8,warpdrive,id,eR,bG,db,ie,bH,ig,ih,eM,bF,dc,ii,fM,fL,gF,ij,de,fO,gG,fN,ik,il,im,io,ip,iq)local ir=9.80665;local is={}local it={}local iu={}local iv={}local iw=nil;local ix=nil;local iy=nil;local iz=false;local iA="none"local iB=""local iC=55;local iD=0;local iE=0;local iF=""local iG=nil;local iH=ac;local iI=ad;local iJ=ae;local iK=[[rgb(]]..bG(iH+0.5)..","..bG(iI+0.5)..","..bG(iJ+0.5)..[[)]]local iL=[[rgb(]]..bG(iH*0.9+0.5)..","..bG(iI*0.9+0.5)..","..bG(iJ*0.9+0.5)..[[)]]local iM=0;local iN=0;local iO=""local iP=bF()local iQ=false;local iR=vec3({13771471,7435803,-128971})local iS=18000000;local iT=500000;local iU,iV=math.huge;local iW;local function iX(iY)iU=vec3(iY):dist(iR)if iU<iS then return true,eR(iU-iS)end;iV=vec3(iY):dist(vec3(iZ.center))if iV<iT then iW=true else iW=false end;if eR(iV-iT)<eR(iU-iS)then return iW,eR(iV-iT)else return iW,eR(iU-iS)end end;local function i_(dn)if cc==1920 then return dn else return fO(cc*dn/1920,0)end end;local function j0(dn)if cd==1080 then return dn else return fO(cd*dn/1080,0)end end;local function j1()return ij()==0 and g~="keyboard"and ih()==0 end;local function j2()local j3="TRAVEL"if not cK then j3="CRUISE"end;if a_ then j3="AUTOPILOT"end;return j3 end;local hT=""local j4=""local j5=""local j6=1;local j7=2;local j8=3;local j9=4;local ja=5;local jb=6;local jc=7;local jd=""local je=0;local jf=120.0*aP;local jg={}local jh={}local ji={}local jj={}local jk={}local jl={}local jm={}jm["atmofueltank"],jm["spacefueltank"],jm["rocketfueltank"]=0,0,0;local jn=0;local function jo(hh,jp,jq,jr,js,jt)local ju=jn;local jv=jn+5;if not B then jv=jv+5 end;if ih()==1 and not l then ju=ju-50;jv=jv-50 end;if jq=="ATMO"then jd="atmofueltank"elseif jq=="SPACE"then jd="spacefueltank"else jd="rocketfueltank"end;je=_G[jd.."_size"]if#jr>0 then for K=1,#jr do local gr=jr[K][j7]local jw=jr[K][jc]for jx=1,je do if jr[K][j7]==ie(c[jd.."_"..jx].getData()).name then jw=jx;break end end;local jy=bF()if js[K]==nil or jt[K]==nil or jy-jr[K][jb]>jf then local jz;local jA=0;jA=ig(jr[K][j6])-jr[K][j9]jz=jr[K][ja]if jz>jA then jm[jd]=jm[jd]+jz-jA end;if jw~=0 then local jB=ie(c[jd.."_"..jw].getData())jt[K]=jB.percentage;js[K]=jB.timeLeft;if js[K]=="n/a"then js[K]=0 end else jt[K]=bG(0.5+jA*100/jr[K][j8])if jz<=jA then js[K]=0 else js[K]=bG(0.5+jA/((jz-jA)/(jy-jr[K][jb])))end end;jr[K][jb]=jy;jr[K][ja]=jA end;if gr==jp then gr=db("%s %d",jq,K)end;if jw==0 then gr=gr.." *"end;local jC;if js[K]==0 then jC=""else jC=io(js[K])end;if jt[K]~=nil then local jD=bG(jt[K]*2.55)local jE=db("rgb(%d,%d,%d)",255-jD,jD,0)local jF=""if jC~=""and js[K]<120 or jt[K]<5 then jF="red "end;local jG=db("rgb(%d,%d,%d)",dc(bG((255-jD)/2.55),50,100),dc(bG(jD/2.55),0,50),50)local jH="rgb(196,0,255)"if jq=="ATMO"then jH="rgb(0,188,255)"elseif jq=="SPACE"then jH="rgb(239,255,0)"end;local jI=false;if jJ~=jH then jI=true end;jJ=jH;if B then if jI then ju=ju-5;jv=jv-5 end;j4=j4 ..db([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jG,jH,hh,jv,jE,bG(jt[K]*1.7+0.5)-2,hh+1,jv+1,hh+5,jv+14,gr,jt[K],jC)ju=ju-22;jv=jv-22 else j4=j4 ..gG(hh,ju,gr,jF.."pdim txtfuel")j4=j4 ..gG(hh,jv,db("%d%% %s",jt[K],jC),"pdim txtfuel","fill:"..jE)ju=ju+30;jv=jv+30 end end end end;jn=ju end;local function jK(jL,dW)if am==0 and an==0 then return end;if dW<200000 and not c7 or dW and c7 then local jM=0;if eR(cG)>1 then jM=45*math.log(eR(cG),10)if cG<0 then jM=-jM end end;jL[#jL+1]=db([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bG(cG),bG(jM))end;return jL end;local function jN(jO)local gk=-cF;jO=jO-jO:project_on(gk)local jP=vec3(0,0,1)jP=jP-jP:project_on(gk)local jQ=jP:cross(gk)local jM=jP:angle_between(jO)*constants.rad2deg;if jO:dot(jQ)<0 then jM=360-jM end;return jM end;local function jR(jL,ai,aj,jS,jT,cR)if ab==0 then return end;local jU=ab;local jV=20;local jW=bG(jS)if cR then for K=-45,45,5 do local jX=K;jL[#jL+1]=db([[<g transform="rotate(%f,%d,%d)">]],jX,ai,aj)jY=5;if K%15==0 then jY=15 elseif K%10==0 then jY=10 end;jL[#jL+1]=db([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jU+jV-jY,ai,aj+jU+jV)end;jL[#jL+1]=gG(ai,aj+jU+jV-35,jT,"pdim txt txtmid")jL[#jL+1]=gG(ai,aj+jU+jV-25,jW.." deg","pdim txt txtmid")jL[#jL+1]=db([[<g transform="rotate(%f,%d,%d)">]],-jS,ai,aj)jL[#jL+1]=db([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jU+jV-20,ai+5,aj+jU+jV-20,ai,aj+jU+jV-15)jL[#jL+1]="</g>"end;jL[#jL+1]=[[<g style="clip-path: url(#headingClip);">]]local jZ=jW;if cR then jZ=jN(cA)end;local j_=20;local k0=bG(jZ)local k1=0;local k2=aj+jU+jV+20;local k3=ai;if jT~="YAW"then k2=j0(130)k3=i_(960)end;local k4=[[<path class="txttick line" d="]]local k5=bG(k0-(j_+10)-k0%5+0.5)for K=k5+70,k5,-5 do local hh=k3-(-K*5+jZ*5)if K%10==0 then k1=10;local du=K;if du==360 then du=0 elseif du>360 then du=du-360 elseif du<0 then du=du+360 end;jL[#jL+1]=gG(hh,k2+15,du,"txtmid bright")elseif K%5==0 then k1=5 end;if k1==10 then k4=db([[%s M %f %f v %d]],k4,hh,k2-5,k1)else k4=db([[%s M %f %f v %d]],k4,hh,k2-2.5,k1)end end;jL[#jL+1]=k4 ..[["/>]]jL[#jL+1]=db([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k3-5,k2-20,k3+5,k2-20,k3,k2-10)if I then if cR then jT="HDG"end;jL[#jL+1]=gG(i_(960),j0(100),k0 .."°","dim txt txtmid size14","")jL[#jL+1]=gG(i_(960),j0(85),jT,"dim txt txtmid size20","")end;jL[#jL+1]=[[</g>]]end;local function k6(jL,k7,jS,ai,aj,cR,k8,fi)if ab==0 then return end;local jU=ab;local k9=bG(jU*3/5)if jU>0 then local ka=bG(k7)local jY=0;local k4=db([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jS,ai,aj)if not c7 then k4=db([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jL[#jL+1]=db([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jU-1,ai,aj)jL[#jL+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bG(ka-30-ka%5+0.5),bG(ka+30+ka%5+0.5),5 do if K%10==0 then jY=30 elseif K%5==0 then jY=20 end;local hi=aj+-K*5+k7*5;if jY==30 then k4=db([[%s M %d %f h %d]],k4,ai-k9-jY,hi,jY)if c7 then jL[#jL+1]=db([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jS,ai,aj,ai-k9+10,hi+4,K)jL[#jL+1]=db([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jS,ai,aj,ai+k9-10,hi+4,K)if K==0 or K==180 or K==-180 then jL[#jL+1]=db([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jS,ai,aj,ai-k9+20,hi,k9*2-40)end else jL[#jL+1]=gG(ai-k9+10,hi,K,"pdim txt txtmid")jL[#jL+1]=gG(ai+k9-10,hi,K,"pdim txt txtmid")end;k4=db([[%s M %d %f h %d]],k4,ai+k9,hi,jY)else k4=db([[%s M %d %f h %d]],k4,ai-k9-jY,hi,jY)k4=db([[%s M %d %f h %d]],k4,ai+k9,hi,jY)end end;jL[#jL+1]=k4 ..[["/>]]local kb="PITCH"if not cR then kb="REL PITCH"end;if k7>90 and not c7 then k7=90-(k7-90)elseif k7<-90 and not c7 then k7=-90-(k7+90)end;if jU>200 then if c7 then if fi>iC then jL[#jL+1]=gG(ai,aj-15,"Yaw","pdim txt txtmid")jL[#jL+1]=gG(ai,aj+20,k8,"pdim txt txtmid")end;jL[#jL+1]=db([[<g transform="rotate(%f,%d,%d)">]],-jS,ai,aj)else jL[#jL+1]=db([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jL[#jL+1]=db([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k9+25,aj-5,ai-k9+20,aj,ai-k9+25,aj+5,ai-k9+50,aj+4,ka)jL[#jL+1]=db([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k9-25,aj-5,ai+k9-20,aj,ai+k9-25,aj+5,ai+k9-30,aj+4,ka)jL[#jL+1]="</g>"end;local kc=bG(jU/3)jL[#jL+1]=db([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-kc,aj,jU-kc)if not c7 and cR then jL[#jL+1]=db([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jS,ai,aj,ai-k9+10,aj,k9*2-20)end;jL[#jL+1]="</g>"if jU<200 then if c7 and fi>iC then jL[#jL+1]=gG(ai,aj-jU,kb,"pdim txt txtmid")jL[#jL+1]=gG(ai,aj-jU+10,ka,"pdim txt txtmid")jL[#jL+1]=gG(ai,aj-15,"Yaw","pdim txt txtmid")jL[#jL+1]=gG(ai,aj+20,k8,"pdim txt txtmid")else jL[#jL+1]=gG(ai,aj-jU,kb,"pdim txt txtmid")jL[#jL+1]=gG(ai,aj-jU+15,ka,"pdim txt txtmid")end end end end;local function kd(jL,dW,cR)local ke=ao;local kf=ap;if ke==0 and kf==0 then return end;local kg=78;local kh=19;local ki=c6;if c6~=-1 then jL[#jL+1]=gG(ke+kg,kf+kh+20,db("AGL: %.1fm",c6),"pdim altsm txtend")end;if cR and(dW<200000 and not c7 or dW and c7)then table.insert(jL,db([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ke-1,kf-4,kg+2,kh+6,ke+1,kf-1,kg-4,kh))local gp=0;local kj=1;local kk=0;local kl=dW<0;local km=dW<iZ.surfaceMaxAltitude;local kn=9;if kl then kn=0 end;local dW=eR(dW)while gp<6 do local ko=11;local kp=16;local kq=9;local kr=14;local jF="altsm"if gp>2 then kp=kp+3;ko=ko+2;kr=kr+2;kq=kq-6;jF="altbig"end;if kl then jF=jF.." red"elseif km then jF=jF.." orange"end;local ks=dW/kj%10;local kt=bG(ks)local ku=bG((kt+1)%10)local kv=kk;if gp==0 then kv=ks-kt;if kl then kv=1-kv end end;if kl and(gp==0 or kk~=0)then local gs=ku;ku=kt;kt=gs end;local kw=kp*(kv-1)local kx=kw+kp;local hh=ke+kq+(6-gp)*ko;local hi=kf+kr;jL[#jL+1]=gG(hh,hi+kw,ku,jF)jL[#jL+1]=gG(hh,hi+kx,kt,jF)gp=gp+1;kj=kj*10;if kt==kn then kk=kv else kk=0 end end;table.insert(jL,[[</g></g>]])end end;local function ky(fn)local kz=-math.deg(eM(fn.y,fn.z))+180;kz=kz-90;if kz<0 then kz=360+kz end;if kz>180 then kz=-180+kz-180 end;return-kz end;local function kA(fn)local jZ=math.deg(eM(fn.y,fn.x))-90;if jZ<-180 then jZ=360+jZ end;return jZ end;local function kB(jL,fn,fi,ai,aj)if fi>5 and not c7 or fi>iC then local jU=ab;local kC=20;local kD=20;local kE=ky(fn)local kF=kA(fn)local kG=14;local kH=kG/2;local kI=-kF/kD*jU;local kJ=kE/kC*jU;local hh=ai+kI;local hi=aj+kJ;local c2=de(kI^2+kJ^2)local kK=[[<circle
                            cx="]]..hh..[["
                            cy="]]..hi..[["
                            r="]]..kH/kG..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hh..[["
                            cy="]]..hi..[["
                            r="]]..kH..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hh-kG..[[,]]..hi..[[ h ]]..kH..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hh+kH..[[,]]..hi..[[ h ]]..kH..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hh..[[,]]..hi-kG..[[ v ]]..kH..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c2<jU then jL[#jL+1]=kK else local jM=eM(kJ,kI)local kL=4;local kM=ai+jU*math.cos(jM)local kN=aj+jU*math.sin(jM)jL[#jL+1]=db('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jM*180/math.pi,kM,kN,kM-kL,kN-kL/2,kL*2,kL,kM+kL,kN-kL,kL,kL,-kL,kL)end;if not c7 then local kO=vec3(fn)kE=ky(-kO)kF=kA(-kO)kI=-kF/kD*jU;kJ=kE/kC*jU;hh=ai+kI;hi=aj+kJ;c2=de(kI^2+kJ^2)if c2<jU then local kP=[[<circle
                                    cx="]]..hh..[["
                                    cy="]]..hi..[["
                                    r="]]..kH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hh..[[,]]..hi-kG..[[ v ]]..kH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hh..[[,]]..hi..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hh..[[,]]..hi..[[)" />
                                <path
                                    d="M ]]..hh-kH..[[,]]..hi..[[ h ]]..kG..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hh..[[,]]..hi..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hh..[[,]]..hi..[[)"/>]]jL[#jL+1]=kP end end end end;local function kQ(jL,j3,kR,kS)if ak==0 and al==0 then return end;kR=bG(kR+0.5)local ju=al+10;local jv=al+20;if ih()==1 and not l then ju=55;jv=65 end;local kT="CRUISE"local c="km/h"local dD=kS;if j3=="TRAVEL"or j3=="AUTOPILOT"then kT="THROT"c="%"dD=kR;local kU="dim"if kR<0 then kU="red"end;jL[#jL+1]=db([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kU,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eR(kR),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jL[#jL+1]=gG(ak+10,ju,kT,"pbright txtstart")jL[#jL+1]=gG(ak+10,jv,db("%.0f %s",dD,c),"pbright txtstart")if c7 and t and cK and bL then kR=bG(bM*100+0.5)local kU="red"if kR<0 then kU="red"end;jL[#jL+1]=db([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kU,1-eR(kR),ak-10,al+50,ak-15,al+53,ak-15,al+47)jL[#jL+1]=gG(ak+10,ju+40,"LIMIT","pbright txtstart")jL[#jL+1]=gG(ak+10,jv+40,kR.."%","pbright txtstart")end;if c7 and t or b4 then jL[#jL+1]=gG(ak+10,ju-40,"LIMIT: "..cu.." km/h","dim txtstart")elseif not c7 and a_ then jL[#jL+1]=gG(ak+10,ju-40,"LIMIT: "..bG(_*3.6+0.5).." km/h","dim txtstart")end end;local function kV(jL,kW)if ak==0 and al==0 then return end;local kX=al-10;local kY=ak+10;jL[#jL+1]=gG(0,0,"","pdim txt txtend")if ih()==1 and not l then kX=75 end;jL[#jL+1]=gG(kY,kX,bG(kW).." km/h","pbright txtbig txtstart")end;local function kZ(jL)jL[#jL+1]=gG(i_(1900),j0(1070),db("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jL[#jL+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jL[#jL+1]=gG(i_(960),j0(550),"Warning: Invalid Control Scheme Detected","warnings")jL[#jL+1]=gG(i_(960),j0(600),"Keyboard Scheme must be selected","warnings")jL[#jL+1]=gG(i_(960),j0(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local k_=i_(960)local l0=j0(860)local l1=j0(880)local l2=j0(900)local l3=j0(960)local l4=j0(200)local l5=j0(250)local l6=j0(960)if ih()==1 and not l then l0=j0(135)l1=j0(155)l2=j0(175)l4=j0(115)l5=j0(95)end;local l7="#222222"local l8="white"local l9="dimmer"local la="pbright"local lb="#110000"local lc=l7;local ld=l9;if aX then local le=""if type(aX)=="string"then le="-"..aX end;jL[#jL+1]=gG(k_,l0,"Brake Engaged"..le,"warnings")lb="#440000"lc=l8;ld=la elseif bK>0 then jL[#jL+1]=gG(k_,l0,"Auto-Brake Engaged","warnings","opacity:"..bK)end;local lf="#110000"local lg=l7;local lh=l9;if c7 and ct and c6==-1 then if not a_ and not bm and not b2 and not cJ and not b5 and not b3 then jL[#jL+1]=gG(k_,l4+50,"** STALL WARNING **","warnings")lf="#ff0000"lg=l8;lh=la;fN("stall","SW",2)end end;if cQ then jL[#jL+1]=gG(k_,l4+90,"Flight Assist in Progress","warnings")end;if cb then jL[#jL+1]=gG(k_,l6,"Gyro Enabled","warnings")end;local li="#111100"local lj=l7;local lk=l9;if bi then li="#775500"lj=l8;lk=la;if bO then jL[#jL+1]=gG(k_,l1,"Gear Extended","warn")else jL[#jL+1]=gG(k_,l1,"Landed (G: Takeoff)","warnings")end end;if c6>-1 and(not cJ or c9<100)then local ll=im(d:getTargetGroundAltitude())jL[#jL+1]=gG(k_,l2,"Hover Height: "..ll,"warn")end;local lm="#000011"local ln=l7;local lo=l9;if bX then lm="#0000DD"ln=l8;lo=la;jL[#jL+1]=gG(k_,l3+20,"ROCKET BOOST ENABLED","warn")end;local lp="#001100"local lq=l7;local lr=l9;if antigrav and not q and cJ and br~=nil then lp="#00DD00"lq=l8;lr=la;local ls="warnings"if eR(c9-antigrav.getBaseAltitude())<501 then ls="warn"end;jL[#jL+1]=gG(k_,l4+40,db("Target Altitude: %d Singularity Altitude: %d",bG(br),bG(antigrav.getBaseAltitude())),ls)end;if a_ and bf~="None"then jL[#jL+1]=gG(k_,l4,"Autopilot "..bc,"warn")elseif bp~=nil then jL[#jL+1]=gG(k_,l4+20,db("LockedPitch: %d",bG(bp)),"warn")elseif bT then jL[#jL+1]=gG(k_,l4+20,"Follow Mode Engaged","warn")elseif b4 or c5 then jL[#jL+1]=gG(k_,l4+20,"Re-entry in Progress","warn")end;if b1 or b5 then local ll=im(b6,2)if b5 then if cJ then ll=im(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jL[#jL+1]=gG(k_,l4,"VTO to "..ll,"warn")elseif b3 and not bv then if c4 then jL[#jL+1]=gG(k_,l4,"Takeoff to "..bf,"warn")else jL[#jL+1]=gG(k_,l4,"Takeoff to "..ll,"warn")end;if aX and not b5 then jL[#jL+1]=gG(k_,l4+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jL[#jL+1]=gG(k_,l4,"Altitude Hold: "..db("%.1fm",b6),"warn")end end;if b5 and(antigrav~=nil and antigrav)then if c8>0.1 then jL[#jL+1]=gG(k_,l4+20,"Beginning ascent","warn")elseif c8<0.09 and c8>0.05 then jL[#jL+1]=gG(k_,l4+20,"Aligning trajectory","warn")elseif c8<0.05 then jL[#jL+1]=gG(k_,l4+20,"Leaving atmosphere","warn")end end;if bv then if cv~=nil then jL[#jL+1]=gG(k_,l4,cv,"warn")end end;if b2 then if lt then local lu="Brake Landing"if d5 then lu=lu.."-Aligning"end;if d4 then lu=lu.."-Drift Limited"end;jL[#jL+1]=gG(k_,l4,lu,"warnings")else jL[#jL+1]=gG(k_,l4,"Coast-Landing","warnings")end end;if aZ then jL[#jL+1]=gG(k_,l4,"Prograde Alignment","crit")end;if aY then jL[#jL+1]=gG(k_,l4,"Retrograde Alignment","crit")end;local lv="#110000"local lw=l7;local lx=l9;if cS then lv="#FF0000"lw=l8;lx=la;local type;if string.find(cS,"COLLISION")then type="warnings"else type="crit"end;jL[#jL+1]=gG(k_,l5+20,cS,type)elseif c8==0 then local ly,lz=cm.checkLOS(cD:normalize())if lz~=nil then lx=la;lv="#FF0000"lw=l8;local ll=im(lz)local lA=ci.computeTravelTime(cE,0,lz)local lB="Collision"if ly.noAtmosphericDensityAltitude>0 then lB="Atmosphere"end;jL[#jL+1]=gG(k_,l5+20,ly.name.." "..lB.." "..io(lA).." In "..ll,"crit")end end;if bm and not bv then jL[#jL+1]=gG(k_,l4+60,lC,"warn")end;local lD="#111100"local lE=l7;local lF=l9;if cW and#cW>1 then lD="#DDDD00"lE=l8;lF=la end;local lG=i_;local lH=j0;local l9="topButton"local lI="topButtonActive"local lJ=l9;if a_ or bm or c4 or bv then lJ=lI end;local lK=l9;if aZ then lK=lI end;local lL=l9;if b2 or bi then lL=lI end;local lM=l9;if b1 or bm then lM=lI end;local lN=l9;if aY then lN=lI end;local lO=l9;if bv or cx and a_ then lO=lI end;if w and I then local lP=lH(30)jL[#jL+1]=db([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lG(960),lH(54),lH(-53),lG(-120),lG(25),lH(50))jL[#jL+1]=gG(lG(910),lP,"AUTOPILOT")jL[#jL+1]=db([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lK,lG(865),lH(51),lG(-25),lH(-50),lG(-110),lG(25),lH(46))jL[#jL+1]=gG(lG(800),lP,"PROGRADE")jL[#jL+1]=db([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lL,lG(755),lH(47),lG(-25),lH(-46),lG(-98),lG(44),lH(44))jL[#jL+1]=gG(lG(700),lP,"LAND")jL[#jL+1]=db([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lM,lG(960),lH(54),lH(-53),lG(120),lG(-25),lH(50))jL[#jL+1]=gG(lG(1010),lP,"ALT HOLD")jL[#jL+1]=db([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lN,lG(1055),lH(51),lG(25),lH(-50),lG(110),lG(-25),lH(46))jL[#jL+1]=gG(lG(1122),lP,"RETROGRADE")jL[#jL+1]=db([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lO,lG(1165),lH(47),lG(25),lH(-46),lG(98),lG(-44),lH(44))jL[#jL+1]=gG(lG(1220),lP,"ORBIT")jL[#jL+1]=[[
                                    </g>
                                </g>]]jL[#jL+1]="</g>"end;return jL end;local function lQ(fi)return bG(fO(fi*3.6,0)+0.5).." km/h"end;local function lR(gp)local gr=bf;if gp~=nil and type(gp)=="number"then if gp==0 then return"None"end;gr=cN[gp].name end;if gr==nil then gr=fZ.name end;if gr==nil then gr="None"end;return gr end;local function lS(jL)local lT=cm.routeWP(true)if not lT or#lT==0 then return end;local hh=i_(750)local hi=j0(360)if a_ or bm then jL[#jL+1]=gG(hh,hi,"REMAINING ROUTE","pdim txtstart size20")else jL[#jL+1]=gG(hh,hi,"LOADED ROUTE","pdim txtstart size20")end;for dC,K in pairs(lT)do hi=hi+20;jL[#jL+1]=gG(hh,hi,dC..". "..lT[dC],"pdim txtstart size20")end end;local function lU(jL)local hh=aw+10;local hi=ax+20;local lV={}local lW={"Alt-4: AutoTakeoff to Target"}local lX={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lY={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lZ={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lV,"--------------DYNAMIC-----------------")if c7 then if c6~=-1 then ik(lV,lW)if b_ and iZ and b_.name==iZ.name then table.insert(lV,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aW then if antigrav then if cJ then table.insert(lV,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lV,"Turn on AGG to takeoff to AGG Height")end end;if aW then table.insert(lV,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lV,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lV,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bi then table.insert(lV,"G: Takeoff to hover height, raise gear")else table.insert(lV,"G: Lowergear and Land")end else ik(lV,lX)table.insert(lV,"G: Begin BrakeLanding or Land")end;if b5 then table.insert(lV,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ik(lV,lY)if d8 then table.insert(lV,"Alt-Shift-6: Vent shields")if not G then table.insert(lV,"Alt-Shift-7: Toggle shield off/on")end end end;if fZ~=nil then table.insert(lV,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lV,"Alt-9: Activate Gyroscope")end;if aS~="none"or aR~="none"or aT~="none"then table.insert(lV,"Alt-Shift-9: Cycles engines with Extra tags")end;if b1 then table.insert(lV,"Alt-Spacebar/C will raise/lower target height")table.insert(lV,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c7 then table.insert(lV,"LALT+Mousewheel will lower/raise speed limit")end;ik(lV,lZ)for K=1,#lV do hi=hi+12;jL[#jL+1]=gG(hh,hi,lV[K],"pdim txtbig txtstart")end end;local function l_(jL)local m0=aw;local m1=ax;local m2=av;local m3=4;local m4=15;local hh=0;local hi=0;local m5,m6,m7,m8;local m9;local function ma(type)local gB,bI,fi,mb,jF,mc;if type=="Periapsis"then gB=m9.periapsis.altitude;bI=m9.timeToPeriapsis;fi=m9.periapsis.speed;jF="txtend"mb=12;mc=math.min(hh,m0+m2-iZ.radius/m7-m3*2)else gB=m9.apoapsis.altitude;bI=m9.timeToApoapsis;fi=m9.apoapsis.speed;mb=-12;jF="txtstart"mc=hh end;if cE<1 then bI=0 end;jL[#jL+1]=db([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mc+mb,hi-5,hh,hi-5)jL[#jL+1]=db([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mc-mb*4,hi+2,hh,hi+2)jL[#jL+1]=gG(mc,hi,type,jF)hh=mc-mb*2;hi=hi+m4;local ll=im(gB)jL[#jL+1]=gG(hh,hi,ll,jF)hi=hi+m4;jL[#jL+1]=gG(hh,hi,io(bI),jF)hi=hi+m4;jL[#jL+1]=gG(hh,hi,lQ(fi),jF)end;local md=m2*1.5;if bD=="INFO"then md=25*9 end;if bD~="HIDE"then jL[#jL+1]=[[<g class="pbright txtorb txtmid">]]jL[#jL+1]=db('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m2*2,md,m0,m1)jL[#jL+1]=db([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m2*2,md,m0,m1)end;local me=m2*1.5;local mf=m2*2;local mg=me/2;local mh=m2;local mi=m0+mh;local mj=m1+mg;local mk=m0+mf;local ml=m1+me;if bD=="ORBIT"then m1=m1+m3;m5=m2/2;m8=0;m9={}m9.periapsis={}m9.apoapsis={}if fm~=nil then if fm.periapsis~=nil then m9.periapsis.altitude=fm.periapsis.altitude;m9.periapsis.speed=fm.periapsis.speed end;if fm.apoapsis~=nil then m9.apoapsis.altitude=fm.apoapsis.altitude;m9.apoapsis.speed=fm.apoapsis.speed end;m9.period=fm.period;m9.eccentricity=fm.eccentricity;m9.timeToApoapsis=fm.timeToApoapsis;m9.timeToPeriapsis=fm.timeToPeriapsis;m9.eccentricAnomaly=fm.eccentricAnomaly;m9.trueAnomaly=fm.trueAnomaly end;if m9.periapsis==nil then m9.periapsis={}m9.periapsis.altitude=-iZ.radius;m9.periapsis.speed=_ end;if m9.eccentricity==nil then m9.eccentricity=1 end;if m9.apoapsis==nil then m9.apoapsis={}m9.apoapsis.altitude=c9;m9.apoapsis.speed=0 end;if cE<1 then m9.apoapsis.altitude=c9;m9.apoapsis.speed=0 end;if m9.apoapsis.altitude then m7=(m9.apoapsis.altitude+m9.periapsis.altitude+iZ.radius*2)/(m5*2)m6=(iZ.radius+m9.apoapsis.altitude)/m7*(1-m9.eccentricity)m8=m5-m9.periapsis.altitude/m7-iZ.radius/m7;local mm=math.pi;if m9.period~=nil and m9.period>0 and m9.timeToApoapsis~=nil then mm=m9.eccentricAnomaly;if m9.timeToPeriapsis<m9.timeToApoapsis then mm=2*math.pi-mm end end;if cE<1 or mm~=mm then mm=math.pi end;local mn=-m5*math.cos(mm)+m0+mh+m3;local mo=m6*math.sin(mm)+m1+mg+m3;local mp=""jL[#jL+1]='<g clip-path="url(#orbitRect)">'jL[#jL+1]=db([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mp,m0+m2+m3,m1+m2*1.5/2+m3,m5,m6)if m6<1 then jL[#jL+1]=db([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m0+m2+m3-m8,m1+m2*1.5/2+m3,mn,mo)end;jL[#jL+1]=db('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m0+m2+m3-m8,m1+m2*1.5/2+m3,(iZ.radius+iZ.noAtmosphericDensityAltitude)/m7)jL[#jL+1]=db('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m0+m2+m3-m8,m1+m2*1.5/2+m3,(iZ.radius+iZ.noAtmosphericDensityAltitude)/m7)jL[#jL+1]=db([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m0+m2+m3,m1+m2*1.5/2+m3,m5,m6)jL[#jL+1]=db('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m0+m2+m3-m8,m1+m2*1.5/2+m3,iZ.radius/m7)jL[#jL+1]='</g>'local mq=math.floor(iZ.radius/m7+0.5)hh=m0+m2+m3*4+m5;hi=m1+m2*1.5/2+5+m3;if m9.apoapsis~=nil and m9.apoapsis.speed<_ then ma("Apoapsis")end;hi=m1+m2*1.5/2+5+m3;hh=m0+m2-m3*2-m5;if m9.periapsis~=nil and m9.periapsis.speed<_ and m9.periapsis.altitude>0 then ma("Periapsis")end;jL[#jL+1]=gG(m0+m2+m3,m1+20+m3,iZ.name,"txtorbbig")jL[#jL+1]=db('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mn,mo)jL[#jL+1]=[[</g>]]return jL else jL[#jL+1]='<g clip-path="url(#orbitRect)">'local mr=""local ms=1.2*(mt-mu)/(m2*2)local mv=1.4*(mw-mx)/(m2*1.5)for dC,dn in pairs(e[0])do if dn.center then local hh=m0+m2+dn.center.x/ms;local hi=m1+m2*1.5/2+dn.center.y/mv;mr=mr..'<circle cx="'..hh..'" cy="'..hi..'" r="'..dn.radius/ms*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dn.name,"Moon")and not string.match(dn.name,"Sanctuary")and not string.match(dn.name,"Space")then mr=mr.."<text x='"..hh.."' y='"..hi+dn.radius/ms*30+20 .."' font-size='12' fill="..iK.." text-anchor='middle' font-family='Montserrat'>"..dn.name.."</text>"end end end;local fo=vec3(b.getConstructWorldPos())local hh=m0+m2+fo.x/ms;local hi=m1+m2*1.5/2+fo.y/mv;mr=mr..'<circle cx="'..hh..'" cy="'..hi..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mr=mr.."<text x='"..hh.."' y='"..hi-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iw=ms;ix=mv;local my=fo+cD*1000000;local mz=m0+m2+my.x/ms;local jv=m1+m2*1.5/2+my.y/mv;mr=mr..'<line x1="'..hh..'" y1="'..hi..'" x2="'..mz..'" y2="'..jv..'" stroke="purple" stroke-width="1"/>'jL[#jL+1]=mr;jL[#jL+1]='</g>'end elseif bD=="INFO"then jL=ck.DrawOdometer(jL,iM,bj,iN)elseif bD=="HELP"then jL=lU(jL)elseif bD=="SCOPE"then jL[#jL+1]='<g clip-path="url(#orbitRect)">'local mA=cZ;if c8>0 then table.sort(cY,function(es,et)local eu,ev=es.center,et.center;return(eu.x-cH.x)^2+(eu.y-cH.y)^2+(eu.z-cH.z)^2<(ev.x-cH.x)^2+(ev.y-cH.y)^2+(ev.z-cH.z)^2 end)end;local gO={}local mB={}local mC=120;local mD=nil;local mE=nil;for K,dn in ipairs(cY)do local gN=dn.center-cH;local mF=gN:len()local mG=gN:normalize()local mH=gN:cross(cA):normalize()local mI=math.acos(mH:dot(cB))if mI~=mI then mI=0 end;if mH:cross(cB):dot(cA)<0 then mI=-mI end;local mJ=gN:project_on_plane(cA):len()local mK=math.sin(mI)*math.asin(mJ/mF)*constants.rad2deg;local mL=math.cos(mI)*math.asin(mJ/mF)*constants.rad2deg;if mG:dot(cA)<0 then mL=90*math.cos(mI)+90*math.cos(mI)-mL;mK=90*math.sin(mI)+90*math.sin(mI)-mK end;local hh=mi+mK/mA*me;local hi=mj+mL/mA*me;local mM=(hh-mi)*(hh-mi)+(hi-mj)*(hi-mj)local mN=math.asin((dn.radius+dn.surfaceMaxAltitude)/mF)*constants.rad2deg;if mN~=mN then mN=mA end;local hC=mN/mA*me;local mO=math.asin(dn.atmosphereRadius/mF)*constants.rad2deg;if mO~=mO then mO=mN end;local mP=mO/mA*me;local c2=im(mF,1)local mQ=dn.name;local mR=false;if hi>m1 then if hi>ml then if hi-mP<=ml then mR=true end else mR=true end else if hi+mP>=m1 then mR=true end end;local mS=false;local mT=hh;if dn.systemId==0 then mT=hh+mC else mT=hh-mC end;if mT+mC>m0 then if mT+mC>mk then if mT-mP-mC<=mk then mS=true end else mS=true end else if mT+mP+mC>=m0 then mS=true end end;local mU={}mU.x=hh;mU.y=hi;mU.planet=dn;mU.atmoSize=mP;if not mD or mM<mD then mD=mM;mE=mU end;if mS and mR then local mV=math.max(mP,5)if mM<mV*mV then mQ=mQ.." - "..c2 end;mU.size=hC;mU.i=K;mU.displayString=mQ;mU.distance=c2;mU.visible=true;mB[#mB+1]=mU else mU.visible=false end end;local mW=false;table.sort(mB,function(eu,ev)return eu.y<ev.y end)for dC,fr in ipairs(mB)do local dn,hC,K,mP,hh,hi,mQ,c2=fr.planet,fr.size,fr.i,fr.atmoSize,fr.x,fr.y,fr.displayString,fr.distance;local mc,mX,mY,mZ;local m_=15;local jF="pdim"if dn.systemId~=0 then mY=i_(string.len(mQ)*5)m_=-(15+mY)mZ=j0(10)jF="pdimfill"else mY=i_(string.len(mQ)*9)mZ=j0(15)end;if hC*2>mY then mc=dc(hh,m0+mY/2,mk-mY/2)mX=dc(hi,m1+mZ,ml-5)mc=dc(mc,hh-hC+mY/2,hh+hC-mY/2)mX=dc(mX,hi-hC+mZ,hi+hC)else mc=hh+m_;mX=hi end;for n0,fr in pairs(gO)do local n1=fr.textPositions;local n2=n1.y-mX;if n0~=K and eR(n2)<n1.height and n1.x+n1.width>mc and n1.x<mc+mY then if hC>mY then mX=dc(mX+mZ,m1+15,ml-5)else mX=n1.y+n1.height+1 end end end;local n3=mQ~=dn.name or mc<=mi and mc+mY>=mi and mX-mZ<=mj and mX>=mj;fr.hovered=n3;local n4=1;if n3 then n4=2;if hC*2<mY then n4=10 end;if mQ==dn.name then mQ=mQ.." - "..c2 end;jF="pbright"if dn.systemId~=0 then mY=i_(string.len(mQ)*5)m_=-(15+mY)else mY=i_(string.len(mQ)*7)end;if hC*2>mY then mc=dc(hh,m0+mY/2,mk-mY/2)mc=dc(mc,hh-hC+mY/2,hh+hC-mY/2)else mc=hh+m_ end end;gO[K]={}gO[K].textPositions={}gO[K].textPositions.y=mX;gO[K].textPositions.x=mc;gO[K].textPositions.width=mY;gO[K].textPositions.height=mZ;gO[K].output=""if hC*2>mY then jF=jF.." txtmid"else jF=jF.." txtstart"end;if mP-hC>2 then gO[K].output=db('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hh,hi,mP,iL,0.1*n4)end;gO[K].output=gO[K].output..db('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hh,hi,hC,iL,0.2*n4)if dn.systemId==0 then gO[K].output=gO[K].output..db([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mc,mX,iK,jF,mQ)if hC*2<=mY then gO[K].output=gO[K].output..db("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mc+mY,mX+2,mc,mX+2,hh,hi)end else gO[K].output=gO[K].output..db([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mc,mX,iL,jF,mQ)if hC*2<=mY then gO[K].output=gO[K].output..db("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mc,mX+2,mc+mY,mX+2,hh,hi)end end end;for dC=#cY,1,-1 do if gO[dC]then jL[#jL+1]=gO[dC].output end end;if mE~=nil and cZ<90 and not mE.hovered then local n5=mE.planet.atmosphereRadius/mE.atmoSize;local n6=de(mD)*n5;local n7=im(n6,1)local mY=i_(math.max(string.len(n7)*7,string.len(mE.planet.name)*7))local mZ=j0(12)local mc=dc(mE.x+(mi-mE.x)/2,m0+mY/2,mk-mY/2)local mX=dc(mE.y+(mj-mE.y)/2,m1+mZ*2,ml-5)jL[#jL+1]=db("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mE.x,mE.y,mi,mj)jL[#jL+1]=db([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mc,mX,"white",n7)if not mE.visible then jL[#jL+1]=db([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mc,mX-mZ,"white",mE.planet.name)end end;if cE>1 then local gN=cD;local mG=gN:normalize()local mJ=gN:project_on_plane(cA):len()local mH=gN:cross(cA):normalize()local mI=math.acos(mH:dot(cB))if mI~=mI then mI=0 end;if mH:cross(cB):dot(cA)<0 then mI=-mI end;local mK=math.sin(mI)*math.asin(mJ/gN:len())*constants.rad2deg;local mL=math.cos(mI)*math.asin(mJ/gN:len())*constants.rad2deg;if mG:dot(cA)<0 then mL=90*math.cos(mI)+90*math.cos(mI)-mL;mK=90*math.sin(mI)+90*math.sin(mI)-mK end;local hh=mi+mK/mA*me;local hi=mj+mL/mA*me;local kG=14;local kH=kG/2;local kK=[[<circle
                                    cx="]]..hh..[["
                                    cy="]]..hi..[["
                                    r="]]..kH/kG..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hh..[["
                                    cy="]]..hi..[["
                                    r="]]..kH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hh-kG..[[,]]..hi..[[ h ]]..kH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hh+kH..[[,]]..hi..[[ h ]]..kH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hh..[[,]]..hi-kG..[[ v ]]..kH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jL[#jL+1]=kK end;jL[#jL+1]=db("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mi,mj-10,mi,mj+10)jL[#jL+1]=db("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mi-10,mj,mi+10,mj)jL[#jL+1]='</g>'else return jL end end;local function n8(n9,na)local nb;local nc=(na-n9):normalize()local fp=(cH-n9):dot(nc)/nc:dot(nc)if fp<=0. then return(cH-n9):len()elseif fp>=(na-n9):len()then return(cH-na):len()end;local nd=n9+fp*nc;nb=(nd-cH):len()return nb end;local function ne()local nb;local nf=nil;local ng=nil;local nh=nil;for dC,ni in pairs(e[0])do if ni.hasAtmosphere then local c2=n8(iZ.center,ni.center)if nf==nil or c2<nf then ng=ni;nf=c2;nh=iZ end;if b_ and b_.hasAtmosphere and b_.name~=iZ.name then local eH=n8(b_.center,ni.center)if eH<nf then ng=ni;nf=eH;nh=b_ end end end end;local nj=i_(1770)local nk=j0(330)if nf then local nl="txttick "local nm=500000;if nf<ng.radius+nm or nf<nh.radius+nm then if cO then nl="txttick red "else nl="txttick orange "end end;nb=im(nf,2)iB=gG(nj,nk,"Pipe ("..nh.name.."--"..ng.name.."): "..nb,nl.."pbright txtmid")end end;local function nn(hh,hi,no,np,kT)local nq={x=hh,y=hi,width=no,height=np,label=kT}iv[kT]=nq;return nq end;local function nr(ns,nt,no,np,hh,hi,nu,nv,nw,nx,jF)local nq={enableName=ns,disableName=nt,width=no,height=np,x=hh,y=hi,toggleVar=nu,toggleFunction=nv,drawCondition=nw,hovered=false,class=jF}if nx then table.insert(iu,nq)else table.insert(it,nq)end;return nq end;local function ny(nz)if not iz then nA=false;nB=false;nC=false;w=true;return elseif nz=="handling"then nA=not nA;nB=false;nC=false elseif nz=="hud"then nB=not nB;nA=false;nC=false elseif nz=="physics"then nC=not nC;nA=false;nB=false end;if nC or nB or nA then iA=il(nz)w=false else iA="none"w=true end end;local function nD()iz=not iz;if iz then is=iu;bV="Hold SHIFT to see Settings"c_=w else is=it;bV="Hold SHIFT to see Control Buttons"ny()w=c_ end end;local function nE()local function nF(dn,dC)dn.set(not dn.get())if dn.get()then bV=dC.." set to true"else bV=dC.." set to false"end;if dC=="showHud"then c_=dn.get()elseif dC=="BrakeToggleDefault"then aV=j end end;local nG=50;local nH=340;local hh=500;local hi=cd/2-400;local nI=0;for dC,dn in pairs(il("boolean"))do if type(dn.get())=="boolean"then nr(dC,dC,nH,nG,hh,hi,function()return dn.get()end,function()nF(dn,dC)end,function()return true end,true)hi=hi+nG+20;if nI==9 then hh=hh+nH+20;hi=cd/2-400;nI=0 else nI=nI+1 end end end;nr("Control View","Control View",nH,nG,10,cd/2-500,function()return true end,nD,function()return true end,true)nr("View Handling Settings",'Hide Handling Settings',nH,nG,10,cd/2-(500-nG),function()return nA end,function()ny("handling")end,function()return true end,true)nr("View Hud Settings",'Hide Hud Settings',nH,nG,10,cd/2-(500-nG*2),function()return nB end,function()ny("hud")end,function()return true end,true)nr("View Physics Settings",'Hide Physics Settings',nH,nG,10,cd/2-(500-nG*3),function()return nC end,function()ny("physics")end,function()return true end,true)end;local function nJ()local function gq()local fQ=cH;local gr=iZ.name..". "..#bl;if radar_1 then gr=cn.GetClosestName(gr)end;return cl.AddNewLocation(gr,fQ,false,true)end;local function nK()b0=not b0 end;local function nL(nM)if nM==1 then aZ=not aZ;aY=false else aY=not aY;aZ=false end;a_=false;b1=false;bT=false;b2=false;bp=nil;b4=false;b3=false end;local function nN(nO,nP)cl.UpdatePosition(nil,nO,nP)end;local function gl()cl.ClearCurrentPosition()end;local function nQ(gp)local lT=cm.routeWP(true)if lT and#lT>0 then return"Engage Route: "..lT[1]end;return"Engage Autopilot: "..lR(gp)end;local function nR(gp)local lT=cm.routeWP(true)if lT and#lT>0 then return"Next Route Point: "..lT[1]end;return"Disable Autopilot: "..lR(gp)end;local function nS()if ih()==1 then bT=not bT;if bT then a_=false;aY=false;aZ=false;b1=false;b4=false;b2=false;b3=false;nT=bi;bi=false;d.control.retractLandingGears()ii:setTargetGroundAltitude(X)fN("folOn","F")else fN("folOff","F")aX="Follow Off"cs=p;bi=nT;if bi then d.control.extendLandingGears()ii:setTargetGroundAltitude(Y)end end else bV="Follow Mode only works with Remote controller"bT=false end end;local nG=50;local nH=260;local nU=i_(30)local nV=aw+av*2+2;local nW=ax+1;nr("+","+",nU,nU,nV,nW+nU+1,function()return false end,function()cZ=cZ/8 end,function()return bD=="SCOPE"end,nil,"ZoomButton")nr("-","-",nU,nU,nV,nW,function()return false end,function()cZ=math.min(cZ*8,90)end,function()return bD=="SCOPE"end,nil,"ZoomButton")nr("0","0",nU,nU,nV,nW+nU*2+2,function()return false end,function()cZ=90 end,function()return bD=="SCOPE"and cZ~=90 end,nil,"ZoomButton")local nX=nr("Enable Brake Toggle","Disable Brake Toggle",nH,nG,cc/2-nH/2,cd/2+350,function()return aV end,function()aV=not aV;if aV then bV="Brakes in Toggle Mode"else bV="Brakes in Default Mode"end end)nr("Align Prograde","Disable Prograde",nH,nG,cc/2-nH/2-50-nX.width,cd/2-nG+380,function()return aZ end,function()nL(1)end)nr("Align Retrograde","Disable Retrograde",nH,nG,cc/2-nH/2+nX.width+50,cd/2-nG+380,function()return aY end,nL,function()return c8==0 end)nY=nr(nQ,nR,600,60,cc/2-600/2,cd/2-60/2-330,function()return a_ or bm or c4 or bv end,function()end)local K;local function nZ(n_)local gp=cV+n_;if gp>#cN then gp=gp-#cN-1 end;if gp<0 then gp=#cN+gp end;return gp end;o0={}for K=0,10 do local o1=nr(function(ev)local gp=nZ(ev.apExtraIndex)if a_ or bm or c4 or bv then return"Redirect: "..lR(gp)end;return nQ(gp)end,function(ev)local gp=nZ(ev.apExtraIndex)return nR(gp)end,600,60,cc/2-600/2,cd/2-60/2-330+60*K,function(ev)local gp=nZ(ev.apExtraIndex)return gp==bh and(a_ or bm or c4 or bv)end,function(ev)local gp=nZ(ev.apExtraIndex)local o2=bh==gp;bh=gp;cl.UpdateAutopilotTarget()cm.ToggleAutopilot()if not o2 and not(a_ or bm or c4 or bv)then cm.ToggleAutopilot()end end,function()return cU and(#cm.routeWP(true)==0 or K==0)end)o1.apExtraIndex=K;o0[K]=o1 end;nr("Save Position","Save Position",200,nY.height,nY.x+nY.width+30,nY.y,function()return false end,gq,function()return bh==0 or fZ==nil end)nr("Update Position","Update Position",200,nY.height,nY.x+nY.width+30,nY.y,function()return false end,function()nN(nil)end,function()return bh>0 and fZ~=nil end)nr("Save Heading","Clear Heading",200,nY.height,nY.x+nY.width+30,nY.y+nY.height+20,function()return fZ.heading~=nil end,function()if fZ.heading~=nil then nN(false)else nN(true)end end,function()return bh>0 and fZ~=nil end)nr("Save AGG Alt","Clear AGG Alt",200,nY.height,nY.x+nY.width+30,nY.y+nY.height*2+40,function()return fZ.agg~=nil end,function()if fZ.agg~=nil then nN(nil,false)else nN(nil,true)end end,function()return bh>0 and fZ~=nil and antigrav end)nr("Clear Position","Clear Position",200,nY.height,nY.x-200-30,nY.y,function()return true end,gl,function()return bh>0 and fZ~=nil end)nr("Save Route","Save Route",200,nY.height,nY.x-200-30,nY.y+nY.height*2+40,function()return false end,function()cm.routeWP(false,false,2)end,function()return#cm.routeWP(true)>0 end)nr("Load Route","Clear Route",200,nY.height,nY.x-200-30,nY.y+nY.height+20,function()return#cm.routeWP(true)>0 end,function()if#cm.routeWP(true)>0 then cm.routeWP(false,true)elseif a_ or bm then bV="Disable Autopilot before loading route"return else cm.routeWP(false,false,1)end end,function()return true end)nG=60;nH=300;local hh=0;local hi=cd/2-150;nr("Enable Check Damage","Disable Check Damage",nH,nG,hh,hi-nG-20,function()return s end,function()s=not s end)nr("View Settings","View Settings",nH,nG,hh,hi,function()return true end,nD)hi=hi+nG+20;nr("Enable Turn and Burn","Disable Turn and Burn",nH,nG,hh,hi,function()return b0 end,nK)hh=10;hi=cd/2-300;nr("Horizontal Takeoff Mode","Vertical Takeoff Mode",nH,nG,hh+nH+20,hi,function()return aW end,function()aW=not aW;if aW then bV="Vertical Takeoff Mode"else bV="Horizontal Takeoff Mode"end end,function()return cI end)hi=hi+nG+20;nr("Engage Orbiting","Cancel Orbiting",nH,nG,hh+nH+20,hi,function()return bv end,cm.ToggleIntoOrbit,function()return c8==0 and cR end)hi=cd/2-150;nr("Glide Re-Entry","Cancel Glide Re-Entry",nH,nG,hh+nH+20,hi,function()return b4 end,function()c3=1;nL(1)end,function()return iZ.hasAtmosphere and not c7 end)hi=hi+nG+20;nr("Parachute Re-Entry","Cancel Parachute Re-Entry",nH,nG,hh+nH+20,hi,function()return b4 end,function()c3=2;nL(1)end,function()return iZ.hasAtmosphere and not c7 end)hi=hi+nG+20;nr("Engage Follow Mode","Disable Follow Mode",nH,nG,hh,hi,function()return bT end,nS,function()return ih()==1 end)nr("Enable Repair Arrows","Disable Repair Arrows",nH,nG,hh+nH+20,hi,function()return iQ end,function()iQ=not iQ;if iQ then bV="Repair Arrows Enabled"else bV="Repair Arrows Diabled"end end,function()return ih()==1 end)hi=hi+nG+20;if not q then nr("Enable AGG","Disable AGG",nH,nG,hh,hi,function()return cJ end,cm.ToggleAntigrav,function()return antigrav~=nil end)end;nr(function()return db("Switch IPH Mode - Current: %s",bw)end,function()return db("IPH Mode: %s",bw)end,nH*2,nG,hh,hi,function()return false end,function()if bw=="All"then bw="Custom Only"elseif bw=="Custom Only"then bw="No Moons"else bw="All"end;bV="IPH Mode: "..bw end)hi=hi+nG+20;nr(function()return db("Toggle Control Scheme - Current: %s",g)end,function()return db("Control Scheme: %s",g)end,nH*2,nG,hh,hi,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bV="New Control Scheme: "..g end)local o3=j0(20)local o1=nn(0,0,i_(70),o3,"HELP")o1=nn(o1.x+o1.width,o1.y,i_(80),o3,"INFO")o1=nn(o1.x+o1.width,o1.y,i_(70),o3,"ORBIT")o1=nn(o1.x+o1.width,o1.y,i_(70),o3,"SCOPE")nn(o1.x+o1.width,o1.y,i_(70),o3,"HIDE")end;local o4={}local o5=nil;function o4.HUDPrologue(jL)cO,cP=iX(cH)if not cO then iH=af;iI=ag;iJ=ah else iH=ac;iI=ad;iJ=ae end;iK=[[rgb(]]..bG(iH+0.6)..","..bG(iI+0.6)..","..bG(iJ+0.6)..[[)]]iL=[[rgb(]]..bG(iH*0.8+0.5)..","..bG(iI*0.8+0.5)..","..bG(iJ*0.8+0.5)..[[)]]local o6=iK;local o7=iL;local o8=[[rgb(]]..bG(iH*0.4+0.5)..","..bG(iI*0.4+0.5)..","..bG(iJ*0.4+0.5)..[[)]]local o9=iK;local oa=iL;local ob=o8;if j1()and not m then o6=[[rgb(]]..bG(iH*0.5+0.5)..","..bG(iI*0.5+0.5)..","..bG(iJ*0.5+0.5)..[[)]]o7=[[rgb(]]..bG(iH*0.3+0.5)..","..bG(iI*0.3+0.5)..","..bG(iJ*0.2+0.5)..[[)]]o8=[[rgb(]]..bG(iH*0.2+0.5)..","..bG(iI*0.2+0.5)..","..bG(iJ*0.2+0.5)..[[)]]end;local lG=i_;local lH=j0;jL[#jL+1]=db([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o6,o6,o6,o9,o9,o7,o7,oa,oa,o7,o6,o8,oa,o6,o6,o8,o8,ob,o8,cc,cd,o7,o7,o7,o7,o7,o9,o7,oa,ob,oa,oa,ob)if not o5 then o5=db([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lG(630),lH(0),lG(675),lH(45),lG(960),lH(55),lG(1245),lH(45),lG(1290),lH(0),lG(1000),lH(105),lG(1040),lH(59),lG(1250),lH(51),lG(1300),lH(0),lG(1920),lH(0),lG(1920),lH(20),lG(1400),lH(20),lG(1300),lH(105),lG(920),lH(105),lG(880),lH(59),lG(670),lH(51),lG(620),lH(0),lG(0),lH(0),lG(0),lH(20),lG(520),lH(20),lG(620),lH(105),lG(890),lH(59),lG(960),lH(62),lG(1030),lH(59),lG(985),lH(112),lG(1150),lH(112),lG(1100),lH(152),lG(820),lH(152),lG(780),lH(112),lG(935),lH(112),lG(890),lH(59),lG(960),lH(62),lG(1030),lH(59),lG(985),lH(112),lG(1150),lH(112),lG(1100),lH(152),lG(820),lH(152),lG(780),lH(112),lG(935),lH(112))end;if w and I then jL[#jL+1]=o5 end;return jL end;function o4.DrawVerticalSpeed(jL,dW)jK(jL,dW)end;function o4.UpdateHud(jL)local kz=cL;local oc=cM;local jS=oc;local k7=kz;local kR=bG(c.getThrottle())local kW=cE*3.6;local kS=c.getAxisCommandValue(0)local od=i_(1770)local oe=j0(310)if t and cK then kS=bJ;kR=bJ*100 end;local j3=j2()local jT="ROLL"if kR==nil then kR=0 end;if not cR then if cE>5 then kz=ky(cC)oc=kA(cC)else kz=0;oc=0 end;jT="YAW"end;if cP>50000 and not c7 then local of;of=im(cP)jL[#jL+1]=gG(od,oe,"PvP Boundary: "..of,"pbright txtbig txtmid")end;jL[#jL+1]=iO;jL[#jL+1]=iF;jL[#jL+1]=hT;if iB~=""then jL[#jL+1]=iB end;if j4~=""then jL[#jL+1]=j4 end;if j5~=""then jL[#jL+1]=j5 end;jK(jL,c9)if ih()==0 or l then if not j1()or m then if cR then jR(jL,ai,aj,jS,jT,cR)k6(jL,k7,jS,ai,aj,cR,bG(kA(cC)),cE)else jR(jL,ai,aj,oc,jT,cR)k6(jL,kz,oc,ai,aj,cR,bG(oc),cE)end;kd(jL,c9,cR)kB(jL,cC,cE,ai,aj)end end;kQ(jL,j3,kR,kS)kV(jL,kW)kZ(jL)l_(jL)if not iz and bU then lS(jL)end;return jL end;function o4.HUDEpilogue(jL)jL[#jL+1]="</svg>"return jL end;function o4.ExtraData(jL)local og=i_(1240)local oh=j0(55)local oi=oh+10;local oj;local lG=i_;local lH=j0;local ok=0;local j3=j2()if aW then j3=j3 .."-VERTICAL"end;if E and not b3 and not b2 and cE>20 then j3=j3 .."-COLLISION ON"end;if by~="Off"then j3="("..by..")-"..j3 end;if b0 then j3="TB-"..j3 end;if not bx then j3=j3 .."-DeCoupled"end;local ol=lH(99)local om=lH(80)local on=lH(85)local oo=lH(31)local op=0;local oq=0;local os=ca>1000000 and fO(ca/1000000,2).."kT"or fO(ca/1000,2).."T"if c7 then ok=bq else ok=bo end;local ot,ou=ci.computeDistanceAndTime(cE,0,ca,0,0,ok)if ot<0 then ot=0 end;ok=fO(ok/(ca*ir),2).."g"local ov=d:maxForceForward()oj=b.g()if oj>0.1 then oq=ca*oj;oq=fO(oq/(ca*ir),2).."g"op=0.5*ov/oj;op=op>1000000 and fO(op/1000000,2).."kT"or fO(op/1000,2).."T"end;ov=fO(ov/(ca*ir),2).."g"local ow=vec3(b.getWorldAcceleration()):len()/9.80665;oj=b.g()jL[#jL+1]=[[<g class="dim txt txtend size14">]]if ih()==1 and not l then og=i_(1120)oh=j0(55)oi=oh+10 elseif c7 and I then local ox=i_(770)jL[#jL+1]=gG(lG(895),ol,"ATMO","")jL[#jL+1]=db([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lG(895),on,lG(-80))jL[#jL+1]=gG(lG(815),om,db("%.1f%%",c8*100),"txtstart size20")end;if I then jL[#jL+1]=gG(lG(1025),ol,"GRAVITY","txtstart")jL[#jL+1]=db([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(1025),on,lG(80))jL[#jL+1]=gG(lG(1105),om,db("%.2fg",oj/9.80665),"size20")jL[#jL+1]=gG(lG(1125),ol,"ACCEL","txtstart")jL[#jL+1]=db([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(1125),on,lG(80))jL[#jL+1]=gG(lG(1205),om,db("%.2fg",ow),"size20")jL[#jL+1]=gG(lG(695),ol,"BRK TIME","")jL[#jL+1]=db([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(695),on,lG(-80))jL[#jL+1]=gG(lG(615),om,db("%s",io(ou)),"txtstart size20")jL[#jL+1]=gG(lG(635),lH(45),"TRIP","")jL[#jL+1]=db([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(635),lH(31),lG(-90))if lA then jL[#jL+1]=gG(lG(545),lH(26),db("%s",io(lA)),"txtstart size20")end;jL[#jL+1]=gG(lG(795),ol,"BRK DIST","")jL[#jL+1]=db([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(795),on,lG(-80))jL[#jL+1]=gG(lG(715),om,db("%s",im(ot)),"txtstart size20")jL[#jL+1]=gG(lG(1285),lH(45),"MASS","txtstart")jL[#jL+1]=db([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(1285),lH(31),lG(90))jL[#jL+1]=gG(lG(1375),lH(26),db("%s",os),"size20")jL[#jL+1]=gG(lG(1220),ol,"THRUST","txtstart")jL[#jL+1]=db([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(1220),on,lG(80))jL[#jL+1]=gG(lG(1300),om,db("%s",ov),"size20")jL[#jL+1]=gG(i_(960),j0(175),j3,"pbright txtbig txtmid size20")end;jL[#jL+1]="</g>"end;local oy=1-(a5*0.05+a6*0.05)function o4.FuelUsed(oz)local oA;if oz=="atmofueltank"then oA=db("Atmo Fuel Used: %.1f L",jm[oz]/(4*oy))elseif oz=="spacefueltank"then oA=db("Space Fuel Used: %.1f L",jm[oz]/(6*oy))else oA=db("Rocket Fuel Used: %.1f L",jm[oz]/(0.8*oy))end;return oA end;function o4.DrawOdometer(jL,iM,bj,iN)if bD~="INFO"then return jL end;local oj;local op=0;local oq=0;local ok=0;local os=ca>1000000 and fO(ca/1000000,2).." kTons"or fO(ca/1000,2).." Tons"if c7 then ok=bq else ok=bo end;local ot,ou=ci.computeDistanceAndTime(cE,0,ca,0,0,ok)ok=fO(ok/(ca*ir),2).." g"local ov=d:maxForceForward()oj=b.g()if oj>0.1 then oq=ca*oj;oq=fO(oq/(ca*ir),2).." g"op=0.5*ov/oj;op=op>1000000 and fO(op/1000000,2).." kTons"or fO(op/1000,2).." Tons"end;ov=fO(ov/(ca*ir),2).." g"if ih()==0 or l then local oB=i_(aw+10)local oC=j0(ax+20)local oD=i_(aw+10+av/1.25)local np=25;jL[#jL+1]="<g class='txtstart size14 bright'>"jL[#jL+1]=gG(oB,oC,db("BrkTime: %s",io(ou)))jL[#jL+1]=gG(oD,oC,db("Trip: %.2f km",iM))jL[#jL+1]=gG(oB,oC+np,db("Lifetime: %.2f kSU",bj/200000))jL[#jL+1]=gG(oD,oC+np,db("BrkDist: %s",im(ot)))jL[#jL+1]=gG(oB,oC+np*2,"Trip Time: "..io(iN))jL[#jL+1]=gG(oD,oC+np*2,"Total Time: "..io(bk))jL[#jL+1]=gG(oB,oC+np*3,db("Mass: %s",os))jL[#jL+1]=gG(oD,oC+np*3,db("Max Brake: %s",ok))jL[#jL+1]=gG(oB,oC+np*4,db("Max Thrust: %s",ov))if oj>0.1 then jL[#jL+1]=gG(oD,oC+np*4,db("Max Thrust Mass: %s",op))jL[#jL+1]=gG(oB,oC+np*5,db("Req Thrust: %s",oq))else jL[#jL+1]=gG(oD,oC+np*4,"Max Mass: n/a")jL[#jL+1]=gG(oB,oC+np*5,"Req Thrust: n/a")end;jL[#jL+1]=gG(oD,oC+np*5,ck.FuelUsed("atmofueltank"))jL[#jL+1]=gG(oB,oC+np*6,ck.FuelUsed("spacefueltank"))jL[#jL+1]=gG(oD,oC+np*6,ck.FuelUsed("rocketfueltank"))if cE>833 then local oE=ca/math.sqrt(1-(cE/8333.33)^2)local os=oE>1000000 and fO(oE/1000000,2).." kTons"or fO(oE/1000,2).." Tons"jL[#jL+1]=gG(oD,oC+np*7,db("Rel. Mass: %s",os))end end;jL[#jL+1]="</g></g>"return jL end;function o4.DrawWarnings(jL)return kZ(jL)end;function o4.DisplayOrbitScreen(jL)return l_(jL)end;function o4.DisplayMessage(jL,ll)if ll~="empty"then local hi=310;for lu in string.gmatch(ll,"([^\n]+)")do hi=hi+35;jL[#jL+1]=gG("50%",hi,lu,"msg")end end;if bW~=0 then c.setTimer("msgTick",bW)bW=0 end end;function o4.DrawDeadZone(jL)jL[#jL+1]=db([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function o4.UpdatePipe()if c7 then iB=""return end;ne()end;function o4.DrawSettings(jL)local hh=i_(640)local hi=j0(200)jL[#jL+1]=[[<g class="pbright txtvspd txtstart">]]local hA=0;for dC,dn in pairs(iA)do hA=hA+1;jL[#jL+1]=gG(hh,hi,dC..": "..dn.get())hi=hi+20;if hA%12==0 then hh=hh+i_(350)hi=j0(200)end end;jL[#jL+1]=gG(i_(640),j0(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jL[#jL+1]="</g>"return jL end;local hQ=i_(1770)local hR=j0(350)local hP=j0(15)local hO=i_(1370)local hU,oF;function o4.DrawRadarInfo()hT=cn.GetRadarHud(hO,hP,hQ,hR)end;function o4.DrawTanks()if aq~=0 and ar~=0 then j4=gG(aq,ar,"","txtstart pdim txtfuel")jn=ar;jo(aq,"Atmospheric ","ATMO",ce,jk,jl)jo(aq,"Space Fuel T","SPACE",cf,ji,jj)jo(aq,"Rocket Fuel ","ROCKET",cg,jg,jh)end end;function o4.DrawShield()local i0=d8.getState()==1 and"Shield Active"or"Shield Disabled"local oG=b.getPvPTimer()local oH=d8.getResistances()local oI="A: "..10+oH[1]*100 .."% / E: "..10+oH[2]*100 .."% / K:"..10+oH[3]*100 .."% / T: "..10+oH[4]*100 .."%"local hh,hi=as-60,at+30;local jD=bG(d9*2.55)local jE=db("rgb(%d,%d,%d)",255-jD,jD,0)local jF=""j5=gG(hh,hi,"","txtmid pdim txtfuel")if d9<10 and i0~="Shield Disabled"then jF="red "end;oG=oG>0 and"   PvPTime: "..io(oG)or""j5=j5 ..db([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hh,hi,jE,d9*2,hh,hi,hh+2,hi+10,d9,oG)j5=j5 ..gG(hh,hi-5,i0,jF.."txtstart pbright txtbig")j5=j5 ..gG(hh,hi+30,oI,jF.."txtstart pbright txtsmall")end;function o4.hudtick()if not iZ then return end;local function oJ(jL)local jH=bG(dc(d6/(cc/4)*255,0,255))jL[#jL+1]=db("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c0,c1,bG(iH+0.5)+jH,bG(iI+0.5)-jH,bG(iJ+0.5)-jH)end;local function oK()for dH,dn in pairs(is)do if dn.hovered then if not dn.drawCondition or dn.drawCondition(dn)then dn.toggleFunction(dn)end;dn.hovered=false end end;for dH,dn in pairs(iv)do if dn.hovered then bD=dn.label;dn.hovered=false end end end;local function oL()local function oM(oN,oO,hh,hi,no,np)if oN>=hh and oN<=hh+no and oO>=hi and oO<=hi+np then return true else return false end end;local hh=c0+cc/2;local hi=c1+cd/2;for dH,dn in pairs(is)do dn.hovered=oM(hh,hi,dn.x,dn.y,dn.width,dn.height)end;for dH,dn in pairs(iv)do dn.hovered=oM(hh,hi,dn.x,dn.y,dn.width,dn.height)end;if cU then local n3=false;for dH,ev in ipairs(o0)do if ev.hovered then n3=true;break end end;if nY.hovered then n3=true end;cU=n3 else cU=nY.hovered;if not cU then cV=bh end end end;local function oP(jL)if not bD or bD==""then bD="HELP"end;if w then for dC,dn in pairs(iv)do local jF="dim brightstroke"local oQ=0.2;if bD==dC then jF="pbright dimstroke"oQ=0.6 end;local oR=""if dn.hovered then oQ=0.8;oR=";stroke:white"end;jL[#jL+1]=db([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dn.width,dn.height,dn.x,dn.y,jF,oQ,oR)jL[#jL+1]=gG(dn.x+dn.width/2,dn.y+dn.height/2+5,dn.label,"txt txtmid pdim")end end end;local function oS(jL)local function oT(jL,oU,hover,hh,hi,fb,oV,oW,oX,oY,oZ,o1)if type(oY)=="function"then oY=oY(o1)end;if type(oZ)=="function"then oZ=oZ(o1)end;jL[#jL+1]=db("<rect x='%f' y='%f' width='%f' height='%f' fill='",hh,hi,fb,oV)if oU then jL[#jL+1]=db("%s'",oW)else jL[#jL+1]=oX end;if hover then jL[#jL+1]=db(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jL[#jL+1]=db(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fO(ac*0.5,0),fO(ad*0.5,0),fO(ae*0.5,0))end;jL[#jL+1]=" rx='5'></rect>"jL[#jL+1]=db("<text x='%f' y='%f' font-size='24' fill='",hh+fb/2,hi+oV/2+5)if oU then jL[#jL+1]="black"else jL[#jL+1]="white"end;jL[#jL+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oU then jL[#jL+1]=db("%s</text>",oY)else jL[#jL+1]=db("%s</text>",oZ)end end;local o_=db("rgb(%d,%d,%d)'",fO(ac*0.1,0),fO(ad*0.1,0),fO(ae*0.1,0))local p0=db("rgb(%d,%d,%d)",fO(ac*0.8,0),fO(ad*0.8,0),fO(ae*0.8,0))local p1=oT;for dH,dn in pairs(is)do local nt=dn.disableName;local ns=dn.enableName;if type(nt)=="function"then nt=nt(dn)end;if type(ns)=="function"then ns=ns(dn)end;if not dn.drawCondition or dn.drawCondition(dn)then p1(jL,dn.toggleVar(dn),dn.hovered,dn.x,dn.y,dn.width,dn.height,p0,o_,nt,ns,dn)end end end;local p2=fO(cc/2,0)local p3=fO(cd/2,0)local jL={}if p4 then jL[#jL+1]=p4 end;ck.HUDPrologue(jL)if w then ck.UpdateHud(jL)else if A then ck.DrawVerticalSpeed(jL,c9)end;ck.DrawWarnings(jL)end;if iz and iA~="none"then ck.DrawSettings(jL)end;if radar_1 then ck.DrawRadarInfo()end;ck.HUDEpilogue(jL)jL[#jL+1]=db([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cc,cd)if bV~="empty"then ck.DisplayMessage(jL,bV)end;if ih()==0 and g=="virtual joystick"then if v then ck.DrawDeadZone(jL)end end;oP(jL)if ij()==0 then if ih()==1 and bU then if not p5 then oL()oS(jL)end;if not cq and not cr then local p6=table.concat(jL,"")jL={}jL[#jL+1]=db("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cc,cd)jL[#jL+1]=p6;jL[#jL+1]="</body>"cq=true;jL[#jL+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cr then local p6=table.concat(jL,"")jL={}jL[#jL+1]=db("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cc,cd)jL[#jL+1]=p6;jL[#jL+1]="</body>"end;if not cq then jL[#jL+1]=db([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,c0,c1)end else oK()end else if not bU and ih()==0 then oK()if d6>au then if v then oJ(jL)end end elseif bU and(not p5 or not i)then oL()oS(jL)end;jL[#jL+1]=db([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,c0,c1)end;jL[#jL+1]=[[</svg></body>]]p7=table.concat(jL,"")end;function o4.TenthTick()local function p8()local p9=a.createData;local pa=a.createWidget;pb=a.createWidgetPanel("Interplanetary Helper")pc=pa(pb,"value")pd=p9('{"label": "Target Planet", "value": "N/A", "unit":""}')fM(pd,pc)pe=pa(pb,"value")pf=p9('{"label": "distance", "value": "N/A", "unit":""}')fM(pf,pe)gf=pa(pb,"value")ge=p9('{"label": "Travel Time", "value": "N/A", "unit":""}')fM(ge,gf)gd=pa(pb,"value")gc=p9('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fM(gc,gd)gh=pa(pb,"value")gg=p9('{"label": "Target Altitude", "value": "N/A", "unit":""}')fM(gg,gh)g9=pa(pb,"value")g8=p9('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g7=pa(pb,"value")g6=p9('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g5=pa(pb,"value")g4=p9('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g3=pa(pb,"value")g2=p9('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gb=pa(pb,"value")ga=p9('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c7 then fM(g8,g9)fM(g6,g7)fM(g4,g5)fM(g2,g3)fM(ga,gb)end end;local function pg()gF(pb)pb=nil end;local function ph()if not a_ then if fZ==nil or fZ.planetname~=iZ.name then pi=(b_.center-cH):len()else pi=(fZ.position-cH):len()end end;local fi=cE;local pj=c.getThrottle()/100;if t then pj=bJ end;local pk,pl=ci.computeDistanceAndTime(cE,_,ca,d:maxForceForward()*pj,a1,0)local bY,bZ;if not b0 then bY,bZ=cm.GetAutopilotBrakeDistanceAndTime(_)else bY,bZ=cm.GetAutopilotTBBrakeDistanceAndTime(_)end;local dH,pm;if not b0 and fi>0 then dH,pm=cm.GetAutopilotBrakeDistanceAndTime(fi)else dH,pm=cm.GetAutopilotTBBrakeDistanceAndTime(fi)end;local pn=0;local po=0;if ba or not a_ and fi>5 then po=ci.computeTravelTime(fi,0,pi)elseif bY+pk<pi then pn=pi-(bY+pk)po=ci.computeTravelTime(8333.0556,0,pn)else local pp=(pi-bY)/pk;pk=pi-bY;pl=pl*pp end;if fZ~=nil and fZ.planetname==iZ.name and not a_ then return po elseif b9 then return pm elseif ba then return po+pm else return pl+bZ+po end end;ck.DrawTanks()if d8 then ck.DrawShield()end;if bf~="None"then if pb==nil then p8()end;if bf~=nil then local mF;local pq=fZ~=nil;local pr=0.5*bq/b_:getGravity(b_.center+vec3(0,0,1)*b_.radius):len()pr=pr>1000000 and fO(pr/1000000,2).." kTons"or fO(pr/1000,2).." Tons"fL(pd,'{"label": "Target", "value": "'..bf..'", "unit":""}')lA=ph()if pq and not a_ then mF=(cH-fZ.position):len()else mF=(bg-cH):len()end;if not b0 then bY,bZ=cm.GetAutopilotBrakeDistanceAndTime(cE)iD,iE=cm.GetAutopilotBrakeDistanceAndTime(_)else bY,bZ=cm.GetAutopilotTBBrakeDistanceAndTime(cE)iD,iE=cm.GetAutopilotTBBrakeDistanceAndTime(_)end;local ll=im(mF)fL(pf,'{"label": "distance", "value": "'..ll..'"}')fL(ge,'{"label": "Travel Time", "value": "'..io(lA)..'", "unit":""}')ll=im(bY)fL(g8,'{"label": "Cur Brake distance", "value": "'..ll..'"}')fL(g6,'{"label": "Cur Brake Time", "value": "'..io(bZ)..'", "unit":""}')ll=im(iD)fL(g4,'{"label": "Max Brake distance", "value": "'..ll..'"}')fL(g2,'{"label": "Max Brake Time", "value": "'..io(iE)..'", "unit":""}')fL(gc,'{"label": "Max Brake Mass", "value": "'..db("%s",pr)..'", "unit":""}')ll=im(gi)fL(gg,'{"label": "Target Orbit", "value": "'..ll..'"}')if c8>0 and not ps then a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)ps=true;if not cK and t and(b1 or b4 or c5)then cm.cmdThrottle(1)aX=false;bN=false end end;if c8==0 and ps then if fL(g2,g3)==1 then fM(g2,g3)end;if fL(g4,g5)==1 then fM(g4,g5)end;if fL(g6,g7)==1 then fM(g6,g7)end;if fL(g8,g9)==1 then fM(g8,g9)end;if fL(ga,gb)==1 then fM(ga,gb)end;ps=false end end else pg()end;if warpdrive~=nil then if ie(warpdrive.getData()).destination~="Unknown"and ie(warpdrive.getData()).distance>400000 then warpdrive.show()pt=true else warpdrive.hide()pt=false end end end;function o4.OneSecondTick()local function pu()local jy=bF()local kW=cE;local pv=jy-iP;if kW>1.38889 then kW=kW/1000;local pw=kW*(jy-iP)bj=bj+pw;iM=iM+pw end;iN=iN+pv;bk=bk+pv;iP=jy end;local function px(jL)local py=0;iF=""local pz=iq;local pA=0;local pB=0;local pC=0;local jD=0;local jE=""local pD=b.getElementHitPointsById;local pE=b.getElementMaxHitPointsById;local pF={}for dC in pairs(ip)do local pG=0;local pH=0;pH=pE(ip[dC])pG=pD(ip[dC])pA=pA+pG;if pG<pH then if pG==0 then pC=pC+1 else pB=pB+1 end;if iQ and#pF==0 then fQ=vec3(b.getElementPositionById(ip[dC]))local hh=fQ.x;local hi=fQ.y;local hj=fQ.z;table.insert(pF,b.spawnArrowSticker(hh,hi,hj+1,"down"))table.insert(pF,b.spawnArrowSticker(hh,hi,hj+1,"down"))b.rotateSticker(pF[2],0,0,90)table.insert(pF,b.spawnArrowSticker(hh+1,hi,hj,"north"))table.insert(pF,b.spawnArrowSticker(hh+1,hi,hj,"north"))b.rotateSticker(pF[4],90,90,0)table.insert(pF,b.spawnArrowSticker(hh-1,hi,hj,"south"))table.insert(pF,b.spawnArrowSticker(hh-1,hi,hj,"south"))b.rotateSticker(pF[6],90,-90,0)table.insert(pF,b.spawnArrowSticker(hh,hi-1,hj,"east"))table.insert(pF,b.spawnArrowSticker(hh,hi-1,hj,"east"))b.rotateSticker(pF[8],90,0,90)table.insert(pF,b.spawnArrowSticker(hh,hi+1,hj,"west"))table.insert(pF,b.spawnArrowSticker(hh,hi+1,hj,"west"))b.rotateSticker(pF[10],-90,0,90)table.insert(pF,ip[dC])end elseif iQ and#pF>0 and pF[11]==ip[dC]then for jx in pairs(pF)do b.deleteSticker(pF[jx])end;pF={}end end;py=bG(pA/pz*100)if py<100 then jL[#jL+1]=gG(0,0,"","pbright txt")jD=bG(py*2.55)jE=db("rgb(%d,%d,%d)",255-jD,jD,0)if py<100 then jL[#jL+1]=gG("50%",1035,"Elemental Integrity: "..py.."%","txtbig txtmid","fill:"..jE)if pC>0 then jL[#jL+1]=gG("50%",1055,"Disabled Modules: "..pC.." Damaged Modules: "..pB,"txtbig txtmid","fill:"..jE)elseif pB>0 then jL[#jL+1]=gG("50%",1055,"Damaged Modules: "..pB,"txtbig txtmid","fill:"..jE)end end end end;local function pI()if id then if iG==nil and(d1~=nil or bi)then _autoconf.displayCategoryPanel(id,weapon_size,"Weapons","weapon",true)iG=_autoconf.panels[_autoconf.panels_size]elseif iG~=nil and d1==nil and not bi then gF(iG)iG=nil end end end;cW=b.getPlayersOnBoard()cX=b.getDockedConstructs()local jL={}pu()if s then px(jL)end;pI()ck.UpdatePipe()ck.ExtraData(jL)iO=table.concat(jL,"")end;function o4.AnimateTick()cr=true;cq=false;c0=0;c1=0;c.stopTimer("animateTick")end;function o4.MsgTick()local jL={}ck.DisplayMessage(jL,"empty")bV="empty"c.stopTimer("msgTick")bW=3 end;function o4.ButtonSetup()nE()nJ()is=it end;if pJ then for dC,dn in pairs(pJ)do o4[dC]=dn end end;return o4 end;local function pK(d,b,c,a,e,vBooster,hover,pL,antigrav,warpdrive,dbHud_1,radar_1,eR,bG,bH,ih,eM,bF,dc,ii,fL,ij,de,fO,fN,ik,df,im,io,pM,ie,db,fM)local pN={}local pO=false;local pP=0;local pQ=0;local pR=0;local pS=bF()local pT=0;local pU=0;local pV=0;local pW=0;local pX=false;local pY=false;local pZ=false;local p_=nil;local q0=0;local iC=55;local q1=nil;local q2=false;local q3=false;local q4=false;local q5=0;local q6=0;local q7=0;local q8=0;local q9=0;local qa={VectorToTarget=false}local qb=vec3(b.getConstructWorldOrientationUp())local qc=nil;local qd=0;local qe=-1;local qf=-1;local qg=false;local qh=false;local qi=0;local qj=false;local qk=false;local ql=false;local qm=false;local qn=""local qo=false;local qp=false;local qq=""local qr=false;local qs=0;local function qt(fi)local qu=bb;if not a_ then qu=0 end;if not c7 then return ci.computeDistanceAndTime(fi,qu,ca,0,0,bo-bd*ca)else if bq and bq>0 then return ci.computeDistanceAndTime(fi,qu,ca,0,0,bq-bd*ca)else return 0,0 end end end;local function qv(fi)local qu=bb;if not a_ then qu=0 end;return ci.computeDistanceAndTime(fi,qu,ca,d:maxForceForward(),a1,bo-bd*ca)end;local function qw(qx,qy,qz)qy=qy:project_on_plane(qx)qz=qz:project_on_plane(qx)return eM(qy:cross(qz):dot(qx),qy:dot(qz))end;local function qA()local function qB()local qC=-1;local qD=-1;if vBooster then qC=vBooster.getDistance()end;if hover then qD=hover.getDistance()end;if qC~=-1 and qD~=-1 then if qC<qD then return qC else return qD end elseif qC~=-1 then return qC elseif qD~=-1 then return qD else return-1 end end;local qE=qB()local qF=-1;if antigrav and antigrav.getState()==1 and not q and cE<iC then local qG=eR(c9-antigrav.getBaseAltitude())if qG<50 then return qG end end;if pL then qF=pL.getDistance()end;if qE~=-1 and qF~=-1 then if qE<qF then return qE else return qF end elseif qE~=-1 then return qE else return qF end end;local function qH(iZ,eD,qI)local function qJ(qK,dO)local eJ=vec3(dO)if qK.id==0 then return setmetatable({latitude=eJ.x,longitude=eJ.y,altitude=eJ.z,id=0,systemId=qK.systemId},dQ)end;local eK=eJ-qK.center;local c2=eK:len()local dW=c2-qK.radius;local dU=0;local dV=0;if not df(c2,0)then local eL=eM(eK.y,eK.x)dV=eL>=0 and eL or 2*math.pi+eL;dU=math.pi/2-math.acos(eK.z/c2)end;return setmetatable({latitude=math.deg(dU),longitude=math.deg(dV),altitude=dW,id=qK.id,systemId=qK.systemId},dQ)end;local qL=qJ(iZ,eD)qL="::pos{"..qL.systemId..","..qL.id..","..qL.latitude..","..qL.longitude..","..qL.altitude.."}"if qI then return qL else ql=qL;return true end end;local function qM(qN,qO,qP)local function qQ(qN,em)qN=vec3(qN)em=vec3(em):normalize()local dx=qN*em;return dx.x+dx.y+dx.z end;local qR=0.001;local qS=1;if not c7 or not ct or c6~=-1 or cE<iC then if qP==nil then qP=aO end;if qO==nil then qO=qR end;qN=vec3(qN):normalize()local qT=vec3()-qN;local qU=-qQ(qT,b.getConstructWorldOrientationRight())*qS;local qV=-qQ(qT,b.getConstructWorldOrientationUp())*qS;if pQ==0 then pQ=qU/2 end;if pR==0 then pR=qV/2 end;if eR(qU)<0.1 then q6=q6-qU*2 else q6=q6-(qU+(qU-pQ)*qP)end;if eR(qV)<0.1 then q5=q5+qV*2 else q5=q5+qV+(qV-pR)*qP end;pQ=qU;pR=qV;if eR(qU)<qO and eR(qV)<qO then return true end;return false elseif ct and c6==-1 then qN=cD;if qP==nil then qP=aO end;if qO==nil then qO=qR end;qN=vec3(qN):normalize()local qT=cA-qN;local qU=-qQ(qT,b.getConstructWorldOrientationRight())*qS;local qV=-qQ(qT,b.getConstructWorldOrientationUp())*qS;if pQ==0 then pQ=qU/2 end;if pR==0 then pR=qV/2 end;if eR(qU)<0.1 then q6=q6-qU*5 else q6=q6-(qU+(qU-pQ)*qP)end;if eR(qV)<0.1 then q5=q5+qV*5 else q5=q5+qV+(qV-pR)*qP end;pQ=qU;pR=qV;if eR(qU)<qO and eR(qV)<qO then return true end;return false end end;function pN.clearAll()b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"aY=false;aZ=false;cQ=nil;b1=false;b4=false;b2=false;aX=false;b3=false;b5=false;bT=false;q3=false;c3=false;c4=false;q4=false;cs=p;bm=false;b0=false;cb=false;bp=nil;bv=false;d4=false;d5=nil end;function pN.GetAutopilotBrakeDistanceAndTime(fi)return qt(fi)end;function pN.GetAutopilotTBBrakeDistanceAndTime(fi)return qv(fi)end;function pN.showWayPoint(iZ,eD,qI)return qH(iZ,eD,qI)end;function pN.APTick()local qW=a.getMouseWheel()if qW>0 then cm.changeSpd()elseif qW<0 then cm.changeSpd(true)else q2=true end;qi=ij()if ql then a.setWaypoint(ql)ql=false end;if qo then antigrav.setBaseAltitude(qo)qo=false end;if qm then fL(qm,qn)qm=false;qn=""end;if qe~=-1 then cm.cmdThrottle(qe,qg)qg=false;qe=-1 end;if qf~=-1 then cm.cmdCruise(qf,qg)qg=false;qf=-1 end;if qh then co.landingGear()qh=false end;if qp then cm.ToggleAutopilot()end end;function pN.ToggleIntoOrbit()cx=false;pV=nil;pW=nil;q0=0;if not c7 then if bv then fN("orOff","AP")bv=false;pX=false;p_=nil;cs=p;if b1 then b1=false;b3=false end;qa.VectorToTarget=false;qa.AutopilotAlign=false;pZ=false elseif cR then fN("orOn","AP")bv=true;cs=true;if p_==nil then p_=iZ end;if b1 then b1=false;b3=false end else bV="Unable to engage auto-orbit, not near a planet"end else bv=false;pX=false;p_=nil;cs=p;if b1 then b1=false end;qa.VectorToTarget=false;qa.AutopilotAlign=false;pZ=false end end;function pN.ToggleVerticalTakeoff()b1=false;if b5 then lt=true;b4=false;b3=false;b2=true;cs=true;bS=0;if c7 and c6==-1 then b2=false;b1=true;bS=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qf=bG(cu)end else cx=false;bi=false;d.control.retractLandingGears()ii:setTargetGroundAltitude(X)aX="VTO Takeoff"end;b5=not b5 end;function pN.checkLOS(qN)local ly,eB,eC=ch:getPlanetarySystem(0):castIntersections(cH,qN,function(ek)if ek.noAtmosphericDensityAltitude>0 then return ek.radius+ek.noAtmosphericDensityAltitude else return ek.radius+ek.surfaceMaxAltitude*1.5 end end)local lz=eB;if eC~=nil and eB~=nil then lz=math.min(eC,eB)end;if lz~=nil then return ly,lz else return nil,nil end end;function pN.ToggleAutopilot()local function qX(bt)cS=false;bm=not bm;if bm then b0=false;if not b1 and not bt then cm.ToggleAltitudeHold()end end;lC="Proceeding to Waypoint"end;local function qY(gr)if gr then for K,dC in pairs(cN)do if dC.name and dC.name==gr then return K end end else return 0 end end;local qZ=false;if bI-pU<1.5 and c7 then if not cz then if c7 then b6=iZ.spaceEngineMinAltitude-0.01*iZ.noAtmosphericDensityAltitude;fN("11","EP")pU=-1;if a_ or bm or bv then return end else bV="No space engines detected, Orbital Hop not supported"return end elseif iZ.hasAtmosphere then if c7 then b6=iZ.noAtmosphericDensityAltitude+T;fN("orH","OH")end;pU=-1;if a_ or bm or bv then return end end else pU=bI end;q_=false;if(bh>0 or#bB>0)and not a_ and not bm and not c4 and not bv then if 0.5*d:maxForceForward()/b.g()<ca then bV="WARNING: Heavy Loads may affect autopilot performance."bW=5 end;if#bB>0 and not c5 then bh=qY(bB[1])cl.UpdateAutopilotTarget()bV="Route Autopilot in Progress"local qT=fZ.position-cH;local r0=qT:project_on_plane(cF):len()if r0>50000 and fZ.planetname==iZ.name then qZ=true end end;cl.UpdateAutopilotTarget()cm.showWayPoint(b_,bg)if fZ~=nil then if fZ.agg and not q and antigrav then if not cJ then cm.ToggleAntigrav()end;br=fZ.agg end;bp=nil;bt=fZ.planetname=="Space"if bt then fN("apSpc","AP")if c7 then c4=true;cm.ToggleAltitudeHold()else a_=true end elseif iZ.name==fZ.planetname then lt=true;if c7 then if not bm then fN("vtt","AP")qX(bt)if qZ then b6=iZ.noAtmosphericDensityAltitude+T end end else fN("apOn","AP")if not(b_.name==iZ.name and c9<gi*1.5)then cx=false;a_=true elseif not c7 then if bv then cm.ToggleIntoOrbit()end;cw=iZ.noAtmosphericDensityAltitude+T;pZ=true;qa.AutopilotAlign=true;qa.VectorToTarget=true;pX=false;if not bv then cm.ToggleIntoOrbit()end end end else fN("apP","AP")aY=false;aZ=false;if c7 then c4=true;cm.ToggleAltitudeHold()else a_=true end end elseif not c7 then if fZ==nil and(b_.name==iZ.name and cR)and not bv then r1=false;cx=false;pX=false;cm.ToggleIntoOrbit()else fN("apP","AP")a_=true;aY=false;aZ=false;b8=false;bT=false;b1=false;b2=false;b4=false;b3=false;q3=false;bp=nil;r1=false end else fN("apP","AP")c4=true;cm.ToggleAltitudeHold()end;qp=false else fN("apOff","AP")cm.ResetAutopilots(1)if qp==2 then qp=true end end end;function pN.routeWP(r2,r3,r4)if r4 then if r4==1 then bB={}bB=ik(bB,bA)if#bB>0 then bV="Route Loaded"else bV="No Saved Route found on Databank"end;return bB else bA={}bA=ik(bA,bB)bV="Route Saved"pM()return end end;if r2 then return bB end;if r3 then bB={}bV="Current Route Cleared"else bB[#bB+1]=fZ.name;bV="Added "..fZ.name.." to route. "end;return bB end;function pN.cmdThrottle(dD,r5)if ii:getAxisCommandType(0)~=axisCommandType.byThrottle and not r5 then d.control.cancelCurrentControlMasterMode()end;ii:setThrottleCommand(axisCommandId.longitudinal,dD)bJ=dc(fO(dD*100,0)/100,-1,1)qc=nil end;function pN.cmdCruise(dD,r5)if ii:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r5 then d.control.cancelCurrentControlMasterMode()end;ii:setTargetSpeedCommand(axisCommandId.longitudinal,dD)qc=dD end;function pN.ToggleLockPitch()if bp==nil then fN("lkPOn","LP")if not bU then bp=cL else bp=Q end;b3=false;b1=false;b2=false else fN("lkPOff","LP")bp=nil end end;function pN.ToggleAltitudeHold()if bI-pT<1.5 then if iZ.hasAtmosphere then if c7 then b6=iZ.spaceEngineMinAltitude-0.01*iZ.noAtmosphericDensityAltitude;fN("11","EP")else if cR then b6=iZ.noAtmosphericDensityAltitude+T;cw=b6;pZ=true;if not bv then cm.ToggleIntoOrbit()end;pX=true end end;pT=-1;if b1 or bv or b5 then return end end else pT=bI end;if cR and not c7 then cw=c9;pZ=true;pX=true;cm.ToggleIntoOrbit()if bv then pT=bI else pT=0 end;return end;b1=not b1;b2=false;b4=false;if b1 then a_=false;aZ=false;aY=false;bT=false;cs=true;bp=nil;cx=false;if c6~=-1 and cE<20 then if bi then co.landingGear()end;fN("lfs","LS")b3=true;if pT>-1 then b6=c9+W end;aX="ATO Hold"ii:setTargetGroundAltitude(X)if aW and cI then cm.ToggleVerticalTakeoff()end else fN("altOn","AH")b3=false;if pT>-1 then if cR then b6=c9 end end;if b5 then cm.ToggleVerticalTakeoff()end end;if cJ and not q then local r6=antigrav.getBaseAltitude()if bm and fZ.agg and fZ.agg>c9 then b6=fZ.agg elseif b3 then b6=r6 end;if eR(c9-r6)<100 and cE<20 then b6=r6;aX="AGG Hold"qe=0 end end;if c4 then b6=200000 end else fN("altOff","AH")if bv then cm.ToggleIntoOrbit()end;if b5 then cm.ToggleVerticalTakeoff()end;cs=p;b3=false;bm=false;pT=0 end end;function pN.ResetAutopilots(pN)if pN then c4=false;a_=false;b8=false;q3=false;b6=c9;q_=false;d4=false;bc="Aligning"end;bm=false;b3=false;b4=false;aZ=false;b2=false;d5=nil;r7=false;cQ=nil;d4=false;if not cJ then b1=false;bp=nil end;if b5 then cm.ToggleVerticalTakeoff()end;if bv then cm.ToggleIntoOrbit()end;cs=p;c3=false;c5=false;bS=0 end;function pN.BrakeToggle(r8)if not aX then if r8 then aX=r8 else aX=true end else aX=false end;if b2 then b2=false;cs=p;d4=false end;if aX then fN("bkOn","B",1)cm.ResetAutopilots()else fN("bkOff","B",1)end end;function pN.BeginReentry()if b4 then bV="Re-Entry cancelled"fN("reOff","RE")b4=false;cs=p;b1=false elseif not iZ.hasAtmosphere then bV="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bW=5 elseif not q4 then b4=true;if ii:getAxisCommandType(0)~=r9.cruise then d.control.cancelCurrentControlMasterMode()end;cs=true;aX=false;bV="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cu;fN("par","RE")else b4=true;b1=true;cs=true;aX=false;b6=iZ.surfaceMaxAltitude+Z;if b6>iZ.spaceEngineMinAltitude then b6=iZ.spaceEngineMinAltitude-0.01*iZ.noAtmosphericDensityAltitude end;local ra=im(b6)bV="Beginning Re-entry.  Target speed: "..cu.." Target Altitude: "..ra;fN("glide","RE")qf=bG(cu)end;b3=false end;function pN.ToggleAntigrav()if antigrav and not q then if cJ then fN("aggOff","AG")antigrav.deactivate()antigrav.hide()else if br==nil then br=c9 end;if br<1000 then br=1000 end;fN("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pN.changeSpd(rb)local rc=1;if rb then rc=-1 end;if not bU then if t and not p5 and q2 then local rd=bJ;bJ=fO(dc(bJ+rc*aA/100,-1,1),2)if bJ>=0 and rd<0 then bJ=0;q2=false end elseif p5 then if c7 or b4 then cu=dc(cu+rc*aA,0,U)elseif a_ then _=dc(_+rc*aA/3.6*100,0,8333.00)end else ii:updateCommandFromActionStart(axisCommandId.longitudinal,rc*aA/10)end else if a_ or bm or c4 or bv then cV=cV+1*rc*-1;if cV>#cN then cV=1 end;if cV<1 then cV=#cN end else if not rb then rc=1 else rc=nil end;cl.adjustAutopilotTargetIndex(rc)end end end;function pN.TenthTick()local function re(oj,rf)if oj==nil then oj=b.g()end;oj=fO(oj,5)if rf~=nil and rf or(q1==nil or q1~=oj)then local fi=cC:len()local rg=ie(c.getData()).maxBrake;if rg~=nil and rg>0 and c7 then rg=rg/dc(fi/100,0.1,1)rg=rg/c8;if c8>0.10 then if bq then bq=(bq+rg)/2 else bq=rg end end end;if rg~=nil and rg>0 then bo=rg end;q1=oj end end;re(nil,true)if qc~=nil then if ii:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ii:getTargetSpeed(axisCommandId.longitudinal)~=qc then qf=qc else qc=nil end end end;function pN.SatNavTick()if not r then return end;qq=dbHud_1.getStringValue("SPBAutopilotTargetName")if qq~=nil and qq~=""and qq~="SatNavNotChanged"then local dx=ie(dbHud_1.getStringValue("SavedLocations"))if dx~=nil then bl=dx;local gp=-1;local gv;for dC,dn in pairs(bl)do if dn.name and dn.name=="SatNav Location"then gp=dC;break end end;if gp~=-1 then gv=bl[gp]gp=-1;for dC,dn in pairs(e[0])do if dn.name and dn.name=="SatNav Location"then gp=dC;break end end;if gp>-1 then e[0][gp]=gv end;cl.UpdateAtlasLocationsList()bV=gv.name.." position updated"end end;for K=1,#cN do if cN[K].name==qq then bh=K;a.print("Index = "..bh.." "..cN[K].name)cl.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pN.onFlush()local function rh(ri,rj)local rk=vec3()local rl=vec3()if ri==axisCommandId.longitudinal then rk=vec3(b.getConstructOrientationForward())rl=cA elseif ri==axisCommandId.vertical then rk=vec3(b.getConstructOrientationUp())rl=qb elseif ri==axisCommandId.lateral then rk=vec3(b.getConstructOrientationRight())rl=cB else return vec3()end;local rm=vec3(b.getWorldGravity())local rn=rm:dot(rl)local ro=vec3(b.getWorldAirFrictionAcceleration())local rp=ro:dot(rl)local rq=cC:dot(rk)local rr=rj*constants.kph2m;if rs==nil then rs=pid.new(10,0,10.0)end;rs:inject(rr-rq)local rt=rs:get()local ru=(rt-rp-rn)*rl;return ru end;local function rv(ri,rj)local rk=vec3()local rl=vec3()if ri==axisCommandId.longitudinal then rk=vec3(b.getConstructOrientationForward())rl=cA elseif ri==axisCommandId.vertical then rk=vec3(b.getConstructOrientationUp())rl=qb elseif ri==axisCommandId.lateral then rk=vec3(b.getConstructOrientationRight())rl=cB else return vec3()end;local rm=vec3(b.getWorldGravity())local rn=rm:dot(rl)local ro=vec3(b.getWorldAirFrictionAcceleration())local rp=ro:dot(rl)local rq=cC:dot(rk)local rr=rj*constants.kph2m;if rw==nil then rw=pid.new(10,0,10.0)end;rw:inject(rr-rq)local rt=rw:get()local ru=(rt-rp-rn)*rl;return ru end;local function rx(ry,jO,fV)local rz=ry:cross(fV):normalize_inplace()local kz=math.acos(dc(rz:dot(-jO),-1,1))*constants.rad2deg;if rz:cross(-jO):dot(fV)<0 then kz=-kz end;return kz end;local function rA()if cT and not b2 then local ek=cT[1]local hF,hG=cT[2],cT[3]local rB=math.min(hF,hG or hF)local rC=rB/cE;local rD=b3 and(cE<42 or c6~=-1)local rE=b1 or bm or bp or a_;if rE and not rD and(bY*1.5>rB or rC<1)then aX="Collision"bB={}qe=0;if b1 then cm.ToggleAltitudeHold()end;if bp then cm.ToggleLockPitch()end;bV="Autopilot Cancelled due to possible collision"a.print(ek.name.." COLLISION "..io(rC).." / "..im(rB,2))cm.ResetAutopilots(1)lt=true;if c7 then b2=true end;cs=true end;if rC<11 then cS=ek.name.." COLLISION "..io(rC).." / "..im(rB,2)else cS=ek.name.." collision "..io(rC)end;if rC<6 then fN("alarm","AL",2)end else cS=false end end;if antigrav and not q then if not cJ and antigrav.getBaseAltitude()~=br then qo=br end end;if d7 then d:setEngineForceCommand('hover',vec3(),1)d7=false end;cK=ii:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local rF=dc(bP+q5+a.getControlDeviceForwardInput(),-1,1)local rG=dc(bQ+q7+a.getControlDeviceYawInput(),-1,1)local rH=dc(bR+q6-a.getControlDeviceLeftRightInput(),-1,1)local rI=aX and 1 or 0;cF=vec3(b.getWorldVertical())if cF==nil or cF:len()==0 then cF=(iZ.center-cH):normalize()end;qb=vec3(b.getConstructWorldOrientationUp())cA=vec3(b.getConstructWorldOrientationForward())cB=vec3(b.getConstructWorldOrientationRight())cD=vec3(b.getWorldVelocity())cC=vec3(b.getVelocity())cH=vec3(b.getConstructWorldPos())ca=b.getConstructMass()cE=vec3(cD):len()cG=-cF:dot(cD)cM=getRoll(cF,cA,cB)local rJ=cM/180*math.pi;local rK=math.cos(rJ)local rL=math.sin(rJ)cL=rx(cF,cA,cB*rK+qb*rL)local rM=cD:normalize()local rN=eR(cM)local rO=utils.sign(cM)local rP=vec3(b.getWorldAngularVelocity())local rQ=rF*aK*cB+rG*aF*cA+rH*aL*qb;if cs==true and cF:len()>0.01 then local rR=eR(q8-cM)if((aZ or b4 or b2 or c3 or b1 or bv)and rR>0 or c7 and rR<aG and p)and rG==0 and eR(cL)<85 then local rS=q8;local rT=aE;if not c7 then rT=rT/4;q8=0;rS=0 end;if rU==nil then rU=pid.new(rT*0.01,0,rT*0.1)end;rU:inject(rS-cM)local rV=rU:get()rQ=rQ+rV*cA end end;local rW=1;local rX=0;local rY=1;bK=0;c7=false or c9<iZ.noAtmosphericDensityAltitude;c8=bH()c9=b.getAltitude()c6=qA()bI=bF()pS=bI;if bi and c6>-1 and c6-3<Y then if ii.targetGroundAltitudeActivated then ii:deactivateGroundEngineAltitudeStabilization()end end;if radar_1 then qr=not qr;if qr then cn.UpdateRadar()end;if E then rA()end end;if antigrav then cJ=antigrav.getState()==1 end;local rZ=1;local r_=1;local s0=bI-pS;local s1=-math.deg(qw(qb,cD,cA))local s2=math.deg(qw(cB,cD,cA))local gk=cF*-1;ct=c7 and s1<-L or s1>L or s2<-M or s2>M;local s3=a.getMouseDeltaX()local s4=a.getMouseDeltaY()if qs then local s5=bF()-qs;s3=s3*s5/0.016;s4=s4*s5/0.016 end;qs=bF()if o and not bU then s4=-s4 end;q6=0;q7=0;q5=0;fR=ch[0]iZ=fR:closestBody(b.getConstructWorldPos())s6=cj(iZ)fm=s6:orbitalParameters(b.getConstructWorldPos(),cD)if c9==0 then c9=(cH-iZ.center):len()-iZ.radius end;cR=c.getClosestPlanetInfluence()>0 or c9>0 and c9<200000;local oj=iZ:getGravity(b.getConstructWorldPos()):len()*ca;q8=0;local s7=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if qi==0 then if ih()==1 and bU then if not cq then c0=dc(c0+s3/2,-cc/2,cc/2)c1=dc(c1+s4/2,-cd/2,cd/2)end else c0=0;c1=0 end else c0=dc(c0+s3/2,-cc/2,cc/2)c1=dc(c1+s4/2,-cd/2,cd/2)d6=de(c0*c0+c1*c1)if not bU and ih()==0 then local kI,kJ=1,1;if bD=="SCOPE"then kI,kJ=cZ/90,cZ/90 end;if g=="virtual joystick"then if d6>au then q6=q6-dc(eR(c0)-au,0,cc/2)*utils.sign(c0)*aC*kI;q5=q5-dc(eR(c1)-au,0,cd/2)*utils.sign(c1)*aD*kJ end else c0=0;c1=0;if g=="mouse"then q5=(-utils.smoothstep(s4,-100,100)+0.5)*2*rZ;q6=(-utils.smoothstep(s3,-100,100)+0.5)*2*r_ end end end end;local s8=cE>8334;if cE>V/3.6 and not c7 and not a_ and not s8 then bV="Space Speed Engine Shutoff reached"qe=0 end;if not s8 and s9 then if not aX then cm.BrakeToggle()end;if a_ then cm.ResetAutopilots(1)end end;s9=s8;if c8>0.09 then if cE>cu/3.6 and not t and not pO then aX="SpdLmt"pO=true elseif not t and pO then if cE<cu/3.6 then aX=false;pO=false end end end;if aZ then if c3 then aX=false;local sa=false;if fZ and c3==true then sa=qM(fZ.position-cH,0.1)else sa=qM(vec3(cD),0.01)end;cs=true;if sa then qf=bG(cu)if(eR(cM)<2 or eR(cL)>85)and cE>=cu/3.6-1 then aX=false;aZ=false;if c3~=2 then q4=true end;if c3==true then c5=true end;c3=false;a_=false;cm.BeginReentry()end elseif c7 and t then qe=1 end elseif cE>iC then qM(vec3(cD),0.01)end end;if aY then if c7 then aY=false elseif cE>iC then qM(-vec3(cD))end end;if not aZ and c3 and not bv then if not c7 then if c3~=2 then q4=true end;cm.BeginReentry()c3=false;c5=true else c3=false;if not qp then qp=true end end end;if c5 and fZ and(c9<b6+250 and c9>b6-250)and cE*3.6>cu-250 and eR(cG)<25 and c8>=0.1 and(fZ.position-cH):len()>2000+c9 then if not qp then qp=true end;c5=false end;if b5 then cs=true;local sb=b6;if cG<-30 then bV="Unable to achieve lift. Safety Landing."bS=0;cs=p;b5=false;b2=true elseif not q and cJ or b6<iZ.spaceEngineMinAltitude then if cJ then sb=antigrav.getBaseAltitude()end;if c9<sb-100 then q9=0;bS=15;aX=false elseif cG>0 then aX="VTO Limit"bS=0 elseif cG<-30 then aX="VTO Fall"bS=15 elseif c9>=sb then if cJ then if a_ or bm then cm.ToggleVerticalTakeoff()else aX="VTO Complete"b5=false end;bV="Takeoff complete. Singularity engaged"fN("aggLk","AG")else aX=false;bV="VTO complete. Engaging Horizontal Flight"fN("vtoc","VT")cm.ToggleVerticalTakeoff()end;bS=0 end else if c8>0.08 then q9=0;aX=false;bS=20 elseif c8<0.08 and c7 then aX=false;if cy then q9=0;bS=20 else bS=0;q9=36;qf=3500 end else cs=p;bv=true;cx=false;sc=false;pX=false;pV=nil;pW=nil;if p_==nil then p_=iZ end;cw=sb;pZ=true;b5=false end end;if q9~=nil then if sd==nil then sd=pid.new(2*0.01,0,2*0.1)end;local se=dc(q9-cL,-M*0.80,M*0.80)sd:inject(se)local sf=dc(sd:get(),-1,1)q5=sf end end;if bv then local function sg()if fm.periapsis.altitude>=cw*0.99 and fm.apoapsis.altitude>=cw*0.99 and fm.periapsis.altitude<fm.apoapsis.altitude and fm.periapsis.altitude*1.05>=fm.apoapsis.altitude and eR(cw-c9)<1000 then return true else return false end end;local qT;local sh=false;local si=im(cw)if p_==nil then p_=iZ;if bm then p_=b_ end end;if not pZ then cw=bG(p_.radius+p_.surfaceMaxAltitude+T)if p_.hasAtmosphere then cw=bG(p_.radius+p_.noAtmosphericDensityAltitude+T)end;pZ=true end;if qa.VectorToTarget and fZ then qT=fZ.position-cH end;local sj,sk=cj(p_):escapeAndOrbitalSpeed((cH-p_.center):len()-p_.radius)local sl=cM;if not pX then local sm=false;local sn=false;qe=0;pW=0;cv="Aligning to orbital path - OrbitHeight: "..si;if qa.VectorToTarget then qM(qT:normalize():project_on_plane(cF))sh=cA:dot(qT:project_on_plane(qb):normalize())>0.95 else qM(cD)sh=s1<0.5;if cE<150 then sh=true end end;q5=0;pV=0;if cL<=pV+2 and cL>=pV-2 then sm=true else sm=false end;if sl<=pW+2 and sl>=pW-2 then sn=true else sn=false end;if sm and sn and sh then pV=nil;pW=nil;pX=true end else if qa.VectorToTarget then qM(qT:normalize():project_on_plane(cF))elseif cE>150 then qM(cD)end;q5=0;if qa.VectorToTarget and fZ then local bY,dH=ci.computeDistanceAndTime(cE,cu/3.6,ca,0,0,bo)if cx and qT:len()>15000+bY+c9 then cv="Orbiting to Target"if c9-100<=p_.noAtmosphericDensityAltitude or lA>fm.timeToPeriapsis and fm.periapsis.altitude<p_.noAtmosphericDensityAltitude or not sg()and fm.eccentricity>0.1 then bV="Re-Aligning Orbit"cx=false end elseif cx or qT:len()<15000+bY+c9 then bV="Orbit complete, proceeding with reentry"fN("orCom","OB")bg=fZ.position;q4=true;c5=true;qa.VectorToTarget,qa.AutopilotAlign=false,false;cm.ToggleIntoOrbit()cm.BeginReentry()return end end;if fm.periapsis~=nil and fm.apoapsis~=nil and fm.eccentricity<1 and c9>cw*0.9 and c9<cw*1.4 then if fm.apoapsis~=nil then if sg()or cx then if cx then aX=false;qe=0;pV=0;if not qa.VectorToTarget then bV="Orbit complete"fN("orCom","OB")cm.ToggleIntoOrbit()end else q0=q0+1;if q0>=2 then cx=true end end else cv="Adjusting Orbit - OrbitHeight: "..si;pY=true;qf=sk*3.6+1;local so=cw-c9;if sp==nil then sp=pid.new(0.1,0,1*0.1)end;sp:inject(so-cG*dc(utils.smoothstep(2000-so,-2000,2000)^6*10,1,10))pV=dc(sp:get(),-60,60)end end else local sq=2.75;local sr=eR(fO(sj*sq))local oy=sr%50;if oy>0 then sr=sr-oy+50 end;aX=false;if c9<cw*0.8 then cv="Escaping planet gravity - OrbitHeight: "..si;pV=utils.map(cG,200,0,-15,80)elseif c9>=cw*0.8 and c9<cw*1.15 then cv="Approaching orbital corridor - OrbitHeight: "..si;sr=sr*0.75;pV=utils.map(cG,100,-100,-15,65)elseif c9>=cw*1.15 and c9<cw*1.5 then cv="Approaching orbital corridor - OrbitHeight: "..si;sr=sr*0.75;if cG<0 or pY then pV=utils.map(c9,cw*1.5,cw*1.01,-30,0)else pV=utils.map(c9,cw*0.99,cw*1.5,0,30)end elseif c9>cw*1.5 then cv="Reentering orbital corridor - OrbitHeight: "..si;pV=-65;local ss=utils.map(cG,-150,-400,1,0.55)sr=sr*ss end;qf=bG(sr)end end;if pV~=nil then if st==nil then st=pid.new(1*0.01,0,5*0.1)end;local su=pV-cL;st:inject(su)local sv=dc(st:get(),-0.5,0.5)q5=sv end end;if a_ and not c7 and not c3 then local function sw(hU,fm)a.print(hU)aX=false;b9=false;a_=false;q_=false;bc="Aligning"qe=0;q3=false;bV=hU;fN("apCom","AP")if fm or c3 then if fm and gi~=nil and not c3 then if not c9 or c9==0 then return end;cw=c9;pZ=true end;cm.ToggleIntoOrbit()end end;local sx,sy=bg,false;if fZ and fZ.planetname~="Space"then b8=true;if not q_ then local sz=(fZ.position-b_.center):normalize()local sA=sz:project_on_plane((b_.center-cH):normalize()):normalize()local sB=b_.center+sA*(b_.radius+gi)local sC=fZ.position+(fZ.position-b_.center):normalize()*(gi-b_:getAltitude(fZ.position))if(cH-sB):len()<(cH-sC):len()then sx=sB else sx=sC;bb=0 end;bg=sx;cm.showWayPoint(b_,bg)sy=true;q_=true end;bd=0 elseif fZ and fZ.planetname=="Space"then if not q_ then bd=0;sy=true;b8=true;q_=true;sx=fZ.position+(cH-fZ.position):normalize()*R;bg=sx end elseif fZ==nil then bd=0;if not q_ then local sz=(cH+cD*100000-b_.center):normalize()local sA=sz:project_on_plane((b_.center-cH):normalize()):normalize()if sA:len()<1 then sz=(cH+cA*100000-b_.center):normalize()sA=sz:project_on_plane((b_.center-cH):normalize()):normalize()end;sx=b_.center+sA*(b_.radius+gi)bg=sx;q_=true;sy=true;b8=true;cm.showWayPoint(b_,bg)end end;pi=(vec3(sx)-cH):len()local ly,eB,eC=ch:getPlanetarySystem(0):castIntersections(cH,cD:normalize(),function(ek)if ek.noAtmosphericDensityAltitude>0 then return ek.radius+ek.noAtmosphericDensityAltitude else return ek.radius+ek.surfaceMaxAltitude*1.5 end end)local lz=eB;if eC~=nil and eB~=nil then lz=math.min(eC,eB)end;if lz~=nil and lz<pi and ly.name==b_.name then pi=lz end;local sa=true;local sD=(b_.center-(cH+vec3(cD):normalize()*pi)):len()-b_.radius;local ll=im(sD)qm=ga;qn='{"label": "Projected Altitude", "value": "'..ll..'"}'local bY,bZ;if not b0 then bY,bZ=qt(cE)else bY,bZ=qv(cE)end;if cE>50 and b7 then local qT=vec3(sx)-cH;local sE=dc(math.deg(qw(qb,cD:normalize(),qT:normalize()))*cE/500,-90,90)local sF=dc(math.deg(qw(cB,cD:normalize(),qT:normalize()))*cE/500,-90,90)if eR(sE)<20 and eR(sF)<20 then sE=sE*2;sF=sF*2 end;if eR(sE)<2 and eR(sF)<2 then sE=sE*2;sF=sF*2 end;local s1=-math.deg(qw(qb,cA,cD:normalize()))local s2=-math.deg(qw(cB,cA,cD:normalize()))if sG==nil then sG=pid.new(2*0.01,0,2*0.1)end;sG:inject(sF-s2)local sH=dc(sG:get(),-1,1)q5=q5+sH;if sI==nil then sI=pid.new(2*0.01,0,2*0.1)end;sI:inject(sE-s1)local sJ=dc(sI:get(),-1,1)q6=q6+sJ;sy=true;if eR(sE)>2 or eR(sF)>2 then if bc~="Adjusting Trajectory"then bc="Adjusting Trajectory"fN("apAdj","AP")end else if bc~="Accelerating"then bc="Accelerating"fN("apAcc","AP")end end elseif b7 and cE<=50 then qM((sx-cH):normalize())end;if sD<gi*1.5 then if fZ and fZ.planetname=="Space"then bb=0 elseif fZ==nil then dH,bb=cj(b_):escapeAndOrbitalSpeed(sD)end end;if a_ and not b7 and not ba and not b9 then local ly,lz=cm.checkLOS((bg-cH):normalize())if b_.name~=iZ.name then if ly~=nil and b_.name~=ly.name and lz<pi then bV="Collision with "..ly.name.." in "..im(lz).."\nClear LOS to continue."bW=5;qj=true else qj=false;bV=""end end end;if not qj then if not ba and not b9 and not sy then sa=qM((sx-cH):normalize())elseif b0 and(b9 or ba)then sa=qM(-vec3(cD):normalize())end end;if b7 then if not q3 then aX=false;qe=a0;bJ=fO(a0,2)q3=true end;local pj=c.getThrottle()if t then pj=bJ end;local sK=99999;local ow=-vec3(b.getWorldAcceleration()):dot(cD:normalize())local sL=dc(cD:dot((sx-cH):normalize()),0,cE)if sL>0 or ow>0 then sK=ci.computeTravelTime(sL,ow,pi-bY)end;if cC:len()>=_ or pj==0 and q3 or a1/4>sK then b7=false;if bc~="Cruising"then fN("apCru","AP")bc="Cruising"end;ba=true;qe=0 end;local sM=pi;if sM<=bY or H and cP<=bY+10000 and cO then if H and cP<=bY+10000 and cO then if cP<pP and cP>2000 then cm.ResetAutopilots(1)bV="Autopilot cancelled to prevent crossing PvP Line"aX="PvP Prevent"pP=cP else pP=cP;return end end;b7=false;if bc~="Braking"then fN("apBrk","AP")bc="Braking"end;b9=true;qe=0;q3=false end elseif b9 then if bc~="Orbiting to Target"then aX="AP Brk"end;if b0 then qe=1;qg=true end;local dH,sk=cj(b_):escapeAndOrbitalSpeed((cH-iZ.center):len()-iZ.radius)local qT;if fZ then qT=fZ.position-cH end;if fZ and fZ.planetname=="Space"and cE<50 then if#bB>0 then if not qp then table.remove(bB,1)end;if#bB>0 then aX=false;if not qp then qp=2 end;return end end;sw("Autopilot complete, arrived at space location")aX="Space Arrival"elseif fZ and fZ.planetname~="Space"and cE<=sk and(fm.apoapsis==nil or fm.periapsis==nil or fm.apoapsis.altitude<=0 or fm.periapsis.altitude<=0)then sw("Autopilot complete, commencing reentry")bg=fZ.position;c3=true;cm.showWayPoint(b_,bg)elseif(fZ and fZ.planetname~="Space"or fZ==nil)and fm.periapsis~=nil and fm.periapsis.altitude>0 and fm.eccentricity<1 or bc=="Circularizing"then if bc~="Circularizing"then fN("apCir","AP")bc="Circularizing"end;if cE<=sk then if fZ then if cD:normalize():dot(qT:normalize())>0.4 then if bc~="Orbiting to Target"then fN("apOrb","OB")bc="Orbiting to Target"end;if not r1 then aX=false;cm.showWayPoint(b_,fZ.position)r1=true end else sw("Autopilot complete, proceeding with reentry")bg=fZ.position;c3=true;cm.showWayPoint(b_,fZ.position)r1=false end else sw("Autopilot completed, setting orbit",true)aX=false end end elseif bc=="Circularizing"then sw("Autopilot complete, fixing Orbit",true)end elseif ba then local sM=pi;if sM<=bY or H and cP<=bY+10000 and cO then if H and cP<=bY+10000 and cO then if cP<pP and cP>2000 then if not qp then qp=true end;bV="Autopilot cancelled to prevent crossing PvP Line"aX="Prevent PvP"pP=cP else pP=cP;return end end;b7=false;if bc~="Braking"then fN("apBrk","AP")bc="Braking"end;b9=true end;local pj=c.getThrottle()if t then pj=bJ end;if pj>0 then b7=true;if bc~="Accelerating"then bc="Accelerating"fN("apAcc","AP")end;ba=false end else if sa then if not b8 and fZ==nil or not b8 and fZ and fZ.planetname~="Space"then if not c3 then bg=vec3(b_.center)+(gi+b_.radius)*cB;sN=qb;sO=cB end;b8=true elseif sa and not qj then b7=true;if bc~="Accelerating"then bc="Accelerating"fN("apAcc","AP")end;if not q3 then qe=a0;qg=true;bJ=fO(a0,2)q3=true;aX=false end end end end elseif a_ and(fZ~=nil and fZ.planetname~="Space"and c7)then bV="Autopilot complete, starting reentry"fN("apCom","AP")bg=fZ.position;aX=false;b9=false;a_=false;q_=false;bc="Aligning"qe=0;q3=false;aZ=true;c3=true;cm.showWayPoint(b_,fZ.position)end;if bT then cs=true;local sF=0;local fo=cH+vec3(c.getMasterPlayerRelativePosition())local sP=fo-cH;local sQ=vec3(sP):project_on(cA):len()local sR=vec3(sP):project_on(cB):len()local c2=de(sQ*sQ+sR*sR)qM(sP:normalize())local mF=40;local sS=c2<mF;local sT=100;local rj=dc((c2-mF)/2,10,sT)q5=0;local sa=eR(q6)<0.1;if sa and cE<rj and not sS then aX=false;sF=-20 else aX="Follow"sF=0 end;local sU=0;if eR(sF-cL)>sU then if sV==nil then sV=pid.new(2*0.01,0,2*0.1)end;sV:inject(sF-cL)local sH=sV:get()q5=sH end end;if b1 or b2 or b4 or bm or bp~=nil then local sW=bq;if sW then sW=sW*dc(cE/100,0.1,1)*c8 else sW=bo end;if not c7 then sW=bo end;qd=cA:project_on_plane(cF):normalize():dot(cD)if qd>100 then bY,bZ=ci.computeDistanceAndTime(qd,100,ca,0,0,sW)local sX,sY=ci.computeDistanceAndTime(100,0,ca,0,0,sW*0.55)bY=bY+sX else bY,bZ=ci.computeDistanceAndTime(qd,0,ca,0,0,sW*0.55)end;local so=b6-c9-cG;local sZ=200+cE;if b4 or c3 then s_=2000+cE end;local t0=1;if b3 then t0=dc(cE/100,0.1,1)end;local sF=(utils.smoothstep(so,-sZ,sZ)-0.5)*2*O*t0;if not b4 and not c3 and not bm and cA:dot(cD:normalize())<0.99 then sF=(utils.smoothstep(so,-sZ*dc(20-19*c8*10,1,20),sZ*dc(20-19*c8*10,1,20))-0.5)*2*O*dc(2-c8*10,1,2)*t0 end;if not b1 then sF=0 end;if bp~=nil then if cR and not bv then sF=bp else bp=nil end end;cs=true;local t1=q5;if b4 then local t2=bG(cu)local t3,t4=ci.computeDistanceAndTime(cE,t2/3.6,ca,0,0,bo-iZ.gravity*9.8*ca)t3=t3==-1 and 5000 or t3;local r0=c9-(iZ.noAtmosphericDensityAltitude+t3)local t5=c9>iZ.noAtmosphericDensityAltitude+t3*1.35;if t5 then sF=P;if cE<=t2/3.6 and cE>t2/3.6-10 and eR(cD:normalize():dot(cA))>0.9 and not cK then bN=false;qe=1 end elseif(cK or ii:getTargetSpeed(axisCommandId.longitudinal)~=t2)and not t5 and not c7 then qf=t2;qg=true end;if cK then if cE>t2/3.6 and not t5 then aX="Reentry Limit"else aX=false end else aX=false end;if cG>0 then aX="Reentry vSpd"end;if not q4 then sF=-80;if c9<iZ.surfaceMaxAltitude+(iZ.atmosphereThickness-iZ.surfaceMaxAltitude)*0.25 then bV="PARACHUTE DEPLOYED at "..fO(c9,0)b4=false;b2=true;lt=true;qe=0;sF=0;cs=p end elseif iZ.noAtmosphericDensityAltitude>0 and t5 then cs=true elseif not t5 then if not c7 and(cK or ii:getTargetSpeed(axisCommandId.longitudinal)~=t2)then qf=t2 end;if cE<t2/3.6+1 then aX=false;q4=false;b4=false;cs=true end end end;if cE>iC and not c4 and not bm and not b2 and u then qM(vec3(cD))end;if cQ or(bm or c4)and bh>0 and c7 then local qT;if cQ then if type(cQ)=="table"then qT=cQ elseif cQ<3 and cQ>0 then qT=-cF:cross(cD)*5000 elseif cQ>=3 then qT=cF:cross(cD)*5000 elseif cQ<0 then qT=cD*25000 end elseif fZ~=nil then qT=fZ.position-cH else qT=b_.center-cH end;local sE=math.deg(qw(cF:normalize(),cD,qT))*2;local mI=math.rad(eR(cM))if cE>aH and c7 then local t6=1000+cE;local t7=(utils.smoothstep(so-cG*10,-t6,t6)-0.5)*2*O;local t8=dc(90-t7,0,180)q8=dc(sE*2,-t8,t8)local t9=sE;sE=dc(dc(sE,-L*0.80,L*0.80)*math.cos(mI)+4*(cL-sF)*math.sin(math.rad(cM)),-L*0.80,L*0.80)local ta=1;if q8~=0 then ta=eR(mI/q8)end;ta=(90-dc(eR(q8-cM),0,90))/90;local tb=sF;if eR(cM)>90 then tb=-tb end;sF=ta*dc(dc(tb*math.cos(mI),-M*0.8,M*0.8)+eR(dc(eR(t9)*math.sin(mI),-M*0.80,M*0.80)),-M*0.80,M*0.80)else q8=0;sE=dc(sE,-L*0.80,L*0.80)end;local tc=s1-sE;if cQ and eR(tc)<=0.0001 and(type(cQ)=="table"or type(cQ)~="table"and cQ<0 and eR(cM)<1)then if cQ==-2 then cm.ToggleAltitudeHold()end;cQ=nil;fN("180Off","BR")return end;if not ct and cE>aH and c7 then if td==nil then td=pid.new(2*0.01,0,2*0.1)end;td:inject(tc)local sJ=dc(td:get(),-1,1)q6=q6+sJ elseif c7 and c6>-1 or cE<aH then qM(qT)elseif ct and c7 then if(s1<-L or s1>L)and c7 then qM(cD)end;if(s2<-M or s2>M)and c7 then sF=dc(cL-s2,cL-M*0.80,cL+M*0.80)end end;if fZ~=nil and not c4 then local sb=iZ:getAltitude(fZ.position)local r0=qT:project_on_plane(cF):len()lt=true;if not c4 and not b3 and not b4 and(r0<=bY and qT:len()<iZ.radius)and(cD:project_on_plane(cF):normalize():dot(qT:project_on_plane(cF):normalize())>0.99 or lC=="Finalizing Approach")then lC="Finalizing Approach"if#bB>0 then if not qp then table.remove(bB,1)end;if#bB>0 then if not qp then qp=2 end;return end end;qe=0;if b1 then cm.ToggleAltitudeHold()bm=true end;aX="AP Finalizing"elseif not b3 then aX=false end;if lC=="Finalizing Approach"and(qd<0.1 or r0<0.1 or te~=nil and te<r0)then fN("bklOn","BL")b2=true;d4=true;if fZ.heading then d5=fZ.heading else d5=nil end;bm=false;lC="Proceeding to Waypoint"cS=false end;te=r0 end elseif bm and not c7 and b6>iZ.noAtmosphericDensityAltitude and not(c4 or b4)then if fZ~=nil and b_.name==iZ.name then local qT=fZ.position-cH;local sb=iZ:getAltitude(fZ.position)local r0=de(qT:len()^2-(c9-sb)^2)local sW=bq;if sW then bY,bZ=ci.computeDistanceAndTime(cE,0,ca,0,0,sW/2)lt=true;if r0<=bY+cE*s0/2 and cD:project_on_plane(cF):normalize():dot(qT:project_on_plane(cF):normalize())>0.99 then if iZ.hasAtmosphere then aX=false;aZ=false;q4=true;c3=false;c5=true;a_=false;cm.BeginReentry()end end;te=r0 end end end;if not c7 and(b1 and b6>iZ.noAtmosphericDensityAltitude)and not(c4 or bv or b4)then if not cx and not bv then cw=b6;pZ=true;if bm then qa.VectorToTarget=true end;cm.ToggleIntoOrbit()bm=false;pX=true end end;if ct and c7 and c6==-1 and cE>aH and lC~="Finalizing Approach"then qM(cD)sF=dc(cL-s2,cL-M*0.80,cL+M*0.80)end;q5=t1;local qF=-1;if b2 then if not qk then if not cK then qe=0 end;ii:setTargetGroundAltitude(500)ii:activateGroundEngineAltitudeStabilization(500)bx=true;qk=true end;sF=0;local tf=false;local tg=math.abs(qd)if not q and cJ then tf=antigrav.getBaseAltitude()if tf<iZ.surfaceMaxAltitude and fZ==nil or fZ~=nil and iZ:getAltitude(fZ.position)>tf then tf=false end else tf=false end;if d5 then if tg<0.05 then if cG>-N then aX=false else aX="BL Align BLR"end;if qM(d5,0.001)then d5=nil;cs=p else q5=0;cs=true end else aX="BL Align Hzn"end;if tf and eR(c9-tf)<250 then aX="AGG Align"end else local th=false;local ti=30;if tg<10 and s7~=nil and s7>0 then local tj=dc(c8,0.4,2)local sW=bq*dc(cE/100,0.1,1)*tj;local tk=s7*tj+sW-oj;local tl=sW/2-oj;local tm=cE-de(eR(tl/2)*20/(0.5*ca))*utils.sign(tl)if tm<0 then tm=0 end;local tn;if cE>100 then local to,dH=ci.computeDistanceAndTime(cE,100,ca,0,0,sW)local tp,dH=ci.computeDistanceAndTime(100,0,ca,0,0,de(sW))tn=to+tp else tn=ci.computeDistanceAndTime(cE,0,ca,0,0,de(sW))end;if tn<20 then aX=false else local tq=0;if tm>100 then local tr,dH=ci.computeDistanceAndTime(tm,100,ca,0,0,tk)local ts,dH=ci.computeDistanceAndTime(100,0,ca,0,0,s7*tj+de(sW)-oj)tq=tr+ts else tq,dH=ci.computeDistanceAndTime(tm,0,ca,0,0,s7*tj+de(sW)-oj)end;tq=(tq+15+cE*s0)*1.1;local tt=d4 and fZ~=nil and iZ:getAltitude(fZ.position)>0 and fZ.safe;local sb=nil;if tf and tf<c9 then sb=tf elseif tt then sb=iZ:getAltitude(fZ.position)+250 elseif c9>iZ.surfaceMaxAltitude then sb=iZ.surfaceMaxAltitude end;if cT then local tu=iZ:getAltitude(cT[1].center)if sb then if tu>sb then sb=tu end else sb=tu end end;if sb~=nil then local tv=c9-sb;th=true;if tv<=tq or tq==-1 or tg>0.05 and d4 then if tg>0.05 and d4 then aX="BL AP Hzn"else aX="BL Stop Dist"end else aX=false end end end end;qF=c6;if qF>-1 then if(cE<1 or cD:normalize():dot(cF)<0)and not d5 then b2=false;b1=false;if not tf then qh=true;ii:setTargetGroundAltitude(Y)end;bS=0;aX="BL Complete"cs=p;d4=false else aX="BL Slowing"end elseif not th then if lt and cD:normalize():dot(-gk)<0.999 then aX="BL Strong"qM()elseif tg>10 or tg>0.05 and d4 then aX="BL hSpd"elseif cG<-N then aX="BL BLR"else aX=false end end end else qk=false end;if b3 or c4 then local ly,eC,eB;if bg~=nil then ly,eC,eB=ch:getPlanetarySystem(0):castIntersections(cH,(bg-cH):normalize(),function(ek)return ek.radius+ek.noAtmosphericDensityAltitude end)end;if cJ and not c4 then if c9>=b6-50 and cE>iC then b3=false;if not a_ and not bm then aX="ATO Agg Arrive"qe=0 end end elseif eR(sF)<15 and c9/b6>0.75 then b3=false;if not c4 then if cK and not t then d.control.cancelCurrentControlMasterMode()end elseif c4 and cE<iC then a_=true;c4=false;b1=false;b3=false;qe=0 elseif c4 then qe=0;aX="ATO Space"end elseif c4 and not c7 and b_~=nil and(ly==nil or ly.name==b_.name)then a_=true;c4=false;b1=false;b3=false;if not cK then qe=0 end;b7=true end end;local tw=c6>-1;local tx=cL;if(bm or c4 or cQ)and not tw and cE>aH and c7 then local mI=math.rad(eR(cM))tx=cL*eR(math.cos(mI))+s2*math.sin(mI)end;local ty=dc(sF-tx,-M*0.80,M*0.80)if not c7 and bm then ty=dc(sF-tx,-85,O)elseif not c7 then ty=dc(sF-tx,-O,O)end;if eR(cM)<5 or bm or cQ or b2 or tw or b1 then if sV==nil then sV=pid.new(5*0.01,0,5*0.1)end;sV:inject(ty)local sH=sV:get()q5=q5+sH end end;if antigrav~=nil and(antigrav and not q and c9<200000)then if br==nil or br<1000 then br=1000 end;if tz~=br then tz=br;qo=tz end end;if c7 and t and cK then if tA==nil then tA=pid.new(0.1,0,1)end;local tB=0;if aQ>0 and not b4 and c8>0.005 and c8<0.1 and cG>-50 then tB=(0.1-c8)*cu*aQ end;tA:inject(cu/3.6+tB-cD:dot(cA))local tC=tA:get()bM=dc(tC,-1,1)if not d0 then if bM<bJ and c8>0.005 then bL=true;d0=dc(bM,0.01,1)else bL=false;d0=bJ end end;if tD==nil then tD=pid.new(1*0.01,0,1*0.1)end;tD:inject(cD:len()-cu/3.6-tB)local tE=dc(tD:get(),0,1)if c7 and cG<-80 or c8>0.005 then bK=tE end;if bK>0 then if bL and bM==0.01 and not d0 then d0=0 end else bM=dc(bM,0.01,1)end;local tF=''local tG=vec3()local tH=rh(axisCommandId.vertical,bS*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tH,rX)local tI='thrust analog longitudinal 'if by=="All"or by=="Longitude"then tI=tI..aR end;local tJ=ii:getAxisCommandType(axisCommandId.longitudinal)local tK=ii:composeAxisAccelerationFromThrottle(tI,axisCommandId.longitudinal)local tL=rv(axisCommandId.lateral,bu*1000)tF=tF..' , '.."lateral airfoil , lateral ground "tG=tG+tL;if tG:len()>constants.epsilon then d:setEngineForceCommand(tF,tG,rX,'','','',rY)end;d:setEngineForceCommand(tI,tK,rW)local tM='thrust analog vertical fueled 'local tN='thrust analog lateral fueled 'if by=="All"or by=="Lateral"then tN=tN..aS end;if by=="All"or by=="Vertical"then tM=tM..aT end;if bS~=0 or b2 and aX or not bi and not bx then d:setEngineForceCommand(tM,tH,rW)else d:setEngineForceCommand(tM,vec3(),rW)end;if bu~=0 then d:setEngineForceCommand(tN,tL,rW)else d:setEngineForceCommand(tN,vec3(),rW)end;if rI==0 then rI=bK end;local tO=-rI*(aM*cD+aN*rM)d:setEngineForceCommand('brake',tO)else if t then if not d0 then d0=bJ end end;local rj=c.getAxisCommandValue(0)if not cK then if tD==nil then tD=pid.new(1*0.01,0,1*0.1)end;tD:inject(cD:len()-rj/3.6)local tE=dc(tD:get(),0,1)rI=dc(rI+tE,0,1)end;local tO=-rI*(aM*cD+aN*rM)d:setEngineForceCommand('brake',tO)local tF=''local tG=vec3()local tP=false;local tI='thrust analog longitudinal 'if by=="All"or by=="Longitude"then tI=tI..aR end;local tJ=ii:getAxisCommandType(axisCommandId.longitudinal)if tJ==axisCommandType.byThrottle then local tK=ii:composeAxisAccelerationFromThrottle(tI,axisCommandId.longitudinal)d:setEngineForceCommand(tI,tK,rW)elseif tJ==axisCommandType.byTargetSpeed then local tK=ii:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tF=tF..' , '..tI;tG=tG+tK;if ii:getTargetSpeed(axisCommandId.longitudinal)==0 or ii:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ii:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tP=true end end;local tN='thrust analog lateral 'if by=="All"or by=="Lateral"then tN=tN..aS end;local tQ=ii:getAxisCommandType(axisCommandId.lateral)if tQ==axisCommandType.byThrottle then local tR=ii:composeAxisAccelerationFromThrottle(tN,axisCommandId.lateral)d:setEngineForceCommand(tN,tR,rW)elseif tQ==axisCommandType.byTargetSpeed then local tL=ii:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tF=tF..' , '..tN;tG=tG+tL end;local tM='thrust analog vertical 'if by=="All"or by=="Vertical"then tM=tM..aT end;local tS=ii:getAxisCommandType(axisCommandId.vertical)if tS==axisCommandType.byThrottle then local tH=ii:composeAxisAccelerationFromThrottle(tM,axisCommandId.vertical)if bS~=0 or b2 and aX then d:setEngineForceCommand(tM,tH,rW,'airfoil','ground','',rY)else d:setEngineForceCommand(tM,vec3(),rW)d:setEngineForceCommand('airfoil vertical',tH,rW,'airfoil','','',rY)d:setEngineForceCommand('ground vertical',tH,rW,'ground','','',rY)end elseif tS==axisCommandType.byTargetSpeed then if bS<0 then d:setEngineForceCommand('hover',vec3(),rW)end;local tT=ii:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tF=tF..' , '..tM;tG=tG+tT end;if tG:len()>constants.epsilon then if rI~=0 or tP or eR(rM:dot(cA))<0.5 then tF=tF..', brake'end;d:setEngineForceCommand(tF,tG,rX,'','','',rY)end end;local tU=aJ*(rQ-rP)local tV=vec3(b.getWorldAirFrictionAngularAcceleration())tU=tU-tV;d:setEngineTorqueCommand('torque',tU,rW,'airfoil','','',rY)d:setBoosterCommand('rocket_engine')if bX and not n then local fi=cC:len()local tW=0.15;if not cK then local tX=ii:getTargetSpeed(axisCommandId.longitudinal)if fi*3.6>tX*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fi*3.6<tX*(1-tW)and not tY then tY=true;d:toggleBoosters()end else local pj=c.getThrottle()if t then pj=bJ*100 end;local rj=pj/100;if bH==0 then rj=rj*_;if fi>=rj*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fi<rj*(1-tW)and not tY then tY=true;d:toggleBoosters()end else local t2=bG(cu)rj=rj*t2/3.6;if fi>=rj*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fi<rj*(1-tW)and not tY then tY=true;d:toggleBoosters()end end end end end;if tZ then for dC,dn in pairs(tZ)do pN[dC]=dn end end;c6=qA()return pN end;local function t_(d,b,c,a,e,vBooster,hover,antigrav,d8,dbHud_2,gyro,u0,ih,ii,ij,u1,gF,fO,dX,dd,dc,fN,il,pM)local u2={}local u3=true;local u4=5;local u5=5;local u6=u4;local u7=u5;local u8=bI;function u2.landingGear()bi=not bi;if bi then bm=false;bp=nil;cm.cmdThrottle(0)if vBooster or hover then if c7 and c6==-1 then fN("bklOn","BL")lt=true;b4=false;b3=false;b5=false;b1=false;if b2 then d4=not d4 end;b2=true;cs=true;bi=false else if bO then fN("grOut","LG",1)d.control.extendLandingGears()end;d4=false;ii:setTargetGroundAltitude(Y)if c7 then aX="Landing"end end end;if bO and not b2 and not(vBooster or hover)then fN("grOut","LG",1)d.control.extendLandingGears()end else if bO then fN("grIn","LG",1)d.control.retractLandingGears()end;ii:activateGroundEngineAltitudeStabilization(u9)if bx then ii:setTargetGroundAltitude(X)end end end;function u2.startControl(ua)local function ub(rb)local rc=1;local function uc(ud,rb)local ue={iZ.surfaceMaxAltitude+100,iZ.spaceEngineMinAltitude-0.01*iZ.noAtmosphericDensityAltitude,iZ.noAtmosphericDensityAltitude+T,iZ.radius*(S-1)+iZ.noAtmosphericDensityAltitude}local uf=ud;for dH,dn in ipairs(ue)do if rb and uf>dn then ud=dn elseif ud<dn and not rb then ud=dn;break end end;return ud end;if rb then rc=-1 end;if not q and cJ then if bU and rb then br=1000 elseif br~=nil then br=br+rc*u5;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end else br=tz+rc*100 end elseif b1 or b5 or bv then if bv then if bU then cw=uc(cw,rb)else cw=cw+rc*u4 end;if cw<iZ.noAtmosphericDensityAltitude then cw=iZ.noAtmosphericDensityAltitude end else if bU and c7 then b6=uc(b6,rb)else b6=b6+rc*u4 end end else if not rb and c6-3<Y and c9>0 and bi then co.landingGear()end;ii:updateTargetGroundAltitudeFromActionStart(rc*1.0)end end;local function ug(uh)if not c7 then bV="Flight Assist in Atmo only"return end;local dk=type(uh)if cQ==nil then if dk=="table"then if a_ or bm then cm.ToggleAutopilot()end;fN("180On","BR")elseif uh==1 then fN("bnkLft","BR")else fN("bnkRht","BR")end;if not b1 and not a_ and not bm then cm.ToggleAltitudeHold()if dk~="table"then uh=uh+1 end end;cQ=uh else fN("180Off","BR")cQ=nil end end;if ua=="gear"then co.landingGear()elseif ua=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ua=="forward"then bP=bP-1 elseif ua=="backward"then if p5 then ug(-cD*5000)else bP=bP+1 end elseif ua=="left"then if p5 then ug(1)else bQ=bQ-1 end elseif ua=="right"then if p5 then ug(3)else bQ=bQ+1 end elseif ua=="yawright"then bR=bR-1;d5=nil elseif ua=="yawleft"then bR=bR+1;d5=nil elseif ua=="straferight"then ii:updateCommandFromActionStart(axisCommandId.lateral,1.0)bu=1 elseif ua=="strafeleft"then ii:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bu=-1 elseif ua=="up"then bS=bS+1;if c6-3<Y and c9>0 and bi then co.landingGear()end;ii:deactivateGroundEngineAltitudeStabilization()ii:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ua=="down"then bS=bS-1;ii:deactivateGroundEngineAltitudeStabilization()ii:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ua=="groundaltitudeup"then ub()elseif ua=="groundaltitudedown"then ub(true)elseif ua=="option1"then ui=false;if p5 and bU then local uj=""for K=1,#cW do uj=uj.."| Name: "..a.getPlayerName(cW[K]).." Mass: "..fO(b.getBoardedPlayerMass(cW[K])/1000,1).."t "end;a.print("Onboard: "..uj)return end;cl.adjustAutopilotTargetIndex()elseif ua=="option2"then ui=false;if p5 and bU then for K=1,#cW do b.forceDeboard(cW[K])end;bV="Deboarded All Passengers"return end;cl.adjustAutopilotTargetIndex(1)elseif ua=="option3"then local function uk()u3=not u3;if not u3 then fN("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(ul,atmofueltank_size,"Atmo Fuel","fuel_container")um=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(un,spacefueltank_size,"Space Fuel","fuel_container")uo=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(up,rocketfueltank_size,"Rocket Fuel","fuel_container")uq=_autoconf.panels[_autoconf.panels_size]end;ur=a.createWidgetPanel("Docking")us=a.createWidget(ur,"parenting")a.addDataToWidget(c.getDataId(),us)ut=a.createWidgetPanel("Core combat stress")uu=a.createWidget(ut,"core_stress")a.addDataToWidget(b.getDataId(),uu)if d8~=nil then d8.show()end else fN("hud","DH")c.hide()b.hide()if um~=nil then gF(um)um=nil end;if ur~=nil then gF(ur)ur=nil end;if ut~=nil then gF(ut)ut=nil end;if uo~=nil then gF(uo)uo=nil end;if uq~=nil then gF(uq)uq=nil end;if d8~=nil then d8.hide()end end end;ui=false;if p5 and bU then local uj=""for K=1,#cX do uj=uj.."| ID: "..cX[K].." Mass: "..fO(b.getDockedConstructMass(cX[K])/1000,1).."t "end;a.print("Docked Ships: "..uj)return end;if x then if w then w=false else w=true end end;uk()elseif ua=="option4"then ui=false;if p5 and bU then for K=1,#cX do b.forceUndock(cX[K])end;bV="Undocked all ships"return end;cQ=nil;cm.ToggleAutopilot()elseif ua=="option5"then ui=false;cm.ToggleLockPitch()elseif ua=="option6"then ui=false;if p5 and bU then if d8 then cp.ventShield()else bV="No shield found"end;return end;cm.ToggleAltitudeHold()elseif ua=="option7"then ui=false;if p5 and bU then if d8 then d8.toggle()return else bV="No shield found"return end end;E=not E;if E then bV="Collision System Enabled"else bV="Collision System Secured"end elseif ua=="option8"then ui=false;if p5 and bU then if bh>0 and fZ~=nil then cm.routeWP()else bV="Select a saved wp on IPH to add to or remove from route"end;return end;bx=not bx;if not bx then bV="DeCoupled Mode - Ground Stabilization off"ii:deactivateGroundEngineAltitudeStabilization()fN("gsOff","GS")else bV="Coupled Mode - Ground Stabilization on"ii:activateGroundEngineAltitudeStabilization(u9)d7=true;fN("gsOn","GS")end elseif ua=="option9"then ui=false;if p5 and bU then ii:resetCommand(axisCommandId.longitudinal)ii:resetCommand(axisCommandId.lateral)ii:resetCommand(axisCommandId.vertical)cm.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cb=gyro.getState()==1;if cb then fN("gyOn","GA")else fN("gyOff","GA")end else bV="No gyro found"end elseif ua=="lshift"then cU=false;if p5 then bU=true end;if ij()==1 then bU=true;be=ij()u1(1)elseif ih()==1 and y then bU=true;cr=false;cq=false end elseif ua=="brake"then if aV or p5 then cm.BrakeToggle("Manual")elseif not aX then cm.BrakeToggle("Manual")else aX="Manual"end elseif ua=="lalt"then ui=true;p5=true;if ih()==0 and not i and g=="keyboard"then u1(1)end elseif ua=="booster"then if n then d:toggleBoosters()elseif not bX then if not tY then d:toggleBoosters()tY=true end;bX=true else if tY then d:toggleBoosters()tY=false end;bX=false end elseif ua=="stopengines"then local function uv()if bI-u8<1.5 then fN("clear","CA")cm.clearAll()end end;uv()u8=bI;if ii:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bJ~=0 then ii:resetCommand(axisCommandId.longitudinal)cm.cmdThrottle(0)else cm.cmdThrottle(100)end else if ii:getTargetSpeed(axisCommandId.longitudinal)~=0 then ii:resetCommand(axisCommandId.longitudinal)else if c7 then cm.cmdCruise(U)else cm.cmdCruise(_*3.6)end end end elseif ua=="speedup"then cm.changeSpd()elseif ua=="speeddown"then cm.changeSpd(true)elseif ua=="antigravity"and not q then if antigrav~=nil then cm.ToggleAntigrav()else bV="No antigrav found"end end end;function u2.stopControl(ua)local function uw()if not q and cJ then u7=u5 end;if b1 or b5 or bv then u6=u4 end end;if ua=="forward"then bP=0 elseif ua=="backward"then bP=0 elseif ua=="left"then if cQ then if cQ==2 then cQ=-2 else cQ=-1 end end;bQ=0 elseif ua=="right"then if cQ then if cQ==4 then cQ=-2 else cQ=-1 end end;bQ=0 elseif ua=="yawright"then bR=0 elseif ua=="yawleft"then bR=0 elseif ua=="straferight"then ii:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bu=0 elseif ua=="strafeleft"then ii:updateCommandFromActionStop(axisCommandId.lateral,1.0)bu=0 elseif ua=="up"then bS=0;ii:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bx then ii:activateGroundEngineAltitudeStabilization(u9)d7=true end elseif ua=="down"then bS=0;ii:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bx then ii:activateGroundEngineAltitudeStabilization(u9)d7=true end elseif ua=="groundaltitudeup"then uw()ui=false elseif ua=="groundaltitudedown"then uw()ui=false elseif ua=="lshift"then if ij()==1 then c0=0;c1=0;u1(be)elseif ih()==1 and y then cr=false;cq=false end;bU=false elseif ua=="brake"then if not aV and not p5 then if aX then cm.BrakeToggle()else aX=false end end elseif ua=="lalt"then if ih()==0 and i then if ui then if ij()==1 then u1(0)else u1(1)end else ui=true end elseif ih()==0 and not i and g=="keyboard"then u1(0)end;p5=false end end;function u2.loopControl(ua)local function ux(rb)local rc=1;if rb then rc=-1 end;if not q and cJ then if br~=nil then br=br+rc*u7;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end;u7=dc(u7*1.05,u5,50)else br=tz+rc*100 end elseif b1 or b5 or bv then if bv then cw=cw+rc*u6;if cw<iZ.noAtmosphericDensityAltitude then cw=iZ.noAtmosphericDensityAltitude end else b6=b6+rc*u6 end;u6=dc(u6*1.05,u4,50)else ii:updateTargetGroundAltitudeFromActionLoop(rc*1.0)end end;local function uy(rb)local rc=1;if rb then rc=-1 end;if not bU then if t and not p5 then bJ=dc(bJ+rc*aB/100,-1,1)else ii:updateCommandFromActionLoop(axisCommandId.longitudinal,rc*aB)end end end;if ua=="groundaltitudeup"then if not bU then ux()end elseif ua=="groundaltitudedown"then if not bU then ux(true)end elseif ua=="speedup"then uy()elseif ua=="speeddown"then uy(true)end end;function u2.inputTextControl(ra)local function uz(uA,fo,gs)local function uB(fo)local du=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dv='::pos{'..du..','..du..','..du..','..du..','..du..'}'local dL,dM,dU,dV,dW=dX(fo,dv)if dL=="0"and dM=="0"then return vec3(dd(dU),dd(dV),dd(dW))end;dV=math.rad(dV)dU=math.rad(dU)local iZ=e[dd(dL)][dd(dM)]local eN=math.cos(dU)local uC=vec3(eN*math.cos(dV),eN*math.sin(dV),math.sin(dU))return iZ.center+(iZ.radius+dW)*uC end;local fQ=uB(fo)return cl.AddNewLocation(uA,fQ,gs)end;local K;local uD,i5=nil,nil;local uE="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(ra," ")uD=ra;if K~=nil then uD=string.sub(ra,0,K-1)i5=string.sub(ra,K+1)end;if uD=="/help"or uD=="/commands"then for lu in string.gmatch(uE,"([^\n]+)")do a.print(lu)end;return elseif uD=="/setname"then if i5==nil or i5==""then bV="Usage: ah-setname Newname"return end;if bh>0 and fZ~=nil then cl.UpdatePosition(i5)else bV="Select a saved target to rename first"end elseif d8 and uD=="/resist"then cp.setResist(i5)elseif uD=="/addlocation"or string.find(ra,"::pos")~=nil then local gs=false;local uA="0-Temp"if i5==nil or i5==""or uD~="/addlocation"then i5=uD;gs=true end;K=string.find(i5,"::")if not gs then uA=string.sub(i5,1,K-2)end;local fo=string.sub(i5,K)uz(uA,fo,gs)elseif uD=="/agg"then if i5==nil or i5==""then bV="Usage: /agg targetheight"return end;i5=dd(i5)if i5<1000 then i5=1000 end;br=i5;bV="AGG Target Height set to "..i5 elseif uD=="/G"then if i5==nil or i5==""then bV="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if i5=="dump"then for dC,dn in pairs(il())do if type(dn.get())=="boolean"then if dn.get()==true then a.print(dC.." true")else a.print(dC.." false")end elseif dn.get()==nil then a.print(dC.." nil")else a.print(dC.." "..dn.get())end end;return end;K=string.find(i5," ")local uF=string.sub(i5,0,K-1)local uG=string.sub(i5,K+1)for dC,dn in pairs(il())do if dC==uF then bV="Variable "..uF.." changed to "..uG;local uH=type(dn.get())if uH=="number"then uG=dd(uG)if dC=="AtmoSpeedLimit"then cu=uG end elseif uH=="boolean"then if string.lower(uG)=="true"then uG=true else uG=false end end;dn.set(uG)return end end;bV="No such global variable: "..uF elseif uD=="/deletewp"then if bh>0 and fZ~=nil then cl.ClearCurrentPosition()else bV="Select a custom wp to delete first in IPH"end elseif uD=="/copydatabank"then if dbHud_2 then pM(true)else bV="Spare Databank required to copy databank"end elseif uD=="/iphWP"then if bh>0 then a.print(cm.showWayPoint(b_,bg,true))a.print(json.encode(bg))bV="::pos waypoint shown in lua chat in local and world format"else bV="No target selected in IPH"end elseif uD=="/createPrivate"then local uI="privatelocations = {\n"local uJ=""if#d2>0 then for dC,dn in pairs(d2)do uI=uI.."{position = {x = "..dn.position.x..", y = "..dn.position.y..", z = "..dn.position.z.."},\n ".."name = '"..dn.name.."',\n planetname = '"..dn.planetname.."',\n gravity = "..dn.gravity..",\n"if dn.heading then uI=uI.."heading = {x = "..dn.heading.x..", y = "..dn.heading.y..", z = "..dn.heading.z.."},\n"end;if dn.safe then uI=uI.."safe = true},\n"else uI=uI.."safe = false},\n"end end end;uJ=#d2 .."-Private "if i5=="all"then for dC,dn in pairs(bl)do uI=uI.."{position = {x = "..dn.position.x..", y = "..dn.position.y..", z = "..dn.position.z.."},\n ".."name = '*"..dn.name.."',\n planetname = '"..dn.planetname.."',\n gravity = "..dn.gravity..",\n"if dn.heading then uI=uI.."heading = {x = "..dn.heading.x..", y = "..dn.heading.y..", z = "..dn.heading.z.."},\n"end;if dn.safe then uI=uI.." safe = true},\n"else uI=uI.."safe = false},\n"end end;uJ=uJ..#bl.."-Public "end;uI=uI.."}\n return privatelocations"if u0 then u0.setHTML(uI)end;bV=uJ.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bW=7 end end;function u2.tagTick()if by=="Off"then by="All"elseif by=="All"then by="Longitude"elseif by=="Longitude"then by="Lateral"elseif by=="Lateral"then by="Vertical"else by="Off"end;bV="Extra Engine Tags: "..by;c.stopTimer("tagTick")end;if uK then for dC,dn in pairs(uK)do u2[dC]=dn end end;return u2 end;local function uL(d,b,c,a,library,e,vBooster,hover,pL,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,d8,gyro,warpdrive,id,u0)local uM={}local db=string.format;local ie=json.decode;local uN=json.encode;local pE=b.getElementMaxHitPointsById;local ig=b.getElementMassById;local ih=d.control.isRemoteControlled;local dX=string.match;local gF=a.destroyWidgetPanel;local fL=a.updateData;local fM=a.addDataToWidget;local u1=a.lockView;local ij=a.isViewLocked;local de=math.sqrt;local dd=tonumber;local eR=math.abs;local bG=math.floor;local bH=c.getAtmosphereDensity;local eM=math.atan;local bF=a.getTime;local dc=utils.clamp;local ii=d.axisCommandManager;local uO=Y;local gH=13;local ip=b.getElementIdList()local iq=0;local function df(eu,ev)if eu==0 then return eR(ev)<1e-09 end;if ev==0 then return eR(eu)<1e-09 end;return eR(eu-ev)<math.max(eR(eu),eR(ev))*dt end;local function fO(du,uP)local rc=10^(uP or 0)return bG(du*rc+0.5)/rc end;local function ik(uQ,uR)for dC,dn in pairs(uR)do if type(dC)=="string"then uQ[dC]=dn else uQ[#uQ+1]=uR[dC]end end;return uQ end;local function il(uS)local uT={}if not uS then ik(uT,J)ik(uT,a8)ik(uT,az)ik(uT,aU)return uT elseif uS=="boolean"then return J elseif uS=="handling"then return a8 elseif uS=="hud"then return az elseif uS=="physics"then return aU end end;local function pM(uU)local function uV(uW)for dC,dn in pairs(uW)do dbHud_1.setStringValue(dC,uN(dn.get()))if uU and dbHud_2 then dbHud_2.setStringValue(dC,uN(dn.get()))end end end;if dbHud_1 then uV(bC)uV(il())a.print("Saved Variables to Datacore")if uU and dbHud_2 then bV="Databank copied.  Remove copy when ready."end end end;local function fN(uX,uY,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uX..".mp3")end;local function gG(hh,hi,ra,jF,uZ)if jF==nil then jF=""end;if uZ==nil then uZ=""end;return db([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jF,hh,hi,uZ,ra)end;local function im(c2,u_)local v0=c2>100000;if u_==nil then u_=1 end;if v0 then return fO(c2/1000/200,u_).."SU"elseif c2<1000 then return fO(c2,u_).."M"else return fO(c2/1000,u_).."KM"end end;local function io(v1)local v2=0;local v3=0;local v4=0;if v1<60 then v1=bG(v1)elseif v1<3600 then v2=bG(v1/60)v1=bG(v1%60)elseif v1<86400 then v3=bG(v1/3600)v2=bG(v1%3600/60)else v4=bG(v1/86400)v3=bG(v1%86400/3600)end;if v4>0 then return v4 .."d "..v3 .."h "elseif v3>0 then return v3 .."h "..v2 .."m "elseif v2>0 then return v2 .."m "..v1 .."s"elseif v1>0 then return v1 .."s"else return"0s"end end;function uM.onStart()local v5=false;local function v6()local function v7(v8)local v9=dbHud_1.hasKey;for dC,dn in pairs(v8)do if v9(dC)then local dx=ie(dbHud_1.getStringValue(dC))if dx~=nil then dn.set(dx)v5=true end end end end;if dbHud_1 then if not f then v7(il())coroutine.yield()v7(bC)else v7(bC)bV="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bW=5;v5=false end;coroutine.yield()if v5 then bV="Loaded Saved Variables"cc=a9;cd=aa;aV=j;g=string.lower(g)cs=p;cu=U elseif not f then bV="No Saved Variables Found - Exit HUD to save settings"end;if bz<1.500 then if T<2000 then bV="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bz=VERSION_NUMBER;if#bl>0 then d3=ik(d3,bl)end else bV="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bs+180<bI then bq=0 end;bs=bI;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bV="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bW=7 end;if antigrav and not q then if br==nil then br=c9 end;antigrav.setBaseAltitude(br)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d2>0 then d3=ik(d3,d2)end end;lC="Proceeding to Waypoint"end;local function va()local function vb(vc,vd)if vc>vd then vd=vc end;local ve,vf=0,0;if a5>0 then ve=a5*0.05 end;if a6>0 then vf=a6*0.05 end;vd=vd*(1-(ve+vf))return vd end;local vg=b.getElementNameById;local vh=aq~=0 and ar~=0;local vi=_G["atmofueltank_size"]local vj=_G["spacefueltank_size"]local vk=_G["rocketfueltank_size"]for dC in pairs(ip)do local type=b.getElementTypeById(ip[dC])if dX(type,'^.*Atmospheric Engine$')then if dX(tostring(b.getElementTagsById(ip[dC])),'^.*vertical.*$')and b.getElementForwardById(ip[dC])[3]>0 then cI=true end end;if dX(type,'^.*Space Engine$')then cz=true;if dX(tostring(b.getElementTagsById(ip[dC])),'^.*vertical.*$')then local vl=b.getElementForwardById(ip[dC])if vl[3]<0 then vm=true else cy=true end end end;if type=="Landing Gear"then bO=true end;if type=="Dynamic Core Unit"then local pG=pE(ip[dC])if pG>10000 then gH=110 elseif pG>1000 then gH=55 elseif pG>150 then gH=27 end end;iq=iq+pE(ip[dC])if vh and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pG=pE(ip[dC])local os=ig(ip[dC])local vc=0;local jy=bF()if type=="Atmospheric Fuel Tank"then local vd=400;local vn=35.03;if pG>10000 then vd=51200;vn=5480 elseif pG>1300 then vd=6400;vn=988.67 elseif pG>150 then vd=1600;vn=182.67 end;vc=os-vn;if a2>0 then vd=vd+vd*a2*0.2 end;vd=vb(vc,vd)local gr=vg(ip[dC])local jw=0;for jx=1,vi do if gr==ie(c["atmofueltank_"..jx].getData()).name then jw=jx;break end end;local vo={ip[dC],string.sub(gr,1,12),vd,vn,vc,jy,jw}ce[#ce+1]=vo end;if type=="Rocket Fuel Tank"then local vd=320;local vn=173.42;if pG>65000 then vd=40000;vn=25740 elseif pG>6000 then vd=5120;vn=4720 elseif pG>700 then vd=640;vn=886.72 end;vc=os-vn;if a4>0 then vd=vd+vd*a4*0.1 end;vd=vb(vc,vd)local gr=vg(ip[dC])local jw=0;for jx=1,vk do if gr==ie(c["rocketfueltank_"..jx].getData()).name then jw=jx;break end end;local vo={ip[dC],string.sub(gr,1,12),vd,vn,vc,jy,jw}cg[#cg+1]=vo end;if type=="Space Fuel Tank"then local vd=600;local vn=35.03;if pG>10000 then vd=76800;vn=5480 elseif pG>1300 then vd=9600;vn=988.67 elseif pG>150 then vd=2400;vn=182.67 end;vc=os-vn;if a3>0 then vd=vd+vd*a3*0.2 end;vd=vb(vc,vd)local gr=vg(ip[dC])local jw=0;for jx=1,vj do if gr==ie(c["spacefueltank_"..jx].getData()).name then jw=jx;break end end;local vo={ip[dC],string.sub(gr,1,12),vd,vn,vc,jy,jw}cf[#cf+1]=vo end end end;if not cI then b5,aW=false,false end end;local function vp()if gyro~=nil then cb=gyro.getState()==1 end;if not bx then ii:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u1(1)else u1(0)end;if door and(c7 or not c7 and c9<10000)then for dH,dn in pairs(door)do dn.toggle()end end;if switch then for dH,dn in pairs(switch)do dn.toggle()end end;if forcefield and(c7 or not c7==0 and c9<10000)then for dH,dn in pairs(forcefield)do dn.toggle()end end;if antigrav then cJ=antigrav.getState()==1;if cJ and not q then antigrav.show()end end;if ih()==1 and k then a.freeze(1)else a.freeze(0)end;if bO then if c6~=-1 and not cJ then d.control.extendLandingGears()else d.control.retractLandingGears()end end;bi=d.control.isAnyLandingGearExtended()==1 or c6-3<Y;if c6~=-1 or not c7 and cC:len()<50 then aX="Startup"else aX=false end;ii:setTargetGroundAltitude(uO)ps=c7 end;local function vq()local vr={}local function vs()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vt={[1]=4480,[6]=4480,[7]=6270}for vu,vv in pairs(e)do e[vu][0]=vs()e[vu][0].systemId=vu;vr[vu]={}for vw,iZ in pairs(e[vu])do iZ.gravity=iZ.gravity/9.8;iZ.center=vec3(iZ.center)iZ.name=iZ.name[1]iZ.noAtmosphericDensityAltitude=iZ.atmosphereThickness or iZ.atmosphereRadius-iZ.radius;iZ.spaceEngineMinAltitude=vt[iZ.id]or 0.68377*iZ.atmosphereThickness;iZ.planetarySystemId=vu;iZ.bodyId=iZ.id;vr[vu][vw]=iZ;if mu==nil or iZ.center.x<mu then mu=iZ.center.x end;if mt==nil or iZ.center.x>mt then mt=iZ.center.x end;if mx==nil or iZ.center.y<mx then mx=iZ.center.y end;if mw==nil or iZ.center.y>mw then mw=iZ.center.y end;if iZ.center and iZ.name~="Space"then cY[#cY+1]=iZ end end end;e6=da(d,b,c,a,db,dc,dd,de,df)ch=e6(vr)ci=eQ(d,b,c,a,de,eR)cj=fk(d,b,c,a,db,dc,dd,de,df)cl=fK(d,b,c,a,dbHud_1,e,fL,fM,bG,dd,de,fN,fO)iZ=ch[0]:closestBody(b.getConstructWorldPos())end;vx=false;vy=coroutine.create(function()ii:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v6()coroutine.yield()va()coroutine.yield()cm=pK(d,b,c,a,e,vBooster,hover,pL,antigrav,warpdrive,dbHud_1,radar_1,eR,bG,bH,ih,eM,bF,dc,ii,fL,ij,de,fO,fN,ik,df,im,io,pM,ie,db,fM)vp()coroutine.yield()vq()if radar_1 then cn=gE(b,a,c,library,radar_1,radar_2,eR,gF,de,gG,dd,gH,fN)end;ck=ic(d,b,c,a,e,radar_1,radar_2,antigrav,hover,d8,warpdrive,id,eR,bG,db,ie,bH,ig,ih,eM,bF,dc,ii,fM,fL,gF,ij,de,fO,gG,fN,ik,il,im,io,ip,iq)ck.ButtonSetup()co=t_(d,b,c,a,e,vBooster,hover,antigrav,d8,dbHud_2,gyro,u0,ih,ii,ij,u1,gF,fO,dX,dd,dc,fN,il,pM)if d8 then cp=hX(d8,dX,bG)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if u0 then u0.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aP)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if d8 then c.setTimer("shieldTick",0.0166667)end;if vz then vA.ExtraOnStart()end;fN("start","SU")end)coroutine.resume(vy)end;function uM.onUpdate()if not vx then local hM=coroutine.status(vy)if hM=="suspended"then local dD,hN=coroutine.resume(vy)if hN then a.print("ERROR STARTUP: "..hN)end elseif hM=="dead"then vx=true end end;if vx then d:update()if c7 and t and cK then if cK and bN then cm.cmdThrottle(0)bN=false elseif not cK and not bN then bJ=0;bN=true end end;if d0 then ii:setThrottleCommand(axisCommandId.longitudinal,d0)d0=nil end;if not cq and p7~=vB then a.setScreen(p7)end;vB=p7;if vz then vA.ExtraOnUpdate()end end end;function uM.onFlush()if vx then cm.onFlush()if vz then vA.ExtraOnFlush()end end end;function uM.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c8>0 or c8==0 and c9<10000)then for dH,dn in pairs(door)do dn.toggle()end end;if switch then for dH,dn in pairs(switch)do dn.toggle()end end;if forcefield and(c8>0 or c8==0 and c9<10000)then for dH,dn in pairs(forcefield)do dn.toggle()end end;w=c_;pM()if o1 then o1.activate()end;if z then cm.showWayPoint(iZ,cH)end;a.print(ck.FuelUsed("atmofueltank")..", "..ck.FuelUsed("spacefueltank")..", "..ck.FuelUsed("rocketfueltank"))if vz then vA.ExtraOnStop()end;fN("stop","SU")end;function uM.controlStart(ua)if vx then co.startControl(ua)end end;function uM.controlStop(ua)if vx then co.stopControl(ua)end end;function uM.controlLoop(ua)if vx then co.loopControl(ua)end end;function uM.controlInput(ra)if vx then co.inputTextControl(ra)end end;function uM.radarEnter(dM)cn.onEnter(dM)end;function uM.radarLeave(dM)cn.onLeave(dM)end;function uM.onTick(vC)if vC=="tenthSecond"then cm.TenthTick()ck.TenthTick()elseif vC=="oneSecond"then ck.OneSecondTick()elseif vC=="fiveSecond"then cm.SatNavTick()elseif vC=="msgTick"then ck.MsgTick()elseif vC=="animateTick"then ck.AnimateTick()elseif vC=="hudTick"then ck.hudtick()elseif vC=="apTick"then cm.APTick()elseif vC=="shieldTick"then cp.shieldTick()elseif vC=="tagTick"then co.tagTick()elseif vC=="contact"then cn.ContactTick()end end;if vz then for dC,dn in pairs(vz)do uM[dC]=dn end end;return uM end;function script.onStart()vA.onStart()end;function script.onStop()vA.onStop()end;function script.onTick(vC)vA.onTick(vC)end;function script.onFlush()vA.onFlush()end;function script.onUpdate()vA.onUpdate()end;function script.onActionStart(ua)vA.controlStart(ua)end;function script.onActionStop(ua)vA.controlStop(ua)end;function script.onActionLoop(ua)vA.controlLoop(ua)end;function script.onInputText(ra)vA.controlInput(ra)end;function script.onEnter(dM)vA.radarEnter(dM)end;function script.onLeave(dM)vA.radarLeave(dM)end;bE(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)vA=uL(d,b,c,a,library,e,vBooster,hover,pL,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,d8,gyro,warpdrive,id,u0)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua:       if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua:       if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua:       if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
