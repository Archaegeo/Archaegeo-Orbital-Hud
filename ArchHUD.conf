name: ArchHud - Archaegeo v1.404 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        LockPitchTarget = 0 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.404;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=system.getTime;local vec3=vec3;local p=utils.clamp;local q=a.axisCommandManager;local r=system.destroyWidgetPanel;local s=system.updateData;local t=system.addDataToWidget;local u=system.lockView;local v=system.isViewLocked;local w=math.sqrt;local x=tonumber;local core=core;local function y(z,A)local B=10^(A or 0)return d(z*B+0.5)/B end;local C=o()local D=o()local E=16;local F=13;local G=SafeR;local H=SafeB;local I=SafeG;local J=0;local K=0;local L=false;local M=0;local N=false;local O=false;local P=55;local Q=false;local R=false;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=false;local a0=false;local a1="empty"local a2=5;local a3=5;local a4=a2;local a5=a3;local a6=false;local a7,a8=0;local a9,aa=0;local ab=nil;local ac=0;local ad=0;local ae=0;local af=0;local ag=0;local ah=3;local ai=0;local aj=""local ak=false;local al=false;local am=false;local an=-1;local ao=""local ap=j()>0;local aq=j()local ar=core.getAltitude()local as=core.getElementIdList()local at=o()local au=core.getConstructMass()local av=false;local aw=nil;local ax=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]local ay=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local az={}local aA=0;local aB=0;local aC=""local aD=true;local aE={}local aF=ResolutionX;local aG=ResolutionY;local aH={}local aI={}local aJ={}local aK=0;local aL=false;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=o()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=""local bJ=nil;local bK={}local bL=unit.getClosestPlanetInfluence()>0;local bM=false;local bN=nil;local function bO(bP)local bQ,bR,bS=aR:getPlanetarySystem(0):castIntersections(bv,bP,function(bT)if bT.noAtmosphericDensityAltitude>0 then return bT.radius+bT.noAtmosphericDensityAltitude else return bT.radius+bT.surfaceMaxAltitude*1.5 end end)local bU=bR;if bS~=nil and bR~=nil then bU=math.min(bS,bR)end;if bU~=nil then return bQ,bU else return nil,nil end end;local function bV(bW,bX,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bW.."|"..bX.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bW.."|"..bX.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bW.."|"..bX.."|"..soundVolume)end end;local function bY(bZ,b_)for i=1,#b_ do bZ[#bZ+1]=b_[i]end;return bZ end;local function c0(c1)local c2={}local c3={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local c4={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","LockPitchTarget","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c5={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local c6={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c1 then bY(c2,c3)bY(c2,c4)bY(c2,c5)bY(c2,c6)return c2 elseif c1=="boolean"then return c3 elseif c1=="handling"then return c4 elseif c1=="hud"then return c5 elseif c1=="physics"then return c6 end end;local function c7(c8,c9,ca,cb,cc)if cb==nil then cb=""end;if cc==nil then cc=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cb,c8,c9,cc,ca)end;local function cd(ce,cf)if q:getAxisCommandType(0)~=axisCommandType.byThrottle and not cf then a.control.cancelCurrentControlMasterMode()end;q:setThrottleCommand(axisCommandId.longitudinal,ce)J=p(y(ce*100,0)/100,-1,1)end;local function cg(ce,cf)if q:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cf then a.control.cancelCurrentControlMasterMode()end;q:setTargetSpeedCommand(axisCommandId.longitudinal,ce)bz=ce end;local function ch(ci,cj)if ci==0 then return c(cj)<1e-09 end;if cj==0 then return c(ci)<1e-09 end;return c(ci-cj)<math.max(c(ci),c(cj))*epsilon end;local function ck(ai,cl)local cm=ai>100000;if cl==nil then cl=1 end;if cm then return y(ai/1000/200,cl).."SU"elseif ai<1000 then return y(ai,cl).."M"else return y(ai/1000,cl).."KM"end end;local function cn()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;ae=0;if ap and an==-1 then BrakeLanding=false;AltitudeHold=true;ae=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cg(d(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()q:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function co()bi=false;ba=nil;bb=nil;bm=0;if aq==0 then if IntoOrbit then bV("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bL then bV("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a1="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function cp()if C-b5<1.5 then if planet.hasAtmosphere then if aq>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bV("11","EP")else if bL then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then co()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=C end;if bL and aq==0 then bg=ar;bf=true;bc=true;co()if IntoOrbit then b5=C else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Z=false;b0=true;LockPitch=nil;bi=false;if an~=-1 and bs<20 then bV("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=ar+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;q:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cn()end else bV("altOn","AH")AutoTakeoff=false;if b5>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=ar end end;if VertTakeOff then cn()end end;if al then HoldAltitude=100000 end else bV("altOff","AH")if IntoOrbit then co()end;if VertTakeOff then cn()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cq()local function cr(SpaceTarget)bM=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cp()end end;VectorStatus="Proceeding to Waypoint"end;if C-b6<1.5 and aq>0 then if not bl then a1="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if aq>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bV("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=C end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not al and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<au then a1="WARNING: Heavy Loads may affect autopilot performance."ah=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ab,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bV("apSpc","AP")if aq~=0 then al=true;cp()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if aq>0 then if not VectorToTarget then bV("vtt","AP")cr(SpaceTarget)end else bV("apOn","AP")if not(ab.name==planet.name and bL)then bi=false;Autopilot=true elseif not ap then if IntoOrbit then co()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then co()end end end else bV("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if aq~=0 then al=true;cp()else Autopilot=true end end elseif aq==0 then if CustomTarget==nil and(ab.name==planet.name and bL)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;co()else bV("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Z=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;O=false;LockPitch=nil;WaypointSet=false end else bV("apP","AP")al=true;cp()end else bV("apOff","AP")al=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;O=false;AutoTakeoff=false;AltitudeHold=false;HoldAltitude=ar;TargetSet=false;Reentry=false;if IntoOrbit then co()end end end;local function cs()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then bV("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bJ=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cn()end;if IntoOrbit then co()end;b0=autoRollPreference;ak=false;am=false;ae=0 else bV("bkOff","B",1)end end;local function ct()if Reentry then a1="Re-Entry cancelled"bV("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ah=5 elseif not Q then Reentry=true;if q:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;bV("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local ca=ck(HoldAltitude)a1="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..ca;bV("glide","RE")cg(d(b7))end;AutoTakeoff=false end;local function cu()if antigrav and not ExternalAGG then if by then bV("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=ar end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bV("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cv(cw)local cx=0;local cy=0;local cz=0;if cw<60 then cw=d(cw)elseif cw<3600 then cx=d(cw/60)cw=d(cw%60)elseif cw<86400 then cy=d(cw/3600)cx=d(cw%3600/60)else cz=d(cw/86400)cy=d(cw%86400/3600)end;if cz>0 then return cz.."d "..cy.."h "elseif cy>0 then return cy.."h "..cx.."m "elseif cx>0 then return cx.."m "..cw.."s"elseif cw>0 then return cw.."s"else return"0s"end end;local function cA(cB)local function cC(cD)for cE,cF in pairs(cD)do dbHud_1.setStringValue(cF,g(_G[cF]))if cB and dbHud_2 then dbHud_2.setStringValue(cF,g(_G[cF]))end end end;if dbHud_1 then cC(b)cC(c0())system.print("Saved Variables to Datacore")if cB and dbHud_2 then a1="Databank copied.  Remove copy when ready."end end end;local function cG()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function cH()local function cI(cJ)return type(cJ)=='number'end;local function cK(cJ)return type(x(cJ))=='number'end;local function cL(cM)return type(cM)=='table'end;local function cN(cO)return type(cO)=='string'end;local function cP(cF)return cL(cF)and cI(cF.x and cF.y and cF.z)end;local function cQ(cR)return cL(cR)and cI(cR.latitude and cR.longitude and cR.altitude and cR.bodyId and cR.systemId)end;local cS=math.pi/180;local cT=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cU='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cV(cJ)local cW=string.gsub(string.reverse(e('%.4f',cJ)),'^0*%.?','')return cW==''and'0'or string.reverse(cW)end;local function cX(cY)if cP(cY)then return e('{x=%.3f,y=%.3f,z=%.3f}',cY.x,cY.y,cY.z)end;if cL(cY)and not getmetatable(cY)then local cZ={}local c_=next(cY)if type(c_)=='nil'or c_==1 then cZ=cY else for cE,cF in pairs(cY)do local ce=cX(cF)if type(cE)=='number'then table.insert(cZ,e('[%s]=%s',cE,ce))else table.insert(cZ,e('%s=%s',cE,ce))end end end;return e('{%s}',table.concat(cZ,','))end;if cN(cY)then return e("'%s'",cY:gsub("'",[[\']]))end;return tostring(cY)end;local d0={}d0.__index=d0;d0.__tostring=function(cY,d1)local d2={}for cE in pairs(cY)do table.insert(d2,cE)end;table.sort(d2)local cZ={}for _,cE in ipairs(d2)do local ce=cX(cY[cE])if type(cE)=='number'then table.insert(cZ,e('[%s]=%s',cE,ce))else table.insert(cZ,e('%s=%s',cE,ce))end end;if d1 then return e('%s%s',d1,table.concat(cZ,',\n'..d1))end;return e('{%s}',table.concat(cZ,','))end;d0.__eq=function(d3,d4)return d3.planetarySystemId==d4.planetarySystemId and d3.bodyId==d4.bodyId and ch(d3.radius,d4.radius)and ch(d3.center.x,d4.center.x)and ch(d3.center.y,d4.center.y)and ch(d3.center.z,d4.center.z)and ch(d3.GM,d4.GM)end;local function d5(d6,d7,d8,d9,da)assert(cK(d6),'Argument 1 (planetarySystemId) must be a number:'..type(d6))assert(cK(d7),'Argument 2 (bodyId) must be a number:'..type(d7))assert(cK(d8),'Argument 3 (radius) must be a number:'..type(d8))assert(cL(d9),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(d9))assert(cK(da),'Argument 5 (GM) must be a number:'..type(da))return setmetatable({planetarySystemId=x(d6),bodyId=x(d7),radius=x(d8),center=vec3(d9),GM=x(da)},d0)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(db)return e('::pos{%d,%d,%s,%s,%s}',db.systemId,db.bodyId,cV(db.latitude*cT),cV(db.longitude*cT),cV(db.altitude))end;MapPosition.__eq=function(d3,d4)return d3.bodyId==d4.bodyId and d3.systemId==d4.systemId and ch(d3.latitude,d4.latitude)and ch(d3.altitude,d4.altitude)and(ch(d3.longitude,d4.longitude)or ch(d3.latitude,math.pi/2)or ch(d3.latitude,-math.pi/2))end;local function dc(dd,d7,de,df,dg)local d6=dd;if cN(dd)and not df and not dg and not d7 and not de then d6,d7,de,df,dg=n(dd,cU)assert(d6,'Argument 1 (position string) is malformed.')else assert(cK(d6),'Argument 1 (systemId) must be a number:'..type(d6))assert(cK(d7),'Argument 2 (bodyId) must be a number:'..type(d7))assert(cK(de),'Argument 3 (latitude) must be in degrees:'..type(de))assert(cK(df),'Argument 4 (longitude) must be in degrees:'..type(df))assert(cK(dg),'Argument 5 (altitude) must be in meters:'..type(dg))end;d6=x(d6)d7=x(d7)de=x(de)df=x(df)dg=x(dg)if d7==0 then return setmetatable({latitude=de,longitude=df,altitude=dg,bodyId=d7,systemId=d6},MapPosition)end;return setmetatable({latitude=cS*p(de,-90,90),longitude=cS*(df%360),altitude=dg,bodyId=d7,systemId=d6},MapPosition)end;local dh={}dh.__index=dh;dh.__tostring=function(cY,d1)local di=d1 and d1 ..'  'local dj={}local d2={}for cE in pairs(cY)do table.insert(d2,cE)end;table.sort(d2)for _,dk in ipairs(d2)do bdy=cY[dk]local dl=d0.__tostring(bdy,di)if d1 then table.insert(dj,e('[%s]={\n%s\n%s}',dk,dl,d1))else table.insert(dj,e('  [%s]=%s',dk,dl))end end;if d1 then return e('\n%s%s%s',d1,table.concat(dj,',\n'..d1),d1)end;return e('{\n%s\n}',table.concat(dj,',\n'))end;local function dm(dn)local aM={}local pid;for _,cF in pairs(dn)do local dp=cF.planetarySystemId;if type(dp)~='number'then error('Invalid planetary system ID: '..tostring(dp))elseif pid and dp~=pid then error('Mistringmatch planetary system IDs: '..dp..' and '..pid)end;local dq=cF.bodyId;if type(dq)~='number'then error('Invalid body ID: '..tostring(dq))elseif aM[dq]then error('Duplicate body ID: '..tostring(dq))end;setmetatable(cF.center,getmetatable(vec3.unit_x))aM[dq]=setmetatable(cF,d0)pid=dp end;return setmetatable(aM,dh)end;aQ={}local function dr(dn)return setmetatable({galaxyAtlas=dn or{}},aQ)end;aQ.__index=function(cM,i)if type(i)=='number'then local system=cM.galaxyAtlas[i]return dm(system)end;return rawget(aQ,i)end;aQ.__pairs=function(cY)return function(cM,cE)local ds,nv=next(cM,cE)return ds,nv and dm(nv)end,cY.galaxyAtlas,nil end;aQ.__tostring=function(cY)local dt={}for _,du in pairs(cY or{})do local dv=du:getPlanetarySystemId()local dw=dh.__tostring(du,'    ')table.insert(dt,e('  [%s]={%s\n  }',dv,dw))end;return e('{\n%s\n}\n',table.concat(dt,',\n'))end;aQ.BodyParameters=d5;aQ.MapPosition=dc;aQ.PlanetarySystem=dm;function aQ.createBodyParameters(dx,d7,dy,dz,dA,dB,dC)assert(cK(dx),'Argument 1 (planetarySystemId) must be a number:'..type(dx))assert(cK(d7),'Argument 2 (bodyId) must be a number:'..type(d7))assert(cK(dy),'Argument 3 (surfaceArea) must be a number:'..type(dy))assert(cL(dz),'Argument 4 (aPosition) must be an array or vec3:'..type(dz))assert(cL(dA),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dA))assert(cK(dB),'Argument 6 (altitude) must be in meters:'..type(dB))assert(cK(dC),'Argument 7 (gravityAtPosition) must be number:'..type(dC))local d8=w(dy/4/math.pi)local ai=d8+dB;local dD=vec3(dz)+ai*vec3(dA)local da=dC*ai*ai;return d5(dx,d7,d8,dD,da)end;aQ.isMapPosition=cQ;function aQ:getPlanetarySystem(dd)if i==nil then i=0 end;if nv==nil then nv=0 end;local dx=dd;if cQ(dd)then dx=dd.systemId end;if type(dx)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dh then system=dm(system)end;return system end end end;function dh:sizeCalculator(bT)return 1.05*bT.radius end;function dh:castIntersections(dE,dF,dG,dH,dI,dJ)local dK={}local dL=dI or self;for _,bT in pairs(dL)do table.insert(dK,bT)end;if not dJ then table.sort(dK,function(dM,dN)return(dM.center-dE):len()<(dN.center-dE):len()end)end;local dO=dF:normalize()for _,bT in ipairs(dK)do local dP=bT.center-dE;local d8=self:sizeCalculator(bT)local dQ=dP:dot(dO)local dR=dQ^2-(dP:len2()-d8^2)if dR>=0 then local dS=w(dR)local bR=dQ+dS;local bS=dQ-dS;if bS>0 then return bT,bR,bS elseif bR>0 then return bT,bR,nil end end end;return nil,nil,nil end;function dh:closestBody(dT)assert(type(dT)=='table','Invalid coordinates.')local dU,bT;local dV=vec3(dT)for _,dW in pairs(self)do local dX=(dW.center-dV):len2()if(not bT or dX<dU)and dW.name~="Space"then bT=dW;dU=dX end end;return bT end;function dh:convertToBodyIdAndWorldCoordinates(dd)local dY=dd;if cN(dd)then dY=dc(dd)end;if dY.bodyId==0 then return 0,vec3(dY.latitude,dY.longitude,dY.altitude)end;local dW=self:getBodyParameters(dY)if dW then return dY.bodyId,dW:convertToWorldCoordinates(dY)end end;function dh:getBodyParameters(dd)local d7=dd;if cQ(dd)then d7=dd.bodyId end;assert(cK(d7),'Argument 1 (bodyId) must be a number:'..type(d7))return self[d7]end;function dh:getPlanetarySystemId()local _,cF=next(self)return cF and cF.planetarySystemId end;function d0:convertToMapPosition(d9)assert(cL(d9),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(d9))local dZ=vec3(d9)if self.bodyId==0 then return setmetatable({latitude=dZ.x,longitude=dZ.y,altitude=dZ.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local d_=dZ-self.center;local ai=d_:len()local dg=ai-self.radius;local de=0;local df=0;if not ch(ai,0)then local e0=m(d_.y,d_.x)df=e0>=0 and e0 or 2*math.pi+e0;de=math.pi/2-math.acos(d_.z/ai)end;return setmetatable({latitude=de,longitude=df,altitude=dg,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function d0:convertToWorldCoordinates(dd)local dY=cN(dd)and dc(dd)or dd;if dY.bodyId==0 then return vec3(dY.latitude,dY.longitude,dY.altitude)end;assert(cQ(dY),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dY.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dY.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local e1=math.cos(dY.latitude)return self.center+(self.radius+dY.altitude)*vec3(e1*math.cos(dY.longitude),e1*math.sin(dY.longitude),math.sin(dY.latitude))end;function d0:getAltitude(d9)return(vec3(d9)-self.center):len()-self.radius end;function d0:getDistance(d9)return(vec3(d9)-self.center):len()end;function d0:getGravity(d9)local e2=self.center-vec3(d9)local e3=e2:len2()return self.GM/e3*e2/w(e3)end;return setmetatable(aQ,{__call=function(_,...)return dr(...)end})end;local function e4()local aS={}local e5=30000000/3600;local e6=e5*e5;local e7=100;function aS.computeAccelerationTime(e8,e9,ea)local eb=e5*math.asin(e8/e5)return(e5*math.asin(ea/e5)-eb)/e9 end;function aS.computeDistanceAndTime(e8,ea,ec,ed,ee,ef)ee=ee or 0;ef=ef or 0;local eg=e8<=ea;local eh=ed*(eg and 1 or-1)/ec;local ei=-ef/ec;local ej=eh+ei;if eg and ej<=0 or not eg and ej>=0 then return-1,-1 end;local ek,el=0,0;if eh~=0 and ee>0 then local eb=math.asin(e8/e5)local em=math.pi*(eh/2+ei)local en=eh*ee;local eo=e5*math.pi;local cF=function(cM)local ep=(em*cM-en*math.sin(math.pi*cM/2/ee)+eo*eb)/eo;local eq=math.tan(ep)return e5*eq/w(eq*eq+1)end;local er=eg and function(cO)return cO>=ea end or function(cO)return cO<=ea end;el=2*ee;if er(cF(el))then local es=0;while c(el-es)>0.5 do local cM=(el+es)/2;if er(cF(cM))then el=cM else es=cM end end end;local et=e8;local eu=el/e7;for ev=1,e7 do local ew=cF(ev*eu)ek=ek+(ew+et)*eu/2;et=ew end;if el<2*ee then return ek,el end;e8=et end;local eb=e5*math.asin(e8/e5)local C=(e5*math.asin(ea/e5)-eb)/ej;local ex=e6*math.cos(eb/e5)/ej;local ai=ex-e6*math.cos((ej*C+eb)/e5)/ej;return ai+ek,C+el end;function aS.computeTravelTime(e8,e9,ai)if ai==0 then return 0 end;if e9>0 then local eb=e5*math.asin(e8/e5)local ex=e6*math.cos(eb/e5)/e9;return(e5*math.acos(e9*(ex-ai)/e6)-eb)/e9 end;if e8==0 then return-1 end;assert(e8>0,'Acceleration and initial speed are both zero.')return ai/e8 end;return aS end;local function ey()local vec3=require('cpml.vec3')local cH=cH()local function cN(cO)return type(cO)=='string'end;local function cL(cM)return type(cM)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dg)assert(self.body)local ai=dg+self.body.radius;if not ch(ai,0)then local orbit=w(self.body.GM/ai)return w(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dd,ez)assert(self.body)assert(cL(dd)or cN(dd))assert(cL(ez))local eA=(cN(dd)or cH.isMapPosition(dd))and self.body:convertToWorldCoordinates(dd)or vec3(dd)local cF=vec3(ez)local eB=eA-self.body.center;local eC=cF:len2()local eD=eB:len()local eE=self.body.GM;local eF=((eC-eE/eD)*eB-eB:dot(cF)*cF)/eE;local ci=eE/(2*eE/eD-eC)local eG=eF:len()local dO=eF:normalize()local eH=ci*(1-eG)local eI=ci*(1+eG)local eJ=eH*dO+self.body.center;local eK=eG<=1 and-eI*dO+self.body.center or nil;local eL=w(ci*eE*(1-eG*eG))local eM=eK and 2*math.pi*w(ci^3/eE)local eN=math.acos(eF:dot(eB)/(eG*eD))if eB:dot(cF)<0 then eN=-(eN-2*math.pi)end;local eO=math.acos((math.cos(eN)+eG)/(1+eG*math.cos(eN)))local eP=eO;if eP<0 then eP=eP+2*math.pi end;local eQ=eP-eG*math.sin(eP)local eR=0;local eS=0;local eT=0;if eM~=nil then eR=eQ/(2*math.pi/eM)eS=eM-eR;eT=eS+eM/2;if eN-math.pi>0 then eS=eR;eT=eS+eM/2 end;if eT>eM then eT=eT-eM end end;return{periapsis={position=eJ,speed=eL/eH,circularOrbitSpeed=w(eE/eH),altitude=eH-self.body.radius},apoapsis=eK and{position=eK,speed=eL/eI,circularOrbitSpeed=w(eE/eI),altitude=eI-self.body.radius},currentVelocity=cF,currentPosition=eA,eccentricity=eG,period=eM,eccentricAnomaly=eO,meanAnomaly=eQ,timeToPeriapsis=eS,timeToApoapsis=eT}end;local function eU(eV)local dW=cH.BodyParameters(eV.planetarySystemId,eV.bodyId,eV.radius,eV.center,eV.GM)return setmetatable({body=dW},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eU(...)end})end;local function eW()local eX={}local eY={}local eZ={XS=13,S=27,M=55,L=110,XL=221}local e_={}local f0;local f1;local f2;local f3;local f4;local function f5()local function f6(f7,f8,f9,fa,fb,fc,fd,fe)f8,fa,fc,fe=vec3(f8),vec3(fa),vec3(fc),vec3(fe)local ff,fg,fh=f7*f7,f9*f9,fb*fb;local eC=fa-f8;local fi=eC:normalize()local fj=eC:len()local fk=fc-f8;local fl=(fk-fk:project_on(fi)):normalize()local fm,fn=fk:dot(fi),fk:dot(fl)local fo=fm*fm+fn*fn;local fp=fi:cross(fl)local c8=(ff-fg+fj*fj)/(2*fj)local c9=(ff-fh+fo-2*fm*c8)/(2*fn)local cR=ff-c8^2-c9^2;local fq=w(cR)local fr=f8+fi*c8+fl*c9+fp*fq;local fs=f8+fi*c8+fl*c9-fp*fq;if c((fe-fr):len()-fd)<c((fe-fs):len()-fd)then return fr else return fs end end;local function ft()local function fu()local fv=core.getConstructWorldOrientationRight()local eC=core.getConstructWorldOrientationForward()local fk=core.getConstructWorldOrientationUp()local fw=library.systemResolution3(fv,eC,fk,{1,0,0})local fx=library.systemResolution3(fv,eC,fk,{0,1,0})local fy=library.systemResolution3(fv,eC,fk,{0,0,1})return function(fz)return library.systemResolution3(fw,fx,fy,fz)end end;local fA=fu()local fB=core.getConstructWorldPos()local eA=core.getElementPositionById(1)local fC={eA[1]-E,eA[2]-E,eA[3]-E}local fD=fA(fC)local fE={fB[1]-fD[1],fB[2]-fD[2],fB[3]-fD[3]}return fE end;local function fF(fG,eD,fH)local fI=fG.pts;local fJ=#fI;local fK=fG.ref;if fJ>3 then local fL,fM,fN,fO=fI[fJ],fI[fJ-1],fI[fJ-2],fI[fJ-3]fG.ref=fH;local eA=f6(fL[1],fL[2],fM[1],fM[2],fN[1],fN[2],fO[1],fO[2])local c8,c9,fq=eA.x,eA.y,eA.z;if c8==c8 and c9==c9 and fq==fq then c8=c8+fK[1]c9=c9+fK[2]fq=fq+fK[3]local fP=vec3(c8,c9,fq)if not fG.lastPos then fG.center=fP elseif(fG.lastPos-fP):len()<2 then fG.center=fP;fG.skipCalc=true end;fG.lastPos=fP end;fG.pts={}else local fQ={fH[1]-fK[1],fH[2]-fK[2],fH[3]-fK[3]}fI[fJ+1]={eD,fQ}end end;if radar_1 then f0=#radar_1.getEntries()local fR=radar_1.getData()local fS=fR:gmatch('{"constructId[^}]*}[^}]*}')if f0>0 then local fH=ft()local fT,fU=0,0;f4,f3=0,0;for cF in fS do local dp,ai,fV=cF:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fW=eZ[fV]ai=x(ai)if radar_1.hasMatchingTransponder(dp)==1 then table.insert(eY,dp)end;local fX=radar_1.getConstructType(dp)if CollisionSystem then if fW>27 or fX=="static"or fX=="space"then f4=f4+1;local fY=radar_1.getConstructName(dp)local fG=bK[dp]if fG==nil then fW=fW+F;bK[dp]={pts={},ref=fH,name=fY,i=0,radius=fW,skipCalc=false}fG=bK[dp]end;if not fG.skipCalc then fF(fG,ai,fH)fU=fU+1 end;if fG.center then table.insert(e_,fG)end end;fT=fT+1;if bL and fT>700 or fU>70 or(not bL and fT>300 or fU>30)then coroutine.yield()fT,fU=0,0 end end end;f3=#e_;if f3>0 and bs>20 then local bT,fZ,f_,g0;local g1=0;local g2=aR:getPlanetarySystem(0)g0=br:normalize()while g1<f3 do coroutine.yield()local g3={table.unpack(e_,g1,math.min(g1+75,f3))}bT,fZ,f_=g2:castIntersections(bv,g0,nil,nil,g3,true)if bT and f_ then bN={bT,fZ,f_}break end;g1=g1+75 end;if not bT then bN=nil end else bN=nil end;e_={}f1=fR:find('identifiedConstructs":%[%]')else f2=fR:find('worksInEnvironment":false')end end end;function eX.UpdateRadar()local g4=coroutine.status(UpdateRadarCoroutine)if g4=="suspended"then local ce,g5=coroutine.resume(UpdateRadarCoroutine)if g5 then system.print("ERROR UPDATE RADAR: "..g5)end elseif g4=="dead"then UpdateRadarCoroutine=coroutine.create(f5)local ce,g5=coroutine.resume(UpdateRadarCoroutine)end end;function eX.GetRadarHud()return f1,f2,f0,f3,f4,eY end;UpdateRadarCoroutine=coroutine.create(f5)return eX end;local function g6()local g7=0;local g8=vec3({13771471,7435803,-128971})local g9=18000000;local ga=500000;local gb,gc=math.huge;local gd;local function ge(gf)gb=vec3(gf):dist(g8)if gb<g9 then return true,c(gb-g9)end;gc=vec3(gf):dist(vec3(planet.center))if gc<ga then gd=true else gd=false end;if c(gc-ga)<c(gb-g9)then return gd,c(gc-ga)else return gd,c(gb-g9)end end;local function gg(cF)if aF==1920 then return cF else return y(aF*cF/1920,0)end end;local function gh(cF)if aG==1080 then return cF else return y(aG*cF/1080,0)end end;local function gi()return v()==0 and userControlScheme~="keyboard"and l()==0 end;local function gj()local gk="TRAVEL"if not bA then gk="CRUISE"end;if Autopilot then gk="AUTOPILOT"end;return gk end;local gl=""local gm=""local gn=1;local go=2;local gp=3;local gq=4;local gr=5;local gs=6;local gt=""local gu=0;local gv=d(1/apTickRate)*2*hudTickRate;local gw={}local gx={}local gy={}local gz={}local gA={}local gB={}local function gC(c8,gD,gE,gF,gG,gH)local gI=fuelY;local gJ=fuelY+5;if not BarFuelDisplay then gJ=gJ+5 end;if l()==1 and not RemoteHud then gI=gI-50;gJ=gJ-50 end;if gE=="ATMO"then gt="atmofueltank"elseif gE=="SPACE"then gt="spacefueltank"else gt="rocketfueltank"end;gu=_G[gt.."_size"]if#gF>0 then for i=1,#gF do local fY=string.sub(gF[i][go],1,12)local gK=0;for gL=1,gu do if gF[i][go]==f(unit[gt.."_"..gL].getData()).name then gK=gL;break end end;local gM=o()if gG[i]==nil or gH[i]==nil or gM-gF[i][gs]>gv then local gN;local gO=0;if gK~=0 then gH[i]=f(unit[gt.."_"..gK].getData()).percentage;gG[i]=f(unit[gt.."_"..gK].getData()).timeLeft;if gG[i]=="n/a"then gG[i]=0 end else gO=k(gF[i][gn])-gF[i][gq]gH[i]=d(0.5+gO*100/gF[i][gp])gN=gF[i][gr]if gN<=gO then gG[i]=0 else gG[i]=d(0.5+gO/((gN-gO)/(gM-gF[i][gs])))end;gF[i][gr]=gO;gF[i][gs]=gM end end;if fY==gD then fY=e("%s %d",gE,i)end;if gK==0 then fY=fY.." *"end;local gP;if gG[i]==0 then gP=""else gP=cv(gG[i])end;if gH[i]~=nil then local gQ=d(gH[i]*2.55)local gR=e("rgb(%d,%d,%d)",255-gQ,gQ,0)local cb=""if gP~=""and gG[i]<120 or gH[i]<5 then cb=[[class="red"]]end;if BarFuelDisplay then gm=gm..e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],c8,gJ,gR,gH[i],c8,gJ,c8+2,gJ+10,gH[i],gP)gm=gm..c7(c8,gI,fY,cb.."txtstart pdim txtfuel")gI=gI-30;gJ=gJ-30 else gm=gm..c7(c8,gI,fY,cb.." pdim txtfuel")gm=gm..c7(c8,gJ,e("%d%% %s",gH[i],gP),"pdim txtfuel","fill:"..gR)gI=gI+30;gJ=gJ+30 end end end end end;local function gS(gT,dg)if dg<200000 and not ap or dg and ap then local gU=0;if c(bu)>1 then gU=45*math.log(c(bu),10)if bu<0 then gU=-gU end end;gT[#gT+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bu),d(gU))end;return gT end;local function gV(gW)local gX=-bt;gW=gW-gW:project_on(gX)local gY=vec3(0,0,1)gY=gY-gY:project_on(gX)local gZ=gY:cross(gX)local gU=gY:angle_between(gW)*constants.rad2deg;if gW:dot(gZ)<0 then gU=360-gU end;return gU end;local function g_(gT,centerX,centerY,h0,h1,bL)local h2=circleRad;local h3=20;local h4=d(h0)if bL then for i=-45,45,5 do local h5=i;gT[#gT+1]=e([[<g transform="rotate(%f,%d,%d)">]],h5,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gT[#gT+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h2+h3-len,centerX,centerY+h2+h3)end;gT[#gT+1]=c7(centerX,centerY+h2+h3-35,h1,"pdim txt txtmid")gT[#gT+1]=c7(centerX,centerY+h2+h3-25,h4 .." deg","pdim txt txtmid")gT[#gT+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h0,centerX,centerY)gT[#gT+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h2+h3-20,centerX+5,centerY+h2+h3-20,centerX,centerY+h2+h3-15)gT[#gT+1]="</g>"end;local h6=h4;if bL then h6=gV(bo)end;local h7=20;local h8=d(h6)local h9=0;local ha=centerY+h2+h3+20;local hb=centerX;if h1~="YAW"then ha=gh(130)hb=gg(960)end;local hc=[[<path class="txttick line" d="]]local hd=d(h8-(h7+10)-h8%5+0.5)for i=hd+60,hd,-5 do local c8=hb-(-i*5+h6*5)if i%10==0 then h9=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;gT[#gT+1]=c7(c8+5,ha-12,z)elseif i%5==0 then h9=5 end;if h9==10 then hc=e([[%s M %f %f v %d]],hc,c8,ha-5,h9)else hc=e([[%s M %f %f v %d]],hc,c8,ha-2.5,h9)end end;gT[#gT+1]=hc..[["/>]]gT[#gT+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],hb-5,ha+10,hb+5,ha+10,hb,ha+5)if bL then h1="HDG"end;gT[#gT+1]=c7(hb,ha+25,h8 .."deg","pdim txt txtmid","")gT[#gT+1]=c7(hb,ha+35,h1,"pdim txt txtmid","")end;local function he(gT,hf,h0,centerX,centerY,bL,hg,ew)local h2=circleRad;local hh=d(h2*3/5)if h2>0 then local hi=d(hf)local len=0;local hc=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h0,centerX,centerY)if not ap then hc=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gT[#gT+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h2-1,centerX,centerY)gT[#gT+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(hi-30-hi%5+0.5),d(hi+30+hi%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local c9=centerY+-i*5+hf*5;if len==30 then hc=e([[%s M %d %f h %d]],hc,centerX-hh-len,c9,len)if ap then gT[#gT+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h0,centerX,centerY,centerX-hh+10,c9,i)gT[#gT+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h0,centerX,centerY,centerX+hh-10,c9,i)if i==0 or i==180 or i==-180 then gT[#gT+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h0,centerX,centerY,centerX-hh+20,c9,hh*2-40)end else gT[#gT+1]=c7(centerX-hh+10,c9,i,"pdim txt txtmid")gT[#gT+1]=c7(centerX+hh-10,c9,i,"pdim txt txtmid")end;hc=e([[%s M %d %f h %d]],hc,centerX+hh,c9,len)else hc=e([[%s M %d %f h %d]],hc,centerX-hh-len,c9,len)hc=e([[%s M %d %f h %d]],hc,centerX+hh,c9,len)end end;gT[#gT+1]=hc..[["/>]]local hj="PITCH"if not bL then hj="REL PITCH"end;if hf>90 and not ap then hf=90-(hf-90)elseif hf<-90 and not ap then hf=-90-(hf+90)end;if h2>200 then if ap then if ew>P then gT[#gT+1]=c7(centerX,centerY-15,"Yaw","pdim txt txtmid")gT[#gT+1]=c7(centerX,centerY+20,hg,"pdim txt txtmid")end;gT[#gT+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h0,centerX,centerY)else gT[#gT+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gT[#gT+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hh+25,centerY-5,centerX-hh+20,centerY,centerX-hh+25,centerY+5,centerX-hh+50,centerY+4,hi)gT[#gT+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hh-25,centerY-5,centerX+hh-20,centerY,centerX+hh-25,centerY+5,centerX+hh-30,centerY+4,hi)gT[#gT+1]="</g>"end;local hk=d(h2/3)gT[#gT+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hk,centerY,h2-hk)if not ap and bL then gT[#gT+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h0,centerX,centerY,centerX-hh+10,centerY,hh*2-20)end;gT[#gT+1]="</g>"if h2<200 then if ap and ew>P then gT[#gT+1]=c7(centerX,centerY-h2,hj,"pdim txt txtmid")gT[#gT+1]=c7(centerX,centerY-h2+10,hi,"pdim txt txtmid")gT[#gT+1]=c7(centerX,centerY-15,"Yaw","pdim txt txtmid")gT[#gT+1]=c7(centerX,centerY+20,hg,"pdim txt txtmid")else gT[#gT+1]=c7(centerX,centerY-h2,hj,"pdim txt txtmid")gT[#gT+1]=c7(centerX,centerY-h2+15,hi,"pdim txt txtmid")end end end end;local function hl(gT,dg,bL)local hm=altMeterX;local hn=altMeterY;local ho=78;local hp=19;local hq=an;if an~=-1 then gT[#gT+1]=c7(hm+ho,hn+hp+20,e("AGL: %.1fm",an),"pdim altsm txtend")end;if bL and(dg<200000 and not ap or dg and ap)then table.insert(gT,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hm-1,hn-4,ho+2,hp+6,hm+1,hn-1,ho-4,hp))local fJ=0;local hr=1;local hs=0;local ht=dg<0;local hu=dg<planet.surfaceMaxAltitude;local hv=9;if ht then hv=0 end;local dg=c(dg)while fJ<6 do local hw=11;local hx=16;local hy=9;local hz=14;local cb="altsm"if fJ>2 then hx=hx+3;hw=hw+2;hz=hz+2;hy=hy-6;cb="altbig"end;if ht then cb=cb.." red"elseif hu then cb=cb.." orange"end;local hA=dg/hr%10;local hB=d(hA)local hC=d((hB+1)%10)local hD=hs;if fJ==0 then hD=hA-hB;if ht then hD=1-hD end end;if ht and(fJ==0 or hs~=0)then local hE=hC;hC=hB;hB=hE end;local hF=hx*(hD-1)local hG=hF+hx;local c8=hm+hy+(6-fJ)*hw;local c9=hn+hz;gT[#gT+1]=c7(c8,c9+hF,hC,cb)gT[#gT+1]=c7(c8,c9+hG,hB,cb)fJ=fJ+1;hr=hr*10;if hB==hv then hs=hD else hs=0 end end;table.insert(gT,[[</g></g>]])end end;local function hH(ez)local hI=-math.deg(m(ez.y,ez.z))+180;hI=hI-90;if hI<0 then hI=360+hI end;if hI>180 then hI=-180+hI-180 end;return-hI end;local function hJ(ez)local h6=math.deg(m(ez.y,ez.x))-90;if h6<-180 then h6=360+h6 end;return h6 end;local function hK(gT,ez,ew,centerX,centerY)if ew>5 and not ap or ew>P then local h2=circleRad;local hL=20;local hM=20;local hN=hH(ez)local hO=hJ(ez)local hP=14;local hQ=hP/2;local hR=-hO/hM*h2;local hS=hN/hL*h2;local c8=centerX+hR;local c9=centerY+hS;local ai=w(hR^2+hS^2)local hT=[[<circle
                            cx="]]..c8 ..[["
                            cy="]]..c9 ..[["
                            r="]]..hQ/hP..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c8 ..[["
                            cy="]]..c9 ..[["
                            r="]]..hQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c8-hP..[[,]]..c9 ..[[ h ]]..hQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c8+hQ..[[,]]..c9 ..[[ h ]]..hQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c8 ..[[,]]..c9-hP..[[ v ]]..hQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ai<h2 then gT[#gT+1]=hT else local gU=m(hS,hR)local hU=4;local hV=centerX+h2*math.cos(gU)local hW=centerY+h2*math.sin(gU)gT[#gT+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gU*180/math.pi,hV,hW,hV-hU,hW-hU/2,hU*2,hU,hV+hU,hW-hU,hU,hU,-hU,hU)end;if not ap then local hX=vec3(ez)hN=hH(-hX)hO=hJ(-hX)hR=-hO/hM*h2;hS=hN/hL*h2;c8=centerX+hR;c9=centerY+hS;ai=w(hR^2+hS^2)if ai<h2 then local hY=[[<circle
                                    cx="]]..c8 ..[["
                                    cy="]]..c9 ..[["
                                    r="]]..hQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c8 ..[[,]]..c9-hP..[[ v ]]..hQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c8 ..[[,]]..c9 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c8 ..[[,]]..c9 ..[[)" />
                                <path
                                    d="M ]]..c8-hQ..[[,]]..c9 ..[[ h ]]..hP..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c8 ..[[,]]..c9 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c8 ..[[,]]..c9 ..[[)"/>]]gT[#gT+1]=hY end end end end;local function hZ(gT,gk,h_,i0)h_=d(h_+0.5)local gI=throtPosY+10;local gJ=throtPosY+20;if l()==1 and not RemoteHud then gI=55;gJ=65 end;local i1="CRUISE"local unit="km/h"local ce=i0;if gk=="TRAVEL"or gk=="AUTOPILOT"then i1="THROT"unit="%"ce=h_;local i2="dim"if h_<0 then i2="red"end;gT[#gT+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i2,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(h_),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gT[#gT+1]=c7(throtPosX+10,gI,i1,"pbright txtstart")gT[#gT+1]=c7(throtPosX+10,gJ,e("%.0f %s",ce,unit),"pbright txtstart")if ap and AtmoSpeedAssist and bA and L then h_=d(M*100+0.5)local i2="red"if h_<0 then i2="red"end;gT[#gT+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i2,1-c(h_),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gT[#gT+1]=c7(throtPosX+10,gI+40,"LIMIT","pbright txtstart")gT[#gT+1]=c7(throtPosX+10,gJ+40,h_.."%","pbright txtstart")end;if ap and AtmoSpeedAssist or Reentry then gT[#gT+1]=c7(throtPosX+10,gI-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not ap and Autopilot then gT[#gT+1]=c7(throtPosX+10,gI-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i3(gT,i4)local i5=throtPosY-10;local i6=throtPosX+10;gT[#gT+1]=c7(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then i5=75 end;gT[#gT+1]=c7(i6,i5,d(i4).." km/h","pbright txtbig txtstart")end;local function i7(gT)gT[#gT+1]=c7(gg(1900),gh(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gT[#gT+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gT[#gT+1]=c7(gg(960),gh(550),"Warning: Invalid Control Scheme Detected","warnings")gT[#gT+1]=c7(gg(960),gh(600),"Keyboard Scheme must be selected","warnings")gT[#gT+1]=c7(gg(960),gh(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local i8=gg(960)local i9=gh(860)local ia=gh(880)local ib=gh(900)local ic=gh(960)local id=gh(200)local ie=gh(250)local ig=gh(960)if l()==1 and not RemoteHud then i9=gh(135)ia=gh(155)ib=gh(175)id=gh(115)ie=gh(95)end;if BrakeIsOn then gT[#gT+1]=c7(i8,i9,"Brake Engaged","warnings")elseif K>0 then gT[#gT+1]=c7(i8,i9,"Auto-Brake Engaged","warnings","opacity:"..K)end;if ap and b2 and an==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then gT[#gT+1]=c7(i8,id+50,"** STALL WARNING **","warnings")bV("stall","SW",2)end end;if bJ then gT[#gT+1]=c7(i8,id+90,"Flight Assist in Progress","warnings")end;if aw then gT[#gT+1]=c7(i8,ig,"Gyro Enabled","warnings")end;if GearExtended then if R then gT[#gT+1]=c7(i8,ia,"Gear Extended","warn")else gT[#gT+1]=c7(i8,ia,"Landed (G: Takeoff)","warnings")end;local ih=ck(a:getTargetGroundAltitude())gT[#gT+1]=c7(i8,ib,"Hover Height: "..ih,"warn")end;if a6 then gT[#gT+1]=c7(i8,ic+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then if c(ar-antigrav.getBaseAltitude())<501 then gT[#gT+1]=c7(i8,id+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else gT[#gT+1]=c7(i8,id+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gT[#gT+1]=c7(i8,id+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gT[#gT+1]=c7(i8,id+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Z then gT[#gT+1]=c7(i8,id+20,"Follow Mode Engaged","warn")elseif Reentry or am then gT[#gT+1]=c7(i8,id+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ih=ck(HoldAltitude,2)if VertTakeOff then if by then ih=ck(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gT[#gT+1]=c7(i8,id,"VTO to "..ih,"warn")elseif AutoTakeoff and not IntoOrbit then if al then gT[#gT+1]=c7(i8,id,"Takeoff to "..AutopilotTargetName,"warn")else gT[#gT+1]=c7(i8,id,"Takeoff to "..ih,"warn")end;if BrakeIsOn and not VertTakeOff then gT[#gT+1]=c7(i8,id+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gT[#gT+1]=c7(i8,id,"Altitude Hold: "..ih,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if aq>0.1 then gT[#gT+1]=c7(i8,id+20,"Beginning ascent","warn")elseif aq<0.09 and aq>0.05 then gT[#gT+1]=c7(i8,id+20,"Aligning trajectory","warn")elseif aq<0.05 then gT[#gT+1]=c7(i8,id+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then gT[#gT+1]=c7(i8,id,b9,"warn")end end;if IntruderAlertSystem and safeMass==-1 then gT[#gT+1]=c7(i8,id+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bw.."kg DETECTED","warnings")bV("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then gT[#gT+1]=c7(i8,id,"Brake-Landing","warnings")else gT[#gT+1]=c7(i8,id,"Coast-Landing","warnings")end end;if ProgradeIsOn then gT[#gT+1]=c7(i8,id,"Prograde Alignment","crit")end;if RetrogradeIsOn then gT[#gT+1]=c7(i8,id,"Retrograde Alignment","crit")end;if bM then local type;if string.find(bM,"COLLISION")then type="warnings"else type="crit"end;gT[#gT+1]=c7(i8,ie+20,bM,type)elseif aq==0 then local bQ,bU=bO(br:normalize())if bU~=nil then local ih=ck(bU)local travelTime=aS.computeTravelTime(bs,0,bU)local ii="Collision"if bQ.noAtmosphericDensityAltitude>0 then ii="Atmosphere"end;gT[#gT+1]=c7(i8,ie+20,bQ.name.." "..ii.." "..cv(travelTime).." In "..ih,"crit")end end;if VectorToTarget and not IntoOrbit then gT[#gT+1]=c7(i8,id+35,VectorStatus,"warn")end;gT[#gT+1]="</g>"return gT end;local function ij(ew)return d(y(ew*3.6,0)+0.5).." km/h"end;local function ik(gT)local il=OrbitMapX;local im=OrbitMapY;local io=OrbitMapSize;local ip=4;local iq=15;local c8=0;local c9=0;local ir,is,it,iu;local function iv(type)local iw,C,ew,ix;if type=="Periapsis"then iw=orbit.periapsis.altitude;C=orbit.timeToPeriapsis;ew=orbit.periapsis.speed;ix=35 else iw=orbit.apoapsis.altitude;C=orbit.timeToApoapsis;ew=orbit.apoapsis.speed;ix=-35 end;gT[#gT+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c8+ix,c9-5,il+io/2-ir+iu,c9-5)gT[#gT+1]=c7(c8,c9,type)c9=c9+iq;local ih=ck(iw)gT[#gT+1]=c7(c8,c9,ih)c9=c9+iq;gT[#gT+1]=c7(c8,c9,cv(C))c9=c9+iq;gT[#gT+1]=c7(c8,c9,ij(ew))end;if orbit~=nil and aq<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then im=im+ip;c8=il+io+il/2+ip;c9=im+io/2+5+ip;ir=io/4;iu=0;gT[#gT+1]=[[<g class="pbright txtorb txtmid">]]gT[#gT+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',io+il*2,io+im,ip,ip)if orbit.periapsis~=nil and orbit.apoapsis~=nil then it=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(ir*2)is=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/it*(1-orbit.eccentricity)iu=ir-orbit.periapsis.altitude/it-planet.radius/it;local iy=""if orbit.periapsis.altitude<=0 then iy='redout'end;gT[#gT+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iy,il+io/2+iu+ip,im+io/2+ip,ir,is)gT[#gT+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',il+io/2+ip,im+io/2+ip,planet.radius/it)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iv("Apoapsis")end;c9=im+io/2+5+ip;c8=il-il/2+10+ip;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iv("Periapsis")end;gT[#gT+1]=c7(il+io/2+ip,planet.name,20+ip,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iz=orbit.timeToApoapsis/orbit.period*2*math.pi;local iA=ir*math.cos(iz)local iB=is*math.sin(iz)gT[#gT+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',il+io/2+iA+iu+ip,im+io/2+iB+ip)end;gT[#gT+1]=[[</g>]]return gT else return gT end end;local function iC(gT)local c8=30;local c9=275;local iD={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local iE={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iF={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iG={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and offset","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if ap then bY(iD,iE)table.insert(iD,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(iD,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if an~=-1 then if antigrav then if by then table.insert(iD,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iD,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iD,"Alt-6: Begins Vertical Takeoff.")else table.insert(iD,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(iD,"G: Begin BrakeLanding or Land")end else bY(iD,iF)end;if AltitudeHold then table.insert(iD,"Alt-Spacebar/Alt-C will raise/lower target height")end;bY(iD,iG)for i=1,#iD do c9=c9+12;gT[#gT+1]=c7(c8,c9,iD[i],"pdim txttick txtstart")end end;local function iH(iI,iJ)local iK;local iL=(iJ-iI):normalize()local eB=(bv-iI):dot(iL)/iL:dot(iL)if eB<=0.then return(bv-iI):len()elseif eB>=(iJ-iI):len()then return(bv-iJ):len()end;local iM=iI+eB*iL;iK=(iM-bv):len()return iK end;local function iN()local iK;local iO=nil;local iP=nil;local iQ=nil;for cE,iR in pairs(aM[0])do if iR.hasAtmosphere then local ai=iH(planet.center,iR.center)if iO==nil or ai<iO then iP=iR;iO=ai;iQ=planet end;if ab and ab.hasAtmosphere and ab.name~=planet.name then local dX=iH(ab.center,iR.center)if dX<iO then iP=iR;iO=dX;iQ=ab end end end end;local iS=gg(1770)local iT=gh(330)if iO then local iU="txttick "local iV=500000;if iO<iP.radius+iV or iO<iQ.radius+iV then if bH then iU="txttick red "else iU="txttick orange "end end;iK=ck(iO,2)bI=c7(iS,iT,"Pipe ("..iQ.name.."--"..iP.name.."): "..iK,iU.."pbright txtmid")end end;local iW={}function iW.HUDPrologue(gT)bH,g7=ge(bv)if not bH then G=PvPR;I=PvPG;H=PvPB else G=SafeR;I=SafeG;H=SafeB end;ax=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]ay=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local iX=ax;local iY=ay;local iZ=ax;local i_=ay;if gi()and not brightHud then iX=[[rgb(]]..d(G*0.4+0.5)..","..d(I*0.4+0.5)..","..d(H*0.3+0.5)..[[)]]iY=[[rgb(]]..d(G*0.3+0.5)..","..d(I*0.3+0.5)..","..d(H*0.2+0.5)..[[)]]end;gT[#gT+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],iX,iX,iZ,iZ,iY,iY,i_,i_,aF,aG)return gT end;function iW.DrawVerticalSpeed(gT,dg)gS(gT,dg)end;function iW.UpdateHud(gT)local hI=bB;local j0=bC;local h0=j0;local hf=hI;local h_=d(unit.getThrottle())local i4=bs*3.6;local i0=unit.getAxisCommandValue(0)local j1=gg(1770)local j2=gh(310)if AtmoSpeedAssist and bA then i0=J;h_=J*100 end;local gk=gj()local h1="ROLL"if h_==nil then h_=0 end;if not bL then if bs>5 then hI=hH(bq)j0=hJ(bq)else hI=0;j0=0 end;h1="YAW"end;if g7>50000 and not ap then local j3;j3=ck(g7)gT[#gT+1]=c7(j1,j2,"PvP Boundary: "..j3,"pbright txtbig txtmid")end;gT[#gT+1]=aj;gT[#gT+1]=aC;gT[#gT+1]=gl;if bI~=""then gT[#gT+1]=bI end;if gm~=""then gT[#gT+1]=gm end;gS(gT,ar)if l()==0 or RemoteHud then if not gi()or brightHud then if bL then g_(gT,centerX,centerY,h0,h1,bL)he(gT,hf,h0,centerX,centerY,bL,d(hJ(bq)),bs)else g_(gT,centerX,centerY,j0,h1,bL)he(gT,hI,j0,centerX,centerY,bL,d(j0),bs)end;hl(gT,ar,bL)hK(gT,bq,bs,centerX,centerY)end end;hZ(gT,gk,h_,i0)i3(gT,i4)i7(gT)ik(gT)if showHelp then iC(gT)end;return gT end;function iW.HUDEpilogue(gT)gT[#gT+1]="</svg>"return gT end;function iW.ExtraData(gT)local j4=gg(1240)local j5=gh(55)local j6=j5+10;local j7;local j8=0;local gk=gj()if VertTakeOffEngine then gk=gk.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bs>20 then gk=gk.."-COLLISION ON"end;if TurnBurn then gk="TB-"..gk end;if not stablized then gk=gk.."-DeCoupled"end;local j9=vec3(core.getWorldAcceleration()):len()/9.80665;j7=core.g()gT[#gT+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then j4=gg(1120)j5=gh(55)j6=j5+10 elseif ap then local ja=gg(770)gT[#gT+1]=c7(ja,j5,"ATMOSPHERE","pdim txt txtend")gT[#gT+1]=c7(ja,j6,e("%.2f",aq),"pdim txt txtend","")end;gT[#gT+1]=c7(j4,j5,"GRAVITY","pdim txt txtend")gT[#gT+1]=c7(j4,j6,e("%.2f",j7/9.80665),"pdim txt txtend")gT[#gT+1]=c7(j4,j5+20,"ACCEL","pdim txt txtend")gT[#gT+1]=c7(j4,j6+20,e("%.2f",j9),"pdim txt txtend")gT[#gT+1]=c7(gg(960),gh(180),gk,"txtbig txtmid")end;function iW.DrawOdometer(gT,ac,TotalDistanceTravelled,ad)local j7;local jb=0;local jc=0;local j8=0;if ap then j8=LastMaxBrakeInAtmo else j8=LastMaxBrake end;local jd=a:maxForceForward()j7=core.g()if j7>0.1 then jc=au*j7;jb=jd/j7 end;gT[#gT+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gg(660),gg(700),gh(35),gg(960),gh(55),gg(1240),gh(35),gg(1280))if l()==0 or RemoteHud then gT[#gT+1]=c7(gg(700),gh(20),e("Trip: %.2f km",ac),"txtstart")gT[#gT+1]=c7(gg(700),gh(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gT[#gT+1]=c7(gg(830),gh(20),"Trip Time: "..cv(ad),"txtstart")gT[#gT+1]=c7(gg(830),gh(30),"Total Time: "..cv(TotalFlightTime),"txtstart")gT[#gT+1]=c7(gg(970),gh(20),e("Mass: %.2f Tons",au/1000),"txtstart")gT[#gT+1]=c7(gg(1240),gh(10),e("Max Brake: %.2f kN",j8/1000),"txtend")gT[#gT+1]=c7(gg(1240),gh(30),e("Max Thrust: %.2f kN",jd/1000),"txtend")if j7>0.1 then gT[#gT+1]=c7(gg(970),gh(30),e("Max Mass: %.2f Tons",jb*0.5/1000),"txtstart")gT[#gT+1]=c7(gg(1240),gh(20),e("Req Thrust: %.2f kN",jc/1000),"txtend")else gT[#gT+1]=c7(gg(970),gh(30),"Max Mass: n/a","txtstart")gT[#gT+1]=c7(gg(1240),gh(20),"Req Thrust: n/a","txtend")end end;gT[#gT+1]="</g>"return gT end;function iW.DrawWarnings(gT)return i7(gT)end;function iW.DisplayOrbitScreen(gT)return ik(gT)end;function iW.DisplayMessage(gT,ih)if ih~="empty"then local c9=310;for je in string.gmatch(ih,"([^\n]+)")do c9=c9+35;gT[#gT+1]=c7("50%",c9,je,"msg")end end;if ah~=0 then unit.setTimer("msgTick",ah)ah=0 end end;function iW.DrawDeadZone(gT)gT[#gT+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function iW.UpdatePipe()if ap then bI=""return end;iN()end;function iW.DrawSettings(gT)if#bE>0 then local c8=gg(640)local c9=gh(200)gT[#gT+1]=[[<g class="pbright txtvspd txtstart">]]for cE,cF in pairs(bE)do gT[#gT+1]=c7(c8,c9,cF..": ".._G[cF])c9=c9+20;if cE%12==0 then c8=c8+gg(350)c9=gh(200)end end;gT[#gT+1]=c7(gg(640),gh(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gT[#gT+1]="</g>"end;return gT end;local jf;local jg=gg(1770)local jh=gh(350)local ji=gh(15)local jj=gg(1370)local jk,jl;local jm=0;function iW.DrawRadarInfo()local function jn()if radarPanelID~=nil and jm==0 then r(radarPanelID)radarPanelID=nil;if jf~=nil then r(jf)jf=nil end else if jm==1 then r(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jf=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;jm=0 end end;local f1,f2,f0,f3,f4,eY=aY.GetRadarHud()local z=f3 or 0;if f0>0 then if CollisionSystem then jk=z.."/"..f4 .." Plotted : "..f0-f4 .." Ignored"else jk="Radar Contacts: "..f0 end;gl=c7(jg,jh,jk,"pbright txtbig txtmid")if#eY>0 then gl=gl..c7(jj,ji,"Friendlies In Range","pbright txtbig txtmid")for cE,cF in pairs(eY)do ji=ji+20;gl=gl..c7(jj,ji,radar_1.getConstructName(cF),"pdim txtmid")end;eY={}end;if f1==nil and jf==nil then jm=1;jn()end;if f1~=nil and jf~=nil then jn()end;if radarPanelID==nil then jn()end else if f2 then gl=c7(jg,jh,"Radar: Jammed","pbright txtbig txtmid")else gl=c7(jg,jh,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then jm=0;jn()end end end;function iW.DrawTanks()if fuelX~=0 and fuelY~=0 then gm=c7(fuelX,fuelY,"","txtstart pdim txtfuel")gC(fuelX,"Atmospheric ","ATMO",aH,gA,gB)gC(fuelX+120,"Space fuel t","SPACE",aI,gy,gz)gC(fuelX+240,"Rocket fuel ","ROCKET",aJ,gw,gx)end end;return iW end;local function jo()local function jp(position)local db=sys:closestBody(position)if(position-db.center):len()>db.radius+db.noAtmosphericDensityAltitude then db=aM[0][0]end;return db end;local function jq()local function jr(js,jt)return js.name<jt.name end;bG={}for cE,cF in pairs(aM[0])do bG[#bG+1]={name=cF.name,index=cE}end;table.sort(bG,jr)end;local function ju(jv)for cE,cF in pairs(jv)do if cF.name and cF.name==CustomTarget.name then return cE end end;return-1 end;local function jw()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ab=nil;CustomTarget=nil;return true end;local jx=bG[AutopilotTargetIndex].index;local jy=aM[0][jx]if jy.center then AutopilotTargetName=jy.name;ab=aR[0][jx]if CustomTarget~=nil then if aq==0 then if s(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if s(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if s(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then t(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if s(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if s(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if s(widgetMaxMassText,widgetMaxMass)~=1 then t(widgetMaxMassText,widgetMaxMass)end;if s(widgetTravelTimeText,widgetTravelTime)~=1 then t(widgetTravelTimeText,widgetTravelTime)end;if s(widgetTargetOrbitText,widgetTargetOrbit)~=1 then t(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jy;for _,cF in pairs(aR[0])do if cF.name==CustomTarget.planetname then ab=cF;AutopilotTargetName=CustomTarget.name;break end end;if s(widgetMaxMassText,widgetMaxMass)~=1 then t(widgetMaxMassText,widgetMaxMass)end;if s(widgetTravelTimeText,widgetTravelTime)~=1 then t(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ab.center)else AutopilotTargetCoords=CustomTarget.position end;if ab.planetname~="Space"then if ab.hasAtmosphere then AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ab):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jz(gX)if not Autopilot and not VectorToTarget and not al and not IntoOrbit then if gX==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then jw()else local jx=bG[AutopilotTargetIndex].index;local jy=aM[0][jx]if jy~=nil and jy.name=="Space"or iphCondition=="Custom Only"and jy.center or iphCondition=="No Moons"and string.find(jy.name,"Moon")~=nil then if gX==nil then jz()else jz(1)end else jw()end end else a1="Disengage autopilot before changing Interplanetary Helper"bV("iph","AP")end end;local function jA()local fJ=-1;fJ=ju(aM[0])if fJ>-1 then table.remove(aM[0],fJ)end;fJ=-1;fJ=ju(SavedLocations)if fJ~=-1 then a1=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fJ)end;jz()jq()end;local function jB(fY,position,hE,jC)if dbHud_1 or hE then local db=jp(position)local j7=db.gravity;local jD=db.atmosphericDensityAboveSurface;if jC then jD=aq;j7=unit.getClosestPlanetInfluence()end;local jE={position=position,name=fY,atmosphere=jD,planetname=db.name,gravity=j7,safe=jC}if not hE then SavedLocations[#SavedLocations+1]=jE else for cE,cF in pairs(aM[0])do if cF.name and fY==cF.name then table.remove(aM[0],cE)end end end;table.insert(aM[0],jE)jq()jw()a1="Location saved as "..fY.."("..db.name..")"else a1="Databank must be installed to save permanent locations"end end;local cG={}function cG.UpdateAtlasLocationsList()jq()end;function cG.UpdateAutopilotTarget()jw()end;function cG.adjustAutopilotTargetIndex(gX)jz(gX)end;function cG.findAtlasIndex(jv)ju(jv)end;function cG.UpdatePosition(jF)local fJ=ju(SavedLocations)if fJ~=-1 then if jF~=nil then SavedLocations[fJ].name=jF;AutopilotTargetIndex=AutopilotTargetIndex-1;jz()else local jG=SavedLocations[fJ]jG.atmosphere=aq;jG.gravity=unit.getClosestPlanetInfluence()jG.position=bv;jG.safe=true end;a1=SavedLocations[fJ].name.." position updated ("..SavedLocations[fJ].planetname..")"else a1="Name Not Found"end end;function cG.AddNewLocation(fY,position,hE,jC)jB(fY,position,hE,jC)end;function cG.ClearCurrentPosition()jA()end;for cE,cF in pairs(SavedLocations)do table.insert(aM[0],cF)end;jq()cG.UpdateAutopilotTarget()return cG end;local function jH()local jI={}local function jJ(ew)local jK=AutopilotEndSpeed;if not Autopilot then jK=0 end;if not ap then return aS.computeDistanceAndTime(ew,jK,au,0,0,LastMaxBrake-AutopilotPlanetGravity*au)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(ew,jK,au,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*au)else return 0,0 end end end;local function jL(ew)local jK=AutopilotEndSpeed;if not Autopilot then jK=0 end;return aS.computeDistanceAndTime(ew,jK,au,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*au)end;local jM=false;function jI.GetAutopilotBrakeDistanceAndTime(ew)return jJ(ew)end;function jI.GetAutopilotTBBrakeDistanceAndTime(ew)return jL(ew)end;local function jN(jO,jP,jQ)jP=jP:project_on_plane(jO)jQ=jQ:project_on_plane(jO)return m(jP:cross(jQ):dot(jO),jP:dot(jQ))end;local function jR()local function jS()local jT=-1;local jU=-1;if vBooster then jT=vBooster.distance()end;if hover then jU=hover.distance()end;if jT~=-1 and jU~=-1 then if jT<jU then return jT else return jU end elseif jT~=-1 then return jT elseif jU~=-1 then return jU else return-1 end end;local jV=jS()local jW=-1;if telemeter_1 then jW=telemeter_1.getDistance()end;if jV~=-1 and jW~=-1 then if jV<jW then return jV else return jW end elseif jV~=-1 then return jV else return jW end end;local function jX(planet,dT,jY)local function jZ(j_,d9)local dZ=vec3(d9)if j_.bodyId==0 then return setmetatable({latitude=dZ.x,longitude=dZ.y,altitude=dZ.z,bodyId=0,systemId=j_.planetarySystemId},MapPosition)end;local d_=dZ-j_.center;local ai=d_:len()local dg=ai-j_.radius;local de=0;local df=0;if not ch(ai,0)then local e0=m(d_.y,d_.x)df=e0>=0 and e0 or 2*math.pi+e0;de=math.pi/2-math.acos(d_.z/ai)end;return setmetatable({latitude=math.deg(de),longitude=math.deg(df),altitude=dg,bodyId=j_.bodyId,systemId=j_.planetarySystemId},MapPosition)end;local k0=jZ(planet,dT)k0="::pos{"..k0.systemId..","..k0.bodyId..","..k0.latitude..","..k0.longitude..","..k0.altitude.."}"if jY then return k0 else system.setWaypoint(k0)return true end end;local k1=false;function jI.showWayPoint(planet,dT,jY)return jX(planet,dT,jY)end;function jI.APTick()local function k2()if bN and not BrakeLanding then local bT=bN[1]local fZ,f_=bN[2],bN[3]local k3=math.min(fZ,f_ or fZ)local k4=k3/bs;local k5=AutoTakeoff and(bs<42 or an~=-1)local k6=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if k6 and not k5 and(a7*1.5>k3 or k4<1)then BrakeIsOn=true;cd(0)if AltitudeHold then cp()end;if LockPitch then ToggleLockPitch()end;a1="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cq()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if k4<11 then bM=bT.name.." COLLISION "..cv(k4).." / "..ck(k3,2)else bM=bT.name.." collision "..cv(k4)end;if k4<6 then bV("alarm","AL",2)end else bM=false end end;local function k7(bP,k8,k9)local function ka(bP,dF)bP=vec3(bP)dF=vec3(dF):normalize()local cW=bP*dF;return cW.x+cW.y+cW.z end;local kb=0.001;local kc=1;if not ap or not b2 or an~=-1 or bs<P then if k9==nil then k9=DampingMultiplier end;if k8==nil then k8=kb end;bP=vec3(bP):normalize()local kd=vec3()-bP;local ke=-ka(kd,core.getConstructWorldOrientationRight())*kc;local kf=-ka(kd,core.getConstructWorldOrientationUp())*kc;if aA==0 then aA=ke/2 end;if aB==0 then aB=kf/2 end;if c(ke)<0.1 then U=U-ke*2 else U=U-(ke+(ke-aA)*k9)end;if c(kf)<0.1 then T=T+kf*2 else T=T+kf+(kf-aB)*k9 end;aA=ke;aB=kf;if c(ke)<k8 and c(kf)<k8 then return true end;return false elseif b2 and an==-1 then bP=br;if k9==nil then k9=DampingMultiplier end;if k8==nil then k8=kb end;bP=vec3(bP):normalize()local kd=bo-bP;local ke=-ka(kd,core.getConstructWorldOrientationRight())*kc;local kf=-ka(kd,core.getConstructWorldOrientationUp())*kc;if aA==0 then aA=ke/2 end;if aB==0 then aB=kf/2 end;if c(ke)<0.1 then U=U-ke*5 else U=U-(ke+(ke-aA)*k9)end;if c(kf)<0.1 then T=T+kf*5 else T=T+kf+(kf-aB)*k9 end;aA=ke;aB=kf;if c(ke)<k8 and c(kf)<k8 then return true end;return false end end;ap=j()>0;aq=j()ar=core.getAltitude()an=jR()C=o()b3=C;bL=unit.getClosestPlanetInfluence()>0;if CollisionSystem then k2()end;if antigrav then by=antigrav.getState()==1 end;local kg=1;local kh=1;local ki=C-b3;local kj=-math.deg(jN(bn,br,bo))local kk=math.deg(jN(bp,br,bo))local gX=bt*-1;b2=ap and kj<-YawStallAngle or kj>YawStallAngle or kk<-PitchStallAngle or kk>PitchStallAngle;local kl=system.getMouseDeltaX()local km=system.getMouseDeltaY()if InvertMouse and not a0 then km=-km end;U=0;Y=0;T=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if ar==0 then ar=(bv-planet.center):len()-planet.radius end;local j7=planet:getGravity(core.getConstructWorldPos()):len()*au;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if v()==0 then if l()==1 and a0 then if not aZ then af=af+kl;ag=ag+km end else af=0;ag=0 end else af=af+kl;ag=ag+km;ai=w(af*af+ag*ag)if not a0 and l()==0 then if userControlScheme=="virtual joystick"then if af>0 and af>DeadZone then U=U-(af-DeadZone)*MouseXSensitivity elseif af<0 and af<DeadZone*-1 then U=U-(af+DeadZone)*MouseXSensitivity else U=0 end;if ag>0 and ag>DeadZone then T=T-(ag-DeadZone)*MouseYSensitivity elseif ag<0 and ag<DeadZone*-1 then T=T-(ag+DeadZone)*MouseYSensitivity else T=0 end else af=0;ag=0;if userControlScheme=="mouse"then T=(-utils.smoothstep(km,-100,100)+0.5)*2*kg;U=(-utils.smoothstep(kl,-100,100)+0.5)*2*kh end end end end;local kn=bs>8334;if bs>SpaceSpeedLimit/3.6 and not ap and not Autopilot and not kn then a1="Space Speed Engine Shutoff reached"cd(0)end;if not kn and LastIsWarping then if not BrakeIsOn then cs()end;if Autopilot then cq()end end;LastIsWarping=kn;if ap and aq>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not jM then BrakeIsOn=true;jM=true elseif not AtmoSpeedAssist and jM then if bs<b7/3.6 then BrakeIsOn=false;jM=false end end end;if BrakeIsOn then X=1 else X=0 end;if ProgradeIsOn then if ak then BrakeIsOn=false;local ko=false;if CustomTarget~=nil and ak~=1 then ko=k7(CustomTarget.position-bv,0.1)else ko=k7(vec3(br),0.01)end;b0=true;if ko then cg(d(b7))if(c(bC)<2 or c(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;Q=true;if ak~=1 then am=true end;ak=false;Autopilot=false;ct()end elseif ap and AtmoSpeedAssist then cd(1)end elseif bs>P then k7(vec3(br),0.01)end end;if RetrogradeIsOn then if ap then RetrogradeIsOn=false elseif bs>P then k7(-vec3(br))end end;if not ProgradeIsOn and ak and not IntoOrbit then if aq==0 then Q=true;ct()ak=false;am=true else ak=false;cq()end end;if am and CustomTarget~=nil and(ar<HoldAltitude+250 and ar>HoldAltitude-250)and bs*3.6>b7-250 and c(bu)<25 and aq>=0.1 and(CustomTarget.position-bv):len()>2000+ar then cq()am=false end;if VertTakeOff then b0=true;local kp=HoldAltitude;if bu<-30 then a1="Unable to achieve lift. Safety Landing."ae=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then kp=antigrav.getBaseAltitude()end;if ar<kp-100 then b8=0;ae=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;ae=0 elseif bu<-30 then BrakeIsOn=true;ae=15 elseif ar>=kp then if by then if Autopilot or VectorToTarget then cn()else BrakeIsOn=true;VertTakeOff=false end;a1="Takeoff complete. Singularity engaged"bV("aggLk","AG")else BrakeIsOn=false;a1="VTO complete. Engaging Horizontal Flight"bV("vtoc","VT")cn()end;ae=0 end else if aq>0.08 then b8=0;BrakeIsOn=false;ae=20 elseif aq<0.08 and aq>0 then BrakeIsOn=false;if bk then b8=0;ae=20 else ae=0;b8=36;cg(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=kp;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kq=p(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kq)local kr=p(vTpitchPID:get(),-1,1)T=kr end end;if IntoOrbit then local kd;local ks=false;local kt=ck(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ab end end;if not bf then bg=d(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=d(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget then kd=CustomTarget.position-bv end;local ku,kv=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local kw=bC;if not bc then local kx=false;local ky=false;cd(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..kt;if be.VectorToTarget then k7(kd:normalize():project_on_plane(bt))ks=bo:dot(kd:project_on_plane(bn):normalize())>0.95 else k7(br)ks=kj<0.5;if bs<150 then ks=true end end;T=0;ba=0;if bB<=ba+1 and bB>=ba-1 then kx=true else kx=false end;if kw<=bb+1 and kw>=bb-1 then ky=true else ky=false end;if kx and ky and ks then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then k7(kd:normalize():project_on_plane(bt))elseif bs>150 then k7(br)end;T=0;if be.VectorToTarget then local a7,_=aS.computeDistanceAndTime(bs,b7/3.6,au,0,0,LastMaxBrake)if bi and kd:len()>15000+a7+ar then b9="Orbiting to Target"if ar-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or kd:len()<15000+a7+ar then a1="Orbit complete, proceeding with reentry"bV("orCom","OB")AutopilotTargetCoords=CustomTarget.position;Q=true;am=true;be.VectorToTarget,be.AutopilotAlign=false,false;co()ct()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and ar>bg*0.9 and ar<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;cd(0)ba=0;if not be.VectorToTarget then a1="Orbit complete"bV("orCom","OB")co()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..kt;bd=true;cg(kv*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kz=bu;local kA=ar-bg;local kB=c(kA)if bu<10 and c(bB)<10 and kB<100 then kz=bu*2 end;if kz<10 and c(bB)<10 and kB<100 then kz=kz*2 end;if kz<5 and c(bB)<5 and kB<100 then kz=kz*4 end;VSpdPID:inject(kz)ba=p(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kA)ba=p(ba-p(OrbitAltPID:get(),-15,15),-90,90)end end else local kC=2.75;local kD=c(y(ku*kC))local kE=kD%50;if kE>0 then kD=kD-kE+50 end;BrakeIsOn=false;if ar<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..kt;ba=utils.map(bu,200,0,-15,80)elseif ar>=bg*0.8 and ar<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..kt;kD=kD*0.75;ba=utils.map(bu,100,-100,-15,65)elseif ar>=bg*1.15 and ar<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..kt;kD=kD*0.75;if bu<0 or bd then ba=utils.map(ar,bg*1.5,bg*1.01,-30,0)else ba=utils.map(ar,bg*0.99,bg*1.5,0,30)end elseif ar>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..kt;ba=-65;local kF=utils.map(bu,-150,-400,1,0.55)kD=kD*kF end;cg(d(kD))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kG=ba-bB;OrbitPitchPID:inject(kG)local kH=p(OrbitPitchPID:get(),-0.5,0.5)T=kH end end;if Autopilot and aq==0 and not ak then local function kI(jk,orbit)system.print(jk)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cd(0)O=false;a1=jk;bV("apCom","AP")if orbit or ak then if orbit and AutopilotTargetOrbit~=nil and not ak then if not ar or ar==0 then return end;bg=ar;bf=true end;co()end end;local kJ,kK=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kL=(CustomTarget.position-ab.center):normalize()local kM=kL:project_on_plane((ab.center-bv):normalize()):normalize()local kN=ab.center+kM*(ab.radius+AutopilotTargetOrbit)local kO=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))if(bv-kN):len()<(bv-kO):len()then kJ=kN else kJ=kO;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kJ;aX.showWayPoint(ab,AutopilotTargetCoords)kK=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kK=true;TargetSet=true;AutopilotRealigned=true;kJ=CustomTarget.position+(bv-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kL=(bv+br*100000-ab.center):normalize()local kM=kL:project_on_plane((ab.center-bv):normalize()):normalize()if kM:len()<1 then kL=(bv+bo*100000-ab.center):normalize()kM=kL:project_on_plane((ab.center-bv):normalize()):normalize()end;kJ=ab.center+kM*(ab.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kJ;TargetSet=true;kK=true;AutopilotRealigned=true;aX.showWayPoint(ab,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kJ)-bv):len()local bQ,bR,bS=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(bT)if bT.noAtmosphericDensityAltitude>0 then return bT.radius+bT.noAtmosphericDensityAltitude else return bT.radius+bT.surfaceMaxAltitude*1.5 end end)local bU=bR;if bS~=nil and bR~=nil then bU=math.min(bS,bR)end;if bU~=nil and bU<AutopilotDistance and bQ.name==ab.name then AutopilotDistance=bU end;local ko=true;local kP=(ab.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ab.radius;local ih=ck(kP)s(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ih..'"}')local a7,a8;if not TurnBurn then a7,a8=jJ(bs)else a7,a8=jL(bs)end;if bs>300 and AutopilotAccelerating then local kd=vec3(kJ)-bv;local kQ=p(math.deg(jN(bn,br:normalize(),kd:normalize()))*bs/500,-90,90)local kR=p(math.deg(jN(bp,br:normalize(),kd:normalize()))*bs/500,-90,90)if c(kQ)<20 and c(kR)<20 then kQ=kQ*2;kR=kR*2 end;if c(kQ)<2 and c(kR)<2 then kQ=kQ*2;kR=kR*2 end;local kj=-math.deg(jN(bn,bo,br:normalize()))local kk=-math.deg(jN(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kR-kk)local kS=p(apPitchPID:get(),-1,1)T=T+kS;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kQ-kj)local kT=p(apYawPID:get(),-1,1)U=U+kT;kK=true;if c(kQ)>2 or c(kR)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bV("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bV("apAcc","AP")end end end;if kP<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ab):escapeAndOrbitalSpeed(kP)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bQ,bU=bO((AutopilotTargetCoords-bv):normalize())if ab.name~=planet.name then if bQ~=nil then a1="Collision with "..bQ.name.." in "..ck(bU).."\nClear LOS to continue."ah=5;k1=true else k1=false;a1=""end end end;if not k1 then if not AutopilotCruising and not AutopilotBraking and not kK then ko=k7((kJ-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then ko=k7(-vec3(br):normalize())end end;if AutopilotAccelerating then if not O then BrakeIsOn=false;cd(AutopilotInterplanetaryThrottle)J=y(AutopilotInterplanetaryThrottle,2)O=true end;local kU=unit.getThrottle()if AtmoSpeedAssist then kU=J end;if bq:len()>=MaxGameVelocity or kU==0 and O then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bV("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cd(0)end;if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bV("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cd(0)O=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;X=1 end;if TurnBurn then cd(1,true)end;local _,kv=aU(ab):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local kd;if CustomTarget~=nil then kd=CustomTarget.position-bv end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bs<50 then kI("Autopilot complete, arrived at space location")BrakeIsOn=true;X=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bs<=kv and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kI("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;ak=true;aX.showWayPoint(ab,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bV("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=kv then if CustomTarget~=nil then if br:normalize():dot(kd:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bV("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ab,CustomTarget.position)WaypointSet=true end else kI("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;ak=true;aX.showWayPoint(ab,CustomTarget.position)WaypointSet=false end else kI("Autopilot completed, setting orbit",true)X=0 end end elseif AutopilotStatus=="Circularizing"then kI("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bV("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kU=unit.getThrottle()if AtmoSpeedAssist then kU=J end;if kU>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bV("apAcc","AP")end;AutopilotCruising=false end else if ko then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not ak then AutopilotTargetCoords=vec3(ab.center)+(AutopilotTargetOrbit+ab.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif ko and not k1 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bV("apAcc","AP")end;if not O then cd(AutopilotInterplanetaryThrottle,true)J=y(AutopilotInterplanetaryThrottle,2)O=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and aq>0)then a1="Autopilot complete, starting reentry"bV("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"X=0;cd(0)O=false;ProgradeIsOn=true;ak=true;aX.showWayPoint(ab,CustomTarget.position)end;if Z then b0=true;local kR=0;local eA=bv+vec3(unit.getMasterPlayerRelativePosition())local kV=eA-bv;local kW=vec3(kV):project_on(bo):len()local kX=vec3(kV):project_on(bp):len()local ai=w(kW*kW+kX*kX)k7(kV:normalize())local kY=40;local kZ=ai<kY;local k_=100;local l0=p((ai-kY)/2,10,k_)T=0;local ko=c(U)<0.1;if ko and bs<l0 and not kZ then BrakeIsOn=false;kR=-20 else BrakeIsOn=true;kR=0 end;local l1=0;if c(kR-bB)>l1 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kR-bB)local kS=pitchPID:get()T=kS end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l2=LastMaxBrakeInAtmo;if l2 then l2=l2*p(bs/100,0.1,1)*aq else l2=LastMaxBrake end;if aq<0.01 then l2=LastMaxBrake end;local l3=vec3(core.getWorldAirFrictionAcceleration())local l4=w(l3:len()-l3:project_on(gX):len())*au;if bs>100 then a7,a8=aS.computeDistanceAndTime(bs,100,au,0,0,l2+l4)local l5,l6=aS.computeDistanceAndTime(100,0,au,0,0,l2/2)a7=a7+l5 else a7,a8=aS.computeDistanceAndTime(bs,0,au,0,0,l2/2)end;local l7=HoldAltitude-ar;local l8=500+bs;local l9=1;if AutoTakeoff then l9=p(bs/100,0.1,1)end;local kR=(utils.smoothstep(l7,-l8,l8)-0.5)*2*MaxPitch*l9;if not Reentry and not ak and not VectorToTarget and bo:dot(br:normalize())<0.99 then kR=(utils.smoothstep(l7,-l8*p(20-19*aq*10,1,20),l8*p(20-19*aq*10,1,20))-0.5)*2*MaxPitch*p(2-aq*10,1,2)*l9 end;if not AltitudeHold then kR=0 end;if LockPitch~=nil then if bL and not IntoOrbit then kR=LockPitch else LockPitch=nil end end;b0=true;local la=T;if Reentry then local lb=d(b7)local lc,ld=aS.computeDistanceAndTime(bs,lb/3.6,au,0,0,LastMaxBrake-planet.gravity*9.8*au)local le=ar-(planet.noAtmosphericDensityAltitude+5000)local lf=ar>planet.noAtmosphericDensityAltitude+5000;if lf and bs<=lb/3.6 and bs>lb/3.6-10 and c(br:normalize():dot(bo))>0.9 then if not bA then cd(0)end elseif bA and not lf and not ap then cg(lb,true)end;if bA then if bs>lb/3.6 and(lc>-1 and le<=lc or not lf)then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if not Q then kR=-80;if aq>0.02 then a1="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kR=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and ar>planet.noAtmosphericDensityAltitude+5000 then b0=true elseif ar<=planet.noAtmosphericDensityAltitude+5000 then BrakeIsOn=false;if not ap and(bA or q:getTargetSpeed(axisCommandId.longitudinal)~=lb)then cg(lb)end;if bs<lb/3.6+1 then Q=false;Reentry=false;b0=true end end end;if bs>P and not al and not VectorToTarget and not BrakeLanding and ForceAlignment then k7(vec3(br))end;if bJ or(VectorToTarget or al)and AutopilotTargetIndex>0 and aq>0.01 then local kd;if bJ then if type(bJ)=="table"then kd=bJ elseif bJ<3 and bJ>0 then kd=-bt:cross(br)*5000 elseif bJ>=3 then kd=bt:cross(br)*5000 elseif bJ<0 then kd=br*25000 end elseif CustomTarget~=nil then kd=CustomTarget.position-bv else kd=ab.center-bv end;local kQ=math.deg(jN(bt:normalize(),br,kd))*2;local lg=math.rad(c(bC))if bs>minRollVelocity and aq>0.01 then local lh=p(90-kR*2,-90,90)b4=p(kQ*2,-lh,lh)local li=kQ;kQ=p(p(kQ,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(lg)+4*(bB-kR)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)kR=p(p(kR*math.cos(lg),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(p(c(li)*math.sin(lg),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;kQ=p(kQ,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lj=kj-kQ;if bJ and c(lj)<=0.0001 and(type(bJ)=="table"or type(bJ)~="table"and bJ<0 and c(bC)<1)then if bJ==-2 then cp()end;bJ=nil;bV("180Off","BR")return end;if not b2 and bs>minRollVelocity and aq>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lj)local kT=p(yawPID:get(),-1,1)U=U+kT elseif ap and an>-1 or bs<minRollVelocity then k7(kd)elseif b2 and aq>0.01 then if(kj<-YawStallAngle or kj>YawStallAngle)and aq>0.01 then k7(br)end;if(kk<-PitchStallAngle or kk>PitchStallAngle)and aq>0.01 then kR=p(bB-kk,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not al then local kp=planet:getAltitude(CustomTarget.position)local le=w(kd:len()^2-(ar-kp)^2)local lk=br:len()-c(bu)StrongBrakes=true;if not al and not Reentry and le<=a7+bs*ki/2 and(br:project_on_plane(bt):normalize():dot(kd:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cd(0)if AltitudeHold then cp()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(lk<0.1 or le<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<le)then if not by then bV("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bM=false end;LastDistanceToTarget=le end elseif VectorToTarget and aq==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(al or Reentry)then if CustomTarget~=nil and ab.name==planet.name then local kd=CustomTarget.position-bv;local kp=planet:getAltitude(CustomTarget.position)local le=w(kd:len()^2-(ar-kp)^2)local l2=LastMaxBrakeInAtmo;if l2 then a7,a8=aS.computeDistanceAndTime(bs,0,au,0,0,l2/2)StrongBrakes=true;if le<=a7+bs*ki/2 and br:project_on_plane(bt):normalize():dot(kd:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;Q=true;ak=false;am=true;Autopilot=false;ct()end end;LastDistanceToTarget=le end end end;if aq==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(al or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;co()VectorToTarget=false;bc=true end end;if b2 and aq>0.01 and an==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then k7(br)kR=p(bB-kk,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;T=la;local jW=-1;if BrakeLanding then kR=0;local ll=false;local lm=30;if aT~=nil and aT>0 then local ln=p(aq,0.4,2)local l2=LastMaxBrakeInAtmo*p(bs/100,0.1,1)*ln;local lo=aT*ln+l2-j7;local lp=l2/2-j7;local lq=bs-w(c(lp/2)*20/(0.5*au))*utils.sign(lp)if lq<0 then lq=0 end;local lr;if bs>100 then local ls,_=aS.computeDistanceAndTime(bs,100,au,0,0,l2)local lt,_=aS.computeDistanceAndTime(100,0,au,0,0,w(l2))lr=ls+lt else lr=aS.computeDistanceAndTime(bs,0,au,0,0,w(l2))end;if lr<20 then BrakeIsOn=false else local lu=0;if lq>100 then local lv,_=aS.computeDistanceAndTime(lq,100,au,0,0,lo)local lw,_=aS.computeDistanceAndTime(100,0,au,0,0,aT*ln+w(l2)-j7)lu=lv+lw else lu,_=aS.computeDistanceAndTime(lq,0,au,0,0,aT*ln+w(l2)-j7)end;lu=(lu+15+bs*ki)*1.1;local lx=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lx then local kp=planet:getAltitude(CustomTarget.position)local ly=ar-kp-100;local kd=CustomTarget.position-bv;local lz=w(kd:len()^2-(ar-kp)^2)if lz>100 then lx=false elseif ly<=lu or lu==-1 then BrakeIsOn=true;ll=true else BrakeIsOn=false;ll=true end end;if not lx and CalculateBrakeLandingSpeed then if lu>=lm then BrakeIsOn=true else BrakeIsOn=false end;ll=true end end end;if not bA then cd(0)end;q:setTargetGroundAltitude(500)q:activateGroundEngineAltitudeStabilization(500)stablized=true;jW=an;if jW>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if R then a.control.extendLandingGears()bV("grOut","LG",1)end;q:setTargetGroundAltitude(LandingGearGroundHeight)ae=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-gX)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not ll then BrakeIsOn=true elseif not ll then BrakeIsOn=false end end;if AutoTakeoff or al then local bQ,bS,bR;if AutopilotTargetCoords~=nil then bQ,bS,bR=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(bT)return bT.radius+bT.noAtmosphericDensityAltitude end)end;if by then if ar>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cd(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kR)<15 and ar/HoldAltitude>0.75 then AutoTakeoff=false;if not al then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif al and bs<P then Autopilot=true;al=false;AltitudeHold=false;AutoTakeoff=false;cd(0)elseif al then cd(0)BrakeIsOn=true end elseif al and aq==0 and ab~=nil and(bQ==nil or bQ.name==ab.name)then Autopilot=true;al=false;AltitudeHold=false;AutoTakeoff=false;if not bA then cd(0)end;AutopilotAccelerating=true end end;local lA=an>-1;local lB=bB;if(VectorToTarget or al or bJ)and not lA and bs>minRollVelocity and aq>0.01 then local lg=math.rad(c(bC))lB=bB*c(math.cos(lg))+kk*math.sin(lg)end;local lC=p(kR-lB,-PitchStallAngle*0.80,PitchStallAngle*0.80)if aq<0.01 and VectorToTarget then lC=p(kR-lB,-85,MaxPitch)elseif aq<0.01 then lC=p(kR-lB,-MaxPitch,MaxPitch)end;if c(bC)<5 or VectorToTarget or bJ or BrakeLanding or lA or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lC)local kS=pitchPID:get()T=T+kS end end;if antigrav~=nil and(antigrav and not ExternalAGG and ar<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;an=jR()return jI end;function script.onStart()local lD={}local lE={}local lF=false;local function lG()local function lH(lI)local lJ=dbHud_1.hasKey;for cE,cF in pairs(lI)do if lJ(cF)then local cW=f(dbHud_1.getStringValue(cF))if cW~=nil then _G[cF]=cW;lF=true end end end end;if dbHud_1 then if not useTheseSettings then lH(c0())coroutine.yield()lH(b)else lH(b)a1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ah=5;lF=false end;coroutine.yield()if lF then a1="Loaded Saved Variables"aF=ResolutionX;aG=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ax=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]ay=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]elseif not useTheseSettings then a1="No Saved Variables Found - Exit HUD to save settings"end else a1="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<C then LastMaxBrakeInAtmo=0 end;LastStartTime=C;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ah=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=ar end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=au end;VectorStatus="Proceeding to Waypoint"end;local function lK()local function lL(lM,lN)if lM>lN then lN=lM end;local lO,lP=0,0;if ContainerOptimization>0 then lO=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lP=FuelTankOptimization*0.05 end;lN=lN*(1-(lO+lP))return lN end;local lQ=core.getElementNameById;local lR=fuelX~=0 and fuelY~=0;for cE in pairs(as)do local type=core.getElementTypeById(as[cE])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(as[cE])),'^.*vertical.*$')then bx=true end end;if n(type,'^.*Space Engine$')then bl=true;if n(tostring(core.getElementTagsById(as[cE])),'^.*vertical.*$')then local lS=core.getElementRotationById(as[cE])if lS[4]<0 then if y(-lS[4],0.1)==0.5 then bj=true end else if y(lS[4],0.1)==0.5 then bk=true end end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local lT=h(as[cE])if lT>10000 then E=128;F=110 elseif lT>1000 then E=64;F=55 elseif lT>150 then E=32;F=27 end end;aK=aK+h(as[cE])if lR and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lT=h(as[cE])local lU=k(as[cE])local lM=0;local gM=o()if type=="Atmospheric Fuel Tank"then local lN=400;local lV=35.03;if lT>10000 then lN=51200;lV=5480 elseif lT>1300 then lN=6400;lV=988.67 elseif lT>150 then lN=1600;lV=182.67 end;lM=lU-lV;if fuelTankHandlingAtmo>0 then lN=lN+lN*fuelTankHandlingAtmo*0.2 end;lN=lL(lM,lN)aH[#aH+1]={as[cE],lQ(as[cE]),lN,lV,lM,gM}end;if type=="Rocket Fuel Tank"then local lN=320;local lV=173.42;if lT>65000 then lN=40000;lV=25740 elseif lT>6000 then lN=5120;lV=4720 elseif lT>700 then lN=640;lV=886.72 end;lM=lU-lV;if fuelTankHandlingRocket>0 then lN=lN+lN*fuelTankHandlingRocket*0.1 end;lN=lL(lM,lN)aJ[#aJ+1]={as[cE],lQ(as[cE]),lN,lV,lM,gM}end;if type=="Space Fuel Tank"then local lN=2400;local lV=182.67;if lT>10000 then lN=76800;lV=5480 elseif lT>1300 then lN=9600;lV=988.67 end;lM=lU-lV;if fuelTankHandlingSpace>0 then lN=lN+lN*fuelTankHandlingSpace*0.2 end;lN=lL(lM,lN)aI[#aI+1]={as[cE],lQ(as[cE]),lN,lV,lM,gM}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function lW()if gyro~=nil then aw=gyro.getState()==1 end;if not stablized then q:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then u(1)else u(0)end;if door and(ap or not ap and ar<10000)then for _,cF in pairs(door)do cF.toggle()end end;if switch then for _,cF in pairs(switch)do cF.toggle()end end;if forcefield and(ap or not ap==0 and ar<10000)then for _,cF in pairs(forcefield)do cF.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if R then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if an~=-1 or not ap and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if R then a.control.extendLandingGears()end else BrakeIsOn=false end;q:setTargetGroundAltitude(b1)if ap and an~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ap end;local function lX(lY,lZ,l_,m0,c8,c9,m1,m2,m3,m4)local m5={enableName=lY,disableName=lZ,width=l_,height=m0,x=c8,y=c9,toggleVar=m1,toggleFunction=m2,drawCondition=m3,hovered=false}if m4 then table.insert(lE,m5)else table.insert(lD,m5)end;return m5 end;local function m6(m7)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif m7=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif m7=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif m7=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=c0(m7)showHud=false else bE={}showHud=true end end;local function m8()bD=not bD;if bD then aE=lE;a1="Hold SHIFT to see Settings"bF=showHud else aE=lD;a1="Hold SHIFT to see Control Buttons"m6()showHud=bF end end;local function m9(cF)_G[cF]=not _G[cF]if _G[cF]then a1=cF.." set to true"else a1=cF.." set to false"end;if cF=="showHud"then bF=_G[cF]elseif cF=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif cF=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function ma()local mb=50;local mc=340;local c8=500;local c9=aG/2-400;local md=0;for cE,cF in pairs(c0("boolean"))do if type(_G[cF])=="boolean"then lX(cF,cF,mc,mb,c8,c9,function()return _G[cF]end,function()m9(cF)end,function()return true end,true)c9=c9+mb+20;if md==9 then c8=c8+mc+20;c9=aG/2-400;md=0 else md=md+1 end end end;lX("Control View","Control View",mc,mb,10,aG/2-500,function()return true end,m8,function()return true end,true)lX("View Handling Settings",'Hide Handling Settings',mc,mb,10,aG/2-(500-mb),function()return showHandlingVariables end,function()m6("handling")end,function()return true end,true)lX("View Hud Settings",'Hide Hud Settings',mc,mb,10,aG/2-(500-mb*2),function()return showHudVariables end,function()m6("hud")end,function()return true end,true)lX("View Physics Settings",'Hide Physics Settings',mc,mb,10,aG/2-(500-mb*3),function()return showPhysicsVariables end,function()m6("physics")end,function()return true end,true)end;local function me()local function jB()local position=bv;local fY=planet.name..". "..#SavedLocations;if radar_1 then local dp,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dp~=nil and dp~=""then fY=fY.." "..radar_1.getConstructName(dp)end end;return aW.AddNewLocation(fY,position,false,true)end;local function mf()TurnBurn=not TurnBurn end;local function mg(mh)if mh==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Z=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function mi()aW.UpdatePosition()end;local function jA()aW.ClearCurrentPosition()end;local function mj()local fY=AutopilotTargetName;if fY==nil then local ih=ck((bv-CustomTarget.position):len())fY=CustomTarget.name.." "..ih end;if fY==nil then fY="None"end;return"Engage Autopilot: "..fY end;local function mk()local fY=AutopilotTargetName;if fY==nil then fY=CustomTarget.name end;if fY==nil then fY="None"end;return"Disable Autopilot: "..fY end;local function ml()if safeMass>0 then a1="Safe Mass set to "..y(au,2).." kg"else a1="Intruder Detection reset\nSafe Mass set to "..y(au,2).." kg"ah=5;bw=0 end;safeMass=au end;local function mm()if l()==1 then Z=not Z;if Z then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()q:setTargetGroundAltitude(TargetHoverHeight)bV("folOn","F")else bV("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()q:setTargetGroundAltitude(LandingGearGroundHeight)end end else a1="Follow Mode only works with Remote controller"Z=false end end;local mb=50;local mc=260;local mn=lX("Enable Brake Toggle","Disable Brake Toggle",mc,mb,aF/2-mc/2,aG/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a1="Brakes in Toggle Mode"else a1="Brakes in Default Mode"end end)lX("Align Prograde","Disable Prograde",mc,mb,aF/2-mc/2-50-mn.width,aG/2-mb+380,function()return ProgradeIsOn end,function()mg(1)end)lX("Align Retrograde","Disable Retrograde",mc,mb,aF/2-mc/2+mn.width+50,aG/2-mb+380,function()return RetrogradeIsOn end,mg,function()return aq==0 end)local mo=lX(mj,mk,600,60,aF/2-600/2,aG/2-60/2-400,function()return Autopilot end,cq)lX("Save Position","Save Position",200,mo.height,mo.x+mo.width+30,mo.y,function()return false end,jB,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)lX("Update Position","Update Position",200,mo.height,mo.x+mo.width+30,mo.y,function()return false end,mi,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lX("Clear Position","Clear Position",200,mo.height,mo.x-200-30,mo.y,function()return true end,jA,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mb=60;mc=300;local c8=10;local c9=aG/2-500;lX("Show Help","Hide Help",mc,mb,c8,c9,function()return showHelp end,function()showHelp=not showHelp end)c9=c9+mb+20;lX("View Settings","View Settings",mc,mb,c8,c9,function()return true end,m8)local c9=aG/2-300;lX("Enable Turn and Burn","Disable Turn and Burn",mc,mb,c8,c9,function()return TurnBurn end,mf)lX("Horizontal Takeoff Mode","Vertical Takeoff Mode",mc,mb,c8+mc+20,c9,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a1="Vertical Takeoff Mode"else a1="Horizontal Takeoff Mode"end end,function()return bx end)c9=c9+mb+20;lX("Show Orbit Display","Hide Orbit Display",mc,mb,c8,c9,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a1="Orbit Display Enabled"else a1="Orbit Display Disabled"end end)lX("Engage Orbiting","Cancel Orbiting",mc,mb,c8+mc+20,c9,function()return IntoOrbit end,co,function()return aq==0 and bL end)c9=c9+mb+20;lX("Glide Re-Entry","Cancel Glide Re-Entry",mc,mb,c8,c9,function()return Reentry end,function()ak=1;mg(1)end,function()return planet.hasAtmosphere and not ap end)lX("Parachute Re-Entry","Cancel Parachute Re-Entry",mc,mb,c8+mc+20,c9,function()return Reentry end,ct,function()return planet.hasAtmosphere and not ap end)c9=c9+mb+20;lX("Engage Follow Mode","Disable Follow Mode",mc,mb,c8,c9,function()return Z end,mm,function()return l()==1 end)lX("Enable Repair Arrows","Disable Repair Arrows",mc,mb,c8+mc+20,c9,function()return aL end,function()aL=not aL;if aL then a1="Repair Arrows Enabled"else a1="Repair Arrows Diabled"end end,function()return l()==1 end)c9=c9+mb+20;if not ExternalAGG then lX("Enable AGG","Disable AGG",mc,mb,c8,c9,function()return by end,cu,function()return antigrav~=nil end)end;lX("Reset Intruder Alert","Set Safe Mass",mc,mb,c8+mc+20,c9,function()return safeMass>0 end,ml,function()return IntruderAlertSystem end)c9=c9+mb+20;lX(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,mc*2,mb,c8,c9,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a1="IPH Mode: "..iphCondition end)c9=c9+mb+20;lX(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,mc*2,mb,c8,c9,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a1="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()q:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lG()coroutine.yield()lK()coroutine.yield()aX=jH()lW()ma()me()aE=lD;coroutine.yield()aM=cG()aQ=cH()aR=aQ(cG())aS=e4()aU=ey()aY=eW()aV=g6()aW=jo()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bV("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(aq>0 or aq==0 and ar<10000)then for _,cF in pairs(door)do cF.toggle()end end;if switch then for _,cF in pairs(switch)do cF.toggle()end end;if forcefield and(aq>0 or aq==0 and ar<10000)then for _,cF in pairs(forcefield)do cF.toggle()end end;safeMass=au;cA()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;bV("stop","SU")end;function script.onTick(mp)local mq=nil;if mp=="contact"then if not contactTimer then contactTimer=0 end;if C>contactTimer+10 then a1="Radar Contact"bV("rdrCon","RC")contactTimer=C end;unit.stopTimer("contact")elseif mp=="tenthSecond"then local function mr()local ms=system.createData;local mt=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mt(panelInterplanetary,"value")interplanetaryHeaderText=ms('{"label": "Target Planet", "value": "N/A", "unit":""}')t(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mt(panelInterplanetary,"value")widgetDistanceText=ms('{"label": "distance", "value": "N/A", "unit":""}')t(widgetDistanceText,widgetDistance)widgetTravelTime=mt(panelInterplanetary,"value")widgetTravelTimeText=ms('{"label": "Travel Time", "value": "N/A", "unit":""}')t(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mt(panelInterplanetary,"value")widgetMaxMassText=ms('{"label": "Maximum Mass", "value": "N/A", "unit":""}')t(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mt(panelInterplanetary,"value")widgetTargetOrbitText=ms('{"label": "Target Altitude", "value": "N/A", "unit":""}')t(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mt(panelInterplanetary,"value")widgetCurBrakeDistanceText=ms('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mt(panelInterplanetary,"value")widgetCurBrakeTimeText=ms('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mt(panelInterplanetary,"value")widgetMaxBrakeDistanceText=ms('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mt(panelInterplanetary,"value")widgetMaxBrakeTimeText=ms('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mt(panelInterplanetary,"value")widgetTrajectoryAltitudeText=ms('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ap then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)t(widgetCurBrakeTimeText,widgetCurBrakeTime)t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mu()r(panelInterplanetary)panelInterplanetary=nil end;local function mv()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ab.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local ew=bs;local kU=unit.getThrottle()/100;if AtmoSpeedAssist then kU=J end;local mw,mx=aS.computeDistanceAndTime(bs,MaxGameVelocity,au,a:maxForceForward()*kU,warmup,0)local a7,a8;if not TurnBurn then a7,a8=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,my;if not TurnBurn and ew>0 then _,my=aX.GetAutopilotBrakeDistanceAndTime(ew)else _,my=aX.GetAutopilotTBBrakeDistanceAndTime(ew)end;local mz=0;local mA=0;if AutopilotCruising or not Autopilot and ew>5 then mA=aS.computeTravelTime(ew,0,AutopilotDistance)elseif a7+mw<AutopilotDistance then mz=AutopilotDistance-(a7+mw)mA=aS.computeTravelTime(8333.0556,0,mz)else local mB=(AutopilotDistance-a7)/mw;mw=AutopilotDistance-a7;mx=mx*mB end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mA elseif AutopilotBraking then return my elseif AutopilotCruising then return mA+my else return mx+a8+mA end end;local function mC(j7,mD)if j7==nil then j7=core.g()end;j7=y(j7,5)if mD~=nil and mD or(mq==nil or mq~=j7)then local ew=bq:len()local mE=f(unit.getData()).maxBrake;if mE~=nil and mE>0 and ap then mE=mE/p(ew/100,0.1,1)mE=mE/aq;if aq>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mE)/2 else LastMaxBrakeInAtmo=mE end end end;if mE~=nil and mE>0 then LastMaxBrake=mE end;mq=j7 end end;mC(nil,true)if bz~=nil then if q:getTargetSpeed(axisCommandId.longitudinal)~=bz then cg(bz,TRUE)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mr()end;if AutopilotTargetName~=nil then local mF=CustomTarget~=nil;local mG=LastMaxBrakeInAtmo/ab:getGravity(ab.center+vec3(0,0,1)*ab.radius):len()s(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mv()if mF and not Autopilot then ai=(bv-CustomTarget.position):len()else ai=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a7,a8=aX.GetAutopilotBrakeDistanceAndTime(bs)a9,aa=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=aX.GetAutopilotTBBrakeDistanceAndTime(bs)a9,aa=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ih=ck(ai)s(widgetDistanceText,'{"label": "distance", "value": "'..ih..'"}')s(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cv(travelTime)..'", "unit":""}')ih=ck(a7)s(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ih..'"}')s(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cv(a8)..'", "unit":""}')ih=ck(a9)s(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ih..'"}')s(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cv(aa)..'", "unit":""}')s(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",mG*0.5/1000)..'", "unit":" Tons"}')ih=ck(AutopilotTargetOrbit)s(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ih..'"}')if aq>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or am)then cd(1)BrakeIsOn=false;N=false end end;if aq==0 and WasInAtmo then if s(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if s(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if s(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then t(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if s(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if s(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mu()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()elseif mp=="oneSecond"then local function mH(gT)local mI=0;aC=""local mJ=aK;local mK=0;local mL=0;local mM=0;local gQ=0;local gR=""local mN=core.getElementHitPointsById;for cE in pairs(as)do local lT=0;local mO=0;mO=h(as[cE])lT=mN(as[cE])mK=mK+lT;if lT<mO then if lT==0 then mM=mM+1 else mL=mL+1 end;if aL and#az==0 then position=vec3(core.getElementPositionById(as[cE]))local c8=position.x-E;local c9=position.y-E;local fq=position.z-E;table.insert(az,core.spawnArrowSticker(c8,c9,fq+1,"down"))table.insert(az,core.spawnArrowSticker(c8,c9,fq+1,"down"))core.rotateSticker(az[2],0,0,90)table.insert(az,core.spawnArrowSticker(c8+1,c9,fq,"north"))table.insert(az,core.spawnArrowSticker(c8+1,c9,fq,"north"))core.rotateSticker(az[4],90,90,0)table.insert(az,core.spawnArrowSticker(c8-1,c9,fq,"south"))table.insert(az,core.spawnArrowSticker(c8-1,c9,fq,"south"))core.rotateSticker(az[6],90,-90,0)table.insert(az,core.spawnArrowSticker(c8,c9-1,fq,"east"))table.insert(az,core.spawnArrowSticker(c8,c9-1,fq,"east"))core.rotateSticker(az[8],90,0,90)table.insert(az,core.spawnArrowSticker(c8,c9+1,fq,"west"))table.insert(az,core.spawnArrowSticker(c8,c9+1,fq,"west"))core.rotateSticker(az[10],-90,0,90)table.insert(az,as[cE])end elseif aL and#az>0 and az[11]==as[cE]then for gL in pairs(az)do core.deleteSticker(az[gL])end;az={}end end;mI=d(mK/mJ*100)if mI<100 then gT[#gT+1]=c7(0,0,"","pbright txt")gQ=d(mI*2.55)gR=e("rgb(%d,%d,%d)",255-gQ,gQ,0)if mI<100 then gT[#gT+1]=c7("50%",1035,"Elemental Integrity: "..mI.."%","txtbig txtmid","fill:"..gR)if mM>0 then gT[#gT+1]=c7("50%",1055,"Disabled Modules: "..mM.." Damaged Modules: "..mL,"txtbig txtmid","fill:"..gR)elseif mL>0 then gT[#gT+1]=c7("50%",1055,"Damaged Modules: "..mL,"txtbig txtmid","fill:"..gR)end end end end;local function mP()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then r(WeaponPanelID)WeaponPanelID=nil end end end;local function mQ()local gM=o()local i4=bs;local mR=gM-at;if i4>1.38889 then i4=i4/1000;local mS=i4*(gM-at)TotalDistanceTravelled=TotalDistanceTravelled+mS;ac=ac+mS end;ad=ad+mR;TotalFlightTime=TotalFlightTime+mR;at=gM end;local function mT()if safeMass>0 then if au>safeMass+50 then bw=d(au-safeMass)safeMass=-1 elseif au<safeMass then safeMass=au end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mT()end;mQ()aV.UpdatePipe()mP()local gT={}aV.ExtraData(gT)if ShowOdometer then gT=aV.DrawOdometer(gT,ac,TotalDistanceTravelled,ad)end;if ShouldCheckDamage then mH(gT)end;aj=table.concat(gT,"")collectgarbage("collect")elseif mp=="fiveSecond"then if not UseSatNav then return end;ao=dbHud_1.getStringValue("SPBAutopilotTargetName")if ao~=nil and ao~=""and ao~="SatNavNotChanged"then local cW=f(dbHud_1.getStringValue("SavedLocations"))if cW~=nil then _G["SavedLocations"]=cW;local fJ=-1;local jE;for cE,cF in pairs(SavedLocations)do if cF.name and cF.name=="SatNav Location"then fJ=cE;break end end;if fJ~=-1 then jE=SavedLocations[fJ]fJ=-1;for cE,cF in pairs(aM[0])do if cF.name and cF.name=="SatNav Location"then fJ=cE;break end end;if fJ>-1 then aM[0][fJ]=jE end;aW.UpdateAtlasLocationsList()a1=jE.name.." position updated"end end;for i=1,#bG do if bG[i].name==ao then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mp=="msgTick"then local gT={}aV.DisplayMessage(gT,"empty")a1="empty"unit.stopTimer("msgTick")ah=3 elseif mp=="animateTick"then a_=true;aZ=false;af=0;ag=0;unit.stopTimer("animateTick")elseif mp=="hudTick"then local function mU(gT)local mV=d(p(ai/(aF/4)*255,0,255))gT[#gT+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",af,ag,d(G+0.5)+mV,d(I+0.5)-mV,d(H+0.5)-mV)end;local function mW()for _,cF in pairs(aE)do if cF.hovered then if not cF.drawCondition or cF.drawCondition()then cF.toggleFunction()end;cF.hovered=false end end end;local function mX()local function mY(mZ,m_,c8,c9,l_,m0)if mZ>c8 and mZ<c8+l_ and m_>c9 and m_<c9+m0 then return true else return false end end;local c8=af+aF/2;local c9=ag+aG/2;for _,cF in pairs(aE)do cF.hovered=mY(c8,c9,cF.x,cF.y,cF.width,cF.height)end end;local function n0(gT)local function n1(gT,n2,hover,c8,c9,ep,n3,n4,n5,n6,n7)if type(n6)=="function"then n6=n6()end;if type(n7)=="function"then n7=n7()end;gT[#gT+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c8,c9,ep,n3)if n2 then gT[#gT+1]=e("%s'",n4)else gT[#gT+1]=n5 end;if hover then gT[#gT+1]=" style='stroke:white; stroke-width:2'"else gT[#gT+1]=" style='stroke:black; stroke-width:1'"end;gT[#gT+1]="></rect>"gT[#gT+1]=e("<text x='%f' y='%f' font-size='24' fill='",c8+ep/2,c9+n3/2+5)if n2 then gT[#gT+1]="black"else gT[#gT+1]="white"end;gT[#gT+1]="' text-anchor='middle' font-family='Montserrat'>"if n2 then gT[#gT+1]=e("%s</text>",n6)else gT[#gT+1]=e("%s</text>",n7)end end;local n8="rgb(50,50,50)'"local n9="rgb(210,200,200)"local na=n1;for _,cF in pairs(aE)do local lZ=cF.disableName;local lY=cF.enableName;if type(lZ)=="function"then lZ=lZ()end;if type(lY)=="function"then lY=lY()end;if not cF.drawCondition or cF.drawCondition()then na(gT,cF.toggleVar(),cF.hovered,cF.x,cF.y,cF.width,cF.height,n9,n8,lZ,lY)end end end;local nb=y(ResolutionX/2,0)local nc=y(ResolutionY/2,0)local gT={}aV.HUDPrologue(gT)if showHud then aV.UpdateHud(gT)else if AlwaysVSpd then aV.DrawVerticalSpeed(gT,ar)end;aV.DisplayOrbitScreen(gT)aV.DrawWarnings(gT)end;if bD and bE~={}then aV.DrawSettings(gT)end;if radar_1 then aV.DrawRadarInfo()end;aV.HUDEpilogue(gT)gT[#gT+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aF,aG)if a1~="empty"then aV.DisplayMessage(gT,a1)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(gT)end end;if v()==0 then if l()==1 and a0 then if not AltIsOn then mX()n0(gT)end;if not aZ and not a_ then local nd=table.concat(gT,"")gT={}gT[#gT+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aF,aG)gT[#gT+1]=nd;gT[#gT+1]="</body>"aZ=true;gT[#gT+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gT,"")system.setScreen(content)elseif a_ then local nd=table.concat(gT,"")gT={}gT[#gT+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aF,aG)gT[#gT+1]=nd;gT[#gT+1]="</body>"end;if not aZ then gT[#gT+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nb,nc,af,ag)end else mW()end else if not a0 and l()==0 then mW()if ai>DeadZone then if DisplayDeadZone then mU(gT)end end elseif not AltIsOn or AltIsOn and a0 then mX()n0(gT)end;gT[#gT+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nb,nc,af,ag)end;gT[#gT+1]=[[</svg></body>]]content=table.concat(gT,"")elseif mp=="apTick"then aX.APTick()elseif mp=="radarTick"then aY.UpdateRadar()end end;function script.onFlush()local function ne(nf,l0)local ng=vec3()local nh=vec3()if nf==axisCommandId.longitudinal then ng=vec3(core.getConstructOrientationForward())nh=bo elseif nf==axisCommandId.vertical then ng=vec3(core.getConstructOrientationUp())nh=bn elseif nf==axisCommandId.lateral then ng=vec3(core.getConstructOrientationRight())nh=bp else return vec3()end;local ni=vec3(core.getWorldGravity())local nj=ni:dot(nh)local nk=vec3(core.getWorldAirFrictionAcceleration())local nl=nk:dot(nh)local nm=bq:dot(ng)local nn=l0*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nn-nm)local no=targetSpeedPID2:get()local np=(no-nl-nj)*nh;return np end;local function nq(nf,l0)local ng=vec3()local nh=vec3()if nf==axisCommandId.longitudinal then ng=vec3(core.getConstructOrientationForward())nh=bo elseif nf==axisCommandId.vertical then ng=vec3(core.getConstructOrientationUp())nh=bn elseif nf==axisCommandId.lateral then ng=vec3(core.getConstructOrientationRight())nh=bp else return vec3()end;local ni=vec3(core.getWorldGravity())local nj=ni:dot(nh)local nk=vec3(core.getWorldAirFrictionAcceleration())local nl=nk:dot(nh)local nm=bq:dot(ng)local nn=l0*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nn-nm)local no=targetSpeedPID:get()local np=(no-nl-nj)*nh;return np end;local function nr(ns,gW,jt)local nt=ns:cross(jt):normalize_inplace()local hI=math.acos(p(nt:dot(-gW),-1,1))*constants.rad2deg;if nt:cross(-gW):dot(jt)<0 then hI=-hI end;return hI end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=q:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and N then cd(0)N=false elseif not bA and not N then J=0;N=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local nu=p(S+T+system.getControlDeviceForwardInput(),-1,1)local nw=p(V+Y+system.getControlDeviceYawInput(),-1,1)local nx=p(W+U-system.getControlDeviceLeftRightInput(),-1,1)local ny=X;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())au=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local nz=bC/180*math.pi;local nA=math.cos(nz)local nB=math.sin(nz)bB=nr(bt,bo,bp*nA+bn*nB)local nC=br:normalize()local nD=c(bC)local nE=utils.sign(bC)local nF=vec3(core.getWorldAngularVelocity())local nG=nu*pitchSpeedFactor*bp+nw*rollSpeedFactor*bo+nx*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local nH=c(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or ak or AltitudeHold or IntoOrbit)and nH>0 or aq>0.0 and nH<autoRollRollThreshold and autoRollPreference)and nw==0 and c(bB)<85 then local nI=b4;local nJ=autoRollFactor;if aq==0 then nJ=nJ/4;b4=0;nI=0 end;if rollPID==nil then rollPID=pid.new(nJ*0.01,0,nJ*0.1)end;rollPID:inject(nI-bC)local nK=rollPID:get()nG=nG+nK*bo end end;local nL=1;local nM=0;local nN=1;if system.getMouseWheel()>0 then if AltIsOn then if aq>0 or Reentry then b7=p(b7+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=p(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif av then local nO=J;J=y(p(J+speedChangeLarge/100,-1,1),2)if J>=0 and nO<0 then J=0;av=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if aq>0 or Reentry then b7=p(b7-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=p(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif av then local nO=J;J=y(p(J-speedChangeLarge/100,-1,1),2)if J<=0 and nO>0 then J=0;av=false end end else av=true end;K=0;if ap and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local nP=throttlePID:get()M=p(nP,-1,1)if M<J and aq>0.005 then L=true;q:setThrottleCommand(axisCommandId.longitudinal,p(M,0.01,1))else L=false;q:setThrottleCommand(axisCommandId.longitudinal,J)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local nQ=p(brakePID:get(),0,1)if aq>0 and bu<-80 or aq>0.005 then K=nQ end;if K>0 then if L and M==0.01 then q:setThrottleCommand(axisCommandId.longitudinal,0)end else M=p(M,0.01,1)end;local nR=''local nS=vec3()local nT=ne(axisCommandId.vertical,ae*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",nT,nM)local nU='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nU=nU..ExtraLongitudeTags end;local nV=q:getAxisCommandType(axisCommandId.longitudinal)local nW=q:composeAxisAccelerationFromThrottle(nU,axisCommandId.longitudinal)local nX=nq(axisCommandId.lateral,LeftAmount*1000)nR=nR..' , '.."lateral airfoil , lateral ground "nS=nS+nX;if nS:len()>constants.epsilon then a:setEngineForceCommand(nR,nS,nM,'','','',nN)end;a:setEngineForceCommand(nU,nW,nL)local nY='thrust analog vertical fueled 'local nZ='thrust analog lateral fueled 'if ExtraLateralTags~="none"then nZ=nZ..ExtraLateralTags end;if ExtraVerticalTags~="none"then nY=nY..ExtraVerticalTags end;if ae~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(nY,nT,nL)else a:setEngineForceCommand(nY,vec3(),nL)end;if LeftAmount~=0 then a:setEngineForceCommand(nZ,nX,nL)else a:setEngineForceCommand(nZ,vec3(),nL)end;if ny==0 then ny=K end;local n_=-ny*(brakeSpeedFactor*br+brakeFlatFactor*nC)a:setEngineForceCommand('brake',n_)else if AtmoSpeedAssist then q:setThrottleCommand(axisCommandId.longitudinal,J)end;local l0=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-l0/3.6)local nQ=p(brakePID:get(),0,1)ny=p(ny+nQ,0,1)end;local n_=-ny*(brakeSpeedFactor*br+brakeFlatFactor*nC)a:setEngineForceCommand('brake',n_)local nR=''local nS=vec3()local o0=false;local nU='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nU=nU..ExtraLongitudeTags end;local nV=q:getAxisCommandType(axisCommandId.longitudinal)if nV==axisCommandType.byThrottle then local nW=q:composeAxisAccelerationFromThrottle(nU,axisCommandId.longitudinal)a:setEngineForceCommand(nU,nW,nL)elseif nV==axisCommandType.byTargetSpeed then local nW=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)nR=nR..' , '..nU;nS=nS+nW;if q:getTargetSpeed(axisCommandId.longitudinal)==0 or q:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-q:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then o0=true end end;local nZ='thrust analog lateral 'if ExtraLateralTags~="none"then nZ=nZ..ExtraLateralTags end;local o1=q:getAxisCommandType(axisCommandId.lateral)if o1==axisCommandType.byThrottle then local o2=q:composeAxisAccelerationFromThrottle(nZ,axisCommandId.lateral)a:setEngineForceCommand(nZ,o2,nL)elseif o1==axisCommandType.byTargetSpeed then local nX=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)nR=nR..' , '..nZ;nS=nS+nX end;local nY='thrust analog vertical 'if ExtraVerticalTags~="none"then nY=nY..ExtraVerticalTags end;local o3=q:getAxisCommandType(axisCommandId.vertical)if o3==axisCommandType.byThrottle then local nT=q:composeAxisAccelerationFromThrottle(nY,axisCommandId.vertical)if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(nY,nT,nL,'airfoil','ground','',nN)else a:setEngineForceCommand(nY,vec3(),nL)a:setEngineForceCommand('airfoil vertical',nT,nL,'airfoil','','',nN)a:setEngineForceCommand('ground vertical',nT,nL,'ground','','',nN)end elseif o3==axisCommandType.byTargetSpeed then if ae<0 then a:setEngineForceCommand('hover',vec3(),nL)end;local o4=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)nR=nR..' , '..nY;nS=nS+o4 end;if nS:len()>constants.epsilon then if X~=0 or o0 or c(nC:dot(bo))<0.8 then nR=nR..', brake'end;a:setEngineForceCommand(nR,nS,nM,'','','',nN)end end;local o5=torqueFactor*(nG-nF)local o6=vec3(core.getWorldAirFrictionAngularAcceleration())o5=o5-o6;a:setEngineTorqueCommand('torque',o5,nL,'airfoil','','',nN)a:setBoosterCommand('rocket_engine')if a6 and not VanillaRockets then local ew=bq:len()local o7=0.15;if not bA then local o8=q:getTargetSpeed(axisCommandId.longitudinal)if ew*3.6>o8*(1-o7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew*3.6<o8*(1-o7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kU=unit.getThrottle()if AtmoSpeedAssist then kU=J*100 end;local l0=kU/100;if j==0 then l0=l0*MaxGameVelocity;if ew>=l0*(1-o7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew<l0*(1-o7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local lb=d(b7)l0=l0*lb/3.6;if ew>=l0*(1-o7)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew<l0*(1-o7)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g4=coroutine.status(beginSetup)if g4=="suspended"then local ce,g5=coroutine.resume(beginSetup)if g5 then system.print("ERROR STARTUP: "..g5)end elseif g4=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(o9)local function oa(ob)local B=1;local function oc(od,ob)local oe={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local of=od;for _,cF in ipairs(oe)do if ob and of>cF then od=cF elseif od<cF and not ob then od=cF;break end end;return od end;if ob then B=-1 end;if not ExternalAGG and by then if a0 and ob then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a0 then bg=oc(bg,ob)else bg=bg+B*a2 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a0 and ap then HoldAltitude=oc(HoldAltitude,ob)else HoldAltitude=HoldAltitude+B*a2 end end else q:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function og(ob)local B=1;if ob then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=p(J+B*speedChangeLarge/100,-1,1)else q:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if ob then B=1 else B=nil end;aW.adjustAutopilotTargetIndex(B)end end;local function oh(oi)if not ap then a1="Flight Assist in Atmo only"return end;local cM=type(oi)if bJ==nil then if cM=="table"then if Autopilot or VectorToTarget then cq()end;bV("180On","BR")elseif oi==1 then bV("bnkLft","BR")else bV("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cp()if cM~="table"then oi=oi+1 end end;bJ=oi else bV("180Off","BR")bJ=nil end end;if o9=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cd(0)if vBooster or hover then if ap and an==-1 then bV("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if R then bV("grOut","LG",1)a.control.extendLandingGears()end;q:setTargetGroundAltitude(LandingGearGroundHeight)if ap then BrakeIsOn=true end end end;if R and not BrakeLanding and not(vBooster or hover)then bV("grOut","LG",1)a.control.extendLandingGears()end else if R then bV("grIn","LG",1)a.control.retractLandingGears()end;q:setTargetGroundAltitude(TargetHoverHeight)end elseif o9=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif o9=="forward"then S=S-1 elseif o9=="backward"then if AltIsOn then oh(-br*5000)else S=S+1 end elseif o9=="left"then if AltIsOn then oh(1)else V=V-1 end elseif o9=="right"then if AltIsOn then oh(3)else V=V+1 end elseif o9=="yawright"then W=W-1 elseif o9=="yawleft"then W=W+1 elseif o9=="straferight"then q:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif o9=="strafeleft"then q:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif o9=="up"then ae=ae+1;q:deactivateGroundEngineAltitudeStabilization()q:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif o9=="down"then ae=ae-1;q:deactivateGroundEngineAltitudeStabilization()q:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif o9=="groundaltitudeup"then oa()elseif o9=="groundaltitudedown"then oa(true)elseif o9=="option1"then aW.adjustAutopilotTargetIndex()toggleView=false elseif o9=="option2"then aW.adjustAutopilotTargetIndex(1)toggleView=false elseif o9=="option3"then local function oj()aD=not aD;if not aD then bV("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else bV("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then r(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then r(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then r(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oj()toggleView=false elseif o9=="option4"then bJ=nil;cq()toggleView=false elseif o9=="option5"then function ToggleLockPitch()if LockPitch==nil then bV("lkPOn","LP")if not a0 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bV("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif o9=="option6"then cp()toggleView=false elseif o9=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a1="Collision System Enabled"else a1="Collision System Secured"end;toggleView=false elseif o9=="option8"then stablized=not stablized;if not stablized then a1="DeCoupled Mode - Ground Stabilization off"q:deactivateGroundEngineAltitudeStabilization()bV("gsOff","GS")else a1="Coupled Mode - Ground Stabilization on"q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bV("gsOn","GS")end;toggleView=false elseif o9=="option9"then if gyro~=nil then gyro.toggle()aw=gyro.getState()==1;if aw then bV("gyOn","GA")else bV("gyOff","GA")end end;toggleView=false elseif o9=="lshift"then if AltIsOn then a0=true end;if v()==1 then a0=true;PrevViewLock=v()u(1)elseif l()==1 and ShiftShowsRemoteButtons then a0=true;a_=false;aZ=false end elseif o9=="brake"then if BrakeToggleStatus then cs()elseif not BrakeIsOn then cs()else BrakeIsOn=true end elseif o9=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then u(1)end elseif o9=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a6 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a6=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a6=false end elseif o9=="stopengines"then local function ok()if C-D<1.5 then bV("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bJ=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Z=false;O=false;ak=false;al=false;Q=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;aw=false;LockPitch=nil;IntoOrbit=false end end;ok()D=C;if q:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if J~=0 then q:resetCommand(axisCommandId.longitudinal)cd(0)else cd(100)end else if q:getTargetSpeed(axisCommandId.longitudinal)~=0 then q:resetCommand(axisCommandId.longitudinal)else if ap then cg(AtmoSpeedLimit)else cg(MaxGameVelocity*3.6)end end end elseif o9=="speedup"then og()elseif o9=="speeddown"then og(true)elseif o9=="antigravity"and not ExternalAGG then if antigrav~=nil then cu()end end end;function script.onActionStop(o9)local function ol()if not ExternalAGG and by then a5=a3 end;if AltitudeHold or VertTakeOff or IntoOrbit then a4=a2 end end;if o9=="forward"then S=0 elseif o9=="backward"then S=0 elseif o9=="left"then if bJ then if bJ==2 then bJ=-2 else bJ=-1 end end;V=0 elseif o9=="right"then if bJ then if bJ==4 then bJ=-2 else bJ=-1 end end;V=0 elseif o9=="yawright"then W=0 elseif o9=="yawleft"then W=0 elseif o9=="straferight"then q:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif o9=="strafeleft"then q:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif o9=="up"then ae=0;q:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif o9=="down"then ae=0;q:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif o9=="groundaltitudeup"then ol()toggleView=false elseif o9=="groundaltitudedown"then ol()toggleView=false elseif o9=="lshift"then if v()==1 then af=0;ag=0;u(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a0=false elseif o9=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cs()else BrakeIsOn=false end end elseif o9=="lalt"then if l()==0 and freeLookToggle then if toggleView then if v()==1 then u(0)else u(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then u(0)end;AltIsOn=false end end;function script.onActionLoop(o9)local function om(ob)local B=1;if ob then B=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a5=p(a5*1.05,a3,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+B*a4;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a4 end;a4=p(a4*1.05,a2,50)else q:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function on(ob)local B=1;if ob then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=p(J+B*speedChangeSmall/100,-1,1)else q:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if o9=="groundaltitudeup"then if not a0 then om()end elseif o9=="groundaltitudedown"then if not a0 then om(true)end elseif o9=="speedup"then on()elseif o9=="speeddown"then on(true)end end;function script.onInputText(ca)local function oo()for cE,cF in pairs(c0())do dbHud_1.setStringValue(cF,g(nil))end;for cE,cF in pairs(b)do if cF~="SavedLocations"then dbHud_1.setStringValue(cF,g(nil))end end;a1="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ah=5 end;local function op(oq,eA,hE)local function os(eA)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cU='::pos{'..z..','..z..','..z..','..z..','..z..'}'local d6,d7,de,df,dg=n(eA,cU)if d6=="0"and d7=="0"then return vec3(x(de),x(df),x(dg))end;df=math.rad(df)de=math.rad(de)local planet=aM[x(d6)][x(d7)]local e1=math.cos(de)local ot=vec3(e1*math.cos(df),e1*math.sin(df),math.sin(de))return planet.center+(planet.radius+dg)*ot end;local position=os(eA)return aW.AddNewLocation(oq,position,hE)end;local i;local ou,ov=nil,nil;local ow="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(ca," ")ou=ca;if i~=nil then ou=string.sub(ca,0,i-1)ov=string.sub(ca,i+1)end;if ou=="/help"or ou=="/commands"then for je in string.gmatch(ow,"([^\n]+)")do system.print(je)end;return elseif ou=="/setname"then if ov==nil or ov==""then a1="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(ov)else a1="Select a saved target to rename first"end elseif ou=="/addlocation"or string.find(ca,"::pos")~=nil then local hE=false;local oq="0-Temp"if ov==nil or ov==""then ov=ou;hE=true end;i=string.find(ov,"::")if not hE then oq=string.sub(ov,1,i-2)end;local eA=string.sub(ov,i)op(oq,eA,hE)elseif ou=="/agg"then if ov==nil or ov==""then a1="Usage: /agg targetheight"return end;ov=x(ov)if ov<1000 then ov=1000 end;AntigravTargetAltitude=ov;a1="AGG Target Height set to "..ov elseif ou=="/G"then if ov==nil or ov==""then a1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ov=="dump"then for cE,cF in pairs(c0())do if type(_G[cF])=="boolean"then if _G[cF]==true then system.print(cF.." true")else system.print(cF.." false")end elseif _G[cF]==nil then system.print(cF.." nil")else system.print(cF.." ".._G[cF])end end;return end;i=string.find(ov," ")local ox=string.sub(ov,0,i-1)local oy=string.sub(ov,i+1)for cE,cF in pairs(c0())do if cF==ox then a1="Variable "..ox.." changed to "..oy;local oz=type(_G[cF])if oz=="number"then oy=x(oy)elseif oz=="boolean"then if string.lower(oy)=="true"then oy=true else oy=false end end;_G[cF]=oy;return end end;a1="No such global variable: "..ox elseif ou=="/copydatabank"then if dbHud_2 then cA(true)else a1="Spare Databank required to copy databank"end elseif ou=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ab,AutopilotTargetCoords,true))a1="::pos waypoint shown in lua chat"else a1="No target selected in IPH"end end end;function script.onEnter(dp)if radar_1 and not ap and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(dp)if radar_1 and CollisionSystem then if#bK>650 then dp=tostring(dp)bK[dp]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
