name: ArchHud - Archaegeo v1.143 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export: (Default: false)
        userControlScheme = "virtual joystick" --export: (Default: "virtual joystick") Set to "virtual joystick", "mouse", or "keyboard"
        freeLookToggle = true --export: (Default: true)
        BrakeToggleDefault = true --export: (Default: true)
        RemoteFreeze = false --export: (Default: false)
        RemoteHud = false --export: (Default: false)
        brightHud = false --export: (Default: false)
        VanillaRockets = false --export: (Default: false)
        InvertMouse = false --export: (Default: false)
        autoRollPreference = false --export: (Default: false)
        turnAssist = true --export: (Default: true)
        ExternalAGG = false --export: (Default: false)
        UseSatNav = false --export: (Default: false)
        ShouldCheckDamage = true --export: (Default: true)
        CalculateBrakeLandingSpeed = false --export: (Default: false)
        AtmoSpeedAssist = true --export: (Default: true)
        ForceAlignment = false --export: (Default: false)
        DisplayDeadZone = true --export: (Default: true)
        showHud = true --export: (Default: true) 
        ShowOdometer = true --export: (Default: true)
        hideHudOnToggleWidgets = true --export: (Default: true)
        ShiftShowsRemoteButtons = true --export: (Default: true)
        DisplayOrbit = true --export: (Default: true) 
        YawStallAngle = 35 --export: (Default: 35)
        PitchStallAngle = 35 --export: (Default: 35)
        brakeLandingRate = 30 --export: (Default: 30)
        MaxPitch = 30 --export: (Default: 30)
        TargetOrbitRadius = 1.4 --export: (Default: 1.4)
        AtmoSpeedLimit = 1050 --export: (Default: 1050)
        SpaceSpeedLimit = 30000 --export: (Default: 30000).
        AutoTakeoffAltitude = 1000 --export: (Default: 1000)
        TargetHoverHeight = 50 --export: (Default: 50)
        LandingGearGroundHeight = 0 --export: (Default: 0)
        MaxGameVelocity = 8333.00 --export: (Default: 8333.00)
        AutopilotInterplanetaryThrottle = 1.0 --export: (Default: 1.0)
        warmup = 32 --export: (Default: 32)
        fuelTankHandlingAtmo = 0 --export: (Default: 0)
        fuelTankHandlingSpace = 0 --export: (Default: 0)
        fuelTankHandlingRocket = 0 --export: (Default: 0)
        ContainerOptimization = 0 --export: (Default: 0)
        FuelTankOptimization = 0 --export: (Default: 0)
        ResolutionX = 1920 --export: (Default: 1920)
        ResolutionY = 1080 --export: (Default: 1080) 
        circleRad = 400 --export: (Default: 400)
        SafeR = 130 --export: (Default: 130)
        SafeG = 224 --export: (Default: 224)
        SafeB = 255 --export: (Default: 255)
        PvPR = 255 --export: (Default: 255)
        PvPG = 0 --export: (Default: 0)
        PvPB = 0 --export: (Default: 0)
        centerX = 960 --export: (Default: 960)
        centerY = 540 --export: (Default: 540)
        throtPosX = 1300 --export: (Default: 1300)
        throtPosY = 540 --export: (Default: 540)
        vSpdMeterX = 1525  --export: (Default: 1525)
        vSpdMeterY = 325 --export: (Default: 325)
        altMeterX = 550  --export: (Default: 550)
        altMeterY = 540 --export: (Default: 540) 
        fuelX = 100 --export: (Default: 100)
        fuelY = 300 --export: (Default: 300)
        DeadZone = 50 --export: (Default: 50)
        OrbitMapSize = 250 --export: (Default: 250)
        OrbitMapX = 75 --export: (Default: 75)
        OrbitMapY = 0 --export: (Default: 0)
        speedChangeLarge = 5 --export: (Default: 5)
        speedChangeSmall = 1 --export: (Default: 1)
        MouseYSensitivity = 0.003 --export: (Default: 0.003)
        MouseXSensitivity = 0.003 --export: (Default: 0.003)
        autoRollFactor = 2 --export: (Default: 2)
        rollSpeedFactor = 1.5 --export: (Default: 1.5)
        autoRollRollThreshold = 0 --export: (Default: 0)
        turnAssistFactor = 2 --export: (Default: 2)
        TrajectoryAlignmentStrength = 0.002 --export: (Default: 0.002)
        torqueFactor = 2 --export: (Default: 2)
        pitchSpeedFactor = 0.8 --export: (Default: 0.8)
        yawSpeedFactor = 1 --export: (Default: 1)
        brakeSpeedFactor = 3 --export: (Default: 3)
        brakeFlatFactor = 1 --export: (Default: 1)
        DampingMultiplier = 40 --export: (Default: 40) 
        minRollVelocity = 150 --export: (Default: 150)
        apTickRate = 0.0166667 --export: (Default: 0.0166667)  
        hudTickRate = 0.0666667 --export: (Default: 0.0666667)
        ExtraLongitudeTags = "none" --export: (Default: "none")
        ExtraLateralTags = "none" --export: (Default: "none")
        ExtraVerticalTags = "none" --export: (Default: "none")
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.143;SetWaypointOnExit=true;local b={"freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","userControlScheme","TargetOrbitRadius","apTickRate","SafeR","SafeG","SafeB","warmup","DeadZone","circleRad","MouseXSensitivity","MouseYSensitivity","MaxGameVelocity","pitchSpeedFactor","yawSpeedFactor","rollSpeedFactor","brakeSpeedFactor","brakeFlatFactor","autoRollFactor","turnAssistFactor","torqueFactor","AutoTakeoffAltitude","TargetHoverHeight","AutopilotInterplanetaryThrottle","DampingMultiplier","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","RemoteFreeze","hudTickRate","speedChangeLarge","speedChangeSmall","brakeLandingRate","MaxPitch","AtmoSpeedLimit","centerX","centerY","SpaceSpeedLimit","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","LandingGearGroundHeight","TrajectoryAlignmentStrength","YawStallAngle","PitchStallAngle","ResolutionX","ResolutionY","FuelTankOptimization","ContainerOptimization","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags","OrbitMapSize","OrbitMapX","OrbitMapY","autoRollRollThreshold","minRollVelocity","PvPR","PvPG","PvPB"}BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;showHelp=true;local c={"showHelp","VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=core.getConstructMass;local n=a.control.isRemoteControlled;local o=math.atan;local p=string.match;local tostring=tostring;local q=utils.round;local r=system.getTime;local vec3=vec3;local s=utils.clamp;local t=a.axisCommandManager;local u=system.destroyWidgetPanel;local v=system.updateData;local w=system.addDataToWidget;local x=system.lockView;local y=system.isViewLocked;local function z(A,B)local C=10^(B or 0)return e(A*C+0.5)/C end;local D=SafeR;local E=SafeB;local F=SafeG;local G=false;local H=0;local I=0;local J=0;local K=false;local L=0;local M=false;local N=z(ResolutionX/2,0)local O=z(ResolutionY/2,0)local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8,a9=0;local aa,ab=0;local ac=nil;local ad=0;local ae=0;local af=false;local ag=0;local ah=0;local ai=0;local aj=3;local ak=0;local al=""local am=""local an=0;local ao=false;local ap=false;local aq=false;local ar=-1;local as=false;local at=""local au=k()>0;local av=k()local aw=core.getAltitude()local ax=core.getElementIdList()local ay=r()local az=nil;local aA=false;local aB=[[rgb(]]..e(D+0.5)..","..e(F+0.5)..","..e(E+0.5)..[[)]]local aC=[[rgb(]]..e(D*0.9+0.5)..","..e(F*0.9+0.5)..","..e(E*0.9+0.5)..[[)]]local aD={}local aE=0;local aF=0;local aG=""local aH=true;local aI={}local aJ={}local aK={}local aL=ResolutionX;local aM=ResolutionY;local aN=false;local aO=false;local aP=0;local aQ=nil;local aR={}local aS={}local aT={}local aU=0;local aV=false;local aW={}local aX={}local aY=e(1/apTickRate)*2;local aZ={}local a_={}local b0={}local b1={}local b2=false;local b3=16;local b4=0;local b5=nil;local b6=""local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=nil;local bd=nil;local be=nil;local bf=nil;local bg=false;local bh=false;local bi=autoRollPreference;local bj=LandingGearGroundHeight;local bk=system.getMouseDeltaX()local bl=system.getMouseDeltaY()local bm=false;local bn=r()local bo=0;local bp=0;local bq=0;local br=AtmoSpeedLimit;local bs=0;local bt=nil;local bu=0;local bv=0;local bw=false;local bx=false;local by={VectorToTarget=false}local bz=false;local bA=0;local bB=nil;local bC=false;local bD=false;local bE=false;local bF=false;local bG=0;local bH=r()local bI=vec3(core.getConstructWorldOrientationUp())local bJ=vec3(core.getConstructWorldOrientationForward())local bK=vec3(core.getConstructWorldOrientationRight())local bL=vec3(core.getWorldVelocity())local bM=vec3(bL):len()local bN=vec3(core.getWorldVertical())local bO=-bN:dot(bL)local bP=vec3(core.getConstructWorldPos())local bQ=false;local bR=false;local bS=nil;local bT=true;local bU=0;local bV=0;local bW=false;local function bX(bY,bZ,b_,c0,c1)return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bY,bZ,b_,c0,c1)end;local function c2(c3,c4)if t:getAxisCommandType(0)~=axisCommandType.byThrottle and not c4 then a.control.cancelCurrentControlMasterMode()end;t:setThrottleCommand(axisCommandId.longitudinal,c3)I=s(z(c3*100,0)/100,-1,1)end;local function c5(c3,c4)if t:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not c4 then a.control.cancelCurrentControlMasterMode()end;t:setTargetSpeedCommand(axisCommandId.longitudinal,c3)bS=c3 end;local function c6()AtlasOrdered={}for c7,c8 in pairs(b5[0])do table.insert(AtlasOrdered,{name=c8.name,index=c7})end;local function c9(ca,cb)return ca.name<cb.name end;table.sort(AtlasOrdered,c9)end;local function cc(cd,ce)if cd==0 then return d(ce)<1e-09 end;if ce==0 then return d(cd)<1e-09 end;return d(cd-ce)<math.max(d(cd),d(ce))*epsilon end;local function cf(ak,cg)local ch=ak>100000;local ci,cj=""if cg==nil then cg=1 end;if ch then ci,cj=z(ak/1000/200,cg),"SU"elseif ak<1000 then ci,cj=z(ak,cg),"M"else ci,cj=z(ak/1000,cg),"KM"end;return ci,cj end;local function ck(cl)for c7,c8 in pairs(cl)do if c8.name and c8.name==CustomTarget.name then return c7 end end;return-1 end;local function cm()if VertTakeOff then AltitudeHold=false;StrongBrakes=true;Reentry=false;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=true;VertTakeOff=false;bi=true;ag=0;if au and ar==-1 then BrakeLanding=false;AltitudeHold=true;ag=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)c5(e(br))end else VertTakeOff=true;AltitudeHold=false;bC=false;GearExtended=false;a.control.retractLandingGears()t:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end end;local function cn()bC=false;bu=nil;bv=nil;bG=0;if av==0 then if IntoOrbit then IntoOrbit=false;bw=false;bB=nil;bi=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;by.VectorToTarget=false;by.AutopilotAlign=false;bz=false elseif unit.getClosestPlanetInfluence()>0 then IntoOrbit=true;bi=true;if bB==nil then bB=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage orbiting, not near planet"end else IntoOrbit=false;bw=false;bB=nil;bi=autoRollPreference;if AltitudeHold then AltitudeHold=false end;by.VectorToTarget=false;by.AutopilotAlign=false;bz=false end end;local function co()if bH-bp<1.5 then if planet.hasAtmosphere then if av>0 then HoldAltitude=planet.spaceEngineMinAltitude-50 else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+1000;bA=HoldAltitude;bz=true;if not IntoOrbit then cn()end;bw=true end end;bp=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bp=bH end;if unit.getClosestPlanetInfluence()>0 and av==0 then bA=aw;bz=true;bw=true;cn()if IntoOrbit then bp=bH else bp=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;bi=true;LockPitch=nil;bC=false;if ar==-1 then AutoTakeoff=false;if bp>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=aw end end;if VertTakeOff then cm()end else AutoTakeoff=true;if bp>-1 then HoldAltitude=aw+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;t:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bQ then cm()end end;if ap then HoldAltitude=100000 end else if IntoOrbit then cn()end;if VertTakeOff then cm()end;bi=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bp=0 end end;local function cp()if n()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()t:setTargetGroundAltitude(TargetHoverHeight)else BrakeIsOn=true;bi=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()t:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local function cq()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local cr=AtlasOrdered[AutopilotTargetIndex].index;local cs=b5[0][cr]if cs.center then AutopilotTargetName=cs.name;ac=bb[0][cr]if CustomTarget~=nil then if av==0 then if v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then w(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then w(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if v(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then w(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then w(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then w(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if v(widgetMaxMassText,widgetMaxMass)~=1 then w(widgetMaxMassText,widgetMaxMass)end;if v(widgetTravelTimeText,widgetTravelTime)~=1 then w(widgetTravelTimeText,widgetTravelTime)end;if v(widgetTargetOrbitText,widgetTargetOrbit)~=1 then w(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=cs;for _,c8 in pairs(bb[0])do if c8.name==CustomTarget.planetname then ac=c8;AutopilotTargetName=CustomTarget.name;break end end;if v(widgetMaxMassText,widgetMaxMass)~=1 then w(widgetMaxMassText,widgetMaxMass)end;if v(widgetTravelTimeText,widgetTravelTime)~=1 then w(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=be(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function ct(cu)if not Autopilot and not VectorToTarget and not ap and not IntoOrbit then if cu==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then cq()else local cr=AtlasOrdered[AutopilotTargetIndex].index;local cs=b5[0][cr]if cs.name=="Space"then if cu==nil then ct()else ct(1)end else cq()end end else a2="Disengage autopilot before changing Interplanetary Helper"end end;local function cv(planet,cw)local function cx(cy,cz)local cA=vec3(cz)if cy.bodyId==0 then return setmetatable({latitude=cA.x,longitude=cA.y,altitude=cA.z,bodyId=0,systemId=cy.planetarySystemId},MapPosition)end;local cB=cA-cy.center;local ak=cB:len()local cC=ak-cy.radius;local cD=0;local cE=0;if not cc(ak,0)then local cF=o(cB.y,cB.x)cE=cF>=0 and cF or 2*math.pi+cF;cD=math.pi/2-math.acos(cB.z/ak)end;return setmetatable({latitude=math.deg(cD),longitude=math.deg(cE),altitude=cC,bodyId=cy.bodyId,systemId=cy.planetarySystemId},MapPosition)end;local cG=cx(planet,cw)cG="::pos{"..cG.systemId..","..cG.bodyId..","..cG.latitude..","..cG.longitude..","..cG.altitude.."}"system.setWaypoint(cG)end;local function cH()local function cI(SpaceTarget)VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then co()end end;VectorStatus="Proceeding to Waypoint"end;if bH-bq<1.5 and av>0 then if not bF then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if av>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+1000 end;bq=-1;if Autopilot or VectorToTarget then return end end else bq=bH end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not ap then cq()cv(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then if av~=0 then ap=true;co()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if av>0 then if not VectorToTarget then cI(SpaceTarget)end else if aw>AutopilotTargetOrbit*1.5 or aw==0 then bC=false;Autopilot=true elseif not au then if IntoOrbit then cn()end;bA=planet.noAtmosphericDensityAltitude+1000;bz=true;by.AutopilotAlign=true;by.VectorToTarget=true;bw=false;if not IntoOrbit then cn()end end end else RetrogradeIsOn=false;ProgradeIsOn=false;if av~=0 then ap=true;co()else Autopilot=true end end elseif av==0 then local cJ=unit.getClosestPlanetInfluence()>0;if CustomTarget==nil and(ac.name==planet.name and cJ)and not IntoOrbit then WaypointSet=false;bC=false;bw=false;cn()else Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else ap=true;co()end else ap=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;P=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=aw;TargetSet=false;Reentry=false;if IntoOrbit then cn()end end end;local function cK(cL)local cM=-1;local cN;cM=ck(SavedLocations)if cM~=-1 then local cO;if cL~=nil then cN={position=SavedLocations[cM].position,name=cL,atmosphere=SavedLocations[cM].atmosphere,planetname=SavedLocations[cM].planetname,gravity=SavedLocations[cM].gravity}else cN={position=bP,name=SavedLocations[cM].name,atmosphere=av,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cM]=cN;cM=-1;cM=ck(b5[0])if cM>-1 then b5[0][cM]=cN end;c6()a2=CustomTarget.name.." position updated"AutopilotTargetIndex=0;cq()else a2="Name Not Found"end end;local function cP()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bi=autoRollPreference end;if BrakeIsOn then AltitudeHold=false;VectorToTarget=false;AutoTakeoff=false;VertTakeOff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;AltitudeHold=false;if VertTakeOff then cm()end;if IntoOrbit then cn()end;LockPitch=nil;bi=autoRollPreference;ao=false;aq=false;ag=0 end end;local function cQ(cR,cS,cT)local function cU(cR,cV)cR=vec3(cR)cV=vec3(cV):normalize()local ci=cR*cV;return ci.x+ci.y+ci.z end;local cW=0.001;local cX=1;if not au or not bm or ar~=-1 or bM<Q then local cY=cT;if cY==nil then cY=DampingMultiplier end;if cS==nil then cS=cW end;cR=vec3(cR):normalize()local cZ=vec3()-cR;local c_=-cU(cZ,core.getConstructWorldOrientationRight())*cX;local d0=-cU(cZ,core.getConstructWorldOrientationUp())*cX;if aE==0 then aE=c_/2 end;if aF==0 then aF=d0/2 end;if d(c_)<0.1 then V=V-c_*2 else V=V-(c_+(c_-aE)*cY)end;if d(d0)<0.1 then U=U+d0*2 else U=U+d0+(d0-aF)*cY end;aE=c_;aF=d0;if d(c_)<cS and d(d0)<cS then return true end;return false elseif bm and ar==-1 then cR=bL;local cY=cT;if cY==nil then cY=DampingMultiplier end;if cS==nil then cS=cW end;cR=vec3(cR):normalize()local cZ=bJ-cR;local c_=-cU(cZ,core.getConstructWorldOrientationRight())*cX;local d0=-cU(cZ,core.getConstructWorldOrientationUp())*cX;if aE==0 then aE=c_/2 end;if aF==0 then aF=d0/2 end;if d(c_)<0.1 then V=V-c_*5 else V=V-(c_+(c_-aE)*cY)end;if d(d0)<0.1 then U=U+d0*5 else U=U+d0+(d0-aF)*cY end;aE=c_;aF=d0;if d(c_)<cS and d(d0)<cS then return true end;return false end end;local function d1()if Reentry then a2="Re-Entry cancelled"Reentry=false;bi=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"aj=5 elseif not R then StrongBrakes=planet.gravity*9.80665*m()<LastMaxBrakeInAtmo;if not StrongBrakes then a2="WARNING: Insufficient Brakes for Parachute Re-Entry"else Reentry=true;if t:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bi=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..br end else Reentry=true;AltitudeHold=true;bi=true;BrakeIsOn=false;HoldAltitude=planet.spaceEngineMinAltitude-50;local c1,d2=cf(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..br.." Target Altitude: "..c1 ..d2;c5(e(br))end;AutoTakeoff=false end;local function d3()if antigrav and not ExternalAGG then if bR then antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=aw end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;antigrav.activate()antigrav.show()end end end;local function d4(d5)local d6=0;local d7=0;local d8=0;if d5<60 then d5=e(d5)elseif d5<3600 then d6=e(d5/60)d5=e(d5%60)elseif d5<86400 then d7=e(d5/3600)d6=e(d5%3600/60)else d8=e(d5/86400)d7=e(d5%86400/3600)end;if d8>0 then return d8 .."d "..d7 .."h "elseif d7>0 then return d7 .."h "..d6 .."m "elseif d6>0 then return d6 .."m "..d5 .."s"elseif d5>0 then return d5 .."s"else return"0s"end end;local function d9()local da=-1;if telemeter_1 then da=telemeter_1.getDistance()end;if ar~=-1 and da~=-1 then if ar<da then return ar else return da end elseif ar~=-1 then return ar else return da end end;local function db(dc)local function dd(de)for c7,c8 in pairs(de)do dbHud_1.setStringValue(c8,h(_G[c8]))if dc and dbHud_2 then dbHud_2.setStringValue(c8,h(_G[c8]))end end end;if dbHud_1 then if not af then dd(c)dd(b)system.print("Saved Variables to Datacore")if dc and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end end;local function df()local dg=-1;local dh=-1;if vBooster then dg=vBooster.distance()end;if hover then dh=hover.distance()end;if dg~=-1 and dh~=-1 then if dg<dh then return dg else return dh end elseif dg~=-1 then return dg elseif dh~=-1 then return dh else return-1 end end;local function di()local function dj(c8)if aL==1920 then return c8 else return z(aL*c8/1920,0)end end;local function dk(c8)if aM==1080 then return c8 else return z(aM*c8/1080,0)end end;local function dl()return y()==0 and userControlScheme~="keyboard"and n()==0 end;local function dm()local dn="TRAVEL"if not bT then dn="CRUISE"end;if Autopilot then dn="AUTOPILOT"end;return dn end;local function dp(dq,b2,bZ,dr,ds,dt,du,dv)local dw=1;local dx=2;local dy=3;local dz=4;local dA=5;local dB=6;local dC=""local dD=0;local dE=fuelY;local dF=fuelY+10;if n()==1 and not RemoteHud then dE=dE-50;dF=dF-50 end;dq[#dq+1]=[[<g class="pdim txtfuel">]]if ds=="ATMO"then dC="atmofueltank"elseif ds=="SPACE"then dC="spacefueltank"else dC="rocketfueltank"end;dD=_G[dC.."_size"]if#dt>0 then for i=1,#dt do local dG=string.sub(dt[i][dx],1,12)local dH=0;for dI=1,dD do if dt[i][dx]==g(unit[dC.."_"..dI].getData()).name then dH=dI;break end end;if b2 or du[i]==nil or dv[i]==nil then local dJ=0;local dK=0;local dL=0;local dM=0;local dN=r()if dH~=0 then dv[i]=g(unit[dC.."_"..dH].getData()).percentage;du[i]=g(unit[dC.."_"..dH].getData()).timeLeft;if du[i]=="n/a"then du[i]=0 end else dL=l(dt[i][dw])-dt[i][dz]dJ=dt[i][dy]dv[i]=e(0.5+dL*100/dJ)dK=dt[i][dA]dM=dt[i][dB]if dK<=dL then du[i]=0 else du[i]=e(0.5+dL/((dK-dL)/(dN-dM)))end;dt[i][dA]=dL;dt[i][dB]=dN end end;if dG==dr then dG=f("%s %d",ds,i)end;if dH==0 then dG=dG.." *"end;local dO;if du[i]==0 then dO="n/a"else dO=d4(du[i])end;if dv[i]~=nil then local dP=e(dv[i]*2.55)local dQ=f("rgb(%d,%d,%d)",255-dP,dP,0)local bY=""if dO~="n/a"and du[i]<120 or dv[i]<5 then if b2 then bY=[[class="red"]]end end;dq[#dq+1]=bX("",bZ,dE,bY,dG)dq[#dq+1]=bX("",bZ,dF,"fill:"..dQ,f("%d%% %s",dv[i],dO))dE=dE+30;dF=dF+30 end end end;dq[#dq+1]="</g>"end;local function dR(dq,cC)if cC<200000 and not au or cC and au then local dS=0;if d(bO)>1 then dS=45*math.log(d(bO),10)if bO<0 then dS=-dS end end;dq[#dq+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bO),e(dS))end;return dq end;local function dT(dU)local cu=-bN;dU=dU-dU:project_on(cu)local dV=vec3(0,0,1)dV=dV-dV:project_on(cu)local dW=dV:cross(cu)local dS=dV:angle_between(dU)*constants.rad2deg;if dU:dot(dW)<0 then dS=360-dS end;return dS end;local function dX(dq,centerX,centerY,dY,dZ,cJ)local d_=circleRad;local e0=20;local e1=e(dY)if cJ then for i=-45,45,5 do local e2=i;dq[#dq+1]=f([[<g transform="rotate(%f,%d,%d)">]],e2,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;dq[#dq+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+d_+e0-len,centerX,centerY+d_+e0)end;dq[#dq+1]=bX("pdim txt txtmid",centerX,centerY+d_+e0-35,"",dZ)dq[#dq+1]=bX("pdim txt txtmid",centerX,centerY+d_+e0-25,"",e1 .." deg")dq[#dq+1]=f([[<g transform="rotate(%f,%d,%d)">]],-dY,centerX,centerY)dq[#dq+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+d_+e0-20,centerX+5,centerY+d_+e0-20,centerX,centerY+d_+e0-15)dq[#dq+1]="</g>"end;local e3=e1;if cJ then e3=dT(bJ)end;local e4=20;local e5=e(e3)local e6=0;local e7=centerY+d_+e0+20;local e8=centerX;if dZ~="YAW"then e7=dk(130)e8=dj(960)end;local e9=[[<path class="txttick line" d="]]for i=e(e5-(e4+10)-e5%5+0.5),e(e5+e4+10+e5%5+0.5),5 do local bZ=e8+-i*5+e3*5;if i%10==0 then e6=10;local A=i;if A==360 then A=0 elseif A>360 then A=A-360 elseif A<0 then A=A+360 end;dq[#dq+1]=bX("",bZ+5,e7-12,"",A)elseif i%5==0 then e6=5 end;if e6==10 then e9=f([[%s M %f %f v %d]],e9,bZ,e7-5,e6)else e9=f([[%s M %f %f v %d]],e9,bZ,e7-2.5,e6)end end;dq[#dq+1]=e9 ..[["/>]]dq[#dq+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],e8-5,e7+10,e8+5,e7+10,e8,e7+5)if cJ then dZ="HDG"end;dq[#dq+1]=bX("pdim txt txtmid",e8,e7+25,"",e5 .."deg")dq[#dq+1]=bX("pdim txt txtmid",e8,e7+35,"",dZ)end;local function ea(dq,eb,dY,centerX,centerY,cJ,ec,ed)local d_=circleRad;local ee=e(d_*3/5)if d_>0 then local ef=e(eb)local len=0;local e9=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*dY,centerX,centerY)if not au then e9=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;dq[#dq+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],d_-1,centerX,centerY)dq[#dq+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(ef-30-ef%5+0.5),e(ef+30+ef%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local b_=centerY+-i*5+eb*5;if len==30 then e9=f([[%s M %d %f h %d]],e9,centerX-ee-len,b_,len)if au then dq[#dq+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*dY,centerX,centerY,centerX-ee+10,b_,i)dq[#dq+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*dY,centerX,centerY,centerX+ee-10,b_,i)if i==0 or i==180 or i==-180 then dq[#dq+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*dY,centerX,centerY,centerX-ee+20,b_,ee*2-40)end else dq[#dq+1]=bX("pdim txt txtmid",centerX-ee+10,b_,"",i)dq[#dq+1]=bX("pdim txt txtmid",centerX+ee-10,b_,"",i)end;e9=f([[%s M %d %f h %d]],e9,centerX+ee,b_,len)else e9=f([[%s M %d %f h %d]],e9,centerX-ee-len,b_,len)e9=f([[%s M %d %f h %d]],e9,centerX+ee,b_,len)end end;dq[#dq+1]=e9 ..[["/>]]local eg="PITCH"if not cJ then eg="REL PITCH"end;if eb>90 and not au then eb=90-(eb-90)elseif eb<-90 and not au then eb=-90-(eb+90)end;if d_>200 then if au then if ed>Q then dq[#dq+1]=bX("pdim txt txtmid",centerX,centerY-15,"","Yaw")dq[#dq+1]=bX("pdim txt txtmid",centerX,centerY+20,"",ec)end;dq[#dq+1]=f([[<g transform="rotate(%f,%d,%d)">]],-dY,centerX,centerY)else dq[#dq+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;dq[#dq+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-ee+25,centerY-5,centerX-ee+20,centerY,centerX-ee+25,centerY+5,centerX-ee+50,centerY+4,ef)dq[#dq+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+ee-25,centerY-5,centerX+ee-20,centerY,centerX+ee-25,centerY+5,centerX+ee-30,centerY+4,ef)dq[#dq+1]="</g>"end;local eh=e(d_/3)dq[#dq+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-eh,centerY,d_-eh)if not au and cJ then dq[#dq+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*dY,centerX,centerY,centerX-ee+10,centerY,ee*2-20)end;dq[#dq+1]="</g>"if d_<200 then if au and ed>Q then dq[#dq+1]=bX("pdim txt txtmid",centerX,centerY-d_,"",eg)dq[#dq+1]=bX("pdim txt txtmid",centerX,centerY-d_+10,"",ef)dq[#dq+1]=bX("pdim txt txtmid",centerX,centerY-15,"","Yaw")dq[#dq+1]=bX("pdim txt txtmid",centerX,centerY+20,"",ec)else dq[#dq+1]=f([["
                                    <g class="pdim txt txtmid">
                                    <text x="%d" y="%d">%s</text>
                                    <text x="%d" y="%d">%d deg</text>
                                    </g>
                                    ]],centerX,centerY-d_,eg,centerX,centerY-d_+15,ef)end end end end;local function ei(dq,cC,cJ)local ej=altMeterX;local ek=altMeterY;local el=78;local em=19;local en=d9()if en~=-1 then dq[#dq+1]=bX("pdim altsm txtend",ej+el,ek+em+20,"",f("AGL: %.1fm",en))end;if cJ and(cC<200000 and not au or cC and au)then table.insert(dq,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ej-1,ek-4,el+2,em+6,ej+1,ek-1,el-4,em))local cM=0;local eo=1;local ep=0;local eq=cC<0;local er=9;if eq then er=0 end;local cC=d(cC)while cM<6 do local es=11;local et=16;local eu=9;local ev=14;local bY="altsm"if cM>2 then et=et+3;es=es+2;ev=ev+2;eu=eu-6;bY="altbig"end;if eq then bY=bY.." red"end;local ew=cC/eo%10;local ex=e(ew)local ey=e((ex+1)%10)local ez=ep;if cM==0 then ez=ew-ex;if eq then ez=1-ez end end;if eq and(cM==0 or ep~=0)then local eA=ey;ey=ex;ex=eA end;local eB=et*(ez-1)local eC=eB+et;local bZ=ej+eu+(6-cM)*es;local b_=ek+ev;dq[#dq+1]=bX(bY,bZ,b_+eB,"",ey)dq[#dq+1]=bX(bY,bZ,b_+eC,"",ex)cM=cM+1;eo=eo*10;if ex==er then ep=ez else ep=0 end end;table.insert(dq,[[</g></g>]])end end;local function eD(eE)eE=vec3(eE)local eF=-math.deg(o(eE.y,eE.z))+180;eF=eF-90;if eF<0 then eF=360+eF end;if eF>180 then eF=-180+eF-180 end;return-eF end;local function eG(eE)eE=vec3(eE)local e3=math.deg(o(eE.y,eE.x))-90;if e3<-180 then e3=360+e3 end;return e3 end;local function eH(dq,eE,ed,centerX,centerY)if ed>5 and not au or ed>Q then local d_=circleRad;local eI=20;local eJ=20;local eK=vec3(eE)local eL=eD(eK)local eM=eG(eK)local eN=14;local eO=eN/2;local eP=-eM/eJ*d_;local eQ=eL/eI*d_;local bZ=centerX+eP;local b_=centerY+eQ;local ak=math.sqrt(eP^2+eQ^2)local eR=[[<circle
                            cx="]]..bZ..[["
                            cy="]]..b_..[["
                            r="]]..eO/eN..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bZ..[["
                            cy="]]..b_..[["
                            r="]]..eO..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bZ-eN..[[,]]..b_..[[ h ]]..eO..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bZ+eO..[[,]]..b_..[[ h ]]..eO..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bZ..[[,]]..b_-eN..[[ v ]]..eO..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ak<d_ then dq[#dq+1]=eR else local dS=o(eQ,eP)local eS=4;local eT=centerX+d_*math.cos(dS)local eU=centerY+d_*math.sin(dS)dq[#dq+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',dS*180/math.pi,eT,eU,eT-eS,eU-eS/2,eS*2,eS,eT+eS,eU-eS,eS,eS,-eS,eS)end;if not au then eL=eD(-eK)eM=eG(-eK)eP=-eM/eJ*d_;eQ=eL/eI*d_;bZ=centerX+eP;b_=centerY+eQ;ak=math.sqrt(eP^2+eQ^2)if ak<d_ then local eV=[[<circle
                                    cx="]]..bZ..[["
                                    cy="]]..b_..[["
                                    r="]]..eO..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bZ..[[,]]..b_-eN..[[ v ]]..eO..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bZ..[[,]]..b_..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bZ..[[,]]..b_..[[)" />
                                <path
                                    d="M ]]..bZ-eO..[[,]]..b_..[[ h ]]..eN..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bZ..[[,]]..b_..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bZ..[[,]]..b_..[[)"/>]]dq[#dq+1]=eV end end end end;local function eW(dq,dn,eX,eY)eX=e(eX+0.5)local dE=throtPosY+10;local dF=throtPosY+20;if n()==1 and not RemoteHud then dE=55;dF=65 end;local eZ="CRUISE"local unit="km/h"local c3=eY;if dn=="TRAVEL"or dn=="AUTOPILOT"then eZ="THROT"unit="%"c3=eX;local e_="dim"if eX<0 then e_="red"end;dq[#dq+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],e_,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(eX),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;dq[#dq+1]=bX("pbright txtstart",throtPosX+10,dE,"",eZ)dq[#dq+1]=bX("pbright txtstart",throtPosX+10,dF,"",f("%.0f %s",c3,unit))if au and AtmoSpeedAssist and bT and K then eX=e(L*100+0.5)local e_="red"if eX<0 then e_="red"end;dq[#dq+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],e_,1-d(eX),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)dq[#dq+1]=bX("pbright txtstart",throtPosX+10,dE+40,"","LIMIT")dq[#dq+1]=bX("pbright txtstart",throtPosX+10,dF+40,"",eX.."%")end;if au and AtmoSpeedAssist or Reentry then dq[#dq+1]=bX("dim txtstart",throtPosX+10,dE-40,"","LIMIT: "..br.." km/h")elseif not au and Autopilot then dq[#dq+1]=bX("dim txtstart",throtPosX+10,dE-40,"","LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h")end end;local function f0(dq,f1)local f2=throtPosY-10;local f3=throtPosX+10;dq[#dq+1]=[[<g class="pdim txt txtend">]]if n()==1 and not RemoteHud then f2=75 end;dq[#dq+1]=bX("pbright txtbig txtstart",f3,f2,"",e(f1).." km/h")end;local function f4(dq)dq[#dq+1]=bX("hudver",dj(1900),dk(1070),"",f("ARCH Hud Version: %.3f",VERSION_NUMBER))dq[#dq+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then dq[#dq+1]=bX("warnings",dj(960),dk(550),"","Warning: Invalid Control Scheme Detected")dq[#dq+1]=bX("warnings",dj(960),dk(600),"","Keyboard Scheme must be selected")dq[#dq+1]=bX("warnings",dj(960),dk(650),"","Set your preferred scheme in Lua Parameters instead")end;local f5=dj(960)local f6=dk(860)local f7=dk(880)local f8=dk(900)local f9=dk(960)local fa=dk(200)local fb=dk(150)local fc=dk(960)if n()==1 and not RemoteHud then f6=dk(135)f7=dk(155)f8=dk(175)fa=dk(115)fb=dk(95)end;if BrakeIsOn then dq[#dq+1]=bX("warnings",f5,f6,"","Brake Engaged")elseif J>0 then dq[#dq+1]=bX("warnings",f5,f6,"opacity:"..J,"Auto-Brake Engaged")end;if au and bm and ar==-1 then dq[#dq+1]=bX("warnings",f5,fa+50,"","** STALL WARNING **")end;if az then dq[#dq+1]=bX("warnings",f5,fc,"","Gyro Enabled")end;if GearExtended then if S then dq[#dq+1]=bX("warn",f5,f7,"","Gear Extended")else dq[#dq+1]=bX("warnings",f5,f7,"","Landed (G: Takeoff)")end;local fd,cj=cf(a:getTargetGroundAltitude())dq[#dq+1]=bX("warn",f5,f8,"",f("Hover Height: %s",fd..cj))end;if a7 then dq[#dq+1]=bX("warn",f5,f9+20,"","ROCKET BOOST ENABLED")end;if antigrav and not ExternalAGG and bR and AntigravTargetAltitude~=nil then if d(aw-antigrav.getBaseAltitude())<501 then dq[#dq+1]=bX("warn",f5,fa+15,"",f("AGG On - Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())))else dq[#dq+1]=bX("warnings",f5,fa+15,"",f("AGG On - Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())))end elseif Autopilot and AutopilotTargetName~="None"then dq[#dq+1]=bX("warn",f5,fa+20,"",f("Autopilot %s",AutopilotStatus))elseif LockPitch~=nil then dq[#dq+1]=bX("warn",f5,fa+20,"",f("LockedPitch: %d",e(LockPitch)))elseif a0 then dq[#dq+1]=bX("warn",f5,fa+20,"","Follow Mode Engaged")elseif Reentry then dq[#dq+1]=bX("warn",f5,fa+20,"","Re-entry in Progress")end;local fe,ff,fg=bb:getPlanetarySystem(0):castIntersections(bP,bL:normalize(),function(fh)if fh.noAtmosphericDensityAltitude>0 then return fh.radius+fh.noAtmosphericDensityAltitude else return fh.radius+fh.surfaceMaxAltitude*1.5 end end)local fi=ff;if fg~=nil and ff~=nil then fi=math.min(fg,ff)end;if AltitudeHold or VertTakeOff then local fd,cj=cf(HoldAltitude,2)if VertTakeOff then if bR then fd,cj=cf(antigrav.getBaseAltitude(),2)end;dq[#dq+1]=bX("warn",f5,fa,"",f("VTO to %s",fd..cj))elseif AutoTakeoff and not IntoOrbit then dq[#dq+1]=bX("warn",f5,fa,"",f("Takeoff to %s",fd..cj))if BrakeIsOn and not VertTakeOff then dq[#dq+1]=bX("crit",f5,fa+50,"","Throttle Up and Disengage Brake For Takeoff")end else dq[#dq+1]=bX("warn",f5,fa,"",f("Altitude Hold: %s",fd..cj))end end;if VertTakeOff and(antigrav~=nil and antigrav)then if av>0.1 then dq[#dq+1]=bX("warn",f5,fa,"","Beginning ascent")elseif av<0.09 and av>0.05 then dq[#dq+1]=bX("warn",f5,fa,"","Aligning trajectory")elseif av<0.05 then dq[#dq+1]=bX("warn",f5,fa,"","Leaving atmosphere")end end;if IntoOrbit then if bt~=nil then dq[#dq+1]=bX("warn",f5,fa,"",bt)end end;if BrakeLanding then if StrongBrakes then dq[#dq+1]=bX("warnings",f5,fa,"","Brake-Landing")else dq[#dq+1]=bX("warnings",f5,fa,"","Coast-Landing")end end;if ProgradeIsOn then dq[#dq+1]=bX("crit",f5,fa,"","Prograde Alignment")end;if RetrogradeIsOn then dq[#dq+1]=bX("crit",f5,fa,"","Retrograde Alignment")end;if fi~=nil and av==0 then local fd,cj=cf(fi)local travelTime=bc.computeTravelTime(bM,0,fi)local fj="Collision"if fe.noAtmosphericDensityAltitude>0 then fj="Atmosphere"end;dq[#dq+1]=bX("crit",f5,fb,"",f("%s %s In %s (%s)",fe.name,fj,d4(travelTime),fd..cj))end;if VectorToTarget and not IntoOrbit then dq[#dq+1]=bX("warn",f5,fa+35,"",VectorStatus)end;dq[#dq+1]="</g>"return dq end;local function fk(ed)return e(z(ed*3.6,0)+0.5).." km/h"end;local function fl(dq)local fm=OrbitMapX;local fn=OrbitMapY;local fo=OrbitMapSize;local fp=4;local fq=15;local bZ=0;local b_=0;local fr,fs,ft,fu;local function fv(type)local fw,bH,ed,fx;if type=="Periapsis"then fw=orbit.periapsis.altitude;bH=orbit.timeToPeriapsis;ed=orbit.periapsis.speed;fx=35 else fw=orbit.apoapsis.altitude;bH=orbit.timeToApoapsis;ed=orbit.apoapsis.speed;fx=-35 end;dq[#dq+1]=f([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],bZ+fx,b_-5,fm+fo/2-fr+fu,b_-5)dq[#dq+1]=bX("",bZ,b_,"",type)b_=b_+fq;local fd,cj=cf(fw)dq[#dq+1]=bX("",bZ,b_,"",fd..cj)b_=b_+fq;dq[#dq+1]=bX("",bZ,b_,"",d4(bH))b_=b_+fq;dq[#dq+1]=bX("",bZ,b_,"",fk(ed))end;if orbit~=nil and av<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then fn=fn+fp;bZ=fm+fo+fm/2+fp;b_=fn+fo/2+5+fp;fr=fo/4;fu=0;dq[#dq+1]=[[<g class="pbright txtorb txtmid">]]dq[#dq+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',fo+fm*2,fo+fn,fp,fp)if orbit.periapsis~=nil and orbit.apoapsis~=nil then ft=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(fr*2)fs=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/ft*(1-orbit.eccentricity)fu=fr-orbit.periapsis.altitude/ft-planet.radius/ft;local fy=""if orbit.periapsis.altitude<=0 then fy='redout'end;dq[#dq+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],fy,fm+fo/2+fu+fp,fn+fo/2+fp,fr,fs)dq[#dq+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',fm+fo/2+fp,fn+fo/2+fp,planet.radius/ft)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then fv("Apoapsis")end;b_=fn+fo/2+5+fp;bZ=fm-fm/2+10+fp;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then fv("Periapsis")end;dq[#dq+1]=bX("txtorbbig",fm+fo/2+fp,20+fp,"",planet.name)if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local fz=orbit.timeToApoapsis/orbit.period*2*math.pi;local fA=fr*math.cos(fz)local fB=fs*math.sin(fz)dq[#dq+1]=f('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',fm+fo/2+fA+fu+fp,fn+fo/2+fB+fp)end;dq[#dq+1]=[[</g>]]return dq else return dq end end;local function fC()if radarPanelID~=nil and an==0 then u(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then u(perisPanelID)perisPanelID=nil end else if an==1 then u(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;an=0 end end;local function fD(dq)local function fE(fF,fG)for i=1,#fG do table.insert(fF,fG[i])end;return fF end;local bZ=50;local b_=525;local fH={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local fI={"Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to +1k over atmosphere and orbit to target","Alt-5: Lock Pitch at current pitch","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-9: Activate Gyroscope"}local fJ={"Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at 1k over atmosphere","Alt-9: Activate Gyroscope"}local fK={"CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if au then fE(fH,fI)table.insert(fH,"---------------------------------------")if VertTakeOff then table.insert(fH,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ar~=-1 then if antigrav then if bR then table.insert(fH,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(fH,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(fH,"Alt-6: Begins Vertical Takeoff.")else table.insert(fH,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(fH,"G: Begin BrakeLanding or Land")end else fE(fH,fJ)end;if AltitudeHold then table.insert(fH,"Alt-Spacebar/Alt-C will raise/lower target height")end;table.insert(fH,"---------------------------------------")fE(fH,fK)dq[#dq+1]=[[<g class="pdim txttick txtstart">]]for i=1,#fH do b_=b_+12;dq[#dq+1]=bX("pdim txttick txtstart",bZ,b_,"",fH[i])end;dq[#dq+1]="</g>"end;local fL={}function fL.HUDPrologue(dq)if not G then D=PvPR;F=PvPG;E=PvPB else D=SafeR;F=SafeG;E=SafeB end;aB=[[rgb(]]..e(D+0.5)..","..e(F+0.5)..","..e(E+0.5)..[[)]]aC=[[rgb(]]..e(D*0.9+0.5)..","..e(F*0.9+0.5)..","..e(E*0.9+0.5)..[[)]]local fM=aB;local fN=aC;local fO=aB;local fP=aC;if dl()and not brightHud then fM=[[rgb(]]..e(D*0.4+0.5)..","..e(F*0.4+0.5)..","..e(E*0.3+0.5)..[[)]]fN=[[rgb(]]..e(D*0.3+0.5)..","..e(F*0.3+0.5)..","..e(E*0.2+0.5)..[[)]]end;dq[#dq+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],fM,fM,fO,fO,fN,fN,fP,fP,aL,aM)return dq end;function fL.UpdateHud(dq)local cC=aw;local eE=core.getVelocity()local ed=vec3(eE):len()local eF=bU;local fQ=bV;local dY=fQ;local eb=bU;local eX=e(unit.getThrottle())local f1=ed*3.6;local eY=unit.getAxisCommandValue(0)local fR=dj(1770)local fS=dk(310)if AtmoSpeedAssist and bT then eY=I;eX=I*100 end;local dn=dm()local dZ="ROLL"local cJ=unit.getClosestPlanetInfluence()>0;if eX==nil then eX=0 end;if not cJ then if ed>5 then eF=eD(eE)fQ=eG(eE)else eF=0;fQ=0 end;dZ="YAW"end;if H>50000 and not au then local fT;if H>200000 then fT=z(H/200000,2).." su"else fT=z(H/1000,1).." km"end;dq[#dq+1]=bX("pbright txtbig txtmid",fR,fS,"",f("PvP Boundary: %s",fT))end;dq[#dq+1]=am;dq[#dq+1]=aG;dq[#dq+1]=al;if b4%aY==0 then b2=true end;if fuelX~=0 and fuelY~=0 then dp(dq,b2,fuelX,"Atmospheric ","ATMO",aR,b0,b1)dp(dq,b2,fuelX+100,"Space fuel t","SPACE",aS,aZ,a_)dp(dq,b2,fuelX+200,"Rocket fuel ","ROCKET",aT,aW,aX)end;if b2 then b2=false;b4=0 end;b4=b4+1;dR(dq,cC)if n()==0 or RemoteHud then if not dl()or brightHud then if cJ then dX(dq,centerX,centerY,dY,dZ,cJ)ea(dq,eb,dY,centerX,centerY,cJ,e(eG(eE)),ed)else dX(dq,centerX,centerY,fQ,dZ,cJ)ea(dq,eF,fQ,centerX,centerY,cJ,e(fQ),ed)end;ei(dq,cC,cJ)eH(dq,eE,ed,centerX,centerY)end end;eW(dq,dn,eX,eY)f0(dq,f1)f4(dq)fl(dq)if showHelp then fD(dq)end;if screen_2 then local fU=bP;local bZ=960+fU.x/b7;local b_=450+fU.y/b8;screen_2.moveContent(b9,(bZ-80)/19.2,(b_-80)/10.8)end;return dq end;function fL.HUDEpilogue(dq)dq[#dq+1]="</svg>"return dq end;function fL.DrawOdometer(dq,ad,TotalDistanceTravelled,ae,fV)local fW=dj(1240)local fX=dk(55)local fY=fX+10;local fZ=core.g()local f_=0;local g0=0;local g1=0;local dn=dm()if VertTakeOffEngine then dn=dn.."-VERTICAL"end;if TurnBurn then dn="TB-"..dn end;if au then g1=LastMaxBrakeInAtmo else g1=LastMaxBrake end;maxThrust=a:maxForceForward()aP=m()local g2=vec3(core.getWorldAcceleration()):len()/9.80665;fZ=planet:getGravity(planet.center+vec3(0,0,1)*planet.radius):len()if fZ>0.1 then g0=aP*fZ;f_=maxThrust/fZ end;dq[#dq+1]=[[<g class="pdim txt txtend">]]if n()==1 and not RemoteHud then fW=dj(1120)fX=dk(55)fY=fX+10 elseif au then local g3=dj(770)dq[#dq+1]=bX("pdim txt txtend",g3,fX,"","ATMOSPHERE")dq[#dq+1]=bX("pdim txt txtend",g3,fY,"",f("%.2f",av))end;dq[#dq+1]=bX("pdim txt txtend",fW,fX,"","GRAVITY")dq[#dq+1]=bX("pdim txt txtend",fW,fY,"",f("%.2f",fZ/9.80665))dq[#dq+1]=bX("pdim txt txtend",fW,fX+20,"","ACCEL")dq[#dq+1]=bX("pdim txt txtend",fW,fY+20,"",f("%.2f",g2))dq[#dq+1]=f([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],dj(660),dj(700),dk(35),dj(960),dk(55),dj(1240),dk(35),dj(1280))if n()==0 or RemoteHud then dq[#dq+1]=bX("txtstart",dj(700),dk(20),"",f("Trip: %.2f km",ad))dq[#dq+1]=bX("txtstart",dj(700),dk(30),"",f("Lifetime: %.2f Mm",TotalDistanceTravelled/1000))dq[#dq+1]=bX("txtstart",dj(830),dk(20),"","Trip Time: "..d4(ae))dq[#dq+1]=bX("txtstart",dj(830),dk(30),"","Total Time: "..d4(TotalFlightTime))dq[#dq+1]=bX("txtstart",dj(970),dk(20),"",f("Mass: %.2f Tons",aP/1000))dq[#dq+1]=bX("txtend",dj(1240),dk(10),"",f("Max Brake: %.2f kN",g1/1000))dq[#dq+1]=bX("txtend",dj(1240),dk(30),"",f("Max Thrust: %.2f kN",maxThrust/1000))dq[#dq+1]=bX("txtbig txtmid",dj(960),dk(180),"",dn)if fZ>0.1 then dq[#dq+1]=bX("txtstart",dj(970),dk(30),"",f("Max Mass: %.2f Tons",f_/1000))dq[#dq+1]=bX("txtend",dj(1240),dk(20),"",f("Req Thrust: %.2f kN",g0/1000))else dq[#dq+1]=bX("txtstart",dj(970),dk(30),"","Max Mass: n/a")dq[#dq+1]=bX("txtend",dj(1240),dk(20),"","Req Thrust: n/a")end else dq[#dq+1]=bX("txtbig txtmid",dj(960),dk(33),"",dn)end;dq[#dq+1]="</g>"return dq end;function fL.DrawWarnings(dq)return f4(dq)end;function fL.DisplayOrbitScreen(dq)return fl(dq)end;function fL.DisplayMessage(dq,fd)if fd~="empty"then dq[#dq+1]=[[<text class="msg" x="50%%" y="310" >]]for g4 in string.gmatch(fd,"([^\n]+)")do dq[#dq+1]=f([[<tspan x="50%%" dy="35">%s</tspan>]],g4)end;dq[#dq+1]=[[</text>]]end;if aj~=0 then unit.setTimer("msgTick",aj)aj=0 end end;function fL.DrawDeadZone(dq)dq[#dq+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function fL.UpdateRadar()if radar_1 then local g5=radar_1.getEntries()local g6=radar_1.getData()local g7=dj(1770)local g8=dk(330)if#g5>0 then local g9=g6:find('identifiedConstructs":%[%]')if g9==nil and perisPanelID==nil then an=1;fC()end;if g9~=nil and perisPanelID~=nil then fC()end;if radarPanelID==nil then fC()end;al=bX("pbright txtbig txtmid",g7,g8,"",f("Radar: %i contacts",#g5))local ga={}for c7,c8 in pairs(g5)do if radar_1.hasMatchingTransponder(c8)==1 then table.insert(ga,c8)end end;if#ga>0 then local b_=dk(15)local bZ=dj(1370)al=al..bX("pbright txtbig txtmid",bZ,b_,"","Friendlies In Range")for c7,c8 in pairs(ga)do b_=b_+20;al=al..bX("pdim txtmid",bZ,b_,"",radar_1.getConstructName(c8))end end else local gb;gb=g6:find('worksInEnvironment":false')if gb then al=bX("pbright txtbig txtmid",g7,g8,"","Radar: Jammed")else al=bX("pbright txtbig txtmid",g7,g8,"","Radar: No Contacts")end;if radarPanelID~=nil then an=0;fC()end end end end;return fL end;local function gc()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function gd()local function ge(gf)return type(gf)=='number'end;local function gg(gf)return type(tonumber(gf))=='number'end;local function gh(gi)return type(gi)=='table'end;local function gj(gk)return type(gk)=='string'end;local function gl(c8)return gh(c8)and ge(c8.x and c8.y and c8.z)end;local function gm(gn)return gh(gn)and ge(gn.latitude and gn.longitude and gn.altitude and gn.bodyId and gn.systemId)end;local go=math.pi/180;local gp=180/math.pi;local epsilon=1e-10;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local gq='::pos{'..A..','..A..','..A..','..A..','..A..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local gr=s;local function cc(cd,ce)if cd==0 then return d(ce)<1e-09 end;if ce==0 then return d(cd)<1e-09 end;return d(cd-ce)<math.max(d(cd),d(ce))*epsilon end;local function gs(gf)local ci=string.gsub(string.reverse(f('%.4f',gf)),'^0*%.?','')return ci==''and'0'or string.reverse(ci)end;local function gt(gu)if gl(gu)then return f('{x=%.3f,y=%.3f,z=%.3f}',gu.x,gu.y,gu.z)end;if gh(gu)and not getmetatable(gu)then local gv={}local gw=next(gu)if type(gw)=='nil'or gw==1 then gv=gu else for c7,c8 in pairs(gu)do local c3=gt(c8)if type(c7)=='number'then table.insert(gv,f('[%s]=%s',c7,c3))else table.insert(gv,f('%s=%s',c7,c3))end end end;return f('{%s}',table.concat(gv,','))end;if gj(gu)then return f("'%s'",gu:gsub("'",[[\']]))end;return tostring(gu)end;local gx={}gx.__index=gx;gx.__tostring=function(gu,gy)local gz={}for c7 in pairs(gu)do table.insert(gz,c7)end;table.sort(gz)local gv={}for _,c7 in ipairs(gz)do local c3=gt(gu[c7])if type(c7)=='number'then table.insert(gv,f('[%s]=%s',c7,c3))else table.insert(gv,f('%s=%s',c7,c3))end end;if gy then return f('%s%s',gy,table.concat(gv,',\n'..gy))end;return f('{%s}',table.concat(gv,','))end;gx.__eq=function(gA,gB)return gA.planetarySystemId==gB.planetarySystemId and gA.bodyId==gB.bodyId and cc(gA.radius,gB.radius)and cc(gA.center.x,gB.center.x)and cc(gA.center.y,gB.center.y)and cc(gA.center.z,gB.center.z)and cc(gA.GM,gB.GM)end;local function gC(gD,gE,gF,cz,gG)assert(gg(gD),'Argument 1 (planetarySystemId) must be a number:'..type(gD))assert(gg(gE),'Argument 2 (bodyId) must be a number:'..type(gE))assert(gg(gF),'Argument 3 (radius) must be a number:'..type(gF))assert(gh(cz),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cz))assert(gg(gG),'Argument 5 (GM) must be a number:'..type(gG))return setmetatable({planetarySystemId=tonumber(gD),bodyId=tonumber(gE),radius=tonumber(gF),center=vec3(cz),GM=tonumber(gG)},gx)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(gH)return f('::pos{%d,%d,%s,%s,%s}',gH.systemId,gH.bodyId,gs(gH.latitude*gp),gs(gH.longitude*gp),gs(gH.altitude))end;MapPosition.__eq=function(gA,gB)return gA.bodyId==gB.bodyId and gA.systemId==gB.systemId and cc(gA.latitude,gB.latitude)and cc(gA.altitude,gB.altitude)and(cc(gA.longitude,gB.longitude)or cc(gA.latitude,math.pi/2)or cc(gA.latitude,-math.pi/2))end;local function gI(gJ,gE,cD,cE,cC)local gD=gJ;if gj(gJ)and not cE and not cC and not gE and not cD then gD,gE,cD,cE,cC=p(gJ,gq)assert(gD,'Argument 1 (position string) is malformed.')else assert(gg(gD),'Argument 1 (systemId) must be a number:'..type(gD))assert(gg(gE),'Argument 2 (bodyId) must be a number:'..type(gE))assert(gg(cD),'Argument 3 (latitude) must be in degrees:'..type(cD))assert(gg(cE),'Argument 4 (longitude) must be in degrees:'..type(cE))assert(gg(cC),'Argument 5 (altitude) must be in meters:'..type(cC))end;gD=tonumber(gD)gE=tonumber(gE)cD=tonumber(cD)cE=tonumber(cE)cC=tonumber(cC)if gE==0 then return setmetatable({latitude=cD,longitude=cE,altitude=cC,bodyId=gE,systemId=gD},MapPosition)end;return setmetatable({latitude=go*gr(cD,-90,90),longitude=go*(cE%360),altitude=cC,bodyId=gE,systemId=gD},MapPosition)end;local gK={}gK.__index=gK;gK.__tostring=function(gu,gy)local gL=gy and gy..'  'local gM={}local gz={}for c7 in pairs(gu)do table.insert(gz,c7)end;table.sort(gz)for _,gN in ipairs(gz)do bdy=gu[gN]local gO=gx.__tostring(bdy,gL)if gy then table.insert(gM,f('[%s]={\n%s\n%s}',gN,gO,gy))else table.insert(gM,f('  [%s]=%s',gN,gO))end end;if gy then return f('\n%s%s%s',gy,table.concat(gM,',\n'..gy),gy)end;return f('{\n%s\n}',table.concat(gM,',\n'))end;local function gP(gQ)local b5={}local pid;for _,c8 in pairs(gQ)do local gR=c8.planetarySystemId;if type(gR)~='number'then error('Invalid planetary system ID: '..tostring(gR))elseif pid and gR~=pid then error('Mistringmatch planetary system IDs: '..gR..' and '..pid)end;local gS=c8.bodyId;if type(gS)~='number'then error('Invalid body ID: '..tostring(gS))elseif b5[gS]then error('Duplicate body ID: '..tostring(gS))end;setmetatable(c8.center,getmetatable(vec3.unit_x))b5[gS]=setmetatable(c8,gx)pid=gR end;return setmetatable(b5,gK)end;ba={}local function gT(gQ)return setmetatable({galaxyAtlas=gQ or{}},ba)end;ba.__index=function(gi,i)if type(i)=='number'then local system=gi.galaxyAtlas[i]return gP(system)end;return rawget(ba,i)end;ba.__pairs=function(gu)return function(gi,c7)local gU,nv=next(gi,c7)return gU,nv and gP(nv)end,gu.galaxyAtlas,nil end;ba.__tostring=function(gu)local gV={}for _,gW in pairs(gu or{})do local gX=gW:getPlanetarySystemId()local gY=gK.__tostring(gW,'    ')table.insert(gV,f('  [%s]={%s\n  }',gX,gY))end;return f('{\n%s\n}\n',table.concat(gV,',\n'))end;ba.BodyParameters=gC;ba.MapPosition=gI;ba.PlanetarySystem=gP;function ba.createBodyParameters(gZ,gE,g_,h0,h1,h2,h3)assert(gg(gZ),'Argument 1 (planetarySystemId) must be a number:'..type(gZ))assert(gg(gE),'Argument 2 (bodyId) must be a number:'..type(gE))assert(gg(g_),'Argument 3 (surfaceArea) must be a number:'..type(g_))assert(gh(h0),'Argument 4 (aPosition) must be an array or vec3:'..type(h0))assert(gh(h1),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(h1))assert(gg(h2),'Argument 6 (altitude) must be in meters:'..type(h2))assert(gg(h3),'Argument 7 (gravityAtPosition) must be number:'..type(h3))local gF=math.sqrt(g_/4/math.pi)local ak=gF+h2;local h4=vec3(h0)+ak*vec3(h1)local gG=h3*ak*ak;return gC(gZ,gE,gF,h4,gG)end;ba.isMapPosition=gm;function ba:getPlanetarySystem(gJ)if i==nil then i=0 end;if nv==nil then nv=0 end;local gZ=gJ;if gm(gJ)then gZ=gJ.systemId end;if type(gZ)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=gK then system=gP(system)end;return system end end end;function gK:castIntersections(h5,cV,h6,h7)local h6=h6 or function(fh)return 1.05*fh.radius end;local h8={}if h7 then for _,i in ipairs(h7)do h8[i]=self[i]end else h7={}for c7,fh in pairs(self)do table.insert(h7,c7)h8[c7]=fh end end;local function h9(ha,hb)local hc=h8[ha].center-h5;local hd=h8[hb].center-h5;return hc:len()<hd:len()end;table.sort(h7,h9)local he=cV:normalize()for i,gR in ipairs(h7)do local fh=h8[gR]local hf=fh.center-h5;local gF=h6(fh)local hg=hf:dot(he)local hh=hg^2-(hf:len2()-gF^2)if hh>=0 then local hi=math.sqrt(hh)local ff=hg+hi;local fg=hg-hi;if fg>0 then return fh,ff,fg elseif ff>0 then return fh,ff,nil end end end;return nil,nil,nil end;function gK:closestBody(cw)assert(type(cw)=='table','Invalid coordinates.')local hj,fh;local hk=vec3(cw)for _,hl in pairs(self)do local hm=(hl.center-hk):len2()if(not fh or hm<hj)and hl.name~="Space"then fh=hl;hj=hm end end;return fh end;function gK:convertToBodyIdAndWorldCoordinates(gJ)local hn=gJ;if gj(gJ)then hn=gI(gJ)end;if hn.bodyId==0 then return 0,vec3(hn.latitude,hn.longitude,hn.altitude)end;local hl=self:getBodyParameters(hn)if hl then return hn.bodyId,hl:convertToWorldCoordinates(hn)end end;function gK:getBodyParameters(gJ)local gE=gJ;if gm(gJ)then gE=gJ.bodyId end;assert(gg(gE),'Argument 1 (bodyId) must be a number:'..type(gE))return self[gE]end;function gK:getPlanetarySystemId()local _,c8=next(self)return c8 and c8.planetarySystemId end;function gx:convertToMapPosition(cz)assert(gh(cz),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cz))local cA=vec3(cz)if self.bodyId==0 then return setmetatable({latitude=cA.x,longitude=cA.y,altitude=cA.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local cB=cA-self.center;local ak=cB:len()local cC=ak-self.radius;local cD=0;local cE=0;if not cc(ak,0)then local cF=o(cB.y,cB.x)cE=cF>=0 and cF or 2*math.pi+cF;cD=math.pi/2-math.acos(cB.z/ak)end;return setmetatable({latitude=cD,longitude=cE,altitude=cC,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function gx:convertToWorldCoordinates(gJ)local hn=gj(gJ)and gI(gJ)or gJ;if hn.bodyId==0 then return vec3(hn.latitude,hn.longitude,hn.altitude)end;assert(gm(hn),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(hn.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(hn.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local ho=math.cos(hn.latitude)return self.center+(self.radius+hn.altitude)*vec3(ho*math.cos(hn.longitude),ho*math.sin(hn.longitude),math.sin(hn.latitude))end;function gx:getAltitude(cz)return(vec3(cz)-self.center):len()-self.radius end;function gx:getDistance(cz)return(vec3(cz)-self.center):len()end;function gx:getGravity(cz)local hp=self.center-vec3(cz)local hq=hp:len2()return self.GM/hq*hp/math.sqrt(hq)end;return setmetatable(ba,{__call=function(_,...)return gT(...)end})end;function script.onStart()local function hr()local function hs(ht)local hu=dbHud_1.hasKey;for c7,c8 in pairs(ht)do if hu(c8)then local ci=g(dbHud_1.getStringValue(c8))if ci~=nil then _G[c8]=ci;aN=true end end end end;if dbHud_1 then local hu=dbHud_1.hasKey;if not useTheseSettings then hs(b)else a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"aj=5 end;coroutine.yield()hs(c)if aN then a2="Loaded Saved Variables (see Lua Chat Tab for list)"N=z(ResolutionX/2,0)O=z(ResolutionY/2,0)aL=ResolutionX;aM=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bi=autoRollPreference;br=AtmoSpeedLimit;aB=[[rgb(]]..e(D+0.5)..","..e(F+0.5)..","..e(E+0.5)..[[)]]aC=[[rgb(]]..e(D*0.9+0.5)..","..e(F*0.9+0.5)..","..e(E*0.9+0.5)..[[)]]else a2="No Saved Variables Found - Stand up / leave remote to save settings"end else a2="No databank found, install one anywhere and rerun the autoconfigure to save variables"end;if LastStartTime+180<bH then LastMaxBrakeInAtmo=0 end;LastStartTime=bH;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.  Change userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"aj=5 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=aw end;antigrav.setBaseAltitude(AntigravTargetAltitude)end end;local function hv()local function hw(hx,hy)if hx>hy then hy=hx end;if ContainerOptimization>0 then hy=hy-hy*ContainerOptimization*0.05 end;if FuelTankOptimization>0 then hy=hy-hy*FuelTankOptimization*0.05 end;return hy end;local hz=core.getElementNameById;local hA=fuelX~=0 and fuelY~=0;for c7 in pairs(ax)do local type=core.getElementTypeById(ax[c7])if p(type,'^.*Atmospheric Engine$')then if p(tostring(core.getElementTagsById(ax[c7])),'^.*vertical.*$')then bQ=true end end;if p(type,'^.*Space Engine$')then bF=true;if p(tostring(core.getElementTagsById(ax[c7])),'^.*vertical.*$')then local hB=core.getElementRotationById(ax[c7])if hB[4]<0 then if q(-hB[4],0.1)==0.5 then bD=true end else if q(hB[4],0.1)==0.5 then bE=true end end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local hC=j(ax[c7])if hC>10000 then b3=128 elseif hC>1000 then b3=64 elseif hC>150 then b3=32 end end;aU=aU+j(ax[c7])if hA and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local hC=j(ax[c7])local hD=l(ax[c7])local hx=0;local dN=r()if type=="Atmospheric Fuel Tank"then local hy=400;local hE=35.03;if hC>10000 then hy=51200;hE=5480 elseif hC>1300 then hy=6400;hE=988.67 elseif hC>150 then hy=1600;hE=182.67 end;hx=hD-hE;if fuelTankHandlingAtmo>0 then hy=hy+hy*fuelTankHandlingAtmo*0.2 end;hy=hw(hx,hy)aR[#aR+1]={ax[c7],hz(ax[c7]),hy,hE,hx,dN}end;if type=="Rocket Fuel Tank"then local hy=320;local hE=173.42;if hC>65000 then hy=40000;hE=25740 elseif hC>6000 then hy=5120;hE=4720 elseif hC>700 then hy=640;hE=886.72 end;hx=hD-hE;if fuelTankHandlingRocket>0 then hy=hy+hy*fuelTankHandlingRocket*0.1 end;hy=hw(hx,hy)aT[#aT+1]={ax[c7],hz(ax[c7]),hy,hE,hx,dN}end;if type=="Space Fuel Tank"then local hy=2400;local hE=182.67;if hC>10000 then hy=76800;hE=5480 elseif hC>1300 then hy=9600;hE=988.67 end;hx=hD-hE;if fuelTankHandlingSpace>0 then hy=hy+hy*fuelTankHandlingSpace*0.2 end;hy=hw(hx,hy)aS[#aS+1]={ax[c7],hz(ax[c7]),hy,hE,hx,dN}end end end;if not bQ then VertTakeOff,VertTakeOffEngine=false,false end end;local function hF()ar=df()if gyro~=nil then az=gyro.getState()==1 end;if userControlScheme~="keyboard"then x(1)else x(0)end;if door and(au or not au and aw<10000)then for _,c8 in pairs(door)do c8.toggle()end end;if switch then for _,c8 in pairs(switch)do c8.toggle()end end;if forcefield and(au or not au==0 and aw<10000)then for _,c8 in pairs(forcefield)do c8.toggle()end end;if antigrav then bR=antigrav.getState()==1;if bR and not ExternalAGG then antigrav.show()end end;if n()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;local hG=d9()if hG~=-1 or not au and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;if not S then GearExtended=true end else BrakeIsOn=false end;if bj~=nil then t:setTargetGroundAltitude(bj)if bj==0 and not S then GearExtended=true;BrakeIsOn=true end else bj=a:getTargetGroundAltitude()if GearExtended then t:setTargetGroundAltitude(LandingGearGroundHeight)else t:setTargetGroundAltitude(TargetHoverHeight)end end;if au and hG~=-1 then bd=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=au end;local function hH(hI,hJ,hK,hL,bZ,b_,hM,hN,hO,hP)local hQ={enableName=hI,disableName=hJ,width=hK,height=hL,x=bZ,y=b_,toggleVar=hM,toggleFunction=hN,drawCondition=hO,hovered=false}if hP then table.insert(aK,hQ)else table.insert(aJ,hQ)end;return hQ end;local function hR()bW=not bW;if bW then aI=aK;a2="Hold SHIFT to see Settings"else aI=aJ;a2="Hold SHIFT to see Control Buttons"end end;local function hS()local hT=50;local hU=400;local bZ=200;local b_=aM/2-400;local hV=0;for c7,c8 in pairs(b)do if type(_G[c8])=="boolean"then hH(c8,c8,hU,hT,bZ,b_,function()return _G[c8]end,function()_G[c8]=not _G[c8]if _G[c8]then a2=c8 .." set to true"else a2=c8 .." set to false"end end,function()return true end,true)b_=b_+hT+20;if hV==7 then bZ=bZ+hU+20;b_=aM/2-400;hV=0 else hV=hV+1 end end end;hH("Control View","Control View",hU,hT,10,aM/2-500,function()return true end,hR,function()return true end,true)end;local function hW()local function hX()if dbHud_1 then local position=bP;local dG=planet.name..". "..#SavedLocations;if radar_1 then local gR,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if gR~=nil and gR~=""then dG=dG.." "..radar_1.getConstructName(gR)end end;local cN={}cN={position=position,name=dG,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cN;table.insert(b5[0],cN)c6()a2="Location saved as "..dG else a2="Databank must be installed to save locations"end end;local function hY()TurnBurn=not TurnBurn end;local function hZ(h_)if h_==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function i0()hZ(1)end;local function i1()local cM=-1;cM=ck(b5[0])if cM>-1 then table.remove(b5[0],cM)end;cM=-1;cM=ck(SavedLocations)if cM~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cM)end;ct()c6()end;local function i2()local dG=AutopilotTargetName;if dG==nil then local fd,cj=cf((bP-CustomTarget.position):len())dG=CustomTarget.name.." "..fd..cj end;if dG==nil then dG="None"end;return"Engage Autopilot: "..dG end;local function i3()local dG=AutopilotTargetName;if dG==nil then dG=CustomTarget.name end;if dG==nil then dG="None"end;return"Disable Autopilot: "..dG end;local hT=50;local hU=260;local i4=hH("Enable Brake Toggle","Disable Brake Toggle",hU,hT,aL/2-hU/2,aM/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)hH("Align Prograde","Disable Prograde",hU,hT,aL/2-hU/2-50-i4.width,aM/2-hT+380,function()return ProgradeIsOn end,i0)hH("Align Retrograde","Disable Retrograde",hU,hT,aL/2-hU/2+i4.width+50,aM/2-hT+380,function()return RetrogradeIsOn end,hZ,function()return av==0 end)local i5=hH(i2,i3,600,60,aL/2-600/2,aM/2-60/2-400,function()return Autopilot end,cH)hH("Save Position","Save Position",200,i5.height,i5.x+i5.width+30,i5.y,function()return false end,hX,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)hH("Update Position","Update Position",200,i5.height,i5.x+i5.width+30,i5.y,function()return false end,cK,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)hH("Clear Position","Clear Position",200,i5.height,i5.x-200-30,i5.y,function()return true end,i1,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)hT=60;hU=300;local bZ=10;local b_=aM/2-500;hH("Show Help","Hide Help",hU,hT,bZ,b_,function()return showHelp end,function()showHelp=not showHelp end)b_=b_+hT+20;hH("View Settings","View Settings",hU,hT,bZ,b_,function()return true end,hR)local b_=aM/2-300;hH("Enable Turn and Burn","Disable Turn and Burn",hU,hT,bZ,b_,function()return TurnBurn end,hY)hH("Horizontal Takeoff Mode","Vertical Takeoff Mode",hU,hT,bZ+hU+20,b_,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bQ end)b_=b_+hT+20;hH("Show Orbit Display","Hide Orbit Display",hU,hT,bZ,b_,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a2="Orbit Display Enabled"else a2="Orbit Display Disabled"end end)hH("Engage Orbiting","Cancel Orbiting",hU,hT,bZ+hU+20,b_,function()return IntoOrbit end,cn,function()return av==0 and unit.getClosestPlanetInfluence()>0 end)b_=b_+hT+20;hH("Glide Re-Entry","Cancel Glide Re-Entry",hU,hT,bZ,b_,function()return Reentry end,function()ao=true;i0()end,function()return planet.hasAtmosphere and not au end)hH("Parachute Re-Entry","Cancel Parachute Re-Entry",hU,hT,bZ+hU+20,b_,function()return Reentry end,d1,function()return planet.hasAtmosphere and not au end)b_=b_+hT+20;hH("Engage Follow Mode","Disable Follow Mode",hU,hT,bZ,b_,function()return a0 end,cp,function()return n()==1 end)hH("Enable Repair Arrows","Disable Repair Arrows",hU,hT,bZ+hU+20,b_,function()return aV end,function()aV=not aV;if aV then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return n()==1 end)b_=b_+hT+20;if not ExternalAGG then hH("Enable AGG","Disable AGG",hU,hT,bZ,b_,function()return bR end,d3,function()return antigrav~=nil end)end;b_=b_+hT+20;hH(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,hU*2,hT,bZ,b_,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end end)end;local function i6()local i7=nil;local i8=nil;local i9=nil;local ia=nil;b5=gc()for c7,c8 in pairs(b5[0])do if i7==nil or c8.center.x<i7 then i7=c8.center.x end;if i8==nil or c8.center.x>i8 then i8=c8.center.x end;if i9==nil or c8.center.y<i9 then i9=c8.center.y end;if ia==nil or c8.center.y>ia then ia=c8.center.y end end;b6=""local ib=1.1*(i8-i7)/1920;local ic=1.4*(ia-i9)/1080;for c7,c8 in pairs(b5[0])do local bZ=960+c8.center.x/ib;local b_=540+c8.center.y/ic;b6=b6 ..'<circle cx="'..bZ..'" cy="'..b_..'" r="'..c8.radius/ib*30 ..'" stroke="white" stroke-width="3" fill="blue" />'if not p(c8.name,"Moon")and not p(c8.name,"Sanctuary")and not p(c8.name,"Space")then b6=b6 .."<text x='"..bZ.."' y='"..b_+c8.radius/ib*30+20 .."' font-size='28' fill="..aB.." text-anchor='middle' font-family='Montserrat'>"..c8.name.."</text>"end end;local fU=bP;local bZ=960+fU.x/ib;local b_=540+fU.y/ic;b6=b6 ..'<circle cx="'..bZ..'" cy="'..b_..'" r="5" stroke="white" stroke-width="3" fill="red"/>'b6=b6 .."<text x='"..bZ.."' y='"..b_-50 .."' font-size='36' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"b6=b6 ..[[</svg>]]b7=ib;b8=ic;if screen_2 then screen_2.setHTML('<svg width="100%" height="100%" viewBox="0 0 1920 1080">'..b6)local fU=bP;local bZ=960+fU.x/ib;local b_=540+fU.y/ic;b6='<svg><circle cx="80" cy="80" r="5" stroke="white" stroke-width="3" fill="red"/>'b6=b6 .."<text x='80' y='105' font-size='18' fill="..aB.." text-anchor='middle' font-family='Montserrat''>You Are Here</text></svg>"b9=screen_2.addContent((bZ-80)/19.20,(b_-80)/10.80,b6)end end;local function id()for c7,c8 in pairs(SavedLocations)do table.insert(b5[0],c8)end;c6()end;local function ie()local bc={}local ig=30000000/3600;local ih=ig*ig;local ii=100;local function ij(c8)return 1/math.sqrt(1-c8*c8/ih)end;function bc.computeAccelerationTime(ik,il,im)local io=ig*math.asin(ik/ig)return(ig*math.asin(im/ig)-io)/il end;function bc.computeDistanceAndTime(ik,im,ip,iq,ir,is)ir=ir or 0;is=is or 0;local it=ik<=im;local iu=iq*(it and 1 or-1)/ip;local iv=-is/ip;local iw=iu+iv;if it and iw<=0 or not it and iw>=0 then return-1,-1 end;local ix,iy=0,0;if iu~=0 and ir>0 then local io=math.asin(ik/ig)local iz=math.pi*(iu/2+iv)local iA=iu*ir;local iB=ig*math.pi;local c8=function(gi)local iC=(iz*gi-iA*math.sin(math.pi*gi/2/ir)+iB*io)/iB;local iD=math.tan(iC)return ig*iD/math.sqrt(iD*iD+1)end;local iE=it and function(gk)return gk>=im end or function(gk)return gk<=im end;iy=2*ir;if iE(c8(iy))then local iF=0;while d(iy-iF)>0.5 do local gi=(iy+iF)/2;if iE(c8(gi))then iy=gi else iF=gi end end end;local iG=ik;local iH=iy/ii;for iI=1,ii do local ed=c8(iI*iH)ix=ix+(ed+iG)*iH/2;iG=ed end;if iy<2*ir then return ix,iy end;ik=iG end;local io=ig*math.asin(ik/ig)local bH=(ig*math.asin(im/ig)-io)/iw;local iJ=ih*math.cos(io/ig)/iw;local ak=iJ-ih*math.cos((iw*bH+io)/ig)/iw;return ak+ix,bH+iy end;function bc.computeTravelTime(ik,il,ak)if ak==0 then return 0 end;if il>0 then local io=ig*math.asin(ik/ig)local iJ=ih*math.cos(io/ig)/il;return(ig*math.acos(il*(iJ-ak)/ih)-io)/il end;if ik==0 then return-1 end;assert(ik>0,'Acceleration and initial speed are both zero.')return ak/ik end;function bc.lorentz(c8)return ij(c8)end;return bc end;local function iK()local vec3=require('cpml.vec3')local gd=gd()local function gj(gk)return type(gk)=='string'end;local function gh(gi)return type(gi)=='table'end;local function cc(cd,ce)if cd==0 then return d(ce)<1e-09 end;if ce==0 then return d(cd)<1e-09 end;return d(cd-ce)<math.max(d(cd),d(ce))*constants.epsilon end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cC)assert(self.body)local ak=cC+self.body.radius;if not cc(ak,0)then local orbit=math.sqrt(self.body.GM/ak)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(gJ,eE)assert(self.body)assert(gh(gJ)or gj(gJ))assert(gh(eE))local fU=(gj(gJ)or gd.isMapPosition(gJ))and self.body:convertToWorldCoordinates(gJ)or vec3(gJ)local c8=vec3(eE)local iL=fU-self.body.center;local hd=c8:len2()local iM=iL:len()local iN=self.body.GM;local iO=((hd-iN/iM)*iL-iL:dot(c8)*c8)/iN;local cd=iN/(2*iN/iM-hd)local iP=iO:len()local he=iO:normalize()local iQ=cd*(1-iP)local iR=cd*(1+iP)local iS=iQ*he+self.body.center;local iT=iP<=1 and-iR*he+self.body.center or nil;local iU=math.sqrt(cd*iN*(1-iP*iP))local iV=iT and 2*math.pi*math.sqrt(cd^3/iN)local iW=math.acos(iO:dot(iL)/(iP*iM))if iL:dot(c8)<0 then iW=-(iW-2*math.pi)end;local iX=math.acos((math.cos(iW)+iP)/(1+iP*math.cos(iW)))local iY=iX;if iY<0 then iY=iY+2*math.pi end;local iZ=iY-iP*math.sin(iY)local i_=0;local j0=0;local j1=0;if iV~=nil then i_=iZ/(2*math.pi/iV)j0=iV-i_;j1=j0+iV/2;if iW-math.pi>0 then j0=i_;j1=j0+iV/2 end;if j1>iV then j1=j1-iV end end;return{periapsis={position=iS,speed=iU/iQ,circularOrbitSpeed=math.sqrt(iN/iQ),altitude=iQ-self.body.radius},apoapsis=iT and{position=iT,speed=iU/iR,circularOrbitSpeed=math.sqrt(iN/iR),altitude=iR-self.body.radius},currentVelocity=c8,currentPosition=fU,eccentricity=iP,period=iV,eccentricAnomaly=iX,meanAnomaly=iZ,timeToPeriapsis=j0,timeToApoapsis=j1}end;local function j2(j3)local hl=gd.BodyParameters(j3.planetarySystemId,j3.bodyId,j3.radius,j3.center,j3.GM)return setmetatable({body=hl},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return j2(...)end})end;SetupComplete=false;beginSetup=coroutine.create(function()t:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})hr()coroutine.yield()hv()coroutine.yield()hF()hS()hW()aI=aJ;coroutine.yield()i6()ba=gd()bb=ba(gc())bc=ie()be=iK()bf=di()id()c6()cq()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)if UseSatNav then unit.setTimer("fiveSecond",5)end end)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(av>0 or av==0 and aw<10000)then for _,c8 in pairs(door)do c8.toggle()end end;if switch then for _,c8 in pairs(switch)do c8.toggle()end end;if forcefield and(av>0 or av==0 and aw<10000)then for _,c8 in pairs(forcefield)do c8.toggle()end end;db()if button then button.activate()end;if SetWaypointOnExit then cv(planet,bP)end end;function script.onTick(j4)local function j5(ed)if not au then return bc.computeDistanceAndTime(ed,AutopilotEndSpeed,m(),0,0,LastMaxBrake-AutopilotPlanetGravity*m())else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return bc.computeDistanceAndTime(ed,AutopilotEndSpeed,m(),0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*m())else return 0,0 end end end;local function j6(ed)return bc.computeDistanceAndTime(ed,AutopilotEndSpeed,m(),a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*m())end;if j4=="tenthSecond"then local function j7()local j8=system.createData;local j9=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=j9(panelInterplanetary,"value")interplanetaryHeaderText=j8('{"label": "Target Planet", "value": "N/A", "unit":""}')w(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=j9(panelInterplanetary,"value")widgetDistanceText=j8('{"label": "distance", "value": "N/A", "unit":""}')w(widgetDistanceText,widgetDistance)widgetTravelTime=j9(panelInterplanetary,"value")widgetTravelTimeText=j8('{"label": "Travel Time", "value": "N/A", "unit":""}')w(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=j9(panelInterplanetary,"value")widgetMaxMassText=j8('{"label": "Maximum Mass", "value": "N/A", "unit":""}')w(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=j9(panelInterplanetary,"value")widgetTargetOrbitText=j8('{"label": "Target Altitude", "value": "N/A", "unit":""}')w(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=j9(panelInterplanetary,"value")widgetCurBrakeDistanceText=j8('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=j9(panelInterplanetary,"value")widgetCurBrakeTimeText=j8('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=j9(panelInterplanetary,"value")widgetMaxBrakeDistanceText=j8('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=j9(panelInterplanetary,"value")widgetMaxBrakeTimeText=j8('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=j9(panelInterplanetary,"value")widgetTrajectoryAltitudeText=j8('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not au then w(widgetCurBrakeDistanceText,widgetCurBrakeDistance)w(widgetCurBrakeTimeText,widgetCurBrakeTime)w(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)w(widgetMaxBrakeTimeText,widgetMaxBrakeTime)w(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function ja()u(panelInterplanetary)panelInterplanetary=nil end;local function jb()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bP):len()else AutopilotDistance=(CustomTarget.position-bP):len()end end;local ed=bM;local jc=unit.getThrottle()/100;if AtmoSpeedAssist then jc=I end;local jd,je=bc.computeDistanceAndTime(bM,MaxGameVelocity,m(),a:maxForceForward()*jc,warmup,0)local a8,a9;if not TurnBurn then a8,a9=j5(MaxGameVelocity)else a8,a9=j6(MaxGameVelocity)end;local _,jf;if not TurnBurn and ed>0 then _,jf=j5(ed)else _,jf=j6(ed)end;local jg=0;local jh=0;if AutopilotCruising or not Autopilot and ed>5 then jh=bc.computeTravelTime(ed,0,AutopilotDistance)elseif a8+jd<AutopilotDistance then jg=AutopilotDistance-(a8+jd)jh=bc.computeTravelTime(8333.0556,0,jg)else local ji=(AutopilotDistance-a8)/jd;jd=AutopilotDistance-a8;je=je*ji end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return jh elseif AutopilotBraking then return jf elseif AutopilotCruising then return jh+jf else return je+a9+jh end end;local function jj()local jk=LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()return jk end;if av>0 and not WasInAtmo then if not bT and AtmoSpeedAssist and(AltitudeHold or Reentry)then c2(1)M=false end end;if bS~=nil then if t:getTargetSpeed(axisCommandId.longitudinal)~=bS then c5(bS,TRUE)else bS=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then j7()end;if AutopilotTargetName~=nil then local jl=CustomTarget~=nil;planetMaxMass=jj()v(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=jb()if jl and not Autopilot then ak=(bP-CustomTarget.position):len()else ak=(AutopilotTargetCoords-bP):len()end;if not TurnBurn then a8,a9=j5(bM)aa,ab=j5(MaxGameVelocity)else a8,a9=j6(bM)aa,ab=j6(MaxGameVelocity)end;local fd,cj=cf(ak)v(widgetDistanceText,'{"label": "distance", "value": "'..fd..'", "unit":"'..cj..'"}')v(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d4(travelTime)..'", "unit":""}')fd,cj=cf(a8)v(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..fd..'", "unit":"'..cj..'"}')v(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d4(a9)..'", "unit":""}')fd,cj=cf(aa)v(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..fd..'", "unit":"'..cj..'"}')v(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d4(ab)..'", "unit":""}')v(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..f("%.2f",planetMaxMass/1000)..'", "unit":" Tons"}')fd,cj=cf(AutopilotTargetOrbit)v(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..f("%.2f",fd)..'", "unit":"'..cj..'"}')if av>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if av==0 and WasInAtmo then if v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then w(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then w(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if v(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then w(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then w(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then w(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else ja()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif j4=="oneSecond"then local function jm(fZ,jn)if fZ==nil then fZ=core.g()end;fZ=z(fZ,5)if jn~=nil and jn or(aQ==nil or aQ~=fZ)then local eE=core.getVelocity()local ed=vec3(eE):len()local jo=g(unit.getData()).maxBrake;if jo~=nil and jo>0 and au then jo=jo/s(ed/100,0.1,1)jo=jo/av;if av>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+jo)/2 else LastMaxBrakeInAtmo=jo end end end;if jo~=nil and jo>0 then LastMaxBrake=jo end;aQ=fZ end end;local function jp(dq)local jq=0;aG=""local jr=aU;local js=0;local jt=0;local ju=0;local dP=0;local dQ=""local jv=core.getElementHitPointsById;for c7 in pairs(ax)do local hC=0;local jw=0;jw=j(ax[c7])hC=jv(ax[c7])js=js+hC;if hC<jw then if hC==0 then ju=ju+1 else jt=jt+1 end;if aV and#aD==0 then position=vec3(core.getElementPositionById(ax[c7]))local bZ=position.x-b3;local b_=position.y-b3;local jx=position.z-b3;table.insert(aD,core.spawnArrowSticker(bZ,b_,jx+1,"down"))table.insert(aD,core.spawnArrowSticker(bZ,b_,jx+1,"down"))core.rotateSticker(aD[2],0,0,90)table.insert(aD,core.spawnArrowSticker(bZ+1,b_,jx,"north"))table.insert(aD,core.spawnArrowSticker(bZ+1,b_,jx,"north"))core.rotateSticker(aD[4],90,90,0)table.insert(aD,core.spawnArrowSticker(bZ-1,b_,jx,"south"))table.insert(aD,core.spawnArrowSticker(bZ-1,b_,jx,"south"))core.rotateSticker(aD[6],90,-90,0)table.insert(aD,core.spawnArrowSticker(bZ,b_-1,jx,"east"))table.insert(aD,core.spawnArrowSticker(bZ,b_-1,jx,"east"))core.rotateSticker(aD[8],90,0,90)table.insert(aD,core.spawnArrowSticker(bZ,b_+1,jx,"west"))table.insert(aD,core.spawnArrowSticker(bZ,b_+1,jx,"west"))core.rotateSticker(aD[10],-90,0,90)table.insert(aD,ax[c7])end elseif aV and#aD>0 and aD[11]==ax[c7]then for dI in pairs(aD)do core.deleteSticker(aD[dI])end;aD={}end end;jq=e(js/jr*100)if jq<100 then dq[#dq+1]=[[<g class="pbright txt">]]dP=e(jq*2.55)dQ=f("rgb(%d,%d,%d)",255-dP,dP,0)if jq<100 then dq[#dq+1]=bX("txtbig txtmid","50%",1035,"fill:"..dQ,f("Elemental Integrity: %i %%",jq))if ju>0 then dq[#dq+1]=bX("txtbig txtmid","50%",1055,"fill:"..dQ,f("Disabled Modules: %i Damaged Modules: %i",ju,jt))elseif jt>0 then dq[#dq+1]=bX("txtbig txtmid","50%",1055,"fill:"..dQ,f("Damaged Modules: %i",jt))end end;dq[#dq+1]=[[<\g>]]end end;local function jy()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then u(WeaponPanelID)WeaponPanelID=nil end end end;local function jz()local dN=r()local f1=bM;local jA=dN-ay;if f1>1.38889 then f1=f1/1000;local jB=f1*(dN-ay)TotalDistanceTravelled=TotalDistanceTravelled+jB;ad=ad+jB end;ae=ae+jA;TotalFlightTime=TotalFlightTime+jA;ay=dN end;as=false;jm(nil,true)jz()bf.UpdateRadar()jy()local dq={}if ShowOdometer then dq=bf.DrawOdometer(dq,ad,TotalDistanceTravelled,ae)end;if ShouldCheckDamage then jp(dq)end;am=table.concat(dq,"")collectgarbage("collect")elseif j4=="fiveSecond"then at=dbHud_1.getStringValue("SPBAutopilotTargetName")if at~=nil and at~=""and at~="SatNavNotChanged"then local ci=g(dbHud_1.getStringValue("SavedLocations"))if ci~=nil then _G["SavedLocations"]=ci;local cM=-1;local cN;for c7,c8 in pairs(SavedLocations)do if c8.name and c8.name=="SatNav Location"then cM=c7;break end end;if cM~=-1 then cN=SavedLocations[cM]cM=-1;for c7,c8 in pairs(b5[0])do if c8.name and c8.name=="SatNav Location"then cM=c7;break end end;if cM>-1 then b5[0][cM]=cN end;c6()a2=cN.name.." position updated"end end;for i=1,#AtlasOrdered do if AtlasOrdered[i].name==at then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..AtlasOrdered[i].name)cq()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif j4=="msgTick"then local dq={}bf.DisplayMessage(dq,"empty")a2="empty"unit.stopTimer("msgTick")aj=3 elseif j4=="animateTick"then bh=true;bg=false;ah=0;ai=0;unit.stopTimer("animateTick")elseif j4=="hudTick"then local function jC(dq)local jD=e(s(ak/(aL/4)*255,0,255))dq[#dq+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ah,ai,e(D+0.5)+jD,e(F+0.5)-jD,e(E+0.5)-jD)end;local function jE()for _,c8 in pairs(aI)do if c8.hovered then if not c8.drawCondition or c8.drawCondition()then c8.toggleFunction()end;c8.hovered=false end end end;local function jF()local function jG(jH,jI,bZ,b_,hK,hL)if jH>bZ and jH<bZ+hK and jI>b_ and jI<b_+hL then return true else return false end end;local bZ=ah+aL/2;local b_=ai+aM/2;for _,c8 in pairs(aI)do c8.hovered=jG(bZ,b_,c8.x,c8.y,c8.width,c8.height)end end;local function jJ(dq)local function jK(dq,jL,hover,bZ,b_,iC,jM,jN,jO,jP,jQ)if type(jP)=="function"then jP=jP()end;if type(jQ)=="function"then jQ=jQ()end;dq[#dq+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bZ,b_,iC,jM)if jL then dq[#dq+1]=f("%s'",jN)else dq[#dq+1]=jO end;if hover then dq[#dq+1]=" style='stroke:white; stroke-width:2'"else dq[#dq+1]=" style='stroke:black; stroke-width:1'"end;dq[#dq+1]="></rect>"dq[#dq+1]=f("<text x='%f' y='%f' font-size='24' fill='",bZ+iC/2,b_+jM/2+5)if jL then dq[#dq+1]="black"else dq[#dq+1]="white"end;dq[#dq+1]="' text-anchor='middle' font-family='Montserrat'>"if jL then dq[#dq+1]=f("%s</text>",jP)else dq[#dq+1]=f("%s</text>",jQ)end end;local jR="rgb(50,50,50)'"local jS="rgb(210,200,200)"local jT=jK;for _,c8 in pairs(aI)do local hJ=c8.disableName;local hI=c8.enableName;if type(hJ)=="function"then hJ=hJ()end;if type(hI)=="function"then hI=hI()end;if not c8.drawCondition or c8.drawCondition()then jT(dq,c8.toggleVar(),c8.hovered,c8.x,c8.y,c8.width,c8.height,jS,jR,hJ,hI)end end end;local dq={}bf.HUDPrologue(dq)if showHud then bf.UpdateHud(dq)else bf.DisplayOrbitScreen(dq)bf.DrawWarnings(dq)end;bf.HUDEpilogue(dq)dq[#dq+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aL,aM)if a2~="empty"then bf.DisplayMessage(dq,a2)end;if n()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then bf.DrawDeadZone(dq)end end;if n()==1 and screen_1 and screen_1.getMouseY()~=-1 then jF()jJ(dq)if screen_1.getMouseState()==1 then jE()end;dq[#dq+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],N,O,ah,ai)elseif y()==0 then if n()==1 and a1 then jF()jJ(dq)if not bg and not bh then local jU=table.concat(dq,"")dq={}dq[#dq+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aL,aM)dq[#dq+1]=b6;dq[#dq+1]=jU;dq[#dq+1]="</body>"bg=true;dq[#dq+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(dq,"")system.setScreen(content)elseif bh then local jU=table.concat(dq,"")dq={}dq[#dq+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aL,aM)dq[#dq+1]=b6;dq[#dq+1]=jU;dq[#dq+1]="</body>"end;if not bg then dq[#dq+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],N,O,ah,ai)end else jE()end else if not a1 and n()==0 then jE()if ak>DeadZone then if DisplayDeadZone then jC(dq)end end else jF()jJ(dq)end;dq[#dq+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],N,O,ah,ai)end;dq[#dq+1]=[[</svg></body>]]content=table.concat(dq,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif j4=="apTick"then local function jV(jW)local gF=500000;local jX,jY,jZ=math.huge;local j_=false;local k0=vec3({13771471,7435803,-128971})local k1=18000000;jX=vec3(jW):dist(k0)if jX<k1 then return true,d(jX-k1),"Safe Zone",0 end;jY=vec3(jW):dist(vec3(planet.center))if jY<gF then j_=true end;if d(jY-gF)<d(jX-k1)then return j_,d(jY-gF),planet.name,planet.bodyId else return j_,d(jX-k1),"Safe Zone",0 end end;local function k2(k3,k4,k5)k4=k4:project_on_plane(k3)k5=k5:project_on_plane(k3)return o(k4:cross(k5):dot(k3),k4:dot(k5))end;au=k()>0;av=k()aw=core.getAltitude()ar=df()bH=r()bn=bH;if antigrav then bR=antigrav.getState()==1 end;local k6=1;local k7=1;local k8=bH-bn;local k9=-math.deg(k2(bI,bL,bJ))local ka=math.deg(k2(bK,bL,bJ))local cu=bN*-1;bm=au and k9<-YawStallAngle or k9>YawStallAngle or ka<-PitchStallAngle or ka>PitchStallAngle;bk=system.getMouseDeltaX()bl=system.getMouseDeltaY()if InvertMouse and not a1 then bl=-bl end;V=0;Z=0;U=0;sys=bb[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=be(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bL)if aw==0 then aw=(bP-planet.center):len()-planet.radius end;local fZ=planet:getGravity(core.getConstructWorldPos()):len()*m()bo=0;bd=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if not au then G,H,_,_=jV(bP)else G=true end;ah=ah+bk;ai=ai+bl;if n()==1 and screen_1 and screen_1.getMouseY()~=-1 then ah=screen_1.getMouseX()*aL;ai=screen_1.getMouseY()*aM elseif y()==0 then if not n()==1 and not a1 then ah=0;ai=0 end else ak=math.sqrt(ah*ah+ai*ai)if not a1 and n()==0 then if userControlScheme=="virtual joystick"then if ah>0 and ah>DeadZone then V=V-(ah-DeadZone)*MouseXSensitivity elseif ah<0 and ah<DeadZone*-1 then V=V-(ah+DeadZone)*MouseXSensitivity else V=0 end;if ai>0 and ai>DeadZone then U=U-(ai-DeadZone)*MouseYSensitivity elseif ai<0 and ai<DeadZone*-1 then U=U-(ai+DeadZone)*MouseYSensitivity else U=0 end else ah=0;ai=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(bl,-100,100)+0.5)*2*k6;V=(-utils.smoothstep(bk,-100,100)+0.5)*2*k7 end end end end;local kb=bM>8334;if bM>SpaceSpeedLimit/3.6 and not au and not Autopilot and not kb then a2="Space Speed Engine Shutoff reached"c2(0)end;if not kb and LastIsWarping then if not BrakeIsOn then cP()end;if Autopilot then cH()end end;LastIsWarping=kb;if au and av>0.09 then if bM>br/3.6 and not AtmoSpeedAssist and not aA then BrakeIsOn=true;aA=true elseif not AtmoSpeedAssist and aA then if bM<br/3.6 then BrakeIsOn=false;aA=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if ao then BrakeIsOn=false;local kc=false;if CustomTarget~=nil then kc=cQ(CustomTarget.position-bP,0.01)else kc=cQ(vec3(bL),0.01)end;bi=true;if kc and(d(bV)<2 or d(bU)>85)and bM>=br/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;ao=false;aq=true;Autopilot=false;d1()elseif au and AtmoSpeedAssist then c2(1)else c5(e(br))end elseif bM>Q then cQ(vec3(bL),0.01)end end;if RetrogradeIsOn then if au then RetrogradeIsOn=false elseif bM>Q then cQ(-vec3(bL))end end;if not ProgradeIsOn and ao and not IntoOrbit then if av==0 then R=true;d1()ao=false;aq=true else ao=false;cH()end end;if aq and CustomTarget~=nil and(aw<HoldAltitude+200 and aw>HoldAltitude-200)and bM*3.6>br-100 and d(bO)<20 and av>=0.1 and(CustomTarget.position-bP):len()>2000+aw then cH()aq=false end;if VertTakeOff then bi=true;local kd=HoldAltitude;if bO<-30 then a2="Unable to achieve lift. Safety Landing."ag=0;bi=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bR or HoldAltitude<planet.spaceEngineMinAltitude then if bR then kd=antigrav.getBaseAltitude()end;if aw<kd-100 then bs=0;ag=15;BrakeIsOn=false elseif bO>0 then BrakeIsOn=true;ag=0 elseif bO<-30 then BrakeIsOn=true;ag=15 elseif aw>=kd then if bR then if Autopilot or VectorToTarget then cm()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"cm()end;ag=0 end else if av>0.08 then bs=0;BrakeIsOn=false;ag=20 elseif av<0.08 and av>0 then BrakeIsOn=false;if bE then bs=0;ag=20 else ag=0;bs=36;c5(3500)end else bi=autoRollPreference;IntoOrbit=true;bC=false;CancelIntoOrbit=false;bw=false;bu=nil;bv=nil;if bB==nil then bB=planet end;bA=kd;bz=true;VertTakeOff=false end end;if bs~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ke=s(bs-bU,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ke)local kf=s(vTpitchPID:get(),-1,1)U=kf end end;if IntoOrbit then local cZ;local kg=false;local kh,ki=cf(bA)local kj=kh..ki;if bB==nil then bB=planet;if VectorToTarget then bB=ac end end;if not bz then bA=math.floor(bB.radius+bB.surfaceMaxAltitude+1000)if bB.hasAtmosphere then bA=math.floor(bB.radius+bB.noAtmosphericDensityAltitude+1000)end;bz=true end;if by.VectorToTarget then cZ=CustomTarget.position-bP end;local kk,kl=be(bB):escapeAndOrbitalSpeed((bP-bB.center):len()-bB.radius)local km=bV;if not bw then local kn=false;local ko=false;c2(0)bv=0;bt="Aligning to orbital path - OrbitHeight: "..kj;if by.VectorToTarget then cQ(cZ:normalize():project_on_plane(bN))kg=bJ:dot(cZ:project_on_plane(bI):normalize())>0.95 else cQ(bL)kg=k9<0.5;if bM<150 then kg=true end end;U=0;bu=0;if bU<=bu+1 and bU>=bu-1 then kn=true else kn=false end;if km<=bv+1 and km>=bv-1 then ko=true else ko=false end;if kn and ko and kg then bu=nil;bv=nil;bw=true end else if by.VectorToTarget then cQ(cZ:normalize():project_on_plane(bN))elseif bM>150 then cQ(bL)end;U=0;if by.VectorToTarget then local a8,_=bc.computeDistanceAndTime(bM,br/3.6,m(),0,0,LastMaxBrake)if bC and cZ:len()>15000+a8+aw then bt="Orbiting to Target"if orbit.periapsis.altitude<bB.noAtmosphericDensityAltitude then bC=false end elseif bC or cZ:len()<15000+a8+aw then a2="Orbit complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;R=true;aq=true;by.VectorToTarget,by.AutopilotAlign=false,false;cn()d1()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and aw>bA*0.9 and aw<bA*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bA*0.99 and orbit.apoapsis.altitude>=bA*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bC then if bC then BrakeIsOn=false;c2(0)bu=0;if not by.VectorToTarget then a2="Orbit complete"cn()end else bG=bG+1;if bG>=2 then bC=true end end else bt="Adjusting Orbit - OrbitHeight: "..kj;bx=true;c5(kl*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kp=bO;local kq=aw-bA;local kr=d(kq)if bO<10 and d(bU)<10 and kr<100 then kp=bO*2 end;if kp<10 and d(bU)<10 and kr<100 then kp=kp*2 end;if kp<5 and d(bU)<5 and kr<100 then kp=kp*4 end;VSpdPID:inject(kp)bu=s(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kq)bu=s(bu-s(OrbitAltPID:get(),-15,15),-90,90)end end else local ks=2.75;local kt=d(q(kk*ks))local ku=kt%50;if ku>0 then kt=kt-ku+50 end;BrakeIsOn=false;if aw<bA*0.8 then bt="Escaping planet gravity - OrbitHeight: "..kj;bu=utils.map(bO,200,0,-15,80)elseif aw>=bA*0.8 and aw<bA*1.15 then bt="Approaching orbital corridor - OrbitHeight: "..kj;kt=kt*0.75;bu=utils.map(bO,100,-100,-15,65)elseif aw>=bA*1.15 and aw<bA*1.5 then bt="Approaching orbital corridor - OrbitHeight: "..kj;kt=kt*0.75;if bO<0 or bx then bu=utils.map(aw,bA*1.5,bA*1.01,-30,0)else bu=utils.map(aw,bA*0.99,bA*1.5,0,30)end elseif aw>bA*1.5 then bt="Reentering orbital corridor - OrbitHeight: "..kj;bu=-85;local kv=utils.map(bO,-150,-400,1,0.55)kt=kt*kv end;c5(e(kt))end end;if bu~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kw=bu-bU;OrbitPitchPID:inject(kw)local kx=s(OrbitPitchPID:get(),-0.5,0.5)U=kx end end;if Autopilot and av==0 and not ao then local ky,kz=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kA=(CustomTarget.position-ac.center):normalize()local kB=kA:project_on_plane((ac.center-bP):normalize()):normalize()local kC=ac.center+kB*(ac.radius+AutopilotTargetOrbit)local kD=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bP-kC):len()<(bP-kD):len()then ky=kC;AutopilotTargetCoords=ky else ky=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))AutopilotTargetCoords=ky end;cv(ac,AutopilotTargetCoords)kz=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kz=true;TargetSet=true;AutopilotRealigned=true;ky=CustomTarget.position+(bP-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kA=(bP+bL*100000-ac.center):normalize()local kB=kA:project_on_plane((ac.center-bP):normalize()):normalize()if kB:len()<1 then kA=(bP+bJ*100000-ac.center):normalize()kB=kA:project_on_plane((ac.center-bP):normalize()):normalize()end;ky=ac.center+kB*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=ky;TargetSet=true;kz=true;AutopilotRealigned=true;cv(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(ky)-bP):len()local fe,ff,fg=bb:getPlanetarySystem(0):castIntersections(bP,bL:normalize(),function(fh)if fh.noAtmosphericDensityAltitude>0 then return fh.radius+fh.noAtmosphericDensityAltitude else return fh.radius+fh.surfaceMaxAltitude*1.5 end end)local fi=ff;if fg~=nil and ff~=nil then fi=math.min(fg,ff)end;if fi~=nil and fi<AutopilotDistance and fe.name==ac.name then AutopilotDistance=fi end;local kc=true;local kE=(ac.center-(bP+vec3(bL):normalize()*AutopilotDistance)):len()-ac.radius;local fd,cj=cf(kE)v(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..fd..'", "unit":"'..cj..'"}')local a8,a9;if not TurnBurn then a8,a9=j5(bM)else a8,a9=j6(bM)end;if bM>300 and AutopilotAccelerating then local cZ=vec3(ky)-bP;local kF=s(math.deg(k2(bI,bL:normalize(),cZ:normalize()))*bM/500,-90,90)local kG=s(math.deg(k2(bK,bL:normalize(),cZ:normalize()))*bM/500,-90,90)if d(kF)<20 and d(kG)<20 then kF=kF*2;kG=kG*2 end;if d(kF)<2 and d(kG)<2 then kF=kF*2;kG=kG*2 end;local k9=-math.deg(k2(bI,bJ,bL:normalize()))local ka=-math.deg(k2(bK,bJ,bL:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kG-ka)local kH=s(apPitchPID:get(),-1,1)U=U+kH;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kF-k9)local kI=s(apYawPID:get(),-1,1)V=V+kI;kz=true;if d(kF)>2 or d(kG)>2 then AutopilotStatus="Adjusting Trajectory"else AutopilotStatus="Accelerating"end end;if kE<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=be(ac):escapeAndOrbitalSpeed(kE)end end;if not AutopilotCruising and not AutopilotBraking and not kz then kc=cQ((ky-bP):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kc=cQ(-vec3(bL):normalize())end;if AutopilotAccelerating then if not P then BrakeIsOn=false;c2(AutopilotInterplanetaryThrottle)I=z(AutopilotInterplanetaryThrottle,2)P=true end;local jc=unit.getThrottle()if AtmoSpeedAssist then jc=I end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or jc==0 and P then AutopilotAccelerating=false;AutopilotStatus="Cruising"AutopilotCruising=true;c2(0)end;if AutopilotDistance<=a8 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true;c2(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then c2(1,true)end;local _,kl=be(ac):escapeAndOrbitalSpeed((bP-planet.center):len()-planet.radius)local cZ;if CustomTarget~=nil then cZ=CustomTarget.position-bP end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bM<50 then a2="Autopilot complete, arrived at space location"AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bM<=kl and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then a2="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"c2(0)P=false;ProgradeIsOn=true;ao=true;cv(ac,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 then AutopilotStatus="Circularizing"local _,kl=be(ac):escapeAndOrbitalSpeed((bP-planet.center):len()-planet.radius)if bM<=kl then if CustomTarget~=nil then if bL:normalize():dot(cZ:normalize())>0.4 then AutopilotStatus="Orbiting to Target"if not WaypointSet then BrakeIsOn=false;cv(ac,CustomTarget.position)WaypointSet=true end else a2="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"c2(0)P=false;ProgradeIsOn=true;ao=true;BrakeIsOn=false;cv(ac,CustomTarget.position)WaypointSet=false end else BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"a2="Autopilot completed, orbit established"Y=0;c2(0)P=false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then ProgradeIsOn=true;ao=true end end end end elseif AutopilotCruising then if AutopilotDistance<=a8 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true end;local jc=unit.getThrottle()if AtmoSpeedAssist then jc=I end;if jc>0 then AutopilotAccelerating=true;AutopilotStatus="Accelerating"AutopilotCruising=false end else if kc then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not ao then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bK;AutopilotShipUp=bI;AutopilotShipRight=bK end;AutopilotRealigned=true elseif kc then AutopilotAccelerating=true;AutopilotStatus="Accelerating"if not P then c2(AutopilotInterplanetaryThrottle,true)I=z(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and av>0)then a2="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;c2(0)P=false;ProgradeIsOn=true;ao=true;cv(ac,CustomTarget.position)end;if a0 then bi=true;local kG=0;local fU=bP+vec3(unit.getMasterPlayerRelativePosition())local kJ=fU-bP;local kK=vec3(kJ):project_on(bJ):len()local kL=vec3(kJ):project_on(bK):len()local ak=math.sqrt(kK*kK+kL*kL)cQ(kJ:normalize())local kM=40;local kN=ak<kM;local kO=100;local kP=s((ak-kM)/2,10,kO)U=0;local kc=d(V)<0.1;if kc and bM<kP and not kN then BrakeIsOn=false;kG=-20 else BrakeIsOn=true;kG=0 end;local kQ=0;if d(kG-bU)>kQ then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kG-bU)local kH=pitchPID:get()U=kH end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local cJ=unit.getClosestPlanetInfluence()>0;local kR=HoldAltitude-aw;local kS=500+bM;local kT=1;if AutoTakeoff then kT=s(bM/100,0.1,1)end;local kG=(utils.smoothstep(kR,-kS,kS)-0.5)*2*MaxPitch*kT;if not Reentry and not ao and not VectorToTarget and bJ:dot(bL:normalize())<0.99 then kG=(utils.smoothstep(kR,-kS*s(20-19*av*10,1,20),kS*s(20-19*av*10,1,20))-0.5)*2*MaxPitch*s(2-av*10,1,2)*kT end;if not AltitudeHold then kG=0 end;if LockPitch~=nil then if cJ and not IntoOrbit then kG=LockPitch else LockPitch=nil end end;bi=true;local kU=U;if Reentry then local kV=e(br)local kW,kX=bc.computeDistanceAndTime(bM,kV/3.6,m(),0,0,LastMaxBrake-planet.gravity*9.8*m())local kY=aw-(planet.noAtmosphericDensityAltitude+5000)if not bT and aw>planet.noAtmosphericDensityAltitude+5000 and bM<=kV/3.6 and bM>kV/3.6-10 and d(bL:normalize():dot(bJ))>0.9 then c2(0)elseif bT and(kW>-1 and kY<=kW or aw<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;c5(kV,true)if not R then kG=-80;if av>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kG=0;bi=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and aw>planet.noAtmosphericDensityAltitude+5000 then bi=true elseif aw<=planet.noAtmosphericDensityAltitude+5000 then c5(kV)if not bT and t:getTargetSpeed(axisCommandId.longitudinal)==br then R=false;Reentry=false;bi=true end end end;if bM>Q and not ap and not VectorToTarget and not BrakeLanding and ForceAlignment then cQ(vec3(bL))end;if(VectorToTarget or ap)and AutopilotTargetIndex>0 and av>0.01 then local cZ;if CustomTarget~=nil then cZ=CustomTarget.position-bP else cZ=ac.center-bP end;local kF=math.deg(k2(bN:normalize(),bL,cZ))*2;local kZ=math.rad(d(bV))if bM>minRollVelocity and av>0.01 then local k_=s(90-kG*2,-90,90)bo=s(kF*2,-k_,k_)local l0=kF;kF=s(s(kF,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(kZ)+4*(bU-kG)*math.sin(math.rad(bV)),-YawStallAngle*0.80,YawStallAngle*0.80)kG=s(s(kG*math.cos(kZ),-PitchStallAngle*0.80,PitchStallAngle*0.80)+d(s(d(l0)*math.sin(kZ),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bo=0;kF=s(kF,-YawStallAngle*0.80,YawStallAngle*0.80)end;local l1=k9-kF;if not bm and bM>minRollVelocity and av>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(l1)local kI=s(yawPID:get(),-1,1)V=V+kI elseif au and ar>-1 or bM<minRollVelocity then cQ(cZ)elseif bm and av>0.01 then if(k9<-YawStallAngle or k9>YawStallAngle)and av>0.01 then cQ(bL)end;if(ka<-PitchStallAngle or ka>PitchStallAngle)and av>0.01 then kG=s(bU-ka,bU-PitchStallAngle*0.80,bU+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ap then local kd=planet:getAltitude(CustomTarget.position)local kY=math.sqrt(cZ:len()^2-(aw-kd)^2)local l2=LastMaxBrakeInAtmo;if l2 then l2=l2*s(bM/100,0.1,1)*av else l2=LastMaxBrake end;if av<0.01 then l2=LastMaxBrake end;local l3=bL:len()-d(bO)local l4=vec3(core.getWorldAirFrictionAcceleration())local l5=math.sqrt(l4:len()-l4:project_on(cu):len())*m()if bM>100 then a8,a9=bc.computeDistanceAndTime(bM,100,m(),0,0,l2+l5)local l6,l7=bc.computeDistanceAndTime(100,0,m(),0,0,l2/2)a8=a8+l6 else a8,a9=bc.computeDistanceAndTime(bM,0,m(),0,0,l2/2)end;StrongBrakes=true;if not ap and not Reentry and kY<=a8+bM*k8/2 and(bL:project_on_plane(bN):normalize():dot(cZ:project_on_plane(bN):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"c2(0)if AltitudeHold then co()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l3<0.1 or kY<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<kY)then if not bR then BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"end;LastDistanceToTarget=kY end elseif VectorToTarget and av==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ap or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local cZ=CustomTarget.position-bP;local kd=planet:getAltitude(CustomTarget.position)local kY=math.sqrt(cZ:len()^2-(aw-kd)^2)local l2=LastMaxBrakeInAtmo;if l2 then a8,a9=bc.computeDistanceAndTime(bM,0,m(),0,0,l2/2)StrongBrakes=true;if kY<=a8+bM*k8/2 and bL:project_on_plane(bN):normalize():dot(cZ:project_on_plane(bN):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;ao=false;aq=true;Autopilot=false;d1()end end;LastDistanceToTarget=kY end end end;if av==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ap or IntoOrbit or Reentry)then if not bC and not IntoOrbit then bA=HoldAltitude;bz=true;if VectorToTarget then by.VectorToTarget=true end;cn()VectorToTarget=false;bw=true end end;if bm and av>0.01 and ar==-1 and bM>minRollVelocity and VectorStatus~="Finalizing Approach"then cQ(bL)kG=s(bU-ka,bU-PitchStallAngle*0.80,bU+PitchStallAngle*0.80)end;U=kU;local da=-1;if BrakeLanding then kG=0;local l8=false;local l9=30;if bd~=nil and bd>0 then local l5=0;local fV=s(av,0.4,2)local l2=LastMaxBrakeInAtmo*s(bM/100,0.1,1)*fV;local la=bd*fV+l2+l5-fZ;local lb=l2/2+l5-fZ;local lc=bM-math.sqrt(d(lb/2)*20/(0.5*m()))*utils.sign(lb)if lc<0 then lc=0 end;local ld;if bM>100 then local le,_=bc.computeDistanceAndTime(bM,100,m(),0,0,l2)local lf,_=bc.computeDistanceAndTime(100,0,m(),0,0,math.sqrt(l2))ld=le+lf else ld=bc.computeDistanceAndTime(bM,0,m(),0,0,math.sqrt(l2))end;if ld<20 then BrakeIsOn=false else local lg=0;if lc>100 then local lh,_=bc.computeDistanceAndTime(lc,100,m(),0,0,la)local li,_=bc.computeDistanceAndTime(100,0,m(),0,0,bd*fV+math.sqrt(l2)+l5-fZ)lg=lh+li else lg,_=bc.computeDistanceAndTime(lc,0,m(),0,0,bd*fV+math.sqrt(l2)+l5-fZ)end;lg=(lg+15+bM*k8)*1.1;local lj=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lj then local kd=planet:getAltitude(CustomTarget.position)local lk=aw-kd-100;local cZ=CustomTarget.position-bP;local ll=math.sqrt(cZ:len()^2-(aw-kd)^2)if ll>100 then lj=false elseif lk<=lg or lg==-1 then BrakeIsOn=true;l8=true else BrakeIsOn=false;l8=true end end;if not lj and CalculateBrakeLandingSpeed then if lg>=l9 then BrakeIsOn=true else BrakeIsOn=false end;l8=true end end end;if not bT then c2(0)end;t:setTargetGroundAltitude(500)t:activateGroundEngineAltitudeStabilization(500)da=ar;if da>-1 then bi=autoRollPreference;if bM<1 or bL:normalize():dot(bN)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;a.control.extendLandingGears()t:setTargetGroundAltitude(LandingGearGroundHeight)ag=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bL:normalize():dot(-cu)<0.999 then BrakeIsOn=true elseif bO<-brakeLandingRate and not l8 then BrakeIsOn=true elseif not l8 then BrakeIsOn=false end end;if AutoTakeoff or ap then local fe,fg,ff;if AutopilotTargetCoords~=nil then fe,fg,ff=bb:getPlanetarySystem(0):castIntersections(bP,(AutopilotTargetCoords-bP):normalize(),function(fh)return fh.radius+fh.noAtmosphericDensityAltitude end)end;if bR then if aw>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;c2(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(kG)<15 and aw/HoldAltitude>0.75 then AutoTakeoff=false;if not ap then if bT and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ap and bM<Q then Autopilot=true;ap=false;AltitudeHold=false;AutoTakeoff=false;c2(0)elseif ap then c2(0)BrakeIsOn=true end elseif ap and av==0 and ac~=nil and(fe==nil or fe.name==ac.name)then Autopilot=true;ap=false;AltitudeHold=false;AutoTakeoff=false;if not bT then c2(0)end;AutopilotAccelerating=true end end;local lm=ar>-1;local ln=bU;if(VectorToTarget or ap)and not lm and bM>minRollVelocity and av>0.01 then local kZ=math.rad(d(bV))ln=bU*d(math.cos(kZ))+ka*math.sin(kZ)end;local lo=s(kG-ln,-PitchStallAngle*0.80,PitchStallAngle*0.80)if av<0.01 and VectorToTarget then lo=s(kG-ln,-85,MaxPitch)elseif av<0.01 then lo=s(kG-ln,-MaxPitch,MaxPitch)end;if d(bV)<5 or VectorToTarget or BrakeLanding or lm or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lo)local kH=pitchPID:get()U=U+kH end end;if antigrav~=nil and(antigrav and not ExternalAGG and aw<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end end;function script.onFlush()local function lp(lq,kP)local lr=vec3()local ls=vec3()if lq==axisCommandId.longitudinal then lr=vec3(core.getConstructOrientationForward())ls=bJ elseif lq==axisCommandId.vertical then lr=vec3(core.getConstructOrientationUp())ls=bI elseif lq==axisCommandId.lateral then lr=vec3(core.getConstructOrientationRight())ls=bK else return vec3()end;local lt=vec3(core.getWorldGravity())local lu=lt:dot(ls)local lv=vec3(core.getWorldAirFrictionAcceleration())local lw=lv:dot(ls)local lx=vec3(core.getVelocity())local ly=lx:dot(lr)local lz=kP*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(lz-ly)local lA=targetSpeedPID2:get()local lB=(lA-lw-lu)*ls;return lB end;local function lC(lq,kP)local lr=vec3()local ls=vec3()if lq==axisCommandId.longitudinal then lr=vec3(core.getConstructOrientationForward())ls=bJ elseif lq==axisCommandId.vertical then lr=vec3(core.getConstructOrientationUp())ls=bI elseif lq==axisCommandId.lateral then lr=vec3(core.getConstructOrientationRight())ls=bK else return vec3()end;local lt=vec3(core.getWorldGravity())local lu=lt:dot(ls)local lv=vec3(core.getWorldAirFrictionAcceleration())local lw=lv:dot(ls)local lx=vec3(core.getVelocity())local ly=lx:dot(lr)local lz=kP*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(lz-ly)local lA=targetSpeedPID:get()local lB=(lA-lw-lu)*ls;return lB end;local function lD(lE,dU,cb)local lF=lE:cross(cb):normalize_inplace()local eF=math.acos(s(lF:dot(-dU),-1,1))*constants.rad2deg;if lF:cross(-dU):dot(cb)<0 then eF=-eF end;return eF end;if antigrav~=nil and(antigrav and not ExternalAGG)then if not bR and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bT=t:getAxisCommandType(0)==axisCommandType.byThrottle;if bT and M then c2(0)M=false elseif not bT and not M then I=0;M=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local lG=s(T+U+system.getControlDeviceForwardInput(),-1,1)local lH=s(W+Z+system.getControlDeviceYawInput(),-1,1)local lI=s(X+V-system.getControlDeviceLeftRightInput(),-1,1)local lJ=Y;bN=vec3(core.getWorldVertical())if bN==nil or bN:len()==0 then bN=(planet.center-bP):normalize()end;bP=vec3(core.getConstructWorldPos())bI=vec3(core.getConstructWorldOrientationUp())bJ=vec3(core.getConstructWorldOrientationForward())bK=vec3(core.getConstructWorldOrientationRight())bL=vec3(core.getWorldVelocity())bM=vec3(bL):len()bO=-bN:dot(bL)bV=getRoll(bN,bJ,bK)local lK=bV/180*math.pi;local lL=math.cos(lK)local lM=math.sin(lK)bU=lD(bN,bJ,bK*lL+bI*lM)local lN=bL:normalize()local lO=getRoll(bN,bJ,bK)local lP=d(lO)local lQ=utils.sign(lO)local lR=vec3(core.getWorldAngularVelocity())local lS=lG*pitchSpeedFactor*bK+lH*rollSpeedFactor*bJ+lI*yawSpeedFactor*bI;if bN:len()>0.01 and(av>0.0 or ProgradeIsOn or Reentry or ao or AltitudeHold or IntoOrbit)then if bi==true and d(bo-lO)>autoRollRollThreshold and lH==0 and d(bU)<85 then local lT=bo;local lU=autoRollFactor;if av==0 then lU=lU/4;bo=0;lT=0 end;if rollPID==nil then rollPID=pid.new(lU*0.01,0,lU*0.1)end;rollPID:inject(lT-lO)local lV=rollPID:get()lS=lS+lV*bJ end end;if bN:len()>0.01 and av>0.0 then local lW=20.0;if turnAssist==true and lP>lW and lG==0 and lI==0 then local lX=turnAssistFactor*0.1;local lY=turnAssistFactor*0.025;local lZ=(lP-lW)/(180-lW)*180;local l_=0;if lZ<90 then l_=lZ/90 elseif lZ<180 then l_=(180-lZ)/90 end;l_=l_*l_;local m0=-lQ*lY*(1.0-l_)local m1=lX*l_;lS=lS+m1*bK+m0*bI end end;local m2=1;local m3=0;local m4=1;if system.getMouseWheel()>0 then if AltIsOn then if av>0 or Reentry then br=s(br+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=s(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end else I=z(s(I+speedChangeLarge/100,-1,1),2)end elseif system.getMouseWheel()<0 then if AltIsOn then if av>0 or Reentry then br=s(br-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=s(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end else I=z(s(I-speedChangeLarge/100,-1,1),2)end end;J=0;if au and AtmoSpeedAssist and bT then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(br/3.6-bL:dot(bJ))local m5=throttlePID:get()L=s(m5,-1,1)if L<I and av>0.005 then K=true;t:setThrottleCommand(axisCommandId.longitudinal,s(L,0.01,1))else K=false;t:setThrottleCommand(axisCommandId.longitudinal,I)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bL:len()-br/3.6)local m6=s(brakePID:get(),0,1)if av>0 and bO<-80 or av>0.005 then J=m6 end;if J>0 then if K and L==0.01 then t:setThrottleCommand(axisCommandId.longitudinal,0)end else L=s(L,0.01,1)end;local m7=''local m8=vec3()local m9=lp(axisCommandId.vertical,ag*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",m9,m3)local ma='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then ma=ma..ExtraLongitudeTags end;local mb=t:getAxisCommandType(axisCommandId.longitudinal)local mc=t:composeAxisAccelerationFromThrottle(ma,axisCommandId.longitudinal)local md=lC(axisCommandId.lateral,LeftAmount*1000)m7=m7 ..' , '.."lateral airfoil , lateral ground "m8=m8+md;if m8:len()>constants.epsilon then a:setEngineForceCommand(m7,m8,m3,'','','',m4)end;a:setEngineForceCommand(ma,mc,m2)local me='thrust analog vertical fueled 'local mf='thrust analog lateral fueled 'if ExtraLateralTags~="none"then mf=mf..ExtraLateralTags end;if ExtraVerticalTags~="none"then me=me..ExtraVerticalTags end;if ag~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(me,m9,m2)else a:setEngineForceCommand(me,vec3(),m2)end;if LeftAmount~=0 then a:setEngineForceCommand(mf,md,m2)else a:setEngineForceCommand(mf,vec3(),m2)end;if lJ==0 then lJ=J end;local mg=-lJ*(brakeSpeedFactor*bL+brakeFlatFactor*lN)a:setEngineForceCommand('brake',mg)else if AtmoSpeedAssist then t:setThrottleCommand(axisCommandId.longitudinal,I)end;local kP=unit.getAxisCommandValue(0)if not bT then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bL:len()-kP/3.6)local m6=s(brakePID:get(),0,1)lJ=s(lJ+m6,0,1)end;local mg=-lJ*(brakeSpeedFactor*bL+brakeFlatFactor*lN)a:setEngineForceCommand('brake',mg)local m7=''local m8=vec3()local mh=false;local ma='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then ma=ma..ExtraLongitudeTags end;local mb=t:getAxisCommandType(axisCommandId.longitudinal)if mb==axisCommandType.byThrottle then local mc=t:composeAxisAccelerationFromThrottle(ma,axisCommandId.longitudinal)a:setEngineForceCommand(ma,mc,m2)elseif mb==axisCommandType.byTargetSpeed then local mc=t:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)m7=m7 ..' , '..ma;m8=m8+mc;if t:getTargetSpeed(axisCommandId.longitudinal)==0 or t:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-t:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then mh=true end end;local mf='thrust analog lateral 'if ExtraLateralTags~="none"then mf=mf..ExtraLateralTags end;local mi=t:getAxisCommandType(axisCommandId.lateral)if mi==axisCommandType.byThrottle then local mj=t:composeAxisAccelerationFromThrottle(mf,axisCommandId.lateral)a:setEngineForceCommand(mf,mj,m2)elseif mi==axisCommandType.byTargetSpeed then local md=t:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)m7=m7 ..' , '..mf;m8=m8+md end;local me='thrust analog vertical 'if ExtraVerticalTags~="none"then me=me..ExtraVerticalTags end;local mk=t:getAxisCommandType(axisCommandId.vertical)if mk==axisCommandType.byThrottle then local m9=t:composeAxisAccelerationFromThrottle(me,axisCommandId.vertical)if ag~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(me,m9,m2,'airfoil','ground','',m4)else a:setEngineForceCommand(me,vec3(),m2)a:setEngineForceCommand('airfoil vertical',m9,m2,'airfoil','','',m4)a:setEngineForceCommand('ground vertical',m9,m2,'ground','','',m4)end elseif mk==axisCommandType.byTargetSpeed then if ag<0 then a:setEngineForceCommand('hover',vec3(),m2)end;local ml=t:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)m7=m7 ..' , '..me;m8=m8+ml end;if m8:len()>constants.epsilon then if Y~=0 or mh or d(lN:dot(bJ))<0.8 then m7=m7 ..', brake'end;a:setEngineForceCommand(m7,m8,m3,'','','',m4)end end;local mm=torqueFactor*(lS-lR)local mn=vec3(core.getWorldAirFrictionAngularAcceleration())mm=mm-mn;a:setEngineTorqueCommand('torque',mm,m2,'airfoil','','',m4)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local ed=vec3(core.getVelocity()):len()local mo=0.15;if not bT then local mp=t:getTargetSpeed(axisCommandId.longitudinal)if ed*3.6>mp*(1-mo)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ed*3.6<mp*(1-mo)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jc=unit.getThrottle()if AtmoSpeedAssist then jc=I*100 end;local kP=jc/100;if k==0 then kP=kP*MaxGameVelocity;if ed>=kP*(1-mo)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ed<kP*(1-mo)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kV=e(br)kP=kP*kV/3.6;if ed>=kP*(1-mo)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ed<kP*(1-mo)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local _,ci=coroutine.resume(beginSetup)if ci then SetupComplete=true end else a:update()if not bg and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(mq)local C=1;local function mr(ms)if ms then C=-1 end;if not ExternalAGG and bR then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+C*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bA=bA+C*a3;if bA<planet.noAtmosphericDensityAltitude then bA=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+C*a3 end else t:updateTargetGroundAltitudeFromActionStart(C*1.0)end end;local function mt(ms)if ms then C=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then I=s(I+C*speedChangeLarge/100,-1,1)else t:updateCommandFromActionStart(axisCommandId.longitudinal,C*speedChangeLarge)end else if ms then C=1 else C=nil end;ct(C)end end;if mq=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;c2(0)if(vBooster or hover)and ar==-1 then StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bi=true;GearExtended=false else BrakeIsOn=true;a.control.extendLandingGears()t:setTargetGroundAltitude(LandingGearGroundHeight)end;if S and not BrakeLanding then a.control.extendLandingGears()end else if S then a.control.retractLandingGears()end;t:setTargetGroundAltitude(TargetHoverHeight)end elseif mq=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif mq=="forward"then T=T-1 elseif mq=="backward"then T=T+1 elseif mq=="left"then W=W-1 elseif mq=="right"then W=W+1 elseif mq=="yawright"then X=X-1 elseif mq=="yawleft"then X=X+1 elseif mq=="straferight"then t:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif mq=="strafeleft"then t:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif mq=="up"then ag=ag+1;t:deactivateGroundEngineAltitudeStabilization()t:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif mq=="down"then ag=ag-1;t:deactivateGroundEngineAltitudeStabilization()t:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif mq=="groundaltitudeup"then mr()elseif mq=="groundaltitudedown"then mr(true)elseif mq=="option1"then ct()toggleView=false elseif mq=="option2"then ct(1)toggleView=false elseif mq=="option3"then local function mu()aH=not aH;if not aH then unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else unit.hide()core.hide()if fuelPanelID~=nil then u(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then u(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then u(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;mu()toggleView=false elseif mq=="option4"then cH()toggleView=false elseif mq=="option5"then local function mv()if LockPitch==nil then LockPitch=bU;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else LockPitch=nil end end;mv()toggleView=false elseif mq=="option6"then co()toggleView=false elseif mq=="option7"then toggleView=false elseif mq=="option8"then cp()toggleView=false elseif mq=="option9"then if gyro~=nil then gyro.toggle()az=gyro.getState()==1 end;toggleView=false elseif mq=="lshift"then if y()==1 then a1=true;PrevViewLock=y()x(1)elseif n()==1 and ShiftShowsRemoteButtons then a1=true;bh=false;bg=false end elseif mq=="brake"then if BrakeToggleStatus then cP()elseif not BrakeIsOn then cP()else BrakeIsOn=true end elseif mq=="lalt"then AltIsOn=true;if n()==0 and not freeLookToggle and userControlScheme=="keyboard"then x(1)end elseif mq=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif mq=="stopengines"then local function mw()if as then as=false;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;ao=false;ap=false;R=false;bi=autoRollPreference;VectorToTarget=false;TurnBurn=false;az=false;LockPitch=nil;IntoOrbit=false else as=true end end;t:resetCommand(axisCommandId.longitudinal)mw()I=0 elseif mq=="speedup"then mt()elseif mq=="speeddown"then mt(true)elseif mq=="antigravity"and not ExternalAGG then if antigrav~=nil then d3()end end end;function script.onActionStop(mq)local function mx()if not ExternalAGG and bR then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if mq=="forward"then T=0 elseif mq=="backward"then T=0 elseif mq=="left"then W=0 elseif mq=="right"then W=0 elseif mq=="yawright"then X=0 elseif mq=="yawleft"then X=0 elseif mq=="straferight"then t:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif mq=="strafeleft"then t:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif mq=="up"then ag=0;t:updateCommandFromActionStop(axisCommandId.vertical,-1.0)t:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mq=="down"then ag=0;t:updateCommandFromActionStop(axisCommandId.vertical,1.0)t:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mq=="groundaltitudeup"then mx()toggleView=false elseif mq=="groundaltitudedown"then mx()toggleView=false elseif mq=="lshift"then if y()==1 then a1=false;ah=0;ai=0;x(PrevViewLock)elseif n()==1 and ShiftShowsRemoteButtons then a1=false;bh=false;bg=false end elseif mq=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cP()else BrakeIsOn=false end end elseif mq=="lalt"then if n()==0 and freeLookToggle then if toggleView then if y()==1 then x(0)else x(1)end else toggleView=true end elseif n()==0 and not freeLookToggle and userControlScheme=="keyboard"then x(0)end;AltIsOn=false end end;function script.onActionLoop(mq)local C=1;local function my(ms)if ms then C=-1 end;if not ExternalAGG and bR then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=a6*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+C*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bA=bA+C*a5;if bA<planet.noAtmosphericDensityAltitude then bA=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+C*a5 end;a5=a5*1.05 else t:updateTargetGroundAltitudeFromActionLoop(C*1.0)end end;local function mz(ms)if ms then C=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then I=s(I+C*speedChangeSmall/100,-1,1)else t:updateCommandFromActionLoop(axisCommandId.longitudinal,C*speedChangeSmall)end end end;if mq=="groundaltitudeup"then my()elseif mq=="groundaltitudedown"then my(true)elseif mq=="speedup"then mz()elseif mq=="speeddown"then mz(true)end end;function script.onInputText(c1)local function mA()for c7,c8 in pairs(b)do dbHud_1.setStringValue(c8,h(nil))end;for c7,c8 in pairs(c)do if c8~="SavedLocations"then dbHud_1.setStringValue(c8,h(nil))end end;a2="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"aj=5;aN=false;af=true end;local function mB(mC,planet,fU)local function mD(fU)local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local gq='::pos{'..A..','..A..','..A..','..A..','..A..'}'local gD,gE,cD,cE,cC=p(fU,gq)if gD=="0"and gE=="0"then return vec3(tonumber(cD),tonumber(cE),tonumber(cC))end;cE=math.rad(cE)cD=math.rad(cD)local planet=b5[tonumber(gD)][tonumber(gE)]local ho=math.cos(cD)local mE=vec3(ho*math.cos(cE),ho*math.sin(cE),math.sin(cD))return planet.center+(planet.radius+cC)*mE end;if dbHud_1 then local cN={}local position=mD(fU)if planet.name=="Space"then cN={position=position,name=mC,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cN={position=position,name=mC,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;SavedLocations[#SavedLocations+1]=cN;table.insert(b5[0],cN)c6()else a2="Databank must be installed to save locations"end end;local i;local mF="/commands /setname /G /agg /addlocation /copydatabank /wipedatabank"local mG,mH=nil,nil;local mI="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all updatable variables with /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572} - adds a saved location by waypoint, not as accurate as making one at location\n".."/copydatabank - copies dbHud databank to a blank databank\n/wipedatabank - wipes the databank of all hud variables but not save variables"i=string.find(c1," ")mG=c1;if i~=nil then mG=string.sub(c1,0,i-1)mH=string.sub(c1,i+1)end;if mG=="/help"or mG=="/commands"then for g4 in string.gmatch(mI,"([^\n]+)")do system.print(g4)end;return elseif mG=="/setname"then if mH==nil or mH==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cK(mH)else a2="Select a saved target to rename first"end elseif mG=="/addlocation"then if mH==nil or mH==""or string.find(mH,"::")==nil then a2="Usage: ah-addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572}"return end;i=string.find(mH,"::")local mC=string.sub(mH,1,i-2)local fU=string.sub(mH,i)local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local gq='::pos{'..A..','..A..','..A..','..A..','..A..'}'local gD,gE,cD,cE,cC=p(fU,gq)local planet=b5[tonumber(gD)][tonumber(gE)]mB(mC,planet,fU)a2="Added "..mC.." to saved locations,\nplanet "..planet.name.." at "..fU;aj=5 elseif mG=="/agg"then if mH==nil or mH==""then a2="Usage: ah-agg targetheight"return end;mH=tonumber(mH)if mH<1000 then mH=1000 end;AntigravTargetAltitude=mH;a2="AGG Target Height set to "..mH elseif mG=="/G"then if mH==nil or mH==""then a2="Usage: ah-G VariableName variablevalue\nah-G dump - shows all variables"return end;if mH=="dump"then for c7,c8 in pairs(b)do if type(_G[c8])=="boolean"then if _G[c8]==true then system.print(c8 .." true")else system.print(c8 .." false")end elseif _G[c8]==nil then system.print(c8 .." nil")else system.print(c8 .." ".._G[c8])end end;return end;i=string.find(mH," ")local mJ=string.sub(mH,0,i-1)local mK=string.sub(mH,i+1)for c7,c8 in pairs(b)do if c8==mJ then a2="Variable "..mJ.." changed to "..mK;local mL=type(_G[c8])if mL=="number"then mK=tonumber(mK)elseif mL=="boolean"then if string.lower(mK)=="true"then mK=true else mK=false end end;_G[c8]=mK;return end end;a2="No such global variable: "..mJ elseif mG=="/copydatabank"then if dbHud_2 then db(true)else a2="Spare Databank required to copy databank"end elseif mG=="/wipedatabank"then if dbHud_1 then mA()else a2="No databank found."end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
