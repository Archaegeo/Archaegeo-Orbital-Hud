name: ArchHud - Archaegeo v0.742 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.742;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1175;V=66000;W=1000;X=50;Y=0;Z=100000;_=1.0;a0=32;a1=0;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)a9=K end,get=function()return a9 end},AutopilotInterplanetaryThrottle={set=function(K)_=K end,get=function()return _ end},warmup={set=function(K)a0=K end,get=function()return a0 end},fuelTankHandlingAtmo={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingSpace={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingRocket={set=function(K)a3=K end,get=function()return a3 end},ContainerOptimization={set=function(K)a4=K end,get=function()return a4 end},FuelTankOptimization={set=function(K)a5=K end,get=function()return a5 end},AutoShieldPercent={set=function(K)a6=K end,get=function()return a6 end},EmergencyWarp={set=function(K)a7=K end,get=function()return a7 end}}aa=1920;ab=1080;ac=400;ad=130;ae=224;af=255;ag=255;ah=0;ai=0;aj=960;ak=540;al=1300;am=540;an=1525;ao=325;ap=550;aq=540;ar=30;as=700;at=1750;au=250;av=1750;aw=350;ax=50;ay=250;az=0;aA=30;aB=100;aC={ResolutionX={set=function(K)aa=K end,get=function()return aa end},ResolutionY={set=function(K)ab=K end,get=function()return ab end},circleRad={set=function(K)ac=K end,get=function()return ac end},SafeR={set=function(K)ad=K end,get=function()return ad end},SafeG={set=function(K)ae=K end,get=function()return ae end},SafeB={set=function(K)af=K end,get=function()return af end},PvPR={set=function(K)ag=K end,get=function()return ag end},PvPG={set=function(K)ah=K end,get=function()return ah end},PvPB={set=function(K)ai=K end,get=function()return ai end},centerX={set=function(K)aj=K end,get=function()return aj end},centerY={set=function(K)ak=K end,get=function()return ak end},throtPosX={set=function(K)al=K end,get=function()return al end},throtPosY={set=function(K)am=K end,get=function()return am end},vSpdMeterX={set=function(K)an=K end,get=function()return an end},vSpdMeterY={set=function(K)ao=K end,get=function()return ao end},altMeterX={set=function(K)ap=K end,get=function()return ap end},altMeterY={set=function(K)aq=K end,get=function()return aq end},fuelX={set=function(K)ar=K end,get=function()return ar end},fuelY={set=function(K)as=K end,get=function()return as end},shieldX={set=function(K)at=K end,get=function()return at end},shieldY={set=function(K)au=K end,get=function()return au end},radarX={set=function(K)av=K end,get=function()return av end},radarY={set=function(K)aw=K end,get=function()return aw end},DeadZone={set=function(K)ax=K end,get=function()return ax end},OrbitMapSize={set=function(K)ay=K end,get=function()return ay end},OrbitMapX={set=function(K)az=K end,get=function()return az end},OrbitMapY={set=function(K)aA=K end,get=function()return aA end},soundVolume={set=function(K)aB=K end,get=function()return aB end}}aD=5.0;aE=1.0;aF=0.003;aG=0.003;aH=2;aI=1.5;aJ=180;aK=150;aL=0.002;aM=2;aN=0.8;aO=1;aP=3;aQ=1;aR=40;aS=0.0666667;aT=0.0;aU="none"aV="none"aW="none"aX={speedChangeLarge={set=function(K)aD=K end,get=function()return aD end},speedChangeSmall={set=function(K)aE=K end,get=function()return aE end},MouseXSensitivity={set=function(K)aF=K end,get=function()return aF end},MouseYSensitivity={set=function(K)aG=K end,get=function()return aG end},autoRollFactor={set=function(K)aH=K end,get=function()return aH end},rollSpeedFactor={set=function(K)aI=K end,get=function()return aI end},autoRollRollThreshold={set=function(K)aJ=K end,get=function()return aJ end},minRollVelocity={set=function(K)aK=K end,get=function()return aK end},TrajectoryAlignmentStrength={set=function(K)aL=K end,get=function()return aL end},torqueFactor={set=function(K)aM=K end,get=function()return aM end},pitchSpeedFactor={set=function(K)aN=K end,get=function()return aN end},yawSpeedFactor={set=function(K)aO=K end,get=function()return aO end},brakeSpeedFactor={set=function(K)aP=K end,get=function()return aP end},brakeFlatFactor={set=function(K)aQ=K end,get=function()return aQ end},DampingMultiplier={set=function(K)aR=K end,get=function()return aR end},hudTickRate={set=function(K)aS=K end,get=function()return aS end},ExtraEscapeThrust={set=function(K)aT=K end,get=function()return aT end},ExtraLongitudeTags={set=function(K)aU=K end,get=function()return aU end},ExtraLateralTags={set=function(K)aV=K end,get=function()return aV end},ExtraVerticalTags={set=function(K)aW=K end,get=function()return aW end}}aY=j;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=1000;ba=false;bb=false;bc=false;bd=false;be=0;bf="Aligning"bg=0;bh=1;bi="None"bj=nil;bk=0;bl=nil;bm=0.0;bn=0;bo={}bp=false;bq=0;br=0;bs=nil;bt=0;bu=1000;bv=0;bw=false;bx=0;by=false;bz="All"bA=true;bB="Off"bC=0.000;bD={}bE={}bF={VertTakeOff={set=function(K)b8=K end,get=function()return b8 end},VertTakeOffEngine={set=function(K)aZ=K end,get=function()return aZ end},SpaceTarget={set=function(K)bw=K end,get=function()return bw end},BrakeToggleStatus={set=function(K)aY=K end,get=function()return aY end},BrakeIsOn={set=function(K)a_=K end,get=function()return a_ end},RetrogradeIsOn={set=function(K)b0=K end,get=function()return b0 end},ProgradeIsOn={set=function(K)b1=K end,get=function()return b1 end},Autopilot={set=function(K)b2=K end,get=function()return b2 end},TurnBurn={set=function(K)b3=K end,get=function()return b3 end},AltitudeHold={set=function(K)b4=K end,get=function()return b4 end},BrakeLanding={set=function(K)b5=K end,get=function()return b5 end},Reentry={set=function(K)b7=K end,get=function()return b7 end},AutoTakeoff={set=function(K)b6=K end,get=function()return b6 end},HoldAltitude={set=function(K)b9=K end,get=function()return b9 end},AutopilotAccelerating={set=function(K)ba=K end,get=function()return ba end},AutopilotBraking={set=function(K)bc=K end,get=function()return bc end},AutopilotCruising={set=function(K)bd=K end,get=function()return bd end},AutopilotRealigned={set=function(K)bb=K end,get=function()return bb end},AutopilotEndSpeed={set=function(K)be=K end,get=function()return be end},AutopilotStatus={set=function(K)bf=K end,get=function()return bf end},AutopilotPlanetGravity={set=function(K)bg=K end,get=function()return bg end},PrevViewLock={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetName={set=function(K)bi=K end,get=function()return bi end},AutopilotTargetCoords={set=function(K)bj=K end,get=function()return bj end},AutopilotTargetIndex={set=function(K)bk=K end,get=function()return bk end},TotalDistanceTravelled={set=function(K)bm=K end,get=function()return bm end},TotalFlightTime={set=function(K)bn=K end,get=function()return bn end},SavedLocations={set=function(K)bo=K end,get=function()return bo end},VectorToTarget={set=function(K)bp=K end,get=function()return bp end},LocationIndex={set=function(K)bq=K end,get=function()return bq end},LastMaxBrake={set=function(K)br=K end,get=function()return br end},LockPitch={set=function(K)bs=K end,get=function()return bs end},LastMaxBrakeInAtmo={set=function(K)bt=K end,get=function()return bt end},AntigravTargetAltitude={set=function(K)bu=K end,get=function()return bu end},LastStartTime={set=function(K)bv=K end,get=function()return bv end},iphCondition={set=function(K)bz=K end,get=function()return bz end},stablized={set=function(K)bA=K end,get=function()return bA end},UseExtra={set=function(K)bB=K end,get=function()return bB end},SelectedTab={set=function(K)bG=K end,get=function()return bG end},saveRoute={set=function(K)bD=K end,get=function()return bD end},apRoute={set=function(K)bE=K end,get=function()return bE end}}local function bH(b,c,bI,bJ,bK)local a=DUSystem;local bL=DUConstruct;bM=bI()bN=0;bO=0;bP=false;bQ=0;bR=false;bS=false;bT=0;bU=0;bV=0;bW=0;bX=false;bY=false;bZ=false;b_="empty"c0=3;c1=false;c2=0;c3=0;c4=nil;c5=0;c6=0;c7=0;c8=false;c9=false;ca=false;cb=-1;cc=bK()>0;cd=bK()ce=b.getAltitude()cf=DUConstruct.getMass()cg=nil;ch=aa;ci=ab;cj={}ck={}cl={}cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=false;cw=false;cx=p;cy=false;cz=U;cA=nil;cB=0;cC=false;cD=false;cE=false;cF=vec3(bL.getWorldOrientationForward())cG=vec3(bL.getWorldOrientationRight())cH=vec3(bL.getVelocity())cI=vec3(bL.getWorldVelocity())cJ=vec3(cI):len()cK=vec3(b.getWorldVertical())cL=-cK:dot(cI)cM=vec3(bL.getWorldPosition())cN=false;cO=false;cP=true;cQ=0;cR=0;cS={}cT=false;cU=50000;cV=nil;cW=c.getClosestPlanetInfluence()>0 or ce>0 and ce<200000;cX=false;cY=nil;cZ=false;c_=0;d0=nil;d1=nil;d2={}d3=90;d4=w;d5=nil;d6=nil;d7={}d8={}d9=false;da=nil;db=0;dc=false;dd=bL.getMaxSpeed()if shield then de=bJ(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function df(dg)a.print(bM..": "..dg)end;local function dh(d,b,c,a,di,dj,dk,dl,dm)local function dn(dp)return type(dp)=='number'end;local function dq(dp)return type(dk(dp))=='number'end;local function dr(ds)return type(ds)=='table'end;local function dt(a)return type(a)=='string'end;local function du(dv)return dr(dv)and dn(dv.x and dv.y and dv.z)end;local function dw(dx)return dr(dx)and dn(dx.latitude and dx.longitude and dx.altitude and dx.id and dx.systemId)end;local dy=math.pi/180;local dz=180/math.pi;local dA=1e-10;local dB=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dC='::pos{'..dB..','..dB..','..dB..','..dB..','..dB..'}'local utils=utils;local vec3=vec3;local function dD(dp)local dE=string.gsub(string.reverse(di('%.4f',dp)),'^0*%.?','')return dE==''and'0'or string.reverse(dE)end;local function dF(dG)if du(dG)then return di('{x=%.3f,y=%.3f,z=%.3f}',dG.x,dG.y,dG.z)end;if dr(dG)and not getmetatable(dG)then local dH={}local dI=next(dG)if type(dI)=='nil'or dI==1 then dH=dG else for dJ,dv in pairs(dG)do local dK=dF(dv)if type(dJ)=='number'then table.insert(dH,di('[%s]=%s',dJ,dK))else table.insert(dH,di('%s=%s',dJ,dK))end end end;return di('{%s}',table.concat(dH,','))end;if dt(dG)then return di("'%s'",dG:gsub("'",[[\']]))end;return tostring(dG)end;local dL={}dL.__index=dL;dL.__tostring=function(dG,dM)local dN={}for dJ in pairs(dG)do table.insert(dN,dJ)end;table.sort(dN)local dH={}for dO,dJ in ipairs(dN)do local dK=dF(dG[dJ])if type(dJ)=='number'then table.insert(dH,di('[%s]=%s',dJ,dK))else table.insert(dH,di('%s=%s',dJ,dK))end end;if dM then return di('%s%s',dM,table.concat(dH,',\n'..dM))end;return di('{%s}',table.concat(dH,','))end;dL.__eq=function(dP,dQ)return dP.systemId==dQ.systemId and dP.id==dQ.id and dm(dP.radius,dQ.radius)and dm(dP.center.x,dQ.center.x)and dm(dP.center.y,dQ.center.y)and dm(dP.center.z,dQ.center.z)and dm(dP.GM,dQ.GM)end;local function dR(dS,dT,dU,dV,dW)assert(dq(dS),'Argument 1 (systemId) must be a number:'..type(dS))assert(dq(dT),'Argument 2 (id) must be a number:'..type(dT))assert(dq(dU),'Argument 3 (radius) must be a number:'..type(dU))assert(dr(dV),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dV))assert(dq(dW),'Argument 5 (GM) must be a number:'..type(dW))return setmetatable({systemId=dk(dS),id=dk(dT),radius=dk(dU),center=vec3(dV),GM=dk(dW)},dL)end;local dX={}dX.__index=dX;dX.__tostring=function(df)return di('::pos{%d,%d,%s,%s,%s}',df.systemId,df.id,dD(df.latitude*dz),dD(df.longitude*dz),dD(df.altitude))end;dX.__eq=function(dP,dQ)return dP.id==dQ.id and dP.systemId==dQ.systemId and dm(dP.latitude,dQ.latitude)and dm(dP.altitude,dQ.altitude)and(dm(dP.longitude,dQ.longitude)or dm(dP.latitude,math.pi/2)or dm(dP.latitude,-math.pi/2))end;local function dY(dZ,dT,d_,e0,e1)local dS=dZ;if dt(dZ)and not e0 and not e1 and not dT and not d_ then dS,dT,d_,e0,e1=e2(dZ,dC)assert(dS,'Argument 1 (position string) is malformed.')else assert(dq(dS),'Argument 1 (systemId) must be a number:'..type(dS))assert(dq(dT),'Argument 2 (id) must be a number:'..type(dT))assert(dq(d_),'Argument 3 (latitude) must be in degrees:'..type(d_))assert(dq(e0),'Argument 4 (longitude) must be in degrees:'..type(e0))assert(dq(e1),'Argument 5 (altitude) must be in meters:'..type(e1))end;dS=dk(dS)dT=dk(dT)d_=dk(d_)e0=dk(e0)e1=dk(e1)if dT==0 then return setmetatable({latitude=d_,longitude=e0,altitude=e1,id=dT,systemId=dS},dX)end;return setmetatable({latitude=dy*dj(d_,-90,90),longitude=dy*(e0%360),altitude=e1,id=dT,systemId=dS},dX)end;local e3={}e3.__index=e3;e3.__tostring=function(dG,dM)local e4=dM and dM..'  'local e5={}local dN={}for dJ in pairs(dG)do table.insert(dN,dJ)end;table.sort(dN)for dO,e6 in ipairs(dN)do e7=dG[e6]local e8=dL.__tostring(e7,e4)if dM then table.insert(e5,di('[%s]={\n%s\n%s}',e6,e8,dM))else table.insert(e5,di('  [%s]=%s',e6,e8))end end;if dM then return di('\n%s%s%s',dM,table.concat(e5,',\n'..dM),dM)end;return di('{\n%s\n}',table.concat(e5,',\n'))end;local function e9(ea)local e={}local pid;for dO,dv in pairs(ea)do local dT=dv.planetarySystemId;if type(dT)~='number'then error('Invalid planetary s ID: '..tostring(dT))elseif pid and dT~=pid then error('Mistringmatch planetary s IDs: '..dT..' and '..pid)end;local eb=dv.bodyId;if type(eb)~='number'then error('Invalid body ID: '..tostring(eb))elseif e[eb]then error('Duplicate body ID: '..tostring(eb))end;setmetatable(dv.center,getmetatable(vec3.unit_x))e[eb]=setmetatable(dv,dL)pid=dT end;return setmetatable(e,e3)end;ec={}local function ed(ea)return setmetatable({galaxyAtlas=ea or{}},ec)end;ec.__index=function(ds,K)if type(K)=='number'then local a=ds.galaxyAtlas[K]return e9(a)end;return rawget(ec,K)end;ec.__pairs=function(dG)return function(ds,dJ)local ee,ef=next(ds,dJ)return ee,ef and e9(ef)end,dG.galaxyAtlas,nil end;ec.__tostring=function(dG)local eg={}for dO,eh in pairs(dG or{})do local ei=eh:getPlanetarySystemId()local ej=e3.__tostring(eh,'    ')table.insert(eg,di('  [%s]={%s\n  }',ei,ej))end;return di('{\n%s\n}\n',table.concat(eg,',\n'))end;ec.BodyParameters=dR;ec.MapPosition=dY;ec.PlanetarySystem=e9;function ec.createBodyParameters(dS,dT,ek,el,em,en,eo)assert(dq(dS),'Argument 1 (systemId) must be a number:'..type(dS))assert(dq(dT),'Argument 2 (id) must be a number:'..type(dT))assert(dq(ek),'Argument 3 (surfaceArea) must be a number:'..type(ek))assert(dr(el),'Argument 4 (aPosition) must be an array or vec3:'..type(el))assert(dr(em),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(em))assert(dq(en),'Argument 6 (altitude) must be in meters:'..type(en))assert(dq(eo),'Argument 7 (gravityAtPosition) must be number:'..type(eo))local dU=dl(ek/4/math.pi)local c7=dU+en;local ep=vec3(el)+c7*vec3(em)local dW=eo*c7*c7;return dR(dS,dT,dU,ep,dW)end;ec.isMapPosition=dw;function ec:getPlanetarySystem(dZ)if K==nil then K=0 end;if ef==nil then ef=0 end;local dS=dZ;if dw(dZ)then dS=dZ.systemId end;if type(dS)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(ef)~=e3 then a=e9(a)end;return a end end end;function e3:sizeCalculator(eq)return 1.05*eq.radius end;function e3:castIntersections(er,es,et,eu,ev,ew)local ex={}if ev then for dO,eq in pairs(ev)do table.insert(ex,eq)end else ex=d2 end;if not ew then table.sort(ex,function(ey,ez)local eA=ey.center;local eB=ez.center;return(eA.x-er.x)^2+(eA.y-er.y)^2+(eA.z-er.z)^2<(eB.x-er.x)^2+(eB.y-er.y)^2+(eB.z-er.z)^2 end)end;local eC=es:normalize()for dO,eq in ipairs(ex)do local eD=eq.center-er;local dU;if et then dU=et(eq)else dU=self:sizeCalculator(eq)end;local eE=eD:dot(eC)local eF=eE^2-(eD:len2()-dU^2)if eF>=0 then local eG=dl(eF)local eH=eE+eG;local eI=eE-eG;if eI>0 then return eq,eH,eI elseif eH>0 then return eq,eH,nil end end end;return nil,nil,nil end;function e3:closestBody(eJ)assert(type(eJ)=='table','Invalid coordinates.')local eK,eq;local eL=vec3(eJ)for dO,eM in pairs(self)do local eN=(eM.center-eL):len2()if(not eq or eN<eK)and eM.name~="Space"then eq=eM;eK=eN end end;return eq end;function e3:convertToBodyIdAndWorldCoordinates(dZ)local eO=dZ;if dt(dZ)then eO=dY(dZ)end;if eO.id==0 then return 0,vec3(eO.latitude,eO.longitude,eO.altitude)end;local eM=self:getBodyParameters(eO)if eM then return eO.id,eM:convertToWorldCoordinates(eO)end end;function e3:getBodyParameters(dZ)local dT=dZ;if dw(dZ)then dT=dZ.id end;assert(dq(dT),'Argument 1 (id) must be a number:'..type(dT))return self[dT]end;function e3:getPlanetarySystemId()local dO,dv=next(self)return dv and dv.systemId end;function dL:convertToMapPosition(dV)assert(dr(dV),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dV))local eP=vec3(dV)if self.id==0 then return setmetatable({latitude=eP.x,longitude=eP.y,altitude=eP.z,id=0,systemId=self.systemId},dX)end;local eQ=eP-self.center;local c7=eQ:len()local e1=c7-self.radius;local d_=0;local e0=0;if not dm(c7,0)then local eR=eS(eQ.y,eQ.x)e0=eR>=0 and eR or 2*math.pi+eR;d_=math.pi/2-math.acos(eQ.z/c7)end;return setmetatable({latitude=d_,longitude=e0,altitude=e1,id=self.id,systemId=self.systemId},dX)end;function dL:convertToWorldCoordinates(dZ)local eO=dt(dZ)and dY(dZ)or dZ;if eO.id==0 then return vec3(eO.latitude,eO.longitude,eO.altitude)end;assert(dw(eO),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eO.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eO.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eT=math.cos(eO.latitude)return self.center+(self.radius+eO.altitude)*vec3(eT*math.cos(eO.longitude),eT*math.sin(eO.longitude),math.sin(eO.latitude))end;function dL:getAltitude(dV)return(vec3(dV)-self.center):len()-self.radius end;function dL:getDistance(dV)return(vec3(dV)-self.center):len()end;function dL:getGravity(dV)local eU=self.center-vec3(dV)local eV=eU:len2()return self.GM/eV*eU/dl(eV)end;return setmetatable(ec,{__call=function(dO,...)return ed(...)end})end;local function eW(d,b,c,a,dl,eX)local cn={}local bL=100000000/3600;local eY=bL*bL;local eZ=100;function cn.computeAccelerationTime(e_,f0,f1)local f2=bL*math.asin(e_/bL)return(bL*math.asin(f1/bL)-f2)/f0 end;function cn.computeDistanceAndTime(e_,f1,f3,f4,f5,f6)f5=f5 or 0;f6=f6 or 0;local f7=e_<=f1;local f8=f4*(f7 and 1 or-1)/f3;local f9=-f6/f3;local fa=f8+f9;if f7 and fa<=0 or not f7 and fa>=0 then return-1,-1 end;local fb,fc=0,0;if f8~=0 and f5>0 then local f2=math.asin(e_/bL)local fd=math.pi*(f8/2+f9)local fe=f8*f5;local ff=bL*math.pi;local dv=function(ds)local fg=(fd*ds-fe*math.sin(math.pi*ds/2/f5)+ff*f2)/ff;local fh=math.tan(fg)return bL*fh/dl(fh*fh+1)end;local fi=f7 and function(a)return a>=f1 end or function(a)return a<=f1 end;fc=2*f5;if fi(dv(fc))then local fj=0;while eX(fc-fj)>0.5 do local ds=(fc+fj)/2;if fi(dv(ds))then fc=ds else fj=ds end end end;local fk=e_;local fl=fc/eZ;for fm=1,eZ do local fn=dv(fm*fl)fb=fb+(fn+fk)*fl/2;fk=fn end;if fc<2*f5 then return fb,fc end;e_=fk end;local f2=bL*math.asin(e_/bL)local bM=(bL*math.asin(f1/bL)-f2)/fa;local fo=eY*math.cos(f2/bL)/fa;local c7=fo-eY*math.cos((fa*bM+f2)/bL)/fa;return c7+fb,bM+fc end;function cn.computeTravelTime(e_,f0,c7)if c7==0 then return 0 end;if f0>0 then local f2=bL*math.asin(e_/bL)local fo=eY*math.cos(f2/bL)/f0;return(bL*math.acos(f0*(fo-c7)/eY)-f2)/f0 end;if e_==0 then return-1 end;assert(e_>0,'Acceleration and initial speed are both zero.')return c7/e_ end;return cn end;local function fp(d,b,c,a,di,dj,dk,dl,dm)local vec3=vec3;local dh=dh(d,b,c,a,di,dj,dk,dl,dm)local function dt(a)return type(a)=='string'end;local function dr(ds)return type(ds)=='table'end;fq={}fq.__index=fq;function fq:escapeAndOrbitalSpeed(e1)assert(self.body)local c7=e1+self.body.radius;if not dm(c7,0)then local fr=dl(self.body.GM/c7)return dl(2)*fr,fr end;return nil,nil end;function fq:orbitalParameters(dZ,fs)assert(self.body)assert(dr(dZ)or dt(dZ))assert(dr(fs))local ft=(dt(dZ)or dh.isMapPosition(dZ))and self.body:convertToWorldCoordinates(dZ)or vec3(dZ)local dv=vec3(fs)local fu=ft-self.body.center;local fv=dv:len2()local fw=fu:len()local fx=self.body.GM;local fy=((fv-fx/fw)*fu-fu:dot(dv)*dv)/fx;local eA=fx/(2*fx/fw-fv)local fz=fy:len()local eC=fy:normalize()local fA=eA*(1-fz)local fB=eA*(1+fz)local fC=fA*eC+self.body.center;local fD=fz<=1 and-fB*eC+self.body.center or nil;local fE=dl(eA*fx*(1-fz*fz))local fF=fD and 2*math.pi*dl(eA^3/fx)local fG=math.acos(fy:dot(fu)/(fz*fw))if fu:dot(dv)<0 then fG=-(fG-2*math.pi)end;local fH=math.acos((math.cos(fG)+fz)/(1+fz*math.cos(fG)))local fI=fH;if fI<0 then fI=fI+2*math.pi end;local fJ=fI-fz*math.sin(fI)local fK=0;local fL=0;local fM=0;if fF~=nil then fK=fJ/(2*math.pi/fF)fL=fF-fK;fM=fL+fF/2;if fG-math.pi>0 then fL=fK;fM=fL+fF/2 end;if fM>fF then fM=fM-fF end end;return{periapsis={position=fC,speed=fE/fA,circularOrbitSpeed=dl(fx/fA),altitude=fA-self.body.radius},apoapsis=fD and{position=fD,speed=fE/fB,circularOrbitSpeed=dl(fx/fB),altitude=fB-self.body.radius},currentVelocity=dv,currentPosition=ft,eccentricity=fz,period=fF,eccentricAnomaly=fH,meanAnomaly=fJ,timeToPeriapsis=fL,timeToApoapsis=fM,trueAnomaly=fG}end;local function fN(fO)local eM=dh.BodyParameters(fO.systemId,fO.id,fO.radius,fO.center,fO.GM)return setmetatable({body=eM},fq)end;return setmetatable(fq,{__call=function(dO,...)return fN(...)end})end;local function fP(d,b,c,a,dbHud_1,e,fQ,fR,bJ,dk,dl,fS,fT)local function fU(fV)local df=fW:closestBody(fV)if(fV-df.center):len()>df.radius+df.noAtmosphericDensityAltitude then df=e[0][0]end;return df end;local function fX()local function fY(fZ,f_)return fZ.name<f_.name end;cS={}for dJ,dv in pairs(e[0])do cS[#cS+1]={name=dv.name,index=dJ}end;table.sort(cS,fY)end;local function g0(g1,g2)if not g2 then g2=g3.name end;for dJ,dv in pairs(g1)do if dv.name and dv.name==g2 then return dJ end end;return-1 end;local function g4()c_=bk;if bk==0 then bi="None"c4=nil;g3=nil;return true end;local g5=cS[bk].index;local g6=e[0][g5]if g6.center then bi=g6.name;c4=cm[0][g5]if g3~=nil then if cd==0 then if fQ(g7,g8)~=1 then fR(g7,g8)end;if fQ(g9,ga)~=1 then fR(g9,ga)end;if fQ(gb,gc)~=1 then fR(gb,gc)end;if fQ(gd,ge)~=1 then fR(gd,ge)end;if fQ(gf,gg)~=1 then fR(gf,gg)end end;if fQ(gh,gi)~=1 then fR(gh,gi)end;if fQ(gj,gk)~=1 then fR(gj,gk)end;if fQ(gl,gm)~=1 then fR(gl,gm)end end;g3=nil else g3=g6;for dO,dv in pairs(cm[0])do if dv.name==g3.planetname then c4=dv;bi=g3.name;break end end;if fQ(gh,gi)~=1 then fR(gh,gi)end;if fQ(gj,gk)~=1 then fR(gj,gk)end end;if g3==nil then bj=vec3(c4.center)else bj=g3.position end;if c4.planetname~="Space"then if c4.hasAtmosphere then gn=bJ(c4.radius*(S-1)+c4.noAtmosphericDensityAltitude)else gn=bJ(c4.radius*(S-1)+c4.surfaceMaxAltitude)end else gn=R end;if g3~=nil and g3.planetname=="Space"then be=0 else dO,be=co(c4):escapeAndOrbitalSpeed(gn)end;bg=0;ba=false;bc=false;bd=false;b2=false;bb=false;bf="Aligning"return true end;local function go(gp)if not b2 and not bp and not c9 and not by and not b7 and not ca then if gp==nil then bk=bk+1;if bk>#cS then bk=0 end else bk=bk-1;if bk<0 then bk=#cS end end;if bk==0 then g4()else local g5=cS[bk].index;local g6=e[0][g5]if g6 and(g6~=nil and g6.name=="Space"or bz=="Custom Only"and g6.center or bz=="No Moons"and string.find(g6.name,"Moon")~=nil)then if gp==nil then go()else go(1)end else g4()end end else b_="Disengage autopilot before changing Interplanetary Helper"fS("iph","AP")end end;local function gq()local function gr(gs)local gt;if gs then gt=d7 else gt=bo end;local gu=-1;gu=g0(e[0])if gu>-1 then table.remove(e[0],gu)end;gu=-1;gu=g0(gt)if gu~=-1 then b_=g3.name.." saved location cleared"table.remove(gt,gu)end;go()fX()return gt end;if string.sub(bi,1,1)=="*"then d7=gr(true)else bo=gr(false)end end;local function gv(gw,fV,gx,gy)local function gz(gs)if gs then gt=d7 else gt=bo end;if dbHud_1 or gx or gs then local df=fU(fV)local gA={position=fV,name=gw,planetname=df.name,gravity=b.getGravityIntensity(),safe=gy}if not gx then gt[#gt+1]=gA else for dJ,dv in pairs(e[0])do if dv.name and gw==dv.name then table.remove(e[0],dJ)end end end;table.insert(e[0],gA)fX()g4()b_="Location saved as "..gw.."("..df.name..")"return gt else b_="Databank must be installed to save permanent locations"end end;if string.sub(gw,1,1)=="*"then d7=gz(true)else bo=gz(false)end end;local gB={}function gB.UpdateAtlasLocationsList()fX()end;function gB.UpdateAutopilotTarget()g4()end;function gB.adjustAutopilotTargetIndex(gp)go(gp)end;function gB.findAtlasIndex(g1,g2)return g0(g1,g2)end;function gB.UpdatePosition(gC,gD,gE)local function gF(gs)local gt;if gs then gt=d7 else gt=bo end;local gu=g0(gt)if gu~=-1 then if gC~=nil then if gs then gC="*"..gC end;gt[gu].name=gC;bk=bk-1;go()elseif gE~=nil then if gE then local gG=ce;if gG<1000 then gG=1000 end;gt[gu].agg=fT(gG,0)b_=gt[gu].name.." AGG Altitude:"..gt[gu].agg.." saved ("..gt[gu].planetname..")"return elseif gE==false then gt[gu].agg=nil;b_=gt[gu].name.." AGG Altitude cleared ("..gt[gu].planetname..")"return end else local gH=gt[gu]if gD then gH.heading=cG:cross(cK)*5000;b_=gt[gu].name.." heading saved ("..gt[gu].planetname..")"return elseif gD==false then gH.heading=nil;b_=gt[gu].name.." heading cleared ("..gt[gu].planetname..")"return end;gH.gravity=b.getGravityIntensity()gH.position=cM;gH.safe=true end;b_=gt[gu].name.." position updated ("..gt[gu].planetname..")"else b_="Name Not Found"end end;if string.sub(bi,1,1)=="*"then gF(true)else gF(false)end end;function gB.AddNewLocation(gw,fV,gx,gy)gv(gw,fV,gx,gy)end;function gB.ClearCurrentPosition()gq()end;for dJ,dv in pairs(d8)do table.insert(e[0],dv)end;if gI then for dJ,dv in pairs(gI)do gB[dJ]=dv end end;fX()if bk>#cS then bk=0 end;gB.UpdateAutopilotTarget()return gB end;local function gJ(b,a,c,gK,radar_1,radar_2,warpdrive,eX,gL,dl,gM,dk,gN,fS)local gO={}local gP={}local gQ={XS=13,S=27,M=55,L=110,XL=221}local gR={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gS={}local gT=0;local gU;local gV;local gW;local gX;local gY={gX}local gZ="Atmo"local g_;local h0;local h1=0;local h2={}local h3;local h4=0;local vec3=vec3;local h5=table.insert;local h6=-4;local h7={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local function h8()local function h9(ha,hb,hc,hd,he,hf,hg,hh)hb,hd,hf,hh=vec3(hb),vec3(hd),vec3(hf),vec3(hh)local hi,hj,hk=ha*ha,hc*hc,he*he;local fv=hd-hb;local hl=fv:normalize()local hm=fv:len()local hn=hf-hb;local ho=(hn-hn:project_on(hl)):normalize()local hp,hq=hn:dot(hl),hn:dot(ho)local hr=hp*hp+hq*hq;local hs=hl:cross(ho)local ht=(hi-hj+hm*hm)/(2*hm)local hu=(hi-hk+hr-2*hp*ht)/(2*hq)local dx=hi-ht^2-hu^2;local hv=dl(dx)local hw=hb+hl*ht+ho*hu+hs*hv;local hx=hb+hl*ht+ho*hu-hs*hv;if eX((hh-hw):len()-hg)<eX((hh-hx):len()-hg)then return hw else return hx end end;local function hy(hz,fw,hA)local hB=hz.pts;local gu=#hB;local hC=hz.ref;if gu>3 then local hD,hE,hF,hG=hB[gu],hB[gu-1],hB[gu-2],hB[gu-3]hz.ref=hA;local ft=h9(hD[1],hD[2],hE[1],hE[2],hF[1],hF[2],hG[1],hG[2])local ht,hu,hv=ft.x,ft.y,ft.z;if ht==ht and hu==hu and hv==hv then ht=ht+hC[1]hu=hu+hC[2]hv=hv+hC[3]local hH=vec3(ht,hu,hv)hz.center=hH;if hz.lastPos then if(hz.lastPos-hH):len()<2 then local hI=(hH-vec3(hA)):len()if eX(hI-fw)<10 then hz.skipCalc=true end end end;hz.lastPos=hH end;hz.pts={}else local hJ={hA[1]-hC[1],hA[2]-hC[2],hA[3]-hC[3]}hB[gu+1]={fw,hJ}end end;if radar_1 or radar_2 then cs.assignRadar()end;if gX then gT=#gX.getConstructIds()if gT>0 then local hK=h3:gmatch('{"constructId[^}]*}[^}]*}')local hL=gX.hasMatchingTransponder;local hM=gX.getConstructKind;local hN=gX.isConstructAbandoned;local hO=gX.getConstructName;local hA={cM["x"],cM["y"],cM["z"]}local hP,hQ=0,0;local hR=cJ*10;local cW=cW;gW,gV=0,0;gP={}for dv in hK do local dT,c7,hS=dv:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hT=gQ[hS]c7=dk(c7)if hL(dT)==1 then h5(gP,dT)end;if not cT and warpdrive and c7<a7 and warpdrive.getStatus()==15 then b_="INITIATING WARP"c0=7;warpdrive.initiate()end;if E then local hU=hM(dT)local hV=F and hN(dT)==1;if hV or c7<hR and(hT>27 or hU==4 or hU==6)then gW=gW+1;local gw=hO(dT)local hz=h2[dT]if hz==nil then hT=hT+gN;h2[dT]={pts={},ref=hA,name=gw,i=0,radius=hT,skipCalc=false}hz=h2[dT]end;if not hz.skipCalc then hy(hz,c7,hA)if hV and not hz.abandoned and hz.center then local bM=a.getArkTime()if h4+5<bM then h4=bM;fS("abRdr","RD")end;a.print("Abandoned Construct: "..gw.." ("..hS.." "..gR[hU]..") at estimated ::pos{0,0,"..hz.center.x..","..hz.center.y..","..hz.center.z.."}")b_="Abandoned Radar Contact ("..hS.." "..gR[hU]..") detected"hz.abandoned=true end;hQ=hQ+1 else h5(gS,hz)end end;hP=hP+1;if cW and hP>700 or hQ>70 or(not cW and hP>300 or hQ>30)then coroutine.yield()hP,hQ=0,0 end end end;gV=#gS;if gV>0 and(cJ>20 or b5)then local eq,hW,hX,hY;local hZ=0;local h_=cm:getPlanetarySystem(0)hY=cI:normalize()while hZ<gV do coroutine.yield()local i0={table.unpack(gS,hZ,math.min(hZ+75,gV))}eq,hW,hX=h_:castIntersections(cM,hY,nil,nil,i0,true)if eq and hX then cY={eq,hW,hX}break end;hZ=hZ+75 end;if not eq then cY=nil end else cY=nil end;gS={}gU=h3:find('identifiedConstructs":%[%]')end end end;local function i1()if gX then gZ="Atmo"if h3:find('worksInAtmosphere":false')then gZ="Space"end end end;function gO.pickType()i1()end;function gO.assignRadar()if radar_2 and h6~=1 then if h6==-1 then if gX==radar_2 then gX=radar_1 else gX=radar_2 end end;gY={gX}h3=gX.getWidgetData()i1()else h3=gX.getWidgetData()end;h6=gX.getOperationalState()end;function gO.UpdateRadar()local i2=coroutine.status(g_)if i2=="suspended"then local dK,i3=coroutine.resume(g_)if i3 then a.print("ERROR UPDATE RADAR: "..i3)end elseif i2=="dead"then g_=coroutine.create(h8)local dK,i3=coroutine.resume(g_)end end;function gO.GetRadarHud(i4,i5,av,aw)local i6,dg;local dB=gV or 0;if gT>0 then if E then dg=dB.."/"..gW.." Plotted : "..gT-gW.." Ignored"else dg="Radar Contacts: "..gT end;i6=gM(av,aw,dg,"pbright txtbig txtmid")if#gP>0 then i6=i6 ..gM(i4,i5,"Friendlies In Range","pbright txtbig txtmid")for dJ,dv in pairs(gP)do i5=i5+20;i6=i6 ..gM(i4,i5,gX.getConstructName(dv),"pdim txtmid")end end;if gU==nil and h0==nil then h1=1;cs.ToggleRadarPanel()end;if gU~=nil and h0~=nil then cs.ToggleRadarPanel()end;if d6==nil then cs.ToggleRadarPanel()end else if h6~=1 then i6=gM(av,aw,gZ.." Radar: "..h7[h6],"pbright txtbig txtmid")else i6=gM(av,aw,"Radar: No "..gZ.." Contacts","pbright txtbig txtmid")end;if d6~=nil then h1=0;cs.ToggleRadarPanel()end end;return i6 end;function gO.GetClosestName(gw)if gX then local dT,dO=gX.getWidgetData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dT~=nil and dT~=""then gw=gw.." "..gX.getConstructName(dT)end end;return gw end;function gO.ToggleRadarPanel()if d6~=nil and h1==0 then gL(d6)d6=nil;if h0~=nil then gL(h0)h0=nil end else if h1==1 then gL(d6)d6=nil;_autoconf.displayCategoryPanel(gY,1,"Periscope","periscope")h0=_autoconf.panels[_autoconf.panels_size]end;if d6==nil then _autoconf.displayCategoryPanel(gY,1,"Radar","radar")d6=_autoconf.panels[_autoconf.panels_size]end;h1=0 end end;function gO.ContactTick()if not i7 then i7=0 end;if bM>i7+10 then b_="Radar Contact"fS("rdrCon","RC")i7=bM end;c.stopTimer("contact")end;function gO.onEnter(dT)if gX and not cc and not cT then c.setTimer("contact",0.1)end end;function gO.onLeave(dT)if gX and E then if#h2>650 then dT=tostring(dT)h2[dT]=nil end end end;gX=nil;if radar_2 and radar_2.getOperationalState()==1 then gX=radar_2 else gX=radar_1 end;h6=gX.getOperationalState()gY={gX}h3=gX.getWidgetData()i1()g_=coroutine.create(h8)if i8 then for dJ,dv in pairs(i8)do gO[dJ]=dv end end;return gO end;local function i9(shield,e2,bJ)local ia={}local ib=shield.getResistancesCooldown()local function ic()local id=shield.isActive()if G then if not cT and id==0 and shield.isVenting()~=1 then shield.toggle()elseif cT and id==1 then shield.toggle()end end end;local function ie()local ig=shield.getStressRatioRaw()local ih=0.5999;if ig[1]==0.0 and ig[2]==0.0 and ig[3]==0.0 and ig[4]==0.0 then return end;local ii=shield.setResistances(ih*ig[1],ih*ig[2],ih*ig[3],ih*ig[4])if ii==1 then b_="Shield Resistances updated"else b_="Value Exceeded. Failed to update Shield Resistances"end end;function ia.shieldTick()de=bJ(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ic()ib=shield.getResistancesCooldown()if ib==0 and de<a6 then ie()end end;function ia.setResist(ij)if not shield then b_="No shield found"return elseif ij==nil or ib>0 then b_="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dB=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dC=dB..', '..dB..', '..dB..', '..dB;local ik,il,im,io=e2(ij,dC)if io==nil or ik+il+im+io>0.6 then b_="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(ik,il,im,io)==1 then b_="Shield Resistances set"else b_="Resistance setting failed."end end;function ia.ventShield()local ip=shield.getVentingCooldown()if ip>0 then b_="Cannot vent again for "..ip.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()b_="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else b_="Shields already at max hitpoints"end end;if iq then for dJ,dv in pairs(iq)do ia[dJ]=dv end end;return ia end;local function ir(d,b,c,a,e,antigrav,hover,shield,warpdrive,is,eX,bJ,di,it,bK,iu,iv,eS,bI,dj,iw,fR,fQ,gL,ix,dl,fT,gM,fS,iy,iz,iA,iB,iC,iD)local bL=DUConstruct;local iE=9.80665;local iF={}local iG={}local iH={}local iI={}local iJ=nil;local iK=nil;local iL=nil;local iM=false;local iN="none"local iO=""local iP=55;local iQ=0;local iR=0;local iS=nil;local iT=ad;local iU=ae;local iV=af;local iW=[[rgb(]]..bJ(iT+0.5)..","..bJ(iU+0.5)..","..bJ(iV+0.5)..[[)]]local iX=[[rgb(]]..bJ(iT*0.9+0.5)..","..bJ(iU*0.9+0.5)..","..bJ(iV*0.9+0.5)..[[)]]local iY=0;local iZ=0;local i_=""local j0=bI()local j1=false;local j2=false;local function j3(dv)if ch==1920 then return dv else return fT(ch*dv/1920,0)end end;local function j4(dv)if ci==1080 then return dv else return fT(ci*dv/1080,0)end end;local function j5()return ix()==0 and g~="keyboard"and iv()==0 end;local function j6()local j7="TRAVEL"if not cP then j7="CRUISE"end;if b2 then j7="AUTOPILOT"end;return j7 end;local i6=""local j8=""local j9=""local ja=1;local jb=2;local jc=3;local jd=4;local je=5;local jf=6;local jg=7;local jh=""local ji=0;local jj=120.0*aS;local jk={}local jl={}local jm={}local jn={}local jo={}local jp={}local jq={}jq["atmofueltank"],jq["spacefueltank"],jq["rocketfueltank"]=0,0,0;local jr=0;local function js(ht,jt,ju,jv,jw,jx)local jy=jr;local jz=jr+5;if not B then jz=jz+5 end;if iv()==1 and not l then jy=jy-50;jz=jz-50 end;if ju=="ATMO"then jh="atmofueltank"elseif ju=="SPACE"then jh="spacefueltank"else jh="rocketfueltank"end;ji=_G[jh.."_size"]if#jv>0 then for K=1,#jv do local gw=jv[K][jb]local jA=jv[K][jg]for jB=1,ji do if jv[K][jb]==it(c[jh.."_"..jB].getWidgetData()).name then jA=jB;break end end;local jC=bI()if jw[K]==nil or jx[K]==nil or jC-jv[K][jf]>jj then local jD;local jE=0;jE=iu(jv[K][ja])-jv[K][jd]jD=jv[K][je]if jD>jE then jq[jh]=jq[jh]+jD-jE end;if jA~=0 then local jF=it(c[jh.."_"..jA].getWidgetData())jx[K]=jF.percentage;jw[K]=jF.timeLeft;if jw[K]=="n/a"then jw[K]=0 end else jx[K]=bJ(0.5+jE*100/jv[K][jc])if jD<=jE then jw[K]=0 else jw[K]=bJ(0.5+jE/((jD-jE)/(jC-jv[K][jf])))end end;jv[K][jf]=jC;jv[K][je]=jE end;if gw==jt then gw=di("%s %d",ju,K)end;if jA==0 then gw=gw.." *"end;local jG;if jw[K]==0 then jG=""else jG=iB(jw[K])end;if jx[K]~=nil then local jH=bJ(jx[K]*2.55)local jI=di("rgb(%d,%d,%d)",255-jH,jH,0)local jJ=""if jG~=""and jw[K]<120 or jx[K]<5 then jJ="red "end;local jK=di("rgb(%d,%d,%d)",dj(bJ((255-jH)/2.55),50,100),dj(bJ(jH/2.55),0,50),50)local jL="rgb(196,0,255)"if ju=="ATMO"then jL="rgb(0,188,255)"elseif ju=="SPACE"then jL="rgb(239,255,0)"end;local jM=false;if jN~=jL then jM=true end;jN=jL;if B then if jM then jy=jy-5;jz=jz-5 end;j8=j8 ..di([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jK,jL,ht,jz,jI,bJ(jx[K]*1.7+0.5)-2,ht+1,jz+1,ht+5,jz+14,gw,jx[K],jG)jy=jy-22;jz=jz-22 else j8=j8 ..gM(ht,jy,gw,jJ.."pdim txtfuel")j8=j8 ..gM(ht,jz,di("%d%% %s",jx[K],jG),"pdim txtfuel","fill:"..jI)jy=jy+30;jz=jz+30 end end end end;jr=jy end;local function jO(jP,e1)if an==0 and ao==0 then return end;if e1<200000 and not cc or e1 and cc then local jQ=0;if eX(cL)>1 then jQ=45*math.log(eX(cL),10)if cL<0 then jQ=-jQ end end;jP[#jP+1]=di([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],an,ao,bJ(cL),bJ(jQ))end;return jP end;local function jR(jS)local gp=-cK;jS=jS-jS:project_on(gp)local jT=vec3(0,0,1)jT=jT-jT:project_on(gp)local jU=jT:cross(gp)local jQ=jT:angle_between(jS)*constants.rad2deg;if jS:dot(jU)<0 then jQ=360-jQ end;return jQ end;local function jV(jP,aj,ak,jW,jX,cW)if ac==0 then return end;local jY=ac;local jZ=20;local j_=bJ(jW)if cW then for K=-45,45,5 do local k0=K;jP[#jP+1]=di([[<g transform="rotate(%f,%d,%d)">]],k0,aj,ak)k1=5;if K%15==0 then k1=15 elseif K%10==0 then k1=10 end;jP[#jP+1]=di([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],aj,ak+jY+jZ-k1,aj,ak+jY+jZ)end;jP[#jP+1]=gM(aj,ak+jY+jZ-35,jX,"pdim txt txtmid")jP[#jP+1]=gM(aj,ak+jY+jZ-25,j_.." deg","pdim txt txtmid")jP[#jP+1]=di([[<g transform="rotate(%f,%d,%d)">]],-jW,aj,ak)jP[#jP+1]=di([[<<polygon points="%d,%d %d,%d %d,%d"/>]],aj-5,ak+jY+jZ-20,aj+5,ak+jY+jZ-20,aj,ak+jY+jZ-15)jP[#jP+1]="</g>"end;jP[#jP+1]=[[<g style="clip-path: url(#headingClip);">]]local k2=j_;if cW then k2=jR(cF)end;local k3=20;local k4=bJ(k2)local k5=0;local k6=ak+jY+jZ+20;local k7=aj;if jX~="YAW"then k6=j4(130)k7=j3(960)end;local k8=[[<path class="txttick line" d="]]local k9=bJ(k4-(k3+10)-k4%5+0.5)for K=k9+70,k9,-5 do local ht=k7-(-K*5+k2*5)if K%10==0 then k5=10;local dB=K;if dB==360 then dB=0 elseif dB>360 then dB=dB-360 elseif dB<0 then dB=dB+360 end;jP[#jP+1]=gM(ht,k6+15,dB,"txtmid bright")elseif K%5==0 then k5=5 end;if k5==10 then k8=di([[%s M %f %f v %d]],k8,ht,k6-5,k5)else k8=di([[%s M %f %f v %d]],k8,ht,k6-2.5,k5)end end;jP[#jP+1]=k8 ..[["/>]]jP[#jP+1]=di([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k7-5,k6-20,k7+5,k6-20,k7,k6-10)if I then if cW then jX="HDG"end;jP[#jP+1]=gM(j3(960),j4(100),k4 .."°","dim txt txtmid size14","")jP[#jP+1]=gM(j3(960),j4(85),jX,"dim txt txtmid size20","")end;jP[#jP+1]=[[</g>]]end;local function ka(jP,kb,jW,aj,ak,cW,kc,fn)if ac==0 then return end;local jY=ac;local kd=bJ(jY*3/5)if jY>0 then local ke=bJ(kb)local k1=0;local k8=di([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jW,aj,ak)if not cc then k8=di([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],aj,ak)end;jP[#jP+1]=di([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jY-1,aj,ak)jP[#jP+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bJ(ke-30-ke%5+0.5),bJ(ke+30+ke%5+0.5),5 do if K%10==0 then k1=30 elseif K%5==0 then k1=20 end;local hu=ak+-K*5+kb*5;if k1==30 then k8=di([[%s M %d %f h %d]],k8,aj-kd-k1,hu,k1)if cc then jP[#jP+1]=di([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jW,aj,ak,aj-kd+10,hu+4,K)jP[#jP+1]=di([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jW,aj,ak,aj+kd-10,hu+4,K)if K==0 or K==180 or K==-180 then jP[#jP+1]=di([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jW,aj,ak,aj-kd+20,hu,kd*2-40)end else jP[#jP+1]=gM(aj-kd+10,hu,K,"pdim txt txtmid")jP[#jP+1]=gM(aj+kd-10,hu,K,"pdim txt txtmid")end;k8=di([[%s M %d %f h %d]],k8,aj+kd,hu,k1)else k8=di([[%s M %d %f h %d]],k8,aj-kd-k1,hu,k1)k8=di([[%s M %d %f h %d]],k8,aj+kd,hu,k1)end end;jP[#jP+1]=k8 ..[["/>]]local kf="PITCH"if not cW then kf="REL PITCH"end;if kb>90 and not cc then kb=90-(kb-90)elseif kb<-90 and not cc then kb=-90-(kb+90)end;if jY>200 then if cc then if fn>iP then jP[#jP+1]=gM(aj,ak-15,"Yaw","pdim txt txtmid")jP[#jP+1]=gM(aj,ak+20,kc,"pdim txt txtmid")end;jP[#jP+1]=di([[<g transform="rotate(%f,%d,%d)">]],-jW,aj,ak)else jP[#jP+1]=di([[<g transform="rotate(0,%d,%d)">]],aj,ak)end;jP[#jP+1]=di([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],aj-kd+25,ak-5,aj-kd+20,ak,aj-kd+25,ak+5,aj-kd+50,ak+4,ke)jP[#jP+1]=di([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],aj+kd-25,ak-5,aj+kd-20,ak,aj+kd-25,ak+5,aj+kd-30,ak+4,ke)jP[#jP+1]="</g>"end;local kg=bJ(jY/3)jP[#jP+1]=di([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],aj-kg,ak,jY-kg)if not cc and cW then jP[#jP+1]=di([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jW,aj,ak,aj-kd+10,ak,kd*2-20)end;jP[#jP+1]="</g>"if jY<200 then if cc and fn>iP then jP[#jP+1]=gM(aj,ak-jY,kf,"pdim txt txtmid")jP[#jP+1]=gM(aj,ak-jY+10,ke,"pdim txt txtmid")jP[#jP+1]=gM(aj,ak-15,"Yaw","pdim txt txtmid")jP[#jP+1]=gM(aj,ak+20,kc,"pdim txt txtmid")else jP[#jP+1]=gM(aj,ak-jY,kf,"pdim txt txtmid")jP[#jP+1]=gM(aj,ak-jY+15,ke,"pdim txt txtmid")end end end end;local function kh(jP,e1,cW)local ki=ap;local kj=aq;if ki==0 and kj==0 then return end;local kk=78;local kl=19;local km=cb;if cb~=-1 then jP[#jP+1]=gM(ki+kk,kj+kl+20,di("AGL: %.1fm",cb),"pdim altsm txtend")end;if cW and(e1<200000 and not cc or e1 and cc)then table.insert(jP,di([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ki-1,kj-4,kk+2,kl+6,ki+1,kj-1,kk-4,kl))local gu=0;local kn=1;local ko=0;local kp=e1<0;local kq=e1<kr.surfaceMaxAltitude;local ks=9;if kp then ks=0 end;local e1=eX(e1)while gu<6 do local kt=11;local ku=16;local kv=9;local kw=14;local jJ="altsm"if gu>2 then ku=ku+3;kt=kt+2;kw=kw+2;kv=kv-6;jJ="altbig"end;if kp then jJ=jJ.." red"elseif kq then jJ=jJ.." orange"end;local kx=e1/kn%10;local ky=bJ(kx)local kz=bJ((ky+1)%10)local kA=ko;if gu==0 then kA=kx-ky;if kp then kA=1-kA end end;if kp and(gu==0 or ko~=0)then local gx=kz;kz=ky;ky=gx end;local kB=ku*(kA-1)local kC=kB+ku;local ht=ki+kv+(6-gu)*kt;local hu=kj+kw;jP[#jP+1]=gM(ht,hu+kB,kz,jJ)jP[#jP+1]=gM(ht,hu+kC,ky,jJ)gu=gu+1;kn=kn*10;if ky==ks then ko=kA else ko=0 end end;table.insert(jP,[[</g></g>]])end end;local function kD(fs)local kE=-math.deg(eS(fs.y,fs.z))+180;kE=kE-90;if kE<0 then kE=360+kE end;if kE>180 then kE=-180+kE-180 end;return-kE end;local function kF(fs)local k2=math.deg(eS(fs.y,fs.x))-90;if k2<-180 then k2=360+k2 end;return k2 end;local function kG(jP,fs,fn,aj,ak)if fn>5 and not cc or fn>iP then local jY=ac;local kH=20;local kI=20;local kJ=kD(fs)local kK=kF(fs)local kL=14;local kM=kL/2;local kN=-kK/kI*jY;local kO=kJ/kH*jY;local ht=aj+kN;local hu=ak+kO;local c7=dl(kN^2+kO^2)local kP=[[<circle
                            cx="]]..ht..[["
                            cy="]]..hu..[["
                            r="]]..kM/kL..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..ht..[["
                            cy="]]..hu..[["
                            r="]]..kM..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..ht-kL..[[,]]..hu..[[ h ]]..kM..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ht+kM..[[,]]..hu..[[ h ]]..kM..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ht..[[,]]..hu-kL..[[ v ]]..kM..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c7<jY then jP[#jP+1]=kP else local jQ=eS(kO,kN)local kQ=4;local kR=aj+jY*math.cos(jQ)local kS=ak+jY*math.sin(jQ)jP[#jP+1]=di('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jQ*180/math.pi,kR,kS,kR-kQ,kS-kQ/2,kQ*2,kQ,kR+kQ,kS-kQ,kQ,kQ,-kQ,kQ)end;if not cc then local kT=vec3(fs)kJ=kD(-kT)kK=kF(-kT)kN=-kK/kI*jY;kO=kJ/kH*jY;ht=aj+kN;hu=ak+kO;c7=dl(kN^2+kO^2)if c7<jY then local kU=[[<circle
                                    cx="]]..ht..[["
                                    cy="]]..hu..[["
                                    r="]]..kM..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ht..[[,]]..hu-kL..[[ v ]]..kM..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..ht..[[,]]..hu..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..ht..[[,]]..hu..[[)" />
                                <path
                                    d="M ]]..ht-kM..[[,]]..hu..[[ h ]]..kL..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..ht..[[,]]..hu..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..ht..[[,]]..hu..[[)"/>]]jP[#jP+1]=kU end end end end;local function kV(jP,j7,kW,kX)if al==0 and am==0 then return end;kW=bJ(kW+0.5)local jy=am+10;local jz=am+20;if iv()==1 and not l then jy=55;jz=65 end;local kY="CRUISE"local c="km/h"local dK=kX;if j7=="TRAVEL"or j7=="AUTOPILOT"then kY="THROT"c="%"dK=kW;local kZ="dim"if kW<0 then kZ="red"end;jP[#jP+1]=di([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kZ,al-7,am-50,al,am-50,al,am+50,al-7,am+50,1-eX(kW),al-10,am+50,al-15,am+53,al-15,am+47)end;jP[#jP+1]=gM(al+10,jy,kY,"pbright txtstart")jP[#jP+1]=gM(al+10,jz,di("%.0f %s",dK,c),"pbright txtstart")if cc and t and cP and bP then kW=bJ(bQ*100+0.5)local kZ="red"if kW<0 then kZ="red"end;jP[#jP+1]=di([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kZ,1-eX(kW),al-10,am+50,al-15,am+53,al-15,am+47)jP[#jP+1]=gM(al+10,jy+40,"LIMIT","pbright txtstart")jP[#jP+1]=gM(al+10,jz+40,kW.."%","pbright txtstart")end;if cc and t or b7 then jP[#jP+1]=gM(al+10,jy-40,"LIMIT: "..cz.." km/h","dim txtstart")elseif not cc and b2 then jP[#jP+1]=gM(al+10,jy-40,"LIMIT: "..bJ(a9*3.6+0.5).." km/h","dim txtstart")end end;local function k_(jP,l0)if al==0 and am==0 then return end;local l1=am-10;local l2=al+10;jP[#jP+1]=gM(0,0,"","pdim txt txtend")if iv()==1 and not l then l1=75 end;jP[#jP+1]=gM(l2,l1,bJ(l0).." km/h","pbright txtbig txtstart")end;local function l3(jP)jP[#jP+1]=gM(j3(150),j4(1070),di("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jP[#jP+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jP[#jP+1]=gM(j3(960),j4(550),"Warning: Invalid Control Scheme Detected","warnings")jP[#jP+1]=gM(j3(960),j4(600),"Keyboard Scheme must be selected","warnings")jP[#jP+1]=gM(j3(960),j4(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l4=j3(960)local l5=j4(860)local l6=j4(880)local l7=j4(900)local l8=j4(960)local l9=j4(200)local la=j4(250)local lb=j4(960)if iv()==1 and not l then l5=j4(135)l6=j4(155)l7=j4(175)l9=j4(115)la=j4(95)end;local lc="#222222"local ld="white"local le="dimmer"local lf="pbright"local lg="#110000"local lh=lc;local li=le;if a_ then local lj=""if type(a_)=="string"then lj="-"..a_ end;jP[#jP+1]=gM(l4,l5,"Brake Engaged"..lj,"warnings")lg="#440000"lh=ld;li=lf elseif bO>0 then jP[#jP+1]=gM(l4,l5,"Auto-Brake Engaged","warnings","opacity:"..bO)end;local lk="#110000"local ll=lc;local lm=le;if cc and cy and cb==-1 then if not b2 and not bp and not b5 and not cO and not b8 and not b6 then jP[#jP+1]=gM(l4,l9+50,"** STALL WARNING **","warnings")lk="#ff0000"ll=ld;lm=lf;fS("stall","SW",2)end end;if cV then jP[#jP+1]=gM(l4,l9+90,"Flight Assist in Progress","warnings")end;if cg then jP[#jP+1]=gM(l4,lb,"Gyro Enabled","warnings")end;local ln="#111100"local lo=lc;local lp=le;if bl then ln="#775500"lo=ld;lp=lf;if bS then jP[#jP+1]=gM(l4,l6,"Gear Extended","warn")else jP[#jP+1]=gM(l4,l6,"Landed (G: Takeoff)","warnings")end end;if cb>-1 and(not cO or ce<100)then local lq=iA(d:getTargetGroundAltitude())jP[#jP+1]=gM(l4,l7,"Hover Height: "..lq,"warn")end;local lr="#000011"local ls=lc;local lt=le;if c1 then lr="#0000DD"ls=ld;lt=lf;jP[#jP+1]=gM(l4,l8+20,"ROCKET BOOST ENABLED","warn")end;local lu="#001100"local lv=lc;local lw=le;if antigrav and not q and cO and bu~=nil then lu="#00DD00"lv=ld;lw=lf;local lx="warnings"if eX(ce-antigrav.getBaseAltitude())<501 then lx="warn"end;jP[#jP+1]=gM(l4,l9+40,di("Target Altitude: %d Singularity Altitude: %d",bJ(bu),bJ(antigrav.getBaseAltitude())),lx)end;if b2 and bi~="None"then jP[#jP+1]=gM(l4,l9,"Autopilot "..bf,"warn")elseif bs~=nil then jP[#jP+1]=gM(l4,l9+20,di("LockedPitch: %d",bJ(bs)),"warn")elseif bX then jP[#jP+1]=gM(l4,l9+20,"Follow Mode Engaged","warn")elseif b7 or ca then jP[#jP+1]=gM(l4,l9+20,"Re-entry in Progress","warn")end;if b4 or b8 then local lq=iA(b9,2)if b8 then if cO then lq=iA(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jP[#jP+1]=gM(l4,l9,"VTO to "..lq,"warn")elseif b6 and not by then if c9 then jP[#jP+1]=gM(l4,l9,"Takeoff to "..bi,"warn")else jP[#jP+1]=gM(l4,l9,"Takeoff to "..lq,"warn")end;if a_ and not b8 then jP[#jP+1]=gM(l4,l9+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jP[#jP+1]=gM(l4,l9,"Altitude Hold: "..di("%.1fm",b9),"warn")end end;if b8 and(antigrav~=nil and antigrav)then if cd>0.1 then jP[#jP+1]=gM(l4,l9+20,"Beginning ascent","warn")elseif cd<0.09 and cd>0.05 then jP[#jP+1]=gM(l4,l9+20,"Aligning trajectory","warn")elseif cd<0.05 then jP[#jP+1]=gM(l4,l9+20,"Leaving atmosphere","warn")end end;if by then if cA~=nil then jP[#jP+1]=gM(l4,l9,cA,"warn")end end;if b5 then if ly then local lz="Brake Landing"if da then lz=lz.."-Aligning"end;if d9 then lz=lz.."-Drift Limited"end;jP[#jP+1]=gM(l4,l9,lz,"warnings")else jP[#jP+1]=gM(l4,l9,"Coast-Landing","warnings")end end;if b1 then jP[#jP+1]=gM(l4,l9,"Prograde Alignment","crit")end;if b0 then jP[#jP+1]=gM(l4,l9,"Retrograde Alignment","crit")end;local lA="#110000"local lB=lc;local lC=le;if cX then lA="#FF0000"lB=ld;lC=lf;local type;if string.find(cX,"COLLISION")then type="warnings"else type="crit"end;jP[#jP+1]=gM(l4,la+20,cX,type)elseif cd==0 then local lD,lE=cr.checkLOS(cI:normalize())if lE~=nil then lC=lf;lA="#FF0000"lB=ld;local lq=iA(lE)local lF=cn.computeTravelTime(cJ,0,lE)local lG="Collision"if lD.noAtmosphericDensityAltitude>0 then lG="Atmosphere"end;jP[#jP+1]=gM(l4,la+20,lD.name.." "..lG.." "..iB(lF).." In "..lq,"crit")end end;if bp and not by then jP[#jP+1]=gM(l4,l9+60,lH,"warn")end;local lI="#111100"local lJ=lc;local lK=le;if d0 and#d0>1 then lI="#DDDD00"lJ=ld;lK=lf end;local lL=j3;local lM=j4;local le="topButton"local lN="topButtonActive"local lO=le;if b2 or bp or c9 or by then lO=lN end;local lP=le;if b1 then lP=lN end;local lQ=le;if b5 or bl then lQ=lN end;local lR=le;if b4 or bp then lR=lN end;local lS=le;if b0 then lS=lN end;local lT=le;if by or cC and b2 then lT=lN end;if w and I then local lU=lM(30)jP[#jP+1]=di([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lO,lL(960),lM(54),lM(-53),lL(-120),lL(25),lM(50))jP[#jP+1]=gM(lL(910),lU,"AUTOPILOT")jP[#jP+1]=di([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lP,lL(865),lM(51),lL(-25),lM(-50),lL(-110),lL(25),lM(46))jP[#jP+1]=gM(lL(800),lU,"PROGRADE")jP[#jP+1]=di([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lQ,lL(755),lM(47),lL(-25),lM(-46),lL(-98),lL(44),lM(44))jP[#jP+1]=gM(lL(700),lU,"LAND")jP[#jP+1]=di([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lR,lL(960),lM(54),lM(-53),lL(120),lL(-25),lM(50))jP[#jP+1]=gM(lL(1010),lU,"ALT HOLD")jP[#jP+1]=di([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lS,lL(1055),lM(51),lL(25),lM(-50),lL(110),lL(-25),lM(46))jP[#jP+1]=gM(lL(1122),lU,"RETROGRADE")jP[#jP+1]=di([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lT,lL(1165),lM(47),lL(25),lM(-46),lL(98),lL(-44),lM(44))jP[#jP+1]=gM(lL(1220),lU,"ORBIT")jP[#jP+1]=[[
                                    </g>
                                </g>]]jP[#jP+1]="</g>"end;return jP end;local function lV(fn)return bJ(fT(fn*3.6,0)+0.5).." km/h"end;local function lW(gu)local gw=bi;if gu~=nil and type(gu)=="number"then if gu==0 then return"None"end;gw=cS[gu].name end;if gw==nil then gw=g3.name end;if gw==nil then gw="None"end;return gw end;local function lX(jP)local lY=cr.routeWP(true)if not lY or#lY==0 then return end;local ht=j3(750)local hu=j4(360)if b2 or bp then jP[#jP+1]=gM(ht,hu,"REMAINING ROUTE","pdim txtstart size20")else jP[#jP+1]=gM(ht,hu,"LOADED ROUTE","pdim txtstart size20")end;for dJ,K in pairs(lY)do hu=hu+20;jP[#jP+1]=gM(ht,hu,dJ..". "..lY[dJ],"pdim txtstart size20")end end;local function lZ(jP)local ht=az+10;local hu=aA+20;local l_={}local m0={"Alt-4: AutoTakeoff to Target"}local m1={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m2={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local m3={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(l_,"--------------DYNAMIC-----------------")if cc then if cb~=-1 then iy(l_,m0)if c4 and kr and c4.name==kr.name then table.insert(l_,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aZ then if antigrav then if cO then table.insert(l_,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(l_,"Turn on AGG to takeoff to AGG Height")end end;if aZ then table.insert(l_,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(l_,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(l_,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bl then table.insert(l_,"G: Takeoff to hover height, raise gear")else table.insert(l_,"G: Lowergear and Land")end else iy(l_,m1)table.insert(l_,"G: Begin BrakeLanding or Land")end;if b8 then table.insert(l_,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iy(l_,m2)if shield then table.insert(l_,"Alt-Shift-6: Vent shields")if not G then table.insert(l_,"Alt-Shift-7: Toggle shield off/on")end end end;if g3~=nil then table.insert(l_,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(l_,"Alt-9: Activate Gyroscope")end;if aV~="none"or aU~="none"or aW~="none"then table.insert(l_,"Alt-Shift-9: Cycles engines with Extra tags")end;if b4 then table.insert(l_,"Alt-Spacebar/C will raise/lower target height")table.insert(l_,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cc then table.insert(l_,"LALT+Mousewheel will lower/raise speed limit")end;iy(l_,m3)for K=1,#l_ do hu=hu+12;jP[#jP+1]=gM(ht,hu,l_[K],"pdim txtbig txtstart")end end;local function m4(jP)local m5=az;local m6=aA;local m7=ay;local m8=4;local m9=15;local ht=0;local hu=0;local ma,mb,mc,md;local me;local function mf(type)local gG,bM,fn,mg,jJ,mh;if type=="Periapsis"then gG=me.periapsis.altitude;bM=me.timeToPeriapsis;fn=me.periapsis.speed;jJ="txtend"mg=12;mh=math.min(ht,m5+m7-kr.radius/mc-m8*2)else gG=me.apoapsis.altitude;bM=me.timeToApoapsis;fn=me.apoapsis.speed;mg=-12;jJ="txtstart"mh=ht end;if cJ<1 then bM=0 end;jP[#jP+1]=di([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mh+mg,hu-5,ht,hu-5)jP[#jP+1]=di([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mh-mg*4,hu+2,ht,hu+2)jP[#jP+1]=gM(mh,hu,type,jJ)ht=mh-mg*2;hu=hu+m9;local lq=iA(gG)jP[#jP+1]=gM(ht,hu,lq,jJ)hu=hu+m9;jP[#jP+1]=gM(ht,hu,iB(bM),jJ)hu=hu+m9;jP[#jP+1]=gM(ht,hu,lV(fn),jJ)end;local mi=m7*1.5;if bG=="INFO"then mi=25*10 end;if bG~="HIDE"then jP[#jP+1]=[[<g class="pbright txtorb txtmid">]]jP[#jP+1]=di('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m7*2,mi,m5,m6)jP[#jP+1]=di([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m7*2,mi,m5,m6)end;local mj=m7*1.5;local mk=m7*2;local ml=mj/2;local mm=m7;local mn=m5+mm;local mo=m6+ml;local mp=m5+mk;local mq=m6+mj;if bG=="ORBIT"then m6=m6+m8;ma=m7/2;md=0;me={}me.periapsis={}me.apoapsis={}if fr~=nil then if fr.periapsis~=nil then me.periapsis.altitude=fr.periapsis.altitude;me.periapsis.speed=fr.periapsis.speed end;if fr.apoapsis~=nil then me.apoapsis.altitude=fr.apoapsis.altitude;me.apoapsis.speed=fr.apoapsis.speed end;me.period=fr.period;me.eccentricity=fr.eccentricity;me.timeToApoapsis=fr.timeToApoapsis;me.timeToPeriapsis=fr.timeToPeriapsis;me.eccentricAnomaly=fr.eccentricAnomaly;me.trueAnomaly=fr.trueAnomaly end;if me.periapsis==nil then me.periapsis={}me.periapsis.altitude=-kr.radius;me.periapsis.speed=a9 end;if me.eccentricity==nil then me.eccentricity=1 end;if me.apoapsis==nil then me.apoapsis={}me.apoapsis.altitude=ce;me.apoapsis.speed=0 end;if cJ<1 then me.apoapsis.altitude=ce;me.apoapsis.speed=0 end;if me.apoapsis.altitude then mc=(me.apoapsis.altitude+me.periapsis.altitude+kr.radius*2)/(ma*2)mb=(kr.radius+me.apoapsis.altitude)/mc*(1-me.eccentricity)md=ma-me.periapsis.altitude/mc-kr.radius/mc;local mr=math.pi;if me.period~=nil and me.period>0 and me.timeToApoapsis~=nil then mr=me.eccentricAnomaly;if me.timeToPeriapsis<me.timeToApoapsis then mr=2*math.pi-mr end end;if cJ<1 or mr~=mr then mr=math.pi end;local ms=-ma*math.cos(mr)+m5+mm+m8;local mt=mb*math.sin(mr)+m6+ml+m8;local mu=""jP[#jP+1]='<g clip-path="url(#orbitRect)">'jP[#jP+1]=di([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mu,m5+m7+m8,m6+m7*1.5/2+m8,ma,mb)if mb<1 then jP[#jP+1]=di([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m5+m7+m8-md,m6+m7*1.5/2+m8,ms,mt)end;jP[#jP+1]=di('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m5+m7+m8-md,m6+m7*1.5/2+m8,(kr.radius+kr.noAtmosphericDensityAltitude)/mc)jP[#jP+1]=di('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m5+m7+m8-md,m6+m7*1.5/2+m8,(kr.radius+kr.noAtmosphericDensityAltitude)/mc)jP[#jP+1]=di([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m5+m7+m8,m6+m7*1.5/2+m8,ma,mb)jP[#jP+1]=di('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m5+m7+m8-md,m6+m7*1.5/2+m8,kr.radius/mc)jP[#jP+1]='</g>'local mv=math.floor(kr.radius/mc+0.5)ht=m5+m7+m8*4+ma;hu=m6+m7*1.5/2+5+m8;if me.apoapsis~=nil and me.apoapsis.speed<a9 then mf("Apoapsis")end;hu=m6+m7*1.5/2+5+m8;ht=m5+m7-m8*2-ma;if me.periapsis~=nil and me.periapsis.speed<a9 and me.periapsis.altitude>0 then mf("Periapsis")end;jP[#jP+1]=gM(m5+m7+m8,m6+20+m8,kr.name,"txtorbbig")jP[#jP+1]=di('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',ms,mt)jP[#jP+1]=[[</g>]]return jP else jP[#jP+1]='<g clip-path="url(#orbitRect)">'local mw=""local mx=1.2*(my-mz)/(m7*2)local mA=1.4*(mB-mC)/(m7*1.5)for dJ,dv in pairs(e[0])do if dv.center then local ht=m5+m7+dv.center.x/mx;local hu=m6+m7*1.5/2+dv.center.y/mA;mw=mw..'<circle cx="'..ht..'" cy="'..hu..'" r="'..dv.radius/mx*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dv.name,"Moon")and not string.match(dv.name,"Sanctuary")and not string.match(dv.name,"Space")then mw=mw.."<text x='"..ht.."' y='"..hu+dv.radius/mx*30+20 .."' font-size='12' fill="..iW.." text-anchor='middle' font-family='Montserrat'>"..dv.name.."</text>"end end end;local ft=vec3(bL.getWorldPosition())local ht=m5+m7+ft.x/mx;local hu=m6+m7*1.5/2+ft.y/mA;mw=mw..'<circle cx="'..ht..'" cy="'..hu..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mw=mw.."<text x='"..ht.."' y='"..hu-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iJ=mx;iK=mA;local mD=ft+cI*1000000;local mE=m5+m7+mD.x/mx;local jz=m6+m7*1.5/2+mD.y/mA;mw=mw..'<line x1="'..ht..'" y1="'..hu..'" x2="'..mE..'" y2="'..jz..'" stroke="purple" stroke-width="1"/>'jP[#jP+1]=mw;jP[#jP+1]='</g>'end elseif bG=="INFO"then jP=cp.DrawOdometer(jP,iY,bm,iZ)elseif bG=="HELP"then jP=lZ(jP)elseif bG=="SCOPE"then jP[#jP+1]='<g clip-path="url(#orbitRect)">'local mF=d3;if cd>0 then table.sort(d2,function(ey,ez)local eA,eB=ey.center,ez.center;return(eA.x-cM.x)^2+(eA.y-cM.y)^2+(eA.z-cM.z)^2<(eB.x-cM.x)^2+(eB.y-cM.y)^2+(eB.z-cM.z)^2 end)end;local mG={}local mH={}local mI=120;local mJ=nil;local mK=nil;for K,dv in ipairs(d2)do local gU=dv.center-cM;local mL=gU:len()local mM=gU:normalize()local mN=gU:cross(cF):normalize()local mO=math.acos(mN:dot(cG))if mO~=mO then mO=0 end;if mN:cross(cG):dot(cF)<0 then mO=-mO end;local mP=gU:project_on_plane(cF):len()local mQ=math.sin(mO)*math.asin(mP/mL)*constants.rad2deg;local mR=math.cos(mO)*math.asin(mP/mL)*constants.rad2deg;if mM:dot(cF)<0 then mR=90*math.cos(mO)+90*math.cos(mO)-mR;mQ=90*math.sin(mO)+90*math.sin(mO)-mQ end;local ht=mn+mQ/mF*mj;local hu=mo+mR/mF*mj;local mS=(ht-mn)*(ht-mn)+(hu-mo)*(hu-mo)local mT=math.asin((dv.radius+dv.surfaceMaxAltitude)/mL)*constants.rad2deg;if mT~=mT then mT=mF end;local hS=mT/mF*mj;local mU=math.asin(dv.atmosphereRadius/mL)*constants.rad2deg;if mU~=mU then mU=mT end;local mV=mU/mF*mj;local c7=iA(mL,1)local mW=dv.name;local mX=false;if hu>m6 then if hu>mq then if hu-mV<=mq then mX=true end else mX=true end else if hu+mV>=m6 then mX=true end end;local mY=false;local mZ=ht;if dv.systemId==0 then mZ=ht+mI else mZ=ht-mI end;if mZ+mI>m5 then if mZ+mI>mp then if mZ-mV-mI<=mp then mY=true end else mY=true end else if mZ+mV+mI>=m5 then mY=true end end;local m_={}m_.x=ht;m_.y=hu;m_.planet=dv;m_.atmoSize=mV;if not mJ or mS<mJ then mJ=mS;mK=m_ end;if mY and mX then local n0=math.max(mV,5)if mS<n0*n0 then mW=mW.." - "..c7 end;m_.size=hS;m_.i=K;m_.displayString=mW;m_.distance=c7;m_.visible=true;mH[#mH+1]=m_ else m_.visible=false end end;local n1=false;table.sort(mH,function(eA,eB)return eA.y<eB.y end)for dJ,fw in ipairs(mH)do local dv,hS,K,mV,ht,hu,mW,c7=fw.planet,fw.size,fw.i,fw.atmoSize,fw.x,fw.y,fw.displayString,fw.distance;local mh,n2,n3,n4;local n5=15;local jJ="pdim"if dv.systemId~=0 then n3=j3(string.len(mW)*5)n5=-(15+n3)n4=j4(10)jJ="pdimfill"else n3=j3(string.len(mW)*9)n4=j4(15)end;if hS*2>n3 then mh=dj(ht,m5+n3/2,mp-n3/2)n2=dj(hu,m6+n4,mq-5)mh=dj(mh,ht-hS+n3/2,ht+hS-n3/2)n2=dj(n2,hu-hS+n4,hu+hS)else mh=ht+n5;n2=hu end;for n6,fw in pairs(mG)do local n7=fw.textPositions;local n8=n7.y-n2;if n6~=K and eX(n8)<n7.height and n7.x+n7.width>mh and n7.x<mh+n3 then if hS>n3 then n2=dj(n2+n4,m6+15,mq-5)else n2=n7.y+n7.height+1 end end end;local n9=mW~=dv.name or mh<=mn and mh+n3>=mn and n2-n4<=mo and n2>=mo;fw.hovered=n9;local na=1;if n9 then na=2;if hS*2<n3 then na=10 end;if mW==dv.name then mW=mW.." - "..c7 end;jJ="pbright"if dv.systemId~=0 then n3=j3(string.len(mW)*5)n5=-(15+n3)else n3=j3(string.len(mW)*7)end;if hS*2>n3 then mh=dj(ht,m5+n3/2,mp-n3/2)mh=dj(mh,ht-hS+n3/2,ht+hS-n3/2)else mh=ht+n5 end end;mG[K]={}mG[K].textPositions={}mG[K].textPositions.y=n2;mG[K].textPositions.x=mh;mG[K].textPositions.width=n3;mG[K].textPositions.height=n4;mG[K].output=""if hS*2>n3 then jJ=jJ.." txtmid"else jJ=jJ.." txtstart"end;if mV-hS>2 then mG[K].output=di('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',ht,hu,mV,iX,0.1*na)end;mG[K].output=mG[K].output..di('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',ht,hu,hS,iX,0.2*na)if dv.systemId==0 then mG[K].output=mG[K].output..di([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mh,n2,iW,jJ,mW)if hS*2<=n3 then mG[K].output=mG[K].output..di("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mh+n3,n2+2,mh,n2+2,ht,hu)end else mG[K].output=mG[K].output..di([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mh,n2,iX,jJ,mW)if hS*2<=n3 then mG[K].output=mG[K].output..di("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mh,n2+2,mh+n3,n2+2,ht,hu)end end end;for dJ=#d2,1,-1 do if mG[dJ]then jP[#jP+1]=mG[dJ].output end end;if mK~=nil and d3<90 and not mK.hovered then local nb=mK.planet.atmosphereRadius/mK.atmoSize;local nc=dl(mJ)*nb;local nd=iA(nc,1)local n3=j3(math.max(string.len(nd)*7,string.len(mK.planet.name)*7))local n4=j4(12)local mh=dj(mK.x+(mn-mK.x)/2,m5+n3/2,mp-n3/2)local n2=dj(mK.y+(mo-mK.y)/2,m6+n4*2,mq-5)jP[#jP+1]=di("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mK.x,mK.y,mn,mo)jP[#jP+1]=di([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mh,n2,"white",nd)if not mK.visible then jP[#jP+1]=di([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mh,n2-n4,"white",mK.planet.name)end end;if cJ>1 then local gU=cI;local mM=gU:normalize()local mP=gU:project_on_plane(cF):len()local mN=gU:cross(cF):normalize()local mO=math.acos(mN:dot(cG))if mO~=mO then mO=0 end;if mN:cross(cG):dot(cF)<0 then mO=-mO end;local mQ=math.sin(mO)*math.asin(mP/gU:len())*constants.rad2deg;local mR=math.cos(mO)*math.asin(mP/gU:len())*constants.rad2deg;if mM:dot(cF)<0 then mR=90*math.cos(mO)+90*math.cos(mO)-mR;mQ=90*math.sin(mO)+90*math.sin(mO)-mQ end;local ht=mn+mQ/mF*mj;local hu=mo+mR/mF*mj;local kL=14;local kM=kL/2;local kP=[[<circle
                                    cx="]]..ht..[["
                                    cy="]]..hu..[["
                                    r="]]..kM/kL..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..ht..[["
                                    cy="]]..hu..[["
                                    r="]]..kM..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ht-kL..[[,]]..hu..[[ h ]]..kM..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..ht+kM..[[,]]..hu..[[ h ]]..kM..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..ht..[[,]]..hu-kL..[[ v ]]..kM..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jP[#jP+1]=kP end;jP[#jP+1]=di("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mn,mo-10,mn,mo+10)jP[#jP+1]=di("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mn-10,mo,mn+10,mo)jP[#jP+1]='</g>'else return jP end end;local function ne(nf,ng)local nh;local ni=(ng-nf):normalize()local fu=(cM-nf):dot(ni)/ni:dot(ni)if fu<=0. then return(cM-nf):len()elseif fu>=(ng-nf):len()then return(cM-ng):len()end;local nj=nf+fu*ni;nh=(nj-cM):len()return nh end;local function nk()local nh;local nl=nil;local nm=nil;local nn=nil;for dJ,no in pairs(e[0])do if no.hasAtmosphere then local c7=ne(kr.center,no.center)if nl==nil or c7<nl then nm=no;nl=c7;nn=kr end;if c4 and c4.hasAtmosphere and c4.name~=kr.name then local eN=ne(c4.center,no.center)if eN<nl then nm=no;nl=eN;nn=c4 end end end end;local np=j3(1770)local nq=j4(330)if nl then local nr="txttick "local ns=500000;if nl<nm.radius+ns or nl<nn.radius+ns then if cT then nr="txttick red "else nr="txttick orange "end end;nh=iA(nl,2)iO=gM(np,nq,"Pipe ("..nn.name.."--"..nm.name.."): "..nh,nr.."pbright txtmid")end end;local function nt(ht,hu,nu,nv,kY)local nw={x=ht,y=hu,width=nu,height=nv,label=kY}iI[kY]=nw;return nw end;local function nx(ny,nz,nu,nv,ht,hu,nA,nB,nC,nD,jJ)local nw={enableName=ny,disableName=nz,width=nu,height=nv,x=ht,y=hu,toggleVar=nA,toggleFunction=nB,drawCondition=nC,hovered=false,class=jJ}if nD then table.insert(iH,nw)else table.insert(iG,nw)end;return nw end;local function nE(nF)if not iM then nG=false;nH=false;nI=false;w=true;return elseif nF=="handling"then nG=not nG;nH=false;nI=false elseif nF=="hud"then nH=not nH;nG=false;nI=false elseif nF=="physics"then nI=not nI;nG=false;nH=false end;if nI or nH or nG then iN=iz(nF)w=false else iN="none"w=true end end;local function nJ()iM=not iM;if iM then iF=iH;b_="Tap SHIFT to see Settings"d4=w else iF=iG;b_="Tap SHIFT to see Control Buttons"nE()w=d4 end end;local function nK()local function nL(dv,dJ)dv.set(not dv.get())if dv.get()then b_=dJ.." set to true"else b_=dJ.." set to false"end;if dJ=="showHud"then d4=dv.get()elseif dJ=="BrakeToggleDefault"then aY=j end end;local nM=50;local nN=340;local ht=500;local hu=ci/2-400;local nO=0;for dJ,dv in pairs(iz("boolean"))do if type(dv.get())=="boolean"then nx(dJ,dJ,nN,nM,ht,hu,function()return dv.get()end,function()nL(dv,dJ)end,function()return true end,true)hu=hu+nM+20;if nO==9 then ht=ht+nN+20;hu=ci/2-400;nO=0 else nO=nO+1 end end end;nx("Control View","Control View",nN,nM,10,ci/2-500,function()return true end,nJ,function()return true end,true)nx("View Handling Settings",'Hide Handling Settings',nN,nM,10,ci/2-(500-nM),function()return nG end,function()nE("handling")end,function()return true end,true)nx("View Hud Settings",'Hide Hud Settings',nN,nM,10,ci/2-(500-nM*2),function()return nH end,function()nE("hud")end,function()return true end,true)nx("View Physics Settings",'Hide Physics Settings',nN,nM,10,ci/2-(500-nM*3),function()return nI end,function()nE("physics")end,function()return true end,true)end;local function nP()local function gv()local fV=cM;local gw=kr.name..". "..#bo;if cs then gw=cs.GetClosestName(gw)end;return cq.AddNewLocation(gw,fV,false,true)end;local function nQ()b3=not b3 end;local function nR(nS)if nS==1 then b1=not b1;b0=false else b0=not b0;b1=false end;b2=false;b4=false;bX=false;b5=false;bs=nil;b7=false;b6=false end;local function nT(nU,nV)cq.UpdatePosition(nil,nU,nV)end;local function gq()cq.ClearCurrentPosition()end;local function nW(gu)local lY=cr.routeWP(true)if lY and#lY>0 then return"Engage Route: "..lY[1]end;return"Engage Autopilot: "..lW(gu)end;local function nX(gu)local lY=cr.routeWP(true)if lY and#lY>0 then return"Next Route Point: "..lY[1]end;return"Disable Autopilot: "..lW(gu)end;local function nY()if iv()==1 then bX=not bX;if bX then b2=false;b0=false;b1=false;b4=false;b7=false;b5=false;b6=false;nZ=bl;bl=false;d.control.retractLandingGears()iw:setTargetGroundAltitude(X)fS("folOn","F")else fS("folOff","F")a_="Follow Off"cx=p;bl=nZ;if bl then d.control.deployLandingGears()iw:setTargetGroundAltitude(Y)end end else b_="Follow Mode only works with Remote controller"bX=false end end;local nM=50;local nN=260;local n_=j3(30)local o0=az+ay*2+2;local o1=aA+1;nx("+","+",n_,n_,o0,o1+n_+1,function()return false end,function()d3=d3/8 end,function()return bG=="SCOPE"end,nil,"ZoomButton")nx("-","-",n_,n_,o0,o1,function()return false end,function()d3=math.min(d3*8,90)end,function()return bG=="SCOPE"end,nil,"ZoomButton")nx("0","0",n_,n_,o0,o1+n_*2+2,function()return false end,function()d3=90 end,function()return bG=="SCOPE"and d3~=90 end,nil,"ZoomButton")local o2=nx("Enable Brake Toggle","Disable Brake Toggle",nN,nM,ch/2-nN/2,ci/2+350,function()return aY end,function()aY=not aY;if aY then b_="Brakes in Toggle Mode"else b_="Brakes in Default Mode"end end)nx("Align Prograde","Disable Prograde",nN,nM,ch/2-nN/2-50-o2.width,ci/2-nM+380,function()return b1 end,function()nR(1)end)nx("Align Retrograde","Disable Retrograde",nN,nM,ch/2-nN/2+o2.width+50,ci/2-nM+380,function()return b0 end,nR,function()return cd==0 end)o3=nx(nW,nX,600,60,ch/2-600/2,ci/2-60/2-330,function()return b2 or bp or c9 or by end,function()end)local K;local function o4(o5)local gu=c_+o5;if gu>#cS then gu=gu-#cS-1 end;if gu<0 then gu=#cS+gu end;return gu end;o6={}for K=0,10 do local o7=nx(function(eB)local gu=o4(eB.apExtraIndex)if b2 or bp or c9 or by then return"Redirect: "..lW(gu)end;return nW(gu)end,function(eB)local gu=o4(eB.apExtraIndex)return nX(gu)end,600,60,ch/2-600/2,ci/2-60/2-330+60*K,function(eB)local gu=o4(eB.apExtraIndex)return gu==bk and(b2 or bp or c9 or by)end,function(eB)local gu=o4(eB.apExtraIndex)local o8=bk==gu;bk=gu;cq.UpdateAutopilotTarget()cr.ToggleAutopilot()if not o8 and not(b2 or bp or c9 or by)then cr.ToggleAutopilot()end end,function()return cZ and(#cr.routeWP(true)==0 or K==0)end)o7.apExtraIndex=K;o6[K]=o7 end;nx("Save Position","Save Position",200,o3.height,o3.x+o3.width+30,o3.y,function()return false end,gv,function()return bk==0 or g3==nil end)nx("Update Position","Update Position",200,o3.height,o3.x+o3.width+30,o3.y,function()return false end,function()nT(nil)end,function()return bk>0 and g3~=nil end)nx("Save Heading","Clear Heading",200,o3.height,o3.x+o3.width+30,o3.y+o3.height+20,function()return g3.heading~=nil end,function()if g3.heading~=nil then nT(false)else nT(true)end end,function()return bk>0 and g3~=nil end)nx("Save AGG Alt","Clear AGG Alt",200,o3.height,o3.x+o3.width+30,o3.y+o3.height*2+40,function()return g3.agg~=nil end,function()if g3.agg~=nil then nT(nil,false)else nT(nil,true)end end,function()return bk>0 and g3~=nil and antigrav end)nx("Clear Position","Clear Position",200,o3.height,o3.x-200-30,o3.y,function()return true end,gq,function()return bk>0 and g3~=nil end)nx("Save Route","Save Route",200,o3.height,o3.x-200-30,o3.y+o3.height*2+40,function()return false end,function()cr.routeWP(false,false,2)end,function()return#cr.routeWP(true)>0 end)nx("Load Route","Clear Route",200,o3.height,o3.x-200-30,o3.y+o3.height+20,function()return#cr.routeWP(true)>0 end,function()if#cr.routeWP(true)>0 then cr.routeWP(false,true)elseif b2 or bp then b_="Disable Autopilot before loading route"return else cr.routeWP(false,false,1)end end,function()return true end)nM=60;nN=300;local ht=0;local hu=ci/2-150;nx("Enable Check Damage","Disable Check Damage",nN,nM,ht,hu-nM-20,function()return s end,function()s=not s end)nx("View Settings","View Settings",nN,nM,ht,hu,function()return true end,nJ)hu=hu+nM+20;nx("Enable Turn and Burn","Disable Turn and Burn",nN,nM,ht,hu,function()return b3 end,nQ)ht=10;hu=ci/2-300;nx("Horizontal Takeoff Mode","Vertical Takeoff Mode",nN,nM,ch/2-nN/2,hu+20,function()return aZ end,function()aZ=not aZ;if aZ then b_="Vertical Takeoff Mode"else b_="Horizontal Takeoff Mode"end end,function()return cN end)hu=hu+nM+20;nx("Engage Orbiting","Cancel Orbiting",nN,nM,ht+nN+20,hu,function()return by end,cr.ToggleIntoOrbit,function()return cd==0 and cW end)hu=ci/2-150;nx("Glide Re-Entry","Cancel Glide Re-Entry",nN,nM,ht+nN+20,hu,function()return b7 end,function()c8=1;nR(1)end,function()return kr.hasAtmosphere and not cc end)hu=hu+nM+20;nx("Parachute Re-Entry","Cancel Parachute Re-Entry",nN,nM,ht+nN+20,hu,function()return b7 end,function()c8=2;nR(1)end,function()return kr.hasAtmosphere and not cc end)hu=hu+nM+20;nx("Engage Follow Mode","Disable Follow Mode",nN,nM,ht,hu,function()return bX end,nY,function()return iv()==1 end)nx("Enable Repair Arrows","Disable Repair Arrows",nN,nM,ht+nN+20,hu,function()return j1 end,function()j1=not j1;if j1 then b_="Repair Arrows Enabled"else b_="Repair Arrows Diabled"end end,function()return iv()==1 end)hu=hu+nM+20;if not q then nx("Enable AGG","Disable AGG",nN,nM,ht,hu,function()return cO end,cr.ToggleAntigrav,function()return antigrav~=nil end)end;nx(function()return di("Switch IPH Mode - Current: %s",bz)end,function()return di("IPH Mode: %s",bz)end,nN*2,nM,ht,hu,function()return false end,function()if bz=="All"then bz="Custom Only"elseif bz=="Custom Only"then bz="No Moons"else bz="All"end;b_="IPH Mode: "..bz end)hu=hu+nM+20;nx(function()return di("Toggle Control Scheme - Current: %s",g)end,function()return di("Control Scheme: %s",g)end,nN*2,nM,ht,hu,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;b_="New Control Scheme: "..g end)local o9=j4(20)local o7=nt(0,0,j3(70),o9,"HELP")o7=nt(o7.x+o7.width,o7.y,j3(80),o9,"INFO")o7=nt(o7.x+o7.width,o7.y,j3(70),o9,"ORBIT")o7=nt(o7.x+o7.width,o7.y,j3(70),o9,"SCOPE")nt(o7.x+o7.width,o7.y,j3(70),o9,"HIDE")end;local oa={}local ob=nil;function oa.HUDPrologue(jP)if not cT then iT=ag;iU=ah;iV=ai else iT=ad;iU=ae;iV=af end;iW=[[rgb(]]..bJ(iT+0.6)..","..bJ(iU+0.6)..","..bJ(iV+0.6)..[[)]]iX=[[rgb(]]..bJ(iT*0.8+0.5)..","..bJ(iU*0.8+0.5)..","..bJ(iV*0.8+0.5)..[[)]]local oc=iW;local od=iX;local oe=[[rgb(]]..bJ(iT*0.4+0.5)..","..bJ(iU*0.4+0.5)..","..bJ(iV*0.4+0.5)..[[)]]local of=iW;local og=iX;local oh=oe;if j5()and not m then oc=[[rgb(]]..bJ(iT*0.5+0.5)..","..bJ(iU*0.5+0.5)..","..bJ(iV*0.5+0.5)..[[)]]od=[[rgb(]]..bJ(iT*0.3+0.5)..","..bJ(iU*0.3+0.5)..","..bJ(iV*0.2+0.5)..[[)]]oe=[[rgb(]]..bJ(iT*0.2+0.5)..","..bJ(iU*0.2+0.5)..","..bJ(iV*0.2+0.5)..[[)]]end;local lL=j3;local lM=j4;jP[#jP+1]=di([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],oc,oc,oc,of,of,od,od,og,og,od,oc,oe,og,oc,oc,oe,oe,oh,oe,ch,ci,od,od,od,od,od,of,od,og,oh,og,og,oh)if not ob then ob=di([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lL(630),lM(0),lL(675),lM(45),lL(960),lM(55),lL(1245),lM(45),lL(1290),lM(0),lL(1000),lM(105),lL(1040),lM(59),lL(1250),lM(51),lL(1300),lM(0),lL(1920),lM(0),lL(1920),lM(20),lL(1400),lM(20),lL(1300),lM(105),lL(920),lM(105),lL(880),lM(59),lL(670),lM(51),lL(620),lM(0),lL(0),lM(0),lL(0),lM(20),lL(520),lM(20),lL(620),lM(105),lL(890),lM(59),lL(960),lM(62),lL(1030),lM(59),lL(985),lM(112),lL(1150),lM(112),lL(1100),lM(152),lL(820),lM(152),lL(780),lM(112),lL(935),lM(112),lL(890),lM(59),lL(960),lM(62),lL(1030),lM(59),lL(985),lM(112),lL(1150),lM(112),lL(1100),lM(152),lL(820),lM(152),lL(780),lM(112),lL(935),lM(112))end;if w and I then jP[#jP+1]=ob end;return jP end;function oa.DrawVerticalSpeed(jP,e1)jO(jP,e1)end;function oa.UpdateHud(jP)local kE=cQ;local oi=cR;local jW=oi;local kb=kE;local kW=bJ(c.getThrottle())local l0=cJ*3.6;local kX=c.getAxisCommandValue(0)local oj=j3(1770)local ok=j4(310)if t and cP then kX=bN;kW=bN*100 end;local j7=j6()local jX="ROLL"if kW==nil then kW=0 end;if not cW then if cJ>5 then kE=kD(cH)oi=kF(cH)else kE=0;oi=0 end;jX="YAW"end;if cU>50000 and not cc then local ol;ol=iA(cU)jP[#jP+1]=gM(oj,ok,"PvP Boundary: "..ol,"pbright txtbig txtmid")end;jP[#jP+1]=i_;jP[#jP+1]=i6;if iO~=""then jP[#jP+1]=iO end;if j8~=""then jP[#jP+1]=j8 end;if j9~=""then jP[#jP+1]=j9 end;jO(jP,ce)if iv()==0 or l then if not j5()or m then if cW then jV(jP,aj,ak,jW,jX,cW)ka(jP,kb,jW,aj,ak,cW,bJ(kF(cH)),cJ)else jV(jP,aj,ak,oi,jX,cW)ka(jP,kE,oi,aj,ak,cW,bJ(oi),cJ)end;kh(jP,ce,cW)kG(jP,cH,cJ,aj,ak)end end;kV(jP,j7,kW,kX)k_(jP,l0)l3(jP)m4(jP)if not iM and bY then lX(jP)end;return jP end;function oa.HUDEpilogue(jP)jP[#jP+1]="</svg>"return jP end;function oa.ExtraData(jP)local om=j3(1240)local on=j4(55)local oo=on+10;local op;local lL=j3;local lM=j4;local oq=0;local j7=j6()if aZ then j7=j7 .."-VERTICAL"end;if E and not b6 and not b5 and cJ>20 then j7=j7 .."-COLLISION ON"end;if bB~="Off"then j7="("..bB..")-"..j7 end;if b3 then j7="TB-"..j7 end;if not bA then j7=j7 .."-DeCoupled"end;local os=lM(99)local ot=lM(80)local ou=lM(85)local ov=lM(31)local ow=0;local ox=0;local oy=cf>1000000 and fT(cf/1000000,2).."kT"or fT(cf/1000,2).."T"if cc then oq=bt else oq=br end;local oz,oA=cn.computeDistanceAndTime(cJ,0,cf,0,0,oq)if oz<0 then oz=0 end;oq=fT(oq/(cf*iE),2).."g"local oB=d:maxForceForward()op=b.getGravityIntensity()if op>0.1 then ox=cf*op;ox=fT(ox/(cf*iE),2).."g"ow=0.5*oB/op;ow=ow>1000000 and fT(ow/1000000,2).."kT"or fT(ow/1000,2).."T"end;oB=fT(oB/(cf*iE),2).."g"local oC=vec3(bL.getWorldAcceleration()):len()/9.80665;op=b.getGravityIntensity()jP[#jP+1]=[[<g class="dim txt txtend size14">]]if iv()==1 and not l then om=j3(1120)on=j4(55)oo=on+10 elseif cc and I then local oD=j3(770)jP[#jP+1]=gM(lL(895),os,"ATMO","")jP[#jP+1]=di([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lL(895),ou,lL(-80))jP[#jP+1]=gM(lL(815),ot,di("%.1f%%",cd*100),"txtstart size20")end;if I then jP[#jP+1]=gM(lL(1025),os,"GRAVITY","txtstart")jP[#jP+1]=di([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lL(1025),ou,lL(80))jP[#jP+1]=gM(lL(1105),ot,di("%.2fg",op/9.80665),"size20")jP[#jP+1]=gM(lL(1125),os,"ACCEL","txtstart")jP[#jP+1]=di([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lL(1125),ou,lL(80))jP[#jP+1]=gM(lL(1205),ot,di("%.2fg",oC),"size20")jP[#jP+1]=gM(lL(695),os,"BRK TIME","")jP[#jP+1]=di([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lL(695),ou,lL(-80))jP[#jP+1]=gM(lL(615),ot,di("%s",iB(oA)),"txtstart size20")jP[#jP+1]=gM(lL(635),lM(45),"TRIP","")jP[#jP+1]=di([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lL(635),lM(31),lL(-90))if lF then jP[#jP+1]=gM(lL(545),lM(26),di("%s",iB(lF)),"txtstart size20")end;jP[#jP+1]=gM(lL(795),os,"BRK DIST","")jP[#jP+1]=di([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lL(795),ou,lL(-80))jP[#jP+1]=gM(lL(715),ot,di("%s",iA(oz)),"txtstart size20")jP[#jP+1]=gM(lL(1285),lM(45),"MASS","txtstart")jP[#jP+1]=di([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lL(1285),lM(31),lL(90))jP[#jP+1]=gM(lL(1375),lM(26),di("%s",oy),"size20")jP[#jP+1]=gM(lL(1220),os,"THRUST","txtstart")jP[#jP+1]=di([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lL(1220),ou,lL(80))jP[#jP+1]=gM(lL(1300),ot,di("%s",oB),"size20")jP[#jP+1]=gM(j3(960),j4(175),j7,"pbright txtbig txtmid size20")end;jP[#jP+1]="</g>"end;local oE=1-(a4*0.05+a5*0.05)function oa.FuelUsed(oF)local oG;if oF=="atmofueltank"then oG=di("Atmo Fuel Used: %.1f L",jq[oF]/(4*oE))elseif oF=="spacefueltank"then oG=di("Space Fuel Used: %.1f L",jq[oF]/(6*oE))else oG=di("Rocket Fuel Used: %.1f L",jq[oF]/(0.8*oE))end;return oG end;local oH,oI,oJ,oK,oL=0,0,0,{},0;function oa.DrawOdometer(jP,iY,bm,iZ)if bG~="INFO"then return jP end;local op;local ow=0;local ox=0;local oq=0;local oy=cf>1000000 and fT(cf/1000000,2).." kTons"or fT(cf/1000,2).." Tons"if cc then oq=bt else oq=br end;local oz,oA=cn.computeDistanceAndTime(cJ,0,cf,0,0,oq)oq=fT(oq/(cf*iE),2).." g"local oB=d:maxForceForward()op=b.getGravityIntensity()if op>0.1 then ox=cf*op;ox=fT(ox/(cf*iE),2).." g"ow=0.5*oB/op;ow=ow>1000000 and fT(ow/1000000,2).." kTons"or fT(ow/1000,2).." Tons"end;oB=fT(oB/(cf*iE),2).." g"if iv()==0 or l then local oM=j3(az+10)local oN=j4(aA+20)local oO=j3(az+10+ay/1.25)local nv=25;local oP=bJ(1/aS)if oJ<oP then oL=oL+a.getActionUpdateDeltaTime()oJ=oJ+1 else oH=1/(oL/oP)table.insert(oK,oH)oJ,oL=0,0 end;oI=0;for dJ,dv in pairs(oK)do oI=oI+dv end;if#oK>0 then oI=bJ(oI/#oK)end;if#oK>29 then table.remove(oK,1)end;jP[#jP+1]="<g class='txtstart size14 bright'>"jP[#jP+1]=gM(oM,oN,di("BrkTime: %s",iB(oA)))jP[#jP+1]=gM(oO,oN,di("Trip: %.2f km",iY))jP[#jP+1]=gM(oM,oN+nv,di("Lifetime: %.2f kSU",bm/200000))jP[#jP+1]=gM(oO,oN+nv,di("BrkDist: %s",iA(oz)))jP[#jP+1]=gM(oM,oN+nv*2,"Trip Time: "..iB(iZ))jP[#jP+1]=gM(oO,oN+nv*2,"Total Time: "..iB(bn))jP[#jP+1]=gM(oM,oN+nv*3,di("Mass: %s",oy))jP[#jP+1]=gM(oO,oN+nv*3,di("Max Brake: %s",oq))jP[#jP+1]=gM(oM,oN+nv*4,di("Max Thrust: %s",oB))if op>0.1 then jP[#jP+1]=gM(oO,oN+nv*4,di("Max Thrust Mass: %s",ow))jP[#jP+1]=gM(oM,oN+nv*5,di("Req Thrust: %s",ox))else jP[#jP+1]=gM(oO,oN+nv*4,"Max Mass: n/a")jP[#jP+1]=gM(oM,oN+nv*5,"Req Thrust: n/a")end;jP[#jP+1]=gM(oO,oN+nv*5,cp.FuelUsed("atmofueltank"))jP[#jP+1]=gM(oM,oN+nv*6,cp.FuelUsed("spacefueltank"))jP[#jP+1]=gM(oO,oN+nv*6,cp.FuelUsed("rocketfueltank"))jP[#jP+1]=gM(oM,oN+nv*7,di("Set Max Speed: %s",bJ(a9*3.6+0.5)))jP[#jP+1]=gM(oO,oN+nv*7,di("Actual Max Speed: %s",bJ(dd*3.6+0.5)))jP[#jP+1]=gM(oM,oN+nv*8,di("Friction Burn Speed: %s",bJ(bL.getFrictionBurnSpeed()*3.6)))jP[#jP+1]=gM(oO,oN+nv*8,di("FPS (Avg): %s (%s)",bJ(oH),oI))end;jP[#jP+1]="</g></g>"return jP end;function oa.DrawWarnings(jP)return l3(jP)end;function oa.DisplayOrbitScreen(jP)return m4(jP)end;function oa.DisplayMessage(jP,lq)if lq~="empty"then local hu=310;for lz in string.gmatch(lq,"([^\n]+)")do hu=hu+35;jP[#jP+1]=gM("50%",hu,lz,"msg")end end;if c0~=0 then c.setTimer("msgTick",c0)c0=0 end end;function oa.DrawDeadZone(jP)jP[#jP+1]=di([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],ax)end;function oa.UpdatePipe()if cc then iO=""return end;nk()end;function oa.DrawSettings(jP)local ht=j3(640)local hu=j4(200)jP[#jP+1]=[[<g class="pbright txtvspd txtstart">]]local hP=0;for dJ,dv in pairs(iN)do hP=hP+1;jP[#jP+1]=gM(ht,hu,dJ..": "..dv.get())hu=hu+20;if hP%12==0 then ht=ht+j3(350)hu=j4(200)end end;jP[#jP+1]=gM(j3(640),j4(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jP[#jP+1]="</g>"return jP end;local i5=j4(125)local i4=j3(1225)function oa.DrawRadarInfo()i6=cs.GetRadarHud(i4,i5,av,aw)end;function oa.DrawTanks()if ar~=0 and as~=0 then j8=gM(ar,as,"","txtstart pdim txtfuel")jr=as;js(ar,"Atmospheric ","ATMO",cj,jo,jp)js(ar,"Space Fuel T","SPACE",ck,jm,jn)js(ar,"Rocket Fuel ","ROCKET",cl,jk,jl)end end;function oa.DrawShield()local id=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oQ=bL.getPvPTimer()local oR=shield.getResistances()local oS="A: "..10+oR[1]*100 .."% / E: "..10+oR[2]*100 .."% / K:"..10+oR[3]*100 .."% / T: "..10+oR[4]*100 .."%"local ht,hu=at-60,au+30;local jH=bJ(de*2.55)local jI=di("rgb(%d,%d,%d)",255-jH,jH,0)local jJ=""j9=gM(ht,hu,"","txtmid pdim txtfuel")if de<10 and id~="Shield Disabled"then jJ="red "end;oQ=oQ>0 and"   PvPTime: "..iB(oQ)or""j9=j9 ..di([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],ht,hu,jI,de*2,ht,hu,ht+2,hu+10,de,oQ)j9=j9 ..gM(ht,hu-5,id,jJ.."txtstart pbright txtbig")j9=j9 ..gM(ht,hu+30,oS,jJ.."txtstart pbright txtsmall")end;function oa.hudtick()if not kr then return end;local function oT(jP)local jL=bJ(dj(db/(ch/4)*255,0,255))jP[#jP+1]=di("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c5,c6,bJ(iT+0.5)+jL,bJ(iU+0.5)-jL,bJ(iV+0.5)-jL)end;local function oU()if bZ then for dO,dv in pairs(iF)do if dv.hovered then if not dv.drawCondition or dv.drawCondition(dv)then dv.toggleFunction(dv)end;dv.hovered=false end end;for dO,dv in pairs(iI)do if dv.hovered then bG=dv.label;dv.hovered=false end end;bZ=false end end;local function oV()local function oW(oX,oY,ht,hu,nu,nv)if oX>=ht and oX<=ht+nu and oY>=hu and oY<=hu+nv then return true else return false end end;local ht=c5+ch/2;local hu=c6+ci/2;for dO,dv in pairs(iF)do dv.hovered=oW(ht,hu,dv.x,dv.y,dv.width,dv.height)end;for dO,dv in pairs(iI)do dv.hovered=oW(ht,hu,dv.x,dv.y,dv.width,dv.height)end;if cZ then local n9=false;for dO,eB in ipairs(o6)do if eB.hovered then n9=true;break end end;if o3.hovered then n9=true end;cZ=n9 else cZ=o3.hovered;if not cZ then c_=bk end end end;local function oZ(jP)if not bG or bG==""then bG="HELP"end;if w then for dJ,dv in pairs(iI)do local jJ="dim brightstroke"local o_=0.2;if bG==dJ then jJ="pbright dimstroke"o_=0.6 end;local p0=""if dv.hovered then o_=0.8;p0=";stroke:white"end;jP[#jP+1]=di([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dv.width,dv.height,dv.x,dv.y,jJ,o_,p0)jP[#jP+1]=gM(dv.x+dv.width/2,dv.y+dv.height/2+5,dv.label,"txt txtmid pdim")end end end;local function p1(jP)local function p2(jP,p3,hover,ht,hu,fg,p4,p5,p6,p7,p8,o7)if type(p7)=="function"then p7=p7(o7)end;if type(p8)=="function"then p8=p8(o7)end;jP[#jP+1]=di("<rect x='%f' y='%f' width='%f' height='%f' fill='",ht,hu,fg,p4)if p3 then jP[#jP+1]=di("%s'",p5)else jP[#jP+1]=p6 end;if hover then jP[#jP+1]=di(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ad,ae,af)else jP[#jP+1]=di(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fT(ad*0.5,0),fT(ae*0.5,0),fT(af*0.5,0))end;jP[#jP+1]=" rx='5'></rect>"jP[#jP+1]=di("<text x='%f' y='%f' font-size='24' fill='",ht+fg/2,hu+p4/2+5)if p3 then jP[#jP+1]="black"else jP[#jP+1]="white"end;jP[#jP+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if p3 then jP[#jP+1]=di("%s</text>",p7)else jP[#jP+1]=di("%s</text>",p8)end end;local p9=di("rgb(%d,%d,%d)'",fT(ad*0.1,0),fT(ae*0.1,0),fT(af*0.1,0))local pa=di("rgb(%d,%d,%d)",fT(ad*0.8,0),fT(ae*0.8,0),fT(af*0.8,0))local pb=p2;for dO,dv in pairs(iF)do local nz=dv.disableName;local ny=dv.enableName;if type(nz)=="function"then nz=nz(dv)end;if type(ny)=="function"then ny=ny(dv)end;if not dv.drawCondition or dv.drawCondition(dv)then pb(jP,dv.toggleVar(dv),dv.hovered,dv.x,dv.y,dv.width,dv.height,pa,p9,nz,ny,dv)end end end;local pc=fT(ch/2,0)local pd=fT(ci/2,0)local jP={}if pe then jP[#jP+1]=pe end;cp.HUDPrologue(jP)if w then cp.UpdateHud(jP)else if A then cp.DrawVerticalSpeed(jP,ce)end;cp.DrawWarnings(jP)end;if iM and iN~="none"then cp.DrawSettings(jP)end;if cs then cp.DrawRadarInfo()end;cp.HUDEpilogue(jP)jP[#jP+1]=di([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ch,ci)if b_~="empty"then cp.DisplayMessage(jP,b_)end;if iv()==0 and g=="virtual joystick"then if v then cp.DrawDeadZone(jP)end end;oZ(jP)if ix()==0 then if iv()==1 and bY then if not pf then oV()p1(jP)end;if not cv and not cw then local pg=table.concat(jP,"")jP={}jP[#jP+1]=di("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ch,ci)jP[#jP+1]=pg;jP[#jP+1]="</body>"cv=true;jP[#jP+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cw then local pg=table.concat(jP,"")jP={}jP[#jP+1]=di("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ch,ci)jP[#jP+1]=pg;jP[#jP+1]="</body>"end;if not cv then jP[#jP+1]=di([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],pc,pd,c5,c6)end else oU()end else if not bY and iv()==0 then oU()if db>ax then if v then oT(jP)end end elseif bY and(not pf or not i)then oV()p1(jP)end;jP[#jP+1]=di([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],pc,pd,c5,c6)end;jP[#jP+1]=[[</svg></body>]]ph=table.concat(jP,"")end;function oa.TenthTick()local function pi()local pj=a.createData;local pk=a.createWidget;pl=a.createWidgetPanel("Interplanetary Helper")pm=pk(pl,"value")pn=pj('{"label": "Target Planet", "value": "N/A", "unit":""}')fR(pn,pm)po=pk(pl,"value")pp=pj('{"label": "distance", "value": "N/A", "unit":""}')fR(pp,po)gk=pk(pl,"value")gj=pj('{"label": "Travel Time", "value": "N/A", "unit":""}')fR(gj,gk)gi=pk(pl,"value")gh=pj('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fR(gh,gi)gm=pk(pl,"value")gl=pj('{"label": "Target Altitude", "value": "N/A", "unit":""}')fR(gl,gm)ge=pk(pl,"value")gd=pj('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gc=pk(pl,"value")gb=pj('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')ga=pk(pl,"value")g9=pj('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g8=pk(pl,"value")g7=pj('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gg=pk(pl,"value")gf=pj('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cc then fR(gd,ge)fR(gb,gc)fR(g9,ga)fR(g7,g8)fR(gf,gg)end end;local function pq()gL(pl)pl=nil end;cp.DrawTanks()if shield then cp.DrawShield()end;if bi~="None"then if pl==nil then pi()end;if bi~=nil then local mL;local pr=g3~=nil;local ps=0.5*bt/c4:getGravity(c4.center+vec3(0,0,1)*c4.radius):len()ps=ps>1000000 and fT(ps/1000000,2).." kTons"or fT(ps/1000,2).." Tons"fQ(pn,'{"label": "Target", "value": "'..bi..'", "unit":""}')if pr and not b2 then mL=(cM-g3.position):len()else mL=(bj-cM):len()end;if not b3 then c2,c3=cr.GetAutopilotBrakeDistanceAndTime(cJ)iQ,iR=cr.GetAutopilotBrakeDistanceAndTime(a9)else c2,c3=cr.GetAutopilotTBBrakeDistanceAndTime(cJ)iQ,iR=cr.GetAutopilotTBBrakeDistanceAndTime(a9)end;local lq=iA(mL)fQ(pp,'{"label": "distance", "value": "'..lq..'"}')fQ(gj,'{"label": "Travel Time", "value": "'..iB(lF)..'", "unit":""}')lq=iA(c2)fQ(gd,'{"label": "Cur Brake distance", "value": "'..lq..'"}')fQ(gb,'{"label": "Cur Brake Time", "value": "'..iB(c3)..'", "unit":""}')lq=iA(iQ)fQ(g9,'{"label": "Max Brake distance", "value": "'..lq..'"}')fQ(g7,'{"label": "Max Brake Time", "value": "'..iB(iR)..'", "unit":""}')fQ(gh,'{"label": "Max Brake Mass", "value": "'..di("%s",ps)..'", "unit":""}')lq=iA(gn)fQ(gl,'{"label": "Target Orbit", "value": "'..lq..'"}')if cc and not pt then a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)a.removeDataFromWidget(gf,gg)pt=true;if not cP and t and(b4 or b7 or ca)then cr.cmdThrottle(1)a_=false;bR=false end end;if not cc and pt then if fQ(g7,g8)==1 then fR(g7,g8)end;if fQ(g9,ga)==1 then fR(g9,ga)end;if fQ(gb,gc)==1 then fR(gb,gc)end;if fQ(gd,ge)==1 then fR(gd,ge)end;if fQ(gf,gg)==1 then fR(gf,gg)end;pt=false end end else pq()end;if warpdrive~=nil then local pu=it(warpdrive.getWidgetData())if pu.destination~="Unknown"and pu.distance>400000 then if not j2 then warpdrive.showWidget()j2=true end elseif j2 then warpdrive.hideWidget()j2=false end end end;function oa.OneSecondTick()local function pv()local jC=bI()local l0=cJ;local pw=jC-j0;if l0>1.38889 then l0=l0/1000;local px=l0*(jC-j0)bm=bm+px;iY=iY+px end;iZ=iZ+pw;bn=bn+pw;j0=jC end;local function py(jP)local pz=0;local pA=iD;local pB=0;local pC=0;local pD=0;local jH=0;local jI=""local pE=b.getElementHitPointsById;local pF=b.getElementMaxHitPointsById;local pG={}for dJ in pairs(iC)do local pH=0;local pI=0;pI=pF(iC[dJ])pH=pE(iC[dJ])pB=pB+pH;if pH+1<pI then if pH==0 then pD=pD+1 else pC=pC+1 end;if j1 and#pG==0 then fV=vec3(b.getElementPositionById(iC[dJ]))local ht=fV.x;local hu=fV.y;local hv=fV.z;table.insert(pG,b.spawnArrowSticker(ht,hu,hv+1,"down"))table.insert(pG,b.spawnArrowSticker(ht,hu,hv+1,"down"))b.rotateSticker(pG[2],0,0,90)table.insert(pG,b.spawnArrowSticker(ht+1,hu,hv,"north"))table.insert(pG,b.spawnArrowSticker(ht+1,hu,hv,"north"))b.rotateSticker(pG[4],90,90,0)table.insert(pG,b.spawnArrowSticker(ht-1,hu,hv,"south"))table.insert(pG,b.spawnArrowSticker(ht-1,hu,hv,"south"))b.rotateSticker(pG[6],90,-90,0)table.insert(pG,b.spawnArrowSticker(ht,hu-1,hv,"east"))table.insert(pG,b.spawnArrowSticker(ht,hu-1,hv,"east"))b.rotateSticker(pG[8],90,0,90)table.insert(pG,b.spawnArrowSticker(ht,hu+1,hv,"west"))table.insert(pG,b.spawnArrowSticker(ht,hu+1,hv,"west"))b.rotateSticker(pG[10],-90,0,90)table.insert(pG,iC[dJ])end elseif j1 and#pG>0 and pG[11]==iC[dJ]then for jB in pairs(pG)do b.deleteSticker(pG[jB])end;pG={}end end;pz=fT(pB/pA*100,2)if pD>0 or pC>0 then jP[#jP+1]=gM(0,0,"","pbright txt")jH=bJ(pz*2.55)jI=di("rgb(%d,%d,%d)",255-jH,jH,0)jP[#jP+1]=gM("50%",1035,"Elemental Integrity: "..pz.."%","txtbig txtmid","fill:"..jI)if pD>0 then jP[#jP+1]=gM("50%",1055,"Disabled Modules: "..pD.." Damaged Modules: "..pC,"txtbig txtmid","fill:"..jI)elseif pC>0 then jP[#jP+1]=gM("50%",1055,"Damaged Modules: "..pC,"txtbig txtmid","fill:"..jI)end end end;local function pJ()if is then if iS==nil and(d6~=nil or bl)then _autoconf.displayCategoryPanel(is,weapon_size,"Weapons","weapon",true)iS=_autoconf.panels[_autoconf.panels_size]elseif iS~=nil and d6==nil and not bl then gL(iS)iS=nil end end end;d0=bL.getPlayersOnBoard()d1=bL.getDockedConstructs()local jP={}pv()if s then py(jP)end;pJ()cp.UpdatePipe()cp.ExtraData(jP)i_=table.concat(jP,"")end;function oa.AnimateTick()cw=true;cv=false;c5=0;c6=0;c.stopTimer("animateTick")end;function oa.MsgTick()local jP={}cp.DisplayMessage(jP,"empty")b_="empty"c.stopTimer("msgTick")c0=3 end;function oa.ButtonSetup()nK()nP()iF=iG end;if pK then for dJ,dv in pairs(pK)do oa[dJ]=dv end end;return oa end;local function pL(d,b,c,e,vBooster,hover,pM,antigrav,warpdrive,dbHud_1,eX,bJ,bK,iv,eS,bI,dj,iw,fQ,ix,dl,fT,fS,iy,dm,iA,iB,pN,it,di,fR)local a=DUSystem;local bL=DUConstruct;local pO={}local pP=false;local pQ=0;local pR=0;local pS=0;local pT=bI()local pU=0;local pV=0;local pW=0;local pX=0;local pY=false;local pZ=false;local p_=false;local q0=nil;local q1=0;local iP=55;local q2=nil;local q3=false;local q4=false;local q5=false;local q6=0;local q7=0;local q8=0;local q9=0;local qa=0;local qb={VectorToTarget=false}local qc=vec3(bL.getWorldOrientationUp())local qd=nil;local qe=0;local qf=-1;local qg=-1;local qh=false;local qi=false;local qj=0;local qk=false;local ql=false;local qm=false;local qn=false;local qo=""local qp=false;local qq=false;local qr=""local qs=false;local qt=0;local function qu()return bL.isInPvPZone()~=1,eX(bL.getDistanceToSafeZone())end;local function qv(fn)local qw=be;if not b2 then qw=0 end;local qx=br;if cc then if bt and bt>0 then qx=bt else return 0,0 end end;return cn.computeDistanceAndTime(fn,qw,cf,0,0,qx-bg*cf)end;local function qy(fn)local qw=be;if not b2 then qw=0 end;return cn.computeDistanceAndTime(fn,qw,cf,d:maxForceForward(),a0,br-bg*cf)end;local function qz(qA,qB,qC)qB=qB:project_on_plane(qA)qC=qC:project_on_plane(qA)return eS(qB:cross(qC):dot(qA),qB:dot(qC))end;local function qD()local function qE()local qF=-1;local qG=-1;if vBooster then qF=vBooster.getDistance()end;if hover then qG=hover.getDistance()end;if qF~=-1 and qG~=-1 then if qF<qG then return qF else return qG end elseif qF~=-1 then return qF elseif qG~=-1 then return qG else return-1 end end;local qH=qE()local qI=-1;if antigrav and antigrav.isActive()==1 and not q and cJ<iP then local qJ=eX(ce-antigrav.getBaseAltitude())if qJ<50 then return qJ end end;if pM then qI=pM.raycast().distance end;if qH~=-1 and qI~=-1 then if qH<qI then return qH else return qI end elseif qH~=-1 then return qH else return qI end end;local function qK(kr,eJ,qL)local function qM(qN,dV)local eP=vec3(dV)if qN.id==0 then return setmetatable({latitude=eP.x,longitude=eP.y,altitude=eP.z,id=0,systemId=qN.systemId},dX)end;local eQ=eP-qN.center;local c7=eQ:len()local e1=c7-qN.radius;local d_=0;local e0=0;if not dm(c7,0)then local eR=eS(eQ.y,eQ.x)e0=eR>=0 and eR or 2*math.pi+eR;d_=math.pi/2-math.acos(eQ.z/c7)end;return setmetatable({latitude=math.deg(d_),longitude=math.deg(e0),altitude=e1,id=qN.id,systemId=qN.systemId},dX)end;local qO=qM(kr,eJ)qO="::pos{"..qO.systemId..","..qO.id..","..qO.latitude..","..qO.longitude..","..qO.altitude.."}"if qL then return qO else qm=qO;return true end end;local function qP(qQ,qR,qS)local function qT(qQ,es)qQ=vec3(qQ)es=vec3(es):normalize()local dE=qQ*es;return dE.x+dE.y+dE.z end;local qU=0.001;local qV=1;if not cc or not cy or cb~=-1 or cJ<iP then if qS==nil then qS=aR end;if qR==nil then qR=qU end;qQ=vec3(qQ):normalize()local qW=vec3()-qQ;local qX=-qT(qW,bL.getWorldOrientationRight())*qV;local qY=-qT(qW,bL.getWorldOrientationUp())*qV;if pR==0 then pR=qX/2 end;if pS==0 then pS=qY/2 end;if eX(qX)<0.1 then q7=q7-qX*2 else q7=q7-(qX+(qX-pR)*qS)end;if eX(qY)<0.1 then q6=q6+qY*2 else q6=q6+qY+(qY-pS)*qS end;pR=qX;pS=qY;if eX(qX)<qR and eX(qY)<qR then return true end;return false elseif cy and cb==-1 then qQ=cI;if qS==nil then qS=aR end;if qR==nil then qR=qU end;qQ=vec3(qQ):normalize()local qW=cF-qQ;local qX=-qT(qW,bL.getWorldOrientationRight())*qV;local qY=-qT(qW,bL.getWorldOrientationUp())*qV;if pR==0 then pR=qX/2 end;if pS==0 then pS=qY/2 end;if eX(qX)<0.1 then q7=q7-qX*5 else q7=q7-(qX+(qX-pR)*qS)end;if eX(qY)<0.1 then q6=q6+qY*5 else q6=q6+qY+(qY-pS)*qS end;pR=qX;pS=qY;if eX(qX)<qR and eX(qY)<qR then return true end;return false end end;function pO.clearAll()ba=false;bc=false;bd=false;b2=false;bb=false;bf="Aligning"b0=false;b1=false;cV=nil;b4=false;b7=false;b5=false;b6=false;b8=false;bX=false;q4=false;c8=false;c9=false;q5=false;cx=p;bp=false;b3=false;cg=false;bs=nil;by=false;d9=false;da=nil end;function pO.GetAutopilotBrakeDistanceAndTime(fn)return qv(fn)end;function pO.GetAutopilotTBBrakeDistanceAndTime(fn)return qy(fn)end;function pO.showWayPoint(kr,eJ,qL)return qK(kr,eJ,qL)end;function pO.APTick()local qZ=a.getMouseWheel()if qZ>0 then cr.changeSpd()elseif qZ<0 then cr.changeSpd(true)else q3=true end;qj=ix()if qm then a.setWaypoint(qm)qm=false end;if qp then antigrav.setTargetAltitude(qp)qp=false end;if qn then fQ(qn,qo)qn=false;qo=""end;if qg~=-1 then cr.cmdCruise(qg,qh)qh=false;qg=-1 end;if qd~=nil then if iw:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iw:getTargetSpeed(axisCommandId.longitudinal)~=qd then iw:setTargetSpeedCommand(axisCommandId.longitudinal,qd)else qd=nil end end;if qf~=-1 then cr.cmdThrottle(qf,qh)qh=false;qf=-1 end;if qi then ct.landingGear()qi=false end;if qq then cr.ToggleAutopilot()end end;function pO.ToggleIntoOrbit()cC=false;pW=nil;pX=nil;q1=0;if not cc then if by then fS("orOff","AP")by=false;pY=false;q0=nil;cx=p;if b4 then b4=false;b6=false end;qb.VectorToTarget=false;qb.AutopilotAlign=false;p_=false elseif cW then fS("orOn","AP")by=true;cx=true;if q0==nil then q0=kr end;if b4 then b4=false;b6=false end else b_="Unable to engage auto-orbit, not near a planet"end else by=false;pY=false;q0=nil;cx=p;if b4 then b4=false end;qb.VectorToTarget=false;qb.AutopilotAlign=false;p_=false end end;function pO.ToggleVerticalTakeoff()b4=false;if b8 then ly=true;b7=false;b6=false;b5=true;cx=true;bW=0;if cc and cb==-1 then b5=false;b4=true;bW=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qg=bJ(cz)end else cC=false;bl=false;d.control.retractLandingGears()iw:setTargetGroundAltitude(X)a_="VTO Takeoff"end;b8=not b8 end;function pO.checkLOS(qQ)local lD,eH,eI=cm:getPlanetarySystem(0):castIntersections(cM,qQ,function(eq)if eq.noAtmosphericDensityAltitude>0 then return eq.radius+eq.noAtmosphericDensityAltitude else return eq.radius+eq.surfaceMaxAltitude*1.5 end end)local lE=eH;if eI~=nil and eH~=nil then lE=math.min(eI,eH)end;if lE~=nil then return lD,lE else return nil,nil end end;function pO.ToggleAutopilot()local function q_(bw)cX=false;bp=not bp;if bp then b3=false;if not b4 and not bw then cr.ToggleAltitudeHold()end end;lH="Proceeding to Waypoint"end;local function r0(gw)if gw then for K,dJ in pairs(cS)do if dJ.name and dJ.name==gw then return K end end else return 0 end end;local r1=false;if bM-pV<1.5 and cc then if not cE then if cc then b9=kr.spaceEngineMinAltitude-0.01*kr.noAtmosphericDensityAltitude;fS("11","EP")pV=-1;if b2 or bp or by then return end else b_="No space engines detected, Orbital Hop not supported"return end elseif kr.hasAtmosphere then if cc then b9=kr.noAtmosphericDensityAltitude+T;fS("orH","OH")end;pV=-1;if b2 or bp or by then return end end else pV=bM end;r2=false;if(bk>0 or#bE>0)and not b2 and not bp and not c9 and not by then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cf then b_="WARNING: Heavy Loads may affect autopilot performance."c0=5 end;if#bE>0 and not ca then bk=r0(bE[1])cq.UpdateAutopilotTarget()b_="Route Autopilot in Progress"local qW=g3.position-cM;local r3=qW:project_on_plane(cK):len()if r3>50000 and g3.planetname==kr.name then r1=true end end;cq.UpdateAutopilotTarget()cr.showWayPoint(c4,bj)if g3~=nil then if g3.agg and not q and antigrav then if not cO then cr.ToggleAntigrav()end;bu=g3.agg end;bs=nil;bw=g3.planetname=="Space"if bw then fS("apSpc","AP")if cc then c9=true;cr.ToggleAltitudeHold()else b2=true end elseif kr.name==g3.planetname then ly=true;if cc then if not bp then fS("vtt","AP")q_(bw)if r1 then b9=kr.noAtmosphericDensityAltitude+T end end else fS("apOn","AP")if not(c4.name==kr.name and ce<gn*1.5)then cC=false;b2=true elseif not cc then if by then cr.ToggleIntoOrbit()end;cB=kr.noAtmosphericDensityAltitude+T;p_=true;qb.AutopilotAlign=true;qb.VectorToTarget=true;pY=false;if not by then cr.ToggleIntoOrbit()end end end else fS("apP","AP")b0=false;b1=false;if cc then c9=true;cr.ToggleAltitudeHold()else b2=true end end elseif not cc then if g3==nil and(c4.name==kr.name and cW)and not by then r4=false;cC=false;pY=false;cr.ToggleIntoOrbit()else fS("apP","AP")b2=true;b0=false;b1=false;bb=false;bX=false;b4=false;b5=false;b7=false;b6=false;q4=false;bs=nil;r4=false end else fS("apP","AP")c9=true;cr.ToggleAltitudeHold()end;qq=false else fS("apOff","AP")cr.ResetAutopilots(1)if qq==2 then qq=true end end end;function pO.routeWP(r5,r6,r7)if r7 then if r7==1 then bE={}bE=iy(bE,bD)if#bE>0 then b_="Route Loaded"else b_="No Saved Route found on Databank"end;return bE else bD={}bD=iy(bD,bE)b_="Route Saved"pN()return end end;if r5 then return bE end;if r6 then bE={}b_="Current Route Cleared"else bE[#bE+1]=g3.name;b_="Added "..g3.name.." to route. "end;return bE end;function pO.cmdThrottle(dK,r8)if iw:getAxisCommandType(0)~=axisCommandType.byThrottle and not r8 then d.control.cancelCurrentControlMasterMode()end;iw:setThrottleCommand(axisCommandId.longitudinal,dK)bN=dj(fT(dK*100,0)/100,-1,1)qd=nil end;function pO.cmdCruise(dK,r8)if iw:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r8 then d.control.cancelCurrentControlMasterMode()end;iw:setTargetSpeedCommand(axisCommandId.longitudinal,dK)qd=dK end;function pO.ToggleLockPitch()if bs==nil then fS("lkPOn","LP")if not bY then bs=cQ else bs=Q end;b6=false;b4=false;b5=false else fS("lkPOff","LP")bs=nil end end;function pO.ToggleAltitudeHold()if bM-pU<1.5 then if kr.hasAtmosphere then if cc then b9=kr.spaceEngineMinAltitude-0.01*kr.noAtmosphericDensityAltitude;fS("11","EP")else if cW then b9=kr.noAtmosphericDensityAltitude+T;cB=b9;p_=true;if not by then cr.ToggleIntoOrbit()end;pY=true end end;pU=-1;if b4 or by or b8 then return end end else pU=bM end;if cW and not cc then cB=ce;p_=true;pY=true;cr.ToggleIntoOrbit()if by then pU=bM else pU=0 end;return end;b4=not b4;b5=false;b7=false;if b4 then b2=false;b1=false;b0=false;bX=false;cx=true;bs=nil;cC=false;if cb~=-1 and cJ<20 then if bl then ct.landingGear()end;fS("lfs","LS")b6=true;if pU>-1 then b9=ce+W end;a_="ATO Hold"iw:setTargetGroundAltitude(X)if aZ and cN then cr.ToggleVerticalTakeoff()end else fS("altOn","AH")b6=false;if pU>-1 then if cW then b9=ce end end;if b8 then cr.ToggleVerticalTakeoff()end end;if cO and not q then local r9=antigrav.getBaseAltitude()if bp and g3.agg and g3.agg>ce then b9=g3.agg elseif b6 then b9=r9 end;if eX(ce-r9)<100 and cJ<20 then b9=r9;a_="AGG Hold"qf=0 end end;if c9 then b9=200000 end else fS("altOff","AH")if by then cr.ToggleIntoOrbit()end;if b8 then cr.ToggleVerticalTakeoff()end;cx=p;b6=false;bp=false;pU=0 end end;function pO.ResetAutopilots(pO)if pO then c9=false;b2=false;bb=false;q4=false;b9=ce;r2=false;d9=false;bf="Aligning"end;bp=false;b6=false;b7=false;b1=false;b5=false;da=nil;ra=false;cV=nil;d9=false;if not cO then b4=false;bs=nil end;if b8 then cr.ToggleVerticalTakeoff()end;if by then cr.ToggleIntoOrbit()end;cx=p;c8=false;ca=false;bW=0 end;function pO.BrakeToggle(rb)if not a_ then if rb then a_=rb else a_=true end else a_=false end;if b5 then b5=false;cx=p;d9=false end;if a_ then fS("bkOn","B",1)cr.ResetAutopilots()else fS("bkOff","B",1)end end;function pO.BeginReentry()if b7 then b_="Re-Entry cancelled"fS("reOff","RE")b7=false;cx=p;b4=false elseif not kr.hasAtmosphere then b_="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c0=5 elseif not q5 then b7=true;if iw:getAxisCommandType(0)~=rc.cruise then d.control.cancelCurrentControlMasterMode()end;cx=true;a_=false;b_="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cz;fS("par","RE")else b7=true;b4=true;cx=true;a_=false;b9=kr.surfaceMaxAltitude+Z;if b9>kr.spaceEngineMinAltitude then b9=kr.spaceEngineMinAltitude-0.01*kr.noAtmosphericDensityAltitude end;local rd=iA(b9)b_="Beginning Re-entry.  Target speed: "..cz.." Target Altitude: "..rd;fS("glide","RE")qg=bJ(cz)end;b6=false end;function pO.ToggleAntigrav()if antigrav and not q then if cO then fS("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bu==nil then bu=ce end;if bu<1000 then bu=1000 end;fS("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pO.changeSpd(re)local rf=1;if re then rf=-1 end;if not bY then if t and not pf and q3 then local rg=bN;bN=fT(dj(bN+rf*aD/100,-1,1),2)if bN>=0 and rg<0 then bN=0;q3=false end elseif pf then if cc or b7 then cz=dj(cz+rf*aD,0,U)elseif b2 then a9=dj(a9+rf*aD/3.6*100,0,dd-0.2)end else iw:updateCommandFromActionStart(axisCommandId.longitudinal,rf*aD/10)end else if b2 or bp or c9 or by then c_=c_+1*rf*-1;if c_>#cS then c_=1 end;if c_<1 then c_=#cS end else if not re then rf=1 else rf=nil end;cq.adjustAutopilotTargetIndex(rf)end end end;function pO.TenthTick()local function rh()if not b2 then if g3==nil or g3.planetname~=kr.name then ri=(c4.center-cM):len()else ri=(g3.position-cM):len()end end;local fn=cJ;local rj=c.getThrottle()/100;if t then rj=bN end;local rk,rl=cn.computeDistanceAndTime(cJ,a9,cf,d:maxForceForward()*rj,a0,0)local c2,c3;if not b3 then c2,c3=cr.GetAutopilotBrakeDistanceAndTime(a9)else c2,c3=cr.GetAutopilotTBBrakeDistanceAndTime(a9)end;local dO,rm;if not b3 and fn>0 then dO,rm=cr.GetAutopilotBrakeDistanceAndTime(fn)else dO,rm=cr.GetAutopilotTBBrakeDistanceAndTime(fn)end;local rn=0;local ro=0;if bd or not b2 and fn>5 then ro=cn.computeTravelTime(fn,0,ri)elseif c2+rk<ri then rn=ri-(c2+rk)ro=cn.computeTravelTime(8333.0556,0,rn)else local rp=(ri-c2)/rk;rk=ri-c2;rl=rl*rp end;if g3~=nil and g3.planetname==kr.name and not b2 then return ro elseif bc then return rm elseif bd then return ro+rm else return rl+c3+ro end end;local function rq(op,rr)if op==nil then op=b.getGravityIntensity()end;op=fT(op,5)if rr~=nil and rr or(q2==nil or q2~=op)then local fn=cH:len()local rs=it(c.getWidgetData()).maxBrake;if rs~=nil and rs>0 and cc then rs=rs/dj(fn/100,0.1,1)rs=rs/cd;if cd>0.10 then if bt then bt=(bt+rs)/2 else bt=rs end end end;if rs~=nil and rs>0 then br=rs end;q2=op end end;cT,cU=qu()dd=bL.getMaxSpeed()if bi~="None"and(c4 or g3)then lF=rh()end;rq(nil,true)end;function pO.SatNavTick()if not r then return end;qr=dbHud_1.getStringValue("SPBAutopilotTargetName")if qr~=nil and qr~=""and qr~="SatNavNotChanged"then local dE=it(dbHud_1.getStringValue("SavedLocations"))if dE~=nil then bo=dE;local gu=-1;local gA;for dJ,dv in pairs(bo)do if dv.name and dv.name=="SatNav Location"then gu=dJ;break end end;if gu~=-1 then gA=bo[gu]gu=-1;for dJ,dv in pairs(e[0])do if dv.name and dv.name=="SatNav Location"then gu=dJ;break end end;if gu>-1 then e[0][gu]=gA end;cq.UpdateAtlasLocationsList()b_=gA.name.." position updated"end end;for K=1,#cS do if cS[K].name==qr then bk=K;a.print("Index = "..bk.." "..cS[K].name)cq.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pO.onFlush()local function rt(ru,rv)local rw=vec3()local rx=vec3()if ru==axisCommandId.longitudinal then rw=vec3(bL.getOrientationForward())rx=cF elseif ru==axisCommandId.vertical then rw=vec3(bL.getOrientationUp())rx=qc elseif ru==axisCommandId.lateral then rw=vec3(bL.getOrientationRight())rx=cG else return vec3()end;local ry=vec3(b.getWorldGravity())local rz=ry:dot(rx)local rA=vec3(bL.getWorldAirFrictionAcceleration())local rB=rA:dot(rx)local rC=cH:dot(rw)local rD=rv*constants.kph2m;if rE==nil then rE=pid.new(10,0,10.0)end;rE:inject(rD-rC)local rF=rE:get()local rG=(rF-rB-rz)*rx;return rG end;local function rH(ru,rv)local rw=vec3()local rx=vec3()if ru==axisCommandId.longitudinal then rw=vec3(bL.getOrientationForward())rx=cF elseif ru==axisCommandId.vertical then rw=vec3(bL.getOrientationUp())rx=qc elseif ru==axisCommandId.lateral then rw=vec3(bL.getOrientationRight())rx=cG else return vec3()end;local ry=vec3(b.getWorldGravity())local rz=ry:dot(rx)local rA=vec3(bL.getWorldAirFrictionAcceleration())local rB=rA:dot(rx)local rC=cH:dot(rw)local rD=rv*constants.kph2m;if rI==nil then rI=pid.new(10,0,10.0)end;rI:inject(rD-rC)local rF=rI:get()local rG=(rF-rB-rz)*rx;return rG end;local function rJ(rK,jS,f_)local rL=rK:cross(f_):normalize_inplace()local kE=math.acos(dj(rL:dot(-jS),-1,1))*constants.rad2deg;if rL:cross(-jS):dot(f_)<0 then kE=-kE end;return kE end;local function rM()if cY and not b5 then local eq=cY[1]local hW,hX=cY[2],cY[3]local rN=math.min(hW,hX or hW)local rO=rN/cJ;local rP=b6 and(cJ<42 or cb~=-1)local rQ=b4 or bp or bs or b2;if rQ and not rP and(c2*1.5>rN or rO<1)then a_="Collision"bE={}qf=0;if b4 then cr.ToggleAltitudeHold()end;if bs then cr.ToggleLockPitch()end;b_="Autopilot Cancelled due to possible collision"a.print(eq.name.." COLLISION "..iB(rO).." / "..iA(rN,2))cr.ResetAutopilots(1)ly=true;if cc then b5=true end;cx=true end;if rO<11 then cX=eq.name.." COLLISION "..iB(rO).." / "..iA(rN,2)else cX=eq.name.." collision "..iB(rO)end;if rO<6 then fS("alarm","AL",2)end else cX=false end end;if antigrav and not q then if not cO and antigrav.getBaseAltitude()~=bu then qp=bu end end;if dc then d:setEngineForceCommand('hover',vec3(),1)dc=false end;cP=iw:getAxisCommandType(0)==axisCommandType.byThrottle;aN=math.max(aN,0.01)aO=math.max(aO,0.01)aI=math.max(aI,0.01)aM=math.max(aM,0.01)aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aH=math.max(aH,0.01)local rR=dj(bT+q6+a.getControlDeviceForwardInput(),-1,1)local rS=dj(bU+q8+a.getControlDeviceYawInput(),-1,1)local rT=dj(bV+q7-a.getControlDeviceLeftRightInput(),-1,1)local rU=a_ and 1 or 0;cK=vec3(b.getWorldVertical())if cK==nil or cK:len()==0 then cK=(kr.center-cM):normalize()end;qc=vec3(bL.getWorldOrientationUp())cF=vec3(bL.getWorldOrientationForward())cG=vec3(bL.getWorldOrientationRight())cI=vec3(bL.getWorldVelocity())cH=vec3(bL.getVelocity())cM=vec3(bL.getWorldPosition())cf=bL.getMass()cJ=vec3(cI):len()cL=-cK:dot(cI)cR=getRoll(cK,cF,cG)local rV=cR/180*math.pi;local rW=math.cos(rV)local rX=math.sin(rV)cQ=rJ(cK,cF,cG*rW+qc*rX)local rY=cI:normalize()local rZ=eX(cR)local r_=utils.sign(cR)local s0=vec3(bL.getWorldAngularVelocity())local s1=rR*aN*cG+rS*aI*cF+rT*aO*qc;if cx==true and cK:len()>0.01 then local s2=eX(q9-cR)if((b1 or b7 or b5 or c8 or b4 or by)and s2>0 or cc and s2<aJ and p)and rS==0 and eX(cQ)<85 then local s3=q9;local s4=aH;if not cc then s4=s4/4;q9=0;s3=0 end;if s5==nil then s5=pid.new(s4*0.01,0,s4*0.1)end;s5:inject(s3-cR)local s6=s5:get()s1=s1+s6*cF end end;local s7=1;local s8=0;local s9=1;bO=0;cd=bK()cc=false or ce<kr.noAtmosphericDensityAltitude and cd>0.00001;ce=b.getAltitude()cb=qD()bM=bI()pT=bM;if bl and cb>-1 and cb-3<Y then if iw.targetGroundAltitudeActivated then iw:deactivateGroundEngineAltitudeStabilization()end end;if cs then qs=not qs;if qs then cs.UpdateRadar()end;if E then rM()end end;if antigrav then cO=antigrav.isActive()==1 end;local sa=1;local sb=1;local sc=bM-pT;local sd=-math.deg(qz(qc,cI,cF))local se=math.deg(qz(cG,cI,cF))local gp=cK*-1;cy=cc and sd<-L or sd>L or se<-M or se>M;local sf=a.getMouseDeltaX()local sg=a.getMouseDeltaY()if qt then local sh=bI()-qt;sf=sf*sh/0.016;sg=sg*sh/0.016 end;qt=bI()if o and not bY then sg=-sg end;q7=0;q8=0;q6=0;fW=cm[0]local si=bL.getWorldPosition()kr=fW:closestBody(si)sj=co(kr)fr=sj:orbitalParameters(si,cI)if ce==0 then ce=(cM-kr.center):len()-kr.radius end;cW=c.getClosestPlanetInfluence()>0 or ce>0 and ce<200000;local op=kr:getGravity(si):len()*cf;q9=0;local sk=bL.getMaxThrustAlongAxis("ground",bL.getOrientationUp())[1]if qj==0 then if iv()==1 and bY then if not cv then c5=dj(c5+sf/2,-ch/2,ch/2)c6=dj(c6+sg/2,-ci/2,ci/2)end else c5=0;c6=0 end else c5=dj(c5+sf/2,-ch/2,ch/2)c6=dj(c6+sg/2,-ci/2,ci/2)db=dl(c5*c5+c6*c6)if not bY and iv()==0 then local kN,kO=1,1;if bG=="SCOPE"then kN,kO=d3/90,d3/90 end;if g=="virtual joystick"then if db>ax then q7=q7-dj(eX(c5)-ax,0,ch/2)*utils.sign(c5)*aF*kN;q6=q6-dj(eX(c6)-ax,0,ci/2)*utils.sign(c6)*aG*kO end else c5=0;c6=0;if g=="mouse"then q6=(-utils.smoothstep(sg,-100,100)+0.5)*2*sa;q7=(-utils.smoothstep(sf,-100,100)+0.5)*2*sb end end end end;local sl=cJ>27777;if cJ>V/3.6 and not cc and not b2 and not sl then b_="Space Speed Engine Shutoff reached"qf=0 end;if not sl and sm then if not a_ then cr.BrakeToggle()end;if b2 then cr.ResetAutopilots(1)end;qf=0 end;sm=sl;if cd>0.09 then if cJ>cz/3.6 and not t and not pP then a_="SpdLmt"pP=true elseif not t and pP then if cJ<cz/3.6 then a_=false;pP=false end end end;if b1 then if c8 then a_=false;local sn=false;if g3 and c8==true then sn=qP(g3.position-cM,0.1)else sn=qP(vec3(cI),0.01)end;cx=true;if sn then qg=bJ(cz)if(eX(cR)<2 or eX(cQ)>85)and cJ>=cz/3.6-1 then a_=false;b1=false;if c8~=2 then q5=true end;if c8==true then ca=true end;c8=false;b2=false;cr.BeginReentry()end elseif cc and t then qf=1 end elseif cJ>iP then qP(vec3(cI),0.01)end end;if b0 then if cc then b0=false elseif cJ>iP then qP(-vec3(cI))end end;if not b1 and c8 and not by then if not cc then if c8~=2 then q5=true end;cr.BeginReentry()c8=false;ca=true else c8=false;if not qq then qq=true end end end;if ca and g3 and(ce<b9+250 and ce>b9-250)and cJ*3.6>cz-250 and eX(cL)<25 and cd>=0.1 and(g3.position-cM):len()>2000+ce then if not qq then qq=true end;ca=false end;if b8 then cx=true;local so=b9;if cL<-30 then b_="Unable to achieve lift. Safety Landing."bW=0;cx=p;b8=false;b5=true elseif not q and cO or b9<kr.spaceEngineMinAltitude then if cO then so=antigrav.getBaseAltitude()end;if ce<so-100 then qa=0;bW=15;a_=false elseif cL>0 then a_="VTO Limit"bW=0 elseif cL<-30 then a_="VTO Fall"bW=15 elseif ce>=so then if cO then if b2 or bp then cr.ToggleVerticalTakeoff()else a_="VTO Complete"b8=false end;b_="Takeoff complete. Singularity engaged"fS("aggLk","AG")else a_=false;b_="VTO complete. Engaging Horizontal Flight"fS("vtoc","VT")cr.ToggleVerticalTakeoff()end;bW=0 end else if cd>0.08 then qa=0;a_=false;bW=20 elseif cd<0.08 and cc then a_=false;if cD then qa=0;bW=20 else bW=0;qa=36;qg=3500 end else cx=p;by=true;cC=false;sp=false;pY=false;pW=nil;pX=nil;if q0==nil then q0=kr end;cB=so;p_=true;b8=false end end;if qa~=nil then if sq==nil then sq=pid.new(2*0.01,0,2*0.1)end;local sr=dj(qa-cQ,-M*0.80,M*0.80)sq:inject(sr)local ss=dj(sq:get(),-1,1)q6=ss end end;if by then local function st()if fr.periapsis.altitude>=cB*0.99 and fr.apoapsis.altitude>=cB*0.99 and fr.periapsis.altitude<fr.apoapsis.altitude and fr.periapsis.altitude*1.05>=fr.apoapsis.altitude and eX(cB-ce)<1000 then return true else return false end end;local qW;local su=false;local sv=iA(cB)if q0==nil then q0=kr;if bp then q0=c4 end end;if not p_ then cB=bJ(q0.radius+q0.surfaceMaxAltitude+T)if q0.hasAtmosphere then cB=bJ(q0.radius+q0.noAtmosphericDensityAltitude+T)end;p_=true end;if qb.VectorToTarget and g3 then qW=g3.position-cM end;local sw,sx=co(q0):escapeAndOrbitalSpeed((cM-q0.center):len()-q0.radius)local sy=cR;if not pY then local sz=false;local sA=false;qf=0;pX=0;cA="Aligning to orbital path - OrbitHeight: "..sv;if qb.VectorToTarget then qP(qW:normalize():project_on_plane(cK))su=cF:dot(qW:project_on_plane(qc):normalize())>0.95 else qP(cI)su=sd<0.5;if cJ<150 then su=true end end;q6=0;pW=0;if cQ<=pW+2 and cQ>=pW-2 then sz=true else sz=false end;if sy<=pX+2 and sy>=pX-2 then sA=true else sA=false end;if sz and sA and su then pW=nil;pX=nil;pY=true end else if qb.VectorToTarget then qP(qW:normalize():project_on_plane(cK))elseif cJ>150 then qP(cI)end;q6=0;if qb.VectorToTarget and g3 then local c2,dO=cn.computeDistanceAndTime(cJ,cz/3.6,cf,0,0,br)if cC and qW:len()>15000+c2+ce then cA="Orbiting to Target"if ce-100<=q0.noAtmosphericDensityAltitude or lF>fr.timeToPeriapsis and fr.periapsis.altitude<q0.noAtmosphericDensityAltitude or not st()and fr.eccentricity>0.1 then b_="Re-Aligning Orbit"cC=false end elseif cC or qW:len()<15000+c2+ce then b_="Orbit complete, proceeding with reentry"fS("orCom","OB")bj=g3.position;q5=true;ca=true;qb.VectorToTarget,qb.AutopilotAlign=false,false;cr.ToggleIntoOrbit()cr.BeginReentry()return end end;if fr.periapsis~=nil and fr.apoapsis~=nil and fr.eccentricity<1 and ce>cB*0.9 and ce<cB*1.4 then if fr.apoapsis~=nil then if st()or cC then if cC then a_=false;qf=0;pW=0;if not qb.VectorToTarget then b_="Orbit complete"fS("orCom","OB")cr.ToggleIntoOrbit()end else q1=q1+1;if q1>=2 then cC=true end end else cA="Adjusting Orbit - OrbitHeight: "..sv;pZ=true;qg=sx*3.6+1;local sB=cB-ce;if sC==nil then sC=pid.new(0.1,0,1*0.1)end;sC:inject(sB-cL*dj(utils.smoothstep(2000-sB,-2000,2000)^6*10,1,10))pW=dj(sC:get(),-60,60)end end else local sD=2.75;local sE=eX(fT(sw*sD))local oE=sE%50;if oE>0 then sE=sE-oE+50 end;a_=false;if ce<cB*0.8 then cA="Escaping planet gravity - OrbitHeight: "..sv;pW=utils.map(cL,200,0,-15,80)elseif ce>=cB*0.8 and ce<cB*1.15 then cA="Approaching orbital corridor - OrbitHeight: "..sv;sE=sE*0.75;pW=utils.map(cL,100,-100,-15,65)elseif ce>=cB*1.15 and ce<cB*1.5 then cA="Approaching orbital corridor - OrbitHeight: "..sv;sE=sE*0.75;if cL<0 or pZ then pW=utils.map(ce,cB*1.5,cB*1.01,-30,0)else pW=utils.map(ce,cB*0.99,cB*1.5,0,30)end elseif ce>cB*1.5 then cA="Reentering orbital corridor - OrbitHeight: "..sv;pW=-65;local sF=utils.map(cL,-150,-400,1,0.55)sE=sE*sF end;qg=bJ(sE)end end;if pW~=nil then if sG==nil then sG=pid.new(1*0.01,0,5*0.1)end;local sH=pW-cQ;sG:inject(sH)local sI=dj(sG:get(),-0.5,0.5)q6=sI end end;if b2 and not cc and not c8 then local function sJ(dg,fr)a.print(dg)a_=false;bc=false;b2=false;r2=false;bf="Aligning"qf=0;q4=false;b_=dg;fS("apCom","AP")if fr or c8 then if fr and gn~=nil and not c8 then if not ce or ce==0 then return end;cB=ce;p_=true end;cr.ToggleIntoOrbit()end end;local sK,sL=bj,false;if g3 and g3.planetname~="Space"then bb=true;if not r2 then local sM=(g3.position-c4.center):normalize()local sN=sM:project_on_plane((c4.center-cM):normalize()):normalize()local sO=c4.center+sN*(c4.radius+gn)local sP=g3.position+(g3.position-c4.center):normalize()*(gn-c4:getAltitude(g3.position))if(cM-sO):len()<(cM-sP):len()then sK=sO else sK=sP;be=0 end;bj=sK;cr.showWayPoint(c4,bj)sL=true;r2=true end;bg=0 elseif g3 and g3.planetname=="Space"then if not r2 then bg=0;sL=true;bb=true;r2=true;sK=g3.position+(cM-g3.position):normalize()*R;bj=sK end elseif g3==nil then bg=0;if not r2 then local sM=(cM+cI*100000-c4.center):normalize()local sN=sM:project_on_plane((c4.center-cM):normalize()):normalize()if sN:len()<1 then sM=(cM+cF*100000-c4.center):normalize()sN=sM:project_on_plane((c4.center-cM):normalize()):normalize()end;sK=c4.center+sN*(c4.radius+gn)bj=sK;r2=true;sL=true;bb=true;cr.showWayPoint(c4,bj)end end;ri=(vec3(sK)-cM):len()local lD,eH,eI=cm:getPlanetarySystem(0):castIntersections(cM,cI:normalize(),function(eq)if eq.noAtmosphericDensityAltitude>0 then return eq.radius+eq.noAtmosphericDensityAltitude else return eq.radius+eq.surfaceMaxAltitude*1.5 end end)local lE=eH;if eI~=nil and eH~=nil then lE=math.min(eI,eH)end;if lE~=nil and lE<ri and lD.name==c4.name then ri=lE end;local sn=true;local sQ=(c4.center-(cM+vec3(cI):normalize()*ri)):len()-c4.radius;local lq=iA(sQ)qn=gf;qo='{"label": "Projected Altitude", "value": "'..lq..'"}'if cJ>50 and ba then local qW=vec3(sK)-cM;local sR=dj(math.deg(qz(qc,cI:normalize(),qW:normalize()))*cJ/500,-90,90)local sS=dj(math.deg(qz(cG,cI:normalize(),qW:normalize()))*cJ/500,-90,90)if eX(sR)<20 and eX(sS)<20 then sR=sR*2;sS=sS*2 end;if eX(sR)<2 and eX(sS)<2 then sR=sR*2;sS=sS*2 end;local sd=-math.deg(qz(qc,cF,cI:normalize()))local se=-math.deg(qz(cG,cF,cI:normalize()))if sT==nil then sT=pid.new(2*0.01,0,2*0.1)end;sT:inject(sS-se)local sU=dj(sT:get(),-1,1)q6=q6+sU;if sV==nil then sV=pid.new(2*0.01,0,2*0.1)end;sV:inject(sR-sd)local sW=dj(sV:get(),-1,1)q7=q7+sW;sL=true;if eX(sR)>2 or eX(sS)>2 then if bf~="Adjusting Trajectory"then bf="Adjusting Trajectory"fS("apAdj","AP")end else if bf~="Accelerating"then bf="Accelerating"fS("apAcc","AP")end end elseif ba and cJ<=50 then qP((sK-cM):normalize())end;if sQ<gn*1.5 then be=cz/3.6;if g3==nil then dO,be=co(c4):escapeAndOrbitalSpeed(sQ)end end;local c2,c3;if not b3 then c2,c3=qv(cJ)else c2,c3=qy(cJ)end;if b2 and not ba and not bd and not bc then local lD,lE=cr.checkLOS((bj-cM):normalize())if c4.name~=kr.name then if lD~=nil and c4.name~=lD.name and lE<ri then b_="Collision with "..lD.name.." in "..iA(lE).."\nClear LOS to continue."c0=5;qk=true else qk=false;b_=""end end end;if not qk then if not bd and not bc and not sL then sn=qP((sK-cM):normalize())elseif b3 and(bc or bd)then sn=qP(-vec3(cI):normalize())end end;if ba then if not q4 then a_=false;qf=_;bN=fT(_,2)q4=true end;local rj=c.getThrottle()if t then rj=bN end;local sX=99999;local oC=-vec3(bL.getWorldAcceleration()):dot(cI:normalize())local sY=dj(cI:dot((sK-cM):normalize()),0,cJ)if sY>0 or oC>0 then sX=cn.computeTravelTime(sY,oC,ri-c2)end;if a9>dd then a9=dd-0.2 end;if cH:len()>=a9 or rj==0 and q4 or a0/4>sX then ba=false;if bf~="Cruising"then fS("apCru","AP")bf="Cruising"end;bd=true;qf=0 end;local sZ=ri;if sZ<=c2 or H and cU<=c2+10000 and cT then if H and cU<=c2+10000 and cT then if cU<pQ and cU>2000 then cr.ResetAutopilots(1)b_="Autopilot cancelled to prevent crossing PvP Line"a_="PvP Prevent"pQ=cU else pQ=cU;return end end;ba=false;if bf~="Braking"then fS("apBrk","AP")bf="Braking"end;bc=true;qf=0;q4=false end elseif bc then if bf~="Orbiting to Target"then a_="AP Brk"end;if b3 then qf=1;qh=true end;local dO,sx=co(c4):escapeAndOrbitalSpeed((cM-kr.center):len()-kr.radius)local qW;if g3 then qW=g3.position-cM end;if g3 and g3.planetname=="Space"and cJ<50 then if#bE>0 then if not qq then table.remove(bE,1)end;if#bE>0 then a_=false;if not qq then qq=2 end;return end end;sJ("Autopilot complete, arrived at space location")a_="Space Arrival"elseif g3 and g3.planetname~="Space"and cJ<=sx and(fr.apoapsis==nil or fr.periapsis==nil or fr.apoapsis.altitude<=0 or fr.periapsis.altitude<=0)then sJ("Autopilot complete, commencing reentry")bj=g3.position;c8=true;cr.showWayPoint(c4,bj)elseif(g3 and g3.planetname~="Space"or g3==nil)and fr.periapsis~=nil and fr.periapsis.altitude>0 and fr.eccentricity<1 or bf=="Circularizing"then if bf~="Circularizing"then fS("apCir","AP")bf="Circularizing"end;if cJ<=sx then if g3 then if cI:normalize():dot(qW:normalize())>0.4 then if bf~="Orbiting to Target"then fS("apOrb","OB")bf="Orbiting to Target"end;if not r4 then a_=false;cr.showWayPoint(c4,g3.position)r4=true end else sJ("Autopilot complete, proceeding with reentry")bj=g3.position;c8=true;cr.showWayPoint(c4,g3.position)r4=false end else sJ("Autopilot completed, setting orbit",true)a_=false end end elseif bf=="Circularizing"then sJ("Autopilot complete, fixing Orbit",true)end elseif bd then local sZ=ri;if sZ<=c2 or H and cU<=c2+10000 and cT then if H and cU<=c2+10000 and cT then if cU<pQ and cU>2000 then if not qq then qq=true end;b_="Autopilot cancelled to prevent crossing PvP Line"a_="Prevent PvP"pQ=cU else pQ=cU;return end end;ba=false;if bf~="Braking"then fS("apBrk","AP")bf="Braking"end;bc=true end;local rj=c.getThrottle()if t then rj=bN end;if rj>0 then ba=true;if bf~="Accelerating"then bf="Accelerating"fS("apAcc","AP")end;bd=false end else if sn then if not bb and g3==nil or not bb and g3 and g3.planetname~="Space"then if not c8 then bj=vec3(c4.center)+(gn+c4.radius)*cG;s_=qc;t0=cG end;bb=true elseif sn and not qk then ba=true;if bf~="Accelerating"then bf="Accelerating"fS("apAcc","AP")end;if not q4 then qf=_;qh=true;bN=fT(_,2)q4=true;a_=false end end end end elseif b2 and(g3~=nil and g3.planetname~="Space"and cc)then b_="Autopilot complete, starting reentry"fS("apCom","AP")bj=g3.position;a_=false;bc=false;b2=false;r2=false;bf="Aligning"qf=0;q4=false;b1=true;c8=true;cr.showWayPoint(c4,g3.position)end;if bX then cx=true;local sS=0;local ft=cM+vec3(c.getMasterPlayerRelativePosition())local t1=ft-cM;local t2=vec3(t1):project_on(cF):len()local t3=vec3(t1):project_on(cG):len()local c7=dl(t2*t2+t3*t3)qP(t1:normalize())local mL=40;local t4=c7<mL;local t5=100;local rv=dj((c7-mL)/2,10,t5)q6=0;local sn=eX(q7)<0.1;if sn and cJ<rv and not t4 then a_=false;sS=-20 else a_="Follow"sS=0 end;local t6=0;if eX(sS-cQ)>t6 then if t7==nil then t7=pid.new(2*0.01,0,2*0.1)end;t7:inject(sS-cQ)local sU=t7:get()q6=sU end end;if b4 or b5 or b7 or bp or bs~=nil then local t8=bt;if t8 then t8=t8*dj(cJ/100,0.1,1)*cd else t8=br end;if not cc then t8=br end;qe=cF:project_on_plane(cK):normalize():dot(cI)if qe>100 then c2,c3=cn.computeDistanceAndTime(qe,100,cf,0,0,t8)local t9,ta=cn.computeDistanceAndTime(100,0,cf,0,0,t8*0.55)c2=c2+t9 else c2,c3=cn.computeDistanceAndTime(qe,0,cf,0,0,t8*0.55)end;local sB=b9-ce-cL;local tb=200+cJ;if b7 or c8 then tc=2000+cJ end;local td=1;if b6 then td=dj(cJ/100,0.1,1)end;local sS=(utils.smoothstep(sB,-tb,tb)-0.5)*2*O*td;if not b7 and not c8 and not bp and cF:dot(cI:normalize())<0.99 then sS=(utils.smoothstep(sB,-tb*dj(20-19*cd*10,1,20),tb*dj(20-19*cd*10,1,20))-0.5)*2*O*dj(2-cd*10,1,2)*td end;if not b4 then sS=0 end;if bs~=nil then if cW and not by then sS=bs else bs=nil end end;cx=true;local te=q6;if b7 then local tf=bJ(cz)local tg,th=cn.computeDistanceAndTime(cJ,tf/3.6,cf,0,0,br-kr.gravity*9.8*cf)tg=tg==-1 and 5000 or tg;local r3=ce-(kr.noAtmosphericDensityAltitude+tg)local ti=ce>kr.noAtmosphericDensityAltitude+tg*1.35;if ti then sS=P;if cJ<=tf/3.6 and cJ>tf/3.6-10 and eX(cI:normalize():dot(cF))>0.9 and not cP then bR=false;qf=1 end elseif(cP or iw:getTargetSpeed(axisCommandId.longitudinal)~=tf)and not ti and not cc then qg=tf;qh=true end;if cP then if cJ>tf/3.6 and not ti then a_="Reentry Limit"if bN>0 then qf=0 end else a_=false end else a_=false end;if cL>0 then a_="Reentry vSpd"end;if not q5 then sS=-80;if ce<kr.surfaceMaxAltitude+(kr.atmosphereThickness-kr.surfaceMaxAltitude)*0.25 then b_="PARACHUTE DEPLOYED at "..fT(ce,0)b7=false;b5=true;ly=true;qf=0;sS=0;cx=p end elseif kr.noAtmosphericDensityAltitude>0 and ti then cx=true elseif not ti then if not cc and(cP or iw:getTargetSpeed(axisCommandId.longitudinal)~=tf)then qg=tf end;if cJ<tf/3.6+1 then a_=false;q5=false;b7=false;cx=true;qf=1 end end end;if cJ>iP and not c9 and not bp and not b5 and u then qP(vec3(cI))end;if cV or(bp or c9)and bk>0 and cc then local qW;if cV then if type(cV)=="table"then qW=cV elseif cV<3 and cV>0 then qW=-cK:cross(cI)*5000 elseif cV>=3 then qW=cK:cross(cI)*5000 elseif cV<0 then qW=cI*25000 end elseif g3~=nil then qW=g3.position-cM else qW=c4.center-cM end;local sR=math.deg(qz(cK:normalize(),cI,qW))*2;local mO=math.rad(eX(cR))if cJ>aK and cc then local tj=1000+cJ;local tk=(utils.smoothstep(sB-cL*10,-tj,tj)-0.5)*2*O;local tl=dj(90-tk,0,180)q9=dj(sR*2,-tl,tl)local tm=sR;sR=dj(dj(sR,-L*0.80,L*0.80)*math.cos(mO)+4*(cQ-sS)*math.sin(math.rad(cR)),-L*0.80,L*0.80)local tn=1;if q9~=0 then tn=eX(mO/q9)end;tn=(90-dj(eX(q9-cR),0,90))/90;local to=sS;if eX(cR)>90 then to=-to end;sS=tn*dj(dj(to*math.cos(mO),-M*0.8,M*0.8)+eX(dj(eX(tm)*math.sin(mO),-M*0.80,M*0.80)),-M*0.80,M*0.80)else q9=0;sR=dj(sR,-L*0.80,L*0.80)end;local tp=sd-sR;if cV and eX(tp)<=0.0001 and(type(cV)=="table"or type(cV)~="table"and cV<0 and eX(cR)<1)then if cV==-2 then cr.ToggleAltitudeHold()end;cV=nil;fS("180Off","BR")return end;if not cy and cJ>aK and cc then if tq==nil then tq=pid.new(2*0.01,0,2*0.1)end;tq:inject(tp)local sW=dj(tq:get(),-1,1)q7=q7+sW elseif cc and cb>-1 or cJ<aK then qP(qW)elseif cy and cc then if(sd<-L or sd>L)and cc then qP(cI)end;if(se<-M or se>M)and cc then sS=dj(cQ-se,cQ-M*0.80,cQ+M*0.80)end end;if g3~=nil and not c9 then local so=kr:getAltitude(g3.position)local r3=qW:project_on_plane(cK):len()ly=true;if b9<kr.noAtmosphericDensityAltitude and not c9 and not b6 and not b7 and(r3<=c2 and qW:len()<kr.radius)and(cI:project_on_plane(cK):normalize():dot(qW:project_on_plane(cK):normalize())>0.99 or lH=="Finalizing Approach")then lH="Finalizing Approach"if#bE>0 then if not qq then table.remove(bE,1)end;if#bE>0 then if not qq then qq=2 end;return end end;qf=0;if b4 then cr.ToggleAltitudeHold()bp=true end;a_="AP Finalizing"elseif not b6 then a_=false end;if lH=="Finalizing Approach"and(qe<0.1 or r3<0.1 or tr~=nil and tr<r3)then fS("bklOn","BL")b5=true;d9=true;if g3.heading then da=g3.heading else da=nil end;bp=false;lH="Proceeding to Waypoint"cX=false end;tr=r3 end elseif bp and not cc and b9>kr.noAtmosphericDensityAltitude and not(c9 or b7)then if g3~=nil and c4.name==kr.name then local qW=g3.position-cM;local so=kr:getAltitude(g3.position)local r3=dl(qW:len()^2-(ce-so)^2)local t8=bt;if t8 then c2,c3=cn.computeDistanceAndTime(cJ,0,cf,0,0,t8/2)ly=true;if r3<=c2+cJ*sc/2 and cI:project_on_plane(cK):normalize():dot(qW:project_on_plane(cK):normalize())>0.99 then if kr.hasAtmosphere then a_=false;b1=false;q5=true;c8=false;ca=true;b2=false;cr.BeginReentry()end end;tr=r3 end end end;if not cc and(b4 and b9>kr.noAtmosphericDensityAltitude)and not(c9 or by or b7)then if not cC and not by then cB=b9;p_=true;if bp then qb.VectorToTarget=true end;cr.ToggleIntoOrbit()bp=false;pY=true end end;if cy and cc and cb==-1 and cJ>aK and lH~="Finalizing Approach"then qP(cI)sS=dj(cQ-se,cQ-M*0.80,cQ+M*0.80)end;q6=te;local qI=-1;if b5 then if not ql then if not cP then qf=0 end;iw:setTargetGroundAltitude(500)iw:activateGroundEngineAltitudeStabilization(500)bA=true;ql=true end;sS=0;local ts=false;local tt=math.abs(qe)if not q and cO then ts=antigrav.getBaseAltitude()if ts<kr.surfaceMaxAltitude and g3==nil or g3~=nil and kr:getAltitude(g3.position)>ts then ts=false end else ts=false end;if da then if tt<0.05 then if cL>-N then a_=false else a_="BL Align BLR"end;if qP(da,0.001)then da=nil;cx=p else q6=0;cx=true end else a_="BL Align Hzn"end;if ts and eX(ce-ts)<250 then a_="AGG Align"end else local tu=false;local tv=30;if tt<10 and sk~=nil and sk>0 then local tw=dj(cd,0.4,2)local t8=bt*dj(cJ/100,0.1,1)*tw;local tx=sk*tw+t8-op;local ty=t8/2-op;local tz=cJ-dl(eX(ty/2)*20/(0.5*cf))*utils.sign(ty)if tz<0 then tz=0 end;local tA;if cJ>100 then local tB,dO=cn.computeDistanceAndTime(cJ,100,cf,0,0,t8)local tC,dO=cn.computeDistanceAndTime(100,0,cf,0,0,dl(t8))tA=tB+tC else tA=cn.computeDistanceAndTime(cJ,0,cf,0,0,dl(t8))end;if tA<20 then a_=false else local tD=0;if tz>100 then local tE,dO=cn.computeDistanceAndTime(tz,100,cf,0,0,tx)local tF,dO=cn.computeDistanceAndTime(100,0,cf,0,0,sk*tw+dl(t8)-op)tD=tE+tF else tD,dO=cn.computeDistanceAndTime(tz,0,cf,0,0,sk*tw+dl(t8)-op)end;tD=(tD+15+cJ*sc)*1.1;local tG=d9 and g3~=nil and kr:getAltitude(g3.position)>0 and g3.safe;local so=nil;if ts and ts<ce then so=ts elseif tG then so=kr:getAltitude(g3.position)+250 elseif ce>kr.surfaceMaxAltitude then so=kr.surfaceMaxAltitude end;if cY then local tH=kr:getAltitude(cY[1].center)if so then if tH>so then so=tH end else so=tH end end;if so~=nil then local tI=ce-so;tu=true;if tI<=tD or tD==-1 or tt>0.05 and d9 then if tt>0.05 and d9 then a_="BL AP Hzn"else a_="BL Stop Dist"end else a_=false end end end end;qI=cb;if qI>-1 then if(cJ<1 or cI:normalize():dot(cK)<0)and not da then b5=false;b4=false;if not ts then qi=true;iw:setTargetGroundAltitude(Y)end;bW=0;a_="BL Complete"cx=p;d9=false else a_="BL Slowing"end elseif not tu then if ly and cI:normalize():dot(-gp)<0.999 then a_="BL Strong"qP()elseif tt>10 or tt>0.05 and d9 then a_="BL hSpd"elseif cL<-N then a_="BL BLR"else a_=false end end end else ql=false end;if b6 or c9 then local lD,eI,eH;if bj~=nil then lD,eI,eH=cm:getPlanetarySystem(0):castIntersections(cM,(bj-cM):normalize(),function(eq)if eq.noAtmosphericDensityAltitude>0 then return eq.radius+eq.noAtmosphericDensityAltitude else return eq.radius+eq.surfaceMaxAltitude*1.5 end end)end;if cO and not c9 then if ce>=b9-50 and cJ>iP then b6=false;if not b2 and not bp then a_="ATO Agg Arrive"qf=0 end end elseif eX(sS)<15 and ce/b9>0.75 then b6=false;if not c9 then if cP and not t then d.control.cancelCurrentControlMasterMode()end elseif c9 and cJ<iP then b2=true;c9=false;b4=false;b6=false;qf=0 elseif c9 then qf=0;a_="ATO Space"end elseif c9 and not cc and c4~=nil and(lD==nil or lD.name==c4.name)then b2=true;c9=false;b4=false;b6=false;if not cP then qf=0 end;ba=true end end;local tJ=cb>-1;local tK=cQ;if(bp or c9 or cV)and not tJ and cJ>aK and cc then local mO=math.rad(eX(cR))tK=cQ*eX(math.cos(mO))+se*math.sin(mO)end;local tL=dj(sS-tK,-M*0.80,M*0.80)if not cc and bp then tL=dj(sS-tK,-85,O)elseif not cc then tL=dj(sS-tK,-O,O)end;if eX(cR)<5 or bp or cV or b5 or tJ or b4 then if t7==nil then t7=pid.new(5*0.01,0,5*0.1)end;t7:inject(tL)local sU=t7:get()q6=q6+sU end end;if antigrav~=nil and(antigrav and not q and ce<200000)then if bu==nil or bu<1000 then bu=1000 end;if tM~=bu then tM=bu;qp=tM end end;if(cc or b7 or ca)and t and cP then if tN==nil then tN=pid.new(0.1,0,1)end;local tO=0;if aT>0 and not b7 and cd>0.005 and cd<0.1 and cL>-50 then tO=(0.1-cd)*cz*aT end;tN:inject(cz/3.6+tO-cI:dot(cF))local tP=tN:get()bQ=dj(tP,-1,1)if not d5 then if bQ<bN and(cd>0.005 or b7 or ca)then bP=true;d5=dj(bQ,0.01,1)else bP=false;d5=bN end end;if tQ==nil then tQ=pid.new(1*0.01,0,1*0.1)end;tQ:inject(cI:len()-cz/3.6-tO)local tR=dj(tQ:get(),0,1)if cc and cL<-80 or(cd>0.005 or b7 or ca)then bO=tR end;if bO>0 then if bP and bQ==0.01 and not d5 then d5=0 end else bQ=dj(bQ,0.01,1)end;local tS=''local tT=vec3()local tU=rt(axisCommandId.vertical,bW*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tU,s8)local tV='thrust analog longitudinal 'if bB=="All"or bB=="Longitude"then tV=tV..aU end;local tW=iw:getAxisCommandType(axisCommandId.longitudinal)local tX=iw:composeAxisAccelerationFromThrottle(tV,axisCommandId.longitudinal)local tY=rH(axisCommandId.lateral,bx*1000)tS=tS..' , '.."lateral airfoil , lateral ground "tT=tT+tY;if tT:len()>constants.epsilon then d:setEngineForceCommand(tS,tT,s8,'','','',s9)end;d:setEngineForceCommand(tV,tX,s7)local tZ='thrust analog vertical fueled 'local t_='thrust analog lateral fueled 'if bB=="All"or bB=="Lateral"then t_=t_..aV end;if bB=="All"or bB=="Vertical"then tZ=tZ..aW end;if bW~=0 or b5 and a_ or not bl and not bA then d:setEngineForceCommand(tZ,tU,s7)else d:setEngineForceCommand(tZ,vec3(),s7)end;if bx~=0 then d:setEngineForceCommand(t_,tY,s7)else d:setEngineForceCommand(t_,vec3(),s7)end;if rU==0 then rU=bO end;local u0=-rU*(aP*cI+aQ*rY)d:setEngineForceCommand('brake',u0)else if t then if not d5 then d5=bN end end;local rv=c.getAxisCommandValue(0)if not cP then if tQ==nil then tQ=pid.new(1*0.01,0,1*0.1)end;tQ:inject(cI:len()-rv/3.6)local tR=dj(tQ:get(),0,1)rU=dj(rU+tR,0,1)end;local u0=-rU*(aP*cI+aQ*rY)d:setEngineForceCommand('brake',u0)local tS=''local tT=vec3()local u1=false;local tV='thrust analog longitudinal 'if bB=="All"or bB=="Longitude"then tV=tV..aU end;local tW=iw:getAxisCommandType(axisCommandId.longitudinal)if tW==axisCommandType.byThrottle then local tX=iw:composeAxisAccelerationFromThrottle(tV,axisCommandId.longitudinal)d:setEngineForceCommand(tV,tX,s7)elseif tW==axisCommandType.byTargetSpeed then local tX=iw:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tS=tS..' , '..tV;tT=tT+tX;if iw:getTargetSpeed(axisCommandId.longitudinal)==0 or iw:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iw:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u1=true end end;local t_='thrust analog lateral 'if bB=="All"or bB=="Lateral"then t_=t_..aV end;local u2=iw:getAxisCommandType(axisCommandId.lateral)if u2==axisCommandType.byThrottle then local u3=iw:composeAxisAccelerationFromThrottle(t_,axisCommandId.lateral)d:setEngineForceCommand(t_,u3,s7)elseif u2==axisCommandType.byTargetSpeed then local tY=iw:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tS=tS..' , '..t_;tT=tT+tY end;local tZ='thrust analog vertical 'if bB=="All"or bB=="Vertical"then tZ=tZ..aW end;local u4=iw:getAxisCommandType(axisCommandId.vertical)if u4==axisCommandType.byThrottle then local tU=iw:composeAxisAccelerationFromThrottle(tZ,axisCommandId.vertical)if bW~=0 or b5 and a_ then d:setEngineForceCommand(tZ,tU,s7,'airfoil','ground','',s9)else d:setEngineForceCommand(tZ,vec3(),s7)d:setEngineForceCommand('airfoil vertical',tU,s7,'airfoil','','',s9)d:setEngineForceCommand('ground vertical',tU,s7,'ground','','',s9)end elseif u4==axisCommandType.byTargetSpeed then if bW<0 then d:setEngineForceCommand('hover',vec3(),s7)end;local u5=iw:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tS=tS..' , '..tZ;tT=tT+u5 end;if tT:len()>constants.epsilon then if rU~=0 or u1 or eX(rY:dot(cF))<0.5 then tS=tS..', brake'end;d:setEngineForceCommand(tS,tT,s8,'','','',s9)end end;local u6=aM*(s1-s0)local u7=vec3(bL.getWorldAirFrictionAngularAcceleration())u6=u6-u7;d:setEngineTorqueCommand('torque',u6,s7,'airfoil','','',s9)d:setBoosterCommand('rocket_engine')if c1 and not n then local fn=cH:len()local u8=0.15;if not cP then local u9=iw:getTargetSpeed(axisCommandId.longitudinal)if fn*3.6>u9*(1-u8)and ua then ua=false;d:toggleBoosters()elseif fn*3.6<u9*(1-u8)and not ua then ua=true;d:toggleBoosters()end else local rj=c.getThrottle()if t then rj=bN*100 end;local rv=rj/100;if not cc then rv=rv*a9;if fn>=rv*(1-u8)and ua then ua=false;d:toggleBoosters()elseif fn<rv*(1-u8)and not ua then ua=true;d:toggleBoosters()end else local tf=bJ(cz)rv=rv*tf/3.6;if fn>=rv*(1-u8)and ua then ua=false;d:toggleBoosters()elseif fn<rv*(1-u8)and not ua then ua=true;d:toggleBoosters()end end end end end;if ub then for dJ,dv in pairs(ub)do pO[dJ]=dv end end;cb=qD()return pO end;local function uc(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ud,iv,iw,ix,ue,gL,fT,e2,dk,dj,fS,iz,pN)local uf={}local ug=true;local uh=5;local ui=5;local uj=uh;local uk=ui;local ul=bM;function uf.landingGear()bl=not bl;if bl then bp=false;bs=nil;cr.cmdThrottle(0)if vBooster or hover then if cc and cb==-1 then fS("bklOn","BL")ly=true;b7=false;b6=false;b8=false;b4=false;if b5 then d9=not d9 end;b5=true;cx=true;bl=false else if bS then fS("grOut","LG",1)d.control.deployLandingGears()end;d9=false;iw:setTargetGroundAltitude(Y)if cc then a_="Landing"end end elseif bS and not b5 then fS("grOut","LG",1)d.control.deployLandingGears()end else if bS then fS("grIn","LG",1)d.control.retractLandingGears()end;iw:activateGroundEngineAltitudeStabilization(um)if bA then if Y<iw.targetGroundAltitude then iw:setTargetGroundAltitude(iw.targetGroundAltitude)else iw:setTargetGroundAltitude(X)end end end end;function uf.startControl(un)local function uo(re)local rf=1;local function up(uq,re)local ur={kr.surfaceMaxAltitude+100,kr.spaceEngineMinAltitude-0.01*kr.noAtmosphericDensityAltitude,kr.noAtmosphericDensityAltitude+T,kr.radius*(S-1)+kr.noAtmosphericDensityAltitude}local us=uq;for dO,dv in ipairs(ur)do if re and us>dv then uq=dv elseif uq<dv and not re then uq=dv;break end end;return uq end;if re then rf=-1 end;if not q and cO then if bY and re then bu=1000 elseif bu~=nil then bu=bu+rf*ui;if bu<1000 then bu=1000 end;if b4 and bu<b9+10 and bu>b9-10 then b9=bu end else bu=tM+rf*100 end elseif b4 or b8 or by then if by then if bY then cB=up(cB,re)else cB=cB+rf*uh end;if cB<kr.noAtmosphericDensityAltitude then cB=kr.noAtmosphericDensityAltitude end else if bY and cc then b9=up(b9,re)else b9=b9+rf*uh end end else iw:updateTargetGroundAltitudeFromActionStart(rf*1.0)end end;local function ut(uu)if not cc then b_="Flight Assist in Atmo only"return end;local ds=type(uu)if cV==nil then if ds=="table"then if b2 or bp then cr.ToggleAutopilot()end;fS("180On","BR")elseif uu==1 then fS("bnkLft","BR")else fS("bnkRht","BR")end;if not b4 and not b2 and not bp then cr.ToggleAltitudeHold()if ds~="table"then uu=uu+1 end end;cV=uu else fS("180Off","BR")cV=nil end end;local function uv()if ix()==1 then c5=0;c6=0;ue(bh)elseif iv()==1 and y then cw=false;cv=false end;bY=false end;if un=="gear"then ct.landingGear()elseif un=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif un=="forward"then if pf and not cc and not b2 then b1=not b1;b0=false else bT=bT-1 end elseif un=="backward"then if pf then if not cc then if not b2 then b0=not b0;b1=false else b3=not b3 end else ut(-cI*5000)end else bT=bT+1 end elseif un=="left"then if pf then ut(1)else bU=bU-1 end elseif un=="right"then if pf then ut(3)else bU=bU+1 end elseif un=="yawright"then bV=bV-1;da=nil elseif un=="yawleft"then bV=bV+1;da=nil elseif un=="straferight"then iw:updateCommandFromActionStart(axisCommandId.lateral,1.0)bx=1 elseif un=="strafeleft"then iw:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bx=-1 elseif un=="up"then bW=bW+1;if cb-3<Y and ce>0 and bl then ct.landingGear()end;iw:deactivateGroundEngineAltitudeStabilization()iw:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif un=="down"then bW=bW-1;iw:deactivateGroundEngineAltitudeStabilization()iw:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif un=="groundaltitudeup"then uo()elseif un=="groundaltitudedown"then uo(true)elseif un=="option1"then uw=false;if pf and bY then local ux=""for K=1,#d0 do ux=ux.."| Name: "..a.getPlayerName(d0[K]).." Mass: "..fT(b.getBoardedPlayerMass(d0[K])/1000,1).."t "end;a.print("Onboard: "..ux)return end;cq.adjustAutopilotTargetIndex()elseif un=="option2"then uw=false;if pf and bY then for K=1,#d0 do b.forceDeboard(d0[K])b.forceInterruptVRSession(d0[K])end;b_="Deboarded All Passengers"return end;cq.adjustAutopilotTargetIndex(1)elseif un=="option3"then local function uy()ug=not ug;if not ug then fS("wid","DH")c.showWidget()b.showWidget()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(uz,atmofueltank_size,"Atmo Fuel","fuel_container")uA=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uB,spacefueltank_size,"Space Fuel","fuel_container")uC=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uD,rocketfueltank_size,"Rocket Fuel","fuel_container")uE=_autoconf.panels[_autoconf.panels_size]end;uF=a.createWidgetPanel("Docking")uG=a.createWidget(uF,"parenting")a.addDataToWidget(c.getWidgetDataId(),uG)uH=a.createWidgetPanel("Core combat stress")uI=a.createWidget(uH,"core_stress")a.addDataToWidget(b.getWidgetDataId(),uI)if shield~=nil then shield.showWidget()end else fS("hud","DH")c.hideWidget()b.hideWidget()if uA~=nil then gL(uA)uA=nil end;if uF~=nil then gL(uF)uF=nil end;if uH~=nil then gL(uH)uH=nil end;if uC~=nil then gL(uC)uC=nil end;if uE~=nil then gL(uE)uE=nil end;if shield~=nil then shield.hideWidget()end end end;uw=false;if pf and bY then local ux=""for K=1,#d1 do ux=ux.."| ID: "..d1[K].." Mass: "..fT(b.getDockedConstructMass(d1[K])/1000,1).."t "end;a.print("Docked Ships: "..ux)return end;if x then if w then w=false else w=true end end;uy()elseif un=="option4"then uw=false;if pf and bY then for K=1,#d1 do b.forceUndock(d1[K])end;b_="Undocked all ships"return end;cV=nil;cr.ToggleAutopilot()elseif un=="option5"then uw=false;cr.ToggleLockPitch()elseif un=="option6"then uw=false;if pf and bY then if shield then cu.ventShield()else b_="No shield found"end;return end;cr.ToggleAltitudeHold()elseif un=="option7"then uw=false;if pf and bY then if shield then shield.toggle()return else b_="No shield found"return end end;E=not E;if E then b_="Collision System Enabled"else b_="Collision System Secured"end elseif un=="option8"then uw=false;if pf and bY then if bk>0 and g3~=nil then cr.routeWP()else b_="Select a saved wp on IPH to add to or remove from route"end;return end;bA=not bA;if not bA then b_="DeCoupled Mode - Ground Stabilization off"iw:deactivateGroundEngineAltitudeStabilization()fS("gsOff","GS")else b_="Coupled Mode - Ground Stabilization on"iw:activateGroundEngineAltitudeStabilization(um)dc=true;fS("gsOn","GS")end elseif un=="option9"then uw=false;if pf and bY then iw:resetCommand(axisCommandId.longitudinal)iw:resetCommand(axisCommandId.lateral)iw:resetCommand(axisCommandId.vertical)cr.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cg=gyro.getState()==1;if cg then fS("gyOn","GA")else fS("gyOff","GA")end else b_="No gyro found"end elseif un=="lshift"then cZ=false;if pf then bY=true elseif bY then uv()else if ix()==1 then bY=true;bh=ix()ue(1)elseif iv()==1 and y then bY=true;cw=false;cv=false end end elseif un=="brake"then if aY or pf then cr.BrakeToggle("Manual")elseif not a_ then cr.BrakeToggle("Manual")else a_="Manual"end elseif un=="lalt"then uw=true;pf=true;if iv()==0 and not i and g=="keyboard"then ue(1)end elseif un=="booster"then if n then d:toggleBoosters()elseif not c1 then if not ua then d:toggleBoosters()ua=true end;c1=true else if ua then d:toggleBoosters()ua=false end;c1=false end elseif un=="stopengines"then local function uJ()if bM-ul<1.5 then fS("clear","CA")cr.clearAll()end end;uJ()ul=bM;if iw:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bN~=0 then iw:resetCommand(axisCommandId.longitudinal)cr.cmdThrottle(0)else cr.cmdThrottle(100)end else if iw:getTargetSpeed(axisCommandId.longitudinal)~=0 then iw:resetCommand(axisCommandId.longitudinal)else if cc then cr.cmdCruise(cz)else cr.cmdCruise(a9*3.6)end end end elseif un=="speedup"then cr.changeSpd()elseif un=="speeddown"then cr.changeSpd(true)elseif un=="antigravity"and not q then if antigrav~=nil then cr.ToggleAntigrav()else b_="No antigrav found"end elseif un=="leftmouse"then if bY then bZ=true;uv()end end end;function uf.stopControl(un)local function uK()if not q and cO then uk=ui end;if b4 or b8 or by then uj=uh end end;if un=="forward"then bT=0 elseif un=="backward"then bT=0 elseif un=="left"then if cV then if cV==2 then cV=-2 else cV=-1 end end;bU=0 elseif un=="right"then if cV then if cV==4 then cV=-2 else cV=-1 end end;bU=0 elseif un=="yawright"then bV=0 elseif un=="yawleft"then bV=0 elseif un=="straferight"then iw:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bx=0 elseif un=="strafeleft"then iw:updateCommandFromActionStop(axisCommandId.lateral,1.0)bx=0 elseif un=="up"then bW=0;iw:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bA then iw:activateGroundEngineAltitudeStabilization(um)dc=true end elseif un=="down"then bW=0;iw:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bA then iw:activateGroundEngineAltitudeStabilization(um)dc=true end elseif un=="groundaltitudeup"then uK()uw=false elseif un=="groundaltitudedown"then uK()uw=false elseif un=="brake"then if not aY and not pf then if a_ then cr.BrakeToggle()else a_=false end end elseif un=="lalt"then if bY then bY=false end;if iv()==0 and i then if uw then if ix()==1 then ue(0)else ue(1)end else uw=true end elseif iv()==0 and not i and g=="keyboard"then ue(0)end;pf=false end end;function uf.loopControl(un)local function uL(re)local rf=1;if re then rf=-1 end;if not q and cO then if bu~=nil then bu=bu+rf*uk;if bu<1000 then bu=1000 end;if b4 and bu<b9+10 and bu>b9-10 then b9=bu end;uk=dj(uk*1.05,ui,50)else bu=tM+rf*100 end elseif b4 or b8 or by then if by then cB=cB+rf*uj;if cB<kr.noAtmosphericDensityAltitude then cB=kr.noAtmosphericDensityAltitude end else b9=b9+rf*uj end;uj=dj(uj*1.05,uh,50)else iw:updateTargetGroundAltitudeFromActionLoop(rf*1.0)end end;local function uM(re)local rf=1;if re then rf=-1 end;if not bY then if t and not pf then bN=dj(bN+rf*aE/100,-1,1)else iw:updateCommandFromActionLoop(axisCommandId.longitudinal,rf*aE)end end end;if un=="groundaltitudeup"then if not bY then uL()end elseif un=="groundaltitudedown"then if not bY then uL(true)end elseif un=="speedup"then uM()elseif un=="speeddown"then uM(true)end end;function uf.inputTextControl(rd)local function uN(uO,ft,gx)local function uP(ft)local dB=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dC='::pos{'..dB..','..dB..','..dB..','..dB..','..dB..'}'local dS,dT,d_,e0,e1=e2(ft,dC)if dS=="0"and dT=="0"then return vec3(dk(d_),dk(e0),dk(e1))end;e0=math.rad(e0)d_=math.rad(d_)local kr=e[dk(dS)][dk(dT)]local eT=math.cos(d_)local uQ=vec3(eT*math.cos(e0),eT*math.sin(e0),math.sin(d_))return kr.center+(kr.radius+e1)*uQ end;local fV=uP(ft)return cq.AddNewLocation(uO,fV,gx)end;local K;local uR,ij=nil,nil;local uS="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(rd," ")uR=rd;if K~=nil then uR=string.sub(rd,0,K-1)ij=string.sub(rd,K+1)end;if uR=="/help"or uR=="/commands"then for lz in string.gmatch(uS,"([^\n]+)")do a.print(lz)end;return elseif uR=="/setname"then if ij==nil or ij==""then b_="Usage: ah-setname Newname"return end;if bk>0 and g3~=nil then cq.UpdatePosition(ij)else b_="Select a saved target to rename first"end elseif shield and uR=="/resist"then cu.setResist(ij)elseif uR=="/addlocation"or string.find(rd,"::pos")~=nil then local gx=false;local uO="0-Temp"if ij==nil or ij==""or uR~="/addlocation"then ij=uR;gx=true end;K=string.find(ij,"::")if not gx then uO=string.sub(ij,1,K-2)end;local ft=string.sub(ij,K)uN(uO,ft,gx)elseif uR=="/agg"then if ij==nil or ij==""then b_="Usage: /agg targetheight"return end;ij=dk(ij)if ij<1000 then ij=1000 end;bu=ij;b_="AGG Target Height set to "..ij elseif uR=="/G"then if ij==nil or ij==""then b_="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ij=="dump"then for dJ,dv in pairs(iz())do if type(dv.get())=="boolean"then if dv.get()==true then a.print(dJ.." true")else a.print(dJ.." false")end elseif dv.get()==nil then a.print(dJ.." nil")else a.print(dJ.." "..dv.get())end end;return end;K=string.find(ij," ")local uT=string.sub(ij,0,K-1)local uU=string.sub(ij,K+1)for dJ,dv in pairs(iz())do if dJ==uT then local uV=type(dv.get())if uV=="number"then uU=dk(uU)if dJ=="AtmoSpeedLimit"then cz=uU end end;b_="Variable "..uT.." changed to "..uU;if dJ=="MaxGameVelocity"then uU=uU/3.6;if uU>dd-0.2 then uU=dd-0.2;b_="Variable "..uT.." changed to "..fT(uU*3.6,1)end end;if uV=="boolean"then if string.lower(uU)=="true"then uU=true else uU=false end end;dv.set(uU)return end end;b_="No such global variable: "..uT elseif uR=="/deletewp"then if bk>0 and g3~=nil then cq.ClearCurrentPosition()else b_="Select a custom wp to delete first in IPH"end elseif uR=="/copydatabank"then if dbHud_2 then pN(true)else b_="Spare Databank required to copy databank"end elseif uR=="/iphWP"then if bk>0 then a.print(cr.showWayPoint(c4,bj,true))a.print(json.encode(bj))b_="::pos waypoint shown in lua chat in local and world format"else b_="No target selected in IPH"end elseif uR=="/createPrivate"then local uW="privatelocations = {\n"local uX=""if#d7>0 then for dJ,dv in pairs(d7)do uW=uW.."{position = {x = "..dv.position.x..", y = "..dv.position.y..", z = "..dv.position.z.."},\n ".."name = '"..dv.name.."',\n planetname = '"..dv.planetname.."',\n gravity = "..dv.gravity..",\n"if dv.heading then uW=uW.."heading = {x = "..dv.heading.x..", y = "..dv.heading.y..", z = "..dv.heading.z.."},\n"end;if dv.safe then uW=uW.."safe = true},\n"else uW=uW.."safe = false},\n"end end end;uX=#d7 .."-Private "if ij=="all"then for dJ,dv in pairs(bo)do uW=uW.."{position = {x = "..dv.position.x..", y = "..dv.position.y..", z = "..dv.position.z.."},\n ".."name = '*"..dv.name.."',\n planetname = '"..dv.planetname.."',\n gravity = "..dv.gravity..",\n"if dv.heading then uW=uW.."heading = {x = "..dv.heading.x..", y = "..dv.heading.y..", z = "..dv.heading.z.."},\n"end;if dv.safe then uW=uW.." safe = true},\n"else uW=uW.."safe = false},\n"end end;uX=uX..#bo.."-Public "end;uW=uW.."}\n return privatelocations"if ud then ud.setHTML(uW)end;b_=uX.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c0=7 end end;function uf.tagTick()if bB=="Off"then bB="All"elseif bB=="All"then bB="Longitude"elseif bB=="Longitude"then bB="Lateral"elseif bB=="Lateral"then bB="Vertical"else bB="Off"end;b_="Extra Engine Tags: "..bB;c.stopTimer("tagTick")end;if uY then for dJ,dv in pairs(uY)do uf[dJ]=dv end end;return uf end;local function uZ(d,b,c,e,vBooster,hover,pM,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,is,ud)local a=DUSystem;local bL=DUConstruct;local u_=DUPlayer;local gK=DULibrary;local v0={}local di=string.format;local it=json.decode;local v1=json.encode;local pF=b.getElementMaxHitPointsById;local iu=b.getElementMassById;local iv=d.control.isRemoteControlled;local e2=string.match;local gL=a.destroyWidgetPanel;local fQ=a.updateData;local fR=a.addDataToWidget;local ue=a.lockView;local ix=a.isViewLocked;local dl=math.sqrt;local dk=tonumber;local eX=math.abs;local bJ=math.floor;local bK=c.getAtmosphereDensity;local eS=math.atan;local bI=a.getArkTime;local dj=utils.clamp;local iw=d.axisCommandManager;local v2=Y;local gN=13;local iC=b.getElementIdList()local iD=0;local function dm(eA,eB)if eA==0 then return eX(eB)<1e-09 end;if eB==0 then return eX(eA)<1e-09 end;return eX(eA-eB)<math.max(eX(eA),eX(eB))*dA end;local function fT(dB,v3)local rf=10^(v3 or 0)return bJ(dB*rf+0.5)/rf end;local function iy(v4,v5)for dJ,dv in pairs(v5)do if type(dJ)=="string"then v4[dJ]=dv else v4[#v4+1]=v5[dJ]end end;return v4 end;local function iz(v6)local v7={}if not v6 then iy(v7,J)iy(v7,a8)iy(v7,aC)iy(v7,aX)return v7 elseif v6=="boolean"then return J elseif v6=="handling"then return a8 elseif v6=="hud"then return aC elseif v6=="physics"then return aX end end;local function pN(v8)local function v9(va)for dJ,dv in pairs(va)do dbHud_1.setStringValue(dJ,v1(dv.get()))if v8 and dbHud_2 then dbHud_2.setStringValue(dJ,v1(dv.get()))end end end;if dbHud_1 then v9(bF)v9(iz())a.print("Saved Variables to Datacore")if v8 and dbHud_2 then b_="Databank copied.  Remove copy when ready."end end end;local function fS(vb,vc,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..vb..".mp3")end;local function gM(ht,hu,rd,jJ,vd)if jJ==nil then jJ=""end;if vd==nil then vd=""end;return di([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jJ,ht,hu,vd,rd)end;local function iA(c7,ve)local vf=c7>100000;if ve==nil then ve=1 end;if vf then return fT(c7/1000/200,ve).."SU"elseif c7<1000 then return fT(c7,ve).."M"else return fT(c7/1000,ve).."KM"end end;local function iB(vg)local vh=0;local vi=0;local vj=0;if vg<60 then vg=bJ(vg)elseif vg<3600 then vh=bJ(vg/60)vg=bJ(vg%60)elseif vg<86400 then vi=bJ(vg/3600)vh=bJ(vg%3600/60)else vj=bJ(vg/86400)vi=bJ(vg%86400/3600)end;if vj>0 then return vj.."d "..vi.."h "elseif vi>0 then return vi.."h "..vh.."m "elseif vh>0 then return vh.."m "..vg.."s"elseif vg>0 then return vg.."s"else return"0s"end end;function v0.onStart()local vk=false;local function vl()local function vm(vn)local vo=dbHud_1.hasKey;for dJ,dv in pairs(vn)do if vo(dJ)then local dE=it(dbHud_1.getStringValue(dJ))if dE~=nil then dv.set(dE)vk=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vm(iz())coroutine.yield()vm(bF)else vm(bF)b_="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"c0=5;vk=false end;coroutine.yield()if vk then b_="Loaded Saved Variables"elseif not f then b_="No Databank Saved Variables Found\nVariables will save to Databank on standing"c0=5 end;if#bo>0 then d8=iy(d8,bo)end else b_="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;ch=aa;ci=ab;aY=j;g=string.lower(g)cx=p;cz=U;if bv+180<bM then bt=0 end;bv=bM;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then b_="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c0=7 end;if antigrav and not q then if bu==nil then bu=ce end;antigrav.setTargetAltitude(bu)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d7>0 then d8=iy(d8,d7)end end;lH="Proceeding to Waypoint"if a9<0 then a9=bL.getMaxSpeed()-0.1 end end;local function vp()local function vq(vr,vs)if vr>vs then vs=vr end;local vt,vu=0,0;if a4>0 then vt=a4*0.05 end;if a5>0 then vu=a5*0.05 end;vs=vs*(1-(vt+vu))return vs end;local vv=b.getElementNameById;local vw=ar~=0 and as~=0;local vx=_G["atmofueltank_size"]local vy=_G["spacefueltank_size"]local vz=_G["rocketfueltank_size"]for dJ in pairs(iC)do local type=b.getElementDisplayNameById(iC[dJ])if e2(type,'^.*Atmospheric Engine$')then if e2(tostring(b.getElementTagsById(iC[dJ])),'^.*vertical.*$')and b.getElementForwardById(iC[dJ])[3]>0 then cN=true end end;if e2(type,'^.*Space Engine$')then cE=true;if e2(tostring(b.getElementTagsById(iC[dJ])),'^.*vertical.*$')then local vA=b.getElementForwardById(iC[dJ])if vA[3]<0 then vB=true else cD=true end end end;if type=="Landing Gear"then bS=true end;if type=="Dynamic Core Unit"then local pH=pF(iC[dJ])if pH>10000 then gN=110 elseif pH>1000 then gN=55 elseif pH>150 then gN=27 end end;iD=iD+pF(iC[dJ])if vw and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pH=pF(iC[dJ])local oy=iu(iC[dJ])local vr=0;local jC=bI()if type=="Atmospheric Fuel Tank"then local vs=400;local vC=35.03;if pH>10000 then vs=51200;vC=5480 elseif pH>1300 then vs=6400;vC=988.67 elseif pH>150 then vs=1600;vC=182.67 end;vr=oy-vC;if a1>0 then vs=vs+vs*a1*0.2 end;vs=vq(vr,vs)local gw=vv(iC[dJ])local jA=0;for jB=1,vx do if gw==it(c["atmofueltank_"..jB].getWidgetData()).name then jA=jB;break end end;local vD={iC[dJ],string.sub(gw,1,12),vs,vC,vr,jC,jA}cj[#cj+1]=vD end;if type=="Rocket Fuel Tank"then local vs=320;local vC=173.42;if pH>65000 then vs=40000;vC=25740 elseif pH>6000 then vs=5120;vC=4720 elseif pH>700 then vs=640;vC=886.72 end;vr=oy-vC;if a3>0 then vs=vs+vs*a3*0.1 end;vs=vq(vr,vs)local gw=vv(iC[dJ])local jA=0;for jB=1,vz do if gw==it(c["rocketfueltank_"..jB].getWidgetData()).name then jA=jB;break end end;local vD={iC[dJ],string.sub(gw,1,12),vs,vC,vr,jC,jA}cl[#cl+1]=vD end;if type=="Space Fuel Tank"then local vs=600;local vC=35.03;if pH>10000 then vs=76800;vC=5480 elseif pH>1300 then vs=9600;vC=988.67 elseif pH>150 then vs=2400;vC=182.67 end;vr=oy-vC;if a2>0 then vs=vs+vs*a2*0.2 end;vs=vq(vr,vs)local gw=vv(iC[dJ])local jA=0;for jB=1,vy do if gw==it(c["spacefueltank_"..jB].getWidgetData()).name then jA=jB;break end end;local vD={iC[dJ],string.sub(gw,1,12),vs,vC,vr,jC,jA}ck[#ck+1]=vD end end end;if not cN then b8,aZ=false,false end end;local function vE()if gyro~=nil then cg=gyro.isActive()==1 end;if not bA then iw:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ue(1)else ue(0)end;if door and(cc or not cc and ce<10000)then for dO,dv in pairs(door)do dv.toggle()end end;if switch then for dO,dv in pairs(switch)do dv.toggle()end end;if forcefield and(cc or not cc==0 and ce<10000)then for dO,dv in pairs(forcefield)do dv.toggle()end end;if antigrav then cO=antigrav.isActive()==1;if cO and not q then antigrav.showWidget()end end;if iv()==1 and k then u_.freeze(1)else u_.freeze(0)end;if bS then if cb~=-1 and not cO then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bl=d.control.isAnyLandingGearDeployed()==1 or cb~=-1 and cb-3<Y;if cb~=-1 or not cc and cH:len()<50 then a_="Startup"else a_=false end;iw:setTargetGroundAltitude(v2)pt=cc end;local function vF()local vG={}local function vH()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vI={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vJ={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vK,vL in pairs(e)do e[vK][0]=vH()e[vK][0].systemId=vK;vG[vK]={}for vM,kr in pairs(e[vK])do kr.gravity=kr.gravity/9.8;kr.center=vec3(kr.center)kr.name=kr.name[1]kr.noAtmosphericDensityAltitude=vJ[kr.id]or kr.atmosphereThickness or kr.atmosphereRadius-kr.radius;kr.spaceEngineMinAltitude=vI[kr.id]or 0.68377*kr.atmosphereThickness;kr.planetarySystemId=vK;kr.bodyId=kr.id;vG[vK][vM]=kr;if mz==nil or kr.center.x<mz then mz=kr.center.x end;if my==nil or kr.center.x>my then my=kr.center.x end;if mC==nil or kr.center.y<mC then mC=kr.center.y end;if mB==nil or kr.center.y>mB then mB=kr.center.y end;if kr.center and kr.name~="Space"then d2[#d2+1]=kr end end end;ec=dh(d,b,c,a,di,dj,dk,dl,dm)cm=ec(vG)cn=eW(d,b,c,a,dl,eX)co=fp(d,b,c,a,di,dj,dk,dl,dm)cq=fP(d,b,c,a,dbHud_1,e,fQ,fR,bJ,dk,dl,fS,fT)kr=cm[0]:closestBody(bL.getWorldPosition())end;vN=false;vO=coroutine.create(function()iw:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vl()coroutine.yield()vp()coroutine.yield()cr=pL(d,b,c,e,vBooster,hover,pM,antigrav,warpdrive,dbHud_1,eX,bJ,bK,iv,eS,bI,dj,iw,fQ,ix,dl,fT,fS,iy,dm,iA,iB,pN,it,di,fR)vE()coroutine.yield()vF()if radar_1 then cs=gJ(b,a,c,library,radar_1,radar_2,warpdrive,eX,gL,dl,gM,dk,gN,fS)end;if ir then cp=ir(d,b,c,a,e,antigrav,hover,shield,warpdrive,is,eX,bJ,di,it,bK,iu,iv,eS,bI,dj,iw,fR,fQ,gL,ix,dl,fT,gM,fS,iy,iz,iA,iB,iC,iD)end;if cp then cp.ButtonSetup()end;ct=uc(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ud,iv,iw,ix,ue,gL,fT,e2,dk,dj,fS,iz,pN)if shield then cu=i9(shield,e2,bJ)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if ud then ud.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aS)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vP then vQ.ExtraOnStart()end;fS("start","SU")end)coroutine.resume(vO)end;function v0.onUpdate()if not vN then local i2=coroutine.status(vO)if i2=="suspended"then local dK,i3=coroutine.resume(vO)if i3 then a.print("ERROR STARTUP: "..i3)end elseif i2=="dead"then vN=true end end;if vN then d:update()if cc and t and cP then if cP and bR then cr.cmdThrottle(0)bR=false elseif not cP and not bR then bN=0;bR=true end end;if d5 then iw:setThrottleCommand(axisCommandId.longitudinal,d5)d5=nil end;if not cv and ph~=vR then a.setScreen(ph)end;vR=ph;if vP then vQ.ExtraOnUpdate()end end end;function v0.onFlush()if vN then cr.onFlush()if vP then vQ.ExtraOnFlush()end end end;function v0.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cd>0 or cd==0 and ce<10000)then for dO,dv in pairs(door)do dv.toggle()end end;if switch then for dO,dv in pairs(switch)do dv.toggle()end end;if forcefield and(cd>0 or cd==0 and ce<10000)then for dO,dv in pairs(forcefield)do dv.toggle()end end;w=d4;pN()if o7 then o7.activate()end;if z then cr.showWayPoint(kr,cM)end;if cp then a.print(cp.FuelUsed("atmofueltank")..", "..cp.FuelUsed("spacefueltank")..", "..cp.FuelUsed("rocketfueltank"))end;if vP then vQ.ExtraOnStop()end;fS("stop","SU")end;function v0.controlStart(un)if vN then ct.startControl(un)end end;function v0.controlStop(un)if vN then ct.stopControl(un)end end;function v0.controlLoop(un)if vN then ct.loopControl(un)end end;function v0.controlInput(rd)if vN then ct.inputTextControl(rd)end end;function v0.radarEnter(dT)if cs then cs.onEnter(dT)end end;function v0.radarLeave(dT)if cs then cs.onLeave(dT)end end;function v0.onTick(vS)if vS=="tenthSecond"then cr.TenthTick()if cp then cp.TenthTick()end elseif vS=="oneSecond"then if cp then cp.OneSecondTick()end elseif vS=="fiveSecond"then cr.SatNavTick()elseif vS=="msgTick"then if cp then cp.MsgTick()end elseif vS=="animateTick"then if cp then cp.AnimateTick()end elseif vS=="hudTick"then if cp then cp.hudtick()end elseif vS=="apTick"then cr.APTick()elseif vS=="shieldTick"then cu.shieldTick()elseif vS=="tagTick"then ct.tagTick()elseif vS=="contact"then cs.ContactTick()end end;if vP then for dJ,dv in pairs(vP)do v0[dJ]=dv end end;return v0 end;function script.onStart()vQ.onStart()end;function script.onOnStop()vQ.onStop()end;function script.onTick(vS)vQ.onTick(vS)end;function script.onOnFlush()vQ.onFlush()end;function script.onOnUpdate()vQ.onUpdate()end;function script.onActionStart(un)vQ.controlStart(un)end;function script.onActionStop(un)vQ.controlStop(un)end;function script.onActionLoop(un)vQ.controlLoop(un)end;function script.onInputText(rd)vQ.controlInput(rd)end;function script.onEnter(dT)vQ.radarEnter(dT)end;function script.onLeave(dT)vQ.radarLeave(dT)end;bH(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vQ=uZ(d,core,unit,e,vBooster,hover,pM,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,is,ud)script.onStart()
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
