name: ArchHud - Archaegeo v0.727 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.727;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},DeadZone={set=function(K)au=K end,get=function()return au end},OrbitMapSize={set=function(K)av=K end,get=function()return av end},OrbitMapX={set=function(K)aw=K end,get=function()return aw end},OrbitMapY={set=function(K)ax=K end,get=function()return ax end},soundVolume={set=function(K)ay=K end,get=function()return ay end}}aA=5.0;aB=1.0;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0166667;aQ=0.0666667;aR=0.0;aS="none"aT="none"aU="none"aV={speedChangeLarge={set=function(K)aA=K end,get=function()return aA end},speedChangeSmall={set=function(K)aB=K end,get=function()return aB end},MouseXSensitivity={set=function(K)aC=K end,get=function()return aC end},MouseYSensitivity={set=function(K)aD=K end,get=function()return aD end},autoRollFactor={set=function(K)aE=K end,get=function()return aE end},rollSpeedFactor={set=function(K)aF=K end,get=function()return aF end},autoRollRollThreshold={set=function(K)aG=K end,get=function()return aG end},minRollVelocity={set=function(K)aH=K end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(K)aI=K end,get=function()return aI end},torqueFactor={set=function(K)aJ=K end,get=function()return aJ end},pitchSpeedFactor={set=function(K)aK=K end,get=function()return aK end},yawSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeSpeedFactor={set=function(K)aM=K end,get=function()return aM end},brakeFlatFactor={set=function(K)aN=K end,get=function()return aN end},DampingMultiplier={set=function(K)aO=K end,get=function()return aO end},apTickRate={set=function(K)aP=K end,get=function()return aP end},hudTickRate={set=function(K)aQ=K end,get=function()return aQ end},ExtraEscapeThrust={set=function(K)aR=K end,get=function()return aR end},ExtraLongitudeTags={set=function(K)aS=K end,get=function()return aS end},ExtraLateralTags={set=function(K)aT=K end,get=function()return aT end},ExtraVerticalTags={set=function(K)aU=K end,get=function()return aU end}}aW=j;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=1000;b8=false;b9=false;ba=false;bb=false;bc=0;bd="Aligning"be=0;bf=1;bg="None"bh=nil;bi=0;bj=nil;bk=0.0;bl=0;bm={}bn=false;bo=0;bp=0;bq=nil;br=0;bs=1000;bt=0;bu=false;bv=0;bw=false;bx="All"by=true;bz="Off"bA=0.000;bB={}bC={}bD={VertTakeOff={set=function(K)b6=K end,get=function()return b6 end},VertTakeOffEngine={set=function(K)aX=K end,get=function()return aX end},SpaceTarget={set=function(K)bu=K end,get=function()return bu end},BrakeToggleStatus={set=function(K)aW=K end,get=function()return aW end},BrakeIsOn={set=function(K)aY=K end,get=function()return aY end},RetrogradeIsOn={set=function(K)aZ=K end,get=function()return aZ end},ProgradeIsOn={set=function(K)a_=K end,get=function()return a_ end},Autopilot={set=function(K)b0=K end,get=function()return b0 end},TurnBurn={set=function(K)b1=K end,get=function()return b1 end},AltitudeHold={set=function(K)b2=K end,get=function()return b2 end},BrakeLanding={set=function(K)b3=K end,get=function()return b3 end},Reentry={set=function(K)b5=K end,get=function()return b5 end},AutoTakeoff={set=function(K)b4=K end,get=function()return b4 end},HoldAltitude={set=function(K)b7=K end,get=function()return b7 end},AutopilotAccelerating={set=function(K)b8=K end,get=function()return b8 end},AutopilotBraking={set=function(K)ba=K end,get=function()return ba end},AutopilotCruising={set=function(K)bb=K end,get=function()return bb end},AutopilotRealigned={set=function(K)b9=K end,get=function()return b9 end},AutopilotEndSpeed={set=function(K)bc=K end,get=function()return bc end},AutopilotStatus={set=function(K)bd=K end,get=function()return bd end},AutopilotPlanetGravity={set=function(K)be=K end,get=function()return be end},PrevViewLock={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetName={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetCoords={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetIndex={set=function(K)bi=K end,get=function()return bi end},TotalDistanceTravelled={set=function(K)bk=K end,get=function()return bk end},TotalFlightTime={set=function(K)bl=K end,get=function()return bl end},SavedLocations={set=function(K)bm=K end,get=function()return bm end},VectorToTarget={set=function(K)bn=K end,get=function()return bn end},LocationIndex={set=function(K)bo=K end,get=function()return bo end},LastMaxBrake={set=function(K)bp=K end,get=function()return bp end},LockPitch={set=function(K)bq=K end,get=function()return bq end},LastMaxBrakeInAtmo={set=function(K)br=K end,get=function()return br end},AntigravTargetAltitude={set=function(K)bs=K end,get=function()return bs end},LastStartTime={set=function(K)bt=K end,get=function()return bt end},iphCondition={set=function(K)bx=K end,get=function()return bx end},stablized={set=function(K)by=K end,get=function()return by end},UseExtra={set=function(K)bz=K end,get=function()return bz end},SelectedTab={set=function(K)bE=K end,get=function()return bE end},saveRoute={set=function(K)bB=K end,get=function()return bB end},apRoute={set=function(K)bC=K end,get=function()return bC end}}local function bF(a,b,c,bG,bH,bI)bJ=bG()bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=0;bR=0;bS=0;bT=0;bU=false;bV=false;bW="empty"bX=3;bY=false;bZ=0;b_=0;c0=nil;c1=0;c2=0;c3=0;c4=false;c5=false;c6=false;c7=-1;c8=bI()>0;c9=bI()ca=b.getAltitude()cb=b.getConstructMass()cc=nil;cd=a9;ce=aa;cf={}cg={}ch={}ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=false;cs=false;ct=p;cu=false;cv=U;cw=nil;cx=0;cy=false;cz=false;cA=false;cB=vec3(b.getConstructWorldOrientationForward())cC=vec3(b.getConstructWorldOrientationRight())cD=vec3(b.getVelocity())cE=vec3(b.getWorldVelocity())cF=vec3(cE):len()cG=vec3(b.getWorldVertical())cH=-cG:dot(cE)cI=vec3(b.getConstructWorldPos())cJ=false;cK=false;cL=true;cM=0;cN=0;cO={}cP=false;cQ=50000;cR=nil;cS=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;cT=false;cU=nil;cV=false;cW=0;cX=nil;cY=nil;cZ={}c_=90;d0=w;d1=nil;d2=nil;d3={}d4={}d5=false;d6=nil;if shield_1 then d7=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())end end;local function d8(d,b,c,a,d9,da,db,dc,dd)local function de(df)return type(df)=='number'end;local function dg(df)return type(db(df))=='number'end;local function dh(di)return type(di)=='table'end;local function dj(a)return type(a)=='string'end;local function dk(dl)return dh(dl)and de(dl.x and dl.y and dl.z)end;local function dm(dn)return dh(dn)and de(dn.latitude and dn.longitude and dn.altitude and dn.id and dn.systemId)end;local dp=math.pi/180;local dq=180/math.pi;local dr=1e-10;local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..ds..','..ds..','..ds..','..ds..','..ds..'}'local utils=utils;local vec3=vec3;local function du(df)local dv=string.gsub(string.reverse(d9('%.4f',df)),'^0*%.?','')return dv==''and'0'or string.reverse(dv)end;local function dw(dx)if dk(dx)then return d9('{x=%.3f,y=%.3f,z=%.3f}',dx.x,dx.y,dx.z)end;if dh(dx)and not getmetatable(dx)then local dy={}local dz=next(dx)if type(dz)=='nil'or dz==1 then dy=dx else for dA,dl in pairs(dx)do local dB=dw(dl)if type(dA)=='number'then table.insert(dy,d9('[%s]=%s',dA,dB))else table.insert(dy,d9('%s=%s',dA,dB))end end end;return d9('{%s}',table.concat(dy,','))end;if dj(dx)then return d9("'%s'",dx:gsub("'",[[\']]))end;return tostring(dx)end;local dC={}dC.__index=dC;dC.__tostring=function(dx,dD)local dE={}for dA in pairs(dx)do table.insert(dE,dA)end;table.sort(dE)local dy={}for dF,dA in ipairs(dE)do local dB=dw(dx[dA])if type(dA)=='number'then table.insert(dy,d9('[%s]=%s',dA,dB))else table.insert(dy,d9('%s=%s',dA,dB))end end;if dD then return d9('%s%s',dD,table.concat(dy,',\n'..dD))end;return d9('{%s}',table.concat(dy,','))end;dC.__eq=function(dG,dH)return dG.systemId==dH.systemId and dG.id==dH.id and dd(dG.radius,dH.radius)and dd(dG.center.x,dH.center.x)and dd(dG.center.y,dH.center.y)and dd(dG.center.z,dH.center.z)and dd(dG.GM,dH.GM)end;local function dI(dJ,dK,dL,dM,dN)assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(dL),'Argument 3 (radius) must be a number:'..type(dL))assert(dh(dM),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dM))assert(dg(dN),'Argument 5 (GM) must be a number:'..type(dN))return setmetatable({systemId=db(dJ),id=db(dK),radius=db(dL),center=vec3(dM),GM=db(dN)},dC)end;local dO={}dO.__index=dO;dO.__tostring=function(dP)return d9('::pos{%d,%d,%s,%s,%s}',dP.systemId,dP.id,du(dP.latitude*dq),du(dP.longitude*dq),du(dP.altitude))end;dO.__eq=function(dG,dH)return dG.id==dH.id and dG.systemId==dH.systemId and dd(dG.latitude,dH.latitude)and dd(dG.altitude,dH.altitude)and(dd(dG.longitude,dH.longitude)or dd(dG.latitude,math.pi/2)or dd(dG.latitude,-math.pi/2))end;local function dQ(dR,dK,dS,dT,dU)local dJ=dR;if dj(dR)and not dT and not dU and not dK and not dS then dJ,dK,dS,dT,dU=dV(dR,dt)assert(dJ,'Argument 1 (position string) is malformed.')else assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(dS),'Argument 3 (latitude) must be in degrees:'..type(dS))assert(dg(dT),'Argument 4 (longitude) must be in degrees:'..type(dT))assert(dg(dU),'Argument 5 (altitude) must be in meters:'..type(dU))end;dJ=db(dJ)dK=db(dK)dS=db(dS)dT=db(dT)dU=db(dU)if dK==0 then return setmetatable({latitude=dS,longitude=dT,altitude=dU,id=dK,systemId=dJ},dO)end;return setmetatable({latitude=dp*da(dS,-90,90),longitude=dp*(dT%360),altitude=dU,id=dK,systemId=dJ},dO)end;local dW={}dW.__index=dW;dW.__tostring=function(dx,dD)local dX=dD and dD..'  'local dY={}local dE={}for dA in pairs(dx)do table.insert(dE,dA)end;table.sort(dE)for dF,dZ in ipairs(dE)do d_=dx[dZ]local e0=dC.__tostring(d_,dX)if dD then table.insert(dY,d9('[%s]={\n%s\n%s}',dZ,e0,dD))else table.insert(dY,d9('  [%s]=%s',dZ,e0))end end;if dD then return d9('\n%s%s%s',dD,table.concat(dY,',\n'..dD),dD)end;return d9('{\n%s\n}',table.concat(dY,',\n'))end;local function e1(e2)local e={}local pid;for dF,dl in pairs(e2)do local dK=dl.planetarySystemId;if type(dK)~='number'then error('Invalid planetary s ID: '..tostring(dK))elseif pid and dK~=pid then error('Mistringmatch planetary s IDs: '..dK..' and '..pid)end;local e3=dl.bodyId;if type(e3)~='number'then error('Invalid body ID: '..tostring(e3))elseif e[e3]then error('Duplicate body ID: '..tostring(e3))end;setmetatable(dl.center,getmetatable(vec3.unit_x))e[e3]=setmetatable(dl,dC)pid=dK end;return setmetatable(e,dW)end;e4={}local function e5(e2)return setmetatable({galaxyAtlas=e2 or{}},e4)end;e4.__index=function(di,K)if type(K)=='number'then local a=di.galaxyAtlas[K]return e1(a)end;return rawget(e4,K)end;e4.__pairs=function(dx)return function(di,dA)local e6,e7=next(di,dA)return e6,e7 and e1(e7)end,dx.galaxyAtlas,nil end;e4.__tostring=function(dx)local e8={}for dF,e9 in pairs(dx or{})do local ea=e9:getPlanetarySystemId()local eb=dW.__tostring(e9,'    ')table.insert(e8,d9('  [%s]={%s\n  }',ea,eb))end;return d9('{\n%s\n}\n',table.concat(e8,',\n'))end;e4.BodyParameters=dI;e4.MapPosition=dQ;e4.PlanetarySystem=e1;function e4.createBodyParameters(dJ,dK,ec,ed,ee,ef,eg)assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(ec),'Argument 3 (surfaceArea) must be a number:'..type(ec))assert(dh(ed),'Argument 4 (aPosition) must be an array or vec3:'..type(ed))assert(dh(ee),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ee))assert(dg(ef),'Argument 6 (altitude) must be in meters:'..type(ef))assert(dg(eg),'Argument 7 (gravityAtPosition) must be number:'..type(eg))local dL=dc(ec/4/math.pi)local c3=dL+ef;local eh=vec3(ed)+c3*vec3(ee)local dN=eg*c3*c3;return dI(dJ,dK,dL,eh,dN)end;e4.isMapPosition=dm;function e4:getPlanetarySystem(dR)if K==nil then K=0 end;if e7==nil then e7=0 end;local dJ=dR;if dm(dR)then dJ=dR.systemId end;if type(dJ)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(e7)~=dW then a=e1(a)end;return a end end end;function dW:sizeCalculator(ei)return 1.05*ei.radius end;function dW:castIntersections(ej,ek,el,em,en,eo)local ep={}if en then for dF,ei in pairs(en)do table.insert(ep,ei)end else ep=cZ end;if not eo then table.sort(ep,function(eq,er)local es=eq.center;local et=er.center;return(es.x-ej.x)^2+(es.y-ej.y)^2+(es.z-ej.z)^2<(et.x-ej.x)^2+(et.y-ej.y)^2+(et.z-ej.z)^2 end)end;local eu=ek:normalize()for dF,ei in ipairs(ep)do local ev=ei.center-ej;local dL=self:sizeCalculator(ei)local ew=ev:dot(eu)local ex=ew^2-(ev:len2()-dL^2)if ex>=0 then local ey=dc(ex)local ez=ew+ey;local eA=ew-ey;if eA>0 then return ei,ez,eA elseif ez>0 then return ei,ez,nil end end end;return nil,nil,nil end;function dW:closestBody(eB)assert(type(eB)=='table','Invalid coordinates.')local eC,ei;local eD=vec3(eB)for dF,eE in pairs(self)do local eF=(eE.center-eD):len2()if(not ei or eF<eC)and eE.name~="Space"then ei=eE;eC=eF end end;return ei end;function dW:convertToBodyIdAndWorldCoordinates(dR)local eG=dR;if dj(dR)then eG=dQ(dR)end;if eG.id==0 then return 0,vec3(eG.latitude,eG.longitude,eG.altitude)end;local eE=self:getBodyParameters(eG)if eE then return eG.id,eE:convertToWorldCoordinates(eG)end end;function dW:getBodyParameters(dR)local dK=dR;if dm(dR)then dK=dR.id end;assert(dg(dK),'Argument 1 (id) must be a number:'..type(dK))return self[dK]end;function dW:getPlanetarySystemId()local dF,dl=next(self)return dl and dl.systemId end;function dC:convertToMapPosition(dM)assert(dh(dM),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dM))local eH=vec3(dM)if self.id==0 then return setmetatable({latitude=eH.x,longitude=eH.y,altitude=eH.z,id=0,systemId=self.systemId},dO)end;local eI=eH-self.center;local c3=eI:len()local dU=c3-self.radius;local dS=0;local dT=0;if not dd(c3,0)then local eJ=eK(eI.y,eI.x)dT=eJ>=0 and eJ or 2*math.pi+eJ;dS=math.pi/2-math.acos(eI.z/c3)end;return setmetatable({latitude=dS,longitude=dT,altitude=dU,id=self.id,systemId=self.systemId},dO)end;function dC:convertToWorldCoordinates(dR)local eG=dj(dR)and dQ(dR)or dR;if eG.id==0 then return vec3(eG.latitude,eG.longitude,eG.altitude)end;assert(dm(eG),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eG.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eG.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eL=math.cos(eG.latitude)return self.center+(self.radius+eG.altitude)*vec3(eL*math.cos(eG.longitude),eL*math.sin(eG.longitude),math.sin(eG.latitude))end;function dC:getAltitude(dM)return(vec3(dM)-self.center):len()-self.radius end;function dC:getDistance(dM)return(vec3(dM)-self.center):len()end;function dC:getGravity(dM)local eM=self.center-vec3(dM)local eN=eM:len2()return self.GM/eN*eM/dc(eN)end;return setmetatable(e4,{__call=function(dF,...)return e5(...)end})end;local function eO(d,b,c,a,dc,eP)local cj={}local eQ=30000000/3600;local eR=eQ*eQ;local eS=100;function cj.computeAccelerationTime(eT,eU,eV)local eW=eQ*math.asin(eT/eQ)return(eQ*math.asin(eV/eQ)-eW)/eU end;function cj.computeDistanceAndTime(eT,eV,eX,eY,eZ,e_)eZ=eZ or 0;e_=e_ or 0;local f0=eT<=eV;local f1=eY*(f0 and 1 or-1)/eX;local f2=-e_/eX;local f3=f1+f2;if f0 and f3<=0 or not f0 and f3>=0 then return-1,-1 end;local f4,f5=0,0;if f1~=0 and eZ>0 then local eW=math.asin(eT/eQ)local f6=math.pi*(f1/2+f2)local f7=f1*eZ;local f8=eQ*math.pi;local dl=function(di)local f9=(f6*di-f7*math.sin(math.pi*di/2/eZ)+f8*eW)/f8;local fa=math.tan(f9)return eQ*fa/dc(fa*fa+1)end;local fb=f0 and function(a)return a>=eV end or function(a)return a<=eV end;f5=2*eZ;if fb(dl(f5))then local fc=0;while eP(f5-fc)>0.5 do local di=(f5+fc)/2;if fb(dl(di))then f5=di else fc=di end end end;local fd=eT;local fe=f5/eS;for ff=1,eS do local fg=dl(ff*fe)f4=f4+(fg+fd)*fe/2;fd=fg end;if f5<2*eZ then return f4,f5 end;eT=fd end;local eW=eQ*math.asin(eT/eQ)local bJ=(eQ*math.asin(eV/eQ)-eW)/f3;local fh=eR*math.cos(eW/eQ)/f3;local c3=fh-eR*math.cos((f3*bJ+eW)/eQ)/f3;return c3+f4,bJ+f5 end;function cj.computeTravelTime(eT,eU,c3)if c3==0 then return 0 end;if eU>0 then local eW=eQ*math.asin(eT/eQ)local fh=eR*math.cos(eW/eQ)/eU;return(eQ*math.acos(eU*(fh-c3)/eR)-eW)/eU end;if eT==0 then return-1 end;assert(eT>0,'Acceleration and initial speed are both zero.')return c3/eT end;return cj end;local function fi(d,b,c,a,d9,da,db,dc,dd)local vec3=vec3;local d8=d8(d,b,c,a,d9,da,db,dc,dd)local function dj(a)return type(a)=='string'end;local function dh(di)return type(di)=='table'end;fj={}fj.__index=fj;function fj:escapeAndOrbitalSpeed(dU)assert(self.body)local c3=dU+self.body.radius;if not dd(c3,0)then local fk=dc(self.body.GM/c3)return dc(2)*fk,fk end;return nil,nil end;function fj:orbitalParameters(dR,fl)assert(self.body)assert(dh(dR)or dj(dR))assert(dh(fl))local fm=(dj(dR)or d8.isMapPosition(dR))and self.body:convertToWorldCoordinates(dR)or vec3(dR)local dl=vec3(fl)local fn=fm-self.body.center;local fo=dl:len2()local fp=fn:len()local fq=self.body.GM;local fr=((fo-fq/fp)*fn-fn:dot(dl)*dl)/fq;local es=fq/(2*fq/fp-fo)local fs=fr:len()local eu=fr:normalize()local ft=es*(1-fs)local fu=es*(1+fs)local fv=ft*eu+self.body.center;local fw=fs<=1 and-fu*eu+self.body.center or nil;local fx=dc(es*fq*(1-fs*fs))local fy=fw and 2*math.pi*dc(es^3/fq)local fz=math.acos(fr:dot(fn)/(fs*fp))if fn:dot(dl)<0 then fz=-(fz-2*math.pi)end;local fA=math.acos((math.cos(fz)+fs)/(1+fs*math.cos(fz)))local fB=fA;if fB<0 then fB=fB+2*math.pi end;local fC=fB-fs*math.sin(fB)local fD=0;local fE=0;local fF=0;if fy~=nil then fD=fC/(2*math.pi/fy)fE=fy-fD;fF=fE+fy/2;if fz-math.pi>0 then fE=fD;fF=fE+fy/2 end;if fF>fy then fF=fF-fy end end;return{periapsis={position=fv,speed=fx/ft,circularOrbitSpeed=dc(fq/ft),altitude=ft-self.body.radius},apoapsis=fw and{position=fw,speed=fx/fu,circularOrbitSpeed=dc(fq/fu),altitude=fu-self.body.radius},currentVelocity=dl,currentPosition=fm,eccentricity=fs,period=fy,eccentricAnomaly=fA,meanAnomaly=fC,timeToPeriapsis=fE,timeToApoapsis=fF,trueAnomaly=fz}end;local function fG(fH)local eE=d8.BodyParameters(fH.systemId,fH.id,fH.radius,fH.center,fH.GM)return setmetatable({body=eE},fj)end;return setmetatable(fj,{__call=function(dF,...)return fG(...)end})end;local function fI(d,b,c,a,dbHud_1,e,fJ,fK,bH,db,dc,fL,fM)local function fN(fO)local dP=fP:closestBody(fO)if(fO-dP.center):len()>dP.radius+dP.noAtmosphericDensityAltitude then dP=e[0][0]end;return dP end;local function fQ()local function fR(fS,fT)return fS.name<fT.name end;cO={}for dA,dl in pairs(e[0])do cO[#cO+1]={name=dl.name,index=dA}end;table.sort(cO,fR)end;local function fU(fV,fW)if not fW then fW=fX.name end;for dA,dl in pairs(fV)do if dl.name and dl.name==fW then return dA end end;return-1 end;local function fY()cW=bi;if bi==0 then bg="None"c0=nil;fX=nil;return true end;local fZ=cO[bi].index;local f_=e[0][fZ]if f_.center then bg=f_.name;c0=ci[0][fZ]if fX~=nil then if c9==0 then if fJ(g0,g1)~=1 then fK(g0,g1)end;if fJ(g2,g3)~=1 then fK(g2,g3)end;if fJ(g4,g5)~=1 then fK(g4,g5)end;if fJ(g6,g7)~=1 then fK(g6,g7)end;if fJ(g8,g9)~=1 then fK(g8,g9)end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end;if fJ(ge,gf)~=1 then fK(ge,gf)end end;fX=nil else fX=f_;for dF,dl in pairs(ci[0])do if dl.name==fX.planetname then c0=dl;bg=fX.name;break end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end end;if fX==nil then bh=vec3(c0.center)else bh=fX.position end;if c0.planetname~="Space"then if c0.hasAtmosphere then gg=bH(c0.radius*(S-1)+c0.noAtmosphericDensityAltitude)else gg=bH(c0.radius*(S-1)+c0.surfaceMaxAltitude)end else gg=R end;if fX~=nil and fX.planetname=="Space"then bc=0 else dF,bc=ck(c0):escapeAndOrbitalSpeed(gg)end;be=0;b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"return true end;local function gh(gi)if not b0 and not bn and not c5 and not bw and not b5 and not c6 then if gi==nil then bi=bi+1;if bi>#cO then bi=0 end else bi=bi-1;if bi<0 then bi=#cO end end;if bi==0 then fY()else local fZ=cO[bi].index;local f_=e[0][fZ]if f_ and(f_~=nil and f_.name=="Space"or bx=="Custom Only"and f_.center or bx=="No Moons"and string.find(f_.name,"Moon")~=nil)then if gi==nil then gh()else gh(1)end else fY()end end else bW="Disengage autopilot before changing Interplanetary Helper"fL("iph","AP")end end;local function gj()local function gk(gl)local gm;if gl then gm=d3 else gm=bm end;local gn=-1;gn=fU(e[0])if gn>-1 then table.remove(e[0],gn)end;gn=-1;gn=fU(gm)if gn~=-1 then bW=fX.name.." saved location cleared"table.remove(gm,gn)end;gh()fQ()return gm end;if string.sub(bg,1,1)=="*"then d3=gk(true)else bm=gk(false)end end;local function go(gp,fO,gq,gr)local function gs(gl)if gl then gm=d3 else gm=bm end;if dbHud_1 or gq or gl then local dP=fN(fO)local gt={position=fO,name=gp,planetname=dP.name,gravity=b.g(),safe=gr}if not gq then gm[#gm+1]=gt else for dA,dl in pairs(e[0])do if dl.name and gp==dl.name then table.remove(e[0],dA)end end end;table.insert(e[0],gt)fQ()fY()bW="Location saved as "..gp.."("..dP.name..")"return gm else bW="Databank must be installed to save permanent locations"end end;if string.sub(gp,1,1)=="*"then d3=gs(true)else bm=gs(false)end end;local gu={}function gu.UpdateAtlasLocationsList()fQ()end;function gu.UpdateAutopilotTarget()fY()end;function gu.adjustAutopilotTargetIndex(gi)gh(gi)end;function gu.findAtlasIndex(fV,fW)return fU(fV,fW)end;function gu.UpdatePosition(gv,gw,gx)local function gy(gl)local gm;if gl then gm=d3 else gm=bm end;local gn=fU(gm)if gn~=-1 then if gv~=nil then if gl then gv="*"..gv end;gm[gn].name=gv;bi=bi-1;gh()elseif gx~=nil then if gx then local gz=ca;if gz<1000 then gz=1000 end;gm[gn].agg=fM(gz,0)bW=gm[gn].name.." AGG Altitude:"..gm[gn].agg.." saved ("..gm[gn].planetname..")"return elseif gx==false then gm[gn].agg=nil;bW=gm[gn].name.." AGG Altitude cleared ("..gm[gn].planetname..")"return end else local gA=gm[gn]if gw then gA.heading=cC:cross(cG)*5000;bW=gm[gn].name.." heading saved ("..gm[gn].planetname..")"return elseif gw==false then gA.heading=nil;bW=gm[gn].name.." heading cleared ("..gm[gn].planetname..")"return end;gA.gravity=b.g()gA.position=cI;gA.safe=true end;bW=gm[gn].name.." position updated ("..gm[gn].planetname..")"else bW="Name Not Found"end end;if string.sub(bg,1,1)=="*"then gy(true)else gy(false)end end;function gu.AddNewLocation(gp,fO,gq,gr)go(gp,fO,gq,gr)end;function gu.ClearCurrentPosition()gj()end;for dA,dl in pairs(d4)do table.insert(e[0],dl)end;if gB then for dA,dl in pairs(gB)do gu[dA]=dl end end;fQ()if bi>#cO then bi=0 end;gu.UpdateAutopilotTarget()return gu end;local function gC(b,a,c,library,radar_1,radar_2,eP,gD,dc,gE,db,gF,fL)local gG={}local gH={}local gI={XS=13,S=27,M=55,L=110,XL=221}local gJ={}local gK=0;local gL;local gM;local gN;local gO;local gP={}local gQ="Atmo"local gR;local gS;local gT=0;local gU={}local function gV()local function gW(gX,gY,gZ,g_,h0,h1,h2,h3)gY,g_,h1,h3=vec3(gY),vec3(g_),vec3(h1),vec3(h3)local h4,h5,h6=gX*gX,gZ*gZ,h0*h0;local fo=g_-gY;local h7=fo:normalize()local h8=fo:len()local h9=h1-gY;local ha=(h9-h9:project_on(h7)):normalize()local hb,hc=h9:dot(h7),h9:dot(ha)local hd=hb*hb+hc*hc;local he=h7:cross(ha)local hf=(h4-h5+h8*h8)/(2*h8)local hg=(h4-h6+hd-2*hb*hf)/(2*hc)local dn=h4-hf^2-hg^2;local hh=dc(dn)local hi=gY+h7*hf+ha*hg+he*hh;local hj=gY+h7*hf+ha*hg-he*hh;if eP((h3-hi):len()-h2)<eP((h3-hj):len()-h2)then return hi else return hj end end;local function hk(hl,fp,hm)local hn=hl.pts;local gn=#hn;local ho=hl.ref;if gn>3 then local hp,hq,hr,hs=hn[gn],hn[gn-1],hn[gn-2],hn[gn-3]hl.ref=hm;local fm=gW(hp[1],hp[2],hq[1],hq[2],hr[1],hr[2],hs[1],hs[2])local hf,hg,hh=fm.x,fm.y,fm.z;if hf==hf and hg==hg and hh==hh then hf=hf+ho[1]hg=hg+ho[2]hh=hh+ho[3]local ht=vec3(hf,hg,hh)hl.center=ht;if hl.lastPos then if(hl.lastPos-ht):len()<2 then local hu=(ht-vec3(hm)):len()if eP(hu-fp)<10 then hl.skipCalc=true end end end;hl.lastPos=ht end;hl.pts={}else local hv={hm[1]-ho[1],hm[2]-ho[2],hm[3]-ho[3]}hn[gn+1]={fp,hv}end end;if radar_1 or radar_2 then co.assignRadar()end;if gP[1]then gK=#gP[1].getConstructIds()local hw=gP[1].getData()local hx=hw:gmatch('{"constructId[^}]*}[^}]*}')if gK>0 then local hm={cI["x"],cI["y"],cI["z"]}local hy,hz=0,0;gO,gN=0,0;for dl in hx do local dK,c3,hA=dl:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hB=gI[hA]c3=db(c3)if gP[1].hasMatchingTransponder(dK)==1 then table.insert(gH,dK)end;if E then local hC=gP[1].getConstructType(dK)if hB>27 or F or hC=="static"or hC=="space"then gO=gO+1;local gp=gP[1].getConstructName(dK)local hl=gU[dK]if hl==nil then hB=hB+gF;gU[dK]={pts={},ref=hm,name=gp,i=0,radius=hB,skipCalc=false}hl=gU[dK]end;if not hl.skipCalc then hk(hl,c3,hm)if F and not hl.abandoned and gP[1].isConstructAbandoned(dK)==1 and hl.center then fL("abRdr","RD")a.print("Abandoned Construct: "..gp.." ("..hC..") rough ::pos{0,0,"..hl.center.x..","..hl.center.y..","..hl.center.z.."}")bW="Abandoned Radar Contact ("..hC..") detected"hl.abandoned=true end;hz=hz+1 else table.insert(gJ,hl)end end;hy=hy+1;if cS and hy>700 or hz>70 or(not cS and hy>300 or hz>30)then coroutine.yield()hy,hz=0,0 end end end;gN=#gJ;if gN>0 and(cF>20 or b3)then local ei,hD,hE,hF;local hG=0;local hH=ci:getPlanetarySystem(0)hF=cE:normalize()while hG<gN do coroutine.yield()local hI={table.unpack(gJ,hG,math.min(hG+75,gN))}ei,hD,hE=hH:castIntersections(cI,hF,nil,nil,hI,true)if ei and hE then cU={ei,hD,hE}break end;hG=hG+75 end;if not ei then cU=nil end else cU=nil end;gJ={}gL=hw:find('identifiedConstructs":%[%]')else gM=hw:find('worksInEnvironment":false')end end end;local function hJ()if gP[1]then gQ="Atmo"if gP[1].getData():find('worksInAtmosphere":false')then gQ="Space"end end end;function gG.pickType()hJ()end;function gG.assignRadar()if radar_1 and gP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gP[1]=radar_2 end;if gP[1]==radar_2 then hJ()end elseif radar_2 and gP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gP[1]=radar_1 end;if gP[1]==radar_1 then hJ()end end end;function gG.UpdateRadar()local hK=coroutine.status(gR)if hK=="suspended"then local dB,hL=coroutine.resume(gR)if hL then a.print("ERROR UPDATE RADAR: "..hL)end elseif hK=="dead"then gR=coroutine.create(gV)local dB,hL=coroutine.resume(gR)end end;function gG.GetRadarHud(hM,hN,hO,hP)local hQ=gH;local hR,hS;gH={}local ds=gN or 0;if gK>0 then if E then hS=ds.."/"..gO.." Plotted : "..gK-gO.." Ignored"else hS="Radar Contacts: "..gK end;hR=gE(hO,hP,hS,"pbright txtbig txtmid")if#gH>0 then hR=hR..gE(hM,hN,"Friendlies In Range","pbright txtbig txtmid")for dA,dl in pairs(gH)do hN=hN+20;hR=hR..gE(hM,hN,gP[1].getConstructName(dl),"pdim txtmid")end end;if gL==nil and gS==nil then gT=1;co.ToggleRadarPanel()end;if gL~=nil and gS~=nil then co.ToggleRadarPanel()end;if d2==nil then co.ToggleRadarPanel()end else if gM then hR=gE(hO,hP,gQ.." Radar: Jammed","pbright txtbig txtmid")else hR=gE(hO,hP,"Radar: No "..gQ.." Contacts","pbright txtbig txtmid")end;if d2~=nil then gT=0;co.ToggleRadarPanel()end end;return hR end;function gG.GetClosestName(gp)if gP[1]then local dK,dF=gP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dK~=nil and dK~=""then gp=gp.." "..gP[1].getConstructName(dK)end end;return gp end;function gG.ToggleRadarPanel()if d2~=nil and gT==0 then gD(d2)d2=nil;if gS~=nil then gD(gS)gS=nil end else if gT==1 then gD(d2)d2=nil;_autoconf.displayCategoryPanel(gP,1,"Periscope","periscope")gS=_autoconf.panels[_autoconf.panels_size]end;if d2==nil then _autoconf.displayCategoryPanel(gP,1,"Radar","radar")d2=_autoconf.panels[_autoconf.panels_size]end;gT=0 end end;function gG.ContactTick()if not hT then hT=0 end;if bJ>hT+10 then bW="Radar Contact"fL("rdrCon","RC")hT=bJ end;c.stopTimer("contact")end;function gG.onEnter(dK)if radar_1 and not c8 and not cP then c.setTimer("contact",0.1)end end;function gG.onLeave(dK)if radar_1 and E then if#gU>650 then dK=tostring(dK)gU[dK]=nil end end end;gP[1]=nil;if radar_1 then gP[1]=radar_1;hJ()end;gR=coroutine.create(gV)if hU then for dA,dl in pairs(hU)do gG[dA]=dl end end;return gG end;local function hV(shield_1,dV,bH)local hW={}local hX=shield_1.getResistancesCooldown()local function hY()local hZ=shield_1.getState()if G then if not cP and hZ==0 then shield_1.toggle()elseif cP and hZ==1 then shield_1.toggle()end end end;local function h_()local i0=shield_1.getStressRatioRaw()local i1=0.5999;if i0[1]==0.0 and i0[2]==0.0 and i0[3]==0.0 and i0[4]==0.0 then return end;local i2=shield_1.setResistances(i1*i0[1],i1*i0[2],i1*i0[3],i1*i0[4])if i2==1 then bW="Shield Resistances updated"else bW="Value Exceeded. Failed to update Shield Resistances"end end;function hW.shieldTick()d7=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())hY()hX=shield_1.getResistancesCooldown()if hX==0 and d7<a7 then h_()end end;function hW.setResist(i3)if not shield_1 then bW="No shield found"return elseif i3==nil or hX>0 then bW="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt=ds..', '..ds..', '..ds..', '..ds;local i4,i5,i6,i7=dV(i3,dt)if i7==nil or i4+i5+i6+i7>0.6 then bW="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(i4,i5,i6,i7)==1 then bW="Shield Resistances set"else bW="Resistance setting failed."end end;function hW.ventShield()local i8=shield_1.getVentingCooldown()if i8>0 then bW="Cannot vent again for "..i8 .." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()bW="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bW="Shields already at max hitpoints"end end;if i9 then for dA,dl in pairs(i9)do hW[dA]=dl end end;return hW end;local function ia(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ib,eP,bH,d9,ic,bI,id,ie,eK,bG,da,ig,fK,fJ,gD,ih,dc,fM,gE,fL,ii,ij,ik,il,im,io)local ip=9.80665;local iq={}local ir={}local is={}local it={}local iu=nil;local iv=nil;local iw=nil;local ix=false;local iy="none"local iz=""local iA=55;local iB=0;local iC=0;local iD=""local iE=nil;local iF=ac;local iG=ad;local iH=ae;local iI=[[rgb(]]..bH(iF+0.5)..","..bH(iG+0.5)..","..bH(iH+0.5)..[[)]]local iJ=[[rgb(]]..bH(iF*0.9+0.5)..","..bH(iG*0.9+0.5)..","..bH(iH*0.9+0.5)..[[)]]local iK=0;local iL=0;local iM=""local iN=bG()local iO=false;local iP=vec3({13771471,7435803,-128971})local iQ=18000000;local iR=500000;local iS,iT=math.huge;local iU;local function iV(iW)iS=vec3(iW):dist(iP)if iS<iQ then return true,eP(iS-iQ)end;iT=vec3(iW):dist(vec3(iX.center))if iT<iR then iU=true else iU=false end;if eP(iT-iR)<eP(iS-iQ)then return iU,eP(iT-iR)else return iU,eP(iS-iQ)end end;local function iY(dl)if cd==1920 then return dl else return fM(cd*dl/1920,0)end end;local function iZ(dl)if ce==1080 then return dl else return fM(ce*dl/1080,0)end end;local function i_()return ih()==0 and g~="keyboard"and ie()==0 end;local function j0()local j1="TRAVEL"if not cL then j1="CRUISE"end;if b0 then j1="AUTOPILOT"end;return j1 end;local hR=""local j2=""local j3=""local j4=1;local j5=2;local j6=3;local j7=4;local j8=5;local j9=6;local ja=""local jb=0;local jc=bH(1/aP)*2*aQ;local jd={}local je={}local jf={}local jg={}local jh={}local ji={}local jj={}jj["atmofueltank"],jj["spacefueltank"],jj["rocketfueltank"]=0,0,0;local jk=0;local function jl(hf,jm,jn,jo,jp,jq)local jr=jk;local js=jk+5;if not B then js=js+5 end;if ie()==1 and not l then jr=jr-50;js=js-50 end;if jn=="ATMO"then ja="atmofueltank"elseif jn=="SPACE"then ja="spacefueltank"else ja="rocketfueltank"end;jb=_G[ja.."_size"]if#jo>0 then for K=1,#jo do local gp=string.sub(jo[K][j5],1,12)local jt=0;for ju=1,jb do if jo[K][j5]==ic(c[ja.."_"..ju].getData()).name then jt=ju;break end end;local jv=bG()if jp[K]==nil or jq[K]==nil or jv-jo[K][j9]>jc then local jw;local jx=0;jx=id(jo[K][j4])-jo[K][j7]jw=jo[K][j8]if jw>jx then jj[ja]=jj[ja]+jw-jx end;if jt~=0 then jq[K]=ic(c[ja.."_"..jt].getData()).percentage;jp[K]=ic(c[ja.."_"..jt].getData()).timeLeft;if jp[K]=="n/a"then jp[K]=0 end else jq[K]=bH(0.5+jx*100/jo[K][j6])if jw<=jx then jp[K]=0 else jp[K]=bH(0.5+jx/((jw-jx)/(jv-jo[K][j9])))end end;jo[K][j9]=jv;jo[K][j8]=jx end;if gp==jm then gp=d9("%s %d",jn,K)end;if jt==0 then gp=gp.." *"end;local jy;if jp[K]==0 then jy=""else jy=il(jp[K])end;if jq[K]~=nil then local jz=bH(jq[K]*2.55)local jA=d9("rgb(%d,%d,%d)",255-jz,jz,0)local jB=""if jy~=""and jp[K]<120 or jq[K]<5 then jB="red "end;local jC=d9("rgb(%d,%d,%d)",da(bH((255-jz)/2.55),50,100),da(bH(jz/2.55),0,50),50)local jD="rgb(196,0,255)"if jn=="ATMO"then jD="rgb(0,188,255)"elseif jn=="SPACE"then jD="rgb(239,255,0)"end;local jE=false;if jF~=jD then jE=true end;jF=jD;if B then if jE then jr=jr-5;js=js-5 end;j2=j2 ..d9([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jC,jD,hf,js,jA,bH(jq[K]*1.7+0.5)-2,hf+1,js+1,hf+5,js+14,gp,jq[K],jy)jr=jr-22;js=js-22 else j2=j2 ..gE(hf,jr,gp,jB.."pdim txtfuel")j2=j2 ..gE(hf,js,d9("%d%% %s",jq[K],jy),"pdim txtfuel","fill:"..jA)jr=jr+30;js=js+30 end end end end;jk=jr end;local function jG(jH,dU)if am==0 and an==0 then return end;if dU<200000 and not c8 or dU and c8 then local jI=0;if eP(cH)>1 then jI=45*math.log(eP(cH),10)if cH<0 then jI=-jI end end;jH[#jH+1]=d9([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bH(cH),bH(jI))end;return jH end;local function jJ(jK)local gi=-cG;jK=jK-jK:project_on(gi)local jL=vec3(0,0,1)jL=jL-jL:project_on(gi)local jM=jL:cross(gi)local jI=jL:angle_between(jK)*constants.rad2deg;if jK:dot(jM)<0 then jI=360-jI end;return jI end;local function jN(jH,ai,aj,jO,jP,cS)if ab==0 then return end;local jQ=ab;local jR=20;local jS=bH(jO)if cS then for K=-45,45,5 do local jT=K;jH[#jH+1]=d9([[<g transform="rotate(%f,%d,%d)">]],jT,ai,aj)jU=5;if K%15==0 then jU=15 elseif K%10==0 then jU=10 end;jH[#jH+1]=d9([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jQ+jR-jU,ai,aj+jQ+jR)end;jH[#jH+1]=gE(ai,aj+jQ+jR-35,jP,"pdim txt txtmid")jH[#jH+1]=gE(ai,aj+jQ+jR-25,jS.." deg","pdim txt txtmid")jH[#jH+1]=d9([[<g transform="rotate(%f,%d,%d)">]],-jO,ai,aj)jH[#jH+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jQ+jR-20,ai+5,aj+jQ+jR-20,ai,aj+jQ+jR-15)jH[#jH+1]="</g>"end;jH[#jH+1]=[[<g style="clip-path: url(#headingClip);">]]local jV=jS;if cS then jV=jJ(cB)end;local jW=20;local jX=bH(jV)local jY=0;local jZ=aj+jQ+jR+20;local j_=ai;if jP~="YAW"then jZ=iZ(130)j_=iY(960)end;local k0=[[<path class="txttick line" d="]]local k1=bH(jX-(jW+10)-jX%5+0.5)for K=k1+70,k1,-5 do local hf=j_-(-K*5+jV*5)if K%10==0 then jY=10;local ds=K;if ds==360 then ds=0 elseif ds>360 then ds=ds-360 elseif ds<0 then ds=ds+360 end;jH[#jH+1]=gE(hf,jZ+15,ds,"txtmid bright")elseif K%5==0 then jY=5 end;if jY==10 then k0=d9([[%s M %f %f v %d]],k0,hf,jZ-5,jY)else k0=d9([[%s M %f %f v %d]],k0,hf,jZ-2.5,jY)end end;jH[#jH+1]=k0 ..[["/>]]jH[#jH+1]=d9([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],j_-5,jZ-20,j_+5,jZ-20,j_,jZ-10)if I then if cS then jP="HDG"end;jH[#jH+1]=gE(iY(960),iZ(100),jX.."Â°","dim txt txtmid size14","")jH[#jH+1]=gE(iY(960),iZ(85),jP,"dim txt txtmid size20","")end;jH[#jH+1]=[[</g>]]end;local function k2(jH,k3,jO,ai,aj,cS,k4,fg)if ab==0 then return end;local jQ=ab;local k5=bH(jQ*3/5)if jQ>0 then local k6=bH(k3)local jU=0;local k0=d9([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jO,ai,aj)if not c8 then k0=d9([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jH[#jH+1]=d9([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jQ-1,ai,aj)jH[#jH+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bH(k6-30-k6%5+0.5),bH(k6+30+k6%5+0.5),5 do if K%10==0 then jU=30 elseif K%5==0 then jU=20 end;local hg=aj+-K*5+k3*5;if jU==30 then k0=d9([[%s M %d %f h %d]],k0,ai-k5-jU,hg,jU)if c8 then jH[#jH+1]=d9([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jO,ai,aj,ai-k5+10,hg+4,K)jH[#jH+1]=d9([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jO,ai,aj,ai+k5-10,hg+4,K)if K==0 or K==180 or K==-180 then jH[#jH+1]=d9([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jO,ai,aj,ai-k5+20,hg,k5*2-40)end else jH[#jH+1]=gE(ai-k5+10,hg,K,"pdim txt txtmid")jH[#jH+1]=gE(ai+k5-10,hg,K,"pdim txt txtmid")end;k0=d9([[%s M %d %f h %d]],k0,ai+k5,hg,jU)else k0=d9([[%s M %d %f h %d]],k0,ai-k5-jU,hg,jU)k0=d9([[%s M %d %f h %d]],k0,ai+k5,hg,jU)end end;jH[#jH+1]=k0 ..[["/>]]local k7="PITCH"if not cS then k7="REL PITCH"end;if k3>90 and not c8 then k3=90-(k3-90)elseif k3<-90 and not c8 then k3=-90-(k3+90)end;if jQ>200 then if c8 then if fg>iA then jH[#jH+1]=gE(ai,aj-15,"Yaw","pdim txt txtmid")jH[#jH+1]=gE(ai,aj+20,k4,"pdim txt txtmid")end;jH[#jH+1]=d9([[<g transform="rotate(%f,%d,%d)">]],-jO,ai,aj)else jH[#jH+1]=d9([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jH[#jH+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k5+25,aj-5,ai-k5+20,aj,ai-k5+25,aj+5,ai-k5+50,aj+4,k6)jH[#jH+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k5-25,aj-5,ai+k5-20,aj,ai+k5-25,aj+5,ai+k5-30,aj+4,k6)jH[#jH+1]="</g>"end;local k8=bH(jQ/3)jH[#jH+1]=d9([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-k8,aj,jQ-k8)if not c8 and cS then jH[#jH+1]=d9([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jO,ai,aj,ai-k5+10,aj,k5*2-20)end;jH[#jH+1]="</g>"if jQ<200 then if c8 and fg>iA then jH[#jH+1]=gE(ai,aj-jQ,k7,"pdim txt txtmid")jH[#jH+1]=gE(ai,aj-jQ+10,k6,"pdim txt txtmid")jH[#jH+1]=gE(ai,aj-15,"Yaw","pdim txt txtmid")jH[#jH+1]=gE(ai,aj+20,k4,"pdim txt txtmid")else jH[#jH+1]=gE(ai,aj-jQ,k7,"pdim txt txtmid")jH[#jH+1]=gE(ai,aj-jQ+15,k6,"pdim txt txtmid")end end end end;local function k9(jH,dU,cS)local ka=ao;local kb=ap;if ka==0 and kb==0 then return end;local kc=78;local kd=19;local ke=c7;if c7~=-1 then jH[#jH+1]=gE(ka+kc,kb+kd+20,d9("AGL: %.1fm",c7),"pdim altsm txtend")end;if cS and(dU<200000 and not c8 or dU and c8)then table.insert(jH,d9([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ka-1,kb-4,kc+2,kd+6,ka+1,kb-1,kc-4,kd))local gn=0;local kf=1;local kg=0;local kh=dU<0;local ki=dU<iX.surfaceMaxAltitude;local kj=9;if kh then kj=0 end;local dU=eP(dU)while gn<6 do local kk=11;local kl=16;local km=9;local kn=14;local jB="altsm"if gn>2 then kl=kl+3;kk=kk+2;kn=kn+2;km=km-6;jB="altbig"end;if kh then jB=jB.." red"elseif ki then jB=jB.." orange"end;local ko=dU/kf%10;local kp=bH(ko)local kq=bH((kp+1)%10)local kr=kg;if gn==0 then kr=ko-kp;if kh then kr=1-kr end end;if kh and(gn==0 or kg~=0)then local gq=kq;kq=kp;kp=gq end;local ks=kl*(kr-1)local kt=ks+kl;local hf=ka+km+(6-gn)*kk;local hg=kb+kn;jH[#jH+1]=gE(hf,hg+ks,kq,jB)jH[#jH+1]=gE(hf,hg+kt,kp,jB)gn=gn+1;kf=kf*10;if kp==kj then kg=kr else kg=0 end end;table.insert(jH,[[</g></g>]])end end;local function ku(fl)local kv=-math.deg(eK(fl.y,fl.z))+180;kv=kv-90;if kv<0 then kv=360+kv end;if kv>180 then kv=-180+kv-180 end;return-kv end;local function kw(fl)local jV=math.deg(eK(fl.y,fl.x))-90;if jV<-180 then jV=360+jV end;return jV end;local function kx(jH,fl,fg,ai,aj)if fg>5 and not c8 or fg>iA then local jQ=ab;local ky=20;local kz=20;local kA=ku(fl)local kB=kw(fl)local kC=14;local kD=kC/2;local kE=-kB/kz*jQ;local kF=kA/ky*jQ;local hf=ai+kE;local hg=aj+kF;local c3=dc(kE^2+kF^2)local kG=[[<circle
                            cx="]]..hf..[["
                            cy="]]..hg..[["
                            r="]]..kD/kC..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hf..[["
                            cy="]]..hg..[["
                            r="]]..kD..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hf-kC..[[,]]..hg..[[ h ]]..kD..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hf+kD..[[,]]..hg..[[ h ]]..kD..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hf..[[,]]..hg-kC..[[ v ]]..kD..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c3<jQ then jH[#jH+1]=kG else local jI=eK(kF,kE)local kH=4;local kI=ai+jQ*math.cos(jI)local kJ=aj+jQ*math.sin(jI)jH[#jH+1]=d9('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jI*180/math.pi,kI,kJ,kI-kH,kJ-kH/2,kH*2,kH,kI+kH,kJ-kH,kH,kH,-kH,kH)end;if not c8 then local kK=vec3(fl)kA=ku(-kK)kB=kw(-kK)kE=-kB/kz*jQ;kF=kA/ky*jQ;hf=ai+kE;hg=aj+kF;c3=dc(kE^2+kF^2)if c3<jQ then local kL=[[<circle
                                    cx="]]..hf..[["
                                    cy="]]..hg..[["
                                    r="]]..kD..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hf..[[,]]..hg-kC..[[ v ]]..kD..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hf..[[,]]..hg..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hf..[[,]]..hg..[[)" />
                                <path
                                    d="M ]]..hf-kD..[[,]]..hg..[[ h ]]..kC..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hf..[[,]]..hg..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hf..[[,]]..hg..[[)"/>]]jH[#jH+1]=kL end end end end;local function kM(jH,j1,kN,kO)if ak==0 and al==0 then return end;kN=bH(kN+0.5)local jr=al+10;local js=al+20;if ie()==1 and not l then jr=55;js=65 end;local kP="CRUISE"local c="km/h"local dB=kO;if j1=="TRAVEL"or j1=="AUTOPILOT"then kP="THROT"c="%"dB=kN;local kQ="dim"if kN<0 then kQ="red"end;jH[#jH+1]=d9([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kQ,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eP(kN),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jH[#jH+1]=gE(ak+10,jr,kP,"pbright txtstart")jH[#jH+1]=gE(ak+10,js,d9("%.0f %s",dB,c),"pbright txtstart")if c8 and t and cL and bM then kN=bH(bN*100+0.5)local kQ="red"if kN<0 then kQ="red"end;jH[#jH+1]=d9([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kQ,1-eP(kN),ak-10,al+50,ak-15,al+53,ak-15,al+47)jH[#jH+1]=gE(ak+10,jr+40,"LIMIT","pbright txtstart")jH[#jH+1]=gE(ak+10,js+40,kN.."%","pbright txtstart")end;if c8 and t or b5 then jH[#jH+1]=gE(ak+10,jr-40,"LIMIT: "..cv.." km/h","dim txtstart")elseif not c8 and b0 then jH[#jH+1]=gE(ak+10,jr-40,"LIMIT: "..bH(_*3.6+0.5).." km/h","dim txtstart")end end;local function kR(jH,kS)if ak==0 and al==0 then return end;local kT=al-10;local kU=ak+10;jH[#jH+1]=gE(0,0,"","pdim txt txtend")if ie()==1 and not l then kT=75 end;jH[#jH+1]=gE(kU,kT,bH(kS).." km/h","pbright txtbig txtstart")end;local function kV(jH)jH[#jH+1]=gE(iY(1900),iZ(1070),d9("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jH[#jH+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jH[#jH+1]=gE(iY(960),iZ(550),"Warning: Invalid Control Scheme Detected","warnings")jH[#jH+1]=gE(iY(960),iZ(600),"Keyboard Scheme must be selected","warnings")jH[#jH+1]=gE(iY(960),iZ(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kW=iY(960)local kX=iZ(860)local kY=iZ(880)local kZ=iZ(900)local k_=iZ(960)local l0=iZ(200)local l1=iZ(250)local l2=iZ(960)if ie()==1 and not l then kX=iZ(135)kY=iZ(155)kZ=iZ(175)l0=iZ(115)l1=iZ(95)end;local l3="#222222"local l4="white"local l5="dimmer"local l6="pbright"local l7="#110000"local l8=l3;local l9=l5;if aY then local la=""if type(aY)=="string"then la="-"..aY end;jH[#jH+1]=gE(kW,kX,"Brake Engaged"..la,"warnings")l7="#440000"l8=l4;l9=l6 elseif bL>0 then jH[#jH+1]=gE(kW,kX,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local lb="#110000"local lc=l3;local ld=l5;if c8 and cu and c7==-1 then if not b0 and not bn and not b3 and not cK and not b6 and not b4 then jH[#jH+1]=gE(kW,l0+50,"** STALL WARNING **","warnings")lb="#ff0000"lc=l4;ld=l6;fL("stall","SW",2)end end;if cR then jH[#jH+1]=gE(kW,l0+90,"Flight Assist in Progress","warnings")end;if cc then jH[#jH+1]=gE(kW,l2,"Gyro Enabled","warnings")end;local le="#111100"local lf=l3;local lg=l5;if bj then le="#775500"lf=l4;lg=l6;if bP then jH[#jH+1]=gE(kW,kY,"Gear Extended","warn")else jH[#jH+1]=gE(kW,kY,"Landed (G: Takeoff)","warnings")end;local lh=ik(d:getTargetGroundAltitude())jH[#jH+1]=gE(kW,kZ,"Hover Height: "..lh,"warn")end;local li="#000011"local lj=l3;local lk=l5;if bY then li="#0000DD"lj=l4;lk=l6;jH[#jH+1]=gE(kW,k_+20,"ROCKET BOOST ENABLED","warn")end;local ll="#001100"local lm=l3;local ln=l5;if antigrav and not q and cK and bs~=nil then ll="#00DD00"lm=l4;ln=l6;local lo="warnings"if eP(ca-antigrav.getBaseAltitude())<501 then lo="warn"end;jH[#jH+1]=gE(kW,l0+40,d9("Target Altitude: %d Singularity Altitude: %d",bH(bs),bH(antigrav.getBaseAltitude())),lo)end;if b0 and bg~="None"then jH[#jH+1]=gE(kW,l0,"Autopilot "..bd,"warn")elseif bq~=nil then jH[#jH+1]=gE(kW,l0+20,d9("LockedPitch: %d",bH(bq)),"warn")elseif bU then jH[#jH+1]=gE(kW,l0+20,"Follow Mode Engaged","warn")elseif b5 or c6 then jH[#jH+1]=gE(kW,l0+20,"Re-entry in Progress","warn")end;if b2 or b6 then local lh=ik(b7,2)if b6 then if cK then lh=ik(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jH[#jH+1]=gE(kW,l0,"VTO to "..lh,"warn")elseif b4 and not bw then if c5 then jH[#jH+1]=gE(kW,l0,"Takeoff to "..bg,"warn")else jH[#jH+1]=gE(kW,l0,"Takeoff to "..lh,"warn")end;if aY and not b6 then jH[#jH+1]=gE(kW,l0+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jH[#jH+1]=gE(kW,l0,"Altitude Hold: "..d9("%.1fm",b7),"warn")end end;if b6 and(antigrav~=nil and antigrav)then if c9>0.1 then jH[#jH+1]=gE(kW,l0+20,"Beginning ascent","warn")elseif c9<0.09 and c9>0.05 then jH[#jH+1]=gE(kW,l0+20,"Aligning trajectory","warn")elseif c9<0.05 then jH[#jH+1]=gE(kW,l0+20,"Leaving atmosphere","warn")end end;if bw then if cw~=nil then jH[#jH+1]=gE(kW,l0,cw,"warn")end end;if b3 then if lp then local lq="Brake Landing"if d6 then lq=lq.."-Aligning"end;if d5 then lq=lq.."-Drift Limited"end;jH[#jH+1]=gE(kW,l0,lq,"warnings")else jH[#jH+1]=gE(kW,l0,"Coast-Landing","warnings")end end;if a_ then jH[#jH+1]=gE(kW,l0,"Prograde Alignment","crit")end;if aZ then jH[#jH+1]=gE(kW,l0,"Retrograde Alignment","crit")end;local lr="#110000"local ls=l3;local lt=l5;if cT then lr="#FF0000"ls=l4;lt=l6;local type;if string.find(cT,"COLLISION")then type="warnings"else type="crit"end;jH[#jH+1]=gE(kW,l1+20,cT,type)elseif c9==0 then local lu,lv=cn.checkLOS(cE:normalize())if lv~=nil then lt=l6;lr="#FF0000"ls=l4;local lh=ik(lv)local lw=cj.computeTravelTime(cF,0,lv)local lx="Collision"if lu.noAtmosphericDensityAltitude>0 then lx="Atmosphere"end;jH[#jH+1]=gE(kW,l1+20,lu.name.." "..lx.." "..il(lw).." In "..lh,"crit")end end;if bn and not bw then jH[#jH+1]=gE(kW,l0+60,ly,"warn")end;local lz="#111100"local lA=l3;local lB=l5;if cX and#cX>1 then lz="#DDDD00"lA=l4;lB=l6 end;local lC=iY;local lD=iZ;local l5="topButton"local lE="topButtonActive"local lF=l5;if b0 or bn or c5 or bw then lF=lE end;local lG=l5;if a_ then lG=lE end;local lH=l5;if b3 or bj then lH=lE end;local lI=l5;if b2 or bn then lI=lE end;local lJ=l5;if aZ then lJ=lE end;local lK=l5;if bw or cy and b0 then lK=lE end;if w and I then local lL=lD(30)jH[#jH+1]=d9([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lF,lC(960),lD(54),lD(-53),lC(-120),lC(25),lD(50))jH[#jH+1]=gE(lC(910),lL,"AUTOPILOT")jH[#jH+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lC(865),lD(51),lC(-25),lD(-50),lC(-110),lC(25),lD(46))jH[#jH+1]=gE(lC(800),lL,"PROGRADE")jH[#jH+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,lC(755),lD(47),lC(-25),lD(-46),lC(-98),lC(44),lD(44))jH[#jH+1]=gE(lC(700),lL,"LAND")jH[#jH+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lI,lC(960),lD(54),lD(-53),lC(120),lC(-25),lD(50))jH[#jH+1]=gE(lC(1010),lL,"ALT HOLD")jH[#jH+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lC(1055),lD(51),lC(25),lD(-50),lC(110),lC(-25),lD(46))jH[#jH+1]=gE(lC(1122),lL,"RETROGRADE")jH[#jH+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lK,lC(1165),lD(47),lC(25),lD(-46),lC(98),lC(-44),lD(44))jH[#jH+1]=gE(lC(1220),lL,"ORBIT")jH[#jH+1]=[[
                                    </g>
                                </g>]]jH[#jH+1]="</g>"end;return jH end;local function lM(fg)return bH(fM(fg*3.6,0)+0.5).." km/h"end;local function lN(gn)local gp=bg;if gn~=nil and type(gn)=="number"then if gn==0 then return"None"end;gp=cO[gn].name end;if gp==nil then gp=fX.name end;if gp==nil then gp="None"end;return gp end;local function lO(jH)local lP=cn.routeWP(true)if not lP or#lP==0 then return end;local hf=iY(750)local hg=iZ(360)if b0 or bn then jH[#jH+1]=gE(hf,hg,"REMAINING ROUTE","pdim txtstart size20")else jH[#jH+1]=gE(hf,hg,"LOADED ROUTE","pdim txtstart size20")end;for dA,K in pairs(lP)do hg=hg+20;jH[#jH+1]=gE(hf,hg,dA..". "..lP[dA],"pdim txtstart size20")end end;local function lQ(jH)local hf=aw+10;local hg=ax+20;local lR={}local lS={"Alt-4: AutoTakeoff to Target"}local lT={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lU={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lV={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lR,"--------------DYNAMIC-----------------")if c8 then if c7~=-1 then ii(lR,lS)if c0 and iX and c0.name==iX.name then table.insert(lR,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aX then if antigrav then if cK then table.insert(lR,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lR,"Turn on AGG to takeoff to AGG Height")end end;if aX then table.insert(lR,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lR,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lR,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bj then table.insert(lR,"G: Takeoff to hover height, raise gear")else table.insert(lR,"G: Lowergear and Land")end else ii(lR,lT)table.insert(lR,"G: Begin BrakeLanding or Land")end;if b6 then table.insert(lR,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ii(lR,lU)if shield_1 then table.insert(lR,"Alt-Shift-6: Vent shields")if not G then table.insert(lR,"Alt-Shift-7: Toggle shield off/on")end end end;if fX~=nil then table.insert(lR,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lR,"Alt-9: Activate Gyroscope")end;if aT~="none"or aS~="none"or aU~="none"then table.insert(lR,"Alt-Shift-9: Cycles engines with Extra tags")end;if b2 then table.insert(lR,"Alt-Spacebar/C will raise/lower target height")table.insert(lR,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c8 then table.insert(lR,"LALT+Mousewheel will lower/raise speed limit")end;ii(lR,lV)for K=1,#lR do hg=hg+12;jH[#jH+1]=gE(hf,hg,lR[K],"pdim txtbig txtstart")end end;local function lW(jH)local lX=aw;local lY=ax;local lZ=av;local l_=4;local m0=15;local hf=0;local hg=0;local m1,m2,m3,m4;local m5;local function m6(type)local gz,bJ,fg,m7,jB,m8;if type=="Periapsis"then gz=m5.periapsis.altitude;bJ=m5.timeToPeriapsis;fg=m5.periapsis.speed;jB="txtend"m7=12;m8=math.min(hf,lX+lZ-iX.radius/m3-l_*2)else gz=m5.apoapsis.altitude;bJ=m5.timeToApoapsis;fg=m5.apoapsis.speed;m7=-12;jB="txtstart"m8=hf end;if cF<1 then bJ=0 end;jH[#jH+1]=d9([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m8+m7,hg-5,hf,hg-5)jH[#jH+1]=d9([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m8-m7*4,hg+2,hf,hg+2)jH[#jH+1]=gE(m8,hg,type,jB)hf=m8-m7*2;hg=hg+m0;local lh=ik(gz)jH[#jH+1]=gE(hf,hg,lh,jB)hg=hg+m0;jH[#jH+1]=gE(hf,hg,il(bJ),jB)hg=hg+m0;jH[#jH+1]=gE(hf,hg,lM(fg),jB)end;local m9=lZ*1.5;if bE=="INFO"then m9=25*9 end;if bE~="HIDE"then jH[#jH+1]=[[<g class="pbright txtorb txtmid">]]jH[#jH+1]=d9('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lZ*2,m9,lX,lY)jH[#jH+1]=d9([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lZ*2,m9,lX,lY)end;local ma=lZ*1.5;local mb=lZ*2;local mc=ma/2;local md=lZ;local me=lX+md;local mf=lY+mc;local mg=lX+mb;local mh=lY+ma;if bE=="ORBIT"then lY=lY+l_;m1=lZ/2;m4=0;m5={}m5.periapsis={}m5.apoapsis={}if fk~=nil then if fk.periapsis~=nil then m5.periapsis.altitude=fk.periapsis.altitude;m5.periapsis.speed=fk.periapsis.speed end;if fk.apoapsis~=nil then m5.apoapsis.altitude=fk.apoapsis.altitude;m5.apoapsis.speed=fk.apoapsis.speed end;m5.period=fk.period;m5.eccentricity=fk.eccentricity;m5.timeToApoapsis=fk.timeToApoapsis;m5.timeToPeriapsis=fk.timeToPeriapsis;m5.eccentricAnomaly=fk.eccentricAnomaly;m5.trueAnomaly=fk.trueAnomaly end;if m5.periapsis==nil then m5.periapsis={}m5.periapsis.altitude=-iX.radius;m5.periapsis.speed=_ end;if m5.eccentricity==nil then m5.eccentricity=1 end;if m5.apoapsis==nil then m5.apoapsis={}m5.apoapsis.altitude=ca;m5.apoapsis.speed=0 end;if cF<1 then m5.apoapsis.altitude=ca;m5.apoapsis.speed=0 end;if m5.apoapsis.altitude then m3=(m5.apoapsis.altitude+m5.periapsis.altitude+iX.radius*2)/(m1*2)m2=(iX.radius+m5.apoapsis.altitude)/m3*(1-m5.eccentricity)m4=m1-m5.periapsis.altitude/m3-iX.radius/m3;local mi=math.pi;if m5.period~=nil and m5.period>0 and m5.timeToApoapsis~=nil then mi=m5.eccentricAnomaly;if m5.timeToPeriapsis<m5.timeToApoapsis then mi=2*math.pi-mi end end;if cF<1 or mi~=mi then mi=math.pi end;local mj=-m1*math.cos(mi)+lX+md+l_;local mk=m2*math.sin(mi)+lY+mc+l_;local ml=""jH[#jH+1]='<g clip-path="url(#orbitRect)">'jH[#jH+1]=d9([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ml,lX+lZ+l_,lY+lZ*1.5/2+l_,m1,m2)if m2<1 then jH[#jH+1]=d9([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lX+lZ+l_-m4,lY+lZ*1.5/2+l_,mj,mk)end;jH[#jH+1]=d9('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,(iX.radius+iX.noAtmosphericDensityAltitude)/m3)jH[#jH+1]=d9('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,(iX.radius+iX.noAtmosphericDensityAltitude)/m3)jH[#jH+1]=d9([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lX+lZ+l_,lY+lZ*1.5/2+l_,m1,m2)jH[#jH+1]=d9('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,iX.radius/m3)jH[#jH+1]='</g>'local mm=math.floor(iX.radius/m3+0.5)hf=lX+lZ+l_*4+m1;hg=lY+lZ*1.5/2+5+l_;if m5.apoapsis~=nil and m5.apoapsis.speed<_ then m6("Apoapsis")end;hg=lY+lZ*1.5/2+5+l_;hf=lX+lZ-l_*2-m1;if m5.periapsis~=nil and m5.periapsis.speed<_ and m5.periapsis.altitude>0 then m6("Periapsis")end;jH[#jH+1]=gE(lX+lZ+l_,lY+20+l_,iX.name,"txtorbbig")jH[#jH+1]=d9('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mj,mk)jH[#jH+1]=[[</g>]]return jH else jH[#jH+1]='<g clip-path="url(#orbitRect)">'local mn=""local mo=1.2*(mp-mq)/(lZ*2)local mr=1.4*(ms-mt)/(lZ*1.5)for dA,dl in pairs(e[0])do if dl.center then local hf=lX+lZ+dl.center.x/mo;local hg=lY+lZ*1.5/2+dl.center.y/mr;mn=mn..'<circle cx="'..hf..'" cy="'..hg..'" r="'..dl.radius/mo*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dl.name,"Moon")and not string.match(dl.name,"Sanctuary")and not string.match(dl.name,"Space")then mn=mn.."<text x='"..hf.."' y='"..hg+dl.radius/mo*30+20 .."' font-size='12' fill="..iI.." text-anchor='middle' font-family='Montserrat'>"..dl.name.."</text>"end end end;local fm=vec3(b.getConstructWorldPos())local hf=lX+lZ+fm.x/mo;local hg=lY+lZ*1.5/2+fm.y/mr;mn=mn..'<circle cx="'..hf..'" cy="'..hg..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mn=mn.."<text x='"..hf.."' y='"..hg-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iu=mo;iv=mr;local mu=fm+cE*1000000;local mv=lX+lZ+mu.x/mo;local js=lY+lZ*1.5/2+mu.y/mr;mn=mn..'<line x1="'..hf..'" y1="'..hg..'" x2="'..mv..'" y2="'..js..'" stroke="purple" stroke-width="1"/>'jH[#jH+1]=mn;jH[#jH+1]='</g>'end elseif bE=="INFO"then jH=cl.DrawOdometer(jH,iK,bk,iL)elseif bE=="HELP"then jH=lQ(jH)elseif bE=="SCOPE"then jH[#jH+1]='<g clip-path="url(#orbitRect)">'local mw=c_;if c9>0 then table.sort(cZ,function(eq,er)local es,et=eq.center,er.center;return(es.x-cI.x)^2+(es.y-cI.y)^2+(es.z-cI.z)^2<(et.x-cI.x)^2+(et.y-cI.y)^2+(et.z-cI.z)^2 end)end;local gM={}local mx={}local my=120;local mz=nil;local mA=nil;for K,dl in ipairs(cZ)do local gL=dl.center-cI;local mB=gL:len()local mC=gL:normalize()local mD=gL:cross(cB):normalize()local mE=math.acos(mD:dot(cC))if mE~=mE then mE=0 end;if mD:cross(cC):dot(cB)<0 then mE=-mE end;local mF=gL:project_on_plane(cB):len()local mG=math.sin(mE)*math.asin(mF/mB)*constants.rad2deg;local mH=math.cos(mE)*math.asin(mF/mB)*constants.rad2deg;if mC:dot(cB)<0 then mH=90*math.cos(mE)+90*math.cos(mE)-mH;mG=90*math.sin(mE)+90*math.sin(mE)-mG end;local hf=me+mG/mw*ma;local hg=mf+mH/mw*ma;local mI=(hf-me)*(hf-me)+(hg-mf)*(hg-mf)local mJ=math.asin((dl.radius+dl.surfaceMaxAltitude)/mB)*constants.rad2deg;if mJ~=mJ then mJ=mw end;local hA=mJ/mw*ma;local mK=math.asin(dl.atmosphereRadius/mB)*constants.rad2deg;if mK~=mK then mK=mJ end;local mL=mK/mw*ma;local c3=ik(mB,1)local mM=dl.name;local mN=false;if hg>lY then if hg>mh then if hg-mL<=mh then mN=true end else mN=true end else if hg+mL>=lY then mN=true end end;local mO=false;local mP=hf;if dl.systemId==0 then mP=hf+my else mP=hf-my end;if mP+my>lX then if mP+my>mg then if mP-mL-my<=mg then mO=true end else mO=true end else if mP+mL+my>=lX then mO=true end end;local mQ={}mQ.x=hf;mQ.y=hg;mQ.planet=dl;mQ.atmoSize=mL;if not mz or mI<mz then mz=mI;mA=mQ end;if mO and mN then local mR=math.max(mL,5)if mI<mR*mR then mM=mM.." - "..c3 end;mQ.size=hA;mQ.i=K;mQ.displayString=mM;mQ.distance=c3;mQ.visible=true;mx[#mx+1]=mQ else mQ.visible=false end end;local mS=false;table.sort(mx,function(es,et)return es.y<et.y end)for dA,fp in ipairs(mx)do local dl,hA,K,mL,hf,hg,mM,c3=fp.planet,fp.size,fp.i,fp.atmoSize,fp.x,fp.y,fp.displayString,fp.distance;local m8,mT,mU,mV;local mW=15;local jB="pdim"if dl.systemId~=0 then mU=iY(string.len(mM)*5)mW=-(15+mU)mV=iZ(10)jB="pdimfill"else mU=iY(string.len(mM)*9)mV=iZ(15)end;if hA*2>mU then m8=da(hf,lX+mU/2,mg-mU/2)mT=da(hg,lY+mV,mh-5)m8=da(m8,hf-hA+mU/2,hf+hA-mU/2)mT=da(mT,hg-hA+mV,hg+hA)else m8=hf+mW;mT=hg end;for mX,fp in pairs(gM)do local mY=fp.textPositions;local mZ=mY.y-mT;if mX~=K and eP(mZ)<mY.height and mY.x+mY.width>m8 and mY.x<m8+mU then if hA>mU then mT=da(mT+mV,lY+15,mh-5)else mT=mY.y+mY.height+1 end end end;local m_=mM~=dl.name or m8<=me and m8+mU>=me and mT-mV<=mf and mT>=mf;fp.hovered=m_;local n0=1;if m_ then n0=2;if hA*2<mU then n0=10 end;if mM==dl.name then mM=mM.." - "..c3 end;jB="pbright"if dl.systemId~=0 then mU=iY(string.len(mM)*5)mW=-(15+mU)else mU=iY(string.len(mM)*7)end;if hA*2>mU then m8=da(hf,lX+mU/2,mg-mU/2)m8=da(m8,hf-hA+mU/2,hf+hA-mU/2)else m8=hf+mW end end;gM[K]={}gM[K].textPositions={}gM[K].textPositions.y=mT;gM[K].textPositions.x=m8;gM[K].textPositions.width=mU;gM[K].textPositions.height=mV;gM[K].output=""if hA*2>mU then jB=jB.." txtmid"else jB=jB.." txtstart"end;if mL-hA>2 then gM[K].output=d9('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hf,hg,mL,iJ,0.1*n0)end;gM[K].output=gM[K].output..d9('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hf,hg,hA,iJ,0.2*n0)if dl.systemId==0 then gM[K].output=gM[K].output..d9([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m8,mT,iI,jB,mM)if hA*2<=mU then gM[K].output=gM[K].output..d9("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m8+mU,mT+2,m8,mT+2,hf,hg)end else gM[K].output=gM[K].output..d9([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m8,mT,iJ,jB,mM)if hA*2<=mU then gM[K].output=gM[K].output..d9("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m8,mT+2,m8+mU,mT+2,hf,hg)end end end;for dA=#cZ,1,-1 do if gM[dA]then jH[#jH+1]=gM[dA].output end end;if mA~=nil and c_<90 and not mA.hovered then local n1=mA.planet.atmosphereRadius/mA.atmoSize;local n2=dc(mz)*n1;local n3=ik(n2,1)local mU=iY(math.max(string.len(n3)*7,string.len(mA.planet.name)*7))local mV=iZ(12)local m8=da(mA.x+(me-mA.x)/2,lX+mU/2,mg-mU/2)local mT=da(mA.y+(mf-mA.y)/2,lY+mV*2,mh-5)jH[#jH+1]=d9("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mA.x,mA.y,me,mf)jH[#jH+1]=d9([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m8,mT,"white",n3)if not mA.visible then jH[#jH+1]=d9([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m8,mT-mV,"white",mA.planet.name)end end;if cF>1 then local gL=cE;local mC=gL:normalize()local mF=gL:project_on_plane(cB):len()local mD=gL:cross(cB):normalize()local mE=math.acos(mD:dot(cC))if mE~=mE then mE=0 end;if mD:cross(cC):dot(cB)<0 then mE=-mE end;local mG=math.sin(mE)*math.asin(mF/gL:len())*constants.rad2deg;local mH=math.cos(mE)*math.asin(mF/gL:len())*constants.rad2deg;if mC:dot(cB)<0 then mH=90*math.cos(mE)+90*math.cos(mE)-mH;mG=90*math.sin(mE)+90*math.sin(mE)-mG end;local hf=me+mG/mw*ma;local hg=mf+mH/mw*ma;local kC=14;local kD=kC/2;local kG=[[<circle
                                    cx="]]..hf..[["
                                    cy="]]..hg..[["
                                    r="]]..kD/kC..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hf..[["
                                    cy="]]..hg..[["
                                    r="]]..kD..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hf-kC..[[,]]..hg..[[ h ]]..kD..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hf+kD..[[,]]..hg..[[ h ]]..kD..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hf..[[,]]..hg-kC..[[ v ]]..kD..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jH[#jH+1]=kG end;jH[#jH+1]=d9("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",me,mf-10,me,mf+10)jH[#jH+1]=d9("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",me-10,mf,me+10,mf)jH[#jH+1]='</g>'else return jH end end;local function n4(n5,n6)local n7;local n8=(n6-n5):normalize()local fn=(cI-n5):dot(n8)/n8:dot(n8)if fn<=0. then return(cI-n5):len()elseif fn>=(n6-n5):len()then return(cI-n6):len()end;local n9=n5+fn*n8;n7=(n9-cI):len()return n7 end;local function na()local n7;local nb=nil;local nc=nil;local nd=nil;for dA,ne in pairs(e[0])do if ne.hasAtmosphere then local c3=n4(iX.center,ne.center)if nb==nil or c3<nb then nc=ne;nb=c3;nd=iX end;if c0 and c0.hasAtmosphere and c0.name~=iX.name then local eF=n4(c0.center,ne.center)if eF<nb then nc=ne;nb=eF;nd=c0 end end end end;local nf=iY(1770)local ng=iZ(330)if nb then local nh="txttick "local ni=500000;if nb<nc.radius+ni or nb<nd.radius+ni then if cP then nh="txttick red "else nh="txttick orange "end end;n7=ik(nb,2)iz=gE(nf,ng,"Pipe ("..nd.name.."--"..nc.name.."): "..n7,nh.."pbright txtmid")end end;local function nj(hf,hg,nk,nl,kP)local nm={x=hf,y=hg,width=nk,height=nl,label=kP}it[kP]=nm;return nm end;local function nn(no,np,nk,nl,hf,hg,nq,nr,ns,nt,jB)local nm={enableName=no,disableName=np,width=nk,height=nl,x=hf,y=hg,toggleVar=nq,toggleFunction=nr,drawCondition=ns,hovered=false,class=jB}if nt then table.insert(is,nm)else table.insert(ir,nm)end;return nm end;local function nu(nv)if not ix then nw=false;nx=false;ny=false;w=true;return elseif nv=="handling"then nw=not nw;nx=false;ny=false elseif nv=="hud"then nx=not nx;nw=false;ny=false elseif nv=="physics"then ny=not ny;nw=false;nx=false end;if ny or nx or nw then iy=ij(nv)w=false else iy="none"w=true end end;local function nz()ix=not ix;if ix then iq=is;bW="Hold SHIFT to see Settings"d0=w else iq=ir;bW="Hold SHIFT to see Control Buttons"nu()w=d0 end end;local function nA()local function nB(dl,dA)dl.set(not dl.get())if dl.get()then bW=dA.." set to true"else bW=dA.." set to false"end;if dA=="showHud"then d0=dl.get()elseif dA=="BrakeToggleDefault"then aW=j end end;local nC=50;local nD=340;local hf=500;local hg=ce/2-400;local nE=0;for dA,dl in pairs(ij("boolean"))do if type(dl.get())=="boolean"then nn(dA,dA,nD,nC,hf,hg,function()return dl.get()end,function()nB(dl,dA)end,function()return true end,true)hg=hg+nC+20;if nE==9 then hf=hf+nD+20;hg=ce/2-400;nE=0 else nE=nE+1 end end end;nn("Control View","Control View",nD,nC,10,ce/2-500,function()return true end,nz,function()return true end,true)nn("View Handling Settings",'Hide Handling Settings',nD,nC,10,ce/2-(500-nC),function()return nw end,function()nu("handling")end,function()return true end,true)nn("View Hud Settings",'Hide Hud Settings',nD,nC,10,ce/2-(500-nC*2),function()return nx end,function()nu("hud")end,function()return true end,true)nn("View Physics Settings",'Hide Physics Settings',nD,nC,10,ce/2-(500-nC*3),function()return ny end,function()nu("physics")end,function()return true end,true)end;local function nF()local function go()local fO=cI;local gp=iX.name..". "..#bm;if radar_1 then gp=co.GetClosestName(gp)end;return cm.AddNewLocation(gp,fO,false,true)end;local function nG()b1=not b1 end;local function nH(nI)if nI==1 then a_=not a_;aZ=false else aZ=not aZ;a_=false end;b0=false;b2=false;bU=false;b3=false;bq=nil;b5=false;b4=false end;local function nJ(nK,nL)cm.UpdatePosition(nil,nK,nL)end;local function gj()cm.ClearCurrentPosition()end;local function nM(gn)local lP=cn.routeWP(true)if lP and#lP>0 then return"Engage Route: "..lP[1]end;return"Engage Autopilot: "..lN(gn)end;local function nN(gn)local lP=cn.routeWP(true)if lP and#lP>0 then return"Next Route Point: "..lP[1]end;return"Disable Autopilot: "..lN(gn)end;local function nO()if ie()==1 then bU=not bU;if bU then b0=false;aZ=false;a_=false;b2=false;b5=false;b3=false;b4=false;nP=bj;bj=false;d.control.retractLandingGears()ig:setTargetGroundAltitude(X)fL("folOn","F")else fL("folOff","F")aY="Follow Off"ct=p;bj=nP;if bj then d.control.extendLandingGears()ig:setTargetGroundAltitude(Y)end end else bW="Follow Mode only works with Remote controller"bU=false end end;local nC=50;local nD=260;local nQ=iY(30)local nR=aw+av*2+2;local nS=ax+1;nn("+","+",nQ,nQ,nR,nS+nQ+1,function()return false end,function()c_=c_/8 end,function()return bE=="SCOPE"end,nil,"ZoomButton")nn("-","-",nQ,nQ,nR,nS,function()return false end,function()c_=math.min(c_*8,90)end,function()return bE=="SCOPE"end,nil,"ZoomButton")nn("0","0",nQ,nQ,nR,nS+nQ*2+2,function()return false end,function()c_=90 end,function()return bE=="SCOPE"and c_~=90 end,nil,"ZoomButton")local nT=nn("Enable Brake Toggle","Disable Brake Toggle",nD,nC,cd/2-nD/2,ce/2+350,function()return aW end,function()aW=not aW;if aW then bW="Brakes in Toggle Mode"else bW="Brakes in Default Mode"end end)nn("Align Prograde","Disable Prograde",nD,nC,cd/2-nD/2-50-nT.width,ce/2-nC+380,function()return a_ end,function()nH(1)end)nn("Align Retrograde","Disable Retrograde",nD,nC,cd/2-nD/2+nT.width+50,ce/2-nC+380,function()return aZ end,nH,function()return c9==0 end)nU=nn(nM,nN,600,60,cd/2-600/2,ce/2-60/2-330,function()return b0 or bn or c5 or bw end,function()end)local K;local function nV(nW)local gn=cW+nW;if gn>#cO then gn=gn-#cO-1 end;if gn<0 then gn=#cO+gn end;return gn end;nX={}for K=0,10 do local nY=nn(function(et)local gn=nV(et.apExtraIndex)if b0 or bn or c5 or bw then return"Redirect: "..lN(gn)end;return nM(gn)end,function(et)local gn=nV(et.apExtraIndex)return nN(gn)end,600,60,cd/2-600/2,ce/2-60/2-330+60*K,function(et)local gn=nV(et.apExtraIndex)return gn==bi and(b0 or bn or c5 or bw)end,function(et)local gn=nV(et.apExtraIndex)local nZ=bi==gn;bi=gn;cm.UpdateAutopilotTarget()cn.ToggleAutopilot()if not nZ and not(b0 or bn or c5 or bw)then cn.ToggleAutopilot()end end,function()return cV and(#cn.routeWP(true)==0 or K==0)end)nY.apExtraIndex=K;nX[K]=nY end;nn("Save Position","Save Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,go,function()return bi==0 or fX==nil end)nn("Update Position","Update Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,function()nJ(nil)end,function()return bi>0 and fX~=nil end)nn("Save Heading","Clear Heading",200,nU.height,nU.x+nU.width+30,nU.y+nU.height+20,function()return fX.heading~=nil end,function()if fX.heading~=nil then nJ(false)else nJ(true)end end,function()return bi>0 and fX~=nil end)nn("Save AGG Alt","Clear AGG Alt",200,nU.height,nU.x+nU.width+30,nU.y+nU.height*2+40,function()return fX.agg~=nil end,function()if fX.agg~=nil then nJ(nil,false)else nJ(nil,true)end end,function()return bi>0 and fX~=nil and antigrav end)nn("Clear Position","Clear Position",200,nU.height,nU.x-200-30,nU.y,function()return true end,gj,function()return bi>0 and fX~=nil end)nn("Save Route","Save Route",200,nU.height,nU.x-200-30,nU.y+nU.height*2+40,function()return false end,function()cn.routeWP(false,false,2)end,function()return#cn.routeWP(true)>0 end)nn("Load Route","Clear Route",200,nU.height,nU.x-200-30,nU.y+nU.height+20,function()return#cn.routeWP(true)>0 end,function()if#cn.routeWP(true)>0 then cn.routeWP(false,true)elseif b0 or bn then bW="Disable Autopilot before loading route"return else cn.routeWP(false,false,1)end end,function()return true end)nC=60;nD=300;local hf=0;local hg=ce/2-150;nn("Enable Check Damage","Disable Check Damage",nD,nC,hf,hg-nC-20,function()return s end,function()s=not s end)nn("View Settings","View Settings",nD,nC,hf,hg,function()return true end,nz)hg=hg+nC+20;nn("Enable Turn and Burn","Disable Turn and Burn",nD,nC,hf,hg,function()return b1 end,nG)hf=10;hg=ce/2-300;nn("Horizontal Takeoff Mode","Vertical Takeoff Mode",nD,nC,hf+nD+20,hg,function()return aX end,function()aX=not aX;if aX then bW="Vertical Takeoff Mode"else bW="Horizontal Takeoff Mode"end end,function()return cJ end)hg=hg+nC+20;nn("Engage Orbiting","Cancel Orbiting",nD,nC,hf+nD+20,hg,function()return bw end,cn.ToggleIntoOrbit,function()return c9==0 and cS end)hg=ce/2-150;nn("Glide Re-Entry","Cancel Glide Re-Entry",nD,nC,hf+nD+20,hg,function()return b5 end,function()c4=1;nH(1)end,function()return iX.hasAtmosphere and not c8 end)hg=hg+nC+20;nn("Parachute Re-Entry","Cancel Parachute Re-Entry",nD,nC,hf+nD+20,hg,function()return b5 end,function()c4=2;nH(1)end,function()return iX.hasAtmosphere and not c8 end)hg=hg+nC+20;nn("Engage Follow Mode","Disable Follow Mode",nD,nC,hf,hg,function()return bU end,nO,function()return ie()==1 end)nn("Enable Repair Arrows","Disable Repair Arrows",nD,nC,hf+nD+20,hg,function()return iO end,function()iO=not iO;if iO then bW="Repair Arrows Enabled"else bW="Repair Arrows Diabled"end end,function()return ie()==1 end)hg=hg+nC+20;if not q then nn("Enable AGG","Disable AGG",nD,nC,hf,hg,function()return cK end,cn.ToggleAntigrav,function()return antigrav~=nil end)end;nn(function()return d9("Switch IPH Mode - Current: %s",bx)end,function()return d9("IPH Mode: %s",bx)end,nD*2,nC,hf,hg,function()return false end,function()if bx=="All"then bx="Custom Only"elseif bx=="Custom Only"then bx="No Moons"else bx="All"end;bW="IPH Mode: "..bx end)hg=hg+nC+20;nn(function()return d9("Toggle Control Scheme - Current: %s",g)end,function()return d9("Control Scheme: %s",g)end,nD*2,nC,hf,hg,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bW="New Control Scheme: "..g end)local n_=iZ(20)local nY=nj(0,0,iY(70),n_,"HELP")nY=nj(nY.x+nY.width,nY.y,iY(80),n_,"INFO")nY=nj(nY.x+nY.width,nY.y,iY(70),n_,"ORBIT")nY=nj(nY.x+nY.width,nY.y,iY(70),n_,"SCOPE")nj(nY.x+nY.width,nY.y,iY(70),n_,"HIDE")end;local o0={}local o1=nil;function o0.HUDPrologue(jH)cP,cQ=iV(cI)if not cP then iF=af;iG=ag;iH=ah else iF=ac;iG=ad;iH=ae end;iI=[[rgb(]]..bH(iF+0.6)..","..bH(iG+0.6)..","..bH(iH+0.6)..[[)]]iJ=[[rgb(]]..bH(iF*0.8+0.5)..","..bH(iG*0.8+0.5)..","..bH(iH*0.8+0.5)..[[)]]local o2=iI;local o3=iJ;local o4=[[rgb(]]..bH(iF*0.4+0.5)..","..bH(iG*0.4+0.5)..","..bH(iH*0.4+0.5)..[[)]]local o5=iI;local o6=iJ;local o7=o4;if i_()and not m then o2=[[rgb(]]..bH(iF*0.5+0.5)..","..bH(iG*0.5+0.5)..","..bH(iH*0.5+0.5)..[[)]]o3=[[rgb(]]..bH(iF*0.3+0.5)..","..bH(iG*0.3+0.5)..","..bH(iH*0.2+0.5)..[[)]]o4=[[rgb(]]..bH(iF*0.2+0.5)..","..bH(iG*0.2+0.5)..","..bH(iH*0.2+0.5)..[[)]]end;local lC=iY;local lD=iZ;jH[#jH+1]=d9([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o2,o2,o2,o5,o5,o3,o3,o6,o6,o3,o2,o4,o6,o2,o2,o4,o4,o7,o4,cd,ce,o3,o3,o3,o3,o3,o5,o3,o6,o7,o6,o6,o7)if not o1 then o1=d9([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lC(630),lD(0),lC(675),lD(45),lC(960),lD(55),lC(1245),lD(45),lC(1290),lD(0),lC(1000),lD(105),lC(1040),lD(59),lC(1250),lD(51),lC(1300),lD(0),lC(1920),lD(0),lC(1920),lD(20),lC(1400),lD(20),lC(1300),lD(105),lC(920),lD(105),lC(880),lD(59),lC(670),lD(51),lC(620),lD(0),lC(0),lD(0),lC(0),lD(20),lC(520),lD(20),lC(620),lD(105),lC(890),lD(59),lC(960),lD(62),lC(1030),lD(59),lC(985),lD(112),lC(1150),lD(112),lC(1100),lD(152),lC(820),lD(152),lC(780),lD(112),lC(935),lD(112),lC(890),lD(59),lC(960),lD(62),lC(1030),lD(59),lC(985),lD(112),lC(1150),lD(112),lC(1100),lD(152),lC(820),lD(152),lC(780),lD(112),lC(935),lD(112))end;if w and I then jH[#jH+1]=o1 end;return jH end;function o0.DrawVerticalSpeed(jH,dU)jG(jH,dU)end;function o0.UpdateHud(jH)local kv=cM;local o8=cN;local jO=o8;local k3=kv;local kN=bH(c.getThrottle())local kS=cF*3.6;local kO=c.getAxisCommandValue(0)local o9=iY(1770)local oa=iZ(310)if t and cL then kO=bK;kN=bK*100 end;local j1=j0()local jP="ROLL"if kN==nil then kN=0 end;if not cS then if cF>5 then kv=ku(cD)o8=kw(cD)else kv=0;o8=0 end;jP="YAW"end;if cQ>50000 and not c8 then local ob;ob=ik(cQ)jH[#jH+1]=gE(o9,oa,"PvP Boundary: "..ob,"pbright txtbig txtmid")end;jH[#jH+1]=iM;jH[#jH+1]=iD;jH[#jH+1]=hR;if iz~=""then jH[#jH+1]=iz end;if j2~=""then jH[#jH+1]=j2 end;if j3~=""then jH[#jH+1]=j3 end;jG(jH,ca)if ie()==0 or l then if cS then jN(jH,ai,aj,jO,jP,cS)else jN(jH,ai,aj,o8,jP,cS)end;if not i_()or m then if cS then jN(jH,ai,aj,jO,jP,cS)k2(jH,k3,jO,ai,aj,cS,bH(kw(cD)),cF)else jN(jH,ai,aj,o8,jP,cS)k2(jH,kv,o8,ai,aj,cS,bH(o8),cF)end;k9(jH,ca,cS)kx(jH,cD,cF,ai,aj)end end;kM(jH,j1,kN,kO)kR(jH,kS)kV(jH)lW(jH)if not ix and bV then lO(jH)end;return jH end;function o0.HUDEpilogue(jH)jH[#jH+1]="</svg>"return jH end;function o0.ExtraData(jH)local oc=iY(1240)local od=iZ(55)local oe=od+10;local of;local lC=iY;local lD=iZ;local og=0;local j1=j0()if aX then j1=j1 .."-VERTICAL"end;if E and not b4 and not b3 and cF>20 then j1=j1 .."-COLLISION ON"end;if bz~="Off"then j1="("..bz..")-"..j1 end;if b1 then j1="TB-"..j1 end;if not by then j1=j1 .."-DeCoupled"end;local oh=lD(99)local oi=lD(80)local oj=lD(85)local ok=lD(31)local ol=0;local om=0;local on=cb>1000000 and fM(cb/1000000,2).."kT"or fM(cb/1000,2).."T"if c8 then og=br else og=bp end;local oo,op=cj.computeDistanceAndTime(cF,0,cb,0,0,og)if oo<0 then oo=0 end;og=fM(og/(cb*ip),2).."g"local oq=d:maxForceForward()of=b.g()if of>0.1 then om=cb*of;om=fM(om/(cb*ip),2).."g"ol=0.5*oq/of;ol=ol>1000000 and fM(ol/1000000,2).."kT"or fM(ol/1000,2).."T"end;oq=fM(oq/(cb*ip),2).."g"local os=vec3(b.getWorldAcceleration()):len()/9.80665;of=b.g()jH[#jH+1]=[[<g class="dim txt txtend size14">]]if ie()==1 and not l then oc=iY(1120)od=iZ(55)oe=od+10 elseif c8 and I then local ot=iY(770)jH[#jH+1]=gE(lC(895),oh,"ATMO","")jH[#jH+1]=d9([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lC(895),oj,lC(-80))jH[#jH+1]=gE(lC(815),oi,d9("%.1f%%",c9*100),"txtstart size20")end;if I then jH[#jH+1]=gE(lC(1025),oh,"GRAVITY","txtstart")jH[#jH+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(1025),oj,lC(80))jH[#jH+1]=gE(lC(1105),oi,d9("%.2fg",of/9.80665),"size20")jH[#jH+1]=gE(lC(1125),oh,"ACCEL","txtstart")jH[#jH+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(1125),oj,lC(80))jH[#jH+1]=gE(lC(1205),oi,d9("%.2fg",os),"size20")jH[#jH+1]=gE(lC(695),oh,"BRK TIME","")jH[#jH+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(695),oj,lC(-80))jH[#jH+1]=gE(lC(615),oi,d9("%s",il(op)),"txtstart size20")jH[#jH+1]=gE(lC(635),lD(45),"TRIP","")jH[#jH+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(635),lD(31),lC(-90))if lw then jH[#jH+1]=gE(lC(545),lD(26),d9("%s",il(lw)),"txtstart size20")end;jH[#jH+1]=gE(lC(795),oh,"BRK DIST","")jH[#jH+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(795),oj,lC(-80))jH[#jH+1]=gE(lC(715),oi,d9("%s",ik(oo)),"txtstart size20")jH[#jH+1]=gE(lC(1285),lD(45),"MASS","txtstart")jH[#jH+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(1285),lD(31),lC(90))jH[#jH+1]=gE(lC(1375),lD(26),d9("%s",on),"size20")jH[#jH+1]=gE(lC(1220),oh,"THRUST","txtstart")jH[#jH+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(1220),oj,lC(80))jH[#jH+1]=gE(lC(1300),oi,d9("%s",oq),"size20")jH[#jH+1]=gE(iY(960),iZ(175),j1,"pbright txtbig txtmid size20")end;jH[#jH+1]="</g>"end;local ou=1-(a5*0.05+a6*0.05)function o0.FuelUsed(ov)local ow;if ov=="atmofueltank"then ow=d9("Atmo Fuel Used: %.1f L",jj[ov]/(4*ou))elseif ov=="spacefueltank"then ow=d9("Space Fuel Used: %.1f L",jj[ov]/(6*ou))else ow=d9("Rocket Fuel Used: %.1f L",jj[ov]/(0.8*ou))end;return ow end;function o0.DrawOdometer(jH,iK,bk,iL)if bE~="INFO"then return jH end;local of;local ol=0;local om=0;local og=0;local on=cb>1000000 and fM(cb/1000000,2).." kTons"or fM(cb/1000,2).." Tons"if c8 then og=br else og=bp end;local oo,op=cj.computeDistanceAndTime(cF,0,cb,0,0,og)og=fM(og/(cb*ip),2).." g"local oq=d:maxForceForward()of=b.g()if of>0.1 then om=cb*of;om=fM(om/(cb*ip),2).." g"ol=0.5*oq/of;ol=ol>1000000 and fM(ol/1000000,2).." kTons"or fM(ol/1000,2).." Tons"end;oq=fM(oq/(cb*ip),2).." g"if ie()==0 or l then local ox=iY(aw+10)local oy=iZ(ax+20)local oz=iY(aw+10+av/1.25)local nl=25;jH[#jH+1]="<g class='txtstart size14 bright'>"jH[#jH+1]=gE(ox,oy,d9("BrkTime: %s",il(op)))jH[#jH+1]=gE(oz,oy,d9("Trip: %.2f km",iK))jH[#jH+1]=gE(ox,oy+nl,d9("Lifetime: %.2f kSU",bk/200000))jH[#jH+1]=gE(oz,oy+nl,d9("BrkDist: %s",ik(oo)))jH[#jH+1]=gE(ox,oy+nl*2,"Trip Time: "..il(iL))jH[#jH+1]=gE(oz,oy+nl*2,"Total Time: "..il(bl))jH[#jH+1]=gE(ox,oy+nl*3,d9("Mass: %s",on))jH[#jH+1]=gE(oz,oy+nl*3,d9("Max Brake: %s",og))jH[#jH+1]=gE(ox,oy+nl*4,d9("Max Thrust: %s",oq))if of>0.1 then jH[#jH+1]=gE(oz,oy+nl*4,d9("Max Thrust Mass: %s",ol))jH[#jH+1]=gE(ox,oy+nl*5,d9("Req Thrust: %s",om))else jH[#jH+1]=gE(oz,oy+nl*4,"Max Mass: n/a")jH[#jH+1]=gE(ox,oy+nl*5,"Req Thrust: n/a")end;jH[#jH+1]=gE(oz,oy+nl*5,cl.FuelUsed("atmofueltank"))jH[#jH+1]=gE(ox,oy+nl*6,cl.FuelUsed("spacefueltank"))jH[#jH+1]=gE(oz,oy+nl*6,cl.FuelUsed("rocketfueltank"))if cF>833 then local oA=cb/math.sqrt(1-(cF/8333.33)^2)local on=oA>1000000 and fM(oA/1000000,2).." kTons"or fM(oA/1000,2).." Tons"jH[#jH+1]=gE(oz,oy+nl*7,d9("Rel. Mass: %s",on))end end;jH[#jH+1]="</g></g>"return jH end;function o0.DrawWarnings(jH)return kV(jH)end;function o0.DisplayOrbitScreen(jH)return lW(jH)end;function o0.DisplayMessage(jH,lh)if lh~="empty"then local hg=310;for lq in string.gmatch(lh,"([^\n]+)")do hg=hg+35;jH[#jH+1]=gE("50%",hg,lq,"msg")end end;if bX~=0 then c.setTimer("msgTick",bX)bX=0 end end;function o0.DrawDeadZone(jH)jH[#jH+1]=d9([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function o0.UpdatePipe()if c8 then iz=""return end;na()end;function o0.DrawSettings(jH)local hf=iY(640)local hg=iZ(200)jH[#jH+1]=[[<g class="pbright txtvspd txtstart">]]local hy=0;for dA,dl in pairs(iy)do hy=hy+1;jH[#jH+1]=gE(hf,hg,dA..": "..dl.get())hg=hg+20;if hy%12==0 then hf=hf+iY(350)hg=iZ(200)end end;jH[#jH+1]=gE(iY(640),iZ(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jH[#jH+1]="</g>"return jH end;local hO=iY(1770)local hP=iZ(350)local hN=iZ(15)local hM=iY(1370)local hS,oB;function o0.DrawRadarInfo()hR=co.GetRadarHud(hM,hN,hO,hP)end;function o0.DrawTanks()if aq~=0 and ar~=0 then j2=gE(aq,ar,"","txtstart pdim txtfuel")jk=ar;jl(aq,"Atmospheric ","ATMO",cf,jh,ji)jl(aq,"Space Fuel T","SPACE",cg,jf,jg)jl(aq,"Rocket Fuel ","ROCKET",ch,jd,je)end end;function o0.DrawShield()local hZ=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local oC=b.getPvPTimer()local oD=shield_1.getResistances()local oE="A: "..10+oD[1]*100 .."% / E: "..10+oD[2]*100 .."% / K:"..10+oD[3]*100 .."% / T: "..10+oD[4]*100 .."%"local hf,hg=as-60,at+30;local jz=bH(d7*2.55)local jA=d9("rgb(%d,%d,%d)",255-jz,jz,0)local jB=""j3=gE(hf,hg,"","txtmid pdim txtfuel")if d7<10 and hZ~="Shield Disabled"then jB="red "end;oC=oC>0 and"   PvPTime: "..il(oC)or""j3=j3 ..d9([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hf,hg,jA,d7*2,hf,hg,hf+2,hg+10,d7,oC)j3=j3 ..gE(hf,hg-5,hZ,jB.."txtstart pbright txtbig")j3=j3 ..gE(hf,hg+30,oE,jB.."txtstart pbright txtsmall")end;function o0.hudtick()if not iX then return end;local function oF(jH)local jD=bH(da(c3/(cd/4)*255,0,255))jH[#jH+1]=d9("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c1,c2,bH(iF+0.5)+jD,bH(iG+0.5)-jD,bH(iH+0.5)-jD)end;local function oG()for dF,dl in pairs(iq)do if dl.hovered then if not dl.drawCondition or dl.drawCondition(dl)then dl.toggleFunction(dl)end;dl.hovered=false end end;for dF,dl in pairs(it)do if dl.hovered then bE=dl.label;dl.hovered=false end end end;local function oH()local function oI(oJ,oK,hf,hg,nk,nl)if oJ>=hf and oJ<=hf+nk and oK>=hg and oK<=hg+nl then return true else return false end end;local hf=c1+cd/2;local hg=c2+ce/2;for dF,dl in pairs(iq)do dl.hovered=oI(hf,hg,dl.x,dl.y,dl.width,dl.height)end;for dF,dl in pairs(it)do dl.hovered=oI(hf,hg,dl.x,dl.y,dl.width,dl.height)end;if cV then local m_=false;for dF,et in ipairs(nX)do if et.hovered then m_=true;break end end;if nU.hovered then m_=true end;cV=m_ else cV=nU.hovered;if not cV then cW=bi end end end;local function oL(jH)if not bE or bE==""then bE="HELP"end;if w then for dA,dl in pairs(it)do local jB="dim brightstroke"local oM=0.2;if bE==dA then jB="pbright dimstroke"oM=0.6 end;local oN=""if dl.hovered then oM=0.8;oN=";stroke:white"end;jH[#jH+1]=d9([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dl.width,dl.height,dl.x,dl.y,jB,oM,oN)jH[#jH+1]=gE(dl.x+dl.width/2,dl.y+dl.height/2+5,dl.label,"txt txtmid pdim")end end end;local function oO(jH)local function oP(jH,oQ,hover,hf,hg,f9,oR,oS,oT,oU,oV,nY)if type(oU)=="function"then oU=oU(nY)end;if type(oV)=="function"then oV=oV(nY)end;jH[#jH+1]=d9("<rect x='%f' y='%f' width='%f' height='%f' fill='",hf,hg,f9,oR)if oQ then jH[#jH+1]=d9("%s'",oS)else jH[#jH+1]=oT end;if hover then jH[#jH+1]=d9(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jH[#jH+1]=d9(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fM(ac*0.5,0),fM(ad*0.5,0),fM(ae*0.5,0))end;jH[#jH+1]=" rx='5'></rect>"jH[#jH+1]=d9("<text x='%f' y='%f' font-size='24' fill='",hf+f9/2,hg+oR/2+5)if oQ then jH[#jH+1]="black"else jH[#jH+1]="white"end;jH[#jH+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oQ then jH[#jH+1]=d9("%s</text>",oU)else jH[#jH+1]=d9("%s</text>",oV)end end;local oW=d9("rgb(%d,%d,%d)'",fM(ac*0.1,0),fM(ad*0.1,0),fM(ae*0.1,0))local oX=d9("rgb(%d,%d,%d)",fM(ac*0.8,0),fM(ad*0.8,0),fM(ae*0.8,0))local oY=oP;for dF,dl in pairs(iq)do local np=dl.disableName;local no=dl.enableName;if type(np)=="function"then np=np(dl)end;if type(no)=="function"then no=no(dl)end;if not dl.drawCondition or dl.drawCondition(dl)then oY(jH,dl.toggleVar(dl),dl.hovered,dl.x,dl.y,dl.width,dl.height,oX,oW,np,no,dl)end end end;local oZ=fM(cd/2,0)local o_=fM(ce/2,0)local jH={}if p0 then jH[#jH+1]=p0 end;cl.HUDPrologue(jH)if w then cl.UpdateHud(jH)else if A then cl.DrawVerticalSpeed(jH,ca)end;cl.DrawWarnings(jH)end;if ix and iy~="none"then cl.DrawSettings(jH)end;if radar_1 then cl.DrawRadarInfo()end;cl.HUDEpilogue(jH)jH[#jH+1]=d9([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cd,ce)if bW~="empty"then cl.DisplayMessage(jH,bW)end;if ie()==0 and g=="virtual joystick"then if v then cl.DrawDeadZone(jH)end end;oL(jH)if ih()==0 then if ie()==1 and bV then if not p1 then oH()oO(jH)end;if not cr and not cs then local p2=table.concat(jH,"")jH={}jH[#jH+1]=d9("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jH[#jH+1]=p2;jH[#jH+1]="</body>"cr=true;jH[#jH+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cs then local p2=table.concat(jH,"")jH={}jH[#jH+1]=d9("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jH[#jH+1]=p2;jH[#jH+1]="</body>"end;if not cr then jH[#jH+1]=d9([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oZ,o_,c1,c2)end else oG()end else if not bV and ie()==0 then oG()if c3>au then if v then oF(jH)end end elseif bV and(not p1 or not i)then oH()oO(jH)end;jH[#jH+1]=d9([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oZ,o_,c1,c2)end;jH[#jH+1]=[[</svg></body>]]p3=table.concat(jH,"")end;function o0.TenthTick()local function p4()local p5=a.createData;local p6=a.createWidget;p7=a.createWidgetPanel("Interplanetary Helper")p8=p6(p7,"value")p9=p5('{"label": "Target Planet", "value": "N/A", "unit":""}')fK(p9,p8)pa=p6(p7,"value")pb=p5('{"label": "distance", "value": "N/A", "unit":""}')fK(pb,pa)gd=p6(p7,"value")gc=p5('{"label": "Travel Time", "value": "N/A", "unit":""}')fK(gc,gd)gb=p6(p7,"value")ga=p5('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fK(ga,gb)gf=p6(p7,"value")ge=p5('{"label": "Target Altitude", "value": "N/A", "unit":""}')fK(ge,gf)g7=p6(p7,"value")g6=p5('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g5=p6(p7,"value")g4=p5('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g3=p6(p7,"value")g2=p5('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g1=p6(p7,"value")g0=p5('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g9=p6(p7,"value")g8=p5('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c8 then fK(g6,g7)fK(g4,g5)fK(g2,g3)fK(g0,g1)fK(g8,g9)end end;local function pc()gD(p7)p7=nil end;local function pd()if not b0 then if fX==nil or fX.planetname~=iX.name then pe=(c0.center-cI):len()else pe=(fX.position-cI):len()end end;local fg=cF;local pf=c.getThrottle()/100;if t then pf=bK end;local pg,ph=cj.computeDistanceAndTime(cF,_,cb,d:maxForceForward()*pf,a1,0)local bZ,b_;if not b1 then bZ,b_=cn.GetAutopilotBrakeDistanceAndTime(_)else bZ,b_=cn.GetAutopilotTBBrakeDistanceAndTime(_)end;local dF,pi;if not b1 and fg>0 then dF,pi=cn.GetAutopilotBrakeDistanceAndTime(fg)else dF,pi=cn.GetAutopilotTBBrakeDistanceAndTime(fg)end;local pj=0;local pk=0;if bb or not b0 and fg>5 then pk=cj.computeTravelTime(fg,0,pe)elseif bZ+pg<pe then pj=pe-(bZ+pg)pk=cj.computeTravelTime(8333.0556,0,pj)else local pl=(pe-bZ)/pg;pg=pe-bZ;ph=ph*pl end;if fX~=nil and fX.planetname==iX.name and not b0 then return pk elseif ba then return pi elseif bb then return pk+pi else return ph+b_+pk end end;cl.DrawTanks()if shield_1 then cl.DrawShield()end;if bg~="None"then if p7==nil then p4()end;if bg~=nil then local pm=fX~=nil;local pn=0.5*br/c0:getGravity(c0.center+vec3(0,0,1)*c0.radius):len()pn=pn>1000000 and fM(pn/1000000,2).." kTons"or fM(pn/1000,2).." Tons"fJ(p9,'{"label": "Target", "value": "'..bg..'", "unit":""}')lw=pd()if pm and not b0 then c3=(cI-fX.position):len()else c3=(bh-cI):len()end;if not b1 then bZ,b_=cn.GetAutopilotBrakeDistanceAndTime(cF)iB,iC=cn.GetAutopilotBrakeDistanceAndTime(_)else bZ,b_=cn.GetAutopilotTBBrakeDistanceAndTime(cF)iB,iC=cn.GetAutopilotTBBrakeDistanceAndTime(_)end;local lh=ik(c3)fJ(pb,'{"label": "distance", "value": "'..lh..'"}')fJ(gc,'{"label": "Travel Time", "value": "'..il(lw)..'", "unit":""}')lh=ik(bZ)fJ(g6,'{"label": "Cur Brake distance", "value": "'..lh..'"}')fJ(g4,'{"label": "Cur Brake Time", "value": "'..il(b_)..'", "unit":""}')lh=ik(iB)fJ(g2,'{"label": "Max Brake distance", "value": "'..lh..'"}')fJ(g0,'{"label": "Max Brake Time", "value": "'..il(iC)..'", "unit":""}')fJ(ga,'{"label": "Max Brake Mass", "value": "'..d9("%s",pn)..'", "unit":""}')lh=ik(gg)fJ(ge,'{"label": "Target Orbit", "value": "'..lh..'"}')if c9>0 and not po then a.removeDataFromWidget(g0,g1)a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)po=true;if not cL and t and(b2 or b5 or c6)then cn.cmdThrottle(1)aY=false;bO=false end end;if c9==0 and po then if fJ(g0,g1)==1 then fK(g0,g1)end;if fJ(g2,g3)==1 then fK(g2,g3)end;if fJ(g4,g5)==1 then fK(g4,g5)end;if fJ(g6,g7)==1 then fK(g6,g7)end;if fJ(g8,g9)==1 then fK(g8,g9)end;po=false end end else pc()end;if warpdrive~=nil then if ic(warpdrive.getData()).destination~="Unknown"and ic(warpdrive.getData()).distance>400000 then warpdrive.show()pp=true else warpdrive.hide()pp=false end end end;function o0.OneSecondTick()local function pq()local jv=bG()local kS=cF;local pr=jv-iN;if kS>1.38889 then kS=kS/1000;local ps=kS*(jv-iN)bk=bk+ps;iK=iK+ps end;iL=iL+pr;bl=bl+pr;iN=jv end;local function pt(jH)local pu=0;iD=""local pv=io;local pw=0;local px=0;local py=0;local jz=0;local jA=""local pz=b.getElementHitPointsById;local pA=b.getElementMaxHitPointsById;local pB={}for dA in pairs(im)do local pC=0;local pD=0;pD=pA(im[dA])pC=pz(im[dA])pw=pw+pC;if pC<pD then if pC==0 then py=py+1 else px=px+1 end;if iO and#pB==0 then fO=vec3(b.getElementPositionById(im[dA]))local hf=fO.x;local hg=fO.y;local hh=fO.z;table.insert(pB,b.spawnArrowSticker(hf,hg,hh+1,"down"))table.insert(pB,b.spawnArrowSticker(hf,hg,hh+1,"down"))b.rotateSticker(pB[2],0,0,90)table.insert(pB,b.spawnArrowSticker(hf+1,hg,hh,"north"))table.insert(pB,b.spawnArrowSticker(hf+1,hg,hh,"north"))b.rotateSticker(pB[4],90,90,0)table.insert(pB,b.spawnArrowSticker(hf-1,hg,hh,"south"))table.insert(pB,b.spawnArrowSticker(hf-1,hg,hh,"south"))b.rotateSticker(pB[6],90,-90,0)table.insert(pB,b.spawnArrowSticker(hf,hg-1,hh,"east"))table.insert(pB,b.spawnArrowSticker(hf,hg-1,hh,"east"))b.rotateSticker(pB[8],90,0,90)table.insert(pB,b.spawnArrowSticker(hf,hg+1,hh,"west"))table.insert(pB,b.spawnArrowSticker(hf,hg+1,hh,"west"))b.rotateSticker(pB[10],-90,0,90)table.insert(pB,im[dA])end elseif iO and#pB>0 and pB[11]==im[dA]then for ju in pairs(pB)do b.deleteSticker(pB[ju])end;pB={}end end;pu=bH(pw/pv*100)if pu<100 then jH[#jH+1]=gE(0,0,"","pbright txt")jz=bH(pu*2.55)jA=d9("rgb(%d,%d,%d)",255-jz,jz,0)if pu<100 then jH[#jH+1]=gE("50%",1035,"Elemental Integrity: "..pu.."%","txtbig txtmid","fill:"..jA)if py>0 then jH[#jH+1]=gE("50%",1055,"Disabled Modules: "..py.." Damaged Modules: "..px,"txtbig txtmid","fill:"..jA)elseif px>0 then jH[#jH+1]=gE("50%",1055,"Damaged Modules: "..px,"txtbig txtmid","fill:"..jA)end end end end;local function pE()if ib then if iE==nil and(d2~=nil or bj)then _autoconf.displayCategoryPanel(ib,weapon_size,"Weapons","weapon",true)iE=_autoconf.panels[_autoconf.panels_size]elseif iE~=nil and d2==nil and not bj then gD(iE)iE=nil end end end;cX=b.getPlayersOnBoard()cY=b.getDockedConstructs()local jH={}pq()if s then pt(jH)end;pE()cl.UpdatePipe()cl.ExtraData(jH)iM=table.concat(jH,"")collectgarbage("collect")end;function o0.AnimateTick()cs=true;cr=false;c1=0;c2=0;c.stopTimer("animateTick")end;function o0.MsgTick()local jH={}cl.DisplayMessage(jH,"empty")bW="empty"c.stopTimer("msgTick")bX=3 end;function o0.ButtonSetup()nA()nF()iq=ir end;if pF then for dA,dl in pairs(pF)do o0[dA]=dl end end;return o0 end;local function pG(d,b,c,a,e,vBooster,hover,pH,antigrav,warpdrive,dbHud_1,radar_1,eP,bH,bI,ie,eK,bG,da,ig,fJ,ih,dc,fM,fL,ii,dd,ik,il,pI,ic,d9,fK)local pJ={}local pK=false;local pL=0;local pM=0;local pN=0;local pO=bG()local pP=0;local pQ=0;local pR=0;local pS=0;local pT=false;local pU=false;local pV=false;local pW=nil;local pX=0;local iA=55;local pY=nil;local pZ=false;local p_=false;local q0=false;local q1=0;local q2=0;local q3=0;local q4=0;local q5=0;local q6={VectorToTarget=false}local q7=vec3(b.getConstructWorldOrientationUp())local q8=nil;local q9=0;local qa=-1;local qb=-1;local qc=false;local qd=false;local qe=0;local qf=false;local qg=false;local qh=false;local qi=false;local qj=""local qk=false;local ql=false;local qm=""local qn=false;local function qo(fg)local qp=bc;if not b0 then qp=0 end;if not c8 then return cj.computeDistanceAndTime(fg,qp,cb,0,0,bp-be*cb)else if br and br>0 then return cj.computeDistanceAndTime(fg,qp,cb,0,0,br-be*cb)else return 0,0 end end end;local function qq(fg)local qp=bc;if not b0 then qp=0 end;return cj.computeDistanceAndTime(fg,qp,cb,d:maxForceForward(),a1,bp-be*cb)end;local function qr(qs,qt,qu)qt=qt:project_on_plane(qs)qu=qu:project_on_plane(qs)return eK(qt:cross(qu):dot(qs),qt:dot(qu))end;local function qv()local function qw()local qx=-1;local qy=-1;if vBooster then qx=vBooster.getDistance()end;if hover then qy=hover.getDistance()end;if qx~=-1 and qy~=-1 then if qx<qy then return qx else return qy end elseif qx~=-1 then return qx elseif qy~=-1 then return qy else return-1 end end;local qz=qw()local qA=-1;if antigrav and antigrav.getState()==1 and not q and cF<iA then local qB=eP(ca-antigrav.getBaseAltitude())if qB<50 then return qB end end;if pH then qA=pH.getDistance()end;if qz~=-1 and qA~=-1 then if qz<qA then return qz else return qA end elseif qz~=-1 then return qz else return qA end end;local function qC(iX,eB,qD)local function qE(qF,dM)local eH=vec3(dM)if qF.id==0 then return setmetatable({latitude=eH.x,longitude=eH.y,altitude=eH.z,id=0,systemId=qF.systemId},dO)end;local eI=eH-qF.center;local c3=eI:len()local dU=c3-qF.radius;local dS=0;local dT=0;if not dd(c3,0)then local eJ=eK(eI.y,eI.x)dT=eJ>=0 and eJ or 2*math.pi+eJ;dS=math.pi/2-math.acos(eI.z/c3)end;return setmetatable({latitude=math.deg(dS),longitude=math.deg(dT),altitude=dU,id=qF.id,systemId=qF.systemId},dO)end;local qG=qE(iX,eB)qG="::pos{"..qG.systemId..","..qG.id..","..qG.latitude..","..qG.longitude..","..qG.altitude.."}"if qD then return qG else qh=qG;return true end end;local function qH(qI,qJ,qK)local function qL(qI,ek)qI=vec3(qI)ek=vec3(ek):normalize()local dv=qI*ek;return dv.x+dv.y+dv.z end;local qM=0.001;local qN=1;if not c8 or not cu or c7~=-1 or cF<iA then if qK==nil then qK=aO end;if qJ==nil then qJ=qM end;qI=vec3(qI):normalize()local qO=vec3()-qI;local qP=-qL(qO,b.getConstructWorldOrientationRight())*qN;local qQ=-qL(qO,b.getConstructWorldOrientationUp())*qN;if pM==0 then pM=qP/2 end;if pN==0 then pN=qQ/2 end;if eP(qP)<0.1 then q2=q2-qP*2 else q2=q2-(qP+(qP-pM)*qK)end;if eP(qQ)<0.1 then q1=q1+qQ*2 else q1=q1+qQ+(qQ-pN)*qK end;pM=qP;pN=qQ;if eP(qP)<qJ and eP(qQ)<qJ then return true end;return false elseif cu and c7==-1 then qI=cE;if qK==nil then qK=aO end;if qJ==nil then qJ=qM end;qI=vec3(qI):normalize()local qO=cB-qI;local qP=-qL(qO,b.getConstructWorldOrientationRight())*qN;local qQ=-qL(qO,b.getConstructWorldOrientationUp())*qN;if pM==0 then pM=qP/2 end;if pN==0 then pN=qQ/2 end;if eP(qP)<0.1 then q2=q2-qP*5 else q2=q2-(qP+(qP-pM)*qK)end;if eP(qQ)<0.1 then q1=q1+qQ*5 else q1=q1+qQ+(qQ-pN)*qK end;pM=qP;pN=qQ;if eP(qP)<qJ and eP(qQ)<qJ then return true end;return false end end;function pJ.clearAll()b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"aZ=false;a_=false;cR=nil;b2=false;b5=false;b3=false;aY=false;b4=false;b6=false;bU=false;p_=false;c4=false;c5=false;q0=false;ct=p;bn=false;b1=false;cc=false;bq=nil;bw=false;d5=false;d6=nil end;function pJ.GetAutopilotBrakeDistanceAndTime(fg)return qo(fg)end;function pJ.GetAutopilotTBBrakeDistanceAndTime(fg)return qq(fg)end;function pJ.showWayPoint(iX,eB,qD)return qC(iX,eB,qD)end;function pJ.APTick()qe=ih()if qh then a.setWaypoint(qh)qh=false end;if qk then antigrav.setBaseAltitude(qk)qk=false end;if qi then fJ(qi,qj)qi=false;qj=""end;if qa~=-1 then cn.cmdThrottle(qa,qc)qc=false;qa=-1 end;if qb~=-1 then cn.cmdCruise(qb,qc)qc=false;qb=-1 end;if qd then d.control.extendLandingGears()qd=false end;if ql then cn.ToggleAutopilot()end end;function pJ.ToggleIntoOrbit()cy=false;pR=nil;pS=nil;pX=0;if not c8 then if bw then fL("orOff","AP")bw=false;pT=false;pW=nil;ct=p;if b2 then b2=false;b4=false end;q6.VectorToTarget=false;q6.AutopilotAlign=false;pV=false elseif cS then fL("orOn","AP")bw=true;ct=true;if pW==nil then pW=iX end;if b2 then b2=false;b4=false end else bW="Unable to engage auto-orbit, not near a planet"end else bw=false;pT=false;pW=nil;ct=p;if b2 then b2=false end;q6.VectorToTarget=false;q6.AutopilotAlign=false;pV=false end end;function pJ.ToggleVerticalTakeoff()b2=false;if b6 then lp=true;b5=false;b4=false;b3=true;ct=true;bT=0;if c8 and c7==-1 then b3=false;b2=true;bT=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qb=bH(cv)end else cy=false;bj=false;d.control.retractLandingGears()ig:setTargetGroundAltitude(X)aY="VTO Takeoff"end;b6=not b6 end;function pJ.checkLOS(qI)local lu,ez,eA=ci:getPlanetarySystem(0):castIntersections(cI,qI,function(ei)if ei.noAtmosphericDensityAltitude>0 then return ei.radius+ei.noAtmosphericDensityAltitude else return ei.radius+ei.surfaceMaxAltitude*1.5 end end)local lv=ez;if eA~=nil and ez~=nil then lv=math.min(eA,ez)end;if lv~=nil then return lu,lv else return nil,nil end end;function pJ.ToggleAutopilot()local function qR(bu)cT=false;bn=not bn;if bn then b1=false;if not b2 and not bu then cn.ToggleAltitudeHold()end end;ly="Proceeding to Waypoint"end;local function qS(gp)if gp then for K,dA in pairs(cO)do if dA.name and dA.name==gp then return K end end else return 0 end end;local qT=false;if bJ-pQ<1.5 and c8 then if not cA then if c8 then b7=iX.spaceEngineMinAltitude-0.01*iX.noAtmosphericDensityAltitude;fL("11","EP")pQ=-1;if b0 or bn or bw then return end else bW="No space engines detected, Orbital Hop not supported"return end elseif iX.hasAtmosphere then if c8 then b7=iX.noAtmosphericDensityAltitude+T;fL("orH","OH")end;pQ=-1;if b0 or bn or bw then return end end else pQ=bJ end;qU=false;if(bi>0 or#bC>0)and not b0 and not bn and not c5 and not bw then if 0.5*d:maxForceForward()/b.g()<cb then bW="WARNING: Heavy Loads may affect autopilot performance."bX=5 end;if#bC>0 and not c6 then bi=qS(bC[1])cm.UpdateAutopilotTarget()bW="Route Autopilot in Progress"local qO=fX.position-cI;local qV=qO:project_on_plane(cG):len()if qV>50000 and fX.planetname==iX.name then qT=true end end;cm.UpdateAutopilotTarget()cn.showWayPoint(c0,bh)if fX~=nil then if fX.agg and not q and antigrav then if not cK then cn.ToggleAntigrav()end;bs=fX.agg end;bq=nil;bu=fX.planetname=="Space"if bu then fL("apSpc","AP")if c8 then c5=true;cn.ToggleAltitudeHold()else b0=true end elseif iX.name==fX.planetname then lp=true;if c8 then if not bn then fL("vtt","AP")qR(bu)if qT then b7=iX.noAtmosphericDensityAltitude+T end end else fL("apOn","AP")if not(c0.name==iX.name and ca<gg*1.5)then cy=false;b0=true elseif not c8 then if bw then cn.ToggleIntoOrbit()end;cx=iX.noAtmosphericDensityAltitude+T;pV=true;q6.AutopilotAlign=true;q6.VectorToTarget=true;pT=false;if not bw then cn.ToggleIntoOrbit()end end end else fL("apP","AP")aZ=false;a_=false;if c8 then c5=true;cn.ToggleAltitudeHold()else b0=true end end elseif not c8 then if fX==nil and(c0.name==iX.name and cS)and not bw then qW=false;cy=false;pT=false;cn.ToggleIntoOrbit()else fL("apP","AP")b0=true;aZ=false;a_=false;b9=false;bU=false;b2=false;b3=false;b5=false;b4=false;p_=false;bq=nil;qW=false end else fL("apP","AP")c5=true;cn.ToggleAltitudeHold()end;ql=false else fL("apOff","AP")cn.ResetAutopilots(1)if ql==2 then ql=true end end end;function pJ.routeWP(qX,qY,qZ)if qZ then if qZ==1 then bC={}bC=ii(bC,bB)if#bC>0 then bW="Route Loaded"else bW="No Saved Route found on Databank"end;return bC else bB={}bB=ii(bB,bC)bW="Route Saved"pI()return end end;if qX then return bC end;if qY then bC={}bW="Current Route Cleared"else bC[#bC+1]=fX.name;bW="Added "..fX.name.." to route. "end;return bC end;function pJ.cmdThrottle(dB,q_)if ig:getAxisCommandType(0)~=axisCommandType.byThrottle and not q_ then d.control.cancelCurrentControlMasterMode()end;ig:setThrottleCommand(axisCommandId.longitudinal,dB)bK=da(fM(dB*100,0)/100,-1,1)q8=nil end;function pJ.cmdCruise(dB,q_)if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not q_ then d.control.cancelCurrentControlMasterMode()end;ig:setTargetSpeedCommand(axisCommandId.longitudinal,dB)q8=dB end;function pJ.ToggleLockPitch()if bq==nil then fL("lkPOn","LP")if not bV then bq=cM else bq=Q end;b4=false;b2=false;b3=false else fL("lkPOff","LP")bq=nil end end;function pJ.ToggleAltitudeHold()if bJ-pP<1.5 then if iX.hasAtmosphere then if c8 then b7=iX.spaceEngineMinAltitude-0.01*iX.noAtmosphericDensityAltitude;fL("11","EP")else if cS then b7=iX.noAtmosphericDensityAltitude+T;cx=b7;pV=true;if not bw then cn.ToggleIntoOrbit()end;pT=true end end;pP=-1;if b2 or bw or b6 then return end end else pP=bJ end;if cS and not c8 then cx=ca;pV=true;pT=true;cn.ToggleIntoOrbit()if bw then pP=bJ else pP=0 end;return end;b2=not b2;b3=false;b5=false;if b2 then b0=false;a_=false;aZ=false;bU=false;ct=true;bq=nil;cy=false;if c7~=-1 and cF<20 then fL("lfs","LS")b4=true;if pP>-1 then b7=ca+W end;bj=false;d.control.retractLandingGears()aY="ATO Hold"ig:setTargetGroundAltitude(X)if aX and cJ then cn.ToggleVerticalTakeoff()end else fL("altOn","AH")b4=false;if pP>-1 then if cS then b7=ca end end;if b6 then cn.ToggleVerticalTakeoff()end end;if cK and not q then local r0=antigrav.getBaseAltitude()if bn and fX.agg and fX.agg>ca then b7=fX.agg elseif b4 then b7=r0 end;if eP(ca-r0)<100 and cF<20 then b7=r0;aY="AGG Hold"qa=0 end end;if c5 then b7=200000 end else fL("altOff","AH")if bw then cn.ToggleIntoOrbit()end;if b6 then cn.ToggleVerticalTakeoff()end;ct=p;b4=false;bn=false;pP=0 end end;function pJ.ResetAutopilots(pJ)if pJ then c5=false;b0=false;b9=false;p_=false;b7=ca;qU=false;d5=false;bd="Aligning"end;bn=false;b4=false;b5=false;a_=false;b3=false;d6=nil;r1=false;cR=nil;d5=false;if not cK then b2=false;bq=nil end;if b6 then cn.ToggleVerticalTakeoff()end;if bw then cn.ToggleIntoOrbit()end;ct=p;c4=false;c6=false;bT=0 end;function pJ.BrakeToggle(r2)if not aY then if r2 then aY=r2 else aY=true end else aY=false end;if b3 then b3=false;ct=p;d5=false end;if aY then fL("bkOn","B",1)cn.ResetAutopilots()else fL("bkOff","B",1)end end;function pJ.BeginReentry()if b5 then bW="Re-Entry cancelled"fL("reOff","RE")b5=false;ct=p;b2=false elseif not iX.hasAtmosphere then bW="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bX=5 elseif not q0 then b5=true;if ig:getAxisCommandType(0)~=r3.cruise then d.control.cancelCurrentControlMasterMode()end;ct=true;aY=false;bW="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cv;fL("par","RE")else b5=true;b2=true;ct=true;aY=false;b7=iX.surfaceMaxAltitude+Z;if b7>iX.spaceEngineMinAltitude then b7=iX.spaceEngineMinAltitude-0.01*iX.noAtmosphericDensityAltitude end;local r4=ik(b7)bW="Beginning Re-entry.  Target speed: "..cv.." Target Altitude: "..r4;fL("glide","RE")qb=bH(cv)end;b4=false end;function pJ.ToggleAntigrav()if antigrav and not q then if cK then fL("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bs==nil then bs=ca end;if bs<1000 then bs=1000 end;fL("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pJ.changeSpd(r5)local r6=1;if r5 then r6=-1 end;if not bV then if t and not p1 and pZ then local r7=bK;bK=fM(da(bK+r6*aA/100,-1,1),2)if bK>=0 and r7<0 then bK=0;pZ=false end elseif p1 then if c8 or b5 then cv=da(cv+r6*aA,0,U)elseif b0 then _=da(_+r6*aA/3.6*100,0,8333.00)end else ig:updateCommandFromActionStart(axisCommandId.longitudinal,r6*aA/10)end else if b0 or bn or c5 or bw then cW=cW+1*r6*-1;if cW>#cO then cW=1 end;if cW<1 then cW=#cO end else if not r5 then r6=1 else r6=nil end;cm.adjustAutopilotTargetIndex(r6)end end end;function pJ.TenthTick()local function r8(of,r9)if of==nil then of=b.g()end;of=fM(of,5)if r9~=nil and r9 or(pY==nil or pY~=of)then local fg=cD:len()local ra=ic(c.getData()).maxBrake;if ra~=nil and ra>0 and c8 then ra=ra/da(fg/100,0.1,1)ra=ra/c9;if c9>0.10 then if br then br=(br+ra)/2 else br=ra end end end;if ra~=nil and ra>0 then bp=ra end;pY=of end end;r8(nil,true)if q8~=nil then if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ig:getTargetSpeed(axisCommandId.longitudinal)~=q8 then qb=q8 else q8=nil end end end;function pJ.SatNavTick()if not r then return end;qm=dbHud_1.getStringValue("SPBAutopilotTargetName")if qm~=nil and qm~=""and qm~="SatNavNotChanged"then local dv=ic(dbHud_1.getStringValue("SavedLocations"))if dv~=nil then bm=dv;local gn=-1;local gt;for dA,dl in pairs(bm)do if dl.name and dl.name=="SatNav Location"then gn=dA;break end end;if gn~=-1 then gt=bm[gn]gn=-1;for dA,dl in pairs(e[0])do if dl.name and dl.name=="SatNav Location"then gn=dA;break end end;if gn>-1 then e[0][gn]=gt end;cm.UpdateAtlasLocationsList()bW=gt.name.." position updated"end end;for K=1,#cO do if cO[K].name==qm then bi=K;a.print("Index = "..bi.." "..cO[K].name)cm.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pJ.onFlush()local function rb(rc,rd)local re=vec3()local rf=vec3()if rc==axisCommandId.longitudinal then re=vec3(b.getConstructOrientationForward())rf=cB elseif rc==axisCommandId.vertical then re=vec3(b.getConstructOrientationUp())rf=q7 elseif rc==axisCommandId.lateral then re=vec3(b.getConstructOrientationRight())rf=cC else return vec3()end;local rg=vec3(b.getWorldGravity())local rh=rg:dot(rf)local ri=vec3(b.getWorldAirFrictionAcceleration())local rj=ri:dot(rf)local rk=cD:dot(re)local rl=rd*constants.kph2m;if rm==nil then rm=pid.new(10,0,10.0)end;rm:inject(rl-rk)local rn=rm:get()local ro=(rn-rj-rh)*rf;return ro end;local function rp(rc,rd)local re=vec3()local rf=vec3()if rc==axisCommandId.longitudinal then re=vec3(b.getConstructOrientationForward())rf=cB elseif rc==axisCommandId.vertical then re=vec3(b.getConstructOrientationUp())rf=q7 elseif rc==axisCommandId.lateral then re=vec3(b.getConstructOrientationRight())rf=cC else return vec3()end;local rg=vec3(b.getWorldGravity())local rh=rg:dot(rf)local ri=vec3(b.getWorldAirFrictionAcceleration())local rj=ri:dot(rf)local rk=cD:dot(re)local rl=rd*constants.kph2m;if rq==nil then rq=pid.new(10,0,10.0)end;rq:inject(rl-rk)local rn=rq:get()local ro=(rn-rj-rh)*rf;return ro end;local function rr(rs,jK,fT)local rt=rs:cross(fT):normalize_inplace()local kv=math.acos(da(rt:dot(-jK),-1,1))*constants.rad2deg;if rt:cross(-jK):dot(fT)<0 then kv=-kv end;return kv end;local function ru()if cU and not b3 then local ei=cU[1]local hD,hE=cU[2],cU[3]local rv=math.min(hD,hE or hD)local rw=rv/cF;local rx=b4 and(cF<42 or c7~=-1)local ry=b2 or bn or bq or b0;if ry and not rx and(bZ*1.5>rv or rw<1)then dP("HERE1")aY="Collision"bC={}qa=0;if b2 then cn.ToggleAltitudeHold()end;if bq then cn.ToggleLockPitch()end;bW="Autopilot Cancelled due to possible collision"a.print(ei.name.." COLLISION "..il(rw).." / "..ik(rv,2))cn.ResetAutopilots(1)lp=true;if c8 then b3=true end;ct=true;dP("HERE2")end;if rw<11 then cT=ei.name.." COLLISION "..il(rw).." / "..ik(rv,2)else cT=ei.name.." collision "..il(rw)end;if rw<6 then fL("alarm","AL",2)end else cT=false end end;if antigrav and not q then if not cK and antigrav.getBaseAltitude()~=bs then qk=bs end end;cL=ig:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local rz=da(bQ+q1+a.getControlDeviceForwardInput(),-1,1)local rA=da(bR+q3+a.getControlDeviceYawInput(),-1,1)local rB=da(bS+q2-a.getControlDeviceLeftRightInput(),-1,1)local rC=aY and 1 or 0;cG=vec3(b.getWorldVertical())if cG==nil or cG:len()==0 then cG=(iX.center-cI):normalize()end;q7=vec3(b.getConstructWorldOrientationUp())cB=vec3(b.getConstructWorldOrientationForward())cC=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getWorldVelocity())cD=vec3(b.getVelocity())cI=vec3(b.getConstructWorldPos())cb=b.getConstructMass()cF=vec3(cE):len()cH=-cG:dot(cE)cN=getRoll(cG,cB,cC)local rD=cN/180*math.pi;local rE=math.cos(rD)local rF=math.sin(rD)cM=rr(cG,cB,cC*rE+q7*rF)local rG=cE:normalize()local rH=eP(cN)local rI=utils.sign(cN)local rJ=vec3(b.getWorldAngularVelocity())local rK=rz*aK*cC+rA*aF*cB+rB*aL*q7;if ct==true and cG:len()>0.01 then local rL=eP(q4-cN)if((a_ or b5 or b3 or c4 or b2 or bw)and rL>0 or c8 and rL<aG and p)and rA==0 and eP(cM)<85 then local rM=q4;local rN=aE;if not c8 then rN=rN/4;q4=0;rM=0 end;if rO==nil then rO=pid.new(rN*0.01,0,rN*0.1)end;rO:inject(rM-cN)local rP=rO:get()rK=rK+rP*cB end end;local rQ=1;local rR=0;local rS=1;bL=0;c8=false or ca<iX.noAtmosphericDensityAltitude;c9=bI()ca=b.getAltitude()c7=qv()bJ=bG()pO=bJ;if radar_1 then qn=not qn;if qn then co.UpdateRadar()end;if E then ru()end end;if antigrav then cK=antigrav.getState()==1 end;local rT=a.getMouseWheel()if rT>0 then cn.changeSpd()elseif rT<0 then cn.changeSpd(true)else pZ=true end;local rU=1;local rV=1;local rW=bJ-pO;local rX=-math.deg(qr(q7,cE,cB))local rY=math.deg(qr(cC,cE,cB))local gi=cG*-1;cu=c8 and rX<-L or rX>L or rY<-M or rY>M;local rZ=a.getMouseDeltaX()local r_=a.getMouseDeltaY()if o and not bV then r_=-r_ end;q2=0;q3=0;q1=0;fP=ci[0]iX=fP:closestBody(b.getConstructWorldPos())s0=ck(iX)fk=s0:orbitalParameters(b.getConstructWorldPos(),cE)if ca==0 then ca=(cI-iX.center):len()-iX.radius end;cS=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;local of=iX:getGravity(b.getConstructWorldPos()):len()*cb;q4=0;local s1=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if qe==0 then if ie()==1 and bV then if not cr then c1=da(c1+rZ/2,-cd/2,cd/2)c2=da(c2+r_/2,-ce/2,ce/2)end else c1=0;c2=0 end else c1=da(c1+rZ/2,-cd/2,cd/2)c2=da(c2+r_/2,-ce/2,ce/2)c3=dc(c1*c1+c2*c2)if not bV and ie()==0 then local kE,kF=1,1;if bE=="SCOPE"then kE,kF=c_/90,c_/90 end;if g=="virtual joystick"then if c1>0 and c1>au then q2=q2-(c1-au)*aC*kE elseif c1<0 and c1<au*-1 then q2=q2-(c1+au)*aC*kE else q2=0 end;if c2>0 and c2>au then q1=q1-(c2-au)*aD*kF elseif c2<0 and c2<au*-1 then q1=q1-(c2+au)*aD*kF else q1=0 end else c1=0;c2=0;if g=="mouse"then q1=(-utils.smoothstep(r_,-100,100)+0.5)*2*rU;q2=(-utils.smoothstep(rZ,-100,100)+0.5)*2*rV end end end end;local s2=cF>8334;if cF>V/3.6 and not c8 and not b0 and not s2 then bW="Space Speed Engine Shutoff reached"qa=0 end;if not s2 and s3 then if not aY then cn.BrakeToggle()end;if b0 then if not ql then ql=true end end end;s3=s2;if c9>0.09 then if cF>cv/3.6 and not t and not pK then aY="SpdLmt"pK=true elseif not t and pK then if cF<cv/3.6 then aY=false;pK=false end end end;if a_ then if c4 then aY=false;local s4=false;if fX and c4==true then s4=qH(fX.position-cI,0.1)else s4=qH(vec3(cE),0.01)end;ct=true;if s4 then qb=bH(cv)if(eP(cN)<2 or eP(cM)>85)and cF>=cv/3.6-1 then aY=false;a_=false;if c4~=2 then q0=true end;if c4==true then c6=true end;c4=false;b0=false;cn.BeginReentry()end elseif c8 and t then qa=1 end elseif cF>iA then qH(vec3(cE),0.01)end end;if aZ then if c8 then aZ=false elseif cF>iA then qH(-vec3(cE))end end;if not a_ and c4 and not bw then if not c8 then if c4~=2 then q0=true end;cn.BeginReentry()c4=false;c6=true else c4=false;if not ql then ql=true end end end;if c6 and fX and(ca<b7+250 and ca>b7-250)and cF*3.6>cv-250 and eP(cH)<25 and c9>=0.1 and(fX.position-cI):len()>2000+ca then if not ql then ql=true end;c6=false end;if b6 then ct=true;local s5=b7;if cH<-30 then bW="Unable to achieve lift. Safety Landing."bT=0;ct=p;b6=false;b3=true elseif not q and cK or b7<iX.spaceEngineMinAltitude then if cK then s5=antigrav.getBaseAltitude()end;if ca<s5-100 then q5=0;bT=15;aY=false elseif cH>0 then aY="VTO Limit"bT=0 elseif cH<-30 then aY="VTO Fall"bT=15 elseif ca>=s5 then if cK then if b0 or bn then cn.ToggleVerticalTakeoff()else aY="VTO Complete"b6=false end;bW="Takeoff complete. Singularity engaged"fL("aggLk","AG")else aY=false;bW="VTO complete. Engaging Horizontal Flight"fL("vtoc","VT")cn.ToggleVerticalTakeoff()end;bT=0 end else if c9>0.08 then q5=0;aY=false;bT=20 elseif c9<0.08 and c8 then aY=false;if cz then q5=0;bT=20 else bT=0;q5=36;qb=3500 end else ct=p;bw=true;cy=false;s6=false;pT=false;pR=nil;pS=nil;if pW==nil then pW=iX end;cx=s5;pV=true;b6=false end end;if q5~=nil then if s7==nil then s7=pid.new(2*0.01,0,2*0.1)end;local s8=da(q5-cM,-M*0.80,M*0.80)s7:inject(s8)local s9=da(s7:get(),-1,1)q1=s9 end end;if bw then local function sa()if fk.periapsis.altitude>=cx*0.99 and fk.apoapsis.altitude>=cx*0.99 and fk.periapsis.altitude<fk.apoapsis.altitude and fk.periapsis.altitude*1.05>=fk.apoapsis.altitude and eP(cx-ca)<1000 then return true else return false end end;local qO;local sb=false;local sc=ik(cx)if pW==nil then pW=iX;if bn then pW=c0 end end;if not pV then cx=bH(pW.radius+pW.surfaceMaxAltitude+T)if pW.hasAtmosphere then cx=bH(pW.radius+pW.noAtmosphericDensityAltitude+T)end;pV=true end;if q6.VectorToTarget and fX then qO=fX.position-cI end;local sd,se=ck(pW):escapeAndOrbitalSpeed((cI-pW.center):len()-pW.radius)local sf=cN;if not pT then local sg=false;local sh=false;qa=0;pS=0;cw="Aligning to orbital path - OrbitHeight: "..sc;if q6.VectorToTarget then qH(qO:normalize():project_on_plane(cG))sb=cB:dot(qO:project_on_plane(q7):normalize())>0.95 else qH(cE)sb=rX<0.5;if cF<150 then sb=true end end;q1=0;pR=0;if cM<=pR+2 and cM>=pR-2 then sg=true else sg=false end;if sf<=pS+2 and sf>=pS-2 then sh=true else sh=false end;if sg and sh and sb then pR=nil;pS=nil;pT=true end else if q6.VectorToTarget then qH(qO:normalize():project_on_plane(cG))elseif cF>150 then qH(cE)end;q1=0;if q6.VectorToTarget and fX then local bZ,dF=cj.computeDistanceAndTime(cF,cv/3.6,cb,0,0,bp)if cy and qO:len()>15000+bZ+ca then cw="Orbiting to Target"if ca-100<=pW.noAtmosphericDensityAltitude or lw>fk.timeToPeriapsis and fk.periapsis.altitude<pW.noAtmosphericDensityAltitude or not sa()and fk.eccentricity>0.1 then bW="Re-Aligning Orbit"cy=false end elseif cy or qO:len()<15000+bZ+ca then bW="Orbit complete, proceeding with reentry"fL("orCom","OB")bh=fX.position;q0=true;c6=true;q6.VectorToTarget,q6.AutopilotAlign=false,false;cn.ToggleIntoOrbit()cn.BeginReentry()return end end;if fk.periapsis~=nil and fk.apoapsis~=nil and fk.eccentricity<1 and ca>cx*0.9 and ca<cx*1.4 then if fk.apoapsis~=nil then if sa()or cy then if cy then aY=false;qa=0;pR=0;if not q6.VectorToTarget then bW="Orbit complete"fL("orCom","OB")cn.ToggleIntoOrbit()end else pX=pX+1;if pX>=2 then cy=true end end else cw="Adjusting Orbit - OrbitHeight: "..sc;pU=true;qb=se*3.6+1;local si=cx-ca;if sj==nil then sj=pid.new(0.1,0,1*0.1)end;sj:inject(si-cH*da(utils.smoothstep(2000-si,-2000,2000)^6*10,1,10))pR=da(sj:get(),-60,60)end end else local sk=2.75;local sl=eP(fM(sd*sk))local ou=sl%50;if ou>0 then sl=sl-ou+50 end;aY=false;if ca<cx*0.8 then cw="Escaping planet gravity - OrbitHeight: "..sc;pR=utils.map(cH,200,0,-15,80)elseif ca>=cx*0.8 and ca<cx*1.15 then cw="Approaching orbital corridor - OrbitHeight: "..sc;sl=sl*0.75;pR=utils.map(cH,100,-100,-15,65)elseif ca>=cx*1.15 and ca<cx*1.5 then cw="Approaching orbital corridor - OrbitHeight: "..sc;sl=sl*0.75;if cH<0 or pU then pR=utils.map(ca,cx*1.5,cx*1.01,-30,0)else pR=utils.map(ca,cx*0.99,cx*1.5,0,30)end elseif ca>cx*1.5 then cw="Reentering orbital corridor - OrbitHeight: "..sc;pR=-65;local sm=utils.map(cH,-150,-400,1,0.55)sl=sl*sm end;qb=bH(sl)end end;if pR~=nil then if sn==nil then sn=pid.new(1*0.01,0,5*0.1)end;local so=pR-cM;sn:inject(so)local sp=da(sn:get(),-0.5,0.5)q1=sp end end;if b0 and not c8 and not c4 then local function sq(hS,fk)a.print(hS)aY=false;ba=false;b0=false;qU=false;bd="Aligning"qa=0;p_=false;bW=hS;fL("apCom","AP")if fk or c4 then if fk and gg~=nil and not c4 then if not ca or ca==0 then return end;cx=ca;pV=true end;cn.ToggleIntoOrbit()end end;local sr,ss=bh,false;if fX and fX.planetname~="Space"then b9=true;if not qU then local st=(fX.position-c0.center):normalize()local su=st:project_on_plane((c0.center-cI):normalize()):normalize()local sv=c0.center+su*(c0.radius+gg)local sw=fX.position+(fX.position-c0.center):normalize()*(gg-c0:getAltitude(fX.position))if(cI-sv):len()<(cI-sw):len()then sr=sv else sr=sw;bc=0 end;bh=sr;cn.showWayPoint(c0,bh)ss=true;qU=true end;be=0 elseif fX and fX.planetname=="Space"then if not qU then be=0;ss=true;b9=true;qU=true;sr=fX.position+(cI-fX.position):normalize()*R;bh=sr end elseif fX==nil then be=0;if not qU then local st=(cI+cE*100000-c0.center):normalize()local su=st:project_on_plane((c0.center-cI):normalize()):normalize()if su:len()<1 then st=(cI+cB*100000-c0.center):normalize()su=st:project_on_plane((c0.center-cI):normalize()):normalize()end;sr=c0.center+su*(c0.radius+gg)bh=sr;qU=true;ss=true;b9=true;cn.showWayPoint(c0,bh)end end;pe=(vec3(sr)-cI):len()local lu,ez,eA=ci:getPlanetarySystem(0):castIntersections(cI,cE:normalize(),function(ei)if ei.noAtmosphericDensityAltitude>0 then return ei.radius+ei.noAtmosphericDensityAltitude else return ei.radius+ei.surfaceMaxAltitude*1.5 end end)local lv=ez;if eA~=nil and ez~=nil then lv=math.min(eA,ez)end;if lv~=nil and lv<pe and lu.name==c0.name then pe=lv end;local s4=true;local sx=(c0.center-(cI+vec3(cE):normalize()*pe)):len()-c0.radius;local lh=ik(sx)qi=g8;qj='{"label": "Projected Altitude", "value": "'..lh..'"}'local bZ,b_;if not b1 then bZ,b_=qo(cF)else bZ,b_=qq(cF)end;if cF>50 and b8 then local qO=vec3(sr)-cI;local sy=da(math.deg(qr(q7,cE:normalize(),qO:normalize()))*cF/500,-90,90)local sz=da(math.deg(qr(cC,cE:normalize(),qO:normalize()))*cF/500,-90,90)if eP(sy)<20 and eP(sz)<20 then sy=sy*2;sz=sz*2 end;if eP(sy)<2 and eP(sz)<2 then sy=sy*2;sz=sz*2 end;local rX=-math.deg(qr(q7,cB,cE:normalize()))local rY=-math.deg(qr(cC,cB,cE:normalize()))if sA==nil then sA=pid.new(2*0.01,0,2*0.1)end;sA:inject(sz-rY)local sB=da(sA:get(),-1,1)q1=q1+sB;if sC==nil then sC=pid.new(2*0.01,0,2*0.1)end;sC:inject(sy-rX)local sD=da(sC:get(),-1,1)q2=q2+sD;ss=true;if eP(sy)>2 or eP(sz)>2 then if bd~="Adjusting Trajectory"then bd="Adjusting Trajectory"fL("apAdj","AP")end else if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end end elseif b8 and cF<=50 then qH((sr-cI):normalize())end;if sx<gg*1.5 then if fX and fX.planetname=="Space"then bc=0 elseif fX==nil then dF,bc=ck(c0):escapeAndOrbitalSpeed(sx)end end;if b0 and not b8 and not bb and not ba then local lu,lv=cn.checkLOS((bh-cI):normalize())if c0.name~=iX.name then if lu~=nil and c0.name~=lu.name and lv<pe then bW="Collision with "..lu.name.." in "..ik(lv).."\nClear LOS to continue."bX=5;qf=true else qf=false;bW=""end end end;if not qf then if not bb and not ba and not ss then s4=qH((sr-cI):normalize())elseif b1 and(ba or bb)then s4=qH(-vec3(cE):normalize())end end;if b8 then if not p_ then aY=false;qa=a0;bK=fM(a0,2)p_=true end;local pf=c.getThrottle()if t then pf=bK end;local sE=99999;local os=-vec3(b.getWorldAcceleration()):dot(cE:normalize())local sF=da(cE:dot((sr-cI):normalize()),0,cF)if sF>0 or os>0 then sE=cj.computeTravelTime(sF,os,pe-bZ)end;if cD:len()>=_ or pf==0 and p_ or a1/4>sE then b8=false;if bd~="Cruising"then fL("apCru","AP")bd="Cruising"end;bb=true;qa=0 end;local sG=pe;if sG<=bZ or H and cQ<=bZ+10000 and cP then if H and cQ<=bZ+10000 and cP then if cQ<pL and cQ>2000 then cn.ResetAutopilots(1)bW="Autopilot cancelled to prevent crossing PvP Line"aY="PvP Prevent"pL=cQ else pL=cQ;return end end;b8=false;if bd~="Braking"then fL("apBrk","AP")bd="Braking"end;ba=true;qa=0;p_=false end elseif ba then if bd~="Orbiting to Target"then aY="AP Brk"end;if b1 then qa=1;qc=true end;local dF,se=ck(c0):escapeAndOrbitalSpeed((cI-iX.center):len()-iX.radius)local qO;if fX then qO=fX.position-cI end;if fX and fX.planetname=="Space"and cF<50 then if#bC>0 then if not ql then table.remove(bC,1)end;if#bC>0 then aY=false;if not ql then ql=2 end;return end end;sq("Autopilot complete, arrived at space location")aY="Space Arrival"elseif fX and fX.planetname~="Space"and cF<=se and(fk.apoapsis==nil or fk.periapsis==nil or fk.apoapsis.altitude<=0 or fk.periapsis.altitude<=0)then sq("Autopilot complete, commencing reentry")bh=fX.position;c4=true;cn.showWayPoint(c0,bh)elseif(fX and fX.planetname~="Space"or fX==nil)and fk.periapsis~=nil and fk.periapsis.altitude>0 and fk.eccentricity<1 or bd=="Circularizing"then if bd~="Circularizing"then fL("apCir","AP")bd="Circularizing"end;if cF<=se then if fX then if cE:normalize():dot(qO:normalize())>0.4 then if bd~="Orbiting to Target"then fL("apOrb","OB")bd="Orbiting to Target"end;if not qW then aY=false;cn.showWayPoint(c0,fX.position)qW=true end else sq("Autopilot complete, proceeding with reentry")bh=fX.position;c4=true;cn.showWayPoint(c0,fX.position)qW=false end else sq("Autopilot completed, setting orbit",true)aY=false end end elseif bd=="Circularizing"then sq("Autopilot complete, fixing Orbit",true)end elseif bb then local sG=pe;if sG<=bZ or H and cQ<=bZ+10000 and cP then if H and cQ<=bZ+10000 and cP then if cQ<pL and cQ>2000 then if not ql then ql=true end;bW="Autopilot cancelled to prevent crossing PvP Line"aY="Prevent PvP"pL=cQ else pL=cQ;return end end;b8=false;if bd~="Braking"then fL("apBrk","AP")bd="Braking"end;ba=true end;local pf=c.getThrottle()if t then pf=bK end;if pf>0 then b8=true;if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end;bb=false end else if s4 then if not b9 and fX==nil or not b9 and fX and fX.planetname~="Space"then if not c4 then bh=vec3(c0.center)+(gg+c0.radius)*cC;sH=q7;sI=cC end;b9=true elseif s4 and not qf then b8=true;if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end;if not p_ then qa=a0;qc=true;bK=fM(a0,2)p_=true;aY=false end end end end elseif b0 and(fX~=nil and fX.planetname~="Space"and c8)then bW="Autopilot complete, starting reentry"fL("apCom","AP")bh=fX.position;aY=false;ba=false;b0=false;qU=false;bd="Aligning"qa=0;p_=false;a_=true;c4=true;cn.showWayPoint(c0,fX.position)end;if bU then ct=true;local sz=0;local fm=cI+vec3(c.getMasterPlayerRelativePosition())local sJ=fm-cI;local sK=vec3(sJ):project_on(cB):len()local sL=vec3(sJ):project_on(cC):len()local c3=dc(sK*sK+sL*sL)qH(sJ:normalize())local mB=40;local sM=c3<mB;local sN=100;local rd=da((c3-mB)/2,10,sN)q1=0;local s4=eP(q2)<0.1;if s4 and cF<rd and not sM then aY=false;sz=-20 else aY="Follow"sz=0 end;local sO=0;if eP(sz-cM)>sO then if sP==nil then sP=pid.new(2*0.01,0,2*0.1)end;sP:inject(sz-cM)local sB=sP:get()q1=sB end end;if b2 or b3 or b5 or bn or bq~=nil then local sQ=br;if sQ then sQ=sQ*da(cF/100,0.1,1)*c9 else sQ=bp end;if not c8 then sQ=bp end;q9=cB:project_on_plane(cG):normalize():dot(cE)if q9>100 then bZ,b_=cj.computeDistanceAndTime(q9,100,cb,0,0,sQ)local sR,sS=cj.computeDistanceAndTime(100,0,cb,0,0,sQ*0.55)bZ=bZ+sR else bZ,b_=cj.computeDistanceAndTime(q9,0,cb,0,0,sQ*0.55)end;local si=b7-ca-cH;local sT=200+cF;if b5 or c4 then sU=2000+cF end;local sV=1;if b4 then sV=da(cF/100,0.1,1)end;local sz=(utils.smoothstep(si,-sT,sT)-0.5)*2*O*sV;if not b5 and not c4 and not bn and cB:dot(cE:normalize())<0.99 then sz=(utils.smoothstep(si,-sT*da(20-19*c9*10,1,20),sT*da(20-19*c9*10,1,20))-0.5)*2*O*da(2-c9*10,1,2)*sV end;if not b2 then sz=0 end;if bq~=nil then if cS and not bw then sz=bq else bq=nil end end;ct=true;local sW=q1;if b5 then local sX=bH(cv)local sY,sZ=cj.computeDistanceAndTime(cF,sX/3.6,cb,0,0,bp-iX.gravity*9.8*cb)sY=sY==-1 and 5000 or sY;local qV=ca-(iX.noAtmosphericDensityAltitude+sY)local s_=ca>iX.noAtmosphericDensityAltitude+sY*1.35;if s_ then sz=P;if cF<=sX/3.6 and cF>sX/3.6-10 and eP(cE:normalize():dot(cB))>0.9 and not cL then bO=false;qa=1 end elseif(cL or ig:getTargetSpeed(axisCommandId.longitudinal)~=sX)and not s_ and not c8 then qb=sX;qc=true end;if cL then if cF>sX/3.6 and not s_ then aY="Reentry Limit"else aY=false end else aY=false end;if cH>0 then aY="Reentry vSpd"end;if not q0 then sz=-80;if ca<iX.surfaceMaxAltitude+(iX.atmosphereThickness-iX.surfaceMaxAltitude)*0.25 then bW="PARACHUTE DEPLOYED at "..fM(ca,0)b5=false;b3=true;lp=true;qa=0;sz=0;ct=p end elseif iX.noAtmosphericDensityAltitude>0 and s_ then ct=true elseif not s_ then if not c8 and(cL or ig:getTargetSpeed(axisCommandId.longitudinal)~=sX)then qb=sX end;if cF<sX/3.6+1 then aY=false;q0=false;b5=false;ct=true end end end;if cF>iA and not c5 and not bn and not b3 and u then qH(vec3(cE))end;if cR or(bn or c5)and bi>0 and c8 then local qO;if cR then if type(cR)=="table"then qO=cR elseif cR<3 and cR>0 then qO=-cG:cross(cE)*5000 elseif cR>=3 then qO=cG:cross(cE)*5000 elseif cR<0 then qO=cE*25000 end elseif fX~=nil then qO=fX.position-cI else qO=c0.center-cI end;local sy=math.deg(qr(cG:normalize(),cE,qO))*2;local mE=math.rad(eP(cN))if cF>aH and c8 then local t0=1000+cF;local t1=(utils.smoothstep(si-cH*10,-t0,t0)-0.5)*2*O;local t2=da(90-t1,0,180)q4=da(sy*2,-t2,t2)local t3=sy;sy=da(da(sy,-L*0.80,L*0.80)*math.cos(mE)+4*(cM-sz)*math.sin(math.rad(cN)),-L*0.80,L*0.80)local t4=1;if q4~=0 then t4=eP(mE/q4)end;t4=(90-da(eP(q4-cN),0,90))/90;local t5=sz;if eP(cN)>90 then t5=-t5 end;sz=t4*da(da(t5*math.cos(mE),-M*0.8,M*0.8)+eP(da(eP(t3)*math.sin(mE),-M*0.80,M*0.80)),-M*0.80,M*0.80)else q4=0;sy=da(sy,-L*0.80,L*0.80)end;local t6=rX-sy;if cR and eP(t6)<=0.0001 and(type(cR)=="table"or type(cR)~="table"and cR<0 and eP(cN)<1)then if cR==-2 then cn.ToggleAltitudeHold()end;cR=nil;fL("180Off","BR")return end;if not cu and cF>aH and c8 then if t7==nil then t7=pid.new(2*0.01,0,2*0.1)end;t7:inject(t6)local sD=da(t7:get(),-1,1)q2=q2+sD elseif c8 and c7>-1 or cF<aH then qH(qO)elseif cu and c8 then if(rX<-L or rX>L)and c8 then qH(cE)end;if(rY<-M or rY>M)and c8 then sz=da(cM-rY,cM-M*0.80,cM+M*0.80)end end;if fX~=nil and not c5 then local s5=iX:getAltitude(fX.position)local qV=qO:project_on_plane(cG):len()lp=true;if not c5 and not b4 and not b5 and(qV<=bZ and qO:len()<iX.radius)and(cE:project_on_plane(cG):normalize():dot(qO:project_on_plane(cG):normalize())>0.99 or ly=="Finalizing Approach")then ly="Finalizing Approach"if#bC>0 then if not ql then table.remove(bC,1)end;if#bC>0 then if not ql then ql=2 end;return end end;qa=0;if b2 then cn.ToggleAltitudeHold()bn=true end;aY="AP Finalizing"elseif not b4 then aY=false end;if ly=="Finalizing Approach"and(q9<0.1 or qV<0.1 or t8~=nil and t8<qV)then fL("bklOn","BL")b3=true;d5=true;if fX.heading then d6=fX.heading else d6=nil end;bn=false;ly="Proceeding to Waypoint"cT=false end;t8=qV end elseif bn and not c8 and b7>iX.noAtmosphericDensityAltitude and not(c5 or b5)then if fX~=nil and c0.name==iX.name then local qO=fX.position-cI;local s5=iX:getAltitude(fX.position)local qV=dc(qO:len()^2-(ca-s5)^2)local sQ=br;if sQ then bZ,b_=cj.computeDistanceAndTime(cF,0,cb,0,0,sQ/2)lp=true;if qV<=bZ+cF*rW/2 and cE:project_on_plane(cG):normalize():dot(qO:project_on_plane(cG):normalize())>0.99 then if iX.hasAtmosphere then aY=false;a_=false;q0=true;c4=false;c6=true;b0=false;cn.BeginReentry()end end;t8=qV end end end;if not c8 and(b2 and b7>iX.noAtmosphericDensityAltitude)and not(c5 or bw or b5)then if not cy and not bw then cx=b7;pV=true;if bn then q6.VectorToTarget=true end;cn.ToggleIntoOrbit()bn=false;pT=true end end;if cu and c8 and c7==-1 and cF>aH and ly~="Finalizing Approach"then qH(cE)sz=da(cM-rY,cM-M*0.80,cM+M*0.80)end;q1=sW;local qA=-1;if b3 then if not qg then if not cL then qa=0 end;ig:setTargetGroundAltitude(500)ig:activateGroundEngineAltitudeStabilization(500)by=true;qg=true end;sz=0;local t9=false;local ta=math.abs(q9)if not q and cK then t9=antigrav.getBaseAltitude()if t9<iX.surfaceMaxAltitude and fX==nil or fX~=nil and iX:getAltitude(fX.position)>t9 then t9=false end else t9=false end;if d6 then if ta<0.05 then if cH>-N then aY=false else aY="BL Align BLR"end;if qH(d6,0.001)then d6=nil;ct=p else q1=0;ct=true end else aY="BL Align Hzn"end;if t9 and eP(ca-t9)<250 then aY="AGG Align"end else local tb=false;local tc=30;if ta<10 and s1~=nil and s1>0 then local td=da(c9,0.4,2)local sQ=br*da(cF/100,0.1,1)*td;local te=s1*td+sQ-of;local tf=sQ/2-of;local tg=cF-dc(eP(tf/2)*20/(0.5*cb))*utils.sign(tf)if tg<0 then tg=0 end;local th;if cF>100 then local ti,dF=cj.computeDistanceAndTime(cF,100,cb,0,0,sQ)local tj,dF=cj.computeDistanceAndTime(100,0,cb,0,0,dc(sQ))th=ti+tj else th=cj.computeDistanceAndTime(cF,0,cb,0,0,dc(sQ))end;if th<20 then aY=false else local tk=0;if tg>100 then local tl,dF=cj.computeDistanceAndTime(tg,100,cb,0,0,te)local tm,dF=cj.computeDistanceAndTime(100,0,cb,0,0,s1*td+dc(sQ)-of)tk=tl+tm else tk,dF=cj.computeDistanceAndTime(tg,0,cb,0,0,s1*td+dc(sQ)-of)end;tk=(tk+15+cF*rW)*1.1;local tn=d5 and fX~=nil and iX:getAltitude(fX.position)>0 and fX.safe;local s5=nil;if t9 and t9<ca then s5=t9 elseif tn then s5=iX:getAltitude(fX.position)+250 elseif ca>iX.surfaceMaxAltitude then s5=iX.surfaceMaxAltitude end;if cU then local to=iX:getAltitude(cU[1].center)if s5 then if to>s5 then s5=to end else s5=to end end;if s5~=nil then local tp=ca-s5;tb=true;if tp<=tk or tk==-1 or ta>0.05 and d5 then if ta>0.05 and d5 then aY="BL AP Hzn"else aY="BL Stop Dist"end else aY=false end end end end;qA=c7;if qA>-1 then if(cF<1 or cE:normalize():dot(cG)<0)and not d6 then b3=false;b2=false;if not t9 then bj=true;if bP then qd=true;fL("grOut","LG",1)end;ig:setTargetGroundAltitude(Y)end;bT=0;aY="BL Complete"ct=p;d5=false else aY="BL Slowing"end elseif not tb then if lp and cE:normalize():dot(-gi)<0.999 then aY="BL Strong"qH()elseif ta>10 or ta>0.05 and d5 then aY="BL hSpd"elseif cH<-N then aY="BL BLR"else aY=false end end end else qg=false end;if b4 or c5 then local lu,eA,ez;if bh~=nil then lu,eA,ez=ci:getPlanetarySystem(0):castIntersections(cI,(bh-cI):normalize(),function(ei)return ei.radius+ei.noAtmosphericDensityAltitude end)end;if cK and not c5 then if ca>=b7-50 and cF>iA then b4=false;if not b0 and not bn then aY="ATO Agg Arrive"qa=0 end end elseif eP(sz)<15 and ca/b7>0.75 then b4=false;if not c5 then if cL and not t then d.control.cancelCurrentControlMasterMode()end elseif c5 and cF<iA then b0=true;c5=false;b2=false;b4=false;qa=0 elseif c5 then qa=0;aY="ATO Space"end elseif c5 and not c8 and c0~=nil and(lu==nil or lu.name==c0.name)then b0=true;c5=false;b2=false;b4=false;if not cL then qa=0 end;b8=true end end;local tq=c7>-1;local tr=cM;if(bn or c5 or cR)and not tq and cF>aH and c8 then local mE=math.rad(eP(cN))tr=cM*eP(math.cos(mE))+rY*math.sin(mE)end;local ts=da(sz-tr,-M*0.80,M*0.80)if not c8 and bn then ts=da(sz-tr,-85,O)elseif not c8 then ts=da(sz-tr,-O,O)end;if eP(cN)<5 or bn or cR or b3 or tq or b2 then if sP==nil then sP=pid.new(5*0.01,0,5*0.1)end;sP:inject(ts)local sB=sP:get()q1=q1+sB end end;if antigrav~=nil and(antigrav and not q and ca<200000)then if bs==nil or bs<1000 then bs=1000 end;if tt~=bs then tt=bs;qk=tt end end;if c8 and t and cL then if tu==nil then tu=pid.new(0.1,0,1)end;local tv=0;if aR>0 and not b5 and c9>0.005 and c9<0.1 and cH>-50 then tv=(0.1-c9)*cv*aR end;tu:inject(cv/3.6+tv-cE:dot(cB))local tw=tu:get()bN=da(tw,-1,1)if not d1 then if bN<bK and c9>0.005 then bM=true;d1=da(bN,0.01,1)else bM=false;d1=bK end end;if tx==nil then tx=pid.new(1*0.01,0,1*0.1)end;tx:inject(cE:len()-cv/3.6-tv)local ty=da(tx:get(),0,1)if c8 and cH<-80 or c9>0.005 then bL=ty end;if bL>0 then if bM and bN==0.01 and not d1 then d1=0 end else bN=da(bN,0.01,1)end;local tz=''local tA=vec3()local tB=rb(axisCommandId.vertical,bT*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tB,rR)local tC='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then tC=tC..aS end;local tD=ig:getAxisCommandType(axisCommandId.longitudinal)local tE=ig:composeAxisAccelerationFromThrottle(tC,axisCommandId.longitudinal)local tF=rp(axisCommandId.lateral,bv*1000)tz=tz..' , '.."lateral airfoil , lateral ground "tA=tA+tF;if tA:len()>constants.epsilon then d:setEngineForceCommand(tz,tA,rR,'','','',rS)end;d:setEngineForceCommand(tC,tE,rQ)local tG='thrust analog vertical fueled 'local tH='thrust analog lateral fueled 'if bz=="All"or bz=="Lateral"then tH=tH..aT end;if bz=="All"or bz=="Vertical"then tG=tG..aU end;if bT~=0 or b3 and aY or not bj and not by then d:setEngineForceCommand(tG,tB,rQ)else d:setEngineForceCommand(tG,vec3(),rQ)end;if bv~=0 then d:setEngineForceCommand(tH,tF,rQ)else d:setEngineForceCommand(tH,vec3(),rQ)end;if rC==0 then rC=bL end;local tI=-rC*(aM*cE+aN*rG)d:setEngineForceCommand('brake',tI)else if t then if not d1 then d1=bK end end;local rd=c.getAxisCommandValue(0)if not cL then if tx==nil then tx=pid.new(1*0.01,0,1*0.1)end;tx:inject(cE:len()-rd/3.6)local ty=da(tx:get(),0,1)rC=da(rC+ty,0,1)end;local tI=-rC*(aM*cE+aN*rG)d:setEngineForceCommand('brake',tI)local tz=''local tA=vec3()local tJ=false;local tC='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then tC=tC..aS end;local tD=ig:getAxisCommandType(axisCommandId.longitudinal)if tD==axisCommandType.byThrottle then local tE=ig:composeAxisAccelerationFromThrottle(tC,axisCommandId.longitudinal)d:setEngineForceCommand(tC,tE,rQ)elseif tD==axisCommandType.byTargetSpeed then local tE=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tz=tz..' , '..tC;tA=tA+tE;if ig:getTargetSpeed(axisCommandId.longitudinal)==0 or ig:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ig:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tJ=true end end;local tH='thrust analog lateral 'if bz=="All"or bz=="Lateral"then tH=tH..aT end;local tK=ig:getAxisCommandType(axisCommandId.lateral)if tK==axisCommandType.byThrottle then local tL=ig:composeAxisAccelerationFromThrottle(tH,axisCommandId.lateral)d:setEngineForceCommand(tH,tL,rQ)elseif tK==axisCommandType.byTargetSpeed then local tF=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tz=tz..' , '..tH;tA=tA+tF end;local tG='thrust analog vertical 'if bz=="All"or bz=="Vertical"then tG=tG..aU end;local tM=ig:getAxisCommandType(axisCommandId.vertical)if tM==axisCommandType.byThrottle then local tB=ig:composeAxisAccelerationFromThrottle(tG,axisCommandId.vertical)if bT~=0 or b3 and aY then d:setEngineForceCommand(tG,tB,rQ,'airfoil','ground','',rS)else d:setEngineForceCommand(tG,vec3(),rQ)d:setEngineForceCommand('airfoil vertical',tB,rQ,'airfoil','','',rS)d:setEngineForceCommand('ground vertical',tB,rQ,'ground','','',rS)end elseif tM==axisCommandType.byTargetSpeed then if bT<0 then d:setEngineForceCommand('hover',vec3(),rQ)end;local tN=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tz=tz..' , '..tG;tA=tA+tN end;if tA:len()>constants.epsilon then if rC~=0 or tJ or eP(rG:dot(cB))<0.5 then tz=tz..', brake'end;d:setEngineForceCommand(tz,tA,rR,'','','',rS)end end;local tO=aJ*(rK-rJ)local tP=vec3(b.getWorldAirFrictionAngularAcceleration())tO=tO-tP;d:setEngineTorqueCommand('torque',tO,rQ,'airfoil','','',rS)d:setBoosterCommand('rocket_engine')if bY and not n then local fg=cD:len()local tQ=0.15;if not cL then local tR=ig:getTargetSpeed(axisCommandId.longitudinal)if fg*3.6>tR*(1-tQ)and tS then tS=false;d:toggleBoosters()elseif fg*3.6<tR*(1-tQ)and not tS then tS=true;d:toggleBoosters()end else local pf=c.getThrottle()if t then pf=bK*100 end;local rd=pf/100;if bI==0 then rd=rd*_;if fg>=rd*(1-tQ)and tS then tS=false;d:toggleBoosters()elseif fg<rd*(1-tQ)and not tS then tS=true;d:toggleBoosters()end else local sX=bH(cv)rd=rd*sX/3.6;if fg>=rd*(1-tQ)and tS then tS=false;d:toggleBoosters()elseif fg<rd*(1-tQ)and not tS then tS=true;d:toggleBoosters()end end end end end;if tT then for dA,dl in pairs(tT)do pJ[dA]=dl end end;c7=qv()return pJ end;local function tU(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,ie,ig,ih,tV,gD,fM,dV,db,da,fL,ij,pI)local tW={}local tX=true;local tY=5;local tZ=5;local t_=tY;local u0=tZ;local u1=bJ;function tW.startControl(u2)local function u3(r5)local r6=1;local function u4(u5,r5)local u6={iX.surfaceMaxAltitude+100,iX.spaceEngineMinAltitude-0.01*iX.noAtmosphericDensityAltitude,iX.noAtmosphericDensityAltitude+T,iX.radius*(S-1)+iX.noAtmosphericDensityAltitude}local u7=u5;for dF,dl in ipairs(u6)do if r5 and u7>dl then u5=dl elseif u5<dl and not r5 then u5=dl;break end end;return u5 end;if r5 then r6=-1 end;if not q and cK then if bV and r5 then bs=1000 elseif bs~=nil then bs=bs+r6*tZ;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end else bs=tt+r6*100 end elseif b2 or b6 or bw then if bw then if bV then cx=u4(cx,r5)else cx=cx+r6*tY end;if cx<iX.noAtmosphericDensityAltitude then cx=iX.noAtmosphericDensityAltitude end else if bV and c8 then b7=u4(b7,r5)else b7=b7+r6*tY end end else ig:updateTargetGroundAltitudeFromActionStart(r6*1.0)end end;local function u8(u9)if not c8 then bW="Flight Assist in Atmo only"return end;local di=type(u9)if cR==nil then if di=="table"then if b0 or bn then cn.ToggleAutopilot()end;fL("180On","BR")elseif u9==1 then fL("bnkLft","BR")else fL("bnkRht","BR")end;if not b2 and not b0 and not bn then cn.ToggleAltitudeHold()if di~="table"then u9=u9+1 end end;cR=u9 else fL("180Off","BR")cR=nil end end;if u2=="gear"then bj=not bj;if bj then bn=false;bq=nil;cn.cmdThrottle(0)if vBooster or hover then if c8 and c7==-1 then fL("bklOn","BL")lp=true;b5=false;b4=false;b6=false;b2=false;if b3 then d5=not d5 end;b3=true;ct=true;bj=false else if bP then fL("grOut","LG",1)d.control.extendLandingGears()end;d5=false;ig:setTargetGroundAltitude(Y)if c8 then aY="Landing"end end end;if bP and not b3 and not(vBooster or hover)then fL("grOut","LG",1)d.control.extendLandingGears()end else if bP then fL("grIn","LG",1)d.control.retractLandingGears()end;ig:setTargetGroundAltitude(X)end elseif u2=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif u2=="forward"then bQ=bQ-1 elseif u2=="backward"then if p1 then u8(-cE*5000)else bQ=bQ+1 end elseif u2=="left"then if p1 then u8(1)else bR=bR-1 end elseif u2=="right"then if p1 then u8(3)else bR=bR+1 end elseif u2=="yawright"then bS=bS-1;d6=nil elseif u2=="yawleft"then bS=bS+1;d6=nil elseif u2=="straferight"then ig:updateCommandFromActionStart(axisCommandId.lateral,1.0)bv=1 elseif u2=="strafeleft"then ig:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bv=-1 elseif u2=="up"then bT=bT+1;ig:deactivateGroundEngineAltitudeStabilization()ig:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif u2=="down"then bT=bT-1;ig:deactivateGroundEngineAltitudeStabilization()ig:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif u2=="groundaltitudeup"then u3()elseif u2=="groundaltitudedown"then u3(true)elseif u2=="option1"then ua=false;if p1 and bV then local ub=""for K=1,#cX do ub=ub.."| Name: "..a.getPlayerName(cX[K]).." Mass: "..fM(b.getBoardedPlayerMass(cX[K])/1000,1).."t "end;a.print("Onboard: "..ub)return end;cm.adjustAutopilotTargetIndex()elseif u2=="option2"then ua=false;if p1 and bV then for K=1,#cX do b.forceDeboard(cX[K])end;bW="Deboarded All Passengers"return end;cm.adjustAutopilotTargetIndex(1)elseif u2=="option3"then local function uc()tX=not tX;if not tX then fL("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(ud,atmofueltank_size,"Atmo Fuel","fuel_container")ue=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uf,spacefueltank_size,"Space Fuel","fuel_container")ug=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uh,rocketfueltank_size,"Rocket Fuel","fuel_container")ui=_autoconf.panels[_autoconf.panels_size]end;uj=a.createWidgetPanel("Docking")uk=a.createWidget(uj,"parenting")a.addDataToWidget(c.getDataId(),uk)ul=a.createWidgetPanel("Core combat stress")um=a.createWidget(ul,"core_stress")a.addDataToWidget(b.getDataId(),um)if shield_1~=nil then shield_1.show()end else fL("hud","DH")c.hide()b.hide()if ue~=nil then gD(ue)ue=nil end;if uj~=nil then gD(uj)uj=nil end;if ul~=nil then gD(ul)ul=nil end;if ug~=nil then gD(ug)ug=nil end;if ui~=nil then gD(ui)ui=nil end;if shield_1~=nil then shield_1.hide()end end end;ua=false;if p1 and bV then local ub=""for K=1,#cY do ub=ub.."| ID: "..cY[K].." Mass: "..fM(b.getDockedConstructMass(cY[K])/1000,1).."t "end;a.print("Docked Ships: "..ub)return end;if x then if w then w=false else w=true end end;uc()elseif u2=="option4"then ua=false;if p1 and bV then for K=1,#cY do b.forceUndock(cY[K])end;bW="Undocked all ships"return end;cR=nil;cn.ToggleAutopilot()elseif u2=="option5"then ua=false;cn.ToggleLockPitch()elseif u2=="option6"then ua=false;if p1 and bV then if shield_1 then cq.ventShield()else bW="No shield found"end;return end;cn.ToggleAltitudeHold()elseif u2=="option7"then ua=false;if p1 and bV then if shield_1 then shield_1.toggle()return else bW="No shield found"return end end;E=not E;if E then bW="Collision System Enabled"else bW="Collision System Secured"end elseif u2=="option8"then ua=false;if p1 and bV then if bi>0 and fX~=nil then cn.routeWP()else bW="Select a saved wp on IPH to add to or remove from route"end;return end;by=not by;if not by then bW="DeCoupled Mode - Ground Stabilization off"ig:deactivateGroundEngineAltitudeStabilization()fL("gsOff","GS")else bW="Coupled Mode - Ground Stabilization on"ig:activateGroundEngineAltitudeStabilization(un)d:setEngineForceCommand('hover',vec3(),1)fL("gsOn","GS")end elseif u2=="option9"then ua=false;if p1 and bV then ig:resetCommand(axisCommandId.longitudinal)ig:resetCommand(axisCommandId.lateral)ig:resetCommand(axisCommandId.vertical)cn.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cc=gyro.getState()==1;if cc then fL("gyOn","GA")else fL("gyOff","GA")end else bW="No gyro found"end elseif u2=="lshift"then cV=false;if p1 then bV=true end;if ih()==1 then bV=true;bf=ih()tV(1)elseif ie()==1 and y then bV=true;cs=false;cr=false end elseif u2=="brake"then if aW or p1 then cn.BrakeToggle("Manual")elseif not aY then cn.BrakeToggle("Manual")else aY="Manual"end elseif u2=="lalt"then ua=true;p1=true;if ie()==0 and not i and g=="keyboard"then tV(1)end elseif u2=="booster"then if n then d:toggleBoosters()elseif not bY then if not tS then d:toggleBoosters()tS=true end;bY=true else if tS then d:toggleBoosters()tS=false end;bY=false end elseif u2=="stopengines"then local function uo()if bJ-u1<1.5 then fL("clear","CA")cn.clearAll()end end;uo()u1=bJ;if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then ig:resetCommand(axisCommandId.longitudinal)cn.cmdThrottle(0)else cn.cmdThrottle(100)end else if ig:getTargetSpeed(axisCommandId.longitudinal)~=0 then ig:resetCommand(axisCommandId.longitudinal)else if c8 then cn.cmdCruise(U)else cn.cmdCruise(_*3.6)end end end elseif u2=="speedup"then cn.changeSpd()elseif u2=="speeddown"then cn.changeSpd(true)elseif u2=="antigravity"and not q then if antigrav~=nil then cn.ToggleAntigrav()else bW="No antigrav found"end end end;function tW.stopControl(u2)local function up()if not q and cK then u0=tZ end;if b2 or b6 or bw then t_=tY end end;if u2=="forward"then bQ=0 elseif u2=="backward"then bQ=0 elseif u2=="left"then if cR then if cR==2 then cR=-2 else cR=-1 end end;bR=0 elseif u2=="right"then if cR then if cR==4 then cR=-2 else cR=-1 end end;bR=0 elseif u2=="yawright"then bS=0 elseif u2=="yawleft"then bS=0 elseif u2=="straferight"then ig:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bv=0 elseif u2=="strafeleft"then ig:updateCommandFromActionStop(axisCommandId.lateral,1.0)bv=0 elseif u2=="up"then bT=0;ig:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if by then ig:activateGroundEngineAltitudeStabilization(un)d:setEngineForceCommand('hover',vec3(),1)end elseif u2=="down"then bT=0;ig:updateCommandFromActionStop(axisCommandId.vertical,1.0)if by then ig:activateGroundEngineAltitudeStabilization(un)d:setEngineForceCommand('hover',vec3(),1)end elseif u2=="groundaltitudeup"then up()ua=false elseif u2=="groundaltitudedown"then up()ua=false elseif u2=="lshift"then if ih()==1 then c1=0;c2=0;tV(bf)elseif ie()==1 and y then cs=false;cr=false end;bV=false elseif u2=="brake"then if not aW and not p1 then if aY then cn.BrakeToggle()else aY=false end end elseif u2=="lalt"then if ie()==0 and i then if ua then if ih()==1 then tV(0)else tV(1)end else ua=true end elseif ie()==0 and not i and g=="keyboard"then tV(0)end;p1=false end end;function tW.loopControl(u2)local function uq(r5)local r6=1;if r5 then r6=-1 end;if not q and cK then if bs~=nil then bs=bs+r6*u0;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end;u0=da(u0*1.05,tZ,50)else bs=tt+r6*100 end elseif b2 or b6 or bw then if bw then cx=cx+r6*t_;if cx<iX.noAtmosphericDensityAltitude then cx=iX.noAtmosphericDensityAltitude end else b7=b7+r6*t_ end;t_=da(t_*1.05,tY,50)else ig:updateTargetGroundAltitudeFromActionLoop(r6*1.0)end end;local function ur(r5)local r6=1;if r5 then r6=-1 end;if not bV then if t and not p1 then bK=da(bK+r6*aB/100,-1,1)else ig:updateCommandFromActionLoop(axisCommandId.longitudinal,r6*aB)end end end;if u2=="groundaltitudeup"then if not bV then uq()end elseif u2=="groundaltitudedown"then if not bV then uq(true)end elseif u2=="speedup"then ur()elseif u2=="speeddown"then ur(true)end end;function tW.inputTextControl(r4)local function us(ut,fm,gq)local function uu(fm)local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..ds..','..ds..','..ds..','..ds..','..ds..'}'local dJ,dK,dS,dT,dU=dV(fm,dt)if dJ=="0"and dK=="0"then return vec3(db(dS),db(dT),db(dU))end;dT=math.rad(dT)dS=math.rad(dS)local iX=e[db(dJ)][db(dK)]local eL=math.cos(dS)local uv=vec3(eL*math.cos(dT),eL*math.sin(dT),math.sin(dS))return iX.center+(iX.radius+dU)*uv end;local fO=uu(fm)return cm.AddNewLocation(ut,fO,gq)end;local K;local uw,i3=nil,nil;local ux="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(r4," ")uw=r4;if K~=nil then uw=string.sub(r4,0,K-1)i3=string.sub(r4,K+1)end;if uw=="/help"or uw=="/commands"then for lq in string.gmatch(ux,"([^\n]+)")do a.print(lq)end;return elseif uw=="/setname"then if i3==nil or i3==""then bW="Usage: ah-setname Newname"return end;if bi>0 and fX~=nil then cm.UpdatePosition(i3)else bW="Select a saved target to rename first"end elseif shield_1 and uw=="/resist"then cq.setResist(i3)elseif uw=="/addlocation"or string.find(r4,"::pos")~=nil then local gq=false;local ut="0-Temp"if i3==nil or i3==""or uw~="/addlocation"then i3=uw;gq=true end;K=string.find(i3,"::")if not gq then ut=string.sub(i3,1,K-2)end;local fm=string.sub(i3,K)us(ut,fm,gq)elseif uw=="/agg"then if i3==nil or i3==""then bW="Usage: /agg targetheight"return end;i3=db(i3)if i3<1000 then i3=1000 end;bs=i3;bW="AGG Target Height set to "..i3 elseif uw=="/G"then if i3==nil or i3==""then bW="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if i3=="dump"then for dA,dl in pairs(ij())do if type(dl.get())=="boolean"then if dl.get()==true then a.print(dA.." true")else a.print(dA.." false")end elseif dl.get()==nil then a.print(dA.." nil")else a.print(dA.." "..dl.get())end end;return end;K=string.find(i3," ")local uy=string.sub(i3,0,K-1)local uz=string.sub(i3,K+1)for dA,dl in pairs(ij())do if dA==uy then bW="Variable "..uy.." changed to "..uz;local uA=type(dl.get())if uA=="number"then uz=db(uz)if dA=="AtmoSpeedLimit"then cv=uz end elseif uA=="boolean"then if string.lower(uz)=="true"then uz=true else uz=false end end;dl.set(uz)return end end;bW="No such global variable: "..uy elseif uw=="/deletewp"then if bi>0 and fX~=nil then cm.ClearCurrentPosition()else bW="Select a custom wp to delete first in IPH"end elseif uw=="/copydatabank"then if dbHud_2 then pI(true)else bW="Spare Databank required to copy databank"end elseif uw=="/iphWP"then if bi>0 then a.print(cn.showWayPoint(c0,bh,true))a.print(json.encode(bh))bW="::pos waypoint shown in lua chat in local and world format"else bW="No target selected in IPH"end elseif uw=="/createPrivate"then local uB="privatelocations = {\n"local uC=""if#d3>0 then for dA,dl in pairs(d3)do uB=uB.."{position = {x = "..dl.position.x..", y = "..dl.position.y..", z = "..dl.position.z.."},\n ".."name = '"..dl.name.."',\n planetname = '"..dl.planetname.."',\n gravity = "..dl.gravity..",\n"if dl.heading then uB=uB.."heading = {x = "..dl.heading.x..", y = "..dl.heading.y..", z = "..dl.heading.z.."},\n"end;if dl.safe then uB=uB.."safe = true},\n"else uB=uB.."safe = false},\n"end end end;uC=#d3 .."-Private "if i3=="all"then for dA,dl in pairs(bm)do uB=uB.."{position = {x = "..dl.position.x..", y = "..dl.position.y..", z = "..dl.position.z.."},\n ".."name = '*"..dl.name.."',\n planetname = '"..dl.planetname.."',\n gravity = "..dl.gravity..",\n"if dl.heading then uB=uB.."heading = {x = "..dl.heading.x..", y = "..dl.heading.y..", z = "..dl.heading.z.."},\n"end;if dl.safe then uB=uB.." safe = true},\n"else uB=uB.."safe = false},\n"end end;uC=uC..#bm.."-Public "end;uB=uB.."}\n return privatelocations"if screenHud_1 then screenHud_1.setHTML(uB)end;bW=uC.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bX=7 end end;function tW.tagTick()if bz=="Off"then bz="All"elseif bz=="All"then bz="Longitude"elseif bz=="Longitude"then bz="Lateral"elseif bz=="Lateral"then bz="Vertical"else bz="Off"end;bW="Extra Engine Tags: "..bz;c.stopTimer("tagTick")end;if uD then for dA,dl in pairs(uD)do tW[dA]=dl end end;return tW end;local function uE(d,b,c,a,library,e,vBooster,hover,pH,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ib,screenHud_1)local uF={}local d9=string.format;local ic=json.decode;local uG=json.encode;local pA=b.getElementMaxHitPointsById;local id=b.getElementMassById;local ie=d.control.isRemoteControlled;local dV=string.match;local gD=a.destroyWidgetPanel;local fJ=a.updateData;local fK=a.addDataToWidget;local tV=a.lockView;local ih=a.isViewLocked;local dc=math.sqrt;local db=tonumber;local eP=math.abs;local bH=math.floor;local bI=c.getAtmosphereDensity;local eK=math.atan;local bG=a.getTime;local da=utils.clamp;local ig=d.axisCommandManager;local uH=Y;local gF=13;local im=b.getElementIdList()local io=0;local function dd(es,et)if es==0 then return eP(et)<1e-09 end;if et==0 then return eP(es)<1e-09 end;return eP(es-et)<math.max(eP(es),eP(et))*dr end;local function fM(ds,uI)local r6=10^(uI or 0)return bH(ds*r6+0.5)/r6 end;local function ii(uJ,uK)for dA,dl in pairs(uK)do if type(dA)=="string"then uJ[dA]=dl else uJ[#uJ+1]=uK[dA]end end;return uJ end;local function ij(uL)local uM={}if not uL then ii(uM,J)ii(uM,a8)ii(uM,az)ii(uM,aV)return uM elseif uL=="boolean"then return J elseif uL=="handling"then return a8 elseif uL=="hud"then return az elseif uL=="physics"then return aV end end;local function pI(uN)local function uO(uP)for dA,dl in pairs(uP)do dbHud_1.setStringValue(dA,uG(dl.get()))if uN and dbHud_2 then dbHud_2.setStringValue(dA,uG(dl.get()))end end end;if dbHud_1 then uO(bD)uO(ij())a.print("Saved Variables to Datacore")if uN and dbHud_2 then bW="Databank copied.  Remove copy when ready."end end end;local function fL(uQ,uR,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uQ..".mp3")end;local function gE(hf,hg,r4,jB,uS)if jB==nil then jB=""end;if uS==nil then uS=""end;return d9([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jB,hf,hg,uS,r4)end;local function ik(c3,uT)local uU=c3>100000;if uT==nil then uT=1 end;if uU then return fM(c3/1000/200,uT).."SU"elseif c3<1000 then return fM(c3,uT).."M"else return fM(c3/1000,uT).."KM"end end;local function il(uV)local uW=0;local uX=0;local uY=0;if uV<60 then uV=bH(uV)elseif uV<3600 then uW=bH(uV/60)uV=bH(uV%60)elseif uV<86400 then uX=bH(uV/3600)uW=bH(uV%3600/60)else uY=bH(uV/86400)uX=bH(uV%86400/3600)end;if uY>0 then return uY.."d "..uX.."h "elseif uX>0 then return uX.."h "..uW.."m "elseif uW>0 then return uW.."m "..uV.."s"elseif uV>0 then return uV.."s"else return"0s"end end;function uF.onStart()local uZ=false;local function u_()local function v0(v1)local v2=dbHud_1.hasKey;for dA,dl in pairs(v1)do if v2(dA)then local dv=ic(dbHud_1.getStringValue(dA))if dv~=nil then dl.set(dv)uZ=true end end end end;if dbHud_1 then if not f then v0(ij())coroutine.yield()v0(bD)else v0(bD)bW="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bX=5;uZ=false end;coroutine.yield()if uZ then bW="Loaded Saved Variables"cd=a9;ce=aa;aW=j;g=string.lower(g)ct=p;cv=U elseif not f then bW="No Saved Variables Found - Exit HUD to save settings"end;if bA<1.500 then if T<2000 then bW="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bA=VERSION_NUMBER;if#bm>0 then d4=ii(d4,bm)end else bW="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bt+180<bJ then br=0 end;bt=bJ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bW="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bX=7 end;if antigrav and not q then if bs==nil then bs=ca end;antigrav.setBaseAltitude(bs)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d3>0 then d4=ii(d4,d3)end end;ly="Proceeding to Waypoint"end;local function v3()local function v4(v5,v6)if v5>v6 then v6=v5 end;local v7,v8=0,0;if a5>0 then v7=a5*0.05 end;if a6>0 then v8=a6*0.05 end;v6=v6*(1-(v7+v8))return v6 end;local v9=b.getElementNameById;local va=aq~=0 and ar~=0;for dA in pairs(im)do local type=b.getElementTypeById(im[dA])if dV(type,'^.*Atmospheric Engine$')then if dV(tostring(b.getElementTagsById(im[dA])),'^.*vertical.*$')and b.getElementForwardById(im[dA])[3]>0 then cJ=true end end;if dV(type,'^.*Space Engine$')then cA=true;if dV(tostring(b.getElementTagsById(im[dA])),'^.*vertical.*$')then local vb=b.getElementForwardById(im[dA])if vb[3]<0 then vc=true else cz=true end end end;if type=="Landing Gear"then bP=true end;if type=="Dynamic Core Unit"then local pC=pA(im[dA])if pC>10000 then gF=110 elseif pC>1000 then gF=55 elseif pC>150 then gF=27 end end;io=io+pA(im[dA])if va and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pC=pA(im[dA])local on=id(im[dA])local v5=0;local jv=bG()if type=="Atmospheric Fuel Tank"then local v6=400;local vd=35.03;if pC>10000 then v6=51200;vd=5480 elseif pC>1300 then v6=6400;vd=988.67 elseif pC>150 then v6=1600;vd=182.67 end;v5=on-vd;if a2>0 then v6=v6+v6*a2*0.2 end;v6=v4(v5,v6)cf[#cf+1]={im[dA],v9(im[dA]),v6,vd,v5,jv}end;if type=="Rocket Fuel Tank"then local v6=320;local vd=173.42;if pC>65000 then v6=40000;vd=25740 elseif pC>6000 then v6=5120;vd=4720 elseif pC>700 then v6=640;vd=886.72 end;v5=on-vd;if a4>0 then v6=v6+v6*a4*0.1 end;v6=v4(v5,v6)ch[#ch+1]={im[dA],v9(im[dA]),v6,vd,v5,jv}end;if type=="Space Fuel Tank"then local v6=600;local vd=35.03;if pC>10000 then v6=76800;vd=5480 elseif pC>1300 then v6=9600;vd=988.67 elseif pC>150 then v6=2400;vd=182.67 end;v5=on-vd;if a3>0 then v6=v6+v6*a3*0.2 end;v6=v4(v5,v6)cg[#cg+1]={im[dA],v9(im[dA]),v6,vd,v5,jv}end end end;if not cJ then b6,aX=false,false end end;local function ve()if gyro~=nil then cc=gyro.getState()==1 end;if not by then ig:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then tV(1)else tV(0)end;if door and(c8 or not c8 and ca<10000)then for dF,dl in pairs(door)do dl.toggle()end end;if switch then for dF,dl in pairs(switch)do dl.toggle()end end;if forcefield and(c8 or not c8==0 and ca<10000)then for dF,dl in pairs(forcefield)do dl.toggle()end end;if antigrav then cK=antigrav.getState()==1;if cK and not q then antigrav.show()end end;if ie()==1 and k then a.freeze(1)else a.freeze(0)end;if bP then if c7~=-1 then d.control.extendLandingGears()else d.control.retractLandingGears()end;bj=d.control.isAnyLandingGearExtended()==1 end;if c7~=-1 or not c8 and cD:len()<50 then aY="Startup"else aY=false end;ig:setTargetGroundAltitude(uH)po=c8 end;local function vf()local vg={}local function vh()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vi={[1]=4480,[6]=4480,[7]=6270}for vj,vk in pairs(e)do e[vj][0]=vh()e[vj][0].systemId=vj;vg[vj]={}for vl,iX in pairs(e[vj])do iX.gravity=iX.gravity/9.8;iX.center=vec3(iX.center)iX.name=iX.name[1]iX.noAtmosphericDensityAltitude=iX.atmosphereThickness or iX.atmosphereRadius-iX.radius;iX.spaceEngineMinAltitude=vi[iX.id]or 0.68377*iX.atmosphereThickness;iX.planetarySystemId=vj;iX.bodyId=iX.id;vg[vj][vl]=iX;if mq==nil or iX.center.x<mq then mq=iX.center.x end;if mp==nil or iX.center.x>mp then mp=iX.center.x end;if mt==nil or iX.center.y<mt then mt=iX.center.y end;if ms==nil or iX.center.y>ms then ms=iX.center.y end;if iX.center and iX.name~="Space"then cZ[#cZ+1]=iX end end end;e4=d8(d,b,c,a,d9,da,db,dc,dd)ci=e4(vg)cj=eO(d,b,c,a,dc,eP)ck=fi(d,b,c,a,d9,da,db,dc,dd)cm=fI(d,b,c,a,dbHud_1,e,fJ,fK,bH,db,dc,fL,fM)iX=ci[0]:closestBody(b.getConstructWorldPos())end;vm=false;vn=coroutine.create(function()ig:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})u_()coroutine.yield()v3()coroutine.yield()cn=pG(d,b,c,a,e,vBooster,hover,pH,antigrav,warpdrive,dbHud_1,radar_1,eP,bH,bI,ie,eK,bG,da,ig,fJ,ih,dc,fM,fL,ii,dd,ik,il,pI,ic,d9,fK)ve()coroutine.yield()vf()if radar_1 then co=gC(b,a,c,library,radar_1,radar_2,eP,gD,dc,gE,db,gF,fL)end;cl=ia(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ib,eP,bH,d9,ic,bI,id,ie,eK,bG,da,ig,fK,fJ,gD,ih,dc,fM,gE,fL,ii,ij,ik,il,im,io)cl.ButtonSetup()cp=tU(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,ie,ig,ih,tV,gD,fM,dV,db,da,fL,ij,pI)if shield_1 then cq=hV(shield_1,dV,bH)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aQ)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield_1 then c.setTimer("shieldTick",0.0166667)end;if vo then vp.ExtraOnStart()end;fL("start","SU")end)coroutine.resume(vn)end;function uF.onUpdate()if not vm then local hK=coroutine.status(vn)if hK=="suspended"then local dB,hL=coroutine.resume(vn)if hL then a.print("ERROR STARTUP: "..hL)end elseif hK=="dead"then vm=true end end;if vm then d:update()if c8 and t and cL then if cL and bO then cn.cmdThrottle(0)bO=false elseif not cL and not bO then bK=0;bO=true end end;if d1 then ig:setThrottleCommand(axisCommandId.longitudinal,d1)d1=nil end;if not cr and p3~=vq then a.setScreen(p3)end;vq=p3;if vo then vp.ExtraOnUpdate()end end end;function uF.onFlush()if vm then cn.onFlush()if vo then vp.ExtraOnFlush()end end end;function uF.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c9>0 or c9==0 and ca<10000)then for dF,dl in pairs(door)do dl.toggle()end end;if switch then for dF,dl in pairs(switch)do dl.toggle()end end;if forcefield and(c9>0 or c9==0 and ca<10000)then for dF,dl in pairs(forcefield)do dl.toggle()end end;w=d0;pI()if nY then nY.activate()end;if z then cn.showWayPoint(iX,cI)end;a.print(cl.FuelUsed("atmofueltank")..", "..cl.FuelUsed("spacefueltank")..", "..cl.FuelUsed("rocketfueltank"))if vo then vp.ExtraOnStop()end;fL("stop","SU")end;function uF.controlStart(u2)if vm then cp.startControl(u2)end end;function uF.controlStop(u2)if vm then cp.stopControl(u2)end end;function uF.controlLoop(u2)if vm then cp.loopControl(u2)end end;function uF.controlInput(r4)if vm then cp.inputTextControl(r4)end end;function uF.radarEnter(dK)co.onEnter(dK)end;function uF.radarLeave(dK)co.onLeave(dK)end;function uF.onTick(vr)if vr=="tenthSecond"then cn.TenthTick()cl.TenthTick()elseif vr=="oneSecond"then cl.OneSecondTick()elseif vr=="fiveSecond"then cn.SatNavTick()elseif vr=="msgTick"then cl.MsgTick()elseif vr=="animateTick"then cl.AnimateTick()elseif vr=="hudTick"then cl.hudtick()elseif vr=="apTick"then cn.APTick()elseif vr=="shieldTick"then cq.shieldTick()elseif vr=="tagTick"then cp.tagTick()elseif vr=="contact"then co.ContactTick()end end;if vo then for dA,dl in pairs(vo)do uF[dA]=dl end end;return uF end;function script.onStart()vp.onStart()end;function script.onStop()vp.onStop()end;function script.onTick(vr)vp.onTick(vr)end;function script.onFlush()vp.onFlush()end;function script.onUpdate()vp.onUpdate()end;function script.onActionStart(u2)vp.controlStart(u2)end;function script.onActionStop(u2)vp.controlStop(u2)end;function script.onActionLoop(u2)vp.controlLoop(u2)end;function script.onInputText(r4)vp.controlInput(r4)end;function script.onEnter(dK)vp.radarEnter(dK)end;function script.onLeave(dK)vp.radarLeave(dK)end;bF(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)vp=uE(d,b,c,a,library,e,vBooster,hover,pH,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ib,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
