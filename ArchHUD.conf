name: ArchHud - Archaegeo v0.707 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.707;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=true;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(K)t=K end,get=function()return t end},AtmoSpeedAssist={set=function(K)u=K end,get=function()return u end},ForceAlignment={set=function(K)v=K end,get=function()return v end},DisplayDeadZone={set=function(K)w=K end,get=function()return w end},showHud={set=function(K)x=K end,get=function()return x end},hideHudOnToggleWidgets={set=function(K)y=K end,get=function()return y end},ShiftShowsRemoteButtons={set=function(K)z=K end,get=function()return z end},SetWaypointOnExit={set=function(K)A=K end,get=function()return A end},AlwaysVSpd={set=function(K)B=K end,get=function()return B end},BarFuelDisplay={set=function(K)C=K end,get=function()return C end},voices={set=function(K)D=K end,get=function()return D end},alerts={set=function(K)E=K end,get=function()return E end},CollisionSystem={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end}}a8=1920;a9=1080;aa=400;ab=130;ac=224;ad=255;ae=255;af=0;ag=0;ah=960;ai=540;aj=1300;ak=540;al=1525;am=325;an=550;ao=540;ap=30;aq=700;ar=1750;as=250;at=50;au=250;av=0;aw=30;ax=100;ay={ResolutionX={set=function(K)a8=K end,get=function()return a8 end},ResolutionY={set=function(K)a9=K end,get=function()return a9 end},circleRad={set=function(K)aa=K end,get=function()return aa end},SafeR={set=function(K)ab=K end,get=function()return ab end},SafeG={set=function(K)ac=K end,get=function()return ac end},SafeB={set=function(K)ad=K end,get=function()return ad end},PvPR={set=function(K)ae=K end,get=function()return ae end},PvPG={set=function(K)af=K end,get=function()return af end},PvPB={set=function(K)ag=K end,get=function()return ag end},centerX={set=function(K)ah=K end,get=function()return ah end},centerY={set=function(K)ai=K end,get=function()return ai end},throtPosX={set=function(K)aj=K end,get=function()return aj end},throtPosY={set=function(K)ak=K end,get=function()return ak end},vSpdMeterX={set=function(K)al=K end,get=function()return al end},vSpdMeterY={set=function(K)am=K end,get=function()return am end},altMeterX={set=function(K)an=K end,get=function()return an end},altMeterY={set=function(K)ao=K end,get=function()return ao end},fuelX={set=function(K)ap=K end,get=function()return ap end},fuelY={set=function(K)aq=K end,get=function()return aq end},shieldX={set=function(K)ar=K end,get=function()return ar end},shieldY={set=function(K)as=K end,get=function()return as end},DeadZone={set=function(K)at=K end,get=function()return at end},OrbitMapSize={set=function(K)au=K end,get=function()return au end},OrbitMapX={set=function(K)av=K end,get=function()return av end},OrbitMapY={set=function(K)aw=K end,get=function()return aw end},soundVolume={set=function(K)ax=K end,get=function()return ax end}}az=5;aA=1;aB=0.003;aC=0.003;aD=2;aE=1.5;aF=180;aG=150;aH=0.002;aI=2;aJ=0.8;aK=1;aL=3;aM=1;aN=40;aO=0.0166667;aP=0.0666667;aQ="none"aR="none"aS="none"aT={speedChangeLarge={set=function(K)az=K end,get=function()return az end},speedChangeSmall={set=function(K)aA=K end,get=function()return aA end},MouseXSensitivity={set=function(K)aB=K end,get=function()return aB end},MouseYSensitivity={set=function(K)aC=K end,get=function()return aC end},autoRollFactor={set=function(K)aD=K end,get=function()return aD end},rollSpeedFactor={set=function(K)aE=K end,get=function()return aE end},autoRollRollThreshold={set=function(K)aF=K end,get=function()return aF end},minRollVelocity={set=function(K)aG=K end,get=function()return aG end},TrajectoryAlignmentStrength={set=function(K)aH=K end,get=function()return aH end},torqueFactor={set=function(K)aI=K end,get=function()return aI end},pitchSpeedFactor={set=function(K)aJ=K end,get=function()return aJ end},yawSpeedFactor={set=function(K)aK=K end,get=function()return aK end},brakeSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeFlatFactor={set=function(K)aM=K end,get=function()return aM end},DampingMultiplier={set=function(K)aN=K end,get=function()return aN end},apTickRate={set=function(K)aO=K end,get=function()return aO end},hudTickRate={set=function(K)aP=K end,get=function()return aP end},ExtraLongitudeTags={set=function(K)aQ=K end,get=function()return aQ end},ExtraLateralTags={set=function(K)aR=K end,get=function()return aR end},ExtraVerticalTags={set=function(K)aS=K end,get=function()return aS end}}aU=j;aV=false;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=1000;b6=false;b7=false;b8=false;b9=false;ba=0;bb="Aligning"bc=0;bd=1;be="None"bf=nil;bg=0;bh=nil;bi=0.0;bj=0;bk={}bl=false;bm=0;bn=0;bo=nil;bp=0;bq=1000;br=0;bs=false;bt=0;bu=false;bv="All"bw=true;bx="Off"by=0.000;bz={}bA={VertTakeOff={set=function(K)b4=K end,get=function()return b4 end},VertTakeOffEngine={set=function(K)aV=K end,get=function()return aV end},SpaceTarget={set=function(K)bs=K end,get=function()return bs end},BrakeToggleStatus={set=function(K)aU=K end,get=function()return aU end},BrakeIsOn={set=function(K)aW=K end,get=function()return aW end},RetrogradeIsOn={set=function(K)aX=K end,get=function()return aX end},ProgradeIsOn={set=function(K)aY=K end,get=function()return aY end},Autopilot={set=function(K)aZ=K end,get=function()return aZ end},TurnBurn={set=function(K)a_=K end,get=function()return a_ end},AltitudeHold={set=function(K)b0=K end,get=function()return b0 end},BrakeLanding={set=function(K)b1=K end,get=function()return b1 end},Reentry={set=function(K)b3=K end,get=function()return b3 end},AutoTakeoff={set=function(K)b2=K end,get=function()return b2 end},HoldAltitude={set=function(K)b5=K end,get=function()return b5 end},AutopilotAccelerating={set=function(K)b6=K end,get=function()return b6 end},AutopilotBraking={set=function(K)b8=K end,get=function()return b8 end},AutopilotCruising={set=function(K)b9=K end,get=function()return b9 end},AutopilotRealigned={set=function(K)b7=K end,get=function()return b7 end},AutopilotEndSpeed={set=function(K)ba=K end,get=function()return ba end},AutopilotStatus={set=function(K)bb=K end,get=function()return bb end},AutopilotPlanetGravity={set=function(K)bc=K end,get=function()return bc end},PrevViewLock={set=function(K)bd=K end,get=function()return bd end},AutopilotTargetName={set=function(K)be=K end,get=function()return be end},AutopilotTargetCoords={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetIndex={set=function(K)bg=K end,get=function()return bg end},TotalDistanceTravelled={set=function(K)bi=K end,get=function()return bi end},TotalFlightTime={set=function(K)bj=K end,get=function()return bj end},SavedLocations={set=function(K)bk=K end,get=function()return bk end},VectorToTarget={set=function(K)bl=K end,get=function()return bl end},LocationIndex={set=function(K)bm=K end,get=function()return bm end},LastMaxBrake={set=function(K)bn=K end,get=function()return bn end},LockPitch={set=function(K)bo=K end,get=function()return bo end},LastMaxBrakeInAtmo={set=function(K)bp=K end,get=function()return bp end},AntigravTargetAltitude={set=function(K)bq=K end,get=function()return bq end},LastStartTime={set=function(K)br=K end,get=function()return br end},iphCondition={set=function(K)bv=K end,get=function()return bv end},stablized={set=function(K)bw=K end,get=function()return bw end},UseExtra={set=function(K)bx=K end,get=function()return bx end},SelectedTab={set=function(K)bB=K end,get=function()return bB end},saveRoute={set=function(K)bz=K end,get=function()return bz end}}local function bC(a,b,c,bD,bE,bF)bG=bD()bH=ab;bI=ad;bJ=ac;bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=false;bR=false;bS=0;bT=0;bU=0;bV=0;bW=0;bX=0;bY=0;bZ=false;b_=false;bZ=false;b_=false;c0="empty"c1=false;c2=0;c3=0;c4=nil;c5=0;c6=0;c7=0;c8=0;c9=0;ca=3;cb=0;cc=""cd=false;ce=false;cf=false;cg=-1;ch=bF()>0;ci=bF()cj=b.getAltitude()ck=bD()cl=b.getConstructMass()cm=false;cn=nil;co=[[rgb(]]..bE(bH+0.5)..","..bE(bJ+0.5)..","..bE(bI+0.5)..[[)]]cp=[[rgb(]]..bE(bH*0.9+0.5)..","..bE(bJ*0.9+0.5)..","..bE(bI*0.9+0.5)..[[)]]cq=""cr=a8;cs=a9;ct={}cu={}cv={}cw=false;cx=nil;cy=nil;cz=nil;cA=nil;cB=nil;cC=nil;cD=nil;cE=nil;cF=nil;cG=false;cH=false;cI=p;cJ=false;cK=0;cL=U;cM=0;cN=nil;cO={VectorToTarget=false}cP=0;cQ=false;cR=false;cS=false;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cW=vec3(b.getVelocity())cX=vec3(b.getWorldVelocity())cY=vec3(cX):len()cZ=vec3(b.getWorldVertical())c_=-cZ:dot(cX)d0=vec3(b.getConstructWorldPos())d1=false;d2=false;d3=nil;d4=true;d5=0;d6=0;d7={}d8=false;d9=50000;da=nil;db={}dc=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;dd=false;de=nil;df=false;dg=0;dh=nil;di=nil;dj={}dk=90;dl=x end;function dm(dn)a.print(bG..": "..dn)end;local function dp(d,b,c,a,dq,dr,ds,dt,du)local function dv(dw)return type(dw)=='number'end;local function dx(dw)return type(ds(dw))=='number'end;local function dy(dz)return type(dz)=='table'end;local function dA(a)return type(a)=='string'end;local function dB(dC)return dy(dC)and dv(dC.x and dC.y and dC.z)end;local function dD(dE)return dy(dE)and dv(dE.latitude and dE.longitude and dE.altitude and dE.id and dE.systemId)end;local dF=math.pi/180;local dG=180/math.pi;local dH=1e-10;local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ='::pos{'..dI..','..dI..','..dI..','..dI..','..dI..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function dK(dw)local dL=string.gsub(string.reverse(dq('%.4f',dw)),'^0*%.?','')return dL==''and'0'or string.reverse(dL)end;local function dM(dN)if dB(dN)then return dq('{x=%.3f,y=%.3f,z=%.3f}',dN.x,dN.y,dN.z)end;if dy(dN)and not getmetatable(dN)then local dO={}local dP=next(dN)if type(dP)=='nil'or dP==1 then dO=dN else for dQ,dC in pairs(dN)do local dR=dM(dC)if type(dQ)=='number'then table.insert(dO,dq('[%s]=%s',dQ,dR))else table.insert(dO,dq('%s=%s',dQ,dR))end end end;return dq('{%s}',table.concat(dO,','))end;if dA(dN)then return dq("'%s'",dN:gsub("'",[[\']]))end;return tostring(dN)end;local dS={}dS.__index=dS;dS.__tostring=function(dN,dT)local dU={}for dQ in pairs(dN)do table.insert(dU,dQ)end;table.sort(dU)local dO={}for dV,dQ in ipairs(dU)do local dR=dM(dN[dQ])if type(dQ)=='number'then table.insert(dO,dq('[%s]=%s',dQ,dR))else table.insert(dO,dq('%s=%s',dQ,dR))end end;if dT then return dq('%s%s',dT,table.concat(dO,',\n'..dT))end;return dq('{%s}',table.concat(dO,','))end;dS.__eq=function(dW,dX)return dW.systemId==dX.systemId and dW.id==dX.id and du(dW.radius,dX.radius)and du(dW.center.x,dX.center.x)and du(dW.center.y,dX.center.y)and du(dW.center.z,dX.center.z)and du(dW.GM,dX.GM)end;local function dY(dZ,d_,e0,e1,e2)assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(e0),'Argument 3 (radius) must be a number:'..type(e0))assert(dy(e1),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e1))assert(dx(e2),'Argument 5 (GM) must be a number:'..type(e2))return setmetatable({systemId=ds(dZ),id=ds(d_),radius=ds(e0),center=vec3(e1),GM=ds(e2)},dS)end;local e3={}e3.__index=e3;e3.__tostring=function(dm)return dq('::pos{%d,%d,%s,%s,%s}',dm.systemId,dm.id,dK(dm.latitude*dG),dK(dm.longitude*dG),dK(dm.altitude))end;e3.__eq=function(dW,dX)return dW.id==dX.id and dW.systemId==dX.systemId and du(dW.latitude,dX.latitude)and du(dW.altitude,dX.altitude)and(du(dW.longitude,dX.longitude)or du(dW.latitude,math.pi/2)or du(dW.latitude,-math.pi/2))end;local function e4(e5,d_,e6,e7,e8)local dZ=e5;if dA(e5)and not e7 and not e8 and not d_ and not e6 then dZ,d_,e6,e7,e8=e9(e5,dJ)assert(dZ,'Argument 1 (position string) is malformed.')else assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(e6),'Argument 3 (latitude) must be in degrees:'..type(e6))assert(dx(e7),'Argument 4 (longitude) must be in degrees:'..type(e7))assert(dx(e8),'Argument 5 (altitude) must be in meters:'..type(e8))end;dZ=ds(dZ)d_=ds(d_)e6=ds(e6)e7=ds(e7)e8=ds(e8)if d_==0 then return setmetatable({latitude=e6,longitude=e7,altitude=e8,id=d_,systemId=dZ},e3)end;return setmetatable({latitude=dF*dr(e6,-90,90),longitude=dF*(e7%360),altitude=e8,id=d_,systemId=dZ},e3)end;local ea={}ea.__index=ea;ea.__tostring=function(dN,dT)local eb=dT and dT..'  'local ec={}local dU={}for dQ in pairs(dN)do table.insert(dU,dQ)end;table.sort(dU)for dV,ed in ipairs(dU)do ee=dN[ed]local ef=dS.__tostring(ee,eb)if dT then table.insert(ec,dq('[%s]={\n%s\n%s}',ed,ef,dT))else table.insert(ec,dq('  [%s]=%s',ed,ef))end end;if dT then return dq('\n%s%s%s',dT,table.concat(ec,',\n'..dT),dT)end;return dq('{\n%s\n}',table.concat(ec,',\n'))end;local function eg(eh)local e={}local pid;for dV,dC in pairs(eh)do local d_=dC.planetarySystemId;if type(d_)~='number'then error('Invalid planetary s ID: '..tostring(d_))elseif pid and d_~=pid then error('Mistringmatch planetary s IDs: '..d_..' and '..pid)end;local ei=dC.bodyId;if type(ei)~='number'then error('Invalid body ID: '..tostring(ei))elseif e[ei]then error('Duplicate body ID: '..tostring(ei))end;setmetatable(dC.center,getmetatable(vec3.unit_x))e[ei]=setmetatable(dC,dS)pid=d_ end;return setmetatable(e,ea)end;ej={}local function ek(eh)return setmetatable({galaxyAtlas=eh or{}},ej)end;ej.__index=function(dz,K)if type(K)=='number'then local a=dz.galaxyAtlas[K]return eg(a)end;return rawget(ej,K)end;ej.__pairs=function(dN)return function(dz,dQ)local el,em=next(dz,dQ)return el,em and eg(em)end,dN.galaxyAtlas,nil end;ej.__tostring=function(dN)local en={}for dV,eo in pairs(dN or{})do local ep=eo:getPlanetarySystemId()local eq=ea.__tostring(eo,'    ')table.insert(en,dq('  [%s]={%s\n  }',ep,eq))end;return dq('{\n%s\n}\n',table.concat(en,',\n'))end;ej.BodyParameters=dY;ej.MapPosition=e4;ej.PlanetarySystem=eg;function ej.createBodyParameters(dZ,d_,er,es,et,eu,ev)assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(er),'Argument 3 (surfaceArea) must be a number:'..type(er))assert(dy(es),'Argument 4 (aPosition) must be an array or vec3:'..type(es))assert(dy(et),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(et))assert(dx(eu),'Argument 6 (altitude) must be in meters:'..type(eu))assert(dx(ev),'Argument 7 (gravityAtPosition) must be number:'..type(ev))local e0=dt(er/4/math.pi)local cb=e0+eu;local ew=vec3(es)+cb*vec3(et)local e2=ev*cb*cb;return dY(dZ,d_,e0,ew,e2)end;ej.isMapPosition=dD;function ej:getPlanetarySystem(e5)if K==nil then K=0 end;if em==nil then em=0 end;local dZ=e5;if dD(e5)then dZ=e5.systemId end;if type(dZ)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(em)~=ea then a=eg(a)end;return a end end end;function ea:sizeCalculator(ex)return 1.05*ex.radius end;function ea:castIntersections(ey,ez,eA,eB,eC,eD)local eE={}if eC then for dV,ex in pairs(eC)do table.insert(eE,ex)end else eE=dj end;if not eD then table.sort(eE,function(eF,eG)local eH=eF.center;local eI=eG.center;return(eH.x-ey.x)^2+(eH.y-ey.y)^2+(eH.z-ey.z)^2<(eI.x-ey.x)^2+(eI.y-ey.y)^2+(eI.z-ey.z)^2 end)end;local eJ=ez:normalize()for dV,ex in ipairs(eE)do local eK=ex.center-ey;local e0=self:sizeCalculator(ex)local eL=eK:dot(eJ)local eM=eL^2-(eK:len2()-e0^2)if eM>=0 then local eN=dt(eM)local eO=eL+eN;local eP=eL-eN;if eP>0 then return ex,eO,eP elseif eO>0 then return ex,eO,nil end end end;return nil,nil,nil end;function ea:closestBody(eQ)assert(type(eQ)=='table','Invalid coordinates.')local eR,ex;local eS=vec3(eQ)for dV,eT in pairs(self)do local eU=(eT.center-eS):len2()if(not ex or eU<eR)and eT.name~="Space"then ex=eT;eR=eU end end;return ex end;function ea:convertToBodyIdAndWorldCoordinates(e5)local eV=e5;if dA(e5)then eV=e4(e5)end;if eV.id==0 then return 0,vec3(eV.latitude,eV.longitude,eV.altitude)end;local eT=self:getBodyParameters(eV)if eT then return eV.id,eT:convertToWorldCoordinates(eV)end end;function ea:getBodyParameters(e5)local d_=e5;if dD(e5)then d_=e5.id end;assert(dx(d_),'Argument 1 (id) must be a number:'..type(d_))return self[d_]end;function ea:getPlanetarySystemId()local dV,dC=next(self)return dC and dC.systemId end;function dS:convertToMapPosition(e1)assert(dy(e1),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e1))local eW=vec3(e1)if self.id==0 then return setmetatable({latitude=eW.x,longitude=eW.y,altitude=eW.z,id=0,systemId=self.systemId},e3)end;local eX=eW-self.center;local cb=eX:len()local e8=cb-self.radius;local e6=0;local e7=0;if not du(cb,0)then local eY=eZ(eX.y,eX.x)e7=eY>=0 and eY or 2*math.pi+eY;e6=math.pi/2-math.acos(eX.z/cb)end;return setmetatable({latitude=e6,longitude=e7,altitude=e8,id=self.id,systemId=self.systemId},e3)end;function dS:convertToWorldCoordinates(e5)local eV=dA(e5)and e4(e5)or e5;if eV.id==0 then return vec3(eV.latitude,eV.longitude,eV.altitude)end;assert(dD(eV),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eV.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eV.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local e_=math.cos(eV.latitude)return self.center+(self.radius+eV.altitude)*vec3(e_*math.cos(eV.longitude),e_*math.sin(eV.longitude),math.sin(eV.latitude))end;function dS:getAltitude(e1)return(vec3(e1)-self.center):len()-self.radius end;function dS:getDistance(e1)return(vec3(e1)-self.center):len()end;function dS:getGravity(e1)local f0=self.center-vec3(e1)local f1=f0:len2()return self.GM/f1*f0/dt(f1)end;return setmetatable(ej,{__call=function(dV,...)return ek(...)end})end;local function f2(d,b,c,a,dt,f3)local cy={}local f4=30000000/3600;local f5=f4*f4;local f6=100;function cy.computeAccelerationTime(f7,f8,f9)local fa=f4*math.asin(f7/f4)return(f4*math.asin(f9/f4)-fa)/f8 end;function cy.computeDistanceAndTime(f7,f9,fb,fc,fd,fe)fd=fd or 0;fe=fe or 0;local ff=f7<=f9;local fg=fc*(ff and 1 or-1)/fb;local fh=-fe/fb;local fi=fg+fh;if ff and fi<=0 or not ff and fi>=0 then return-1,-1 end;local fj,fk=0,0;if fg~=0 and fd>0 then local fa=math.asin(f7/f4)local fl=math.pi*(fg/2+fh)local fm=fg*fd;local fn=f4*math.pi;local dC=function(dz)local fo=(fl*dz-fm*math.sin(math.pi*dz/2/fd)+fn*fa)/fn;local fp=math.tan(fo)return f4*fp/dt(fp*fp+1)end;local fq=ff and function(a)return a>=f9 end or function(a)return a<=f9 end;fk=2*fd;if fq(dC(fk))then local fr=0;while f3(fk-fr)>0.5 do local dz=(fk+fr)/2;if fq(dC(dz))then fk=dz else fr=dz end end end;local fs=f7;local ft=fk/f6;for fu=1,f6 do local fv=dC(fu*ft)fj=fj+(fv+fs)*ft/2;fs=fv end;if fk<2*fd then return fj,fk end;f7=fs end;local fa=f4*math.asin(f7/f4)local bG=(f4*math.asin(f9/f4)-fa)/fi;local fw=f5*math.cos(fa/f4)/fi;local cb=fw-f5*math.cos((fi*bG+fa)/f4)/fi;return cb+fj,bG+fk end;function cy.computeTravelTime(f7,f8,cb)if cb==0 then return 0 end;if f8>0 then local fa=f4*math.asin(f7/f4)local fw=f5*math.cos(fa/f4)/f8;return(f4*math.acos(f8*(fw-cb)/f5)-fa)/f8 end;if f7==0 then return-1 end;assert(f7>0,'Acceleration and initial speed are both zero.')return cb/f7 end;return cy end;local function fx(d,b,c,a,dq,dr,ds,dt,du)local vec3=require('cpml.vec3')local dp=dp(d,b,c,a,dq,dr,ds,dt,du)local function dA(a)return type(a)=='string'end;local function dy(dz)return type(dz)=='table'end;fy={}fy.__index=fy;function fy:escapeAndOrbitalSpeed(e8)assert(self.body)local cb=e8+self.body.radius;if not du(cb,0)then local fz=dt(self.body.GM/cb)return dt(2)*fz,fz end;return nil,nil end;function fy:orbitalParameters(e5,fA)assert(self.body)assert(dy(e5)or dA(e5))assert(dy(fA))local fB=(dA(e5)or dp.isMapPosition(e5))and self.body:convertToWorldCoordinates(e5)or vec3(e5)local dC=vec3(fA)local fC=fB-self.body.center;local fD=dC:len2()local fE=fC:len()local fF=self.body.GM;local fG=((fD-fF/fE)*fC-fC:dot(dC)*dC)/fF;local eH=fF/(2*fF/fE-fD)local fH=fG:len()local eJ=fG:normalize()local fI=eH*(1-fH)local fJ=eH*(1+fH)local fK=fI*eJ+self.body.center;local fL=fH<=1 and-fJ*eJ+self.body.center or nil;local fM=dt(eH*fF*(1-fH*fH))local fN=fL and 2*math.pi*dt(eH^3/fF)local fO=math.acos(fG:dot(fC)/(fH*fE))if fC:dot(dC)<0 then fO=-(fO-2*math.pi)end;local fP=math.acos((math.cos(fO)+fH)/(1+fH*math.cos(fO)))local fQ=fP;if fQ<0 then fQ=fQ+2*math.pi end;local fR=fQ-fH*math.sin(fQ)local fS=0;local fT=0;local fU=0;if fN~=nil then fS=fR/(2*math.pi/fN)fT=fN-fS;fU=fT+fN/2;if fO-math.pi>0 then fT=fS;fU=fT+fN/2 end;if fU>fN then fU=fU-fN end end;return{periapsis={position=fK,speed=fM/fI,circularOrbitSpeed=dt(fF/fI),altitude=fI-self.body.radius},apoapsis=fL and{position=fL,speed=fM/fJ,circularOrbitSpeed=dt(fF/fJ),altitude=fJ-self.body.radius},currentVelocity=dC,currentPosition=fB,eccentricity=fH,period=fN,eccentricAnomaly=fP,meanAnomaly=fR,timeToPeriapsis=fT,timeToApoapsis=fU,trueAnomaly=fO}end;local function fV(fW)local eT=dp.BodyParameters(fW.systemId,fW.id,fW.radius,fW.center,fW.GM)return setmetatable({body=eT},fy)end;return setmetatable(fy,{__call=function(dV,...)return fV(...)end})end;local function fX(d,b,c,a,dbHud_1,e,fY,fZ,bE,ds,dt,f_)local function g0(g1)local dm=g2:closestBody(g1)if(g1-dm.center):len()>dm.radius+dm.noAtmosphericDensityAltitude then dm=e[0][0]end;return dm end;local function g3()local function g4(g5,g6)return g5.name<g6.name end;d7={}for dQ,dC in pairs(e[0])do d7[#d7+1]={name=dC.name,index=dQ}end;table.sort(d7,g4)end;local function g7(g8)for dQ,dC in pairs(g8)do if dC.name and dC.name==g9.name then return dQ end end;return-1 end;local function ga()dg=bg;if bg==0 then be="None"c4=nil;g9=nil;return true end;local gb=d7[bg].index;local gc=e[0][gb]if gc.center then be=gc.name;c4=cx[0][gb]if g9~=nil then if ci==0 then if fY(gd,ge)~=1 then fZ(gd,ge)end;if fY(gf,gg)~=1 then fZ(gf,gg)end;if fY(gh,gi)~=1 then fZ(gh,gi)end;if fY(gj,gk)~=1 then fZ(gj,gk)end;if fY(gl,gm)~=1 then fZ(gl,gm)end end;if fY(gn,go)~=1 then fZ(gn,go)end;if fY(gp,gq)~=1 then fZ(gp,gq)end;if fY(gr,gs)~=1 then fZ(gr,gs)end end;g9=nil else g9=gc;for dV,dC in pairs(cx[0])do if dC.name==g9.planetname then c4=dC;be=g9.name;break end end;if fY(gn,go)~=1 then fZ(gn,go)end;if fY(gp,gq)~=1 then fZ(gp,gq)end end;if g9==nil then bf=vec3(c4.center)else bf=g9.position end;if c4.planetname~="Space"then if c4.hasAtmosphere then gt=bE(c4.radius*(S-1)+c4.noAtmosphericDensityAltitude)else gt=bE(c4.radius*(S-1)+c4.surfaceMaxAltitude)end else gt=R end;if g9~=nil and g9.planetname=="Space"then ba=0 else dV,ba=cA(c4):escapeAndOrbitalSpeed(gt)end;bc=0;b6=false;b8=false;b9=false;aZ=false;b7=false;bb="Aligning"return true end;local function gu(gv)if not aZ and not bl and not ce and not bu and not b3 and not cf then if gv==nil then bg=bg+1;if bg>#d7 then bg=0 end else bg=bg-1;if bg<0 then bg=#d7 end end;if bg==0 then ga()else local gb=d7[bg].index;local gc=e[0][gb]if gc~=nil and gc.name=="Space"or bv=="Custom Only"and gc.center or bv=="No Moons"and string.find(gc.name,"Moon")~=nil then if gv==nil then gu()else gu(1)end else ga()end end else c0="Disengage autopilot before changing Interplanetary Helper"f_("iph","AP")end end;local function gw()local gx=-1;gx=g7(e[0])if gx>-1 then table.remove(e[0],gx)end;gx=-1;gx=g7(bk)if gx~=-1 then c0=g9.name.." saved location cleared"table.remove(bk,gx)end;gu()g3()end;local function gy(gz,g1,gA,gB)if dbHud_1 or gA then local dm=g0(g1)local gC=dm.gravity;if gB then gC=c.getClosestPlanetInfluence()end;local gD={position=g1,name=gz,planetname=dm.name,gravity=gC,safe=gB}if not gA then bk[#bk+1]=gD else for dQ,dC in pairs(e[0])do if dC.name and gz==dC.name then table.remove(e[0],dQ)end end end;table.insert(e[0],gD)g3()ga()c0="Location saved as "..gz.."("..dm.name..")"else c0="Databank must be installed to save permanent locations"end end;local gE={}function gE.UpdateAtlasLocationsList()g3()end;function gE.UpdateAutopilotTarget()ga()end;function gE.adjustAutopilotTargetIndex(gv)gu(gv)end;function gE.findAtlasIndex(g8)g7(g8)end;function gE.UpdatePosition(gF)local gx=g7(bk)if gx~=-1 then if gF~=nil then bk[gx].name=gF;bg=bg-1;gu()else local gG=bk[gx]gG.gravity=c.getClosestPlanetInfluence()gG.position=d0;gG.safe=true end;c0=bk[gx].name.." position updated ("..bk[gx].planetname..")"else c0="Name Not Found"end end;function gE.AddNewLocation(gz,g1,gA,gB)gy(gz,g1,gA,gB)end;function gE.ClearCurrentPosition()gw()end;for dQ,dC in pairs(bk)do table.insert(e[0],dC)end;g3()if bg>#d7 then bg=0 end;gE.UpdateAutopilotTarget()return gE end;function gH(b,a,c,library,radar_1,radar_2,f3,gI,dt,gJ,ds,gK,f_)local gL={}local gM={}local gN={XS=13,S=27,M=55,L=110,XL=221}local gO={}local gP;local gQ;local gR;local gS;local gT;local gU={}local gV="Atmo"local gW;local function gX()local function gY(gZ,g_,h0,h1,h2,h3,h4,h5)g_,h1,h3,h5=vec3(g_),vec3(h1),vec3(h3),vec3(h5)local h6,h7,h8=gZ*gZ,h0*h0,h2*h2;local fD=h1-g_;local h9=fD:normalize()local ha=fD:len()local hb=h3-g_;local hc=(hb-hb:project_on(h9)):normalize()local hd,he=hb:dot(h9),hb:dot(hc)local hf=hd*hd+he*he;local hg=h9:cross(hc)local hh=(h6-h7+ha*ha)/(2*ha)local hi=(h6-h8+hf-2*hd*hh)/(2*he)local dE=h6-hh^2-hi^2;local hj=dt(dE)local hk=g_+h9*hh+hc*hi+hg*hj;local hl=g_+h9*hh+hc*hi-hg*hj;if f3((h5-hk):len()-h4)<f3((h5-hl):len()-h4)then return hk else return hl end end;local function hm()local function hn()local ho=b.getConstructWorldOrientationRight()local fD=b.getConstructWorldOrientationForward()local hb=b.getConstructWorldOrientationUp()local hp=library.systemResolution3(ho,fD,hb,{1,0,0})local hq=library.systemResolution3(ho,fD,hb,{0,1,0})local hr=library.systemResolution3(ho,fD,hb,{0,0,1})return function(hs)return library.systemResolution3(hp,hq,hr,hs)end end;local ht=hn()local hu=b.getConstructWorldPos()local fB=b.getElementPositionById(1)local hv={fB[1],fB[2],fB[3]}local hw=ht(hv)local hx={hu[1]-hw[1],hu[2]-hw[2],hu[3]-hw[3]}return hx end;local function hy(hz,fE,hA)local hB=hz.pts;local gx=#hB;local hC=hz.ref;if gx>3 then local hD,hE,hF,hG=hB[gx],hB[gx-1],hB[gx-2],hB[gx-3]hz.ref=hA;local fB=gY(hD[1],hD[2],hE[1],hE[2],hF[1],hF[2],hG[1],hG[2])local hh,hi,hj=fB.x,fB.y,fB.z;if hh==hh and hi==hi and hj==hj then hh=hh+hC[1]hi=hi+hC[2]hj=hj+hC[3]local hH=vec3(hh,hi,hj)if not hz.lastPos then hz.center=hH elseif(hz.lastPos-hH):len()<2 then hz.center=hH;hz.skipCalc=true end;hz.lastPos=hH end;hz.pts={}else local hI={hA[1]-hC[1],hA[2]-hC[2],hA[3]-hC[3]}hB[gx+1]={fE,hI}end end;if radar_1 or radar_2 then cE.assignRadar()end;if gU[1]then gP=#gU[1].getConstructIds()local hJ=gU[1].getData()local hK=hJ:gmatch('{"constructId[^}]*}[^}]*}')if gP>0 then local hA=hm()local hL,hM=0,0;gT,gS=0,0;for dC in hK do local d_,cb,hN=dC:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hO=gN[hN]cb=ds(cb)if gU[1].hasMatchingTransponder(d_)==1 then table.insert(gM,d_)end;local hP=gU[1].getConstructType(d_)if F then if hO>27 or hP=="static"or hP=="space"then gT=gT+1;local gz=gU[1].getConstructName(d_)local hz=db[d_]if hz==nil then hO=hO+gK;db[d_]={pts={},ref=hA,name=gz,i=0,radius=hO,skipCalc=false}hz=db[d_]end;if not hz.skipCalc then hy(hz,cb,hA)hM=hM+1 end;if hz.center then table.insert(gO,hz)end end;hL=hL+1;if dc and hL>700 or hM>70 or(not dc and hL>300 or hM>30)then coroutine.yield()hL,hM=0,0 end end end;gS=#gO;if gS>0 and cY>20 then local ex,hQ,hR,hS;local hT=0;local hU=cx:getPlanetarySystem(0)hS=cX:normalize()while hT<gS do coroutine.yield()local hV={table.unpack(gO,hT,math.min(hT+75,gS))}ex,hQ,hR=hU:castIntersections(d0,hS,nil,nil,hV,true)if ex and hR then de={ex,hQ,hR}break end;hT=hT+75 end;if not ex then de=nil end else de=nil end;gO={}gQ=hJ:find('identifiedConstructs":%[%]')else gR=hJ:find('worksInEnvironment":false')end end end;local function hW()if gU[1]then gV="Atmo"if gU[1].getData():find('worksInAtmosphere":false')then gV="Space"end end end;function gL.pickType()hW()end;function gL.assignRadar()if radar_1 and gU[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gU[1]=radar_2 end;if gU[1]==radar_2 then hW()end elseif radar_2 and gU[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gU[1]=radar_1 end;if gU[1]==radar_1 then hW()end end end;function gL.UpdateRadar()local hX=coroutine.status(gW)if hX=="suspended"then local dR,hY=coroutine.resume(gW)if hY then a.print("ERROR UPDATE RADAR: "..hY)end elseif hX=="dead"then gW=coroutine.create(gX)local dR,hY=coroutine.resume(gW)end end;function gL.GetRadarHud(hZ,h_,i0,i1)local i2=gM;local i3,dn;gM={}local dI=gS or 0;if gP>0 then if F then dn=dI.."/"..gT.." Plotted : "..gP-gT.." Ignored"else dn="Radar Contacts: "..gP end;i3=gJ(i0,i1,dn,"pbright txtbig txtmid")if#gM>0 then i3=i3 ..gJ(hZ,h_,"Friendlies In Range","pbright txtbig txtmid")for dQ,dC in pairs(gM)do h_=h_+20;i3=i3 ..gJ(hZ,h_,gU[1].getConstructName(dC),"pdim txtmid")end end;if gQ==nil and i4==nil then i5=1;cE.ToggleRadarPanel()end;if gQ~=nil and i4~=nil then cE.ToggleRadarPanel()end;if i6==nil then cE.ToggleRadarPanel()end else if gR then i3=gJ(i0,i1,gV.." Radar: Jammed","pbright txtbig txtmid")else i3=gJ(i0,i1,"Radar: No "..gV.." Contacts","pbright txtbig txtmid")end;if i6~=nil then i5=0;cE.ToggleRadarPanel()end end;return i3 end;function gL.GetClosestName(gz)if gU[1]then local d_,dV=gU[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if d_~=nil and d_~=""then gz=gz.." "..gU[1].getConstructName(d_)end end;return gz end;function gL.ToggleRadarPanel()if i6~=nil and i5==0 then gI(i6)i6=nil;if i4~=nil then gI(i4)i4=nil end else if i5==1 then gI(i6)i6=nil;_autoconf.displayCategoryPanel(gU,1,"Periscope","periscope")i4=_autoconf.panels[_autoconf.panels_size]end;if i6==nil then _autoconf.displayCategoryPanel(gU,1,"Radar","radar")i6=_autoconf.panels[_autoconf.panels_size]end;i5=0 end end;function gL.ContactTick()if not i7 then i7=0 end;if bG>i7+10 then c0="Radar Contact"f_("rdrCon","RC")i7=bG end;c.stopTimer("contact")end;function gL.onEnter(d_)if radar_1 and not ch and not d8 then c.setTimer("contact",0.1)end end;function gL.onLeave(d_)if radar_1 and F then if#db>650 then d_=tostring(d_)db[d_]=nil end end end;gU[1]=nil;if radar_1 then gU[1]=radar_1;hW()end;gW=coroutine.create(gX)return gL end;local function i8(d,b,c,a,e,radar_1,radar_2,antigrav,hover,i9,warpdrive,f3,bE,dq,ia,bF,ib,ic,eZ,bD,dr,id,fZ,fY,gI,ie,dt,ig,gJ,f_,ih,ii,ij,ik)local il=9.80665;local im={}local io={}local ip={}local iq={}local ir=nil;local is=nil;local it=nil;local iu=false;local iv="none"local iw=""local ix=55;local iy=0;local iz=0;local iA=vec3({13771471,7435803,-128971})local iB=18000000;local iC=500000;local iD,iE=math.huge;local iF;local function iG(iH)iD=vec3(iH):dist(iA)if iD<iB then return true,f3(iD-iB)end;iE=vec3(iH):dist(vec3(iI.center))if iE<iC then iF=true else iF=false end;if f3(iE-iC)<f3(iD-iB)then return iF,f3(iE-iC)else return iF,f3(iD-iB)end end;local function iJ(dC)if cr==1920 then return dC else return ig(cr*dC/1920,0)end end;local function iK(dC)if cs==1080 then return dC else return ig(cs*dC/1080,0)end end;local function iL()return ie()==0 and g~="keyboard"and ic()==0 end;local function iM()local iN="TRAVEL"if not d4 then iN="CRUISE"end;if aZ then iN="AUTOPILOT"end;return iN end;local i3=""local iO=""local iP=""local iQ=1;local iR=2;local iS=3;local iT=4;local iU=5;local iV=6;local iW=""local iX=0;local iY=bE(1/aO)*2*aP;local iZ={}local i_={}local j0={}local j1={}local j2={}local j3={}local function j4(hh,j5,j6,j7,j8,j9)local ja=jb;local jc=jb+5;if not C then jc=jc+5 end;if ic()==1 and not l then ja=ja-50;jc=jc-50 end;if j6=="ATMO"then iW="atmofueltank"elseif j6=="SPACE"then iW="spacefueltank"else iW="rocketfueltank"end;iX=_G[iW.."_size"]if#j7>0 then for K=1,#j7 do local gz=string.sub(j7[K][iR],1,12)local jd=0;for je=1,iX do if j7[K][iR]==ia(c[iW.."_"..je].getData()).name then jd=je;break end end;local jf=bD()if j8[K]==nil or j9[K]==nil or jf-j7[K][iV]>iY then local jg;local jh=0;if jd~=0 then j9[K]=ia(c[iW.."_"..jd].getData()).percentage;j8[K]=ia(c[iW.."_"..jd].getData()).timeLeft;if j8[K]=="n/a"then j8[K]=0 end else jh=ib(j7[K][iQ])-j7[K][iT]j9[K]=bE(0.5+jh*100/j7[K][iS])jg=j7[K][iU]if jg<=jh then j8[K]=0 else j8[K]=bE(0.5+jh/((jg-jh)/(jf-j7[K][iV])))end;j7[K][iU]=jh;j7[K][iV]=jf end end;if gz==j5 then gz=dq("%s %d",j6,K)end;if jd==0 then gz=gz.." *"end;local ji;if j8[K]==0 then ji=""else ji=ik(j8[K])end;if j9[K]~=nil then local jj=bE(j9[K]*2.55)local jk=dq("rgb(%d,%d,%d)",255-jj,jj,0)local jl=""if ji~=""and j8[K]<120 or j9[K]<5 then jl="red "end;local jm=dq("rgb(%d,%d,%d)",dr(bE((255-jj)/2.55),50,100),dr(bE(jj/2.55),0,50),50)local jn="rgb(196,0,255)"if j6=="ATMO"then jn="rgb(0,188,255)"elseif j6=="SPACE"then jn="rgb(239,255,0)"end;local jo=false;if jp~=jn then jo=true end;jp=jn;if C then if jo then ja=ja-5;jc=jc-5 end;iO=iO..dq([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jm,jn,hh,jc,jk,bE(j9[K]*1.7+0.5)-2,hh+1,jc+1,hh+5,jc+14,gz,j9[K],ji)ja=ja-22;jc=jc-22 else iO=iO..gJ(hh,ja,gz,jl.."pdim txtfuel")iO=iO..gJ(hh,jc,dq("%d%% %s",j9[K],ji),"pdim txtfuel","fill:"..jk)ja=ja+30;jc=jc+30 end end end end;jb=ja end;local function jq(jr,e8)if al==0 and am==0 then return end;if e8<200000 and not ch or e8 and ch then local js=0;if f3(c_)>1 then js=45*math.log(f3(c_),10)if c_<0 then js=-js end end;jr[#jr+1]=dq([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],al,am,bE(c_),bE(js))end;return jr end;local function jt(ju)local gv=-cZ;ju=ju-ju:project_on(gv)local jv=vec3(0,0,1)jv=jv-jv:project_on(gv)local jw=jv:cross(gv)local js=jv:angle_between(ju)*constants.rad2deg;if ju:dot(jw)<0 then js=360-js end;return js end;local function jx(jr,ah,ai,jy,jz,dc)if aa==0 then return end;local jA=aa;local jB=20;local jC=bE(jy)if dc then for K=-45,45,5 do local jD=K;jr[#jr+1]=dq([[<g transform="rotate(%f,%d,%d)">]],jD,ah,ai)jE=5;if K%15==0 then jE=15 elseif K%10==0 then jE=10 end;jr[#jr+1]=dq([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ah,ai+jA+jB-jE,ah,ai+jA+jB)end;jr[#jr+1]=gJ(ah,ai+jA+jB-35,jz,"pdim txt txtmid")jr[#jr+1]=gJ(ah,ai+jA+jB-25,jC.." deg","pdim txt txtmid")jr[#jr+1]=dq([[<g transform="rotate(%f,%d,%d)">]],-jy,ah,ai)jr[#jr+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ah-5,ai+jA+jB-20,ah+5,ai+jA+jB-20,ah,ai+jA+jB-15)jr[#jr+1]="</g>"end;jr[#jr+1]=[[<g style="clip-path: url(#headingClip);">]]local jF=jC;if dc then jF=jt(cU)end;local jG=20;local jH=bE(jF)local jI=0;local jJ=ai+jA+jB+20;local jK=ah;if jz~="YAW"then jJ=iK(130)jK=iJ(960)end;local jL=[[<path class="txttick line" d="]]local jM=bE(jH-(jG+10)-jH%5+0.5)for K=jM+70,jM,-5 do local hh=jK-(-K*5+jF*5)if K%10==0 then jI=10;local dI=K;if dI==360 then dI=0 elseif dI>360 then dI=dI-360 elseif dI<0 then dI=dI+360 end;jr[#jr+1]=gJ(hh,jJ+15,dI,"txtmid bright")elseif K%5==0 then jI=5 end;if jI==10 then jL=dq([[%s M %f %f v %d]],jL,hh,jJ-5,jI)else jL=dq([[%s M %f %f v %d]],jL,hh,jJ-2.5,jI)end end;jr[#jr+1]=jL..[["/>]]jr[#jr+1]=dq([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jK-5,jJ-20,jK+5,jJ-20,jK,jJ-10)if I then if dc then jz="HDG"end;jr[#jr+1]=gJ(iJ(960),iK(100),jH.."Â°","dim txt txtmid size14","")jr[#jr+1]=gJ(iJ(960),iK(85),jz,"dim txt txtmid size20","")end;jr[#jr+1]=[[</g>]]end;local function jN(jr,jO,jy,ah,ai,dc,jP,fv)if aa==0 then return end;local jA=aa;local jQ=bE(jA*3/5)if jA>0 then local jR=bE(jO)local jE=0;local jL=dq([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jy,ah,ai)if not ch then jL=dq([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ah,ai)end;jr[#jr+1]=dq([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jA-1,ah,ai)jr[#jr+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bE(jR-30-jR%5+0.5),bE(jR+30+jR%5+0.5),5 do if K%10==0 then jE=30 elseif K%5==0 then jE=20 end;local hi=ai+-K*5+jO*5;if jE==30 then jL=dq([[%s M %d %f h %d]],jL,ah-jQ-jE,hi,jE)if ch then jr[#jr+1]=dq([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jy,ah,ai,ah-jQ+10,hi+4,K)jr[#jr+1]=dq([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jy,ah,ai,ah+jQ-10,hi+4,K)if K==0 or K==180 or K==-180 then jr[#jr+1]=dq([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jy,ah,ai,ah-jQ+20,hi,jQ*2-40)end else jr[#jr+1]=gJ(ah-jQ+10,hi,K,"pdim txt txtmid")jr[#jr+1]=gJ(ah+jQ-10,hi,K,"pdim txt txtmid")end;jL=dq([[%s M %d %f h %d]],jL,ah+jQ,hi,jE)else jL=dq([[%s M %d %f h %d]],jL,ah-jQ-jE,hi,jE)jL=dq([[%s M %d %f h %d]],jL,ah+jQ,hi,jE)end end;jr[#jr+1]=jL..[["/>]]local jS="PITCH"if not dc then jS="REL PITCH"end;if jO>90 and not ch then jO=90-(jO-90)elseif jO<-90 and not ch then jO=-90-(jO+90)end;if jA>200 then if ch then if fv>ix then jr[#jr+1]=gJ(ah,ai-15,"Yaw","pdim txt txtmid")jr[#jr+1]=gJ(ah,ai+20,jP,"pdim txt txtmid")end;jr[#jr+1]=dq([[<g transform="rotate(%f,%d,%d)">]],-jy,ah,ai)else jr[#jr+1]=dq([[<g transform="rotate(0,%d,%d)">]],ah,ai)end;jr[#jr+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah-jQ+25,ai-5,ah-jQ+20,ai,ah-jQ+25,ai+5,ah-jQ+50,ai+4,jR)jr[#jr+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah+jQ-25,ai-5,ah+jQ-20,ai,ah+jQ-25,ai+5,ah+jQ-30,ai+4,jR)jr[#jr+1]="</g>"end;local jT=bE(jA/3)jr[#jr+1]=dq([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ah-jT,ai,jA-jT)if not ch and dc then jr[#jr+1]=dq([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jy,ah,ai,ah-jQ+10,ai,jQ*2-20)end;jr[#jr+1]="</g>"if jA<200 then if ch and fv>ix then jr[#jr+1]=gJ(ah,ai-jA,jS,"pdim txt txtmid")jr[#jr+1]=gJ(ah,ai-jA+10,jR,"pdim txt txtmid")jr[#jr+1]=gJ(ah,ai-15,"Yaw","pdim txt txtmid")jr[#jr+1]=gJ(ah,ai+20,jP,"pdim txt txtmid")else jr[#jr+1]=gJ(ah,ai-jA,jS,"pdim txt txtmid")jr[#jr+1]=gJ(ah,ai-jA+15,jR,"pdim txt txtmid")end end end end;local function jU(jr,e8,dc)local jV=an;local jW=ao;if jV==0 and jW==0 then return end;local jX=78;local jY=19;local jZ=cg;if cg~=-1 then jr[#jr+1]=gJ(jV+jX,jW+jY+20,dq("AGL: %.1fm",cg),"pdim altsm txtend")end;if dc and(e8<200000 and not ch or e8 and ch)then table.insert(jr,dq([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],jV-1,jW-4,jX+2,jY+6,jV+1,jW-1,jX-4,jY))local gx=0;local j_=1;local k0=0;local k1=e8<0;local k2=e8<iI.surfaceMaxAltitude;local k3=9;if k1 then k3=0 end;local e8=f3(e8)while gx<6 do local k4=11;local k5=16;local k6=9;local k7=14;local jl="altsm"if gx>2 then k5=k5+3;k4=k4+2;k7=k7+2;k6=k6-6;jl="altbig"end;if k1 then jl=jl.." red"elseif k2 then jl=jl.." orange"end;local k8=e8/j_%10;local k9=bE(k8)local ka=bE((k9+1)%10)local kb=k0;if gx==0 then kb=k8-k9;if k1 then kb=1-kb end end;if k1 and(gx==0 or k0~=0)then local gA=ka;ka=k9;k9=gA end;local kc=k5*(kb-1)local kd=kc+k5;local hh=jV+k6+(6-gx)*k4;local hi=jW+k7;jr[#jr+1]=gJ(hh,hi+kc,ka,jl)jr[#jr+1]=gJ(hh,hi+kd,k9,jl)gx=gx+1;j_=j_*10;if k9==k3 then k0=kb else k0=0 end end;table.insert(jr,[[</g></g>]])end end;local function ke(fA)local kf=-math.deg(eZ(fA.y,fA.z))+180;kf=kf-90;if kf<0 then kf=360+kf end;if kf>180 then kf=-180+kf-180 end;return-kf end;local function kg(fA)local jF=math.deg(eZ(fA.y,fA.x))-90;if jF<-180 then jF=360+jF end;return jF end;local function kh(jr,fA,fv,ah,ai)if fv>5 and not ch or fv>ix then local jA=aa;local ki=20;local kj=20;local kk=ke(fA)local kl=kg(fA)local km=14;local kn=km/2;local ko=-kl/kj*jA;local kp=kk/ki*jA;local hh=ah+ko;local hi=ai+kp;local cb=dt(ko^2+kp^2)local kq=[[<circle
                            cx="]]..hh..[["
                            cy="]]..hi..[["
                            r="]]..kn/km..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hh..[["
                            cy="]]..hi..[["
                            r="]]..kn..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hh-km..[[,]]..hi..[[ h ]]..kn..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hh+kn..[[,]]..hi..[[ h ]]..kn..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hh..[[,]]..hi-km..[[ v ]]..kn..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<jA then jr[#jr+1]=kq else local js=eZ(kp,ko)local kr=4;local ks=ah+jA*math.cos(js)local kt=ai+jA*math.sin(js)jr[#jr+1]=dq('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',js*180/math.pi,ks,kt,ks-kr,kt-kr/2,kr*2,kr,ks+kr,kt-kr,kr,kr,-kr,kr)end;if not ch then local ku=vec3(fA)kk=ke(-ku)kl=kg(-ku)ko=-kl/kj*jA;kp=kk/ki*jA;hh=ah+ko;hi=ai+kp;cb=dt(ko^2+kp^2)if cb<jA then local kv=[[<circle
                                    cx="]]..hh..[["
                                    cy="]]..hi..[["
                                    r="]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hh..[[,]]..hi-km..[[ v ]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hh..[[,]]..hi..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hh..[[,]]..hi..[[)" />
                                <path
                                    d="M ]]..hh-kn..[[,]]..hi..[[ h ]]..km..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hh..[[,]]..hi..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hh..[[,]]..hi..[[)"/>]]jr[#jr+1]=kv end end end end;local function kw(jr,iN,kx,ky)if aj==0 and ak==0 then return end;kx=bE(kx+0.5)local ja=ak+10;local jc=ak+20;if ic()==1 and not l then ja=55;jc=65 end;local kz="CRUISE"local c="km/h"local dR=ky;if iN=="TRAVEL"or iN=="AUTOPILOT"then kz="THROT"c="%"dR=kx;local kA="dim"if kx<0 then kA="red"end;jr[#jr+1]=dq([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kA,aj-7,ak-50,aj,ak-50,aj,ak+50,aj-7,ak+50,1-f3(kx),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)end;jr[#jr+1]=gJ(aj+10,ja,kz,"pbright txtstart")jr[#jr+1]=gJ(aj+10,jc,dq("%.0f %s",dR,c),"pbright txtstart")if ch and u and d4 and bM then kx=bE(bN*100+0.5)local kA="red"if kx<0 then kA="red"end;jr[#jr+1]=dq([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kA,1-f3(kx),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)jr[#jr+1]=gJ(aj+10,ja+40,"LIMIT","pbright txtstart")jr[#jr+1]=gJ(aj+10,jc+40,kx.."%","pbright txtstart")end;if ch and u or b3 then jr[#jr+1]=gJ(aj+10,ja-40,"LIMIT: "..cL.." km/h","dim txtstart")elseif not ch and aZ then jr[#jr+1]=gJ(aj+10,ja-40,"LIMIT: "..bE(_*3.6+0.5).." km/h","dim txtstart")end end;local function kB(jr,kC)if aj==0 and ak==0 then return end;local kD=ak-10;local kE=aj+10;jr[#jr+1]=gJ(0,0,"","pdim txt txtend")if ic()==1 and not l then kD=75 end;jr[#jr+1]=gJ(kE,kD,bE(kC).." km/h","pbright txtbig txtstart")end;local function kF(jr)jr[#jr+1]=gJ(iJ(1900),iK(1070),dq("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jr[#jr+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jr[#jr+1]=gJ(iJ(960),iK(550),"Warning: Invalid Control Scheme Detected","warnings")jr[#jr+1]=gJ(iJ(960),iK(600),"Keyboard Scheme must be selected","warnings")jr[#jr+1]=gJ(iJ(960),iK(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kG=iJ(960)local kH=iK(860)local kI=iK(880)local kJ=iK(900)local kK=iK(960)local kL=iK(200)local kM=iK(250)local kN=iK(960)if ic()==1 and not l then kH=iK(135)kI=iK(155)kJ=iK(175)kL=iK(115)kM=iK(95)end;local kO="#222222"local kP="white"local kQ="dimmer"local kR="pbright"local kS="#110000"local kT=kO;local kU=kQ;if aW then jr[#jr+1]=gJ(kG,kH,"Brake Engaged","warnings")kS="#440000"kT=kP;kU=kR elseif bL>0 then jr[#jr+1]=gJ(kG,kH,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local kV="#110000"local kW=kO;local kX=kQ;if ch and cJ and cg==-1 then if not aZ and not bl and not b1 and not d2 and not b4 and not b2 then jr[#jr+1]=gJ(kG,kL+50,"** STALL WARNING **","warnings")kV="#ff0000"kW=kP;kX=kR;f_("stall","SW",2)end end;if da then jr[#jr+1]=gJ(kG,kL+90,"Flight Assist in Progress","warnings")end;if cn then jr[#jr+1]=gJ(kG,kN,"Gyro Enabled","warnings")end;local kY="#111100"local kZ=kO;local k_=kQ;if bh then kY="#775500"kZ=kP;k_=kR;if bR then jr[#jr+1]=gJ(kG,kI,"Gear Extended","warn")else jr[#jr+1]=gJ(kG,kI,"Landed (G: Takeoff)","warnings")end;local l0=ij(d:getTargetGroundAltitude())jr[#jr+1]=gJ(kG,kJ,"Hover Height: "..l0,"warn")end;local l1="#000011"local l2=kO;local l3=kQ;if c1 then l1="#0000DD"l2=kP;l3=kR;jr[#jr+1]=gJ(kG,kK+20,"ROCKET BOOST ENABLED","warn")end;local l4="#001100"local l5=kO;local l6=kQ;if antigrav and not q and d2 and bq~=nil then l4="#00DD00"l5=kP;l6=kR;if f3(cj-antigrav.getBaseAltitude())<501 then jr[#jr+1]=gJ(kG,kL+15,dq("Target Altitude: %d Singularity Altitude: %d",bE(bq),bE(antigrav.getBaseAltitude())),"warn")else jr[#jr+1]=gJ(kG,kL+15,dq("Target Altitude: %d Singluarity Altitude: %d",bE(bq),bE(antigrav.getBaseAltitude())),"warnings")end elseif aZ and be~="None"then jr[#jr+1]=gJ(kG,kL+20,"Autopilot "..bb,"warn")elseif bo~=nil then jr[#jr+1]=gJ(kG,kL+20,dq("LockedPitch: %d",bE(bo)),"warn")elseif bZ then jr[#jr+1]=gJ(kG,kL+20,"Follow Mode Engaged","warn")elseif b3 or cf then jr[#jr+1]=gJ(kG,kL+20,"Re-entry in Progress","warn")end;if b0 or b4 then local l0=ij(b5,2)if b4 then if d2 then l0=ij(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jr[#jr+1]=gJ(kG,kL,"VTO to "..l0,"warn")elseif b2 and not bu then if ce then jr[#jr+1]=gJ(kG,kL,"Takeoff to "..be,"warn")else jr[#jr+1]=gJ(kG,kL,"Takeoff to "..l0,"warn")end;if aW and not b4 then jr[#jr+1]=gJ(kG,kL+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jr[#jr+1]=gJ(kG,kL,"Altitude Hold: "..l0,"warn")end end;if b4 and(antigrav~=nil and antigrav)then if ci>0.1 then jr[#jr+1]=gJ(kG,kL+20,"Beginning ascent","warn")elseif ci<0.09 and ci>0.05 then jr[#jr+1]=gJ(kG,kL+20,"Aligning trajectory","warn")elseif ci<0.05 then jr[#jr+1]=gJ(kG,kL+20,"Leaving atmosphere","warn")end end;if bu then if cN~=nil then jr[#jr+1]=gJ(kG,kL,cN,"warn")end end;if b1 then if l7 then jr[#jr+1]=gJ(kG,kL,"Brake-Landing","warnings")else jr[#jr+1]=gJ(kG,kL,"Coast-Landing","warnings")end end;if aY then jr[#jr+1]=gJ(kG,kL,"Prograde Alignment","crit")end;if aX then jr[#jr+1]=gJ(kG,kL,"Retrograde Alignment","crit")end;local l8="#110000"local l9=kO;local la=kQ;if dd then l8="#FF0000"l9=kP;la=kR;local type;if string.find(dd,"COLLISION")then type="warnings"else type="crit"end;jr[#jr+1]=gJ(kG,kM+20,dd,type)elseif ci==0 then local lb,lc=cD.checkLOS(cX:normalize())if lc~=nil then la=kR;l8="#FF0000"l9=kP;local l0=ij(lc)local ld=cy.computeTravelTime(cY,0,lc)local le="Collision"if lb.noAtmosphericDensityAltitude>0 then le="Atmosphere"end;jr[#jr+1]=gJ(kG,kM+20,lb.name.." "..le.." "..ik(ld).." In "..l0,"crit")end end;if bl and not bu then jr[#jr+1]=gJ(kG,kL+35,lf,"warn")end;local lg="#111100"local lh=kO;local li=kQ;if dh and#dh>1 then lg="#DDDD00"lh=kP;li=kR end;local lj=iJ;local lk=iK;local kQ="topButton"local ll="topButtonActive"local lm=kQ;if aZ or bl or ce or bu then lm=ll end;local ln=kQ;if aY then ln=ll end;local lo=kQ;if b1 or bh then lo=ll end;local lp=kQ;if b0 or bl then lp=ll end;local lq=kQ;if aX then lq=ll end;local lr=kQ;if bu or cQ and aZ then lr=ll end;if x and I then local ls=lk(30)jr[#jr+1]=dq([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lm,lj(960),lk(54),lk(-53),lj(-120),lj(25),lk(50))jr[#jr+1]=gJ(lj(910),ls,"AUTOPILOT")jr[#jr+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ln,lj(865),lk(51),lj(-25),lk(-50),lj(-110),lj(25),lk(46))jr[#jr+1]=gJ(lj(800),ls,"PROGRADE")jr[#jr+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lo,lj(755),lk(47),lj(-25),lk(-46),lj(-98),lj(44),lk(44))jr[#jr+1]=gJ(lj(700),ls,"LAND")jr[#jr+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lp,lj(960),lk(54),lk(-53),lj(120),lj(-25),lk(50))jr[#jr+1]=gJ(lj(1010),ls,"ALT HOLD")jr[#jr+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lq,lj(1055),lk(51),lj(25),lk(-50),lj(110),lj(-25),lk(46))jr[#jr+1]=gJ(lj(1122),ls,"RETROGRADE")jr[#jr+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lr,lj(1165),lk(47),lj(25),lk(-46),lj(98),lj(-44),lk(44))jr[#jr+1]=gJ(lj(1220),ls,"ORBIT")jr[#jr+1]=[[
                                    </g>
                                </g>]]jr[#jr+1]="</g>"end;return jr end;local function lt(fv)return bE(ig(fv*3.6,0)+0.5).." km/h"end;local function lu(gx)local gz=be;if gx~=nil and type(gx)=="number"then if gx==0 then return"None"end;gz=d7[gx].name end;if gz==nil then gz=g9.name end;if gz==nil then gz="None"end;return gz end;local function lv(jr)local lw=cD.routeWP(true)if not lw or#lw==0 then return end;local hh=iJ(750)local hi=iK(360)if aZ or bl then jr[#jr+1]=gJ(hh,hi,"REMAINING ROUTE","pdim txtstart size20")else jr[#jr+1]=gJ(hh,hi,"LOADED ROUTE","pdim txtstart size20")end;for dQ,K in pairs(lw)do hi=hi+20;jr[#jr+1]=gJ(hh,hi,dQ..". "..lu(lw[dQ]),"pdim txtstart size20")end end;local function lx(jr)local hh=av+10;local hi=aw+20;local ly={}local lz={"Alt-4: AutoTakeoff to Target"}local lA={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lB={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lC={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(ly,"--------------DYNAMIC-----------------")if ch then if cg~=-1 then ih(ly,lz)if c4 and iI and c4.name==iI.name then table.insert(ly,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aV then if antigrav then if d2 then table.insert(ly,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(ly,"Turn on AGG to takeoff to AGG Height")end end;if aV then table.insert(ly,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(ly,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(ly,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bh then table.insert(ly,"G: Takeoff to hover height, raise gear")else table.insert(ly,"G: Lowergear and Land")end else ih(ly,lA)table.insert(ly,"G: Begin BrakeLanding or Land")end;if b4 then table.insert(ly,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ih(ly,lB)if i9 then table.insert(ly,"Alt-Shift-6: Vent shields")table.insert(ly,"Alt-Shift-7: Toggle shied off/on")end end;if g9~=nil then table.insert(ly,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(ly,"Alt-9: Activate Gyroscope")end;if aR~="none"or aQ~="none"or aS~="none"then table.insert(ly,"Alt-Shift-9: Cycles engines with Extra tags")end;if b0 then table.insert(ly,"Alt-Spacebar/C will raise/lower target height")table.insert(ly,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not ch then table.insert(ly,"LALT+Mousewheel will lower/raise speed limit")end;ih(ly,lC)for K=1,#ly do hi=hi+12;jr[#jr+1]=gJ(hh,hi,ly[K],"pdim txtbig txtstart")end end;local function lD(jr)local lE=av;local lF=aw;local lG=au;local lH=4;local lI=15;local hh=0;local hi=0;local lJ,lK,lL,lM;local lN;local function lO(type)local lP,bG,fv,lQ,jl,lR;if type=="Periapsis"then lP=lN.periapsis.altitude;bG=lN.timeToPeriapsis;fv=lN.periapsis.speed;jl="txtend"lQ=12;lR=math.min(hh,lE+lG-iI.radius/lL-lH*2)else lP=lN.apoapsis.altitude;bG=lN.timeToApoapsis;fv=lN.apoapsis.speed;lQ=-12;jl="txtstart"lR=hh end;if cY<1 then bG=0 end;jr[#jr+1]=dq([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lR+lQ,hi-5,hh,hi-5)jr[#jr+1]=dq([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lR-lQ*4,hi+2,hh,hi+2)jr[#jr+1]=gJ(lR,hi,type,jl)hh=lR-lQ*2;hi=hi+lI;local l0=ij(lP)jr[#jr+1]=gJ(hh,hi,l0,jl)hi=hi+lI;jr[#jr+1]=gJ(hh,hi,ik(bG),jl)hi=hi+lI;jr[#jr+1]=gJ(hh,hi,lt(fv),jl)end;local lS=lG*1.5;if bB=="INFO"then lS=25*7 end;if bB~="HIDE"then jr[#jr+1]=[[<g class="pbright txtorb txtmid">]]jr[#jr+1]=dq('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lG*2,lS,lE,lF)jr[#jr+1]=dq([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lG*2,lS,lE,lF)end;local lT=lG*1.5;local lU=lG*2;local lV=lT/2;local lW=lG;local lX=lE+lW;local lY=lF+lV;local lZ=lE+lU;local l_=lF+lT;if bB=="ORBIT"then lF=lF+lH;lJ=lG/2;lM=0;lN={}lN.periapsis={}lN.apoapsis={}if fz~=nil then if fz.periapsis~=nil then lN.periapsis.altitude=fz.periapsis.altitude;lN.periapsis.speed=fz.periapsis.speed end;if fz.apoapsis~=nil then lN.apoapsis.altitude=fz.apoapsis.altitude;lN.apoapsis.speed=fz.apoapsis.speed end;lN.period=fz.period;lN.eccentricity=fz.eccentricity;lN.timeToApoapsis=fz.timeToApoapsis;lN.timeToPeriapsis=fz.timeToPeriapsis;lN.eccentricAnomaly=fz.eccentricAnomaly;lN.trueAnomaly=fz.trueAnomaly end;if lN.periapsis==nil then lN.periapsis={}lN.periapsis.altitude=-iI.radius;lN.periapsis.speed=_ end;if lN.eccentricity==nil then lN.eccentricity=1 end;if lN.apoapsis==nil then lN.apoapsis={}lN.apoapsis.altitude=cj;lN.apoapsis.speed=0 end;if cY<1 then lN.apoapsis.altitude=cj;lN.apoapsis.speed=0 end;if lN.apoapsis.altitude then lL=(lN.apoapsis.altitude+lN.periapsis.altitude+iI.radius*2)/(lJ*2)lK=(iI.radius+lN.apoapsis.altitude)/lL*(1-lN.eccentricity)lM=lJ-lN.periapsis.altitude/lL-iI.radius/lL;local m0=math.pi;if lN.period~=nil and lN.period>0 and lN.timeToApoapsis~=nil then m0=lN.eccentricAnomaly;if lN.timeToPeriapsis<lN.timeToApoapsis then m0=2*math.pi-m0 end end;if cY<1 or m0~=m0 then m0=math.pi end;local m1=-lJ*math.cos(m0)+lE+lW+lH;local m2=lK*math.sin(m0)+lF+lV+lH;local m3=""jr[#jr+1]='<g clip-path="url(#orbitRect)">'jr[#jr+1]=dq([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],m3,lE+lG+lH,lF+lG*1.5/2+lH,lJ,lK)if lK<1 then jr[#jr+1]=dq([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lE+lG+lH-lM,lF+lG*1.5/2+lH,m1,m2)end;jr[#jr+1]=dq('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lE+lG+lH-lM,lF+lG*1.5/2+lH,(iI.radius+iI.noAtmosphericDensityAltitude)/lL)jr[#jr+1]=dq('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lE+lG+lH-lM,lF+lG*1.5/2+lH,(iI.radius+iI.noAtmosphericDensityAltitude)/lL)jr[#jr+1]=dq([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lE+lG+lH,lF+lG*1.5/2+lH,lJ,lK)jr[#jr+1]=dq('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lE+lG+lH-lM,lF+lG*1.5/2+lH,iI.radius/lL)jr[#jr+1]='</g>'local m4=math.floor(iI.radius/lL+0.5)hh=lE+lG+lH*4+lJ;hi=lF+lG*1.5/2+5+lH;if lN.apoapsis~=nil and lN.apoapsis.speed<_ then lO("Apoapsis")end;hi=lF+lG*1.5/2+5+lH;hh=lE+lG-lH*2-lJ;if lN.periapsis~=nil and lN.periapsis.speed<_ and lN.periapsis.altitude>0 then lO("Periapsis")end;jr[#jr+1]=gJ(lE+lG+lH,lF+20+lH,iI.name,"txtorbbig")jr[#jr+1]=dq('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m1,m2)jr[#jr+1]=[[</g>]]return jr else jr[#jr+1]='<g clip-path="url(#orbitRect)">'local m5=""local m6=1.2*(m7-m8)/(lG*2)local m9=1.4*(ma-mb)/(lG*1.5)for dQ,dC in pairs(e[0])do if dC.center then local hh=lE+lG+dC.center.x/m6;local hi=lF+lG*1.5/2+dC.center.y/m9;m5=m5 ..'<circle cx="'..hh..'" cy="'..hi..'" r="'..dC.radius/m6*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dC.name,"Moon")and not string.match(dC.name,"Sanctuary")and not string.match(dC.name,"Space")then m5=m5 .."<text x='"..hh.."' y='"..hi+dC.radius/m6*30+20 .."' font-size='12' fill="..co.." text-anchor='middle' font-family='Montserrat'>"..dC.name.."</text>"end end end;local fB=vec3(b.getConstructWorldPos())local hh=lE+lG+fB.x/m6;local hi=lF+lG*1.5/2+fB.y/m9;m5=m5 ..'<circle cx="'..hh..'" cy="'..hi..'" r="2" stroke="white" stroke-width="1" fill="red"/>'m5=m5 .."<text x='"..hh.."' y='"..hi-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"ir=m6;is=m9;local mc=fB+cX*1000000;local md=lE+lG+mc.x/m6;local jc=lF+lG*1.5/2+mc.y/m9;m5=m5 ..'<line x1="'..hh..'" y1="'..hi..'" x2="'..md..'" y2="'..jc..'" stroke="purple" stroke-width="1"/>'jr[#jr+1]=m5;jr[#jr+1]='</g>'end elseif bB=="INFO"then jr=cB.DrawOdometer(jr,c5,bi,c6)elseif bB=="HELP"then jr=lx(jr)elseif bB=="SCOPE"then jr[#jr+1]='<g clip-path="url(#orbitRect)">'local me=dk;if ci>0 then table.sort(dj,function(eF,eG)local eH,eI=eF.center,eG.center;return(eH.x-d0.x)^2+(eH.y-d0.y)^2+(eH.z-d0.z)^2<(eI.x-d0.x)^2+(eI.y-d0.y)^2+(eI.z-d0.z)^2 end)end;local gR={}local mf={}local mg=120;local mh=nil;local mi=nil;for K,dC in ipairs(dj)do local gQ=dC.center-d0;local mj=gQ:len()local mk=gQ:normalize()local ml=gQ:cross(cU):normalize()local mm=math.acos(ml:dot(cV))if mm~=mm then mm=0 end;if ml:cross(cV):dot(cU)<0 then mm=-mm end;local mn=gQ:project_on_plane(cU):len()local mo=math.sin(mm)*math.asin(mn/mj)*constants.rad2deg;local mp=math.cos(mm)*math.asin(mn/mj)*constants.rad2deg;if mk:dot(cU)<0 then mp=90*math.cos(mm)+90*math.cos(mm)-mp;mo=90*math.sin(mm)+90*math.sin(mm)-mo end;local hh=lX+mo/me*lT;local hi=lY+mp/me*lT;local mq=(hh-lX)*(hh-lX)+(hi-lY)*(hi-lY)local mr=math.asin((dC.radius+dC.surfaceMaxAltitude)/mj)*constants.rad2deg;if mr~=mr then mr=me end;local hN=mr/me*lT;local ms=math.asin(dC.atmosphereRadius/mj)*constants.rad2deg;if ms~=ms then ms=mr end;local mt=ms/me*lT;local cb=ij(mj,1)local mu=dC.name;local mv=false;if hi>lF then if hi>l_ then if hi-mt<=l_ then mv=true end else mv=true end else if hi+mt>=lF then mv=true end end;local mw=false;local mx=hh;if dC.systemId==0 then mx=hh+mg else mx=hh-mg end;if mx+mg>lE then if mx+mg>lZ then if mx-mt-mg<=lZ then mw=true end else mw=true end else if mx+mt+mg>=lE then mw=true end end;local my={}my.x=hh;my.y=hi;my.planet=dC;my.atmoSize=mt;if not mh or mq<mh then mh=mq;mi=my end;if mw and mv then local mz=math.max(mt,5)if mq<mz*mz then mu=mu.." - "..cb end;my.size=hN;my.i=K;my.displayString=mu;my.distance=cb;my.visible=true;mf[#mf+1]=my else my.visible=false end end;local mA=false;table.sort(mf,function(eH,eI)return eH.y<eI.y end)for dQ,fE in ipairs(mf)do local dC,hN,K,mt,hh,hi,mu,cb=fE.planet,fE.size,fE.i,fE.atmoSize,fE.x,fE.y,fE.displayString,fE.distance;local lR,mB,mC,mD;local mE=15;local jl="pdim"if dC.systemId~=0 then mC=iJ(string.len(mu)*5)mE=-(15+mC)mD=iK(10)jl="pdimfill"else mC=iJ(string.len(mu)*9)mD=iK(15)end;if hN*2>mC then lR=dr(hh,lE+mC/2,lZ-mC/2)mB=dr(hi,lF+mD,l_-5)lR=dr(lR,hh-hN+mC/2,hh+hN-mC/2)mB=dr(mB,hi-hN+mD,hi+hN)else lR=hh+mE;mB=hi end;for mF,fE in pairs(gR)do local mG=fE.textPositions;local mH=mG.y-mB;if mF~=K and f3(mH)<mG.height and mG.x+mG.width>lR and mG.x<lR+mC then if hN>mC then mB=dr(mB+mD,lF+15,l_-5)else mB=mG.y+mG.height+1 end end end;local mI=mu~=dC.name or lR<=lX and lR+mC>=lX and mB-mD<=lY and mB>=lY;fE.hovered=mI;local mJ=1;if mI then mJ=2;if hN*2<mC then mJ=10 end;if mu==dC.name then mu=mu.." - "..cb end;jl="pbright"if dC.systemId~=0 then mC=iJ(string.len(mu)*5)mE=-(15+mC)else mC=iJ(string.len(mu)*7)end;if hN*2>mC then lR=dr(hh,lE+mC/2,lZ-mC/2)lR=dr(lR,hh-hN+mC/2,hh+hN-mC/2)else lR=hh+mE end end;gR[K]={}gR[K].textPositions={}gR[K].textPositions.y=mB;gR[K].textPositions.x=lR;gR[K].textPositions.width=mC;gR[K].textPositions.height=mD;gR[K].output=""if hN*2>mC then jl=jl.." txtmid"else jl=jl.." txtstart"end;if mt-hN>2 then gR[K].output=dq('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hh,hi,mt,cp,0.1*mJ)end;gR[K].output=gR[K].output..dq('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hh,hi,hN,cp,0.2*mJ)if dC.systemId==0 then gR[K].output=gR[K].output..dq([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lR,mB,co,jl,mu)if hN*2<=mC then gR[K].output=gR[K].output..dq("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lR+mC,mB+2,lR,mB+2,hh,hi)end else gR[K].output=gR[K].output..dq([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lR,mB,cp,jl,mu)if hN*2<=mC then gR[K].output=gR[K].output..dq("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lR,mB+2,lR+mC,mB+2,hh,hi)end end end;for dQ=#dj,1,-1 do if gR[dQ]then jr[#jr+1]=gR[dQ].output end end;if mi~=nil and dk<90 and not mi.hovered then local mK=mi.planet.atmosphereRadius/mi.atmoSize;local mL=dt(mh)*mK;local mM=ij(mL,1)local mC=iJ(math.max(string.len(mM)*7,string.len(mi.planet.name)*7))local mD=iK(12)local lR=dr(mi.x+(lX-mi.x)/2,lE+mC/2,lZ-mC/2)local mB=dr(mi.y+(lY-mi.y)/2,lF+mD*2,l_-5)jr[#jr+1]=dq("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mi.x,mi.y,lX,lY)jr[#jr+1]=dq([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lR,mB,"white",mM)if not mi.visible then jr[#jr+1]=dq([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lR,mB-mD,"white",mi.planet.name)end end;if cY>1 then local gQ=cX;local mk=gQ:normalize()local mn=gQ:project_on_plane(cU):len()local ml=gQ:cross(cU):normalize()local mm=math.acos(ml:dot(cV))if mm~=mm then mm=0 end;if ml:cross(cV):dot(cU)<0 then mm=-mm end;local mo=math.sin(mm)*math.asin(mn/gQ:len())*constants.rad2deg;local mp=math.cos(mm)*math.asin(mn/gQ:len())*constants.rad2deg;if mk:dot(cU)<0 then mp=90*math.cos(mm)+90*math.cos(mm)-mp;mo=90*math.sin(mm)+90*math.sin(mm)-mo end;local hh=lX+mo/me*lT;local hi=lY+mp/me*lT;local km=14;local kn=km/2;local kq=[[<circle
                                    cx="]]..hh..[["
                                    cy="]]..hi..[["
                                    r="]]..kn/km..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hh..[["
                                    cy="]]..hi..[["
                                    r="]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hh-km..[[,]]..hi..[[ h ]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hh+kn..[[,]]..hi..[[ h ]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hh..[[,]]..hi-km..[[ v ]]..kn..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jr[#jr+1]=kq end;jr[#jr+1]=dq("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",lX,lY-10,lX,lY+10)jr[#jr+1]=dq("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",lX-10,lY,lX+10,lY)jr[#jr+1]='</g>'else return jr end end;local function mN(mO,mP)local mQ;local mR=(mP-mO):normalize()local fC=(d0-mO):dot(mR)/mR:dot(mR)if fC<=0. then return(d0-mO):len()elseif fC>=(mP-mO):len()then return(d0-mP):len()end;local mS=mO+fC*mR;mQ=(mS-d0):len()return mQ end;local function mT()local mQ;local mU=nil;local mV=nil;local mW=nil;for dQ,mX in pairs(e[0])do if mX.hasAtmosphere then local cb=mN(iI.center,mX.center)if mU==nil or cb<mU then mV=mX;mU=cb;mW=iI end;if c4 and c4.hasAtmosphere and c4.name~=iI.name then local eU=mN(c4.center,mX.center)if eU<mU then mV=mX;mU=eU;mW=c4 end end end end;local mY=iJ(1770)local mZ=iK(330)if mU then local m_="txttick "local n0=500000;if mU<mV.radius+n0 or mU<mW.radius+n0 then if d8 then m_="txttick red "else m_="txttick orange "end end;mQ=ij(mU,2)iw=gJ(mY,mZ,"Pipe ("..mW.name.."--"..mV.name.."): "..mQ,m_.."pbright txtmid")end end;local function n1(hh,hi,n2,n3,kz)local n4={x=hh,y=hi,width=n2,height=n3,label=kz}iq[kz]=n4;return n4 end;local function n5(n6,n7,n2,n3,hh,hi,n8,n9,na,nb,jl)local n4={enableName=n6,disableName=n7,width=n2,height=n3,x=hh,y=hi,toggleVar=n8,toggleFunction=n9,drawCondition=na,hovered=false,class=jl}if nb then table.insert(ip,n4)else table.insert(io,n4)end;return n4 end;local function nc(nd)if not iu then ne=false;nf=false;ng=false;x=true;return elseif nd=="handling"then ne=not ne;nf=false;ng=false elseif nd=="hud"then nf=not nf;ne=false;ng=false elseif nd=="physics"then ng=not ng;ne=false;nf=false end;if ng or nf or ne then iv=ii(nd)x=false else iv="none"x=true end end;local function nh()iu=not iu;if iu then im=ip;c0="Hold SHIFT to see Settings"dl=x else im=io;c0="Hold SHIFT to see Control Buttons"nc()x=dl end end;local function ni()local function nj(dC,dQ)dC.set(not dC.get())if dC.get()then c0=dQ.." set to true"else c0=dQ.." set to false"end;if dQ=="showHud"then dl=dC.get()elseif dQ=="BrakeToggleDefault"then aU=j end end;local nk=50;local nl=340;local hh=500;local hi=cs/2-400;local nm=0;for dQ,dC in pairs(ii("boolean"))do if type(dC.get())=="boolean"then n5(dQ,dQ,nl,nk,hh,hi,function()return dC.get()end,function()nj(dC,dQ)end,function()return true end,true)hi=hi+nk+20;if nm==9 then hh=hh+nl+20;hi=cs/2-400;nm=0 else nm=nm+1 end end end;n5("Control View","Control View",nl,nk,10,cs/2-500,function()return true end,nh,function()return true end,true)n5("View Handling Settings",'Hide Handling Settings',nl,nk,10,cs/2-(500-nk),function()return ne end,function()nc("handling")end,function()return true end,true)n5("View Hud Settings",'Hide Hud Settings',nl,nk,10,cs/2-(500-nk*2),function()return nf end,function()nc("hud")end,function()return true end,true)n5("View Physics Settings",'Hide Physics Settings',nl,nk,10,cs/2-(500-nk*3),function()return ng end,function()nc("physics")end,function()return true end,true)end;local function nn()local function gy()local g1=d0;local gz=iI.name..". "..#bk;if radar_1 then gz=cE.GetClosestName(gz)end;return cC.AddNewLocation(gz,g1,false,true)end;local function no()a_=not a_ end;local function np(nq)if nq==1 then aY=not aY;aX=false else aX=not aX;aY=false end;aZ=false;b0=false;bZ=false;b1=false;bo=nil;b3=false;b2=false end;local function nr()cC.UpdatePosition()end;local function gw()cC.ClearCurrentPosition()end;local function ns(gx)local lw=cD.routeWP(true)if lw and#lw>0 then return"Engage Route: "..lu(lw[1])end;return"Engage Autopilot: "..lu(gx)end;local function nt(gx)local lw=cD.routeWP(true)if lw and#lw>0 then return"Next Route Point: "..lu(lw[1])end;return"Disable Autopilot: "..lu(gx)end;local function nu()if ic()==1 then bZ=not bZ;if bZ then aZ=false;aX=false;aY=false;b0=false;b3=false;b1=false;b2=false;nv=bh;bh=false;d.control.retractLandingGears()id:setTargetGroundAltitude(X)f_("folOn","F")else f_("folOff","F")aW=true;cI=p;bh=nv;if bh then d.control.extendLandingGears()id:setTargetGroundAltitude(Y)end end else c0="Follow Mode only works with Remote controller"bZ=false end end;local nk=50;local nl=260;local nw=iJ(30)local nx=av+au*2+2;local ny=aw+1;n5("+","+",nw,nw,nx,ny+nw+1,function()return false end,function()dk=dk/8 end,function()return bB=="SCOPE"end,nil,"ZoomButton")n5("-","-",nw,nw,nx,ny,function()return false end,function()dk=math.min(dk*8,90)end,function()return bB=="SCOPE"end,nil,"ZoomButton")n5("0","0",nw,nw,nx,ny+nw*2+2,function()return false end,function()dk=90 end,function()return bB=="SCOPE"and dk~=90 end,nil,"ZoomButton")local nz=n5("Enable Brake Toggle","Disable Brake Toggle",nl,nk,cr/2-nl/2,cs/2+350,function()return aU end,function()aU=not aU;if aU then c0="Brakes in Toggle Mode"else c0="Brakes in Default Mode"end end)n5("Align Prograde","Disable Prograde",nl,nk,cr/2-nl/2-50-nz.width,cs/2-nk+380,function()return aY end,function()np(1)end)n5("Align Retrograde","Disable Retrograde",nl,nk,cr/2-nl/2+nz.width+50,cs/2-nk+380,function()return aX end,np,function()return ci==0 end)nA=n5(ns,nt,600,60,cr/2-600/2,cs/2-60/2-330,function()return aZ or bl or ce or bu end,function()end)local K;local function nB(nC)local lw=cD.routeWP(true)if lw and#lw>0 then return lw[1]end;local gx=dg+nC;if gx>#d7 then gx=gx-#d7-1 end;if gx<0 then gx=#d7+gx end;return gx end;nD={}for K=0,10 do local nE=n5(function(eI)local gx=nB(eI.apExtraIndex)if aZ or bl or ce or bu then return"Redirect: "..lu(gx)end;return ns(gx)end,function(eI)local gx=nB(eI.apExtraIndex)return nt(gx)end,600,60,cr/2-600/2,cs/2-60/2-330+60*K,function(eI)local gx=nB(eI.apExtraIndex)return gx==bg and(aZ or bl or ce or bu)end,function(eI)local gx=nB(eI.apExtraIndex)local nF=bg==gx;bg=gx;cC.UpdateAutopilotTarget()cD.ToggleAutopilot()if not nF and not(aZ or bl or ce or bu)then cD.ToggleAutopilot()end end,function()return df and(#cD.routeWP(true)==0 or K==0)end)nE.apExtraIndex=K;nD[K]=nE end;n5("Save Position","Save Position",200,nA.height,nA.x+nA.width+30,nA.y,function()return false end,gy,function()return bg==0 or g9==nil end)n5("Update Position","Update Position",200,nA.height,nA.x+nA.width+30,nA.y,function()return false end,nr,function()return bg>0 and g9~=nil end)n5("Clear Position","Clear Position",200,nA.height,nA.x-200-30,nA.y,function()return true end,gw,function()return bg>0 and g9~=nil end)n5("Save Route","Save Route",200,nA.height,nA.x+nA.width+30,nA.y+nA.height+20,function()return false end,function()cD.routeWP(false,false,2)end,function()return#cD.routeWP(true)>0 end)n5("Load Route","Clear Route",200,nA.height,nA.x-200-30,nA.y+nA.height+20,function()return#cD.routeWP(true)>0 end,function()if#cD.routeWP(true)>0 then cD.routeWP(false,true)elseif aZ or bl then c0="Disable Autopilot before loading route"return else cD.routeWP(false,false,1)end end,function()return true end)nk=60;nl=300;local hh=0;local hi=cs/2-150;n5("View Settings","View Settings",nl,nk,hh,hi,function()return true end,nh)hi=hi+nk+20;n5("Enable Turn and Burn","Disable Turn and Burn",nl,nk,hh,hi,function()return a_ end,no)hh=10;hi=cs/2-300;n5("Horizontal Takeoff Mode","Vertical Takeoff Mode",nl,nk,hh+nl+20,hi,function()return aV end,function()aV=not aV;if aV then c0="Vertical Takeoff Mode"else c0="Horizontal Takeoff Mode"end end,function()return d1 end)hi=hi+nk+20;n5("Engage Orbiting","Cancel Orbiting",nl,nk,hh+nl+20,hi,function()return bu end,cD.ToggleIntoOrbit,function()return ci==0 and dc end)hi=cs/2-150;n5("Glide Re-Entry","Cancel Glide Re-Entry",nl,nk,hh+nl+20,hi,function()return b3 end,function()cd=1;np(1)end,function()return iI.hasAtmosphere and not ch end)hi=hi+nk+20;n5("Parachute Re-Entry","Cancel Parachute Re-Entry",nl,nk,hh+nl+20,hi,function()return b3 end,cD.BeginReentry,function()return iI.hasAtmosphere and not ch end)hi=hi+nk+20;n5("Engage Follow Mode","Disable Follow Mode",nl,nk,hh,hi,function()return bZ end,nu,function()return ic()==1 end)n5("Enable Repair Arrows","Disable Repair Arrows",nl,nk,hh+nl+20,hi,function()return cw end,function()cw=not cw;if cw then c0="Repair Arrows Enabled"else c0="Repair Arrows Diabled"end end,function()return ic()==1 end)hi=hi+nk+20;if not q then n5("Enable AGG","Disable AGG",nl,nk,hh,hi,function()return d2 end,cD.ToggleAntigrav,function()return antigrav~=nil end)end;n5(function()return dq("Switch IPH Mode - Current: %s",bv)end,function()return dq("IPH Mode: %s",bv)end,nl*2,nk,hh,hi,function()return false end,function()if bv=="All"then bv="Custom Only"elseif bv=="Custom Only"then bv="No Moons"else bv="All"end;c0="IPH Mode: "..bv end)hi=hi+nk+20;n5(function()return dq("Toggle Control Scheme - Current: %s",g)end,function()return dq("Control Scheme: %s",g)end,nl*2,nk,hh,hi,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c0="New Control Scheme: "..g end)local nG=iK(20)local nE=n1(0,0,iJ(70),nG,"HELP")nE=n1(nE.x+nE.width,nE.y,iJ(80),nG,"INFO")nE=n1(nE.x+nE.width,nE.y,iJ(70),nG,"ORBIT")nE=n1(nE.x+nE.width,nE.y,iJ(70),nG,"SCOPE")n1(nE.x+nE.width,nE.y,iJ(70),nG,"HIDE")end;local nH={}local nI=nil;function nH.HUDPrologue(jr)d8,d9=iG(d0)if not d8 then bH=ae;bJ=af;bI=ag;if i9 and G and i9.getState()==0 then i9.toggle()end else bH=ab;bJ=ac;bI=ad;if i9 and G and i9.getState()==1 then i9.toggle()end end;co=[[rgb(]]..bE(bH+0.6)..","..bE(bJ+0.6)..","..bE(bI+0.6)..[[)]]cp=[[rgb(]]..bE(bH*0.8+0.5)..","..bE(bJ*0.8+0.5)..","..bE(bI*0.8+0.5)..[[)]]local nJ=co;local nK=cp;local nL=[[rgb(]]..bE(bH*0.4+0.5)..","..bE(bJ*0.4+0.5)..","..bE(bI*0.4+0.5)..[[)]]local nM=co;local nN=cp;local nO=nL;if iL()and not m then nJ=[[rgb(]]..bE(bH*0.5+0.5)..","..bE(bJ*0.5+0.5)..","..bE(bI*0.5+0.5)..[[)]]nK=[[rgb(]]..bE(bH*0.3+0.5)..","..bE(bJ*0.3+0.5)..","..bE(bI*0.2+0.5)..[[)]]nL=[[rgb(]]..bE(bH*0.2+0.5)..","..bE(bJ*0.2+0.5)..","..bE(bI*0.2+0.5)..[[)]]end;local lj=iJ;local lk=iK;jr[#jr+1]=dq([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nJ,nJ,nJ,nM,nM,nK,nK,nN,nN,nK,nJ,nL,nN,nJ,nJ,nL,nL,nO,nL,cr,cs,nK,nK,nK,nK,nK,nM,nK,nN,nO,nN,nN,nO)if not nI then nI=dq([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lj(630),lk(0),lj(675),lk(45),lj(960),lk(55),lj(1245),lk(45),lj(1290),lk(0),lj(1000),lk(105),lj(1040),lk(59),lj(1250),lk(51),lj(1300),lk(0),lj(1920),lk(0),lj(1920),lk(20),lj(1400),lk(20),lj(1300),lk(105),lj(920),lk(105),lj(880),lk(59),lj(670),lk(51),lj(620),lk(0),lj(0),lk(0),lj(0),lk(20),lj(520),lk(20),lj(620),lk(105),lj(890),lk(59),lj(960),lk(62),lj(1030),lk(59),lj(985),lk(112),lj(1150),lk(112),lj(1100),lk(152),lj(820),lk(152),lj(780),lk(112),lj(935),lk(112),lj(890),lk(59),lj(960),lk(62),lj(1030),lk(59),lj(985),lk(112),lj(1150),lk(112),lj(1100),lk(152),lj(820),lk(152),lj(780),lk(112),lj(935),lk(112))end;if x and I then jr[#jr+1]=nI end;return jr end;function nH.DrawVerticalSpeed(jr,e8)jq(jr,e8)end;function nH.UpdateHud(jr)local kf=d5;local nP=d6;local jy=nP;local jO=kf;local kx=bE(c.getThrottle())local kC=cY*3.6;local ky=c.getAxisCommandValue(0)local nQ=iJ(1770)local nR=iK(310)if u and d4 then ky=bK;kx=bK*100 end;local iN=iM()local jz="ROLL"if kx==nil then kx=0 end;if not dc then if cY>5 then kf=ke(cW)nP=kg(cW)else kf=0;nP=0 end;jz="YAW"end;if d9>50000 and not ch then local nS;nS=ij(d9)jr[#jr+1]=gJ(nQ,nR,"PvP Boundary: "..nS,"pbright txtbig txtmid")end;jr[#jr+1]=cc;jr[#jr+1]=cq;jr[#jr+1]=i3;if iw~=""then jr[#jr+1]=iw end;if iO~=""then jr[#jr+1]=iO end;if iP~=""then jr[#jr+1]=iP end;jq(jr,cj)if ic()==0 or l then if dc then jx(jr,ah,ai,jy,jz,dc)else jx(jr,ah,ai,nP,jz,dc)end;if not iL()or m then if dc then jx(jr,ah,ai,jy,jz,dc)jN(jr,jO,jy,ah,ai,dc,bE(kg(cW)),cY)else jx(jr,ah,ai,nP,jz,dc)jN(jr,kf,nP,ah,ai,dc,bE(nP),cY)end;jU(jr,cj,dc)kh(jr,cW,cY,ah,ai)end end;kw(jr,iN,kx,ky)kB(jr,kC)kF(jr)lD(jr)if not iu and b_ then lv(jr)end;return jr end;function nH.HUDEpilogue(jr)jr[#jr+1]="</svg>"return jr end;function nH.ExtraData(jr)local nT=iJ(1240)local nU=iK(55)local nV=nU+10;local gC;local lj=iJ;local lk=iK;local nW=0;local iN=iM()if aV then iN=iN.."-VERTICAL"end;if F and not b2 and not b1 and cY>20 then iN=iN.."-COLLISION ON"end;if bx~="Off"then iN="("..bx..")-"..iN end;if a_ then iN="TB-"..iN end;if not bw then iN=iN.."-DeCoupled"end;local nX=lk(99)local nY=lk(80)local nZ=lk(85)local n_=lk(31)local o0=0;local o1=0;local o2=cl>1000000 and ig(cl/1000000,2).."kT"or ig(cl/1000,2).."T"if ch then nW=bp else nW=bn end;local o3,o4=cy.computeDistanceAndTime(cY,0,cl,0,0,nW)if o3<0 then o3=0 end;nW=ig(nW/(cl*il),2).."g"local o5=d:maxForceForward()gC=b.g()if gC>0.1 then o1=cl*gC;o1=ig(o1/(cl*il),2).."g"o0=0.5*o5/gC;o0=o0>1000000 and ig(o0/1000000,2).."kT"or ig(o0/1000,2).."T"end;o5=ig(o5/(cl*il),2).."g"local o6=vec3(b.getWorldAcceleration()):len()/9.80665;gC=b.g()jr[#jr+1]=[[<g class="dim txt txtend size14">]]if ic()==1 and not l then nT=iJ(1120)nU=iK(55)nV=nU+10 elseif ch and I then local o7=iJ(770)jr[#jr+1]=gJ(lj(895),nX,"ATMO","")jr[#jr+1]=dq([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lj(895),nZ,lj(-80))jr[#jr+1]=gJ(lj(815),nY,dq("%.1f%%",ci*100),"txtstart size20")end;if I then jr[#jr+1]=gJ(lj(1025),nX,"GRAVITY","txtstart")jr[#jr+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(1025),nZ,lj(80))jr[#jr+1]=gJ(lj(1105),nY,dq("%.2fg",gC/9.80665),"size20")jr[#jr+1]=gJ(lj(1125),nX,"ACCEL","txtstart")jr[#jr+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(1125),nZ,lj(80))jr[#jr+1]=gJ(lj(1205),nY,dq("%.2fg",o6),"size20")jr[#jr+1]=gJ(lj(695),nX,"BRK TIME","")jr[#jr+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(695),nZ,lj(-80))jr[#jr+1]=gJ(lj(615),nY,dq("%s",ik(o4)),"txtstart size20")jr[#jr+1]=gJ(lj(635),lk(45),"TRIP","")jr[#jr+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(635),lk(31),lj(-90))if ld then jr[#jr+1]=gJ(lj(532),lk(23),dq("%s",ik(ld)),"txtstart size20")end;jr[#jr+1]=gJ(lj(795),nX,"BRK DIST","")jr[#jr+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(795),nZ,lj(-80))jr[#jr+1]=gJ(lj(715),nY,dq("%s",ij(o3)),"txtstart size20")jr[#jr+1]=gJ(lj(1285),lk(45),"MASS","txtstart")jr[#jr+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(1285),lk(31),lj(90))jr[#jr+1]=gJ(lj(1388),lk(23),dq("%s",o2),"size20")jr[#jr+1]=gJ(lj(1220),nX,"THRUST","txtstart")jr[#jr+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lj(1220),nZ,lj(80))jr[#jr+1]=gJ(lj(1300),nY,dq("%s",o5),"size20")jr[#jr+1]=gJ(iJ(960),iK(175),iN,"pbright txtbig txtmid size20")end;jr[#jr+1]="</g>"end;function nH.DrawOdometer(jr,c5,bi,c6)if bB~="INFO"then return jr end;local gC;local o0=0;local o1=0;local nW=0;local o2=cl>1000000 and ig(cl/1000000,2).." kTons"or ig(cl/1000,2).." Tons"if ch then nW=bp else nW=bn end;local o3,o4=cy.computeDistanceAndTime(cY,0,cl,0,0,nW)nW=ig(nW/(cl*il),2).." g"local o5=d:maxForceForward()gC=b.g()if gC>0.1 then o1=cl*gC;o1=ig(o1/(cl*il),2).." g"o0=0.5*o5/gC;o0=o0>1000000 and ig(o0/1000000,2).." kTons"or ig(o0/1000,2).." Tons"end;o5=ig(o5/(cl*il),2).." g"if ic()==0 or l then local o8=iJ(av+10)local o9=iK(aw+20)local oa=iJ(av+10+au/1.25)local n3=25;jr[#jr+1]="<g class='txtstart size14 bright'>"jr[#jr+1]=gJ(o8,o9,dq("BrkTime: %s",ik(o4)))jr[#jr+1]=gJ(oa,o9,dq("Trip: %.2f km",c5))jr[#jr+1]=gJ(o8,o9+n3,dq("Lifetime: %.2f kSU",bi/200000))jr[#jr+1]=gJ(oa,o9+n3,dq("BrkDist: %s",ij(o3)))jr[#jr+1]=gJ(o8,o9+n3*2,"Trip Time: "..ik(c6))jr[#jr+1]=gJ(oa,o9+n3*2,"Total Time: "..ik(bj))jr[#jr+1]=gJ(o8,o9+n3*3,dq("Mass: %s",o2))jr[#jr+1]=gJ(oa,o9+n3*3,dq("Max Brake: %s",nW))jr[#jr+1]=gJ(o8,o9+n3*4,dq("Max Thrust: %s",o5))if gC>0.1 then jr[#jr+1]=gJ(oa,o9+n3*4,dq("Max Thrust Mass: %s",o0))jr[#jr+1]=gJ(o8,o9+n3*5,dq("Req Thrust: %s",o1))else jr[#jr+1]=gJ(oa,o9+n3*5,"Max Mass: n/a")jr[#jr+1]=gJ(o8,o9+n3*6,"Req Thrust: n/a")end end;jr[#jr+1]="</g></g>"return jr end;function nH.DrawWarnings(jr)return kF(jr)end;function nH.DisplayOrbitScreen(jr)return lD(jr)end;function nH.DisplayMessage(jr,l0)if l0~="empty"then local hi=310;for ob in string.gmatch(l0,"([^\n]+)")do hi=hi+35;jr[#jr+1]=gJ("50%",hi,ob,"msg")end end;if ca~=0 then c.setTimer("msgTick",ca)ca=0 end end;function nH.DrawDeadZone(jr)jr[#jr+1]=dq([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],at)end;function nH.UpdatePipe()if ch then iw=""return end;mT()end;function nH.DrawSettings(jr)local hh=iJ(640)local hi=iK(200)jr[#jr+1]=[[<g class="pbright txtvspd txtstart">]]local hL=0;for dQ,dC in pairs(iv)do hL=hL+1;jr[#jr+1]=gJ(hh,hi,dQ..": "..dC.get())hi=hi+20;if hL%12==0 then hh=hh+iJ(350)hi=iK(200)end end;jr[#jr+1]=gJ(iJ(640),iK(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jr[#jr+1]="</g>"return jr end;local i4;local i0=iJ(1770)local i1=iK(350)local h_=iK(15)local hZ=iJ(1370)local dn,oc;local i5=0;function nH.DrawRadarInfo()i3=cE.GetRadarHud(hZ,h_,i0,i1)end;function nH.DrawTanks()if ap~=0 and aq~=0 then iO=gJ(ap,aq,"","txtstart pdim txtfuel")jb=aq;j4(ap,"Atmospheric ","ATMO",ct,j2,j3)j4(ap,"Space Fuel T","SPACE",cu,j0,j1)j4(ap,"Rocket Fuel ","ROCKET",cv,iZ,i_)end end;function nH.DrawShield()local od=i9.getState()==1 and"Shield Active"or"Shield Disabled"local oe=b.getPvPTimer()local of=i9.getResistances()local og="A: "..10+of[1]*100 .."% / E: "..10+of[2]*100 .."% / K:"..10+of[3]*100 .."% / T: "..10+of[4]*100 .."%"local hh,hi=ar-60,as+30;local oh=bE(0.5+i9.getShieldHitpoints()*100/i9.getMaxShieldHitpoints())local jj=bE(oh*2.55)local jk=dq("rgb(%d,%d,%d)",255-jj,jj,0)local jl=""iP=gJ(hh,hi,"","txtmid pdim txtfuel")if oh<10 and od~="Shield Disabled"then jl="red "end;oe=oe>0 and"   PvPTime: "..ik(oe)or""iP=iP..dq([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hh,hi,jk,oh*2,hh,hi,hh+2,hi+10,oh,oe)iP=iP..gJ(hh,hi-5,od,jl.."txtstart pbright txtbig")iP=iP..gJ(hh,hi+30,og,jl.."txtstart pbright txtsmall")end;function nH.hudtick()if not iI then return end;local function oi(jr)local jn=bE(dr(cb/(cr/4)*255,0,255))jr[#jr+1]=dq("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c8,c9,bE(bH+0.5)+jn,bE(bJ+0.5)-jn,bE(bI+0.5)-jn)end;local function oj()for dV,dC in pairs(im)do if dC.hovered then if not dC.drawCondition or dC.drawCondition(dC)then dC.toggleFunction(dC)end;dC.hovered=false end end;for dV,dC in pairs(iq)do if dC.hovered then bB=dC.label;dC.hovered=false end end end;local function ok()local function ol(om,on,hh,hi,n2,n3)if om>=hh and om<=hh+n2 and on>=hi and on<=hi+n3 then return true else return false end end;local hh=c8+cr/2;local hi=c9+cs/2;for dV,dC in pairs(im)do dC.hovered=ol(hh,hi,dC.x,dC.y,dC.width,dC.height)end;for dV,dC in pairs(iq)do dC.hovered=ol(hh,hi,dC.x,dC.y,dC.width,dC.height)end;if df then local mI=false;for dV,eI in ipairs(nD)do if eI.hovered then mI=true;break end end;if nA.hovered then mI=true end;df=mI else df=nA.hovered;if not df then dg=bg end end end;local function oo(jr)if not bB or bB==""then bB="HELP"end;if x then for dQ,dC in pairs(iq)do local jl="dim brightstroke"local op=0.2;if bB==dQ then jl="pbright dimstroke"op=0.6 end;local oq=""if dC.hovered then op=0.8;oq=";stroke:white"end;jr[#jr+1]=dq([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dC.width,dC.height,dC.x,dC.y,jl,op,oq)jr[#jr+1]=gJ(dC.x+dC.width/2,dC.y+dC.height/2+5,dC.label,"txt txtmid pdim")end end end;local function os(jr)local function ot(jr,ou,hover,hh,hi,fo,ov,ow,ox,oy,oz,nE)if type(oy)=="function"then oy=oy(nE)end;if type(oz)=="function"then oz=oz(nE)end;jr[#jr+1]=dq("<rect x='%f' y='%f' width='%f' height='%f' fill='",hh,hi,fo,ov)if ou then jr[#jr+1]=dq("%s'",ow)else jr[#jr+1]=ox end;if hover then jr[#jr+1]=dq(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ab,ac,ad)else jr[#jr+1]=dq(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",ig(ab*0.5,0),ig(ac*0.5,0),ig(ad*0.5,0))end;jr[#jr+1]=" rx='5'></rect>"jr[#jr+1]=dq("<text x='%f' y='%f' font-size='24' fill='",hh+fo/2,hi+ov/2+5)if ou then jr[#jr+1]="black"else jr[#jr+1]="white"end;jr[#jr+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if ou then jr[#jr+1]=dq("%s</text>",oy)else jr[#jr+1]=dq("%s</text>",oz)end end;local oA=dq("rgb(%d,%d,%d)'",ig(ab*0.1,0),ig(ac*0.1,0),ig(ad*0.1,0))local oB=dq("rgb(%d,%d,%d)",ig(ab*0.8,0),ig(ac*0.8,0),ig(ad*0.8,0))local oC=ot;for dV,dC in pairs(im)do local n7=dC.disableName;local n6=dC.enableName;if type(n7)=="function"then n7=n7(dC)end;if type(n6)=="function"then n6=n6(dC)end;if not dC.drawCondition or dC.drawCondition(dC)then oC(jr,dC.toggleVar(dC),dC.hovered,dC.x,dC.y,dC.width,dC.height,oB,oA,n7,n6,dC)end end end;local oD=ig(cr/2,0)local oE=ig(cs/2,0)local jr={}cB.HUDPrologue(jr)if x then cB.UpdateHud(jr)else if B then cB.DrawVerticalSpeed(jr,cj)end;cB.DrawWarnings(jr)end;if iu and iv~="none"then cB.DrawSettings(jr)end;if radar_1 then cB.DrawRadarInfo()end;cB.HUDEpilogue(jr)jr[#jr+1]=dq([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cr,cs)if c0~="empty"then cB.DisplayMessage(jr,c0)end;if ic()==0 and g=="virtual joystick"then if w then cB.DrawDeadZone(jr)end end;oo(jr)if ie()==0 then if ic()==1 and b_ then if not oF then ok()os(jr)end;if not cG and not cH then local oG=table.concat(jr,"")jr={}jr[#jr+1]=dq("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jr[#jr+1]=oG;jr[#jr+1]="</body>"cG=true;jr[#jr+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local oH=table.concat(jr,"")a.setScreen(oH)elseif cH then local oG=table.concat(jr,"")jr={}jr[#jr+1]=dq("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jr[#jr+1]=oG;jr[#jr+1]="</body>"end;if not cG then jr[#jr+1]=dq([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oD,oE,c8,c9)end else oj()end else if not b_ and ic()==0 then oj()if cb>at then if w then oi(jr)end end elseif b_ and(not oF or not i)then ok()os(jr)end;jr[#jr+1]=dq([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oD,oE,c8,c9)end;jr[#jr+1]=[[</svg></body>]]oH=table.concat(jr,"")end;function nH.TenthTick()local function oI()local oJ=a.createData;local oK=a.createWidget;oL=a.createWidgetPanel("Interplanetary Helper")oM=oK(oL,"value")oN=oJ('{"label": "Target Planet", "value": "N/A", "unit":""}')fZ(oN,oM)oO=oK(oL,"value")oP=oJ('{"label": "distance", "value": "N/A", "unit":""}')fZ(oP,oO)gq=oK(oL,"value")gp=oJ('{"label": "Travel Time", "value": "N/A", "unit":""}')fZ(gp,gq)go=oK(oL,"value")gn=oJ('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fZ(gn,go)gs=oK(oL,"value")gr=oJ('{"label": "Target Altitude", "value": "N/A", "unit":""}')fZ(gr,gs)gk=oK(oL,"value")gj=oJ('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gi=oK(oL,"value")gh=oJ('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gg=oK(oL,"value")gf=oJ('{"label": "Max Brake distance", "value": "N/A", "unit":""}')ge=oK(oL,"value")gd=oJ('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gm=oK(oL,"value")gl=oJ('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ch then fZ(gj,gk)fZ(gh,gi)fZ(gf,gg)fZ(gd,ge)fZ(gl,gm)end end;local function oQ()gI(oL)oL=nil end;local function oR()if not aZ then if g9==nil or g9.planetname~=iI.name then oS=(c4.center-d0):len()else oS=(g9.position-d0):len()end end;local fv=cY;local oT=c.getThrottle()/100;if u then oT=bK end;local oU,oV=cy.computeDistanceAndTime(cY,_,cl,d:maxForceForward()*oT,a1,0)local c2,c3;if not a_ then c2,c3=cD.GetAutopilotBrakeDistanceAndTime(_)else c2,c3=cD.GetAutopilotTBBrakeDistanceAndTime(_)end;local dV,oW;if not a_ and fv>0 then dV,oW=cD.GetAutopilotBrakeDistanceAndTime(fv)else dV,oW=cD.GetAutopilotTBBrakeDistanceAndTime(fv)end;local oX=0;local oY=0;if b9 or not aZ and fv>5 then oY=cy.computeTravelTime(fv,0,oS)elseif c2+oU<oS then oX=oS-(c2+oU)oY=cy.computeTravelTime(8333.0556,0,oX)else local oZ=(oS-c2)/oU;oU=oS-c2;oV=oV*oZ end;if g9~=nil and g9.planetname==iI.name and not aZ then return oY elseif b8 then return oW elseif b9 then return oY+oW else return oV+c3+oY end end;cB.DrawTanks()if i9 then cB.DrawShield()end;if be~="None"then if oL==nil then oI()end;if be~=nil then local o_=g9~=nil;local p0=0.5*bp/c4:getGravity(c4.center+vec3(0,0,1)*c4.radius):len()p0=p0>1000000 and ig(p0/1000000,2).." kTons"or ig(p0/1000,2).." Tons"fY(oN,'{"label": "Target", "value": "'..be..'", "unit":""}')ld=oR()if o_ and not aZ then cb=(d0-g9.position):len()else cb=(bf-d0):len()end;if not a_ then c2,c3=cD.GetAutopilotBrakeDistanceAndTime(cY)iy,iz=cD.GetAutopilotBrakeDistanceAndTime(_)else c2,c3=cD.GetAutopilotTBBrakeDistanceAndTime(cY)iy,iz=cD.GetAutopilotTBBrakeDistanceAndTime(_)end;local l0=ij(cb)fY(oP,'{"label": "distance", "value": "'..l0 ..'"}')fY(gp,'{"label": "Travel Time", "value": "'..ik(ld)..'", "unit":""}')l0=ij(c2)fY(gj,'{"label": "Cur Brake distance", "value": "'..l0 ..'"}')fY(gh,'{"label": "Cur Brake Time", "value": "'..ik(c3)..'", "unit":""}')l0=ij(iy)fY(gf,'{"label": "Max Brake distance", "value": "'..l0 ..'"}')fY(gd,'{"label": "Max Brake Time", "value": "'..ik(iz)..'", "unit":""}')fY(gn,'{"label": "Max Brake Mass", "value": "'..dq("%s",p0)..'", "unit":""}')l0=ij(gt)fY(gr,'{"label": "Target Orbit", "value": "'..l0 ..'"}')if ci>0 and not p1 then a.removeDataFromWidget(gd,ge)a.removeDataFromWidget(gf,gg)a.removeDataFromWidget(gh,gi)a.removeDataFromWidget(gj,gk)a.removeDataFromWidget(gl,gm)p1=true;if not d4 and u and(b0 or b3 or cf)then cD.cmdThrottle(1)aW=false;bO=false end end;if ci==0 and p1 then if fY(gd,ge)==1 then fZ(gd,ge)end;if fY(gf,gg)==1 then fZ(gf,gg)end;if fY(gh,gi)==1 then fZ(gh,gi)end;if fY(gj,gk)==1 then fZ(gj,gk)end;if fY(gl,gm)==1 then fZ(gl,gm)end;p1=false end end else oQ()end;if warpdrive~=nil then if ia(warpdrive.getData()).destination~="Unknown"and ia(warpdrive.getData()).distance>400000 then warpdrive.show()p2=true else warpdrive.hide()p2=false end end end;function nH.OneSecondTick(jr)local function p3()local jf=bD()local kC=cY;local p4=jf-ck;if kC>1.38889 then kC=kC/1000;local p5=kC*(jf-ck)bi=bi+p5;c5=c5+p5 end;c6=c6+p4;bj=bj+p4;ck=jf end;p3()cB.UpdatePipe()cB.ExtraData(jr)end;function nH.AnimateTick()cH=true;cG=false;c8=0;c9=0;c.stopTimer("animateTick")end;function nH.MsgTick()local jr={}cB.DisplayMessage(jr,"empty")c0="empty"c.stopTimer("msgTick")ca=3 end;function nH.ButtonSetup()ni()nn()im=io end;return nH end;local function p6(d,b,c,a,e,vBooster,hover,p7,antigrav,warpdrive,dbHud_1,f3,bE,bF,ic,eZ,bD,dr,id,fY,ie,dt,ig,f_,ih,du,ij,ik,p8,ia,dq,fZ)local p9={}local function pa(fv)local pb=ba;if not aZ then pb=0 end;if not ch then return cy.computeDistanceAndTime(fv,pb,cl,0,0,bn-bc*cl)else if bp and bp>0 then return cy.computeDistanceAndTime(fv,pb,cl,0,0,bp-bc*cl)else return 0,0 end end end;local function pc(fv)local pb=ba;if not aZ then pb=0 end;return cy.computeDistanceAndTime(fv,pb,cl,d:maxForceForward(),a1,bn-bc*cl)end;local pd=false;local pe=0;local pf=0;local pg=0;local ph=bD()local pi=0;local pj=0;local pk=0;local pl=0;local pm=false;local pn=false;local po=false;local pp=nil;local pq=0;local pr={}local ix=55;local ps=nil;local pt=""function p9.GetAutopilotBrakeDistanceAndTime(fv)return pa(fv)end;function p9.GetAutopilotTBBrakeDistanceAndTime(fv)return pc(fv)end;local function pu(pv,pw,px)pw=pw:project_on_plane(pv)px=px:project_on_plane(pv)return eZ(pw:cross(px):dot(pv),pw:dot(px))end;local function py()local function pz()local pA=-1;local pB=-1;if vBooster then pA=vBooster.getDistance()end;if hover then pB=hover.getDistance()end;if pA~=-1 and pB~=-1 then if pA<pB then return pA else return pB end elseif pA~=-1 then return pA elseif pB~=-1 then return pB else return-1 end end;local pC=pz()local pD=-1;if p7 then pD=p7.getDistance()end;if pC~=-1 and pD~=-1 then if pC<pD then return pC else return pD end elseif pC~=-1 then return pC else return pD end end;local function pE(iI,eQ,pF)local function pG(pH,e1)local eW=vec3(e1)if pH.id==0 then return setmetatable({latitude=eW.x,longitude=eW.y,altitude=eW.z,id=0,systemId=pH.systemId},e3)end;local eX=eW-pH.center;local cb=eX:len()local e8=cb-pH.radius;local e6=0;local e7=0;if not du(cb,0)then local eY=eZ(eX.y,eX.x)e7=eY>=0 and eY or 2*math.pi+eY;e6=math.pi/2-math.acos(eX.z/cb)end;return setmetatable({latitude=math.deg(e6),longitude=math.deg(e7),altitude=e8,id=pH.id,systemId=pH.systemId},e3)end;local pI=pG(iI,eQ)pI="::pos{"..pI.systemId..","..pI.id..","..pI.latitude..","..pI.longitude..","..pI.altitude.."}"if pF then return pI else a.setWaypoint(pI)return true end end;local pJ=false;function p9.showWayPoint(iI,eQ,pF)return pE(iI,eQ,pF)end;function p9.APTick()local function pK()if de and not b1 then local ex=de[1]local hQ,hR=de[2],de[3]local pL=math.min(hQ,hR or hQ)local pM=pL/cY;local pN=b2 and(cY<42 or cg~=-1)local pO=b0 or bl or bo or aZ;if pO and not pN and(c2*1.5>pL or pM<1)then aW=true;pr={}cD.cmdThrottle(0)if b0 then cD.ToggleAltitudeHold()end;if bo then cD.ToggleLockPitch()end;c0="Autopilot Cancelled due to possible collision"if bl or aZ then cD.ToggleAutopilot()end;l7=true;b1=true;cI=true end;if pM<11 then dd=ex.name.." COLLISION "..ik(pM).." / "..ij(pL,2)else dd=ex.name.." collision "..ik(pM)end;if pM<6 then f_("alarm","AL",2)end else dd=false end end;local function pP(pQ,pR,pS)local function pT(pQ,ez)pQ=vec3(pQ)ez=vec3(ez):normalize()local dL=pQ*ez;return dL.x+dL.y+dL.z end;local pU=0.001;local pV=1;if not ch or not cJ or cg~=-1 or cY<ix then if pS==nil then pS=aN end;if pR==nil then pR=pU end;pQ=vec3(pQ):normalize()local pW=vec3()-pQ;local pX=-pT(pW,b.getConstructWorldOrientationRight())*pV;local pY=-pT(pW,b.getConstructWorldOrientationUp())*pV;if pf==0 then pf=pX/2 end;if pg==0 then pg=pY/2 end;if f3(pX)<0.1 then bU=bU-pX*2 else bU=bU-(pX+(pX-pf)*pS)end;if f3(pY)<0.1 then bT=bT+pY*2 else bT=bT+pY+(pY-pg)*pS end;pf=pX;pg=pY;if f3(pX)<pR and f3(pY)<pR then return true end;return false elseif cJ and cg==-1 then pQ=cX;if pS==nil then pS=aN end;if pR==nil then pR=pU end;pQ=vec3(pQ):normalize()local pW=cU-pQ;local pX=-pT(pW,b.getConstructWorldOrientationRight())*pV;local pY=-pT(pW,b.getConstructWorldOrientationUp())*pV;if pf==0 then pf=pX/2 end;if pg==0 then pg=pY/2 end;if f3(pX)<0.1 then bU=bU-pX*5 else bU=bU-(pX+(pX-pf)*pS)end;if f3(pY)<0.1 then bT=bT+pY*5 else bT=bT+pY+(pY-pg)*pS end;pf=pX;pg=pY;if f3(pX)<pR and f3(pY)<pR then return true end;return false end end;ch=bF()>0;ci=bF()cj=b.getAltitude()cg=py()bG=bD()ph=bG;if F then pK()end;if antigrav then d2=antigrav.getState()==1 end;local pZ=1;local p_=1;local q0=bG-ph;local q1=-math.deg(pu(cT,cX,cU))local q2=math.deg(pu(cV,cX,cU))local gv=cZ*-1;cJ=ch and q1<-L or q1>L or q2<-M or q2>M;local q3=a.getMouseDeltaX()local q4=a.getMouseDeltaY()if o and not b_ then q4=-q4 end;bU=0;bY=0;bT=0;g2=cx[0]iI=g2:closestBody(b.getConstructWorldPos())q5=cA(iI)fz=q5:orbitalParameters(b.getConstructWorldPos(),cX)if cj==0 then cj=(d0-iI.center):len()-iI.radius end;dc=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;local gC=iI:getGravity(b.getConstructWorldPos()):len()*cl;cK=0;cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if ie()==0 then if ic()==1 and b_ then if not cG then c8=dr(c8+q3,-cr/2,cr/2)c9=dr(c9+q4,-cs/2,cs/2)end else c8=0;c9=0 end else c8=dr(c8+q3,-cr/2,cr/2)c9=dr(c9+q4,-cs/2,cs/2)cb=dt(c8*c8+c9*c9)if not b_ and ic()==0 then local ko,kp=1,1;if bB=="SCOPE"then ko,kp=dk/90,dk/90 end;if g=="virtual joystick"then if c8>0 and c8>at then bU=bU-(c8-at)*aB*ko elseif c8<0 and c8<at*-1 then bU=bU-(c8+at)*aB*ko else bU=0 end;if c9>0 and c9>at then bT=bT-(c9-at)*aC*kp elseif c9<0 and c9<at*-1 then bT=bT-(c9+at)*aC*kp else bT=0 end else c8=0;c9=0;if g=="mouse"then bT=(-utils.smoothstep(q4,-100,100)+0.5)*2*pZ;bU=(-utils.smoothstep(q3,-100,100)+0.5)*2*p_ end end end end;local q6=cY>8334;if cY>V/3.6 and not ch and not aZ and not q6 then c0="Space Speed Engine Shutoff reached"cD.cmdThrottle(0)end;if not q6 and q7 then if not aW then cD.BrakeToggle()end;if aZ then cD.ToggleAutopilot()end end;q7=q6;if ch and ci>0.09 then if cY>cL/3.6 and not u and not pd then aW=true;pd=true elseif not u and pd then if cY<cL/3.6 then dm("HERE1")aW=false;pd=false end end end;if aW then bX=1 else bX=0 end;if aY then if cd then aW=false;local q8=false;if g9 and cd~=1 then q8=pP(g9.position-d0,0.1)else q8=pP(vec3(cX),0.01)end;cI=true;if q8 then cD.cmdCruise(bE(cL))if(f3(d6)<2 or f3(d5)>85)and cY>=cL/3.6-1 then aW=false;aY=false;bQ=true;if cd~=1 then cf=true end;cd=false;aZ=false;cD.BeginReentry()end elseif ch and u then cD.cmdThrottle(1)end elseif cY>ix then pP(vec3(cX),0.01)end end;if aX then if ch then aX=false elseif cY>ix then pP(-vec3(cX))end end;if not aY and cd and not bu then if ci==0 then bQ=true;cD.BeginReentry()cd=false;cf=true else cd=false;cD.ToggleAutopilot()end end;if cf and g9 and(cj<b5+250 and cj>b5-250)and cY*3.6>cL-250 and f3(c_)<25 and ci>=0.1 and(g9.position-d0):len()>2000+cj then cD.ToggleAutopilot()cf=false end;if b4 then cI=true;local q9=b5;if c_<-30 then c0="Unable to achieve lift. Safety Landing."c7=0;cI=p;b4=false;b1=true elseif not q and d2 or b5<iI.spaceEngineMinAltitude then if d2 then q9=antigrav.getBaseAltitude()end;if cj<q9-100 then cM=0;c7=15;aW=false elseif c_>0 then aW=true;c7=0 elseif c_<-30 then aW=true;c7=15 elseif cj>=q9 then if d2 then if aZ or bl then cD.ToggleVerticalTakeoff()else aW=true;b4=false end;c0="Takeoff complete. Singularity engaged"f_("aggLk","AG")else aW=false;c0="VTO complete. Engaging Horizontal Flight"f_("vtoc","VT")cD.ToggleVerticalTakeoff()end;c7=0 end else if ci>0.08 then cM=0;aW=false;c7=20 elseif ci<0.08 and ci>0 then aW=false;if cR then cM=0;c7=20 else c7=0;cM=36;cD.cmdCruise(3500)end else cI=p;bu=true;cQ=false;qa=false;pm=false;pk=nil;pl=nil;if pp==nil then pp=iI end;cP=q9;po=true;b4=false end end;if cM~=nil then if qb==nil then qb=pid.new(2*0.01,0,2*0.1)end;local qc=dr(cM-d5,-M*0.80,M*0.80)qb:inject(qc)local qd=dr(qb:get(),-1,1)bT=qd end end;if bu then local pW;local qe=false;local qf=ij(cP)if pp==nil then pp=iI;if bl then pp=c4 end end;if not po then cP=bE(pp.radius+pp.surfaceMaxAltitude+T)if pp.hasAtmosphere then cP=bE(pp.radius+pp.noAtmosphericDensityAltitude+T)end;po=true end;if cO.VectorToTarget and g9 then pW=g9.position-d0 end;local qg,qh=cA(pp):escapeAndOrbitalSpeed((d0-pp.center):len()-pp.radius)local qi=d6;if not pm then local qj=false;local qk=false;cD.cmdThrottle(0)pl=0;cN="Aligning to orbital path - OrbitHeight: "..qf;if cO.VectorToTarget then pP(pW:normalize():project_on_plane(cZ))qe=cU:dot(pW:project_on_plane(cT):normalize())>0.95 else pP(cX)qe=q1<0.5;if cY<150 then qe=true end end;bT=0;pk=0;if d5<=pk+1 and d5>=pk-1 then qj=true else qj=false end;if qi<=pl+1 and qi>=pl-1 then qk=true else qk=false end;if qj and qk and qe then pk=nil;pl=nil;pm=true end else if cO.VectorToTarget then pP(pW:normalize():project_on_plane(cZ))elseif cY>150 then pP(cX)end;bT=0;if cO.VectorToTarget and g9 then local c2,dV=cy.computeDistanceAndTime(cY,cL/3.6,cl,0,0,bn)if cQ and pW:len()>15000+c2+cj then cN="Orbiting to Target"if cj-100<=pp.noAtmosphericDensityAltitude or ld>fz.timeToPeriapsis and fz.periapsis.altitude<pp.noAtmosphericDensityAltitude then cQ=false end elseif cQ or pW:len()<15000+c2+cj then c0="Orbit complete, proceeding with reentry"f_("orCom","OB")bf=g9.position;bQ=true;cf=true;cO.VectorToTarget,cO.AutopilotAlign=false,false;cD.ToggleIntoOrbit()cD.BeginReentry()return end end;if fz.periapsis~=nil and fz.apoapsis~=nil and fz.eccentricity<1 and cj>cP*0.9 and cj<cP*1.4 then if fz.apoapsis~=nil then if fz.periapsis.altitude>=cP*0.99 and fz.apoapsis.altitude>=cP*0.99 and fz.periapsis.altitude<fz.apoapsis.altitude and fz.periapsis.altitude*1.05>=fz.apoapsis.altitude or cQ then if cQ then aW=false;cD.cmdThrottle(0)pk=0;if not cO.VectorToTarget then c0="Orbit complete"f_("orCom","OB")cD.ToggleIntoOrbit()end else pq=pq+1;if pq>=2 then cQ=true end end else cN="Adjusting Orbit - OrbitHeight: "..qf;pn=true;cD.cmdCruise(qh*3.6+1)local ql=cP-cj;if qm==nil then qm=pid.new(0.1,0,1*0.1)end;qm:inject(ql-c_*dr(utils.smoothstep(2000-ql,-2000,2000)^6*10,1,10))pk=dr(qm:get(),-60,60)end end else local qn=2.75;local qo=f3(ig(qg*qn))local qp=qo%50;if qp>0 then qo=qo-qp+50 end;aW=false;if cj<cP*0.8 then cN="Escaping planet gravity - OrbitHeight: "..qf;pk=utils.map(c_,200,0,-15,80)elseif cj>=cP*0.8 and cj<cP*1.15 then cN="Approaching orbital corridor - OrbitHeight: "..qf;qo=qo*0.75;pk=utils.map(c_,100,-100,-15,65)elseif cj>=cP*1.15 and cj<cP*1.5 then cN="Approaching orbital corridor - OrbitHeight: "..qf;qo=qo*0.75;if c_<0 or pn then pk=utils.map(cj,cP*1.5,cP*1.01,-30,0)else pk=utils.map(cj,cP*0.99,cP*1.5,0,30)end elseif cj>cP*1.5 then cN="Reentering orbital corridor - OrbitHeight: "..qf;pk=-65;local qq=utils.map(c_,-150,-400,1,0.55)qo=qo*qq end;cD.cmdCruise(bE(qo))end end;if pk~=nil then if qr==nil then qr=pid.new(1*0.01,0,5*0.1)end;local qs=pk-d5;qr:inject(qs)local qt=dr(qr:get(),-0.5,0.5)bT=qt end end;if aZ and ci==0 and not cd then local function qu(dn,fz)a.print(dn)aW=false;b8=false;aZ=false;qv=false;bb="Aligning"cD.cmdThrottle(0)bP=false;c0=dn;f_("apCom","AP")if fz or cd then if fz and gt~=nil and not cd then if not cj or cj==0 then return end;cP=cj;po=true end;cD.ToggleIntoOrbit()end end;local qw,qx=bf,false;if g9 and g9.planetname~="Space"then b7=true;if not qv then local qy=(g9.position-c4.center):normalize()local qz=qy:project_on_plane((c4.center-d0):normalize()):normalize()local qA=c4.center+qz*(c4.radius+gt)local qB=g9.position+(g9.position-c4.center):normalize()*(gt-c4:getAltitude(g9.position))if(d0-qA):len()<(d0-qB):len()then qw=qA else qw=qB;ba=0 end;bf=qw;cD.showWayPoint(c4,bf)qx=true;qv=true end;bc=0 elseif g9 and g9.planetname=="Space"then if not qv then bc=0;qx=true;b7=true;qv=true;qw=g9.position+(d0-g9.position):normalize()*R;bf=qw end elseif g9==nil then bc=0;if not qv then local qy=(d0+cX*100000-c4.center):normalize()local qz=qy:project_on_plane((c4.center-d0):normalize()):normalize()if qz:len()<1 then qy=(d0+cU*100000-c4.center):normalize()qz=qy:project_on_plane((c4.center-d0):normalize()):normalize()end;qw=c4.center+qz*(c4.radius+gt)bf=qw;qv=true;qx=true;b7=true;cD.showWayPoint(c4,bf)end end;oS=(vec3(qw)-d0):len()local lb,eO,eP=cx:getPlanetarySystem(0):castIntersections(d0,cX:normalize(),function(ex)if ex.noAtmosphericDensityAltitude>0 then return ex.radius+ex.noAtmosphericDensityAltitude else return ex.radius+ex.surfaceMaxAltitude*1.5 end end)local lc=eO;if eP~=nil and eO~=nil then lc=math.min(eP,eO)end;if lc~=nil and lc<oS and lb.name==c4.name then oS=lc end;local q8=true;local qC=(c4.center-(d0+vec3(cX):normalize()*oS)):len()-c4.radius;local l0=ij(qC)fY(gl,'{"label": "Projected Altitude", "value": "'..l0 ..'"}')local c2,c3;if not a_ then c2,c3=pa(cY)else c2,c3=pc(cY)end;if cY>50 and b6 then local pW=vec3(qw)-d0;local qD=dr(math.deg(pu(cT,cX:normalize(),pW:normalize()))*cY/500,-90,90)local qE=dr(math.deg(pu(cV,cX:normalize(),pW:normalize()))*cY/500,-90,90)if f3(qD)<20 and f3(qE)<20 then qD=qD*2;qE=qE*2 end;if f3(qD)<2 and f3(qE)<2 then qD=qD*2;qE=qE*2 end;local q1=-math.deg(pu(cT,cU,cX:normalize()))local q2=-math.deg(pu(cV,cU,cX:normalize()))if qF==nil then qF=pid.new(2*0.01,0,2*0.1)end;qF:inject(qE-q2)local qG=dr(qF:get(),-1,1)bT=bT+qG;if qH==nil then qH=pid.new(2*0.01,0,2*0.1)end;qH:inject(qD-q1)local qI=dr(qH:get(),-1,1)bU=bU+qI;qx=true;if f3(qD)>2 or f3(qE)>2 then if bb~="Adjusting Trajectory"then bb="Adjusting Trajectory"f_("apAdj","AP")end else if bb~="Accelerating"then bb="Accelerating"f_("apAcc","AP")end end elseif b6 and cY<=50 then pP((qw-d0):normalize())end;if qC<gt*1.5 then if g9 and g9.planetname=="Space"then ba=0 elseif g9==nil then dV,ba=cA(c4):escapeAndOrbitalSpeed(qC)end end;if aZ and not b6 and not b9 and not b8 then local lb,lc=cD.checkLOS((bf-d0):normalize())if c4.name~=iI.name then if lb~=nil and c4.name~=lb.name and lc<oS then c0="Collision with "..lb.name.." in "..ij(lc).."\nClear LOS to continue."ca=5;pJ=true else pJ=false;c0=""end end end;if not pJ then if not b9 and not b8 and not qx then q8=pP((qw-d0):normalize())elseif a_ and(b8 or b9)then q8=pP(-vec3(cX):normalize())end end;if b6 then if not bP then aW=false;cD.cmdThrottle(a0)bK=ig(a0,2)bP=true end;local oT=c.getThrottle()if u then oT=bK end;local qJ=99999;local o6=-vec3(b.getWorldAcceleration()):dot(cX:normalize())local qK=dr(cX:dot((qw-d0):normalize()),0,cY)if qK>0 or o6>0 then qJ=cy.computeTravelTime(qK,o6,oS-c2)end;if cW:len()>=_ or oT==0 and bP or a1/4>qJ then b6=false;if bb~="Cruising"then f_("apCru","AP")bb="Cruising"end;b9=true;cD.cmdThrottle(0)end;local qL=oS;if qL<=c2 or H and d9<=c2+10000 and d8 then if H and d9<=c2+10000 and d8 then if d9<pe and d9>2000 then cD.ToggleAutopilot()c0="Autopilot cancelled to prevent crossing PvP Line"aW=true;pe=d9 else pe=d9;return end end;b6=false;if bb~="Braking"then f_("apBrk","AP")bb="Braking"end;b8=true;cD.cmdThrottle(0)bP=false end elseif b8 then if bb~="Orbiting to Target"then aW=true;bX=1 end;if a_ then cD.cmdThrottle(1,true)end;local dV,qh=cA(c4):escapeAndOrbitalSpeed((d0-iI.center):len()-iI.radius)local pW;if g9 then pW=g9.position-d0 end;if g9 and g9.planetname=="Space"and cY<50 then if#pr>0 then aW=false;cD.ToggleAutopilot()cD.ToggleAutopilot()return end;qu("Autopilot complete, arrived at space location")aW=true;bX=1 elseif g9 and g9.planetname~="Space"and cY<=qh and(fz.apoapsis==nil or fz.periapsis==nil or fz.apoapsis.altitude<=0 or fz.periapsis.altitude<=0)then qu("Autopilot complete, commencing reentry")bf=g9.position;cd=true;cD.showWayPoint(c4,bf)elseif(g9 and g9.planetname~="Space"or g9==nil)and fz.periapsis~=nil and fz.periapsis.altitude>0 and fz.eccentricity<1 or bb=="Circularizing"then if bb~="Circularizing"then f_("apCir","AP")bb="Circularizing"end;if cY<=qh then if g9 then if cX:normalize():dot(pW:normalize())>0.4 then if bb~="Orbiting to Target"then f_("apOrb","OB")bb="Orbiting to Target"end;if not qM then aW=false;cD.showWayPoint(c4,g9.position)qM=true end else qu("Autopilot complete, proceeding with reentry")bf=g9.position;cd=true;cD.showWayPoint(c4,g9.position)qM=false end else qu("Autopilot completed, setting orbit",true)bX=0 end end elseif bb=="Circularizing"then qu("Autopilot complete, fixing Orbit",true)end elseif b9 then local qL=oS;if qL<=c2 or H and d9<=c2+10000 and d8 then if H and d9<=c2+10000 and d8 then if d9<pe and d9>2000 then cD.ToggleAutopilot()c0="Autopilot cancelled to prevent crossing PvP Line"aW=true;pe=d9 else pe=d9;return end end;b6=false;if bb~="Braking"then f_("apBrk","AP")bb="Braking"end;b8=true end;local oT=c.getThrottle()if u then oT=bK end;if oT>0 then b6=true;if bb~="Accelerating"then bb="Accelerating"f_("apAcc","AP")end;b9=false end else if q8 then if not b7 and g9==nil or not b7 and g9 and g9.planetname~="Space"then if not cd then bf=vec3(c4.center)+(gt+c4.radius)*cV;qN=cT;qO=cV end;b7=true elseif q8 and not pJ then b6=true;if bb~="Accelerating"then bb="Accelerating"f_("apAcc","AP")end;if not bP then cD.cmdThrottle(a0,true)bK=ig(a0,2)bP=true;aW=false end end end end elseif aZ and(g9~=nil and g9.planetname~="Space"and ci>0)then c0="Autopilot complete, starting reentry"f_("apCom","AP")bf=g9.position;aW=false;b8=false;aZ=false;qv=false;bb="Aligning"bX=0;cD.cmdThrottle(0)bP=false;aY=true;cd=true;cD.showWayPoint(c4,g9.position)end;if bZ then cI=true;local qE=0;local fB=d0+vec3(c.getMasterPlayerRelativePosition())local qP=fB-d0;local qQ=vec3(qP):project_on(cU):len()local qR=vec3(qP):project_on(cV):len()local cb=dt(qQ*qQ+qR*qR)pP(qP:normalize())local mj=40;local qS=cb<mj;local qT=100;local qU=dr((cb-mj)/2,10,qT)bT=0;local q8=f3(bU)<0.1;if q8 and cY<qU and not qS then aW=false;qE=-20 else aW=true;qE=0 end;local qV=0;if f3(qE-d5)>qV then if qW==nil then qW=pid.new(2*0.01,0,2*0.1)end;qW:inject(qE-d5)local qG=qW:get()bT=qG end end;if b0 or b1 or b3 or bl or bo~=nil then local qX=bp;if qX then qX=qX*dr(cY/100,0.1,1)*ci else qX=bn end;if ci<0.01 then qX=bn end;local qY=cU:project_on_plane(cZ):normalize():dot(cX)local qZ=vec3(b.getWorldAirFrictionAcceleration())local q_=qZ:len()*cl;if qY>100 then c2,c3=cy.computeDistanceAndTime(qY,100,cl,0,0,qX)local r0,r1=cy.computeDistanceAndTime(100,0,cl,0,0,qX*0.55)c2=c2+r0 else c2,c3=cy.computeDistanceAndTime(qY,0,cl,0,0,qX*0.55)end;local ql=b5-cj-c_;local r2=200+cY;if b3 or cd then r3=2000+cY end;local r4=1;if b2 then r4=dr(cY/100,0.1,1)end;local qE=(utils.smoothstep(ql,-r2,r2)-0.5)*2*O*r4;if not b3 and not cd and not bl and cU:dot(cX:normalize())<0.99 then qE=(utils.smoothstep(ql,-r2*dr(20-19*ci*10,1,20),r2*dr(20-19*ci*10,1,20))-0.5)*2*O*dr(2-ci*10,1,2)*r4 end;if not b0 then qE=0 end;if bo~=nil then if dc and not bu then qE=bo else bo=nil end end;cI=true;local r5=bT;if b3 then local r6=bE(cL)local r7,r8=cy.computeDistanceAndTime(cY,r6/3.6,cl,0,0,bn-iI.gravity*9.8*cl)r7=r7==-1 and 5000 or r7;local r9=cj-(iI.noAtmosphericDensityAltitude+r7)local ra=cj>iI.noAtmosphericDensityAltitude+r7*1.35;if ra then qE=P;if cY<=r6/3.6 and cY>r6/3.6-10 and f3(cX:normalize():dot(cU))>0.9 and not d4 then bO=false;cD.cmdThrottle(1)end elseif d4 and not ra and not ch then cD.cmdCruise(r6,true)end;if d4 then if cY>r6/3.6 and not ra then aW=true else aW=false end else aW=false end;if c_>0 then aW=true end;if not bQ then qE=-80;if ci>0.02 then c0="PARACHUTE DEPLOYED"b3=false;b1=true;qE=0;cI=p end elseif iI.noAtmosphericDensityAltitude>0 and ra then cI=true elseif not ra then if not ch and(d4 or id:getTargetSpeed(axisCommandId.longitudinal)~=r6)then cD.cmdCruise(r6)end;if cY<r6/3.6+1 then aW=false;bQ=false;b3=false;cI=true end end end;if cY>ix and not ce and not bl and not b1 and v then pP(vec3(cX))end;if da or(bl or ce)and bg>0 and ci>0.01 then local pW;if da then if type(da)=="table"then pW=da elseif da<3 and da>0 then pW=-cZ:cross(cX)*5000 elseif da>=3 then pW=cZ:cross(cX)*5000 elseif da<0 then pW=cX*25000 end elseif g9~=nil then pW=g9.position-d0 else pW=c4.center-d0 end;local qD=math.deg(pu(cZ:normalize(),cX,pW))*2;local mm=math.rad(f3(d6))if cY>aG and ci>0.01 then local rb=1000+cY;local rc=(utils.smoothstep(ql-c_*10,-rb,rb)-0.5)*2*O;local rd=dr(90-rc,0,180)cK=dr(qD*2,-rd,rd)local re=qD;qD=dr(dr(qD,-L*0.80,L*0.80)*math.cos(mm)+4*(d5-qE)*math.sin(math.rad(d6)),-L*0.80,L*0.80)local rf=1;if cK~=0 then rf=f3(mm/cK)end;rf=(90-dr(f3(cK-d6),0,90))/90;local rg=qE;if f3(d6)>90 then rg=-rg end;qE=rf*dr(dr(rg*math.cos(mm),-M*0.8,M*0.8)+f3(dr(f3(re)*math.sin(mm),-M*0.80,M*0.80)),-M*0.80,M*0.80)else cK=0;qD=dr(qD,-L*0.80,L*0.80)end;local rh=q1-qD;if da and f3(rh)<=0.0001 and(type(da)=="table"or type(da)~="table"and da<0 and f3(d6)<1)then if da==-2 then cD.ToggleAltitudeHold()end;da=nil;f_("180Off","BR")return end;if not cJ and cY>aG and ci>0.01 then if ri==nil then ri=pid.new(2*0.01,0,2*0.1)end;ri:inject(rh)local qI=dr(ri:get(),-1,1)bU=bU+qI elseif ch and cg>-1 or cY<aG then pP(pW)elseif cJ and ci>0.01 then if(q1<-L or q1>L)and ci>0.01 then pP(cX)end;if(q2<-M or q2>M)and ci>0.01 then qE=dr(d5-q2,d5-M*0.80,d5+M*0.80)end end;if g9~=nil and not ce then local q9=iI:getAltitude(g9.position)local r9=pW:project_on_plane(cZ):len()l7=true;if not ce and not b3 and r9<=c2 and(cX:project_on_plane(cZ):normalize():dot(pW:project_on_plane(cZ):normalize())>0.99 or lf=="Finalizing Approach")then lf="Finalizing Approach"if#pr>0 then cD.ToggleAutopilot()cD.ToggleAutopilot()return end;cD.cmdThrottle(0)if b0 then cD.ToggleAltitudeHold()bl=true end;aW=true elseif not b2 then aW=false end;if lf=="Finalizing Approach"and(qY<0.1 or r9<0.1 or rj~=nil and rj<r9)then if not d2 then f_("bklOn","BL")b1=true end;bl=false;lf="Proceeding to Waypoint"dd=false end;rj=r9 end elseif bl and ci==0 and b5>iI.noAtmosphericDensityAltitude and not(ce or b3)then if g9~=nil and c4.name==iI.name then local pW=g9.position-d0;local q9=iI:getAltitude(g9.position)local r9=dt(pW:len()^2-(cj-q9)^2)local qX=bp;if qX then c2,c3=cy.computeDistanceAndTime(cY,0,cl,0,0,qX/2)l7=true;if r9<=c2+cY*q0/2 and cX:project_on_plane(cZ):normalize():dot(pW:project_on_plane(cZ):normalize())>0.99 then if iI.hasAtmosphere then aW=false;aY=false;bQ=true;cd=false;cf=true;aZ=false;cD.BeginReentry()end end;rj=r9 end end end;if ci==0 and(b0 and b5>iI.noAtmosphericDensityAltitude)and not(ce or bu or b3)then if not cQ and not bu then cP=b5;po=true;if bl then cO.VectorToTarget=true end;cD.ToggleIntoOrbit()bl=false;pm=true end end;if cJ and ci>0.01 and cg==-1 and cY>aG and lf~="Finalizing Approach"then pP(cX)qE=dr(d5-q2,d5-M*0.80,d5+M*0.80)end;bT=r5;local pD=-1;if b1 then qE=0;local rk=false;local rl=30;if cz~=nil and cz>0 then local rm=dr(ci,0.4,2)local qX=bp*dr(cY/100,0.1,1)*rm;local rn=cz*rm+qX-gC;local ro=qX/2-gC;local rp=cY-dt(f3(ro/2)*20/(0.5*cl))*utils.sign(ro)if rp<0 then rp=0 end;local rq;if cY>100 then local rr,dV=cy.computeDistanceAndTime(cY,100,cl,0,0,qX)local rs,dV=cy.computeDistanceAndTime(100,0,cl,0,0,dt(qX))rq=rr+rs else rq=cy.computeDistanceAndTime(cY,0,cl,0,0,dt(qX))end;if rq<20 then aW=false else local rt=0;if rp>100 then local ru,dV=cy.computeDistanceAndTime(rp,100,cl,0,0,rn)local rv,dV=cy.computeDistanceAndTime(100,0,cl,0,0,cz*rm+dt(qX)-gC)rt=ru+rv else rt,dV=cy.computeDistanceAndTime(rp,0,cl,0,0,cz*rm+dt(qX)-gC)end;rt=(rt+15+cY*q0)*1.1;local rw=g9~=nil and iI:getAltitude(g9.position)>0 and g9.safe;if rw then local q9=iI:getAltitude(g9.position)local rx=cj-q9-100;local pW=g9.position-d0;local ry=dt(pW:len()^2-(cj-q9)^2)if ry>100 then rw=false elseif rx<=rt or rt==-1 then aW=true;rk=true else aW=false;rk=true end end;if not rw and t then if rt>=rl then aW=true else aW=false end;rk=true end end end;if not d4 then cD.cmdThrottle(0)end;id:setTargetGroundAltitude(500)id:activateGroundEngineAltitudeStabilization(500)bw=true;pD=cg;if pD>-1 then cI=p;if cY<1 or cX:normalize():dot(cZ)<0 then b1=false;b0=false;bh=true;if bR then d.control.extendLandingGears()f_("grOut","LG",1)end;id:setTargetGroundAltitude(Y)c7=0;aW=true else aW=true end elseif l7 and cX:normalize():dot(-gv)<0.999 then aW=true elseif c_<-N and not rk then aW=true elseif not rk then aW=false end end;if b2 or ce then local lb,eP,eO;if bf~=nil then lb,eP,eO=cx:getPlanetarySystem(0):castIntersections(d0,(bf-d0):normalize(),function(ex)return ex.radius+ex.noAtmosphericDensityAltitude end)end;if d2 then if cj>=b5-50 then b2=false;if not aZ and not bl then aW=true;cD.cmdThrottle(0)end else b5=antigrav.getBaseAltitude()end elseif f3(qE)<15 and cj/b5>0.75 then b2=false;if not ce then if d4 and not u then d.control.cancelCurrentControlMasterMode()end elseif ce and cY<ix then aZ=true;ce=false;b0=false;b2=false;cD.cmdThrottle(0)elseif ce then cD.cmdThrottle(0)aW=true end elseif ce and ci==0 and c4~=nil and(lb==nil or lb.name==c4.name)then aZ=true;ce=false;b0=false;b2=false;if not d4 then cD.cmdThrottle(0)end;b6=true end end;local rz=cg>-1;local rA=d5;if(bl or ce or da)and not rz and cY>aG and ci>0.01 then local mm=math.rad(f3(d6))rA=d5*f3(math.cos(mm))+q2*math.sin(mm)end;local rB=dr(qE-rA,-M*0.80,M*0.80)if ci<0.01 and bl then rB=dr(qE-rA,-85,O)elseif ci<0.01 then rB=dr(qE-rA,-O,O)end;if f3(d6)<5 or bl or da or b1 or rz or b0 then if qW==nil then qW=pid.new(5*0.01,0,5*0.1)end;qW:inject(rB)local qG=qW:get()bT=bT+qG end end;if antigrav~=nil and(antigrav and not q and cj<200000)then if bq==nil or bq<1000 then bq=1000 end;if rC~=bq then rC=bq;antigrav.setBaseAltitude(rC)end end end;function p9.ToggleIntoOrbit()cQ=false;pk=nil;pl=nil;pq=0;if ci==0 then if bu then f_("orOff","AP")bu=false;pm=false;pp=nil;cI=p;if b0 then b0=false;b2=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;po=false elseif dc then f_("orOn","AP")bu=true;cI=true;if pp==nil then pp=iI end;if b0 then b0=false;b2=false end else c0="Unable to engage auto-orbit, not near a planet"end else bu=false;pm=false;pp=nil;cI=p;if b0 then b0=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;po=false end end;function p9.ToggleVerticalTakeoff()b0=false;if b4 then l7=true;b3=false;b2=false;b1=true;cI=true;c7=0;if ch and cg==-1 then b1=false;b0=true;c7=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cD.cmdCruise(bE(cL))end else cQ=false;bh=false;d.control.retractLandingGears()id:setTargetGroundAltitude(X)aW=true end;b4=not b4 end;function p9.checkLOS(pQ)local lb,eO,eP=cx:getPlanetarySystem(0):castIntersections(d0,pQ,function(ex)if ex.noAtmosphericDensityAltitude>0 then return ex.radius+ex.noAtmosphericDensityAltitude else return ex.radius+ex.surfaceMaxAltitude*1.5 end end)local lc=eO;if eP~=nil and eO~=nil then lc=math.min(eP,eO)end;if lc~=nil then return lb,lc else return nil,nil end end;function p9.ToggleAutopilot()local function rD(bs)dd=false;bl=not bl;if bl then a_=false;if not b0 and not bs then cD.ToggleAltitudeHold()end end;lf="Proceeding to Waypoint"end;local rE=false;if bG-pj<1.5 and ci>0 then if not cS then c0="No space engines detected, Orbital Hop not supported"return end;if iI.hasAtmosphere then if ci>0 then b5=iI.noAtmosphericDensityAltitude+T;f_("orH","OH")end;pj=-1;if aZ or bl or bu then return end end else pj=bG end;qv=false;if(bg>0 or#pr>0)and not aZ and not bl and not ce and not bu then if 0.5*d:maxForceForward()/b.g()<cl then c0="WARNING: Heavy Loads may affect autopilot performance."ca=5 end;if#pr>0 and not cf then bg=pr[1]cC.UpdateAutopilotTarget()table.remove(pr,1)c0="Route Autopilot in Progress"local pW=g9.position-d0;local r9=pW:project_on_plane(cZ):len()if r9>50000 and g9.planetname==iI.name then rE=true end end;cC.UpdateAutopilotTarget()cD.showWayPoint(c4,bf)if g9~=nil then bo=nil;bs=g9.planetname=="Space"if bs then f_("apSpc","AP")if ci~=0 then ce=true;cD.ToggleAltitudeHold()else aZ=true end elseif iI.name==g9.planetname then l7=true;if ci>0 then if not bl then f_("vtt","AP")rD(bs)if rE then b5=iI.noAtmosphericDensityAltitude+T end end else f_("apOn","AP")if not(c4.name==iI.name and cj<gt*1.5)then cQ=false;aZ=true elseif not ch then if bu then cD.ToggleIntoOrbit()end;cP=iI.noAtmosphericDensityAltitude+T;po=true;cO.AutopilotAlign=true;cO.VectorToTarget=true;pm=false;if not bu then cD.ToggleIntoOrbit()end end end else f_("apP","AP")aX=false;aY=false;if ci~=0 then ce=true;cD.ToggleAltitudeHold()else aZ=true end end elseif ci==0 then if g9==nil and(c4.name==iI.name and dc)and not bu then qM=false;cQ=false;pm=false;cD.ToggleIntoOrbit()else f_("apP","AP")aZ=true;aX=false;aY=false;b7=false;bZ=false;b0=false;b1=false;b3=false;b2=false;bP=false;bo=nil;qM=false end else f_("apP","AP")ce=true;cD.ToggleAltitudeHold()end else f_("apOff","AP")cD.ResetAutopilots(1)end end;function p9.routeWP(rF,rG,rH)if rH then if rH==1 then pr={}pr=ih(pr,bz)if#pr>0 then c0="Route Loaded"else c0="No Saved Route found on Databank"end;return pr else bz={}bz=ih(bz,pr)c0="Route Saved"p8()return end end;if rF then return pr end;if rG then pr={}c0="Current Route Cleared"else pr[#pr+1]=bg;c0="Added "..g9.name.." to route. "end;return pr end;function p9.cmdThrottle(dR,rI)if id:getAxisCommandType(0)~=axisCommandType.byThrottle and not rI then d.control.cancelCurrentControlMasterMode()end;id:setThrottleCommand(axisCommandId.longitudinal,dR)bK=dr(ig(dR*100,0)/100,-1,1)d3=nil end;function p9.cmdCruise(dR,rI)if id:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rI then d.control.cancelCurrentControlMasterMode()end;id:setTargetSpeedCommand(axisCommandId.longitudinal,dR)d3=dR end;function p9.ToggleLockPitch()if bo==nil then f_("lkPOn","LP")if not b_ then bo=d5 else bo=Q end;b2=false;b0=false;b1=false else f_("lkPOff","LP")bo=nil end end;function p9.ToggleAltitudeHold()if bG-pi<1.5 then if iI.hasAtmosphere then if ci>0 then b5=iI.spaceEngineMinAltitude-0.01*iI.noAtmosphericDensityAltitude;f_("11","EP")else if dc then b5=iI.noAtmosphericDensityAltitude+T;cP=b5;po=true;if not bu then cD.ToggleIntoOrbit()end;pm=true end end;pi=-1;if b0 or bu or b4 then return end end else pi=bG end;if dc and ci==0 then cP=cj;po=true;pm=true;cD.ToggleIntoOrbit()if bu then pi=bG else pi=0 end;return end;b0=not b0;b1=false;b3=false;if b0 then aZ=false;aY=false;aX=false;bZ=false;cI=true;bo=nil;cQ=false;if cg~=-1 and cY<20 then f_("lfs","LS")b2=true;if pi>-1 then b5=cj+W end;bh=false;d.control.retractLandingGears()aW=true;id:setTargetGroundAltitude(X)if aV and d1 then cD.ToggleVerticalTakeoff()end else f_("altOn","AH")b2=false;if pi>-1 then if dc then b5=cj end end;if b4 then cD.ToggleVerticalTakeoff()end end;if ce then b5=100000 end else f_("altOff","AH")if bu then cD.ToggleIntoOrbit()end;if b4 then cD.ToggleVerticalTakeoff()end;cI=p;b2=false;bl=false;pi=0 end end;function p9.ResetAutopilots(p9)if p9 then ce=false;aZ=false;b7=false;bP=false;b5=cj;qv=false end;bl=false;b2=false;b3=false;aY=false;b1=false;rJ=false;da=nil;if not d2 then b0=false;bo=nil end;if b4 then cD.ToggleVerticalTakeoff()end;if bu then cD.ToggleIntoOrbit()end;cI=p;cd=false;cf=false;c7=0 end;function p9.BrakeToggle()aW=not aW;if b1 then b1=false;cI=p end;if aW then f_("bkOn","B",1)cD.ResetAutopilots()else f_("bkOff","B",1)end end;function p9.BeginReentry()if b3 then c0="Re-Entry cancelled"f_("reOff","RE")b3=false;cI=p;b0=false elseif not iI.hasAtmosphere then c0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ca=5 elseif not bQ then b3=true;if id:getAxisCommandType(0)~=rK.cruise then d.control.cancelCurrentControlMasterMode()end;cI=true;aW=false;c0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cL;f_("par","RE")else b3=true;b0=true;cI=true;aW=false;b5=iI.surfaceMaxAltitude+Z;if b5>iI.spaceEngineMinAltitude then b5=iI.spaceEngineMinAltitude-0.01*iI.noAtmosphericDensityAltitude end;local rL=ij(b5)c0="Beginning Re-entry.  Target speed: "..cL.." Target Altitude: "..rL;f_("glide","RE")cD.cmdCruise(bE(cL))end;b2=false end;function p9.ToggleAntigrav()if antigrav and not q then if d2 then f_("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bq==nil then bq=cj end;if bq<1000 then bq=1000 end;f_("aggOn","AG")antigrav.activate()antigrav.show()end end end;function p9.changeSpd(rM)local rN=1;if rM then rN=-1 end;if not b_ then if u and not oF and cm then local rO=bK;bK=ig(dr(bK+rN*az/100,-1,1),2)if bK>=0 and rO<0 then bK=0;cm=false end elseif oF then if ci>0 or b3 then cL=dr(cL+rN*az,0,U)elseif aZ then _=dr(_+rN*az/3.6*100,0,8333.00)end else id:updateCommandFromActionStart(axisCommandId.longitudinal,rN*az)end else if aZ or bl or ce or bu then dg=dg+1*rN*-1;if dg>#d7 then dg=1 end;if dg<1 then dg=#d7 end else if not rM then rN=1 else rN=nil end;cC.adjustAutopilotTargetIndex(rN)end end end;function p9.TenthTick()local function rP(gC,rQ)if gC==nil then gC=b.g()end;gC=ig(gC,5)if rQ~=nil and rQ or(ps==nil or ps~=gC)then local fv=cW:len()local rR=ia(c.getData()).maxBrake;if rR~=nil and rR>0 and ch then rR=rR/dr(fv/100,0.1,1)rR=rR/ci;if ci>0.10 then if bp then bp=(bp+rR)/2 else bp=rR end end end;if rR~=nil and rR>0 then bn=rR end;ps=gC end end;rP(nil,true)if d3~=nil then if id:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or id:getTargetSpeed(axisCommandId.longitudinal)~=d3 then cD.cmdCruise(d3)else d3=nil end end end;function p9.SatNavTick()if not r then return end;pt=dbHud_1.getStringValue("SPBAutopilotTargetName")if pt~=nil and pt~=""and pt~="SatNavNotChanged"then local dL=ia(dbHud_1.getStringValue("SavedLocations"))if dL~=nil then bk=dL;local gx=-1;local gD;for dQ,dC in pairs(bk)do if dC.name and dC.name=="SatNav Location"then gx=dQ;break end end;if gx~=-1 then gD=bk[gx]gx=-1;for dQ,dC in pairs(e[0])do if dC.name and dC.name=="SatNav Location"then gx=dQ;break end end;if gx>-1 then e[0][gx]=gD end;cC.UpdateAtlasLocationsList()c0=gD.name.." position updated"end end;for K=1,#d7 do if d7[K].name==pt then bg=K;a.print("Index = "..bg.." "..d7[K].name)cC.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;cg=py()return p9 end;local function rS(d,b,c,a,e,vBooster,hover,antigrav,i9,dbHud_2,gyro,ic,id,ie,rT,gI,ig,e9,ds,dr,f_,ii)local rU={}local rV=true;local rW=5;local rX=5;local rY=rW;local rZ=rX;local r_=bG;function rU.startControl(s0)local function s1(rM)local rN=1;local function s2(s3,rM)local s4={iI.surfaceMaxAltitude+100,iI.spaceEngineMinAltitude-0.01*iI.noAtmosphericDensityAltitude,iI.noAtmosphericDensityAltitude+T,iI.radius*(S-1)+iI.noAtmosphericDensityAltitude}local s5=s3;for dV,dC in ipairs(s4)do if rM and s5>dC then s3=dC elseif s3<dC and not rM then s3=dC;break end end;return s3 end;if rM then rN=-1 end;if not q and d2 then if b_ and rM then bq=1000 elseif bq~=nil then bq=bq+rN*rX;if bq<1000 then bq=1000 end;if b0 and bq<b5+10 and bq>b5-10 then b5=bq end else bq=rC+rN*100 end elseif b0 or b4 or bu then if bu then if b_ then cP=s2(cP,rM)else cP=cP+rN*rW end;if cP<iI.noAtmosphericDensityAltitude then cP=iI.noAtmosphericDensityAltitude end else if b_ and ch then b5=s2(b5,rM)else b5=b5+rN*rW end end else id:updateTargetGroundAltitudeFromActionStart(rN*1.0)end end;local function s6(s7)if not ch then c0="Flight Assist in Atmo only"return end;local dz=type(s7)if da==nil then if dz=="table"then if aZ or bl then cD.ToggleAutopilot()end;f_("180On","BR")elseif s7==1 then f_("bnkLft","BR")else f_("bnkRht","BR")end;if not b0 and not aZ and not bl then cD.ToggleAltitudeHold()if dz~="table"then s7=s7+1 end end;da=s7 else f_("180Off","BR")da=nil end end;if s0=="gear"then bh=not bh;if bh then bl=false;bo=nil;cD.cmdThrottle(0)if vBooster or hover then if ch and cg==-1 then f_("bklOn","BL")l7=true;b3=false;b2=false;b4=false;b0=false;b1=true;cI=true;bh=false else if bR then f_("grOut","LG",1)d.control.extendLandingGears()end;id:setTargetGroundAltitude(Y)if ch then aW=true end end end;if bR and not b1 and not(vBooster or hover)then f_("grOut","LG",1)d.control.extendLandingGears()end else if bR then f_("grIn","LG",1)d.control.retractLandingGears()end;id:setTargetGroundAltitude(X)end elseif s0=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif s0=="forward"then bS=bS-1 elseif s0=="backward"then if oF then s6(-cX*5000)else bS=bS+1 end elseif s0=="left"then if oF then s6(1)else bV=bV-1 end elseif s0=="right"then if oF then s6(3)else bV=bV+1 end elseif s0=="yawright"then bW=bW-1 elseif s0=="yawleft"then bW=bW+1 elseif s0=="straferight"then id:updateCommandFromActionStart(axisCommandId.lateral,1.0)bt=1 elseif s0=="strafeleft"then id:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bt=-1 elseif s0=="up"then c7=c7+1;id:deactivateGroundEngineAltitudeStabilization()id:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif s0=="down"then c7=c7-1;id:deactivateGroundEngineAltitudeStabilization()id:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif s0=="groundaltitudeup"then s1()elseif s0=="groundaltitudedown"then s1(true)elseif s0=="option1"then s8=false;if oF and b_ then local s9=""for K=1,#dh do s9=s9 .."| Name: "..a.getPlayerName(dh[K]).." Mass: "..ig(b.getBoardedPlayerMass(dh[K])/1000,1).."t "end;a.print("Onboard: "..s9)return end;cC.adjustAutopilotTargetIndex()elseif s0=="option2"then s8=false;if oF and b_ then for K=1,#dh do b.forceDeboard(dh[K])end;c0="Deboarded All Passengers"return end;cC.adjustAutopilotTargetIndex(1)elseif s0=="option3"then local function sa()rV=not rV;if not rV then f_("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(sb,atmofueltank_size,"Atmo Fuel","fuel_container")sc=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(sd,spacefueltank_size,"Space Fuel","fuel_container")se=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(sf,rocketfueltank_size,"Rocket Fuel","fuel_container")sg=_autoconf.panels[_autoconf.panels_size]end;sh=a.createWidgetPanel("Docking")si=a.createWidget(sh,"parenting")a.addDataToWidget(c.getDataId(),si)sj=a.createWidgetPanel("Core combat stress")sk=a.createWidget(sj,"core_stress")a.addDataToWidget(b.getDataId(),sk)if i9~=nil then i9.show()end else f_("hud","DH")c.hide()b.hide()if sc~=nil then gI(sc)sc=nil end;if sh~=nil then gI(sh)sh=nil end;if sj~=nil then gI(sj)sj=nil end;if se~=nil then gI(se)se=nil end;if sg~=nil then gI(sg)sg=nil end;if i9~=nil then i9.hide()end end end;s8=false;if oF and b_ then local s9=""for K=1,#di do s9=s9 .."| ID: "..di[K].." Mass: "..ig(b.getDockedConstructMass(di[K])/1000,1).."t "end;a.print("Docked Ships: "..s9)return end;if y then if x then x=false else x=true end end;sa()elseif s0=="option4"then s8=false;if oF and b_ then for K=1,#di do b.forceUndock(di[K])end;c0="Undocked all ships"return end;da=nil;cD.ToggleAutopilot()elseif s0=="option5"then s8=false;cD.ToggleLockPitch()elseif s0=="option6"then s8=false;if oF and b_ then if i9 then local sl=i9.getVentingCooldown()if sl>0 then c0="Cannot vent again for "..sl.." seconds"return end;if i9.getShieldHitpoints()<i9.getMaxShieldHitpoints()then i9.startVenting()c0="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c0="Shields already at max hitpoints"end;return else c0="No shield found"return end end;cD.ToggleAltitudeHold()elseif s0=="option7"then s8=false;if oF and b_ then if i9 then i9.toggle()return else c0="No shield found"return end end;F=not F;if F then c0="Collision System Enabled"else c0="Collision System Secured"end elseif s0=="option8"then s8=false;if oF and b_ then if bg>0 and g9~=nil then cD.routeWP()else c0="Select a saved wp on IPH to add to or remove from route"end;return end;bw=not bw;if not bw then c0="DeCoupled Mode - Ground Stabilization off"id:deactivateGroundEngineAltitudeStabilization()f_("gsOff","GS")else c0="Coupled Mode - Ground Stabilization on"id:activateGroundEngineAltitudeStabilization(sm)d:setEngineForceCommand('hover',vec3(),1)f_("gsOn","GS")end elseif s0=="option9"then s8=false;if oF and b_ then id:resetCommand(axisCommandId.longitudinal)id:resetCommand(axisCommandId.lateral)id:resetCommand(axisCommandId.vertical)cD.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cn=gyro.getState()==1;if cn then f_("gyOn","GA")else f_("gyOff","GA")end else c0="No gyro found"end elseif s0=="lshift"then df=false;if oF then b_=true end;if ie()==1 then b_=true;bd=ie()rT(1)elseif ic()==1 and z then b_=true;cH=false;cG=false end elseif s0=="brake"then if aU or oF then cD.BrakeToggle()elseif not aW then cD.BrakeToggle()else aW=true end elseif s0=="lalt"then s8=true;oF=true;if ic()==0 and not i and g=="keyboard"then rT(1)end elseif s0=="booster"then if n then d:toggleBoosters()elseif not c1 then if not sn then d:toggleBoosters()sn=true end;c1=true else if sn then d:toggleBoosters()sn=false end;c1=false end elseif s0=="stopengines"then local function so()if bG-r_<1.5 then f_("clear","CA")b6=false;b8=false;b9=false;aZ=false;b7=false;bb="Aligning"aX=false;aY=false;da=nil;b0=false;b3=false;b1=false;aW=false;b2=false;b4=false;bZ=false;bP=false;cd=false;ce=false;bQ=false;cI=p;bl=false;a_=false;cn=false;bo=nil;bu=false end end;so()r_=bG;if id:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then id:resetCommand(axisCommandId.longitudinal)cD.cmdThrottle(0)else cD.cmdThrottle(100)end else if id:getTargetSpeed(axisCommandId.longitudinal)~=0 then id:resetCommand(axisCommandId.longitudinal)else if ch then cD.cmdCruise(U)else cD.cmdCruise(_*3.6)end end end elseif s0=="speedup"then cD.changeSpd()elseif s0=="speeddown"then cD.changeSpd(true)elseif s0=="antigravity"and not q then if antigrav~=nil then cD.ToggleAntigrav()else c0="No antigrav found"end end end;function rU.stopControl(s0)local function sp()if not q and d2 then rZ=rX end;if b0 or b4 or bu then rY=rW end end;if s0=="forward"then bS=0 elseif s0=="backward"then bS=0 elseif s0=="left"then if da then if da==2 then da=-2 else da=-1 end end;bV=0 elseif s0=="right"then if da then if da==4 then da=-2 else da=-1 end end;bV=0 elseif s0=="yawright"then bW=0 elseif s0=="yawleft"then bW=0 elseif s0=="straferight"then id:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bt=0 elseif s0=="strafeleft"then id:updateCommandFromActionStop(axisCommandId.lateral,1.0)bt=0 elseif s0=="up"then c7=0;id:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bw then id:activateGroundEngineAltitudeStabilization(sm)d:setEngineForceCommand('hover',vec3(),1)end elseif s0=="down"then c7=0;id:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bw then id:activateGroundEngineAltitudeStabilization(sm)d:setEngineForceCommand('hover',vec3(),1)end elseif s0=="groundaltitudeup"then sp()s8=false elseif s0=="groundaltitudedown"then sp()s8=false elseif s0=="lshift"then if ie()==1 then c8=0;c9=0;rT(bd)elseif ic()==1 and z then cH=false;cG=false end;b_=false elseif s0=="brake"then if not aU and not oF then if aW then cD.BrakeToggle()else aW=false end end elseif s0=="lalt"then if ic()==0 and i then if s8 then if ie()==1 then rT(0)else rT(1)end else s8=true end elseif ic()==0 and not i and g=="keyboard"then rT(0)end;oF=false end end;function rU.loopControl(s0)local function sq(rM)local rN=1;if rM then rN=-1 end;if not q and d2 then if bq~=nil then bq=bq+rN*rZ;if bq<1000 then bq=1000 end;if b0 and bq<b5+10 and bq>b5-10 then b5=bq end;rZ=dr(rZ*1.05,rX,50)aW=false else bq=rC+rN*100;aW=false end elseif b0 or b4 or bu then if bu then cP=cP+rN*rY;if cP<iI.noAtmosphericDensityAltitude then cP=iI.noAtmosphericDensityAltitude end else b5=b5+rN*rY end;rY=dr(rY*1.05,rW,50)else id:updateTargetGroundAltitudeFromActionLoop(rN*1.0)end end;local function sr(rM)local rN=1;if rM then rN=-1 end;if not b_ then if u and not oF then bK=dr(bK+rN*aA/100,-1,1)else id:updateCommandFromActionLoop(axisCommandId.longitudinal,rN*aA)end end end;if s0=="groundaltitudeup"then if not b_ then sq()end elseif s0=="groundaltitudedown"then if not b_ then sq(true)end elseif s0=="speedup"then sr()elseif s0=="speeddown"then sr(true)end end;function rU.inputTextControl(rL)local function ss(st,fB,gA)local function su(fB)local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ='::pos{'..dI..','..dI..','..dI..','..dI..','..dI..'}'local dZ,d_,e6,e7,e8=e9(fB,dJ)if dZ=="0"and d_=="0"then return vec3(ds(e6),ds(e7),ds(e8))end;e7=math.rad(e7)e6=math.rad(e6)local iI=e[ds(dZ)][ds(d_)]local e_=math.cos(e6)local sv=vec3(e_*math.cos(e7),e_*math.sin(e7),math.sin(e6))return iI.center+(iI.radius+e8)*sv end;local g1=su(fB)return cC.AddNewLocation(st,g1,gA)end;local K;local sw,sx=nil,nil;local sy="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp"K=string.find(rL," ")sw=rL;if K~=nil then sw=string.sub(rL,0,K-1)sx=string.sub(rL,K+1)end;if sw=="/help"or sw=="/commands"then for ob in string.gmatch(sy,"([^\n]+)")do a.print(ob)end;return elseif sw=="/setname"then if sx==nil or sx==""then c0="Usage: ah-setname Newname"return end;if bg>0 and g9~=nil then cC.UpdatePosition(sx)else c0="Select a saved target to rename first"end elseif i9 and sw=="/resist"then if not i9 then c0="No shield found"return elseif sx==nil or i9.getResistancesCooldown()>0 then c0="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ=dI..', '..dI..', '..dI..', '..dI;local sz,sA,sB,sC=e9(sx,dJ)if sC==nil or sz+sA+sB+sC>0.6 then c0="Improperly formatted or total exceeds 0.6"return end;if i9.setResistances(sz,sA,sB,sC)==1 then c0="Shield Resistances set"else c0="Resistance setting failed."end elseif sw=="/addlocation"or string.find(rL,"::pos")~=nil then local gA=false;local st="0-Temp"if sx==nil or sx==""then sx=sw;gA=true end;K=string.find(sx,"::")if not gA then st=string.sub(sx,1,K-2)end;local fB=string.sub(sx,K)ss(st,fB,gA)elseif sw=="/agg"then if sx==nil or sx==""then c0="Usage: /agg targetheight"return end;sx=ds(sx)if sx<1000 then sx=1000 end;bq=sx;c0="AGG Target Height set to "..sx elseif sw=="/G"then if sx==nil or sx==""then c0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if sx=="dump"then for dQ,dC in pairs(ii())do if type(dC.get())=="boolean"then if dC.get()==true then a.print(dQ.." true")else a.print(dQ.." false")end elseif dC.get()==nil then a.print(dQ.." nil")else a.print(dQ.." "..dC.get())end end;return end;K=string.find(sx," ")local sD=string.sub(sx,0,K-1)local sE=string.sub(sx,K+1)for dQ,dC in pairs(ii())do if dQ==sD then c0="Variable "..sD.." changed to "..sE;local sF=type(dC.get())if sF=="number"then sE=ds(sE)if dQ=="AtmoSpeedLimit"then cL=sE end elseif sF=="boolean"then if string.lower(sE)=="true"then sE=true else sE=false end end;dC.set(sE)return end end;c0="No such global variable: "..sD elseif sw=="/deletewp"then if bg>0 and g9~=nil then cC.ClearCurrentPosition()else c0="Select a custom wp to delete first in IPH"end elseif sw=="/copydatabank"then if dbHud_2 then p8(true)else c0="Spare Databank required to copy databank"end elseif sw=="/iphWP"then if bg>0 then a.print(cD.showWayPoint(c4,bf,true))c0="::pos waypoint shown in lua chat"else c0="No target selected in IPH"end end end;function rU.tagTick()if bx=="Off"then bx="All"elseif bx=="All"then bx="Longitude"elseif bx=="Longitude"then bx="Lateral"elseif bx=="Lateral"then bx="Vertical"else bx="Off"end;c0="Extra Engine Tags: "..bx;c.stopTimer("tagTick")end;return rU end;local function sG(d,b,c,a,library,e,vBooster,hover,p7,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,i9,gyro,warpdrive,sH)local sI={}local dq=string.format;local ia=json.decode;local sJ=json.encode;local sK=b.getElementMaxHitPointsById;local ib=b.getElementMassById;local ic=d.control.isRemoteControlled;local e9=string.match;local gI=a.destroyWidgetPanel;local fY=a.updateData;local fZ=a.addDataToWidget;local rT=a.lockView;local ie=a.isViewLocked;local dt=math.sqrt;local ds=tonumber;local f3=math.abs;local bE=math.floor;local bF=c.getAtmosphereDensity;local eZ=math.atan;local bD=a.getTime;local dr=utils.clamp;local id=d.axisCommandManager;local sL=Y;local gK=13;local sM=b.getElementIdList()local sN={}local sO=0;local function du(eH,eI)if eH==0 then return f3(eI)<1e-09 end;if eI==0 then return f3(eH)<1e-09 end;return f3(eH-eI)<math.max(f3(eH),f3(eI))*dH end;local function ig(dI,sP)local rN=10^(sP or 0)return bE(dI*rN+0.5)/rN end;local function ih(sQ,sR)for dQ,dC in pairs(sR)do if type(dQ)=="string"then sQ[dQ]=dC else sQ[#sQ+1]=sR[dQ]end end;return sQ end;local function ii(sS)local sT={}if not sS then ih(sT,J)ih(sT,a7)ih(sT,ay)ih(sT,aT)return sT elseif sS=="boolean"then return J elseif sS=="handling"then return a7 elseif sS=="hud"then return ay elseif sS=="physics"then return aT end end;local function p8(sU)local function sV(sW)for dQ,dC in pairs(sW)do dbHud_1.setStringValue(dQ,sJ(dC.get()))if sU and dbHud_2 then dbHud_2.setStringValue(dQ,sJ(dC.get()))end end end;if dbHud_1 then sV(bA)sV(ii())a.print("Saved Variables to Datacore")if sU and dbHud_2 then c0="Databank copied.  Remove copy when ready."end end end;local function f_(sX,sY,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..sX.."|"..sY.."|"..ax)else a.logInfo("sound_notification|audiopacks/"..h.."/"..sX.."|"..sY.."|"..ax)end else a.logInfo("sound_q|audiopacks/"..h.."/"..sX.."|"..sY.."|"..ax)end end;local function gJ(hh,hi,rL,jl,sZ)if jl==nil then jl=""end;if sZ==nil then sZ=""end;return dq([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jl,hh,hi,sZ,rL)end;local function ij(cb,s_)local t0=cb>100000;if s_==nil then s_=1 end;if t0 then return ig(cb/1000/200,s_).."SU"elseif cb<1000 then return ig(cb,s_).."M"else return ig(cb/1000,s_).."KM"end end;local function ik(t1)local t2=0;local t3=0;local t4=0;if t1<60 then t1=bE(t1)elseif t1<3600 then t2=bE(t1/60)t1=bE(t1%60)elseif t1<86400 then t3=bE(t1/3600)t2=bE(t1%3600/60)else t4=bE(t1/86400)t3=bE(t1%86400/3600)end;if t4>0 then return t4 .."d "..t3 .."h "elseif t3>0 then return t3 .."h "..t2 .."m "elseif t2>0 then return t2 .."m "..t1 .."s"elseif t1>0 then return t1 .."s"else return"0s"end end;function sI.onStart()local t5=false;local function t6()local function t7(t8)local t9=dbHud_1.hasKey;for dQ,dC in pairs(t8)do if t9(dQ)then local dL=ia(dbHud_1.getStringValue(dQ))if dL~=nil then dC.set(dL)t5=true end end end end;if dbHud_1 then if not f then t7(ii())coroutine.yield()t7(bA)else t7(bA)c0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ca=5;t5=false end;coroutine.yield()if t5 then c0="Loaded Saved Variables"cr=a8;cs=a9;aU=j;g=string.lower(g)cI=p;cL=U;co=[[rgb(]]..bE(bH+0.5)..","..bE(bJ+0.5)..","..bE(bI+0.5)..[[)]]cp=[[rgb(]]..bE(bH*0.9+0.5)..","..bE(bJ*0.9+0.5)..","..bE(bI*0.9+0.5)..[[)]]elseif not f then c0="No Saved Variables Found - Exit HUD to save settings"end;if by<1.500 then if T<2000 then c0="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;by=VERSION_NUMBER else c0="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if br+180<bG then bp=0 end;br=bG;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ca=7 end;if antigrav and not q then if bq==nil then bq=cj end;antigrav.setBaseAltitude(bq)end;lf="Proceeding to Waypoint"end;local function ta()local function tb(tc,td)if tc>td then td=tc end;local te,tf=0,0;if a5>0 then te=a5*0.05 end;if a6>0 then tf=a6*0.05 end;td=td*(1-(te+tf))return td end;local tg=b.getElementNameById;local th=ap~=0 and aq~=0;for dQ in pairs(sM)do local type=b.getElementTypeById(sM[dQ])if e9(type,'^.*Atmospheric Engine$')then if e9(tostring(b.getElementTagsById(sM[dQ])),'^.*vertical.*$')and b.getElementForwardById(sM[dQ])[3]>0 then d1=true end end;if e9(type,'^.*Space Engine$')then cS=true;if e9(tostring(b.getElementTagsById(sM[dQ])),'^.*vertical.*$')then local ti=b.getElementForwardById(sM[dQ])if ti[3]<0 then tj=true else cR=true end end end;if type=="Landing Gear"then bR=true end;if type=="Dynamic Core Unit"then local tk=sK(sM[dQ])if tk>10000 then gK=110 elseif tk>1000 then gK=55 elseif tk>150 then gK=27 end end;sO=sO+sK(sM[dQ])if th and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local tk=sK(sM[dQ])local o2=ib(sM[dQ])local tc=0;local jf=bD()if type=="Atmospheric Fuel Tank"then local td=400;local tl=35.03;if tk>10000 then td=51200;tl=5480 elseif tk>1300 then td=6400;tl=988.67 elseif tk>150 then td=1600;tl=182.67 end;tc=o2-tl;if a2>0 then td=td+td*a2*0.2 end;td=tb(tc,td)ct[#ct+1]={sM[dQ],tg(sM[dQ]),td,tl,tc,jf}end;if type=="Rocket Fuel Tank"then local td=320;local tl=173.42;if tk>65000 then td=40000;tl=25740 elseif tk>6000 then td=5120;tl=4720 elseif tk>700 then td=640;tl=886.72 end;tc=o2-tl;if a4>0 then td=td+td*a4*0.1 end;td=tb(tc,td)cv[#cv+1]={sM[dQ],tg(sM[dQ]),td,tl,tc,jf}end;if type=="Space Fuel Tank"then local td=600;local tl=35.03;if tk>10000 then td=76800;tl=5480 elseif tk>1300 then td=9600;tl=988.67 elseif tk>150 then td=2400;tl=182.67 end;tc=o2-tl;if a3>0 then td=td+td*a3*0.2 end;td=tb(tc,td)cu[#cu+1]={sM[dQ],tg(sM[dQ]),td,tl,tc,jf}end end end;if not d1 then b4,aV=false,false end end;local function tm()if gyro~=nil then cn=gyro.getState()==1 end;if not bw then id:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then rT(1)else rT(0)end;if door and(ch or not ch and cj<10000)then for dV,dC in pairs(door)do dC.toggle()end end;if switch then for dV,dC in pairs(switch)do dC.toggle()end end;if forcefield and(ch or not ch==0 and cj<10000)then for dV,dC in pairs(forcefield)do dC.toggle()end end;if antigrav then d2=antigrav.getState()==1;if d2 and not q then antigrav.show()end end;if ic()==1 and k then a.freeze(1)else a.freeze(0)end;if bR then bh=d.control.isAnyLandingGearExtended()==1;if bh then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if cg~=-1 or not ch and cW:len()<50 then aW=true;bh=true;if bR then d.control.extendLandingGears()end else aW=false end;id:setTargetGroundAltitude(sL)if ch and cg~=-1 then cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;p1=ch end;local function tn()local to={}local function tp()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local tq={[1]=4480,[6]=4480,[7]=6270}for tr,ts in pairs(e)do e[tr][0]=tp()e[tr][0].systemId=tr;to[tr]={}for tt,iI in pairs(e[tr])do iI.gravity=iI.gravity/9.8;iI.center=vec3(iI.center)iI.name=iI.name[1]iI.noAtmosphericDensityAltitude=iI.atmosphereThickness or iI.atmosphereRadius-iI.radius;iI.spaceEngineMinAltitude=tq[iI.id]or 0.68377*(iI.atmosphereThickness or iI.atmosphereRadius-iI.radius)iI.planetarySystemId=tr;iI.bodyId=iI.id;to[tr][tt]=iI;if m8==nil or iI.center.x<m8 then m8=iI.center.x end;if m7==nil or iI.center.x>m7 then m7=iI.center.x end;if mb==nil or iI.center.y<mb then mb=iI.center.y end;if ma==nil or iI.center.y>ma then ma=iI.center.y end;if iI.center and iI.name~="Space"then dj[#dj+1]=iI end end end;ej=dp(d,b,c,a,dq,dr,ds,dt,du)cx=ej(to)cy=f2(d,b,c,a,dt,f3)cA=fx(d,b,c,a,dq,dr,ds,dt,du)cC=fX(d,b,c,a,dbHud_1,e,fY,fZ,bE,ds,dt,f_)end;tu=false;tv=coroutine.create(function()id:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})t6()coroutine.yield()ta()coroutine.yield()cD=p6(d,b,c,a,e,vBooster,hover,p7,antigrav,warpdrive,dbHud_1,f3,bE,bF,ic,eZ,bD,dr,id,fY,ie,dt,ig,f_,ih,du,ij,ik,p8,ia,dq,fZ)tm()coroutine.yield()tn()cE=gH(b,a,c,library,radar_1,radar_2,f3,gI,dt,gJ,ds,gK,f_)cB=i8(d,b,c,a,e,radar_1,radar_2,antigrav,hover,i9,warpdrive,f3,bE,dq,ia,bF,ib,ic,eZ,bD,dr,id,fZ,fY,gI,ie,dt,ig,gJ,f_,ih,ii,ij,ik)cB.ButtonSetup()cF=rS(d,b,c,a,e,vBooster,hover,antigrav,i9,dbHud_2,gyro,ic,id,ie,rT,gI,ig,e9,ds,dr,f_,ii)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aO)c.setTimer("radarTick",aO)c.setTimer("hudTick",aP)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)f_("start","SU")end)coroutine.resume(tv)end;function sI.onUpdate()if not tu then local hX=coroutine.status(tv)if hX=="suspended"then local dR,hY=coroutine.resume(tv)if hY then a.print("ERROR STARTUP: "..hY)end elseif hX=="dead"then tu=true end end;if tu then d:update()if not cG and oH~=tw then a.setScreen(oH)end;tw=oH end end;function sI.onFlush()local function tx(ty,qU)local tz=vec3()local tA=vec3()if ty==axisCommandId.longitudinal then tz=vec3(b.getConstructOrientationForward())tA=cU elseif ty==axisCommandId.vertical then tz=vec3(b.getConstructOrientationUp())tA=cT elseif ty==axisCommandId.lateral then tz=vec3(b.getConstructOrientationRight())tA=cV else return vec3()end;local tB=vec3(b.getWorldGravity())local tC=tB:dot(tA)local tD=vec3(b.getWorldAirFrictionAcceleration())local tE=tD:dot(tA)local tF=cW:dot(tz)local tG=qU*constants.kph2m;if tH==nil then tH=pid.new(10,0,10.0)end;tH:inject(tG-tF)local tI=tH:get()local tJ=(tI-tE-tC)*tA;return tJ end;local function tK(ty,qU)local tz=vec3()local tA=vec3()if ty==axisCommandId.longitudinal then tz=vec3(b.getConstructOrientationForward())tA=cU elseif ty==axisCommandId.vertical then tz=vec3(b.getConstructOrientationUp())tA=cT elseif ty==axisCommandId.lateral then tz=vec3(b.getConstructOrientationRight())tA=cV else return vec3()end;local tB=vec3(b.getWorldGravity())local tC=tB:dot(tA)local tD=vec3(b.getWorldAirFrictionAcceleration())local tE=tD:dot(tA)local tF=cW:dot(tz)local tG=qU*constants.kph2m;if tL==nil then tL=pid.new(10,0,10.0)end;tL:inject(tG-tF)local tI=tL:get()local tJ=(tI-tE-tC)*tA;return tJ end;local function tM(tN,ju,g6)local tO=tN:cross(g6):normalize_inplace()local kf=math.acos(dr(tO:dot(-ju),-1,1))*constants.rad2deg;if tO:cross(-ju):dot(g6)<0 then kf=-kf end;return kf end;if antigrav and not q then if not d2 and antigrav.getBaseAltitude()~=bq then antigrav.setBaseAltitude(bq)end end;d4=id:getAxisCommandType(0)==axisCommandType.byThrottle;if d4 and bO then cD.cmdThrottle(0)bO=false elseif not d4 and not bO then bK=0;bO=true end;aJ=math.max(aJ,0.01)aK=math.max(aK,0.01)aE=math.max(aE,0.01)aI=math.max(aI,0.01)aL=math.max(aL,0.01)aM=math.max(aM,0.01)aD=math.max(aD,0.01)local tP=dr(bS+bT+a.getControlDeviceForwardInput(),-1,1)local tQ=dr(bV+bY+a.getControlDeviceYawInput(),-1,1)local tR=dr(bW+bU-a.getControlDeviceLeftRightInput(),-1,1)local tS=bX;cZ=vec3(b.getWorldVertical())if cZ==nil or cZ:len()==0 then cZ=(iI.center-d0):normalize()end;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cX=vec3(b.getWorldVelocity())cW=vec3(b.getVelocity())d0=vec3(b.getConstructWorldPos())cl=b.getConstructMass()cY=vec3(cX):len()c_=-cZ:dot(cX)d6=getRoll(cZ,cU,cV)local tT=d6/180*math.pi;local tU=math.cos(tT)local tV=math.sin(tT)d5=tM(cZ,cU,cV*tU+cT*tV)local tW=cX:normalize()local tX=f3(d6)local tY=utils.sign(d6)local tZ=vec3(b.getWorldAngularVelocity())local t_=tP*aJ*cV+tQ*aE*cU+tR*aK*cT;if cI==true and cZ:len()>0.01 then local u0=f3(cK-d6)if((aY or b3 or b1 or cd or b0 or bu)and u0>0 or ci>0.0 and u0<aF and p)and tQ==0 and f3(d5)<85 then local u1=cK;local u2=aD;if ci==0 then u2=u2/4;cK=0;u1=0 end;if u3==nil then u3=pid.new(u2*0.01,0,u2*0.1)end;u3:inject(u1-d6)local u4=u3:get()t_=t_+u4*cU end end;local u5=1;local u6=0;local u7=1;local u8=a.getMouseWheel()if u8>0 then cD.changeSpd()elseif u8<0 then cD.changeSpd(true)else cm=true end;bL=0;if ch and u and d4 then if u9==nil then u9=pid.new(0.5,0,1)end;u9:inject(cL/3.6-cX:dot(cU))local ua=u9:get()bN=dr(ua,-1,1)if bN<bK and ci>0.005 then bM=true;id:setThrottleCommand(axisCommandId.longitudinal,dr(bN,0.01,1))else bM=false;id:setThrottleCommand(axisCommandId.longitudinal,bK)end;if ub==nil then ub=pid.new(1*0.01,0,1*0.1)end;ub:inject(cX:len()-cL/3.6)local uc=dr(ub:get(),0,1)if ci>0 and c_<-80 or ci>0.005 then bL=uc end;if bL>0 then if bM and bN==0.01 then id:setThrottleCommand(axisCommandId.longitudinal,0)end else bN=dr(bN,0.01,1)end;local ud=''local ue=vec3()local uf=tx(axisCommandId.vertical,c7*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",uf,u6)local ug='thrust analog longitudinal 'if bx=="All"or bx=="Longitude"then ug=ug..aQ end;local uh=id:getAxisCommandType(axisCommandId.longitudinal)local ui=id:composeAxisAccelerationFromThrottle(ug,axisCommandId.longitudinal)local uj=tK(axisCommandId.lateral,bt*1000)ud=ud..' , '.."lateral airfoil , lateral ground "ue=ue+uj;if ue:len()>constants.epsilon then d:setEngineForceCommand(ud,ue,u6,'','','',u7)end;d:setEngineForceCommand(ug,ui,u5)local uk='thrust analog vertical fueled 'local ul='thrust analog lateral fueled 'if bx=="All"or bx=="Lateral"then ul=ul..aR end;if bx=="All"or bx=="Vertical"then uk=uk..aS end;if c7~=0 or b1 and aW or not bh and not bw then d:setEngineForceCommand(uk,uf,u5)else d:setEngineForceCommand(uk,vec3(),u5)end;if bt~=0 then d:setEngineForceCommand(ul,uj,u5)else d:setEngineForceCommand(ul,vec3(),u5)end;if tS==0 then tS=bL end;local um=-tS*(aL*cX+aM*tW)d:setEngineForceCommand('brake',um)else if u then id:setThrottleCommand(axisCommandId.longitudinal,bK)end;local qU=c.getAxisCommandValue(0)if not d4 then if ub==nil then ub=pid.new(1*0.01,0,1*0.1)end;ub:inject(cX:len()-qU/3.6)local uc=dr(ub:get(),0,1)tS=dr(tS+uc,0,1)end;local um=-tS*(aL*cX+aM*tW)d:setEngineForceCommand('brake',um)local ud=''local ue=vec3()local un=false;local ug='thrust analog longitudinal 'if bx=="All"or bx=="Longitude"then ug=ug..aQ end;local uh=id:getAxisCommandType(axisCommandId.longitudinal)if uh==axisCommandType.byThrottle then local ui=id:composeAxisAccelerationFromThrottle(ug,axisCommandId.longitudinal)d:setEngineForceCommand(ug,ui,u5)elseif uh==axisCommandType.byTargetSpeed then local ui=id:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ud=ud..' , '..ug;ue=ue+ui;if id:getTargetSpeed(axisCommandId.longitudinal)==0 or id:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-id:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then un=true end end;local ul='thrust analog lateral 'if bx=="All"or bx=="Lateral"then ul=ul..aR end;local uo=id:getAxisCommandType(axisCommandId.lateral)if uo==axisCommandType.byThrottle then local up=id:composeAxisAccelerationFromThrottle(ul,axisCommandId.lateral)d:setEngineForceCommand(ul,up,u5)elseif uo==axisCommandType.byTargetSpeed then local uj=id:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ud=ud..' , '..ul;ue=ue+uj end;local uk='thrust analog vertical 'if bx=="All"or bx=="Vertical"then uk=uk..aS end;local uq=id:getAxisCommandType(axisCommandId.vertical)if uq==axisCommandType.byThrottle then local uf=id:composeAxisAccelerationFromThrottle(uk,axisCommandId.vertical)if c7~=0 or b1 and aW then d:setEngineForceCommand(uk,uf,u5,'airfoil','ground','',u7)else d:setEngineForceCommand(uk,vec3(),u5)d:setEngineForceCommand('airfoil vertical',uf,u5,'airfoil','','',u7)d:setEngineForceCommand('ground vertical',uf,u5,'ground','','',u7)end elseif uq==axisCommandType.byTargetSpeed then if c7<0 then d:setEngineForceCommand('hover',vec3(),u5)end;local ur=id:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ud=ud..' , '..uk;ue=ue+ur end;if ue:len()>constants.epsilon then if bX~=0 or un or f3(tW:dot(cU))<0.5 then ud=ud..', brake'end;d:setEngineForceCommand(ud,ue,u6,'','','',u7)end end;local us=aI*(t_-tZ)local ut=vec3(b.getWorldAirFrictionAngularAcceleration())us=us-ut;d:setEngineTorqueCommand('torque',us,u5,'airfoil','','',u7)d:setBoosterCommand('rocket_engine')if c1 and not n then local fv=cW:len()local uu=0.15;if not d4 then local uv=id:getTargetSpeed(axisCommandId.longitudinal)if fv*3.6>uv*(1-uu)and sn then sn=false;d:toggleBoosters()elseif fv*3.6<uv*(1-uu)and not sn then sn=true;d:toggleBoosters()end else local oT=c.getThrottle()if u then oT=bK*100 end;local qU=oT/100;if bF==0 then qU=qU*_;if fv>=qU*(1-uu)and sn then sn=false;d:toggleBoosters()elseif fv<qU*(1-uu)and not sn then sn=true;d:toggleBoosters()end else local r6=bE(cL)qU=qU*r6/3.6;if fv>=qU*(1-uu)and sn then sn=false;d:toggleBoosters()elseif fv<qU*(1-uu)and not sn then sn=true;d:toggleBoosters()end end end end end;function sI.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ci>0 or ci==0 and cj<10000)then for dV,dC in pairs(door)do dC.toggle()end end;if switch then for dV,dC in pairs(switch)do dC.toggle()end end;if forcefield and(ci>0 or ci==0 and cj<10000)then for dV,dC in pairs(forcefield)do dC.toggle()end end;x=dl;p8()if nE then nE.activate()end;if A then cD.showWayPoint(iI,d0)end;f_("stop","SU")end;function sI.OneSecondTick()local function uw(jr)local ux=0;cq=""local uy=sO;local uz=0;local uA=0;local uB=0;local jj=0;local jk=""local uC=b.getElementHitPointsById;for dQ in pairs(sM)do local tk=0;local uD=0;uD=sK(sM[dQ])tk=uC(sM[dQ])uz=uz+tk;if tk<uD then if tk==0 then uB=uB+1 else uA=uA+1 end;if cw and#sN==0 then g1=vec3(b.getElementPositionById(sM[dQ]))local hh=g1.x;local hi=g1.y;local hj=g1.z;table.insert(sN,b.spawnArrowSticker(hh,hi,hj+1,"down"))table.insert(sN,b.spawnArrowSticker(hh,hi,hj+1,"down"))b.rotateSticker(sN[2],0,0,90)table.insert(sN,b.spawnArrowSticker(hh+1,hi,hj,"north"))table.insert(sN,b.spawnArrowSticker(hh+1,hi,hj,"north"))b.rotateSticker(sN[4],90,90,0)table.insert(sN,b.spawnArrowSticker(hh-1,hi,hj,"south"))table.insert(sN,b.spawnArrowSticker(hh-1,hi,hj,"south"))b.rotateSticker(sN[6],90,-90,0)table.insert(sN,b.spawnArrowSticker(hh,hi-1,hj,"east"))table.insert(sN,b.spawnArrowSticker(hh,hi-1,hj,"east"))b.rotateSticker(sN[8],90,0,90)table.insert(sN,b.spawnArrowSticker(hh,hi+1,hj,"west"))table.insert(sN,b.spawnArrowSticker(hh,hi+1,hj,"west"))b.rotateSticker(sN[10],-90,0,90)table.insert(sN,sM[dQ])end elseif cw and#sN>0 and sN[11]==sM[dQ]then for je in pairs(sN)do b.deleteSticker(sN[je])end;sN={}end end;ux=bE(uz/uy*100)if ux<100 then jr[#jr+1]=gJ(0,0,"","pbright txt")jj=bE(ux*2.55)jk=dq("rgb(%d,%d,%d)",255-jj,jj,0)if ux<100 then jr[#jr+1]=gJ("50%",1035,"Elemental Integrity: "..ux.."%","txtbig txtmid","fill:"..jk)if uB>0 then jr[#jr+1]=gJ("50%",1055,"Disabled Modules: "..uB.." Damaged Modules: "..uA,"txtbig txtmid","fill:"..jk)elseif uA>0 then jr[#jr+1]=gJ("50%",1055,"Damaged Modules: "..uA,"txtbig txtmid","fill:"..jk)end end end end;local function uE()if sH then if uF==nil and(i6~=nil or bh)then _autoconf.displayCategoryPanel(sH,weapon_size,"Weapons","weapon",true)uF=_autoconf.panels[_autoconf.panels_size]elseif uF~=nil and i6==nil and not bh then gI(uF)uF=nil end end end;local function p3()local jf=bD()local kC=cY;local p4=jf-ck;if kC>1.38889 then kC=kC/1000;local p5=kC*(jf-ck)bi=bi+p5;c5=c5+p5 end;c6=c6+p4;bj=bj+p4;ck=jf end;p3()dh=b.getPlayersOnBoard()di=b.getDockedConstructs()uE()local jr={}cB.OneSecondTick(jr)if s then uw(jr)end;cc=table.concat(jr,"")collectgarbage("collect")end;function sI.controlStart(s0)cF.startControl(s0)end;function sI.controlStop(s0)cF.stopControl(s0)end;function sI.controlLoop(s0)cF.loopControl(s0)end;function sI.onInputText(rL)cF.inputTextControl(rL)end;function sI.radarEnter(d_)cE.onEnter(d_)end;function sI.radarLeave(d_)cE.onLeave(d_)end;function sI.onTick(uG)if uG=="tenthSecond"then cD.TenthTick()cB.TenthTick()elseif uG=="oneSecond"then uH.OneSecondTick()elseif uG=="fiveSecond"then cD.SatNavTick()elseif uG=="msgTick"then cB.MsgTick()elseif uG=="animateTick"then cB.AnimateTick()elseif uG=="hudTick"then cB.hudtick()elseif uG=="apTick"then cD.APTick()elseif uG=="radarTick"then cE.UpdateRadar()elseif uG=="tagTick"then cF.tagTick()elseif uG=="contact"then cE.ContactTick()end end;return sI end;function script.onStart()uH.onStart()end;function script.onStop()uH.onStop()end;function script.onTick(uG)uH.onTick(uG)end;function script.onFlush()uH.onFlush()end;function script.onUpdate()uH.onUpdate()end;function script.onActionStart(s0)uH.controlStart(s0)end;function script.onActionStop(s0)uH.controlStop(s0)end;function script.onActionLoop(s0)uH.controlLoop(s0)end;function script.onInputText(rL)uH.controlInput(rL)end;function script.onEnter(d_)uH.radarEnter(d_)end;function script.onLeave(d_)uH.radarLeave(d_)end;bC(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)uH=sG(d,b,c,a,library,e,vBooster,hover,p7,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,i9,gyro,warpdrive,sH)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
