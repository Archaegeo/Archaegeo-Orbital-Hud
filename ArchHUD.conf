name: ArchHud - Archaegeo v1.512 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.512;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=50000;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local bP={}local bQ="Atmo"function p(bR)system.print(E..": "..bR)end;local function bS(bT)local bU,bV,bW=aR:getPlanetarySystem(0):castIntersections(bv,bT,function(bX)if bX.noAtmosphericDensityAltitude>0 then return bX.radius+bX.noAtmosphericDensityAltitude else return bX.radius+bX.surfaceMaxAltitude*1.5 end end)local bY=bV;if bW~=nil and bV~=nil then bY=math.min(bW,bV)end;if bY~=nil then return bU,bY else return nil,nil end end;local function bZ(b_,c0,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)end end;local function c1(c2,c3)for i=1,#c3 do c2[#c2+1]=c3[i]end;return c2 end;local function c4(c5)local c6={}local c7={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","showHelp","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local c8={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c9={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local ca={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c5 then c1(c6,c7)c1(c6,c8)c1(c6,c9)c1(c6,ca)return c6 elseif c5=="boolean"then return c7 elseif c5=="handling"then return c8 elseif c5=="hud"then return c9 elseif c5=="physics"then return ca end end;local function cb(cc,cd,ce,cf,cg)if cf==nil then cf=""end;if cg==nil then cg=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cf,cc,cd,cg,ce)end;local function ch(ci,cj)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not cj then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,ci)K=r(A(ci*100,0)/100,-1,1)bz=nil end;local function ck(ci,cj)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cj then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,ci)bz=ci end;local function cl(cm,cn)if cm==0 then return d(cn)<1e-09 end;if cn==0 then return d(cm)<1e-09 end;return d(cm-cn)<math.max(d(cm),d(cn))*epsilon end;local function co(aj,cp)local cq=aj>100000;if cp==nil then cp=1 end;if cq then return A(aj/1000/200,cp).."SU"elseif aj<1000 then return A(aj,cp).."M"else return A(aj/1000,cp).."KM"end end;local function cr()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ck(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cs()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then bZ("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then bZ("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function ct()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bZ("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cs()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;cs()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then bZ("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cr()end else bZ("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cr()end end;if am then HoldAltitude=100000 end else bZ("altOff","AH")if IntoOrbit then cs()end;if VertTakeOff then cr()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cu(cv)if cv then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cr()end;if IntoOrbit then cs()end;b0=autoRollPreference;al=false;an=false;af=0 end;local function cw()local function cx(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then ct()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bZ("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bZ("apSpc","AP")if ar~=0 then am=true;ct()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bZ("vtt","AP")cx(SpaceTarget)end else bZ("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then cs()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cs()end end end else bZ("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;ct()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cs()else bZ("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bZ("apP","AP")am=true;ct()end else bZ("apOff","AP")cu(1)end end;local function cy()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then bZ("bkOn","B",1)cu()else bZ("bkOff","B",1)end end;local function cz()if Reentry then a2="Re-Entry cancelled"bZ("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;bZ("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local ce=co(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..ce;bZ("glide","RE")ck(e(b7))end;AutoTakeoff=false end;local function cA()if antigrav and not ExternalAGG then if by then bZ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bZ("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cB(cC)local cD=0;local cE=0;local cF=0;if cC<60 then cC=e(cC)elseif cC<3600 then cD=e(cC/60)cC=e(cC%60)elseif cC<86400 then cE=e(cC/3600)cD=e(cC%3600/60)else cF=e(cC/86400)cE=e(cC%86400/3600)end;if cF>0 then return cF.."d "..cE.."h "elseif cE>0 then return cE.."h "..cD.."m "elseif cD>0 then return cD.."m "..cC.."s"elseif cC>0 then return cC.."s"else return"0s"end end;local function cG(cH)local function cI(cJ)for cK,cL in pairs(cJ)do dbHud_1.setStringValue(cL,h(_G[cL]))if cH and dbHud_2 then dbHud_2.setStringValue(cL,h(_G[cL]))end end end;if dbHud_1 then cI(c)cI(c4())system.print("Saved Variables to Datacore")if cH and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cM()local function cN(cO)return type(cO)=='number'end;local function cP(cO)return type(z(cO))=='number'end;local function cQ(cR)return type(cR)=='table'end;local function cS(cT)return type(cT)=='string'end;local function cU(cL)return cQ(cL)and cN(cL.x and cL.y and cL.z)end;local function cV(cW)return cQ(cW)and cN(cW.latitude and cW.longitude and cW.altitude and cW.id and cW.systemId)end;local cX=math.pi/180;local cY=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cZ='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function c_(cO)local d0=string.gsub(string.reverse(f('%.4f',cO)),'^0*%.?','')return d0==''and'0'or string.reverse(d0)end;local function d1(d2)if cU(d2)then return f('{x=%.3f,y=%.3f,z=%.3f}',d2.x,d2.y,d2.z)end;if cQ(d2)and not getmetatable(d2)then local d3={}local d4=next(d2)if type(d4)=='nil'or d4==1 then d3=d2 else for cK,cL in pairs(d2)do local ci=d1(cL)if type(cK)=='number'then table.insert(d3,f('[%s]=%s',cK,ci))else table.insert(d3,f('%s=%s',cK,ci))end end end;return f('{%s}',table.concat(d3,','))end;if cS(d2)then return f("'%s'",d2:gsub("'",[[\']]))end;return tostring(d2)end;local d5={}d5.__index=d5;d5.__tostring=function(d2,d6)local d7={}for cK in pairs(d2)do table.insert(d7,cK)end;table.sort(d7)local d3={}for _,cK in ipairs(d7)do local ci=d1(d2[cK])if type(cK)=='number'then table.insert(d3,f('[%s]=%s',cK,ci))else table.insert(d3,f('%s=%s',cK,ci))end end;if d6 then return f('%s%s',d6,table.concat(d3,',\n'..d6))end;return f('{%s}',table.concat(d3,','))end;d5.__eq=function(d8,d9)return d8.systemId==d9.systemId and d8.id==d9.id and cl(d8.radius,d9.radius)and cl(d8.center.x,d9.center.x)and cl(d8.center.y,d9.center.y)and cl(d8.center.z,d9.center.z)and cl(d8.GM,d9.GM)end;local function da(db,dc,dd,de,df)assert(cP(db),'Argument 1 (systemId) must be a number:'..type(db))assert(cP(dc),'Argument 2 (id) must be a number:'..type(dc))assert(cP(dd),'Argument 3 (radius) must be a number:'..type(dd))assert(cQ(de),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(de))assert(cP(df),'Argument 5 (GM) must be a number:'..type(df))return setmetatable({systemId=z(db),id=z(dc),radius=z(dd),center=vec3(de),GM=z(df)},d5)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,c_(p.latitude*cY),c_(p.longitude*cY),c_(p.altitude))end;MapPosition.__eq=function(d8,d9)return d8.id==d9.id and d8.systemId==d9.systemId and cl(d8.latitude,d9.latitude)and cl(d8.altitude,d9.altitude)and(cl(d8.longitude,d9.longitude)or cl(d8.latitude,math.pi/2)or cl(d8.latitude,-math.pi/2))end;local function dg(dh,dc,di,dj,dk)local db=dh;if cS(dh)and not dj and not dk and not dc and not di then db,dc,di,dj,dk=o(dh,cZ)assert(db,'Argument 1 (position string) is malformed.')else assert(cP(db),'Argument 1 (systemId) must be a number:'..type(db))assert(cP(dc),'Argument 2 (id) must be a number:'..type(dc))assert(cP(di),'Argument 3 (latitude) must be in degrees:'..type(di))assert(cP(dj),'Argument 4 (longitude) must be in degrees:'..type(dj))assert(cP(dk),'Argument 5 (altitude) must be in meters:'..type(dk))end;db=z(db)dc=z(dc)di=z(di)dj=z(dj)dk=z(dk)if dc==0 then return setmetatable({latitude=di,longitude=dj,altitude=dk,id=dc,systemId=db},MapPosition)end;return setmetatable({latitude=cX*r(di,-90,90),longitude=cX*(dj%360),altitude=dk,id=dc,systemId=db},MapPosition)end;local dl={}dl.__index=dl;dl.__tostring=function(d2,d6)local dm=d6 and d6 ..'  'local dn={}local d7={}for cK in pairs(d2)do table.insert(d7,cK)end;table.sort(d7)for _,dp in ipairs(d7)do bdy=d2[dp]local dq=d5.__tostring(bdy,dm)if d6 then table.insert(dn,f('[%s]={\n%s\n%s}',dp,dq,d6))else table.insert(dn,f('  [%s]=%s',dp,dq))end end;if d6 then return f('\n%s%s%s',d6,table.concat(dn,',\n'..d6),d6)end;return f('{\n%s\n}',table.concat(dn,',\n'))end;local function dr(ds)local b={}local pid;for _,cL in pairs(ds)do local dc=cL.planetarySystemId;if type(dc)~='number'then error('Invalid planetary system ID: '..tostring(dc))elseif pid and dc~=pid then error('Mistringmatch planetary system IDs: '..dc..' and '..pid)end;local dt=cL.bodyId;if type(dt)~='number'then error('Invalid body ID: '..tostring(dt))elseif b[dt]then error('Duplicate body ID: '..tostring(dt))end;setmetatable(cL.center,getmetatable(vec3.unit_x))b[dt]=setmetatable(cL,d5)pid=dc end;return setmetatable(b,dl)end;aQ={}local function du(ds)return setmetatable({galaxyAtlas=ds or{}},aQ)end;aQ.__index=function(cR,i)if type(i)=='number'then local system=cR.galaxyAtlas[i]return dr(system)end;return rawget(aQ,i)end;aQ.__pairs=function(d2)return function(cR,cK)local dv,nv=next(cR,cK)return dv,nv and dr(nv)end,d2.galaxyAtlas,nil end;aQ.__tostring=function(d2)local dw={}for _,dx in pairs(d2 or{})do local dy=dx:getPlanetarySystemId()local dz=dl.__tostring(dx,'    ')table.insert(dw,f('  [%s]={%s\n  }',dy,dz))end;return f('{\n%s\n}\n',table.concat(dw,',\n'))end;aQ.BodyParameters=da;aQ.MapPosition=dg;aQ.PlanetarySystem=dr;function aQ.createBodyParameters(db,dc,dA,dB,dC,dD,dE)assert(cP(db),'Argument 1 (systemId) must be a number:'..type(db))assert(cP(dc),'Argument 2 (id) must be a number:'..type(dc))assert(cP(dA),'Argument 3 (surfaceArea) must be a number:'..type(dA))assert(cQ(dB),'Argument 4 (aPosition) must be an array or vec3:'..type(dB))assert(cQ(dC),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dC))assert(cP(dD),'Argument 6 (altitude) must be in meters:'..type(dD))assert(cP(dE),'Argument 7 (gravityAtPosition) must be number:'..type(dE))local dd=y(dA/4/math.pi)local aj=dd+dD;local dF=vec3(dB)+aj*vec3(dC)local df=dE*aj*aj;return da(db,dc,dd,dF,df)end;aQ.isMapPosition=cV;function aQ:getPlanetarySystem(dh)if i==nil then i=0 end;if nv==nil then nv=0 end;local db=dh;if cV(dh)then db=dh.systemId end;if type(db)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dl then system=dr(system)end;return system end end end;function dl:sizeCalculator(bX)return 1.05*bX.radius end;function dl:castIntersections(dG,dH,dI,dJ,dK,dL)local dM={}local dN=dK or self;for _,bX in pairs(dN)do table.insert(dM,bX)end;if not dL then table.sort(dM,function(dO,dP)return(dO.center-dG):len()<(dP.center-dG):len()end)end;local dQ=dH:normalize()for _,bX in ipairs(dM)do local dR=bX.center-dG;local dd=self:sizeCalculator(bX)local dS=dR:dot(dQ)local dT=dS^2-(dR:len2()-dd^2)if dT>=0 then local dU=y(dT)local bV=dS+dU;local bW=dS-dU;if bW>0 then return bX,bV,bW elseif bV>0 then return bX,bV,nil end end end;return nil,nil,nil end;function dl:closestBody(dV)assert(type(dV)=='table','Invalid coordinates.')local dW,bX;local dX=vec3(dV)for _,dY in pairs(self)do local dZ=(dY.center-dX):len2()if(not bX or dZ<dW)and dY.name~="Space"then bX=dY;dW=dZ end end;return bX end;function dl:convertToBodyIdAndWorldCoordinates(dh)local d_=dh;if cS(dh)then d_=dg(dh)end;if d_.id==0 then return 0,vec3(d_.latitude,d_.longitude,d_.altitude)end;local dY=self:getBodyParameters(d_)if dY then return d_.id,dY:convertToWorldCoordinates(d_)end end;function dl:getBodyParameters(dh)local dc=dh;if cV(dh)then dc=dh.id end;assert(cP(dc),'Argument 1 (id) must be a number:'..type(dc))return self[dc]end;function dl:getPlanetarySystemId()local _,cL=next(self)return cL and cL.systemId end;function d5:convertToMapPosition(de)assert(cQ(de),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(de))local e0=vec3(de)if self.id==0 then return setmetatable({latitude=e0.x,longitude=e0.y,altitude=e0.z,id=0,systemId=self.systemId},MapPosition)end;local e1=e0-self.center;local aj=e1:len()local dk=aj-self.radius;local di=0;local dj=0;if not cl(aj,0)then local e2=n(e1.y,e1.x)dj=e2>=0 and e2 or 2*math.pi+e2;di=math.pi/2-math.acos(e1.z/aj)end;return setmetatable({latitude=di,longitude=dj,altitude=dk,id=self.id,systemId=self.systemId},MapPosition)end;function d5:convertToWorldCoordinates(dh)local d_=cS(dh)and dg(dh)or dh;if d_.id==0 then return vec3(d_.latitude,d_.longitude,d_.altitude)end;assert(cV(d_),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(d_.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(d_.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local e3=math.cos(d_.latitude)return self.center+(self.radius+d_.altitude)*vec3(e3*math.cos(d_.longitude),e3*math.sin(d_.longitude),math.sin(d_.latitude))end;function d5:getAltitude(de)return(vec3(de)-self.center):len()-self.radius end;function d5:getDistance(de)return(vec3(de)-self.center):len()end;function d5:getGravity(de)local e4=self.center-vec3(de)local e5=e4:len2()return self.GM/e5*e4/y(e5)end;return setmetatable(aQ,{__call=function(_,...)return du(...)end})end;local function e6()local aS={}local e7=30000000/3600;local e8=e7*e7;local e9=100;function aS.computeAccelerationTime(ea,eb,ec)local ed=e7*math.asin(ea/e7)return(e7*math.asin(ec/e7)-ed)/eb end;function aS.computeDistanceAndTime(ea,ec,ee,ef,eg,eh)eg=eg or 0;eh=eh or 0;local ei=ea<=ec;local ej=ef*(ei and 1 or-1)/ee;local ek=-eh/ee;local el=ej+ek;if ei and el<=0 or not ei and el>=0 then return-1,-1 end;local em,en=0,0;if ej~=0 and eg>0 then local ed=math.asin(ea/e7)local eo=math.pi*(ej/2+ek)local ep=ej*eg;local eq=e7*math.pi;local cL=function(cR)local er=(eo*cR-ep*math.sin(math.pi*cR/2/eg)+eq*ed)/eq;local es=math.tan(er)return e7*es/y(es*es+1)end;local et=ei and function(cT)return cT>=ec end or function(cT)return cT<=ec end;en=2*eg;if et(cL(en))then local eu=0;while d(en-eu)>0.5 do local cR=(en+eu)/2;if et(cL(cR))then en=cR else eu=cR end end end;local ev=ea;local ew=en/e9;for ex=1,e9 do local ey=cL(ex*ew)em=em+(ey+ev)*ew/2;ev=ey end;if en<2*eg then return em,en end;ea=ev end;local ed=e7*math.asin(ea/e7)local E=(e7*math.asin(ec/e7)-ed)/el;local ez=e8*math.cos(ed/e7)/el;local aj=ez-e8*math.cos((el*E+ed)/e7)/el;return aj+em,E+en end;function aS.computeTravelTime(ea,eb,aj)if aj==0 then return 0 end;if eb>0 then local ed=e7*math.asin(ea/e7)local ez=e8*math.cos(ed/e7)/eb;return(e7*math.acos(eb*(ez-aj)/e8)-ed)/eb end;if ea==0 then return-1 end;assert(ea>0,'Acceleration and initial speed are both zero.')return aj/ea end;return aS end;local function eA()local vec3=require('cpml.vec3')local cM=cM()local function cS(cT)return type(cT)=='string'end;local function cQ(cR)return type(cR)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dk)assert(self.body)local aj=dk+self.body.radius;if not cl(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dh,eB)assert(self.body)assert(cQ(dh)or cS(dh))assert(cQ(eB))local eC=(cS(dh)or cM.isMapPosition(dh))and self.body:convertToWorldCoordinates(dh)or vec3(dh)local cL=vec3(eB)local eD=eC-self.body.center;local eE=cL:len2()local eF=eD:len()local eG=self.body.GM;local eH=((eE-eG/eF)*eD-eD:dot(cL)*cL)/eG;local cm=eG/(2*eG/eF-eE)local eI=eH:len()local dQ=eH:normalize()local eJ=cm*(1-eI)local eK=cm*(1+eI)local eL=eJ*dQ+self.body.center;local eM=eI<=1 and-eK*dQ+self.body.center or nil;local eN=y(cm*eG*(1-eI*eI))local eO=eM and 2*math.pi*y(cm^3/eG)local eP=math.acos(eH:dot(eD)/(eI*eF))if eD:dot(cL)<0 then eP=-(eP-2*math.pi)end;local eQ=math.acos((math.cos(eP)+eI)/(1+eI*math.cos(eP)))local eR=eQ;if eR<0 then eR=eR+2*math.pi end;local eS=eR-eI*math.sin(eR)local eT=0;local eU=0;local eV=0;if eO~=nil then eT=eS/(2*math.pi/eO)eU=eO-eT;eV=eU+eO/2;if eP-math.pi>0 then eU=eT;eV=eU+eO/2 end;if eV>eO then eV=eV-eO end end;return{periapsis={position=eL,speed=eN/eJ,circularOrbitSpeed=y(eG/eJ),altitude=eJ-self.body.radius},apoapsis=eM and{position=eM,speed=eN/eK,circularOrbitSpeed=y(eG/eK),altitude=eK-self.body.radius},currentVelocity=cL,currentPosition=eC,eccentricity=eI,period=eO,eccentricAnomaly=eQ,meanAnomaly=eS,timeToPeriapsis=eU,timeToApoapsis=eV}end;local function eW(eX)local dY=cM.BodyParameters(eX.systemId,eX.id,eX.radius,eX.center,eX.GM)return setmetatable({body=dY},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eW(...)end})end;local function eY()local eZ={}local e_={}local f0={XS=13,S=27,M=55,L=110,XL=221}local f1={}local f2;local f3;local f4;local f5;local f6;local function f7()local function f8(f9,fa,fb,fc,fd,fe,ff,fg)fa,fc,fe,fg=vec3(fa),vec3(fc),vec3(fe),vec3(fg)local fh,fi,fj=f9*f9,fb*fb,fd*fd;local eE=fc-fa;local fk=eE:normalize()local fl=eE:len()local fm=fe-fa;local fn=(fm-fm:project_on(fk)):normalize()local fo,fp=fm:dot(fk),fm:dot(fn)local fq=fo*fo+fp*fp;local fr=fk:cross(fn)local cc=(fh-fi+fl*fl)/(2*fl)local cd=(fh-fj+fq-2*fo*cc)/(2*fp)local cW=fh-cc^2-cd^2;local fs=y(cW)local ft=fa+fk*cc+fn*cd+fr*fs;local fu=fa+fk*cc+fn*cd-fr*fs;if d((fg-ft):len()-ff)<d((fg-fu):len()-ff)then return ft else return fu end end;local function fv()local function fw()local fx=core.getConstructWorldOrientationRight()local eE=core.getConstructWorldOrientationForward()local fm=core.getConstructWorldOrientationUp()local fy=library.systemResolution3(fx,eE,fm,{1,0,0})local fz=library.systemResolution3(fx,eE,fm,{0,1,0})local fA=library.systemResolution3(fx,eE,fm,{0,0,1})return function(fB)return library.systemResolution3(fy,fz,fA,fB)end end;local fC=fw()local fD=core.getConstructWorldPos()local eC=core.getElementPositionById(1)local fE={eC[1],eC[2],eC[3]}local fF=fC(fE)local fG={fD[1]-fF[1],fD[2]-fF[2],fD[3]-fF[3]}return fG end;local function fH(fI,eF,fJ)local fK=fI.pts;local fL=#fK;local fM=fI.ref;if fL>3 then local fN,fO,fP,fQ=fK[fL],fK[fL-1],fK[fL-2],fK[fL-3]fI.ref=fJ;local eC=f8(fN[1],fN[2],fO[1],fO[2],fP[1],fP[2],fQ[1],fQ[2])local cc,cd,fs=eC.x,eC.y,eC.z;if cc==cc and cd==cd and fs==fs then cc=cc+fM[1]cd=cd+fM[2]fs=fs+fM[3]local fR=vec3(cc,cd,fs)if not fI.lastPos then fI.center=fR elseif(fI.lastPos-fR):len()<2 then fI.center=fR;fI.skipCalc=true end;fI.lastPos=fR end;fI.pts={}else local fS={fJ[1]-fM[1],fJ[2]-fM[2],fJ[3]-fM[3]}fK[fL+1]={eF,fS}end end;if bP[1]then f2=#bP[1].getConstructIds()local fT=bP[1].getData()local fU=fT:gmatch('{"constructId[^}]*}[^}]*}')if f2>0 then local fJ=fv()local fV,fW=0,0;f6,f5=0,0;for cL in fU do local dc,aj,fX=cL:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fY=f0[fX]aj=z(aj)if bP[1].hasMatchingTransponder(dc)==1 then table.insert(e_,dc)end;local fZ=bP[1].getConstructType(dc)if CollisionSystem then if fY>27 or fZ=="static"or fZ=="space"then f6=f6+1;local f_=bP[1].getConstructName(dc)local fI=bL[dc]if fI==nil then fY=fY+G;bL[dc]={pts={},ref=fJ,name=f_,i=0,radius=fY,skipCalc=false}fI=bL[dc]end;if not fI.skipCalc then fH(fI,aj,fJ)fW=fW+1 end;if fI.center then table.insert(f1,fI)end end;fV=fV+1;if bM and fV>700 or fW>70 or(not bM and fV>300 or fW>30)then coroutine.yield()fV,fW=0,0 end end end;f5=#f1;if f5>0 and bs>20 then local bX,g0,g1,g2;local g3=0;local g4=aR:getPlanetarySystem(0)g2=br:normalize()while g3<f5 do coroutine.yield()local g5={table.unpack(f1,g3,math.min(g3+75,f5))}bX,g0,g1=g4:castIntersections(bv,g2,nil,nil,g5,true)if bX and g1 then bO={bX,g0,g1}break end;g3=g3+75 end;if not bX then bO=nil end else bO=nil end;f1={}f3=fT:find('identifiedConstructs":%[%]')else f4=fT:find('worksInEnvironment":false')end end end;local function g6()if bP[1]then bQ="Atmo"if bP[1].getData():find('worksInAtmosphere":false')then bQ="Space"end end end;function eZ.pickType()g6()end;function eZ.assignRadar()if radar_1 and bP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 end;if bP[1]==radar_2 then g6()end elseif radar_2 and bP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 end;if bP[1]==radar_1 then g6()end end end;function eZ.UpdateRadar()local g7=coroutine.status(UpdateRadarCoroutine)if g7=="suspended"then local ci,g8=coroutine.resume(UpdateRadarCoroutine)if g8 then system.print("ERROR UPDATE RADAR: "..g8)end elseif g7=="dead"then UpdateRadarCoroutine=coroutine.create(f7)local ci,g8=coroutine.resume(UpdateRadarCoroutine)end end;function eZ.GetRadarHud()local g9=e_;e_={}return f3,f4,f2,f5,f6,g9 end;UpdateRadarCoroutine=coroutine.create(f7)return eZ end;local function ga()local gb=9.80665;local gc=vec3({13771471,7435803,-128971})local gd=18000000;local ge=500000;local gf,gg=math.huge;local gh;local function gi(gj)gf=vec3(gj):dist(gc)if gf<gd then return true,d(gf-gd)end;gg=vec3(gj):dist(vec3(planet.center))if gg<ge then gh=true else gh=false end;if d(gg-ge)<d(gf-gd)then return gh,d(gg-ge)else return gh,d(gf-gd)end end;local function gk(cL)if aG==1920 then return cL else return A(aG*cL/1920,0)end end;local function gl(cL)if aH==1080 then return cL else return A(aH*cL/1080,0)end end;local function gm()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gn()local go="TRAVEL"if not bA then go="CRUISE"end;if Autopilot then go="AUTOPILOT"end;return go end;local gp=""local gq=""local gr=""local gs=1;local gt=2;local gu=3;local gv=4;local gw=5;local gx=6;local gy=""local gz=0;local gA=e(1/apTickRate)*2*hudTickRate;local gB={}local gC={}local gD={}local gE={}local gF={}local gG={}local function gH(cc,gI,gJ,gK,gL,gM)local gN=fuelY;local gO=fuelY+5;if not BarFuelDisplay then gO=gO+5 end;if m()==1 and not RemoteHud then gN=gN-50;gO=gO-50 end;if gJ=="ATMO"then gy="atmofueltank"elseif gJ=="SPACE"then gy="spacefueltank"else gy="rocketfueltank"end;gz=_G[gy.."_size"]if#gK>0 then for i=1,#gK do local f_=string.sub(gK[i][gt],1,12)local gP=0;for gQ=1,gz do if gK[i][gt]==g(unit[gy.."_"..gQ].getData()).name then gP=gQ;break end end;local gR=q()if gL[i]==nil or gM[i]==nil or gR-gK[i][gx]>gA then local gS;local gT=0;if gP~=0 then gM[i]=g(unit[gy.."_"..gP].getData()).percentage;gL[i]=g(unit[gy.."_"..gP].getData()).timeLeft;if gL[i]=="n/a"then gL[i]=0 end else gT=l(gK[i][gs])-gK[i][gv]gM[i]=e(0.5+gT*100/gK[i][gu])gS=gK[i][gw]if gS<=gT then gL[i]=0 else gL[i]=e(0.5+gT/((gS-gT)/(gR-gK[i][gx])))end;gK[i][gw]=gT;gK[i][gx]=gR end end;if f_==gI then f_=f("%s %d",gJ,i)end;if gP==0 then f_=f_.." *"end;local gU;if gL[i]==0 then gU=""else gU=cB(gL[i])end;if gM[i]~=nil then local gV=e(gM[i]*2.55)local gW=f("rgb(%d,%d,%d)",255-gV,gV,0)local cf=""if gU~=""and gL[i]<120 or gM[i]<5 then cf="red "end;if BarFuelDisplay then gq=gq..f([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cc,gO,gW,gM[i],cc,gO,cc+2,gO+10,gM[i],gU)gq=gq..cb(cc,gN,f_,cf.."txtstart pdim txtfuel")gN=gN-30;gO=gO-30 else gq=gq..cb(cc,gN,f_,cf.."pdim txtfuel")gq=gq..cb(cc,gO,f("%d%% %s",gM[i],gU),"pdim txtfuel","fill:"..gW)gN=gN+30;gO=gO+30 end end end end end;local function gX(gY,dk)if dk<200000 and not aq or dk and aq then local gZ=0;if d(bu)>1 then gZ=45*math.log(d(bu),10)if bu<0 then gZ=-gZ end end;gY[#gY+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(gZ))end;return gY end;local function g_(h0)local h1=-bt;h0=h0-h0:project_on(h1)local h2=vec3(0,0,1)h2=h2-h2:project_on(h1)local h3=h2:cross(h1)local gZ=h2:angle_between(h0)*constants.rad2deg;if h0:dot(h3)<0 then gZ=360-gZ end;return gZ end;local function h4(gY,centerX,centerY,h5,h6,bM)local h7=circleRad;local h8=20;local h9=e(h5)if bM then for i=-45,45,5 do local ha=i;gY[#gY+1]=f([[<g transform="rotate(%f,%d,%d)">]],ha,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gY[#gY+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h7+h8-len,centerX,centerY+h7+h8)end;gY[#gY+1]=cb(centerX,centerY+h7+h8-35,h6,"pdim txt txtmid")gY[#gY+1]=cb(centerX,centerY+h7+h8-25,h9 .." deg","pdim txt txtmid")gY[#gY+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h5,centerX,centerY)gY[#gY+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h7+h8-20,centerX+5,centerY+h7+h8-20,centerX,centerY+h7+h8-15)gY[#gY+1]="</g>"end;local hb=h9;if bM then hb=g_(bo)end;local hc=20;local hd=e(hb)local he=0;local hf=centerY+h7+h8+20;local hg=centerX;if h6~="YAW"then hf=gl(130)hg=gk(960)end;local hh=[[<path class="txttick line" d="]]local hi=e(hd-(hc+10)-hd%5+0.5)for i=hi+60,hi,-5 do local cc=hg-(-i*5+hb*5)if i%10==0 then he=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gY[#gY+1]=cb(cc+5,hf-12,B)elseif i%5==0 then he=5 end;if he==10 then hh=f([[%s M %f %f v %d]],hh,cc,hf-5,he)else hh=f([[%s M %f %f v %d]],hh,cc,hf-2.5,he)end end;gY[#gY+1]=hh..[["/>]]gY[#gY+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],hg-5,hf+10,hg+5,hf+10,hg,hf+5)if bM then h6="HDG"end;gY[#gY+1]=cb(hg,hf+25,hd.."deg","pdim txt txtmid","")gY[#gY+1]=cb(hg,hf+35,h6,"pdim txt txtmid","")end;local function hj(gY,hk,h5,centerX,centerY,bM,hl,ey)local h7=circleRad;local hm=e(h7*3/5)if h7>0 then local hn=e(hk)local len=0;local hh=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h5,centerX,centerY)if not aq then hh=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gY[#gY+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h7-1,centerX,centerY)gY[#gY+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hn-30-hn%5+0.5),e(hn+30+hn%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cd=centerY+-i*5+hk*5;if len==30 then hh=f([[%s M %d %f h %d]],hh,centerX-hm-len,cd,len)if aq then gY[#gY+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h5,centerX,centerY,centerX-hm+10,cd,i)gY[#gY+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h5,centerX,centerY,centerX+hm-10,cd,i)if i==0 or i==180 or i==-180 then gY[#gY+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h5,centerX,centerY,centerX-hm+20,cd,hm*2-40)end else gY[#gY+1]=cb(centerX-hm+10,cd,i,"pdim txt txtmid")gY[#gY+1]=cb(centerX+hm-10,cd,i,"pdim txt txtmid")end;hh=f([[%s M %d %f h %d]],hh,centerX+hm,cd,len)else hh=f([[%s M %d %f h %d]],hh,centerX-hm-len,cd,len)hh=f([[%s M %d %f h %d]],hh,centerX+hm,cd,len)end end;gY[#gY+1]=hh..[["/>]]local ho="PITCH"if not bM then ho="REL PITCH"end;if hk>90 and not aq then hk=90-(hk-90)elseif hk<-90 and not aq then hk=-90-(hk+90)end;if h7>200 then if aq then if ey>Q then gY[#gY+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")gY[#gY+1]=cb(centerX,centerY+20,hl,"pdim txt txtmid")end;gY[#gY+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h5,centerX,centerY)else gY[#gY+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gY[#gY+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hm+25,centerY-5,centerX-hm+20,centerY,centerX-hm+25,centerY+5,centerX-hm+50,centerY+4,hn)gY[#gY+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hm-25,centerY-5,centerX+hm-20,centerY,centerX+hm-25,centerY+5,centerX+hm-30,centerY+4,hn)gY[#gY+1]="</g>"end;local hp=e(h7/3)gY[#gY+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hp,centerY,h7-hp)if not aq and bM then gY[#gY+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h5,centerX,centerY,centerX-hm+10,centerY,hm*2-20)end;gY[#gY+1]="</g>"if h7<200 then if aq and ey>Q then gY[#gY+1]=cb(centerX,centerY-h7,ho,"pdim txt txtmid")gY[#gY+1]=cb(centerX,centerY-h7+10,hn,"pdim txt txtmid")gY[#gY+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")gY[#gY+1]=cb(centerX,centerY+20,hl,"pdim txt txtmid")else gY[#gY+1]=cb(centerX,centerY-h7,ho,"pdim txt txtmid")gY[#gY+1]=cb(centerX,centerY-h7+15,hn,"pdim txt txtmid")end end end end;local function hq(gY,dk,bM)local hr=altMeterX;local hs=altMeterY;local ht=78;local hu=19;local hv=ao;if ao~=-1 then gY[#gY+1]=cb(hr+ht,hs+hu+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dk<200000 and not aq or dk and aq)then table.insert(gY,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hr-1,hs-4,ht+2,hu+6,hr+1,hs-1,ht-4,hu))local fL=0;local hw=1;local hx=0;local hy=dk<0;local hz=dk<planet.surfaceMaxAltitude;local hA=9;if hy then hA=0 end;local dk=d(dk)while fL<6 do local hB=11;local hC=16;local hD=9;local hE=14;local cf="altsm"if fL>2 then hC=hC+3;hB=hB+2;hE=hE+2;hD=hD-6;cf="altbig"end;if hy then cf=cf.." red"elseif hz then cf=cf.." orange"end;local hF=dk/hw%10;local hG=e(hF)local hH=e((hG+1)%10)local hI=hx;if fL==0 then hI=hF-hG;if hy then hI=1-hI end end;if hy and(fL==0 or hx~=0)then local hJ=hH;hH=hG;hG=hJ end;local hK=hC*(hI-1)local hL=hK+hC;local cc=hr+hD+(6-fL)*hB;local cd=hs+hE;gY[#gY+1]=cb(cc,cd+hK,hH,cf)gY[#gY+1]=cb(cc,cd+hL,hG,cf)fL=fL+1;hw=hw*10;if hG==hA then hx=hI else hx=0 end end;table.insert(gY,[[</g></g>]])end end;local function hM(eB)local hN=-math.deg(n(eB.y,eB.z))+180;hN=hN-90;if hN<0 then hN=360+hN end;if hN>180 then hN=-180+hN-180 end;return-hN end;local function hO(eB)local hb=math.deg(n(eB.y,eB.x))-90;if hb<-180 then hb=360+hb end;return hb end;local function hP(gY,eB,ey,centerX,centerY)if ey>5 and not aq or ey>Q then local h7=circleRad;local hQ=20;local hR=20;local hS=hM(eB)local hT=hO(eB)local hU=14;local hV=hU/2;local hW=-hT/hR*h7;local hX=hS/hQ*h7;local cc=centerX+hW;local cd=centerY+hX;local aj=y(hW^2+hX^2)local hY=[[<circle
                            cx="]]..cc..[["
                            cy="]]..cd..[["
                            r="]]..hV/hU..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cc..[["
                            cy="]]..cd..[["
                            r="]]..hV..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cc-hU..[[,]]..cd..[[ h ]]..hV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cc+hV..[[,]]..cd..[[ h ]]..hV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cc..[[,]]..cd-hU..[[ v ]]..hV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<h7 then gY[#gY+1]=hY else local gZ=n(hX,hW)local hZ=4;local h_=centerX+h7*math.cos(gZ)local i0=centerY+h7*math.sin(gZ)gY[#gY+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gZ*180/math.pi,h_,i0,h_-hZ,i0-hZ/2,hZ*2,hZ,h_+hZ,i0-hZ,hZ,hZ,-hZ,hZ)end;if not aq then local i1=vec3(eB)hS=hM(-i1)hT=hO(-i1)hW=-hT/hR*h7;hX=hS/hQ*h7;cc=centerX+hW;cd=centerY+hX;aj=y(hW^2+hX^2)if aj<h7 then local i2=[[<circle
                                    cx="]]..cc..[["
                                    cy="]]..cd..[["
                                    r="]]..hV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cc..[[,]]..cd-hU..[[ v ]]..hV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cc..[[,]]..cd..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cc..[[,]]..cd..[[)" />
                                <path
                                    d="M ]]..cc-hV..[[,]]..cd..[[ h ]]..hU..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cc..[[,]]..cd..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cc..[[,]]..cd..[[)"/>]]gY[#gY+1]=i2 end end end end;local function i3(gY,go,i4,i5)i4=e(i4+0.5)local gN=throtPosY+10;local gO=throtPosY+20;if m()==1 and not RemoteHud then gN=55;gO=65 end;local i6="CRUISE"local unit="km/h"local ci=i5;if go=="TRAVEL"or go=="AUTOPILOT"then i6="THROT"unit="%"ci=i4;local i7="dim"if i4<0 then i7="red"end;gY[#gY+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i7,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(i4),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gY[#gY+1]=cb(throtPosX+10,gN,i6,"pbright txtstart")gY[#gY+1]=cb(throtPosX+10,gO,f("%.0f %s",ci,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then i4=e(N*100+0.5)local i7="red"if i4<0 then i7="red"end;gY[#gY+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i7,1-d(i4),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gY[#gY+1]=cb(throtPosX+10,gN+40,"LIMIT","pbright txtstart")gY[#gY+1]=cb(throtPosX+10,gO+40,i4 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gY[#gY+1]=cb(throtPosX+10,gN-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then gY[#gY+1]=cb(throtPosX+10,gN-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i8(gY,i9)local ia=throtPosY-10;local ib=throtPosX+10;gY[#gY+1]=cb(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then ia=75 end;gY[#gY+1]=cb(ib,ia,e(i9).." km/h","pbright txtbig txtstart")end;local function ic(gY)gY[#gY+1]=cb(gk(1900),gl(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gY[#gY+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gY[#gY+1]=cb(gk(960),gl(550),"Warning: Invalid Control Scheme Detected","warnings")gY[#gY+1]=cb(gk(960),gl(600),"Keyboard Scheme must be selected","warnings")gY[#gY+1]=cb(gk(960),gl(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local id=gk(960)local ie=gl(860)local ig=gl(880)local ih=gl(900)local ii=gl(960)local ij=gl(200)local ik=gl(250)local il=gl(960)if m()==1 and not RemoteHud then ie=gl(135)ig=gl(155)ih=gl(175)ij=gl(115)ik=gl(95)end;if BrakeIsOn then gY[#gY+1]=cb(id,ie,"Brake Engaged","warnings")elseif L>0 then gY[#gY+1]=cb(id,ie,"Auto-Brake Engaged","warnings","opacity:"..L)end;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then gY[#gY+1]=cb(id,ij+50,"** STALL WARNING **","warnings")bZ("stall","SW",2)end end;if bK then gY[#gY+1]=cb(id,ij+90,"Flight Assist in Progress","warnings")end;if ax then gY[#gY+1]=cb(id,il,"Gyro Enabled","warnings")end;if GearExtended then if S then gY[#gY+1]=cb(id,ig,"Gear Extended","warn")else gY[#gY+1]=cb(id,ig,"Landed (G: Takeoff)","warnings")end;local im=co(a:getTargetGroundAltitude())gY[#gY+1]=cb(id,ih,"Hover Height: "..im,"warn")end;if a7 then gY[#gY+1]=cb(id,ii+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then if d(as-antigrav.getBaseAltitude())<501 then gY[#gY+1]=cb(id,ij+15,f("AGG On - Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gY[#gY+1]=cb(id,ij+15,f("AGG On - Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gY[#gY+1]=cb(id,ij+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gY[#gY+1]=cb(id,ij+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gY[#gY+1]=cb(id,ij+20,"Follow Mode Engaged","warn")elseif Reentry or an then gY[#gY+1]=cb(id,ij+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local im=co(HoldAltitude,2)if VertTakeOff then if by then im=co(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gY[#gY+1]=cb(id,ij,"VTO to "..im,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gY[#gY+1]=cb(id,ij,"Takeoff to "..AutopilotTargetName,"warn")else gY[#gY+1]=cb(id,ij,"Takeoff to "..im,"warn")end;if BrakeIsOn and not VertTakeOff then gY[#gY+1]=cb(id,ij+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gY[#gY+1]=cb(id,ij,"Altitude Hold: "..im,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gY[#gY+1]=cb(id,ij+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gY[#gY+1]=cb(id,ij+20,"Aligning trajectory","warn")elseif ar<0.05 then gY[#gY+1]=cb(id,ij+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then gY[#gY+1]=cb(id,ij,b9,"warn")end end;if BrakeLanding then if StrongBrakes then gY[#gY+1]=cb(id,ij,"Brake-Landing","warnings")else gY[#gY+1]=cb(id,ij,"Coast-Landing","warnings")end end;if ProgradeIsOn then gY[#gY+1]=cb(id,ij,"Prograde Alignment","crit")end;if RetrogradeIsOn then gY[#gY+1]=cb(id,ij,"Retrograde Alignment","crit")end;if bN then local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;gY[#gY+1]=cb(id,ik+20,bN,type)elseif ar==0 then local bU,bY=bS(br:normalize())if bY~=nil then local im=co(bY)local travelTime=aS.computeTravelTime(bs,0,bY)local io="Collision"if bU.noAtmosphericDensityAltitude>0 then io="Atmosphere"end;gY[#gY+1]=cb(id,ik+20,bU.name.." "..io.." "..cB(travelTime).." In "..im,"crit")end end;if VectorToTarget and not IntoOrbit then gY[#gY+1]=cb(id,ij+35,VectorStatus,"warn")end;gY[#gY+1]="</g>"return gY end;local function ip(ey)return e(A(ey*3.6,0)+0.5).." km/h"end;local function iq(gY)local ir=OrbitMapX;local is=OrbitMapY;local it=OrbitMapSize;local iu=4;local iv=15;local cc=0;local cd=0;local iw,ix,iy,iz;local function iA(type)local iB,E,ey,iC;if type=="Periapsis"then iB=orbit.periapsis.altitude;E=orbit.timeToPeriapsis;ey=orbit.periapsis.speed;iC=35 else iB=orbit.apoapsis.altitude;E=orbit.timeToApoapsis;ey=orbit.apoapsis.speed;iC=-35 end;gY[#gY+1]=f([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cc+iC,cd-5,ir+it/2-iw+iz,cd-5)gY[#gY+1]=cb(cc,cd,type)cd=cd+iv;local im=co(iB)gY[#gY+1]=cb(cc,cd,im)cd=cd+iv;gY[#gY+1]=cb(cc,cd,cB(E))cd=cd+iv;gY[#gY+1]=cb(cc,cd,ip(ey))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then is=is+iu;cc=ir+it+ir/2+iu;cd=is+it/2+5+iu;iw=it/4;iz=0;gY[#gY+1]=[[<g class="pbright txtorb txtmid">]]gY[#gY+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',it+ir*2,it+is,iu,iu)if orbit.periapsis~=nil and orbit.apoapsis~=nil then iy=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(iw*2)ix=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/iy*(1-orbit.eccentricity)iz=iw-orbit.periapsis.altitude/iy-planet.radius/iy;local iD=""if orbit.periapsis.altitude<=0 then iD='redout'end;gY[#gY+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iD,ir+it/2+iz+iu,is+it/2+iu,iw,ix)gY[#gY+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',ir+it/2+iu,is+it/2+iu,planet.radius/iy)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iA("Apoapsis")end;cd=is+it/2+5+iu;cc=ir-ir/2+10+iu;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iA("Periapsis")end;gY[#gY+1]=cb(ir+it/2+iu,planet.name,20+iu,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iE=orbit.timeToApoapsis/orbit.period*2*math.pi;local iF=iw*math.cos(iE)local iG=ix*math.sin(iE)gY[#gY+1]=f('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',ir+it/2+iF+iz+iu,is+it/2+iG+iu)end;gY[#gY+1]=[[</g>]]return gY else return gY end end;local function iH(gY)local cc=30;local cd=275;local iI={}local iJ={"Alt-4: AutoTakeoff to Target"}local iK={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iL={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iM={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iI,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then c1(iI,iJ)if ac and planet and ac.name==planet.name then table.insert(iI,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if by then table.insert(iI,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iI,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iI,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iI,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iI,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iI,"G: Takeoff to hover height, raise gear")else table.insert(iI,"G: Lowergear and Land")end else c1(iI,iK)table.insert(iI,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iI,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else c1(iI,iL)if shield_1 then table.insert(iI,"Alt-Shift-5: Toggle shield off and on")table.insert(iI,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iI,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iI,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iI,"Alt-Spacebar/C will raise/lower target height")table.insert(iI,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iI,"LALT+Mousewheel will lower/raise speed limit")end;c1(iI,iM)for i=1,#iI do cd=cd+12;gY[#gY+1]=cb(cc,cd,iI[i],"pdim txttick txtstart")end end;local function iN(iO,iP)local iQ;local iR=(iP-iO):normalize()local eD=(bv-iO):dot(iR)/iR:dot(iR)if eD<=0.then return(bv-iO):len()elseif eD>=(iP-iO):len()then return(bv-iP):len()end;local iS=iO+eD*iR;iQ=(iS-bv):len()return iQ end;local function iT()local iQ;local iU=nil;local iV=nil;local iW=nil;for cK,iX in pairs(b[0])do if iX.hasAtmosphere then local aj=iN(planet.center,iX.center)if iU==nil or aj<iU then iV=iX;iU=aj;iW=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dZ=iN(ac.center,iX.center)if dZ<iU then iV=iX;iU=dZ;iW=ac end end end end;local iY=gk(1770)local iZ=gl(330)if iU then local i_="txttick "local j0=500000;if iU<iV.radius+j0 or iU<iW.radius+j0 then if bH then i_="txttick red "else i_="txttick orange "end end;iQ=co(iU,2)bJ=cb(iY,iZ,"Pipe ("..iW.name.."--"..iV.name.."): "..iQ,i_.."pbright txtmid")end end;local j1={}function j1.HUDPrologue(gY)bH,bI=gi(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local j2=ay;local j3=az;local j4=ay;local j5=az;if gm()and not brightHud then j2=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.3+0.5)..[[)]]j3=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;gY[#gY+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],j2,j2,j4,j4,j3,j3,j5,j5,aG,aH)return gY end;function j1.DrawVerticalSpeed(gY,dk)gX(gY,dk)end;function j1.UpdateHud(gY)local hN=bB;local j6=bC;local h5=j6;local hk=hN;local i4=e(unit.getThrottle())local i9=bs*3.6;local i5=unit.getAxisCommandValue(0)local j7=gk(1770)local j8=gl(310)if AtmoSpeedAssist and bA then i5=K;i4=K*100 end;local go=gn()local h6="ROLL"if i4==nil then i4=0 end;if not bM then if bs>5 then hN=hM(bq)j6=hO(bq)else hN=0;j6=0 end;h6="YAW"end;if bI>50000 and not aq then local j9;j9=co(bI)gY[#gY+1]=cb(j7,j8,"PvP Boundary: "..j9,"pbright txtbig txtmid")end;gY[#gY+1]=ak;gY[#gY+1]=aD;gY[#gY+1]=gp;if bJ~=""then gY[#gY+1]=bJ end;if gq~=""then gY[#gY+1]=gq end;if gr~=""then gY[#gY+1]=gr end;gX(gY,as)if m()==0 or RemoteHud then if not gm()or brightHud then if bM then h4(gY,centerX,centerY,h5,h6,bM)hj(gY,hk,h5,centerX,centerY,bM,e(hO(bq)),bs)else h4(gY,centerX,centerY,j6,h6,bM)hj(gY,hN,j6,centerX,centerY,bM,e(j6),bs)end;hq(gY,as,bM)hP(gY,bq,bs,centerX,centerY)end end;i3(gY,go,i4,i5)i8(gY,i9)ic(gY)iq(gY)if showHelp then iH(gY)end;return gY end;function j1.HUDEpilogue(gY)gY[#gY+1]="</svg>"return gY end;function j1.ExtraData(gY)local ja=gk(1240)local jb=gl(55)local jc=jb+10;local jd;local je=0;local go=gn()if VertTakeOffEngine then go=go.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bs>20 then go=go.."-COLLISION ON"end;if UseExtra~="Off"then go="("..UseExtra..")-"..go end;if TurnBurn then go="TB-"..go end;if not stablized then go=go.."-DeCoupled"end;local jf=vec3(core.getWorldAcceleration()):len()/9.80665;jd=core.g()gY[#gY+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then ja=gk(1120)jb=gl(55)jc=jb+10 elseif aq then local jg=gk(770)gY[#gY+1]=cb(jg,jb,"ATMOSPHERE","pdim txt txtend")gY[#gY+1]=cb(jg,jc,f("%.2f",ar),"pdim txt txtend","")end;gY[#gY+1]=cb(ja,jb,"GRAVITY","pdim txt txtend")gY[#gY+1]=cb(ja,jc,f("%.2f",jd/9.80665),"pdim txt txtend")gY[#gY+1]=cb(ja,jb+20,"ACCEL","pdim txt txtend")gY[#gY+1]=cb(ja,jc+20,f("%.2f",jf),"pdim txt txtend")gY[#gY+1]=cb(gk(960),gl(180),go,"txtbig txtmid")end;function j1.DrawOdometer(gY,ad,TotalDistanceTravelled,ae)local jd;local jh=0;local ji=0;local je=0;local jj=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then je=LastMaxBrakeInAtmo else je=LastMaxBrake end;local jk,jl=aS.computeDistanceAndTime(bs,0,av,0,0,je)je=A(je/(av*gb),2).." g"local jm=a:maxForceForward()jd=core.g()if jd>0.1 then ji=av*jd;ji=A(ji/(av*gb),2).." g"jh=0.5*jm/jd;jh=jh>1000000 and A(jh/1000000,2).." kTons"or A(jh/1000,2).." Tons"end;jm=A(jm/(av*gb),2).." g"gY[#gY+1]=f([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gk(660),gk(700),gl(35),gk(960),gl(55),gk(1240),gl(35),gk(1280))if m()==0 or RemoteHud then gY[#gY+1]=cb(gk(700),gl(10),f("BrkTime: %s",cB(jl)),"txtstart")gY[#gY+1]=cb(gk(700),gl(20),f("Trip: %.2f km",ad),"txtstart")gY[#gY+1]=cb(gk(700),gl(30),f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gY[#gY+1]=cb(gk(830),gl(10),f("BrkDist: %s",co(jk)),"txtstart")gY[#gY+1]=cb(gk(830),gl(20),"Trip Time: "..cB(ae),"txtstart")gY[#gY+1]=cb(gk(830),gl(30),"Total Time: "..cB(TotalFlightTime),"txtstart")gY[#gY+1]=cb(gk(970),gl(20),f("Mass: %s",jj),"txtstart")gY[#gY+1]=cb(gk(1240),gl(10),f("Max Brake: %s",je),"txtend")gY[#gY+1]=cb(gk(1240),gl(30),f("Max Thrust: %s",jm),"txtend")if jd>0.1 then gY[#gY+1]=cb(gk(970),gl(30),f("Max Thrust Mass: %s",jh),"txtstart")gY[#gY+1]=cb(gk(1240),gl(20),f("Req Thrust: %s",ji),"txtend")else gY[#gY+1]=cb(gk(970),gl(30),"Max Mass: n/a","txtstart")gY[#gY+1]=cb(gk(1240),gl(20),"Req Thrust: n/a","txtend")end end;gY[#gY+1]="</g>"return gY end;function j1.DrawWarnings(gY)return ic(gY)end;function j1.DisplayOrbitScreen(gY)return iq(gY)end;function j1.DisplayMessage(gY,im)if im~="empty"then local cd=310;for jn in string.gmatch(im,"([^\n]+)")do cd=cd+35;gY[#gY+1]=cb("50%",cd,jn,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function j1.DrawDeadZone(gY)gY[#gY+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function j1.UpdatePipe()if aq then bJ=""return end;iT()end;function j1.DrawSettings(gY)if#bE>0 then local cc=gk(640)local cd=gl(200)gY[#gY+1]=[[<g class="pbright txtvspd txtstart">]]for cK,cL in pairs(bE)do gY[#gY+1]=cb(cc,cd,cL..": ".._G[cL])cd=cd+20;if cK%12==0 then cc=cc+gk(350)cd=gl(200)end end;gY[#gY+1]=cb(gk(640),gl(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gY[#gY+1]="</g>"end;return gY end;local jo;local jp=gk(1770)local jq=gl(350)local jr=gl(15)local js=gk(1370)local bR,jt;local ju=0;function j1.DrawRadarInfo()local function jv()if radarPanelID~=nil and ju==0 then t(radarPanelID)radarPanelID=nil;if jo~=nil then t(jo)jo=nil end else if ju==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jo=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;ju=0 end end;local f3,f4,f2,f5,f6,e_=aY.GetRadarHud()local B=f5 or 0;if f2>0 then if CollisionSystem then bR=B.."/"..f6 .." Plotted : "..f2-f6 .." Ignored"else bR="Radar Contacts: "..f2 end;gp=cb(jp,jq,bR,"pbright txtbig txtmid")if#e_>0 then gp=gp..cb(js,jr,"Friendlies In Range","pbright txtbig txtmid")for cK,cL in pairs(e_)do jr=jr+20;gp=gp..cb(js,jr,bP[1].getConstructName(cL),"pdim txtmid")end end;if f3==nil and jo==nil then ju=1;jv()end;if f3~=nil and jo~=nil then jv()end;if radarPanelID==nil then jv()end else if f4 then gp=cb(jp,jq,bQ.." Radar: Jammed","pbright txtbig txtmid")else gp=cb(jp,jq,"Radar: No "..bQ.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ju=0;jv()end end end;function j1.DrawTanks()if fuelX~=0 and fuelY~=0 then gq=cb(fuelX,fuelY,"","txtstart pdim txtfuel")gH(fuelX,"Atmospheric ","ATMO",aI,gF,gG)gH(fuelX+120,"Space fuel t","SPACE",aJ,gD,gE)gH(fuelX+240,"Rocket fuel ","ROCKET",aK,gB,gC)end end;function j1.DrawShield()local jw=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local jx=core.getPvPTimer()local jy=shield_1.getResistances()local jz="A: "..10+jy[1]*100 .."% / E: "..10+jy[2]*100 .."% / K:"..10+jy[3]*100 .."% / T: "..10+jy[4]*100 .."%"local cc,cd=shieldX-60,shieldY+30;local jA=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gV=e(jA*2.55)local gW=f("rgb(%d,%d,%d)",255-gV,gV,0)local cf=""gr=cb(cc,cd,"","txtmid pdim txtfuel")if jA<10 and jw~="Shield Disabled"then cf="red "end;jx=jx>0 and"   PvPTime: "..cB(jx)or""gr=gr..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],cc,cd,gW,jA*2,cc,cd,cc+2,cd+10,jA,jx)gr=gr..cb(cc,cd-5,jw,cf.."txtstart pbright txtbig")gr=gr..cb(cc,cd+30,jz,cf.."txtstart pbright txtsmall")end;return j1 end;local function jB()local function jC(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function jD()local function jE(jF,jG)return jF.name<jG.name end;bG={}for cK,cL in pairs(b[0])do bG[#bG+1]={name=cL.name,index=cK}end;table.sort(bG,jE)end;local function jH(jI)for cK,cL in pairs(jI)do if cL.name and cL.name==CustomTarget.name then return cK end end;return-1 end;local function jJ()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local jK=bG[AutopilotTargetIndex].index;local jL=b[0][jK]if jL.center then AutopilotTargetName=jL.name;ac=aR[0][jK]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jL;for _,cL in pairs(aR[0])do if cL.name==CustomTarget.planetname then ac=cL;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jM(h1)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if h1==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then jJ()else local jK=bG[AutopilotTargetIndex].index;local jL=b[0][jK]if jL~=nil and jL.name=="Space"or iphCondition=="Custom Only"and jL.center or iphCondition=="No Moons"and string.find(jL.name,"Moon")~=nil then if h1==nil then jM()else jM(1)end else jJ()end end else a2="Disengage autopilot before changing Interplanetary Helper"bZ("iph","AP")end end;local function jN()local fL=-1;fL=jH(b[0])if fL>-1 then table.remove(b[0],fL)end;fL=-1;fL=jH(SavedLocations)if fL~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fL)end;jM()jD()end;local function jO(f_,position,hJ,jP)if dbHud_1 or hJ then local p=jC(position)local jd=p.gravity;if jP then jd=unit.getClosestPlanetInfluence()end;local jQ={position=position,name=f_,planetname=p.name,gravity=jd,safe=jP}if not hJ then SavedLocations[#SavedLocations+1]=jQ else for cK,cL in pairs(b[0])do if cL.name and f_==cL.name then table.remove(b[0],cK)end end end;table.insert(b[0],jQ)jD()jJ()a2="Location saved as "..f_.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local jR={}function jR.UpdateAtlasLocationsList()jD()end;function jR.UpdateAutopilotTarget()jJ()end;function jR.adjustAutopilotTargetIndex(h1)jM(h1)end;function jR.findAtlasIndex(jI)jH(jI)end;function jR.UpdatePosition(jS)local fL=jH(SavedLocations)if fL~=-1 then if jS~=nil then SavedLocations[fL].name=jS;AutopilotTargetIndex=AutopilotTargetIndex-1;jM()else local jT=SavedLocations[fL]jT.gravity=unit.getClosestPlanetInfluence()jT.position=bv;jT.safe=true end;a2=SavedLocations[fL].name.." position updated ("..SavedLocations[fL].planetname..")"else a2="Name Not Found"end end;function jR.AddNewLocation(f_,position,hJ,jP)jO(f_,position,hJ,jP)end;function jR.ClearCurrentPosition()jN()end;for cK,cL in pairs(SavedLocations)do table.insert(b[0],cL)end;jD()if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end;jR.UpdateAutopilotTarget()return jR end;local function jU()local cv={}local function jV(ey)local jW=AutopilotEndSpeed;if not Autopilot then jW=0 end;if not aq then return aS.computeDistanceAndTime(ey,jW,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(ey,jW,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jX(ey)local jW=AutopilotEndSpeed;if not Autopilot then jW=0 end;return aS.computeDistanceAndTime(ey,jW,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local jY=false;local jZ=0;function cv.GetAutopilotBrakeDistanceAndTime(ey)return jV(ey)end;function cv.GetAutopilotTBBrakeDistanceAndTime(ey)return jX(ey)end;local function j_(k0,k1,k2)k1=k1:project_on_plane(k0)k2=k2:project_on_plane(k0)return n(k1:cross(k2):dot(k0),k1:dot(k2))end;local function k3()local function k4()local k5=-1;local k6=-1;if vBooster then k5=vBooster.getDistance()end;if hover then k6=hover.getDistance()end;if k5~=-1 and k6~=-1 then if k5<k6 then return k5 else return k6 end elseif k5~=-1 then return k5 elseif k6~=-1 then return k6 else return-1 end end;local k7=k4()local k8=-1;if telemeter_1 then k8=telemeter_1.getDistance()end;if k7~=-1 and k8~=-1 then if k7<k8 then return k7 else return k8 end elseif k7~=-1 then return k7 else return k8 end end;local function k9(planet,dV,ka)local function kb(kc,de)local e0=vec3(de)if kc.id==0 then return setmetatable({latitude=e0.x,longitude=e0.y,altitude=e0.z,id=0,systemId=kc.systemId},MapPosition)end;local e1=e0-kc.center;local aj=e1:len()local dk=aj-kc.radius;local di=0;local dj=0;if not cl(aj,0)then local e2=n(e1.y,e1.x)dj=e2>=0 and e2 or 2*math.pi+e2;di=math.pi/2-math.acos(e1.z/aj)end;return setmetatable({latitude=math.deg(di),longitude=math.deg(dj),altitude=dk,id=kc.id,systemId=kc.systemId},MapPosition)end;local kd=kb(planet,dV)kd="::pos{"..kd.systemId..","..kd.id..","..kd.latitude..","..kd.longitude..","..kd.altitude.."}"if ka then return kd else system.setWaypoint(kd)return true end end;local ke=false;function cv.showWayPoint(planet,dV,ka)return k9(planet,dV,ka)end;function cv.APTick()local function kf()if bO and not BrakeLanding then local bX=bO[1]local g0,g1=bO[2],bO[3]local kg=math.min(g0,g1 or g0)local kh=kg/bs;local ki=AutoTakeoff and(bs<42 or ao~=-1)local kj=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if kj and not ki and(a8*1.5>kg or kh<1)then BrakeIsOn=true;ch(0)if AltitudeHold then ct()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cw()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if kh<11 then bN=bX.name.." COLLISION "..cB(kh).." / "..co(kg,2)else bN=bX.name.." collision "..cB(kh)end;if kh<6 then bZ("alarm","AL",2)end else bN=false end end;local function kk(bT,kl,km)local function kn(bT,dH)bT=vec3(bT)dH=vec3(dH):normalize()local d0=bT*dH;return d0.x+d0.y+d0.z end;local ko=0.001;local kp=1;if not aq or not b2 or ao~=-1 or bs<Q then if km==nil then km=DampingMultiplier end;if kl==nil then kl=ko end;bT=vec3(bT):normalize()local kq=vec3()-bT;local kr=-kn(kq,core.getConstructWorldOrientationRight())*kp;local ks=-kn(kq,core.getConstructWorldOrientationUp())*kp;if aB==0 then aB=kr/2 end;if aC==0 then aC=ks/2 end;if d(kr)<0.1 then V=V-kr*2 else V=V-(kr+(kr-aB)*km)end;if d(ks)<0.1 then U=U+ks*2 else U=U+ks+(ks-aC)*km end;aB=kr;aC=ks;if d(kr)<kl and d(ks)<kl then return true end;return false elseif b2 and ao==-1 then bT=br;if km==nil then km=DampingMultiplier end;if kl==nil then kl=ko end;bT=vec3(bT):normalize()local kq=bo-bT;local kr=-kn(kq,core.getConstructWorldOrientationRight())*kp;local ks=-kn(kq,core.getConstructWorldOrientationUp())*kp;if aB==0 then aB=kr/2 end;if aC==0 then aC=ks/2 end;if d(kr)<0.1 then V=V-kr*5 else V=V-(kr+(kr-aB)*km)end;if d(ks)<0.1 then U=U+ks*5 else U=U+ks+(ks-aC)*km end;aB=kr;aC=ks;if d(kr)<kl and d(ks)<kl then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=k3()E=q()b3=E;if CollisionSystem then kf()end;if antigrav then by=antigrav.getState()==1 end;local kt=1;local ku=1;local kv=E-b3;local kw=-math.deg(j_(bn,br,bo))local kx=math.deg(j_(bp,br,bo))local h1=bt*-1;b2=aq and kw<-YawStallAngle or kw>YawStallAngle or kx<-PitchStallAngle or kx>PitchStallAngle;local ky=system.getMouseDeltaX()local kz=system.getMouseDeltaY()if InvertMouse and not a1 then kz=-kz end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local jd=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=ag+ky;ah=ah+kz end else ag=0;ah=0 end else ag=ag+ky;ah=ah+kz;aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(kz,-100,100)+0.5)*2*kt;V=(-utils.smoothstep(ky,-100,100)+0.5)*2*ku end end end end;local kA=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not kA then a2="Space Speed Engine Shutoff reached"ch(0)end;if not kA and LastIsWarping then if not BrakeIsOn then cy()end;if Autopilot then cw()end end;LastIsWarping=kA;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not jY then BrakeIsOn=true;jY=true elseif not AtmoSpeedAssist and jY then if bs<b7/3.6 then BrakeIsOn=false;jY=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local kB=false;if CustomTarget~=nil and al~=1 then kB=kk(CustomTarget.position-bv,0.1)else kB=kk(vec3(br),0.01)end;b0=true;if kB then ck(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cz()end elseif aq and AtmoSpeedAssist then ch(1)end elseif bs>Q then kk(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then kk(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cz()al=false;an=true else al=false;cw()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then cw()an=false end;if VertTakeOff then b0=true;local kC=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then kC=antigrav.getBaseAltitude()end;if as<kC-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=kC then if by then if Autopilot or VectorToTarget then cr()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bZ("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bZ("vtoc","VT")cr()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;ck(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=kC;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kD=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kD)local kE=r(vTpitchPID:get(),-1,1)U=kE end end;if IntoOrbit then local kq;local kF=false;local kG=co(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget then kq=CustomTarget.position-bv end;local kH,kI=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local kJ=bC;if not bc then local kK=false;local kL=false;ch(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..kG;if be.VectorToTarget then kk(kq:normalize():project_on_plane(bt))kF=bo:dot(kq:project_on_plane(bn):normalize())>0.95 else kk(br)kF=kw<0.5;if bs<150 then kF=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then kK=true else kK=false end;if kJ<=bb+1 and kJ>=bb-1 then kL=true else kL=false end;if kK and kL and kF then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then kk(kq:normalize():project_on_plane(bt))elseif bs>150 then kk(br)end;U=0;if be.VectorToTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and kq:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or kq:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bZ("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;cs()cz()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bg*0.9 and as<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;ch(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"bZ("orCom","OB")cs()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..kG;bd=true;ck(kI*3.6+1)local kM=bg-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(kM-bu*r(utils.smoothstep(2000-kM,-2000,2000)^6*10,1,10))ba=r(VSpdPID:get(),-60,60)end end else local kN=2.75;local kO=d(A(kH*kN))local kP=kO%50;if kP>0 then kO=kO-kP+50 end;BrakeIsOn=false;if as<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..kG;ba=utils.map(bu,200,0,-15,80)elseif as>=bg*0.8 and as<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..kG;kO=kO*0.75;ba=utils.map(bu,100,-100,-15,65)elseif as>=bg*1.15 and as<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..kG;kO=kO*0.75;if bu<0 or bd then ba=utils.map(as,bg*1.5,bg*1.01,-30,0)else ba=utils.map(as,bg*0.99,bg*1.5,0,30)end elseif as>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..kG;ba=-65;local kQ=utils.map(bu,-150,-400,1,0.55)kO=kO*kQ end;ck(e(kO))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kR=ba-bB;OrbitPitchPID:inject(kR)local kS=r(OrbitPitchPID:get(),-0.5,0.5)U=kS end end;if Autopilot and ar==0 and not al then local function kT(bR,orbit)system.print(bR)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"ch(0)P=false;a2=bR;bZ("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;cs()end end;local kU,kV=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kW=(CustomTarget.position-ac.center):normalize()local kX=kW:project_on_plane((ac.center-bv):normalize()):normalize()local kY=ac.center+kX*(ac.radius+AutopilotTargetOrbit)local kZ=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-kY):len()<(bv-kZ):len()then kU=kY else kU=kZ;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kU;aX.showWayPoint(ac,AutopilotTargetCoords)kV=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;kV=true;AutopilotRealigned=true;TargetSet=true;kU=CustomTarget.position+(bv-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=kU end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kW=(bv+br*100000-ac.center):normalize()local kX=kW:project_on_plane((ac.center-bv):normalize()):normalize()if kX:len()<1 then kW=(bv+bo*100000-ac.center):normalize()kX=kW:project_on_plane((ac.center-bv):normalize()):normalize()end;kU=ac.center+kX*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kU;TargetSet=true;kV=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kU)-bv):len()local bU,bV,bW=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(bX)if bX.noAtmosphericDensityAltitude>0 then return bX.radius+bX.noAtmosphericDensityAltitude else return bX.radius+bX.surfaceMaxAltitude*1.5 end end)local bY=bV;if bW~=nil and bV~=nil then bY=math.min(bW,bV)end;if bY~=nil and bY<AutopilotDistance and bU.name==ac.name then AutopilotDistance=bY end;local kB=true;local k_=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local im=co(k_)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..im..'"}')local a8,a9;if not TurnBurn then a8,a9=jV(bs)else a8,a9=jX(bs)end;if bs>50 and AutopilotAccelerating then local kq=vec3(kU)-bv;local l0=r(math.deg(j_(bn,br:normalize(),kq:normalize()))*bs/500,-90,90)local l1=r(math.deg(j_(bp,br:normalize(),kq:normalize()))*bs/500,-90,90)if d(l0)<20 and d(l1)<20 then l0=l0*2;l1=l1*2 end;if d(l0)<2 and d(l1)<2 then l0=l0*2;l1=l1*2 end;local kw=-math.deg(j_(bn,bo,br:normalize()))local kx=-math.deg(j_(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(l1-kx)local l2=r(apPitchPID:get(),-1,1)U=U+l2;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(l0-kw)local l3=r(apYawPID:get(),-1,1)V=V+l3;kV=true;if d(l0)>2 or d(l1)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bZ("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end end elseif AutopilotAccelerating and bs<=50 then kk((kU-bv):normalize())end;if k_<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(k_)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bU,bY=bS((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if bU~=nil and ac.name~=bU.name and bY<AutopilotDistance then a2="Collision with "..bU.name.." in "..co(bY).."\nClear LOS to continue."ai=5;ke=true else ke=false;a2=""end end end;if not ke then if not AutopilotCruising and not AutopilotBraking and not kV then kB=kk((kU-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kB=kk(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;ch(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local l4=unit.getThrottle()if AtmoSpeedAssist then l4=K end;local l5=99999;local jf=-vec3(core.getWorldAcceleration()):dot(br:normalize())local l6=r(br:dot((kU-bv):normalize()),0,bs)if l6>0 or jf>0 then l5=aS.computeTravelTime(l6,jf,AutopilotDistance-a8)end;if bq:len()>=MaxGameVelocity or l4==0 and P or warmup/4>l5 then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bZ("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;ch(0)end;local l7=AutopilotDistance;if l7<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<jZ and bI>2000 then cw()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;jZ=bI else jZ=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bZ("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;ch(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then ch(1,true)end;local _,kI=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local kq;if CustomTarget~=nil then kq=CustomTarget.position-bv end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bs<50 then kT("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bs<=kI and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kT("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif CustomTarget.planetname~="Space"and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bZ("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=kI then if CustomTarget~=nil then if br:normalize():dot(kq:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bZ("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else kT("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else kT("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then kT("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local l7=AutopilotDistance;if l7<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<jZ and bI>2000 then cw()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;jZ=bI else jZ=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bZ("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local l4=unit.getThrottle()if AtmoSpeedAssist then l4=K end;if l4>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end;AutopilotCruising=false end else if kB then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif kB and not ke then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end;if not P then ch(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bZ("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;ch(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local l1=0;local eC=bv+vec3(unit.getMasterPlayerRelativePosition())local l8=eC-bv;local l9=vec3(l8):project_on(bo):len()local la=vec3(l8):project_on(bp):len()local aj=y(l9*l9+la*la)kk(l8:normalize())local lb=40;local lc=aj<lb;local ld=100;local le=r((aj-lb)/2,10,ld)U=0;local kB=d(V)<0.1;if kB and bs<le and not lc then BrakeIsOn=false;l1=-20 else BrakeIsOn=true;l1=0 end;local lf=0;if d(l1-bB)>lf then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(l1-bB)local l2=pitchPID:get()U=l2 end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local lg=LastMaxBrakeInAtmo;if lg then lg=lg*r(bs/100,0.1,1)*ar else lg=LastMaxBrake end;if ar<0.01 then lg=LastMaxBrake end;local lh=bo:project_on_plane(bt):normalize():dot(br)local li=vec3(core.getWorldAirFrictionAcceleration())local lj=li:len()*av;if lh>100 then a8,a9=aS.computeDistanceAndTime(lh,100,av,0,0,lg)local lk,ll=aS.computeDistanceAndTime(100,0,av,0,0,lg*0.55)a8=a8+lk else a8,a9=aS.computeDistanceAndTime(lh,0,av,0,0,lg*0.55)end;local kM=HoldAltitude-as-bu;local lm=200+bs;if Reentry or al then minMax=2000+bs end;local ln=1;if AutoTakeoff then ln=r(bs/100,0.1,1)end;local l1=(utils.smoothstep(kM,-lm,lm)-0.5)*2*MaxPitch*ln;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then l1=(utils.smoothstep(kM,-lm*r(20-19*ar*10,1,20),lm*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*ln end;if not AltitudeHold then l1=0 end;if LockPitch~=nil then if bM and not IntoOrbit then l1=LockPitch else LockPitch=nil end end;b0=true;local lo=U;if Reentry then local lp=e(b7)local lq,lr=aS.computeDistanceAndTime(bs,lp/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)lq=lq==-1 and 5000 or lq;local ls=as-(planet.noAtmosphericDensityAltitude+lq)local lt=as>planet.noAtmosphericDensityAltitude+lq*1.35;if lt then l1=ReEntryPitch;if bs<=lp/3.6 and bs>lp/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;ch(1)end elseif bA and not lt and not aq then ck(lp,true)end;if bA then if bs>lp/3.6 and not lt then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then l1=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;l1=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and lt then b0=true elseif not lt then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=lp)then ck(lp)end;if bs<lp/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then kk(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local kq;if bK then if type(bK)=="table"then kq=bK elseif bK<3 and bK>0 then kq=-bt:cross(br)*5000 elseif bK>=3 then kq=bt:cross(br)*5000 elseif bK<0 then kq=br*25000 end elseif CustomTarget~=nil then kq=CustomTarget.position-bv else kq=ac.center-bv end;local l0=math.deg(j_(bt:normalize(),br,kq))*2;local lu=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local lv=1000+bs;local lw=(utils.smoothstep(kM-bu*10,-lv,lv)-0.5)*2*MaxPitch;local lx=r(90-lw,0,180)b4=r(l0*2,-lx,lx)local ly=l0;l0=r(r(l0,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(lu)+4*(bB-l1)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local lz=1;if b4~=0 then lz=d(lu/b4)end;lz=(90-r(d(b4-bC),0,90))/90;local lA=l1;if d(bC)>90 then lA=-lA end;l1=lz*r(r(lA*math.cos(lu),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(ly)*math.sin(lu),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;l0=r(l0,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lB=kw-l0;if bK and d(lB)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then ct()end;bK=nil;bZ("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lB)local l3=r(yawPID:get(),-1,1)V=V+l3 elseif aq and ao>-1 or bs<minRollVelocity then kk(kq)elseif b2 and ar>0.01 then if(kw<-YawStallAngle or kw>YawStallAngle)and ar>0.01 then kk(br)end;if(kx<-PitchStallAngle or kx>PitchStallAngle)and ar>0.01 then l1=r(bB-kx,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local kC=planet:getAltitude(CustomTarget.position)local ls=kq:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and ls<=a8 and(br:project_on_plane(bt):normalize():dot(kq:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"ch(0)if AltitudeHold then ct()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(lh<0.1 or ls<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<ls)then if not by then bZ("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=ls end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local kq=CustomTarget.position-bv;local kC=planet:getAltitude(CustomTarget.position)local ls=y(kq:len()^2-(as-kC)^2)local lg=LastMaxBrakeInAtmo;if lg then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,lg/2)StrongBrakes=true;if ls<=a8+bs*kv/2 and br:project_on_plane(bt):normalize():dot(kq:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cz()end end;LastDistanceToTarget=ls end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cs()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then kk(br)l1=r(bB-kx,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=lo;local k8=-1;if BrakeLanding then l1=0;local lC=false;local lD=30;if aT~=nil and aT>0 then local lE=r(ar,0.4,2)local lg=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*lE;local lF=aT*lE+lg-jd;local lG=lg/2-jd;local lH=bs-y(d(lG/2)*20/(0.5*av))*utils.sign(lG)if lH<0 then lH=0 end;local lI;if bs>100 then local lJ,_=aS.computeDistanceAndTime(bs,100,av,0,0,lg)local lK,_=aS.computeDistanceAndTime(100,0,av,0,0,y(lg))lI=lJ+lK else lI=aS.computeDistanceAndTime(bs,0,av,0,0,y(lg))end;if lI<20 then BrakeIsOn=false else local lL=0;if lH>100 then local lM,_=aS.computeDistanceAndTime(lH,100,av,0,0,lF)local lN,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*lE+y(lg)-jd)lL=lM+lN else lL,_=aS.computeDistanceAndTime(lH,0,av,0,0,aT*lE+y(lg)-jd)end;lL=(lL+15+bs*kv)*1.1;local lO=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lO then local kC=planet:getAltitude(CustomTarget.position)local lP=as-kC-100;local kq=CustomTarget.position-bv;local lQ=y(kq:len()^2-(as-kC)^2)if lQ>100 then lO=false elseif lP<=lL or lL==-1 then BrakeIsOn=true;lC=true else BrakeIsOn=false;lC=true end end;if not lO and CalculateBrakeLandingSpeed then if lL>=lD then BrakeIsOn=true else BrakeIsOn=false end;lC=true end end end;if not bA then ch(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;k8=ao;if k8>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bZ("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-h1)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not lC then BrakeIsOn=true elseif not lC then BrakeIsOn=false end end;if AutoTakeoff or am then local bU,bW,bV;if AutopilotTargetCoords~=nil then bU,bW,bV=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(bX)return bX.radius+bX.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;ch(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(l1)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;ch(0)elseif am then ch(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(bU==nil or bU.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then ch(0)end;AutopilotAccelerating=true end end;local lR=ao>-1;local lS=bB;if(VectorToTarget or am or bK)and not lR and bs>minRollVelocity and ar>0.01 then local lu=math.rad(d(bC))lS=bB*d(math.cos(lu))+kx*math.sin(lu)end;local lT=r(l1-lS,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then lT=r(l1-lS,-85,MaxPitch)elseif ar<0.01 then lT=r(l1-lS,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or lR or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lT)local l2=pitchPID:get()U=U+l2 end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=k3()return cv end;function script.onStart()local lU={}local lV={}local lW=false;local function lX()local function lY(lZ)local l_=dbHud_1.hasKey;for cK,cL in pairs(lZ)do if l_(cL)then local d0=g(dbHud_1.getStringValue(cL))if d0~=nil then _G[cL]=d0;lW=true end end end end;if dbHud_1 then if not useTheseSettings then lY(c4())coroutine.yield()lY(c)else lY(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;lW=false end;coroutine.yield()if lW then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function m0()local function m1(m2,m3)if m2>m3 then m3=m2 end;local m4,m5=0,0;if ContainerOptimization>0 then m4=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then m5=FuelTankOptimization*0.05 end;m3=m3*(1-(m4+m5))return m3 end;local m6=core.getElementNameById;local m7=fuelX~=0 and fuelY~=0;for cK in pairs(at)do local type=core.getElementTypeById(at[cK])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cK])),'^.*vertical.*$')and core.getElementForwardById(at[cK])[3]>0 then bx=true end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cK])),'^.*vertical.*$')then local m8=core.getElementForwardById(at[cK])if m8[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local m9=j(at[cK])if m9>10000 then G=110 elseif m9>1000 then G=55 elseif m9>150 then G=27 end end;aL=aL+j(at[cK])if m7 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local m9=j(at[cK])local jj=l(at[cK])local m2=0;local gR=q()if type=="Atmospheric Fuel Tank"then local m3=400;local ma=35.03;if m9>10000 then m3=51200;ma=5480 elseif m9>1300 then m3=6400;ma=988.67 elseif m9>150 then m3=1600;ma=182.67 end;m2=jj-ma;if fuelTankHandlingAtmo>0 then m3=m3+m3*fuelTankHandlingAtmo*0.2 end;m3=m1(m2,m3)aI[#aI+1]={at[cK],m6(at[cK]),m3,ma,m2,gR}end;if type=="Rocket Fuel Tank"then local m3=320;local ma=173.42;if m9>65000 then m3=40000;ma=25740 elseif m9>6000 then m3=5120;ma=4720 elseif m9>700 then m3=640;ma=886.72 end;m2=jj-ma;if fuelTankHandlingRocket>0 then m3=m3+m3*fuelTankHandlingRocket*0.1 end;m3=m1(m2,m3)aK[#aK+1]={at[cK],m6(at[cK]),m3,ma,m2,gR}end;if type=="Space Fuel Tank"then local m3=600;local ma=35.03;if m9>10000 then m3=76800;ma=5480 elseif m9>1300 then m3=9600;ma=988.67 elseif m9>150 then m3=2400;ma=182.67 end;m2=jj-ma;if fuelTankHandlingSpace>0 then m3=m3+m3*fuelTankHandlingSpace*0.2 end;m3=m1(m2,m3)aJ[#aJ+1]={at[cK],m6(at[cK]),m3,ma,m2,gR}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function mb()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cL in pairs(door)do cL.toggle()end end;if switch then for _,cL in pairs(switch)do cL.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cL in pairs(forcefield)do cL.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function mc(md,me,mf,mg,cc,cd,mh,mi,mj,mk)local ml={enableName=md,disableName=me,width=mf,height=mg,x=cc,y=cd,toggleVar=mh,toggleFunction=mi,drawCondition=mj,hovered=false}if mk then table.insert(lV,ml)else table.insert(lU,ml)end;return ml end;local function mm(mn)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif mn=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif mn=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif mn=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=c4(mn)showHud=false else bE={}showHud=true end end;local function mo()bD=not bD;if bD then aF=lV;a2="Hold SHIFT to see Settings"bF=showHud else aF=lU;a2="Hold SHIFT to see Control Buttons"mm()showHud=bF end end;local function mp(cL)_G[cL]=not _G[cL]if _G[cL]then a2=cL.." set to true"else a2=cL.." set to false"end;if cL=="showHud"then bF=_G[cL]elseif cL=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function mq()local mr=50;local ms=340;local cc=500;local cd=aH/2-400;local mt=0;for cK,cL in pairs(c4("boolean"))do if type(_G[cL])=="boolean"then mc(cL,cL,ms,mr,cc,cd,function()return _G[cL]end,function()mp(cL)end,function()return true end,true)cd=cd+mr+20;if mt==9 then cc=cc+ms+20;cd=aH/2-400;mt=0 else mt=mt+1 end end end;mc("Control View","Control View",ms,mr,10,aH/2-500,function()return true end,mo,function()return true end,true)mc("View Handling Settings",'Hide Handling Settings',ms,mr,10,aH/2-(500-mr),function()return showHandlingVariables end,function()mm("handling")end,function()return true end,true)mc("View Hud Settings",'Hide Hud Settings',ms,mr,10,aH/2-(500-mr*2),function()return showHudVariables end,function()mm("hud")end,function()return true end,true)mc("View Physics Settings",'Hide Physics Settings',ms,mr,10,aH/2-(500-mr*3),function()return showPhysicsVariables end,function()mm("physics")end,function()return true end,true)end;local function mu()local function jO()local position=bv;local f_=planet.name..". "..#SavedLocations;if bP[1]then local dc,_=bP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dc~=nil and dc~=""then f_=f_.." "..bP[1].getConstructName(dc)end end;return aW.AddNewLocation(f_,position,false,true)end;local function mv()TurnBurn=not TurnBurn end;local function mw(mx)if mx==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function my()aW.UpdatePosition()end;local function jN()aW.ClearCurrentPosition()end;local function mz()local f_=AutopilotTargetName;if f_==nil then local im=co((bv-CustomTarget.position):len())f_=CustomTarget.name.." "..im end;if f_==nil then f_="None"end;return"Engage Autopilot: "..f_ end;local function mA()local f_=AutopilotTargetName;if f_==nil then f_=CustomTarget.name end;if f_==nil then f_="None"end;return"Disable Autopilot: "..f_ end;local function mB()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bZ("folOn","F")else bZ("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local mr=50;local ms=260;local mC=mc("Enable Brake Toggle","Disable Brake Toggle",ms,mr,aG/2-ms/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)mc("Align Prograde","Disable Prograde",ms,mr,aG/2-ms/2-50-mC.width,aH/2-mr+380,function()return ProgradeIsOn end,function()mw(1)end)mc("Align Retrograde","Disable Retrograde",ms,mr,aG/2-ms/2+mC.width+50,aH/2-mr+380,function()return RetrogradeIsOn end,mw,function()return ar==0 end)local mD=mc(mz,mA,600,60,aG/2-600/2,aH/2-60/2-400,function()return Autopilot end,cw)mc("Save Position","Save Position",200,mD.height,mD.x+mD.width+30,mD.y,function()return false end,jO,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)mc("Update Position","Update Position",200,mD.height,mD.x+mD.width+30,mD.y,function()return false end,my,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mc("Clear Position","Clear Position",200,mD.height,mD.x-200-30,mD.y,function()return true end,jN,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mr=60;ms=300;local cc=10;local cd=aH/2-500;mc("Show Help","Hide Help",ms,mr,cc,cd,function()return showHelp end,function()showHelp=not showHelp end)cd=cd+mr+20;mc("View Settings","View Settings",ms,mr,cc,cd,function()return true end,mo)local cd=aH/2-300;mc("Enable Turn and Burn","Disable Turn and Burn",ms,mr,cc,cd,function()return TurnBurn end,mv)mc("Horizontal Takeoff Mode","Vertical Takeoff Mode",ms,mr,cc+ms+20,cd,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)cd=cd+mr+20;mc("Show Orbit Display","Hide Orbit Display",ms,mr,cc,cd,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a2="Orbit Display Enabled"else a2="Orbit Display Disabled"end end)mc("Engage Orbiting","Cancel Orbiting",ms,mr,cc+ms+20,cd,function()return IntoOrbit end,cs,function()return ar==0 and bM end)cd=cd+mr+20;mc("Glide Re-Entry","Cancel Glide Re-Entry",ms,mr,cc,cd,function()return Reentry end,function()al=1;mw(1)end,function()return planet.hasAtmosphere and not aq end)mc("Parachute Re-Entry","Cancel Parachute Re-Entry",ms,mr,cc+ms+20,cd,function()return Reentry end,cz,function()return planet.hasAtmosphere and not aq end)cd=cd+mr+20;mc("Engage Follow Mode","Disable Follow Mode",ms,mr,cc,cd,function()return a0 end,mB,function()return m()==1 end)mc("Enable Repair Arrows","Disable Repair Arrows",ms,mr,cc+ms+20,cd,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)cd=cd+mr+20;if not ExternalAGG then mc("Enable AGG","Disable AGG",ms,mr,cc,cd,function()return by end,cA,function()return antigrav~=nil end)end;mc(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,ms*2,mr,cc,cd,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)cd=cd+mr+20;mc(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,ms*2,mr,cc,cd,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)end;local function mE()local mF={}local function mG()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local mH={[1]=4480,[6]=4480,[7]=6270}for mI,mJ in pairs(b)do b[mI][0]=mG()b[mI][0].systemId=mI;mF[mI]={}for mK,planet in pairs(b[mI])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=mH[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=mI;planet.bodyId=planet.id;mF[mI][mK]=planet end end;aQ=cM()aR=aQ(mF)aS=e6()aU=eA()aY=eY()aV=ga()aW=jB()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lX()coroutine.yield()m0()coroutine.yield()aX=jU()mb()mq()mu()aF=lU;coroutine.yield()mE()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bP[1]=nil;if radar_1 then bP[1]=radar_1;aY.pickType()end;bZ("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cL in pairs(door)do cL.toggle()end end;if switch then for _,cL in pairs(switch)do cL.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cL in pairs(forcefield)do cL.toggle()end end;cG()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;bZ("stop","SU")end;function script.onTick(mL)local mM=nil;if mL=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bZ("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif mL=="tenthSecond"then local function mN()local mO=system.createData;local mP=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mP(panelInterplanetary,"value")interplanetaryHeaderText=mO('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mP(panelInterplanetary,"value")widgetDistanceText=mO('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=mP(panelInterplanetary,"value")widgetTravelTimeText=mO('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mP(panelInterplanetary,"value")widgetMaxMassText=mO('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mP(panelInterplanetary,"value")widgetTargetOrbitText=mO('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mP(panelInterplanetary,"value")widgetCurBrakeDistanceText=mO('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mP(panelInterplanetary,"value")widgetCurBrakeTimeText=mO('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mP(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mO('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mP(panelInterplanetary,"value")widgetMaxBrakeTimeText=mO('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mP(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mO('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mQ()t(panelInterplanetary)panelInterplanetary=nil end;local function mR()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local ey=bs;local l4=unit.getThrottle()/100;if AtmoSpeedAssist then l4=K end;local mS,mT=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*l4,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mU;if not TurnBurn and ey>0 then _,mU=aX.GetAutopilotBrakeDistanceAndTime(ey)else _,mU=aX.GetAutopilotTBBrakeDistanceAndTime(ey)end;local mV=0;local mW=0;if AutopilotCruising or not Autopilot and ey>5 then mW=aS.computeTravelTime(ey,0,AutopilotDistance)elseif a8+mS<AutopilotDistance then mV=AutopilotDistance-(a8+mS)mW=aS.computeTravelTime(8333.0556,0,mV)else local mX=(AutopilotDistance-a8)/mS;mS=AutopilotDistance-a8;mT=mT*mX end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mW elseif AutopilotBraking then return mU elseif AutopilotCruising then return mW+mU else return mT+a9+mW end end;local function mY(jd,mZ)if jd==nil then jd=core.g()end;jd=A(jd,5)if mZ~=nil and mZ or(mM==nil or mM~=jd)then local ey=bq:len()local m_=g(unit.getData()).maxBrake;if m_~=nil and m_>0 and aq then m_=m_/r(ey/100,0.1,1)m_=m_/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+m_)/2 else LastMaxBrakeInAtmo=m_ end end end;if m_~=nil and m_>0 then LastMaxBrake=m_ end;mM=jd end end;mY(nil,true)if bz~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bz then ck(bz)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mN()end;if AutopilotTargetName~=nil then local n0=CustomTarget~=nil;local n1=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()n1=n1>1000000 and A(n1/1000000,2).." kTons"or A(n1/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mR()if n0 and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local im=co(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..im..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cB(travelTime)..'", "unit":""}')im=co(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..im..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cB(a9)..'", "unit":""}')im=co(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..im..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cB(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",n1)..'", "unit":""}')im=co(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..im..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then ch(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mQ()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()if shield_1 then aV.DrawShield()end elseif mL=="oneSecond"then local function n2(gY)local n3=0;aD=""local n4=aL;local n5=0;local n6=0;local n7=0;local gV=0;local gW=""local n8=core.getElementHitPointsById;for cK in pairs(at)do local m9=0;local n9=0;n9=j(at[cK])m9=n8(at[cK])n5=n5+m9;if m9<n9 then if m9==0 then n7=n7+1 else n6=n6+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cK]))local cc=position.x;local cd=position.y;local fs=position.z;table.insert(aA,core.spawnArrowSticker(cc,cd,fs+1,"down"))table.insert(aA,core.spawnArrowSticker(cc,cd,fs+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(cc+1,cd,fs,"north"))table.insert(aA,core.spawnArrowSticker(cc+1,cd,fs,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(cc-1,cd,fs,"south"))table.insert(aA,core.spawnArrowSticker(cc-1,cd,fs,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(cc,cd-1,fs,"east"))table.insert(aA,core.spawnArrowSticker(cc,cd-1,fs,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(cc,cd+1,fs,"west"))table.insert(aA,core.spawnArrowSticker(cc,cd+1,fs,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cK])end elseif aM and#aA>0 and aA[11]==at[cK]then for gQ in pairs(aA)do core.deleteSticker(aA[gQ])end;aA={}end end;n3=e(n5/n4*100)if n3<100 then gY[#gY+1]=cb(0,0,"","pbright txt")gV=e(n3*2.55)gW=f("rgb(%d,%d,%d)",255-gV,gV,0)if n3<100 then gY[#gY+1]=cb("50%",1035,"Elemental Integrity: "..n3 .."%","txtbig txtmid","fill:"..gW)if n7>0 then gY[#gY+1]=cb("50%",1055,"Disabled Modules: "..n7 .." Damaged Modules: "..n6,"txtbig txtmid","fill:"..gW)elseif n6>0 then gY[#gY+1]=cb("50%",1055,"Damaged Modules: "..n6,"txtbig txtmid","fill:"..gW)end end end end;local function na()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function nb()local gR=q()local i9=bs;local nc=gR-au;if i9>1.38889 then i9=i9/1000;local nd=i9*(gR-au)TotalDistanceTravelled=TotalDistanceTravelled+nd;ad=ad+nd end;ae=ae+nc;TotalFlightTime=TotalFlightTime+nc;au=gR end;nb()aV.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()na()local gY={}aV.ExtraData(gY)if ShowOdometer then gY=aV.DrawOdometer(gY,ad,TotalDistanceTravelled,ae)end;if ShouldCheckDamage then n2(gY)end;ak=table.concat(gY,"")collectgarbage("collect")elseif mL=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local d0=g(dbHud_1.getStringValue("SavedLocations"))if d0~=nil then _G["SavedLocations"]=d0;local fL=-1;local jQ;for cK,cL in pairs(SavedLocations)do if cL.name and cL.name=="SatNav Location"then fL=cK;break end end;if fL~=-1 then jQ=SavedLocations[fL]fL=-1;for cK,cL in pairs(b[0])do if cL.name and cL.name=="SatNav Location"then fL=cK;break end end;if fL>-1 then b[0][fL]=jQ end;aW.UpdateAtlasLocationsList()a2=jQ.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mL=="msgTick"then local gY={}aV.DisplayMessage(gY,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif mL=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif mL=="hudTick"then if not planet then return end;local function ne(gY)local nf=e(r(aj/(aG/4)*255,0,255))gY[#gY+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+nf,e(J+0.5)-nf,e(I+0.5)-nf)end;local function ng()for _,cL in pairs(aF)do if cL.hovered then if not cL.drawCondition or cL.drawCondition()then cL.toggleFunction()end;cL.hovered=false end end end;local function nh()local function ni(nj,nk,cc,cd,mf,mg)if nj>cc and nj<cc+mf and nk>cd and nk<cd+mg then return true else return false end end;local cc=ag+aG/2;local cd=ah+aH/2;for _,cL in pairs(aF)do cL.hovered=ni(cc,cd,cL.x,cL.y,cL.width,cL.height)end end;local function nl(gY)local function nm(gY,nn,hover,cc,cd,er,no,np,nq,nr,ns)if type(nr)=="function"then nr=nr()end;if type(ns)=="function"then ns=ns()end;gY[#gY+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",cc,cd,er,no)if nn then gY[#gY+1]=f("%s'",np)else gY[#gY+1]=nq end;if hover then gY[#gY+1]=" style='stroke:white; stroke-width:2'"else gY[#gY+1]=" style='stroke:black; stroke-width:1'"end;gY[#gY+1]="></rect>"gY[#gY+1]=f("<text x='%f' y='%f' font-size='24' fill='",cc+er/2,cd+no/2+5)if nn then gY[#gY+1]="black"else gY[#gY+1]="white"end;gY[#gY+1]="' text-anchor='middle' font-family='Montserrat'>"if nn then gY[#gY+1]=f("%s</text>",nr)else gY[#gY+1]=f("%s</text>",ns)end end;local nt="rgb(50,50,50)'"local nu="rgb(210,200,200)"local nw=nm;for _,cL in pairs(aF)do local me=cL.disableName;local md=cL.enableName;if type(me)=="function"then me=me()end;if type(md)=="function"then md=md()end;if not cL.drawCondition or cL.drawCondition()then nw(gY,cL.toggleVar(),cL.hovered,cL.x,cL.y,cL.width,cL.height,nu,nt,me,md)end end end;local nx=A(ResolutionX/2,0)local ny=A(ResolutionY/2,0)local gY={}aV.HUDPrologue(gY)if showHud then aV.UpdateHud(gY)else if AlwaysVSpd then aV.DrawVerticalSpeed(gY,as)end;aV.DisplayOrbitScreen(gY)aV.DrawWarnings(gY)end;if bD and bE~={}then aV.DrawSettings(gY)end;if radar_1 or radar_2 then aY.assignRadar()end;if bP[1]then aV.DrawRadarInfo()end;aV.HUDEpilogue(gY)gY[#gY+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(gY,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(gY)end end;if x()==0 then if m()==1 and a1 then if not AltIsOn then nh()nl(gY)end;if not aZ and not a_ then local nz=table.concat(gY,"")gY={}gY[#gY+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gY[#gY+1]=nz;gY[#gY+1]="</body>"aZ=true;gY[#gY+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gY,"")system.setScreen(content)elseif a_ then local nz=table.concat(gY,"")gY={}gY[#gY+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gY[#gY+1]=nz;gY[#gY+1]="</body>"end;if not aZ then gY[#gY+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nx,ny,ag,ah)end else ng()end else if not a1 and m()==0 then ng()if aj>DeadZone then if DisplayDeadZone then ne(gY)end end elseif not AltIsOn or AltIsOn and a1 then nh()nl(gY)end;gY[#gY+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nx,ny,ag,ah)end;gY[#gY+1]=[[</svg></body>]]content=table.concat(gY,"")elseif mL=="apTick"then aX.APTick()elseif mL=="radarTick"then aY.UpdateRadar()elseif mL=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function nA(nB,le)local nC=vec3()local nD=vec3()if nB==axisCommandId.longitudinal then nC=vec3(core.getConstructOrientationForward())nD=bo elseif nB==axisCommandId.vertical then nC=vec3(core.getConstructOrientationUp())nD=bn elseif nB==axisCommandId.lateral then nC=vec3(core.getConstructOrientationRight())nD=bp else return vec3()end;local nE=vec3(core.getWorldGravity())local nF=nE:dot(nD)local nG=vec3(core.getWorldAirFrictionAcceleration())local nH=nG:dot(nD)local nI=bq:dot(nC)local nJ=le*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nJ-nI)local nK=targetSpeedPID2:get()local nL=(nK-nH-nF)*nD;return nL end;local function nM(nB,le)local nC=vec3()local nD=vec3()if nB==axisCommandId.longitudinal then nC=vec3(core.getConstructOrientationForward())nD=bo elseif nB==axisCommandId.vertical then nC=vec3(core.getConstructOrientationUp())nD=bn elseif nB==axisCommandId.lateral then nC=vec3(core.getConstructOrientationRight())nD=bp else return vec3()end;local nE=vec3(core.getWorldGravity())local nF=nE:dot(nD)local nG=vec3(core.getWorldAirFrictionAcceleration())local nH=nG:dot(nD)local nI=bq:dot(nC)local nJ=le*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nJ-nI)local nK=targetSpeedPID:get()local nL=(nK-nH-nF)*nD;return nL end;local function nN(nO,h0,jG)local nP=nO:cross(jG):normalize_inplace()local hN=math.acos(r(nP:dot(-h0),-1,1))*constants.rad2deg;if nP:cross(-h0):dot(jG)<0 then hN=-hN end;return hN end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then ch(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local nQ=r(T+U+system.getControlDeviceForwardInput(),-1,1)local nR=r(W+Z+system.getControlDeviceYawInput(),-1,1)local nS=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local nT=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local nU=bC/180*math.pi;local nV=math.cos(nU)local nW=math.sin(nU)bB=nN(bt,bo,bp*nV+bn*nW)local nX=br:normalize()local nY=d(bC)local nZ=utils.sign(bC)local n_=vec3(core.getWorldAngularVelocity())local o0=nQ*pitchSpeedFactor*bp+nR*rollSpeedFactor*bo+nS*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local o1=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and o1>0 or ar>0.0 and o1<autoRollRollThreshold and autoRollPreference)and nR==0 and d(bB)<85 then local o2=b4;local o3=autoRollFactor;if ar==0 then o3=o3/4;b4=0;o2=0 end;if rollPID==nil then rollPID=pid.new(o3*0.01,0,o3*0.1)end;rollPID:inject(o2-bC)local o4=rollPID:get()o0=o0+o4*bo end end;local o5=1;local o6=0;local o7=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then b7=r(b7+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local o8=K;K=A(r(K+speedChangeLarge/100,-1,1),2)if K>=0 and o8<0 then K=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then b7=r(b7-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local o8=K;K=A(r(K-speedChangeLarge/100,-1,1),2)if K<=0 and o8>0 then K=0;aw=false end end else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local o9=throttlePID:get()N=r(o9,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local oa=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=oa end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local ob=''local oc=vec3()local od=nA(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",od,o6)local oe='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then oe=oe..ExtraLongitudeTags end;local of=s:getAxisCommandType(axisCommandId.longitudinal)local og=s:composeAxisAccelerationFromThrottle(oe,axisCommandId.longitudinal)local oh=nM(axisCommandId.lateral,LeftAmount*1000)ob=ob..' , '.."lateral airfoil , lateral ground "oc=oc+oh;if oc:len()>constants.epsilon then a:setEngineForceCommand(ob,oc,o6,'','','',o7)end;a:setEngineForceCommand(oe,og,o5)local oi='thrust analog vertical fueled 'local oj='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then oj=oj..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then oi=oi..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(oi,od,o5)else a:setEngineForceCommand(oi,vec3(),o5)end;if LeftAmount~=0 then a:setEngineForceCommand(oj,oh,o5)else a:setEngineForceCommand(oj,vec3(),o5)end;if nT==0 then nT=L end;local ok=-nT*(brakeSpeedFactor*br+brakeFlatFactor*nX)a:setEngineForceCommand('brake',ok)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local le=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-le/3.6)local oa=r(brakePID:get(),0,1)nT=r(nT+oa,0,1)end;local ok=-nT*(brakeSpeedFactor*br+brakeFlatFactor*nX)a:setEngineForceCommand('brake',ok)local ob=''local oc=vec3()local ol=false;local oe='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then oe=oe..ExtraLongitudeTags end;local of=s:getAxisCommandType(axisCommandId.longitudinal)if of==axisCommandType.byThrottle then local og=s:composeAxisAccelerationFromThrottle(oe,axisCommandId.longitudinal)a:setEngineForceCommand(oe,og,o5)elseif of==axisCommandType.byTargetSpeed then local og=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ob=ob..' , '..oe;oc=oc+og;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ol=true end end;local oj='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then oj=oj..ExtraLateralTags end;local om=s:getAxisCommandType(axisCommandId.lateral)if om==axisCommandType.byThrottle then local on=s:composeAxisAccelerationFromThrottle(oj,axisCommandId.lateral)a:setEngineForceCommand(oj,on,o5)elseif om==axisCommandType.byTargetSpeed then local oh=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ob=ob..' , '..oj;oc=oc+oh end;local oi='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then oi=oi..ExtraVerticalTags end;local oo=s:getAxisCommandType(axisCommandId.vertical)if oo==axisCommandType.byThrottle then local od=s:composeAxisAccelerationFromThrottle(oi,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(oi,od,o5,'airfoil','ground','',o7)else a:setEngineForceCommand(oi,vec3(),o5)a:setEngineForceCommand('airfoil vertical',od,o5,'airfoil','','',o7)a:setEngineForceCommand('ground vertical',od,o5,'ground','','',o7)end elseif oo==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),o5)end;local op=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ob=ob..' , '..oi;oc=oc+op end;if oc:len()>constants.epsilon then if Y~=0 or ol or d(nX:dot(bo))<0.5 then ob=ob..', brake'end;a:setEngineForceCommand(ob,oc,o6,'','','',o7)end end;local oq=torqueFactor*(o0-n_)local os=vec3(core.getWorldAirFrictionAngularAcceleration())oq=oq-os;a:setEngineTorqueCommand('torque',oq,o5,'airfoil','','',o7)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local ey=bq:len()local ot=0.15;if not bA then local ou=s:getTargetSpeed(axisCommandId.longitudinal)if ey*3.6>ou*(1-ot)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ey*3.6<ou*(1-ot)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local l4=unit.getThrottle()if AtmoSpeedAssist then l4=K*100 end;local le=l4/100;if k==0 then le=le*MaxGameVelocity;if ey>=le*(1-ot)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ey<le*(1-ot)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local lp=e(b7)le=le*lp/3.6;if ey>=le*(1-ot)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ey<le*(1-ot)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g7=coroutine.status(beginSetup)if g7=="suspended"then local ci,g8=coroutine.resume(beginSetup)if g8 then system.print("ERROR STARTUP: "..g8)end elseif g7=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(ov)local function ow(ox)local D=1;local function oy(oz,ox)local oA={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local oB=oz;for _,cL in ipairs(oA)do if ox and oB>cL then oz=cL elseif oz<cL and not ox then oz=cL;break end end;return oz end;if ox then D=-1 end;if not ExternalAGG and by then if a1 and ox then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=oy(bg,ox)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=oy(HoldAltitude,ox)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function oC(ox)local D=1;if ox then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if ox then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end;local function oD(oE)if not aq then a2="Flight Assist in Atmo only"return end;local cR=type(oE)if bK==nil then if cR=="table"then if Autopilot or VectorToTarget then cw()end;bZ("180On","BR")elseif oE==1 then bZ("bnkLft","BR")else bZ("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then ct()if cR~="table"then oE=oE+1 end end;bK=oE else bZ("180Off","BR")bK=nil end end;if ov=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;ch(0)if vBooster or hover then if aq and ao==-1 then bZ("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then bZ("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bZ("grOut","LG",1)a.control.extendLandingGears()end else if S then bZ("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif ov=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif ov=="forward"then T=T-1 elseif ov=="backward"then if AltIsOn then oD(-br*5000)else T=T+1 end elseif ov=="left"then if AltIsOn then oD(1)else W=W-1 end elseif ov=="right"then if AltIsOn then oD(3)else W=W+1 end elseif ov=="yawright"then X=X-1 elseif ov=="yawleft"then X=X+1 elseif ov=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif ov=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif ov=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ov=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ov=="groundaltitudeup"then ow()elseif ov=="groundaltitudedown"then ow(true)elseif ov=="option1"then toggleView=false;if AltIsOn and a1 then local oF=""for i=1,#passengers do oF=oF.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..A(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..oF)return end;aW.adjustAutopilotTargetIndex()elseif ov=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif ov=="option3"then local function oG()aE=not aE;if not aE then bZ("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bZ("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local oF=""for i=1,#ships do oF=oF.."| ID: "..ships[i].." Mass: "..A(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..oF)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oG()toggleView=false elseif ov=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;cw()elseif ov=="option5"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;function ToggleLockPitch()if LockPitch==nil then bZ("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bZ("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif ov=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local oH=shield_1.getVentingCooldown()if oH>0 then a2="Cannot vent again for "..oH.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;ct()elseif ov=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end;toggleView=false elseif ov=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bZ("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bZ("gsOn","GS")end;toggleView=false elseif ov=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)ch(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bZ("gyOn","GA")else bZ("gyOff","GA")end end;toggleView=false elseif ov=="lshift"then if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif ov=="brake"then if BrakeToggleStatus or AltIsOn then cy()elseif not BrakeIsOn then cy()else BrakeIsOn=true end elseif ov=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif ov=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif ov=="stopengines"then local function oI()if E-F<1.5 then bZ("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;oI()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)ch(0)else ch(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then ck(AtmoSpeedLimit)else ck(MaxGameVelocity*3.6)end end end elseif ov=="speedup"then oC()elseif ov=="speeddown"then oC(true)elseif ov=="antigravity"and not ExternalAGG then if antigrav~=nil then cA()end end end;function script.onActionStop(ov)local function oJ()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if ov=="forward"then T=0 elseif ov=="backward"then T=0 elseif ov=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif ov=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif ov=="yawright"then X=0 elseif ov=="yawleft"then X=0 elseif ov=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif ov=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif ov=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ov=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ov=="groundaltitudeup"then oJ()toggleView=false elseif ov=="groundaltitudedown"then oJ()toggleView=false elseif ov=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif ov=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then cy()else BrakeIsOn=false end end elseif ov=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(ov)local function oK(ox)local D=1;if ox then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function oL(ox)local D=1;if ox then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if ov=="groundaltitudeup"then if not a1 then oK()end elseif ov=="groundaltitudedown"then if not a1 then oK(true)end elseif ov=="speedup"then oL()elseif ov=="speeddown"then oL(true)end end;function script.onInputText(ce)local function oM()for cK,cL in pairs(c4())do dbHud_1.setStringValue(cL,h(nil))end;for cK,cL in pairs(c)do if cL~="SavedLocations"then dbHud_1.setStringValue(cL,h(nil))end end;a2="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5 end;local function oN(oO,eC,hJ)local function oP(eC)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cZ='::pos{'..B..','..B..','..B..','..B..','..B..'}'local db,dc,di,dj,dk=o(eC,cZ)if db=="0"and dc=="0"then return vec3(z(di),z(dj),z(dk))end;dj=math.rad(dj)di=math.rad(di)local planet=b[z(db)][z(dc)]local e3=math.cos(di)local oQ=vec3(e3*math.cos(dj),e3*math.sin(dj),math.sin(di))return planet.center+(planet.radius+dk)*oQ end;local position=oP(eC)return aW.AddNewLocation(oO,position,hJ)end;local i;local oR,oS=nil,nil;local oT="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(ce," ")oR=ce;if i~=nil then oR=string.sub(ce,0,i-1)oS=string.sub(ce,i+1)end;if oR=="/help"or oR=="/commands"then for jn in string.gmatch(oT,"([^\n]+)")do system.print(jn)end;return elseif oR=="/setname"then if oS==nil or oS==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(oS)else a2="Select a saved target to rename first"end elseif shield_1 and oR=="/resist"then if oS==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cZ=B..', '..B..', '..B..', '..B;local oU,oV,oW,oX=o(oS,cZ)if oX==nil or oU+oV+oW+oX>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(oU,oV,oW,oX)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif oR=="/addlocation"or string.find(ce,"::pos")~=nil then local hJ=false;local oO="0-Temp"if oS==nil or oS==""then oS=oR;hJ=true end;i=string.find(oS,"::")if not hJ then oO=string.sub(oS,1,i-2)end;local eC=string.sub(oS,i)oN(oO,eC,hJ)elseif oR=="/agg"then if oS==nil or oS==""then a2="Usage: /agg targetheight"return end;oS=z(oS)if oS<1000 then oS=1000 end;AntigravTargetAltitude=oS;a2="AGG Target Height set to "..oS elseif oR=="/G"then if oS==nil or oS==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oS=="dump"then for cK,cL in pairs(c4())do if type(_G[cL])=="boolean"then if _G[cL]==true then system.print(cL.." true")else system.print(cL.." false")end elseif _G[cL]==nil then system.print(cL.." nil")else system.print(cL.." ".._G[cL])end end;return end;i=string.find(oS," ")local oY=string.sub(oS,0,i-1)local oZ=string.sub(oS,i+1)for cK,cL in pairs(c4())do if cL==oY then a2="Variable "..oY.." changed to "..oZ;local o_=type(_G[cL])if o_=="number"then oZ=z(oZ)if cL=="AtmoSpeedLimit"then b7=oZ end elseif o_=="boolean"then if string.lower(oZ)=="true"then oZ=true else oZ=false end end;_G[cL]=oZ;return end end;a2="No such global variable: "..oY elseif oR=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif oR=="/copydatabank"then if dbHud_2 then cG(true)else a2="Spare Databank required to copy databank"end elseif oR=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(dc)if bP[1]and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(dc)if bP[1]and CollisionSystem then if#bL>650 then dc=tostring(dc)bL[dc]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
