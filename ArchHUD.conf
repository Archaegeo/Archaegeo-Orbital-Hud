name: ArchHud - Archaegeo v1.150 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export: (Default: false)
        userControlScheme = "virtual joystick" --export: (Default: "virtual joystick") Set to "virtual joystick", "mouse", or "keyboard"
        freeLookToggle = true --export: (Default: true)
        BrakeToggleDefault = true --export: (Default: true)
        RemoteFreeze = false --export: (Default: false)
        RemoteHud = true --export: (Default: true)
        brightHud = false --export: (Default: false)
        VanillaRockets = false --export: (Default: false)
        InvertMouse = false --export: (Default: false)
        autoRollPreference = false --export: (Default: false)
        turnAssist = true --export: (Default: true)
        ExternalAGG = false --export: (Default: false)
        UseSatNav = false --export: (Default: false)
        ShouldCheckDamage = true --export: (Default: true)
        CalculateBrakeLandingSpeed = false --export: (Default: false)
        AtmoSpeedAssist = true --export: (Default: true)
        ForceAlignment = false --export: (Default: false)
        DisplayDeadZone = true --export: (Default: true)
        showHud = true --export: (Default: true) 
        ShowOdometer = true --export: (Default: true)
        hideHudOnToggleWidgets = true --export: (Default: true)
        ShiftShowsRemoteButtons = true --export: (Default: true)
        DisplayOrbit = true --export: (Default: true) 
        YawStallAngle = 35 --export: (Default: 35)
        PitchStallAngle = 35 --export: (Default: 35)
        brakeLandingRate = 30 --export: (Default: 30)
        MaxPitch = 30 --export: (Default: 30)
        TargetOrbitRadius = 1.4 --export: (Default: 1.4)
        LowOrbitHeight = 1000 --export: (Default: 1000)
        AtmoSpeedLimit = 1050 --export: (Default: 1050)
        SpaceSpeedLimit = 30000 --export: (Default: 30000).
        AutoTakeoffAltitude = 1000 --export: (Default: 1000)
        TargetHoverHeight = 50 --export: (Default: 50)
        LandingGearGroundHeight = 0 --export: (Default: 0)
        MaxGameVelocity = 8333.00 --export: (Default: 8333.00)
        AutopilotInterplanetaryThrottle = 1.0 --export: (Default: 1.0)
        warmup = 32 --export: (Default: 32)
        fuelTankHandlingAtmo = 0 --export: (Default: 0)
        fuelTankHandlingSpace = 0 --export: (Default: 0)
        fuelTankHandlingRocket = 0 --export: (Default: 0)
        ContainerOptimization = 0 --export: (Default: 0)
        FuelTankOptimization = 0 --export: (Default: 0)
        ResolutionX = 1920 --export: (Default: 1920)
        ResolutionY = 1080 --export: (Default: 1080) 
        circleRad = 400 --export: (Default: 400)
        SafeR = 130 --export: (Default: 130)
        SafeG = 224 --export: (Default: 224)
        SafeB = 255 --export: (Default: 255)
        PvPR = 255 --export: (Default: 255)
        PvPG = 0 --export: (Default: 0)
        PvPB = 0 --export: (Default: 0)
        centerX = 960 --export: (Default: 960)
        centerY = 540 --export: (Default: 540)
        throtPosX = 1300 --export: (Default: 1300)
        throtPosY = 540 --export: (Default: 540)
        vSpdMeterX = 1525  --export: (Default: 1525)
        vSpdMeterY = 325 --export: (Default: 325)
        altMeterX = 550  --export: (Default: 550)
        altMeterY = 540 --export: (Default: 540) 
        fuelX = 100 --export: (Default: 100)
        fuelY = 300 --export: (Default: 300)
        DeadZone = 50 --export: (Default: 50)
        OrbitMapSize = 250 --export: (Default: 250)
        OrbitMapX = 75 --export: (Default: 75)
        OrbitMapY = 0 --export: (Default: 0)
        speedChangeLarge = 5 --export: (Default: 5)
        speedChangeSmall = 1 --export: (Default: 1)
        MouseXSensitivity = 0.003 --export: (Default: 0.003)
        MouseYSensitivity = 0.003 --export: (Default: 0.003)
        autoRollFactor = 2 --export: (Default: 2)
        rollSpeedFactor = 1.5 --export: (Default: 1.5)
        autoRollRollThreshold = 0 --export: (Default: 0)
        minRollVelocity = 150 --export: (Default: 150)    
        turnAssistFactor = 2 --export: (Default: 2)
        TrajectoryAlignmentStrength = 0.002 --export: (Default: 0.002)
        torqueFactor = 2 --export: (Default: 2)
        pitchSpeedFactor = 0.8 --export: (Default: 0.8)
        yawSpeedFactor = 1 --export: (Default: 1)
        brakeSpeedFactor = 3 --export: (Default: 3)
        brakeFlatFactor = 1 --export: (Default: 1)
        DampingMultiplier = 40 --export: (Default: 40) 
        apTickRate = 0.0166667 --export: (Default: 0.0166667)  
        hudTickRate = 0.0666667 --export: (Default: 0.0666667)
        ExtraLongitudeTags = "none" --export: (Default: "none")
        ExtraLateralTags = "none" --export: (Default: "none")
        ExtraVerticalTags = "none" --export: (Default: "none")
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.150;SetWaypointOnExit=true;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;showHelp=true;local b={"showHelp","VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=core.getConstructMass;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local tostring=tostring;local p=utils.round;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local function y(z,A)local B=10^(A or 0)return d(z*B+0.5)/B end;local C=16;local D=SafeR;local E=SafeB;local F=SafeG;local G=0;local H=0;local I=false;local J=0;local K=false;local L=y(ResolutionX/2,0)local M=y(ResolutionY/2,0)local N=false;local O=55;local P=false;local Q=false;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=false;local Z=false;local a0="empty"local a1=5;local a2=5;local a3=a1;local a4=a2;local a5=false;local a6,a7=0;local a8,a9=0;local aa=nil;local ab=0;local ac=0;local ad=false;local ae=0;local af=0;local ag=0;local ah=3;local ai=0;local aj=""local ak=""local al=0;local am=false;local an=false;local ao=false;local ap=-1;local aq=false;local ar=""local as=j()>0;local at=j()local au=core.getAltitude()local av=core.getElementIdList()local aw=q()local ax=nil;local ay=false;local az=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]local aA=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]local aB={}local aC=0;local aD=0;local aE=""local aF=true;local aG={}local aH={}local aI={}local aJ=ResolutionX;local aK=ResolutionY;local aL=false;local aM=false;local aN=0;local aO=nil;local aP={}local aQ={}local aR={}local aS=0;local aT=false;local aU={}local aV={}local aW=d(1/apTickRate)*2;local aX={}local aY={}local aZ={}local a_={}local b0=false;local b1=0;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=nil;local bd=nil;local be=false;local bf=false;local bg=autoRollPreference;local bh=LandingGearGroundHeight;local bi=false;local bj=q()local bk=0;local bl=0;local bm=0;local bn=AtmoSpeedLimit;local bo=0;local bp=nil;local bq=0;local br=0;local bs=false;local bt=false;local bu={VectorToTarget=false}local bv=false;local bw=0;local bx=nil;local by=false;local bz=false;local bA=false;local bB=false;local bC=0;local bD=q()local bE=vec3(core.getConstructWorldOrientationUp())local bF=vec3(core.getConstructWorldOrientationForward())local bG=vec3(core.getConstructWorldOrientationRight())local bH=vec3(core.getWorldVelocity())local bI=vec3(bH):len()local bJ=vec3(core.getWorldVertical())local bK=-bJ:dot(bH)local bL=vec3(core.getConstructWorldPos())local bM=false;local bN=false;local bO=nil;local bP=true;local bQ=0;local bR=0;local bS=false;local bT={}local bU=showHud;local bV={}local function bW(bX,bY)for i=1,#bY do bX[#bX+1]=bY[i]end;return bX end;local function bZ(b_)local c0={}local c1={"userControlScheme","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit"}local c2={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c3={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY"}local c4={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not b_ then bW(c0,c1)bW(c0,c2)bW(c0,c3)bW(c0,c4)return c0 elseif b_=="boolean"then return c1 elseif b_=="handling"then return c2 elseif b_=="hud"then return c3 elseif b_=="physics"then return c4 end end;local function c5(c6,c7,c8,c9,ca)if c9==nil then c9=""end;if ca==nil then ca=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],c9,c6,c7,ca,c8)end;local function cb(cc,cd)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not cd then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cc)G=r(y(cc*100,0)/100,-1,1)end;local function ce(cc,cd)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cd then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cc)bO=cc end;local function cf(cg,ch)if cg==0 then return c(ch)<1e-09 end;if ch==0 then return c(cg)<1e-09 end;return c(cg-ch)<math.max(c(cg),c(ch))*epsilon end;local function ci(ai,cj)local ck=ai>100000;local cl,cm=""if cj==nil then cj=1 end;if ck then cl,cm=y(ai/1000/200,cj),"SU"elseif ai<1000 then cl,cm=y(ai,cj),"M"else cl,cm=y(ai/1000,cj),"KM"end;return cl,cm end;local function cn()if VertTakeOff then AltitudeHold=false;StrongBrakes=true;Reentry=false;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=true;VertTakeOff=false;bg=true;ae=0;if as and ap==-1 then BrakeLanding=false;AltitudeHold=true;ae=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ce(d(bn))end else VertTakeOff=true;AltitudeHold=false;by=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end end;local function co()by=false;bq=nil;br=nil;bC=0;if at==0 then if IntoOrbit then IntoOrbit=false;bs=false;bx=nil;bg=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bu.VectorToTarget=false;bu.AutopilotAlign=false;bv=false elseif unit.getClosestPlanetInfluence()>0 then IntoOrbit=true;bg=true;if bx==nil then bx=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a0="Unable to engage orbiting, not near planet"end else IntoOrbit=false;bs=false;bx=nil;bg=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bu.VectorToTarget=false;bu.AutopilotAlign=false;bv=false end end;local function cp()if bD-bl<1.5 then if planet.hasAtmosphere then if at>0 then HoldAltitude=planet.spaceEngineMinAltitude-50 else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bw=HoldAltitude;bv=true;if not IntoOrbit then co()end;bs=true end end;bl=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bl=bD end;if unit.getClosestPlanetInfluence()>0 and at==0 then bw=au;bv=true;bs=true;co()if IntoOrbit then bl=bD else bl=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Y=false;bg=true;LockPitch=nil;by=false;if ap==-1 then AutoTakeoff=false;if bl>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=au end end;if VertTakeOff then cn()end else AutoTakeoff=true;if bl>-1 then HoldAltitude=au+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bM then cn()end end;if an then HoldAltitude=100000 end else if IntoOrbit then co()end;if VertTakeOff then cn()end;bg=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bl=0 end end;local function cq()if m()==1 then Y=not Y;if Y then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)else BrakeIsOn=true;bg=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a0="Follow Mode only works with Remote controller"Y=false end end;local function cr(planet,cs)local function ct(cu,cv)local cw=vec3(cv)if cu.bodyId==0 then return setmetatable({latitude=cw.x,longitude=cw.y,altitude=cw.z,bodyId=0,systemId=cu.planetarySystemId},MapPosition)end;local cx=cw-cu.center;local ai=cx:len()local cy=ai-cu.radius;local cz=0;local cA=0;if not cf(ai,0)then local cB=n(cx.y,cx.x)cA=cB>=0 and cB or 2*math.pi+cB;cz=math.pi/2-math.acos(cx.z/ai)end;return setmetatable({latitude=math.deg(cz),longitude=math.deg(cA),altitude=cy,bodyId=cu.bodyId,systemId=cu.planetarySystemId},MapPosition)end;local cC=ct(planet,cs)cC="::pos{"..cC.systemId..","..cC.bodyId..","..cC.latitude..","..cC.longitude..","..cC.altitude.."}"system.setWaypoint(cC)end;local function cD()local function cE(SpaceTarget)VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cp()end end;VectorStatus="Proceeding to Waypoint"end;if bD-bm<1.5 and at>0 then if not bB then a0="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if at>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight end;bm=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bm=bD end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not an and not IntoOrbit then bc.UpdateAutopilotTarget()cr(aa,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then if at~=0 then an=true;cp()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if at>0 then if not VectorToTarget then cE(SpaceTarget)end else if au>AutopilotTargetOrbit*1.5 or au==0 then by=false;Autopilot=true elseif not as then if IntoOrbit then co()end;bw=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bv=true;bu.AutopilotAlign=true;bu.VectorToTarget=true;bs=false;if not IntoOrbit then co()end end end else RetrogradeIsOn=false;ProgradeIsOn=false;if at~=0 then an=true;cp()else Autopilot=true end end elseif at==0 then local cF=unit.getClosestPlanetInfluence()>0;if CustomTarget==nil and(aa.name==planet.name and cF)and not IntoOrbit then WaypointSet=false;by=false;bs=false;co()else Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Y=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;N=false;LockPitch=nil;WaypointSet=false end else an=true;cp()end else an=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;N=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=au;TargetSet=false;Reentry=false;if IntoOrbit then co()end end end;local function cG(cH)local cI=-1;local cJ;cI=bc.findAtlasIndex(SavedLocations)if cI~=-1 then local cK;if cH~=nil then cJ={position=SavedLocations[cI].position,name=cH,atmosphere=SavedLocations[cI].atmosphere,planetname=SavedLocations[cI].planetname,gravity=SavedLocations[cI].gravity}else cJ={position=bL,name=SavedLocations[cI].name,atmosphere=at,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cI]=cJ;cI=-1;cI=bc.findAtlasIndex(b2[0])if cI>-1 then b2[0][cI]=cJ end;bc.UpdateAtlasLocationsList()a0=CustomTarget.name.." position updated"bc.UpdateAutopilotTarget()else a0="Name Not Found"end end;local function cL()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bg=autoRollPreference end;if BrakeIsOn then AltitudeHold=false;VectorToTarget=false;AutoTakeoff=false;VertTakeOff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;AltitudeHold=false;if VertTakeOff then cn()end;if IntoOrbit then co()end;LockPitch=nil;bg=autoRollPreference;am=false;ao=false;ae=0 end end;local function cM(cN,cO,cP)local function cQ(cN,cR)cN=vec3(cN)cR=vec3(cR):normalize()local cl=cN*cR;return cl.x+cl.y+cl.z end;local cS=0.001;local cT=1;if not as or not bi or ap~=-1 or bI<O then local cU=cP;if cU==nil then cU=DampingMultiplier end;if cO==nil then cO=cS end;cN=vec3(cN):normalize()local cV=vec3()-cN;local cW=-cQ(cV,core.getConstructWorldOrientationRight())*cT;local cX=-cQ(cV,core.getConstructWorldOrientationUp())*cT;if aC==0 then aC=cW/2 end;if aD==0 then aD=cX/2 end;if c(cW)<0.1 then T=T-cW*2 else T=T-(cW+(cW-aC)*cU)end;if c(cX)<0.1 then S=S+cX*2 else S=S+cX+(cX-aD)*cU end;aC=cW;aD=cX;if c(cW)<cO and c(cX)<cO then return true end;return false elseif bi and ap==-1 then cN=bH;local cU=cP;if cU==nil then cU=DampingMultiplier end;if cO==nil then cO=cS end;cN=vec3(cN):normalize()local cV=bF-cN;local cW=-cQ(cV,core.getConstructWorldOrientationRight())*cT;local cX=-cQ(cV,core.getConstructWorldOrientationUp())*cT;if aC==0 then aC=cW/2 end;if aD==0 then aD=cX/2 end;if c(cW)<0.1 then T=T-cW*5 else T=T-(cW+(cW-aC)*cU)end;if c(cX)<0.1 then S=S+cX*5 else S=S+cX+(cX-aD)*cU end;aC=cW;aD=cX;if c(cW)<cO and c(cX)<cO then return true end;return false end end;local function cY()if Reentry then a0="Re-Entry cancelled"Reentry=false;bg=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ah=5 elseif not P then StrongBrakes=planet.gravity*9.80665*l()<LastMaxBrakeInAtmo;if not StrongBrakes then a0="WARNING: Insufficient Brakes for Parachute Re-Entry"else Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bg=true;BrakeIsOn=false;a0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bn end else Reentry=true;AltitudeHold=true;bg=true;BrakeIsOn=false;HoldAltitude=planet.spaceEngineMinAltitude-50;local c8,cZ=ci(HoldAltitude)a0="Beginning Re-entry.  Target speed: "..bn.." Target Altitude: "..c8 ..cZ;ce(d(bn))end;AutoTakeoff=false end;local function c_()if antigrav and not ExternalAGG then if bN then antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=au end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;antigrav.activate()antigrav.show()end end end;local function d0(d1)local d2=0;local d3=0;local d4=0;if d1<60 then d1=d(d1)elseif d1<3600 then d2=d(d1/60)d1=d(d1%60)elseif d1<86400 then d3=d(d1/3600)d2=d(d1%3600/60)else d4=d(d1/86400)d3=d(d1%86400/3600)end;if d4>0 then return d4 .."d "..d3 .."h "elseif d3>0 then return d3 .."h "..d2 .."m "elseif d2>0 then return d2 .."m "..d1 .."s"elseif d1>0 then return d1 .."s"else return"0s"end end;local function d5(d6)local function d7(d8)for d9,da in pairs(d8)do dbHud_1.setStringValue(da,g(_G[da]))if d6 and dbHud_2 then dbHud_2.setStringValue(da,g(_G[da]))end end end;if dbHud_1 then if not ad then d7(b)d7(bZ())system.print("Saved Variables to Datacore")if d6 and dbHud_2 then a0="Databank copied.  Remove copy when ready."end end end end;local function db()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function dc()local function dd(de)return type(de)=='number'end;local function df(de)return type(tonumber(de))=='number'end;local function dg(dh)return type(dh)=='table'end;local function di(dj)return type(dj)=='string'end;local function dk(da)return dg(da)and dd(da.x and da.y and da.z)end;local function dl(dm)return dg(dm)and dd(dm.latitude and dm.longitude and dm.altitude and dm.bodyId and dm.systemId)end;local dn=math.pi/180;local dp=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dq='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local dr=r;local function cf(cg,ch)if cg==0 then return c(ch)<1e-09 end;if ch==0 then return c(cg)<1e-09 end;return c(cg-ch)<math.max(c(cg),c(ch))*epsilon end;local function ds(de)local cl=string.gsub(string.reverse(e('%.4f',de)),'^0*%.?','')return cl==''and'0'or string.reverse(cl)end;local function dt(du)if dk(du)then return e('{x=%.3f,y=%.3f,z=%.3f}',du.x,du.y,du.z)end;if dg(du)and not getmetatable(du)then local dv={}local dw=next(du)if type(dw)=='nil'or dw==1 then dv=du else for d9,da in pairs(du)do local cc=dt(da)if type(d9)=='number'then table.insert(dv,e('[%s]=%s',d9,cc))else table.insert(dv,e('%s=%s',d9,cc))end end end;return e('{%s}',table.concat(dv,','))end;if di(du)then return e("'%s'",du:gsub("'",[[\']]))end;return tostring(du)end;local dx={}dx.__index=dx;dx.__tostring=function(du,dy)local dz={}for d9 in pairs(du)do table.insert(dz,d9)end;table.sort(dz)local dv={}for _,d9 in ipairs(dz)do local cc=dt(du[d9])if type(d9)=='number'then table.insert(dv,e('[%s]=%s',d9,cc))else table.insert(dv,e('%s=%s',d9,cc))end end;if dy then return e('%s%s',dy,table.concat(dv,',\n'..dy))end;return e('{%s}',table.concat(dv,','))end;dx.__eq=function(dA,dB)return dA.planetarySystemId==dB.planetarySystemId and dA.bodyId==dB.bodyId and cf(dA.radius,dB.radius)and cf(dA.center.x,dB.center.x)and cf(dA.center.y,dB.center.y)and cf(dA.center.z,dB.center.z)and cf(dA.GM,dB.GM)end;local function dC(dD,dE,dF,cv,dG)assert(df(dD),'Argument 1 (planetarySystemId) must be a number:'..type(dD))assert(df(dE),'Argument 2 (bodyId) must be a number:'..type(dE))assert(df(dF),'Argument 3 (radius) must be a number:'..type(dF))assert(dg(cv),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cv))assert(df(dG),'Argument 5 (GM) must be a number:'..type(dG))return setmetatable({planetarySystemId=tonumber(dD),bodyId=tonumber(dE),radius=tonumber(dF),center=vec3(cv),GM=tonumber(dG)},dx)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dH)return e('::pos{%d,%d,%s,%s,%s}',dH.systemId,dH.bodyId,ds(dH.latitude*dp),ds(dH.longitude*dp),ds(dH.altitude))end;MapPosition.__eq=function(dA,dB)return dA.bodyId==dB.bodyId and dA.systemId==dB.systemId and cf(dA.latitude,dB.latitude)and cf(dA.altitude,dB.altitude)and(cf(dA.longitude,dB.longitude)or cf(dA.latitude,math.pi/2)or cf(dA.latitude,-math.pi/2))end;local function dI(dJ,dE,cz,cA,cy)local dD=dJ;if di(dJ)and not cA and not cy and not dE and not cz then dD,dE,cz,cA,cy=o(dJ,dq)assert(dD,'Argument 1 (position string) is malformed.')else assert(df(dD),'Argument 1 (systemId) must be a number:'..type(dD))assert(df(dE),'Argument 2 (bodyId) must be a number:'..type(dE))assert(df(cz),'Argument 3 (latitude) must be in degrees:'..type(cz))assert(df(cA),'Argument 4 (longitude) must be in degrees:'..type(cA))assert(df(cy),'Argument 5 (altitude) must be in meters:'..type(cy))end;dD=tonumber(dD)dE=tonumber(dE)cz=tonumber(cz)cA=tonumber(cA)cy=tonumber(cy)if dE==0 then return setmetatable({latitude=cz,longitude=cA,altitude=cy,bodyId=dE,systemId=dD},MapPosition)end;return setmetatable({latitude=dn*dr(cz,-90,90),longitude=dn*(cA%360),altitude=cy,bodyId=dE,systemId=dD},MapPosition)end;local dK={}dK.__index=dK;dK.__tostring=function(du,dy)local dL=dy and dy..'  'local dM={}local dz={}for d9 in pairs(du)do table.insert(dz,d9)end;table.sort(dz)for _,dN in ipairs(dz)do bdy=du[dN]local dO=dx.__tostring(bdy,dL)if dy then table.insert(dM,e('[%s]={\n%s\n%s}',dN,dO,dy))else table.insert(dM,e('  [%s]=%s',dN,dO))end end;if dy then return e('\n%s%s%s',dy,table.concat(dM,',\n'..dy),dy)end;return e('{\n%s\n}',table.concat(dM,',\n'))end;local function dP(dQ)local b2={}local pid;for _,da in pairs(dQ)do local dR=da.planetarySystemId;if type(dR)~='number'then error('Invalid planetary system ID: '..tostring(dR))elseif pid and dR~=pid then error('Mistringmatch planetary system IDs: '..dR..' and '..pid)end;local dS=da.bodyId;if type(dS)~='number'then error('Invalid body ID: '..tostring(dS))elseif b2[dS]then error('Duplicate body ID: '..tostring(dS))end;setmetatable(da.center,getmetatable(vec3.unit_x))b2[dS]=setmetatable(da,dx)pid=dR end;return setmetatable(b2,dK)end;b6={}local function dT(dQ)return setmetatable({galaxyAtlas=dQ or{}},b6)end;b6.__index=function(dh,i)if type(i)=='number'then local system=dh.galaxyAtlas[i]return dP(system)end;return rawget(b6,i)end;b6.__pairs=function(du)return function(dh,d9)local dU,nv=next(dh,d9)return dU,nv and dP(nv)end,du.galaxyAtlas,nil end;b6.__tostring=function(du)local dV={}for _,dW in pairs(du or{})do local dX=dW:getPlanetarySystemId()local dY=dK.__tostring(dW,'    ')table.insert(dV,e('  [%s]={%s\n  }',dX,dY))end;return e('{\n%s\n}\n',table.concat(dV,',\n'))end;b6.BodyParameters=dC;b6.MapPosition=dI;b6.PlanetarySystem=dP;function b6.createBodyParameters(dZ,dE,d_,e0,e1,e2,e3)assert(df(dZ),'Argument 1 (planetarySystemId) must be a number:'..type(dZ))assert(df(dE),'Argument 2 (bodyId) must be a number:'..type(dE))assert(df(d_),'Argument 3 (surfaceArea) must be a number:'..type(d_))assert(dg(e0),'Argument 4 (aPosition) must be an array or vec3:'..type(e0))assert(dg(e1),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(e1))assert(df(e2),'Argument 6 (altitude) must be in meters:'..type(e2))assert(df(e3),'Argument 7 (gravityAtPosition) must be number:'..type(e3))local dF=math.sqrt(d_/4/math.pi)local ai=dF+e2;local e4=vec3(e0)+ai*vec3(e1)local dG=e3*ai*ai;return dC(dZ,dE,dF,e4,dG)end;b6.isMapPosition=dl;function b6:getPlanetarySystem(dJ)if i==nil then i=0 end;if nv==nil then nv=0 end;local dZ=dJ;if dl(dJ)then dZ=dJ.systemId end;if type(dZ)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dK then system=dP(system)end;return system end end end;function dK:castIntersections(e5,cR,e6,e7)local e6=e6 or function(e8)return 1.05*e8.radius end;local e9={}if e7 then for _,i in ipairs(e7)do e9[i]=self[i]end else e7={}for d9,e8 in pairs(self)do table.insert(e7,d9)e9[d9]=e8 end end;local function ea(eb,ec)local ed=e9[eb].center-e5;local ee=e9[ec].center-e5;return ed:len()<ee:len()end;table.sort(e7,ea)local ef=cR:normalize()for i,dR in ipairs(e7)do local e8=e9[dR]local eg=e8.center-e5;local dF=e6(e8)local eh=eg:dot(ef)local ei=eh^2-(eg:len2()-dF^2)if ei>=0 then local ej=math.sqrt(ei)local ek=eh+ej;local el=eh-ej;if el>0 then return e8,ek,el elseif ek>0 then return e8,ek,nil end end end;return nil,nil,nil end;function dK:closestBody(cs)assert(type(cs)=='table','Invalid coordinates.')local em,e8;local en=vec3(cs)for _,eo in pairs(self)do local ep=(eo.center-en):len2()if(not e8 or ep<em)and eo.name~="Space"then e8=eo;em=ep end end;return e8 end;function dK:convertToBodyIdAndWorldCoordinates(dJ)local eq=dJ;if di(dJ)then eq=dI(dJ)end;if eq.bodyId==0 then return 0,vec3(eq.latitude,eq.longitude,eq.altitude)end;local eo=self:getBodyParameters(eq)if eo then return eq.bodyId,eo:convertToWorldCoordinates(eq)end end;function dK:getBodyParameters(dJ)local dE=dJ;if dl(dJ)then dE=dJ.bodyId end;assert(df(dE),'Argument 1 (bodyId) must be a number:'..type(dE))return self[dE]end;function dK:getPlanetarySystemId()local _,da=next(self)return da and da.planetarySystemId end;function dx:convertToMapPosition(cv)assert(dg(cv),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cv))local cw=vec3(cv)if self.bodyId==0 then return setmetatable({latitude=cw.x,longitude=cw.y,altitude=cw.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local cx=cw-self.center;local ai=cx:len()local cy=ai-self.radius;local cz=0;local cA=0;if not cf(ai,0)then local cB=n(cx.y,cx.x)cA=cB>=0 and cB or 2*math.pi+cB;cz=math.pi/2-math.acos(cx.z/ai)end;return setmetatable({latitude=cz,longitude=cA,altitude=cy,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dx:convertToWorldCoordinates(dJ)local eq=di(dJ)and dI(dJ)or dJ;if eq.bodyId==0 then return vec3(eq.latitude,eq.longitude,eq.altitude)end;assert(dl(eq),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eq.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(eq.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local er=math.cos(eq.latitude)return self.center+(self.radius+eq.altitude)*vec3(er*math.cos(eq.longitude),er*math.sin(eq.longitude),math.sin(eq.latitude))end;function dx:getAltitude(cv)return(vec3(cv)-self.center):len()-self.radius end;function dx:getDistance(cv)return(vec3(cv)-self.center):len()end;function dx:getGravity(cv)local es=self.center-vec3(cv)local et=es:len2()return self.GM/et*es/math.sqrt(et)end;return setmetatable(b6,{__call=function(_,...)return dT(...)end})end;local function eu()local b8={}local ev=30000000/3600;local ew=ev*ev;local ex=100;local function ey(da)return 1/math.sqrt(1-da*da/ew)end;function b8.computeAccelerationTime(ez,eA,eB)local eC=ev*math.asin(ez/ev)return(ev*math.asin(eB/ev)-eC)/eA end;function b8.computeDistanceAndTime(ez,eB,eD,eE,eF,eG)eF=eF or 0;eG=eG or 0;local eH=ez<=eB;local eI=eE*(eH and 1 or-1)/eD;local eJ=-eG/eD;local eK=eI+eJ;if eH and eK<=0 or not eH and eK>=0 then return-1,-1 end;local eL,eM=0,0;if eI~=0 and eF>0 then local eC=math.asin(ez/ev)local eN=math.pi*(eI/2+eJ)local eO=eI*eF;local eP=ev*math.pi;local da=function(dh)local eQ=(eN*dh-eO*math.sin(math.pi*dh/2/eF)+eP*eC)/eP;local eR=math.tan(eQ)return ev*eR/math.sqrt(eR*eR+1)end;local eS=eH and function(dj)return dj>=eB end or function(dj)return dj<=eB end;eM=2*eF;if eS(da(eM))then local eT=0;while c(eM-eT)>0.5 do local dh=(eM+eT)/2;if eS(da(dh))then eM=dh else eT=dh end end end;local eU=ez;local eV=eM/ex;for eW=1,ex do local eX=da(eW*eV)eL=eL+(eX+eU)*eV/2;eU=eX end;if eM<2*eF then return eL,eM end;ez=eU end;local eC=ev*math.asin(ez/ev)local bD=(ev*math.asin(eB/ev)-eC)/eK;local eY=ew*math.cos(eC/ev)/eK;local ai=eY-ew*math.cos((eK*bD+eC)/ev)/eK;return ai+eL,bD+eM end;function b8.computeTravelTime(ez,eA,ai)if ai==0 then return 0 end;if eA>0 then local eC=ev*math.asin(ez/ev)local eY=ew*math.cos(eC/ev)/eA;return(ev*math.acos(eA*(eY-ai)/ew)-eC)/eA end;if ez==0 then return-1 end;assert(ez>0,'Acceleration and initial speed are both zero.')return ai/ez end;function b8.lorentz(da)return ey(da)end;return b8 end;local function eZ()local vec3=require('cpml.vec3')local dc=dc()local function di(dj)return type(dj)=='string'end;local function dg(dh)return type(dh)=='table'end;local function cf(cg,ch)if cg==0 then return c(ch)<1e-09 end;if ch==0 then return c(cg)<1e-09 end;return c(cg-ch)<math.max(c(cg),c(ch))*constants.epsilon end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cy)assert(self.body)local ai=cy+self.body.radius;if not cf(ai,0)then local orbit=math.sqrt(self.body.GM/ai)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dJ,e_)assert(self.body)assert(dg(dJ)or di(dJ))assert(dg(e_))local f0=(di(dJ)or dc.isMapPosition(dJ))and self.body:convertToWorldCoordinates(dJ)or vec3(dJ)local da=vec3(e_)local f1=f0-self.body.center;local ee=da:len2()local f2=f1:len()local f3=self.body.GM;local f4=((ee-f3/f2)*f1-f1:dot(da)*da)/f3;local cg=f3/(2*f3/f2-ee)local f5=f4:len()local ef=f4:normalize()local f6=cg*(1-f5)local f7=cg*(1+f5)local f8=f6*ef+self.body.center;local f9=f5<=1 and-f7*ef+self.body.center or nil;local fa=math.sqrt(cg*f3*(1-f5*f5))local fb=f9 and 2*math.pi*math.sqrt(cg^3/f3)local fc=math.acos(f4:dot(f1)/(f5*f2))if f1:dot(da)<0 then fc=-(fc-2*math.pi)end;local fd=math.acos((math.cos(fc)+f5)/(1+f5*math.cos(fc)))local fe=fd;if fe<0 then fe=fe+2*math.pi end;local ff=fe-f5*math.sin(fe)local fg=0;local fh=0;local fi=0;if fb~=nil then fg=ff/(2*math.pi/fb)fh=fb-fg;fi=fh+fb/2;if fc-math.pi>0 then fh=fg;fi=fh+fb/2 end;if fi>fb then fi=fi-fb end end;return{periapsis={position=f8,speed=fa/f6,circularOrbitSpeed=math.sqrt(f3/f6),altitude=f6-self.body.radius},apoapsis=f9 and{position=f9,speed=fa/f7,circularOrbitSpeed=math.sqrt(f3/f7),altitude=f7-self.body.radius},currentVelocity=da,currentPosition=f0,eccentricity=f5,period=fb,eccentricAnomaly=fd,meanAnomaly=ff,timeToPeriapsis=fh,timeToApoapsis=fi}end;local function fj(fk)local eo=dc.BodyParameters(fk.planetarySystemId,fk.bodyId,fk.radius,fk.center,fk.GM)return setmetatable({body=eo},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return fj(...)end})end;local function fl()local fm=false;local fn=0;local function fo(fp)local dF=500000;local fq,fr,fs=math.huge;local ft=false;local fu=vec3({13771471,7435803,-128971})local fv=18000000;fq=vec3(fp):dist(fu)if fq<fv then return true,c(fq-fv),"Safe Zone",0 end;fr=vec3(fp):dist(vec3(planet.center))if fr<dF then ft=true end;if c(fr-dF)<c(fq-fv)then return ft,c(fr-dF),planet.name,planet.bodyId else return ft,c(fq-fv),"Safe Zone",0 end end;local function fw(da)if aJ==1920 then return da else return y(aJ*da/1920,0)end end;local function fx(da)if aK==1080 then return da else return y(aK*da/1080,0)end end;local function fy()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function fz()local fA="TRAVEL"if not bP then fA="CRUISE"end;if Autopilot then fA="AUTOPILOT"end;return fA end;local function fB(fC,b0,c6,fD,fE,fF,fG,fH)local fI=1;local fJ=2;local fK=3;local fL=4;local fM=5;local fN=6;local fO=""local fP=0;local fQ=fuelY;local fR=fuelY+10;if m()==1 and not RemoteHud then fQ=fQ-50;fR=fR-50 end;if fE=="ATMO"then fO="atmofueltank"elseif fE=="SPACE"then fO="spacefueltank"else fO="rocketfueltank"end;fP=_G[fO.."_size"]if#fF>0 then for i=1,#fF do local fS=string.sub(fF[i][fJ],1,12)local fT=0;for fU=1,fP do if fF[i][fJ]==f(unit[fO.."_"..fU].getData()).name then fT=fU;break end end;if b0 or fG[i]==nil or fH[i]==nil then local fV=0;local fW=0;local fX=0;local fY=0;local fZ=q()if fT~=0 then fH[i]=f(unit[fO.."_"..fT].getData()).percentage;fG[i]=f(unit[fO.."_"..fT].getData()).timeLeft;if fG[i]=="n/a"then fG[i]=0 end else fX=k(fF[i][fI])-fF[i][fL]fV=fF[i][fK]fH[i]=d(0.5+fX*100/fV)fW=fF[i][fM]fY=fF[i][fN]if fW<=fX then fG[i]=0 else fG[i]=d(0.5+fX/((fW-fX)/(fZ-fY)))end;fF[i][fM]=fX;fF[i][fN]=fZ end end;if fS==fD then fS=e("%s %d",fE,i)end;if fT==0 then fS=fS.." *"end;local f_;if fG[i]==0 then f_="n/a"else f_=d0(fG[i])end;if fH[i]~=nil then local g0=d(fH[i]*2.55)local g1=e("rgb(%d,%d,%d)",255-g0,g0,0)local c9=""if f_~="n/a"and fG[i]<120 or fH[i]<5 then if b0 then c9=[[class="red"]]end end;fC[#fC+1]=c5(c6,fQ,fS,c9 .." pdim txtfuel")fC[#fC+1]=c5(c6,fR,e("%d%% %s",fH[i],f_),"pdim txtfuel","fill:"..g1)fQ=fQ+30;fR=fR+30 end end end end;local function g2(fC,cy)if cy<200000 and not as or cy and as then local g3=0;if c(bK)>1 then g3=45*math.log(c(bK),10)if bK<0 then g3=-g3 end end;fC[#fC+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bK),d(g3))end;return fC end;local function g4(g5)local g6=-bJ;g5=g5-g5:project_on(g6)local g7=vec3(0,0,1)g7=g7-g7:project_on(g6)local g8=g7:cross(g6)local g3=g7:angle_between(g5)*constants.rad2deg;if g5:dot(g8)<0 then g3=360-g3 end;return g3 end;local function g9(fC,centerX,centerY,ga,gb,cF)local gc=circleRad;local gd=20;local ge=d(ga)if cF then for i=-45,45,5 do local gf=i;fC[#fC+1]=e([[<g transform="rotate(%f,%d,%d)">]],gf,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fC[#fC+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gc+gd-len,centerX,centerY+gc+gd)end;fC[#fC+1]=c5(centerX,centerY+gc+gd-35,gb,"pdim txt txtmid")fC[#fC+1]=c5(centerX,centerY+gc+gd-25,ge.." deg","pdim txt txtmid")fC[#fC+1]=e([[<g transform="rotate(%f,%d,%d)">]],-ga,centerX,centerY)fC[#fC+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gc+gd-20,centerX+5,centerY+gc+gd-20,centerX,centerY+gc+gd-15)fC[#fC+1]="</g>"end;local gg=ge;if cF then gg=g4(bF)end;local gh=20;local gi=d(gg)local gj=0;local gk=centerY+gc+gd+20;local gl=centerX;if gb~="YAW"then gk=fx(130)gl=fw(960)end;local gm=[[<path class="txttick line" d="]]for i=d(gi-(gh+10)-gi%5+0.5),d(gi+gh+10+gi%5+0.5),5 do local c6=gl+-i*5+gg*5;if i%10==0 then gj=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;fC[#fC+1]=c5(c6+5,gk-12,z)elseif i%5==0 then gj=5 end;if gj==10 then gm=e([[%s M %f %f v %d]],gm,c6,gk-5,gj)else gm=e([[%s M %f %f v %d]],gm,c6,gk-2.5,gj)end end;fC[#fC+1]=gm..[["/>]]fC[#fC+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],gl-5,gk+10,gl+5,gk+10,gl,gk+5)if cF then gb="HDG"end;fC[#fC+1]=c5(gl,gk+25,gi.."deg","pdim txt txtmid","")fC[#fC+1]=c5(gl,gk+35,gb,"pdim txt txtmid","")end;local function gn(fC,go,ga,centerX,centerY,cF,gp,eX)local gc=circleRad;local gq=d(gc*3/5)if gc>0 then local gr=d(go)local len=0;local gm=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*ga,centerX,centerY)if not as then gm=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fC[#fC+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gc-1,centerX,centerY)fC[#fC+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gr-30-gr%5+0.5),d(gr+30+gr%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local c7=centerY+-i*5+go*5;if len==30 then gm=e([[%s M %d %f h %d]],gm,centerX-gq-len,c7,len)if as then fC[#fC+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*ga,centerX,centerY,centerX-gq+10,c7,i)fC[#fC+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*ga,centerX,centerY,centerX+gq-10,c7,i)if i==0 or i==180 or i==-180 then fC[#fC+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*ga,centerX,centerY,centerX-gq+20,c7,gq*2-40)end else fC[#fC+1]=c5(centerX-gq+10,c7,i,"pdim txt txtmid")fC[#fC+1]=c5(centerX+gq-10,c7,i,"pdim txt txtmid")end;gm=e([[%s M %d %f h %d]],gm,centerX+gq,c7,len)else gm=e([[%s M %d %f h %d]],gm,centerX-gq-len,c7,len)gm=e([[%s M %d %f h %d]],gm,centerX+gq,c7,len)end end;fC[#fC+1]=gm..[["/>]]local gs="PITCH"if not cF then gs="REL PITCH"end;if go>90 and not as then go=90-(go-90)elseif go<-90 and not as then go=-90-(go+90)end;if gc>200 then if as then if eX>O then fC[#fC+1]=c5(centerX,centerY-15,"Yaw","pdim txt txtmid")fC[#fC+1]=c5(centerX,centerY+20,gp,"pdim txt txtmid")end;fC[#fC+1]=e([[<g transform="rotate(%f,%d,%d)">]],-ga,centerX,centerY)else fC[#fC+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fC[#fC+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gq+25,centerY-5,centerX-gq+20,centerY,centerX-gq+25,centerY+5,centerX-gq+50,centerY+4,gr)fC[#fC+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gq-25,centerY-5,centerX+gq-20,centerY,centerX+gq-25,centerY+5,centerX+gq-30,centerY+4,gr)fC[#fC+1]="</g>"end;local gt=d(gc/3)fC[#fC+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gt,centerY,gc-gt)if not as and cF then fC[#fC+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*ga,centerX,centerY,centerX-gq+10,centerY,gq*2-20)end;fC[#fC+1]="</g>"if gc<200 then if as and eX>O then fC[#fC+1]=c5(centerX,centerY-gc,gs,"pdim txt txtmid")fC[#fC+1]=c5(centerX,centerY-gc+10,gr,"pdim txt txtmid")fC[#fC+1]=c5(centerX,centerY-15,"Yaw","pdim txt txtmid")fC[#fC+1]=c5(centerX,centerY+20,gp,"pdim txt txtmid")else fC[#fC+1]=c5(centerX,centerY-gc,gs,"pdim txt txtmid")fC[#fC+1]=c5(centerX,centerY-gc+15,gr,"pdim txt txtmid")end end end end;local function gu(fC,cy,cF)local gv=altMeterX;local gw=altMeterY;local gx=78;local gy=19;local gz=ap;if ap~=-1 then fC[#fC+1]=c5(gv+gx,gw+gy+20,e("AGL: %.1fm",ap),"pdim altsm txtend")end;if cF and(cy<200000 and not as or cy and as)then table.insert(fC,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gv-1,gw-4,gx+2,gy+6,gv+1,gw-1,gx-4,gy))local cI=0;local gA=1;local gB=0;local gC=cy<0;local gD=9;if gC then gD=0 end;local cy=c(cy)while cI<6 do local gE=11;local gF=16;local gG=9;local gH=14;local c9="altsm"if cI>2 then gF=gF+3;gE=gE+2;gH=gH+2;gG=gG-6;c9="altbig"end;if gC then c9=c9 .." red"end;local gI=cy/gA%10;local gJ=d(gI)local gK=d((gJ+1)%10)local gL=gB;if cI==0 then gL=gI-gJ;if gC then gL=1-gL end end;if gC and(cI==0 or gB~=0)then local gM=gK;gK=gJ;gJ=gM end;local gN=gF*(gL-1)local gO=gN+gF;local c6=gv+gG+(6-cI)*gE;local c7=gw+gH;fC[#fC+1]=c5(c6,c7+gN,gK,c9)fC[#fC+1]=c5(c6,c7+gO,gJ,c9)cI=cI+1;gA=gA*10;if gJ==gD then gB=gL else gB=0 end end;table.insert(fC,[[</g></g>]])end end;local function gP(e_)e_=vec3(e_)local gQ=-math.deg(n(e_.y,e_.z))+180;gQ=gQ-90;if gQ<0 then gQ=360+gQ end;if gQ>180 then gQ=-180+gQ-180 end;return-gQ end;local function gR(e_)e_=vec3(e_)local gg=math.deg(n(e_.y,e_.x))-90;if gg<-180 then gg=360+gg end;return gg end;local function gS(fC,e_,eX,centerX,centerY)if eX>5 and not as or eX>O then local gc=circleRad;local gT=20;local gU=20;local gV=vec3(e_)local gW=gP(gV)local gX=gR(gV)local gY=14;local gZ=gY/2;local g_=-gX/gU*gc;local h0=gW/gT*gc;local c6=centerX+g_;local c7=centerY+h0;local ai=math.sqrt(g_^2+h0^2)local h1=[[<circle
                            cx="]]..c6 ..[["
                            cy="]]..c7 ..[["
                            r="]]..gZ/gY..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c6 ..[["
                            cy="]]..c7 ..[["
                            r="]]..gZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c6-gY..[[,]]..c7 ..[[ h ]]..gZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c6+gZ..[[,]]..c7 ..[[ h ]]..gZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c6 ..[[,]]..c7-gY..[[ v ]]..gZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ai<gc then fC[#fC+1]=h1 else local g3=n(h0,g_)local h2=4;local h3=centerX+gc*math.cos(g3)local h4=centerY+gc*math.sin(g3)fC[#fC+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',g3*180/math.pi,h3,h4,h3-h2,h4-h2/2,h2*2,h2,h3+h2,h4-h2,h2,h2,-h2,h2)end;if not as then gW=gP(-gV)gX=gR(-gV)g_=-gX/gU*gc;h0=gW/gT*gc;c6=centerX+g_;c7=centerY+h0;ai=math.sqrt(g_^2+h0^2)if ai<gc then local h5=[[<circle
                                    cx="]]..c6 ..[["
                                    cy="]]..c7 ..[["
                                    r="]]..gZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c6 ..[[,]]..c7-gY..[[ v ]]..gZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c6 ..[[,]]..c7 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c6 ..[[,]]..c7 ..[[)" />
                                <path
                                    d="M ]]..c6-gZ..[[,]]..c7 ..[[ h ]]..gY..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c6 ..[[,]]..c7 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c6 ..[[,]]..c7 ..[[)"/>]]fC[#fC+1]=h5 end end end end;local function h6(fC,fA,h7,h8)h7=d(h7+0.5)local fQ=throtPosY+10;local fR=throtPosY+20;if m()==1 and not RemoteHud then fQ=55;fR=65 end;local h9="CRUISE"local unit="km/h"local cc=h8;if fA=="TRAVEL"or fA=="AUTOPILOT"then h9="THROT"unit="%"cc=h7;local ha="dim"if h7<0 then ha="red"end;fC[#fC+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],ha,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(h7),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fC[#fC+1]=c5(throtPosX+10,fQ,h9,"pbright txtstart")fC[#fC+1]=c5(throtPosX+10,fR,e("%.0f %s",cc,unit),"pbright txtstart")if as and AtmoSpeedAssist and bP and I then h7=d(J*100+0.5)local ha="red"if h7<0 then ha="red"end;fC[#fC+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],ha,1-c(h7),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fC[#fC+1]=c5(throtPosX+10,fQ+40,"LIMIT","pbright txtstart")fC[#fC+1]=c5(throtPosX+10,fR+40,h7 .."%","pbright txtstart")end;if as and AtmoSpeedAssist or Reentry then fC[#fC+1]=c5(throtPosX+10,fQ-40,"LIMIT: "..bn.." km/h","dim txtstart")elseif not as and Autopilot then fC[#fC+1]=c5(throtPosX+10,fQ-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hb(fC,hc)local hd=throtPosY-10;local he=throtPosX+10;fC[#fC+1]=c5(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then hd=75 end;fC[#fC+1]=c5(he,hd,d(hc).." km/h","pbright txtbig txtstart")end;local function hf(fC)fC[#fC+1]=c5(fw(1900),fx(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fC[#fC+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fC[#fC+1]=c5(fw(960),fx(550),"Warning: Invalid Control Scheme Detected","warnings")fC[#fC+1]=c5(fw(960),fx(600),"Keyboard Scheme must be selected","warnings")fC[#fC+1]=c5(fw(960),fx(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hg=fw(960)local hh=fx(860)local hi=fx(880)local hj=fx(900)local hk=fx(960)local hl=fx(200)local hm=fx(150)local hn=fx(960)if m()==1 and not RemoteHud then hh=fx(135)hi=fx(155)hj=fx(175)hl=fx(115)hm=fx(95)end;if BrakeIsOn then fC[#fC+1]=c5(hg,hh,"Brake Engaged","warnings")elseif H>0 then fC[#fC+1]=c5(hg,hh,"Auto-Brake Engaged","warnings","opacity:"..H)end;if as and bi and ap==-1 then fC[#fC+1]=c5(hg,hl+50,"** STALL WARNING **","warnings")end;if ax then fC[#fC+1]=c5(hg,hn,"Gyro Enabled","warnings")end;if GearExtended then if Q then fC[#fC+1]=c5(hg,hi,"Gear Extended","warn")else fC[#fC+1]=c5(hg,hi,"Landed (G: Takeoff)","warnings")end;local ho,cm=ci(a:getTargetGroundAltitude())fC[#fC+1]=c5(hg,hj,"Hover Height: "..ho..cm,"warn")end;if a5 then fC[#fC+1]=c5(hg,hk+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bN and AntigravTargetAltitude~=nil then if c(au-antigrav.getBaseAltitude())<501 then fC[#fC+1]=c5(hg,hl+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fC[#fC+1]=c5(hg,hl+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fC[#fC+1]=c5(hg,hl+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fC[#fC+1]=c5(hg,hl+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Y then fC[#fC+1]=c5(hg,hl+20,"Follow Mode Engaged","warn")elseif Reentry then fC[#fC+1]=c5(hg,hl+20,"Re-entry in Progress","warn")end;local hp,ek,el=b7:getPlanetarySystem(0):castIntersections(bL,bH:normalize(),function(e8)if e8.noAtmosphericDensityAltitude>0 then return e8.radius+e8.noAtmosphericDensityAltitude else return e8.radius+e8.surfaceMaxAltitude*1.5 end end)local hq=ek;if el~=nil and ek~=nil then hq=math.min(el,ek)end;if AltitudeHold or VertTakeOff then local ho,cm=ci(HoldAltitude,2)if VertTakeOff then if bN then ho,cm=ci(antigrav.getBaseAltitude(),2)end;fC[#fC+1]=c5(hg,hl,"VTO to "..ho..cm,"warn")elseif AutoTakeoff and not IntoOrbit then fC[#fC+1]=c5(hg,hl,"Takeoff to "..ho..cm,"warn")if BrakeIsOn and not VertTakeOff then fC[#fC+1]=c5(hg,hl+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fC[#fC+1]=c5(hg,hl,"Altitude Hold: "..ho..cm,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if at>0.1 then fC[#fC+1]=c5(hg,hl,"Beginning ascent","warn")elseif at<0.09 and at>0.05 then fC[#fC+1]=c5(hg,hl,"Aligning trajectory","warn")elseif at<0.05 then fC[#fC+1]=c5(hg,hl,"Leaving atmosphere","warn")end end;if IntoOrbit then if bp~=nil then fC[#fC+1]=c5(hg,hl,bp,"warn")end end;if BrakeLanding then if StrongBrakes then fC[#fC+1]=c5(hg,hl,"Brake-Landing","warnings")else fC[#fC+1]=c5(hg,hl,"Coast-Landing","warnings")end end;if ProgradeIsOn then fC[#fC+1]=c5(hg,hl,"Prograde Alignment","crit")end;if RetrogradeIsOn then fC[#fC+1]=c5(hg,hl,"Retrograde Alignment","crit")end;if hq~=nil and at==0 then local ho,cm=ci(hq)local travelTime=b8.computeTravelTime(bI,0,hq)local hr="Collision"if hp.noAtmosphericDensityAltitude>0 then hr="Atmosphere"end;fC[#fC+1]=c5(hg,hm,hp.name.." "..hr.." "..d0(travelTime).." In "..ho..cm,"crit")end;if VectorToTarget and not IntoOrbit then fC[#fC+1]=c5(hg,hl+35,VectorStatus,"warn")end;fC[#fC+1]="</g>"return fC end;local function hs(eX)return d(y(eX*3.6,0)+0.5).." km/h"end;local function ht(fC)local hu=OrbitMapX;local hv=OrbitMapY;local hw=OrbitMapSize;local hx=4;local hy=15;local c6=0;local c7=0;local hz,hA,hB,hC;local function hD(type)local hE,bD,eX,hF;if type=="Periapsis"then hE=orbit.periapsis.altitude;bD=orbit.timeToPeriapsis;eX=orbit.periapsis.speed;hF=35 else hE=orbit.apoapsis.altitude;bD=orbit.timeToApoapsis;eX=orbit.apoapsis.speed;hF=-35 end;fC[#fC+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c6+hF,c7-5,hu+hw/2-hz+hC,c7-5)fC[#fC+1]=c5(c6,c7,type)c7=c7+hy;local ho,cm=ci(hE)fC[#fC+1]=c5(c6,c7,ho..cm)c7=c7+hy;fC[#fC+1]=c5(c6,c7,d0(bD))c7=c7+hy;fC[#fC+1]=c5(c6,c7,hs(eX))end;if orbit~=nil and at<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hv=hv+hx;c6=hu+hw+hu/2+hx;c7=hv+hw/2+5+hx;hz=hw/4;hC=0;fC[#fC+1]=[[<g class="pbright txtorb txtmid">]]fC[#fC+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hw+hu*2,hw+hv,hx,hx)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hB=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hz*2)hA=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hB*(1-orbit.eccentricity)hC=hz-orbit.periapsis.altitude/hB-planet.radius/hB;local hG=""if orbit.periapsis.altitude<=0 then hG='redout'end;fC[#fC+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hG,hu+hw/2+hC+hx,hv+hw/2+hx,hz,hA)fC[#fC+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hu+hw/2+hx,hv+hw/2+hx,planet.radius/hB)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hD("Apoapsis")end;c7=hv+hw/2+5+hx;c6=hu-hu/2+10+hx;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hD("Periapsis")end;fC[#fC+1]=c5(hu+hw/2+hx,planet.name,20+hx,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hH=orbit.timeToApoapsis/orbit.period*2*math.pi;local hI=hz*math.cos(hH)local hJ=hA*math.sin(hH)fC[#fC+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hu+hw/2+hI+hC+hx,hv+hw/2+hJ+hx)end;fC[#fC+1]=[[</g>]]return fC else return fC end end;local function hK()if radarPanelID~=nil and al==0 then t(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then t(perisPanelID)perisPanelID=nil end else if al==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;al=0 end end;local function hL(fC)local c6=50;local c7=525;local hM={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hN={"Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to +1k over atmosphere and orbit to target","Alt-5: Lock Pitch at current pitch","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-9: Activate Gyroscope"}local hO={"Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at 1k over atmosphere","Alt-9: Activate Gyroscope"}local hP={"CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if as then bW(hM,hN)table.insert(hM,"---------------------------------------")if VertTakeOff then table.insert(hM,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ap~=-1 then if antigrav then if bN then table.insert(hM,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hM,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hM,"Alt-6: Begins Vertical Takeoff.")else table.insert(hM,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hM,"G: Begin BrakeLanding or Land")end else bW(hM,hO)end;if AltitudeHold then table.insert(hM,"Alt-Spacebar/Alt-C will raise/lower target height")end;table.insert(hM,"---------------------------------------")bW(hM,hP)for i=1,#hM do c7=c7+12;fC[#fC+1]=c5(c6,c7,hM[i],"pdim txttick txtstart")end end;local hQ={}function hQ.HUDPrologue(fC)if not fm then D=PvPR;F=PvPG;E=PvPB else D=SafeR;F=SafeG;E=SafeB end;az=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]aA=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]local hR=az;local hS=aA;local hT=az;local hU=aA;if fy()and not brightHud then hR=[[rgb(]]..d(D*0.4+0.5)..","..d(F*0.4+0.5)..","..d(E*0.3+0.5)..[[)]]hS=[[rgb(]]..d(D*0.3+0.5)..","..d(F*0.3+0.5)..","..d(E*0.2+0.5)..[[)]]end;fC[#fC+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],hR,hR,hT,hT,hS,hS,hU,hU,aJ,aK)return fC end;function hQ.UpdateHud(fC)local cy=au;local e_=core.getVelocity()local eX=vec3(e_):len()local gQ=bQ;local hV=bR;local ga=hV;local go=bQ;local h7=d(unit.getThrottle())local hc=eX*3.6;local h8=unit.getAxisCommandValue(0)local hW=fw(1770)local hX=fx(310)if AtmoSpeedAssist and bP then h8=G;h7=G*100 end;local fA=fz()local gb="ROLL"local cF=unit.getClosestPlanetInfluence()>0;if h7==nil then h7=0 end;if not cF then if eX>5 then gQ=gP(e_)hV=gR(e_)else gQ=0;hV=0 end;gb="YAW"end;if not as then fm,fn,_,_=fo(bL)else fm=true end;if fn>50000 and not as then local hY;if fn>200000 then hY=y(fn/200000,2).." su"else hY=y(fn/1000,1).." km"end;fC[#fC+1]=c5(hW,hX,"PvP Boundary: "..hY,"pbright txtbig txtmid")end;fC[#fC+1]=ak;fC[#fC+1]=aE;fC[#fC+1]=aj;if b1%aW==0 then b0=true end;if fuelX~=0 and fuelY~=0 then fB(fC,b0,fuelX,"Atmospheric ","ATMO",aP,aZ,a_)fB(fC,b0,fuelX+100,"Space fuel t","SPACE",aQ,aX,aY)fB(fC,b0,fuelX+200,"Rocket fuel ","ROCKET",aR,aU,aV)end;if b0 then b0=false;b1=0 end;b1=b1+1;g2(fC,cy)if m()==0 or RemoteHud then if not fy()or brightHud then if cF then g9(fC,centerX,centerY,ga,gb,cF)gn(fC,go,ga,centerX,centerY,cF,d(gR(e_)),eX)else g9(fC,centerX,centerY,hV,gb,cF)gn(fC,gQ,hV,centerX,centerY,cF,d(hV),eX)end;gu(fC,cy,cF)gS(fC,e_,eX,centerX,centerY)end end;h6(fC,fA,h7,h8)hb(fC,hc)hf(fC)ht(fC)if showHelp then hL(fC)end;return fC end;function hQ.HUDEpilogue(fC)fC[#fC+1]="</svg>"return fC end;function hQ.ExtraData(fC)local hZ=fw(1240)local h_=fx(55)local i0=h_+10;local i1;local i2=0;local fA=fz()if VertTakeOffEngine then fA=fA.."-VERTICAL"end;if TurnBurn then fA="TB-"..fA end;local i3=vec3(core.getWorldAcceleration()):len()/9.80665;i1=core.g()fC[#fC+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then hZ=fw(1120)h_=fx(55)i0=h_+10 elseif as then local i4=fw(770)fC[#fC+1]=c5(i4,h_,"ATMOSPHERE","pdim txt txtend")fC[#fC+1]=c5(i4,i0,e("%.2f",at),"pdim txt txtend","")end;fC[#fC+1]=c5(hZ,h_,"GRAVITY","pdim txt txtend")fC[#fC+1]=c5(hZ,i0,e("%.2f",i1/9.80665),"pdim txt txtend")fC[#fC+1]=c5(hZ,h_+20,"ACCEL","pdim txt txtend")fC[#fC+1]=c5(hZ,i0+20,e("%.2f",i3),"pdim txt txtend")fC[#fC+1]=c5(fw(960),fx(180),fA,"txtbig txtmid")end;function hQ.DrawOdometer(fC,ab,TotalDistanceTravelled,ac)local i1;local i5=0;local i6=0;local i2=0;if as then i2=LastMaxBrakeInAtmo else i2=LastMaxBrake end;maxThrust=a:maxForceForward()aN=l()i1=core.g()if i1>0.1 then i6=aN*i1;i5=maxThrust/i1 end;fC[#fC+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fw(660),fw(700),fx(35),fw(960),fx(55),fw(1240),fx(35),fw(1280))if m()==0 or RemoteHud then fC[#fC+1]=c5(fw(700),fx(20),e("Trip: %.2f km",ab),"txtstart")fC[#fC+1]=c5(fw(700),fx(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fC[#fC+1]=c5(fw(830),fx(20),"Trip Time: "..d0(ac),"txtstart")fC[#fC+1]=c5(fw(830),fx(30),"Total Time: "..d0(TotalFlightTime),"txtstart")fC[#fC+1]=c5(fw(970),fx(20),e("Mass: %.2f Tons",aN/1000),"txtstart")fC[#fC+1]=c5(fw(1240),fx(10),e("Max Brake: %.2f kN",i2/1000),"txtend")fC[#fC+1]=c5(fw(1240),fx(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if i1>0.1 then fC[#fC+1]=c5(fw(970),fx(30),e("Max Mass: %.2f Tons",i5/1000),"txtstart")fC[#fC+1]=c5(fw(1240),fx(20),e("Req Thrust: %.2f kN",i6/1000),"txtend")else fC[#fC+1]=c5(fw(970),fx(30),"Max Mass: n/a","txtstart")fC[#fC+1]=c5(fw(1240),fx(20),"Req Thrust: n/a","txtend")end end;fC[#fC+1]="</g>"return fC end;function hQ.DrawWarnings(fC)return hf(fC)end;function hQ.DisplayOrbitScreen(fC)return ht(fC)end;function hQ.DisplayMessage(fC,ho)if ho~="empty"then local c7=310;for i7 in string.gmatch(ho,"([^\n]+)")do c7=c7+35;fC[#fC+1]=c5("50%",c7,i7,"msg")end end;if ah~=0 then unit.setTimer("msgTick",ah)ah=0 end end;function hQ.DrawDeadZone(fC)fC[#fC+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function hQ.UpdateRadar()if radar_1 then local i8=radar_1.getEntries()local i9=radar_1.getData()local ia=fw(1770)local ib=fx(330)if#i8>0 then local ic=i9:find('identifiedConstructs":%[%]')if ic==nil and perisPanelID==nil then al=1;hK()end;if ic~=nil and perisPanelID~=nil then hK()end;if radarPanelID==nil then hK()end;aj=c5(ia,ib,"Radar: "..#i8 .." contacts","pbright txtbig txtmid")local id={}for d9,da in pairs(i8)do if radar_1.hasMatchingTransponder(da)==1 then table.insert(id,da)end end;if#id>0 then local c7=fx(15)local c6=fw(1370)aj=aj..c5(c6,c7,"Friendlies In Range","pbright txtbig txtmid")for d9,da in pairs(id)do c7=c7+20;aj=aj..c5(c6,c7,radar_1.getConstructName(da),"pdim txtmid")end end else local ie;ie=i9:find('worksInEnvironment":false')if ie then aj=c5(ia,ib,"Radar: Jammed","pbright txtbig txtmid")else aj=c5(ia,ib,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then al=0;hK()end end end end;function hQ.DrawSettings(fC)if#bT>0 then local c6=fw(640)local c7=fx(200)fC[#fC+1]=[[<g class="pbright txtvspd txtstart">]]for d9,da in pairs(bT)do fC[#fC+1]=c5(c6,c7,da..": ".._G[da])c7=c7+20;if d9%12==0 then c6=c6+fw(350)c7=fx(200)end end;fC[#fC+1]=c5(fw(640),fx(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fC[#fC+1]="</g>"end;return fC end;return hQ end;local function ig()local function ih()local function ii(ij,ik)return ij.name<ik.name end;bV={}for d9,da in pairs(b2[0])do bV[#bV+1]={name=da.name,index=d9}end;table.sort(bV,ii)end;local db={}function db.UpdateAtlasLocationsList()ih()end;function db.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"aa=nil;CustomTarget=nil;return true end;local il=bV[AutopilotTargetIndex].index;local im=b2[0][il]if im.center then AutopilotTargetName=im.name;aa=b7[0][il]if CustomTarget~=nil then if at==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=im;for _,da in pairs(b7[0])do if da.name==CustomTarget.planetname then aa=da;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(aa.center)else AutopilotTargetCoords=CustomTarget.position end;if aa.planetname~="Space"then if aa.hasAtmosphere then AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=ba(aa):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function db.adjustAutopilotTargetIndex(g6)if not Autopilot and not VectorToTarget and not an and not IntoOrbit then if g6==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bV then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bV end end;if AutopilotTargetIndex==0 then bc.UpdateAutopilotTarget()else local il=bV[AutopilotTargetIndex].index;local im=b2[0][il]if im.name=="Space"then if g6==nil then bc.adjustAutopilotTargetIndex()else bc.adjustAutopilotTargetIndex(1)end else bc.UpdateAutopilotTarget()end end else a0="Disengage autopilot before changing Interplanetary Helper"end end;function db.findAtlasIndex(io)for d9,da in pairs(io)do if da.name and da.name==CustomTarget.name then return d9 end end;return-1 end;for d9,da in pairs(SavedLocations)do table.insert(b2[0],da)end;ih()db.UpdateAutopilotTarget()return db end;local function ip()local iq={}local function ir(eX)local is=AutopilotEndSpeed;if not Autopilot then is=0 end;if not as then return b8.computeDistanceAndTime(eX,is,l(),0,0,LastMaxBrake-AutopilotPlanetGravity*l())else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b8.computeDistanceAndTime(eX,is,l(),0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*l())else return 0,0 end end end;local function it(eX)local is=AutopilotEndSpeed;if not Autopilot then is=0 end;return b8.computeDistanceAndTime(eX,is,l(),a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*l())end;function iq.GetAutopilotBrakeDistanceAndTime(eX)return ir(eX)end;function iq.GetAutopilotTBBrakeDistanceAndTime(eX)return it(eX)end;local function iu(iv,iw,ix)iw=iw:project_on_plane(iv)ix=ix:project_on_plane(iv)return n(iw:cross(ix):dot(iv),iw:dot(ix))end;local function iy()local function iz()local iA=-1;local iB=-1;if vBooster then iA=vBooster.distance()end;if hover then iB=hover.distance()end;if iA~=-1 and iB~=-1 then if iA<iB then return iA else return iB end elseif iA~=-1 then return iA elseif iB~=-1 then return iB else return-1 end end;local iC=iz()local iD=-1;if telemeter_1 then iD=telemeter_1.getDistance()end;if iC~=-1 and iD~=-1 then if iC<iD then return iC else return iD end elseif iC~=-1 then return iC else return iD end end;function iq.APTick()as=j()>0;at=j()au=core.getAltitude()ap=iy()bD=q()bj=bD;if antigrav then bN=antigrav.getState()==1 end;local iE=1;local iF=1;local iG=bD-bj;local iH=-math.deg(iu(bE,bH,bF))local iI=math.deg(iu(bG,bH,bF))local g6=bJ*-1;bi=as and iH<-YawStallAngle or iH>YawStallAngle or iI<-PitchStallAngle or iI>PitchStallAngle;local iJ=system.getMouseDeltaX()local iK=system.getMouseDeltaY()if InvertMouse and not Z then iK=-iK end;T=0;X=0;S=0;sys=b7[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=ba(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bH)if au==0 then au=(bL-planet.center):len()-planet.radius end;local i1=planet:getGravity(core.getConstructWorldPos()):len()*l()bk=0;b9=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and Z then if not be then af=af+iJ;ag=ag+iK end else af=0;ag=0 end else af=af+iJ;ag=ag+iK;ai=math.sqrt(af*af+ag*ag)if not Z and m()==0 then if userControlScheme=="virtual joystick"then if af>0 and af>DeadZone then T=T-(af-DeadZone)*MouseXSensitivity elseif af<0 and af<DeadZone*-1 then T=T-(af+DeadZone)*MouseXSensitivity else T=0 end;if ag>0 and ag>DeadZone then S=S-(ag-DeadZone)*MouseYSensitivity elseif ag<0 and ag<DeadZone*-1 then S=S-(ag+DeadZone)*MouseYSensitivity else S=0 end else af=0;ag=0;if userControlScheme=="mouse"then S=(-utils.smoothstep(iK,-100,100)+0.5)*2*iE;T=(-utils.smoothstep(iJ,-100,100)+0.5)*2*iF end end end end;local iL=bI>8334;if bI>SpaceSpeedLimit/3.6 and not as and not Autopilot and not iL then a0="Space Speed Engine Shutoff reached"cb(0)end;if not iL and LastIsWarping then if not BrakeIsOn then cL()end;if Autopilot then cD()end end;LastIsWarping=iL;if as and at>0.09 then if bI>bn/3.6 and not AtmoSpeedAssist and not ay then BrakeIsOn=true;ay=true elseif not AtmoSpeedAssist and ay then if bI<bn/3.6 then BrakeIsOn=false;ay=false end end end;if BrakeIsOn then W=1 else W=0 end;if ProgradeIsOn then if am then BrakeIsOn=false;local iM=false;if CustomTarget~=nil then iM=cM(CustomTarget.position-bL,0.01)else iM=cM(vec3(bH),0.01)end;bg=true;if iM and(c(bR)<2 or c(bQ)>85)and bI>=bn/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;P=true;am=false;ao=true;Autopilot=false;cY()elseif as and AtmoSpeedAssist then cb(1)else ce(d(bn))end elseif bI>O then cM(vec3(bH),0.01)end end;if RetrogradeIsOn then if as then RetrogradeIsOn=false elseif bI>O then cM(-vec3(bH))end end;if not ProgradeIsOn and am and not IntoOrbit then if at==0 then P=true;cY()am=false;ao=true else am=false;cD()end end;if ao and CustomTarget~=nil and(au<HoldAltitude+200 and au>HoldAltitude-200)and bI*3.6>bn-100 and c(bK)<20 and at>=0.1 and(CustomTarget.position-bL):len()>2000+au then cD()ao=false end;if VertTakeOff then bg=true;local iN=HoldAltitude;if bK<-30 then a0="Unable to achieve lift. Safety Landing."ae=0;bg=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bN or HoldAltitude<planet.spaceEngineMinAltitude then if bN then iN=antigrav.getBaseAltitude()end;if au<iN-100 then bo=0;ae=15;BrakeIsOn=false elseif bK>0 then BrakeIsOn=true;ae=0 elseif bK<-30 then BrakeIsOn=true;ae=15 elseif au>=iN then if bN then if Autopilot or VectorToTarget then cn()else BrakeIsOn=true;VertTakeOff=false end;a0="Takeoff complete. Singularity engaged"else BrakeIsOn=false;a0="VTO complete. Engaging Horizontal Flight"cn()end;ae=0 end else if at>0.08 then bo=0;BrakeIsOn=false;ae=20 elseif at<0.08 and at>0 then BrakeIsOn=false;if bA then bo=0;ae=20 else ae=0;bo=36;ce(3500)end else bg=autoRollPreference;IntoOrbit=true;by=false;CancelIntoOrbit=false;bs=false;bq=nil;br=nil;if bx==nil then bx=planet end;bw=iN;bv=true;VertTakeOff=false end end;if bo~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local iO=r(bo-bQ,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(iO)local iP=r(vTpitchPID:get(),-1,1)S=iP end end;if IntoOrbit then local cV;local iQ=false;local iR,iS=ci(bw)local iT=iR..iS;if bx==nil then bx=planet;if VectorToTarget then bx=aa end end;if not bv then bw=math.floor(bx.radius+bx.surfaceMaxAltitude+LowOrbitHeight)if bx.hasAtmosphere then bw=math.floor(bx.radius+bx.noAtmosphericDensityAltitude+LowOrbitHeight)end;bv=true end;if bu.VectorToTarget then cV=CustomTarget.position-bL end;local iU,iV=ba(bx):escapeAndOrbitalSpeed((bL-bx.center):len()-bx.radius)local iW=bR;if not bs then local iX=false;local iY=false;cb(0)br=0;bp="Aligning to orbital path - OrbitHeight: "..iT;if bu.VectorToTarget then cM(cV:normalize():project_on_plane(bJ))iQ=bF:dot(cV:project_on_plane(bE):normalize())>0.95 else cM(bH)iQ=iH<0.5;if bI<150 then iQ=true end end;S=0;bq=0;if bQ<=bq+1 and bQ>=bq-1 then iX=true else iX=false end;if iW<=br+1 and iW>=br-1 then iY=true else iY=false end;if iX and iY and iQ then bq=nil;br=nil;bs=true end else if bu.VectorToTarget then cM(cV:normalize():project_on_plane(bJ))elseif bI>150 then cM(bH)end;S=0;if bu.VectorToTarget then local a6,_=b8.computeDistanceAndTime(bI,bn/3.6,l(),0,0,LastMaxBrake)if by and cV:len()>15000+a6+au then bp="Orbiting to Target"if orbit.periapsis.altitude<bx.noAtmosphericDensityAltitude then by=false end elseif by or cV:len()<15000+a6+au then a0="Orbit complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;P=true;ao=true;bu.VectorToTarget,bu.AutopilotAlign=false,false;co()cY()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and au>bw*0.9 and au<bw*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bw*0.99 and orbit.apoapsis.altitude>=bw*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or by then if by then BrakeIsOn=false;cb(0)bq=0;if not bu.VectorToTarget then a0="Orbit complete"co()end else bC=bC+1;if bC>=2 then by=true end end else bp="Adjusting Orbit - OrbitHeight: "..iT;bt=true;ce(iV*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local iZ=bK;local i_=au-bw;local j0=c(i_)if bK<10 and c(bQ)<10 and j0<100 then iZ=bK*2 end;if iZ<10 and c(bQ)<10 and j0<100 then iZ=iZ*2 end;if iZ<5 and c(bQ)<5 and j0<100 then iZ=iZ*4 end;VSpdPID:inject(iZ)bq=r(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(i_)bq=r(bq-r(OrbitAltPID:get(),-15,15),-90,90)end end else local j1=2.75;local j2=c(p(iU*j1))local j3=j2%50;if j3>0 then j2=j2-j3+50 end;BrakeIsOn=false;if au<bw*0.8 then bp="Escaping planet gravity - OrbitHeight: "..iT;bq=utils.map(bK,200,0,-15,80)elseif au>=bw*0.8 and au<bw*1.15 then bp="Approaching orbital corridor - OrbitHeight: "..iT;j2=j2*0.75;bq=utils.map(bK,100,-100,-15,65)elseif au>=bw*1.15 and au<bw*1.5 then bp="Approaching orbital corridor - OrbitHeight: "..iT;j2=j2*0.75;if bK<0 or bt then bq=utils.map(au,bw*1.5,bw*1.01,-30,0)else bq=utils.map(au,bw*0.99,bw*1.5,0,30)end elseif au>bw*1.5 then bp="Reentering orbital corridor - OrbitHeight: "..iT;bq=-85;local j4=utils.map(bK,-150,-400,1,0.55)j2=j2*j4 end;ce(d(j2))end end;if bq~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local j5=bq-bQ;OrbitPitchPID:inject(j5)local j6=r(OrbitPitchPID:get(),-0.5,0.5)S=j6 end end;if Autopilot and at==0 and not am then local j7,j8=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local j9=(CustomTarget.position-aa.center):normalize()local ja=j9:project_on_plane((aa.center-bL):normalize()):normalize()local jb=aa.center+ja*(aa.radius+AutopilotTargetOrbit)local jc=CustomTarget.position+(CustomTarget.position-aa.center):normalize()*(AutopilotTargetOrbit-aa:getAltitude(CustomTarget.position))if(bL-jb):len()<(bL-jc):len()then j7=jb;AutopilotTargetCoords=j7 else j7=CustomTarget.position+(CustomTarget.position-aa.center):normalize()*(AutopilotTargetOrbit-aa:getAltitude(CustomTarget.position))AutopilotTargetCoords=j7 end;cr(aa,AutopilotTargetCoords)j8=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;j8=true;TargetSet=true;AutopilotRealigned=true;j7=CustomTarget.position+(bL-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local j9=(bL+bH*100000-aa.center):normalize()local ja=j9:project_on_plane((aa.center-bL):normalize()):normalize()if ja:len()<1 then j9=(bL+bF*100000-aa.center):normalize()ja=j9:project_on_plane((aa.center-bL):normalize()):normalize()end;j7=aa.center+ja*(aa.radius+AutopilotTargetOrbit)AutopilotTargetCoords=j7;TargetSet=true;j8=true;AutopilotRealigned=true;cr(aa,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(j7)-bL):len()local hp,ek,el=b7:getPlanetarySystem(0):castIntersections(bL,bH:normalize(),function(e8)if e8.noAtmosphericDensityAltitude>0 then return e8.radius+e8.noAtmosphericDensityAltitude else return e8.radius+e8.surfaceMaxAltitude*1.5 end end)local hq=ek;if el~=nil and ek~=nil then hq=math.min(el,ek)end;if hq~=nil and hq<AutopilotDistance and hp.name==aa.name then AutopilotDistance=hq end;local iM=true;local jd=(aa.center-(bL+vec3(bH):normalize()*AutopilotDistance)):len()-aa.radius;local ho,cm=ci(jd)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ho..'", "unit":"'..cm..'"}')local a6,a7;if not TurnBurn then a6,a7=ir(bI)else a6,a7=it(bI)end;if bI>300 and AutopilotAccelerating then local cV=vec3(j7)-bL;local je=r(math.deg(iu(bE,bH:normalize(),cV:normalize()))*bI/500,-90,90)local jf=r(math.deg(iu(bG,bH:normalize(),cV:normalize()))*bI/500,-90,90)if c(je)<20 and c(jf)<20 then je=je*2;jf=jf*2 end;if c(je)<2 and c(jf)<2 then je=je*2;jf=jf*2 end;local iH=-math.deg(iu(bE,bF,bH:normalize()))local iI=-math.deg(iu(bG,bF,bH:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(jf-iI)local jg=r(apPitchPID:get(),-1,1)S=S+jg;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(je-iH)local jh=r(apYawPID:get(),-1,1)T=T+jh;j8=true;if c(je)>2 or c(jf)>2 then AutopilotStatus="Adjusting Trajectory"else AutopilotStatus="Accelerating"end end;if jd<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=ba(aa):escapeAndOrbitalSpeed(jd)end end;if not AutopilotCruising and not AutopilotBraking and not j8 then iM=cM((j7-bL):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then iM=cM(-vec3(bH):normalize())end;if AutopilotAccelerating then if not N then BrakeIsOn=false;cb(AutopilotInterplanetaryThrottle)G=y(AutopilotInterplanetaryThrottle,2)N=true end;local ji=unit.getThrottle()if AtmoSpeedAssist then ji=G end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or ji==0 and N then AutopilotAccelerating=false;AutopilotStatus="Cruising"AutopilotCruising=true;cb(0)end;if AutopilotDistance<=a6 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true;cb(0)N=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;W=1 end;if TurnBurn then cb(1,true)end;local _,iV=ba(aa):escapeAndOrbitalSpeed((bL-planet.center):len()-planet.radius)local cV;if CustomTarget~=nil then cV=CustomTarget.position-bL end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bI<50 then a0="Autopilot complete, arrived at space location"AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bI<=iV and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then a0="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cb(0)N=false;ProgradeIsOn=true;am=true;cr(aa,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 then AutopilotStatus="Circularizing"local _,iV=ba(aa):escapeAndOrbitalSpeed((bL-planet.center):len()-planet.radius)if bI<=iV then if CustomTarget~=nil then if bH:normalize():dot(cV:normalize())>0.4 then AutopilotStatus="Orbiting to Target"if not WaypointSet then BrakeIsOn=false;cr(aa,CustomTarget.position)WaypointSet=true end else a0="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cb(0)N=false;ProgradeIsOn=true;am=true;BrakeIsOn=false;cr(aa,CustomTarget.position)WaypointSet=false end else BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"a0="Autopilot completed, orbit established"W=0;cb(0)N=false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then ProgradeIsOn=true;am=true end end end end elseif AutopilotCruising then if AutopilotDistance<=a6 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true end;local ji=unit.getThrottle()if AtmoSpeedAssist then ji=G end;if ji>0 then AutopilotAccelerating=true;AutopilotStatus="Accelerating"AutopilotCruising=false end else if iM then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not am then AutopilotTargetCoords=vec3(aa.center)+(AutopilotTargetOrbit+aa.radius)*bG;AutopilotShipUp=bE;AutopilotShipRight=bG end;AutopilotRealigned=true elseif iM then AutopilotAccelerating=true;AutopilotStatus="Accelerating"if not N then cb(AutopilotInterplanetaryThrottle,true)G=y(AutopilotInterplanetaryThrottle,2)N=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and at>0)then a0="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"W=0;cb(0)N=false;ProgradeIsOn=true;am=true;cr(aa,CustomTarget.position)end;if Y then bg=true;local jf=0;local f0=bL+vec3(unit.getMasterPlayerRelativePosition())local jj=f0-bL;local jk=vec3(jj):project_on(bF):len()local jl=vec3(jj):project_on(bG):len()local ai=math.sqrt(jk*jk+jl*jl)cM(jj:normalize())local jm=40;local jn=ai<jm;local jo=100;local jp=r((ai-jm)/2,10,jo)S=0;local iM=c(T)<0.1;if iM and bI<jp and not jn then BrakeIsOn=false;jf=-20 else BrakeIsOn=true;jf=0 end;local jq=0;if c(jf-bQ)>jq then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(jf-bQ)local jg=pitchPID:get()S=jg end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local cF=unit.getClosestPlanetInfluence()>0;local jr=HoldAltitude-au;local js=500+bI;local jt=1;if AutoTakeoff then jt=r(bI/100,0.1,1)end;local jf=(utils.smoothstep(jr,-js,js)-0.5)*2*MaxPitch*jt;if not Reentry and not am and not VectorToTarget and bF:dot(bH:normalize())<0.99 then jf=(utils.smoothstep(jr,-js*r(20-19*at*10,1,20),js*r(20-19*at*10,1,20))-0.5)*2*MaxPitch*r(2-at*10,1,2)*jt end;if not AltitudeHold then jf=0 end;if LockPitch~=nil then if cF and not IntoOrbit then jf=LockPitch else LockPitch=nil end end;bg=true;local ju=S;if Reentry then local jv=d(bn)local jw,jx=b8.computeDistanceAndTime(bI,jv/3.6,l(),0,0,LastMaxBrake-planet.gravity*9.8*l())local jy=au-(planet.noAtmosphericDensityAltitude+5000)if not bP and au>planet.noAtmosphericDensityAltitude+5000 and bI<=jv/3.6 and bI>jv/3.6-10 and c(bH:normalize():dot(bF))>0.9 then cb(0)elseif bP and(jw>-1 and jy<=jw or au<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;ce(jv,true)if not P then jf=-80;if at>0.02 then a0="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;jf=0;bg=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and au>planet.noAtmosphericDensityAltitude+5000 then bg=true elseif au<=planet.noAtmosphericDensityAltitude+5000 then ce(jv)if not bP and s:getTargetSpeed(axisCommandId.longitudinal)==bn then P=false;Reentry=false;bg=true end end end;if bI>O and not an and not VectorToTarget and not BrakeLanding and ForceAlignment then cM(vec3(bH))end;if(VectorToTarget or an)and AutopilotTargetIndex>0 and at>0.01 then local cV;if CustomTarget~=nil then cV=CustomTarget.position-bL else cV=aa.center-bL end;local je=math.deg(iu(bJ:normalize(),bH,cV))*2;local jz=math.rad(c(bR))if bI>minRollVelocity and at>0.01 then local jA=r(90-jf*2,-90,90)bk=r(je*2,-jA,jA)local jB=je;je=r(r(je,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jz)+4*(bQ-jf)*math.sin(math.rad(bR)),-YawStallAngle*0.80,YawStallAngle*0.80)jf=r(r(jf*math.cos(jz),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(r(c(jB)*math.sin(jz),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bk=0;je=r(je,-YawStallAngle*0.80,YawStallAngle*0.80)end;local jC=iH-je;if not bi and bI>minRollVelocity and at>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(jC)local jh=r(yawPID:get(),-1,1)T=T+jh elseif as and ap>-1 or bI<minRollVelocity then cM(cV)elseif bi and at>0.01 then if(iH<-YawStallAngle or iH>YawStallAngle)and at>0.01 then cM(bH)end;if(iI<-PitchStallAngle or iI>PitchStallAngle)and at>0.01 then jf=r(bQ-iI,bQ-PitchStallAngle*0.80,bQ+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not an then local iN=planet:getAltitude(CustomTarget.position)local jy=math.sqrt(cV:len()^2-(au-iN)^2)local jD=LastMaxBrakeInAtmo;if jD then jD=jD*r(bI/100,0.1,1)*at else jD=LastMaxBrake end;if at<0.01 then jD=LastMaxBrake end;local jE=bH:len()-c(bK)local jF=vec3(core.getWorldAirFrictionAcceleration())local jG=math.sqrt(jF:len()-jF:project_on(g6):len())*l()if bI>100 then a6,a7=b8.computeDistanceAndTime(bI,100,l(),0,0,jD+jG)local jH,jI=b8.computeDistanceAndTime(100,0,l(),0,0,jD/2)a6=a6+jH else a6,a7=b8.computeDistanceAndTime(bI,0,l(),0,0,jD/2)end;StrongBrakes=true;if not an and not Reentry and jy<=a6+bI*iG/2 and(bH:project_on_plane(bJ):normalize():dot(cV:project_on_plane(bJ):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cb(0)if AltitudeHold then cp()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(jE<0.1 or jy<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<jy)then if not bN then BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"end;LastDistanceToTarget=jy end elseif VectorToTarget and at==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(an or Reentry)then if CustomTarget~=nil and aa.name==planet.name then local cV=CustomTarget.position-bL;local iN=planet:getAltitude(CustomTarget.position)local jy=math.sqrt(cV:len()^2-(au-iN)^2)local jD=LastMaxBrakeInAtmo;if jD then a6,a7=b8.computeDistanceAndTime(bI,0,l(),0,0,jD/2)StrongBrakes=true;if jy<=a6+bI*iG/2 and bH:project_on_plane(bJ):normalize():dot(cV:project_on_plane(bJ):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;P=true;am=false;ao=true;Autopilot=false;cY()end end;LastDistanceToTarget=jy end end end;if at==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(an or IntoOrbit or Reentry)then if not by and not IntoOrbit then bw=HoldAltitude;bv=true;if VectorToTarget then bu.VectorToTarget=true end;co()VectorToTarget=false;bs=true end end;if bi and at>0.01 and ap==-1 and bI>minRollVelocity and VectorStatus~="Finalizing Approach"then cM(bH)jf=r(bQ-iI,bQ-PitchStallAngle*0.80,bQ+PitchStallAngle*0.80)end;S=ju;local iD=-1;if BrakeLanding then jf=0;local jJ=false;local jK=30;if b9~=nil and b9>0 then local jG=0;local jL=r(at,0.4,2)local jD=LastMaxBrakeInAtmo*r(bI/100,0.1,1)*jL;local jM=b9*jL+jD+jG-i1;local jN=jD/2+jG-i1;local jO=bI-math.sqrt(c(jN/2)*20/(0.5*l()))*utils.sign(jN)if jO<0 then jO=0 end;local jP;if bI>100 then local jQ,_=b8.computeDistanceAndTime(bI,100,l(),0,0,jD)local jR,_=b8.computeDistanceAndTime(100,0,l(),0,0,math.sqrt(jD))jP=jQ+jR else jP=b8.computeDistanceAndTime(bI,0,l(),0,0,math.sqrt(jD))end;if jP<20 then BrakeIsOn=false else local jS=0;if jO>100 then local jT,_=b8.computeDistanceAndTime(jO,100,l(),0,0,jM)local jU,_=b8.computeDistanceAndTime(100,0,l(),0,0,b9*jL+math.sqrt(jD)+jG-i1)jS=jT+jU else jS,_=b8.computeDistanceAndTime(jO,0,l(),0,0,b9*jL+math.sqrt(jD)+jG-i1)end;jS=(jS+15+bI*iG)*1.1;local jV=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if jV then local iN=planet:getAltitude(CustomTarget.position)local jW=au-iN-100;local cV=CustomTarget.position-bL;local jX=math.sqrt(cV:len()^2-(au-iN)^2)if jX>100 then jV=false elseif jW<=jS or jS==-1 then BrakeIsOn=true;jJ=true else BrakeIsOn=false;jJ=true end end;if not jV and CalculateBrakeLandingSpeed then if jS>=jK then BrakeIsOn=true else BrakeIsOn=false end;jJ=true end end end;if not bP then cb(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)iD=ap;if iD>-1 then bg=autoRollPreference;if bI<1 or bH:normalize():dot(bJ)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)ae=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bH:normalize():dot(-g6)<0.999 then BrakeIsOn=true elseif bK<-brakeLandingRate and not jJ then BrakeIsOn=true elseif not jJ then BrakeIsOn=false end end;if AutoTakeoff or an then local hp,el,ek;if AutopilotTargetCoords~=nil then hp,el,ek=b7:getPlanetarySystem(0):castIntersections(bL,(AutopilotTargetCoords-bL):normalize(),function(e8)return e8.radius+e8.noAtmosphericDensityAltitude end)end;if bN then if au>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cb(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(jf)<15 and au/HoldAltitude>0.75 then AutoTakeoff=false;if not an then if bP and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif an and bI<O then Autopilot=true;an=false;AltitudeHold=false;AutoTakeoff=false;cb(0)elseif an then cb(0)BrakeIsOn=true end elseif an and at==0 and aa~=nil and(hp==nil or hp.name==aa.name)then Autopilot=true;an=false;AltitudeHold=false;AutoTakeoff=false;if not bP then cb(0)end;AutopilotAccelerating=true end end;local jY=ap>-1;local jZ=bQ;if(VectorToTarget or an)and not jY and bI>minRollVelocity and at>0.01 then local jz=math.rad(c(bR))jZ=bQ*c(math.cos(jz))+iI*math.sin(jz)end;local j_=r(jf-jZ,-PitchStallAngle*0.80,PitchStallAngle*0.80)if at<0.01 and VectorToTarget then j_=r(jf-jZ,-85,MaxPitch)elseif at<0.01 then j_=r(jf-jZ,-MaxPitch,MaxPitch)end;if c(bR)<5 or VectorToTarget or BrakeLanding or jY or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(j_)local jg=pitchPID:get()S=S+jg end end;if antigrav~=nil and(antigrav and not ExternalAGG and au<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ap=iy()return iq end;function script.onStart()local function k0()local function k1(k2)local k3=dbHud_1.hasKey;for d9,da in pairs(k2)do if k3(da)then local cl=f(dbHud_1.getStringValue(da))if cl~=nil then _G[da]=cl;aL=true end end end end;if dbHud_1 then local k3=dbHud_1.hasKey;if not useTheseSettings then k1(bZ())coroutine.yield()k1(b)else k1(b)a0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ah=5;aL=false end;coroutine.yield()if aL then a0="Loaded Saved Variables"L=y(ResolutionX/2,0)M=y(ResolutionY/2,0)aJ=ResolutionX;aK=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bg=autoRollPreference;bn=AtmoSpeedLimit;az=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]aA=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]elseif not useTheseSettings then a0="No Saved Variables Found - Exit HUD to save settings"end else a0="No databank found. Attach one to control unit and rerun the autoconfigure to save preferences and locations"end;if LastStartTime+180<bD then LastMaxBrakeInAtmo=0 end;LastStartTime=bD;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ah=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=au end;antigrav.setBaseAltitude(AntigravTargetAltitude)end end;local function k4()local function k5(k6,k7)if k6>k7 then k7=k6 end;if ContainerOptimization>0 then k7=k7-k7*ContainerOptimization*0.05 end;if FuelTankOptimization>0 then k7=k7-k7*FuelTankOptimization*0.05 end;return k7 end;local k8=core.getElementNameById;local k9=fuelX~=0 and fuelY~=0;for d9 in pairs(av)do local type=core.getElementTypeById(av[d9])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(av[d9])),'^.*vertical.*$')then bM=true end end;if o(type,'^.*Space Engine$')then bB=true;if o(tostring(core.getElementTagsById(av[d9])),'^.*vertical.*$')then local ka=core.getElementRotationById(av[d9])if ka[4]<0 then if p(-ka[4],0.1)==0.5 then bz=true end else if p(ka[4],0.1)==0.5 then bA=true end end end end;if type=="Landing Gear"then Q=true end;if type=="Dynamic Core Unit"then local kb=h(av[d9])if kb>10000 then C=128 elseif kb>1000 then C=64 elseif kb>150 then C=32 end end;aS=aS+h(av[d9])if k9 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local kb=h(av[d9])local kc=k(av[d9])local k6=0;local fZ=q()if type=="Atmospheric Fuel Tank"then local k7=400;local kd=35.03;if kb>10000 then k7=51200;kd=5480 elseif kb>1300 then k7=6400;kd=988.67 elseif kb>150 then k7=1600;kd=182.67 end;k6=kc-kd;if fuelTankHandlingAtmo>0 then k7=k7+k7*fuelTankHandlingAtmo*0.2 end;k7=k5(k6,k7)aP[#aP+1]={av[d9],k8(av[d9]),k7,kd,k6,fZ}end;if type=="Rocket Fuel Tank"then local k7=320;local kd=173.42;if kb>65000 then k7=40000;kd=25740 elseif kb>6000 then k7=5120;kd=4720 elseif kb>700 then k7=640;kd=886.72 end;k6=kc-kd;if fuelTankHandlingRocket>0 then k7=k7+k7*fuelTankHandlingRocket*0.1 end;k7=k5(k6,k7)aR[#aR+1]={av[d9],k8(av[d9]),k7,kd,k6,fZ}end;if type=="Space Fuel Tank"then local k7=2400;local kd=182.67;if kb>10000 then k7=76800;kd=5480 elseif kb>1300 then k7=9600;kd=988.67 end;k6=kc-kd;if fuelTankHandlingSpace>0 then k7=k7+k7*fuelTankHandlingSpace*0.2 end;k7=k5(k6,k7)aQ[#aQ+1]={av[d9],k8(av[d9]),k7,kd,k6,fZ}end end end;if not bM then VertTakeOff,VertTakeOffEngine=false,false end end;local function ke()if gyro~=nil then ax=gyro.getState()==1 end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(as or not as and au<10000)then for _,da in pairs(door)do da.toggle()end end;if switch then for _,da in pairs(switch)do da.toggle()end end;if forcefield and(as or not as==0 and au<10000)then for _,da in pairs(forcefield)do da.toggle()end end;if antigrav then bN=antigrav.getState()==1;if bN and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if Q then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ap~=-1 or not as and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;if not Q then GearExtended=true end else BrakeIsOn=false end;if bh~=nil then s:setTargetGroundAltitude(bh)if bh==0 and not Q then GearExtended=true;BrakeIsOn=true end else bh=a:getTargetGroundAltitude()if GearExtended then s:setTargetGroundAltitude(LandingGearGroundHeight)else s:setTargetGroundAltitude(TargetHoverHeight)end end;if as and ap~=-1 then b9=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=as end;local function kf(kg,kh,ki,kj,c6,c7,kk,kl,km,kn)local ko={enableName=kg,disableName=kh,width=ki,height=kj,x=c6,y=c7,toggleVar=kk,toggleFunction=kl,drawCondition=km,hovered=false}if kn then table.insert(aI,ko)else table.insert(aH,ko)end;return ko end;local function kp(kq)if not bS then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif kq=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif kq=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif kq=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bT=bZ(kq)showHud=false else bT={}showHud=true end end;local function kr()bS=not bS;if bS then aG=aI;a0="Hold SHIFT to see Settings"bU=showHud else aG=aH;a0="Hold SHIFT to see Control Buttons"kp()showHud=bU end end;local function ks(da)_G[da]=not _G[da]if _G[da]then a0=da.." set to true"else a0=da.." set to false"end;if da=="showHud"then bU=_G[da]elseif da=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function kt()local ku=50;local kv=340;local c6=500;local c7=aK/2-400;local kw=0;for d9,da in pairs(bZ("boolean"))do if type(_G[da])=="boolean"then kf(da,da,kv,ku,c6,c7,function()return _G[da]end,function()ks(da)end,function()return true end,true)c7=c7+ku+20;if kw==7 then c6=c6+kv+20;c7=aK/2-400;kw=0 else kw=kw+1 end end end;kf("Control View","Control View",kv,ku,10,aK/2-500,function()return true end,kr,function()return true end,true)kf("View Handling Settings",'Hide Handling Settings',kv,ku,10,aK/2-(500-ku),function()return showHandlingVariables end,function()kp("handling")end,function()return true end,true)kf("View Hud Settings",'Hide Hud Settings',kv,ku,10,aK/2-(500-ku*2),function()return showHudVariables end,function()kp("hud")end,function()return true end,true)kf("View Physics Settings",'Hide Physics Settings',kv,ku,10,aK/2-(500-ku*3),function()return showPhysicsVariables end,function()kp("physics")end,function()return true end,true)end;local function kx()local function ky()if dbHud_1 then local position=bL;local fS=planet.name..". "..#SavedLocations;if radar_1 then local dR,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dR~=nil and dR~=""then fS=fS.." "..radar_1.getConstructName(dR)end end;local cJ={}cJ={position=position,name=fS,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cJ;table.insert(b2[0],cJ)bc.UpdateAtlasLocationsList()a0="Location saved as "..fS else a0="Databank must be installed to save locations"end end;local function kz()TurnBurn=not TurnBurn end;local function kA(kB)if kB==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Y=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kC()kA(1)end;local function kD()local cI=-1;cI=bc.findAtlasIndex(b2[0])if cI>-1 then table.remove(b2[0],cI)end;cI=-1;cI=bc.findAtlasIndex(SavedLocations)if cI~=-1 then a0=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cI)end;bc.adjustAutopilotTargetIndex()bc.UpdateAtlasLocationsList()end;local function kE()local fS=AutopilotTargetName;if fS==nil then local ho,cm=ci((bL-CustomTarget.position):len())fS=CustomTarget.name.." "..ho..cm end;if fS==nil then fS="None"end;return"Engage Autopilot: "..fS end;local function kF()local fS=AutopilotTargetName;if fS==nil then fS=CustomTarget.name end;if fS==nil then fS="None"end;return"Disable Autopilot: "..fS end;local ku=50;local kv=260;local kG=kf("Enable Brake Toggle","Disable Brake Toggle",kv,ku,aJ/2-kv/2,aK/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a0="Brakes in Toggle Mode"else a0="Brakes in Default Mode"end end)kf("Align Prograde","Disable Prograde",kv,ku,aJ/2-kv/2-50-kG.width,aK/2-ku+380,function()return ProgradeIsOn end,kC)kf("Align Retrograde","Disable Retrograde",kv,ku,aJ/2-kv/2+kG.width+50,aK/2-ku+380,function()return RetrogradeIsOn end,kA,function()return at==0 end)local kH=kf(kE,kF,600,60,aJ/2-600/2,aK/2-60/2-400,function()return Autopilot end,cD)kf("Save Position","Save Position",200,kH.height,kH.x+kH.width+30,kH.y,function()return false end,ky,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)kf("Update Position","Update Position",200,kH.height,kH.x+kH.width+30,kH.y,function()return false end,cG,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kf("Clear Position","Clear Position",200,kH.height,kH.x-200-30,kH.y,function()return true end,kD,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ku=60;kv=300;local c6=10;local c7=aK/2-500;kf("Show Help","Hide Help",kv,ku,c6,c7,function()return showHelp end,function()showHelp=not showHelp end)c7=c7+ku+20;kf("View Settings","View Settings",kv,ku,c6,c7,function()return true end,kr)local c7=aK/2-300;kf("Enable Turn and Burn","Disable Turn and Burn",kv,ku,c6,c7,function()return TurnBurn end,kz)kf("Horizontal Takeoff Mode","Vertical Takeoff Mode",kv,ku,c6+kv+20,c7,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a0="Vertical Takeoff Mode"else a0="Horizontal Takeoff Mode"end end,function()return bM end)c7=c7+ku+20;kf("Show Orbit Display","Hide Orbit Display",kv,ku,c6,c7,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a0="Orbit Display Enabled"else a0="Orbit Display Disabled"end end)kf("Engage Orbiting","Cancel Orbiting",kv,ku,c6+kv+20,c7,function()return IntoOrbit end,co,function()return at==0 and unit.getClosestPlanetInfluence()>0 end)c7=c7+ku+20;kf("Glide Re-Entry","Cancel Glide Re-Entry",kv,ku,c6,c7,function()return Reentry end,function()am=true;kC()end,function()return planet.hasAtmosphere and not as end)kf("Parachute Re-Entry","Cancel Parachute Re-Entry",kv,ku,c6+kv+20,c7,function()return Reentry end,cY,function()return planet.hasAtmosphere and not as end)c7=c7+ku+20;kf("Engage Follow Mode","Disable Follow Mode",kv,ku,c6,c7,function()return Y end,cq,function()return m()==1 end)kf("Enable Repair Arrows","Disable Repair Arrows",kv,ku,c6+kv+20,c7,function()return aT end,function()aT=not aT;if aT then a0="Repair Arrows Enabled"else a0="Repair Arrows Diabled"end end,function()return m()==1 end)c7=c7+ku+20;if not ExternalAGG then kf("Enable AGG","Disable AGG",kv,ku,c6,c7,function()return bN end,c_,function()return antigrav~=nil end)end;c7=c7+ku+20;kf(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,kv*2,ku,c6,c7,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end end)end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})k0()coroutine.yield()k4()coroutine.yield()bd=ip()ke()kt()kx()aG=aH;coroutine.yield()b2=db()b6=dc()b7=b6(db())b8=eu()ba=eZ()bb=fl()bc=ig()bd=ip()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)if UseSatNav then unit.setTimer("fiveSecond",5)end end)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(at>0 or at==0 and au<10000)then for _,da in pairs(door)do da.toggle()end end;if switch then for _,da in pairs(switch)do da.toggle()end end;if forcefield and(at>0 or at==0 and au<10000)then for _,da in pairs(forcefield)do da.toggle()end end;d5()if button then button.activate()end;if SetWaypointOnExit then cr(planet,bL)end end;function script.onTick(kI)if kI=="tenthSecond"then local function kJ()local kK=system.createData;local kL=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=kL(panelInterplanetary,"value")interplanetaryHeaderText=kK('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=kL(panelInterplanetary,"value")widgetDistanceText=kK('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=kL(panelInterplanetary,"value")widgetTravelTimeText=kK('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=kL(panelInterplanetary,"value")widgetMaxMassText=kK('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=kL(panelInterplanetary,"value")widgetTargetOrbitText=kK('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=kL(panelInterplanetary,"value")widgetCurBrakeDistanceText=kK('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=kL(panelInterplanetary,"value")widgetCurBrakeTimeText=kK('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=kL(panelInterplanetary,"value")widgetMaxBrakeDistanceText=kK('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=kL(panelInterplanetary,"value")widgetMaxBrakeTimeText=kK('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=kL(panelInterplanetary,"value")widgetTrajectoryAltitudeText=kK('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not as then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function kM()t(panelInterplanetary)panelInterplanetary=nil end;local function kN()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(aa.center-bL):len()else AutopilotDistance=(CustomTarget.position-bL):len()end end;local eX=bI;local ji=unit.getThrottle()/100;if AtmoSpeedAssist then ji=G end;local kO,kP=b8.computeDistanceAndTime(bI,MaxGameVelocity,l(),a:maxForceForward()*ji,warmup,0)local a6,a7;if not TurnBurn then a6,a7=bd.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=bd.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,kQ;if not TurnBurn and eX>0 then _,kQ=bd.GetAutopilotBrakeDistanceAndTime(eX)else _,kQ=bd.GetAutopilotTBBrakeDistanceAndTime(eX)end;local kR=0;local kS=0;if AutopilotCruising or not Autopilot and eX>5 then kS=b8.computeTravelTime(eX,0,AutopilotDistance)elseif a6+kO<AutopilotDistance then kR=AutopilotDistance-(a6+kO)kS=b8.computeTravelTime(8333.0556,0,kR)else local kT=(AutopilotDistance-a6)/kO;kO=AutopilotDistance-a6;kP=kP*kT end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return kS elseif AutopilotBraking then return kQ elseif AutopilotCruising then return kS+kQ else return kP+a7+kS end end;if at>0 and not WasInAtmo then if not bP and AtmoSpeedAssist and(AltitudeHold or Reentry)then cb(1)K=false end end;if bO~=nil then if s:getTargetSpeed(axisCommandId.longitudinal)~=bO then ce(bO,TRUE)else bO=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then kJ()end;if AutopilotTargetName~=nil then local kU=CustomTarget~=nil;planetMaxMass=LastMaxBrakeInAtmo/aa:getGravity(aa.center+vec3(0,0,1)*aa.radius):len()u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=kN()if kU and not Autopilot then ai=(bL-CustomTarget.position):len()else ai=(AutopilotTargetCoords-bL):len()end;if not TurnBurn then a6,a7=bd.GetAutopilotBrakeDistanceAndTime(bI)a8,a9=bd.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=bd.GetAutopilotTBBrakeDistanceAndTime(bI)a8,a9=bd.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ho,cm=ci(ai)u(widgetDistanceText,'{"label": "distance", "value": "'..ho..'", "unit":"'..cm..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d0(travelTime)..'", "unit":""}')ho,cm=ci(a6)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ho..'", "unit":"'..cm..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d0(a7)..'", "unit":""}')ho,cm=ci(a8)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ho..'", "unit":"'..cm..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d0(a9)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",planetMaxMass/1000)..'", "unit":" Tons"}')ho,cm=ci(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..e("%.2f",ho)..'", "unit":"'..cm..'"}')if at>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if at==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else kM()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif kI=="oneSecond"then local function kV(i1,kW)if i1==nil then i1=core.g()end;i1=y(i1,5)if kW~=nil and kW or(aO==nil or aO~=i1)then local e_=core.getVelocity()local eX=vec3(e_):len()local kX=f(unit.getData()).maxBrake;if kX~=nil and kX>0 and as then kX=kX/r(eX/100,0.1,1)kX=kX/at;if at>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+kX)/2 else LastMaxBrakeInAtmo=kX end end end;if kX~=nil and kX>0 then LastMaxBrake=kX end;aO=i1 end end;local function kY(fC)local kZ=0;aE=""local k_=aS;local l0=0;local l1=0;local l2=0;local g0=0;local g1=""local l3=core.getElementHitPointsById;for d9 in pairs(av)do local kb=0;local l4=0;l4=h(av[d9])kb=l3(av[d9])l0=l0+kb;if kb<l4 then if kb==0 then l2=l2+1 else l1=l1+1 end;if aT and#aB==0 then position=vec3(core.getElementPositionById(av[d9]))local c6=position.x-C;local c7=position.y-C;local l5=position.z-C;table.insert(aB,core.spawnArrowSticker(c6,c7,l5+1,"down"))table.insert(aB,core.spawnArrowSticker(c6,c7,l5+1,"down"))core.rotateSticker(aB[2],0,0,90)table.insert(aB,core.spawnArrowSticker(c6+1,c7,l5,"north"))table.insert(aB,core.spawnArrowSticker(c6+1,c7,l5,"north"))core.rotateSticker(aB[4],90,90,0)table.insert(aB,core.spawnArrowSticker(c6-1,c7,l5,"south"))table.insert(aB,core.spawnArrowSticker(c6-1,c7,l5,"south"))core.rotateSticker(aB[6],90,-90,0)table.insert(aB,core.spawnArrowSticker(c6,c7-1,l5,"east"))table.insert(aB,core.spawnArrowSticker(c6,c7-1,l5,"east"))core.rotateSticker(aB[8],90,0,90)table.insert(aB,core.spawnArrowSticker(c6,c7+1,l5,"west"))table.insert(aB,core.spawnArrowSticker(c6,c7+1,l5,"west"))core.rotateSticker(aB[10],-90,0,90)table.insert(aB,av[d9])end elseif aT and#aB>0 and aB[11]==av[d9]then for fU in pairs(aB)do core.deleteSticker(aB[fU])end;aB={}end end;kZ=d(l0/k_*100)if kZ<100 then fC[#fC+1]=c5(0,0,"","pbright txt")g0=d(kZ*2.55)g1=e("rgb(%d,%d,%d)",255-g0,g0,0)if kZ<100 then fC[#fC+1]=c5("50%",1035,"Elemental Integrity: "..kZ.."%","txtbig txtmid","fill:"..g1)if l2>0 then fC[#fC+1]=c5("50%",1055,"Disabled Modules: "..l2 .." Damaged Modules: "..l1,"txtbig txtmid","fill:"..g1)elseif l1>0 then fC[#fC+1]=c5("50%",1055,"Damaged Modules: "..l1,"txtbig txtmid","fill:"..g1)end end end end;local function l6()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function l7()local fZ=q()local hc=bI;local l8=fZ-aw;if hc>1.38889 then hc=hc/1000;local l9=hc*(fZ-aw)TotalDistanceTravelled=TotalDistanceTravelled+l9;ab=ab+l9 end;ac=ac+l8;TotalFlightTime=TotalFlightTime+l8;aw=fZ end;aq=false;kV(nil,true)l7()bb.UpdateRadar()l6()local fC={}bb.ExtraData(fC)if ShowOdometer then fC=bb.DrawOdometer(fC,ab,TotalDistanceTravelled,ac)end;if ShouldCheckDamage then kY(fC)end;ak=table.concat(fC,"")collectgarbage("collect")elseif kI=="fiveSecond"then ar=dbHud_1.getStringValue("SPBAutopilotTargetName")if ar~=nil and ar~=""and ar~="SatNavNotChanged"then local cl=f(dbHud_1.getStringValue("SavedLocations"))if cl~=nil then _G["SavedLocations"]=cl;local cI=-1;local cJ;for d9,da in pairs(SavedLocations)do if da.name and da.name=="SatNav Location"then cI=d9;break end end;if cI~=-1 then cJ=SavedLocations[cI]cI=-1;for d9,da in pairs(b2[0])do if da.name and da.name=="SatNav Location"then cI=d9;break end end;if cI>-1 then b2[0][cI]=cJ end;bc.UpdateAtlasLocationsList()a0=cJ.name.." position updated"end end;for i=1,#bV do if bV[i].name==ar then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bV[i].name)bc.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif kI=="msgTick"then local fC={}bb.DisplayMessage(fC,"empty")a0="empty"unit.stopTimer("msgTick")ah=3 elseif kI=="animateTick"then bf=true;be=false;af=0;ag=0;unit.stopTimer("animateTick")elseif kI=="hudTick"then local function la(fC)local lb=d(r(ai/(aJ/4)*255,0,255))fC[#fC+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",af,ag,d(D+0.5)+lb,d(F+0.5)-lb,d(E+0.5)-lb)end;local function lc()for _,da in pairs(aG)do if da.hovered then if not da.drawCondition or da.drawCondition()then da.toggleFunction()end;da.hovered=false end end end;local function ld()local function le(lf,lg,c6,c7,ki,kj)if lf>c6 and lf<c6+ki and lg>c7 and lg<c7+kj then return true else return false end end;local c6=af+aJ/2;local c7=ag+aK/2;for _,da in pairs(aG)do da.hovered=le(c6,c7,da.x,da.y,da.width,da.height)end end;local function lh(fC)local function li(fC,lj,hover,c6,c7,eQ,lk,ll,lm,ln,lo)if type(ln)=="function"then ln=ln()end;if type(lo)=="function"then lo=lo()end;fC[#fC+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c6,c7,eQ,lk)if lj then fC[#fC+1]=e("%s'",ll)else fC[#fC+1]=lm end;if hover then fC[#fC+1]=" style='stroke:white; stroke-width:2'"else fC[#fC+1]=" style='stroke:black; stroke-width:1'"end;fC[#fC+1]="></rect>"fC[#fC+1]=e("<text x='%f' y='%f' font-size='24' fill='",c6+eQ/2,c7+lk/2+5)if lj then fC[#fC+1]="black"else fC[#fC+1]="white"end;fC[#fC+1]="' text-anchor='middle' font-family='Montserrat'>"if lj then fC[#fC+1]=e("%s</text>",ln)else fC[#fC+1]=e("%s</text>",lo)end end;local lp="rgb(50,50,50)'"local lq="rgb(210,200,200)"local lr=li;for _,da in pairs(aG)do local kh=da.disableName;local kg=da.enableName;if type(kh)=="function"then kh=kh()end;if type(kg)=="function"then kg=kg()end;if not da.drawCondition or da.drawCondition()then lr(fC,da.toggleVar(),da.hovered,da.x,da.y,da.width,da.height,lq,lp,kh,kg)end end end;local fC={}bb.HUDPrologue(fC)if showHud then bb.UpdateHud(fC)else bb.DisplayOrbitScreen(fC)bb.DrawWarnings(fC)end;if bS and bT~={}then bb.DrawSettings(fC)end;bb.HUDEpilogue(fC)fC[#fC+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aJ,aK)if a0~="empty"then bb.DisplayMessage(fC,a0)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then bb.DrawDeadZone(fC)end end;if x()==0 then if m()==1 and Z then ld()lh(fC)if not be and not bf then local ls=table.concat(fC,"")fC={}fC[#fC+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aJ,aK)fC[#fC+1]=ls;fC[#fC+1]="</body>"be=true;fC[#fC+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fC,"")system.setScreen(content)elseif bf then local ls=table.concat(fC,"")fC={}fC[#fC+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aJ,aK)fC[#fC+1]=ls;fC[#fC+1]="</body>"end;if not be then fC[#fC+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],L,M,af,ag)end else lc()end else if not Z and m()==0 then lc()if ai>DeadZone then if DisplayDeadZone then la(fC)end end else ld()lh(fC)end;fC[#fC+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],L,M,af,ag)end;fC[#fC+1]=[[</svg></body>]]content=table.concat(fC,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif kI=="apTick"then bd.APTick()end end;function script.onFlush()local function lt(lu,jp)local lv=vec3()local lw=vec3()if lu==axisCommandId.longitudinal then lv=vec3(core.getConstructOrientationForward())lw=bF elseif lu==axisCommandId.vertical then lv=vec3(core.getConstructOrientationUp())lw=bE elseif lu==axisCommandId.lateral then lv=vec3(core.getConstructOrientationRight())lw=bG else return vec3()end;local lx=vec3(core.getWorldGravity())local ly=lx:dot(lw)local lz=vec3(core.getWorldAirFrictionAcceleration())local lA=lz:dot(lw)local lB=vec3(core.getVelocity())local lC=lB:dot(lv)local lD=jp*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(lD-lC)local lE=targetSpeedPID2:get()local lF=(lE-lA-ly)*lw;return lF end;local function lG(lu,jp)local lv=vec3()local lw=vec3()if lu==axisCommandId.longitudinal then lv=vec3(core.getConstructOrientationForward())lw=bF elseif lu==axisCommandId.vertical then lv=vec3(core.getConstructOrientationUp())lw=bE elseif lu==axisCommandId.lateral then lv=vec3(core.getConstructOrientationRight())lw=bG else return vec3()end;local lx=vec3(core.getWorldGravity())local ly=lx:dot(lw)local lz=vec3(core.getWorldAirFrictionAcceleration())local lA=lz:dot(lw)local lB=vec3(core.getVelocity())local lC=lB:dot(lv)local lD=jp*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(lD-lC)local lE=targetSpeedPID:get()local lF=(lE-lA-ly)*lw;return lF end;local function lH(lI,g5,ik)local lJ=lI:cross(ik):normalize_inplace()local gQ=math.acos(r(lJ:dot(-g5),-1,1))*constants.rad2deg;if lJ:cross(-g5):dot(ik)<0 then gQ=-gQ end;return gQ end;if antigrav and not ExternalAGG then if not bN and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bP=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bP and K then cb(0)K=false elseif not bP and not K then G=0;K=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local lK=r(R+S+system.getControlDeviceForwardInput(),-1,1)local lL=r(U+X+system.getControlDeviceYawInput(),-1,1)local lM=r(V+T-system.getControlDeviceLeftRightInput(),-1,1)local lN=W;bJ=vec3(core.getWorldVertical())if bJ==nil or bJ:len()==0 then bJ=(planet.center-bL):normalize()end;bL=vec3(core.getConstructWorldPos())bE=vec3(core.getConstructWorldOrientationUp())bF=vec3(core.getConstructWorldOrientationForward())bG=vec3(core.getConstructWorldOrientationRight())bH=vec3(core.getWorldVelocity())bI=vec3(bH):len()bK=-bJ:dot(bH)bR=getRoll(bJ,bF,bG)local lO=bR/180*math.pi;local lP=math.cos(lO)local lQ=math.sin(lO)bQ=lH(bJ,bF,bG*lP+bE*lQ)local lR=bH:normalize()local lS=getRoll(bJ,bF,bG)local lT=c(lS)local lU=utils.sign(lS)local lV=vec3(core.getWorldAngularVelocity())local lW=lK*pitchSpeedFactor*bG+lL*rollSpeedFactor*bF+lM*yawSpeedFactor*bE;if bJ:len()>0.01 and(at>0.0 or ProgradeIsOn or Reentry or am or AltitudeHold or IntoOrbit)then if bg==true and c(bk-lS)>autoRollRollThreshold and lL==0 and c(bQ)<85 then local lX=bk;local lY=autoRollFactor;if at==0 then lY=lY/4;bk=0;lX=0 end;if rollPID==nil then rollPID=pid.new(lY*0.01,0,lY*0.1)end;rollPID:inject(lX-lS)local lZ=rollPID:get()lW=lW+lZ*bF end end;if bJ:len()>0.01 and at>0.0 then local l_=20.0;if turnAssist==true and lT>l_ and lK==0 and lM==0 then local m0=turnAssistFactor*0.1;local m1=turnAssistFactor*0.025;local m2=(lT-l_)/(180-l_)*180;local m3=0;if m2<90 then m3=m2/90 elseif m2<180 then m3=(180-m2)/90 end;m3=m3*m3;local m4=-lU*m1*(1.0-m3)local m5=m0*m3;lW=lW+m5*bG+m4*bE end end;local m6=1;local m7=0;local m8=1;if system.getMouseWheel()>0 then if AltIsOn then if at>0 or Reentry then bn=r(bn+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end else G=y(r(G+speedChangeLarge/100,-1,1),2)end elseif system.getMouseWheel()<0 then if AltIsOn then if at>0 or Reentry then bn=r(bn-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end else G=y(r(G-speedChangeLarge/100,-1,1),2)end end;H=0;if as and AtmoSpeedAssist and bP then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bn/3.6-bH:dot(bF))local m9=throttlePID:get()J=r(m9,-1,1)if J<G and at>0.005 then I=true;s:setThrottleCommand(axisCommandId.longitudinal,r(J,0.01,1))else I=false;s:setThrottleCommand(axisCommandId.longitudinal,G)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bH:len()-bn/3.6)local ma=r(brakePID:get(),0,1)if at>0 and bK<-80 or at>0.005 then H=ma end;if H>0 then if I and J==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else J=r(J,0.01,1)end;local mb=''local mc=vec3()local md=lt(axisCommandId.vertical,ae*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",md,m7)local me='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then me=me..ExtraLongitudeTags end;local mf=s:getAxisCommandType(axisCommandId.longitudinal)local mg=s:composeAxisAccelerationFromThrottle(me,axisCommandId.longitudinal)local mh=lG(axisCommandId.lateral,LeftAmount*1000)mb=mb..' , '.."lateral airfoil , lateral ground "mc=mc+mh;if mc:len()>constants.epsilon then a:setEngineForceCommand(mb,mc,m7,'','','',m8)end;a:setEngineForceCommand(me,mg,m6)local mi='thrust analog vertical fueled 'local mj='thrust analog lateral fueled 'if ExtraLateralTags~="none"then mj=mj..ExtraLateralTags end;if ExtraVerticalTags~="none"then mi=mi..ExtraVerticalTags end;if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mi,md,m6)else a:setEngineForceCommand(mi,vec3(),m6)end;if LeftAmount~=0 then a:setEngineForceCommand(mj,mh,m6)else a:setEngineForceCommand(mj,vec3(),m6)end;if lN==0 then lN=H end;local mk=-lN*(brakeSpeedFactor*bH+brakeFlatFactor*lR)a:setEngineForceCommand('brake',mk)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,G)end;local jp=unit.getAxisCommandValue(0)if not bP then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bH:len()-jp/3.6)local ma=r(brakePID:get(),0,1)lN=r(lN+ma,0,1)end;local mk=-lN*(brakeSpeedFactor*bH+brakeFlatFactor*lR)a:setEngineForceCommand('brake',mk)local mb=''local mc=vec3()local ml=false;local me='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then me=me..ExtraLongitudeTags end;local mf=s:getAxisCommandType(axisCommandId.longitudinal)if mf==axisCommandType.byThrottle then local mg=s:composeAxisAccelerationFromThrottle(me,axisCommandId.longitudinal)a:setEngineForceCommand(me,mg,m6)elseif mf==axisCommandType.byTargetSpeed then local mg=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)mb=mb..' , '..me;mc=mc+mg;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ml=true end end;local mj='thrust analog lateral 'if ExtraLateralTags~="none"then mj=mj..ExtraLateralTags end;local mm=s:getAxisCommandType(axisCommandId.lateral)if mm==axisCommandType.byThrottle then local mn=s:composeAxisAccelerationFromThrottle(mj,axisCommandId.lateral)a:setEngineForceCommand(mj,mn,m6)elseif mm==axisCommandType.byTargetSpeed then local mh=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)mb=mb..' , '..mj;mc=mc+mh end;local mi='thrust analog vertical 'if ExtraVerticalTags~="none"then mi=mi..ExtraVerticalTags end;local mo=s:getAxisCommandType(axisCommandId.vertical)if mo==axisCommandType.byThrottle then local md=s:composeAxisAccelerationFromThrottle(mi,axisCommandId.vertical)if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mi,md,m6,'airfoil','ground','',m8)else a:setEngineForceCommand(mi,vec3(),m6)a:setEngineForceCommand('airfoil vertical',md,m6,'airfoil','','',m8)a:setEngineForceCommand('ground vertical',md,m6,'ground','','',m8)end elseif mo==axisCommandType.byTargetSpeed then if ae<0 then a:setEngineForceCommand('hover',vec3(),m6)end;local mp=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)mb=mb..' , '..mi;mc=mc+mp end;if mc:len()>constants.epsilon then if W~=0 or ml or c(lR:dot(bF))<0.8 then mb=mb..', brake'end;a:setEngineForceCommand(mb,mc,m7,'','','',m8)end end;local mq=torqueFactor*(lW-lV)local mr=vec3(core.getWorldAirFrictionAngularAcceleration())mq=mq-mr;a:setEngineTorqueCommand('torque',mq,m6,'airfoil','','',m8)a:setBoosterCommand('rocket_engine')if a5 and not VanillaRockets then local eX=vec3(core.getVelocity()):len()local ms=0.15;if not bP then local mt=s:getTargetSpeed(axisCommandId.longitudinal)if eX*3.6>mt*(1-ms)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eX*3.6<mt*(1-ms)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local ji=unit.getThrottle()if AtmoSpeedAssist then ji=G*100 end;local jp=ji/100;if j==0 then jp=jp*MaxGameVelocity;if eX>=jp*(1-ms)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eX<jp*(1-ms)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jv=d(bn)jp=jp*jv/3.6;if eX>=jp*(1-ms)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eX<jp*(1-ms)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local _,cl=coroutine.resume(beginSetup)if cl then SetupComplete=true end else a:update()if not be and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(mu)local B=1;local function mv(mw)if mw then B=-1 end;if not ExternalAGG and bN then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a2;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bw=bw+B*a1;if bw<planet.noAtmosphericDensityAltitude then bw=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a1 end else s:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function mx(mw)if mw then B=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then G=r(G+B*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if mw then B=1 else B=nil end;bc.adjustAutopilotTargetIndex(B)end end;if mu=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cb(0)if vBooster or hover then if as and ap==-1 then StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bg=true;GearExtended=false elseif as then BrakeIsOn=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)else a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end;if Q and not BrakeLanding then a.control.extendLandingGears()end else if Q then a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif mu=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif mu=="forward"then R=R-1 elseif mu=="backward"then R=R+1 elseif mu=="left"then U=U-1 elseif mu=="right"then U=U+1 elseif mu=="yawright"then V=V-1 elseif mu=="yawleft"then V=V+1 elseif mu=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif mu=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif mu=="up"then ae=ae+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif mu=="down"then ae=ae-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif mu=="groundaltitudeup"then mv()elseif mu=="groundaltitudedown"then mv(true)elseif mu=="option1"then bc.adjustAutopilotTargetIndex()toggleView=false elseif mu=="option2"then bc.adjustAutopilotTargetIndex(1)toggleView=false elseif mu=="option3"then local function my()aF=not aF;if not aF then unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;my()toggleView=false elseif mu=="option4"then cD()toggleView=false elseif mu=="option5"then local function mz()if LockPitch==nil then LockPitch=bQ;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else LockPitch=nil end end;mz()toggleView=false elseif mu=="option6"then cp()toggleView=false elseif mu=="option7"then toggleView=false elseif mu=="option8"then cq()toggleView=false elseif mu=="option9"then if gyro~=nil then gyro.toggle()ax=gyro.getState()==1 end;toggleView=false elseif mu=="lshift"then if x()==1 then Z=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then Z=true;bf=false;be=false end elseif mu=="brake"then if BrakeToggleStatus then cL()elseif not BrakeIsOn then cL()else BrakeIsOn=true end elseif mu=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif mu=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a5 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a5=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a5=false end elseif mu=="stopengines"then local function mA()if aq then aq=false;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Y=false;N=false;am=false;an=false;P=false;bg=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false else aq=true end end;s:resetCommand(axisCommandId.longitudinal)mA()G=0 elseif mu=="speedup"then mx()elseif mu=="speeddown"then mx(true)elseif mu=="antigravity"and not ExternalAGG then if antigrav~=nil then c_()end end end;function script.onActionStop(mu)local function mB()if not ExternalAGG and bN then a4=a2 end;if AltitudeHold or VertTakeOff or IntoOrbit then a3=a1 end end;if mu=="forward"then R=0 elseif mu=="backward"then R=0 elseif mu=="left"then U=0 elseif mu=="right"then U=0 elseif mu=="yawright"then V=0 elseif mu=="yawleft"then V=0 elseif mu=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif mu=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif mu=="up"then ae=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mu=="down"then ae=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mu=="groundaltitudeup"then mB()toggleView=false elseif mu=="groundaltitudedown"then mB()toggleView=false elseif mu=="lshift"then if x()==1 then Z=false;af=0;ag=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then Z=false;bf=false;be=false end elseif mu=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cL()else BrakeIsOn=false end end elseif mu=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(mu)local B=1;local function mC(mw)if mw then B=-1 end;if not ExternalAGG and bN then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a4=a4*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bw=bw+B*a3;if bw<planet.noAtmosphericDensityAltitude then bw=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a3 end;a3=a3*1.05 else s:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function mD(mw)if mw then B=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then G=r(G+B*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if mu=="groundaltitudeup"then mC()elseif mu=="groundaltitudedown"then mC(true)elseif mu=="speedup"then mD()elseif mu=="speeddown"then mD(true)end end;function script.onInputText(c8)local function mE()for d9,da in pairs(bZ())do dbHud_1.setStringValue(da,g(nil))end;for d9,da in pairs(b)do if da~="SavedLocations"then dbHud_1.setStringValue(da,g(nil))end end;a0="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ah=5;aL=false;ad=true end;local function mF(mG,planet,f0)local function mH(f0)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dq='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dD,dE,cz,cA,cy=o(f0,dq)if dD=="0"and dE=="0"then return vec3(tonumber(cz),tonumber(cA),tonumber(cy))end;cA=math.rad(cA)cz=math.rad(cz)local planet=b2[tonumber(dD)][tonumber(dE)]local er=math.cos(cz)local mI=vec3(er*math.cos(cA),er*math.sin(cA),math.sin(cz))return planet.center+(planet.radius+cy)*mI end;if dbHud_1 then local cJ={}local position=mH(f0)if planet.name=="Space"then cJ={position=position,name=mG,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cJ={position=position,name=mG,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;SavedLocations[#SavedLocations+1]=cJ;table.insert(b2[0],cJ)bc.UpdateAtlasLocationsList()else a0="Databank must be installed to save locations"end end;local i;local mJ="/commands /setname /G /agg /addlocation /copydatabank /wipedatabank"local mK,mL=nil,nil;local mM="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all updatable variables with /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572} - adds a saved location by waypoint, not as accurate as making one at location\n".."/copydatabank - copies dbHud databank to a blank databank\n/wipedatabank - wipes the databank of all hud variables but not save variables"i=string.find(c8," ")mK=c8;if i~=nil then mK=string.sub(c8,0,i-1)mL=string.sub(c8,i+1)end;if mK=="/help"or mK=="/commands"then for i7 in string.gmatch(mM,"([^\n]+)")do system.print(i7)end;return elseif mK=="/setname"then if mL==nil or mL==""then a0="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cG(mL)else a0="Select a saved target to rename first"end elseif mK=="/addlocation"then if mL==nil or mL==""or string.find(mL,"::")==nil then a0="Usage: ah-addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572}"return end;i=string.find(mL,"::")local mG=string.sub(mL,1,i-2)local f0=string.sub(mL,i)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dq='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dD,dE,cz,cA,cy=o(f0,dq)local planet=b2[tonumber(dD)][tonumber(dE)]mF(mG,planet,f0)a0="Added "..mG.." to saved locations,\nplanet "..planet.name.." at "..f0;ah=5 elseif mK=="/agg"then if mL==nil or mL==""then a0="Usage: ah-agg targetheight"return end;mL=tonumber(mL)if mL<1000 then mL=1000 end;AntigravTargetAltitude=mL;a0="AGG Target Height set to "..mL elseif mK=="/G"then if mL==nil or mL==""then a0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if mL=="dump"then for d9,da in pairs(bZ())do if type(_G[da])=="boolean"then if _G[da]==true then system.print(da.." true")else system.print(da.." false")end elseif _G[da]==nil then system.print(da.." nil")else system.print(da.." ".._G[da])end end;return end;i=string.find(mL," ")local mN=string.sub(mL,0,i-1)local mO=string.sub(mL,i+1)for d9,da in pairs(bZ())do if da==mN then a0="Variable "..mN.." changed to "..mO;local mP=type(_G[da])if mP=="number"then mO=tonumber(mO)elseif mP=="boolean"then if string.lower(mO)=="true"then mO=true else mO=false end end;_G[da]=mO;return end end;a0="No such global variable: "..mN elseif mK=="/copydatabank"then if dbHud_2 then d5(true)else a0="Spare Databank required to copy databank"end elseif mK=="/wipedatabank"then if dbHud_1 then mE()else a0="No databank found."end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
