name: ArchHud - Archaegeo v1.5201 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 0 --export:
        OrbitMapY = 25 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5201;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=""local aC=true;local aD=ResolutionX;local aE=ResolutionY;local aF={}local aG={}local aH={}local aI=0;local aJ=false;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=false;local aU=false;local aV=autoRollPreference;local aW=LandingGearGroundHeight;local aX=false;local aY=0;local aZ=AtmoSpeedLimit;local a_=0;local b0=nil;local b1={VectorToTarget=false}local b2=0;local b3=false;local b4=false;local b5=false;local b6=false;local b7=vec3(core.getConstructWorldOrientationUp())local b8=vec3(core.getConstructWorldOrientationForward())local b9=vec3(core.getConstructWorldOrientationRight())local ba=vec3(core.getVelocity())local bb=vec3(core.getWorldVelocity())local bc=vec3(bb):len()local bd=vec3(core.getWorldVertical())local be=-bd:dot(bb)local bf=vec3(core.getConstructWorldPos())local bg=false;local bh=false;local bi=nil;local bj=true;local bk=0;local bl=0;local bm={}local bn=false;local bo=50000;local bp=nil;local bq={}local br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bs=false;local bt=nil;local bu={}local bv="Atmo"local bw=false;local bx=0;local by={}local bz=nil;local bA=nil;local bB={}local bC=90;local bD=showHud;function p(bE)system.print(E..": "..bE)end;local function bF(bG)local D=1;if bG then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bH=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bH<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then aZ=r(aZ+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bx=bx+1*D*-1;if bx>#bm then bx=1 end;if bx<1 then bx=#bm end else if not bG then D=1 else D=nil end;aQ.adjustAutopilotTargetIndex(D)end end end;local function bI(bJ,bK,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)end end;local function bL(bM,bN)for i=1,#bN do bM[#bM+1]=bN[i]end;return bM end;local function bO(bP)local bQ={}local bR={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local bS={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bT={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bU={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bP then bL(bQ,bR)bL(bQ,bS)bL(bQ,bT)bL(bQ,bU)return bQ elseif bP=="boolean"then return bR elseif bP=="handling"then return bS elseif bP=="hud"then return bT elseif bP=="physics"then return bU end end;local function bV(bW,bX,bY,bZ,b_)if bZ==nil then bZ=""end;if b_==nil then b_=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bZ,bW,bX,b_,bY)end;local function c0(c1,c2)if c1==0 then return d(c2)<1e-09 end;if c2==0 then return d(c1)<1e-09 end;return d(c1-c2)<math.max(d(c1),d(c2))*epsilon end;local function c3(aj,c4)local c5=aj>100000;if c4==nil then c4=1 end;if c5 then return A(aj/1000/200,c4).."SU"elseif aj<1000 then return A(aj,c4).."M"else return A(aj/1000,c4).."KM"end end;local function c6(c7)local c8=0;local c9=0;local ca=0;if c7<60 then c7=e(c7)elseif c7<3600 then c8=e(c7/60)c7=e(c7%60)elseif c7<86400 then c9=e(c7/3600)c8=e(c7%3600/60)else ca=e(c7/86400)c9=e(c7%86400/3600)end;if ca>0 then return ca.."d "..c9 .."h "elseif c9>0 then return c9 .."h "..c8 .."m "elseif c8>0 then return c8 .."m "..c7 .."s"elseif c7>0 then return c7 .."s"else return"0s"end end;local function cb(cc)local function cd(ce)for cf,cg in pairs(ce)do dbHud_1.setStringValue(cg,h(_G[cg]))if cc and dbHud_2 then dbHud_2.setStringValue(cg,h(_G[cg]))end end end;if dbHud_1 then cd(c)cd(bO())system.print("Saved Variables to Datacore")if cc and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function ch()local function ci(cj)return type(cj)=='number'end;local function ck(cj)return type(z(cj))=='number'end;local function cl(cm)return type(cm)=='table'end;local function cn(co)return type(co)=='string'end;local function cp(cg)return cl(cg)and ci(cg.x and cg.y and cg.z)end;local function cq(cr)return cl(cr)and ci(cr.latitude and cr.longitude and cr.altitude and cr.id and cr.systemId)end;local cs=math.pi/180;local ct=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cv(cj)local cw=string.gsub(string.reverse(f('%.4f',cj)),'^0*%.?','')return cw==''and'0'or string.reverse(cw)end;local function cx(cy)if cp(cy)then return f('{x=%.3f,y=%.3f,z=%.3f}',cy.x,cy.y,cy.z)end;if cl(cy)and not getmetatable(cy)then local cz={}local cA=next(cy)if type(cA)=='nil'or cA==1 then cz=cy else for cf,cg in pairs(cy)do local cB=cx(cg)if type(cf)=='number'then table.insert(cz,f('[%s]=%s',cf,cB))else table.insert(cz,f('%s=%s',cf,cB))end end end;return f('{%s}',table.concat(cz,','))end;if cn(cy)then return f("'%s'",cy:gsub("'",[[\']]))end;return tostring(cy)end;local cC={}cC.__index=cC;cC.__tostring=function(cy,cD)local cE={}for cf in pairs(cy)do table.insert(cE,cf)end;table.sort(cE)local cz={}for _,cf in ipairs(cE)do local cB=cx(cy[cf])if type(cf)=='number'then table.insert(cz,f('[%s]=%s',cf,cB))else table.insert(cz,f('%s=%s',cf,cB))end end;if cD then return f('%s%s',cD,table.concat(cz,',\n'..cD))end;return f('{%s}',table.concat(cz,','))end;cC.__eq=function(cF,cG)return cF.systemId==cG.systemId and cF.id==cG.id and c0(cF.radius,cG.radius)and c0(cF.center.x,cG.center.x)and c0(cF.center.y,cG.center.y)and c0(cF.center.z,cG.center.z)and c0(cF.GM,cG.GM)end;local function cH(cI,cJ,cK,cL,cM)assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(cK),'Argument 3 (radius) must be a number:'..type(cK))assert(cl(cL),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cL))assert(ck(cM),'Argument 5 (GM) must be a number:'..type(cM))return setmetatable({systemId=z(cI),id=z(cJ),radius=z(cK),center=vec3(cL),GM=z(cM)},cC)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cv(p.latitude*ct),cv(p.longitude*ct),cv(p.altitude))end;MapPosition.__eq=function(cF,cG)return cF.id==cG.id and cF.systemId==cG.systemId and c0(cF.latitude,cG.latitude)and c0(cF.altitude,cG.altitude)and(c0(cF.longitude,cG.longitude)or c0(cF.latitude,math.pi/2)or c0(cF.latitude,-math.pi/2))end;local function cN(cO,cJ,cP,cQ,cR)local cI=cO;if cn(cO)and not cQ and not cR and not cJ and not cP then cI,cJ,cP,cQ,cR=o(cO,cu)assert(cI,'Argument 1 (position string) is malformed.')else assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(cP),'Argument 3 (latitude) must be in degrees:'..type(cP))assert(ck(cQ),'Argument 4 (longitude) must be in degrees:'..type(cQ))assert(ck(cR),'Argument 5 (altitude) must be in meters:'..type(cR))end;cI=z(cI)cJ=z(cJ)cP=z(cP)cQ=z(cQ)cR=z(cR)if cJ==0 then return setmetatable({latitude=cP,longitude=cQ,altitude=cR,id=cJ,systemId=cI},MapPosition)end;return setmetatable({latitude=cs*r(cP,-90,90),longitude=cs*(cQ%360),altitude=cR,id=cJ,systemId=cI},MapPosition)end;local cS={}cS.__index=cS;cS.__tostring=function(cy,cD)local cT=cD and cD..'  'local cU={}local cE={}for cf in pairs(cy)do table.insert(cE,cf)end;table.sort(cE)for _,cV in ipairs(cE)do bdy=cy[cV]local cW=cC.__tostring(bdy,cT)if cD then table.insert(cU,f('[%s]={\n%s\n%s}',cV,cW,cD))else table.insert(cU,f('  [%s]=%s',cV,cW))end end;if cD then return f('\n%s%s%s',cD,table.concat(cU,',\n'..cD),cD)end;return f('{\n%s\n}',table.concat(cU,',\n'))end;local function cX(cY)local b={}local pid;for _,cg in pairs(cY)do local cJ=cg.planetarySystemId;if type(cJ)~='number'then error('Invalid planetary system ID: '..tostring(cJ))elseif pid and cJ~=pid then error('Mistringmatch planetary system IDs: '..cJ..' and '..pid)end;local cZ=cg.bodyId;if type(cZ)~='number'then error('Invalid body ID: '..tostring(cZ))elseif b[cZ]then error('Duplicate body ID: '..tostring(cZ))end;setmetatable(cg.center,getmetatable(vec3.unit_x))b[cZ]=setmetatable(cg,cC)pid=cJ end;return setmetatable(b,cS)end;aK={}local function c_(cY)return setmetatable({galaxyAtlas=cY or{}},aK)end;aK.__index=function(cm,i)if type(i)=='number'then local system=cm.galaxyAtlas[i]return cX(system)end;return rawget(aK,i)end;aK.__pairs=function(cy)return function(cm,cf)local d0,nv=next(cm,cf)return d0,nv and cX(nv)end,cy.galaxyAtlas,nil end;aK.__tostring=function(cy)local d1={}for _,d2 in pairs(cy or{})do local d3=d2:getPlanetarySystemId()local d4=cS.__tostring(d2,'    ')table.insert(d1,f('  [%s]={%s\n  }',d3,d4))end;return f('{\n%s\n}\n',table.concat(d1,',\n'))end;aK.BodyParameters=cH;aK.MapPosition=cN;aK.PlanetarySystem=cX;function aK.createBodyParameters(cI,cJ,d5,d6,d7,d8,d9)assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(d5),'Argument 3 (surfaceArea) must be a number:'..type(d5))assert(cl(d6),'Argument 4 (aPosition) must be an array or vec3:'..type(d6))assert(cl(d7),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(d7))assert(ck(d8),'Argument 6 (altitude) must be in meters:'..type(d8))assert(ck(d9),'Argument 7 (gravityAtPosition) must be number:'..type(d9))local cK=y(d5/4/math.pi)local aj=cK+d8;local da=vec3(d6)+aj*vec3(d7)local cM=d9*aj*aj;return cH(cI,cJ,cK,da,cM)end;aK.isMapPosition=cq;function aK:getPlanetarySystem(cO)if i==nil then i=0 end;if nv==nil then nv=0 end;local cI=cO;if cq(cO)then cI=cO.systemId end;if type(cI)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=cS then system=cX(system)end;return system end end end;function cS:sizeCalculator(db)return 1.05*db.radius end;function cS:castIntersections(dc,dd,de,df,dg,dh)local di={}local dj=dg or self;for _,db in pairs(dj)do table.insert(di,db)end;if not dh then table.sort(di,function(dk,dl)return(dk.center-dc):len()<(dl.center-dc):len()end)end;local dm=dd:normalize()for _,db in ipairs(di)do local dn=db.center-dc;local cK=self:sizeCalculator(db)local dp=dn:dot(dm)local dq=dp^2-(dn:len2()-cK^2)if dq>=0 then local dr=y(dq)local ds=dp+dr;local dt=dp-dr;if dt>0 then return db,ds,dt elseif ds>0 then return db,ds,nil end end end;return nil,nil,nil end;function cS:closestBody(du)assert(type(du)=='table','Invalid coordinates.')local dv,db;local dw=vec3(du)for _,dx in pairs(self)do local dy=(dx.center-dw):len2()if(not db or dy<dv)and dx.name~="Space"then db=dx;dv=dy end end;return db end;function cS:convertToBodyIdAndWorldCoordinates(cO)local dz=cO;if cn(cO)then dz=cN(cO)end;if dz.id==0 then return 0,vec3(dz.latitude,dz.longitude,dz.altitude)end;local dx=self:getBodyParameters(dz)if dx then return dz.id,dx:convertToWorldCoordinates(dz)end end;function cS:getBodyParameters(cO)local cJ=cO;if cq(cO)then cJ=cO.id end;assert(ck(cJ),'Argument 1 (id) must be a number:'..type(cJ))return self[cJ]end;function cS:getPlanetarySystemId()local _,cg=next(self)return cg and cg.systemId end;function cC:convertToMapPosition(cL)assert(cl(cL),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cL))local dA=vec3(cL)if self.id==0 then return setmetatable({latitude=dA.x,longitude=dA.y,altitude=dA.z,id=0,systemId=self.systemId},MapPosition)end;local dB=dA-self.center;local aj=dB:len()local cR=aj-self.radius;local cP=0;local cQ=0;if not c0(aj,0)then local dC=n(dB.y,dB.x)cQ=dC>=0 and dC or 2*math.pi+dC;cP=math.pi/2-math.acos(dB.z/aj)end;return setmetatable({latitude=cP,longitude=cQ,altitude=cR,id=self.id,systemId=self.systemId},MapPosition)end;function cC:convertToWorldCoordinates(cO)local dz=cn(cO)and cN(cO)or cO;if dz.id==0 then return vec3(dz.latitude,dz.longitude,dz.altitude)end;assert(cq(dz),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dz.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dz.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dD=math.cos(dz.latitude)return self.center+(self.radius+dz.altitude)*vec3(dD*math.cos(dz.longitude),dD*math.sin(dz.longitude),math.sin(dz.latitude))end;function cC:getAltitude(cL)return(vec3(cL)-self.center):len()-self.radius end;function cC:getDistance(cL)return(vec3(cL)-self.center):len()end;function cC:getGravity(cL)local dE=self.center-vec3(cL)local dF=dE:len2()return self.GM/dF*dE/y(dF)end;return setmetatable(aK,{__call=function(_,...)return c_(...)end})end;local function dG()local aM={}local dH=30000000/3600;local dI=dH*dH;local dJ=100;function aM.computeAccelerationTime(dK,dL,dM)local dN=dH*math.asin(dK/dH)return(dH*math.asin(dM/dH)-dN)/dL end;function aM.computeDistanceAndTime(dK,dM,dO,dP,dQ,dR)dQ=dQ or 0;dR=dR or 0;local dS=dK<=dM;local dT=dP*(dS and 1 or-1)/dO;local dU=-dR/dO;local dV=dT+dU;if dS and dV<=0 or not dS and dV>=0 then return-1,-1 end;local dW,dX=0,0;if dT~=0 and dQ>0 then local dN=math.asin(dK/dH)local dY=math.pi*(dT/2+dU)local dZ=dT*dQ;local d_=dH*math.pi;local cg=function(cm)local e0=(dY*cm-dZ*math.sin(math.pi*cm/2/dQ)+d_*dN)/d_;local e1=math.tan(e0)return dH*e1/y(e1*e1+1)end;local e2=dS and function(co)return co>=dM end or function(co)return co<=dM end;dX=2*dQ;if e2(cg(dX))then local e3=0;while d(dX-e3)>0.5 do local cm=(dX+e3)/2;if e2(cg(cm))then dX=cm else e3=cm end end end;local e4=dK;local e5=dX/dJ;for e6=1,dJ do local e7=cg(e6*e5)dW=dW+(e7+e4)*e5/2;e4=e7 end;if dX<2*dQ then return dW,dX end;dK=e4 end;local dN=dH*math.asin(dK/dH)local E=(dH*math.asin(dM/dH)-dN)/dV;local e8=dI*math.cos(dN/dH)/dV;local aj=e8-dI*math.cos((dV*E+dN)/dH)/dV;return aj+dW,E+dX end;function aM.computeTravelTime(dK,dL,aj)if aj==0 then return 0 end;if dL>0 then local dN=dH*math.asin(dK/dH)local e8=dI*math.cos(dN/dH)/dL;return(dH*math.acos(dL*(e8-aj)/dI)-dN)/dL end;if dK==0 then return-1 end;assert(dK>0,'Acceleration and initial speed are both zero.')return aj/dK end;return aM end;local function e9()local vec3=require('cpml.vec3')local ch=ch()local function cn(co)return type(co)=='string'end;local function cl(cm)return type(cm)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cR)assert(self.body)local aj=cR+self.body.radius;if not c0(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cO,ea)assert(self.body)assert(cl(cO)or cn(cO))assert(cl(ea))local eb=(cn(cO)or ch.isMapPosition(cO))and self.body:convertToWorldCoordinates(cO)or vec3(cO)local cg=vec3(ea)local ec=eb-self.body.center;local ed=cg:len2()local ee=ec:len()local ef=self.body.GM;local eg=((ed-ef/ee)*ec-ec:dot(cg)*cg)/ef;local c1=ef/(2*ef/ee-ed)local eh=eg:len()local dm=eg:normalize()local ei=c1*(1-eh)local ej=c1*(1+eh)local ek=ei*dm+self.body.center;local el=eh<=1 and-ej*dm+self.body.center or nil;local em=y(c1*ef*(1-eh*eh))local en=el and 2*math.pi*y(c1^3/ef)local eo=math.acos(eg:dot(ec)/(eh*ee))if ec:dot(cg)<0 then eo=-(eo-2*math.pi)end;local ep=math.acos((math.cos(eo)+eh)/(1+eh*math.cos(eo)))local eq=ep;if eq<0 then eq=eq+2*math.pi end;local er=eq-eh*math.sin(eq)local es=0;local et=0;local eu=0;if en~=nil then es=er/(2*math.pi/en)et=en-es;eu=et+en/2;if eo-math.pi>0 then et=es;eu=et+en/2 end;if eu>en then eu=eu-en end end;return{periapsis={position=ek,speed=em/ei,circularOrbitSpeed=y(ef/ei),altitude=ei-self.body.radius},apoapsis=el and{position=el,speed=em/ej,circularOrbitSpeed=y(ef/ej),altitude=ej-self.body.radius},currentVelocity=cg,currentPosition=eb,eccentricity=eh,period=en,eccentricAnomaly=ep,meanAnomaly=er,timeToPeriapsis=et,timeToApoapsis=eu,trueAnomaly=eo}end;local function ev(ew)local dx=ch.BodyParameters(ew.systemId,ew.id,ew.radius,ew.center,ew.GM)return setmetatable({body=dx},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return ev(...)end})end;local function ex()local ey={}local ez={}local eA={XS=13,S=27,M=55,L=110,XL=221}local eB={}local eC;local eD;local eE;local eF;local eG;local function eH()local function eI(eJ,eK,eL,eM,eN,eO,eP,eQ)eK,eM,eO,eQ=vec3(eK),vec3(eM),vec3(eO),vec3(eQ)local eR,eS,eT=eJ*eJ,eL*eL,eN*eN;local ed=eM-eK;local eU=ed:normalize()local eV=ed:len()local eW=eO-eK;local eX=(eW-eW:project_on(eU)):normalize()local eY,eZ=eW:dot(eU),eW:dot(eX)local e_=eY*eY+eZ*eZ;local f0=eU:cross(eX)local bW=(eR-eS+eV*eV)/(2*eV)local bX=(eR-eT+e_-2*eY*bW)/(2*eZ)local cr=eR-bW^2-bX^2;local f1=y(cr)local f2=eK+eU*bW+eX*bX+f0*f1;local f3=eK+eU*bW+eX*bX-f0*f1;if d((eQ-f2):len()-eP)<d((eQ-f3):len()-eP)then return f2 else return f3 end end;local function f4()local function f5()local f6=core.getConstructWorldOrientationRight()local ed=core.getConstructWorldOrientationForward()local eW=core.getConstructWorldOrientationUp()local f7=library.systemResolution3(f6,ed,eW,{1,0,0})local f8=library.systemResolution3(f6,ed,eW,{0,1,0})local f9=library.systemResolution3(f6,ed,eW,{0,0,1})return function(fa)return library.systemResolution3(f7,f8,f9,fa)end end;local fb=f5()local fc=core.getConstructWorldPos()local eb=core.getElementPositionById(1)local fd={eb[1],eb[2],eb[3]}local fe=fb(fd)local ff={fc[1]-fe[1],fc[2]-fe[2],fc[3]-fe[3]}return ff end;local function fg(fh,ee,fi)local fj=fh.pts;local fk=#fj;local fl=fh.ref;if fk>3 then local fm,fn,fo,fp=fj[fk],fj[fk-1],fj[fk-2],fj[fk-3]fh.ref=fi;local eb=eI(fm[1],fm[2],fn[1],fn[2],fo[1],fo[2],fp[1],fp[2])local bW,bX,f1=eb.x,eb.y,eb.z;if bW==bW and bX==bX and f1==f1 then bW=bW+fl[1]bX=bX+fl[2]f1=f1+fl[3]local fq=vec3(bW,bX,f1)if not fh.lastPos then fh.center=fq elseif(fh.lastPos-fq):len()<2 then fh.center=fq;fh.skipCalc=true end;fh.lastPos=fq end;fh.pts={}else local fr={fi[1]-fl[1],fi[2]-fl[2],fi[3]-fl[3]}fj[fk+1]={ee,fr}end end;if bu[1]then eC=#bu[1].getConstructIds()local fs=bu[1].getData()local ft=fs:gmatch('{"constructId[^}]*}[^}]*}')if eC>0 then local fi=f4()local fu,fv=0,0;eG,eF=0,0;for cg in ft do local cJ,aj,fw=cg:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fx=eA[fw]aj=z(aj)if bu[1].hasMatchingTransponder(cJ)==1 then table.insert(ez,cJ)end;local fy=bu[1].getConstructType(cJ)if CollisionSystem then if fx>27 or fy=="static"or fy=="space"then eG=eG+1;local fz=bu[1].getConstructName(cJ)local fh=bq[cJ]if fh==nil then fx=fx+G;bq[cJ]={pts={},ref=fi,name=fz,i=0,radius=fx,skipCalc=false}fh=bq[cJ]end;if not fh.skipCalc then fg(fh,aj,fi)fv=fv+1 end;if fh.center then table.insert(eB,fh)end end;fu=fu+1;if br and fu>700 or fv>70 or(not br and fu>300 or fv>30)then coroutine.yield()fu,fv=0,0 end end end;eF=#eB;if eF>0 and bc>20 then local db,fA,fB,fC;local fD=0;local fE=aL:getPlanetarySystem(0)fC=bb:normalize()while fD<eF do coroutine.yield()local fF={table.unpack(eB,fD,math.min(fD+75,eF))}db,fA,fB=fE:castIntersections(bf,fC,nil,nil,fF,true)if db and fB then bt={db,fA,fB}break end;fD=fD+75 end;if not db then bt=nil end else bt=nil end;eB={}eD=fs:find('identifiedConstructs":%[%]')else eE=fs:find('worksInEnvironment":false')end end end;local function fG()if bu[1]then bv="Atmo"if bu[1].getData():find('worksInAtmosphere":false')then bv="Space"end end end;function ey.pickType()fG()end;function ey.assignRadar()if radar_1 and bu[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bu[1]=radar_2 end;if bu[1]==radar_2 then fG()end elseif radar_2 and bu[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bu[1]=radar_1 end;if bu[1]==radar_1 then fG()end end end;function ey.UpdateRadar()local fH=coroutine.status(UpdateRadarCoroutine)if fH=="suspended"then local cB,fI=coroutine.resume(UpdateRadarCoroutine)if fI then system.print("ERROR UPDATE RADAR: "..fI)end elseif fH=="dead"then UpdateRadarCoroutine=coroutine.create(eH)local cB,fI=coroutine.resume(UpdateRadarCoroutine)end end;function ey.GetRadarHud()local fJ=ez;ez={}return eD,eE,eC,eF,eG,fJ end;UpdateRadarCoroutine=coroutine.create(eH)return ey end;local function fK()local fL=9.80665;local fM={}local fN={}local fO={}local by={}local fP=nil;local fQ=nil;local fR=nil;local fS=false;local fT={}local fU=""local fV=vec3({13771471,7435803,-128971})local fW=18000000;local fX=500000;local fY,fZ=math.huge;local f_;local function g0(g1)fY=vec3(g1):dist(fV)if fY<fW then return true,d(fY-fW)end;fZ=vec3(g1):dist(vec3(planet.center))if fZ<fX then f_=true else f_=false end;if d(fZ-fX)<d(fY-fW)then return f_,d(fZ-fX)else return f_,d(fY-fW)end end;local function g2(cg)if aD==1920 then return cg else return A(aD*cg/1920,0)end end;local function g3(cg)if aE==1080 then return cg else return A(aE*cg/1080,0)end end;local function g4()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function g5()local g6="TRAVEL"if not bj then g6="CRUISE"end;if Autopilot then g6="AUTOPILOT"end;return g6 end;local g7={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local g8=""local g9=""local ga=""local gb=1;local gc=2;local gd=3;local ge=4;local gf=5;local gg=6;local gh=""local gi=0;local gj=e(1/apTickRate)*2*hudTickRate;local gk={}local gl={}local gm={}local gn={}local go={}local gp={}local function gq(bW,gr,gs,gt,gu,gv)local gw=tankY;local gx=tankY+5;if not BarFuelDisplay then gx=gx+5 end;if m()==1 and not RemoteHud then gw=gw-50;gx=gx-50 end;if gs=="ATMO"then gh="atmofueltank"elseif gs=="SPACE"then gh="spacefueltank"else gh="rocketfueltank"end;gi=_G[gh.."_size"]if#gt>0 then for i=1,#gt do local fz=string.sub(gt[i][gc],1,12)local gy=0;for gz=1,gi do if gt[i][gc]==g(unit[gh.."_"..gz].getData()).name then gy=gz;break end end;local gA=q()if gu[i]==nil or gv[i]==nil or gA-gt[i][gg]>gj then local gB;local gC=0;if gy~=0 then gv[i]=g(unit[gh.."_"..gy].getData()).percentage;gu[i]=g(unit[gh.."_"..gy].getData()).timeLeft;if gu[i]=="n/a"then gu[i]=0 end else gC=l(gt[i][gb])-gt[i][ge]gv[i]=e(0.5+gC*100/gt[i][gd])gB=gt[i][gf]if gB<=gC then gu[i]=0 else gu[i]=e(0.5+gC/((gB-gC)/(gA-gt[i][gg])))end;gt[i][gf]=gC;gt[i][gg]=gA end end;if fz==gr then fz=f("%s %d",gs,i)end;if gy==0 then fz=fz.." *"end;local gD;if gu[i]==0 then gD=""else gD=c6(gu[i])end;if gv[i]~=nil then local gE=e(gv[i]*2.55)local gF=f("rgb(%d,%d,%d)",255-gE,gE,0)local bZ=""if gD~=""and gu[i]<120 or gv[i]<5 then bZ="red "end;local gG=f("rgb(%d,%d,%d)",r(e((255-gE)/2.55),50,100),r(e(gE/2.55),0,50),50)local gH="rgb(196,0,255)"if gs=="ATMO"then gH="rgb(0,188,255)"elseif gs=="SPACE"then gH="rgb(239,255,0)"end;local gI=false;if previous~=gH then gI=true end;previous=gH;if BarFuelDisplay then if gI then gw=gw-5;gx=gx-5 end;g9=g9 ..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gG,gH,bW,gx,gF,e(gv[i]*1.7+0.5)-2,bW+1,gx+1,bW+5,gx+14,fz,gv[i],gD)gw=gw-22;gx=gx-22 else g9=g9 ..bV(bW,gw,fz,bZ.."pdim txtfuel")g9=g9 ..bV(bW,gx,f("%d%% %s",gv[i],gD),"pdim txtfuel","fill:"..gF)gw=gw+30;gx=gx+30 end end end end;tankY=gw end;local function gJ(gK,cR)if cR<200000 and not aq or cR and aq then local gL=0;if d(be)>1 then gL=45*math.log(d(be),10)if be<0 then gL=-gL end end;gK[#gK+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(be),e(gL))end;return gK end;local function gM(gN)local gO=-bd;gN=gN-gN:project_on(gO)local gP=vec3(0,0,1)gP=gP-gP:project_on(gO)local gQ=gP:cross(gO)local gL=gP:angle_between(gN)*constants.rad2deg;if gN:dot(gQ)<0 then gL=360-gL end;return gL end;local function gR(gK,centerX,centerY,gS,gT,br)local gU=circleRad;local gV=20;local gW=e(gS)if br then for i=-45,45,5 do local gX=i;gK[#gK+1]=f([[<g transform="rotate(%f,%d,%d)">]],gX,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gK[#gK+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gU+gV-len,centerX,centerY+gU+gV)end;gK[#gK+1]=bV(centerX,centerY+gU+gV-35,gT,"pdim txt txtmid")gK[#gK+1]=bV(centerX,centerY+gU+gV-25,gW.." deg","pdim txt txtmid")gK[#gK+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gS,centerX,centerY)gK[#gK+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gU+gV-20,centerX+5,centerY+gU+gV-20,centerX,centerY+gU+gV-15)gK[#gK+1]="</g>"end;gK[#gK+1]=[[<g style="clip-path: url(#headingClip);">]]local gY=gW;if br then gY=gM(b8)end;local gZ=20;local g_=e(gY)local h0=0;local h1=centerY+gU+gV+20;local h2=centerX;if gT~="YAW"then h1=g3(130)h2=g2(960)end;local h3=[[<path class="txttick line" d="]]local h4=e(g_-(gZ+10)-g_%5+0.5)for i=h4+70,h4,-5 do local bW=h2-(-i*5+gY*5)if i%10==0 then h0=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gK[#gK+1]=bV(bW,h1+15,B,"txtmid bright")elseif i%5==0 then h0=5 end;if h0==10 then h3=f([[%s M %f %f v %d]],h3,bW,h1-5,h0)else h3=f([[%s M %f %f v %d]],h3,bW,h1-2.5,h0)end end;gK[#gK+1]=h3 ..[["/>]]gK[#gK+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],h2-5,h1-20,h2+5,h1-20,h2,h1-10)if br then gT="HDG"end;gK[#gK+1]=bV(g2(960),g3(100),g_.."°","dim txt txtmid size14","")gK[#gK+1]=bV(g2(960),g3(85),gT,"dim txt txtmid size20","")gK[#gK+1]=[[</g>]]end;local function h5(gK,h6,gS,centerX,centerY,br,h7,e7)local gU=circleRad;local h8=e(gU*3/5)if gU>0 then local h9=e(h6)local len=0;local h3=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gS,centerX,centerY)if not aq then h3=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gK[#gK+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gU-1,centerX,centerY)gK[#gK+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(h9-30-h9%5+0.5),e(h9+30+h9%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bX=centerY+-i*5+h6*5;if len==30 then h3=f([[%s M %d %f h %d]],h3,centerX-h8-len,bX,len)if aq then gK[#gK+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gS,centerX,centerY,centerX-h8+10,bX+4,i)gK[#gK+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gS,centerX,centerY,centerX+h8-10,bX+4,i)if i==0 or i==180 or i==-180 then gK[#gK+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gS,centerX,centerY,centerX-h8+20,bX,h8*2-40)end else gK[#gK+1]=bV(centerX-h8+10,bX,i,"pdim txt txtmid")gK[#gK+1]=bV(centerX+h8-10,bX,i,"pdim txt txtmid")end;h3=f([[%s M %d %f h %d]],h3,centerX+h8,bX,len)else h3=f([[%s M %d %f h %d]],h3,centerX-h8-len,bX,len)h3=f([[%s M %d %f h %d]],h3,centerX+h8,bX,len)end end;gK[#gK+1]=h3 ..[["/>]]local ha="PITCH"if not br then ha="REL PITCH"end;if h6>90 and not aq then h6=90-(h6-90)elseif h6<-90 and not aq then h6=-90-(h6+90)end;if gU>200 then if aq then if e7>Q then gK[#gK+1]=bV(centerX,centerY-15,"Yaw","pdim txt txtmid")gK[#gK+1]=bV(centerX,centerY+20,h7,"pdim txt txtmid")end;gK[#gK+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gS,centerX,centerY)else gK[#gK+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gK[#gK+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-h8+25,centerY-5,centerX-h8+20,centerY,centerX-h8+25,centerY+5,centerX-h8+50,centerY+4,h9)gK[#gK+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+h8-25,centerY-5,centerX+h8-20,centerY,centerX+h8-25,centerY+5,centerX+h8-30,centerY+4,h9)gK[#gK+1]="</g>"end;local hb=e(gU/3)gK[#gK+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hb,centerY,gU-hb)if not aq and br then gK[#gK+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gS,centerX,centerY,centerX-h8+10,centerY,h8*2-20)end;gK[#gK+1]="</g>"if gU<200 then if aq and e7>Q then gK[#gK+1]=bV(centerX,centerY-gU,ha,"pdim txt txtmid")gK[#gK+1]=bV(centerX,centerY-gU+10,h9,"pdim txt txtmid")gK[#gK+1]=bV(centerX,centerY-15,"Yaw","pdim txt txtmid")gK[#gK+1]=bV(centerX,centerY+20,h7,"pdim txt txtmid")else gK[#gK+1]=bV(centerX,centerY-gU,ha,"pdim txt txtmid")gK[#gK+1]=bV(centerX,centerY-gU+15,h9,"pdim txt txtmid")end end end end;local function hc(gK,cR,br)local hd=altMeterX;local he=altMeterY;local hf=78;local hg=19;local hh=ao;if ao~=-1 then gK[#gK+1]=bV(hd+hf,he+hg+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if br and(cR<200000 and not aq or cR and aq)then table.insert(gK,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hd-1,he-4,hf+2,hg+6,hd+1,he-1,hf-4,hg))local fk=0;local hi=1;local hj=0;local hk=cR<0;local hl=cR<planet.surfaceMaxAltitude;local hm=9;if hk then hm=0 end;local cR=d(cR)while fk<6 do local hn=11;local ho=16;local hp=9;local hq=14;local bZ="altsm"if fk>2 then ho=ho+3;hn=hn+2;hq=hq+2;hp=hp-6;bZ="altbig"end;if hk then bZ=bZ.." red"elseif hl then bZ=bZ.." orange"end;local hr=cR/hi%10;local hs=e(hr)local ht=e((hs+1)%10)local hu=hj;if fk==0 then hu=hr-hs;if hk then hu=1-hu end end;if hk and(fk==0 or hj~=0)then local hv=ht;ht=hs;hs=hv end;local hw=ho*(hu-1)local hx=hw+ho;local bW=hd+hp+(6-fk)*hn;local bX=he+hq;gK[#gK+1]=bV(bW,bX+hw,ht,bZ)gK[#gK+1]=bV(bW,bX+hx,hs,bZ)fk=fk+1;hi=hi*10;if hs==hm then hj=hu else hj=0 end end;table.insert(gK,[[</g></g>]])end end;local function hy(ea)local hz=-math.deg(n(ea.y,ea.z))+180;hz=hz-90;if hz<0 then hz=360+hz end;if hz>180 then hz=-180+hz-180 end;return-hz end;local function hA(ea)local gY=math.deg(n(ea.y,ea.x))-90;if gY<-180 then gY=360+gY end;return gY end;local function hB(gK,ea,e7,centerX,centerY)if e7>5 and not aq or e7>Q then local gU=circleRad;local hC=20;local hD=20;local hE=hy(ea)local hF=hA(ea)local hG=14;local hH=hG/2;local hI=-hF/hD*gU;local hJ=hE/hC*gU;local bW=centerX+hI;local bX=centerY+hJ;local aj=y(hI^2+hJ^2)local hK=[[<circle
                            cx="]]..bW..[["
                            cy="]]..bX..[["
                            r="]]..hH/hG..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bW..[["
                            cy="]]..bX..[["
                            r="]]..hH..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bW-hG..[[,]]..bX..[[ h ]]..hH..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bW+hH..[[,]]..bX..[[ h ]]..hH..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bW..[[,]]..bX-hG..[[ v ]]..hH..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<gU then gK[#gK+1]=hK else local gL=n(hJ,hI)local hL=4;local hM=centerX+gU*math.cos(gL)local hN=centerY+gU*math.sin(gL)gK[#gK+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gL*180/math.pi,hM,hN,hM-hL,hN-hL/2,hL*2,hL,hM+hL,hN-hL,hL,hL,-hL,hL)end;if not aq then local hO=vec3(ea)hE=hy(-hO)hF=hA(-hO)hI=-hF/hD*gU;hJ=hE/hC*gU;bW=centerX+hI;bX=centerY+hJ;aj=y(hI^2+hJ^2)if aj<gU then local hP=[[<circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bW..[[,]]..bX-hG..[[ v ]]..hH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bW..[[,]]..bX..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bW..[[,]]..bX..[[)" />
                                <path
                                    d="M ]]..bW-hH..[[,]]..bX..[[ h ]]..hG..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bW..[[,]]..bX..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bW..[[,]]..bX..[[)"/>]]gK[#gK+1]=hP end end end end;local function hQ(gK,g6,hR,hS)hR=e(hR+0.5)local gw=throtPosY+10;local gx=throtPosY+20;if m()==1 and not RemoteHud then gw=55;gx=65 end;local hT="CRUISE"local unit="km/h"local cB=hS;if g6=="TRAVEL"or g6=="AUTOPILOT"then hT="THROT"unit="%"cB=hR;local hU="dim"if hR<0 then hU="red"end;gK[#gK+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hU,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(hR),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gK[#gK+1]=bV(throtPosX+10,gw,hT,"pbright txtstart")gK[#gK+1]=bV(throtPosX+10,gx,f("%.0f %s",cB,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bj and M then hR=e(N*100+0.5)local hU="red"if hR<0 then hU="red"end;gK[#gK+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hU,1-d(hR),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gK[#gK+1]=bV(throtPosX+10,gw+40,"LIMIT","pbright txtstart")gK[#gK+1]=bV(throtPosX+10,gx+40,hR.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gK[#gK+1]=bV(throtPosX+10,gw-40,"LIMIT: "..aZ.." km/h","dim txtstart")elseif not aq and Autopilot then gK[#gK+1]=bV(throtPosX+10,gw-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hV(gK,hW)local hX=throtPosY-10;local hY=throtPosX+10;gK[#gK+1]=bV(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then hX=75 end;gK[#gK+1]=bV(hY,hX,e(hW).." km/h","pbright txtbig txtstart")end;local function hZ(gK)gK[#gK+1]=bV(g2(1900),g3(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gK[#gK+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gK[#gK+1]=bV(g2(960),g3(550),"Warning: Invalid Control Scheme Detected","warnings")gK[#gK+1]=bV(g2(960),g3(600),"Keyboard Scheme must be selected","warnings")gK[#gK+1]=bV(g2(960),g3(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local h_=g2(960)local i0=g3(860)local i1=g3(880)local i2=g3(900)local i3=g3(960)local i4=g3(200)local i5=g3(250)local i6=g3(960)if m()==1 and not RemoteHud then i0=g3(135)i1=g3(155)i2=g3(175)i4=g3(115)i5=g3(95)end;local i7="#222222"local i8="white"local i9="dimmer"local ia="pbright"local ib="#110000"local ic=i7;local id=i9;if BrakeIsOn then gK[#gK+1]=bV(h_,i0,"Brake Engaged","warnings")ib="#440000"ic=i8;id=ia elseif L>0 then gK[#gK+1]=bV(h_,i0,"Auto-Brake Engaged","warnings","opacity:"..L)end;local ie="#110000"local ig=i7;local ih=i9;if aq and aX and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bh and not VertTakeOff and not AutoTakeoff then gK[#gK+1]=bV(h_,i4+50,"** STALL WARNING **","warnings")ie="#ff0000"ig=i8;ih=ia;bI("stall","SW",2)end end;if bp then gK[#gK+1]=bV(h_,i4+90,"Flight Assist in Progress","warnings")end;if ax then gK[#gK+1]=bV(h_,i6,"Gyro Enabled","warnings")end;local ii="#111100"local ij=i7;local ik=i9;if GearExtended then ii="#775500"ij=i8;ik=ia;if S then gK[#gK+1]=bV(h_,i1,"Gear Extended","warn")else gK[#gK+1]=bV(h_,i1,"Landed (G: Takeoff)","warnings")end;local il=c3(a:getTargetGroundAltitude())gK[#gK+1]=bV(h_,i2,"Hover Height: "..il,"warn")end;local im="#000011"local io=i7;local ip=i9;if a7 then im="#0000DD"io=i8;ip=ia;gK[#gK+1]=bV(h_,i3+20,"ROCKET BOOST ENABLED","warn")end;local iq="#001100"local ir=i7;local is=i9;if antigrav and not ExternalAGG and bh and AntigravTargetAltitude~=nil then iq="#00DD00"ir=i8;is=ia;if d(as-antigrav.getBaseAltitude())<501 then gK[#gK+1]=bV(h_,i4+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gK[#gK+1]=bV(h_,i4+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gK[#gK+1]=bV(h_,i4+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gK[#gK+1]=bV(h_,i4+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gK[#gK+1]=bV(h_,i4+20,"Follow Mode Engaged","warn")elseif Reentry or an then gK[#gK+1]=bV(h_,i4+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local il=c3(HoldAltitude,2)if VertTakeOff then if bh then il=c3(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gK[#gK+1]=bV(h_,i4,"VTO to "..il,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gK[#gK+1]=bV(h_,i4,"Takeoff to "..AutopilotTargetName,"warn")else gK[#gK+1]=bV(h_,i4,"Takeoff to "..il,"warn")end;if BrakeIsOn and not VertTakeOff then gK[#gK+1]=bV(h_,i4+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gK[#gK+1]=bV(h_,i4,"Altitude Hold: "..il,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gK[#gK+1]=bV(h_,i4+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gK[#gK+1]=bV(h_,i4+20,"Aligning trajectory","warn")elseif ar<0.05 then gK[#gK+1]=bV(h_,i4+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b0~=nil then gK[#gK+1]=bV(h_,i4,b0,"warn")end end;if BrakeLanding then if StrongBrakes then gK[#gK+1]=bV(h_,i4,"Brake-Landing","warnings")else gK[#gK+1]=bV(h_,i4,"Coast-Landing","warnings")end end;if ProgradeIsOn then gK[#gK+1]=bV(h_,i4,"Prograde Alignment","crit")end;if RetrogradeIsOn then gK[#gK+1]=bV(h_,i4,"Retrograde Alignment","crit")end;local it="#110000"local iu=i7;local iv=i9;if bs then it="#FF0000"iu=i8;iv=ia;local type;if string.find(bs,"COLLISION")then type="warnings"else type="crit"end;gK[#gK+1]=bV(h_,i5+20,bs,type)elseif ar==0 then local iw,ix=aR.checkLOS(bb:normalize())if ix~=nil then iv=ia;it="#FF0000"iu=i8;local il=c3(ix)local travelTime=aM.computeTravelTime(bc,0,ix)local iy="Collision"if iw.noAtmosphericDensityAltitude>0 then iy="Atmosphere"end;gK[#gK+1]=bV(h_,i5+20,iw.name.." "..iy.." "..c6(travelTime).." In "..il,"crit")end end;if VectorToTarget and not IntoOrbit then gK[#gK+1]=bV(h_,i4+35,VectorStatus,"warn")end;local iz="#111100"local iA=i7;local iB=i9;if bz and#bz>1 then iz="#DDDD00"iA=i8;iB=ia end;local iC=g2;local iD=g3;local i9="topButton"local iE="topButtonActive"local iF=i9;if Autopilot or VectorToTarget or am or IntoOrbit then iF=iE end;local iG=i9;if ProgradeIsOn then iG=iE end;local iH=i9;if BrakeLanding or GearExtended then iH=iE end;local iI=i9;if AltitudeHold or VectorToTarget then iI=iE end;local iJ=i9;if RetrogradeIsOn then iJ=iE end;local iK=i9;if IntoOrbit or b3 and Autopilot then iK=iE end;local iL=iD(30)gK[#gK+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iF,iC(960),iD(54),iD(-53),iC(-120),iC(25),iD(50))gK[#gK+1]=bV(iC(910),iL,"AUTOPILOT")gK[#gK+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iG,iC(865),iD(51),iC(-25),iD(-50),iC(-110),iC(25),iD(46))gK[#gK+1]=bV(iC(800),iL,"PROGRADE")gK[#gK+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iH,iC(755),iD(47),iC(-25),iD(-46),iC(-98),iC(44),iD(44))gK[#gK+1]=bV(iC(700),iL,"LAND")gK[#gK+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iI,iC(960),iD(54),iD(-53),iC(120),iC(-25),iD(50))gK[#gK+1]=bV(iC(1010),iL,"ALT HOLD")gK[#gK+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iJ,iC(1055),iD(51),iC(25),iD(-50),iC(110),iC(-25),iD(46))gK[#gK+1]=bV(iC(1122),iL,"RETROGRADE")gK[#gK+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iK,iC(1165),iD(47),iC(25),iD(-46),iC(98),iC(-44),iD(44))gK[#gK+1]=bV(iC(1220),iL,"ORBIT")gK[#gK+1]=[[
                                </g>
                            </g>]]gK[#gK+1]="</g>"return gK end;local function iM(e7)return e(A(e7*3.6,0)+0.5).." km/h"end;local function iN(gK)local bW=OrbitMapX+10;local bX=OrbitMapY+20;local iO={}local iP={"Alt-4: AutoTakeoff to Target"}local iQ={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iR={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iS={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iO,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then bL(iO,iP)if ac and planet and ac.name==planet.name then table.insert(iO,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bh then table.insert(iO,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iO,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iO,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iO,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iO,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iO,"G: Takeoff to hover height, raise gear")else table.insert(iO,"G: Lowergear and Land")end else bL(iO,iQ)table.insert(iO,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iO,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bL(iO,iR)if shield_1 then table.insert(iO,"Alt-Shift-5: Toggle shield off and on")table.insert(iO,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iO,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iO,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iO,"Alt-Spacebar/C will raise/lower target height")table.insert(iO,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iO,"LALT+Mousewheel will lower/raise speed limit")end;bL(iO,iS)for i=1,#iO do bX=bX+12;gK[#gK+1]=bV(bW,bX,iO[i],"pdim txtbig txtstart")end end;local function iT(gK)local iU=OrbitMapX;local iV=OrbitMapY;local iW=OrbitMapSize;local iX=4;local iY=15;local bW=0;local bX=0;local iZ,i_,j0,j1;local j2;local function j3(type)local j4,E,e7,j5,bZ,j6;if type=="Periapsis"then j4=j2.periapsis.altitude;E=j2.timeToPeriapsis;e7=j2.periapsis.speed;bZ="txtend"j5=12;j6=math.min(bW,iU+iW-planet.radius/j0-iX*2)else j4=j2.apoapsis.altitude;E=j2.timeToApoapsis;e7=j2.apoapsis.speed;j5=-12;bZ="txtstart"j6=bW end;if bc<1 then E=0 end;gK[#gK+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j6+j5,bX-5,bW,bX-5)gK[#gK+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j6-j5*4,bX+2,bW,bX+2)gK[#gK+1]=bV(j6,bX,type,bZ)bW=j6-j5*2;bX=bX+iY;local il=c3(j4)gK[#gK+1]=bV(bW,bX,il,bZ)bX=bX+iY;gK[#gK+1]=bV(bW,bX,c6(E),bZ)bX=bX+iY;gK[#gK+1]=bV(bW,bX,iM(e7),bZ)end;local j7=iW*1.5;if SelectedTab=="INFO"then j7=25*7 end;if SelectedTab~="HIDE"then gK[#gK+1]=[[<g class="pbright txtorb txtmid">]]gK[#gK+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',iW*2,j7,iU,iV)gK[#gK+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],iW*2,j7,iU,iV)end;local j8=iW*1.5;local j9=iW*2;local ja=j8/2;local jb=iW;local jc=iU+jb;local jd=iV+ja;local je=iU+j9;local jf=iV+j8;if SelectedTab=="ORBIT"then iV=iV+iX;iZ=iW/2;j1=0;j2={}j2.periapsis={}j2.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then j2.periapsis.altitude=orbit.periapsis.altitude;j2.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then j2.apoapsis.altitude=orbit.apoapsis.altitude;j2.apoapsis.speed=orbit.apoapsis.speed end;j2.period=orbit.period;j2.eccentricity=orbit.eccentricity;j2.timeToApoapsis=orbit.timeToApoapsis;j2.timeToPeriapsis=orbit.timeToPeriapsis;j2.eccentricAnomaly=orbit.eccentricAnomaly;j2.trueAnomaly=orbit.trueAnomaly end;if j2.periapsis==nil then j2.periapsis={}j2.periapsis.altitude=-planet.radius;j2.periapsis.speed=MaxGameVelocity end;if j2.eccentricity==nil then j2.eccentricity=1 end;if j2.apoapsis==nil then j2.apoapsis={}j2.apoapsis.altitude=as;j2.apoapsis.speed=0 end;if bc<1 then j2.apoapsis.altitude=as;j2.apoapsis.speed=0 end;if j2.apoapsis.altitude then j0=(j2.apoapsis.altitude+j2.periapsis.altitude+planet.radius*2)/(iZ*2)i_=(planet.radius+j2.apoapsis.altitude)/j0*(1-j2.eccentricity)j1=iZ-j2.periapsis.altitude/j0-planet.radius/j0;local jg=math.pi;if j2.period~=nil and j2.period>0 and j2.timeToApoapsis~=nil then jg=j2.eccentricAnomaly;if j2.timeToPeriapsis<j2.timeToApoapsis then jg=2*math.pi-jg end end;if bc<1 or jg~=jg then jg=math.pi end;local jh=-iZ*math.cos(jg)+iU+jb+iX;local ji=i_*math.sin(jg)+iV+ja+iX;local jj=""gK[#gK+1]='<g clip-path="url(#orbitRect)">'gK[#gK+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jj,iU+iW+iX,iV+iW*1.5/2+iX,iZ,i_)if i_<1 then gK[#gK+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iU+iW+iX-j1,iV+iW*1.5/2+iX,jh,ji)end;gK[#gK+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iU+iW+iX-j1,iV+iW*1.5/2+iX,(planet.radius+planet.noAtmosphericDensityAltitude)/j0)gK[#gK+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iU+iW+iX-j1,iV+iW*1.5/2+iX,(planet.radius+planet.noAtmosphericDensityAltitude)/j0)gK[#gK+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iU+iW+iX,iV+iW*1.5/2+iX,iZ,i_)gK[#gK+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iU+iW+iX-j1,iV+iW*1.5/2+iX,planet.radius/j0)gK[#gK+1]='</g>'local jk=math.floor(planet.radius/j0+0.5)local jl=g7.Generic_Moon;if g7[planet.name]then jl=g7[planet.name]end;bW=iU+iW+iX*4+iZ;bX=iV+iW*1.5/2+5+iX;if j2.apoapsis~=nil and j2.apoapsis.speed<MaxGameVelocity then j3("Apoapsis")end;bX=iV+iW*1.5/2+5+iX;bW=iU+iW-iX*2-iZ;if j2.periapsis~=nil and j2.periapsis.speed<MaxGameVelocity and j2.periapsis.altitude>0 then j3("Periapsis")end;gK[#gK+1]=bV(iU+iW+iX,iV+20+iX,planet.name,"txtorbbig")gK[#gK+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jh,ji)gK[#gK+1]=[[</g>]]return gK else gK[#gK+1]='<g clip-path="url(#orbitRect)">'local jm=""local jn=1.2*(maxAtlasX-minAtlasX)/(iW*2)local jo=1.4*(maxAtlasY-minAtlasY)/(iW*1.5)for cf,cg in pairs(b[0])do if cg.center then local bW=iU+iW+cg.center.x/jn;local bX=iV+iW*1.5/2+cg.center.y/jo;jm=jm..'<circle cx="'..bW..'" cy="'..bX..'" r="'..cg.radius/jn*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(cg.name,"Moon")and not string.match(cg.name,"Sanctuary")and not string.match(cg.name,"Space")then jm=jm.."<text x='"..bW.."' y='"..bX+cg.radius/jn*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..cg.name.."</text>"end end end;local eb=vec3(core.getConstructWorldPos())local bW=iU+iW+eb.x/jn;local bX=iV+iW*1.5/2+eb.y/jo;jm=jm..'<circle cx="'..bW..'" cy="'..bX..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jm=jm.."<text x='"..bW.."' y='"..bX-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fP=jn;fQ=jo;local jp=eb+bb*1000000;local jq=iU+iW+jp.x/jn;local gx=iV+iW*1.5/2+jp.y/jo;jm=jm..'<line x1="'..bW..'" y1="'..bX..'" x2="'..jq..'" y2="'..gx..'" stroke="purple" stroke-width="1"/>'gK[#gK+1]=jm;gK[#gK+1]='</g>'end elseif SelectedTab=="INFO"then gK=aP.DrawOdometer(gK,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then gK=iN(gK)elseif SelectedTab=="SCOPE"then gK[#gK+1]='<g clip-path="url(#orbitRect)">'local jn=(maxAtlasX-minAtlasX)/j9;local jo=(maxAtlasY-minAtlasY)/j8;local jr=bC;table.sort(bB,function(c1,c2)return(c1.center-bf):len2()>(c2.center-bf):len2()end)local eE={}local js={}local jt=120;local ju=100;local jv=nil;local jw=nil;for i=#bB,1,-1 do local cg=bB[i]local eD=cg.center-bf;local jx=eD:len()local jy=eD:normalize()local jz=eD:cross(b8):normalize()local jA=math.acos(jz:dot(b9))if jz:cross(b9):dot(b8)<0 then jA=-jA end;local jB=eD:project_on_plane(b8):len()local jC=eD:project_on_plane(b9)local jD=eD:project_on_plane(b7)local jE=math.sin(jA)*math.asin(jB/jx)*constants.rad2deg;local jF=math.cos(jA)*math.asin(jB/jx)*constants.rad2deg;if jy:dot(b8)<0 then jF=90*math.cos(jA)+90*math.cos(jA)-jF;jE=90*math.sin(jA)+90*math.sin(jA)-jE end;local bW=jc+jE/jr*j8;local bX=jd+jF/jr*j8;local jG=(bW-jc)*(bW-jc)+(bX-jd)*(bX-jd)local jH=math.asin((cg.radius+cg.surfaceMaxAltitude)/jx)*constants.rad2deg;local fw=jH/jr*j8;local jI=math.asin(cg.atmosphereRadius/jx)*constants.rad2deg;local jJ=jI/jr*j8;local aj=c3(jx,1)local jK=cg.name;local jL=false;if bX>iV then if bX>jf then if bX-jJ<=jf then jL=true end else jL=true end else if bX+jJ>=iV then jL=true end end;local jM=false;local jN=bW;if cg.systemId==0 then jN=bW+jt else jN=bW-jt end;if jN+jt>iU then if jN+jt>je then if jN-jJ-jt<=je then jM=true end else jM=true end else if jN+jJ+jt>=iU then jM=true end end;local jO={}jO.x=bW;jO.y=bX;jO.planet=cg;jO.atmoSize=jJ;if not jv or jG<jv then jv=jG;jw=jO end;if jM and jL then local jP=math.max(jJ,5)if jG<jP*jP then jK=jK.." - "..aj end;jO.size=fw;jO.i=i;jO.displayString=jK;jO.distance=aj;jO.visible=true;js[#js+1]=jO else jO.visible=false end end;local jQ=false;table.sort(js,function(c1,c2)return c1.y<c2.y end)for cf,ee in ipairs(js)do local cg,fw,i,jJ,bW,bX,jK,aj=ee.planet,ee.size,ee.i,ee.atmoSize,ee.x,ee.y,ee.displayString,ee.distance;local j6,jR,jS,jT;local jU=15;local bZ="pdim"if cg.systemId~=0 then jS=g2(string.len(jK)*5)jU=-(15+jS)jT=g3(10)bZ="pdimfill"else jS=g2(string.len(jK)*9)jT=g3(15)end;if fw*2>jS then j6=r(bW,iU+jS/2,je-jS/2)jR=r(bX,iV+jT,jf-5)j6=r(j6,bW-fw+jS/2,bW+fw-jS/2)jR=r(jR,bX-fw+jT,bX+fw)else j6=bW+jU;jR=bX end;local jV;local jW=0;repeat jV=false;for jX,ee in pairs(eE)do local jY=ee.textPositions;local jZ=jY.y-jR;if jX~=i and d(jZ)<jY.height and jY.x+jY.width>j6 and jY.x<j6+jS then if fw>jS then jR=r(jR+jT,iV+15,jf-5)else jR=jY.y+jY.height+1;jV=true;break end end end;jW=jW+1 until not jV or jW==10;local j_=jK~=cg.name or j6<=jc and j6+jS>=jc and jR-jT<=jd and jR>=jd;ee.hovered=j_;local k0=1;if j_ then k0=2;if fw*2<jS then k0=10 end;if jK==cg.name then jK=jK.." - "..aj end;bZ="pbright"if cg.systemId~=0 then jS=g2(string.len(jK)*5)jU=-(15+jS)else jS=g2(string.len(jK)*7)end;if fw*2>jS then j6=r(bW,iU+jS/2,je-jS/2)j6=r(j6,bW-fw+jS/2,bW+fw-jS/2)else j6=bW+jU end;if not Autopilot and not VectorToTarget and not am and not IntoOrbit and not jQ then jQ=true;if AutopilotTargetName~=cg.name then for k1,cJ in ipairs(bm)do if cJ.index==cg.id then AutopilotTargetIndex=k1;aQ.UpdateAutopilotTarget()break end end end end end;eE[i]={}eE[i].textPositions={}eE[i].textPositions.y=jR;eE[i].textPositions.x=j6;eE[i].textPositions.width=jS;eE[i].textPositions.height=jT;eE[i].output=""if fw*2>jS then bZ=bZ.." txtmid"else bZ=bZ.." txtstart"end;if jJ-fw>2 then eE[i].output=f('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',bW,bX,jJ,az,0.1*k0)end;eE[i].output=eE[i].output..f('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',bW,bX,fw,az,0.2*k0)if cg.systemId==0 then eE[i].output=eE[i].output..f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j6,jR,ay,bZ,jK)if fw*2<=jS then eE[i].output=eE[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j6+jS,jR+2,j6,jR+2,bW,bX)end else eE[i].output=eE[i].output..f([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j6,jR,az,bZ,jK)if fw*2<=jS then eE[i].output=eE[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j6,jR+2,j6+jS,jR+2,bW,bX)end end end;for cf,cg in ipairs(bB)do if eE[cf]then gK[#gK+1]=eE[cf].output end end;if jw~=nil and bC<90 and not jw.hovered then local k2=jw.planet.atmosphereRadius/jw.atmoSize;local k3=y(jv)*k2;local k4=c3(k3,1)local jS=g2(math.max(string.len(k4)*7,string.len(jw.planet.name)*7))local jT=g3(12)local j6=r(jw.x+(jc-jw.x)/2,iU+jS/2,je-jS/2)local jR=r(jw.y+(jd-jw.y)/2,iV+jT*2,jf-5)gK[#gK+1]=f("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",jw.x,jw.y,jc,jd)gK[#gK+1]=f([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j6,jR,"white",k4)if not jw.visible then gK[#gK+1]=f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j6,jR-jT,"white",jw.planet.name)end end;if bc>1 then local eD=bb;local jy=eD:normalize()local jB=eD:project_on_plane(b8):len()local jC=eD:project_on_plane(b9)local jD=eD:project_on_plane(b7)local jz=eD:cross(b8):normalize()local jA=math.acos(jz:dot(b9))if jz:cross(b9):dot(b8)<0 then jA=-jA end;local jE=math.sin(jA)*math.asin(jB/eD:len())*constants.rad2deg;local jF=math.cos(jA)*math.asin(jB/eD:len())*constants.rad2deg;if jy:dot(b8)<0 then jF=90*math.cos(jA)+90*math.cos(jA)-jF;jE=90*math.sin(jA)+90*math.sin(jA)-jE end;local bW=jc+jE/jr*j8;local bX=jd+jF/jr*j8;local hG=14;local hH=hG/2;local hK=[[<circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hH/hG..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bW-hG..[[,]]..bX..[[ h ]]..hH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bW+hH..[[,]]..bX..[[ h ]]..hH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bW..[[,]]..bX-hG..[[ v ]]..hH..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]gK[#gK+1]=hK end;gK[#gK+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jc,jd-10,jc,jd+10)gK[#gK+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jc-10,jd,jc+10,jd)gK[#gK+1]='</g>'else return gK end end;local function k5(k6,k7)local k8;local k9=(k7-k6):normalize()local ec=(bf-k6):dot(k9)/k9:dot(k9)if ec<=0.then return(bf-k6):len()elseif ec>=(k7-k6):len()then return(bf-k7):len()end;local ka=k6+ec*k9;k8=(ka-bf):len()return k8 end;local function kb()local k8;local kc=nil;local kd=nil;local ke=nil;for cf,kf in pairs(b[0])do if kf.hasAtmosphere then local aj=k5(planet.center,kf.center)if kc==nil or aj<kc then kd=kf;kc=aj;ke=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dy=k5(ac.center,kf.center)if dy<kc then kd=kf;kc=dy;ke=ac end end end end;local kg=g2(1770)local kh=g3(330)if kc then local ki="txttick "local kj=500000;if kc<kd.radius+kj or kc<ke.radius+kj then if bn then ki="txttick red "else ki="txttick orange "end end;k8=c3(kc,2)fU=bV(kg,kh,"Pipe ("..ke.name.."--"..kd.name.."): "..k8,ki.."pbright txtmid")end end;local function kk(bW,bX,kl,km,hT)local kn={x=bW,y=bX,width=kl,height=km,label=hT}by[hT]=kn;return kn end;local function ko(kp,kq,kl,km,bW,bX,kr,ks,kt,ku,bZ)local kn={enableName=kp,disableName=kq,width=kl,height=km,x=bW,y=bX,toggleVar=kr,toggleFunction=ks,drawCondition=kt,hovered=false,class=bZ}if ku then table.insert(fO,kn)else table.insert(fN,kn)end;return kn end;local function kv(kw)if not fS then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif kw=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif kw=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif kw=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fT=bO(kw)showHud=false else fT={}showHud=true end end;local function kx()fS=not fS;if fS then fM=fO;a2="Hold SHIFT to see Settings"bD=showHud else fM=fN;a2="Hold SHIFT to see Control Buttons"kv()showHud=bD end end;local function ky()local function kz(cg)_G[cg]=not _G[cg]if _G[cg]then a2=cg.." set to true"else a2=cg.." set to false"end;if cg=="showHud"then bD=_G[cg]elseif cg=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local kA=50;local kB=340;local bW=500;local bX=aE/2-400;local kC=0;for cf,cg in pairs(bO("boolean"))do if type(_G[cg])=="boolean"then ko(cg,cg,kB,kA,bW,bX,function()return _G[cg]end,function()kz(cg)end,function()return true end,true)bX=bX+kA+20;if kC==9 then bW=bW+kB+20;bX=aE/2-400;kC=0 else kC=kC+1 end end end;ko("Control View","Control View",kB,kA,10,aE/2-500,function()return true end,kx,function()return true end,true)ko("View Handling Settings",'Hide Handling Settings',kB,kA,10,aE/2-(500-kA),function()return showHandlingVariables end,function()kv("handling")end,function()return true end,true)ko("View Hud Settings",'Hide Hud Settings',kB,kA,10,aE/2-(500-kA*2),function()return showHudVariables end,function()kv("hud")end,function()return true end,true)ko("View Physics Settings",'Hide Physics Settings',kB,kA,10,aE/2-(500-kA*3),function()return showPhysicsVariables end,function()kv("physics")end,function()return true end,true)end;local function kD()local function kE()local position=bf;local fz=planet.name..". "..#SavedLocations;if bu[1]then local cJ,_=bu[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cJ~=nil and cJ~=""then fz=fz.." "..bu[1].getConstructName(cJ)end end;return aQ.AddNewLocation(fz,position,false,true)end;local function kF()TurnBurn=not TurnBurn end;local function kG(kH)if kH==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kI()aQ.UpdatePosition()end;local function kJ()aQ.ClearCurrentPosition()end;local function kK(fk)local fz=AutopilotTargetName;if fk~=nil and type(fk)=="number"then if fk==0 then return"None"end;fz=bm[fk].name end;if fz==nil then fz=CustomTarget.name end;if fz==nil then fz="None"end;return fz end;local function kL(fk)return"Engage Autopilot: "..kK(fk)end;local function kM(fk)return"Disable Autopilot: "..kK(fk)end;local function kN()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bI("folOn","F")else bI("folOff","F")BrakeIsOn=true;aV=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local kA=50;local kB=260;local kO=g2(30)local kP=OrbitMapX+OrbitMapSize*2+2;local kQ=OrbitMapY+1;ko("+","+",kO,kO,kP,kQ+kO+1,function()return false end,function()bC=bC/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")ko("-","-",kO,kO,kP,kQ,function()return false end,function()bC=math.min(bC*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")ko("0","0",kO,kO,kP,kQ+kO*2+2,function()return false end,function()bC=90 end,function()return SelectedTab=="SCOPE"and bC~=90 end,nil,"ZoomButton")local kR=ko("Enable Brake Toggle","Disable Brake Toggle",kB,kA,aD/2-kB/2,aE/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)ko("Align Prograde","Disable Prograde",kB,kA,aD/2-kB/2-50-kR.width,aE/2-kA+380,function()return ProgradeIsOn end,function()kG(1)end)ko("Align Retrograde","Disable Retrograde",kB,kA,aD/2-kB/2+kR.width+50,aE/2-kA+380,function()return RetrogradeIsOn end,kG,function()return ar==0 end)apbutton=ko(kL,kM,600,60,aD/2-600/2,aE/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function kS(kT)local fk=bx+kT;if fk>#bm then fk=fk-#bm-1 end;if fk<0 then fk=#bm+fk end;return fk end;apExtraButtons={}for i=0,10 do local button=ko(function(c2)local fk=kS(c2.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..kK(fk)end;return kL(fk)end,function(c2)local fk=kS(c2.apExtraIndex)return kM(fk)end,600,60,aD/2-600/2,aE/2-60/2-330+60*i,function(c2)local fk=kS(c2.apExtraIndex)return fk==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(c2)local fk=kS(c2.apExtraIndex)local kU=AutopilotTargetIndex==fk;AutopilotTargetIndex=fk;aQ.UpdateAutopilotTarget()aR.ToggleAutopilot()if not kU and not(Autopilot or VectorToTarget or am or IntoOrbit)then aR.ToggleAutopilot()end end,function()return bw end)button.apExtraIndex=i;apExtraButtons[i]=button end;ko("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kE,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)ko("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kI,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ko("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kJ,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kA=60;kB=300;local bW=0;local bX=aE/2-150;ko("View Settings","View Settings",kB,kA,bW,bX,function()return true end,kx)bX=bX+kA+20;ko("Enable Turn and Burn","Disable Turn and Burn",kB,kA,bW,bX,function()return TurnBurn end,kF)bW=10;bX=aE/2-300;ko("Horizontal Takeoff Mode","Vertical Takeoff Mode",kB,kA,bW+kB+20,bX,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bg end)bX=bX+kA+20;ko("Engage Orbiting","Cancel Orbiting",kB,kA,bW+kB+20,bX,function()return IntoOrbit end,aR.ToggleIntoOrbit,function()return ar==0 and br end)bX=aE/2-150;ko("Glide Re-Entry","Cancel Glide Re-Entry",kB,kA,bW+kB+20,bX,function()return Reentry end,function()al=1;kG(1)end,function()return planet.hasAtmosphere and not aq end)bX=bX+kA+20;ko("Parachute Re-Entry","Cancel Parachute Re-Entry",kB,kA,bW+kB+20,bX,function()return Reentry end,aR.BeginReentry,function()return planet.hasAtmosphere and not aq end)bX=bX+kA+20;ko("Engage Follow Mode","Disable Follow Mode",kB,kA,bW,bX,function()return a0 end,kN,function()return m()==1 end)ko("Enable Repair Arrows","Disable Repair Arrows",kB,kA,bW+kB+20,bX,function()return aJ end,function()aJ=not aJ;if aJ then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)bX=bX+kA+20;if not ExternalAGG then ko("Enable AGG","Disable AGG",kB,kA,bW,bX,function()return bh end,aR.ToggleAntigrav,function()return antigrav~=nil end)end;ko(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,kB*2,kA,bW,bX,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)bX=bX+kA+20;ko(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,kB*2,kA,bW,bX,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local kV=g3(20)local button=kk(0,0,g2(70),kV,"HELP")button=kk(button.x+button.width,button.y,g2(80),kV,"INFO")button=kk(button.x+button.width,button.y,g2(70),kV,"ORBIT")button=kk(button.x+button.width,button.y,g2(70),kV,"SCOPE")kk(button.x+button.width,button.y,g2(70),kV,"HIDE")end;local kW={}local kX=nil;function kW.HUDPrologue(gK)bn,bo=g0(bf)if not bn then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.6)..","..e(J+0.6)..","..e(I+0.6)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kY=ay;local kZ=az;local k_=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.4+0.5)..[[)]]local l0=ay;local l1=az;local l2=k_;if g4()and not brightHud then kY=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kZ=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]k_=[[rgb(]]..e(H*0.2+0.5)..","..e(J*0.2+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iC=g2;local iD=g3;gK[#gK+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .pdimfill {fill: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                    <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="1"/>
                                    </radialGradient>
                                    <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="66%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/>
                                    </radialGradient>                            
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kY,kY,kY,l0,l0,kZ,kZ,l1,l1,kZ,kY,k_,l1,kY,kY,k_,k_,l2,k_,aD,aE,kZ,kZ,kZ,kZ,kZ,l0,kZ,l1,l2,l1,l1,l2)if not kX then kX=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iC(630),iD(0),iC(675),iD(45),iC(960),iD(55),iC(1245),iD(45),iC(1290),iD(0),iC(1000),iD(105),iC(1040),iD(59),iC(1250),iD(51),iC(1300),iD(0),iC(1920),iD(0),iC(1920),iD(20),iC(1400),iD(20),iC(1300),iD(105),iC(920),iD(105),iC(880),iD(59),iC(670),iD(51),iC(620),iD(0),iC(0),iD(0),iC(0),iD(20),iC(520),iD(20),iC(620),iD(105),iC(890),iD(59),iC(960),iD(62),iC(1030),iD(59),iC(985),iD(112),iC(1150),iD(112),iC(1100),iD(152),iC(820),iD(152),iC(780),iD(112),iC(935),iD(112),iC(890),iD(59),iC(960),iD(62),iC(1030),iD(59),iC(985),iD(112),iC(1150),iD(112),iC(1100),iD(152),iC(820),iD(152),iC(780),iD(112),iC(935),iD(112))end;gK[#gK+1]=kX;return gK end;function kW.DrawVerticalSpeed(gK,cR)gJ(gK,cR)end;function kW.UpdateHud(gK)local hz=bk;local l3=bl;local gS=l3;local h6=hz;local hR=e(unit.getThrottle())local hW=bc*3.6;local hS=unit.getAxisCommandValue(0)local l4=g2(1770)local l5=g3(310)if AtmoSpeedAssist and bj then hS=K;hR=K*100 end;local g6=g5()local gT="ROLL"if hR==nil then hR=0 end;if not br then if bc>5 then hz=hy(ba)l3=hA(ba)else hz=0;l3=0 end;gT="YAW"end;if bo>50000 and not aq then local l6;l6=c3(bo)gK[#gK+1]=bV(l4,l5,"PvP Boundary: "..l6,"pbright txtbig txtmid")end;gK[#gK+1]=ak;gK[#gK+1]=aB;gK[#gK+1]=g8;if fU~=""then gK[#gK+1]=fU end;if g9~=""then gK[#gK+1]=g9 end;if ga~=""then gK[#gK+1]=ga end;gJ(gK,as)if m()==0 or RemoteHud then if br then gR(gK,centerX,centerY,gS,gT,br)else gR(gK,centerX,centerY,l3,gT,br)end;if not g4()or brightHud then if br then gR(gK,centerX,centerY,gS,gT,br)h5(gK,h6,gS,centerX,centerY,br,e(hA(ba)),bc)else gR(gK,centerX,centerY,l3,gT,br)h5(gK,hz,l3,centerX,centerY,br,e(l3),bc)end;hc(gK,as,br)hB(gK,ba,bc,centerX,centerY)end end;hQ(gK,g6,hR,hS)hV(gK,hW)hZ(gK)iT(gK)return gK end;function kW.HUDEpilogue(gK)gK[#gK+1]="</svg>"return gK end;function kW.ExtraData(gK)local l7=g2(1240)local l8=g3(55)local l9=l8+10;local la;local iC=g2;local iD=g3;local lb=0;local g6=g5()if VertTakeOffEngine then g6=g6 .."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bc>20 then g6=g6 .."-COLLISION ON"end;if UseExtra~="Off"then g6="("..UseExtra..")-"..g6 end;if TurnBurn then g6="TB-"..g6 end;if not stablized then g6=g6 .."-DeCoupled"end;local lc=iD(99)local ld=iD(80)local le=iD(85)local lf=iD(31)local lg=0;local lh=0;local li=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then lb=LastMaxBrakeInAtmo else lb=LastMaxBrake end;local lj,lk=aM.computeDistanceAndTime(bc,0,av,0,0,lb)if lj<0 then lj=0 end;lb=A(lb/(av*fL),2).."g"local ll=a:maxForceForward()la=core.g()if la>0.1 then lh=av*la;lh=A(lh/(av*fL),2).."g"lg=0.5*ll/la;lg=lg>1000000 and A(lg/1000000,2).."kT"or A(lg/1000,2).."T"end;ll=A(ll/(av*fL),2).."g"local lm=vec3(core.getWorldAcceleration()):len()/9.80665;la=core.g()gK[#gK+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then l7=g2(1120)l8=g3(55)l9=l8+10 elseif aq then local ln=g2(770)gK[#gK+1]=bV(iC(895),lc,"ATMO","")gK[#gK+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iC(895),le,iC(-80))gK[#gK+1]=bV(iC(815),ld,f("%.1f%%",ar*100),"txtstart size20")end;gK[#gK+1]=bV(iC(1025),lc,"GRAVITY","txtstart")gK[#gK+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iC(1025),le,iC(80))gK[#gK+1]=bV(iC(1105),ld,f("%.2fg",la/9.80665),"size20")gK[#gK+1]=bV(iC(1125),lc,"ACCEL","txtstart")gK[#gK+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iC(1125),le,iC(80))gK[#gK+1]=bV(iC(1205),ld,f("%.2fg",lm),"size20")gK[#gK+1]=bV(iC(695),lc,"BRK TIME","")gK[#gK+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iC(695),le,iC(-80))gK[#gK+1]=bV(iC(615),ld,f("%s",c6(lk)),"txtstart size20")gK[#gK+1]=bV(iC(635),iD(45),"TRIP","")gK[#gK+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iC(635),iD(31),iC(-90))if travelTime then gK[#gK+1]=bV(iC(532),iD(23),f("%s",c6(travelTime)),"txtstart size20")end;gK[#gK+1]=bV(iC(795),lc,"BRK DIST","")gK[#gK+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iC(795),le,iC(-80))gK[#gK+1]=bV(iC(715),ld,f("%s",c3(lj)),"txtstart size20")gK[#gK+1]=bV(iC(1285),iD(45),"MASS","txtstart")gK[#gK+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iC(1285),iD(31),iC(90))gK[#gK+1]=bV(iC(1388),iD(23),f("%s",li),"size20")gK[#gK+1]=bV(iC(1220),lc,"THRUST","txtstart")gK[#gK+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iC(1220),le,iC(80))gK[#gK+1]=bV(iC(1300),ld,f("%s",ll),"size20")gK[#gK+1]=bV(g2(960),g3(175),g6,"pbright txtbig txtmid size20")gK[#gK+1]="</g>"end;function kW.DrawOdometer(gK,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return gK end;local la;local lg=0;local lh=0;local lb=0;local li=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then lb=LastMaxBrakeInAtmo else lb=LastMaxBrake end;local lj,lk=aM.computeDistanceAndTime(bc,0,av,0,0,lb)lb=A(lb/(av*fL),2).." g"local ll=a:maxForceForward()la=core.g()if la>0.1 then lh=av*la;lh=A(lh/(av*fL),2).." g"lg=0.5*ll/la;lg=lg>1000000 and A(lg/1000000,2).." kTons"or A(lg/1000,2).." Tons"end;ll=A(ll/(av*fL),2).." g"if m()==0 or RemoteHud then local lo=g2(OrbitMapX+10)local lp=g3(OrbitMapY+20)local lq=g2(OrbitMapX+10+OrbitMapSize/1.25)local km=25;gK[#gK+1]="<g class='txtstart size14 bright'>"gK[#gK+1]=bV(lo,lp,f("BrkTime: %s",c6(lk)))gK[#gK+1]=bV(lq,lp,f("Trip: %.2f km",ad))gK[#gK+1]=bV(lo,lp+km,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gK[#gK+1]=bV(lq,lp+km,f("BrkDist: %s",c3(lj)))gK[#gK+1]=bV(lo,lp+km*2,"Trip Time: "..c6(ae))gK[#gK+1]=bV(lq,lp+km*2,"Total Time: "..c6(TotalFlightTime))gK[#gK+1]=bV(lo,lp+km*3,f("Mass: %s",li))gK[#gK+1]=bV(lq,lp+km*3,f("Max Brake: %s",lb))gK[#gK+1]=bV(lo,lp+km*4,f("Max Thrust: %s",ll))if la>0.1 then gK[#gK+1]=bV(lq,lp+km*4,f("Max Thrust Mass: %s",lg))gK[#gK+1]=bV(lo,lp+km*5,f("Req Thrust: %s",lh))else gK[#gK+1]=bV(lq,lp+km*5,"Max Mass: n/a")gK[#gK+1]=bV(lo,lp+km*6,"Req Thrust: n/a")end end;gK[#gK+1]="</g></g>"return gK end;function kW.DrawWarnings(gK)return hZ(gK)end;function kW.DisplayOrbitScreen(gK)return iT(gK)end;function kW.DisplayMessage(gK,il)if il~="empty"then local bX=310;for lr in string.gmatch(il,"([^\n]+)")do bX=bX+35;gK[#gK+1]=bV("50%",bX,lr,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function kW.DrawDeadZone(gK)gK[#gK+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kW.UpdatePipe()if aq then fU=""return end;kb()end;function kW.DrawSettings(gK)if#fT>0 then local bW=g2(640)local bX=g3(200)gK[#gK+1]=[[<g class="pbright txtvspd txtstart">]]for cf,cg in pairs(fT)do gK[#gK+1]=bV(bW,bX,cg..": ".._G[cg])bX=bX+20;if cf%12==0 then bW=bW+g2(350)bX=g3(200)end end;gK[#gK+1]=bV(g2(640),g3(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gK[#gK+1]="</g>"end;return gK end;local ls;local lt=g2(1770)local lu=g3(350)local lv=g3(15)local lw=g2(1370)local bE,lx;local ly=0;function kW.DrawRadarInfo()local function lz()if radarPanelID~=nil and ly==0 then t(radarPanelID)radarPanelID=nil;if ls~=nil then t(ls)ls=nil end else if ly==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bu,1,"Periscope","periscope")ls=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bu,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;ly=0 end end;local eD,eE,eC,eF,eG,ez=aS.GetRadarHud()local B=eF or 0;if eC>0 then if CollisionSystem then bE=B.."/"..eG.." Plotted : "..eC-eG.." Ignored"else bE="Radar Contacts: "..eC end;g8=bV(lt,lu,bE,"pbright txtbig txtmid")if#ez>0 then g8=g8 ..bV(lw,lv,"Friendlies In Range","pbright txtbig txtmid")for cf,cg in pairs(ez)do lv=lv+20;g8=g8 ..bV(lw,lv,bu[1].getConstructName(cg),"pdim txtmid")end end;if eD==nil and ls==nil then ly=1;lz()end;if eD~=nil and ls~=nil then lz()end;if radarPanelID==nil then lz()end else if eE then g8=bV(lt,lu,bv.." Radar: Jammed","pbright txtbig txtmid")else g8=bV(lt,lu,"Radar: No "..bv.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ly=0;lz()end end end;function kW.DrawTanks()if fuelX~=0 and fuelY~=0 then g9=bV(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gq(fuelX,"Atmospheric ","ATMO",aF,go,gp)gq(fuelX,"Space Fuel T","SPACE",aG,gm,gn)gq(fuelX,"Rocket Fuel ","ROCKET",aH,gk,gl)end end;function kW.DrawShield()local lA=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local lB=core.getPvPTimer()local lC=shield_1.getResistances()local lD="A: "..10+lC[1]*100 .."% / E: "..10+lC[2]*100 .."% / K:"..10+lC[3]*100 .."% / T: "..10+lC[4]*100 .."%"local bW,bX=shieldX-60,shieldY+30;local lE=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gE=e(lE*2.55)local gF=f("rgb(%d,%d,%d)",255-gE,gE,0)local bZ=""ga=bV(bW,bX,"","txtmid pdim txtfuel")if lE<10 and lA~="Shield Disabled"then bZ="red "end;lB=lB>0 and"   PvPTime: "..c6(lB)or""ga=ga..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bW,bX,gF,lE*2,bW,bX,bW+2,bX+10,lE,lB)ga=ga..bV(bW,bX-5,lA,bZ.."txtstart pbright txtbig")ga=ga..bV(bW,bX+30,lD,bZ.."txtstart pbright txtsmall")end;function kW.hudtick()if not planet then return end;local function lF(gK)local gH=e(r(aj/(aD/4)*255,0,255))gK[#gK+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+gH,e(J+0.5)-gH,e(I+0.5)-gH)end;local function lG()for _,cg in pairs(fM)do if cg.hovered then if not cg.drawCondition or cg.drawCondition(cg)then cg.toggleFunction(cg)end;cg.hovered=false end end;for _,cg in pairs(by)do if cg.hovered then SelectedTab=cg.label;cg.hovered=false end end end;local function lH()local function lI(lJ,lK,bW,bX,kl,km)if lJ>=bW and lJ<=bW+kl and lK>=bX and lK<=bX+km then return true else return false end end;local bW=ag+aD/2;local bX=ah+aE/2;for _,cg in pairs(fM)do cg.hovered=lI(bW,bX,cg.x,cg.y,cg.width,cg.height)end;for _,cg in pairs(by)do cg.hovered=lI(bW,bX,cg.x,cg.y,cg.width,cg.height)end;if bw then local j_=false;for _,c2 in ipairs(apExtraButtons)do if c2.hovered then j_=true;break end end;if apbutton.hovered then j_=true end;bw=j_ else bw=apbutton.hovered;if not bw then bx=AutopilotTargetIndex end end end;local function lL(gK)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;for cf,cg in pairs(by)do local bZ="dim brightstroke"local lM=0.2;if SelectedTab==cf then bZ="pbright dimstroke"lM=0.6 end;local lN=""if cg.hovered then lM=0.8;lN=";stroke:white"end;gK[#gK+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cg.width,cg.height,cg.x,cg.y,bZ,lM,lN)gK[#gK+1]=bV(cg.x+cg.width/2,cg.y+cg.height/2+5,cg.label,"txt txtmid pdim")end end;local function lO(gK)local function lP(gK,lQ,hover,bW,bX,e0,lR,lS,lT,lU,lV,button)if type(lU)=="function"then lU=lU(button)end;if type(lV)=="function"then lV=lV(button)end;gK[#gK+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bW,bX,e0,lR)if lQ then gK[#gK+1]=f("%s'",lS)else gK[#gK+1]=lT end;if hover then gK[#gK+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gK[#gK+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gK[#gK+1]=" rx='5'></rect>"gK[#gK+1]=f("<text x='%f' y='%f' font-size='24' fill='",bW+e0/2,bX+lR/2+5)if lQ then gK[#gK+1]="black"else gK[#gK+1]="white"end;gK[#gK+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lQ then gK[#gK+1]=f("%s</text>",lU)else gK[#gK+1]=f("%s</text>",lV)end end;local lW=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local lX=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local lY=lP;for _,cg in pairs(fM)do local kq=cg.disableName;local kp=cg.enableName;if type(kq)=="function"then kq=kq(cg)end;if type(kp)=="function"then kp=kp(cg)end;if not cg.drawCondition or cg.drawCondition(cg)then lY(gK,cg.toggleVar(cg),cg.hovered,cg.x,cg.y,cg.width,cg.height,lX,lW,kq,kp,cg)end end end;local lZ=A(aD/2,0)local l_=A(aE/2,0)local gK={}aP.HUDPrologue(gK)if showHud then aP.UpdateHud(gK)else if AlwaysVSpd then aP.DrawVerticalSpeed(gK,as)end;aP.DisplayOrbitScreen(gK)aP.DrawWarnings(gK)end;if fS and fT~={}then aP.DrawSettings(gK)end;if radar_1 or radar_2 then aS.assignRadar()end;if bu[1]then aP.DrawRadarInfo()end;aP.HUDEpilogue(gK)gK[#gK+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aD,aE)if a2~="empty"then aP.DisplayMessage(gK,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aP.DrawDeadZone(gK)end end;lL(gK)if x()==0 then if m()==1 and a1 then if not AltIsOn then lH()lO(gK)end;if not aT and not aU then local m0=table.concat(gK,"")gK={}gK[#gK+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gK[#gK+1]=m0;gK[#gK+1]="</body>"aT=true;gK[#gK+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gK,"")system.setScreen(content)elseif aU then local m0=table.concat(gK,"")gK={}gK[#gK+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gK[#gK+1]=m0;gK[#gK+1]="</body>"end;if not aT then gK[#gK+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lZ,l_,ag,ah)end else lG()end else if not a1 and m()==0 then lG()if aj>DeadZone then if DisplayDeadZone then lF(gK)end end elseif a1 and(not AltIsOn or not freeLookToggle)then lH()lO(gK)end;gK[#gK+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lZ,l_,ag,ah)end;gK[#gK+1]=[[</svg></body>]]content=table.concat(gK,"")end;function kW.TenthTick()aP.DrawTanks()if shield_1 then aP.DrawShield()end end;function kW.OneSecond(gK)local function m1()local gA=q()local hW=bc;local m2=gA-au;if hW>1.38889 then hW=hW/1000;local m3=hW*(gA-au)TotalDistanceTravelled=TotalDistanceTravelled+m3;ad=ad+m3 end;ae=ae+m2;TotalFlightTime=TotalFlightTime+m2;au=gA end;m1()aP.UpdatePipe()aP.ExtraData(gK)end;function kW.ButtonSetup()ky()kD()fM=fN end;return kW end;local function m4()local function m5(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function m6()local function m7(m8,m9)return m8.name<m9.name end;bm={}for cf,cg in pairs(b[0])do bm[#bm+1]={name=cg.name,index=cf}end;table.sort(bm,m7)end;local function ma(mb)for cf,cg in pairs(mb)do if cg.name and cg.name==CustomTarget.name then return cf end end;return-1 end;local function mc()bx=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local md=bm[AutopilotTargetIndex].index;local me=b[0][md]if me.center then AutopilotTargetName=me.name;ac=aL[0][md]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=me;for _,cg in pairs(aL[0])do if cg.name==CustomTarget.planetname then ac=cg;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function mf(gO)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if gO==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bm end end;if AutopilotTargetIndex==0 then mc()else local md=bm[AutopilotTargetIndex].index;local me=b[0][md]if me~=nil and me.name=="Space"or iphCondition=="Custom Only"and me.center or iphCondition=="No Moons"and string.find(me.name,"Moon")~=nil then if gO==nil then mf()else mf(1)end else mc()end end else a2="Disengage autopilot before changing Interplanetary Helper"bI("iph","AP")end end;local function kJ()local fk=-1;fk=ma(b[0])if fk>-1 then table.remove(b[0],fk)end;fk=-1;fk=ma(SavedLocations)if fk~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fk)end;mf()m6()end;local function kE(fz,position,hv,mg)if dbHud_1 or hv then local p=m5(position)local la=p.gravity;if mg then la=unit.getClosestPlanetInfluence()end;local mh={position=position,name=fz,planetname=p.name,gravity=la,safe=mg}if not hv then SavedLocations[#SavedLocations+1]=mh else for cf,cg in pairs(b[0])do if cg.name and fz==cg.name then table.remove(b[0],cf)end end end;table.insert(b[0],mh)m6()mc()a2="Location saved as "..fz.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local mi={}function mi.UpdateAtlasLocationsList()m6()end;function mi.UpdateAutopilotTarget()mc()end;function mi.adjustAutopilotTargetIndex(gO)mf(gO)end;function mi.findAtlasIndex(mb)ma(mb)end;function mi.UpdatePosition(mj)local fk=ma(SavedLocations)if fk~=-1 then if mj~=nil then SavedLocations[fk].name=mj;AutopilotTargetIndex=AutopilotTargetIndex-1;mf()else local mk=SavedLocations[fk]mk.gravity=unit.getClosestPlanetInfluence()mk.position=bf;mk.safe=true end;a2=SavedLocations[fk].name.." position updated ("..SavedLocations[fk].planetname..")"else a2="Name Not Found"end end;function mi.AddNewLocation(fz,position,hv,mg)kE(fz,position,hv,mg)end;function mi.ClearCurrentPosition()kJ()end;for cf,cg in pairs(SavedLocations)do table.insert(b[0],cg)end;m6()if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end;mi.UpdateAutopilotTarget()return mi end;local function ml()local mm={}local function mn(e7)local mo=AutopilotEndSpeed;if not Autopilot then mo=0 end;if not aq then return aM.computeDistanceAndTime(e7,mo,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aM.computeDistanceAndTime(e7,mo,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function mp(e7)local mo=AutopilotEndSpeed;if not Autopilot then mo=0 end;return aM.computeDistanceAndTime(e7,mo,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local mq=false;local mr=0;local ms=0;local mt=0;local mu=q()local mv=0;local mw=0;local mx=0;local my=0;local mz=false;local mA=false;local mB=false;local mC=nil;local mD=0;function mm.GetAutopilotBrakeDistanceAndTime(e7)return mn(e7)end;function mm.GetAutopilotTBBrakeDistanceAndTime(e7)return mp(e7)end;local function mE(mF,mG,mH)mG=mG:project_on_plane(mF)mH=mH:project_on_plane(mF)return n(mG:cross(mH):dot(mF),mG:dot(mH))end;local function mI()local function mJ()local mK=-1;local mL=-1;if vBooster then mK=vBooster.getDistance()end;if hover then mL=hover.getDistance()end;if mK~=-1 and mL~=-1 then if mK<mL then return mK else return mL end elseif mK~=-1 then return mK elseif mL~=-1 then return mL else return-1 end end;local mM=mJ()local mN=-1;if telemeter_1 then mN=telemeter_1.getDistance()end;if mM~=-1 and mN~=-1 then if mM<mN then return mM else return mN end elseif mM~=-1 then return mM else return mN end end;local function mO(planet,du,mP)local function mQ(mR,cL)local dA=vec3(cL)if mR.id==0 then return setmetatable({latitude=dA.x,longitude=dA.y,altitude=dA.z,id=0,systemId=mR.systemId},MapPosition)end;local dB=dA-mR.center;local aj=dB:len()local cR=aj-mR.radius;local cP=0;local cQ=0;if not c0(aj,0)then local dC=n(dB.y,dB.x)cQ=dC>=0 and dC or 2*math.pi+dC;cP=math.pi/2-math.acos(dB.z/aj)end;return setmetatable({latitude=math.deg(cP),longitude=math.deg(cQ),altitude=cR,id=mR.id,systemId=mR.systemId},MapPosition)end;local mS=mQ(planet,du)mS="::pos{"..mS.systemId..","..mS.id..","..mS.latitude..","..mS.longitude..","..mS.altitude.."}"if mP then return mS else system.setWaypoint(mS)return true end end;local mT=false;function mm.showWayPoint(planet,du,mP)return mO(planet,du,mP)end;function mm.APTick()local function mU()if bt and not BrakeLanding then local db=bt[1]local fA,fB=bt[2],bt[3]local mV=math.min(fA,fB or fA)local mW=mV/bc;local mX=AutoTakeoff and(bc<42 or ao~=-1)local mY=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mY and not mX and(a8*1.5>mV or mW<1)then BrakeIsOn=true;aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()end;if LockPitch then aR.ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then aR.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aV=true end;if mW<11 then bs=db.name.." COLLISION "..c6(mW).." / "..c3(mV,2)else bs=db.name.." collision "..c6(mW)end;if mW<6 then bI("alarm","AL",2)end else bs=false end end;local function mZ(m_,n0,n1)local function n2(m_,dd)m_=vec3(m_)dd=vec3(dd):normalize()local cw=m_*dd;return cw.x+cw.y+cw.z end;local n3=0.001;local n4=1;if not aq or not aX or ao~=-1 or bc<Q then if n1==nil then n1=DampingMultiplier end;if n0==nil then n0=n3 end;m_=vec3(m_):normalize()local n5=vec3()-m_;local n6=-n2(n5,core.getConstructWorldOrientationRight())*n4;local n7=-n2(n5,core.getConstructWorldOrientationUp())*n4;if ms==0 then ms=n6/2 end;if mt==0 then mt=n7/2 end;if d(n6)<0.1 then V=V-n6*2 else V=V-(n6+(n6-ms)*n1)end;if d(n7)<0.1 then U=U+n7*2 else U=U+n7+(n7-mt)*n1 end;ms=n6;mt=n7;if d(n6)<n0 and d(n7)<n0 then return true end;return false elseif aX and ao==-1 then m_=bb;if n1==nil then n1=DampingMultiplier end;if n0==nil then n0=n3 end;m_=vec3(m_):normalize()local n5=b8-m_;local n6=-n2(n5,core.getConstructWorldOrientationRight())*n4;local n7=-n2(n5,core.getConstructWorldOrientationUp())*n4;if ms==0 then ms=n6/2 end;if mt==0 then mt=n7/2 end;if d(n6)<0.1 then V=V-n6*5 else V=V-(n6+(n6-ms)*n1)end;if d(n7)<0.1 then U=U+n7*5 else U=U+n7+(n7-mt)*n1 end;ms=n6;mt=n7;if d(n6)<n0 and d(n7)<n0 then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=mI()E=q()mu=E;if CollisionSystem then mU()end;if antigrav then bh=antigrav.getState()==1 end;local n8=1;local n9=1;local na=E-mu;local nb=-math.deg(mE(b7,bb,b8))local nc=math.deg(mE(b9,bb,b8))local gO=bd*-1;aX=aq and nb<-YawStallAngle or nb>YawStallAngle or nc<-PitchStallAngle or nc>PitchStallAngle;local nd=system.getMouseDeltaX()local ne=system.getMouseDeltaY()if InvertMouse and not a1 then ne=-ne end;V=0;Z=0;U=0;sys=aL[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aO(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bb)if as==0 then as=(bf-planet.center):len()-planet.radius end;br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local la=planet:getGravity(core.getConstructWorldPos()):len()*av;aY=0;aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aT then ag=r(ag+nd,-aD/2,aD/2)ah=r(ah+ne,-aE/2,aE/2)end else ag=0;ah=0 end else ag=r(ag+nd,-aD/2,aD/2)ah=r(ah+ne,-aE/2,aE/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then local hI,hJ=nd,ne;if SelectedTab=="SCOPE"then hI,hJ=bC/90,bC/90 end;if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity*hI elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity*hI else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity*hJ elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity*hJ else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(ne,-100,100)+0.5)*2*n8;V=(-utils.smoothstep(nd,-100,100)+0.5)*2*n9 end end end end;local nf=bc>8334;if bc>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not nf then a2="Space Speed Engine Shutoff reached"aR.cmdThrottle(0)end;if not nf and LastIsWarping then if not BrakeIsOn then aR.BrakeToggle()end;if Autopilot then aR.ToggleAutopilot()end end;LastIsWarping=nf;if aq and ar>0.09 then if bc>aZ/3.6 and not AtmoSpeedAssist and not mq then BrakeIsOn=true;mq=true elseif not AtmoSpeedAssist and mq then if bc<aZ/3.6 then BrakeIsOn=false;mq=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local ng=false;if CustomTarget and al~=1 then ng=mZ(CustomTarget.position-bf,0.1)else ng=mZ(vec3(bb),0.01)end;aV=true;if ng then aR.cmdCruise(e(aZ))if(d(bl)<2 or d(bk)>85)and bc>=aZ/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;aR.BeginReentry()end elseif aq and AtmoSpeedAssist then aR.cmdThrottle(1)end elseif bc>Q then mZ(vec3(bb),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bc>Q then mZ(-vec3(bb))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;aR.BeginReentry()al=false;an=true else al=false;aR.ToggleAutopilot()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bc*3.6>aZ-250 and d(be)<25 and ar>=0.1 and(CustomTarget.position-bf):len()>2000+as then aR.ToggleAutopilot()an=false end;if VertTakeOff then aV=true;local nh=HoldAltitude;if be<-30 then a2="Unable to achieve lift. Safety Landing."af=0;aV=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bh or HoldAltitude<planet.spaceEngineMinAltitude then if bh then nh=antigrav.getBaseAltitude()end;if as<nh-100 then a_=0;af=15;BrakeIsOn=false elseif be>0 then BrakeIsOn=true;af=0 elseif be<-30 then BrakeIsOn=true;af=15 elseif as>=nh then if bh then if Autopilot or VectorToTarget then aR.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bI("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bI("vtoc","VT")aR.ToggleVerticalTakeoff()end;af=0 end else if ar>0.08 then a_=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if b5 then a_=0;af=20 else af=0;a_=36;aR.cmdCruise(3500)end else aV=autoRollPreference;IntoOrbit=true;b3=false;CancelIntoOrbit=false;mz=false;mx=nil;my=nil;if mC==nil then mC=planet end;b2=nh;mB=true;VertTakeOff=false end end;if a_~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ni=r(a_-bk,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ni)local nj=r(vTpitchPID:get(),-1,1)U=nj end end;if IntoOrbit then local n5;local nk=false;local nl=c3(b2)if mC==nil then mC=planet;if VectorToTarget then mC=ac end end;if not mB then b2=e(mC.radius+mC.surfaceMaxAltitude+LowOrbitHeight)if mC.hasAtmosphere then b2=e(mC.radius+mC.noAtmosphericDensityAltitude+LowOrbitHeight)end;mB=true end;if b1.VectorToTarget and CustomTarget then n5=CustomTarget.position-bf end;local nm,nn=aO(mC):escapeAndOrbitalSpeed((bf-mC.center):len()-mC.radius)local no=bl;if not mz then local np=false;local nq=false;aR.cmdThrottle(0)my=0;b0="Aligning to orbital path - OrbitHeight: "..nl;if b1.VectorToTarget then mZ(n5:normalize():project_on_plane(bd))nk=b8:dot(n5:project_on_plane(b7):normalize())>0.95 else mZ(bb)nk=nb<0.5;if bc<150 then nk=true end end;U=0;mx=0;if bk<=mx+1 and bk>=mx-1 then np=true else np=false end;if no<=my+1 and no>=my-1 then nq=true else nq=false end;if np and nq and nk then mx=nil;my=nil;mz=true end else if b1.VectorToTarget then mZ(n5:normalize():project_on_plane(bd))elseif bc>150 then mZ(bb)end;U=0;if b1.VectorToTarget and CustomTarget then local a8,_=aM.computeDistanceAndTime(bc,aZ/3.6,av,0,0,LastMaxBrake)if b3 and n5:len()>15000+a8+as then b0="Orbiting to Target"if as-100<=mC.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<mC.noAtmosphericDensityAltitude then b3=false end elseif b3 or n5:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bI("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;b1.VectorToTarget,b1.AutopilotAlign=false,false;aR.ToggleIntoOrbit()aR.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>b2*0.9 and as<b2*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=b2*0.99 and orbit.apoapsis.altitude>=b2*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or b3 then if b3 then BrakeIsOn=false;aR.cmdThrottle(0)mx=0;if not b1.VectorToTarget then a2="Orbit complete"bI("orCom","OB")aR.ToggleIntoOrbit()end else mD=mD+1;if mD>=2 then b3=true end end else b0="Adjusting Orbit - OrbitHeight: "..nl;mA=true;aR.cmdCruise(nn*3.6+1)local nr=b2-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(nr-be*r(utils.smoothstep(2000-nr,-2000,2000)^6*10,1,10))mx=r(VSpdPID:get(),-60,60)end end else local ns=2.75;local nt=d(A(nm*ns))local nu=nt%50;if nu>0 then nt=nt-nu+50 end;BrakeIsOn=false;if as<b2*0.8 then b0="Escaping planet gravity - OrbitHeight: "..nl;mx=utils.map(be,200,0,-15,80)elseif as>=b2*0.8 and as<b2*1.15 then b0="Approaching orbital corridor - OrbitHeight: "..nl;nt=nt*0.75;mx=utils.map(be,100,-100,-15,65)elseif as>=b2*1.15 and as<b2*1.5 then b0="Approaching orbital corridor - OrbitHeight: "..nl;nt=nt*0.75;if be<0 or mA then mx=utils.map(as,b2*1.5,b2*1.01,-30,0)else mx=utils.map(as,b2*0.99,b2*1.5,0,30)end elseif as>b2*1.5 then b0="Reentering orbital corridor - OrbitHeight: "..nl;mx=-65;local nw=utils.map(be,-150,-400,1,0.55)nt=nt*nw end;aR.cmdCruise(e(nt))end end;if mx~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local nx=mx-bk;OrbitPitchPID:inject(nx)local ny=r(OrbitPitchPID:get(),-0.5,0.5)U=ny end end;if Autopilot and ar==0 and not al then local function nz(bE,orbit)system.print(bE)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aR.cmdThrottle(0)P=false;a2=bE;bI("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;b2=as;mB=true end;aR.ToggleIntoOrbit()end end;local nA,nB=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local nC=(CustomTarget.position-ac.center):normalize()local nD=nC:project_on_plane((ac.center-bf):normalize()):normalize()local nE=ac.center+nD*(ac.radius+AutopilotTargetOrbit)local nF=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bf-nE):len()<(bf-nF):len()then nA=nE else nA=nF;AutopilotEndSpeed=0 end;AutopilotTargetCoords=nA;aR.showWayPoint(ac,AutopilotTargetCoords)nB=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;nB=true;AutopilotRealigned=true;TargetSet=true;nA=CustomTarget.position+(bf-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=nA end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local nC=(bf+bb*100000-ac.center):normalize()local nD=nC:project_on_plane((ac.center-bf):normalize()):normalize()if nD:len()<1 then nC=(bf+b8*100000-ac.center):normalize()nD=nC:project_on_plane((ac.center-bf):normalize()):normalize()end;nA=ac.center+nD*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=nA;TargetSet=true;nB=true;AutopilotRealigned=true;aR.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(nA)-bf):len()local iw,ds,dt=aL:getPlanetarySystem(0):castIntersections(bf,bb:normalize(),function(db)if db.noAtmosphericDensityAltitude>0 then return db.radius+db.noAtmosphericDensityAltitude else return db.radius+db.surfaceMaxAltitude*1.5 end end)local ix=ds;if dt~=nil and ds~=nil then ix=math.min(dt,ds)end;if ix~=nil and ix<AutopilotDistance and iw.name==ac.name then AutopilotDistance=ix end;local ng=true;local nG=(ac.center-(bf+vec3(bb):normalize()*AutopilotDistance)):len()-ac.radius;local il=c3(nG)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..il..'"}')local a8,a9;if not TurnBurn then a8,a9=mn(bc)else a8,a9=mp(bc)end;if bc>50 and AutopilotAccelerating then local n5=vec3(nA)-bf;local nH=r(math.deg(mE(b7,bb:normalize(),n5:normalize()))*bc/500,-90,90)local nI=r(math.deg(mE(b9,bb:normalize(),n5:normalize()))*bc/500,-90,90)if d(nH)<20 and d(nI)<20 then nH=nH*2;nI=nI*2 end;if d(nH)<2 and d(nI)<2 then nH=nH*2;nI=nI*2 end;local nb=-math.deg(mE(b7,b8,bb:normalize()))local nc=-math.deg(mE(b9,b8,bb:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(nI-nc)local nJ=r(apPitchPID:get(),-1,1)U=U+nJ;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(nH-nb)local nK=r(apYawPID:get(),-1,1)V=V+nK;nB=true;if d(nH)>2 or d(nI)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bI("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end end elseif AutopilotAccelerating and bc<=50 then mZ((nA-bf):normalize())end;if nG<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(nG)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local iw,ix=aR.checkLOS((AutopilotTargetCoords-bf):normalize())if ac.name~=planet.name then if iw~=nil and ac.name~=iw.name and ix<AutopilotDistance then a2="Collision with "..iw.name.." in "..c3(ix).."\nClear LOS to continue."ai=5;mT=true else mT=false;a2=""end end end;if not mT then if not AutopilotCruising and not AutopilotBraking and not nB then ng=mZ((nA-bf):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then ng=mZ(-vec3(bb):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aR.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local nL=unit.getThrottle()if AtmoSpeedAssist then nL=K end;local nM=99999;local lm=-vec3(core.getWorldAcceleration()):dot(bb:normalize())local nN=r(bb:dot((nA-bf):normalize()),0,bc)if nN>0 or lm>0 then nM=aM.computeTravelTime(nN,lm,AutopilotDistance-a8)end;if ba:len()>=MaxGameVelocity or nL==0 and P or warmup/4>nM then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bI("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aR.cmdThrottle(0)end;local nO=AutopilotDistance;if nO<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mr and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mr=bo else mr=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bI("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aR.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aR.cmdThrottle(1,true)end;local _,nn=aO(ac):escapeAndOrbitalSpeed((bf-planet.center):len()-planet.radius)local n5;if CustomTarget then n5=CustomTarget.position-bf end;if CustomTarget and CustomTarget.planetname=="Space"and bc<50 then nz("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bc<=nn and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then nz("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bI("apCir","AP")AutopilotStatus="Circularizing"end;if bc<=nn then if CustomTarget then if bb:normalize():dot(n5:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bI("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else nz("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else nz("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then nz("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nO=AutopilotDistance;if nO<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mr and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mr=bo else mr=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bI("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local nL=unit.getThrottle()if AtmoSpeedAssist then nL=K end;if nL>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end;AutopilotCruising=false end else if ng then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*b9;AutopilotShipUp=b7;AutopilotShipRight=b9 end;AutopilotRealigned=true elseif ng and not mT then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end;if not P then aR.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bI("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aR.cmdThrottle(0)P=false;ProgradeIsOn=true;al=true;aR.showWayPoint(ac,CustomTarget.position)end;if a0 then aV=true;local nI=0;local eb=bf+vec3(unit.getMasterPlayerRelativePosition())local nP=eb-bf;local nQ=vec3(nP):project_on(b8):len()local nR=vec3(nP):project_on(b9):len()local aj=y(nQ*nQ+nR*nR)mZ(nP:normalize())local jx=40;local nS=aj<jx;local nT=100;local nU=r((aj-jx)/2,10,nT)U=0;local ng=d(V)<0.1;if ng and bc<nU and not nS then BrakeIsOn=false;nI=-20 else BrakeIsOn=true;nI=0 end;local nV=0;if d(nI-bk)>nV then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(nI-bk)local nJ=pitchPID:get()U=nJ end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local nW=LastMaxBrakeInAtmo;if nW then nW=nW*r(bc/100,0.1,1)*ar else nW=LastMaxBrake end;if ar<0.01 then nW=LastMaxBrake end;local nX=b8:project_on_plane(bd):normalize():dot(bb)local nY=vec3(core.getWorldAirFrictionAcceleration())local nZ=nY:len()*av;if nX>100 then a8,a9=aM.computeDistanceAndTime(nX,100,av,0,0,nW)local n_,o0=aM.computeDistanceAndTime(100,0,av,0,0,nW*0.55)a8=a8+n_ else a8,a9=aM.computeDistanceAndTime(nX,0,av,0,0,nW*0.55)end;local nr=HoldAltitude-as-be;local o1=200+bc;if Reentry or al then minMax=2000+bc end;local o2=1;if AutoTakeoff then o2=r(bc/100,0.1,1)end;local nI=(utils.smoothstep(nr,-o1,o1)-0.5)*2*MaxPitch*o2;if not Reentry and not al and not VectorToTarget and b8:dot(bb:normalize())<0.99 then nI=(utils.smoothstep(nr,-o1*r(20-19*ar*10,1,20),o1*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*o2 end;if not AltitudeHold then nI=0 end;if LockPitch~=nil then if br and not IntoOrbit then nI=LockPitch else LockPitch=nil end end;aV=true;local o3=U;if Reentry then local o4=e(aZ)local o5,o6=aM.computeDistanceAndTime(bc,o4/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)o5=o5==-1 and 5000 or o5;local o7=as-(planet.noAtmosphericDensityAltitude+o5)local o8=as>planet.noAtmosphericDensityAltitude+o5*1.35;if o8 then nI=ReEntryPitch;if bc<=o4/3.6 and bc>o4/3.6-10 and d(bb:normalize():dot(b8))>0.9 and not bj then O=false;aR.cmdThrottle(1)end elseif bj and not o8 and not aq then aR.cmdCruise(o4,true)end;if bj then if bc>o4/3.6 and not o8 then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if be>0 then BrakeIsOn=true end;if not R then nI=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;nI=0;aV=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and o8 then aV=true elseif not o8 then if not aq and(bj or s:getTargetSpeed(axisCommandId.longitudinal)~=o4)then aR.cmdCruise(o4)end;if bc<o4/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;aV=true end end end;if bc>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then mZ(vec3(bb))end;if bp or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local n5;if bp then if type(bp)=="table"then n5=bp elseif bp<3 and bp>0 then n5=-bd:cross(bb)*5000 elseif bp>=3 then n5=bd:cross(bb)*5000 elseif bp<0 then n5=bb*25000 end elseif CustomTarget~=nil then n5=CustomTarget.position-bf else n5=ac.center-bf end;local nH=math.deg(mE(bd:normalize(),bb,n5))*2;local jA=math.rad(d(bl))if bc>minRollVelocity and ar>0.01 then local o9=1000+bc;local oa=(utils.smoothstep(nr-be*10,-o9,o9)-0.5)*2*MaxPitch;local ob=r(90-oa,0,180)aY=r(nH*2,-ob,ob)local oc=nH;nH=r(r(nH,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jA)+4*(bk-nI)*math.sin(math.rad(bl)),-YawStallAngle*0.80,YawStallAngle*0.80)local od=1;if aY~=0 then od=d(jA/aY)end;od=(90-r(d(aY-bl),0,90))/90;local oe=nI;if d(bl)>90 then oe=-oe end;nI=od*r(r(oe*math.cos(jA),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(oc)*math.sin(jA),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aY=0;nH=r(nH,-YawStallAngle*0.80,YawStallAngle*0.80)end;local of=nb-nH;if bp and d(of)<=0.0001 and(type(bp)=="table"or type(bp)~="table"and bp<0 and d(bl)<1)then if bp==-2 then aR.ToggleAltitudeHold()end;bp=nil;bI("180Off","BR")return end;if not aX and bc>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(of)local nK=r(yawPID:get(),-1,1)V=V+nK elseif aq and ao>-1 or bc<minRollVelocity then mZ(n5)elseif aX and ar>0.01 then if(nb<-YawStallAngle or nb>YawStallAngle)and ar>0.01 then mZ(bb)end;if(nc<-PitchStallAngle or nc>PitchStallAngle)and ar>0.01 then nI=r(bk-nc,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local nh=planet:getAltitude(CustomTarget.position)local o7=n5:project_on_plane(bd):len()StrongBrakes=true;if not am and not Reentry and o7<=a8 and(bb:project_on_plane(bd):normalize():dot(n5:project_on_plane(bd):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(nX<0.1 or o7<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<o7)then if not bh then bI("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bs=false end;LastDistanceToTarget=o7 end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local n5=CustomTarget.position-bf;local nh=planet:getAltitude(CustomTarget.position)local o7=y(n5:len()^2-(as-nh)^2)local nW=LastMaxBrakeInAtmo;if nW then a8,a9=aM.computeDistanceAndTime(bc,0,av,0,0,nW/2)StrongBrakes=true;if o7<=a8+bc*na/2 and bb:project_on_plane(bd):normalize():dot(n5:project_on_plane(bd):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;aR.BeginReentry()end end;LastDistanceToTarget=o7 end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not b3 and not IntoOrbit then b2=HoldAltitude;mB=true;if VectorToTarget then b1.VectorToTarget=true end;aR.ToggleIntoOrbit()VectorToTarget=false;mz=true end end;if aX and ar>0.01 and ao==-1 and bc>minRollVelocity and VectorStatus~="Finalizing Approach"then mZ(bb)nI=r(bk-nc,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end;U=o3;local mN=-1;if BrakeLanding then nI=0;local og=false;local oh=30;if aN~=nil and aN>0 then local oi=r(ar,0.4,2)local nW=LastMaxBrakeInAtmo*r(bc/100,0.1,1)*oi;local oj=aN*oi+nW-la;local ok=nW/2-la;local ol=bc-y(d(ok/2)*20/(0.5*av))*utils.sign(ok)if ol<0 then ol=0 end;local om;if bc>100 then local on,_=aM.computeDistanceAndTime(bc,100,av,0,0,nW)local oo,_=aM.computeDistanceAndTime(100,0,av,0,0,y(nW))om=on+oo else om=aM.computeDistanceAndTime(bc,0,av,0,0,y(nW))end;if om<20 then BrakeIsOn=false else local op=0;if ol>100 then local oq,_=aM.computeDistanceAndTime(ol,100,av,0,0,oj)local os,_=aM.computeDistanceAndTime(100,0,av,0,0,aN*oi+y(nW)-la)op=oq+os else op,_=aM.computeDistanceAndTime(ol,0,av,0,0,aN*oi+y(nW)-la)end;op=(op+15+bc*na)*1.1;local ot=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if ot then local nh=planet:getAltitude(CustomTarget.position)local ou=as-nh-100;local n5=CustomTarget.position-bf;local ov=y(n5:len()^2-(as-nh)^2)if ov>100 then ot=false elseif ou<=op or op==-1 then BrakeIsOn=true;og=true else BrakeIsOn=false;og=true end end;if not ot and CalculateBrakeLandingSpeed then if op>=oh then BrakeIsOn=true else BrakeIsOn=false end;og=true end end end;if not bj then aR.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;mN=ao;if mN>-1 then aV=autoRollPreference;if bc<1 or bb:normalize():dot(bd)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bI("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bb:normalize():dot(-gO)<0.999 then BrakeIsOn=true elseif be<-brakeLandingRate and not og then BrakeIsOn=true elseif not og then BrakeIsOn=false end end;if AutoTakeoff or am then local iw,dt,ds;if AutopilotTargetCoords~=nil then iw,dt,ds=aL:getPlanetarySystem(0):castIntersections(bf,(AutopilotTargetCoords-bf):normalize(),function(db)return db.radius+db.noAtmosphericDensityAltitude end)end;if bh then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aR.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(nI)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bj and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bc<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;aR.cmdThrottle(0)elseif am then aR.cmdThrottle(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(iw==nil or iw.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bj then aR.cmdThrottle(0)end;AutopilotAccelerating=true end end;local ow=ao>-1;local ox=bk;if(VectorToTarget or am or bp)and not ow and bc>minRollVelocity and ar>0.01 then local jA=math.rad(d(bl))ox=bk*d(math.cos(jA))+nc*math.sin(jA)end;local oy=r(nI-ox,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then oy=r(nI-ox,-85,MaxPitch)elseif ar<0.01 then oy=r(nI-ox,-MaxPitch,MaxPitch)end;if d(bl)<5 or VectorToTarget or bp or BrakeLanding or ow or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(oy)local nJ=pitchPID:get()U=U+nJ end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function mm.ToggleIntoOrbit()b3=false;mx=nil;my=nil;mD=0;if ar==0 then if IntoOrbit then bI("orOff","AP")IntoOrbit=false;mz=false;mC=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mB=false elseif br then bI("orOn","AP")IntoOrbit=true;aV=true;if mC==nil then mC=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;mz=false;mC=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mB=false end end;function mm.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aV=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aR.cmdCruise(e(aZ))end else b3=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function mm.checkLOS(m_)local iw,ds,dt=aL:getPlanetarySystem(0):castIntersections(bf,m_,function(db)if db.noAtmosphericDensityAltitude>0 then return db.radius+db.noAtmosphericDensityAltitude else return db.radius+db.surfaceMaxAltitude*1.5 end end)local ix=ds;if dt~=nil and ds~=nil then ix=math.min(dt,ds)end;if ix~=nil then return iw,ix else return nil,nil end end;function mm.ToggleAutopilot()local function oz(SpaceTarget)bs=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aR.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if E-mw<1.5 and ar>0 then if not b6 then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bI("orH","OH")end;mw=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else mw=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aQ.UpdateAutopilotTarget()aR.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bI("apSpc","AP")if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bI("vtt","AP")oz(SpaceTarget)end else bI("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then b3=false;Autopilot=true elseif not aq then if IntoOrbit then aR.ToggleIntoOrbit()end;b2=planet.noAtmosphericDensityAltitude+LowOrbitHeight;mB=true;b1.AutopilotAlign=true;b1.VectorToTarget=true;mz=false;if not IntoOrbit then aR.ToggleIntoOrbit()end end end else bI("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and br)and not IntoOrbit then WaypointSet=false;b3=false;mz=false;aR.ToggleIntoOrbit()else bI("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bI("apP","AP")am=true;aR.ToggleAltitudeHold()end else bI("apOff","AP")aR.ResetAutopilots(1)end end;function mm.cmdThrottle(cB,oA)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not oA then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cB)K=r(A(cB*100,0)/100,-1,1)bi=nil end;function mm.cmdCruise(cB,oA)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not oA then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cB)bi=cB end;function mm.ToggleLockPitch()if LockPitch==nil then bI("lkPOn","LP")if not a1 then LockPitch=bk else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bI("lkPOff","LP")LockPitch=nil end end;function mm.ToggleAltitudeHold()if E-mv<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bI("11","EP")else if br then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b2=HoldAltitude;mB=true;if not IntoOrbit then aR.ToggleIntoOrbit()end;mz=true end end;mv=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else mv=E end;if br and ar==0 then b2=as;mB=true;mz=true;aR.ToggleIntoOrbit()if IntoOrbit then mv=E else mv=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;aV=true;LockPitch=nil;b3=false;if ao~=-1 and bc<20 then bI("lfs","LS")AutoTakeoff=true;if mv>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bg then aR.ToggleVerticalTakeoff()end else bI("altOn","AH")AutoTakeoff=false;if mv>-1 then if br then HoldAltitude=as end end;if VertTakeOff then aR.ToggleVerticalTakeoff()end end;if am then HoldAltitude=100000 end else bI("altOff","AH")if IntoOrbit then aR.ToggleIntoOrbit()end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;aV=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;mv=0 end end;function mm.ResetAutopilots(mm)if mm then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bp=nil;if not bh then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;if IntoOrbit then aR.ToggleIntoOrbit()end;aV=autoRollPreference;al=false;an=false;af=0 end;function mm.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aV=autoRollPreference end;if BrakeIsOn then bI("bkOn","B",1)aR.ResetAutopilots()else bI("bkOff","B",1)end end;function mm.BeginReentry()if Reentry then a2="Re-Entry cancelled"bI("reOff","RE")Reentry=false;aV=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;aV=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aZ;bI("par","RE")else Reentry=true;AltitudeHold=true;aV=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bY=c3(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..aZ.." Target Altitude: "..bY;bI("glide","RE")aR.cmdCruise(e(aZ))end;AutoTakeoff=false end;function mm.ToggleAntigrav()if antigrav and not ExternalAGG then if bh then bI("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bI("aggOn","AG")antigrav.activate()antigrav.show()end end end;ao=mI()return mm end;function script.onStart()local oB=false;local function oC()local function oD(oE)local oF=dbHud_1.hasKey;for cf,cg in pairs(oE)do if oF(cg)then local cw=g(dbHud_1.getStringValue(cg))if cw~=nil then _G[cg]=cw;oB=true end end end end;if dbHud_1 then if not useTheseSettings then oD(bO())coroutine.yield()oD(c)else oD(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;oB=false end;coroutine.yield()if oB then a2="Loaded Saved Variables"aD=ResolutionX;aE=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aV=autoRollPreference;aZ=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function oG()local function oH(oI,oJ)if oI>oJ then oJ=oI end;local oK,oL=0,0;if ContainerOptimization>0 then oK=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then oL=FuelTankOptimization*0.05 end;oJ=oJ*(1-(oK+oL))return oJ end;local oM=core.getElementNameById;local oN=fuelX~=0 and fuelY~=0;for cf in pairs(at)do local type=core.getElementTypeById(at[cf])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cf])),'^.*vertical.*$')and core.getElementForwardById(at[cf])[3]>0 then bg=true end end;if o(type,'^.*Space Engine$')then b6=true;if o(tostring(core.getElementTagsById(at[cf])),'^.*vertical.*$')then local oO=core.getElementForwardById(at[cf])if oO[3]<0 then b4=true else b5=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local oP=j(at[cf])if oP>10000 then G=110 elseif oP>1000 then G=55 elseif oP>150 then G=27 end end;aI=aI+j(at[cf])if oN and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local oP=j(at[cf])local li=l(at[cf])local oI=0;local gA=q()if type=="Atmospheric Fuel Tank"then local oJ=400;local oQ=35.03;if oP>10000 then oJ=51200;oQ=5480 elseif oP>1300 then oJ=6400;oQ=988.67 elseif oP>150 then oJ=1600;oQ=182.67 end;oI=li-oQ;if fuelTankHandlingAtmo>0 then oJ=oJ+oJ*fuelTankHandlingAtmo*0.2 end;oJ=oH(oI,oJ)aF[#aF+1]={at[cf],oM(at[cf]),oJ,oQ,oI,gA}end;if type=="Rocket Fuel Tank"then local oJ=320;local oQ=173.42;if oP>65000 then oJ=40000;oQ=25740 elseif oP>6000 then oJ=5120;oQ=4720 elseif oP>700 then oJ=640;oQ=886.72 end;oI=li-oQ;if fuelTankHandlingRocket>0 then oJ=oJ+oJ*fuelTankHandlingRocket*0.1 end;oJ=oH(oI,oJ)aH[#aH+1]={at[cf],oM(at[cf]),oJ,oQ,oI,gA}end;if type=="Space Fuel Tank"then local oJ=600;local oQ=35.03;if oP>10000 then oJ=76800;oQ=5480 elseif oP>1300 then oJ=9600;oQ=988.67 elseif oP>150 then oJ=2400;oQ=182.67 end;oI=li-oQ;if fuelTankHandlingSpace>0 then oJ=oJ+oJ*fuelTankHandlingSpace*0.2 end;oJ=oH(oI,oJ)aG[#aG+1]={at[cf],oM(at[cf]),oJ,oQ,oI,gA}end end end;if not bg then VertTakeOff,VertTakeOffEngine=false,false end end;local function oR()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cg in pairs(door)do cg.toggle()end end;if switch then for _,cg in pairs(switch)do cg.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cg in pairs(forcefield)do cg.toggle()end end;if antigrav then bh=antigrav.getState()==1;if bh and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and ba:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(aW)if aq and ao~=-1 then aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function oS()local oT={}local function oU()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local oV={[1]=4480,[6]=4480,[7]=6270}for oW,oX in pairs(b)do b[oW][0]=oU()b[oW][0].systemId=oW;oT[oW]={}for oY,planet in pairs(b[oW])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=oV[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=oW;planet.bodyId=planet.id;oT[oW][oY]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bB[#bB+1]=planet end end end;aK=ch()aL=aK(oT)aM=dG()aO=e9()aQ=m4()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})oC()coroutine.yield()oG()coroutine.yield()aR=ml()oR()coroutine.yield()oS()aS=ex()aP=fK()aP.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bu[1]=nil;if radar_1 then bu[1]=radar_1;aS.pickType()end;bI("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cg in pairs(door)do cg.toggle()end end;if switch then for _,cg in pairs(switch)do cg.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cg in pairs(forcefield)do cg.toggle()end end;showHud=bD;cb()if button then button.activate()end;if SetWaypointOnExit then aR.showWayPoint(planet,bf)end;bI("stop","SU")end;function script.onTick(oZ)local o_=nil;if oZ=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bI("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif oZ=="tenthSecond"then local function p0()local p1=system.createData;local p2=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=p2(panelInterplanetary,"value")interplanetaryHeaderText=p1('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=p2(panelInterplanetary,"value")widgetDistanceText=p1('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=p2(panelInterplanetary,"value")widgetTravelTimeText=p1('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=p2(panelInterplanetary,"value")widgetMaxMassText=p1('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=p2(panelInterplanetary,"value")widgetTargetOrbitText=p1('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=p2(panelInterplanetary,"value")widgetCurBrakeDistanceText=p1('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=p2(panelInterplanetary,"value")widgetCurBrakeTimeText=p1('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=p2(panelInterplanetary,"value")widgetMaxBrakeDistanceText=p1('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=p2(panelInterplanetary,"value")widgetMaxBrakeTimeText=p1('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=p2(panelInterplanetary,"value")widgetTrajectoryAltitudeText=p1('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function p3()t(panelInterplanetary)panelInterplanetary=nil end;local function p4()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bf):len()else AutopilotDistance=(CustomTarget.position-bf):len()end end;local e7=bc;local nL=unit.getThrottle()/100;if AtmoSpeedAssist then nL=K end;local p5,p6=aM.computeDistanceAndTime(bc,MaxGameVelocity,av,a:maxForceForward()*nL,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,p7;if not TurnBurn and e7>0 then _,p7=aR.GetAutopilotBrakeDistanceAndTime(e7)else _,p7=aR.GetAutopilotTBBrakeDistanceAndTime(e7)end;local p8=0;local p9=0;if AutopilotCruising or not Autopilot and e7>5 then p9=aM.computeTravelTime(e7,0,AutopilotDistance)elseif a8+p5<AutopilotDistance then p8=AutopilotDistance-(a8+p5)p9=aM.computeTravelTime(8333.0556,0,p8)else local pa=(AutopilotDistance-a8)/p5;p5=AutopilotDistance-a8;p6=p6*pa end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return p9 elseif AutopilotBraking then return p7 elseif AutopilotCruising then return p9+p7 else return p6+a9+p9 end end;local function pb(la,pc)if la==nil then la=core.g()end;la=A(la,5)if pc~=nil and pc or(o_==nil or o_~=la)then local e7=ba:len()local pd=g(unit.getData()).maxBrake;if pd~=nil and pd>0 and aq then pd=pd/r(e7/100,0.1,1)pd=pd/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+pd)/2 else LastMaxBrakeInAtmo=pd end end end;if pd~=nil and pd>0 then LastMaxBrake=pd end;o_=la end end;pb(nil,true)if bi~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bi then aR.cmdCruise(bi)else bi=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then p0()end;if AutopilotTargetName~=nil then local pe=CustomTarget~=nil;local pf=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()pf=pf>1000000 and A(pf/1000000,2).." kTons"or A(pf/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=p4()if pe and not Autopilot then aj=(bf-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bf):len()end;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local il=c3(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..il..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..c6(travelTime)..'", "unit":""}')il=c3(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..il..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..c6(a9)..'", "unit":""}')il=c3(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..il..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..c6(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",pf)..'", "unit":""}')il=c3(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..il..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bj and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then aR.cmdThrottle(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else p3()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aP.TenthTick()elseif oZ=="oneSecond"then local function pg(gK)local ph=0;aB=""local pi=aI;local pj=0;local pk=0;local pl=0;local gE=0;local gF=""local pm=core.getElementHitPointsById;for cf in pairs(at)do local oP=0;local pn=0;pn=j(at[cf])oP=pm(at[cf])pj=pj+oP;if oP<pn then if oP==0 then pl=pl+1 else pk=pk+1 end;if aJ and#aA==0 then position=vec3(core.getElementPositionById(at[cf]))local bW=position.x;local bX=position.y;local f1=position.z;table.insert(aA,core.spawnArrowSticker(bW,bX,f1+1,"down"))table.insert(aA,core.spawnArrowSticker(bW,bX,f1+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(bW+1,bX,f1,"north"))table.insert(aA,core.spawnArrowSticker(bW+1,bX,f1,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(bW-1,bX,f1,"south"))table.insert(aA,core.spawnArrowSticker(bW-1,bX,f1,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(bW,bX-1,f1,"east"))table.insert(aA,core.spawnArrowSticker(bW,bX-1,f1,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(bW,bX+1,f1,"west"))table.insert(aA,core.spawnArrowSticker(bW,bX+1,f1,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cf])end elseif aJ and#aA>0 and aA[11]==at[cf]then for gz in pairs(aA)do core.deleteSticker(aA[gz])end;aA={}end end;ph=e(pj/pi*100)if ph<100 then gK[#gK+1]=bV(0,0,"","pbright txt")gE=e(ph*2.55)gF=f("rgb(%d,%d,%d)",255-gE,gE,0)if ph<100 then gK[#gK+1]=bV("50%",1035,"Elemental Integrity: "..ph.."%","txtbig txtmid","fill:"..gF)if pl>0 then gK[#gK+1]=bV("50%",1055,"Disabled Modules: "..pl.." Damaged Modules: "..pk,"txtbig txtmid","fill:"..gF)elseif pk>0 then gK[#gK+1]=bV("50%",1055,"Damaged Modules: "..pk,"txtbig txtmid","fill:"..gF)end end end end;local function po()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bz=core.getPlayersOnBoard()bA=core.getDockedConstructs()po()local gK={}aP.OneSecond(gK)if ShouldCheckDamage then pg(gK)end;ak=table.concat(gK,"")collectgarbage("collect")elseif oZ=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cw=g(dbHud_1.getStringValue("SavedLocations"))if cw~=nil then _G["SavedLocations"]=cw;local fk=-1;local mh;for cf,cg in pairs(SavedLocations)do if cg.name and cg.name=="SatNav Location"then fk=cf;break end end;if fk~=-1 then mh=SavedLocations[fk]fk=-1;for cf,cg in pairs(b[0])do if cg.name and cg.name=="SatNav Location"then fk=cf;break end end;if fk>-1 then b[0][fk]=mh end;aQ.UpdateAtlasLocationsList()a2=mh.name.." position updated"end end;for i=1,#bm do if bm[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bm[i].name)aQ.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif oZ=="msgTick"then local gK={}aP.DisplayMessage(gK,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif oZ=="animateTick"then aU=true;aT=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif oZ=="hudTick"then aP.hudtick()elseif oZ=="apTick"then aR.APTick()elseif oZ=="radarTick"then aS.UpdateRadar()elseif oZ=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function pp(pq,nU)local pr=vec3()local ps=vec3()if pq==axisCommandId.longitudinal then pr=vec3(core.getConstructOrientationForward())ps=b8 elseif pq==axisCommandId.vertical then pr=vec3(core.getConstructOrientationUp())ps=b7 elseif pq==axisCommandId.lateral then pr=vec3(core.getConstructOrientationRight())ps=b9 else return vec3()end;local pt=vec3(core.getWorldGravity())local pu=pt:dot(ps)local pv=vec3(core.getWorldAirFrictionAcceleration())local pw=pv:dot(ps)local px=ba:dot(pr)local py=nU*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(py-px)local pz=targetSpeedPID2:get()local pA=(pz-pw-pu)*ps;return pA end;local function pB(pq,nU)local pr=vec3()local ps=vec3()if pq==axisCommandId.longitudinal then pr=vec3(core.getConstructOrientationForward())ps=b8 elseif pq==axisCommandId.vertical then pr=vec3(core.getConstructOrientationUp())ps=b7 elseif pq==axisCommandId.lateral then pr=vec3(core.getConstructOrientationRight())ps=b9 else return vec3()end;local pt=vec3(core.getWorldGravity())local pu=pt:dot(ps)local pv=vec3(core.getWorldAirFrictionAcceleration())local pw=pv:dot(ps)local px=ba:dot(pr)local py=nU*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(py-px)local pz=targetSpeedPID:get()local pA=(pz-pw-pu)*ps;return pA end;local function pC(pD,gN,m9)local pE=pD:cross(m9):normalize_inplace()local hz=math.acos(r(pE:dot(-gN),-1,1))*constants.rad2deg;if pE:cross(-gN):dot(m9)<0 then hz=-hz end;return hz end;if antigrav and not ExternalAGG then if not bh and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bj=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bj and O then aR.cmdThrottle(0)O=false elseif not bj and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local pF=r(T+U+system.getControlDeviceForwardInput(),-1,1)local pG=r(W+Z+system.getControlDeviceYawInput(),-1,1)local pH=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local pI=Y;bd=vec3(core.getWorldVertical())if bd==nil or bd:len()==0 then bd=(planet.center-bf):normalize()end;b7=vec3(core.getConstructWorldOrientationUp())b8=vec3(core.getConstructWorldOrientationForward())b9=vec3(core.getConstructWorldOrientationRight())bb=vec3(core.getWorldVelocity())ba=vec3(core.getVelocity())bf=vec3(core.getConstructWorldPos())av=core.getConstructMass()bc=vec3(bb):len()be=-bd:dot(bb)bl=getRoll(bd,b8,b9)local pJ=bl/180*math.pi;local pK=math.cos(pJ)local pL=math.sin(pJ)bk=pC(bd,b8,b9*pK+b7*pL)local pM=bb:normalize()local pN=d(bl)local pO=utils.sign(bl)local pP=vec3(core.getWorldAngularVelocity())local pQ=pF*pitchSpeedFactor*b9+pG*rollSpeedFactor*b8+pH*yawSpeedFactor*b7;if aV==true and bd:len()>0.01 then local pR=d(aY-bl)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and pR>0 or ar>0.0 and pR<autoRollRollThreshold and autoRollPreference)and pG==0 and d(bk)<85 then local pS=aY;local pT=autoRollFactor;if ar==0 then pT=pT/4;aY=0;pS=0 end;if rollPID==nil then rollPID=pid.new(pT*0.01,0,pT*0.1)end;rollPID:inject(pS-bl)local pU=rollPID:get()pQ=pQ+pU*b8 end end;local pV=1;local pW=0;local pX=1;local pY=system.getMouseWheel()if pY>0 then bF()elseif pY<0 then bF(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bj then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aZ/3.6-bb:dot(b8))local pZ=throttlePID:get()N=r(pZ,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-aZ/3.6)local p_=r(brakePID:get(),0,1)if ar>0 and be<-80 or ar>0.005 then L=p_ end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local q0=''local q1=vec3()local q2=pp(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",q2,pW)local q3='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then q3=q3 ..ExtraLongitudeTags end;local q4=s:getAxisCommandType(axisCommandId.longitudinal)local q5=s:composeAxisAccelerationFromThrottle(q3,axisCommandId.longitudinal)local q6=pB(axisCommandId.lateral,LeftAmount*1000)q0=q0 ..' , '.."lateral airfoil , lateral ground "q1=q1+q6;if q1:len()>constants.epsilon then a:setEngineForceCommand(q0,q1,pW,'','','',pX)end;a:setEngineForceCommand(q3,q5,pV)local q7='thrust analog vertical fueled 'local q8='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then q8=q8 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then q7=q7 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(q7,q2,pV)else a:setEngineForceCommand(q7,vec3(),pV)end;if LeftAmount~=0 then a:setEngineForceCommand(q8,q6,pV)else a:setEngineForceCommand(q8,vec3(),pV)end;if pI==0 then pI=L end;local q9=-pI*(brakeSpeedFactor*bb+brakeFlatFactor*pM)a:setEngineForceCommand('brake',q9)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local nU=unit.getAxisCommandValue(0)if not bj then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-nU/3.6)local p_=r(brakePID:get(),0,1)pI=r(pI+p_,0,1)end;local q9=-pI*(brakeSpeedFactor*bb+brakeFlatFactor*pM)a:setEngineForceCommand('brake',q9)local q0=''local q1=vec3()local qa=false;local q3='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then q3=q3 ..ExtraLongitudeTags end;local q4=s:getAxisCommandType(axisCommandId.longitudinal)if q4==axisCommandType.byThrottle then local q5=s:composeAxisAccelerationFromThrottle(q3,axisCommandId.longitudinal)a:setEngineForceCommand(q3,q5,pV)elseif q4==axisCommandType.byTargetSpeed then local q5=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)q0=q0 ..' , '..q3;q1=q1+q5;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then qa=true end end;local q8='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then q8=q8 ..ExtraLateralTags end;local qb=s:getAxisCommandType(axisCommandId.lateral)if qb==axisCommandType.byThrottle then local qc=s:composeAxisAccelerationFromThrottle(q8,axisCommandId.lateral)a:setEngineForceCommand(q8,qc,pV)elseif qb==axisCommandType.byTargetSpeed then local q6=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)q0=q0 ..' , '..q8;q1=q1+q6 end;local q7='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then q7=q7 ..ExtraVerticalTags end;local qd=s:getAxisCommandType(axisCommandId.vertical)if qd==axisCommandType.byThrottle then local q2=s:composeAxisAccelerationFromThrottle(q7,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(q7,q2,pV,'airfoil','ground','',pX)else a:setEngineForceCommand(q7,vec3(),pV)a:setEngineForceCommand('airfoil vertical',q2,pV,'airfoil','','',pX)a:setEngineForceCommand('ground vertical',q2,pV,'ground','','',pX)end elseif qd==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),pV)end;local qe=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)q0=q0 ..' , '..q7;q1=q1+qe end;if q1:len()>constants.epsilon then if Y~=0 or qa or d(pM:dot(b8))<0.5 then q0=q0 ..', brake'end;a:setEngineForceCommand(q0,q1,pW,'','','',pX)end end;local qf=torqueFactor*(pQ-pP)local qg=vec3(core.getWorldAirFrictionAngularAcceleration())qf=qf-qg;a:setEngineTorqueCommand('torque',qf,pV,'airfoil','','',pX)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local e7=ba:len()local qh=0.15;if not bj then local qi=s:getTargetSpeed(axisCommandId.longitudinal)if e7*3.6>qi*(1-qh)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e7*3.6<qi*(1-qh)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nL=unit.getThrottle()if AtmoSpeedAssist then nL=K*100 end;local nU=nL/100;if k==0 then nU=nU*MaxGameVelocity;if e7>=nU*(1-qh)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e7<nU*(1-qh)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local o4=e(aZ)nU=nU*o4/3.6;if e7>=nU*(1-qh)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e7<nU*(1-qh)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fH=coroutine.status(beginSetup)if fH=="suspended"then local cB,fI=coroutine.resume(beginSetup)if fI then system.print("ERROR STARTUP: "..fI)end elseif fH=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aT and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(qj)local function qk(bG)local D=1;local function ql(qm,bG)local qn={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local qo=qm;for _,cg in ipairs(qn)do if bG and qo>cg then qm=cg elseif qm<cg and not bG then qm=cg;break end end;return qm end;if bG then D=-1 end;if not ExternalAGG and bh then if a1 and bG then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then b2=ql(b2,bG)else b2=b2+D*a3 end;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=ql(HoldAltitude,bG)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function qp(qq)if not aq then a2="Flight Assist in Atmo only"return end;local cm=type(qq)if bp==nil then if cm=="table"then if Autopilot or VectorToTarget then aR.ToggleAutopilot()end;bI("180On","BR")elseif qq==1 then bI("bnkLft","BR")else bI("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aR.ToggleAltitudeHold()if cm~="table"then qq=qq+1 end end;bp=qq else bI("180Off","BR")bp=nil end end;if qj=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aR.cmdThrottle(0)if vBooster or hover then if aq and ao==-1 then bI("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aV=true;GearExtended=false else if S then bI("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bI("grOut","LG",1)a.control.extendLandingGears()end else if S then bI("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif qj=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif qj=="forward"then T=T-1 elseif qj=="backward"then if AltIsOn then qp(-bb*5000)else T=T+1 end elseif qj=="left"then if AltIsOn then qp(1)else W=W-1 end elseif qj=="right"then if AltIsOn then qp(3)else W=W+1 end elseif qj=="yawright"then X=X-1 elseif qj=="yawleft"then X=X+1 elseif qj=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif qj=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif qj=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif qj=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif qj=="groundaltitudeup"then qk()elseif qj=="groundaltitudedown"then qk(true)elseif qj=="option1"then toggleView=false;if AltIsOn and a1 then local qr=""for i=1,#bz do qr=qr.."| Name: "..system.getPlayerName(bz[i]).." Mass: "..A(core.getBoardedPlayerMass(bz[i])/1000,1).."t "end;system.print("Onboard: "..qr)return end;aQ.adjustAutopilotTargetIndex()elseif qj=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bz do core.forceDeboard(bz[i])end;a2="Deboarded All Passengers"return end;aQ.adjustAutopilotTargetIndex(1)elseif qj=="option3"then local function qs()aC=not aC;if not aC then bI("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bI("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local qr=""for i=1,#bA do qr=qr.."| ID: "..bA[i].." Mass: "..A(core.getDockedConstructMass(bA[i])/1000,1).."t "end;system.print("Docked Ships: "..qr)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;qs()toggleView=false elseif qj=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#bA do core.forceUndock(bA[i])end;a2="Undocked all ships"return end;bp=nil;aR.ToggleAutopilot()elseif qj=="option5"then toggleView=false;aR.ToggleLockPitch()elseif qj=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local qt=shield_1.getVentingCooldown()if qt>0 then a2="Cannot vent again for "..qt.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aR.ToggleAltitudeHold()elseif qj=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif qj=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bI("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bI("gsOn","GS")end;toggleView=false elseif qj=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aR.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bI("gyOn","GA")else bI("gyOff","GA")end end;toggleView=false elseif qj=="lshift"then bw=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;aU=false;aT=false end elseif qj=="brake"then if BrakeToggleStatus or AltIsOn then aR.BrakeToggle()elseif not BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=true end elseif qj=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif qj=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif qj=="stopengines"then local function qu()if E-F<1.5 then bI("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bp=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;aV=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;qu()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aR.cmdThrottle(0)else aR.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then aR.cmdCruise(AtmoSpeedLimit)else aR.cmdCruise(MaxGameVelocity*3.6)end end end elseif qj=="speedup"then bF()elseif qj=="speeddown"then bF(true)elseif qj=="antigravity"and not ExternalAGG then if antigrav~=nil then aR.ToggleAntigrav()end end end;function script.onActionStop(qj)local function qv()if not ExternalAGG and bh then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if qj=="forward"then T=0 elseif qj=="backward"then T=0 elseif qj=="left"then if bp then if bp==2 then bp=-2 else bp=-1 end end;W=0 elseif qj=="right"then if bp then if bp==4 then bp=-2 else bp=-1 end end;W=0 elseif qj=="yawright"then X=0 elseif qj=="yawleft"then X=0 elseif qj=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif qj=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif qj=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qj=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qj=="groundaltitudeup"then qv()toggleView=false elseif qj=="groundaltitudedown"then qv()toggleView=false elseif qj=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then aU=false;aT=false end;a1=false elseif qj=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=false end end elseif qj=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(qj)local function qw(bG)local D=1;if bG then D=-1 end;if not ExternalAGG and bh then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then b2=b2+D*a5;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function qx(bG)local D=1;if bG then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if qj=="groundaltitudeup"then if not a1 then qw()end elseif qj=="groundaltitudedown"then if not a1 then qw(true)end elseif qj=="speedup"then qx()elseif qj=="speeddown"then qx(true)end end;function script.onInputText(bY)local function qy(qz,eb,hv)local function qA(eb)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu='::pos{'..B..','..B..','..B..','..B..','..B..'}'local cI,cJ,cP,cQ,cR=o(eb,cu)if cI=="0"and cJ=="0"then return vec3(z(cP),z(cQ),z(cR))end;cQ=math.rad(cQ)cP=math.rad(cP)local planet=b[z(cI)][z(cJ)]local dD=math.cos(cP)local qB=vec3(dD*math.cos(cQ),dD*math.sin(cQ),math.sin(cP))return planet.center+(planet.radius+cR)*qB end;local position=qA(eb)return aQ.AddNewLocation(qz,position,hv)end;local i;local qC,qD=nil,nil;local qE="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(bY," ")qC=bY;if i~=nil then qC=string.sub(bY,0,i-1)qD=string.sub(bY,i+1)end;if qC=="/help"or qC=="/commands"then for lr in string.gmatch(qE,"([^\n]+)")do system.print(lr)end;return elseif qC=="/setname"then if qD==nil or qD==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aQ.UpdatePosition(qD)else a2="Select a saved target to rename first"end elseif shield_1 and qC=="/resist"then if qD==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu=B..', '..B..', '..B..', '..B;local qF,qG,qH,qI=o(qD,cu)if qI==nil or qF+qG+qH+qI>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(qF,qG,qH,qI)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif qC=="/addlocation"or string.find(bY,"::pos")~=nil then local hv=false;local qz="0-Temp"if qD==nil or qD==""then qD=qC;hv=true end;i=string.find(qD,"::")if not hv then qz=string.sub(qD,1,i-2)end;local eb=string.sub(qD,i)qy(qz,eb,hv)elseif qC=="/agg"then if qD==nil or qD==""then a2="Usage: /agg targetheight"return end;qD=z(qD)if qD<1000 then qD=1000 end;AntigravTargetAltitude=qD;a2="AGG Target Height set to "..qD elseif qC=="/G"then if qD==nil or qD==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if qD=="dump"then for cf,cg in pairs(bO())do if type(_G[cg])=="boolean"then if _G[cg]==true then system.print(cg.." true")else system.print(cg.." false")end elseif _G[cg]==nil then system.print(cg.." nil")else system.print(cg.." ".._G[cg])end end;return end;i=string.find(qD," ")local qJ=string.sub(qD,0,i-1)local qK=string.sub(qD,i+1)for cf,cg in pairs(bO())do if cg==qJ then a2="Variable "..qJ.." changed to "..qK;local qL=type(_G[cg])if qL=="number"then qK=z(qK)if cg=="AtmoSpeedLimit"then aZ=qK end elseif qL=="boolean"then if string.lower(qK)=="true"then qK=true else qK=false end end;_G[cg]=qK;return end end;a2="No such global variable: "..qJ elseif qC=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aQ.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif qC=="/copydatabank"then if dbHud_2 then cb(true)else a2="Spare Databank required to copy databank"end elseif qC=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aR.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(cJ)if bu[1]and not aq and not bn then unit.setTimer("contact",0.1)end end;function script.onLeave(cJ)if bu[1]and CollisionSystem then if#bq>650 then cJ=tostring(cJ)bq[cJ]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
