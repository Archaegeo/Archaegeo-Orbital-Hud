name: ArchHud - Archaegeo v1.595 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        require("autoconf/custom/archhud/globals")local a=Navigator.new(system,core,unit)local b=require("atlas")navGlobal=a;atlasGlobal=b;coreGlobal=core;unitGlobal=unit;systemGlobal=system;vBoosterGlobal=vBooster;hoverGlobal=hover;telmeter_1Global=telemeter_1;radar_1Global=radar_1;radar_2Global=radar_2;antigravGlobal=antigrav;shield_1Global=shield_1;require("autoconf/custom/archhud/hudclass")require("autoconf/custom/archhud/apclass")script={}VERSION_NUMBER=1.595;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}mabs=math.abs;mfloor=math.floor;stringf=string.format;jdecode=json.decode;jencode=json.encode;eleMaxHp=core.getElementMaxHitPointsById;atmosphere=unit.getAtmosphereDensity;eleMass=core.getElementMassById;isRemote=a.control.isRemoteControlled;atan=math.atan;stringmatch=string.match;systime=system.getTime;uclamp=utils.clamp;navCom=a.axisCommandManager;sysDestWid=system.destroyWidgetPanel;sysUpData=system.updateData;sysAddData=system.addDataToWidget;sysLockVw=system.lockView;sysIsVwLock=system.isViewLocked;msqrt=math.sqrt;tonum=tonumber;function round(d,e)local f=10^(e or 0)return mfloor(d*f+0.5)/f end;time=systime()clearAllCheck=systime()coreHalfDiag=13;PrimaryR=SafeR;PrimaryB=SafeB;PrimaryG=SafeG;PlayerThrottle=0;brakeInput2=0;ThrottleLimited=false;calculatedThrottle=0;WasInCruise=false;apThrottleSet=false;minAutopilotSpeed=55;reentryMode=false;hasGear=false;pitchInput=0;pitchInput2=0;yawInput2=0;rollInput=0;yawInput=0;brakeInput=0;rollInput2=0;followMode=false;holdingShift=false;msgText="empty"holdAltitudeButtonModifier=5;antiGravButtonModifier=5;currentHoldAltModifier=holdAltitudeButtonModifier;currentAggModifier=antiGravButtonModifier;isBoosting=false;brakeDistance=0;brakeTime=0;maxBrakeDistance=0;maxBrakeTime=0;autopilotTargetPlanet=nil;totalDistanceTrip=0;flightTime=0;upAmount=0;simulatedX=0;simulatedY=0;msgTimer=3;distance=0;lastOdometerOutput=""spaceLand=false;spaceLaunch=false;finalLand=false;abvGndDet=-1;myAutopilotTarget=""inAtmo=atmosphere()>0;atmosDensity=atmosphere()coreAltitude=core.getAltitude()elementsID=core.getElementIdList()lastTravelTime=systime()coreMass=core.getConstructMass()mousePause=false;gyroIsOn=nil;rgb=[[rgb(]]..mfloor(PrimaryR+0.5)..","..mfloor(PrimaryG+0.5)..","..mfloor(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..mfloor(PrimaryR*0.9+0.5)..","..mfloor(PrimaryG*0.9+0.5)..","..mfloor(PrimaryB*0.9+0.5)..[[)]]markers={}previousYawAmount=0;previousPitchAmount=0;damageMessage=""UnitHidden=true;Buttons={}resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;atmoTanks={}spaceTanks={}rocketTanks={}eleTotalMaxHp=0;repairArrows=false;MapXRatio=nil;MapYRatio=nil;YouAreHere=nil;PlanetaryReference=nil;galaxyReference=nil;Kinematic=nil;maxKinematicUp=nil;Kep=nil;HUD=nil;ATLAS=nil;AP=nil;RADAR=nil;Animating=false;Animated=false;autoRoll=autoRollPreference;targetGroundAltitude=LandingGearGroundHeight;stalling=false;lastApTickTime=systime()targetRoll=0;ahDoubleClick=0;apDoubleClick=0;adjustedAtmoSpeedLimit=AtmoSpeedLimit;VtPitch=0;orbitMsg=nil;orbitPitch=0;orbitRoll=0;orbitAligned=false;orbitalRecover=false;orbitalParams={VectorToTarget=false}OrbitTargetSet=false;OrbitTargetOrbit=0;OrbitTargetPlanet=nil;OrbitAchieved=false;SpaceEngineVertUp=false;SpaceEngineVertDn=false;SpaceEngines=false;OrbitTicks=0;constructUp=vec3(core.getConstructWorldOrientationUp())constructForward=vec3(core.getConstructWorldOrientationForward())constructRight=vec3(core.getConstructWorldOrientationRight())coreVelocity=vec3(core.getVelocity())constructVelocity=vec3(core.getWorldVelocity())velMag=vec3(constructVelocity):len()worldVertical=vec3(core.getWorldVertical())vSpd=-worldVertical:dot(constructVelocity)worldPos=vec3(core.getConstructWorldPos())soundAlarm=0;UpVertAtmoEngine=false;antigravOn=false;setCruiseSpeed=nil;throttleMode=true;adjustedPitch=0;adjustedRoll=0;showSettings=false;settingsVariables={}oldShowHud=showHud;AtlasOrdered={}notPvPZone=false;pvpDist=50000;pipeMessage=""ReversalIsOn=nil;contacts={}nearPlanet=unit.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;collisionAlertStatus=false;collisionTarget=nil;radars={}rType="Atmo"apButtonsHovered=false;apScrollIndex=0;TabButtons={}function p(g)system.print(time..": "..g)end;function changeSpd(h)local f=1;if h then f=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn and mousePause then local j=PlayerThrottle;PlayerThrottle=round(uclamp(PlayerThrottle+f*speedChangeLarge/100,-1,1),2)if PlayerThrottle>=0 and j<0 then PlayerThrottle=0;mousePause=false end elseif AltIsOn then if atmosDensity>0 or Reentry then adjustedAtmoSpeedLimit=uclamp(adjustedAtmoSpeedLimit+f*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=uclamp(MaxGameVelocity+f*speedChangeLarge/3.6*100,0,8333.00)end else navCom:updateCommandFromActionStart(axisCommandId.longitudinal,f*speedChangeLarge)end else if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then apScrollIndex=apScrollIndex+1*f*-1;if apScrollIndex>#AtlasOrdered then apScrollIndex=1 end;if apScrollIndex<1 then apScrollIndex=#AtlasOrdered end else if not h then f=1 else f=nil end;ATLAS.adjustAutopilotTargetIndex(f)end end end;function checkLOS(k)local l,m,n=galaxyReference:getPlanetarySystem(0):castIntersections(worldPos,k,function(o)if o.noAtmosphericDensityAltitude>0 then return o.radius+o.noAtmosphericDensityAltitude else return o.radius+o.surfaceMaxAltitude*1.5 end end)local q=m;if n~=nil and m~=nil then q=math.min(n,m)end;if q~=nil then return l,q else return nil,nil end end;function play(r,s,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..r.."|"..s.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..r.."|"..s.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..r.."|"..s.."|"..soundVolume)end end;function addTable(t,u)for i=1,#u do t[#t+1]=u[i]end;return t end;function saveableVariables(v)local w={}local x={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local y={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization","WipeDamage"}local z={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local A={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not v then addTable(w,x)addTable(w,y)addTable(w,z)addTable(w,A)return w elseif v=="boolean"then return x elseif v=="handling"then return y elseif v=="hud"then return z elseif v=="physics"then return A end end;function svgText(B,C,D,E,F)if E==nil then E=""end;if F==nil then F=""end;return stringf([[<text class="%s" x=%s y=%s style="%s">%s</text>]],E,B,C,F,D)end;function cmdThrottle(G,H)if navCom:getAxisCommandType(0)~=axisCommandType.byThrottle and not H then a.control.cancelCurrentControlMasterMode()end;navCom:setThrottleCommand(axisCommandId.longitudinal,G)PlayerThrottle=uclamp(round(G*100,0)/100,-1,1)setCruiseSpeed=nil end;function cmdCruise(G,H)if navCom:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not H then a.control.cancelCurrentControlMasterMode()end;navCom:setTargetSpeedCommand(axisCommandId.longitudinal,G)setCruiseSpeed=G end;function float_eq(I,J)if I==0 then return mabs(J)<1e-09 end;if J==0 then return mabs(I)<1e-09 end;return mabs(I-J)<math.max(mabs(I),mabs(J))*epsilon end;function getDistanceDisplayString(distance,K)local L=distance>100000;if K==nil then K=1 end;if L then return round(distance/1000/200,K).."SU"elseif distance<1000 then return round(distance,K).."M"else return round(distance/1000,K).."KM"end end;function ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;autoRoll=true;upAmount=0;if inAtmo and abvGndDet==-1 then BrakeLanding=false;AltitudeHold=true;upAmount=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cmdCruise(mfloor(adjustedAtmoSpeedLimit))end else OrbitAchieved=false;GearExtended=false;a.control.retractLandingGears()navCom:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function ToggleIntoOrbit()OrbitAchieved=false;orbitPitch=nil;orbitRoll=nil;OrbitTicks=0;if atmosDensity==0 then if IntoOrbit then play("orOff","AP")IntoOrbit=false;orbitAligned=false;OrbitTargetPlanet=nil;autoRoll=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;orbitalParams.VectorToTarget=false;orbitalParams.AutopilotAlign=false;OrbitTargetSet=false elseif nearPlanet then play("orOn","AP")IntoOrbit=true;autoRoll=true;if OrbitTargetPlanet==nil then OrbitTargetPlanet=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else msgText="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;orbitAligned=false;OrbitTargetPlanet=nil;autoRoll=autoRollPreference;if AltitudeHold then AltitudeHold=false end;orbitalParams.VectorToTarget=false;orbitalParams.AutopilotAlign=false;OrbitTargetSet=false end end;function ToggleAltitudeHold()if time-ahDoubleClick<1.5 then if planet.hasAtmosphere then if atmosDensity>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;play("11","EP")else if nearPlanet then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;OrbitTargetOrbit=HoldAltitude;OrbitTargetSet=true;if not IntoOrbit then ToggleIntoOrbit()end;orbitAligned=true end end;ahDoubleClick=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else ahDoubleClick=time end;if nearPlanet and atmosDensity==0 then OrbitTargetOrbit=coreAltitude;OrbitTargetSet=true;orbitAligned=true;ToggleIntoOrbit()if IntoOrbit then ahDoubleClick=time else ahDoubleClick=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;followMode=false;autoRoll=true;LockPitch=nil;OrbitAchieved=false;if abvGndDet~=-1 and velMag<20 then play("lfs","LS")AutoTakeoff=true;if ahDoubleClick>-1 then HoldAltitude=coreAltitude+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;navCom:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and UpVertAtmoEngine then ToggleVerticalTakeoff()end else play("altOn","AH")AutoTakeoff=false;if ahDoubleClick>-1 then if nearPlanet then HoldAltitude=coreAltitude end end;if VertTakeOff then ToggleVerticalTakeoff()end end;if spaceLaunch then HoldAltitude=100000 end else play("altOff","AH")if IntoOrbit then ToggleIntoOrbit()end;if VertTakeOff then ToggleVerticalTakeoff()end;autoRoll=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;ahDoubleClick=0 end end;function ResetAutopilots(M)if M then spaceLaunch=false;Autopilot=false;AutopilotRealigned=false;apThrottleSet=false;HoldAltitude=coreAltitude;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;ReversalIsOn=nil;if not antigravOn then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then ToggleVerticalTakeoff()end;if IntoOrbit then ToggleIntoOrbit()end;autoRoll=autoRollPreference;spaceLand=false;finalLand=false;upAmount=0 end;function ToggleAutopilot()local function N(SpaceTarget)collisionAlertStatus=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if time-apDoubleClick<1.5 and atmosDensity>0 then if not SpaceEngines then msgText="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if atmosDensity>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;play("orH","OH")end;apDoubleClick=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else apDoubleClick=time end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<coreMass then msgText="WARNING: Heavy Loads may affect autopilot performance."msgTimer=5 end;ATLAS.UpdateAutopilotTarget()AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then play("apSpc","AP")if atmosDensity~=0 then spaceLaunch=true;ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if atmosDensity>0 then if not VectorToTarget then play("vtt","AP")N(SpaceTarget)end else play("apOn","AP")if not(autopilotTargetPlanet.name==planet.name and coreAltitude<AutopilotTargetOrbit*1.5)then OrbitAchieved=false;Autopilot=true elseif not inAtmo then if IntoOrbit then ToggleIntoOrbit()end;OrbitTargetOrbit=planet.noAtmosphericDensityAltitude+LowOrbitHeight;OrbitTargetSet=true;orbitalParams.AutopilotAlign=true;orbitalParams.VectorToTarget=true;orbitAligned=false;if not IntoOrbit then ToggleIntoOrbit()end end end else play("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if atmosDensity~=0 then spaceLaunch=true;ToggleAltitudeHold()else Autopilot=true end end elseif atmosDensity==0 then if CustomTarget==nil and(autopilotTargetPlanet.name==planet.name and nearPlanet)and not IntoOrbit then WaypointSet=false;OrbitAchieved=false;orbitAligned=false;ToggleIntoOrbit()else play("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;followMode=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;apThrottleSet=false;LockPitch=nil;WaypointSet=false end else play("apP","AP")spaceLaunch=true;ToggleAltitudeHold()end else play("apOff","AP")ResetAutopilots(1)end end;function BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;autoRoll=autoRollPreference end;if BrakeIsOn then play("bkOn","B",1)ResetAutopilots()else play("bkOff","B",1)end end;function BeginReentry()if Reentry then msgText="Re-Entry cancelled"play("reOff","RE")Reentry=false;autoRoll=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then msgText="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"msgTimer=5 elseif not reentryMode then Reentry=true;if navCom:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;autoRoll=true;BrakeIsOn=false;msgText="Beginning Parachute Re-Entry - Strap In.  Target speed: "..adjustedAtmoSpeedLimit;play("par","RE")else Reentry=true;AltitudeHold=true;autoRoll=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local D=getDistanceDisplayString(HoldAltitude)msgText="Beginning Re-entry.  Target speed: "..adjustedAtmoSpeedLimit.." Target Altitude: "..D;play("glide","RE")cmdCruise(mfloor(adjustedAtmoSpeedLimit))end;AutoTakeoff=false end;function ToggleAntigrav()if antigrav and not ExternalAGG then if antigravOn then play("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;play("aggOn","AG")antigrav.activate()antigrav.show()end end end;function FormatTimeString(O)local P=0;local Q=0;local R=0;if O<60 then O=mfloor(O)elseif O<3600 then P=mfloor(O/60)O=mfloor(O%60)elseif O<86400 then Q=mfloor(O/3600)P=mfloor(O%3600/60)else R=mfloor(O/86400)Q=mfloor(O%86400/3600)end;if R>0 then return R.."d "..Q.."h "elseif Q>0 then return Q.."h "..P.."m "elseif P>0 then return P.."m "..O.."s"elseif O>0 then return O.."s"else return"0s"end end;function SaveDataBank(S)local function T(U)for V,W in pairs(U)do dbHud_1.setStringValue(W,jencode(_G[W]))if S and dbHud_2 then dbHud_2.setStringValue(W,jencode(_G[W]))end end end;if dbHud_1 then T(c)T(saveableVariables())system.print("Saved Variables to Datacore")if S and dbHud_2 then msgText="Databank copied.  Remove copy when ready."end end end;function ConvertResolutionX(W)if resolutionWidth==1920 then return W else return round(resolutionWidth*W/1920,0)end end;function ConvertResolutionY(W)if resolutionHeight==1080 then return W else return round(resolutionHeight*W/1080,0)end end;local function X()local function Y(Z)return type(Z)=='number'end;local function a0(Z)return type(tonum(Z))=='number'end;local function a1(a2)return type(a2)=='table'end;local function a3(a4)return type(a4)=='string'end;local function a5(W)return a1(W)and Y(W.x and W.y and W.z)end;local function a6(a7)return a1(a7)and Y(a7.latitude and a7.longitude and a7.altitude and a7.id and a7.systemId)end;local a8=math.pi/180;local a9=180/math.pi;local epsilon=1e-10;local d=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aa='::pos{'..d..','..d..','..d..','..d..','..d..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function ab(Z)local ac=string.gsub(string.reverse(stringf('%.4f',Z)),'^0*%.?','')return ac==''and'0'or string.reverse(ac)end;local function ad(ae)if a5(ae)then return stringf('{x=%.3f,y=%.3f,z=%.3f}',ae.x,ae.y,ae.z)end;if a1(ae)and not getmetatable(ae)then local af={}local ag=next(ae)if type(ag)=='nil'or ag==1 then af=ae else for V,W in pairs(ae)do local G=ad(W)if type(V)=='number'then table.insert(af,stringf('[%s]=%s',V,G))else table.insert(af,stringf('%s=%s',V,G))end end end;return stringf('{%s}',table.concat(af,','))end;if a3(ae)then return stringf("'%s'",ae:gsub("'",[[\']]))end;return tostring(ae)end;local ah={}ah.__index=ah;ah.__tostring=function(ae,ai)local aj={}for V in pairs(ae)do table.insert(aj,V)end;table.sort(aj)local af={}for _,V in ipairs(aj)do local G=ad(ae[V])if type(V)=='number'then table.insert(af,stringf('[%s]=%s',V,G))else table.insert(af,stringf('%s=%s',V,G))end end;if ai then return stringf('%s%s',ai,table.concat(af,',\n'..ai))end;return stringf('{%s}',table.concat(af,','))end;ah.__eq=function(ak,al)return ak.systemId==al.systemId and ak.id==al.id and float_eq(ak.radius,al.radius)and float_eq(ak.center.x,al.center.x)and float_eq(ak.center.y,al.center.y)and float_eq(ak.center.z,al.center.z)and float_eq(ak.GM,al.GM)end;local function am(an,ao,ap,aq,ar)assert(a0(an),'Argument 1 (systemId) must be a number:'..type(an))assert(a0(ao),'Argument 2 (id) must be a number:'..type(ao))assert(a0(ap),'Argument 3 (radius) must be a number:'..type(ap))assert(a1(aq),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(aq))assert(a0(ar),'Argument 5 (GM) must be a number:'..type(ar))return setmetatable({systemId=tonum(an),id=tonum(ao),radius=tonum(ap),center=vec3(aq),GM=tonum(ar)},ah)end;local as={}as.__index=as;as.__tostring=function(p)return stringf('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,ab(p.latitude*a9),ab(p.longitude*a9),ab(p.altitude))end;as.__eq=function(ak,al)return ak.id==al.id and ak.systemId==al.systemId and float_eq(ak.latitude,al.latitude)and float_eq(ak.altitude,al.altitude)and(float_eq(ak.longitude,al.longitude)or float_eq(ak.latitude,math.pi/2)or float_eq(ak.latitude,-math.pi/2))end;local function at(au,ao,av,aw,ax)local an=au;if a3(au)and not aw and not ax and not ao and not av then an,ao,av,aw,ax=stringmatch(au,aa)assert(an,'Argument 1 (position string) is malformed.')else assert(a0(an),'Argument 1 (systemId) must be a number:'..type(an))assert(a0(ao),'Argument 2 (id) must be a number:'..type(ao))assert(a0(av),'Argument 3 (latitude) must be in degrees:'..type(av))assert(a0(aw),'Argument 4 (longitude) must be in degrees:'..type(aw))assert(a0(ax),'Argument 5 (altitude) must be in meters:'..type(ax))end;an=tonum(an)ao=tonum(ao)av=tonum(av)aw=tonum(aw)ax=tonum(ax)if ao==0 then return setmetatable({latitude=av,longitude=aw,altitude=ax,id=ao,systemId=an},as)end;return setmetatable({latitude=a8*uclamp(av,-90,90),longitude=a8*(aw%360),altitude=ax,id=ao,systemId=an},as)end;local ay={}ay.__index=ay;ay.__tostring=function(ae,ai)local az=ai and ai..'  'local aA={}local aj={}for V in pairs(ae)do table.insert(aj,V)end;table.sort(aj)for _,aB in ipairs(aj)do bdy=ae[aB]local aC=ah.__tostring(bdy,az)if ai then table.insert(aA,stringf('[%s]={\n%s\n%s}',aB,aC,ai))else table.insert(aA,stringf('  [%s]=%s',aB,aC))end end;if ai then return stringf('\n%s%s%s',ai,table.concat(aA,',\n'..ai),ai)end;return stringf('{\n%s\n}',table.concat(aA,',\n'))end;local function aD(aE)local b={}local pid;for _,W in pairs(aE)do local ao=W.planetarySystemId;if type(ao)~='number'then error('Invalid planetary system ID: '..tostring(ao))elseif pid and ao~=pid then error('Mistringmatch planetary system IDs: '..ao..' and '..pid)end;local aF=W.bodyId;if type(aF)~='number'then error('Invalid body ID: '..tostring(aF))elseif b[aF]then error('Duplicate body ID: '..tostring(aF))end;setmetatable(W.center,getmetatable(vec3.unit_x))b[aF]=setmetatable(W,ah)pid=ao end;return setmetatable(b,ay)end;PlanetaryReference={}local function aG(aE)return setmetatable({galaxyAtlas=aE or{}},PlanetaryReference)end;PlanetaryReference.__index=function(a2,i)if type(i)=='number'then local system=a2.galaxyAtlas[i]return aD(system)end;return rawget(PlanetaryReference,i)end;PlanetaryReference.__pairs=function(ae)return function(a2,V)local aH,nv=next(a2,V)return aH,nv and aD(nv)end,ae.galaxyAtlas,nil end;PlanetaryReference.__tostring=function(ae)local aI={}for _,aJ in pairs(ae or{})do local aK=aJ:getPlanetarySystemId()local aL=ay.__tostring(aJ,'    ')table.insert(aI,stringf('  [%s]={%s\n  }',aK,aL))end;return stringf('{\n%s\n}\n',table.concat(aI,',\n'))end;PlanetaryReference.BodyParameters=am;PlanetaryReference.MapPosition=at;PlanetaryReference.PlanetarySystem=aD;function PlanetaryReference.createBodyParameters(an,ao,aM,aN,aO,aP,aQ)assert(a0(an),'Argument 1 (systemId) must be a number:'..type(an))assert(a0(ao),'Argument 2 (id) must be a number:'..type(ao))assert(a0(aM),'Argument 3 (surfaceArea) must be a number:'..type(aM))assert(a1(aN),'Argument 4 (aPosition) must be an array or vec3:'..type(aN))assert(a1(aO),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(aO))assert(a0(aP),'Argument 6 (altitude) must be in meters:'..type(aP))assert(a0(aQ),'Argument 7 (gravityAtPosition) must be number:'..type(aQ))local ap=msqrt(aM/4/math.pi)local distance=ap+aP;local aR=vec3(aN)+distance*vec3(aO)local ar=aQ*distance*distance;return am(an,ao,ap,aR,ar)end;PlanetaryReference.isMapPosition=a6;function PlanetaryReference:getPlanetarySystem(au)if i==nil then i=0 end;if nv==nil then nv=0 end;local an=au;if a6(au)then an=au.systemId end;if type(an)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=ay then system=aD(system)end;return system end end end;function ay:sizeCalculator(o)return 1.05*o.radius end;function ay:castIntersections(aS,aT,aU,aV,aW,aX)local aY={}local aZ=aW or self;for _,o in pairs(aZ)do table.insert(aY,o)end;if not aX then table.sort(aY,function(a_,b0)return(a_.center-aS):len()<(b0.center-aS):len()end)end;local b1=aT:normalize()for _,o in ipairs(aY)do local b2=o.center-aS;local ap=self:sizeCalculator(o)local b3=b2:dot(b1)local b4=b3^2-(b2:len2()-ap^2)if b4>=0 then local b5=msqrt(b4)local m=b3+b5;local n=b3-b5;if n>0 then return o,m,n elseif m>0 then return o,m,nil end end end;return nil,nil,nil end;function ay:closestBody(b6)assert(type(b6)=='table','Invalid coordinates.')local b7,o;local b8=vec3(b6)for _,b9 in pairs(self)do local ba=(b9.center-b8):len2()if(not o or ba<b7)and b9.name~="Space"then o=b9;b7=ba end end;return o end;function ay:convertToBodyIdAndWorldCoordinates(au)local bb=au;if a3(au)then bb=at(au)end;if bb.id==0 then return 0,vec3(bb.latitude,bb.longitude,bb.altitude)end;local b9=self:getBodyParameters(bb)if b9 then return bb.id,b9:convertToWorldCoordinates(bb)end end;function ay:getBodyParameters(au)local ao=au;if a6(au)then ao=au.id end;assert(a0(ao),'Argument 1 (id) must be a number:'..type(ao))return self[ao]end;function ay:getPlanetarySystemId()local _,W=next(self)return W and W.systemId end;function ah:convertToMapPosition(aq)assert(a1(aq),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(aq))local bc=vec3(aq)if self.id==0 then return setmetatable({latitude=bc.x,longitude=bc.y,altitude=bc.z,id=0,systemId=self.systemId},as)end;local bd=bc-self.center;local distance=bd:len()local ax=distance-self.radius;local av=0;local aw=0;if not float_eq(distance,0)then local be=atan(bd.y,bd.x)aw=be>=0 and be or 2*math.pi+be;av=math.pi/2-math.acos(bd.z/distance)end;return setmetatable({latitude=av,longitude=aw,altitude=ax,id=self.id,systemId=self.systemId},as)end;function ah:convertToWorldCoordinates(au)local bb=a3(au)and at(au)or au;if bb.id==0 then return vec3(bb.latitude,bb.longitude,bb.altitude)end;assert(a6(bb),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(bb.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(bb.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local bf=math.cos(bb.latitude)return self.center+(self.radius+bb.altitude)*vec3(bf*math.cos(bb.longitude),bf*math.sin(bb.longitude),math.sin(bb.latitude))end;function ah:getAltitude(aq)return(vec3(aq)-self.center):len()-self.radius end;function ah:getDistance(aq)return(vec3(aq)-self.center):len()end;function ah:getGravity(aq)local bg=self.center-vec3(aq)local bh=bg:len2()return self.GM/bh*bg/msqrt(bh)end;return setmetatable(PlanetaryReference,{__call=function(_,...)return aG(...)end})end;local function bi()local Kinematic={}local bj=30000000/3600;local bk=bj*bj;local bl=100;function Kinematic.computeAccelerationTime(bm,bn,bo)local bp=bj*math.asin(bm/bj)return(bj*math.asin(bo/bj)-bp)/bn end;function Kinematic.computeDistanceAndTime(bm,bo,bq,br,bs,bt)bs=bs or 0;bt=bt or 0;local bu=bm<=bo;local bv=br*(bu and 1 or-1)/bq;local bw=-bt/bq;local bx=bv+bw;if bu and bx<=0 or not bu and bx>=0 then return-1,-1 end;local by,bz=0,0;if bv~=0 and bs>0 then local bp=math.asin(bm/bj)local bA=math.pi*(bv/2+bw)local bB=bv*bs;local bC=bj*math.pi;local W=function(a2)local bD=(bA*a2-bB*math.sin(math.pi*a2/2/bs)+bC*bp)/bC;local bE=math.tan(bD)return bj*bE/msqrt(bE*bE+1)end;local bF=bu and function(a4)return a4>=bo end or function(a4)return a4<=bo end;bz=2*bs;if bF(W(bz))then local bG=0;while mabs(bz-bG)>0.5 do local a2=(bz+bG)/2;if bF(W(a2))then bz=a2 else bG=a2 end end end;local bH=bm;local bI=bz/bl;for bJ=1,bl do local bK=W(bJ*bI)by=by+(bK+bH)*bI/2;bH=bK end;if bz<2*bs then return by,bz end;bm=bH end;local bp=bj*math.asin(bm/bj)local time=(bj*math.asin(bo/bj)-bp)/bx;local bL=bk*math.cos(bp/bj)/bx;local distance=bL-bk*math.cos((bx*time+bp)/bj)/bx;return distance+by,time+bz end;function Kinematic.computeTravelTime(bm,bn,distance)if distance==0 then return 0 end;if bn>0 then local bp=bj*math.asin(bm/bj)local bL=bk*math.cos(bp/bj)/bn;return(bj*math.acos(bn*(bL-distance)/bk)-bp)/bn end;if bm==0 then return-1 end;assert(bm>0,'Acceleration and initial speed are both zero.')return distance/bm end;return Kinematic end;local function bM()local vec3=require('cpml.vec3')local X=X()local function a3(a4)return type(a4)=='string'end;local function a1(a2)return type(a2)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(ax)assert(self.body)local distance=ax+self.body.radius;if not float_eq(distance,0)then local bN=msqrt(self.body.GM/distance)return msqrt(2)*bN,bN end;return nil,nil end;function Kepler:orbitalParameters(au,bO)assert(self.body)assert(a1(au)or a3(au))assert(a1(bO))local bP=(a3(au)or X.isMapPosition(au))and self.body:convertToWorldCoordinates(au)or vec3(au)local W=vec3(bO)local bQ=bP-self.body.center;local bR=W:len2()local bS=bQ:len()local bT=self.body.GM;local bU=((bR-bT/bS)*bQ-bQ:dot(W)*W)/bT;local I=bT/(2*bT/bS-bR)local bV=bU:len()local b1=bU:normalize()local bW=I*(1-bV)local bX=I*(1+bV)local bY=bW*b1+self.body.center;local bZ=bV<=1 and-bX*b1+self.body.center or nil;local b_=msqrt(I*bT*(1-bV*bV))local c0=bZ and 2*math.pi*msqrt(I^3/bT)local c1=math.acos(bU:dot(bQ)/(bV*bS))if bQ:dot(W)<0 then c1=-(c1-2*math.pi)end;local c2=math.acos((math.cos(c1)+bV)/(1+bV*math.cos(c1)))local c3=c2;if c3<0 then c3=c3+2*math.pi end;local c4=c3-bV*math.sin(c3)local c5=0;local c6=0;local c7=0;if c0~=nil then c5=c4/(2*math.pi/c0)c6=c0-c5;c7=c6+c0/2;if c1-math.pi>0 then c6=c5;c7=c6+c0/2 end;if c7>c0 then c7=c7-c0 end end;return{periapsis={position=bY,speed=b_/bW,circularOrbitSpeed=msqrt(bT/bW),altitude=bW-self.body.radius},apoapsis=bZ and{position=bZ,speed=b_/bX,circularOrbitSpeed=msqrt(bT/bX),altitude=bX-self.body.radius},currentVelocity=W,currentPosition=bP,eccentricity=bV,period=c0,eccentricAnomaly=c2,meanAnomaly=c4,timeToPeriapsis=c6,timeToApoapsis=c7}end;local function c8(c9)local b9=X.BodyParameters(c9.systemId,c9.id,c9.radius,c9.center,c9.GM)return setmetatable({body=b9},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return c8(...)end})end;local function ca()local cb={}local cc={}local cd={XS=13,S=27,M=55,L=110,XL=221}local ce={}local cf;local cg;local ch;local ci;local cj;local function ck()local function cl(cm,cn,co,cp,cq,cr,cs,ct)cn,cp,cr,ct=vec3(cn),vec3(cp),vec3(cr),vec3(ct)local cu,cv,cw=cm*cm,co*co,cq*cq;local bR=cp-cn;local cx=bR:normalize()local cy=bR:len()local cz=cr-cn;local cA=(cz-cz:project_on(cx)):normalize()local cB,cC=cz:dot(cx),cz:dot(cA)local cD=cB*cB+cC*cC;local cE=cx:cross(cA)local B=(cu-cv+cy*cy)/(2*cy)local C=(cu-cw+cD-2*cB*B)/(2*cC)local a7=cu-B^2-C^2;local cF=msqrt(a7)local cG=cn+cx*B+cA*C+cE*cF;local cH=cn+cx*B+cA*C-cE*cF;if mabs((ct-cG):len()-cs)<mabs((ct-cH):len()-cs)then return cG else return cH end end;local function cI()local function cJ()local cK=core.getConstructWorldOrientationRight()local bR=core.getConstructWorldOrientationForward()local cz=core.getConstructWorldOrientationUp()local cL=library.systemResolution3(cK,bR,cz,{1,0,0})local cM=library.systemResolution3(cK,bR,cz,{0,1,0})local cN=library.systemResolution3(cK,bR,cz,{0,0,1})return function(cO)return library.systemResolution3(cL,cM,cN,cO)end end;local cP=cJ()local cQ=core.getConstructWorldPos()local bP=core.getElementPositionById(1)local cR={bP[1],bP[2],bP[3]}local cS=cP(cR)local cT={cQ[1]-cS[1],cQ[2]-cS[2],cQ[3]-cS[3]}return cT end;local function cU(cV,bS,cW)local cX=cV.pts;local cY=#cX;local cZ=cV.ref;if cY>3 then local c_,d0,d1,d2=cX[cY],cX[cY-1],cX[cY-2],cX[cY-3]cV.ref=cW;local bP=cl(c_[1],c_[2],d0[1],d0[2],d1[1],d1[2],d2[1],d2[2])local B,C,cF=bP.x,bP.y,bP.z;if B==B and C==C and cF==cF then B=B+cZ[1]C=C+cZ[2]cF=cF+cZ[3]local d3=vec3(B,C,cF)if not cV.lastPos then cV.center=d3 elseif(cV.lastPos-d3):len()<2 then cV.center=d3;cV.skipCalc=true end;cV.lastPos=d3 end;cV.pts={}else local d4={cW[1]-cZ[1],cW[2]-cZ[2],cW[3]-cZ[3]}cX[cY+1]={bS,d4}end end;if radars[1]then cf=#radars[1].getConstructIds()local d5=radars[1].getData()local d6=d5:gmatch('{"constructId[^}]*}[^}]*}')if cf>0 then local cW=cI()local d7,d8=0,0;cj,ci=0,0;for W in d6 do local ao,distance,d9=W:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local da=cd[d9]distance=tonum(distance)if radars[1].hasMatchingTransponder(ao)==1 then table.insert(cc,ao)end;local db=radars[1].getConstructType(ao)if CollisionSystem then if da>27 or db=="static"or db=="space"then cj=cj+1;local dc=radars[1].getConstructName(ao)local cV=contacts[ao]if cV==nil then da=da+coreHalfDiag;contacts[ao]={pts={},ref=cW,name=dc,i=0,radius=da,skipCalc=false}cV=contacts[ao]end;if not cV.skipCalc then cU(cV,distance,cW)d8=d8+1 end;if cV.center then table.insert(ce,cV)end end;d7=d7+1;if nearPlanet and d7>700 or d8>70 or(not nearPlanet and d7>300 or d8>30)then coroutine.yield()d7,d8=0,0 end end end;ci=#ce;if ci>0 and velMag>20 then local o,dd,de,df;local dg=0;local dh=galaxyReference:getPlanetarySystem(0)df=constructVelocity:normalize()while dg<ci do coroutine.yield()local di={table.unpack(ce,dg,math.min(dg+75,ci))}o,dd,de=dh:castIntersections(worldPos,df,nil,nil,di,true)if o and de then collisionTarget={o,dd,de}break end;dg=dg+75 end;if not o then collisionTarget=nil end else collisionTarget=nil end;ce={}cg=d5:find('identifiedConstructs":%[%]')else ch=d5:find('worksInEnvironment":false')end end end;local function dj()if radars[1]then rType="Atmo"if radars[1].getData():find('worksInAtmosphere":false')then rType="Space"end end end;function cb.pickType()dj()end;function cb.assignRadar()if radar_1 and radars[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then radars[1]=radar_2 end;if radars[1]==radar_2 then dj()end elseif radar_2 and radars[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then radars[1]=radar_1 end;if radars[1]==radar_1 then dj()end end end;function cb.UpdateRadar()local dk=coroutine.status(UpdateRadarCoroutine)if dk=="suspended"then local G,dl=coroutine.resume(UpdateRadarCoroutine)if dl then system.print("ERROR UPDATE RADAR: "..dl)end elseif dk=="dead"then UpdateRadarCoroutine=coroutine.create(ck)local G,dl=coroutine.resume(UpdateRadarCoroutine)end end;function cb.GetRadarHud()local dm=cc;cc={}return cg,ch,cf,ci,cj,dm end;UpdateRadarCoroutine=coroutine.create(ck)return cb end;local function dn()local function dp(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function dq()local function dr(ds,dt)return ds.name<dt.name end;AtlasOrdered={}for V,W in pairs(b[0])do AtlasOrdered[#AtlasOrdered+1]={name=W.name,index=V}end;table.sort(AtlasOrdered,dr)end;local function du(dv)for V,W in pairs(dv)do if W.name and W.name==CustomTarget.name then return V end end;return-1 end;local function dw()apScrollIndex=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"autopilotTargetPlanet=nil;CustomTarget=nil;return true end;local dx=AtlasOrdered[AutopilotTargetIndex].index;local dy=b[0][dx]if dy.center then AutopilotTargetName=dy.name;autopilotTargetPlanet=galaxyReference[0][dx]if CustomTarget~=nil then if atmosDensity==0 then if sysUpData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then sysAddData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if sysUpData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then sysAddData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if sysUpData(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then sysAddData(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if sysUpData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then sysAddData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if sysUpData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then sysAddData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if sysUpData(widgetMaxMassText,widgetMaxMass)~=1 then sysAddData(widgetMaxMassText,widgetMaxMass)end;if sysUpData(widgetTravelTimeText,widgetTravelTime)~=1 then sysAddData(widgetTravelTimeText,widgetTravelTime)end;if sysUpData(widgetTargetOrbitText,widgetTargetOrbit)~=1 then sysAddData(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=dy;for _,W in pairs(galaxyReference[0])do if W.name==CustomTarget.planetname then autopilotTargetPlanet=W;AutopilotTargetName=CustomTarget.name;break end end;if sysUpData(widgetMaxMassText,widgetMaxMass)~=1 then sysAddData(widgetMaxMassText,widgetMaxMass)end;if sysUpData(widgetTravelTimeText,widgetTravelTime)~=1 then sysAddData(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)else AutopilotTargetCoords=CustomTarget.position end;if autopilotTargetPlanet.planetname~="Space"then if autopilotTargetPlanet.hasAtmosphere then AutopilotTargetOrbit=mfloor(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=mfloor(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function dz(dA)if not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit then if dA==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then dw()else local dx=AtlasOrdered[AutopilotTargetIndex].index;local dy=b[0][dx]if dy~=nil and dy.name=="Space"or iphCondition=="Custom Only"and dy.center or iphCondition=="No Moons"and string.find(dy.name,"Moon")~=nil then if dA==nil then dz()else dz(1)end else dw()end end else msgText="Disengage autopilot before changing Interplanetary Helper"play("iph","AP")end end;local function dB()local cY=-1;cY=du(b[0])if cY>-1 then table.remove(b[0],cY)end;cY=-1;cY=du(SavedLocations)if cY~=-1 then msgText=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cY)end;dz()dq()end;local function dC(dc,position,dD,dE)if dbHud_1 or dD then local p=dp(position)local dF=p.gravity;if dE then dF=unit.getClosestPlanetInfluence()end;local dG={position=position,name=dc,planetname=p.name,gravity=dF,safe=dE}if not dD then SavedLocations[#SavedLocations+1]=dG else for V,W in pairs(b[0])do if W.name and dc==W.name then table.remove(b[0],V)end end end;table.insert(b[0],dG)dq()dw()msgText="Location saved as "..dc.."("..p.name..")"else msgText="Databank must be installed to save permanent locations"end end;local dH={}function dH.UpdateAtlasLocationsList()dq()end;function dH.UpdateAutopilotTarget()dw()end;function dH.adjustAutopilotTargetIndex(dA)dz(dA)end;function dH.findAtlasIndex(dv)du(dv)end;function dH.UpdatePosition(dI)local cY=du(SavedLocations)if cY~=-1 then if dI~=nil then SavedLocations[cY].name=dI;AutopilotTargetIndex=AutopilotTargetIndex-1;dz()else local dJ=SavedLocations[cY]dJ.gravity=unit.getClosestPlanetInfluence()dJ.position=worldPos;dJ.safe=true end;msgText=SavedLocations[cY].name.." position updated ("..SavedLocations[cY].planetname..")"else msgText="Name Not Found"end end;function dH.AddNewLocation(dc,position,dD,dE)dC(dc,position,dD,dE)end;function dH.ClearCurrentPosition()dB()end;for V,W in pairs(SavedLocations)do table.insert(b[0],W)end;dq()if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end;dH.UpdateAutopilotTarget()return dH end;function script.onStart()local dK=false;local function dL()local function dM(dN)local dO=dbHud_1.hasKey;for V,W in pairs(dN)do if dO(W)then local ac=jdecode(dbHud_1.getStringValue(W))if ac~=nil then _G[W]=ac;dK=true end end end end;if dbHud_1 then if not useTheseSettings then dM(saveableVariables())coroutine.yield()dM(c)else dM(c)msgText="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"msgTimer=5;dK=false end;coroutine.yield()if dK then msgText="Loaded Saved Variables"resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)autoRoll=autoRollPreference;adjustedAtmoSpeedLimit=AtmoSpeedLimit;rgb=[[rgb(]]..mfloor(PrimaryR+0.5)..","..mfloor(PrimaryG+0.5)..","..mfloor(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..mfloor(PrimaryR*0.9+0.5)..","..mfloor(PrimaryG*0.9+0.5)..","..mfloor(PrimaryB*0.9+0.5)..[[)]]elseif not useTheseSettings then msgText="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then msgText="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else msgText="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<time then LastMaxBrakeInAtmo=0 end;LastStartTime=time;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then msgText="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"msgTimer=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function dP()local function dQ(dR,dS)if dR>dS then dS=dR end;local dT,dU=0,0;if ContainerOptimization>0 then dT=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then dU=FuelTankOptimization*0.05 end;dS=dS*(1-(dT+dU))return dS end;local dV=core.getElementNameById;local dW=fuelX~=0 and fuelY~=0;for V in pairs(elementsID)do local type=core.getElementTypeById(elementsID[V])if stringmatch(type,'^.*Atmospheric Engine$')then if stringmatch(tostring(core.getElementTagsById(elementsID[V])),'^.*vertical.*$')and core.getElementForwardById(elementsID[V])[3]>0 then UpVertAtmoEngine=true end end;if stringmatch(type,'^.*Space Engine$')then SpaceEngines=true;if stringmatch(tostring(core.getElementTagsById(elementsID[V])),'^.*vertical.*$')then local dX=core.getElementForwardById(elementsID[V])if dX[3]<0 then SpaceEngineVertUp=true else SpaceEngineVertDn=true end end end;if type=="Landing Gear"then hasGear=true end;if type=="Dynamic Core Unit"then local dY=eleMaxHp(elementsID[V])if dY>10000 then coreHalfDiag=110 elseif dY>1000 then coreHalfDiag=55 elseif dY>150 then coreHalfDiag=27 end end;eleTotalMaxHp=eleTotalMaxHp+eleMaxHp(elementsID[V])if dW and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local dY=eleMaxHp(elementsID[V])local dZ=eleMass(elementsID[V])local dR=0;local d_=systime()if type=="Atmospheric Fuel Tank"then local dS=400;local e0=35.03;if dY>10000 then dS=51200;e0=5480 elseif dY>1300 then dS=6400;e0=988.67 elseif dY>150 then dS=1600;e0=182.67 end;dR=dZ-e0;if fuelTankHandlingAtmo>0 then dS=dS+dS*fuelTankHandlingAtmo*0.2 end;dS=dQ(dR,dS)atmoTanks[#atmoTanks+1]={elementsID[V],dV(elementsID[V]),dS,e0,dR,d_}end;if type=="Rocket Fuel Tank"then local dS=320;local e0=173.42;if dY>65000 then dS=40000;e0=25740 elseif dY>6000 then dS=5120;e0=4720 elseif dY>700 then dS=640;e0=886.72 end;dR=dZ-e0;if fuelTankHandlingRocket>0 then dS=dS+dS*fuelTankHandlingRocket*0.1 end;dS=dQ(dR,dS)rocketTanks[#rocketTanks+1]={elementsID[V],dV(elementsID[V]),dS,e0,dR,d_}end;if type=="Space Fuel Tank"then local dS=600;local e0=35.03;if dY>10000 then dS=76800;e0=5480 elseif dY>1300 then dS=9600;e0=988.67 elseif dY>150 then dS=2400;e0=182.67 end;dR=dZ-e0;if fuelTankHandlingSpace>0 then dS=dS+dS*fuelTankHandlingSpace*0.2 end;dS=dQ(dR,dS)spaceTanks[#spaceTanks+1]={elementsID[V],dV(elementsID[V]),dS,e0,dR,d_}end end end;if not UpVertAtmoEngine then VertTakeOff,VertTakeOffEngine=false,false end end;local function e1()if gyro~=nil then gyroIsOn=gyro.getState()==1 end;if not stablized then navCom:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then sysLockVw(1)else sysLockVw(0)end;if door and(inAtmo or not inAtmo and coreAltitude<10000)then for _,W in pairs(door)do W.toggle()end end;if switch then for _,W in pairs(switch)do W.toggle()end end;if forcefield and(inAtmo or not inAtmo==0 and coreAltitude<10000)then for _,W in pairs(forcefield)do W.toggle()end end;if antigrav then antigravOn=antigrav.getState()==1;if antigravOn and not ExternalAGG then antigrav.show()end end;if isRemote()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if hasGear then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if abvGndDet~=-1 or not inAtmo and coreVelocity:len()<50 then BrakeIsOn=true;GearExtended=true;if hasGear then a.control.extendLandingGears()end else BrakeIsOn=false end;navCom:setTargetGroundAltitude(targetGroundAltitude)if inAtmo and abvGndDet~=-1 then maxKinematicUp=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=inAtmo end;local function e2()local e3={}local function e4()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local e5={[1]=4480,[6]=4480,[7]=6270}for e6,e7 in pairs(b)do b[e6][0]=e4()b[e6][0].systemId=e6;e3[e6]={}for e8,planet in pairs(b[e6])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=e5[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=e6;planet.bodyId=planet.id;e3[e6][e8]=planet end end;PlanetaryReference=X()galaxyReference=PlanetaryReference(e3)Kinematic=bi()Kep=bM()ATLAS=dn()end;SetupComplete=false;beginSetup=coroutine.create(function()navCom:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})dL()coroutine.yield()dP()coroutine.yield()AP=APClass()e1()coroutine.yield()e2()RADAR=ca()HUD=HudClass()HUD.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)radars[1]=nil;if radar_1 then radars[1]=radar_1;RADAR.pickType()end;play("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,W in pairs(door)do W.toggle()end end;if switch then for _,W in pairs(switch)do W.toggle()end end;if forcefield and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,W in pairs(forcefield)do W.toggle()end end;SaveDataBank()if button then button.activate()end;if SetWaypointOnExit then AP.showWayPoint(planet,worldPos)end;play("stop","SU")end;function script.onTick(e9)local ea=nil;if e9=="contact"then if not contactTimer then contactTimer=0 end;if time>contactTimer+10 then msgText="Radar Contact"play("rdrCon","RC")contactTimer=time end;unit.stopTimer("contact")elseif e9=="tenthSecond"then local function eb()local ec=system.createData;local ed=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=ed(panelInterplanetary,"value")interplanetaryHeaderText=ec('{"label": "Target Planet", "value": "N/A", "unit":""}')sysAddData(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=ed(panelInterplanetary,"value")widgetDistanceText=ec('{"label": "distance", "value": "N/A", "unit":""}')sysAddData(widgetDistanceText,widgetDistance)widgetTravelTime=ed(panelInterplanetary,"value")widgetTravelTimeText=ec('{"label": "Travel Time", "value": "N/A", "unit":""}')sysAddData(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=ed(panelInterplanetary,"value")widgetMaxMassText=ec('{"label": "Maximum Mass", "value": "N/A", "unit":""}')sysAddData(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=ed(panelInterplanetary,"value")widgetTargetOrbitText=ec('{"label": "Target Altitude", "value": "N/A", "unit":""}')sysAddData(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=ed(panelInterplanetary,"value")widgetCurBrakeDistanceText=ec('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=ed(panelInterplanetary,"value")widgetCurBrakeTimeText=ec('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=ed(panelInterplanetary,"value")widgetMaxBrakeDistanceText=ec('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=ed(panelInterplanetary,"value")widgetMaxBrakeTimeText=ec('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=ed(panelInterplanetary,"value")widgetTrajectoryAltitudeText=ec('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not inAtmo then sysAddData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)sysAddData(widgetCurBrakeTimeText,widgetCurBrakeTime)sysAddData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)sysAddData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)sysAddData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function ee()sysDestWid(panelInterplanetary)panelInterplanetary=nil end;local function ef()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(autopilotTargetPlanet.center-worldPos):len()else AutopilotDistance=(CustomTarget.position-worldPos):len()end end;local bK=velMag;local eg=unit.getThrottle()/100;if AtmoSpeedAssist then eg=PlayerThrottle end;local eh,ei=Kinematic.computeDistanceAndTime(velMag,MaxGameVelocity,coreMass,a:maxForceForward()*eg,warmup,0)local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,ej;if not TurnBurn and bK>0 then _,ej=AP.GetAutopilotBrakeDistanceAndTime(bK)else _,ej=AP.GetAutopilotTBBrakeDistanceAndTime(bK)end;local ek=0;local el=0;if AutopilotCruising or not Autopilot and bK>5 then el=Kinematic.computeTravelTime(bK,0,AutopilotDistance)elseif brakeDistance+eh<AutopilotDistance then ek=AutopilotDistance-(brakeDistance+eh)el=Kinematic.computeTravelTime(8333.0556,0,ek)else local em=(AutopilotDistance-brakeDistance)/eh;eh=AutopilotDistance-brakeDistance;ei=ei*em end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return el elseif AutopilotBraking then return ej elseif AutopilotCruising then return el+ej else return ei+brakeTime+el end end;local function en(dF,eo)if dF==nil then dF=core.g()end;dF=round(dF,5)if eo~=nil and eo or(ea==nil or ea~=dF)then local bK=coreVelocity:len()local ep=jdecode(unit.getData()).maxBrake;if ep~=nil and ep>0 and inAtmo then ep=ep/uclamp(bK/100,0.1,1)ep=ep/atmosDensity;if atmosDensity>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+ep)/2 else LastMaxBrakeInAtmo=ep end end end;if ep~=nil and ep>0 then LastMaxBrake=ep end;ea=dF end end;en(nil,true)if setCruiseSpeed~=nil then if navCom:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or navCom:getTargetSpeed(axisCommandId.longitudinal)~=setCruiseSpeed then cmdCruise(setCruiseSpeed)else setCruiseSpeed=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then eb()end;if AutopilotTargetName~=nil then local eq=CustomTarget~=nil;local er=0.5*LastMaxBrakeInAtmo/autopilotTargetPlanet:getGravity(autopilotTargetPlanet.center+vec3(0,0,1)*autopilotTargetPlanet.radius):len()er=er>1000000 and round(er/1000000,2).." kTons"or round(er/1000,2).." Tons"sysUpData(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=ef()if eq and not Autopilot then distance=(worldPos-CustomTarget.position):len()else distance=(AutopilotTargetCoords-worldPos):len()end;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(velMag)maxBrakeDistance,maxBrakeTime=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(velMag)maxBrakeDistance,maxBrakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local es=getDistanceDisplayString(distance)sysUpData(widgetDistanceText,'{"label": "distance", "value": "'..es..'"}')sysUpData(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..FormatTimeString(travelTime)..'", "unit":""}')es=getDistanceDisplayString(brakeDistance)sysUpData(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..es..'"}')sysUpData(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..FormatTimeString(brakeTime)..'", "unit":""}')es=getDistanceDisplayString(maxBrakeDistance)sysUpData(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..es..'"}')sysUpData(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..FormatTimeString(maxBrakeTime)..'", "unit":""}')sysUpData(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..stringf("%s",er)..'", "unit":""}')es=getDistanceDisplayString(AutopilotTargetOrbit)sysUpData(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..es..'"}')if atmosDensity>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not throttleMode and AtmoSpeedAssist and(AltitudeHold or Reentry or finalLand)then cmdThrottle(1)BrakeIsOn=false;WasInCruise=false end end;if atmosDensity==0 and WasInAtmo then if sysUpData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then sysAddData(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if sysUpData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then sysAddData(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if sysUpData(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then sysAddData(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if sysUpData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then sysAddData(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if sysUpData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then sysAddData(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else ee()end;if warpdrive~=nil then if jdecode(warpdrive.getData()).destination~="Unknown"and jdecode(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;HUD.DrawTanks()if shield_1 then HUD.DrawShield()end elseif e9=="oneSecond"then local function et(eu)local ev=0;damageMessage=""local ew=eleTotalMaxHp;local ex=0;local ey=0;local ez=0;local eA=0;local eB=""local eC=core.getElementHitPointsById;for V in pairs(elementsID)do local dY=0;local eD=0;eD=eleMaxHp(elementsID[V])dY=eC(elementsID[V])ex=ex+dY;if dY<eD then if dY==0 then ez=ez+1 else ey=ey+1 end;if repairArrows and#markers==0 then position=vec3(core.getElementPositionById(elementsID[V]))local B=position.x;local C=position.y;local cF=position.z;table.insert(markers,core.spawnArrowSticker(B,C,cF+1,"down"))table.insert(markers,core.spawnArrowSticker(B,C,cF+1,"down"))core.rotateSticker(markers[2],0,0,90)table.insert(markers,core.spawnArrowSticker(B+1,C,cF,"north"))table.insert(markers,core.spawnArrowSticker(B+1,C,cF,"north"))core.rotateSticker(markers[4],90,90,0)table.insert(markers,core.spawnArrowSticker(B-1,C,cF,"south"))table.insert(markers,core.spawnArrowSticker(B-1,C,cF,"south"))core.rotateSticker(markers[6],90,-90,0)table.insert(markers,core.spawnArrowSticker(B,C-1,cF,"east"))table.insert(markers,core.spawnArrowSticker(B,C-1,cF,"east"))core.rotateSticker(markers[8],90,0,90)table.insert(markers,core.spawnArrowSticker(B,C+1,cF,"west"))table.insert(markers,core.spawnArrowSticker(B,C+1,cF,"west"))core.rotateSticker(markers[10],-90,0,90)table.insert(markers,elementsID[V])end elseif repairArrows and#markers>0 and markers[11]==elementsID[V]then for eE in pairs(markers)do core.deleteSticker(markers[eE])end;markers={}end end;ev=mfloor(ex/ew*100)if ev<100 then if ev>0 and ev<WipeDamage then SavedLocations={}ATLAS.UpdateAtlasLocationsList()ATLAS.UpdateAutopilotTarget()SaveDataBank()end;eu[#eu+1]=svgText(0,0,"","pbright txt")eA=mfloor(ev*2.55)eB=stringf("rgb(%d,%d,%d)",255-eA,eA,0)if ev<100 then eu[#eu+1]=svgText("50%",1035,"Elemental Integrity: "..ev.."%","txtbig txtmid","fill:"..eB)if ez>0 then eu[#eu+1]=svgText("50%",1055,"Disabled Modules: "..ez.." Damaged Modules: "..ey,"txtbig txtmid","fill:"..eB)elseif ey>0 then eu[#eu+1]=svgText("50%",1055,"Damaged Modules: "..ey,"txtbig txtmid","fill:"..eB)end end end end;local function eF()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then sysDestWid(WeaponPanelID)WeaponPanelID=nil end end end;local function eG()local d_=systime()local eH=velMag;local eI=d_-lastTravelTime;if eH>1.38889 then eH=eH/1000;local eJ=eH*(d_-lastTravelTime)TotalDistanceTravelled=TotalDistanceTravelled+eJ;totalDistanceTrip=totalDistanceTrip+eJ end;flightTime=flightTime+eI;TotalFlightTime=TotalFlightTime+eI;lastTravelTime=d_ end;eG()HUD.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()eF()local eu={}HUD.ExtraData(eu)if ShouldCheckDamage then et(eu)end;lastOdometerOutput=table.concat(eu,"")collectgarbage("collect")elseif e9=="fiveSecond"then if not UseSatNav then return end;myAutopilotTarget=dbHud_1.getStringValue("SPBAutopilotTargetName")if myAutopilotTarget~=nil and myAutopilotTarget~=""and myAutopilotTarget~="SatNavNotChanged"then local ac=jdecode(dbHud_1.getStringValue("SavedLocations"))if ac~=nil then _G["SavedLocations"]=ac;local cY=-1;local dG;for V,W in pairs(SavedLocations)do if W.name and W.name=="SatNav Location"then cY=V;break end end;if cY~=-1 then dG=SavedLocations[cY]cY=-1;for V,W in pairs(b[0])do if W.name and W.name=="SatNav Location"then cY=V;break end end;if cY>-1 then b[0][cY]=dG end;ATLAS.UpdateAtlasLocationsList()msgText=dG.name.." position updated"end end;for i=1,#AtlasOrdered do if AtlasOrdered[i].name==myAutopilotTarget then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..AtlasOrdered[i].name)ATLAS.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif e9=="msgTick"then local eu={}HUD.DisplayMessage(eu,"empty")msgText="empty"unit.stopTimer("msgTick")msgTimer=3 elseif e9=="animateTick"then Animated=true;Animating=false;simulatedX=0;simulatedY=0;unit.stopTimer("animateTick")elseif e9=="hudTick"then HUD.hudtick()elseif e9=="apTick"then AP.APTick()elseif e9=="radarTick"then RADAR.UpdateRadar()elseif e9=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;msgText="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function eK(eL,eM)local eN=vec3()local eO=vec3()if eL==axisCommandId.longitudinal then eN=vec3(core.getConstructOrientationForward())eO=constructForward elseif eL==axisCommandId.vertical then eN=vec3(core.getConstructOrientationUp())eO=constructUp elseif eL==axisCommandId.lateral then eN=vec3(core.getConstructOrientationRight())eO=constructRight else return vec3()end;local eP=vec3(core.getWorldGravity())local eQ=eP:dot(eO)local eR=vec3(core.getWorldAirFrictionAcceleration())local eS=eR:dot(eO)local eT=coreVelocity:dot(eN)local eU=eM*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(eU-eT)local eV=targetSpeedPID2:get()local eW=(eV-eS-eQ)*eO;return eW end;local function eX(eL,eM)local eN=vec3()local eO=vec3()if eL==axisCommandId.longitudinal then eN=vec3(core.getConstructOrientationForward())eO=constructForward elseif eL==axisCommandId.vertical then eN=vec3(core.getConstructOrientationUp())eO=constructUp elseif eL==axisCommandId.lateral then eN=vec3(core.getConstructOrientationRight())eO=constructRight else return vec3()end;local eP=vec3(core.getWorldGravity())local eQ=eP:dot(eO)local eR=vec3(core.getWorldAirFrictionAcceleration())local eS=eR:dot(eO)local eT=coreVelocity:dot(eN)local eU=eM*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(eU-eT)local eV=targetSpeedPID:get()local eW=(eV-eS-eQ)*eO;return eW end;local function eY(eZ,e_,dt)local f0=eZ:cross(dt):normalize_inplace()local f1=math.acos(uclamp(f0:dot(-e_),-1,1))*constants.rad2deg;if f0:cross(-e_):dot(dt)<0 then f1=-f1 end;return f1 end;if antigrav and not ExternalAGG then if not antigravOn and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;throttleMode=navCom:getAxisCommandType(0)==axisCommandType.byThrottle;if throttleMode and WasInCruise then cmdThrottle(0)WasInCruise=false elseif not throttleMode and not WasInCruise then PlayerThrottle=0;WasInCruise=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local f2=uclamp(pitchInput+pitchInput2+system.getControlDeviceForwardInput(),-1,1)local f3=uclamp(rollInput+rollInput2+system.getControlDeviceYawInput(),-1,1)local f4=uclamp(yawInput+yawInput2-system.getControlDeviceLeftRightInput(),-1,1)local f5=brakeInput;worldVertical=vec3(core.getWorldVertical())if worldVertical==nil or worldVertical:len()==0 then worldVertical=(planet.center-worldPos):normalize()end;constructUp=vec3(core.getConstructWorldOrientationUp())constructForward=vec3(core.getConstructWorldOrientationForward())constructRight=vec3(core.getConstructWorldOrientationRight())constructVelocity=vec3(core.getWorldVelocity())coreVelocity=vec3(core.getVelocity())worldPos=vec3(core.getConstructWorldPos())coreMass=core.getConstructMass()velMag=vec3(constructVelocity):len()vSpd=-worldVertical:dot(constructVelocity)adjustedRoll=getRoll(worldVertical,constructForward,constructRight)local f6=adjustedRoll/180*math.pi;local f7=math.cos(f6)local f8=math.sin(f6)adjustedPitch=eY(worldVertical,constructForward,constructRight*f7+constructUp*f8)local f9=constructVelocity:normalize()local fa=mabs(adjustedRoll)local fb=utils.sign(adjustedRoll)local fc=vec3(core.getWorldAngularVelocity())local fd=f2*pitchSpeedFactor*constructRight+f3*rollSpeedFactor*constructForward+f4*yawSpeedFactor*constructUp;if autoRoll==true and worldVertical:len()>0.01 then local fe=mabs(targetRoll-adjustedRoll)if((ProgradeIsOn or Reentry or BrakeLanding or spaceLand or AltitudeHold or IntoOrbit)and fe>0 or atmosDensity>0.0 and fe<autoRollRollThreshold and autoRollPreference)and f3==0 and mabs(adjustedPitch)<85 then local ff=targetRoll;local fg=autoRollFactor;if atmosDensity==0 then fg=fg/4;targetRoll=0;ff=0 end;if rollPID==nil then rollPID=pid.new(fg*0.01,0,fg*0.1)end;rollPID:inject(ff-adjustedRoll)local fh=rollPID:get()fd=fd+fh*constructForward end end;local fi=1;local fj=0;local fk=1;local fl=system.getMouseWheel()if fl>0 then changeSpd()elseif fl<0 then changeSpd(true)else mousePause=true end;brakeInput2=0;if inAtmo and AtmoSpeedAssist and throttleMode then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(adjustedAtmoSpeedLimit/3.6-constructVelocity:dot(constructForward))local fm=throttlePID:get()calculatedThrottle=uclamp(fm,-1,1)if calculatedThrottle<PlayerThrottle and atmosDensity>0.005 then ThrottleLimited=true;navCom:setThrottleCommand(axisCommandId.longitudinal,uclamp(calculatedThrottle,0.01,1))else ThrottleLimited=false;navCom:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-adjustedAtmoSpeedLimit/3.6)local fn=uclamp(brakePID:get(),0,1)if atmosDensity>0 and vSpd<-80 or atmosDensity>0.005 then brakeInput2=fn end;if brakeInput2>0 then if ThrottleLimited and calculatedThrottle==0.01 then navCom:setThrottleCommand(axisCommandId.longitudinal,0)end else calculatedThrottle=uclamp(calculatedThrottle,0.01,1)end;local fo=''local fp=vec3()local fq=eK(axisCommandId.vertical,upAmount*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",fq,fj)local fr='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then fr=fr..ExtraLongitudeTags end;local fs=navCom:getAxisCommandType(axisCommandId.longitudinal)local ft=navCom:composeAxisAccelerationFromThrottle(fr,axisCommandId.longitudinal)local fu=eX(axisCommandId.lateral,LeftAmount*1000)fo=fo..' , '.."lateral airfoil , lateral ground "fp=fp+fu;if fp:len()>constants.epsilon then a:setEngineForceCommand(fo,fp,fj,'','','',fk)end;a:setEngineForceCommand(fr,ft,fi)local fv='thrust analog vertical fueled 'local fw='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then fw=fw..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then fv=fv..ExtraVerticalTags end;if upAmount~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(fv,fq,fi)else a:setEngineForceCommand(fv,vec3(),fi)end;if LeftAmount~=0 then a:setEngineForceCommand(fw,fu,fi)else a:setEngineForceCommand(fw,vec3(),fi)end;if f5==0 then f5=brakeInput2 end;local fx=-f5*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*f9)a:setEngineForceCommand('brake',fx)else if AtmoSpeedAssist then navCom:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;local eM=unit.getAxisCommandValue(0)if not throttleMode then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-eM/3.6)local fn=uclamp(brakePID:get(),0,1)f5=uclamp(f5+fn,0,1)end;local fx=-f5*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*f9)a:setEngineForceCommand('brake',fx)local fo=''local fp=vec3()local fy=false;local fr='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then fr=fr..ExtraLongitudeTags end;local fs=navCom:getAxisCommandType(axisCommandId.longitudinal)if fs==axisCommandType.byThrottle then local ft=navCom:composeAxisAccelerationFromThrottle(fr,axisCommandId.longitudinal)a:setEngineForceCommand(fr,ft,fi)elseif fs==axisCommandType.byTargetSpeed then local ft=navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)fo=fo..' , '..fr;fp=fp+ft;if navCom:getTargetSpeed(axisCommandId.longitudinal)==0 or navCom:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-navCom:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then fy=true end end;local fw='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then fw=fw..ExtraLateralTags end;local fz=navCom:getAxisCommandType(axisCommandId.lateral)if fz==axisCommandType.byThrottle then local fA=navCom:composeAxisAccelerationFromThrottle(fw,axisCommandId.lateral)a:setEngineForceCommand(fw,fA,fi)elseif fz==axisCommandType.byTargetSpeed then local fu=navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)fo=fo..' , '..fw;fp=fp+fu end;local fv='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then fv=fv..ExtraVerticalTags end;local fB=navCom:getAxisCommandType(axisCommandId.vertical)if fB==axisCommandType.byThrottle then local fq=navCom:composeAxisAccelerationFromThrottle(fv,axisCommandId.vertical)if upAmount~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(fv,fq,fi,'airfoil','ground','',fk)else a:setEngineForceCommand(fv,vec3(),fi)a:setEngineForceCommand('airfoil vertical',fq,fi,'airfoil','','',fk)a:setEngineForceCommand('ground vertical',fq,fi,'ground','','',fk)end elseif fB==axisCommandType.byTargetSpeed then if upAmount<0 then a:setEngineForceCommand('hover',vec3(),fi)end;local fC=navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)fo=fo..' , '..fv;fp=fp+fC end;if fp:len()>constants.epsilon then if brakeInput~=0 or fy or mabs(f9:dot(constructForward))<0.5 then fo=fo..', brake'end;a:setEngineForceCommand(fo,fp,fj,'','','',fk)end end;local fD=torqueFactor*(fd-fc)local fE=vec3(core.getWorldAirFrictionAngularAcceleration())fD=fD-fE;a:setEngineTorqueCommand('torque',fD,fi,'airfoil','','',fk)a:setBoosterCommand('rocket_engine')if isBoosting and not VanillaRockets then local bK=coreVelocity:len()local fF=0.15;if not throttleMode then local fG=navCom:getTargetSpeed(axisCommandId.longitudinal)if bK*3.6>fG*(1-fF)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif bK*3.6<fG*(1-fF)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local eg=unit.getThrottle()if AtmoSpeedAssist then eg=PlayerThrottle*100 end;local eM=eg/100;if atmosphere==0 then eM=eM*MaxGameVelocity;if bK>=eM*(1-fF)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif bK<eM*(1-fF)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local fH=mfloor(adjustedAtmoSpeedLimit)eM=eM*fH/3.6;if bK>=eM*(1-fF)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif bK<eM*(1-fF)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local dk=coroutine.status(beginSetup)if dk=="suspended"then local G,dl=coroutine.resume(beginSetup)if dl then system.print("ERROR STARTUP: "..dl)end elseif dk=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not Animating and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(fI)local function fJ(h)local f=1;local function fK(fL,h)local fM={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local fN=fL;for _,W in ipairs(fM)do if h and fN>W then fL=W elseif fL<W and not h then fL=W;break end end;return fL end;if h then f=-1 end;if not ExternalAGG and antigravOn then if holdingShift and h then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+f*antiGravButtonModifier;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+f*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if holdingShift then OrbitTargetOrbit=fK(OrbitTargetOrbit,h)else OrbitTargetOrbit=OrbitTargetOrbit+f*holdAltitudeButtonModifier end;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else if holdingShift and inAtmo then HoldAltitude=fK(HoldAltitude,h)else HoldAltitude=HoldAltitude+f*holdAltitudeButtonModifier end end else navCom:updateTargetGroundAltitudeFromActionStart(f*1.0)end end;local function fO(fP)if not inAtmo then msgText="Flight Assist in Atmo only"return end;local a2=type(fP)if ReversalIsOn==nil then if a2=="table"then if Autopilot or VectorToTarget then ToggleAutopilot()end;play("180On","BR")elseif fP==1 then play("bnkLft","BR")else play("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then ToggleAltitudeHold()if a2~="table"then fP=fP+1 end end;ReversalIsOn=fP else play("180Off","BR")ReversalIsOn=nil end end;if fI=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cmdThrottle(0)if vBooster or hover then if inAtmo and abvGndDet==-1 then play("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;autoRoll=true;GearExtended=false else if hasGear then play("grOut","LG",1)a.control.extendLandingGears()end;navCom:setTargetGroundAltitude(LandingGearGroundHeight)if inAtmo then BrakeIsOn=true end end end;if hasGear and not BrakeLanding and not(vBooster or hover)then play("grOut","LG",1)a.control.extendLandingGears()end else if hasGear then play("grIn","LG",1)a.control.retractLandingGears()end;navCom:setTargetGroundAltitude(TargetHoverHeight)end elseif fI=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif fI=="forward"then pitchInput=pitchInput-1 elseif fI=="backward"then if AltIsOn then fO(-constructVelocity*5000)else pitchInput=pitchInput+1 end elseif fI=="left"then if AltIsOn then fO(1)else rollInput=rollInput-1 end elseif fI=="right"then if AltIsOn then fO(3)else rollInput=rollInput+1 end elseif fI=="yawright"then yawInput=yawInput-1 elseif fI=="yawleft"then yawInput=yawInput+1 elseif fI=="straferight"then navCom:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif fI=="strafeleft"then navCom:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif fI=="up"then upAmount=upAmount+1;navCom:deactivateGroundEngineAltitudeStabilization()navCom:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif fI=="down"then upAmount=upAmount-1;navCom:deactivateGroundEngineAltitudeStabilization()navCom:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif fI=="groundaltitudeup"then fJ()elseif fI=="groundaltitudedown"then fJ(true)elseif fI=="option1"then toggleView=false;if AltIsOn and holdingShift then local fQ=""for i=1,#passengers do fQ=fQ.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..round(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..fQ)return end;ATLAS.adjustAutopilotTargetIndex()elseif fI=="option2"then toggleView=false;if AltIsOn and holdingShift then for i=1,#passengers do core.forceDeboard(passengers[i])end;msgText="Deboarded All Passengers"return end;ATLAS.adjustAutopilotTargetIndex(1)elseif fI=="option3"then local function fR()UnitHidden=not UnitHidden;if not UnitHidden then play("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else play("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then sysDestWid(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then sysDestWid(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then sysDestWid(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then sysDestWid(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then sysDestWid(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and holdingShift then local fQ=""for i=1,#ships do fQ=fQ.."| ID: "..ships[i].." Mass: "..round(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..fQ)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;fR()toggleView=false elseif fI=="option4"then toggleView=false;if AltIsOn and holdingShift then for i=1,#ships do core.forceUndock(ships[i])end;msgText="Undocked all ships"return end;ReversalIsOn=nil;ToggleAutopilot()elseif fI=="option5"then toggleView=false;function ToggleLockPitch()if LockPitch==nil then play("lkPOn","LP")if not holdingShift then LockPitch=adjustedPitch else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else play("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif fI=="option6"then toggleView=false;if AltIsOn and holdingShift then if shield_1 then local fS=shield_1.getVentingCooldown()if fS>0 then msgText="Cannot vent again for "..fS.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()msgText="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else msgText="Shields already at max hitpoints"end;return else msgText="No shield found"return end end;ToggleAltitudeHold()elseif fI=="option7"then toggleView=false;if AltIsOn and holdingShift then if shield_1 then shield_1.toggle()return else msgText="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then msgText="Collision System Enabled"else msgText="Collision System Secured"end elseif fI=="option8"then stablized=not stablized;if not stablized then msgText="DeCoupled Mode - Ground Stabilization off"navCom:deactivateGroundEngineAltitudeStabilization()play("gsOff","GS")else msgText="Coupled Mode - Ground Stabilization on"navCom:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)play("gsOn","GS")end;toggleView=false elseif fI=="option9"then if AltIsOn and holdingShift then navCom:resetCommand(axisCommandId.longitudinal)navCom:resetCommand(axisCommandId.lateral)navCom:resetCommand(axisCommandId.vertical)cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()gyroIsOn=gyro.getState()==1;if gyroIsOn then play("gyOn","GA")else play("gyOff","GA")end end;toggleView=false elseif fI=="lshift"then apButtonsHovered=false;if AltIsOn then holdingShift=true end;if sysIsVwLock()==1 then holdingShift=true;PrevViewLock=sysIsVwLock()sysLockVw(1)elseif isRemote()==1 and ShiftShowsRemoteButtons then holdingShift=true;Animated=false;Animating=false end elseif fI=="brake"then if BrakeToggleStatus or AltIsOn then BrakeToggle()elseif not BrakeIsOn then BrakeToggle()else BrakeIsOn=true end elseif fI=="lalt"then toggleView=true;AltIsOn=true;if isRemote()==0 and not freeLookToggle and userControlScheme=="keyboard"then sysLockVw(1)end elseif fI=="booster"then if VanillaRockets then a:toggleBoosters()elseif not isBoosting then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;isBoosting=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;isBoosting=false end elseif fI=="stopengines"then local function fT()if time-clearAllCheck<1.5 then play("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;ReversalIsOn=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;followMode=false;apThrottleSet=false;spaceLand=false;spaceLaunch=false;reentryMode=false;autoRoll=autoRollPreference;VectorToTarget=false;TurnBurn=false;gyroIsOn=false;LockPitch=nil;IntoOrbit=false end end;fT()clearAllCheck=time;if navCom:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if PlayerThrottle~=0 then navCom:resetCommand(axisCommandId.longitudinal)cmdThrottle(0)else cmdThrottle(100)end else if navCom:getTargetSpeed(axisCommandId.longitudinal)~=0 then navCom:resetCommand(axisCommandId.longitudinal)else if inAtmo then cmdCruise(AtmoSpeedLimit)else cmdCruise(MaxGameVelocity*3.6)end end end elseif fI=="speedup"then changeSpd()elseif fI=="speeddown"then changeSpd(true)elseif fI=="antigravity"and not ExternalAGG then if antigrav~=nil then ToggleAntigrav()end end end;function script.onActionStop(fI)local function fU()if not ExternalAGG and antigravOn then currentAggModifier=antiGravButtonModifier end;if AltitudeHold or VertTakeOff or IntoOrbit then currentHoldAltModifier=holdAltitudeButtonModifier end end;if fI=="forward"then pitchInput=0 elseif fI=="backward"then pitchInput=0 elseif fI=="left"then if ReversalIsOn then if ReversalIsOn==2 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;rollInput=0 elseif fI=="right"then if ReversalIsOn then if ReversalIsOn==4 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;rollInput=0 elseif fI=="yawright"then yawInput=0 elseif fI=="yawleft"then yawInput=0 elseif fI=="straferight"then navCom:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif fI=="strafeleft"then navCom:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif fI=="up"then upAmount=0;navCom:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then navCom:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif fI=="down"then upAmount=0;navCom:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then navCom:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif fI=="groundaltitudeup"then fU()toggleView=false elseif fI=="groundaltitudedown"then fU()toggleView=false elseif fI=="lshift"then if sysIsVwLock()==1 then simulatedX=0;simulatedY=0;sysLockVw(PrevViewLock)elseif isRemote()==1 and ShiftShowsRemoteButtons then Animated=false;Animating=false end;holdingShift=false elseif fI=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then BrakeToggle()else BrakeIsOn=false end end elseif fI=="lalt"then if isRemote()==0 and freeLookToggle then if toggleView then if sysIsVwLock()==1 then sysLockVw(0)else sysLockVw(1)end else toggleView=true end elseif isRemote()==0 and not freeLookToggle and userControlScheme=="keyboard"then sysLockVw(0)end;AltIsOn=false end end;function script.onActionLoop(fI)local function fV(h)local f=1;if h then f=-1 end;if not ExternalAGG and antigravOn then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+f*currentAggModifier;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;currentAggModifier=uclamp(currentAggModifier*1.05,antiGravButtonModifier,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+f*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then OrbitTargetOrbit=OrbitTargetOrbit+f*currentHoldAltModifier;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+f*currentHoldAltModifier end;currentHoldAltModifier=uclamp(currentHoldAltModifier*1.05,holdAltitudeButtonModifier,50)else navCom:updateTargetGroundAltitudeFromActionLoop(f*1.0)end end;local function fW(h)local f=1;if h then f=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn then PlayerThrottle=uclamp(PlayerThrottle+f*speedChangeSmall/100,-1,1)else navCom:updateCommandFromActionLoop(axisCommandId.longitudinal,f*speedChangeSmall)end end end;if fI=="groundaltitudeup"then if not holdingShift then fV()end elseif fI=="groundaltitudedown"then if not holdingShift then fV(true)end elseif fI=="speedup"then fW()elseif fI=="speeddown"then fW(true)end end;function script.onInputText(D)local function fX(fY,bP,dD)local function fZ(bP)local d=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aa='::pos{'..d..','..d..','..d..','..d..','..d..'}'local an,ao,av,aw,ax=stringmatch(bP,aa)if an=="0"and ao=="0"then return vec3(tonum(av),tonum(aw),tonum(ax))end;aw=math.rad(aw)av=math.rad(av)local planet=b[tonum(an)][tonum(ao)]local bf=math.cos(av)local f_=vec3(bf*math.cos(aw),bf*math.sin(aw),math.sin(av))return planet.center+(planet.radius+ax)*f_ end;local position=fZ(bP)return ATLAS.AddNewLocation(fY,position,dD)end;local i;local g0,g1=nil,nil;local g2="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(D," ")g0=D;if i~=nil then g0=string.sub(D,0,i-1)g1=string.sub(D,i+1)end;if g0=="/help"or g0=="/commands"then for g3 in string.gmatch(g2,"([^\n]+)")do system.print(g3)end;return elseif g0=="/setname"then if g1==nil or g1==""then msgText="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.UpdatePosition(g1)else msgText="Select a saved target to rename first"end elseif shield_1 and g0=="/resist"then if g1==nil or shield_1.getResistancesCooldown()>0 then msgText="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local d=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aa=d..', '..d..', '..d..', '..d;local g4,g5,g6,g7=stringmatch(g1,aa)if g7==nil or g4+g5+g6+g7>0.6 then msgText="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(g4,g5,g6,g7)==1 then msgText="Shield Resistances set"else msgText="Resistance setting failed."end elseif g0=="/addlocation"or string.find(D,"::pos")~=nil then local dD=false;local fY="0-Temp"if g1==nil or g1==""then g1=g0;dD=true end;i=string.find(g1,"::")if not dD then fY=string.sub(g1,1,i-2)end;local bP=string.sub(g1,i)fX(fY,bP,dD)elseif g0=="/agg"then if g1==nil or g1==""then msgText="Usage: /agg targetheight"return end;g1=tonum(g1)if g1<1000 then g1=1000 end;AntigravTargetAltitude=g1;msgText="AGG Target Height set to "..g1 elseif g0=="/G"then if g1==nil or g1==""then msgText="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if g1=="dump"then for V,W in pairs(saveableVariables())do if type(_G[W])=="boolean"then if _G[W]==true then system.print(W.." true")else system.print(W.." false")end elseif _G[W]==nil then system.print(W.." nil")else system.print(W.." ".._G[W])end end;return end;i=string.find(g1," ")local g8=string.sub(g1,0,i-1)local g9=string.sub(g1,i+1)for V,W in pairs(saveableVariables())do if W==g8 then msgText="Variable "..g8 .." changed to "..g9;local ga=type(_G[W])if ga=="number"then g9=tonum(g9)if W=="AtmoSpeedLimit"then adjustedAtmoSpeedLimit=g9 end elseif ga=="boolean"then if string.lower(g9)=="true"then g9=true else g9=false end end;_G[W]=g9;return end end;msgText="No such global variable: "..g8 elseif g0=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.ClearCurrentPosition()else msgText="Select a custom wp to delete first in IPH"end elseif g0=="/copydatabank"then if dbHud_2 then SaveDataBank(true)else msgText="Spare Databank required to copy databank"end elseif g0=="/iphWP"then if AutopilotTargetIndex>0 then system.print(AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords,true))msgText="::pos waypoint shown in lua chat"else msgText="No target selected in IPH"end end end;function script.onEnter(ao)if radars[1]and not inAtmo and not notPvPZone then unit.setTimer("contact",0.1)end end;function script.onLeave(ao)if radars[1]and CollisionSystem then if#contacts>650 then ao=tostring(ao)contacts[ao]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
