name: ArchHud - Archaegeo v0.748 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.748;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=true;K=false;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},freeLookToggle={set=function(M)i=M end,get=function()return i end},BrakeToggleDefault={set=function(M)j=M end,get=function()return j end},RemoteFreeze={set=function(M)k=M end,get=function()return k end},brightHud={set=function(M)m=M end,get=function()return m end},RemoteHud={set=function(M)l=M end,get=function()return l end},VanillaRockets={set=function(M)n=M end,get=function()return n end},InvertMouse={set=function(M)o=M end,get=function()return o end},autoRollPreference={set=function(M)p=M end,get=function()return p end},ExternalAGG={set=function(M)q=M end,get=function()return q end},UseSatNav={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},FullRadar={set=function(M)J=M end,get=function()return J end},ECUHud={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.2;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)ab=M end,get=function()return ab end},AutopilotInterplanetaryThrottle={set=function(M)a1=M end,get=function()return a1 end},warmup={set=function(M)a2=M end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingSpace={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingRocket={set=function(M)a5=M end,get=function()return a5 end},ContainerOptimization={set=function(M)a6=M end,get=function()return a6 end},FuelTankOptimization={set=function(M)a7=M end,get=function()return a7 end},AutoShieldPercent={set=function(M)a8=M end,get=function()return a8 end},EmergencyWarp={set=function(M)a9=M end,get=function()return a9 end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=0.0;aV="none"aW="none"aX="none"aY={speedChangeLarge={set=function(M)aE=M end,get=function()return aE end},speedChangeSmall={set=function(M)aF=M end,get=function()return aF end},MouseXSensitivity={set=function(M)aG=M end,get=function()return aG end},MouseYSensitivity={set=function(M)aH=M end,get=function()return aH end},autoRollFactor={set=function(M)aI=M end,get=function()return aI end},rollSpeedFactor={set=function(M)aJ=M end,get=function()return aJ end},autoRollRollThreshold={set=function(M)aK=M end,get=function()return aK end},minRollVelocity={set=function(M)aL=M end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(M)aM=M end,get=function()return aM end},torqueFactor={set=function(M)aN=M end,get=function()return aN end},pitchSpeedFactor={set=function(M)aO=M end,get=function()return aO end},yawSpeedFactor={set=function(M)aP=M end,get=function()return aP end},brakeSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeFlatFactor={set=function(M)aR=M end,get=function()return aR end},DampingMultiplier={set=function(M)aS=M end,get=function()return aS end},hudTickRate={set=function(M)aT=M end,get=function()return aT end},ExtraEscapeThrust={set=function(M)aU=M end,get=function()return aU end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end}}aZ=j;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=1000;bb=false;bc=false;bd=false;be=false;bf=0;bg="Aligning"bh=0;bi=1;bj="None"bk=nil;bl=0;bm=nil;bn=0.0;bo=0;bp={}bq=false;br=0;bs=0;bt=nil;bu=0;bv=1000;bw=0;bx=false;by=0;bz=false;bA="All"bB=true;bC="Off"bD=0.000;bE={}bF={}bG={}bH={VertTakeOff={set=function(M)b9=M end,get=function()return b9 end},VertTakeOffEngine={set=function(M)a_=M end,get=function()return a_ end},SpaceTarget={set=function(M)bx=M end,get=function()return bx end},BrakeToggleStatus={set=function(M)aZ=M end,get=function()return aZ end},BrakeIsOn={set=function(M)b0=M end,get=function()return b0 end},RetrogradeIsOn={set=function(M)b1=M end,get=function()return b1 end},ProgradeIsOn={set=function(M)b2=M end,get=function()return b2 end},Autopilot={set=function(M)b3=M end,get=function()return b3 end},TurnBurn={set=function(M)b4=M end,get=function()return b4 end},AltitudeHold={set=function(M)b5=M end,get=function()return b5 end},BrakeLanding={set=function(M)b6=M end,get=function()return b6 end},Reentry={set=function(M)b8=M end,get=function()return b8 end},AutoTakeoff={set=function(M)b7=M end,get=function()return b7 end},HoldAltitude={set=function(M)ba=M end,get=function()return ba end},AutopilotAccelerating={set=function(M)bb=M end,get=function()return bb end},AutopilotBraking={set=function(M)bd=M end,get=function()return bd end},AutopilotCruising={set=function(M)be=M end,get=function()return be end},AutopilotRealigned={set=function(M)bc=M end,get=function()return bc end},AutopilotEndSpeed={set=function(M)bf=M end,get=function()return bf end},AutopilotStatus={set=function(M)bg=M end,get=function()return bg end},AutopilotPlanetGravity={set=function(M)bh=M end,get=function()return bh end},PrevViewLock={set=function(M)bi=M end,get=function()return bi end},AutopilotTargetName={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetCoords={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetIndex={set=function(M)bl=M end,get=function()return bl end},TotalDistanceTravelled={set=function(M)bn=M end,get=function()return bn end},TotalFlightTime={set=function(M)bo=M end,get=function()return bo end},SavedLocations={set=function(M)bp=M end,get=function()return bp end},VectorToTarget={set=function(M)bq=M end,get=function()return bq end},LocationIndex={set=function(M)br=M end,get=function()return br end},LastMaxBrake={set=function(M)bs=M end,get=function()return bs end},LockPitch={set=function(M)bt=M end,get=function()return bt end},LastMaxBrakeInAtmo={set=function(M)bu=M end,get=function()return bu end},AntigravTargetAltitude={set=function(M)bv=M end,get=function()return bv end},LastStartTime={set=function(M)bw=M end,get=function()return bw end},iphCondition={set=function(M)bA=M end,get=function()return bA end},stablized={set=function(M)bB=M end,get=function()return bB end},UseExtra={set=function(M)bC=M end,get=function()return bC end},SelectedTab={set=function(M)bI=M end,get=function()return bI end},saveRoute={set=function(M)bE=M end,get=function()return bE end},apRoute={set=function(M)bF=M end,get=function()return bF end},ecuThrottle={set=function(M)bG=M end,get=function()return bG end}}local function bJ(b,c,bK,bL,bM)local a=DUSystem;local bN=DUConstruct;bO=bK()bP=0;bQ=0;bR=false;bS=0;bT=false;bU=false;bV=0;bW=0;bX=0;bY=0;bZ=false;b_=false;c0=false;c1="empty"c2=3;c3=false;c4=0;c5=0;c6=nil;c7=0;c8=0;c9=0;ca=false;cb=false;cc=false;cd=-1;ce=bM()>0;cf=bM()cg=b.getAltitude()ch=DUConstruct.getMass()ci=nil;cj=ac;ck=ad;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=p;cA=false;cB=W;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bN.getWorldOrientationForward())cI=vec3(bN.getWorldOrientationRight())cJ=vec3(bN.getVelocity())cK=vec3(bN.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bN.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or cg>0 and cg<200000;cZ=false;c_=nil;d0=false;d1=0;d2=nil;d3=nil;d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bN.getMaxSpeed()if shield then dg=bL(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dh(di)a.print(bO..": "..di)end;local function dj(d,b,c,a,dk,dl,dm,dn,dp)local function dq(dr)return type(dr)=='number'end;local function ds(dr)return type(dm(dr))=='number'end;local function dt(du)return type(du)=='table'end;local function dv(a)return type(a)=='string'end;local function dw(dx)return dt(dx)and dq(dx.x and dx.y and dx.z)end;local function dy(dz)return dt(dz)and dq(dz.latitude and dz.longitude and dz.altitude and dz.id and dz.systemId)end;local dA=math.pi/180;local dB=180/math.pi;local dC=1e-10;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local utils=utils;local vec3=vec3;local function dF(dr)local dG=string.gsub(string.reverse(dk('%.4f',dr)),'^0*%.?','')return dG==''and'0'or string.reverse(dG)end;local function dH(dI)if dw(dI)then return dk('{x=%.3f,y=%.3f,z=%.3f}',dI.x,dI.y,dI.z)end;if dt(dI)and not getmetatable(dI)then local dJ={}local dK=next(dI)if type(dK)=='nil'or dK==1 then dJ=dI else for dL,dx in pairs(dI)do local dM=dH(dx)if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end end;return dk('{%s}',table.concat(dJ,','))end;if dv(dI)then return dk("'%s'",dI:gsub("'",[[\']]))end;return tostring(dI)end;local dN={}dN.__index=dN;dN.__tostring=function(dI,dO)local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)local dJ={}for dQ,dL in ipairs(dP)do local dM=dH(dI[dL])if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end;if dO then return dk('%s%s',dO,table.concat(dJ,',\n'..dO))end;return dk('{%s}',table.concat(dJ,','))end;dN.__eq=function(dR,dS)return dR.systemId==dS.systemId and dR.id==dS.id and dp(dR.radius,dS.radius)and dp(dR.center.x,dS.center.x)and dp(dR.center.y,dS.center.y)and dp(dR.center.z,dS.center.z)and dp(dR.GM,dS.GM)end;local function dT(dU,dV,dW,dX,dY)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(dW),'Argument 3 (radius) must be a number:'..type(dW))assert(dt(dX),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dX))assert(ds(dY),'Argument 5 (GM) must be a number:'..type(dY))return setmetatable({systemId=dm(dU),id=dm(dV),radius=dm(dW),center=vec3(dX),GM=dm(dY)},dN)end;local dZ={}dZ.__index=dZ;dZ.__tostring=function(dh)return dk('::pos{%d,%d,%s,%s,%s}',dh.systemId,dh.id,dF(dh.latitude*dB),dF(dh.longitude*dB),dF(dh.altitude))end;dZ.__eq=function(dR,dS)return dR.id==dS.id and dR.systemId==dS.systemId and dp(dR.latitude,dS.latitude)and dp(dR.altitude,dS.altitude)and(dp(dR.longitude,dS.longitude)or dp(dR.latitude,math.pi/2)or dp(dR.latitude,-math.pi/2))end;local function d_(e0,dV,e1,e2,e3)local dU=e0;if dv(e0)and not e2 and not e3 and not dV and not e1 then dU,dV,e1,e2,e3=e4(e0,dE)assert(dU,'Argument 1 (position string) is malformed.')else assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(e1),'Argument 3 (latitude) must be in degrees:'..type(e1))assert(ds(e2),'Argument 4 (longitude) must be in degrees:'..type(e2))assert(ds(e3),'Argument 5 (altitude) must be in meters:'..type(e3))end;dU=dm(dU)dV=dm(dV)e1=dm(e1)e2=dm(e2)e3=dm(e3)if dV==0 then return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=dV,systemId=dU},dZ)end;return setmetatable({latitude=dA*dl(e1,-90,90),longitude=dA*(e2%360),altitude=e3,id=dV,systemId=dU},dZ)end;local e5={}e5.__index=e5;e5.__tostring=function(dI,dO)local e6=dO and dO..'  'local e7={}local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)for dQ,e8 in ipairs(dP)do e9=dI[e8]local ea=dN.__tostring(e9,e6)if dO then table.insert(e7,dk('[%s]={\n%s\n%s}',e8,ea,dO))else table.insert(e7,dk('  [%s]=%s',e8,ea))end end;if dO then return dk('\n%s%s%s',dO,table.concat(e7,',\n'..dO),dO)end;return dk('{\n%s\n}',table.concat(e7,',\n'))end;local function eb(ec)local e={}local pid;for dQ,dx in pairs(ec)do local dV=dx.planetarySystemId;if type(dV)~='number'then error('Invalid planetary s ID: '..tostring(dV))elseif pid and dV~=pid then error('Mistringmatch planetary s IDs: '..dV..' and '..pid)end;local ed=dx.bodyId;if type(ed)~='number'then error('Invalid body ID: '..tostring(ed))elseif e[ed]then error('Duplicate body ID: '..tostring(ed))end;setmetatable(dx.center,getmetatable(vec3.unit_x))e[ed]=setmetatable(dx,dN)pid=dV end;return setmetatable(e,e5)end;ee={}local function ef(ec)return setmetatable({galaxyAtlas=ec or{}},ee)end;ee.__index=function(du,M)if type(M)=='number'then local a=du.galaxyAtlas[M]return eb(a)end;return rawget(ee,M)end;ee.__pairs=function(dI)return function(du,dL)local eg,eh=next(du,dL)return eg,eh and eb(eh)end,dI.galaxyAtlas,nil end;ee.__tostring=function(dI)local ei={}for dQ,ej in pairs(dI or{})do local ek=ej:getPlanetarySystemId()local el=e5.__tostring(ej,'    ')table.insert(ei,dk('  [%s]={%s\n  }',ek,el))end;return dk('{\n%s\n}\n',table.concat(ei,',\n'))end;ee.BodyParameters=dT;ee.MapPosition=d_;ee.PlanetarySystem=eb;function ee.createBodyParameters(dU,dV,em,en,eo,ep,eq)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(em),'Argument 3 (surfaceArea) must be a number:'..type(em))assert(dt(en),'Argument 4 (aPosition) must be an array or vec3:'..type(en))assert(dt(eo),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eo))assert(ds(ep),'Argument 6 (altitude) must be in meters:'..type(ep))assert(ds(eq),'Argument 7 (gravityAtPosition) must be number:'..type(eq))local dW=dn(em/4/math.pi)local c9=dW+ep;local er=vec3(en)+c9*vec3(eo)local dY=eq*c9*c9;return dT(dU,dV,dW,er,dY)end;ee.isMapPosition=dy;function ee:getPlanetarySystem(e0)if M==nil then M=0 end;if eh==nil then eh=0 end;local dU=e0;if dy(e0)then dU=e0.systemId end;if type(dU)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eh)~=e5 then a=eb(a)end;return a end end end;function e5:sizeCalculator(es)return 1.05*es.radius end;function e5:castIntersections(et,eu,ev,ew,ex,ey)local ez={}if ex then for dQ,es in pairs(ex)do table.insert(ez,es)end else ez=d4 end;if not ey then table.sort(ez,function(eA,eB)local eC=eA.center;local eD=eB.center;return(eC.x-et.x)^2+(eC.y-et.y)^2+(eC.z-et.z)^2<(eD.x-et.x)^2+(eD.y-et.y)^2+(eD.z-et.z)^2 end)end;local eE=eu:normalize()for dQ,es in ipairs(ez)do local eF=es.center-et;local dW;if ev then dW=ev(es)else dW=self:sizeCalculator(es)end;local eG=eF:dot(eE)local eH=eG^2-(eF:len2()-dW^2)if eH>=0 then local eI=dn(eH)local eJ=eG+eI;local eK=eG-eI;if eK>0 then return es,eJ,eK elseif eJ>0 then return es,eJ,nil end end end;return nil,nil,nil end;function e5:closestBody(eL)assert(type(eL)=='table','Invalid coordinates.')local eM,es;local eN=vec3(eL)for dQ,eO in pairs(self)do local eP=(eO.center-eN):len2()if(not es or eP<eM)and eO.name~="Space"then es=eO;eM=eP end end;return es end;function e5:convertToBodyIdAndWorldCoordinates(e0)local eQ=e0;if dv(e0)then eQ=d_(e0)end;if eQ.id==0 then return 0,vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;local eO=self:getBodyParameters(eQ)if eO then return eQ.id,eO:convertToWorldCoordinates(eQ)end end;function e5:getBodyParameters(e0)local dV=e0;if dy(e0)then dV=e0.id end;assert(ds(dV),'Argument 1 (id) must be a number:'..type(dV))return self[dV]end;function e5:getPlanetarySystemId()local dQ,dx=next(self)return dx and dx.systemId end;function dN:convertToMapPosition(dX)assert(dt(dX),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dX))local eR=vec3(dX)if self.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=self.systemId},dZ)end;local eS=eR-self.center;local c9=eS:len()local e3=c9-self.radius;local e1=0;local e2=0;if not dp(c9,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/c9)end;return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=self.id,systemId=self.systemId},dZ)end;function dN:convertToWorldCoordinates(e0)local eQ=dv(e0)and d_(e0)or e0;if eQ.id==0 then return vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;assert(dy(eQ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eQ.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eQ.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eV=math.cos(eQ.latitude)return self.center+(self.radius+eQ.altitude)*vec3(eV*math.cos(eQ.longitude),eV*math.sin(eQ.longitude),math.sin(eQ.latitude))end;function dN:getAltitude(dX)return(vec3(dX)-self.center):len()-self.radius end;function dN:getDistance(dX)return(vec3(dX)-self.center):len()end;function dN:getGravity(dX)local eW=self.center-vec3(dX)local eX=eW:len2()return self.GM/eX*eW/dn(eX)end;return setmetatable(ee,{__call=function(dQ,...)return ef(...)end})end;local function eY(d,b,c,a,dn,eZ)local cp={}local bN=100000000/3600;local e_=bN*bN;local f0=100;function cp.computeAccelerationTime(f1,f2,f3)local f4=bN*math.asin(f1/bN)return(bN*math.asin(f3/bN)-f4)/f2 end;function cp.computeDistanceAndTime(f1,f3,f5,f6,f7,f8)f7=f7 or 0;f8=f8 or 0;local f9=f1<=f3;local fa=f6*(f9 and 1 or-1)/f5;local fb=-f8/f5;local fc=fa+fb;if f9 and fc<=0 or not f9 and fc>=0 then return-1,-1 end;local fd,fe=0,0;if fa~=0 and f7>0 then local f4=math.asin(f1/bN)local ff=math.pi*(fa/2+fb)local fg=fa*f7;local fh=bN*math.pi;local dx=function(du)local fi=(ff*du-fg*math.sin(math.pi*du/2/f7)+fh*f4)/fh;local fj=math.tan(fi)return bN*fj/dn(fj*fj+1)end;local fk=f9 and function(a)return a>=f3 end or function(a)return a<=f3 end;fe=2*f7;if fk(dx(fe))then local fl=0;while eZ(fe-fl)>0.5 do local du=(fe+fl)/2;if fk(dx(du))then fe=du else fl=du end end end;local fm=f1;local fn=fe/f0;for fo=1,f0 do local fp=dx(fo*fn)fd=fd+(fp+fm)*fn/2;fm=fp end;if fe<2*f7 then return fd,fe end;f1=fm end;local f4=bN*math.asin(f1/bN)local bO=(bN*math.asin(f3/bN)-f4)/fc;local fq=e_*math.cos(f4/bN)/fc;local c9=fq-e_*math.cos((fc*bO+f4)/bN)/fc;return c9+fd,bO+fe end;function cp.computeTravelTime(f1,f2,c9)if c9==0 then return 0 end;if f2>0 then local f4=bN*math.asin(f1/bN)local fq=e_*math.cos(f4/bN)/f2;return(bN*math.acos(f2*(fq-c9)/e_)-f4)/f2 end;if f1==0 then return-1 end;assert(f1>0,'Acceleration and initial speed are both zero.')return c9/f1 end;return cp end;local function fr(d,b,c,a,dk,dl,dm,dn,dp)local vec3=vec3;local dj=dj(d,b,c,a,dk,dl,dm,dn,dp)local function dv(a)return type(a)=='string'end;local function dt(du)return type(du)=='table'end;fs={}fs.__index=fs;function fs:escapeAndOrbitalSpeed(e3)assert(self.body)local c9=e3+self.body.radius;if not dp(c9,0)then local ft=dn(self.body.GM/c9)return dn(2)*ft,ft end;return nil,nil end;function fs:orbitalParameters(e0,fu)assert(self.body)assert(dt(e0)or dv(e0))assert(dt(fu))local fv=(dv(e0)or dj.isMapPosition(e0))and self.body:convertToWorldCoordinates(e0)or vec3(e0)local dx=vec3(fu)local fw=fv-self.body.center;local fx=dx:len2()local fy=fw:len()local fz=self.body.GM;local fA=((fx-fz/fy)*fw-fw:dot(dx)*dx)/fz;local eC=fz/(2*fz/fy-fx)local fB=fA:len()local eE=fA:normalize()local fC=eC*(1-fB)local fD=eC*(1+fB)local fE=fC*eE+self.body.center;local fF=fB<=1 and-fD*eE+self.body.center or nil;local fG=dn(eC*fz*(1-fB*fB))local fH=fF and 2*math.pi*dn(eC^3/fz)local fI=math.acos(fA:dot(fw)/(fB*fy))if fw:dot(dx)<0 then fI=-(fI-2*math.pi)end;local fJ=math.acos((math.cos(fI)+fB)/(1+fB*math.cos(fI)))local fK=fJ;if fK<0 then fK=fK+2*math.pi end;local fL=fK-fB*math.sin(fK)local fM=0;local fN=0;local fO=0;if fH~=nil then fM=fL/(2*math.pi/fH)fN=fH-fM;fO=fN+fH/2;if fI-math.pi>0 then fN=fM;fO=fN+fH/2 end;if fO>fH then fO=fO-fH end end;return{periapsis={position=fE,speed=fG/fC,circularOrbitSpeed=dn(fz/fC),altitude=fC-self.body.radius},apoapsis=fF and{position=fF,speed=fG/fD,circularOrbitSpeed=dn(fz/fD),altitude=fD-self.body.radius},currentVelocity=dx,currentPosition=fv,eccentricity=fB,period=fH,eccentricAnomaly=fJ,meanAnomaly=fL,timeToPeriapsis=fN,timeToApoapsis=fO,trueAnomaly=fI}end;local function fP(fQ)local eO=dj.BodyParameters(fQ.systemId,fQ.id,fQ.radius,fQ.center,fQ.GM)return setmetatable({body=eO},fs)end;return setmetatable(fs,{__call=function(dQ,...)return fP(...)end})end;local function fR(d,b,c,a,dbHud_1,e,fS,fT,bL,dm,dn,fU,fV)local function fW(fX)local dh=fY:closestBody(fX)if(fX-dh.center):len()>dh.radius+dh.noAtmosphericDensityAltitude then dh=e[0][0]end;return dh end;local function fZ()local function f_(g0,g1)return g0.name<g1.name end;cU={}for dL,dx in pairs(e[0])do cU[#cU+1]={name=dx.name,index=dL}end;table.sort(cU,f_)end;local function g2(g3,g4)if not g4 then g4=g5.name end;for dL,dx in pairs(g3)do if dx.name and dx.name==g4 then return dL end end;return-1 end;local function g6()d1=bl;if bl==0 then bj="None"c6=nil;g5=nil;return true end;local g7=cU[bl].index;local g8=e[0][g7]if g8.center then bj=g8.name;c6=co[0][g7]if g5~=nil then if cf==0 then if fS(g9,ga)~=1 then fT(g9,ga)end;if fS(gb,gc)~=1 then fT(gb,gc)end;if fS(gd,ge)~=1 then fT(gd,ge)end;if fS(gf,gg)~=1 then fT(gf,gg)end;if fS(gh,gi)~=1 then fT(gh,gi)end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end;if fS(gn,go)~=1 then fT(gn,go)end end;g5=nil else g5=g8;for dQ,dx in pairs(co[0])do if dx.name==g5.planetname then c6=dx;bj=g5.name;break end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end end;if g5==nil then bk=vec3(c6.center)else bk=g5.position end;if c6.planetname~="Space"then if c6.hasAtmosphere then gp=bL(c6.radius*(U-1)+c6.noAtmosphericDensityAltitude)else gp=bL(c6.radius*(U-1)+c6.surfaceMaxAltitude)end else gp=T end;if g5~=nil and g5.planetname=="Space"then bf=0 else dQ,bf=cq(c6):escapeAndOrbitalSpeed(gp)end;bh=0;bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"return true end;local function gq(gr)if not b3 and not bq and not cb and not bz and not b8 and not cc then if gr==nil then bl=bl+1;if bl>#cU then bl=0 end else bl=bl-1;if bl<0 then bl=#cU end end;if bl==0 then g6()else local g7=cU[bl].index;local g8=e[0][g7]if g8 and(g8~=nil and g8.name=="Space"or bA=="Custom Only"and g8.center or bA=="No Moons"and string.find(g8.name,"Moon")~=nil)then if gr==nil then gq()else gq(1)end else g6()end end else c1="Disengage autopilot before changing Interplanetary Helper"fU("iph","AP")end end;local function gs()local function gt(gu)local gv;if gu then gv=d9 else gv=bp end;local gw=-1;gw=g2(e[0])if gw>-1 then table.remove(e[0],gw)end;gw=-1;gw=g2(gv)if gw~=-1 then c1=g5.name.." saved location cleared"table.remove(gv,gw)end;gq()fZ()return gv end;if string.sub(bj,1,1)=="*"then d9=gt(true)else bp=gt(false)end end;local function gx(gy,fX,gz,gA)local function gB(gu)if gu then gv=d9 else gv=bp end;if dbHud_1 or gz or gu then local dh=fW(fX)local gC={position=fX,name=gy,planetname=dh.name,gravity=b.getGravityIntensity(),safe=gA}if not gz then gv[#gv+1]=gC else for dL,dx in pairs(e[0])do if dx.name and gy==dx.name then table.remove(e[0],dL)end end end;table.insert(e[0],gC)fZ()g6()c1="Location saved as "..gy.."("..dh.name..")"return gv else c1="Databank must be installed to save permanent locations"end end;if string.sub(gy,1,1)=="*"then d9=gB(true)else bp=gB(false)end end;local gD={}function gD.UpdateAtlasLocationsList()fZ()end;function gD.UpdateAutopilotTarget()g6()end;function gD.adjustAutopilotTargetIndex(gr)gq(gr)end;function gD.findAtlasIndex(g3,g4)return g2(g3,g4)end;function gD.UpdatePosition(gE,gF,gG)local function gH(gu)local gv;if gu then gv=d9 else gv=bp end;local gw=g2(gv)if gw~=-1 then if gE~=nil then if gu then gE="*"..gE end;gv[gw].name=gE;bl=bl-1;gq()elseif gG~=nil then if gG then local gI=cg;if gI<1000 then gI=1000 end;gv[gw].agg=fV(gI,0)c1=gv[gw].name.." AGG Altitude:"..gv[gw].agg.." saved ("..gv[gw].planetname..")"return elseif gG==false then gv[gw].agg=nil;c1=gv[gw].name.." AGG Altitude cleared ("..gv[gw].planetname..")"return end else local gJ=gv[gw]if gF then gJ.heading=cI:cross(cM)*5000;c1=gv[gw].name.." heading saved ("..gv[gw].planetname..")"return elseif gF==false then gJ.heading=nil;c1=gv[gw].name.." heading cleared ("..gv[gw].planetname..")"return end;gJ.gravity=b.getGravityIntensity()gJ.position=cO;gJ.safe=true end;c1=gv[gw].name.." position updated ("..gv[gw].planetname..")"else c1="Name Not Found"end end;if string.sub(bj,1,1)=="*"then gH(true)else gH(false)end end;function gD.AddNewLocation(gy,fX,gz,gA)gx(gy,fX,gz,gA)end;function gD.ClearCurrentPosition()gs()end;for dL,dx in pairs(da)do table.insert(e[0],dx)end;if gK then for dL,dx in pairs(gK)do gD[dL]=dx end end;fZ()if bl>#cU then bl=0 end;gD.UpdateAutopilotTarget()return gD end;local function gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU)local gP={}local gQ={}local gR={XS=13,S=27,M=55,L=110,XL=221}local gS={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gT={}local gU=0;local gV;local gW;local gX;local gY;local gZ={gY}local g_="Atmo"local h0;local h1;local h2=0;local h3={}local h4;local h5=0;local vec3=vec3;local h6=table.insert;local h7=-4;local h8={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h9,ha;local hb,hc;local function hd()if he~=nil and h2==0 then gM(he)a.destroyWidget(h9)a.destroyData(hb)h9,hb,he=nil,nil,nil;if h1~=nil then gM(h1)a.destroyWidget(ha)a.destroyData(hc)h1,ha,hc=nil,nil,nil end else if h2==1 then gM(he)he=nil;h1=a.createWidgetPanel("PeriWinkle")ha=a.createWidget(h1,'periscope')hc=gY.getWidgetDataId()a.addDataToWidget(hc,ha)end;if he==nil and gU>0 then he=a.createWidgetPanel(g_)h9=a.createWidget(he,'radar')hb=gY.getWidgetDataId()a.addDataToWidget(hb,h9)end;h2=0 end end;local function hf()local function hg(hh,hi,hj,hk,hl,hm,hn,ho)hi,hk,hm,ho=vec3(hi),vec3(hk),vec3(hm),vec3(ho)local hp,hq,hr=hh*hh,hj*hj,hl*hl;local fx=hk-hi;local hs=fx:normalize()local ht=fx:len()local hu=hm-hi;local hv=(hu-hu:project_on(hs)):normalize()local hw,hx=hu:dot(hs),hu:dot(hv)local hy=hw*hw+hx*hx;local hz=hs:cross(hv)local hA=(hp-hq+ht*ht)/(2*ht)local hB=(hp-hr+hy-2*hw*hA)/(2*hx)local dz=hp-hA^2-hB^2;local hC=dn(dz)local hD=hi+hs*hA+hv*hB+hz*hC;local hE=hi+hs*hA+hv*hB-hz*hC;if eZ((ho-hD):len()-hn)<eZ((ho-hE):len()-hn)then return hD else return hE end end;local function hF(hG,fy,hH)local hI=hG.pts;local gw=#hI;local hJ=hG.ref;if gw>3 then local hK,hL,hM,hN=hI[gw],hI[gw-1],hI[gw-2],hI[gw-3]hG.ref=hH;local fv=hg(hK[1],hK[2],hL[1],hL[2],hM[1],hM[2],hN[1],hN[2])local hA,hB,hC=fv.x,fv.y,fv.z;if hA==hA and hB==hB and hC==hC then hA=hA+hJ[1]hB=hB+hJ[2]hC=hC+hJ[3]local hO=vec3(hA,hB,hC)hG.center=hO;if hG.lastPos then if(hG.lastPos-hO):len()<2 then local hP=(hO-vec3(hH)):len()if eZ(hP-fy)<10 then hG.skipCalc=true end end end;hG.lastPos=hO end;hG.pts={}else local hQ={hH[1]-hJ[1],hH[2]-hJ[2],hH[3]-hJ[3]}hI[gw+1]={fy,hQ}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gY then gU=#gY.getConstructIds()if gU>0 then local hR=h4:gmatch('{"constructId[^}]*}[^}]*}')local hS=gY.hasMatchingTransponder;local hT=gY.getConstructKind;local hU=gY.isConstructAbandoned;local hV=gY.getConstructName;local hH={cO["x"],cO["y"],cO["z"]}local hW,hX=0,0;local hY=cL*10;local cY=cY;gX,gW=0,0;gQ={}for dx in hR do local dV,c9,hZ=dx:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local h_=gR[hZ]c9=dm(c9)if hS(dV)==1 then h6(gQ,dV)end;if not cV and warpdrive and c9<a9 and warpdrive.getStatus()==15 then c1="INITIATING WARP"c2=7;warpdrive.initiate()end;if E then local i0=hT(dV)local i1=F and hU(dV)==1;if i1 or c9<hY and(h_>27 or i0==4 or i0==6)then gX=gX+1;local gy=hV(dV)local hG=h3[dV]if hG==nil then h_=h_+gO;h3[dV]={pts={},ref=hH,name=gy,i=0,radius=h_,skipCalc=false}hG=h3[dV]end;if not hG.skipCalc then hF(hG,c9,hH)if i1 and not hG.abandoned and hG.center then local bO=a.getArkTime()if h5+5<bO then h5=bO;fU("abRdr","RD")end;a.print("Abandoned Construct: "..gy.." ("..hZ.." "..gS[i0]..") at estimated ::pos{0,0,"..hG.center.x..","..hG.center.y..","..hG.center.z.."}")c1="Abandoned Radar Contact ("..hZ.." "..gS[i0]..") detected"hG.abandoned=true end;hX=hX+1 else h6(gT,hG)end end;hW=hW+1;if cY and hW>700 or hX>70 or(not cY and hW>300 or hX>30)then coroutine.yield()hW,hX=0,0 end end end;gW=#gT;if gW>0 and(cL>20 or b6)then local es,i2,i3,i4;local i5=0;local i6=co:getPlanetarySystem(0)i4=cK:normalize()while i5<gW do coroutine.yield()local i7={table.unpack(gT,i5,math.min(i5+75,gW))}es,i2,i3=i6:castIntersections(cO,i4,nil,nil,i7,true)if es and i3 then c_={es,i2,i3}break end;i5=i5+75 end;if not es then c_=nil end else c_=nil end;gT={}gV=h4:find('identifiedConstructs":%[%]')end end end;local function i8()if gY then g_="Atmo"if h4:find('worksInAtmosphere":false')then g_="Space"end end end;function gP.pickType()i8()end;function gP.assignRadar()if radar_2 and h7~=1 then if h7==-1 then if gY==radar_2 then gY=radar_1 else gY=radar_2 end end;gZ={gY}h4=gY.getWidgetData()i8()else h4=gY.getWidgetData()end;h7=gY.getOperationalState()end;function gP.UpdateRadar()local i9=coroutine.status(h0)if i9=="suspended"then local dM,ia=coroutine.resume(h0)if ia then a.print("ERROR UPDATE RADAR: "..ia)end elseif i9=="dead"then h0=coroutine.create(hf)local dM,ia=coroutine.resume(h0)end end;function gP.GetRadarHud(ib,ic,ax,ay)local id,di;local dD=gW or 0;if gU>0 then if E then di=dD.."/"..gX.." Plotted : "..gU-gX.." Ignored"else di="Radar Contacts: "..gU end;id=gN(ax,ay,di,"pbright txtbig txtmid")if#gQ>0 then id=id..gN(ib,ic,"Friendlies In Range","pbright txtbig txtmid")for dL,dx in pairs(gQ)do ic=ic+20;id=id..gN(ib,ic,gY.getConstructName(dx),"pdim txtmid")end end;if gV==nil and h1==nil then h2=1;cu.ToggleRadarPanel()end;if gV~=nil and h1~=nil then cu.ToggleRadarPanel()end;if he==nil then cu.ToggleRadarPanel()end else if h7~=1 then id=gN(ax,ay,g_.." Radar: "..h8[h7],"pbright txtbig txtmid")else id=gN(ax,ay,"Radar: No "..g_.." Contacts","pbright txtbig txtmid")end;if he~=nil then h2=0;cu.ToggleRadarPanel()end end;return id end;function gP.GetClosestName(gy)if gY then local dV,dQ=gY.getWidgetData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dV~=nil and dV~=""then gy=gy.." "..gY.getConstructName(dV)end end;return gy end;function gP.ToggleRadarPanel()hd()end;function gP.ContactTick()if not ie then ie=0 end;if bO>ie+10 then c1="Radar Contact"fU("rdrCon","RC")ie=bO end;c.stopTimer("contact")end;function gP.onEnter(dV)if gY and not ce and not cV then c.setTimer("contact",0.1)end end;function gP.onLeave(dV)if gY and E then if#h3>650 then dV=tostring(dV)h3[dV]=nil end end end;local function ig()gY=nil;if radar_2 and radar_2.getOperationalState()==1 then gY=radar_2 else gY=radar_1 end;h7=gY.getOperationalState()gZ={gY}h4=gY.getWidgetData()i8()h0=coroutine.create(hf)if ih then for dL,dx in pairs(ih)do gP[dL]=dx end end end;ig()return gP end;local function ii(shield,e4,bL)local ij={}local ik=shield.getResistancesCooldown()local function il()local im=shield.isActive()if G then if not cV and im==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and im==1 then shield.toggle()end end end;local function io()local ip=shield.getStressRatioRaw()local iq=0.5999;if ip[1]==0.0 and ip[2]==0.0 and ip[3]==0.0 and ip[4]==0.0 then return end;local ir=shield.setResistances(iq*ip[1],iq*ip[2],iq*ip[3],iq*ip[4])if ir==1 then c1="Shield Resistances updated"else c1="Value Exceeded. Failed to update Shield Resistances"end end;function ij.shieldTick()dg=bL(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())il()ik=shield.getResistancesCooldown()if ik==0 and dg<a8 then io()end end;function ij.setResist(is)if not shield then c1="No shield found"return elseif is==nil or ik>0 then c1="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE=dD..', '..dD..', '..dD..', '..dD;local it,iu,iv,iw=e4(is,dE)if iw==nil or it+iu+iv+iw>0.6 then c1="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(it,iu,iv,iw)==1 then c1="Shield Resistances set"else c1="Resistance setting failed."end end;function ij.ventShield()local ix=shield.getVentingCooldown()if ix>0 then c1="Cannot vent again for "..ix.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c1="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c1="Shields already at max hitpoints"end end;if iy then for dL,dx in pairs(iy)do ij[dL]=dx end end;return ij end;local function iz(d,b,c,a,e,antigrav,hover,shield,warpdrive,iA,eZ,bL,dk,iB,bM,iC,iD,eU,bK,dl,iE,fT,fS,gM,iF,dn,fV,gN,fU,iG,iH,iI,iJ,iK,iL)local bN=DUConstruct;local iM=9.80665;local iN={}local iO={}local iP={}local iQ={}local iR=nil;local iS=nil;local iT=nil;local iU=false;local iV="none"local iW=""local iX=55;local iY=0;local iZ=0;local i_=nil;local j0=af;local j1=ag;local j2=ah;local j3=[[rgb(]]..bL(j0+0.5)..","..bL(j1+0.5)..","..bL(j2+0.5)..[[)]]local j4=[[rgb(]]..bL(j0*0.9+0.5)..","..bL(j1*0.9+0.5)..","..bL(j2*0.9+0.5)..[[)]]local j5=0;local j6=0;local j7=""local j8=bK()local j9=false;local ja=false;local function jb(dx)if cj==1920 then return dx else return fV(cj*dx/1920,0)end end;local function jc(dx)if ck==1080 then return dx else return fV(ck*dx/1080,0)end end;local function jd()return iF()==0 and g~="keyboard"and iD()==0 end;local function je()local jf="TRAVEL"if not cR then jf="CRUISE"end;if b3 then jf="AUTOPILOT"end;return jf end;local id=""local jg=""local jh=""local ji=1;local jj=2;local jk=3;local jl=4;local jm=5;local jn=6;local jo=7;local jp=""local jq=0;local jr=120.0*aT;local js={}local jt={}local ju={}local jv={}local jw={}local jx={}local jy={}jy["atmofueltank"],jy["spacefueltank"],jy["rocketfueltank"]=0,0,0;local jz=0;local function jA(hA,jB,jC,jD,jE,jF)local jG=jz;local jH=jz+5;if not B then jH=jH+5 end;if iD()==1 and not l then jG=jG-50;jH=jH-50 end;if jC=="ATMO"then jp="atmofueltank"elseif jC=="SPACE"then jp="spacefueltank"else jp="rocketfueltank"end;jq=_G[jp.."_size"]if#jD>0 then for M=1,#jD do local gy=jD[M][jj]local jI=jD[M][jo]for jJ=1,jq do if jD[M][jj]==iB(c[jp.."_"..jJ].getWidgetData()).name then jI=jJ;break end end;local jK=bK()if jE[M]==nil or jF[M]==nil or jK-jD[M][jn]>jr then local jL;local jM=0;jM=iC(jD[M][ji])-jD[M][jl]jL=jD[M][jm]if jL>jM then jy[jp]=jy[jp]+jL-jM end;if jI~=0 then local jN=iB(c[jp.."_"..jI].getWidgetData())jF[M]=jN.percentage;jE[M]=jN.timeLeft;if jE[M]=="n/a"then jE[M]=0 end else jF[M]=bL(0.5+jM*100/jD[M][jk])if jL<=jM then jE[M]=0 else jE[M]=bL(0.5+jM/((jL-jM)/(jK-jD[M][jn])))end end;jD[M][jn]=jK;jD[M][jm]=jM end;if gy==jB then gy=dk("%s %d",jC,M)end;if jI==0 then gy=gy.." *"end;local jO;if jE[M]==0 then jO=""else jO=iJ(jE[M])end;if jF[M]~=nil then local jP=bL(jF[M]*2.55)local jQ=dk("rgb(%d,%d,%d)",255-jP,jP,0)local jR=""if jO~=""and jE[M]<120 or jF[M]<5 then jR="red "end;local jS=dk("rgb(%d,%d,%d)",dl(bL((255-jP)/2.55),50,100),dl(bL(jP/2.55),0,50),50)local jT="rgb(196,0,255)"if jC=="ATMO"then jT="rgb(0,188,255)"elseif jC=="SPACE"then jT="rgb(239,255,0)"end;local jU=false;if jV~=jT then jU=true end;jV=jT;if B then if jU then jG=jG-5;jH=jH-5 end;jg=jg..dk([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jS,jT,hA,jH,jQ,bL(jF[M]*1.7+0.5)-2,hA+1,jH+1,hA+5,jH+14,gy,jF[M],jO)jG=jG-22;jH=jH-22 else jg=jg..gN(hA,jG,gy,jR.."pdim txtfuel")jg=jg..gN(hA,jH,dk("%d%% %s",jF[M],jO),"pdim txtfuel","fill:"..jQ)jG=jG+30;jH=jH+30 end end end end;jz=jG end;local function jW(jX,e3)if ap==0 and aq==0 then return end;if e3<200000 and not ce or e3 and ce then local jY=0;if eZ(cN)>1 then jY=45*math.log(eZ(cN),10)if cN<0 then jY=-jY end end;jX[#jX+1]=dk([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bL(cN),bL(jY))end;return jX end;local function jZ(j_)local gr=-cM;j_=j_-j_:project_on(gr)local k0=vec3(0,0,1)k0=k0-k0:project_on(gr)local k1=k0:cross(gr)local jY=k0:angle_between(j_)*constants.rad2deg;if j_:dot(k1)<0 then jY=360-jY end;return jY end;local function k2(jX,al,am,k3,k4,cY)if ae==0 then return end;local k5=ae;local k6=20;local k7=bL(k3)if cY then for M=-45,45,5 do local k8=M;jX[#jX+1]=dk([[<g transform="rotate(%f,%d,%d)">]],k8,al,am)k9=5;if M%15==0 then k9=15 elseif M%10==0 then k9=10 end;jX[#jX+1]=dk([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+k5+k6-k9,al,am+k5+k6)end;jX[#jX+1]=gN(al,am+k5+k6-35,k4,"pdim txt txtmid")jX[#jX+1]=gN(al,am+k5+k6-25,k7 .." deg","pdim txt txtmid")jX[#jX+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k3,al,am)jX[#jX+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+k5+k6-20,al+5,am+k5+k6-20,al,am+k5+k6-15)jX[#jX+1]="</g>"end;jX[#jX+1]=[[<g style="clip-path: url(#headingClip);">]]local ka=k7;if cY then ka=jZ(cH)end;local kb=20;local kc=bL(ka)local kd=0;local ke=am+k5+k6+20;local kf=al;if k4~="YAW"then ke=jc(130)kf=jb(960)end;local kg=[[<path class="txttick line" d="]]local kh=bL(kc-(kb+10)-kc%5+0.5)for M=kh+70,kh,-5 do local hA=kf-(-M*5+ka*5)if M%10==0 then kd=10;local dD=M;if dD==360 then dD=0 elseif dD>360 then dD=dD-360 elseif dD<0 then dD=dD+360 end;jX[#jX+1]=gN(hA,ke+15,dD,"txtmid bright")elseif M%5==0 then kd=5 end;if kd==10 then kg=dk([[%s M %f %f v %d]],kg,hA,ke-5,kd)else kg=dk([[%s M %f %f v %d]],kg,hA,ke-2.5,kd)end end;jX[#jX+1]=kg..[["/>]]jX[#jX+1]=dk([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kf-5,ke-20,kf+5,ke-20,kf,ke-10)if cY then k4="HDG"end;jX[#jX+1]=gN(jb(960),jc(100),kc.."°","dim txt txtmid size14","")jX[#jX+1]=gN(jb(960),jc(85),k4,"dim txt txtmid size20","")jX[#jX+1]=[[</g>]]end;local function ki(jX,kj,k3,al,am,cY,kk,fp)if ae==0 then return end;local k5=ae;local kl=bL(k5*3/5)if k5>0 then local km=bL(kj)local k9=0;local kg=dk([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k3,al,am)if not ce then kg=dk([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;jX[#jX+1]=dk([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k5-1,al,am)jX[#jX+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bL(km-30-km%5+0.5),bL(km+30+km%5+0.5),5 do if M%10==0 then k9=30 elseif M%5==0 then k9=20 end;local hB=am+-M*5+kj*5;if k9==30 then kg=dk([[%s M %d %f h %d]],kg,al-kl-k9,hB,k9)if ce then jX[#jX+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k3,al,am,al-kl+10,hB+4,M)jX[#jX+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k3,al,am,al+kl-10,hB+4,M)if M==0 or M==180 or M==-180 then jX[#jX+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k3,al,am,al-kl+20,hB,kl*2-40)end else jX[#jX+1]=gN(al-kl+10,hB,M,"pdim txt txtmid")jX[#jX+1]=gN(al+kl-10,hB,M,"pdim txt txtmid")end;kg=dk([[%s M %d %f h %d]],kg,al+kl,hB,k9)else kg=dk([[%s M %d %f h %d]],kg,al-kl-k9,hB,k9)kg=dk([[%s M %d %f h %d]],kg,al+kl,hB,k9)end end;jX[#jX+1]=kg..[["/>]]local kn="PITCH"if not cY then kn="REL PITCH"end;if kj>90 and not ce then kj=90-(kj-90)elseif kj<-90 and not ce then kj=-90-(kj+90)end;if k5>200 then if ce then if fp>iX then jX[#jX+1]=gN(al,am-15,"Yaw","pdim txt txtmid")jX[#jX+1]=gN(al,am+20,kk,"pdim txt txtmid")end;jX[#jX+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k3,al,am)else jX[#jX+1]=dk([[<g transform="rotate(0,%d,%d)">]],al,am)end;jX[#jX+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-kl+25,am-5,al-kl+20,am,al-kl+25,am+5,al-kl+50,am+4,km)jX[#jX+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+kl-25,am-5,al+kl-20,am,al+kl-25,am+5,al+kl-30,am+4,km)jX[#jX+1]="</g>"end;local ko=bL(k5/3)jX[#jX+1]=dk([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-ko,am,k5-ko)if not ce and cY then jX[#jX+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k3,al,am,al-kl+10,am,kl*2-20)end;jX[#jX+1]="</g>"if k5<200 then if ce and fp>iX then jX[#jX+1]=gN(al,am-k5,kn,"pdim txt txtmid")jX[#jX+1]=gN(al,am-k5+10,km,"pdim txt txtmid")jX[#jX+1]=gN(al,am-15,"Yaw","pdim txt txtmid")jX[#jX+1]=gN(al,am+20,kk,"pdim txt txtmid")else jX[#jX+1]=gN(al,am-k5,kn,"pdim txt txtmid")jX[#jX+1]=gN(al,am-k5+15,km,"pdim txt txtmid")end end end end;local function kp(jX,e3,cY)local kq=ar;local kr=as;if kq==0 and kr==0 then return end;local ks=78;local kt=19;local ku=cd;if cd~=-1 then jX[#jX+1]=gN(kq+ks,kr+kt+20,dk("AGL: %.1fm",cd),"pdim altsm txtend")end;if cY and(e3<200000 and not ce or e3 and ce)then table.insert(jX,dk([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kq-1,kr-4,ks+2,kt+6,kq+1,kr-1,ks-4,kt))local gw=0;local kv=1;local kw=0;local kx=e3<0;local ky=e3<kz.surfaceMaxAltitude;local kA=9;if kx then kA=0 end;local e3=eZ(e3)while gw<6 do local kB=11;local kC=16;local kD=9;local kE=14;local jR="altsm"if gw>2 then kC=kC+3;kB=kB+2;kE=kE+2;kD=kD-6;jR="altbig"end;if kx then jR=jR.." red"elseif ky then jR=jR.." orange"end;local kF=e3/kv%10;local kG=bL(kF)local kH=bL((kG+1)%10)local kI=kw;if gw==0 then kI=kF-kG;if kx then kI=1-kI end end;if kx and(gw==0 or kw~=0)then local gz=kH;kH=kG;kG=gz end;local kJ=kC*(kI-1)local kK=kJ+kC;local hA=kq+kD+(6-gw)*kB;local hB=kr+kE;jX[#jX+1]=gN(hA,hB+kJ,kH,jR)jX[#jX+1]=gN(hA,hB+kK,kG,jR)gw=gw+1;kv=kv*10;if kG==kA then kw=kI else kw=0 end end;table.insert(jX,[[</g></g>]])end end;local function kL(fu)local kM=-math.deg(eU(fu.y,fu.z))+180;kM=kM-90;if kM<0 then kM=360+kM end;if kM>180 then kM=-180+kM-180 end;return-kM end;local function kN(fu)local ka=math.deg(eU(fu.y,fu.x))-90;if ka<-180 then ka=360+ka end;return ka end;local function kO(jX,fu,fp,al,am)if fp>5 and not ce or fp>iX then local k5=ae;local kP=20;local kQ=20;local kR=kL(fu)local kS=kN(fu)local kT=14;local kU=kT/2;local kV=-kS/kQ*k5;local kW=kR/kP*k5;local hA=al+kV;local hB=am+kW;local c9=dn(kV^2+kW^2)local kX=[[<circle
                            cx="]]..hA..[["
                            cy="]]..hB..[["
                            r="]]..kU/kT..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hA..[["
                            cy="]]..hB..[["
                            r="]]..kU..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hA-kT..[[,]]..hB..[[ h ]]..kU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hA+kU..[[,]]..hB..[[ h ]]..kU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hA..[[,]]..hB-kT..[[ v ]]..kU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c9<k5 then jX[#jX+1]=kX else local jY=eU(kW,kV)local kY=4;local kZ=al+k5*math.cos(jY)local k_=am+k5*math.sin(jY)jX[#jX+1]=dk('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jY*180/math.pi,kZ,k_,kZ-kY,k_-kY/2,kY*2,kY,kZ+kY,k_-kY,kY,kY,-kY,kY)end;if not ce then local l0=vec3(fu)kR=kL(-l0)kS=kN(-l0)kV=-kS/kQ*k5;kW=kR/kP*k5;hA=al+kV;hB=am+kW;c9=dn(kV^2+kW^2)if c9<k5 then local l1=[[<circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hA..[[,]]..hB-kT..[[ v ]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hA..[[,]]..hB..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hA..[[,]]..hB..[[)" />
                                <path
                                    d="M ]]..hA-kU..[[,]]..hB..[[ h ]]..kT..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hA..[[,]]..hB..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hA..[[,]]..hB..[[)"/>]]jX[#jX+1]=l1 end end end end;local function l2(jX,jf,l3,l4)if an==0 and ao==0 then return end;l3=bL(l3+0.5)local jG=ao+10;local jH=ao+20;if iD()==1 and not l then jG=55;jH=65 end;local l5="CRUISE"local c="km/h"local dM=l4;if jf=="TRAVEL"or jf=="AUTOPILOT"then l5="THROT"c="%"dM=l3;local l6="dim"if l3<0 then l6="red"end;jX[#jX+1]=dk([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l6,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-eZ(l3),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;jX[#jX+1]=gN(an+10,jG,l5,"pbright txtstart")jX[#jX+1]=gN(an+10,jH,dk("%.0f %s",dM,c),"pbright txtstart")if ce and t and cR and bR then l3=bL(bS*100+0.5)local l6="red"if l3<0 then l6="red"end;jX[#jX+1]=dk([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l6,1-eZ(l3),an-10,ao+50,an-15,ao+53,an-15,ao+47)jX[#jX+1]=gN(an+10,jG+40,"LIMIT","pbright txtstart")jX[#jX+1]=gN(an+10,jH+40,l3 .."%","pbright txtstart")end;if ce and t or b8 then jX[#jX+1]=gN(an+10,jG-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not ce and b3 then jX[#jX+1]=gN(an+10,jG-40,"LIMIT: "..bL(ab*3.6+0.5).." km/h","dim txtstart")end end;local function l7(jX,l8)if an==0 and ao==0 then return end;local l9=ao-10;local la=an+10;jX[#jX+1]=gN(0,0,"","pdim txt txtend")if iD()==1 and not l then l9=75 end;jX[#jX+1]=gN(la,l9,bL(l8).." km/h","pbright txtbig txtstart")end;local lb=40;local function lc(jX)jX[#jX+1]=gN(jb(150),jc(1070),dk("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jX[#jX+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jX[#jX+1]=gN(jb(960),jc(550),"Warning: Invalid Control Scheme Detected","warnings")jX[#jX+1]=gN(jb(960),jc(600),"Keyboard Scheme must be selected","warnings")jX[#jX+1]=gN(jb(960),jc(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ld=jb(960)local le=jc(860)local lf=jc(880)local lg=jc(900)local lh=jc(960)local li=jc(200)local lj=jc(250)local lk=jc(960)if iD()==1 and not l then le=jc(135)lf=jc(155)lg=jc(175)li=jc(115)lj=jc(95)end;if b0 then local ll=""if type(b0)=="string"then ll="-"..b0 end;jX[#jX+1]=gN(ld,le,"Brake Engaged"..ll,"warnings")elseif bQ>0 then jX[#jX+1]=gN(ld,le,"Auto-Brake Engaged","warnings","opacity:"..bQ)end;if ce and cA and cd==-1 then if not b3 and not bq and not b6 and not cQ and not b9 and not b7 then jX[#jX+1]=gN(ld,li+50,"** STALL WARNING **","warnings")fU("stall","SW",2)end end;if cX then jX[#jX+1]=gN(ld,li+90,"Flight Assist in Progress","warnings")end;if ci then jX[#jX+1]=gN(ld,lk,"Gyro Enabled","warnings")end;if lm then lb=lb-1;if lb>20 then jX[#jX+1]=gN(ld,lk-20,"ECU Enabled","warnings")elseif lb<0 then lb=40 end end;if bm then if bU then jX[#jX+1]=gN(ld,lf,"Gear Extended","warn")else jX[#jX+1]=gN(ld,lf,"Landed (G: Takeoff)","warnings")end end;if cd>-1 and(not cQ or cg<100)then local ln=iI(d:getTargetGroundAltitude())jX[#jX+1]=gN(ld,lg,"Hover Height: "..ln,"warn")end;if c3 then jX[#jX+1]=gN(ld,lh+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not q and cQ and bv~=nil then local lo="warnings"if eZ(cg-antigrav.getBaseAltitude())<501 then lo="warn"end;jX[#jX+1]=gN(ld,li+40,dk("Target Altitude: %d Singularity Altitude: %d",bL(bv),bL(antigrav.getBaseAltitude())),lo)end;if b3 and bj~="None"then jX[#jX+1]=gN(ld,li,"Autopilot "..bg,"warn")elseif bt~=nil then jX[#jX+1]=gN(ld,li+20,dk("LockedPitch: %d",bL(bt)),"warn")elseif bZ then jX[#jX+1]=gN(ld,li+20,"Follow Mode Engaged","warn")elseif b8 or cc then jX[#jX+1]=gN(ld,li+20,"Re-entry in Progress","warn")end;if b5 or b9 then local ln=iI(ba,2)if b9 then if cQ then ln=iI(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jX[#jX+1]=gN(ld,li,"VTO to "..ln,"warn")elseif b7 and not bz then if cb then jX[#jX+1]=gN(ld,li,"Takeoff to "..bj,"warn")else jX[#jX+1]=gN(ld,li,"Takeoff to "..ln,"warn")end;if b0 and not b9 then jX[#jX+1]=gN(ld,li+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jX[#jX+1]=gN(ld,li,"Altitude Hold: "..dk("%.1fm",ba),"warn")end end;if b9 and(antigrav~=nil and antigrav)then if cf>0.1 then jX[#jX+1]=gN(ld,li+20,"Beginning ascent","warn")elseif cf<0.09 and cf>0.05 then jX[#jX+1]=gN(ld,li+20,"Aligning trajectory","warn")elseif cf<0.05 then jX[#jX+1]=gN(ld,li+20,"Leaving atmosphere","warn")end end;if bz then if cC~=nil then jX[#jX+1]=gN(ld,li,cC,"warn")end end;if b6 then if lp then local lq="Brake Landing"if dc then lq=lq.."-Aligning"end;if db then lq=lq.."-Drift Limited"end;jX[#jX+1]=gN(ld,li,lq,"warnings")else jX[#jX+1]=gN(ld,li,"Coast-Landing","warnings")end end;if b2 then jX[#jX+1]=gN(ld,li,"Prograde Alignment","crit")end;if b1 then jX[#jX+1]=gN(ld,li,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;jX[#jX+1]=gN(ld,lj+20,cZ,type)elseif cf==0 then local lr,ls=ct.checkLOS(cK:normalize())if ls~=nil then local ln=iI(ls)local lt=cp.computeTravelTime(cL,0,ls)local lu="Collision"if lr.noAtmosphericDensityAltitude>0 then lu="Atmosphere"end;jX[#jX+1]=gN(ld,lj+20,lr.name.." "..lu.." "..iJ(lt).." In "..ln,"crit")end end;if bq and not bz then jX[#jX+1]=gN(ld,li+60,lv,"warn")end;if d2 and#d2>1 then end;local lw=jb;local lx=jc;local ly="topButton"local lz="topButtonActive"local lA=ly;if b3 or bq or cb or bz then lA=lz end;local lB=ly;if b2 then lB=lz end;local lC=ly;if b6 or bm then lC=lz end;local lD=ly;if b5 or bq then lD=lz end;local lE=ly;if b1 then lE=lz end;local lF=ly;if bz or cE and b3 then lF=lz end;if w and I then local lG=lx(30)jX[#jX+1]=dk([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lA,lw(960),lx(54),lx(-53),lw(-120),lw(25),lx(50))jX[#jX+1]=gN(lw(910),lG,"AUTOPILOT")jX[#jX+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lB,lw(865),lx(51),lw(-25),lx(-50),lw(-110),lw(25),lx(46))jX[#jX+1]=gN(lw(800),lG,"PROGRADE")jX[#jX+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lC,lw(755),lx(47),lw(-25),lx(-46),lw(-98),lw(44),lx(44))jX[#jX+1]=gN(lw(700),lG,"LAND")jX[#jX+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lD,lw(960),lx(54),lx(-53),lw(120),lw(-25),lx(50))jX[#jX+1]=gN(lw(1010),lG,"ALT HOLD")jX[#jX+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,lw(1055),lx(51),lw(25),lx(-50),lw(110),lw(-25),lx(46))jX[#jX+1]=gN(lw(1122),lG,"RETROGRADE")jX[#jX+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lw(1165),lx(47),lw(25),lx(-46),lw(98),lw(-44),lx(44))jX[#jX+1]=gN(lw(1220),lG,"ORBIT")jX[#jX+1]=[[
                                    </g>
                                </g>]]jX[#jX+1]="</g>"end;return jX end;local function lH(fp)return bL(fV(fp*3.6,0)+0.5).." km/h"end;local function lI(gw)local gy=bj;if gw~=nil and type(gw)=="number"then if gw==0 then return"None"end;gy=cU[gw].name end;if gy==nil then gy=g5.name end;if gy==nil then gy="None"end;return gy end;local function lJ(jX)local lK=ct.routeWP(true)if not lK or#lK==0 then return end;local hA=jb(750)local hB=jc(360)if b3 or bq then jX[#jX+1]=gN(hA,hB,"REMAINING ROUTE","pdim txtstart size20")else jX[#jX+1]=gN(hA,hB,"LOADED ROUTE","pdim txtstart size20")end;for dL,M in pairs(lK)do hB=hB+20;jX[#jX+1]=gN(hA,hB,dL..". "..lK[dL],"pdim txtstart size20")end end;local function lL(jX)local hA=aB+10;local hB=aC+20;local lM={}local lN={"Alt-4: AutoTakeoff to Target"}local lO={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lP={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lQ={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lM,"--------------DYNAMIC-----------------")if ce then if cd~=-1 then iG(lM,lN)if c6 and kz and c6.name==kz.name then table.insert(lM,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or a_ then if antigrav then if cQ then table.insert(lM,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lM,"Turn on AGG to takeoff to AGG Height")end end;if a_ then table.insert(lM,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lM,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lM,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bm then table.insert(lM,"G: Takeoff to hover height, raise gear")else table.insert(lM,"G: Lowergear and Land")end else iG(lM,lO)table.insert(lM,"G: Begin BrakeLanding or Land")end;if b9 then table.insert(lM,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iG(lM,lP)if shield then table.insert(lM,"Alt-Shift-6: Vent shields")if not G then table.insert(lM,"Alt-Shift-7: Toggle shield off/on")end end end;if g5~=nil then table.insert(lM,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lM,"Alt-9: Activate Gyroscope")end;if aW~="none"or aV~="none"or aX~="none"then table.insert(lM,"Alt-Shift-9: Cycles engines with Extra tags")end;if b5 then table.insert(lM,"Alt-Spacebar/C will raise/lower target height")table.insert(lM,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not ce then table.insert(lM,"LALT+Mousewheel will lower/raise speed limit")end;iG(lM,lQ)for M=1,#lM do hB=hB+12;jX[#jX+1]=gN(hA,hB,lM[M],"pdim txtbig txtstart")end end;local function lR(jX)local lS=aB;local lT=aC;local lU=aA;local lV=4;local lW=15;local hA=0;local hB=0;local lX,lY,lZ,l_;local m0;local function m1(type)local gI,bO,fp,m2,jR,m3;if type=="Periapsis"then gI=m0.periapsis.altitude;bO=m0.timeToPeriapsis;fp=m0.periapsis.speed;jR="txtend"m2=12;m3=math.min(hA,lS+lU-kz.radius/lZ-lV*2)else gI=m0.apoapsis.altitude;bO=m0.timeToApoapsis;fp=m0.apoapsis.speed;m2=-12;jR="txtstart"m3=hA end;if cL<1 then bO=0 end;jX[#jX+1]=dk([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m3+m2,hB-5,hA,hB-5)jX[#jX+1]=dk([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m3-m2*4,hB+2,hA,hB+2)jX[#jX+1]=gN(m3,hB,type,jR)hA=m3-m2*2;hB=hB+lW;local ln=iI(gI)jX[#jX+1]=gN(hA,hB,ln,jR)hB=hB+lW;jX[#jX+1]=gN(hA,hB,iJ(bO),jR)hB=hB+lW;jX[#jX+1]=gN(hA,hB,lH(fp),jR)end;local m4=lU*1.5;if bI=="INFO"then m4=25*10 end;if bI=="ORBIT"and cg<kz.spaceEngineMinAltitude then return jX end;if bI~="HIDE"then jX[#jX+1]=[[<g class="pbright txtorb txtmid">]]jX[#jX+1]=dk('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lU*2,m4,lS,lT)jX[#jX+1]=dk([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lU*2,m4,lS,lT)end;local m5=lU*1.5;local m6=lU*2;local m7=m5/2;local m8=lU;local m9=lS+m8;local ma=lT+m7;local mb=lS+m6;local mc=lT+m5;if bI=="ORBIT"then lT=lT+lV;lX=lU/2;l_=0;m0={}m0.periapsis={}m0.apoapsis={}if ft~=nil then if ft.periapsis~=nil then m0.periapsis.altitude=ft.periapsis.altitude;m0.periapsis.speed=ft.periapsis.speed end;if ft.apoapsis~=nil then m0.apoapsis.altitude=ft.apoapsis.altitude;m0.apoapsis.speed=ft.apoapsis.speed end;m0.period=ft.period;m0.eccentricity=ft.eccentricity;m0.timeToApoapsis=ft.timeToApoapsis;m0.timeToPeriapsis=ft.timeToPeriapsis;m0.eccentricAnomaly=ft.eccentricAnomaly;m0.trueAnomaly=ft.trueAnomaly end;if m0.periapsis==nil then m0.periapsis={}m0.periapsis.altitude=-kz.radius;m0.periapsis.speed=ab end;if m0.eccentricity==nil then m0.eccentricity=1 end;if m0.apoapsis==nil then m0.apoapsis={}m0.apoapsis.altitude=cg;m0.apoapsis.speed=0 end;if cL<1 then m0.apoapsis.altitude=cg;m0.apoapsis.speed=0 end;if m0.apoapsis.altitude then lZ=(m0.apoapsis.altitude+m0.periapsis.altitude+kz.radius*2)/(lX*2)lY=(kz.radius+m0.apoapsis.altitude)/lZ*(1-m0.eccentricity)l_=lX-m0.periapsis.altitude/lZ-kz.radius/lZ;local md=math.pi;if m0.period~=nil and m0.period>0 and m0.timeToApoapsis~=nil then md=m0.eccentricAnomaly;if m0.timeToPeriapsis<m0.timeToApoapsis then md=2*math.pi-md end end;if cL<1 or md~=md then md=math.pi end;local me=-lX*math.cos(md)+lS+m8+lV;local mf=lY*math.sin(md)+lT+m7+lV;local mg=""jX[#jX+1]='<g clip-path="url(#orbitRect)">'jX[#jX+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mg,lS+lU+lV,lT+lU*1.5/2+lV,lX,lY)if lY<1 then jX[#jX+1]=dk([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lS+lU+lV-l_,lT+lU*1.5/2+lV,me,mf)end;jX[#jX+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lS+lU+lV-l_,lT+lU*1.5/2+lV,(kz.radius+kz.noAtmosphericDensityAltitude)/lZ)jX[#jX+1]=dk('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lS+lU+lV-l_,lT+lU*1.5/2+lV,(kz.radius+kz.noAtmosphericDensityAltitude)/lZ)jX[#jX+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lS+lU+lV,lT+lU*1.5/2+lV,lX,lY)jX[#jX+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lS+lU+lV-l_,lT+lU*1.5/2+lV,kz.radius/lZ)jX[#jX+1]='</g>'local mh=math.floor(kz.radius/lZ+0.5)hA=lS+lU+lV*4+lX;hB=lT+lU*1.5/2+5+lV;if m0.apoapsis~=nil and m0.apoapsis.speed<ab then m1("Apoapsis")end;hB=lT+lU*1.5/2+5+lV;hA=lS+lU-lV*2-lX;if m0.periapsis~=nil and m0.periapsis.speed<ab and m0.periapsis.altitude>0 then m1("Periapsis")end;jX[#jX+1]=gN(lS+lU+lV,lT+20+lV,kz.name,"txtorbbig")jX[#jX+1]=dk('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',me,mf)jX[#jX+1]=[[</g>]]return jX else jX[#jX+1]='<g clip-path="url(#orbitRect)">'local mi=""local mj=1.2*(mk-ml)/(lU*2)local mm=1.4*(mn-mo)/(lU*1.5)for dL,dx in pairs(e[0])do if dx.center then local hA=lS+lU+dx.center.x/mj;local hB=lT+lU*1.5/2+dx.center.y/mm;mi=mi..'<circle cx="'..hA..'" cy="'..hB..'" r="'..dx.radius/mj*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dx.name,"Moon")and not string.match(dx.name,"Sanctuary")and not string.match(dx.name,"Space")then mi=mi.."<text x='"..hA.."' y='"..hB+dx.radius/mj*30+20 .."' font-size='12' fill="..j3 .." text-anchor='middle' font-family='Montserrat'>"..dx.name.."</text>"end end end;local fv=vec3(bN.getWorldPosition())local hA=lS+lU+fv.x/mj;local hB=lT+lU*1.5/2+fv.y/mm;mi=mi..'<circle cx="'..hA..'" cy="'..hB..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mi=mi.."<text x='"..hA.."' y='"..hB-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iR=mj;iS=mm;local mp=fv+cK*1000000;local mq=lS+lU+mp.x/mj;local jH=lT+lU*1.5/2+mp.y/mm;mi=mi..'<line x1="'..hA..'" y1="'..hB..'" x2="'..mq..'" y2="'..jH..'" stroke="purple" stroke-width="1"/>'jX[#jX+1]=mi;jX[#jX+1]='</g>'end elseif bI=="INFO"then jX=cr.DrawOdometer(jX,j5,bn,j6)elseif bI=="HELP"then jX=lL(jX)elseif bI=="SCOPE"then jX[#jX+1]='<g clip-path="url(#orbitRect)">'local mr=d5;if cf>0 then table.sort(d4,function(eA,eB)local eC,eD=eA.center,eB.center;return(eC.x-cO.x)^2+(eC.y-cO.y)^2+(eC.z-cO.z)^2<(eD.x-cO.x)^2+(eD.y-cO.y)^2+(eD.z-cO.z)^2 end)end;local ms={}local mt={}local mu=120;local mv=nil;local mw=nil;for M,dx in ipairs(d4)do local gV=dx.center-cO;local mx=gV:len()local my=gV:normalize()local mz=gV:cross(cH):normalize()local mA=math.acos(mz:dot(cI))if mA~=mA then mA=0 end;if mz:cross(cI):dot(cH)<0 then mA=-mA end;local mB=gV:project_on_plane(cH):len()local mC=math.sin(mA)*math.asin(mB/mx)*constants.rad2deg;local mD=math.cos(mA)*math.asin(mB/mx)*constants.rad2deg;if my:dot(cH)<0 then mD=90*math.cos(mA)+90*math.cos(mA)-mD;mC=90*math.sin(mA)+90*math.sin(mA)-mC end;local hA=m9+mC/mr*m5;local hB=ma+mD/mr*m5;local mE=(hA-m9)*(hA-m9)+(hB-ma)*(hB-ma)local mF=math.asin((dx.radius+dx.surfaceMaxAltitude)/mx)*constants.rad2deg;if mF~=mF then mF=mr end;local hZ=mF/mr*m5;local mG=math.asin(dx.atmosphereRadius/mx)*constants.rad2deg;if mG~=mG then mG=mF end;local mH=mG/mr*m5;local c9=iI(mx,1)local mI=dx.name;local mJ=false;if hB>lT then if hB>mc then if hB-mH<=mc then mJ=true end else mJ=true end else if hB+mH>=lT then mJ=true end end;local mK=false;local mL=hA;if dx.systemId==0 then mL=hA+mu else mL=hA-mu end;if mL+mu>lS then if mL+mu>mb then if mL-mH-mu<=mb then mK=true end else mK=true end else if mL+mH+mu>=lS then mK=true end end;local mM={}mM.x=hA;mM.y=hB;mM.planet=dx;mM.atmoSize=mH;if not mv or mE<mv then mv=mE;mw=mM end;if mK and mJ then local mN=math.max(mH,5)if mE<mN*mN then mI=mI.." - "..c9 end;mM.size=hZ;mM.i=M;mM.displayString=mI;mM.distance=c9;mM.visible=true;mt[#mt+1]=mM else mM.visible=false end end;local mO=false;table.sort(mt,function(eC,eD)return eC.y<eD.y end)for dL,fy in ipairs(mt)do local dx,hZ,M,mH,hA,hB,mI,c9=fy.planet,fy.size,fy.i,fy.atmoSize,fy.x,fy.y,fy.displayString,fy.distance;local m3,mP,mQ,mR;local mS=15;local jR="pdim"if dx.systemId~=0 then mQ=jb(string.len(mI)*5)mS=-(15+mQ)mR=jc(10)jR="pdimfill"else mQ=jb(string.len(mI)*9)mR=jc(15)end;if hZ*2>mQ then m3=dl(hA,lS+mQ/2,mb-mQ/2)mP=dl(hB,lT+mR,mc-5)m3=dl(m3,hA-hZ+mQ/2,hA+hZ-mQ/2)mP=dl(mP,hB-hZ+mR,hB+hZ)else m3=hA+mS;mP=hB end;for mT,fy in pairs(ms)do local mU=fy.textPositions;local mV=mU.y-mP;if mT~=M and eZ(mV)<mU.height and mU.x+mU.width>m3 and mU.x<m3+mQ then if hZ>mQ then mP=dl(mP+mR,lT+15,mc-5)else mP=mU.y+mU.height+1 end end end;local mW=mI~=dx.name or m3<=m9 and m3+mQ>=m9 and mP-mR<=ma and mP>=ma;fy.hovered=mW;local mX=1;if mW then mX=2;if hZ*2<mQ then mX=10 end;if mI==dx.name then mI=mI.." - "..c9 end;jR="pbright"if dx.systemId~=0 then mQ=jb(string.len(mI)*5)mS=-(15+mQ)else mQ=jb(string.len(mI)*7)end;if hZ*2>mQ then m3=dl(hA,lS+mQ/2,mb-mQ/2)m3=dl(m3,hA-hZ+mQ/2,hA+hZ-mQ/2)else m3=hA+mS end end;ms[M]={}ms[M].textPositions={}ms[M].textPositions.y=mP;ms[M].textPositions.x=m3;ms[M].textPositions.width=mQ;ms[M].textPositions.height=mR;ms[M].output=""if hZ*2>mQ then jR=jR.." txtmid"else jR=jR.." txtstart"end;if mH-hZ>2 then ms[M].output=dk('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hA,hB,mH,j4,0.1*mX)end;ms[M].output=ms[M].output..dk('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hA,hB,hZ,j4,0.2*mX)if dx.systemId==0 then ms[M].output=ms[M].output..dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m3,mP,j3,jR,mI)if hZ*2<=mQ then ms[M].output=ms[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m3+mQ,mP+2,m3,mP+2,hA,hB)end else ms[M].output=ms[M].output..dk([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m3,mP,j4,jR,mI)if hZ*2<=mQ then ms[M].output=ms[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m3,mP+2,m3+mQ,mP+2,hA,hB)end end end;for dL=#d4,1,-1 do if ms[dL]then jX[#jX+1]=ms[dL].output end end;if mw~=nil and d5<90 and not mw.hovered then local mY=mw.planet.atmosphereRadius/mw.atmoSize;local mZ=dn(mv)*mY;local m_=iI(mZ,1)local mQ=jb(math.max(string.len(m_)*7,string.len(mw.planet.name)*7))local mR=jc(12)local m3=dl(mw.x+(m9-mw.x)/2,lS+mQ/2,mb-mQ/2)local mP=dl(mw.y+(ma-mw.y)/2,lT+mR*2,mc-5)jX[#jX+1]=dk("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mw.x,mw.y,m9,ma)jX[#jX+1]=dk([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m3,mP,"white",m_)if not mw.visible then jX[#jX+1]=dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m3,mP-mR,"white",mw.planet.name)end end;if cL>1 then local gV=cK;local my=gV:normalize()local mB=gV:project_on_plane(cH):len()local mz=gV:cross(cH):normalize()local mA=math.acos(mz:dot(cI))if mA~=mA then mA=0 end;if mz:cross(cI):dot(cH)<0 then mA=-mA end;local mC=math.sin(mA)*math.asin(mB/gV:len())*constants.rad2deg;local mD=math.cos(mA)*math.asin(mB/gV:len())*constants.rad2deg;if my:dot(cH)<0 then mD=90*math.cos(mA)+90*math.cos(mA)-mD;mC=90*math.sin(mA)+90*math.sin(mA)-mC end;local hA=m9+mC/mr*m5;local hB=ma+mD/mr*m5;local kT=14;local kU=kT/2;local kX=[[<circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kU/kT..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hA-kT..[[,]]..hB..[[ h ]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hA+kU..[[,]]..hB..[[ h ]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hA..[[,]]..hB-kT..[[ v ]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jX[#jX+1]=kX end;jX[#jX+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m9,ma-10,m9,ma+10)jX[#jX+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m9-10,ma,m9+10,ma)jX[#jX+1]='</g>'else return jX end end;local function n0(n1,n2)local n3;local n4=(n2-n1):normalize()local fw=(cO-n1):dot(n4)/n4:dot(n4)if fw<=0. then return(cO-n1):len()elseif fw>=(n2-n1):len()then return(cO-n2):len()end;local n5=n1+fw*n4;n3=(n5-cO):len()return n3 end;local function n6()local n3;local n7=nil;local n8=nil;local n9=nil;for dL,na in pairs(e[0])do if na.hasAtmosphere then local c9=n0(kz.center,na.center)if n7==nil or c9<n7 then n8=na;n7=c9;n9=kz end;if c6 and c6.hasAtmosphere and c6.name~=kz.name then local eP=n0(c6.center,na.center)if eP<n7 then n8=na;n7=eP;n9=c6 end end end end;local nb=jb(1770)local nc=jc(330)if n7 then local nd="txttick "local ne=500000;if n7<n8.radius+ne or n7<n9.radius+ne then if cV then nd="txttick red "else nd="txttick orange "end end;n3=iI(n7,2)iW=gN(nb,nc,"Pipe ("..n9.name.."--"..n8.name.."): "..n3,nd.."pbright txtmid")end end;local function nf(hA,hB,ng,nh,l5)local ni={x=hA,y=hB,width=ng,height=nh,label=l5}iQ[l5]=ni;return ni end;local function nj(nk,nl,ng,nh,hA,hB,nm,nn,no,np,jR)local ni={enableName=nk,disableName=nl,width=ng,height=nh,x=hA,y=hB,toggleVar=nm,toggleFunction=nn,drawCondition=no,hovered=false,class=jR}if np then table.insert(iP,ni)else table.insert(iO,ni)end;return ni end;local function nq(nr)if not iU then ns=false;nt=false;nu=false;w=true;return elseif nr=="handling"then ns=not ns;nt=false;nu=false elseif nr=="hud"then nt=not nt;ns=false;nu=false elseif nr=="physics"then nu=not nu;ns=false;nt=false end;if nu or nt or ns then iV=iH(nr)w=false else iV="none"w=true end end;local function nv()iU=not iU;if iU then iN=iP;c1="Tap SHIFT to see Settings"d6=w else iN=iO;c1="Tap SHIFT to see Control Buttons"nq()w=d6 end end;local function nw()local function nx(dx,dL)dx.set(not dx.get())if dx.get()then c1=dL.." set to true"else c1=dL.." set to false"end;if dL=="showHud"then d6=dx.get()elseif dL=="BrakeToggleDefault"then aZ=j elseif dL=="FullRadar"then if cu then cu.ToggleRadarPanel()cu=nil;J=false else J=true;ny.radarSetup()end end end;local nz=50;local nA=340;local hA=500;local hB=ck/2-400;local nB=0;for dL,dx in pairs(iH("boolean"))do if type(dx.get())=="boolean"then nj(dL,dL,nA,nz,hA,hB,function()return dx.get()end,function()nx(dx,dL)end,function()return true end,true)hB=hB+nz+20;if nB==9 then hA=hA+nA+20;hB=ck/2-400;nB=0 else nB=nB+1 end end end;nj("Control View","Control View",nA,nz,10,ck/2-500,function()return true end,nv,function()return true end,true)nj("View Handling Settings",'Hide Handling Settings',nA,nz,10,ck/2-(500-nz),function()return ns end,function()nq("handling")end,function()return true end,true)nj("View Hud Settings",'Hide Hud Settings',nA,nz,10,ck/2-(500-nz*2),function()return nt end,function()nq("hud")end,function()return true end,true)nj("View Physics Settings",'Hide Physics Settings',nA,nz,10,ck/2-(500-nz*3),function()return nu end,function()nq("physics")end,function()return true end,true)end;local function nC()local function gx()local fX=cO;local gy=kz.name..". "..#bp;if cu then gy=cu.GetClosestName(gy)end;return cs.AddNewLocation(gy,fX,false,true)end;local function nD()b4=not b4 end;local function nE(nF)if nF==1 then b2=not b2;b1=false else b1=not b1;b2=false end;b3=false;b5=false;bZ=false;b6=false;bt=nil;b8=false;b7=false end;local function nG(nH,nI)cs.UpdatePosition(nil,nH,nI)end;local function gs()cs.ClearCurrentPosition()end;local function nJ(gw)local lK=ct.routeWP(true)if lK and#lK>0 then return"Engage Route: "..lK[1]end;return"Engage Autopilot: "..lI(gw)end;local function nK(gw)local lK=ct.routeWP(true)if lK and#lK>0 then return"Next Route Point: "..lK[1]end;return"Disable Autopilot: "..lI(gw)end;local function nL()if iD()==1 then bZ=not bZ;if bZ then b3=false;b1=false;b2=false;b5=false;b8=false;b6=false;b7=false;nM=bm;bm=false;d.control.retractLandingGears()iE:setTargetGroundAltitude(Z)fU("folOn","F")else fU("folOff","F")b0="Follow Off"cz=p;bm=nM;if bm then d.control.deployLandingGears()iE:setTargetGroundAltitude(_)end end else c1="Follow Mode only works with Remote controller"bZ=false end end;local nz=50;local nA=260;local nN=jb(30)local nO=aB+aA*2+2;local nP=aC+1;nj("+","+",nN,nN,nO,nP+nN+1,function()return false end,function()d5=d5/8 end,function()return bI=="SCOPE"end,nil,"ZoomButton")nj("-","-",nN,nN,nO,nP,function()return false end,function()d5=math.min(d5*8,90)end,function()return bI=="SCOPE"end,nil,"ZoomButton")nj("0","0",nN,nN,nO,nP+nN*2+2,function()return false end,function()d5=90 end,function()return bI=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nQ=nj("Enable Brake Toggle","Disable Brake Toggle",nA,nz,cj/2-nA/2,ck/2+350,function()return aZ end,function()aZ=not aZ;if aZ then c1="Brakes in Toggle Mode"else c1="Brakes in Default Mode"end end)nj("Align Prograde","Disable Prograde",nA,nz,cj/2-nA/2-50-nQ.width,ck/2-nz+380,function()return b2 end,function()nE(1)end)nj("Align Retrograde","Disable Retrograde",nA,nz,cj/2-nA/2+nQ.width+50,ck/2-nz+380,function()return b1 end,nE,function()return cf==0 end)nR=nj(nJ,nK,600,60,cj/2-600/2,ck/2-60/2-330,function()return b3 or bq or cb or bz end,function()end)local M;local function nS(nT)local gw=d1+nT;if gw>#cU then gw=gw-#cU-1 end;if gw<0 then gw=#cU+gw end;return gw end;nU={}for M=0,10 do local nV=nj(function(eD)local gw=nS(eD.apExtraIndex)if b3 or bq or cb or bz then return"Redirect: "..lI(gw)end;return nJ(gw)end,function(eD)local gw=nS(eD.apExtraIndex)return nK(gw)end,600,60,cj/2-600/2,ck/2-60/2-330+60*M,function(eD)local gw=nS(eD.apExtraIndex)return gw==bl and(b3 or bq or cb or bz)end,function(eD)local gw=nS(eD.apExtraIndex)local nW=bl==gw;bl=gw;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not nW and not(b3 or bq or cb or bz)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nV.apExtraIndex=M;nU[M]=nV end;nj("Save Position","Save Position",200,nR.height,nR.x+nR.width+30,nR.y,function()return false end,gx,function()return bl==0 or g5==nil end)nj("Update Position","Update Position",200,nR.height,nR.x+nR.width+30,nR.y,function()return false end,function()nG(nil)end,function()return bl>0 and g5~=nil end)nj("Save Heading","Clear Heading",200,nR.height,nR.x+nR.width+30,nR.y+nR.height+20,function()return g5.heading~=nil end,function()if g5.heading~=nil then nG(false)else nG(true)end end,function()return bl>0 and g5~=nil end)nj("Save AGG Alt","Clear AGG Alt",200,nR.height,nR.x+nR.width+30,nR.y+nR.height*2+40,function()return g5.agg~=nil end,function()if g5.agg~=nil then nG(nil,false)else nG(nil,true)end end,function()return bl>0 and g5~=nil and antigrav end)nj("Clear Position","Clear Position",200,nR.height,nR.x-200-30,nR.y,function()return true end,gs,function()return bl>0 and g5~=nil end)nj("Save Route","Save Route",200,nR.height,nR.x-200-30,nR.y+nR.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)nj("Load Route","Clear Route",200,nR.height,nR.x-200-30,nR.y+nR.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b3 or bq then c1="Disable Autopilot before loading route"return else ct.routeWP(false,false,1)end end,function()return true end)nz=60;nA=300;local hA=0;local hB=ck/2-150;nj("Enable Check Damage","Disable Check Damage",nA,nz,hA,hB-nz-20,function()return s end,function()s=not s end)nj("View Settings","View Settings",nA,nz,hA,hB,function()return true end,nv)hB=hB+nz+20;nj("Enable Turn and Burn","Disable Turn and Burn",nA,nz,hA,hB,function()return b4 end,nD)hA=10;hB=ck/2-300;nj("Horizontal Takeoff Mode","Vertical Takeoff Mode",nA,nz,cj/2-nA/2,hB+20,function()return a_ end,function()a_=not a_;if a_ then c1="Vertical Takeoff Mode"else c1="Horizontal Takeoff Mode"end end,function()return cP end)hB=hB+nz+20;nj("Engage Orbiting","Cancel Orbiting",nA,nz,hA+nA+20,hB,function()return bz end,ct.ToggleIntoOrbit,function()return cf==0 and cY end)hB=ck/2-150;nj("Glide Re-Entry","Cancel Glide Re-Entry",nA,nz,hA+nA+20,hB,function()return b8 end,function()ca=1;nE(1)end,function()return kz.hasAtmosphere and not ce end)hB=hB+nz+20;nj("Parachute Re-Entry","Cancel Parachute Re-Entry",nA,nz,hA+nA+20,hB,function()return b8 end,function()ca=2;nE(1)end,function()return kz.hasAtmosphere and not ce end)hB=hB+nz+20;nj("Engage Follow Mode","Disable Follow Mode",nA,nz,hA,hB,function()return bZ end,nL,function()return iD()==1 end)nj("Enable Repair Arrows","Disable Repair Arrows",nA,nz,hA+nA+20,hB,function()return j9 end,function()j9=not j9;if j9 then c1="Repair Arrows Enabled"else c1="Repair Arrows Diabled"end end,function()return iD()==1 end)hB=hB+nz+20;if not q then nj("Enable AGG","Disable AGG",nA,nz,hA,hB,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;nj(function()return dk("Switch IPH Mode - Current: %s",bA)end,function()return dk("IPH Mode: %s",bA)end,nA*2,nz,hA,hB,function()return false end,function()if bA=="All"then bA="Custom Only"elseif bA=="Custom Only"then bA="No Moons"else bA="All"end;c1="IPH Mode: "..bA end)hB=hB+nz+20;nj(function()return dk("Toggle Control Scheme - Current: %s",g)end,function()return dk("Control Scheme: %s",g)end,nA*2,nz,hA,hB,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c1="New Control Scheme: "..g end)local nX=jc(20)local nV=nf(0,0,jb(70),nX,"HELP")nV=nf(nV.x+nV.width,nV.y,jb(80),nX,"INFO")nV=nf(nV.x+nV.width,nV.y,jb(70),nX,"ORBIT")nV=nf(nV.x+nV.width,nV.y,jb(70),nX,"SCOPE")nf(nV.x+nV.width,nV.y,jb(70),nX,"HIDE")end;local nY={}local nZ=nil;function nY.HUDPrologue(jX)if not cV then j0=ai;j1=aj;j2=ak else j0=af;j1=ag;j2=ah end;j3=[[rgb(]]..bL(j0+0.6)..","..bL(j1+0.6)..","..bL(j2+0.6)..[[)]]j4=[[rgb(]]..bL(j0*0.8+0.5)..","..bL(j1*0.8+0.5)..","..bL(j2*0.8+0.5)..[[)]]local n_=j3;local o0=j4;local o1=[[rgb(]]..bL(j0*0.4+0.5)..","..bL(j1*0.4+0.5)..","..bL(j2*0.4+0.5)..[[)]]local o2=j3;local o3=j4;local o4=o1;if jd()and not m then n_=[[rgb(]]..bL(j0*0.5+0.5)..","..bL(j1*0.5+0.5)..","..bL(j2*0.5+0.5)..[[)]]o0=[[rgb(]]..bL(j0*0.3+0.5)..","..bL(j1*0.3+0.5)..","..bL(j2*0.2+0.5)..[[)]]o1=[[rgb(]]..bL(j0*0.2+0.5)..","..bL(j1*0.2+0.5)..","..bL(j2*0.2+0.5)..[[)]]end;local lw=jb;local lx=jc;jX[#jX+1]=dk([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],n_,n_,n_,o2,o2,o0,o0,o3,o3,o0,n_,o1,o3,n_,n_,o1,o1,o4,o1,cj,ck,o0,o0,o0,o0,o0,o2,o0,o3,o4,o3,o3,o4)if not nZ then nZ=dk([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lw(630),lx(0),lw(675),lx(45),lw(960),lx(55),lw(1245),lx(45),lw(1290),lx(0),lw(1000),lx(105),lw(1040),lx(59),lw(1250),lx(51),lw(1300),lx(0),lw(1920),lx(0),lw(1920),lx(20),lw(1400),lx(20),lw(1300),lx(105),lw(920),lx(105),lw(880),lx(59),lw(670),lx(51),lw(620),lx(0),lw(0),lx(0),lw(0),lx(20),lw(520),lx(20),lw(620),lx(105),lw(890),lx(59),lw(960),lx(62),lw(1030),lx(59),lw(985),lx(112),lw(1150),lx(112),lw(1100),lx(152),lw(820),lx(152),lw(780),lx(112),lw(935),lx(112),lw(890),lx(59),lw(960),lx(62),lw(1030),lx(59),lw(985),lx(112),lw(1150),lx(112),lw(1100),lx(152),lw(820),lx(152),lw(780),lx(112),lw(935),lx(112))end;if w and I then jX[#jX+1]=nZ end;return jX end;function nY.DrawVerticalSpeed(jX,e3)jW(jX,e3)end;function nY.UpdateHud(jX)local kM=cS;local o5=cT;local k3=o5;local kj=kM;local l3=bL(c.getThrottle())local l8=cL*3.6;local l4=c.getAxisCommandValue(0)local o6=jb(1770)local o7=jc(310)if t and cR then l4=bP;l3=bP*100 end;local jf=je()local k4="ROLL"if l3==nil then l3=0 end;if not cY then if cL>5 then kM=kL(cJ)o5=kN(cJ)else kM=0;o5=0 end;k4="YAW"end;if cW>50000 and not ce then local o8;o8=iI(cW)jX[#jX+1]=gN(o6,o7,"PvP Boundary: "..o8,"pbright txtbig txtmid")end;jX[#jX+1]=j7;jX[#jX+1]=id;if iW~=""then jX[#jX+1]=iW end;if jg~=""then jX[#jX+1]=jg end;if jh~=""then jX[#jX+1]=jh end;jW(jX,cg)if iD()==0 or l then if not jd()or m then if cY then k2(jX,al,am,k3,k4,cY)ki(jX,kj,k3,al,am,cY,bL(kN(cJ)),cL)else k2(jX,al,am,o5,k4,cY)ki(jX,kM,o5,al,am,cY,bL(o5),cL)end;kp(jX,cg,cY)kO(jX,cJ,cL,al,am)end end;l2(jX,jf,l3,l4)l7(jX,l8)lc(jX)lR(jX)if not iU and b_ then lJ(jX)end;return jX end;function nY.HUDEpilogue(jX)jX[#jX+1]="</svg>"return jX end;function nY.ExtraData(jX)local o9=jb(1240)local oa=jc(55)local ob=oa+10;local oc;local lw=jb;local lx=jc;local od=0;local jf=je()if a_ then jf=jf.."-VERTICAL"end;if E and not b7 and not b6 and cL>20 then jf=jf.."-COLLISION ON"end;if bC~="Off"then jf="("..bC..")-"..jf end;if b4 then jf="TB-"..jf end;if not bB then jf=jf.."-DeCoupled"end;local oe=lx(99)local of=lx(80)local og=lx(85)local oh=lx(31)local oi=0;local oj=0;local ok=ch>1000000 and fV(ch/1000000,2).."kT"or fV(ch/1000,2).."T"if ce then od=bu else od=bs end;local ol,om=cp.computeDistanceAndTime(cL,0,ch,0,0,od)if ol<0 then ol=0 end;od=fV(od/(ch*iM),2).."g"local on=d:maxForceForward()oc=b.getGravityIntensity()if oc>0.1 then oj=ch*oc;oj=fV(oj/(ch*iM),2).."g"oi=0.5*on/oc;oi=oi>1000000 and fV(oi/1000000,2).."kT"or fV(oi/1000,2).."T"end;on=fV(on/(ch*iM),2).."g"local oo=vec3(bN.getWorldAcceleration()):len()/9.80665;oc=b.getGravityIntensity()jX[#jX+1]=[[<g class="dim txt txtend size14">]]if iD()==1 and not l then o9=jb(1120)oa=jc(55)ob=oa+10 elseif ce and I then local op=jb(770)jX[#jX+1]=gN(lw(895),oe,"ATMO","")jX[#jX+1]=dk([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lw(895),og,lw(-80))jX[#jX+1]=gN(lw(815),of,dk("%.1f%%",cf*100),"txtstart size20")end;if I then jX[#jX+1]=gN(lw(1025),oe,"GRAVITY","txtstart")jX[#jX+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(1025),og,lw(80))jX[#jX+1]=gN(lw(1105),of,dk("%.2fg",oc/9.80665),"size20")jX[#jX+1]=gN(lw(1125),oe,"ACCEL","txtstart")jX[#jX+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(1125),og,lw(80))jX[#jX+1]=gN(lw(1205),of,dk("%.2fg",oo),"size20")jX[#jX+1]=gN(lw(695),oe,"BRK TIME","")jX[#jX+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(695),og,lw(-80))jX[#jX+1]=gN(lw(615),of,dk("%s",iJ(om)),"txtstart size20")jX[#jX+1]=gN(lw(635),lx(45),"TRIP","")jX[#jX+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(635),lx(31),lw(-90))if lt then jX[#jX+1]=gN(lw(545),lx(26),dk("%s",iJ(lt)),"txtstart size20")end;jX[#jX+1]=gN(lw(795),oe,"BRK DIST","")jX[#jX+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(795),og,lw(-80))jX[#jX+1]=gN(lw(715),of,dk("%s",iI(ol)),"txtstart size20")jX[#jX+1]=gN(lw(1285),lx(45),"MASS","txtstart")jX[#jX+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(1285),lx(31),lw(90))jX[#jX+1]=gN(lw(1375),lx(26),dk("%s",ok),"size20")jX[#jX+1]=gN(lw(1220),oe,"THRUST","txtstart")jX[#jX+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(1220),og,lw(80))jX[#jX+1]=gN(lw(1300),of,dk("%s",on),"size20")jX[#jX+1]=gN(jb(960),jc(175),jf,"pbright txtbig txtmid size20")end;jX[#jX+1]="</g>"end;local oq=1-(a6*0.05+a7*0.05)function nY.FuelUsed(os)local ot;if os=="atmofueltank"then ot=dk("Atmo Fuel Used: %.1f L",jy[os]/(4*oq))elseif os=="spacefueltank"then ot=dk("Space Fuel Used: %.1f L",jy[os]/(6*oq))else ot=dk("Rocket Fuel Used: %.1f L",jy[os]/(0.8*oq))end;return ot end;local ou,ov,ow,ox,oy=0,0,0,{},0;function nY.DrawOdometer(jX,j5,bn,j6)if bI~="INFO"then return jX end;local oc;local oi=0;local oj=0;local od=0;local ok=ch>1000000 and fV(ch/1000000,2).." kTons"or fV(ch/1000,2).." Tons"if ce then od=bu else od=bs end;local ol,om=cp.computeDistanceAndTime(cL,0,ch,0,0,od)od=fV(od/(ch*iM),2).." g"local on=d:maxForceForward()oc=b.getGravityIntensity()if oc>0.1 then oj=ch*oc;oj=fV(oj/(ch*iM),2).." g"oi=0.5*on/oc;oi=oi>1000000 and fV(oi/1000000,2).." kTons"or fV(oi/1000,2).." Tons"end;on=fV(on/(ch*iM),2).." g"if iD()==0 or l then local oz=jb(aB+10)local oA=jc(aC+20)local oB=jb(aB+10+aA/1.25)local nh=25;local oC=bL(1/aT)if ow<oC then oy=oy+a.getActionUpdateDeltaTime()ow=ow+1 else ou=1/(oy/oC)table.insert(ox,ou)ow,oy=0,0 end;ov=0;for dL,dx in pairs(ox)do ov=ov+dx end;if#ox>0 then ov=bL(ov/#ox)end;if#ox>29 then table.remove(ox,1)end;jX[#jX+1]="<g class='txtstart size14 bright'>"jX[#jX+1]=gN(oz,oA,dk("BrkTime: %s",iJ(om)))jX[#jX+1]=gN(oB,oA,dk("Trip: %.2f km",j5))jX[#jX+1]=gN(oz,oA+nh,dk("Lifetime: %.2f kSU",bn/200000))jX[#jX+1]=gN(oB,oA+nh,dk("BrkDist: %s",iI(ol)))jX[#jX+1]=gN(oz,oA+nh*2,"Trip Time: "..iJ(j6))jX[#jX+1]=gN(oB,oA+nh*2,"Total Time: "..iJ(bo))jX[#jX+1]=gN(oz,oA+nh*3,dk("Mass: %s",ok))jX[#jX+1]=gN(oB,oA+nh*3,dk("Max Brake: %s",od))jX[#jX+1]=gN(oz,oA+nh*4,dk("Max Thrust: %s",on))if oc>0.1 then jX[#jX+1]=gN(oB,oA+nh*4,dk("Max Thrust Mass: %s",oi))jX[#jX+1]=gN(oz,oA+nh*5,dk("Req Thrust: %s",oj))else jX[#jX+1]=gN(oB,oA+nh*4,"Max Mass: n/a")jX[#jX+1]=gN(oz,oA+nh*5,"Req Thrust: n/a")end;jX[#jX+1]=gN(oB,oA+nh*5,cr.FuelUsed("atmofueltank"))jX[#jX+1]=gN(oz,oA+nh*6,cr.FuelUsed("spacefueltank"))jX[#jX+1]=gN(oB,oA+nh*6,cr.FuelUsed("rocketfueltank"))jX[#jX+1]=gN(oz,oA+nh*7,dk("Set Max Speed: %s",bL(ab*3.6+0.5)))jX[#jX+1]=gN(oB,oA+nh*7,dk("Actual Max Speed: %s",bL(df*3.6+0.5)))jX[#jX+1]=gN(oz,oA+nh*8,dk("Friction Burn Speed: %s",bL(bN.getFrictionBurnSpeed()*3.6)))jX[#jX+1]=gN(oB,oA+nh*8,dk("FPS (Avg): %s (%s)",bL(ou),ov))end;jX[#jX+1]="</g></g>"return jX end;function nY.DrawWarnings(jX)return lc(jX)end;function nY.DisplayOrbitScreen(jX)return lR(jX)end;function nY.DisplayMessage(jX,ln)if ln~="empty"then local hB=310;for lq in string.gmatch(ln,"([^\n]+)")do hB=hB+35;jX[#jX+1]=gN("50%",hB,lq,"msg")end end;if c2~=0 then c.setTimer("msgTick",c2)c2=0 end end;function nY.DrawDeadZone(jX)jX[#jX+1]=dk([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;function nY.UpdatePipe()if ce then iW=""return end;n6()end;function nY.DrawSettings(jX)local hA=jb(640)local hB=jc(200)jX[#jX+1]=[[<g class="pbright txtvspd txtstart">]]local hW=0;for dL,dx in pairs(iV)do hW=hW+1;jX[#jX+1]=gN(hA,hB,dL..": "..dx.get())hB=hB+20;if hW%12==0 then hA=hA+jb(350)hB=jc(200)end end;jX[#jX+1]=gN(jb(640),jc(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jX[#jX+1]="</g>"return jX end;local ic=jc(125)local ib=jb(1225)function nY.DrawRadarInfo()id=cu.GetRadarHud(ib,ic,ax,ay)end;function nY.DrawTanks()if at~=0 and au~=0 then jg=gN(at,au,"","txtstart pdim txtfuel")jz=au;jA(at,"Atmospheric ","ATMO",cl,jw,jx)jA(at,"Space Fuel T","SPACE",cm,ju,jv)jA(at,"Rocket Fuel ","ROCKET",cn,js,jt)end end;function nY.DrawShield()local im=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oD=bN.getPvPTimer()local oE=shield.getResistances()local oF="A: "..10+oE[1]*100 .."% / E: "..10+oE[2]*100 .."% / K:"..10+oE[3]*100 .."% / T: "..10+oE[4]*100 .."%"local hA,hB=av-60,aw+30;local jP=bL(dg*2.55)local jQ=dk("rgb(%d,%d,%d)",255-jP,jP,0)local jR=""jh=gN(hA,hB,"","txtmid pdim txtfuel")if dg<10 and im~="Shield Disabled"then jR="red "end;oD=oD>0 and"   PvPTime: "..iJ(oD)or""jh=jh..dk([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hA,hB,jQ,dg*2,hA,hB,hA+2,hB+10,dg,oD)jh=jh..gN(hA,hB-5,im,jR.."txtstart pbright txtbig")jh=jh..gN(hA,hB+30,oF,jR.."txtstart pbright txtsmall")end;function nY.hudtick()if not kz then return end;local function oG(jX)local jT=bL(dl(dd/(cj/4)*255,0,255))jX[#jX+1]=dk("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c7,c8,bL(j0+0.5)+jT,bL(j1+0.5)-jT,bL(j2+0.5)-jT)end;local function oH()if c0 then for dQ,dx in pairs(iN)do if dx.hovered then if not dx.drawCondition or dx.drawCondition(dx)then dx.toggleFunction(dx)end;dx.hovered=false end end;for dQ,dx in pairs(iQ)do if dx.hovered then bI=dx.label;dx.hovered=false end end;c0=false end end;local function oI()local function oJ(oK,oL,hA,hB,ng,nh)if oK>=hA and oK<=hA+ng and oL>=hB and oL<=hB+nh then return true else return false end end;local hA=c7+cj/2;local hB=c8+ck/2;for dQ,dx in pairs(iN)do dx.hovered=oJ(hA,hB,dx.x,dx.y,dx.width,dx.height)end;for dQ,dx in pairs(iQ)do dx.hovered=oJ(hA,hB,dx.x,dx.y,dx.width,dx.height)end;if d0 then local mW=false;for dQ,eD in ipairs(nU)do if eD.hovered then mW=true;break end end;if nR.hovered then mW=true end;d0=mW else d0=nR.hovered;if not d0 then d1=bl end end end;local function oM(jX)if not bI or bI==""then bI="HELP"end;if w then for dL,dx in pairs(iQ)do local jR="dim brightstroke"local oN=0.2;if bI==dL then jR="pbright dimstroke"oN=0.6 end;local oO=""if dx.hovered then oN=0.8;oO=";stroke:white"end;jX[#jX+1]=dk([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dx.width,dx.height,dx.x,dx.y,jR,oN,oO)jX[#jX+1]=gN(dx.x+dx.width/2,dx.y+dx.height/2+5,dx.label,"txt txtmid pdim")end end end;local function oP(jX)local function oQ(jX,oR,hover,hA,hB,fi,oS,oT,oU,oV,oW,nV)if type(oV)=="function"then oV=oV(nV)end;if type(oW)=="function"then oW=oW(nV)end;jX[#jX+1]=dk("<rect x='%f' y='%f' width='%f' height='%f' fill='",hA,hB,fi,oS)if oR then jX[#jX+1]=dk("%s'",oT)else jX[#jX+1]=oU end;if hover then jX[#jX+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else jX[#jX+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fV(af*0.5,0),fV(ag*0.5,0),fV(ah*0.5,0))end;jX[#jX+1]=" rx='5'></rect>"jX[#jX+1]=dk("<text x='%f' y='%f' font-size='24' fill='",hA+fi/2,hB+oS/2+5)if oR then jX[#jX+1]="black"else jX[#jX+1]="white"end;jX[#jX+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oR then jX[#jX+1]=dk("%s</text>",oV)else jX[#jX+1]=dk("%s</text>",oW)end end;local oX=dk("rgb(%d,%d,%d)'",fV(af*0.1,0),fV(ag*0.1,0),fV(ah*0.1,0))local oY=dk("rgb(%d,%d,%d)",fV(af*0.8,0),fV(ag*0.8,0),fV(ah*0.8,0))local oZ=oQ;for dQ,dx in pairs(iN)do local nl=dx.disableName;local nk=dx.enableName;if type(nl)=="function"then nl=nl(dx)end;if type(nk)=="function"then nk=nk(dx)end;if not dx.drawCondition or dx.drawCondition(dx)then oZ(jX,dx.toggleVar(dx),dx.hovered,dx.x,dx.y,dx.width,dx.height,oY,oX,nl,nk,dx)end end end;local o_=fV(cj/2,0)local p0=fV(ck/2,0)local jX={}if p1 then jX[#jX+1]=p1 end;cr.HUDPrologue(jX)if w then cr.UpdateHud(jX)else if A then cr.DrawVerticalSpeed(jX,cg)end;cr.DrawWarnings(jX)end;if iU and iV~="none"then cr.DrawSettings(jX)end;if cu then cr.DrawRadarInfo()else id=""end;cr.HUDEpilogue(jX)jX[#jX+1]=dk([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cj,ck)if c1~="empty"then cr.DisplayMessage(jX,c1)end;if iD()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(jX)end end;oM(jX)if iF()==0 then if iD()==1 and b_ then if not p2 then oI()oP(jX)end;if not cx and not cy then local p3=table.concat(jX,"")jX={}jX[#jX+1]=dk("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cj,ck)jX[#jX+1]=p3;jX[#jX+1]="</body>"cx=true;jX[#jX+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local p3=table.concat(jX,"")jX={}jX[#jX+1]=dk("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cj,ck)jX[#jX+1]=p3;jX[#jX+1]="</body>"end;if not cx then jX[#jX+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],o_,p0,c7,c8)end else oH()end else if not b_ and iD()==0 then oH()if dd>az then if v then oG(jX)end end elseif b_ and(not p2 or not i)then oI()oP(jX)end;jX[#jX+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],o_,p0,c7,c8)end;jX[#jX+1]=[[</svg></body>]]p4=table.concat(jX,"")end;function nY.TenthTick()local function p5()local p6=a.createData;local p7=a.createWidget;p8=a.createWidgetPanel("Interplanetary Helper")p9=p7(p8,"value")pa=p6('{"label": "Target Planet", "value": "N/A", "unit":""}')fT(pa,p9)pb=p7(p8,"value")pc=p6('{"label": "distance", "value": "N/A", "unit":""}')fT(pc,pb)gm=p7(p8,"value")gl=p6('{"label": "Travel Time", "value": "N/A", "unit":""}')fT(gl,gm)gk=p7(p8,"value")gj=p6('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fT(gj,gk)go=p7(p8,"value")gn=p6('{"label": "Target Altitude", "value": "N/A", "unit":""}')fT(gn,go)gg=p7(p8,"value")gf=p6('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ge=p7(p8,"value")gd=p6('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gc=p7(p8,"value")gb=p6('{"label": "Max Brake distance", "value": "N/A", "unit":""}')ga=p7(p8,"value")g9=p6('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gi=p7(p8,"value")gh=p6('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ce then fT(gf,gg)fT(gd,ge)fT(gb,gc)fT(g9,ga)fT(gh,gi)end end;local function pd()gM(p8)p8=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bj~="None"then if p8==nil then p5()end;if bj~=nil then local mx;local pe=g5~=nil;local pf=0.5*bu/c6:getGravity(c6.center+vec3(0,0,1)*c6.radius):len()pf=pf>1000000 and fV(pf/1000000,2).." kTons"or fV(pf/1000,2).." Tons"fS(pa,'{"label": "Target", "value": "'..bj..'", "unit":""}')if pe and not b3 then mx=(cO-g5.position):len()else mx=(bk-cO):len()end;if not b4 then c4,c5=ct.GetAutopilotBrakeDistanceAndTime(cL)iY,iZ=ct.GetAutopilotBrakeDistanceAndTime(ab)else c4,c5=ct.GetAutopilotTBBrakeDistanceAndTime(cL)iY,iZ=ct.GetAutopilotTBBrakeDistanceAndTime(ab)end;local ln=iI(mx)fS(pc,'{"label": "distance", "value": "'..ln..'"}')fS(gl,'{"label": "Travel Time", "value": "'..iJ(lt)..'", "unit":""}')ln=iI(c4)fS(gf,'{"label": "Cur Brake distance", "value": "'..ln..'"}')fS(gd,'{"label": "Cur Brake Time", "value": "'..iJ(c5)..'", "unit":""}')ln=iI(iY)fS(gb,'{"label": "Max Brake distance", "value": "'..ln..'"}')fS(g9,'{"label": "Max Brake Time", "value": "'..iJ(iZ)..'", "unit":""}')fS(gj,'{"label": "Max Brake Mass", "value": "'..dk("%s",pf)..'", "unit":""}')ln=iI(gp)fS(gn,'{"label": "Target Orbit", "value": "'..ln..'"}')if ce and not pg then a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)a.removeDataFromWidget(gf,gg)a.removeDataFromWidget(gh,gi)pg=true;if not cR and t and(b5 or b8 or cc)then ct.cmdThrottle(1)b0=false;bT=false end end;if not ce and pg then if fS(g9,ga)==1 then fT(g9,ga)end;if fS(gb,gc)==1 then fT(gb,gc)end;if fS(gd,ge)==1 then fT(gd,ge)end;if fS(gf,gg)==1 then fT(gf,gg)end;if fS(gh,gi)==1 then fT(gh,gi)end;pg=false end end else pd()end;if warpdrive~=nil then local ph=iB(warpdrive.getWidgetData())if ph.destination~="Unknown"and ph.distance>400000 then if not ja then warpdrive.showWidget()ja=true end elseif ja then warpdrive.hideWidget()ja=false end end end;function nY.OneSecondTick()local function pi()local jK=bK()local l8=cL;local pj=jK-j8;if l8>1.38889 then l8=l8/1000;local pk=l8*(jK-j8)bn=bn+pk;j5=j5+pk end;j6=j6+pj;bo=bo+pj;j8=jK end;local function pl(jX)local pm=0;local pn=iL;local po=0;local pp=0;local pq=0;local jP=0;local jQ=""local pr=b.getElementHitPointsById;local ps=b.getElementMaxHitPointsById;local pt={}for dL in pairs(iK)do local pu=0;local pv=0;pv=ps(iK[dL])pu=pr(iK[dL])po=po+pu;if pu+1<pv then if pu==0 then pq=pq+1 else pp=pp+1 end;if j9 and#pt==0 then fX=vec3(b.getElementPositionById(iK[dL]))local hA=fX.x;local hB=fX.y;local hC=fX.z;table.insert(pt,b.spawnArrowSticker(hA,hB,hC+1,"down"))table.insert(pt,b.spawnArrowSticker(hA,hB,hC+1,"down"))b.rotateSticker(pt[2],0,0,90)table.insert(pt,b.spawnArrowSticker(hA+1,hB,hC,"north"))table.insert(pt,b.spawnArrowSticker(hA+1,hB,hC,"north"))b.rotateSticker(pt[4],90,90,0)table.insert(pt,b.spawnArrowSticker(hA-1,hB,hC,"south"))table.insert(pt,b.spawnArrowSticker(hA-1,hB,hC,"south"))b.rotateSticker(pt[6],90,-90,0)table.insert(pt,b.spawnArrowSticker(hA,hB-1,hC,"east"))table.insert(pt,b.spawnArrowSticker(hA,hB-1,hC,"east"))b.rotateSticker(pt[8],90,0,90)table.insert(pt,b.spawnArrowSticker(hA,hB+1,hC,"west"))table.insert(pt,b.spawnArrowSticker(hA,hB+1,hC,"west"))b.rotateSticker(pt[10],-90,0,90)table.insert(pt,iK[dL])end elseif j9 and#pt>0 and pt[11]==iK[dL]then for jJ in pairs(pt)do b.deleteSticker(pt[jJ])end;pt={}end end;pm=fV(po/pn*100,2)if pq>0 or pp>0 then jX[#jX+1]=gN(0,0,"","pbright txt")jP=bL(pm*2.55)jQ=dk("rgb(%d,%d,%d)",255-jP,jP,0)jX[#jX+1]=gN("50%",1035,"Elemental Integrity: "..pm.."%","txtbig txtmid","fill:"..jQ)if pq>0 then jX[#jX+1]=gN("50%",1055,"Disabled Modules: "..pq.." Damaged Modules: "..pp,"txtbig txtmid","fill:"..jQ)elseif pp>0 then jX[#jX+1]=gN("50%",1055,"Damaged Modules: "..pp,"txtbig txtmid","fill:"..jQ)end end end;local function pw()if iA then if i_==nil and(he~=nil or bm)then _autoconf.displayCategoryPanel(iA,weapon_size,"Weapons","weapon",true)i_=_autoconf.panels[_autoconf.panels_size]elseif i_~=nil and he==nil and not bm then gM(i_)i_=nil end end end;d2=bN.getPlayersOnBoard()d3=bN.getDockedConstructs()local jX={}pi()if s then pl(jX)end;pw()cr.UpdatePipe()cr.ExtraData(jX)j7=table.concat(jX,"")end;function nY.AnimateTick()cy=true;cx=false;c7=0;c8=0;c.stopTimer("animateTick")end;function nY.MsgTick()local jX={}cr.DisplayMessage(jX,"empty")c1="empty"c.stopTimer("msgTick")c2=3 end;function nY.ButtonSetup()nw()nC()iN=iO end;if px then for dL,dx in pairs(px)do nY[dL]=dx end end;return nY end;local function py(d,b,c,e,vBooster,hover,pz,antigrav,warpdrive,dbHud_1,eZ,bL,bM,iD,eU,bK,dl,iE,fS,iF,dn,fV,fU,iG,dp,iI,iJ,pA,iB,dk,fT)local a=DUSystem;local bN=DUConstruct;local pB={}local pC=false;local pD=0;local pE=0;local pF=0;local pG=bK()local pH=0;local pI=0;local pJ=0;local pK=0;local pL=false;local pM=false;local pN=false;local pO=nil;local pP=0;local iX=55;local pQ=nil;local pR=false;local pS=false;local pT=false;local pU=0;local pV=0;local pW=0;local pX=0;local pY=0;local pZ={VectorToTarget=false}local p_=vec3(bN.getWorldOrientationUp())local q0=nil;local q1=0;local q2=-1;local q3=-1;local q4=false;local q5=false;local q6=0;local q7=false;local q8=false;local q9=false;local qa=false;local qb=""local qc=false;local qd=false;local qe=""local qf=false;local qg=0;local function qh()return bN.isInPvPZone()~=1,eZ(bN.getDistanceToSafeZone())end;local function qi(fp)local qj=bf;if not b3 then qj=0 end;local qk=bs;if ce then if bu and bu>0 then qk=bu else return 0,0 end end;return cp.computeDistanceAndTime(fp,qj,ch,0,0,qk-bh*ch)end;local function ql(fp)local qj=bf;if not b3 then qj=0 end;return cp.computeDistanceAndTime(fp,qj,ch,d:maxForceForward(),a2,bs-bh*ch)end;local function qm(qn,qo,qp)qo=qo:project_on_plane(qn)qp=qp:project_on_plane(qn)return eU(qo:cross(qp):dot(qn),qo:dot(qp))end;local function qq()local function qr()local qs=-1;local qt=-1;if vBooster then qs=vBooster.getDistance()end;if hover then qt=hover.getDistance()end;if qs~=-1 and qt~=-1 then if qs<qt then return qs else return qt end elseif qs~=-1 then return qs elseif qt~=-1 then return qt else return-1 end end;local qu=qr()local qv=-1;if antigrav and antigrav.isActive()==1 and not q and cL<iX then local qw=eZ(cg-antigrav.getBaseAltitude())if qw<50 then return qw end end;if pz then qv=pz.raycast().distance end;if qu~=-1 and qv~=-1 then if qu<qv then return qu else return qv end elseif qu~=-1 then return qu else return qv end end;local function qx(kz,eL,qy)local function qz(qA,dX)local eR=vec3(dX)if qA.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=qA.systemId},dZ)end;local eS=eR-qA.center;local c9=eS:len()local e3=c9-qA.radius;local e1=0;local e2=0;if not dp(c9,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/c9)end;return setmetatable({latitude=math.deg(e1),longitude=math.deg(e2),altitude=e3,id=qA.id,systemId=qA.systemId},dZ)end;local qB=qz(kz,eL)qB="::pos{"..qB.systemId..","..qB.id..","..qB.latitude..","..qB.longitude..","..qB.altitude.."}"if qy then return qB else q9=qB;return true end end;local function qC(qD,qE,qF)local function qG(qD,eu)qD=vec3(qD)eu=vec3(eu):normalize()local dG=qD*eu;return dG.x+dG.y+dG.z end;local qH=0.001;local qI=1;if not ce or not cA or cd~=-1 or cL<iX then if qF==nil then qF=aS end;if qE==nil then qE=qH end;qD=vec3(qD):normalize()local qJ=vec3()-qD;local qK=-qG(qJ,bN.getWorldOrientationRight())*qI;local qL=-qG(qJ,bN.getWorldOrientationUp())*qI;if pE==0 then pE=qK/2 end;if pF==0 then pF=qL/2 end;if eZ(qK)<0.1 then pV=pV-qK*2 else pV=pV-(qK+(qK-pE)*qF)end;if eZ(qL)<0.1 then pU=pU+qL*2 else pU=pU+qL+(qL-pF)*qF end;pE=qK;pF=qL;if eZ(qK)<qE and eZ(qL)<qE then return true end;return false elseif cA and cd==-1 then qD=cK;if qF==nil then qF=aS end;if qE==nil then qE=qH end;qD=vec3(qD):normalize()local qJ=cH-qD;local qK=-qG(qJ,bN.getWorldOrientationRight())*qI;local qL=-qG(qJ,bN.getWorldOrientationUp())*qI;if pE==0 then pE=qK/2 end;if pF==0 then pF=qL/2 end;if eZ(qK)<0.1 then pV=pV-qK*5 else pV=pV-(qK+(qK-pE)*qF)end;if eZ(qL)<0.1 then pU=pU+qL*5 else pU=pU+qL+(qL-pF)*qF end;pE=qK;pF=qL;if eZ(qK)<qE and eZ(qL)<qE then return true end;return false end end;function pB.clearAll()bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"b1=false;b2=false;cX=nil;b5=false;b8=false;b6=false;b7=false;b9=false;bZ=false;pS=false;ca=false;cb=false;pT=false;cz=p;bq=false;b4=false;ci=false;bt=nil;bz=false;db=false;dc=nil end;function pB.GetAutopilotBrakeDistanceAndTime(fp)return qi(fp)end;function pB.GetAutopilotTBBrakeDistanceAndTime(fp)return ql(fp)end;function pB.showWayPoint(kz,eL,qy)return qx(kz,eL,qy)end;function pB.APTick()local qM=a.getMouseWheel()if qM>0 then ct.changeSpd()elseif qM<0 then ct.changeSpd(true)else pR=true end;q6=iF()if q9 then a.setWaypoint(q9)q9=false end;if qc then antigrav.setTargetAltitude(qc)qc=false end;if qa then fS(qa,qb)qa=false;qb=""end;if q3~=-1 then ct.cmdCruise(q3,q4)q4=false;q3=-1 end;if q0~=nil then if iE:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iE:getTargetSpeed(axisCommandId.longitudinal)~=q0 then iE:setTargetSpeedCommand(axisCommandId.longitudinal,q0)else q0=nil end end;if q2~=-1 then ct.cmdThrottle(q2,q4)q4=false;q2=-1 end;if q5 then cv.landingGear()q5=false end;if qd then ct.ToggleAutopilot()end end;function pB.ToggleIntoOrbit()cE=false;pJ=nil;pK=nil;pP=0;if not ce then if bz then fU("orOff","AP")bz=false;pL=false;pO=nil;cz=p;if b5 then b5=false;b7=false end;pZ.VectorToTarget=false;pZ.AutopilotAlign=false;pN=false elseif cY then fU("orOn","AP")bz=true;cz=true;if pO==nil then pO=kz end;if b5 then b5=false;b7=false end else c1="Unable to engage auto-orbit, not near a planet"end else bz=false;pL=false;pO=nil;cz=p;if b5 then b5=false end;pZ.VectorToTarget=false;pZ.AutopilotAlign=false;pN=false end end;function pB.ToggleVerticalTakeoff()b5=false;if b9 then lp=true;b8=false;b7=false;b6=true;cz=true;bY=0;if ce and cd==-1 then b6=false;b5=true;bY=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q3=bL(cB)end else cE=false;bm=false;d.control.retractLandingGears()iE:setTargetGroundAltitude(Z)b0="VTO Takeoff"end;b9=not b9 end;function pB.checkLOS(qD)local lr,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,qD,function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local ls=eJ;if eK~=nil and eJ~=nil then ls=math.min(eK,eJ)end;if ls~=nil then return lr,ls else return nil,nil end end;function pB.ToggleAutopilot()local function qN(bx)cZ=false;bq=not bq;if bq then b4=false;if not b5 and not bx then ct.ToggleAltitudeHold()end end;lv="Proceeding to Waypoint"end;local function qO(gy)if gy then for M,dL in pairs(cU)do if dL.name and dL.name==gy then return M end end else return 0 end end;local qP=false;if bO-pI<1.5 and ce then if not cG then if ce then ba=kz.spaceEngineMinAltitude-0.01*kz.noAtmosphericDensityAltitude;fU("11","EP")pI=-1;if b3 or bq or bz then return end else c1="No space engines detected, Orbital Hop not supported"return end elseif kz.hasAtmosphere then if ce then ba=kz.noAtmosphericDensityAltitude+V;fU("orH","OH")end;pI=-1;if b3 or bq or bz then return end end else pI=bO end;qQ=false;if(bl>0 or#bF>0)and not b3 and not bq and not cb and not bz then if 0.5*d:maxForceForward()/b.getGravityIntensity()<ch then c1="WARNING: Heavy Loads may affect autopilot performance."c2=5 end;if#bF>0 and not cc then bl=qO(bF[1])cs.UpdateAutopilotTarget()c1="Route Autopilot in Progress"local qJ=g5.position-cO;local qR=qJ:project_on_plane(cM):len()if qR>50000 and g5.planetname==kz.name then qP=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c6,bk)if g5~=nil then if g5.agg and not q and antigrav then if not cQ then ct.ToggleAntigrav()end;bv=g5.agg end;bt=nil;bx=g5.planetname=="Space"if bx then fU("apSpc","AP")if ce then cb=true;ct.ToggleAltitudeHold()else b3=true end elseif kz.name==g5.planetname then lp=true;if ce then if not bq then fU("vtt","AP")qN(bx)if qP then ba=kz.noAtmosphericDensityAltitude+V end end else fU("apOn","AP")if not(c6.name==kz.name and cg<gp*1.5)then cE=false;b3=true elseif not ce then if bz then ct.ToggleIntoOrbit()end;cD=kz.noAtmosphericDensityAltitude+V;pN=true;pZ.AutopilotAlign=true;pZ.VectorToTarget=true;pL=false;if not bz then ct.ToggleIntoOrbit()end end end else fU("apP","AP")b1=false;b2=false;if ce then cb=true;ct.ToggleAltitudeHold()else b3=true end end elseif not ce then if g5==nil and(c6.name==kz.name and cY)and not bz then qS=false;cE=false;pL=false;ct.ToggleIntoOrbit()else fU("apP","AP")b3=true;b1=false;b2=false;bc=false;bZ=false;b5=false;b6=false;b8=false;b7=false;pS=false;bt=nil;qS=false end else fU("apP","AP")cb=true;ct.ToggleAltitudeHold()end;qd=false else fU("apOff","AP")ct.ResetAutopilots(1)if qd==2 then qd=true end end end;function pB.routeWP(qT,qU,qV)if qV then if qV==1 then bF={}bF=iG(bF,bE)if#bF>0 then c1="Route Loaded"else c1="No Saved Route found on Databank"end;return bF else bE={}bE=iG(bE,bF)c1="Route Saved"pA()return end end;if qT then return bF end;if qU then bF={}c1="Current Route Cleared"else bF[#bF+1]=g5.name;c1="Added "..g5.name.." to route. "end;return bF end;function pB.cmdThrottle(dM,qW)if iE:getAxisCommandType(0)~=axisCommandType.byThrottle and not qW then d.control.cancelCurrentControlMasterMode()end;iE:setThrottleCommand(axisCommandId.longitudinal,dM)bP=dl(fV(dM*100,0)/100,-1,1)q0=nil end;function pB.cmdCruise(dM,qW)if iE:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not qW then d.control.cancelCurrentControlMasterMode()end;iE:setTargetSpeedCommand(axisCommandId.longitudinal,dM)q0=dM end;function pB.ToggleLockPitch()if bt==nil then fU("lkPOn","LP")if not b_ then bt=cS else bt=S end;b7=false;b5=false;b6=false else fU("lkPOff","LP")bt=nil end end;function pB.ToggleAltitudeHold()if bO-pH<1.5 then if kz.hasAtmosphere then if ce then ba=kz.spaceEngineMinAltitude-0.01*kz.noAtmosphericDensityAltitude;fU("11","EP")else if cY then ba=kz.noAtmosphericDensityAltitude+V;cD=ba;pN=true;if not bz then ct.ToggleIntoOrbit()end;pL=true end end;pH=-1;if b5 or bz or b9 then return end end else pH=bO end;if cY and not ce then cD=cg;pN=true;pL=true;ct.ToggleIntoOrbit()if bz then pH=bO else pH=0 end;return end;b5=not b5;b6=false;b8=false;if b5 then b3=false;b2=false;b1=false;bZ=false;cz=true;bt=nil;cE=false;if cd~=-1 and cL<20 then if bm then cv.landingGear()end;fU("lfs","LS")b7=true;if pH>-1 then ba=cg+Y end;b0="ATO Hold"iE:setTargetGroundAltitude(Z)if a_ and cP then ct.ToggleVerticalTakeoff()end else fU("altOn","AH")b7=false;if pH>-1 then if cY then ba=cg end end;if b9 then ct.ToggleVerticalTakeoff()end end;if cQ and not q then local qX=antigrav.getBaseAltitude()if bq and g5.agg and g5.agg>cg then ba=g5.agg elseif b7 then ba=qX end;if eZ(cg-qX)<100 and cL<20 then ba=qX;b0="AGG Hold"q2=0 end end;if cb then ba=200000 end else fU("altOff","AH")if bz then ct.ToggleIntoOrbit()end;if b9 then ct.ToggleVerticalTakeoff()end;cz=p;b7=false;bq=false;pH=0 end end;function pB.ResetAutopilots(pB)if pB then cb=false;b3=false;bc=false;pS=false;ba=cg;qQ=false;db=false;bg="Aligning"end;bq=false;b7=false;b8=false;b2=false;b6=false;dc=nil;qY=false;cX=nil;db=false;if not cQ then b5=false;bt=nil end;if b9 then ct.ToggleVerticalTakeoff()end;if bz then ct.ToggleIntoOrbit()end;cz=p;ca=false;cc=false;bY=0 end;function pB.BrakeToggle(qZ)if not b0 then if qZ then b0=qZ else b0=true end else b0=false end;if b6 then b6=false;cz=p;db=false end;if b0 then fU("bkOn","B",1)ct.ResetAutopilots()else fU("bkOff","B",1)end end;function pB.BeginReentry()if b8 then c1="Re-Entry cancelled"fU("reOff","RE")b8=false;cz=p;b5=false elseif not kz.hasAtmosphere then c1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c2=5 elseif not pT then b8=true;if iE:getAxisCommandType(0)~=q_.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b0=false;c1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB;fU("par","RE")else b8=true;b5=true;cz=true;b0=false;ba=kz.surfaceMaxAltitude+a0;if ba>kz.spaceEngineMinAltitude then ba=kz.spaceEngineMinAltitude-0.01*kz.noAtmosphericDensityAltitude end;local r0=iI(ba)c1="Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..r0;fU("glide","RE")q3=bL(cB)end;b7=false end;function pB.ToggleAntigrav()if antigrav and not q then if cQ then fU("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bv==nil then bv=cg end;if bv<1000 then bv=1000 end;fU("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pB.changeSpd(r1)local r2=1;if r1 then r2=-1 end;if not b_ then if t and not p2 and pR then local r3=bP;bP=fV(dl(bP+r2*aE/100,-1,1),2)if bP>=0 and r3<0 then bP=0;pR=false end elseif p2 then if ce or b8 then cB=dl(cB+r2*aE,0,W)elseif b3 then ab=dl(ab+r2*aE/3.6*100,0,df-0.2)end else iE:updateCommandFromActionStart(axisCommandId.longitudinal,r2*aE/10)end else if b3 or bq or cb or bz then d1=d1+1*r2*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not r1 then r2=1 else r2=nil end;cs.adjustAutopilotTargetIndex(r2)end end end;function pB.TenthTick()local function r4()if not b3 then if g5==nil or g5.planetname~=kz.name then r5=(c6.center-cO):len()else r5=(g5.position-cO):len()end end;local fp=cL;local r6=c.getThrottle()/100;if t then r6=bP end;local r7,r8=cp.computeDistanceAndTime(cL,ab,ch,d:maxForceForward()*r6,a2,0)local c4,c5;if not b4 then c4,c5=ct.GetAutopilotBrakeDistanceAndTime(ab)else c4,c5=ct.GetAutopilotTBBrakeDistanceAndTime(ab)end;local dQ,r9;if not b4 and fp>0 then dQ,r9=ct.GetAutopilotBrakeDistanceAndTime(fp)else dQ,r9=ct.GetAutopilotTBBrakeDistanceAndTime(fp)end;local ra=0;local rb=0;if be or not b3 and fp>5 then rb=cp.computeTravelTime(fp,0,r5)elseif c4+r7<r5 then ra=r5-(c4+r7)rb=cp.computeTravelTime(8333.0556,0,ra)else local rc=(r5-c4)/r7;r7=r5-c4;r8=r8*rc end;if g5~=nil and g5.planetname==kz.name and not b3 then return rb elseif bd then return r9 elseif be then return rb+r9 else return r8+c5+rb end end;local function rd(oc,re)if oc==nil then oc=b.getGravityIntensity()end;oc=fV(oc,5)if re~=nil and re or(pQ==nil or pQ~=oc)then local fp=cJ:len()local rf=iB(c.getWidgetData()).maxBrake;if rf~=nil and rf>0 and ce then rf=rf/dl(fp/100,0.1,1)rf=rf/cf;if cf>0.10 then if bu then bu=(bu+rf)/2 else bu=rf end end end;if rf~=nil and rf>0 then bs=rf end;pQ=oc end end;cV,cW=qh()df=bN.getMaxSpeed()if bj~="None"and(c6 or g5)then lt=r4()end;rd(nil,true)end;function pB.SatNavTick()if not r then return end;qe=dbHud_1.getStringValue("SPBAutopilotTargetName")if qe~=nil and qe~=""and qe~="SatNavNotChanged"then local dG=iB(dbHud_1.getStringValue("SavedLocations"))if dG~=nil then bp=dG;local gw=-1;local gC;for dL,dx in pairs(bp)do if dx.name and dx.name=="SatNav Location"then gw=dL;break end end;if gw~=-1 then gC=bp[gw]gw=-1;for dL,dx in pairs(e[0])do if dx.name and dx.name=="SatNav Location"then gw=dL;break end end;if gw>-1 then e[0][gw]=gC end;cs.UpdateAtlasLocationsList()c1=gC.name.." position updated"end end;for M=1,#cU do if cU[M].name==qe then bl=M;a.print("Index = "..bl.." "..cU[M].name)cs.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pB.onFlush()local function rg(rh,ri)local rj=vec3()local rk=vec3()if rh==axisCommandId.longitudinal then rj=vec3(bN.getOrientationForward())rk=cH elseif rh==axisCommandId.vertical then rj=vec3(bN.getOrientationUp())rk=p_ elseif rh==axisCommandId.lateral then rj=vec3(bN.getOrientationRight())rk=cI else return vec3()end;local rl=vec3(b.getWorldGravity())local rm=rl:dot(rk)local rn=vec3(bN.getWorldAirFrictionAcceleration())local ro=rn:dot(rk)local rp=cJ:dot(rj)local rq=ri*constants.kph2m;if rr==nil then rr=pid.new(10,0,10.0)end;rr:inject(rq-rp)local rs=rr:get()local rt=(rs-ro-rm)*rk;return rt end;local function ru(rh,ri)local rj=vec3()local rk=vec3()if rh==axisCommandId.longitudinal then rj=vec3(bN.getOrientationForward())rk=cH elseif rh==axisCommandId.vertical then rj=vec3(bN.getOrientationUp())rk=p_ elseif rh==axisCommandId.lateral then rj=vec3(bN.getOrientationRight())rk=cI else return vec3()end;local rl=vec3(b.getWorldGravity())local rm=rl:dot(rk)local rn=vec3(bN.getWorldAirFrictionAcceleration())local ro=rn:dot(rk)local rp=cJ:dot(rj)local rq=ri*constants.kph2m;if rv==nil then rv=pid.new(10,0,10.0)end;rv:inject(rq-rp)local rs=rv:get()local rt=(rs-ro-rm)*rk;return rt end;local function rw(rx,j_,g1)local ry=rx:cross(g1):normalize_inplace()local kM=math.acos(dl(ry:dot(-j_),-1,1))*constants.rad2deg;if ry:cross(-j_):dot(g1)<0 then kM=-kM end;return kM end;local function rz()if c_ and not b6 then local es=c_[1]local i2,i3=c_[2],c_[3]local rA=math.min(i2,i3 or i2)local rB=rA/cL;local rC=b7 and(cL<42 or cd~=-1)local rD=b5 or bq or bt or b3;if rD and not rC and(c4*1.5>rA or rB<1)then b0="Collision"bF={}q2=0;if b5 then ct.ToggleAltitudeHold()end;if bt then ct.ToggleLockPitch()end;c1="Autopilot Cancelled due to possible collision"a.print(es.name.." COLLISION "..iJ(rB).." / "..iI(rA,2))ct.ResetAutopilots(1)lp=true;if ce then b6=true end;cz=true end;if rB<11 then cZ=es.name.." COLLISION "..iJ(rB).." / "..iI(rA,2)else cZ=es.name.." collision "..iJ(rB)end;if rB<6 then fU("alarm","AL",2)end else cZ=false end end;if antigrav and not q then if not cQ and antigrav.getBaseAltitude()~=bv then qc=bv end end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iE:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local rE=dl(bV+pU+a.getControlDeviceForwardInput(),-1,1)local rF=dl(bW+pW+a.getControlDeviceYawInput(),-1,1)local rG=dl(bX+pV-a.getControlDeviceLeftRightInput(),-1,1)local rH=b0 and 1 or 0;cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(kz.center-cO):normalize()end;p_=vec3(bN.getWorldOrientationUp())cH=vec3(bN.getWorldOrientationForward())cI=vec3(bN.getWorldOrientationRight())cK=vec3(bN.getWorldVelocity())cJ=vec3(bN.getVelocity())cO=vec3(bN.getWorldPosition())ch=bN.getMass()cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local rI=cT/180*math.pi;local rJ=math.cos(rI)local rK=math.sin(rI)cS=rw(cM,cH,cI*rJ+p_*rK)local rL=cK:normalize()local rM=eZ(cT)local rN=utils.sign(cT)local rO=vec3(bN.getWorldAngularVelocity())local rP=rE*aO*cI+rF*aJ*cH+rG*aP*p_;if cz==true and cM:len()>0.01 then local rQ=eZ(pX-cT)if((b2 or b8 or b6 or ca or b5 or bz)and rQ>0 or ce and rQ<aK and p)and rF==0 and eZ(cS)<85 then local rR=pX;local rS=aI;if not ce then rS=rS/4;pX=0;rR=0 end;if rT==nil then rT=pid.new(rS*0.01,0,rS*0.1)end;rT:inject(rR-cT)local rU=rT:get()rP=rP+rU*cH end end;local rV=1;local rW=0;local rX=1;bQ=0;cf=bM()ce=false or cg<kz.noAtmosphericDensityAltitude and cf>0.00001;cg=b.getAltitude()cd=qq()bO=bK()pG=bO;if bm and cd>-1 and cd-3<_ then if iE.targetGroundAltitudeActivated then iE:deactivateGroundEngineAltitudeStabilization()end end;if cu then qf=not qf;if qf then cu.UpdateRadar()end;if E then rz()end end;if antigrav then cQ=antigrav.isActive()==1 end;local rY=1;local rZ=1;local r_=bO-pG;local s0=-math.deg(qm(p_,cK,cH))local s1=math.deg(qm(cI,cK,cH))local gr=cM*-1;cA=ce and s0<-N or s0>N or s1<-O or s1>O;local s2=a.getMouseDeltaX()local s3=a.getMouseDeltaY()if qg then local s4=bK()-qg;s2=s2*s4/0.016;s3=s3*s4/0.016 end;qg=bK()if o and not b_ then s3=-s3 end;pV=0;pW=0;pU=0;fY=co[0]local s5=bN.getWorldPosition()kz=fY:closestBody(s5)s6=cq(kz)ft=s6:orbitalParameters(s5,cK)if cg==0 then cg=(cO-kz.center):len()-kz.radius end;cY=c.getClosestPlanetInfluence()>0 or cg>0 and cg<200000;local oc=kz:getGravity(s5):len()*ch;pX=0;local s7=bN.getMaxThrustAlongAxis("ground",bN.getOrientationUp())[1]if q6==0 then if iD()==1 and b_ then if not cx then c7=dl(c7+s2/2,-cj/2,cj/2)c8=dl(c8+s3/2,-ck/2,ck/2)end else c7=0;c8=0 end else c7=dl(c7+s2/2,-cj/2,cj/2)c8=dl(c8+s3/2,-ck/2,ck/2)dd=dn(c7*c7+c8*c8)if not b_ and iD()==0 then local kV,kW=1,1;if bI=="SCOPE"then kV,kW=d5/90,d5/90 end;if g=="virtual joystick"then if dd>az then pV=pV-dl(eZ(c7)-az,0,cj/2)*utils.sign(c7)*aG*kV;pU=pU-dl(eZ(c8)-az,0,ck/2)*utils.sign(c8)*aH*kW end else c7=0;c8=0;if g=="mouse"then pU=(-utils.smoothstep(s3,-100,100)+0.5)*2*rY;pV=(-utils.smoothstep(s2,-100,100)+0.5)*2*rZ end end end end;local s8=cL>27777;if cL>X/3.6 and not ce and not b3 and not s8 then c1="Space Speed Engine Shutoff reached"q2=0 end;if not s8 and s9 then if not b0 then ct.BrakeToggle()end;if b3 then ct.ResetAutopilots(1)end;q2=0 end;s9=s8;if cf>0.09 then if cL>cB/3.6 and not t and not pC then b0="SpdLmt"pC=true elseif not t and pC then if cL<cB/3.6 then b0=false;pC=false end end end;if b2 then if ca then b0=false;local sa=false;if g5 and ca==true then sa=qC(g5.position-cO,0.1)else sa=qC(vec3(cK),0.01)end;cz=true;if sa then q3=bL(cB)if(eZ(cT)<2 or eZ(cS)>85)and cL>=cB/3.6-1 then b0=false;b2=false;if ca~=2 then pT=true end;if ca==true then cc=true end;ca=false;b3=false;ct.BeginReentry()end elseif ce and t then q2=1 end elseif cL>iX then qC(vec3(cK),0.01)end end;if b1 then if ce then b1=false elseif cL>iX then qC(-vec3(cK))end end;if not b2 and ca and not bz then if not ce then if ca~=2 then pT=true end;ct.BeginReentry()ca=false;cc=true else ca=false;if not qd then qd=true end end end;if cc and g5 and(cg<ba+250 and cg>ba-250)and cL*3.6>cB-250 and eZ(cN)<25 and cf>=0.1 and(g5.position-cO):len()>2000+cg then if not qd then qd=true end;cc=false end;if b9 then cz=true;local sb=ba;if cN<-30 then c1="Unable to achieve lift. Safety Landing."bY=0;cz=p;b9=false;b6=true elseif not q and cQ or ba<kz.spaceEngineMinAltitude then if cQ then sb=antigrav.getBaseAltitude()end;if cg<sb-100 then pY=0;bY=15;b0=false elseif cN>0 then b0="VTO Limit"bY=0 elseif cN<-30 then b0="VTO Fall"bY=15 elseif cg>=sb then if cQ then if b3 or bq then ct.ToggleVerticalTakeoff()else b0="VTO Complete"b9=false end;c1="Takeoff complete. Singularity engaged"fU("aggLk","AG")else b0=false;c1="VTO complete. Engaging Horizontal Flight"fU("vtoc","VT")ct.ToggleVerticalTakeoff()end;bY=0 end else if cf>0.08 then pY=0;b0=false;bY=20 elseif cf<0.08 and ce then b0=false;if cF then pY=0;bY=20 else bY=0;pY=36;q3=3500 end else cz=p;bz=true;cE=false;sc=false;pL=false;pJ=nil;pK=nil;if pO==nil then pO=kz end;cD=sb;pN=true;b9=false end end;if pY~=nil then if sd==nil then sd=pid.new(2*0.01,0,2*0.1)end;local se=dl(pY-cS,-O*0.80,O*0.80)sd:inject(se)local sf=dl(sd:get(),-1,1)pU=sf end end;if bz then local function sg()if ft.periapsis.altitude>=cD*0.99 and ft.apoapsis.altitude>=cD*0.99 and ft.periapsis.altitude<ft.apoapsis.altitude and ft.periapsis.altitude*1.05>=ft.apoapsis.altitude and eZ(cD-cg)<1000 then return true else return false end end;local qJ;local sh=false;local si=iI(cD)if pO==nil then pO=kz;if bq then pO=c6 end end;if not pN then cD=bL(pO.radius+pO.surfaceMaxAltitude+V)if pO.hasAtmosphere then cD=bL(pO.radius+pO.noAtmosphericDensityAltitude+V)end;pN=true end;if pZ.VectorToTarget and g5 then qJ=g5.position-cO end;local sj,sk=cq(pO):escapeAndOrbitalSpeed((cO-pO.center):len()-pO.radius)local sl=cT;if not pL then local sm=false;local sn=false;q2=0;pK=0;cC="Aligning to orbital path - OrbitHeight: "..si;if pZ.VectorToTarget then qC(qJ:normalize():project_on_plane(cM))sh=cH:dot(qJ:project_on_plane(p_):normalize())>0.95 else qC(cK)sh=s0<0.5;if cL<150 then sh=true end end;pU=0;pJ=0;if cS<=pJ+2 and cS>=pJ-2 then sm=true else sm=false end;if sl<=pK+2 and sl>=pK-2 then sn=true else sn=false end;if sm and sn and sh then pJ=nil;pK=nil;pL=true end else if pZ.VectorToTarget then qC(qJ:normalize():project_on_plane(cM))elseif cL>150 then qC(cK)end;pU=0;if pZ.VectorToTarget and g5 then local c4,dQ=cp.computeDistanceAndTime(cL,cB/3.6,ch,0,0,bs)if cE and qJ:len()>15000+c4+cg then cC="Orbiting to Target"if cg-100<=pO.noAtmosphericDensityAltitude or lt>ft.timeToPeriapsis and ft.periapsis.altitude<pO.noAtmosphericDensityAltitude or not sg()and ft.eccentricity>0.1 then c1="Re-Aligning Orbit"cE=false end elseif cE or qJ:len()<15000+c4+cg then c1="Orbit complete, proceeding with reentry"fU("orCom","OB")bk=g5.position;pT=true;cc=true;pZ.VectorToTarget,pZ.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if ft.periapsis~=nil and ft.apoapsis~=nil and ft.eccentricity<1 and cg>cD*0.9 and cg<cD*1.4 then if ft.apoapsis~=nil then if sg()or cE then if cE then b0=false;q2=0;pJ=0;if not pZ.VectorToTarget then c1="Orbit complete"fU("orCom","OB")ct.ToggleIntoOrbit()end else pP=pP+1;if pP>=2 then cE=true end end else cC="Adjusting Orbit - OrbitHeight: "..si;pM=true;q3=sk*3.6+1;local so=cD-cg;if sp==nil then sp=pid.new(0.1,0,1*0.1)end;sp:inject(so-cN*dl(utils.smoothstep(2000-so,-2000,2000)^6*10,1,10))pJ=dl(sp:get(),-60,60)end end else local sq=2.75;local sr=eZ(fV(sj*sq))local oq=sr%50;if oq>0 then sr=sr-oq+50 end;b0=false;if cg<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..si;pJ=utils.map(cN,200,0,-15,80)elseif cg>=cD*0.8 and cg<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..si;sr=sr*0.75;pJ=utils.map(cN,100,-100,-15,65)elseif cg>=cD*1.15 and cg<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..si;sr=sr*0.75;if cN<0 or pM then pJ=utils.map(cg,cD*1.5,cD*1.01,-30,0)else pJ=utils.map(cg,cD*0.99,cD*1.5,0,30)end elseif cg>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..si;pJ=-65;local ss=utils.map(cN,-150,-400,1,0.55)sr=sr*ss end;q3=bL(sr)end end;if pJ~=nil then if st==nil then st=pid.new(1*0.01,0,5*0.1)end;local su=pJ-cS;st:inject(su)local sv=dl(st:get(),-0.5,0.5)pU=sv end end;if b3 and not ce and not ca then local function sw(di,ft)a.print(di)b0=false;bd=false;b3=false;qQ=false;bg="Aligning"q2=0;pS=false;c1=di;fU("apCom","AP")if ft or ca then if ft and gp~=nil and not ca then if not cg or cg==0 then return end;cD=cg;pN=true end;ct.ToggleIntoOrbit()end end;local sx,sy=bk,false;if g5 and g5.planetname~="Space"then bc=true;if not qQ then local sz=(g5.position-c6.center):normalize()local sA=sz:project_on_plane((c6.center-cO):normalize()):normalize()local sB=c6.center+sA*(c6.radius+gp)local sC=g5.position+(g5.position-c6.center):normalize()*(gp-c6:getAltitude(g5.position))if(cO-sB):len()<(cO-sC):len()then sx=sB else sx=sC;bf=0 end;bk=sx;ct.showWayPoint(c6,bk)sy=true;qQ=true end;bh=0 elseif g5 and g5.planetname=="Space"then if not qQ then bh=0;sy=true;bc=true;qQ=true;sx=g5.position+(cO-g5.position):normalize()*T;bk=sx end elseif g5==nil then bh=0;if not qQ then local sz=(cO+cK*100000-c6.center):normalize()local sA=sz:project_on_plane((c6.center-cO):normalize()):normalize()if sA:len()<1 then sz=(cO+cH*100000-c6.center):normalize()sA=sz:project_on_plane((c6.center-cO):normalize()):normalize()end;sx=c6.center+sA*(c6.radius+gp)bk=sx;qQ=true;sy=true;bc=true;ct.showWayPoint(c6,bk)end end;r5=(vec3(sx)-cO):len()local lr,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local ls=eJ;if eK~=nil and eJ~=nil then ls=math.min(eK,eJ)end;if ls~=nil and ls<r5 and lr.name==c6.name then r5=ls end;local sa=true;local sD=(c6.center-(cO+vec3(cK):normalize()*r5)):len()-c6.radius;local ln=iI(sD)qa=gh;qb='{"label": "Projected Altitude", "value": "'..ln..'"}'if cL>50 and bb then local qJ=vec3(sx)-cO;local sE=dl(math.deg(qm(p_,cK:normalize(),qJ:normalize()))*cL/500,-90,90)local sF=dl(math.deg(qm(cI,cK:normalize(),qJ:normalize()))*cL/500,-90,90)if eZ(sE)<20 and eZ(sF)<20 then sE=sE*2;sF=sF*2 end;if eZ(sE)<2 and eZ(sF)<2 then sE=sE*2;sF=sF*2 end;local s0=-math.deg(qm(p_,cH,cK:normalize()))local s1=-math.deg(qm(cI,cH,cK:normalize()))if sG==nil then sG=pid.new(2*0.01,0,2*0.1)end;sG:inject(sF-s1)local sH=dl(sG:get(),-1,1)pU=pU+sH;if sI==nil then sI=pid.new(2*0.01,0,2*0.1)end;sI:inject(sE-s0)local sJ=dl(sI:get(),-1,1)pV=pV+sJ;sy=true;if eZ(sE)>2 or eZ(sF)>2 then if bg~="Adjusting Trajectory"then bg="Adjusting Trajectory"fU("apAdj","AP")end else if bg~="Accelerating"then bg="Accelerating"fU("apAcc","AP")end end elseif bb and cL<=50 then qC((sx-cO):normalize())end;if sD<gp*1.5 then bf=cB/3.6;if g5==nil then dQ,bf=cq(c6):escapeAndOrbitalSpeed(sD)end end;local c4,c5;if not b4 then c4,c5=qi(cL)else c4,c5=ql(cL)end;if b3 and not bb and not be and not bd then local lr,ls=ct.checkLOS((bk-cO):normalize())if c6.name~=kz.name then if lr~=nil and c6.name~=lr.name and ls<r5 then c1="Collision with "..lr.name.." in "..iI(ls).."\nClear LOS to continue."c2=5;q7=true else q7=false;c1=""end end end;if not q7 then if not be and not bd and not sy then sa=qC((sx-cO):normalize())elseif b4 and(bd or be)then sa=qC(-vec3(cK):normalize())end end;if bb then if not pS then b0=false;q2=a1;bP=fV(a1,2)pS=true end;local r6=c.getThrottle()if t then r6=bP end;local sK=99999;local oo=-vec3(bN.getWorldAcceleration()):dot(cK:normalize())local sL=dl(cK:dot((sx-cO):normalize()),0,cL)if sL>0 or oo>0 then sK=cp.computeTravelTime(sL,oo,r5-c4)end;if ab>df then ab=df-0.2 end;if cJ:len()>=ab or r6==0 and pS or a2/4>sK then bb=false;if bg~="Cruising"then fU("apCru","AP")bg="Cruising"end;be=true;q2=0 end;local sM=r5;if sM<=c4 or H and cW<=c4+10000 and cV then if H and cW<=c4+10000 and cV then if cW<pD and cW>2000 then ct.ResetAutopilots(1)c1="Autopilot cancelled to prevent crossing PvP Line"b0="PvP Prevent"pD=cW else pD=cW;return end end;bb=false;if bg~="Braking"then fU("apBrk","AP")bg="Braking"end;bd=true;q2=0;pS=false end elseif bd then if bg~="Orbiting to Target"then b0="AP Brk"end;if b4 then q2=1;q4=true end;local dQ,sk=cq(c6):escapeAndOrbitalSpeed((cO-kz.center):len()-kz.radius)local qJ;if g5 then qJ=g5.position-cO end;if g5 and g5.planetname=="Space"and cL<50 then if#bF>0 then if not qd then table.remove(bF,1)end;if#bF>0 then b0=false;if not qd then qd=2 end;return end end;sw("Autopilot complete, arrived at space location")b0="Space Arrival"elseif g5 and g5.planetname~="Space"and cL<=sk and(ft.apoapsis==nil or ft.periapsis==nil or ft.apoapsis.altitude<=0 or ft.periapsis.altitude<=0)then sw("Autopilot complete, commencing reentry")bk=g5.position;ca=true;ct.showWayPoint(c6,bk)elseif(g5 and g5.planetname~="Space"or g5==nil)and ft.periapsis~=nil and ft.periapsis.altitude>0 and ft.eccentricity<1 or bg=="Circularizing"then if bg~="Circularizing"then fU("apCir","AP")bg="Circularizing"end;if cL<=sk then if g5 then if cK:normalize():dot(qJ:normalize())>0.4 then if bg~="Orbiting to Target"then fU("apOrb","OB")bg="Orbiting to Target"end;if not qS then b0=false;ct.showWayPoint(c6,g5.position)qS=true end else sw("Autopilot complete, proceeding with reentry")bk=g5.position;ca=true;ct.showWayPoint(c6,g5.position)qS=false end else sw("Autopilot completed, setting orbit",true)b0=false end end elseif bg=="Circularizing"then sw("Autopilot complete, fixing Orbit",true)end elseif be then local sM=r5;if sM<=c4 or H and cW<=c4+10000 and cV then if H and cW<=c4+10000 and cV then if cW<pD and cW>2000 then if not qd then qd=true end;c1="Autopilot cancelled to prevent crossing PvP Line"b0="Prevent PvP"pD=cW else pD=cW;return end end;bb=false;if bg~="Braking"then fU("apBrk","AP")bg="Braking"end;bd=true end;local r6=c.getThrottle()if t then r6=bP end;if r6>0 then bb=true;if bg~="Accelerating"then bg="Accelerating"fU("apAcc","AP")end;be=false end else if sa then if not bc and g5==nil or not bc and g5 and g5.planetname~="Space"then if not ca then bk=vec3(c6.center)+(gp+c6.radius)*cI;sN=p_;sO=cI end;bc=true elseif sa and not q7 then bb=true;if bg~="Accelerating"then bg="Accelerating"fU("apAcc","AP")end;if not pS then q2=a1;q4=true;bP=fV(a1,2)pS=true;b0=false end end end end elseif b3 and(g5~=nil and g5.planetname~="Space"and ce)then c1="Autopilot complete, starting reentry"fU("apCom","AP")bk=g5.position;b0=false;bd=false;b3=false;qQ=false;bg="Aligning"q2=0;pS=false;b2=true;ca=true;ct.showWayPoint(c6,g5.position)end;if bZ then cz=true;local sF=0;local fv=cO+vec3(c.getMasterPlayerRelativePosition())local sP=fv-cO;local sQ=vec3(sP):project_on(cH):len()local sR=vec3(sP):project_on(cI):len()local c9=dn(sQ*sQ+sR*sR)qC(sP:normalize())local mx=40;local sS=c9<mx;local sT=100;local ri=dl((c9-mx)/2,10,sT)pU=0;local sa=eZ(pV)<0.1;if sa and cL<ri and not sS then b0=false;sF=-20 else b0="Follow"sF=0 end;local sU=0;if eZ(sF-cS)>sU then if sV==nil then sV=pid.new(2*0.01,0,2*0.1)end;sV:inject(sF-cS)local sH=sV:get()pU=sH end end;if b5 or b6 or b8 or bq or bt~=nil then local sW=bu;if sW then sW=sW*dl(cL/100,0.1,1)*cf else sW=bs end;if not ce then sW=bs end;q1=cH:project_on_plane(cM):normalize():dot(cK)if q1>100 then c4,c5=cp.computeDistanceAndTime(q1,100,ch,0,0,sW)local sX,sY=cp.computeDistanceAndTime(100,0,ch,0,0,sW*0.55)c4=c4+sX else c4,c5=cp.computeDistanceAndTime(q1,0,ch,0,0,sW*0.55)end;local so=ba-cg-cN;local sZ=200+cL;if b8 or ca then s_=2000+cL end;local t0=1;if b7 then t0=dl(cL/100,0.1,1)end;local sF=(utils.smoothstep(so,-sZ,sZ)-0.5)*2*Q*t0;if not b8 and not ca and not bq and cH:dot(cK:normalize())<0.99 then sF=(utils.smoothstep(so,-sZ*dl(20-19*cf*10,1,20),sZ*dl(20-19*cf*10,1,20))-0.5)*2*Q*dl(2-cf*10,1,2)*t0 end;if not b5 then sF=0 end;if bt~=nil then if cY and not bz then sF=bt else bt=nil end end;cz=true;local t1=pU;if b8 then local t2=bL(cB)local t3,t4=cp.computeDistanceAndTime(cL,t2/3.6,ch,0,0,bs-kz.gravity*9.8*ch)t3=t3==-1 and 5000 or t3;local qR=cg-(kz.noAtmosphericDensityAltitude+t3)local t5=cg>kz.noAtmosphericDensityAltitude+t3*1.35;if t5 then sF=R;if cL<=t2/3.6 and cL>t2/3.6-10 and eZ(cK:normalize():dot(cH))>0.9 and not cR then bT=false;q2=1 end elseif(cR or iE:getTargetSpeed(axisCommandId.longitudinal)~=t2)and not t5 and not ce then q3=t2;q4=true end;if cR then if cL>t2/3.6 and not t5 then b0="Reentry Limit"if bP>0 then q2=0 end else b0=false end else b0=false end;if cN>0 then b0="Reentry vSpd"end;if not pT then sF=-80;if cg<kz.surfaceMaxAltitude+(kz.atmosphereThickness-kz.surfaceMaxAltitude)*0.25 then c1="PARACHUTE DEPLOYED at "..fV(cg,0)b8=false;b6=true;lp=true;q2=0;sF=0;cz=p end elseif kz.noAtmosphericDensityAltitude>0 and t5 then cz=true elseif not t5 then if not ce and(cR or iE:getTargetSpeed(axisCommandId.longitudinal)~=t2)then q3=t2 end;if cL<t2/3.6+1 then b0=false;pT=false;b8=false;cz=true;q2=1 end end end;if cL>iX and not cb and not bq and not b6 and u then qC(vec3(cK))end;if cX or(bq or cb)and bl>0 and ce then local qJ;if cX then if type(cX)=="table"then qJ=cX elseif cX<3 and cX>0 then qJ=-cM:cross(cK)*5000 elseif cX>=3 then qJ=cM:cross(cK)*5000 elseif cX<0 then qJ=cK*25000 end elseif g5~=nil then qJ=g5.position-cO else qJ=c6.center-cO end;local sE=math.deg(qm(cM:normalize(),cK,qJ))*2;local mA=math.rad(eZ(cT))if cL>aL and ce then local t6=1000+cL;local t7=(utils.smoothstep(so-cN*10,-t6,t6)-0.5)*2*Q;local t8=dl(90-t7,0,180)pX=dl(sE*2,-t8,t8)local t9=sE;sE=dl(dl(sE,-N*0.80,N*0.80)*math.cos(mA)+4*(cS-sF)*math.sin(math.rad(cT)),-N*0.80,N*0.80)local ta=1;if pX~=0 then ta=eZ(mA/pX)end;ta=(90-dl(eZ(pX-cT),0,90))/90;local tb=sF;if eZ(cT)>90 then tb=-tb end;sF=ta*dl(dl(tb*math.cos(mA),-O*0.8,O*0.8)+eZ(dl(eZ(t9)*math.sin(mA),-O*0.80,O*0.80)),-O*0.80,O*0.80)else pX=0;sE=dl(sE,-N*0.80,N*0.80)end;local tc=s0-sE;if cX and eZ(tc)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and eZ(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fU("180Off","BR")return end;if not cA and cL>aL and ce then if td==nil then td=pid.new(2*0.01,0,2*0.1)end;td:inject(tc)local sJ=dl(td:get(),-1,1)pV=pV+sJ elseif ce and cd>-1 or cL<aL then qC(qJ)elseif cA and ce then if(s0<-N or s0>N)and ce then qC(cK)end;if(s1<-O or s1>O)and ce then sF=dl(cS-s1,cS-O*0.80,cS+O*0.80)end end;if g5~=nil and not cb then local sb=kz:getAltitude(g5.position)local qR=qJ:project_on_plane(cM):len()lp=true;if ba<kz.noAtmosphericDensityAltitude and not cb and not b7 and not b8 and(qR<=c4 and qJ:len()<kz.radius)and(cK:project_on_plane(cM):normalize():dot(qJ:project_on_plane(cM):normalize())>0.99 or lv=="Finalizing Approach")then lv="Finalizing Approach"if#bF>0 then if not qd then table.remove(bF,1)end;if#bF>0 then if not qd then qd=2 end;return end end;q2=0;if b5 then ct.ToggleAltitudeHold()bq=true end;b0="AP Finalizing"elseif not b7 then b0=false end;if lv=="Finalizing Approach"and(q1<0.1 or qR<0.1 or te~=nil and te<qR)then fU("bklOn","BL")b6=true;db=true;if g5.heading then dc=g5.heading else dc=nil end;bq=false;lv="Proceeding to Waypoint"cZ=false end;te=qR end elseif bq and not ce and ba>kz.noAtmosphericDensityAltitude and not(cb or b8)then if g5~=nil and c6.name==kz.name then local qJ=g5.position-cO;local sb=kz:getAltitude(g5.position)local qR=dn(qJ:len()^2-(cg-sb)^2)local sW=bu;if sW then c4,c5=cp.computeDistanceAndTime(cL,0,ch,0,0,sW/2)lp=true;if qR<=c4+cL*r_/2 and cK:project_on_plane(cM):normalize():dot(qJ:project_on_plane(cM):normalize())>0.99 then if kz.hasAtmosphere then b0=false;b2=false;pT=true;ca=false;cc=true;b3=false;ct.BeginReentry()end end;te=qR end end end;if not ce and(b5 and ba>kz.noAtmosphericDensityAltitude)and not(cb or bz or b8)then if not cE and not bz then cD=ba;pN=true;if bq then pZ.VectorToTarget=true end;ct.ToggleIntoOrbit()bq=false;pL=true end end;if cA and ce and cd==-1 and cL>aL and lv~="Finalizing Approach"then qC(cK)sF=dl(cS-s1,cS-O*0.80,cS+O*0.80)end;pU=t1;local qv=-1;if b6 then if not q8 then if not cR then q2=0 end;iE:setTargetGroundAltitude(500)iE:activateGroundEngineAltitudeStabilization(500)bB=true;q8=true end;sF=0;local tf=false;local tg=math.abs(q1)if not q and cQ then tf=antigrav.getBaseAltitude()if tf<kz.surfaceMaxAltitude and g5==nil or g5~=nil and kz:getAltitude(g5.position)>tf then tf=false end else tf=false end;if dc then if tg<0.05 then if cN>-P then b0=false else b0="BL Align BLR"end;if qC(dc,0.001)then dc=nil;cz=p else pU=0;cz=true end else b0="BL Align Hzn"end;if tf and eZ(cg-tf)<250 then b0="AGG Align"end else local th=false;local ti=30;if tg<10 and s7~=nil and s7>0 then local tj=dl(cf,0.4,2)local sW=bu*dl(cL/100,0.1,1)*tj;local tk=s7*tj+sW-oc;local tl=sW/2-oc;local tm=cL-dn(eZ(tl/2)*20/(0.5*ch))*utils.sign(tl)if tm<0 then tm=0 end;local tn;if cL>100 then local to,dQ=cp.computeDistanceAndTime(cL,100,ch,0,0,sW)local tp,dQ=cp.computeDistanceAndTime(100,0,ch,0,0,dn(sW))tn=to+tp else tn=cp.computeDistanceAndTime(cL,0,ch,0,0,dn(sW))end;if tn<20 then b0=false else local tq=0;if tm>100 then local tr,dQ=cp.computeDistanceAndTime(tm,100,ch,0,0,tk)local ts,dQ=cp.computeDistanceAndTime(100,0,ch,0,0,s7*tj+dn(sW)-oc)tq=tr+ts else tq,dQ=cp.computeDistanceAndTime(tm,0,ch,0,0,s7*tj+dn(sW)-oc)end;tq=(tq+15+cL*r_)*1.1;local tt=db and g5~=nil and kz:getAltitude(g5.position)>0 and g5.safe;local sb=nil;if tf and tf<cg then sb=tf elseif tt then sb=kz:getAltitude(g5.position)+250 elseif cg>kz.surfaceMaxAltitude then sb=kz.surfaceMaxAltitude end;if c_ then local tu=kz:getAltitude(c_[1].center)if sb then if tu>sb then sb=tu end else sb=tu end end;if sb~=nil then local tv=cg-sb;th=true;if tv<=tq or tq==-1 or tg>0.05 and db then if tg>0.05 and db then b0="BL AP Hzn"else b0="BL Stop Dist"end else b0=false end end end end;qv=cd;if qv>-1 then if(cL<1 or cK:normalize():dot(cM)<0)and not dc then b6=false;b5=false;if not tf then q5=true;iE:setTargetGroundAltitude(_)end;bY=0;b0="BL Complete"cz=p;db=false else b0="BL Slowing"end elseif not th then if lp and cK:normalize():dot(-gr)<0.999 then b0="BL Strong"qC()elseif tg>10 or tg>0.05 and db then b0="BL hSpd"elseif cN<-P then b0="BL BLR"else b0=false end end end else q8=false end;if b7 or cb then local lr,eK,eJ;if bk~=nil then lr,eK,eJ=co:getPlanetarySystem(0):castIntersections(cO,(bk-cO):normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)end;if cQ and not cb then if cg>=ba-50 and cL>iX then b7=false;if not b3 and not bq then b0="ATO Agg Arrive"q2=0 end end elseif eZ(sF)<15 and cg/ba>0.75 then b7=false;if not cb then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cb and cL<iX then b3=true;cb=false;b5=false;b7=false;q2=0 elseif cb then q2=0;b0="ATO Space"end elseif cb and not ce and c6~=nil and(lr==nil or lr.name==c6.name)then b3=true;cb=false;b5=false;b7=false;if not cR then q2=0 end;bb=true end end;local tw=cd>-1;local tx=cS;if(bq or cb or cX)and not tw and cL>aL and ce then local mA=math.rad(eZ(cT))tx=cS*eZ(math.cos(mA))+s1*math.sin(mA)end;local ty=dl(sF-tx,-O*0.80,O*0.80)if not ce and bq then ty=dl(sF-tx,-85,Q)elseif not ce then ty=dl(sF-tx,-Q,Q)end;if eZ(cT)<5 or bq or cX or b6 or tw or b5 then if sV==nil then sV=pid.new(5*0.01,0,5*0.1)end;sV:inject(ty)local sH=sV:get()pU=pU+sH end end;if antigrav~=nil and(antigrav and not q and cg<200000)then if bv==nil or bv<1000 then bv=1000 end;if tz~=bv then tz=bv;qc=tz end end;if(ce or b8 or cc)and t and cR then if tA==nil then tA=pid.new(0.1,0,1)end;local tB=0;if aU>0 and not b8 and cf>0.005 and cf<0.1 and cN>-50 then tB=(0.1-cf)*cB*aU end;tA:inject(cB/3.6+tB-cK:dot(cH))local tC=tA:get()bS=dl(tC,-1,1)if not d7 then if bS<bP and(cf>0.005 or b8 or cc)then bR=true;d7=dl(bS,0.01,1)else bR=false;d7=bP end end;if tD==nil then tD=pid.new(1*0.01,0,1*0.1)end;tD:inject(cK:len()-cB/3.6-tB)local tE=dl(tD:get(),0,1)if ce and cN<-80 or(cf>0.005 or b8 or cc)then bQ=tE end;if bQ>0 then if bR and bS==0.01 and not d7 then d7=0 end else bS=dl(bS,0.01,1)end;local tF=''local tG=vec3()local tH=rg(axisCommandId.vertical,bY*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tH,rW)local tI='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then tI=tI..aV end;local tJ=iE:getAxisCommandType(axisCommandId.longitudinal)local tK=iE:composeAxisAccelerationFromThrottle(tI,axisCommandId.longitudinal)local tL=ru(axisCommandId.lateral,by*1000)tF=tF..' , '.."lateral airfoil , lateral ground "tG=tG+tL;if tG:len()>constants.epsilon then d:setEngineForceCommand(tF,tG,rW,'','','',rX)end;d:setEngineForceCommand(tI,tK,rV)local tM='thrust analog vertical fueled 'local tN='thrust analog lateral fueled 'if bC=="All"or bC=="Lateral"then tN=tN..aW end;if bC=="All"or bC=="Vertical"then tM=tM..aX end;if bY~=0 or b6 and b0 or not bm and not bB then d:setEngineForceCommand(tM,tH,rV)else d:setEngineForceCommand(tM,vec3(),rV)end;if by~=0 then d:setEngineForceCommand(tN,tL,rV)else d:setEngineForceCommand(tN,vec3(),rV)end;if rH==0 then rH=bQ end;local tO=-rH*(aQ*cK+aR*rL)d:setEngineForceCommand('brake',tO)else if t then if not d7 then d7=bP end end;local ri=c.getAxisCommandValue(0)if not cR then if tD==nil then tD=pid.new(1*0.01,0,1*0.1)end;tD:inject(cK:len()-ri/3.6)local tE=dl(tD:get(),0,1)rH=dl(rH+tE,0,1)end;local tO=-rH*(aQ*cK+aR*rL)d:setEngineForceCommand('brake',tO)local tF=''local tG=vec3()local tP=false;local tI='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then tI=tI..aV end;local tJ=iE:getAxisCommandType(axisCommandId.longitudinal)if tJ==axisCommandType.byThrottle then local tK=iE:composeAxisAccelerationFromThrottle(tI,axisCommandId.longitudinal)d:setEngineForceCommand(tI,tK,rV)elseif tJ==axisCommandType.byTargetSpeed then local tK=iE:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tF=tF..' , '..tI;tG=tG+tK;if iE:getTargetSpeed(axisCommandId.longitudinal)==0 or iE:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iE:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tP=true end end;local tN='thrust analog lateral 'if bC=="All"or bC=="Lateral"then tN=tN..aW end;local tQ=iE:getAxisCommandType(axisCommandId.lateral)if tQ==axisCommandType.byThrottle then local tR=iE:composeAxisAccelerationFromThrottle(tN,axisCommandId.lateral)d:setEngineForceCommand(tN,tR,rV)elseif tQ==axisCommandType.byTargetSpeed then local tL=iE:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tF=tF..' , '..tN;tG=tG+tL end;local tM='thrust analog vertical 'if bC=="All"or bC=="Vertical"then tM=tM..aX end;local tS=iE:getAxisCommandType(axisCommandId.vertical)if tS==axisCommandType.byThrottle then local tH=iE:composeAxisAccelerationFromThrottle(tM,axisCommandId.vertical)if bY~=0 or b6 and b0 then d:setEngineForceCommand(tM,tH,rV,'airfoil','ground','',rX)else d:setEngineForceCommand(tM,vec3(),rV)d:setEngineForceCommand('airfoil vertical',tH,rV,'airfoil','','',rX)d:setEngineForceCommand('ground vertical',tH,rV,'ground','','',rX)end elseif tS==axisCommandType.byTargetSpeed then if bY<0 then d:setEngineForceCommand('hover',vec3(),rV)end;local tT=iE:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tF=tF..' , '..tM;tG=tG+tT end;if tG:len()>constants.epsilon then if rH~=0 or tP or eZ(rL:dot(cH))<0.5 then tF=tF..', brake'end;d:setEngineForceCommand(tF,tG,rW,'','','',rX)end end;local tU=aN*(rP-rO)local tV=vec3(bN.getWorldAirFrictionAngularAcceleration())tU=tU-tV;d:setEngineTorqueCommand('torque',tU,rV,'airfoil','','',rX)d:setBoosterCommand('rocket_engine')if c3 and not n then local fp=cJ:len()local tW=0.15;if not cR then local tX=iE:getTargetSpeed(axisCommandId.longitudinal)if fp*3.6>tX*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fp*3.6<tX*(1-tW)and not tY then tY=true;d:toggleBoosters()end else local r6=c.getThrottle()if t then r6=bP*100 end;local ri=r6/100;if not ce then ri=ri*ab;if fp>=ri*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fp<ri*(1-tW)and not tY then tY=true;d:toggleBoosters()end else local t2=bL(cB)ri=ri*t2/3.6;if fp>=ri*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fp<ri*(1-tW)and not tY then tY=true;d:toggleBoosters()end end end end end;if tZ then for dL,dx in pairs(tZ)do pB[dL]=dx end end;cd=qq()return pB end;local function t_(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u0,iD,iE,iF,u1,gM,fV,e4,dm,dl,fU,iH,pA)local bN=DUConstruct;local u2={}local u3=true;local u4=5;local u5=5;local u6=u4;local u7=u5;local u8=bO;function u2.landingGear()bm=not bm;if bm then bq=false;bt=nil;ct.cmdThrottle(0)if vBooster or hover then if ce and cd==-1 then fU("bklOn","BL")lp=true;b8=false;b7=false;b9=false;b5=false;if b6 then db=not db end;b6=true;cz=true;bm=false else if bU then fU("grOut","LG",1)d.control.deployLandingGears()end;db=false;iE:setTargetGroundAltitude(_)if ce then b0="Landing"end end elseif bU and not b6 then fU("grOut","LG",1)d.control.deployLandingGears()end else if bU then fU("grIn","LG",1)d.control.retractLandingGears()end;iE:activateGroundEngineAltitudeStabilization(u9)if bB then if _<iE.targetGroundAltitude then iE:setTargetGroundAltitude(iE.targetGroundAltitude)else iE:setTargetGroundAltitude(Z)end end end end;function u2.startControl(ua)local function ub(r1)local r2=1;local function uc(ud,r1)local ue={kz.surfaceMaxAltitude+100,kz.spaceEngineMinAltitude-0.01*kz.noAtmosphericDensityAltitude,kz.noAtmosphericDensityAltitude+V,kz.radius*(U-1)+kz.noAtmosphericDensityAltitude}local uf=ud;for dQ,dx in ipairs(ue)do if r1 and uf>dx then ud=dx elseif ud<dx and not r1 then ud=dx;break end end;return ud end;if r1 then r2=-1 end;if not q and cQ then if b_ and r1 then bv=1000 elseif bv~=nil then bv=bv+r2*u5;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end else bv=tz+r2*100 end elseif b5 or b9 or bz then if bz then if b_ then cD=uc(cD,r1)else cD=cD+r2*u4 end;if cD<kz.noAtmosphericDensityAltitude then cD=kz.noAtmosphericDensityAltitude end else if b_ and ce then ba=uc(ba,r1)else ba=ba+r2*u4 end end else iE:updateTargetGroundAltitudeFromActionStart(r2*1.0)end end;local function ug(uh)if not ce then c1="Flight Assist in Atmo only"return end;local du=type(uh)if cX==nil then if du=="table"then if b3 or bq then ct.ToggleAutopilot()end;fU("180On","BR")elseif uh==1 then fU("bnkLft","BR")else fU("bnkRht","BR")end;if not b5 and not b3 and not bq then ct.ToggleAltitudeHold()if du~="table"then uh=uh+1 end end;cX=uh else fU("180Off","BR")cX=nil end end;local function ui()if iF()==1 then c7=0;c8=0;u1(bi)elseif iD()==1 and y then cy=false;cx=false end;b_=false end;if ua=="gear"then cv.landingGear()elseif ua=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ua=="forward"then if p2 and not ce and not b3 then b2=not b2;b1=false else bV=bV-1 end elseif ua=="backward"then if p2 then if not ce then if not b3 then b1=not b1;b2=false else b4=not b4 end else ug(-cK*5000)end else bV=bV+1 end elseif ua=="left"then if p2 then ug(1)else bW=bW-1 end elseif ua=="right"then if p2 then ug(3)else bW=bW+1 end elseif ua=="yawright"then bX=bX-1;dc=nil elseif ua=="yawleft"then bX=bX+1;dc=nil elseif ua=="straferight"then iE:updateCommandFromActionStart(axisCommandId.lateral,1.0)by=1 elseif ua=="strafeleft"then iE:updateCommandFromActionStart(axisCommandId.lateral,-1.0)by=-1 elseif ua=="up"then bY=bY+1;if cd-3<_ and cg>0 and bm then cv.landingGear()end;iE:deactivateGroundEngineAltitudeStabilization()iE:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ua=="down"then bY=bY-1;iE:deactivateGroundEngineAltitudeStabilization()iE:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ua=="groundaltitudeup"then ub()elseif ua=="groundaltitudedown"then ub(true)elseif ua=="option1"then uj=false;if p2 and b_ then local uk=""for M=1,#d2 do uk=uk.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fV(bN.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..uk)return end;cs.adjustAutopilotTargetIndex()elseif ua=="option2"then uj=false;if p2 and b_ then for M=1,#d2 do bN.forceDeboard(d2[M])bN.forceInterruptVRSession(d2[M])end;c1="Deboarded All Passengers"return end;cs.adjustAutopilotTargetIndex(1)elseif ua=="option3"then local function ul()u3=not u3;if not u3 then fU("wid","DH")c.showWidget()b.showWidget()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(um,atmofueltank_size,"Atmo Fuel","fuel_container")un=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uo,spacefueltank_size,"Space Fuel","fuel_container")up=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uq,rocketfueltank_size,"Rocket Fuel","fuel_container")ur=_autoconf.panels[_autoconf.panels_size]end;us=a.createWidgetPanel("Docking")ut=a.createWidget(us,"parenting")a.addDataToWidget(c.getWidgetDataId(),ut)uu=a.createWidgetPanel("Core combat stress")uv=a.createWidget(uu,"core_stress")a.addDataToWidget(b.getWidgetDataId(),uv)if shield~=nil then shield.showWidget()end else fU("hud","DH")c.hideWidget()b.hideWidget()if un~=nil then gM(un)un=nil end;if us~=nil then gM(us)us=nil end;if uu~=nil then gM(uu)uu=nil end;if up~=nil then gM(up)up=nil end;if ur~=nil then gM(ur)ur=nil end;if shield~=nil then shield.hideWidget()end end end;uj=false;if p2 and b_ then local uk=""for M=1,#d3 do uk=uk.."| ID: "..d3[M].." Mass: "..fV(b.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..uk)return end;if x then if w then w=false else w=true end end;ul()elseif ua=="option4"then uj=false;if p2 and b_ then for M=1,#d3 do b.forceUndock(d3[M])end;c1="Undocked all ships"return end;cX=nil;ct.ToggleAutopilot()elseif ua=="option5"then uj=false;ct.ToggleLockPitch()elseif ua=="option6"then uj=false;if p2 and b_ then if shield then cw.ventShield()else c1="No shield found"end;return end;ct.ToggleAltitudeHold()elseif ua=="option7"then uj=false;if p2 and b_ then if shield then shield.toggle()return else c1="No shield found"return end end;E=not E;if E then c1="Collision System Enabled"else c1="Collision System Secured"end elseif ua=="option8"then uj=false;if p2 and b_ then if bl>0 and g5~=nil then ct.routeWP()else c1="Select a saved wp on IPH to add to or remove from route"end;return end;bB=not bB;if not bB then c1="DeCoupled Mode - Ground Stabilization off"iE:deactivateGroundEngineAltitudeStabilization()fU("gsOff","GS")else c1="Coupled Mode - Ground Stabilization on"iE:activateGroundEngineAltitudeStabilization(u9)de=true;fU("gsOn","GS")end elseif ua=="option9"then uj=false;if p2 and b_ then iE:resetCommand(axisCommandId.longitudinal)iE:resetCommand(axisCommandId.lateral)iE:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ci=gyro.getState()==1;if ci then fU("gyOn","GA")else fU("gyOff","GA")end else c1="No gyro found"end elseif ua=="lshift"then d0=false;if p2 then b_=true elseif b_ then ui()else if iF()==1 then b_=true;bi=iF()u1(1)elseif iD()==1 and y then b_=true;cy=false;cx=false end end elseif ua=="brake"then if aZ or p2 then ct.BrakeToggle("Manual")elseif not b0 then ct.BrakeToggle("Manual")else b0="Manual"end elseif ua=="lalt"then uj=true;p2=true;if iD()==0 and not i and g=="keyboard"then u1(1)end elseif ua=="booster"then if n then d:toggleBoosters()elseif not c3 then if not tY then d:toggleBoosters()tY=true end;c3=true else if tY then d:toggleBoosters()tY=false end;c3=false end elseif ua=="stopengines"then local function uw()if bO-u8<1.5 then fU("clear","CA")ct.clearAll()end end;uw()u8=bO;if iE:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bP~=0 then iE:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iE:getTargetSpeed(axisCommandId.longitudinal)~=0 then iE:resetCommand(axisCommandId.longitudinal)else if ce then ct.cmdCruise(cB)else ct.cmdCruise(ab*3.6)end end end elseif ua=="speedup"then if b_ and not p2 then dh("RADAR OFF")return end;ct.changeSpd()elseif ua=="speeddown"then ct.changeSpd(true)elseif ua=="antigravity"and not q then if antigrav~=nil then ct.ToggleAntigrav()else c1="No antigrav found"end elseif ua=="leftmouse"then c0=true;ui()uj=false end end;function u2.stopControl(ua)local function ux()if not q and cQ then u7=u5 end;if b5 or b9 or bz then u6=u4 end end;if ua=="forward"then bV=0 elseif ua=="backward"then bV=0 elseif ua=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bW=0 elseif ua=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bW=0 elseif ua=="yawright"then bX=0 elseif ua=="yawleft"then bX=0 elseif ua=="straferight"then iE:updateCommandFromActionStop(axisCommandId.lateral,-1.0)by=0 elseif ua=="strafeleft"then iE:updateCommandFromActionStop(axisCommandId.lateral,1.0)by=0 elseif ua=="up"then bY=0;iE:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bB then iE:activateGroundEngineAltitudeStabilization(u9)de=true end elseif ua=="down"then bY=0;iE:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bB then iE:activateGroundEngineAltitudeStabilization(u9)de=true end elseif ua=="groundaltitudeup"then ux()uj=false elseif ua=="groundaltitudedown"then ux()uj=false elseif ua=="brake"then if not aZ and not p2 then if b0 then ct.BrakeToggle()else b0=false end end elseif ua=="lalt"then if b_ then b_=false end;if iD()==0 and i then if uj then if iF()==1 then u1(0)else u1(1)end else uj=true end elseif iD()==0 and not i and g=="keyboard"then u1(0)end;p2=false end end;function u2.loopControl(ua)local function uy(r1)local r2=1;if r1 then r2=-1 end;if not q and cQ then if bv~=nil then bv=bv+r2*u7;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end;u7=dl(u7*1.05,u5,50)else bv=tz+r2*100 end elseif b5 or b9 or bz then if bz then cD=cD+r2*u6;if cD<kz.noAtmosphericDensityAltitude then cD=kz.noAtmosphericDensityAltitude end else ba=ba+r2*u6 end;u6=dl(u6*1.05,u4,50)else iE:updateTargetGroundAltitudeFromActionLoop(r2*1.0)end end;local function uz(r1)local r2=1;if r1 then r2=-1 end;if not b_ then if t and not p2 then bP=dl(bP+r2*aF/100,-1,1)else iE:updateCommandFromActionLoop(axisCommandId.longitudinal,r2*aF)end end end;if ua=="groundaltitudeup"then if not b_ then uy()end elseif ua=="groundaltitudedown"then if not b_ then uy(true)end elseif ua=="speedup"then uz()elseif ua=="speeddown"then uz(true)end end;function u2.inputTextControl(r0)local function uA(uB,fv,gz)local function uC(fv)local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local dU,dV,e1,e2,e3=e4(fv,dE)if dU=="0"and dV=="0"then return vec3(dm(e1),dm(e2),dm(e3))end;e2=math.rad(e2)e1=math.rad(e1)local kz=e[dm(dU)][dm(dV)]local eV=math.cos(e1)local uD=vec3(eV*math.cos(e2),eV*math.sin(e2),math.sin(e1))return kz.center+(kz.radius+e3)*uD end;local fX=uC(fv)return cs.AddNewLocation(uB,fX,gz)end;local M;local uE,is=nil,nil;local uF="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(r0," ")uE=r0;if M~=nil then uE=string.sub(r0,0,M-1)is=string.sub(r0,M+1)end;if uE=="/help"or uE=="/commands"then for lq in string.gmatch(uF,"([^\n]+)")do a.print(lq)end;return elseif uE=="/setname"then if is==nil or is==""then c1="Usage: ah-setname Newname"return end;if bl>0 and g5~=nil then cs.UpdatePosition(is)else c1="Select a saved target to rename first"end elseif shield and uE=="/resist"then cw.setResist(is)elseif uE=="/addlocation"or string.find(r0,"::pos")~=nil then local gz=false;local uB="0-Temp"if is==nil or is==""or uE~="/addlocation"then is=uE;gz=true end;M=string.find(is,"::")if not gz then uB=string.sub(is,1,M-2)end;local fv=string.sub(is,M)uA(uB,fv,gz)elseif uE=="/agg"then if is==nil or is==""then c1="Usage: /agg targetheight"return end;is=dm(is)if is<1000 then is=1000 end;bv=is;c1="AGG Target Height set to "..is elseif uE=="/G"then if is==nil or is==""then c1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if is=="dump"then for dL,dx in pairs(iH())do if type(dx.get())=="boolean"then if dx.get()==true then a.print(dL.." true")else a.print(dL.." false")end elseif dx.get()==nil then a.print(dL.." nil")else a.print(dL.." "..dx.get())end end;return end;M=string.find(is," ")local uG=string.sub(is,0,M-1)local uH=string.sub(is,M+1)for dL,dx in pairs(iH())do if dL==uG then local uI=type(dx.get())if uI=="number"then uH=dm(uH)if dL=="AtmoSpeedLimit"then cB=uH end end;c1="Variable "..uG.." changed to "..uH;if dL=="MaxGameVelocity"then uH=uH/3.6;if uH>df-0.2 then uH=df-0.2;c1="Variable "..uG.." changed to "..fV(uH*3.6,1)end end;if uI=="boolean"then if string.lower(uH)=="true"then uH=true else uH=false end end;dx.set(uH)return end end;c1="No such global variable: "..uG elseif uE=="/deletewp"then if bl>0 and g5~=nil then cs.ClearCurrentPosition()else c1="Select a custom wp to delete first in IPH"end elseif uE=="/copydatabank"then if dbHud_2 then pA(true)else c1="Spare Databank required to copy databank"end elseif uE=="/iphWP"then if bl>0 then a.print(ct.showWayPoint(c6,bk,true))a.print(json.encode(bk))c1="::pos waypoint shown in lua chat in local and world format"else c1="No target selected in IPH"end elseif uE=="/createPrivate"then local uJ="privatelocations = {\n"local uK=""if#d9>0 then for dL,dx in pairs(d9)do uJ=uJ.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uJ=uJ.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uJ=uJ.."safe = true},\n"else uJ=uJ.."safe = false},\n"end end end;uK=#d9 .."-Private "if is=="all"then for dL,dx in pairs(bp)do uJ=uJ.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '*"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uJ=uJ.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uJ=uJ.." safe = true},\n"else uJ=uJ.."safe = false},\n"end end;uK=uK..#bp.."-Public "end;uJ=uJ.."}\n return privatelocations"if u0 then u0.setHTML(uJ)end;c1=uK.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c2=7 end end;function u2.tagTick()if bC=="Off"then bC="All"elseif bC=="All"then bC="Longitude"elseif bC=="Longitude"then bC="Lateral"elseif bC=="Lateral"then bC="Vertical"else bC="Off"end;c1="Extra Engine Tags: "..bC;c.stopTimer("tagTick")end;if uL then for dL,dx in pairs(uL)do u2[dL]=dx end end;return u2 end;local function uM(d,b,c,e,vBooster,hover,pz,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iA,u0)local a=DUSystem;local bN=DUConstruct;local uN=DUPlayer;local uO=DULibrary;local uP={}local dk=string.format;local iB=json.decode;local uQ=json.encode;local ps=b.getElementMaxHitPointsById;local iC=b.getElementMassById;local iD=d.control.isRemoteControlled;local e4=string.match;local gM=a.destroyWidgetPanel;local fS=a.updateData;local fT=a.addDataToWidget;local u1=a.lockView;local iF=a.isViewLocked;local dn=math.sqrt;local dm=tonumber;local eZ=math.abs;local bL=math.floor;local bM=c.getAtmosphereDensity;local eU=math.atan;local bK=a.getArkTime;local dl=utils.clamp;local iE=d.axisCommandManager;local uR=_;local gO=13;local iK=b.getElementIdList()local iL=0;local function dp(eC,eD)if eC==0 then return eZ(eD)<1e-09 end;if eD==0 then return eZ(eC)<1e-09 end;return eZ(eC-eD)<math.max(eZ(eC),eZ(eD))*dC end;local function fV(dD,uS)local r2=10^(uS or 0)return bL(dD*r2+0.5)/r2 end;local function iG(uT,uU)for dL,dx in pairs(uU)do if type(dL)=="string"then uT[dL]=dx else uT[#uT+1]=uU[dL]end end;return uT end;local function iH(uV)local uW={}if not uV then iG(uW,L)iG(uW,aa)iG(uW,aD)iG(uW,aY)return uW elseif uV=="boolean"then return L elseif uV=="handling"then return aa elseif uV=="hud"then return aD elseif uV=="physics"then return aY end end;local function pA(uX)local function uY(uZ)for dL,dx in pairs(uZ)do dbHud_1.setStringValue(dL,uQ(dx.get()))if uX and dbHud_2 then dbHud_2.setStringValue(dL,uQ(dx.get()))end end end;if dbHud_1 then uY(bH)uY(iH())a.print("Saved Variables to Datacore")if uX and dbHud_2 then c1="Databank copied.  Remove copy when ready."end end end;local function fU(u_,v0,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..u_..".mp3")end;local function gN(hA,hB,r0,jR,v1)if jR==nil then jR=""end;if v1==nil then v1=""end;return dk([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jR,hA,hB,v1,r0)end;local function iI(c9,v2)local v3=c9>100000;if v2==nil then v2=1 end;if v3 then return fV(c9/1000/200,v2).."SU"elseif c9<1000 then return fV(c9,v2).."M"else return fV(c9/1000,v2).."KM"end end;local function iJ(v4)local v5=0;local v6=0;local v7=0;if v4<60 then v4=bL(v4)elseif v4<3600 then v5=bL(v4/60)v4=bL(v4%60)elseif v4<86400 then v6=bL(v4/3600)v5=bL(v4%3600/60)else v7=bL(v4/86400)v6=bL(v4%86400/3600)end;if v7>0 then return v7 .."d "..v6 .."h "elseif v6>0 then return v6 .."h "..v5 .."m "elseif v5>0 then return v5 .."m "..v4 .."s"elseif v4>0 then return v4 .."s"else return"0s"end end;local function v8()if radar_1 and J then cu=gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU)end end;function uP.radarSetup()v8()end;function uP.onStart()local v9=false;local function va()local function vb(vc)local vd=dbHud_1.hasKey;for dL,dx in pairs(vc)do if vd(dL)then local dG=iB(dbHud_1.getStringValue(dL))if dG~=nil then dx.set(dG)v9=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vb(iH())coroutine.yield()vb(bH)else vb(bH)c1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"c2=5;v9=false end;coroutine.yield()if v9 then c1="Loaded Saved Variables"elseif not f then c1="No Databank Saved Variables Found\nVariables will save to Databank on standing"c2=5 end;if#bp>0 then da=iG(da,bp)end else c1="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;cj=ac;ck=ad;aZ=j;g=string.lower(g)cz=p;cB=W;if bw+180<bO then bu=0 end;bw=bO;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c2=7 end;if antigrav and not q then if bv==nil then bv=cg end;antigrav.setTargetAltitude(bv)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d9>0 then da=iG(da,d9)end end;lv="Proceeding to Waypoint"if not ab or ab<0 then ab=bN.getMaxSpeed()-0.1 end end;local function ve()local function vf(vg,vh)if vg>vh then vh=vg end;local vi,vj=0,0;if a6>0 then vi=a6*0.05 end;if a7>0 then vj=a7*0.05 end;vh=vh*(1-(vi+vj))return vh end;local vk=b.getElementNameById;local vl=at~=0 and au~=0;local vm=_G["atmofueltank_size"]local vn=_G["spacefueltank_size"]local vo=_G["rocketfueltank_size"]for dL in pairs(iK)do local type=b.getElementDisplayNameById(iK[dL])if e4(type,'^.*Atmospheric Engine$')then if e4(tostring(b.getElementTagsById(iK[dL])),'^.*vertical.*$')and b.getElementForwardById(iK[dL])[3]>0 then cP=true end end;if e4(type,'^.*Space Engine$')then cG=true;if e4(tostring(b.getElementTagsById(iK[dL])),'^.*vertical.*$')then local vp=b.getElementForwardById(iK[dL])if vp[3]<0 then vq=true else cF=true end end end;if type=="Landing Gear"then bU=true end;if type=="Dynamic Core Unit"then local pu=ps(iK[dL])if pu>10000 then gO=110 elseif pu>1000 then gO=55 elseif pu>150 then gO=27 end end;iL=iL+ps(iK[dL])if vl and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pu=ps(iK[dL])local ok=iC(iK[dL])local vg=0;local jK=bK()if type=="Atmospheric Fuel Tank"then local vh=400;local vr=35.03;if pu>10000 then vh=51200;vr=5480 elseif pu>1300 then vh=6400;vr=988.67 elseif pu>150 then vh=1600;vr=182.67 end;vg=ok-vr;if a3>0 then vh=vh+vh*a3*0.2 end;vh=vf(vg,vh)local gy=vk(iK[dL])local jI=0;for jJ=1,vm do if gy==iB(c["atmofueltank_"..jJ].getWidgetData()).name then jI=jJ;break end end;local vs={iK[dL],string.sub(gy,1,12),vh,vr,vg,jK,jI}cl[#cl+1]=vs end;if type=="Rocket Fuel Tank"then local vh=320;local vr=173.42;if pu>65000 then vh=40000;vr=25740 elseif pu>6000 then vh=5120;vr=4720 elseif pu>700 then vh=640;vr=886.72 end;vg=ok-vr;if a5>0 then vh=vh+vh*a5*0.1 end;vh=vf(vg,vh)local gy=vk(iK[dL])local jI=0;for jJ=1,vo do if gy==iB(c["rocketfueltank_"..jJ].getWidgetData()).name then jI=jJ;break end end;local vs={iK[dL],string.sub(gy,1,12),vh,vr,vg,jK,jI}cn[#cn+1]=vs end;if type=="Space Fuel Tank"then local vh=600;local vr=35.03;if pu>10000 then vh=76800;vr=5480 elseif pu>1300 then vh=9600;vr=988.67 elseif pu>150 then vh=2400;vr=182.67 end;vg=ok-vr;if a4>0 then vh=vh+vh*a4*0.2 end;vh=vf(vg,vh)local gy=vk(iK[dL])local jI=0;for jJ=1,vn do if gy==iB(c["spacefueltank_"..jJ].getWidgetData()).name then jI=jJ;break end end;local vs={iK[dL],string.sub(gy,1,12),vh,vr,vg,jK,jI}cm[#cm+1]=vs end end end;if not cP then b9,a_=false,false end end;local function vt()if gyro~=nil then ci=gyro.isActive()==1 end;if not bB then iE:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u1(1)else u1(0)end;if door and(ce or not ce and cg<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(ce or not ce==0 and cg<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not q then antigrav.showWidget()end end;if iD()==1 and k then uN.freeze(1)else uN.freeze(0)end;if bU then if cd~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bm=d.control.isAnyLandingGearDeployed()==1 or cd~=-1 and cd-3<_;if cd~=-1 or not ce and cJ:len()<50 then b0="Startup"else b0=false end;iE:setTargetGroundAltitude(uR)pg=ce end;local function vu()local vv={}local function vw()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vx={[1]=4480,[6]=4480,[7]=6270,[27]=4150}local vy={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=7700,[100]=12511,[110]=7792,[120]=11766}for vz,vA in pairs(e)do e[vz][0]=vw()e[vz][0].systemId=vz;vv[vz]={}for vB,kz in pairs(e[vz])do kz.gravity=kz.gravity/9.8;kz.center=vec3(kz.center)kz.name=kz.name[1]kz.noAtmosphericDensityAltitude=vy[kz.id]or kz.atmosphereThickness or kz.atmosphereRadius-kz.radius;kz.spaceEngineMinAltitude=vx[kz.id]or 0.68377*kz.atmosphereThickness;kz.planetarySystemId=vz;kz.bodyId=kz.id;vv[vz][vB]=kz;if ml==nil or kz.center.x<ml then ml=kz.center.x end;if mk==nil or kz.center.x>mk then mk=kz.center.x end;if mo==nil or kz.center.y<mo then mo=kz.center.y end;if mn==nil or kz.center.y>mn then mn=kz.center.y end;if kz.center and kz.name~="Space"then d4[#d4+1]=kz end end end;ee=dj(d,b,c,a,dk,dl,dm,dn,dp)co=ee(vv)cp=eY(d,b,c,a,dn,eZ)cq=fr(d,b,c,a,dk,dl,dm,dn,dp)cs=fR(d,b,c,a,dbHud_1,e,fS,fT,bL,dm,dn,fU,fV)kz=co[0]:closestBody(bN.getWorldPosition())end;vC=false;vD=coroutine.create(function()iE:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})va()coroutine.yield()ve()coroutine.yield()ct=py(d,b,c,e,vBooster,hover,pz,antigrav,warpdrive,dbHud_1,eZ,bL,bM,iD,eU,bK,dl,iE,fS,iF,dn,fV,fU,iG,dp,iI,iJ,pA,iB,dk,fT)vt()coroutine.yield()vu()v8()if iz then cr=iz(d,b,c,a,e,antigrav,hover,shield,warpdrive,iA,eZ,bL,dk,iB,bM,iC,iD,eU,bK,dl,iE,fT,fS,gM,iF,dn,fV,gN,fU,iG,iH,iI,iJ,iK,iL)end;if cr then cr.ButtonSetup()end;cv=t_(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u0,iD,iE,iF,u1,gM,fV,e4,dm,dl,fU,iH,pA)if shield then cw=ii(shield,e4,bL)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if u0 then u0.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vE then ny.ExtraOnStart()end;fU("start","SU")local function vF()if bG[1]==0 then ct.cmdThrottle(bG[2])else if cf>0 then cB=bG[2]ct.cmdThrottle(1)end end end;lm=string.find(c.getName(),"Emergency")or false;if lm then if cd>-1 and cL<1 and cd-3<_ then c.exit()else if K then vF()else if cf==0 then b0="ECU Braking"elseif cd==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif K and bG[3]+3>bK()then vF()end end)coroutine.resume(vD)end;function uP.onUpdate()if not vC then local i9=coroutine.status(vD)if i9=="suspended"then local dM,ia=coroutine.resume(vD)if ia then a.print("ERROR STARTUP: "..ia)end elseif i9=="dead"then vC=true end end;if vC then d:update()if ce and t and cR then if cR and bT then ct.cmdThrottle(0)bT=false elseif not cR and not bT then bP=0;bT=true end end;if d7 then iE:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and p4~=vG then a.setScreen(p4)end;vG=p4;if lm and not K and cf>0 and cd==-1 then cv.landingGear()end;if lm and cd>-1 and cL<1 and cd-3<_ then c.exit()end;if vE then ny.ExtraOnUpdate()end end end;function uP.onFlush()if vC then ct.onFlush()if vE then ny.ExtraOnFlush()end end end;function uP.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cf>0 or cf==0 and cg<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(cf>0 or cf==0 and cg<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;w=d6;local vH=0;if lm then vH=bK()end;if iE:getAxisCommandType(0)==0 then bG={0,bP,vH}else bG={1,iE:getTargetSpeed(axisCommandId.longitudinal),vH}end;pA()if nV then nV.activate()end;if z then ct.showWayPoint(kz,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vE then ny.ExtraOnStop()end;fU("stop","SU")end;function uP.controlStart(ua)if vC then cv.startControl(ua)end end;function uP.controlStop(ua)if vC then cv.stopControl(ua)end end;function uP.controlLoop(ua)if vC then cv.loopControl(ua)end end;function uP.controlInput(r0)if vC then cv.inputTextControl(r0)end end;function uP.radarEnter(dV)if cu then cu.onEnter(dV)end end;function uP.radarLeave(dV)if cu then cu.onLeave(dV)end end;function uP.onTick(vI)if vI=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vI=="oneSecond"then if cr then cr.OneSecondTick()end elseif vI=="fiveSecond"then ct.SatNavTick()elseif vI=="msgTick"then if cr then cr.MsgTick()end elseif vI=="animateTick"then if cr then cr.AnimateTick()end elseif vI=="hudTick"then if cr then cr.hudtick()end elseif vI=="apTick"then if ct then ct.APTick()end elseif vI=="shieldTick"then cw.shieldTick()elseif vI=="tagTick"then cv.tagTick()elseif vI=="contact"then cu.ContactTick()end end;if vE then for dL,dx in pairs(vE)do uP[dL]=dx end end;return uP end;function script.onStart()ny.onStart()end;function script.onOnStop()ny.onStop()end;function script.onTick(vI)ny.onTick(vI)end;function script.onOnFlush()ny.onFlush()end;function script.onOnUpdate()ny.onUpdate()end;function script.onActionStart(ua)ny.controlStart(ua)end;function script.onActionStop(ua)ny.controlStop(ua)end;function script.onActionLoop(ua)ny.controlLoop(ua)end;function script.onInputText(r0)ny.controlInput(r0)end;function script.onEnter(dV)ny.radarEnter(dV)end;function script.onLeave(dV)ny.radarLeave(dV)end;bJ(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)ny=uM(d,core,unit,e,vBooster,hover,pz,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iA,u0)script.onStart()
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
