name: ArchHud - Archaegeo v0.013 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.013;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.3;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab=1;ac={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end},DockingMode={set=function(M)ab=M end,get=function()return ab end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV=1.0;aW="none"aX="none"aY="none"aZ=0.05;a_={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aV=M end,get=function()return aV end},ExtraLongitudeTags={set=function(M)aW=M end,get=function()return aW end},ExtraLateralTags={set=function(M)aX=M end,get=function()return aX end},ExtraVerticalTags={set=function(M)aY=M end,get=function()return aY end},allowedHorizontalDrift={set=function(M)aZ=M end,get=function()return aZ end}}b0=k;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=false;bc=1000;bd=false;be=false;bf=false;bg=false;bh=0;bi="Aligning"bj=0;bk=1;bl="None"bm=nil;bn=0;bo=nil;bp=0.0;bq=0;br={}bs=false;bt=0;bu=0;bv=nil;bw=0;bx=1000;by=0;bz=false;bA=0;bB=false;bC="All"bD=true;bE="Off"bF=0.000;bG={}bH={}bI={}bJ=false;bK={VertTakeOff={set=function(M)bb=M end,get=function()return bb end},VertTakeOffEngine={set=function(M)b1=M end,get=function()return b1 end},SpaceTarget={set=function(M)bz=M end,get=function()return bz end},BrakeToggleStatus={set=function(M)b0=M end,get=function()return b0 end},BrakeIsOn={set=function(M)b2=M end,get=function()return b2 end},RetrogradeIsOn={set=function(M)b3=M end,get=function()return b3 end},ProgradeIsOn={set=function(M)b4=M end,get=function()return b4 end},Autopilot={set=function(M)b5=M end,get=function()return b5 end},TurnBurn={set=function(M)b6=M end,get=function()return b6 end},AltitudeHold={set=function(M)b7=M end,get=function()return b7 end},BrakeLanding={set=function(M)b8=M end,get=function()return b8 end},Reentry={set=function(M)ba=M end,get=function()return ba end},AutoTakeoff={set=function(M)b9=M end,get=function()return b9 end},HoldAltitude={set=function(M)bc=M end,get=function()return bc end},AutopilotAccelerating={set=function(M)bd=M end,get=function()return bd end},AutopilotBraking={set=function(M)bf=M end,get=function()return bf end},AutopilotCruising={set=function(M)bg=M end,get=function()return bg end},AutopilotRealigned={set=function(M)be=M end,get=function()return be end},AutopilotEndSpeed={set=function(M)bh=M end,get=function()return bh end},AutopilotStatus={set=function(M)bi=M end,get=function()return bi end},AutopilotPlanetGravity={set=function(M)bj=M end,get=function()return bj end},PrevViewLock={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetName={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetCoords={set=function(M)bm=M end,get=function()return bm end},AutopilotTargetIndex={set=function(M)bn=M end,get=function()return bn end},TotalDistanceTravelled={set=function(M)bp=M end,get=function()return bp end},TotalFlightTime={set=function(M)bq=M end,get=function()return bq end},SavedLocations={set=function(M)br=M end,get=function()return br end},VectorToTarget={set=function(M)bs=M end,get=function()return bs end},LocationIndex={set=function(M)bt=M end,get=function()return bt end},LastMaxBrake={set=function(M)bu=M end,get=function()return bu end},LockPitch={set=function(M)bv=M end,get=function()return bv end},LastMaxBrakeInAtmo={set=function(M)bw=M end,get=function()return bw end},AntigravTargetAltitude={set=function(M)bx=M end,get=function()return bx end},LastStartTime={set=function(M)by=M end,get=function()return by end},iphCondition={set=function(M)bC=M end,get=function()return bC end},stablized={set=function(M)bD=M end,get=function()return bD end},UseExtra={set=function(M)bE=M end,get=function()return bE end},SelectedTab={set=function(M)bL=M end,get=function()return bL end},saveRoute={set=function(M)bG=M end,get=function()return bG end},apRoute={set=function(M)bH=M end,get=function()return bH end},ecuThrottle={set=function(M)bI=M end,get=function()return bI end},HoverMode={set=function(M)bJ=M end,get=function()return bJ end}}local function bM(b,c,bN,bO,bP)local a=bQ;local bR=bS;bT=bN()bU=0;bV=0;bW=false;bX=0;bY=false;bZ=false;b_=0;c0=0;c1=0;c2=0;c3=false;c4=false;c5=false;c6="empty"c7=3;c8=false;c9=0;ca=0;cb=nil;cc=0;cd=0;ce=0;cf=false;cg=false;ch=false;ci=-1;cj=bP()>0;ck=bP()cl=b.getAltitude()cm=bS.getMass()cn=nil;co={}cp={}cq={}cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=nil;cy=nil;cz=nil;cA=false;cB=false;cC=q;cD=false;cE=W;cF=nil;cG=0;cH=false;cI=false;cJ=false;cK=vec3(bR.getWorldOrientationForward())cL=vec3(bR.getWorldOrientationRight())cM=vec3(bR.getVelocity())cN=vec3(bR.getWorldVelocity())cO=vec3(cN):len()cP=vec3(b.getWorldVertical())cQ=-cP:dot(cN)cR=vec3(bR.getWorldPosition())cS=false;cT=false;cU=true;cV=0;cW=0;cX={}cY=false;cZ=50000;c_=nil;d0=c.getClosestPlanetInfluence()>0 or cl>0 and cl<200000;d1=false;d2=nil;d3=false;d4=0;d5={}d6={}d7={}d8=90;d9=w;da=nil;db=nil;dc={}dd={}de=false;df=nil;dg=0;dh=false;di=bR.getMaxSpeed()if shield then dj=bO(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dk(dl)a.print(bT..": "..dl)end;local function dm(d,b,c,a,dn,dp,dq,dr,ds)local function dt(du)return type(du)=='number'end;local function dv(du)return type(dq(du))=='number'end;local function dw(dx)return type(dx)=='table'end;local function dy(a)return type(a)=='string'end;local function dz(dA)return dw(dA)and dt(dA.x and dA.y and dA.z)end;local function dB(dC)return dw(dC)and dt(dC.latitude and dC.longitude and dC.altitude and dC.id and dC.systemId)end;local dD=math.pi/180;local dE=180/math.pi;local dF=1e-10;local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH='::pos{'..dG..','..dG..','..dG..','..dG..','..dG..'}'local utils=utils;local vec3=vec3;local function dI(du)local dJ=string.gsub(string.reverse(dn('%.4f',du)),'^0*%.?','')return dJ==''and'0'or string.reverse(dJ)end;local function dK(dL)if dz(dL)then return dn('{x=%.3f,y=%.3f,z=%.3f}',dL.x,dL.y,dL.z)end;if dw(dL)and not getmetatable(dL)then local dM={}local dN=next(dL)if type(dN)=='nil'or dN==1 then dM=dL else for dO,dA in pairs(dL)do local dP=dK(dA)if type(dO)=='number'then table.insert(dM,dn('[%s]=%s',dO,dP))else table.insert(dM,dn('%s=%s',dO,dP))end end end;return dn('{%s}',table.concat(dM,','))end;if dy(dL)then return dn("'%s'",dL:gsub("'",[[\']]))end;return tostring(dL)end;local dQ={}dQ.__index=dQ;dQ.__tostring=function(dL,dR)local dS={}for dO in pairs(dL)do table.insert(dS,dO)end;table.sort(dS)local dM={}for dT,dO in ipairs(dS)do local dP=dK(dL[dO])if type(dO)=='number'then table.insert(dM,dn('[%s]=%s',dO,dP))else table.insert(dM,dn('%s=%s',dO,dP))end end;if dR then return dn('%s%s',dR,table.concat(dM,',\n'..dR))end;return dn('{%s}',table.concat(dM,','))end;dQ.__eq=function(dU,dV)return dU.systemId==dV.systemId and dU.id==dV.id and ds(dU.radius,dV.radius)and ds(dU.center.x,dV.center.x)and ds(dU.center.y,dV.center.y)and ds(dU.center.z,dV.center.z)and ds(dU.GM,dV.GM)end;local function dW(dX,dY,dZ,d_,e0)assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(dZ),'Argument 3 (radius) must be a number:'..type(dZ))assert(dw(d_),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(d_))assert(dv(e0),'Argument 5 (GM) must be a number:'..type(e0))return setmetatable({systemId=dq(dX),id=dq(dY),radius=dq(dZ),center=vec3(d_),GM=dq(e0)},dQ)end;local e1={}e1.__index=e1;e1.__tostring=function(dk)return dn('::pos{%d,%d,%s,%s,%s}',dk.systemId,dk.id,dI(dk.latitude*dE),dI(dk.longitude*dE),dI(dk.altitude))end;e1.__eq=function(dU,dV)return dU.id==dV.id and dU.systemId==dV.systemId and ds(dU.latitude,dV.latitude)and ds(dU.altitude,dV.altitude)and(ds(dU.longitude,dV.longitude)or ds(dU.latitude,math.pi/2)or ds(dU.latitude,-math.pi/2))end;local function e2(e3,dY,e4,e5,e6)local dX=e3;if dy(e3)and not e5 and not e6 and not dY and not e4 then dX,dY,e4,e5,e6=e7(e3,dH)assert(dX,'Argument 1 (position string) is malformed.')else assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(e4),'Argument 3 (latitude) must be in degrees:'..type(e4))assert(dv(e5),'Argument 4 (longitude) must be in degrees:'..type(e5))assert(dv(e6),'Argument 5 (altitude) must be in meters:'..type(e6))end;dX=dq(dX)dY=dq(dY)e4=dq(e4)e5=dq(e5)e6=dq(e6)if dY==0 then return setmetatable({latitude=e4,longitude=e5,altitude=e6,id=dY,systemId=dX},e1)end;return setmetatable({latitude=dD*dp(e4,-90,90),longitude=dD*(e5%360),altitude=e6,id=dY,systemId=dX},e1)end;local e8={}e8.__index=e8;e8.__tostring=function(dL,dR)local e9=dR and dR..'  'local ea={}local dS={}for dO in pairs(dL)do table.insert(dS,dO)end;table.sort(dS)for dT,eb in ipairs(dS)do ec=dL[eb]local ed=dQ.__tostring(ec,e9)if dR then table.insert(ea,dn('[%s]={\n%s\n%s}',eb,ed,dR))else table.insert(ea,dn('  [%s]=%s',eb,ed))end end;if dR then return dn('\n%s%s%s',dR,table.concat(ea,',\n'..dR),dR)end;return dn('{\n%s\n}',table.concat(ea,',\n'))end;local function ee(ef)local e={}local pid;for dT,dA in pairs(ef)do local dY=dA.planetarySystemId;if type(dY)~='number'then error('Invalid planetary s ID: '..tostring(dY))elseif pid and dY~=pid then error('Mistringmatch planetary s IDs: '..dY..' and '..pid)end;local eg=dA.bodyId;if type(eg)~='number'then error('Invalid body ID: '..tostring(eg))elseif e[eg]then error('Duplicate body ID: '..tostring(eg))end;setmetatable(dA.center,getmetatable(vec3.unit_x))e[eg]=setmetatable(dA,dQ)pid=dY end;return setmetatable(e,e8)end;eh={}local function ei(ef)return setmetatable({galaxyAtlas=ef or{}},eh)end;eh.__index=function(dx,M)if type(M)=='number'then local a=dx.galaxyAtlas[M]return ee(a)end;return rawget(eh,M)end;eh.__pairs=function(dL)return function(dx,dO)local ej,ek=next(dx,dO)return ej,ek and ee(ek)end,dL.galaxyAtlas,nil end;eh.__tostring=function(dL)local el={}for dT,em in pairs(dL or{})do local en=em:getPlanetarySystemId()local eo=e8.__tostring(em,'    ')table.insert(el,dn('  [%s]={%s\n  }',en,eo))end;return dn('{\n%s\n}\n',table.concat(el,',\n'))end;eh.BodyParameters=dW;eh.MapPosition=e2;eh.PlanetarySystem=ee;function eh.createBodyParameters(dX,dY,ep,eq,er,es,et)assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(ep),'Argument 3 (surfaceArea) must be a number:'..type(ep))assert(dw(eq),'Argument 4 (aPosition) must be an array or vec3:'..type(eq))assert(dw(er),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(er))assert(dv(es),'Argument 6 (altitude) must be in meters:'..type(es))assert(dv(et),'Argument 7 (gravityAtPosition) must be number:'..type(et))local dZ=dr(ep/4/math.pi)local ce=dZ+es;local eu=vec3(eq)+ce*vec3(er)local e0=et*ce*ce;return dW(dX,dY,dZ,eu,e0)end;eh.isMapPosition=dB;function eh:getPlanetarySystem(e3)if M==nil then M=0 end;if ek==nil then ek=0 end;local dX=e3;if dB(e3)then dX=e3.systemId end;if type(dX)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(ek)~=e8 then a=ee(a)end;return a end end end;function e8:sizeCalculator(ev)return 1.05*ev.radius end;function e8:castIntersections(ew,ex,ey,ez,eA,eB)local eC={}if eA then for dT,ev in pairs(eA)do table.insert(eC,ev)end else eC=d7 end;if not eB then table.sort(eC,function(eD,eE)local eF=eD.center;local eG=eE.center;return(eF.x-ew.x)^2+(eF.y-ew.y)^2+(eF.z-ew.z)^2<(eG.x-ew.x)^2+(eG.y-ew.y)^2+(eG.z-ew.z)^2 end)end;local eH=ex:normalize()for dT,ev in ipairs(eC)do local eI=ev.center-ew;local dZ;if ey then dZ=ey(ev)else dZ=self:sizeCalculator(ev)end;local eJ=eI:dot(eH)local eK=eJ^2-(eI:len2()-dZ^2)if eK>=0 then local eL=dr(eK)local eM=eJ+eL;local eN=eJ-eL;if eN>0 then return ev,eM,eN elseif eM>0 then return ev,eM,nil end end end;return nil,nil,nil end;function e8:closestBody(eO)assert(type(eO)=='table','Invalid coordinates.')local eP,ev;local eQ=vec3(eO)for dT,eR in pairs(self)do local eS=(eR.center-eQ):len2()if(not ev or eS<eP)and eR.name~="Space"then ev=eR;eP=eS end end;return ev end;function e8:convertToBodyIdAndWorldCoordinates(e3)local eT=e3;if dy(e3)then eT=e2(e3)end;if eT.id==0 then return 0,vec3(eT.latitude,eT.longitude,eT.altitude)end;local eR=self:getBodyParameters(eT)if eR then return eT.id,eR:convertToWorldCoordinates(eT)end end;function e8:getBodyParameters(e3)local dY=e3;if dB(e3)then dY=e3.id end;assert(dv(dY),'Argument 1 (id) must be a number:'..type(dY))return self[dY]end;function e8:getPlanetarySystemId()local dT,dA=next(self)return dA and dA.systemId end;function dQ:convertToMapPosition(d_)assert(dw(d_),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(d_))local eU=vec3(d_)if self.id==0 then return setmetatable({latitude=eU.x,longitude=eU.y,altitude=eU.z,id=0,systemId=self.systemId},e1)end;local eV=eU-self.center;local ce=eV:len()local e6=ce-self.radius;local e4=0;local e5=0;if not ds(ce,0)then local eW=eX(eV.y,eV.x)e5=eW>=0 and eW or 2*math.pi+eW;e4=math.pi/2-math.acos(eV.z/ce)end;return setmetatable({latitude=e4,longitude=e5,altitude=e6,id=self.id,systemId=self.systemId},e1)end;function dQ:convertToWorldCoordinates(e3)local eT=dy(e3)and e2(e3)or e3;if eT.id==0 then return vec3(eT.latitude,eT.longitude,eT.altitude)end;assert(dB(eT),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eT.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eT.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eY=math.cos(eT.latitude)return self.center+(self.radius+eT.altitude)*vec3(eY*math.cos(eT.longitude),eY*math.sin(eT.longitude),math.sin(eT.latitude))end;function dQ:getAltitude(d_)return(vec3(d_)-self.center):len()-self.radius end;function dQ:getDistance(d_)return(vec3(d_)-self.center):len()end;function dQ:getGravity(d_)local eZ=self.center-vec3(d_)local e_=eZ:len2()return self.GM/e_*eZ/dr(e_)end;return setmetatable(eh,{__call=function(dT,...)return ei(...)end})end;local function f0(d,b,c,a,dr,f1)local cs={}local f2=100;function cs.computeAccelerationTime(f3,f4,f5)return(f5-f3)/f4 end;function cs.computeDistanceAndTime(f3,f5,f6,f7,f8,f9)f8=f8 or 0;f9=f9 or 0;local fa=f3<f5;local fb=f7/(fa and f6 or-f6)local fc=-f9/f6;local fd=fb+fc;if f3==f5 then return 0,0 elseif fa and fd<=0 or not fa and fd>=0 then return-1,-1 end;local fe,ff=0,0;if fb~=0 and f8>0 then local fg=math.pi/f8/2;local dA=function(dx)return fb*(dx/2-f8*math.sin(fg*dx)/math.pi)+fc*dx+f3 end;local fh=fa and function(a)return a>=f5 end or function(a)return a<=f5 end;ff=2*f8;if fh(dA(ff))then local fi=0;while math.abs(ff-fi)>0.25 do local dx=(ff+fi)/2;if fh(dA(dx))then ff=dx else fi=dx end end end;local fj=2*fb*f8^2/math.pi^2;fe=fj*(math.cos(fg*ff)-1)+(fb+2*fc)*ff^2/4+f3*ff;if ff<2*f8 then return fe,ff end;f3=dA(ff)end;local eF=fb+fc;local dx=cs.computeAccelerationTime(f3,eF,f5)local fk=f3*dx+eF*dx*dx/2;return fe+fk,ff+dx end;function cs.computeTravelTime(f3,f4,ce)if ce==0 then return 0 end;if f4~=0 then return(math.sqrt(2*f4*ce+f3^2)-f3)/f4 end;assert(f3>0,'Acceleration and initial speed are both zero.')return ce/f3 end;return cs end;local function fl(d,b,c,a,dn,dp,dq,dr,ds)local vec3=vec3;local dm=dm(d,b,c,a,dn,dp,dq,dr,ds)local function dy(a)return type(a)=='string'end;local function dw(dx)return type(dx)=='table'end;fm={}fm.__index=fm;function fm:escapeAndOrbitalSpeed(e6)assert(self.body)local ce=e6+self.body.radius;if not ds(ce,0)then local fn=dr(self.body.GM/ce)return dr(2)*fn,fn end;return nil,nil end;function fm:orbitalParameters(e3,fo)assert(self.body)assert(dw(e3)or dy(e3))assert(dw(fo))local fp=(dy(e3)or dm.isMapPosition(e3))and self.body:convertToWorldCoordinates(e3)or vec3(e3)local dA=vec3(fo)local fq=fp-self.body.center;local fr=dA:len2()local fk=fq:len()local fs=self.body.GM;local ft=((fr-fs/fk)*fq-fq:dot(dA)*dA)/fs;local eF=fs/(2*fs/fk-fr)local fu=ft:len()local eH=ft:normalize()local fv=eF*(1-fu)local fw=eF*(1+fu)local fx=fv*eH+self.body.center;local fy=fu<=1 and-fw*eH+self.body.center or nil;local fz=dr(eF*fs*(1-fu*fu))local fA=fy and 2*math.pi*dr(eF^3/fs)local fB=math.acos(ft:dot(fq)/(fu*fk))if fq:dot(dA)<0 then fB=-(fB-2*math.pi)end;local fC=math.acos((math.cos(fB)+fu)/(1+fu*math.cos(fB)))local fD=fC;if fD<0 then fD=fD+2*math.pi end;local fE=fD-fu*math.sin(fD)local fF=0;local fG=0;local fH=0;if fA~=nil then fF=fE/(2*math.pi/fA)fG=fA-fF;fH=fG+fA/2;if fB-math.pi>0 then fG=fF;fH=fG+fA/2 end;if fH>fA then fH=fH-fA end end;return{periapsis={position=fx,speed=fz/fv,circularOrbitSpeed=dr(fs/fv),altitude=fv-self.body.radius},apoapsis=fy and{position=fy,speed=fz/fw,circularOrbitSpeed=dr(fs/fw),altitude=fw-self.body.radius},currentVelocity=dA,currentPosition=fp,eccentricity=fu,period=fA,eccentricAnomaly=fC,meanAnomaly=fE,timeToPeriapsis=fG,timeToApoapsis=fH,trueAnomaly=fB}end;local function fI(fJ)local eR=dm.BodyParameters(fJ.systemId,fJ.id,fJ.radius,fJ.center,fJ.GM)return setmetatable({body=eR},fm)end;return setmetatable(fm,{__call=function(dT,...)return fI(...)end})end;local function fK(d,b,c,a,dbHud_1,e,fL,fM,bO,dq,dr,fN,fO,dl)local function fP(fQ)local dk=fR:closestBody(fQ)if(fQ-dk.center):len()>dk.radius+dk.noAtmosphericDensityAltitude then dk=e[0][0]end;return dk end;local function fS()local function fT(fU,fV)return fU.name<fV.name end;cX={}for dO,dA in pairs(e[0])do cX[#cX+1]={name=dA.name,index=dO}end;table.sort(cX,fT)end;local function fW(fX,fY)if not fY then fY=fZ.name end;for dO,dA in pairs(fX)do if dA.name and dA.name==fY then return dO end end;return-1 end;local function f_()d4=bn;if bn==0 then bl="None"cb=nil;fZ=nil;return true end;local g0=cX[bn].index;local g1=e[0][g0]if g1.center then bl=g1.name;cb=cr[0][g0]if fZ~=nil then if ck==0 then if fL(g2,g3)~=1 then fM(g2,g3)end;if fL(g4,g5)~=1 then fM(g4,g5)end;if fL(g6,g7)~=1 then fM(g6,g7)end;if fL(g8,g9)~=1 then fM(g8,g9)end;if fL(ga,gb)~=1 then fM(ga,gb)end end;if fL(gc,gd)~=1 then fM(gc,gd)end;if fL(ge,gf)~=1 then fM(ge,gf)end;if fL(gg,gh)~=1 then fM(gg,gh)end end;fZ=nil else fZ=g1;for dT,dA in pairs(cr[0])do if dA.name==fZ.planetname then cb=dA;bl=fZ.name;break end end;if fL(gc,gd)~=1 then fM(gc,gd)end;if fL(ge,gf)~=1 then fM(ge,gf)end end;if fZ==nil then bm=vec3(cb.center)else bm=fZ.position end;if cb.planetname~="Space"then if cb.hasAtmosphere then gi=bO(cb.radius*(U-1)+cb.noAtmosphericDensityAltitude)else gi=bO(V+cb.surfaceMaxAltitude)end else gi=T end;if fZ~=nil and fZ.planetname=="Space"then bh=0 else dT,bh=ct(cb):escapeAndOrbitalSpeed(gi)end;bj=0;bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"return true end;local function gj(gk)if not b5 and not bs and not cg and not bB and not ba and not ch then if gk==nil then bn=bn+1;if bn>#cX then bn=0 end else bn=bn-1;if bn<0 then bn=#cX end end;if bn==0 then f_()else local g0=cX[bn].index;local g1=e[0][g0]if g1 and(g1~=nil and g1.name=="Space"or bC=="Custom Only"and g1.center or bC=="No Moons-Asteroids"and(string.find(g1.name,"Moon")~=nil or string.find(g1.name,"Asteroid")~=nil))then if gk==nil then gj()else gj(1)end else f_()end end else dl("Disengage autopilot before changing Interplanetary Helper")fN("iph","AP")end end;local function gl()local function gm(gn)local go;if gn then go=dc else go=br end;local gp=-1;gp=fW(e[0])if gp>-1 then table.remove(e[0],gp)end;gp=-1;gp=fW(go)if gp~=-1 then dl(fZ.name.." saved location cleared")table.remove(go,gp)end;gj()fS()return go end;if string.sub(bl,1,1)=="*"then dc=gm(true)else br=gm(false)end end;local function gq(gr,fQ,gs,gt)local function gu(gn)if gn then go=dc else go=br end;if dbHud_1 or gs or gn then local dk=fP(fQ)local gv={position=fQ,name=gr,planetname=dk.name,gravity=b.getGravityIntensity(),safe=gt}if not gs then go[#go+1]=gv else for dO,dA in pairs(e[0])do if dA.name and gr==dA.name then table.remove(e[0],dO)end end end;table.insert(e[0],gv)fS()f_()dl("Location saved as "..gr.."("..dk.name..")")return go else dl("Databank must be installed to save permanent locations")end end;if string.sub(gr,1,1)=="*"then dc=gu(true)else br=gu(false)end end;local gw={}function gw.UpdateAtlasLocationsList()fS()end;function gw.UpdateAutopilotTarget()f_()end;function gw.adjustAutopilotTargetIndex(gk)gj(gk)end;function gw.findAtlasIndex(fX,fY)return fW(fX,fY)end;function gw.UpdatePosition(gx,gy,gz)local function gA(gn)local go;if gn then go=dc else go=br end;local gp=fW(go)if gp~=-1 then if gx~=nil then if gn then gx="*"..gx end;go[gp].name=gx;bn=bn-1;gj()elseif gz~=nil then if gz then local gB=cl;if gB<1000 then gB=1000 end;go[gp].agg=fO(gB,0)dl(go[gp].name.." AGG Altitude:"..go[gp].agg.." saved ("..go[gp].planetname..")")return elseif gz==false then go[gp].agg=nil;dl(go[gp].name.." AGG Altitude cleared ("..go[gp].planetname..")")return end else local gC=go[gp]if gy then gC.heading=cL:cross(cP)*5000;dl(go[gp].name.." heading saved ("..go[gp].planetname..")")return elseif gy==false then gC.heading=nil;dl(go[gp].name.." heading cleared ("..go[gp].planetname..")")return end;gC.gravity=b.getGravityIntensity()gC.position=cR;gC.safe=true end;dl(go[gp].name.." position updated ("..go[gp].planetname..")")else dl("Name Not Found")end end;if string.sub(bl,1,1)=="*"then gA(true)else gA(false)end end;function gw.AddNewLocation(gr,fQ,gs,gt)gq(gr,fQ,gs,gt)end;function gw.ClearCurrentPosition()gl()end;for dO,dA in pairs(dd)do table.insert(e[0],dA)end;if gD then for dO,dA in pairs(gD)do gw[dO]=dA end end;fS()if bn>#cX then bn=0 end;gw.UpdateAutopilotTarget()return gw end;local function gE(b,a,c,radar_1,radar_2,warpdrive,f1,gF,dr,gG,dq,gH,fN,dl)local gI={}local gJ={}local gK={XS=13,S=27,M=55,L=110,XL=221}local gL={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gM={}local gN=0;local gO;local gP;local gQ=0;local gR;local gS={gR}local gT="Atmo"local gU;local gV;local gW=0;local gX={}local gY;local gZ=0;local g_=table.insert;local h0=-4;local h1={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h2,h3;local h4,h5;local h6;local h7;local h8;local h9;local ha;local hb;local hc;local function hd()if he~=nil and gW==0 then gF(he)a.destroyWidget(h2)a.destroyData(h4)h2,h4,he=nil,nil,nil;if gV~=nil then gF(gV)a.destroyWidget(h3)a.destroyData(h5)gV,h3,h5=nil,nil,nil end else if gW==1 then gV=a.createWidgetPanel("PeriWinkle")h3=a.createWidget(gV,'periscope')h5=gR.getWidgetDataId()a.addDataToWidget(h5,h3)end;if he==nil and gN>0 then he=a.createWidgetPanel(gT)h2=a.createWidget(he,'radar')h4=gR.getWidgetDataId()a.addDataToWidget(h4,h2)end;gW=0 end end;local function hf()local function hg(hh,hi,hj,hk,hl,hm,hn,ho)hi,hk,hm,ho=vec3(hi),vec3(hk),vec3(hm),vec3(ho)local hp,hq,hr=hh*hh,hj*hj,hl*hl;local fr=hk-hi;local hs=fr:normalize()local ht=fr:len()local hu=hm-hi;local hv=(hu-hu:project_on(hs)):normalize()local hw,hx=hu:dot(hs),hu:dot(hv)local hy=hw*hw+hx*hx;local hz=hs:cross(hv)local hA=(hp-hq+ht*ht)/(2*ht)local hB=(hp-hr+hy-2*hw*hA)/(2*hx)local dC=hp-hA^2-hB^2;local hC=dr(dC)local hD=hi+hs*hA+hv*hB+hz*hC;local hE=hi+hs*hA+hv*hB-hz*hC;if f1((ho-hD):len()-hn)<f1((ho-hE):len()-hn)then return hD else return hE end end;local function hF(hG,fk,hH)local hI=hG.pts;local gp=#hI;local hJ=hG.ref;if gp>3 then local hK,hL,hM,hN=hI[gp],hI[gp-1],hI[gp-2],hI[gp-3]hG.ref=hH;local fp=hg(hK[1],hK[2],hL[1],hL[2],hM[1],hM[2],hN[1],hN[2])local hA,hB,hC=fp.x,fp.y,fp.z;if hA==hA and hB==hB and hC==hC then hA=hA+hJ[1]hB=hB+hJ[2]hC=hC+hJ[3]local hO=vec3(hA,hB,hC)hG.center=hO;if hG.lastPos then if(hG.lastPos-hO):len()<2 then local hP=(hO-vec3(hH)):len()if f1(hP-fk)<10 then hG.skipCalc=true end end end;hG.lastPos=hO end;hG.pts={}else local hQ={hH[1]-hJ[1],hH[2]-hJ[2],hH[3]-hJ[3]}hI[gp+1]={fk,hQ}end end;if radar_1 or radar_2 then cx.assignRadar()end;if gR then if#gY>0 then local hR,hS=0,0;local hT=cO*10;local d0=d0;gQ,gP=0,0;gJ={}for dT,dA in pairs(gY)do local ce=ha(dA)if ce>0.0 then if h6(dA)==1 then g_(gJ,dA)end;if not cY and warpdrive and ce<aa and warpdrive.getStatus()==15 then dl("INITIATING WARP")c7=7;warpdrive.initiate()end;local hU=F and h8(dA)==1;if E or hU then local hV=hb(dA)local hW=gK[hV]local hX=h7(dA)if hU or ce<hT and(hW>27 or hX==4 or hX==6)then gQ=gQ+1;local hH={cR["x"],cR["y"],cR["z"]}local hG=gX[dA]if hG==nil then hW=hW+gH;gX[dA]={pts={},ref=hH,name=h9(dA),i=0,radius=hW,skipCalc=false}hG=gX[dA]end;if not hG.skipCalc then if hU or hX==4 or hX==6 then hG.center=vec3(hc(dA))hG.skipCalc=true else hF(hG,ce,hH)hS=hS+1 end;if hU and not hG.abandoned then local bT=a.getArkTime()if gZ+5<bT then gZ=bT;fN("abRdr","RD")end;a.print("Abandoned Construct: "..hG.name.." ("..hV.." "..gL[hX]..") at ::pos{0,0,"..hG.center.x..","..hG.center.y..","..hG.center.z.."}")dl("Abandoned Radar Contact ("..hV.." "..gL[hX]..") detected")hG.abandoned=true end else g_(gM,hG)end end;hR=hR+1;if hR>300 or hS>30 then coroutine.yield()hR,hS=0,0 end end end end;gP=#gM;if gP>0 and(cO>20 or b8)then local ev,hY,hZ,h_;local i0=0;local i1=cr:getPlanetarySystem(0)h_=cN:normalize()while i0<gP do coroutine.yield()local i2={table.unpack(gM,i0,math.min(i0+75,gP))}ev,hY,hZ=i1:castIntersections(cR,h_,nil,nil,i2,true)if ev and hZ then d2={ev,hY,hZ}break end;i0=i0+75 end;if not ev then d2=nil end else d2=nil end;gM={}gO=gR.getTargetId()end end end;local function i3()if gR then gT="Atmo"if string.find(gR.getName(),"Space")then gT="Space"end end end;function gI.pickType()i3()end;function gI.assignRadar()if radar_2 and h0~=1 then if h0==-1 then if gR==radar_2 then gR=radar_1 else gR=radar_2 end end;gS={gR}h6=gR.hasMatchingTransponder;h7=gR.getConstructKind;h8=gR.isConstructAbandoned;h9=gR.getConstructName;ha=gR.getConstructDistance;hb=gR.getConstructCoreSize;hc=gR.getConstructWorldPos;gY=gR.getConstructIds()i3()else gY=gR.getConstructIds()end;h0=gR.getOperationalState()end;function gI.UpdateRadar()local i4=coroutine.status(gU)if i4=="suspended"then local dP,i5=coroutine.resume(gU)if i5 then a.print("ERROR UPDATE RADAR: "..i5)end elseif i4=="dead"then gU=coroutine.create(hf)local dP,i5=coroutine.resume(gU)end end;function gI.GetRadarHud(i6,i7,ay,az)local i8,dl;local dG=gP or 0;gN=#gY;if gN>0 then if E then dl=dG.."/"..gQ.." Known/InRange : "..gN.." Total"else dl="Radar Contacts: "..gN end;i8=gG(ay,az,dl,"pbright txtbig txtmid")if#gJ>0 then i8=i8 ..gG(i6,i7,"Friendlies In Range","pbright txtbig txtmid")for dO,dA in pairs(gJ)do i7=i7+20;i8=i8 ..gG(i6,i7,gR.getConstructName(dA),"pdim txtmid")end end;local i9=#gR.getIdentifiedConstructIds()if gV==nil and i9>0 then gW=1;cx.ToggleRadarPanel()end;if gV~=nil and i9==0 then cx.ToggleRadarPanel()end;if he==nil then if w then cx.ToggleRadarPanel()end end else if h0~=1 then i8=gG(ay,az,gT.." Radar: "..h1[h0],"pbright txtbig txtmid")else i8=gG(ay,az,"Radar: No "..gT.." Contacts","pbright txtbig txtmid")end;if he~=nil then gW=0;cx.ToggleRadarPanel()end end;return i8 end;function gI.GetClosestName(gr)if gR then local ia=gR.getConstructName(gR.getConstructIds()[1])if ia then gr=gr.." "..ia end end;return gr end;function gI.ToggleRadarPanel()hd()end;function gI.ContactTick()if not ib then ib=0 end;if bT>ib+10 then dl("Radar Contact")fN("rdrCon","RC")ib=bT end;c.stopTimer("contact")end;function gI.onEnter(dY)if gR and not cj and not cY then c.setTimer("contact",0.1)end end;function gI.onLeave(dY)if gR and E then if#gX>650 then dY=tostring(dY)gX[dY]=nil end end end;local function ic()gR=nil;if radar_2 and radar_2.getOperationalState()==1 then gR=radar_2 else gR=radar_1 end;h0=gR.getOperationalState()h6=gR.hasMatchingTransponder;h7=gR.getConstructKind;h8=gR.isConstructAbandoned;h9=gR.getConstructName;ha=gR.getConstructDistance;hb=gR.getConstructCoreSize;hc=gR.getConstructWorldPos;gS={gR}gY=gR.getConstructIds()i3()gU=coroutine.create(hf)if id then for dO,dA in pairs(id)do gI[dO]=dA end end end;ic()return gI end;local function ie(shield,e7,bO,dl)local ig={}local ih=shield.getResistancesCooldown()local function ii()local ij=shield.isActive()if G then if not cY and ij==0 and shield.isVenting()~=1 then shield.toggle()elseif cY and ij==1 then shield.toggle()end end end;local function ik()local il=shield.getStressRatioRaw()local im=0.5999;if il[1]==0.0 and il[2]==0.0 and il[3]==0.0 and il[4]==0.0 then return end;local io=shield.setResistances(im*il[1],im*il[2],im*il[3],im*il[4])if io==1 then dl("Shield Resistances updated")else dl("Value Exceeded. Failed to update Shield Resistances")end end;function ig.shieldTick()dj=bO(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ii()ih=shield.getResistancesCooldown()if ih==0 and dj<a9 then ik()end end;function ig.setResist(ip)if not shield then dl("No shield found")return elseif ip==nil or ih>0 then dl("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH=dG..', '..dG..', '..dG..', '..dG;local iq,ir,is,it=e7(ip,dH)if it==nil or iq+ir+is+it>0.6 then dl("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(iq,ir,is,it)==1 then dl("Shield Resistances set")else dl("Resistance setting failed.")end end;function ig.ventShield()local iu=shield.getVentingCooldown()if iu>0 then dl("Cannot vent again for "..iu.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()dl("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else dl("Shields already at max hitpoints")end end;if iv then for dO,dA in pairs(iv)do ig[dO]=dA end end;return ig end;local function iw(d,b,c,a,e,antigrav,hover,shield,warpdrive,ix,f1,bO,dn,iy,bP,iz,iA,eX,bN,dp,iB,fM,fL,gF,iC,dr,fO,gG,fN,iD,iE,iF,iG,iH,iI,dl)local bR=bS;local iJ=9.80665;local iK={}local iL={}local iM={}local iN={}local iO=nil;local iP=nil;local iQ=nil;local iR=false;local iS="none"local iT=""local iU=55;local iV=0;local iW=0;local iX=nil;local iY=ag;local iZ=ah;local i_=ai;local j0=[[rgb(]]..bO(iY+0.5)..","..bO(iZ+0.5)..","..bO(i_+0.5)..[[)]]local j1=[[rgb(]]..bO(iY*0.9+0.5)..","..bO(iZ*0.9+0.5)..","..bO(i_*0.9+0.5)..[[)]]local j2=0;local j3=0;local j4=""local j5=bN()local j6=false;local j7=false;local gR=false;local function j8(dA)if ad==1920 then return dA else return fO(ad*dA/1920,0)end end;local function j9(dA)if ae==1080 then return dA else return fO(ae*dA/1080,0)end end;local function ja()return iC()==0 and g~="keyboard"and iA()==0 end;local function jb()local jc="TRAVEL"if not cU then jc="CRUISE"end;if b5 then jc="AUTOPILOT"end;return jc end;local i8=""local jd=""local je=""local jf=1;local jg=2;local jh=3;local ji=4;local jj=5;local jk=6;local jl=7;local jm=""local jn=0;local jo=90.0*aU;local jp={}local jq={}local jr={}local js={}local jt={}local ju={}local jv={}jv["atmofueltank"],jv["spacefueltank"],jv["rocketfueltank"]=0,0,0;local jw=0;local function jx(hA,jy,jz,jA,jB,jC)local jD=jw;local jE=jw+5;if not B then jE=jE+5 end;if iA()==1 and not m then jD=jD-50;jE=jE-50 end;if jz=="ATMO"then jm="atmofueltank"elseif jz=="SPACE"then jm="spacefueltank"else jm="rocketfueltank"end;jn=_G[jm.."_size"]if#jA>0 then for M=1,#jA do local gr=jA[M][jg]local jF=jA[M][jl]for jG=1,jn do if jA[M][jg]==iy(c[jm.."_"..jG].getWidgetData()).name then jF=jG;break end end;local jH=bN()if jB[M]==nil or jC[M]==nil or jH-jA[M][jk]>jo then local jI;local jJ=0;jJ=iz(jA[M][jf])-jA[M][ji]jI=jA[M][jj]local jK=jI>jJ or false;if jK then jv[jm]=jv[jm]+jI-jJ end;if jF~=0 then local jL=iy(c[jm.."_"..jF].getWidgetData())jC[M]=jL.percentage;jB[M]=jL.timeLeft;if jB[M]=="n/a"then jB[M]=0 end else jC[M]=bO(0.5+jJ*100/jA[M][jh])if jK then jB[M]=bO(0.5+jJ/((jI-jJ)/(jH-jA[M][jk])))else jB[M]=0 end end;jA[M][jk]=jH;jA[M][jj]=jJ end;if gr==jy then gr=dn("%s %d",jz,M)end;if jF==0 then gr=gr.." *"end;local jM;jM=iG(jB[M])if jB[M]==0 or jM==">1y"then jM=""end;if jC[M]~=nil then local jN=bO(jC[M]*2.55)local jO=dn("rgb(%d,%d,%d)",255-jN,jN,0)local jP=""if jM~=""and jB[M]<120 or jC[M]<5 then jP="red "end;local jQ=dn("rgb(%d,%d,%d)",dp(bO((255-jN)/2.55),50,100),dp(bO(jN/2.55),0,50),50)local jR="rgb(196,0,255)"if jz=="ATMO"then jR="rgb(0,188,255)"elseif jz=="SPACE"then jR="rgb(239,255,0)"end;local jS=false;if jT~=jR then jS=true end;jT=jR;if B then if jS then jD=jD-5;jE=jE-5 end;jd=jd..dn([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jQ,jR,hA,jE,jO,bO(jC[M]*1.7+0.5)-2,hA+1,jE+1,hA+5,jE+14,gr,jC[M],jM)jD=jD-22;jE=jE-22 else jd=jd..gG(hA,jD,gr,jP.."pdim txtfuel")jd=jd..gG(hA,jE,dn("%d%% %s",jC[M],jM),"pdim txtfuel","fill:"..jO)jD=jD+30;jE=jE+30 end end end end;jw=jD end;local function jU(jV,e6)if aq==0 and ar==0 then return end;if e6<200000 and not cj or e6 and cj then local jW=0;if f1(cQ)>1 then jW=45*math.log(f1(cQ),10)if cQ<0 then jW=-jW end end;jV[#jV+1]=dn([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bO(cQ),bO(jW))end;return jV end;local function jX(jY)local gk=-cP;jY=jY-jY:project_on(gk)local jZ=vec3(0,0,1)jZ=jZ-jZ:project_on(gk)local j_=jZ:cross(gk)local jW=jZ:angle_between(jY)*constants.rad2deg;if jY:dot(j_)<0 then jW=360-jW end;return jW end;local function k0(jV,am,an,k1,k2,d0)if af==0 then return end;local k3=af;local k4=20;local k5=bO(k1)if d0 then for M=-45,45,5 do local k6=M;jV[#jV+1]=dn([[<g transform="rotate(%f,%d,%d)">]],k6,am,an)k7=5;if M%15==0 then k7=15 elseif M%10==0 then k7=10 end;jV[#jV+1]=dn([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+k3+k4-k7,am,an+k3+k4)end;jV[#jV+1]=gG(am,an+k3+k4-35,k2,"pdim txt txtmid")jV[#jV+1]=gG(am,an+k3+k4-25,k5 .." deg","pdim txt txtmid")jV[#jV+1]=dn([[<g transform="rotate(%f,%d,%d)">]],-k1,am,an)jV[#jV+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+k3+k4-20,am+5,an+k3+k4-20,am,an+k3+k4-15)jV[#jV+1]="</g>"end;jV[#jV+1]=[[<g style="clip-path: url(#headingClip);">]]local k8=k5;if d0 then k8=jX(cK)end;local k9=20;local ka=bO(k8)local kb=0;local kc=an+k3+k4+20;local kd=am;if k2~="YAW"then kc=j9(130)kd=j8(960)end;local ke=[[<path class="txttick line" d="]]local kf=bO(ka-(k9+10)-ka%5+0.5)for M=kf+70,kf,-5 do local hA=kd-(-M*5+k8*5)if M%10==0 then kb=10;local dG=M;if dG==360 then dG=0 elseif dG>360 then dG=dG-360 elseif dG<0 then dG=dG+360 end;jV[#jV+1]=gG(hA,kc+15,dG,"txtmid bright")elseif M%5==0 then kb=5 end;if kb==10 then ke=dn([[%s M %f %f v %d]],ke,hA,kc-5,kb)else ke=dn([[%s M %f %f v %d]],ke,hA,kc-2.5,kb)end end;jV[#jV+1]=ke..[["/>]]jV[#jV+1]=dn([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kd-5,kc-20,kd+5,kc-20,kd,kc-10)if d0 then k2="HDG"end;jV[#jV+1]=gG(j8(960),j9(100),ka.."Â°","dim txt txtmid size14","")jV[#jV+1]=gG(j8(960),j9(85),k2,"dim txt txtmid size20","")jV[#jV+1]=[[</g>]]end;local function kg(jV,kh,k1,am,an,d0,ki,kj)if af==0 then return end;local k3=af;local kk=bO(k3*3/5)if k3>0 then local kl=bO(kh)local k7=0;local ke=dn([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k1,am,an)if not cj then ke=dn([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;jV[#jV+1]=dn([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k3-1,am,an)jV[#jV+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bO(kl-30-kl%5+0.5),bO(kl+30+kl%5+0.5),5 do if M%10==0 then k7=30 elseif M%5==0 then k7=20 end;local hB=an+-M*5+kh*5;if k7==30 then ke=dn([[%s M %d %f h %d]],ke,am-kk-k7,hB,k7)if cj then jV[#jV+1]=dn([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k1,am,an,am-kk+10,hB+4,M)jV[#jV+1]=dn([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k1,am,an,am+kk-10,hB+4,M)if M==0 or M==180 or M==-180 then jV[#jV+1]=dn([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k1,am,an,am-kk+20,hB,kk*2-40)end else jV[#jV+1]=gG(am-kk+10,hB,M,"pdim txt txtmid")jV[#jV+1]=gG(am+kk-10,hB,M,"pdim txt txtmid")end;ke=dn([[%s M %d %f h %d]],ke,am+kk,hB,k7)else ke=dn([[%s M %d %f h %d]],ke,am-kk-k7,hB,k7)ke=dn([[%s M %d %f h %d]],ke,am+kk,hB,k7)end end;jV[#jV+1]=ke..[["/>]]local km="PITCH"if not d0 then km="REL PITCH"end;if kh>90 and not cj then kh=90-(kh-90)elseif kh<-90 and not cj then kh=-90-(kh+90)end;if k3>200 then if cj then if kj>iU then jV[#jV+1]=gG(am,an-15,"Yaw","pdim txt txtmid")jV[#jV+1]=gG(am,an+20,ki,"pdim txt txtmid")end;jV[#jV+1]=dn([[<g transform="rotate(%f,%d,%d)">]],-k1,am,an)else jV[#jV+1]=dn([[<g transform="rotate(0,%d,%d)">]],am,an)end;jV[#jV+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-kk+25,an-5,am-kk+20,an,am-kk+25,an+5,am-kk+50,an+4,kl)jV[#jV+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+kk-25,an-5,am+kk-20,an,am+kk-25,an+5,am+kk-30,an+4,kl)jV[#jV+1]="</g>"end;local kn=bO(k3/3)jV[#jV+1]=dn([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-kn,an,k3-kn)if not cj and d0 then jV[#jV+1]=dn([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k1,am,an,am-kk+10,an,kk*2-20)end;jV[#jV+1]="</g>"if k3<200 then if cj and kj>iU then jV[#jV+1]=gG(am,an-k3,km,"pdim txt txtmid")jV[#jV+1]=gG(am,an-k3+10,kl,"pdim txt txtmid")jV[#jV+1]=gG(am,an-15,"Yaw","pdim txt txtmid")jV[#jV+1]=gG(am,an+20,ki,"pdim txt txtmid")else jV[#jV+1]=gG(am,an-k3,km,"pdim txt txtmid")jV[#jV+1]=gG(am,an-k3+15,kl,"pdim txt txtmid")end end end end;local function ko(jV,e6,d0)local kp=as;local kq=at;if kp==0 and kq==0 then return end;local kr=78;local ks=19;local kt=ci;if ci~=-1 then jV[#jV+1]=gG(kp+kr,kq+ks+20,dn("AGL: %.1fm",ci),"pdim altsm txtend")end;if d0 and(e6<200000 and not cj or e6 and cj)then jV[#jV+1]=gG(kp+kr,kq-10,dn("%s",ku.name),"pdim altsm txtend")table.insert(jV,dn([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kp-1,kq-4,kr+2,ks+6,kp+1,kq-1,kr-4,ks))local gp=0;local kv=1;local kw=0;local kx=e6<0;local ky=e6<ku.surfaceMaxAltitude;local kz=9;if kx then kz=0 end;local e6=f1(e6)while gp<6 do local kA=11;local kB=16;local kC=9;local kD=14;local jP="altsm"if gp>2 then kB=kB+3;kA=kA+2;kD=kD+2;kC=kC-6;jP="altbig"end;if kx then jP=jP.." red"elseif ky then jP=jP.." orange"end;local kE=e6/kv%10;local kF=bO(kE)local kG=bO((kF+1)%10)local kH=kw;if gp==0 then kH=kE-kF;if kx then kH=1-kH end end;if kx and(gp==0 or kw~=0)then local gs=kG;kG=kF;kF=gs end;local kI=kB*(kH-1)local kJ=kI+kB;local hA=kp+kC+(6-gp)*kA;local hB=kq+kD;jV[#jV+1]=gG(hA,hB+kI,kG,jP)jV[#jV+1]=gG(hA,hB+kJ,kF,jP)gp=gp+1;kv=kv*10;if kF==kz then kw=kH else kw=0 end end;table.insert(jV,[[</g></g>]])end end;local function kK(fo)local kL=-math.deg(eX(fo.y,fo.z))+180;kL=kL-90;if kL<0 then kL=360+kL end;if kL>180 then kL=-180+kL-180 end;return-kL end;local function kM(fo)local k8=math.deg(eX(fo.y,fo.x))-90;if k8<-180 then k8=360+k8 end;return k8 end;local function kN(jV,fo,kj,am,an)if kj>5 and not cj or kj>iU then local k3=af;local kO=20;local kP=20;local kQ=kK(fo)local kR=kM(fo)local kS=14;local kT=kS/2;local kU=-kR/kP*k3;local kV=kQ/kO*k3;local hA=am+kU;local hB=an+kV;local ce=dr(kU^2+kV^2)local kW=[[<circle
                            cx="]]..hA..[["
                            cy="]]..hB..[["
                            r="]]..kT/kS..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hA..[["
                            cy="]]..hB..[["
                            r="]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hA-kS..[[,]]..hB..[[ h ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hA+kT..[[,]]..hB..[[ h ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hA..[[,]]..hB-kS..[[ v ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ce<k3 then jV[#jV+1]=kW else local jW=eX(kV,kU)local kX=4;local kY=am+k3*math.cos(jW)local kZ=an+k3*math.sin(jW)jV[#jV+1]=dn('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jW*180/math.pi,kY,kZ,kY-kX,kZ-kX/2,kX*2,kX,kY+kX,kZ-kX,kX,kX,-kX,kX)end;if not cj then local k_=vec3(fo)kQ=kK(-k_)kR=kM(-k_)kU=-kR/kP*k3;kV=kQ/kO*k3;hA=am+kU;hB=an+kV;ce=dr(kU^2+kV^2)if ce<k3 then local l0=[[<circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hA..[[,]]..hB-kS..[[ v ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hA..[[,]]..hB..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hA..[[,]]..hB..[[)" />
                                <path
                                    d="M ]]..hA-kT..[[,]]..hB..[[ h ]]..kS..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hA..[[,]]..hB..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hA..[[,]]..hB..[[)"/>]]jV[#jV+1]=l0 end end end end;local function l1(jV,jc,l2,l3)if ao==0 and ap==0 then return end;l2=bO(l2+0.5)local jD=ap+10;local jE=ap+20;if iA()==1 and not m then jD=55;jE=65 end;local l4="CRUISE"local c="km/h"local dP=l3;if jc=="TRAVEL"or jc=="AUTOPILOT"then l4="THROT"c="%"dP=l2;local l5="dim"if l2<0 then l5="red"end;jV[#jV+1]=dn([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l5,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-f1(l2),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;jV[#jV+1]=gG(ao+10,jD,l4,"pbright txtstart")jV[#jV+1]=gG(ao+10,jE,dn("%.0f %s",dP,c),"pbright txtstart")if cj and t and cU and bW then l2=bO(bX*100+0.5)local l5="red"if l2<0 then l5="red"end;jV[#jV+1]=dn([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l5,1-f1(l2),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)jV[#jV+1]=gG(ao+10,jD+40,"LIMIT","pbright txtstart")jV[#jV+1]=gG(ao+10,jE+40,l2 .."%","pbright txtstart")end;if cj and t or ba then jV[#jV+1]=gG(ao+10,jD-40,"LIMIT: "..cE.." km/h","dim txtstart")elseif not cj and b5 then jV[#jV+1]=gG(ao+10,jD-40,"LIMIT: "..bO(a1*3.6+0.5).." km/h","dim txtstart")end end;local function l6(jV,l7)if ao==0 and ap==0 then return end;local l8=ap-10;local l9=ao+10;jV[#jV+1]=gG(0,0,"","pdim txt txtend")if iA()==1 and not m then l8=75 end;jV[#jV+1]=gG(l9,l8,bO(l7).." km/h","pbright txtbig txtstart")end;local la=40;local function lb(jV)jV[#jV+1]=gG(j8(150),j9(1070),dn("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jV[#jV+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jV[#jV+1]=gG(j8(960),j9(550),"Warning: Invalid Control Scheme Detected","warnings")jV[#jV+1]=gG(j8(960),j9(600),"Keyboard Scheme must be selected","warnings")jV[#jV+1]=gG(j8(960),j9(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lc=j8(960)local ld=j9(860)local le=j9(880)local lf=j9(900)local lg=j9(960)local lh=j9(200)local li=j9(250)local lj=j9(960)if iA()==1 and not m then ld=j9(135)le=j9(155)lf=j9(175)lh=j9(115)li=j9(95)end;if b2 then local lk=""if type(b2)=="string"then lk="-"..b2 end;jV[#jV+1]=gG(lc,ld,"Brake Engaged"..lk,"warnings")elseif bV>0 then jV[#jV+1]=gG(lc,ld,"Auto-Brake Engaged","warnings","opacity:"..bV)end;if cj and cD and ci==-1 then if not b5 and not bs and not b8 and not cT and not bb and not b9 then jV[#jV+1]=gG(lc,lh+50,"** STALL WARNING **","warnings")fN("stall","SW",2)end end;if c_ then jV[#jV+1]=gG(lc,lh+90,"Flight Assist in Progress","warnings")end;if cn then jV[#jV+1]=gG(lc,lj,"Gyro Enabled","warnings")end;if ll then la=la-1;if la>20 then jV[#jV+1]=gG(lc,lj-20,"ECU Enabled","warnings")elseif la<0 then la=40 end end;if bo then if bZ then jV[#jV+1]=gG(lc,le,"Gear Extended","warn")else jV[#jV+1]=gG(lc,le,"Landed (G: Takeoff)","warnings")end end;if ci>-1 and(not cT or cl<100)then local lm=iF(d:getTargetGroundAltitude())jV[#jV+1]=gG(lc,lf,"Hover Height: "..lm,"warn")end;if c8 then jV[#jV+1]=gG(lc,lg+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cT and bx~=nil then local ln="warnings"if f1(cl-antigrav.getBaseAltitude())<501 then ln="warn"end;jV[#jV+1]=gG(lc,lh+40,dn("Target Altitude: %d Singularity Altitude: %d",bO(bx),bO(antigrav.getBaseAltitude())),ln)end;if b5 and bl~="None"then jV[#jV+1]=gG(lc,lh,"Autopilot "..bi,"warn")elseif bv~=nil then jV[#jV+1]=gG(lc,lh+20,dn("LockedPitch: %d",bO(bv)),"warn")elseif c3 then jV[#jV+1]=gG(lc,lh+20,"Follow Mode Engaged","warn")elseif ba or ch then jV[#jV+1]=gG(lc,lh+20,"Re-entry in Progress","warn")end;if b7 or bb then local lm=iF(bc,2)if bb then if cT then lm=iF(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jV[#jV+1]=gG(lc,lh,"VTO to "..lm,"warn")elseif(b9 or cg)and not bB then if cg then jV[#jV+1]=gG(lc,lh,"Takeoff to "..bl,"warn")else jV[#jV+1]=gG(lc,lh,"Takeoff to "..lm,"warn")end;if b2 and not bb then jV[#jV+1]=gG(lc,lh+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jV[#jV+1]=gG(lc,lh,"Altitude Hold: "..dn("%.1fm",bc),"warn")end end;if bb and(antigrav~=nil and antigrav)then if ck>0.1 then jV[#jV+1]=gG(lc,lh+20,"Beginning ascent","warn")elseif ck<0.09 and ck>0.05 then jV[#jV+1]=gG(lc,lh+20,"Aligning trajectory","warn")elseif ck<0.05 then jV[#jV+1]=gG(lc,lh+20,"Leaving atmosphere","warn")end end;if bB then if cF~=nil then jV[#jV+1]=gG(lc,lh,cF,"warn")end end;if b8 then local lo="Brake Landing"if df then lo=lo.."-Aligning"end;if de then lo=lo.."-Drift Limited"end;jV[#jV+1]=gG(lc,lh,lo,"warnings")end;if b4 then jV[#jV+1]=gG(lc,lh+20,"Prograde Alignment","crit")end;if b3 then jV[#jV+1]=gG(lc,lh,"Retrograde Alignment","crit")end;if d1 then local type;if string.find(d1,"COLLISION")then type="warnings"else type="crit"end;jV[#jV+1]=gG(lc,li+20,d1,type)elseif ck==0 then local lp,lq=cw.checkLOS(cN:normalize())if lq~=nil and cO>0 then local lm=iF(lq)local lr=cs.computeTravelTime(cO,0,lq)local ls="Collision"if lp.noAtmosphericDensityAltitude>0 then ls="Atmosphere"end;jV[#jV+1]=gG(lc,li+20,lp.name.." "..ls.." "..iG(lr).." In "..lm,"crit")end end;if bs and not bB then jV[#jV+1]=gG(lc,lh+60,lt,"warn")end;if d5 and#d5>1 then end;local lu=j8;local lv=j9;local lw="topButton"local lx="topButtonActive"local ly=lw;if b5 or bs or cg or bB then ly=lx end;local lz=lw;if b4 then lz=lx end;local lA=lw;if b8 or bo then lA=lx end;local lB=lw;if b7 or bs then lB=lx end;local lC=lw;if b3 then lC=lx end;local lD=lw;if bB or cH and b5 then lD=lx end;if w and I then local lE=lv(30)jV[#jV+1]=dn([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],ly,lu(960),lv(54),lv(-53),lu(-120),lu(25),lv(50))jV[#jV+1]=gG(lu(910),lE,"AUTOPILOT")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lz,lu(865),lv(51),lu(-25),lv(-50),lu(-110),lu(25),lv(46))jV[#jV+1]=gG(lu(800),lE,"PROGRADE")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lA,lu(755),lv(47),lu(-25),lv(-46),lu(-98),lu(44),lv(44))jV[#jV+1]=gG(lu(700),lE,"LAND")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lB,lu(960),lv(54),lv(-53),lu(120),lu(-25),lv(50))jV[#jV+1]=gG(lu(1010),lE,"ALT HOLD")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lC,lu(1055),lv(51),lu(25),lv(-50),lu(110),lu(-25),lv(46))jV[#jV+1]=gG(lu(1122),lE,"RETROGRADE")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,lu(1165),lv(47),lu(25),lv(-46),lu(98),lu(-44),lv(44))jV[#jV+1]=gG(lu(1220),lE,"ORBIT")jV[#jV+1]=[[
                                    </g>
                                </g>]]jV[#jV+1]="</g>"end;return jV end;local function lF(kj)return bO(fO(kj*3.6,0)+0.5).." km/h"end;local function lG(gp)local gr=bl;if gp~=nil and type(gp)=="number"then if gp==0 then return"None"end;gr=cX[gp].name end;if gr==nil then gr=fZ.name end;if gr==nil then gr="None"end;return gr end;local function lH(jV)local lI=cw.routeWP(true)if not lI or#lI==0 then return end;local hA=j8(750)local hB=j9(360)if b5 or bs then jV[#jV+1]=gG(hA,hB,"REMAINING ROUTE","pdim txtstart size20")else jV[#jV+1]=gG(hA,hB,"LOADED ROUTE","pdim txtstart size20")end;for dO,M in pairs(lI)do hB=hB+20;jV[#jV+1]=gG(hA,hB,dO..". "..lI[dO],"pdim txtstart size20")end end;local function lJ(jV)local hA=aC+10;local hB=aD+20;local lK={}local lL={"Alt-4: AutoTakeoff to Target"}local lM={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lN={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lO={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lK,"--------------DYNAMIC-----------------")if cj then if ci~=-1 then iD(lK,lL)if cb and ku and cb.name==ku.name then table.insert(lK,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b1 then if antigrav then if cT then table.insert(lK,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lK,"Turn on AGG to takeoff to AGG Height")end end;if b1 then table.insert(lK,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lK,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lK,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bo then table.insert(lK,"G: Takeoff to hover height, raise gear")else table.insert(lK,"G: Lowergear and Land")end else iD(lK,lM)table.insert(lK,"G: Begin BrakeLanding or Land")end;if bb then table.insert(lK,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iD(lK,lN)if shield then table.insert(lK,"Alt-Shift-6: Vent shields")if not G then table.insert(lK,"Alt-Shift-7: Toggle shield off/on")end end end;if fZ~=nil then table.insert(lK,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lK,"Alt-9: Activate Gyroscope")end;if aX~="none"or aW~="none"or aY~="none"then table.insert(lK,"Alt-Shift-9: Cycles engines with Extra tags")end;if b7 then table.insert(lK,"Alt-Spacebar/C will raise/lower target height")table.insert(lK,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cj then table.insert(lK,"LALT+Mousewheel will lower/raise speed limit")end;iD(lK,lO)for M=1,#lK do hB=hB+12;jV[#jV+1]=gG(hA,hB,lK[M],"pdim txtbig txtstart")end end;local function lP(jV)local lQ=aC;local lR=aD;local lS=aB;local lT=4;local lU=15;local hA=0;local hB=0;local lV,lW,lX,lY;local lZ;local function l_(type)local gB,bT,kj,m0,jP,m1;if type=="Periapsis"then gB=lZ.periapsis.altitude;bT=lZ.timeToPeriapsis;kj=lZ.periapsis.speed;jP="txtend"m0=12;m1=math.min(hA,lQ+lS-ku.radius/lX-lT*2)else gB=lZ.apoapsis.altitude;bT=lZ.timeToApoapsis;kj=lZ.apoapsis.speed;m0=-12;jP="txtstart"m1=hA end;if cO<1 then bT=0 end;jV[#jV+1]=dn([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m1+m0,hB-5,hA,hB-5)jV[#jV+1]=dn([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m1-m0*4,hB+2,hA,hB+2)jV[#jV+1]=gG(m1,hB,type,jP)hA=m1-m0*2;hB=hB+lU;local lm=iF(gB)jV[#jV+1]=gG(hA,hB,lm,jP)hB=hB+lU;jV[#jV+1]=gG(hA,hB,iG(bT),jP)hB=hB+lU;jV[#jV+1]=gG(hA,hB,lF(kj),jP)end;local m2=lS*1.5;if bL=="INFO"then m2=25*10 end;if bL=="ORBIT"and cl<ku.spaceEngineMinAltitude then return jV end;if bL~="HIDE"then jV[#jV+1]=[[<g class="pbright txtorb txtmid">]]jV[#jV+1]=dn('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lS*2,m2,lQ,lR)jV[#jV+1]=dn([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lS*2,m2,lQ,lR)end;local m3=lS*1.5;local m4=lS*2;local m5=m3/2;local m6=lS;local m7=lQ+m6;local m8=lR+m5;local m9=lQ+m4;local ma=lR+m3;if bL=="ORBIT"then lR=lR+lT;lV=lS/2;lY=0;lZ={}lZ.periapsis={}lZ.apoapsis={}if fn~=nil then if fn.periapsis~=nil then lZ.periapsis.altitude=fn.periapsis.altitude;lZ.periapsis.speed=fn.periapsis.speed end;if fn.apoapsis~=nil then lZ.apoapsis.altitude=fn.apoapsis.altitude;lZ.apoapsis.speed=fn.apoapsis.speed end;lZ.period=fn.period;lZ.eccentricity=fn.eccentricity;lZ.timeToApoapsis=fn.timeToApoapsis;lZ.timeToPeriapsis=fn.timeToPeriapsis;lZ.eccentricAnomaly=fn.eccentricAnomaly;lZ.trueAnomaly=fn.trueAnomaly end;if lZ.periapsis==nil then lZ.periapsis={}lZ.periapsis.altitude=-ku.radius;lZ.periapsis.speed=a1 end;if lZ.eccentricity==nil then lZ.eccentricity=1 end;if lZ.apoapsis==nil then lZ.apoapsis={}lZ.apoapsis.altitude=cl;lZ.apoapsis.speed=0 end;if cO<1 then lZ.apoapsis.altitude=cl;lZ.apoapsis.speed=0 end;if lZ.apoapsis.altitude then lX=(lZ.apoapsis.altitude+lZ.periapsis.altitude+ku.radius*2)/(lV*2)lW=(ku.radius+lZ.apoapsis.altitude)/lX*(1-lZ.eccentricity)lY=lV-lZ.periapsis.altitude/lX-ku.radius/lX;local mb=math.pi;if lZ.period~=nil and lZ.period>0 and lZ.timeToApoapsis~=nil then mb=lZ.eccentricAnomaly;if lZ.timeToPeriapsis<lZ.timeToApoapsis then mb=2*math.pi-mb end end;if cO<1 or mb~=mb then mb=math.pi end;local mc=-lV*math.cos(mb)+lQ+m6+lT;local md=lW*math.sin(mb)+lR+m5+lT;local me=""jV[#jV+1]='<g clip-path="url(#orbitRect)">'jV[#jV+1]=dn([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],me,lQ+lS+lT,lR+lS*1.5/2+lT,lV,lW)if lW<1 then jV[#jV+1]=dn([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lQ+lS+lT-lY,lR+lS*1.5/2+lT,mc,md)end;jV[#jV+1]=dn('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lQ+lS+lT-lY,lR+lS*1.5/2+lT,(ku.radius+ku.noAtmosphericDensityAltitude)/lX)jV[#jV+1]=dn('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lQ+lS+lT-lY,lR+lS*1.5/2+lT,(ku.radius+ku.noAtmosphericDensityAltitude)/lX)jV[#jV+1]=dn([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lQ+lS+lT,lR+lS*1.5/2+lT,lV,lW)jV[#jV+1]=dn('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lQ+lS+lT-lY,lR+lS*1.5/2+lT,ku.radius/lX)jV[#jV+1]='</g>'local mf=math.floor(ku.radius/lX+0.5)hA=lQ+lS+lT*4+lV;hB=lR+lS*1.5/2+5+lT;if lZ.apoapsis~=nil and lZ.apoapsis.speed<a1 then l_("Apoapsis")end;hB=lR+lS*1.5/2+5+lT;hA=lQ+lS-lT*2-lV;if lZ.periapsis~=nil and lZ.periapsis.speed<a1 and lZ.periapsis.altitude>0 then l_("Periapsis")end;jV[#jV+1]=gG(lQ+lS+lT,lR+20+lT,ku.name,"txtorbbig")jV[#jV+1]=dn('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mc,md)jV[#jV+1]=[[</g>]]return jV else jV[#jV+1]='<g clip-path="url(#orbitRect)">'local mg=""local mh=1.2*(mi-mj)/(lS*2)local mk=1.4*(ml-mm)/(lS*1.5)for dO,dA in pairs(e[0])do if dA.center then local hA=lQ+lS+dA.center.x/mh;local hB=lR+lS*1.5/2+dA.center.y/mk;mg=mg..'<circle cx="'..hA..'" cy="'..hB..'" r="'..dA.radius/mh*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dA.name,"Moon")and not string.match(dA.name,"Sanctuary")and not string.match(dA.name,"Space")then mg=mg.."<text x='"..hA.."' y='"..hB+dA.radius/mh*30+20 .."' font-size='12' fill="..j0 .." text-anchor='middle' font-family='Montserrat'>"..dA.name.."</text>"end end end;local fp=vec3(bR.getWorldPosition())local hA=lQ+lS+fp.x/mh;local hB=lR+lS*1.5/2+fp.y/mk;mg=mg..'<circle cx="'..hA..'" cy="'..hB..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mg=mg.."<text x='"..hA.."' y='"..hB-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iO=mh;iP=mk;local mn=fp+cN*1000000;local mo=lQ+lS+mn.x/mh;local jE=lR+lS*1.5/2+mn.y/mk;mg=mg..'<line x1="'..hA..'" y1="'..hB..'" x2="'..mo..'" y2="'..jE..'" stroke="purple" stroke-width="1"/>'jV[#jV+1]=mg;jV[#jV+1]='</g>'end elseif bL=="INFO"then jV=cu.DrawOdometer(jV,j2,bp,j3)elseif bL=="HELP"then jV=lJ(jV)elseif bL=="SCOPE"then jV[#jV+1]='<g clip-path="url(#orbitRect)">'local mp=d8;local mq=vec3(bQ.getCameraWorldPos())local mr=vec3(bQ.getCameraWorldRight())local ms=vec3(bQ.getCameraWorldForward())if iC()==1 then mq=cR;mr=cL;ms=cK end;if ck>0 then table.sort(d7,function(eD,eE)local eF,eG=eD.center,eE.center;return(eF.x-mq.x)^2+(eF.y-mq.y)^2+(eF.z-mq.z)^2<(eG.x-mq.x)^2+(eG.y-mq.y)^2+(eG.z-mq.z)^2 end)end;local mt={}local mu={}local mv=120;local mw=nil;local mx=nil;for M,dA in ipairs(d7)do local gO=dA.center-mq;local my=gO:len()local mz=gO:normalize()local mA=gO:cross(ms):normalize()local mB=math.acos(mA:dot(mr))if mB~=mB then mB=0 end;if mA:cross(mr):dot(ms)<0 then mB=-mB end;local mC=gO:project_on_plane(ms):len()local mD=math.sin(mB)*math.asin(mC/my)*constants.rad2deg;local mE=math.cos(mB)*math.asin(mC/my)*constants.rad2deg;if mz:dot(ms)<0 then mE=90*math.cos(mB)+90*math.cos(mB)-mE;mD=90*math.sin(mB)+90*math.sin(mB)-mD end;local hA=m7+mD/mp*m3;local hB=m8+mE/mp*m3;local mF=(hA-m7)*(hA-m7)+(hB-m8)*(hB-m8)local mG=math.asin((dA.radius+dA.surfaceMaxAltitude)/my)*constants.rad2deg;if mG~=mG then mG=mp end;local hV=mG/mp*m3;local mH=math.asin(dA.atmosphereRadius/my)*constants.rad2deg;if mH~=mH then mH=mG end;local mI=mH/mp*m3;local ce=iF(my,1)local mJ=dA.name;local mK=false;if hB>lR then if hB>ma then if hB-mI<=ma then mK=true end else mK=true end else if hB+mI>=lR then mK=true end end;local mL=false;local mM=hA;if dA.systemId==0 then mM=hA+mv else mM=hA-mv end;if mM+mv>lQ then if mM+mv>m9 then if mM-mI-mv<=m9 then mL=true end else mL=true end else if mM+mI+mv>=lQ then mL=true end end;local mN={}mN.x=hA;mN.y=hB;mN.planet=dA;mN.atmoSize=mI;if not mw or mF<mw then mw=mF;mx=mN end;if mL and mK then local mO=math.max(mI,5)if mF<mO*mO then mJ=mJ.." - "..ce end;mN.size=hV;mN.i=M;mN.displayString=mJ;mN.distance=ce;mN.visible=true;mu[#mu+1]=mN else mN.visible=false end end;local mP=false;table.sort(mu,function(eF,eG)return eF.y<eG.y end)for dO,fk in ipairs(mu)do local dA,hV,M,mI,hA,hB,mJ,ce=fk.planet,fk.size,fk.i,fk.atmoSize,fk.x,fk.y,fk.displayString,fk.distance;local m1,mQ,mR,mS;local mT=15;local jP="pdim"if dA.systemId~=0 then mR=j8(string.len(mJ)*5)mT=-(15+mR)mS=j9(10)jP="pdimfill"else mR=j8(string.len(mJ)*9)mS=j9(15)end;if hV*2>mR then m1=dp(hA,lQ+mR/2,m9-mR/2)mQ=dp(hB,lR+mS,ma-5)m1=dp(m1,hA-hV+mR/2,hA+hV-mR/2)mQ=dp(mQ,hB-hV+mS,hB+hV)else m1=hA+mT;mQ=hB end;for mU,fk in pairs(mt)do local mV=fk.textPositions;local mW=mV.y-mQ;if mU~=M and f1(mW)<mV.height and mV.x+mV.width>m1 and mV.x<m1+mR then if hV>mR then mQ=dp(mQ+mS,lR+15,ma-5)else mQ=mV.y+mV.height+1 end end end;local mX=mJ~=dA.name or m1<=m7 and m1+mR>=m7 and mQ-mS<=m8 and mQ>=m8;fk.hovered=mX;local mY=1;if mX then mY=2;if hV*2<mR then mY=10 end;if mJ==dA.name then mJ=mJ.." - "..ce end;jP="pbright"if dA.systemId~=0 then mR=j8(string.len(mJ)*5)mT=-(15+mR)else mR=j8(string.len(mJ)*7)end;if hV*2>mR then m1=dp(hA,lQ+mR/2,m9-mR/2)m1=dp(m1,hA-hV+mR/2,hA+hV-mR/2)else m1=hA+mT end end;mt[M]={}mt[M].textPositions={}mt[M].textPositions.y=mQ;mt[M].textPositions.x=m1;mt[M].textPositions.width=mR;mt[M].textPositions.height=mS;mt[M].output=""if hV*2>mR then jP=jP.." txtmid"else jP=jP.." txtstart"end;if mI-hV>2 then mt[M].output=dn('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hA,hB,mI,j1,0.1*mY)end;mt[M].output=mt[M].output..dn('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hA,hB,hV,j1,0.2*mY)if dA.systemId==0 then mt[M].output=mt[M].output..dn([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m1,mQ,j0,jP,mJ)if hV*2<=mR then mt[M].output=mt[M].output..dn("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m1+mR,mQ+2,m1,mQ+2,hA,hB)end else mt[M].output=mt[M].output..dn([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m1,mQ,j1,jP,mJ)if hV*2<=mR then mt[M].output=mt[M].output..dn("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m1,mQ+2,m1+mR,mQ+2,hA,hB)end end end;for dO=#d7,1,-1 do if mt[dO]then jV[#jV+1]=mt[dO].output end end;if mx~=nil and d8<90 and not mx.hovered then local mZ=mx.planet.atmosphereRadius/mx.atmoSize;local m_=dr(mw)*mZ;local n0=iF(m_,1)local mR=j8(math.max(string.len(n0)*7,string.len(mx.planet.name)*7))local mS=j9(12)local m1=dp(mx.x+(m7-mx.x)/2,lQ+mR/2,m9-mR/2)local mQ=dp(mx.y+(m8-mx.y)/2,lR+mS*2,ma-5)jV[#jV+1]=dn("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mx.x,mx.y,m7,m8)jV[#jV+1]=dn([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m1,mQ,"white",n0)if not mx.visible then jV[#jV+1]=dn([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m1,mQ-mS,"white",mx.planet.name)end end;if cO>1 then local gO=cN;local mz=gO:normalize()local mC=gO:project_on_plane(ms):len()local mA=gO:cross(ms):normalize()local mB=math.acos(mA:dot(mr))if mB~=mB then mB=0 end;if mA:cross(mr):dot(ms)<0 then mB=-mB end;local mD=math.sin(mB)*math.asin(mC/gO:len())*constants.rad2deg;local mE=math.cos(mB)*math.asin(mC/gO:len())*constants.rad2deg;if mz:dot(ms)<0 then mE=90*math.cos(mB)+90*math.cos(mB)-mE;mD=90*math.sin(mB)+90*math.sin(mB)-mD end;local hA=m7+mD/mp*m3;local hB=m8+mE/mp*m3;local kS=14;local kT=kS/2;local kW=[[<circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kT/kS..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hA-kS..[[,]]..hB..[[ h ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hA+kT..[[,]]..hB..[[ h ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hA..[[,]]..hB-kS..[[ v ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jV[#jV+1]=kW end;jV[#jV+1]=dn("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m7,m8-10,m7,m8+10)jV[#jV+1]=dn("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m7-10,m8,m7+10,m8)jV[#jV+1]='</g>'else return jV end end;local function n1(n2,n3)local n4;local n5=(n3-n2):normalize()local fq=(cR-n2):dot(n5)/n5:dot(n5)if fq<=0. then return(cR-n2):len()elseif fq>=(n3-n2):len()then return(cR-n3):len()end;local n6=n2+fq*n5;n4=(n6-cR):len()return n4 end;local function n7()local n4;local n8=nil;local n9=nil;local na=nil;for dO,nb in pairs(e[0])do if nb.hasAtmosphere then local ce=n1(ku.center,nb.center)if n8==nil or ce<n8 then n9=nb;n8=ce;na=ku end;if cb and cb.hasAtmosphere and cb.name~=ku.name then local eS=n1(cb.center,nb.center)if eS<n8 then n9=nb;n8=eS;na=cb end end end end;local nc=j8(1770)local nd=j9(330)if n8 then local ne="txttick "local nf=500000;if n8<n9.radius+nf or n8<na.radius+nf then if cY then ne="txttick red "else ne="txttick orange "end end;n4=iF(n8,2)iT=gG(nc,nd,"Pipe ("..na.name.."--"..n9.name.."): "..n4,ne.."pbright txtmid")end end;local function ng(hA,hB,nh,ni,l4)local nj={x=hA,y=hB,width=nh,height=ni,label=l4}iN[l4]=nj;return nj end;local function nk(nl,nm,nh,ni,hA,hB,nn,no,np,nq,jP)local nj={enableName=nl,disableName=nm,width=nh,height=ni,x=hA,y=hB,toggleVar=nn,toggleFunction=no,drawCondition=np,hovered=false,class=jP}if nq then table.insert(iM,nj)else table.insert(iL,nj)end;return nj end;local function nr(ns)if not iR then nt=false;nu=false;nv=false;w=true;return elseif ns=="handling"then nt=not nt;nu=false;nv=false elseif ns=="hud"then nu=not nu;nt=false;nv=false elseif ns=="physics"then nv=not nv;nt=false;nu=false end;if nv or nu or nt then iS=iE(ns)w=false else iS="none"w=true end end;local function nw()iR=not iR;if iR then iK=iM;dl("Tap LMB to see Settings")d9=w else iK=iL;dl("Tap LMB to see Control Buttons")nr()w=d9 end end;local function nx()local function ny(dA,dO)dA.set(not dA.get())if dA.get()then dl(dO.." set to true")else dl(dO.." set to false")end;if dO=="showHud"then d9=dA.get()elseif dO=="BrakeToggleDefault"then b0=k end end;local nz=50;local nA=340;local hA=500;local hB=ae/2-400;local nB=0;for dO,dA in pairs(iE("boolean"))do if type(dA.get())=="boolean"then nk(dO,dO,nA,nz,hA,hB,function()return dA.get()end,function()ny(dA,dO)end,function()return true end,true)hB=hB+nz+20;if nB==9 then hA=hA+nA+20;hB=ae/2-400;nB=0 else nB=nB+1 end end end;nk("Control View","Control View",nA,nz,10,ae/2-500,function()return true end,nw,function()return true end,true)nk("View Handling Settings",'Hide Handling Settings',nA,nz,10,ae/2-(500-nz),function()return nt end,function()nr("handling")end,function()return true end,true)nk("View Hud Settings",'Hide Hud Settings',nA,nz,10,ae/2-(500-nz*2),function()return nu end,function()nr("hud")end,function()return true end,true)nk("View Physics Settings",'Hide Physics Settings',nA,nz,10,ae/2-(500-nz*3),function()return nv end,function()nr("physics")end,function()return true end,true)end;local function nC()local function gq()local fQ=cR;local gr=ku.name..". "..#br;if cx then gr=cx.GetClosestName(gr)end;return cv.AddNewLocation(gr,fQ,false,true)end;local function nD()b6=not b6 end;local function nE(nF)if nF==1 then b4=not b4;b3=false else b3=not b3;b4=false end;b5=false;b7=false;c3=false;b8=false;bv=nil;ba=false;b9=false end;local function nG(nH,nI)cv.UpdatePosition(nil,nH,nI)end;local function gl()cv.ClearCurrentPosition()end;local function nJ(gp)local lI=cw.routeWP(true)if lI and#lI>0 then return"Engage Route: "..lI[1]end;return"Engage Autopilot: "..lG(gp)end;local function nK(gp)local lI=cw.routeWP(true)if lI and#lI>0 then return"Next Route Point: "..lI[1]end;return"Disable Autopilot: "..lG(gp)end;local function nL()if iA()==1 then c3=not c3;if c3 then b5=false;b3=false;b4=false;b7=false;ba=false;b8=false;b9=false;nM=bo;bo=false;d.control.retractLandingGears()iB:setTargetGroundAltitude(Z)fN("folOn","F")else fN("folOff","F")b2="Follow Off"cC=q;bo=nM;if bo then d.control.deployLandingGears()iB:setTargetGroundAltitude(_)end end else dl("Follow Mode only works with Remote controller")c3=false end end;local nz=50;local nA=260;local nN=j8(30)local nO=aC+aB*2+2;local nP=aD+1;nk("+","+",nN,nN,nO,nP+nN+1,function()return false end,function()d8=d8/8 end,function()return bL=="SCOPE"end,nil,"ZoomButton")nk("-","-",nN,nN,nO,nP,function()return false end,function()d8=math.min(d8*8,90)end,function()return bL=="SCOPE"end,nil,"ZoomButton")nk("0","0",nN,nN,nO,nP+nN*2+2,function()return false end,function()d8=90 end,function()return bL=="SCOPE"and d8~=90 end,nil,"ZoomButton")local nQ=nk("Enable Brake Toggle","Disable Brake Toggle",nA,nz,ad/2-nA/2,ae/2+350,function()return b0 end,function()b0=not b0;if b0 then dl("Brakes in Toggle Mode")else dl("Brakes in Default Mode")end end)nk("Align Prograde","Disable Prograde",nA,nz,ad/2-nA/2-50-nQ.width,ae/2-nz+380,function()return b4 end,function()nE(1)end)nk("Align Retrograde","Disable Retrograde",nA,nz,ad/2-nA/2+nQ.width+50,ae/2-nz+380,function()return b3 end,nE,function()return ck==0 end)nR=nk(nJ,nK,600,60,ad/2-600/2,ae/2-60/2-330,function()return b5 or bs or cg or bB end,function()end)local M;local function nS(nT)local gp=d4+nT;if gp>#cX then gp=gp-#cX-1 end;if gp<0 then gp=#cX+gp end;return gp end;nU={}for M=0,10 do local nV=nk(function(eG)local gp=nS(eG.apExtraIndex)if b5 or bs or cg or bB then return"Redirect: "..lG(gp)end;return nJ(gp)end,function(eG)local gp=nS(eG.apExtraIndex)return nK(gp)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eG)local gp=nS(eG.apExtraIndex)return gp==bn and(b5 or bs or cg or bB)end,function(eG)local gp=nS(eG.apExtraIndex)local nW=bn==gp;bn=gp;cv.UpdateAutopilotTarget()cw.ToggleAutopilot()if not nW and not(b5 or bs or cg or bB)then cw.ToggleAutopilot()end end,function()return d3 and(#cw.routeWP(true)==0 or M==0)end)nV.apExtraIndex=M;nU[M]=nV end;nk("Save Position","Save Position",200,nR.height,nR.x+nR.width+30,nR.y,function()return false end,gq,function()return bn==0 or fZ==nil end)nk("Update Position","Update Position",200,nR.height,nR.x+nR.width+30,nR.y,function()return false end,function()nG(nil)end,function()return bn>0 and fZ~=nil end)nk("Save Heading","Clear Heading",200,nR.height,nR.x+nR.width+30,nR.y+nR.height+20,function()return fZ.heading~=nil end,function()if fZ.heading~=nil then nG(false)else nG(true)end end,function()return bn>0 and fZ~=nil end)nk("Save AGG Alt","Clear AGG Alt",200,nR.height,nR.x+nR.width+30,nR.y+nR.height*2+40,function()return fZ.agg~=nil end,function()if fZ.agg~=nil then nG(nil,false)else nG(nil,true)end end,function()return bn>0 and fZ~=nil and antigrav end)nk("Clear Position","Clear Position",200,nR.height,nR.x-200-30,nR.y,function()return true end,gl,function()return bn>0 and fZ~=nil end)nk("Save Route","Save Route",200,nR.height,nR.x-200-30,nR.y+nR.height*2+40,function()return false end,function()cw.routeWP(false,false,2)end,function()return#cw.routeWP(true)>0 end)nk("Load Route","Clear Route",200,nR.height,nR.x-200-30,nR.y+nR.height+20,function()return#cw.routeWP(true)>0 end,function()if#cw.routeWP(true)>0 then cw.routeWP(false,true)elseif b5 or bs then dl("Disable Autopilot before loading route")return else cw.routeWP(false,false,1)end end,function()return true end)nz=60;nA=300;local hA=0;local hB=ae/2-150;nk("Enable Check Damage","Disable Check Damage",nA,nz,hA,hB-nz-20,function()return s end,function()s=not s end)nk("View Settings","View Settings",nA,nz,hA,hB,function()return true end,nw)hB=hB+nz+20;nk("Enable Turn and Burn","Disable Turn and Burn",nA,nz,hA,hB,function()return b6 end,nD)hA=10;hB=ae/2-300;nk("Horizontal Takeoff Mode","Vertical Takeoff Mode",nA,nz,ad/2-nA/2,hB+20,function()return b1 end,function()b1=not b1;if b1 then dl("Vertical Takeoff Mode")else dl("Horizontal Takeoff Mode")end end,function()return cS end)hB=hB+nz+20;nk("Engage Orbiting","Cancel Orbiting",nA,nz,hA+nA+20,hB,function()return bB end,cw.ToggleIntoOrbit,function()return ck==0 and d0 end)hB=ae/2-150;nk("Glide Re-Entry","Cancel Glide Re-Entry",nA,nz,hA+nA+20,hB,function()return ba end,function()cf=1;nE(1)end,function()return ku.hasAtmosphere and not cj end)hB=hB+nz+20;nk("Parachute Re-Entry","Cancel Parachute Re-Entry",nA,nz,hA+nA+20,hB,function()return ba end,function()cf=2;nE(1)end,function()return ku.hasAtmosphere and not cj end)hB=hB+nz+20;nk("Engage Follow Mode","Disable Follow Mode",nA,nz,hA,hB,function()return c3 end,nL,function()return iA()==1 end)nk("Enable Repair Arrows","Disable Repair Arrows",nA,nz,hA+nA+20,hB,function()return j6 end,function()j6=not j6;if j6 then dl("Repair Arrows Enabled")else dl("Repair Arrows Diabled")end end,function()return iA()==1 end)hB=hB+nz+20;if not r then nk("Enable AGG","Disable AGG",nA,nz,hA,hB,function()return cT end,cw.ToggleAntigrav,function()return antigrav~=nil end)end;nk(function()return dn("Switch IPH Mode - Current: %s",bC)end,function()return dn("IPH Mode: %s",bC)end,nA*2,nz,hA,hB,function()return false end,function()if bC=="All"then bC="Custom Only"elseif bC=="Custom Only"then bC="No Moons-Asteroids"else bC="All"end;dl("IPH Mode: "..bC)end)hB=hB+nz+20;nk(function()return dn("Toggle Control Scheme - Current: %s",g)end,function()return dn("Control Scheme: %s",g)end,nA*2,nz,hA,hB,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;dl("New Control Scheme: "..g)end)local nX=j9(20)local nV=ng(0,0,j8(70),nX,"HELP")nV=ng(nV.x+nV.width,nV.y,j8(80),nX,"INFO")nV=ng(nV.x+nV.width,nV.y,j8(70),nX,"ORBIT")nV=ng(nV.x+nV.width,nV.y,j8(70),nX,"SCOPE")ng(nV.x+nV.width,nV.y,j8(70),nX,"HIDE")end;local nY={}local nZ=nil;function nY.HUDPrologue(jV)if not cY then iY=aj;iZ=ak;i_=al else iY=ag;iZ=ah;i_=ai end;j0=[[rgb(]]..bO(iY+0.6)..","..bO(iZ+0.6)..","..bO(i_+0.6)..[[)]]j1=[[rgb(]]..bO(iY*0.8+0.5)..","..bO(iZ*0.8+0.5)..","..bO(i_*0.8+0.5)..[[)]]local n_=j0;local o0=j1;local o1=[[rgb(]]..bO(iY*0.4+0.5)..","..bO(iZ*0.4+0.5)..","..bO(i_*0.4+0.5)..[[)]]local o2=j0;local o3=j1;local o4=o1;if ja()and not n then n_=[[rgb(]]..bO(iY*0.5+0.5)..","..bO(iZ*0.5+0.5)..","..bO(i_*0.5+0.5)..[[)]]o0=[[rgb(]]..bO(iY*0.3+0.5)..","..bO(iZ*0.3+0.5)..","..bO(i_*0.2+0.5)..[[)]]o1=[[rgb(]]..bO(iY*0.2+0.5)..","..bO(iZ*0.2+0.5)..","..bO(i_*0.2+0.5)..[[)]]end;local lu=j8;local lv=j9;jV[#jV+1]=dn([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],n_,n_,n_,o2,o2,o0,o0,o3,o3,o0,n_,o1,o3,n_,n_,o1,o1,o4,o1,ad,ae,o0,o0,o0,o0,o0,o2,o0,o3,o4,o3,o3,o4)if not nZ then nZ=dn([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lu(630),lv(0),lu(675),lv(45),lu(960),lv(55),lu(1245),lv(45),lu(1290),lv(0),lu(1000),lv(105),lu(1040),lv(59),lu(1250),lv(51),lu(1300),lv(0),lu(1920),lv(0),lu(1920),lv(20),lu(1400),lv(20),lu(1300),lv(105),lu(920),lv(105),lu(880),lv(59),lu(670),lv(51),lu(620),lv(0),lu(0),lv(0),lu(0),lv(20),lu(520),lv(20),lu(620),lv(105),lu(890),lv(59),lu(960),lv(62),lu(1030),lv(59),lu(985),lv(112),lu(1150),lv(112),lu(1100),lv(152),lu(820),lv(152),lu(780),lv(112),lu(935),lv(112),lu(890),lv(59),lu(960),lv(62),lu(1030),lv(59),lu(985),lv(112),lu(1150),lv(112),lu(1100),lv(152),lu(820),lv(152),lu(780),lv(112),lu(935),lv(112))end;if w and I then jV[#jV+1]=nZ end;return jV end;function nY.DrawVerticalSpeed(jV,e6)jU(jV,e6)end;function nY.UpdateHud(jV)local kL=cV;local o5=cW;local k1=o5;local kh=kL;local l2=bO(c.getThrottle())local l7=cO*3.6;local l3=c.getAxisCommandValue(0)local o6=j8(1770)local o7=j9(310)if t and cU then l3=bU;l2=bU*100 end;local jc=jb()local k2="ROLL"if l2==nil then l2=0 end;if not d0 then if cO>5 then kL=kK(cM)o5=kM(cM)else kL=0;o5=0 end;k2="YAW"end;if cZ>50000 and not cj then local o8;o8=iF(cZ)jV[#jV+1]=gG(o6,o7,"PvP Boundary: "..o8,"pbright txtbig txtmid")end;jV[#jV+1]=j4;jV[#jV+1]=i8;if iT~=""then jV[#jV+1]=iT end;if jd~=""then jV[#jV+1]=jd end;if je~=""then jV[#jV+1]=je end;jU(jV,cl)if iA()==0 or m then if not ja()or n then if d0 then k0(jV,am,an,k1,k2,d0)kg(jV,kh,k1,am,an,d0,bO(kM(cM)),cO)else k0(jV,am,an,o5,k2,d0)kg(jV,kL,o5,am,an,d0,bO(o5),cO)end;ko(jV,cl,d0)kN(jV,cM,cO,am,an)end end;l1(jV,jc,l2,l3)l6(jV,l7)lb(jV)lP(jV)if not iR and c4 then lH(jV)end;return jV end;function nY.HUDEpilogue(jV)jV[#jV+1]="</svg>"return jV end;function nY.ExtraData(jV)local o9=j8(1240)local oa=j9(55)local ob=oa+10;local oc;local lu=j8;local lv=j9;local od=0;local jc=jb()if b1 then jc=jc.."-VERTICAL"end;if E and gR and not b9 and not b8 and cO>20 then jc=jc.."-COLLISION ON"end;if bE~="Off"then jc="("..bE..")-"..jc end;if b6 then jc="TB-"..jc end;if bJ then jc="HOVERMODE-"..jc end;if not bD then jc=jc.."-DeCoupled"end;local oe=lv(99)local of=lv(80)local og=lv(85)local oh=lv(31)local oi=0;local oj=0;local f6=cm>1000000 and fO(cm/1000000,2).."kT"or fO(cm/1000,2).."T"if cj then od=bw else od=bu end;local ok,ol=cs.computeDistanceAndTime(cO,0,cm,0,0,od)if ok<0 then ok=0 end;od=fO(od/(cm*iJ),2).."g"local om=d:maxForceForward()oc=b.getGravityIntensity()if oc>0.1 then oj=cm*oc;oj=fO(oj/(cm*iJ),2).."g"oi=0.5*om/oc;oi=oi>1000000 and fO(oi/1000000,2).."kT"or fO(oi/1000,2).."T"end;om=fO(om/(cm*iJ),2).."g"local on=vec3(bR.getWorldAcceleration()):len()/9.80665;oc=b.getGravityIntensity()jV[#jV+1]=[[<g class="dim txt txtend size14">]]if iA()==1 and not m then o9=j8(1120)oa=j9(55)ob=oa+10 elseif cj and I then local oo=j8(770)jV[#jV+1]=gG(lu(895),oe,"ATMO","")jV[#jV+1]=dn([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lu(895),og,lu(-80))jV[#jV+1]=gG(lu(815),of,dn("%.1f%%",ck*100),"txtstart size20")end;if I then jV[#jV+1]=gG(lu(1025),oe,"GRAVITY","txtstart")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(1025),og,lu(80))jV[#jV+1]=gG(lu(1105),of,dn("%.2fg",oc/9.80665),"size20")jV[#jV+1]=gG(lu(1125),oe,"ACCEL","txtstart")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(1125),og,lu(80))jV[#jV+1]=gG(lu(1205),of,dn("%.2fg",on),"size20")jV[#jV+1]=gG(lu(695),oe,"BRK TIME","")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(695),og,lu(-80))jV[#jV+1]=gG(lu(615),of,dn("%s",iG(ol)),"txtstart size20")jV[#jV+1]=gG(lu(635),lv(45),"TRIP","")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(635),lv(31),lu(-90))if lr then jV[#jV+1]=gG(lu(545),lv(26),dn("%s",iG(lr)),"txtstart size20")end;jV[#jV+1]=gG(lu(795),oe,"BRK DIST","")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(795),og,lu(-80))jV[#jV+1]=gG(lu(715),of,dn("%s",iF(ok)),"txtstart size20")jV[#jV+1]=gG(lu(1285),lv(45),"MASS","txtstart")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(1285),lv(31),lu(90))jV[#jV+1]=gG(lu(1375),lv(26),dn("%s",f6),"size20")jV[#jV+1]=gG(lu(1220),oe,"THRUST","txtstart")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(1220),og,lu(80))jV[#jV+1]=gG(lu(1300),of,dn("%s",om),"size20")jV[#jV+1]=gG(j8(960),j9(175),jc,"pbright txtbig txtmid size20")end;jV[#jV+1]="</g>"end;local op=1-(a7*0.05+a8*0.05)function nY.FuelUsed(oq)local os;if oq=="atmofueltank"then os=dn("Atmo Fuel Used: %.1f L",jv[oq]/(4*op))elseif oq=="spacefueltank"then os=dn("Space Fuel Used: %.1f L",jv[oq]/(6*op))else os=dn("Rocket Fuel Used: %.1f L",jv[oq]/(0.8*op))end;return os end;local ot,ou,ov,ow,ox=0,0,0,{},0;local oy=0;local oz=0;local oA=0;local oB=0;function nY.DrawOdometer(jV,j2,bp,j3)if bL~="INFO"then return jV end;local oc;local od=0;local oj=0;local f6=cm>1000000 and fO(cm/1000000,2).." kTons"or fO(cm/1000,2).." Tons"if cj then od=bw else od=bu end;local ok,ol=cs.computeDistanceAndTime(cO,0,cm,0,0,od)local om=d:maxForceForward()oc=b.getGravityIntensity()if cO<5 and ci~=-1 then local oC=vec3(bR.getOrientationForward())local oD=bR.getMaxThrustAlongAxis('thrust analog longitudinal ',{oC:unpack()})oy=0.5*oD[1]/oc;oy=oy>1000000 and fO(oy/1000000,1).." kTons"or fO(oy/1000,1).." Tons"oz=0.5*oD[3]/oc;oz=oz>1000000 and fO(oz/1000000,1).." kTons"or fO(oz/1000,1).." Tons"oC=vec3(bR.getOrientationUp())oD=bR.getMaxThrustAlongAxis('hover_engine, booster_engine',{oC:unpack()})oA=0.5*oD[1]/oc;oA=oA>1000000 and fO(oA/1000000,1).." kTons"or fO(oA/1000,1).." Tons"oB=0.5*od/oc;oB=oB>1000000 and fO(oB/1000000,1).." kTons"or fO(oB/1000,1).." Tons"end;od=fO(od/(cm*iJ),2).." g"if oc>0.1 then oj=cm*oc;oj=fO(oj/(cm*iJ),2).." g"else oj="n/a"end;om=fO(om/(cm*iJ),2).." g"if iA()==0 or m then local oE=j8(aC+10)local oF=j9(aD+20)local oG=j8(aC+10+aB/1.25)local ni=25;local oH=bO(1/aU)if ov<oH then ox=ox+a.getActionUpdateDeltaTime()ov=ov+1 else ot=1/(ox/oH)table.insert(ow,ot)ov,ox=0,0 end;ou=0;for dO,dA in pairs(ow)do ou=ou+dA end;if#ow>0 then ou=bO(ou/#ow)end;if#ow>29 then table.remove(ow,1)end;jV[#jV+1]="<g class='txtstart size14 bright'>"jV[#jV+1]=gG(oE,oF,dn("BrkTime: %s",iG(ol)))jV[#jV+1]=gG(oG,oF,dn("Trip: %.2f km",j2))jV[#jV+1]=gG(oE,oF+ni,dn("Lifetime: %.2f kSU",bp/200000))jV[#jV+1]=gG(oG,oF+ni,dn("BrkDist: %s",iF(ok)))jV[#jV+1]=gG(oE,oF+ni*2,"Trip Time: "..iG(j3))jV[#jV+1]=gG(oG,oF+ni*2,"Total Time: "..iG(bq))jV[#jV+1]=gG(oE,oF+ni*3,dn("Mass: %s",f6))jV[#jV+1]=gG(oG,oF+ni*3,dn("Safe Brake Mass: %s",oB))jV[#jV+1]=gG(oE,oF+ni*4,dn("Max Thrust: %s",om))jV[#jV+1]=gG(oG,oF+ni*4,dn("Safe Atmo Mass: %s",oy))jV[#jV+1]=gG(oE,oF+ni*5,dn("Max Brake: %s",od))jV[#jV+1]=gG(oG,oF+ni*5,dn("Safe Space Mass: %s",oz))jV[#jV+1]=gG(oG,oF+ni*6,dn("Safe Hover Mass: %s",oA))jV[#jV+1]=gG(oE,oF+ni*6,dn("Influence: %s",ku.name))jV[#jV+1]=gG(oE,oF+ni*7,dn("Set Max Speed: %s",bO(a1*3.6+0.5)))jV[#jV+1]=gG(oG,oF+ni*7,dn("Actual Max Speed: %s",bO(di*3.6+0.5)))jV[#jV+1]=gG(oE,oF+ni*8,dn("Friction Burn Speed: %s",bO(bR.getFrictionBurnSpeed()*3.6)))jV[#jV+1]=gG(oG,oF+ni*8,dn("FPS (Avg): %s (%s)",bO(ot),ou))end;jV[#jV+1]="</g></g>"return jV end;function nY.DrawWarnings(jV)return lb(jV)end;function nY.DisplayOrbitScreen(jV)return lP(jV)end;function nY.DisplayMessage(jV,lm)if lm~="empty"then local hB=310;for lo in string.gmatch(lm,"([^\n]+)")do hB=hB+35;jV[#jV+1]=gG("50%",hB,lo,"msg")end end;if c7~=0 then c.setTimer("msgTick",c7)c7=0 end end;function nY.DrawDeadZone(jV)jV[#jV+1]=dn([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function nY.UpdatePipe()if cj then iT=""return end;n7()end;function nY.DrawSettings(jV)local hA=j8(640)local hB=j9(200)jV[#jV+1]=[[<g class="pbright txtvspd txtstart">]]local hR=0;for dO,dA in pairs(iS)do hR=hR+1;jV[#jV+1]=gG(hA,hB,dO..": "..dA.get())hB=hB+20;if hR%12==0 then hA=hA+j8(350)hB=j9(200)end end;jV[#jV+1]=gG(j8(640),j9(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jV[#jV+1]="</g>"return jV end;local i7=j9(125)local i6=j8(1225)function nY.DrawRadarInfo()i8=cx.GetRadarHud(i6,i7,ay,az)if i8 then gR=true end end;function nY.DrawTanks()if au~=0 and av~=0 then jd=gG(au,av,"","txtstart pdim txtfuel")jw=av;jx(au,"Atmospheric ","ATMO",co,jt,ju)jx(au,"Space Fuel T","SPACE",cp,jr,js)jx(au,"Rocket Fuel ","ROCKET",cq,jp,jq)end end;function nY.DrawShield()local ij=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oI=bR.getPvPTimer()local oJ=shield.getResistances()local oK="A: "..10+oJ[1]*100 .."% / E: "..10+oJ[2]*100 .."% / K:"..10+oJ[3]*100 .."% / T: "..10+oJ[4]*100 .."%"local hA,hB=aw-60,ax+30;local jN=bO(dj*2.55)local jO=dn("rgb(%d,%d,%d)",255-jN,jN,0)local jP=""je=gG(hA,hB,"","txtmid pdim txtfuel")if dj<10 and ij~="Shield Disabled"then jP="red "end;oI=oI>0 and"   PvPTime: "..iG(oI)or""je=je..dn([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hA,hB,jO,dj*2,hA,hB,hA+2,hB+10,dj,oI)je=je..gG(hA,hB-5,ij,jP.."txtstart pbright txtbig")je=je..gG(hA,hB+30,oK,jP.."txtstart pbright txtsmall")end;function nY.hudtick()if not ku then return end;local function oL(jV)local jR=bO(dp(dg/(ad/4)*255,0,255))jV[#jV+1]=dn("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",cc,cd,bO(iY+0.5)+jR,bO(iZ+0.5)-jR,bO(i_+0.5)-jR)end;local function oM()if c5 then for dT,dA in pairs(iK)do if dA.hovered then if not dA.drawCondition or dA.drawCondition(dA)then dA.toggleFunction(dA)end;dA.hovered=false end end;for dT,dA in pairs(iN)do if dA.hovered then bL=dA.label;dA.hovered=false end end;c5=false end end;local function oN()local function oO(oP,oQ,hA,hB,nh,ni)if oP>=hA and oP<=hA+nh and oQ>=hB and oQ<=hB+ni then return true else return false end end;local hA=cc+ad/2;local hB=cd+ae/2;for dT,dA in pairs(iK)do dA.hovered=oO(hA,hB,dA.x,dA.y,dA.width,dA.height)end;for dT,dA in pairs(iN)do dA.hovered=oO(hA,hB,dA.x,dA.y,dA.width,dA.height)end;if d3 then local mX=false;for dT,eG in ipairs(nU)do if eG.hovered then mX=true;break end end;if nR.hovered then mX=true end;d3=mX else d3=nR.hovered;if not d3 then d4=bn end end end;local function oR(jV)if not bL or bL==""then bL="HELP"end;if w then for dO,dA in pairs(iN)do local jP="dim brightstroke"local oS=0.2;if bL==dO then jP="pbright dimstroke"oS=0.6 end;local oT=""if dA.hovered then oS=0.8;oT=";stroke:white"end;jV[#jV+1]=dn([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dA.width,dA.height,dA.x,dA.y,jP,oS,oT)jV[#jV+1]=gG(dA.x+dA.width/2,dA.y+dA.height/2+5,dA.label,"txt txtmid pdim")end end end;local function oU(jV)local function oV(jV,oW,hover,hA,hB,oX,oY,oZ,o_,p0,p1,nV)if type(p0)=="function"then p0=p0(nV)end;if type(p1)=="function"then p1=p1(nV)end;jV[#jV+1]=dn("<rect x='%f' y='%f' width='%f' height='%f' fill='",hA,hB,oX,oY)if oW then jV[#jV+1]=dn("%s'",oZ)else jV[#jV+1]=o_ end;if hover then jV[#jV+1]=dn(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else jV[#jV+1]=dn(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fO(ag*0.5,0),fO(ah*0.5,0),fO(ai*0.5,0))end;jV[#jV+1]=" rx='5'></rect>"jV[#jV+1]=dn("<text x='%f' y='%f' font-size='24' fill='",hA+oX/2,hB+oY/2+5)if oW then jV[#jV+1]="black"else jV[#jV+1]="white"end;jV[#jV+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oW then jV[#jV+1]=dn("%s</text>",p0)else jV[#jV+1]=dn("%s</text>",p1)end end;local p2=dn("rgb(%d,%d,%d)'",fO(ag*0.1,0),fO(ah*0.1,0),fO(ai*0.1,0))local p3=dn("rgb(%d,%d,%d)",fO(ag*0.8,0),fO(ah*0.8,0),fO(ai*0.8,0))local p4=oV;for dT,dA in pairs(iK)do local nm=dA.disableName;local nl=dA.enableName;if type(nm)=="function"then nm=nm(dA)end;if type(nl)=="function"then nl=nl(dA)end;if not dA.drawCondition or dA.drawCondition(dA)then p4(jV,dA.toggleVar(dA),dA.hovered,dA.x,dA.y,dA.width,dA.height,p3,p2,nm,nl,dA)end end end;local p5=fO(ad/2,0)local p6=fO(ae/2,0)local jV={}if p7 then jV[#jV+1]=p7 end;cu.HUDPrologue(jV)if w then cu.UpdateHud(jV)else if A then cu.DrawVerticalSpeed(jV,cl)end;cu.DrawWarnings(jV)end;if iR and iS~="none"then cu.DrawSettings(jV)end;if cx then cu.DrawRadarInfo()else i8=""end;cu.HUDEpilogue(jV)jV[#jV+1]=dn([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c6~="empty"then cu.DisplayMessage(jV,c6)end;if iA()==0 and g=="virtual joystick"then if v then cu.DrawDeadZone(jV)end end;oR(jV)if iC()==0 then if iA()==1 and c4 then if not p8 then oN()oU(jV)end;if not cA and not cB then local p9=table.concat(jV,"")jV={}jV[#jV+1]=dn("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jV[#jV+1]=p9;jV[#jV+1]="</body>"cA=true;jV[#jV+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cB then local p9=table.concat(jV,"")jV={}jV[#jV+1]=dn("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jV[#jV+1]=p9;jV[#jV+1]="</body>"end;if not cA then jV[#jV+1]=dn([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p5,p6,cc,cd)end else oM()end else if not c4 and iA()==0 then oM()if dg>aA then if v then oL(jV)end end elseif c4 and(not p8 or not j)then oN()oU(jV)end;jV[#jV+1]=dn([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p5,p6,cc,cd)end;jV[#jV+1]=[[</svg></body>]]pa=table.concat(jV,"")end;function nY.TenthTick()local function pb()local pc=a.createData;local pd=a.createWidget;pe=a.createWidgetPanel("Interplanetary Helper")pf=pd(pe,"value")pg=pc('{"label": "Target Planet", "value": "N/A", "unit":""}')fM(pg,pf)ph=pd(pe,"value")pi=pc('{"label": "distance", "value": "N/A", "unit":""}')fM(pi,ph)gf=pd(pe,"value")ge=pc('{"label": "Travel Time", "value": "N/A", "unit":""}')fM(ge,gf)gh=pd(pe,"value")gg=pc('{"label": "Target Altitude", "value": "N/A", "unit":""}')fM(gg,gh)pj=pd(pe,"value")pk=pc('{"label": "End Speed", "value": "N/A", "unit":""}')g9=pd(pe,"value")g8=pc('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g7=pd(pe,"value")g6=pc('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g5=pd(pe,"value")g4=pc('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g3=pd(pe,"value")g2=pc('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gb=pd(pe,"value")ga=pc('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cj then fM(pk,pj)fM(g8,g9)fM(g6,g7)fM(g4,g5)fM(g2,g3)fM(ga,gb)end end;local function pl()gF(pe)pe=nil end;cu.DrawTanks()if shield then cu.DrawShield()end;if bl~="None"then if pe==nil then pb()end;if bl~=nil then local my;local pm=fZ~=nil;local pn=b5 and bh*3.6 or 0;fL(pg,'{"label": "Target", "value": "'..bl..'", "unit":""}')if pm and not b5 then my=(cR-fZ.position):len()else my=(bm-cR):len()end;if not b6 then c9,ca=cw.GetAutopilotBrakeDistanceAndTime(cO)iV,iW=cw.GetAutopilotBrakeDistanceAndTime(a1)else c9,ca=cw.GetAutopilotTBBrakeDistanceAndTime(cO)iV,iW=cw.GetAutopilotTBBrakeDistanceAndTime(a1)end;local lm=iF(my)fL(pi,'{"label": "distance", "value": "'..lm..'"}')fL(ge,'{"label": "Travel Time", "value": "'..iG(lr)..'", "unit":""}')lm=iF(c9)fL(g8,'{"label": "Cur Brake distance", "value": "'..lm..'"}')fL(g6,'{"label": "Cur Brake Time", "value": "'..iG(ca)..'", "unit":""}')lm=iF(iV)fL(g4,'{"label": "Max Brake distance", "value": "'..lm..'"}')fL(g2,'{"label": "Max Brake Time", "value": "'..iG(iW)..'", "unit":""}')fL(pk,'{"label": "End Speed", "value": "'..dn("%.0fkph",pn)..'", "unit":""}')lm=iF(gi)fL(gg,'{"label": "Target Orbit", "value": "'..lm..'"}')if cj and not po then a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(pk,pj)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)po=true;if not cU and t and(b7 or ba or ch)then cw.cmdThrottle(1)b2=false;bY=false end end;if not cj and po then if fL(g2,g3)==1 then fM(g2,g3)end;if fL(g2,pj)==1 then fM(pk,pj)end;if fL(g4,g5)==1 then fM(g4,g5)end;if fL(g6,g7)==1 then fM(g6,g7)end;if fL(g8,g9)==1 then fM(g8,g9)end;if fL(ga,gb)==1 then fM(ga,gb)end;po=false end end else pl()end;if warpdrive~=nil then local pp=iy(warpdrive.getWidgetData())if pp.destination~="Unknown"and pp.distance>400000 then if not j7 then warpdrive.showWidget()j7=true end elseif j7 then warpdrive.hideWidget()j7=false end end end;function nY.OneSecondTick()local function pq()local jH=bN()local l7=cO;local pr=jH-j5;if l7>1.38889 then l7=l7/1000;local ps=l7*(jH-j5)bp=bp+ps;j2=j2+ps end;j3=j3+pr;bq=bq+pr;j5=jH end;local function pt(jV)local pu=0;local pv=iI;local pw=0;local px=0;local py=0;local jN=0;local jO=""local pz=b.getElementHitPointsById;local pA=b.getElementMaxHitPointsById;local pB={}for dO in pairs(iH)do local pC=0;local pD=0;pD=pA(iH[dO])pC=pz(iH[dO])pw=pw+pC;if pC+1<pD then if pC==0 then py=py+1 else px=px+1 end;if j6 and#pB==0 then fQ=vec3(b.getElementPositionById(iH[dO]))local hA=fQ.x;local hB=fQ.y;local hC=fQ.z;table.insert(pB,b.spawnArrowSticker(hA,hB,hC+1,"down"))table.insert(pB,b.spawnArrowSticker(hA,hB,hC+1,"down"))b.rotateSticker(pB[2],0,0,90)table.insert(pB,b.spawnArrowSticker(hA+1,hB,hC,"north"))table.insert(pB,b.spawnArrowSticker(hA+1,hB,hC,"north"))b.rotateSticker(pB[4],90,90,0)table.insert(pB,b.spawnArrowSticker(hA-1,hB,hC,"south"))table.insert(pB,b.spawnArrowSticker(hA-1,hB,hC,"south"))b.rotateSticker(pB[6],90,-90,0)table.insert(pB,b.spawnArrowSticker(hA,hB-1,hC,"east"))table.insert(pB,b.spawnArrowSticker(hA,hB-1,hC,"east"))b.rotateSticker(pB[8],90,0,90)table.insert(pB,b.spawnArrowSticker(hA,hB+1,hC,"west"))table.insert(pB,b.spawnArrowSticker(hA,hB+1,hC,"west"))b.rotateSticker(pB[10],-90,0,90)table.insert(pB,iH[dO])end elseif j6 and#pB>0 and pB[11]==iH[dO]then for jG in pairs(pB)do b.deleteSticker(pB[jG])end;pB={}end end;pu=fO(pw/pv*100,2)if py>0 or px>0 then jV[#jV+1]=gG(0,0,"","pbright txt")jN=bO(pu*2.55)jO=dn("rgb(%d,%d,%d)",255-jN,jN,0)jV[#jV+1]=gG("50%",1035,"Elemental Integrity: "..pu.."%","txtbig txtmid","fill:"..jO)if py>0 then jV[#jV+1]=gG("50%",1055,"Disabled Modules: "..py.." Damaged Modules: "..px,"txtbig txtmid","fill:"..jO)elseif px>0 then jV[#jV+1]=gG("50%",1055,"Damaged Modules: "..px,"txtbig txtmid","fill:"..jO)end end end;local function pE()if ix then if iX==nil and(he~=nil or bo)then _autoconf.displayCategoryPanel(ix,weapon_size,"Weapons","weapon",true)iX=_autoconf.panels[_autoconf.panels_size]elseif iX~=nil and he==nil and not bo then gF(iX)iX=nil end end end;local jV={}pq()if s then pt(jV)end;pE()cu.UpdatePipe()cu.ExtraData(jV)j4=table.concat(jV,"")end;function nY.AnimateTick()cB=true;cA=false;cc=0;cd=0;c.stopTimer("animateTick")end;function nY.MsgTick()local jV={}cu.DisplayMessage(jV,"empty")c6="empty"c.stopTimer("msgTick")c7=3 end;function nY.ButtonSetup()nx()nC()iK=iL end;if pF then for dO,dA in pairs(pF)do nY[dO]=dA end end;return nY end;local function pG(d,b,c,e,vBooster,hover,pH,antigrav,dbHud_1,f1,bO,bP,iA,eX,bN,dp,iB,fL,iC,dr,fO,fN,iD,ds,iF,iG,pI,iy,dl)local a=bQ;local bR=bS;local pJ={}local pK=false;local pL=0;local pM=0;local pN=0;local pO=bN()local pP=0;local pQ=0;local pR=0;local pS=0;local pT=false;local pU=false;local pV=false;local pW=nil;local pX=0;local iU=55;local pY=nil;local pZ=false;local p_=false;local q0=false;local q1=0;local q2=0;local q3=0;local q4=0;local q5=0;local q6={VectorToTarget=false}local q7=vec3(bR.getWorldOrientationUp())local q8=nil;local q9=0;local qa=-1;local qb=-1;local qc=false;local qd=false;local qe=0;local qf=false;local qg=false;local qh=false;local qi=false;local qj=""local qk=false;local ql=false;local qm=""local qn=false;local qo=0;local qp=0;local function qq()return bR.isInPvPZone()~=1,f1(bR.getDistanceToSafeZone())end;local function qr(kj)local qs=bh;if not b5 then qs=0 end;local qt=bu;if cj then if bw and bw>0 then qt=bw else return 0,0 end end;return cs.computeDistanceAndTime(kj,qs,cm,0,0,qt-bj*cm)end;local function qu(kj)local qs=bh;if not b5 then qs=0 end;return cs.computeDistanceAndTime(kj,qs,cm,d:maxForceForward(),a3,bu-bj*cm)end;local function qv(qw,qx,qy)qx=qx:project_on_plane(qw)qy=qy:project_on_plane(qw)return eX(qx:cross(qy):dot(qw),qx:dot(qy))end;local qz=-1;local qA=-1;local function qB()local function qC()local qD=-1;local qE=-1;if vBooster then qD=vBooster.getDistance()if qD>-1 and qD<0.01 then qD=qz else qz=qD end end;if hover then qE=hover.getDistance()if qE>-1 and qE<0.01 then qE=qA else qA=qE end end;if qD~=-1 and qE~=-1 then if qD<qE then return qD else return qE end elseif qD~=-1 then return qD elseif qE~=-1 then return qE else return-1 end end;local qF=qC()local qG=-1;if antigrav and antigrav.isActive()==1 and not r and cO<iU then local qH=f1(cl-antigrav.getBaseAltitude())if qH<50 then return qH end end;if pH then qG=pH.raycast().distance;if qG==0 then qG=-1 end end;if qF~=-1 and qG~=-1 then if qF<qG then return qF else return qG end elseif qF~=-1 then return qF else return qG end end;local function qI(ku,eO,qJ)local function qK(qL,d_)local eU=vec3(d_)if qL.id==0 then return setmetatable({latitude=eU.x,longitude=eU.y,altitude=eU.z,id=0,systemId=qL.systemId},e1)end;local eV=eU-qL.center;local ce=eV:len()local e6=ce-qL.radius;local e4=0;local e5=0;if not ds(ce,0)then local eW=eX(eV.y,eV.x)e5=eW>=0 and eW or 2*math.pi+eW;e4=math.pi/2-math.acos(eV.z/ce)end;return setmetatable({latitude=math.deg(e4),longitude=math.deg(e5),altitude=e6,id=qL.id,systemId=qL.systemId},e1)end;local qM=qK(ku,eO)qM="::pos{"..qM.systemId..","..qM.id..","..qM.latitude..","..qM.longitude..","..qM.altitude.."}"if qJ then return qM else qh=qM;return true end end;local function qN(qO,qP,qQ)local function qR(qO,ex)qO=vec3(qO)ex=vec3(ex):normalize()local dJ=qO*ex;return dJ.x+dJ.y+dJ.z end;local qS=0.001;local qT=1;if not cj or not cD or ci~=-1 or cO<iU then if qQ==nil then qQ=aT end;if qP==nil then qP=qS end;qO=vec3(qO):normalize()local qU=vec3()-qO;local qV=-qR(qU,bR.getWorldOrientationRight())*qT;local qW=-qR(qU,bR.getWorldOrientationUp())*qT;if pM==0 then pM=qV/2 end;if pN==0 then pN=qW/2 end;if f1(qV)<0.1 then q2=q2-qV*2 else q2=q2-(qV+(qV-pM)*qQ)end;if f1(qW)<0.1 then q1=q1+qW*2 else q1=q1+qW+(qW-pN)*qQ end;pM=qV;pN=qW;if f1(qV)<qP and f1(qW)<qP then return true end;return false elseif cD and ci==-1 then qO=cN;if qQ==nil then qQ=aT end;if qP==nil then qP=qS end;qO=vec3(qO):normalize()local qU=cK-qO;local qV=-qR(qU,bR.getWorldOrientationRight())*qT;local qW=-qR(qU,bR.getWorldOrientationUp())*qT;if pM==0 then pM=qV/2 end;if pN==0 then pN=qW/2 end;if f1(qV)<0.1 then q2=q2-qV*5 else q2=q2-(qV+(qV-pM)*qQ)end;if f1(qW)<0.1 then q1=q1+qW*5 else q1=q1+qW+(qW-pN)*qQ end;pM=qV;pN=qW;if f1(qV)<qP and f1(qW)<qP then return true end;return false end end;function pJ.clearAll()bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"b3=false;b4=false;c_=nil;b7=false;ba=false;b8=false;b9=false;bb=false;c3=false;p_=false;cf=false;cg=false;q0=false;cC=q;bs=false;b6=false;cn=false;bv=nil;bB=false;de=false;df=nil;ch=false end;function pJ.GetAutopilotBrakeDistanceAndTime(kj)return qr(kj)end;function pJ.GetAutopilotTBBrakeDistanceAndTime(kj)return qu(kj)end;function pJ.showWayPoint(ku,eO,qJ)return qI(ku,eO,qJ)end;function pJ.APTick()local qX=a.getMouseWheel()if qX>0 then cw.changeSpd()elseif qX<0 then cw.changeSpd(true)else pZ=true end;qe=iC()if qh then a.setWaypoint(qh)qh=false end;if qk then antigrav.setTargetAltitude(qk)qk=false end;if qi then fL(qi,qj)qi=false;qj=""end;if qb~=-1 then cw.cmdCruise(qb,qc)qc=false;qb=-1 end;if q8~=nil then if iB:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iB:getTargetSpeed(axisCommandId.longitudinal)~=q8 then iB:setTargetSpeedCommand(axisCommandId.longitudinal,q8)else q8=nil end end;if qa~=-1 then cw.cmdThrottle(qa,qc)qc=false;qa=-1 end;if qd then cy.landingGear(qd)qd=false end;if ql then cw.ToggleAutopilot()end end;function pJ.ToggleIntoOrbit()cH=false;pR=nil;pS=nil;pX=0;if not cj then if bB then fN("orOff","AP")bB=false;pT=false;pW=nil;cC=q;if b7 then b7=false;b9=false end;q6.VectorToTarget=false;q6.AutopilotAlign=false;pV=false elseif d0 then fN("orOn","AP")bB=true;cC=true;if pW==nil then pW=ku end;if b7 then b7=false;b9=false end else dl("Unable to engage auto-orbit, not near a planet")end else bB=false;pT=false;pW=nil;cC=q;if b7 then b7=false end;q6.VectorToTarget=false;q6.AutopilotAlign=false;pV=false end end;function pJ.ToggleVerticalTakeoff()b7=false;if bb then qY=true;ba=false;b9=false;b8=true;cC=true;c2=0;if cj and ci==-1 then b8=false;b7=true;c2=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qb=bO(cE)end else cH=false;bo=false;d.control.retractLandingGears()iB:setTargetGroundAltitude(Z)b2="VTO Takeoff"end;bb=not bb end;function pJ.checkLOS(qO)local lp,eM,eN=cr:getPlanetarySystem(0):castIntersections(cR,qO,function(ev)if ev.noAtmosphericDensityAltitude>0 then return ev.radius+ev.noAtmosphericDensityAltitude else return ev.radius+ev.surfaceMaxAltitude*1.5 end end)local lq=eM;if eN~=nil and eM~=nil then lq=math.min(eN,eM)end;if lq~=nil then return lp,lq else return nil,nil end end;local function qZ(q_,r0)if r0 then c2=0;iB:updateCommandFromActionStop(axisCommandId.vertical,r0)if bD then iB:activateGroundEngineAltitudeStabilization(r1)dh=true end else c2=c2+q_;iB:deactivateGroundEngineAltitudeStabilization()iB:updateCommandFromActionStart(axisCommandId.vertical,q_)end end;function pJ.vertical(q_,r0)qZ(q_,r0)end;function pJ.ToggleAutopilot()local function r2(bz)d1=false;bs=not bs;if bs then b6=false;if not b7 and not bz then cw.ToggleAltitudeHold()end end;lt="Proceeding to Waypoint"end;local function r3(gr)if gr then for M,dO in pairs(cX)do if dO.name and dO.name==gr then return M end end else return 0 end end;local r4=false;bJ=false;if bT-pQ<1.5 and cj then if not cJ then if cj then bc=ku.spaceEngineMinAltitude-0.01*ku.noAtmosphericDensityAltitude;fN("11","EP")pQ=-1;if b5 or bs or bB then return end else dl("No space engines detected, Orbital Hop not supported")return end elseif ku.hasAtmosphere then if cj then bc=ku.noAtmosphericDensityAltitude+V;fN("orH","OH")end;pQ=-1;if b5 or bs or bB then return end end else pQ=bT end;r5=false;if(bn>0 or#bH>0)and not b5 and not bs and not cg and not bB then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cm then dl("WARNING: Heavy Loads may affect autopilot performance.")end;if#bH>0 and not ch then bn=r3(bH[1])cv.UpdateAutopilotTarget()dl("Route Autopilot in Progress")local qU=fZ.position-cR;local r6=qU:project_on_plane(cP):len()if r6>50000 and fZ.planetname==ku.name then r4=true end end;cv.UpdateAutopilotTarget()cw.showWayPoint(cb,bm)if fZ~=nil then if fZ.agg and not r and antigrav then if not cT then cw.ToggleAntigrav()end;bx=fZ.agg end;bv=nil;bz=fZ.planetname=="Space"if bz then fN("apSpc","AP")if cj then cg=true;cw.ToggleAltitudeHold()else b5=true end elseif ku.name==fZ.planetname then qY=true;if cj then if not bs then fN("vtt","AP")r2(bz)if r4 then bc=ku.noAtmosphericDensityAltitude+V end end else fN("apOn","AP")if not(cb.name==ku.name and cl<gi*1.5)then cH=false;b5=true elseif not cj then if bB then cw.ToggleIntoOrbit()end;cG=(ku.noAtmosphericDensityAltitude>0 and ku.noAtmosphericDensityAltitude or ku.surfaceMaxAltitude)+V;pV=true;q6.AutopilotAlign=true;q6.VectorToTarget=true;pT=false;if not bB then cw.ToggleIntoOrbit()end end end else fN("apP","AP")b3=false;b4=false;if cj then cg=true;cw.ToggleAltitudeHold()else b5=true end end elseif not cj then if fZ==nil and(cb.name==ku.name and d0)and not bB then r7=false;cH=false;pT=false;cG=(ku.noAtmosphericDensityAltitude>0 and ku.noAtmosphericDensityAltitude or ku.surfaceMaxAltitude)+V;pV=true;cw.ToggleIntoOrbit()else fN("apP","AP")b5=true;b3=false;b4=false;be=false;c3=false;b7=false;b8=false;ba=false;b9=false;p_=false;bv=nil;r7=false end else fN("apP","AP")cg=true;cw.ToggleAltitudeHold()end;ql=false else fN("apOff","AP")cw.ResetAutopilots(1)if ql==2 then ql=true end end end;function pJ.routeWP(r8,r9,ra)if ra then if ra==1 then bH={}bH=iD(bH,bG)if#bH>0 then dl("Route Loaded")else dl("No Saved Route found on Databank")end;return bH else bG={}bG=iD(bG,bH)dl("Route Saved")pI()return end end;if r8 then return bH end;if r9 then bH={}dl("Current Route Cleared")else bH[#bH+1]=fZ.name;dl("Added "..fZ.name.." to route. ")end;return bH end;function pJ.cmdThrottle(dP,rb)if iB:getAxisCommandType(0)~=axisCommandType.byThrottle and not rb then d.control.cancelCurrentControlMasterMode()end;iB:setThrottleCommand(axisCommandId.longitudinal,dP)bU=dp(fO(dP*100,0)/100,-1,1)q8=nil end;function pJ.cmdCruise(dP,rb)if iB:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rb then d.control.cancelCurrentControlMasterMode()end;iB:setTargetSpeedCommand(axisCommandId.longitudinal,dP)q8=dP end;function pJ.ToggleLockPitch()if bv==nil then fN("lkPOn","LP")if not c4 then bv=cV else bv=S end;b9=false;b7=false;b8=false else fN("lkPOff","LP")bv=nil end end;function pJ.ToggleAltitudeHold()if bT-pP<1.5 then bJ=false;if ku.hasAtmosphere then if cj then bc=ku.spaceEngineMinAltitude-0.01*ku.noAtmosphericDensityAltitude;fN("11","EP")else if d0 then bc=ku.noAtmosphericDensityAltitude+V;cG=bc;pV=true;if not bB then cw.ToggleIntoOrbit()end;pT=true end end;pP=-1;if b7 or bB or bb then return end end else pP=bT end;if d0 and not cj and ci==-1 then cG=cl;pV=true;pT=true;cw.ToggleIntoOrbit()if bB then pP=bT else pP=0 end;return end;b7=not b7;b8=false;ba=false;if b7 then b5=false;b4=false;b3=false;c3=false;cC=true;bv=nil;cH=false;if ci~=-1 then if not bo and not bs and not cg then bc=cl;bJ=ci;iB:setTargetGroundAltitude(bJ)elseif cO<20 then if bo then cy.landingGear()end;fN("lfs","LS")b9=true;if cj then bc=cl+Y else bc=ku.surfaceMaxAltitude+100 end;b2="ATO Hold"iB:setTargetGroundAltitude(Z)if b1 and cS then cw.ToggleVerticalTakeoff()end end else fN("altOn","AH")b9=false;if pP>-1 then if d0 then bc=cl end end;if bb then cw.ToggleVerticalTakeoff()end end;if cT and not r then local rc=antigrav.getBaseAltitude()if bs and fZ.agg and fZ.agg>cl then bc=fZ.agg elseif b9 then bc=rc end;if f1(cl-rc)<100 and cO<20 then bc=rc;b2="AGG Hold"qa=0 end end;if cg then bc=200000 end else fN("altOff","AH")if bB then cw.ToggleIntoOrbit()end;if bb then cw.ToggleVerticalTakeoff()end;cC=q;b9=false;bs=false;pP=0;bJ=false end end;function pJ.ResetAutopilots(pJ)if pJ then cg=false;b5=false;be=false;p_=false;bc=cl;r5=false;de=false;bi="Aligning"end;bs=false;b9=false;ba=false;b4=false;b8=false;df=nil;rd=false;c_=nil;de=false;if not cT then b7=false;bv=nil end;if bb then cw.ToggleVerticalTakeoff()end;if bB then cw.ToggleIntoOrbit()end;cC=q;cf=false;ch=false;c2=0 end;function pJ.BrakeToggle(re)if not b2 then if re then b2=re else b2=true end else b2=false end;if b8 then b8=false;cC=q;de=false end;if b2 then fN("bkOn","B",1)cw.ResetAutopilots()else fN("bkOff","B",1)end end;function pJ.BeginReentry()if ba then dl("Re-Entry cancelled")fN("reOff","RE")ba=false;cC=q;b7=false elseif not ku.hasAtmosphere then dl("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c7=5 elseif not q0 then ba=true;if iB:getAxisCommandType(0)~=rf.cruise then d.control.cancelCurrentControlMasterMode()end;cC=true;b2=false;dl("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cE)fN("par","RE")else ba=true;b7=true;cC=true;b2=false;bc=ku.surfaceMaxAltitude+a0;if bc>ku.spaceEngineMinAltitude then bc=ku.spaceEngineMinAltitude-0.01*ku.noAtmosphericDensityAltitude end;local rg=iF(bc)dl("Beginning Re-entry.  Target speed: "..cE.." Target Altitude: "..rg)fN("glide","RE")qb=bO(cE)end;b9=false end;function pJ.ToggleAntigrav()if antigrav and not r then if cT then fN("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bx==nil then bx=cl end;if bx<1000 then bx=1000 end;fN("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pJ.changeSpd(rh)local ri=1;if rh then ri=-1 end;if not c4 then if t and not p8 and pZ then local rj=bU;bU=fO(dp(bU+ri*aF/100,-1,1),2)if bU>=0 and rj<0 then bU=0;pZ=false end elseif p8 then if cj or ba then cE=dp(cE+ri*aF,0,W)elseif b5 then a1=dp(a1+ri*aF/3.6*100,0,di-0.2)end else iB:updateCommandFromActionStart(axisCommandId.longitudinal,ri*aF/10)end else if b5 or bs or cg or bB then d4=d4+1*ri*-1;if d4>#cX then d4=1 end;if d4<1 then d4=#cX end else if not rh then ri=1 else ri=nil end;cv.adjustAutopilotTargetIndex(ri)end end end;function pJ.TenthTick()local function rk()if not b5 then if fZ==nil or fZ.planetname~=ku.name then rl=(cb.center-cR):len()else rl=(fZ.position-cR):len()end end;local kj=cO;local rm=c.getThrottle()/100;if t then rm=bU end;local rn,ro=cs.computeDistanceAndTime(cO,a1,cm,d:maxForceForward()*rm,a3,0)local c9,ca;if not b6 then c9,ca=cw.GetAutopilotBrakeDistanceAndTime(a1)else c9,ca=cw.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dT,rp;if not b6 and kj>0 then dT,rp=cw.GetAutopilotBrakeDistanceAndTime(kj)else dT,rp=cw.GetAutopilotTBBrakeDistanceAndTime(kj)end;local rq=0;local rr=0;if bg or not b5 and kj>5 then rr=cs.computeTravelTime(kj,0,rl)elseif c9+rn<rl then rq=rl-(c9+rn)rr=cs.computeTravelTime(a1,0,rq)else local rs=(rl-c9)/rn;rn=rl-c9;ro=ro*rs end;if fZ~=nil and fZ.planetname==ku.name and not b5 then return rr elseif bf then return rp elseif bg then return rr+rp else return ro+ca+rr end end;local function rt()local oc=b.getGravityIntensity()oc=fO(oc,5)if pY==nil or pY~=oc then local kj=cM:len()local ru=bR.getMaxBrake()if ru~=nil and ru>0 and cj then ru=ru/dp(kj/100,0.1,1)ru=ru/ck;if ck>0.10 then bw=ru end end;if ru~=nil and ru>0 then bu=ru end;pY=oc end end;d6=bR.getDockedConstructs()d5=bR.getPlayersOnBoard()qp=0;for M=1,#d6 do qp=qp+bR.getDockedConstructMass(d6[M])end;local rv=0;for M=1,#d5 do rv=rv+bR.getBoardedPlayerMass(d5[M])end;if rv>20000 then qp=qp+rv-20000 end;cY,cZ=qq()di=bR.getMaxSpeed()if bl~="None"and(cb or fZ)then lr=rk()end;rt()end;local function rw(rx,ry)local oC=vec3()local rz=vec3()if rx==axisCommandId.longitudinal then oC=vec3(bR.getOrientationForward())rz=cK elseif rx==axisCommandId.vertical then oC=vec3(bR.getOrientationUp())rz=q7 elseif rx==axisCommandId.lateral then oC=vec3(bR.getOrientationRight())rz=cL else return vec3()end;local rA=vec3(b.getWorldGravity())local rB=rA:dot(rz)local rC=vec3(bR.getWorldAirFrictionAcceleration())local rD=rC:dot(rz)local rE=cM:dot(oC)local rF=ry*constants.kph2m;if rG==nil then rG=pid.new(10,0,10.0)end;rG:inject(rF-rE)local rH=rG:get()local rI=(rH-rD-rB)*rz;return rI end;local function rJ(rx,ry)local oC=vec3()local rz=vec3()if rx==axisCommandId.longitudinal then oC=vec3(bR.getOrientationForward())rz=cK elseif rx==axisCommandId.vertical then oC=vec3(bR.getOrientationUp())rz=q7 elseif rx==axisCommandId.lateral then oC=vec3(bR.getOrientationRight())rz=cL else return vec3()end;local rA=vec3(b.getWorldGravity())local rB=rA:dot(rz)local rC=vec3(bR.getWorldAirFrictionAcceleration())local rD=rC:dot(rz)local rE=cM:dot(oC)local rF=ry*constants.kph2m;if rK==nil then rK=pid.new(10,0,10.0)end;rK:inject(rF-rE)local rH=rK:get()local rI=(rH-rD-rB)*rz;return rI end;local function rL(rM,jY,fV)local rN=rM:cross(fV):normalize_inplace()local kL=math.acos(dp(rN:dot(-jY),-1,1))*constants.rad2deg;if rN:cross(-jY):dot(fV)<0 then kL=-kL end;return kL end;local function rO()if d2 and not b8 then local ev=d2[1]local hY,hZ=d2[2],d2[3]local rP=math.min(hY,hZ or hY)local rQ=rP/cO;local rR=b9 and(cO<42 or ci~=-1)local rS=b7 or bs or bv or b5;if rS and not rR and(c9*1.5>rP or rQ<1)then b2="Collision"bH={}qa=0;if b7 then cw.ToggleAltitudeHold()end;if bv then cw.ToggleLockPitch()end;dl("Autopilot Cancelled due to possible collision")a.print(ev.name.." COLLISION "..iG(rQ).." / "..iF(rP,2))cw.ResetAutopilots(1)qY=true;if cj then b8=true end;cC=true end;if rQ<11 then d1=ev.name.." COLLISION "..iG(rQ).." / "..iF(rP,2)else d1=ev.name.." collision "..iG(rQ)end;if rQ<6 then fN("alarm","AL",2)end else d1=false end end;local rT=1;local rU=0;local rV=1;local rW=1;local rX=1;local rY=false;function pJ.onFlush()if antigrav and not r and not cT and antigrav.getBaseAltitude()~=bx then qk=bx end;if dh then d:setEngineForceCommand('hover',vec3(),1)dh=false end;cU=iB:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local rZ=dp(b_+q1+a.getControlDeviceForwardInput(),-1,1)local r_=dp(c0+q3+a.getControlDeviceYawInput(),-1,1)local s0=dp(c1+q2-a.getControlDeviceLeftRightInput(),-1,1)local s1=b2 and 1 or 0;if cj then cP=vec3(b.getWorldVertical())if cP==nil or cP:len()==0 then cP=(ku.center-cR):normalize()end else cP=(ku.center-cR):normalize()end;q7=vec3(bR.getWorldOrientationUp())cK=vec3(bR.getWorldOrientationForward())cL=vec3(bR.getWorldOrientationRight())cN=vec3(bR.getWorldVelocity())cM=vec3(bR.getVelocity())cR=vec3(bR.getWorldPosition())cm=bR.getMass()+qp;cO=vec3(cN):len()cQ=-cP:dot(cN)cW=getRoll(cP,cK,cL)local s2=cW/180*math.pi;local s3=math.cos(s2)local s4=math.sin(s2)cV=rL(cP,cK,cL*s3+q7*s4)local s5=cN:normalize()local s6=f1(cW)local s7=utils.sign(cW)local s8=vec3(bR.getWorldAngularVelocity())local s9=rZ*aP*cL+r_*aK*cK+s0*aQ*q7;if cC==true and cP:len()>0.01 then local sa=f1(q4-cW)if((b4 or ba or b8 or cf or b7 or bB)and sa>0 or cj and sa<aL and q)and r_==0 and f1(cV)<85 then local sb=q4;local sc=aJ;if not cj then sc=sc/4;q4=0;sb=0 end;if sd==nil then sd=pid.new(sc*0.01,0,sc*0.1)end;sd:inject(sb-cW)local se=sd:get()s9=s9+se*cK end end;bV=0;ck=bP()cj=false or cl<ku.noAtmosphericDensityAltitude and ck>0.00001;cl=(cR-ku.center):len()-ku.radius;ci=qB()bT=bN()pO=bT;if bo and ci>-1 and ci-3<_ then if iB.targetGroundAltitudeActivated then iB:deactivateGroundEngineAltitudeStabilization()end end;if cx then qn=not qn;if qn then cx.UpdateRadar()end;if E then rO()end end;if antigrav then cT=antigrav.isActive()==1 end;local sf=bT-pO;local sg=-math.deg(qv(q7,cN,cK))local sh=math.deg(qv(cL,cN,cK))local gk=cP*-1;cD=cj and sg<-N or sg>N or sh<-O or sh>O;local si=a.getMouseDeltaX()local sj=a.getMouseDeltaY()if qo then local sk=bN()-qo;si=si*sk/0.016;sj=sj*sk/0.016 end;qo=bN()if p and not c4 then sj=-sj end;q2=0;q3=0;q1=0;local sl=bR.getWorldPosition()ku=fR:closestBody(sl)sm=ct(ku)fn=sm:orbitalParameters(sl,cN)d0=c.getClosestPlanetInfluence()>0 or cl>0 and cl<200000;local oc=ku:getGravity(sl):len()*cm;q4=0;local sn=bR.getMaxThrustAlongAxis("ground",bR.getOrientationUp())[1]if qe==0 then if iA()==1 and c4 then if not cA then cc=dp(cc+si/2,-ad/2,ad/2)cd=dp(cd+sj/2,-ae/2,ae/2)end else cc=0;cd=0 end else cc=dp(cc+si/2,-ad/2,ad/2)cd=dp(cd+sj/2,-ae/2,ae/2)dg=dr(cc*cc+cd*cd)if not c4 and iA()==0 then local kU,kV=1,1;if bL=="SCOPE"then kU,kV=d8/90,d8/90 end;if g=="virtual joystick"then if dg>aA then q2=q2-dp(f1(cc)-aA,0,ad/2)*utils.sign(cc)*aH*kU;q1=q1-dp(f1(cd)-aA,0,ae/2)*utils.sign(cd)*aI*kV end else cc=0;cd=0;if g=="mouse"then q1=(-utils.smoothstep(sj,-100,100)+0.5)*2*rW;q2=(-utils.smoothstep(si,-100,100)+0.5)*2*rX end end end end;local so=cO>27777;if cO>X/3.6 and not cj and not b5 and not so then dl("Space Speed Engine Shutoff reached")qa=0 end;if not so and sp then if not b2 then cw.BrakeToggle()end;if b5 then cw.ResetAutopilots(1)end;qa=0 end;sp=so;if ck>0.09 then if cO>cE/3.6 and not t and not pK then b2="SpdLmt"pK=true elseif not t and pK then if cO<cE/3.6 then b2=false;pK=false end end end;if b4 then if cf then b2=false;local sq=false;sq=qN(fZ.position-cR,0.1)cC=true;if sq then qb=bO(cE)if(f1(cW)<2 or f1(cV)>85)and cO>=cE/3.6-1 then b2=false;b4=false;if cf~=2 then q0=true end;if cf==true then ch=true end;cf=false;b5=false;cw.BeginReentry()end elseif cj and t then qa=1 end elseif cO>iU then qN(vec3(cN),0.01)end end;if b3 then if cj then b3=false elseif cO>iU then qN(-vec3(cN))end end;if not b4 and cf and not bB then if not cj then if cf~=2 then q0=true end;cw.BeginReentry()cf=false;ch=true else cf=false;if not ql then ql=true end end end;if ch and fZ and(cl<bc+250 and cl>bc-250)and f1(cQ)<25 and ck>=0.1 and(fZ.position-cR):len()>2000+cl then if not ql then ql=true end;ch=false end;if bb then cC=true;local sr=bc;if cQ<-30 then dl("Unable to achieve lift. Safety Landing.")c2=0;cC=q;bb=false;b8=true elseif not r and cT or bc<ku.spaceEngineMinAltitude then if cT then sr=antigrav.getBaseAltitude()end;if cl<sr-100 then q5=0;c2=15;b2=false elseif cQ>0 then b2="VTO Limit"c2=0 elseif cQ<-30 then b2="VTO Fall"c2=15 elseif cl>=sr then if cT then if b5 or bs then cw.ToggleVerticalTakeoff()else b2="VTO Complete"bb=false end;dl("Takeoff complete. Singularity engaged")fN("aggLk","AG")else b2=false;dl("VTO complete. Engaging Horizontal Flight")fN("vtoc","VT")cw.ToggleVerticalTakeoff()end;c2=0 end else if ck>0.08 then q5=0;b2=false;c2=20 elseif ck<0.08 and cj then b2=false;if cI then q5=0;c2=20 else c2=0;q5=36;qb=3500 end else cC=q;bB=true;cH=false;ss=false;pT=false;pR=nil;pS=nil;if pW==nil then pW=ku end;cG=sr;pV=true;bb=false end end;if q5~=nil then if st==nil then st=pid.new(2*0.01,0,2*0.1)end;local su=dp(q5-cV,-O*0.80,O*0.80)st:inject(su)local sv=dp(st:get(),-1,1)q1=sv end end;if bB then local function sw()if fn.periapsis.altitude>=cG*0.99 and fn.apoapsis.altitude>=cG*0.99 and fn.periapsis.altitude<fn.apoapsis.altitude and fn.periapsis.altitude*1.05>=fn.apoapsis.altitude and f1(cG-cl)<1000 then return true else return false end end;local qU;local sx=false;local sy=iF(cG,3)if pW==nil then pW=ku;if bs then pW=cb end end;if not pV then cG=bO(pW.radius+pW.surfaceMaxAltitude+V)if pW.hasAtmosphere then cG=bO(pW.radius+pW.noAtmosphericDensityAltitude+V)end;pV=true end;if q6.VectorToTarget and fZ then qU=fZ.position-cR end;local sz,sA=ct(pW):escapeAndOrbitalSpeed((cR-pW.center):len()-pW.radius)local sB=cW;if not pT then local sC=false;local sD=false;qa=0;pS=0;cF="Aligning to orbital path - OrbitHeight: "..sy;if q6.VectorToTarget then qN(qU:normalize():project_on_plane(cP))sx=cK:dot(qU:project_on_plane(q7):normalize())>0.95 else qN(cN)sx=sg<0.5;if cO<150 then sx=true end end;q1=0;pR=0;if cV<=pR+2 and cV>=pR-2 then sC=true else sC=false end;if sB<=pS+2 and sB>=pS-2 then sD=true else sD=false end;if sC and sD and sx then pR=nil;pS=nil;pT=true end else if q6.VectorToTarget then qN(qU:normalize():project_on_plane(cP))elseif cO>150 then qN(cN)end;q1=0;if q6.VectorToTarget and fZ then local c9,dT=cs.computeDistanceAndTime(cO,cE/3.6,cm,0,0,bu)if cH and qU:len()>15000+c9+cl then cF="Orbiting to Target"if cl-100<=pW.noAtmosphericDensityAltitude or lr>fn.timeToPeriapsis and fn.periapsis.altitude<pW.noAtmosphericDensityAltitude or not sw()and fn.eccentricity>0.1 then dl("Re-Aligning Orbit")cH=false end elseif cH or qU:len()<15000+c9+cl then dl("Orbit complete, proceeding with reentry")fN("orCom","OB")bm=fZ.position;q0=true;ch=true;q6.VectorToTarget,q6.AutopilotAlign=false,false;cw.ToggleIntoOrbit()cw.BeginReentry()return end end;if fn.periapsis~=nil and fn.apoapsis~=nil and fn.eccentricity<1 and cl>cG*0.9 and cl<cG*1.4 then if fn.apoapsis~=nil then if(sw()or cH)and not K then if cH then b2=false;qa=0;pR=0;if not q6.VectorToTarget then dl("Orbit complete")fN("orCom","OB")cw.ToggleIntoOrbit()end else pX=pX+1;if pX>=2 then cH=true end end else if sw()then cF="Maintaining "else cF="Adjusting "pU=true;qb=sA*3.6+1;local sE=cG-cl;if sF==nil then sF=pid.new(0.1,0,1*0.1)end;sF:inject(sE-cQ*dp(utils.smoothstep(2000-sE,-2000,2000)^6*10,1,10))pR=dp(sF:get(),-60,60)end;cF=cF.." - OrbitHeight: "..sy end end else local sG=2.75;local sH=f1(fO(sz*sG))local op=sH%50;if op>0 then sH=sH-op+50 end;b2=false;if cl<cG*0.8 then cF="Escaping planet gravity - OrbitHeight: "..sy;pR=utils.map(cQ,200,0,-15,80)elseif cl>=cG*0.8 and cl<cG*1.15 then cF="Approaching orbital corridor - OrbitHeight: "..sy;sH=sH*0.75;pR=utils.map(cQ,100,-100,-15,65)elseif cl>=cG*1.15 and cl<cG*1.5 then cF="Approaching orbital corridor - OrbitHeight: "..sy;sH=sH*0.75;if cQ<0 or pU then pR=utils.map(cl,cG*1.5,cG*1.01,-30,0)else pR=utils.map(cl,cG*0.99,cG*1.5,0,30)end elseif cl>cG*1.5 then cF="Reentering orbital corridor - OrbitHeight: "..sy;pR=-65;local sI=utils.map(cQ,-150,-400,1,0.55)sH=sH*sI end;qb=bO(sH)end end;if pR~=nil then if sJ==nil then sJ=pid.new(1*0.01,0,5*0.1)end;local sK=pR-cV;sJ:inject(sK)local sL=dp(sJ:get(),-0.5,0.5)q1=sL end end;if b5 and not cj and not cf then local function sM(sN,fn)a.print(sN)b4=false;b2=false;bf=false;b5=false;r5=false;bi="Aligning"qa=0;p_=false;dl(sN)fN("apCom","AP")if fn or cf then if fn and gi~=nil and not cf then if not cl or cl==0 then return end;cG=cl;pV=true end;cw.ToggleIntoOrbit()end end;local sO,sP=bm,false;if fZ and fZ.planetname~="Space"then be=true;if not r5 then local sQ=(fZ.position-cb.center):normalize()local sR=sQ:project_on_plane((cb.center-cR):normalize()):normalize()local sS=cb.center+sR*(cb.radius+gi)local sT=fZ.position+(fZ.position-cb.center):normalize()*(gi-cb:getAltitude(fZ.position))if(cR-sS):len()<(cR-sT):len()then sO=sS else sO=sT;bh=0 end;bm=sO;cw.showWayPoint(cb,bm)sP=true;r5=true end;bj=0 elseif fZ and fZ.planetname=="Space"then if not r5 then bj=0;sP=true;be=true;r5=true;sO=fZ.position+(cR-fZ.position):normalize()*T;bm=sO end elseif fZ==nil then bj=0;if not r5 then local sQ=(cR+cN*100000-cb.center):normalize()local sR=sQ:project_on_plane((cb.center-cR):normalize()):normalize()if sR:len()<1 then sQ=(cR+cK*100000-cb.center):normalize()sR=sQ:project_on_plane((cb.center-cR):normalize()):normalize()end;sO=cb.center+sR*(cb.radius+gi)bm=sO;r5=true;sP=true;be=true;cw.showWayPoint(cb,bm)end end;rl=(vec3(sO)-cR):len()local lp,eM,eN=cr:getPlanetarySystem(0):castIntersections(cR,cN:normalize(),function(ev)if ev.noAtmosphericDensityAltitude>0 then return ev.radius+ev.noAtmosphericDensityAltitude else return ev.radius+ev.surfaceMaxAltitude*1.5 end end)local lq=eM;if eN~=nil and eM~=nil then lq=math.min(eN,eM)end;if lq~=nil and lq<rl and lp.name==cb.name then rl=lq end;local sq=true;local sU=(cb.center-(cR+vec3(cN):normalize()*rl)):len()-cb.radius;local lm=iF(sU)qi=ga;qj='{"label": "Projected Altitude", "value": "'..lm..'"}'if cO>50 and bd then local qU=vec3(sO)-cR;local sV=dp(math.deg(qv(q7,cN:normalize(),qU:normalize()))*cO/500,-90,90)local sW=dp(math.deg(qv(cL,cN:normalize(),qU:normalize()))*cO/500,-90,90)if f1(sV)<20 and f1(sW)<20 then sV=sV*2;sW=sW*2 end;if f1(sV)<2 and f1(sW)<2 then sV=sV*2;sW=sW*2 end;local sg=-math.deg(qv(q7,cK,cN:normalize()))local sh=-math.deg(qv(cL,cK,cN:normalize()))if sX==nil then sX=pid.new(2*0.01,0,2*0.1)end;sX:inject(sW-sh)local sY=dp(sX:get(),-1,1)q1=q1+sY;if sZ==nil then sZ=pid.new(2*0.01,0,2*0.1)end;sZ:inject(sV-sg)local s_=dp(sZ:get(),-1,1)q2=q2+s_;sP=true;if f1(sV)>2 or f1(sW)>2 then if bi~="Adjusting Trajectory"then bi="Adjusting Trajectory"fN("apAdj","AP")end else if bi~="Accelerating"then bi="Accelerating"fN("apAcc","AP")end end elseif bd and cO<=50 then qN((sO-cR):normalize())end;if sU<gi*1.5 then bh=cE/3.6;if fZ==nil then dT,bh=ct(cb):escapeAndOrbitalSpeed(sU)end end;local c9,ca;if not b6 then c9,ca=qr(cO)else c9,ca=qu(cO)end;if b5 and not bd and not bg and not bf then local lp,lq=cw.checkLOS((bm-cR):normalize())if cb.name~=ku.name then if lp~=nil and cb.name~=lp.name and lq<rl then d1="Attempting to clear LOS between "..lp.name.." and waypoint."qf=true else qf=false;d1=false end end end;if not qf then if not bg and not bf and not sP then sq=qN((sO-cR):normalize())elseif b6 and(bf or bg)then sq=qN(-vec3(cN):normalize())end end;if bd then if not p_ then b2=false;qa=a2;bU=fO(a2,2)p_=true end;local rm=c.getThrottle()if t then rm=bU end;local t0=99999;local on=-vec3(bR.getWorldAcceleration()):dot(cN:normalize())local t1=dp(cN:dot((sO-cR):normalize()),0,cO)if t1>0 or on>0 then t0=cs.computeTravelTime(t1,on,rl-c9)end;if a1>di then a1=di-0.2 end;if cM:len()>=a1 or rm==0 and p_ or a3/4>t0 then bd=false;if bi~="Cruising"then fN("apCru","AP")bi="Cruising"end;bg=true;qa=0 end;local t2=rl;if t2<=c9 or H and cZ<=c9+10000 and cY then if H and cZ<=c9+10000 and cY then if cZ<pL and cZ>2000 then cw.ResetAutopilots(1)dl("Autopilot cancelled to prevent crossing PvP Line")b2="PvP Prevent"pL=cZ else pL=cZ;return end end;bd=false;if bi~="Braking"then fN("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cC=true end;qa=0;p_=false end elseif bf then if bi~="Orbiting to Target"then b2="AP Brk"end;if b6 then qa=1;qc=true end;local dT,sA=ct(cb):escapeAndOrbitalSpeed((cR-ku.center):len()-ku.radius)local qU;if fZ then qU=fZ.position-cR end;if fZ and fZ.planetname=="Space"and cO<50 then if#bH>0 then if not ql then table.remove(bH,1)end;if#bH>0 then b2=false;if not ql then ql=2 end;return end end;sM("Autopilot complete, arrived at space location")b2="Space Arrival"elseif fZ and fZ.planetname~="Space"and cO<=sA and(fn.apoapsis==nil or fn.periapsis==nil or fn.apoapsis.altitude<=0 or fn.periapsis.altitude<=0)then sM("Autopilot complete, commencing reentry")bm=fZ.position;cf=true;cw.showWayPoint(cb,bm)elseif(fZ and fZ.planetname~="Space"or fZ==nil)and fn.periapsis~=nil and fn.periapsis.altitude>0 and fn.eccentricity<1 or bi=="Circularizing"then if bi~="Circularizing"then fN("apCir","AP")bi="Circularizing"end;if cO<=sA then if fZ then if cN:normalize():dot(qU:normalize())>0.4 then if bi~="Orbiting to Target"then fN("apOrb","OB")bi="Orbiting to Target"end;if not r7 then b2=false;cw.showWayPoint(cb,fZ.position)r7=true end else sM("Autopilot complete, proceeding with reentry")bm=fZ.position;cf=true;cw.showWayPoint(cb,fZ.position)r7=false end else sM("Autopilot completed, setting orbit",true)b2=false end end elseif bi=="Circularizing"then sM("Autopilot complete, fixing Orbit",true)end elseif bg then local t2=rl;if t2<=c9 or H and cZ<=c9+10000 and cY then if H and cZ<=c9+10000 and cY then if cZ<pL and cZ>2000 then if not ql then ql=true end;dl("Autopilot cancelled to prevent crossing PvP Line")b2="Prevent PvP"pL=cZ else pL=cZ;return end end;bd=false;if bi~="Braking"then fN("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cC=true end end;local rm=c.getThrottle()if t then rm=bU end;if rm>0 then bd=true;if bi~="Accelerating"then bi="Accelerating"fN("apAcc","AP")end;bg=false end else if sq then if not be and fZ==nil or not be and fZ and fZ.planetname~="Space"then if not cf then bm=vec3(cb.center)+(gi+cb.radius)*cL;t3=q7;t4=cL end;be=true elseif sq and not qf then bd=true;if bi~="Accelerating"then bi="Accelerating"fN("apAcc","AP")end;if not p_ then qa=a2;qc=true;bU=fO(a2,2)p_=true;b2=false end end end end elseif b5 and(fZ~=nil and fZ.planetname~="Space"and cj)then dl("Autopilot complete, starting reentry")fN("apCom","AP")bm=fZ.position;b2=false;bf=false;b5=false;r5=false;bi="Aligning"qa=0;p_=false;b4=true;cf=true;cw.showWayPoint(cb,fZ.position)end;if c3 then cC=true;local sW=0;local fp=vec3(t5.getWorldPosition())local t6=fp-cR;local t7=vec3(t6):project_on(cK):len()local t8=vec3(t6):project_on(cL):len()local ce=dr(t7*t7+t8*t8)qN(t6:normalize())local my=40;local t9=ce<my;local ta=100;local ry=dp((ce-my)/2,10,ta)q1=0;local sq=f1(q2)<0.1;if sq and cO<ry and not t9 then b2=false;sW=-20 else b2="Follow"sW=0 end;local tb=0;if f1(sW-cV)>tb then if tc==nil then tc=pid.new(2*0.01,0,2*0.1)end;tc:inject(sW-cV)local sY=tc:get()q1=sY end end;if b7 or b8 or ba or bs or bv~=nil then if bJ then if ci==-1 then bc=bc-0.2 else bc=cl+bJ-ci end end;local td=bw;if td then td=td*dp(cO/100,0.1,1)*ck else td=bu end;if not cj then td=bu end;q9=cK:project_on_plane(cP):normalize():dot(cN)if q9>100 then c9,ca=cs.computeDistanceAndTime(q9,100,cm,0,0,td)local te,dT=cs.computeDistanceAndTime(100,0,cm,0,0,td*0.55)c9=c9+te else c9,ca=cs.computeDistanceAndTime(q9,0,cm,0,0,td*0.55)end;local sE=bc-cl-cQ;local tf=200+cO;if ba or cf then tg=2000+cO end;local th=1;if b9 then th=dp(cO/100,0.1,1)end;local sW=(utils.smoothstep(sE,-tf,tf)-0.5)*2*Q*th;if not ba and not cf and not bs and cK:dot(cN:normalize())<0.99 then sW=(utils.smoothstep(sE,-tf*dp(20-19*ck*10,1,20),tf*dp(20-19*ck*10,1,20))-0.5)*2*Q*dp(2-ck*10,1,2)*th end;if not b7 then sW=0 end;if bv~=nil then if d0 and not bB then sW=bv else bv=nil end end;cC=true;local ti=q1;if ba then local tj=bO(cE)local tk,tl=cs.computeDistanceAndTime(cO,tj/3.6,cm,0,0,bu-ku.gravity*9.8*cm)tk=tk==-1 and 5000 or tk;local r6=cl-(ku.noAtmosphericDensityAltitude+tk)local tm=cl>ku.noAtmosphericDensityAltitude+tk*1.35;if tm then sW=R;if cO<=tj/3.6 and cO>tj/3.6-10 and f1(cN:normalize():dot(cK))>0.9 and not cU then bY=false;qa=1 end elseif(cU or iB:getTargetSpeed(axisCommandId.longitudinal)~=tj)and not tm and not cj then qb=tj;qc=true end;if cU then if cO>tj/3.6 and not tm then b2="Reentry Limit"if bU>0 then qa=0 end else b2=false end else b2=false end;if cQ>0 then b2="Reentry vSpd"end;if not q0 then sW=-80;if cl<ku.surfaceMaxAltitude+(ku.atmosphereThickness-ku.surfaceMaxAltitude)*0.25 then dl("PARACHUTE DEPLOYED at "..fO(cl,0))ba=false;b8=true;qY=true;qa=0;sW=0;cC=q end elseif ku.noAtmosphericDensityAltitude>0 and tm then cC=true elseif not tm then if not cj and(cU or iB:getTargetSpeed(axisCommandId.longitudinal)~=tj)then qb=tj end;if cO<tj/3.6+1 then b2=false;q0=false;ba=false;cC=true;qa=1 end end end;if cO>iU and not cg and not bs and not b8 and u then qN(vec3(cN))end;if c_ or(bs or cg)and bn>0 and cj then local qU;if c_ then if type(c_)=="table"then qU=c_ elseif c_<3 and c_>0 then qU=-cP:cross(cN)*5000 elseif c_>=3 then qU=cP:cross(cN)*5000 elseif c_<0 then qU=cN*25000 end elseif fZ~=nil then qU=fZ.position-cR else qU=cb.center-cR end;local sV=math.deg(qv(cP:normalize(),cN,qU))*2;local mB=math.rad(f1(cW))if cO>aM and cj then local tn=1000+cO;local to=(utils.smoothstep(sE-cQ*10,-tn,tn)-0.5)*2*Q;local tp=dp(90-to,0,180)q4=dp(sV*2,-tp,tp)local tq=sV;sV=dp(dp(sV,-N*0.80,N*0.80)*math.cos(mB)+4*(cV-sW)*math.sin(math.rad(cW)),-N*0.80,N*0.80)local tr=1;if q4~=0 then tr=f1(mB/q4)end;tr=(90-dp(f1(q4-cW),0,90))/90;local ts=sW;if f1(cW)>90 then ts=-ts end;sW=tr*dp(dp(ts*math.cos(mB),-O*0.8,O*0.8)+f1(dp(f1(tq)*math.sin(mB),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q4=0;sV=dp(sV,-N*0.80,N*0.80)end;local tt=sg-sV;if c_ and f1(tt)<=0.0001 and(type(c_)=="table"or type(c_)~="table"and c_<0 and f1(cW)<1)then if c_==-2 then cw.ToggleAltitudeHold()end;c_=nil;fN("180Off","BR")return end;if not cD and cO>aM and cj then if tu==nil then tu=pid.new(2*0.01,0,2*0.1)end;tu:inject(tt)local s_=dp(tu:get(),-1,1)q2=q2+s_ elseif cj and ci>-1 or cO<aM then qN(qU)elseif cD and cj then if(sg<-N or sg>N)and cj then qN(cN)end;if(sh<-O or sh>O)and cj then sW=dp(cV-sh,cV-O*0.80,cV+O*0.80)end end;if fZ~=nil and not cg then local sr=ku:getAltitude(fZ.position)local r6=qU:project_on_plane(cP):len()qY=true;if bc<ku.noAtmosphericDensityAltitude and not cg and not b9 and not ba and(r6<=c9 and qU:len()<ku.radius)and(cN:project_on_plane(cP):normalize():dot(qU:project_on_plane(cP):normalize())>0.99 or lt=="Finalizing Approach")then lt="Finalizing Approach"if#bH>0 then if not ql then table.remove(bH,1)end;if#bH>0 then if not ql then ql=2 end;return end end;qa=0;if b7 then cw.ToggleAltitudeHold()bs=true end;b2="AP Finalizing"elseif not b9 then b2=false end;if lt=="Finalizing Approach"and(q9<0.1 or r6<0.1 or tv~=nil and tv<r6)then fN("bklOn","BL")b8=true;de=true;if fZ.heading then df=fZ.heading else df=nil end;bs=false;lt="Proceeding to Waypoint"d1=false end;tv=r6 end elseif bs and not cj and bc>ku.noAtmosphericDensityAltitude and not(cg or ba)then if fZ~=nil and cb.name==ku.name then local qU=fZ.position-cR;local sr=ku:getAltitude(fZ.position)local r6=dr(qU:len()^2-(cl-sr)^2)local td=bw;if td then c9,ca=cs.computeDistanceAndTime(cO,0,cm,0,0,td/2)qY=true;if r6<=c9+cO*sf/2 and cN:project_on_plane(cP):normalize():dot(qU:project_on_plane(cP):normalize())>0.99 then if ku.hasAtmosphere then b2=false;b4=false;q0=true;cf=false;ch=true;b5=false;cw.BeginReentry()end end;tv=r6 end end end;if not cj and ci==-1 and(b7 and bc>ku.noAtmosphericDensityAltitude)and not(cg or bB or ba)then if not cH and not bB then cG=bc;pV=true;if bs then q6.VectorToTarget=true end;cw.ToggleIntoOrbit()bs=false;pT=true end end;if cD and cj and ci==-1 and cO>aM and lt~="Finalizing Approach"then qN(cN)sW=dp(cV-sh,cV-O*0.80,cV+O*0.80)end;q1=ti;local qG=-1;if b8 then local tw=aZ or 0.05;if not qg then rY=false;if not cU then qa=0 end;if ci==-1 then iB:setTargetGroundAltitude(500)iB:activateGroundEngineAltitudeStabilization(500)end;bD=true;if not cj then rY=true end;qg=true end;sW=0;local tx=false;local ty=math.abs(q9)if not r and cT then tx=antigrav.getBaseAltitude()if tx<ku.surfaceMaxAltitude and fZ==nil or fZ~=nil and ku:getAltitude(fZ.position)>tx then tx=false end else tx=false end;if df then if ty<tw then if cQ>-P then b2=false else b2="BL Align BLR"end;if qN(df,0.001)then df=nil;cC=q else q1=0;cC=true end else b2="BL Align Hzn"end;if tx and f1(cl-tx)<250 then b2="AGG Align"end else local tz=false;local tA=30;if ty<10 and sn~=nil and sn>0 then local tB=dp(ck,0.4,2)local td=bw*dp(cO/100,0.1,1)*tB;local tC=sn*tB+td-oc;local tD=td/2-oc;local tE=cO-dr(f1(tD/2)*20/(0.5*cm))*utils.sign(tD)if tE<0 then tE=0 end;local tF;if cO>100 then local tG,dT=cs.computeDistanceAndTime(cO,100,cm,0,0,td)local tH,dT=cs.computeDistanceAndTime(100,0,cm,0,0,dr(td))tF=tG+tH else tF=cs.computeDistanceAndTime(cO,0,cm,0,0,dr(td))end;if tF<20 then b2=false else local tI=0;if tE>100 then local tJ,dT=cs.computeDistanceAndTime(tE,100,cm,0,0,tC)local tK,dT=cs.computeDistanceAndTime(100,0,cm,0,0,sn*tB+dr(td)-oc)tI=tJ+tK else tI,dT=cs.computeDistanceAndTime(tE,0,cm,0,0,sn*tB+dr(td)-oc)end;tI=(tI+15+cO*sf)*1.1;local tL=de and fZ~=nil and ku:getAltitude(fZ.position)>0 and fZ.safe;local sr=nil;if tx and tx<cl then sr=tx elseif tL then sr=ku:getAltitude(fZ.position)+250 elseif cl>ku.surfaceMaxAltitude then sr=ku.surfaceMaxAltitude end;if d2 then local tM=ku:getAltitude(d2[1].center)if sr then if tM>sr then sr=tM end else sr=tM end end;if sr~=nil then local tN=cl-sr;tz=true;if tN<=tI or tI==-1 or ty>tw and de then if sr==ku.surfaceMaxAltitude and cQ<-P then b2="BL Stop BLR"elseif ty>tw and de then b2="BL AP Hzn"else b2="BL Stop Dist"end else b2=false end end end end;qG=ci;if qG>-1 then b2=false;if not tx and not bo then qd=true;iB:setTargetGroundAltitude(_)end;if(cO<1 or cN:normalize():dot(cP)<0)and not df and qG-3<_ then b8=false;b7=false;c2=0;qZ(0,1)b2="BL Complete"cC=q;de=false;qg=false else if cQ<-5 or ty>tw*10 then qZ(0,1)b2="BL Slowing"else b2=false;qZ(-1)end end elseif not tz then if qY and cN:normalize():dot(-gk)<0.999 then b2="BL Strong"qN()elseif ty>10 or ty>tw and de then b2="BL hSpd"elseif cQ<-P then b2="BL BLR"qZ(0,1)else qZ(-1)b2=false end end end else qg=false end;if b9 or cg then local lp,eN,eM;if bm~=nil then lp,eN,eM=cr:getPlanetarySystem(0):castIntersections(cR,(bm-cR):normalize(),function(ev)if ev.noAtmosphericDensityAltitude>0 then return ev.radius+ev.noAtmosphericDensityAltitude else return ev.radius+ev.surfaceMaxAltitude*1.5 end end)end;if lp~=nil then if lp.name~=cb.name and not cj then d1="Clearing LOS between "..lp.name.." and waypoint."end end;if cT and not cg then if cl>=bc-50 and cO>iU then b9=false;if not b5 and not bs then b2="ATO Agg Arrive"qa=0 end end elseif f1(sW)<15 and cl/bc>0.75 then b9=false;if not cg then if cU and not t then d.control.cancelCurrentControlMasterMode()end elseif cg and cO<iU then b5=true;cg=false;b7=false;b9=false;qa=0 elseif cg then qa=0;b2="ATO Space"end elseif cg and not cj and cb~=nil and(lp==nil or lp.name==cb.name)then b5=true;d1=false;cg=false;b7=false;b9=false;if not cU then qa=0 end;bd=true end end;local tO=ci>-1;local tP=cV;if(bs or cg or c_)and not tO and cO>aM and cj then local mB=math.rad(f1(cW))tP=cV*f1(math.cos(mB))+sh*math.sin(mB)end;local tQ=dp(sW-tP,-O*0.80,O*0.80)if not cj and bs then tQ=dp(sW-tP,-85,Q)elseif not cj then tQ=dp(sW-tP,-Q,Q)end;if f1(cW)<5 or bs or c_ or b8 or tO or b7 then if tc==nil then tc=pid.new(5*0.01,0,5*0.1)end;tc:inject(tQ)local sY=tc:get()q1=q1+sY end end;if antigrav~=nil and(antigrav and not r and cl<200000)then if bx==nil or bx<1000 then bx=1000 end;if tR~=bx then tR=bx;qk=tR end end;if(cj or ba or ch)and t and cU then if tS==nil then tS=pid.new(0.1,0,1)end;local tT=0;if aV>0 and not ba and ck>0.005 and ck<0.1 and cQ>-50 then local tU=bR.getFrictionBurnSpeed()*aV;local tV=cE/3.6;if tU>tV then tT=tU-tV-1 end end;tS:inject(cE/3.6+tT-cN:dot(cK))local tW=tS:get()bX=dp(tW,-1,1)if not da then if bX<bU and(ck>0.005 or ba or ch)then bW=true;da=dp(bX,0.01,1)else bW=false;da=bU end end;if tX==nil then tX=pid.new(1*0.01,0,1*0.1)end;tX:inject(cN:len()-cE/3.6-tT)local tY=dp(tX:get(),0,1)if cj and cQ<-80 or(ck>0.005 or ba or ch)then bV=tY end;if bV>0 then if bW and bX==0.01 and not da then da=0 end else bX=dp(bX,0.01,1)end;local tZ=''local t_=vec3()local u0=rw(axisCommandId.vertical,c2*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",u0,rU)local u1='thrust analog longitudinal 'if bE=="All"or bE=="Longitude"then u1=u1 ..aW end;local u2=iB:getAxisCommandType(axisCommandId.longitudinal)local u3=iB:composeAxisAccelerationFromThrottle(u1,axisCommandId.longitudinal)local u4=rJ(axisCommandId.lateral,bA*1000)tZ=tZ..' , '.."lateral airfoil , lateral ground "t_=t_+u4;if t_:len()>constants.epsilon then d:setEngineForceCommand(tZ,t_,rU,'','','',rV)end;d:setEngineForceCommand(u1,u3,rT)local u5='thrust analog vertical fueled 'local u6='thrust analog lateral fueled 'if bE=="All"or bE=="Lateral"then u6=u6 ..aX end;if bE=="All"or bE=="Vertical"then u5=u5 ..aY end;if c2~=0 or b8 and b2 or not bo and not bD then d:setEngineForceCommand(u5,u0,rT)else d:setEngineForceCommand(u5,vec3(),rT)end;if bA~=0 then d:setEngineForceCommand(u6,u4,rT)else d:setEngineForceCommand(u6,vec3(),rT)end;if s1==0 then s1=bV end;local u7=-s1*(aR*cN+aS*s5)d:setEngineForceCommand('brake',u7)else if t then if not da then da=bU end end;local ry=c.getAxisCommandValue(0)if not cU then if tX==nil then tX=pid.new(1*0.01,0,1*0.1)end;tX:inject(cN:len()-ry/3.6)local tY=dp(tX:get(),0,1)s1=dp(s1+tY,0,1)end;local u7=-s1*(aR*cN+aS*s5)d:setEngineForceCommand('brake',u7)local tZ=''local t_=vec3()local u8=false;local u1='thrust analog longitudinal 'if aW~="none"and(bE=="All"or bE=="Longitude")then u1=u1 ..aW end;local u2=iB:getAxisCommandType(axisCommandId.longitudinal)if u2==axisCommandType.byThrottle then local u3=iB:composeAxisAccelerationFromThrottle(u1,axisCommandId.longitudinal)d:setEngineForceCommand(u1,u3,rT)elseif u2==axisCommandType.byTargetSpeed then local u3=iB:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tZ=tZ..' , '..u1;t_=t_+u3;if iB:getTargetSpeed(axisCommandId.longitudinal)==0 or iB:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iB:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u8=true end end;local u6='thrust analog lateral 'if aX~="none"and(bE=="All"or bE=="Lateral")then u6=u6 ..aX end;local u9=iB:getAxisCommandType(axisCommandId.lateral)if u9==axisCommandType.byThrottle then local ua=iB:composeAxisAccelerationFromThrottle(u6,axisCommandId.lateral)d:setEngineForceCommand(u6,ua,rT)elseif u9==axisCommandType.byTargetSpeed then local u4=iB:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tZ=tZ..' , '..u6;t_=t_+u4 end;local u5='thrust analog vertical 'if aY~="none"and(bE=="All"or bE=="Vertical")then u5=u5 ..aY end;local ub=iB:getAxisCommandType(axisCommandId.vertical)if ub==axisCommandType.byThrottle then local u0=iB:composeAxisAccelerationFromThrottle(u5,axisCommandId.vertical)if c2~=0 or b8 and b2 then d:setEngineForceCommand(u5,u0,rT,'airfoil','ground','',rV)else d:setEngineForceCommand(u5,vec3(),rT)d:setEngineForceCommand('airfoil vertical',u0,rT,'airfoil','','',rV)d:setEngineForceCommand('ground vertical',u0,rT,'ground','','',rV)end elseif ub==axisCommandType.byTargetSpeed then if c2<0 then d:setEngineForceCommand('hover',vec3(),rT)end;local uc=iB:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tZ=tZ..' , '..u5;t_=t_+uc end;if t_:len()>constants.epsilon then if s1~=0 or u8 or f1(s5:dot(cK))<0.5 then tZ=tZ..', brake'end;d:setEngineForceCommand(tZ,t_,rU,'','','',rV)end end;local ud=aO*(s9-s8)local ue=vec3(bR.getWorldAirFrictionAngularAcceleration())ud=ud-ue;d:setEngineTorqueCommand('torque',ud,rT,'airfoil','','',rV)d:setBoosterCommand('rocket_engine')if c8 and not o then local kj=cM:len()local uf=0.15;if not cU then local ug=iB:getTargetSpeed(axisCommandId.longitudinal)if kj*3.6>ug*(1-uf)and uh then uh=false;d:toggleBoosters()elseif kj*3.6<ug*(1-uf)and not uh then uh=true;d:toggleBoosters()end else local rm=c.getThrottle()if t then rm=bU*100 end;local ry=rm/100;if not cj then ry=ry*a1;if kj>=ry*(1-uf)and uh then uh=false;d:toggleBoosters()elseif kj<ry*(1-uf)and not uh then uh=true;d:toggleBoosters()end else local tj=bO(cE)ry=ry*tj/3.6;if kj>=ry*(1-uf)and uh then uh=false;d:toggleBoosters()elseif kj<ry*(1-uf)and not uh then uh=true;d:toggleBoosters()end end end end end;if ui then for dO,dA in pairs(ui)do pJ[dO]=dA end end;ci=qB()return pJ end;local function uj(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uk,iA,iB,iC,ul,gF,fO,e7,dq,dp,fN,iE,pI,dl)local bR=bS;local um={}local un=true;local uo=5;local up=5;local uq=uo;local ur=up;local us=bT;function um.landingGear(qd)bo=not bo;if bo then if b5 or bs or cg or bB then cw.ResetAutopilots(true)end;bv=nil;cw.cmdThrottle(0)if vBooster or hover then if(cj or cl<20000)and not qd and ci==-1 then fN("bklOn","BL")qY=true;ba=false;b9=false;bb=false;if b8 then de=not de end;cC=true;bo=false;b8=true else if bZ then fN("grOut","LG",1)d.control.deployLandingGears()end;de=false;if cj then cC=q;b2="Landing"end end;if qd or ci~=-1 and ci>_-3 then b8=true end;iB:setTargetGroundAltitude(_)b7=false;bJ=false elseif bZ and not b8 then fN("grOut","LG",1)d.control.deployLandingGears()end else if b8 then b8=false end;if bZ then fN("grIn","LG",1)d.control.retractLandingGears()end;iB:activateGroundEngineAltitudeStabilization(r1)if bD then if _<iB.targetGroundAltitude then iB:setTargetGroundAltitude(iB.targetGroundAltitude)else iB:setTargetGroundAltitude(Z)end end end end;function um.startControl(ut)local function uu(rh)local ri=1;local function uv(uw,rh)local ux={ku.surfaceMaxAltitude+100,ku.spaceEngineMinAltitude-0.01*ku.noAtmosphericDensityAltitude,ku.noAtmosphericDensityAltitude+V,ku.radius*(U-1)+ku.noAtmosphericDensityAltitude}local uy=uw;for dT,dA in ipairs(ux)do if rh and uy>dA then uw=dA elseif uw<dA and not rh then uw=dA;break end end;return uw end;if rh then ri=-1 end;if not r and cT then if c4 and rh then bx=1000 elseif bx~=nil then bx=bx+ri*up;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end else bx=tR+ri*100 end elseif b7 or bb or bB then if bB then if c4 then cG=uv(cG,rh)else cG=cG+ri*uo end;if cG<ku.noAtmosphericDensityAltitude then cG=ku.noAtmosphericDensityAltitude end else if c4 and cj then bc=uv(bc,rh)bJ=false else bc=bc+ri*uo;if bJ then if bc>100 then bJ=false else iB:updateTargetGroundAltitudeFromActionStart(ri*1.0)bJ=d:getTargetGroundAltitude()end end end end else iB:updateTargetGroundAltitudeFromActionStart(ri*1.0)end end;local function uz(uA)if not cj then dl("Flight Assist in Atmo only")return end;local dx=type(uA)if c_==nil then if dx=="table"then if b5 or bs then cw.ToggleAutopilot()end;fN("180On","BR")elseif uA==1 then fN("bnkLft","BR")else fN("bnkRht","BR")end;if not b7 and not b5 and not bs then cw.ToggleAltitudeHold()if dx~="table"then uA=uA+1 end end;c_=uA else fN("180Off","BR")c_=nil end end;local function uB()if iC()==1 then cc=0;cd=0;ul(bk)elseif iA()==1 and y then cB=false;cA=false end;c4=false end;if ut=="gear"then cy.landingGear()elseif ut=="light"then if p8 then if iA()==1 then if t5.isFrozen()==1 then t5.freeze(0)dl("Player Unfrozen, pitch/yaw/roll disabled")else t5.freeze(1)dl("Player Frozen, pitch/yaw/roll enabled")end else dl("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ut=="forward"then if p8 and not cj and not b5 then b4=not b4;b3=false else b_=b_-1 end elseif ut=="backward"then if p8 then if not cj then if not b5 then b3=not b3;b4=false else b6=not b6 end else uz(-cN*5000)end else b_=b_+1 end elseif ut=="left"then if p8 then uz(1)else c0=c0-1 end elseif ut=="right"then if p8 then uz(3)else c0=c0+1 end elseif ut=="yawright"then c1=c1-1;df=nil elseif ut=="yawleft"then c1=c1+1;df=nil elseif ut=="straferight"then iB:updateCommandFromActionStart(axisCommandId.lateral,1.0)bA=1 elseif ut=="strafeleft"then iB:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bA=-1 elseif ut=="up"then cw.vertical(1)if ci-3<_ and cl>0 and bo then cy.landingGear()end elseif ut=="down"then cw.vertical(-1)elseif ut=="groundaltitudeup"then uu()elseif ut=="groundaltitudedown"then uu(true)elseif ut=="option1"then uC=false;if p8 and c4 then local uD=""for M=1,#d5 do uD=uD.."| Name: "..a.getPlayerName(d5[M]).." Mass: "..fO(bR.getBoardedPlayerMass(d5[M])/1000,1).."t "end;a.print("Onboard: "..uD)return end;cv.adjustAutopilotTargetIndex()elseif ut=="option2"then uC=false;if p8 and c4 then for M=1,#d5 do bR.forceDeboard(d5[M])bR.forceInterruptVRSession(d5[M])end;dl("Deboarded All Passengers")return end;cv.adjustAutopilotTargetIndex(1)elseif ut=="option3"then uC=false;if p8 and c4 then local uD=""for M=1,#d6 do uD=uD.."| ID: "..d6[M].." Mass: "..fO(bR.getDockedConstructMass(d6[M])/1000,1).."t "end;a.print("Docked Ships: "..uD)return end;if x then if w then w=false else w=true end;if cx then cx.ToggleRadarPanel()end end elseif ut=="option4"then uC=false;if p8 and c4 then for M=1,#d6 do bR.forceUndock(d6[M])end;dl("Undocked all ships")return end;c_=nil;cw.ToggleAutopilot()elseif ut=="option5"then uC=false;cw.ToggleLockPitch()elseif ut=="option6"then uC=false;if p8 and c4 then if shield then cz.ventShield()else dl("No shield found")end;return end;cw.ToggleAltitudeHold()elseif ut=="option7"then uC=false;if p8 and c4 then if shield then shield.toggle()return else dl("No shield found")return end end;E=not E;if E then dl("Collision System Enabled")else dl("Collision System Secured")end elseif ut=="option8"then uC=false;if p8 and c4 then if bn>0 and fZ~=nil then cw.routeWP()else dl("Select a saved wp on IPH to add to or remove from route")end;return end;bD=not bD;if not bD then dl("DeCoupled Mode - Ground Stabilization off")iB:deactivateGroundEngineAltitudeStabilization()fN("gsOff","GS")else dl("Coupled Mode - Ground Stabilization on")iB:activateGroundEngineAltitudeStabilization(r1)dh=true;fN("gsOn","GS")end elseif ut=="option9"then uC=false;if p8 and c4 then iB:resetCommand(axisCommandId.longitudinal)iB:resetCommand(axisCommandId.lateral)iB:resetCommand(axisCommandId.vertical)cw.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cn=gyro.isActive()==1;if cn then fN("gyOn","GA")else fN("gyOff","GA")end else dl("No gyro found")end elseif ut=="lshift"then if p8 then c4=true end elseif ut=="brake"then if b0 or p8 then cw.BrakeToggle("Manual")elseif not b2 then cw.BrakeToggle("Manual")else b2="Manual"end elseif ut=="lalt"then uC=true;p8=true;if iA()==0 and not j and g=="keyboard"then ul(1)end elseif ut=="booster"then if o then d:toggleBoosters()elseif not c8 then if not uh then d:toggleBoosters()uh=true end;c8=true else if uh then d:toggleBoosters()uh=false end;c8=false end elseif ut=="stopengines"then local function uE()if bT-us<1.5 then fN("clear","CA")cw.clearAll()end end;uE()us=bT;if iB:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p8 then if cE>0 then cE=0 else cE=W end elseif bU~=0 then iB:resetCommand(axisCommandId.longitudinal)cw.cmdThrottle(0)else cw.cmdThrottle(100)end else if iB:getTargetSpeed(axisCommandId.longitudinal)~=0 then iB:resetCommand(axisCommandId.longitudinal)else if cj then cw.cmdCruise(cE)else cw.cmdCruise(a1*3.6)end end end elseif ut=="speedup"then cw.changeSpd()elseif ut=="speeddown"then cw.changeSpd(true)elseif ut=="antigravity"and not r then if antigrav~=nil then cw.ToggleAntigrav()else dl("No antigrav found")end elseif ut=="leftmouse"then c5=true;if c4 then uB()uC=false else c4=true;bk=iC()ul(1)end end end;function um.stopControl(ut)local function uF()if not r and cT then ur=up end;if b7 or bb or bB then uq=uo end end;if ut=="forward"then b_=0 elseif ut=="backward"then b_=0 elseif ut=="left"then if c_ then if c_==2 then c_=-2 else c_=-1 end end;c0=0 elseif ut=="right"then if c_ then if c_==4 then c_=-2 else c_=-1 end end;c0=0 elseif ut=="yawright"then c1=0 elseif ut=="yawleft"then c1=0 elseif ut=="straferight"then iB:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bA=0 elseif ut=="strafeleft"then iB:updateCommandFromActionStop(axisCommandId.lateral,1.0)bA=0 elseif ut=="up"then cw.vertical(0,-1)elseif ut=="down"then cw.vertical(0,1)elseif ut=="groundaltitudeup"then uF()uC=false elseif ut=="groundaltitudedown"then uF()uC=false elseif ut=="brake"then if not b0 and not p8 then if b2 then cw.BrakeToggle()else b2=false end end elseif ut=="lalt"then if c4 then c4=false end;if iA()==0 and j then if uC then if iC()==1 then ul(0)else ul(1)end else uC=true end elseif iA()==0 and not j and g=="keyboard"then ul(0)end;p8=false end end;function um.loopControl(ut)local function uG(rh)local ri=1;if rh then ri=-1 end;if not r and cT then if bx~=nil then bx=bx+ri*ur;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end;ur=dp(ur*1.05,up,50)else bx=tR+ri*100 end elseif b7 or bb or bB then if bB then cG=cG+ri*uq;if cG<ku.noAtmosphericDensityAltitude then cG=ku.noAtmosphericDensityAltitude end else bc=bc+ri*uq end;uq=dp(uq*1.05,uo,50)else iB:updateTargetGroundAltitudeFromActionLoop(ri*1.0)end end;local function uH(rh)local ri=1;if rh then ri=-1 end;if not c4 then if t and not p8 then bU=dp(bU+ri*aG/100,-1,1)else iB:updateCommandFromActionLoop(axisCommandId.longitudinal,ri*aG)end end end;if ut=="groundaltitudeup"then if not c4 then uG()end elseif ut=="groundaltitudedown"then if not c4 then uG(true)end elseif ut=="speedup"then uH()elseif ut=="speeddown"then uH(true)end end;function um.inputTextControl(rg)local function uI(uJ,fp,gs)local function uK(fp)local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH='::pos{'..dG..','..dG..','..dG..','..dG..','..dG..'}'local dX,dY,e4,e5,e6=e7(fp,dH)if dX=="0"and dY=="0"then return vec3(dq(e4),dq(e5),dq(e6))end;e5=math.rad(e5)e4=math.rad(e4)local ku=e[dq(dX)][dq(dY)]local eY=math.cos(e4)local uL=vec3(eY*math.cos(e5),eY*math.sin(e5),math.sin(e4))return ku.center+(ku.radius+e6)*uL end;local fQ=uK(fp)return cv.AddNewLocation(uJ,fQ,gs)end;local M;local uM,ip=nil,nil;local uN="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(rg," ")uM=rg;if M~=nil and string.find(rg,"::")~=1 then uM=string.sub(rg,0,M-1)ip=string.sub(rg,M+1)end;if uM=="/help"or uM=="/commands"then for lo in string.gmatch(uN,"([^\n]+)")do a.print(lo)end;return elseif uM=="/setname"then if ip==nil or ip==""then dl("Usage: ah-setname Newname")return end;if bn>0 and fZ~=nil then cv.UpdatePosition(ip)else dl("Select a saved target to rename first")end elseif shield and uM=="/resist"then cz.setResist(ip)elseif uM=="/addlocation"or string.find(rg,"::pos")~=nil then local gs=false;local uJ="0-Temp"if ip==nil or ip==""or uM~="/addlocation"then ip=uM;gs=true end;M=string.find(ip,"::")if not gs then uJ=string.sub(ip,1,M-2)end;local fp=string.sub(ip,M)fp=fp:gsub("%s+","")uI(uJ,fp,gs)elseif uM=="/agg"then if ip==nil or ip==""then dl("Usage: /agg targetheight")return end;ip=dq(ip)if ip<1000 then ip=1000 end;bx=ip;dl("AGG Target Height set to "..ip)elseif uM=="/G"then if ip==nil or ip==""then dl("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if ip=="dump"then for dO,dA in pairs(iE())do if type(dA.get())=="boolean"then if dA.get()==true then a.print(dO.." true")else a.print(dO.." false")end elseif dA.get()==nil then a.print(dO.." nil")else a.print(dO.." "..dA.get())end end;return end;M=string.find(ip," ")local uO=string.sub(ip,0,M-1)local uP=string.sub(ip,M+1)for dO,dA in pairs(iE())do if dO==uO then local uQ=type(dA.get())if uQ=="number"then uP=dq(uP)if dO=="AtmoSpeedLimit"then cE=uP end end;dl("Variable "..uO.." changed to "..uP)if dO=="MaxGameVelocity"then uP=uP/3.6;if uP>di-0.2 then uP=di-0.2;dl("Variable "..uO.." changed to "..fO(uP*3.6,1))end end;if uQ=="boolean"then if string.lower(uP)=="true"then uP=true else uP=false end end;dA.set(uP)return end end;dl("No such global variable: "..uO)elseif uM=="/deletewp"then if bn>0 and fZ~=nil then cv.ClearCurrentPosition()else dl("Select a custom wp to delete first in IPH")end elseif uM=="/copydatabank"then if dbHud_2 then pI(true)else dl("Spare Databank required to copy databank")end elseif uM=="/iphWP"then if bn>0 then a.print(cw.showWayPoint(cb,bm,true))a.print(json.encode(bm))dl("::pos waypoint shown in lua chat in local and world format")else dl("No target selected in IPH")end elseif uM=="/createPrivate"then local uR="privatelocations = {\n"local uS=""if#dc>0 then for dO,dA in pairs(dc)do uR=uR.."{position = {x = "..dA.position.x..", y = "..dA.position.y..", z = "..dA.position.z.."},\n ".."name = '"..dA.name.."',\n planetname = '"..dA.planetname.."',\n gravity = "..dA.gravity..",\n"if dA.heading then uR=uR.."heading = {x = "..dA.heading.x..", y = "..dA.heading.y..", z = "..dA.heading.z.."},\n"end;if dA.safe then uR=uR.."safe = true},\n"else uR=uR.."safe = false},\n"end end end;uS=#dc.."-Private "if ip=="all"then for dO,dA in pairs(br)do uR=uR.."{position = {x = "..dA.position.x..", y = "..dA.position.y..", z = "..dA.position.z.."},\n ".."name = '*"..dA.name.."',\n planetname = '"..dA.planetname.."',\n gravity = "..dA.gravity..",\n"if dA.heading then uR=uR.."heading = {x = "..dA.heading.x..", y = "..dA.heading.y..", z = "..dA.heading.z.."},\n"end;if dA.safe then uR=uR.." safe = true},\n"else uR=uR.."safe = false},\n"end end;uS=uS..#br.."-Public "end;uR=uR.."}\n return privatelocations"if uk then uk.setHTML(uR)end;dl(uS.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c7=7 end end;function um.tagTick()if bE=="Off"then bE="All"elseif bE=="All"then bE="Longitude"elseif bE=="Longitude"then bE="Lateral"elseif bE=="Lateral"then bE="Vertical"else bE="Off"end;dl("Extra Engine Tags: "..bE)c.stopTimer("tagTick")end;if uT then for dO,dA in pairs(uT)do um[dO]=dA end end;return um end;local function uU(d,b,c,e,vBooster,hover,pH,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ix,uk)local a=bQ;local bR=bS;local uV=t5;local uW=uX;local uY={}local dn=string.format;local iy=json.decode;local uZ=json.encode;local pA=b.getElementMaxHitPointsById;local iz=b.getElementMassById;local iA=d.control.isRemoteControlled;local e7=string.match;local gF=a.destroyWidgetPanel;local fL=a.updateData;local fM=a.addDataToWidget;local ul=a.lockView;local iC=a.isViewLocked;local dr=math.sqrt;local dq=tonumber;local f1=math.abs;local bO=math.floor;local bP=c.getAtmosphereDensity;local eX=math.atan;local bN=a.getArkTime;local dp=utils.clamp;local iB=d.axisCommandManager;local gH=13;local iH=b.getElementIdList()local iI=0;local function ds(eF,eG)if eF==0 then return f1(eG)<1e-09 elseif eG==0 then return f1(eF)<1e-09 else return f1(eF-eG)<math.max(f1(eF),f1(eG))*dF end end;local function fO(dG,u_)local ri=10^(u_ or 0)return bO(dG*ri+0.5)/ri end;local function iD(v0,v1)for dO,dA in pairs(v1)do if type(dO)=="string"then v0[dO]=dA else v0[#v0+1]=v1[dO]end end;return v0 end;local function iE(v2)local v3={}if not v2 then iD(v3,L)iD(v3,ac)iD(v3,aE)iD(v3,a_)return v3 elseif v2=="boolean"then return L elseif v2=="handling"then return ac elseif v2=="hud"then return aE elseif v2=="physics"then return a_ end end;local function dl(sN)if not sN then return end;if c6~="empty"then if c6~=sN then c6=c6 .."\n"..sN;c7=7 end else c6=sN end end;local function pI(v4)local function v5(v6)for dO,dA in pairs(v6)do dbHud_1.setStringValue(dO,uZ(dA.get()))if v4 and dbHud_2 then dbHud_2.setStringValue(dO,uZ(dA.get()))end end end;if dbHud_1 then v5(bK)v5(iE())a.print("Saved Variables to Datacore")if v4 and dbHud_2 then dl("Databank copied.  Remove copy when ready.")end end end;local function fN(v7,v8,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v7 ..".mp3")end;local function gG(hA,hB,rg,jP,v9)return dn([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jP or"",hA,hB,v9 or"",rg)end;local function iF(ce,va)va=va or 1;local unit="m"if ce>100000 then ce=ce/200000;unit="su"elseif ce>1000 then ce=ce/1000;unit="km"end;return fO(ce,va)..unit end;local function iG(vb)local vc=0;local vd=0;local ve=0;if vb<60 then vb=bO(vb)elseif vb<3600 then vc=bO(vb/60)vb=bO(vb%60)elseif vb<86400 then vd=bO(vb/3600)vc=bO(vb%3600/60)else ve=bO(vb/86400)vd=bO(vb%86400/3600)end;if ve>365 then return">1y"elseif ve>0 then return ve.."d "..vd.."h "elseif vd>0 then return vd.."h "..vc.."m "elseif vc>0 then return vc.."m "..vb.."s"elseif vb>0 then return vb.."s"else return"0s"end end;local function vf()if radar_1 then cx=gE(b,a,c,radar_1,radar_2,warpdrive,f1,gF,dr,gG,dq,gH,fN,dl)end end;function uY.radarSetup()vf()end;function uY.onStart()local vg=false;local function vh()local function vi(vj)local vk=dbHud_1.hasKey;for dO,dA in pairs(vj)do if vk(dO)then local dJ=iy(dbHud_1.getStringValue(dO))if dJ~=nil then dA.set(dJ)vg=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vi(iE())coroutine.yield()vi(bK)else vi(bK)dl("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c7=5;vg=false end;coroutine.yield()if vg then dl("Loaded Saved Variables")elseif not f then dl("No Databank Saved Variables Found\nVariables will save to Databank on standing")c7=5 end;if#br>0 then dd=iD(dd,br)end else dl("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;b0=k;g=string.lower(g)cC=q;cE=W;if by+180<bT then bw=0 end;by=bT;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then dl("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c7=7 end;if antigrav and not r then if bx==nil then bx=cl end;antigrav.setTargetAltitude(bx)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#dc>0 then dd=iD(dd,dc)end end;lt="Proceeding to Waypoint"if not a1 or a1<0 then a1=bR.getMaxSpeed()-0.1 end end;local function vl()local function vm(vn,vo)if vn>vo then vo=vn end;local vp,vq=0,0;if a7>0 then vp=a7*0.05 end;if a8>0 then vq=a8*0.05 end;vo=vo*(1-(vp+vq))return vo end;local vr=b.getElementNameById;local vs=au~=0 and av~=0;local vt=_G["atmofueltank_size"]local vu=_G["spacefueltank_size"]local vv=_G["rocketfueltank_size"]for dO in pairs(iH)do local type=b.getElementDisplayNameById(iH[dO])if e7(type,'^.*Atmospheric Engine$')then if e7(tostring(b.getElementTagsById(iH[dO])),'^.*vertical.*$')and b.getElementForwardById(iH[dO])[3]>0 then cS=true end end;if e7(type,'^.*Space Engine$')then cJ=true;if e7(tostring(b.getElementTagsById(iH[dO])),'^.*vertical.*$')then local vw=b.getElementForwardById(iH[dO])if vw[3]<0 then vx=true else cI=true end end end;if type=="Landing Gear"then bZ=true end;if type=="Dynamic Core Unit"then local pC=pA(iH[dO])if pC>10000 then gH=110 elseif pC>1000 then gH=55 elseif pC>150 then gH=27 end end;iI=iI+pA(iH[dO])if vs and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pC=pA(iH[dO])local f6=iz(iH[dO])local vn=0;local jH=bN()if type=="Atmospheric Fuel Tank"then local vo=400;local vy=35.03;if pC>10000 then vo=51200;vy=5480 elseif pC>1300 then vo=6400;vy=988.67 elseif pC>150 then vo=1600;vy=182.67 end;vn=f6-vy;if a4>0 then vo=vo+vo*a4*0.2 end;vo=vm(vn,vo)local gr=vr(iH[dO])local jF=0;for jG=1,vt do if gr==iy(c["atmofueltank_"..jG].getWidgetData()).name then jF=jG;break end end;local vz={iH[dO],string.sub(gr,1,12),vo,vy,vn,jH,jF}co[#co+1]=vz end;if type=="Rocket Fuel Tank"then local vo=320;local vy=173.42;if pC>65000 then vo=40000;vy=25740 elseif pC>6000 then vo=5120;vy=4720 elseif pC>700 then vo=640;vy=886.72 end;vn=f6-vy;if a6>0 then vo=vo+vo*a6*0.1 end;vo=vm(vn,vo)local gr=vr(iH[dO])local jF=0;for jG=1,vv do if gr==iy(c["rocketfueltank_"..jG].getWidgetData()).name then jF=jG;break end end;local vz={iH[dO],string.sub(gr,1,12),vo,vy,vn,jH,jF}cq[#cq+1]=vz end;if type=="Space Fuel Tank"then local vo=600;local vy=35.03;if pC>10000 then vo=76800;vy=5480 elseif pC>1300 then vo=9600;vy=988.67 elseif pC>150 then vo=2400;vy=182.67 end;vn=f6-vy;if a5>0 then vo=vo+vo*a5*0.2 end;vo=vm(vn,vo)local gr=vr(iH[dO])local jF=0;for jG=1,vu do if gr==iy(c["spacefueltank_"..jG].getWidgetData()).name then jF=jG;break end end;local vz={iH[dO],string.sub(gr,1,12),vo,vy,vn,jH,jF}cp[#cp+1]=vz end end end;if not cS then bb,b1=false,false end end;local function vA()if gyro~=nil then cn=gyro.isActive()==1 end;if not bD then iB:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ul(1)else ul(0)end;if door and(cj or not cj and cl<10000)then for dT,dA in pairs(door)do dA.toggle()end end;if switch then for dT,dA in pairs(switch)do dA.toggle()end end;if forcefield and(cj or not cj==0 and cl<10000)then for dT,dA in pairs(forcefield)do dA.toggle()end end;if antigrav then cT=antigrav.isActive()==1;if cT and not r then antigrav.showWidget()end end;if iA()==1 and l then uV.freeze(1)else uV.freeze(0)end;if bZ then if ci~=-1 and not cT then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bo=d.control.isAnyLandingGearDeployed()==1 or ci~=-1 and ci-3<_;if ci~=-1 or not cj and cM:len()<30 then b2="Startup"else b2=false end;iB:setTargetGroundAltitude(_)po=cj end;local function vB()local vC={}local function vD()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vE={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vF,vG in pairs(e)do e[vF][0]=vD()e[vF][0].systemId=vF;vC[vF]={}for vH,ku in pairs(e[vF])do ku.gravity=ku.gravity/9.8;ku.center=vec3(ku.center)ku.name=ku.name[1]ku.noAtmosphericDensityAltitude=ku.atmosphereThickness;ku.spaceEngineMinAltitude=vE[ku.id]or 0.5353125*ku.atmosphereThickness;ku.planetarySystemId=vF;ku.bodyId=ku.id;vC[vF][vH]=ku;if mj==nil or ku.center.x<mj then mj=ku.center.x end;if mi==nil or ku.center.x>mi then mi=ku.center.x end;if mm==nil or ku.center.y<mm then mm=ku.center.y end;if ml==nil or ku.center.y>ml then ml=ku.center.y end;if ku.center and ku.name~="Space"then d7[#d7+1]=ku end end end;eh=dm(d,b,c,a,dn,dp,dq,dr,ds)cr=eh(vC)fR=cr[0]cs=f0(d,b,c,a,dr,f1)ct=fl(d,b,c,a,dn,dp,dq,dr,ds)cv=fK(d,b,c,a,dbHud_1,e,fL,fM,bO,dq,dr,fN,fO,dl)ku=cr[0]:closestBody(bR.getWorldPosition())end;vI=false;vJ=coroutine.create(function()iB:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vh()coroutine.yield()vl()coroutine.yield()cw=pG(d,b,c,e,vBooster,hover,pH,antigrav,dbHud_1,f1,bO,bP,iA,eX,bN,dp,iB,fL,iC,dr,fO,fN,iD,ds,iF,iG,pI,iy,dl)vA()coroutine.yield()vB()vf()if iw then cu=iw(d,b,c,a,e,antigrav,hover,shield,warpdrive,ix,f1,bO,dn,iy,bP,iz,iA,eX,bN,dp,iB,fM,fL,gF,iC,dr,fO,gG,fN,iD,iE,iF,iG,iH,iI,dl)end;if cu then cu.ButtonSetup()end;cy=uj(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uk,iA,iB,iC,ul,gF,fO,e7,dq,dp,fN,iE,pI,dl)if shield then cz=ie(shield,e7,bO,dl)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uk then uk.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bR.setDockingMode(ab)if shield then c.setTimer("shieldTick",0.0166667)end;if vK then vL.ExtraOnStart()end;fN("start","SU")local function vM()if bI[1]==0 then cw.cmdThrottle(bI[2])else if ck>0 then cE=bI[2]cw.cmdThrottle(1)end end end;ll=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if ll then if ci>-1 and cO<1 and ci-3<_ then c.exit()else if J then vM()else if ck==0 then b2="ECU Braking"elseif ci==-1 then cy.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bI[3]+3>bN()then vM()end;d6=bR.getDockedConstructs()d5=bR.getPlayersOnBoard()local vN;vN=#d5>1 and"Passengers: "..#d5-1 .." "or""vN=vN..(#d6>0 and"Ships: "..#d6 or"")if vN~=""then dl("NOTICE: Docked "..vN)end end)coroutine.resume(vJ)end;function uY.onUpdate()if vI then d:update()if cj and t and cU then if cU and bY then cw.cmdThrottle(0)bY=false elseif not cU and not bY then bU=0;bY=true end end;if da then iB:setThrottleCommand(axisCommandId.longitudinal,da)da=nil end;if not cA and pa~=vO then a.setScreen(pa)end;vO=pa;if ll and not J and ck>0 and ci==-1 then cy.landingGear()end;if ll and ci>-1 and cO<1 and ci-3<_ then c.exit()end;if vK then vL.ExtraOnUpdate()end else local i4=coroutine.status(vJ)if i4=="suspended"then local dP,i5=coroutine.resume(vJ)if i5 then a.print("ERROR STARTUP: "..i5)end elseif i4=="dead"then vI=true end end end;function uY.onFlush()if vI then cw.onFlush()if vK then vL.ExtraOnFlush()end end end;function uY.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ck>0 or ck==0 and cl<10000)then for dT,dA in pairs(door)do dA.toggle()end end;if switch then for dT,dA in pairs(switch)do dA.toggle()end end;if forcefield and(ck>0 or ck==0 and cl<10000)then for dT,dA in pairs(forcefield)do dA.toggle()end end;w=d9;local vP=0;if ll then vP=bN()end;if iB:getAxisCommandType(0)==0 then bI={0,bU,vP}else bI={1,iB:getTargetSpeed(axisCommandId.longitudinal),vP}end;pI()if nV then nV.activate()end;if z then cw.showWayPoint(ku,cR)end;if cu then a.print(cu.FuelUsed("atmofueltank")..", "..cu.FuelUsed("spacefueltank")..", "..cu.FuelUsed("rocketfueltank"))end;if vK then vL.ExtraOnStop()end;fN("stop","SU")end;function uY.controlStart(ut)if vI then cy.startControl(ut)end end;function uY.controlStop(ut)if vI then cy.stopControl(ut)end end;function uY.controlLoop(ut)if vI then cy.loopControl(ut)end end;function uY.controlInput(rg)if vI then cy.inputTextControl(rg)end end;function uY.radarEnter(dY)if cx then cx.onEnter(dY)end end;function uY.radarLeave(dY)if cx then cx.onLeave(dY)end end;function uY.onTick(vQ)if vQ=="tenthSecond"then if cw then cw.TenthTick()end;if cu then cu.TenthTick()end elseif vQ=="oneSecond"then if cu then cu.OneSecondTick()end elseif vQ=="msgTick"then if cu then cu.MsgTick()end elseif vQ=="animateTick"then if cu then cu.AnimateTick()end elseif vQ=="hudTick"then if cu then cu.hudtick()end elseif vQ=="apTick"then if cw then cw.APTick()end elseif vQ=="shieldTick"then cz.shieldTick()elseif vQ=="tagTick"then cy.tagTick()elseif vQ=="contact"then cx.ContactTick()end end;if vK then for dO,dA in pairs(vK)do uY[dO]=dA end end;return uY end;function script.onStart()vL.onStart()end;function script.onOnStop()vL.onStop()end;function script.onTick(vQ)vL.onTick(vQ)end;function script.onOnFlush()vL.onFlush()end;function script.onOnUpdate()vL.onUpdate()end;function script.onActionStart(ut)vL.controlStart(ut)end;function script.onActionStop(ut)vL.controlStop(ut)end;function script.onActionLoop(ut)vL.controlLoop(ut)end;function script.onInputText(rg)vL.controlInput(rg)end;function script.onEnter(dY)vL.radarEnter(dY)end;function script.onLeave(dY)vL.radarLeave(dY)end;bM(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vL=uU(d,core,unit,e,vBooster,hover,pH,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ix,uk)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
