name: ArchHud - Archaegeo v1.5202 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5202;useTheseSettings=false;userControlScheme="virtual joystick"soundFolder="archHUD"freeLookToggle=true;BrakeToggleDefault=true;RemoteFreeze=false;RemoteHud=true;brightHud=false;VanillaRockets=false;InvertMouse=false;autoRollPreference=false;ExternalAGG=false;UseSatNav=false;ShouldCheckDamage=true;CalculateBrakeLandingSpeed=false;AtmoSpeedAssist=true;ForceAlignment=false;DisplayDeadZone=true;showHud=true;hideHudOnToggleWidgets=true;ShiftShowsRemoteButtons=true;SetWaypointOnExit=false;AlwaysVSpd=false;BarFuelDisplay=true;voices=true;alerts=true;CollisionSystem=true;AutoShieldToggle=true;PreventPvP=true;DisplayOdometer=true;YawStallAngle=35;PitchStallAngle=35;brakeLandingRate=30;MaxPitch=30;ReEntryPitch=-30;LockPitchTarget=0;AutopilotSpaceDistance=5000;TargetOrbitRadius=1.2;LowOrbitHeight=2000;AtmoSpeedLimit=1050;SpaceSpeedLimit=30000;AutoTakeoffAltitude=1000;TargetHoverHeight=50;LandingGearGroundHeight=0;ReEntryHeight=100000;MaxGameVelocity=8333.00;AutopilotInterplanetaryThrottle=1.0;warmup=32;fuelTankHandlingAtmo=0;fuelTankHandlingSpace=0;fuelTankHandlingRocket=0;ContainerOptimization=0;FuelTankOptimization=0;ResolutionX=1920;ResolutionY=1080;circleRad=400;SafeR=130;SafeG=224;SafeB=255;PvPR=255;PvPG=0;PvPB=0;centerX=960;centerY=540;throtPosX=1300;throtPosY=540;vSpdMeterX=1525;vSpdMeterY=325;altMeterX=550;altMeterY=540;fuelX=30;fuelY=700;shieldX=1750;shieldY=250;DeadZone=50;OrbitMapSize=250;OrbitMapX=0;OrbitMapY=25;soundVolume=100;speedChangeLarge=5;speedChangeSmall=1;MouseXSensitivity=0.003;MouseYSensitivity=0.003;autoRollFactor=2;rollSpeedFactor=1.5;autoRollRollThreshold=180;minRollVelocity=150;TrajectoryAlignmentStrength=0.002;torqueFactor=2;pitchSpeedFactor=0.8;yawSpeedFactor=1;brakeSpeedFactor=3;brakeFlatFactor=1;DampingMultiplier=40;apTickRate=0.0166667;hudTickRate=0.0666667;ExtraLongitudeTags="none"ExtraLateralTags="none"ExtraVerticalTags="none"BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=""local aC=true;local aD=ResolutionX;local aE=ResolutionY;local aF={}local aG={}local aH={}local aI=0;local aJ=false;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=false;local aU=false;local aV=autoRollPreference;local aW=LandingGearGroundHeight;local aX=false;local aY=0;local aZ=AtmoSpeedLimit;local a_=0;local b0=nil;local b1={VectorToTarget=false}local b2=0;local b3=false;local b4=false;local b5=false;local b6=false;local b7=vec3(core.getConstructWorldOrientationUp())local b8=vec3(core.getConstructWorldOrientationForward())local b9=vec3(core.getConstructWorldOrientationRight())local ba=vec3(core.getVelocity())local bb=vec3(core.getWorldVelocity())local bc=vec3(bb):len()local bd=vec3(core.getWorldVertical())local be=-bd:dot(bb)local bf=vec3(core.getConstructWorldPos())local bg=false;local bh=false;local bi=nil;local bj=true;local bk=0;local bl=0;local bm={}local bn=false;local bo=50000;local bp=nil;local bq={}local br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bs=false;local bt=nil;local bu=false;local bv=0;local bw={}local bx=nil;local by=nil;local bz={}local bA=90;local bB=showHud;function p(bC)system.print(E..": "..bC)end;local function bD(bE)local D=1;if bE then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bF=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bF<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then aZ=r(aZ+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bv=bv+1*D*-1;if bv>#bm then bv=1 end;if bv<1 then bv=#bm end else if not bE then D=1 else D=nil end;aQ.adjustAutopilotTargetIndex(D)end end end;local function bG(bH,bI,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)end end;local function bJ(bK,bL)for i=1,#bL do bK[#bK+1]=bL[i]end;return bK end;local function bM(bN)local bO={}local bP={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP","DisplayOdometer"}local bQ={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bR={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bS={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bN then bJ(bO,bP)bJ(bO,bQ)bJ(bO,bR)bJ(bO,bS)return bO elseif bN=="boolean"then return bP elseif bN=="handling"then return bQ elseif bN=="hud"then return bR elseif bN=="physics"then return bS end end;local function bT(bU,bV,bW,bX,bY)if bX==nil then bX=""end;if bY==nil then bY=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bX,bU,bV,bY,bW)end;local function bZ(b_,c0)if b_==0 then return d(c0)<1e-09 end;if c0==0 then return d(b_)<1e-09 end;return d(b_-c0)<math.max(d(b_),d(c0))*epsilon end;local function c1(aj,c2)local c3=aj>100000;if c2==nil then c2=1 end;if c3 then return A(aj/1000/200,c2).."SU"elseif aj<1000 then return A(aj,c2).."M"else return A(aj/1000,c2).."KM"end end;local function c4(c5)local c6=0;local c7=0;local c8=0;if c5<60 then c5=e(c5)elseif c5<3600 then c6=e(c5/60)c5=e(c5%60)elseif c5<86400 then c7=e(c5/3600)c6=e(c5%3600/60)else c8=e(c5/86400)c7=e(c5%86400/3600)end;if c8>0 then return c8 .."d "..c7 .."h "elseif c7>0 then return c7 .."h "..c6 .."m "elseif c6>0 then return c6 .."m "..c5 .."s"elseif c5>0 then return c5 .."s"else return"0s"end end;local function c9(ca)local function cb(cc)for cd,ce in pairs(cc)do dbHud_1.setStringValue(ce,h(_G[ce]))if ca and dbHud_2 then dbHud_2.setStringValue(ce,h(_G[ce]))end end end;if dbHud_1 then cb(c)cb(bM())system.print("Saved Variables to Datacore")if ca and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cf()local function cg(ch)return type(ch)=='number'end;local function ci(ch)return type(z(ch))=='number'end;local function cj(ck)return type(ck)=='table'end;local function cl(cm)return type(cm)=='string'end;local function cn(ce)return cj(ce)and cg(ce.x and ce.y and ce.z)end;local function co(cp)return cj(cp)and cg(cp.latitude and cp.longitude and cp.altitude and cp.id and cp.systemId)end;local cq=math.pi/180;local cr=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function ct(ch)local cu=string.gsub(string.reverse(f('%.4f',ch)),'^0*%.?','')return cu==''and'0'or string.reverse(cu)end;local function cv(cw)if cn(cw)then return f('{x=%.3f,y=%.3f,z=%.3f}',cw.x,cw.y,cw.z)end;if cj(cw)and not getmetatable(cw)then local cx={}local cy=next(cw)if type(cy)=='nil'or cy==1 then cx=cw else for cd,ce in pairs(cw)do local cz=cv(ce)if type(cd)=='number'then table.insert(cx,f('[%s]=%s',cd,cz))else table.insert(cx,f('%s=%s',cd,cz))end end end;return f('{%s}',table.concat(cx,','))end;if cl(cw)then return f("'%s'",cw:gsub("'",[[\']]))end;return tostring(cw)end;local cA={}cA.__index=cA;cA.__tostring=function(cw,cB)local cC={}for cd in pairs(cw)do table.insert(cC,cd)end;table.sort(cC)local cx={}for _,cd in ipairs(cC)do local cz=cv(cw[cd])if type(cd)=='number'then table.insert(cx,f('[%s]=%s',cd,cz))else table.insert(cx,f('%s=%s',cd,cz))end end;if cB then return f('%s%s',cB,table.concat(cx,',\n'..cB))end;return f('{%s}',table.concat(cx,','))end;cA.__eq=function(cD,cE)return cD.systemId==cE.systemId and cD.id==cE.id and bZ(cD.radius,cE.radius)and bZ(cD.center.x,cE.center.x)and bZ(cD.center.y,cE.center.y)and bZ(cD.center.z,cE.center.z)and bZ(cD.GM,cE.GM)end;local function cF(cG,cH,cI,cJ,cK)assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(cI),'Argument 3 (radius) must be a number:'..type(cI))assert(cj(cJ),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cJ))assert(ci(cK),'Argument 5 (GM) must be a number:'..type(cK))return setmetatable({systemId=z(cG),id=z(cH),radius=z(cI),center=vec3(cJ),GM=z(cK)},cA)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,ct(p.latitude*cr),ct(p.longitude*cr),ct(p.altitude))end;MapPosition.__eq=function(cD,cE)return cD.id==cE.id and cD.systemId==cE.systemId and bZ(cD.latitude,cE.latitude)and bZ(cD.altitude,cE.altitude)and(bZ(cD.longitude,cE.longitude)or bZ(cD.latitude,math.pi/2)or bZ(cD.latitude,-math.pi/2))end;local function cL(cM,cH,cN,cO,cP)local cG=cM;if cl(cM)and not cO and not cP and not cH and not cN then cG,cH,cN,cO,cP=o(cM,cs)assert(cG,'Argument 1 (position string) is malformed.')else assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(cN),'Argument 3 (latitude) must be in degrees:'..type(cN))assert(ci(cO),'Argument 4 (longitude) must be in degrees:'..type(cO))assert(ci(cP),'Argument 5 (altitude) must be in meters:'..type(cP))end;cG=z(cG)cH=z(cH)cN=z(cN)cO=z(cO)cP=z(cP)if cH==0 then return setmetatable({latitude=cN,longitude=cO,altitude=cP,id=cH,systemId=cG},MapPosition)end;return setmetatable({latitude=cq*r(cN,-90,90),longitude=cq*(cO%360),altitude=cP,id=cH,systemId=cG},MapPosition)end;local cQ={}cQ.__index=cQ;cQ.__tostring=function(cw,cB)local cR=cB and cB..'  'local cS={}local cC={}for cd in pairs(cw)do table.insert(cC,cd)end;table.sort(cC)for _,cT in ipairs(cC)do bdy=cw[cT]local cU=cA.__tostring(bdy,cR)if cB then table.insert(cS,f('[%s]={\n%s\n%s}',cT,cU,cB))else table.insert(cS,f('  [%s]=%s',cT,cU))end end;if cB then return f('\n%s%s%s',cB,table.concat(cS,',\n'..cB),cB)end;return f('{\n%s\n}',table.concat(cS,',\n'))end;local function cV(cW)local b={}local pid;for _,ce in pairs(cW)do local cH=ce.planetarySystemId;if type(cH)~='number'then error('Invalid planetary system ID: '..tostring(cH))elseif pid and cH~=pid then error('Mistringmatch planetary system IDs: '..cH..' and '..pid)end;local cX=ce.bodyId;if type(cX)~='number'then error('Invalid body ID: '..tostring(cX))elseif b[cX]then error('Duplicate body ID: '..tostring(cX))end;setmetatable(ce.center,getmetatable(vec3.unit_x))b[cX]=setmetatable(ce,cA)pid=cH end;return setmetatable(b,cQ)end;aK={}local function cY(cW)return setmetatable({galaxyAtlas=cW or{}},aK)end;aK.__index=function(ck,i)if type(i)=='number'then local system=ck.galaxyAtlas[i]return cV(system)end;return rawget(aK,i)end;aK.__pairs=function(cw)return function(ck,cd)local cZ,nv=next(ck,cd)return cZ,nv and cV(nv)end,cw.galaxyAtlas,nil end;aK.__tostring=function(cw)local c_={}for _,d0 in pairs(cw or{})do local d1=d0:getPlanetarySystemId()local d2=cQ.__tostring(d0,'    ')table.insert(c_,f('  [%s]={%s\n  }',d1,d2))end;return f('{\n%s\n}\n',table.concat(c_,',\n'))end;aK.BodyParameters=cF;aK.MapPosition=cL;aK.PlanetarySystem=cV;function aK.createBodyParameters(cG,cH,d3,d4,d5,d6,d7)assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(d3),'Argument 3 (surfaceArea) must be a number:'..type(d3))assert(cj(d4),'Argument 4 (aPosition) must be an array or vec3:'..type(d4))assert(cj(d5),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(d5))assert(ci(d6),'Argument 6 (altitude) must be in meters:'..type(d6))assert(ci(d7),'Argument 7 (gravityAtPosition) must be number:'..type(d7))local cI=y(d3/4/math.pi)local aj=cI+d6;local d8=vec3(d4)+aj*vec3(d5)local cK=d7*aj*aj;return cF(cG,cH,cI,d8,cK)end;aK.isMapPosition=co;function aK:getPlanetarySystem(cM)if i==nil then i=0 end;if nv==nil then nv=0 end;local cG=cM;if co(cM)then cG=cM.systemId end;if type(cG)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=cQ then system=cV(system)end;return system end end end;function cQ:sizeCalculator(d9)return 1.05*d9.radius end;function cQ:castIntersections(da,db,dc,dd,de,df)local dg={}if de then for _,d9 in pairs(de)do table.insert(dg,d9)end else dg=bz end;if not df then table.sort(dg,function(dh,di)local b_=dh.center;local c0=di.center;return(b_.x-da.x)^2+(b_.y-da.y)^2+(b_.z-da.z)^2<(c0.x-da.x)^2+(c0.y-da.y)^2+(c0.z-da.z)^2 end)end;local dj=db:normalize()for _,d9 in ipairs(dg)do local dk=d9.center-da;local cI=self:sizeCalculator(d9)local dl=dk:dot(dj)local dm=dl^2-(dk:len2()-cI^2)if dm>=0 then local dn=y(dm)local dp=dl+dn;local dq=dl-dn;if dq>0 then return d9,dp,dq elseif dp>0 then return d9,dp,nil end end end;return nil,nil,nil end;function cQ:closestBody(dr)assert(type(dr)=='table','Invalid coordinates.')local ds,d9;local dt=vec3(dr)for _,du in pairs(self)do local dv=(du.center-dt):len2()if(not d9 or dv<ds)and du.name~="Space"then d9=du;ds=dv end end;return d9 end;function cQ:convertToBodyIdAndWorldCoordinates(cM)local dw=cM;if cl(cM)then dw=cL(cM)end;if dw.id==0 then return 0,vec3(dw.latitude,dw.longitude,dw.altitude)end;local du=self:getBodyParameters(dw)if du then return dw.id,du:convertToWorldCoordinates(dw)end end;function cQ:getBodyParameters(cM)local cH=cM;if co(cM)then cH=cM.id end;assert(ci(cH),'Argument 1 (id) must be a number:'..type(cH))return self[cH]end;function cQ:getPlanetarySystemId()local _,ce=next(self)return ce and ce.systemId end;function cA:convertToMapPosition(cJ)assert(cj(cJ),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cJ))local dx=vec3(cJ)if self.id==0 then return setmetatable({latitude=dx.x,longitude=dx.y,altitude=dx.z,id=0,systemId=self.systemId},MapPosition)end;local dy=dx-self.center;local aj=dy:len()local cP=aj-self.radius;local cN=0;local cO=0;if not bZ(aj,0)then local dz=n(dy.y,dy.x)cO=dz>=0 and dz or 2*math.pi+dz;cN=math.pi/2-math.acos(dy.z/aj)end;return setmetatable({latitude=cN,longitude=cO,altitude=cP,id=self.id,systemId=self.systemId},MapPosition)end;function cA:convertToWorldCoordinates(cM)local dw=cl(cM)and cL(cM)or cM;if dw.id==0 then return vec3(dw.latitude,dw.longitude,dw.altitude)end;assert(co(dw),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dw.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dw.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dA=math.cos(dw.latitude)return self.center+(self.radius+dw.altitude)*vec3(dA*math.cos(dw.longitude),dA*math.sin(dw.longitude),math.sin(dw.latitude))end;function cA:getAltitude(cJ)return(vec3(cJ)-self.center):len()-self.radius end;function cA:getDistance(cJ)return(vec3(cJ)-self.center):len()end;function cA:getGravity(cJ)local dB=self.center-vec3(cJ)local dC=dB:len2()return self.GM/dC*dB/y(dC)end;return setmetatable(aK,{__call=function(_,...)return cY(...)end})end;local function dD()local aM={}local dE=30000000/3600;local dF=dE*dE;local dG=100;function aM.computeAccelerationTime(dH,dI,dJ)local dK=dE*math.asin(dH/dE)return(dE*math.asin(dJ/dE)-dK)/dI end;function aM.computeDistanceAndTime(dH,dJ,dL,dM,dN,dO)dN=dN or 0;dO=dO or 0;local dP=dH<=dJ;local dQ=dM*(dP and 1 or-1)/dL;local dR=-dO/dL;local dS=dQ+dR;if dP and dS<=0 or not dP and dS>=0 then return-1,-1 end;local dT,dU=0,0;if dQ~=0 and dN>0 then local dK=math.asin(dH/dE)local dV=math.pi*(dQ/2+dR)local dW=dQ*dN;local dX=dE*math.pi;local ce=function(ck)local dY=(dV*ck-dW*math.sin(math.pi*ck/2/dN)+dX*dK)/dX;local dZ=math.tan(dY)return dE*dZ/y(dZ*dZ+1)end;local d_=dP and function(cm)return cm>=dJ end or function(cm)return cm<=dJ end;dU=2*dN;if d_(ce(dU))then local e0=0;while d(dU-e0)>0.5 do local ck=(dU+e0)/2;if d_(ce(ck))then dU=ck else e0=ck end end end;local e1=dH;local e2=dU/dG;for e3=1,dG do local e4=ce(e3*e2)dT=dT+(e4+e1)*e2/2;e1=e4 end;if dU<2*dN then return dT,dU end;dH=e1 end;local dK=dE*math.asin(dH/dE)local E=(dE*math.asin(dJ/dE)-dK)/dS;local e5=dF*math.cos(dK/dE)/dS;local aj=e5-dF*math.cos((dS*E+dK)/dE)/dS;return aj+dT,E+dU end;function aM.computeTravelTime(dH,dI,aj)if aj==0 then return 0 end;if dI>0 then local dK=dE*math.asin(dH/dE)local e5=dF*math.cos(dK/dE)/dI;return(dE*math.acos(dI*(e5-aj)/dF)-dK)/dI end;if dH==0 then return-1 end;assert(dH>0,'Acceleration and initial speed are both zero.')return aj/dH end;return aM end;local function e6()local vec3=require('cpml.vec3')local cf=cf()local function cl(cm)return type(cm)=='string'end;local function cj(ck)return type(ck)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cP)assert(self.body)local aj=cP+self.body.radius;if not bZ(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cM,e7)assert(self.body)assert(cj(cM)or cl(cM))assert(cj(e7))local e8=(cl(cM)or cf.isMapPosition(cM))and self.body:convertToWorldCoordinates(cM)or vec3(cM)local ce=vec3(e7)local e9=e8-self.body.center;local ea=ce:len2()local eb=e9:len()local ec=self.body.GM;local ed=((ea-ec/eb)*e9-e9:dot(ce)*ce)/ec;local b_=ec/(2*ec/eb-ea)local ee=ed:len()local dj=ed:normalize()local ef=b_*(1-ee)local eg=b_*(1+ee)local eh=ef*dj+self.body.center;local ei=ee<=1 and-eg*dj+self.body.center or nil;local ej=y(b_*ec*(1-ee*ee))local ek=ei and 2*math.pi*y(b_^3/ec)local el=math.acos(ed:dot(e9)/(ee*eb))if e9:dot(ce)<0 then el=-(el-2*math.pi)end;local em=math.acos((math.cos(el)+ee)/(1+ee*math.cos(el)))local en=em;if en<0 then en=en+2*math.pi end;local eo=en-ee*math.sin(en)local ep=0;local eq=0;local er=0;if ek~=nil then ep=eo/(2*math.pi/ek)eq=ek-ep;er=eq+ek/2;if el-math.pi>0 then eq=ep;er=eq+ek/2 end;if er>ek then er=er-ek end end;return{periapsis={position=eh,speed=ej/ef,circularOrbitSpeed=y(ec/ef),altitude=ef-self.body.radius},apoapsis=ei and{position=ei,speed=ej/eg,circularOrbitSpeed=y(ec/eg),altitude=eg-self.body.radius},currentVelocity=ce,currentPosition=e8,eccentricity=ee,period=ek,eccentricAnomaly=em,meanAnomaly=eo,timeToPeriapsis=eq,timeToApoapsis=er,trueAnomaly=el}end;local function es(et)local du=cf.BodyParameters(et.systemId,et.id,et.radius,et.center,et.GM)return setmetatable({body=du},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return es(...)end})end;local function eu()local ev={}local ew={}local ex={XS=13,S=27,M=55,L=110,XL=221}local ey={}local ez;local eA;local eB;local eC;local eD;local eE={}local eF="Atmo"local eG;local function eH()local function eI(eJ,eK,eL,eM,eN,eO,eP,eQ)eK,eM,eO,eQ=vec3(eK),vec3(eM),vec3(eO),vec3(eQ)local eR,eS,eT=eJ*eJ,eL*eL,eN*eN;local ea=eM-eK;local eU=ea:normalize()local eV=ea:len()local eW=eO-eK;local eX=(eW-eW:project_on(eU)):normalize()local eY,eZ=eW:dot(eU),eW:dot(eX)local e_=eY*eY+eZ*eZ;local f0=eU:cross(eX)local bU=(eR-eS+eV*eV)/(2*eV)local bV=(eR-eT+e_-2*eY*bU)/(2*eZ)local cp=eR-bU^2-bV^2;local f1=y(cp)local f2=eK+eU*bU+eX*bV+f0*f1;local f3=eK+eU*bU+eX*bV-f0*f1;if d((eQ-f2):len()-eP)<d((eQ-f3):len()-eP)then return f2 else return f3 end end;local function f4()local function f5()local f6=core.getConstructWorldOrientationRight()local ea=core.getConstructWorldOrientationForward()local eW=core.getConstructWorldOrientationUp()local f7=library.systemResolution3(f6,ea,eW,{1,0,0})local f8=library.systemResolution3(f6,ea,eW,{0,1,0})local f9=library.systemResolution3(f6,ea,eW,{0,0,1})return function(fa)return library.systemResolution3(f7,f8,f9,fa)end end;local fb=f5()local fc=core.getConstructWorldPos()local e8=core.getElementPositionById(1)local fd={e8[1],e8[2],e8[3]}local fe=fb(fd)local ff={fc[1]-fe[1],fc[2]-fe[2],fc[3]-fe[3]}return ff end;local function fg(fh,eb,fi)local fj=fh.pts;local fk=#fj;local fl=fh.ref;if fk>3 then local fm,fn,fo,fp=fj[fk],fj[fk-1],fj[fk-2],fj[fk-3]fh.ref=fi;local e8=eI(fm[1],fm[2],fn[1],fn[2],fo[1],fo[2],fp[1],fp[2])local bU,bV,f1=e8.x,e8.y,e8.z;if bU==bU and bV==bV and f1==f1 then bU=bU+fl[1]bV=bV+fl[2]f1=f1+fl[3]local fq=vec3(bU,bV,f1)if not fh.lastPos then fh.center=fq elseif(fh.lastPos-fq):len()<2 then fh.center=fq;fh.skipCalc=true end;fh.lastPos=fq end;fh.pts={}else local fr={fi[1]-fl[1],fi[2]-fl[2],fi[3]-fl[3]}fj[fk+1]={eb,fr}end end;if radar_1 or radar_2 then aS.assignRadar()end;if eE[1]then ez=#eE[1].getConstructIds()local fs=eE[1].getData()local ft=fs:gmatch('{"constructId[^}]*}[^}]*}')if ez>0 then local fi=f4()local fu,fv=0,0;eD,eC=0,0;for ce in ft do local cH,aj,fw=ce:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fx=ex[fw]aj=z(aj)if eE[1].hasMatchingTransponder(cH)==1 then table.insert(ew,cH)end;local fy=eE[1].getConstructType(cH)if CollisionSystem then if fx>27 or fy=="static"or fy=="space"then eD=eD+1;local fz=eE[1].getConstructName(cH)local fh=bq[cH]if fh==nil then fx=fx+G;bq[cH]={pts={},ref=fi,name=fz,i=0,radius=fx,skipCalc=false}fh=bq[cH]end;if not fh.skipCalc then fg(fh,aj,fi)fv=fv+1 end;if fh.center then table.insert(ey,fh)end end;fu=fu+1;if br and fu>700 or fv>70 or(not br and fu>300 or fv>30)then coroutine.yield()fu,fv=0,0 end end end;eC=#ey;if eC>0 and bc>20 then local d9,fA,fB,fC;local fD=0;local fE=aL:getPlanetarySystem(0)fC=bb:normalize()while fD<eC do coroutine.yield()local fF={table.unpack(ey,fD,math.min(fD+75,eC))}d9,fA,fB=fE:castIntersections(bf,fC,nil,nil,fF,true)if d9 and fB then bt={d9,fA,fB}break end;fD=fD+75 end;if not d9 then bt=nil end else bt=nil end;ey={}eA=fs:find('identifiedConstructs":%[%]')else eB=fs:find('worksInEnvironment":false')end end end;local function fG()if eE[1]then eF="Atmo"if eE[1].getData():find('worksInAtmosphere":false')then eF="Space"end end end;function ev.pickType()fG()end;function ev.assignRadar()if radar_1 and eE[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then eE[1]=radar_2 end;if eE[1]==radar_2 then fG()end elseif radar_2 and eE[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then eE[1]=radar_1 end;if eE[1]==radar_1 then fG()end end end;function ev.UpdateRadar()local fH=coroutine.status(eG)if fH=="suspended"then local cz,fI=coroutine.resume(eG)if fI then system.print("ERROR UPDATE RADAR: "..fI)end elseif fH=="dead"then eG=coroutine.create(eH)local cz,fI=coroutine.resume(eG)end end;function ev.GetRadarHud(fJ,fK,fL,fM)local fN=ew;local fO,bC;ew={}local B=eC or 0;if ez>0 then if CollisionSystem then bC=B.."/"..eD.." Plotted : "..ez-eD.." Ignored"else bC="Radar Contacts: "..ez end;fO=bT(fL,fM,bC,"pbright txtbig txtmid")if#ew>0 then fO=fO..bT(fJ,fK,"Friendlies In Range","pbright txtbig txtmid")for cd,ce in pairs(ew)do fK=fK+20;fO=fO..bT(fJ,fK,eE[1].getConstructName(ce),"pdim txtmid")end end;if eA==nil and perisPanelID==nil then peris=1;aS.ToggleRadarPanel()end;if eA~=nil and perisPanelID~=nil then aS.ToggleRadarPanel()end;if radarPanelID==nil then aS.ToggleRadarPanel()end else if eB then fO=bT(fL,fM,eF.." Radar: Jammed","pbright txtbig txtmid")else fO=bT(fL,fM,"Radar: No "..eF.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then peris=0;aS.ToggleRadarPanel()end end;return fO end;function ev.GetClosestName(fz)if eE[1]then local cH,_=eE[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cH~=nil and cH~=""then fz=fz.." "..eE[1].getConstructName(cH)end end;return fz end;function ev.ToggleRadarPanel()if radarPanelID~=nil and peris==0 then t(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then t(perisPanelID)perisPanelID=nil end else if peris==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(eE,1,"Periscope","periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(eE,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;peris=0 end end;eE[1]=nil;if radar_1 then eE[1]=radar_1;fG()end;eG=coroutine.create(eH)return ev end;local function fP()local fQ=9.80665;local fR={}local fS={}local fT={}local bw={}local fU=nil;local fV=nil;local fW=nil;local fX=false;local fY={}local fZ=""local f_=vec3({13771471,7435803,-128971})local g0=18000000;local g1=500000;local g2,g3=math.huge;local g4;local function g5(g6)g2=vec3(g6):dist(f_)if g2<g0 then return true,d(g2-g0)end;g3=vec3(g6):dist(vec3(planet.center))if g3<g1 then g4=true else g4=false end;if d(g3-g1)<d(g2-g0)then return g4,d(g3-g1)else return g4,d(g2-g0)end end;local function g7(ce)if aD==1920 then return ce else return A(aD*ce/1920,0)end end;local function g8(ce)if aE==1080 then return ce else return A(aE*ce/1080,0)end end;local function g9()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function ga()local gb="TRAVEL"if not bj then gb="CRUISE"end;if Autopilot then gb="AUTOPILOT"end;return gb end;local gc={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local fO=""local gd=""local ge=""local gf=1;local gg=2;local gh=3;local gi=4;local gj=5;local gk=6;local gl=""local gm=0;local gn=e(1/apTickRate)*2*hudTickRate;local go={}local gp={}local gq={}local gr={}local gs={}local gt={}local function gu(bU,gv,gw,gx,gy,gz)local gA=tankY;local gB=tankY+5;if not BarFuelDisplay then gB=gB+5 end;if m()==1 and not RemoteHud then gA=gA-50;gB=gB-50 end;if gw=="ATMO"then gl="atmofueltank"elseif gw=="SPACE"then gl="spacefueltank"else gl="rocketfueltank"end;gm=_G[gl.."_size"]if#gx>0 then for i=1,#gx do local fz=string.sub(gx[i][gg],1,12)local gC=0;for gD=1,gm do if gx[i][gg]==g(unit[gl.."_"..gD].getData()).name then gC=gD;break end end;local gE=q()if gy[i]==nil or gz[i]==nil or gE-gx[i][gk]>gn then local gF;local gG=0;if gC~=0 then gz[i]=g(unit[gl.."_"..gC].getData()).percentage;gy[i]=g(unit[gl.."_"..gC].getData()).timeLeft;if gy[i]=="n/a"then gy[i]=0 end else gG=l(gx[i][gf])-gx[i][gi]gz[i]=e(0.5+gG*100/gx[i][gh])gF=gx[i][gj]if gF<=gG then gy[i]=0 else gy[i]=e(0.5+gG/((gF-gG)/(gE-gx[i][gk])))end;gx[i][gj]=gG;gx[i][gk]=gE end end;if fz==gv then fz=f("%s %d",gw,i)end;if gC==0 then fz=fz.." *"end;local gH;if gy[i]==0 then gH=""else gH=c4(gy[i])end;if gz[i]~=nil then local gI=e(gz[i]*2.55)local gJ=f("rgb(%d,%d,%d)",255-gI,gI,0)local bX=""if gH~=""and gy[i]<120 or gz[i]<5 then bX="red "end;local gK=f("rgb(%d,%d,%d)",r(e((255-gI)/2.55),50,100),r(e(gI/2.55),0,50),50)local gL="rgb(196,0,255)"if gw=="ATMO"then gL="rgb(0,188,255)"elseif gw=="SPACE"then gL="rgb(239,255,0)"end;local gM=false;if previous~=gL then gM=true end;previous=gL;if BarFuelDisplay then if gM then gA=gA-5;gB=gB-5 end;gd=gd..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gK,gL,bU,gB,gJ,e(gz[i]*1.7+0.5)-2,bU+1,gB+1,bU+5,gB+14,fz,gz[i],gH)gA=gA-22;gB=gB-22 else gd=gd..bT(bU,gA,fz,bX.."pdim txtfuel")gd=gd..bT(bU,gB,f("%d%% %s",gz[i],gH),"pdim txtfuel","fill:"..gJ)gA=gA+30;gB=gB+30 end end end end;tankY=gA end;local function gN(gO,cP)if vSpdMeterX==0 and vSpdMeterY==0 then return end;if cP<200000 and not aq or cP and aq then local gP=0;if d(be)>1 then gP=45*math.log(d(be),10)if be<0 then gP=-gP end end;gO[#gO+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(be),e(gP))end;return gO end;local function gQ(gR)local gS=-bd;gR=gR-gR:project_on(gS)local gT=vec3(0,0,1)gT=gT-gT:project_on(gS)local gU=gT:cross(gS)local gP=gT:angle_between(gR)*constants.rad2deg;if gR:dot(gU)<0 then gP=360-gP end;return gP end;local function gV(gO,centerX,centerY,gW,gX,br)if circleRad==0 then return end;local gY=circleRad;local gZ=20;local g_=e(gW)if br then for i=-45,45,5 do local h0=i;gO[#gO+1]=f([[<g transform="rotate(%f,%d,%d)">]],h0,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gO[#gO+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gY+gZ-len,centerX,centerY+gY+gZ)end;gO[#gO+1]=bT(centerX,centerY+gY+gZ-35,gX,"pdim txt txtmid")gO[#gO+1]=bT(centerX,centerY+gY+gZ-25,g_.." deg","pdim txt txtmid")gO[#gO+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gW,centerX,centerY)gO[#gO+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gY+gZ-20,centerX+5,centerY+gY+gZ-20,centerX,centerY+gY+gZ-15)gO[#gO+1]="</g>"end;gO[#gO+1]=[[<g style="clip-path: url(#headingClip);">]]local h1=g_;if br then h1=gQ(b8)end;local h2=20;local h3=e(h1)local h4=0;local h5=centerY+gY+gZ+20;local h6=centerX;if gX~="YAW"then h5=g8(130)h6=g7(960)end;local h7=[[<path class="txttick line" d="]]local h8=e(h3-(h2+10)-h3%5+0.5)for i=h8+70,h8,-5 do local bU=h6-(-i*5+h1*5)if i%10==0 then h4=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gO[#gO+1]=bT(bU,h5+15,B,"txtmid bright")elseif i%5==0 then h4=5 end;if h4==10 then h7=f([[%s M %f %f v %d]],h7,bU,h5-5,h4)else h7=f([[%s M %f %f v %d]],h7,bU,h5-2.5,h4)end end;gO[#gO+1]=h7 ..[["/>]]gO[#gO+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],h6-5,h5-20,h6+5,h5-20,h6,h5-10)if DisplayOdometer then if br then gX="HDG"end;gO[#gO+1]=bT(g7(960),g8(100),h3 .."°","dim txt txtmid size14","")gO[#gO+1]=bT(g7(960),g8(85),gX,"dim txt txtmid size20","")end;gO[#gO+1]=[[</g>]]end;local function h9(gO,ha,gW,centerX,centerY,br,hb,e4)if circleRad==0 then return end;local gY=circleRad;local hc=e(gY*3/5)if gY>0 then local hd=e(ha)local len=0;local h7=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gW,centerX,centerY)if not aq then h7=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gO[#gO+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gY-1,centerX,centerY)gO[#gO+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hd-30-hd%5+0.5),e(hd+30+hd%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bV=centerY+-i*5+ha*5;if len==30 then h7=f([[%s M %d %f h %d]],h7,centerX-hc-len,bV,len)if aq then gO[#gO+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gW,centerX,centerY,centerX-hc+10,bV+4,i)gO[#gO+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gW,centerX,centerY,centerX+hc-10,bV+4,i)if i==0 or i==180 or i==-180 then gO[#gO+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gW,centerX,centerY,centerX-hc+20,bV,hc*2-40)end else gO[#gO+1]=bT(centerX-hc+10,bV,i,"pdim txt txtmid")gO[#gO+1]=bT(centerX+hc-10,bV,i,"pdim txt txtmid")end;h7=f([[%s M %d %f h %d]],h7,centerX+hc,bV,len)else h7=f([[%s M %d %f h %d]],h7,centerX-hc-len,bV,len)h7=f([[%s M %d %f h %d]],h7,centerX+hc,bV,len)end end;gO[#gO+1]=h7 ..[["/>]]local he="PITCH"if not br then he="REL PITCH"end;if ha>90 and not aq then ha=90-(ha-90)elseif ha<-90 and not aq then ha=-90-(ha+90)end;if gY>200 then if aq then if e4>Q then gO[#gO+1]=bT(centerX,centerY-15,"Yaw","pdim txt txtmid")gO[#gO+1]=bT(centerX,centerY+20,hb,"pdim txt txtmid")end;gO[#gO+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gW,centerX,centerY)else gO[#gO+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gO[#gO+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hc+25,centerY-5,centerX-hc+20,centerY,centerX-hc+25,centerY+5,centerX-hc+50,centerY+4,hd)gO[#gO+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hc-25,centerY-5,centerX+hc-20,centerY,centerX+hc-25,centerY+5,centerX+hc-30,centerY+4,hd)gO[#gO+1]="</g>"end;local hf=e(gY/3)gO[#gO+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hf,centerY,gY-hf)if not aq and br then gO[#gO+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gW,centerX,centerY,centerX-hc+10,centerY,hc*2-20)end;gO[#gO+1]="</g>"if gY<200 then if aq and e4>Q then gO[#gO+1]=bT(centerX,centerY-gY,he,"pdim txt txtmid")gO[#gO+1]=bT(centerX,centerY-gY+10,hd,"pdim txt txtmid")gO[#gO+1]=bT(centerX,centerY-15,"Yaw","pdim txt txtmid")gO[#gO+1]=bT(centerX,centerY+20,hb,"pdim txt txtmid")else gO[#gO+1]=bT(centerX,centerY-gY,he,"pdim txt txtmid")gO[#gO+1]=bT(centerX,centerY-gY+15,hd,"pdim txt txtmid")end end end end;local function hg(gO,cP,br)local hh=altMeterX;local hi=altMeterY;if hh==0 and hi==0 then return end;local hj=78;local hk=19;local hl=ao;if ao~=-1 then gO[#gO+1]=bT(hh+hj,hi+hk+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if br and(cP<200000 and not aq or cP and aq)then table.insert(gO,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hh-1,hi-4,hj+2,hk+6,hh+1,hi-1,hj-4,hk))local fk=0;local hm=1;local hn=0;local ho=cP<0;local hp=cP<planet.surfaceMaxAltitude;local hq=9;if ho then hq=0 end;local cP=d(cP)while fk<6 do local hr=11;local hs=16;local ht=9;local hu=14;local bX="altsm"if fk>2 then hs=hs+3;hr=hr+2;hu=hu+2;ht=ht-6;bX="altbig"end;if ho then bX=bX.." red"elseif hp then bX=bX.." orange"end;local hv=cP/hm%10;local hw=e(hv)local hx=e((hw+1)%10)local hy=hn;if fk==0 then hy=hv-hw;if ho then hy=1-hy end end;if ho and(fk==0 or hn~=0)then local hz=hx;hx=hw;hw=hz end;local hA=hs*(hy-1)local hB=hA+hs;local bU=hh+ht+(6-fk)*hr;local bV=hi+hu;gO[#gO+1]=bT(bU,bV+hA,hx,bX)gO[#gO+1]=bT(bU,bV+hB,hw,bX)fk=fk+1;hm=hm*10;if hw==hq then hn=hy else hn=0 end end;table.insert(gO,[[</g></g>]])end end;local function hC(e7)local hD=-math.deg(n(e7.y,e7.z))+180;hD=hD-90;if hD<0 then hD=360+hD end;if hD>180 then hD=-180+hD-180 end;return-hD end;local function hE(e7)local h1=math.deg(n(e7.y,e7.x))-90;if h1<-180 then h1=360+h1 end;return h1 end;local function hF(gO,e7,e4,centerX,centerY)if e4>5 and not aq or e4>Q then local gY=circleRad;local hG=20;local hH=20;local hI=hC(e7)local hJ=hE(e7)local hK=14;local hL=hK/2;local hM=-hJ/hH*gY;local hN=hI/hG*gY;local bU=centerX+hM;local bV=centerY+hN;local aj=y(hM^2+hN^2)local hO=[[<circle
                            cx="]]..bU..[["
                            cy="]]..bV..[["
                            r="]]..hL/hK..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bU..[["
                            cy="]]..bV..[["
                            r="]]..hL..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bU-hK..[[,]]..bV..[[ h ]]..hL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bU+hL..[[,]]..bV..[[ h ]]..hL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bU..[[,]]..bV-hK..[[ v ]]..hL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<gY then gO[#gO+1]=hO else local gP=n(hN,hM)local hP=4;local hQ=centerX+gY*math.cos(gP)local hR=centerY+gY*math.sin(gP)gO[#gO+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gP*180/math.pi,hQ,hR,hQ-hP,hR-hP/2,hP*2,hP,hQ+hP,hR-hP,hP,hP,-hP,hP)end;if not aq then local hS=vec3(e7)hI=hC(-hS)hJ=hE(-hS)hM=-hJ/hH*gY;hN=hI/hG*gY;bU=centerX+hM;bV=centerY+hN;aj=y(hM^2+hN^2)if aj<gY then local hT=[[<circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bU..[[,]]..bV-hK..[[ v ]]..hL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bU..[[,]]..bV..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bU..[[,]]..bV..[[)" />
                                <path
                                    d="M ]]..bU-hL..[[,]]..bV..[[ h ]]..hK..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bU..[[,]]..bV..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bU..[[,]]..bV..[[)"/>]]gO[#gO+1]=hT end end end end;local function hU(gO,gb,hV,hW)if throtPosX==0 and throtPosY==0 then return end;hV=e(hV+0.5)local gA=throtPosY+10;local gB=throtPosY+20;if m()==1 and not RemoteHud then gA=55;gB=65 end;local hX="CRUISE"local unit="km/h"local cz=hW;if gb=="TRAVEL"or gb=="AUTOPILOT"then hX="THROT"unit="%"cz=hV;local hY="dim"if hV<0 then hY="red"end;gO[#gO+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hY,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(hV),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gO[#gO+1]=bT(throtPosX+10,gA,hX,"pbright txtstart")gO[#gO+1]=bT(throtPosX+10,gB,f("%.0f %s",cz,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bj and M then hV=e(N*100+0.5)local hY="red"if hV<0 then hY="red"end;gO[#gO+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hY,1-d(hV),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gO[#gO+1]=bT(throtPosX+10,gA+40,"LIMIT","pbright txtstart")gO[#gO+1]=bT(throtPosX+10,gB+40,hV.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gO[#gO+1]=bT(throtPosX+10,gA-40,"LIMIT: "..aZ.." km/h","dim txtstart")elseif not aq and Autopilot then gO[#gO+1]=bT(throtPosX+10,gA-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hZ(gO,h_)if throtPosX==0 and throtPosY==0 then return end;local i0=throtPosY-10;local i1=throtPosX+10;gO[#gO+1]=bT(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then i0=75 end;gO[#gO+1]=bT(i1,i0,e(h_).." km/h","pbright txtbig txtstart")end;local function i2(gO)gO[#gO+1]=bT(g7(1900),g8(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gO[#gO+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gO[#gO+1]=bT(g7(960),g8(550),"Warning: Invalid Control Scheme Detected","warnings")gO[#gO+1]=bT(g7(960),g8(600),"Keyboard Scheme must be selected","warnings")gO[#gO+1]=bT(g7(960),g8(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local i3=g7(960)local i4=g8(860)local i5=g8(880)local i6=g8(900)local i7=g8(960)local i8=g8(200)local i9=g8(250)local ia=g8(960)if m()==1 and not RemoteHud then i4=g8(135)i5=g8(155)i6=g8(175)i8=g8(115)i9=g8(95)end;local ib="#222222"local ic="white"local id="dimmer"local ie="pbright"local ig="#110000"local ih=ib;local ii=id;if BrakeIsOn then gO[#gO+1]=bT(i3,i4,"Brake Engaged","warnings")ig="#440000"ih=ic;ii=ie elseif L>0 then gO[#gO+1]=bT(i3,i4,"Auto-Brake Engaged","warnings","opacity:"..L)end;local ij="#110000"local ik=ib;local il=id;if aq and aX and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bh and not VertTakeOff and not AutoTakeoff then gO[#gO+1]=bT(i3,i8+50,"** STALL WARNING **","warnings")ij="#ff0000"ik=ic;il=ie;bG("stall","SW",2)end end;if bp then gO[#gO+1]=bT(i3,i8+90,"Flight Assist in Progress","warnings")end;if ax then gO[#gO+1]=bT(i3,ia,"Gyro Enabled","warnings")end;local im="#111100"local io=ib;local ip=id;if GearExtended then im="#775500"io=ic;ip=ie;if S then gO[#gO+1]=bT(i3,i5,"Gear Extended","warn")else gO[#gO+1]=bT(i3,i5,"Landed (G: Takeoff)","warnings")end;local iq=c1(a:getTargetGroundAltitude())gO[#gO+1]=bT(i3,i6,"Hover Height: "..iq,"warn")end;local ir="#000011"local is=ib;local it=id;if a7 then ir="#0000DD"is=ic;it=ie;gO[#gO+1]=bT(i3,i7+20,"ROCKET BOOST ENABLED","warn")end;local iu="#001100"local iv=ib;local iw=id;if antigrav and not ExternalAGG and bh and AntigravTargetAltitude~=nil then iu="#00DD00"iv=ic;iw=ie;if d(as-antigrav.getBaseAltitude())<501 then gO[#gO+1]=bT(i3,i8+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gO[#gO+1]=bT(i3,i8+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gO[#gO+1]=bT(i3,i8+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gO[#gO+1]=bT(i3,i8+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gO[#gO+1]=bT(i3,i8+20,"Follow Mode Engaged","warn")elseif Reentry or an then gO[#gO+1]=bT(i3,i8+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local iq=c1(HoldAltitude,2)if VertTakeOff then if bh then iq=c1(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gO[#gO+1]=bT(i3,i8,"VTO to "..iq,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gO[#gO+1]=bT(i3,i8,"Takeoff to "..AutopilotTargetName,"warn")else gO[#gO+1]=bT(i3,i8,"Takeoff to "..iq,"warn")end;if BrakeIsOn and not VertTakeOff then gO[#gO+1]=bT(i3,i8+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gO[#gO+1]=bT(i3,i8,"Altitude Hold: "..iq,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gO[#gO+1]=bT(i3,i8+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gO[#gO+1]=bT(i3,i8+20,"Aligning trajectory","warn")elseif ar<0.05 then gO[#gO+1]=bT(i3,i8+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b0~=nil then gO[#gO+1]=bT(i3,i8,b0,"warn")end end;if BrakeLanding then if StrongBrakes then gO[#gO+1]=bT(i3,i8,"Brake-Landing","warnings")else gO[#gO+1]=bT(i3,i8,"Coast-Landing","warnings")end end;if ProgradeIsOn then gO[#gO+1]=bT(i3,i8,"Prograde Alignment","crit")end;if RetrogradeIsOn then gO[#gO+1]=bT(i3,i8,"Retrograde Alignment","crit")end;local ix="#110000"local iy=ib;local iz=id;if bs then ix="#FF0000"iy=ic;iz=ie;local type;if string.find(bs,"COLLISION")then type="warnings"else type="crit"end;gO[#gO+1]=bT(i3,i9+20,bs,type)elseif ar==0 then local iA,iB=aR.checkLOS(bb:normalize())if iB~=nil then iz=ie;ix="#FF0000"iy=ic;local iq=c1(iB)local travelTime=aM.computeTravelTime(bc,0,iB)local iC="Collision"if iA.noAtmosphericDensityAltitude>0 then iC="Atmosphere"end;gO[#gO+1]=bT(i3,i9+20,iA.name.." "..iC.." "..c4(travelTime).." In "..iq,"crit")end end;if VectorToTarget and not IntoOrbit then gO[#gO+1]=bT(i3,i8+35,VectorStatus,"warn")end;local iD="#111100"local iE=ib;local iF=id;if bx and#bx>1 then iD="#DDDD00"iE=ic;iF=ie end;local iG=g7;local iH=g8;local id="topButton"local iI="topButtonActive"local iJ=id;if Autopilot or VectorToTarget or am or IntoOrbit then iJ=iI end;local iK=id;if ProgradeIsOn then iK=iI end;local iL=id;if BrakeLanding or GearExtended then iL=iI end;local iM=id;if AltitudeHold or VectorToTarget then iM=iI end;local iN=id;if RetrogradeIsOn then iN=iI end;local iO=id;if IntoOrbit or b3 and Autopilot then iO=iI end;if showHud and DisplayOdometer then local iP=iH(30)gO[#gO+1]=f([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],iJ,iG(960),iH(54),iH(-53),iG(-120),iG(25),iH(50))gO[#gO+1]=bT(iG(910),iP,"AUTOPILOT")gO[#gO+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iK,iG(865),iH(51),iG(-25),iH(-50),iG(-110),iG(25),iH(46))gO[#gO+1]=bT(iG(800),iP,"PROGRADE")gO[#gO+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iL,iG(755),iH(47),iG(-25),iH(-46),iG(-98),iG(44),iH(44))gO[#gO+1]=bT(iG(700),iP,"LAND")gO[#gO+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],iM,iG(960),iH(54),iH(-53),iG(120),iG(-25),iH(50))gO[#gO+1]=bT(iG(1010),iP,"ALT HOLD")gO[#gO+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iN,iG(1055),iH(51),iG(25),iH(-50),iG(110),iG(-25),iH(46))gO[#gO+1]=bT(iG(1122),iP,"RETROGRADE")gO[#gO+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iO,iG(1165),iH(47),iG(25),iH(-46),iG(98),iG(-44),iH(44))gO[#gO+1]=bT(iG(1220),iP,"ORBIT")gO[#gO+1]=[[
                                    </g>
                                </g>]]gO[#gO+1]="</g>"end;return gO end;local function iQ(e4)return e(A(e4*3.6,0)+0.5).." km/h"end;local function iR(gO)local bU=OrbitMapX+10;local bV=OrbitMapY+20;local iS={}local iT={"Alt-4: AutoTakeoff to Target"}local iU={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iV={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iW={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iS,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then bJ(iS,iT)if ac and planet and ac.name==planet.name then table.insert(iS,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bh then table.insert(iS,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iS,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iS,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iS,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iS,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iS,"G: Takeoff to hover height, raise gear")else table.insert(iS,"G: Lowergear and Land")end else bJ(iS,iU)table.insert(iS,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iS,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bJ(iS,iV)if shield_1 then table.insert(iS,"Alt-Shift-5: Toggle shield off and on")table.insert(iS,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iS,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iS,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iS,"Alt-Spacebar/C will raise/lower target height")table.insert(iS,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iS,"LALT+Mousewheel will lower/raise speed limit")end;bJ(iS,iW)for i=1,#iS do bV=bV+12;gO[#gO+1]=bT(bU,bV,iS[i],"pdim txtbig txtstart")end end;local function iX(gO)local iY=OrbitMapX;local iZ=OrbitMapY;local i_=OrbitMapSize;local j0=4;local j1=15;local bU=0;local bV=0;local j2,j3,j4,j5;local j6;local function j7(type)local j8,E,e4,j9,bX,ja;if type=="Periapsis"then j8=j6.periapsis.altitude;E=j6.timeToPeriapsis;e4=j6.periapsis.speed;bX="txtend"j9=12;ja=math.min(bU,iY+i_-planet.radius/j4-j0*2)else j8=j6.apoapsis.altitude;E=j6.timeToApoapsis;e4=j6.apoapsis.speed;j9=-12;bX="txtstart"ja=bU end;if bc<1 then E=0 end;gO[#gO+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],ja+j9,bV-5,bU,bV-5)gO[#gO+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],ja-j9*4,bV+2,bU,bV+2)gO[#gO+1]=bT(ja,bV,type,bX)bU=ja-j9*2;bV=bV+j1;local iq=c1(j8)gO[#gO+1]=bT(bU,bV,iq,bX)bV=bV+j1;gO[#gO+1]=bT(bU,bV,c4(E),bX)bV=bV+j1;gO[#gO+1]=bT(bU,bV,iQ(e4),bX)end;local jb=i_*1.5;if SelectedTab=="INFO"then jb=25*7 end;if SelectedTab~="HIDE"then gO[#gO+1]=[[<g class="pbright txtorb txtmid">]]gO[#gO+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',i_*2,jb,iY,iZ)gO[#gO+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],i_*2,jb,iY,iZ)end;local jc=i_*1.5;local jd=i_*2;local je=jc/2;local jf=i_;local jg=iY+jf;local jh=iZ+je;local ji=iY+jd;local jj=iZ+jc;if SelectedTab=="ORBIT"then iZ=iZ+j0;j2=i_/2;j5=0;j6={}j6.periapsis={}j6.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then j6.periapsis.altitude=orbit.periapsis.altitude;j6.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then j6.apoapsis.altitude=orbit.apoapsis.altitude;j6.apoapsis.speed=orbit.apoapsis.speed end;j6.period=orbit.period;j6.eccentricity=orbit.eccentricity;j6.timeToApoapsis=orbit.timeToApoapsis;j6.timeToPeriapsis=orbit.timeToPeriapsis;j6.eccentricAnomaly=orbit.eccentricAnomaly;j6.trueAnomaly=orbit.trueAnomaly end;if j6.periapsis==nil then j6.periapsis={}j6.periapsis.altitude=-planet.radius;j6.periapsis.speed=MaxGameVelocity end;if j6.eccentricity==nil then j6.eccentricity=1 end;if j6.apoapsis==nil then j6.apoapsis={}j6.apoapsis.altitude=as;j6.apoapsis.speed=0 end;if bc<1 then j6.apoapsis.altitude=as;j6.apoapsis.speed=0 end;if j6.apoapsis.altitude then j4=(j6.apoapsis.altitude+j6.periapsis.altitude+planet.radius*2)/(j2*2)j3=(planet.radius+j6.apoapsis.altitude)/j4*(1-j6.eccentricity)j5=j2-j6.periapsis.altitude/j4-planet.radius/j4;local jk=math.pi;if j6.period~=nil and j6.period>0 and j6.timeToApoapsis~=nil then jk=j6.eccentricAnomaly;if j6.timeToPeriapsis<j6.timeToApoapsis then jk=2*math.pi-jk end end;if bc<1 or jk~=jk then jk=math.pi end;local jl=-j2*math.cos(jk)+iY+jf+j0;local jm=j3*math.sin(jk)+iZ+je+j0;local jn=""gO[#gO+1]='<g clip-path="url(#orbitRect)">'gO[#gO+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jn,iY+i_+j0,iZ+i_*1.5/2+j0,j2,j3)if j3<1 then gO[#gO+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iY+i_+j0-j5,iZ+i_*1.5/2+j0,jl,jm)end;gO[#gO+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iY+i_+j0-j5,iZ+i_*1.5/2+j0,(planet.radius+planet.noAtmosphericDensityAltitude)/j4)gO[#gO+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iY+i_+j0-j5,iZ+i_*1.5/2+j0,(planet.radius+planet.noAtmosphericDensityAltitude)/j4)gO[#gO+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iY+i_+j0,iZ+i_*1.5/2+j0,j2,j3)gO[#gO+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iY+i_+j0-j5,iZ+i_*1.5/2+j0,planet.radius/j4)gO[#gO+1]='</g>'local jo=math.floor(planet.radius/j4+0.5)local jp=gc.Generic_Moon;if gc[planet.name]then jp=gc[planet.name]end;bU=iY+i_+j0*4+j2;bV=iZ+i_*1.5/2+5+j0;if j6.apoapsis~=nil and j6.apoapsis.speed<MaxGameVelocity then j7("Apoapsis")end;bV=iZ+i_*1.5/2+5+j0;bU=iY+i_-j0*2-j2;if j6.periapsis~=nil and j6.periapsis.speed<MaxGameVelocity and j6.periapsis.altitude>0 then j7("Periapsis")end;gO[#gO+1]=bT(iY+i_+j0,iZ+20+j0,planet.name,"txtorbbig")gO[#gO+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jl,jm)gO[#gO+1]=[[</g>]]return gO else gO[#gO+1]='<g clip-path="url(#orbitRect)">'local jq=""local jr=1.2*(maxAtlasX-minAtlasX)/(i_*2)local js=1.4*(maxAtlasY-minAtlasY)/(i_*1.5)for cd,ce in pairs(b[0])do if ce.center then local bU=iY+i_+ce.center.x/jr;local bV=iZ+i_*1.5/2+ce.center.y/js;jq=jq..'<circle cx="'..bU..'" cy="'..bV..'" r="'..ce.radius/jr*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(ce.name,"Moon")and not string.match(ce.name,"Sanctuary")and not string.match(ce.name,"Space")then jq=jq.."<text x='"..bU.."' y='"..bV+ce.radius/jr*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..ce.name.."</text>"end end end;local e8=vec3(core.getConstructWorldPos())local bU=iY+i_+e8.x/jr;local bV=iZ+i_*1.5/2+e8.y/js;jq=jq..'<circle cx="'..bU..'" cy="'..bV..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jq=jq.."<text x='"..bU.."' y='"..bV-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fU=jr;fV=js;local jt=e8+bb*1000000;local ju=iY+i_+jt.x/jr;local gB=iZ+i_*1.5/2+jt.y/js;jq=jq..'<line x1="'..bU..'" y1="'..bV..'" x2="'..ju..'" y2="'..gB..'" stroke="purple" stroke-width="1"/>'gO[#gO+1]=jq;gO[#gO+1]='</g>'end elseif SelectedTab=="INFO"then gO=aP.DrawOdometer(gO,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then gO=iR(gO)elseif SelectedTab=="SCOPE"then gO[#gO+1]='<g clip-path="url(#orbitRect)">'local jv=bA;if ar>0 then table.sort(bz,function(dh,di)local b_,c0=dh.center,di.center;return(b_.x-bf.x)^2+(b_.y-bf.y)^2+(b_.z-bf.z)^2<(c0.x-bf.x)^2+(c0.y-bf.y)^2+(c0.z-bf.z)^2 end)end;local eB={}local jw={}local jx=120;local jy=nil;local jz=nil;for i,ce in ipairs(bz)do local eA=ce.center-bf;local jA=eA:len()local jB=eA:normalize()local jC=eA:cross(b8):normalize()local jD=math.acos(jC:dot(b9))if jD~=jD then jD=0 end;if jC:cross(b9):dot(b8)<0 then jD=-jD end;local jE=eA:project_on_plane(b8):len()local jF=math.sin(jD)*math.asin(jE/jA)*constants.rad2deg;local jG=math.cos(jD)*math.asin(jE/jA)*constants.rad2deg;if jB:dot(b8)<0 then jG=90*math.cos(jD)+90*math.cos(jD)-jG;jF=90*math.sin(jD)+90*math.sin(jD)-jF end;local bU=jg+jF/jv*jc;local bV=jh+jG/jv*jc;local jH=(bU-jg)*(bU-jg)+(bV-jh)*(bV-jh)local jI=math.asin((ce.radius+ce.surfaceMaxAltitude)/jA)*constants.rad2deg;if jI~=jI then jI=jv end;local fw=jI/jv*jc;local jJ=math.asin(ce.atmosphereRadius/jA)*constants.rad2deg;if jJ~=jJ then jJ=jI end;local jK=jJ/jv*jc;local aj=c1(jA,1)local jL=ce.name;local jM=false;if bV>iZ then if bV>jj then if bV-jK<=jj then jM=true end else jM=true end else if bV+jK>=iZ then jM=true end end;local jN=false;local jO=bU;if ce.systemId==0 then jO=bU+jx else jO=bU-jx end;if jO+jx>iY then if jO+jx>ji then if jO-jK-jx<=ji then jN=true end else jN=true end else if jO+jK+jx>=iY then jN=true end end;local jP={}jP.x=bU;jP.y=bV;jP.planet=ce;jP.atmoSize=jK;if not jy or jH<jy then jy=jH;jz=jP end;if jN and jM then local jQ=math.max(jK,5)if jH<jQ*jQ then jL=jL.." - "..aj end;jP.size=fw;jP.i=i;jP.displayString=jL;jP.distance=aj;jP.visible=true;jw[#jw+1]=jP else jP.visible=false end end;local jR=false;table.sort(jw,function(b_,c0)return b_.y<c0.y end)for cd,eb in ipairs(jw)do local ce,fw,i,jK,bU,bV,jL,aj=eb.planet,eb.size,eb.i,eb.atmoSize,eb.x,eb.y,eb.displayString,eb.distance;local ja,jS,jT,jU;local jV=15;local bX="pdim"if ce.systemId~=0 then jT=g7(string.len(jL)*5)jV=-(15+jT)jU=g8(10)bX="pdimfill"else jT=g7(string.len(jL)*9)jU=g8(15)end;if fw*2>jT then ja=r(bU,iY+jT/2,ji-jT/2)jS=r(bV,iZ+jU,jj-5)ja=r(ja,bU-fw+jT/2,bU+fw-jT/2)jS=r(jS,bV-fw+jU,bV+fw)else ja=bU+jV;jS=bV end;for jW,eb in pairs(eB)do local jX=eb.textPositions;local jY=jX.y-jS;if jW~=i and d(jY)<jX.height and jX.x+jX.width>ja and jX.x<ja+jT then if fw>jT then jS=r(jS+jU,iZ+15,jj-5)else jS=jX.y+jX.height+1 end end end;local jZ=jL~=ce.name or ja<=jg and ja+jT>=jg and jS-jU<=jh and jS>=jh;eb.hovered=jZ;local j_=1;if jZ then j_=2;if fw*2<jT then j_=10 end;if jL==ce.name then jL=jL.." - "..aj end;bX="pbright"if ce.systemId~=0 then jT=g7(string.len(jL)*5)jV=-(15+jT)else jT=g7(string.len(jL)*7)end;if fw*2>jT then ja=r(bU,iY+jT/2,ji-jT/2)ja=r(ja,bU-fw+jT/2,bU+fw-jT/2)else ja=bU+jV end end;eB[i]={}eB[i].textPositions={}eB[i].textPositions.y=jS;eB[i].textPositions.x=ja;eB[i].textPositions.width=jT;eB[i].textPositions.height=jU;eB[i].output=""if fw*2>jT then bX=bX.." txtmid"else bX=bX.." txtstart"end;if jK-fw>2 then eB[i].output=f('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',bU,bV,jK,az,0.1*j_)end;eB[i].output=eB[i].output..f('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',bU,bV,fw,az,0.2*j_)if ce.systemId==0 then eB[i].output=eB[i].output..f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],ja,jS,ay,bX,jL)if fw*2<=jT then eB[i].output=eB[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",ja+jT,jS+2,ja,jS+2,bU,bV)end else eB[i].output=eB[i].output..f([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],ja,jS,az,bX,jL)if fw*2<=jT then eB[i].output=eB[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",ja,jS+2,ja+jT,jS+2,bU,bV)end end end;for cd=#bz,1,-1 do if eB[cd]then gO[#gO+1]=eB[cd].output end end;if jz~=nil and bA<90 and not jz.hovered then local k0=jz.planet.atmosphereRadius/jz.atmoSize;local k1=y(jy)*k0;local k2=c1(k1,1)local jT=g7(math.max(string.len(k2)*7,string.len(jz.planet.name)*7))local jU=g8(12)local ja=r(jz.x+(jg-jz.x)/2,iY+jT/2,ji-jT/2)local jS=r(jz.y+(jh-jz.y)/2,iZ+jU*2,jj-5)gO[#gO+1]=f("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",jz.x,jz.y,jg,jh)gO[#gO+1]=f([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],ja,jS,"white",k2)if not jz.visible then gO[#gO+1]=f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],ja,jS-jU,"white",jz.planet.name)end end;if bc>1 then local eA=bb;local jB=eA:normalize()local jE=eA:project_on_plane(b8):len()local jC=eA:cross(b8):normalize()local jD=math.acos(jC:dot(b9))if jD~=jD then jD=0 end;if jC:cross(b9):dot(b8)<0 then jD=-jD end;local jF=math.sin(jD)*math.asin(jE/eA:len())*constants.rad2deg;local jG=math.cos(jD)*math.asin(jE/eA:len())*constants.rad2deg;if jB:dot(b8)<0 then jG=90*math.cos(jD)+90*math.cos(jD)-jG;jF=90*math.sin(jD)+90*math.sin(jD)-jF end;local bU=jg+jF/jv*jc;local bV=jh+jG/jv*jc;local hK=14;local hL=hK/2;local hO=[[<circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hL/hK..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bU-hK..[[,]]..bV..[[ h ]]..hL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bU+hL..[[,]]..bV..[[ h ]]..hL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bU..[[,]]..bV-hK..[[ v ]]..hL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]gO[#gO+1]=hO end;gO[#gO+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jg,jh-10,jg,jh+10)gO[#gO+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jg-10,jh,jg+10,jh)gO[#gO+1]='</g>'else return gO end end;local function k3(k4,k5)local k6;local k7=(k5-k4):normalize()local e9=(bf-k4):dot(k7)/k7:dot(k7)if e9<=0.then return(bf-k4):len()elseif e9>=(k5-k4):len()then return(bf-k5):len()end;local k8=k4+e9*k7;k6=(k8-bf):len()return k6 end;local function k9()local k6;local ka=nil;local kb=nil;local kc=nil;for cd,kd in pairs(b[0])do if kd.hasAtmosphere then local aj=k3(planet.center,kd.center)if ka==nil or aj<ka then kb=kd;ka=aj;kc=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dv=k3(ac.center,kd.center)if dv<ka then kb=kd;ka=dv;kc=ac end end end end;local ke=g7(1770)local kf=g8(330)if ka then local kg="txttick "local kh=500000;if ka<kb.radius+kh or ka<kc.radius+kh then if bn then kg="txttick red "else kg="txttick orange "end end;k6=c1(ka,2)fZ=bT(ke,kf,"Pipe ("..kc.name.."--"..kb.name.."): "..k6,kg.."pbright txtmid")end end;local function ki(bU,bV,kj,kk,hX)local kl={x=bU,y=bV,width=kj,height=kk,label=hX}bw[hX]=kl;return kl end;local function km(kn,ko,kj,kk,bU,bV,kp,kq,kr,ks,bX)local kl={enableName=kn,disableName=ko,width=kj,height=kk,x=bU,y=bV,toggleVar=kp,toggleFunction=kq,drawCondition=kr,hovered=false,class=bX}if ks then table.insert(fT,kl)else table.insert(fS,kl)end;return kl end;local function kt(ku)if not fX then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif ku=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif ku=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif ku=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fY=bM(ku)showHud=false else fY={}showHud=true end end;local function kv()fX=not fX;if fX then fR=fT;a2="Hold SHIFT to see Settings"bB=showHud else fR=fS;a2="Hold SHIFT to see Control Buttons"kt()showHud=bB end end;local function kw()local function kx(ce)_G[ce]=not _G[ce]if _G[ce]then a2=ce.." set to true"else a2=ce.." set to false"end;if ce=="showHud"then bB=_G[ce]elseif ce=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local ky=50;local kz=340;local bU=500;local bV=aE/2-400;local kA=0;for cd,ce in pairs(bM("boolean"))do if type(_G[ce])=="boolean"then km(ce,ce,kz,ky,bU,bV,function()return _G[ce]end,function()kx(ce)end,function()return true end,true)bV=bV+ky+20;if kA==9 then bU=bU+kz+20;bV=aE/2-400;kA=0 else kA=kA+1 end end end;km("Control View","Control View",kz,ky,10,aE/2-500,function()return true end,kv,function()return true end,true)km("View Handling Settings",'Hide Handling Settings',kz,ky,10,aE/2-(500-ky),function()return showHandlingVariables end,function()kt("handling")end,function()return true end,true)km("View Hud Settings",'Hide Hud Settings',kz,ky,10,aE/2-(500-ky*2),function()return showHudVariables end,function()kt("hud")end,function()return true end,true)km("View Physics Settings",'Hide Physics Settings',kz,ky,10,aE/2-(500-ky*3),function()return showPhysicsVariables end,function()kt("physics")end,function()return true end,true)end;local function kB()local function kC()local position=bf;local fz=planet.name..". "..#SavedLocations;if radar_1 then fz=aS.GetClosestName(fz)end;return aQ.AddNewLocation(fz,position,false,true)end;local function kD()TurnBurn=not TurnBurn end;local function kE(kF)if kF==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kG()aQ.UpdatePosition()end;local function kH()aQ.ClearCurrentPosition()end;local function kI(fk)local fz=AutopilotTargetName;if fk~=nil and type(fk)=="number"then if fk==0 then return"None"end;fz=bm[fk].name end;if fz==nil then fz=CustomTarget.name end;if fz==nil then fz="None"end;return fz end;local function kJ(fk)return"Engage Autopilot: "..kI(fk)end;local function kK(fk)return"Disable Autopilot: "..kI(fk)end;local function kL()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bG("folOn","F")else bG("folOff","F")BrakeIsOn=true;aV=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local ky=50;local kz=260;local kM=g7(30)local kN=OrbitMapX+OrbitMapSize*2+2;local kO=OrbitMapY+1;km("+","+",kM,kM,kN,kO+kM+1,function()return false end,function()bA=bA/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")km("-","-",kM,kM,kN,kO,function()return false end,function()bA=math.min(bA*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")km("0","0",kM,kM,kN,kO+kM*2+2,function()return false end,function()bA=90 end,function()return SelectedTab=="SCOPE"and bA~=90 end,nil,"ZoomButton")local kP=km("Enable Brake Toggle","Disable Brake Toggle",kz,ky,aD/2-kz/2,aE/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)km("Align Prograde","Disable Prograde",kz,ky,aD/2-kz/2-50-kP.width,aE/2-ky+380,function()return ProgradeIsOn end,function()kE(1)end)km("Align Retrograde","Disable Retrograde",kz,ky,aD/2-kz/2+kP.width+50,aE/2-ky+380,function()return RetrogradeIsOn end,kE,function()return ar==0 end)apbutton=km(kJ,kK,600,60,aD/2-600/2,aE/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function kQ(kR)local fk=bv+kR;if fk>#bm then fk=fk-#bm-1 end;if fk<0 then fk=#bm+fk end;return fk end;apExtraButtons={}for i=0,10 do local button=km(function(c0)local fk=kQ(c0.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..kI(fk)end;return kJ(fk)end,function(c0)local fk=kQ(c0.apExtraIndex)return kK(fk)end,600,60,aD/2-600/2,aE/2-60/2-330+60*i,function(c0)local fk=kQ(c0.apExtraIndex)return fk==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(c0)local fk=kQ(c0.apExtraIndex)local kS=AutopilotTargetIndex==fk;AutopilotTargetIndex=fk;aQ.UpdateAutopilotTarget()aR.ToggleAutopilot()if not kS and not(Autopilot or VectorToTarget or am or IntoOrbit)then aR.ToggleAutopilot()end end,function()return bu end)button.apExtraIndex=i;apExtraButtons[i]=button end;km("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kC,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)km("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kG,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)km("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kH,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ky=60;kz=300;local bU=0;local bV=aE/2-150;km("View Settings","View Settings",kz,ky,bU,bV,function()return true end,kv)bV=bV+ky+20;km("Enable Turn and Burn","Disable Turn and Burn",kz,ky,bU,bV,function()return TurnBurn end,kD)bU=10;bV=aE/2-300;km("Horizontal Takeoff Mode","Vertical Takeoff Mode",kz,ky,bU+kz+20,bV,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bg end)bV=bV+ky+20;km("Engage Orbiting","Cancel Orbiting",kz,ky,bU+kz+20,bV,function()return IntoOrbit end,aR.ToggleIntoOrbit,function()return ar==0 and br end)bV=aE/2-150;km("Glide Re-Entry","Cancel Glide Re-Entry",kz,ky,bU+kz+20,bV,function()return Reentry end,function()al=1;kE(1)end,function()return planet.hasAtmosphere and not aq end)bV=bV+ky+20;km("Parachute Re-Entry","Cancel Parachute Re-Entry",kz,ky,bU+kz+20,bV,function()return Reentry end,aR.BeginReentry,function()return planet.hasAtmosphere and not aq end)bV=bV+ky+20;km("Engage Follow Mode","Disable Follow Mode",kz,ky,bU,bV,function()return a0 end,kL,function()return m()==1 end)km("Enable Repair Arrows","Disable Repair Arrows",kz,ky,bU+kz+20,bV,function()return aJ end,function()aJ=not aJ;if aJ then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)bV=bV+ky+20;if not ExternalAGG then km("Enable AGG","Disable AGG",kz,ky,bU,bV,function()return bh end,aR.ToggleAntigrav,function()return antigrav~=nil end)end;km(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,kz*2,ky,bU,bV,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)bV=bV+ky+20;km(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,kz*2,ky,bU,bV,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local kT=g8(20)local button=ki(0,0,g7(70),kT,"HELP")button=ki(button.x+button.width,button.y,g7(80),kT,"INFO")button=ki(button.x+button.width,button.y,g7(70),kT,"ORBIT")button=ki(button.x+button.width,button.y,g7(70),kT,"SCOPE")ki(button.x+button.width,button.y,g7(70),kT,"HIDE")end;local kU={}local kV=nil;function kU.HUDPrologue(gO)bn,bo=g5(bf)if not bn then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.6)..","..e(J+0.6)..","..e(I+0.6)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kW=ay;local kX=az;local kY=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.4+0.5)..[[)]]local kZ=ay;local k_=az;local l0=kY;if g9()and not brightHud then kW=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kX=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]kY=[[rgb(]]..e(H*0.2+0.5)..","..e(J*0.2+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iG=g7;local iH=g8;gO[#gO+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .pdimfill {fill: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                    <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="1"/>
                                    </radialGradient>
                                    <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="66%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/>
                                    </radialGradient>                            
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kW,kW,kW,kZ,kZ,kX,kX,k_,k_,kX,kW,kY,k_,kW,kW,kY,kY,l0,kY,aD,aE,kX,kX,kX,kX,kX,kZ,kX,k_,l0,k_,k_,l0)if not kV then kV=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iG(630),iH(0),iG(675),iH(45),iG(960),iH(55),iG(1245),iH(45),iG(1290),iH(0),iG(1000),iH(105),iG(1040),iH(59),iG(1250),iH(51),iG(1300),iH(0),iG(1920),iH(0),iG(1920),iH(20),iG(1400),iH(20),iG(1300),iH(105),iG(920),iH(105),iG(880),iH(59),iG(670),iH(51),iG(620),iH(0),iG(0),iH(0),iG(0),iH(20),iG(520),iH(20),iG(620),iH(105),iG(890),iH(59),iG(960),iH(62),iG(1030),iH(59),iG(985),iH(112),iG(1150),iH(112),iG(1100),iH(152),iG(820),iH(152),iG(780),iH(112),iG(935),iH(112),iG(890),iH(59),iG(960),iH(62),iG(1030),iH(59),iG(985),iH(112),iG(1150),iH(112),iG(1100),iH(152),iG(820),iH(152),iG(780),iH(112),iG(935),iH(112))end;if showHud and DisplayOdometer then gO[#gO+1]=kV end;return gO end;function kU.DrawVerticalSpeed(gO,cP)gN(gO,cP)end;function kU.UpdateHud(gO)local hD=bk;local l1=bl;local gW=l1;local ha=hD;local hV=e(unit.getThrottle())local h_=bc*3.6;local hW=unit.getAxisCommandValue(0)local l2=g7(1770)local l3=g8(310)if AtmoSpeedAssist and bj then hW=K;hV=K*100 end;local gb=ga()local gX="ROLL"if hV==nil then hV=0 end;if not br then if bc>5 then hD=hC(ba)l1=hE(ba)else hD=0;l1=0 end;gX="YAW"end;if bo>50000 and not aq then local l4;l4=c1(bo)gO[#gO+1]=bT(l2,l3,"PvP Boundary: "..l4,"pbright txtbig txtmid")end;gO[#gO+1]=ak;gO[#gO+1]=aB;gO[#gO+1]=fO;if fZ~=""then gO[#gO+1]=fZ end;if gd~=""then gO[#gO+1]=gd end;if ge~=""then gO[#gO+1]=ge end;gN(gO,as)if m()==0 or RemoteHud then if br then gV(gO,centerX,centerY,gW,gX,br)else gV(gO,centerX,centerY,l1,gX,br)end;if not g9()or brightHud then if br then gV(gO,centerX,centerY,gW,gX,br)h9(gO,ha,gW,centerX,centerY,br,e(hE(ba)),bc)else gV(gO,centerX,centerY,l1,gX,br)h9(gO,hD,l1,centerX,centerY,br,e(l1),bc)end;hg(gO,as,br)hF(gO,ba,bc,centerX,centerY)end end;hU(gO,gb,hV,hW)hZ(gO,h_)i2(gO)iX(gO)return gO end;function kU.HUDEpilogue(gO)gO[#gO+1]="</svg>"return gO end;function kU.ExtraData(gO)local l5=g7(1240)local l6=g8(55)local l7=l6+10;local l8;local iG=g7;local iH=g8;local l9=0;local gb=ga()if VertTakeOffEngine then gb=gb.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bc>20 then gb=gb.."-COLLISION ON"end;if UseExtra~="Off"then gb="("..UseExtra..")-"..gb end;if TurnBurn then gb="TB-"..gb end;if not stablized then gb=gb.."-DeCoupled"end;local la=iH(99)local lb=iH(80)local lc=iH(85)local ld=iH(31)local le=0;local lf=0;local lg=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then l9=LastMaxBrakeInAtmo else l9=LastMaxBrake end;local lh,li=aM.computeDistanceAndTime(bc,0,av,0,0,l9)if lh<0 then lh=0 end;l9=A(l9/(av*fQ),2).."g"local lj=a:maxForceForward()l8=core.g()if l8>0.1 then lf=av*l8;lf=A(lf/(av*fQ),2).."g"le=0.5*lj/l8;le=le>1000000 and A(le/1000000,2).."kT"or A(le/1000,2).."T"end;lj=A(lj/(av*fQ),2).."g"local lk=vec3(core.getWorldAcceleration()):len()/9.80665;l8=core.g()gO[#gO+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then l5=g7(1120)l6=g8(55)l7=l6+10 elseif aq and DisplayOdometer then local ll=g7(770)gO[#gO+1]=bT(iG(895),la,"ATMO","")gO[#gO+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iG(895),lc,iG(-80))gO[#gO+1]=bT(iG(815),lb,f("%.1f%%",ar*100),"txtstart size20")end;if DisplayOdometer then gO[#gO+1]=bT(iG(1025),la,"GRAVITY","txtstart")gO[#gO+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iG(1025),lc,iG(80))gO[#gO+1]=bT(iG(1105),lb,f("%.2fg",l8/9.80665),"size20")gO[#gO+1]=bT(iG(1125),la,"ACCEL","txtstart")gO[#gO+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iG(1125),lc,iG(80))gO[#gO+1]=bT(iG(1205),lb,f("%.2fg",lk),"size20")gO[#gO+1]=bT(iG(695),la,"BRK TIME","")gO[#gO+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iG(695),lc,iG(-80))gO[#gO+1]=bT(iG(615),lb,f("%s",c4(li)),"txtstart size20")gO[#gO+1]=bT(iG(635),iH(45),"TRIP","")gO[#gO+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iG(635),iH(31),iG(-90))if travelTime then gO[#gO+1]=bT(iG(532),iH(23),f("%s",c4(travelTime)),"txtstart size20")end;gO[#gO+1]=bT(iG(795),la,"BRK DIST","")gO[#gO+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iG(795),lc,iG(-80))gO[#gO+1]=bT(iG(715),lb,f("%s",c1(lh)),"txtstart size20")gO[#gO+1]=bT(iG(1285),iH(45),"MASS","txtstart")gO[#gO+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iG(1285),iH(31),iG(90))gO[#gO+1]=bT(iG(1388),iH(23),f("%s",lg),"size20")gO[#gO+1]=bT(iG(1220),la,"THRUST","txtstart")gO[#gO+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iG(1220),lc,iG(80))gO[#gO+1]=bT(iG(1300),lb,f("%s",lj),"size20")gO[#gO+1]=bT(g7(960),g8(175),gb,"pbright txtbig txtmid size20")end;gO[#gO+1]="</g>"end;function kU.DrawOdometer(gO,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return gO end;local l8;local le=0;local lf=0;local l9=0;local lg=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then l9=LastMaxBrakeInAtmo else l9=LastMaxBrake end;local lh,li=aM.computeDistanceAndTime(bc,0,av,0,0,l9)l9=A(l9/(av*fQ),2).." g"local lj=a:maxForceForward()l8=core.g()if l8>0.1 then lf=av*l8;lf=A(lf/(av*fQ),2).." g"le=0.5*lj/l8;le=le>1000000 and A(le/1000000,2).." kTons"or A(le/1000,2).." Tons"end;lj=A(lj/(av*fQ),2).." g"if m()==0 or RemoteHud then local lm=g7(OrbitMapX+10)local ln=g8(OrbitMapY+20)local lo=g7(OrbitMapX+10+OrbitMapSize/1.25)local kk=25;gO[#gO+1]="<g class='txtstart size14 bright'>"gO[#gO+1]=bT(lm,ln,f("BrkTime: %s",c4(li)))gO[#gO+1]=bT(lo,ln,f("Trip: %.2f km",ad))gO[#gO+1]=bT(lm,ln+kk,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gO[#gO+1]=bT(lo,ln+kk,f("BrkDist: %s",c1(lh)))gO[#gO+1]=bT(lm,ln+kk*2,"Trip Time: "..c4(ae))gO[#gO+1]=bT(lo,ln+kk*2,"Total Time: "..c4(TotalFlightTime))gO[#gO+1]=bT(lm,ln+kk*3,f("Mass: %s",lg))gO[#gO+1]=bT(lo,ln+kk*3,f("Max Brake: %s",l9))gO[#gO+1]=bT(lm,ln+kk*4,f("Max Thrust: %s",lj))if l8>0.1 then gO[#gO+1]=bT(lo,ln+kk*4,f("Max Thrust Mass: %s",le))gO[#gO+1]=bT(lm,ln+kk*5,f("Req Thrust: %s",lf))else gO[#gO+1]=bT(lo,ln+kk*5,"Max Mass: n/a")gO[#gO+1]=bT(lm,ln+kk*6,"Req Thrust: n/a")end end;gO[#gO+1]="</g></g>"return gO end;function kU.DrawWarnings(gO)return i2(gO)end;function kU.DisplayOrbitScreen(gO)return iX(gO)end;function kU.DisplayMessage(gO,iq)if iq~="empty"then local bV=310;for lp in string.gmatch(iq,"([^\n]+)")do bV=bV+35;gO[#gO+1]=bT("50%",bV,lp,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function kU.DrawDeadZone(gO)gO[#gO+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kU.UpdatePipe()if aq then fZ=""return end;k9()end;function kU.DrawSettings(gO)if#fY>0 then local bU=g7(640)local bV=g8(200)gO[#gO+1]=[[<g class="pbright txtvspd txtstart">]]for cd,ce in pairs(fY)do gO[#gO+1]=bT(bU,bV,ce..": ".._G[ce])bV=bV+20;if cd%12==0 then bU=bU+g7(350)bV=g8(200)end end;gO[#gO+1]=bT(g7(640),g8(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gO[#gO+1]="</g>"end;return gO end;local perisPanelID;local fL=g7(1770)local fM=g8(350)local fK=g8(15)local fJ=g7(1370)local bC,lq;local peris=0;function kU.DrawRadarInfo()fO=aS.GetRadarHud(fJ,fK,fL,fM)end;function kU.DrawTanks()if fuelX~=0 and fuelY~=0 then gd=bT(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gu(fuelX,"Atmospheric ","ATMO",aF,gs,gt)gu(fuelX,"Space Fuel T","SPACE",aG,gq,gr)gu(fuelX,"Rocket Fuel ","ROCKET",aH,go,gp)end end;function kU.DrawShield()local lr=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local ls=core.getPvPTimer()local lt=shield_1.getResistances()local lu="A: "..10+lt[1]*100 .."% / E: "..10+lt[2]*100 .."% / K:"..10+lt[3]*100 .."% / T: "..10+lt[4]*100 .."%"local bU,bV=shieldX-60,shieldY+30;local lv=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gI=e(lv*2.55)local gJ=f("rgb(%d,%d,%d)",255-gI,gI,0)local bX=""ge=bT(bU,bV,"","txtmid pdim txtfuel")if lv<10 and lr~="Shield Disabled"then bX="red "end;ls=ls>0 and"   PvPTime: "..c4(ls)or""ge=ge..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bU,bV,gJ,lv*2,bU,bV,bU+2,bV+10,lv,ls)ge=ge..bT(bU,bV-5,lr,bX.."txtstart pbright txtbig")ge=ge..bT(bU,bV+30,lu,bX.."txtstart pbright txtsmall")end;function kU.hudtick()if not planet then return end;local function lw(gO)local gL=e(r(aj/(aD/4)*255,0,255))gO[#gO+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+gL,e(J+0.5)-gL,e(I+0.5)-gL)end;local function lx()for _,ce in pairs(fR)do if ce.hovered then if not ce.drawCondition or ce.drawCondition(ce)then ce.toggleFunction(ce)end;ce.hovered=false end end;for _,ce in pairs(bw)do if ce.hovered then SelectedTab=ce.label;ce.hovered=false end end end;local function ly()local function lz(lA,lB,bU,bV,kj,kk)if lA>=bU and lA<=bU+kj and lB>=bV and lB<=bV+kk then return true else return false end end;local bU=ag+aD/2;local bV=ah+aE/2;for _,ce in pairs(fR)do ce.hovered=lz(bU,bV,ce.x,ce.y,ce.width,ce.height)end;for _,ce in pairs(bw)do ce.hovered=lz(bU,bV,ce.x,ce.y,ce.width,ce.height)end;if bu then local jZ=false;for _,c0 in ipairs(apExtraButtons)do if c0.hovered then jZ=true;break end end;if apbutton.hovered then jZ=true end;bu=jZ else bu=apbutton.hovered;if not bu then bv=AutopilotTargetIndex end end end;local function lC(gO)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;if showHud then for cd,ce in pairs(bw)do local bX="dim brightstroke"local lD=0.2;if SelectedTab==cd then bX="pbright dimstroke"lD=0.6 end;local lE=""if ce.hovered then lD=0.8;lE=";stroke:white"end;gO[#gO+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],ce.width,ce.height,ce.x,ce.y,bX,lD,lE)gO[#gO+1]=bT(ce.x+ce.width/2,ce.y+ce.height/2+5,ce.label,"txt txtmid pdim")end end end;local function lF(gO)local function lG(gO,lH,hover,bU,bV,dY,lI,lJ,lK,lL,lM,button)if type(lL)=="function"then lL=lL(button)end;if type(lM)=="function"then lM=lM(button)end;gO[#gO+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bU,bV,dY,lI)if lH then gO[#gO+1]=f("%s'",lJ)else gO[#gO+1]=lK end;if hover then gO[#gO+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gO[#gO+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gO[#gO+1]=" rx='5'></rect>"gO[#gO+1]=f("<text x='%f' y='%f' font-size='24' fill='",bU+dY/2,bV+lI/2+5)if lH then gO[#gO+1]="black"else gO[#gO+1]="white"end;gO[#gO+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lH then gO[#gO+1]=f("%s</text>",lL)else gO[#gO+1]=f("%s</text>",lM)end end;local lN=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local lO=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local lP=lG;for _,ce in pairs(fR)do local ko=ce.disableName;local kn=ce.enableName;if type(ko)=="function"then ko=ko(ce)end;if type(kn)=="function"then kn=kn(ce)end;if not ce.drawCondition or ce.drawCondition(ce)then lP(gO,ce.toggleVar(ce),ce.hovered,ce.x,ce.y,ce.width,ce.height,lO,lN,ko,kn,ce)end end end;local lQ=A(aD/2,0)local lR=A(aE/2,0)local gO={}aP.HUDPrologue(gO)if showHud then aP.UpdateHud(gO)else if AlwaysVSpd then aP.DrawVerticalSpeed(gO,as)end;aP.DrawWarnings(gO)end;if fX and fY~={}then aP.DrawSettings(gO)end;if radar_1 then aP.DrawRadarInfo()end;aP.HUDEpilogue(gO)gO[#gO+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aD,aE)if a2~="empty"then aP.DisplayMessage(gO,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aP.DrawDeadZone(gO)end end;lC(gO)if x()==0 then if m()==1 and a1 then if not AltIsOn then ly()lF(gO)end;if not aT and not aU then local lS=table.concat(gO,"")gO={}gO[#gO+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gO[#gO+1]=lS;gO[#gO+1]="</body>"aT=true;gO[#gO+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gO,"")system.setScreen(content)elseif aU then local lS=table.concat(gO,"")gO={}gO[#gO+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gO[#gO+1]=lS;gO[#gO+1]="</body>"end;if not aT then gO[#gO+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lQ,lR,ag,ah)end else lx()end else if not a1 and m()==0 then lx()if aj>DeadZone then if DisplayDeadZone then lw(gO)end end elseif a1 and(not AltIsOn or not freeLookToggle)then ly()lF(gO)end;gO[#gO+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lQ,lR,ag,ah)end;gO[#gO+1]=[[</svg></body>]]content=table.concat(gO,"")end;function kU.TenthTick()aP.DrawTanks()if shield_1 then aP.DrawShield()end end;function kU.OneSecond(gO)local function lT()local gE=q()local h_=bc;local lU=gE-au;if h_>1.38889 then h_=h_/1000;local lV=h_*(gE-au)TotalDistanceTravelled=TotalDistanceTravelled+lV;ad=ad+lV end;ae=ae+lU;TotalFlightTime=TotalFlightTime+lU;au=gE end;lT()aP.UpdatePipe()aP.ExtraData(gO)end;function kU.ButtonSetup()kw()kB()fR=fS end;return kU end;local function lW()local function lX(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function lY()local function lZ(l_,m0)return l_.name<m0.name end;bm={}for cd,ce in pairs(b[0])do bm[#bm+1]={name=ce.name,index=cd}end;table.sort(bm,lZ)end;local function m1(m2)for cd,ce in pairs(m2)do if ce.name and ce.name==CustomTarget.name then return cd end end;return-1 end;local function m3()bv=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local m4=bm[AutopilotTargetIndex].index;local m5=b[0][m4]if m5.center then AutopilotTargetName=m5.name;ac=aL[0][m4]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=m5;for _,ce in pairs(aL[0])do if ce.name==CustomTarget.planetname then ac=ce;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function m6(gS)if not Autopilot and not VectorToTarget and not am and not IntoOrbit and not Reentry and not an then if gS==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bm end end;if AutopilotTargetIndex==0 then m3()else local m4=bm[AutopilotTargetIndex].index;local m5=b[0][m4]if m5~=nil and m5.name=="Space"or iphCondition=="Custom Only"and m5.center or iphCondition=="No Moons"and string.find(m5.name,"Moon")~=nil then if gS==nil then m6()else m6(1)end else m3()end end else a2="Disengage autopilot before changing Interplanetary Helper"bG("iph","AP")end end;local function kH()local fk=-1;fk=m1(b[0])if fk>-1 then table.remove(b[0],fk)end;fk=-1;fk=m1(SavedLocations)if fk~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fk)end;m6()lY()end;local function kC(fz,position,hz,m7)if dbHud_1 or hz then local p=lX(position)local l8=p.gravity;if m7 then l8=unit.getClosestPlanetInfluence()end;local m8={position=position,name=fz,planetname=p.name,gravity=l8,safe=m7}if not hz then SavedLocations[#SavedLocations+1]=m8 else for cd,ce in pairs(b[0])do if ce.name and fz==ce.name then table.remove(b[0],cd)end end end;table.insert(b[0],m8)lY()m3()a2="Location saved as "..fz.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local m9={}function m9.UpdateAtlasLocationsList()lY()end;function m9.UpdateAutopilotTarget()m3()end;function m9.adjustAutopilotTargetIndex(gS)m6(gS)end;function m9.findAtlasIndex(m2)m1(m2)end;function m9.UpdatePosition(ma)local fk=m1(SavedLocations)if fk~=-1 then if ma~=nil then SavedLocations[fk].name=ma;AutopilotTargetIndex=AutopilotTargetIndex-1;m6()else local mb=SavedLocations[fk]mb.gravity=unit.getClosestPlanetInfluence()mb.position=bf;mb.safe=true end;a2=SavedLocations[fk].name.." position updated ("..SavedLocations[fk].planetname..")"else a2="Name Not Found"end end;function m9.AddNewLocation(fz,position,hz,m7)kC(fz,position,hz,m7)end;function m9.ClearCurrentPosition()kH()end;for cd,ce in pairs(SavedLocations)do table.insert(b[0],ce)end;lY()if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end;m9.UpdateAutopilotTarget()return m9 end;local function mc()local md={}local function me(e4)local mf=AutopilotEndSpeed;if not Autopilot then mf=0 end;if not aq then return aM.computeDistanceAndTime(e4,mf,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aM.computeDistanceAndTime(e4,mf,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function mg(e4)local mf=AutopilotEndSpeed;if not Autopilot then mf=0 end;return aM.computeDistanceAndTime(e4,mf,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local mh=false;local mi=0;local mj=0;local mk=0;local ml=q()local mm=0;local mn=0;local mo=0;local mp=0;local mq=false;local mr=false;local ms=false;local mt=nil;local mu=0;function md.GetAutopilotBrakeDistanceAndTime(e4)return me(e4)end;function md.GetAutopilotTBBrakeDistanceAndTime(e4)return mg(e4)end;local function mv(mw,mx,my)mx=mx:project_on_plane(mw)my=my:project_on_plane(mw)return n(mx:cross(my):dot(mw),mx:dot(my))end;local function mz()local function mA()local mB=-1;local mC=-1;if vBooster then mB=vBooster.getDistance()end;if hover then mC=hover.getDistance()end;if mB~=-1 and mC~=-1 then if mB<mC then return mB else return mC end elseif mB~=-1 then return mB elseif mC~=-1 then return mC else return-1 end end;local mD=mA()local mE=-1;if telemeter_1 then mE=telemeter_1.getDistance()end;if mD~=-1 and mE~=-1 then if mD<mE then return mD else return mE end elseif mD~=-1 then return mD else return mE end end;local function mF(planet,dr,mG)local function mH(mI,cJ)local dx=vec3(cJ)if mI.id==0 then return setmetatable({latitude=dx.x,longitude=dx.y,altitude=dx.z,id=0,systemId=mI.systemId},MapPosition)end;local dy=dx-mI.center;local aj=dy:len()local cP=aj-mI.radius;local cN=0;local cO=0;if not bZ(aj,0)then local dz=n(dy.y,dy.x)cO=dz>=0 and dz or 2*math.pi+dz;cN=math.pi/2-math.acos(dy.z/aj)end;return setmetatable({latitude=math.deg(cN),longitude=math.deg(cO),altitude=cP,id=mI.id,systemId=mI.systemId},MapPosition)end;local mJ=mH(planet,dr)mJ="::pos{"..mJ.systemId..","..mJ.id..","..mJ.latitude..","..mJ.longitude..","..mJ.altitude.."}"if mG then return mJ else system.setWaypoint(mJ)return true end end;local mK=false;function md.showWayPoint(planet,dr,mG)return mF(planet,dr,mG)end;function md.APTick()local function mL()if bt and not BrakeLanding then local d9=bt[1]local fA,fB=bt[2],bt[3]local mM=math.min(fA,fB or fA)local mN=mM/bc;local mO=AutoTakeoff and(bc<42 or ao~=-1)local mP=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mP and not mO and(a8*1.5>mM or mN<1)then BrakeIsOn=true;aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()end;if LockPitch then aR.ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then aR.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aV=true end;if mN<11 then bs=d9.name.." COLLISION "..c4(mN).." / "..c1(mM,2)else bs=d9.name.." collision "..c4(mN)end;if mN<6 then bG("alarm","AL",2)end else bs=false end end;local function mQ(mR,mS,mT)local function mU(mR,db)mR=vec3(mR)db=vec3(db):normalize()local cu=mR*db;return cu.x+cu.y+cu.z end;local mV=0.001;local mW=1;if not aq or not aX or ao~=-1 or bc<Q then if mT==nil then mT=DampingMultiplier end;if mS==nil then mS=mV end;mR=vec3(mR):normalize()local mX=vec3()-mR;local mY=-mU(mX,core.getConstructWorldOrientationRight())*mW;local mZ=-mU(mX,core.getConstructWorldOrientationUp())*mW;if mj==0 then mj=mY/2 end;if mk==0 then mk=mZ/2 end;if d(mY)<0.1 then V=V-mY*2 else V=V-(mY+(mY-mj)*mT)end;if d(mZ)<0.1 then U=U+mZ*2 else U=U+mZ+(mZ-mk)*mT end;mj=mY;mk=mZ;if d(mY)<mS and d(mZ)<mS then return true end;return false elseif aX and ao==-1 then mR=bb;if mT==nil then mT=DampingMultiplier end;if mS==nil then mS=mV end;mR=vec3(mR):normalize()local mX=b8-mR;local mY=-mU(mX,core.getConstructWorldOrientationRight())*mW;local mZ=-mU(mX,core.getConstructWorldOrientationUp())*mW;if mj==0 then mj=mY/2 end;if mk==0 then mk=mZ/2 end;if d(mY)<0.1 then V=V-mY*5 else V=V-(mY+(mY-mj)*mT)end;if d(mZ)<0.1 then U=U+mZ*5 else U=U+mZ+(mZ-mk)*mT end;mj=mY;mk=mZ;if d(mY)<mS and d(mZ)<mS then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=mz()E=q()ml=E;if CollisionSystem then mL()end;if antigrav then bh=antigrav.getState()==1 end;local m_=1;local n0=1;local n1=E-ml;local n2=-math.deg(mv(b7,bb,b8))local n3=math.deg(mv(b9,bb,b8))local gS=bd*-1;aX=aq and n2<-YawStallAngle or n2>YawStallAngle or n3<-PitchStallAngle or n3>PitchStallAngle;local n4=system.getMouseDeltaX()local n5=system.getMouseDeltaY()if InvertMouse and not a1 then n5=-n5 end;V=0;Z=0;U=0;sys=aL[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aO(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bb)if as==0 then as=(bf-planet.center):len()-planet.radius end;br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local l8=planet:getGravity(core.getConstructWorldPos()):len()*av;aY=0;aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aT then ag=r(ag+n4,-aD/2,aD/2)ah=r(ah+n5,-aE/2,aE/2)end else ag=0;ah=0 end else ag=r(ag+n4,-aD/2,aD/2)ah=r(ah+n5,-aE/2,aE/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then local hM,hN=1,1;if SelectedTab=="SCOPE"then hM,hN=bA/90,bA/90 end;if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity*hM elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity*hM else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity*hN elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity*hN else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(n5,-100,100)+0.5)*2*m_;V=(-utils.smoothstep(n4,-100,100)+0.5)*2*n0 end end end end;local n6=bc>8334;if bc>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not n6 then a2="Space Speed Engine Shutoff reached"aR.cmdThrottle(0)end;if not n6 and LastIsWarping then if not BrakeIsOn then aR.BrakeToggle()end;if Autopilot then aR.ToggleAutopilot()end end;LastIsWarping=n6;if aq and ar>0.09 then if bc>aZ/3.6 and not AtmoSpeedAssist and not mh then BrakeIsOn=true;mh=true elseif not AtmoSpeedAssist and mh then if bc<aZ/3.6 then BrakeIsOn=false;mh=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local n7=false;if CustomTarget and al~=1 then n7=mQ(CustomTarget.position-bf,0.1)else n7=mQ(vec3(bb),0.01)end;aV=true;if n7 then aR.cmdCruise(e(aZ))if(d(bl)<2 or d(bk)>85)and bc>=aZ/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;aR.BeginReentry()end elseif aq and AtmoSpeedAssist then aR.cmdThrottle(1)end elseif bc>Q then mQ(vec3(bb),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bc>Q then mQ(-vec3(bb))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;aR.BeginReentry()al=false;an=true else al=false;aR.ToggleAutopilot()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bc*3.6>aZ-250 and d(be)<25 and ar>=0.1 and(CustomTarget.position-bf):len()>2000+as then aR.ToggleAutopilot()an=false end;if VertTakeOff then aV=true;local n8=HoldAltitude;if be<-30 then a2="Unable to achieve lift. Safety Landing."af=0;aV=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bh or HoldAltitude<planet.spaceEngineMinAltitude then if bh then n8=antigrav.getBaseAltitude()end;if as<n8-100 then a_=0;af=15;BrakeIsOn=false elseif be>0 then BrakeIsOn=true;af=0 elseif be<-30 then BrakeIsOn=true;af=15 elseif as>=n8 then if bh then if Autopilot or VectorToTarget then aR.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bG("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bG("vtoc","VT")aR.ToggleVerticalTakeoff()end;af=0 end else if ar>0.08 then a_=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if b5 then a_=0;af=20 else af=0;a_=36;aR.cmdCruise(3500)end else aV=autoRollPreference;IntoOrbit=true;b3=false;CancelIntoOrbit=false;mq=false;mo=nil;mp=nil;if mt==nil then mt=planet end;b2=n8;ms=true;VertTakeOff=false end end;if a_~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local n9=r(a_-bk,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(n9)local na=r(vTpitchPID:get(),-1,1)U=na end end;if IntoOrbit then local mX;local nb=false;local nc=c1(b2)if mt==nil then mt=planet;if VectorToTarget then mt=ac end end;if not ms then b2=e(mt.radius+mt.surfaceMaxAltitude+LowOrbitHeight)if mt.hasAtmosphere then b2=e(mt.radius+mt.noAtmosphericDensityAltitude+LowOrbitHeight)end;ms=true end;if b1.VectorToTarget and CustomTarget then mX=CustomTarget.position-bf end;local nd,ne=aO(mt):escapeAndOrbitalSpeed((bf-mt.center):len()-mt.radius)local nf=bl;if not mq then local ng=false;local nh=false;aR.cmdThrottle(0)mp=0;b0="Aligning to orbital path - OrbitHeight: "..nc;if b1.VectorToTarget then mQ(mX:normalize():project_on_plane(bd))nb=b8:dot(mX:project_on_plane(b7):normalize())>0.95 else mQ(bb)nb=n2<0.5;if bc<150 then nb=true end end;U=0;mo=0;if bk<=mo+1 and bk>=mo-1 then ng=true else ng=false end;if nf<=mp+1 and nf>=mp-1 then nh=true else nh=false end;if ng and nh and nb then mo=nil;mp=nil;mq=true end else if b1.VectorToTarget then mQ(mX:normalize():project_on_plane(bd))elseif bc>150 then mQ(bb)end;U=0;if b1.VectorToTarget and CustomTarget then local a8,_=aM.computeDistanceAndTime(bc,aZ/3.6,av,0,0,LastMaxBrake)if b3 and mX:len()>15000+a8+as then b0="Orbiting to Target"if as-100<=mt.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<mt.noAtmosphericDensityAltitude then b3=false end elseif b3 or mX:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bG("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;b1.VectorToTarget,b1.AutopilotAlign=false,false;aR.ToggleIntoOrbit()aR.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>b2*0.9 and as<b2*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=b2*0.99 and orbit.apoapsis.altitude>=b2*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or b3 then if b3 then BrakeIsOn=false;aR.cmdThrottle(0)mo=0;if not b1.VectorToTarget then a2="Orbit complete"bG("orCom","OB")aR.ToggleIntoOrbit()end else mu=mu+1;if mu>=2 then b3=true end end else b0="Adjusting Orbit - OrbitHeight: "..nc;mr=true;aR.cmdCruise(ne*3.6+1)local ni=b2-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(ni-be*r(utils.smoothstep(2000-ni,-2000,2000)^6*10,1,10))mo=r(VSpdPID:get(),-60,60)end end else local nj=2.75;local nk=d(A(nd*nj))local nl=nk%50;if nl>0 then nk=nk-nl+50 end;BrakeIsOn=false;if as<b2*0.8 then b0="Escaping planet gravity - OrbitHeight: "..nc;mo=utils.map(be,200,0,-15,80)elseif as>=b2*0.8 and as<b2*1.15 then b0="Approaching orbital corridor - OrbitHeight: "..nc;nk=nk*0.75;mo=utils.map(be,100,-100,-15,65)elseif as>=b2*1.15 and as<b2*1.5 then b0="Approaching orbital corridor - OrbitHeight: "..nc;nk=nk*0.75;if be<0 or mr then mo=utils.map(as,b2*1.5,b2*1.01,-30,0)else mo=utils.map(as,b2*0.99,b2*1.5,0,30)end elseif as>b2*1.5 then b0="Reentering orbital corridor - OrbitHeight: "..nc;mo=-65;local nm=utils.map(be,-150,-400,1,0.55)nk=nk*nm end;aR.cmdCruise(e(nk))end end;if mo~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local nn=mo-bk;OrbitPitchPID:inject(nn)local no=r(OrbitPitchPID:get(),-0.5,0.5)U=no end end;if Autopilot and ar==0 and not al then local function np(bC,orbit)system.print(bC)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aR.cmdThrottle(0)P=false;a2=bC;bG("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;b2=as;ms=true end;aR.ToggleIntoOrbit()end end;local nq,nr=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local ns=(CustomTarget.position-ac.center):normalize()local nt=ns:project_on_plane((ac.center-bf):normalize()):normalize()local nu=ac.center+nt*(ac.radius+AutopilotTargetOrbit)local nw=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bf-nu):len()<(bf-nw):len()then nq=nu else nq=nw;AutopilotEndSpeed=0 end;AutopilotTargetCoords=nq;aR.showWayPoint(ac,AutopilotTargetCoords)nr=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;nr=true;AutopilotRealigned=true;TargetSet=true;nq=CustomTarget.position+(bf-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=nq end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local ns=(bf+bb*100000-ac.center):normalize()local nt=ns:project_on_plane((ac.center-bf):normalize()):normalize()if nt:len()<1 then ns=(bf+b8*100000-ac.center):normalize()nt=ns:project_on_plane((ac.center-bf):normalize()):normalize()end;nq=ac.center+nt*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=nq;TargetSet=true;nr=true;AutopilotRealigned=true;aR.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(nq)-bf):len()local iA,dp,dq=aL:getPlanetarySystem(0):castIntersections(bf,bb:normalize(),function(d9)if d9.noAtmosphericDensityAltitude>0 then return d9.radius+d9.noAtmosphericDensityAltitude else return d9.radius+d9.surfaceMaxAltitude*1.5 end end)local iB=dp;if dq~=nil and dp~=nil then iB=math.min(dq,dp)end;if iB~=nil and iB<AutopilotDistance and iA.name==ac.name then AutopilotDistance=iB end;local n7=true;local nx=(ac.center-(bf+vec3(bb):normalize()*AutopilotDistance)):len()-ac.radius;local iq=c1(nx)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..iq..'"}')local a8,a9;if not TurnBurn then a8,a9=me(bc)else a8,a9=mg(bc)end;if bc>50 and AutopilotAccelerating then local mX=vec3(nq)-bf;local ny=r(math.deg(mv(b7,bb:normalize(),mX:normalize()))*bc/500,-90,90)local nz=r(math.deg(mv(b9,bb:normalize(),mX:normalize()))*bc/500,-90,90)if d(ny)<20 and d(nz)<20 then ny=ny*2;nz=nz*2 end;if d(ny)<2 and d(nz)<2 then ny=ny*2;nz=nz*2 end;local n2=-math.deg(mv(b7,b8,bb:normalize()))local n3=-math.deg(mv(b9,b8,bb:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(nz-n3)local nA=r(apPitchPID:get(),-1,1)U=U+nA;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(ny-n2)local nB=r(apYawPID:get(),-1,1)V=V+nB;nr=true;if d(ny)>2 or d(nz)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bG("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end end elseif AutopilotAccelerating and bc<=50 then mQ((nq-bf):normalize())end;if nx<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(nx)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local iA,iB=aR.checkLOS((AutopilotTargetCoords-bf):normalize())if ac.name~=planet.name then if iA~=nil and ac.name~=iA.name and iB<AutopilotDistance then a2="Collision with "..iA.name.." in "..c1(iB).."\nClear LOS to continue."ai=5;mK=true else mK=false;a2=""end end end;if not mK then if not AutopilotCruising and not AutopilotBraking and not nr then n7=mQ((nq-bf):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then n7=mQ(-vec3(bb):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aR.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local nC=unit.getThrottle()if AtmoSpeedAssist then nC=K end;local nD=99999;local lk=-vec3(core.getWorldAcceleration()):dot(bb:normalize())local nE=r(bb:dot((nq-bf):normalize()),0,bc)if nE>0 or lk>0 then nD=aM.computeTravelTime(nE,lk,AutopilotDistance-a8)end;if ba:len()>=MaxGameVelocity or nC==0 and P or warmup/4>nD then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bG("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aR.cmdThrottle(0)end;local nF=AutopilotDistance;if nF<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mi and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mi=bo else mi=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bG("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aR.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aR.cmdThrottle(1,true)end;local _,ne=aO(ac):escapeAndOrbitalSpeed((bf-planet.center):len()-planet.radius)local mX;if CustomTarget then mX=CustomTarget.position-bf end;if CustomTarget and CustomTarget.planetname=="Space"and bc<50 then np("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bc<=ne and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then np("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bG("apCir","AP")AutopilotStatus="Circularizing"end;if bc<=ne then if CustomTarget then if bb:normalize():dot(mX:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bG("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else np("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else np("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then np("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nF=AutopilotDistance;if nF<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mi and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mi=bo else mi=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bG("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local nC=unit.getThrottle()if AtmoSpeedAssist then nC=K end;if nC>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end;AutopilotCruising=false end else if n7 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*b9;AutopilotShipUp=b7;AutopilotShipRight=b9 end;AutopilotRealigned=true elseif n7 and not mK then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end;if not P then aR.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bG("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aR.cmdThrottle(0)P=false;ProgradeIsOn=true;al=true;aR.showWayPoint(ac,CustomTarget.position)end;if a0 then aV=true;local nz=0;local e8=bf+vec3(unit.getMasterPlayerRelativePosition())local nG=e8-bf;local nH=vec3(nG):project_on(b8):len()local nI=vec3(nG):project_on(b9):len()local aj=y(nH*nH+nI*nI)mQ(nG:normalize())local jA=40;local nJ=aj<jA;local nK=100;local nL=r((aj-jA)/2,10,nK)U=0;local n7=d(V)<0.1;if n7 and bc<nL and not nJ then BrakeIsOn=false;nz=-20 else BrakeIsOn=true;nz=0 end;local nM=0;if d(nz-bk)>nM then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(nz-bk)local nA=pitchPID:get()U=nA end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local nN=LastMaxBrakeInAtmo;if nN then nN=nN*r(bc/100,0.1,1)*ar else nN=LastMaxBrake end;if ar<0.01 then nN=LastMaxBrake end;local nO=b8:project_on_plane(bd):normalize():dot(bb)local nP=vec3(core.getWorldAirFrictionAcceleration())local nQ=nP:len()*av;if nO>100 then a8,a9=aM.computeDistanceAndTime(nO,100,av,0,0,nN)local nR,nS=aM.computeDistanceAndTime(100,0,av,0,0,nN*0.55)a8=a8+nR else a8,a9=aM.computeDistanceAndTime(nO,0,av,0,0,nN*0.55)end;local ni=HoldAltitude-as-be;local nT=200+bc;if Reentry or al then minMax=2000+bc end;local nU=1;if AutoTakeoff then nU=r(bc/100,0.1,1)end;local nz=(utils.smoothstep(ni,-nT,nT)-0.5)*2*MaxPitch*nU;if not Reentry and not al and not VectorToTarget and b8:dot(bb:normalize())<0.99 then nz=(utils.smoothstep(ni,-nT*r(20-19*ar*10,1,20),nT*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*nU end;if not AltitudeHold then nz=0 end;if LockPitch~=nil then if br and not IntoOrbit then nz=LockPitch else LockPitch=nil end end;aV=true;local nV=U;if Reentry then local nW=e(aZ)local nX,nY=aM.computeDistanceAndTime(bc,nW/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)nX=nX==-1 and 5000 or nX;local nZ=as-(planet.noAtmosphericDensityAltitude+nX)local n_=as>planet.noAtmosphericDensityAltitude+nX*1.35;if n_ then nz=ReEntryPitch;if bc<=nW/3.6 and bc>nW/3.6-10 and d(bb:normalize():dot(b8))>0.9 and not bj then O=false;aR.cmdThrottle(1)end elseif bj and not n_ and not aq then aR.cmdCruise(nW,true)end;if bj then if bc>nW/3.6 and not n_ then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if be>0 then BrakeIsOn=true end;if not R then nz=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;nz=0;aV=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and n_ then aV=true elseif not n_ then if not aq and(bj or s:getTargetSpeed(axisCommandId.longitudinal)~=nW)then aR.cmdCruise(nW)end;if bc<nW/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;aV=true end end end;if bc>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then mQ(vec3(bb))end;if bp or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local mX;if bp then if type(bp)=="table"then mX=bp elseif bp<3 and bp>0 then mX=-bd:cross(bb)*5000 elseif bp>=3 then mX=bd:cross(bb)*5000 elseif bp<0 then mX=bb*25000 end elseif CustomTarget~=nil then mX=CustomTarget.position-bf else mX=ac.center-bf end;local ny=math.deg(mv(bd:normalize(),bb,mX))*2;local jD=math.rad(d(bl))if bc>minRollVelocity and ar>0.01 then local o0=1000+bc;local o1=(utils.smoothstep(ni-be*10,-o0,o0)-0.5)*2*MaxPitch;local o2=r(90-o1,0,180)aY=r(ny*2,-o2,o2)local o3=ny;ny=r(r(ny,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jD)+4*(bk-nz)*math.sin(math.rad(bl)),-YawStallAngle*0.80,YawStallAngle*0.80)local o4=1;if aY~=0 then o4=d(jD/aY)end;o4=(90-r(d(aY-bl),0,90))/90;local o5=nz;if d(bl)>90 then o5=-o5 end;nz=o4*r(r(o5*math.cos(jD),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(o3)*math.sin(jD),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aY=0;ny=r(ny,-YawStallAngle*0.80,YawStallAngle*0.80)end;local o6=n2-ny;if bp and d(o6)<=0.0001 and(type(bp)=="table"or type(bp)~="table"and bp<0 and d(bl)<1)then if bp==-2 then aR.ToggleAltitudeHold()end;bp=nil;bG("180Off","BR")return end;if not aX and bc>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(o6)local nB=r(yawPID:get(),-1,1)V=V+nB elseif aq and ao>-1 or bc<minRollVelocity then mQ(mX)elseif aX and ar>0.01 then if(n2<-YawStallAngle or n2>YawStallAngle)and ar>0.01 then mQ(bb)end;if(n3<-PitchStallAngle or n3>PitchStallAngle)and ar>0.01 then nz=r(bk-n3,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local n8=planet:getAltitude(CustomTarget.position)local nZ=mX:project_on_plane(bd):len()StrongBrakes=true;if not am and not Reentry and nZ<=a8 and(bb:project_on_plane(bd):normalize():dot(mX:project_on_plane(bd):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(nO<0.1 or nZ<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<nZ)then if not bh then bG("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bs=false end;LastDistanceToTarget=nZ end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local mX=CustomTarget.position-bf;local n8=planet:getAltitude(CustomTarget.position)local nZ=y(mX:len()^2-(as-n8)^2)local nN=LastMaxBrakeInAtmo;if nN then a8,a9=aM.computeDistanceAndTime(bc,0,av,0,0,nN/2)StrongBrakes=true;if nZ<=a8+bc*n1/2 and bb:project_on_plane(bd):normalize():dot(mX:project_on_plane(bd):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;aR.BeginReentry()end end;LastDistanceToTarget=nZ end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not b3 and not IntoOrbit then b2=HoldAltitude;ms=true;if VectorToTarget then b1.VectorToTarget=true end;aR.ToggleIntoOrbit()VectorToTarget=false;mq=true end end;if aX and ar>0.01 and ao==-1 and bc>minRollVelocity and VectorStatus~="Finalizing Approach"then mQ(bb)nz=r(bk-n3,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end;U=nV;local mE=-1;if BrakeLanding then nz=0;local o7=false;local o8=30;if aN~=nil and aN>0 then local o9=r(ar,0.4,2)local nN=LastMaxBrakeInAtmo*r(bc/100,0.1,1)*o9;local oa=aN*o9+nN-l8;local ob=nN/2-l8;local oc=bc-y(d(ob/2)*20/(0.5*av))*utils.sign(ob)if oc<0 then oc=0 end;local od;if bc>100 then local oe,_=aM.computeDistanceAndTime(bc,100,av,0,0,nN)local of,_=aM.computeDistanceAndTime(100,0,av,0,0,y(nN))od=oe+of else od=aM.computeDistanceAndTime(bc,0,av,0,0,y(nN))end;if od<20 then BrakeIsOn=false else local og=0;if oc>100 then local oh,_=aM.computeDistanceAndTime(oc,100,av,0,0,oa)local oi,_=aM.computeDistanceAndTime(100,0,av,0,0,aN*o9+y(nN)-l8)og=oh+oi else og,_=aM.computeDistanceAndTime(oc,0,av,0,0,aN*o9+y(nN)-l8)end;og=(og+15+bc*n1)*1.1;local oj=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if oj then local n8=planet:getAltitude(CustomTarget.position)local ok=as-n8-100;local mX=CustomTarget.position-bf;local ol=y(mX:len()^2-(as-n8)^2)if ol>100 then oj=false elseif ok<=og or og==-1 then BrakeIsOn=true;o7=true else BrakeIsOn=false;o7=true end end;if not oj and CalculateBrakeLandingSpeed then if og>=o8 then BrakeIsOn=true else BrakeIsOn=false end;o7=true end end end;if not bj then aR.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;mE=ao;if mE>-1 then aV=autoRollPreference;if bc<1 or bb:normalize():dot(bd)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bG("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bb:normalize():dot(-gS)<0.999 then BrakeIsOn=true elseif be<-brakeLandingRate and not o7 then BrakeIsOn=true elseif not o7 then BrakeIsOn=false end end;if AutoTakeoff or am then local iA,dq,dp;if AutopilotTargetCoords~=nil then iA,dq,dp=aL:getPlanetarySystem(0):castIntersections(bf,(AutopilotTargetCoords-bf):normalize(),function(d9)return d9.radius+d9.noAtmosphericDensityAltitude end)end;if bh then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aR.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(nz)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bj and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bc<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;aR.cmdThrottle(0)elseif am then aR.cmdThrottle(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(iA==nil or iA.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bj then aR.cmdThrottle(0)end;AutopilotAccelerating=true end end;local om=ao>-1;local on=bk;if(VectorToTarget or am or bp)and not om and bc>minRollVelocity and ar>0.01 then local jD=math.rad(d(bl))on=bk*d(math.cos(jD))+n3*math.sin(jD)end;local oo=r(nz-on,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then oo=r(nz-on,-85,MaxPitch)elseif ar<0.01 then oo=r(nz-on,-MaxPitch,MaxPitch)end;if d(bl)<5 or VectorToTarget or bp or BrakeLanding or om or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(oo)local nA=pitchPID:get()U=U+nA end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function md.ToggleIntoOrbit()b3=false;mo=nil;mp=nil;mu=0;if ar==0 then if IntoOrbit then bG("orOff","AP")IntoOrbit=false;mq=false;mt=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;ms=false elseif br then bG("orOn","AP")IntoOrbit=true;aV=true;if mt==nil then mt=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;mq=false;mt=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;ms=false end end;function md.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aV=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aR.cmdCruise(e(aZ))end else b3=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function md.checkLOS(mR)local iA,dp,dq=aL:getPlanetarySystem(0):castIntersections(bf,mR,function(d9)if d9.noAtmosphericDensityAltitude>0 then return d9.radius+d9.noAtmosphericDensityAltitude else return d9.radius+d9.surfaceMaxAltitude*1.5 end end)local iB=dp;if dq~=nil and dp~=nil then iB=math.min(dq,dp)end;if iB~=nil then return iA,iB else return nil,nil end end;function md.ToggleAutopilot()local function op(SpaceTarget)bs=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aR.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if E-mn<1.5 and ar>0 then if not b6 then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bG("orH","OH")end;mn=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else mn=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aQ.UpdateAutopilotTarget()aR.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bG("apSpc","AP")if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bG("vtt","AP")op(SpaceTarget)end else bG("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then b3=false;Autopilot=true elseif not aq then if IntoOrbit then aR.ToggleIntoOrbit()end;b2=planet.noAtmosphericDensityAltitude+LowOrbitHeight;ms=true;b1.AutopilotAlign=true;b1.VectorToTarget=true;mq=false;if not IntoOrbit then aR.ToggleIntoOrbit()end end end else bG("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and br)and not IntoOrbit then WaypointSet=false;b3=false;mq=false;aR.ToggleIntoOrbit()else bG("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bG("apP","AP")am=true;aR.ToggleAltitudeHold()end else bG("apOff","AP")aR.ResetAutopilots(1)end end;function md.cmdThrottle(cz,oq)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not oq then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cz)K=r(A(cz*100,0)/100,-1,1)bi=nil end;function md.cmdCruise(cz,oq)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not oq then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cz)bi=cz end;function md.ToggleLockPitch()if LockPitch==nil then bG("lkPOn","LP")if not a1 then LockPitch=bk else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bG("lkPOff","LP")LockPitch=nil end end;function md.ToggleAltitudeHold()if E-mm<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bG("11","EP")else if br then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b2=HoldAltitude;ms=true;if not IntoOrbit then aR.ToggleIntoOrbit()end;mq=true end end;mm=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else mm=E end;if br and ar==0 then b2=as;ms=true;mq=true;aR.ToggleIntoOrbit()if IntoOrbit then mm=E else mm=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;aV=true;LockPitch=nil;b3=false;if ao~=-1 and bc<20 then bG("lfs","LS")AutoTakeoff=true;if mm>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bg then aR.ToggleVerticalTakeoff()end else bG("altOn","AH")AutoTakeoff=false;if mm>-1 then if br then HoldAltitude=as end end;if VertTakeOff then aR.ToggleVerticalTakeoff()end end;if am then HoldAltitude=100000 end else bG("altOff","AH")if IntoOrbit then aR.ToggleIntoOrbit()end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;aV=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;mm=0 end end;function md.ResetAutopilots(md)if md then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bp=nil;if not bh then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;if IntoOrbit then aR.ToggleIntoOrbit()end;aV=autoRollPreference;al=false;an=false;af=0 end;function md.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aV=autoRollPreference end;if BrakeIsOn then bG("bkOn","B",1)aR.ResetAutopilots()else bG("bkOff","B",1)end end;function md.BeginReentry()if Reentry then a2="Re-Entry cancelled"bG("reOff","RE")Reentry=false;aV=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;aV=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aZ;bG("par","RE")else Reentry=true;AltitudeHold=true;aV=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bW=c1(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..aZ.." Target Altitude: "..bW;bG("glide","RE")aR.cmdCruise(e(aZ))end;AutoTakeoff=false end;function md.ToggleAntigrav()if antigrav and not ExternalAGG then if bh then bG("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bG("aggOn","AG")antigrav.activate()antigrav.show()end end end;ao=mz()return md end;function script.onStart()local os=false;local function ot()local function ou(ov)local ow=dbHud_1.hasKey;for cd,ce in pairs(ov)do if ow(ce)then local cu=g(dbHud_1.getStringValue(ce))if cu~=nil then _G[ce]=cu;os=true end end end end;if dbHud_1 then if not useTheseSettings then ou(bM())coroutine.yield()ou(c)else ou(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;os=false end;coroutine.yield()if os then a2="Loaded Saved Variables"aD=ResolutionX;aE=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aV=autoRollPreference;aZ=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function ox()local function oy(oz,oA)if oz>oA then oA=oz end;local oB,oC=0,0;if ContainerOptimization>0 then oB=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then oC=FuelTankOptimization*0.05 end;oA=oA*(1-(oB+oC))return oA end;local oD=core.getElementNameById;local oE=fuelX~=0 and fuelY~=0;for cd in pairs(at)do local type=core.getElementTypeById(at[cd])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cd])),'^.*vertical.*$')and core.getElementForwardById(at[cd])[3]>0 then bg=true end end;if o(type,'^.*Space Engine$')then b6=true;if o(tostring(core.getElementTagsById(at[cd])),'^.*vertical.*$')then local oF=core.getElementForwardById(at[cd])if oF[3]<0 then b4=true else b5=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local oG=j(at[cd])if oG>10000 then G=110 elseif oG>1000 then G=55 elseif oG>150 then G=27 end end;aI=aI+j(at[cd])if oE and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local oG=j(at[cd])local lg=l(at[cd])local oz=0;local gE=q()if type=="Atmospheric Fuel Tank"then local oA=400;local oH=35.03;if oG>10000 then oA=51200;oH=5480 elseif oG>1300 then oA=6400;oH=988.67 elseif oG>150 then oA=1600;oH=182.67 end;oz=lg-oH;if fuelTankHandlingAtmo>0 then oA=oA+oA*fuelTankHandlingAtmo*0.2 end;oA=oy(oz,oA)aF[#aF+1]={at[cd],oD(at[cd]),oA,oH,oz,gE}end;if type=="Rocket Fuel Tank"then local oA=320;local oH=173.42;if oG>65000 then oA=40000;oH=25740 elseif oG>6000 then oA=5120;oH=4720 elseif oG>700 then oA=640;oH=886.72 end;oz=lg-oH;if fuelTankHandlingRocket>0 then oA=oA+oA*fuelTankHandlingRocket*0.1 end;oA=oy(oz,oA)aH[#aH+1]={at[cd],oD(at[cd]),oA,oH,oz,gE}end;if type=="Space Fuel Tank"then local oA=600;local oH=35.03;if oG>10000 then oA=76800;oH=5480 elseif oG>1300 then oA=9600;oH=988.67 elseif oG>150 then oA=2400;oH=182.67 end;oz=lg-oH;if fuelTankHandlingSpace>0 then oA=oA+oA*fuelTankHandlingSpace*0.2 end;oA=oy(oz,oA)aG[#aG+1]={at[cd],oD(at[cd]),oA,oH,oz,gE}end end end;if not bg then VertTakeOff,VertTakeOffEngine=false,false end end;local function oI()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,ce in pairs(door)do ce.toggle()end end;if switch then for _,ce in pairs(switch)do ce.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,ce in pairs(forcefield)do ce.toggle()end end;if antigrav then bh=antigrav.getState()==1;if bh and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and ba:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(aW)if aq and ao~=-1 then aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function oJ()local oK={}local function oL()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local oM={[1]=4480,[6]=4480,[7]=6270}for oN,oO in pairs(b)do b[oN][0]=oL()b[oN][0].systemId=oN;oK[oN]={}for oP,planet in pairs(b[oN])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=oM[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=oN;planet.bodyId=planet.id;oK[oN][oP]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bz[#bz+1]=planet end end end;aK=cf()aL=aK(oK)aM=dD()aO=e6()aQ=lW()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})ot()coroutine.yield()ox()coroutine.yield()aR=mc()oI()coroutine.yield()oJ()aS=eu()aP=fP()aP.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bG("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,ce in pairs(door)do ce.toggle()end end;if switch then for _,ce in pairs(switch)do ce.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,ce in pairs(forcefield)do ce.toggle()end end;showHud=bB;c9()if button then button.activate()end;if SetWaypointOnExit then aR.showWayPoint(planet,bf)end;bG("stop","SU")end;function script.onTick(oQ)local oR=nil;if oQ=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bG("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif oQ=="tenthSecond"then local function oS()local oT=system.createData;local oU=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=oU(panelInterplanetary,"value")interplanetaryHeaderText=oT('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=oU(panelInterplanetary,"value")widgetDistanceText=oT('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=oU(panelInterplanetary,"value")widgetTravelTimeText=oT('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=oU(panelInterplanetary,"value")widgetMaxMassText=oT('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=oU(panelInterplanetary,"value")widgetTargetOrbitText=oT('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=oU(panelInterplanetary,"value")widgetCurBrakeDistanceText=oT('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=oU(panelInterplanetary,"value")widgetCurBrakeTimeText=oT('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=oU(panelInterplanetary,"value")widgetMaxBrakeDistanceText=oT('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=oU(panelInterplanetary,"value")widgetMaxBrakeTimeText=oT('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=oU(panelInterplanetary,"value")widgetTrajectoryAltitudeText=oT('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function oV()t(panelInterplanetary)panelInterplanetary=nil end;local function oW()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bf):len()else AutopilotDistance=(CustomTarget.position-bf):len()end end;local e4=bc;local nC=unit.getThrottle()/100;if AtmoSpeedAssist then nC=K end;local oX,oY=aM.computeDistanceAndTime(bc,MaxGameVelocity,av,a:maxForceForward()*nC,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,oZ;if not TurnBurn and e4>0 then _,oZ=aR.GetAutopilotBrakeDistanceAndTime(e4)else _,oZ=aR.GetAutopilotTBBrakeDistanceAndTime(e4)end;local o_=0;local p0=0;if AutopilotCruising or not Autopilot and e4>5 then p0=aM.computeTravelTime(e4,0,AutopilotDistance)elseif a8+oX<AutopilotDistance then o_=AutopilotDistance-(a8+oX)p0=aM.computeTravelTime(8333.0556,0,o_)else local p1=(AutopilotDistance-a8)/oX;oX=AutopilotDistance-a8;oY=oY*p1 end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return p0 elseif AutopilotBraking then return oZ elseif AutopilotCruising then return p0+oZ else return oY+a9+p0 end end;local function p2(l8,p3)if l8==nil then l8=core.g()end;l8=A(l8,5)if p3~=nil and p3 or(oR==nil or oR~=l8)then local e4=ba:len()local p4=g(unit.getData()).maxBrake;if p4~=nil and p4>0 and aq then p4=p4/r(e4/100,0.1,1)p4=p4/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+p4)/2 else LastMaxBrakeInAtmo=p4 end end end;if p4~=nil and p4>0 then LastMaxBrake=p4 end;oR=l8 end end;p2(nil,true)if bi~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bi then aR.cmdCruise(bi)else bi=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then oS()end;if AutopilotTargetName~=nil then local p5=CustomTarget~=nil;local p6=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()p6=p6>1000000 and A(p6/1000000,2).." kTons"or A(p6/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=oW()if p5 and not Autopilot then aj=(bf-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bf):len()end;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local iq=c1(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..iq..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..c4(travelTime)..'", "unit":""}')iq=c1(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..iq..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..c4(a9)..'", "unit":""}')iq=c1(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..iq..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..c4(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",p6)..'", "unit":""}')iq=c1(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..iq..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bj and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then aR.cmdThrottle(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else oV()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aP.TenthTick()elseif oQ=="oneSecond"then local function p7(gO)local p8=0;aB=""local p9=aI;local pa=0;local pb=0;local pc=0;local gI=0;local gJ=""local pd=core.getElementHitPointsById;for cd in pairs(at)do local oG=0;local pe=0;pe=j(at[cd])oG=pd(at[cd])pa=pa+oG;if oG<pe then if oG==0 then pc=pc+1 else pb=pb+1 end;if aJ and#aA==0 then position=vec3(core.getElementPositionById(at[cd]))local bU=position.x;local bV=position.y;local f1=position.z;table.insert(aA,core.spawnArrowSticker(bU,bV,f1+1,"down"))table.insert(aA,core.spawnArrowSticker(bU,bV,f1+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(bU+1,bV,f1,"north"))table.insert(aA,core.spawnArrowSticker(bU+1,bV,f1,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(bU-1,bV,f1,"south"))table.insert(aA,core.spawnArrowSticker(bU-1,bV,f1,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(bU,bV-1,f1,"east"))table.insert(aA,core.spawnArrowSticker(bU,bV-1,f1,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(bU,bV+1,f1,"west"))table.insert(aA,core.spawnArrowSticker(bU,bV+1,f1,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cd])end elseif aJ and#aA>0 and aA[11]==at[cd]then for gD in pairs(aA)do core.deleteSticker(aA[gD])end;aA={}end end;p8=e(pa/p9*100)if p8<100 then gO[#gO+1]=bT(0,0,"","pbright txt")gI=e(p8*2.55)gJ=f("rgb(%d,%d,%d)",255-gI,gI,0)if p8<100 then gO[#gO+1]=bT("50%",1035,"Elemental Integrity: "..p8 .."%","txtbig txtmid","fill:"..gJ)if pc>0 then gO[#gO+1]=bT("50%",1055,"Disabled Modules: "..pc.." Damaged Modules: "..pb,"txtbig txtmid","fill:"..gJ)elseif pb>0 then gO[#gO+1]=bT("50%",1055,"Damaged Modules: "..pb,"txtbig txtmid","fill:"..gJ)end end end end;local function pf()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bx=core.getPlayersOnBoard()by=core.getDockedConstructs()pf()local gO={}aP.OneSecond(gO)if ShouldCheckDamage then p7(gO)end;ak=table.concat(gO,"")collectgarbage("collect")elseif oQ=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cu=g(dbHud_1.getStringValue("SavedLocations"))if cu~=nil then _G["SavedLocations"]=cu;local fk=-1;local m8;for cd,ce in pairs(SavedLocations)do if ce.name and ce.name=="SatNav Location"then fk=cd;break end end;if fk~=-1 then m8=SavedLocations[fk]fk=-1;for cd,ce in pairs(b[0])do if ce.name and ce.name=="SatNav Location"then fk=cd;break end end;if fk>-1 then b[0][fk]=m8 end;aQ.UpdateAtlasLocationsList()a2=m8.name.." position updated"end end;for i=1,#bm do if bm[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bm[i].name)aQ.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif oQ=="msgTick"then local gO={}aP.DisplayMessage(gO,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif oQ=="animateTick"then aU=true;aT=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif oQ=="hudTick"then aP.hudtick()elseif oQ=="apTick"then aR.APTick()elseif oQ=="radarTick"then aS.UpdateRadar()elseif oQ=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function pg(ph,nL)local pi=vec3()local pj=vec3()if ph==axisCommandId.longitudinal then pi=vec3(core.getConstructOrientationForward())pj=b8 elseif ph==axisCommandId.vertical then pi=vec3(core.getConstructOrientationUp())pj=b7 elseif ph==axisCommandId.lateral then pi=vec3(core.getConstructOrientationRight())pj=b9 else return vec3()end;local pk=vec3(core.getWorldGravity())local pl=pk:dot(pj)local pm=vec3(core.getWorldAirFrictionAcceleration())local pn=pm:dot(pj)local po=ba:dot(pi)local pp=nL*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(pp-po)local pq=targetSpeedPID2:get()local pr=(pq-pn-pl)*pj;return pr end;local function ps(ph,nL)local pi=vec3()local pj=vec3()if ph==axisCommandId.longitudinal then pi=vec3(core.getConstructOrientationForward())pj=b8 elseif ph==axisCommandId.vertical then pi=vec3(core.getConstructOrientationUp())pj=b7 elseif ph==axisCommandId.lateral then pi=vec3(core.getConstructOrientationRight())pj=b9 else return vec3()end;local pk=vec3(core.getWorldGravity())local pl=pk:dot(pj)local pm=vec3(core.getWorldAirFrictionAcceleration())local pn=pm:dot(pj)local po=ba:dot(pi)local pp=nL*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(pp-po)local pq=targetSpeedPID:get()local pr=(pq-pn-pl)*pj;return pr end;local function pt(pu,gR,m0)local pv=pu:cross(m0):normalize_inplace()local hD=math.acos(r(pv:dot(-gR),-1,1))*constants.rad2deg;if pv:cross(-gR):dot(m0)<0 then hD=-hD end;return hD end;if antigrav and not ExternalAGG then if not bh and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bj=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bj and O then aR.cmdThrottle(0)O=false elseif not bj and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local pw=r(T+U+system.getControlDeviceForwardInput(),-1,1)local px=r(W+Z+system.getControlDeviceYawInput(),-1,1)local py=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local pz=Y;bd=vec3(core.getWorldVertical())if bd==nil or bd:len()==0 then bd=(planet.center-bf):normalize()end;b7=vec3(core.getConstructWorldOrientationUp())b8=vec3(core.getConstructWorldOrientationForward())b9=vec3(core.getConstructWorldOrientationRight())bb=vec3(core.getWorldVelocity())ba=vec3(core.getVelocity())bf=vec3(core.getConstructWorldPos())av=core.getConstructMass()bc=vec3(bb):len()be=-bd:dot(bb)bl=getRoll(bd,b8,b9)local pA=bl/180*math.pi;local pB=math.cos(pA)local pC=math.sin(pA)bk=pt(bd,b8,b9*pB+b7*pC)local pD=bb:normalize()local pE=d(bl)local pF=utils.sign(bl)local pG=vec3(core.getWorldAngularVelocity())local pH=pw*pitchSpeedFactor*b9+px*rollSpeedFactor*b8+py*yawSpeedFactor*b7;if aV==true and bd:len()>0.01 then local pI=d(aY-bl)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and pI>0 or ar>0.0 and pI<autoRollRollThreshold and autoRollPreference)and px==0 and d(bk)<85 then local pJ=aY;local pK=autoRollFactor;if ar==0 then pK=pK/4;aY=0;pJ=0 end;if rollPID==nil then rollPID=pid.new(pK*0.01,0,pK*0.1)end;rollPID:inject(pJ-bl)local pL=rollPID:get()pH=pH+pL*b8 end end;local pM=1;local pN=0;local pO=1;local pP=system.getMouseWheel()if pP>0 then bD()elseif pP<0 then bD(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bj then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aZ/3.6-bb:dot(b8))local pQ=throttlePID:get()N=r(pQ,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-aZ/3.6)local pR=r(brakePID:get(),0,1)if ar>0 and be<-80 or ar>0.005 then L=pR end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pS=''local pT=vec3()local pU=pg(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pU,pN)local pV='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pV=pV..ExtraLongitudeTags end;local pW=s:getAxisCommandType(axisCommandId.longitudinal)local pX=s:composeAxisAccelerationFromThrottle(pV,axisCommandId.longitudinal)local pY=ps(axisCommandId.lateral,LeftAmount*1000)pS=pS..' , '.."lateral airfoil , lateral ground "pT=pT+pY;if pT:len()>constants.epsilon then a:setEngineForceCommand(pS,pT,pN,'','','',pO)end;a:setEngineForceCommand(pV,pX,pM)local pZ='thrust analog vertical fueled 'local p_='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then p_=p_..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then pZ=pZ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(pZ,pU,pM)else a:setEngineForceCommand(pZ,vec3(),pM)end;if LeftAmount~=0 then a:setEngineForceCommand(p_,pY,pM)else a:setEngineForceCommand(p_,vec3(),pM)end;if pz==0 then pz=L end;local q0=-pz*(brakeSpeedFactor*bb+brakeFlatFactor*pD)a:setEngineForceCommand('brake',q0)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local nL=unit.getAxisCommandValue(0)if not bj then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-nL/3.6)local pR=r(brakePID:get(),0,1)pz=r(pz+pR,0,1)end;local q0=-pz*(brakeSpeedFactor*bb+brakeFlatFactor*pD)a:setEngineForceCommand('brake',q0)local pS=''local pT=vec3()local q1=false;local pV='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pV=pV..ExtraLongitudeTags end;local pW=s:getAxisCommandType(axisCommandId.longitudinal)if pW==axisCommandType.byThrottle then local pX=s:composeAxisAccelerationFromThrottle(pV,axisCommandId.longitudinal)a:setEngineForceCommand(pV,pX,pM)elseif pW==axisCommandType.byTargetSpeed then local pX=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pS=pS..' , '..pV;pT=pT+pX;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then q1=true end end;local p_='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then p_=p_..ExtraLateralTags end;local q2=s:getAxisCommandType(axisCommandId.lateral)if q2==axisCommandType.byThrottle then local q3=s:composeAxisAccelerationFromThrottle(p_,axisCommandId.lateral)a:setEngineForceCommand(p_,q3,pM)elseif q2==axisCommandType.byTargetSpeed then local pY=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pS=pS..' , '..p_;pT=pT+pY end;local pZ='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then pZ=pZ..ExtraVerticalTags end;local q4=s:getAxisCommandType(axisCommandId.vertical)if q4==axisCommandType.byThrottle then local pU=s:composeAxisAccelerationFromThrottle(pZ,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(pZ,pU,pM,'airfoil','ground','',pO)else a:setEngineForceCommand(pZ,vec3(),pM)a:setEngineForceCommand('airfoil vertical',pU,pM,'airfoil','','',pO)a:setEngineForceCommand('ground vertical',pU,pM,'ground','','',pO)end elseif q4==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),pM)end;local q5=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pS=pS..' , '..pZ;pT=pT+q5 end;if pT:len()>constants.epsilon then if Y~=0 or q1 or d(pD:dot(b8))<0.5 then pS=pS..', brake'end;a:setEngineForceCommand(pS,pT,pN,'','','',pO)end end;local q6=torqueFactor*(pH-pG)local q7=vec3(core.getWorldAirFrictionAngularAcceleration())q6=q6-q7;a:setEngineTorqueCommand('torque',q6,pM,'airfoil','','',pO)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local e4=ba:len()local q8=0.15;if not bj then local q9=s:getTargetSpeed(axisCommandId.longitudinal)if e4*3.6>q9*(1-q8)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4*3.6<q9*(1-q8)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nC=unit.getThrottle()if AtmoSpeedAssist then nC=K*100 end;local nL=nC/100;if k==0 then nL=nL*MaxGameVelocity;if e4>=nL*(1-q8)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4<nL*(1-q8)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nW=e(aZ)nL=nL*nW/3.6;if e4>=nL*(1-q8)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4<nL*(1-q8)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fH=coroutine.status(beginSetup)if fH=="suspended"then local cz,fI=coroutine.resume(beginSetup)if fI then system.print("ERROR STARTUP: "..fI)end elseif fH=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aT and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(qa)local function qb(bE)local D=1;local function qc(qd,bE)local qe={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local qf=qd;for _,ce in ipairs(qe)do if bE and qf>ce then qd=ce elseif qd<ce and not bE then qd=ce;break end end;return qd end;if bE then D=-1 end;if not ExternalAGG and bh then if a1 and bE then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then b2=qc(b2,bE)else b2=b2+D*a3 end;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=qc(HoldAltitude,bE)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function qg(qh)if not aq then a2="Flight Assist in Atmo only"return end;local ck=type(qh)if bp==nil then if ck=="table"then if Autopilot or VectorToTarget then aR.ToggleAutopilot()end;bG("180On","BR")elseif qh==1 then bG("bnkLft","BR")else bG("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aR.ToggleAltitudeHold()if ck~="table"then qh=qh+1 end end;bp=qh else bG("180Off","BR")bp=nil end end;if qa=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aR.cmdThrottle(0)if vBooster or hover then if aq and ao==-1 then bG("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aV=true;GearExtended=false else if S then bG("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bG("grOut","LG",1)a.control.extendLandingGears()end else if S then bG("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif qa=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif qa=="forward"then T=T-1 elseif qa=="backward"then if AltIsOn then qg(-bb*5000)else T=T+1 end elseif qa=="left"then if AltIsOn then qg(1)else W=W-1 end elseif qa=="right"then if AltIsOn then qg(3)else W=W+1 end elseif qa=="yawright"then X=X-1 elseif qa=="yawleft"then X=X+1 elseif qa=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif qa=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif qa=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif qa=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif qa=="groundaltitudeup"then qb()elseif qa=="groundaltitudedown"then qb(true)elseif qa=="option1"then toggleView=false;if AltIsOn and a1 then local qi=""for i=1,#bx do qi=qi.."| Name: "..system.getPlayerName(bx[i]).." Mass: "..A(core.getBoardedPlayerMass(bx[i])/1000,1).."t "end;system.print("Onboard: "..qi)return end;aQ.adjustAutopilotTargetIndex()elseif qa=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bx do core.forceDeboard(bx[i])end;a2="Deboarded All Passengers"return end;aQ.adjustAutopilotTargetIndex(1)elseif qa=="option3"then local function qj()aC=not aC;if not aC then bG("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bG("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local qi=""for i=1,#by do qi=qi.."| ID: "..by[i].." Mass: "..A(core.getDockedConstructMass(by[i])/1000,1).."t "end;system.print("Docked Ships: "..qi)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;qj()toggleView=false elseif qa=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#by do core.forceUndock(by[i])end;a2="Undocked all ships"return end;bp=nil;aR.ToggleAutopilot()elseif qa=="option5"then toggleView=false;aR.ToggleLockPitch()elseif qa=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local qk=shield_1.getVentingCooldown()if qk>0 then a2="Cannot vent again for "..qk.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aR.ToggleAltitudeHold()elseif qa=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif qa=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bG("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bG("gsOn","GS")end;toggleView=false elseif qa=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aR.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bG("gyOn","GA")else bG("gyOff","GA")end end;toggleView=false elseif qa=="lshift"then bu=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;aU=false;aT=false end elseif qa=="brake"then if BrakeToggleStatus or AltIsOn then aR.BrakeToggle()elseif not BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=true end elseif qa=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif qa=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif qa=="stopengines"then local function ql()if E-F<1.5 then bG("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bp=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;aV=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;ql()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aR.cmdThrottle(0)else aR.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then aR.cmdCruise(AtmoSpeedLimit)else aR.cmdCruise(MaxGameVelocity*3.6)end end end elseif qa=="speedup"then bD()elseif qa=="speeddown"then bD(true)elseif qa=="antigravity"and not ExternalAGG then if antigrav~=nil then aR.ToggleAntigrav()end end end;function script.onActionStop(qa)local function qm()if not ExternalAGG and bh then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if qa=="forward"then T=0 elseif qa=="backward"then T=0 elseif qa=="left"then if bp then if bp==2 then bp=-2 else bp=-1 end end;W=0 elseif qa=="right"then if bp then if bp==4 then bp=-2 else bp=-1 end end;W=0 elseif qa=="yawright"then X=0 elseif qa=="yawleft"then X=0 elseif qa=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif qa=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif qa=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qa=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qa=="groundaltitudeup"then qm()toggleView=false elseif qa=="groundaltitudedown"then qm()toggleView=false elseif qa=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then aU=false;aT=false end;a1=false elseif qa=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=false end end elseif qa=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(qa)local function qn(bE)local D=1;if bE then D=-1 end;if not ExternalAGG and bh then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then b2=b2+D*a5;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function qo(bE)local D=1;if bE then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if qa=="groundaltitudeup"then if not a1 then qn()end elseif qa=="groundaltitudedown"then if not a1 then qn(true)end elseif qa=="speedup"then qo()elseif qa=="speeddown"then qo(true)end end;function script.onInputText(bW)local function qp(qq,e8,hz)local function qr(e8)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs='::pos{'..B..','..B..','..B..','..B..','..B..'}'local cG,cH,cN,cO,cP=o(e8,cs)if cG=="0"and cH=="0"then return vec3(z(cN),z(cO),z(cP))end;cO=math.rad(cO)cN=math.rad(cN)local planet=b[z(cG)][z(cH)]local dA=math.cos(cN)local qs=vec3(dA*math.cos(cO),dA*math.sin(cO),math.sin(cN))return planet.center+(planet.radius+cP)*qs end;local position=qr(e8)return aQ.AddNewLocation(qq,position,hz)end;local i;local qt,qu=nil,nil;local qv="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(bW," ")qt=bW;if i~=nil then qt=string.sub(bW,0,i-1)qu=string.sub(bW,i+1)end;if qt=="/help"or qt=="/commands"then for lp in string.gmatch(qv,"([^\n]+)")do system.print(lp)end;return elseif qt=="/setname"then if qu==nil or qu==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aQ.UpdatePosition(qu)else a2="Select a saved target to rename first"end elseif shield_1 and qt=="/resist"then if qu==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs=B..', '..B..', '..B..', '..B;local qw,qx,qy,qz=o(qu,cs)if qz==nil or qw+qx+qy+qz>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(qw,qx,qy,qz)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif qt=="/addlocation"or string.find(bW,"::pos")~=nil then local hz=false;local qq="0-Temp"if qu==nil or qu==""then qu=qt;hz=true end;i=string.find(qu,"::")if not hz then qq=string.sub(qu,1,i-2)end;local e8=string.sub(qu,i)qp(qq,e8,hz)elseif qt=="/agg"then if qu==nil or qu==""then a2="Usage: /agg targetheight"return end;qu=z(qu)if qu<1000 then qu=1000 end;AntigravTargetAltitude=qu;a2="AGG Target Height set to "..qu elseif qt=="/G"then if qu==nil or qu==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if qu=="dump"then for cd,ce in pairs(bM())do if type(_G[ce])=="boolean"then if _G[ce]==true then system.print(ce.." true")else system.print(ce.." false")end elseif _G[ce]==nil then system.print(ce.." nil")else system.print(ce.." ".._G[ce])end end;return end;i=string.find(qu," ")local qA=string.sub(qu,0,i-1)local qB=string.sub(qu,i+1)for cd,ce in pairs(bM())do if ce==qA then a2="Variable "..qA.." changed to "..qB;local qC=type(_G[ce])if qC=="number"then qB=z(qB)if ce=="AtmoSpeedLimit"then aZ=qB end elseif qC=="boolean"then if string.lower(qB)=="true"then qB=true else qB=false end end;_G[ce]=qB;return end end;a2="No such global variable: "..qA elseif qt=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aQ.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif qt=="/copydatabank"then if dbHud_2 then c9(true)else a2="Spare Databank required to copy databank"end elseif qt=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aR.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(cH)if radar_1 and not aq and not bn then unit.setTimer("contact",0.1)end end;function script.onLeave(cH)if radar_1 and CollisionSystem then if#bq>650 then cH=tostring(cH)bq[cH]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
