name: ArchHud - Archaegeo v0.721 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.721;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},DeadZone={set=function(K)au=K end,get=function()return au end},OrbitMapSize={set=function(K)av=K end,get=function()return av end},OrbitMapX={set=function(K)aw=K end,get=function()return aw end},OrbitMapY={set=function(K)ax=K end,get=function()return ax end},soundVolume={set=function(K)ay=K end,get=function()return ay end}}aA=5.0;aB=1.0;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0166667;aQ=0.0666667;aR=0.0;aS="none"aT="none"aU="none"aV={speedChangeLarge={set=function(K)aA=K end,get=function()return aA end},speedChangeSmall={set=function(K)aB=K end,get=function()return aB end},MouseXSensitivity={set=function(K)aC=K end,get=function()return aC end},MouseYSensitivity={set=function(K)aD=K end,get=function()return aD end},autoRollFactor={set=function(K)aE=K end,get=function()return aE end},rollSpeedFactor={set=function(K)aF=K end,get=function()return aF end},autoRollRollThreshold={set=function(K)aG=K end,get=function()return aG end},minRollVelocity={set=function(K)aH=K end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(K)aI=K end,get=function()return aI end},torqueFactor={set=function(K)aJ=K end,get=function()return aJ end},pitchSpeedFactor={set=function(K)aK=K end,get=function()return aK end},yawSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeSpeedFactor={set=function(K)aM=K end,get=function()return aM end},brakeFlatFactor={set=function(K)aN=K end,get=function()return aN end},DampingMultiplier={set=function(K)aO=K end,get=function()return aO end},apTickRate={set=function(K)aP=K end,get=function()return aP end},hudTickRate={set=function(K)aQ=K end,get=function()return aQ end},ExtraEscapeThrust={set=function(K)aR=K end,get=function()return aR end},ExtraLongitudeTags={set=function(K)aS=K end,get=function()return aS end},ExtraLateralTags={set=function(K)aT=K end,get=function()return aT end},ExtraVerticalTags={set=function(K)aU=K end,get=function()return aU end}}aW=j;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=1000;b8=false;b9=false;ba=false;bb=false;bc=0;bd="Aligning"be=0;bf=1;bg="None"bh=nil;bi=0;bj=nil;bk=0.0;bl=0;bm={}bn=false;bo=0;bp=0;bq=nil;br=0;bs=1000;bt=0;bu=false;bv=0;bw=false;bx="All"by=true;bz="Off"bA=0.000;bB={}bC={}bD={VertTakeOff={set=function(K)b6=K end,get=function()return b6 end},VertTakeOffEngine={set=function(K)aX=K end,get=function()return aX end},SpaceTarget={set=function(K)bu=K end,get=function()return bu end},BrakeToggleStatus={set=function(K)aW=K end,get=function()return aW end},BrakeIsOn={set=function(K)aY=K end,get=function()return aY end},RetrogradeIsOn={set=function(K)aZ=K end,get=function()return aZ end},ProgradeIsOn={set=function(K)a_=K end,get=function()return a_ end},Autopilot={set=function(K)b0=K end,get=function()return b0 end},TurnBurn={set=function(K)b1=K end,get=function()return b1 end},AltitudeHold={set=function(K)b2=K end,get=function()return b2 end},BrakeLanding={set=function(K)b3=K end,get=function()return b3 end},Reentry={set=function(K)b5=K end,get=function()return b5 end},AutoTakeoff={set=function(K)b4=K end,get=function()return b4 end},HoldAltitude={set=function(K)b7=K end,get=function()return b7 end},AutopilotAccelerating={set=function(K)b8=K end,get=function()return b8 end},AutopilotBraking={set=function(K)ba=K end,get=function()return ba end},AutopilotCruising={set=function(K)bb=K end,get=function()return bb end},AutopilotRealigned={set=function(K)b9=K end,get=function()return b9 end},AutopilotEndSpeed={set=function(K)bc=K end,get=function()return bc end},AutopilotStatus={set=function(K)bd=K end,get=function()return bd end},AutopilotPlanetGravity={set=function(K)be=K end,get=function()return be end},PrevViewLock={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetName={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetCoords={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetIndex={set=function(K)bi=K end,get=function()return bi end},TotalDistanceTravelled={set=function(K)bk=K end,get=function()return bk end},TotalFlightTime={set=function(K)bl=K end,get=function()return bl end},SavedLocations={set=function(K)bm=K end,get=function()return bm end},VectorToTarget={set=function(K)bn=K end,get=function()return bn end},LocationIndex={set=function(K)bo=K end,get=function()return bo end},LastMaxBrake={set=function(K)bp=K end,get=function()return bp end},LockPitch={set=function(K)bq=K end,get=function()return bq end},LastMaxBrakeInAtmo={set=function(K)br=K end,get=function()return br end},AntigravTargetAltitude={set=function(K)bs=K end,get=function()return bs end},LastStartTime={set=function(K)bt=K end,get=function()return bt end},iphCondition={set=function(K)bx=K end,get=function()return bx end},stablized={set=function(K)by=K end,get=function()return by end},UseExtra={set=function(K)bz=K end,get=function()return bz end},SelectedTab={set=function(K)bE=K end,get=function()return bE end},saveRoute={set=function(K)bB=K end,get=function()return bB end},apRoute={set=function(K)bC=K end,get=function()return bC end}}local function bF(a,b,c,bG,bH,bI)bJ=bG()bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=0;bR=0;bS=0;bT=0;bU=false;bV=false;bW="empty"bX=3;bY=false;bZ=0;b_=0;c0=nil;c1=0;c2=0;c3=0;c4=false;c5=false;c6=false;c7=-1;c8=bI()>0;c9=bI()ca=b.getAltitude()cb=b.getConstructMass()cc=nil;cd=a9;ce=aa;cf={}cg={}ch={}ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=false;cs=false;ct=p;cu=false;cv=U;cw=nil;cx=0;cy=false;cz=false;cA=false;cB=vec3(b.getConstructWorldOrientationForward())cC=vec3(b.getConstructWorldOrientationRight())cD=vec3(b.getVelocity())cE=vec3(b.getWorldVelocity())cF=vec3(cE):len()cG=vec3(b.getWorldVertical())cH=-cG:dot(cE)cI=vec3(b.getConstructWorldPos())cJ=false;cK=false;cL=true;cM=0;cN=0;cO={}cP=false;cQ=50000;cR=nil;cS=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;cT=false;cU=nil;cV=false;cW=0;cX=nil;cY=nil;cZ={}c_=90;d0=w;d1=nil;d2=nil;d3={}d4={}d5=false;d6=nil;if shield_1 then d7=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())end end;local function d8(d,b,c,a,d9,da,db,dc,dd)local function de(df)return type(df)=='number'end;local function dg(df)return type(db(df))=='number'end;local function dh(di)return type(di)=='table'end;local function dj(a)return type(a)=='string'end;local function dk(dl)return dh(dl)and de(dl.x and dl.y and dl.z)end;local function dm(dn)return dh(dn)and de(dn.latitude and dn.longitude and dn.altitude and dn.id and dn.systemId)end;local dp=math.pi/180;local dq=180/math.pi;local dr=1e-10;local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..ds..','..ds..','..ds..','..ds..','..ds..'}'local utils=utils;local vec3=vec3;local function du(df)local dv=string.gsub(string.reverse(d9('%.4f',df)),'^0*%.?','')return dv==''and'0'or string.reverse(dv)end;local function dw(dx)if dk(dx)then return d9('{x=%.3f,y=%.3f,z=%.3f}',dx.x,dx.y,dx.z)end;if dh(dx)and not getmetatable(dx)then local dy={}local dz=next(dx)if type(dz)=='nil'or dz==1 then dy=dx else for dA,dl in pairs(dx)do local dB=dw(dl)if type(dA)=='number'then table.insert(dy,d9('[%s]=%s',dA,dB))else table.insert(dy,d9('%s=%s',dA,dB))end end end;return d9('{%s}',table.concat(dy,','))end;if dj(dx)then return d9("'%s'",dx:gsub("'",[[\']]))end;return tostring(dx)end;local dC={}dC.__index=dC;dC.__tostring=function(dx,dD)local dE={}for dA in pairs(dx)do table.insert(dE,dA)end;table.sort(dE)local dy={}for dF,dA in ipairs(dE)do local dB=dw(dx[dA])if type(dA)=='number'then table.insert(dy,d9('[%s]=%s',dA,dB))else table.insert(dy,d9('%s=%s',dA,dB))end end;if dD then return d9('%s%s',dD,table.concat(dy,',\n'..dD))end;return d9('{%s}',table.concat(dy,','))end;dC.__eq=function(dG,dH)return dG.systemId==dH.systemId and dG.id==dH.id and dd(dG.radius,dH.radius)and dd(dG.center.x,dH.center.x)and dd(dG.center.y,dH.center.y)and dd(dG.center.z,dH.center.z)and dd(dG.GM,dH.GM)end;local function dI(dJ,dK,dL,dM,dN)assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(dL),'Argument 3 (radius) must be a number:'..type(dL))assert(dh(dM),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dM))assert(dg(dN),'Argument 5 (GM) must be a number:'..type(dN))return setmetatable({systemId=db(dJ),id=db(dK),radius=db(dL),center=vec3(dM),GM=db(dN)},dC)end;local dO={}dO.__index=dO;dO.__tostring=function(dP)return d9('::pos{%d,%d,%s,%s,%s}',dP.systemId,dP.id,du(dP.latitude*dq),du(dP.longitude*dq),du(dP.altitude))end;dO.__eq=function(dG,dH)return dG.id==dH.id and dG.systemId==dH.systemId and dd(dG.latitude,dH.latitude)and dd(dG.altitude,dH.altitude)and(dd(dG.longitude,dH.longitude)or dd(dG.latitude,math.pi/2)or dd(dG.latitude,-math.pi/2))end;local function dQ(dR,dK,dS,dT,dU)local dJ=dR;if dj(dR)and not dT and not dU and not dK and not dS then dJ,dK,dS,dT,dU=dV(dR,dt)assert(dJ,'Argument 1 (position string) is malformed.')else assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(dS),'Argument 3 (latitude) must be in degrees:'..type(dS))assert(dg(dT),'Argument 4 (longitude) must be in degrees:'..type(dT))assert(dg(dU),'Argument 5 (altitude) must be in meters:'..type(dU))end;dJ=db(dJ)dK=db(dK)dS=db(dS)dT=db(dT)dU=db(dU)if dK==0 then return setmetatable({latitude=dS,longitude=dT,altitude=dU,id=dK,systemId=dJ},dO)end;return setmetatable({latitude=dp*da(dS,-90,90),longitude=dp*(dT%360),altitude=dU,id=dK,systemId=dJ},dO)end;local dW={}dW.__index=dW;dW.__tostring=function(dx,dD)local dX=dD and dD..'  'local dY={}local dE={}for dA in pairs(dx)do table.insert(dE,dA)end;table.sort(dE)for dF,dZ in ipairs(dE)do d_=dx[dZ]local e0=dC.__tostring(d_,dX)if dD then table.insert(dY,d9('[%s]={\n%s\n%s}',dZ,e0,dD))else table.insert(dY,d9('  [%s]=%s',dZ,e0))end end;if dD then return d9('\n%s%s%s',dD,table.concat(dY,',\n'..dD),dD)end;return d9('{\n%s\n}',table.concat(dY,',\n'))end;local function e1(e2)local e={}local pid;for dF,dl in pairs(e2)do local dK=dl.planetarySystemId;if type(dK)~='number'then error('Invalid planetary s ID: '..tostring(dK))elseif pid and dK~=pid then error('Mistringmatch planetary s IDs: '..dK..' and '..pid)end;local e3=dl.bodyId;if type(e3)~='number'then error('Invalid body ID: '..tostring(e3))elseif e[e3]then error('Duplicate body ID: '..tostring(e3))end;setmetatable(dl.center,getmetatable(vec3.unit_x))e[e3]=setmetatable(dl,dC)pid=dK end;return setmetatable(e,dW)end;e4={}local function e5(e2)return setmetatable({galaxyAtlas=e2 or{}},e4)end;e4.__index=function(di,K)if type(K)=='number'then local a=di.galaxyAtlas[K]return e1(a)end;return rawget(e4,K)end;e4.__pairs=function(dx)return function(di,dA)local e6,e7=next(di,dA)return e6,e7 and e1(e7)end,dx.galaxyAtlas,nil end;e4.__tostring=function(dx)local e8={}for dF,e9 in pairs(dx or{})do local ea=e9:getPlanetarySystemId()local eb=dW.__tostring(e9,'    ')table.insert(e8,d9('  [%s]={%s\n  }',ea,eb))end;return d9('{\n%s\n}\n',table.concat(e8,',\n'))end;e4.BodyParameters=dI;e4.MapPosition=dQ;e4.PlanetarySystem=e1;function e4.createBodyParameters(dJ,dK,ec,ed,ee,ef,eg)assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(ec),'Argument 3 (surfaceArea) must be a number:'..type(ec))assert(dh(ed),'Argument 4 (aPosition) must be an array or vec3:'..type(ed))assert(dh(ee),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ee))assert(dg(ef),'Argument 6 (altitude) must be in meters:'..type(ef))assert(dg(eg),'Argument 7 (gravityAtPosition) must be number:'..type(eg))local dL=dc(ec/4/math.pi)local c3=dL+ef;local eh=vec3(ed)+c3*vec3(ee)local dN=eg*c3*c3;return dI(dJ,dK,dL,eh,dN)end;e4.isMapPosition=dm;function e4:getPlanetarySystem(dR)if K==nil then K=0 end;if e7==nil then e7=0 end;local dJ=dR;if dm(dR)then dJ=dR.systemId end;if type(dJ)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(e7)~=dW then a=e1(a)end;return a end end end;function dW:sizeCalculator(ei)return 1.05*ei.radius end;function dW:castIntersections(ej,ek,el,em,en,eo)local ep={}if en then for dF,ei in pairs(en)do table.insert(ep,ei)end else ep=cZ end;if not eo then table.sort(ep,function(eq,er)local es=eq.center;local et=er.center;return(es.x-ej.x)^2+(es.y-ej.y)^2+(es.z-ej.z)^2<(et.x-ej.x)^2+(et.y-ej.y)^2+(et.z-ej.z)^2 end)end;local eu=ek:normalize()for dF,ei in ipairs(ep)do local ev=ei.center-ej;local dL=self:sizeCalculator(ei)local ew=ev:dot(eu)local ex=ew^2-(ev:len2()-dL^2)if ex>=0 then local ey=dc(ex)local ez=ew+ey;local eA=ew-ey;if eA>0 then return ei,ez,eA elseif ez>0 then return ei,ez,nil end end end;return nil,nil,nil end;function dW:closestBody(eB)assert(type(eB)=='table','Invalid coordinates.')local eC,ei;local eD=vec3(eB)for dF,eE in pairs(self)do local eF=(eE.center-eD):len2()if(not ei or eF<eC)and eE.name~="Space"then ei=eE;eC=eF end end;return ei end;function dW:convertToBodyIdAndWorldCoordinates(dR)local eG=dR;if dj(dR)then eG=dQ(dR)end;if eG.id==0 then return 0,vec3(eG.latitude,eG.longitude,eG.altitude)end;local eE=self:getBodyParameters(eG)if eE then return eG.id,eE:convertToWorldCoordinates(eG)end end;function dW:getBodyParameters(dR)local dK=dR;if dm(dR)then dK=dR.id end;assert(dg(dK),'Argument 1 (id) must be a number:'..type(dK))return self[dK]end;function dW:getPlanetarySystemId()local dF,dl=next(self)return dl and dl.systemId end;function dC:convertToMapPosition(dM)assert(dh(dM),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dM))local eH=vec3(dM)if self.id==0 then return setmetatable({latitude=eH.x,longitude=eH.y,altitude=eH.z,id=0,systemId=self.systemId},dO)end;local eI=eH-self.center;local c3=eI:len()local dU=c3-self.radius;local dS=0;local dT=0;if not dd(c3,0)then local eJ=eK(eI.y,eI.x)dT=eJ>=0 and eJ or 2*math.pi+eJ;dS=math.pi/2-math.acos(eI.z/c3)end;return setmetatable({latitude=dS,longitude=dT,altitude=dU,id=self.id,systemId=self.systemId},dO)end;function dC:convertToWorldCoordinates(dR)local eG=dj(dR)and dQ(dR)or dR;if eG.id==0 then return vec3(eG.latitude,eG.longitude,eG.altitude)end;assert(dm(eG),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eG.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eG.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eL=math.cos(eG.latitude)return self.center+(self.radius+eG.altitude)*vec3(eL*math.cos(eG.longitude),eL*math.sin(eG.longitude),math.sin(eG.latitude))end;function dC:getAltitude(dM)return(vec3(dM)-self.center):len()-self.radius end;function dC:getDistance(dM)return(vec3(dM)-self.center):len()end;function dC:getGravity(dM)local eM=self.center-vec3(dM)local eN=eM:len2()return self.GM/eN*eM/dc(eN)end;return setmetatable(e4,{__call=function(dF,...)return e5(...)end})end;local function eO(d,b,c,a,dc,eP)local cj={}local eQ=30000000/3600;local eR=eQ*eQ;local eS=100;function cj.computeAccelerationTime(eT,eU,eV)local eW=eQ*math.asin(eT/eQ)return(eQ*math.asin(eV/eQ)-eW)/eU end;function cj.computeDistanceAndTime(eT,eV,eX,eY,eZ,e_)eZ=eZ or 0;e_=e_ or 0;local f0=eT<=eV;local f1=eY*(f0 and 1 or-1)/eX;local f2=-e_/eX;local f3=f1+f2;if f0 and f3<=0 or not f0 and f3>=0 then return-1,-1 end;local f4,f5=0,0;if f1~=0 and eZ>0 then local eW=math.asin(eT/eQ)local f6=math.pi*(f1/2+f2)local f7=f1*eZ;local f8=eQ*math.pi;local dl=function(di)local f9=(f6*di-f7*math.sin(math.pi*di/2/eZ)+f8*eW)/f8;local fa=math.tan(f9)return eQ*fa/dc(fa*fa+1)end;local fb=f0 and function(a)return a>=eV end or function(a)return a<=eV end;f5=2*eZ;if fb(dl(f5))then local fc=0;while eP(f5-fc)>0.5 do local di=(f5+fc)/2;if fb(dl(di))then f5=di else fc=di end end end;local fd=eT;local fe=f5/eS;for ff=1,eS do local fg=dl(ff*fe)f4=f4+(fg+fd)*fe/2;fd=fg end;if f5<2*eZ then return f4,f5 end;eT=fd end;local eW=eQ*math.asin(eT/eQ)local bJ=(eQ*math.asin(eV/eQ)-eW)/f3;local fh=eR*math.cos(eW/eQ)/f3;local c3=fh-eR*math.cos((f3*bJ+eW)/eQ)/f3;return c3+f4,bJ+f5 end;function cj.computeTravelTime(eT,eU,c3)if c3==0 then return 0 end;if eU>0 then local eW=eQ*math.asin(eT/eQ)local fh=eR*math.cos(eW/eQ)/eU;return(eQ*math.acos(eU*(fh-c3)/eR)-eW)/eU end;if eT==0 then return-1 end;assert(eT>0,'Acceleration and initial speed are both zero.')return c3/eT end;return cj end;local function fi(d,b,c,a,d9,da,db,dc,dd)local vec3=vec3;local d8=d8(d,b,c,a,d9,da,db,dc,dd)local function dj(a)return type(a)=='string'end;local function dh(di)return type(di)=='table'end;fj={}fj.__index=fj;function fj:escapeAndOrbitalSpeed(dU)assert(self.body)local c3=dU+self.body.radius;if not dd(c3,0)then local fk=dc(self.body.GM/c3)return dc(2)*fk,fk end;return nil,nil end;function fj:orbitalParameters(dR,fl)assert(self.body)assert(dh(dR)or dj(dR))assert(dh(fl))local fm=(dj(dR)or d8.isMapPosition(dR))and self.body:convertToWorldCoordinates(dR)or vec3(dR)local dl=vec3(fl)local fn=fm-self.body.center;local fo=dl:len2()local fp=fn:len()local fq=self.body.GM;local fr=((fo-fq/fp)*fn-fn:dot(dl)*dl)/fq;local es=fq/(2*fq/fp-fo)local fs=fr:len()local eu=fr:normalize()local ft=es*(1-fs)local fu=es*(1+fs)local fv=ft*eu+self.body.center;local fw=fs<=1 and-fu*eu+self.body.center or nil;local fx=dc(es*fq*(1-fs*fs))local fy=fw and 2*math.pi*dc(es^3/fq)local fz=math.acos(fr:dot(fn)/(fs*fp))if fn:dot(dl)<0 then fz=-(fz-2*math.pi)end;local fA=math.acos((math.cos(fz)+fs)/(1+fs*math.cos(fz)))local fB=fA;if fB<0 then fB=fB+2*math.pi end;local fC=fB-fs*math.sin(fB)local fD=0;local fE=0;local fF=0;if fy~=nil then fD=fC/(2*math.pi/fy)fE=fy-fD;fF=fE+fy/2;if fz-math.pi>0 then fE=fD;fF=fE+fy/2 end;if fF>fy then fF=fF-fy end end;return{periapsis={position=fv,speed=fx/ft,circularOrbitSpeed=dc(fq/ft),altitude=ft-self.body.radius},apoapsis=fw and{position=fw,speed=fx/fu,circularOrbitSpeed=dc(fq/fu),altitude=fu-self.body.radius},currentVelocity=dl,currentPosition=fm,eccentricity=fs,period=fy,eccentricAnomaly=fA,meanAnomaly=fC,timeToPeriapsis=fE,timeToApoapsis=fF,trueAnomaly=fz}end;local function fG(fH)local eE=d8.BodyParameters(fH.systemId,fH.id,fH.radius,fH.center,fH.GM)return setmetatable({body=eE},fj)end;return setmetatable(fj,{__call=function(dF,...)return fG(...)end})end;local function fI(d,b,c,a,dbHud_1,e,fJ,fK,bH,db,dc,fL,fM)local function fN(fO)local dP=fP:closestBody(fO)if(fO-dP.center):len()>dP.radius+dP.noAtmosphericDensityAltitude then dP=e[0][0]end;return dP end;local function fQ()local function fR(fS,fT)return fS.name<fT.name end;cO={}for dA,dl in pairs(e[0])do cO[#cO+1]={name=dl.name,index=dA}end;table.sort(cO,fR)end;local function fU(fV,fW)if not fW then fW=fX.name end;for dA,dl in pairs(fV)do if dl.name and dl.name==fW then return dA end end;return-1 end;local function fY()cW=bi;if bi==0 then bg="None"c0=nil;fX=nil;return true end;local fZ=cO[bi].index;local f_=e[0][fZ]if f_.center then bg=f_.name;c0=ci[0][fZ]if fX~=nil then if c9==0 then if fJ(g0,g1)~=1 then fK(g0,g1)end;if fJ(g2,g3)~=1 then fK(g2,g3)end;if fJ(g4,g5)~=1 then fK(g4,g5)end;if fJ(g6,g7)~=1 then fK(g6,g7)end;if fJ(g8,g9)~=1 then fK(g8,g9)end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end;if fJ(ge,gf)~=1 then fK(ge,gf)end end;fX=nil else fX=f_;for dF,dl in pairs(ci[0])do if dl.name==fX.planetname then c0=dl;bg=fX.name;break end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end end;if fX==nil then bh=vec3(c0.center)else bh=fX.position end;if c0.planetname~="Space"then if c0.hasAtmosphere then gg=bH(c0.radius*(S-1)+c0.noAtmosphericDensityAltitude)else gg=bH(c0.radius*(S-1)+c0.surfaceMaxAltitude)end else gg=R end;if fX~=nil and fX.planetname=="Space"then bc=0 else dF,bc=ck(c0):escapeAndOrbitalSpeed(gg)end;be=0;b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"return true end;local function gh(gi)if not b0 and not bn and not c5 and not bw and not b5 and not c6 then if gi==nil then bi=bi+1;if bi>#cO then bi=0 end else bi=bi-1;if bi<0 then bi=#cO end end;if bi==0 then fY()else local fZ=cO[bi].index;local f_=e[0][fZ]if f_ and(f_~=nil and f_.name=="Space"or bx=="Custom Only"and f_.center or bx=="No Moons"and string.find(f_.name,"Moon")~=nil)then if gi==nil then gh()else gh(1)end else fY()end end else bW="Disengage autopilot before changing Interplanetary Helper"fL("iph","AP")end end;local function gj()local function gk(gl)local gm;if gl then gm=d3 else gm=bm end;local gn=-1;gn=fU(e[0])if gn>-1 then table.remove(e[0],gn)end;gn=-1;gn=fU(gm)if gn~=-1 then bW=fX.name.." saved location cleared"table.remove(gm,gn)end;gh()fQ()return gm end;if string.sub(bg,1,1)=="*"then d3=gk(true)else bm=gk(false)end end;local function go(gp,fO,gq,gr)local function gs(gl)if gl then gm=d3 else gm=bm end;if dbHud_1 or gq or gl then local dP=fN(fO)local gt={position=fO,name=gp,planetname=dP.name,gravity=b.g(),safe=gr}if not gq then gm[#gm+1]=gt else for dA,dl in pairs(e[0])do if dl.name and gp==dl.name then table.remove(e[0],dA)end end end;table.insert(e[0],gt)fQ()fY()bW="Location saved as "..gp.."("..dP.name..")"return gm else bW="Databank must be installed to save permanent locations"end end;if string.sub(gp,1,1)=="*"then d3=gs(true)else bm=gs(false)end end;local gu={}function gu.UpdateAtlasLocationsList()fQ()end;function gu.UpdateAutopilotTarget()fY()end;function gu.adjustAutopilotTargetIndex(gi)gh(gi)end;function gu.findAtlasIndex(fV,fW)return fU(fV,fW)end;function gu.UpdatePosition(gv,gw,gx)local function gy(gl)local gm;if gl then gm=d3 else gm=bm end;local gn=fU(gm)if gn~=-1 then if gv~=nil then if gl then gv="*"..gv end;gm[gn].name=gv;bi=bi-1;gh()elseif gx~=nil then if gx then local gz=ca;if gz<1000 then gz=1000 end;gm[gn].agg=fM(gz,0)bW=gm[gn].name.." AGG Altitude:"..gm[gn].agg.." saved ("..gm[gn].planetname..")"return elseif gx==false then gm[gn].agg=nil;bW=gm[gn].name.." AGG Altitude cleared ("..gm[gn].planetname..")"return end else local gA=gm[gn]if gw then gA.heading=cC:cross(cG)*5000;bW=gm[gn].name.." heading saved ("..gm[gn].planetname..")"return elseif gw==false then gA.heading=nil;bW=gm[gn].name.." heading cleared ("..gm[gn].planetname..")"return end;gA.gravity=b.g()gA.position=cI;gA.safe=true end;bW=gm[gn].name.." position updated ("..gm[gn].planetname..")"else bW="Name Not Found"end end;if string.sub(bg,1,1)=="*"then gy(true)else gy(false)end end;function gu.AddNewLocation(gp,fO,gq,gr)go(gp,fO,gq,gr)end;function gu.ClearCurrentPosition()gj()end;for dA,dl in pairs(d4)do table.insert(e[0],dl)end;fQ()if bi>#cO then bi=0 end;gu.UpdateAutopilotTarget()return gu end;local function gB(b,a,c,library,radar_1,radar_2,eP,gC,dc,gD,db,gE,fL)local gF={}local gG={}local gH={XS=13,S=27,M=55,L=110,XL=221}local gI={}local gJ;local gK;local gL;local gM;local gN;local gO={}local gP="Atmo"local gQ;local gR;local gS=0;local gT={}local function gU()local function gV(gW,gX,gY,gZ,g_,h0,h1,h2)gX,gZ,h0,h2=vec3(gX),vec3(gZ),vec3(h0),vec3(h2)local h3,h4,h5=gW*gW,gY*gY,g_*g_;local fo=gZ-gX;local h6=fo:normalize()local h7=fo:len()local h8=h0-gX;local h9=(h8-h8:project_on(h6)):normalize()local ha,hb=h8:dot(h6),h8:dot(h9)local hc=ha*ha+hb*hb;local hd=h6:cross(h9)local he=(h3-h4+h7*h7)/(2*h7)local hf=(h3-h5+hc-2*ha*he)/(2*hb)local dn=h3-he^2-hf^2;local hg=dc(dn)local hh=gX+h6*he+h9*hf+hd*hg;local hi=gX+h6*he+h9*hf-hd*hg;if eP((h2-hh):len()-h1)<eP((h2-hi):len()-h1)then return hh else return hi end end;local function hj()local function hk()local hl=b.getConstructWorldOrientationRight()local fo=b.getConstructWorldOrientationForward()local h8=b.getConstructWorldOrientationUp()local hm=library.systemResolution3(hl,fo,h8,{1,0,0})local hn=library.systemResolution3(hl,fo,h8,{0,1,0})local ho=library.systemResolution3(hl,fo,h8,{0,0,1})return function(hp)return library.systemResolution3(hm,hn,ho,hp)end end;local hq=hk()local hr=b.getConstructWorldPos()local fm=b.getElementPositionById(1)local hs={fm[1],fm[2],fm[3]}local ht=hq(hs)local hu={hr[1]-ht[1],hr[2]-ht[2],hr[3]-ht[3]}return hu end;local function hv(hw,fp,hx)local hy=hw.pts;local gn=#hy;local hz=hw.ref;if gn>3 then local hA,hB,hC,hD=hy[gn],hy[gn-1],hy[gn-2],hy[gn-3]hw.ref=hx;local fm=gV(hA[1],hA[2],hB[1],hB[2],hC[1],hC[2],hD[1],hD[2])local he,hf,hg=fm.x,fm.y,fm.z;if he==he and hf==hf and hg==hg then he=he+hz[1]hf=hf+hz[2]hg=hg+hz[3]local hE=vec3(he,hf,hg)if not hw.lastPos then hw.center=hE elseif(hw.lastPos-hE):len()<2 then hw.center=hE;hw.skipCalc=true end;hw.lastPos=hE end;hw.pts={}else local hF={hx[1]-hz[1],hx[2]-hz[2],hx[3]-hz[3]}hy[gn+1]={fp,hF}end end;if radar_1 or radar_2 then co.assignRadar()end;if gO[1]then gJ=#gO[1].getConstructIds()local hG=gO[1].getData()local hH=hG:gmatch('{"constructId[^}]*}[^}]*}')if gJ>0 then local hx=hj()local hI,hJ=0,0;gN,gM=0,0;for dl in hH do local dK,c3,hK=dl:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hL=gH[hK]c3=db(c3)if gO[1].hasMatchingTransponder(dK)==1 then table.insert(gG,dK)end;local hM=gO[1].getConstructType(dK)if E then if hL>27 or F or hM=="static"or hM=="space"then gN=gN+1;local gp=gO[1].getConstructName(dK)local hw=gT[dK]if hw==nil then hL=hL+gE;gT[dK]={pts={},ref=hx,name=gp,i=0,radius=hL,skipCalc=false}hw=gT[dK]end;if not hw.skipCalc then hv(hw,c3,hx)hJ=hJ+1 end;if hw.center then if F and gO[1].isConstructAbandoned(dK)==1 and not hw.abandoned then fL("abRdr","RD")a.print("Abandoned Construct: "..gp.." ("..hM..") ::pos{0,0,"..hw.center.x..","..hw.center.y..","..hw.center.z.."}")bW="Abandoned Radar Contact ("..hM..") detected"hw.abandoned=true end;table.insert(gI,hw)end end;hI=hI+1;if cS and hI>700 or hJ>70 or(not cS and hI>300 or hJ>30)then coroutine.yield()hI,hJ=0,0 end end end;gM=#gI;if gM>0 and(cF>20 or b3)then local ei,hN,hO,hP;local hQ=0;local hR=ci:getPlanetarySystem(0)hP=cE:normalize()while hQ<gM do coroutine.yield()local hS={table.unpack(gI,hQ,math.min(hQ+75,gM))}ei,hN,hO=hR:castIntersections(cI,hP,nil,nil,hS,true)if ei and hO then cU={ei,hN,hO}break end;hQ=hQ+75 end;if not ei then cU=nil end else cU=nil end;gI={}gK=hG:find('identifiedConstructs":%[%]')else gL=hG:find('worksInEnvironment":false')end end end;local function hT()if gO[1]then gP="Atmo"if gO[1].getData():find('worksInAtmosphere":false')then gP="Space"end end end;function gF.pickType()hT()end;function gF.assignRadar()if radar_1 and gO[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gO[1]=radar_2 end;if gO[1]==radar_2 then hT()end elseif radar_2 and gO[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gO[1]=radar_1 end;if gO[1]==radar_1 then hT()end end end;function gF.UpdateRadar()local hU=coroutine.status(gQ)if hU=="suspended"then local dB,hV=coroutine.resume(gQ)if hV then a.print("ERROR UPDATE RADAR: "..hV)end elseif hU=="dead"then gQ=coroutine.create(gU)local dB,hV=coroutine.resume(gQ)end end;function gF.GetRadarHud(hW,hX,hY,hZ)local h_=gG;local i0,i1;gG={}local ds=gM or 0;if gJ>0 then if E then i1=ds.."/"..gN.." Plotted : "..gJ-gN.." Ignored"else i1="Radar Contacts: "..gJ end;i0=gD(hY,hZ,i1,"pbright txtbig txtmid")if#gG>0 then i0=i0 ..gD(hW,hX,"Friendlies In Range","pbright txtbig txtmid")for dA,dl in pairs(gG)do hX=hX+20;i0=i0 ..gD(hW,hX,gO[1].getConstructName(dl),"pdim txtmid")end end;if gK==nil and gR==nil then gS=1;co.ToggleRadarPanel()end;if gK~=nil and gR~=nil then co.ToggleRadarPanel()end;if d2==nil then co.ToggleRadarPanel()end else if gL then i0=gD(hY,hZ,gP.." Radar: Jammed","pbright txtbig txtmid")else i0=gD(hY,hZ,"Radar: No "..gP.." Contacts","pbright txtbig txtmid")end;if d2~=nil then gS=0;co.ToggleRadarPanel()end end;return i0 end;function gF.GetClosestName(gp)if gO[1]then local dK,dF=gO[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dK~=nil and dK~=""then gp=gp.." "..gO[1].getConstructName(dK)end end;return gp end;function gF.ToggleRadarPanel()if d2~=nil and gS==0 then gC(d2)d2=nil;if gR~=nil then gC(gR)gR=nil end else if gS==1 then gC(d2)d2=nil;_autoconf.displayCategoryPanel(gO,1,"Periscope","periscope")gR=_autoconf.panels[_autoconf.panels_size]end;if d2==nil then _autoconf.displayCategoryPanel(gO,1,"Radar","radar")d2=_autoconf.panels[_autoconf.panels_size]end;gS=0 end end;function gF.ContactTick()if not i2 then i2=0 end;if bJ>i2+10 then bW="Radar Contact"fL("rdrCon","RC")i2=bJ end;c.stopTimer("contact")end;function gF.onEnter(dK)if radar_1 and not c8 and not cP then c.setTimer("contact",0.1)end end;function gF.onLeave(dK)if radar_1 and E then if#gT>650 then dK=tostring(dK)gT[dK]=nil end end end;gO[1]=nil;if radar_1 then gO[1]=radar_1;hT()end;gQ=coroutine.create(gU)return gF end;local function i3(shield_1,dV,bH)local i4={}local i5=shield_1.getResistancesCooldown()local function i6()local i7=shield_1.getState()if G then if not cP and i7==0 then shield_1.toggle()elseif cP and i7==1 then shield_1.toggle()end end end;local function i8()local i9=shield_1.getStressRatioRaw()local ia=0.5999;if i9[1]==0.0 and i9[2]==0.0 and i9[3]==0.0 and i9[4]==0.0 then return end;local ib=shield_1.setResistances(ia*i9[1],ia*i9[2],ia*i9[3],ia*i9[4])if ib==1 then bW="Shield Resistances updated"else bW="Value Exceeded. Failed to update Shield Resistances"end end;function i4.shieldTick()d7=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())i6()i5=shield_1.getResistancesCooldown()if i5==0 and d7<a7 then i8()end end;function i4.setResist(ic)if not shield_1 then bW="No shield found"return elseif ic==nil or i5>0 then bW="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt=ds..', '..ds..', '..ds..', '..ds;local id,ie,ig,ih=dV(ic,dt)if ih==nil or id+ie+ig+ih>0.6 then bW="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(id,ie,ig,ih)==1 then bW="Shield Resistances set"else bW="Resistance setting failed."end end;function i4.ventShield()local ii=shield_1.getVentingCooldown()if ii>0 then bW="Cannot vent again for "..ii.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()bW="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bW="Shields already at max hitpoints"end end;return i4 end;local function ij(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ik,eP,bH,d9,il,bI,im,io,eK,bG,da,ip,fK,fJ,gC,iq,dc,fM,gD,fL,ir,is,it,iu,iv,iw)local ix=9.80665;local iy={}local iz={}local iA={}local iB={}local iC=nil;local iD=nil;local iE=nil;local iF=false;local iG="none"local iH=""local iI=55;local iJ=0;local iK=0;local iL=""local iM=nil;local iN=ac;local iO=ad;local iP=ae;local iQ=[[rgb(]]..bH(iN+0.5)..","..bH(iO+0.5)..","..bH(iP+0.5)..[[)]]local iR=[[rgb(]]..bH(iN*0.9+0.5)..","..bH(iO*0.9+0.5)..","..bH(iP*0.9+0.5)..[[)]]local iS=0;local iT=0;local iU=""local iV=bG()local iW=false;local iX=vec3({13771471,7435803,-128971})local iY=18000000;local iZ=500000;local i_,j0=math.huge;local j1;local function j2(j3)i_=vec3(j3):dist(iX)if i_<iY then return true,eP(i_-iY)end;j0=vec3(j3):dist(vec3(j4.center))if j0<iZ then j1=true else j1=false end;if eP(j0-iZ)<eP(i_-iY)then return j1,eP(j0-iZ)else return j1,eP(i_-iY)end end;local function j5(dl)if cd==1920 then return dl else return fM(cd*dl/1920,0)end end;local function j6(dl)if ce==1080 then return dl else return fM(ce*dl/1080,0)end end;local function j7()return iq()==0 and g~="keyboard"and io()==0 end;local function j8()local j9="TRAVEL"if not cL then j9="CRUISE"end;if b0 then j9="AUTOPILOT"end;return j9 end;local i0=""local ja=""local jb=""local jc=1;local jd=2;local je=3;local jf=4;local jg=5;local jh=6;local ji=""local jj=0;local jk=bH(1/aP)*2*aQ;local jl={}local jm={}local jn={}local jo={}local jp={}local jq={}local jr={}jr["atmofueltank"],jr["spacefueltank"],jr["rocketfueltank"]=0,0,0;local js=0;local function jt(he,ju,jv,jw,jx,jy)local jz=js;local jA=js+5;if not B then jA=jA+5 end;if io()==1 and not l then jz=jz-50;jA=jA-50 end;if jv=="ATMO"then ji="atmofueltank"elseif jv=="SPACE"then ji="spacefueltank"else ji="rocketfueltank"end;jj=_G[ji.."_size"]if#jw>0 then for K=1,#jw do local gp=string.sub(jw[K][jd],1,12)local jB=0;for jC=1,jj do if jw[K][jd]==il(c[ji.."_"..jC].getData()).name then jB=jC;break end end;local jD=bG()if jx[K]==nil or jy[K]==nil or jD-jw[K][jh]>jk then local jE;local jF=0;jF=im(jw[K][jc])-jw[K][jf]jE=jw[K][jg]if jE>jF then jr[ji]=jr[ji]+jE-jF end;if jB~=0 then jy[K]=il(c[ji.."_"..jB].getData()).percentage;jx[K]=il(c[ji.."_"..jB].getData()).timeLeft;if jx[K]=="n/a"then jx[K]=0 end else jy[K]=bH(0.5+jF*100/jw[K][je])if jE<=jF then jx[K]=0 else jx[K]=bH(0.5+jF/((jE-jF)/(jD-jw[K][jh])))end end;jw[K][jh]=jD;jw[K][jg]=jF end;if gp==ju then gp=d9("%s %d",jv,K)end;if jB==0 then gp=gp.." *"end;local jG;if jx[K]==0 then jG=""else jG=iu(jx[K])end;if jy[K]~=nil then local jH=bH(jy[K]*2.55)local jI=d9("rgb(%d,%d,%d)",255-jH,jH,0)local jJ=""if jG~=""and jx[K]<120 or jy[K]<5 then jJ="red "end;local jK=d9("rgb(%d,%d,%d)",da(bH((255-jH)/2.55),50,100),da(bH(jH/2.55),0,50),50)local jL="rgb(196,0,255)"if jv=="ATMO"then jL="rgb(0,188,255)"elseif jv=="SPACE"then jL="rgb(239,255,0)"end;local jM=false;if jN~=jL then jM=true end;jN=jL;if B then if jM then jz=jz-5;jA=jA-5 end;ja=ja..d9([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jK,jL,he,jA,jI,bH(jy[K]*1.7+0.5)-2,he+1,jA+1,he+5,jA+14,gp,jy[K],jG)jz=jz-22;jA=jA-22 else ja=ja..gD(he,jz,gp,jJ.."pdim txtfuel")ja=ja..gD(he,jA,d9("%d%% %s",jy[K],jG),"pdim txtfuel","fill:"..jI)jz=jz+30;jA=jA+30 end end end end;js=jz end;local function jO(jP,dU)if am==0 and an==0 then return end;if dU<200000 and not c8 or dU and c8 then local jQ=0;if eP(cH)>1 then jQ=45*math.log(eP(cH),10)if cH<0 then jQ=-jQ end end;jP[#jP+1]=d9([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bH(cH),bH(jQ))end;return jP end;local function jR(jS)local gi=-cG;jS=jS-jS:project_on(gi)local jT=vec3(0,0,1)jT=jT-jT:project_on(gi)local jU=jT:cross(gi)local jQ=jT:angle_between(jS)*constants.rad2deg;if jS:dot(jU)<0 then jQ=360-jQ end;return jQ end;local function jV(jP,ai,aj,jW,jX,cS)if ab==0 then return end;local jY=ab;local jZ=20;local j_=bH(jW)if cS then for K=-45,45,5 do local k0=K;jP[#jP+1]=d9([[<g transform="rotate(%f,%d,%d)">]],k0,ai,aj)k1=5;if K%15==0 then k1=15 elseif K%10==0 then k1=10 end;jP[#jP+1]=d9([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jY+jZ-k1,ai,aj+jY+jZ)end;jP[#jP+1]=gD(ai,aj+jY+jZ-35,jX,"pdim txt txtmid")jP[#jP+1]=gD(ai,aj+jY+jZ-25,j_.." deg","pdim txt txtmid")jP[#jP+1]=d9([[<g transform="rotate(%f,%d,%d)">]],-jW,ai,aj)jP[#jP+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jY+jZ-20,ai+5,aj+jY+jZ-20,ai,aj+jY+jZ-15)jP[#jP+1]="</g>"end;jP[#jP+1]=[[<g style="clip-path: url(#headingClip);">]]local k2=j_;if cS then k2=jR(cB)end;local k3=20;local k4=bH(k2)local k5=0;local k6=aj+jY+jZ+20;local k7=ai;if jX~="YAW"then k6=j6(130)k7=j5(960)end;local k8=[[<path class="txttick line" d="]]local k9=bH(k4-(k3+10)-k4%5+0.5)for K=k9+70,k9,-5 do local he=k7-(-K*5+k2*5)if K%10==0 then k5=10;local ds=K;if ds==360 then ds=0 elseif ds>360 then ds=ds-360 elseif ds<0 then ds=ds+360 end;jP[#jP+1]=gD(he,k6+15,ds,"txtmid bright")elseif K%5==0 then k5=5 end;if k5==10 then k8=d9([[%s M %f %f v %d]],k8,he,k6-5,k5)else k8=d9([[%s M %f %f v %d]],k8,he,k6-2.5,k5)end end;jP[#jP+1]=k8 ..[["/>]]jP[#jP+1]=d9([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k7-5,k6-20,k7+5,k6-20,k7,k6-10)if I then if cS then jX="HDG"end;jP[#jP+1]=gD(j5(960),j6(100),k4 .."Â°","dim txt txtmid size14","")jP[#jP+1]=gD(j5(960),j6(85),jX,"dim txt txtmid size20","")end;jP[#jP+1]=[[</g>]]end;local function ka(jP,kb,jW,ai,aj,cS,kc,fg)if ab==0 then return end;local jY=ab;local kd=bH(jY*3/5)if jY>0 then local ke=bH(kb)local k1=0;local k8=d9([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jW,ai,aj)if not c8 then k8=d9([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jP[#jP+1]=d9([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jY-1,ai,aj)jP[#jP+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bH(ke-30-ke%5+0.5),bH(ke+30+ke%5+0.5),5 do if K%10==0 then k1=30 elseif K%5==0 then k1=20 end;local hf=aj+-K*5+kb*5;if k1==30 then k8=d9([[%s M %d %f h %d]],k8,ai-kd-k1,hf,k1)if c8 then jP[#jP+1]=d9([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jW,ai,aj,ai-kd+10,hf+4,K)jP[#jP+1]=d9([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jW,ai,aj,ai+kd-10,hf+4,K)if K==0 or K==180 or K==-180 then jP[#jP+1]=d9([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jW,ai,aj,ai-kd+20,hf,kd*2-40)end else jP[#jP+1]=gD(ai-kd+10,hf,K,"pdim txt txtmid")jP[#jP+1]=gD(ai+kd-10,hf,K,"pdim txt txtmid")end;k8=d9([[%s M %d %f h %d]],k8,ai+kd,hf,k1)else k8=d9([[%s M %d %f h %d]],k8,ai-kd-k1,hf,k1)k8=d9([[%s M %d %f h %d]],k8,ai+kd,hf,k1)end end;jP[#jP+1]=k8 ..[["/>]]local kf="PITCH"if not cS then kf="REL PITCH"end;if kb>90 and not c8 then kb=90-(kb-90)elseif kb<-90 and not c8 then kb=-90-(kb+90)end;if jY>200 then if c8 then if fg>iI then jP[#jP+1]=gD(ai,aj-15,"Yaw","pdim txt txtmid")jP[#jP+1]=gD(ai,aj+20,kc,"pdim txt txtmid")end;jP[#jP+1]=d9([[<g transform="rotate(%f,%d,%d)">]],-jW,ai,aj)else jP[#jP+1]=d9([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jP[#jP+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-kd+25,aj-5,ai-kd+20,aj,ai-kd+25,aj+5,ai-kd+50,aj+4,ke)jP[#jP+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+kd-25,aj-5,ai+kd-20,aj,ai+kd-25,aj+5,ai+kd-30,aj+4,ke)jP[#jP+1]="</g>"end;local kg=bH(jY/3)jP[#jP+1]=d9([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-kg,aj,jY-kg)if not c8 and cS then jP[#jP+1]=d9([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jW,ai,aj,ai-kd+10,aj,kd*2-20)end;jP[#jP+1]="</g>"if jY<200 then if c8 and fg>iI then jP[#jP+1]=gD(ai,aj-jY,kf,"pdim txt txtmid")jP[#jP+1]=gD(ai,aj-jY+10,ke,"pdim txt txtmid")jP[#jP+1]=gD(ai,aj-15,"Yaw","pdim txt txtmid")jP[#jP+1]=gD(ai,aj+20,kc,"pdim txt txtmid")else jP[#jP+1]=gD(ai,aj-jY,kf,"pdim txt txtmid")jP[#jP+1]=gD(ai,aj-jY+15,ke,"pdim txt txtmid")end end end end;local function kh(jP,dU,cS)local ki=ao;local kj=ap;if ki==0 and kj==0 then return end;local kk=78;local kl=19;local km=c7;if c7~=-1 then jP[#jP+1]=gD(ki+kk,kj+kl+20,d9("AGL: %.1fm",c7),"pdim altsm txtend")end;if cS and(dU<200000 and not c8 or dU and c8)then table.insert(jP,d9([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ki-1,kj-4,kk+2,kl+6,ki+1,kj-1,kk-4,kl))local gn=0;local kn=1;local ko=0;local kp=dU<0;local kq=dU<j4.surfaceMaxAltitude;local kr=9;if kp then kr=0 end;local dU=eP(dU)while gn<6 do local ks=11;local kt=16;local ku=9;local kv=14;local jJ="altsm"if gn>2 then kt=kt+3;ks=ks+2;kv=kv+2;ku=ku-6;jJ="altbig"end;if kp then jJ=jJ.." red"elseif kq then jJ=jJ.." orange"end;local kw=dU/kn%10;local kx=bH(kw)local ky=bH((kx+1)%10)local kz=ko;if gn==0 then kz=kw-kx;if kp then kz=1-kz end end;if kp and(gn==0 or ko~=0)then local gq=ky;ky=kx;kx=gq end;local kA=kt*(kz-1)local kB=kA+kt;local he=ki+ku+(6-gn)*ks;local hf=kj+kv;jP[#jP+1]=gD(he,hf+kA,ky,jJ)jP[#jP+1]=gD(he,hf+kB,kx,jJ)gn=gn+1;kn=kn*10;if kx==kr then ko=kz else ko=0 end end;table.insert(jP,[[</g></g>]])end end;local function kC(fl)local kD=-math.deg(eK(fl.y,fl.z))+180;kD=kD-90;if kD<0 then kD=360+kD end;if kD>180 then kD=-180+kD-180 end;return-kD end;local function kE(fl)local k2=math.deg(eK(fl.y,fl.x))-90;if k2<-180 then k2=360+k2 end;return k2 end;local function kF(jP,fl,fg,ai,aj)if fg>5 and not c8 or fg>iI then local jY=ab;local kG=20;local kH=20;local kI=kC(fl)local kJ=kE(fl)local kK=14;local kL=kK/2;local kM=-kJ/kH*jY;local kN=kI/kG*jY;local he=ai+kM;local hf=aj+kN;local c3=dc(kM^2+kN^2)local kO=[[<circle
                            cx="]]..he..[["
                            cy="]]..hf..[["
                            r="]]..kL/kK..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..he..[["
                            cy="]]..hf..[["
                            r="]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..he-kK..[[,]]..hf..[[ h ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..he+kL..[[,]]..hf..[[ h ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..he..[[,]]..hf-kK..[[ v ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c3<jY then jP[#jP+1]=kO else local jQ=eK(kN,kM)local kP=4;local kQ=ai+jY*math.cos(jQ)local kR=aj+jY*math.sin(jQ)jP[#jP+1]=d9('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jQ*180/math.pi,kQ,kR,kQ-kP,kR-kP/2,kP*2,kP,kQ+kP,kR-kP,kP,kP,-kP,kP)end;if not c8 then local kS=vec3(fl)kI=kC(-kS)kJ=kE(-kS)kM=-kJ/kH*jY;kN=kI/kG*jY;he=ai+kM;hf=aj+kN;c3=dc(kM^2+kN^2)if c3<jY then local kT=[[<circle
                                    cx="]]..he..[["
                                    cy="]]..hf..[["
                                    r="]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..he..[[,]]..hf-kK..[[ v ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..he..[[,]]..hf..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..he..[[,]]..hf..[[)" />
                                <path
                                    d="M ]]..he-kL..[[,]]..hf..[[ h ]]..kK..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..he..[[,]]..hf..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..he..[[,]]..hf..[[)"/>]]jP[#jP+1]=kT end end end end;local function kU(jP,j9,kV,kW)if ak==0 and al==0 then return end;kV=bH(kV+0.5)local jz=al+10;local jA=al+20;if io()==1 and not l then jz=55;jA=65 end;local kX="CRUISE"local c="km/h"local dB=kW;if j9=="TRAVEL"or j9=="AUTOPILOT"then kX="THROT"c="%"dB=kV;local kY="dim"if kV<0 then kY="red"end;jP[#jP+1]=d9([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kY,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eP(kV),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jP[#jP+1]=gD(ak+10,jz,kX,"pbright txtstart")jP[#jP+1]=gD(ak+10,jA,d9("%.0f %s",dB,c),"pbright txtstart")if c8 and t and cL and bM then kV=bH(bN*100+0.5)local kY="red"if kV<0 then kY="red"end;jP[#jP+1]=d9([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kY,1-eP(kV),ak-10,al+50,ak-15,al+53,ak-15,al+47)jP[#jP+1]=gD(ak+10,jz+40,"LIMIT","pbright txtstart")jP[#jP+1]=gD(ak+10,jA+40,kV.."%","pbright txtstart")end;if c8 and t or b5 then jP[#jP+1]=gD(ak+10,jz-40,"LIMIT: "..cv.." km/h","dim txtstart")elseif not c8 and b0 then jP[#jP+1]=gD(ak+10,jz-40,"LIMIT: "..bH(_*3.6+0.5).." km/h","dim txtstart")end end;local function kZ(jP,k_)if ak==0 and al==0 then return end;local l0=al-10;local l1=ak+10;jP[#jP+1]=gD(0,0,"","pdim txt txtend")if io()==1 and not l then l0=75 end;jP[#jP+1]=gD(l1,l0,bH(k_).." km/h","pbright txtbig txtstart")end;local function l2(jP)jP[#jP+1]=gD(j5(1900),j6(1070),d9("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jP[#jP+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jP[#jP+1]=gD(j5(960),j6(550),"Warning: Invalid Control Scheme Detected","warnings")jP[#jP+1]=gD(j5(960),j6(600),"Keyboard Scheme must be selected","warnings")jP[#jP+1]=gD(j5(960),j6(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l3=j5(960)local l4=j6(860)local l5=j6(880)local l6=j6(900)local l7=j6(960)local l8=j6(200)local l9=j6(250)local la=j6(960)if io()==1 and not l then l4=j6(135)l5=j6(155)l6=j6(175)l8=j6(115)l9=j6(95)end;local lb="#222222"local lc="white"local ld="dimmer"local le="pbright"local lf="#110000"local lg=lb;local lh=ld;if aY then local li=""if type(aY)=="string"then li="-"..aY end;jP[#jP+1]=gD(l3,l4,"Brake Engaged"..li,"warnings")lf="#440000"lg=lc;lh=le elseif bL>0 then jP[#jP+1]=gD(l3,l4,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local lj="#110000"local lk=lb;local ll=ld;if c8 and cu and c7==-1 then if not b0 and not bn and not b3 and not cK and not b6 and not b4 then jP[#jP+1]=gD(l3,l8+50,"** STALL WARNING **","warnings")lj="#ff0000"lk=lc;ll=le;fL("stall","SW",2)end end;if cR then jP[#jP+1]=gD(l3,l8+90,"Flight Assist in Progress","warnings")end;if cc then jP[#jP+1]=gD(l3,la,"Gyro Enabled","warnings")end;local lm="#111100"local ln=lb;local lo=ld;if bj then lm="#775500"ln=lc;lo=le;if bP then jP[#jP+1]=gD(l3,l5,"Gear Extended","warn")else jP[#jP+1]=gD(l3,l5,"Landed (G: Takeoff)","warnings")end;local lp=it(d:getTargetGroundAltitude())jP[#jP+1]=gD(l3,l6,"Hover Height: "..lp,"warn")end;local lq="#000011"local lr=lb;local ls=ld;if bY then lq="#0000DD"lr=lc;ls=le;jP[#jP+1]=gD(l3,l7+20,"ROCKET BOOST ENABLED","warn")end;local lt="#001100"local lu=lb;local lv=ld;if antigrav and not q and cK and bs~=nil then lt="#00DD00"lu=lc;lv=le;local lw="warnings"if eP(ca-antigrav.getBaseAltitude())<501 then lw="warn"end;jP[#jP+1]=gD(l3,l8+40,d9("Target Altitude: %d Singularity Altitude: %d",bH(bs),bH(antigrav.getBaseAltitude())),lw)end;if b0 and bg~="None"then jP[#jP+1]=gD(l3,l8,"Autopilot "..bd,"warn")elseif bq~=nil then jP[#jP+1]=gD(l3,l8+20,d9("LockedPitch: %d",bH(bq)),"warn")elseif bU then jP[#jP+1]=gD(l3,l8+20,"Follow Mode Engaged","warn")elseif b5 or c6 then jP[#jP+1]=gD(l3,l8+20,"Re-entry in Progress","warn")end;if b2 or b6 then local lp=it(b7,2)if b6 then if cK then lp=it(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jP[#jP+1]=gD(l3,l8,"VTO to "..lp,"warn")elseif b4 and not bw then if c5 then jP[#jP+1]=gD(l3,l8,"Takeoff to "..bg,"warn")else jP[#jP+1]=gD(l3,l8,"Takeoff to "..lp,"warn")end;if aY and not b6 then jP[#jP+1]=gD(l3,l8+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jP[#jP+1]=gD(l3,l8,"Altitude Hold: "..lp,"warn")end end;if b6 and(antigrav~=nil and antigrav)then if c9>0.1 then jP[#jP+1]=gD(l3,l8+20,"Beginning ascent","warn")elseif c9<0.09 and c9>0.05 then jP[#jP+1]=gD(l3,l8+20,"Aligning trajectory","warn")elseif c9<0.05 then jP[#jP+1]=gD(l3,l8+20,"Leaving atmosphere","warn")end end;if bw then if cw~=nil then jP[#jP+1]=gD(l3,l8,cw,"warn")end end;if b3 then if lx then local ly="Brake Landing"if d6 then ly=ly.."-Aligning"end;if d5 then ly=ly.."-Drift Limited"end;jP[#jP+1]=gD(l3,l8,ly,"warnings")else jP[#jP+1]=gD(l3,l8,"Coast-Landing","warnings")end end;if a_ then jP[#jP+1]=gD(l3,l8,"Prograde Alignment","crit")end;if aZ then jP[#jP+1]=gD(l3,l8,"Retrograde Alignment","crit")end;local lz="#110000"local lA=lb;local lB=ld;if cT then lz="#FF0000"lA=lc;lB=le;local type;if string.find(cT,"COLLISION")then type="warnings"else type="crit"end;jP[#jP+1]=gD(l3,l9+20,cT,type)elseif c9==0 then local lC,lD=cn.checkLOS(cE:normalize())if lD~=nil then lB=le;lz="#FF0000"lA=lc;local lp=it(lD)local lE=cj.computeTravelTime(cF,0,lD)local lF="Collision"if lC.noAtmosphericDensityAltitude>0 then lF="Atmosphere"end;jP[#jP+1]=gD(l3,l9+20,lC.name.." "..lF.." "..iu(lE).." In "..lp,"crit")end end;if bn and not bw then jP[#jP+1]=gD(l3,l8+60,lG,"warn")end;local lH="#111100"local lI=lb;local lJ=ld;if cX and#cX>1 then lH="#DDDD00"lI=lc;lJ=le end;local lK=j5;local lL=j6;local ld="topButton"local lM="topButtonActive"local lN=ld;if b0 or bn or c5 or bw then lN=lM end;local lO=ld;if a_ then lO=lM end;local lP=ld;if b3 or bj then lP=lM end;local lQ=ld;if b2 or bn then lQ=lM end;local lR=ld;if aZ then lR=lM end;local lS=ld;if bw or cy and b0 then lS=lM end;if w and I then local lT=lL(30)jP[#jP+1]=d9([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lN,lK(960),lL(54),lL(-53),lK(-120),lK(25),lL(50))jP[#jP+1]=gD(lK(910),lT,"AUTOPILOT")jP[#jP+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lO,lK(865),lL(51),lK(-25),lL(-50),lK(-110),lK(25),lL(46))jP[#jP+1]=gD(lK(800),lT,"PROGRADE")jP[#jP+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lP,lK(755),lL(47),lK(-25),lL(-46),lK(-98),lK(44),lL(44))jP[#jP+1]=gD(lK(700),lT,"LAND")jP[#jP+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lQ,lK(960),lL(54),lL(-53),lK(120),lK(-25),lL(50))jP[#jP+1]=gD(lK(1010),lT,"ALT HOLD")jP[#jP+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lR,lK(1055),lL(51),lK(25),lL(-50),lK(110),lK(-25),lL(46))jP[#jP+1]=gD(lK(1122),lT,"RETROGRADE")jP[#jP+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lS,lK(1165),lL(47),lK(25),lL(-46),lK(98),lK(-44),lL(44))jP[#jP+1]=gD(lK(1220),lT,"ORBIT")jP[#jP+1]=[[
                                    </g>
                                </g>]]jP[#jP+1]="</g>"end;return jP end;local function lU(fg)return bH(fM(fg*3.6,0)+0.5).." km/h"end;local function lV(gn)local gp=bg;if gn~=nil and type(gn)=="number"then if gn==0 then return"None"end;gp=cO[gn].name end;if gp==nil then gp=fX.name end;if gp==nil then gp="None"end;return gp end;local function lW(jP)local lX=cn.routeWP(true)if not lX or#lX==0 then return end;local he=j5(750)local hf=j6(360)if b0 or bn then jP[#jP+1]=gD(he,hf,"REMAINING ROUTE","pdim txtstart size20")else jP[#jP+1]=gD(he,hf,"LOADED ROUTE","pdim txtstart size20")end;for dA,K in pairs(lX)do hf=hf+20;jP[#jP+1]=gD(he,hf,dA..". "..lX[dA],"pdim txtstart size20")end end;local function lY(jP)local he=aw+10;local hf=ax+20;local lZ={}local l_={"Alt-4: AutoTakeoff to Target"}local m0={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m1={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local m2={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lZ,"--------------DYNAMIC-----------------")if c8 then if c7~=-1 then ir(lZ,l_)if c0 and j4 and c0.name==j4.name then table.insert(lZ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aX then if antigrav then if cK then table.insert(lZ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lZ,"Turn on AGG to takeoff to AGG Height")end end;if aX then table.insert(lZ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lZ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lZ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bj then table.insert(lZ,"G: Takeoff to hover height, raise gear")else table.insert(lZ,"G: Lowergear and Land")end else ir(lZ,m0)table.insert(lZ,"G: Begin BrakeLanding or Land")end;if b6 then table.insert(lZ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ir(lZ,m1)if shield_1 then table.insert(lZ,"Alt-Shift-6: Vent shields")if not G then table.insert(lZ,"Alt-Shift-7: Toggle shield off/on")end end end;if fX~=nil then table.insert(lZ,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lZ,"Alt-9: Activate Gyroscope")end;if aT~="none"or aS~="none"or aU~="none"then table.insert(lZ,"Alt-Shift-9: Cycles engines with Extra tags")end;if b2 then table.insert(lZ,"Alt-Spacebar/C will raise/lower target height")table.insert(lZ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c8 then table.insert(lZ,"LALT+Mousewheel will lower/raise speed limit")end;ir(lZ,m2)for K=1,#lZ do hf=hf+12;jP[#jP+1]=gD(he,hf,lZ[K],"pdim txtbig txtstart")end end;local function m3(jP)local m4=aw;local m5=ax;local m6=av;local m7=4;local m8=15;local he=0;local hf=0;local m9,ma,mb,mc;local md;local function me(type)local gz,bJ,fg,mf,jJ,mg;if type=="Periapsis"then gz=md.periapsis.altitude;bJ=md.timeToPeriapsis;fg=md.periapsis.speed;jJ="txtend"mf=12;mg=math.min(he,m4+m6-j4.radius/mb-m7*2)else gz=md.apoapsis.altitude;bJ=md.timeToApoapsis;fg=md.apoapsis.speed;mf=-12;jJ="txtstart"mg=he end;if cF<1 then bJ=0 end;jP[#jP+1]=d9([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mg+mf,hf-5,he,hf-5)jP[#jP+1]=d9([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mg-mf*4,hf+2,he,hf+2)jP[#jP+1]=gD(mg,hf,type,jJ)he=mg-mf*2;hf=hf+m8;local lp=it(gz)jP[#jP+1]=gD(he,hf,lp,jJ)hf=hf+m8;jP[#jP+1]=gD(he,hf,iu(bJ),jJ)hf=hf+m8;jP[#jP+1]=gD(he,hf,lU(fg),jJ)end;local mh=m6*1.5;if bE=="INFO"then mh=25*9 end;if bE~="HIDE"then jP[#jP+1]=[[<g class="pbright txtorb txtmid">]]jP[#jP+1]=d9('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m6*2,mh,m4,m5)jP[#jP+1]=d9([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m6*2,mh,m4,m5)end;local mi=m6*1.5;local mj=m6*2;local mk=mi/2;local ml=m6;local mm=m4+ml;local mn=m5+mk;local mo=m4+mj;local mp=m5+mi;if bE=="ORBIT"then m5=m5+m7;m9=m6/2;mc=0;md={}md.periapsis={}md.apoapsis={}if fk~=nil then if fk.periapsis~=nil then md.periapsis.altitude=fk.periapsis.altitude;md.periapsis.speed=fk.periapsis.speed end;if fk.apoapsis~=nil then md.apoapsis.altitude=fk.apoapsis.altitude;md.apoapsis.speed=fk.apoapsis.speed end;md.period=fk.period;md.eccentricity=fk.eccentricity;md.timeToApoapsis=fk.timeToApoapsis;md.timeToPeriapsis=fk.timeToPeriapsis;md.eccentricAnomaly=fk.eccentricAnomaly;md.trueAnomaly=fk.trueAnomaly end;if md.periapsis==nil then md.periapsis={}md.periapsis.altitude=-j4.radius;md.periapsis.speed=_ end;if md.eccentricity==nil then md.eccentricity=1 end;if md.apoapsis==nil then md.apoapsis={}md.apoapsis.altitude=ca;md.apoapsis.speed=0 end;if cF<1 then md.apoapsis.altitude=ca;md.apoapsis.speed=0 end;if md.apoapsis.altitude then mb=(md.apoapsis.altitude+md.periapsis.altitude+j4.radius*2)/(m9*2)ma=(j4.radius+md.apoapsis.altitude)/mb*(1-md.eccentricity)mc=m9-md.periapsis.altitude/mb-j4.radius/mb;local mq=math.pi;if md.period~=nil and md.period>0 and md.timeToApoapsis~=nil then mq=md.eccentricAnomaly;if md.timeToPeriapsis<md.timeToApoapsis then mq=2*math.pi-mq end end;if cF<1 or mq~=mq then mq=math.pi end;local mr=-m9*math.cos(mq)+m4+ml+m7;local ms=ma*math.sin(mq)+m5+mk+m7;local mt=""jP[#jP+1]='<g clip-path="url(#orbitRect)">'jP[#jP+1]=d9([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mt,m4+m6+m7,m5+m6*1.5/2+m7,m9,ma)if ma<1 then jP[#jP+1]=d9([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m4+m6+m7-mc,m5+m6*1.5/2+m7,mr,ms)end;jP[#jP+1]=d9('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m4+m6+m7-mc,m5+m6*1.5/2+m7,(j4.radius+j4.noAtmosphericDensityAltitude)/mb)jP[#jP+1]=d9('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m4+m6+m7-mc,m5+m6*1.5/2+m7,(j4.radius+j4.noAtmosphericDensityAltitude)/mb)jP[#jP+1]=d9([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m4+m6+m7,m5+m6*1.5/2+m7,m9,ma)jP[#jP+1]=d9('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m4+m6+m7-mc,m5+m6*1.5/2+m7,j4.radius/mb)jP[#jP+1]='</g>'local mu=math.floor(j4.radius/mb+0.5)he=m4+m6+m7*4+m9;hf=m5+m6*1.5/2+5+m7;if md.apoapsis~=nil and md.apoapsis.speed<_ then me("Apoapsis")end;hf=m5+m6*1.5/2+5+m7;he=m4+m6-m7*2-m9;if md.periapsis~=nil and md.periapsis.speed<_ and md.periapsis.altitude>0 then me("Periapsis")end;jP[#jP+1]=gD(m4+m6+m7,m5+20+m7,j4.name,"txtorbbig")jP[#jP+1]=d9('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mr,ms)jP[#jP+1]=[[</g>]]return jP else jP[#jP+1]='<g clip-path="url(#orbitRect)">'local mv=""local mw=1.2*(mx-my)/(m6*2)local mz=1.4*(mA-mB)/(m6*1.5)for dA,dl in pairs(e[0])do if dl.center then local he=m4+m6+dl.center.x/mw;local hf=m5+m6*1.5/2+dl.center.y/mz;mv=mv..'<circle cx="'..he..'" cy="'..hf..'" r="'..dl.radius/mw*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dl.name,"Moon")and not string.match(dl.name,"Sanctuary")and not string.match(dl.name,"Space")then mv=mv.."<text x='"..he.."' y='"..hf+dl.radius/mw*30+20 .."' font-size='12' fill="..iQ.." text-anchor='middle' font-family='Montserrat'>"..dl.name.."</text>"end end end;local fm=vec3(b.getConstructWorldPos())local he=m4+m6+fm.x/mw;local hf=m5+m6*1.5/2+fm.y/mz;mv=mv..'<circle cx="'..he..'" cy="'..hf..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mv=mv.."<text x='"..he.."' y='"..hf-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iC=mw;iD=mz;local mC=fm+cE*1000000;local mD=m4+m6+mC.x/mw;local jA=m5+m6*1.5/2+mC.y/mz;mv=mv..'<line x1="'..he..'" y1="'..hf..'" x2="'..mD..'" y2="'..jA..'" stroke="purple" stroke-width="1"/>'jP[#jP+1]=mv;jP[#jP+1]='</g>'end elseif bE=="INFO"then jP=cl.DrawOdometer(jP,iS,bk,iT)elseif bE=="HELP"then jP=lY(jP)elseif bE=="SCOPE"then jP[#jP+1]='<g clip-path="url(#orbitRect)">'local mE=c_;if c9>0 then table.sort(cZ,function(eq,er)local es,et=eq.center,er.center;return(es.x-cI.x)^2+(es.y-cI.y)^2+(es.z-cI.z)^2<(et.x-cI.x)^2+(et.y-cI.y)^2+(et.z-cI.z)^2 end)end;local gL={}local mF={}local mG=120;local mH=nil;local mI=nil;for K,dl in ipairs(cZ)do local gK=dl.center-cI;local mJ=gK:len()local mK=gK:normalize()local mL=gK:cross(cB):normalize()local mM=math.acos(mL:dot(cC))if mM~=mM then mM=0 end;if mL:cross(cC):dot(cB)<0 then mM=-mM end;local mN=gK:project_on_plane(cB):len()local mO=math.sin(mM)*math.asin(mN/mJ)*constants.rad2deg;local mP=math.cos(mM)*math.asin(mN/mJ)*constants.rad2deg;if mK:dot(cB)<0 then mP=90*math.cos(mM)+90*math.cos(mM)-mP;mO=90*math.sin(mM)+90*math.sin(mM)-mO end;local he=mm+mO/mE*mi;local hf=mn+mP/mE*mi;local mQ=(he-mm)*(he-mm)+(hf-mn)*(hf-mn)local mR=math.asin((dl.radius+dl.surfaceMaxAltitude)/mJ)*constants.rad2deg;if mR~=mR then mR=mE end;local hK=mR/mE*mi;local mS=math.asin(dl.atmosphereRadius/mJ)*constants.rad2deg;if mS~=mS then mS=mR end;local mT=mS/mE*mi;local c3=it(mJ,1)local mU=dl.name;local mV=false;if hf>m5 then if hf>mp then if hf-mT<=mp then mV=true end else mV=true end else if hf+mT>=m5 then mV=true end end;local mW=false;local mX=he;if dl.systemId==0 then mX=he+mG else mX=he-mG end;if mX+mG>m4 then if mX+mG>mo then if mX-mT-mG<=mo then mW=true end else mW=true end else if mX+mT+mG>=m4 then mW=true end end;local mY={}mY.x=he;mY.y=hf;mY.planet=dl;mY.atmoSize=mT;if not mH or mQ<mH then mH=mQ;mI=mY end;if mW and mV then local mZ=math.max(mT,5)if mQ<mZ*mZ then mU=mU.." - "..c3 end;mY.size=hK;mY.i=K;mY.displayString=mU;mY.distance=c3;mY.visible=true;mF[#mF+1]=mY else mY.visible=false end end;local m_=false;table.sort(mF,function(es,et)return es.y<et.y end)for dA,fp in ipairs(mF)do local dl,hK,K,mT,he,hf,mU,c3=fp.planet,fp.size,fp.i,fp.atmoSize,fp.x,fp.y,fp.displayString,fp.distance;local mg,n0,n1,n2;local n3=15;local jJ="pdim"if dl.systemId~=0 then n1=j5(string.len(mU)*5)n3=-(15+n1)n2=j6(10)jJ="pdimfill"else n1=j5(string.len(mU)*9)n2=j6(15)end;if hK*2>n1 then mg=da(he,m4+n1/2,mo-n1/2)n0=da(hf,m5+n2,mp-5)mg=da(mg,he-hK+n1/2,he+hK-n1/2)n0=da(n0,hf-hK+n2,hf+hK)else mg=he+n3;n0=hf end;for n4,fp in pairs(gL)do local n5=fp.textPositions;local n6=n5.y-n0;if n4~=K and eP(n6)<n5.height and n5.x+n5.width>mg and n5.x<mg+n1 then if hK>n1 then n0=da(n0+n2,m5+15,mp-5)else n0=n5.y+n5.height+1 end end end;local n7=mU~=dl.name or mg<=mm and mg+n1>=mm and n0-n2<=mn and n0>=mn;fp.hovered=n7;local n8=1;if n7 then n8=2;if hK*2<n1 then n8=10 end;if mU==dl.name then mU=mU.." - "..c3 end;jJ="pbright"if dl.systemId~=0 then n1=j5(string.len(mU)*5)n3=-(15+n1)else n1=j5(string.len(mU)*7)end;if hK*2>n1 then mg=da(he,m4+n1/2,mo-n1/2)mg=da(mg,he-hK+n1/2,he+hK-n1/2)else mg=he+n3 end end;gL[K]={}gL[K].textPositions={}gL[K].textPositions.y=n0;gL[K].textPositions.x=mg;gL[K].textPositions.width=n1;gL[K].textPositions.height=n2;gL[K].output=""if hK*2>n1 then jJ=jJ.." txtmid"else jJ=jJ.." txtstart"end;if mT-hK>2 then gL[K].output=d9('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',he,hf,mT,iR,0.1*n8)end;gL[K].output=gL[K].output..d9('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',he,hf,hK,iR,0.2*n8)if dl.systemId==0 then gL[K].output=gL[K].output..d9([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mg,n0,iQ,jJ,mU)if hK*2<=n1 then gL[K].output=gL[K].output..d9("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mg+n1,n0+2,mg,n0+2,he,hf)end else gL[K].output=gL[K].output..d9([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mg,n0,iR,jJ,mU)if hK*2<=n1 then gL[K].output=gL[K].output..d9("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mg,n0+2,mg+n1,n0+2,he,hf)end end end;for dA=#cZ,1,-1 do if gL[dA]then jP[#jP+1]=gL[dA].output end end;if mI~=nil and c_<90 and not mI.hovered then local n9=mI.planet.atmosphereRadius/mI.atmoSize;local na=dc(mH)*n9;local nb=it(na,1)local n1=j5(math.max(string.len(nb)*7,string.len(mI.planet.name)*7))local n2=j6(12)local mg=da(mI.x+(mm-mI.x)/2,m4+n1/2,mo-n1/2)local n0=da(mI.y+(mn-mI.y)/2,m5+n2*2,mp-5)jP[#jP+1]=d9("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mI.x,mI.y,mm,mn)jP[#jP+1]=d9([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mg,n0,"white",nb)if not mI.visible then jP[#jP+1]=d9([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mg,n0-n2,"white",mI.planet.name)end end;if cF>1 then local gK=cE;local mK=gK:normalize()local mN=gK:project_on_plane(cB):len()local mL=gK:cross(cB):normalize()local mM=math.acos(mL:dot(cC))if mM~=mM then mM=0 end;if mL:cross(cC):dot(cB)<0 then mM=-mM end;local mO=math.sin(mM)*math.asin(mN/gK:len())*constants.rad2deg;local mP=math.cos(mM)*math.asin(mN/gK:len())*constants.rad2deg;if mK:dot(cB)<0 then mP=90*math.cos(mM)+90*math.cos(mM)-mP;mO=90*math.sin(mM)+90*math.sin(mM)-mO end;local he=mm+mO/mE*mi;local hf=mn+mP/mE*mi;local kK=14;local kL=kK/2;local kO=[[<circle
                                    cx="]]..he..[["
                                    cy="]]..hf..[["
                                    r="]]..kL/kK..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..he..[["
                                    cy="]]..hf..[["
                                    r="]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..he-kK..[[,]]..hf..[[ h ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..he+kL..[[,]]..hf..[[ h ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..he..[[,]]..hf-kK..[[ v ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jP[#jP+1]=kO end;jP[#jP+1]=d9("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mm,mn-10,mm,mn+10)jP[#jP+1]=d9("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mm-10,mn,mm+10,mn)jP[#jP+1]='</g>'else return jP end end;local function nc(nd,ne)local nf;local ng=(ne-nd):normalize()local fn=(cI-nd):dot(ng)/ng:dot(ng)if fn<=0. then return(cI-nd):len()elseif fn>=(ne-nd):len()then return(cI-ne):len()end;local nh=nd+fn*ng;nf=(nh-cI):len()return nf end;local function ni()local nf;local nj=nil;local nk=nil;local nl=nil;for dA,nm in pairs(e[0])do if nm.hasAtmosphere then local c3=nc(j4.center,nm.center)if nj==nil or c3<nj then nk=nm;nj=c3;nl=j4 end;if c0 and c0.hasAtmosphere and c0.name~=j4.name then local eF=nc(c0.center,nm.center)if eF<nj then nk=nm;nj=eF;nl=c0 end end end end;local nn=j5(1770)local no=j6(330)if nj then local np="txttick "local nq=500000;if nj<nk.radius+nq or nj<nl.radius+nq then if cP then np="txttick red "else np="txttick orange "end end;nf=it(nj,2)iH=gD(nn,no,"Pipe ("..nl.name.."--"..nk.name.."): "..nf,np.."pbright txtmid")end end;local function nr(he,hf,ns,nt,kX)local nu={x=he,y=hf,width=ns,height=nt,label=kX}iB[kX]=nu;return nu end;local function nv(nw,nx,ns,nt,he,hf,ny,nz,nA,nB,jJ)local nu={enableName=nw,disableName=nx,width=ns,height=nt,x=he,y=hf,toggleVar=ny,toggleFunction=nz,drawCondition=nA,hovered=false,class=jJ}if nB then table.insert(iA,nu)else table.insert(iz,nu)end;return nu end;local function nC(nD)if not iF then nE=false;nF=false;nG=false;w=true;return elseif nD=="handling"then nE=not nE;nF=false;nG=false elseif nD=="hud"then nF=not nF;nE=false;nG=false elseif nD=="physics"then nG=not nG;nE=false;nF=false end;if nG or nF or nE then iG=is(nD)w=false else iG="none"w=true end end;local function nH()iF=not iF;if iF then iy=iA;bW="Hold SHIFT to see Settings"d0=w else iy=iz;bW="Hold SHIFT to see Control Buttons"nC()w=d0 end end;local function nI()local function nJ(dl,dA)dl.set(not dl.get())if dl.get()then bW=dA.." set to true"else bW=dA.." set to false"end;if dA=="showHud"then d0=dl.get()elseif dA=="BrakeToggleDefault"then aW=j end end;local nK=50;local nL=340;local he=500;local hf=ce/2-400;local nM=0;for dA,dl in pairs(is("boolean"))do if type(dl.get())=="boolean"then nv(dA,dA,nL,nK,he,hf,function()return dl.get()end,function()nJ(dl,dA)end,function()return true end,true)hf=hf+nK+20;if nM==9 then he=he+nL+20;hf=ce/2-400;nM=0 else nM=nM+1 end end end;nv("Control View","Control View",nL,nK,10,ce/2-500,function()return true end,nH,function()return true end,true)nv("View Handling Settings",'Hide Handling Settings',nL,nK,10,ce/2-(500-nK),function()return nE end,function()nC("handling")end,function()return true end,true)nv("View Hud Settings",'Hide Hud Settings',nL,nK,10,ce/2-(500-nK*2),function()return nF end,function()nC("hud")end,function()return true end,true)nv("View Physics Settings",'Hide Physics Settings',nL,nK,10,ce/2-(500-nK*3),function()return nG end,function()nC("physics")end,function()return true end,true)end;local function nN()local function go()local fO=cI;local gp=j4.name..". "..#bm;if radar_1 then gp=co.GetClosestName(gp)end;return cm.AddNewLocation(gp,fO,false,true)end;local function nO()b1=not b1 end;local function nP(nQ)if nQ==1 then a_=not a_;aZ=false else aZ=not aZ;a_=false end;b0=false;b2=false;bU=false;b3=false;bq=nil;b5=false;b4=false end;local function nR(nS,nT)cm.UpdatePosition(nil,nS,nT)end;local function gj()cm.ClearCurrentPosition()end;local function nU(gn)local lX=cn.routeWP(true)if lX and#lX>0 then return"Engage Route: "..lX[1]end;return"Engage Autopilot: "..lV(gn)end;local function nV(gn)local lX=cn.routeWP(true)if lX and#lX>0 then return"Next Route Point: "..lX[1]end;return"Disable Autopilot: "..lV(gn)end;local function nW()if io()==1 then bU=not bU;if bU then b0=false;aZ=false;a_=false;b2=false;b5=false;b3=false;b4=false;nX=bj;bj=false;d.control.retractLandingGears()ip:setTargetGroundAltitude(X)fL("folOn","F")else fL("folOff","F")aY="Follow Off"ct=p;bj=nX;if bj then d.control.extendLandingGears()ip:setTargetGroundAltitude(Y)end end else bW="Follow Mode only works with Remote controller"bU=false end end;local nK=50;local nL=260;local nY=j5(30)local nZ=aw+av*2+2;local n_=ax+1;nv("+","+",nY,nY,nZ,n_+nY+1,function()return false end,function()c_=c_/8 end,function()return bE=="SCOPE"end,nil,"ZoomButton")nv("-","-",nY,nY,nZ,n_,function()return false end,function()c_=math.min(c_*8,90)end,function()return bE=="SCOPE"end,nil,"ZoomButton")nv("0","0",nY,nY,nZ,n_+nY*2+2,function()return false end,function()c_=90 end,function()return bE=="SCOPE"and c_~=90 end,nil,"ZoomButton")local o0=nv("Enable Brake Toggle","Disable Brake Toggle",nL,nK,cd/2-nL/2,ce/2+350,function()return aW end,function()aW=not aW;if aW then bW="Brakes in Toggle Mode"else bW="Brakes in Default Mode"end end)nv("Align Prograde","Disable Prograde",nL,nK,cd/2-nL/2-50-o0.width,ce/2-nK+380,function()return a_ end,function()nP(1)end)nv("Align Retrograde","Disable Retrograde",nL,nK,cd/2-nL/2+o0.width+50,ce/2-nK+380,function()return aZ end,nP,function()return c9==0 end)o1=nv(nU,nV,600,60,cd/2-600/2,ce/2-60/2-330,function()return b0 or bn or c5 or bw end,function()end)local K;local function o2(o3)local gn=cW+o3;if gn>#cO then gn=gn-#cO-1 end;if gn<0 then gn=#cO+gn end;return gn end;o4={}for K=0,10 do local o5=nv(function(et)local gn=o2(et.apExtraIndex)if b0 or bn or c5 or bw then return"Redirect: "..lV(gn)end;return nU(gn)end,function(et)local gn=o2(et.apExtraIndex)return nV(gn)end,600,60,cd/2-600/2,ce/2-60/2-330+60*K,function(et)local gn=o2(et.apExtraIndex)return gn==bi and(b0 or bn or c5 or bw)end,function(et)local gn=o2(et.apExtraIndex)local o6=bi==gn;bi=gn;cm.UpdateAutopilotTarget()cn.ToggleAutopilot()if not o6 and not(b0 or bn or c5 or bw)then cn.ToggleAutopilot()end end,function()return cV and(#cn.routeWP(true)==0 or K==0)end)o5.apExtraIndex=K;o4[K]=o5 end;nv("Save Position","Save Position",200,o1.height,o1.x+o1.width+30,o1.y,function()return false end,go,function()return bi==0 or fX==nil end)nv("Update Position","Update Position",200,o1.height,o1.x+o1.width+30,o1.y,function()return false end,function()nR(nil)end,function()return bi>0 and fX~=nil end)nv("Save Heading","Clear Heading",200,o1.height,o1.x+o1.width+30,o1.y+o1.height+20,function()return fX.heading~=nil end,function()if fX.heading~=nil then nR(false)else nR(true)end end,function()return bi>0 and fX~=nil end)nv("Save AGG Alt","Clear AGG Alt",200,o1.height,o1.x+o1.width+30,o1.y+o1.height*2+40,function()return fX.agg~=nil end,function()if fX.agg~=nil then nR(nil,false)else nR(nil,true)end end,function()return bi>0 and fX~=nil and antigrav end)nv("Clear Position","Clear Position",200,o1.height,o1.x-200-30,o1.y,function()return true end,gj,function()return bi>0 and fX~=nil end)nv("Save Route","Save Route",200,o1.height,o1.x-200-30,o1.y+o1.height*2+40,function()return false end,function()cn.routeWP(false,false,2)end,function()return#cn.routeWP(true)>0 end)nv("Load Route","Clear Route",200,o1.height,o1.x-200-30,o1.y+o1.height+20,function()return#cn.routeWP(true)>0 end,function()if#cn.routeWP(true)>0 then cn.routeWP(false,true)elseif b0 or bn then bW="Disable Autopilot before loading route"return else cn.routeWP(false,false,1)end end,function()return true end)nK=60;nL=300;local he=0;local hf=ce/2-150;nv("Enable Check Damage","Disable Check Damage",nL,nK,he,hf-nK-20,function()return s end,function()s=not s end)nv("View Settings","View Settings",nL,nK,he,hf,function()return true end,nH)hf=hf+nK+20;nv("Enable Turn and Burn","Disable Turn and Burn",nL,nK,he,hf,function()return b1 end,nO)he=10;hf=ce/2-300;nv("Horizontal Takeoff Mode","Vertical Takeoff Mode",nL,nK,he+nL+20,hf,function()return aX end,function()aX=not aX;if aX then bW="Vertical Takeoff Mode"else bW="Horizontal Takeoff Mode"end end,function()return cJ end)hf=hf+nK+20;nv("Engage Orbiting","Cancel Orbiting",nL,nK,he+nL+20,hf,function()return bw end,cn.ToggleIntoOrbit,function()return c9==0 and cS end)hf=ce/2-150;nv("Glide Re-Entry","Cancel Glide Re-Entry",nL,nK,he+nL+20,hf,function()return b5 end,function()c4=1;nP(1)end,function()return j4.hasAtmosphere and not c8 end)hf=hf+nK+20;nv("Parachute Re-Entry","Cancel Parachute Re-Entry",nL,nK,he+nL+20,hf,function()return b5 end,function()c4=2;nP(1)end,function()return j4.hasAtmosphere and not c8 end)hf=hf+nK+20;nv("Engage Follow Mode","Disable Follow Mode",nL,nK,he,hf,function()return bU end,nW,function()return io()==1 end)nv("Enable Repair Arrows","Disable Repair Arrows",nL,nK,he+nL+20,hf,function()return iW end,function()iW=not iW;if iW then bW="Repair Arrows Enabled"else bW="Repair Arrows Diabled"end end,function()return io()==1 end)hf=hf+nK+20;if not q then nv("Enable AGG","Disable AGG",nL,nK,he,hf,function()return cK end,cn.ToggleAntigrav,function()return antigrav~=nil end)end;nv(function()return d9("Switch IPH Mode - Current: %s",bx)end,function()return d9("IPH Mode: %s",bx)end,nL*2,nK,he,hf,function()return false end,function()if bx=="All"then bx="Custom Only"elseif bx=="Custom Only"then bx="No Moons"else bx="All"end;bW="IPH Mode: "..bx end)hf=hf+nK+20;nv(function()return d9("Toggle Control Scheme - Current: %s",g)end,function()return d9("Control Scheme: %s",g)end,nL*2,nK,he,hf,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bW="New Control Scheme: "..g end)local o7=j6(20)local o5=nr(0,0,j5(70),o7,"HELP")o5=nr(o5.x+o5.width,o5.y,j5(80),o7,"INFO")o5=nr(o5.x+o5.width,o5.y,j5(70),o7,"ORBIT")o5=nr(o5.x+o5.width,o5.y,j5(70),o7,"SCOPE")nr(o5.x+o5.width,o5.y,j5(70),o7,"HIDE")end;local o8={}local o9=nil;function o8.HUDPrologue(jP)cP,cQ=j2(cI)if not cP then iN=af;iO=ag;iP=ah else iN=ac;iO=ad;iP=ae end;iQ=[[rgb(]]..bH(iN+0.6)..","..bH(iO+0.6)..","..bH(iP+0.6)..[[)]]iR=[[rgb(]]..bH(iN*0.8+0.5)..","..bH(iO*0.8+0.5)..","..bH(iP*0.8+0.5)..[[)]]local oa=iQ;local ob=iR;local oc=[[rgb(]]..bH(iN*0.4+0.5)..","..bH(iO*0.4+0.5)..","..bH(iP*0.4+0.5)..[[)]]local od=iQ;local oe=iR;local of=oc;if j7()and not m then oa=[[rgb(]]..bH(iN*0.5+0.5)..","..bH(iO*0.5+0.5)..","..bH(iP*0.5+0.5)..[[)]]ob=[[rgb(]]..bH(iN*0.3+0.5)..","..bH(iO*0.3+0.5)..","..bH(iP*0.2+0.5)..[[)]]oc=[[rgb(]]..bH(iN*0.2+0.5)..","..bH(iO*0.2+0.5)..","..bH(iP*0.2+0.5)..[[)]]end;local lK=j5;local lL=j6;jP[#jP+1]=d9([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],oa,oa,oa,od,od,ob,ob,oe,oe,ob,oa,oc,oe,oa,oa,oc,oc,of,oc,cd,ce,ob,ob,ob,ob,ob,od,ob,oe,of,oe,oe,of)if not o9 then o9=d9([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lK(630),lL(0),lK(675),lL(45),lK(960),lL(55),lK(1245),lL(45),lK(1290),lL(0),lK(1000),lL(105),lK(1040),lL(59),lK(1250),lL(51),lK(1300),lL(0),lK(1920),lL(0),lK(1920),lL(20),lK(1400),lL(20),lK(1300),lL(105),lK(920),lL(105),lK(880),lL(59),lK(670),lL(51),lK(620),lL(0),lK(0),lL(0),lK(0),lL(20),lK(520),lL(20),lK(620),lL(105),lK(890),lL(59),lK(960),lL(62),lK(1030),lL(59),lK(985),lL(112),lK(1150),lL(112),lK(1100),lL(152),lK(820),lL(152),lK(780),lL(112),lK(935),lL(112),lK(890),lL(59),lK(960),lL(62),lK(1030),lL(59),lK(985),lL(112),lK(1150),lL(112),lK(1100),lL(152),lK(820),lL(152),lK(780),lL(112),lK(935),lL(112))end;if w and I then jP[#jP+1]=o9 end;return jP end;function o8.DrawVerticalSpeed(jP,dU)jO(jP,dU)end;function o8.UpdateHud(jP)local kD=cM;local og=cN;local jW=og;local kb=kD;local kV=bH(c.getThrottle())local k_=cF*3.6;local kW=c.getAxisCommandValue(0)local oh=j5(1770)local oi=j6(310)if t and cL then kW=bK;kV=bK*100 end;local j9=j8()local jX="ROLL"if kV==nil then kV=0 end;if not cS then if cF>5 then kD=kC(cD)og=kE(cD)else kD=0;og=0 end;jX="YAW"end;if cQ>50000 and not c8 then local oj;oj=it(cQ)jP[#jP+1]=gD(oh,oi,"PvP Boundary: "..oj,"pbright txtbig txtmid")end;jP[#jP+1]=iU;jP[#jP+1]=iL;jP[#jP+1]=i0;if iH~=""then jP[#jP+1]=iH end;if ja~=""then jP[#jP+1]=ja end;if jb~=""then jP[#jP+1]=jb end;jO(jP,ca)if io()==0 or l then if cS then jV(jP,ai,aj,jW,jX,cS)else jV(jP,ai,aj,og,jX,cS)end;if not j7()or m then if cS then jV(jP,ai,aj,jW,jX,cS)ka(jP,kb,jW,ai,aj,cS,bH(kE(cD)),cF)else jV(jP,ai,aj,og,jX,cS)ka(jP,kD,og,ai,aj,cS,bH(og),cF)end;kh(jP,ca,cS)kF(jP,cD,cF,ai,aj)end end;kU(jP,j9,kV,kW)kZ(jP,k_)l2(jP)m3(jP)if not iF and bV then lW(jP)end;return jP end;function o8.HUDEpilogue(jP)jP[#jP+1]="</svg>"return jP end;function o8.ExtraData(jP)local ok=j5(1240)local ol=j6(55)local om=ol+10;local on;local lK=j5;local lL=j6;local oo=0;local j9=j8()if aX then j9=j9 .."-VERTICAL"end;if E and not b4 and not b3 and cF>20 then j9=j9 .."-COLLISION ON"end;if bz~="Off"then j9="("..bz..")-"..j9 end;if b1 then j9="TB-"..j9 end;if not by then j9=j9 .."-DeCoupled"end;local op=lL(99)local oq=lL(80)local os=lL(85)local ot=lL(31)local ou=0;local ov=0;local ow=cb>1000000 and fM(cb/1000000,2).."kT"or fM(cb/1000,2).."T"if c8 then oo=br else oo=bp end;local ox,oy=cj.computeDistanceAndTime(cF,0,cb,0,0,oo)if ox<0 then ox=0 end;oo=fM(oo/(cb*ix),2).."g"local oz=d:maxForceForward()on=b.g()if on>0.1 then ov=cb*on;ov=fM(ov/(cb*ix),2).."g"ou=0.5*oz/on;ou=ou>1000000 and fM(ou/1000000,2).."kT"or fM(ou/1000,2).."T"end;oz=fM(oz/(cb*ix),2).."g"local oA=vec3(b.getWorldAcceleration()):len()/9.80665;on=b.g()jP[#jP+1]=[[<g class="dim txt txtend size14">]]if io()==1 and not l then ok=j5(1120)ol=j6(55)om=ol+10 elseif c8 and I then local oB=j5(770)jP[#jP+1]=gD(lK(895),op,"ATMO","")jP[#jP+1]=d9([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lK(895),os,lK(-80))jP[#jP+1]=gD(lK(815),oq,d9("%.1f%%",c9*100),"txtstart size20")end;if I then jP[#jP+1]=gD(lK(1025),op,"GRAVITY","txtstart")jP[#jP+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1025),os,lK(80))jP[#jP+1]=gD(lK(1105),oq,d9("%.2fg",on/9.80665),"size20")jP[#jP+1]=gD(lK(1125),op,"ACCEL","txtstart")jP[#jP+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1125),os,lK(80))jP[#jP+1]=gD(lK(1205),oq,d9("%.2fg",oA),"size20")jP[#jP+1]=gD(lK(695),op,"BRK TIME","")jP[#jP+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(695),os,lK(-80))jP[#jP+1]=gD(lK(615),oq,d9("%s",iu(oy)),"txtstart size20")jP[#jP+1]=gD(lK(635),lL(45),"TRIP","")jP[#jP+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(635),lL(31),lK(-90))if lE then jP[#jP+1]=gD(lK(545),lL(26),d9("%s",iu(lE)),"txtstart size20")end;jP[#jP+1]=gD(lK(795),op,"BRK DIST","")jP[#jP+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(795),os,lK(-80))jP[#jP+1]=gD(lK(715),oq,d9("%s",it(ox)),"txtstart size20")jP[#jP+1]=gD(lK(1285),lL(45),"MASS","txtstart")jP[#jP+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1285),lL(31),lK(90))jP[#jP+1]=gD(lK(1375),lL(26),d9("%s",ow),"size20")jP[#jP+1]=gD(lK(1220),op,"THRUST","txtstart")jP[#jP+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1220),os,lK(80))jP[#jP+1]=gD(lK(1300),oq,d9("%s",oz),"size20")jP[#jP+1]=gD(j5(960),j6(175),j9,"pbright txtbig txtmid size20")end;jP[#jP+1]="</g>"end;local oC=1-(a5*0.05+a6*0.05)function o8.FuelUsed(oD)local oE;if oD=="atmofueltank"then oE=d9("Atmo Fuel Used: %.1f L",jr[oD]/(4*oC))elseif oD=="spacefueltank"then oE=d9("Space Fuel Used: %.1f L",jr[oD]/(6*oC))else oE=d9("Rocket Fuel Used: %.1f L",jr[oD]/(0.8*oC))end;return oE end;function o8.DrawOdometer(jP,iS,bk,iT)if bE~="INFO"then return jP end;local on;local ou=0;local ov=0;local oo=0;local ow=cb>1000000 and fM(cb/1000000,2).." kTons"or fM(cb/1000,2).." Tons"if c8 then oo=br else oo=bp end;local ox,oy=cj.computeDistanceAndTime(cF,0,cb,0,0,oo)oo=fM(oo/(cb*ix),2).." g"local oz=d:maxForceForward()on=b.g()if on>0.1 then ov=cb*on;ov=fM(ov/(cb*ix),2).." g"ou=0.5*oz/on;ou=ou>1000000 and fM(ou/1000000,2).." kTons"or fM(ou/1000,2).." Tons"end;oz=fM(oz/(cb*ix),2).." g"if io()==0 or l then local oF=j5(aw+10)local oG=j6(ax+20)local oH=j5(aw+10+av/1.25)local nt=25;jP[#jP+1]="<g class='txtstart size14 bright'>"jP[#jP+1]=gD(oF,oG,d9("BrkTime: %s",iu(oy)))jP[#jP+1]=gD(oH,oG,d9("Trip: %.2f km",iS))jP[#jP+1]=gD(oF,oG+nt,d9("Lifetime: %.2f kSU",bk/200000))jP[#jP+1]=gD(oH,oG+nt,d9("BrkDist: %s",it(ox)))jP[#jP+1]=gD(oF,oG+nt*2,"Trip Time: "..iu(iT))jP[#jP+1]=gD(oH,oG+nt*2,"Total Time: "..iu(bl))jP[#jP+1]=gD(oF,oG+nt*3,d9("Mass: %s",ow))jP[#jP+1]=gD(oH,oG+nt*3,d9("Max Brake: %s",oo))jP[#jP+1]=gD(oF,oG+nt*4,d9("Max Thrust: %s",oz))if on>0.1 then jP[#jP+1]=gD(oH,oG+nt*4,d9("Max Thrust Mass: %s",ou))jP[#jP+1]=gD(oF,oG+nt*5,d9("Req Thrust: %s",ov))else jP[#jP+1]=gD(oH,oG+nt*4,"Max Mass: n/a")jP[#jP+1]=gD(oF,oG+nt*5,"Req Thrust: n/a")end;jP[#jP+1]=gD(oH,oG+nt*5,cl.FuelUsed("atmofueltank"))jP[#jP+1]=gD(oF,oG+nt*6,cl.FuelUsed("spacefueltank"))jP[#jP+1]=gD(oH,oG+nt*6,cl.FuelUsed("rocketfueltank"))if cF>833 then local oI=cb/math.sqrt(1-(cF/8333.33)^2)local ow=oI>1000000 and fM(oI/1000000,2).." kTons"or fM(oI/1000,2).." Tons"jP[#jP+1]=gD(oH,oG+nt*7,d9("Rel. Mass: %s",ow))end end;jP[#jP+1]="</g></g>"return jP end;function o8.DrawWarnings(jP)return l2(jP)end;function o8.DisplayOrbitScreen(jP)return m3(jP)end;function o8.DisplayMessage(jP,lp)if lp~="empty"then local hf=310;for ly in string.gmatch(lp,"([^\n]+)")do hf=hf+35;jP[#jP+1]=gD("50%",hf,ly,"msg")end end;if bX~=0 then c.setTimer("msgTick",bX)bX=0 end end;function o8.DrawDeadZone(jP)jP[#jP+1]=d9([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function o8.UpdatePipe()if c8 then iH=""return end;ni()end;function o8.DrawSettings(jP)local he=j5(640)local hf=j6(200)jP[#jP+1]=[[<g class="pbright txtvspd txtstart">]]local hI=0;for dA,dl in pairs(iG)do hI=hI+1;jP[#jP+1]=gD(he,hf,dA..": "..dl.get())hf=hf+20;if hI%12==0 then he=he+j5(350)hf=j6(200)end end;jP[#jP+1]=gD(j5(640),j6(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jP[#jP+1]="</g>"return jP end;local hY=j5(1770)local hZ=j6(350)local hX=j6(15)local hW=j5(1370)local i1,oJ;function o8.DrawRadarInfo()i0=co.GetRadarHud(hW,hX,hY,hZ)end;function o8.DrawTanks()if aq~=0 and ar~=0 then ja=gD(aq,ar,"","txtstart pdim txtfuel")js=ar;jt(aq,"Atmospheric ","ATMO",cf,jp,jq)jt(aq,"Space Fuel T","SPACE",cg,jn,jo)jt(aq,"Rocket Fuel ","ROCKET",ch,jl,jm)end end;function o8.DrawShield()local i7=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local oK=b.getPvPTimer()local oL=shield_1.getResistances()local oM="A: "..10+oL[1]*100 .."% / E: "..10+oL[2]*100 .."% / K:"..10+oL[3]*100 .."% / T: "..10+oL[4]*100 .."%"local he,hf=as-60,at+30;local jH=bH(d7*2.55)local jI=d9("rgb(%d,%d,%d)",255-jH,jH,0)local jJ=""jb=gD(he,hf,"","txtmid pdim txtfuel")if d7<10 and i7~="Shield Disabled"then jJ="red "end;oK=oK>0 and"   PvPTime: "..iu(oK)or""jb=jb..d9([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],he,hf,jI,d7*2,he,hf,he+2,hf+10,d7,oK)jb=jb..gD(he,hf-5,i7,jJ.."txtstart pbright txtbig")jb=jb..gD(he,hf+30,oM,jJ.."txtstart pbright txtsmall")end;function o8.hudtick()if not j4 then return end;local function oN(jP)local jL=bH(da(c3/(cd/4)*255,0,255))jP[#jP+1]=d9("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c1,c2,bH(iN+0.5)+jL,bH(iO+0.5)-jL,bH(iP+0.5)-jL)end;local function oO()for dF,dl in pairs(iy)do if dl.hovered then if not dl.drawCondition or dl.drawCondition(dl)then dl.toggleFunction(dl)end;dl.hovered=false end end;for dF,dl in pairs(iB)do if dl.hovered then bE=dl.label;dl.hovered=false end end end;local function oP()local function oQ(oR,oS,he,hf,ns,nt)if oR>=he and oR<=he+ns and oS>=hf and oS<=hf+nt then return true else return false end end;local he=c1+cd/2;local hf=c2+ce/2;for dF,dl in pairs(iy)do dl.hovered=oQ(he,hf,dl.x,dl.y,dl.width,dl.height)end;for dF,dl in pairs(iB)do dl.hovered=oQ(he,hf,dl.x,dl.y,dl.width,dl.height)end;if cV then local n7=false;for dF,et in ipairs(o4)do if et.hovered then n7=true;break end end;if o1.hovered then n7=true end;cV=n7 else cV=o1.hovered;if not cV then cW=bi end end end;local function oT(jP)if not bE or bE==""then bE="HELP"end;if w then for dA,dl in pairs(iB)do local jJ="dim brightstroke"local oU=0.2;if bE==dA then jJ="pbright dimstroke"oU=0.6 end;local oV=""if dl.hovered then oU=0.8;oV=";stroke:white"end;jP[#jP+1]=d9([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dl.width,dl.height,dl.x,dl.y,jJ,oU,oV)jP[#jP+1]=gD(dl.x+dl.width/2,dl.y+dl.height/2+5,dl.label,"txt txtmid pdim")end end end;local function oW(jP)local function oX(jP,oY,hover,he,hf,f9,oZ,o_,p0,p1,p2,o5)if type(p1)=="function"then p1=p1(o5)end;if type(p2)=="function"then p2=p2(o5)end;jP[#jP+1]=d9("<rect x='%f' y='%f' width='%f' height='%f' fill='",he,hf,f9,oZ)if oY then jP[#jP+1]=d9("%s'",o_)else jP[#jP+1]=p0 end;if hover then jP[#jP+1]=d9(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jP[#jP+1]=d9(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fM(ac*0.5,0),fM(ad*0.5,0),fM(ae*0.5,0))end;jP[#jP+1]=" rx='5'></rect>"jP[#jP+1]=d9("<text x='%f' y='%f' font-size='24' fill='",he+f9/2,hf+oZ/2+5)if oY then jP[#jP+1]="black"else jP[#jP+1]="white"end;jP[#jP+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oY then jP[#jP+1]=d9("%s</text>",p1)else jP[#jP+1]=d9("%s</text>",p2)end end;local p3=d9("rgb(%d,%d,%d)'",fM(ac*0.1,0),fM(ad*0.1,0),fM(ae*0.1,0))local p4=d9("rgb(%d,%d,%d)",fM(ac*0.8,0),fM(ad*0.8,0),fM(ae*0.8,0))local p5=oX;for dF,dl in pairs(iy)do local nx=dl.disableName;local nw=dl.enableName;if type(nx)=="function"then nx=nx(dl)end;if type(nw)=="function"then nw=nw(dl)end;if not dl.drawCondition or dl.drawCondition(dl)then p5(jP,dl.toggleVar(dl),dl.hovered,dl.x,dl.y,dl.width,dl.height,p4,p3,nx,nw,dl)end end end;local p6=fM(cd/2,0)local p7=fM(ce/2,0)local jP={}cl.HUDPrologue(jP)if w then cl.UpdateHud(jP)else if A then cl.DrawVerticalSpeed(jP,ca)end;cl.DrawWarnings(jP)end;if iF and iG~="none"then cl.DrawSettings(jP)end;if radar_1 then cl.DrawRadarInfo()end;cl.HUDEpilogue(jP)jP[#jP+1]=d9([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cd,ce)if bW~="empty"then cl.DisplayMessage(jP,bW)end;if io()==0 and g=="virtual joystick"then if v then cl.DrawDeadZone(jP)end end;oT(jP)if iq()==0 then if io()==1 and bV then if not p8 then oP()oW(jP)end;if not cr and not cs then local p9=table.concat(jP,"")jP={}jP[#jP+1]=d9("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jP[#jP+1]=p9;jP[#jP+1]="</body>"cr=true;jP[#jP+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local pa=table.concat(jP,"")a.setScreen(pa)elseif cs then local p9=table.concat(jP,"")jP={}jP[#jP+1]=d9("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jP[#jP+1]=p9;jP[#jP+1]="</body>"end;if not cr then jP[#jP+1]=d9([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p6,p7,c1,c2)end else oO()end else if not bV and io()==0 then oO()if c3>au then if v then oN(jP)end end elseif bV and(not p8 or not i)then oP()oW(jP)end;jP[#jP+1]=d9([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p6,p7,c1,c2)end;jP[#jP+1]=[[</svg></body>]]pa=table.concat(jP,"")end;function o8.TenthTick()local function pb()local pc=a.createData;local pd=a.createWidget;pe=a.createWidgetPanel("Interplanetary Helper")pf=pd(pe,"value")pg=pc('{"label": "Target Planet", "value": "N/A", "unit":""}')fK(pg,pf)ph=pd(pe,"value")pi=pc('{"label": "distance", "value": "N/A", "unit":""}')fK(pi,ph)gd=pd(pe,"value")gc=pc('{"label": "Travel Time", "value": "N/A", "unit":""}')fK(gc,gd)gb=pd(pe,"value")ga=pc('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fK(ga,gb)gf=pd(pe,"value")ge=pc('{"label": "Target Altitude", "value": "N/A", "unit":""}')fK(ge,gf)g7=pd(pe,"value")g6=pc('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g5=pd(pe,"value")g4=pc('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g3=pd(pe,"value")g2=pc('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g1=pd(pe,"value")g0=pc('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g9=pd(pe,"value")g8=pc('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c8 then fK(g6,g7)fK(g4,g5)fK(g2,g3)fK(g0,g1)fK(g8,g9)end end;local function pj()gC(pe)pe=nil end;local function pk()if not b0 then if fX==nil or fX.planetname~=j4.name then pl=(c0.center-cI):len()else pl=(fX.position-cI):len()end end;local fg=cF;local pm=c.getThrottle()/100;if t then pm=bK end;local pn,po=cj.computeDistanceAndTime(cF,_,cb,d:maxForceForward()*pm,a1,0)local bZ,b_;if not b1 then bZ,b_=cn.GetAutopilotBrakeDistanceAndTime(_)else bZ,b_=cn.GetAutopilotTBBrakeDistanceAndTime(_)end;local dF,pp;if not b1 and fg>0 then dF,pp=cn.GetAutopilotBrakeDistanceAndTime(fg)else dF,pp=cn.GetAutopilotTBBrakeDistanceAndTime(fg)end;local pq=0;local pr=0;if bb or not b0 and fg>5 then pr=cj.computeTravelTime(fg,0,pl)elseif bZ+pn<pl then pq=pl-(bZ+pn)pr=cj.computeTravelTime(8333.0556,0,pq)else local ps=(pl-bZ)/pn;pn=pl-bZ;po=po*ps end;if fX~=nil and fX.planetname==j4.name and not b0 then return pr elseif ba then return pp elseif bb then return pr+pp else return po+b_+pr end end;cl.DrawTanks()if shield_1 then cl.DrawShield()end;if bg~="None"then if pe==nil then pb()end;if bg~=nil then local pt=fX~=nil;local pu=0.5*br/c0:getGravity(c0.center+vec3(0,0,1)*c0.radius):len()pu=pu>1000000 and fM(pu/1000000,2).." kTons"or fM(pu/1000,2).." Tons"fJ(pg,'{"label": "Target", "value": "'..bg..'", "unit":""}')lE=pk()if pt and not b0 then c3=(cI-fX.position):len()else c3=(bh-cI):len()end;if not b1 then bZ,b_=cn.GetAutopilotBrakeDistanceAndTime(cF)iJ,iK=cn.GetAutopilotBrakeDistanceAndTime(_)else bZ,b_=cn.GetAutopilotTBBrakeDistanceAndTime(cF)iJ,iK=cn.GetAutopilotTBBrakeDistanceAndTime(_)end;local lp=it(c3)fJ(pi,'{"label": "distance", "value": "'..lp..'"}')fJ(gc,'{"label": "Travel Time", "value": "'..iu(lE)..'", "unit":""}')lp=it(bZ)fJ(g6,'{"label": "Cur Brake distance", "value": "'..lp..'"}')fJ(g4,'{"label": "Cur Brake Time", "value": "'..iu(b_)..'", "unit":""}')lp=it(iJ)fJ(g2,'{"label": "Max Brake distance", "value": "'..lp..'"}')fJ(g0,'{"label": "Max Brake Time", "value": "'..iu(iK)..'", "unit":""}')fJ(ga,'{"label": "Max Brake Mass", "value": "'..d9("%s",pu)..'", "unit":""}')lp=it(gg)fJ(ge,'{"label": "Target Orbit", "value": "'..lp..'"}')if c9>0 and not pv then a.removeDataFromWidget(g0,g1)a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)pv=true;if not cL and t and(b2 or b5 or c6)then cn.cmdThrottle(1)aY=false;bO=false end end;if c9==0 and pv then if fJ(g0,g1)==1 then fK(g0,g1)end;if fJ(g2,g3)==1 then fK(g2,g3)end;if fJ(g4,g5)==1 then fK(g4,g5)end;if fJ(g6,g7)==1 then fK(g6,g7)end;if fJ(g8,g9)==1 then fK(g8,g9)end;pv=false end end else pj()end;if warpdrive~=nil then if il(warpdrive.getData()).destination~="Unknown"and il(warpdrive.getData()).distance>400000 then warpdrive.show()pw=true else warpdrive.hide()pw=false end end end;function o8.OneSecondTick()local function px()local jD=bG()local k_=cF;local py=jD-iV;if k_>1.38889 then k_=k_/1000;local pz=k_*(jD-iV)bk=bk+pz;iS=iS+pz end;iT=iT+py;bl=bl+py;iV=jD end;local function pA(jP)local pB=0;iL=""local pC=iw;local pD=0;local pE=0;local pF=0;local jH=0;local jI=""local pG=b.getElementHitPointsById;local pH=b.getElementMaxHitPointsById;local pI={}for dA in pairs(iv)do local pJ=0;local pK=0;pK=pH(iv[dA])pJ=pG(iv[dA])pD=pD+pJ;if pJ<pK then if pJ==0 then pF=pF+1 else pE=pE+1 end;if iW and#pI==0 then fO=vec3(b.getElementPositionById(iv[dA]))local he=fO.x;local hf=fO.y;local hg=fO.z;table.insert(pI,b.spawnArrowSticker(he,hf,hg+1,"down"))table.insert(pI,b.spawnArrowSticker(he,hf,hg+1,"down"))b.rotateSticker(pI[2],0,0,90)table.insert(pI,b.spawnArrowSticker(he+1,hf,hg,"north"))table.insert(pI,b.spawnArrowSticker(he+1,hf,hg,"north"))b.rotateSticker(pI[4],90,90,0)table.insert(pI,b.spawnArrowSticker(he-1,hf,hg,"south"))table.insert(pI,b.spawnArrowSticker(he-1,hf,hg,"south"))b.rotateSticker(pI[6],90,-90,0)table.insert(pI,b.spawnArrowSticker(he,hf-1,hg,"east"))table.insert(pI,b.spawnArrowSticker(he,hf-1,hg,"east"))b.rotateSticker(pI[8],90,0,90)table.insert(pI,b.spawnArrowSticker(he,hf+1,hg,"west"))table.insert(pI,b.spawnArrowSticker(he,hf+1,hg,"west"))b.rotateSticker(pI[10],-90,0,90)table.insert(pI,iv[dA])end elseif iW and#pI>0 and pI[11]==iv[dA]then for jC in pairs(pI)do b.deleteSticker(pI[jC])end;pI={}end end;pB=bH(pD/pC*100)if pB<100 then jP[#jP+1]=gD(0,0,"","pbright txt")jH=bH(pB*2.55)jI=d9("rgb(%d,%d,%d)",255-jH,jH,0)if pB<100 then jP[#jP+1]=gD("50%",1035,"Elemental Integrity: "..pB.."%","txtbig txtmid","fill:"..jI)if pF>0 then jP[#jP+1]=gD("50%",1055,"Disabled Modules: "..pF.." Damaged Modules: "..pE,"txtbig txtmid","fill:"..jI)elseif pE>0 then jP[#jP+1]=gD("50%",1055,"Damaged Modules: "..pE,"txtbig txtmid","fill:"..jI)end end end end;local function pL()if ik then if iM==nil and(d2~=nil or bj)then _autoconf.displayCategoryPanel(ik,weapon_size,"Weapons","weapon",true)iM=_autoconf.panels[_autoconf.panels_size]elseif iM~=nil and d2==nil and not bj then gC(iM)iM=nil end end end;cX=b.getPlayersOnBoard()cY=b.getDockedConstructs()local jP={}px()if s then pA(jP)end;pL()cl.UpdatePipe()cl.ExtraData(jP)iU=table.concat(jP,"")collectgarbage("collect")end;function o8.AnimateTick()cs=true;cr=false;c1=0;c2=0;c.stopTimer("animateTick")end;function o8.MsgTick()local jP={}cl.DisplayMessage(jP,"empty")bW="empty"c.stopTimer("msgTick")bX=3 end;function o8.ButtonSetup()nI()nN()iy=iz end;return o8 end;local function pM(d,b,c,a,e,vBooster,hover,pN,antigrav,warpdrive,dbHud_1,eP,bH,bI,io,eK,bG,da,ip,fJ,iq,dc,fM,fL,ir,dd,it,iu,pO,il,d9,fK)local pP={}local function pQ(fg)local pR=bc;if not b0 then pR=0 end;if not c8 then return cj.computeDistanceAndTime(fg,pR,cb,0,0,bp-be*cb)else if br and br>0 then return cj.computeDistanceAndTime(fg,pR,cb,0,0,br-be*cb)else return 0,0 end end end;local function pS(fg)local pR=bc;if not b0 then pR=0 end;return cj.computeDistanceAndTime(fg,pR,cb,d:maxForceForward(),a1,bp-be*cb)end;local pT=false;local pU=0;local pV=0;local pW=0;local pX=bG()local pY=0;local pZ=0;local p_=0;local q0=0;local q1=false;local q2=false;local q3=false;local q4=nil;local q5=0;local iI=55;local q6=nil;local q7=false;local q8=false;local q9=false;local qa=0;local qb=0;local qc=0;local qd=0;local qe=0;local qf={VectorToTarget=false}local qg=vec3(b.getConstructWorldOrientationUp())local qh=nil;local qi=""function pP.clearAll()b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"aZ=false;a_=false;cR=nil;b2=false;b5=false;b3=false;aY=false;b4=false;b6=false;bU=false;q8=false;c4=false;c5=false;q9=false;ct=p;bn=false;b1=false;cc=false;bq=nil;bw=false;d5=false;d6=nil end;function pP.GetAutopilotBrakeDistanceAndTime(fg)return pQ(fg)end;function pP.GetAutopilotTBBrakeDistanceAndTime(fg)return pS(fg)end;local function qj(qk,ql,qm)ql=ql:project_on_plane(qk)qm=qm:project_on_plane(qk)return eK(ql:cross(qm):dot(qk),ql:dot(qm))end;local function qn()local function qo()local qp=-1;local qq=-1;if vBooster then qp=vBooster.getDistance()end;if hover then qq=hover.getDistance()end;if qp~=-1 and qq~=-1 then if qp<qq then return qp else return qq end elseif qp~=-1 then return qp elseif qq~=-1 then return qq else return-1 end end;local qr=qo()local qs=-1;if pN then qs=pN.getDistance()end;if qr~=-1 and qs~=-1 then if qr<qs then return qr else return qs end elseif qr~=-1 then return qr else return qs end end;local function qt(j4,eB,qu)local function qv(qw,dM)local eH=vec3(dM)if qw.id==0 then return setmetatable({latitude=eH.x,longitude=eH.y,altitude=eH.z,id=0,systemId=qw.systemId},dO)end;local eI=eH-qw.center;local c3=eI:len()local dU=c3-qw.radius;local dS=0;local dT=0;if not dd(c3,0)then local eJ=eK(eI.y,eI.x)dT=eJ>=0 and eJ or 2*math.pi+eJ;dS=math.pi/2-math.acos(eI.z/c3)end;return setmetatable({latitude=math.deg(dS),longitude=math.deg(dT),altitude=dU,id=qw.id,systemId=qw.systemId},dO)end;local qx=qv(j4,eB)qx="::pos{"..qx.systemId..","..qx.id..","..qx.latitude..","..qx.longitude..","..qx.altitude.."}"if qu then return qx else a.setWaypoint(qx)return true end end;local qy=false;local qz=false;function pP.showWayPoint(j4,eB,qu)return qt(j4,eB,qu)end;function pP.APTick()local function qA()if cU and not b3 then local ei=cU[1]local hN,hO=cU[2],cU[3]local qB=math.min(hN,hO or hN)local qC=qB/cF;local qD=b4 and(cF<42 or c7~=-1)local qE=b2 or bn or bq or b0;if qE and not qD and(bZ*1.5>qB or qC<1)then aY="Collision"bC={}cn.cmdThrottle(0)if b2 then cn.ToggleAltitudeHold()end;if bq then cn.ToggleLockPitch()end;bW="Autopilot Cancelled due to possible collision"if bn or b0 then cn.ToggleAutopilot()end;lx=true;b3=true;ct=true end;if qC<11 then cT=ei.name.." COLLISION "..iu(qC).." / "..it(qB,2)else cT=ei.name.." collision "..iu(qC)end;if qC<6 then fL("alarm","AL",2)end else cT=false end end;local function qF(qG,qH,qI)local function qJ(qG,ek)qG=vec3(qG)ek=vec3(ek):normalize()local dv=qG*ek;return dv.x+dv.y+dv.z end;local qK=0.001;local qL=1;if not c8 or not cu or c7~=-1 or cF<iI then if qI==nil then qI=aO end;if qH==nil then qH=qK end;qG=vec3(qG):normalize()local qM=vec3()-qG;local qN=-qJ(qM,b.getConstructWorldOrientationRight())*qL;local qO=-qJ(qM,b.getConstructWorldOrientationUp())*qL;if pV==0 then pV=qN/2 end;if pW==0 then pW=qO/2 end;if eP(qN)<0.1 then qb=qb-qN*2 else qb=qb-(qN+(qN-pV)*qI)end;if eP(qO)<0.1 then qa=qa+qO*2 else qa=qa+qO+(qO-pW)*qI end;pV=qN;pW=qO;if eP(qN)<qH and eP(qO)<qH then return true end;return false elseif cu and c7==-1 then qG=cE;if qI==nil then qI=aO end;if qH==nil then qH=qK end;qG=vec3(qG):normalize()local qM=cB-qG;local qN=-qJ(qM,b.getConstructWorldOrientationRight())*qL;local qO=-qJ(qM,b.getConstructWorldOrientationUp())*qL;if pV==0 then pV=qN/2 end;if pW==0 then pW=qO/2 end;if eP(qN)<0.1 then qb=qb-qN*5 else qb=qb-(qN+(qN-pV)*qI)end;if eP(qO)<0.1 then qa=qa+qO*5 else qa=qa+qO+(qO-pW)*qI end;pV=qN;pW=qO;if eP(qN)<qH and eP(qO)<qH then return true end;return false end end;c8=bI()>0;c9=bI()ca=b.getAltitude()c7=qn()bJ=bG()pX=bJ;if E then qA()end;if antigrav then cK=antigrav.getState()==1 end;local qP=a.getMouseWheel()if qP>0 then cn.changeSpd()elseif qP<0 then cn.changeSpd(true)else q7=true end;local qQ=1;local qR=1;local qS=bJ-pX;local qT=-math.deg(qj(qg,cE,cB))local qU=math.deg(qj(cC,cE,cB))local gi=cG*-1;cu=c8 and qT<-L or qT>L or qU<-M or qU>M;local qV=a.getMouseDeltaX()local qW=a.getMouseDeltaY()if o and not bV then qW=-qW end;qb=0;qc=0;qa=0;fP=ci[0]j4=fP:closestBody(b.getConstructWorldPos())qX=ck(j4)fk=qX:orbitalParameters(b.getConstructWorldPos(),cE)if ca==0 then ca=(cI-j4.center):len()-j4.radius end;cS=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;local on=j4:getGravity(b.getConstructWorldPos()):len()*cb;qd=0;local qY=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if iq()==0 then if io()==1 and bV then if not cr then c1=da(c1+qV,-cd/2,cd/2)c2=da(c2+qW,-ce/2,ce/2)end else c1=0;c2=0 end else c1=da(c1+qV,-cd/2,cd/2)c2=da(c2+qW,-ce/2,ce/2)c3=dc(c1*c1+c2*c2)if not bV and io()==0 then local kM,kN=1,1;if bE=="SCOPE"then kM,kN=c_/90,c_/90 end;if g=="virtual joystick"then if c1>0 and c1>au then qb=qb-(c1-au)*aC*kM elseif c1<0 and c1<au*-1 then qb=qb-(c1+au)*aC*kM else qb=0 end;if c2>0 and c2>au then qa=qa-(c2-au)*aD*kN elseif c2<0 and c2<au*-1 then qa=qa-(c2+au)*aD*kN else qa=0 end else c1=0;c2=0;if g=="mouse"then qa=(-utils.smoothstep(qW,-100,100)+0.5)*2*qQ;qb=(-utils.smoothstep(qV,-100,100)+0.5)*2*qR end end end end;local qZ=cF>8334;if cF>V/3.6 and not c8 and not b0 and not qZ then bW="Space Speed Engine Shutoff reached"cn.cmdThrottle(0)end;if not qZ and q_ then if not aY then cn.BrakeToggle()end;if b0 then cn.ToggleAutopilot()end end;q_=qZ;if c8 and c9>0.09 then if cF>cv/3.6 and not t and not pT then aY="SpdLmt"pT=true elseif not t and pT then if cF<cv/3.6 then aY=false;pT=false end end end;if a_ then if c4 then aY=false;local r0=false;if fX and c4==true then r0=qF(fX.position-cI,0.1)else r0=qF(vec3(cE),0.01)end;ct=true;if r0 then cn.cmdCruise(bH(cv))if(eP(cN)<2 or eP(cM)>85)and cF>=cv/3.6-1 then aY=false;a_=false;if c4~=2 then q9=true end;if c4==true then c6=true end;c4=false;b0=false;cn.BeginReentry()end elseif c8 and t then cn.cmdThrottle(1)end elseif cF>iI then qF(vec3(cE),0.01)end end;if aZ then if c8 then aZ=false elseif cF>iI then qF(-vec3(cE))end end;if not a_ and c4 and not bw then if c9==0 then if c4~=2 then q9=true end;cn.BeginReentry()c4=false;c6=true else c4=false;cn.ToggleAutopilot()end end;if c6 and fX and(ca<b7+250 and ca>b7-250)and cF*3.6>cv-250 and eP(cH)<25 and c9>=0.1 and(fX.position-cI):len()>2000+ca then cn.ToggleAutopilot()c6=false end;if b6 then ct=true;local r1=b7;if cH<-30 then bW="Unable to achieve lift. Safety Landing."bT=0;ct=p;b6=false;b3=true elseif not q and cK or b7<j4.spaceEngineMinAltitude then if cK then r1=antigrav.getBaseAltitude()end;if ca<r1-100 then qe=0;bT=15;aY=false elseif cH>0 then aY="VTO Limit"bT=0 elseif cH<-30 then aY="VTO Fall"bT=15 elseif ca>=r1 then if cK then if b0 or bn then cn.ToggleVerticalTakeoff()else aY="VTO Complete"b6=false end;bW="Takeoff complete. Singularity engaged"fL("aggLk","AG")else aY=false;bW="VTO complete. Engaging Horizontal Flight"fL("vtoc","VT")cn.ToggleVerticalTakeoff()end;bT=0 end else if c9>0.08 then qe=0;aY=false;bT=20 elseif c9<0.08 and c9>0 then aY=false;if cz then qe=0;bT=20 else bT=0;qe=36;cn.cmdCruise(3500)end else ct=p;bw=true;cy=false;r2=false;q1=false;p_=nil;q0=nil;if q4==nil then q4=j4 end;cx=r1;q3=true;b6=false end end;if qe~=nil then if r3==nil then r3=pid.new(2*0.01,0,2*0.1)end;local r4=da(qe-cM,-M*0.80,M*0.80)r3:inject(r4)local r5=da(r3:get(),-1,1)qa=r5 end end;if bw then local qM;local r6=false;local r7=it(cx)if q4==nil then q4=j4;if bn then q4=c0 end end;if not q3 then cx=bH(q4.radius+q4.surfaceMaxAltitude+T)if q4.hasAtmosphere then cx=bH(q4.radius+q4.noAtmosphericDensityAltitude+T)end;q3=true end;if qf.VectorToTarget and fX then qM=fX.position-cI end;local r8,r9=ck(q4):escapeAndOrbitalSpeed((cI-q4.center):len()-q4.radius)local ra=cN;if not q1 then local rb=false;local rc=false;cn.cmdThrottle(0)q0=0;cw="Aligning to orbital path - OrbitHeight: "..r7;if qf.VectorToTarget then qF(qM:normalize():project_on_plane(cG))r6=cB:dot(qM:project_on_plane(qg):normalize())>0.95 else qF(cE)r6=qT<0.5;if cF<150 then r6=true end end;qa=0;p_=0;if cM<=p_+2 and cM>=p_-2 then rb=true else rb=false end;if ra<=q0+2 and ra>=q0-2 then rc=true else rc=false end;if rb and rc and r6 then p_=nil;q0=nil;q1=true end else if qf.VectorToTarget then qF(qM:normalize():project_on_plane(cG))elseif cF>150 then qF(cE)end;qa=0;if qf.VectorToTarget and fX then local bZ,dF=cj.computeDistanceAndTime(cF,cv/3.6,cb,0,0,bp)if cy and qM:len()>15000+bZ+ca then cw="Orbiting to Target"if ca-100<=q4.noAtmosphericDensityAltitude or lE>fk.timeToPeriapsis and fk.periapsis.altitude<q4.noAtmosphericDensityAltitude then cy=false end elseif cy or qM:len()<15000+bZ+ca then bW="Orbit complete, proceeding with reentry"fL("orCom","OB")bh=fX.position;q9=true;c6=true;qf.VectorToTarget,qf.AutopilotAlign=false,false;cn.ToggleIntoOrbit()cn.BeginReentry()return end end;if fk.periapsis~=nil and fk.apoapsis~=nil and fk.eccentricity<1 and ca>cx*0.9 and ca<cx*1.4 then if fk.apoapsis~=nil then if fk.periapsis.altitude>=cx*0.99 and fk.apoapsis.altitude>=cx*0.99 and fk.periapsis.altitude<fk.apoapsis.altitude and fk.periapsis.altitude*1.05>=fk.apoapsis.altitude or cy then if cy then aY=false;cn.cmdThrottle(0)p_=0;if not qf.VectorToTarget then bW="Orbit complete"fL("orCom","OB")cn.ToggleIntoOrbit()end else q5=q5+1;if q5>=2 then cy=true end end else cw="Adjusting Orbit - OrbitHeight: "..r7;q2=true;cn.cmdCruise(r9*3.6+1)local rd=cx-ca;if re==nil then re=pid.new(0.1,0,1*0.1)end;re:inject(rd-cH*da(utils.smoothstep(2000-rd,-2000,2000)^6*10,1,10))p_=da(re:get(),-60,60)end end else local rf=2.75;local rg=eP(fM(r8*rf))local oC=rg%50;if oC>0 then rg=rg-oC+50 end;aY=false;if ca<cx*0.8 then cw="Escaping planet gravity - OrbitHeight: "..r7;p_=utils.map(cH,200,0,-15,80)elseif ca>=cx*0.8 and ca<cx*1.15 then cw="Approaching orbital corridor - OrbitHeight: "..r7;rg=rg*0.75;p_=utils.map(cH,100,-100,-15,65)elseif ca>=cx*1.15 and ca<cx*1.5 then cw="Approaching orbital corridor - OrbitHeight: "..r7;rg=rg*0.75;if cH<0 or q2 then p_=utils.map(ca,cx*1.5,cx*1.01,-30,0)else p_=utils.map(ca,cx*0.99,cx*1.5,0,30)end elseif ca>cx*1.5 then cw="Reentering orbital corridor - OrbitHeight: "..r7;p_=-65;local rh=utils.map(cH,-150,-400,1,0.55)rg=rg*rh end;cn.cmdCruise(bH(rg))end end;if p_~=nil then if ri==nil then ri=pid.new(1*0.01,0,5*0.1)end;local rj=p_-cM;ri:inject(rj)local rk=da(ri:get(),-0.5,0.5)qa=rk end end;if b0 and c9==0 and not c4 then local function rl(i1,fk)a.print(i1)aY=false;ba=false;b0=false;rm=false;bd="Aligning"cn.cmdThrottle(0)q8=false;bW=i1;fL("apCom","AP")if fk or c4 then if fk and gg~=nil and not c4 then if not ca or ca==0 then return end;cx=ca;q3=true end;cn.ToggleIntoOrbit()end end;local rn,ro=bh,false;if fX and fX.planetname~="Space"then b9=true;if not rm then local rp=(fX.position-c0.center):normalize()local rq=rp:project_on_plane((c0.center-cI):normalize()):normalize()local rr=c0.center+rq*(c0.radius+gg)local rs=fX.position+(fX.position-c0.center):normalize()*(gg-c0:getAltitude(fX.position))if(cI-rr):len()<(cI-rs):len()then rn=rr else rn=rs;bc=0 end;bh=rn;cn.showWayPoint(c0,bh)ro=true;rm=true end;be=0 elseif fX and fX.planetname=="Space"then if not rm then be=0;ro=true;b9=true;rm=true;rn=fX.position+(cI-fX.position):normalize()*R;bh=rn end elseif fX==nil then be=0;if not rm then local rp=(cI+cE*100000-c0.center):normalize()local rq=rp:project_on_plane((c0.center-cI):normalize()):normalize()if rq:len()<1 then rp=(cI+cB*100000-c0.center):normalize()rq=rp:project_on_plane((c0.center-cI):normalize()):normalize()end;rn=c0.center+rq*(c0.radius+gg)bh=rn;rm=true;ro=true;b9=true;cn.showWayPoint(c0,bh)end end;pl=(vec3(rn)-cI):len()local lC,ez,eA=ci:getPlanetarySystem(0):castIntersections(cI,cE:normalize(),function(ei)if ei.noAtmosphericDensityAltitude>0 then return ei.radius+ei.noAtmosphericDensityAltitude else return ei.radius+ei.surfaceMaxAltitude*1.5 end end)local lD=ez;if eA~=nil and ez~=nil then lD=math.min(eA,ez)end;if lD~=nil and lD<pl and lC.name==c0.name then pl=lD end;local r0=true;local rt=(c0.center-(cI+vec3(cE):normalize()*pl)):len()-c0.radius;local lp=it(rt)fJ(g8,'{"label": "Projected Altitude", "value": "'..lp..'"}')local bZ,b_;if not b1 then bZ,b_=pQ(cF)else bZ,b_=pS(cF)end;if cF>50 and b8 then local qM=vec3(rn)-cI;local ru=da(math.deg(qj(qg,cE:normalize(),qM:normalize()))*cF/500,-90,90)local rv=da(math.deg(qj(cC,cE:normalize(),qM:normalize()))*cF/500,-90,90)if eP(ru)<20 and eP(rv)<20 then ru=ru*2;rv=rv*2 end;if eP(ru)<2 and eP(rv)<2 then ru=ru*2;rv=rv*2 end;local qT=-math.deg(qj(qg,cB,cE:normalize()))local qU=-math.deg(qj(cC,cB,cE:normalize()))if rw==nil then rw=pid.new(2*0.01,0,2*0.1)end;rw:inject(rv-qU)local rx=da(rw:get(),-1,1)qa=qa+rx;if ry==nil then ry=pid.new(2*0.01,0,2*0.1)end;ry:inject(ru-qT)local rz=da(ry:get(),-1,1)qb=qb+rz;ro=true;if eP(ru)>2 or eP(rv)>2 then if bd~="Adjusting Trajectory"then bd="Adjusting Trajectory"fL("apAdj","AP")end else if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end end elseif b8 and cF<=50 then qF((rn-cI):normalize())end;if rt<gg*1.5 then if fX and fX.planetname=="Space"then bc=0 elseif fX==nil then dF,bc=ck(c0):escapeAndOrbitalSpeed(rt)end end;if b0 and not b8 and not bb and not ba then local lC,lD=cn.checkLOS((bh-cI):normalize())if c0.name~=j4.name then if lC~=nil and c0.name~=lC.name and lD<pl then bW="Collision with "..lC.name.." in "..it(lD).."\nClear LOS to continue."bX=5;qy=true else qy=false;bW=""end end end;if not qy then if not bb and not ba and not ro then r0=qF((rn-cI):normalize())elseif b1 and(ba or bb)then r0=qF(-vec3(cE):normalize())end end;if b8 then if not q8 then aY=false;cn.cmdThrottle(a0)bK=fM(a0,2)q8=true end;local pm=c.getThrottle()if t then pm=bK end;local rA=99999;local oA=-vec3(b.getWorldAcceleration()):dot(cE:normalize())local rB=da(cE:dot((rn-cI):normalize()),0,cF)if rB>0 or oA>0 then rA=cj.computeTravelTime(rB,oA,pl-bZ)end;if cD:len()>=_ or pm==0 and q8 or a1/4>rA then b8=false;if bd~="Cruising"then fL("apCru","AP")bd="Cruising"end;bb=true;cn.cmdThrottle(0)end;local rC=pl;if rC<=bZ or H and cQ<=bZ+10000 and cP then if H and cQ<=bZ+10000 and cP then if cQ<pU and cQ>2000 then cn.ToggleAutopilot()bW="Autopilot cancelled to prevent crossing PvP Line"aY="PvP Prevent"pU=cQ else pU=cQ;return end end;b8=false;if bd~="Braking"then fL("apBrk","AP")bd="Braking"end;ba=true;cn.cmdThrottle(0)q8=false end elseif ba then if bd~="Orbiting to Target"then aY="AP Brk"end;if b1 then cn.cmdThrottle(1,true)end;local dF,r9=ck(c0):escapeAndOrbitalSpeed((cI-j4.center):len()-j4.radius)local qM;if fX then qM=fX.position-cI end;if fX and fX.planetname=="Space"and cF<50 then if#bC>0 then table.remove(bC,1)if#bC>0 then aY=false;cn.ToggleAutopilot()cn.ToggleAutopilot()return end end;rl("Autopilot complete, arrived at space location")aY="Space Arrival"elseif fX and fX.planetname~="Space"and cF<=r9 and(fk.apoapsis==nil or fk.periapsis==nil or fk.apoapsis.altitude<=0 or fk.periapsis.altitude<=0)then rl("Autopilot complete, commencing reentry")bh=fX.position;c4=true;cn.showWayPoint(c0,bh)elseif(fX and fX.planetname~="Space"or fX==nil)and fk.periapsis~=nil and fk.periapsis.altitude>0 and fk.eccentricity<1 or bd=="Circularizing"then if bd~="Circularizing"then fL("apCir","AP")bd="Circularizing"end;if cF<=r9 then if fX then if cE:normalize():dot(qM:normalize())>0.4 then if bd~="Orbiting to Target"then fL("apOrb","OB")bd="Orbiting to Target"end;if not rD then aY=false;cn.showWayPoint(c0,fX.position)rD=true end else rl("Autopilot complete, proceeding with reentry")bh=fX.position;c4=true;cn.showWayPoint(c0,fX.position)rD=false end else rl("Autopilot completed, setting orbit",true)aY=false end end elseif bd=="Circularizing"then rl("Autopilot complete, fixing Orbit",true)end elseif bb then local rC=pl;if rC<=bZ or H and cQ<=bZ+10000 and cP then if H and cQ<=bZ+10000 and cP then if cQ<pU and cQ>2000 then cn.ToggleAutopilot()bW="Autopilot cancelled to prevent crossing PvP Line"aY="Prevent PvP"pU=cQ else pU=cQ;return end end;b8=false;if bd~="Braking"then fL("apBrk","AP")bd="Braking"end;ba=true end;local pm=c.getThrottle()if t then pm=bK end;if pm>0 then b8=true;if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end;bb=false end else if r0 then if not b9 and fX==nil or not b9 and fX and fX.planetname~="Space"then if not c4 then bh=vec3(c0.center)+(gg+c0.radius)*cC;rE=qg;rF=cC end;b9=true elseif r0 and not qy then b8=true;if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end;if not q8 then cn.cmdThrottle(a0,true)bK=fM(a0,2)q8=true;aY=false end end end end elseif b0 and(fX~=nil and fX.planetname~="Space"and c9>0)then bW="Autopilot complete, starting reentry"fL("apCom","AP")bh=fX.position;aY=false;ba=false;b0=false;rm=false;bd="Aligning"cn.cmdThrottle(0)q8=false;a_=true;c4=true;cn.showWayPoint(c0,fX.position)end;if bU then ct=true;local rv=0;local fm=cI+vec3(c.getMasterPlayerRelativePosition())local rG=fm-cI;local rH=vec3(rG):project_on(cB):len()local rI=vec3(rG):project_on(cC):len()local c3=dc(rH*rH+rI*rI)qF(rG:normalize())local mJ=40;local rJ=c3<mJ;local rK=100;local rL=da((c3-mJ)/2,10,rK)qa=0;local r0=eP(qb)<0.1;if r0 and cF<rL and not rJ then aY=false;rv=-20 else aY="Follow"rv=0 end;local rM=0;if eP(rv-cM)>rM then if rN==nil then rN=pid.new(2*0.01,0,2*0.1)end;rN:inject(rv-cM)local rx=rN:get()qa=rx end end;if b2 or b3 or b5 or bn or bq~=nil then local rO=br;if rO then rO=rO*da(cF/100,0.1,1)*c9 else rO=bp end;if c9<0.01 then rO=bp end;local rP=cB:project_on_plane(cG):normalize():dot(cE)local rQ=vec3(b.getWorldAirFrictionAcceleration())local rR=rQ:len()*cb;if rP>100 then bZ,b_=cj.computeDistanceAndTime(rP,100,cb,0,0,rO)local rS,rT=cj.computeDistanceAndTime(100,0,cb,0,0,rO*0.55)bZ=bZ+rS else bZ,b_=cj.computeDistanceAndTime(rP,0,cb,0,0,rO*0.55)end;if not q and cK and not b5 and b7<antigrav.getBaseAltitude()then b7=antigrav.getBaseAltitude()end;local rd=b7-ca-cH;local rU=200+cF;if b5 or c4 then rV=2000+cF end;local rW=1;if b4 then rW=da(cF/100,0.1,1)end;local rv=(utils.smoothstep(rd,-rU,rU)-0.5)*2*O*rW;if not b5 and not c4 and not bn and cB:dot(cE:normalize())<0.99 then rv=(utils.smoothstep(rd,-rU*da(20-19*c9*10,1,20),rU*da(20-19*c9*10,1,20))-0.5)*2*O*da(2-c9*10,1,2)*rW end;if not b2 then rv=0 end;if bq~=nil then if cS and not bw then rv=bq else bq=nil end end;ct=true;local rX=qa;if b5 then local rY=bH(cv)local rZ,r_=cj.computeDistanceAndTime(cF,rY/3.6,cb,0,0,bp-j4.gravity*9.8*cb)rZ=rZ==-1 and 5000 or rZ;local s0=ca-(j4.noAtmosphericDensityAltitude+rZ)local s1=ca>j4.noAtmosphericDensityAltitude+rZ*1.35;if s1 then rv=P;if cF<=rY/3.6 and cF>rY/3.6-10 and eP(cE:normalize():dot(cB))>0.9 and not cL then bO=false;cn.cmdThrottle(1)end elseif(cL or ip:getTargetSpeed(axisCommandId.longitudinal)~=rY)and not s1 and not c8 then cn.cmdCruise(rY,true)end;if cL then if cF>rY/3.6 and not s1 then aY="Reentry Limit"else aY=false end else aY=false end;if cH>0 then aY="Reentry vSpd"end;if not q9 then rv=-80;if ca<j4.surfaceMaxAltitude+(j4.atmosphereThickness-j4.surfaceMaxAltitude)*0.25 then bW="PARACHUTE DEPLOYED at "..fM(ca,0)b5=false;b3=true;lx=true;cn.cmdThrottle(0)rv=0;ct=p end elseif j4.noAtmosphericDensityAltitude>0 and s1 then ct=true elseif not s1 then if not c8 and(cL or ip:getTargetSpeed(axisCommandId.longitudinal)~=rY)then cn.cmdCruise(rY)end;if cF<rY/3.6+1 then aY=false;q9=false;b5=false;ct=true end end end;if cF>iI and not c5 and not bn and not b3 and u then qF(vec3(cE))end;if cR or(bn or c5)and bi>0 and c9>0.01 then local qM;if cR then if type(cR)=="table"then qM=cR elseif cR<3 and cR>0 then qM=-cG:cross(cE)*5000 elseif cR>=3 then qM=cG:cross(cE)*5000 elseif cR<0 then qM=cE*25000 end elseif fX~=nil then qM=fX.position-cI else qM=c0.center-cI end;local ru=math.deg(qj(cG:normalize(),cE,qM))*2;local mM=math.rad(eP(cN))if cF>aH and c9>0.01 then local s2=1000+cF;local s3=(utils.smoothstep(rd-cH*10,-s2,s2)-0.5)*2*O;local s4=da(90-s3,0,180)qd=da(ru*2,-s4,s4)local s5=ru;ru=da(da(ru,-L*0.80,L*0.80)*math.cos(mM)+4*(cM-rv)*math.sin(math.rad(cN)),-L*0.80,L*0.80)local s6=1;if qd~=0 then s6=eP(mM/qd)end;s6=(90-da(eP(qd-cN),0,90))/90;local s7=rv;if eP(cN)>90 then s7=-s7 end;rv=s6*da(da(s7*math.cos(mM),-M*0.8,M*0.8)+eP(da(eP(s5)*math.sin(mM),-M*0.80,M*0.80)),-M*0.80,M*0.80)else qd=0;ru=da(ru,-L*0.80,L*0.80)end;local s8=qT-ru;if cR and eP(s8)<=0.0001 and(type(cR)=="table"or type(cR)~="table"and cR<0 and eP(cN)<1)then if cR==-2 then cn.ToggleAltitudeHold()end;cR=nil;fL("180Off","BR")return end;if not cu and cF>aH and c9>0.01 then if s9==nil then s9=pid.new(2*0.01,0,2*0.1)end;s9:inject(s8)local rz=da(s9:get(),-1,1)qb=qb+rz elseif c8 and c7>-1 or cF<aH then qF(qM)elseif cu and c9>0.01 then if(qT<-L or qT>L)and c9>0.01 then qF(cE)end;if(qU<-M or qU>M)and c9>0.01 then rv=da(cM-qU,cM-M*0.80,cM+M*0.80)end end;if fX~=nil and not c5 then local r1=j4:getAltitude(fX.position)local s0=qM:project_on_plane(cG):len()lx=true;if not c5 and not b5 and s0<=bZ and(cE:project_on_plane(cG):normalize():dot(qM:project_on_plane(cG):normalize())>0.99 or lG=="Finalizing Approach")then lG="Finalizing Approach"if#bC>0 then table.remove(bC,1)if#bC>0 then cn.ToggleAutopilot()cn.ToggleAutopilot()return end end;cn.cmdThrottle(0)if b2 then cn.ToggleAltitudeHold()bn=true end;aY="AP Finalizing"elseif not b4 then aY=false end;if lG=="Finalizing Approach"and(rP<0.1 or s0<0.1 or sa~=nil and sa<s0)then fL("bklOn","BL")b3=true;d5=true;if fX.heading then d6=fX.heading else d6=nil end;bn=false;lG="Proceeding to Waypoint"cT=false end;sa=s0 end elseif bn and c9==0 and b7>j4.noAtmosphericDensityAltitude and not(c5 or b5)then if fX~=nil and c0.name==j4.name then local qM=fX.position-cI;local r1=j4:getAltitude(fX.position)local s0=dc(qM:len()^2-(ca-r1)^2)local rO=br;if rO then bZ,b_=cj.computeDistanceAndTime(cF,0,cb,0,0,rO/2)lx=true;if s0<=bZ+cF*qS/2 and cE:project_on_plane(cG):normalize():dot(qM:project_on_plane(cG):normalize())>0.99 then if j4.hasAtmosphere then aY=false;a_=false;q9=true;c4=false;c6=true;b0=false;cn.BeginReentry()end end;sa=s0 end end end;if c9==0 and(b2 and b7>j4.noAtmosphericDensityAltitude)and not(c5 or bw or b5)then if not cy and not bw then cx=b7;q3=true;if bn then qf.VectorToTarget=true end;cn.ToggleIntoOrbit()bn=false;q1=true end end;if cu and c9>0.01 and c7==-1 and cF>aH and lG~="Finalizing Approach"then qF(cE)rv=da(cM-qU,cM-M*0.80,cM+M*0.80)end;qa=rX;local qs=-1;if b3 then if not qz then if not cL then cn.cmdThrottle(0)end;ip:setTargetGroundAltitude(500)ip:activateGroundEngineAltitudeStabilization(500)by=true;qz=true end;rv=0;local sb=false;local sc=math.abs(rP)if not q and cK then sb=antigrav.getBaseAltitude()if sb<j4.surfaceMaxAltitude and fX==nil or fX~=nil and j4:getAltitude(fX.position)>sb then sb=false end end;if d6 then if sc<0.05 then if cH>-N then aY=false else aY="BL Align BLR"end;if qF(d6,0.001)then d6=nil;ct=p else qa=0;ct=true end else aY="BL Align Hzn"end else local sd=false;local se=30;if sc<10 and qY~=nil and qY>0 then local sf=da(c9,0.4,2)local rO=br*da(cF/100,0.1,1)*sf;local sg=qY*sf+rO-on;local sh=rO/2-on;local si=cF-dc(eP(sh/2)*20/(0.5*cb))*utils.sign(sh)if si<0 then si=0 end;local sj;if cF>100 then local sk,dF=cj.computeDistanceAndTime(cF,100,cb,0,0,rO)local sl,dF=cj.computeDistanceAndTime(100,0,cb,0,0,dc(rO))sj=sk+sl else sj=cj.computeDistanceAndTime(cF,0,cb,0,0,dc(rO))end;if sj<20 then aY=false else local sm=0;if si>100 then local sn,dF=cj.computeDistanceAndTime(si,100,cb,0,0,sg)local so,dF=cj.computeDistanceAndTime(100,0,cb,0,0,qY*sf+dc(rO)-on)sm=sn+so else sm,dF=cj.computeDistanceAndTime(si,0,cb,0,0,qY*sf+dc(rO)-on)end;sm=(sm+15+cF*qS)*1.1;local sp=d5 and fX~=nil and j4:getAltitude(fX.position)>0 and fX.safe;local r1=nil;if sb and sb<ca then r1=sb elseif sp then r1=j4:getAltitude(fX.position)+250 elseif ca>j4.surfaceMaxAltitude then r1=j4.surfaceMaxAltitude end;if cU then local sq=j4:getAltitude(cU[1].center)if r1 then if sq>r1 then r1=sq end else r1=sq end end;if r1~=nil then local sr=ca-r1;sd=true;if sr<=sm or sm==-1 or sc>0.05 and d5 then if sc>0.05 and d5 then aY="BL AP Hzn"else aY="BL Stop Dist"end else aY=false end end end end;qs=c7;if qs==-1 and sb and eP(ca-sb)<100 then if not d6 then b3=false;ct=p;d5=false end;aY="BL AGG Comp"elseif qs>-1 then if(cF<1 or cE:normalize():dot(cG)<0)and not d6 then b3=false;b2=false;bj=true;if bP then d.control.extendLandingGears()fL("grOut","LG",1)end;ip:setTargetGroundAltitude(Y)bT=0;aY="BL Complete"ct=p;d5=false else aY="BL Slowing"end elseif not sd then if lx and cE:normalize():dot(-gi)<0.999 then aY="BL Strong"qF()elseif sc>10 or sc>0.05 and d5 then aY="BL hSpd"elseif cH<-N then aY="BL BLR"else aY=false end end end else qz=false end;if b4 or c5 then local lC,eA,ez;if bh~=nil then lC,eA,ez=ci:getPlanetarySystem(0):castIntersections(cI,(bh-cI):normalize(),function(ei)return ei.radius+ei.noAtmosphericDensityAltitude end)end;if cK and not c5 then if ca>=b7-50 then b4=false;if not b0 and not bn then aY="ATO Agg Arrive"cn.cmdThrottle(0)end end elseif eP(rv)<15 and ca/b7>0.75 then b4=false;if not c5 then if cL and not t then d.control.cancelCurrentControlMasterMode()end elseif c5 and cF<iI then b0=true;c5=false;b2=false;b4=false;cn.cmdThrottle(0)elseif c5 then cn.cmdThrottle(0)aY="ATO Space"end elseif c5 and c9==0 and c0~=nil and(lC==nil or lC.name==c0.name)then b0=true;c5=false;b2=false;b4=false;if not cL then cn.cmdThrottle(0)end;b8=true end end;local ss=c7>-1;local st=cM;if(bn or c5 or cR)and not ss and cF>aH and c9>0.01 then local mM=math.rad(eP(cN))st=cM*eP(math.cos(mM))+qU*math.sin(mM)end;local su=da(rv-st,-M*0.80,M*0.80)if c9<0.01 and bn then su=da(rv-st,-85,O)elseif c9<0.01 then su=da(rv-st,-O,O)end;if eP(cN)<5 or bn or cR or b3 or ss or b2 then if rN==nil then rN=pid.new(5*0.01,0,5*0.1)end;rN:inject(su)local rx=rN:get()qa=qa+rx end end;if antigrav~=nil and(antigrav and not q and ca<200000)then if bs==nil or bs<1000 then bs=1000 end;if sv~=bs then sv=bs;antigrav.setBaseAltitude(sv)end end end;function pP.ToggleIntoOrbit()cy=false;p_=nil;q0=nil;q5=0;if c9==0 then if bw then fL("orOff","AP")bw=false;q1=false;q4=nil;ct=p;if b2 then b2=false;b4=false end;qf.VectorToTarget=false;qf.AutopilotAlign=false;q3=false elseif cS then fL("orOn","AP")bw=true;ct=true;if q4==nil then q4=j4 end;if b2 then b2=false;b4=false end else bW="Unable to engage auto-orbit, not near a planet"end else bw=false;q1=false;q4=nil;ct=p;if b2 then b2=false end;qf.VectorToTarget=false;qf.AutopilotAlign=false;q3=false end end;function pP.ToggleVerticalTakeoff()b2=false;if b6 then lx=true;b5=false;b4=false;b3=true;ct=true;bT=0;if c8 and c7==-1 then b3=false;b2=true;bT=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cn.cmdCruise(bH(cv))end else cy=false;bj=false;d.control.retractLandingGears()ip:setTargetGroundAltitude(X)aY="VTO Takeoff"end;b6=not b6 end;function pP.checkLOS(qG)local lC,ez,eA=ci:getPlanetarySystem(0):castIntersections(cI,qG,function(ei)if ei.noAtmosphericDensityAltitude>0 then return ei.radius+ei.noAtmosphericDensityAltitude else return ei.radius+ei.surfaceMaxAltitude*1.5 end end)local lD=ez;if eA~=nil and ez~=nil then lD=math.min(eA,ez)end;if lD~=nil then return lC,lD else return nil,nil end end;function pP.ToggleAutopilot()local function sw(bu)cT=false;bn=not bn;if bn then b1=false;if not b2 and not bu then cn.ToggleAltitudeHold()end end;lG="Proceeding to Waypoint"end;local function sx(gp)if gp then for K,dA in pairs(cO)do if dA.name and dA.name==gp then return K end end else return 0 end end;local sy=false;if bJ-pZ<1.5 and c9>0 then if not cA then bW="No space engines detected, Orbital Hop not supported"return end;if j4.hasAtmosphere then if c9>0 then b7=j4.noAtmosphericDensityAltitude+T;fL("orH","OH")end;pZ=-1;if b0 or bn or bw then return end end else pZ=bJ end;rm=false;if(bi>0 or#bC>0)and not b0 and not bn and not c5 and not bw then if 0.5*d:maxForceForward()/b.g()<cb then bW="WARNING: Heavy Loads may affect autopilot performance."bX=5 end;if#bC>0 and not c6 then bi=sx(bC[1])cm.UpdateAutopilotTarget()bW="Route Autopilot in Progress"local qM=fX.position-cI;local s0=qM:project_on_plane(cG):len()if s0>50000 and fX.planetname==j4.name then sy=true end end;cm.UpdateAutopilotTarget()cn.showWayPoint(c0,bh)if fX~=nil then if fX.agg and not q and antigrav then if not cK then cn.ToggleAntigrav()end;bs=fX.agg end;bq=nil;bu=fX.planetname=="Space"if bu then fL("apSpc","AP")if c9~=0 then c5=true;cn.ToggleAltitudeHold()else b0=true end elseif j4.name==fX.planetname then lx=true;if c9>0 then if not bn then fL("vtt","AP")sw(bu)if sy then b7=j4.noAtmosphericDensityAltitude+T end end else fL("apOn","AP")if not(c0.name==j4.name and ca<gg*1.5)then cy=false;b0=true elseif not c8 then if bw then cn.ToggleIntoOrbit()end;cx=j4.noAtmosphericDensityAltitude+T;q3=true;qf.AutopilotAlign=true;qf.VectorToTarget=true;q1=false;if not bw then cn.ToggleIntoOrbit()end end end else fL("apP","AP")aZ=false;a_=false;if c9~=0 then c5=true;cn.ToggleAltitudeHold()else b0=true end end elseif c9==0 then if fX==nil and(c0.name==j4.name and cS)and not bw then rD=false;cy=false;q1=false;cn.ToggleIntoOrbit()else fL("apP","AP")b0=true;aZ=false;a_=false;b9=false;bU=false;b2=false;b3=false;b5=false;b4=false;q8=false;bq=nil;rD=false end else fL("apP","AP")c5=true;cn.ToggleAltitudeHold()end else fL("apOff","AP")cn.ResetAutopilots(1)end end;function pP.routeWP(sz,sA,sB)if sB then if sB==1 then bC={}bC=ir(bC,bB)if#bC>0 then bW="Route Loaded"else bW="No Saved Route found on Databank"end;return bC else bB={}bB=ir(bB,bC)bW="Route Saved"pO()return end end;if sz then return bC end;if sA then bC={}bW="Current Route Cleared"else bC[#bC+1]=fX.name;bW="Added "..fX.name.." to route. "end;return bC end;function pP.cmdThrottle(dB,sC)if ip:getAxisCommandType(0)~=axisCommandType.byThrottle and not sC then d.control.cancelCurrentControlMasterMode()end;ip:setThrottleCommand(axisCommandId.longitudinal,dB)bK=da(fM(dB*100,0)/100,-1,1)qh=nil end;function pP.cmdCruise(dB,sC)if ip:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not sC then d.control.cancelCurrentControlMasterMode()end;ip:setTargetSpeedCommand(axisCommandId.longitudinal,dB)qh=dB end;function pP.ToggleLockPitch()if bq==nil then fL("lkPOn","LP")if not bV then bq=cM else bq=Q end;b4=false;b2=false;b3=false else fL("lkPOff","LP")bq=nil end end;function pP.ToggleAltitudeHold()if bJ-pY<1.5 then if j4.hasAtmosphere then if c9>0 then b7=j4.spaceEngineMinAltitude-0.01*j4.noAtmosphericDensityAltitude;fL("11","EP")else if cS then b7=j4.noAtmosphericDensityAltitude+T;cx=b7;q3=true;if not bw then cn.ToggleIntoOrbit()end;q1=true end end;pY=-1;if b2 or bw or b6 then return end end else pY=bJ end;if cS and c9==0 then cx=ca;q3=true;q1=true;cn.ToggleIntoOrbit()if bw then pY=bJ else pY=0 end;return end;b2=not b2;b3=false;b5=false;if b2 then b0=false;a_=false;aZ=false;bU=false;ct=true;bq=nil;cy=false;if c7~=-1 and cF<20 then fL("lfs","LS")b4=true;if pY>-1 then b7=ca+W end;bj=false;d.control.retractLandingGears()aY="ATO Hold"ip:setTargetGroundAltitude(X)if aX and cJ then cn.ToggleVerticalTakeoff()end else fL("altOn","AH")b4=false;if pY>-1 then if cS then b7=ca end end;if b6 then cn.ToggleVerticalTakeoff()end end;if cK and not q then local sD=antigrav.getBaseAltitude()if fX.agg and fX.agg>ca then b7=fX.agg else b7=sD end;if eP(ca-sD)<50 then aY="AGG Hold"end end;if c5 then b7=200000 end else fL("altOff","AH")if bw then cn.ToggleIntoOrbit()end;if b6 then cn.ToggleVerticalTakeoff()end;ct=p;b4=false;bn=false;pY=0 end end;function pP.ResetAutopilots(pP)if pP then c5=false;b0=false;b9=false;q8=false;b7=ca;rm=false;d5=false end;bn=false;b4=false;b5=false;a_=false;b3=false;d6=nil;sE=false;cR=nil;d5=false;if not cK then b2=false;bq=nil end;if b6 then cn.ToggleVerticalTakeoff()end;if bw then cn.ToggleIntoOrbit()end;ct=p;c4=false;c6=false;bT=0 end;function pP.BrakeToggle(sF)if not aY then if sF then aY=sF else aY=true end else aY=false end;if b3 then b3=false;ct=p;d5=false end;if aY then fL("bkOn","B",1)cn.ResetAutopilots()else fL("bkOff","B",1)end end;function pP.BeginReentry()if b5 then bW="Re-Entry cancelled"fL("reOff","RE")b5=false;ct=p;b2=false elseif not j4.hasAtmosphere then bW="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bX=5 elseif not q9 then b5=true;if ip:getAxisCommandType(0)~=sG.cruise then d.control.cancelCurrentControlMasterMode()end;ct=true;aY=false;bW="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cv;fL("par","RE")else b5=true;b2=true;ct=true;aY=false;b7=j4.surfaceMaxAltitude+Z;if b7>j4.spaceEngineMinAltitude then b7=j4.spaceEngineMinAltitude-0.01*j4.noAtmosphericDensityAltitude end;local sH=it(b7)bW="Beginning Re-entry.  Target speed: "..cv.." Target Altitude: "..sH;fL("glide","RE")cn.cmdCruise(bH(cv))end;b4=false end;function pP.ToggleAntigrav()if antigrav and not q then if cK then fL("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bs==nil then bs=ca end;if bs<1000 then bs=1000 end;fL("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pP.changeSpd(sI)local sJ=1;if sI then sJ=-1 end;if not bV then if t and not p8 and q7 then local sK=bK;bK=fM(da(bK+sJ*aA/100,-1,1),2)if bK>=0 and sK<0 then bK=0;q7=false end elseif p8 then if c9>0 or b5 then cv=da(cv+sJ*aA,0,U)elseif b0 then _=da(_+sJ*aA/3.6*100,0,8333.00)end else ip:updateCommandFromActionStart(axisCommandId.longitudinal,sJ*aA/10)end else if b0 or bn or c5 or bw then cW=cW+1*sJ*-1;if cW>#cO then cW=1 end;if cW<1 then cW=#cO end else if not sI then sJ=1 else sJ=nil end;cm.adjustAutopilotTargetIndex(sJ)end end end;function pP.TenthTick()local function sL(on,sM)if on==nil then on=b.g()end;on=fM(on,5)if sM~=nil and sM or(q6==nil or q6~=on)then local fg=cD:len()local sN=il(c.getData()).maxBrake;if sN~=nil and sN>0 and c8 then sN=sN/da(fg/100,0.1,1)sN=sN/c9;if c9>0.10 then if br then br=(br+sN)/2 else br=sN end end end;if sN~=nil and sN>0 then bp=sN end;q6=on end end;sL(nil,true)if qh~=nil then if ip:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ip:getTargetSpeed(axisCommandId.longitudinal)~=qh then cn.cmdCruise(qh)else qh=nil end end end;function pP.SatNavTick()if not r then return end;qi=dbHud_1.getStringValue("SPBAutopilotTargetName")if qi~=nil and qi~=""and qi~="SatNavNotChanged"then local dv=il(dbHud_1.getStringValue("SavedLocations"))if dv~=nil then bm=dv;local gn=-1;local gt;for dA,dl in pairs(bm)do if dl.name and dl.name=="SatNav Location"then gn=dA;break end end;if gn~=-1 then gt=bm[gn]gn=-1;for dA,dl in pairs(e[0])do if dl.name and dl.name=="SatNav Location"then gn=dA;break end end;if gn>-1 then e[0][gn]=gt end;cm.UpdateAtlasLocationsList()bW=gt.name.." position updated"end end;for K=1,#cO do if cO[K].name==qi then bi=K;a.print("Index = "..bi.." "..cO[K].name)cm.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pP.onFlush()local function sO(sP,rL)local sQ=vec3()local sR=vec3()if sP==axisCommandId.longitudinal then sQ=vec3(b.getConstructOrientationForward())sR=cB elseif sP==axisCommandId.vertical then sQ=vec3(b.getConstructOrientationUp())sR=qg elseif sP==axisCommandId.lateral then sQ=vec3(b.getConstructOrientationRight())sR=cC else return vec3()end;local sS=vec3(b.getWorldGravity())local sT=sS:dot(sR)local sU=vec3(b.getWorldAirFrictionAcceleration())local sV=sU:dot(sR)local sW=cD:dot(sQ)local sX=rL*constants.kph2m;if sY==nil then sY=pid.new(10,0,10.0)end;sY:inject(sX-sW)local sZ=sY:get()local s_=(sZ-sV-sT)*sR;return s_ end;local function t0(sP,rL)local sQ=vec3()local sR=vec3()if sP==axisCommandId.longitudinal then sQ=vec3(b.getConstructOrientationForward())sR=cB elseif sP==axisCommandId.vertical then sQ=vec3(b.getConstructOrientationUp())sR=qg elseif sP==axisCommandId.lateral then sQ=vec3(b.getConstructOrientationRight())sR=cC else return vec3()end;local sS=vec3(b.getWorldGravity())local sT=sS:dot(sR)local sU=vec3(b.getWorldAirFrictionAcceleration())local sV=sU:dot(sR)local sW=cD:dot(sQ)local sX=rL*constants.kph2m;if t1==nil then t1=pid.new(10,0,10.0)end;t1:inject(sX-sW)local sZ=t1:get()local s_=(sZ-sV-sT)*sR;return s_ end;local function t2(t3,jS,fT)local t4=t3:cross(fT):normalize_inplace()local kD=math.acos(da(t4:dot(-jS),-1,1))*constants.rad2deg;if t4:cross(-jS):dot(fT)<0 then kD=-kD end;return kD end;if antigrav and not q then if not cK and antigrav.getBaseAltitude()~=bs then antigrav.setBaseAltitude(bs)end end;cL=ip:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local t5=da(bQ+qa+a.getControlDeviceForwardInput(),-1,1)local t6=da(bR+qc+a.getControlDeviceYawInput(),-1,1)local t7=da(bS+qb-a.getControlDeviceLeftRightInput(),-1,1)local t8=aY and 1 or 0;cG=vec3(b.getWorldVertical())if cG==nil or cG:len()==0 then cG=(j4.center-cI):normalize()end;qg=vec3(b.getConstructWorldOrientationUp())cB=vec3(b.getConstructWorldOrientationForward())cC=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getWorldVelocity())cD=vec3(b.getVelocity())cI=vec3(b.getConstructWorldPos())cb=b.getConstructMass()cF=vec3(cE):len()cH=-cG:dot(cE)cN=getRoll(cG,cB,cC)local t9=cN/180*math.pi;local ta=math.cos(t9)local tb=math.sin(t9)cM=t2(cG,cB,cC*ta+qg*tb)local tc=cE:normalize()local td=eP(cN)local te=utils.sign(cN)local tf=vec3(b.getWorldAngularVelocity())local tg=t5*aK*cC+t6*aF*cB+t7*aL*qg;if ct==true and cG:len()>0.01 then local th=eP(qd-cN)if((a_ or b5 or b3 or c4 or b2 or bw)and th>0 or c9>0.0 and th<aG and p)and t6==0 and eP(cM)<85 then local ti=qd;local tj=aE;if c9==0 then tj=tj/4;qd=0;ti=0 end;if tk==nil then tk=pid.new(tj*0.01,0,tj*0.1)end;tk:inject(ti-cN)local tl=tk:get()tg=tg+tl*cB end end;local tm=1;local tn=0;local to=1;bL=0;if c8 and t and cL then if tp==nil then tp=pid.new(0.1,0,1)end;local tq=0;if aR>0 and not b5 and c9>0.005 and c9<0.1 and cH>-50 then tq=(0.1-c9)*cv*aR end;tp:inject(cv/3.6+tq-cE:dot(cB))local tr=tp:get()bN=da(tr,-1,1)if not d1 then if bN<bK and c9>0.005 then bM=true;d1=da(bN,0.01,1)else bM=false;d1=bK end end;if ts==nil then ts=pid.new(1*0.01,0,1*0.1)end;ts:inject(cE:len()-cv/3.6-tq)local tt=da(ts:get(),0,1)if c9>0 and cH<-80 or c9>0.005 then bL=tt end;if bL>0 then if bM and bN==0.01 and not d1 then d1=0 end else bN=da(bN,0.01,1)end;local tu=''local tv=vec3()local tw=sO(axisCommandId.vertical,bT*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tw,tn)local tx='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then tx=tx..aS end;local ty=ip:getAxisCommandType(axisCommandId.longitudinal)local tz=ip:composeAxisAccelerationFromThrottle(tx,axisCommandId.longitudinal)local tA=t0(axisCommandId.lateral,bv*1000)tu=tu..' , '.."lateral airfoil , lateral ground "tv=tv+tA;if tv:len()>constants.epsilon then d:setEngineForceCommand(tu,tv,tn,'','','',to)end;d:setEngineForceCommand(tx,tz,tm)local tB='thrust analog vertical fueled 'local tC='thrust analog lateral fueled 'if bz=="All"or bz=="Lateral"then tC=tC..aT end;if bz=="All"or bz=="Vertical"then tB=tB..aU end;if bT~=0 or b3 and aY or not bj and not by then d:setEngineForceCommand(tB,tw,tm)else d:setEngineForceCommand(tB,vec3(),tm)end;if bv~=0 then d:setEngineForceCommand(tC,tA,tm)else d:setEngineForceCommand(tC,vec3(),tm)end;if t8==0 then t8=bL end;local tD=-t8*(aM*cE+aN*tc)d:setEngineForceCommand('brake',tD)else if t then if not d1 then d1=bK end end;local rL=c.getAxisCommandValue(0)if not cL then if ts==nil then ts=pid.new(1*0.01,0,1*0.1)end;ts:inject(cE:len()-rL/3.6)local tt=da(ts:get(),0,1)t8=da(t8+tt,0,1)end;local tD=-t8*(aM*cE+aN*tc)d:setEngineForceCommand('brake',tD)local tu=''local tv=vec3()local tE=false;local tx='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then tx=tx..aS end;local ty=ip:getAxisCommandType(axisCommandId.longitudinal)if ty==axisCommandType.byThrottle then local tz=ip:composeAxisAccelerationFromThrottle(tx,axisCommandId.longitudinal)d:setEngineForceCommand(tx,tz,tm)elseif ty==axisCommandType.byTargetSpeed then local tz=ip:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tu=tu..' , '..tx;tv=tv+tz;if ip:getTargetSpeed(axisCommandId.longitudinal)==0 or ip:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ip:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tE=true end end;local tC='thrust analog lateral 'if bz=="All"or bz=="Lateral"then tC=tC..aT end;local tF=ip:getAxisCommandType(axisCommandId.lateral)if tF==axisCommandType.byThrottle then local tG=ip:composeAxisAccelerationFromThrottle(tC,axisCommandId.lateral)d:setEngineForceCommand(tC,tG,tm)elseif tF==axisCommandType.byTargetSpeed then local tA=ip:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tu=tu..' , '..tC;tv=tv+tA end;local tB='thrust analog vertical 'if bz=="All"or bz=="Vertical"then tB=tB..aU end;local tH=ip:getAxisCommandType(axisCommandId.vertical)if tH==axisCommandType.byThrottle then local tw=ip:composeAxisAccelerationFromThrottle(tB,axisCommandId.vertical)if bT~=0 or b3 and aY then d:setEngineForceCommand(tB,tw,tm,'airfoil','ground','',to)else d:setEngineForceCommand(tB,vec3(),tm)d:setEngineForceCommand('airfoil vertical',tw,tm,'airfoil','','',to)d:setEngineForceCommand('ground vertical',tw,tm,'ground','','',to)end elseif tH==axisCommandType.byTargetSpeed then if bT<0 then d:setEngineForceCommand('hover',vec3(),tm)end;local tI=ip:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tu=tu..' , '..tB;tv=tv+tI end;if tv:len()>constants.epsilon then if t8~=0 or tE or eP(tc:dot(cB))<0.5 then tu=tu..', brake'end;d:setEngineForceCommand(tu,tv,tn,'','','',to)end end;local tJ=aJ*(tg-tf)local tK=vec3(b.getWorldAirFrictionAngularAcceleration())tJ=tJ-tK;d:setEngineTorqueCommand('torque',tJ,tm,'airfoil','','',to)d:setBoosterCommand('rocket_engine')if bY and not n then local fg=cD:len()local tL=0.15;if not cL then local tM=ip:getTargetSpeed(axisCommandId.longitudinal)if fg*3.6>tM*(1-tL)and tN then tN=false;d:toggleBoosters()elseif fg*3.6<tM*(1-tL)and not tN then tN=true;d:toggleBoosters()end else local pm=c.getThrottle()if t then pm=bK*100 end;local rL=pm/100;if bI==0 then rL=rL*_;if fg>=rL*(1-tL)and tN then tN=false;d:toggleBoosters()elseif fg<rL*(1-tL)and not tN then tN=true;d:toggleBoosters()end else local rY=bH(cv)rL=rL*rY/3.6;if fg>=rL*(1-tL)and tN then tN=false;d:toggleBoosters()elseif fg<rL*(1-tL)and not tN then tN=true;d:toggleBoosters()end end end end end;c7=qn()return pP end;local function tO(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,io,ip,iq,tP,gC,fM,dV,db,da,fL,is,pO)local tQ={}local tR=true;local tS=5;local tT=5;local tU=tS;local tV=tT;local tW=bJ;function tQ.startControl(tX)local function tY(sI)local sJ=1;local function tZ(t_,sI)local u0={j4.surfaceMaxAltitude+100,j4.spaceEngineMinAltitude-0.01*j4.noAtmosphericDensityAltitude,j4.noAtmosphericDensityAltitude+T,j4.radius*(S-1)+j4.noAtmosphericDensityAltitude}local u1=t_;for dF,dl in ipairs(u0)do if sI and u1>dl then t_=dl elseif t_<dl and not sI then t_=dl;break end end;return t_ end;if sI then sJ=-1 end;if not q and cK then if bV and sI then bs=1000 elseif bs~=nil then bs=bs+sJ*tT;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end else bs=sv+sJ*100 end elseif b2 or b6 or bw then if bw then if bV then cx=tZ(cx,sI)else cx=cx+sJ*tS end;if cx<j4.noAtmosphericDensityAltitude then cx=j4.noAtmosphericDensityAltitude end else if bV and c8 then b7=tZ(b7,sI)else b7=b7+sJ*tS end end else ip:updateTargetGroundAltitudeFromActionStart(sJ*1.0)end end;local function u2(u3)if not c8 then bW="Flight Assist in Atmo only"return end;local di=type(u3)if cR==nil then if di=="table"then if b0 or bn then cn.ToggleAutopilot()end;fL("180On","BR")elseif u3==1 then fL("bnkLft","BR")else fL("bnkRht","BR")end;if not b2 and not b0 and not bn then cn.ToggleAltitudeHold()if di~="table"then u3=u3+1 end end;cR=u3 else fL("180Off","BR")cR=nil end end;if tX=="gear"then bj=not bj;if bj then bn=false;bq=nil;cn.cmdThrottle(0)if vBooster or hover then if c8 and c7==-1 then fL("bklOn","BL")lx=true;b5=false;b4=false;b6=false;b2=false;if b3 then d5=not d5 end;b3=true;ct=true;bj=false else if bP then fL("grOut","LG",1)d.control.extendLandingGears()end;d5=false;ip:setTargetGroundAltitude(Y)if c8 then aY="Landing"end end end;if bP and not b3 and not(vBooster or hover)then fL("grOut","LG",1)d.control.extendLandingGears()end else if bP then fL("grIn","LG",1)d.control.retractLandingGears()end;ip:setTargetGroundAltitude(X)end elseif tX=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif tX=="forward"then bQ=bQ-1 elseif tX=="backward"then if p8 then u2(-cE*5000)else bQ=bQ+1 end elseif tX=="left"then if p8 then u2(1)else bR=bR-1 end elseif tX=="right"then if p8 then u2(3)else bR=bR+1 end elseif tX=="yawright"then bS=bS-1;d6=nil elseif tX=="yawleft"then bS=bS+1;d6=nil elseif tX=="straferight"then ip:updateCommandFromActionStart(axisCommandId.lateral,1.0)bv=1 elseif tX=="strafeleft"then ip:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bv=-1 elseif tX=="up"then bT=bT+1;ip:deactivateGroundEngineAltitudeStabilization()ip:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif tX=="down"then bT=bT-1;ip:deactivateGroundEngineAltitudeStabilization()ip:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif tX=="groundaltitudeup"then tY()elseif tX=="groundaltitudedown"then tY(true)elseif tX=="option1"then u4=false;if p8 and bV then local u5=""for K=1,#cX do u5=u5 .."| Name: "..a.getPlayerName(cX[K]).." Mass: "..fM(b.getBoardedPlayerMass(cX[K])/1000,1).."t "end;a.print("Onboard: "..u5)return end;cm.adjustAutopilotTargetIndex()elseif tX=="option2"then u4=false;if p8 and bV then for K=1,#cX do b.forceDeboard(cX[K])end;bW="Deboarded All Passengers"return end;cm.adjustAutopilotTargetIndex(1)elseif tX=="option3"then local function u6()tR=not tR;if not tR then fL("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(u7,atmofueltank_size,"Atmo Fuel","fuel_container")u8=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(u9,spacefueltank_size,"Space Fuel","fuel_container")ua=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(ub,rocketfueltank_size,"Rocket Fuel","fuel_container")uc=_autoconf.panels[_autoconf.panels_size]end;ud=a.createWidgetPanel("Docking")ue=a.createWidget(ud,"parenting")a.addDataToWidget(c.getDataId(),ue)uf=a.createWidgetPanel("Core combat stress")ug=a.createWidget(uf,"core_stress")a.addDataToWidget(b.getDataId(),ug)if shield_1~=nil then shield_1.show()end else fL("hud","DH")c.hide()b.hide()if u8~=nil then gC(u8)u8=nil end;if ud~=nil then gC(ud)ud=nil end;if uf~=nil then gC(uf)uf=nil end;if ua~=nil then gC(ua)ua=nil end;if uc~=nil then gC(uc)uc=nil end;if shield_1~=nil then shield_1.hide()end end end;u4=false;if p8 and bV then local u5=""for K=1,#cY do u5=u5 .."| ID: "..cY[K].." Mass: "..fM(b.getDockedConstructMass(cY[K])/1000,1).."t "end;a.print("Docked Ships: "..u5)return end;if x then if w then w=false else w=true end end;u6()elseif tX=="option4"then u4=false;if p8 and bV then for K=1,#cY do b.forceUndock(cY[K])end;bW="Undocked all ships"return end;cR=nil;cn.ToggleAutopilot()elseif tX=="option5"then u4=false;cn.ToggleLockPitch()elseif tX=="option6"then u4=false;if p8 and bV then if shield_1 then cq.ventShield()else bW="No shield found"end;return end;cn.ToggleAltitudeHold()elseif tX=="option7"then u4=false;if p8 and bV then if shield_1 then shield_1.toggle()return else bW="No shield found"return end end;E=not E;if E then bW="Collision System Enabled"else bW="Collision System Secured"end elseif tX=="option8"then u4=false;if p8 and bV then if bi>0 and fX~=nil then cn.routeWP()else bW="Select a saved wp on IPH to add to or remove from route"end;return end;by=not by;if not by then bW="DeCoupled Mode - Ground Stabilization off"ip:deactivateGroundEngineAltitudeStabilization()fL("gsOff","GS")else bW="Coupled Mode - Ground Stabilization on"ip:activateGroundEngineAltitudeStabilization(uh)d:setEngineForceCommand('hover',vec3(),1)fL("gsOn","GS")end elseif tX=="option9"then u4=false;if p8 and bV then ip:resetCommand(axisCommandId.longitudinal)ip:resetCommand(axisCommandId.lateral)ip:resetCommand(axisCommandId.vertical)cn.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cc=gyro.getState()==1;if cc then fL("gyOn","GA")else fL("gyOff","GA")end else bW="No gyro found"end elseif tX=="lshift"then cV=false;if p8 then bV=true end;if iq()==1 then bV=true;bf=iq()tP(1)elseif io()==1 and y then bV=true;cs=false;cr=false end elseif tX=="brake"then if aW or p8 then cn.BrakeToggle("Manual")elseif not aY then cn.BrakeToggle("Manual")else aY="Manual"end elseif tX=="lalt"then u4=true;p8=true;if io()==0 and not i and g=="keyboard"then tP(1)end elseif tX=="booster"then if n then d:toggleBoosters()elseif not bY then if not tN then d:toggleBoosters()tN=true end;bY=true else if tN then d:toggleBoosters()tN=false end;bY=false end elseif tX=="stopengines"then local function ui()if bJ-tW<1.5 then fL("clear","CA")cn.clearAll()end end;ui()tW=bJ;if ip:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then ip:resetCommand(axisCommandId.longitudinal)cn.cmdThrottle(0)else cn.cmdThrottle(100)end else if ip:getTargetSpeed(axisCommandId.longitudinal)~=0 then ip:resetCommand(axisCommandId.longitudinal)else if c8 then cn.cmdCruise(U)else cn.cmdCruise(_*3.6)end end end elseif tX=="speedup"then cn.changeSpd()elseif tX=="speeddown"then cn.changeSpd(true)elseif tX=="antigravity"and not q then if antigrav~=nil then cn.ToggleAntigrav()else bW="No antigrav found"end end end;function tQ.stopControl(tX)local function uj()if not q and cK then tV=tT end;if b2 or b6 or bw then tU=tS end end;if tX=="forward"then bQ=0 elseif tX=="backward"then bQ=0 elseif tX=="left"then if cR then if cR==2 then cR=-2 else cR=-1 end end;bR=0 elseif tX=="right"then if cR then if cR==4 then cR=-2 else cR=-1 end end;bR=0 elseif tX=="yawright"then bS=0 elseif tX=="yawleft"then bS=0 elseif tX=="straferight"then ip:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bv=0 elseif tX=="strafeleft"then ip:updateCommandFromActionStop(axisCommandId.lateral,1.0)bv=0 elseif tX=="up"then bT=0;ip:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if by then ip:activateGroundEngineAltitudeStabilization(uh)d:setEngineForceCommand('hover',vec3(),1)end elseif tX=="down"then bT=0;ip:updateCommandFromActionStop(axisCommandId.vertical,1.0)if by then ip:activateGroundEngineAltitudeStabilization(uh)d:setEngineForceCommand('hover',vec3(),1)end elseif tX=="groundaltitudeup"then uj()u4=false elseif tX=="groundaltitudedown"then uj()u4=false elseif tX=="lshift"then if iq()==1 then c1=0;c2=0;tP(bf)elseif io()==1 and y then cs=false;cr=false end;bV=false elseif tX=="brake"then if not aW and not p8 then if aY then cn.BrakeToggle()else aY=false end end elseif tX=="lalt"then if io()==0 and i then if u4 then if iq()==1 then tP(0)else tP(1)end else u4=true end elseif io()==0 and not i and g=="keyboard"then tP(0)end;p8=false end end;function tQ.loopControl(tX)local function uk(sI)local sJ=1;if sI then sJ=-1 end;if not q and cK then if bs~=nil then bs=bs+sJ*tV;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end;tV=da(tV*1.05,tT,50)else bs=sv+sJ*100 end elseif b2 or b6 or bw then if bw then cx=cx+sJ*tU;if cx<j4.noAtmosphericDensityAltitude then cx=j4.noAtmosphericDensityAltitude end else b7=b7+sJ*tU end;tU=da(tU*1.05,tS,50)else ip:updateTargetGroundAltitudeFromActionLoop(sJ*1.0)end end;local function ul(sI)local sJ=1;if sI then sJ=-1 end;if not bV then if t and not p8 then bK=da(bK+sJ*aB/100,-1,1)else ip:updateCommandFromActionLoop(axisCommandId.longitudinal,sJ*aB)end end end;if tX=="groundaltitudeup"then if not bV then uk()end elseif tX=="groundaltitudedown"then if not bV then uk(true)end elseif tX=="speedup"then ul()elseif tX=="speeddown"then ul(true)end end;function tQ.inputTextControl(sH)local function um(un,fm,gq)local function uo(fm)local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..ds..','..ds..','..ds..','..ds..','..ds..'}'local dJ,dK,dS,dT,dU=dV(fm,dt)if dJ=="0"and dK=="0"then return vec3(db(dS),db(dT),db(dU))end;dT=math.rad(dT)dS=math.rad(dS)local j4=e[db(dJ)][db(dK)]local eL=math.cos(dS)local up=vec3(eL*math.cos(dT),eL*math.sin(dT),math.sin(dS))return j4.center+(j4.radius+dU)*up end;local fO=uo(fm)return cm.AddNewLocation(un,fO,gq)end;local K;local uq,ic=nil,nil;local ur="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(sH," ")uq=sH;if K~=nil then uq=string.sub(sH,0,K-1)ic=string.sub(sH,K+1)end;if uq=="/help"or uq=="/commands"then for ly in string.gmatch(ur,"([^\n]+)")do a.print(ly)end;return elseif uq=="/setname"then if ic==nil or ic==""then bW="Usage: ah-setname Newname"return end;if bi>0 and fX~=nil then cm.UpdatePosition(ic)else bW="Select a saved target to rename first"end elseif shield_1 and uq=="/resist"then cq.setResist(ic)elseif uq=="/addlocation"or string.find(sH,"::pos")~=nil then local gq=false;local un="0-Temp"if ic==nil or ic==""then ic=uq;gq=true end;K=string.find(ic,"::")if not gq then un=string.sub(ic,1,K-2)end;local fm=string.sub(ic,K)um(un,fm,gq)elseif uq=="/agg"then if ic==nil or ic==""then bW="Usage: /agg targetheight"return end;ic=db(ic)if ic<1000 then ic=1000 end;bs=ic;bW="AGG Target Height set to "..ic elseif uq=="/G"then if ic==nil or ic==""then bW="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ic=="dump"then for dA,dl in pairs(is())do if type(dl.get())=="boolean"then if dl.get()==true then a.print(dA.." true")else a.print(dA.." false")end elseif dl.get()==nil then a.print(dA.." nil")else a.print(dA.." "..dl.get())end end;return end;K=string.find(ic," ")local us=string.sub(ic,0,K-1)local ut=string.sub(ic,K+1)for dA,dl in pairs(is())do if dA==us then bW="Variable "..us.." changed to "..ut;local uu=type(dl.get())if uu=="number"then ut=db(ut)if dA=="AtmoSpeedLimit"then cv=ut end elseif uu=="boolean"then if string.lower(ut)=="true"then ut=true else ut=false end end;dl.set(ut)return end end;bW="No such global variable: "..us elseif uq=="/deletewp"then if bi>0 and fX~=nil then cm.ClearCurrentPosition()else bW="Select a custom wp to delete first in IPH"end elseif uq=="/copydatabank"then if dbHud_2 then pO(true)else bW="Spare Databank required to copy databank"end elseif uq=="/iphWP"then if bi>0 then a.print(cn.showWayPoint(c0,bh,true))a.print(json.encode(bh))bW="::pos waypoint shown in lua chat in local and world format"else bW="No target selected in IPH"end elseif uq=="/createPrivate"then local uv="privatelocations = {\n"local uw=""if#d3>0 then for dA,dl in pairs(d3)do uv=uv.."{position = {x = "..dl.position.x..", y = "..dl.position.y..", z = "..dl.position.z.."},\n ".."name = '"..dl.name.."',\n planetname = '"..dl.planetname.."',\n gravity = "..dl.gravity..",\n"if dl.heading then uv=uv.."heading = {x = "..dl.heading.x..", y = "..dl.heading.y..", z = "..dl.heading.z.."},\n"end;if dl.safe then uv=uv.."safe = true},\n"else uv=uv.."safe = false},\n"end end end;uw=#d3 .."-Private "if ic=="all"then for dA,dl in pairs(bm)do uv=uv.."{position = {x = "..dl.position.x..", y = "..dl.position.y..", z = "..dl.position.z.."},\n ".."name = '*"..dl.name.."',\n planetname = '"..dl.planetname.."',\n gravity = "..dl.gravity..",\n"if dl.heading then uv=uv.."heading = {x = "..dl.heading.x..", y = "..dl.heading.y..", z = "..dl.heading.z.."},\n"end;if dl.safe then uv=uv.." safe = true},\n"else uv=uv.."safe = false},\n"end end;uw=uw..#bm.."-Public "end;uv=uv.."}\n return privatelocations"if screenHud_1 then screenHud_1.setHTML(uv)end;bW=uw.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bX=7 end end;function tQ.tagTick()if bz=="Off"then bz="All"elseif bz=="All"then bz="Longitude"elseif bz=="Longitude"then bz="Lateral"elseif bz=="Lateral"then bz="Vertical"else bz="Off"end;bW="Extra Engine Tags: "..bz;c.stopTimer("tagTick")end;return tQ end;local function ux(d,b,c,a,library,e,vBooster,hover,pN,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ik,screenHud_1)local uy={}local d9=string.format;local il=json.decode;local uz=json.encode;local pH=b.getElementMaxHitPointsById;local im=b.getElementMassById;local io=d.control.isRemoteControlled;local dV=string.match;local gC=a.destroyWidgetPanel;local fJ=a.updateData;local fK=a.addDataToWidget;local tP=a.lockView;local iq=a.isViewLocked;local dc=math.sqrt;local db=tonumber;local eP=math.abs;local bH=math.floor;local bI=c.getAtmosphereDensity;local eK=math.atan;local bG=a.getTime;local da=utils.clamp;local ip=d.axisCommandManager;local uA=Y;local gE=13;local iv=b.getElementIdList()local iw=0;local function dd(es,et)if es==0 then return eP(et)<1e-09 end;if et==0 then return eP(es)<1e-09 end;return eP(es-et)<math.max(eP(es),eP(et))*dr end;local function fM(ds,uB)local sJ=10^(uB or 0)return bH(ds*sJ+0.5)/sJ end;local function ir(uC,uD)for dA,dl in pairs(uD)do if type(dA)=="string"then uC[dA]=dl else uC[#uC+1]=uD[dA]end end;return uC end;local function is(uE)local uF={}if not uE then ir(uF,J)ir(uF,a8)ir(uF,az)ir(uF,aV)return uF elseif uE=="boolean"then return J elseif uE=="handling"then return a8 elseif uE=="hud"then return az elseif uE=="physics"then return aV end end;local function pO(uG)local function uH(uI)for dA,dl in pairs(uI)do dbHud_1.setStringValue(dA,uz(dl.get()))if uG and dbHud_2 then dbHud_2.setStringValue(dA,uz(dl.get()))end end end;if dbHud_1 then uH(bD)uH(is())a.print("Saved Variables to Datacore")if uG and dbHud_2 then bW="Databank copied.  Remove copy when ready."end end end;local function fL(uJ,uK,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uJ..".mp3")end;local function gD(he,hf,sH,jJ,uL)if jJ==nil then jJ=""end;if uL==nil then uL=""end;return d9([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jJ,he,hf,uL,sH)end;local function it(c3,uM)local uN=c3>100000;if uM==nil then uM=1 end;if uN then return fM(c3/1000/200,uM).."SU"elseif c3<1000 then return fM(c3,uM).."M"else return fM(c3/1000,uM).."KM"end end;local function iu(uO)local uP=0;local uQ=0;local uR=0;if uO<60 then uO=bH(uO)elseif uO<3600 then uP=bH(uO/60)uO=bH(uO%60)elseif uO<86400 then uQ=bH(uO/3600)uP=bH(uO%3600/60)else uR=bH(uO/86400)uQ=bH(uO%86400/3600)end;if uR>0 then return uR.."d "..uQ.."h "elseif uQ>0 then return uQ.."h "..uP.."m "elseif uP>0 then return uP.."m "..uO.."s"elseif uO>0 then return uO.."s"else return"0s"end end;function uy.onStart()local uS=false;local function uT()local function uU(uV)local uW=dbHud_1.hasKey;for dA,dl in pairs(uV)do if uW(dA)then local dv=il(dbHud_1.getStringValue(dA))if dv~=nil then dl.set(dv)uS=true end end end end;if dbHud_1 then if not f then uU(is())coroutine.yield()uU(bD)else uU(bD)bW="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bX=5;uS=false end;coroutine.yield()if uS then bW="Loaded Saved Variables"cd=a9;ce=aa;aW=j;g=string.lower(g)ct=p;cv=U elseif not f then bW="No Saved Variables Found - Exit HUD to save settings"end;if bA<1.500 then if T<2000 then bW="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bA=VERSION_NUMBER;if#bm>0 then d4=ir(d4,bm)end else bW="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bt+180<bJ then br=0 end;bt=bJ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bW="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bX=7 end;if antigrav and not q then if bs==nil then bs=ca end;antigrav.setBaseAltitude(bs)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d3>0 then d4=ir(d4,d3)end end;lG="Proceeding to Waypoint"end;local function uX()local function uY(uZ,u_)if uZ>u_ then u_=uZ end;local v0,v1=0,0;if a5>0 then v0=a5*0.05 end;if a6>0 then v1=a6*0.05 end;u_=u_*(1-(v0+v1))return u_ end;local v2=b.getElementNameById;local v3=aq~=0 and ar~=0;for dA in pairs(iv)do local type=b.getElementTypeById(iv[dA])if dV(type,'^.*Atmospheric Engine$')then if dV(tostring(b.getElementTagsById(iv[dA])),'^.*vertical.*$')and b.getElementForwardById(iv[dA])[3]>0 then cJ=true end end;if dV(type,'^.*Space Engine$')then cA=true;if dV(tostring(b.getElementTagsById(iv[dA])),'^.*vertical.*$')then local v4=b.getElementForwardById(iv[dA])if v4[3]<0 then v5=true else cz=true end end end;if type=="Landing Gear"then bP=true end;if type=="Dynamic Core Unit"then local pJ=pH(iv[dA])if pJ>10000 then gE=110 elseif pJ>1000 then gE=55 elseif pJ>150 then gE=27 end end;iw=iw+pH(iv[dA])if v3 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pJ=pH(iv[dA])local ow=im(iv[dA])local uZ=0;local jD=bG()if type=="Atmospheric Fuel Tank"then local u_=400;local v6=35.03;if pJ>10000 then u_=51200;v6=5480 elseif pJ>1300 then u_=6400;v6=988.67 elseif pJ>150 then u_=1600;v6=182.67 end;uZ=ow-v6;if a2>0 then u_=u_+u_*a2*0.2 end;u_=uY(uZ,u_)cf[#cf+1]={iv[dA],v2(iv[dA]),u_,v6,uZ,jD}end;if type=="Rocket Fuel Tank"then local u_=320;local v6=173.42;if pJ>65000 then u_=40000;v6=25740 elseif pJ>6000 then u_=5120;v6=4720 elseif pJ>700 then u_=640;v6=886.72 end;uZ=ow-v6;if a4>0 then u_=u_+u_*a4*0.1 end;u_=uY(uZ,u_)ch[#ch+1]={iv[dA],v2(iv[dA]),u_,v6,uZ,jD}end;if type=="Space Fuel Tank"then local u_=600;local v6=35.03;if pJ>10000 then u_=76800;v6=5480 elseif pJ>1300 then u_=9600;v6=988.67 elseif pJ>150 then u_=2400;v6=182.67 end;uZ=ow-v6;if a3>0 then u_=u_+u_*a3*0.2 end;u_=uY(uZ,u_)cg[#cg+1]={iv[dA],v2(iv[dA]),u_,v6,uZ,jD}end end end;if not cJ then b6,aX=false,false end end;local function v7()if gyro~=nil then cc=gyro.getState()==1 end;if not by then ip:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then tP(1)else tP(0)end;if door and(c8 or not c8 and ca<10000)then for dF,dl in pairs(door)do dl.toggle()end end;if switch then for dF,dl in pairs(switch)do dl.toggle()end end;if forcefield and(c8 or not c8==0 and ca<10000)then for dF,dl in pairs(forcefield)do dl.toggle()end end;if antigrav then cK=antigrav.getState()==1;if cK and not q then antigrav.show()end end;if io()==1 and k then a.freeze(1)else a.freeze(0)end;if bP then bj=d.control.isAnyLandingGearExtended()==1;if bj then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if c7~=-1 or not c8 and cD:len()<50 then aY="Startup"bj=true;if bP then d.control.extendLandingGears()end else aY=false end;ip:setTargetGroundAltitude(uA)pv=c8 end;local function v8()local v9={}local function va()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vb={[1]=4480,[6]=4480,[7]=6270}for vc,vd in pairs(e)do e[vc][0]=va()e[vc][0].systemId=vc;v9[vc]={}for ve,j4 in pairs(e[vc])do j4.gravity=j4.gravity/9.8;j4.center=vec3(j4.center)j4.name=j4.name[1]j4.noAtmosphericDensityAltitude=j4.atmosphereThickness or j4.atmosphereRadius-j4.radius;if j4.name=="Lacobus"then j4.noAtmosphericDensityAltitude=12510 end;j4.spaceEngineMinAltitude=vb[j4.id]or 0.68377*j4.atmosphereThickness;j4.planetarySystemId=vc;j4.bodyId=j4.id;v9[vc][ve]=j4;if my==nil or j4.center.x<my then my=j4.center.x end;if mx==nil or j4.center.x>mx then mx=j4.center.x end;if mB==nil or j4.center.y<mB then mB=j4.center.y end;if mA==nil or j4.center.y>mA then mA=j4.center.y end;if j4.center and j4.name~="Space"then cZ[#cZ+1]=j4 end end end;e4=d8(d,b,c,a,d9,da,db,dc,dd)ci=e4(v9)cj=eO(d,b,c,a,dc,eP)ck=fi(d,b,c,a,d9,da,db,dc,dd)cm=fI(d,b,c,a,dbHud_1,e,fJ,fK,bH,db,dc,fL,fM)end;vf=false;vg=coroutine.create(function()ip:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})uT()coroutine.yield()uX()coroutine.yield()cn=pM(d,b,c,a,e,vBooster,hover,pN,antigrav,warpdrive,dbHud_1,eP,bH,bI,io,eK,bG,da,ip,fJ,iq,dc,fM,fL,ir,dd,it,iu,pO,il,d9,fK)v7()coroutine.yield()v8()if radar_1 then co=gB(b,a,c,library,radar_1,radar_2,eP,gC,dc,gD,db,gE,fL)end;cl=ij(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ik,eP,bH,d9,il,bI,im,io,eK,bG,da,ip,fK,fJ,gC,iq,dc,fM,gD,fL,ir,is,it,iu,iv,iw)cl.ButtonSetup()cp=tO(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,io,ip,iq,tP,gC,fM,dV,db,da,fL,is,pO)if shield_1 then cq=i3(shield_1,dV,bH)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aP)if radar_1 then c.setTimer("radarTick",aP)end;c.setTimer("hudTick",aQ)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield_1 then c.setTimer("shieldTick",aP)end;if vh then vh(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1)end;fL("start","SU")end)coroutine.resume(vg)end;function uy.onUpdate()if not vf then local hU=coroutine.status(vg)if hU=="suspended"then local dB,hV=coroutine.resume(vg)if hV then a.print("ERROR STARTUP: "..hV)end elseif hU=="dead"then vf=true end end;if vf then d:update()if c8 and t and cL then if cL and bO then cn.cmdThrottle(0)bO=false elseif not cL and not bO then bK=0;bO=true end end;if d1 then ip:setThrottleCommand(axisCommandId.longitudinal,d1)d1=nil end;if not cr and pa~=vi then a.setScreen(pa)end;if vj then vj(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1)end;vi=pa end end;function uy.onFlush()if vf then cn.onFlush()if vk then vk(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1)end end end;function uy.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c9>0 or c9==0 and ca<10000)then for dF,dl in pairs(door)do dl.toggle()end end;if switch then for dF,dl in pairs(switch)do dl.toggle()end end;if forcefield and(c9>0 or c9==0 and ca<10000)then for dF,dl in pairs(forcefield)do dl.toggle()end end;w=d0;pO()if o5 then o5.activate()end;if z then cn.showWayPoint(j4,cI)end;a.print(cl.FuelUsed("atmofueltank")..", "..cl.FuelUsed("spacefueltank")..", "..cl.FuelUsed("rocketfueltank"))if vl then vl(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1)end;fL("stop","SU")end;function uy.controlStart(tX)if vf then cp.startControl(tX)if vm then vm(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1,tX)end end end;function uy.controlStop(tX)if vf then cp.stopControl(tX)if vn then vn(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1,tX)end end end;function uy.controlLoop(tX)if vf then cp.loopControl(tX)if vo then vo(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1,tX)end end end;function uy.controlInput(sH)if vf then cp.inputTextControl(sH)if vp then vp(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1,sH)end end end;function uy.radarEnter(dK)co.onEnter(dK)if vq then vq(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1,dK)end end;function uy.radarLeave(dK)co.onLeave(dK)if vr then vr(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1,dK)end end;function uy.onTick(vs)if vs=="tenthSecond"then cn.TenthTick()cl.TenthTick()elseif vs=="oneSecond"then cl.OneSecondTick()elseif vs=="fiveSecond"then cn.SatNavTick()elseif vs=="msgTick"then cl.MsgTick()elseif vs=="animateTick"then cl.AnimateTick()elseif vs=="hudTick"then cl.hudtick()elseif vs=="apTick"then cn.APTick()elseif vs=="radarTick"then co.UpdateRadar()elseif vs=="shieldTick"then cq.shieldTick()elseif vs=="tagTick"then cp.tagTick()elseif vs=="contact"then co.ContactTick()end;if vt then vt(d,b,c,a,e,radar_1,radar_2,vBooster,hover,antigrav,hover,shield_1,warpdrive,ik,dbHud_1,dbHud_2,gyro,screenHud_1,vs)end end;return uy end;function script.onStart()vu.onStart()end;function script.onStop()vu.onStop()end;function script.onTick(vs)vu.onTick(vs)end;function script.onFlush()vu.onFlush()end;function script.onUpdate()vu.onUpdate()end;function script.onActionStart(tX)vu.controlStart(tX)end;function script.onActionStop(tX)vu.controlStop(tX)end;function script.onActionLoop(tX)vu.controlLoop(tX)end;function script.onInputText(sH)vu.controlInput(sH)end;function script.onEnter(dK)vu.radarEnter(dK)end;function script.onLeave(dK)vu.radarLeave(dK)end;bF(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)vu=ux(d,b,c,a,library,e,vBooster,hover,pN,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ik,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
