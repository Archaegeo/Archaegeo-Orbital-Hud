name: ArchHud - Archaegeo v1.5201 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 0 --export:
        OrbitMapY = 25 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5201;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=""local aC=true;local aD=ResolutionX;local aE=ResolutionY;local aF={}local aG={}local aH={}local aI=0;local aJ=false;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=false;local aU=false;local aV=autoRollPreference;local aW=LandingGearGroundHeight;local aX=false;local aY=0;local aZ=AtmoSpeedLimit;local a_=0;local b0=nil;local b1={VectorToTarget=false}local b2=0;local b3=false;local b4=false;local b5=false;local b6=false;local b7=vec3(core.getConstructWorldOrientationUp())local b8=vec3(core.getConstructWorldOrientationForward())local b9=vec3(core.getConstructWorldOrientationRight())local ba=vec3(core.getVelocity())local bb=vec3(core.getWorldVelocity())local bc=vec3(bb):len()local bd=vec3(core.getWorldVertical())local be=-bd:dot(bb)local bf=vec3(core.getConstructWorldPos())local bg=false;local bh=false;local bi=nil;local bj=true;local bk=0;local bl=0;local bm={}local bn=false;local bo=50000;local bp=nil;local bq={}local br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bs=false;local bt=nil;local bu={}local bv="Atmo"local bw=false;local bx=0;local by={}local bz=nil;local bA=nil;local bB={}local bC=90;local bD=showHud;function p(bE)system.print(E..": "..bE)end;local function bF(bG)local D=1;if bG then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bH=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bH<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then aZ=r(aZ+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bx=bx+1*D*-1;if bx>#bm then bx=1 end;if bx<1 then bx=#bm end else if not bG then D=1 else D=nil end;aQ.adjustAutopilotTargetIndex(D)end end end;local function bI(bJ,bK,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bJ.."|"..bK.."|"..soundVolume)end end;local function bL(bM,bN)for i=1,#bN do bM[#bM+1]=bN[i]end;return bM end;local function bO(bP)local bQ={}local bR={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local bS={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bT={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bU={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bP then bL(bQ,bR)bL(bQ,bS)bL(bQ,bT)bL(bQ,bU)return bQ elseif bP=="boolean"then return bR elseif bP=="handling"then return bS elseif bP=="hud"then return bT elseif bP=="physics"then return bU end end;local function bV(bW,bX,bY,bZ,b_)if bZ==nil then bZ=""end;if b_==nil then b_=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bZ,bW,bX,b_,bY)end;local function c0(c1,c2)if c1==0 then return d(c2)<1e-09 end;if c2==0 then return d(c1)<1e-09 end;return d(c1-c2)<math.max(d(c1),d(c2))*epsilon end;local function c3(aj,c4)local c5=aj>100000;if c4==nil then c4=1 end;if c5 then return A(aj/1000/200,c4).."SU"elseif aj<1000 then return A(aj,c4).."M"else return A(aj/1000,c4).."KM"end end;local function c6(c7)local c8=0;local c9=0;local ca=0;if c7<60 then c7=e(c7)elseif c7<3600 then c8=e(c7/60)c7=e(c7%60)elseif c7<86400 then c9=e(c7/3600)c8=e(c7%3600/60)else ca=e(c7/86400)c9=e(c7%86400/3600)end;if ca>0 then return ca.."d "..c9 .."h "elseif c9>0 then return c9 .."h "..c8 .."m "elseif c8>0 then return c8 .."m "..c7 .."s"elseif c7>0 then return c7 .."s"else return"0s"end end;local function cb(cc)local function cd(ce)for cf,cg in pairs(ce)do dbHud_1.setStringValue(cg,h(_G[cg]))if cc and dbHud_2 then dbHud_2.setStringValue(cg,h(_G[cg]))end end end;if dbHud_1 then cd(c)cd(bO())system.print("Saved Variables to Datacore")if cc and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function ch()local function ci(cj)return type(cj)=='number'end;local function ck(cj)return type(z(cj))=='number'end;local function cl(cm)return type(cm)=='table'end;local function cn(co)return type(co)=='string'end;local function cp(cg)return cl(cg)and ci(cg.x and cg.y and cg.z)end;local function cq(cr)return cl(cr)and ci(cr.latitude and cr.longitude and cr.altitude and cr.id and cr.systemId)end;local cs=math.pi/180;local ct=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cv(cj)local cw=string.gsub(string.reverse(f('%.4f',cj)),'^0*%.?','')return cw==''and'0'or string.reverse(cw)end;local function cx(cy)if cp(cy)then return f('{x=%.3f,y=%.3f,z=%.3f}',cy.x,cy.y,cy.z)end;if cl(cy)and not getmetatable(cy)then local cz={}local cA=next(cy)if type(cA)=='nil'or cA==1 then cz=cy else for cf,cg in pairs(cy)do local cB=cx(cg)if type(cf)=='number'then table.insert(cz,f('[%s]=%s',cf,cB))else table.insert(cz,f('%s=%s',cf,cB))end end end;return f('{%s}',table.concat(cz,','))end;if cn(cy)then return f("'%s'",cy:gsub("'",[[\']]))end;return tostring(cy)end;local cC={}cC.__index=cC;cC.__tostring=function(cy,cD)local cE={}for cf in pairs(cy)do table.insert(cE,cf)end;table.sort(cE)local cz={}for _,cf in ipairs(cE)do local cB=cx(cy[cf])if type(cf)=='number'then table.insert(cz,f('[%s]=%s',cf,cB))else table.insert(cz,f('%s=%s',cf,cB))end end;if cD then return f('%s%s',cD,table.concat(cz,',\n'..cD))end;return f('{%s}',table.concat(cz,','))end;cC.__eq=function(cF,cG)return cF.systemId==cG.systemId and cF.id==cG.id and c0(cF.radius,cG.radius)and c0(cF.center.x,cG.center.x)and c0(cF.center.y,cG.center.y)and c0(cF.center.z,cG.center.z)and c0(cF.GM,cG.GM)end;local function cH(cI,cJ,cK,cL,cM)assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(cK),'Argument 3 (radius) must be a number:'..type(cK))assert(cl(cL),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cL))assert(ck(cM),'Argument 5 (GM) must be a number:'..type(cM))return setmetatable({systemId=z(cI),id=z(cJ),radius=z(cK),center=vec3(cL),GM=z(cM)},cC)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cv(p.latitude*ct),cv(p.longitude*ct),cv(p.altitude))end;MapPosition.__eq=function(cF,cG)return cF.id==cG.id and cF.systemId==cG.systemId and c0(cF.latitude,cG.latitude)and c0(cF.altitude,cG.altitude)and(c0(cF.longitude,cG.longitude)or c0(cF.latitude,math.pi/2)or c0(cF.latitude,-math.pi/2))end;local function cN(cO,cJ,cP,cQ,cR)local cI=cO;if cn(cO)and not cQ and not cR and not cJ and not cP then cI,cJ,cP,cQ,cR=o(cO,cu)assert(cI,'Argument 1 (position string) is malformed.')else assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(cP),'Argument 3 (latitude) must be in degrees:'..type(cP))assert(ck(cQ),'Argument 4 (longitude) must be in degrees:'..type(cQ))assert(ck(cR),'Argument 5 (altitude) must be in meters:'..type(cR))end;cI=z(cI)cJ=z(cJ)cP=z(cP)cQ=z(cQ)cR=z(cR)if cJ==0 then return setmetatable({latitude=cP,longitude=cQ,altitude=cR,id=cJ,systemId=cI},MapPosition)end;return setmetatable({latitude=cs*r(cP,-90,90),longitude=cs*(cQ%360),altitude=cR,id=cJ,systemId=cI},MapPosition)end;local cS={}cS.__index=cS;cS.__tostring=function(cy,cD)local cT=cD and cD..'  'local cU={}local cE={}for cf in pairs(cy)do table.insert(cE,cf)end;table.sort(cE)for _,cV in ipairs(cE)do bdy=cy[cV]local cW=cC.__tostring(bdy,cT)if cD then table.insert(cU,f('[%s]={\n%s\n%s}',cV,cW,cD))else table.insert(cU,f('  [%s]=%s',cV,cW))end end;if cD then return f('\n%s%s%s',cD,table.concat(cU,',\n'..cD),cD)end;return f('{\n%s\n}',table.concat(cU,',\n'))end;local function cX(cY)local b={}local pid;for _,cg in pairs(cY)do local cJ=cg.planetarySystemId;if type(cJ)~='number'then error('Invalid planetary system ID: '..tostring(cJ))elseif pid and cJ~=pid then error('Mistringmatch planetary system IDs: '..cJ..' and '..pid)end;local cZ=cg.bodyId;if type(cZ)~='number'then error('Invalid body ID: '..tostring(cZ))elseif b[cZ]then error('Duplicate body ID: '..tostring(cZ))end;setmetatable(cg.center,getmetatable(vec3.unit_x))b[cZ]=setmetatable(cg,cC)pid=cJ end;return setmetatable(b,cS)end;aK={}local function c_(cY)return setmetatable({galaxyAtlas=cY or{}},aK)end;aK.__index=function(cm,i)if type(i)=='number'then local system=cm.galaxyAtlas[i]return cX(system)end;return rawget(aK,i)end;aK.__pairs=function(cy)return function(cm,cf)local d0,nv=next(cm,cf)return d0,nv and cX(nv)end,cy.galaxyAtlas,nil end;aK.__tostring=function(cy)local d1={}for _,d2 in pairs(cy or{})do local d3=d2:getPlanetarySystemId()local d4=cS.__tostring(d2,'    ')table.insert(d1,f('  [%s]={%s\n  }',d3,d4))end;return f('{\n%s\n}\n',table.concat(d1,',\n'))end;aK.BodyParameters=cH;aK.MapPosition=cN;aK.PlanetarySystem=cX;function aK.createBodyParameters(cI,cJ,d5,d6,d7,d8,d9)assert(ck(cI),'Argument 1 (systemId) must be a number:'..type(cI))assert(ck(cJ),'Argument 2 (id) must be a number:'..type(cJ))assert(ck(d5),'Argument 3 (surfaceArea) must be a number:'..type(d5))assert(cl(d6),'Argument 4 (aPosition) must be an array or vec3:'..type(d6))assert(cl(d7),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(d7))assert(ck(d8),'Argument 6 (altitude) must be in meters:'..type(d8))assert(ck(d9),'Argument 7 (gravityAtPosition) must be number:'..type(d9))local cK=y(d5/4/math.pi)local aj=cK+d8;local da=vec3(d6)+aj*vec3(d7)local cM=d9*aj*aj;return cH(cI,cJ,cK,da,cM)end;aK.isMapPosition=cq;function aK:getPlanetarySystem(cO)if i==nil then i=0 end;if nv==nil then nv=0 end;local cI=cO;if cq(cO)then cI=cO.systemId end;if type(cI)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=cS then system=cX(system)end;return system end end end;function cS:sizeCalculator(db)return 1.05*db.radius end;function cS:castIntersections(dc,dd,de,df,dg,dh)local di={}if dg then for _,db in pairs(dg)do table.insert(di,db)end else di=bB end;if not dh then table.sort(di,function(dj,dk)local c1=dj.center;local c2=dk.center;return(c1.x-dc.x)^2+(c1.y-dc.y)^2+(c1.z-dc.z)^2<(c2.x-dc.x)^2+(c2.y-dc.y)^2+(c2.z-dc.z)^2 end)end;local dl=dd:normalize()for _,db in ipairs(di)do local dm=db.center-dc;local cK=self:sizeCalculator(db)local dn=dm:dot(dl)local dp=dn^2-(dm:len2()-cK^2)if dp>=0 then local dq=y(dp)local dr=dn+dq;local ds=dn-dq;if ds>0 then return db,dr,ds elseif dr>0 then return db,dr,nil end end end;return nil,nil,nil end;function cS:closestBody(dt)assert(type(dt)=='table','Invalid coordinates.')local du,db;local dv=vec3(dt)for _,dw in pairs(self)do local dx=(dw.center-dv):len2()if(not db or dx<du)and dw.name~="Space"then db=dw;du=dx end end;return db end;function cS:convertToBodyIdAndWorldCoordinates(cO)local dy=cO;if cn(cO)then dy=cN(cO)end;if dy.id==0 then return 0,vec3(dy.latitude,dy.longitude,dy.altitude)end;local dw=self:getBodyParameters(dy)if dw then return dy.id,dw:convertToWorldCoordinates(dy)end end;function cS:getBodyParameters(cO)local cJ=cO;if cq(cO)then cJ=cO.id end;assert(ck(cJ),'Argument 1 (id) must be a number:'..type(cJ))return self[cJ]end;function cS:getPlanetarySystemId()local _,cg=next(self)return cg and cg.systemId end;function cC:convertToMapPosition(cL)assert(cl(cL),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cL))local dz=vec3(cL)if self.id==0 then return setmetatable({latitude=dz.x,longitude=dz.y,altitude=dz.z,id=0,systemId=self.systemId},MapPosition)end;local dA=dz-self.center;local aj=dA:len()local cR=aj-self.radius;local cP=0;local cQ=0;if not c0(aj,0)then local dB=n(dA.y,dA.x)cQ=dB>=0 and dB or 2*math.pi+dB;cP=math.pi/2-math.acos(dA.z/aj)end;return setmetatable({latitude=cP,longitude=cQ,altitude=cR,id=self.id,systemId=self.systemId},MapPosition)end;function cC:convertToWorldCoordinates(cO)local dy=cn(cO)and cN(cO)or cO;if dy.id==0 then return vec3(dy.latitude,dy.longitude,dy.altitude)end;assert(cq(dy),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dy.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dy.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dC=math.cos(dy.latitude)return self.center+(self.radius+dy.altitude)*vec3(dC*math.cos(dy.longitude),dC*math.sin(dy.longitude),math.sin(dy.latitude))end;function cC:getAltitude(cL)return(vec3(cL)-self.center):len()-self.radius end;function cC:getDistance(cL)return(vec3(cL)-self.center):len()end;function cC:getGravity(cL)local dD=self.center-vec3(cL)local dE=dD:len2()return self.GM/dE*dD/y(dE)end;return setmetatable(aK,{__call=function(_,...)return c_(...)end})end;local function dF()local aM={}local dG=30000000/3600;local dH=dG*dG;local dI=100;function aM.computeAccelerationTime(dJ,dK,dL)local dM=dG*math.asin(dJ/dG)return(dG*math.asin(dL/dG)-dM)/dK end;function aM.computeDistanceAndTime(dJ,dL,dN,dO,dP,dQ)dP=dP or 0;dQ=dQ or 0;local dR=dJ<=dL;local dS=dO*(dR and 1 or-1)/dN;local dT=-dQ/dN;local dU=dS+dT;if dR and dU<=0 or not dR and dU>=0 then return-1,-1 end;local dV,dW=0,0;if dS~=0 and dP>0 then local dM=math.asin(dJ/dG)local dX=math.pi*(dS/2+dT)local dY=dS*dP;local dZ=dG*math.pi;local cg=function(cm)local d_=(dX*cm-dY*math.sin(math.pi*cm/2/dP)+dZ*dM)/dZ;local e0=math.tan(d_)return dG*e0/y(e0*e0+1)end;local e1=dR and function(co)return co>=dL end or function(co)return co<=dL end;dW=2*dP;if e1(cg(dW))then local e2=0;while d(dW-e2)>0.5 do local cm=(dW+e2)/2;if e1(cg(cm))then dW=cm else e2=cm end end end;local e3=dJ;local e4=dW/dI;for e5=1,dI do local e6=cg(e5*e4)dV=dV+(e6+e3)*e4/2;e3=e6 end;if dW<2*dP then return dV,dW end;dJ=e3 end;local dM=dG*math.asin(dJ/dG)local E=(dG*math.asin(dL/dG)-dM)/dU;local e7=dH*math.cos(dM/dG)/dU;local aj=e7-dH*math.cos((dU*E+dM)/dG)/dU;return aj+dV,E+dW end;function aM.computeTravelTime(dJ,dK,aj)if aj==0 then return 0 end;if dK>0 then local dM=dG*math.asin(dJ/dG)local e7=dH*math.cos(dM/dG)/dK;return(dG*math.acos(dK*(e7-aj)/dH)-dM)/dK end;if dJ==0 then return-1 end;assert(dJ>0,'Acceleration and initial speed are both zero.')return aj/dJ end;return aM end;local function e8()local vec3=require('cpml.vec3')local ch=ch()local function cn(co)return type(co)=='string'end;local function cl(cm)return type(cm)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cR)assert(self.body)local aj=cR+self.body.radius;if not c0(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cO,e9)assert(self.body)assert(cl(cO)or cn(cO))assert(cl(e9))local ea=(cn(cO)or ch.isMapPosition(cO))and self.body:convertToWorldCoordinates(cO)or vec3(cO)local cg=vec3(e9)local eb=ea-self.body.center;local ec=cg:len2()local ed=eb:len()local ee=self.body.GM;local ef=((ec-ee/ed)*eb-eb:dot(cg)*cg)/ee;local c1=ee/(2*ee/ed-ec)local eg=ef:len()local dl=ef:normalize()local eh=c1*(1-eg)local ei=c1*(1+eg)local ej=eh*dl+self.body.center;local ek=eg<=1 and-ei*dl+self.body.center or nil;local el=y(c1*ee*(1-eg*eg))local em=ek and 2*math.pi*y(c1^3/ee)local en=math.acos(ef:dot(eb)/(eg*ed))if eb:dot(cg)<0 then en=-(en-2*math.pi)end;local eo=math.acos((math.cos(en)+eg)/(1+eg*math.cos(en)))local ep=eo;if ep<0 then ep=ep+2*math.pi end;local eq=ep-eg*math.sin(ep)local er=0;local es=0;local et=0;if em~=nil then er=eq/(2*math.pi/em)es=em-er;et=es+em/2;if en-math.pi>0 then es=er;et=es+em/2 end;if et>em then et=et-em end end;return{periapsis={position=ej,speed=el/eh,circularOrbitSpeed=y(ee/eh),altitude=eh-self.body.radius},apoapsis=ek and{position=ek,speed=el/ei,circularOrbitSpeed=y(ee/ei),altitude=ei-self.body.radius},currentVelocity=cg,currentPosition=ea,eccentricity=eg,period=em,eccentricAnomaly=eo,meanAnomaly=eq,timeToPeriapsis=es,timeToApoapsis=et,trueAnomaly=en}end;local function eu(ev)local dw=ch.BodyParameters(ev.systemId,ev.id,ev.radius,ev.center,ev.GM)return setmetatable({body=dw},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eu(...)end})end;local function ew()local ex={}local ey={}local ez={XS=13,S=27,M=55,L=110,XL=221}local eA={}local eB;local eC;local eD;local eE;local eF;local function eG()local function eH(eI,eJ,eK,eL,eM,eN,eO,eP)eJ,eL,eN,eP=vec3(eJ),vec3(eL),vec3(eN),vec3(eP)local eQ,eR,eS=eI*eI,eK*eK,eM*eM;local ec=eL-eJ;local eT=ec:normalize()local eU=ec:len()local eV=eN-eJ;local eW=(eV-eV:project_on(eT)):normalize()local eX,eY=eV:dot(eT),eV:dot(eW)local eZ=eX*eX+eY*eY;local e_=eT:cross(eW)local bW=(eQ-eR+eU*eU)/(2*eU)local bX=(eQ-eS+eZ-2*eX*bW)/(2*eY)local cr=eQ-bW^2-bX^2;local f0=y(cr)local f1=eJ+eT*bW+eW*bX+e_*f0;local f2=eJ+eT*bW+eW*bX-e_*f0;if d((eP-f1):len()-eO)<d((eP-f2):len()-eO)then return f1 else return f2 end end;local function f3()local function f4()local f5=core.getConstructWorldOrientationRight()local ec=core.getConstructWorldOrientationForward()local eV=core.getConstructWorldOrientationUp()local f6=library.systemResolution3(f5,ec,eV,{1,0,0})local f7=library.systemResolution3(f5,ec,eV,{0,1,0})local f8=library.systemResolution3(f5,ec,eV,{0,0,1})return function(f9)return library.systemResolution3(f6,f7,f8,f9)end end;local fa=f4()local fb=core.getConstructWorldPos()local ea=core.getElementPositionById(1)local fc={ea[1],ea[2],ea[3]}local fd=fa(fc)local fe={fb[1]-fd[1],fb[2]-fd[2],fb[3]-fd[3]}return fe end;local function ff(fg,ed,fh)local fi=fg.pts;local fj=#fi;local fk=fg.ref;if fj>3 then local fl,fm,fn,fo=fi[fj],fi[fj-1],fi[fj-2],fi[fj-3]fg.ref=fh;local ea=eH(fl[1],fl[2],fm[1],fm[2],fn[1],fn[2],fo[1],fo[2])local bW,bX,f0=ea.x,ea.y,ea.z;if bW==bW and bX==bX and f0==f0 then bW=bW+fk[1]bX=bX+fk[2]f0=f0+fk[3]local fp=vec3(bW,bX,f0)if not fg.lastPos then fg.center=fp elseif(fg.lastPos-fp):len()<2 then fg.center=fp;fg.skipCalc=true end;fg.lastPos=fp end;fg.pts={}else local fq={fh[1]-fk[1],fh[2]-fk[2],fh[3]-fk[3]}fi[fj+1]={ed,fq}end end;if bu[1]then eB=#bu[1].getConstructIds()local fr=bu[1].getData()local fs=fr:gmatch('{"constructId[^}]*}[^}]*}')if eB>0 then local fh=f3()local ft,fu=0,0;eF,eE=0,0;for cg in fs do local cJ,aj,fv=cg:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fw=ez[fv]aj=z(aj)if bu[1].hasMatchingTransponder(cJ)==1 then table.insert(ey,cJ)end;local fx=bu[1].getConstructType(cJ)if CollisionSystem then if fw>27 or fx=="static"or fx=="space"then eF=eF+1;local fy=bu[1].getConstructName(cJ)local fg=bq[cJ]if fg==nil then fw=fw+G;bq[cJ]={pts={},ref=fh,name=fy,i=0,radius=fw,skipCalc=false}fg=bq[cJ]end;if not fg.skipCalc then ff(fg,aj,fh)fu=fu+1 end;if fg.center then table.insert(eA,fg)end end;ft=ft+1;if br and ft>700 or fu>70 or(not br and ft>300 or fu>30)then coroutine.yield()ft,fu=0,0 end end end;eE=#eA;if eE>0 and bc>20 then local db,fz,fA,fB;local fC=0;local fD=aL:getPlanetarySystem(0)fB=bb:normalize()while fC<eE do coroutine.yield()local fE={table.unpack(eA,fC,math.min(fC+75,eE))}db,fz,fA=fD:castIntersections(bf,fB,nil,nil,fE,true)if db and fA then bt={db,fz,fA}break end;fC=fC+75 end;if not db then bt=nil end else bt=nil end;eA={}eC=fr:find('identifiedConstructs":%[%]')else eD=fr:find('worksInEnvironment":false')end end end;local function fF()if bu[1]then bv="Atmo"if bu[1].getData():find('worksInAtmosphere":false')then bv="Space"end end end;function ex.pickType()fF()end;function ex.assignRadar()if radar_1 and bu[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bu[1]=radar_2 end;if bu[1]==radar_2 then fF()end elseif radar_2 and bu[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bu[1]=radar_1 end;if bu[1]==radar_1 then fF()end end end;function ex.UpdateRadar()local fG=coroutine.status(UpdateRadarCoroutine)if fG=="suspended"then local cB,fH=coroutine.resume(UpdateRadarCoroutine)if fH then system.print("ERROR UPDATE RADAR: "..fH)end elseif fG=="dead"then UpdateRadarCoroutine=coroutine.create(eG)local cB,fH=coroutine.resume(UpdateRadarCoroutine)end end;function ex.GetRadarHud()local fI=ey;ey={}return eC,eD,eB,eE,eF,fI end;UpdateRadarCoroutine=coroutine.create(eG)return ex end;local function fJ()local fK=9.80665;local fL={}local fM={}local fN={}local by={}local fO=nil;local fP=nil;local fQ=nil;local fR=false;local fS={}local fT=""local fU=vec3({13771471,7435803,-128971})local fV=18000000;local fW=500000;local fX,fY=math.huge;local fZ;local function f_(g0)fX=vec3(g0):dist(fU)if fX<fV then return true,d(fX-fV)end;fY=vec3(g0):dist(vec3(planet.center))if fY<fW then fZ=true else fZ=false end;if d(fY-fW)<d(fX-fV)then return fZ,d(fY-fW)else return fZ,d(fX-fV)end end;local function g1(cg)if aD==1920 then return cg else return A(aD*cg/1920,0)end end;local function g2(cg)if aE==1080 then return cg else return A(aE*cg/1080,0)end end;local function g3()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function g4()local g5="TRAVEL"if not bj then g5="CRUISE"end;if Autopilot then g5="AUTOPILOT"end;return g5 end;local g6={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local g7=""local g8=""local g9=""local ga=1;local gb=2;local gc=3;local gd=4;local ge=5;local gf=6;local gg=""local gh=0;local gi=e(1/apTickRate)*2*hudTickRate;local gj={}local gk={}local gl={}local gm={}local gn={}local go={}local function gp(bW,gq,gr,gs,gt,gu)local gv=tankY;local gw=tankY+5;if not BarFuelDisplay then gw=gw+5 end;if m()==1 and not RemoteHud then gv=gv-50;gw=gw-50 end;if gr=="ATMO"then gg="atmofueltank"elseif gr=="SPACE"then gg="spacefueltank"else gg="rocketfueltank"end;gh=_G[gg.."_size"]if#gs>0 then for i=1,#gs do local fy=string.sub(gs[i][gb],1,12)local gx=0;for gy=1,gh do if gs[i][gb]==g(unit[gg.."_"..gy].getData()).name then gx=gy;break end end;local gz=q()if gt[i]==nil or gu[i]==nil or gz-gs[i][gf]>gi then local gA;local gB=0;if gx~=0 then gu[i]=g(unit[gg.."_"..gx].getData()).percentage;gt[i]=g(unit[gg.."_"..gx].getData()).timeLeft;if gt[i]=="n/a"then gt[i]=0 end else gB=l(gs[i][ga])-gs[i][gd]gu[i]=e(0.5+gB*100/gs[i][gc])gA=gs[i][ge]if gA<=gB then gt[i]=0 else gt[i]=e(0.5+gB/((gA-gB)/(gz-gs[i][gf])))end;gs[i][ge]=gB;gs[i][gf]=gz end end;if fy==gq then fy=f("%s %d",gr,i)end;if gx==0 then fy=fy.." *"end;local gC;if gt[i]==0 then gC=""else gC=c6(gt[i])end;if gu[i]~=nil then local gD=e(gu[i]*2.55)local gE=f("rgb(%d,%d,%d)",255-gD,gD,0)local bZ=""if gC~=""and gt[i]<120 or gu[i]<5 then bZ="red "end;local gF=f("rgb(%d,%d,%d)",r(e((255-gD)/2.55),50,100),r(e(gD/2.55),0,50),50)local gG="rgb(196,0,255)"if gr=="ATMO"then gG="rgb(0,188,255)"elseif gr=="SPACE"then gG="rgb(239,255,0)"end;local gH=false;if previous~=gG then gH=true end;previous=gG;if BarFuelDisplay then if gH then gv=gv-5;gw=gw-5 end;g8=g8 ..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gF,gG,bW,gw,gE,e(gu[i]*1.7+0.5)-2,bW+1,gw+1,bW+5,gw+14,fy,gu[i],gC)gv=gv-22;gw=gw-22 else g8=g8 ..bV(bW,gv,fy,bZ.."pdim txtfuel")g8=g8 ..bV(bW,gw,f("%d%% %s",gu[i],gC),"pdim txtfuel","fill:"..gE)gv=gv+30;gw=gw+30 end end end end;tankY=gv end;local function gI(gJ,cR)if cR<200000 and not aq or cR and aq then local gK=0;if d(be)>1 then gK=45*math.log(d(be),10)if be<0 then gK=-gK end end;gJ[#gJ+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(be),e(gK))end;return gJ end;local function gL(gM)local gN=-bd;gM=gM-gM:project_on(gN)local gO=vec3(0,0,1)gO=gO-gO:project_on(gN)local gP=gO:cross(gN)local gK=gO:angle_between(gM)*constants.rad2deg;if gM:dot(gP)<0 then gK=360-gK end;return gK end;local function gQ(gJ,centerX,centerY,gR,gS,br)local gT=circleRad;local gU=20;local gV=e(gR)if br then for i=-45,45,5 do local gW=i;gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],gW,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gJ[#gJ+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gT+gU-len,centerX,centerY+gT+gU)end;gJ[#gJ+1]=bV(centerX,centerY+gT+gU-35,gS,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY+gT+gU-25,gV.." deg","pdim txt txtmid")gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gR,centerX,centerY)gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gT+gU-20,centerX+5,centerY+gT+gU-20,centerX,centerY+gT+gU-15)gJ[#gJ+1]="</g>"end;gJ[#gJ+1]=[[<g style="clip-path: url(#headingClip);">]]local gX=gV;if br then gX=gL(b8)end;local gY=20;local gZ=e(gX)local g_=0;local h0=centerY+gT+gU+20;local h1=centerX;if gS~="YAW"then h0=g2(130)h1=g1(960)end;local h2=[[<path class="txttick line" d="]]local h3=e(gZ-(gY+10)-gZ%5+0.5)for i=h3+70,h3,-5 do local bW=h1-(-i*5+gX*5)if i%10==0 then g_=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gJ[#gJ+1]=bV(bW,h0+15,B,"txtmid bright")elseif i%5==0 then g_=5 end;if g_==10 then h2=f([[%s M %f %f v %d]],h2,bW,h0-5,g_)else h2=f([[%s M %f %f v %d]],h2,bW,h0-2.5,g_)end end;gJ[#gJ+1]=h2 ..[["/>]]gJ[#gJ+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],h1-5,h0-20,h1+5,h0-20,h1,h0-10)if br then gS="HDG"end;gJ[#gJ+1]=bV(g1(960),g2(100),gZ.."°","dim txt txtmid size14","")gJ[#gJ+1]=bV(g1(960),g2(85),gS,"dim txt txtmid size20","")gJ[#gJ+1]=[[</g>]]end;local function h4(gJ,h5,gR,centerX,centerY,br,h6,e6)local gT=circleRad;local h7=e(gT*3/5)if gT>0 then local h8=e(h5)local len=0;local h2=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gR,centerX,centerY)if not aq then h2=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gJ[#gJ+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gT-1,centerX,centerY)gJ[#gJ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(h8-30-h8%5+0.5),e(h8+30+h8%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bX=centerY+-i*5+h5*5;if len==30 then h2=f([[%s M %d %f h %d]],h2,centerX-h7-len,bX,len)if aq then gJ[#gJ+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gR,centerX,centerY,centerX-h7+10,bX+4,i)gJ[#gJ+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gR,centerX,centerY,centerX+h7-10,bX+4,i)if i==0 or i==180 or i==-180 then gJ[#gJ+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gR,centerX,centerY,centerX-h7+20,bX,h7*2-40)end else gJ[#gJ+1]=bV(centerX-h7+10,bX,i,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX+h7-10,bX,i,"pdim txt txtmid")end;h2=f([[%s M %d %f h %d]],h2,centerX+h7,bX,len)else h2=f([[%s M %d %f h %d]],h2,centerX-h7-len,bX,len)h2=f([[%s M %d %f h %d]],h2,centerX+h7,bX,len)end end;gJ[#gJ+1]=h2 ..[["/>]]local h9="PITCH"if not br then h9="REL PITCH"end;if h5>90 and not aq then h5=90-(h5-90)elseif h5<-90 and not aq then h5=-90-(h5+90)end;if gT>200 then if aq then if e6>Q then gJ[#gJ+1]=bV(centerX,centerY-15,"Yaw","pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY+20,h6,"pdim txt txtmid")end;gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gR,centerX,centerY)else gJ[#gJ+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-h7+25,centerY-5,centerX-h7+20,centerY,centerX-h7+25,centerY+5,centerX-h7+50,centerY+4,h8)gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+h7-25,centerY-5,centerX+h7-20,centerY,centerX+h7-25,centerY+5,centerX+h7-30,centerY+4,h8)gJ[#gJ+1]="</g>"end;local ha=e(gT/3)gJ[#gJ+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-ha,centerY,gT-ha)if not aq and br then gJ[#gJ+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gR,centerX,centerY,centerX-h7+10,centerY,h7*2-20)end;gJ[#gJ+1]="</g>"if gT<200 then if aq and e6>Q then gJ[#gJ+1]=bV(centerX,centerY-gT,h9,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY-gT+10,h8,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY-15,"Yaw","pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY+20,h6,"pdim txt txtmid")else gJ[#gJ+1]=bV(centerX,centerY-gT,h9,"pdim txt txtmid")gJ[#gJ+1]=bV(centerX,centerY-gT+15,h8,"pdim txt txtmid")end end end end;local function hb(gJ,cR,br)local hc=altMeterX;local hd=altMeterY;local he=78;local hf=19;local hg=ao;if ao~=-1 then gJ[#gJ+1]=bV(hc+he,hd+hf+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if br and(cR<200000 and not aq or cR and aq)then table.insert(gJ,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hc-1,hd-4,he+2,hf+6,hc+1,hd-1,he-4,hf))local fj=0;local hh=1;local hi=0;local hj=cR<0;local hk=cR<planet.surfaceMaxAltitude;local hl=9;if hj then hl=0 end;local cR=d(cR)while fj<6 do local hm=11;local hn=16;local ho=9;local hp=14;local bZ="altsm"if fj>2 then hn=hn+3;hm=hm+2;hp=hp+2;ho=ho-6;bZ="altbig"end;if hj then bZ=bZ.." red"elseif hk then bZ=bZ.." orange"end;local hq=cR/hh%10;local hr=e(hq)local hs=e((hr+1)%10)local ht=hi;if fj==0 then ht=hq-hr;if hj then ht=1-ht end end;if hj and(fj==0 or hi~=0)then local hu=hs;hs=hr;hr=hu end;local hv=hn*(ht-1)local hw=hv+hn;local bW=hc+ho+(6-fj)*hm;local bX=hd+hp;gJ[#gJ+1]=bV(bW,bX+hv,hs,bZ)gJ[#gJ+1]=bV(bW,bX+hw,hr,bZ)fj=fj+1;hh=hh*10;if hr==hl then hi=ht else hi=0 end end;table.insert(gJ,[[</g></g>]])end end;local function hx(e9)local hy=-math.deg(n(e9.y,e9.z))+180;hy=hy-90;if hy<0 then hy=360+hy end;if hy>180 then hy=-180+hy-180 end;return-hy end;local function hz(e9)local gX=math.deg(n(e9.y,e9.x))-90;if gX<-180 then gX=360+gX end;return gX end;local function hA(gJ,e9,e6,centerX,centerY)if e6>5 and not aq or e6>Q then local gT=circleRad;local hB=20;local hC=20;local hD=hx(e9)local hE=hz(e9)local hF=14;local hG=hF/2;local hH=-hE/hC*gT;local hI=hD/hB*gT;local bW=centerX+hH;local bX=centerY+hI;local aj=y(hH^2+hI^2)local hJ=[[<circle
                            cx="]]..bW..[["
                            cy="]]..bX..[["
                            r="]]..hG/hF..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bW..[["
                            cy="]]..bX..[["
                            r="]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bW-hF..[[,]]..bX..[[ h ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bW+hG..[[,]]..bX..[[ h ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bW..[[,]]..bX-hF..[[ v ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<gT then gJ[#gJ+1]=hJ else local gK=n(hI,hH)local hK=4;local hL=centerX+gT*math.cos(gK)local hM=centerY+gT*math.sin(gK)gJ[#gJ+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gK*180/math.pi,hL,hM,hL-hK,hM-hK/2,hK*2,hK,hL+hK,hM-hK,hK,hK,-hK,hK)end;if not aq then local hN=vec3(e9)hD=hx(-hN)hE=hz(-hN)hH=-hE/hC*gT;hI=hD/hB*gT;bW=centerX+hH;bX=centerY+hI;aj=y(hH^2+hI^2)if aj<gT then local hO=[[<circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bW..[[,]]..bX-hF..[[ v ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bW..[[,]]..bX..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bW..[[,]]..bX..[[)" />
                                <path
                                    d="M ]]..bW-hG..[[,]]..bX..[[ h ]]..hF..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bW..[[,]]..bX..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bW..[[,]]..bX..[[)"/>]]gJ[#gJ+1]=hO end end end end;local function hP(gJ,g5,hQ,hR)hQ=e(hQ+0.5)local gv=throtPosY+10;local gw=throtPosY+20;if m()==1 and not RemoteHud then gv=55;gw=65 end;local hS="CRUISE"local unit="km/h"local cB=hR;if g5=="TRAVEL"or g5=="AUTOPILOT"then hS="THROT"unit="%"cB=hQ;local hT="dim"if hQ<0 then hT="red"end;gJ[#gJ+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hT,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(hQ),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gJ[#gJ+1]=bV(throtPosX+10,gv,hS,"pbright txtstart")gJ[#gJ+1]=bV(throtPosX+10,gw,f("%.0f %s",cB,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bj and M then hQ=e(N*100+0.5)local hT="red"if hQ<0 then hT="red"end;gJ[#gJ+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hT,1-d(hQ),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gJ[#gJ+1]=bV(throtPosX+10,gv+40,"LIMIT","pbright txtstart")gJ[#gJ+1]=bV(throtPosX+10,gw+40,hQ.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gJ[#gJ+1]=bV(throtPosX+10,gv-40,"LIMIT: "..aZ.." km/h","dim txtstart")elseif not aq and Autopilot then gJ[#gJ+1]=bV(throtPosX+10,gv-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hU(gJ,hV)local hW=throtPosY-10;local hX=throtPosX+10;gJ[#gJ+1]=bV(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then hW=75 end;gJ[#gJ+1]=bV(hX,hW,e(hV).." km/h","pbright txtbig txtstart")end;local function hY(gJ)gJ[#gJ+1]=bV(g1(1900),g2(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gJ[#gJ+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gJ[#gJ+1]=bV(g1(960),g2(550),"Warning: Invalid Control Scheme Detected","warnings")gJ[#gJ+1]=bV(g1(960),g2(600),"Keyboard Scheme must be selected","warnings")gJ[#gJ+1]=bV(g1(960),g2(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hZ=g1(960)local h_=g2(860)local i0=g2(880)local i1=g2(900)local i2=g2(960)local i3=g2(200)local i4=g2(250)local i5=g2(960)if m()==1 and not RemoteHud then h_=g2(135)i0=g2(155)i1=g2(175)i3=g2(115)i4=g2(95)end;local i6="#222222"local i7="white"local i8="dimmer"local i9="pbright"local ia="#110000"local ib=i6;local ic=i8;if BrakeIsOn then gJ[#gJ+1]=bV(hZ,h_,"Brake Engaged","warnings")ia="#440000"ib=i7;ic=i9 elseif L>0 then gJ[#gJ+1]=bV(hZ,h_,"Auto-Brake Engaged","warnings","opacity:"..L)end;local id="#110000"local ie=i6;local ig=i8;if aq and aX and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bh and not VertTakeOff and not AutoTakeoff then gJ[#gJ+1]=bV(hZ,i3+50,"** STALL WARNING **","warnings")id="#ff0000"ie=i7;ig=i9;bI("stall","SW",2)end end;if bp then gJ[#gJ+1]=bV(hZ,i3+90,"Flight Assist in Progress","warnings")end;if ax then gJ[#gJ+1]=bV(hZ,i5,"Gyro Enabled","warnings")end;local ih="#111100"local ii=i6;local ij=i8;if GearExtended then ih="#775500"ii=i7;ij=i9;if S then gJ[#gJ+1]=bV(hZ,i0,"Gear Extended","warn")else gJ[#gJ+1]=bV(hZ,i0,"Landed (G: Takeoff)","warnings")end;local ik=c3(a:getTargetGroundAltitude())gJ[#gJ+1]=bV(hZ,i1,"Hover Height: "..ik,"warn")end;local il="#000011"local im=i6;local io=i8;if a7 then il="#0000DD"im=i7;io=i9;gJ[#gJ+1]=bV(hZ,i2+20,"ROCKET BOOST ENABLED","warn")end;local ip="#001100"local iq=i6;local ir=i8;if antigrav and not ExternalAGG and bh and AntigravTargetAltitude~=nil then ip="#00DD00"iq=i7;ir=i9;if d(as-antigrav.getBaseAltitude())<501 then gJ[#gJ+1]=bV(hZ,i3+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gJ[#gJ+1]=bV(hZ,i3+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gJ[#gJ+1]=bV(hZ,i3+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gJ[#gJ+1]=bV(hZ,i3+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gJ[#gJ+1]=bV(hZ,i3+20,"Follow Mode Engaged","warn")elseif Reentry or an then gJ[#gJ+1]=bV(hZ,i3+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ik=c3(HoldAltitude,2)if VertTakeOff then if bh then ik=c3(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gJ[#gJ+1]=bV(hZ,i3,"VTO to "..ik,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gJ[#gJ+1]=bV(hZ,i3,"Takeoff to "..AutopilotTargetName,"warn")else gJ[#gJ+1]=bV(hZ,i3,"Takeoff to "..ik,"warn")end;if BrakeIsOn and not VertTakeOff then gJ[#gJ+1]=bV(hZ,i3+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gJ[#gJ+1]=bV(hZ,i3,"Altitude Hold: "..ik,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gJ[#gJ+1]=bV(hZ,i3+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gJ[#gJ+1]=bV(hZ,i3+20,"Aligning trajectory","warn")elseif ar<0.05 then gJ[#gJ+1]=bV(hZ,i3+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b0~=nil then gJ[#gJ+1]=bV(hZ,i3,b0,"warn")end end;if BrakeLanding then if StrongBrakes then gJ[#gJ+1]=bV(hZ,i3,"Brake-Landing","warnings")else gJ[#gJ+1]=bV(hZ,i3,"Coast-Landing","warnings")end end;if ProgradeIsOn then gJ[#gJ+1]=bV(hZ,i3,"Prograde Alignment","crit")end;if RetrogradeIsOn then gJ[#gJ+1]=bV(hZ,i3,"Retrograde Alignment","crit")end;local is="#110000"local it=i6;local iu=i8;if bs then is="#FF0000"it=i7;iu=i9;local type;if string.find(bs,"COLLISION")then type="warnings"else type="crit"end;gJ[#gJ+1]=bV(hZ,i4+20,bs,type)elseif ar==0 then local iv,iw=aR.checkLOS(bb:normalize())if iw~=nil then iu=i9;is="#FF0000"it=i7;local ik=c3(iw)local travelTime=aM.computeTravelTime(bc,0,iw)local ix="Collision"if iv.noAtmosphericDensityAltitude>0 then ix="Atmosphere"end;gJ[#gJ+1]=bV(hZ,i4+20,iv.name.." "..ix.." "..c6(travelTime).." In "..ik,"crit")end end;if VectorToTarget and not IntoOrbit then gJ[#gJ+1]=bV(hZ,i3+35,VectorStatus,"warn")end;local iy="#111100"local iz=i6;local iA=i8;if bz and#bz>1 then iy="#DDDD00"iz=i7;iA=i9 end;local iB=g1;local iC=g2;local i8="topButton"local iD="topButtonActive"local iE=i8;if Autopilot or VectorToTarget or am or IntoOrbit then iE=iD end;local iF=i8;if ProgradeIsOn then iF=iD end;local iG=i8;if BrakeLanding or GearExtended then iG=iD end;local iH=i8;if AltitudeHold or VectorToTarget then iH=iD end;local iI=i8;if RetrogradeIsOn then iI=iD end;local iJ=i8;if IntoOrbit or b3 and Autopilot then iJ=iD end;local iK=iC(30)gJ[#gJ+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iE,iB(960),iC(54),iC(-53),iB(-120),iB(25),iC(50))gJ[#gJ+1]=bV(iB(910),iK,"AUTOPILOT")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iF,iB(865),iC(51),iB(-25),iC(-50),iB(-110),iB(25),iC(46))gJ[#gJ+1]=bV(iB(800),iK,"PROGRADE")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iG,iB(755),iC(47),iB(-25),iC(-46),iB(-98),iB(44),iC(44))gJ[#gJ+1]=bV(iB(700),iK,"LAND")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iH,iB(960),iC(54),iC(-53),iB(120),iB(-25),iC(50))gJ[#gJ+1]=bV(iB(1010),iK,"ALT HOLD")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iI,iB(1055),iC(51),iB(25),iC(-50),iB(110),iB(-25),iC(46))gJ[#gJ+1]=bV(iB(1122),iK,"RETROGRADE")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iJ,iB(1165),iC(47),iB(25),iC(-46),iB(98),iB(-44),iC(44))gJ[#gJ+1]=bV(iB(1220),iK,"ORBIT")gJ[#gJ+1]=[[
                                </g>
                            </g>]]gJ[#gJ+1]="</g>"return gJ end;local function iL(e6)return e(A(e6*3.6,0)+0.5).." km/h"end;local function iM(gJ)local bW=OrbitMapX+10;local bX=OrbitMapY+20;local iN={}local iO={"Alt-4: AutoTakeoff to Target"}local iP={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iQ={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iR={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iN,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then bL(iN,iO)if ac and planet and ac.name==planet.name then table.insert(iN,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bh then table.insert(iN,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iN,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iN,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iN,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iN,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iN,"G: Takeoff to hover height, raise gear")else table.insert(iN,"G: Lowergear and Land")end else bL(iN,iP)table.insert(iN,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iN,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bL(iN,iQ)if shield_1 then table.insert(iN,"Alt-Shift-5: Toggle shield off and on")table.insert(iN,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iN,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iN,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iN,"Alt-Spacebar/C will raise/lower target height")table.insert(iN,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iN,"LALT+Mousewheel will lower/raise speed limit")end;bL(iN,iR)for i=1,#iN do bX=bX+12;gJ[#gJ+1]=bV(bW,bX,iN[i],"pdim txtbig txtstart")end end;local function iS(gJ)local iT=OrbitMapX;local iU=OrbitMapY;local iV=OrbitMapSize;local iW=4;local iX=15;local bW=0;local bX=0;local iY,iZ,i_,j0;local j1;local function j2(type)local j3,E,e6,j4,bZ,j5;if type=="Periapsis"then j3=j1.periapsis.altitude;E=j1.timeToPeriapsis;e6=j1.periapsis.speed;bZ="txtend"j4=12;j5=math.min(bW,iT+iV-planet.radius/i_-iW*2)else j3=j1.apoapsis.altitude;E=j1.timeToApoapsis;e6=j1.apoapsis.speed;j4=-12;bZ="txtstart"j5=bW end;if bc<1 then E=0 end;gJ[#gJ+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j5+j4,bX-5,bW,bX-5)gJ[#gJ+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j5-j4*4,bX+2,bW,bX+2)gJ[#gJ+1]=bV(j5,bX,type,bZ)bW=j5-j4*2;bX=bX+iX;local ik=c3(j3)gJ[#gJ+1]=bV(bW,bX,ik,bZ)bX=bX+iX;gJ[#gJ+1]=bV(bW,bX,c6(E),bZ)bX=bX+iX;gJ[#gJ+1]=bV(bW,bX,iL(e6),bZ)end;local j6=iV*1.5;if SelectedTab=="INFO"then j6=25*7 end;if SelectedTab~="HIDE"then gJ[#gJ+1]=[[<g class="pbright txtorb txtmid">]]gJ[#gJ+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',iV*2,j6,iT,iU)gJ[#gJ+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],iT*2,j4,iR,iS)end;local j5=iT*1.5;local j6=iT*2;local j7=j5/2;local j8=iT;local j9=iR+j8;local ja=iS+j7;local jb=iR+j6;local jc=iS+j5;if SelectedTab=="ORBIT"then iS=iS+iU;iW=iT/2;iZ=0;i_={}i_.periapsis={}i_.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then i_.periapsis.altitude=orbit.periapsis.altitude;i_.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then i_.apoapsis.altitude=orbit.apoapsis.altitude;i_.apoapsis.speed=orbit.apoapsis.speed end;i_.period=orbit.period;i_.eccentricity=orbit.eccentricity;i_.timeToApoapsis=orbit.timeToApoapsis;i_.timeToPeriapsis=orbit.timeToPeriapsis;i_.eccentricAnomaly=orbit.eccentricAnomaly;i_.trueAnomaly=orbit.trueAnomaly end;if i_.periapsis==nil then i_.periapsis={}i_.periapsis.altitude=-planet.radius;i_.periapsis.speed=MaxGameVelocity end;if i_.eccentricity==nil then i_.eccentricity=1 end;if i_.apoapsis==nil then i_.apoapsis={}i_.apoapsis.altitude=as;i_.apoapsis.speed=0 end;if bc<1 then i_.apoapsis.altitude=as;i_.apoapsis.speed=0 end;if i_.apoapsis.altitude then iY=(i_.apoapsis.altitude+i_.periapsis.altitude+planet.radius*2)/(iW*2)iX=(planet.radius+i_.apoapsis.altitude)/iY*(1-i_.eccentricity)iZ=iW-i_.periapsis.altitude/iY-planet.radius/iY;local jd=math.pi;if i_.period~=nil and i_.period>0 and i_.timeToApoapsis~=nil then jd=i_.eccentricAnomaly;if i_.timeToPeriapsis<i_.timeToApoapsis then jd=2*math.pi-jd end end;if bc<1 or jd~=jd then jd=math.pi end;local je=-iW*math.cos(jd)+iR+j8+iU;local jf=iX*math.sin(jd)+iS+j7+iU;local jg=""gH[#gH+1]='<g clip-path="url(#orbitRect)">'gH[#gH+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jg,iR+iT+iU,iS+iT*1.5/2+iU,iW,iX)if iX<1 then gH[#gH+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iR+iT+iU-iZ,iS+iT*1.5/2+iU,je,jf)end;gH[#gH+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iR+iT+iU-iZ,iS+iT*1.5/2+iU,(planet.radius+planet.noAtmosphericDensityAltitude)/iY)gH[#gH+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iR+iT+iU-iZ,iS+iT*1.5/2+iU,(planet.radius+planet.noAtmosphericDensityAltitude)/iY)gH[#gH+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iR+iT+iU,iS+iT*1.5/2+iU,iW,iX)gH[#gH+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iR+iT+iU-iZ,iS+iT*1.5/2+iU,planet.radius/iY)gH[#gH+1]='</g>'local jh=math.floor(planet.radius/iY+0.5)local ji=g4.Generic_Moon;if g4[planet.name]then ji=g4[planet.name]end;bW=iR+iT+iU*4+iW;bX=iS+iT*1.5/2+5+iU;if i_.apoapsis~=nil and i_.apoapsis.speed<MaxGameVelocity then j0("Apoapsis")end;bX=iS+iT*1.5/2+5+iU;bW=iR+iT-iU*2-iW;if i_.periapsis~=nil and i_.periapsis.speed<MaxGameVelocity and i_.periapsis.altitude>0 then j0("Periapsis")end;gH[#gH+1]=bV(iR+iT+iU,iS+20+iU,planet.name,"txtorbbig")gH[#gH+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',je,jf)gH[#gH+1]=[[</g>]]return gH else gH[#gH+1]='<g clip-path="url(#orbitRect)">'local jj=""local jk=1.2*(maxAtlasX-minAtlasX)/(iT*2)local jl=1.4*(maxAtlasY-minAtlasY)/(iT*1.5)for cf,cg in pairs(b[0])do if cg.center then local bW=iR+iT+cg.center.x/jk;local bX=iS+iT*1.5/2+cg.center.y/jl;jj=jj..'<circle cx="'..bW..'" cy="'..bX..'" r="'..cg.radius/jk*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(cg.name,"Moon")and not string.match(cg.name,"Sanctuary")and not string.match(cg.name,"Space")then jj=jj.."<text x='"..bW.."' y='"..bX+cg.radius/jk*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..cg.name.."</text>"end end end;local e8=vec3(core.getConstructWorldPos())local bW=iR+iT+e8.x/jk;local bX=iS+iT*1.5/2+e8.y/jl;jj=jj..'<circle cx="'..bW..'" cy="'..bX..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jj=jj.."<text x='"..bW.."' y='"..bX-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fM=jk;fN=jl;local jm=e8+bb*1000000;local jn=iR+iT+jm.x/jk;local gu=iS+iT*1.5/2+jm.y/jl;jj=jj..'<line x1="'..bW..'" y1="'..bX..'" x2="'..jn..'" y2="'..gu..'" stroke="purple" stroke-width="1"/>'gH[#gH+1]=jj;gH[#gH+1]='</g>'end elseif SelectedTab=="INFO"then gH=aP.DrawOdometer(gH,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then gH=iK(gH)elseif SelectedTab=="SCOPE"then gH[#gH+1]='<g clip-path="url(#orbitRect)">'local jo=bC;if ar>0 then table.sort(bB,function(c1,c2)return(c1.center.x-bf.x)^2+(c1.center.y-bf.y)^2+(c1.center.z-bf.z)^2<(c2.center.x-bf.x)^2+(c2.center.y-bf.y)^2+(c2.center.z-bf.z)^2 end)end;local eB={}local jp={}local jq=120;local jr=nil;local js=nil;for i,cg in ipairs(bB)do local eA=cg.center-bf;local jt=eA:len()local ju=eA:normalize()local jv=eA:cross(b8):normalize()local jw=math.acos(jv:dot(b9))if jv:cross(b9):dot(b8)<0 then jw=-jw end;local jx=eA:project_on_plane(b8):len()local jy=eA:project_on_plane(b9)local jz=eA:project_on_plane(b7)local jA=math.sin(jw)*math.asin(jx/jt)*constants.rad2deg;local jB=math.cos(jw)*math.asin(jx/jt)*constants.rad2deg;if ju:dot(b8)<0 then jB=90*math.cos(jw)+90*math.cos(jw)-jB;jA=90*math.sin(jw)+90*math.sin(jw)-jA end;local bW=j9+jA/jo*j5;local bX=ja+jB/jo*j5;local jC=(bW-j9)*(bW-j9)+(bX-ja)*(bX-ja)local jD=math.asin((cg.radius+cg.surfaceMaxAltitude)/jt)*constants.rad2deg;local ft=jD/jo*j5;local jE=math.asin(cg.atmosphereRadius/jt)*constants.rad2deg;local jF=jE/jo*j5;local aj=c3(jt,1)local jG=cg.name;local jH=false;if bX>iS then if bX>jc then if bX-jF<=jc then jH=true end else jH=true end else if bX+jF>=iS then jH=true end end;local jI=false;local jJ=bW;if cg.systemId==0 then jJ=bW+jq else jJ=bW-jq end;if jJ+jq>iR then if jJ+jq>jb then if jJ-jF-jq<=jb then jI=true end else jI=true end else if jJ+jF+jq>=iR then jI=true end end;local jK={}jK.x=bW;jK.y=bX;jK.planet=cg;jK.atmoSize=jF;if not jr or jC<jr then jr=jC;js=jK end;if jI and jH then local jL=math.max(jF,5)if jC<jL*jL then jG=jG.." - "..aj end;jK.size=ft;jK.i=i;jK.displayString=jG;jK.distance=aj;jK.visible=true;jp[#jp+1]=jK else jK.visible=false end end;local jM=false;table.sort(jp,function(c1,c2)return c1.y<c2.y end)for cf,eb in ipairs(jp)do local cg,ft,i,jF,bW,bX,jG,aj=eb.planet,eb.size,eb.i,eb.atmoSize,eb.x,eb.y,eb.displayString,eb.distance;local j3,jN,jO,jP;local jQ=15;local bZ="pdim"if cg.systemId~=0 then jO=f_(string.len(jG)*5)jQ=-(15+jO)jP=g0(10)bZ="pdimfill"else jO=f_(string.len(jG)*9)jP=g0(15)end;if ft*2>jO then j3=r(bW,iR+jO/2,jb-jO/2)jN=r(bX,iS+jP,jc-5)j3=r(j3,bW-ft+jO/2,bW+ft-jO/2)jN=r(jN,bX-ft+jP,bX+ft)else j3=bW+jQ;jN=bX end;for jR,eb in pairs(eB)do local jS=eb.textPositions;local jT=jS.y-jN;if jR~=i and d(jT)<jS.height and jS.x+jS.width>j3 and jS.x<j3+jO then if ft>jO then jN=r(jN+jP,iS+15,jc-5)else jN=jS.y+jS.height+1 end end end;local jU=jG~=cg.name or j3<=j9 and j3+jO>=j9 and jN-jP<=ja and jN>=ja;eb.hovered=jU;local jV=1;if jU then jV=2;if ft*2<jO then jV=10 end;if jG==cg.name then jG=jG.." - "..aj end;bZ="pbright"if cg.systemId~=0 then jO=f_(string.len(jG)*5)jQ=-(15+jO)else jO=f_(string.len(jG)*7)end;if ft*2>jO then j3=r(bW,iR+jO/2,jb-jO/2)j3=r(j3,bW-ft+jO/2,bW+ft-jO/2)else j3=bW+jQ end end;eB[i]={}eB[i].textPositions={}eB[i].textPositions.y=jN;eB[i].textPositions.x=j3;eB[i].textPositions.width=jO;eB[i].textPositions.height=jP;eB[i].output=""if ft*2>jO then bZ=bZ.." txtmid"else bZ=bZ.." txtstart"end;if jF-ft>2 then eB[i].output=f('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',bW,bX,jF,az,0.1*jV)end;eB[i].output=eB[i].output..f('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',bW,bX,ft,az,0.2*jV)if cg.systemId==0 then eB[i].output=eB[i].output..f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j3,jN,ay,bZ,jG)if ft*2<=jO then eB[i].output=eB[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j3+jO,jN+2,j3,jN+2,bW,bX)end else eB[i].output=eB[i].output..f([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j3,jN,az,bZ,jG)if ft*2<=jO then eB[i].output=eB[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j3,jN+2,j3+jO,jN+2,bW,bX)end end end;for cf=#bB,1,-1 do if eB[cf]then gH[#gH+1]=eB[cf].output end end;if js~=nil and bC<90 and not js.hovered then local jW=js.planet.atmosphereRadius/js.atmoSize;local jX=y(jr)*jW;local jY=c3(jX,1)local jO=f_(math.max(string.len(jY)*7,string.len(js.planet.name)*7))local jP=g0(12)local j3=r(js.x+(j9-js.x)/2,iR+jO/2,jb-jO/2)local jN=r(js.y+(ja-js.y)/2,iS+jP*2,jc-5)gH[#gH+1]=f("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",js.x,js.y,j9,ja)gH[#gH+1]=f([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j3,jN,"white",jY)if not js.visible then gH[#gH+1]=f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j3,jN-jP,"white",js.planet.name)end end;if bc>1 then local eA=bb;local ju=eA:normalize()local jx=eA:project_on_plane(b8):len()local jy=eA:project_on_plane(b9)local jz=eA:project_on_plane(b7)local jv=eA:cross(b8):normalize()local jw=math.acos(jv:dot(b9))if jv:cross(b9):dot(b8)<0 then jw=-jw end;local jA=math.sin(jw)*math.asin(jx/eA:len())*constants.rad2deg;local jB=math.cos(jw)*math.asin(jx/eA:len())*constants.rad2deg;if ju:dot(b8)<0 then jB=90*math.cos(jw)+90*math.cos(jw)-jB;jA=90*math.sin(jw)+90*math.sin(jw)-jA end;local bW=j9+jA/jo*j5;local bX=ja+jB/jo*j5;local hD=14;local hE=hD/2;local hH=[[<circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hG/hF..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..bW..[["
                                    cy="]]..bX..[["
                                    r="]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bW-hF..[[,]]..bX..[[ h ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bW+hG..[[,]]..bX..[[ h ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bW..[[,]]..bX-hD..[[ v ]]..hE..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]gH[#gH+1]=hH end;gH[#gH+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",j9,ja-10,j9,ja+10)gH[#gH+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",j9-10,ja,j9+10,ja)gH[#gH+1]='</g>'else return gH end end;local function jZ(j_,k0)local k1;local k2=(k0-j_):normalize()local e9=(bf-j_):dot(k2)/k2:dot(k2)if e9<=0.then return(bf-j_):len()elseif e9>=(k0-j_):len()then return(bf-k0):len()end;local k3=j_+e9*k2;k1=(k3-bf):len()return k1 end;local function k4()local k1;local k5=nil;local k6=nil;local k7=nil;for cf,k8 in pairs(b[0])do if k8.hasAtmosphere then local aj=jZ(planet.center,k8.center)if k5==nil or aj<k5 then k6=k8;k5=aj;k7=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dv=jZ(ac.center,k8.center)if dv<k5 then k6=k8;k5=dv;k7=ac end end end end;local k9=f_(1770)local ka=g0(330)if k5 then local kb="txttick "local kc=500000;if k5<k6.radius+kc or k5<k7.radius+kc then if bn then kb="txttick red "else kb="txttick orange "end end;k1=c3(k5,2)fR=bV(k9,ka,"Pipe ("..k7.name.."--"..k6.name.."): "..k1,kb.."pbright txtmid")end end;local function kd(bW,bX,ke,kf,hQ)local kg={x=bW,y=bX,width=ke,height=kf,label=hQ}by[hQ]=kg;return kg end;local function kh(ki,kj,ke,kf,bW,bX,kk,kl,km,kn,bZ)local kg={enableName=ki,disableName=kj,width=ke,height=kf,x=bW,y=bX,toggleVar=kk,toggleFunction=kl,drawCondition=km,hovered=false,class=bZ}if kn then table.insert(fL,kg)else table.insert(fK,kg)end;return kg end;local function ko(kp)if not fP then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif kp=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif kp=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif kp=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fQ=bO(kp)showHud=false else fQ={}showHud=true end end;local function kq()fP=not fP;if fP then fJ=fL;a2="Hold SHIFT to see Settings"bD=showHud else fJ=fK;a2="Hold SHIFT to see Control Buttons"ko()showHud=bD end end;local function kr()local function ks(cg)_G[cg]=not _G[cg]if _G[cg]then a2=cg.." set to true"else a2=cg.." set to false"end;if cg=="showHud"then bD=_G[cg]elseif cg=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local kt=50;local ku=340;local bW=500;local bX=aE/2-400;local kv=0;for cf,cg in pairs(bO("boolean"))do if type(_G[cg])=="boolean"then kh(cg,cg,ku,kt,bW,bX,function()return _G[cg]end,function()ks(cg)end,function()return true end,true)bX=bX+kt+20;if kv==9 then bW=bW+ku+20;bX=aE/2-400;kv=0 else kv=kv+1 end end end;kh("Control View","Control View",ku,kt,10,aE/2-500,function()return true end,kq,function()return true end,true)kh("View Handling Settings",'Hide Handling Settings',ku,kt,10,aE/2-(500-kt),function()return showHandlingVariables end,function()ko("handling")end,function()return true end,true)kh("View Hud Settings",'Hide Hud Settings',ku,kt,10,aE/2-(500-kt*2),function()return showHudVariables end,function()ko("hud")end,function()return true end,true)kh("View Physics Settings",'Hide Physics Settings',ku,kt,10,aE/2-(500-kt*3),function()return showPhysicsVariables end,function()ko("physics")end,function()return true end,true)end;local function kw()local function kx()local position=bf;local fw=planet.name..". "..#SavedLocations;if bu[1]then local cJ,_=bu[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cJ~=nil and cJ~=""then fw=fw.." "..bu[1].getConstructName(cJ)end end;return aQ.AddNewLocation(fw,position,false,true)end;local function ky()TurnBurn=not TurnBurn end;local function kz(kA)if kA==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kB()aQ.UpdatePosition()end;local function kC()aQ.ClearCurrentPosition()end;local function kD(fh)local fw=AutopilotTargetName;if fh~=nil and type(fh)=="number"then if fh==0 then return"None"end;fw=bm[fh].name end;if fw==nil then fw=CustomTarget.name end;if fw==nil then fw="None"end;return fw end;local function kE(fh)return"Engage Autopilot: "..kD(fh)end;local function kF(fh)return"Disable Autopilot: "..kD(fh)end;local function kG()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bI("folOn","F")else bI("folOff","F")BrakeIsOn=true;aV=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local kt=50;local ku=260;local kH=f_(30)local kI=OrbitMapX+OrbitMapSize*2+2;local kJ=OrbitMapY+1;kh("+","+",kH,kH,kI,kJ+kH+1,function()return false end,function()bC=bC/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")kh("-","-",kH,kH,kI,kJ,function()return false end,function()bC=math.min(bC*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")kh("0","0",kH,kH,kI,kJ+kH*2+2,function()return false end,function()bC=90 end,function()return SelectedTab=="SCOPE"and bC~=90 end,nil,"ZoomButton")local kK=kh("Enable Brake Toggle","Disable Brake Toggle",ku,kt,aD/2-ku/2,aE/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)kh("Align Prograde","Disable Prograde",ku,kt,aD/2-ku/2-50-kK.width,aE/2-kt+380,function()return ProgradeIsOn end,function()kz(1)end)kh("Align Retrograde","Disable Retrograde",ku,kt,aD/2-ku/2+kK.width+50,aE/2-kt+380,function()return RetrogradeIsOn end,kz,function()return ar==0 end)apbutton=kh(kE,kF,600,60,aD/2-600/2,aE/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function kL(kM)local fh=bx+kM;if fh>#bm then fh=fh-#bm-1 end;if fh<0 then fh=#bm+fh end;return fh end;apExtraButtons={}for i=0,10 do local button=kh(function(c2)local fh=kL(c2.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..kD(fh)end;return kE(fh)end,function(c2)local fh=kL(c2.apExtraIndex)return kF(fh)end,600,60,aD/2-600/2,aE/2-60/2-330+60*i,function(c2)local fh=kL(c2.apExtraIndex)return fh==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(c2)local fh=kL(c2.apExtraIndex)local kN=AutopilotTargetIndex==fh;AutopilotTargetIndex=fh;aQ.UpdateAutopilotTarget()aR.ToggleAutopilot()if not kN and not(Autopilot or VectorToTarget or am or IntoOrbit)then aR.ToggleAutopilot()end end,function()return bw end)button.apExtraIndex=i;apExtraButtons[i]=button end;kh("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kx,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)kh("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kB,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kh("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kC,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kt=60;ku=300;local bW=0;local bX=aE/2-150;kh("View Settings","View Settings",ku,kt,bW,bX,function()return true end,kq)bX=bX+kt+20;kh("Enable Turn and Burn","Disable Turn and Burn",ku,kt,bW,bX,function()return TurnBurn end,ky)bW=10;bX=aE/2-300;kh("Horizontal Takeoff Mode","Vertical Takeoff Mode",ku,kt,bW+ku+20,bX,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bg end)bX=bX+kt+20;kh("Engage Orbiting","Cancel Orbiting",ku,kt,bW+ku+20,bX,function()return IntoOrbit end,aR.ToggleIntoOrbit,function()return ar==0 and br end)bX=aE/2-150;kh("Glide Re-Entry","Cancel Glide Re-Entry",ku,kt,bW+ku+20,bX,function()return Reentry end,function()al=1;kz(1)end,function()return planet.hasAtmosphere and not aq end)bX=bX+kt+20;kh("Parachute Re-Entry","Cancel Parachute Re-Entry",ku,kt,bW+ku+20,bX,function()return Reentry end,aR.BeginReentry,function()return planet.hasAtmosphere and not aq end)bX=bX+kt+20;kh("Engage Follow Mode","Disable Follow Mode",ku,kt,bW,bX,function()return a0 end,kG,function()return m()==1 end)kh("Enable Repair Arrows","Disable Repair Arrows",ku,kt,bW+ku+20,bX,function()return aJ end,function()aJ=not aJ;if aJ then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)bX=bX+kt+20;if not ExternalAGG then kh("Enable AGG","Disable AGG",ku,kt,bW,bX,function()return bh end,aR.ToggleAntigrav,function()return antigrav~=nil end)end;kh(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,ku*2,kt,bW,bX,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)bX=bX+kt+20;kh(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,ku*2,kt,bW,bX,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local kO=g0(20)local button=kd(0,0,f_(70),kO,"HELP")button=kd(button.x+button.width,button.y,f_(80),kO,"INFO")button=kd(button.x+button.width,button.y,f_(70),kO,"ORBIT")button=kd(button.x+button.width,button.y,f_(70),kO,"SCOPE")kd(button.x+button.width,button.y,f_(70),kO,"HIDE")end;local kP={}local kQ=nil;function kP.HUDPrologue(gH)bn,bo=fY(bf)if not bn then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.6)..","..e(J+0.6)..","..e(I+0.6)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kR=ay;local kS=az;local kT=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.4+0.5)..[[)]]local kU=ay;local kV=az;local kW=kT;if g1()and not brightHud then kR=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kS=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]kT=[[rgb(]]..e(H*0.2+0.5)..","..e(J*0.2+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iz=f_;local iA=g0;gH[#gH+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .pdimfill {fill: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                    <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="1"/>
                                    </radialGradient>
                                    <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="66%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/>
                                    </radialGradient>                            
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kR,kR,kR,kU,kU,kS,kS,kV,kV,kS,kR,kT,kV,kR,kR,kT,kT,kW,kT,aD,aE,kS,kS,kS,kS,kS,kU,kS,kV,kW,kV,kV,kW)if not kQ then kQ=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iz(630),iA(0),iz(675),iA(45),iz(960),iA(55),iz(1245),iA(45),iz(1290),iA(0),iz(1000),iA(105),iz(1040),iA(59),iz(1250),iA(51),iz(1300),iA(0),iz(1920),iA(0),iz(1920),iA(20),iz(1400),iA(20),iz(1300),iA(105),iz(920),iA(105),iz(880),iA(59),iz(670),iA(51),iz(620),iA(0),iz(0),iA(0),iz(0),iA(20),iz(520),iA(20),iz(620),iA(105),iz(890),iA(59),iz(960),iA(62),iz(1030),iA(59),iz(985),iA(112),iz(1150),iA(112),iz(1100),iA(152),iz(820),iA(152),iz(780),iA(112),iz(935),iA(112),iz(890),iA(59),iz(960),iA(62),iz(1030),iA(59),iz(985),iA(112),iz(1150),iA(112),iz(1100),iA(152),iz(820),iA(152),iz(780),iA(112),iz(935),iA(112))end;gH[#gH+1]=kQ;return gH end;function kP.DrawVerticalSpeed(gH,cR)gG(gH,cR)end;function kP.UpdateHud(gH)local hw=bk;local kX=bl;local gP=kX;local h3=hw;local hO=e(unit.getThrottle())local hT=bc*3.6;local hP=unit.getAxisCommandValue(0)local kY=f_(1770)local kZ=g0(310)if AtmoSpeedAssist and bj then hP=K;hO=K*100 end;local g3=g2()local gQ="ROLL"if hO==nil then hO=0 end;if not br then if bc>5 then hw=hv(ba)kX=hx(ba)else hw=0;kX=0 end;gQ="YAW"end;if bo>50000 and not aq then local k_;k_=c3(bo)gH[#gH+1]=bV(kY,kZ,"PvP Boundary: "..k_,"pbright txtbig txtmid")end;gH[#gH+1]=ak;gH[#gH+1]=aB;gH[#gH+1]=g5;if fR~=""then gH[#gH+1]=fR end;if g6~=""then gH[#gH+1]=g6 end;if g7~=""then gH[#gH+1]=g7 end;gG(gH,as)if m()==0 or RemoteHud then if br then gO(gH,centerX,centerY,gP,gQ,br)else gO(gH,centerX,centerY,kX,gQ,br)end;if not g1()or brightHud then if br then gO(gH,centerX,centerY,gP,gQ,br)h2(gH,h3,gP,centerX,centerY,br,e(hx(ba)),bc)else gO(gH,centerX,centerY,kX,gQ,br)h2(gH,hw,kX,centerX,centerY,br,e(kX),bc)end;h9(gH,as,br)hy(gH,ba,bc,centerX,centerY)end end;hN(gH,g3,hO,hP)hS(gH,hT)hW(gH)iQ(gH)return gH end;function kP.HUDEpilogue(gH)gH[#gH+1]="</svg>"return gH end;function kP.ExtraData(gH)local l0=f_(1240)local l1=g0(55)local l2=l1+10;local l3;local iz=f_;local iA=g0;local l4=0;local g3=g2()if VertTakeOffEngine then g3=g3 .."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bc>20 then g3=g3 .."-COLLISION ON"end;if UseExtra~="Off"then g3="("..UseExtra..")-"..g3 end;if TurnBurn then g3="TB-"..g3 end;if not stablized then g3=g3 .."-DeCoupled"end;local l5=iA(99)local l6=iA(80)local l7=iA(85)local l8=iA(31)local l9=0;local la=0;local lb=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then l4=LastMaxBrakeInAtmo else l4=LastMaxBrake end;local lc,ld=aM.computeDistanceAndTime(bc,0,av,0,0,l4)if lc<0 then lc=0 end;l4=A(l4/(av*fI),2).."g"local le=a:maxForceForward()l3=core.g()if l3>0.1 then la=av*l3;la=A(la/(av*fI),2).."g"l9=0.5*le/l3;l9=l9>1000000 and A(l9/1000000,2).."kT"or A(l9/1000,2).."T"end;le=A(le/(av*fI),2).."g"local lf=vec3(core.getWorldAcceleration()):len()/9.80665;l3=core.g()gH[#gH+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then l0=f_(1120)l1=g0(55)l2=l1+10 elseif aq then local lg=f_(770)gH[#gH+1]=bV(iz(895),l5,"ATMO","")gH[#gH+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iz(895),l7,iz(-80))gH[#gH+1]=bV(iz(815),l6,f("%.1f%%",ar*100),"txtstart size20")end;gH[#gH+1]=bV(iz(1025),l5,"GRAVITY","txtstart")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(1025),l7,iz(80))gH[#gH+1]=bV(iz(1105),l6,f("%.2fg",l3/9.80665),"size20")gH[#gH+1]=bV(iz(1125),l5,"ACCEL","txtstart")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(1125),l7,iz(80))gH[#gH+1]=bV(iz(1205),l6,f("%.2fg",lf),"size20")gH[#gH+1]=bV(iz(695),l5,"BRK TIME","")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(695),l7,iz(-80))gH[#gH+1]=bV(iz(615),l6,f("%s",c6(ld)),"txtstart size20")gH[#gH+1]=bV(iz(635),iA(45),"TRIP","")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(635),iA(31),iz(-90))if travelTime then gH[#gH+1]=bV(iz(532),iA(23),f("%s",c6(travelTime)),"txtstart size20")end;gH[#gH+1]=bV(iz(795),l5,"BRK DIST","")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(795),l7,iz(-80))gH[#gH+1]=bV(iz(715),l6,f("%s",c3(lc)),"txtstart size20")gH[#gH+1]=bV(iz(1285),iA(45),"MASS","txtstart")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(1285),iA(31),iz(90))gH[#gH+1]=bV(iz(1388),iA(23),f("%s",lb),"size20")gH[#gH+1]=bV(iz(1220),l5,"THRUST","txtstart")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(1220),l7,iz(80))gH[#gH+1]=bV(iz(1300),l6,f("%s",le),"size20")gH[#gH+1]=bV(f_(960),g0(175),g3,"pbright txtbig txtmid size20")gH[#gH+1]="</g>"end;function kP.DrawOdometer(gH,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return gH end;local l3;local l9=0;local la=0;local l4=0;local lb=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then l4=LastMaxBrakeInAtmo else l4=LastMaxBrake end;local lc,ld=aM.computeDistanceAndTime(bc,0,av,0,0,l4)l4=A(l4/(av*fI),2).." g"local le=a:maxForceForward()l3=core.g()if l3>0.1 then la=av*l3;la=A(la/(av*fI),2).." g"l9=0.5*le/l3;l9=l9>1000000 and A(l9/1000000,2).." kTons"or A(l9/1000,2).." Tons"end;le=A(le/(av*fI),2).." g"if m()==0 or RemoteHud then local lh=f_(OrbitMapX+10)local li=g0(OrbitMapY+20)local lj=f_(OrbitMapX+10+OrbitMapSize/1.25)local kf=25;gH[#gH+1]="<g class='txtstart size14 bright'>"gH[#gH+1]=bV(lh,li,f("BrkTime: %s",c6(ld)))gH[#gH+1]=bV(lj,li,f("Trip: %.2f km",ad))gH[#gH+1]=bV(lh,li+kf,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gH[#gH+1]=bV(lj,li+kf,f("BrkDist: %s",c3(lc)))gH[#gH+1]=bV(lh,li+kf*2,"Trip Time: "..c6(ae))gH[#gH+1]=bV(lj,li+kf*2,"Total Time: "..c6(TotalFlightTime))gH[#gH+1]=bV(lh,li+kf*3,f("Mass: %s",lb))gH[#gH+1]=bV(lj,li+kf*3,f("Max Brake: %s",l4))gH[#gH+1]=bV(lh,li+kf*4,f("Max Thrust: %s",le))if l3>0.1 then gH[#gH+1]=bV(lj,li+kf*4,f("Max Thrust Mass: %s",l9))gH[#gH+1]=bV(lh,li+kf*5,f("Req Thrust: %s",la))else gH[#gH+1]=bV(lj,li+kf*5,"Max Mass: n/a")gH[#gH+1]=bV(lh,li+kf*6,"Req Thrust: n/a")end end;gH[#gH+1]="</g></g>"return gH end;function kP.DrawWarnings(gH)return hW(gH)end;function kP.DisplayOrbitScreen(gH)return iQ(gH)end;function kP.DisplayMessage(gH,ii)if ii~="empty"then local bX=310;for lk in string.gmatch(ii,"([^\n]+)")do bX=bX+35;gH[#gH+1]=bV("50%",bX,lk,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function kP.DrawDeadZone(gH)gH[#gH+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kP.UpdatePipe()if aq then fR=""return end;k4()end;function kP.DrawSettings(gH)if#fQ>0 then local bW=f_(640)local bX=g0(200)gH[#gH+1]=[[<g class="pbright txtvspd txtstart">]]for cf,cg in pairs(fQ)do gH[#gH+1]=bV(bW,bX,cg..": ".._G[cg])bX=bX+20;if cf%12==0 then bW=bW+f_(350)bX=g0(200)end end;gH[#gH+1]=bV(f_(640),g0(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gH[#gH+1]="</g>"end;return gH end;local ll;local lm=f_(1770)local ln=g0(350)local lo=g0(15)local lp=f_(1370)local bE,lq;local lr=0;function kP.DrawRadarInfo()local function ls()if radarPanelID~=nil and lr==0 then t(radarPanelID)radarPanelID=nil;if ll~=nil then t(ll)ll=nil end else if lr==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bu,1,"Periscope","periscope")ll=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bu,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;lr=0 end end;local eA,eB,ez,eC,eD,ew=aS.GetRadarHud()local B=eC or 0;if ez>0 then if CollisionSystem then bE=B.."/"..eD.." Plotted : "..ez-eD.." Ignored"else bE="Radar Contacts: "..ez end;g5=bV(lm,ln,bE,"pbright txtbig txtmid")if#ew>0 then g5=g5 ..bV(lp,lo,"Friendlies In Range","pbright txtbig txtmid")for cf,cg in pairs(ew)do lo=lo+20;g5=g5 ..bV(lp,lo,bu[1].getConstructName(cg),"pdim txtmid")end end;if eA==nil and ll==nil then lr=1;ls()end;if eA~=nil and ll~=nil then ls()end;if radarPanelID==nil then ls()end else if eB then g5=bV(lm,ln,bv.." Radar: Jammed","pbright txtbig txtmid")else g5=bV(lm,ln,"Radar: No "..bv.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then lr=0;ls()end end end;function kP.DrawTanks()if fuelX~=0 and fuelY~=0 then g6=bV(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gn(fuelX,"Atmospheric ","ATMO",aF,gl,gm)gn(fuelX,"Space Fuel T","SPACE",aG,gj,gk)gn(fuelX,"Rocket Fuel ","ROCKET",aH,gh,gi)end end;function kP.DrawShield()local lt=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local lu=core.getPvPTimer()local lv=shield_1.getResistances()local lw="A: "..10+lv[1]*100 .."% / E: "..10+lv[2]*100 .."% / K:"..10+lv[3]*100 .."% / T: "..10+lv[4]*100 .."%"local bW,bX=shieldX-60,shieldY+30;local lx=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gB=e(lx*2.55)local gC=f("rgb(%d,%d,%d)",255-gB,gB,0)local bZ=""g7=bV(bW,bX,"","txtmid pdim txtfuel")if lx<10 and lt~="Shield Disabled"then bZ="red "end;lu=lu>0 and"   PvPTime: "..c6(lu)or""g7=g7 ..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bW,bX,gC,lx*2,bW,bX,bW+2,bX+10,lx,lu)g7=g7 ..bV(bW,bX-5,lt,bZ.."txtstart pbright txtbig")g7=g7 ..bV(bW,bX+30,lw,bZ.."txtstart pbright txtsmall")end;function kP.hudtick()if not planet then return end;local function ly(gH)local gE=e(r(aj/(aD/4)*255,0,255))gH[#gH+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+gE,e(J+0.5)-gE,e(I+0.5)-gE)end;local function lz()for _,cg in pairs(fJ)do if cg.hovered then if not cg.drawCondition or cg.drawCondition(cg)then cg.toggleFunction(cg)end;cg.hovered=false end end;for _,cg in pairs(by)do if cg.hovered then SelectedTab=cg.label;cg.hovered=false end end end;local function lA()local function lB(lC,lD,bW,bX,ke,kf)if lC>=bW and lC<=bW+ke and lD>=bX and lD<=bX+kf then return true else return false end end;local bW=ag+aD/2;local bX=ah+aE/2;for _,cg in pairs(fJ)do cg.hovered=lB(bW,bX,cg.x,cg.y,cg.width,cg.height)end;for _,cg in pairs(by)do cg.hovered=lB(bW,bX,cg.x,cg.y,cg.width,cg.height)end;if bw then local jU=false;for _,c2 in ipairs(apExtraButtons)do if c2.hovered then jU=true;break end end;if apbutton.hovered then jU=true end;bw=jU else bw=apbutton.hovered;if not bw then bx=AutopilotTargetIndex end end end;local function lE(gH)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;for cf,cg in pairs(by)do local bZ="dim brightstroke"local lF=0.2;if SelectedTab==cf then bZ="pbright dimstroke"lF=0.6 end;local lG=""if cg.hovered then lF=0.8;lG=";stroke:white"end;gH[#gH+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cg.width,cg.height,cg.x,cg.y,bZ,lF,lG)gH[#gH+1]=bV(cg.x+cg.width/2,cg.y+cg.height/2+5,cg.label,"txt txtmid pdim")end end;local function lH(gH)local function lI(gH,lJ,hover,bW,bX,dY,lK,lL,lM,lN,lO,button)if type(lN)=="function"then lN=lN(button)end;if type(lO)=="function"then lO=lO(button)end;gH[#gH+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bW,bX,dY,lK)if lJ then gH[#gH+1]=f("%s'",lL)else gH[#gH+1]=lM end;if hover then gH[#gH+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gH[#gH+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gH[#gH+1]=" rx='5'></rect>"gH[#gH+1]=f("<text x='%f' y='%f' font-size='24' fill='",bW+dY/2,bX+lK/2+5)if lJ then gH[#gH+1]="black"else gH[#gH+1]="white"end;gH[#gH+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lJ then gH[#gH+1]=f("%s</text>",lN)else gH[#gH+1]=f("%s</text>",lO)end end;local lP=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local lQ=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local lR=lI;for _,cg in pairs(fJ)do local kj=cg.disableName;local ki=cg.enableName;if type(kj)=="function"then kj=kj(cg)end;if type(ki)=="function"then ki=ki(cg)end;if not cg.drawCondition or cg.drawCondition(cg)then lR(gH,cg.toggleVar(cg),cg.hovered,cg.x,cg.y,cg.width,cg.height,lQ,lP,kj,ki,cg)end end end;local lS=A(aD/2,0)local lT=A(aE/2,0)local gH={}aP.HUDPrologue(gH)if showHud then aP.UpdateHud(gH)else if AlwaysVSpd then aP.DrawVerticalSpeed(gH,as)end;aP.DisplayOrbitScreen(gH)aP.DrawWarnings(gH)end;if fP and fQ~={}then aP.DrawSettings(gH)end;if radar_1 or radar_2 then aS.assignRadar()end;if bu[1]then aP.DrawRadarInfo()end;aP.HUDEpilogue(gH)gH[#gH+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aD,aE)if a2~="empty"then aP.DisplayMessage(gH,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aP.DrawDeadZone(gH)end end;lE(gH)if x()==0 then if m()==1 and a1 then if not AltIsOn then lA()lH(gH)end;if not aT and not aU then local lU=table.concat(gH,"")gH={}gH[#gH+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gH[#gH+1]=lU;gH[#gH+1]="</body>"aT=true;gH[#gH+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gH,"")system.setScreen(content)elseif aU then local lU=table.concat(gH,"")gH={}gH[#gH+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gH[#gH+1]=lU;gH[#gH+1]="</body>"end;if not aT then gH[#gH+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lS,lT,ag,ah)end else lz()end else if not a1 and m()==0 then lz()if aj>DeadZone then if DisplayDeadZone then ly(gH)end end elseif a1 and(not AltIsOn or not freeLookToggle)then lA()lH(gH)end;gH[#gH+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lS,lT,ag,ah)end;gH[#gH+1]=[[</svg></body>]]content=table.concat(gH,"")end;function kP.TenthTick()aP.DrawTanks()if shield_1 then aP.DrawShield()end end;function kP.OneSecond(gH)local function lV()local gx=q()local hT=bc;local lW=gx-au;if hT>1.38889 then hT=hT/1000;local lX=hT*(gx-au)TotalDistanceTravelled=TotalDistanceTravelled+lX;ad=ad+lX end;ae=ae+lW;TotalFlightTime=TotalFlightTime+lW;au=gx end;lV()aP.UpdatePipe()aP.ExtraData(gH)end;function kP.ButtonSetup()kr()kw()fJ=fK end;return kP end;local function lY()local function lZ(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function l_()local function m0(m1,m2)return m1.name<m2.name end;bm={}for cf,cg in pairs(b[0])do bm[#bm+1]={name=cg.name,index=cf}end;table.sort(bm,m0)end;local function m3(m4)for cf,cg in pairs(m4)do if cg.name and cg.name==CustomTarget.name then return cf end end;return-1 end;local function m5()bx=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local m6=bm[AutopilotTargetIndex].index;local m7=b[0][m6]if m7.center then AutopilotTargetName=m7.name;ac=aL[0][m6]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=m7;for _,cg in pairs(aL[0])do if cg.name==CustomTarget.planetname then ac=cg;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function m8(gL)if not Autopilot and not VectorToTarget and not am and not IntoOrbit and not Reentry and not an then if gL==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bm end end;if AutopilotTargetIndex==0 then m5()else local m6=bm[AutopilotTargetIndex].index;local m7=b[0][m6]if m7~=nil and m7.name=="Space"or iphCondition=="Custom Only"and m7.center or iphCondition=="No Moons"and string.find(m7.name,"Moon")~=nil then if gL==nil then m8()else m8(1)end else m5()end end else a2="Disengage autopilot before changing Interplanetary Helper"bI("iph","AP")end end;local function kC()local fh=-1;fh=m3(b[0])if fh>-1 then table.remove(b[0],fh)end;fh=-1;fh=m3(SavedLocations)if fh~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fh)end;m8()l_()end;local function kx(fw,position,hs,m9)if dbHud_1 or hs then local p=lZ(position)local l3=p.gravity;if m9 then l3=unit.getClosestPlanetInfluence()end;local ma={position=position,name=fw,planetname=p.name,gravity=l3,safe=m9}if not hs then SavedLocations[#SavedLocations+1]=ma else for cf,cg in pairs(b[0])do if cg.name and fw==cg.name then table.remove(b[0],cf)end end end;table.insert(b[0],ma)l_()m5()a2="Location saved as "..fw.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local mb={}function mb.UpdateAtlasLocationsList()l_()end;function mb.UpdateAutopilotTarget()m5()end;function mb.adjustAutopilotTargetIndex(gL)m8(gL)end;function mb.findAtlasIndex(m4)m3(m4)end;function mb.UpdatePosition(mc)local fh=m3(SavedLocations)if fh~=-1 then if mc~=nil then SavedLocations[fh].name=mc;AutopilotTargetIndex=AutopilotTargetIndex-1;m8()else local md=SavedLocations[fh]md.gravity=unit.getClosestPlanetInfluence()md.position=bf;md.safe=true end;a2=SavedLocations[fh].name.." position updated ("..SavedLocations[fh].planetname..")"else a2="Name Not Found"end end;function mb.AddNewLocation(fw,position,hs,m9)kx(fw,position,hs,m9)end;function mb.ClearCurrentPosition()kC()end;for cf,cg in pairs(SavedLocations)do table.insert(b[0],cg)end;l_()if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end;mb.UpdateAutopilotTarget()return mb end;local function me()local mf={}local function mg(e4)local mh=AutopilotEndSpeed;if not Autopilot then mh=0 end;if not aq then return aM.computeDistanceAndTime(e4,mh,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aM.computeDistanceAndTime(e4,mh,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function mi(e4)local mh=AutopilotEndSpeed;if not Autopilot then mh=0 end;return aM.computeDistanceAndTime(e4,mh,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local mj=false;local mk=0;local ml=0;local mm=0;local mn=q()local mo=0;local mp=0;local mq=0;local mr=0;local ms=false;local mt=false;local mu=false;local mv=nil;local mw=0;function mf.GetAutopilotBrakeDistanceAndTime(e4)return mg(e4)end;function mf.GetAutopilotTBBrakeDistanceAndTime(e4)return mi(e4)end;local function mx(my,mz,mA)mz=mz:project_on_plane(my)mA=mA:project_on_plane(my)return n(mz:cross(mA):dot(my),mz:dot(mA))end;local function mB()local function mC()local mD=-1;local mE=-1;if vBooster then mD=vBooster.getDistance()end;if hover then mE=hover.getDistance()end;if mD~=-1 and mE~=-1 then if mD<mE then return mD else return mE end elseif mD~=-1 then return mD elseif mE~=-1 then return mE else return-1 end end;local mF=mC()local mG=-1;if telemeter_1 then mG=telemeter_1.getDistance()end;if mF~=-1 and mG~=-1 then if mF<mG then return mF else return mG end elseif mF~=-1 then return mF else return mG end end;local function mH(planet,dr,mI)local function mJ(mK,cL)local dx=vec3(cL)if mK.id==0 then return setmetatable({latitude=dx.x,longitude=dx.y,altitude=dx.z,id=0,systemId=mK.systemId},MapPosition)end;local dy=dx-mK.center;local aj=dy:len()local cR=aj-mK.radius;local cP=0;local cQ=0;if not c0(aj,0)then local dz=n(dy.y,dy.x)cQ=dz>=0 and dz or 2*math.pi+dz;cP=math.pi/2-math.acos(dy.z/aj)end;return setmetatable({latitude=math.deg(cP),longitude=math.deg(cQ),altitude=cR,id=mK.id,systemId=mK.systemId},MapPosition)end;local mL=mJ(planet,dr)mL="::pos{"..mL.systemId..","..mL.id..","..mL.latitude..","..mL.longitude..","..mL.altitude.."}"if mI then return mL else system.setWaypoint(mL)return true end end;local mM=false;function mf.showWayPoint(planet,dr,mI)return mH(planet,dr,mI)end;function mf.APTick()local function mN()if bt and not BrakeLanding then local db=bt[1]local fx,fy=bt[2],bt[3]local mO=math.min(fx,fy or fx)local mP=mO/bc;local mQ=AutoTakeoff and(bc<42 or ao~=-1)local mR=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mR and not mQ and(a8*1.5>mO or mP<1)then BrakeIsOn=true;aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()end;if LockPitch then aR.ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then aR.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aV=true end;if mP<11 then bs=db.name.." COLLISION "..c6(mP).." / "..c3(mO,2)else bs=db.name.." collision "..c6(mP)end;if mP<6 then bI("alarm","AL",2)end else bs=false end end;local function mS(mT,mU,mV)local function mW(mT,dd)mT=vec3(mT)dd=vec3(dd):normalize()local cw=mT*dd;return cw.x+cw.y+cw.z end;local mX=0.001;local mY=1;if not aq or not aX or ao~=-1 or bc<Q then if mV==nil then mV=DampingMultiplier end;if mU==nil then mU=mX end;mT=vec3(mT):normalize()local mZ=vec3()-mT;local m_=-mW(mZ,core.getConstructWorldOrientationRight())*mY;local n0=-mW(mZ,core.getConstructWorldOrientationUp())*mY;if ml==0 then ml=m_/2 end;if mm==0 then mm=n0/2 end;if d(m_)<0.1 then V=V-m_*2 else V=V-(m_+(m_-ml)*mV)end;if d(n0)<0.1 then U=U+n0*2 else U=U+n0+(n0-mm)*mV end;ml=m_;mm=n0;if d(m_)<mU and d(n0)<mU then return true end;return false elseif aX and ao==-1 then mT=bb;if mV==nil then mV=DampingMultiplier end;if mU==nil then mU=mX end;mT=vec3(mT):normalize()local mZ=b8-mT;local m_=-mW(mZ,core.getConstructWorldOrientationRight())*mY;local n0=-mW(mZ,core.getConstructWorldOrientationUp())*mY;if ml==0 then ml=m_/2 end;if mm==0 then mm=n0/2 end;if d(m_)<0.1 then V=V-m_*5 else V=V-(m_+(m_-ml)*mV)end;if d(n0)<0.1 then U=U+n0*5 else U=U+n0+(n0-mm)*mV end;ml=m_;mm=n0;if d(m_)<mU and d(n0)<mU then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=mB()E=q()mn=E;if CollisionSystem then mN()end;if antigrav then bh=antigrav.getState()==1 end;local n1=1;local n2=1;local n3=E-mn;local n4=-math.deg(mx(b7,bb,b8))local n5=math.deg(mx(b9,bb,b8))local gL=bd*-1;aX=aq and n4<-YawStallAngle or n4>YawStallAngle or n5<-PitchStallAngle or n5>PitchStallAngle;local n6=system.getMouseDeltaX()local n7=system.getMouseDeltaY()if InvertMouse and not a1 then n7=-n7 end;V=0;Z=0;U=0;sys=aL[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aO(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bb)if as==0 then as=(bf-planet.center):len()-planet.radius end;br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local l3=planet:getGravity(core.getConstructWorldPos()):len()*av;aY=0;aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aT then ag=r(ag+n6,-aD/2,aD/2)ah=r(ah+n7,-aE/2,aE/2)end else ag=0;ah=0 end else ag=r(ag+n6,-aD/2,aD/2)ah=r(ah+n7,-aE/2,aE/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then local hF,hG=n6,n7;if SelectedTab=="SCOPE"then hF,hG=bC/90,bC/90 end;if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity*hF elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity*hF else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity*hG elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity*hG else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(n7,-100,100)+0.5)*2*n1;V=(-utils.smoothstep(n6,-100,100)+0.5)*2*n2 end end end end;local n8=bc>8334;if bc>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not n8 then a2="Space Speed Engine Shutoff reached"aR.cmdThrottle(0)end;if not n8 and LastIsWarping then if not BrakeIsOn then aR.BrakeToggle()end;if Autopilot then aR.ToggleAutopilot()end end;LastIsWarping=n8;if aq and ar>0.09 then if bc>aZ/3.6 and not AtmoSpeedAssist and not mj then BrakeIsOn=true;mj=true elseif not AtmoSpeedAssist and mj then if bc<aZ/3.6 then BrakeIsOn=false;mj=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local n9=false;if CustomTarget and al~=1 then n9=mS(CustomTarget.position-bf,0.1)else n9=mS(vec3(bb),0.01)end;aV=true;if n9 then aR.cmdCruise(e(aZ))if(d(bl)<2 or d(bk)>85)and bc>=aZ/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;aR.BeginReentry()end elseif aq and AtmoSpeedAssist then aR.cmdThrottle(1)end elseif bc>Q then mS(vec3(bb),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bc>Q then mS(-vec3(bb))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;aR.BeginReentry()al=false;an=true else al=false;aR.ToggleAutopilot()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bc*3.6>aZ-250 and d(be)<25 and ar>=0.1 and(CustomTarget.position-bf):len()>2000+as then aR.ToggleAutopilot()an=false end;if VertTakeOff then aV=true;local na=HoldAltitude;if be<-30 then a2="Unable to achieve lift. Safety Landing."af=0;aV=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bh or HoldAltitude<planet.spaceEngineMinAltitude then if bh then na=antigrav.getBaseAltitude()end;if as<na-100 then a_=0;af=15;BrakeIsOn=false elseif be>0 then BrakeIsOn=true;af=0 elseif be<-30 then BrakeIsOn=true;af=15 elseif as>=na then if bh then if Autopilot or VectorToTarget then aR.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bI("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bI("vtoc","VT")aR.ToggleVerticalTakeoff()end;af=0 end else if ar>0.08 then a_=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if b5 then a_=0;af=20 else af=0;a_=36;aR.cmdCruise(3500)end else aV=autoRollPreference;IntoOrbit=true;b3=false;CancelIntoOrbit=false;ms=false;mq=nil;mr=nil;if mv==nil then mv=planet end;b2=na;mu=true;VertTakeOff=false end end;if a_~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local nb=r(a_-bk,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(nb)local nc=r(vTpitchPID:get(),-1,1)U=nc end end;if IntoOrbit then local mZ;local nd=false;local ne=c3(b2)if mv==nil then mv=planet;if VectorToTarget then mv=ac end end;if not mu then b2=e(mv.radius+mv.surfaceMaxAltitude+LowOrbitHeight)if mv.hasAtmosphere then b2=e(mv.radius+mv.noAtmosphericDensityAltitude+LowOrbitHeight)end;mu=true end;if b1.VectorToTarget and CustomTarget then mZ=CustomTarget.position-bf end;local nf,ng=aO(mv):escapeAndOrbitalSpeed((bf-mv.center):len()-mv.radius)local nh=bl;if not ms then local ni=false;local nj=false;aR.cmdThrottle(0)mr=0;b0="Aligning to orbital path - OrbitHeight: "..ne;if b1.VectorToTarget then mS(mZ:normalize():project_on_plane(bd))nd=b8:dot(mZ:project_on_plane(b7):normalize())>0.95 else mS(bb)nd=n4<0.5;if bc<150 then nd=true end end;U=0;mq=0;if bk<=mq+1 and bk>=mq-1 then ni=true else ni=false end;if nh<=mr+1 and nh>=mr-1 then nj=true else nj=false end;if ni and nj and nd then mq=nil;mr=nil;ms=true end else if b1.VectorToTarget then mS(mZ:normalize():project_on_plane(bd))elseif bc>150 then mS(bb)end;U=0;if b1.VectorToTarget and CustomTarget then local a8,_=aM.computeDistanceAndTime(bc,aZ/3.6,av,0,0,LastMaxBrake)if b3 and mZ:len()>15000+a8+as then b0="Orbiting to Target"if as-100<=mv.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<mv.noAtmosphericDensityAltitude then b3=false end elseif b3 or mZ:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bI("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;b1.VectorToTarget,b1.AutopilotAlign=false,false;aR.ToggleIntoOrbit()aR.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>b2*0.9 and as<b2*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=b2*0.99 and orbit.apoapsis.altitude>=b2*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or b3 then if b3 then BrakeIsOn=false;aR.cmdThrottle(0)mq=0;if not b1.VectorToTarget then a2="Orbit complete"bI("orCom","OB")aR.ToggleIntoOrbit()end else mw=mw+1;if mw>=2 then b3=true end end else b0="Adjusting Orbit - OrbitHeight: "..ne;mt=true;aR.cmdCruise(ng*3.6+1)local nk=b2-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(nk-be*r(utils.smoothstep(2000-nk,-2000,2000)^6*10,1,10))mq=r(VSpdPID:get(),-60,60)end end else local nl=2.75;local nm=d(A(nf*nl))local nn=nm%50;if nn>0 then nm=nm-nn+50 end;BrakeIsOn=false;if as<b2*0.8 then b0="Escaping planet gravity - OrbitHeight: "..ne;mq=utils.map(be,200,0,-15,80)elseif as>=b2*0.8 and as<b2*1.15 then b0="Approaching orbital corridor - OrbitHeight: "..ne;nm=nm*0.75;mq=utils.map(be,100,-100,-15,65)elseif as>=b2*1.15 and as<b2*1.5 then b0="Approaching orbital corridor - OrbitHeight: "..ne;nm=nm*0.75;if be<0 or mt then mq=utils.map(as,b2*1.5,b2*1.01,-30,0)else mq=utils.map(as,b2*0.99,b2*1.5,0,30)end elseif as>b2*1.5 then b0="Reentering orbital corridor - OrbitHeight: "..ne;mq=-65;local no=utils.map(be,-150,-400,1,0.55)nm=nm*no end;aR.cmdCruise(e(nm))end end;if mq~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local np=mq-bk;OrbitPitchPID:inject(np)local nq=r(OrbitPitchPID:get(),-0.5,0.5)U=nq end end;if Autopilot and ar==0 and not al then local function nr(bE,orbit)system.print(bE)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aR.cmdThrottle(0)P=false;a2=bE;bI("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;b2=as;mu=true end;aR.ToggleIntoOrbit()end end;local ns,nt=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local nu=(CustomTarget.position-ac.center):normalize()local nw=nu:project_on_plane((ac.center-bf):normalize()):normalize()local nx=ac.center+nw*(ac.radius+AutopilotTargetOrbit)local ny=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bf-nx):len()<(bf-ny):len()then ns=nx else ns=ny;AutopilotEndSpeed=0 end;AutopilotTargetCoords=ns;aR.showWayPoint(ac,AutopilotTargetCoords)nt=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;nt=true;AutopilotRealigned=true;TargetSet=true;ns=CustomTarget.position+(bf-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=ns end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local nu=(bf+bb*100000-ac.center):normalize()local nw=nu:project_on_plane((ac.center-bf):normalize()):normalize()if nw:len()<1 then nu=(bf+b8*100000-ac.center):normalize()nw=nu:project_on_plane((ac.center-bf):normalize()):normalize()end;ns=ac.center+nw*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=ns;TargetSet=true;nt=true;AutopilotRealigned=true;aR.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(ns)-bf):len()local it,dp,dq=aL:getPlanetarySystem(0):castIntersections(bf,bb:normalize(),function(db)if db.noAtmosphericDensityAltitude>0 then return db.radius+db.noAtmosphericDensityAltitude else return db.radius+db.surfaceMaxAltitude*1.5 end end)local iu=dp;if dq~=nil and dp~=nil then iu=math.min(dq,dp)end;if iu~=nil and iu<AutopilotDistance and it.name==ac.name then AutopilotDistance=iu end;local n9=true;local nz=(ac.center-(bf+vec3(bb):normalize()*AutopilotDistance)):len()-ac.radius;local ii=c3(nz)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ii..'"}')local a8,a9;if not TurnBurn then a8,a9=mg(bc)else a8,a9=mi(bc)end;if bc>50 and AutopilotAccelerating then local mZ=vec3(ns)-bf;local nA=r(math.deg(mx(b7,bb:normalize(),mZ:normalize()))*bc/500,-90,90)local nB=r(math.deg(mx(b9,bb:normalize(),mZ:normalize()))*bc/500,-90,90)if d(nA)<20 and d(nB)<20 then nA=nA*2;nB=nB*2 end;if d(nA)<2 and d(nB)<2 then nA=nA*2;nB=nB*2 end;local n4=-math.deg(mx(b7,b8,bb:normalize()))local n5=-math.deg(mx(b9,b8,bb:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(nB-n5)local nC=r(apPitchPID:get(),-1,1)U=U+nC;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(nA-n4)local nD=r(apYawPID:get(),-1,1)V=V+nD;nt=true;if d(nA)>2 or d(nB)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bI("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end end elseif AutopilotAccelerating and bc<=50 then mS((ns-bf):normalize())end;if nz<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(nz)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local it,iu=aR.checkLOS((AutopilotTargetCoords-bf):normalize())if ac.name~=planet.name then if it~=nil and ac.name~=it.name and iu<AutopilotDistance then a2="Collision with "..it.name.." in "..c3(iu).."\nClear LOS to continue."ai=5;mM=true else mM=false;a2=""end end end;if not mM then if not AutopilotCruising and not AutopilotBraking and not nt then n9=mS((ns-bf):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then n9=mS(-vec3(bb):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aR.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local nE=unit.getThrottle()if AtmoSpeedAssist then nE=K end;local nF=99999;local lf=-vec3(core.getWorldAcceleration()):dot(bb:normalize())local nG=r(bb:dot((ns-bf):normalize()),0,bc)if nG>0 or lf>0 then nF=aM.computeTravelTime(nG,lf,AutopilotDistance-a8)end;if ba:len()>=MaxGameVelocity or nE==0 and P or warmup/4>nF then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bI("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aR.cmdThrottle(0)end;local nH=AutopilotDistance;if nH<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mk and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mk=bo else mk=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bI("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aR.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aR.cmdThrottle(1,true)end;local _,ng=aO(ac):escapeAndOrbitalSpeed((bf-planet.center):len()-planet.radius)local mZ;if CustomTarget then mZ=CustomTarget.position-bf end;if CustomTarget and CustomTarget.planetname=="Space"and bc<50 then nr("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bc<=ng and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then nr("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bI("apCir","AP")AutopilotStatus="Circularizing"end;if bc<=ng then if CustomTarget then if bb:normalize():dot(mZ:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bI("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else nr("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else nr("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then nr("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nH=AutopilotDistance;if nH<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mk and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mk=bo else mk=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bI("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local nE=unit.getThrottle()if AtmoSpeedAssist then nE=K end;if nE>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end;AutopilotCruising=false end else if n9 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*b9;AutopilotShipUp=b7;AutopilotShipRight=b9 end;AutopilotRealigned=true elseif n9 and not mM then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bI("apAcc","AP")end;if not P then aR.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bI("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aR.cmdThrottle(0)P=false;ProgradeIsOn=true;al=true;aR.showWayPoint(ac,CustomTarget.position)end;if a0 then aV=true;local nB=0;local e8=bf+vec3(unit.getMasterPlayerRelativePosition())local nI=e8-bf;local nJ=vec3(nI):project_on(b8):len()local nK=vec3(nI):project_on(b9):len()local aj=y(nJ*nJ+nK*nK)mS(nI:normalize())local jt=40;local nL=aj<jt;local nM=100;local nN=r((aj-jt)/2,10,nM)U=0;local n9=d(V)<0.1;if n9 and bc<nN and not nL then BrakeIsOn=false;nB=-20 else BrakeIsOn=true;nB=0 end;local nO=0;if d(nB-bk)>nO then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(nB-bk)local nC=pitchPID:get()U=nC end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local nP=LastMaxBrakeInAtmo;if nP then nP=nP*r(bc/100,0.1,1)*ar else nP=LastMaxBrake end;if ar<0.01 then nP=LastMaxBrake end;local nQ=b8:project_on_plane(bd):normalize():dot(bb)local nR=vec3(core.getWorldAirFrictionAcceleration())local nS=nR:len()*av;if nQ>100 then a8,a9=aM.computeDistanceAndTime(nQ,100,av,0,0,nP)local nT,nU=aM.computeDistanceAndTime(100,0,av,0,0,nP*0.55)a8=a8+nT else a8,a9=aM.computeDistanceAndTime(nQ,0,av,0,0,nP*0.55)end;local nk=HoldAltitude-as-be;local nV=200+bc;if Reentry or al then minMax=2000+bc end;local nW=1;if AutoTakeoff then nW=r(bc/100,0.1,1)end;local nB=(utils.smoothstep(nk,-nV,nV)-0.5)*2*MaxPitch*nW;if not Reentry and not al and not VectorToTarget and b8:dot(bb:normalize())<0.99 then nB=(utils.smoothstep(nk,-nV*r(20-19*ar*10,1,20),nV*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*nW end;if not AltitudeHold then nB=0 end;if LockPitch~=nil then if br and not IntoOrbit then nB=LockPitch else LockPitch=nil end end;aV=true;local nX=U;if Reentry then local nY=e(aZ)local nZ,n_=aM.computeDistanceAndTime(bc,nY/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)nZ=nZ==-1 and 5000 or nZ;local o0=as-(planet.noAtmosphericDensityAltitude+nZ)local o1=as>planet.noAtmosphericDensityAltitude+nZ*1.35;if o1 then nB=ReEntryPitch;if bc<=nY/3.6 and bc>nY/3.6-10 and d(bb:normalize():dot(b8))>0.9 and not bj then O=false;aR.cmdThrottle(1)end elseif bj and not o1 and not aq then aR.cmdCruise(nY,true)end;if bj then if bc>nY/3.6 and not o1 then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if be>0 then BrakeIsOn=true end;if not R then nB=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;nB=0;aV=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and o1 then aV=true elseif not o1 then if not aq and(bj or s:getTargetSpeed(axisCommandId.longitudinal)~=nY)then aR.cmdCruise(nY)end;if bc<nY/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;aV=true end end end;if bc>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then mS(vec3(bb))end;if bp or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local mZ;if bp then if type(bp)=="table"then mZ=bp elseif bp<3 and bp>0 then mZ=-bd:cross(bb)*5000 elseif bp>=3 then mZ=bd:cross(bb)*5000 elseif bp<0 then mZ=bb*25000 end elseif CustomTarget~=nil then mZ=CustomTarget.position-bf else mZ=ac.center-bf end;local nA=math.deg(mx(bd:normalize(),bb,mZ))*2;local jw=math.rad(d(bl))if bc>minRollVelocity and ar>0.01 then local o2=1000+bc;local o3=(utils.smoothstep(nk-be*10,-o2,o2)-0.5)*2*MaxPitch;local o4=r(90-o3,0,180)aY=r(nA*2,-o4,o4)local o5=nA;nA=r(r(nA,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jw)+4*(bk-nB)*math.sin(math.rad(bl)),-YawStallAngle*0.80,YawStallAngle*0.80)local o6=1;if aY~=0 then o6=d(jw/aY)end;o6=(90-r(d(aY-bl),0,90))/90;local o7=nB;if d(bl)>90 then o7=-o7 end;nB=o6*r(r(o7*math.cos(jw),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(o5)*math.sin(jw),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aY=0;nA=r(nA,-YawStallAngle*0.80,YawStallAngle*0.80)end;local o8=n4-nA;if bp and d(o8)<=0.0001 and(type(bp)=="table"or type(bp)~="table"and bp<0 and d(bl)<1)then if bp==-2 then aR.ToggleAltitudeHold()end;bp=nil;bI("180Off","BR")return end;if not aX and bc>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(o8)local nD=r(yawPID:get(),-1,1)V=V+nD elseif aq and ao>-1 or bc<minRollVelocity then mS(mZ)elseif aX and ar>0.01 then if(n4<-YawStallAngle or n4>YawStallAngle)and ar>0.01 then mS(bb)end;if(n5<-PitchStallAngle or n5>PitchStallAngle)and ar>0.01 then nB=r(bk-n5,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local na=planet:getAltitude(CustomTarget.position)local o0=mZ:project_on_plane(bd):len()StrongBrakes=true;if not am and not Reentry and o0<=a8 and(bb:project_on_plane(bd):normalize():dot(mZ:project_on_plane(bd):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(nQ<0.1 or o0<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<o0)then if not bh then bI("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bs=false end;LastDistanceToTarget=o0 end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local mZ=CustomTarget.position-bf;local na=planet:getAltitude(CustomTarget.position)local o0=y(mZ:len()^2-(as-na)^2)local nP=LastMaxBrakeInAtmo;if nP then a8,a9=aM.computeDistanceAndTime(bc,0,av,0,0,nP/2)StrongBrakes=true;if o0<=a8+bc*n3/2 and bb:project_on_plane(bd):normalize():dot(mZ:project_on_plane(bd):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;aR.BeginReentry()end end;LastDistanceToTarget=o0 end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not b3 and not IntoOrbit then b2=HoldAltitude;mu=true;if VectorToTarget then b1.VectorToTarget=true end;aR.ToggleIntoOrbit()VectorToTarget=false;ms=true end end;if aX and ar>0.01 and ao==-1 and bc>minRollVelocity and VectorStatus~="Finalizing Approach"then mS(bb)nB=r(bk-n5,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end;U=nX;local mG=-1;if BrakeLanding then nB=0;local o9=false;local oa=30;if aN~=nil and aN>0 then local ob=r(ar,0.4,2)local nP=LastMaxBrakeInAtmo*r(bc/100,0.1,1)*ob;local oc=aN*ob+nP-l3;local od=nP/2-l3;local oe=bc-y(d(od/2)*20/(0.5*av))*utils.sign(od)if oe<0 then oe=0 end;local of;if bc>100 then local og,_=aM.computeDistanceAndTime(bc,100,av,0,0,nP)local oh,_=aM.computeDistanceAndTime(100,0,av,0,0,y(nP))of=og+oh else of=aM.computeDistanceAndTime(bc,0,av,0,0,y(nP))end;if of<20 then BrakeIsOn=false else local oi=0;if oe>100 then local oj,_=aM.computeDistanceAndTime(oe,100,av,0,0,oc)local ok,_=aM.computeDistanceAndTime(100,0,av,0,0,aN*ob+y(nP)-l3)oi=oj+ok else oi,_=aM.computeDistanceAndTime(oe,0,av,0,0,aN*ob+y(nP)-l3)end;oi=(oi+15+bc*n3)*1.1;local ol=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if ol then local na=planet:getAltitude(CustomTarget.position)local om=as-na-100;local mZ=CustomTarget.position-bf;local on=y(mZ:len()^2-(as-na)^2)if on>100 then ol=false elseif om<=oi or oi==-1 then BrakeIsOn=true;o9=true else BrakeIsOn=false;o9=true end end;if not ol and CalculateBrakeLandingSpeed then if oi>=oa then BrakeIsOn=true else BrakeIsOn=false end;o9=true end end end;if not bj then aR.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;mG=ao;if mG>-1 then aV=autoRollPreference;if bc<1 or bb:normalize():dot(bd)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bI("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bb:normalize():dot(-gL)<0.999 then BrakeIsOn=true elseif be<-brakeLandingRate and not o9 then BrakeIsOn=true elseif not o9 then BrakeIsOn=false end end;if AutoTakeoff or am then local it,dq,dp;if AutopilotTargetCoords~=nil then it,dq,dp=aL:getPlanetarySystem(0):castIntersections(bf,(AutopilotTargetCoords-bf):normalize(),function(db)return db.radius+db.noAtmosphericDensityAltitude end)end;if bh then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aR.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(nB)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bj and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bc<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;aR.cmdThrottle(0)elseif am then aR.cmdThrottle(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(it==nil or it.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bj then aR.cmdThrottle(0)end;AutopilotAccelerating=true end end;local oo=ao>-1;local op=bk;if(VectorToTarget or am or bp)and not oo and bc>minRollVelocity and ar>0.01 then local jw=math.rad(d(bl))op=bk*d(math.cos(jw))+n5*math.sin(jw)end;local oq=r(nB-op,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then oq=r(nB-op,-85,MaxPitch)elseif ar<0.01 then oq=r(nB-op,-MaxPitch,MaxPitch)end;if d(bl)<5 or VectorToTarget or bp or BrakeLanding or oo or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(oq)local nC=pitchPID:get()U=U+nC end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function mf.ToggleIntoOrbit()b3=false;mq=nil;mr=nil;mw=0;if ar==0 then if IntoOrbit then bI("orOff","AP")IntoOrbit=false;ms=false;mv=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mu=false elseif br then bI("orOn","AP")IntoOrbit=true;aV=true;if mv==nil then mv=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;ms=false;mv=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mu=false end end;function mf.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aV=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aR.cmdCruise(e(aZ))end else b3=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function mf.checkLOS(mT)local it,dp,dq=aL:getPlanetarySystem(0):castIntersections(bf,mT,function(db)if db.noAtmosphericDensityAltitude>0 then return db.radius+db.noAtmosphericDensityAltitude else return db.radius+db.surfaceMaxAltitude*1.5 end end)local iu=dp;if dq~=nil and dp~=nil then iu=math.min(dq,dp)end;if iu~=nil then return it,iu else return nil,nil end end;function mf.ToggleAutopilot()local function os(SpaceTarget)bs=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aR.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if E-mp<1.5 and ar>0 then if not b6 then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bI("orH","OH")end;mp=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else mp=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aQ.UpdateAutopilotTarget()aR.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bI("apSpc","AP")if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bI("vtt","AP")os(SpaceTarget)end else bI("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then b3=false;Autopilot=true elseif not aq then if IntoOrbit then aR.ToggleIntoOrbit()end;b2=planet.noAtmosphericDensityAltitude+LowOrbitHeight;mu=true;b1.AutopilotAlign=true;b1.VectorToTarget=true;ms=false;if not IntoOrbit then aR.ToggleIntoOrbit()end end end else bI("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and br)and not IntoOrbit then WaypointSet=false;b3=false;ms=false;aR.ToggleIntoOrbit()else bI("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bI("apP","AP")am=true;aR.ToggleAltitudeHold()end else bI("apOff","AP")aR.ResetAutopilots(1)end end;function mf.cmdThrottle(cB,ot)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ot then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cB)K=r(A(cB*100,0)/100,-1,1)bi=nil end;function mf.cmdCruise(cB,ot)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ot then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cB)bi=cB end;function mf.ToggleLockPitch()if LockPitch==nil then bI("lkPOn","LP")if not a1 then LockPitch=bk else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bI("lkPOff","LP")LockPitch=nil end end;function mf.ToggleAltitudeHold()if E-mo<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bI("11","EP")else if br then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b2=HoldAltitude;mu=true;if not IntoOrbit then aR.ToggleIntoOrbit()end;ms=true end end;mo=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else mo=E end;if br and ar==0 then b2=as;mu=true;ms=true;aR.ToggleIntoOrbit()if IntoOrbit then mo=E else mo=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;aV=true;LockPitch=nil;b3=false;if ao~=-1 and bc<20 then bI("lfs","LS")AutoTakeoff=true;if mo>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bg then aR.ToggleVerticalTakeoff()end else bI("altOn","AH")AutoTakeoff=false;if mo>-1 then if br then HoldAltitude=as end end;if VertTakeOff then aR.ToggleVerticalTakeoff()end end;if am then HoldAltitude=100000 end else bI("altOff","AH")if IntoOrbit then aR.ToggleIntoOrbit()end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;aV=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;mo=0 end end;function mf.ResetAutopilots(mf)if mf then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bp=nil;if not bh then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;if IntoOrbit then aR.ToggleIntoOrbit()end;aV=autoRollPreference;al=false;an=false;af=0 end;function mf.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aV=autoRollPreference end;if BrakeIsOn then bI("bkOn","B",1)aR.ResetAutopilots()else bI("bkOff","B",1)end end;function mf.BeginReentry()if Reentry then a2="Re-Entry cancelled"bI("reOff","RE")Reentry=false;aV=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;aV=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aZ;bI("par","RE")else Reentry=true;AltitudeHold=true;aV=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bY=c3(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..aZ.." Target Altitude: "..bY;bI("glide","RE")aR.cmdCruise(e(aZ))end;AutoTakeoff=false end;function mf.ToggleAntigrav()if antigrav and not ExternalAGG then if bh then bI("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bI("aggOn","AG")antigrav.activate()antigrav.show()end end end;ao=mB()return mf end;function script.onStart()local ou=false;local function ov()local function ow(ox)local oy=dbHud_1.hasKey;for cf,cg in pairs(ox)do if oy(cg)then local cw=g(dbHud_1.getStringValue(cg))if cw~=nil then _G[cg]=cw;ou=true end end end end;if dbHud_1 then if not useTheseSettings then ow(bO())coroutine.yield()ow(c)else ow(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;ou=false end;coroutine.yield()if ou then a2="Loaded Saved Variables"aD=ResolutionX;aE=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aV=autoRollPreference;aZ=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function oz()local function oA(oB,oC)if oB>oC then oC=oB end;local oD,oE=0,0;if ContainerOptimization>0 then oD=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then oE=FuelTankOptimization*0.05 end;oC=oC*(1-(oD+oE))return oC end;local oF=core.getElementNameById;local oG=fuelX~=0 and fuelY~=0;for cf in pairs(at)do local type=core.getElementTypeById(at[cf])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cf])),'^.*vertical.*$')and core.getElementForwardById(at[cf])[3]>0 then bg=true end end;if o(type,'^.*Space Engine$')then b6=true;if o(tostring(core.getElementTagsById(at[cf])),'^.*vertical.*$')then local oH=core.getElementForwardById(at[cf])if oH[3]<0 then b4=true else b5=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local oI=j(at[cf])if oI>10000 then G=110 elseif oI>1000 then G=55 elseif oI>150 then G=27 end end;aI=aI+j(at[cf])if oG and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local oI=j(at[cf])local lb=l(at[cf])local oB=0;local gx=q()if type=="Atmospheric Fuel Tank"then local oC=400;local oJ=35.03;if oI>10000 then oC=51200;oJ=5480 elseif oI>1300 then oC=6400;oJ=988.67 elseif oI>150 then oC=1600;oJ=182.67 end;oB=lb-oJ;if fuelTankHandlingAtmo>0 then oC=oC+oC*fuelTankHandlingAtmo*0.2 end;oC=oA(oB,oC)aF[#aF+1]={at[cf],oF(at[cf]),oC,oJ,oB,gx}end;if type=="Rocket Fuel Tank"then local oC=320;local oJ=173.42;if oI>65000 then oC=40000;oJ=25740 elseif oI>6000 then oC=5120;oJ=4720 elseif oI>700 then oC=640;oJ=886.72 end;oB=lb-oJ;if fuelTankHandlingRocket>0 then oC=oC+oC*fuelTankHandlingRocket*0.1 end;oC=oA(oB,oC)aH[#aH+1]={at[cf],oF(at[cf]),oC,oJ,oB,gx}end;if type=="Space Fuel Tank"then local oC=600;local oJ=35.03;if oI>10000 then oC=76800;oJ=5480 elseif oI>1300 then oC=9600;oJ=988.67 elseif oI>150 then oC=2400;oJ=182.67 end;oB=lb-oJ;if fuelTankHandlingSpace>0 then oC=oC+oC*fuelTankHandlingSpace*0.2 end;oC=oA(oB,oC)aG[#aG+1]={at[cf],oF(at[cf]),oC,oJ,oB,gx}end end end;if not bg then VertTakeOff,VertTakeOffEngine=false,false end end;local function oK()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cg in pairs(door)do cg.toggle()end end;if switch then for _,cg in pairs(switch)do cg.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cg in pairs(forcefield)do cg.toggle()end end;if antigrav then bh=antigrav.getState()==1;if bh and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and ba:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(aW)if aq and ao~=-1 then aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function oL()local oM={}local function oN()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local oO={[1]=4480,[6]=4480,[7]=6270}for oP,oQ in pairs(b)do b[oP][0]=oN()b[oP][0].systemId=oP;oM[oP]={}for oR,planet in pairs(b[oP])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=oO[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=oP;planet.bodyId=planet.id;oM[oP][oR]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bB[#bB+1]=planet end end end;aK=ch()aL=aK(oM)aM=dD()aO=e6()aQ=lY()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})ov()coroutine.yield()oz()coroutine.yield()aR=me()oK()coroutine.yield()oL()aS=eu()aP=fH()aP.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bu[1]=nil;if radar_1 then bu[1]=radar_1;aS.pickType()end;bI("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cg in pairs(door)do cg.toggle()end end;if switch then for _,cg in pairs(switch)do cg.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cg in pairs(forcefield)do cg.toggle()end end;showHud=bD;cb()if button then button.activate()end;if SetWaypointOnExit then aR.showWayPoint(planet,bf)end;bI("stop","SU")end;function script.onTick(oS)local oT=nil;if oS=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bI("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif oS=="tenthSecond"then local function oU()local oV=system.createData;local oW=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=oW(panelInterplanetary,"value")interplanetaryHeaderText=oV('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=oW(panelInterplanetary,"value")widgetDistanceText=oV('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=oW(panelInterplanetary,"value")widgetTravelTimeText=oV('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=oW(panelInterplanetary,"value")widgetMaxMassText=oV('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=oW(panelInterplanetary,"value")widgetTargetOrbitText=oV('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=oW(panelInterplanetary,"value")widgetCurBrakeDistanceText=oV('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=oW(panelInterplanetary,"value")widgetCurBrakeTimeText=oV('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=oW(panelInterplanetary,"value")widgetMaxBrakeDistanceText=oV('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=oW(panelInterplanetary,"value")widgetMaxBrakeTimeText=oV('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=oW(panelInterplanetary,"value")widgetTrajectoryAltitudeText=oV('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function oX()t(panelInterplanetary)panelInterplanetary=nil end;local function oY()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bf):len()else AutopilotDistance=(CustomTarget.position-bf):len()end end;local e4=bc;local nE=unit.getThrottle()/100;if AtmoSpeedAssist then nE=K end;local oZ,o_=aM.computeDistanceAndTime(bc,MaxGameVelocity,av,a:maxForceForward()*nE,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,p0;if not TurnBurn and e4>0 then _,p0=aR.GetAutopilotBrakeDistanceAndTime(e4)else _,p0=aR.GetAutopilotTBBrakeDistanceAndTime(e4)end;local p1=0;local p2=0;if AutopilotCruising or not Autopilot and e4>5 then p2=aM.computeTravelTime(e4,0,AutopilotDistance)elseif a8+oZ<AutopilotDistance then p1=AutopilotDistance-(a8+oZ)p2=aM.computeTravelTime(8333.0556,0,p1)else local p3=(AutopilotDistance-a8)/oZ;oZ=AutopilotDistance-a8;o_=o_*p3 end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return p2 elseif AutopilotBraking then return p0 elseif AutopilotCruising then return p2+p0 else return o_+a9+p2 end end;local function p4(l3,p5)if l3==nil then l3=core.g()end;l3=A(l3,5)if p5~=nil and p5 or(oT==nil or oT~=l3)then local e4=ba:len()local p6=g(unit.getData()).maxBrake;if p6~=nil and p6>0 and aq then p6=p6/r(e4/100,0.1,1)p6=p6/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+p6)/2 else LastMaxBrakeInAtmo=p6 end end end;if p6~=nil and p6>0 then LastMaxBrake=p6 end;oT=l3 end end;p4(nil,true)if bi~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bi then aR.cmdCruise(bi)else bi=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then oU()end;if AutopilotTargetName~=nil then local p7=CustomTarget~=nil;local p8=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()p8=p8>1000000 and A(p8/1000000,2).." kTons"or A(p8/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=oY()if p7 and not Autopilot then aj=(bf-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bf):len()end;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ii=c3(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ii..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..c6(travelTime)..'", "unit":""}')ii=c3(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ii..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..c6(a9)..'", "unit":""}')ii=c3(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ii..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..c6(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",p8)..'", "unit":""}')ii=c3(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ii..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bj and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then aR.cmdThrottle(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else oX()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aP.TenthTick()elseif oS=="oneSecond"then local function p9(gH)local pa=0;aB=""local pb=aI;local pc=0;local pd=0;local pe=0;local gB=0;local gC=""local pf=core.getElementHitPointsById;for cf in pairs(at)do local oI=0;local pg=0;pg=j(at[cf])oI=pf(at[cf])pc=pc+oI;if oI<pg then if oI==0 then pe=pe+1 else pd=pd+1 end;if aJ and#aA==0 then position=vec3(core.getElementPositionById(at[cf]))local bW=position.x;local bX=position.y;local eZ=position.z;table.insert(aA,core.spawnArrowSticker(bW,bX,eZ+1,"down"))table.insert(aA,core.spawnArrowSticker(bW,bX,eZ+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(bW+1,bX,eZ,"north"))table.insert(aA,core.spawnArrowSticker(bW+1,bX,eZ,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(bW-1,bX,eZ,"south"))table.insert(aA,core.spawnArrowSticker(bW-1,bX,eZ,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(bW,bX-1,eZ,"east"))table.insert(aA,core.spawnArrowSticker(bW,bX-1,eZ,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(bW,bX+1,eZ,"west"))table.insert(aA,core.spawnArrowSticker(bW,bX+1,eZ,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cf])end elseif aJ and#aA>0 and aA[11]==at[cf]then for gw in pairs(aA)do core.deleteSticker(aA[gw])end;aA={}end end;pa=e(pc/pb*100)if pa<100 then gH[#gH+1]=bV(0,0,"","pbright txt")gB=e(pa*2.55)gC=f("rgb(%d,%d,%d)",255-gB,gB,0)if pa<100 then gH[#gH+1]=bV("50%",1035,"Elemental Integrity: "..pa.."%","txtbig txtmid","fill:"..gC)if pe>0 then gH[#gH+1]=bV("50%",1055,"Disabled Modules: "..pe.." Damaged Modules: "..pd,"txtbig txtmid","fill:"..gC)elseif pd>0 then gH[#gH+1]=bV("50%",1055,"Damaged Modules: "..pd,"txtbig txtmid","fill:"..gC)end end end end;local function ph()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bz=core.getPlayersOnBoard()bA=core.getDockedConstructs()ph()local gH={}aP.OneSecond(gH)if ShouldCheckDamage then p9(gH)end;ak=table.concat(gH,"")collectgarbage("collect")elseif oS=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cw=g(dbHud_1.getStringValue("SavedLocations"))if cw~=nil then _G["SavedLocations"]=cw;local fh=-1;local ma;for cf,cg in pairs(SavedLocations)do if cg.name and cg.name=="SatNav Location"then fh=cf;break end end;if fh~=-1 then ma=SavedLocations[fh]fh=-1;for cf,cg in pairs(b[0])do if cg.name and cg.name=="SatNav Location"then fh=cf;break end end;if fh>-1 then b[0][fh]=ma end;aQ.UpdateAtlasLocationsList()a2=ma.name.." position updated"end end;for i=1,#bm do if bm[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bm[i].name)aQ.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif oS=="msgTick"then local gH={}aP.DisplayMessage(gH,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif oS=="animateTick"then aU=true;aT=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif oS=="hudTick"then aP.hudtick()elseif oS=="apTick"then aR.APTick()elseif oS=="radarTick"then aS.UpdateRadar()elseif oS=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function pi(pj,nN)local pk=vec3()local pl=vec3()if pj==axisCommandId.longitudinal then pk=vec3(core.getConstructOrientationForward())pl=b8 elseif pj==axisCommandId.vertical then pk=vec3(core.getConstructOrientationUp())pl=b7 elseif pj==axisCommandId.lateral then pk=vec3(core.getConstructOrientationRight())pl=b9 else return vec3()end;local pm=vec3(core.getWorldGravity())local pn=pm:dot(pl)local po=vec3(core.getWorldAirFrictionAcceleration())local pp=po:dot(pl)local pq=ba:dot(pk)local pr=nN*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(pr-pq)local ps=targetSpeedPID2:get()local pt=(ps-pp-pn)*pl;return pt end;local function pu(pj,nN)local pk=vec3()local pl=vec3()if pj==axisCommandId.longitudinal then pk=vec3(core.getConstructOrientationForward())pl=b8 elseif pj==axisCommandId.vertical then pk=vec3(core.getConstructOrientationUp())pl=b7 elseif pj==axisCommandId.lateral then pk=vec3(core.getConstructOrientationRight())pl=b9 else return vec3()end;local pm=vec3(core.getWorldGravity())local pn=pm:dot(pl)local po=vec3(core.getWorldAirFrictionAcceleration())local pp=po:dot(pl)local pq=ba:dot(pk)local pr=nN*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(pr-pq)local ps=targetSpeedPID:get()local pt=(ps-pp-pn)*pl;return pt end;local function pv(pw,gK,m2)local px=pw:cross(m2):normalize_inplace()local hw=math.acos(r(px:dot(-gK),-1,1))*constants.rad2deg;if px:cross(-gK):dot(m2)<0 then hw=-hw end;return hw end;if antigrav and not ExternalAGG then if not bh and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bj=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bj and O then aR.cmdThrottle(0)O=false elseif not bj and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local py=r(T+U+system.getControlDeviceForwardInput(),-1,1)local pz=r(W+Z+system.getControlDeviceYawInput(),-1,1)local pA=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local pB=Y;bd=vec3(core.getWorldVertical())if bd==nil or bd:len()==0 then bd=(planet.center-bf):normalize()end;b7=vec3(core.getConstructWorldOrientationUp())b8=vec3(core.getConstructWorldOrientationForward())b9=vec3(core.getConstructWorldOrientationRight())bb=vec3(core.getWorldVelocity())ba=vec3(core.getVelocity())bf=vec3(core.getConstructWorldPos())av=core.getConstructMass()bc=vec3(bb):len()be=-bd:dot(bb)bl=getRoll(bd,b8,b9)local pC=bl/180*math.pi;local pD=math.cos(pC)local pE=math.sin(pC)bk=pv(bd,b8,b9*pD+b7*pE)local pF=bb:normalize()local pG=d(bl)local pH=utils.sign(bl)local pI=vec3(core.getWorldAngularVelocity())local pJ=py*pitchSpeedFactor*b9+pz*rollSpeedFactor*b8+pA*yawSpeedFactor*b7;if aV==true and bd:len()>0.01 then local pK=d(aY-bl)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and pK>0 or ar>0.0 and pK<autoRollRollThreshold and autoRollPreference)and pz==0 and d(bk)<85 then local pL=aY;local pM=autoRollFactor;if ar==0 then pM=pM/4;aY=0;pL=0 end;if rollPID==nil then rollPID=pid.new(pM*0.01,0,pM*0.1)end;rollPID:inject(pL-bl)local pN=rollPID:get()pJ=pJ+pN*b8 end end;local pO=1;local pP=0;local pQ=1;local pR=system.getMouseWheel()if pR>0 then bF()elseif pR<0 then bF(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bj then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aZ/3.6-bb:dot(b8))local pS=throttlePID:get()N=r(pS,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-aZ/3.6)local pT=r(brakePID:get(),0,1)if ar>0 and be<-80 or ar>0.005 then L=pT end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pU=''local pV=vec3()local pW=pi(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pW,pP)local pX='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pX=pX..ExtraLongitudeTags end;local pY=s:getAxisCommandType(axisCommandId.longitudinal)local pZ=s:composeAxisAccelerationFromThrottle(pX,axisCommandId.longitudinal)local p_=pu(axisCommandId.lateral,LeftAmount*1000)pU=pU..' , '.."lateral airfoil , lateral ground "pV=pV+p_;if pV:len()>constants.epsilon then a:setEngineForceCommand(pU,pV,pP,'','','',pQ)end;a:setEngineForceCommand(pX,pZ,pO)local q0='thrust analog vertical fueled 'local q1='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then q1=q1 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then q0=q0 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(q0,pW,pO)else a:setEngineForceCommand(q0,vec3(),pO)end;if LeftAmount~=0 then a:setEngineForceCommand(q1,p_,pO)else a:setEngineForceCommand(q1,vec3(),pO)end;if pB==0 then pB=L end;local q2=-pB*(brakeSpeedFactor*bb+brakeFlatFactor*pF)a:setEngineForceCommand('brake',q2)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local nN=unit.getAxisCommandValue(0)if not bj then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-nN/3.6)local pT=r(brakePID:get(),0,1)pB=r(pB+pT,0,1)end;local q2=-pB*(brakeSpeedFactor*bb+brakeFlatFactor*pF)a:setEngineForceCommand('brake',q2)local pU=''local pV=vec3()local q3=false;local pX='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pX=pX..ExtraLongitudeTags end;local pY=s:getAxisCommandType(axisCommandId.longitudinal)if pY==axisCommandType.byThrottle then local pZ=s:composeAxisAccelerationFromThrottle(pX,axisCommandId.longitudinal)a:setEngineForceCommand(pX,pZ,pO)elseif pY==axisCommandType.byTargetSpeed then local pZ=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pU=pU..' , '..pX;pV=pV+pZ;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then q3=true end end;local q1='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then q1=q1 ..ExtraLateralTags end;local q4=s:getAxisCommandType(axisCommandId.lateral)if q4==axisCommandType.byThrottle then local q5=s:composeAxisAccelerationFromThrottle(q1,axisCommandId.lateral)a:setEngineForceCommand(q1,q5,pO)elseif q4==axisCommandType.byTargetSpeed then local p_=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pU=pU..' , '..q1;pV=pV+p_ end;local q0='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then q0=q0 ..ExtraVerticalTags end;local q6=s:getAxisCommandType(axisCommandId.vertical)if q6==axisCommandType.byThrottle then local pW=s:composeAxisAccelerationFromThrottle(q0,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(q0,pW,pO,'airfoil','ground','',pQ)else a:setEngineForceCommand(q0,vec3(),pO)a:setEngineForceCommand('airfoil vertical',pW,pO,'airfoil','','',pQ)a:setEngineForceCommand('ground vertical',pW,pO,'ground','','',pQ)end elseif q6==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),pO)end;local q7=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pU=pU..' , '..q0;pV=pV+q7 end;if pV:len()>constants.epsilon then if Y~=0 or q3 or d(pF:dot(b8))<0.5 then pU=pU..', brake'end;a:setEngineForceCommand(pU,pV,pP,'','','',pQ)end end;local q8=torqueFactor*(pJ-pI)local q9=vec3(core.getWorldAirFrictionAngularAcceleration())q8=q8-q9;a:setEngineTorqueCommand('torque',q8,pO,'airfoil','','',pQ)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local e4=ba:len()local qa=0.15;if not bj then local qb=s:getTargetSpeed(axisCommandId.longitudinal)if e4*3.6>qb*(1-qa)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4*3.6<qb*(1-qa)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nE=unit.getThrottle()if AtmoSpeedAssist then nE=K*100 end;local nN=nE/100;if k==0 then nN=nN*MaxGameVelocity;if e4>=nN*(1-qa)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4<nN*(1-qa)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nY=e(aZ)nN=nN*nY/3.6;if e4>=nN*(1-qa)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4<nN*(1-qa)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fE=coroutine.status(beginSetup)if fE=="suspended"then local cB,fF=coroutine.resume(beginSetup)if fF then system.print("ERROR STARTUP: "..fF)end elseif fE=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aT and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(qc)local function qd(bG)local D=1;local function qe(qf,bG)local qg={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local qh=qf;for _,cg in ipairs(qg)do if bG and qh>cg then qf=cg elseif qf<cg and not bG then qf=cg;break end end;return qf end;if bG then D=-1 end;if not ExternalAGG and bh then if a1 and bG then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then b2=qe(b2,bG)else b2=b2+D*a3 end;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=qe(HoldAltitude,bG)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function qi(qj)if not aq then a2="Flight Assist in Atmo only"return end;local cm=type(qj)if bp==nil then if cm=="table"then if Autopilot or VectorToTarget then aR.ToggleAutopilot()end;bI("180On","BR")elseif qj==1 then bI("bnkLft","BR")else bI("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aR.ToggleAltitudeHold()if cm~="table"then qj=qj+1 end end;bp=qj else bI("180Off","BR")bp=nil end end;if qc=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aR.cmdThrottle(0)if vBooster or hover then if aq and ao==-1 then bI("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aV=true;GearExtended=false else if S then bI("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bI("grOut","LG",1)a.control.extendLandingGears()end else if S then bI("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif qc=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif qc=="forward"then T=T-1 elseif qc=="backward"then if AltIsOn then qi(-bb*5000)else T=T+1 end elseif qc=="left"then if AltIsOn then qi(1)else W=W-1 end elseif qc=="right"then if AltIsOn then qi(3)else W=W+1 end elseif qc=="yawright"then X=X-1 elseif qc=="yawleft"then X=X+1 elseif qc=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif qc=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif qc=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif qc=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif qc=="groundaltitudeup"then qd()elseif qc=="groundaltitudedown"then qd(true)elseif qc=="option1"then toggleView=false;if AltIsOn and a1 then local qk=""for i=1,#bz do qk=qk.."| Name: "..system.getPlayerName(bz[i]).." Mass: "..A(core.getBoardedPlayerMass(bz[i])/1000,1).."t "end;system.print("Onboard: "..qk)return end;aQ.adjustAutopilotTargetIndex()elseif qc=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bz do core.forceDeboard(bz[i])end;a2="Deboarded All Passengers"return end;aQ.adjustAutopilotTargetIndex(1)elseif qc=="option3"then local function ql()aC=not aC;if not aC then bI("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bI("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local qk=""for i=1,#bA do qk=qk.."| ID: "..bA[i].." Mass: "..A(core.getDockedConstructMass(bA[i])/1000,1).."t "end;system.print("Docked Ships: "..qk)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ql()toggleView=false elseif qc=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#bA do core.forceUndock(bA[i])end;a2="Undocked all ships"return end;bp=nil;aR.ToggleAutopilot()elseif qc=="option5"then toggleView=false;aR.ToggleLockPitch()elseif qc=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local qm=shield_1.getVentingCooldown()if qm>0 then a2="Cannot vent again for "..qm.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aR.ToggleAltitudeHold()elseif qc=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif qc=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bI("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bI("gsOn","GS")end;toggleView=false elseif qc=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aR.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bI("gyOn","GA")else bI("gyOff","GA")end end;toggleView=false elseif qc=="lshift"then bw=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;aU=false;aT=false end elseif qc=="brake"then if BrakeToggleStatus or AltIsOn then aR.BrakeToggle()elseif not BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=true end elseif qc=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif qc=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif qc=="stopengines"then local function qn()if E-F<1.5 then bI("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bp=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;aV=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;qn()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aR.cmdThrottle(0)else aR.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then aR.cmdCruise(AtmoSpeedLimit)else aR.cmdCruise(MaxGameVelocity*3.6)end end end elseif qc=="speedup"then bF()elseif qc=="speeddown"then bF(true)elseif qc=="antigravity"and not ExternalAGG then if antigrav~=nil then aR.ToggleAntigrav()end end end;function script.onActionStop(qc)local function qo()if not ExternalAGG and bh then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if qc=="forward"then T=0 elseif qc=="backward"then T=0 elseif qc=="left"then if bp then if bp==2 then bp=-2 else bp=-1 end end;W=0 elseif qc=="right"then if bp then if bp==4 then bp=-2 else bp=-1 end end;W=0 elseif qc=="yawright"then X=0 elseif qc=="yawleft"then X=0 elseif qc=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif qc=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif qc=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qc=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qc=="groundaltitudeup"then qo()toggleView=false elseif qc=="groundaltitudedown"then qo()toggleView=false elseif qc=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then aU=false;aT=false end;a1=false elseif qc=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=false end end elseif qc=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(qc)local function qp(bG)local D=1;if bG then D=-1 end;if not ExternalAGG and bh then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then b2=b2+D*a5;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function qq(bG)local D=1;if bG then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if qc=="groundaltitudeup"then if not a1 then qp()end elseif qc=="groundaltitudedown"then if not a1 then qp(true)end elseif qc=="speedup"then qq()elseif qc=="speeddown"then qq(true)end end;function script.onInputText(bY)local function qr(qs,e8,hs)local function qt(e8)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu='::pos{'..B..','..B..','..B..','..B..','..B..'}'local cI,cJ,cP,cQ,cR=o(e8,cu)if cI=="0"and cJ=="0"then return vec3(z(cP),z(cQ),z(cR))end;cQ=math.rad(cQ)cP=math.rad(cP)local planet=b[z(cI)][z(cJ)]local dA=math.cos(cP)local qu=vec3(dA*math.cos(cQ),dA*math.sin(cQ),math.sin(cP))return planet.center+(planet.radius+cR)*qu end;local position=qt(e8)return aQ.AddNewLocation(qs,position,hs)end;local i;local qv,qw=nil,nil;local qx="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(bY," ")qv=bY;if i~=nil then qv=string.sub(bY,0,i-1)qw=string.sub(bY,i+1)end;if qv=="/help"or qv=="/commands"then for lk in string.gmatch(qx,"([^\n]+)")do system.print(lk)end;return elseif qv=="/setname"then if qw==nil or qw==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aQ.UpdatePosition(qw)else a2="Select a saved target to rename first"end elseif shield_1 and qv=="/resist"then if qw==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cu=B..', '..B..', '..B..', '..B;local qy,qz,qA,qB=o(qw,cu)if qB==nil or qy+qz+qA+qB>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(qy,qz,qA,qB)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif qv=="/addlocation"or string.find(bY,"::pos")~=nil then local hs=false;local qs="0-Temp"if qw==nil or qw==""then qw=qv;hs=true end;i=string.find(qw,"::")if not hs then qs=string.sub(qw,1,i-2)end;local e8=string.sub(qw,i)qr(qs,e8,hs)elseif qv=="/agg"then if qw==nil or qw==""then a2="Usage: /agg targetheight"return end;qw=z(qw)if qw<1000 then qw=1000 end;AntigravTargetAltitude=qw;a2="AGG Target Height set to "..qw elseif qv=="/G"then if qw==nil or qw==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if qw=="dump"then for cf,cg in pairs(bO())do if type(_G[cg])=="boolean"then if _G[cg]==true then system.print(cg.." true")else system.print(cg.." false")end elseif _G[cg]==nil then system.print(cg.." nil")else system.print(cg.." ".._G[cg])end end;return end;i=string.find(qw," ")local qC=string.sub(qw,0,i-1)local qD=string.sub(qw,i+1)for cf,cg in pairs(bO())do if cg==qC then a2="Variable "..qC.." changed to "..qD;local qE=type(_G[cg])if qE=="number"then qD=z(qD)if cg=="AtmoSpeedLimit"then aZ=qD end elseif qE=="boolean"then if string.lower(qD)=="true"then qD=true else qD=false end end;_G[cg]=qD;return end end;a2="No such global variable: "..qC elseif qv=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aQ.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif qv=="/copydatabank"then if dbHud_2 then cb(true)else a2="Spare Databank required to copy databank"end elseif qv=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aR.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(cJ)if bu[1]and not aq and not bn then unit.setTimer("contact",0.1)end end;function script.onLeave(cJ)if bu[1]and CollisionSystem then if#bq>650 then cJ=tostring(cJ)bq[cJ]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
