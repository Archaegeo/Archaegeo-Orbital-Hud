name: ArchHud - Archaegeo v1.5204 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5204;useTheseSettings=false;userControlScheme="virtual joystick"soundFolder="archHUD"freeLookToggle=true;BrakeToggleDefault=true;RemoteFreeze=false;RemoteHud=true;brightHud=false;VanillaRockets=false;InvertMouse=false;autoRollPreference=false;ExternalAGG=false;UseSatNav=false;ShouldCheckDamage=true;CalculateBrakeLandingSpeed=false;AtmoSpeedAssist=true;ForceAlignment=false;DisplayDeadZone=true;showHud=true;hideHudOnToggleWidgets=true;ShiftShowsRemoteButtons=true;SetWaypointOnExit=false;AlwaysVSpd=false;BarFuelDisplay=true;voices=true;alerts=true;CollisionSystem=true;AutoShieldToggle=true;PreventPvP=true;DisplayOdometer=true;YawStallAngle=35;PitchStallAngle=35;brakeLandingRate=30;MaxPitch=30;ReEntryPitch=-30;LockPitchTarget=0;AutopilotSpaceDistance=5000;TargetOrbitRadius=1.2;LowOrbitHeight=2000;AtmoSpeedLimit=1050;SpaceSpeedLimit=30000;AutoTakeoffAltitude=1000;TargetHoverHeight=50;LandingGearGroundHeight=0;ReEntryHeight=100000;MaxGameVelocity=8333.00;AutopilotInterplanetaryThrottle=1.0;warmup=32;fuelTankHandlingAtmo=0;fuelTankHandlingSpace=0;fuelTankHandlingRocket=0;ContainerOptimization=0;FuelTankOptimization=0;ResolutionX=1920;ResolutionY=1080;circleRad=400;SafeR=130;SafeG=224;SafeB=255;PvPR=255;PvPG=0;PvPB=0;centerX=960;centerY=540;throtPosX=1300;throtPosY=540;vSpdMeterX=1525;vSpdMeterY=325;altMeterX=550;altMeterY=540;fuelX=30;fuelY=700;shieldX=1750;shieldY=250;DeadZone=50;OrbitMapSize=250;OrbitMapX=0;OrbitMapY=25;soundVolume=100;speedChangeLarge=5;speedChangeSmall=1;MouseXSensitivity=0.003;MouseYSensitivity=0.003;autoRollFactor=2;rollSpeedFactor=1.5;autoRollRollThreshold=180;minRollVelocity=150;TrajectoryAlignmentStrength=0.002;torqueFactor=2;pitchSpeedFactor=0.8;yawSpeedFactor=1;brakeSpeedFactor=3;brakeFlatFactor=1;DampingMultiplier=40;apTickRate=0.0166667;hudTickRate=0.0666667;ExtraLongitudeTags="none"ExtraLateralTags="none"ExtraVerticalTags="none"BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;saveRoute={}local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab","saveRoute"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=false;local a4=0;local a5=0;local a6=0;local a7=0;local a8=nil;local a9=0;local aa=0;local ab=0;local ac=0;local ad=0;local ae=3;local af=0;local ag=""local ah=false;local ai=false;local aj=false;local ak=-1;local al=""local am=k()>0;local an=k()local ao=core.getAltitude()local ap=core.getElementIdList()local aq=q()local ar=core.getConstructMass()local as=false;local at=nil;local au=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local av=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aw={}local ax=""local ay=ResolutionX;local az=ResolutionY;local aA={}local aB={}local aC={}local aD=0;local aE=false;local aF=nil;local aG=nil;local aH=nil;local aI=nil;local aJ=nil;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=false;local aQ=false;local aR=autoRollPreference;local aS=LandingGearGroundHeight;local aT=false;local aU=0;local aV=AtmoSpeedLimit;local aW=0;local aX=nil;local aY={VectorToTarget=false}local aZ=0;local a_=false;local b0=false;local b1=false;local b2=false;local b3=vec3(core.getConstructWorldOrientationUp())local b4=vec3(core.getConstructWorldOrientationForward())local b5=vec3(core.getConstructWorldOrientationRight())local b6=vec3(core.getVelocity())local b7=vec3(core.getWorldVelocity())local b8=vec3(b7):len()local b9=vec3(core.getWorldVertical())local ba=-b9:dot(b7)local bb=vec3(core.getConstructWorldPos())local bc=false;local bd=false;local be=nil;local bf=true;local bg=0;local bh=0;local bi={}local bj=false;local bk=50000;local bl=nil;local bm={}local bn=unit.getClosestPlanetInfluence()>0 or ao>0 and ao<200000;local bo=false;local bp=nil;local bq=false;local br=0;local bs={}local bt=nil;local bu=nil;local bv={}local bw=90;local bx=showHud;function p(by)system.print(E..": "..by)end;local function bz(bA,bB,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bA.."|"..bB.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bA.."|"..bB.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bA.."|"..bB.."|"..soundVolume)end end;local function bC(bD,bE)for i=1,#bE do bD[#bD+1]=bE[i]end;return bD end;local function bF(bG)local bH={}local bI={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP","DisplayOdometer"}local bJ={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bK={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bL={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bG then bC(bH,bI)bC(bH,bJ)bC(bH,bK)bC(bH,bL)return bH elseif bG=="boolean"then return bI elseif bG=="handling"then return bJ elseif bG=="hud"then return bK elseif bG=="physics"then return bL end end;local function bM(bN,bO,bP,bQ,bR)if bQ==nil then bQ=""end;if bR==nil then bR=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bQ,bN,bO,bR,bP)end;local function bS(bT,bU)if bT==0 then return d(bU)<1e-09 end;if bU==0 then return d(bT)<1e-09 end;return d(bT-bU)<math.max(d(bT),d(bU))*epsilon end;local function bV(af,bW)local bX=af>100000;if bW==nil then bW=1 end;if bX then return A(af/1000/200,bW).."SU"elseif af<1000 then return A(af,bW).."M"else return A(af/1000,bW).."KM"end end;local function bY(bZ)local b_=0;local c0=0;local c1=0;if bZ<60 then bZ=e(bZ)elseif bZ<3600 then b_=e(bZ/60)bZ=e(bZ%60)elseif bZ<86400 then c0=e(bZ/3600)b_=e(bZ%3600/60)else c1=e(bZ/86400)c0=e(bZ%86400/3600)end;if c1>0 then return c1 .."d "..c0 .."h "elseif c0>0 then return c0 .."h "..b_.."m "elseif b_>0 then return b_.."m "..bZ.."s"elseif bZ>0 then return bZ.."s"else return"0s"end end;local function c2(c3)local function c4(c5)for c6,c7 in pairs(c5)do dbHud_1.setStringValue(c7,h(_G[c7]))if c3 and dbHud_2 then dbHud_2.setStringValue(c7,h(_G[c7]))end end end;if dbHud_1 then c4(c)c4(bF())system.print("Saved Variables to Datacore")if c3 and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function c8()local function c9(ca)return type(ca)=='number'end;local function cb(ca)return type(z(ca))=='number'end;local function cc(cd)return type(cd)=='table'end;local function ce(cf)return type(cf)=='string'end;local function cg(c7)return cc(c7)and c9(c7.x and c7.y and c7.z)end;local function ch(ci)return cc(ci)and c9(ci.latitude and ci.longitude and ci.altitude and ci.id and ci.systemId)end;local cj=math.pi/180;local ck=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cl='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cm(ca)local cn=string.gsub(string.reverse(f('%.4f',ca)),'^0*%.?','')return cn==''and'0'or string.reverse(cn)end;local function co(cp)if cg(cp)then return f('{x=%.3f,y=%.3f,z=%.3f}',cp.x,cp.y,cp.z)end;if cc(cp)and not getmetatable(cp)then local cq={}local cr=next(cp)if type(cr)=='nil'or cr==1 then cq=cp else for c6,c7 in pairs(cp)do local cs=co(c7)if type(c6)=='number'then table.insert(cq,f('[%s]=%s',c6,cs))else table.insert(cq,f('%s=%s',c6,cs))end end end;return f('{%s}',table.concat(cq,','))end;if ce(cp)then return f("'%s'",cp:gsub("'",[[\']]))end;return tostring(cp)end;local ct={}ct.__index=ct;ct.__tostring=function(cp,cu)local cv={}for c6 in pairs(cp)do table.insert(cv,c6)end;table.sort(cv)local cq={}for _,c6 in ipairs(cv)do local cs=co(cp[c6])if type(c6)=='number'then table.insert(cq,f('[%s]=%s',c6,cs))else table.insert(cq,f('%s=%s',c6,cs))end end;if cu then return f('%s%s',cu,table.concat(cq,',\n'..cu))end;return f('{%s}',table.concat(cq,','))end;ct.__eq=function(cw,cx)return cw.systemId==cx.systemId and cw.id==cx.id and bS(cw.radius,cx.radius)and bS(cw.center.x,cx.center.x)and bS(cw.center.y,cx.center.y)and bS(cw.center.z,cx.center.z)and bS(cw.GM,cx.GM)end;local function cy(cz,cA,cB,cC,cD)assert(cb(cz),'Argument 1 (systemId) must be a number:'..type(cz))assert(cb(cA),'Argument 2 (id) must be a number:'..type(cA))assert(cb(cB),'Argument 3 (radius) must be a number:'..type(cB))assert(cc(cC),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cC))assert(cb(cD),'Argument 5 (GM) must be a number:'..type(cD))return setmetatable({systemId=z(cz),id=z(cA),radius=z(cB),center=vec3(cC),GM=z(cD)},ct)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cm(p.latitude*ck),cm(p.longitude*ck),cm(p.altitude))end;MapPosition.__eq=function(cw,cx)return cw.id==cx.id and cw.systemId==cx.systemId and bS(cw.latitude,cx.latitude)and bS(cw.altitude,cx.altitude)and(bS(cw.longitude,cx.longitude)or bS(cw.latitude,math.pi/2)or bS(cw.latitude,-math.pi/2))end;local function cE(cF,cA,cG,cH,cI)local cz=cF;if ce(cF)and not cH and not cI and not cA and not cG then cz,cA,cG,cH,cI=o(cF,cl)assert(cz,'Argument 1 (position string) is malformed.')else assert(cb(cz),'Argument 1 (systemId) must be a number:'..type(cz))assert(cb(cA),'Argument 2 (id) must be a number:'..type(cA))assert(cb(cG),'Argument 3 (latitude) must be in degrees:'..type(cG))assert(cb(cH),'Argument 4 (longitude) must be in degrees:'..type(cH))assert(cb(cI),'Argument 5 (altitude) must be in meters:'..type(cI))end;cz=z(cz)cA=z(cA)cG=z(cG)cH=z(cH)cI=z(cI)if cA==0 then return setmetatable({latitude=cG,longitude=cH,altitude=cI,id=cA,systemId=cz},MapPosition)end;return setmetatable({latitude=cj*r(cG,-90,90),longitude=cj*(cH%360),altitude=cI,id=cA,systemId=cz},MapPosition)end;local cJ={}cJ.__index=cJ;cJ.__tostring=function(cp,cu)local cK=cu and cu..'  'local cL={}local cv={}for c6 in pairs(cp)do table.insert(cv,c6)end;table.sort(cv)for _,cM in ipairs(cv)do bdy=cp[cM]local cN=ct.__tostring(bdy,cK)if cu then table.insert(cL,f('[%s]={\n%s\n%s}',cM,cN,cu))else table.insert(cL,f('  [%s]=%s',cM,cN))end end;if cu then return f('\n%s%s%s',cu,table.concat(cL,',\n'..cu),cu)end;return f('{\n%s\n}',table.concat(cL,',\n'))end;local function cO(cP)local b={}local pid;for _,c7 in pairs(cP)do local cA=c7.planetarySystemId;if type(cA)~='number'then error('Invalid planetary system ID: '..tostring(cA))elseif pid and cA~=pid then error('Mistringmatch planetary system IDs: '..cA..' and '..pid)end;local cQ=c7.bodyId;if type(cQ)~='number'then error('Invalid body ID: '..tostring(cQ))elseif b[cQ]then error('Duplicate body ID: '..tostring(cQ))end;setmetatable(c7.center,getmetatable(vec3.unit_x))b[cQ]=setmetatable(c7,ct)pid=cA end;return setmetatable(b,cJ)end;aF={}local function cR(cP)return setmetatable({galaxyAtlas=cP or{}},aF)end;aF.__index=function(cd,i)if type(i)=='number'then local system=cd.galaxyAtlas[i]return cO(system)end;return rawget(aF,i)end;aF.__pairs=function(cp)return function(cd,c6)local cS,nv=next(cd,c6)return cS,nv and cO(nv)end,cp.galaxyAtlas,nil end;aF.__tostring=function(cp)local cT={}for _,cU in pairs(cp or{})do local cV=cU:getPlanetarySystemId()local cW=cJ.__tostring(cU,'    ')table.insert(cT,f('  [%s]={%s\n  }',cV,cW))end;return f('{\n%s\n}\n',table.concat(cT,',\n'))end;aF.BodyParameters=cy;aF.MapPosition=cE;aF.PlanetarySystem=cO;function aF.createBodyParameters(cz,cA,cX,cY,cZ,c_,d0)assert(cb(cz),'Argument 1 (systemId) must be a number:'..type(cz))assert(cb(cA),'Argument 2 (id) must be a number:'..type(cA))assert(cb(cX),'Argument 3 (surfaceArea) must be a number:'..type(cX))assert(cc(cY),'Argument 4 (aPosition) must be an array or vec3:'..type(cY))assert(cc(cZ),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(cZ))assert(cb(c_),'Argument 6 (altitude) must be in meters:'..type(c_))assert(cb(d0),'Argument 7 (gravityAtPosition) must be number:'..type(d0))local cB=y(cX/4/math.pi)local af=cB+c_;local d1=vec3(cY)+af*vec3(cZ)local cD=d0*af*af;return cy(cz,cA,cB,d1,cD)end;aF.isMapPosition=ch;function aF:getPlanetarySystem(cF)if i==nil then i=0 end;if nv==nil then nv=0 end;local cz=cF;if ch(cF)then cz=cF.systemId end;if type(cz)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=cJ then system=cO(system)end;return system end end end;function cJ:sizeCalculator(d2)return 1.05*d2.radius end;function cJ:castIntersections(d3,d4,d5,d6,d7,d8)local d9={}if d7 then for _,d2 in pairs(d7)do table.insert(d9,d2)end else d9=bv end;if not d8 then table.sort(d9,function(da,db)local bT=da.center;local bU=db.center;return(bT.x-d3.x)^2+(bT.y-d3.y)^2+(bT.z-d3.z)^2<(bU.x-d3.x)^2+(bU.y-d3.y)^2+(bU.z-d3.z)^2 end)end;local dc=d4:normalize()for _,d2 in ipairs(d9)do local dd=d2.center-d3;local cB=self:sizeCalculator(d2)local de=dd:dot(dc)local df=de^2-(dd:len2()-cB^2)if df>=0 then local dg=y(df)local dh=de+dg;local di=de-dg;if di>0 then return d2,dh,di elseif dh>0 then return d2,dh,nil end end end;return nil,nil,nil end;function cJ:closestBody(dj)assert(type(dj)=='table','Invalid coordinates.')local dk,d2;local dl=vec3(dj)for _,dm in pairs(self)do local dn=(dm.center-dl):len2()if(not d2 or dn<dk)and dm.name~="Space"then d2=dm;dk=dn end end;return d2 end;function cJ:convertToBodyIdAndWorldCoordinates(cF)local dp=cF;if ce(cF)then dp=cE(cF)end;if dp.id==0 then return 0,vec3(dp.latitude,dp.longitude,dp.altitude)end;local dm=self:getBodyParameters(dp)if dm then return dp.id,dm:convertToWorldCoordinates(dp)end end;function cJ:getBodyParameters(cF)local cA=cF;if ch(cF)then cA=cF.id end;assert(cb(cA),'Argument 1 (id) must be a number:'..type(cA))return self[cA]end;function cJ:getPlanetarySystemId()local _,c7=next(self)return c7 and c7.systemId end;function ct:convertToMapPosition(cC)assert(cc(cC),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cC))local dq=vec3(cC)if self.id==0 then return setmetatable({latitude=dq.x,longitude=dq.y,altitude=dq.z,id=0,systemId=self.systemId},MapPosition)end;local dr=dq-self.center;local af=dr:len()local cI=af-self.radius;local cG=0;local cH=0;if not bS(af,0)then local ds=n(dr.y,dr.x)cH=ds>=0 and ds or 2*math.pi+ds;cG=math.pi/2-math.acos(dr.z/af)end;return setmetatable({latitude=cG,longitude=cH,altitude=cI,id=self.id,systemId=self.systemId},MapPosition)end;function ct:convertToWorldCoordinates(cF)local dp=ce(cF)and cE(cF)or cF;if dp.id==0 then return vec3(dp.latitude,dp.longitude,dp.altitude)end;assert(ch(dp),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dp.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dp.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dt=math.cos(dp.latitude)return self.center+(self.radius+dp.altitude)*vec3(dt*math.cos(dp.longitude),dt*math.sin(dp.longitude),math.sin(dp.latitude))end;function ct:getAltitude(cC)return(vec3(cC)-self.center):len()-self.radius end;function ct:getDistance(cC)return(vec3(cC)-self.center):len()end;function ct:getGravity(cC)local du=self.center-vec3(cC)local dv=du:len2()return self.GM/dv*du/y(dv)end;return setmetatable(aF,{__call=function(_,...)return cR(...)end})end;local function dw()local aH={}local dx=30000000/3600;local dy=dx*dx;local dz=100;function aH.computeAccelerationTime(dA,dB,dC)local dD=dx*math.asin(dA/dx)return(dx*math.asin(dC/dx)-dD)/dB end;function aH.computeDistanceAndTime(dA,dC,dE,dF,dG,dH)dG=dG or 0;dH=dH or 0;local dI=dA<=dC;local dJ=dF*(dI and 1 or-1)/dE;local dK=-dH/dE;local dL=dJ+dK;if dI and dL<=0 or not dI and dL>=0 then return-1,-1 end;local dM,dN=0,0;if dJ~=0 and dG>0 then local dD=math.asin(dA/dx)local dO=math.pi*(dJ/2+dK)local dP=dJ*dG;local dQ=dx*math.pi;local c7=function(cd)local dR=(dO*cd-dP*math.sin(math.pi*cd/2/dG)+dQ*dD)/dQ;local dS=math.tan(dR)return dx*dS/y(dS*dS+1)end;local dT=dI and function(cf)return cf>=dC end or function(cf)return cf<=dC end;dN=2*dG;if dT(c7(dN))then local dU=0;while d(dN-dU)>0.5 do local cd=(dN+dU)/2;if dT(c7(cd))then dN=cd else dU=cd end end end;local dV=dA;local dW=dN/dz;for dX=1,dz do local dY=c7(dX*dW)dM=dM+(dY+dV)*dW/2;dV=dY end;if dN<2*dG then return dM,dN end;dA=dV end;local dD=dx*math.asin(dA/dx)local E=(dx*math.asin(dC/dx)-dD)/dL;local dZ=dy*math.cos(dD/dx)/dL;local af=dZ-dy*math.cos((dL*E+dD)/dx)/dL;return af+dM,E+dN end;function aH.computeTravelTime(dA,dB,af)if af==0 then return 0 end;if dB>0 then local dD=dx*math.asin(dA/dx)local dZ=dy*math.cos(dD/dx)/dB;return(dx*math.acos(dB*(dZ-af)/dy)-dD)/dB end;if dA==0 then return-1 end;assert(dA>0,'Acceleration and initial speed are both zero.')return af/dA end;return aH end;local function d_()local vec3=require('cpml.vec3')local c8=c8()local function ce(cf)return type(cf)=='string'end;local function cc(cd)return type(cd)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cI)assert(self.body)local af=cI+self.body.radius;if not bS(af,0)then local orbit=y(self.body.GM/af)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cF,e0)assert(self.body)assert(cc(cF)or ce(cF))assert(cc(e0))local e1=(ce(cF)or c8.isMapPosition(cF))and self.body:convertToWorldCoordinates(cF)or vec3(cF)local c7=vec3(e0)local e2=e1-self.body.center;local e3=c7:len2()local e4=e2:len()local e5=self.body.GM;local e6=((e3-e5/e4)*e2-e2:dot(c7)*c7)/e5;local bT=e5/(2*e5/e4-e3)local e7=e6:len()local dc=e6:normalize()local e8=bT*(1-e7)local e9=bT*(1+e7)local ea=e8*dc+self.body.center;local eb=e7<=1 and-e9*dc+self.body.center or nil;local ec=y(bT*e5*(1-e7*e7))local ed=eb and 2*math.pi*y(bT^3/e5)local ee=math.acos(e6:dot(e2)/(e7*e4))if e2:dot(c7)<0 then ee=-(ee-2*math.pi)end;local ef=math.acos((math.cos(ee)+e7)/(1+e7*math.cos(ee)))local eg=ef;if eg<0 then eg=eg+2*math.pi end;local eh=eg-e7*math.sin(eg)local ei=0;local ej=0;local ek=0;if ed~=nil then ei=eh/(2*math.pi/ed)ej=ed-ei;ek=ej+ed/2;if ee-math.pi>0 then ej=ei;ek=ej+ed/2 end;if ek>ed then ek=ek-ed end end;return{periapsis={position=ea,speed=ec/e8,circularOrbitSpeed=y(e5/e8),altitude=e8-self.body.radius},apoapsis=eb and{position=eb,speed=ec/e9,circularOrbitSpeed=y(e5/e9),altitude=e9-self.body.radius},currentVelocity=c7,currentPosition=e1,eccentricity=e7,period=ed,eccentricAnomaly=ef,meanAnomaly=eh,timeToPeriapsis=ej,timeToApoapsis=ek,trueAnomaly=ee}end;local function el(em)local dm=c8.BodyParameters(em.systemId,em.id,em.radius,em.center,em.GM)return setmetatable({body=dm},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return el(...)end})end;local function en()local eo={}local ep={}local eq={XS=13,S=27,M=55,L=110,XL=221}local er={}local es;local et;local eu;local ev;local ew;local ex={}local ey="Atmo"local ez;local function eA()local function eB(eC,eD,eE,eF,eG,eH,eI,eJ)eD,eF,eH,eJ=vec3(eD),vec3(eF),vec3(eH),vec3(eJ)local eK,eL,eM=eC*eC,eE*eE,eG*eG;local e3=eF-eD;local eN=e3:normalize()local eO=e3:len()local eP=eH-eD;local eQ=(eP-eP:project_on(eN)):normalize()local eR,eS=eP:dot(eN),eP:dot(eQ)local eT=eR*eR+eS*eS;local eU=eN:cross(eQ)local bN=(eK-eL+eO*eO)/(2*eO)local bO=(eK-eM+eT-2*eR*bN)/(2*eS)local ci=eK-bN^2-bO^2;local eV=y(ci)local eW=eD+eN*bN+eQ*bO+eU*eV;local eX=eD+eN*bN+eQ*bO-eU*eV;if d((eJ-eW):len()-eI)<d((eJ-eX):len()-eI)then return eW else return eX end end;local function eY()local function eZ()local e_=core.getConstructWorldOrientationRight()local e3=core.getConstructWorldOrientationForward()local eP=core.getConstructWorldOrientationUp()local f0=library.systemResolution3(e_,e3,eP,{1,0,0})local f1=library.systemResolution3(e_,e3,eP,{0,1,0})local f2=library.systemResolution3(e_,e3,eP,{0,0,1})return function(f3)return library.systemResolution3(f0,f1,f2,f3)end end;local f4=eZ()local f5=core.getConstructWorldPos()local e1=core.getElementPositionById(1)local f6={e1[1],e1[2],e1[3]}local f7=f4(f6)local f8={f5[1]-f7[1],f5[2]-f7[2],f5[3]-f7[3]}return f8 end;local function f9(fa,e4,fb)local fc=fa.pts;local fd=#fc;local fe=fa.ref;if fd>3 then local ff,fg,fh,fi=fc[fd],fc[fd-1],fc[fd-2],fc[fd-3]fa.ref=fb;local e1=eB(ff[1],ff[2],fg[1],fg[2],fh[1],fh[2],fi[1],fi[2])local bN,bO,eV=e1.x,e1.y,e1.z;if bN==bN and bO==bO and eV==eV then bN=bN+fe[1]bO=bO+fe[2]eV=eV+fe[3]local fj=vec3(bN,bO,eV)if not fa.lastPos then fa.center=fj elseif(fa.lastPos-fj):len()<2 then fa.center=fj;fa.skipCalc=true end;fa.lastPos=fj end;fa.pts={}else local fk={fb[1]-fe[1],fb[2]-fe[2],fb[3]-fe[3]}fc[fd+1]={e4,fk}end end;if radar_1 or radar_2 then aN.assignRadar()end;if ex[1]then es=#ex[1].getConstructIds()local fl=ex[1].getData()local fm=fl:gmatch('{"constructId[^}]*}[^}]*}')if es>0 then local fb=eY()local fn,fo=0,0;ew,ev=0,0;for c7 in fm do local cA,af,fp=c7:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fq=eq[fp]af=z(af)if ex[1].hasMatchingTransponder(cA)==1 then table.insert(ep,cA)end;local fr=ex[1].getConstructType(cA)if CollisionSystem then if fq>27 or fr=="static"or fr=="space"then ew=ew+1;local fs=ex[1].getConstructName(cA)local fa=bm[cA]if fa==nil then fq=fq+G;bm[cA]={pts={},ref=fb,name=fs,i=0,radius=fq,skipCalc=false}fa=bm[cA]end;if not fa.skipCalc then f9(fa,af,fb)fo=fo+1 end;if fa.center then table.insert(er,fa)end end;fn=fn+1;if bn and fn>700 or fo>70 or(not bn and fn>300 or fo>30)then coroutine.yield()fn,fo=0,0 end end end;ev=#er;if ev>0 and b8>20 then local d2,ft,fu,fv;local fw=0;local fx=aG:getPlanetarySystem(0)fv=b7:normalize()while fw<ev do coroutine.yield()local fy={table.unpack(er,fw,math.min(fw+75,ev))}d2,ft,fu=fx:castIntersections(bb,fv,nil,nil,fy,true)if d2 and fu then bp={d2,ft,fu}break end;fw=fw+75 end;if not d2 then bp=nil end else bp=nil end;er={}et=fl:find('identifiedConstructs":%[%]')else eu=fl:find('worksInEnvironment":false')end end end;local function fz()if ex[1]then ey="Atmo"if ex[1].getData():find('worksInAtmosphere":false')then ey="Space"end end end;function eo.pickType()fz()end;function eo.assignRadar()if radar_1 and ex[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then ex[1]=radar_2 end;if ex[1]==radar_2 then fz()end elseif radar_2 and ex[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then ex[1]=radar_1 end;if ex[1]==radar_1 then fz()end end end;function eo.UpdateRadar()local fA=coroutine.status(ez)if fA=="suspended"then local cs,fB=coroutine.resume(ez)if fB then system.print("ERROR UPDATE RADAR: "..fB)end elseif fA=="dead"then ez=coroutine.create(eA)local cs,fB=coroutine.resume(ez)end end;function eo.GetRadarHud(fC,fD,fE,fF)local fG=ep;local fH,by;ep={}local B=ev or 0;if es>0 then if CollisionSystem then by=B.."/"..ew.." Plotted : "..es-ew.." Ignored"else by="Radar Contacts: "..es end;fH=bM(fE,fF,by,"pbright txtbig txtmid")if#ep>0 then fH=fH..bM(fC,fD,"Friendlies In Range","pbright txtbig txtmid")for c6,c7 in pairs(ep)do fD=fD+20;fH=fH..bM(fC,fD,ex[1].getConstructName(c7),"pdim txtmid")end end;if et==nil and perisPanelID==nil then peris=1;aN.ToggleRadarPanel()end;if et~=nil and perisPanelID~=nil then aN.ToggleRadarPanel()end;if radarPanelID==nil then aN.ToggleRadarPanel()end else if eu then fH=bM(fE,fF,ey.." Radar: Jammed","pbright txtbig txtmid")else fH=bM(fE,fF,"Radar: No "..ey.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then peris=0;aN.ToggleRadarPanel()end end;return fH end;function eo.GetClosestName(fs)if ex[1]then local cA,_=ex[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cA~=nil and cA~=""then fs=fs.." "..ex[1].getConstructName(cA)end end;return fs end;function eo.ToggleRadarPanel()if radarPanelID~=nil and peris==0 then t(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then t(perisPanelID)perisPanelID=nil end else if peris==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(ex,1,"Periscope","periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(ex,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;peris=0 end end;ex[1]=nil;if radar_1 then ex[1]=radar_1;fz()end;ez=coroutine.create(eA)return eo end;local function fI()local fJ=9.80665;local fK={}local fL={}local fM={}local bs={}local fN=nil;local fO=nil;local fP=nil;local fQ=false;local fR={}local fS=""local fT=vec3({13771471,7435803,-128971})local fU=18000000;local fV=500000;local fW,fX=math.huge;local fY;local function fZ(f_)fW=vec3(f_):dist(fT)if fW<fU then return true,d(fW-fU)end;fX=vec3(f_):dist(vec3(planet.center))if fX<fV then fY=true else fY=false end;if d(fX-fV)<d(fW-fU)then return fY,d(fX-fV)else return fY,d(fW-fU)end end;local function g0(c7)if ay==1920 then return c7 else return A(ay*c7/1920,0)end end;local function g1(c7)if az==1080 then return c7 else return A(az*c7/1080,0)end end;local function g2()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function g3()local g4="TRAVEL"if not bf then g4="CRUISE"end;if Autopilot then g4="AUTOPILOT"end;return g4 end;local g5={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local fH=""local g6=""local g7=""local g8=1;local g9=2;local ga=3;local gb=4;local gc=5;local gd=6;local ge=""local gf=0;local gg=e(1/apTickRate)*2*hudTickRate;local gh={}local gi={}local gj={}local gk={}local gl={}local gm={}local function gn(bN,go,gp,gq,gr,gs)local gt=tankY;local gu=tankY+5;if not BarFuelDisplay then gu=gu+5 end;if m()==1 and not RemoteHud then gt=gt-50;gu=gu-50 end;if gp=="ATMO"then ge="atmofueltank"elseif gp=="SPACE"then ge="spacefueltank"else ge="rocketfueltank"end;gf=_G[ge.."_size"]if#gq>0 then for i=1,#gq do local fs=string.sub(gq[i][g9],1,12)local gv=0;for gw=1,gf do if gq[i][g9]==g(unit[ge.."_"..gw].getData()).name then gv=gw;break end end;local gx=q()if gr[i]==nil or gs[i]==nil or gx-gq[i][gd]>gg then local gy;local gz=0;if gv~=0 then gs[i]=g(unit[ge.."_"..gv].getData()).percentage;gr[i]=g(unit[ge.."_"..gv].getData()).timeLeft;if gr[i]=="n/a"then gr[i]=0 end else gz=l(gq[i][g8])-gq[i][gb]gs[i]=e(0.5+gz*100/gq[i][ga])gy=gq[i][gc]if gy<=gz then gr[i]=0 else gr[i]=e(0.5+gz/((gy-gz)/(gx-gq[i][gd])))end;gq[i][gc]=gz;gq[i][gd]=gx end end;if fs==go then fs=f("%s %d",gp,i)end;if gv==0 then fs=fs.." *"end;local gA;if gr[i]==0 then gA=""else gA=bY(gr[i])end;if gs[i]~=nil then local gB=e(gs[i]*2.55)local gC=f("rgb(%d,%d,%d)",255-gB,gB,0)local bQ=""if gA~=""and gr[i]<120 or gs[i]<5 then bQ="red "end;local gD=f("rgb(%d,%d,%d)",r(e((255-gB)/2.55),50,100),r(e(gB/2.55),0,50),50)local gE="rgb(196,0,255)"if gp=="ATMO"then gE="rgb(0,188,255)"elseif gp=="SPACE"then gE="rgb(239,255,0)"end;local gF=false;if previous~=gE then gF=true end;previous=gE;if BarFuelDisplay then if gF then gt=gt-5;gu=gu-5 end;g6=g6 ..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gD,gE,bN,gu,gC,e(gs[i]*1.7+0.5)-2,bN+1,gu+1,bN+5,gu+14,fs,gs[i],gA)gt=gt-22;gu=gu-22 else g6=g6 ..bM(bN,gt,fs,bQ.."pdim txtfuel")g6=g6 ..bM(bN,gu,f("%d%% %s",gs[i],gA),"pdim txtfuel","fill:"..gC)gt=gt+30;gu=gu+30 end end end end;tankY=gt end;local function gG(gH,cI)if vSpdMeterX==0 and vSpdMeterY==0 then return end;if cI<200000 and not am or cI and am then local gI=0;if d(ba)>1 then gI=45*math.log(d(ba),10)if ba<0 then gI=-gI end end;gH[#gH+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(ba),e(gI))end;return gH end;local function gJ(gK)local gL=-b9;gK=gK-gK:project_on(gL)local gM=vec3(0,0,1)gM=gM-gM:project_on(gL)local gN=gM:cross(gL)local gI=gM:angle_between(gK)*constants.rad2deg;if gK:dot(gN)<0 then gI=360-gI end;return gI end;local function gO(gH,centerX,centerY,gP,gQ,bn)if circleRad==0 then return end;local gR=circleRad;local gS=20;local gT=e(gP)if bn then for i=-45,45,5 do local gU=i;gH[#gH+1]=f([[<g transform="rotate(%f,%d,%d)">]],gU,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gH[#gH+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gR+gS-len,centerX,centerY+gR+gS)end;gH[#gH+1]=bM(centerX,centerY+gR+gS-35,gQ,"pdim txt txtmid")gH[#gH+1]=bM(centerX,centerY+gR+gS-25,gT.." deg","pdim txt txtmid")gH[#gH+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gP,centerX,centerY)gH[#gH+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gR+gS-20,centerX+5,centerY+gR+gS-20,centerX,centerY+gR+gS-15)gH[#gH+1]="</g>"end;gH[#gH+1]=[[<g style="clip-path: url(#headingClip);">]]local gV=gT;if bn then gV=gJ(b4)end;local gW=20;local gX=e(gV)local gY=0;local gZ=centerY+gR+gS+20;local g_=centerX;if gQ~="YAW"then gZ=g1(130)g_=g0(960)end;local h0=[[<path class="txttick line" d="]]local h1=e(gX-(gW+10)-gX%5+0.5)for i=h1+70,h1,-5 do local bN=g_-(-i*5+gV*5)if i%10==0 then gY=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gH[#gH+1]=bM(bN,gZ+15,B,"txtmid bright")elseif i%5==0 then gY=5 end;if gY==10 then h0=f([[%s M %f %f v %d]],h0,bN,gZ-5,gY)else h0=f([[%s M %f %f v %d]],h0,bN,gZ-2.5,gY)end end;gH[#gH+1]=h0 ..[["/>]]gH[#gH+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],g_-5,gZ-20,g_+5,gZ-20,g_,gZ-10)if DisplayOdometer then if bn then gQ="HDG"end;gH[#gH+1]=bM(g0(960),g1(100),gX.."°","dim txt txtmid size14","")gH[#gH+1]=bM(g0(960),g1(85),gQ,"dim txt txtmid size20","")end;gH[#gH+1]=[[</g>]]end;local function h2(gH,h3,gP,centerX,centerY,bn,h4,dY)if circleRad==0 then return end;local gR=circleRad;local h5=e(gR*3/5)if gR>0 then local h6=e(h3)local len=0;local h0=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gP,centerX,centerY)if not am then h0=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gH[#gH+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gR-1,centerX,centerY)gH[#gH+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(h6-30-h6%5+0.5),e(h6+30+h6%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bO=centerY+-i*5+h3*5;if len==30 then h0=f([[%s M %d %f h %d]],h0,centerX-h5-len,bO,len)if am then gH[#gH+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gP,centerX,centerY,centerX-h5+10,bO+4,i)gH[#gH+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gP,centerX,centerY,centerX+h5-10,bO+4,i)if i==0 or i==180 or i==-180 then gH[#gH+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gP,centerX,centerY,centerX-h5+20,bO,h5*2-40)end else gH[#gH+1]=bM(centerX-h5+10,bO,i,"pdim txt txtmid")gH[#gH+1]=bM(centerX+h5-10,bO,i,"pdim txt txtmid")end;h0=f([[%s M %d %f h %d]],h0,centerX+h5,bO,len)else h0=f([[%s M %d %f h %d]],h0,centerX-h5-len,bO,len)h0=f([[%s M %d %f h %d]],h0,centerX+h5,bO,len)end end;gH[#gH+1]=h0 ..[["/>]]local h7="PITCH"if not bn then h7="REL PITCH"end;if h3>90 and not am then h3=90-(h3-90)elseif h3<-90 and not am then h3=-90-(h3+90)end;if gR>200 then if am then if dY>Q then gH[#gH+1]=bM(centerX,centerY-15,"Yaw","pdim txt txtmid")gH[#gH+1]=bM(centerX,centerY+20,h4,"pdim txt txtmid")end;gH[#gH+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gP,centerX,centerY)else gH[#gH+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gH[#gH+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-h5+25,centerY-5,centerX-h5+20,centerY,centerX-h5+25,centerY+5,centerX-h5+50,centerY+4,h6)gH[#gH+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+h5-25,centerY-5,centerX+h5-20,centerY,centerX+h5-25,centerY+5,centerX+h5-30,centerY+4,h6)gH[#gH+1]="</g>"end;local h8=e(gR/3)gH[#gH+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-h8,centerY,gR-h8)if not am and bn then gH[#gH+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gP,centerX,centerY,centerX-h5+10,centerY,h5*2-20)end;gH[#gH+1]="</g>"if gR<200 then if am and dY>Q then gH[#gH+1]=bM(centerX,centerY-gR,h7,"pdim txt txtmid")gH[#gH+1]=bM(centerX,centerY-gR+10,h6,"pdim txt txtmid")gH[#gH+1]=bM(centerX,centerY-15,"Yaw","pdim txt txtmid")gH[#gH+1]=bM(centerX,centerY+20,h4,"pdim txt txtmid")else gH[#gH+1]=bM(centerX,centerY-gR,h7,"pdim txt txtmid")gH[#gH+1]=bM(centerX,centerY-gR+15,h6,"pdim txt txtmid")end end end end;local function h9(gH,cI,bn)local ha=altMeterX;local hb=altMeterY;if ha==0 and hb==0 then return end;local hc=78;local hd=19;local he=ak;if ak~=-1 then gH[#gH+1]=bM(ha+hc,hb+hd+20,f("AGL: %.1fm",ak),"pdim altsm txtend")end;if bn and(cI<200000 and not am or cI and am)then table.insert(gH,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ha-1,hb-4,hc+2,hd+6,ha+1,hb-1,hc-4,hd))local fd=0;local hf=1;local hg=0;local hh=cI<0;local hi=cI<planet.surfaceMaxAltitude;local hj=9;if hh then hj=0 end;local cI=d(cI)while fd<6 do local hk=11;local hl=16;local hm=9;local hn=14;local bQ="altsm"if fd>2 then hl=hl+3;hk=hk+2;hn=hn+2;hm=hm-6;bQ="altbig"end;if hh then bQ=bQ.." red"elseif hi then bQ=bQ.." orange"end;local ho=cI/hf%10;local hp=e(ho)local hq=e((hp+1)%10)local hr=hg;if fd==0 then hr=ho-hp;if hh then hr=1-hr end end;if hh and(fd==0 or hg~=0)then local hs=hq;hq=hp;hp=hs end;local ht=hl*(hr-1)local hu=ht+hl;local bN=ha+hm+(6-fd)*hk;local bO=hb+hn;gH[#gH+1]=bM(bN,bO+ht,hq,bQ)gH[#gH+1]=bM(bN,bO+hu,hp,bQ)fd=fd+1;hf=hf*10;if hp==hj then hg=hr else hg=0 end end;table.insert(gH,[[</g></g>]])end end;local function hv(e0)local hw=-math.deg(n(e0.y,e0.z))+180;hw=hw-90;if hw<0 then hw=360+hw end;if hw>180 then hw=-180+hw-180 end;return-hw end;local function hx(e0)local gV=math.deg(n(e0.y,e0.x))-90;if gV<-180 then gV=360+gV end;return gV end;local function hy(gH,e0,dY,centerX,centerY)if dY>5 and not am or dY>Q then local gR=circleRad;local hz=20;local hA=20;local hB=hv(e0)local hC=hx(e0)local hD=14;local hE=hD/2;local hF=-hC/hA*gR;local hG=hB/hz*gR;local bN=centerX+hF;local bO=centerY+hG;local af=y(hF^2+hG^2)local hH=[[<circle
                            cx="]]..bN..[["
                            cy="]]..bO..[["
                            r="]]..hE/hD..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bN..[["
                            cy="]]..bO..[["
                            r="]]..hE..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bN-hD..[[,]]..bO..[[ h ]]..hE..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bN+hE..[[,]]..bO..[[ h ]]..hE..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bN..[[,]]..bO-hD..[[ v ]]..hE..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if af<gR then gH[#gH+1]=hH else local gI=n(hG,hF)local hI=4;local hJ=centerX+gR*math.cos(gI)local hK=centerY+gR*math.sin(gI)gH[#gH+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gI*180/math.pi,hJ,hK,hJ-hI,hK-hI/2,hI*2,hI,hJ+hI,hK-hI,hI,hI,-hI,hI)end;if not am then local hL=vec3(e0)hB=hv(-hL)hC=hx(-hL)hF=-hC/hA*gR;hG=hB/hz*gR;bN=centerX+hF;bO=centerY+hG;af=y(hF^2+hG^2)if af<gR then local hM=[[<circle
                                    cx="]]..bN..[["
                                    cy="]]..bO..[["
                                    r="]]..hE..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bN..[[,]]..bO-hD..[[ v ]]..hE..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bN..[[,]]..bO..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bN..[[,]]..bO..[[)" />
                                <path
                                    d="M ]]..bN-hE..[[,]]..bO..[[ h ]]..hD..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bN..[[,]]..bO..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bN..[[,]]..bO..[[)"/>]]gH[#gH+1]=hM end end end end;local function hN(gH,g4,hO,hP)if throtPosX==0 and throtPosY==0 then return end;hO=e(hO+0.5)local gt=throtPosY+10;local gu=throtPosY+20;if m()==1 and not RemoteHud then gt=55;gu=65 end;local hQ="CRUISE"local unit="km/h"local cs=hP;if g4=="TRAVEL"or g4=="AUTOPILOT"then hQ="THROT"unit="%"cs=hO;local hR="dim"if hO<0 then hR="red"end;gH[#gH+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hR,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(hO),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gH[#gH+1]=bM(throtPosX+10,gt,hQ,"pbright txtstart")gH[#gH+1]=bM(throtPosX+10,gu,f("%.0f %s",cs,unit),"pbright txtstart")if am and AtmoSpeedAssist and bf and M then hO=e(N*100+0.5)local hR="red"if hO<0 then hR="red"end;gH[#gH+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hR,1-d(hO),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gH[#gH+1]=bM(throtPosX+10,gt+40,"LIMIT","pbright txtstart")gH[#gH+1]=bM(throtPosX+10,gu+40,hO.."%","pbright txtstart")end;if am and AtmoSpeedAssist or Reentry then gH[#gH+1]=bM(throtPosX+10,gt-40,"LIMIT: "..aV.." km/h","dim txtstart")elseif not am and Autopilot then gH[#gH+1]=bM(throtPosX+10,gt-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hS(gH,hT)if throtPosX==0 and throtPosY==0 then return end;local hU=throtPosY-10;local hV=throtPosX+10;gH[#gH+1]=bM(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then hU=75 end;gH[#gH+1]=bM(hV,hU,e(hT).." km/h","pbright txtbig txtstart")end;local function hW(gH)gH[#gH+1]=bM(g0(1900),g1(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gH[#gH+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gH[#gH+1]=bM(g0(960),g1(550),"Warning: Invalid Control Scheme Detected","warnings")gH[#gH+1]=bM(g0(960),g1(600),"Keyboard Scheme must be selected","warnings")gH[#gH+1]=bM(g0(960),g1(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hX=g0(960)local hY=g1(860)local hZ=g1(880)local h_=g1(900)local i0=g1(960)local i1=g1(200)local i2=g1(250)local i3=g1(960)if m()==1 and not RemoteHud then hY=g1(135)hZ=g1(155)h_=g1(175)i1=g1(115)i2=g1(95)end;local i4="#222222"local i5="white"local i6="dimmer"local i7="pbright"local i8="#110000"local i9=i4;local ia=i6;if BrakeIsOn then gH[#gH+1]=bM(hX,hY,"Brake Engaged","warnings")i8="#440000"i9=i5;ia=i7 elseif L>0 then gH[#gH+1]=bM(hX,hY,"Auto-Brake Engaged","warnings","opacity:"..L)end;local ib="#110000"local ic=i4;local id=i6;if am and aT and ak==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bd and not VertTakeOff and not AutoTakeoff then gH[#gH+1]=bM(hX,i1+50,"** STALL WARNING **","warnings")ib="#ff0000"ic=i5;id=i7;bz("stall","SW",2)end end;if bl then gH[#gH+1]=bM(hX,i1+90,"Flight Assist in Progress","warnings")end;if at then gH[#gH+1]=bM(hX,i3,"Gyro Enabled","warnings")end;local ie="#111100"local ig=i4;local ih=i6;if GearExtended then ie="#775500"ig=i5;ih=i7;if S then gH[#gH+1]=bM(hX,hZ,"Gear Extended","warn")else gH[#gH+1]=bM(hX,hZ,"Landed (G: Takeoff)","warnings")end;local ii=bV(a:getTargetGroundAltitude())gH[#gH+1]=bM(hX,h_,"Hover Height: "..ii,"warn")end;local ij="#000011"local ik=i4;local il=i6;if a3 then ij="#0000DD"ik=i5;il=i7;gH[#gH+1]=bM(hX,i0+20,"ROCKET BOOST ENABLED","warn")end;local im="#001100"local io=i4;local ip=i6;if antigrav and not ExternalAGG and bd and AntigravTargetAltitude~=nil then im="#00DD00"io=i5;ip=i7;if d(ao-antigrav.getBaseAltitude())<501 then gH[#gH+1]=bM(hX,i1+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gH[#gH+1]=bM(hX,i1+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gH[#gH+1]=bM(hX,i1+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gH[#gH+1]=bM(hX,i1+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gH[#gH+1]=bM(hX,i1+20,"Follow Mode Engaged","warn")elseif Reentry or aj then gH[#gH+1]=bM(hX,i1+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ii=bV(HoldAltitude,2)if VertTakeOff then if bd then ii=bV(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gH[#gH+1]=bM(hX,i1,"VTO to "..ii,"warn")elseif AutoTakeoff and not IntoOrbit then if ai then gH[#gH+1]=bM(hX,i1,"Takeoff to "..AutopilotTargetName,"warn")else gH[#gH+1]=bM(hX,i1,"Takeoff to "..ii,"warn")end;if BrakeIsOn and not VertTakeOff then gH[#gH+1]=bM(hX,i1+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gH[#gH+1]=bM(hX,i1,"Altitude Hold: "..ii,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if an>0.1 then gH[#gH+1]=bM(hX,i1+20,"Beginning ascent","warn")elseif an<0.09 and an>0.05 then gH[#gH+1]=bM(hX,i1+20,"Aligning trajectory","warn")elseif an<0.05 then gH[#gH+1]=bM(hX,i1+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if aX~=nil then gH[#gH+1]=bM(hX,i1,aX,"warn")end end;if BrakeLanding then if StrongBrakes then gH[#gH+1]=bM(hX,i1,"Brake-Landing","warnings")else gH[#gH+1]=bM(hX,i1,"Coast-Landing","warnings")end end;if ProgradeIsOn then gH[#gH+1]=bM(hX,i1,"Prograde Alignment","crit")end;if RetrogradeIsOn then gH[#gH+1]=bM(hX,i1,"Retrograde Alignment","crit")end;local iq="#110000"local ir=i4;local is=i6;if bo then iq="#FF0000"ir=i5;is=i7;local type;if string.find(bo,"COLLISION")then type="warnings"else type="crit"end;gH[#gH+1]=bM(hX,i2+20,bo,type)elseif an==0 then local it,iu=aM.checkLOS(b7:normalize())if iu~=nil then is=i7;iq="#FF0000"ir=i5;local ii=bV(iu)local travelTime=aH.computeTravelTime(b8,0,iu)local iv="Collision"if it.noAtmosphericDensityAltitude>0 then iv="Atmosphere"end;gH[#gH+1]=bM(hX,i2+20,it.name.." "..iv.." "..bY(travelTime).." In "..ii,"crit")end end;if VectorToTarget and not IntoOrbit then gH[#gH+1]=bM(hX,i1+35,VectorStatus,"warn")end;local iw="#111100"local ix=i4;local iy=i6;if bt and#bt>1 then iw="#DDDD00"ix=i5;iy=i7 end;local iz=g0;local iA=g1;local i6="topButton"local iB="topButtonActive"local iC=i6;if Autopilot or VectorToTarget or ai or IntoOrbit then iC=iB end;local iD=i6;if ProgradeIsOn then iD=iB end;local iE=i6;if BrakeLanding or GearExtended then iE=iB end;local iF=i6;if AltitudeHold or VectorToTarget then iF=iB end;local iG=i6;if RetrogradeIsOn then iG=iB end;local iH=i6;if IntoOrbit or a_ and Autopilot then iH=iB end;if showHud and DisplayOdometer then local iI=iA(30)gH[#gH+1]=f([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],iC,iz(960),iA(54),iA(-53),iz(-120),iz(25),iA(50))gH[#gH+1]=bM(iz(910),iI,"AUTOPILOT")gH[#gH+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iD,iz(865),iA(51),iz(-25),iA(-50),iz(-110),iz(25),iA(46))gH[#gH+1]=bM(iz(800),iI,"PROGRADE")gH[#gH+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iE,iz(755),iA(47),iz(-25),iA(-46),iz(-98),iz(44),iA(44))gH[#gH+1]=bM(iz(700),iI,"LAND")gH[#gH+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],iF,iz(960),iA(54),iA(-53),iz(120),iz(-25),iA(50))gH[#gH+1]=bM(iz(1010),iI,"ALT HOLD")gH[#gH+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iG,iz(1055),iA(51),iz(25),iA(-50),iz(110),iz(-25),iA(46))gH[#gH+1]=bM(iz(1122),iI,"RETROGRADE")gH[#gH+1]=f([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iH,iz(1165),iA(47),iz(25),iA(-46),iz(98),iz(-44),iA(44))gH[#gH+1]=bM(iz(1220),iI,"ORBIT")gH[#gH+1]=[[
                                    </g>
                                </g>]]gH[#gH+1]="</g>"end;return gH end;local function iJ(dY)return e(A(dY*3.6,0)+0.5).." km/h"end;local function iK(fd)local fs=AutopilotTargetName;if fd~=nil and type(fd)=="number"then if fd==0 then return"None"end;fs=bi[fd].name end;if fs==nil then fs=CustomTarget.name end;if fs==nil then fs="None"end;return fs end;local function iL(gH)local iM=aM.routeWP(true)if#iM==0 then return end;local bN=g0(750)local bO=g1(360)if Autopilot or VectorToTarget then gH[#gH+1]=bM(bN,bO,"REMAINING ROUTE","pdim txtstart size20")else gH[#gH+1]=bM(bN,bO,"LOADED ROUTE","pdim txtstart size20")end;for c6,i in pairs(iM)do bO=bO+20;gH[#gH+1]=bM(bN,bO,c6 ..". "..iK(iM[c6]),"pdim txtstart size20")end end;local function iN(gH)local bN=OrbitMapX+10;local bO=OrbitMapY+20;local iO={}local iP={"Alt-4: AutoTakeoff to Target"}local iQ={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iR={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iS={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iO,"--------------DYNAMIC-----------------")if am then if ak~=-1 then bC(iO,iP)if a8 and planet and a8.name==planet.name then table.insert(iO,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bd then table.insert(iO,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iO,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iO,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iO,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iO,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iO,"G: Takeoff to hover height, raise gear")else table.insert(iO,"G: Lowergear and Land")end else bC(iO,iQ)table.insert(iO,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iO,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bC(iO,iR)if shield_1 then table.insert(iO,"Alt-Shift-5: Toggle shield off and on")table.insert(iO,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iO,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iO,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iO,"Alt-Spacebar/C will raise/lower target height")table.insert(iO,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not am then table.insert(iO,"LALT+Mousewheel will lower/raise speed limit")end;bC(iO,iS)for i=1,#iO do bO=bO+12;gH[#gH+1]=bM(bN,bO,iO[i],"pdim txtbig txtstart")end end;local function iT(gH)local iU=OrbitMapX;local iV=OrbitMapY;local iW=OrbitMapSize;local iX=4;local iY=15;local bN=0;local bO=0;local iZ,i_,j0,j1;local j2;local function j3(type)local j4,E,dY,j5,bQ,j6;if type=="Periapsis"then j4=j2.periapsis.altitude;E=j2.timeToPeriapsis;dY=j2.periapsis.speed;bQ="txtend"j5=12;j6=math.min(bN,iU+iW-planet.radius/j0-iX*2)else j4=j2.apoapsis.altitude;E=j2.timeToApoapsis;dY=j2.apoapsis.speed;j5=-12;bQ="txtstart"j6=bN end;if b8<1 then E=0 end;gH[#gH+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j6+j5,bO-5,bN,bO-5)gH[#gH+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j6-j5*4,bO+2,bN,bO+2)gH[#gH+1]=bM(j6,bO,type,bQ)bN=j6-j5*2;bO=bO+iY;local ii=bV(j4)gH[#gH+1]=bM(bN,bO,ii,bQ)bO=bO+iY;gH[#gH+1]=bM(bN,bO,bY(E),bQ)bO=bO+iY;gH[#gH+1]=bM(bN,bO,iJ(dY),bQ)end;local j7=iW*1.5;if SelectedTab=="INFO"then j7=25*7 end;if SelectedTab~="HIDE"then gH[#gH+1]=[[<g class="pbright txtorb txtmid">]]gH[#gH+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',iW*2,j7,iU,iV)gH[#gH+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],iW*2,j7,iU,iV)end;local j8=iW*1.5;local j9=iW*2;local ja=j8/2;local jb=iW;local jc=iU+jb;local jd=iV+ja;local je=iU+j9;local jf=iV+j8;if SelectedTab=="ORBIT"then iV=iV+iX;iZ=iW/2;j1=0;j2={}j2.periapsis={}j2.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then j2.periapsis.altitude=orbit.periapsis.altitude;j2.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then j2.apoapsis.altitude=orbit.apoapsis.altitude;j2.apoapsis.speed=orbit.apoapsis.speed end;j2.period=orbit.period;j2.eccentricity=orbit.eccentricity;j2.timeToApoapsis=orbit.timeToApoapsis;j2.timeToPeriapsis=orbit.timeToPeriapsis;j2.eccentricAnomaly=orbit.eccentricAnomaly;j2.trueAnomaly=orbit.trueAnomaly end;if j2.periapsis==nil then j2.periapsis={}j2.periapsis.altitude=-planet.radius;j2.periapsis.speed=MaxGameVelocity end;if j2.eccentricity==nil then j2.eccentricity=1 end;if j2.apoapsis==nil then j2.apoapsis={}j2.apoapsis.altitude=ao;j2.apoapsis.speed=0 end;if b8<1 then j2.apoapsis.altitude=ao;j2.apoapsis.speed=0 end;if j2.apoapsis.altitude then j0=(j2.apoapsis.altitude+j2.periapsis.altitude+planet.radius*2)/(iZ*2)i_=(planet.radius+j2.apoapsis.altitude)/j0*(1-j2.eccentricity)j1=iZ-j2.periapsis.altitude/j0-planet.radius/j0;local jg=math.pi;if j2.period~=nil and j2.period>0 and j2.timeToApoapsis~=nil then jg=j2.eccentricAnomaly;if j2.timeToPeriapsis<j2.timeToApoapsis then jg=2*math.pi-jg end end;if b8<1 or jg~=jg then jg=math.pi end;local jh=-iZ*math.cos(jg)+iU+jb+iX;local ji=i_*math.sin(jg)+iV+ja+iX;local jj=""gH[#gH+1]='<g clip-path="url(#orbitRect)">'gH[#gH+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jj,iU+iW+iX,iV+iW*1.5/2+iX,iZ,i_)if i_<1 then gH[#gH+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iU+iW+iX-j1,iV+iW*1.5/2+iX,jh,ji)end;gH[#gH+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iU+iW+iX-j1,iV+iW*1.5/2+iX,(planet.radius+planet.noAtmosphericDensityAltitude)/j0)gH[#gH+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iU+iW+iX-j1,iV+iW*1.5/2+iX,(planet.radius+planet.noAtmosphericDensityAltitude)/j0)gH[#gH+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iU+iW+iX,iV+iW*1.5/2+iX,iZ,i_)gH[#gH+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iU+iW+iX-j1,iV+iW*1.5/2+iX,planet.radius/j0)gH[#gH+1]='</g>'local jk=math.floor(planet.radius/j0+0.5)local jl=g5.Generic_Moon;if g5[planet.name]then jl=g5[planet.name]end;bN=iU+iW+iX*4+iZ;bO=iV+iW*1.5/2+5+iX;if j2.apoapsis~=nil and j2.apoapsis.speed<MaxGameVelocity then j3("Apoapsis")end;bO=iV+iW*1.5/2+5+iX;bN=iU+iW-iX*2-iZ;if j2.periapsis~=nil and j2.periapsis.speed<MaxGameVelocity and j2.periapsis.altitude>0 then j3("Periapsis")end;gH[#gH+1]=bM(iU+iW+iX,iV+20+iX,planet.name,"txtorbbig")gH[#gH+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jh,ji)gH[#gH+1]=[[</g>]]return gH else gH[#gH+1]='<g clip-path="url(#orbitRect)">'local jm=""local jn=1.2*(maxAtlasX-minAtlasX)/(iW*2)local jo=1.4*(maxAtlasY-minAtlasY)/(iW*1.5)for c6,c7 in pairs(b[0])do if c7.center then local bN=iU+iW+c7.center.x/jn;local bO=iV+iW*1.5/2+c7.center.y/jo;jm=jm..'<circle cx="'..bN..'" cy="'..bO..'" r="'..c7.radius/jn*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(c7.name,"Moon")and not string.match(c7.name,"Sanctuary")and not string.match(c7.name,"Space")then jm=jm.."<text x='"..bN.."' y='"..bO+c7.radius/jn*30+20 .."' font-size='12' fill="..au.." text-anchor='middle' font-family='Montserrat'>"..c7.name.."</text>"end end end;local e1=vec3(core.getConstructWorldPos())local bN=iU+iW+e1.x/jn;local bO=iV+iW*1.5/2+e1.y/jo;jm=jm..'<circle cx="'..bN..'" cy="'..bO..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jm=jm.."<text x='"..bN.."' y='"..bO-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fN=jn;fO=jo;local jp=e1+b7*1000000;local jq=iU+iW+jp.x/jn;local gu=iV+iW*1.5/2+jp.y/jo;jm=jm..'<line x1="'..bN..'" y1="'..bO..'" x2="'..jq..'" y2="'..gu..'" stroke="purple" stroke-width="1"/>'gH[#gH+1]=jm;gH[#gH+1]='</g>'end elseif SelectedTab=="INFO"then gH=aK.DrawOdometer(gH,a9,TotalDistanceTravelled,aa)elseif SelectedTab=="HELP"then gH=iN(gH)elseif SelectedTab=="SCOPE"then gH[#gH+1]='<g clip-path="url(#orbitRect)">'local jr=bw;if an>0 then table.sort(bv,function(da,db)local bT,bU=da.center,db.center;return(bT.x-bb.x)^2+(bT.y-bb.y)^2+(bT.z-bb.z)^2<(bU.x-bb.x)^2+(bU.y-bb.y)^2+(bU.z-bb.z)^2 end)end;local eu={}local js={}local jt=120;local ju=nil;local jv=nil;for i,c7 in ipairs(bv)do local et=c7.center-bb;local jw=et:len()local jx=et:normalize()local jy=et:cross(b4):normalize()local jz=math.acos(jy:dot(b5))if jz~=jz then jz=0 end;if jy:cross(b5):dot(b4)<0 then jz=-jz end;local jA=et:project_on_plane(b4):len()local jB=math.sin(jz)*math.asin(jA/jw)*constants.rad2deg;local jC=math.cos(jz)*math.asin(jA/jw)*constants.rad2deg;if jx:dot(b4)<0 then jC=90*math.cos(jz)+90*math.cos(jz)-jC;jB=90*math.sin(jz)+90*math.sin(jz)-jB end;local bN=jc+jB/jr*j8;local bO=jd+jC/jr*j8;local jD=(bN-jc)*(bN-jc)+(bO-jd)*(bO-jd)local jE=math.asin((c7.radius+c7.surfaceMaxAltitude)/jw)*constants.rad2deg;if jE~=jE then jE=jr end;local fp=jE/jr*j8;local jF=math.asin(c7.atmosphereRadius/jw)*constants.rad2deg;if jF~=jF then jF=jE end;local jG=jF/jr*j8;local af=bV(jw,1)local jH=c7.name;local jI=false;if bO>iV then if bO>jf then if bO-jG<=jf then jI=true end else jI=true end else if bO+jG>=iV then jI=true end end;local jJ=false;local jK=bN;if c7.systemId==0 then jK=bN+jt else jK=bN-jt end;if jK+jt>iU then if jK+jt>je then if jK-jG-jt<=je then jJ=true end else jJ=true end else if jK+jG+jt>=iU then jJ=true end end;local jL={}jL.x=bN;jL.y=bO;jL.planet=c7;jL.atmoSize=jG;if not ju or jD<ju then ju=jD;jv=jL end;if jJ and jI then local jM=math.max(jG,5)if jD<jM*jM then jH=jH.." - "..af end;jL.size=fp;jL.i=i;jL.displayString=jH;jL.distance=af;jL.visible=true;js[#js+1]=jL else jL.visible=false end end;local jN=false;table.sort(js,function(bT,bU)return bT.y<bU.y end)for c6,e4 in ipairs(js)do local c7,fp,i,jG,bN,bO,jH,af=e4.planet,e4.size,e4.i,e4.atmoSize,e4.x,e4.y,e4.displayString,e4.distance;local j6,jO,jP,jQ;local jR=15;local bQ="pdim"if c7.systemId~=0 then jP=g0(string.len(jH)*5)jR=-(15+jP)jQ=g1(10)bQ="pdimfill"else jP=g0(string.len(jH)*9)jQ=g1(15)end;if fp*2>jP then j6=r(bN,iU+jP/2,je-jP/2)jO=r(bO,iV+jQ,jf-5)j6=r(j6,bN-fp+jP/2,bN+fp-jP/2)jO=r(jO,bO-fp+jQ,bO+fp)else j6=bN+jR;jO=bO end;for jS,e4 in pairs(eu)do local jT=e4.textPositions;local jU=jT.y-jO;if jS~=i and d(jU)<jT.height and jT.x+jT.width>j6 and jT.x<j6+jP then if fp>jP then jO=r(jO+jQ,iV+15,jf-5)else jO=jT.y+jT.height+1 end end end;local jV=jH~=c7.name or j6<=jc and j6+jP>=jc and jO-jQ<=jd and jO>=jd;e4.hovered=jV;local jW=1;if jV then jW=2;if fp*2<jP then jW=10 end;if jH==c7.name then jH=jH.." - "..af end;bQ="pbright"if c7.systemId~=0 then jP=g0(string.len(jH)*5)jR=-(15+jP)else jP=g0(string.len(jH)*7)end;if fp*2>jP then j6=r(bN,iU+jP/2,je-jP/2)j6=r(j6,bN-fp+jP/2,bN+fp-jP/2)else j6=bN+jR end end;eu[i]={}eu[i].textPositions={}eu[i].textPositions.y=jO;eu[i].textPositions.x=j6;eu[i].textPositions.width=jP;eu[i].textPositions.height=jQ;eu[i].output=""if fp*2>jP then bQ=bQ.." txtmid"else bQ=bQ.." txtstart"end;if jG-fp>2 then eu[i].output=f('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',bN,bO,jG,av,0.1*jW)end;eu[i].output=eu[i].output..f('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',bN,bO,fp,av,0.2*jW)if c7.systemId==0 then eu[i].output=eu[i].output..f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j6,jO,au,bQ,jH)if fp*2<=jP then eu[i].output=eu[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j6+jP,jO+2,j6,jO+2,bN,bO)end else eu[i].output=eu[i].output..f([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j6,jO,av,bQ,jH)if fp*2<=jP then eu[i].output=eu[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j6,jO+2,j6+jP,jO+2,bN,bO)end end end;for c6=#bv,1,-1 do if eu[c6]then gH[#gH+1]=eu[c6].output end end;if jv~=nil and bw<90 and not jv.hovered then local jX=jv.planet.atmosphereRadius/jv.atmoSize;local jY=y(ju)*jX;local jZ=bV(jY,1)local jP=g0(math.max(string.len(jZ)*7,string.len(jv.planet.name)*7))local jQ=g1(12)local j6=r(jv.x+(jc-jv.x)/2,iU+jP/2,je-jP/2)local jO=r(jv.y+(jd-jv.y)/2,iV+jQ*2,jf-5)gH[#gH+1]=f("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",jv.x,jv.y,jc,jd)gH[#gH+1]=f([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j6,jO,"white",jZ)if not jv.visible then gH[#gH+1]=f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j6,jO-jQ,"white",jv.planet.name)end end;if b8>1 then local et=b7;local jx=et:normalize()local jA=et:project_on_plane(b4):len()local jy=et:cross(b4):normalize()local jz=math.acos(jy:dot(b5))if jz~=jz then jz=0 end;if jy:cross(b5):dot(b4)<0 then jz=-jz end;local jB=math.sin(jz)*math.asin(jA/et:len())*constants.rad2deg;local jC=math.cos(jz)*math.asin(jA/et:len())*constants.rad2deg;if jx:dot(b4)<0 then jC=90*math.cos(jz)+90*math.cos(jz)-jC;jB=90*math.sin(jz)+90*math.sin(jz)-jB end;local bN=jc+jB/jr*j8;local bO=jd+jC/jr*j8;local hD=14;local hE=hD/2;local hH=[[<circle
                                    cx="]]..bN..[["
                                    cy="]]..bO..[["
                                    r="]]..hE/hD..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..bN..[["
                                    cy="]]..bO..[["
                                    r="]]..hE..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bN-hD..[[,]]..bO..[[ h ]]..hE..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bN+hE..[[,]]..bO..[[ h ]]..hE..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bN..[[,]]..bO-hD..[[ v ]]..hE..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]gH[#gH+1]=hH end;gH[#gH+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jc,jd-10,jc,jd+10)gH[#gH+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jc-10,jd,jc+10,jd)gH[#gH+1]='</g>'else return gH end end;local function j_(k0,k1)local k2;local k3=(k1-k0):normalize()local e2=(bb-k0):dot(k3)/k3:dot(k3)if e2<=0.then return(bb-k0):len()elseif e2>=(k1-k0):len()then return(bb-k1):len()end;local k4=k0+e2*k3;k2=(k4-bb):len()return k2 end;local function k5()local k2;local k6=nil;local k7=nil;local k8=nil;for c6,k9 in pairs(b[0])do if k9.hasAtmosphere then local af=j_(planet.center,k9.center)if k6==nil or af<k6 then k7=k9;k6=af;k8=planet end;if a8 and a8.hasAtmosphere and a8.name~=planet.name then local dn=j_(a8.center,k9.center)if dn<k6 then k7=k9;k6=dn;k8=a8 end end end end;local ka=g0(1770)local kb=g1(330)if k6 then local kc="txttick "local kd=500000;if k6<k7.radius+kd or k6<k8.radius+kd then if bj then kc="txttick red "else kc="txttick orange "end end;k2=bV(k6,2)fS=bM(ka,kb,"Pipe ("..k8.name.."--"..k7.name.."): "..k2,kc.."pbright txtmid")end end;local function ke(bN,bO,kf,kg,hQ)local kh={x=bN,y=bO,width=kf,height=kg,label=hQ}bs[hQ]=kh;return kh end;local function ki(kj,kk,kf,kg,bN,bO,kl,km,kn,ko,bQ)local kh={enableName=kj,disableName=kk,width=kf,height=kg,x=bN,y=bO,toggleVar=kl,toggleFunction=km,drawCondition=kn,hovered=false,class=bQ}if ko then table.insert(fM,kh)else table.insert(fL,kh)end;return kh end;local function kp(kq)if not fQ then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif kq=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif kq=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif kq=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fR=bF(kq)showHud=false else fR={}showHud=true end end;local function kr()fQ=not fQ;if fQ then fK=fM;a2="Hold SHIFT to see Settings"bx=showHud else fK=fL;a2="Hold SHIFT to see Control Buttons"kp()showHud=bx end end;local function ks()local function kt(c7)_G[c7]=not _G[c7]if _G[c7]then a2=c7 .." set to true"else a2=c7 .." set to false"end;if c7=="showHud"then bx=_G[c7]elseif c7=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local ku=50;local kv=340;local bN=500;local bO=az/2-400;local kw=0;for c6,c7 in pairs(bF("boolean"))do if type(_G[c7])=="boolean"then ki(c7,c7,kv,ku,bN,bO,function()return _G[c7]end,function()kt(c7)end,function()return true end,true)bO=bO+ku+20;if kw==9 then bN=bN+kv+20;bO=az/2-400;kw=0 else kw=kw+1 end end end;ki("Control View","Control View",kv,ku,10,az/2-500,function()return true end,kr,function()return true end,true)ki("View Handling Settings",'Hide Handling Settings',kv,ku,10,az/2-(500-ku),function()return showHandlingVariables end,function()kp("handling")end,function()return true end,true)ki("View Hud Settings",'Hide Hud Settings',kv,ku,10,az/2-(500-ku*2),function()return showHudVariables end,function()kp("hud")end,function()return true end,true)ki("View Physics Settings",'Hide Physics Settings',kv,ku,10,az/2-(500-ku*3),function()return showPhysicsVariables end,function()kp("physics")end,function()return true end,true)end;local function kx()local function ky()local position=bb;local fs=planet.name..". "..#SavedLocations;if radar_1 then fs=aN.GetClosestName(fs)end;return aL.AddNewLocation(fs,position,false,true)end;local function kz()TurnBurn=not TurnBurn end;local function kA(kB)if kB==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kC()aL.UpdatePosition()end;local function kD()aL.ClearCurrentPosition()end;local function kE(fd)local iM=aM.routeWP(true)if#iM>0 then return"Engage Route: "..iK(iM[1])end;return"Engage Autopilot: "..iK(fd)end;local function kF(fd)local iM=aM.routeWP(true)if#iM>0 then return"Next Route Point: "..iK(iM[1])end;return"Disable Autopilot: "..iK(fd)end;local function kG()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bz("folOn","F")else bz("folOff","F")BrakeIsOn=true;aR=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local ku=50;local kv=260;local kH=g0(30)local kI=OrbitMapX+OrbitMapSize*2+2;local kJ=OrbitMapY+1;ki("+","+",kH,kH,kI,kJ+kH+1,function()return false end,function()bw=bw/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")ki("-","-",kH,kH,kI,kJ,function()return false end,function()bw=math.min(bw*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")ki("0","0",kH,kH,kI,kJ+kH*2+2,function()return false end,function()bw=90 end,function()return SelectedTab=="SCOPE"and bw~=90 end,nil,"ZoomButton")local kK=ki("Enable Brake Toggle","Disable Brake Toggle",kv,ku,ay/2-kv/2,az/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)ki("Align Prograde","Disable Prograde",kv,ku,ay/2-kv/2-50-kK.width,az/2-ku+380,function()return ProgradeIsOn end,function()kA(1)end)ki("Align Retrograde","Disable Retrograde",kv,ku,ay/2-kv/2+kK.width+50,az/2-ku+380,function()return RetrogradeIsOn end,kA,function()return an==0 end)apbutton=ki(kE,kF,600,60,ay/2-600/2,az/2-60/2-330,function()return Autopilot or VectorToTarget or ai or IntoOrbit end,function()end)local i;local function kL(kM)local iM=aM.routeWP(true)if#iM>0 then return iM[1]end;local fd=br+kM;if fd>#bi then fd=fd-#bi-1 end;if fd<0 then fd=#bi+fd end;return fd end;apExtraButtons={}for i=0,10 do local button=ki(function(bU)local fd=kL(bU.apExtraIndex)if Autopilot or VectorToTarget or ai or IntoOrbit then return"Redirect: "..iK(fd)end;return kE(fd)end,function(bU)local fd=kL(bU.apExtraIndex)return kF(fd)end,600,60,ay/2-600/2,az/2-60/2-330+60*i,function(bU)local fd=kL(bU.apExtraIndex)return fd==AutopilotTargetIndex and(Autopilot or VectorToTarget or ai or IntoOrbit)end,function(bU)local fd=kL(bU.apExtraIndex)local kN=AutopilotTargetIndex==fd;AutopilotTargetIndex=fd;aL.UpdateAutopilotTarget()aM.ToggleAutopilot()if not kN and not(Autopilot or VectorToTarget or ai or IntoOrbit)then aM.ToggleAutopilot()end end,function()return bq and(#aM.routeWP(true)==0 or i==0)end)button.apExtraIndex=i;apExtraButtons[i]=button end;ki("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,ky,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)ki("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kC,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ki("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kD,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ki("Save Route","Save Route",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y+apbutton.height+20,function()return false end,function()aM.routeWP(false,false,2)end,function()return#aM.routeWP(true)>0 end)ki("Load Route","Clear Route",200,apbutton.height,apbutton.x-200-30,apbutton.y+apbutton.height+20,function()return#aM.routeWP(true)>0 end,function()if#aM.routeWP(true)>0 then aM.routeWP(false,true)elseif Autopilot or VectorToTarget then a2="Disable Autopilot before loading route"return else aM.routeWP(false,false,1)end end,function()return true end)ku=60;kv=300;local bN=0;local bO=az/2-150;ki("View Settings","View Settings",kv,ku,bN,bO,function()return true end,kr)bO=bO+ku+20;ki("Enable Turn and Burn","Disable Turn and Burn",kv,ku,bN,bO,function()return TurnBurn end,kz)bN=10;bO=az/2-300;ki("Horizontal Takeoff Mode","Vertical Takeoff Mode",kv,ku,bN+kv+20,bO,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bc end)bO=bO+ku+20;ki("Engage Orbiting","Cancel Orbiting",kv,ku,bN+kv+20,bO,function()return IntoOrbit end,aM.ToggleIntoOrbit,function()return an==0 and bn end)bO=az/2-150;ki("Glide Re-Entry","Cancel Glide Re-Entry",kv,ku,bN+kv+20,bO,function()return Reentry end,function()ah=1;kA(1)end,function()return planet.hasAtmosphere and not am end)bO=bO+ku+20;ki("Parachute Re-Entry","Cancel Parachute Re-Entry",kv,ku,bN+kv+20,bO,function()return Reentry end,aM.BeginReentry,function()return planet.hasAtmosphere and not am end)bO=bO+ku+20;ki("Engage Follow Mode","Disable Follow Mode",kv,ku,bN,bO,function()return a0 end,kG,function()return m()==1 end)ki("Enable Repair Arrows","Disable Repair Arrows",kv,ku,bN+kv+20,bO,function()return aE end,function()aE=not aE;if aE then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)bO=bO+ku+20;if not ExternalAGG then ki("Enable AGG","Disable AGG",kv,ku,bN,bO,function()return bd end,aM.ToggleAntigrav,function()return antigrav~=nil end)end;ki(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,kv*2,ku,bN,bO,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)bO=bO+ku+20;ki(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,kv*2,ku,bN,bO,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local kO=g1(20)local button=ke(0,0,g0(70),kO,"HELP")button=ke(button.x+button.width,button.y,g0(80),kO,"INFO")button=ke(button.x+button.width,button.y,g0(70),kO,"ORBIT")button=ke(button.x+button.width,button.y,g0(70),kO,"SCOPE")ke(button.x+button.width,button.y,g0(70),kO,"HIDE")end;local kP={}local kQ=nil;function kP.HUDPrologue(gH)bj,bk=fZ(bb)if not bj then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;au=[[rgb(]]..e(H+0.6)..","..e(J+0.6)..","..e(I+0.6)..[[)]]av=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kR=au;local kS=av;local kT=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.4+0.5)..[[)]]local kU=au;local kV=av;local kW=kT;if g2()and not brightHud then kR=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kS=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]kT=[[rgb(]]..e(H*0.2+0.5)..","..e(J*0.2+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iz=g0;local iA=g1;gH[#gH+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .pdimfill {fill: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                    <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="1"/>
                                    </radialGradient>
                                    <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="66%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/>
                                    </radialGradient>                            
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kR,kR,kR,kU,kU,kS,kS,kV,kV,kS,kR,kT,kV,kR,kR,kT,kT,kW,kT,ay,az,kS,kS,kS,kS,kS,kU,kS,kV,kW,kV,kV,kW)if not kQ then kQ=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iz(630),iA(0),iz(675),iA(45),iz(960),iA(55),iz(1245),iA(45),iz(1290),iA(0),iz(1000),iA(105),iz(1040),iA(59),iz(1250),iA(51),iz(1300),iA(0),iz(1920),iA(0),iz(1920),iA(20),iz(1400),iA(20),iz(1300),iA(105),iz(920),iA(105),iz(880),iA(59),iz(670),iA(51),iz(620),iA(0),iz(0),iA(0),iz(0),iA(20),iz(520),iA(20),iz(620),iA(105),iz(890),iA(59),iz(960),iA(62),iz(1030),iA(59),iz(985),iA(112),iz(1150),iA(112),iz(1100),iA(152),iz(820),iA(152),iz(780),iA(112),iz(935),iA(112),iz(890),iA(59),iz(960),iA(62),iz(1030),iA(59),iz(985),iA(112),iz(1150),iA(112),iz(1100),iA(152),iz(820),iA(152),iz(780),iA(112),iz(935),iA(112))end;if showHud and DisplayOdometer then gH[#gH+1]=kQ end;return gH end;function kP.DrawVerticalSpeed(gH,cI)gG(gH,cI)end;function kP.UpdateHud(gH)local hw=bg;local kX=bh;local gP=kX;local h3=hw;local hO=e(unit.getThrottle())local hT=b8*3.6;local hP=unit.getAxisCommandValue(0)local kY=g0(1770)local kZ=g1(310)if AtmoSpeedAssist and bf then hP=K;hO=K*100 end;local g4=g3()local gQ="ROLL"if hO==nil then hO=0 end;if not bn then if b8>5 then hw=hv(b6)kX=hx(b6)else hw=0;kX=0 end;gQ="YAW"end;if bk>50000 and not am then local k_;k_=bV(bk)gH[#gH+1]=bM(kY,kZ,"PvP Boundary: "..k_,"pbright txtbig txtmid")end;gH[#gH+1]=ag;gH[#gH+1]=ax;gH[#gH+1]=fH;if fS~=""then gH[#gH+1]=fS end;if g6~=""then gH[#gH+1]=g6 end;if g7~=""then gH[#gH+1]=g7 end;gG(gH,ao)if m()==0 or RemoteHud then if bn then gO(gH,centerX,centerY,gP,gQ,bn)else gO(gH,centerX,centerY,kX,gQ,bn)end;if not g2()or brightHud then if bn then gO(gH,centerX,centerY,gP,gQ,bn)h2(gH,h3,gP,centerX,centerY,bn,e(hx(b6)),b8)else gO(gH,centerX,centerY,kX,gQ,bn)h2(gH,hw,kX,centerX,centerY,bn,e(kX),b8)end;h9(gH,ao,bn)hy(gH,b6,b8,centerX,centerY)end end;hN(gH,g4,hO,hP)hS(gH,hT)hW(gH)iT(gH)if not fQ and a1 then iL(gH)end;return gH end;function kP.HUDEpilogue(gH)gH[#gH+1]="</svg>"return gH end;function kP.ExtraData(gH)local l0=g0(1240)local l1=g1(55)local l2=l1+10;local l3;local iz=g0;local iA=g1;local l4=0;local g4=g3()if VertTakeOffEngine then g4=g4 .."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and b8>20 then g4=g4 .."-COLLISION ON"end;if UseExtra~="Off"then g4="("..UseExtra..")-"..g4 end;if TurnBurn then g4="TB-"..g4 end;if not stablized then g4=g4 .."-DeCoupled"end;local l5=iA(99)local l6=iA(80)local l7=iA(85)local l8=iA(31)local l9=0;local la=0;local lb=ar>1000000 and A(ar/1000000,2).."kT"or A(ar/1000,2).."T"if am then l4=LastMaxBrakeInAtmo else l4=LastMaxBrake end;local lc,ld=aH.computeDistanceAndTime(b8,0,ar,0,0,l4)if lc<0 then lc=0 end;l4=A(l4/(ar*fJ),2).."g"local le=a:maxForceForward()l3=core.g()if l3>0.1 then la=ar*l3;la=A(la/(ar*fJ),2).."g"l9=0.5*le/l3;l9=l9>1000000 and A(l9/1000000,2).."kT"or A(l9/1000,2).."T"end;le=A(le/(ar*fJ),2).."g"local lf=vec3(core.getWorldAcceleration()):len()/9.80665;l3=core.g()gH[#gH+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then l0=g0(1120)l1=g1(55)l2=l1+10 elseif am and DisplayOdometer then local lg=g0(770)gH[#gH+1]=bM(iz(895),l5,"ATMO","")gH[#gH+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iz(895),l7,iz(-80))gH[#gH+1]=bM(iz(815),l6,f("%.1f%%",an*100),"txtstart size20")end;if DisplayOdometer then gH[#gH+1]=bM(iz(1025),l5,"GRAVITY","txtstart")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(1025),l7,iz(80))gH[#gH+1]=bM(iz(1105),l6,f("%.2fg",l3/9.80665),"size20")gH[#gH+1]=bM(iz(1125),l5,"ACCEL","txtstart")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(1125),l7,iz(80))gH[#gH+1]=bM(iz(1205),l6,f("%.2fg",lf),"size20")gH[#gH+1]=bM(iz(695),l5,"BRK TIME","")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(695),l7,iz(-80))gH[#gH+1]=bM(iz(615),l6,f("%s",bY(ld)),"txtstart size20")gH[#gH+1]=bM(iz(635),iA(45),"TRIP","")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(635),iA(31),iz(-90))if travelTime then gH[#gH+1]=bM(iz(532),iA(23),f("%s",bY(travelTime)),"txtstart size20")end;gH[#gH+1]=bM(iz(795),l5,"BRK DIST","")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(795),l7,iz(-80))gH[#gH+1]=bM(iz(715),l6,f("%s",bV(lc)),"txtstart size20")gH[#gH+1]=bM(iz(1285),iA(45),"MASS","txtstart")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(1285),iA(31),iz(90))gH[#gH+1]=bM(iz(1388),iA(23),f("%s",lb),"size20")gH[#gH+1]=bM(iz(1220),l5,"THRUST","txtstart")gH[#gH+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iz(1220),l7,iz(80))gH[#gH+1]=bM(iz(1300),l6,f("%s",le),"size20")gH[#gH+1]=bM(g0(960),g1(175),g4,"pbright txtbig txtmid size20")end;gH[#gH+1]="</g>"end;function kP.DrawOdometer(gH,a9,TotalDistanceTravelled,aa)if SelectedTab~="INFO"then return gH end;local l3;local l9=0;local la=0;local l4=0;local lb=ar>1000000 and A(ar/1000000,2).." kTons"or A(ar/1000,2).." Tons"if am then l4=LastMaxBrakeInAtmo else l4=LastMaxBrake end;local lc,ld=aH.computeDistanceAndTime(b8,0,ar,0,0,l4)l4=A(l4/(ar*fJ),2).." g"local le=a:maxForceForward()l3=core.g()if l3>0.1 then la=ar*l3;la=A(la/(ar*fJ),2).." g"l9=0.5*le/l3;l9=l9>1000000 and A(l9/1000000,2).." kTons"or A(l9/1000,2).." Tons"end;le=A(le/(ar*fJ),2).." g"if m()==0 or RemoteHud then local lh=g0(OrbitMapX+10)local li=g1(OrbitMapY+20)local lj=g0(OrbitMapX+10+OrbitMapSize/1.25)local kg=25;gH[#gH+1]="<g class='txtstart size14 bright'>"gH[#gH+1]=bM(lh,li,f("BrkTime: %s",bY(ld)))gH[#gH+1]=bM(lj,li,f("Trip: %.2f km",a9))gH[#gH+1]=bM(lh,li+kg,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gH[#gH+1]=bM(lj,li+kg,f("BrkDist: %s",bV(lc)))gH[#gH+1]=bM(lh,li+kg*2,"Trip Time: "..bY(aa))gH[#gH+1]=bM(lj,li+kg*2,"Total Time: "..bY(TotalFlightTime))gH[#gH+1]=bM(lh,li+kg*3,f("Mass: %s",lb))gH[#gH+1]=bM(lj,li+kg*3,f("Max Brake: %s",l4))gH[#gH+1]=bM(lh,li+kg*4,f("Max Thrust: %s",le))if l3>0.1 then gH[#gH+1]=bM(lj,li+kg*4,f("Max Thrust Mass: %s",l9))gH[#gH+1]=bM(lh,li+kg*5,f("Req Thrust: %s",la))else gH[#gH+1]=bM(lj,li+kg*5,"Max Mass: n/a")gH[#gH+1]=bM(lh,li+kg*6,"Req Thrust: n/a")end end;gH[#gH+1]="</g></g>"return gH end;function kP.DrawWarnings(gH)return hW(gH)end;function kP.DisplayOrbitScreen(gH)return iT(gH)end;function kP.DisplayMessage(gH,ii)if ii~="empty"then local bO=310;for lk in string.gmatch(ii,"([^\n]+)")do bO=bO+35;gH[#gH+1]=bM("50%",bO,lk,"msg")end end;if ae~=0 then unit.setTimer("msgTick",ae)ae=0 end end;function kP.DrawDeadZone(gH)gH[#gH+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kP.UpdatePipe()if am then fS=""return end;k5()end;function kP.DrawSettings(gH)if#fR>0 then local bN=g0(640)local bO=g1(200)gH[#gH+1]=[[<g class="pbright txtvspd txtstart">]]for c6,c7 in pairs(fR)do gH[#gH+1]=bM(bN,bO,c7 ..": ".._G[c7])bO=bO+20;if c6%12==0 then bN=bN+g0(350)bO=g1(200)end end;gH[#gH+1]=bM(g0(640),g1(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gH[#gH+1]="</g>"end;return gH end;local perisPanelID;local fE=g0(1770)local fF=g1(350)local fD=g1(15)local fC=g0(1370)local by,ll;local peris=0;function kP.DrawRadarInfo()fH=aN.GetRadarHud(fC,fD,fE,fF)end;function kP.DrawTanks()if fuelX~=0 and fuelY~=0 then g6=bM(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gn(fuelX,"Atmospheric ","ATMO",aA,gl,gm)gn(fuelX,"Space Fuel T","SPACE",aB,gj,gk)gn(fuelX,"Rocket Fuel ","ROCKET",aC,gh,gi)end end;function kP.DrawShield()local lm=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local ln=core.getPvPTimer()local lo=shield_1.getResistances()local lp="A: "..10+lo[1]*100 .."% / E: "..10+lo[2]*100 .."% / K:"..10+lo[3]*100 .."% / T: "..10+lo[4]*100 .."%"local bN,bO=shieldX-60,shieldY+30;local lq=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gB=e(lq*2.55)local gC=f("rgb(%d,%d,%d)",255-gB,gB,0)local bQ=""g7=bM(bN,bO,"","txtmid pdim txtfuel")if lq<10 and lm~="Shield Disabled"then bQ="red "end;ln=ln>0 and"   PvPTime: "..bY(ln)or""g7=g7 ..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bN,bO,gC,lq*2,bN,bO,bN+2,bO+10,lq,ln)g7=g7 ..bM(bN,bO-5,lm,bQ.."txtstart pbright txtbig")g7=g7 ..bM(bN,bO+30,lp,bQ.."txtstart pbright txtsmall")end;function kP.hudtick()if not planet then return end;local function lr(gH)local gE=e(r(af/(ay/4)*255,0,255))gH[#gH+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ac,ad,e(H+0.5)+gE,e(J+0.5)-gE,e(I+0.5)-gE)end;local function ls()for _,c7 in pairs(fK)do if c7.hovered then if not c7.drawCondition or c7.drawCondition(c7)then c7.toggleFunction(c7)end;c7.hovered=false end end;for _,c7 in pairs(bs)do if c7.hovered then SelectedTab=c7.label;c7.hovered=false end end end;local function lt()local function lu(lv,lw,bN,bO,kf,kg)if lv>=bN and lv<=bN+kf and lw>=bO and lw<=bO+kg then return true else return false end end;local bN=ac+ay/2;local bO=ad+az/2;for _,c7 in pairs(fK)do c7.hovered=lu(bN,bO,c7.x,c7.y,c7.width,c7.height)end;for _,c7 in pairs(bs)do c7.hovered=lu(bN,bO,c7.x,c7.y,c7.width,c7.height)end;if bq then local jV=false;for _,bU in ipairs(apExtraButtons)do if bU.hovered then jV=true;break end end;if apbutton.hovered then jV=true end;bq=jV else bq=apbutton.hovered;if not bq then br=AutopilotTargetIndex end end end;local function lx(gH)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;if showHud then for c6,c7 in pairs(bs)do local bQ="dim brightstroke"local ly=0.2;if SelectedTab==c6 then bQ="pbright dimstroke"ly=0.6 end;local lz=""if c7.hovered then ly=0.8;lz=";stroke:white"end;gH[#gH+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],c7.width,c7.height,c7.x,c7.y,bQ,ly,lz)gH[#gH+1]=bM(c7.x+c7.width/2,c7.y+c7.height/2+5,c7.label,"txt txtmid pdim")end end end;local function lA(gH)local function lB(gH,lC,hover,bN,bO,dR,lD,lE,lF,lG,lH,button)if type(lG)=="function"then lG=lG(button)end;if type(lH)=="function"then lH=lH(button)end;gH[#gH+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bN,bO,dR,lD)if lC then gH[#gH+1]=f("%s'",lE)else gH[#gH+1]=lF end;if hover then gH[#gH+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gH[#gH+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gH[#gH+1]=" rx='5'></rect>"gH[#gH+1]=f("<text x='%f' y='%f' font-size='24' fill='",bN+dR/2,bO+lD/2+5)if lC then gH[#gH+1]="black"else gH[#gH+1]="white"end;gH[#gH+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lC then gH[#gH+1]=f("%s</text>",lG)else gH[#gH+1]=f("%s</text>",lH)end end;local lI=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local lJ=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local lK=lB;for _,c7 in pairs(fK)do local kk=c7.disableName;local kj=c7.enableName;if type(kk)=="function"then kk=kk(c7)end;if type(kj)=="function"then kj=kj(c7)end;if not c7.drawCondition or c7.drawCondition(c7)then lK(gH,c7.toggleVar(c7),c7.hovered,c7.x,c7.y,c7.width,c7.height,lJ,lI,kk,kj,c7)end end end;local lL=A(ay/2,0)local lM=A(az/2,0)local gH={}aK.HUDPrologue(gH)if showHud then aK.UpdateHud(gH)else if AlwaysVSpd then aK.DrawVerticalSpeed(gH,ao)end;aK.DrawWarnings(gH)end;if fQ and fR~={}then aK.DrawSettings(gH)end;if radar_1 then aK.DrawRadarInfo()end;aK.HUDEpilogue(gH)gH[#gH+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ay,az)if a2~="empty"then aK.DisplayMessage(gH,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aK.DrawDeadZone(gH)end end;lx(gH)if x()==0 then if m()==1 and a1 then if not AltIsOn then lt()lA(gH)end;if not aP and not aQ then local lN=table.concat(gH,"")gH={}gH[#gH+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ay,az)gH[#gH+1]=lN;gH[#gH+1]="</body>"aP=true;gH[#gH+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gH,"")system.setScreen(content)elseif aQ then local lN=table.concat(gH,"")gH={}gH[#gH+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ay,az)gH[#gH+1]=lN;gH[#gH+1]="</body>"end;if not aP then gH[#gH+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lL,lM,ac,ad)end else ls()end else if not a1 and m()==0 then ls()if af>DeadZone then if DisplayDeadZone then lr(gH)end end elseif a1 and(not AltIsOn or not freeLookToggle)then lt()lA(gH)end;gH[#gH+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lL,lM,ac,ad)end;gH[#gH+1]=[[</svg></body>]]content=table.concat(gH,"")end;function kP.TenthTick()aK.DrawTanks()if shield_1 then aK.DrawShield()end end;function kP.OneSecond(gH)local function lO()local gx=q()local hT=b8;local lP=gx-aq;if hT>1.38889 then hT=hT/1000;local lQ=hT*(gx-aq)TotalDistanceTravelled=TotalDistanceTravelled+lQ;a9=a9+lQ end;aa=aa+lP;TotalFlightTime=TotalFlightTime+lP;aq=gx end;lO()aK.UpdatePipe()aK.ExtraData(gH)end;function kP.ButtonSetup()ks()kx()fK=fL end;return kP end;local function lR()local function lS(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function lT()local function lU(lV,lW)return lV.name<lW.name end;bi={}for c6,c7 in pairs(b[0])do bi[#bi+1]={name=c7.name,index=c6}end;table.sort(bi,lU)end;local function lX(lY)for c6,c7 in pairs(lY)do if c7.name and c7.name==CustomTarget.name then return c6 end end;return-1 end;local function lZ()br=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"a8=nil;CustomTarget=nil;return true end;local l_=bi[AutopilotTargetIndex].index;local m0=b[0][l_]if m0.center then AutopilotTargetName=m0.name;a8=aG[0][l_]if CustomTarget~=nil then if an==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=m0;for _,c7 in pairs(aG[0])do if c7.name==CustomTarget.planetname then a8=c7;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(a8.center)else AutopilotTargetCoords=CustomTarget.position end;if a8.planetname~="Space"then if a8.hasAtmosphere then AutopilotTargetOrbit=e(a8.radius*(TargetOrbitRadius-1)+a8.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(a8.radius*(TargetOrbitRadius-1)+a8.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aJ(a8):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function m1(gL)if not Autopilot and not VectorToTarget and not ai and not IntoOrbit and not Reentry and not aj then if gL==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bi then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bi end end;if AutopilotTargetIndex==0 then lZ()else local l_=bi[AutopilotTargetIndex].index;local m0=b[0][l_]if m0~=nil and m0.name=="Space"or iphCondition=="Custom Only"and m0.center or iphCondition=="No Moons"and string.find(m0.name,"Moon")~=nil then if gL==nil then m1()else m1(1)end else lZ()end end else a2="Disengage autopilot before changing Interplanetary Helper"bz("iph","AP")end end;local function kD()local fd=-1;fd=lX(b[0])if fd>-1 then table.remove(b[0],fd)end;fd=-1;fd=lX(SavedLocations)if fd~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fd)end;m1()lT()end;local function ky(fs,position,hs,m2)if dbHud_1 or hs then local p=lS(position)local l3=p.gravity;if m2 then l3=unit.getClosestPlanetInfluence()end;local m3={position=position,name=fs,planetname=p.name,gravity=l3,safe=m2}if not hs then SavedLocations[#SavedLocations+1]=m3 else for c6,c7 in pairs(b[0])do if c7.name and fs==c7.name then table.remove(b[0],c6)end end end;table.insert(b[0],m3)lT()lZ()a2="Location saved as "..fs.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local m4={}function m4.UpdateAtlasLocationsList()lT()end;function m4.UpdateAutopilotTarget()lZ()end;function m4.adjustAutopilotTargetIndex(gL)m1(gL)end;function m4.findAtlasIndex(lY)lX(lY)end;function m4.UpdatePosition(m5)local fd=lX(SavedLocations)if fd~=-1 then if m5~=nil then SavedLocations[fd].name=m5;AutopilotTargetIndex=AutopilotTargetIndex-1;m1()else local m6=SavedLocations[fd]m6.gravity=unit.getClosestPlanetInfluence()m6.position=bb;m6.safe=true end;a2=SavedLocations[fd].name.." position updated ("..SavedLocations[fd].planetname..")"else a2="Name Not Found"end end;function m4.AddNewLocation(fs,position,hs,m2)ky(fs,position,hs,m2)end;function m4.ClearCurrentPosition()kD()end;for c6,c7 in pairs(SavedLocations)do table.insert(b[0],c7)end;lT()if AutopilotTargetIndex>#bi then AutopilotTargetIndex=0 end;m4.UpdateAutopilotTarget()return m4 end;local function m7()local m8={}local function m9(dY)local ma=AutopilotEndSpeed;if not Autopilot then ma=0 end;if not am then return aH.computeDistanceAndTime(dY,ma,ar,0,0,LastMaxBrake-AutopilotPlanetGravity*ar)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aH.computeDistanceAndTime(dY,ma,ar,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*ar)else return 0,0 end end end;local function mb(dY)local ma=AutopilotEndSpeed;if not Autopilot then ma=0 end;return aH.computeDistanceAndTime(dY,ma,ar,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*ar)end;local mc=false;local md=0;local me=0;local mf=0;local mg=q()local mh=0;local mi=0;local mj=0;local mk=0;local ml=false;local mm=false;local mn=false;local mo=nil;local mp=0;local mq={}function m8.GetAutopilotBrakeDistanceAndTime(dY)return m9(dY)end;function m8.GetAutopilotTBBrakeDistanceAndTime(dY)return mb(dY)end;local function mr(ms,mt,mu)mt=mt:project_on_plane(ms)mu=mu:project_on_plane(ms)return n(mt:cross(mu):dot(ms),mt:dot(mu))end;local function mv()local function mw()local mx=-1;local my=-1;if vBooster then mx=vBooster.getDistance()end;if hover then my=hover.getDistance()end;if mx~=-1 and my~=-1 then if mx<my then return mx else return my end elseif mx~=-1 then return mx elseif my~=-1 then return my else return-1 end end;local mz=mw()local mA=-1;if telemeter_1 then mA=telemeter_1.getDistance()end;if mz~=-1 and mA~=-1 then if mz<mA then return mz else return mA end elseif mz~=-1 then return mz else return mA end end;local function mB(planet,dj,mC)local function mD(mE,cC)local dq=vec3(cC)if mE.id==0 then return setmetatable({latitude=dq.x,longitude=dq.y,altitude=dq.z,id=0,systemId=mE.systemId},MapPosition)end;local dr=dq-mE.center;local af=dr:len()local cI=af-mE.radius;local cG=0;local cH=0;if not bS(af,0)then local ds=n(dr.y,dr.x)cH=ds>=0 and ds or 2*math.pi+ds;cG=math.pi/2-math.acos(dr.z/af)end;return setmetatable({latitude=math.deg(cG),longitude=math.deg(cH),altitude=cI,id=mE.id,systemId=mE.systemId},MapPosition)end;local mF=mD(planet,dj)mF="::pos{"..mF.systemId..","..mF.id..","..mF.latitude..","..mF.longitude..","..mF.altitude.."}"if mC then return mF else system.setWaypoint(mF)return true end end;local mG=false;function m8.changeSpd(mH)local D=1;if mH then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and as then local mI=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and mI<0 then K=0;as=false end elseif AltIsOn then if an>0 or Reentry then aV=r(aV+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or ai or IntoOrbit then br=br+1*D*-1;if br>#bi then br=1 end;if br<1 then br=#bi end else if not mH then D=1 else D=nil end;aL.adjustAutopilotTargetIndex(D)end end end;function m8.showWayPoint(planet,dj,mC)return mB(planet,dj,mC)end;function m8.APTick()local function mJ()if bp and not BrakeLanding then local d2=bp[1]local ft,fu=bp[2],bp[3]local mK=math.min(ft,fu or ft)local mL=mK/b8;local mM=AutoTakeoff and(b8<42 or ak~=-1)local mN=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mN and not mM and(a4*1.5>mK or mL<1)then BrakeIsOn=true;aM.cmdThrottle(0)if AltitudeHold then aM.ToggleAltitudeHold()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then mq={}aM.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aR=true end;if mL<11 then bo=d2.name.." COLLISION "..bY(mL).." / "..bV(mK,2)else bo=d2.name.." collision "..bY(mL)end;if mL<6 then bz("alarm","AL",2)end else bo=false end end;local function mO(mP,mQ,mR)local function mS(mP,d4)mP=vec3(mP)d4=vec3(d4):normalize()local cn=mP*d4;return cn.x+cn.y+cn.z end;local mT=0.001;local mU=1;if not am or not aT or ak~=-1 or b8<Q then if mR==nil then mR=DampingMultiplier end;if mQ==nil then mQ=mT end;mP=vec3(mP):normalize()local mV=vec3()-mP;local mW=-mS(mV,core.getConstructWorldOrientationRight())*mU;local mX=-mS(mV,core.getConstructWorldOrientationUp())*mU;if me==0 then me=mW/2 end;if mf==0 then mf=mX/2 end;if d(mW)<0.1 then V=V-mW*2 else V=V-(mW+(mW-me)*mR)end;if d(mX)<0.1 then U=U+mX*2 else U=U+mX+(mX-mf)*mR end;me=mW;mf=mX;if d(mW)<mQ and d(mX)<mQ then return true end;return false elseif aT and ak==-1 then mP=b7;if mR==nil then mR=DampingMultiplier end;if mQ==nil then mQ=mT end;mP=vec3(mP):normalize()local mV=b4-mP;local mW=-mS(mV,core.getConstructWorldOrientationRight())*mU;local mX=-mS(mV,core.getConstructWorldOrientationUp())*mU;if me==0 then me=mW/2 end;if mf==0 then mf=mX/2 end;if d(mW)<0.1 then V=V-mW*5 else V=V-(mW+(mW-me)*mR)end;if d(mX)<0.1 then U=U+mX*5 else U=U+mX+(mX-mf)*mR end;me=mW;mf=mX;if d(mW)<mQ and d(mX)<mQ then return true end;return false end end;am=k()>0;an=k()ao=core.getAltitude()ak=mv()E=q()mg=E;if CollisionSystem then mJ()end;if antigrav then bd=antigrav.getState()==1 end;local mY=1;local mZ=1;local m_=E-mg;local n0=-math.deg(mr(b3,b7,b4))local n1=math.deg(mr(b5,b7,b4))local gL=b9*-1;aT=am and n0<-YawStallAngle or n0>YawStallAngle or n1<-PitchStallAngle or n1>PitchStallAngle;local n2=system.getMouseDeltaX()local n3=system.getMouseDeltaY()if InvertMouse and not a1 then n3=-n3 end;V=0;Z=0;U=0;sys=aG[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aJ(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),b7)if ao==0 then ao=(bb-planet.center):len()-planet.radius end;bn=unit.getClosestPlanetInfluence()>0 or ao>0 and ao<200000;local l3=planet:getGravity(core.getConstructWorldPos()):len()*ar;aU=0;aI=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aP then ac=r(ac+n2,-ay/2,ay/2)ad=r(ad+n3,-az/2,az/2)end else ac=0;ad=0 end else ac=r(ac+n2,-ay/2,ay/2)ad=r(ad+n3,-az/2,az/2)af=y(ac*ac+ad*ad)if not a1 and m()==0 then local hF,hG=n2,n3;if SelectedTab=="SCOPE"then hF,hG=bw/90,bw/90 end;if userControlScheme=="virtual joystick"then if ac>0 and ac>DeadZone then V=V-(ac-DeadZone)*MouseXSensitivity*hF elseif ac<0 and ac<DeadZone*-1 then V=V-(ac+DeadZone)*MouseXSensitivity*hF else V=0 end;if ad>0 and ad>DeadZone then U=U-(ad-DeadZone)*MouseYSensitivity*hG elseif ad<0 and ad<DeadZone*-1 then U=U-(ad+DeadZone)*MouseYSensitivity*hG else U=0 end else ac=0;ad=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(n3,-100,100)+0.5)*2*mY;V=(-utils.smoothstep(n2,-100,100)+0.5)*2*mZ end end end end;local n4=b8>8334;if b8>SpaceSpeedLimit/3.6 and not am and not Autopilot and not n4 then a2="Space Speed Engine Shutoff reached"aM.cmdThrottle(0)end;if not n4 and LastIsWarping then if not BrakeIsOn then aM.BrakeToggle()end;if Autopilot then aM.ToggleAutopilot()end end;LastIsWarping=n4;if am and an>0.09 then if b8>aV/3.6 and not AtmoSpeedAssist and not mc then BrakeIsOn=true;mc=true elseif not AtmoSpeedAssist and mc then if b8<aV/3.6 then BrakeIsOn=false;mc=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if ah then BrakeIsOn=false;local n5=false;if CustomTarget and ah~=1 then n5=mO(CustomTarget.position-bb,0.1)else n5=mO(vec3(b7),0.01)end;aR=true;if n5 then aM.cmdCruise(e(aV))if(d(bh)<2 or d(bg)>85)and b8>=aV/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if ah~=1 then aj=true end;ah=false;Autopilot=false;aM.BeginReentry()end elseif am and AtmoSpeedAssist then aM.cmdThrottle(1)end elseif b8>Q then mO(vec3(b7),0.01)end end;if RetrogradeIsOn then if am then RetrogradeIsOn=false elseif b8>Q then mO(-vec3(b7))end end;if not ProgradeIsOn and ah and not IntoOrbit then if an==0 then R=true;aM.BeginReentry()ah=false;aj=true else ah=false;aM.ToggleAutopilot()end end;if aj and CustomTarget and(ao<HoldAltitude+250 and ao>HoldAltitude-250)and b8*3.6>aV-250 and d(ba)<25 and an>=0.1 and(CustomTarget.position-bb):len()>2000+ao then aM.ToggleAutopilot()aj=false end;if VertTakeOff then aR=true;local n6=HoldAltitude;if ba<-30 then a2="Unable to achieve lift. Safety Landing."ab=0;aR=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bd or HoldAltitude<planet.spaceEngineMinAltitude then if bd then n6=antigrav.getBaseAltitude()end;if ao<n6-100 then aW=0;ab=15;BrakeIsOn=false elseif ba>0 then BrakeIsOn=true;ab=0 elseif ba<-30 then BrakeIsOn=true;ab=15 elseif ao>=n6 then if bd then if Autopilot or VectorToTarget then aM.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bz("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bz("vtoc","VT")aM.ToggleVerticalTakeoff()end;ab=0 end else if an>0.08 then aW=0;BrakeIsOn=false;ab=20 elseif an<0.08 and an>0 then BrakeIsOn=false;if b1 then aW=0;ab=20 else ab=0;aW=36;aM.cmdCruise(3500)end else aR=autoRollPreference;IntoOrbit=true;a_=false;CancelIntoOrbit=false;ml=false;mj=nil;mk=nil;if mo==nil then mo=planet end;aZ=n6;mn=true;VertTakeOff=false end end;if aW~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local n7=r(aW-bg,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(n7)local n8=r(vTpitchPID:get(),-1,1)U=n8 end end;if IntoOrbit then local mV;local n9=false;local na=bV(aZ)if mo==nil then mo=planet;if VectorToTarget then mo=a8 end end;if not mn then aZ=e(mo.radius+mo.surfaceMaxAltitude+LowOrbitHeight)if mo.hasAtmosphere then aZ=e(mo.radius+mo.noAtmosphericDensityAltitude+LowOrbitHeight)end;mn=true end;if aY.VectorToTarget and CustomTarget then mV=CustomTarget.position-bb end;local nb,nc=aJ(mo):escapeAndOrbitalSpeed((bb-mo.center):len()-mo.radius)local nd=bh;if not ml then local ne=false;local nf=false;aM.cmdThrottle(0)mk=0;aX="Aligning to orbital path - OrbitHeight: "..na;if aY.VectorToTarget then mO(mV:normalize():project_on_plane(b9))n9=b4:dot(mV:project_on_plane(b3):normalize())>0.95 else mO(b7)n9=n0<0.5;if b8<150 then n9=true end end;U=0;mj=0;if bg<=mj+1 and bg>=mj-1 then ne=true else ne=false end;if nd<=mk+1 and nd>=mk-1 then nf=true else nf=false end;if ne and nf and n9 then mj=nil;mk=nil;ml=true end else if aY.VectorToTarget then mO(mV:normalize():project_on_plane(b9))elseif b8>150 then mO(b7)end;U=0;if aY.VectorToTarget and CustomTarget then local a4,_=aH.computeDistanceAndTime(b8,aV/3.6,ar,0,0,LastMaxBrake)if a_ and mV:len()>15000+a4+ao then aX="Orbiting to Target"if ao-100<=mo.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<mo.noAtmosphericDensityAltitude then a_=false end elseif a_ or mV:len()<15000+a4+ao then a2="Orbit complete, proceeding with reentry"bz("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;aj=true;aY.VectorToTarget,aY.AutopilotAlign=false,false;aM.ToggleIntoOrbit()aM.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and ao>aZ*0.9 and ao<aZ*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=aZ*0.99 and orbit.apoapsis.altitude>=aZ*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or a_ then if a_ then BrakeIsOn=false;aM.cmdThrottle(0)mj=0;if not aY.VectorToTarget then a2="Orbit complete"bz("orCom","OB")aM.ToggleIntoOrbit()end else mp=mp+1;if mp>=2 then a_=true end end else aX="Adjusting Orbit - OrbitHeight: "..na;mm=true;aM.cmdCruise(nc*3.6+1)local ng=aZ-ao;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(ng-ba*r(utils.smoothstep(2000-ng,-2000,2000)^6*10,1,10))mj=r(VSpdPID:get(),-60,60)end end else local nh=2.75;local ni=d(A(nb*nh))local nj=ni%50;if nj>0 then ni=ni-nj+50 end;BrakeIsOn=false;if ao<aZ*0.8 then aX="Escaping planet gravity - OrbitHeight: "..na;mj=utils.map(ba,200,0,-15,80)elseif ao>=aZ*0.8 and ao<aZ*1.15 then aX="Approaching orbital corridor - OrbitHeight: "..na;ni=ni*0.75;mj=utils.map(ba,100,-100,-15,65)elseif ao>=aZ*1.15 and ao<aZ*1.5 then aX="Approaching orbital corridor - OrbitHeight: "..na;ni=ni*0.75;if ba<0 or mm then mj=utils.map(ao,aZ*1.5,aZ*1.01,-30,0)else mj=utils.map(ao,aZ*0.99,aZ*1.5,0,30)end elseif ao>aZ*1.5 then aX="Reentering orbital corridor - OrbitHeight: "..na;mj=-65;local nk=utils.map(ba,-150,-400,1,0.55)ni=ni*nk end;aM.cmdCruise(e(ni))end end;if mj~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local nl=mj-bg;OrbitPitchPID:inject(nl)local nm=r(OrbitPitchPID:get(),-0.5,0.5)U=nm end end;if Autopilot and an==0 and not ah then local function nn(by,orbit)system.print(by)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aM.cmdThrottle(0)P=false;a2=by;bz("apCom","AP")if orbit or ah then if orbit and AutopilotTargetOrbit~=nil and not ah then if not ao or ao==0 then return end;aZ=ao;mn=true end;aM.ToggleIntoOrbit()end end;local no,np=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local nq=(CustomTarget.position-a8.center):normalize()local nr=nq:project_on_plane((a8.center-bb):normalize()):normalize()local ns=a8.center+nr*(a8.radius+AutopilotTargetOrbit)local nt=CustomTarget.position+(CustomTarget.position-a8.center):normalize()*(AutopilotTargetOrbit-a8:getAltitude(CustomTarget.position))if(bb-ns):len()<(bb-nt):len()then no=ns else no=nt;AutopilotEndSpeed=0 end;AutopilotTargetCoords=no;aM.showWayPoint(a8,AutopilotTargetCoords)np=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;np=true;AutopilotRealigned=true;TargetSet=true;no=CustomTarget.position+(bb-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=no end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local nq=(bb+b7*100000-a8.center):normalize()local nr=nq:project_on_plane((a8.center-bb):normalize()):normalize()if nr:len()<1 then nq=(bb+b4*100000-a8.center):normalize()nr=nq:project_on_plane((a8.center-bb):normalize()):normalize()end;no=a8.center+nr*(a8.radius+AutopilotTargetOrbit)AutopilotTargetCoords=no;TargetSet=true;np=true;AutopilotRealigned=true;aM.showWayPoint(a8,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(no)-bb):len()local it,dh,di=aG:getPlanetarySystem(0):castIntersections(bb,b7:normalize(),function(d2)if d2.noAtmosphericDensityAltitude>0 then return d2.radius+d2.noAtmosphericDensityAltitude else return d2.radius+d2.surfaceMaxAltitude*1.5 end end)local iu=dh;if di~=nil and dh~=nil then iu=math.min(di,dh)end;if iu~=nil and iu<AutopilotDistance and it.name==a8.name then AutopilotDistance=iu end;local n5=true;local nu=(a8.center-(bb+vec3(b7):normalize()*AutopilotDistance)):len()-a8.radius;local ii=bV(nu)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ii..'"}')local a4,a5;if not TurnBurn then a4,a5=m9(b8)else a4,a5=mb(b8)end;if b8>50 and AutopilotAccelerating then local mV=vec3(no)-bb;local nw=r(math.deg(mr(b3,b7:normalize(),mV:normalize()))*b8/500,-90,90)local nx=r(math.deg(mr(b5,b7:normalize(),mV:normalize()))*b8/500,-90,90)if d(nw)<20 and d(nx)<20 then nw=nw*2;nx=nx*2 end;if d(nw)<2 and d(nx)<2 then nw=nw*2;nx=nx*2 end;local n0=-math.deg(mr(b3,b4,b7:normalize()))local n1=-math.deg(mr(b5,b4,b7:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(nx-n1)local ny=r(apPitchPID:get(),-1,1)U=U+ny;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(nw-n0)local nz=r(apYawPID:get(),-1,1)V=V+nz;np=true;if d(nw)>2 or d(nx)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bz("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bz("apAcc","AP")end end elseif AutopilotAccelerating and b8<=50 then mO((no-bb):normalize())end;if nu<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aJ(a8):escapeAndOrbitalSpeed(nu)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local it,iu=aM.checkLOS((AutopilotTargetCoords-bb):normalize())if a8.name~=planet.name then if it~=nil and a8.name~=it.name and iu<AutopilotDistance then a2="Collision with "..it.name.." in "..bV(iu).."\nClear LOS to continue."ae=5;mG=true else mG=false;a2=""end end end;if not mG then if not AutopilotCruising and not AutopilotBraking and not np then n5=mO((no-bb):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then n5=mO(-vec3(b7):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aM.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local nA=unit.getThrottle()if AtmoSpeedAssist then nA=K end;local nB=99999;local lf=-vec3(core.getWorldAcceleration()):dot(b7:normalize())local nC=r(b7:dot((no-bb):normalize()),0,b8)if nC>0 or lf>0 then nB=aH.computeTravelTime(nC,lf,AutopilotDistance-a4)end;if b6:len()>=MaxGameVelocity or nA==0 and P or warmup/4>nB then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bz("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aM.cmdThrottle(0)end;local nD=AutopilotDistance;if nD<=a4 or PreventPvP and bk<=a4+10000 and bj then if PreventPvP and bk<=a4+10000 and bj then if bk<md and bk>2000 then aM.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;md=bk else md=bk;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bz("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aM.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aM.cmdThrottle(1,true)end;local _,nc=aJ(a8):escapeAndOrbitalSpeed((bb-planet.center):len()-planet.radius)local mV;if CustomTarget then mV=CustomTarget.position-bb end;if CustomTarget and CustomTarget.planetname=="Space"and b8<50 then if#mq>0 then BrakeIsOn=false;aM.ToggleAutopilot()aM.ToggleAutopilot()return end;nn("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and b8<=nc and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then nn("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;ah=true;aM.showWayPoint(a8,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bz("apCir","AP")AutopilotStatus="Circularizing"end;if b8<=nc then if CustomTarget then if b7:normalize():dot(mV:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bz("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aM.showWayPoint(a8,CustomTarget.position)WaypointSet=true end else nn("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;ah=true;aM.showWayPoint(a8,CustomTarget.position)WaypointSet=false end else nn("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then nn("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nD=AutopilotDistance;if nD<=a4 or PreventPvP and bk<=a4+10000 and bj then if PreventPvP and bk<=a4+10000 and bj then if bk<md and bk>2000 then aM.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;md=bk else md=bk;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bz("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local nA=unit.getThrottle()if AtmoSpeedAssist then nA=K end;if nA>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bz("apAcc","AP")end;AutopilotCruising=false end else if n5 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not ah then AutopilotTargetCoords=vec3(a8.center)+(AutopilotTargetOrbit+a8.radius)*b5;AutopilotShipUp=b3;AutopilotShipRight=b5 end;AutopilotRealigned=true elseif n5 and not mG then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bz("apAcc","AP")end;if not P then aM.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and an>0)then a2="Autopilot complete, starting reentry"bz("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aM.cmdThrottle(0)P=false;ProgradeIsOn=true;ah=true;aM.showWayPoint(a8,CustomTarget.position)end;if a0 then aR=true;local nx=0;local e1=bb+vec3(unit.getMasterPlayerRelativePosition())local nE=e1-bb;local nF=vec3(nE):project_on(b4):len()local nG=vec3(nE):project_on(b5):len()local af=y(nF*nF+nG*nG)mO(nE:normalize())local jw=40;local nH=af<jw;local nI=100;local nJ=r((af-jw)/2,10,nI)U=0;local n5=d(V)<0.1;if n5 and b8<nJ and not nH then BrakeIsOn=false;nx=-20 else BrakeIsOn=true;nx=0 end;local nK=0;if d(nx-bg)>nK then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(nx-bg)local ny=pitchPID:get()U=ny end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local nL=LastMaxBrakeInAtmo;if nL then nL=nL*r(b8/100,0.1,1)*an else nL=LastMaxBrake end;if an<0.01 then nL=LastMaxBrake end;local nM=b4:project_on_plane(b9):normalize():dot(b7)local nN=vec3(core.getWorldAirFrictionAcceleration())local nO=nN:len()*ar;if nM>100 then a4,a5=aH.computeDistanceAndTime(nM,100,ar,0,0,nL)local nP,nQ=aH.computeDistanceAndTime(100,0,ar,0,0,nL*0.55)a4=a4+nP else a4,a5=aH.computeDistanceAndTime(nM,0,ar,0,0,nL*0.55)end;local ng=HoldAltitude-ao-ba;local nR=200+b8;if Reentry or ah then minMax=2000+b8 end;local nS=1;if AutoTakeoff then nS=r(b8/100,0.1,1)end;local nx=(utils.smoothstep(ng,-nR,nR)-0.5)*2*MaxPitch*nS;if not Reentry and not ah and not VectorToTarget and b4:dot(b7:normalize())<0.99 then nx=(utils.smoothstep(ng,-nR*r(20-19*an*10,1,20),nR*r(20-19*an*10,1,20))-0.5)*2*MaxPitch*r(2-an*10,1,2)*nS end;if not AltitudeHold then nx=0 end;if LockPitch~=nil then if bn and not IntoOrbit then nx=LockPitch else LockPitch=nil end end;aR=true;local nT=U;if Reentry then local nU=e(aV)local nV,nW=aH.computeDistanceAndTime(b8,nU/3.6,ar,0,0,LastMaxBrake-planet.gravity*9.8*ar)nV=nV==-1 and 5000 or nV;local nX=ao-(planet.noAtmosphericDensityAltitude+nV)local nY=ao>planet.noAtmosphericDensityAltitude+nV*1.35;if nY then nx=ReEntryPitch;if b8<=nU/3.6 and b8>nU/3.6-10 and d(b7:normalize():dot(b4))>0.9 and not bf then O=false;aM.cmdThrottle(1)end elseif bf and not nY and not am then aM.cmdCruise(nU,true)end;if bf then if b8>nU/3.6 and not nY then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if ba>0 then BrakeIsOn=true end;if not R then nx=-80;if an>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;nx=0;aR=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and nY then aR=true elseif not nY then if not am and(bf or s:getTargetSpeed(axisCommandId.longitudinal)~=nU)then aM.cmdCruise(nU)end;if b8<nU/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;aR=true end end end;if b8>Q and not ai and not VectorToTarget and not BrakeLanding and ForceAlignment then mO(vec3(b7))end;if bl or(VectorToTarget or ai)and AutopilotTargetIndex>0 and an>0.01 then local mV;if bl then if type(bl)=="table"then mV=bl elseif bl<3 and bl>0 then mV=-b9:cross(b7)*5000 elseif bl>=3 then mV=b9:cross(b7)*5000 elseif bl<0 then mV=b7*25000 end elseif CustomTarget~=nil then mV=CustomTarget.position-bb else mV=a8.center-bb end;local nw=math.deg(mr(b9:normalize(),b7,mV))*2;local jz=math.rad(d(bh))if b8>minRollVelocity and an>0.01 then local nZ=1000+b8;local n_=(utils.smoothstep(ng-ba*10,-nZ,nZ)-0.5)*2*MaxPitch;local o0=r(90-n_,0,180)aU=r(nw*2,-o0,o0)local o1=nw;nw=r(r(nw,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jz)+4*(bg-nx)*math.sin(math.rad(bh)),-YawStallAngle*0.80,YawStallAngle*0.80)local o2=1;if aU~=0 then o2=d(jz/aU)end;o2=(90-r(d(aU-bh),0,90))/90;local o3=nx;if d(bh)>90 then o3=-o3 end;nx=o2*r(r(o3*math.cos(jz),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(o1)*math.sin(jz),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aU=0;nw=r(nw,-YawStallAngle*0.80,YawStallAngle*0.80)end;local o4=n0-nw;if bl and d(o4)<=0.0001 and(type(bl)=="table"or type(bl)~="table"and bl<0 and d(bh)<1)then if bl==-2 then aM.ToggleAltitudeHold()end;bl=nil;bz("180Off","BR")return end;if not aT and b8>minRollVelocity and an>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(o4)local nz=r(yawPID:get(),-1,1)V=V+nz elseif am and ak>-1 or b8<minRollVelocity then mO(mV)elseif aT and an>0.01 then if(n0<-YawStallAngle or n0>YawStallAngle)and an>0.01 then mO(b7)end;if(n1<-PitchStallAngle or n1>PitchStallAngle)and an>0.01 then nx=r(bg-n1,bg-PitchStallAngle*0.80,bg+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ai then local n6=planet:getAltitude(CustomTarget.position)local nX=mV:project_on_plane(b9):len()StrongBrakes=true;if not ai and not Reentry and nX<=a4 and(b7:project_on_plane(b9):normalize():dot(mV:project_on_plane(b9):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"if#mq>0 then aM.ToggleAutopilot()aM.ToggleAutopilot()return end;aM.cmdThrottle(0)if AltitudeHold then aM.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(nM<0.1 or nX<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<nX)then if not bd then bz("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bo=false end;LastDistanceToTarget=nX end elseif VectorToTarget and an==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ai or Reentry)then if CustomTarget~=nil and a8.name==planet.name then local mV=CustomTarget.position-bb;local n6=planet:getAltitude(CustomTarget.position)local nX=y(mV:len()^2-(ao-n6)^2)local nL=LastMaxBrakeInAtmo;if nL then a4,a5=aH.computeDistanceAndTime(b8,0,ar,0,0,nL/2)StrongBrakes=true;if nX<=a4+b8*m_/2 and b7:project_on_plane(b9):normalize():dot(mV:project_on_plane(b9):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;ah=false;aj=true;Autopilot=false;aM.BeginReentry()end end;LastDistanceToTarget=nX end end end;if an==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ai or IntoOrbit or Reentry)then if not a_ and not IntoOrbit then aZ=HoldAltitude;mn=true;if VectorToTarget then aY.VectorToTarget=true end;aM.ToggleIntoOrbit()VectorToTarget=false;ml=true end end;if aT and an>0.01 and ak==-1 and b8>minRollVelocity and VectorStatus~="Finalizing Approach"then mO(b7)nx=r(bg-n1,bg-PitchStallAngle*0.80,bg+PitchStallAngle*0.80)end;U=nT;local mA=-1;if BrakeLanding then nx=0;local o5=false;local o6=30;if aI~=nil and aI>0 then local o7=r(an,0.4,2)local nL=LastMaxBrakeInAtmo*r(b8/100,0.1,1)*o7;local o8=aI*o7+nL-l3;local o9=nL/2-l3;local oa=b8-y(d(o9/2)*20/(0.5*ar))*utils.sign(o9)if oa<0 then oa=0 end;local ob;if b8>100 then local oc,_=aH.computeDistanceAndTime(b8,100,ar,0,0,nL)local od,_=aH.computeDistanceAndTime(100,0,ar,0,0,y(nL))ob=oc+od else ob=aH.computeDistanceAndTime(b8,0,ar,0,0,y(nL))end;if ob<20 then BrakeIsOn=false else local oe=0;if oa>100 then local of,_=aH.computeDistanceAndTime(oa,100,ar,0,0,o8)local og,_=aH.computeDistanceAndTime(100,0,ar,0,0,aI*o7+y(nL)-l3)oe=of+og else oe,_=aH.computeDistanceAndTime(oa,0,ar,0,0,aI*o7+y(nL)-l3)end;oe=(oe+15+b8*m_)*1.1;local oh=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if oh then local n6=planet:getAltitude(CustomTarget.position)local oi=ao-n6-100;local mV=CustomTarget.position-bb;local oj=y(mV:len()^2-(ao-n6)^2)if oj>100 then oh=false elseif oi<=oe or oe==-1 then BrakeIsOn=true;o5=true else BrakeIsOn=false;o5=true end end;if not oh and CalculateBrakeLandingSpeed then if oe>=o6 then BrakeIsOn=true else BrakeIsOn=false end;o5=true end end end;if not bf then aM.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;mA=ak;if mA>-1 then aR=autoRollPreference;if b8<1 or b7:normalize():dot(b9)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bz("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)ab=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and b7:normalize():dot(-gL)<0.999 then BrakeIsOn=true elseif ba<-brakeLandingRate and not o5 then BrakeIsOn=true elseif not o5 then BrakeIsOn=false end end;if AutoTakeoff or ai then local it,di,dh;if AutopilotTargetCoords~=nil then it,di,dh=aG:getPlanetarySystem(0):castIntersections(bb,(AutopilotTargetCoords-bb):normalize(),function(d2)return d2.radius+d2.noAtmosphericDensityAltitude end)end;if bd then if ao>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aM.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(nx)<15 and ao/HoldAltitude>0.75 then AutoTakeoff=false;if not ai then if bf and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ai and b8<Q then Autopilot=true;ai=false;AltitudeHold=false;AutoTakeoff=false;aM.cmdThrottle(0)elseif ai then aM.cmdThrottle(0)BrakeIsOn=true end elseif ai and an==0 and a8~=nil and(it==nil or it.name==a8.name)then Autopilot=true;ai=false;AltitudeHold=false;AutoTakeoff=false;if not bf then aM.cmdThrottle(0)end;AutopilotAccelerating=true end end;local ok=ak>-1;local ol=bg;if(VectorToTarget or ai or bl)and not ok and b8>minRollVelocity and an>0.01 then local jz=math.rad(d(bh))ol=bg*d(math.cos(jz))+n1*math.sin(jz)end;local om=r(nx-ol,-PitchStallAngle*0.80,PitchStallAngle*0.80)if an<0.01 and VectorToTarget then om=r(nx-ol,-85,MaxPitch)elseif an<0.01 then om=r(nx-ol,-MaxPitch,MaxPitch)end;if d(bh)<5 or VectorToTarget or bl or BrakeLanding or ok or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(om)local ny=pitchPID:get()U=U+ny end end;if antigrav~=nil and(antigrav and not ExternalAGG and ao<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function m8.ToggleIntoOrbit()a_=false;mj=nil;mk=nil;mp=0;if an==0 then if IntoOrbit then bz("orOff","AP")IntoOrbit=false;ml=false;mo=nil;aR=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;aY.VectorToTarget=false;aY.AutopilotAlign=false;mn=false elseif bn then bz("orOn","AP")IntoOrbit=true;aR=true;if mo==nil then mo=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;ml=false;mo=nil;aR=autoRollPreference;if AltitudeHold then AltitudeHold=false end;aY.VectorToTarget=false;aY.AutopilotAlign=false;mn=false end end;function m8.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aR=true;ab=0;if am and ak==-1 then BrakeLanding=false;AltitudeHold=true;ab=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aM.cmdCruise(e(aV))end else a_=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function m8.checkLOS(mP)local it,dh,di=aG:getPlanetarySystem(0):castIntersections(bb,mP,function(d2)if d2.noAtmosphericDensityAltitude>0 then return d2.radius+d2.noAtmosphericDensityAltitude else return d2.radius+d2.surfaceMaxAltitude*1.5 end end)local iu=dh;if di~=nil and dh~=nil then iu=math.min(di,dh)end;if iu~=nil then return it,iu else return nil,nil end end;function m8.ToggleAutopilot()local function on(SpaceTarget)bo=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aM.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;local oo=false;if E-mi<1.5 and an>0 then if not b2 then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if an>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bz("orH","OH")end;mi=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else mi=E end;TargetSet=false;if(AutopilotTargetIndex>0 or#mq>0)and not Autopilot and not VectorToTarget and not ai and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<ar then a2="WARNING: Heavy Loads may affect autopilot performance."ae=5 end;if#mq>0 and not aj then AutopilotTargetIndex=mq[1]aL.UpdateAutopilotTarget()table.remove(mq,1)a2="Route Autopilot in Progress"local mV=CustomTarget.position-bb;local nX=mV:project_on_plane(b9):len()if nX>50000 and CustomTarget.planetname==planet.name then oo=true end end;aL.UpdateAutopilotTarget()aM.showWayPoint(a8,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bz("apSpc","AP")if an~=0 then ai=true;aM.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if an>0 then if not VectorToTarget then bz("vtt","AP")on(SpaceTarget)if oo then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight end end else bz("apOn","AP")if not(a8.name==planet.name and ao<AutopilotTargetOrbit*1.5)then a_=false;Autopilot=true elseif not am then if IntoOrbit then aM.ToggleIntoOrbit()end;aZ=planet.noAtmosphericDensityAltitude+LowOrbitHeight;mn=true;aY.AutopilotAlign=true;aY.VectorToTarget=true;ml=false;if not IntoOrbit then aM.ToggleIntoOrbit()end end end else bz("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if an~=0 then ai=true;aM.ToggleAltitudeHold()else Autopilot=true end end elseif an==0 then if CustomTarget==nil and(a8.name==planet.name and bn)and not IntoOrbit then WaypointSet=false;a_=false;ml=false;aM.ToggleIntoOrbit()else bz("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bz("apP","AP")ai=true;aM.ToggleAltitudeHold()end else bz("apOff","AP")aM.ResetAutopilots(1)end end;function m8.routeWP(op,oq,os)if os then if os==1 then mq={}mq=bC(mq,saveRoute)if#mq>0 then a2="Route Loaded"else a2="No Saved Route found on Databank"end;return mq else saveRoute={}saveRoute=bC(saveRoute,mq)a2="Route Saved"c2()return end end;if op then return mq end;if oq then mq={}a2="Current Route Cleared"else mq[#mq+1]=AutopilotTargetIndex;a2="Added "..CustomTarget.name.." to route. "end;return mq end;function m8.cmdThrottle(cs,ot)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ot then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cs)K=r(A(cs*100,0)/100,-1,1)be=nil end;function m8.cmdCruise(cs,ot)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ot then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cs)be=cs end;function m8.ToggleLockPitch()if LockPitch==nil then bz("lkPOn","LP")if not a1 then LockPitch=bg else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bz("lkPOff","LP")LockPitch=nil end end;function m8.ToggleAltitudeHold()if E-mh<1.5 then if planet.hasAtmosphere then if an>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bz("11","EP")else if bn then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;aZ=HoldAltitude;mn=true;if not IntoOrbit then aM.ToggleIntoOrbit()end;ml=true end end;mh=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else mh=E end;if bn and an==0 then aZ=ao;mn=true;ml=true;aM.ToggleIntoOrbit()if IntoOrbit then mh=E else mh=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;aR=true;LockPitch=nil;a_=false;if ak~=-1 and b8<20 then bz("lfs","LS")AutoTakeoff=true;if mh>-1 then HoldAltitude=ao+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bc then aM.ToggleVerticalTakeoff()end else bz("altOn","AH")AutoTakeoff=false;if mh>-1 then if bn then HoldAltitude=ao end end;if VertTakeOff then aM.ToggleVerticalTakeoff()end end;if ai then HoldAltitude=100000 end else bz("altOff","AH")if IntoOrbit then aM.ToggleIntoOrbit()end;if VertTakeOff then aM.ToggleVerticalTakeoff()end;aR=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;mh=0 end end;function m8.ResetAutopilots(m8)if m8 then ai=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=ao;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bl=nil;if not bd then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aM.ToggleVerticalTakeoff()end;if IntoOrbit then aM.ToggleIntoOrbit()end;aR=autoRollPreference;ah=false;aj=false;ab=0 end;function m8.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aR=autoRollPreference end;if BrakeIsOn then bz("bkOn","B",1)aM.ResetAutopilots()else bz("bkOff","B",1)end end;function m8.BeginReentry()if Reentry then a2="Re-Entry cancelled"bz("reOff","RE")Reentry=false;aR=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ae=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;aR=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aV;bz("par","RE")else Reentry=true;AltitudeHold=true;aR=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bP=bV(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..aV.." Target Altitude: "..bP;bz("glide","RE")aM.cmdCruise(e(aV))end;AutoTakeoff=false end;function m8.ToggleAntigrav()if antigrav and not ExternalAGG then if bd then bz("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=ao end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bz("aggOn","AG")antigrav.activate()antigrav.show()end end end;ak=mv()return m8 end;local function ou()local ov={}local ow=true;local ox=5;local oy=5;local oz=ox;local oA=oy;function ov.startControl(oB)local function oC(mH)local D=1;local function oD(oE,mH)local oF={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local oG=oE;for _,c7 in ipairs(oF)do if mH and oG>c7 then oE=c7 elseif oE<c7 and not mH then oE=c7;break end end;return oE end;if mH then D=-1 end;if not ExternalAGG and bd then if a1 and mH then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*oy;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then aZ=oD(aZ,mH)else aZ=aZ+D*ox end;if aZ<planet.noAtmosphericDensityAltitude then aZ=planet.noAtmosphericDensityAltitude end else if a1 and am then HoldAltitude=oD(HoldAltitude,mH)else HoldAltitude=HoldAltitude+D*ox end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function oH(oI)if not am then a2="Flight Assist in Atmo only"return end;local cd=type(oI)if bl==nil then if cd=="table"then if Autopilot or VectorToTarget then aM.ToggleAutopilot()end;bz("180On","BR")elseif oI==1 then bz("bnkLft","BR")else bz("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aM.ToggleAltitudeHold()if cd~="table"then oI=oI+1 end end;bl=oI else bz("180Off","BR")bl=nil end end;if oB=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aM.cmdThrottle(0)if vBooster or hover then if am and ak==-1 then bz("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aR=true;GearExtended=false else if S then bz("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if am then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bz("grOut","LG",1)a.control.extendLandingGears()end else if S then bz("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif oB=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif oB=="forward"then T=T-1 elseif oB=="backward"then if AltIsOn then oH(-b7*5000)else T=T+1 end elseif oB=="left"then if AltIsOn then oH(1)else W=W-1 end elseif oB=="right"then if AltIsOn then oH(3)else W=W+1 end elseif oB=="yawright"then X=X-1 elseif oB=="yawleft"then X=X+1 elseif oB=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif oB=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif oB=="up"then ab=ab+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif oB=="down"then ab=ab-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif oB=="groundaltitudeup"then oC()elseif oB=="groundaltitudedown"then oC(true)elseif oB=="option1"then toggleView=false;if AltIsOn and a1 then local oJ=""for i=1,#bt do oJ=oJ.."| Name: "..system.getPlayerName(bt[i]).." Mass: "..A(core.getBoardedPlayerMass(bt[i])/1000,1).."t "end;system.print("Onboard: "..oJ)return end;aL.adjustAutopilotTargetIndex()elseif oB=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bt do core.forceDeboard(bt[i])end;a2="Deboarded All Passengers"return end;aL.adjustAutopilotTargetIndex(1)elseif oB=="option3"then local function oK()ow=not ow;if not ow then bz("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,"Atmo Fuel","fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,"Space Fuel","fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,"Rocket Fuel","fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bz("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;toggleView=false;if AltIsOn and a1 then local oJ=""for i=1,#bu do oJ=oJ.."| ID: "..bu[i].." Mass: "..A(core.getDockedConstructMass(bu[i])/1000,1).."t "end;system.print("Docked Ships: "..oJ)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oK()elseif oB=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#bu do core.forceUndock(bu[i])end;a2="Undocked all ships"return end;bl=nil;aM.ToggleAutopilot()elseif oB=="option5"then toggleView=false;aM.ToggleLockPitch()elseif oB=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local oL=shield_1.getVentingCooldown()if oL>0 then a2="Cannot vent again for "..oL.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aM.ToggleAltitudeHold()elseif oB=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif oB=="option8"then toggleView=false;if AltIsOn and a1 then if AutopilotTargetIndex>0 and CustomTarget~=nil then aM.routeWP()else a2="Select a saved wp on IPH to add to or remove from route"end;return end;stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bz("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bz("gsOn","GS")end elseif oB=="option9"then toggleView=false;if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aM.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()at=gyro.getState()==1;if at then bz("gyOn","GA")else bz("gyOff","GA")end else a2="No gyro found"end elseif oB=="lshift"then bq=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;aQ=false;aP=false end elseif oB=="brake"then if BrakeToggleStatus or AltIsOn then aM.BrakeToggle()elseif not BrakeIsOn then aM.BrakeToggle()else BrakeIsOn=true end elseif oB=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif oB=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a3 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a3=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a3=false end elseif oB=="stopengines"then local function oM()if E-F<1.5 then bz("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bl=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;ah=false;ai=false;R=false;aR=autoRollPreference;VectorToTarget=false;TurnBurn=false;at=false;LockPitch=nil;IntoOrbit=false end end;oM()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aM.cmdThrottle(0)else aM.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if am then aM.cmdCruise(AtmoSpeedLimit)else aM.cmdCruise(MaxGameVelocity*3.6)end end end elseif oB=="speedup"then aM.changeSpd()elseif oB=="speeddown"then aM.changeSpd(true)elseif oB=="antigravity"and not ExternalAGG then if antigrav~=nil then aM.ToggleAntigrav()else a2="No antigrav found"end end end;function ov.stopControl(oB)local function oN()if not ExternalAGG and bd then oA=oy end;if AltitudeHold or VertTakeOff or IntoOrbit then oz=ox end end;if oB=="forward"then T=0 elseif oB=="backward"then T=0 elseif oB=="left"then if bl then if bl==2 then bl=-2 else bl=-1 end end;W=0 elseif oB=="right"then if bl then if bl==4 then bl=-2 else bl=-1 end end;W=0 elseif oB=="yawright"then X=0 elseif oB=="yawleft"then X=0 elseif oB=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif oB=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif oB=="up"then ab=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif oB=="down"then ab=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif oB=="groundaltitudeup"then oN()toggleView=false elseif oB=="groundaltitudedown"then oN()toggleView=false elseif oB=="lshift"then if x()==1 then ac=0;ad=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then aQ=false;aP=false end;a1=false elseif oB=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aM.BrakeToggle()else BrakeIsOn=false end end elseif oB=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function ov.loopControl(oB)local function oO(mH)local D=1;if mH then D=-1 end;if not ExternalAGG and bd then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*oA;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;oA=r(oA*1.05,oy,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then aZ=aZ+D*oz;if aZ<planet.noAtmosphericDensityAltitude then aZ=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*oz end;oz=r(oz*1.05,ox,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function oP(mH)local D=1;if mH then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if oB=="groundaltitudeup"then if not a1 then oO()end elseif oB=="groundaltitudedown"then if not a1 then oO(true)end elseif oB=="speedup"then oP()elseif oB=="speeddown"then oP(true)end end;function ov.inputTextControl(bP)local function oQ(oR,e1,hs)local function oS(e1)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cl='::pos{'..B..','..B..','..B..','..B..','..B..'}'local cz,cA,cG,cH,cI=o(e1,cl)if cz=="0"and cA=="0"then return vec3(z(cG),z(cH),z(cI))end;cH=math.rad(cH)cG=math.rad(cG)local planet=b[z(cz)][z(cA)]local dt=math.cos(cG)local oT=vec3(dt*math.cos(cH),dt*math.sin(cH),math.sin(cG))return planet.center+(planet.radius+cI)*oT end;local position=oS(e1)return aL.AddNewLocation(oR,position,hs)end;local i;local oU,oV=nil,nil;local oW="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp"i=string.find(bP," ")oU=bP;if i~=nil then oU=string.sub(bP,0,i-1)oV=string.sub(bP,i+1)end;if oU=="/help"or oU=="/commands"then for lk in string.gmatch(oW,"([^\n]+)")do system.print(lk)end;return elseif oU=="/setname"then if oV==nil or oV==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aL.UpdatePosition(oV)else a2="Select a saved target to rename first"end elseif shield_1 and oU=="/resist"then if not shield_1 then a2="No shield found"return elseif oV==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cl=B..', '..B..', '..B..', '..B;local oX,oY,oZ,o_=o(oV,cl)if o_==nil or oX+oY+oZ+o_>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(oX,oY,oZ,o_)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif oU=="/addlocation"or string.find(bP,"::pos")~=nil then local hs=false;local oR="0-Temp"if oV==nil or oV==""then oV=oU;hs=true end;i=string.find(oV,"::")if not hs then oR=string.sub(oV,1,i-2)end;local e1=string.sub(oV,i)oQ(oR,e1,hs)elseif oU=="/agg"then if oV==nil or oV==""then a2="Usage: /agg targetheight"return end;oV=z(oV)if oV<1000 then oV=1000 end;AntigravTargetAltitude=oV;a2="AGG Target Height set to "..oV elseif oU=="/G"then if oV==nil or oV==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oV=="dump"then for c6,c7 in pairs(bF())do if type(_G[c7])=="boolean"then if _G[c7]==true then system.print(c7 .." true")else system.print(c7 .." false")end elseif _G[c7]==nil then system.print(c7 .." nil")else system.print(c7 .." ".._G[c7])end end;return end;i=string.find(oV," ")local p0=string.sub(oV,0,i-1)local p1=string.sub(oV,i+1)for c6,c7 in pairs(bF())do if c7==p0 then a2="Variable "..p0 .." changed to "..p1;local p2=type(_G[c7])if p2=="number"then p1=z(p1)if c7=="AtmoSpeedLimit"then aV=p1 end elseif p2=="boolean"then if string.lower(p1)=="true"then p1=true else p1=false end end;_G[c7]=p1;return end end;a2="No such global variable: "..p0 elseif oU=="/deletewp"then if AutopilotTargetIndex>0 and CustomTarget~=nil then aL.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif oU=="/copydatabank"then if dbHud_2 then c2(true)else a2="Spare Databank required to copy databank"end elseif oU=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aM.showWayPoint(a8,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;return ov end;function script.onStart()local p3=false;local function p4()local function p5(p6)local p7=dbHud_1.hasKey;for c6,c7 in pairs(p6)do if p7(c7)then local cn=g(dbHud_1.getStringValue(c7))if cn~=nil then _G[c7]=cn;p3=true end end end end;if dbHud_1 then if not useTheseSettings then p5(bF())coroutine.yield()p5(c)else p5(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ae=5;p3=false end;coroutine.yield()if p3 then a2="Loaded Saved Variables"ay=ResolutionX;az=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aR=autoRollPreference;aV=AtmoSpeedLimit;au=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]av=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ae=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=ao end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function p8()local function p9(pa,pb)if pa>pb then pb=pa end;local pc,pd=0,0;if ContainerOptimization>0 then pc=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then pd=FuelTankOptimization*0.05 end;pb=pb*(1-(pc+pd))return pb end;local pe=core.getElementNameById;local pf=fuelX~=0 and fuelY~=0;for c6 in pairs(ap)do local type=core.getElementTypeById(ap[c6])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(ap[c6])),'^.*vertical.*$')and core.getElementForwardById(ap[c6])[3]>0 then bc=true end end;if o(type,'^.*Space Engine$')then b2=true;if o(tostring(core.getElementTagsById(ap[c6])),'^.*vertical.*$')then local pg=core.getElementForwardById(ap[c6])if pg[3]<0 then b0=true else b1=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local ph=j(ap[c6])if ph>10000 then G=110 elseif ph>1000 then G=55 elseif ph>150 then G=27 end end;aD=aD+j(ap[c6])if pf and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local ph=j(ap[c6])local lb=l(ap[c6])local pa=0;local gx=q()if type=="Atmospheric Fuel Tank"then local pb=400;local pi=35.03;if ph>10000 then pb=51200;pi=5480 elseif ph>1300 then pb=6400;pi=988.67 elseif ph>150 then pb=1600;pi=182.67 end;pa=lb-pi;if fuelTankHandlingAtmo>0 then pb=pb+pb*fuelTankHandlingAtmo*0.2 end;pb=p9(pa,pb)aA[#aA+1]={ap[c6],pe(ap[c6]),pb,pi,pa,gx}end;if type=="Rocket Fuel Tank"then local pb=320;local pi=173.42;if ph>65000 then pb=40000;pi=25740 elseif ph>6000 then pb=5120;pi=4720 elseif ph>700 then pb=640;pi=886.72 end;pa=lb-pi;if fuelTankHandlingRocket>0 then pb=pb+pb*fuelTankHandlingRocket*0.1 end;pb=p9(pa,pb)aC[#aC+1]={ap[c6],pe(ap[c6]),pb,pi,pa,gx}end;if type=="Space Fuel Tank"then local pb=600;local pi=35.03;if ph>10000 then pb=76800;pi=5480 elseif ph>1300 then pb=9600;pi=988.67 elseif ph>150 then pb=2400;pi=182.67 end;pa=lb-pi;if fuelTankHandlingSpace>0 then pb=pb+pb*fuelTankHandlingSpace*0.2 end;pb=p9(pa,pb)aB[#aB+1]={ap[c6],pe(ap[c6]),pb,pi,pa,gx}end end end;if not bc then VertTakeOff,VertTakeOffEngine=false,false end end;local function pj()if gyro~=nil then at=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(am or not am and ao<10000)then for _,c7 in pairs(door)do c7.toggle()end end;if switch then for _,c7 in pairs(switch)do c7.toggle()end end;if forcefield and(am or not am==0 and ao<10000)then for _,c7 in pairs(forcefield)do c7.toggle()end end;if antigrav then bd=antigrav.getState()==1;if bd and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ak~=-1 or not am and b6:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(aS)if am and ak~=-1 then aI=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=am end;local function pk()local pl={}local function pm()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local pn={[1]=4480,[6]=4480,[7]=6270}for po,pp in pairs(b)do b[po][0]=pm()b[po][0].systemId=po;pl[po]={}for pq,planet in pairs(b[po])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=pn[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=po;planet.bodyId=planet.id;pl[po][pq]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bv[#bv+1]=planet end end end;aF=c8()aG=aF(pl)aH=dw()aJ=d_()aL=lR()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})p4()coroutine.yield()p8()coroutine.yield()aM=m7()pj()coroutine.yield()pk()aN=en()aK=fI()aK.ButtonSetup()aO=ou()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bz("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(an>0 or an==0 and ao<10000)then for _,c7 in pairs(door)do c7.toggle()end end;if switch then for _,c7 in pairs(switch)do c7.toggle()end end;if forcefield and(an>0 or an==0 and ao<10000)then for _,c7 in pairs(forcefield)do c7.toggle()end end;showHud=bx;c2()if button then button.activate()end;if SetWaypointOnExit then aM.showWayPoint(planet,bb)end;bz("stop","SU")end;function script.onTick(pr)local ps=nil;if pr=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bz("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif pr=="tenthSecond"then local function pt()local pu=system.createData;local pv=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=pv(panelInterplanetary,"value")interplanetaryHeaderText=pu('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=pv(panelInterplanetary,"value")widgetDistanceText=pu('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=pv(panelInterplanetary,"value")widgetTravelTimeText=pu('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=pv(panelInterplanetary,"value")widgetMaxMassText=pu('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=pv(panelInterplanetary,"value")widgetTargetOrbitText=pu('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=pv(panelInterplanetary,"value")widgetCurBrakeDistanceText=pu('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=pv(panelInterplanetary,"value")widgetCurBrakeTimeText=pu('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=pv(panelInterplanetary,"value")widgetMaxBrakeDistanceText=pu('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=pv(panelInterplanetary,"value")widgetMaxBrakeTimeText=pu('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=pv(panelInterplanetary,"value")widgetTrajectoryAltitudeText=pu('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not am then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function pw()t(panelInterplanetary)panelInterplanetary=nil end;local function px()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(a8.center-bb):len()else AutopilotDistance=(CustomTarget.position-bb):len()end end;local dY=b8;local nA=unit.getThrottle()/100;if AtmoSpeedAssist then nA=K end;local py,pz=aH.computeDistanceAndTime(b8,MaxGameVelocity,ar,a:maxForceForward()*nA,warmup,0)local a4,a5;if not TurnBurn then a4,a5=aM.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a4,a5=aM.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,pA;if not TurnBurn and dY>0 then _,pA=aM.GetAutopilotBrakeDistanceAndTime(dY)else _,pA=aM.GetAutopilotTBBrakeDistanceAndTime(dY)end;local pB=0;local pC=0;if AutopilotCruising or not Autopilot and dY>5 then pC=aH.computeTravelTime(dY,0,AutopilotDistance)elseif a4+py<AutopilotDistance then pB=AutopilotDistance-(a4+py)pC=aH.computeTravelTime(8333.0556,0,pB)else local pD=(AutopilotDistance-a4)/py;py=AutopilotDistance-a4;pz=pz*pD end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return pC elseif AutopilotBraking then return pA elseif AutopilotCruising then return pC+pA else return pz+a5+pC end end;local function pE(l3,pF)if l3==nil then l3=core.g()end;l3=A(l3,5)if pF~=nil and pF or(ps==nil or ps~=l3)then local dY=b6:len()local pG=g(unit.getData()).maxBrake;if pG~=nil and pG>0 and am then pG=pG/r(dY/100,0.1,1)pG=pG/an;if an>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+pG)/2 else LastMaxBrakeInAtmo=pG end end end;if pG~=nil and pG>0 then LastMaxBrake=pG end;ps=l3 end end;pE(nil,true)if be~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=be then aM.cmdCruise(be)else be=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then pt()end;if AutopilotTargetName~=nil then local pH=CustomTarget~=nil;local pI=0.5*LastMaxBrakeInAtmo/a8:getGravity(a8.center+vec3(0,0,1)*a8.radius):len()pI=pI>1000000 and A(pI/1000000,2).." kTons"or A(pI/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=px()if pH and not Autopilot then af=(bb-CustomTarget.position):len()else af=(AutopilotTargetCoords-bb):len()end;if not TurnBurn then a4,a5=aM.GetAutopilotBrakeDistanceAndTime(b8)a6,a7=aM.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a4,a5=aM.GetAutopilotTBBrakeDistanceAndTime(b8)a6,a7=aM.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ii=bV(af)u(widgetDistanceText,'{"label": "distance", "value": "'..ii..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..bY(travelTime)..'", "unit":""}')ii=bV(a4)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ii..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..bY(a5)..'", "unit":""}')ii=bV(a6)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ii..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..bY(a7)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",pI)..'", "unit":""}')ii=bV(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ii..'"}')if an>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bf and AtmoSpeedAssist and(AltitudeHold or Reentry or aj)then aM.cmdThrottle(1)BrakeIsOn=false;O=false end end;if an==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else pw()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aK.TenthTick()elseif pr=="oneSecond"then local function pJ(gH)local pK=0;ax=""local pL=aD;local pM=0;local pN=0;local pO=0;local gB=0;local gC=""local pP=core.getElementHitPointsById;for c6 in pairs(ap)do local ph=0;local pQ=0;pQ=j(ap[c6])ph=pP(ap[c6])pM=pM+ph;if ph<pQ then if ph==0 then pO=pO+1 else pN=pN+1 end;if aE and#aw==0 then position=vec3(core.getElementPositionById(ap[c6]))local bN=position.x;local bO=position.y;local eV=position.z;table.insert(aw,core.spawnArrowSticker(bN,bO,eV+1,"down"))table.insert(aw,core.spawnArrowSticker(bN,bO,eV+1,"down"))core.rotateSticker(aw[2],0,0,90)table.insert(aw,core.spawnArrowSticker(bN+1,bO,eV,"north"))table.insert(aw,core.spawnArrowSticker(bN+1,bO,eV,"north"))core.rotateSticker(aw[4],90,90,0)table.insert(aw,core.spawnArrowSticker(bN-1,bO,eV,"south"))table.insert(aw,core.spawnArrowSticker(bN-1,bO,eV,"south"))core.rotateSticker(aw[6],90,-90,0)table.insert(aw,core.spawnArrowSticker(bN,bO-1,eV,"east"))table.insert(aw,core.spawnArrowSticker(bN,bO-1,eV,"east"))core.rotateSticker(aw[8],90,0,90)table.insert(aw,core.spawnArrowSticker(bN,bO+1,eV,"west"))table.insert(aw,core.spawnArrowSticker(bN,bO+1,eV,"west"))core.rotateSticker(aw[10],-90,0,90)table.insert(aw,ap[c6])end elseif aE and#aw>0 and aw[11]==ap[c6]then for gw in pairs(aw)do core.deleteSticker(aw[gw])end;aw={}end end;pK=e(pM/pL*100)if pK<100 then gH[#gH+1]=bM(0,0,"","pbright txt")gB=e(pK*2.55)gC=f("rgb(%d,%d,%d)",255-gB,gB,0)if pK<100 then gH[#gH+1]=bM("50%",1035,"Elemental Integrity: "..pK.."%","txtbig txtmid","fill:"..gC)if pO>0 then gH[#gH+1]=bM("50%",1055,"Disabled Modules: "..pO.." Damaged Modules: "..pN,"txtbig txtmid","fill:"..gC)elseif pN>0 then gH[#gH+1]=bM("50%",1055,"Damaged Modules: "..pN,"txtbig txtmid","fill:"..gC)end end end end;local function pR()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,"Weapons","weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bt=core.getPlayersOnBoard()bu=core.getDockedConstructs()pR()local gH={}aK.OneSecond(gH)if ShouldCheckDamage then pJ(gH)end;ag=table.concat(gH,"")collectgarbage("collect")elseif pr=="fiveSecond"then if not UseSatNav then return end;al=dbHud_1.getStringValue("SPBAutopilotTargetName")if al~=nil and al~=""and al~="SatNavNotChanged"then local cn=g(dbHud_1.getStringValue("SavedLocations"))if cn~=nil then _G["SavedLocations"]=cn;local fd=-1;local m3;for c6,c7 in pairs(SavedLocations)do if c7.name and c7.name=="SatNav Location"then fd=c6;break end end;if fd~=-1 then m3=SavedLocations[fd]fd=-1;for c6,c7 in pairs(b[0])do if c7.name and c7.name=="SatNav Location"then fd=c6;break end end;if fd>-1 then b[0][fd]=m3 end;aL.UpdateAtlasLocationsList()a2=m3.name.." position updated"end end;for i=1,#bi do if bi[i].name==al then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bi[i].name)aL.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif pr=="msgTick"then local gH={}aK.DisplayMessage(gH,"empty")a2="empty"unit.stopTimer("msgTick")ae=3 elseif pr=="animateTick"then aQ=true;aP=false;ac=0;ad=0;unit.stopTimer("animateTick")elseif pr=="hudTick"then aK.hudtick()elseif pr=="apTick"then aM.APTick()elseif pr=="radarTick"then aN.UpdateRadar()elseif pr=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function pS(pT,nJ)local pU=vec3()local pV=vec3()if pT==axisCommandId.longitudinal then pU=vec3(core.getConstructOrientationForward())pV=b4 elseif pT==axisCommandId.vertical then pU=vec3(core.getConstructOrientationUp())pV=b3 elseif pT==axisCommandId.lateral then pU=vec3(core.getConstructOrientationRight())pV=b5 else return vec3()end;local pW=vec3(core.getWorldGravity())local pX=pW:dot(pV)local pY=vec3(core.getWorldAirFrictionAcceleration())local pZ=pY:dot(pV)local p_=b6:dot(pU)local q0=nJ*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(q0-p_)local q1=targetSpeedPID2:get()local q2=(q1-pZ-pX)*pV;return q2 end;local function q3(pT,nJ)local pU=vec3()local pV=vec3()if pT==axisCommandId.longitudinal then pU=vec3(core.getConstructOrientationForward())pV=b4 elseif pT==axisCommandId.vertical then pU=vec3(core.getConstructOrientationUp())pV=b3 elseif pT==axisCommandId.lateral then pU=vec3(core.getConstructOrientationRight())pV=b5 else return vec3()end;local pW=vec3(core.getWorldGravity())local pX=pW:dot(pV)local pY=vec3(core.getWorldAirFrictionAcceleration())local pZ=pY:dot(pV)local p_=b6:dot(pU)local q0=nJ*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(q0-p_)local q1=targetSpeedPID:get()local q2=(q1-pZ-pX)*pV;return q2 end;local function q4(q5,gK,lW)local q6=q5:cross(lW):normalize_inplace()local hw=math.acos(r(q6:dot(-gK),-1,1))*constants.rad2deg;if q6:cross(-gK):dot(lW)<0 then hw=-hw end;return hw end;if antigrav and not ExternalAGG then if not bd and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bf=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bf and O then aM.cmdThrottle(0)O=false elseif not bf and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local q7=r(T+U+system.getControlDeviceForwardInput(),-1,1)local q8=r(W+Z+system.getControlDeviceYawInput(),-1,1)local q9=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local qa=Y;b9=vec3(core.getWorldVertical())if b9==nil or b9:len()==0 then b9=(planet.center-bb):normalize()end;b3=vec3(core.getConstructWorldOrientationUp())b4=vec3(core.getConstructWorldOrientationForward())b5=vec3(core.getConstructWorldOrientationRight())b7=vec3(core.getWorldVelocity())b6=vec3(core.getVelocity())bb=vec3(core.getConstructWorldPos())ar=core.getConstructMass()b8=vec3(b7):len()ba=-b9:dot(b7)bh=getRoll(b9,b4,b5)local qb=bh/180*math.pi;local qc=math.cos(qb)local qd=math.sin(qb)bg=q4(b9,b4,b5*qc+b3*qd)local qe=b7:normalize()local qf=d(bh)local qg=utils.sign(bh)local qh=vec3(core.getWorldAngularVelocity())local qi=q7*pitchSpeedFactor*b5+q8*rollSpeedFactor*b4+q9*yawSpeedFactor*b3;if aR==true and b9:len()>0.01 then local qj=d(aU-bh)if((ProgradeIsOn or Reentry or BrakeLanding or ah or AltitudeHold or IntoOrbit)and qj>0 or an>0.0 and qj<autoRollRollThreshold and autoRollPreference)and q8==0 and d(bg)<85 then local qk=aU;local ql=autoRollFactor;if an==0 then ql=ql/4;aU=0;qk=0 end;if rollPID==nil then rollPID=pid.new(ql*0.01,0,ql*0.1)end;rollPID:inject(qk-bh)local qm=rollPID:get()qi=qi+qm*b4 end end;local qn=1;local qo=0;local qp=1;local qq=system.getMouseWheel()if qq>0 then aM.changeSpd()elseif qq<0 then aM.changeSpd(true)else as=true end;L=0;if am and AtmoSpeedAssist and bf then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aV/3.6-b7:dot(b4))local qr=throttlePID:get()N=r(qr,-1,1)if N<K and an>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(b7:len()-aV/3.6)local qs=r(brakePID:get(),0,1)if an>0 and ba<-80 or an>0.005 then L=qs end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local qt=''local qu=vec3()local qv=pS(axisCommandId.vertical,ab*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",qv,qo)local qw='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then qw=qw..ExtraLongitudeTags end;local qx=s:getAxisCommandType(axisCommandId.longitudinal)local qy=s:composeAxisAccelerationFromThrottle(qw,axisCommandId.longitudinal)local qz=q3(axisCommandId.lateral,LeftAmount*1000)qt=qt..' , '.."lateral airfoil , lateral ground "qu=qu+qz;if qu:len()>constants.epsilon then a:setEngineForceCommand(qt,qu,qo,'','','',qp)end;a:setEngineForceCommand(qw,qy,qn)local qA='thrust analog vertical fueled 'local qB='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then qB=qB..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then qA=qA..ExtraVerticalTags end;if ab~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(qA,qv,qn)else a:setEngineForceCommand(qA,vec3(),qn)end;if LeftAmount~=0 then a:setEngineForceCommand(qB,qz,qn)else a:setEngineForceCommand(qB,vec3(),qn)end;if qa==0 then qa=L end;local qC=-qa*(brakeSpeedFactor*b7+brakeFlatFactor*qe)a:setEngineForceCommand('brake',qC)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local nJ=unit.getAxisCommandValue(0)if not bf then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(b7:len()-nJ/3.6)local qs=r(brakePID:get(),0,1)qa=r(qa+qs,0,1)end;local qC=-qa*(brakeSpeedFactor*b7+brakeFlatFactor*qe)a:setEngineForceCommand('brake',qC)local qt=''local qu=vec3()local qD=false;local qw='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then qw=qw..ExtraLongitudeTags end;local qx=s:getAxisCommandType(axisCommandId.longitudinal)if qx==axisCommandType.byThrottle then local qy=s:composeAxisAccelerationFromThrottle(qw,axisCommandId.longitudinal)a:setEngineForceCommand(qw,qy,qn)elseif qx==axisCommandType.byTargetSpeed then local qy=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)qt=qt..' , '..qw;qu=qu+qy;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then qD=true end end;local qB='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then qB=qB..ExtraLateralTags end;local qE=s:getAxisCommandType(axisCommandId.lateral)if qE==axisCommandType.byThrottle then local qF=s:composeAxisAccelerationFromThrottle(qB,axisCommandId.lateral)a:setEngineForceCommand(qB,qF,qn)elseif qE==axisCommandType.byTargetSpeed then local qz=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)qt=qt..' , '..qB;qu=qu+qz end;local qA='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then qA=qA..ExtraVerticalTags end;local qG=s:getAxisCommandType(axisCommandId.vertical)if qG==axisCommandType.byThrottle then local qv=s:composeAxisAccelerationFromThrottle(qA,axisCommandId.vertical)if ab~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(qA,qv,qn,'airfoil','ground','',qp)else a:setEngineForceCommand(qA,vec3(),qn)a:setEngineForceCommand('airfoil vertical',qv,qn,'airfoil','','',qp)a:setEngineForceCommand('ground vertical',qv,qn,'ground','','',qp)end elseif qG==axisCommandType.byTargetSpeed then if ab<0 then a:setEngineForceCommand('hover',vec3(),qn)end;local qH=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)qt=qt..' , '..qA;qu=qu+qH end;if qu:len()>constants.epsilon then if Y~=0 or qD or d(qe:dot(b4))<0.5 then qt=qt..', brake'end;a:setEngineForceCommand(qt,qu,qo,'','','',qp)end end;local qI=torqueFactor*(qi-qh)local qJ=vec3(core.getWorldAirFrictionAngularAcceleration())qI=qI-qJ;a:setEngineTorqueCommand('torque',qI,qn,'airfoil','','',qp)a:setBoosterCommand('rocket_engine')if a3 and not VanillaRockets then local dY=b6:len()local qK=0.15;if not bf then local qL=s:getTargetSpeed(axisCommandId.longitudinal)if dY*3.6>qL*(1-qK)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif dY*3.6<qL*(1-qK)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nA=unit.getThrottle()if AtmoSpeedAssist then nA=K*100 end;local nJ=nA/100;if k==0 then nJ=nJ*MaxGameVelocity;if dY>=nJ*(1-qK)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif dY<nJ*(1-qK)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nU=e(aV)nJ=nJ*nU/3.6;if dY>=nJ*(1-qK)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif dY<nJ*(1-qK)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fA=coroutine.status(beginSetup)if fA=="suspended"then local cs,fB=coroutine.resume(beginSetup)if fB then system.print("ERROR STARTUP: "..fB)end elseif fA=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aP and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(oB)aO.startControl(oB)end;function script.onActionStop(oB)aO.stopControl(oB)end;function script.onActionLoop(oB)aO.loopControl(oB)end;function script.onInputText(bP)aO.inputTextControl(bP)end;function script.onEnter(cA)if radar_1 and not am and not bj then unit.setTimer("contact",0.1)end end;function script.onLeave(cA)if radar_1 and CollisionSystem then if#bm>650 then cA=tostring(cA)bm[cA]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
