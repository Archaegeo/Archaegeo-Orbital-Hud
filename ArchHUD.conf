name: ArchHud - Archaegeo v1.148 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export: (Default: false)
        userControlScheme = "virtual joystick" --export: (Default: "virtual joystick") Set to "virtual joystick", "mouse", or "keyboard"
        freeLookToggle = true --export: (Default: true)
        BrakeToggleDefault = true --export: (Default: true)
        RemoteFreeze = false --export: (Default: false)
        RemoteHud = true --export: (Default: true)
        brightHud = false --export: (Default: false)
        VanillaRockets = false --export: (Default: false)
        InvertMouse = false --export: (Default: false)
        autoRollPreference = false --export: (Default: false)
        turnAssist = true --export: (Default: true)
        ExternalAGG = false --export: (Default: false)
        UseSatNav = false --export: (Default: false)
        ShouldCheckDamage = true --export: (Default: true)
        CalculateBrakeLandingSpeed = false --export: (Default: false)
        AtmoSpeedAssist = true --export: (Default: true)
        ForceAlignment = false --export: (Default: false)
        DisplayDeadZone = true --export: (Default: true)
        showHud = true --export: (Default: true) 
        ShowOdometer = true --export: (Default: true)
        hideHudOnToggleWidgets = true --export: (Default: true)
        ShiftShowsRemoteButtons = true --export: (Default: true)
        DisplayOrbit = true --export: (Default: true) 
        YawStallAngle = 35 --export: (Default: 35)
        PitchStallAngle = 35 --export: (Default: 35)
        brakeLandingRate = 30 --export: (Default: 30)
        MaxPitch = 30 --export: (Default: 30)
        TargetOrbitRadius = 1.4 --export: (Default: 1.4)
        AtmoSpeedLimit = 1050 --export: (Default: 1050)
        SpaceSpeedLimit = 30000 --export: (Default: 30000).
        AutoTakeoffAltitude = 1000 --export: (Default: 1000)
        TargetHoverHeight = 50 --export: (Default: 50)
        LandingGearGroundHeight = 0 --export: (Default: 0)
        MaxGameVelocity = 8333.00 --export: (Default: 8333.00)
        AutopilotInterplanetaryThrottle = 1.0 --export: (Default: 1.0)
        warmup = 32 --export: (Default: 32)
        fuelTankHandlingAtmo = 0 --export: (Default: 0)
        fuelTankHandlingSpace = 0 --export: (Default: 0)
        fuelTankHandlingRocket = 0 --export: (Default: 0)
        ContainerOptimization = 0 --export: (Default: 0)
        FuelTankOptimization = 0 --export: (Default: 0)
        ResolutionX = 1920 --export: (Default: 1920)
        ResolutionY = 1080 --export: (Default: 1080) 
        circleRad = 400 --export: (Default: 400)
        SafeR = 130 --export: (Default: 130)
        SafeG = 224 --export: (Default: 224)
        SafeB = 255 --export: (Default: 255)
        PvPR = 255 --export: (Default: 255)
        PvPG = 0 --export: (Default: 0)
        PvPB = 0 --export: (Default: 0)
        centerX = 960 --export: (Default: 960)
        centerY = 540 --export: (Default: 540)
        throtPosX = 1300 --export: (Default: 1300)
        throtPosY = 540 --export: (Default: 540)
        vSpdMeterX = 1525  --export: (Default: 1525)
        vSpdMeterY = 325 --export: (Default: 325)
        altMeterX = 550  --export: (Default: 550)
        altMeterY = 540 --export: (Default: 540) 
        fuelX = 100 --export: (Default: 100)
        fuelY = 300 --export: (Default: 300)
        DeadZone = 50 --export: (Default: 50)
        OrbitMapSize = 250 --export: (Default: 250)
        OrbitMapX = 75 --export: (Default: 75)
        OrbitMapY = 0 --export: (Default: 0)
        speedChangeLarge = 5 --export: (Default: 5)
        speedChangeSmall = 1 --export: (Default: 1)
        MouseXSensitivity = 0.003 --export: (Default: 0.003)
        MouseYSensitivity = 0.003 --export: (Default: 0.003)
        autoRollFactor = 2 --export: (Default: 2)
        rollSpeedFactor = 1.5 --export: (Default: 1.5)
        autoRollRollThreshold = 0 --export: (Default: 0)
        minRollVelocity = 150 --export: (Default: 150)    
        turnAssistFactor = 2 --export: (Default: 2)
        TrajectoryAlignmentStrength = 0.002 --export: (Default: 0.002)
        torqueFactor = 2 --export: (Default: 2)
        pitchSpeedFactor = 0.8 --export: (Default: 0.8)
        yawSpeedFactor = 1 --export: (Default: 1)
        brakeSpeedFactor = 3 --export: (Default: 3)
        brakeFlatFactor = 1 --export: (Default: 1)
        DampingMultiplier = 40 --export: (Default: 40) 
        apTickRate = 0.0166667 --export: (Default: 0.0166667)  
        hudTickRate = 0.0666667 --export: (Default: 0.0666667)
        ExtraLongitudeTags = "none" --export: (Default: "none")
        ExtraLateralTags = "none" --export: (Default: "none")
        ExtraVerticalTags = "none" --export: (Default: "none")
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.148;SetWaypointOnExit=true;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;showHelp=true;local b={"showHelp","VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=core.getConstructMass;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local tostring=tostring;local p=utils.round;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local function y(z,A)local B=10^(A or 0)return d(z*B+0.5)/B end;local C=SafeR;local D=SafeB;local E=SafeG;local F=false;local G=0;local H=0;local I=0;local J=false;local K=0;local L=false;local M=y(ResolutionX/2,0)local N=y(ResolutionY/2,0)local O=false;local P=55;local Q=false;local R=false;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=false;local a0=false;local a1="empty"local a2=5;local a3=5;local a4=a2;local a5=a3;local a6=false;local a7,a8=0;local a9,aa=0;local ab=nil;local ac=0;local ad=0;local ae=false;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=""local am=0;local an=false;local ao=false;local ap=false;local aq=-1;local ar=false;local as=""local at=j()>0;local au=j()local av=core.getAltitude()local aw=core.getElementIdList()local ax=q()local ay=nil;local az=false;local aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]local aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local aC={}local aD=0;local aE=0;local aF=""local aG=true;local aH={}local aI={}local aJ={}local aK=ResolutionX;local aL=ResolutionY;local aM=false;local aN=false;local aO=0;local aP=nil;local aQ={}local aR={}local aS={}local aT=0;local aU=false;local aV={}local aW={}local aX=d(1/apTickRate)*2;local aY={}local aZ={}local a_={}local b0={}local b1=false;local b2=0;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=nil;local bd=nil;local be=nil;local bf=false;local bg=false;local bh=autoRollPreference;local bi=LandingGearGroundHeight;local bj=false;local bk=q()local bl=0;local bm=0;local bn=0;local bo=AtmoSpeedLimit;local bp=0;local bq=nil;local br=0;local bs=0;local bt=false;local bu=false;local bv={VectorToTarget=false}local bw=false;local bx=0;local by=nil;local bz=false;local bA=false;local bB=false;local bC=false;local bD=0;local bE=q()local bF=vec3(core.getConstructWorldOrientationUp())local bG=vec3(core.getConstructWorldOrientationForward())local bH=vec3(core.getConstructWorldOrientationRight())local bI=vec3(core.getWorldVelocity())local bJ=vec3(bI):len()local bK=vec3(core.getWorldVertical())local bL=-bK:dot(bI)local bM=vec3(core.getConstructWorldPos())local bN=false;local bO=false;local bP=nil;local bQ=true;local bR=0;local bS=0;local bT=false;local bU={}local bV=showHud;local bW={}local function bX(bY,bZ)for i=1,#bZ do bY[#bY+1]=bZ[i]end;return bY end;local function b_(c0)local c1={}local c2={"userControlScheme","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit"}local c3={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c4={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY"}local c5={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c0 then bX(c1,c2)bX(c1,c3)bX(c1,c4)bX(c1,c5)return c1 elseif c0=="boolean"then return c2 elseif c0=="handling"then return c3 elseif c0=="hud"then return c4 elseif c0=="physics"then return c5 end end;local function c6(c7,c8,c9,ca,cb)if ca==nil then ca=""end;if cb==nil then cb=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ca,c7,c8,cb,c9)end;local function cc(cd,ce)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ce then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cd)H=r(y(cd*100,0)/100,-1,1)end;local function cf(cd,ce)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ce then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cd)bP=cd end;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*epsilon end;local function cj(aj,ck)local cl=aj>100000;local cm,cn=""if ck==nil then ck=1 end;if cl then cm,cn=y(aj/1000/200,ck),"SU"elseif aj<1000 then cm,cn=y(aj,ck),"M"else cm,cn=y(aj/1000,ck),"KM"end;return cm,cn end;local function co()if VertTakeOff then AltitudeHold=false;StrongBrakes=true;Reentry=false;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=true;VertTakeOff=false;bh=true;af=0;if at and aq==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cf(d(bo))end else VertTakeOff=true;AltitudeHold=false;bz=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end end;local function cp()bz=false;br=nil;bs=nil;bD=0;if au==0 then if IntoOrbit then IntoOrbit=false;bt=false;by=nil;bh=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bv.VectorToTarget=false;bv.AutopilotAlign=false;bw=false elseif unit.getClosestPlanetInfluence()>0 then IntoOrbit=true;bh=true;if by==nil then by=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a1="Unable to engage orbiting, not near planet"end else IntoOrbit=false;bt=false;by=nil;bh=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bv.VectorToTarget=false;bv.AutopilotAlign=false;bw=false end end;local function cq()if bE-bm<1.5 then if planet.hasAtmosphere then if au>0 then HoldAltitude=planet.spaceEngineMinAltitude-50 else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+1000;bx=HoldAltitude;bw=true;if not IntoOrbit then cp()end;bt=true end end;bm=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bm=bE end;if unit.getClosestPlanetInfluence()>0 and au==0 then bx=av;bw=true;bt=true;cp()if IntoOrbit then bm=bE else bm=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Z=false;bh=true;LockPitch=nil;bz=false;if aq==-1 then AutoTakeoff=false;if bm>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=av end end;if VertTakeOff then co()end else AutoTakeoff=true;if bm>-1 then HoldAltitude=av+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bN then co()end end;if ao then HoldAltitude=100000 end else if IntoOrbit then cp()end;if VertTakeOff then co()end;bh=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bm=0 end end;local function cr()if m()==1 then Z=not Z;if Z then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)else BrakeIsOn=true;bh=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a1="Follow Mode only works with Remote controller"Z=false end end;local function cs(planet,ct)local function cu(cv,cw)local cx=vec3(cw)if cv.bodyId==0 then return setmetatable({latitude=cx.x,longitude=cx.y,altitude=cx.z,bodyId=0,systemId=cv.planetarySystemId},MapPosition)end;local cy=cx-cv.center;local aj=cy:len()local cz=aj-cv.radius;local cA=0;local cB=0;if not cg(aj,0)then local cC=n(cy.y,cy.x)cB=cC>=0 and cC or 2*math.pi+cC;cA=math.pi/2-math.acos(cy.z/aj)end;return setmetatable({latitude=math.deg(cA),longitude=math.deg(cB),altitude=cz,bodyId=cv.bodyId,systemId=cv.planetarySystemId},MapPosition)end;local cD=cu(planet,ct)cD="::pos{"..cD.systemId..","..cD.bodyId..","..cD.latitude..","..cD.longitude..","..cD.altitude.."}"system.setWaypoint(cD)end;local function cE()local function cF(SpaceTarget)VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cq()end end;VectorStatus="Proceeding to Waypoint"end;if bE-bn<1.5 and au>0 then if not bC then a1="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if au>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+1000 end;bn=-1;if Autopilot or VectorToTarget then return end end else bn=bE end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not ao then bd.UpdateAutopilotTarget()cs(ab,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then if au~=0 then ao=true;cq()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if au>0 then if not VectorToTarget then cF(SpaceTarget)end else if av>AutopilotTargetOrbit*1.5 or av==0 then bz=false;Autopilot=true elseif not at then if IntoOrbit then cp()end;bx=planet.noAtmosphericDensityAltitude+1000;bw=true;bv.AutopilotAlign=true;bv.VectorToTarget=true;bt=false;if not IntoOrbit then cp()end end end else RetrogradeIsOn=false;ProgradeIsOn=false;if au~=0 then ao=true;cq()else Autopilot=true end end elseif au==0 then local cG=unit.getClosestPlanetInfluence()>0;if CustomTarget==nil and(ab.name==planet.name and cG)and not IntoOrbit then WaypointSet=false;bz=false;bt=false;cp()else Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Z=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;O=false;LockPitch=nil;WaypointSet=false end else ao=true;cq()end else ao=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;O=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=av;TargetSet=false;Reentry=false;if IntoOrbit then cp()end end end;local function cH(cI)local cJ=-1;local cK;cJ=bd.findAtlasIndex(SavedLocations)if cJ~=-1 then local cL;if cI~=nil then cK={position=SavedLocations[cJ].position,name=cI,atmosphere=SavedLocations[cJ].atmosphere,planetname=SavedLocations[cJ].planetname,gravity=SavedLocations[cJ].gravity}else cK={position=bM,name=SavedLocations[cJ].name,atmosphere=au,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cJ]=cK;cJ=-1;cJ=bd.findAtlasIndex(b3[0])if cJ>-1 then b3[0][cJ]=cK end;bd.UpdateAtlasLocationsList()a1=CustomTarget.name.." position updated"bd.UpdateAutopilotTarget()else a1="Name Not Found"end end;local function cM()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bh=autoRollPreference end;if BrakeIsOn then AltitudeHold=false;VectorToTarget=false;AutoTakeoff=false;VertTakeOff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;AltitudeHold=false;if VertTakeOff then co()end;if IntoOrbit then cp()end;LockPitch=nil;bh=autoRollPreference;an=false;ap=false;af=0 end end;local function cN(cO,cP,cQ)local function cR(cO,cS)cO=vec3(cO)cS=vec3(cS):normalize()local cm=cO*cS;return cm.x+cm.y+cm.z end;local cT=0.001;local cU=1;if not at or not bj or aq~=-1 or bJ<P then local cV=cQ;if cV==nil then cV=DampingMultiplier end;if cP==nil then cP=cT end;cO=vec3(cO):normalize()local cW=vec3()-cO;local cX=-cR(cW,core.getConstructWorldOrientationRight())*cU;local cY=-cR(cW,core.getConstructWorldOrientationUp())*cU;if aD==0 then aD=cX/2 end;if aE==0 then aE=cY/2 end;if c(cX)<0.1 then U=U-cX*2 else U=U-(cX+(cX-aD)*cV)end;if c(cY)<0.1 then T=T+cY*2 else T=T+cY+(cY-aE)*cV end;aD=cX;aE=cY;if c(cX)<cP and c(cY)<cP then return true end;return false elseif bj and aq==-1 then cO=bI;local cV=cQ;if cV==nil then cV=DampingMultiplier end;if cP==nil then cP=cT end;cO=vec3(cO):normalize()local cW=bG-cO;local cX=-cR(cW,core.getConstructWorldOrientationRight())*cU;local cY=-cR(cW,core.getConstructWorldOrientationUp())*cU;if aD==0 then aD=cX/2 end;if aE==0 then aE=cY/2 end;if c(cX)<0.1 then U=U-cX*5 else U=U-(cX+(cX-aD)*cV)end;if c(cY)<0.1 then T=T+cY*5 else T=T+cY+(cY-aE)*cV end;aD=cX;aE=cY;if c(cX)<cP and c(cY)<cP then return true end;return false end end;local function cZ()if Reentry then a1="Re-Entry cancelled"Reentry=false;bh=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not Q then StrongBrakes=planet.gravity*9.80665*l()<LastMaxBrakeInAtmo;if not StrongBrakes then a1="WARNING: Insufficient Brakes for Parachute Re-Entry"else Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bh=true;BrakeIsOn=false;a1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bo end else Reentry=true;AltitudeHold=true;bh=true;BrakeIsOn=false;HoldAltitude=planet.spaceEngineMinAltitude-50;local c9,c_=cj(HoldAltitude)a1="Beginning Re-entry.  Target speed: "..bo.." Target Altitude: "..c9 ..c_;cf(d(bo))end;AutoTakeoff=false end;local function d0()if antigrav and not ExternalAGG then if bO then antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=av end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;antigrav.activate()antigrav.show()end end end;local function d1(d2)local d3=0;local d4=0;local d5=0;if d2<60 then d2=d(d2)elseif d2<3600 then d3=d(d2/60)d2=d(d2%60)elseif d2<86400 then d4=d(d2/3600)d3=d(d2%3600/60)else d5=d(d2/86400)d4=d(d2%86400/3600)end;if d5>0 then return d5 .."d "..d4 .."h "elseif d4>0 then return d4 .."h "..d3 .."m "elseif d3>0 then return d3 .."m "..d2 .."s"elseif d2>0 then return d2 .."s"else return"0s"end end;local function d6()local d7=-1;if telemeter_1 then d7=telemeter_1.getDistance()end;if aq~=-1 and d7~=-1 then if aq<d7 then return aq else return d7 end elseif aq~=-1 then return aq else return d7 end end;local function d8(d9)local function da(db)for dc,dd in pairs(db)do dbHud_1.setStringValue(dd,g(_G[dd]))if d9 and dbHud_2 then dbHud_2.setStringValue(dd,g(_G[dd]))end end end;if dbHud_1 then if not ae then da(b)da(b_())system.print("Saved Variables to Datacore")if d9 and dbHud_2 then a1="Databank copied.  Remove copy when ready."end end end end;local function de()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function df()local function dg(dh)return type(dh)=='number'end;local function di(dh)return type(tonumber(dh))=='number'end;local function dj(dk)return type(dk)=='table'end;local function dl(dm)return type(dm)=='string'end;local function dn(dd)return dj(dd)and dg(dd.x and dd.y and dd.z)end;local function dp(dq)return dj(dq)and dg(dq.latitude and dq.longitude and dq.altitude and dq.bodyId and dq.systemId)end;local dr=math.pi/180;local ds=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local du=r;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*epsilon end;local function dv(dh)local cm=string.gsub(string.reverse(e('%.4f',dh)),'^0*%.?','')return cm==''and'0'or string.reverse(cm)end;local function dw(dx)if dn(dx)then return e('{x=%.3f,y=%.3f,z=%.3f}',dx.x,dx.y,dx.z)end;if dj(dx)and not getmetatable(dx)then local dy={}local dz=next(dx)if type(dz)=='nil'or dz==1 then dy=dx else for dc,dd in pairs(dx)do local cd=dw(dd)if type(dc)=='number'then table.insert(dy,e('[%s]=%s',dc,cd))else table.insert(dy,e('%s=%s',dc,cd))end end end;return e('{%s}',table.concat(dy,','))end;if dl(dx)then return e("'%s'",dx:gsub("'",[[\']]))end;return tostring(dx)end;local dA={}dA.__index=dA;dA.__tostring=function(dx,dB)local dC={}for dc in pairs(dx)do table.insert(dC,dc)end;table.sort(dC)local dy={}for _,dc in ipairs(dC)do local cd=dw(dx[dc])if type(dc)=='number'then table.insert(dy,e('[%s]=%s',dc,cd))else table.insert(dy,e('%s=%s',dc,cd))end end;if dB then return e('%s%s',dB,table.concat(dy,',\n'..dB))end;return e('{%s}',table.concat(dy,','))end;dA.__eq=function(dD,dE)return dD.planetarySystemId==dE.planetarySystemId and dD.bodyId==dE.bodyId and cg(dD.radius,dE.radius)and cg(dD.center.x,dE.center.x)and cg(dD.center.y,dE.center.y)and cg(dD.center.z,dE.center.z)and cg(dD.GM,dE.GM)end;local function dF(dG,dH,dI,cw,dJ)assert(di(dG),'Argument 1 (planetarySystemId) must be a number:'..type(dG))assert(di(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(di(dI),'Argument 3 (radius) must be a number:'..type(dI))assert(dj(cw),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cw))assert(di(dJ),'Argument 5 (GM) must be a number:'..type(dJ))return setmetatable({planetarySystemId=tonumber(dG),bodyId=tonumber(dH),radius=tonumber(dI),center=vec3(cw),GM=tonumber(dJ)},dA)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dK)return e('::pos{%d,%d,%s,%s,%s}',dK.systemId,dK.bodyId,dv(dK.latitude*ds),dv(dK.longitude*ds),dv(dK.altitude))end;MapPosition.__eq=function(dD,dE)return dD.bodyId==dE.bodyId and dD.systemId==dE.systemId and cg(dD.latitude,dE.latitude)and cg(dD.altitude,dE.altitude)and(cg(dD.longitude,dE.longitude)or cg(dD.latitude,math.pi/2)or cg(dD.latitude,-math.pi/2))end;local function dL(dM,dH,cA,cB,cz)local dG=dM;if dl(dM)and not cB and not cz and not dH and not cA then dG,dH,cA,cB,cz=o(dM,dt)assert(dG,'Argument 1 (position string) is malformed.')else assert(di(dG),'Argument 1 (systemId) must be a number:'..type(dG))assert(di(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(di(cA),'Argument 3 (latitude) must be in degrees:'..type(cA))assert(di(cB),'Argument 4 (longitude) must be in degrees:'..type(cB))assert(di(cz),'Argument 5 (altitude) must be in meters:'..type(cz))end;dG=tonumber(dG)dH=tonumber(dH)cA=tonumber(cA)cB=tonumber(cB)cz=tonumber(cz)if dH==0 then return setmetatable({latitude=cA,longitude=cB,altitude=cz,bodyId=dH,systemId=dG},MapPosition)end;return setmetatable({latitude=dr*du(cA,-90,90),longitude=dr*(cB%360),altitude=cz,bodyId=dH,systemId=dG},MapPosition)end;local dN={}dN.__index=dN;dN.__tostring=function(dx,dB)local dO=dB and dB..'  'local dP={}local dC={}for dc in pairs(dx)do table.insert(dC,dc)end;table.sort(dC)for _,dQ in ipairs(dC)do bdy=dx[dQ]local dR=dA.__tostring(bdy,dO)if dB then table.insert(dP,e('[%s]={\n%s\n%s}',dQ,dR,dB))else table.insert(dP,e('  [%s]=%s',dQ,dR))end end;if dB then return e('\n%s%s%s',dB,table.concat(dP,',\n'..dB),dB)end;return e('{\n%s\n}',table.concat(dP,',\n'))end;local function dS(dT)local b3={}local pid;for _,dd in pairs(dT)do local dU=dd.planetarySystemId;if type(dU)~='number'then error('Invalid planetary system ID: '..tostring(dU))elseif pid and dU~=pid then error('Mistringmatch planetary system IDs: '..dU..' and '..pid)end;local dV=dd.bodyId;if type(dV)~='number'then error('Invalid body ID: '..tostring(dV))elseif b3[dV]then error('Duplicate body ID: '..tostring(dV))end;setmetatable(dd.center,getmetatable(vec3.unit_x))b3[dV]=setmetatable(dd,dA)pid=dU end;return setmetatable(b3,dN)end;b7={}local function dW(dT)return setmetatable({galaxyAtlas=dT or{}},b7)end;b7.__index=function(dk,i)if type(i)=='number'then local system=dk.galaxyAtlas[i]return dS(system)end;return rawget(b7,i)end;b7.__pairs=function(dx)return function(dk,dc)local dX,nv=next(dk,dc)return dX,nv and dS(nv)end,dx.galaxyAtlas,nil end;b7.__tostring=function(dx)local dY={}for _,dZ in pairs(dx or{})do local d_=dZ:getPlanetarySystemId()local e0=dN.__tostring(dZ,'    ')table.insert(dY,e('  [%s]={%s\n  }',d_,e0))end;return e('{\n%s\n}\n',table.concat(dY,',\n'))end;b7.BodyParameters=dF;b7.MapPosition=dL;b7.PlanetarySystem=dS;function b7.createBodyParameters(e1,dH,e2,e3,e4,e5,e6)assert(di(e1),'Argument 1 (planetarySystemId) must be a number:'..type(e1))assert(di(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(di(e2),'Argument 3 (surfaceArea) must be a number:'..type(e2))assert(dj(e3),'Argument 4 (aPosition) must be an array or vec3:'..type(e3))assert(dj(e4),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(e4))assert(di(e5),'Argument 6 (altitude) must be in meters:'..type(e5))assert(di(e6),'Argument 7 (gravityAtPosition) must be number:'..type(e6))local dI=math.sqrt(e2/4/math.pi)local aj=dI+e5;local e7=vec3(e3)+aj*vec3(e4)local dJ=e6*aj*aj;return dF(e1,dH,dI,e7,dJ)end;b7.isMapPosition=dp;function b7:getPlanetarySystem(dM)if i==nil then i=0 end;if nv==nil then nv=0 end;local e1=dM;if dp(dM)then e1=dM.systemId end;if type(e1)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dN then system=dS(system)end;return system end end end;function dN:castIntersections(e8,cS,e9,ea)local e9=e9 or function(eb)return 1.05*eb.radius end;local ec={}if ea then for _,i in ipairs(ea)do ec[i]=self[i]end else ea={}for dc,eb in pairs(self)do table.insert(ea,dc)ec[dc]=eb end end;local function ed(ee,ef)local eg=ec[ee].center-e8;local eh=ec[ef].center-e8;return eg:len()<eh:len()end;table.sort(ea,ed)local ei=cS:normalize()for i,dU in ipairs(ea)do local eb=ec[dU]local ej=eb.center-e8;local dI=e9(eb)local ek=ej:dot(ei)local el=ek^2-(ej:len2()-dI^2)if el>=0 then local em=math.sqrt(el)local en=ek+em;local eo=ek-em;if eo>0 then return eb,en,eo elseif en>0 then return eb,en,nil end end end;return nil,nil,nil end;function dN:closestBody(ct)assert(type(ct)=='table','Invalid coordinates.')local ep,eb;local eq=vec3(ct)for _,er in pairs(self)do local es=(er.center-eq):len2()if(not eb or es<ep)and er.name~="Space"then eb=er;ep=es end end;return eb end;function dN:convertToBodyIdAndWorldCoordinates(dM)local et=dM;if dl(dM)then et=dL(dM)end;if et.bodyId==0 then return 0,vec3(et.latitude,et.longitude,et.altitude)end;local er=self:getBodyParameters(et)if er then return et.bodyId,er:convertToWorldCoordinates(et)end end;function dN:getBodyParameters(dM)local dH=dM;if dp(dM)then dH=dM.bodyId end;assert(di(dH),'Argument 1 (bodyId) must be a number:'..type(dH))return self[dH]end;function dN:getPlanetarySystemId()local _,dd=next(self)return dd and dd.planetarySystemId end;function dA:convertToMapPosition(cw)assert(dj(cw),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cw))local cx=vec3(cw)if self.bodyId==0 then return setmetatable({latitude=cx.x,longitude=cx.y,altitude=cx.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local cy=cx-self.center;local aj=cy:len()local cz=aj-self.radius;local cA=0;local cB=0;if not cg(aj,0)then local cC=n(cy.y,cy.x)cB=cC>=0 and cC or 2*math.pi+cC;cA=math.pi/2-math.acos(cy.z/aj)end;return setmetatable({latitude=cA,longitude=cB,altitude=cz,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dA:convertToWorldCoordinates(dM)local et=dl(dM)and dL(dM)or dM;if et.bodyId==0 then return vec3(et.latitude,et.longitude,et.altitude)end;assert(dp(et),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(et.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(et.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local eu=math.cos(et.latitude)return self.center+(self.radius+et.altitude)*vec3(eu*math.cos(et.longitude),eu*math.sin(et.longitude),math.sin(et.latitude))end;function dA:getAltitude(cw)return(vec3(cw)-self.center):len()-self.radius end;function dA:getDistance(cw)return(vec3(cw)-self.center):len()end;function dA:getGravity(cw)local ev=self.center-vec3(cw)local ew=ev:len2()return self.GM/ew*ev/math.sqrt(ew)end;return setmetatable(b7,{__call=function(_,...)return dW(...)end})end;local function ex()local b9={}local ey=30000000/3600;local ez=ey*ey;local eA=100;local function eB(dd)return 1/math.sqrt(1-dd*dd/ez)end;function b9.computeAccelerationTime(eC,eD,eE)local eF=ey*math.asin(eC/ey)return(ey*math.asin(eE/ey)-eF)/eD end;function b9.computeDistanceAndTime(eC,eE,eG,eH,eI,eJ)eI=eI or 0;eJ=eJ or 0;local eK=eC<=eE;local eL=eH*(eK and 1 or-1)/eG;local eM=-eJ/eG;local eN=eL+eM;if eK and eN<=0 or not eK and eN>=0 then return-1,-1 end;local eO,eP=0,0;if eL~=0 and eI>0 then local eF=math.asin(eC/ey)local eQ=math.pi*(eL/2+eM)local eR=eL*eI;local eS=ey*math.pi;local dd=function(dk)local eT=(eQ*dk-eR*math.sin(math.pi*dk/2/eI)+eS*eF)/eS;local eU=math.tan(eT)return ey*eU/math.sqrt(eU*eU+1)end;local eV=eK and function(dm)return dm>=eE end or function(dm)return dm<=eE end;eP=2*eI;if eV(dd(eP))then local eW=0;while c(eP-eW)>0.5 do local dk=(eP+eW)/2;if eV(dd(dk))then eP=dk else eW=dk end end end;local eX=eC;local eY=eP/eA;for eZ=1,eA do local e_=dd(eZ*eY)eO=eO+(e_+eX)*eY/2;eX=e_ end;if eP<2*eI then return eO,eP end;eC=eX end;local eF=ey*math.asin(eC/ey)local bE=(ey*math.asin(eE/ey)-eF)/eN;local f0=ez*math.cos(eF/ey)/eN;local aj=f0-ez*math.cos((eN*bE+eF)/ey)/eN;return aj+eO,bE+eP end;function b9.computeTravelTime(eC,eD,aj)if aj==0 then return 0 end;if eD>0 then local eF=ey*math.asin(eC/ey)local f0=ez*math.cos(eF/ey)/eD;return(ey*math.acos(eD*(f0-aj)/ez)-eF)/eD end;if eC==0 then return-1 end;assert(eC>0,'Acceleration and initial speed are both zero.')return aj/eC end;function b9.lorentz(dd)return eB(dd)end;return b9 end;local function f1()local vec3=require('cpml.vec3')local df=df()local function dl(dm)return type(dm)=='string'end;local function dj(dk)return type(dk)=='table'end;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*constants.epsilon end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cz)assert(self.body)local aj=cz+self.body.radius;if not cg(aj,0)then local orbit=math.sqrt(self.body.GM/aj)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dM,f2)assert(self.body)assert(dj(dM)or dl(dM))assert(dj(f2))local f3=(dl(dM)or df.isMapPosition(dM))and self.body:convertToWorldCoordinates(dM)or vec3(dM)local dd=vec3(f2)local f4=f3-self.body.center;local eh=dd:len2()local f5=f4:len()local f6=self.body.GM;local f7=((eh-f6/f5)*f4-f4:dot(dd)*dd)/f6;local ch=f6/(2*f6/f5-eh)local f8=f7:len()local ei=f7:normalize()local f9=ch*(1-f8)local fa=ch*(1+f8)local fb=f9*ei+self.body.center;local fc=f8<=1 and-fa*ei+self.body.center or nil;local fd=math.sqrt(ch*f6*(1-f8*f8))local fe=fc and 2*math.pi*math.sqrt(ch^3/f6)local ff=math.acos(f7:dot(f4)/(f8*f5))if f4:dot(dd)<0 then ff=-(ff-2*math.pi)end;local fg=math.acos((math.cos(ff)+f8)/(1+f8*math.cos(ff)))local fh=fg;if fh<0 then fh=fh+2*math.pi end;local fi=fh-f8*math.sin(fh)local fj=0;local fk=0;local fl=0;if fe~=nil then fj=fi/(2*math.pi/fe)fk=fe-fj;fl=fk+fe/2;if ff-math.pi>0 then fk=fj;fl=fk+fe/2 end;if fl>fe then fl=fl-fe end end;return{periapsis={position=fb,speed=fd/f9,circularOrbitSpeed=math.sqrt(f6/f9),altitude=f9-self.body.radius},apoapsis=fc and{position=fc,speed=fd/fa,circularOrbitSpeed=math.sqrt(f6/fa),altitude=fa-self.body.radius},currentVelocity=dd,currentPosition=f3,eccentricity=f8,period=fe,eccentricAnomaly=fg,meanAnomaly=fi,timeToPeriapsis=fk,timeToApoapsis=fl}end;local function fm(fn)local er=df.BodyParameters(fn.planetarySystemId,fn.bodyId,fn.radius,fn.center,fn.GM)return setmetatable({body=er},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return fm(...)end})end;local function fo()local function fp(dd)if aK==1920 then return dd else return y(aK*dd/1920,0)end end;local function fq(dd)if aL==1080 then return dd else return y(aL*dd/1080,0)end end;local function fr()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function fs()local ft="TRAVEL"if not bQ then ft="CRUISE"end;if Autopilot then ft="AUTOPILOT"end;return ft end;local function fu(fv,b1,c7,fw,fx,fy,fz,fA)local fB=1;local fC=2;local fD=3;local fE=4;local fF=5;local fG=6;local fH=""local fI=0;local fJ=fuelY;local fK=fuelY+10;if m()==1 and not RemoteHud then fJ=fJ-50;fK=fK-50 end;if fx=="ATMO"then fH="atmofueltank"elseif fx=="SPACE"then fH="spacefueltank"else fH="rocketfueltank"end;fI=_G[fH.."_size"]if#fy>0 then for i=1,#fy do local fL=string.sub(fy[i][fC],1,12)local fM=0;for fN=1,fI do if fy[i][fC]==f(unit[fH.."_"..fN].getData()).name then fM=fN;break end end;if b1 or fz[i]==nil or fA[i]==nil then local fO=0;local fP=0;local fQ=0;local fR=0;local fS=q()if fM~=0 then fA[i]=f(unit[fH.."_"..fM].getData()).percentage;fz[i]=f(unit[fH.."_"..fM].getData()).timeLeft;if fz[i]=="n/a"then fz[i]=0 end else fQ=k(fy[i][fB])-fy[i][fE]fO=fy[i][fD]fA[i]=d(0.5+fQ*100/fO)fP=fy[i][fF]fR=fy[i][fG]if fP<=fQ then fz[i]=0 else fz[i]=d(0.5+fQ/((fP-fQ)/(fS-fR)))end;fy[i][fF]=fQ;fy[i][fG]=fS end end;if fL==fw then fL=e("%s %d",fx,i)end;if fM==0 then fL=fL.." *"end;local fT;if fz[i]==0 then fT="n/a"else fT=d1(fz[i])end;if fA[i]~=nil then local fU=d(fA[i]*2.55)local fV=e("rgb(%d,%d,%d)",255-fU,fU,0)local ca=""if fT~="n/a"and fz[i]<120 or fA[i]<5 then if b1 then ca=[[class="red"]]end end;fv[#fv+1]=c6(c7,fJ,fL,ca.." pdim txtfuel")fv[#fv+1]=c6(c7,fK,e("%d%% %s",fA[i],fT),"pdim txtfuel","fill:"..fV)fJ=fJ+30;fK=fK+30 end end end end;local function fW(fv,cz)if cz<200000 and not at or cz and at then local fX=0;if c(bL)>1 then fX=45*math.log(c(bL),10)if bL<0 then fX=-fX end end;fv[#fv+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bL),d(fX))end;return fv end;local function fY(fZ)local f_=-bK;fZ=fZ-fZ:project_on(f_)local g0=vec3(0,0,1)g0=g0-g0:project_on(f_)local g1=g0:cross(f_)local fX=g0:angle_between(fZ)*constants.rad2deg;if fZ:dot(g1)<0 then fX=360-fX end;return fX end;local function g2(fv,centerX,centerY,g3,g4,cG)local g5=circleRad;local g6=20;local g7=d(g3)if cG then for i=-45,45,5 do local g8=i;fv[#fv+1]=e([[<g transform="rotate(%f,%d,%d)">]],g8,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fv[#fv+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+g5+g6-len,centerX,centerY+g5+g6)end;fv[#fv+1]=c6(centerX,centerY+g5+g6-35,g4,"pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY+g5+g6-25,g7 .." deg","pdim txt txtmid")fv[#fv+1]=e([[<g transform="rotate(%f,%d,%d)">]],-g3,centerX,centerY)fv[#fv+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+g5+g6-20,centerX+5,centerY+g5+g6-20,centerX,centerY+g5+g6-15)fv[#fv+1]="</g>"end;local g9=g7;if cG then g9=fY(bG)end;local ga=20;local gb=d(g9)local gc=0;local gd=centerY+g5+g6+20;local ge=centerX;if g4~="YAW"then gd=fq(130)ge=fp(960)end;local gf=[[<path class="txttick line" d="]]for i=d(gb-(ga+10)-gb%5+0.5),d(gb+ga+10+gb%5+0.5),5 do local c7=ge+-i*5+g9*5;if i%10==0 then gc=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;fv[#fv+1]=c6(c7+5,gd-12,z)elseif i%5==0 then gc=5 end;if gc==10 then gf=e([[%s M %f %f v %d]],gf,c7,gd-5,gc)else gf=e([[%s M %f %f v %d]],gf,c7,gd-2.5,gc)end end;fv[#fv+1]=gf..[["/>]]fv[#fv+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ge-5,gd+10,ge+5,gd+10,ge,gd+5)if cG then g4="HDG"end;fv[#fv+1]=c6(ge,gd+25,gb.."deg","pdim txt txtmid","")fv[#fv+1]=c6(ge,gd+35,g4,"pdim txt txtmid","")end;local function gg(fv,gh,g3,centerX,centerY,cG,gi,e_)local g5=circleRad;local gj=d(g5*3/5)if g5>0 then local gk=d(gh)local len=0;local gf=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*g3,centerX,centerY)if not at then gf=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fv[#fv+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],g5-1,centerX,centerY)fv[#fv+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gk-30-gk%5+0.5),d(gk+30+gk%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local c8=centerY+-i*5+gh*5;if len==30 then gf=e([[%s M %d %f h %d]],gf,centerX-gj-len,c8,len)if at then fv[#fv+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*g3,centerX,centerY,centerX-gj+10,c8,i)fv[#fv+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*g3,centerX,centerY,centerX+gj-10,c8,i)if i==0 or i==180 or i==-180 then fv[#fv+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*g3,centerX,centerY,centerX-gj+20,c8,gj*2-40)end else fv[#fv+1]=c6(centerX-gj+10,c8,i,"pdim txt txtmid")fv[#fv+1]=c6(centerX+gj-10,c8,i,"pdim txt txtmid")end;gf=e([[%s M %d %f h %d]],gf,centerX+gj,c8,len)else gf=e([[%s M %d %f h %d]],gf,centerX-gj-len,c8,len)gf=e([[%s M %d %f h %d]],gf,centerX+gj,c8,len)end end;fv[#fv+1]=gf..[["/>]]local gl="PITCH"if not cG then gl="REL PITCH"end;if gh>90 and not at then gh=90-(gh-90)elseif gh<-90 and not at then gh=-90-(gh+90)end;if g5>200 then if at then if e_>P then fv[#fv+1]=c6(centerX,centerY-15,"Yaw","pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY+20,gi,"pdim txt txtmid")end;fv[#fv+1]=e([[<g transform="rotate(%f,%d,%d)">]],-g3,centerX,centerY)else fv[#fv+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fv[#fv+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gj+25,centerY-5,centerX-gj+20,centerY,centerX-gj+25,centerY+5,centerX-gj+50,centerY+4,gk)fv[#fv+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gj-25,centerY-5,centerX+gj-20,centerY,centerX+gj-25,centerY+5,centerX+gj-30,centerY+4,gk)fv[#fv+1]="</g>"end;local gm=d(g5/3)fv[#fv+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gm,centerY,g5-gm)if not at and cG then fv[#fv+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*g3,centerX,centerY,centerX-gj+10,centerY,gj*2-20)end;fv[#fv+1]="</g>"if g5<200 then if at and e_>P then fv[#fv+1]=c6(centerX,centerY-g5,gl,"pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY-g5+10,gk,"pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY-15,"Yaw","pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY+20,gi,"pdim txt txtmid")else fv[#fv+1]=c6(centerX,centerY-g5,gl,"pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY-g5+15,gk,"pdim txt txtmid")end end end end;local function gn(fv,cz,cG)local go=altMeterX;local gp=altMeterY;local gq=78;local gr=19;local gs=d6()if gs~=-1 then fv[#fv+1]=c6(go+gq,gp+gr+20,e("AGL: %.1fm",gs),"pdim altsm txtend")end;if cG and(cz<200000 and not at or cz and at)then table.insert(fv,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],go-1,gp-4,gq+2,gr+6,go+1,gp-1,gq-4,gr))local cJ=0;local gt=1;local gu=0;local gv=cz<0;local gw=9;if gv then gw=0 end;local cz=c(cz)while cJ<6 do local gx=11;local gy=16;local gz=9;local gA=14;local ca="altsm"if cJ>2 then gy=gy+3;gx=gx+2;gA=gA+2;gz=gz-6;ca="altbig"end;if gv then ca=ca.." red"end;local gB=cz/gt%10;local gC=d(gB)local gD=d((gC+1)%10)local gE=gu;if cJ==0 then gE=gB-gC;if gv then gE=1-gE end end;if gv and(cJ==0 or gu~=0)then local gF=gD;gD=gC;gC=gF end;local gG=gy*(gE-1)local gH=gG+gy;local c7=go+gz+(6-cJ)*gx;local c8=gp+gA;fv[#fv+1]=c6(c7,c8+gG,gD,ca)fv[#fv+1]=c6(c7,c8+gH,gC,ca)cJ=cJ+1;gt=gt*10;if gC==gw then gu=gE else gu=0 end end;table.insert(fv,[[</g></g>]])end end;local function gI(f2)f2=vec3(f2)local gJ=-math.deg(n(f2.y,f2.z))+180;gJ=gJ-90;if gJ<0 then gJ=360+gJ end;if gJ>180 then gJ=-180+gJ-180 end;return-gJ end;local function gK(f2)f2=vec3(f2)local g9=math.deg(n(f2.y,f2.x))-90;if g9<-180 then g9=360+g9 end;return g9 end;local function gL(fv,f2,e_,centerX,centerY)if e_>5 and not at or e_>P then local g5=circleRad;local gM=20;local gN=20;local gO=vec3(f2)local gP=gI(gO)local gQ=gK(gO)local gR=14;local gS=gR/2;local gT=-gQ/gN*g5;local gU=gP/gM*g5;local c7=centerX+gT;local c8=centerY+gU;local aj=math.sqrt(gT^2+gU^2)local gV=[[<circle
                            cx="]]..c7 ..[["
                            cy="]]..c8 ..[["
                            r="]]..gS/gR..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c7 ..[["
                            cy="]]..c8 ..[["
                            r="]]..gS..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c7-gR..[[,]]..c8 ..[[ h ]]..gS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c7+gS..[[,]]..c8 ..[[ h ]]..gS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c7 ..[[,]]..c8-gR..[[ v ]]..gS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<g5 then fv[#fv+1]=gV else local fX=n(gU,gT)local gW=4;local gX=centerX+g5*math.cos(fX)local gY=centerY+g5*math.sin(fX)fv[#fv+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',fX*180/math.pi,gX,gY,gX-gW,gY-gW/2,gW*2,gW,gX+gW,gY-gW,gW,gW,-gW,gW)end;if not at then gP=gI(-gO)gQ=gK(-gO)gT=-gQ/gN*g5;gU=gP/gM*g5;c7=centerX+gT;c8=centerY+gU;aj=math.sqrt(gT^2+gU^2)if aj<g5 then local gZ=[[<circle
                                    cx="]]..c7 ..[["
                                    cy="]]..c8 ..[["
                                    r="]]..gS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c7 ..[[,]]..c8-gR..[[ v ]]..gS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c7 ..[[,]]..c8 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c7 ..[[,]]..c8 ..[[)" />
                                <path
                                    d="M ]]..c7-gS..[[,]]..c8 ..[[ h ]]..gR..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c7 ..[[,]]..c8 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c7 ..[[,]]..c8 ..[[)"/>]]fv[#fv+1]=gZ end end end end;local function g_(fv,ft,h0,h1)h0=d(h0+0.5)local fJ=throtPosY+10;local fK=throtPosY+20;if m()==1 and not RemoteHud then fJ=55;fK=65 end;local h2="CRUISE"local unit="km/h"local cd=h1;if ft=="TRAVEL"or ft=="AUTOPILOT"then h2="THROT"unit="%"cd=h0;local h3="dim"if h0<0 then h3="red"end;fv[#fv+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],h3,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(h0),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fv[#fv+1]=c6(throtPosX+10,fJ,h2,"pbright txtstart")fv[#fv+1]=c6(throtPosX+10,fK,e("%.0f %s",cd,unit),"pbright txtstart")if at and AtmoSpeedAssist and bQ and J then h0=d(K*100+0.5)local h3="red"if h0<0 then h3="red"end;fv[#fv+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],h3,1-c(h0),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fv[#fv+1]=c6(throtPosX+10,fJ+40,"LIMIT","pbright txtstart")fv[#fv+1]=c6(throtPosX+10,fK+40,h0 .."%","pbright txtstart")end;if at and AtmoSpeedAssist or Reentry then fv[#fv+1]=c6(throtPosX+10,fJ-40,"LIMIT: "..bo.." km/h","dim txtstart")elseif not at and Autopilot then fv[#fv+1]=c6(throtPosX+10,fJ-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function h4(fv,h5)local h6=throtPosY-10;local h7=throtPosX+10;fv[#fv+1]=c6(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then h6=75 end;fv[#fv+1]=c6(h7,h6,d(h5).." km/h","pbright txtbig txtstart")end;local function h8(fv)fv[#fv+1]=c6(fp(1900),fq(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fv[#fv+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fv[#fv+1]=c6(fp(960),fq(550),"Warning: Invalid Control Scheme Detected","warnings")fv[#fv+1]=c6(fp(960),fq(600),"Keyboard Scheme must be selected","warnings")fv[#fv+1]=c6(fp(960),fq(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local h9=fp(960)local ha=fq(860)local hb=fq(880)local hc=fq(900)local hd=fq(960)local he=fq(200)local hf=fq(150)local hg=fq(960)if m()==1 and not RemoteHud then ha=fq(135)hb=fq(155)hc=fq(175)he=fq(115)hf=fq(95)end;if BrakeIsOn then fv[#fv+1]=c6(h9,ha,"Brake Engaged","warnings")elseif I>0 then fv[#fv+1]=c6(h9,ha,"Auto-Brake Engaged","warnings","opacity:"..I)end;if at and bj and aq==-1 then fv[#fv+1]=c6(h9,he+50,"** STALL WARNING **","warnings")end;if ay then fv[#fv+1]=c6(h9,hg,"Gyro Enabled","warnings")end;if GearExtended then if R then fv[#fv+1]=c6(h9,hb,"Gear Extended","warn")else fv[#fv+1]=c6(h9,hb,"Landed (G: Takeoff)","warnings")end;local hh,cn=cj(a:getTargetGroundAltitude())fv[#fv+1]=c6(h9,hc,"Hover Height: "..hh..cn,"warn")end;if a6 then fv[#fv+1]=c6(h9,hd+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bO and AntigravTargetAltitude~=nil then if c(av-antigrav.getBaseAltitude())<501 then fv[#fv+1]=c6(h9,he+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fv[#fv+1]=c6(h9,he+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fv[#fv+1]=c6(h9,he+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fv[#fv+1]=c6(h9,he+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Z then fv[#fv+1]=c6(h9,he+20,"Follow Mode Engaged","warn")elseif Reentry then fv[#fv+1]=c6(h9,he+20,"Re-entry in Progress","warn")end;local hi,en,eo=b8:getPlanetarySystem(0):castIntersections(bM,bI:normalize(),function(eb)if eb.noAtmosphericDensityAltitude>0 then return eb.radius+eb.noAtmosphericDensityAltitude else return eb.radius+eb.surfaceMaxAltitude*1.5 end end)local hj=en;if eo~=nil and en~=nil then hj=math.min(eo,en)end;if AltitudeHold or VertTakeOff then local hh,cn=cj(HoldAltitude,2)if VertTakeOff then if bO then hh,cn=cj(antigrav.getBaseAltitude(),2)end;fv[#fv+1]=c6(h9,he,"VTO to "..hh..cn,"warn")elseif AutoTakeoff and not IntoOrbit then fv[#fv+1]=c6(h9,he,"Takeoff to "..hh..cn,"warn")if BrakeIsOn and not VertTakeOff then fv[#fv+1]=c6(h9,he+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fv[#fv+1]=c6(h9,he,"Altitude Hold: "..hh..cn,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if au>0.1 then fv[#fv+1]=c6(h9,he,"Beginning ascent","warn")elseif au<0.09 and au>0.05 then fv[#fv+1]=c6(h9,he,"Aligning trajectory","warn")elseif au<0.05 then fv[#fv+1]=c6(h9,he,"Leaving atmosphere","warn")end end;if IntoOrbit then if bq~=nil then fv[#fv+1]=c6(h9,he,bq,"warn")end end;if BrakeLanding then if StrongBrakes then fv[#fv+1]=c6(h9,he,"Brake-Landing","warnings")else fv[#fv+1]=c6(h9,he,"Coast-Landing","warnings")end end;if ProgradeIsOn then fv[#fv+1]=c6(h9,he,"Prograde Alignment","crit")end;if RetrogradeIsOn then fv[#fv+1]=c6(h9,he,"Retrograde Alignment","crit")end;if hj~=nil and au==0 then local hh,cn=cj(hj)local travelTime=b9.computeTravelTime(bJ,0,hj)local hk="Collision"if hi.noAtmosphericDensityAltitude>0 then hk="Atmosphere"end;fv[#fv+1]=c6(h9,hf,hi.name.." "..hk.." "..d1(travelTime).." In "..hh..cn,"crit")end;if VectorToTarget and not IntoOrbit then fv[#fv+1]=c6(h9,he+35,VectorStatus,"warn")end;fv[#fv+1]="</g>"return fv end;local function hl(e_)return d(y(e_*3.6,0)+0.5).." km/h"end;local function hm(fv)local hn=OrbitMapX;local ho=OrbitMapY;local hp=OrbitMapSize;local hq=4;local hr=15;local c7=0;local c8=0;local hs,ht,hu,hv;local function hw(type)local hx,bE,e_,hy;if type=="Periapsis"then hx=orbit.periapsis.altitude;bE=orbit.timeToPeriapsis;e_=orbit.periapsis.speed;hy=35 else hx=orbit.apoapsis.altitude;bE=orbit.timeToApoapsis;e_=orbit.apoapsis.speed;hy=-35 end;fv[#fv+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c7+hy,c8-5,hn+hp/2-hs+hv,c8-5)fv[#fv+1]=c6(c7,c8,type)c8=c8+hr;local hh,cn=cj(hx)fv[#fv+1]=c6(c7,c8,hh..cn)c8=c8+hr;fv[#fv+1]=c6(c7,c8,d1(bE))c8=c8+hr;fv[#fv+1]=c6(c7,c8,hl(e_))end;if orbit~=nil and au<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then ho=ho+hq;c7=hn+hp+hn/2+hq;c8=ho+hp/2+5+hq;hs=hp/4;hv=0;fv[#fv+1]=[[<g class="pbright txtorb txtmid">]]fv[#fv+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hp+hn*2,hp+ho,hq,hq)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hu=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hs*2)ht=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hu*(1-orbit.eccentricity)hv=hs-orbit.periapsis.altitude/hu-planet.radius/hu;local hz=""if orbit.periapsis.altitude<=0 then hz='redout'end;fv[#fv+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hz,hn+hp/2+hv+hq,ho+hp/2+hq,hs,ht)fv[#fv+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hn+hp/2+hq,ho+hp/2+hq,planet.radius/hu)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hw("Apoapsis")end;c8=ho+hp/2+5+hq;c7=hn-hn/2+10+hq;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hw("Periapsis")end;fv[#fv+1]=c6(hn+hp/2+hq,planet.name,20+hq,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hA=orbit.timeToApoapsis/orbit.period*2*math.pi;local hB=hs*math.cos(hA)local hC=ht*math.sin(hA)fv[#fv+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hn+hp/2+hB+hv+hq,ho+hp/2+hC+hq)end;fv[#fv+1]=[[</g>]]return fv else return fv end end;local function hD()if radarPanelID~=nil and am==0 then t(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then t(perisPanelID)perisPanelID=nil end else if am==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;am=0 end end;local function hE(fv)local c7=50;local c8=525;local hF={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hG={"Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to +1k over atmosphere and orbit to target","Alt-5: Lock Pitch at current pitch","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-9: Activate Gyroscope"}local hH={"Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at 1k over atmosphere","Alt-9: Activate Gyroscope"}local hI={"CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if at then bX(hF,hG)table.insert(hF,"---------------------------------------")if VertTakeOff then table.insert(hF,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if aq~=-1 then if antigrav then if bO then table.insert(hF,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hF,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hF,"Alt-6: Begins Vertical Takeoff.")else table.insert(hF,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hF,"G: Begin BrakeLanding or Land")end else bX(hF,hH)end;if AltitudeHold then table.insert(hF,"Alt-Spacebar/Alt-C will raise/lower target height")end;table.insert(hF,"---------------------------------------")bX(hF,hI)for i=1,#hF do c8=c8+12;fv[#fv+1]=c6(c7,c8,hF[i],"pdim txttick txtstart")end end;local hJ={}function hJ.HUDPrologue(fv)if not F then C=PvPR;E=PvPG;D=PvPB else C=SafeR;E=SafeG;D=SafeB end;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local hK=aA;local hL=aB;local hM=aA;local hN=aB;if fr()and not brightHud then hK=[[rgb(]]..d(C*0.4+0.5)..","..d(E*0.4+0.5)..","..d(D*0.3+0.5)..[[)]]hL=[[rgb(]]..d(C*0.3+0.5)..","..d(E*0.3+0.5)..","..d(D*0.2+0.5)..[[)]]end;fv[#fv+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],hK,hK,hM,hM,hL,hL,hN,hN,aK,aL)return fv end;function hJ.UpdateHud(fv)local cz=av;local f2=core.getVelocity()local e_=vec3(f2):len()local gJ=bR;local hO=bS;local g3=hO;local gh=bR;local h0=d(unit.getThrottle())local h5=e_*3.6;local h1=unit.getAxisCommandValue(0)local hP=fp(1770)local hQ=fq(310)if AtmoSpeedAssist and bQ then h1=H;h0=H*100 end;local ft=fs()local g4="ROLL"local cG=unit.getClosestPlanetInfluence()>0;if h0==nil then h0=0 end;if not cG then if e_>5 then gJ=gI(f2)hO=gK(f2)else gJ=0;hO=0 end;g4="YAW"end;if G>50000 and not at then local hR;if G>200000 then hR=y(G/200000,2).." su"else hR=y(G/1000,1).." km"end;fv[#fv+1]=c6(hP,hQ,"PvP Boundary: "..hR,"pbright txtbig txtmid")end;fv[#fv+1]=al;fv[#fv+1]=aF;fv[#fv+1]=ak;if b2%aX==0 then b1=true end;if fuelX~=0 and fuelY~=0 then fu(fv,b1,fuelX,"Atmospheric ","ATMO",aQ,a_,b0)fu(fv,b1,fuelX+100,"Space fuel t","SPACE",aR,aY,aZ)fu(fv,b1,fuelX+200,"Rocket fuel ","ROCKET",aS,aV,aW)end;if b1 then b1=false;b2=0 end;b2=b2+1;fW(fv,cz)if m()==0 or RemoteHud then if not fr()or brightHud then if cG then g2(fv,centerX,centerY,g3,g4,cG)gg(fv,gh,g3,centerX,centerY,cG,d(gK(f2)),e_)else g2(fv,centerX,centerY,hO,g4,cG)gg(fv,gJ,hO,centerX,centerY,cG,d(hO),e_)end;gn(fv,cz,cG)gL(fv,f2,e_,centerX,centerY)end end;g_(fv,ft,h0,h1)h4(fv,h5)h8(fv)hm(fv)if showHelp then hE(fv)end;return fv end;function hJ.HUDEpilogue(fv)fv[#fv+1]="</svg>"return fv end;function hJ.ExtraData(fv)local hS=fp(1240)local hT=fq(55)local hU=hT+10;local hV;local hW=0;local ft=fs()if VertTakeOffEngine then ft=ft.."-VERTICAL"end;if TurnBurn then ft="TB-"..ft end;local hX=vec3(core.getWorldAcceleration()):len()/9.80665;hV=planet:getGravity(planet.center+vec3(0,0,1)*planet.radius):len()fv[#fv+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then hS=fp(1120)hT=fq(55)hU=hT+10 elseif at then local hY=fp(770)fv[#fv+1]=c6(hY,hT,"ATMOSPHERE","pdim txt txtend")fv[#fv+1]=c6(hY,hU,e("%.2f",au),"pdim txt txtend","")end;fv[#fv+1]=c6(hS,hT,"GRAVITY","pdim txt txtend")fv[#fv+1]=c6(hS,hU,e("%.2f",hV/9.80665),"pdim txt txtend")fv[#fv+1]=c6(hS,hT+20,"ACCEL","pdim txt txtend")fv[#fv+1]=c6(hS,hU+20,e("%.2f",hX),"pdim txt txtend")fv[#fv+1]=c6(fp(960),fq(180),ft,"txtbig txtmid")end;function hJ.DrawOdometer(fv,ac,TotalDistanceTravelled,ad)local hV;local hZ=0;local h_=0;local hW=0;if at then hW=LastMaxBrakeInAtmo else hW=LastMaxBrake end;maxThrust=a:maxForceForward()aO=l()hV=planet:getGravity(planet.center+vec3(0,0,1)*planet.radius):len()if hV>0.1 then h_=aO*hV;hZ=maxThrust/hV end;fv[#fv+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fp(660),fp(700),fq(35),fp(960),fq(55),fp(1240),fq(35),fp(1280))if m()==0 or RemoteHud then fv[#fv+1]=c6(fp(700),fq(20),e("Trip: %.2f km",ac),"txtstart")fv[#fv+1]=c6(fp(700),fq(30),e("Lifetime: %.2f Mm",TotalDistanceTravelled/1000),"txtstart")fv[#fv+1]=c6(fp(830),fq(20),"Trip Time: "..d1(ad),"txtstart")fv[#fv+1]=c6(fp(830),fq(30),"Total Time: "..d1(TotalFlightTime),"txtstart")fv[#fv+1]=c6(fp(970),fq(20),e("Mass: %.2f Tons",aO/1000),"txtstart")fv[#fv+1]=c6(fp(1240),fq(10),e("Max Brake: %.2f kN",hW/1000),"txtend")fv[#fv+1]=c6(fp(1240),fq(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if hV>0.1 then fv[#fv+1]=c6(fp(970),fq(30),e("Max Mass: %.2f Tons",hZ/1000),"txtstart")fv[#fv+1]=c6(fp(1240),fq(20),e("Req Thrust: %.2f kN",h_/1000),"txtend")else fv[#fv+1]=c6(fp(970),fq(30),"Max Mass: n/a","txtstart")fv[#fv+1]=c6(fp(1240),fq(20),"Req Thrust: n/a","txtend")end end;fv[#fv+1]="</g>"return fv end;function hJ.DrawWarnings(fv)return h8(fv)end;function hJ.DisplayOrbitScreen(fv)return hm(fv)end;function hJ.DisplayMessage(fv,hh)if hh~="empty"then local c8=310;for i0 in string.gmatch(hh,"([^\n]+)")do c8=c8+35;fv[#fv+1]=c6("50%",c8,i0,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function hJ.DrawDeadZone(fv)fv[#fv+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function hJ.UpdateRadar()if radar_1 then local i1=radar_1.getEntries()local i2=radar_1.getData()local i3=fp(1770)local i4=fq(330)if#i1>0 then local i5=i2:find('identifiedConstructs":%[%]')if i5==nil and perisPanelID==nil then am=1;hD()end;if i5~=nil and perisPanelID~=nil then hD()end;if radarPanelID==nil then hD()end;ak=c6(i3,i4,"Radar: "..#i1 .." contacts","pbright txtbig txtmid")local i6={}for dc,dd in pairs(i1)do if radar_1.hasMatchingTransponder(dd)==1 then table.insert(i6,dd)end end;if#i6>0 then local c8=fq(15)local c7=fp(1370)ak=ak..c6(c7,c8,"Friendlies In Range","pbright txtbig txtmid")for dc,dd in pairs(i6)do c8=c8+20;ak=ak..c6(c7,c8,radar_1.getConstructName(dd),"pdim txtmid")end end else local i7;i7=i2:find('worksInEnvironment":false')if i7 then ak=c6(i3,i4,"Radar: Jammed","pbright txtbig txtmid")else ak=c6(i3,i4,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then am=0;hD()end end end end;function hJ.DrawSettings(fv)if#bU>0 then local c7=fp(640)local c8=fq(200)fv[#fv+1]=[[<g class="pbright txtvspd txtstart">]]for dc,dd in pairs(bU)do fv[#fv+1]=c6(c7,c8,dd..": ".._G[dd])c8=c8+20;if dc%12==0 then c7=c7+fp(350)c8=fq(200)end end;fv[#fv+1]=c6(fp(640),fq(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fv[#fv+1]="</g>"end;return fv end;return hJ end;local function i8()local function i9()local function ia(ib,ic)return ib.name<ic.name end;bW={}for dc,dd in pairs(b3[0])do bW[#bW+1]={name=dd.name,index=dc}end;table.sort(bW,ia)end;local de={}function de.UpdateAtlasLocationsList()i9()end;function de.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ab=nil;CustomTarget=nil;return true end;local id=bW[AutopilotTargetIndex].index;local ie=b3[0][id]if ie.center then AutopilotTargetName=ie.name;ab=b8[0][id]if CustomTarget~=nil then if au==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=ie;for _,dd in pairs(b8[0])do if dd.name==CustomTarget.planetname then ab=dd;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ab.center)else AutopilotTargetCoords=CustomTarget.position end;if ab.planetname~="Space"then if ab.hasAtmosphere then AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=bb(ab):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function de.adjustAutopilotTargetIndex(f_)if not Autopilot and not VectorToTarget and not ao and not IntoOrbit then if f_==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bW then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bW end end;if AutopilotTargetIndex==0 then bd.UpdateAutopilotTarget()else local id=bW[AutopilotTargetIndex].index;local ie=b3[0][id]if ie.name=="Space"then if f_==nil then bd.adjustAutopilotTargetIndex()else bd.adjustAutopilotTargetIndex(1)end else bd.UpdateAutopilotTarget()end end else a1="Disengage autopilot before changing Interplanetary Helper"end end;function de.findAtlasIndex(ig)for dc,dd in pairs(ig)do if dd.name and dd.name==CustomTarget.name then return dc end end;return-1 end;for dc,dd in pairs(SavedLocations)do table.insert(b3[0],dd)end;i9()de.UpdateAutopilotTarget()return de end;local function ih()local ii={}local function ij(e_)if not at then return b9.computeDistanceAndTime(e_,AutopilotEndSpeed,l(),0,0,LastMaxBrake-AutopilotPlanetGravity*l())else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b9.computeDistanceAndTime(e_,AutopilotEndSpeed,l(),0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*l())else return 0,0 end end end;local function ik(e_)return b9.computeDistanceAndTime(e_,AutopilotEndSpeed,l(),a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*l())end;function ii.GetAutopilotBrakeDistanceAndTime(e_)return ij(e_)end;function ii.GetAutopilotTBBrakeDistanceAndTime(e_)return ik(e_)end;local function il(im)local dI=500000;local io,ip,iq=math.huge;local ir=false;local is=vec3({13771471,7435803,-128971})local it=18000000;io=vec3(im):dist(is)if io<it then return true,c(io-it),"Safe Zone",0 end;ip=vec3(im):dist(vec3(planet.center))if ip<dI then ir=true end;if c(ip-dI)<c(io-it)then return ir,c(ip-dI),planet.name,planet.bodyId else return ir,c(io-it),"Safe Zone",0 end end;local function iu(iv,iw,ix)iw=iw:project_on_plane(iv)ix=ix:project_on_plane(iv)return n(iw:cross(ix):dot(iv),iw:dot(ix))end;local function iy()local iz=-1;local iA=-1;if vBooster then iz=vBooster.distance()end;if hover then iA=hover.distance()end;if iz~=-1 and iA~=-1 then if iz<iA then return iz else return iA end elseif iz~=-1 then return iz elseif iA~=-1 then return iA else return-1 end end;function ii.APTick()at=j()>0;au=j()av=core.getAltitude()aq=iy()bE=q()bk=bE;if antigrav then bO=antigrav.getState()==1 end;local iB=1;local iC=1;local iD=bE-bk;local iE=-math.deg(iu(bF,bI,bG))local iF=math.deg(iu(bH,bI,bG))local f_=bK*-1;bj=at and iE<-YawStallAngle or iE>YawStallAngle or iF<-PitchStallAngle or iF>PitchStallAngle;local iG=system.getMouseDeltaX()local iH=system.getMouseDeltaY()if InvertMouse and not a0 then iH=-iH end;U=0;Y=0;T=0;sys=b8[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=bb(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bI)if av==0 then av=(bM-planet.center):len()-planet.radius end;local hV=planet:getGravity(core.getConstructWorldPos()):len()*l()bl=0;ba=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if not at then F,G,_,_=il(bM)else F=true end;if x()==0 then if m()==1 and a0 then if not bf then ag=ag+iG;ah=ah+iH end else ag=0;ah=0 end else ag=ag+iG;ah=ah+iH;aj=math.sqrt(ag*ag+ah*ah)if not a0 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then U=U-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then U=U-(ag+DeadZone)*MouseXSensitivity else U=0 end;if ah>0 and ah>DeadZone then T=T-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then T=T-(ah+DeadZone)*MouseYSensitivity else T=0 end else ag=0;ah=0;if userControlScheme=="mouse"then T=(-utils.smoothstep(iH,-100,100)+0.5)*2*iB;U=(-utils.smoothstep(iG,-100,100)+0.5)*2*iC end end end end;local iI=bJ>8334;if bJ>SpaceSpeedLimit/3.6 and not at and not Autopilot and not iI then a1="Space Speed Engine Shutoff reached"cc(0)end;if not iI and LastIsWarping then if not BrakeIsOn then cM()end;if Autopilot then cE()end end;LastIsWarping=iI;if at and au>0.09 then if bJ>bo/3.6 and not AtmoSpeedAssist and not az then BrakeIsOn=true;az=true elseif not AtmoSpeedAssist and az then if bJ<bo/3.6 then BrakeIsOn=false;az=false end end end;if BrakeIsOn then X=1 else X=0 end;if ProgradeIsOn then if an then BrakeIsOn=false;local iJ=false;if CustomTarget~=nil then iJ=cN(CustomTarget.position-bM,0.01)else iJ=cN(vec3(bI),0.01)end;bh=true;if iJ and(c(bS)<2 or c(bR)>85)and bJ>=bo/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;Q=true;an=false;ap=true;Autopilot=false;cZ()elseif at and AtmoSpeedAssist then cc(1)else cf(d(bo))end elseif bJ>P then cN(vec3(bI),0.01)end end;if RetrogradeIsOn then if at then RetrogradeIsOn=false elseif bJ>P then cN(-vec3(bI))end end;if not ProgradeIsOn and an and not IntoOrbit then if au==0 then Q=true;cZ()an=false;ap=true else an=false;cE()end end;if ap and CustomTarget~=nil and(av<HoldAltitude+200 and av>HoldAltitude-200)and bJ*3.6>bo-100 and c(bL)<20 and au>=0.1 and(CustomTarget.position-bM):len()>2000+av then cE()ap=false end;if VertTakeOff then bh=true;local iK=HoldAltitude;if bL<-30 then a1="Unable to achieve lift. Safety Landing."af=0;bh=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bO or HoldAltitude<planet.spaceEngineMinAltitude then if bO then iK=antigrav.getBaseAltitude()end;if av<iK-100 then bp=0;af=15;BrakeIsOn=false elseif bL>0 then BrakeIsOn=true;af=0 elseif bL<-30 then BrakeIsOn=true;af=15 elseif av>=iK then if bO then if Autopilot or VectorToTarget then co()else BrakeIsOn=true;VertTakeOff=false end;a1="Takeoff complete. Singularity engaged"else BrakeIsOn=false;a1="VTO complete. Engaging Horizontal Flight"co()end;af=0 end else if au>0.08 then bp=0;BrakeIsOn=false;af=20 elseif au<0.08 and au>0 then BrakeIsOn=false;if bB then bp=0;af=20 else af=0;bp=36;cf(3500)end else bh=autoRollPreference;IntoOrbit=true;bz=false;CancelIntoOrbit=false;bt=false;br=nil;bs=nil;if by==nil then by=planet end;bx=iK;bw=true;VertTakeOff=false end end;if bp~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local iL=r(bp-bR,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(iL)local iM=r(vTpitchPID:get(),-1,1)T=iM end end;if IntoOrbit then local cW;local iN=false;local iO,iP=cj(bx)local iQ=iO..iP;if by==nil then by=planet;if VectorToTarget then by=ab end end;if not bw then bx=math.floor(by.radius+by.surfaceMaxAltitude+1000)if by.hasAtmosphere then bx=math.floor(by.radius+by.noAtmosphericDensityAltitude+1000)end;bw=true end;if bv.VectorToTarget then cW=CustomTarget.position-bM end;local iR,iS=bb(by):escapeAndOrbitalSpeed((bM-by.center):len()-by.radius)local iT=bS;if not bt then local iU=false;local iV=false;cc(0)bs=0;bq="Aligning to orbital path - OrbitHeight: "..iQ;if bv.VectorToTarget then cN(cW:normalize():project_on_plane(bK))iN=bG:dot(cW:project_on_plane(bF):normalize())>0.95 else cN(bI)iN=iE<0.5;if bJ<150 then iN=true end end;T=0;br=0;if bR<=br+1 and bR>=br-1 then iU=true else iU=false end;if iT<=bs+1 and iT>=bs-1 then iV=true else iV=false end;if iU and iV and iN then br=nil;bs=nil;bt=true end else if bv.VectorToTarget then cN(cW:normalize():project_on_plane(bK))elseif bJ>150 then cN(bI)end;T=0;if bv.VectorToTarget then local a7,_=b9.computeDistanceAndTime(bJ,bo/3.6,l(),0,0,LastMaxBrake)if bz and cW:len()>15000+a7+av then bq="Orbiting to Target"if orbit.periapsis.altitude<by.noAtmosphericDensityAltitude then bz=false end elseif bz or cW:len()<15000+a7+av then a1="Orbit complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;Q=true;ap=true;bv.VectorToTarget,bv.AutopilotAlign=false,false;cp()cZ()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and av>bx*0.9 and av<bx*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bx*0.99 and orbit.apoapsis.altitude>=bx*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bz then if bz then BrakeIsOn=false;cc(0)br=0;if not bv.VectorToTarget then a1="Orbit complete"cp()end else bD=bD+1;if bD>=2 then bz=true end end else bq="Adjusting Orbit - OrbitHeight: "..iQ;bu=true;cf(iS*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local iW=bL;local iX=av-bx;local iY=c(iX)if bL<10 and c(bR)<10 and iY<100 then iW=bL*2 end;if iW<10 and c(bR)<10 and iY<100 then iW=iW*2 end;if iW<5 and c(bR)<5 and iY<100 then iW=iW*4 end;VSpdPID:inject(iW)br=r(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(iX)br=r(br-r(OrbitAltPID:get(),-15,15),-90,90)end end else local iZ=2.75;local i_=c(p(iR*iZ))local j0=i_%50;if j0>0 then i_=i_-j0+50 end;BrakeIsOn=false;if av<bx*0.8 then bq="Escaping planet gravity - OrbitHeight: "..iQ;br=utils.map(bL,200,0,-15,80)elseif av>=bx*0.8 and av<bx*1.15 then bq="Approaching orbital corridor - OrbitHeight: "..iQ;i_=i_*0.75;br=utils.map(bL,100,-100,-15,65)elseif av>=bx*1.15 and av<bx*1.5 then bq="Approaching orbital corridor - OrbitHeight: "..iQ;i_=i_*0.75;if bL<0 or bu then br=utils.map(av,bx*1.5,bx*1.01,-30,0)else br=utils.map(av,bx*0.99,bx*1.5,0,30)end elseif av>bx*1.5 then bq="Reentering orbital corridor - OrbitHeight: "..iQ;br=-85;local j1=utils.map(bL,-150,-400,1,0.55)i_=i_*j1 end;cf(d(i_))end end;if br~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local j2=br-bR;OrbitPitchPID:inject(j2)local j3=r(OrbitPitchPID:get(),-0.5,0.5)T=j3 end end;if Autopilot and au==0 and not an then local j4,j5=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local j6=(CustomTarget.position-ab.center):normalize()local j7=j6:project_on_plane((ab.center-bM):normalize()):normalize()local j8=ab.center+j7*(ab.radius+AutopilotTargetOrbit)local j9=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))if(bM-j8):len()<(bM-j9):len()then j4=j8;AutopilotTargetCoords=j4 else j4=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))AutopilotTargetCoords=j4 end;cs(ab,AutopilotTargetCoords)j5=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;j5=true;TargetSet=true;AutopilotRealigned=true;j4=CustomTarget.position+(bM-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local j6=(bM+bI*100000-ab.center):normalize()local j7=j6:project_on_plane((ab.center-bM):normalize()):normalize()if j7:len()<1 then j6=(bM+bG*100000-ab.center):normalize()j7=j6:project_on_plane((ab.center-bM):normalize()):normalize()end;j4=ab.center+j7*(ab.radius+AutopilotTargetOrbit)AutopilotTargetCoords=j4;TargetSet=true;j5=true;AutopilotRealigned=true;cs(ab,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(j4)-bM):len()local hi,en,eo=b8:getPlanetarySystem(0):castIntersections(bM,bI:normalize(),function(eb)if eb.noAtmosphericDensityAltitude>0 then return eb.radius+eb.noAtmosphericDensityAltitude else return eb.radius+eb.surfaceMaxAltitude*1.5 end end)local hj=en;if eo~=nil and en~=nil then hj=math.min(eo,en)end;if hj~=nil and hj<AutopilotDistance and hi.name==ab.name then AutopilotDistance=hj end;local iJ=true;local ja=(ab.center-(bM+vec3(bI):normalize()*AutopilotDistance)):len()-ab.radius;local hh,cn=cj(ja)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hh..'", "unit":"'..cn..'"}')local a7,a8;if not TurnBurn then a7,a8=ij(bJ)else a7,a8=ik(bJ)end;if bJ>300 and AutopilotAccelerating then local cW=vec3(j4)-bM;local jb=r(math.deg(iu(bF,bI:normalize(),cW:normalize()))*bJ/500,-90,90)local jc=r(math.deg(iu(bH,bI:normalize(),cW:normalize()))*bJ/500,-90,90)if c(jb)<20 and c(jc)<20 then jb=jb*2;jc=jc*2 end;if c(jb)<2 and c(jc)<2 then jb=jb*2;jc=jc*2 end;local iE=-math.deg(iu(bF,bG,bI:normalize()))local iF=-math.deg(iu(bH,bG,bI:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(jc-iF)local jd=r(apPitchPID:get(),-1,1)T=T+jd;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(jb-iE)local je=r(apYawPID:get(),-1,1)U=U+je;j5=true;if c(jb)>2 or c(jc)>2 then AutopilotStatus="Adjusting Trajectory"else AutopilotStatus="Accelerating"end end;if ja<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=bb(ab):escapeAndOrbitalSpeed(ja)end end;if not AutopilotCruising and not AutopilotBraking and not j5 then iJ=cN((j4-bM):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then iJ=cN(-vec3(bI):normalize())end;if AutopilotAccelerating then if not O then BrakeIsOn=false;cc(AutopilotInterplanetaryThrottle)H=y(AutopilotInterplanetaryThrottle,2)O=true end;local jf=unit.getThrottle()if AtmoSpeedAssist then jf=H end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or jf==0 and O then AutopilotAccelerating=false;AutopilotStatus="Cruising"AutopilotCruising=true;cc(0)end;if AutopilotDistance<=a7 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true;cc(0)O=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;X=1 end;if TurnBurn then cc(1,true)end;local _,iS=bb(ab):escapeAndOrbitalSpeed((bM-planet.center):len()-planet.radius)local cW;if CustomTarget~=nil then cW=CustomTarget.position-bM end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bJ<50 then a1="Autopilot complete, arrived at space location"AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bJ<=iS and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cc(0)O=false;ProgradeIsOn=true;an=true;cs(ab,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 then AutopilotStatus="Circularizing"local _,iS=bb(ab):escapeAndOrbitalSpeed((bM-planet.center):len()-planet.radius)if bJ<=iS then if CustomTarget~=nil then if bI:normalize():dot(cW:normalize())>0.4 then AutopilotStatus="Orbiting to Target"if not WaypointSet then BrakeIsOn=false;cs(ab,CustomTarget.position)WaypointSet=true end else a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cc(0)O=false;ProgradeIsOn=true;an=true;BrakeIsOn=false;cs(ab,CustomTarget.position)WaypointSet=false end else BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"a1="Autopilot completed, orbit established"X=0;cc(0)O=false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then ProgradeIsOn=true;an=true end end end end elseif AutopilotCruising then if AutopilotDistance<=a7 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true end;local jf=unit.getThrottle()if AtmoSpeedAssist then jf=H end;if jf>0 then AutopilotAccelerating=true;AutopilotStatus="Accelerating"AutopilotCruising=false end else if iJ then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not an then AutopilotTargetCoords=vec3(ab.center)+(AutopilotTargetOrbit+ab.radius)*bH;AutopilotShipUp=bF;AutopilotShipRight=bH end;AutopilotRealigned=true elseif iJ then AutopilotAccelerating=true;AutopilotStatus="Accelerating"if not O then cc(AutopilotInterplanetaryThrottle,true)H=y(AutopilotInterplanetaryThrottle,2)O=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and au>0)then a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"X=0;cc(0)O=false;ProgradeIsOn=true;an=true;cs(ab,CustomTarget.position)end;if Z then bh=true;local jc=0;local f3=bM+vec3(unit.getMasterPlayerRelativePosition())local jg=f3-bM;local jh=vec3(jg):project_on(bG):len()local ji=vec3(jg):project_on(bH):len()local aj=math.sqrt(jh*jh+ji*ji)cN(jg:normalize())local jj=40;local jk=aj<jj;local jl=100;local jm=r((aj-jj)/2,10,jl)T=0;local iJ=c(U)<0.1;if iJ and bJ<jm and not jk then BrakeIsOn=false;jc=-20 else BrakeIsOn=true;jc=0 end;local jn=0;if c(jc-bR)>jn then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(jc-bR)local jd=pitchPID:get()T=jd end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local cG=unit.getClosestPlanetInfluence()>0;local jo=HoldAltitude-av;local jp=500+bJ;local jq=1;if AutoTakeoff then jq=r(bJ/100,0.1,1)end;local jc=(utils.smoothstep(jo,-jp,jp)-0.5)*2*MaxPitch*jq;if not Reentry and not an and not VectorToTarget and bG:dot(bI:normalize())<0.99 then jc=(utils.smoothstep(jo,-jp*r(20-19*au*10,1,20),jp*r(20-19*au*10,1,20))-0.5)*2*MaxPitch*r(2-au*10,1,2)*jq end;if not AltitudeHold then jc=0 end;if LockPitch~=nil then if cG and not IntoOrbit then jc=LockPitch else LockPitch=nil end end;bh=true;local jr=T;if Reentry then local js=d(bo)local jt,ju=b9.computeDistanceAndTime(bJ,js/3.6,l(),0,0,LastMaxBrake-planet.gravity*9.8*l())local jv=av-(planet.noAtmosphericDensityAltitude+5000)if not bQ and av>planet.noAtmosphericDensityAltitude+5000 and bJ<=js/3.6 and bJ>js/3.6-10 and c(bI:normalize():dot(bG))>0.9 then cc(0)elseif bQ and(jt>-1 and jv<=jt or av<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cf(js,true)if not Q then jc=-80;if au>0.02 then a1="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;jc=0;bh=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and av>planet.noAtmosphericDensityAltitude+5000 then bh=true elseif av<=planet.noAtmosphericDensityAltitude+5000 then cf(js)if not bQ and s:getTargetSpeed(axisCommandId.longitudinal)==bo then Q=false;Reentry=false;bh=true end end end;if bJ>P and not ao and not VectorToTarget and not BrakeLanding and ForceAlignment then cN(vec3(bI))end;if(VectorToTarget or ao)and AutopilotTargetIndex>0 and au>0.01 then local cW;if CustomTarget~=nil then cW=CustomTarget.position-bM else cW=ab.center-bM end;local jb=math.deg(iu(bK:normalize(),bI,cW))*2;local jw=math.rad(c(bS))if bJ>minRollVelocity and au>0.01 then local jx=r(90-jc*2,-90,90)bl=r(jb*2,-jx,jx)local jy=jb;jb=r(r(jb,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jw)+4*(bR-jc)*math.sin(math.rad(bS)),-YawStallAngle*0.80,YawStallAngle*0.80)jc=r(r(jc*math.cos(jw),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(r(c(jy)*math.sin(jw),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bl=0;jb=r(jb,-YawStallAngle*0.80,YawStallAngle*0.80)end;local jz=iE-jb;if not bj and bJ>minRollVelocity and au>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(jz)local je=r(yawPID:get(),-1,1)U=U+je elseif at and aq>-1 or bJ<minRollVelocity then cN(cW)elseif bj and au>0.01 then if(iE<-YawStallAngle or iE>YawStallAngle)and au>0.01 then cN(bI)end;if(iF<-PitchStallAngle or iF>PitchStallAngle)and au>0.01 then jc=r(bR-iF,bR-PitchStallAngle*0.80,bR+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ao then local iK=planet:getAltitude(CustomTarget.position)local jv=math.sqrt(cW:len()^2-(av-iK)^2)local jA=LastMaxBrakeInAtmo;if jA then jA=jA*r(bJ/100,0.1,1)*au else jA=LastMaxBrake end;if au<0.01 then jA=LastMaxBrake end;local jB=bI:len()-c(bL)local jC=vec3(core.getWorldAirFrictionAcceleration())local jD=math.sqrt(jC:len()-jC:project_on(f_):len())*l()if bJ>100 then a7,a8=b9.computeDistanceAndTime(bJ,100,l(),0,0,jA+jD)local jE,jF=b9.computeDistanceAndTime(100,0,l(),0,0,jA/2)a7=a7+jE else a7,a8=b9.computeDistanceAndTime(bJ,0,l(),0,0,jA/2)end;StrongBrakes=true;if not ao and not Reentry and jv<=a7+bJ*iD/2 and(bI:project_on_plane(bK):normalize():dot(cW:project_on_plane(bK):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cc(0)if AltitudeHold then cq()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(jB<0.1 or jv<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<jv)then if not bO then BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"end;LastDistanceToTarget=jv end elseif VectorToTarget and au==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ao or Reentry)then if CustomTarget~=nil and ab.name==planet.name then local cW=CustomTarget.position-bM;local iK=planet:getAltitude(CustomTarget.position)local jv=math.sqrt(cW:len()^2-(av-iK)^2)local jA=LastMaxBrakeInAtmo;if jA then a7,a8=b9.computeDistanceAndTime(bJ,0,l(),0,0,jA/2)StrongBrakes=true;if jv<=a7+bJ*iD/2 and bI:project_on_plane(bK):normalize():dot(cW:project_on_plane(bK):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;Q=true;an=false;ap=true;Autopilot=false;cZ()end end;LastDistanceToTarget=jv end end end;if au==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ao or IntoOrbit or Reentry)then if not bz and not IntoOrbit then bx=HoldAltitude;bw=true;if VectorToTarget then bv.VectorToTarget=true end;cp()VectorToTarget=false;bt=true end end;if bj and au>0.01 and aq==-1 and bJ>minRollVelocity and VectorStatus~="Finalizing Approach"then cN(bI)jc=r(bR-iF,bR-PitchStallAngle*0.80,bR+PitchStallAngle*0.80)end;T=jr;local d7=-1;if BrakeLanding then jc=0;local jG=false;local jH=30;if ba~=nil and ba>0 then local jD=0;local jI=r(au,0.4,2)local jA=LastMaxBrakeInAtmo*r(bJ/100,0.1,1)*jI;local jJ=ba*jI+jA+jD-hV;local jK=jA/2+jD-hV;local jL=bJ-math.sqrt(c(jK/2)*20/(0.5*l()))*utils.sign(jK)if jL<0 then jL=0 end;local jM;if bJ>100 then local jN,_=b9.computeDistanceAndTime(bJ,100,l(),0,0,jA)local jO,_=b9.computeDistanceAndTime(100,0,l(),0,0,math.sqrt(jA))jM=jN+jO else jM=b9.computeDistanceAndTime(bJ,0,l(),0,0,math.sqrt(jA))end;if jM<20 then BrakeIsOn=false else local jP=0;if jL>100 then local jQ,_=b9.computeDistanceAndTime(jL,100,l(),0,0,jJ)local jR,_=b9.computeDistanceAndTime(100,0,l(),0,0,ba*jI+math.sqrt(jA)+jD-hV)jP=jQ+jR else jP,_=b9.computeDistanceAndTime(jL,0,l(),0,0,ba*jI+math.sqrt(jA)+jD-hV)end;jP=(jP+15+bJ*iD)*1.1;local jS=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if jS then local iK=planet:getAltitude(CustomTarget.position)local jT=av-iK-100;local cW=CustomTarget.position-bM;local jU=math.sqrt(cW:len()^2-(av-iK)^2)if jU>100 then jS=false elseif jT<=jP or jP==-1 then BrakeIsOn=true;jG=true else BrakeIsOn=false;jG=true end end;if not jS and CalculateBrakeLandingSpeed then if jP>=jH then BrakeIsOn=true else BrakeIsOn=false end;jG=true end end end;if not bQ then cc(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)d7=aq;if d7>-1 then bh=autoRollPreference;if bJ<1 or bI:normalize():dot(bK)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bI:normalize():dot(-f_)<0.999 then BrakeIsOn=true elseif bL<-brakeLandingRate and not jG then BrakeIsOn=true elseif not jG then BrakeIsOn=false end end;if AutoTakeoff or ao then local hi,eo,en;if AutopilotTargetCoords~=nil then hi,eo,en=b8:getPlanetarySystem(0):castIntersections(bM,(AutopilotTargetCoords-bM):normalize(),function(eb)return eb.radius+eb.noAtmosphericDensityAltitude end)end;if bO then if av>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cc(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(jc)<15 and av/HoldAltitude>0.75 then AutoTakeoff=false;if not ao then if bQ and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ao and bJ<P then Autopilot=true;ao=false;AltitudeHold=false;AutoTakeoff=false;cc(0)elseif ao then cc(0)BrakeIsOn=true end elseif ao and au==0 and ab~=nil and(hi==nil or hi.name==ab.name)then Autopilot=true;ao=false;AltitudeHold=false;AutoTakeoff=false;if not bQ then cc(0)end;AutopilotAccelerating=true end end;local jV=aq>-1;local jW=bR;if(VectorToTarget or ao)and not jV and bJ>minRollVelocity and au>0.01 then local jw=math.rad(c(bS))jW=bR*c(math.cos(jw))+iF*math.sin(jw)end;local jX=r(jc-jW,-PitchStallAngle*0.80,PitchStallAngle*0.80)if au<0.01 and VectorToTarget then jX=r(jc-jW,-85,MaxPitch)elseif au<0.01 then jX=r(jc-jW,-MaxPitch,MaxPitch)end;if c(bS)<5 or VectorToTarget or BrakeLanding or jV or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(jX)local jd=pitchPID:get()T=T+jd end end;if antigrav~=nil and(antigrav and not ExternalAGG and av<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;aq=iy()return ii end;function script.onStart()local coreOffset=16;local function jY()local function jZ(j_)local k0=dbHud_1.hasKey;for dc,dd in pairs(j_)do if k0(dd)then local cm=f(dbHud_1.getStringValue(dd))if cm~=nil then _G[dd]=cm;aM=true end end end end;if dbHud_1 then local k0=dbHud_1.hasKey;if not useTheseSettings then jZ(b_())coroutine.yield()jZ(b)else jZ(b)a1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;aM=false end;coroutine.yield()if aM then a1="Loaded Saved Variables"M=y(ResolutionX/2,0)N=y(ResolutionY/2,0)aK=ResolutionX;aL=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bh=autoRollPreference;bo=AtmoSpeedLimit;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]elseif not useTheseSettings then a1="No Saved Variables Found - Exit HUD to save settings"end else a1="No databank found. Attach one to control unit and rerun the autoconfigure to save preferences and locations"end;if LastStartTime+180<bE then LastMaxBrakeInAtmo=0 end;LastStartTime=bE;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a1="Invalid User Control Scheme selected.  Change userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=5 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=av end;antigrav.setBaseAltitude(AntigravTargetAltitude)end end;local function k1()local function k2(k3,k4)if k3>k4 then k4=k3 end;if ContainerOptimization>0 then k4=k4-k4*ContainerOptimization*0.05 end;if FuelTankOptimization>0 then k4=k4-k4*FuelTankOptimization*0.05 end;return k4 end;local k5=core.getElementNameById;local k6=fuelX~=0 and fuelY~=0;for dc in pairs(aw)do local type=core.getElementTypeById(aw[dc])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(aw[dc])),'^.*vertical.*$')then bN=true end end;if o(type,'^.*Space Engine$')then bC=true;if o(tostring(core.getElementTagsById(aw[dc])),'^.*vertical.*$')then local k7=core.getElementRotationById(aw[dc])if k7[4]<0 then if p(-k7[4],0.1)==0.5 then bA=true end else if p(k7[4],0.1)==0.5 then bB=true end end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local k8=h(aw[dc])if k8>10000 then coreOffset=128 elseif k8>1000 then coreOffset=64 elseif k8>150 then coreOffset=32 end end;aT=aT+h(aw[dc])if k6 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local k8=h(aw[dc])local k9=k(aw[dc])local k3=0;local fS=q()if type=="Atmospheric Fuel Tank"then local k4=400;local ka=35.03;if k8>10000 then k4=51200;ka=5480 elseif k8>1300 then k4=6400;ka=988.67 elseif k8>150 then k4=1600;ka=182.67 end;k3=k9-ka;if fuelTankHandlingAtmo>0 then k4=k4+k4*fuelTankHandlingAtmo*0.2 end;k4=k2(k3,k4)aQ[#aQ+1]={aw[dc],k5(aw[dc]),k4,ka,k3,fS}end;if type=="Rocket Fuel Tank"then local k4=320;local ka=173.42;if k8>65000 then k4=40000;ka=25740 elseif k8>6000 then k4=5120;ka=4720 elseif k8>700 then k4=640;ka=886.72 end;k3=k9-ka;if fuelTankHandlingRocket>0 then k4=k4+k4*fuelTankHandlingRocket*0.1 end;k4=k2(k3,k4)aS[#aS+1]={aw[dc],k5(aw[dc]),k4,ka,k3,fS}end;if type=="Space Fuel Tank"then local k4=2400;local ka=182.67;if k8>10000 then k4=76800;ka=5480 elseif k8>1300 then k4=9600;ka=988.67 end;k3=k9-ka;if fuelTankHandlingSpace>0 then k4=k4+k4*fuelTankHandlingSpace*0.2 end;k4=k2(k3,k4)aR[#aR+1]={aw[dc],k5(aw[dc]),k4,ka,k3,fS}end end end;if not bN then VertTakeOff,VertTakeOffEngine=false,false end end;local function kb()if gyro~=nil then ay=gyro.getState()==1 end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(at or not at and av<10000)then for _,dd in pairs(door)do dd.toggle()end end;if switch then for _,dd in pairs(switch)do dd.toggle()end end;if forcefield and(at or not at==0 and av<10000)then for _,dd in pairs(forcefield)do dd.toggle()end end;if antigrav then bO=antigrav.getState()==1;if bO and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if R then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;local kc=d6()if kc~=-1 or not at and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;if not R then GearExtended=true end else BrakeIsOn=false end;if bi~=nil then s:setTargetGroundAltitude(bi)if bi==0 and not R then GearExtended=true;BrakeIsOn=true end else bi=a:getTargetGroundAltitude()if GearExtended then s:setTargetGroundAltitude(LandingGearGroundHeight)else s:setTargetGroundAltitude(TargetHoverHeight)end end;if at and kc~=-1 then ba=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=at end;local function kd(ke,kf,kg,kh,c7,c8,ki,kj,kk,kl)local km={enableName=ke,disableName=kf,width=kg,height=kh,x=c7,y=c8,toggleVar=ki,toggleFunction=kj,drawCondition=kk,hovered=false}if kl then table.insert(aJ,km)else table.insert(aI,km)end;return km end;local function kn(ko)if not bT then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif ko=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif ko=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif ko=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bU=b_(ko)showHud=false else bU={}showHud=true end end;local function kp()bT=not bT;if bT then aH=aJ;a1="Hold SHIFT to see Settings"bV=showHud else aH=aI;a1="Hold SHIFT to see Control Buttons"kn()showHud=bV end end;local function kq(dd)_G[dd]=not _G[dd]if _G[dd]then a1=dd.." set to true"else a1=dd.." set to false"end;if dd=="showHud"then bV=_G[dd]elseif dd=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function kr()local ks=50;local kt=340;local c7=500;local c8=aL/2-400;local ku=0;for dc,dd in pairs(b_("boolean"))do if type(_G[dd])=="boolean"then kd(dd,dd,kt,ks,c7,c8,function()return _G[dd]end,function()kq(dd)end,function()return true end,true)c8=c8+ks+20;if ku==7 then c7=c7+kt+20;c8=aL/2-400;ku=0 else ku=ku+1 end end end;kd("Control View","Control View",kt,ks,10,aL/2-500,function()return true end,kp,function()return true end,true)kd("View Handling Settings",'Hide Handling Settings',kt,ks,10,aL/2-(500-ks),function()return showHandlingVariables end,function()kn("handling")end,function()return true end,true)kd("View Hud Settings",'Hide Hud Settings',kt,ks,10,aL/2-(500-ks*2),function()return showHudVariables end,function()kn("hud")end,function()return true end,true)kd("View Physics Settings",'Hide Physics Settings',kt,ks,10,aL/2-(500-ks*3),function()return showPhysicsVariables end,function()kn("physics")end,function()return true end,true)end;local function kv()local function kw()if dbHud_1 then local position=bM;local fL=planet.name..". "..#SavedLocations;if radar_1 then local dU,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dU~=nil and dU~=""then fL=fL.." "..radar_1.getConstructName(dU)end end;local cK={}cK={position=position,name=fL,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cK;table.insert(b3[0],cK)bd.UpdateAtlasLocationsList()a1="Location saved as "..fL else a1="Databank must be installed to save locations"end end;local function kx()TurnBurn=not TurnBurn end;local function ky(kz)if kz==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Z=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kA()ky(1)end;local function kB()local cJ=-1;cJ=bd.findAtlasIndex(b3[0])if cJ>-1 then table.remove(b3[0],cJ)end;cJ=-1;cJ=bd.findAtlasIndex(SavedLocations)if cJ~=-1 then a1=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cJ)end;bd.adjustAutopilotTargetIndex()bd.UpdateAtlasLocationsList()end;local function kC()local fL=AutopilotTargetName;if fL==nil then local hh,cn=cj((bM-CustomTarget.position):len())fL=CustomTarget.name.." "..hh..cn end;if fL==nil then fL="None"end;return"Engage Autopilot: "..fL end;local function kD()local fL=AutopilotTargetName;if fL==nil then fL=CustomTarget.name end;if fL==nil then fL="None"end;return"Disable Autopilot: "..fL end;local ks=50;local kt=260;local kE=kd("Enable Brake Toggle","Disable Brake Toggle",kt,ks,aK/2-kt/2,aL/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a1="Brakes in Toggle Mode"else a1="Brakes in Default Mode"end end)kd("Align Prograde","Disable Prograde",kt,ks,aK/2-kt/2-50-kE.width,aL/2-ks+380,function()return ProgradeIsOn end,kA)kd("Align Retrograde","Disable Retrograde",kt,ks,aK/2-kt/2+kE.width+50,aL/2-ks+380,function()return RetrogradeIsOn end,ky,function()return au==0 end)local kF=kd(kC,kD,600,60,aK/2-600/2,aL/2-60/2-400,function()return Autopilot end,cE)kd("Save Position","Save Position",200,kF.height,kF.x+kF.width+30,kF.y,function()return false end,kw,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)kd("Update Position","Update Position",200,kF.height,kF.x+kF.width+30,kF.y,function()return false end,cH,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kd("Clear Position","Clear Position",200,kF.height,kF.x-200-30,kF.y,function()return true end,kB,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ks=60;kt=300;local c7=10;local c8=aL/2-500;kd("Show Help","Hide Help",kt,ks,c7,c8,function()return showHelp end,function()showHelp=not showHelp end)c8=c8+ks+20;kd("View Settings","View Settings",kt,ks,c7,c8,function()return true end,kp)local c8=aL/2-300;kd("Enable Turn and Burn","Disable Turn and Burn",kt,ks,c7,c8,function()return TurnBurn end,kx)kd("Horizontal Takeoff Mode","Vertical Takeoff Mode",kt,ks,c7+kt+20,c8,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a1="Vertical Takeoff Mode"else a1="Horizontal Takeoff Mode"end end,function()return bN end)c8=c8+ks+20;kd("Show Orbit Display","Hide Orbit Display",kt,ks,c7,c8,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a1="Orbit Display Enabled"else a1="Orbit Display Disabled"end end)kd("Engage Orbiting","Cancel Orbiting",kt,ks,c7+kt+20,c8,function()return IntoOrbit end,cp,function()return au==0 and unit.getClosestPlanetInfluence()>0 end)c8=c8+ks+20;kd("Glide Re-Entry","Cancel Glide Re-Entry",kt,ks,c7,c8,function()return Reentry end,function()an=true;kA()end,function()return planet.hasAtmosphere and not at end)kd("Parachute Re-Entry","Cancel Parachute Re-Entry",kt,ks,c7+kt+20,c8,function()return Reentry end,cZ,function()return planet.hasAtmosphere and not at end)c8=c8+ks+20;kd("Engage Follow Mode","Disable Follow Mode",kt,ks,c7,c8,function()return Z end,cr,function()return m()==1 end)kd("Enable Repair Arrows","Disable Repair Arrows",kt,ks,c7+kt+20,c8,function()return aU end,function()aU=not aU;if aU then a1="Repair Arrows Enabled"else a1="Repair Arrows Diabled"end end,function()return m()==1 end)c8=c8+ks+20;if not ExternalAGG then kd("Enable AGG","Disable AGG",kt,ks,c7,c8,function()return bO end,d0,function()return antigrav~=nil end)end;c8=c8+ks+20;kd(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,kt*2,ks,c7,c8,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end end)end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})jY()coroutine.yield()k1()coroutine.yield()be=ih()kb()kr()kv()aH=aI;coroutine.yield()b3=de()b7=df()b8=b7(de())b9=ex()bb=f1()bc=fo()bd=i8()be=ih()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)if UseSatNav then unit.setTimer("fiveSecond",5)end end)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(au>0 or au==0 and av<10000)then for _,dd in pairs(door)do dd.toggle()end end;if switch then for _,dd in pairs(switch)do dd.toggle()end end;if forcefield and(au>0 or au==0 and av<10000)then for _,dd in pairs(forcefield)do dd.toggle()end end;d8()if button then button.activate()end;if SetWaypointOnExit then cs(planet,bM)end end;function script.onTick(kG)if kG=="tenthSecond"then local function kH()local kI=system.createData;local kJ=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=kJ(panelInterplanetary,"value")interplanetaryHeaderText=kI('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=kJ(panelInterplanetary,"value")widgetDistanceText=kI('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=kJ(panelInterplanetary,"value")widgetTravelTimeText=kI('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=kJ(panelInterplanetary,"value")widgetMaxMassText=kI('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=kJ(panelInterplanetary,"value")widgetTargetOrbitText=kI('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=kJ(panelInterplanetary,"value")widgetCurBrakeDistanceText=kI('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=kJ(panelInterplanetary,"value")widgetCurBrakeTimeText=kI('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=kJ(panelInterplanetary,"value")widgetMaxBrakeDistanceText=kI('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=kJ(panelInterplanetary,"value")widgetMaxBrakeTimeText=kI('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=kJ(panelInterplanetary,"value")widgetTrajectoryAltitudeText=kI('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not at then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function kK()t(panelInterplanetary)panelInterplanetary=nil end;local function kL()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ab.center-bM):len()else AutopilotDistance=(CustomTarget.position-bM):len()end end;local e_=bJ;local jf=unit.getThrottle()/100;if AtmoSpeedAssist then jf=H end;local kM,kN=b9.computeDistanceAndTime(bJ,MaxGameVelocity,l(),a:maxForceForward()*jf,warmup,0)local a7,a8;if not TurnBurn then a7,a8=be.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=be.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,kO;if not TurnBurn and e_>0 then _,kO=be.GetAutopilotBrakeDistanceAndTime(e_)else _,kO=be.GetAutopilotTBBrakeDistanceAndTime(e_)end;local kP=0;local kQ=0;if AutopilotCruising or not Autopilot and e_>5 then kQ=b9.computeTravelTime(e_,0,AutopilotDistance)elseif a7+kM<AutopilotDistance then kP=AutopilotDistance-(a7+kM)kQ=b9.computeTravelTime(8333.0556,0,kP)else local kR=(AutopilotDistance-a7)/kM;kM=AutopilotDistance-a7;kN=kN*kR end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return kQ elseif AutopilotBraking then return kO elseif AutopilotCruising then return kQ+kO else return kN+a8+kQ end end;local function kS()local kT=LastMaxBrakeInAtmo/ab:getGravity(ab.center+vec3(0,0,1)*ab.radius):len()return kT end;if au>0 and not WasInAtmo then if not bQ and AtmoSpeedAssist and(AltitudeHold or Reentry)then cc(1)L=false end end;if bP~=nil then if s:getTargetSpeed(axisCommandId.longitudinal)~=bP then cf(bP,TRUE)else bP=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then kH()end;if AutopilotTargetName~=nil then local kU=CustomTarget~=nil;planetMaxMass=kS()u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=kL()if kU and not Autopilot then aj=(bM-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bM):len()end;if not TurnBurn then a7,a8=be.GetAutopilotBrakeDistanceAndTime(bJ)a9,aa=be.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=be.GetAutopilotTBBrakeDistanceAndTime(bJ)a9,aa=be.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hh,cn=cj(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..hh..'", "unit":"'..cn..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d1(travelTime)..'", "unit":""}')hh,cn=cj(a7)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hh..'", "unit":"'..cn..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d1(a8)..'", "unit":""}')hh,cn=cj(a9)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hh..'", "unit":"'..cn..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d1(aa)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",planetMaxMass/1000)..'", "unit":" Tons"}')hh,cn=cj(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..e("%.2f",hh)..'", "unit":"'..cn..'"}')if au>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if au==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else kK()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif kG=="oneSecond"then local function kV(hV,kW)if hV==nil then hV=core.g()end;hV=y(hV,5)if kW~=nil and kW or(aP==nil or aP~=hV)then local f2=core.getVelocity()local e_=vec3(f2):len()local kX=f(unit.getData()).maxBrake;if kX~=nil and kX>0 and at then kX=kX/r(e_/100,0.1,1)kX=kX/au;if au>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+kX)/2 else LastMaxBrakeInAtmo=kX end end end;if kX~=nil and kX>0 then LastMaxBrake=kX end;aP=hV end end;local function kY(fv)local kZ=0;aF=""local k_=aT;local l0=0;local l1=0;local l2=0;local fU=0;local fV=""local l3=core.getElementHitPointsById;for dc in pairs(aw)do local k8=0;local l4=0;l4=h(aw[dc])k8=l3(aw[dc])l0=l0+k8;if k8<l4 then if k8==0 then l2=l2+1 else l1=l1+1 end;if aU and#aC==0 then position=vec3(core.getElementPositionById(aw[dc]))local c7=position.x-coreOffset;local c8=position.y-coreOffset;local l5=position.z-coreOffset;table.insert(aC,core.spawnArrowSticker(c7,c8,l5+1,"down"))table.insert(aC,core.spawnArrowSticker(c7,c8,l5+1,"down"))core.rotateSticker(aC[2],0,0,90)table.insert(aC,core.spawnArrowSticker(c7+1,c8,l5,"north"))table.insert(aC,core.spawnArrowSticker(c7+1,c8,l5,"north"))core.rotateSticker(aC[4],90,90,0)table.insert(aC,core.spawnArrowSticker(c7-1,c8,l5,"south"))table.insert(aC,core.spawnArrowSticker(c7-1,c8,l5,"south"))core.rotateSticker(aC[6],90,-90,0)table.insert(aC,core.spawnArrowSticker(c7,c8-1,l5,"east"))table.insert(aC,core.spawnArrowSticker(c7,c8-1,l5,"east"))core.rotateSticker(aC[8],90,0,90)table.insert(aC,core.spawnArrowSticker(c7,c8+1,l5,"west"))table.insert(aC,core.spawnArrowSticker(c7,c8+1,l5,"west"))core.rotateSticker(aC[10],-90,0,90)table.insert(aC,aw[dc])end elseif aU and#aC>0 and aC[11]==aw[dc]then for fN in pairs(aC)do core.deleteSticker(aC[fN])end;aC={}end end;kZ=d(l0/k_*100)if kZ<100 then fv[#fv+1]=c6(0,0,"","pbright txt")fU=d(kZ*2.55)fV=e("rgb(%d,%d,%d)",255-fU,fU,0)if kZ<100 then fv[#fv+1]=c6("50%",1035,"Elemental Integrity: "..kZ.."%","txtbig txtmid","fill:"..fV)if l2>0 then fv[#fv+1]=c6("50%",1055,"Disabled Modules: "..l2 .." Damaged Modules: "..l1,"txtbig txtmid","fill:"..fV)elseif l1>0 then fv[#fv+1]=c6("50%",1055,"Damaged Modules: "..l1,"txtbig txtmid","fill:"..fV)end end end end;local function l6()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function l7()local fS=q()local h5=bJ;local l8=fS-ax;if h5>1.38889 then h5=h5/1000;local l9=h5*(fS-ax)TotalDistanceTravelled=TotalDistanceTravelled+l9;ac=ac+l9 end;ad=ad+l8;TotalFlightTime=TotalFlightTime+l8;ax=fS end;ar=false;kV(nil,true)l7()bc.UpdateRadar()l6()local fv={}bc.ExtraData(fv)if ShowOdometer then fv=bc.DrawOdometer(fv,ac,TotalDistanceTravelled,ad)end;if ShouldCheckDamage then kY(fv)end;al=table.concat(fv,"")collectgarbage("collect")elseif kG=="fiveSecond"then as=dbHud_1.getStringValue("SPBAutopilotTargetName")if as~=nil and as~=""and as~="SatNavNotChanged"then local cm=f(dbHud_1.getStringValue("SavedLocations"))if cm~=nil then _G["SavedLocations"]=cm;local cJ=-1;local cK;for dc,dd in pairs(SavedLocations)do if dd.name and dd.name=="SatNav Location"then cJ=dc;break end end;if cJ~=-1 then cK=SavedLocations[cJ]cJ=-1;for dc,dd in pairs(b3[0])do if dd.name and dd.name=="SatNav Location"then cJ=dc;break end end;if cJ>-1 then b3[0][cJ]=cK end;bd.UpdateAtlasLocationsList()a1=cK.name.." position updated"end end;for i=1,#bW do if bW[i].name==as then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bW[i].name)bd.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif kG=="msgTick"then local fv={}bc.DisplayMessage(fv,"empty")a1="empty"unit.stopTimer("msgTick")ai=3 elseif kG=="animateTick"then bg=true;bf=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif kG=="hudTick"then local function la(fv)local lb=d(r(aj/(aK/4)*255,0,255))fv[#fv+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,d(C+0.5)+lb,d(E+0.5)-lb,d(D+0.5)-lb)end;local function lc()for _,dd in pairs(aH)do if dd.hovered then if not dd.drawCondition or dd.drawCondition()then dd.toggleFunction()end;dd.hovered=false end end end;local function ld()local function le(lf,lg,c7,c8,kg,kh)if lf>c7 and lf<c7+kg and lg>c8 and lg<c8+kh then return true else return false end end;local c7=ag+aK/2;local c8=ah+aL/2;for _,dd in pairs(aH)do dd.hovered=le(c7,c8,dd.x,dd.y,dd.width,dd.height)end end;local function lh(fv)local function li(fv,lj,hover,c7,c8,eT,lk,ll,lm,ln,lo)if type(ln)=="function"then ln=ln()end;if type(lo)=="function"then lo=lo()end;fv[#fv+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c7,c8,eT,lk)if lj then fv[#fv+1]=e("%s'",ll)else fv[#fv+1]=lm end;if hover then fv[#fv+1]=" style='stroke:white; stroke-width:2'"else fv[#fv+1]=" style='stroke:black; stroke-width:1'"end;fv[#fv+1]="></rect>"fv[#fv+1]=e("<text x='%f' y='%f' font-size='24' fill='",c7+eT/2,c8+lk/2+5)if lj then fv[#fv+1]="black"else fv[#fv+1]="white"end;fv[#fv+1]="' text-anchor='middle' font-family='Montserrat'>"if lj then fv[#fv+1]=e("%s</text>",ln)else fv[#fv+1]=e("%s</text>",lo)end end;local lp="rgb(50,50,50)'"local lq="rgb(210,200,200)"local lr=li;for _,dd in pairs(aH)do local kf=dd.disableName;local ke=dd.enableName;if type(kf)=="function"then kf=kf()end;if type(ke)=="function"then ke=ke()end;if not dd.drawCondition or dd.drawCondition()then lr(fv,dd.toggleVar(),dd.hovered,dd.x,dd.y,dd.width,dd.height,lq,lp,kf,ke)end end end;local fv={}bc.HUDPrologue(fv)if showHud then bc.UpdateHud(fv)else bc.DisplayOrbitScreen(fv)bc.DrawWarnings(fv)end;if bT and bU~={}then bc.DrawSettings(fv)end;bc.HUDEpilogue(fv)fv[#fv+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aK,aL)if a1~="empty"then bc.DisplayMessage(fv,a1)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then bc.DrawDeadZone(fv)end end;if x()==0 then if m()==1 and a0 then ld()lh(fv)if not bf and not bg then local ls=table.concat(fv,"")fv={}fv[#fv+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fv[#fv+1]=ls;fv[#fv+1]="</body>"bf=true;fv[#fv+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fv,"")system.setScreen(content)elseif bg then local ls=table.concat(fv,"")fv={}fv[#fv+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fv[#fv+1]=ls;fv[#fv+1]="</body>"end;if not bf then fv[#fv+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],M,N,ag,ah)end else lc()end else if not a0 and m()==0 then lc()if aj>DeadZone then if DisplayDeadZone then la(fv)end end else ld()lh(fv)end;fv[#fv+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],M,N,ag,ah)end;fv[#fv+1]=[[</svg></body>]]content=table.concat(fv,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif kG=="apTick"then be.APTick()end end;function script.onFlush()local function lt(lu,jm)local lv=vec3()local lw=vec3()if lu==axisCommandId.longitudinal then lv=vec3(core.getConstructOrientationForward())lw=bG elseif lu==axisCommandId.vertical then lv=vec3(core.getConstructOrientationUp())lw=bF elseif lu==axisCommandId.lateral then lv=vec3(core.getConstructOrientationRight())lw=bH else return vec3()end;local lx=vec3(core.getWorldGravity())local ly=lx:dot(lw)local lz=vec3(core.getWorldAirFrictionAcceleration())local lA=lz:dot(lw)local lB=vec3(core.getVelocity())local lC=lB:dot(lv)local lD=jm*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(lD-lC)local lE=targetSpeedPID2:get()local lF=(lE-lA-ly)*lw;return lF end;local function lG(lu,jm)local lv=vec3()local lw=vec3()if lu==axisCommandId.longitudinal then lv=vec3(core.getConstructOrientationForward())lw=bG elseif lu==axisCommandId.vertical then lv=vec3(core.getConstructOrientationUp())lw=bF elseif lu==axisCommandId.lateral then lv=vec3(core.getConstructOrientationRight())lw=bH else return vec3()end;local lx=vec3(core.getWorldGravity())local ly=lx:dot(lw)local lz=vec3(core.getWorldAirFrictionAcceleration())local lA=lz:dot(lw)local lB=vec3(core.getVelocity())local lC=lB:dot(lv)local lD=jm*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(lD-lC)local lE=targetSpeedPID:get()local lF=(lE-lA-ly)*lw;return lF end;local function lH(lI,fZ,ic)local lJ=lI:cross(ic):normalize_inplace()local gJ=math.acos(r(lJ:dot(-fZ),-1,1))*constants.rad2deg;if lJ:cross(-fZ):dot(ic)<0 then gJ=-gJ end;return gJ end;if antigrav and not ExternalAGG then if not bO and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bQ=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bQ and L then cc(0)L=false elseif not bQ and not L then H=0;L=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local lK=r(S+T+system.getControlDeviceForwardInput(),-1,1)local lL=r(V+Y+system.getControlDeviceYawInput(),-1,1)local lM=r(W+U-system.getControlDeviceLeftRightInput(),-1,1)local lN=X;bK=vec3(core.getWorldVertical())if bK==nil or bK:len()==0 then bK=(planet.center-bM):normalize()end;bM=vec3(core.getConstructWorldPos())bF=vec3(core.getConstructWorldOrientationUp())bG=vec3(core.getConstructWorldOrientationForward())bH=vec3(core.getConstructWorldOrientationRight())bI=vec3(core.getWorldVelocity())bJ=vec3(bI):len()bL=-bK:dot(bI)bS=getRoll(bK,bG,bH)local lO=bS/180*math.pi;local lP=math.cos(lO)local lQ=math.sin(lO)bR=lH(bK,bG,bH*lP+bF*lQ)local lR=bI:normalize()local lS=getRoll(bK,bG,bH)local lT=c(lS)local lU=utils.sign(lS)local lV=vec3(core.getWorldAngularVelocity())local lW=lK*pitchSpeedFactor*bH+lL*rollSpeedFactor*bG+lM*yawSpeedFactor*bF;if bK:len()>0.01 and(au>0.0 or ProgradeIsOn or Reentry or an or AltitudeHold or IntoOrbit)then if bh==true and c(bl-lS)>autoRollRollThreshold and lL==0 and c(bR)<85 then local lX=bl;local lY=autoRollFactor;if au==0 then lY=lY/4;bl=0;lX=0 end;if rollPID==nil then rollPID=pid.new(lY*0.01,0,lY*0.1)end;rollPID:inject(lX-lS)local lZ=rollPID:get()lW=lW+lZ*bG end end;if bK:len()>0.01 and au>0.0 then local l_=20.0;if turnAssist==true and lT>l_ and lK==0 and lM==0 then local m0=turnAssistFactor*0.1;local m1=turnAssistFactor*0.025;local m2=(lT-l_)/(180-l_)*180;local m3=0;if m2<90 then m3=m2/90 elseif m2<180 then m3=(180-m2)/90 end;m3=m3*m3;local m4=-lU*m1*(1.0-m3)local m5=m0*m3;lW=lW+m5*bH+m4*bF end end;local m6=1;local m7=0;local m8=1;if system.getMouseWheel()>0 then if AltIsOn then if au>0 or Reentry then bo=r(bo+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end else H=y(r(H+speedChangeLarge/100,-1,1),2)end elseif system.getMouseWheel()<0 then if AltIsOn then if au>0 or Reentry then bo=r(bo-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end else H=y(r(H-speedChangeLarge/100,-1,1),2)end end;I=0;if at and AtmoSpeedAssist and bQ then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bo/3.6-bI:dot(bG))local m9=throttlePID:get()K=r(m9,-1,1)if K<H and au>0.005 then J=true;s:setThrottleCommand(axisCommandId.longitudinal,r(K,0.01,1))else J=false;s:setThrottleCommand(axisCommandId.longitudinal,H)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bI:len()-bo/3.6)local ma=r(brakePID:get(),0,1)if au>0 and bL<-80 or au>0.005 then I=ma end;if I>0 then if J and K==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else K=r(K,0.01,1)end;local mb=''local mc=vec3()local md=lt(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",md,m7)local me='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then me=me..ExtraLongitudeTags end;local mf=s:getAxisCommandType(axisCommandId.longitudinal)local mg=s:composeAxisAccelerationFromThrottle(me,axisCommandId.longitudinal)local mh=lG(axisCommandId.lateral,LeftAmount*1000)mb=mb..' , '.."lateral airfoil , lateral ground "mc=mc+mh;if mc:len()>constants.epsilon then a:setEngineForceCommand(mb,mc,m7,'','','',m8)end;a:setEngineForceCommand(me,mg,m6)local mi='thrust analog vertical fueled 'local mj='thrust analog lateral fueled 'if ExtraLateralTags~="none"then mj=mj..ExtraLateralTags end;if ExtraVerticalTags~="none"then mi=mi..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mi,md,m6)else a:setEngineForceCommand(mi,vec3(),m6)end;if LeftAmount~=0 then a:setEngineForceCommand(mj,mh,m6)else a:setEngineForceCommand(mj,vec3(),m6)end;if lN==0 then lN=I end;local mk=-lN*(brakeSpeedFactor*bI+brakeFlatFactor*lR)a:setEngineForceCommand('brake',mk)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,H)end;local jm=unit.getAxisCommandValue(0)if not bQ then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bI:len()-jm/3.6)local ma=r(brakePID:get(),0,1)lN=r(lN+ma,0,1)end;local mk=-lN*(brakeSpeedFactor*bI+brakeFlatFactor*lR)a:setEngineForceCommand('brake',mk)local mb=''local mc=vec3()local ml=false;local me='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then me=me..ExtraLongitudeTags end;local mf=s:getAxisCommandType(axisCommandId.longitudinal)if mf==axisCommandType.byThrottle then local mg=s:composeAxisAccelerationFromThrottle(me,axisCommandId.longitudinal)a:setEngineForceCommand(me,mg,m6)elseif mf==axisCommandType.byTargetSpeed then local mg=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)mb=mb..' , '..me;mc=mc+mg;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ml=true end end;local mj='thrust analog lateral 'if ExtraLateralTags~="none"then mj=mj..ExtraLateralTags end;local mm=s:getAxisCommandType(axisCommandId.lateral)if mm==axisCommandType.byThrottle then local mn=s:composeAxisAccelerationFromThrottle(mj,axisCommandId.lateral)a:setEngineForceCommand(mj,mn,m6)elseif mm==axisCommandType.byTargetSpeed then local mh=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)mb=mb..' , '..mj;mc=mc+mh end;local mi='thrust analog vertical 'if ExtraVerticalTags~="none"then mi=mi..ExtraVerticalTags end;local mo=s:getAxisCommandType(axisCommandId.vertical)if mo==axisCommandType.byThrottle then local md=s:composeAxisAccelerationFromThrottle(mi,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mi,md,m6,'airfoil','ground','',m8)else a:setEngineForceCommand(mi,vec3(),m6)a:setEngineForceCommand('airfoil vertical',md,m6,'airfoil','','',m8)a:setEngineForceCommand('ground vertical',md,m6,'ground','','',m8)end elseif mo==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),m6)end;local mp=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)mb=mb..' , '..mi;mc=mc+mp end;if mc:len()>constants.epsilon then if X~=0 or ml or c(lR:dot(bG))<0.8 then mb=mb..', brake'end;a:setEngineForceCommand(mb,mc,m7,'','','',m8)end end;local mq=torqueFactor*(lW-lV)local mr=vec3(core.getWorldAirFrictionAngularAcceleration())mq=mq-mr;a:setEngineTorqueCommand('torque',mq,m6,'airfoil','','',m8)a:setBoosterCommand('rocket_engine')if a6 and not VanillaRockets then local e_=vec3(core.getVelocity()):len()local ms=0.15;if not bQ then local mt=s:getTargetSpeed(axisCommandId.longitudinal)if e_*3.6>mt*(1-ms)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e_*3.6<mt*(1-ms)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jf=unit.getThrottle()if AtmoSpeedAssist then jf=H*100 end;local jm=jf/100;if j==0 then jm=jm*MaxGameVelocity;if e_>=jm*(1-ms)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e_<jm*(1-ms)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local js=d(bo)jm=jm*js/3.6;if e_>=jm*(1-ms)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e_<jm*(1-ms)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local _,cm=coroutine.resume(beginSetup)if cm then SetupComplete=true end else a:update()if not bf and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(mu)local B=1;local function mv(mw)if mw then B=-1 end;if not ExternalAGG and bO then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bx=bx+B*a2;if bx<planet.noAtmosphericDensityAltitude then bx=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a2 end else s:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function mx(mw)if mw then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then H=r(H+B*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if mw then B=1 else B=nil end;bd.adjustAutopilotTargetIndex(B)end end;if mu=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cc(0)if(vBooster or hover)and aq==-1 then StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bh=true;GearExtended=false else BrakeIsOn=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end;if R and not BrakeLanding then a.control.extendLandingGears()end else if R then a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif mu=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif mu=="forward"then S=S-1 elseif mu=="backward"then S=S+1 elseif mu=="left"then V=V-1 elseif mu=="right"then V=V+1 elseif mu=="yawright"then W=W-1 elseif mu=="yawleft"then W=W+1 elseif mu=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif mu=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif mu=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif mu=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif mu=="groundaltitudeup"then mv()elseif mu=="groundaltitudedown"then mv(true)elseif mu=="option1"then bd.adjustAutopilotTargetIndex()toggleView=false elseif mu=="option2"then bd.adjustAutopilotTargetIndex(1)toggleView=false elseif mu=="option3"then local function my()aG=not aG;if not aG then unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;my()toggleView=false elseif mu=="option4"then cE()toggleView=false elseif mu=="option5"then local function mz()if LockPitch==nil then LockPitch=bR;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else LockPitch=nil end end;mz()toggleView=false elseif mu=="option6"then cq()toggleView=false elseif mu=="option7"then toggleView=false elseif mu=="option8"then cr()toggleView=false elseif mu=="option9"then if gyro~=nil then gyro.toggle()ay=gyro.getState()==1 end;toggleView=false elseif mu=="lshift"then if x()==1 then a0=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a0=true;bg=false;bf=false end elseif mu=="brake"then if BrakeToggleStatus then cM()elseif not BrakeIsOn then cM()else BrakeIsOn=true end elseif mu=="lalt"then AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif mu=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a6 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a6=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a6=false end elseif mu=="stopengines"then local function mA()if ar then ar=false;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Z=false;O=false;an=false;ao=false;Q=false;bh=autoRollPreference;VectorToTarget=false;TurnBurn=false;ay=false;LockPitch=nil;IntoOrbit=false else ar=true end end;s:resetCommand(axisCommandId.longitudinal)mA()H=0 elseif mu=="speedup"then mx()elseif mu=="speeddown"then mx(true)elseif mu=="antigravity"and not ExternalAGG then if antigrav~=nil then d0()end end end;function script.onActionStop(mu)local function mB()if not ExternalAGG and bO then a5=a3 end;if AltitudeHold or VertTakeOff or IntoOrbit then a4=a2 end end;if mu=="forward"then S=0 elseif mu=="backward"then S=0 elseif mu=="left"then V=0 elseif mu=="right"then V=0 elseif mu=="yawright"then W=0 elseif mu=="yawleft"then W=0 elseif mu=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif mu=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif mu=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mu=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mu=="groundaltitudeup"then mB()toggleView=false elseif mu=="groundaltitudedown"then mB()toggleView=false elseif mu=="lshift"then if x()==1 then a0=false;ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a0=false;bg=false;bf=false end elseif mu=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cM()else BrakeIsOn=false end end elseif mu=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(mu)local B=1;local function mC(mw)if mw then B=-1 end;if not ExternalAGG and bO then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a5=a5*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bx=bx+B*a4;if bx<planet.noAtmosphericDensityAltitude then bx=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a4 end;a4=a4*1.05 else s:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function mD(mw)if mw then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then H=r(H+B*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if mu=="groundaltitudeup"then mC()elseif mu=="groundaltitudedown"then mC(true)elseif mu=="speedup"then mD()elseif mu=="speeddown"then mD(true)end end;function script.onInputText(c9)local function mE()for dc,dd in pairs(b_())do dbHud_1.setStringValue(dd,g(nil))end;for dc,dd in pairs(b)do if dd~="SavedLocations"then dbHud_1.setStringValue(dd,g(nil))end end;a1="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5;aM=false;ae=true end;local function mF(mG,planet,f3)local function mH(f3)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dG,dH,cA,cB,cz=o(f3,dt)if dG=="0"and dH=="0"then return vec3(tonumber(cA),tonumber(cB),tonumber(cz))end;cB=math.rad(cB)cA=math.rad(cA)local planet=b3[tonumber(dG)][tonumber(dH)]local eu=math.cos(cA)local mI=vec3(eu*math.cos(cB),eu*math.sin(cB),math.sin(cA))return planet.center+(planet.radius+cz)*mI end;if dbHud_1 then local cK={}local position=mH(f3)if planet.name=="Space"then cK={position=position,name=mG,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cK={position=position,name=mG,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;SavedLocations[#SavedLocations+1]=cK;table.insert(b3[0],cK)bd.UpdateAtlasLocationsList()else a1="Databank must be installed to save locations"end end;local i;local mJ="/commands /setname /G /agg /addlocation /copydatabank /wipedatabank"local mK,mL=nil,nil;local mM="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all updatable variables with /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572} - adds a saved location by waypoint, not as accurate as making one at location\n".."/copydatabank - copies dbHud databank to a blank databank\n/wipedatabank - wipes the databank of all hud variables but not save variables"i=string.find(c9," ")mK=c9;if i~=nil then mK=string.sub(c9,0,i-1)mL=string.sub(c9,i+1)end;if mK=="/help"or mK=="/commands"then for i0 in string.gmatch(mM,"([^\n]+)")do system.print(i0)end;return elseif mK=="/setname"then if mL==nil or mL==""then a1="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cH(mL)else a1="Select a saved target to rename first"end elseif mK=="/addlocation"then if mL==nil or mL==""or string.find(mL,"::")==nil then a1="Usage: ah-addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572}"return end;i=string.find(mL,"::")local mG=string.sub(mL,1,i-2)local f3=string.sub(mL,i)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dG,dH,cA,cB,cz=o(f3,dt)local planet=b3[tonumber(dG)][tonumber(dH)]mF(mG,planet,f3)a1="Added "..mG.." to saved locations,\nplanet "..planet.name.." at "..f3;ai=5 elseif mK=="/agg"then if mL==nil or mL==""then a1="Usage: ah-agg targetheight"return end;mL=tonumber(mL)if mL<1000 then mL=1000 end;AntigravTargetAltitude=mL;a1="AGG Target Height set to "..mL elseif mK=="/G"then if mL==nil or mL==""then a1="Usage: ah-G VariableName variablevalue\nah-G dump - shows all variables"return end;if mL=="dump"then for dc,dd in pairs(b_())do if type(_G[dd])=="boolean"then if _G[dd]==true then system.print(dd.." true")else system.print(dd.." false")end elseif _G[dd]==nil then system.print(dd.." nil")else system.print(dd.." ".._G[dd])end end;return end;i=string.find(mL," ")local mN=string.sub(mL,0,i-1)local mO=string.sub(mL,i+1)for dc,dd in pairs(b_())do if dd==mN then a1="Variable "..mN.." changed to "..mO;local mP=type(_G[dd])if mP=="number"then mO=tonumber(mO)elseif mP=="boolean"then if string.lower(mO)=="true"then mO=true else mO=false end end;_G[dd]=mO;return end end;a1="No such global variable: "..mN elseif mK=="/copydatabank"then if dbHud_2 then d8(true)else a1="Spare Databank required to copy databank"end elseif mK=="/wipedatabank"then if dbHud_1 then mE()else a1="No databank found."end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
