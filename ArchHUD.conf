name: ArchHud - Archaegeo v1.147 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export: (Default: false)
        userControlScheme = "virtual joystick" --export: (Default: "virtual joystick") Set to "virtual joystick", "mouse", or "keyboard"
        freeLookToggle = true --export: (Default: true)
        BrakeToggleDefault = true --export: (Default: true)
        RemoteFreeze = false --export: (Default: false)
        RemoteHud = true --export: (Default: true)
        brightHud = false --export: (Default: false)
        VanillaRockets = false --export: (Default: false)
        InvertMouse = false --export: (Default: false)
        autoRollPreference = false --export: (Default: false)
        turnAssist = true --export: (Default: true)
        ExternalAGG = false --export: (Default: false)
        UseSatNav = false --export: (Default: false)
        ShouldCheckDamage = true --export: (Default: true)
        CalculateBrakeLandingSpeed = false --export: (Default: false)
        AtmoSpeedAssist = true --export: (Default: true)
        ForceAlignment = false --export: (Default: false)
        DisplayDeadZone = true --export: (Default: true)
        showHud = true --export: (Default: true) 
        ShowOdometer = true --export: (Default: true)
        hideHudOnToggleWidgets = true --export: (Default: true)
        ShiftShowsRemoteButtons = true --export: (Default: true)
        DisplayOrbit = true --export: (Default: true) 
        YawStallAngle = 35 --export: (Default: 35)
        PitchStallAngle = 35 --export: (Default: 35)
        brakeLandingRate = 30 --export: (Default: 30)
        MaxPitch = 30 --export: (Default: 30)
        TargetOrbitRadius = 1.4 --export: (Default: 1.4)
        AtmoSpeedLimit = 1050 --export: (Default: 1050)
        SpaceSpeedLimit = 30000 --export: (Default: 30000).
        AutoTakeoffAltitude = 1000 --export: (Default: 1000)
        TargetHoverHeight = 50 --export: (Default: 50)
        LandingGearGroundHeight = 0 --export: (Default: 0)
        MaxGameVelocity = 8333.00 --export: (Default: 8333.00)
        AutopilotInterplanetaryThrottle = 1.0 --export: (Default: 1.0)
        warmup = 32 --export: (Default: 32)
        fuelTankHandlingAtmo = 0 --export: (Default: 0)
        fuelTankHandlingSpace = 0 --export: (Default: 0)
        fuelTankHandlingRocket = 0 --export: (Default: 0)
        ContainerOptimization = 0 --export: (Default: 0)
        FuelTankOptimization = 0 --export: (Default: 0)
        ResolutionX = 1920 --export: (Default: 1920)
        ResolutionY = 1080 --export: (Default: 1080) 
        circleRad = 400 --export: (Default: 400)
        SafeR = 130 --export: (Default: 130)
        SafeG = 224 --export: (Default: 224)
        SafeB = 255 --export: (Default: 255)
        PvPR = 255 --export: (Default: 255)
        PvPG = 0 --export: (Default: 0)
        PvPB = 0 --export: (Default: 0)
        centerX = 960 --export: (Default: 960)
        centerY = 540 --export: (Default: 540)
        throtPosX = 1300 --export: (Default: 1300)
        throtPosY = 540 --export: (Default: 540)
        vSpdMeterX = 1525  --export: (Default: 1525)
        vSpdMeterY = 325 --export: (Default: 325)
        altMeterX = 550  --export: (Default: 550)
        altMeterY = 540 --export: (Default: 540) 
        fuelX = 100 --export: (Default: 100)
        fuelY = 300 --export: (Default: 300)
        DeadZone = 50 --export: (Default: 50)
        OrbitMapSize = 250 --export: (Default: 250)
        OrbitMapX = 75 --export: (Default: 75)
        OrbitMapY = 0 --export: (Default: 0)
        speedChangeLarge = 5 --export: (Default: 5)
        speedChangeSmall = 1 --export: (Default: 1)
        MouseXSensitivity = 0.003 --export: (Default: 0.003)
        MouseYSensitivity = 0.003 --export: (Default: 0.003)
        autoRollFactor = 2 --export: (Default: 2)
        rollSpeedFactor = 1.5 --export: (Default: 1.5)
        autoRollRollThreshold = 0 --export: (Default: 0)
        minRollVelocity = 150 --export: (Default: 150)    
        turnAssistFactor = 2 --export: (Default: 2)
        TrajectoryAlignmentStrength = 0.002 --export: (Default: 0.002)
        torqueFactor = 2 --export: (Default: 2)
        pitchSpeedFactor = 0.8 --export: (Default: 0.8)
        yawSpeedFactor = 1 --export: (Default: 1)
        brakeSpeedFactor = 3 --export: (Default: 3)
        brakeFlatFactor = 1 --export: (Default: 1)
        DampingMultiplier = 40 --export: (Default: 40) 
        apTickRate = 0.0166667 --export: (Default: 0.0166667)  
        hudTickRate = 0.0666667 --export: (Default: 0.0666667)
        ExtraLongitudeTags = "none" --export: (Default: "none")
        ExtraLateralTags = "none" --export: (Default: "none")
        ExtraVerticalTags = "none" --export: (Default: "none")
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.147;SetWaypointOnExit=true;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;showHelp=true;local b={"showHelp","VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=core.getConstructMass;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local tostring=tostring;local p=utils.round;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local function y(z,A)local B=10^(A or 0)return d(z*B+0.5)/B end;local C=SafeR;local D=SafeB;local E=SafeG;local F=false;local G=0;local H=0;local I=0;local J=false;local K=0;local L=false;local M=y(ResolutionX/2,0)local N=y(ResolutionY/2,0)local O=false;local P=55;local Q=false;local R=false;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=false;local a0=false;local a1="empty"local a2=5;local a3=5;local a4=a2;local a5=a3;local a6=false;local a7,a8=0;local a9,aa=0;local ab=nil;local ac=0;local ad=0;local ae=false;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=""local am=0;local an=false;local ao=false;local ap=false;local aq=-1;local ar=false;local as=""local at=j()>0;local au=j()local av=core.getAltitude()local aw=core.getElementIdList()local ax=q()local ay=nil;local az=false;local aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]local aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local aC={}local aD=0;local aE=0;local aF=""local aG=true;local aH={}local aI={}local aJ={}local aK=ResolutionX;local aL=ResolutionY;local aM=false;local aN=false;local aO=0;local aP=nil;local aQ={}local aR={}local aS={}local aT=0;local aU=false;local aV={}local aW={}local aX=d(1/apTickRate)*2;local aY={}local aZ={}local a_={}local b0={}local b1=false;local b2=0;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=nil;local bd=nil;local be=nil;local bf=false;local bg=false;local bh=autoRollPreference;local bi=LandingGearGroundHeight;local bj=false;local bk=q()local bl=0;local bm=0;local bn=0;local bo=AtmoSpeedLimit;local bp=0;local bq=nil;local br=0;local bs=0;local bt=false;local bu=false;local bv={VectorToTarget=false}local bw=false;local bx=0;local by=nil;local bz=false;local bA=false;local bB=false;local bC=false;local bD=0;local bE=q()local bF=vec3(core.getConstructWorldOrientationUp())local bG=vec3(core.getConstructWorldOrientationForward())local bH=vec3(core.getConstructWorldOrientationRight())local bI=vec3(core.getWorldVelocity())local bJ=vec3(bI):len()local bK=vec3(core.getWorldVertical())local bL=-bK:dot(bI)local bM=vec3(core.getConstructWorldPos())local bN=false;local bO=false;local bP=nil;local bQ=true;local bR=0;local bS=0;local bT=false;local bU={}local bV=showHud;local bW={}local function bX(bY,bZ)for i=1,#bZ do bY[#bY+1]=bZ[i]end;return bY end;local function b_(c0)local c1={}local c2={"userControlScheme","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit"}local c3={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c4={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY"}local c5={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c0 then bX(c1,c2)bX(c1,c3)bX(c1,c4)bX(c1,c5)return c1 elseif c0=="boolean"then return c2 elseif c0=="handling"then return c3 elseif c0=="hud"then return c4 elseif c0=="physics"then return c5 end end;local function c6(c7,c8,c9,ca,cb)if ca==nil then ca=""end;if cb==nil then cb=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ca,c7,c8,cb,c9)end;local function cc(cd,ce)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ce then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cd)H=r(y(cd*100,0)/100,-1,1)end;local function cf(cd,ce)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ce then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cd)bP=cd end;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*epsilon end;local function cj(aj,ck)local cl=aj>100000;local cm,cn=""if ck==nil then ck=1 end;if cl then cm,cn=y(aj/1000/200,ck),"SU"elseif aj<1000 then cm,cn=y(aj,ck),"M"else cm,cn=y(aj/1000,ck),"KM"end;return cm,cn end;local function co()if VertTakeOff then AltitudeHold=false;StrongBrakes=true;Reentry=false;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=true;VertTakeOff=false;bh=true;af=0;if at and aq==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cf(d(bo))end else VertTakeOff=true;AltitudeHold=false;bz=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end end;local function cp()bz=false;br=nil;bs=nil;bD=0;if au==0 then if IntoOrbit then IntoOrbit=false;bt=false;by=nil;bh=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bv.VectorToTarget=false;bv.AutopilotAlign=false;bw=false elseif unit.getClosestPlanetInfluence()>0 then IntoOrbit=true;bh=true;if by==nil then by=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a1="Unable to engage orbiting, not near planet"end else IntoOrbit=false;bt=false;by=nil;bh=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bv.VectorToTarget=false;bv.AutopilotAlign=false;bw=false end end;local function cq()if bE-bm<1.5 then if planet.hasAtmosphere then if au>0 then HoldAltitude=planet.spaceEngineMinAltitude-50 else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+1000;bx=HoldAltitude;bw=true;if not IntoOrbit then cp()end;bt=true end end;bm=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bm=bE end;if unit.getClosestPlanetInfluence()>0 and au==0 then bx=av;bw=true;bt=true;cp()if IntoOrbit then bm=bE else bm=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Z=false;bh=true;LockPitch=nil;bz=false;if aq==-1 then AutoTakeoff=false;if bm>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=av end end;if VertTakeOff then co()end else AutoTakeoff=true;if bm>-1 then HoldAltitude=av+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bN then co()end end;if ao then HoldAltitude=100000 end else if IntoOrbit then cp()end;if VertTakeOff then co()end;bh=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bm=0 end end;local function cr()if m()==1 then Z=not Z;if Z then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)else BrakeIsOn=true;bh=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a1="Follow Mode only works with Remote controller"Z=false end end;local function cs(planet,ct)local function cu(cv,cw)local cx=vec3(cw)if cv.bodyId==0 then return setmetatable({latitude=cx.x,longitude=cx.y,altitude=cx.z,bodyId=0,systemId=cv.planetarySystemId},MapPosition)end;local cy=cx-cv.center;local aj=cy:len()local cz=aj-cv.radius;local cA=0;local cB=0;if not cg(aj,0)then local cC=n(cy.y,cy.x)cB=cC>=0 and cC or 2*math.pi+cC;cA=math.pi/2-math.acos(cy.z/aj)end;return setmetatable({latitude=math.deg(cA),longitude=math.deg(cB),altitude=cz,bodyId=cv.bodyId,systemId=cv.planetarySystemId},MapPosition)end;local cD=cu(planet,ct)cD="::pos{"..cD.systemId..","..cD.bodyId..","..cD.latitude..","..cD.longitude..","..cD.altitude.."}"system.setWaypoint(cD)end;local function cE()local function cF(SpaceTarget)VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cq()end end;VectorStatus="Proceeding to Waypoint"end;if bE-bn<1.5 and au>0 then if not bC then a1="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if au>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+1000 end;bn=-1;if Autopilot or VectorToTarget then return end end else bn=bE end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not ao then bd.UpdateAutopilotTarget()cs(ab,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then if au~=0 then ao=true;cq()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if au>0 then if not VectorToTarget then cF(SpaceTarget)end else if av>AutopilotTargetOrbit*1.5 or av==0 then bz=false;Autopilot=true elseif not at then if IntoOrbit then cp()end;bx=planet.noAtmosphericDensityAltitude+1000;bw=true;bv.AutopilotAlign=true;bv.VectorToTarget=true;bt=false;if not IntoOrbit then cp()end end end else RetrogradeIsOn=false;ProgradeIsOn=false;if au~=0 then ao=true;cq()else Autopilot=true end end elseif au==0 then local cG=unit.getClosestPlanetInfluence()>0;if CustomTarget==nil and(ab.name==planet.name and cG)and not IntoOrbit then WaypointSet=false;bz=false;bt=false;cp()else Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Z=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;O=false;LockPitch=nil;WaypointSet=false end else ao=true;cq()end else ao=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;O=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=av;TargetSet=false;Reentry=false;if IntoOrbit then cp()end end end;local function cH(cI)local cJ=-1;local cK;cJ=bd.findAtlasIndex(SavedLocations)if cJ~=-1 then local cL;if cI~=nil then cK={position=SavedLocations[cJ].position,name=cI,atmosphere=SavedLocations[cJ].atmosphere,planetname=SavedLocations[cJ].planetname,gravity=SavedLocations[cJ].gravity}else cK={position=bM,name=SavedLocations[cJ].name,atmosphere=au,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cJ]=cK;cJ=-1;cJ=bd.findAtlasIndex(b3[0])if cJ>-1 then b3[0][cJ]=cK end;bd.UpdateAtlasLocationsList()a1=CustomTarget.name.." position updated"bd.UpdateAutopilotTarget()else a1="Name Not Found"end end;local function cM()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bh=autoRollPreference end;if BrakeIsOn then AltitudeHold=false;VectorToTarget=false;AutoTakeoff=false;VertTakeOff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;AltitudeHold=false;if VertTakeOff then co()end;if IntoOrbit then cp()end;LockPitch=nil;bh=autoRollPreference;an=false;ap=false;af=0 end end;local function cN(cO,cP,cQ)local function cR(cO,cS)cO=vec3(cO)cS=vec3(cS):normalize()local cm=cO*cS;return cm.x+cm.y+cm.z end;local cT=0.001;local cU=1;if not at or not bj or aq~=-1 or bJ<P then local cV=cQ;if cV==nil then cV=DampingMultiplier end;if cP==nil then cP=cT end;cO=vec3(cO):normalize()local cW=vec3()-cO;local cX=-cR(cW,core.getConstructWorldOrientationRight())*cU;local cY=-cR(cW,core.getConstructWorldOrientationUp())*cU;if aD==0 then aD=cX/2 end;if aE==0 then aE=cY/2 end;if c(cX)<0.1 then U=U-cX*2 else U=U-(cX+(cX-aD)*cV)end;if c(cY)<0.1 then T=T+cY*2 else T=T+cY+(cY-aE)*cV end;aD=cX;aE=cY;if c(cX)<cP and c(cY)<cP then return true end;return false elseif bj and aq==-1 then cO=bI;local cV=cQ;if cV==nil then cV=DampingMultiplier end;if cP==nil then cP=cT end;cO=vec3(cO):normalize()local cW=bG-cO;local cX=-cR(cW,core.getConstructWorldOrientationRight())*cU;local cY=-cR(cW,core.getConstructWorldOrientationUp())*cU;if aD==0 then aD=cX/2 end;if aE==0 then aE=cY/2 end;if c(cX)<0.1 then U=U-cX*5 else U=U-(cX+(cX-aD)*cV)end;if c(cY)<0.1 then T=T+cY*5 else T=T+cY+(cY-aE)*cV end;aD=cX;aE=cY;if c(cX)<cP and c(cY)<cP then return true end;return false end end;local function cZ()if Reentry then a1="Re-Entry cancelled"Reentry=false;bh=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not Q then StrongBrakes=planet.gravity*9.80665*l()<LastMaxBrakeInAtmo;if not StrongBrakes then a1="WARNING: Insufficient Brakes for Parachute Re-Entry"else Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bh=true;BrakeIsOn=false;a1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bo end else Reentry=true;AltitudeHold=true;bh=true;BrakeIsOn=false;HoldAltitude=planet.spaceEngineMinAltitude-50;local c9,c_=cj(HoldAltitude)a1="Beginning Re-entry.  Target speed: "..bo.." Target Altitude: "..c9 ..c_;cf(d(bo))end;AutoTakeoff=false end;local function d0()if antigrav and not ExternalAGG then if bO then antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=av end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;antigrav.activate()antigrav.show()end end end;local function d1(d2)local d3=0;local d4=0;local d5=0;if d2<60 then d2=d(d2)elseif d2<3600 then d3=d(d2/60)d2=d(d2%60)elseif d2<86400 then d4=d(d2/3600)d3=d(d2%3600/60)else d5=d(d2/86400)d4=d(d2%86400/3600)end;if d5>0 then return d5 .."d "..d4 .."h "elseif d4>0 then return d4 .."h "..d3 .."m "elseif d3>0 then return d3 .."m "..d2 .."s"elseif d2>0 then return d2 .."s"else return"0s"end end;local function d6()local d7=-1;if telemeter_1 then d7=telemeter_1.getDistance()end;if aq~=-1 and d7~=-1 then if aq<d7 then return aq else return d7 end elseif aq~=-1 then return aq else return d7 end end;local function d8(d9)local function da(db)for dc,dd in pairs(db)do dbHud_1.setStringValue(dd,g(_G[dd]))if d9 and dbHud_2 then dbHud_2.setStringValue(dd,g(_G[dd]))end end end;if dbHud_1 then if not ae then da(b)da(b_())system.print("Saved Variables to Datacore")if d9 and dbHud_2 then a1="Databank copied.  Remove copy when ready."end end end end;local function de()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function df()local function dg(dh)return type(dh)=='number'end;local function di(dh)return type(tonumber(dh))=='number'end;local function dj(dk)return type(dk)=='table'end;local function dl(dm)return type(dm)=='string'end;local function dn(dd)return dj(dd)and dg(dd.x and dd.y and dd.z)end;local function dp(dq)return dj(dq)and dg(dq.latitude and dq.longitude and dq.altitude and dq.bodyId and dq.systemId)end;local dr=math.pi/180;local ds=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local du=r;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*epsilon end;local function dv(dh)local cm=string.gsub(string.reverse(e('%.4f',dh)),'^0*%.?','')return cm==''and'0'or string.reverse(cm)end;local function dw(dx)if dn(dx)then return e('{x=%.3f,y=%.3f,z=%.3f}',dx.x,dx.y,dx.z)end;if dj(dx)and not getmetatable(dx)then local dy={}local dz=next(dx)if type(dz)=='nil'or dz==1 then dy=dx else for dc,dd in pairs(dx)do local cd=dw(dd)if type(dc)=='number'then table.insert(dy,e('[%s]=%s',dc,cd))else table.insert(dy,e('%s=%s',dc,cd))end end end;return e('{%s}',table.concat(dy,','))end;if dl(dx)then return e("'%s'",dx:gsub("'",[[\']]))end;return tostring(dx)end;local dA={}dA.__index=dA;dA.__tostring=function(dx,dB)local dC={}for dc in pairs(dx)do table.insert(dC,dc)end;table.sort(dC)local dy={}for _,dc in ipairs(dC)do local cd=dw(dx[dc])if type(dc)=='number'then table.insert(dy,e('[%s]=%s',dc,cd))else table.insert(dy,e('%s=%s',dc,cd))end end;if dB then return e('%s%s',dB,table.concat(dy,',\n'..dB))end;return e('{%s}',table.concat(dy,','))end;dA.__eq=function(dD,dE)return dD.planetarySystemId==dE.planetarySystemId and dD.bodyId==dE.bodyId and cg(dD.radius,dE.radius)and cg(dD.center.x,dE.center.x)and cg(dD.center.y,dE.center.y)and cg(dD.center.z,dE.center.z)and cg(dD.GM,dE.GM)end;local function dF(dG,dH,dI,cw,dJ)assert(di(dG),'Argument 1 (planetarySystemId) must be a number:'..type(dG))assert(di(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(di(dI),'Argument 3 (radius) must be a number:'..type(dI))assert(dj(cw),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cw))assert(di(dJ),'Argument 5 (GM) must be a number:'..type(dJ))return setmetatable({planetarySystemId=tonumber(dG),bodyId=tonumber(dH),radius=tonumber(dI),center=vec3(cw),GM=tonumber(dJ)},dA)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dK)return e('::pos{%d,%d,%s,%s,%s}',dK.systemId,dK.bodyId,dv(dK.latitude*ds),dv(dK.longitude*ds),dv(dK.altitude))end;MapPosition.__eq=function(dD,dE)return dD.bodyId==dE.bodyId and dD.systemId==dE.systemId and cg(dD.latitude,dE.latitude)and cg(dD.altitude,dE.altitude)and(cg(dD.longitude,dE.longitude)or cg(dD.latitude,math.pi/2)or cg(dD.latitude,-math.pi/2))end;local function dL(dM,dH,cA,cB,cz)local dG=dM;if dl(dM)and not cB and not cz and not dH and not cA then dG,dH,cA,cB,cz=o(dM,dt)assert(dG,'Argument 1 (position string) is malformed.')else assert(di(dG),'Argument 1 (systemId) must be a number:'..type(dG))assert(di(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(di(cA),'Argument 3 (latitude) must be in degrees:'..type(cA))assert(di(cB),'Argument 4 (longitude) must be in degrees:'..type(cB))assert(di(cz),'Argument 5 (altitude) must be in meters:'..type(cz))end;dG=tonumber(dG)dH=tonumber(dH)cA=tonumber(cA)cB=tonumber(cB)cz=tonumber(cz)if dH==0 then return setmetatable({latitude=cA,longitude=cB,altitude=cz,bodyId=dH,systemId=dG},MapPosition)end;return setmetatable({latitude=dr*du(cA,-90,90),longitude=dr*(cB%360),altitude=cz,bodyId=dH,systemId=dG},MapPosition)end;local dN={}dN.__index=dN;dN.__tostring=function(dx,dB)local dO=dB and dB..'  'local dP={}local dC={}for dc in pairs(dx)do table.insert(dC,dc)end;table.sort(dC)for _,dQ in ipairs(dC)do bdy=dx[dQ]local dR=dA.__tostring(bdy,dO)if dB then table.insert(dP,e('[%s]={\n%s\n%s}',dQ,dR,dB))else table.insert(dP,e('  [%s]=%s',dQ,dR))end end;if dB then return e('\n%s%s%s',dB,table.concat(dP,',\n'..dB),dB)end;return e('{\n%s\n}',table.concat(dP,',\n'))end;local function dS(dT)local b3={}local pid;for _,dd in pairs(dT)do local dU=dd.planetarySystemId;if type(dU)~='number'then error('Invalid planetary system ID: '..tostring(dU))elseif pid and dU~=pid then error('Mistringmatch planetary system IDs: '..dU..' and '..pid)end;local dV=dd.bodyId;if type(dV)~='number'then error('Invalid body ID: '..tostring(dV))elseif b3[dV]then error('Duplicate body ID: '..tostring(dV))end;setmetatable(dd.center,getmetatable(vec3.unit_x))b3[dV]=setmetatable(dd,dA)pid=dU end;return setmetatable(b3,dN)end;b7={}local function dW(dT)return setmetatable({galaxyAtlas=dT or{}},b7)end;b7.__index=function(dk,i)if type(i)=='number'then local system=dk.galaxyAtlas[i]return dS(system)end;return rawget(b7,i)end;b7.__pairs=function(dx)return function(dk,dc)local dX,nv=next(dk,dc)return dX,nv and dS(nv)end,dx.galaxyAtlas,nil end;b7.__tostring=function(dx)local dY={}for _,dZ in pairs(dx or{})do local d_=dZ:getPlanetarySystemId()local e0=dN.__tostring(dZ,'    ')table.insert(dY,e('  [%s]={%s\n  }',d_,e0))end;return e('{\n%s\n}\n',table.concat(dY,',\n'))end;b7.BodyParameters=dF;b7.MapPosition=dL;b7.PlanetarySystem=dS;function b7.createBodyParameters(e1,dH,e2,e3,e4,e5,e6)assert(di(e1),'Argument 1 (planetarySystemId) must be a number:'..type(e1))assert(di(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(di(e2),'Argument 3 (surfaceArea) must be a number:'..type(e2))assert(dj(e3),'Argument 4 (aPosition) must be an array or vec3:'..type(e3))assert(dj(e4),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(e4))assert(di(e5),'Argument 6 (altitude) must be in meters:'..type(e5))assert(di(e6),'Argument 7 (gravityAtPosition) must be number:'..type(e6))local dI=math.sqrt(e2/4/math.pi)local aj=dI+e5;local e7=vec3(e3)+aj*vec3(e4)local dJ=e6*aj*aj;return dF(e1,dH,dI,e7,dJ)end;b7.isMapPosition=dp;function b7:getPlanetarySystem(dM)if i==nil then i=0 end;if nv==nil then nv=0 end;local e1=dM;if dp(dM)then e1=dM.systemId end;if type(e1)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dN then system=dS(system)end;return system end end end;function dN:castIntersections(e8,cS,e9,ea)local e9=e9 or function(eb)return 1.05*eb.radius end;local ec={}if ea then for _,i in ipairs(ea)do ec[i]=self[i]end else ea={}for dc,eb in pairs(self)do table.insert(ea,dc)ec[dc]=eb end end;local function ed(ee,ef)local eg=ec[ee].center-e8;local eh=ec[ef].center-e8;return eg:len()<eh:len()end;table.sort(ea,ed)local ei=cS:normalize()for i,dU in ipairs(ea)do local eb=ec[dU]local ej=eb.center-e8;local dI=e9(eb)local ek=ej:dot(ei)local el=ek^2-(ej:len2()-dI^2)if el>=0 then local em=math.sqrt(el)local en=ek+em;local eo=ek-em;if eo>0 then return eb,en,eo elseif en>0 then return eb,en,nil end end end;return nil,nil,nil end;function dN:closestBody(ct)assert(type(ct)=='table','Invalid coordinates.')local ep,eb;local eq=vec3(ct)for _,er in pairs(self)do local es=(er.center-eq):len2()if(not eb or es<ep)and er.name~="Space"then eb=er;ep=es end end;return eb end;function dN:convertToBodyIdAndWorldCoordinates(dM)local et=dM;if dl(dM)then et=dL(dM)end;if et.bodyId==0 then return 0,vec3(et.latitude,et.longitude,et.altitude)end;local er=self:getBodyParameters(et)if er then return et.bodyId,er:convertToWorldCoordinates(et)end end;function dN:getBodyParameters(dM)local dH=dM;if dp(dM)then dH=dM.bodyId end;assert(di(dH),'Argument 1 (bodyId) must be a number:'..type(dH))return self[dH]end;function dN:getPlanetarySystemId()local _,dd=next(self)return dd and dd.planetarySystemId end;function dA:convertToMapPosition(cw)assert(dj(cw),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cw))local cx=vec3(cw)if self.bodyId==0 then return setmetatable({latitude=cx.x,longitude=cx.y,altitude=cx.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local cy=cx-self.center;local aj=cy:len()local cz=aj-self.radius;local cA=0;local cB=0;if not cg(aj,0)then local cC=n(cy.y,cy.x)cB=cC>=0 and cC or 2*math.pi+cC;cA=math.pi/2-math.acos(cy.z/aj)end;return setmetatable({latitude=cA,longitude=cB,altitude=cz,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dA:convertToWorldCoordinates(dM)local et=dl(dM)and dL(dM)or dM;if et.bodyId==0 then return vec3(et.latitude,et.longitude,et.altitude)end;assert(dp(et),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(et.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(et.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local eu=math.cos(et.latitude)return self.center+(self.radius+et.altitude)*vec3(eu*math.cos(et.longitude),eu*math.sin(et.longitude),math.sin(et.latitude))end;function dA:getAltitude(cw)return(vec3(cw)-self.center):len()-self.radius end;function dA:getDistance(cw)return(vec3(cw)-self.center):len()end;function dA:getGravity(cw)local ev=self.center-vec3(cw)local ew=ev:len2()return self.GM/ew*ev/math.sqrt(ew)end;return setmetatable(b7,{__call=function(_,...)return dW(...)end})end;local function ex()local b9={}local ey=30000000/3600;local ez=ey*ey;local eA=100;local function eB(dd)return 1/math.sqrt(1-dd*dd/ez)end;function b9.computeAccelerationTime(eC,eD,eE)local eF=ey*math.asin(eC/ey)return(ey*math.asin(eE/ey)-eF)/eD end;function b9.computeDistanceAndTime(eC,eE,eG,eH,eI,eJ)eI=eI or 0;eJ=eJ or 0;local eK=eC<=eE;local eL=eH*(eK and 1 or-1)/eG;local eM=-eJ/eG;local eN=eL+eM;if eK and eN<=0 or not eK and eN>=0 then return-1,-1 end;local eO,eP=0,0;if eL~=0 and eI>0 then local eF=math.asin(eC/ey)local eQ=math.pi*(eL/2+eM)local eR=eL*eI;local eS=ey*math.pi;local dd=function(dk)local eT=(eQ*dk-eR*math.sin(math.pi*dk/2/eI)+eS*eF)/eS;local eU=math.tan(eT)return ey*eU/math.sqrt(eU*eU+1)end;local eV=eK and function(dm)return dm>=eE end or function(dm)return dm<=eE end;eP=2*eI;if eV(dd(eP))then local eW=0;while c(eP-eW)>0.5 do local dk=(eP+eW)/2;if eV(dd(dk))then eP=dk else eW=dk end end end;local eX=eC;local eY=eP/eA;for eZ=1,eA do local e_=dd(eZ*eY)eO=eO+(e_+eX)*eY/2;eX=e_ end;if eP<2*eI then return eO,eP end;eC=eX end;local eF=ey*math.asin(eC/ey)local bE=(ey*math.asin(eE/ey)-eF)/eN;local f0=ez*math.cos(eF/ey)/eN;local aj=f0-ez*math.cos((eN*bE+eF)/ey)/eN;return aj+eO,bE+eP end;function b9.computeTravelTime(eC,eD,aj)if aj==0 then return 0 end;if eD>0 then local eF=ey*math.asin(eC/ey)local f0=ez*math.cos(eF/ey)/eD;return(ey*math.acos(eD*(f0-aj)/ez)-eF)/eD end;if eC==0 then return-1 end;assert(eC>0,'Acceleration and initial speed are both zero.')return aj/eC end;function b9.lorentz(dd)return eB(dd)end;return b9 end;local function f1()local vec3=require('cpml.vec3')local df=df()local function dl(dm)return type(dm)=='string'end;local function dj(dk)return type(dk)=='table'end;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*constants.epsilon end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cz)assert(self.body)local aj=cz+self.body.radius;if not cg(aj,0)then local orbit=math.sqrt(self.body.GM/aj)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dM,f2)assert(self.body)assert(dj(dM)or dl(dM))assert(dj(f2))local f3=(dl(dM)or df.isMapPosition(dM))and self.body:convertToWorldCoordinates(dM)or vec3(dM)local dd=vec3(f2)local f4=f3-self.body.center;local eh=dd:len2()local f5=f4:len()local f6=self.body.GM;local f7=((eh-f6/f5)*f4-f4:dot(dd)*dd)/f6;local ch=f6/(2*f6/f5-eh)local f8=f7:len()local ei=f7:normalize()local f9=ch*(1-f8)local fa=ch*(1+f8)local fb=f9*ei+self.body.center;local fc=f8<=1 and-fa*ei+self.body.center or nil;local fd=math.sqrt(ch*f6*(1-f8*f8))local fe=fc and 2*math.pi*math.sqrt(ch^3/f6)local ff=math.acos(f7:dot(f4)/(f8*f5))if f4:dot(dd)<0 then ff=-(ff-2*math.pi)end;local fg=math.acos((math.cos(ff)+f8)/(1+f8*math.cos(ff)))local fh=fg;if fh<0 then fh=fh+2*math.pi end;local fi=fh-f8*math.sin(fh)local fj=0;local fk=0;local fl=0;if fe~=nil then fj=fi/(2*math.pi/fe)fk=fe-fj;fl=fk+fe/2;if ff-math.pi>0 then fk=fj;fl=fk+fe/2 end;if fl>fe then fl=fl-fe end end;return{periapsis={position=fb,speed=fd/f9,circularOrbitSpeed=math.sqrt(f6/f9),altitude=f9-self.body.radius},apoapsis=fc and{position=fc,speed=fd/fa,circularOrbitSpeed=math.sqrt(f6/fa),altitude=fa-self.body.radius},currentVelocity=dd,currentPosition=f3,eccentricity=f8,period=fe,eccentricAnomaly=fg,meanAnomaly=fi,timeToPeriapsis=fk,timeToApoapsis=fl}end;local function fm(fn)local er=df.BodyParameters(fn.planetarySystemId,fn.bodyId,fn.radius,fn.center,fn.GM)return setmetatable({body=er},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return fm(...)end})end;local function fo()local function fp(dd)if aK==1920 then return dd else return y(aK*dd/1920,0)end end;local function fq(dd)if aL==1080 then return dd else return y(aL*dd/1080,0)end end;local function fr()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function fs()local ft="TRAVEL"if not bQ then ft="CRUISE"end;if Autopilot then ft="AUTOPILOT"end;return ft end;local function fu(fv,b1,c7,fw,fx,fy,fz,fA)local fB=1;local fC=2;local fD=3;local fE=4;local fF=5;local fG=6;local fH=""local fI=0;local fJ=fuelY;local fK=fuelY+10;if m()==1 and not RemoteHud then fJ=fJ-50;fK=fK-50 end;if fx=="ATMO"then fH="atmofueltank"elseif fx=="SPACE"then fH="spacefueltank"else fH="rocketfueltank"end;fI=_G[fH.."_size"]if#fy>0 then for i=1,#fy do local fL=string.sub(fy[i][fC],1,12)local fM=0;for fN=1,fI do if fy[i][fC]==f(unit[fH.."_"..fN].getData()).name then fM=fN;break end end;if b1 or fz[i]==nil or fA[i]==nil then local fO=0;local fP=0;local fQ=0;local fR=0;local fS=q()if fM~=0 then fA[i]=f(unit[fH.."_"..fM].getData()).percentage;fz[i]=f(unit[fH.."_"..fM].getData()).timeLeft;if fz[i]=="n/a"then fz[i]=0 end else fQ=k(fy[i][fB])-fy[i][fE]fO=fy[i][fD]fA[i]=d(0.5+fQ*100/fO)fP=fy[i][fF]fR=fy[i][fG]if fP<=fQ then fz[i]=0 else fz[i]=d(0.5+fQ/((fP-fQ)/(fS-fR)))end;fy[i][fF]=fQ;fy[i][fG]=fS end end;if fL==fw then fL=e("%s %d",fx,i)end;if fM==0 then fL=fL.." *"end;local fT;if fz[i]==0 then fT="n/a"else fT=d1(fz[i])end;if fA[i]~=nil then local fU=d(fA[i]*2.55)local fV=e("rgb(%d,%d,%d)",255-fU,fU,0)local ca=""if fT~="n/a"and fz[i]<120 or fA[i]<5 then if b1 then ca=[[class="red"]]end end;fv[#fv+1]=c6(c7,fJ,fL,ca.." pdim txtfuel")fv[#fv+1]=c6(c7,fK,e("%d%% %s",fA[i],fT),"pdim txtfuel","fill:"..fV)fJ=fJ+30;fK=fK+30 end end end end;local function fW(fv,cz)if cz<200000 and not at or cz and at then local fX=0;if c(bL)>1 then fX=45*math.log(c(bL),10)if bL<0 then fX=-fX end end;fv[#fv+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bL),d(fX))end;return fv end;local function fY(fZ)local f_=-bK;fZ=fZ-fZ:project_on(f_)local g0=vec3(0,0,1)g0=g0-g0:project_on(f_)local g1=g0:cross(f_)local fX=g0:angle_between(fZ)*constants.rad2deg;if fZ:dot(g1)<0 then fX=360-fX end;return fX end;local function g2(fv,centerX,centerY,g3,g4,cG)local g5=circleRad;local g6=20;local g7=d(g3)if cG then for i=-45,45,5 do local g8=i;fv[#fv+1]=e([[<g transform="rotate(%f,%d,%d)">]],g8,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fv[#fv+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+g5+g6-len,centerX,centerY+g5+g6)end;fv[#fv+1]=c6(centerX,centerY+g5+g6-35,g4,"pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY+g5+g6-25,g7 .." deg","pdim txt txtmid")fv[#fv+1]=e([[<g transform="rotate(%f,%d,%d)">]],-g3,centerX,centerY)fv[#fv+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+g5+g6-20,centerX+5,centerY+g5+g6-20,centerX,centerY+g5+g6-15)fv[#fv+1]="</g>"end;local g9=g7;if cG then g9=fY(bG)end;local ga=20;local gb=d(g9)local gc=0;local gd=centerY+g5+g6+20;local ge=centerX;if g4~="YAW"then gd=fq(130)ge=fp(960)end;local gf=[[<path class="txttick line" d="]]for i=d(gb-(ga+10)-gb%5+0.5),d(gb+ga+10+gb%5+0.5),5 do local c7=ge+-i*5+g9*5;if i%10==0 then gc=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;fv[#fv+1]=c6(c7+5,gd-12,z)elseif i%5==0 then gc=5 end;if gc==10 then gf=e([[%s M %f %f v %d]],gf,c7,gd-5,gc)else gf=e([[%s M %f %f v %d]],gf,c7,gd-2.5,gc)end end;fv[#fv+1]=gf..[["/>]]fv[#fv+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ge-5,gd+10,ge+5,gd+10,ge,gd+5)if cG then g4="HDG"end;fv[#fv+1]=c6(ge,gd+25,gb.."deg","pdim txt txtmid","")fv[#fv+1]=c6(ge,gd+35,g4,"pdim txt txtmid","")end;local function gg(fv,gh,g3,centerX,centerY,cG,gi,e_)local g5=circleRad;local gj=d(g5*3/5)if g5>0 then local gk=d(gh)local len=0;local gf=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*g3,centerX,centerY)if not at then gf=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fv[#fv+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],g5-1,centerX,centerY)fv[#fv+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gk-30-gk%5+0.5),d(gk+30+gk%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local c8=centerY+-i*5+gh*5;if len==30 then gf=e([[%s M %d %f h %d]],gf,centerX-gj-len,c8,len)if at then fv[#fv+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*g3,centerX,centerY,centerX-gj+10,c8,i)fv[#fv+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*g3,centerX,centerY,centerX+gj-10,c8,i)if i==0 or i==180 or i==-180 then fv[#fv+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*g3,centerX,centerY,centerX-gj+20,c8,gj*2-40)end else fv[#fv+1]=c6(centerX-gj+10,c8,i,"pdim txt txtmid")fv[#fv+1]=c6(centerX+gj-10,c8,i,"pdim txt txtmid")end;gf=e([[%s M %d %f h %d]],gf,centerX+gj,c8,len)else gf=e([[%s M %d %f h %d]],gf,centerX-gj-len,c8,len)gf=e([[%s M %d %f h %d]],gf,centerX+gj,c8,len)end end;fv[#fv+1]=gf..[["/>]]local gl="PITCH"if not cG then gl="REL PITCH"end;if gh>90 and not at then gh=90-(gh-90)elseif gh<-90 and not at then gh=-90-(gh+90)end;if g5>200 then if at then if e_>P then fv[#fv+1]=c6(centerX,centerY-15,"Yaw","pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY+20,gi,"pdim txt txtmid")end;fv[#fv+1]=e([[<g transform="rotate(%f,%d,%d)">]],-g3,centerX,centerY)else fv[#fv+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fv[#fv+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gj+25,centerY-5,centerX-gj+20,centerY,centerX-gj+25,centerY+5,centerX-gj+50,centerY+4,gk)fv[#fv+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gj-25,centerY-5,centerX+gj-20,centerY,centerX+gj-25,centerY+5,centerX+gj-30,centerY+4,gk)fv[#fv+1]="</g>"end;local gm=d(g5/3)fv[#fv+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gm,centerY,g5-gm)if not at and cG then fv[#fv+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*g3,centerX,centerY,centerX-gj+10,centerY,gj*2-20)end;fv[#fv+1]="</g>"if g5<200 then if at and e_>P then fv[#fv+1]=c6(centerX,centerY-g5,gl,"pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY-g5+10,gk,"pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY-15,"Yaw","pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY+20,gi,"pdim txt txtmid")else fv[#fv+1]=c6(centerX,centerY-g5,gl,"pdim txt txtmid")fv[#fv+1]=c6(centerX,centerY-g5+15,gk,"pdim txt txtmid")end end end end;local function gn(fv,cz,cG)local go=altMeterX;local gp=altMeterY;local gq=78;local gr=19;local gs=d6()if gs~=-1 then fv[#fv+1]=c6(go+gq,gp+gr+20,e("AGL: %.1fm",gs),"pdim altsm txtend")end;if cG and(cz<200000 and not at or cz and at)then table.insert(fv,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],go-1,gp-4,gq+2,gr+6,go+1,gp-1,gq-4,gr))local cJ=0;local gt=1;local gu=0;local gv=cz<0;local gw=9;if gv then gw=0 end;local cz=c(cz)while cJ<6 do local gx=11;local gy=16;local gz=9;local gA=14;local ca="altsm"if cJ>2 then gy=gy+3;gx=gx+2;gA=gA+2;gz=gz-6;ca="altbig"end;if gv then ca=ca.." red"end;local gB=cz/gt%10;local gC=d(gB)local gD=d((gC+1)%10)local gE=gu;if cJ==0 then gE=gB-gC;if gv then gE=1-gE end end;if gv and(cJ==0 or gu~=0)then local gF=gD;gD=gC;gC=gF end;local gG=gy*(gE-1)local gH=gG+gy;local c7=go+gz+(6-cJ)*gx;local c8=gp+gA;fv[#fv+1]=c6(c7,c8+gG,gD,ca)fv[#fv+1]=c6(c7,c8+gH,gC,ca)cJ=cJ+1;gt=gt*10;if gC==gw then gu=gE else gu=0 end end;table.insert(fv,[[</g></g>]])end end;local function gI(f2)f2=vec3(f2)local gJ=-math.deg(n(f2.y,f2.z))+180;gJ=gJ-90;if gJ<0 then gJ=360+gJ end;if gJ>180 then gJ=-180+gJ-180 end;return-gJ end;local function gK(f2)f2=vec3(f2)local g9=math.deg(n(f2.y,f2.x))-90;if g9<-180 then g9=360+g9 end;return g9 end;local function gL(fv,f2,e_,centerX,centerY)if e_>5 and not at or e_>P then local g5=circleRad;local gM=20;local gN=20;local gO=vec3(f2)local gP=gI(gO)local gQ=gK(gO)local gR=14;local gS=gR/2;local gT=-gQ/gN*g5;local gU=gP/gM*g5;local c7=centerX+gT;local c8=centerY+gU;local aj=math.sqrt(gT^2+gU^2)local gV=[[<circle
                            cx="]]..c7 ..[["
                            cy="]]..c8 ..[["
                            r="]]..gS/gR..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c7 ..[["
                            cy="]]..c8 ..[["
                            r="]]..gS..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c7-gR..[[,]]..c8 ..[[ h ]]..gS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c7+gS..[[,]]..c8 ..[[ h ]]..gS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c7 ..[[,]]..c8-gR..[[ v ]]..gS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<g5 then fv[#fv+1]=gV else local fX=n(gU,gT)local gW=4;local gX=centerX+g5*math.cos(fX)local gY=centerY+g5*math.sin(fX)fv[#fv+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',fX*180/math.pi,gX,gY,gX-gW,gY-gW/2,gW*2,gW,gX+gW,gY-gW,gW,gW,-gW,gW)end;if not at then gP=gI(-gO)gQ=gK(-gO)gT=-gQ/gN*g5;gU=gP/gM*g5;c7=centerX+gT;c8=centerY+gU;aj=math.sqrt(gT^2+gU^2)if aj<g5 then local gZ=[[<circle
                                    cx="]]..c7 ..[["
                                    cy="]]..c8 ..[["
                                    r="]]..gS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c7 ..[[,]]..c8-gR..[[ v ]]..gS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c7 ..[[,]]..c8 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c7 ..[[,]]..c8 ..[[)" />
                                <path
                                    d="M ]]..c7-gS..[[,]]..c8 ..[[ h ]]..gR..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c7 ..[[,]]..c8 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c7 ..[[,]]..c8 ..[[)"/>]]fv[#fv+1]=gZ end end end end;local function g_(fv,ft,h0,h1)h0=d(h0+0.5)local fJ=throtPosY+10;local fK=throtPosY+20;if m()==1 and not RemoteHud then fJ=55;fK=65 end;local h2="CRUISE"local unit="km/h"local cd=h1;if ft=="TRAVEL"or ft=="AUTOPILOT"then h2="THROT"unit="%"cd=h0;local h3="dim"if h0<0 then h3="red"end;fv[#fv+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],h3,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(h0),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fv[#fv+1]=c6(throtPosX+10,fJ,h2,"pbright txtstart")fv[#fv+1]=c6(throtPosX+10,fK,e("%.0f %s",cd,unit),"pbright txtstart")if at and AtmoSpeedAssist and bQ and J then h0=d(K*100+0.5)local h3="red"if h0<0 then h3="red"end;fv[#fv+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],h3,1-c(h0),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fv[#fv+1]=c6(throtPosX+10,fJ+40,"LIMIT","pbright txtstart")fv[#fv+1]=c6(throtPosX+10,fK+40,h0 .."%","pbright txtstart")end;if at and AtmoSpeedAssist or Reentry then fv[#fv+1]=c6(throtPosX+10,fJ-40,"LIMIT: "..bo.." km/h","dim txtstart")elseif not at and Autopilot then fv[#fv+1]=c6(throtPosX+10,fJ-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function h4(fv,h5)local h6=throtPosY-10;local h7=throtPosX+10;fv[#fv+1]=c6(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then h6=75 end;fv[#fv+1]=c6(h7,h6,d(h5).." km/h","pbright txtbig txtstart")end;local function h8(fv)fv[#fv+1]=c6(fp(1900),fq(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fv[#fv+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fv[#fv+1]=c6(fp(960),fq(550),"Warning: Invalid Control Scheme Detected","warnings")fv[#fv+1]=c6(fp(960),fq(600),"Keyboard Scheme must be selected","warnings")fv[#fv+1]=c6(fp(960),fq(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local h9=fp(960)local ha=fq(860)local hb=fq(880)local hc=fq(900)local hd=fq(960)local he=fq(200)local hf=fq(150)local hg=fq(960)if m()==1 and not RemoteHud then ha=fq(135)hb=fq(155)hc=fq(175)he=fq(115)hf=fq(95)end;if BrakeIsOn then fv[#fv+1]=c6(h9,ha,"Brake Engaged","warnings")elseif I>0 then fv[#fv+1]=c6(h9,ha,"Auto-Brake Engaged","warnings","opacity:"..I)end;if at and bj and aq==-1 then fv[#fv+1]=c6(h9,he+50,"** STALL WARNING **","warnings")end;if ay then fv[#fv+1]=c6(h9,hg,"Gyro Enabled","warnings")end;if GearExtended then if R then fv[#fv+1]=c6(h9,hb,"Gear Extended","warn")else fv[#fv+1]=c6(h9,hb,"Landed (G: Takeoff)","warnings")end;local hh,cn=cj(a:getTargetGroundAltitude())fv[#fv+1]=c6(h9,hc,"Hover Height: "..hh..cn,"warn")end;if a6 then fv[#fv+1]=c6(h9,hd+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bO and AntigravTargetAltitude~=nil then if c(av-antigrav.getBaseAltitude())<501 then fv[#fv+1]=c6(h9,he+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fv[#fv+1]=c6(h9,he+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fv[#fv+1]=c6(h9,he+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fv[#fv+1]=c6(h9,he+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Z then fv[#fv+1]=c6(h9,he+20,"Follow Mode Engaged","warn")elseif Reentry then fv[#fv+1]=c6(h9,he+20,"Re-entry in Progress","warn")end;local hi,en,eo=b8:getPlanetarySystem(0):castIntersections(bM,bI:normalize(),function(eb)if eb.noAtmosphericDensityAltitude>0 then return eb.radius+eb.noAtmosphericDensityAltitude else return eb.radius+eb.surfaceMaxAltitude*1.5 end end)local hj=en;if eo~=nil and en~=nil then hj=math.min(eo,en)end;if AltitudeHold or VertTakeOff then local hh,cn=cj(HoldAltitude,2)if VertTakeOff then if bO then hh,cn=cj(antigrav.getBaseAltitude(),2)end;fv[#fv+1]=c6(h9,he,"VTO to "..hh..cn,"warn")elseif AutoTakeoff and not IntoOrbit then fv[#fv+1]=c6(h9,he,"Takeoff to "..hh..cn,"warn")if BrakeIsOn and not VertTakeOff then fv[#fv+1]=c6(h9,he+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fv[#fv+1]=c6(h9,he,"Altitude Hold: "..hh..cn,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if au>0.1 then fv[#fv+1]=c6(h9,he,"Beginning ascent","warn")elseif au<0.09 and au>0.05 then fv[#fv+1]=c6(h9,he,"Aligning trajectory","warn")elseif au<0.05 then fv[#fv+1]=c6(h9,he,"Leaving atmosphere","warn")end end;if IntoOrbit then if bq~=nil then fv[#fv+1]=c6(h9,he,bq,"warn")end end;if BrakeLanding then if StrongBrakes then fv[#fv+1]=c6(h9,he,"Brake-Landing","warnings")else fv[#fv+1]=c6(h9,he,"Coast-Landing","warnings")end end;if ProgradeIsOn then fv[#fv+1]=c6(h9,he,"Prograde Alignment","crit")end;if RetrogradeIsOn then fv[#fv+1]=c6(h9,he,"Retrograde Alignment","crit")end;if hj~=nil and au==0 then local hh,cn=cj(hj)local travelTime=b9.computeTravelTime(bJ,0,hj)local hk="Collision"if hi.noAtmosphericDensityAltitude>0 then hk="Atmosphere"end;fv[#fv+1]=c6(h9,hf,hi.name.." "..hk.." "..d1(travelTime).." In "..hh..cn,"crit")end;if VectorToTarget and not IntoOrbit then fv[#fv+1]=c6(h9,he+35,VectorStatus,"warn")end;fv[#fv+1]="</g>"return fv end;local function hl(e_)return d(y(e_*3.6,0)+0.5).." km/h"end;local function hm(fv)local hn=OrbitMapX;local ho=OrbitMapY;local hp=OrbitMapSize;local hq=4;local hr=15;local c7=0;local c8=0;local hs,ht,hu,hv;local function hw(type)local hx,bE,e_,hy;if type=="Periapsis"then hx=orbit.periapsis.altitude;bE=orbit.timeToPeriapsis;e_=orbit.periapsis.speed;hy=35 else hx=orbit.apoapsis.altitude;bE=orbit.timeToApoapsis;e_=orbit.apoapsis.speed;hy=-35 end;fv[#fv+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c7+hy,c8-5,hn+hp/2-hs+hv,c8-5)fv[#fv+1]=c6(c7,c8,type)c8=c8+hr;local hh,cn=cj(hx)fv[#fv+1]=c6(c7,c8,hh..cn)c8=c8+hr;fv[#fv+1]=c6(c7,c8,d1(bE))c8=c8+hr;fv[#fv+1]=c6(c7,c8,hl(e_))end;if orbit~=nil and au<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then ho=ho+hq;c7=hn+hp+hn/2+hq;c8=ho+hp/2+5+hq;hs=hp/4;hv=0;fv[#fv+1]=[[<g class="pbright txtorb txtmid">]]fv[#fv+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hp+hn*2,hp+ho,hq,hq)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hu=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hs*2)ht=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hu*(1-orbit.eccentricity)hv=hs-orbit.periapsis.altitude/hu-planet.radius/hu;local hz=""if orbit.periapsis.altitude<=0 then hz='redout'end;fv[#fv+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hz,hn+hp/2+hv+hq,ho+hp/2+hq,hs,ht)fv[#fv+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hn+hp/2+hq,ho+hp/2+hq,planet.radius/hu)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hw("Apoapsis")end;c8=ho+hp/2+5+hq;c7=hn-hn/2+10+hq;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hw("Periapsis")end;fv[#fv+1]=c6(hn+hp/2+hq,planet.name,20+hq,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hA=orbit.timeToApoapsis/orbit.period*2*math.pi;local hB=hs*math.cos(hA)local hC=ht*math.sin(hA)fv[#fv+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hn+hp/2+hB+hv+hq,ho+hp/2+hC+hq)end;fv[#fv+1]=[[</g>]]return fv else return fv end end;local function hD()if radarPanelID~=nil and am==0 then t(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then t(perisPanelID)perisPanelID=nil end else if am==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;am=0 end end;local function hE(fv)local c7=50;local c8=525;local hF={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hG={"Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to +1k over atmosphere and orbit to target","Alt-5: Lock Pitch at current pitch","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-9: Activate Gyroscope"}local hH={"Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at 1k over atmosphere","Alt-9: Activate Gyroscope"}local hI={"CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if at then bX(hF,hG)table.insert(hF,"---------------------------------------")if VertTakeOff then table.insert(hF,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if aq~=-1 then if antigrav then if bO then table.insert(hF,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hF,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hF,"Alt-6: Begins Vertical Takeoff.")else table.insert(hF,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hF,"G: Begin BrakeLanding or Land")end else bX(hF,hH)end;if AltitudeHold then table.insert(hF,"Alt-Spacebar/Alt-C will raise/lower target height")end;table.insert(hF,"---------------------------------------")bX(hF,hI)for i=1,#hF do c8=c8+12;fv[#fv+1]=c6(c7,c8,hF[i],"pdim txttick txtstart")end end;local hJ={}function hJ.HUDPrologue(fv)if not F then C=PvPR;E=PvPG;D=PvPB else C=SafeR;E=SafeG;D=SafeB end;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local hK=aA;local hL=aB;local hM=aA;local hN=aB;if fr()and not brightHud then hK=[[rgb(]]..d(C*0.4+0.5)..","..d(E*0.4+0.5)..","..d(D*0.3+0.5)..[[)]]hL=[[rgb(]]..d(C*0.3+0.5)..","..d(E*0.3+0.5)..","..d(D*0.2+0.5)..[[)]]end;fv[#fv+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],hK,hK,hM,hM,hL,hL,hN,hN,aK,aL)return fv end;function hJ.UpdateHud(fv)local cz=av;local f2=core.getVelocity()local e_=vec3(f2):len()local gJ=bR;local hO=bS;local g3=hO;local gh=bR;local h0=d(unit.getThrottle())local h5=e_*3.6;local h1=unit.getAxisCommandValue(0)local hP=fp(1770)local hQ=fq(310)if AtmoSpeedAssist and bQ then h1=H;h0=H*100 end;local ft=fs()local g4="ROLL"local cG=unit.getClosestPlanetInfluence()>0;if h0==nil then h0=0 end;if not cG then if e_>5 then gJ=gI(f2)hO=gK(f2)else gJ=0;hO=0 end;g4="YAW"end;if G>50000 and not at then local hR;if G>200000 then hR=y(G/200000,2).." su"else hR=y(G/1000,1).." km"end;fv[#fv+1]=c6(hP,hQ,"PvP Boundary: "..hR,"pbright txtbig txtmid")end;fv[#fv+1]=al;fv[#fv+1]=aF;fv[#fv+1]=ak;if b2%aX==0 then b1=true end;if fuelX~=0 and fuelY~=0 then fu(fv,b1,fuelX,"Atmospheric ","ATMO",aQ,a_,b0)fu(fv,b1,fuelX+100,"Space fuel t","SPACE",aR,aY,aZ)fu(fv,b1,fuelX+200,"Rocket fuel ","ROCKET",aS,aV,aW)end;if b1 then b1=false;b2=0 end;b2=b2+1;fW(fv,cz)if m()==0 or RemoteHud then if not fr()or brightHud then if cG then g2(fv,centerX,centerY,g3,g4,cG)gg(fv,gh,g3,centerX,centerY,cG,d(gK(f2)),e_)else g2(fv,centerX,centerY,hO,g4,cG)gg(fv,gJ,hO,centerX,centerY,cG,d(hO),e_)end;gn(fv,cz,cG)gL(fv,f2,e_,centerX,centerY)end end;g_(fv,ft,h0,h1)h4(fv,h5)h8(fv)hm(fv)if showHelp then hE(fv)end;return fv end;function hJ.HUDEpilogue(fv)fv[#fv+1]="</svg>"return fv end;function hJ.ExtraData(fv)local hS=fp(1240)local hT=fq(55)local hU=hT+10;local hV;local hW=0;local ft=fs()if VertTakeOffEngine then ft=ft.."-VERTICAL"end;if TurnBurn then ft="TB-"..ft end;local hX=vec3(core.getWorldAcceleration()):len()/9.80665;hV=planet:getGravity(planet.center+vec3(0,0,1)*planet.radius):len()fv[#fv+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then hS=fp(1120)hT=fq(55)hU=hT+10 elseif at then local hY=fp(770)fv[#fv+1]=c6(hY,hT,"ATMOSPHERE","pdim txt txtend")fv[#fv+1]=c6(hY,hU,e("%.2f",au),"pdim txt txtend","")end;fv[#fv+1]=c6(hS,hT,"GRAVITY","pdim txt txtend")fv[#fv+1]=c6(hS,hU,e("%.2f",hV/9.80665),"pdim txt txtend")fv[#fv+1]=c6(hS,hT+20,"ACCEL","pdim txt txtend")fv[#fv+1]=c6(hS,hU+20,e("%.2f",hX),"pdim txt txtend")fv[#fv+1]=c6(fp(960),fq(180),ft,"txtbig txtmid")end;function hJ.DrawOdometer(fv,ac,TotalDistanceTravelled,ad)local hV;local hZ=0;local h_=0;local hW=0;if at then hW=LastMaxBrakeInAtmo else hW=LastMaxBrake end;maxThrust=a:maxForceForward()aO=l()hV=planet:getGravity(planet.center+vec3(0,0,1)*planet.radius):len()if hV>0.1 then h_=aO*hV;hZ=maxThrust/hV end;fv[#fv+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fp(660),fp(700),fq(35),fp(960),fq(55),fp(1240),fq(35),fp(1280))if m()==0 or RemoteHud then fv[#fv+1]=c6(fp(700),fq(20),e("Trip: %.2f km",ac),"txtstart")fv[#fv+1]=c6(fp(700),fq(30),e("Lifetime: %.2f Mm",TotalDistanceTravelled/1000),"txtstart")fv[#fv+1]=c6(fp(830),fq(20),"Trip Time: "..d1(ad),"txtstart")fv[#fv+1]=c6(fp(830),fq(30),"Total Time: "..d1(TotalFlightTime),"txtstart")fv[#fv+1]=c6(fp(970),fq(20),e("Mass: %.2f Tons",aO/1000),"txtstart")fv[#fv+1]=c6(fp(1240),fq(10),e("Max Brake: %.2f kN",hW/1000),"txtend")fv[#fv+1]=c6(fp(1240),fq(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if hV>0.1 then fv[#fv+1]=c6(fp(970),fq(30),e("Max Mass: %.2f Tons",hZ/1000),"txtstart")fv[#fv+1]=c6(fp(1240),fq(20),e("Req Thrust: %.2f kN",h_/1000),"txtend")else fv[#fv+1]=c6(fp(970),fq(30),"Max Mass: n/a","txtstart")fv[#fv+1]=c6(fp(1240),fq(20),"Req Thrust: n/a","txtend")end end;fv[#fv+1]="</g>"return fv end;function hJ.DrawWarnings(fv)return h8(fv)end;function hJ.DisplayOrbitScreen(fv)return hm(fv)end;function hJ.DisplayMessage(fv,hh)if hh~="empty"then local c8=310;for i0 in string.gmatch(hh,"([^\n]+)")do c8=c8+35;fv[#fv+1]=c6("50%",c8,i0,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function hJ.DrawDeadZone(fv)fv[#fv+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function hJ.UpdateRadar()if radar_1 then local i1=radar_1.getEntries()local i2=radar_1.getData()local i3=fp(1770)local i4=fq(330)if#i1>0 then local i5=i2:find('identifiedConstructs":%[%]')if i5==nil and perisPanelID==nil then am=1;hD()end;if i5~=nil and perisPanelID~=nil then hD()end;if radarPanelID==nil then hD()end;ak=c6(i3,i4,"Radar: "..#i1 .." contacts","pbright txtbig txtmid")local i6={}for dc,dd in pairs(i1)do if radar_1.hasMatchingTransponder(dd)==1 then table.insert(i6,dd)end end;if#i6>0 then local c8=fq(15)local c7=fp(1370)ak=ak..c6(c7,c8,"Friendlies In Range","pbright txtbig txtmid")for dc,dd in pairs(i6)do c8=c8+20;ak=ak..c6(c7,c8,radar_1.getConstructName(dd),"pdim txtmid")end end else local i7;i7=i2:find('worksInEnvironment":false')if i7 then ak=c6(i3,i4,"Radar: Jammed","pbright txtbig txtmid")else ak=c6(i3,i4,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then am=0;hD()end end end end;function hJ.DrawSettings(fv)if#bU>0 then local c7=fp(640)local c8=fq(200)fv[#fv+1]=[[<g class="pbright txtvspd txtstart">]]for dc,dd in pairs(bU)do fv[#fv+1]=c6(c7,c8,dd..": ".._G[dd])c8=c8+20;if dc%12==0 then c7=c7+fp(350)c8=fq(200)end end;fv[#fv+1]=c6(fp(640),fq(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fv[#fv+1]="</g>"end;return fv end;return hJ end;local function i8()local function UpdateAtlasLocationsList()local function i9(ia,ib)return ia.name<ib.name end;bW={}for dc,dd in pairs(b3[0])do bW[#bW+1]={name=dd.name,index=dc}end;table.sort(bW,i9)end;local de={}function de.UpdateAtlasLocationsList()UpdateAtlasLocationsList()end;function de.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ab=nil;CustomTarget=nil;return true end;local ic=bW[AutopilotTargetIndex].index;local id=b3[0][ic]if id.center then AutopilotTargetName=id.name;ab=b8[0][ic]if CustomTarget~=nil then if au==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=id;for _,dd in pairs(b8[0])do if dd.name==CustomTarget.planetname then ab=dd;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ab.center)else AutopilotTargetCoords=CustomTarget.position end;if ab.planetname~="Space"then if ab.hasAtmosphere then AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=bb(ab):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function de.adjustAutopilotTargetIndex(f_)if not Autopilot and not VectorToTarget and not ao and not IntoOrbit then if f_==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bW then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bW end end;if AutopilotTargetIndex==0 then bd.UpdateAutopilotTarget()else local ic=bW[AutopilotTargetIndex].index;local id=b3[0][ic]if id.name=="Space"then if f_==nil then bd.adjustAutopilotTargetIndex()else bd.adjustAutopilotTargetIndex(1)end else bd.UpdateAutopilotTarget()end end else a1="Disengage autopilot before changing Interplanetary Helper"end end;function de.findAtlasIndex(ie)for dc,dd in pairs(ie)do if dd.name and dd.name==CustomTarget.name then return dc end end;return-1 end;for dc,dd in pairs(SavedLocations)do table.insert(b3[0],dd)end;UpdateAtlasLocationsList()de.UpdateAutopilotTarget()return de end;local function ig()local ih={}local function ii(ij)local dI=500000;local ik,il,im=math.huge;local io=false;local ip=vec3({13771471,7435803,-128971})local iq=18000000;ik=vec3(ij):dist(ip)if ik<iq then return true,c(ik-iq),"Safe Zone",0 end;il=vec3(ij):dist(vec3(planet.center))if il<dI then io=true end;if c(il-dI)<c(ik-iq)then return io,c(il-dI),planet.name,planet.bodyId else return io,c(ik-iq),"Safe Zone",0 end end;local function ir(is,it,iu)it=it:project_on_plane(is)iu=iu:project_on_plane(is)return n(it:cross(iu):dot(is),it:dot(iu))end;local function iv()local iw=-1;local ix=-1;if vBooster then iw=vBooster.distance()end;if hover then ix=hover.distance()end;if iw~=-1 and ix~=-1 then if iw<ix then return iw else return ix end elseif iw~=-1 then return iw elseif ix~=-1 then return ix else return-1 end end;function ih.APTick()at=j()>0;au=j()av=core.getAltitude()aq=iv()bE=q()bk=bE;if antigrav then bO=antigrav.getState()==1 end;local iy=1;local iz=1;local iA=bE-bk;local iB=-math.deg(ir(bF,bI,bG))local iC=math.deg(ir(bH,bI,bG))local f_=bK*-1;bj=at and iB<-YawStallAngle or iB>YawStallAngle or iC<-PitchStallAngle or iC>PitchStallAngle;local iD=system.getMouseDeltaX()local iE=system.getMouseDeltaY()if InvertMouse and not a0 then iE=-iE end;U=0;Y=0;T=0;sys=b8[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=bb(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bI)if av==0 then av=(bM-planet.center):len()-planet.radius end;local hV=planet:getGravity(core.getConstructWorldPos()):len()*l()bl=0;ba=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if not at then F,G,_,_=ii(bM)else F=true end;if x()==0 then if m()==1 and a0 then if not bf then ag=ag+iD;ah=ah+iE end else ag=0;ah=0 end else ag=ag+iD;ah=ah+iE;aj=math.sqrt(ag*ag+ah*ah)if not a0 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then U=U-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then U=U-(ag+DeadZone)*MouseXSensitivity else U=0 end;if ah>0 and ah>DeadZone then T=T-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then T=T-(ah+DeadZone)*MouseYSensitivity else T=0 end else ag=0;ah=0;if userControlScheme=="mouse"then T=(-utils.smoothstep(iE,-100,100)+0.5)*2*iy;U=(-utils.smoothstep(iD,-100,100)+0.5)*2*iz end end end end;local iF=bJ>8334;if bJ>SpaceSpeedLimit/3.6 and not at and not Autopilot and not iF then a1="Space Speed Engine Shutoff reached"cc(0)end;if not iF and LastIsWarping then if not BrakeIsOn then cM()end;if Autopilot then cE()end end;LastIsWarping=iF;if at and au>0.09 then if bJ>bo/3.6 and not AtmoSpeedAssist and not az then BrakeIsOn=true;az=true elseif not AtmoSpeedAssist and az then if bJ<bo/3.6 then BrakeIsOn=false;az=false end end end;if BrakeIsOn then X=1 else X=0 end;if ProgradeIsOn then if an then BrakeIsOn=false;local iG=false;if CustomTarget~=nil then iG=cN(CustomTarget.position-bM,0.01)else iG=cN(vec3(bI),0.01)end;bh=true;if iG and(c(bS)<2 or c(bR)>85)and bJ>=bo/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;Q=true;an=false;ap=true;Autopilot=false;cZ()elseif at and AtmoSpeedAssist then cc(1)else cf(d(bo))end elseif bJ>P then cN(vec3(bI),0.01)end end;if RetrogradeIsOn then if at then RetrogradeIsOn=false elseif bJ>P then cN(-vec3(bI))end end;if not ProgradeIsOn and an and not IntoOrbit then if au==0 then Q=true;cZ()an=false;ap=true else an=false;cE()end end;if ap and CustomTarget~=nil and(av<HoldAltitude+200 and av>HoldAltitude-200)and bJ*3.6>bo-100 and c(bL)<20 and au>=0.1 and(CustomTarget.position-bM):len()>2000+av then cE()ap=false end;if VertTakeOff then bh=true;local iH=HoldAltitude;if bL<-30 then a1="Unable to achieve lift. Safety Landing."af=0;bh=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bO or HoldAltitude<planet.spaceEngineMinAltitude then if bO then iH=antigrav.getBaseAltitude()end;if av<iH-100 then bp=0;af=15;BrakeIsOn=false elseif bL>0 then BrakeIsOn=true;af=0 elseif bL<-30 then BrakeIsOn=true;af=15 elseif av>=iH then if bO then if Autopilot or VectorToTarget then co()else BrakeIsOn=true;VertTakeOff=false end;a1="Takeoff complete. Singularity engaged"else BrakeIsOn=false;a1="VTO complete. Engaging Horizontal Flight"co()end;af=0 end else if au>0.08 then bp=0;BrakeIsOn=false;af=20 elseif au<0.08 and au>0 then BrakeIsOn=false;if bB then bp=0;af=20 else af=0;bp=36;cf(3500)end else bh=autoRollPreference;IntoOrbit=true;bz=false;CancelIntoOrbit=false;bt=false;br=nil;bs=nil;if by==nil then by=planet end;bx=iH;bw=true;VertTakeOff=false end end;if bp~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local iI=r(bp-bR,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(iI)local iJ=r(vTpitchPID:get(),-1,1)T=iJ end end;if IntoOrbit then local cW;local iK=false;local iL,iM=cj(bx)local iN=iL..iM;if by==nil then by=planet;if VectorToTarget then by=ab end end;if not bw then bx=math.floor(by.radius+by.surfaceMaxAltitude+1000)if by.hasAtmosphere then bx=math.floor(by.radius+by.noAtmosphericDensityAltitude+1000)end;bw=true end;if bv.VectorToTarget then cW=CustomTarget.position-bM end;local iO,iP=bb(by):escapeAndOrbitalSpeed((bM-by.center):len()-by.radius)local iQ=bS;if not bt then local iR=false;local iS=false;cc(0)bs=0;bq="Aligning to orbital path - OrbitHeight: "..iN;if bv.VectorToTarget then cN(cW:normalize():project_on_plane(bK))iK=bG:dot(cW:project_on_plane(bF):normalize())>0.95 else cN(bI)iK=iB<0.5;if bJ<150 then iK=true end end;T=0;br=0;if bR<=br+1 and bR>=br-1 then iR=true else iR=false end;if iQ<=bs+1 and iQ>=bs-1 then iS=true else iS=false end;if iR and iS and iK then br=nil;bs=nil;bt=true end else if bv.VectorToTarget then cN(cW:normalize():project_on_plane(bK))elseif bJ>150 then cN(bI)end;T=0;if bv.VectorToTarget then local a7,_=b9.computeDistanceAndTime(bJ,bo/3.6,l(),0,0,LastMaxBrake)if bz and cW:len()>15000+a7+av then bq="Orbiting to Target"if orbit.periapsis.altitude<by.noAtmosphericDensityAltitude then bz=false end elseif bz or cW:len()<15000+a7+av then a1="Orbit complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;Q=true;ap=true;bv.VectorToTarget,bv.AutopilotAlign=false,false;cp()cZ()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and av>bx*0.9 and av<bx*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bx*0.99 and orbit.apoapsis.altitude>=bx*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bz then if bz then BrakeIsOn=false;cc(0)br=0;if not bv.VectorToTarget then a1="Orbit complete"cp()end else bD=bD+1;if bD>=2 then bz=true end end else bq="Adjusting Orbit - OrbitHeight: "..iN;bu=true;cf(iP*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local iT=bL;local iU=av-bx;local iV=c(iU)if bL<10 and c(bR)<10 and iV<100 then iT=bL*2 end;if iT<10 and c(bR)<10 and iV<100 then iT=iT*2 end;if iT<5 and c(bR)<5 and iV<100 then iT=iT*4 end;VSpdPID:inject(iT)br=r(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(iU)br=r(br-r(OrbitAltPID:get(),-15,15),-90,90)end end else local iW=2.75;local iX=c(p(iO*iW))local iY=iX%50;if iY>0 then iX=iX-iY+50 end;BrakeIsOn=false;if av<bx*0.8 then bq="Escaping planet gravity - OrbitHeight: "..iN;br=utils.map(bL,200,0,-15,80)elseif av>=bx*0.8 and av<bx*1.15 then bq="Approaching orbital corridor - OrbitHeight: "..iN;iX=iX*0.75;br=utils.map(bL,100,-100,-15,65)elseif av>=bx*1.15 and av<bx*1.5 then bq="Approaching orbital corridor - OrbitHeight: "..iN;iX=iX*0.75;if bL<0 or bu then br=utils.map(av,bx*1.5,bx*1.01,-30,0)else br=utils.map(av,bx*0.99,bx*1.5,0,30)end elseif av>bx*1.5 then bq="Reentering orbital corridor - OrbitHeight: "..iN;br=-85;local iZ=utils.map(bL,-150,-400,1,0.55)iX=iX*iZ end;cf(d(iX))end end;if br~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local i_=br-bR;OrbitPitchPID:inject(i_)local j0=r(OrbitPitchPID:get(),-0.5,0.5)T=j0 end end;if Autopilot and au==0 and not an then local j1,j2=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local j3=(CustomTarget.position-ab.center):normalize()local j4=j3:project_on_plane((ab.center-bM):normalize()):normalize()local j5=ab.center+j4*(ab.radius+AutopilotTargetOrbit)local j6=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))if(bM-j5):len()<(bM-j6):len()then j1=j5;AutopilotTargetCoords=j1 else j1=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))AutopilotTargetCoords=j1 end;cs(ab,AutopilotTargetCoords)j2=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;j2=true;TargetSet=true;AutopilotRealigned=true;j1=CustomTarget.position+(bM-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local j3=(bM+bI*100000-ab.center):normalize()local j4=j3:project_on_plane((ab.center-bM):normalize()):normalize()if j4:len()<1 then j3=(bM+bG*100000-ab.center):normalize()j4=j3:project_on_plane((ab.center-bM):normalize()):normalize()end;j1=ab.center+j4*(ab.radius+AutopilotTargetOrbit)AutopilotTargetCoords=j1;TargetSet=true;j2=true;AutopilotRealigned=true;cs(ab,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(j1)-bM):len()local hi,en,eo=b8:getPlanetarySystem(0):castIntersections(bM,bI:normalize(),function(eb)if eb.noAtmosphericDensityAltitude>0 then return eb.radius+eb.noAtmosphericDensityAltitude else return eb.radius+eb.surfaceMaxAltitude*1.5 end end)local hj=en;if eo~=nil and en~=nil then hj=math.min(eo,en)end;if hj~=nil and hj<AutopilotDistance and hi.name==ab.name then AutopilotDistance=hj end;local iG=true;local j7=(ab.center-(bM+vec3(bI):normalize()*AutopilotDistance)):len()-ab.radius;local hh,cn=cj(j7)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hh..'", "unit":"'..cn..'"}')local a7,a8;if not TurnBurn then a7,a8=GetAutopilotBrakeDistanceAndTime(bJ)else a7,a8=GetAutopilotTBBrakeDistanceAndTime(bJ)end;if bJ>300 and AutopilotAccelerating then local cW=vec3(j1)-bM;local j8=r(math.deg(ir(bF,bI:normalize(),cW:normalize()))*bJ/500,-90,90)local j9=r(math.deg(ir(bH,bI:normalize(),cW:normalize()))*bJ/500,-90,90)if c(j8)<20 and c(j9)<20 then j8=j8*2;j9=j9*2 end;if c(j8)<2 and c(j9)<2 then j8=j8*2;j9=j9*2 end;local iB=-math.deg(ir(bF,bG,bI:normalize()))local iC=-math.deg(ir(bH,bG,bI:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(j9-iC)local ja=r(apPitchPID:get(),-1,1)T=T+ja;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(j8-iB)local jb=r(apYawPID:get(),-1,1)U=U+jb;j2=true;if c(j8)>2 or c(j9)>2 then AutopilotStatus="Adjusting Trajectory"else AutopilotStatus="Accelerating"end end;if j7<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=bb(ab):escapeAndOrbitalSpeed(j7)end end;if not AutopilotCruising and not AutopilotBraking and not j2 then iG=cN((j1-bM):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then iG=cN(-vec3(bI):normalize())end;if AutopilotAccelerating then if not O then BrakeIsOn=false;cc(AutopilotInterplanetaryThrottle)H=y(AutopilotInterplanetaryThrottle,2)O=true end;local jc=unit.getThrottle()if AtmoSpeedAssist then jc=H end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or jc==0 and O then AutopilotAccelerating=false;AutopilotStatus="Cruising"AutopilotCruising=true;cc(0)end;if AutopilotDistance<=a7 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true;cc(0)O=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;X=1 end;if TurnBurn then cc(1,true)end;local _,iP=bb(ab):escapeAndOrbitalSpeed((bM-planet.center):len()-planet.radius)local cW;if CustomTarget~=nil then cW=CustomTarget.position-bM end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bJ<50 then a1="Autopilot complete, arrived at space location"AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bJ<=iP and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cc(0)O=false;ProgradeIsOn=true;an=true;cs(ab,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 then AutopilotStatus="Circularizing"local _,iP=bb(ab):escapeAndOrbitalSpeed((bM-planet.center):len()-planet.radius)if bJ<=iP then if CustomTarget~=nil then if bI:normalize():dot(cW:normalize())>0.4 then AutopilotStatus="Orbiting to Target"if not WaypointSet then BrakeIsOn=false;cs(ab,CustomTarget.position)WaypointSet=true end else a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cc(0)O=false;ProgradeIsOn=true;an=true;BrakeIsOn=false;cs(ab,CustomTarget.position)WaypointSet=false end else BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"a1="Autopilot completed, orbit established"X=0;cc(0)O=false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then ProgradeIsOn=true;an=true end end end end elseif AutopilotCruising then if AutopilotDistance<=a7 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true end;local jc=unit.getThrottle()if AtmoSpeedAssist then jc=H end;if jc>0 then AutopilotAccelerating=true;AutopilotStatus="Accelerating"AutopilotCruising=false end else if iG then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not an then AutopilotTargetCoords=vec3(ab.center)+(AutopilotTargetOrbit+ab.radius)*bH;AutopilotShipUp=bF;AutopilotShipRight=bH end;AutopilotRealigned=true elseif iG then AutopilotAccelerating=true;AutopilotStatus="Accelerating"if not O then cc(AutopilotInterplanetaryThrottle,true)H=y(AutopilotInterplanetaryThrottle,2)O=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and au>0)then a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"X=0;cc(0)O=false;ProgradeIsOn=true;an=true;cs(ab,CustomTarget.position)end;if Z then bh=true;local j9=0;local f3=bM+vec3(unit.getMasterPlayerRelativePosition())local jd=f3-bM;local je=vec3(jd):project_on(bG):len()local jf=vec3(jd):project_on(bH):len()local aj=math.sqrt(je*je+jf*jf)cN(jd:normalize())local jg=40;local jh=aj<jg;local ji=100;local jj=r((aj-jg)/2,10,ji)T=0;local iG=c(U)<0.1;if iG and bJ<jj and not jh then BrakeIsOn=false;j9=-20 else BrakeIsOn=true;j9=0 end;local jk=0;if c(j9-bR)>jk then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(j9-bR)local ja=pitchPID:get()T=ja end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local cG=unit.getClosestPlanetInfluence()>0;local jl=HoldAltitude-av;local jm=500+bJ;local jn=1;if AutoTakeoff then jn=r(bJ/100,0.1,1)end;local j9=(utils.smoothstep(jl,-jm,jm)-0.5)*2*MaxPitch*jn;if not Reentry and not an and not VectorToTarget and bG:dot(bI:normalize())<0.99 then j9=(utils.smoothstep(jl,-jm*r(20-19*au*10,1,20),jm*r(20-19*au*10,1,20))-0.5)*2*MaxPitch*r(2-au*10,1,2)*jn end;if not AltitudeHold then j9=0 end;if LockPitch~=nil then if cG and not IntoOrbit then j9=LockPitch else LockPitch=nil end end;bh=true;local jo=T;if Reentry then local jp=d(bo)local jq,jr=b9.computeDistanceAndTime(bJ,jp/3.6,l(),0,0,LastMaxBrake-planet.gravity*9.8*l())local js=av-(planet.noAtmosphericDensityAltitude+5000)if not bQ and av>planet.noAtmosphericDensityAltitude+5000 and bJ<=jp/3.6 and bJ>jp/3.6-10 and c(bI:normalize():dot(bG))>0.9 then cc(0)elseif bQ and(jq>-1 and js<=jq or av<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cf(jp,true)if not Q then j9=-80;if au>0.02 then a1="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;j9=0;bh=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and av>planet.noAtmosphericDensityAltitude+5000 then bh=true elseif av<=planet.noAtmosphericDensityAltitude+5000 then cf(jp)if not bQ and s:getTargetSpeed(axisCommandId.longitudinal)==bo then Q=false;Reentry=false;bh=true end end end;if bJ>P and not ao and not VectorToTarget and not BrakeLanding and ForceAlignment then cN(vec3(bI))end;if(VectorToTarget or ao)and AutopilotTargetIndex>0 and au>0.01 then local cW;if CustomTarget~=nil then cW=CustomTarget.position-bM else cW=ab.center-bM end;local j8=math.deg(ir(bK:normalize(),bI,cW))*2;local jt=math.rad(c(bS))if bJ>minRollVelocity and au>0.01 then local ju=r(90-j9*2,-90,90)bl=r(j8*2,-ju,ju)local jv=j8;j8=r(r(j8,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jt)+4*(bR-j9)*math.sin(math.rad(bS)),-YawStallAngle*0.80,YawStallAngle*0.80)j9=r(r(j9*math.cos(jt),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(r(c(jv)*math.sin(jt),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bl=0;j8=r(j8,-YawStallAngle*0.80,YawStallAngle*0.80)end;local jw=iB-j8;if not bj and bJ>minRollVelocity and au>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(jw)local jb=r(yawPID:get(),-1,1)U=U+jb elseif at and aq>-1 or bJ<minRollVelocity then cN(cW)elseif bj and au>0.01 then if(iB<-YawStallAngle or iB>YawStallAngle)and au>0.01 then cN(bI)end;if(iC<-PitchStallAngle or iC>PitchStallAngle)and au>0.01 then j9=r(bR-iC,bR-PitchStallAngle*0.80,bR+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ao then local iH=planet:getAltitude(CustomTarget.position)local js=math.sqrt(cW:len()^2-(av-iH)^2)local jx=LastMaxBrakeInAtmo;if jx then jx=jx*r(bJ/100,0.1,1)*au else jx=LastMaxBrake end;if au<0.01 then jx=LastMaxBrake end;local jy=bI:len()-c(bL)local jz=vec3(core.getWorldAirFrictionAcceleration())local jA=math.sqrt(jz:len()-jz:project_on(f_):len())*l()if bJ>100 then a7,a8=b9.computeDistanceAndTime(bJ,100,l(),0,0,jx+jA)local jB,jC=b9.computeDistanceAndTime(100,0,l(),0,0,jx/2)a7=a7+jB else a7,a8=b9.computeDistanceAndTime(bJ,0,l(),0,0,jx/2)end;StrongBrakes=true;if not ao and not Reentry and js<=a7+bJ*iA/2 and(bI:project_on_plane(bK):normalize():dot(cW:project_on_plane(bK):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cc(0)if AltitudeHold then cq()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(jy<0.1 or js<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<js)then if not bO then BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"end;LastDistanceToTarget=js end elseif VectorToTarget and au==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ao or Reentry)then if CustomTarget~=nil and ab.name==planet.name then local cW=CustomTarget.position-bM;local iH=planet:getAltitude(CustomTarget.position)local js=math.sqrt(cW:len()^2-(av-iH)^2)local jx=LastMaxBrakeInAtmo;if jx then a7,a8=b9.computeDistanceAndTime(bJ,0,l(),0,0,jx/2)StrongBrakes=true;if js<=a7+bJ*iA/2 and bI:project_on_plane(bK):normalize():dot(cW:project_on_plane(bK):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;Q=true;an=false;ap=true;Autopilot=false;cZ()end end;LastDistanceToTarget=js end end end;if au==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ao or IntoOrbit or Reentry)then if not bz and not IntoOrbit then bx=HoldAltitude;bw=true;if VectorToTarget then bv.VectorToTarget=true end;cp()VectorToTarget=false;bt=true end end;if bj and au>0.01 and aq==-1 and bJ>minRollVelocity and VectorStatus~="Finalizing Approach"then cN(bI)j9=r(bR-iC,bR-PitchStallAngle*0.80,bR+PitchStallAngle*0.80)end;T=jo;local d7=-1;if BrakeLanding then j9=0;local jD=false;local jE=30;if ba~=nil and ba>0 then local jA=0;local jF=r(au,0.4,2)local jx=LastMaxBrakeInAtmo*r(bJ/100,0.1,1)*jF;local jG=ba*jF+jx+jA-hV;local jH=jx/2+jA-hV;local jI=bJ-math.sqrt(c(jH/2)*20/(0.5*l()))*utils.sign(jH)if jI<0 then jI=0 end;local jJ;if bJ>100 then local jK,_=b9.computeDistanceAndTime(bJ,100,l(),0,0,jx)local jL,_=b9.computeDistanceAndTime(100,0,l(),0,0,math.sqrt(jx))jJ=jK+jL else jJ=b9.computeDistanceAndTime(bJ,0,l(),0,0,math.sqrt(jx))end;if jJ<20 then BrakeIsOn=false else local jM=0;if jI>100 then local jN,_=b9.computeDistanceAndTime(jI,100,l(),0,0,jG)local jO,_=b9.computeDistanceAndTime(100,0,l(),0,0,ba*jF+math.sqrt(jx)+jA-hV)jM=jN+jO else jM,_=b9.computeDistanceAndTime(jI,0,l(),0,0,ba*jF+math.sqrt(jx)+jA-hV)end;jM=(jM+15+bJ*iA)*1.1;local jP=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if jP then local iH=planet:getAltitude(CustomTarget.position)local jQ=av-iH-100;local cW=CustomTarget.position-bM;local jR=math.sqrt(cW:len()^2-(av-iH)^2)if jR>100 then jP=false elseif jQ<=jM or jM==-1 then BrakeIsOn=true;jD=true else BrakeIsOn=false;jD=true end end;if not jP and CalculateBrakeLandingSpeed then if jM>=jE then BrakeIsOn=true else BrakeIsOn=false end;jD=true end end end;if not bQ then cc(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)d7=aq;if d7>-1 then bh=autoRollPreference;if bJ<1 or bI:normalize():dot(bK)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bI:normalize():dot(-f_)<0.999 then BrakeIsOn=true elseif bL<-brakeLandingRate and not jD then BrakeIsOn=true elseif not jD then BrakeIsOn=false end end;if AutoTakeoff or ao then local hi,eo,en;if AutopilotTargetCoords~=nil then hi,eo,en=b8:getPlanetarySystem(0):castIntersections(bM,(AutopilotTargetCoords-bM):normalize(),function(eb)return eb.radius+eb.noAtmosphericDensityAltitude end)end;if bO then if av>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cc(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(j9)<15 and av/HoldAltitude>0.75 then AutoTakeoff=false;if not ao then if bQ and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ao and bJ<P then Autopilot=true;ao=false;AltitudeHold=false;AutoTakeoff=false;cc(0)elseif ao then cc(0)BrakeIsOn=true end elseif ao and au==0 and ab~=nil and(hi==nil or hi.name==ab.name)then Autopilot=true;ao=false;AltitudeHold=false;AutoTakeoff=false;if not bQ then cc(0)end;AutopilotAccelerating=true end end;local jS=aq>-1;local jT=bR;if(VectorToTarget or ao)and not jS and bJ>minRollVelocity and au>0.01 then local jt=math.rad(c(bS))jT=bR*c(math.cos(jt))+iC*math.sin(jt)end;local jU=r(j9-jT,-PitchStallAngle*0.80,PitchStallAngle*0.80)if au<0.01 and VectorToTarget then jU=r(j9-jT,-85,MaxPitch)elseif au<0.01 then jU=r(j9-jT,-MaxPitch,MaxPitch)end;if c(bS)<5 or VectorToTarget or BrakeLanding or jS or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(jU)local ja=pitchPID:get()T=T+ja end end;if antigrav~=nil and(antigrav and not ExternalAGG and av<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;aq=iv()return ih end;function script.onStart()local coreOffset=16;local function jV()local function jW(jX)local jY=dbHud_1.hasKey;for dc,dd in pairs(jX)do if jY(dd)then local cm=f(dbHud_1.getStringValue(dd))if cm~=nil then _G[dd]=cm;aM=true end end end end;if dbHud_1 then local jY=dbHud_1.hasKey;if not useTheseSettings then jW(b_())coroutine.yield()jW(b)else jW(b)a1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;aM=false end;coroutine.yield()if aM then a1="Loaded Saved Variables"M=y(ResolutionX/2,0)N=y(ResolutionY/2,0)aK=ResolutionX;aL=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bh=autoRollPreference;bo=AtmoSpeedLimit;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]elseif not useTheseSettings then a1="No Saved Variables Found - Exit HUD to save settings"end else a1="No databank found. Attach one to control unit and rerun the autoconfigure to save preferences and locations"end;if LastStartTime+180<bE then LastMaxBrakeInAtmo=0 end;LastStartTime=bE;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a1="Invalid User Control Scheme selected.  Change userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=5 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=av end;antigrav.setBaseAltitude(AntigravTargetAltitude)end end;local function jZ()local function j_(k0,k1)if k0>k1 then k1=k0 end;if ContainerOptimization>0 then k1=k1-k1*ContainerOptimization*0.05 end;if FuelTankOptimization>0 then k1=k1-k1*FuelTankOptimization*0.05 end;return k1 end;local k2=core.getElementNameById;local k3=fuelX~=0 and fuelY~=0;for dc in pairs(aw)do local type=core.getElementTypeById(aw[dc])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(aw[dc])),'^.*vertical.*$')then bN=true end end;if o(type,'^.*Space Engine$')then bC=true;if o(tostring(core.getElementTagsById(aw[dc])),'^.*vertical.*$')then local k4=core.getElementRotationById(aw[dc])if k4[4]<0 then if p(-k4[4],0.1)==0.5 then bA=true end else if p(k4[4],0.1)==0.5 then bB=true end end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local k5=h(aw[dc])if k5>10000 then coreOffset=128 elseif k5>1000 then coreOffset=64 elseif k5>150 then coreOffset=32 end end;aT=aT+h(aw[dc])if k3 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local k5=h(aw[dc])local k6=k(aw[dc])local k0=0;local fS=q()if type=="Atmospheric Fuel Tank"then local k1=400;local k7=35.03;if k5>10000 then k1=51200;k7=5480 elseif k5>1300 then k1=6400;k7=988.67 elseif k5>150 then k1=1600;k7=182.67 end;k0=k6-k7;if fuelTankHandlingAtmo>0 then k1=k1+k1*fuelTankHandlingAtmo*0.2 end;k1=j_(k0,k1)aQ[#aQ+1]={aw[dc],k2(aw[dc]),k1,k7,k0,fS}end;if type=="Rocket Fuel Tank"then local k1=320;local k7=173.42;if k5>65000 then k1=40000;k7=25740 elseif k5>6000 then k1=5120;k7=4720 elseif k5>700 then k1=640;k7=886.72 end;k0=k6-k7;if fuelTankHandlingRocket>0 then k1=k1+k1*fuelTankHandlingRocket*0.1 end;k1=j_(k0,k1)aS[#aS+1]={aw[dc],k2(aw[dc]),k1,k7,k0,fS}end;if type=="Space Fuel Tank"then local k1=2400;local k7=182.67;if k5>10000 then k1=76800;k7=5480 elseif k5>1300 then k1=9600;k7=988.67 end;k0=k6-k7;if fuelTankHandlingSpace>0 then k1=k1+k1*fuelTankHandlingSpace*0.2 end;k1=j_(k0,k1)aR[#aR+1]={aw[dc],k2(aw[dc]),k1,k7,k0,fS}end end end;if not bN then VertTakeOff,VertTakeOffEngine=false,false end end;local function k8()if gyro~=nil then ay=gyro.getState()==1 end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(at or not at and av<10000)then for _,dd in pairs(door)do dd.toggle()end end;if switch then for _,dd in pairs(switch)do dd.toggle()end end;if forcefield and(at or not at==0 and av<10000)then for _,dd in pairs(forcefield)do dd.toggle()end end;if antigrav then bO=antigrav.getState()==1;if bO and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if R then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;local k9=d6()if k9~=-1 or not at and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;if not R then GearExtended=true end else BrakeIsOn=false end;if bi~=nil then s:setTargetGroundAltitude(bi)if bi==0 and not R then GearExtended=true;BrakeIsOn=true end else bi=a:getTargetGroundAltitude()if GearExtended then s:setTargetGroundAltitude(LandingGearGroundHeight)else s:setTargetGroundAltitude(TargetHoverHeight)end end;if at and k9~=-1 then ba=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=at end;local function ka(kb,kc,kd,ke,c7,c8,kf,kg,kh,ki)local kj={enableName=kb,disableName=kc,width=kd,height=ke,x=c7,y=c8,toggleVar=kf,toggleFunction=kg,drawCondition=kh,hovered=false}if ki then table.insert(aJ,kj)else table.insert(aI,kj)end;return kj end;local function kk(kl)if not bT then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif kl=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif kl=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif kl=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bU=b_(kl)showHud=false else bU={}showHud=true end end;local function km()bT=not bT;if bT then aH=aJ;a1="Hold SHIFT to see Settings"bV=showHud else aH=aI;a1="Hold SHIFT to see Control Buttons"kk()showHud=bV end end;local function kn(dd)_G[dd]=not _G[dd]if _G[dd]then a1=dd.." set to true"else a1=dd.." set to false"end;if dd=="showHud"then bV=_G[dd]elseif dd=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function ko()local kp=50;local kq=340;local c7=500;local c8=aL/2-400;local kr=0;for dc,dd in pairs(b_("boolean"))do if type(_G[dd])=="boolean"then ka(dd,dd,kq,kp,c7,c8,function()return _G[dd]end,function()kn(dd)end,function()return true end,true)c8=c8+kp+20;if kr==7 then c7=c7+kq+20;c8=aL/2-400;kr=0 else kr=kr+1 end end end;ka("Control View","Control View",kq,kp,10,aL/2-500,function()return true end,km,function()return true end,true)ka("View Handling Settings",'Hide Handling Settings',kq,kp,10,aL/2-(500-kp),function()return showHandlingVariables end,function()kk("handling")end,function()return true end,true)ka("View Hud Settings",'Hide Hud Settings',kq,kp,10,aL/2-(500-kp*2),function()return showHudVariables end,function()kk("hud")end,function()return true end,true)ka("View Physics Settings",'Hide Physics Settings',kq,kp,10,aL/2-(500-kp*3),function()return showPhysicsVariables end,function()kk("physics")end,function()return true end,true)end;local function ks()local function kt()if dbHud_1 then local position=bM;local fL=planet.name..". "..#SavedLocations;if radar_1 then local dU,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dU~=nil and dU~=""then fL=fL.." "..radar_1.getConstructName(dU)end end;local cK={}cK={position=position,name=fL,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cK;table.insert(b3[0],cK)bd.UpdateAtlasLocationsList()a1="Location saved as "..fL else a1="Databank must be installed to save locations"end end;local function ku()TurnBurn=not TurnBurn end;local function kv(kw)if kw==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Z=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kx()kv(1)end;local function ky()local cJ=-1;cJ=bd.findAtlasIndex(b3[0])if cJ>-1 then table.remove(b3[0],cJ)end;cJ=-1;cJ=bd.findAtlasIndex(SavedLocations)if cJ~=-1 then a1=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cJ)end;bd.adjustAutopilotTargetIndex()bd.UpdateAtlasLocationsList()end;local function kz()local fL=AutopilotTargetName;if fL==nil then local hh,cn=cj((bM-CustomTarget.position):len())fL=CustomTarget.name.." "..hh..cn end;if fL==nil then fL="None"end;return"Engage Autopilot: "..fL end;local function kA()local fL=AutopilotTargetName;if fL==nil then fL=CustomTarget.name end;if fL==nil then fL="None"end;return"Disable Autopilot: "..fL end;local kp=50;local kq=260;local kB=ka("Enable Brake Toggle","Disable Brake Toggle",kq,kp,aK/2-kq/2,aL/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a1="Brakes in Toggle Mode"else a1="Brakes in Default Mode"end end)ka("Align Prograde","Disable Prograde",kq,kp,aK/2-kq/2-50-kB.width,aL/2-kp+380,function()return ProgradeIsOn end,kx)ka("Align Retrograde","Disable Retrograde",kq,kp,aK/2-kq/2+kB.width+50,aL/2-kp+380,function()return RetrogradeIsOn end,kv,function()return au==0 end)local kC=ka(kz,kA,600,60,aK/2-600/2,aL/2-60/2-400,function()return Autopilot end,cE)ka("Save Position","Save Position",200,kC.height,kC.x+kC.width+30,kC.y,function()return false end,kt,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)ka("Update Position","Update Position",200,kC.height,kC.x+kC.width+30,kC.y,function()return false end,cH,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ka("Clear Position","Clear Position",200,kC.height,kC.x-200-30,kC.y,function()return true end,ky,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kp=60;kq=300;local c7=10;local c8=aL/2-500;ka("Show Help","Hide Help",kq,kp,c7,c8,function()return showHelp end,function()showHelp=not showHelp end)c8=c8+kp+20;ka("View Settings","View Settings",kq,kp,c7,c8,function()return true end,km)local c8=aL/2-300;ka("Enable Turn and Burn","Disable Turn and Burn",kq,kp,c7,c8,function()return TurnBurn end,ku)ka("Horizontal Takeoff Mode","Vertical Takeoff Mode",kq,kp,c7+kq+20,c8,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a1="Vertical Takeoff Mode"else a1="Horizontal Takeoff Mode"end end,function()return bN end)c8=c8+kp+20;ka("Show Orbit Display","Hide Orbit Display",kq,kp,c7,c8,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a1="Orbit Display Enabled"else a1="Orbit Display Disabled"end end)ka("Engage Orbiting","Cancel Orbiting",kq,kp,c7+kq+20,c8,function()return IntoOrbit end,cp,function()return au==0 and unit.getClosestPlanetInfluence()>0 end)c8=c8+kp+20;ka("Glide Re-Entry","Cancel Glide Re-Entry",kq,kp,c7,c8,function()return Reentry end,function()an=true;kx()end,function()return planet.hasAtmosphere and not at end)ka("Parachute Re-Entry","Cancel Parachute Re-Entry",kq,kp,c7+kq+20,c8,function()return Reentry end,cZ,function()return planet.hasAtmosphere and not at end)c8=c8+kp+20;ka("Engage Follow Mode","Disable Follow Mode",kq,kp,c7,c8,function()return Z end,cr,function()return m()==1 end)ka("Enable Repair Arrows","Disable Repair Arrows",kq,kp,c7+kq+20,c8,function()return aU end,function()aU=not aU;if aU then a1="Repair Arrows Enabled"else a1="Repair Arrows Diabled"end end,function()return m()==1 end)c8=c8+kp+20;if not ExternalAGG then ka("Enable AGG","Disable AGG",kq,kp,c7,c8,function()return bO end,d0,function()return antigrav~=nil end)end;c8=c8+kp+20;ka(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,kq*2,kp,c7,c8,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end end)end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})jV()coroutine.yield()jZ()coroutine.yield()be=ig()k8()ko()ks()aH=aI;coroutine.yield()b3=de()b7=df()b8=b7(de())b9=ex()bb=f1()bc=fo()bd=i8()be=ig()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)if UseSatNav then unit.setTimer("fiveSecond",5)end end)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(au>0 or au==0 and av<10000)then for _,dd in pairs(door)do dd.toggle()end end;if switch then for _,dd in pairs(switch)do dd.toggle()end end;if forcefield and(au>0 or au==0 and av<10000)then for _,dd in pairs(forcefield)do dd.toggle()end end;d8()if button then button.activate()end;if SetWaypointOnExit then cs(planet,bM)end end;function script.onTick(kD)local function GetAutopilotBrakeDistanceAndTime(e_)if not at then return b9.computeDistanceAndTime(e_,AutopilotEndSpeed,l(),0,0,LastMaxBrake-AutopilotPlanetGravity*l())else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b9.computeDistanceAndTime(e_,AutopilotEndSpeed,l(),0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*l())else return 0,0 end end end;local function GetAutopilotTBBrakeDistanceAndTime(e_)return b9.computeDistanceAndTime(e_,AutopilotEndSpeed,l(),a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*l())end;if kD=="tenthSecond"then local function kE()local kF=system.createData;local kG=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=kG(panelInterplanetary,"value")interplanetaryHeaderText=kF('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=kG(panelInterplanetary,"value")widgetDistanceText=kF('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=kG(panelInterplanetary,"value")widgetTravelTimeText=kF('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=kG(panelInterplanetary,"value")widgetMaxMassText=kF('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=kG(panelInterplanetary,"value")widgetTargetOrbitText=kF('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=kG(panelInterplanetary,"value")widgetCurBrakeDistanceText=kF('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=kG(panelInterplanetary,"value")widgetCurBrakeTimeText=kF('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=kG(panelInterplanetary,"value")widgetMaxBrakeDistanceText=kF('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=kG(panelInterplanetary,"value")widgetMaxBrakeTimeText=kF('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=kG(panelInterplanetary,"value")widgetTrajectoryAltitudeText=kF('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not at then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function kH()t(panelInterplanetary)panelInterplanetary=nil end;local function kI()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ab.center-bM):len()else AutopilotDistance=(CustomTarget.position-bM):len()end end;local e_=bJ;local jc=unit.getThrottle()/100;if AtmoSpeedAssist then jc=H end;local kJ,kK=b9.computeDistanceAndTime(bJ,MaxGameVelocity,l(),a:maxForceForward()*jc,warmup,0)local a7,a8;if not TurnBurn then a7,a8=GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,kL;if not TurnBurn and e_>0 then _,kL=GetAutopilotBrakeDistanceAndTime(e_)else _,kL=GetAutopilotTBBrakeDistanceAndTime(e_)end;local kM=0;local kN=0;if AutopilotCruising or not Autopilot and e_>5 then kN=b9.computeTravelTime(e_,0,AutopilotDistance)elseif a7+kJ<AutopilotDistance then kM=AutopilotDistance-(a7+kJ)kN=b9.computeTravelTime(8333.0556,0,kM)else local kO=(AutopilotDistance-a7)/kJ;kJ=AutopilotDistance-a7;kK=kK*kO end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return kN elseif AutopilotBraking then return kL elseif AutopilotCruising then return kN+kL else return kK+a8+kN end end;local function kP()local kQ=LastMaxBrakeInAtmo/ab:getGravity(ab.center+vec3(0,0,1)*ab.radius):len()return kQ end;if au>0 and not WasInAtmo then if not bQ and AtmoSpeedAssist and(AltitudeHold or Reentry)then cc(1)L=false end end;if bP~=nil then if s:getTargetSpeed(axisCommandId.longitudinal)~=bP then cf(bP,TRUE)else bP=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then kE()end;if AutopilotTargetName~=nil then local kR=CustomTarget~=nil;planetMaxMass=kP()u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=kI()if kR and not Autopilot then aj=(bM-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bM):len()end;if not TurnBurn then a7,a8=GetAutopilotBrakeDistanceAndTime(bJ)a9,aa=GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=GetAutopilotTBBrakeDistanceAndTime(bJ)a9,aa=GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hh,cn=cj(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..hh..'", "unit":"'..cn..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d1(travelTime)..'", "unit":""}')hh,cn=cj(a7)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hh..'", "unit":"'..cn..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d1(a8)..'", "unit":""}')hh,cn=cj(a9)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hh..'", "unit":"'..cn..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d1(aa)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",planetMaxMass/1000)..'", "unit":" Tons"}')hh,cn=cj(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..e("%.2f",hh)..'", "unit":"'..cn..'"}')if au>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if au==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else kH()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif kD=="oneSecond"then local function kS(hV,kT)if hV==nil then hV=core.g()end;hV=y(hV,5)if kT~=nil and kT or(aP==nil or aP~=hV)then local f2=core.getVelocity()local e_=vec3(f2):len()local kU=f(unit.getData()).maxBrake;if kU~=nil and kU>0 and at then kU=kU/r(e_/100,0.1,1)kU=kU/au;if au>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+kU)/2 else LastMaxBrakeInAtmo=kU end end end;if kU~=nil and kU>0 then LastMaxBrake=kU end;aP=hV end end;local function kV(fv)local kW=0;aF=""local kX=aT;local kY=0;local kZ=0;local k_=0;local fU=0;local fV=""local l0=core.getElementHitPointsById;for dc in pairs(aw)do local k5=0;local l1=0;l1=h(aw[dc])k5=l0(aw[dc])kY=kY+k5;if k5<l1 then if k5==0 then k_=k_+1 else kZ=kZ+1 end;if aU and#aC==0 then position=vec3(core.getElementPositionById(aw[dc]))local c7=position.x-coreOffset;local c8=position.y-coreOffset;local l2=position.z-coreOffset;table.insert(aC,core.spawnArrowSticker(c7,c8,l2+1,"down"))table.insert(aC,core.spawnArrowSticker(c7,c8,l2+1,"down"))core.rotateSticker(aC[2],0,0,90)table.insert(aC,core.spawnArrowSticker(c7+1,c8,l2,"north"))table.insert(aC,core.spawnArrowSticker(c7+1,c8,l2,"north"))core.rotateSticker(aC[4],90,90,0)table.insert(aC,core.spawnArrowSticker(c7-1,c8,l2,"south"))table.insert(aC,core.spawnArrowSticker(c7-1,c8,l2,"south"))core.rotateSticker(aC[6],90,-90,0)table.insert(aC,core.spawnArrowSticker(c7,c8-1,l2,"east"))table.insert(aC,core.spawnArrowSticker(c7,c8-1,l2,"east"))core.rotateSticker(aC[8],90,0,90)table.insert(aC,core.spawnArrowSticker(c7,c8+1,l2,"west"))table.insert(aC,core.spawnArrowSticker(c7,c8+1,l2,"west"))core.rotateSticker(aC[10],-90,0,90)table.insert(aC,aw[dc])end elseif aU and#aC>0 and aC[11]==aw[dc]then for fN in pairs(aC)do core.deleteSticker(aC[fN])end;aC={}end end;kW=d(kY/kX*100)if kW<100 then fv[#fv+1]=c6(0,0,"","pbright txt")fU=d(kW*2.55)fV=e("rgb(%d,%d,%d)",255-fU,fU,0)if kW<100 then fv[#fv+1]=c6("50%",1035,"Elemental Integrity: "..kW.."%","txtbig txtmid","fill:"..fV)if k_>0 then fv[#fv+1]=c6("50%",1055,"Disabled Modules: "..k_.." Damaged Modules: "..kZ,"txtbig txtmid","fill:"..fV)elseif kZ>0 then fv[#fv+1]=c6("50%",1055,"Damaged Modules: "..kZ,"txtbig txtmid","fill:"..fV)end end end end;local function l3()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function l4()local fS=q()local h5=bJ;local l5=fS-ax;if h5>1.38889 then h5=h5/1000;local l6=h5*(fS-ax)TotalDistanceTravelled=TotalDistanceTravelled+l6;ac=ac+l6 end;ad=ad+l5;TotalFlightTime=TotalFlightTime+l5;ax=fS end;ar=false;kS(nil,true)l4()bc.UpdateRadar()l3()local fv={}bc.ExtraData(fv)if ShowOdometer then fv=bc.DrawOdometer(fv,ac,TotalDistanceTravelled,ad)end;if ShouldCheckDamage then kV(fv)end;al=table.concat(fv,"")collectgarbage("collect")elseif kD=="fiveSecond"then as=dbHud_1.getStringValue("SPBAutopilotTargetName")if as~=nil and as~=""and as~="SatNavNotChanged"then local cm=f(dbHud_1.getStringValue("SavedLocations"))if cm~=nil then _G["SavedLocations"]=cm;local cJ=-1;local cK;for dc,dd in pairs(SavedLocations)do if dd.name and dd.name=="SatNav Location"then cJ=dc;break end end;if cJ~=-1 then cK=SavedLocations[cJ]cJ=-1;for dc,dd in pairs(b3[0])do if dd.name and dd.name=="SatNav Location"then cJ=dc;break end end;if cJ>-1 then b3[0][cJ]=cK end;UpdateAtlasLocationsList()a1=cK.name.." position updated"end end;for i=1,#bW do if bW[i].name==as then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bW[i].name)bd.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif kD=="msgTick"then local fv={}bc.DisplayMessage(fv,"empty")a1="empty"unit.stopTimer("msgTick")ai=3 elseif kD=="animateTick"then bg=true;bf=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif kD=="hudTick"then local function l7(fv)local l8=d(r(aj/(aK/4)*255,0,255))fv[#fv+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,d(C+0.5)+l8,d(E+0.5)-l8,d(D+0.5)-l8)end;local function l9()for _,dd in pairs(aH)do if dd.hovered then if not dd.drawCondition or dd.drawCondition()then dd.toggleFunction()end;dd.hovered=false end end end;local function la()local function lb(lc,ld,c7,c8,kd,ke)if lc>c7 and lc<c7+kd and ld>c8 and ld<c8+ke then return true else return false end end;local c7=ag+aK/2;local c8=ah+aL/2;for _,dd in pairs(aH)do dd.hovered=lb(c7,c8,dd.x,dd.y,dd.width,dd.height)end end;local function le(fv)local function lf(fv,lg,hover,c7,c8,eT,lh,li,lj,lk,ll)if type(lk)=="function"then lk=lk()end;if type(ll)=="function"then ll=ll()end;fv[#fv+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c7,c8,eT,lh)if lg then fv[#fv+1]=e("%s'",li)else fv[#fv+1]=lj end;if hover then fv[#fv+1]=" style='stroke:white; stroke-width:2'"else fv[#fv+1]=" style='stroke:black; stroke-width:1'"end;fv[#fv+1]="></rect>"fv[#fv+1]=e("<text x='%f' y='%f' font-size='24' fill='",c7+eT/2,c8+lh/2+5)if lg then fv[#fv+1]="black"else fv[#fv+1]="white"end;fv[#fv+1]="' text-anchor='middle' font-family='Montserrat'>"if lg then fv[#fv+1]=e("%s</text>",lk)else fv[#fv+1]=e("%s</text>",ll)end end;local lm="rgb(50,50,50)'"local ln="rgb(210,200,200)"local lo=lf;for _,dd in pairs(aH)do local kc=dd.disableName;local kb=dd.enableName;if type(kc)=="function"then kc=kc()end;if type(kb)=="function"then kb=kb()end;if not dd.drawCondition or dd.drawCondition()then lo(fv,dd.toggleVar(),dd.hovered,dd.x,dd.y,dd.width,dd.height,ln,lm,kc,kb)end end end;local fv={}bc.HUDPrologue(fv)if showHud then bc.UpdateHud(fv)else bc.DisplayOrbitScreen(fv)bc.DrawWarnings(fv)end;if bT and bU~={}then bc.DrawSettings(fv)end;bc.HUDEpilogue(fv)fv[#fv+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aK,aL)if a1~="empty"then bc.DisplayMessage(fv,a1)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then bc.DrawDeadZone(fv)end end;if x()==0 then if m()==1 and a0 then la()le(fv)if not bf and not bg then local lp=table.concat(fv,"")fv={}fv[#fv+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fv[#fv+1]=lp;fv[#fv+1]="</body>"bf=true;fv[#fv+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fv,"")system.setScreen(content)elseif bg then local lp=table.concat(fv,"")fv={}fv[#fv+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fv[#fv+1]=lp;fv[#fv+1]="</body>"end;if not bf then fv[#fv+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],M,N,ag,ah)end else l9()end else if not a0 and m()==0 then l9()if aj>DeadZone then if DisplayDeadZone then l7(fv)end end else la()le(fv)end;fv[#fv+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],M,N,ag,ah)end;fv[#fv+1]=[[</svg></body>]]content=table.concat(fv,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif kD=="apTick"then be.APTick()end end;function script.onFlush()local function lq(lr,jj)local ls=vec3()local lt=vec3()if lr==axisCommandId.longitudinal then ls=vec3(core.getConstructOrientationForward())lt=bG elseif lr==axisCommandId.vertical then ls=vec3(core.getConstructOrientationUp())lt=bF elseif lr==axisCommandId.lateral then ls=vec3(core.getConstructOrientationRight())lt=bH else return vec3()end;local lu=vec3(core.getWorldGravity())local lv=lu:dot(lt)local lw=vec3(core.getWorldAirFrictionAcceleration())local lx=lw:dot(lt)local ly=vec3(core.getVelocity())local lz=ly:dot(ls)local lA=jj*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(lA-lz)local lB=targetSpeedPID2:get()local lC=(lB-lx-lv)*lt;return lC end;local function lD(lr,jj)local ls=vec3()local lt=vec3()if lr==axisCommandId.longitudinal then ls=vec3(core.getConstructOrientationForward())lt=bG elseif lr==axisCommandId.vertical then ls=vec3(core.getConstructOrientationUp())lt=bF elseif lr==axisCommandId.lateral then ls=vec3(core.getConstructOrientationRight())lt=bH else return vec3()end;local lu=vec3(core.getWorldGravity())local lv=lu:dot(lt)local lw=vec3(core.getWorldAirFrictionAcceleration())local lx=lw:dot(lt)local ly=vec3(core.getVelocity())local lz=ly:dot(ls)local lA=jj*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(lA-lz)local lB=targetSpeedPID:get()local lC=(lB-lx-lv)*lt;return lC end;local function lE(lF,fZ,ib)local lG=lF:cross(ib):normalize_inplace()local gJ=math.acos(r(lG:dot(-fZ),-1,1))*constants.rad2deg;if lG:cross(-fZ):dot(ib)<0 then gJ=-gJ end;return gJ end;if antigrav and not ExternalAGG then if not bO and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bQ=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bQ and L then cc(0)L=false elseif not bQ and not L then H=0;L=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local lH=r(S+T+system.getControlDeviceForwardInput(),-1,1)local lI=r(V+Y+system.getControlDeviceYawInput(),-1,1)local lJ=r(W+U-system.getControlDeviceLeftRightInput(),-1,1)local lK=X;bK=vec3(core.getWorldVertical())if bK==nil or bK:len()==0 then bK=(planet.center-bM):normalize()end;bM=vec3(core.getConstructWorldPos())bF=vec3(core.getConstructWorldOrientationUp())bG=vec3(core.getConstructWorldOrientationForward())bH=vec3(core.getConstructWorldOrientationRight())bI=vec3(core.getWorldVelocity())bJ=vec3(bI):len()bL=-bK:dot(bI)bS=getRoll(bK,bG,bH)local lL=bS/180*math.pi;local lM=math.cos(lL)local lN=math.sin(lL)bR=lE(bK,bG,bH*lM+bF*lN)local lO=bI:normalize()local lP=getRoll(bK,bG,bH)local lQ=c(lP)local lR=utils.sign(lP)local lS=vec3(core.getWorldAngularVelocity())local lT=lH*pitchSpeedFactor*bH+lI*rollSpeedFactor*bG+lJ*yawSpeedFactor*bF;if bK:len()>0.01 and(au>0.0 or ProgradeIsOn or Reentry or an or AltitudeHold or IntoOrbit)then if bh==true and c(bl-lP)>autoRollRollThreshold and lI==0 and c(bR)<85 then local lU=bl;local lV=autoRollFactor;if au==0 then lV=lV/4;bl=0;lU=0 end;if rollPID==nil then rollPID=pid.new(lV*0.01,0,lV*0.1)end;rollPID:inject(lU-lP)local lW=rollPID:get()lT=lT+lW*bG end end;if bK:len()>0.01 and au>0.0 then local lX=20.0;if turnAssist==true and lQ>lX and lH==0 and lJ==0 then local lY=turnAssistFactor*0.1;local lZ=turnAssistFactor*0.025;local l_=(lQ-lX)/(180-lX)*180;local m0=0;if l_<90 then m0=l_/90 elseif l_<180 then m0=(180-l_)/90 end;m0=m0*m0;local m1=-lR*lZ*(1.0-m0)local m2=lY*m0;lT=lT+m2*bH+m1*bF end end;local m3=1;local m4=0;local m5=1;if system.getMouseWheel()>0 then if AltIsOn then if au>0 or Reentry then bo=r(bo+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end else H=y(r(H+speedChangeLarge/100,-1,1),2)end elseif system.getMouseWheel()<0 then if AltIsOn then if au>0 or Reentry then bo=r(bo-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end else H=y(r(H-speedChangeLarge/100,-1,1),2)end end;I=0;if at and AtmoSpeedAssist and bQ then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bo/3.6-bI:dot(bG))local m6=throttlePID:get()K=r(m6,-1,1)if K<H and au>0.005 then J=true;s:setThrottleCommand(axisCommandId.longitudinal,r(K,0.01,1))else J=false;s:setThrottleCommand(axisCommandId.longitudinal,H)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bI:len()-bo/3.6)local m7=r(brakePID:get(),0,1)if au>0 and bL<-80 or au>0.005 then I=m7 end;if I>0 then if J and K==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else K=r(K,0.01,1)end;local m8=''local m9=vec3()local ma=lq(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",ma,m4)local mb='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then mb=mb..ExtraLongitudeTags end;local mc=s:getAxisCommandType(axisCommandId.longitudinal)local md=s:composeAxisAccelerationFromThrottle(mb,axisCommandId.longitudinal)local me=lD(axisCommandId.lateral,LeftAmount*1000)m8=m8 ..' , '.."lateral airfoil , lateral ground "m9=m9+me;if m9:len()>constants.epsilon then a:setEngineForceCommand(m8,m9,m4,'','','',m5)end;a:setEngineForceCommand(mb,md,m3)local mf='thrust analog vertical fueled 'local mg='thrust analog lateral fueled 'if ExtraLateralTags~="none"then mg=mg..ExtraLateralTags end;if ExtraVerticalTags~="none"then mf=mf..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mf,ma,m3)else a:setEngineForceCommand(mf,vec3(),m3)end;if LeftAmount~=0 then a:setEngineForceCommand(mg,me,m3)else a:setEngineForceCommand(mg,vec3(),m3)end;if lK==0 then lK=I end;local mh=-lK*(brakeSpeedFactor*bI+brakeFlatFactor*lO)a:setEngineForceCommand('brake',mh)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,H)end;local jj=unit.getAxisCommandValue(0)if not bQ then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bI:len()-jj/3.6)local m7=r(brakePID:get(),0,1)lK=r(lK+m7,0,1)end;local mh=-lK*(brakeSpeedFactor*bI+brakeFlatFactor*lO)a:setEngineForceCommand('brake',mh)local m8=''local m9=vec3()local mi=false;local mb='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then mb=mb..ExtraLongitudeTags end;local mc=s:getAxisCommandType(axisCommandId.longitudinal)if mc==axisCommandType.byThrottle then local md=s:composeAxisAccelerationFromThrottle(mb,axisCommandId.longitudinal)a:setEngineForceCommand(mb,md,m3)elseif mc==axisCommandType.byTargetSpeed then local md=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)m8=m8 ..' , '..mb;m9=m9+md;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then mi=true end end;local mg='thrust analog lateral 'if ExtraLateralTags~="none"then mg=mg..ExtraLateralTags end;local mj=s:getAxisCommandType(axisCommandId.lateral)if mj==axisCommandType.byThrottle then local mk=s:composeAxisAccelerationFromThrottle(mg,axisCommandId.lateral)a:setEngineForceCommand(mg,mk,m3)elseif mj==axisCommandType.byTargetSpeed then local me=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)m8=m8 ..' , '..mg;m9=m9+me end;local mf='thrust analog vertical 'if ExtraVerticalTags~="none"then mf=mf..ExtraVerticalTags end;local ml=s:getAxisCommandType(axisCommandId.vertical)if ml==axisCommandType.byThrottle then local ma=s:composeAxisAccelerationFromThrottle(mf,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mf,ma,m3,'airfoil','ground','',m5)else a:setEngineForceCommand(mf,vec3(),m3)a:setEngineForceCommand('airfoil vertical',ma,m3,'airfoil','','',m5)a:setEngineForceCommand('ground vertical',ma,m3,'ground','','',m5)end elseif ml==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),m3)end;local mm=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)m8=m8 ..' , '..mf;m9=m9+mm end;if m9:len()>constants.epsilon then if X~=0 or mi or c(lO:dot(bG))<0.8 then m8=m8 ..', brake'end;a:setEngineForceCommand(m8,m9,m4,'','','',m5)end end;local mn=torqueFactor*(lT-lS)local mo=vec3(core.getWorldAirFrictionAngularAcceleration())mn=mn-mo;a:setEngineTorqueCommand('torque',mn,m3,'airfoil','','',m5)a:setBoosterCommand('rocket_engine')if a6 and not VanillaRockets then local e_=vec3(core.getVelocity()):len()local mp=0.15;if not bQ then local mq=s:getTargetSpeed(axisCommandId.longitudinal)if e_*3.6>mq*(1-mp)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e_*3.6<mq*(1-mp)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jc=unit.getThrottle()if AtmoSpeedAssist then jc=H*100 end;local jj=jc/100;if j==0 then jj=jj*MaxGameVelocity;if e_>=jj*(1-mp)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e_<jj*(1-mp)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jp=d(bo)jj=jj*jp/3.6;if e_>=jj*(1-mp)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e_<jj*(1-mp)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local _,cm=coroutine.resume(beginSetup)if cm then SetupComplete=true end else a:update()if not bf and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(mr)local B=1;local function ms(mt)if mt then B=-1 end;if not ExternalAGG and bO then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bx=bx+B*a2;if bx<planet.noAtmosphericDensityAltitude then bx=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a2 end else s:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function mu(mt)if mt then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then H=r(H+B*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if mt then B=1 else B=nil end;bd.adjustAutopilotTargetIndex(B)end end;if mr=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cc(0)if(vBooster or hover)and aq==-1 then StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bh=true;GearExtended=false else BrakeIsOn=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end;if R and not BrakeLanding then a.control.extendLandingGears()end else if R then a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif mr=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif mr=="forward"then S=S-1 elseif mr=="backward"then S=S+1 elseif mr=="left"then V=V-1 elseif mr=="right"then V=V+1 elseif mr=="yawright"then W=W-1 elseif mr=="yawleft"then W=W+1 elseif mr=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif mr=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif mr=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif mr=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif mr=="groundaltitudeup"then ms()elseif mr=="groundaltitudedown"then ms(true)elseif mr=="option1"then bd.adjustAutopilotTargetIndex()toggleView=false elseif mr=="option2"then bd.adjustAutopilotTargetIndex(1)toggleView=false elseif mr=="option3"then local function mv()aG=not aG;if not aG then unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;mv()toggleView=false elseif mr=="option4"then cE()toggleView=false elseif mr=="option5"then local function mw()if LockPitch==nil then LockPitch=bR;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else LockPitch=nil end end;mw()toggleView=false elseif mr=="option6"then cq()toggleView=false elseif mr=="option7"then toggleView=false elseif mr=="option8"then cr()toggleView=false elseif mr=="option9"then if gyro~=nil then gyro.toggle()ay=gyro.getState()==1 end;toggleView=false elseif mr=="lshift"then if x()==1 then a0=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a0=true;bg=false;bf=false end elseif mr=="brake"then if BrakeToggleStatus then cM()elseif not BrakeIsOn then cM()else BrakeIsOn=true end elseif mr=="lalt"then AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif mr=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a6 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a6=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a6=false end elseif mr=="stopengines"then local function mx()if ar then ar=false;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Z=false;O=false;an=false;ao=false;Q=false;bh=autoRollPreference;VectorToTarget=false;TurnBurn=false;ay=false;LockPitch=nil;IntoOrbit=false else ar=true end end;s:resetCommand(axisCommandId.longitudinal)mx()H=0 elseif mr=="speedup"then mu()elseif mr=="speeddown"then mu(true)elseif mr=="antigravity"and not ExternalAGG then if antigrav~=nil then d0()end end end;function script.onActionStop(mr)local function my()if not ExternalAGG and bO then a5=a3 end;if AltitudeHold or VertTakeOff or IntoOrbit then a4=a2 end end;if mr=="forward"then S=0 elseif mr=="backward"then S=0 elseif mr=="left"then V=0 elseif mr=="right"then V=0 elseif mr=="yawright"then W=0 elseif mr=="yawleft"then W=0 elseif mr=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif mr=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif mr=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mr=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mr=="groundaltitudeup"then my()toggleView=false elseif mr=="groundaltitudedown"then my()toggleView=false elseif mr=="lshift"then if x()==1 then a0=false;ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a0=false;bg=false;bf=false end elseif mr=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cM()else BrakeIsOn=false end end elseif mr=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(mr)local B=1;local function mz(mt)if mt then B=-1 end;if not ExternalAGG and bO then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a5=a5*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bx=bx+B*a4;if bx<planet.noAtmosphericDensityAltitude then bx=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a4 end;a4=a4*1.05 else s:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function mA(mt)if mt then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then H=r(H+B*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if mr=="groundaltitudeup"then mz()elseif mr=="groundaltitudedown"then mz(true)elseif mr=="speedup"then mA()elseif mr=="speeddown"then mA(true)end end;function script.onInputText(c9)local function mB()for dc,dd in pairs(b_())do dbHud_1.setStringValue(dd,g(nil))end;for dc,dd in pairs(b)do if dd~="SavedLocations"then dbHud_1.setStringValue(dd,g(nil))end end;a1="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5;aM=false;ae=true end;local function mC(mD,planet,f3)local function mE(f3)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dG,dH,cA,cB,cz=o(f3,dt)if dG=="0"and dH=="0"then return vec3(tonumber(cA),tonumber(cB),tonumber(cz))end;cB=math.rad(cB)cA=math.rad(cA)local planet=b3[tonumber(dG)][tonumber(dH)]local eu=math.cos(cA)local mF=vec3(eu*math.cos(cB),eu*math.sin(cB),math.sin(cA))return planet.center+(planet.radius+cz)*mF end;if dbHud_1 then local cK={}local position=mE(f3)if planet.name=="Space"then cK={position=position,name=mD,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cK={position=position,name=mD,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;SavedLocations[#SavedLocations+1]=cK;table.insert(b3[0],cK)bd.UpdateAtlasLocationsList()else a1="Databank must be installed to save locations"end end;local i;local mG="/commands /setname /G /agg /addlocation /copydatabank /wipedatabank"local mH,mI=nil,nil;local mJ="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all updatable variables with /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572} - adds a saved location by waypoint, not as accurate as making one at location\n".."/copydatabank - copies dbHud databank to a blank databank\n/wipedatabank - wipes the databank of all hud variables but not save variables"i=string.find(c9," ")mH=c9;if i~=nil then mH=string.sub(c9,0,i-1)mI=string.sub(c9,i+1)end;if mH=="/help"or mH=="/commands"then for i0 in string.gmatch(mJ,"([^\n]+)")do system.print(i0)end;return elseif mH=="/setname"then if mI==nil or mI==""then a1="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cH(mI)else a1="Select a saved target to rename first"end elseif mH=="/addlocation"then if mI==nil or mI==""or string.find(mI,"::")==nil then a1="Usage: ah-addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572}"return end;i=string.find(mI,"::")local mD=string.sub(mI,1,i-2)local f3=string.sub(mI,i)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dG,dH,cA,cB,cz=o(f3,dt)local planet=b3[tonumber(dG)][tonumber(dH)]mC(mD,planet,f3)a1="Added "..mD.." to saved locations,\nplanet "..planet.name.." at "..f3;ai=5 elseif mH=="/agg"then if mI==nil or mI==""then a1="Usage: ah-agg targetheight"return end;mI=tonumber(mI)if mI<1000 then mI=1000 end;AntigravTargetAltitude=mI;a1="AGG Target Height set to "..mI elseif mH=="/G"then if mI==nil or mI==""then a1="Usage: ah-G VariableName variablevalue\nah-G dump - shows all variables"return end;if mI=="dump"then for dc,dd in pairs(b_())do if type(_G[dd])=="boolean"then if _G[dd]==true then system.print(dd.." true")else system.print(dd.." false")end elseif _G[dd]==nil then system.print(dd.." nil")else system.print(dd.." ".._G[dd])end end;return end;i=string.find(mI," ")local mK=string.sub(mI,0,i-1)local mL=string.sub(mI,i+1)for dc,dd in pairs(b_())do if dd==mK then a1="Variable "..mK.." changed to "..mL;local mM=type(_G[dd])if mM=="number"then mL=tonumber(mL)elseif mM=="boolean"then if string.lower(mL)=="true"then mL=true else mL=false end end;_G[dd]=mL;return end end;a1="No such global variable: "..mK elseif mH=="/copydatabank"then if dbHud_2 then d8(true)else a1="Spare Databank required to copy databank"end elseif mH=="/wipedatabank"then if dbHud_1 then mB()else a1="No databank found."end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
