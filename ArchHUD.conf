name: ArchHud - Archaegeo v0.716 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.716;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J=true;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(L)t=L end,get=function()return t end},AtmoSpeedAssist={set=function(L)u=L end,get=function()return u end},ForceAlignment={set=function(L)v=L end,get=function()return v end},DisplayDeadZone={set=function(L)w=L end,get=function()return w end},showHud={set=function(L)x=L end,get=function()return x end},hideHudOnToggleWidgets={set=function(L)y=L end,get=function()return y end},ShiftShowsRemoteButtons={set=function(L)z=L end,get=function()return z end},SetWaypointOnExit={set=function(L)A=L end,get=function()return A end},AlwaysVSpd={set=function(L)B=L end,get=function()return B end},BarFuelDisplay={set=function(L)C=L end,get=function()return C end},voices={set=function(L)D=L end,get=function()return D end},alerts={set=function(L)E=L end,get=function()return E end},CollisionSystem={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},SaveStartingLocation={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1050;W=30000;X=1000;Y=50;Z=0;_=100000;a0=8333.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=90;a9={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)a0=L end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(L)a1=L end,get=function()return a1 end},warmup={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingSpace={set=function(L)a4=L end,get=function()return a4 end},fuelTankHandlingRocket={set=function(L)a5=L end,get=function()return a5 end},ContainerOptimization={set=function(L)a6=L end,get=function()return a6 end},FuelTankOptimization={set=function(L)a7=L end,get=function()return a7 end},AutoShieldPercent={set=function(L)a8=L end,get=function()return a8 end}}aa=1920;ab=1080;ac=400;ad=130;ae=224;af=255;ag=255;ah=0;ai=0;aj=960;ak=540;al=1300;am=540;an=1525;ao=325;ap=550;aq=540;ar=30;as=700;at=1750;au=250;av=50;aw=250;ax=0;ay=30;az=100;aA={ResolutionX={set=function(L)aa=L end,get=function()return aa end},ResolutionY={set=function(L)ab=L end,get=function()return ab end},circleRad={set=function(L)ac=L end,get=function()return ac end},SafeR={set=function(L)ad=L end,get=function()return ad end},SafeG={set=function(L)ae=L end,get=function()return ae end},SafeB={set=function(L)af=L end,get=function()return af end},PvPR={set=function(L)ag=L end,get=function()return ag end},PvPG={set=function(L)ah=L end,get=function()return ah end},PvPB={set=function(L)ai=L end,get=function()return ai end},centerX={set=function(L)aj=L end,get=function()return aj end},centerY={set=function(L)ak=L end,get=function()return ak end},throtPosX={set=function(L)al=L end,get=function()return al end},throtPosY={set=function(L)am=L end,get=function()return am end},vSpdMeterX={set=function(L)an=L end,get=function()return an end},vSpdMeterY={set=function(L)ao=L end,get=function()return ao end},altMeterX={set=function(L)ap=L end,get=function()return ap end},altMeterY={set=function(L)aq=L end,get=function()return aq end},fuelX={set=function(L)ar=L end,get=function()return ar end},fuelY={set=function(L)as=L end,get=function()return as end},shieldX={set=function(L)at=L end,get=function()return at end},shieldY={set=function(L)au=L end,get=function()return au end},DeadZone={set=function(L)av=L end,get=function()return av end},OrbitMapSize={set=function(L)aw=L end,get=function()return aw end},OrbitMapX={set=function(L)ax=L end,get=function()return ax end},OrbitMapY={set=function(L)ay=L end,get=function()return ay end},soundVolume={set=function(L)az=L end,get=function()return az end}}aB=5;aC=1;aD=0.003;aE=0.003;aF=2;aG=1.5;aH=180;aI=150;aJ=0.002;aK=2;aL=0.8;aM=1;aN=3;aO=1;aP=40;aQ=0.0166667;aR=0.0666667;aS=0.0;aT="none"aU="none"aV="none"aW={speedChangeLarge={set=function(L)aB=L end,get=function()return aB end},speedChangeSmall={set=function(L)aC=L end,get=function()return aC end},MouseXSensitivity={set=function(L)aD=L end,get=function()return aD end},MouseYSensitivity={set=function(L)aE=L end,get=function()return aE end},autoRollFactor={set=function(L)aF=L end,get=function()return aF end},rollSpeedFactor={set=function(L)aG=L end,get=function()return aG end},autoRollRollThreshold={set=function(L)aH=L end,get=function()return aH end},minRollVelocity={set=function(L)aI=L end,get=function()return aI end},TrajectoryAlignmentStrength={set=function(L)aJ=L end,get=function()return aJ end},torqueFactor={set=function(L)aK=L end,get=function()return aK end},pitchSpeedFactor={set=function(L)aL=L end,get=function()return aL end},yawSpeedFactor={set=function(L)aM=L end,get=function()return aM end},brakeSpeedFactor={set=function(L)aN=L end,get=function()return aN end},brakeFlatFactor={set=function(L)aO=L end,get=function()return aO end},DampingMultiplier={set=function(L)aP=L end,get=function()return aP end},apTickRate={set=function(L)aQ=L end,get=function()return aQ end},hudTickRate={set=function(L)aR=L end,get=function()return aR end},ExtraEscapeThrust={set=function(L)aS=L end,get=function()return aS end},ExtraLongitudeTags={set=function(L)aT=L end,get=function()return aT end},ExtraLateralTags={set=function(L)aU=L end,get=function()return aU end},ExtraVerticalTags={set=function(L)aV=L end,get=function()return aV end}}aX=j;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=1000;b9=false;ba=false;bb=false;bc=false;bd=0;be="Aligning"bf=0;bg=1;bh="None"bi=nil;bj=0;bk=nil;bl=0.0;bm=0;bn={}bo=false;bp=0;bq=0;br=nil;bs=0;bt=1000;bu=0;bv=false;bw=0;bx=false;by="All"bz=true;bA="Off"bB=0.000;bC={}bD={VertTakeOff={set=function(L)b7=L end,get=function()return b7 end},VertTakeOffEngine={set=function(L)aY=L end,get=function()return aY end},SpaceTarget={set=function(L)bv=L end,get=function()return bv end},BrakeToggleStatus={set=function(L)aX=L end,get=function()return aX end},BrakeIsOn={set=function(L)aZ=L end,get=function()return aZ end},RetrogradeIsOn={set=function(L)a_=L end,get=function()return a_ end},ProgradeIsOn={set=function(L)b0=L end,get=function()return b0 end},Autopilot={set=function(L)b1=L end,get=function()return b1 end},TurnBurn={set=function(L)b2=L end,get=function()return b2 end},AltitudeHold={set=function(L)b3=L end,get=function()return b3 end},BrakeLanding={set=function(L)b4=L end,get=function()return b4 end},Reentry={set=function(L)b6=L end,get=function()return b6 end},AutoTakeoff={set=function(L)b5=L end,get=function()return b5 end},HoldAltitude={set=function(L)b8=L end,get=function()return b8 end},AutopilotAccelerating={set=function(L)b9=L end,get=function()return b9 end},AutopilotBraking={set=function(L)bb=L end,get=function()return bb end},AutopilotCruising={set=function(L)bc=L end,get=function()return bc end},AutopilotRealigned={set=function(L)ba=L end,get=function()return ba end},AutopilotEndSpeed={set=function(L)bd=L end,get=function()return bd end},AutopilotStatus={set=function(L)be=L end,get=function()return be end},AutopilotPlanetGravity={set=function(L)bf=L end,get=function()return bf end},PrevViewLock={set=function(L)bg=L end,get=function()return bg end},AutopilotTargetName={set=function(L)bh=L end,get=function()return bh end},AutopilotTargetCoords={set=function(L)bi=L end,get=function()return bi end},AutopilotTargetIndex={set=function(L)bj=L end,get=function()return bj end},TotalDistanceTravelled={set=function(L)bl=L end,get=function()return bl end},TotalFlightTime={set=function(L)bm=L end,get=function()return bm end},SavedLocations={set=function(L)bn=L end,get=function()return bn end},VectorToTarget={set=function(L)bo=L end,get=function()return bo end},LocationIndex={set=function(L)bp=L end,get=function()return bp end},LastMaxBrake={set=function(L)bq=L end,get=function()return bq end},LockPitch={set=function(L)br=L end,get=function()return br end},LastMaxBrakeInAtmo={set=function(L)bs=L end,get=function()return bs end},AntigravTargetAltitude={set=function(L)bt=L end,get=function()return bt end},LastStartTime={set=function(L)bu=L end,get=function()return bu end},iphCondition={set=function(L)by=L end,get=function()return by end},stablized={set=function(L)bz=L end,get=function()return bz end},UseExtra={set=function(L)bA=L end,get=function()return bA end},SelectedTab={set=function(L)bE=L end,get=function()return bE end},saveRoute={set=function(L)bC=L end,get=function()return bC end}}local function bF(a,b,c,bG,bH,bI)bJ=bG()bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=0;bR=0;bS=0;bT=0;bU=false;bV=false;bW="empty"bX=3;bY=false;bZ=0;b_=0;c0=nil;c1=0;c2=0;c3=0;c4=false;c5=false;c6=false;c7=-1;c8=bI()>0;c9=bI()ca=b.getAltitude()cb=b.getConstructMass()cc=nil;cd=aa;ce=ab;cf={}cg={}ch={}ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=false;ct=false;cu=p;cv=false;cw=V;cx=nil;cy=0;cz=false;cA=false;cB=false;cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getVelocity())cF=vec3(b.getWorldVelocity())cG=vec3(cF):len()cH=vec3(b.getWorldVertical())cI=-cH:dot(cF)cJ=vec3(b.getConstructWorldPos())cK=false;cL=false;cM=true;cN=0;cO=0;cP={}cQ=false;cR=50000;cS=nil;cT=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;cU=false;cV=nil;cW=false;cX=0;cY=nil;cZ=nil;c_={}d0=90;d1=x;d2=nil;d3=nil;d4={}d5={}d6=false;d7=nil;if shield_1 then d8=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())end end;local function d9(d,b,c,a,da,db,dc,dd,de)local function df(dg)return type(dg)=='number'end;local function dh(dg)return type(dc(dg))=='number'end;local function di(dj)return type(dj)=='table'end;local function dk(a)return type(a)=='string'end;local function dl(dm)return di(dm)and df(dm.x and dm.y and dm.z)end;local function dn(dp)return di(dp)and df(dp.latitude and dp.longitude and dp.altitude and dp.id and dp.systemId)end;local dq=math.pi/180;local dr=180/math.pi;local ds=1e-10;local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..dt..','..dt..','..dt..','..dt..','..dt..'}'local utils=utils;local vec3=vec3;local function dv(dg)local dw=string.gsub(string.reverse(da('%.4f',dg)),'^0*%.?','')return dw==''and'0'or string.reverse(dw)end;local function dx(dy)if dl(dy)then return da('{x=%.3f,y=%.3f,z=%.3f}',dy.x,dy.y,dy.z)end;if di(dy)and not getmetatable(dy)then local dz={}local dA=next(dy)if type(dA)=='nil'or dA==1 then dz=dy else for dB,dm in pairs(dy)do local dC=dx(dm)if type(dB)=='number'then table.insert(dz,da('[%s]=%s',dB,dC))else table.insert(dz,da('%s=%s',dB,dC))end end end;return da('{%s}',table.concat(dz,','))end;if dk(dy)then return da("'%s'",dy:gsub("'",[[\']]))end;return tostring(dy)end;local dD={}dD.__index=dD;dD.__tostring=function(dy,dE)local dF={}for dB in pairs(dy)do table.insert(dF,dB)end;table.sort(dF)local dz={}for dG,dB in ipairs(dF)do local dC=dx(dy[dB])if type(dB)=='number'then table.insert(dz,da('[%s]=%s',dB,dC))else table.insert(dz,da('%s=%s',dB,dC))end end;if dE then return da('%s%s',dE,table.concat(dz,',\n'..dE))end;return da('{%s}',table.concat(dz,','))end;dD.__eq=function(dH,dI)return dH.systemId==dI.systemId and dH.id==dI.id and de(dH.radius,dI.radius)and de(dH.center.x,dI.center.x)and de(dH.center.y,dI.center.y)and de(dH.center.z,dI.center.z)and de(dH.GM,dI.GM)end;local function dJ(dK,dL,dM,dN,dO)assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(dM),'Argument 3 (radius) must be a number:'..type(dM))assert(di(dN),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dN))assert(dh(dO),'Argument 5 (GM) must be a number:'..type(dO))return setmetatable({systemId=dc(dK),id=dc(dL),radius=dc(dM),center=vec3(dN),GM=dc(dO)},dD)end;local dP={}dP.__index=dP;dP.__tostring=function(dQ)return da('::pos{%d,%d,%s,%s,%s}',dQ.systemId,dQ.id,dv(dQ.latitude*dr),dv(dQ.longitude*dr),dv(dQ.altitude))end;dP.__eq=function(dH,dI)return dH.id==dI.id and dH.systemId==dI.systemId and de(dH.latitude,dI.latitude)and de(dH.altitude,dI.altitude)and(de(dH.longitude,dI.longitude)or de(dH.latitude,math.pi/2)or de(dH.latitude,-math.pi/2))end;local function dR(dS,dL,dT,dU,dV)local dK=dS;if dk(dS)and not dU and not dV and not dL and not dT then dK,dL,dT,dU,dV=dW(dS,du)assert(dK,'Argument 1 (position string) is malformed.')else assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(dT),'Argument 3 (latitude) must be in degrees:'..type(dT))assert(dh(dU),'Argument 4 (longitude) must be in degrees:'..type(dU))assert(dh(dV),'Argument 5 (altitude) must be in meters:'..type(dV))end;dK=dc(dK)dL=dc(dL)dT=dc(dT)dU=dc(dU)dV=dc(dV)if dL==0 then return setmetatable({latitude=dT,longitude=dU,altitude=dV,id=dL,systemId=dK},dP)end;return setmetatable({latitude=dq*db(dT,-90,90),longitude=dq*(dU%360),altitude=dV,id=dL,systemId=dK},dP)end;local dX={}dX.__index=dX;dX.__tostring=function(dy,dE)local dY=dE and dE..'  'local dZ={}local dF={}for dB in pairs(dy)do table.insert(dF,dB)end;table.sort(dF)for dG,d_ in ipairs(dF)do e0=dy[d_]local e1=dD.__tostring(e0,dY)if dE then table.insert(dZ,da('[%s]={\n%s\n%s}',d_,e1,dE))else table.insert(dZ,da('  [%s]=%s',d_,e1))end end;if dE then return da('\n%s%s%s',dE,table.concat(dZ,',\n'..dE),dE)end;return da('{\n%s\n}',table.concat(dZ,',\n'))end;local function e2(e3)local e={}local pid;for dG,dm in pairs(e3)do local dL=dm.planetarySystemId;if type(dL)~='number'then error('Invalid planetary s ID: '..tostring(dL))elseif pid and dL~=pid then error('Mistringmatch planetary s IDs: '..dL..' and '..pid)end;local e4=dm.bodyId;if type(e4)~='number'then error('Invalid body ID: '..tostring(e4))elseif e[e4]then error('Duplicate body ID: '..tostring(e4))end;setmetatable(dm.center,getmetatable(vec3.unit_x))e[e4]=setmetatable(dm,dD)pid=dL end;return setmetatable(e,dX)end;e5={}local function e6(e3)return setmetatable({galaxyAtlas=e3 or{}},e5)end;e5.__index=function(dj,L)if type(L)=='number'then local a=dj.galaxyAtlas[L]return e2(a)end;return rawget(e5,L)end;e5.__pairs=function(dy)return function(dj,dB)local e7,e8=next(dj,dB)return e7,e8 and e2(e8)end,dy.galaxyAtlas,nil end;e5.__tostring=function(dy)local e9={}for dG,ea in pairs(dy or{})do local eb=ea:getPlanetarySystemId()local ec=dX.__tostring(ea,'    ')table.insert(e9,da('  [%s]={%s\n  }',eb,ec))end;return da('{\n%s\n}\n',table.concat(e9,',\n'))end;e5.BodyParameters=dJ;e5.MapPosition=dR;e5.PlanetarySystem=e2;function e5.createBodyParameters(dK,dL,ed,ee,ef,eg,eh)assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(ed),'Argument 3 (surfaceArea) must be a number:'..type(ed))assert(di(ee),'Argument 4 (aPosition) must be an array or vec3:'..type(ee))assert(di(ef),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ef))assert(dh(eg),'Argument 6 (altitude) must be in meters:'..type(eg))assert(dh(eh),'Argument 7 (gravityAtPosition) must be number:'..type(eh))local dM=dd(ed/4/math.pi)local c3=dM+eg;local ei=vec3(ee)+c3*vec3(ef)local dO=eh*c3*c3;return dJ(dK,dL,dM,ei,dO)end;e5.isMapPosition=dn;function e5:getPlanetarySystem(dS)if L==nil then L=0 end;if e8==nil then e8=0 end;local dK=dS;if dn(dS)then dK=dS.systemId end;if type(dK)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(e8)~=dX then a=e2(a)end;return a end end end;function dX:sizeCalculator(ej)return 1.05*ej.radius end;function dX:castIntersections(ek,el,em,en,eo,ep)local eq={}if eo then for dG,ej in pairs(eo)do table.insert(eq,ej)end else eq=c_ end;if not ep then table.sort(eq,function(er,es)local et=er.center;local eu=es.center;return(et.x-ek.x)^2+(et.y-ek.y)^2+(et.z-ek.z)^2<(eu.x-ek.x)^2+(eu.y-ek.y)^2+(eu.z-ek.z)^2 end)end;local ev=el:normalize()for dG,ej in ipairs(eq)do local ew=ej.center-ek;local dM=self:sizeCalculator(ej)local ex=ew:dot(ev)local ey=ex^2-(ew:len2()-dM^2)if ey>=0 then local ez=dd(ey)local eA=ex+ez;local eB=ex-ez;if eB>0 then return ej,eA,eB elseif eA>0 then return ej,eA,nil end end end;return nil,nil,nil end;function dX:closestBody(eC)assert(type(eC)=='table','Invalid coordinates.')local eD,ej;local eE=vec3(eC)for dG,eF in pairs(self)do local eG=(eF.center-eE):len2()if(not ej or eG<eD)and eF.name~="Space"then ej=eF;eD=eG end end;return ej end;function dX:convertToBodyIdAndWorldCoordinates(dS)local eH=dS;if dk(dS)then eH=dR(dS)end;if eH.id==0 then return 0,vec3(eH.latitude,eH.longitude,eH.altitude)end;local eF=self:getBodyParameters(eH)if eF then return eH.id,eF:convertToWorldCoordinates(eH)end end;function dX:getBodyParameters(dS)local dL=dS;if dn(dS)then dL=dS.id end;assert(dh(dL),'Argument 1 (id) must be a number:'..type(dL))return self[dL]end;function dX:getPlanetarySystemId()local dG,dm=next(self)return dm and dm.systemId end;function dD:convertToMapPosition(dN)assert(di(dN),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dN))local eI=vec3(dN)if self.id==0 then return setmetatable({latitude=eI.x,longitude=eI.y,altitude=eI.z,id=0,systemId=self.systemId},dP)end;local eJ=eI-self.center;local c3=eJ:len()local dV=c3-self.radius;local dT=0;local dU=0;if not de(c3,0)then local eK=eL(eJ.y,eJ.x)dU=eK>=0 and eK or 2*math.pi+eK;dT=math.pi/2-math.acos(eJ.z/c3)end;return setmetatable({latitude=dT,longitude=dU,altitude=dV,id=self.id,systemId=self.systemId},dP)end;function dD:convertToWorldCoordinates(dS)local eH=dk(dS)and dR(dS)or dS;if eH.id==0 then return vec3(eH.latitude,eH.longitude,eH.altitude)end;assert(dn(eH),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eH.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eH.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eM=math.cos(eH.latitude)return self.center+(self.radius+eH.altitude)*vec3(eM*math.cos(eH.longitude),eM*math.sin(eH.longitude),math.sin(eH.latitude))end;function dD:getAltitude(dN)return(vec3(dN)-self.center):len()-self.radius end;function dD:getDistance(dN)return(vec3(dN)-self.center):len()end;function dD:getGravity(dN)local eN=self.center-vec3(dN)local eO=eN:len2()return self.GM/eO*eN/dd(eO)end;return setmetatable(e5,{__call=function(dG,...)return e6(...)end})end;local function eP(d,b,c,a,dd,eQ)local cj={}local eR=30000000/3600;local eS=eR*eR;local eT=100;function cj.computeAccelerationTime(eU,eV,eW)local eX=eR*math.asin(eU/eR)return(eR*math.asin(eW/eR)-eX)/eV end;function cj.computeDistanceAndTime(eU,eW,eY,eZ,e_,f0)e_=e_ or 0;f0=f0 or 0;local f1=eU<=eW;local f2=eZ*(f1 and 1 or-1)/eY;local f3=-f0/eY;local f4=f2+f3;if f1 and f4<=0 or not f1 and f4>=0 then return-1,-1 end;local f5,f6=0,0;if f2~=0 and e_>0 then local eX=math.asin(eU/eR)local f7=math.pi*(f2/2+f3)local f8=f2*e_;local f9=eR*math.pi;local dm=function(dj)local fa=(f7*dj-f8*math.sin(math.pi*dj/2/e_)+f9*eX)/f9;local fb=math.tan(fa)return eR*fb/dd(fb*fb+1)end;local fc=f1 and function(a)return a>=eW end or function(a)return a<=eW end;f6=2*e_;if fc(dm(f6))then local fd=0;while eQ(f6-fd)>0.5 do local dj=(f6+fd)/2;if fc(dm(dj))then f6=dj else fd=dj end end end;local fe=eU;local ff=f6/eT;for fg=1,eT do local fh=dm(fg*ff)f5=f5+(fh+fe)*ff/2;fe=fh end;if f6<2*e_ then return f5,f6 end;eU=fe end;local eX=eR*math.asin(eU/eR)local bJ=(eR*math.asin(eW/eR)-eX)/f4;local fi=eS*math.cos(eX/eR)/f4;local c3=fi-eS*math.cos((f4*bJ+eX)/eR)/f4;return c3+f5,bJ+f6 end;function cj.computeTravelTime(eU,eV,c3)if c3==0 then return 0 end;if eV>0 then local eX=eR*math.asin(eU/eR)local fi=eS*math.cos(eX/eR)/eV;return(eR*math.acos(eV*(fi-c3)/eS)-eX)/eV end;if eU==0 then return-1 end;assert(eU>0,'Acceleration and initial speed are both zero.')return c3/eU end;return cj end;local function fj(d,b,c,a,da,db,dc,dd,de)local vec3=vec3;local d9=d9(d,b,c,a,da,db,dc,dd,de)local function dk(a)return type(a)=='string'end;local function di(dj)return type(dj)=='table'end;fk={}fk.__index=fk;function fk:escapeAndOrbitalSpeed(dV)assert(self.body)local c3=dV+self.body.radius;if not de(c3,0)then local fl=dd(self.body.GM/c3)return dd(2)*fl,fl end;return nil,nil end;function fk:orbitalParameters(dS,fm)assert(self.body)assert(di(dS)or dk(dS))assert(di(fm))local fn=(dk(dS)or d9.isMapPosition(dS))and self.body:convertToWorldCoordinates(dS)or vec3(dS)local dm=vec3(fm)local fo=fn-self.body.center;local fp=dm:len2()local fq=fo:len()local fr=self.body.GM;local fs=((fp-fr/fq)*fo-fo:dot(dm)*dm)/fr;local et=fr/(2*fr/fq-fp)local ft=fs:len()local ev=fs:normalize()local fu=et*(1-ft)local fv=et*(1+ft)local fw=fu*ev+self.body.center;local fx=ft<=1 and-fv*ev+self.body.center or nil;local fy=dd(et*fr*(1-ft*ft))local fz=fx and 2*math.pi*dd(et^3/fr)local fA=math.acos(fs:dot(fo)/(ft*fq))if fo:dot(dm)<0 then fA=-(fA-2*math.pi)end;local fB=math.acos((math.cos(fA)+ft)/(1+ft*math.cos(fA)))local fC=fB;if fC<0 then fC=fC+2*math.pi end;local fD=fC-ft*math.sin(fC)local fE=0;local fF=0;local fG=0;if fz~=nil then fE=fD/(2*math.pi/fz)fF=fz-fE;fG=fF+fz/2;if fA-math.pi>0 then fF=fE;fG=fF+fz/2 end;if fG>fz then fG=fG-fz end end;return{periapsis={position=fw,speed=fy/fu,circularOrbitSpeed=dd(fr/fu),altitude=fu-self.body.radius},apoapsis=fx and{position=fx,speed=fy/fv,circularOrbitSpeed=dd(fr/fv),altitude=fv-self.body.radius},currentVelocity=dm,currentPosition=fn,eccentricity=ft,period=fz,eccentricAnomaly=fB,meanAnomaly=fD,timeToPeriapsis=fF,timeToApoapsis=fG,trueAnomaly=fA}end;local function fH(fI)local eF=d9.BodyParameters(fI.systemId,fI.id,fI.radius,fI.center,fI.GM)return setmetatable({body=eF},fk)end;return setmetatable(fk,{__call=function(dG,...)return fH(...)end})end;local function fJ(d,b,c,a,dbHud_1,e,fK,fL,bH,dc,dd,fM)local function fN(fO)local dQ=fP:closestBody(fO)if(fO-dQ.center):len()>dQ.radius+dQ.noAtmosphericDensityAltitude then dQ=e[0][0]end;return dQ end;local function fQ()local function fR(fS,fT)return fS.name<fT.name end;cP={}for dB,dm in pairs(e[0])do cP[#cP+1]={name=dm.name,index=dB}end;table.sort(cP,fR)end;local function fU(fV,fW)if not fW then fW=fX.name end;for dB,dm in pairs(fV)do if dm.name and dm.name==fW then return dB end end;return-1 end;local function fY()cX=bj;if bj==0 then bh="None"c0=nil;fX=nil;return true end;local fZ=cP[bj].index;local f_=e[0][fZ]if f_.center then bh=f_.name;c0=ci[0][fZ]if fX~=nil then if c9==0 then if fK(g0,g1)~=1 then fL(g0,g1)end;if fK(g2,g3)~=1 then fL(g2,g3)end;if fK(g4,g5)~=1 then fL(g4,g5)end;if fK(g6,g7)~=1 then fL(g6,g7)end;if fK(g8,g9)~=1 then fL(g8,g9)end end;if fK(ga,gb)~=1 then fL(ga,gb)end;if fK(gc,gd)~=1 then fL(gc,gd)end;if fK(ge,gf)~=1 then fL(ge,gf)end end;fX=nil else fX=f_;for dG,dm in pairs(ci[0])do if dm.name==fX.planetname then c0=dm;bh=fX.name;break end end;if fK(ga,gb)~=1 then fL(ga,gb)end;if fK(gc,gd)~=1 then fL(gc,gd)end end;if fX==nil then bi=vec3(c0.center)else bi=fX.position end;if c0.planetname~="Space"then if c0.hasAtmosphere then gg=bH(c0.radius*(T-1)+c0.noAtmosphericDensityAltitude)else gg=bH(c0.radius*(T-1)+c0.surfaceMaxAltitude)end else gg=S end;if fX~=nil and fX.planetname=="Space"then bd=0 else dG,bd=cl(c0):escapeAndOrbitalSpeed(gg)end;bf=0;b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"return true end;local function gh(gi)if not b1 and not bo and not c5 and not bx and not b6 and not c6 then if gi==nil then bj=bj+1;if bj>#cP then bj=0 end else bj=bj-1;if bj<0 then bj=#cP end end;if bj==0 then fY()else local fZ=cP[bj].index;local f_=e[0][fZ]if f_ and(f_~=nil and f_.name=="Space"or by=="Custom Only"and f_.center or by=="No Moons"and string.find(f_.name,"Moon")~=nil)then if gi==nil then gh()else gh(1)end else fY()end end else bW="Disengage autopilot before changing Interplanetary Helper"fM("iph","AP")end end;local function gj()local function gk(gl)local gm;if gl then gm=d4 else gm=bn end;local gn=-1;gn=fU(e[0])if gn>-1 then table.remove(e[0],gn)end;gn=-1;gn=fU(gm)if gn~=-1 then bW=fX.name.." saved location cleared"table.remove(gm,gn)end;gh()fQ()return gm end;if string.sub(bh,1,1)=="*"then d4=gk(true)else bn=gk(false)end end;local function go(gp,fO,gq,gr)local function gs(gl)if gl then gm=d4 else gm=bn end;if dbHud_1 or gq or gl then local dQ=fN(fO)local gt=dQ.gravity;if gr then gt=c.getClosestPlanetInfluence()end;local gu={position=fO,name=gp,planetname=dQ.name,gravity=gt,safe=gr}if not gq then gm[#gm+1]=gu else for dB,dm in pairs(e[0])do if dm.name and gp==dm.name then table.remove(e[0],dB)end end end;table.insert(e[0],gu)fQ()fY()bW="Location saved as "..gp.."("..dQ.name..")"return gm else bW="Databank must be installed to save permanent locations"end end;if string.sub(gp,1,1)=="*"then d4=gs(true)else bn=gs(false)end end;local gv={}function gv.UpdateAtlasLocationsList()fQ()end;function gv.UpdateAutopilotTarget()fY()end;function gv.adjustAutopilotTargetIndex(gi)gh(gi)end;function gv.findAtlasIndex(fV,fW)return fU(fV,fW)end;function gv.UpdatePosition(gw,gx)local function gy(gl)local gm;if gl then gm=d4 else gm=bn end;local gn=fU(gm)if gn~=-1 then if gw~=nil then if gl then gw="*"..gw end;gm[gn].name=gw;bj=bj-1;gh()else local gz=gm[gn]if gx then gz.heading=cD:cross(cH)*5000;bW=gm[gn].name.." heading saved ("..gm[gn].planetname..")"return elseif gx==false then gz.heading=nil;bW=gm[gn].name.." heading cleared ("..gm[gn].planetname..")"return end;gz.gravity=c.getClosestPlanetInfluence()gz.position=cJ;gz.safe=true end;bW=gm[gn].name.." position updated ("..gm[gn].planetname..")"else bW="Name Not Found"end end;if string.sub(bh,1,1)=="*"then gy(true)else gy(false)end end;function gv.AddNewLocation(gp,fO,gq,gr)go(gp,fO,gq,gr)end;function gv.ClearCurrentPosition()gj()end;for dB,dm in pairs(d5)do table.insert(e[0],dm)end;fQ()if bj>#cP then bj=0 end;gv.UpdateAutopilotTarget()return gv end;local function gA(b,a,c,library,radar_1,radar_2,eQ,gB,dd,gC,dc,gD,fM)local gE={}local gF={}local gG={XS=13,S=27,M=55,L=110,XL=221}local gH={}local gI;local gJ;local gK;local gL;local gM;local gN={}local gO="Atmo"local gP;local gQ;local gR=0;local gS={}local function gT()local function gU(gV,gW,gX,gY,gZ,g_,h0,h1)gW,gY,g_,h1=vec3(gW),vec3(gY),vec3(g_),vec3(h1)local h2,h3,h4=gV*gV,gX*gX,gZ*gZ;local fp=gY-gW;local h5=fp:normalize()local h6=fp:len()local h7=g_-gW;local h8=(h7-h7:project_on(h5)):normalize()local h9,ha=h7:dot(h5),h7:dot(h8)local hb=h9*h9+ha*ha;local hc=h5:cross(h8)local hd=(h2-h3+h6*h6)/(2*h6)local he=(h2-h4+hb-2*h9*hd)/(2*ha)local dp=h2-hd^2-he^2;local hf=dd(dp)local hg=gW+h5*hd+h8*he+hc*hf;local hh=gW+h5*hd+h8*he-hc*hf;if eQ((h1-hg):len()-h0)<eQ((h1-hh):len()-h0)then return hg else return hh end end;local function hi()local function hj()local hk=b.getConstructWorldOrientationRight()local fp=b.getConstructWorldOrientationForward()local h7=b.getConstructWorldOrientationUp()local hl=library.systemResolution3(hk,fp,h7,{1,0,0})local hm=library.systemResolution3(hk,fp,h7,{0,1,0})local hn=library.systemResolution3(hk,fp,h7,{0,0,1})return function(ho)return library.systemResolution3(hl,hm,hn,ho)end end;local hp=hj()local hq=b.getConstructWorldPos()local fn=b.getElementPositionById(1)local hr={fn[1],fn[2],fn[3]}local hs=hp(hr)local ht={hq[1]-hs[1],hq[2]-hs[2],hq[3]-hs[3]}return ht end;local function hu(hv,fq,hw)local hx=hv.pts;local gn=#hx;local hy=hv.ref;if gn>3 then local hz,hA,hB,hC=hx[gn],hx[gn-1],hx[gn-2],hx[gn-3]hv.ref=hw;local fn=gU(hz[1],hz[2],hA[1],hA[2],hB[1],hB[2],hC[1],hC[2])local hd,he,hf=fn.x,fn.y,fn.z;if hd==hd and he==he and hf==hf then hd=hd+hy[1]he=he+hy[2]hf=hf+hy[3]local hD=vec3(hd,he,hf)if not hv.lastPos then hv.center=hD elseif(hv.lastPos-hD):len()<2 then hv.center=hD;hv.skipCalc=true end;hv.lastPos=hD end;hv.pts={}else local hE={hw[1]-hy[1],hw[2]-hy[2],hw[3]-hy[3]}hx[gn+1]={fq,hE}end end;if radar_1 or radar_2 then cp.assignRadar()end;if gN[1]then gI=#gN[1].getConstructIds()local hF=gN[1].getData()local hG=hF:gmatch('{"constructId[^}]*}[^}]*}')if gI>0 then local hw=hi()local hH,hI=0,0;gM,gL=0,0;for dm in hG do local dL,c3,hJ=dm:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hK=gG[hJ]c3=dc(c3)if gN[1].hasMatchingTransponder(dL)==1 then table.insert(gF,dL)end;local hL=gN[1].getConstructType(dL)if F then if hK>27 or hL=="static"or hL=="space"then gM=gM+1;local gp=gN[1].getConstructName(dL)local hv=gS[dL]if hv==nil then hK=hK+gD;gS[dL]={pts={},ref=hw,name=gp,i=0,radius=hK,skipCalc=false}hv=gS[dL]end;if not hv.skipCalc then hu(hv,c3,hw)hI=hI+1 end;if hv.center then table.insert(gH,hv)end end;hH=hH+1;if cT and hH>700 or hI>70 or(not cT and hH>300 or hI>30)then coroutine.yield()hH,hI=0,0 end end end;gL=#gH;if gL>0 and cG>20 then local ej,hM,hN,hO;local hP=0;local hQ=ci:getPlanetarySystem(0)hO=cF:normalize()while hP<gL do coroutine.yield()local hR={table.unpack(gH,hP,math.min(hP+75,gL))}ej,hM,hN=hQ:castIntersections(cJ,hO,nil,nil,hR,true)if ej and hN then cV={ej,hM,hN}break end;hP=hP+75 end;if not ej then cV=nil end else cV=nil end;gH={}gJ=hF:find('identifiedConstructs":%[%]')else gK=hF:find('worksInEnvironment":false')end end end;local function hS()if gN[1]then gO="Atmo"if gN[1].getData():find('worksInAtmosphere":false')then gO="Space"end end end;function gE.pickType()hS()end;function gE.assignRadar()if radar_1 and gN[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gN[1]=radar_2 end;if gN[1]==radar_2 then hS()end elseif radar_2 and gN[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gN[1]=radar_1 end;if gN[1]==radar_1 then hS()end end end;function gE.UpdateRadar()local hT=coroutine.status(gP)if hT=="suspended"then local dC,hU=coroutine.resume(gP)if hU then a.print("ERROR UPDATE RADAR: "..hU)end elseif hT=="dead"then gP=coroutine.create(gT)local dC,hU=coroutine.resume(gP)end end;function gE.GetRadarHud(hV,hW,hX,hY)local hZ=gF;local h_,i0;gF={}local dt=gL or 0;if gI>0 then if F then i0=dt.."/"..gM.." Plotted : "..gI-gM.." Ignored"else i0="Radar Contacts: "..gI end;h_=gC(hX,hY,i0,"pbright txtbig txtmid")if#gF>0 then h_=h_..gC(hV,hW,"Friendlies In Range","pbright txtbig txtmid")for dB,dm in pairs(gF)do hW=hW+20;h_=h_..gC(hV,hW,gN[1].getConstructName(dm),"pdim txtmid")end end;if gJ==nil and gQ==nil then gR=1;cp.ToggleRadarPanel()end;if gJ~=nil and gQ~=nil then cp.ToggleRadarPanel()end;if d3==nil then cp.ToggleRadarPanel()end else if gK then h_=gC(hX,hY,gO.." Radar: Jammed","pbright txtbig txtmid")else h_=gC(hX,hY,"Radar: No "..gO.." Contacts","pbright txtbig txtmid")end;if d3~=nil then gR=0;cp.ToggleRadarPanel()end end;return h_ end;function gE.GetClosestName(gp)if gN[1]then local dL,dG=gN[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dL~=nil and dL~=""then gp=gp.." "..gN[1].getConstructName(dL)end end;return gp end;function gE.ToggleRadarPanel()if d3~=nil and gR==0 then gB(d3)d3=nil;if gQ~=nil then gB(gQ)gQ=nil end else if gR==1 then gB(d3)d3=nil;_autoconf.displayCategoryPanel(gN,1,"Periscope","periscope")gQ=_autoconf.panels[_autoconf.panels_size]end;if d3==nil then _autoconf.displayCategoryPanel(gN,1,"Radar","radar")d3=_autoconf.panels[_autoconf.panels_size]end;gR=0 end end;function gE.ContactTick()if not i1 then i1=0 end;if bJ>i1+10 then bW="Radar Contact"fM("rdrCon","RC")i1=bJ end;c.stopTimer("contact")end;function gE.onEnter(dL)if radar_1 and not c8 and not cQ then c.setTimer("contact",0.1)end end;function gE.onLeave(dL)if radar_1 and F then if#gS>650 then dL=tostring(dL)gS[dL]=nil end end end;gN[1]=nil;if radar_1 then gN[1]=radar_1;hS()end;gP=coroutine.create(gT)return gE end;local function i2(shield_1,dW,bH)local i3={}local i4=shield_1.getResistancesCooldown()local function i5()local i6=shield_1.getState()if G then if not cQ and i6==0 then shield_1.toggle()elseif cQ and i6==1 then shield_1.toggle()end end end;local function i7()local i8=shield_1.getStressRatioRaw()if i8[1]==0.0 and i8[2]==0.0 and i8[3]==0.0 and i8[4]==0.0 then return end;local i9=shield_1.setResistances(0.6*i8[1],0.6*i8[2],0.6*i8[3],0.6*i8[4])if i9==1 then bW="Shield Resistances updated"else bW="Failed to update Shield Resistances"end end;function i3.shieldTick()d8=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())i5()i4=shield_1.getResistancesCooldown()if i4==0 and d8<a8 then i7()end end;function i3.setResist(ia)if not shield_1 then bW="No shield found"return elseif ia==nil or i4>0 then bW="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du=dt..', '..dt..', '..dt..', '..dt;local ib,ic,id,ie=dW(ia,du)if ie==nil or ib+ic+id+ie>0.6 then bW="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(ib,ic,id,ie)==1 then bW="Shield Resistances set"else bW="Resistance setting failed."end end;function i3.ventShield()local ig=shield_1.getVentingCooldown()if ig>0 then bW="Cannot vent again for "..ig.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()bW="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bW="Shields already at max hitpoints"end end;return i3 end;local function ih(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ii,eQ,bH,da,ij,bI,ik,il,eL,bG,db,im,fL,fK,gB,io,dd,ip,gC,fM,iq,ir,is,it,iu,iv)local iw=9.80665;local ix={}local iy={}local iz={}local iA={}local iB=nil;local iC=nil;local iD=nil;local iE=false;local iF="none"local iG=""local iH=55;local iI=0;local iJ=0;local iK=""local iL=nil;local iM=ad;local iN=ae;local iO=af;local iP=[[rgb(]]..bH(iM+0.5)..","..bH(iN+0.5)..","..bH(iO+0.5)..[[)]]local iQ=[[rgb(]]..bH(iM*0.9+0.5)..","..bH(iN*0.9+0.5)..","..bH(iO*0.9+0.5)..[[)]]local iR=0;local iS=0;local iT=""local iU=bG()local iV=false;local iW=vec3({13771471,7435803,-128971})local iX=18000000;local iY=500000;local iZ,i_=math.huge;local j0;local function j1(j2)iZ=vec3(j2):dist(iW)if iZ<iX then return true,eQ(iZ-iX)end;i_=vec3(j2):dist(vec3(j3.center))if i_<iY then j0=true else j0=false end;if eQ(i_-iY)<eQ(iZ-iX)then return j0,eQ(i_-iY)else return j0,eQ(iZ-iX)end end;local function j4(dm)if cd==1920 then return dm else return ip(cd*dm/1920,0)end end;local function j5(dm)if ce==1080 then return dm else return ip(ce*dm/1080,0)end end;local function j6()return io()==0 and g~="keyboard"and il()==0 end;local function j7()local j8="TRAVEL"if not cM then j8="CRUISE"end;if b1 then j8="AUTOPILOT"end;return j8 end;local h_=""local j9=""local ja=""local jb=1;local jc=2;local jd=3;local je=4;local jf=5;local jg=6;local jh=""local ji=0;local jj=bH(1/aQ)*2*aR;local jk={}local jl={}local jm={}local jn={}local jo={}local jp={}local jq={}jq["atmofueltank"],jq["spacefueltank"],jq["rocketfueltank"]=0,0,0;local jr=0;local function js(hd,jt,ju,jv,jw,jx)local jy=jr;local jz=jr+5;if not C then jz=jz+5 end;if il()==1 and not l then jy=jy-50;jz=jz-50 end;if ju=="ATMO"then jh="atmofueltank"elseif ju=="SPACE"then jh="spacefueltank"else jh="rocketfueltank"end;ji=_G[jh.."_size"]if#jv>0 then for L=1,#jv do local gp=string.sub(jv[L][jc],1,12)local jA=0;for jB=1,ji do if jv[L][jc]==ij(c[jh.."_"..jB].getData()).name then jA=jB;break end end;local jC=bG()if jw[L]==nil or jx[L]==nil or jC-jv[L][jg]>jj then local jD;local jE=0;jE=ik(jv[L][jb])-jv[L][je]jD=jv[L][jf]if jD>jE then jq[jh]=jq[jh]+jD-jE end;if jA~=0 then jx[L]=ij(c[jh.."_"..jA].getData()).percentage;jw[L]=ij(c[jh.."_"..jA].getData()).timeLeft;if jw[L]=="n/a"then jw[L]=0 end else jx[L]=bH(0.5+jE*100/jv[L][jd])if jD<=jE then jw[L]=0 else jw[L]=bH(0.5+jE/((jD-jE)/(jC-jv[L][jg])))end end;jv[L][jg]=jC;jv[L][jf]=jE end;if gp==jt then gp=da("%s %d",ju,L)end;if jA==0 then gp=gp.." *"end;local jF;if jw[L]==0 then jF=""else jF=it(jw[L])end;if jx[L]~=nil then local jG=bH(jx[L]*2.55)local jH=da("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""if jF~=""and jw[L]<120 or jx[L]<5 then jI="red "end;local jJ=da("rgb(%d,%d,%d)",db(bH((255-jG)/2.55),50,100),db(bH(jG/2.55),0,50),50)local jK="rgb(196,0,255)"if ju=="ATMO"then jK="rgb(0,188,255)"elseif ju=="SPACE"then jK="rgb(239,255,0)"end;local jL=false;if jM~=jK then jL=true end;jM=jK;if C then if jL then jy=jy-5;jz=jz-5 end;j9=j9 ..da([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jJ,jK,hd,jz,jH,bH(jx[L]*1.7+0.5)-2,hd+1,jz+1,hd+5,jz+14,gp,jx[L],jF)jy=jy-22;jz=jz-22 else j9=j9 ..gC(hd,jy,gp,jI.."pdim txtfuel")j9=j9 ..gC(hd,jz,da("%d%% %s",jx[L],jF),"pdim txtfuel","fill:"..jH)jy=jy+30;jz=jz+30 end end end end;jr=jy end;local function jN(jO,dV)if an==0 and ao==0 then return end;if dV<200000 and not c8 or dV and c8 then local jP=0;if eQ(cI)>1 then jP=45*math.log(eQ(cI),10)if cI<0 then jP=-jP end end;jO[#jO+1]=da([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],an,ao,bH(cI),bH(jP))end;return jO end;local function jQ(jR)local gi=-cH;jR=jR-jR:project_on(gi)local jS=vec3(0,0,1)jS=jS-jS:project_on(gi)local jT=jS:cross(gi)local jP=jS:angle_between(jR)*constants.rad2deg;if jR:dot(jT)<0 then jP=360-jP end;return jP end;local function jU(jO,aj,ak,jV,jW,cT)if ac==0 then return end;local jX=ac;local jY=20;local jZ=bH(jV)if cT then for L=-45,45,5 do local j_=L;jO[#jO+1]=da([[<g transform="rotate(%f,%d,%d)">]],j_,aj,ak)k0=5;if L%15==0 then k0=15 elseif L%10==0 then k0=10 end;jO[#jO+1]=da([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],aj,ak+jX+jY-k0,aj,ak+jX+jY)end;jO[#jO+1]=gC(aj,ak+jX+jY-35,jW,"pdim txt txtmid")jO[#jO+1]=gC(aj,ak+jX+jY-25,jZ.." deg","pdim txt txtmid")jO[#jO+1]=da([[<g transform="rotate(%f,%d,%d)">]],-jV,aj,ak)jO[#jO+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/>]],aj-5,ak+jX+jY-20,aj+5,ak+jX+jY-20,aj,ak+jX+jY-15)jO[#jO+1]="</g>"end;jO[#jO+1]=[[<g style="clip-path: url(#headingClip);">]]local k1=jZ;if cT then k1=jQ(cC)end;local k2=20;local k3=bH(k1)local k4=0;local k5=ak+jX+jY+20;local k6=aj;if jW~="YAW"then k5=j5(130)k6=j4(960)end;local k7=[[<path class="txttick line" d="]]local k8=bH(k3-(k2+10)-k3%5+0.5)for L=k8+70,k8,-5 do local hd=k6-(-L*5+k1*5)if L%10==0 then k4=10;local dt=L;if dt==360 then dt=0 elseif dt>360 then dt=dt-360 elseif dt<0 then dt=dt+360 end;jO[#jO+1]=gC(hd,k5+15,dt,"txtmid bright")elseif L%5==0 then k4=5 end;if k4==10 then k7=da([[%s M %f %f v %d]],k7,hd,k5-5,k4)else k7=da([[%s M %f %f v %d]],k7,hd,k5-2.5,k4)end end;jO[#jO+1]=k7 ..[["/>]]jO[#jO+1]=da([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k6-5,k5-20,k6+5,k5-20,k6,k5-10)if I then if cT then jW="HDG"end;jO[#jO+1]=gC(j4(960),j5(100),k3 .."°","dim txt txtmid size14","")jO[#jO+1]=gC(j4(960),j5(85),jW,"dim txt txtmid size20","")end;jO[#jO+1]=[[</g>]]end;local function k9(jO,ka,jV,aj,ak,cT,kb,fh)if ac==0 then return end;local jX=ac;local kc=bH(jX*3/5)if jX>0 then local kd=bH(ka)local k0=0;local k7=da([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jV,aj,ak)if not c8 then k7=da([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],aj,ak)end;jO[#jO+1]=da([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jX-1,aj,ak)jO[#jO+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bH(kd-30-kd%5+0.5),bH(kd+30+kd%5+0.5),5 do if L%10==0 then k0=30 elseif L%5==0 then k0=20 end;local he=ak+-L*5+ka*5;if k0==30 then k7=da([[%s M %d %f h %d]],k7,aj-kc-k0,he,k0)if c8 then jO[#jO+1]=da([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,aj,ak,aj-kc+10,he+4,L)jO[#jO+1]=da([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,aj,ak,aj+kc-10,he+4,L)if L==0 or L==180 or L==-180 then jO[#jO+1]=da([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,aj,ak,aj-kc+20,he,kc*2-40)end else jO[#jO+1]=gC(aj-kc+10,he,L,"pdim txt txtmid")jO[#jO+1]=gC(aj+kc-10,he,L,"pdim txt txtmid")end;k7=da([[%s M %d %f h %d]],k7,aj+kc,he,k0)else k7=da([[%s M %d %f h %d]],k7,aj-kc-k0,he,k0)k7=da([[%s M %d %f h %d]],k7,aj+kc,he,k0)end end;jO[#jO+1]=k7 ..[["/>]]local ke="PITCH"if not cT then ke="REL PITCH"end;if ka>90 and not c8 then ka=90-(ka-90)elseif ka<-90 and not c8 then ka=-90-(ka+90)end;if jX>200 then if c8 then if fh>iH then jO[#jO+1]=gC(aj,ak-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gC(aj,ak+20,kb,"pdim txt txtmid")end;jO[#jO+1]=da([[<g transform="rotate(%f,%d,%d)">]],-jV,aj,ak)else jO[#jO+1]=da([[<g transform="rotate(0,%d,%d)">]],aj,ak)end;jO[#jO+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],aj-kc+25,ak-5,aj-kc+20,ak,aj-kc+25,ak+5,aj-kc+50,ak+4,kd)jO[#jO+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],aj+kc-25,ak-5,aj+kc-20,ak,aj+kc-25,ak+5,aj+kc-30,ak+4,kd)jO[#jO+1]="</g>"end;local kf=bH(jX/3)jO[#jO+1]=da([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],aj-kf,ak,jX-kf)if not c8 and cT then jO[#jO+1]=da([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,aj,ak,aj-kc+10,ak,kc*2-20)end;jO[#jO+1]="</g>"if jX<200 then if c8 and fh>iH then jO[#jO+1]=gC(aj,ak-jX,ke,"pdim txt txtmid")jO[#jO+1]=gC(aj,ak-jX+10,kd,"pdim txt txtmid")jO[#jO+1]=gC(aj,ak-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gC(aj,ak+20,kb,"pdim txt txtmid")else jO[#jO+1]=gC(aj,ak-jX,ke,"pdim txt txtmid")jO[#jO+1]=gC(aj,ak-jX+15,kd,"pdim txt txtmid")end end end end;local function kg(jO,dV,cT)local kh=ap;local ki=aq;if kh==0 and ki==0 then return end;local kj=78;local kk=19;local kl=c7;if c7~=-1 then jO[#jO+1]=gC(kh+kj,ki+kk+20,da("AGL: %.1fm",c7),"pdim altsm txtend")end;if cT and(dV<200000 and not c8 or dV and c8)then table.insert(jO,da([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kh-1,ki-4,kj+2,kk+6,kh+1,ki-1,kj-4,kk))local gn=0;local km=1;local kn=0;local ko=dV<0;local kp=dV<j3.surfaceMaxAltitude;local kq=9;if ko then kq=0 end;local dV=eQ(dV)while gn<6 do local kr=11;local ks=16;local kt=9;local ku=14;local jI="altsm"if gn>2 then ks=ks+3;kr=kr+2;ku=ku+2;kt=kt-6;jI="altbig"end;if ko then jI=jI.." red"elseif kp then jI=jI.." orange"end;local kv=dV/km%10;local kw=bH(kv)local kx=bH((kw+1)%10)local ky=kn;if gn==0 then ky=kv-kw;if ko then ky=1-ky end end;if ko and(gn==0 or kn~=0)then local gq=kx;kx=kw;kw=gq end;local kz=ks*(ky-1)local kA=kz+ks;local hd=kh+kt+(6-gn)*kr;local he=ki+ku;jO[#jO+1]=gC(hd,he+kz,kx,jI)jO[#jO+1]=gC(hd,he+kA,kw,jI)gn=gn+1;km=km*10;if kw==kq then kn=ky else kn=0 end end;table.insert(jO,[[</g></g>]])end end;local function kB(fm)local kC=-math.deg(eL(fm.y,fm.z))+180;kC=kC-90;if kC<0 then kC=360+kC end;if kC>180 then kC=-180+kC-180 end;return-kC end;local function kD(fm)local k1=math.deg(eL(fm.y,fm.x))-90;if k1<-180 then k1=360+k1 end;return k1 end;local function kE(jO,fm,fh,aj,ak)if fh>5 and not c8 or fh>iH then local jX=ac;local kF=20;local kG=20;local kH=kB(fm)local kI=kD(fm)local kJ=14;local kK=kJ/2;local kL=-kI/kG*jX;local kM=kH/kF*jX;local hd=aj+kL;local he=ak+kM;local c3=dd(kL^2+kM^2)local kN=[[<circle
                            cx="]]..hd..[["
                            cy="]]..he..[["
                            r="]]..kK/kJ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hd..[["
                            cy="]]..he..[["
                            r="]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hd-kJ..[[,]]..he..[[ h ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hd+kK..[[,]]..he..[[ h ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hd..[[,]]..he-kJ..[[ v ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c3<jX then jO[#jO+1]=kN else local jP=eL(kM,kL)local kO=4;local kP=aj+jX*math.cos(jP)local kQ=ak+jX*math.sin(jP)jO[#jO+1]=da('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jP*180/math.pi,kP,kQ,kP-kO,kQ-kO/2,kO*2,kO,kP+kO,kQ-kO,kO,kO,-kO,kO)end;if not c8 then local kR=vec3(fm)kH=kB(-kR)kI=kD(-kR)kL=-kI/kG*jX;kM=kH/kF*jX;hd=aj+kL;he=ak+kM;c3=dd(kL^2+kM^2)if c3<jX then local kS=[[<circle
                                    cx="]]..hd..[["
                                    cy="]]..he..[["
                                    r="]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hd..[[,]]..he-kJ..[[ v ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hd..[[,]]..he..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hd..[[,]]..he..[[)" />
                                <path
                                    d="M ]]..hd-kK..[[,]]..he..[[ h ]]..kJ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hd..[[,]]..he..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hd..[[,]]..he..[[)"/>]]jO[#jO+1]=kS end end end end;local function kT(jO,j8,kU,kV)if al==0 and am==0 then return end;kU=bH(kU+0.5)local jy=am+10;local jz=am+20;if il()==1 and not l then jy=55;jz=65 end;local kW="CRUISE"local c="km/h"local dC=kV;if j8=="TRAVEL"or j8=="AUTOPILOT"then kW="THROT"c="%"dC=kU;local kX="dim"if kU<0 then kX="red"end;jO[#jO+1]=da([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kX,al-7,am-50,al,am-50,al,am+50,al-7,am+50,1-eQ(kU),al-10,am+50,al-15,am+53,al-15,am+47)end;jO[#jO+1]=gC(al+10,jy,kW,"pbright txtstart")jO[#jO+1]=gC(al+10,jz,da("%.0f %s",dC,c),"pbright txtstart")if c8 and u and cM and bM then kU=bH(bN*100+0.5)local kX="red"if kU<0 then kX="red"end;jO[#jO+1]=da([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kX,1-eQ(kU),al-10,am+50,al-15,am+53,al-15,am+47)jO[#jO+1]=gC(al+10,jy+40,"LIMIT","pbright txtstart")jO[#jO+1]=gC(al+10,jz+40,kU.."%","pbright txtstart")end;if c8 and u or b6 then jO[#jO+1]=gC(al+10,jy-40,"LIMIT: "..cw.." km/h","dim txtstart")elseif not c8 and b1 then jO[#jO+1]=gC(al+10,jy-40,"LIMIT: "..bH(a0*3.6+0.5).." km/h","dim txtstart")end end;local function kY(jO,kZ)if al==0 and am==0 then return end;local k_=am-10;local l0=al+10;jO[#jO+1]=gC(0,0,"","pdim txt txtend")if il()==1 and not l then k_=75 end;jO[#jO+1]=gC(l0,k_,bH(kZ).." km/h","pbright txtbig txtstart")end;local function l1(jO)jO[#jO+1]=gC(j4(1900),j5(1070),da("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jO[#jO+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jO[#jO+1]=gC(j4(960),j5(550),"Warning: Invalid Control Scheme Detected","warnings")jO[#jO+1]=gC(j4(960),j5(600),"Keyboard Scheme must be selected","warnings")jO[#jO+1]=gC(j4(960),j5(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l2=j4(960)local l3=j5(860)local l4=j5(880)local l5=j5(900)local l6=j5(960)local l7=j5(200)local l8=j5(250)local l9=j5(960)if il()==1 and not l then l3=j5(135)l4=j5(155)l5=j5(175)l7=j5(115)l8=j5(95)end;local la="#222222"local lb="white"local lc="dimmer"local ld="pbright"local le="#110000"local lf=la;local lg=lc;if aZ then jO[#jO+1]=gC(l2,l3,"Brake Engaged","warnings")le="#440000"lf=lb;lg=ld elseif bL>0 then jO[#jO+1]=gC(l2,l3,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local lh="#110000"local li=la;local lj=lc;if c8 and cv and c7==-1 then if not b1 and not bo and not b4 and not cL and not b7 and not b5 then jO[#jO+1]=gC(l2,l7+50,"** STALL WARNING **","warnings")lh="#ff0000"li=lb;lj=ld;fM("stall","SW",2)end end;if cS then jO[#jO+1]=gC(l2,l7+90,"Flight Assist in Progress","warnings")end;if cc then jO[#jO+1]=gC(l2,l9,"Gyro Enabled","warnings")end;local lk="#111100"local ll=la;local lm=lc;if bk then lk="#775500"ll=lb;lm=ld;if bP then jO[#jO+1]=gC(l2,l4,"Gear Extended","warn")else jO[#jO+1]=gC(l2,l4,"Landed (G: Takeoff)","warnings")end;local ln=is(d:getTargetGroundAltitude())jO[#jO+1]=gC(l2,l5,"Hover Height: "..ln,"warn")end;local lo="#000011"local lp=la;local lq=lc;if bY then lo="#0000DD"lp=lb;lq=ld;jO[#jO+1]=gC(l2,l6+20,"ROCKET BOOST ENABLED","warn")end;local lr="#001100"local ls=la;local lt=lc;if antigrav and not q and cL and bt~=nil then lr="#00DD00"ls=lb;lt=ld;if eQ(ca-antigrav.getBaseAltitude())<501 then jO[#jO+1]=gC(l2,l7+15,da("Target Altitude: %d Singularity Altitude: %d",bH(bt),bH(antigrav.getBaseAltitude())),"warn")else jO[#jO+1]=gC(l2,l7+15,da("Target Altitude: %d Singluarity Altitude: %d",bH(bt),bH(antigrav.getBaseAltitude())),"warnings")end elseif b1 and bh~="None"then jO[#jO+1]=gC(l2,l7+20,"Autopilot "..be,"warn")elseif br~=nil then jO[#jO+1]=gC(l2,l7+20,da("LockedPitch: %d",bH(br)),"warn")elseif bU then jO[#jO+1]=gC(l2,l7+20,"Follow Mode Engaged","warn")elseif b6 or c6 then jO[#jO+1]=gC(l2,l7+20,"Re-entry in Progress","warn")end;if b3 or b7 then local ln=is(b8,2)if b7 then if cL then ln=is(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jO[#jO+1]=gC(l2,l7,"VTO to "..ln,"warn")elseif b5 and not bx then if c5 then jO[#jO+1]=gC(l2,l7,"Takeoff to "..bh,"warn")else jO[#jO+1]=gC(l2,l7,"Takeoff to "..ln,"warn")end;if aZ and not b7 then jO[#jO+1]=gC(l2,l7+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jO[#jO+1]=gC(l2,l7,"Altitude Hold: "..ln,"warn")end end;if b7 and(antigrav~=nil and antigrav)then if c9>0.1 then jO[#jO+1]=gC(l2,l7+20,"Beginning ascent","warn")elseif c9<0.09 and c9>0.05 then jO[#jO+1]=gC(l2,l7+20,"Aligning trajectory","warn")elseif c9<0.05 then jO[#jO+1]=gC(l2,l7+20,"Leaving atmosphere","warn")end end;if bx then if cx~=nil then jO[#jO+1]=gC(l2,l7,cx,"warn")end end;if b4 then if lu then jO[#jO+1]=gC(l2,l7,"Brake-Landing","warnings")else jO[#jO+1]=gC(l2,l7,"Coast-Landing","warnings")end end;if b0 then jO[#jO+1]=gC(l2,l7,"Prograde Alignment","crit")end;if a_ then jO[#jO+1]=gC(l2,l7,"Retrograde Alignment","crit")end;local lv="#110000"local lw=la;local lx=lc;if cU then lv="#FF0000"lw=lb;lx=ld;local type;if string.find(cU,"COLLISION")then type="warnings"else type="crit"end;jO[#jO+1]=gC(l2,l8+20,cU,type)elseif c9==0 then local ly,lz=co.checkLOS(cF:normalize())if lz~=nil then lx=ld;lv="#FF0000"lw=lb;local ln=is(lz)local lA=cj.computeTravelTime(cG,0,lz)local lB="Collision"if ly.noAtmosphericDensityAltitude>0 then lB="Atmosphere"end;jO[#jO+1]=gC(l2,l8+20,ly.name.." "..lB.." "..it(lA).." In "..ln,"crit")end end;if bo and not bx then jO[#jO+1]=gC(l2,l7+35,lC,"warn")end;local lD="#111100"local lE=la;local lF=lc;if cY and#cY>1 then lD="#DDDD00"lE=lb;lF=ld end;local lG=j4;local lH=j5;local lc="topButton"local lI="topButtonActive"local lJ=lc;if b1 or bo or c5 or bx then lJ=lI end;local lK=lc;if b0 then lK=lI end;local lL=lc;if b4 or bk then lL=lI end;local lM=lc;if b3 or bo then lM=lI end;local lN=lc;if a_ then lN=lI end;local lO=lc;if bx or cz and b1 then lO=lI end;if x and I then local lP=lH(30)jO[#jO+1]=da([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lG(960),lH(54),lH(-53),lG(-120),lG(25),lH(50))jO[#jO+1]=gC(lG(910),lP,"AUTOPILOT")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lK,lG(865),lH(51),lG(-25),lH(-50),lG(-110),lG(25),lH(46))jO[#jO+1]=gC(lG(800),lP,"PROGRADE")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lL,lG(755),lH(47),lG(-25),lH(-46),lG(-98),lG(44),lH(44))jO[#jO+1]=gC(lG(700),lP,"LAND")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lM,lG(960),lH(54),lH(-53),lG(120),lG(-25),lH(50))jO[#jO+1]=gC(lG(1010),lP,"ALT HOLD")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lN,lG(1055),lH(51),lG(25),lH(-50),lG(110),lG(-25),lH(46))jO[#jO+1]=gC(lG(1122),lP,"RETROGRADE")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lO,lG(1165),lH(47),lG(25),lH(-46),lG(98),lG(-44),lH(44))jO[#jO+1]=gC(lG(1220),lP,"ORBIT")jO[#jO+1]=[[
                                    </g>
                                </g>]]jO[#jO+1]="</g>"end;return jO end;local function lQ(fh)return bH(ip(fh*3.6,0)+0.5).." km/h"end;local function lR(gn)local gp=bh;if gn~=nil and type(gn)=="number"then if gn==0 then return"None"end;gp=cP[gn].name end;if gp==nil then gp=fX.name end;if gp==nil then gp="None"end;return gp end;local function lS(jO)local lT=co.routeWP(true)if not lT or#lT==0 then return end;local hd=j4(750)local he=j5(360)if b1 or bo then jO[#jO+1]=gC(hd,he,"REMAINING ROUTE","pdim txtstart size20")else jO[#jO+1]=gC(hd,he,"LOADED ROUTE","pdim txtstart size20")end;for dB,L in pairs(lT)do he=he+20;jO[#jO+1]=gC(hd,he,dB..". "..lT[dB],"pdim txtstart size20")end end;local function lU(jO)local hd=ax+10;local he=ay+20;local lV={}local lW={"Alt-4: AutoTakeoff to Target"}local lX={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lY={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lZ={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lV,"--------------DYNAMIC-----------------")if c8 then if c7~=-1 then iq(lV,lW)if c0 and j3 and c0.name==j3.name then table.insert(lV,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aY then if antigrav then if cL then table.insert(lV,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lV,"Turn on AGG to takeoff to AGG Height")end end;if aY then table.insert(lV,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lV,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lV,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bk then table.insert(lV,"G: Takeoff to hover height, raise gear")else table.insert(lV,"G: Lowergear and Land")end else iq(lV,lX)table.insert(lV,"G: Begin BrakeLanding or Land")end;if b7 then table.insert(lV,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iq(lV,lY)if shield_1 then table.insert(lV,"Alt-Shift-6: Vent shields")if not G then table.insert(lV,"Alt-Shift-7: Toggle shield off/on")end end end;if fX~=nil then table.insert(lV,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lV,"Alt-9: Activate Gyroscope")end;if aU~="none"or aT~="none"or aV~="none"then table.insert(lV,"Alt-Shift-9: Cycles engines with Extra tags")end;if b3 then table.insert(lV,"Alt-Spacebar/C will raise/lower target height")table.insert(lV,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not c8 then table.insert(lV,"LALT+Mousewheel will lower/raise speed limit")end;iq(lV,lZ)for L=1,#lV do he=he+12;jO[#jO+1]=gC(hd,he,lV[L],"pdim txtbig txtstart")end end;local function l_(jO)local m0=ax;local m1=ay;local m2=aw;local m3=4;local m4=15;local hd=0;local he=0;local m5,m6,m7,m8;local m9;local function ma(type)local mb,bJ,fh,mc,jI,md;if type=="Periapsis"then mb=m9.periapsis.altitude;bJ=m9.timeToPeriapsis;fh=m9.periapsis.speed;jI="txtend"mc=12;md=math.min(hd,m0+m2-j3.radius/m7-m3*2)else mb=m9.apoapsis.altitude;bJ=m9.timeToApoapsis;fh=m9.apoapsis.speed;mc=-12;jI="txtstart"md=hd end;if cG<1 then bJ=0 end;jO[#jO+1]=da([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],md+mc,he-5,hd,he-5)jO[#jO+1]=da([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],md-mc*4,he+2,hd,he+2)jO[#jO+1]=gC(md,he,type,jI)hd=md-mc*2;he=he+m4;local ln=is(mb)jO[#jO+1]=gC(hd,he,ln,jI)he=he+m4;jO[#jO+1]=gC(hd,he,it(bJ),jI)he=he+m4;jO[#jO+1]=gC(hd,he,lQ(fh),jI)end;local me=m2*1.5;if bE=="INFO"then me=25*9 end;if bE~="HIDE"then jO[#jO+1]=[[<g class="pbright txtorb txtmid">]]jO[#jO+1]=da('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m2*2,me,m0,m1)jO[#jO+1]=da([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m2*2,me,m0,m1)end;local mf=m2*1.5;local mg=m2*2;local mh=mf/2;local mi=m2;local mj=m0+mi;local mk=m1+mh;local ml=m0+mg;local mm=m1+mf;if bE=="ORBIT"then m1=m1+m3;m5=m2/2;m8=0;m9={}m9.periapsis={}m9.apoapsis={}if fl~=nil then if fl.periapsis~=nil then m9.periapsis.altitude=fl.periapsis.altitude;m9.periapsis.speed=fl.periapsis.speed end;if fl.apoapsis~=nil then m9.apoapsis.altitude=fl.apoapsis.altitude;m9.apoapsis.speed=fl.apoapsis.speed end;m9.period=fl.period;m9.eccentricity=fl.eccentricity;m9.timeToApoapsis=fl.timeToApoapsis;m9.timeToPeriapsis=fl.timeToPeriapsis;m9.eccentricAnomaly=fl.eccentricAnomaly;m9.trueAnomaly=fl.trueAnomaly end;if m9.periapsis==nil then m9.periapsis={}m9.periapsis.altitude=-j3.radius;m9.periapsis.speed=a0 end;if m9.eccentricity==nil then m9.eccentricity=1 end;if m9.apoapsis==nil then m9.apoapsis={}m9.apoapsis.altitude=ca;m9.apoapsis.speed=0 end;if cG<1 then m9.apoapsis.altitude=ca;m9.apoapsis.speed=0 end;if m9.apoapsis.altitude then m7=(m9.apoapsis.altitude+m9.periapsis.altitude+j3.radius*2)/(m5*2)m6=(j3.radius+m9.apoapsis.altitude)/m7*(1-m9.eccentricity)m8=m5-m9.periapsis.altitude/m7-j3.radius/m7;local mn=math.pi;if m9.period~=nil and m9.period>0 and m9.timeToApoapsis~=nil then mn=m9.eccentricAnomaly;if m9.timeToPeriapsis<m9.timeToApoapsis then mn=2*math.pi-mn end end;if cG<1 or mn~=mn then mn=math.pi end;local mo=-m5*math.cos(mn)+m0+mi+m3;local mp=m6*math.sin(mn)+m1+mh+m3;local mq=""jO[#jO+1]='<g clip-path="url(#orbitRect)">'jO[#jO+1]=da([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mq,m0+m2+m3,m1+m2*1.5/2+m3,m5,m6)if m6<1 then jO[#jO+1]=da([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m0+m2+m3-m8,m1+m2*1.5/2+m3,mo,mp)end;jO[#jO+1]=da('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m0+m2+m3-m8,m1+m2*1.5/2+m3,(j3.radius+j3.noAtmosphericDensityAltitude)/m7)jO[#jO+1]=da('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m0+m2+m3-m8,m1+m2*1.5/2+m3,(j3.radius+j3.noAtmosphericDensityAltitude)/m7)jO[#jO+1]=da([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m0+m2+m3,m1+m2*1.5/2+m3,m5,m6)jO[#jO+1]=da('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m0+m2+m3-m8,m1+m2*1.5/2+m3,j3.radius/m7)jO[#jO+1]='</g>'local mr=math.floor(j3.radius/m7+0.5)hd=m0+m2+m3*4+m5;he=m1+m2*1.5/2+5+m3;if m9.apoapsis~=nil and m9.apoapsis.speed<a0 then ma("Apoapsis")end;he=m1+m2*1.5/2+5+m3;hd=m0+m2-m3*2-m5;if m9.periapsis~=nil and m9.periapsis.speed<a0 and m9.periapsis.altitude>0 then ma("Periapsis")end;jO[#jO+1]=gC(m0+m2+m3,m1+20+m3,j3.name,"txtorbbig")jO[#jO+1]=da('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mo,mp)jO[#jO+1]=[[</g>]]return jO else jO[#jO+1]='<g clip-path="url(#orbitRect)">'local ms=""local mt=1.2*(mu-mv)/(m2*2)local mw=1.4*(mx-my)/(m2*1.5)for dB,dm in pairs(e[0])do if dm.center then local hd=m0+m2+dm.center.x/mt;local he=m1+m2*1.5/2+dm.center.y/mw;ms=ms..'<circle cx="'..hd..'" cy="'..he..'" r="'..dm.radius/mt*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dm.name,"Moon")and not string.match(dm.name,"Sanctuary")and not string.match(dm.name,"Space")then ms=ms.."<text x='"..hd.."' y='"..he+dm.radius/mt*30+20 .."' font-size='12' fill="..iP.." text-anchor='middle' font-family='Montserrat'>"..dm.name.."</text>"end end end;local fn=vec3(b.getConstructWorldPos())local hd=m0+m2+fn.x/mt;local he=m1+m2*1.5/2+fn.y/mw;ms=ms..'<circle cx="'..hd..'" cy="'..he..'" r="2" stroke="white" stroke-width="1" fill="red"/>'ms=ms.."<text x='"..hd.."' y='"..he-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iB=mt;iC=mw;local mz=fn+cF*1000000;local mA=m0+m2+mz.x/mt;local jz=m1+m2*1.5/2+mz.y/mw;ms=ms..'<line x1="'..hd..'" y1="'..he..'" x2="'..mA..'" y2="'..jz..'" stroke="purple" stroke-width="1"/>'jO[#jO+1]=ms;jO[#jO+1]='</g>'end elseif bE=="INFO"then jO=cm.DrawOdometer(jO,iR,bl,iS)elseif bE=="HELP"then jO=lU(jO)elseif bE=="SCOPE"then jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mB=d0;if c9>0 then table.sort(c_,function(er,es)local et,eu=er.center,es.center;return(et.x-cJ.x)^2+(et.y-cJ.y)^2+(et.z-cJ.z)^2<(eu.x-cJ.x)^2+(eu.y-cJ.y)^2+(eu.z-cJ.z)^2 end)end;local gK={}local mC={}local mD=120;local mE=nil;local mF=nil;for L,dm in ipairs(c_)do local gJ=dm.center-cJ;local mG=gJ:len()local mH=gJ:normalize()local mI=gJ:cross(cC):normalize()local mJ=math.acos(mI:dot(cD))if mJ~=mJ then mJ=0 end;if mI:cross(cD):dot(cC)<0 then mJ=-mJ end;local mK=gJ:project_on_plane(cC):len()local mL=math.sin(mJ)*math.asin(mK/mG)*constants.rad2deg;local mM=math.cos(mJ)*math.asin(mK/mG)*constants.rad2deg;if mH:dot(cC)<0 then mM=90*math.cos(mJ)+90*math.cos(mJ)-mM;mL=90*math.sin(mJ)+90*math.sin(mJ)-mL end;local hd=mj+mL/mB*mf;local he=mk+mM/mB*mf;local mN=(hd-mj)*(hd-mj)+(he-mk)*(he-mk)local mO=math.asin((dm.radius+dm.surfaceMaxAltitude)/mG)*constants.rad2deg;if mO~=mO then mO=mB end;local hJ=mO/mB*mf;local mP=math.asin(dm.atmosphereRadius/mG)*constants.rad2deg;if mP~=mP then mP=mO end;local mQ=mP/mB*mf;local c3=is(mG,1)local mR=dm.name;local mS=false;if he>m1 then if he>mm then if he-mQ<=mm then mS=true end else mS=true end else if he+mQ>=m1 then mS=true end end;local mT=false;local mU=hd;if dm.systemId==0 then mU=hd+mD else mU=hd-mD end;if mU+mD>m0 then if mU+mD>ml then if mU-mQ-mD<=ml then mT=true end else mT=true end else if mU+mQ+mD>=m0 then mT=true end end;local mV={}mV.x=hd;mV.y=he;mV.planet=dm;mV.atmoSize=mQ;if not mE or mN<mE then mE=mN;mF=mV end;if mT and mS then local mW=math.max(mQ,5)if mN<mW*mW then mR=mR.." - "..c3 end;mV.size=hJ;mV.i=L;mV.displayString=mR;mV.distance=c3;mV.visible=true;mC[#mC+1]=mV else mV.visible=false end end;local mX=false;table.sort(mC,function(et,eu)return et.y<eu.y end)for dB,fq in ipairs(mC)do local dm,hJ,L,mQ,hd,he,mR,c3=fq.planet,fq.size,fq.i,fq.atmoSize,fq.x,fq.y,fq.displayString,fq.distance;local md,mY,mZ,m_;local n0=15;local jI="pdim"if dm.systemId~=0 then mZ=j4(string.len(mR)*5)n0=-(15+mZ)m_=j5(10)jI="pdimfill"else mZ=j4(string.len(mR)*9)m_=j5(15)end;if hJ*2>mZ then md=db(hd,m0+mZ/2,ml-mZ/2)mY=db(he,m1+m_,mm-5)md=db(md,hd-hJ+mZ/2,hd+hJ-mZ/2)mY=db(mY,he-hJ+m_,he+hJ)else md=hd+n0;mY=he end;for n1,fq in pairs(gK)do local n2=fq.textPositions;local n3=n2.y-mY;if n1~=L and eQ(n3)<n2.height and n2.x+n2.width>md and n2.x<md+mZ then if hJ>mZ then mY=db(mY+m_,m1+15,mm-5)else mY=n2.y+n2.height+1 end end end;local n4=mR~=dm.name or md<=mj and md+mZ>=mj and mY-m_<=mk and mY>=mk;fq.hovered=n4;local n5=1;if n4 then n5=2;if hJ*2<mZ then n5=10 end;if mR==dm.name then mR=mR.." - "..c3 end;jI="pbright"if dm.systemId~=0 then mZ=j4(string.len(mR)*5)n0=-(15+mZ)else mZ=j4(string.len(mR)*7)end;if hJ*2>mZ then md=db(hd,m0+mZ/2,ml-mZ/2)md=db(md,hd-hJ+mZ/2,hd+hJ-mZ/2)else md=hd+n0 end end;gK[L]={}gK[L].textPositions={}gK[L].textPositions.y=mY;gK[L].textPositions.x=md;gK[L].textPositions.width=mZ;gK[L].textPositions.height=m_;gK[L].output=""if hJ*2>mZ then jI=jI.." txtmid"else jI=jI.." txtstart"end;if mQ-hJ>2 then gK[L].output=da('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hd,he,mQ,iQ,0.1*n5)end;gK[L].output=gK[L].output..da('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hd,he,hJ,iQ,0.2*n5)if dm.systemId==0 then gK[L].output=gK[L].output..da([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],md,mY,iP,jI,mR)if hJ*2<=mZ then gK[L].output=gK[L].output..da("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",md+mZ,mY+2,md,mY+2,hd,he)end else gK[L].output=gK[L].output..da([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],md,mY,iQ,jI,mR)if hJ*2<=mZ then gK[L].output=gK[L].output..da("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",md,mY+2,md+mZ,mY+2,hd,he)end end end;for dB=#c_,1,-1 do if gK[dB]then jO[#jO+1]=gK[dB].output end end;if mF~=nil and d0<90 and not mF.hovered then local n6=mF.planet.atmosphereRadius/mF.atmoSize;local n7=dd(mE)*n6;local n8=is(n7,1)local mZ=j4(math.max(string.len(n8)*7,string.len(mF.planet.name)*7))local m_=j5(12)local md=db(mF.x+(mj-mF.x)/2,m0+mZ/2,ml-mZ/2)local mY=db(mF.y+(mk-mF.y)/2,m1+m_*2,mm-5)jO[#jO+1]=da("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mF.x,mF.y,mj,mk)jO[#jO+1]=da([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],md,mY,"white",n8)if not mF.visible then jO[#jO+1]=da([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],md,mY-m_,"white",mF.planet.name)end end;if cG>1 then local gJ=cF;local mH=gJ:normalize()local mK=gJ:project_on_plane(cC):len()local mI=gJ:cross(cC):normalize()local mJ=math.acos(mI:dot(cD))if mJ~=mJ then mJ=0 end;if mI:cross(cD):dot(cC)<0 then mJ=-mJ end;local mL=math.sin(mJ)*math.asin(mK/gJ:len())*constants.rad2deg;local mM=math.cos(mJ)*math.asin(mK/gJ:len())*constants.rad2deg;if mH:dot(cC)<0 then mM=90*math.cos(mJ)+90*math.cos(mJ)-mM;mL=90*math.sin(mJ)+90*math.sin(mJ)-mL end;local hd=mj+mL/mB*mf;local he=mk+mM/mB*mf;local kJ=14;local kK=kJ/2;local kN=[[<circle
                                    cx="]]..hd..[["
                                    cy="]]..he..[["
                                    r="]]..kK/kJ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hd..[["
                                    cy="]]..he..[["
                                    r="]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hd-kJ..[[,]]..he..[[ h ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hd+kK..[[,]]..he..[[ h ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hd..[[,]]..he-kJ..[[ v ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jO[#jO+1]=kN end;jO[#jO+1]=da("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mj,mk-10,mj,mk+10)jO[#jO+1]=da("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mj-10,mk,mj+10,mk)jO[#jO+1]='</g>'else return jO end end;local function n9(na,nb)local nc;local nd=(nb-na):normalize()local fo=(cJ-na):dot(nd)/nd:dot(nd)if fo<=0. then return(cJ-na):len()elseif fo>=(nb-na):len()then return(cJ-nb):len()end;local ne=na+fo*nd;nc=(ne-cJ):len()return nc end;local function nf()local nc;local ng=nil;local nh=nil;local ni=nil;for dB,nj in pairs(e[0])do if nj.hasAtmosphere then local c3=n9(j3.center,nj.center)if ng==nil or c3<ng then nh=nj;ng=c3;ni=j3 end;if c0 and c0.hasAtmosphere and c0.name~=j3.name then local eG=n9(c0.center,nj.center)if eG<ng then nh=nj;ng=eG;ni=c0 end end end end;local nk=j4(1770)local nl=j5(330)if ng then local nm="txttick "local nn=500000;if ng<nh.radius+nn or ng<ni.radius+nn then if cQ then nm="txttick red "else nm="txttick orange "end end;nc=is(ng,2)iG=gC(nk,nl,"Pipe ("..ni.name.."--"..nh.name.."): "..nc,nm.."pbright txtmid")end end;local function no(hd,he,np,nq,kW)local nr={x=hd,y=he,width=np,height=nq,label=kW}iA[kW]=nr;return nr end;local function ns(nt,nu,np,nq,hd,he,nv,nw,nx,ny,jI)local nr={enableName=nt,disableName=nu,width=np,height=nq,x=hd,y=he,toggleVar=nv,toggleFunction=nw,drawCondition=nx,hovered=false,class=jI}if ny then table.insert(iz,nr)else table.insert(iy,nr)end;return nr end;local function nz(nA)if not iE then nB=false;nC=false;nD=false;x=true;return elseif nA=="handling"then nB=not nB;nC=false;nD=false elseif nA=="hud"then nC=not nC;nB=false;nD=false elseif nA=="physics"then nD=not nD;nB=false;nC=false end;if nD or nC or nB then iF=ir(nA)x=false else iF="none"x=true end end;local function nE()iE=not iE;if iE then ix=iz;bW="Hold SHIFT to see Settings"d1=x else ix=iy;bW="Hold SHIFT to see Control Buttons"nz()x=d1 end end;local function nF()local function nG(dm,dB)dm.set(not dm.get())if dm.get()then bW=dB.." set to true"else bW=dB.." set to false"end;if dB=="showHud"then d1=dm.get()elseif dB=="BrakeToggleDefault"then aX=j end end;local nH=50;local nI=340;local hd=500;local he=ce/2-400;local nJ=0;for dB,dm in pairs(ir("boolean"))do if type(dm.get())=="boolean"then ns(dB,dB,nI,nH,hd,he,function()return dm.get()end,function()nG(dm,dB)end,function()return true end,true)he=he+nH+20;if nJ==9 then hd=hd+nI+20;he=ce/2-400;nJ=0 else nJ=nJ+1 end end end;ns("Control View","Control View",nI,nH,10,ce/2-500,function()return true end,nE,function()return true end,true)ns("View Handling Settings",'Hide Handling Settings',nI,nH,10,ce/2-(500-nH),function()return nB end,function()nz("handling")end,function()return true end,true)ns("View Hud Settings",'Hide Hud Settings',nI,nH,10,ce/2-(500-nH*2),function()return nC end,function()nz("hud")end,function()return true end,true)ns("View Physics Settings",'Hide Physics Settings',nI,nH,10,ce/2-(500-nH*3),function()return nD end,function()nz("physics")end,function()return true end,true)end;local function nK()local function go()local fO=cJ;local gp=j3.name..". "..#bn;if radar_1 then gp=cp.GetClosestName(gp)end;return cn.AddNewLocation(gp,fO,false,true)end;local function nL()b2=not b2 end;local function nM(nN)if nN==1 then b0=not b0;a_=false else a_=not a_;b0=false end;b1=false;b3=false;bU=false;b4=false;br=nil;b6=false;b5=false end;local function nO(nP)cn.UpdatePosition(nil,nP)end;local function gj()cn.ClearCurrentPosition()end;local function nQ(gn)local lT=co.routeWP(true)if lT and#lT>0 then return"Engage Route: "..lT[1]end;return"Engage Autopilot: "..lR(gn)end;local function nR(gn)local lT=co.routeWP(true)if lT and#lT>0 then return"Next Route Point: "..lT[1]end;return"Disable Autopilot: "..lR(gn)end;local function nS()if il()==1 then bU=not bU;if bU then b1=false;a_=false;b0=false;b3=false;b6=false;b4=false;b5=false;nT=bk;bk=false;d.control.retractLandingGears()im:setTargetGroundAltitude(Y)fM("folOn","F")else fM("folOff","F")aZ=true;cu=p;bk=nT;if bk then d.control.extendLandingGears()im:setTargetGroundAltitude(Z)end end else bW="Follow Mode only works with Remote controller"bU=false end end;local nH=50;local nI=260;local nU=j4(30)local nV=ax+aw*2+2;local nW=ay+1;ns("+","+",nU,nU,nV,nW+nU+1,function()return false end,function()d0=d0/8 end,function()return bE=="SCOPE"end,nil,"ZoomButton")ns("-","-",nU,nU,nV,nW,function()return false end,function()d0=math.min(d0*8,90)end,function()return bE=="SCOPE"end,nil,"ZoomButton")ns("0","0",nU,nU,nV,nW+nU*2+2,function()return false end,function()d0=90 end,function()return bE=="SCOPE"and d0~=90 end,nil,"ZoomButton")local nX=ns("Enable Brake Toggle","Disable Brake Toggle",nI,nH,cd/2-nI/2,ce/2+350,function()return aX end,function()aX=not aX;if aX then bW="Brakes in Toggle Mode"else bW="Brakes in Default Mode"end end)ns("Align Prograde","Disable Prograde",nI,nH,cd/2-nI/2-50-nX.width,ce/2-nH+380,function()return b0 end,function()nM(1)end)ns("Align Retrograde","Disable Retrograde",nI,nH,cd/2-nI/2+nX.width+50,ce/2-nH+380,function()return a_ end,nM,function()return c9==0 end)nY=ns(nQ,nR,600,60,cd/2-600/2,ce/2-60/2-330,function()return b1 or bo or c5 or bx end,function()end)local L;local function nZ(n_)local gn=cX+n_;if gn>#cP then gn=gn-#cP-1 end;if gn<0 then gn=#cP+gn end;return gn end;o0={}for L=0,10 do local o1=ns(function(eu)local gn=nZ(eu.apExtraIndex)if b1 or bo or c5 or bx then return"Redirect: "..lR(gn)end;return nQ(gn)end,function(eu)local gn=nZ(eu.apExtraIndex)return nR(gn)end,600,60,cd/2-600/2,ce/2-60/2-330+60*L,function(eu)local gn=nZ(eu.apExtraIndex)return gn==bj and(b1 or bo or c5 or bx)end,function(eu)local gn=nZ(eu.apExtraIndex)local o2=bj==gn;bj=gn;cn.UpdateAutopilotTarget()co.ToggleAutopilot()if not o2 and not(b1 or bo or c5 or bx)then co.ToggleAutopilot()end end,function()return cW and(#co.routeWP(true)==0 or L==0)end)o1.apExtraIndex=L;o0[L]=o1 end;ns("Save Position","Save Position",200,nY.height,nY.x+nY.width+30,nY.y,function()return false end,go,function()return bj==0 or fX==nil end)ns("Update Position","Update Position",200,nY.height,nY.x+nY.width+30,nY.y,function()return false end,function()nO(nil)end,function()return bj>0 and fX~=nil end)ns("Save Heading","Clear Heading",200,nY.height,nY.x+nY.width+30,nY.y+nY.height+20,function()return fX.heading~=nil end,function()if fX.heading~=nil then nO(false)else nO(true)end end,function()return bj>0 and fX~=nil end)ns("Clear Position","Clear Position",200,nY.height,nY.x-200-30,nY.y,function()return true end,gj,function()return bj>0 and fX~=nil end)ns("Save Route","Save Route",200,nY.height,nY.x-200-30,nY.y+nY.height*2+40,function()return false end,function()co.routeWP(false,false,2)end,function()return#co.routeWP(true)>0 end)ns("Load Route","Clear Route",200,nY.height,nY.x-200-30,nY.y+nY.height+20,function()return#co.routeWP(true)>0 end,function()if#co.routeWP(true)>0 then co.routeWP(false,true)elseif b1 or bo then bW="Disable Autopilot before loading route"return else co.routeWP(false,false,1)end end,function()return true end)nH=60;nI=300;local hd=0;local he=ce/2-150;ns("Enable Check Damage","Disable Check Damage",nI,nH,hd,he-nH-20,function()return s end,function()s=not s end)ns("View Settings","View Settings",nI,nH,hd,he,function()return true end,nE)he=he+nH+20;ns("Enable Turn and Burn","Disable Turn and Burn",nI,nH,hd,he,function()return b2 end,nL)hd=10;he=ce/2-300;ns("Horizontal Takeoff Mode","Vertical Takeoff Mode",nI,nH,hd+nI+20,he,function()return aY end,function()aY=not aY;if aY then bW="Vertical Takeoff Mode"else bW="Horizontal Takeoff Mode"end end,function()return cK end)he=he+nH+20;ns("Engage Orbiting","Cancel Orbiting",nI,nH,hd+nI+20,he,function()return bx end,co.ToggleIntoOrbit,function()return c9==0 and cT end)he=ce/2-150;ns("Glide Re-Entry","Cancel Glide Re-Entry",nI,nH,hd+nI+20,he,function()return b6 end,function()c4=1;nM(1)end,function()return j3.hasAtmosphere and not c8 end)he=he+nH+20;ns("Parachute Re-Entry","Cancel Parachute Re-Entry",nI,nH,hd+nI+20,he,function()return b6 end,function()c4=2;nM(1)end,function()return j3.hasAtmosphere and not c8 end)he=he+nH+20;ns("Engage Follow Mode","Disable Follow Mode",nI,nH,hd,he,function()return bU end,nS,function()return il()==1 end)ns("Enable Repair Arrows","Disable Repair Arrows",nI,nH,hd+nI+20,he,function()return iV end,function()iV=not iV;if iV then bW="Repair Arrows Enabled"else bW="Repair Arrows Diabled"end end,function()return il()==1 end)he=he+nH+20;if not q then ns("Enable AGG","Disable AGG",nI,nH,hd,he,function()return cL end,co.ToggleAntigrav,function()return antigrav~=nil end)end;ns(function()return da("Switch IPH Mode - Current: %s",by)end,function()return da("IPH Mode: %s",by)end,nI*2,nH,hd,he,function()return false end,function()if by=="All"then by="Custom Only"elseif by=="Custom Only"then by="No Moons"else by="All"end;bW="IPH Mode: "..by end)he=he+nH+20;ns(function()return da("Toggle Control Scheme - Current: %s",g)end,function()return da("Control Scheme: %s",g)end,nI*2,nH,hd,he,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bW="New Control Scheme: "..g end)local o3=j5(20)local o1=no(0,0,j4(70),o3,"HELP")o1=no(o1.x+o1.width,o1.y,j4(80),o3,"INFO")o1=no(o1.x+o1.width,o1.y,j4(70),o3,"ORBIT")o1=no(o1.x+o1.width,o1.y,j4(70),o3,"SCOPE")no(o1.x+o1.width,o1.y,j4(70),o3,"HIDE")end;local o4={}local o5=nil;function o4.HUDPrologue(jO)cQ,cR=j1(cJ)if not cQ then iM=ag;iN=ah;iO=ai else iM=ad;iN=ae;iO=af end;iP=[[rgb(]]..bH(iM+0.6)..","..bH(iN+0.6)..","..bH(iO+0.6)..[[)]]iQ=[[rgb(]]..bH(iM*0.8+0.5)..","..bH(iN*0.8+0.5)..","..bH(iO*0.8+0.5)..[[)]]local o6=iP;local o7=iQ;local o8=[[rgb(]]..bH(iM*0.4+0.5)..","..bH(iN*0.4+0.5)..","..bH(iO*0.4+0.5)..[[)]]local o9=iP;local oa=iQ;local ob=o8;if j6()and not m then o6=[[rgb(]]..bH(iM*0.5+0.5)..","..bH(iN*0.5+0.5)..","..bH(iO*0.5+0.5)..[[)]]o7=[[rgb(]]..bH(iM*0.3+0.5)..","..bH(iN*0.3+0.5)..","..bH(iO*0.2+0.5)..[[)]]o8=[[rgb(]]..bH(iM*0.2+0.5)..","..bH(iN*0.2+0.5)..","..bH(iO*0.2+0.5)..[[)]]end;local lG=j4;local lH=j5;jO[#jO+1]=da([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o6,o6,o6,o9,o9,o7,o7,oa,oa,o7,o6,o8,oa,o6,o6,o8,o8,ob,o8,cd,ce,o7,o7,o7,o7,o7,o9,o7,oa,ob,oa,oa,ob)if not o5 then o5=da([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lG(630),lH(0),lG(675),lH(45),lG(960),lH(55),lG(1245),lH(45),lG(1290),lH(0),lG(1000),lH(105),lG(1040),lH(59),lG(1250),lH(51),lG(1300),lH(0),lG(1920),lH(0),lG(1920),lH(20),lG(1400),lH(20),lG(1300),lH(105),lG(920),lH(105),lG(880),lH(59),lG(670),lH(51),lG(620),lH(0),lG(0),lH(0),lG(0),lH(20),lG(520),lH(20),lG(620),lH(105),lG(890),lH(59),lG(960),lH(62),lG(1030),lH(59),lG(985),lH(112),lG(1150),lH(112),lG(1100),lH(152),lG(820),lH(152),lG(780),lH(112),lG(935),lH(112),lG(890),lH(59),lG(960),lH(62),lG(1030),lH(59),lG(985),lH(112),lG(1150),lH(112),lG(1100),lH(152),lG(820),lH(152),lG(780),lH(112),lG(935),lH(112))end;if x and I then jO[#jO+1]=o5 end;return jO end;function o4.DrawVerticalSpeed(jO,dV)jN(jO,dV)end;function o4.UpdateHud(jO)local kC=cN;local oc=cO;local jV=oc;local ka=kC;local kU=bH(c.getThrottle())local kZ=cG*3.6;local kV=c.getAxisCommandValue(0)local od=j4(1770)local oe=j5(310)if u and cM then kV=bK;kU=bK*100 end;local j8=j7()local jW="ROLL"if kU==nil then kU=0 end;if not cT then if cG>5 then kC=kB(cE)oc=kD(cE)else kC=0;oc=0 end;jW="YAW"end;if cR>50000 and not c8 then local of;of=is(cR)jO[#jO+1]=gC(od,oe,"PvP Boundary: "..of,"pbright txtbig txtmid")end;jO[#jO+1]=iT;jO[#jO+1]=iK;jO[#jO+1]=h_;if iG~=""then jO[#jO+1]=iG end;if j9~=""then jO[#jO+1]=j9 end;if ja~=""then jO[#jO+1]=ja end;jN(jO,ca)if il()==0 or l then if cT then jU(jO,aj,ak,jV,jW,cT)else jU(jO,aj,ak,oc,jW,cT)end;if not j6()or m then if cT then jU(jO,aj,ak,jV,jW,cT)k9(jO,ka,jV,aj,ak,cT,bH(kD(cE)),cG)else jU(jO,aj,ak,oc,jW,cT)k9(jO,kC,oc,aj,ak,cT,bH(oc),cG)end;kg(jO,ca,cT)kE(jO,cE,cG,aj,ak)end end;kT(jO,j8,kU,kV)kY(jO,kZ)l1(jO)l_(jO)if not iE and bV then lS(jO)end;return jO end;function o4.HUDEpilogue(jO)jO[#jO+1]="</svg>"return jO end;function o4.ExtraData(jO)local og=j4(1240)local oh=j5(55)local oi=oh+10;local gt;local lG=j4;local lH=j5;local oj=0;local j8=j7()if aY then j8=j8 .."-VERTICAL"end;if F and not b5 and not b4 and cG>20 then j8=j8 .."-COLLISION ON"end;if bA~="Off"then j8="("..bA..")-"..j8 end;if b2 then j8="TB-"..j8 end;if not bz then j8=j8 .."-DeCoupled"end;local ok=lH(99)local ol=lH(80)local om=lH(85)local on=lH(31)local oo=0;local op=0;local oq=cb>1000000 and ip(cb/1000000,2).."kT"or ip(cb/1000,2).."T"if c8 then oj=bs else oj=bq end;local os,ot=cj.computeDistanceAndTime(cG,0,cb,0,0,oj)if os<0 then os=0 end;oj=ip(oj/(cb*iw),2).."g"local ou=d:maxForceForward()gt=b.g()if gt>0.1 then op=cb*gt;op=ip(op/(cb*iw),2).."g"oo=0.5*ou/gt;oo=oo>1000000 and ip(oo/1000000,2).."kT"or ip(oo/1000,2).."T"end;ou=ip(ou/(cb*iw),2).."g"local ov=vec3(b.getWorldAcceleration()):len()/9.80665;gt=b.g()jO[#jO+1]=[[<g class="dim txt txtend size14">]]if il()==1 and not l then og=j4(1120)oh=j5(55)oi=oh+10 elseif c8 and I then local ow=j4(770)jO[#jO+1]=gC(lG(895),ok,"ATMO","")jO[#jO+1]=da([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lG(895),om,lG(-80))jO[#jO+1]=gC(lG(815),ol,da("%.1f%%",c9*100),"txtstart size20")end;if I then jO[#jO+1]=gC(lG(1025),ok,"GRAVITY","txtstart")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(1025),om,lG(80))jO[#jO+1]=gC(lG(1105),ol,da("%.2fg",gt/9.80665),"size20")jO[#jO+1]=gC(lG(1125),ok,"ACCEL","txtstart")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(1125),om,lG(80))jO[#jO+1]=gC(lG(1205),ol,da("%.2fg",ov),"size20")jO[#jO+1]=gC(lG(695),ok,"BRK TIME","")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(695),om,lG(-80))jO[#jO+1]=gC(lG(615),ol,da("%s",it(ot)),"txtstart size20")jO[#jO+1]=gC(lG(635),lH(45),"TRIP","")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(635),lH(31),lG(-90))if lA then jO[#jO+1]=gC(lG(545),lH(26),da("%s",it(lA)),"txtstart size20")end;jO[#jO+1]=gC(lG(795),ok,"BRK DIST","")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(795),om,lG(-80))jO[#jO+1]=gC(lG(715),ol,da("%s",is(os)),"txtstart size20")jO[#jO+1]=gC(lG(1285),lH(45),"MASS","txtstart")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(1285),lH(31),lG(90))jO[#jO+1]=gC(lG(1375),lH(26),da("%s",oq),"size20")jO[#jO+1]=gC(lG(1220),ok,"THRUST","txtstart")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lG(1220),om,lG(80))jO[#jO+1]=gC(lG(1300),ol,da("%s",ou),"size20")jO[#jO+1]=gC(j4(960),j5(175),j8,"pbright txtbig txtmid size20")end;jO[#jO+1]="</g>"end;local ox=1-(a6*0.05+a7*0.05)function o4.FuelUsed(oy)local oz;if oy=="atmofueltank"then oz=da("Atmo Fuel Used: %.1f L",jq[oy]/(4*ox))elseif oy=="spacefueltank"then oz=da("Space Fuel Used: %.1f L",jq[oy]/(6*ox))else oz=da("Rocket Fuel Used: %.1f L",jq[oy]/(0.8*ox))end;return oz end;function o4.DrawOdometer(jO,iR,bl,iS)if bE~="INFO"then return jO end;local gt;local oo=0;local op=0;local oj=0;local oq=cb>1000000 and ip(cb/1000000,2).." kTons"or ip(cb/1000,2).." Tons"if c8 then oj=bs else oj=bq end;local os,ot=cj.computeDistanceAndTime(cG,0,cb,0,0,oj)oj=ip(oj/(cb*iw),2).." g"local ou=d:maxForceForward()gt=b.g()if gt>0.1 then op=cb*gt;op=ip(op/(cb*iw),2).." g"oo=0.5*ou/gt;oo=oo>1000000 and ip(oo/1000000,2).." kTons"or ip(oo/1000,2).." Tons"end;ou=ip(ou/(cb*iw),2).." g"if il()==0 or l then local oA=j4(ax+10)local oB=j5(ay+20)local oC=j4(ax+10+aw/1.25)local nq=25;jO[#jO+1]="<g class='txtstart size14 bright'>"jO[#jO+1]=gC(oA,oB,da("BrkTime: %s",it(ot)))jO[#jO+1]=gC(oC,oB,da("Trip: %.2f km",iR))jO[#jO+1]=gC(oA,oB+nq,da("Lifetime: %.2f kSU",bl/200000))jO[#jO+1]=gC(oC,oB+nq,da("BrkDist: %s",is(os)))jO[#jO+1]=gC(oA,oB+nq*2,"Trip Time: "..it(iS))jO[#jO+1]=gC(oC,oB+nq*2,"Total Time: "..it(bm))jO[#jO+1]=gC(oA,oB+nq*3,da("Mass: %s",oq))jO[#jO+1]=gC(oC,oB+nq*3,da("Max Brake: %s",oj))jO[#jO+1]=gC(oA,oB+nq*4,da("Max Thrust: %s",ou))if gt>0.1 then jO[#jO+1]=gC(oC,oB+nq*4,da("Max Thrust Mass: %s",oo))jO[#jO+1]=gC(oA,oB+nq*5,da("Req Thrust: %s",op))else jO[#jO+1]=gC(oC,oB+nq*4,"Max Mass: n/a")jO[#jO+1]=gC(oA,oB+nq*5,"Req Thrust: n/a")end;jO[#jO+1]=gC(oC,oB+nq*5,cm.FuelUsed("atmofueltank"))jO[#jO+1]=gC(oA,oB+nq*6,cm.FuelUsed("spacefueltank"))jO[#jO+1]=gC(oC,oB+nq*6,cm.FuelUsed("rocketfueltank"))if cG>833 then local oD=cb/math.sqrt(1-(cG/8333.33)^2)local oq=oD>1000000 and ip(oD/1000000,2).." kTons"or ip(oD/1000,2).." Tons"jO[#jO+1]=gC(oC,oB+nq*7,da("Rel. Mass: %s",oq))end end;jO[#jO+1]="</g></g>"return jO end;function o4.DrawWarnings(jO)return l1(jO)end;function o4.DisplayOrbitScreen(jO)return l_(jO)end;function o4.DisplayMessage(jO,ln)if ln~="empty"then local he=310;for oE in string.gmatch(ln,"([^\n]+)")do he=he+35;jO[#jO+1]=gC("50%",he,oE,"msg")end end;if bX~=0 then c.setTimer("msgTick",bX)bX=0 end end;function o4.DrawDeadZone(jO)jO[#jO+1]=da([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],av)end;function o4.UpdatePipe()if c8 then iG=""return end;nf()end;function o4.DrawSettings(jO)local hd=j4(640)local he=j5(200)jO[#jO+1]=[[<g class="pbright txtvspd txtstart">]]local hH=0;for dB,dm in pairs(iF)do hH=hH+1;jO[#jO+1]=gC(hd,he,dB..": "..dm.get())he=he+20;if hH%12==0 then hd=hd+j4(350)he=j5(200)end end;jO[#jO+1]=gC(j4(640),j5(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jO[#jO+1]="</g>"return jO end;local hX=j4(1770)local hY=j5(350)local hW=j5(15)local hV=j4(1370)local i0,oF;function o4.DrawRadarInfo()h_=cp.GetRadarHud(hV,hW,hX,hY)end;function o4.DrawTanks()if ar~=0 and as~=0 then j9=gC(ar,as,"","txtstart pdim txtfuel")jr=as;js(ar,"Atmospheric ","ATMO",cf,jo,jp)js(ar,"Space Fuel T","SPACE",cg,jm,jn)js(ar,"Rocket Fuel ","ROCKET",ch,jk,jl)end end;function o4.DrawShield()local i6=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local oG=b.getPvPTimer()local oH=shield_1.getResistances()local oI="A: "..10+oH[1]*100 .."% / E: "..10+oH[2]*100 .."% / K:"..10+oH[3]*100 .."% / T: "..10+oH[4]*100 .."%"local hd,he=at-60,au+30;local jG=bH(d8*2.55)local jH=da("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""ja=gC(hd,he,"","txtmid pdim txtfuel")if d8<10 and i6~="Shield Disabled"then jI="red "end;oG=oG>0 and"   PvPTime: "..it(oG)or""ja=ja..da([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hd,he,jH,d8*2,hd,he,hd+2,he+10,d8,oG)ja=ja..gC(hd,he-5,i6,jI.."txtstart pbright txtbig")ja=ja..gC(hd,he+30,oI,jI.."txtstart pbright txtsmall")end;function o4.hudtick()if not j3 then return end;local function oJ(jO)local jK=bH(db(c3/(cd/4)*255,0,255))jO[#jO+1]=da("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c1,c2,bH(iM+0.5)+jK,bH(iN+0.5)-jK,bH(iO+0.5)-jK)end;local function oK()for dG,dm in pairs(ix)do if dm.hovered then if not dm.drawCondition or dm.drawCondition(dm)then dm.toggleFunction(dm)end;dm.hovered=false end end;for dG,dm in pairs(iA)do if dm.hovered then bE=dm.label;dm.hovered=false end end end;local function oL()local function oM(oN,oO,hd,he,np,nq)if oN>=hd and oN<=hd+np and oO>=he and oO<=he+nq then return true else return false end end;local hd=c1+cd/2;local he=c2+ce/2;for dG,dm in pairs(ix)do dm.hovered=oM(hd,he,dm.x,dm.y,dm.width,dm.height)end;for dG,dm in pairs(iA)do dm.hovered=oM(hd,he,dm.x,dm.y,dm.width,dm.height)end;if cW then local n4=false;for dG,eu in ipairs(o0)do if eu.hovered then n4=true;break end end;if nY.hovered then n4=true end;cW=n4 else cW=nY.hovered;if not cW then cX=bj end end end;local function oP(jO)if not bE or bE==""then bE="HELP"end;if x then for dB,dm in pairs(iA)do local jI="dim brightstroke"local oQ=0.2;if bE==dB then jI="pbright dimstroke"oQ=0.6 end;local oR=""if dm.hovered then oQ=0.8;oR=";stroke:white"end;jO[#jO+1]=da([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dm.width,dm.height,dm.x,dm.y,jI,oQ,oR)jO[#jO+1]=gC(dm.x+dm.width/2,dm.y+dm.height/2+5,dm.label,"txt txtmid pdim")end end end;local function oS(jO)local function oT(jO,oU,hover,hd,he,fa,oV,oW,oX,oY,oZ,o1)if type(oY)=="function"then oY=oY(o1)end;if type(oZ)=="function"then oZ=oZ(o1)end;jO[#jO+1]=da("<rect x='%f' y='%f' width='%f' height='%f' fill='",hd,he,fa,oV)if oU then jO[#jO+1]=da("%s'",oW)else jO[#jO+1]=oX end;if hover then jO[#jO+1]=da(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ad,ae,af)else jO[#jO+1]=da(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",ip(ad*0.5,0),ip(ae*0.5,0),ip(af*0.5,0))end;jO[#jO+1]=" rx='5'></rect>"jO[#jO+1]=da("<text x='%f' y='%f' font-size='24' fill='",hd+fa/2,he+oV/2+5)if oU then jO[#jO+1]="black"else jO[#jO+1]="white"end;jO[#jO+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oU then jO[#jO+1]=da("%s</text>",oY)else jO[#jO+1]=da("%s</text>",oZ)end end;local o_=da("rgb(%d,%d,%d)'",ip(ad*0.1,0),ip(ae*0.1,0),ip(af*0.1,0))local p0=da("rgb(%d,%d,%d)",ip(ad*0.8,0),ip(ae*0.8,0),ip(af*0.8,0))local p1=oT;for dG,dm in pairs(ix)do local nu=dm.disableName;local nt=dm.enableName;if type(nu)=="function"then nu=nu(dm)end;if type(nt)=="function"then nt=nt(dm)end;if not dm.drawCondition or dm.drawCondition(dm)then p1(jO,dm.toggleVar(dm),dm.hovered,dm.x,dm.y,dm.width,dm.height,p0,o_,nu,nt,dm)end end end;local p2=ip(cd/2,0)local p3=ip(ce/2,0)local jO={}cm.HUDPrologue(jO)if x then cm.UpdateHud(jO)else if B then cm.DrawVerticalSpeed(jO,ca)end;cm.DrawWarnings(jO)end;if iE and iF~="none"then cm.DrawSettings(jO)end;if radar_1 then cm.DrawRadarInfo()end;cm.HUDEpilogue(jO)jO[#jO+1]=da([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cd,ce)if bW~="empty"then cm.DisplayMessage(jO,bW)end;if il()==0 and g=="virtual joystick"then if w then cm.DrawDeadZone(jO)end end;oP(jO)if io()==0 then if il()==1 and bV then if not p4 then oL()oS(jO)end;if not cs and not ct then local p5=table.concat(jO,"")jO={}jO[#jO+1]=da("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jO[#jO+1]=p5;jO[#jO+1]="</body>"cs=true;jO[#jO+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local p6=table.concat(jO,"")a.setScreen(p6)elseif ct then local p5=table.concat(jO,"")jO={}jO[#jO+1]=da("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jO[#jO+1]=p5;jO[#jO+1]="</body>"end;if not cs then jO[#jO+1]=da([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,c1,c2)end else oK()end else if not bV and il()==0 then oK()if c3>av then if w then oJ(jO)end end elseif bV and(not p4 or not i)then oL()oS(jO)end;jO[#jO+1]=da([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,c1,c2)end;jO[#jO+1]=[[</svg></body>]]p6=table.concat(jO,"")end;function o4.TenthTick()local function p7()local p8=a.createData;local p9=a.createWidget;pa=a.createWidgetPanel("Interplanetary Helper")pb=p9(pa,"value")pc=p8('{"label": "Target Planet", "value": "N/A", "unit":""}')fL(pc,pb)pd=p9(pa,"value")pe=p8('{"label": "distance", "value": "N/A", "unit":""}')fL(pe,pd)gd=p9(pa,"value")gc=p8('{"label": "Travel Time", "value": "N/A", "unit":""}')fL(gc,gd)gb=p9(pa,"value")ga=p8('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fL(ga,gb)gf=p9(pa,"value")ge=p8('{"label": "Target Altitude", "value": "N/A", "unit":""}')fL(ge,gf)g7=p9(pa,"value")g6=p8('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g5=p9(pa,"value")g4=p8('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g3=p9(pa,"value")g2=p8('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g1=p9(pa,"value")g0=p8('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g9=p9(pa,"value")g8=p8('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c8 then fL(g6,g7)fL(g4,g5)fL(g2,g3)fL(g0,g1)fL(g8,g9)end end;local function pf()gB(pa)pa=nil end;local function pg()if not b1 then if fX==nil or fX.planetname~=j3.name then ph=(c0.center-cJ):len()else ph=(fX.position-cJ):len()end end;local fh=cG;local pi=c.getThrottle()/100;if u then pi=bK end;local pj,pk=cj.computeDistanceAndTime(cG,a0,cb,d:maxForceForward()*pi,a2,0)local bZ,b_;if not b2 then bZ,b_=co.GetAutopilotBrakeDistanceAndTime(a0)else bZ,b_=co.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dG,pl;if not b2 and fh>0 then dG,pl=co.GetAutopilotBrakeDistanceAndTime(fh)else dG,pl=co.GetAutopilotTBBrakeDistanceAndTime(fh)end;local pm=0;local pn=0;if bc or not b1 and fh>5 then pn=cj.computeTravelTime(fh,0,ph)elseif bZ+pj<ph then pm=ph-(bZ+pj)pn=cj.computeTravelTime(8333.0556,0,pm)else local po=(ph-bZ)/pj;pj=ph-bZ;pk=pk*po end;if fX~=nil and fX.planetname==j3.name and not b1 then return pn elseif bb then return pl elseif bc then return pn+pl else return pk+b_+pn end end;cm.DrawTanks()if shield_1 then cm.DrawShield()end;if bh~="None"then if pa==nil then p7()end;if bh~=nil then local pp=fX~=nil;local pq=0.5*bs/c0:getGravity(c0.center+vec3(0,0,1)*c0.radius):len()pq=pq>1000000 and ip(pq/1000000,2).." kTons"or ip(pq/1000,2).." Tons"fK(pc,'{"label": "Target", "value": "'..bh..'", "unit":""}')lA=pg()if pp and not b1 then c3=(cJ-fX.position):len()else c3=(bi-cJ):len()end;if not b2 then bZ,b_=co.GetAutopilotBrakeDistanceAndTime(cG)iI,iJ=co.GetAutopilotBrakeDistanceAndTime(a0)else bZ,b_=co.GetAutopilotTBBrakeDistanceAndTime(cG)iI,iJ=co.GetAutopilotTBBrakeDistanceAndTime(a0)end;local ln=is(c3)fK(pe,'{"label": "distance", "value": "'..ln..'"}')fK(gc,'{"label": "Travel Time", "value": "'..it(lA)..'", "unit":""}')ln=is(bZ)fK(g6,'{"label": "Cur Brake distance", "value": "'..ln..'"}')fK(g4,'{"label": "Cur Brake Time", "value": "'..it(b_)..'", "unit":""}')ln=is(iI)fK(g2,'{"label": "Max Brake distance", "value": "'..ln..'"}')fK(g0,'{"label": "Max Brake Time", "value": "'..it(iJ)..'", "unit":""}')fK(ga,'{"label": "Max Brake Mass", "value": "'..da("%s",pq)..'", "unit":""}')ln=is(gg)fK(ge,'{"label": "Target Orbit", "value": "'..ln..'"}')if c9>0 and not pr then a.removeDataFromWidget(g0,g1)a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)pr=true;if not cM and u and(b3 or b6 or c6)then co.cmdThrottle(1)aZ=false;bO=false end end;if c9==0 and pr then if fK(g0,g1)==1 then fL(g0,g1)end;if fK(g2,g3)==1 then fL(g2,g3)end;if fK(g4,g5)==1 then fL(g4,g5)end;if fK(g6,g7)==1 then fL(g6,g7)end;if fK(g8,g9)==1 then fL(g8,g9)end;pr=false end end else pf()end;if warpdrive~=nil then if ij(warpdrive.getData()).destination~="Unknown"and ij(warpdrive.getData()).distance>400000 then warpdrive.show()ps=true else warpdrive.hide()ps=false end end end;function o4.OneSecondTick()local function pt()local jC=bG()local kZ=cG;local pu=jC-iU;if kZ>1.38889 then kZ=kZ/1000;local pv=kZ*(jC-iU)bl=bl+pv;iR=iR+pv end;iS=iS+pu;bm=bm+pu;iU=jC end;local function pw(jO)local px=0;iK=""local py=iv;local pz=0;local pA=0;local pB=0;local jG=0;local jH=""local pC=b.getElementHitPointsById;local pD=b.getElementMaxHitPointsById;local pE={}for dB in pairs(iu)do local pF=0;local pG=0;pG=pD(iu[dB])pF=pC(iu[dB])pz=pz+pF;if pF<pG then if pF==0 then pB=pB+1 else pA=pA+1 end;if iV and#pE==0 then fO=vec3(b.getElementPositionById(iu[dB]))local hd=fO.x;local he=fO.y;local hf=fO.z;table.insert(pE,b.spawnArrowSticker(hd,he,hf+1,"down"))table.insert(pE,b.spawnArrowSticker(hd,he,hf+1,"down"))b.rotateSticker(pE[2],0,0,90)table.insert(pE,b.spawnArrowSticker(hd+1,he,hf,"north"))table.insert(pE,b.spawnArrowSticker(hd+1,he,hf,"north"))b.rotateSticker(pE[4],90,90,0)table.insert(pE,b.spawnArrowSticker(hd-1,he,hf,"south"))table.insert(pE,b.spawnArrowSticker(hd-1,he,hf,"south"))b.rotateSticker(pE[6],90,-90,0)table.insert(pE,b.spawnArrowSticker(hd,he-1,hf,"east"))table.insert(pE,b.spawnArrowSticker(hd,he-1,hf,"east"))b.rotateSticker(pE[8],90,0,90)table.insert(pE,b.spawnArrowSticker(hd,he+1,hf,"west"))table.insert(pE,b.spawnArrowSticker(hd,he+1,hf,"west"))b.rotateSticker(pE[10],-90,0,90)table.insert(pE,iu[dB])end elseif iV and#pE>0 and pE[11]==iu[dB]then for jB in pairs(pE)do b.deleteSticker(pE[jB])end;pE={}end end;px=bH(pz/py*100)if px<100 then jO[#jO+1]=gC(0,0,"","pbright txt")jG=bH(px*2.55)jH=da("rgb(%d,%d,%d)",255-jG,jG,0)if px<100 then jO[#jO+1]=gC("50%",1035,"Elemental Integrity: "..px.."%","txtbig txtmid","fill:"..jH)if pB>0 then jO[#jO+1]=gC("50%",1055,"Disabled Modules: "..pB.." Damaged Modules: "..pA,"txtbig txtmid","fill:"..jH)elseif pA>0 then jO[#jO+1]=gC("50%",1055,"Damaged Modules: "..pA,"txtbig txtmid","fill:"..jH)end end end end;local function pH()if ii then if iL==nil and(d3~=nil or bk)then _autoconf.displayCategoryPanel(ii,weapon_size,"Weapons","weapon",true)iL=_autoconf.panels[_autoconf.panels_size]elseif iL~=nil and d3==nil and not bk then gB(iL)iL=nil end end end;cY=b.getPlayersOnBoard()cZ=b.getDockedConstructs()local jO={}pt()if s then pw(jO)end;pH()cm.UpdatePipe()cm.ExtraData(jO)iT=table.concat(jO,"")collectgarbage("collect")end;function o4.AnimateTick()ct=true;cs=false;c1=0;c2=0;c.stopTimer("animateTick")end;function o4.MsgTick()local jO={}cm.DisplayMessage(jO,"empty")bW="empty"c.stopTimer("msgTick")bX=3 end;function o4.ButtonSetup()nF()nK()ix=iy end;return o4 end;local function pI(d,b,c,a,e,vBooster,hover,pJ,antigrav,warpdrive,dbHud_1,eQ,bH,bI,il,eL,bG,db,im,fK,io,dd,ip,fM,iq,de,is,it,pK,ij,da,fL)local pL={}local function pM(fh)local pN=bd;if not b1 then pN=0 end;if not c8 then return cj.computeDistanceAndTime(fh,pN,cb,0,0,bq-bf*cb)else if bs and bs>0 then return cj.computeDistanceAndTime(fh,pN,cb,0,0,bs-bf*cb)else return 0,0 end end end;local function pO(fh)local pN=bd;if not b1 then pN=0 end;return cj.computeDistanceAndTime(fh,pN,cb,d:maxForceForward(),a2,bq-bf*cb)end;local pP=false;local pQ=0;local pR=0;local pS=0;local pT=bG()local pU=0;local pV=0;local pW=0;local pX=0;local pY=false;local pZ=false;local p_=false;local q0=nil;local q1=0;local q2={}local iH=55;local q3=nil;local q4=false;local q5=false;local q6=false;local q7=0;local q8=0;local q9=0;local qa=0;local qb=0;local qc=0;local qd={VectorToTarget=false}local qe=vec3(b.getConstructWorldOrientationUp())local qf=nil;local qg=""function pL.clearAll()b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"a_=false;b0=false;cS=nil;b3=false;b6=false;b4=false;aZ=false;b5=false;b7=false;bU=false;q5=false;c4=false;c5=false;q6=false;cu=p;bo=false;b2=false;cc=false;br=nil;bx=false;d6=false;d7=nil end;function pL.GetAutopilotBrakeDistanceAndTime(fh)return pM(fh)end;function pL.GetAutopilotTBBrakeDistanceAndTime(fh)return pO(fh)end;local function qh(qi,qj,qk)qj=qj:project_on_plane(qi)qk=qk:project_on_plane(qi)return eL(qj:cross(qk):dot(qi),qj:dot(qk))end;local function ql()local function qm()local qn=-1;local qo=-1;if vBooster then qn=vBooster.getDistance()end;if hover then qo=hover.getDistance()end;if qn~=-1 and qo~=-1 then if qn<qo then return qn else return qo end elseif qn~=-1 then return qn elseif qo~=-1 then return qo else return-1 end end;local qp=qm()local qq=-1;if pJ then qq=pJ.getDistance()end;if qp~=-1 and qq~=-1 then if qp<qq then return qp else return qq end elseif qp~=-1 then return qp else return qq end end;local function qr(j3,eC,qs)local function qt(qu,dN)local eI=vec3(dN)if qu.id==0 then return setmetatable({latitude=eI.x,longitude=eI.y,altitude=eI.z,id=0,systemId=qu.systemId},dP)end;local eJ=eI-qu.center;local c3=eJ:len()local dV=c3-qu.radius;local dT=0;local dU=0;if not de(c3,0)then local eK=eL(eJ.y,eJ.x)dU=eK>=0 and eK or 2*math.pi+eK;dT=math.pi/2-math.acos(eJ.z/c3)end;return setmetatable({latitude=math.deg(dT),longitude=math.deg(dU),altitude=dV,id=qu.id,systemId=qu.systemId},dP)end;local qv=qt(j3,eC)qv="::pos{"..qv.systemId..","..qv.id..","..qv.latitude..","..qv.longitude..","..qv.altitude.."}"if qs then return qv else a.setWaypoint(qv)return true end end;local qw=false;function pL.showWayPoint(j3,eC,qs)return qr(j3,eC,qs)end;function pL.APTick()local function qx()if cV and not b4 then local ej=cV[1]local hM,hN=cV[2],cV[3]local qy=math.min(hM,hN or hM)local qz=qy/cG;local qA=b5 and(cG<42 or c7~=-1)local qB=b3 or bo or br or b1;if qB and not qA and(bZ*1.5>qy or qz<1)then aZ=true;q2={}co.cmdThrottle(0)if b3 then co.ToggleAltitudeHold()end;if br then co.ToggleLockPitch()end;bW="Autopilot Cancelled due to possible collision"if bo or b1 then co.ToggleAutopilot()end;lu=true;b4=true;cu=true end;if qz<11 then cU=ej.name.." COLLISION "..it(qz).." / "..is(qy,2)else cU=ej.name.." collision "..it(qz)end;if qz<6 then fM("alarm","AL",2)end else cU=false end end;local function qC(qD,qE,qF)local function qG(qD,el)qD=vec3(qD)el=vec3(el):normalize()local dw=qD*el;return dw.x+dw.y+dw.z end;local qH=0.001;local qI=1;if not c8 or not cv or c7~=-1 or cG<iH then if qF==nil then qF=aP end;if qE==nil then qE=qH end;qD=vec3(qD):normalize()local qJ=vec3()-qD;local qK=-qG(qJ,b.getConstructWorldOrientationRight())*qI;local qL=-qG(qJ,b.getConstructWorldOrientationUp())*qI;if pR==0 then pR=qK/2 end;if pS==0 then pS=qL/2 end;if eQ(qK)<0.1 then q8=q8-qK*2 else q8=q8-(qK+(qK-pR)*qF)end;if eQ(qL)<0.1 then q7=q7+qL*2 else q7=q7+qL+(qL-pS)*qF end;pR=qK;pS=qL;if eQ(qK)<qE and eQ(qL)<qE then return true end;return false elseif cv and c7==-1 then qD=cF;if qF==nil then qF=aP end;if qE==nil then qE=qH end;qD=vec3(qD):normalize()local qJ=cC-qD;local qK=-qG(qJ,b.getConstructWorldOrientationRight())*qI;local qL=-qG(qJ,b.getConstructWorldOrientationUp())*qI;if pR==0 then pR=qK/2 end;if pS==0 then pS=qL/2 end;if eQ(qK)<0.1 then q8=q8-qK*5 else q8=q8-(qK+(qK-pR)*qF)end;if eQ(qL)<0.1 then q7=q7+qL*5 else q7=q7+qL+(qL-pS)*qF end;pR=qK;pS=qL;if eQ(qK)<qE and eQ(qL)<qE then return true end;return false end end;c8=bI()>0;c9=bI()ca=b.getAltitude()c7=ql()bJ=bG()pT=bJ;if F then qx()end;if antigrav then cL=antigrav.getState()==1 end;local qM=a.getMouseWheel()if qM>0 then co.changeSpd()elseif qM<0 then co.changeSpd(true)else q4=true end;local qN=1;local qO=1;local qP=bJ-pT;local qQ=-math.deg(qh(qe,cF,cC))local qR=math.deg(qh(cD,cF,cC))local gi=cH*-1;cv=c8 and qQ<-M or qQ>M or qR<-N or qR>N;local qS=a.getMouseDeltaX()local qT=a.getMouseDeltaY()if o and not bV then qT=-qT end;q8=0;qa=0;q7=0;fP=ci[0]j3=fP:closestBody(b.getConstructWorldPos())qU=cl(j3)fl=qU:orbitalParameters(b.getConstructWorldPos(),cF)if ca==0 then ca=(cJ-j3.center):len()-j3.radius end;cT=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;local gt=j3:getGravity(b.getConstructWorldPos()):len()*cb;qb=0;ck=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if io()==0 then if il()==1 and bV then if not cs then c1=db(c1+qS,-cd/2,cd/2)c2=db(c2+qT,-ce/2,ce/2)end else c1=0;c2=0 end else c1=db(c1+qS,-cd/2,cd/2)c2=db(c2+qT,-ce/2,ce/2)c3=dd(c1*c1+c2*c2)if not bV and il()==0 then local kL,kM=1,1;if bE=="SCOPE"then kL,kM=d0/90,d0/90 end;if g=="virtual joystick"then if c1>0 and c1>av then q8=q8-(c1-av)*aD*kL elseif c1<0 and c1<av*-1 then q8=q8-(c1+av)*aD*kL else q8=0 end;if c2>0 and c2>av then q7=q7-(c2-av)*aE*kM elseif c2<0 and c2<av*-1 then q7=q7-(c2+av)*aE*kM else q7=0 end else c1=0;c2=0;if g=="mouse"then q7=(-utils.smoothstep(qT,-100,100)+0.5)*2*qN;q8=(-utils.smoothstep(qS,-100,100)+0.5)*2*qO end end end end;local qV=cG>8334;if cG>W/3.6 and not c8 and not b1 and not qV then bW="Space Speed Engine Shutoff reached"co.cmdThrottle(0)end;if not qV and qW then if not aZ then co.BrakeToggle()end;if b1 then co.ToggleAutopilot()end end;qW=qV;if c8 and c9>0.09 then if cG>cw/3.6 and not u and not pP then aZ=true;pP=true elseif not u and pP then if cG<cw/3.6 then aZ=false;pP=false end end end;if aZ then q9=1 else q9=0 end;if b0 then if c4 then aZ=false;local qX=false;if fX and c4==true then qX=qC(fX.position-cJ,0.1)else qX=qC(vec3(cF),0.01)end;cu=true;if qX then co.cmdCruise(bH(cw))if(eQ(cO)<2 or eQ(cN)>85)and cG>=cw/3.6-1 then aZ=false;b0=false;if c4~=2 then q6=true end;if c4==true then c6=true end;c4=false;b1=false;co.BeginReentry()end elseif c8 and u then co.cmdThrottle(1)end elseif cG>iH then qC(vec3(cF),0.01)end end;if a_ then if c8 then a_=false elseif cG>iH then qC(-vec3(cF))end end;if not b0 and c4 and not bx then if c9==0 then if c4~=2 then q6=true end;co.BeginReentry()c4=false;c6=true else c4=false;co.ToggleAutopilot()end end;if c6 and fX and(ca<b8+250 and ca>b8-250)and cG*3.6>cw-250 and eQ(cI)<25 and c9>=0.1 and(fX.position-cJ):len()>2000+ca then co.ToggleAutopilot()c6=false end;if b7 then cu=true;local qY=b8;if cI<-30 then bW="Unable to achieve lift. Safety Landing."bT=0;cu=p;b7=false;b4=true elseif not q and cL or b8<j3.spaceEngineMinAltitude then if cL then qY=antigrav.getBaseAltitude()end;if ca<qY-100 then qc=0;bT=15;aZ=false elseif cI>0 then aZ=true;bT=0 elseif cI<-30 then aZ=true;bT=15 elseif ca>=qY then if cL then if b1 or bo then co.ToggleVerticalTakeoff()else aZ=true;b7=false end;bW="Takeoff complete. Singularity engaged"fM("aggLk","AG")else aZ=false;bW="VTO complete. Engaging Horizontal Flight"fM("vtoc","VT")co.ToggleVerticalTakeoff()end;bT=0 end else if c9>0.08 then qc=0;aZ=false;bT=20 elseif c9<0.08 and c9>0 then aZ=false;if cA then qc=0;bT=20 else bT=0;qc=36;co.cmdCruise(3500)end else cu=p;bx=true;cz=false;qZ=false;pY=false;pW=nil;pX=nil;if q0==nil then q0=j3 end;cy=qY;p_=true;b7=false end end;if qc~=nil then if q_==nil then q_=pid.new(2*0.01,0,2*0.1)end;local r0=db(qc-cN,-N*0.80,N*0.80)q_:inject(r0)local r1=db(q_:get(),-1,1)q7=r1 end end;if bx then local qJ;local r2=false;local r3=is(cy)if q0==nil then q0=j3;if bo then q0=c0 end end;if not p_ then cy=bH(q0.radius+q0.surfaceMaxAltitude+U)if q0.hasAtmosphere then cy=bH(q0.radius+q0.noAtmosphericDensityAltitude+U)end;p_=true end;if qd.VectorToTarget and fX then qJ=fX.position-cJ end;local r4,r5=cl(q0):escapeAndOrbitalSpeed((cJ-q0.center):len()-q0.radius)local r6=cO;if not pY then local r7=false;local r8=false;co.cmdThrottle(0)pX=0;cx="Aligning to orbital path - OrbitHeight: "..r3;if qd.VectorToTarget then qC(qJ:normalize():project_on_plane(cH))r2=cC:dot(qJ:project_on_plane(qe):normalize())>0.95 else qC(cF)r2=qQ<0.5;if cG<150 then r2=true end end;q7=0;pW=0;if cN<=pW+2 and cN>=pW-2 then r7=true else r7=false end;if r6<=pX+2 and r6>=pX-2 then r8=true else r8=false end;if r7 and r8 and r2 then pW=nil;pX=nil;pY=true end else if qd.VectorToTarget then qC(qJ:normalize():project_on_plane(cH))elseif cG>150 then qC(cF)end;q7=0;if qd.VectorToTarget and fX then local bZ,dG=cj.computeDistanceAndTime(cG,cw/3.6,cb,0,0,bq)if cz and qJ:len()>15000+bZ+ca then cx="Orbiting to Target"if ca-100<=q0.noAtmosphericDensityAltitude or lA>fl.timeToPeriapsis and fl.periapsis.altitude<q0.noAtmosphericDensityAltitude then cz=false end elseif cz or qJ:len()<15000+bZ+ca then bW="Orbit complete, proceeding with reentry"fM("orCom","OB")bi=fX.position;q6=true;c6=true;qd.VectorToTarget,qd.AutopilotAlign=false,false;co.ToggleIntoOrbit()co.BeginReentry()return end end;if fl.periapsis~=nil and fl.apoapsis~=nil and fl.eccentricity<1 and ca>cy*0.9 and ca<cy*1.4 then if fl.apoapsis~=nil then if fl.periapsis.altitude>=cy*0.99 and fl.apoapsis.altitude>=cy*0.99 and fl.periapsis.altitude<fl.apoapsis.altitude and fl.periapsis.altitude*1.05>=fl.apoapsis.altitude or cz then if cz then aZ=false;co.cmdThrottle(0)pW=0;if not qd.VectorToTarget then bW="Orbit complete"fM("orCom","OB")co.ToggleIntoOrbit()end else q1=q1+1;if q1>=2 then cz=true end end else cx="Adjusting Orbit - OrbitHeight: "..r3;pZ=true;co.cmdCruise(r5*3.6+1)local r9=cy-ca;if ra==nil then ra=pid.new(0.1,0,1*0.1)end;ra:inject(r9-cI*db(utils.smoothstep(2000-r9,-2000,2000)^6*10,1,10))pW=db(ra:get(),-60,60)end end else local rb=2.75;local rc=eQ(ip(r4*rb))local ox=rc%50;if ox>0 then rc=rc-ox+50 end;aZ=false;if ca<cy*0.8 then cx="Escaping planet gravity - OrbitHeight: "..r3;pW=utils.map(cI,200,0,-15,80)elseif ca>=cy*0.8 and ca<cy*1.15 then cx="Approaching orbital corridor - OrbitHeight: "..r3;rc=rc*0.75;pW=utils.map(cI,100,-100,-15,65)elseif ca>=cy*1.15 and ca<cy*1.5 then cx="Approaching orbital corridor - OrbitHeight: "..r3;rc=rc*0.75;if cI<0 or pZ then pW=utils.map(ca,cy*1.5,cy*1.01,-30,0)else pW=utils.map(ca,cy*0.99,cy*1.5,0,30)end elseif ca>cy*1.5 then cx="Reentering orbital corridor - OrbitHeight: "..r3;pW=-65;local rd=utils.map(cI,-150,-400,1,0.55)rc=rc*rd end;co.cmdCruise(bH(rc))end end;if pW~=nil then if re==nil then re=pid.new(1*0.01,0,5*0.1)end;local rf=pW-cN;re:inject(rf)local rg=db(re:get(),-0.5,0.5)q7=rg end end;if b1 and c9==0 and not c4 then local function rh(i0,fl)a.print(i0)aZ=false;bb=false;b1=false;ri=false;be="Aligning"co.cmdThrottle(0)q5=false;bW=i0;fM("apCom","AP")if fl or c4 then if fl and gg~=nil and not c4 then if not ca or ca==0 then return end;cy=ca;p_=true end;co.ToggleIntoOrbit()end end;local rj,rk=bi,false;if fX and fX.planetname~="Space"then ba=true;if not ri then local rl=(fX.position-c0.center):normalize()local rm=rl:project_on_plane((c0.center-cJ):normalize()):normalize()local rn=c0.center+rm*(c0.radius+gg)local ro=fX.position+(fX.position-c0.center):normalize()*(gg-c0:getAltitude(fX.position))if(cJ-rn):len()<(cJ-ro):len()then rj=rn else rj=ro;bd=0 end;bi=rj;co.showWayPoint(c0,bi)rk=true;ri=true end;bf=0 elseif fX and fX.planetname=="Space"then if not ri then bf=0;rk=true;ba=true;ri=true;rj=fX.position+(cJ-fX.position):normalize()*S;bi=rj end elseif fX==nil then bf=0;if not ri then local rl=(cJ+cF*100000-c0.center):normalize()local rm=rl:project_on_plane((c0.center-cJ):normalize()):normalize()if rm:len()<1 then rl=(cJ+cC*100000-c0.center):normalize()rm=rl:project_on_plane((c0.center-cJ):normalize()):normalize()end;rj=c0.center+rm*(c0.radius+gg)bi=rj;ri=true;rk=true;ba=true;co.showWayPoint(c0,bi)end end;ph=(vec3(rj)-cJ):len()local ly,eA,eB=ci:getPlanetarySystem(0):castIntersections(cJ,cF:normalize(),function(ej)if ej.noAtmosphericDensityAltitude>0 then return ej.radius+ej.noAtmosphericDensityAltitude else return ej.radius+ej.surfaceMaxAltitude*1.5 end end)local lz=eA;if eB~=nil and eA~=nil then lz=math.min(eB,eA)end;if lz~=nil and lz<ph and ly.name==c0.name then ph=lz end;local qX=true;local rp=(c0.center-(cJ+vec3(cF):normalize()*ph)):len()-c0.radius;local ln=is(rp)fK(g8,'{"label": "Projected Altitude", "value": "'..ln..'"}')local bZ,b_;if not b2 then bZ,b_=pM(cG)else bZ,b_=pO(cG)end;if cG>50 and b9 then local qJ=vec3(rj)-cJ;local rq=db(math.deg(qh(qe,cF:normalize(),qJ:normalize()))*cG/500,-90,90)local rr=db(math.deg(qh(cD,cF:normalize(),qJ:normalize()))*cG/500,-90,90)if eQ(rq)<20 and eQ(rr)<20 then rq=rq*2;rr=rr*2 end;if eQ(rq)<2 and eQ(rr)<2 then rq=rq*2;rr=rr*2 end;local qQ=-math.deg(qh(qe,cC,cF:normalize()))local qR=-math.deg(qh(cD,cC,cF:normalize()))if rs==nil then rs=pid.new(2*0.01,0,2*0.1)end;rs:inject(rr-qR)local rt=db(rs:get(),-1,1)q7=q7+rt;if ru==nil then ru=pid.new(2*0.01,0,2*0.1)end;ru:inject(rq-qQ)local rv=db(ru:get(),-1,1)q8=q8+rv;rk=true;if eQ(rq)>2 or eQ(rr)>2 then if be~="Adjusting Trajectory"then be="Adjusting Trajectory"fM("apAdj","AP")end else if be~="Accelerating"then be="Accelerating"fM("apAcc","AP")end end elseif b9 and cG<=50 then qC((rj-cJ):normalize())end;if rp<gg*1.5 then if fX and fX.planetname=="Space"then bd=0 elseif fX==nil then dG,bd=cl(c0):escapeAndOrbitalSpeed(rp)end end;if b1 and not b9 and not bc and not bb then local ly,lz=co.checkLOS((bi-cJ):normalize())if c0.name~=j3.name then if ly~=nil and c0.name~=ly.name and lz<ph then bW="Collision with "..ly.name.." in "..is(lz).."\nClear LOS to continue."bX=5;qw=true else qw=false;bW=""end end end;if not qw then if not bc and not bb and not rk then qX=qC((rj-cJ):normalize())elseif b2 and(bb or bc)then qX=qC(-vec3(cF):normalize())end end;if b9 then if not q5 then aZ=false;co.cmdThrottle(a1)bK=ip(a1,2)q5=true end;local pi=c.getThrottle()if u then pi=bK end;local rw=99999;local ov=-vec3(b.getWorldAcceleration()):dot(cF:normalize())local rx=db(cF:dot((rj-cJ):normalize()),0,cG)if rx>0 or ov>0 then rw=cj.computeTravelTime(rx,ov,ph-bZ)end;if cE:len()>=a0 or pi==0 and q5 or a2/4>rw then b9=false;if be~="Cruising"then fM("apCru","AP")be="Cruising"end;bc=true;co.cmdThrottle(0)end;local ry=ph;if ry<=bZ or H and cR<=bZ+10000 and cQ then if H and cR<=bZ+10000 and cQ then if cR<pQ and cR>2000 then co.ToggleAutopilot()bW="Autopilot cancelled to prevent crossing PvP Line"aZ=true;pQ=cR else pQ=cR;return end end;b9=false;if be~="Braking"then fM("apBrk","AP")be="Braking"end;bb=true;co.cmdThrottle(0)q5=false end elseif bb then if be~="Orbiting to Target"then aZ=true;q9=1 end;if b2 then co.cmdThrottle(1,true)end;local dG,r5=cl(c0):escapeAndOrbitalSpeed((cJ-j3.center):len()-j3.radius)local qJ;if fX then qJ=fX.position-cJ end;if fX and fX.planetname=="Space"and cG<50 then if#q2>0 then aZ=false;co.ToggleAutopilot()co.ToggleAutopilot()return end;rh("Autopilot complete, arrived at space location")aZ=true;q9=1 elseif fX and fX.planetname~="Space"and cG<=r5 and(fl.apoapsis==nil or fl.periapsis==nil or fl.apoapsis.altitude<=0 or fl.periapsis.altitude<=0)then rh("Autopilot complete, commencing reentry")bi=fX.position;c4=true;co.showWayPoint(c0,bi)elseif(fX and fX.planetname~="Space"or fX==nil)and fl.periapsis~=nil and fl.periapsis.altitude>0 and fl.eccentricity<1 or be=="Circularizing"then if be~="Circularizing"then fM("apCir","AP")be="Circularizing"end;if cG<=r5 then if fX then if cF:normalize():dot(qJ:normalize())>0.4 then if be~="Orbiting to Target"then fM("apOrb","OB")be="Orbiting to Target"end;if not rz then aZ=false;co.showWayPoint(c0,fX.position)rz=true end else rh("Autopilot complete, proceeding with reentry")bi=fX.position;c4=true;co.showWayPoint(c0,fX.position)rz=false end else rh("Autopilot completed, setting orbit",true)q9=0 end end elseif be=="Circularizing"then rh("Autopilot complete, fixing Orbit",true)end elseif bc then local ry=ph;if ry<=bZ or H and cR<=bZ+10000 and cQ then if H and cR<=bZ+10000 and cQ then if cR<pQ and cR>2000 then co.ToggleAutopilot()bW="Autopilot cancelled to prevent crossing PvP Line"aZ=true;pQ=cR else pQ=cR;return end end;b9=false;if be~="Braking"then fM("apBrk","AP")be="Braking"end;bb=true end;local pi=c.getThrottle()if u then pi=bK end;if pi>0 then b9=true;if be~="Accelerating"then be="Accelerating"fM("apAcc","AP")end;bc=false end else if qX then if not ba and fX==nil or not ba and fX and fX.planetname~="Space"then if not c4 then bi=vec3(c0.center)+(gg+c0.radius)*cD;rA=qe;rB=cD end;ba=true elseif qX and not qw then b9=true;if be~="Accelerating"then be="Accelerating"fM("apAcc","AP")end;if not q5 then co.cmdThrottle(a1,true)bK=ip(a1,2)q5=true;aZ=false end end end end elseif b1 and(fX~=nil and fX.planetname~="Space"and c9>0)then bW="Autopilot complete, starting reentry"fM("apCom","AP")bi=fX.position;aZ=false;bb=false;b1=false;ri=false;be="Aligning"q9=0;co.cmdThrottle(0)q5=false;b0=true;c4=true;co.showWayPoint(c0,fX.position)end;if bU then cu=true;local rr=0;local fn=cJ+vec3(c.getMasterPlayerRelativePosition())local rC=fn-cJ;local rD=vec3(rC):project_on(cC):len()local rE=vec3(rC):project_on(cD):len()local c3=dd(rD*rD+rE*rE)qC(rC:normalize())local mG=40;local rF=c3<mG;local rG=100;local rH=db((c3-mG)/2,10,rG)q7=0;local qX=eQ(q8)<0.1;if qX and cG<rH and not rF then aZ=false;rr=-20 else aZ=true;rr=0 end;local rI=0;if eQ(rr-cN)>rI then if rJ==nil then rJ=pid.new(2*0.01,0,2*0.1)end;rJ:inject(rr-cN)local rt=rJ:get()q7=rt end end;if b3 or b4 or b6 or bo or br~=nil then local rK=bs;if rK then rK=rK*db(cG/100,0.1,1)*c9 else rK=bq end;if c9<0.01 then rK=bq end;local rL=cC:project_on_plane(cH):normalize():dot(cF)local rM=vec3(b.getWorldAirFrictionAcceleration())local rN=rM:len()*cb;if rL>100 then bZ,b_=cj.computeDistanceAndTime(rL,100,cb,0,0,rK)local rO,rP=cj.computeDistanceAndTime(100,0,cb,0,0,rK*0.55)bZ=bZ+rO else bZ,b_=cj.computeDistanceAndTime(rL,0,cb,0,0,rK*0.55)end;local r9=b8-ca-cI;local rQ=200+cG;if b6 or c4 then rR=2000+cG end;local rS=1;if b5 then rS=db(cG/100,0.1,1)end;local rr=(utils.smoothstep(r9,-rQ,rQ)-0.5)*2*P*rS;if not b6 and not c4 and not bo and cC:dot(cF:normalize())<0.99 then rr=(utils.smoothstep(r9,-rQ*db(20-19*c9*10,1,20),rQ*db(20-19*c9*10,1,20))-0.5)*2*P*db(2-c9*10,1,2)*rS end;if not b3 then rr=0 end;if br~=nil then if cT and not bx then rr=br else br=nil end end;cu=true;local rT=q7;if b6 then local rU=bH(cw)local rV,rW=cj.computeDistanceAndTime(cG,rU/3.6,cb,0,0,bq-j3.gravity*9.8*cb)rV=rV==-1 and 5000 or rV;local rX=ca-(j3.noAtmosphericDensityAltitude+rV)local rY=ca>j3.noAtmosphericDensityAltitude+rV*1.35;if rY then rr=Q;if cG<=rU/3.6 and cG>rU/3.6-10 and eQ(cF:normalize():dot(cC))>0.9 and not cM then bO=false;co.cmdThrottle(1)end elseif(cM or im:getTargetSpeed(axisCommandId.longitudinal)~=rU)and not rY and not c8 then co.cmdCruise(rU,true)end;if cM then if cG>rU/3.6 and not rY then aZ=true else aZ=false end else aZ=false end;if cI>0 then aZ=true end;if not q6 then rr=-80;if ca<j3.surfaceMaxAltitude+(j3.atmosphereThickness-j3.surfaceMaxAltitude)*0.25 then bW="PARACHUTE DEPLOYED at "..ip(ca,0)b6=false;b4=true;lu=true;co.cmdThrottle(0)rr=0;cu=p end elseif j3.noAtmosphericDensityAltitude>0 and rY then cu=true elseif not rY then if not c8 and(cM or im:getTargetSpeed(axisCommandId.longitudinal)~=rU)then co.cmdCruise(rU)end;if cG<rU/3.6+1 then aZ=false;q6=false;b6=false;cu=true end end end;if cG>iH and not c5 and not bo and not b4 and v then qC(vec3(cF))end;if cS or(bo or c5)and bj>0 and c9>0.01 then local qJ;if cS then if type(cS)=="table"then qJ=cS elseif cS<3 and cS>0 then qJ=-cH:cross(cF)*5000 elseif cS>=3 then qJ=cH:cross(cF)*5000 elseif cS<0 then qJ=cF*25000 end elseif fX~=nil then qJ=fX.position-cJ else qJ=c0.center-cJ end;local rq=math.deg(qh(cH:normalize(),cF,qJ))*2;local mJ=math.rad(eQ(cO))if cG>aI and c9>0.01 then local rZ=1000+cG;local r_=(utils.smoothstep(r9-cI*10,-rZ,rZ)-0.5)*2*P;local s0=db(90-r_,0,180)qb=db(rq*2,-s0,s0)local s1=rq;rq=db(db(rq,-M*0.80,M*0.80)*math.cos(mJ)+4*(cN-rr)*math.sin(math.rad(cO)),-M*0.80,M*0.80)local s2=1;if qb~=0 then s2=eQ(mJ/qb)end;s2=(90-db(eQ(qb-cO),0,90))/90;local s3=rr;if eQ(cO)>90 then s3=-s3 end;rr=s2*db(db(s3*math.cos(mJ),-N*0.8,N*0.8)+eQ(db(eQ(s1)*math.sin(mJ),-N*0.80,N*0.80)),-N*0.80,N*0.80)else qb=0;rq=db(rq,-M*0.80,M*0.80)end;local s4=qQ-rq;if cS and eQ(s4)<=0.0001 and(type(cS)=="table"or type(cS)~="table"and cS<0 and eQ(cO)<1)then if cS==-2 then co.ToggleAltitudeHold()end;cS=nil;fM("180Off","BR")return end;if not cv and cG>aI and c9>0.01 then if s5==nil then s5=pid.new(2*0.01,0,2*0.1)end;s5:inject(s4)local rv=db(s5:get(),-1,1)q8=q8+rv elseif c8 and c7>-1 or cG<aI then qC(qJ)elseif cv and c9>0.01 then if(qQ<-M or qQ>M)and c9>0.01 then qC(cF)end;if(qR<-N or qR>N)and c9>0.01 then rr=db(cN-qR,cN-N*0.80,cN+N*0.80)end end;if fX~=nil and not c5 then local qY=j3:getAltitude(fX.position)local rX=qJ:project_on_plane(cH):len()lu=true;if not c5 and not b6 and rX<=bZ and(cF:project_on_plane(cH):normalize():dot(qJ:project_on_plane(cH):normalize())>0.99 or lC=="Finalizing Approach")then lC="Finalizing Approach"if#q2>0 then co.ToggleAutopilot()co.ToggleAutopilot()return end;co.cmdThrottle(0)if b3 then co.ToggleAltitudeHold()bo=true end;aZ=true elseif not b5 then aZ=false end;if lC=="Finalizing Approach"and(rL<0.1 or rX<0.1 or s6~=nil and s6<rX)then if not cL then fM("bklOn","BL")b4=true;d6=true;if fX.heading then d7=fX.heading else d7=nil end end;bo=false;if bh=="STARTINGPOINT"then cn.ClearCurrentPosition()end;lC="Proceeding to Waypoint"cU=false end;s6=rX end elseif bo and c9==0 and b8>j3.noAtmosphericDensityAltitude and not(c5 or b6)then if fX~=nil and c0.name==j3.name then local qJ=fX.position-cJ;local qY=j3:getAltitude(fX.position)local rX=dd(qJ:len()^2-(ca-qY)^2)local rK=bs;if rK then bZ,b_=cj.computeDistanceAndTime(cG,0,cb,0,0,rK/2)lu=true;if rX<=bZ+cG*qP/2 and cF:project_on_plane(cH):normalize():dot(qJ:project_on_plane(cH):normalize())>0.99 then if j3.hasAtmosphere then aZ=false;b0=false;q6=true;c4=false;c6=true;b1=false;co.BeginReentry()end end;s6=rX end end end;if c9==0 and(b3 and b8>j3.noAtmosphericDensityAltitude)and not(c5 or bx or b6)then if not cz and not bx then cy=b8;p_=true;if bo then qd.VectorToTarget=true end;co.ToggleIntoOrbit()bo=false;pY=true end end;if cv and c9>0.01 and c7==-1 and cG>aI and lC~="Finalizing Approach"then qC(cF)rr=db(cN-qR,cN-N*0.80,cN+N*0.80)end;q7=rT;local qq=-1;if b4 then rr=0;if d7 then if rL<0.05 and rL>-0.05 then if cI>-O then aZ=false else aZ=true end;if qC(d7,0.0001)then d7=nil;cu=p else q7=0;cu=true end else aZ=true end else local s7=false;local s8=30;if ck~=nil and ck>0 then local s9=db(c9,0.4,2)local rK=bs*db(cG/100,0.1,1)*s9;local sa=ck*s9+rK-gt;local sb=rK/2-gt;local sc=cG-dd(eQ(sb/2)*20/(0.5*cb))*utils.sign(sb)if sc<0 then sc=0 end;local sd;if cG>100 then local se,dG=cj.computeDistanceAndTime(cG,100,cb,0,0,rK)local sf,dG=cj.computeDistanceAndTime(100,0,cb,0,0,dd(rK))sd=se+sf else sd=cj.computeDistanceAndTime(cG,0,cb,0,0,dd(rK))end;if sd<20 then aZ=false else local sg=0;if sc>100 then local sh,dG=cj.computeDistanceAndTime(sc,100,cb,0,0,sa)local si,dG=cj.computeDistanceAndTime(100,0,cb,0,0,ck*s9+dd(rK)-gt)sg=sh+si else sg,dG=cj.computeDistanceAndTime(sc,0,cb,0,0,ck*s9+dd(rK)-gt)end;sg=(sg+15+cG*qP)*1.1;local sj=fX~=nil and j3:getAltitude(fX.position)>0 and fX.safe;if sj then local qY=j3:getAltitude(fX.position)local sk=ca-qY-100;local qJ=fX.position-cJ;local sl=dd(qJ:len()^2-(ca-qY)^2)if sl>100 then sj=false elseif sk<=sg or sg==-1 then aZ=true;s7=true else aZ=false;s7=true end end;if not sj and t then if sg>=s8 then aZ=true else aZ=false end;s7=true end end end;if not cM then co.cmdThrottle(0)end;im:setTargetGroundAltitude(500)im:activateGroundEngineAltitudeStabilization(500)bz=true;qq=c7;if qq>-1 then if(cG<1 or cF:normalize():dot(cH)<0)and not d7 then b4=false;b3=false;bk=true;if bP then d.control.extendLandingGears()fM("grOut","LG",1)end;im:setTargetGroundAltitude(Z)bT=0;aZ=true;cu=p;d6=false else aZ=true end elseif lu and cF:normalize():dot(-gi)<0.999 then aZ=true;qC()elseif cI<-O and not s7 or(rL>0.05 or rL<-0.05)and d6 then aZ=true elseif not s7 then aZ=false end end end;if b5 or c5 then local ly,eB,eA;if bi~=nil then ly,eB,eA=ci:getPlanetarySystem(0):castIntersections(cJ,(bi-cJ):normalize(),function(ej)return ej.radius+ej.noAtmosphericDensityAltitude end)end;if cL then if ca>=b8-50 then b5=false;if not b1 and not bo then aZ=true;co.cmdThrottle(0)end else b8=antigrav.getBaseAltitude()end elseif eQ(rr)<15 and ca/b8>0.75 then b5=false;if not c5 then if cM and not u then d.control.cancelCurrentControlMasterMode()end elseif c5 and cG<iH then b1=true;c5=false;b3=false;b5=false;co.cmdThrottle(0)elseif c5 then co.cmdThrottle(0)aZ=true end elseif c5 and c9==0 and c0~=nil and(ly==nil or ly.name==c0.name)then b1=true;c5=false;b3=false;b5=false;if not cM then co.cmdThrottle(0)end;b9=true end end;local sm=c7>-1;local sn=cN;if(bo or c5 or cS)and not sm and cG>aI and c9>0.01 then local mJ=math.rad(eQ(cO))sn=cN*eQ(math.cos(mJ))+qR*math.sin(mJ)end;local so=db(rr-sn,-N*0.80,N*0.80)if c9<0.01 and bo then so=db(rr-sn,-85,P)elseif c9<0.01 then so=db(rr-sn,-P,P)end;if eQ(cO)<5 or bo or cS or b4 or sm or b3 then if rJ==nil then rJ=pid.new(5*0.01,0,5*0.1)end;rJ:inject(so)local rt=rJ:get()q7=q7+rt end end;if antigrav~=nil and(antigrav and not q and ca<200000)then if bt==nil or bt<1000 then bt=1000 end;if sp~=bt then sp=bt;antigrav.setBaseAltitude(sp)end end end;function pL.ToggleIntoOrbit()cz=false;pW=nil;pX=nil;q1=0;if c9==0 then if bx then fM("orOff","AP")bx=false;pY=false;q0=nil;cu=p;if b3 then b3=false;b5=false end;qd.VectorToTarget=false;qd.AutopilotAlign=false;p_=false elseif cT then fM("orOn","AP")bx=true;cu=true;if q0==nil then q0=j3 end;if b3 then b3=false;b5=false end else bW="Unable to engage auto-orbit, not near a planet"end else bx=false;pY=false;q0=nil;cu=p;if b3 then b3=false end;qd.VectorToTarget=false;qd.AutopilotAlign=false;p_=false end end;function pL.ToggleVerticalTakeoff()b3=false;if b7 then lu=true;b6=false;b5=false;b4=true;cu=true;bT=0;if c8 and c7==-1 then b4=false;b3=true;bT=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)co.cmdCruise(bH(cw))end else cz=false;bk=false;d.control.retractLandingGears()im:setTargetGroundAltitude(Y)aZ=true end;b7=not b7 end;function pL.checkLOS(qD)local ly,eA,eB=ci:getPlanetarySystem(0):castIntersections(cJ,qD,function(ej)if ej.noAtmosphericDensityAltitude>0 then return ej.radius+ej.noAtmosphericDensityAltitude else return ej.radius+ej.surfaceMaxAltitude*1.5 end end)local lz=eA;if eB~=nil and eA~=nil then lz=math.min(eB,eA)end;if lz~=nil then return ly,lz else return nil,nil end end;function pL.ToggleAutopilot()local function sq(bv)cU=false;bo=not bo;if bo then b2=false;if not b3 and not bv then co.ToggleAltitudeHold()end end;lC="Proceeding to Waypoint"end;local function sr(gp)if gp then for L,dB in pairs(cP)do if dB.name and dB.name==gp then return L end end else return 0 end end;local ss=false;if bJ-pV<1.5 and c9>0 then if not cB then bW="No space engines detected, Orbital Hop not supported"return end;if j3.hasAtmosphere then if c9>0 then b8=j3.noAtmosphericDensityAltitude+U;fM("orH","OH")end;pV=-1;if b1 or bo or bx then return end end else pV=bJ end;ri=false;if(bj>0 or#q2>0)and not b1 and not bo and not c5 and not bx then if 0.5*d:maxForceForward()/b.g()<cb then bW="WARNING: Heavy Loads may affect autopilot performance."bX=5 end;if#q2>0 and not c6 then bj=sr(q2[1])cn.UpdateAutopilotTarget()table.remove(q2,1)bW="Route Autopilot in Progress"local qJ=fX.position-cJ;local rX=qJ:project_on_plane(cH):len()if rX>50000 and fX.planetname==j3.name then ss=true end end;cn.UpdateAutopilotTarget()co.showWayPoint(c0,bi)if J and#q2==0 and bh~="STARTINGPOINT"and cn.findAtlasIndex(bn,"STARTINGPOINT")==-1 and c7>-1 then cn.AddNewLocation("STARTINGPOINT",cJ,false,false)end;if fX~=nil then br=nil;bv=fX.planetname=="Space"if bv then fM("apSpc","AP")if c9~=0 then c5=true;co.ToggleAltitudeHold()else b1=true end elseif j3.name==fX.planetname then lu=true;if c9>0 then if not bo then fM("vtt","AP")sq(bv)if ss then b8=j3.noAtmosphericDensityAltitude+U end end else fM("apOn","AP")if not(c0.name==j3.name and ca<gg*1.5)then cz=false;b1=true elseif not c8 then if bx then co.ToggleIntoOrbit()end;cy=j3.noAtmosphericDensityAltitude+U;p_=true;qd.AutopilotAlign=true;qd.VectorToTarget=true;pY=false;if not bx then co.ToggleIntoOrbit()end end end else fM("apP","AP")a_=false;b0=false;if c9~=0 then c5=true;co.ToggleAltitudeHold()else b1=true end end elseif c9==0 then if fX==nil and(c0.name==j3.name and cT)and not bx then rz=false;cz=false;pY=false;co.ToggleIntoOrbit()else fM("apP","AP")b1=true;a_=false;b0=false;ba=false;bU=false;b3=false;b4=false;b6=false;b5=false;q5=false;br=nil;rz=false end else fM("apP","AP")c5=true;co.ToggleAltitudeHold()end else fM("apOff","AP")co.ResetAutopilots(1)end end;function pL.routeWP(st,su,sv)if sv then if sv==1 then q2={}q2=iq(q2,bC)if#q2>0 then bW="Route Loaded"else bW="No Saved Route found on Databank"end;return q2 else bC={}bC=iq(bC,q2)bW="Route Saved"pK()return end end;if st then return q2 end;if su then q2={}bW="Current Route Cleared"else q2[#q2+1]=fX.name;bW="Added "..fX.name.." to route. "end;return q2 end;function pL.cmdThrottle(dC,sw)if im:getAxisCommandType(0)~=axisCommandType.byThrottle and not sw then d.control.cancelCurrentControlMasterMode()end;im:setThrottleCommand(axisCommandId.longitudinal,dC)bK=db(ip(dC*100,0)/100,-1,1)qf=nil end;function pL.cmdCruise(dC,sw)if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not sw then d.control.cancelCurrentControlMasterMode()end;im:setTargetSpeedCommand(axisCommandId.longitudinal,dC)qf=dC end;function pL.ToggleLockPitch()if br==nil then fM("lkPOn","LP")if not bV then br=cN else br=R end;b5=false;b3=false;b4=false else fM("lkPOff","LP")br=nil end end;function pL.ToggleAltitudeHold()if bJ-pU<1.5 then if j3.hasAtmosphere then if c9>0 then b8=j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude;fM("11","EP")else if cT then b8=j3.noAtmosphericDensityAltitude+U;cy=b8;p_=true;if not bx then co.ToggleIntoOrbit()end;pY=true end end;pU=-1;if b3 or bx or b7 then return end end else pU=bJ end;if cT and c9==0 then cy=ca;p_=true;pY=true;co.ToggleIntoOrbit()if bx then pU=bJ else pU=0 end;return end;b3=not b3;b4=false;b6=false;if b3 then b1=false;b0=false;a_=false;bU=false;cu=true;br=nil;cz=false;if c7~=-1 and cG<20 then fM("lfs","LS")b5=true;if pU>-1 then b8=ca+X end;bk=false;d.control.retractLandingGears()aZ=true;im:setTargetGroundAltitude(Y)if aY and cK then co.ToggleVerticalTakeoff()end else fM("altOn","AH")b5=false;if pU>-1 then if cT then b8=ca end end;if b7 then co.ToggleVerticalTakeoff()end end;if c5 then b8=100000 end else fM("altOff","AH")if bx then co.ToggleIntoOrbit()end;if b7 then co.ToggleVerticalTakeoff()end;cu=p;b5=false;bo=false;pU=0 end end;function pL.ResetAutopilots(pL)if pL then c5=false;b1=false;ba=false;q5=false;b8=ca;ri=false;d6=false end;bo=false;b5=false;b6=false;b0=false;b4=false;d7=nil;sx=false;cS=nil;d6=false;if not cL then b3=false;br=nil end;if b7 then co.ToggleVerticalTakeoff()end;if bx then co.ToggleIntoOrbit()end;cu=p;c4=false;c6=false;bT=0 end;function pL.BrakeToggle()aZ=not aZ;if b4 then b4=false;cu=p end;if aZ then fM("bkOn","B",1)co.ResetAutopilots()else fM("bkOff","B",1)end end;function pL.BeginReentry()if b6 then bW="Re-Entry cancelled"fM("reOff","RE")b6=false;cu=p;b3=false elseif not j3.hasAtmosphere then bW="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bX=5 elseif not q6 then b6=true;if im:getAxisCommandType(0)~=sy.cruise then d.control.cancelCurrentControlMasterMode()end;cu=true;aZ=false;bW="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cw;fM("par","RE")else b6=true;b3=true;cu=true;aZ=false;b8=j3.surfaceMaxAltitude+_;if b8>j3.spaceEngineMinAltitude then b8=j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude end;local sz=is(b8)bW="Beginning Re-entry.  Target speed: "..cw.." Target Altitude: "..sz;fM("glide","RE")co.cmdCruise(bH(cw))end;b5=false end;function pL.ToggleAntigrav()if antigrav and not q then if cL then fM("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bt==nil then bt=ca end;if bt<1000 then bt=1000 end;fM("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pL.changeSpd(sA)local sB=1;if sA then sB=-1 end;if not bV then if u and not p4 and q4 then local sC=bK;bK=ip(db(bK+sB*aB/100,-1,1),2)if bK>=0 and sC<0 then bK=0;q4=false end elseif p4 then if c9>0 or b6 then cw=db(cw+sB*aB,0,V)elseif b1 then a0=db(a0+sB*aB/3.6*100,0,8333.00)end else im:updateCommandFromActionStart(axisCommandId.longitudinal,sB*aB/10)end else if b1 or bo or c5 or bx then cX=cX+1*sB*-1;if cX>#cP then cX=1 end;if cX<1 then cX=#cP end else if not sA then sB=1 else sB=nil end;cn.adjustAutopilotTargetIndex(sB)end end end;function pL.TenthTick()local function sD(gt,sE)if gt==nil then gt=b.g()end;gt=ip(gt,5)if sE~=nil and sE or(q3==nil or q3~=gt)then local fh=cE:len()local sF=ij(c.getData()).maxBrake;if sF~=nil and sF>0 and c8 then sF=sF/db(fh/100,0.1,1)sF=sF/c9;if c9>0.10 then if bs then bs=(bs+sF)/2 else bs=sF end end end;if sF~=nil and sF>0 then bq=sF end;q3=gt end end;sD(nil,true)if qf~=nil then if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or im:getTargetSpeed(axisCommandId.longitudinal)~=qf then co.cmdCruise(qf)else qf=nil end end end;function pL.SatNavTick()if not r then return end;qg=dbHud_1.getStringValue("SPBAutopilotTargetName")if qg~=nil and qg~=""and qg~="SatNavNotChanged"then local dw=ij(dbHud_1.getStringValue("SavedLocations"))if dw~=nil then bn=dw;local gn=-1;local gu;for dB,dm in pairs(bn)do if dm.name and dm.name=="SatNav Location"then gn=dB;break end end;if gn~=-1 then gu=bn[gn]gn=-1;for dB,dm in pairs(e[0])do if dm.name and dm.name=="SatNav Location"then gn=dB;break end end;if gn>-1 then e[0][gn]=gu end;cn.UpdateAtlasLocationsList()bW=gu.name.." position updated"end end;for L=1,#cP do if cP[L].name==qg then bj=L;a.print("Index = "..bj.." "..cP[L].name)cn.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pL.onFlush()local function sG(sH,rH)local sI=vec3()local sJ=vec3()if sH==axisCommandId.longitudinal then sI=vec3(b.getConstructOrientationForward())sJ=cC elseif sH==axisCommandId.vertical then sI=vec3(b.getConstructOrientationUp())sJ=qe elseif sH==axisCommandId.lateral then sI=vec3(b.getConstructOrientationRight())sJ=cD else return vec3()end;local sK=vec3(b.getWorldGravity())local sL=sK:dot(sJ)local sM=vec3(b.getWorldAirFrictionAcceleration())local sN=sM:dot(sJ)local sO=cE:dot(sI)local sP=rH*constants.kph2m;if sQ==nil then sQ=pid.new(10,0,10.0)end;sQ:inject(sP-sO)local sR=sQ:get()local sS=(sR-sN-sL)*sJ;return sS end;local function sT(sH,rH)local sI=vec3()local sJ=vec3()if sH==axisCommandId.longitudinal then sI=vec3(b.getConstructOrientationForward())sJ=cC elseif sH==axisCommandId.vertical then sI=vec3(b.getConstructOrientationUp())sJ=qe elseif sH==axisCommandId.lateral then sI=vec3(b.getConstructOrientationRight())sJ=cD else return vec3()end;local sK=vec3(b.getWorldGravity())local sL=sK:dot(sJ)local sM=vec3(b.getWorldAirFrictionAcceleration())local sN=sM:dot(sJ)local sO=cE:dot(sI)local sP=rH*constants.kph2m;if sU==nil then sU=pid.new(10,0,10.0)end;sU:inject(sP-sO)local sR=sU:get()local sS=(sR-sN-sL)*sJ;return sS end;local function sV(sW,jR,fT)local sX=sW:cross(fT):normalize_inplace()local kC=math.acos(db(sX:dot(-jR),-1,1))*constants.rad2deg;if sX:cross(-jR):dot(fT)<0 then kC=-kC end;return kC end;if antigrav and not q then if not cL and antigrav.getBaseAltitude()~=bt then antigrav.setBaseAltitude(bt)end end;cM=im:getAxisCommandType(0)==axisCommandType.byThrottle;aL=math.max(aL,0.01)aM=math.max(aM,0.01)aG=math.max(aG,0.01)aK=math.max(aK,0.01)aN=math.max(aN,0.01)aO=math.max(aO,0.01)aF=math.max(aF,0.01)local sY=db(bQ+q7+a.getControlDeviceForwardInput(),-1,1)local sZ=db(bR+qa+a.getControlDeviceYawInput(),-1,1)local s_=db(bS+q8-a.getControlDeviceLeftRightInput(),-1,1)local t0=q9;cH=vec3(b.getWorldVertical())if cH==nil or cH:len()==0 then cH=(j3.center-cJ):normalize()end;qe=vec3(b.getConstructWorldOrientationUp())cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cF=vec3(b.getWorldVelocity())cE=vec3(b.getVelocity())cJ=vec3(b.getConstructWorldPos())cb=b.getConstructMass()cG=vec3(cF):len()cI=-cH:dot(cF)cO=getRoll(cH,cC,cD)local t1=cO/180*math.pi;local t2=math.cos(t1)local t3=math.sin(t1)cN=sV(cH,cC,cD*t2+qe*t3)local t4=cF:normalize()local t5=eQ(cO)local t6=utils.sign(cO)local t7=vec3(b.getWorldAngularVelocity())local t8=sY*aL*cD+sZ*aG*cC+s_*aM*qe;if cu==true and cH:len()>0.01 then local t9=eQ(qb-cO)if((b0 or b6 or b4 or c4 or b3 or bx)and t9>0 or c9>0.0 and t9<aH and p)and sZ==0 and eQ(cN)<85 then local ta=qb;local tb=aF;if c9==0 then tb=tb/4;qb=0;ta=0 end;if tc==nil then tc=pid.new(tb*0.01,0,tb*0.1)end;tc:inject(ta-cO)local td=tc:get()t8=t8+td*cC end end;local te=1;local tf=0;local tg=1;bL=0;if c8 and u and cM then if th==nil then th=pid.new(0.1,0,1)end;local ti=0;if aS>0 and not b6 and c9>0.005 and c9<0.1 and cI>-50 then ti=(0.1-c9)*cw*aS end;th:inject(cw/3.6+ti-cF:dot(cC))local tj=th:get()bN=db(tj,-1,1)if not d2 then if bN<bK and c9>0.005 then bM=true;d2=db(bN,0.01,1)else bM=false;d2=bK end end;if tk==nil then tk=pid.new(1*0.01,0,1*0.1)end;tk:inject(cF:len()-cw/3.6-ti)local tl=db(tk:get(),0,1)if c9>0 and cI<-80 or c9>0.005 then bL=tl end;if bL>0 then if bM and bN==0.01 and not d2 then d2=0 end else bN=db(bN,0.01,1)end;local tm=''local tn=vec3()local to=sG(axisCommandId.vertical,bT*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",to,tf)local tp='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tp=tp..aT end;local tq=im:getAxisCommandType(axisCommandId.longitudinal)local tr=im:composeAxisAccelerationFromThrottle(tp,axisCommandId.longitudinal)local ts=sT(axisCommandId.lateral,bw*1000)tm=tm..' , '.."lateral airfoil , lateral ground "tn=tn+ts;if tn:len()>constants.epsilon then d:setEngineForceCommand(tm,tn,tf,'','','',tg)end;d:setEngineForceCommand(tp,tr,te)local tt='thrust analog vertical fueled 'local tu='thrust analog lateral fueled 'if bA=="All"or bA=="Lateral"then tu=tu..aU end;if bA=="All"or bA=="Vertical"then tt=tt..aV end;if bT~=0 or b4 and aZ or not bk and not bz then d:setEngineForceCommand(tt,to,te)else d:setEngineForceCommand(tt,vec3(),te)end;if bw~=0 then d:setEngineForceCommand(tu,ts,te)else d:setEngineForceCommand(tu,vec3(),te)end;if t0==0 then t0=bL end;local tv=-t0*(aN*cF+aO*t4)d:setEngineForceCommand('brake',tv)else if u then if not d2 then d2=bK end end;local rH=c.getAxisCommandValue(0)if not cM then if tk==nil then tk=pid.new(1*0.01,0,1*0.1)end;tk:inject(cF:len()-rH/3.6)local tl=db(tk:get(),0,1)t0=db(t0+tl,0,1)end;local tv=-t0*(aN*cF+aO*t4)d:setEngineForceCommand('brake',tv)local tm=''local tn=vec3()local tw=false;local tp='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tp=tp..aT end;local tq=im:getAxisCommandType(axisCommandId.longitudinal)if tq==axisCommandType.byThrottle then local tr=im:composeAxisAccelerationFromThrottle(tp,axisCommandId.longitudinal)d:setEngineForceCommand(tp,tr,te)elseif tq==axisCommandType.byTargetSpeed then local tr=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tm=tm..' , '..tp;tn=tn+tr;if im:getTargetSpeed(axisCommandId.longitudinal)==0 or im:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-im:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tw=true end end;local tu='thrust analog lateral 'if bA=="All"or bA=="Lateral"then tu=tu..aU end;local tx=im:getAxisCommandType(axisCommandId.lateral)if tx==axisCommandType.byThrottle then local ty=im:composeAxisAccelerationFromThrottle(tu,axisCommandId.lateral)d:setEngineForceCommand(tu,ty,te)elseif tx==axisCommandType.byTargetSpeed then local ts=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tm=tm..' , '..tu;tn=tn+ts end;local tt='thrust analog vertical 'if bA=="All"or bA=="Vertical"then tt=tt..aV end;local tz=im:getAxisCommandType(axisCommandId.vertical)if tz==axisCommandType.byThrottle then local to=im:composeAxisAccelerationFromThrottle(tt,axisCommandId.vertical)if bT~=0 or b4 and aZ then d:setEngineForceCommand(tt,to,te,'airfoil','ground','',tg)else d:setEngineForceCommand(tt,vec3(),te)d:setEngineForceCommand('airfoil vertical',to,te,'airfoil','','',tg)d:setEngineForceCommand('ground vertical',to,te,'ground','','',tg)end elseif tz==axisCommandType.byTargetSpeed then if bT<0 then d:setEngineForceCommand('hover',vec3(),te)end;local tA=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tm=tm..' , '..tt;tn=tn+tA end;if tn:len()>constants.epsilon then if q9~=0 or tw or eQ(t4:dot(cC))<0.5 then tm=tm..', brake'end;d:setEngineForceCommand(tm,tn,tf,'','','',tg)end end;local tB=aK*(t8-t7)local tC=vec3(b.getWorldAirFrictionAngularAcceleration())tB=tB-tC;d:setEngineTorqueCommand('torque',tB,te,'airfoil','','',tg)d:setBoosterCommand('rocket_engine')if bY and not n then local fh=cE:len()local tD=0.15;if not cM then local tE=im:getTargetSpeed(axisCommandId.longitudinal)if fh*3.6>tE*(1-tD)and tF then tF=false;d:toggleBoosters()elseif fh*3.6<tE*(1-tD)and not tF then tF=true;d:toggleBoosters()end else local pi=c.getThrottle()if u then pi=bK*100 end;local rH=pi/100;if bI==0 then rH=rH*a0;if fh>=rH*(1-tD)and tF then tF=false;d:toggleBoosters()elseif fh<rH*(1-tD)and not tF then tF=true;d:toggleBoosters()end else local rU=bH(cw)rH=rH*rU/3.6;if fh>=rH*(1-tD)and tF then tF=false;d:toggleBoosters()elseif fh<rH*(1-tD)and not tF then tF=true;d:toggleBoosters()end end end end end;c7=ql()return pL end;local function tG(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,il,im,io,tH,gB,ip,dW,dc,db,fM,ir,pK)local tI={}local tJ=true;local tK=5;local tL=5;local tM=tK;local tN=tL;local tO=bJ;function tI.startControl(tP)local function tQ(sA)local sB=1;local function tR(tS,sA)local tT={j3.surfaceMaxAltitude+100,j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude,j3.noAtmosphericDensityAltitude+U,j3.radius*(T-1)+j3.noAtmosphericDensityAltitude}local tU=tS;for dG,dm in ipairs(tT)do if sA and tU>dm then tS=dm elseif tS<dm and not sA then tS=dm;break end end;return tS end;if sA then sB=-1 end;if not q and cL then if bV and sA then bt=1000 elseif bt~=nil then bt=bt+sB*tL;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end else bt=sp+sB*100 end elseif b3 or b7 or bx then if bx then if bV then cy=tR(cy,sA)else cy=cy+sB*tK end;if cy<j3.noAtmosphericDensityAltitude then cy=j3.noAtmosphericDensityAltitude end else if bV and c8 then b8=tR(b8,sA)else b8=b8+sB*tK end end else im:updateTargetGroundAltitudeFromActionStart(sB*1.0)end end;local function tV(tW)if not c8 then bW="Flight Assist in Atmo only"return end;local dj=type(tW)if cS==nil then if dj=="table"then if b1 or bo then co.ToggleAutopilot()end;fM("180On","BR")elseif tW==1 then fM("bnkLft","BR")else fM("bnkRht","BR")end;if not b3 and not b1 and not bo then co.ToggleAltitudeHold()if dj~="table"then tW=tW+1 end end;cS=tW else fM("180Off","BR")cS=nil end end;if tP=="gear"then bk=not bk;if bk then bo=false;br=nil;co.cmdThrottle(0)if vBooster or hover then if c8 and c7==-1 then fM("bklOn","BL")lu=true;b6=false;b5=false;b7=false;b3=false;b4=true;d6=false;cu=true;bk=false else if bP then fM("grOut","LG",1)d.control.extendLandingGears()end;im:setTargetGroundAltitude(Z)if c8 then aZ=true end end end;if bP and not b4 and not(vBooster or hover)then fM("grOut","LG",1)d.control.extendLandingGears()end else if bP then fM("grIn","LG",1)d.control.retractLandingGears()end;im:setTargetGroundAltitude(Y)end elseif tP=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif tP=="forward"then bQ=bQ-1 elseif tP=="backward"then if p4 then tV(-cF*5000)else bQ=bQ+1 end elseif tP=="left"then if p4 then tV(1)else bR=bR-1 end elseif tP=="right"then if p4 then tV(3)else bR=bR+1 end elseif tP=="yawright"then bS=bS-1;d7=nil elseif tP=="yawleft"then bS=bS+1;d7=nil elseif tP=="straferight"then im:updateCommandFromActionStart(axisCommandId.lateral,1.0)bw=1 elseif tP=="strafeleft"then im:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bw=-1 elseif tP=="up"then bT=bT+1;im:deactivateGroundEngineAltitudeStabilization()im:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif tP=="down"then bT=bT-1;im:deactivateGroundEngineAltitudeStabilization()im:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif tP=="groundaltitudeup"then tQ()elseif tP=="groundaltitudedown"then tQ(true)elseif tP=="option1"then tX=false;if p4 and bV then local tY=""for L=1,#cY do tY=tY.."| Name: "..a.getPlayerName(cY[L]).." Mass: "..ip(b.getBoardedPlayerMass(cY[L])/1000,1).."t "end;a.print("Onboard: "..tY)return end;cn.adjustAutopilotTargetIndex()elseif tP=="option2"then tX=false;if p4 and bV then for L=1,#cY do b.forceDeboard(cY[L])end;bW="Deboarded All Passengers"return end;cn.adjustAutopilotTargetIndex(1)elseif tP=="option3"then local function tZ()tJ=not tJ;if not tJ then fM("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(t_,atmofueltank_size,"Atmo Fuel","fuel_container")u0=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(u1,spacefueltank_size,"Space Fuel","fuel_container")u2=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(u3,rocketfueltank_size,"Rocket Fuel","fuel_container")u4=_autoconf.panels[_autoconf.panels_size]end;u5=a.createWidgetPanel("Docking")u6=a.createWidget(u5,"parenting")a.addDataToWidget(c.getDataId(),u6)u7=a.createWidgetPanel("Core combat stress")u8=a.createWidget(u7,"core_stress")a.addDataToWidget(b.getDataId(),u8)if shield_1~=nil then shield_1.show()end else fM("hud","DH")c.hide()b.hide()if u0~=nil then gB(u0)u0=nil end;if u5~=nil then gB(u5)u5=nil end;if u7~=nil then gB(u7)u7=nil end;if u2~=nil then gB(u2)u2=nil end;if u4~=nil then gB(u4)u4=nil end;if shield_1~=nil then shield_1.hide()end end end;tX=false;if p4 and bV then local tY=""for L=1,#cZ do tY=tY.."| ID: "..cZ[L].." Mass: "..ip(b.getDockedConstructMass(cZ[L])/1000,1).."t "end;a.print("Docked Ships: "..tY)return end;if y then if x then x=false else x=true end end;tZ()elseif tP=="option4"then tX=false;if p4 and bV then for L=1,#cZ do b.forceUndock(cZ[L])end;bW="Undocked all ships"return end;cS=nil;co.ToggleAutopilot()elseif tP=="option5"then tX=false;co.ToggleLockPitch()elseif tP=="option6"then tX=false;if p4 and bV then if shield_1 then cr.ventShield()else bW="No shield found"end;return end;co.ToggleAltitudeHold()elseif tP=="option7"then tX=false;if p4 and bV then if shield_1 then shield_1.toggle()return else bW="No shield found"return end end;F=not F;if F then bW="Collision System Enabled"else bW="Collision System Secured"end elseif tP=="option8"then tX=false;if p4 and bV then if bj>0 and fX~=nil then co.routeWP()else bW="Select a saved wp on IPH to add to or remove from route"end;return end;bz=not bz;if not bz then bW="DeCoupled Mode - Ground Stabilization off"im:deactivateGroundEngineAltitudeStabilization()fM("gsOff","GS")else bW="Coupled Mode - Ground Stabilization on"im:activateGroundEngineAltitudeStabilization(u9)d:setEngineForceCommand('hover',vec3(),1)fM("gsOn","GS")end elseif tP=="option9"then tX=false;if p4 and bV then im:resetCommand(axisCommandId.longitudinal)im:resetCommand(axisCommandId.lateral)im:resetCommand(axisCommandId.vertical)co.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cc=gyro.getState()==1;if cc then fM("gyOn","GA")else fM("gyOff","GA")end else bW="No gyro found"end elseif tP=="lshift"then cW=false;if p4 then bV=true end;if io()==1 then bV=true;bg=io()tH(1)elseif il()==1 and z then bV=true;ct=false;cs=false end elseif tP=="brake"then if aX or p4 then co.BrakeToggle()elseif not aZ then co.BrakeToggle()else aZ=true end elseif tP=="lalt"then tX=true;p4=true;if il()==0 and not i and g=="keyboard"then tH(1)end elseif tP=="booster"then if n then d:toggleBoosters()elseif not bY then if not tF then d:toggleBoosters()tF=true end;bY=true else if tF then d:toggleBoosters()tF=false end;bY=false end elseif tP=="stopengines"then local function ua()if bJ-tO<1.5 then fM("clear","CA")co.clearAll()end end;ua()tO=bJ;if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then im:resetCommand(axisCommandId.longitudinal)co.cmdThrottle(0)else co.cmdThrottle(100)end else if im:getTargetSpeed(axisCommandId.longitudinal)~=0 then im:resetCommand(axisCommandId.longitudinal)else if c8 then co.cmdCruise(V)else co.cmdCruise(a0*3.6)end end end elseif tP=="speedup"then co.changeSpd()elseif tP=="speeddown"then co.changeSpd(true)elseif tP=="antigravity"and not q then if antigrav~=nil then co.ToggleAntigrav()else bW="No antigrav found"end end end;function tI.stopControl(tP)local function ub()if not q and cL then tN=tL end;if b3 or b7 or bx then tM=tK end end;if tP=="forward"then bQ=0 elseif tP=="backward"then bQ=0 elseif tP=="left"then if cS then if cS==2 then cS=-2 else cS=-1 end end;bR=0 elseif tP=="right"then if cS then if cS==4 then cS=-2 else cS=-1 end end;bR=0 elseif tP=="yawright"then bS=0 elseif tP=="yawleft"then bS=0 elseif tP=="straferight"then im:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bw=0 elseif tP=="strafeleft"then im:updateCommandFromActionStop(axisCommandId.lateral,1.0)bw=0 elseif tP=="up"then bT=0;im:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bz then im:activateGroundEngineAltitudeStabilization(u9)d:setEngineForceCommand('hover',vec3(),1)end elseif tP=="down"then bT=0;im:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bz then im:activateGroundEngineAltitudeStabilization(u9)d:setEngineForceCommand('hover',vec3(),1)end elseif tP=="groundaltitudeup"then ub()tX=false elseif tP=="groundaltitudedown"then ub()tX=false elseif tP=="lshift"then if io()==1 then c1=0;c2=0;tH(bg)elseif il()==1 and z then ct=false;cs=false end;bV=false elseif tP=="brake"then if not aX and not p4 then if aZ then co.BrakeToggle()else aZ=false end end elseif tP=="lalt"then if il()==0 and i then if tX then if io()==1 then tH(0)else tH(1)end else tX=true end elseif il()==0 and not i and g=="keyboard"then tH(0)end;p4=false end end;function tI.loopControl(tP)local function uc(sA)local sB=1;if sA then sB=-1 end;if not q and cL then if bt~=nil then bt=bt+sB*tN;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end;tN=db(tN*1.05,tL,50)else bt=sp+sB*100 end elseif b3 or b7 or bx then if bx then cy=cy+sB*tM;if cy<j3.noAtmosphericDensityAltitude then cy=j3.noAtmosphericDensityAltitude end else b8=b8+sB*tM end;tM=db(tM*1.05,tK,50)else im:updateTargetGroundAltitudeFromActionLoop(sB*1.0)end end;local function ud(sA)local sB=1;if sA then sB=-1 end;if not bV then if u and not p4 then bK=db(bK+sB*aC/100,-1,1)else im:updateCommandFromActionLoop(axisCommandId.longitudinal,sB*aC)end end end;if tP=="groundaltitudeup"then if not bV then uc()end elseif tP=="groundaltitudedown"then if not bV then uc(true)end elseif tP=="speedup"then ud()elseif tP=="speeddown"then ud(true)end end;function tI.inputTextControl(sz)local function ue(uf,fn,gq)local function ug(fn)local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..dt..','..dt..','..dt..','..dt..','..dt..'}'local dK,dL,dT,dU,dV=dW(fn,du)if dK=="0"and dL=="0"then return vec3(dc(dT),dc(dU),dc(dV))end;dU=math.rad(dU)dT=math.rad(dT)local j3=e[dc(dK)][dc(dL)]local eM=math.cos(dT)local uh=vec3(eM*math.cos(dU),eM*math.sin(dU),math.sin(dT))return j3.center+(j3.radius+dV)*uh end;local fO=ug(fn)return cn.AddNewLocation(uf,fO,gq)end;local L;local ui,ia=nil,nil;local uj="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to logfile and screen to cut and paste to privatelocations.lua, all if present will make it include all databank locations."L=string.find(sz," ")ui=sz;if L~=nil then ui=string.sub(sz,0,L-1)ia=string.sub(sz,L+1)end;if ui=="/help"or ui=="/commands"then for oE in string.gmatch(uj,"([^\n]+)")do a.print(oE)end;return elseif ui=="/setname"then if ia==nil or ia==""then bW="Usage: ah-setname Newname"return end;if bj>0 and fX~=nil then cn.UpdatePosition(ia)else bW="Select a saved target to rename first"end elseif shield_1 and ui=="/resist"then cr.setResist(ia)elseif ui=="/addlocation"or string.find(sz,"::pos")~=nil then local gq=false;local uf="0-Temp"if ia==nil or ia==""then ia=ui;gq=true end;L=string.find(ia,"::")if not gq then uf=string.sub(ia,1,L-2)end;local fn=string.sub(ia,L)ue(uf,fn,gq)elseif ui=="/agg"then if ia==nil or ia==""then bW="Usage: /agg targetheight"return end;ia=dc(ia)if ia<1000 then ia=1000 end;bt=ia;bW="AGG Target Height set to "..ia elseif ui=="/G"then if ia==nil or ia==""then bW="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ia=="dump"then for dB,dm in pairs(ir())do if type(dm.get())=="boolean"then if dm.get()==true then a.print(dB.." true")else a.print(dB.." false")end elseif dm.get()==nil then a.print(dB.." nil")else a.print(dB.." "..dm.get())end end;return end;L=string.find(ia," ")local uk=string.sub(ia,0,L-1)local ul=string.sub(ia,L+1)for dB,dm in pairs(ir())do if dB==uk then bW="Variable "..uk.." changed to "..ul;local um=type(dm.get())if um=="number"then ul=dc(ul)if dB=="AtmoSpeedLimit"then cw=ul end elseif um=="boolean"then if string.lower(ul)=="true"then ul=true else ul=false end end;dm.set(ul)return end end;bW="No such global variable: "..uk elseif ui=="/deletewp"then if bj>0 and fX~=nil then cn.ClearCurrentPosition()else bW="Select a custom wp to delete first in IPH"end elseif ui=="/copydatabank"then if dbHud_2 then pK(true)else bW="Spare Databank required to copy databank"end elseif ui=="/iphWP"then if bj>0 then a.print(co.showWayPoint(c0,bi,true))a.print(json.encode(bi))bW="::pos waypoint shown in lua chat in local and world format"else bW="No target selected in IPH"end elseif ui=="/createPrivate"then local un="privatelocations = {\n"local uo=""if#d4>0 then for dB,dm in pairs(d4)do un=un.."{position = {x = "..dm.position.x..", y = "..dm.position.y..", z = "..dm.position.z.."},\n ".."name = '"..dm.name.."',\n planetname = '"..dm.planetname.."',\n gravity = "..dm.gravity..",\n"if dm.heading then un=un.."heading = {x = "..dm.heading.x..", y = "..dm.heading.y..", z = "..dm.heading.z.."},\n"end;if dm.safe then un=un.."safe = true},\n"else un=un.."safe = false},\n"end end end;uo=#d4 .."-Private "if ia=="all"then for dB,dm in pairs(bn)do un=un.."{position = {x = "..dm.position.x..", y = "..dm.position.y..", z = "..dm.position.z.."},\n ".."name = '*"..dm.name.."',\n planetname = '"..dm.planetname.."',\n gravity = "..dm.gravity..",\n"if dm.heading then un=un.."heading = {x = "..dm.heading.x..", y = "..dm.heading.y..", z = "..dm.heading.z.."},\n"end;if dm.safe then un=un.."safe = true},\n"else un=un.."safe = false},\n"end end;uo=uo..#bn.."-Public "end;un=un.."}\n return privatelocations"a.logInfo("PRIVATELOCATIONS:"..un)if screenHud_1 then screenHud_1.setHTML(un)end;bW=uo.."locations dumped to logfile and screen if present.\n Cut and paste to privatelocations.lua to use"bX=7 end end;function tI.tagTick()if bA=="Off"then bA="All"elseif bA=="All"then bA="Longitude"elseif bA=="Longitude"then bA="Lateral"elseif bA=="Lateral"then bA="Vertical"else bA="Off"end;bW="Extra Engine Tags: "..bA;c.stopTimer("tagTick")end;return tI end;local function up(d,b,c,a,library,e,vBooster,hover,pJ,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ii,screenHud_1)local uq={}local da=string.format;local ij=json.decode;local ur=json.encode;local pD=b.getElementMaxHitPointsById;local ik=b.getElementMassById;local il=d.control.isRemoteControlled;local dW=string.match;local gB=a.destroyWidgetPanel;local fK=a.updateData;local fL=a.addDataToWidget;local tH=a.lockView;local io=a.isViewLocked;local dd=math.sqrt;local dc=tonumber;local eQ=math.abs;local bH=math.floor;local bI=c.getAtmosphereDensity;local eL=math.atan;local bG=a.getTime;local db=utils.clamp;local im=d.axisCommandManager;local us=Z;local gD=13;local iu=b.getElementIdList()local iv=0;local function de(et,eu)if et==0 then return eQ(eu)<1e-09 end;if eu==0 then return eQ(et)<1e-09 end;return eQ(et-eu)<math.max(eQ(et),eQ(eu))*ds end;local function ip(dt,ut)local sB=10^(ut or 0)return bH(dt*sB+0.5)/sB end;local function iq(uu,uv)for dB,dm in pairs(uv)do if type(dB)=="string"then uu[dB]=dm else uu[#uu+1]=uv[dB]end end;return uu end;local function ir(uw)local ux={}if not uw then iq(ux,K)iq(ux,a9)iq(ux,aA)iq(ux,aW)return ux elseif uw=="boolean"then return K elseif uw=="handling"then return a9 elseif uw=="hud"then return aA elseif uw=="physics"then return aW end end;local function pK(uy)local function uz(uA)for dB,dm in pairs(uA)do dbHud_1.setStringValue(dB,ur(dm.get()))if uy and dbHud_2 then dbHud_2.setStringValue(dB,ur(dm.get()))end end end;if dbHud_1 then uz(bD)uz(ir())a.print("Saved Variables to Datacore")if uy and dbHud_2 then bW="Databank copied.  Remove copy when ready."end end end;local function fM(uB,uC,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..uB.."|"..uC.."|"..az)else a.logInfo("sound_notification|audiopacks/"..h.."/"..uB.."|"..uC.."|"..az)end else a.logInfo("sound_q|audiopacks/"..h.."/"..uB.."|"..uC.."|"..az)end end;local function gC(hd,he,sz,jI,uD)if jI==nil then jI=""end;if uD==nil then uD=""end;return da([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jI,hd,he,uD,sz)end;local function is(c3,uE)local uF=c3>100000;if uE==nil then uE=1 end;if uF then return ip(c3/1000/200,uE).."SU"elseif c3<1000 then return ip(c3,uE).."M"else return ip(c3/1000,uE).."KM"end end;local function it(uG)local uH=0;local uI=0;local uJ=0;if uG<60 then uG=bH(uG)elseif uG<3600 then uH=bH(uG/60)uG=bH(uG%60)elseif uG<86400 then uI=bH(uG/3600)uH=bH(uG%3600/60)else uJ=bH(uG/86400)uI=bH(uG%86400/3600)end;if uJ>0 then return uJ.."d "..uI.."h "elseif uI>0 then return uI.."h "..uH.."m "elseif uH>0 then return uH.."m "..uG.."s"elseif uG>0 then return uG.."s"else return"0s"end end;function uq.onStart()local uK=false;local function uL()local function uM(uN)local uO=dbHud_1.hasKey;for dB,dm in pairs(uN)do if uO(dB)then local dw=ij(dbHud_1.getStringValue(dB))if dw~=nil then dm.set(dw)uK=true end end end end;if dbHud_1 then if not f then uM(ir())coroutine.yield()uM(bD)else uM(bD)bW="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bX=5;uK=false end;coroutine.yield()if uK then bW="Loaded Saved Variables"cd=aa;ce=ab;aX=j;g=string.lower(g)cu=p;cw=V elseif not f then bW="No Saved Variables Found - Exit HUD to save settings"end;if bB<1.500 then if U<2000 then bW="Updating LowOrbitHeight to new minimum default of 2000."U=2000 end end;bB=VERSION_NUMBER;if#bn>0 then d5=iq(d5,bn)end else bW="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bu+180<bJ then bs=0 end;bu=bJ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bW="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bX=7 end;if antigrav and not q then if bt==nil then bt=ca end;antigrav.setBaseAltitude(bt)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then d4=require("autoconf/custom/archhud/privatelocations")if#d4>0 then d5=iq(d5,d4)end end;lC="Proceeding to Waypoint"end;local function uP()local function uQ(uR,uS)if uR>uS then uS=uR end;local uT,uU=0,0;if a6>0 then uT=a6*0.05 end;if a7>0 then uU=a7*0.05 end;uS=uS*(1-(uT+uU))return uS end;local uV=b.getElementNameById;local uW=ar~=0 and as~=0;for dB in pairs(iu)do local type=b.getElementTypeById(iu[dB])if dW(type,'^.*Atmospheric Engine$')then if dW(tostring(b.getElementTagsById(iu[dB])),'^.*vertical.*$')and b.getElementForwardById(iu[dB])[3]>0 then cK=true end end;if dW(type,'^.*Space Engine$')then cB=true;if dW(tostring(b.getElementTagsById(iu[dB])),'^.*vertical.*$')then local uX=b.getElementForwardById(iu[dB])if uX[3]<0 then uY=true else cA=true end end end;if type=="Landing Gear"then bP=true end;if type=="Dynamic Core Unit"then local pF=pD(iu[dB])if pF>10000 then gD=110 elseif pF>1000 then gD=55 elseif pF>150 then gD=27 end end;iv=iv+pD(iu[dB])if uW and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pF=pD(iu[dB])local oq=ik(iu[dB])local uR=0;local jC=bG()if type=="Atmospheric Fuel Tank"then local uS=400;local uZ=35.03;if pF>10000 then uS=51200;uZ=5480 elseif pF>1300 then uS=6400;uZ=988.67 elseif pF>150 then uS=1600;uZ=182.67 end;uR=oq-uZ;if a3>0 then uS=uS+uS*a3*0.2 end;uS=uQ(uR,uS)cf[#cf+1]={iu[dB],uV(iu[dB]),uS,uZ,uR,jC}end;if type=="Rocket Fuel Tank"then local uS=320;local uZ=173.42;if pF>65000 then uS=40000;uZ=25740 elseif pF>6000 then uS=5120;uZ=4720 elseif pF>700 then uS=640;uZ=886.72 end;uR=oq-uZ;if a5>0 then uS=uS+uS*a5*0.1 end;uS=uQ(uR,uS)ch[#ch+1]={iu[dB],uV(iu[dB]),uS,uZ,uR,jC}end;if type=="Space Fuel Tank"then local uS=600;local uZ=35.03;if pF>10000 then uS=76800;uZ=5480 elseif pF>1300 then uS=9600;uZ=988.67 elseif pF>150 then uS=2400;uZ=182.67 end;uR=oq-uZ;if a4>0 then uS=uS+uS*a4*0.2 end;uS=uQ(uR,uS)cg[#cg+1]={iu[dB],uV(iu[dB]),uS,uZ,uR,jC}end end end;if not cK then b7,aY=false,false end end;local function u_()if gyro~=nil then cc=gyro.getState()==1 end;if not bz then im:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then tH(1)else tH(0)end;if door and(c8 or not c8 and ca<10000)then for dG,dm in pairs(door)do dm.toggle()end end;if switch then for dG,dm in pairs(switch)do dm.toggle()end end;if forcefield and(c8 or not c8==0 and ca<10000)then for dG,dm in pairs(forcefield)do dm.toggle()end end;if antigrav then cL=antigrav.getState()==1;if cL and not q then antigrav.show()end end;if il()==1 and k then a.freeze(1)else a.freeze(0)end;if bP then bk=d.control.isAnyLandingGearExtended()==1;if bk then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if c7~=-1 or not c8 and cE:len()<50 then aZ=true;bk=true;if bP then d.control.extendLandingGears()end else aZ=false end;im:setTargetGroundAltitude(us)if c8 and c7~=-1 then ck=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;pr=c8 end;local function v0()local v1={}local function v2()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local v3={[1]=4480,[6]=4480,[7]=6270}for v4,v5 in pairs(e)do e[v4][0]=v2()e[v4][0].systemId=v4;v1[v4]={}for v6,j3 in pairs(e[v4])do j3.gravity=j3.gravity/9.8;j3.center=vec3(j3.center)j3.name=j3.name[1]j3.noAtmosphericDensityAltitude=j3.atmosphereThickness or j3.atmosphereRadius-j3.radius;if j3.name=="Lacobus"then j3.noAtmosphericDensityAltitude=12510 end;j3.spaceEngineMinAltitude=v3[j3.id]or 0.68377*j3.atmosphereThickness;j3.planetarySystemId=v4;j3.bodyId=j3.id;v1[v4][v6]=j3;if mv==nil or j3.center.x<mv then mv=j3.center.x end;if mu==nil or j3.center.x>mu then mu=j3.center.x end;if my==nil or j3.center.y<my then my=j3.center.y end;if mx==nil or j3.center.y>mx then mx=j3.center.y end;if j3.center and j3.name~="Space"then c_[#c_+1]=j3 end end end;e5=d9(d,b,c,a,da,db,dc,dd,de)ci=e5(v1)cj=eP(d,b,c,a,dd,eQ)cl=fj(d,b,c,a,da,db,dc,dd,de)cn=fJ(d,b,c,a,dbHud_1,e,fK,fL,bH,dc,dd,fM)end;v7=false;v8=coroutine.create(function()im:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})uL()coroutine.yield()uP()coroutine.yield()co=pI(d,b,c,a,e,vBooster,hover,pJ,antigrav,warpdrive,dbHud_1,eQ,bH,bI,il,eL,bG,db,im,fK,io,dd,ip,fM,iq,de,is,it,pK,ij,da,fL)u_()coroutine.yield()v0()if radar_1 then cp=gA(b,a,c,library,radar_1,radar_2,eQ,gB,dd,gC,dc,gD,fM)end;cm=ih(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ii,eQ,bH,da,ij,bI,ik,il,eL,bG,db,im,fL,fK,gB,io,dd,ip,gC,fM,iq,ir,is,it,iu,iv)cm.ButtonSetup()cq=tG(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,il,im,io,tH,gB,ip,dW,dc,db,fM,ir,pK)if shield_1 then cr=i2(shield_1,dW,bH)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aQ)if radar_1 then c.setTimer("radarTick",aQ)end;c.setTimer("hudTick",aR)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield_1 then c.setTimer("shieldTick",aQ)end;fM("start","SU")end)coroutine.resume(v8)end;function uq.onUpdate()if not v7 then local hT=coroutine.status(v8)if hT=="suspended"then local dC,hU=coroutine.resume(v8)if hU then a.print("ERROR STARTUP: "..hU)end elseif hT=="dead"then v7=true end end;if v7 then d:update()if c8 and u and cM then if cM and bO then co.cmdThrottle(0)bO=false elseif not cM and not bO then bK=0;bO=true end end;if d2 then im:setThrottleCommand(axisCommandId.longitudinal,d2)d2=nil end;if not cs and p6~=v9 then a.setScreen(p6)end;v9=p6 end end;function uq.onFlush()if v7 then co.onFlush()end end;function uq.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c9>0 or c9==0 and ca<10000)then for dG,dm in pairs(door)do dm.toggle()end end;if switch then for dG,dm in pairs(switch)do dm.toggle()end end;if forcefield and(c9>0 or c9==0 and ca<10000)then for dG,dm in pairs(forcefield)do dm.toggle()end end;x=d1;pK()if o1 then o1.activate()end;if A then co.showWayPoint(j3,cJ)end;a.print(cm.FuelUsed("atmofueltank")..", "..cm.FuelUsed("spacefueltank")..", "..cm.FuelUsed("rocketfueltank"))fM("stop","SU")end;function uq.controlStart(tP)if v7 then cq.startControl(tP)end end;function uq.controlStop(tP)if v7 then cq.stopControl(tP)end end;function uq.controlLoop(tP)if v7 then cq.loopControl(tP)end end;function uq.controlInput(sz)if v7 then cq.inputTextControl(sz)end end;function uq.radarEnter(dL)cp.onEnter(dL)end;function uq.radarLeave(dL)cp.onLeave(dL)end;function uq.onTick(va)if va=="tenthSecond"then co.TenthTick()cm.TenthTick()elseif va=="oneSecond"then cm.OneSecondTick()elseif va=="fiveSecond"then co.SatNavTick()elseif va=="msgTick"then cm.MsgTick()elseif va=="animateTick"then cm.AnimateTick()elseif va=="hudTick"then cm.hudtick()elseif va=="apTick"then co.APTick()elseif va=="radarTick"then cp.UpdateRadar()elseif va=="shieldTick"then cr.shieldTick()elseif va=="tagTick"then cq.tagTick()elseif va=="contact"then cp.ContactTick()end end;return uq end;function script.onStart()vb.onStart()end;function script.onStop()vb.onStop()end;function script.onTick(va)vb.onTick(va)end;function script.onFlush()vb.onFlush()end;function script.onUpdate()vb.onUpdate()end;function script.onActionStart(tP)vb.controlStart(tP)end;function script.onActionStop(tP)vb.controlStop(tP)end;function script.onActionLoop(tP)vb.controlLoop(tP)end;function script.onInputText(sz)vb.controlInput(sz)end;function script.onEnter(dL)vb.radarEnter(dL)end;function script.onLeave(dL)vb.radarLeave(dL)end;bF(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)vb=up(d,b,c,a,library,e,vBooster,hover,pJ,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ii,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
