name: ArchHud - Archaegeo v0.705 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.705;useTheseSettings=false;userControlScheme="virtual joystick"soundFolder="archHUD"freeLookToggle=true;BrakeToggleDefault=true;RemoteFreeze=false;RemoteHud=true;brightHud=false;VanillaRockets=false;InvertMouse=false;autoRollPreference=false;ExternalAGG=false;UseSatNav=false;ShouldCheckDamage=true;CalculateBrakeLandingSpeed=false;AtmoSpeedAssist=true;ForceAlignment=false;DisplayDeadZone=true;showHud=true;hideHudOnToggleWidgets=true;ShiftShowsRemoteButtons=true;SetWaypointOnExit=false;AlwaysVSpd=false;BarFuelDisplay=true;voices=true;alerts=true;CollisionSystem=true;AutoShieldToggle=true;PreventPvP=true;DisplayOdometer=true;YawStallAngle=35;PitchStallAngle=35;brakeLandingRate=30;MaxPitch=30;ReEntryPitch=-30;LockPitchTarget=0;AutopilotSpaceDistance=5000;TargetOrbitRadius=1.2;LowOrbitHeight=2000;AtmoSpeedLimit=1050;SpaceSpeedLimit=30000;AutoTakeoffAltitude=1000;TargetHoverHeight=50;LandingGearGroundHeight=0;ReEntryHeight=100000;MaxGameVelocity=8333.00;AutopilotInterplanetaryThrottle=1.0;warmup=32;fuelTankHandlingAtmo=0;fuelTankHandlingSpace=0;fuelTankHandlingRocket=0;ContainerOptimization=0;FuelTankOptimization=0;ResolutionX=1920;ResolutionY=1080;circleRad=400;SafeR=130;SafeG=224;SafeB=255;PvPR=255;PvPG=0;PvPB=0;centerX=960;centerY=540;throtPosX=1300;throtPosY=540;vSpdMeterX=1525;vSpdMeterY=325;altMeterX=550;altMeterY=540;fuelX=30;fuelY=700;shieldX=1750;shieldY=250;DeadZone=50;OrbitMapSize=250;OrbitMapX=0;OrbitMapY=25;soundVolume=100;speedChangeLarge=5;speedChangeSmall=1;MouseXSensitivity=0.003;MouseYSensitivity=0.003;autoRollFactor=2;rollSpeedFactor=1.5;autoRollRollThreshold=180;minRollVelocity=150;TrajectoryAlignmentStrength=0.002;torqueFactor=2;pitchSpeedFactor=0.8;yawSpeedFactor=1;brakeSpeedFactor=3;brakeFlatFactor=1;DampingMultiplier=40;apTickRate=0.0166667;hudTickRate=0.0666667;ExtraLongitudeTags="none"ExtraLateralTags="none"ExtraVerticalTags="none"BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;saveRoute={}local f={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab","saveRoute"}local g=math.abs;local h=math.floor;local j=string.format;local k=json.decode;local l=json.encode;local m=b.getElementMaxHitPointsById;local n=c.getAtmosphereDensity;local o=b.getElementMassById;local p=d.control.isRemoteControlled;local q=math.atan;local r=string.match;local s=a.getTime;local vec3=vec3;local t=utils.clamp;local u=d.axisCommandManager;local v=a.destroyWidgetPanel;local w=a.updateData;local x=a.addDataToWidget;local y=a.lockView;local z=a.isViewLocked;local A=math.sqrt;local B=tonumber;local function C(D,E)local F=10^(E or 0)return h(D*F+0.5)/F end;local G=s()local H=s()local I=13;local J=SafeR;local K=SafeB;local L=SafeG;local M=0;local N=0;local O=false;local P=0;local Q=false;local R=false;local S=55;local T=false;local U=false;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=0;local a1=0;local a2=false;local a3=false;local a4="empty"local a5=false;local a6=0;local a7=0;local a8=0;local a9=0;local aa=nil;local ab=0;local ac=0;local ad=0;local ae=0;local af=0;local ag=3;local ah=0;local ai=""local aj=false;local ak=false;local al=false;local am=-1;local an=""local ao=n()>0;local ap=n()local aq=b.getAltitude()local ar=b.getElementIdList()local as=s()local at=b.getConstructMass()local au=false;local av=nil;local aw=[[rgb(]]..h(J+0.5)..","..h(L+0.5)..","..h(K+0.5)..[[)]]local ax=[[rgb(]]..h(J*0.9+0.5)..","..h(L*0.9+0.5)..","..h(K*0.9+0.5)..[[)]]local ay={}local az=""local aA=ResolutionX;local aB=ResolutionY;local aC={}local aD={}local aE={}local aF=0;local aG=false;local aH=nil;local aI=nil;local aJ=nil;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=false;local aS=false;local aT=autoRollPreference;local aU=LandingGearGroundHeight;local aV=false;local aW=0;local aX=AtmoSpeedLimit;local aY=0;local aZ=nil;local a_={VectorToTarget=false}local b0=0;local b1=false;local b2=false;local b3=false;local b4=false;local b5=vec3(b.getConstructWorldOrientationUp())local b6=vec3(b.getConstructWorldOrientationForward())local b7=vec3(b.getConstructWorldOrientationRight())local b8=vec3(b.getVelocity())local b9=vec3(b.getWorldVelocity())local ba=vec3(b9):len()local bb=vec3(b.getWorldVertical())local bc=-bb:dot(b9)local bd=vec3(b.getConstructWorldPos())local be=false;local bf=false;local bg=nil;local bh=true;local bi=0;local bj=0;local bk={}local bl=false;local bm=50000;local bn=nil;local bo={}local bp=c.getClosestPlanetInfluence()>0 or aq>0 and aq<200000;local bq=false;local br=nil;local bs=false;local bt=0;local bu={}local bv=nil;local bw=nil;local bx={}local by=90;local bz=showHud;local function bA(bB,bC,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bB.."|"..bC.."|"..soundVolume)else a.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bB.."|"..bC.."|"..soundVolume)end else a.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bB.."|"..bC.."|"..soundVolume)end end;local function bD(bE,bF)for i=1,#bF do bE[#bE+1]=bF[i]end;return bE end;local function bG(bH)local bI={}local bJ={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP","DisplayOdometer"}local bK={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bL={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bM={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bH then bD(bI,bJ)bD(bI,bK)bD(bI,bL)bD(bI,bM)return bI elseif bH=="boolean"then return bJ elseif bH=="handling"then return bK elseif bH=="hud"then return bL elseif bH=="physics"then return bM end end;local function bN(bO,bP,bQ,bR,bS)if bR==nil then bR=""end;if bS==nil then bS=""end;return j([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bR,bO,bP,bS,bQ)end;local function bT(bU,bV)if bU==0 then return g(bV)<1e-09 end;if bV==0 then return g(bU)<1e-09 end;return g(bU-bV)<math.max(g(bU),g(bV))*epsilon end;local function bW(ah,bX)local bY=ah>100000;if bX==nil then bX=1 end;if bY then return C(ah/1000/200,bX).."SU"elseif ah<1000 then return C(ah,bX).."M"else return C(ah/1000,bX).."KM"end end;local function bZ(b_)local c0=0;local c1=0;local c2=0;if b_<60 then b_=h(b_)elseif b_<3600 then c0=h(b_/60)b_=h(b_%60)elseif b_<86400 then c1=h(b_/3600)c0=h(b_%3600/60)else c2=h(b_/86400)c1=h(b_%86400/3600)end;if c2>0 then return c2 .."d "..c1 .."h "elseif c1>0 then return c1 .."h "..c0 .."m "elseif c0>0 then return c0 .."m "..b_.."s"elseif b_>0 then return b_.."s"else return"0s"end end;local function c3(c4)local function c5(c6)for c7,c8 in pairs(c6)do dbHud_1.setStringValue(c8,l(_G[c8]))if c4 and dbHud_2 then dbHud_2.setStringValue(c8,l(_G[c8]))end end end;if dbHud_1 then c5(f)c5(bG())a.print("Saved Variables to Datacore")if c4 and dbHud_2 then a4="Databank copied.  Remove copy when ready."end end end;local function c9()local function ca(cb)return type(cb)=='number'end;local function cc(cb)return type(B(cb))=='number'end;local function cd(ce)return type(ce)=='table'end;local function cf(a)return type(a)=='string'end;local function cg(c8)return cd(c8)and ca(c8.x and c8.y and c8.z)end;local function ch(ci)return cd(ci)and ca(ci.latitude and ci.longitude and ci.altitude and ci.id and ci.systemId)end;local cj=math.pi/180;local ck=180/math.pi;local epsilon=1e-10;local D=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cl='::pos{'..D..','..D..','..D..','..D..','..D..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cm(cb)local cn=string.gsub(string.reverse(j('%.4f',cb)),'^0*%.?','')return cn==''and'0'or string.reverse(cn)end;local function co(cp)if cg(cp)then return j('{x=%.3f,y=%.3f,z=%.3f}',cp.x,cp.y,cp.z)end;if cd(cp)and not getmetatable(cp)then local cq={}local cr=next(cp)if type(cr)=='nil'or cr==1 then cq=cp else for c7,c8 in pairs(cp)do local cs=co(c8)if type(c7)=='number'then table.insert(cq,j('[%s]=%s',c7,cs))else table.insert(cq,j('%s=%s',c7,cs))end end end;return j('{%s}',table.concat(cq,','))end;if cf(cp)then return j("'%s'",cp:gsub("'",[[\']]))end;return tostring(cp)end;local ct={}ct.__index=ct;ct.__tostring=function(cp,cu)local cv={}for c7 in pairs(cp)do table.insert(cv,c7)end;table.sort(cv)local cq={}for _,c7 in ipairs(cv)do local cs=co(cp[c7])if type(c7)=='number'then table.insert(cq,j('[%s]=%s',c7,cs))else table.insert(cq,j('%s=%s',c7,cs))end end;if cu then return j('%s%s',cu,table.concat(cq,',\n'..cu))end;return j('{%s}',table.concat(cq,','))end;ct.__eq=function(cw,cx)return cw.systemId==cx.systemId and cw.id==cx.id and bT(cw.radius,cx.radius)and bT(cw.center.x,cx.center.x)and bT(cw.center.y,cx.center.y)and bT(cw.center.z,cx.center.z)and bT(cw.GM,cx.GM)end;local function cy(cz,cA,cB,cC,cD)assert(cc(cz),'Argument 1 (systemId) must be a number:'..type(cz))assert(cc(cA),'Argument 2 (id) must be a number:'..type(cA))assert(cc(cB),'Argument 3 (radius) must be a number:'..type(cB))assert(cd(cC),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cC))assert(cc(cD),'Argument 5 (GM) must be a number:'..type(cD))return setmetatable({systemId=B(cz),id=B(cA),radius=B(cB),center=vec3(cC),GM=B(cD)},ct)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(cE)return j('::pos{%d,%d,%s,%s,%s}',cE.systemId,cE.id,cm(cE.latitude*ck),cm(cE.longitude*ck),cm(cE.altitude))end;MapPosition.__eq=function(cw,cx)return cw.id==cx.id and cw.systemId==cx.systemId and bT(cw.latitude,cx.latitude)and bT(cw.altitude,cx.altitude)and(bT(cw.longitude,cx.longitude)or bT(cw.latitude,math.pi/2)or bT(cw.latitude,-math.pi/2))end;local function cF(cG,cA,cH,cI,cJ)local cz=cG;if cf(cG)and not cI and not cJ and not cA and not cH then cz,cA,cH,cI,cJ=r(cG,cl)assert(cz,'Argument 1 (position string) is malformed.')else assert(cc(cz),'Argument 1 (systemId) must be a number:'..type(cz))assert(cc(cA),'Argument 2 (id) must be a number:'..type(cA))assert(cc(cH),'Argument 3 (latitude) must be in degrees:'..type(cH))assert(cc(cI),'Argument 4 (longitude) must be in degrees:'..type(cI))assert(cc(cJ),'Argument 5 (altitude) must be in meters:'..type(cJ))end;cz=B(cz)cA=B(cA)cH=B(cH)cI=B(cI)cJ=B(cJ)if cA==0 then return setmetatable({latitude=cH,longitude=cI,altitude=cJ,id=cA,systemId=cz},MapPosition)end;return setmetatable({latitude=cj*t(cH,-90,90),longitude=cj*(cI%360),altitude=cJ,id=cA,systemId=cz},MapPosition)end;local cK={}cK.__index=cK;cK.__tostring=function(cp,cu)local cL=cu and cu..'  'local cM={}local cv={}for c7 in pairs(cp)do table.insert(cv,c7)end;table.sort(cv)for _,cN in ipairs(cv)do bdy=cp[cN]local cO=ct.__tostring(bdy,cL)if cu then table.insert(cM,j('[%s]={\n%s\n%s}',cN,cO,cu))else table.insert(cM,j('  [%s]=%s',cN,cO))end end;if cu then return j('\n%s%s%s',cu,table.concat(cM,',\n'..cu),cu)end;return j('{\n%s\n}',table.concat(cM,',\n'))end;local function cP(cQ)local e={}local pid;for _,c8 in pairs(cQ)do local cA=c8.planetarySystemId;if type(cA)~='number'then error('Invalid planetary s ID: '..tostring(cA))elseif pid and cA~=pid then error('Mistringmatch planetary s IDs: '..cA..' and '..pid)end;local cR=c8.bodyId;if type(cR)~='number'then error('Invalid body ID: '..tostring(cR))elseif e[cR]then error('Duplicate body ID: '..tostring(cR))end;setmetatable(c8.center,getmetatable(vec3.unit_x))e[cR]=setmetatable(c8,ct)pid=cA end;return setmetatable(e,cK)end;aH={}local function cS(cQ)return setmetatable({galaxyAtlas=cQ or{}},aH)end;aH.__index=function(ce,i)if type(i)=='number'then local a=ce.galaxyAtlas[i]return cP(a)end;return rawget(aH,i)end;aH.__pairs=function(cp)return function(ce,c7)local cT,nv=next(ce,c7)return cT,nv and cP(nv)end,cp.galaxyAtlas,nil end;aH.__tostring=function(cp)local cU={}for _,cV in pairs(cp or{})do local cW=cV:getPlanetarySystemId()local cX=cK.__tostring(cV,'    ')table.insert(cU,j('  [%s]={%s\n  }',cW,cX))end;return j('{\n%s\n}\n',table.concat(cU,',\n'))end;aH.BodyParameters=cy;aH.MapPosition=cF;aH.PlanetarySystem=cP;function aH.createBodyParameters(cz,cA,cY,cZ,c_,d0,d1)assert(cc(cz),'Argument 1 (systemId) must be a number:'..type(cz))assert(cc(cA),'Argument 2 (id) must be a number:'..type(cA))assert(cc(cY),'Argument 3 (surfaceArea) must be a number:'..type(cY))assert(cd(cZ),'Argument 4 (aPosition) must be an array or vec3:'..type(cZ))assert(cd(c_),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(c_))assert(cc(d0),'Argument 6 (altitude) must be in meters:'..type(d0))assert(cc(d1),'Argument 7 (gravityAtPosition) must be number:'..type(d1))local cB=A(cY/4/math.pi)local ah=cB+d0;local d2=vec3(cZ)+ah*vec3(c_)local cD=d1*ah*ah;return cy(cz,cA,cB,d2,cD)end;aH.isMapPosition=ch;function aH:getPlanetarySystem(cG)if i==nil then i=0 end;if nv==nil then nv=0 end;local cz=cG;if ch(cG)then cz=cG.systemId end;if type(cz)=='number'then local a=self.galaxyAtlas[i]if a then if getmetatable(nv)~=cK then a=cP(a)end;return a end end end;function cK:sizeCalculator(d3)return 1.05*d3.radius end;function cK:castIntersections(d4,d5,d6,d7,d8,d9)local da={}if d8 then for _,d3 in pairs(d8)do table.insert(da,d3)end else da=bx end;if not d9 then table.sort(da,function(db,dc)local bU=db.center;local bV=dc.center;return(bU.x-d4.x)^2+(bU.y-d4.y)^2+(bU.z-d4.z)^2<(bV.x-d4.x)^2+(bV.y-d4.y)^2+(bV.z-d4.z)^2 end)end;local dd=d5:normalize()for _,d3 in ipairs(da)do local de=d3.center-d4;local cB=self:sizeCalculator(d3)local df=de:dot(dd)local dg=df^2-(de:len2()-cB^2)if dg>=0 then local dh=A(dg)local di=df+dh;local dj=df-dh;if dj>0 then return d3,di,dj elseif di>0 then return d3,di,nil end end end;return nil,nil,nil end;function cK:closestBody(dk)assert(type(dk)=='table','Invalid coordinates.')local dl,d3;local dm=vec3(dk)for _,dn in pairs(self)do local dp=(dn.center-dm):len2()if(not d3 or dp<dl)and dn.name~="Space"then d3=dn;dl=dp end end;return d3 end;function cK:convertToBodyIdAndWorldCoordinates(cG)local dq=cG;if cf(cG)then dq=cF(cG)end;if dq.id==0 then return 0,vec3(dq.latitude,dq.longitude,dq.altitude)end;local dn=self:getBodyParameters(dq)if dn then return dq.id,dn:convertToWorldCoordinates(dq)end end;function cK:getBodyParameters(cG)local cA=cG;if ch(cG)then cA=cG.id end;assert(cc(cA),'Argument 1 (id) must be a number:'..type(cA))return self[cA]end;function cK:getPlanetarySystemId()local _,c8=next(self)return c8 and c8.systemId end;function ct:convertToMapPosition(cC)assert(cd(cC),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cC))local dr=vec3(cC)if self.id==0 then return setmetatable({latitude=dr.x,longitude=dr.y,altitude=dr.z,id=0,systemId=self.systemId},MapPosition)end;local ds=dr-self.center;local ah=ds:len()local cJ=ah-self.radius;local cH=0;local cI=0;if not bT(ah,0)then local dt=q(ds.y,ds.x)cI=dt>=0 and dt or 2*math.pi+dt;cH=math.pi/2-math.acos(ds.z/ah)end;return setmetatable({latitude=cH,longitude=cI,altitude=cJ,id=self.id,systemId=self.systemId},MapPosition)end;function ct:convertToWorldCoordinates(cG)local dq=cf(cG)and cF(cG)or cG;if dq.id==0 then return vec3(dq.latitude,dq.longitude,dq.altitude)end;assert(ch(dq),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dq.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(dq.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local du=math.cos(dq.latitude)return self.center+(self.radius+dq.altitude)*vec3(du*math.cos(dq.longitude),du*math.sin(dq.longitude),math.sin(dq.latitude))end;function ct:getAltitude(cC)return(vec3(cC)-self.center):len()-self.radius end;function ct:getDistance(cC)return(vec3(cC)-self.center):len()end;function ct:getGravity(cC)local dv=self.center-vec3(cC)local dw=dv:len2()return self.GM/dw*dv/A(dw)end;return setmetatable(aH,{__call=function(_,...)return cS(...)end})end;local function dx()local aJ={}local dy=30000000/3600;local dz=dy*dy;local dA=100;function aJ.computeAccelerationTime(dB,dC,dD)local dE=dy*math.asin(dB/dy)return(dy*math.asin(dD/dy)-dE)/dC end;function aJ.computeDistanceAndTime(dB,dD,dF,dG,dH,dI)dH=dH or 0;dI=dI or 0;local dJ=dB<=dD;local dK=dG*(dJ and 1 or-1)/dF;local dL=-dI/dF;local dM=dK+dL;if dJ and dM<=0 or not dJ and dM>=0 then return-1,-1 end;local dN,dO=0,0;if dK~=0 and dH>0 then local dE=math.asin(dB/dy)local dP=math.pi*(dK/2+dL)local dQ=dK*dH;local dR=dy*math.pi;local c8=function(ce)local dS=(dP*ce-dQ*math.sin(math.pi*ce/2/dH)+dR*dE)/dR;local dT=math.tan(dS)return dy*dT/A(dT*dT+1)end;local dU=dJ and function(a)return a>=dD end or function(a)return a<=dD end;dO=2*dH;if dU(c8(dO))then local dV=0;while g(dO-dV)>0.5 do local ce=(dO+dV)/2;if dU(c8(ce))then dO=ce else dV=ce end end end;local dW=dB;local dX=dO/dA;for dY=1,dA do local dZ=c8(dY*dX)dN=dN+(dZ+dW)*dX/2;dW=dZ end;if dO<2*dH then return dN,dO end;dB=dW end;local dE=dy*math.asin(dB/dy)local G=(dy*math.asin(dD/dy)-dE)/dM;local d_=dz*math.cos(dE/dy)/dM;local ah=d_-dz*math.cos((dM*G+dE)/dy)/dM;return ah+dN,G+dO end;function aJ.computeTravelTime(dB,dC,ah)if ah==0 then return 0 end;if dC>0 then local dE=dy*math.asin(dB/dy)local d_=dz*math.cos(dE/dy)/dC;return(dy*math.acos(dC*(d_-ah)/dz)-dE)/dC end;if dB==0 then return-1 end;assert(dB>0,'Acceleration and initial speed are both zero.')return ah/dB end;return aJ end;local function e0()local vec3=require('cpml.vec3')local c9=c9()local function cf(a)return type(a)=='string'end;local function cd(ce)return type(ce)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cJ)assert(self.body)local ah=cJ+self.body.radius;if not bT(ah,0)then local orbit=A(self.body.GM/ah)return A(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cG,e1)assert(self.body)assert(cd(cG)or cf(cG))assert(cd(e1))local e2=(cf(cG)or c9.isMapPosition(cG))and self.body:convertToWorldCoordinates(cG)or vec3(cG)local c8=vec3(e1)local e3=e2-self.body.center;local e4=c8:len2()local e5=e3:len()local e6=self.body.GM;local e7=((e4-e6/e5)*e3-e3:dot(c8)*c8)/e6;local bU=e6/(2*e6/e5-e4)local e8=e7:len()local dd=e7:normalize()local e9=bU*(1-e8)local ea=bU*(1+e8)local eb=e9*dd+self.body.center;local ec=e8<=1 and-ea*dd+self.body.center or nil;local ed=A(bU*e6*(1-e8*e8))local ee=ec and 2*math.pi*A(bU^3/e6)local ef=math.acos(e7:dot(e3)/(e8*e5))if e3:dot(c8)<0 then ef=-(ef-2*math.pi)end;local eg=math.acos((math.cos(ef)+e8)/(1+e8*math.cos(ef)))local eh=eg;if eh<0 then eh=eh+2*math.pi end;local ei=eh-e8*math.sin(eh)local ej=0;local ek=0;local el=0;if ee~=nil then ej=ei/(2*math.pi/ee)ek=ee-ej;el=ek+ee/2;if ef-math.pi>0 then ek=ej;el=ek+ee/2 end;if el>ee then el=el-ee end end;return{periapsis={position=eb,speed=ed/e9,circularOrbitSpeed=A(e6/e9),altitude=e9-self.body.radius},apoapsis=ec and{position=ec,speed=ed/ea,circularOrbitSpeed=A(e6/ea),altitude=ea-self.body.radius},currentVelocity=c8,currentPosition=e2,eccentricity=e8,period=ee,eccentricAnomaly=eg,meanAnomaly=ei,timeToPeriapsis=ek,timeToApoapsis=el,trueAnomaly=ef}end;local function em(en)local dn=c9.BodyParameters(en.systemId,en.id,en.radius,en.center,en.GM)return setmetatable({body=dn},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return em(...)end})end;local function eo()local ep={}local eq={}local er={XS=13,S=27,M=55,L=110,XL=221}local es={}local et;local eu;local ev;local ew;local ex;local ey={}local ez="Atmo"local eA;local function eB()local function eC(eD,eE,eF,eG,eH,eI,eJ,eK)eE,eG,eI,eK=vec3(eE),vec3(eG),vec3(eI),vec3(eK)local eL,eM,eN=eD*eD,eF*eF,eH*eH;local e4=eG-eE;local eO=e4:normalize()local eP=e4:len()local eQ=eI-eE;local eR=(eQ-eQ:project_on(eO)):normalize()local eS,eT=eQ:dot(eO),eQ:dot(eR)local eU=eS*eS+eT*eT;local eV=eO:cross(eR)local bO=(eL-eM+eP*eP)/(2*eP)local bP=(eL-eN+eU-2*eS*bO)/(2*eT)local ci=eL-bO^2-bP^2;local eW=A(ci)local eX=eE+eO*bO+eR*bP+eV*eW;local eY=eE+eO*bO+eR*bP-eV*eW;if g((eK-eX):len()-eJ)<g((eK-eY):len()-eJ)then return eX else return eY end end;local function eZ()local function e_()local f0=b.getConstructWorldOrientationRight()local e4=b.getConstructWorldOrientationForward()local eQ=b.getConstructWorldOrientationUp()local f1=library.systemResolution3(f0,e4,eQ,{1,0,0})local f2=library.systemResolution3(f0,e4,eQ,{0,1,0})local f3=library.systemResolution3(f0,e4,eQ,{0,0,1})return function(f4)return library.systemResolution3(f1,f2,f3,f4)end end;local f5=e_()local f6=b.getConstructWorldPos()local e2=b.getElementPositionById(1)local f7={e2[1],e2[2],e2[3]}local f8=f5(f7)local f9={f6[1]-f8[1],f6[2]-f8[2],f6[3]-f8[3]}return f9 end;local function fa(fb,e5,fc)local fd=fb.pts;local fe=#fd;local ff=fb.ref;if fe>3 then local fg,fh,fi,fj=fd[fe],fd[fe-1],fd[fe-2],fd[fe-3]fb.ref=fc;local e2=eC(fg[1],fg[2],fh[1],fh[2],fi[1],fi[2],fj[1],fj[2])local bO,bP,eW=e2.x,e2.y,e2.z;if bO==bO and bP==bP and eW==eW then bO=bO+ff[1]bP=bP+ff[2]eW=eW+ff[3]local fk=vec3(bO,bP,eW)if not fb.lastPos then fb.center=fk elseif(fb.lastPos-fk):len()<2 then fb.center=fk;fb.skipCalc=true end;fb.lastPos=fk end;fb.pts={}else local fl={fc[1]-ff[1],fc[2]-ff[2],fc[3]-ff[3]}fd[fe+1]={e5,fl}end end;if radar_1 or radar_2 then aP.assignRadar()end;if ey[1]then et=#ey[1].getConstructIds()local fm=ey[1].getData()local fn=fm:gmatch('{"constructId[^}]*}[^}]*}')if et>0 then local fc=eZ()local fo,fp=0,0;ex,ew=0,0;for c8 in fn do local cA,ah,fq=c8:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fr=er[fq]ah=B(ah)if ey[1].hasMatchingTransponder(cA)==1 then table.insert(eq,cA)end;local fs=ey[1].getConstructType(cA)if CollisionSystem then if fr>27 or fs=="static"or fs=="space"then ex=ex+1;local ft=ey[1].getConstructName(cA)local fb=bo[cA]if fb==nil then fr=fr+I;bo[cA]={pts={},ref=fc,name=ft,i=0,radius=fr,skipCalc=false}fb=bo[cA]end;if not fb.skipCalc then fa(fb,ah,fc)fp=fp+1 end;if fb.center then table.insert(es,fb)end end;fo=fo+1;if bp and fo>700 or fp>70 or(not bp and fo>300 or fp>30)then coroutine.yield()fo,fp=0,0 end end end;ew=#es;if ew>0 and ba>20 then local d3,fu,fv,fw;local fx=0;local fy=aI:getPlanetarySystem(0)fw=b9:normalize()while fx<ew do coroutine.yield()local fz={table.unpack(es,fx,math.min(fx+75,ew))}d3,fu,fv=fy:castIntersections(bd,fw,nil,nil,fz,true)if d3 and fv then br={d3,fu,fv}break end;fx=fx+75 end;if not d3 then br=nil end else br=nil end;es={}eu=fm:find('identifiedConstructs":%[%]')else ev=fm:find('worksInEnvironment":false')end end end;local function fA()if ey[1]then ez="Atmo"if ey[1].getData():find('worksInAtmosphere":false')then ez="Space"end end end;function ep.pickType()fA()end;function ep.assignRadar()if radar_1 and ey[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then ey[1]=radar_2 end;if ey[1]==radar_2 then fA()end elseif radar_2 and ey[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then ey[1]=radar_1 end;if ey[1]==radar_1 then fA()end end end;function ep.UpdateRadar()local fB=coroutine.status(eA)if fB=="suspended"then local cs,fC=coroutine.resume(eA)if fC then a.print("ERROR UPDATE RADAR: "..fC)end elseif fB=="dead"then eA=coroutine.create(eB)local cs,fC=coroutine.resume(eA)end end;function ep.GetRadarHud(fD,fE,fF,fG)local fH=eq;local fI,fJ;eq={}local D=ew or 0;if et>0 then if CollisionSystem then fJ=D.."/"..ex.." Plotted : "..et-ex.." Ignored"else fJ="Radar Contacts: "..et end;fI=bN(fF,fG,fJ,"pbright txtbig txtmid")if#eq>0 then fI=fI..bN(fD,fE,"Friendlies In Range","pbright txtbig txtmid")for c7,c8 in pairs(eq)do fE=fE+20;fI=fI..bN(fD,fE,ey[1].getConstructName(c8),"pdim txtmid")end end;if eu==nil and perisPanelID==nil then peris=1;aP.ToggleRadarPanel()end;if eu~=nil and perisPanelID~=nil then aP.ToggleRadarPanel()end;if radarPanelID==nil then aP.ToggleRadarPanel()end else if ev then fI=bN(fF,fG,ez.." Radar: Jammed","pbright txtbig txtmid")else fI=bN(fF,fG,"Radar: No "..ez.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then peris=0;aP.ToggleRadarPanel()end end;return fI end;function ep.GetClosestName(ft)if ey[1]then local cA,_=ey[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cA~=nil and cA~=""then ft=ft.." "..ey[1].getConstructName(cA)end end;return ft end;function ep.ToggleRadarPanel()if radarPanelID~=nil and peris==0 then v(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then v(perisPanelID)perisPanelID=nil end else if peris==1 then v(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(ey,1,"Periscope","periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(ey,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;peris=0 end end;ey[1]=nil;if radar_1 then ey[1]=radar_1;fA()end;eA=coroutine.create(eB)return ep end;local function fK()local fL=9.80665;local fM={}local fN={}local fO={}local bu={}local fP=nil;local fQ=nil;local fR=nil;local fS=false;local fT={}local fU=""local fV=vec3({13771471,7435803,-128971})local fW=18000000;local fX=500000;local fY,fZ=math.huge;local f_;local function g0(g1)fY=vec3(g1):dist(fV)if fY<fW then return true,g(fY-fW)end;fZ=vec3(g1):dist(vec3(planet.center))if fZ<fX then f_=true else f_=false end;if g(fZ-fX)<g(fY-fW)then return f_,g(fZ-fX)else return f_,g(fY-fW)end end;local function g2(c8)if aA==1920 then return c8 else return C(aA*c8/1920,0)end end;local function g3(c8)if aB==1080 then return c8 else return C(aB*c8/1080,0)end end;local function g4()return z()==0 and userControlScheme~="keyboard"and p()==0 end;local function g5()local g6="TRAVEL"if not bh then g6="CRUISE"end;if Autopilot then g6="AUTOPILOT"end;return g6 end;local g7={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local fI=""local g8=""local g9=""local ga=1;local gb=2;local gc=3;local gd=4;local ge=5;local gf=6;local gg=""local gh=0;local gi=h(1/apTickRate)*2*hudTickRate;local gj={}local gk={}local gl={}local gm={}local gn={}local go={}local function gp(bO,gq,gr,gs,gt,gu)local gv=tankY;local gw=tankY+5;if not BarFuelDisplay then gw=gw+5 end;if p()==1 and not RemoteHud then gv=gv-50;gw=gw-50 end;if gr=="ATMO"then gg="atmofueltank"elseif gr=="SPACE"then gg="spacefueltank"else gg="rocketfueltank"end;gh=_G[gg.."_size"]if#gs>0 then for i=1,#gs do local ft=string.sub(gs[i][gb],1,12)local gx=0;for gy=1,gh do if gs[i][gb]==k(c[gg.."_"..gy].getData()).name then gx=gy;break end end;local gz=s()if gt[i]==nil or gu[i]==nil or gz-gs[i][gf]>gi then local gA;local gB=0;if gx~=0 then gu[i]=k(c[gg.."_"..gx].getData()).percentage;gt[i]=k(c[gg.."_"..gx].getData()).timeLeft;if gt[i]=="n/a"then gt[i]=0 end else gB=o(gs[i][ga])-gs[i][gd]gu[i]=h(0.5+gB*100/gs[i][gc])gA=gs[i][ge]if gA<=gB then gt[i]=0 else gt[i]=h(0.5+gB/((gA-gB)/(gz-gs[i][gf])))end;gs[i][ge]=gB;gs[i][gf]=gz end end;if ft==gq then ft=j("%s %d",gr,i)end;if gx==0 then ft=ft.." *"end;local gC;if gt[i]==0 then gC=""else gC=bZ(gt[i])end;if gu[i]~=nil then local gD=h(gu[i]*2.55)local gE=j("rgb(%d,%d,%d)",255-gD,gD,0)local bR=""if gC~=""and gt[i]<120 or gu[i]<5 then bR="red "end;local gF=j("rgb(%d,%d,%d)",t(h((255-gD)/2.55),50,100),t(h(gD/2.55),0,50),50)local gG="rgb(196,0,255)"if gr=="ATMO"then gG="rgb(0,188,255)"elseif gr=="SPACE"then gG="rgb(239,255,0)"end;local gH=false;if previous~=gG then gH=true end;previous=gG;if BarFuelDisplay then if gH then gv=gv-5;gw=gw-5 end;g8=g8 ..j([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gF,gG,bO,gw,gE,h(gu[i]*1.7+0.5)-2,bO+1,gw+1,bO+5,gw+14,ft,gu[i],gC)gv=gv-22;gw=gw-22 else g8=g8 ..bN(bO,gv,ft,bR.."pdim txtfuel")g8=g8 ..bN(bO,gw,j("%d%% %s",gu[i],gC),"pdim txtfuel","fill:"..gE)gv=gv+30;gw=gw+30 end end end end;tankY=gv end;local function gI(gJ,cJ)if vSpdMeterX==0 and vSpdMeterY==0 then return end;if cJ<200000 and not ao or cJ and ao then local gK=0;if g(bc)>1 then gK=45*math.log(g(bc),10)if bc<0 then gK=-gK end end;gJ[#gJ+1]=j([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,h(bc),h(gK))end;return gJ end;local function gL(gM)local gN=-bb;gM=gM-gM:project_on(gN)local gO=vec3(0,0,1)gO=gO-gO:project_on(gN)local gP=gO:cross(gN)local gK=gO:angle_between(gM)*constants.rad2deg;if gM:dot(gP)<0 then gK=360-gK end;return gK end;local function gQ(gJ,centerX,centerY,gR,gS,bp)if circleRad==0 then return end;local gT=circleRad;local gU=20;local gV=h(gR)if bp then for i=-45,45,5 do local gW=i;gJ[#gJ+1]=j([[<g transform="rotate(%f,%d,%d)">]],gW,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gJ[#gJ+1]=j([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gT+gU-len,centerX,centerY+gT+gU)end;gJ[#gJ+1]=bN(centerX,centerY+gT+gU-35,gS,"pdim txt txtmid")gJ[#gJ+1]=bN(centerX,centerY+gT+gU-25,gV.." deg","pdim txt txtmid")gJ[#gJ+1]=j([[<g transform="rotate(%f,%d,%d)">]],-gR,centerX,centerY)gJ[#gJ+1]=j([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gT+gU-20,centerX+5,centerY+gT+gU-20,centerX,centerY+gT+gU-15)gJ[#gJ+1]="</g>"end;gJ[#gJ+1]=[[<g style="clip-path: url(#headingClip);">]]local gX=gV;if bp then gX=gL(b6)end;local gY=20;local gZ=h(gX)local g_=0;local h0=centerY+gT+gU+20;local h1=centerX;if gS~="YAW"then h0=g3(130)h1=g2(960)end;local h2=[[<path class="txttick line" d="]]local h3=h(gZ-(gY+10)-gZ%5+0.5)for i=h3+70,h3,-5 do local bO=h1-(-i*5+gX*5)if i%10==0 then g_=10;local D=i;if D==360 then D=0 elseif D>360 then D=D-360 elseif D<0 then D=D+360 end;gJ[#gJ+1]=bN(bO,h0+15,D,"txtmid bright")elseif i%5==0 then g_=5 end;if g_==10 then h2=j([[%s M %f %f v %d]],h2,bO,h0-5,g_)else h2=j([[%s M %f %f v %d]],h2,bO,h0-2.5,g_)end end;gJ[#gJ+1]=h2 ..[["/>]]gJ[#gJ+1]=j([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],h1-5,h0-20,h1+5,h0-20,h1,h0-10)if DisplayOdometer then if bp then gS="HDG"end;gJ[#gJ+1]=bN(g2(960),g3(100),gZ.."°","dim txt txtmid size14","")gJ[#gJ+1]=bN(g2(960),g3(85),gS,"dim txt txtmid size20","")end;gJ[#gJ+1]=[[</g>]]end;local function h4(gJ,h5,gR,centerX,centerY,bp,h6,dZ)if circleRad==0 then return end;local gT=circleRad;local h7=h(gT*3/5)if gT>0 then local h8=h(h5)local len=0;local h2=j([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gR,centerX,centerY)if not ao then h2=j([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gJ[#gJ+1]=j([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gT-1,centerX,centerY)gJ[#gJ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=h(h8-30-h8%5+0.5),h(h8+30+h8%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bP=centerY+-i*5+h5*5;if len==30 then h2=j([[%s M %d %f h %d]],h2,centerX-h7-len,bP,len)if ao then gJ[#gJ+1]=j([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gR,centerX,centerY,centerX-h7+10,bP+4,i)gJ[#gJ+1]=j([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gR,centerX,centerY,centerX+h7-10,bP+4,i)if i==0 or i==180 or i==-180 then gJ[#gJ+1]=j([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gR,centerX,centerY,centerX-h7+20,bP,h7*2-40)end else gJ[#gJ+1]=bN(centerX-h7+10,bP,i,"pdim txt txtmid")gJ[#gJ+1]=bN(centerX+h7-10,bP,i,"pdim txt txtmid")end;h2=j([[%s M %d %f h %d]],h2,centerX+h7,bP,len)else h2=j([[%s M %d %f h %d]],h2,centerX-h7-len,bP,len)h2=j([[%s M %d %f h %d]],h2,centerX+h7,bP,len)end end;gJ[#gJ+1]=h2 ..[["/>]]local h9="PITCH"if not bp then h9="REL PITCH"end;if h5>90 and not ao then h5=90-(h5-90)elseif h5<-90 and not ao then h5=-90-(h5+90)end;if gT>200 then if ao then if dZ>S then gJ[#gJ+1]=bN(centerX,centerY-15,"Yaw","pdim txt txtmid")gJ[#gJ+1]=bN(centerX,centerY+20,h6,"pdim txt txtmid")end;gJ[#gJ+1]=j([[<g transform="rotate(%f,%d,%d)">]],-gR,centerX,centerY)else gJ[#gJ+1]=j([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gJ[#gJ+1]=j([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-h7+25,centerY-5,centerX-h7+20,centerY,centerX-h7+25,centerY+5,centerX-h7+50,centerY+4,h8)gJ[#gJ+1]=j([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+h7-25,centerY-5,centerX+h7-20,centerY,centerX+h7-25,centerY+5,centerX+h7-30,centerY+4,h8)gJ[#gJ+1]="</g>"end;local ha=h(gT/3)gJ[#gJ+1]=j([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-ha,centerY,gT-ha)if not ao and bp then gJ[#gJ+1]=j([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gR,centerX,centerY,centerX-h7+10,centerY,h7*2-20)end;gJ[#gJ+1]="</g>"if gT<200 then if ao and dZ>S then gJ[#gJ+1]=bN(centerX,centerY-gT,h9,"pdim txt txtmid")gJ[#gJ+1]=bN(centerX,centerY-gT+10,h8,"pdim txt txtmid")gJ[#gJ+1]=bN(centerX,centerY-15,"Yaw","pdim txt txtmid")gJ[#gJ+1]=bN(centerX,centerY+20,h6,"pdim txt txtmid")else gJ[#gJ+1]=bN(centerX,centerY-gT,h9,"pdim txt txtmid")gJ[#gJ+1]=bN(centerX,centerY-gT+15,h8,"pdim txt txtmid")end end end end;local function hb(gJ,cJ,bp)local hc=altMeterX;local hd=altMeterY;if hc==0 and hd==0 then return end;local he=78;local hf=19;local hg=am;if am~=-1 then gJ[#gJ+1]=bN(hc+he,hd+hf+20,j("AGL: %.1fm",am),"pdim altsm txtend")end;if bp and(cJ<200000 and not ao or cJ and ao)then table.insert(gJ,j([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hc-1,hd-4,he+2,hf+6,hc+1,hd-1,he-4,hf))local fe=0;local hh=1;local hi=0;local hj=cJ<0;local hk=cJ<planet.surfaceMaxAltitude;local hl=9;if hj then hl=0 end;local cJ=g(cJ)while fe<6 do local hm=11;local hn=16;local ho=9;local hp=14;local bR="altsm"if fe>2 then hn=hn+3;hm=hm+2;hp=hp+2;ho=ho-6;bR="altbig"end;if hj then bR=bR.." red"elseif hk then bR=bR.." orange"end;local hq=cJ/hh%10;local hr=h(hq)local hs=h((hr+1)%10)local ht=hi;if fe==0 then ht=hq-hr;if hj then ht=1-ht end end;if hj and(fe==0 or hi~=0)then local hu=hs;hs=hr;hr=hu end;local hv=hn*(ht-1)local hw=hv+hn;local bO=hc+ho+(6-fe)*hm;local bP=hd+hp;gJ[#gJ+1]=bN(bO,bP+hv,hs,bR)gJ[#gJ+1]=bN(bO,bP+hw,hr,bR)fe=fe+1;hh=hh*10;if hr==hl then hi=ht else hi=0 end end;table.insert(gJ,[[</g></g>]])end end;local function hx(e1)local hy=-math.deg(q(e1.y,e1.z))+180;hy=hy-90;if hy<0 then hy=360+hy end;if hy>180 then hy=-180+hy-180 end;return-hy end;local function hz(e1)local gX=math.deg(q(e1.y,e1.x))-90;if gX<-180 then gX=360+gX end;return gX end;local function hA(gJ,e1,dZ,centerX,centerY)if dZ>5 and not ao or dZ>S then local gT=circleRad;local hB=20;local hC=20;local hD=hx(e1)local hE=hz(e1)local hF=14;local hG=hF/2;local hH=-hE/hC*gT;local hI=hD/hB*gT;local bO=centerX+hH;local bP=centerY+hI;local ah=A(hH^2+hI^2)local hJ=[[<circle
                            cx="]]..bO..[["
                            cy="]]..bP..[["
                            r="]]..hG/hF..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bO..[["
                            cy="]]..bP..[["
                            r="]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bO-hF..[[,]]..bP..[[ h ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bO+hG..[[,]]..bP..[[ h ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bO..[[,]]..bP-hF..[[ v ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ah<gT then gJ[#gJ+1]=hJ else local gK=q(hI,hH)local hK=4;local hL=centerX+gT*math.cos(gK)local hM=centerY+gT*math.sin(gK)gJ[#gJ+1]=j('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gK*180/math.pi,hL,hM,hL-hK,hM-hK/2,hK*2,hK,hL+hK,hM-hK,hK,hK,-hK,hK)end;if not ao then local hN=vec3(e1)hD=hx(-hN)hE=hz(-hN)hH=-hE/hC*gT;hI=hD/hB*gT;bO=centerX+hH;bP=centerY+hI;ah=A(hH^2+hI^2)if ah<gT then local hO=[[<circle
                                    cx="]]..bO..[["
                                    cy="]]..bP..[["
                                    r="]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bO..[[,]]..bP-hF..[[ v ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bO..[[,]]..bP..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bO..[[,]]..bP..[[)" />
                                <path
                                    d="M ]]..bO-hG..[[,]]..bP..[[ h ]]..hF..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bO..[[,]]..bP..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bO..[[,]]..bP..[[)"/>]]gJ[#gJ+1]=hO end end end end;local function hP(gJ,g6,hQ,hR)if throtPosX==0 and throtPosY==0 then return end;hQ=h(hQ+0.5)local gv=throtPosY+10;local gw=throtPosY+20;if p()==1 and not RemoteHud then gv=55;gw=65 end;local hS="CRUISE"local c="km/h"local cs=hR;if g6=="TRAVEL"or g6=="AUTOPILOT"then hS="THROT"c="%"cs=hQ;local hT="dim"if hQ<0 then hT="red"end;gJ[#gJ+1]=j([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hT,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-g(hQ),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gJ[#gJ+1]=bN(throtPosX+10,gv,hS,"pbright txtstart")gJ[#gJ+1]=bN(throtPosX+10,gw,j("%.0f %s",cs,c),"pbright txtstart")if ao and AtmoSpeedAssist and bh and O then hQ=h(P*100+0.5)local hT="red"if hQ<0 then hT="red"end;gJ[#gJ+1]=j([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hT,1-g(hQ),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gJ[#gJ+1]=bN(throtPosX+10,gv+40,"LIMIT","pbright txtstart")gJ[#gJ+1]=bN(throtPosX+10,gw+40,hQ.."%","pbright txtstart")end;if ao and AtmoSpeedAssist or Reentry then gJ[#gJ+1]=bN(throtPosX+10,gv-40,"LIMIT: "..aX.." km/h","dim txtstart")elseif not ao and Autopilot then gJ[#gJ+1]=bN(throtPosX+10,gv-40,"LIMIT: "..h(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hU(gJ,hV)if throtPosX==0 and throtPosY==0 then return end;local hW=throtPosY-10;local hX=throtPosX+10;gJ[#gJ+1]=bN(0,0,"","pdim txt txtend")if p()==1 and not RemoteHud then hW=75 end;gJ[#gJ+1]=bN(hX,hW,h(hV).." km/h","pbright txtbig txtstart")end;local function hY(gJ)gJ[#gJ+1]=bN(g2(1900),g3(1070),j("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gJ[#gJ+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then gJ[#gJ+1]=bN(g2(960),g3(550),"Warning: Invalid Control Scheme Detected","warnings")gJ[#gJ+1]=bN(g2(960),g3(600),"Keyboard Scheme must be selected","warnings")gJ[#gJ+1]=bN(g2(960),g3(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hZ=g2(960)local h_=g3(860)local i0=g3(880)local i1=g3(900)local i2=g3(960)local i3=g3(200)local i4=g3(250)local i5=g3(960)if p()==1 and not RemoteHud then h_=g3(135)i0=g3(155)i1=g3(175)i3=g3(115)i4=g3(95)end;local i6="#222222"local i7="white"local i8="dimmer"local i9="pbright"local ia="#110000"local ib=i6;local ic=i8;if BrakeIsOn then gJ[#gJ+1]=bN(hZ,h_,"Brake Engaged","warnings")ia="#440000"ib=i7;ic=i9 elseif N>0 then gJ[#gJ+1]=bN(hZ,h_,"Auto-Brake Engaged","warnings","opacity:"..N)end;local id="#110000"local ie=i6;local ig=i8;if ao and aV and am==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bf and not VertTakeOff and not AutoTakeoff then gJ[#gJ+1]=bN(hZ,i3+50,"** STALL WARNING **","warnings")id="#ff0000"ie=i7;ig=i9;bA("stall","SW",2)end end;if bn then gJ[#gJ+1]=bN(hZ,i3+90,"Flight Assist in Progress","warnings")end;if av then gJ[#gJ+1]=bN(hZ,i5,"Gyro Enabled","warnings")end;local ih="#111100"local ii=i6;local ij=i8;if GearExtended then ih="#775500"ii=i7;ij=i9;if U then gJ[#gJ+1]=bN(hZ,i0,"Gear Extended","warn")else gJ[#gJ+1]=bN(hZ,i0,"Landed (G: Takeoff)","warnings")end;local ik=bW(d:getTargetGroundAltitude())gJ[#gJ+1]=bN(hZ,i1,"Hover Height: "..ik,"warn")end;local il="#000011"local im=i6;local io=i8;if a5 then il="#0000DD"im=i7;io=i9;gJ[#gJ+1]=bN(hZ,i2+20,"ROCKET BOOST ENABLED","warn")end;local ip="#001100"local iq=i6;local ir=i8;if antigrav and not ExternalAGG and bf and AntigravTargetAltitude~=nil then ip="#00DD00"iq=i7;ir=i9;if g(aq-antigrav.getBaseAltitude())<501 then gJ[#gJ+1]=bN(hZ,i3+15,j("Target Altitude: %d Singularity Altitude: %d",h(AntigravTargetAltitude),h(antigrav.getBaseAltitude())),"warn")else gJ[#gJ+1]=bN(hZ,i3+15,j("Target Altitude: %d Singluarity Altitude: %d",h(AntigravTargetAltitude),h(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gJ[#gJ+1]=bN(hZ,i3+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gJ[#gJ+1]=bN(hZ,i3+20,j("LockedPitch: %d",h(LockPitch)),"warn")elseif a2 then gJ[#gJ+1]=bN(hZ,i3+20,"Follow Mode Engaged","warn")elseif Reentry or al then gJ[#gJ+1]=bN(hZ,i3+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ik=bW(HoldAltitude,2)if VertTakeOff then if bf then ik=bW(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gJ[#gJ+1]=bN(hZ,i3,"VTO to "..ik,"warn")elseif AutoTakeoff and not IntoOrbit then if ak then gJ[#gJ+1]=bN(hZ,i3,"Takeoff to "..AutopilotTargetName,"warn")else gJ[#gJ+1]=bN(hZ,i3,"Takeoff to "..ik,"warn")end;if BrakeIsOn and not VertTakeOff then gJ[#gJ+1]=bN(hZ,i3+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gJ[#gJ+1]=bN(hZ,i3,"Altitude Hold: "..ik,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ap>0.1 then gJ[#gJ+1]=bN(hZ,i3+20,"Beginning ascent","warn")elseif ap<0.09 and ap>0.05 then gJ[#gJ+1]=bN(hZ,i3+20,"Aligning trajectory","warn")elseif ap<0.05 then gJ[#gJ+1]=bN(hZ,i3+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if aZ~=nil then gJ[#gJ+1]=bN(hZ,i3,aZ,"warn")end end;if BrakeLanding then if StrongBrakes then gJ[#gJ+1]=bN(hZ,i3,"Brake-Landing","warnings")else gJ[#gJ+1]=bN(hZ,i3,"Coast-Landing","warnings")end end;if ProgradeIsOn then gJ[#gJ+1]=bN(hZ,i3,"Prograde Alignment","crit")end;if RetrogradeIsOn then gJ[#gJ+1]=bN(hZ,i3,"Retrograde Alignment","crit")end;local is="#110000"local it=i6;local iu=i8;if bq then is="#FF0000"it=i7;iu=i9;local type;if string.find(bq,"COLLISION")then type="warnings"else type="crit"end;gJ[#gJ+1]=bN(hZ,i4+20,bq,type)elseif ap==0 then local iv,iw=aO.checkLOS(b9:normalize())if iw~=nil then iu=i9;is="#FF0000"it=i7;local ik=bW(iw)local travelTime=aJ.computeTravelTime(ba,0,iw)local ix="Collision"if iv.noAtmosphericDensityAltitude>0 then ix="Atmosphere"end;gJ[#gJ+1]=bN(hZ,i4+20,iv.name.." "..ix.." "..bZ(travelTime).." In "..ik,"crit")end end;if VectorToTarget and not IntoOrbit then gJ[#gJ+1]=bN(hZ,i3+35,VectorStatus,"warn")end;local iy="#111100"local iz=i6;local iA=i8;if bv and#bv>1 then iy="#DDDD00"iz=i7;iA=i9 end;local iB=g2;local iC=g3;local i8="topButton"local iD="topButtonActive"local iE=i8;if Autopilot or VectorToTarget or ak or IntoOrbit then iE=iD end;local iF=i8;if ProgradeIsOn then iF=iD end;local iG=i8;if BrakeLanding or GearExtended then iG=iD end;local iH=i8;if AltitudeHold or VectorToTarget then iH=iD end;local iI=i8;if RetrogradeIsOn then iI=iD end;local iJ=i8;if IntoOrbit or b1 and Autopilot then iJ=iD end;if showHud and DisplayOdometer then local iK=iC(30)gJ[#gJ+1]=j([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],iE,iB(960),iC(54),iC(-53),iB(-120),iB(25),iC(50))gJ[#gJ+1]=bN(iB(910),iK,"AUTOPILOT")gJ[#gJ+1]=j([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iF,iB(865),iC(51),iB(-25),iC(-50),iB(-110),iB(25),iC(46))gJ[#gJ+1]=bN(iB(800),iK,"PROGRADE")gJ[#gJ+1]=j([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iG,iB(755),iC(47),iB(-25),iC(-46),iB(-98),iB(44),iC(44))gJ[#gJ+1]=bN(iB(700),iK,"LAND")gJ[#gJ+1]=j([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],iH,iB(960),iC(54),iC(-53),iB(120),iB(-25),iC(50))gJ[#gJ+1]=bN(iB(1010),iK,"ALT HOLD")gJ[#gJ+1]=j([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iI,iB(1055),iC(51),iB(25),iC(-50),iB(110),iB(-25),iC(46))gJ[#gJ+1]=bN(iB(1122),iK,"RETROGRADE")gJ[#gJ+1]=j([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],iJ,iB(1165),iC(47),iB(25),iC(-46),iB(98),iB(-44),iC(44))gJ[#gJ+1]=bN(iB(1220),iK,"ORBIT")gJ[#gJ+1]=[[
                                    </g>
                                </g>]]gJ[#gJ+1]="</g>"end;return gJ end;local function iL(dZ)return h(C(dZ*3.6,0)+0.5).." km/h"end;local function iM(fe)local ft=AutopilotTargetName;if fe~=nil and type(fe)=="number"then if fe==0 then return"None"end;ft=bk[fe].name end;if ft==nil then ft=CustomTarget.name end;if ft==nil then ft="None"end;return ft end;local function iN(gJ)local iO=aO.routeWP(true)if#iO==0 then return end;local bO=g2(750)local bP=g3(360)if Autopilot or VectorToTarget then gJ[#gJ+1]=bN(bO,bP,"REMAINING ROUTE","pdim txtstart size20")else gJ[#gJ+1]=bN(bO,bP,"LOADED ROUTE","pdim txtstart size20")end;for c7,i in pairs(iO)do bP=bP+20;gJ[#gJ+1]=bN(bO,bP,c7 ..". "..iM(iO[c7]),"pdim txtstart size20")end end;local function iP(gJ)local bO=OrbitMapX+10;local bP=OrbitMapY+20;local iQ={}local iR={"Alt-4: AutoTakeoff to Target"}local iS={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iT={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iU={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iQ,"--------------DYNAMIC-----------------")if ao then if am~=-1 then bD(iQ,iR)if aa and planet and aa.name==planet.name then table.insert(iQ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bf then table.insert(iQ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iQ,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iQ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iQ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iQ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iQ,"G: Takeoff to hover height, raise gear")else table.insert(iQ,"G: Lowergear and Land")end else bD(iQ,iS)table.insert(iQ,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iQ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bD(iQ,iT)if shield_1 then table.insert(iQ,"Alt-Shift-5: Toggle shield off and on")table.insert(iQ,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iQ,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iQ,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iQ,"Alt-Spacebar/C will raise/lower target height")table.insert(iQ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not ao then table.insert(iQ,"LALT+Mousewheel will lower/raise speed limit")end;bD(iQ,iU)for i=1,#iQ do bP=bP+12;gJ[#gJ+1]=bN(bO,bP,iQ[i],"pdim txtbig txtstart")end end;local function iV(gJ)local iW=OrbitMapX;local iX=OrbitMapY;local iY=OrbitMapSize;local iZ=4;local i_=15;local bO=0;local bP=0;local j0,j1,j2,j3;local j4;local function j5(type)local j6,G,dZ,j7,bR,j8;if type=="Periapsis"then j6=j4.periapsis.altitude;G=j4.timeToPeriapsis;dZ=j4.periapsis.speed;bR="txtend"j7=12;j8=math.min(bO,iW+iY-planet.radius/j2-iZ*2)else j6=j4.apoapsis.altitude;G=j4.timeToApoapsis;dZ=j4.apoapsis.speed;j7=-12;bR="txtstart"j8=bO end;if ba<1 then G=0 end;gJ[#gJ+1]=j([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j8+j7,bP-5,bO,bP-5)gJ[#gJ+1]=j([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j8-j7*4,bP+2,bO,bP+2)gJ[#gJ+1]=bN(j8,bP,type,bR)bO=j8-j7*2;bP=bP+i_;local ik=bW(j6)gJ[#gJ+1]=bN(bO,bP,ik,bR)bP=bP+i_;gJ[#gJ+1]=bN(bO,bP,bZ(G),bR)bP=bP+i_;gJ[#gJ+1]=bN(bO,bP,iL(dZ),bR)end;local j9=iY*1.5;if SelectedTab=="INFO"then j9=25*7 end;if SelectedTab~="HIDE"then gJ[#gJ+1]=[[<g class="pbright txtorb txtmid">]]gJ[#gJ+1]=j('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',iY*2,j9,iW,iX)gJ[#gJ+1]=j([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],iY*2,j9,iW,iX)end;local ja=iY*1.5;local jb=iY*2;local jc=ja/2;local jd=iY;local je=iW+jd;local jf=iX+jc;local jg=iW+jb;local jh=iX+ja;if SelectedTab=="ORBIT"then iX=iX+iZ;j0=iY/2;j3=0;j4={}j4.periapsis={}j4.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then j4.periapsis.altitude=orbit.periapsis.altitude;j4.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then j4.apoapsis.altitude=orbit.apoapsis.altitude;j4.apoapsis.speed=orbit.apoapsis.speed end;j4.period=orbit.period;j4.eccentricity=orbit.eccentricity;j4.timeToApoapsis=orbit.timeToApoapsis;j4.timeToPeriapsis=orbit.timeToPeriapsis;j4.eccentricAnomaly=orbit.eccentricAnomaly;j4.trueAnomaly=orbit.trueAnomaly end;if j4.periapsis==nil then j4.periapsis={}j4.periapsis.altitude=-planet.radius;j4.periapsis.speed=MaxGameVelocity end;if j4.eccentricity==nil then j4.eccentricity=1 end;if j4.apoapsis==nil then j4.apoapsis={}j4.apoapsis.altitude=aq;j4.apoapsis.speed=0 end;if ba<1 then j4.apoapsis.altitude=aq;j4.apoapsis.speed=0 end;if j4.apoapsis.altitude then j2=(j4.apoapsis.altitude+j4.periapsis.altitude+planet.radius*2)/(j0*2)j1=(planet.radius+j4.apoapsis.altitude)/j2*(1-j4.eccentricity)j3=j0-j4.periapsis.altitude/j2-planet.radius/j2;local ji=math.pi;if j4.period~=nil and j4.period>0 and j4.timeToApoapsis~=nil then ji=j4.eccentricAnomaly;if j4.timeToPeriapsis<j4.timeToApoapsis then ji=2*math.pi-ji end end;if ba<1 or ji~=ji then ji=math.pi end;local jj=-j0*math.cos(ji)+iW+jd+iZ;local jk=j1*math.sin(ji)+iX+jc+iZ;local jl=""gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'gJ[#gJ+1]=j([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jl,iW+iY+iZ,iX+iY*1.5/2+iZ,j0,j1)if j1<1 then gJ[#gJ+1]=j([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iW+iY+iZ-j3,iX+iY*1.5/2+iZ,jj,jk)end;gJ[#gJ+1]=j('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iW+iY+iZ-j3,iX+iY*1.5/2+iZ,(planet.radius+planet.noAtmosphericDensityAltitude)/j2)gJ[#gJ+1]=j('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iW+iY+iZ-j3,iX+iY*1.5/2+iZ,(planet.radius+planet.noAtmosphericDensityAltitude)/j2)gJ[#gJ+1]=j([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iW+iY+iZ,iX+iY*1.5/2+iZ,j0,j1)gJ[#gJ+1]=j('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iW+iY+iZ-j3,iX+iY*1.5/2+iZ,planet.radius/j2)gJ[#gJ+1]='</g>'local jm=math.floor(planet.radius/j2+0.5)local jn=g7.Generic_Moon;if g7[planet.name]then jn=g7[planet.name]end;bO=iW+iY+iZ*4+j0;bP=iX+iY*1.5/2+5+iZ;if j4.apoapsis~=nil and j4.apoapsis.speed<MaxGameVelocity then j5("Apoapsis")end;bP=iX+iY*1.5/2+5+iZ;bO=iW+iY-iZ*2-j0;if j4.periapsis~=nil and j4.periapsis.speed<MaxGameVelocity and j4.periapsis.altitude>0 then j5("Periapsis")end;gJ[#gJ+1]=bN(iW+iY+iZ,iX+20+iZ,planet.name,"txtorbbig")gJ[#gJ+1]=j('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jj,jk)gJ[#gJ+1]=[[</g>]]return gJ else gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'local jo=""local jp=1.2*(maxAtlasX-minAtlasX)/(iY*2)local jq=1.4*(maxAtlasY-minAtlasY)/(iY*1.5)for c7,c8 in pairs(e[0])do if c8.center then local bO=iW+iY+c8.center.x/jp;local bP=iX+iY*1.5/2+c8.center.y/jq;jo=jo..'<circle cx="'..bO..'" cy="'..bP..'" r="'..c8.radius/jp*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(c8.name,"Moon")and not string.match(c8.name,"Sanctuary")and not string.match(c8.name,"Space")then jo=jo.."<text x='"..bO.."' y='"..bP+c8.radius/jp*30+20 .."' font-size='12' fill="..aw.." text-anchor='middle' font-family='Montserrat'>"..c8.name.."</text>"end end end;local e2=vec3(b.getConstructWorldPos())local bO=iW+iY+e2.x/jp;local bP=iX+iY*1.5/2+e2.y/jq;jo=jo..'<circle cx="'..bO..'" cy="'..bP..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jo=jo.."<text x='"..bO.."' y='"..bP-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fP=jp;fQ=jq;local jr=e2+b9*1000000;local js=iW+iY+jr.x/jp;local gw=iX+iY*1.5/2+jr.y/jq;jo=jo..'<line x1="'..bO..'" y1="'..bP..'" x2="'..js..'" y2="'..gw..'" stroke="purple" stroke-width="1"/>'gJ[#gJ+1]=jo;gJ[#gJ+1]='</g>'end elseif SelectedTab=="INFO"then gJ=aM.DrawOdometer(gJ,ab,TotalDistanceTravelled,ac)elseif SelectedTab=="HELP"then gJ=iP(gJ)elseif SelectedTab=="SCOPE"then gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'local jt=by;if ap>0 then table.sort(bx,function(db,dc)local bU,bV=db.center,dc.center;return(bU.x-bd.x)^2+(bU.y-bd.y)^2+(bU.z-bd.z)^2<(bV.x-bd.x)^2+(bV.y-bd.y)^2+(bV.z-bd.z)^2 end)end;local ev={}local ju={}local jv=120;local jw=nil;local jx=nil;for i,c8 in ipairs(bx)do local eu=c8.center-bd;local jy=eu:len()local jz=eu:normalize()local jA=eu:cross(b6):normalize()local jB=math.acos(jA:dot(b7))if jB~=jB then jB=0 end;if jA:cross(b7):dot(b6)<0 then jB=-jB end;local jC=eu:project_on_plane(b6):len()local jD=math.sin(jB)*math.asin(jC/jy)*constants.rad2deg;local jE=math.cos(jB)*math.asin(jC/jy)*constants.rad2deg;if jz:dot(b6)<0 then jE=90*math.cos(jB)+90*math.cos(jB)-jE;jD=90*math.sin(jB)+90*math.sin(jB)-jD end;local bO=je+jD/jt*ja;local bP=jf+jE/jt*ja;local jF=(bO-je)*(bO-je)+(bP-jf)*(bP-jf)local jG=math.asin((c8.radius+c8.surfaceMaxAltitude)/jy)*constants.rad2deg;if jG~=jG then jG=jt end;local fq=jG/jt*ja;local jH=math.asin(c8.atmosphereRadius/jy)*constants.rad2deg;if jH~=jH then jH=jG end;local jI=jH/jt*ja;local ah=bW(jy,1)local jJ=c8.name;local jK=false;if bP>iX then if bP>jh then if bP-jI<=jh then jK=true end else jK=true end else if bP+jI>=iX then jK=true end end;local jL=false;local jM=bO;if c8.systemId==0 then jM=bO+jv else jM=bO-jv end;if jM+jv>iW then if jM+jv>jg then if jM-jI-jv<=jg then jL=true end else jL=true end else if jM+jI+jv>=iW then jL=true end end;local jN={}jN.x=bO;jN.y=bP;jN.planet=c8;jN.atmoSize=jI;if not jw or jF<jw then jw=jF;jx=jN end;if jL and jK then local jO=math.max(jI,5)if jF<jO*jO then jJ=jJ.." - "..ah end;jN.size=fq;jN.i=i;jN.displayString=jJ;jN.distance=ah;jN.visible=true;ju[#ju+1]=jN else jN.visible=false end end;local jP=false;table.sort(ju,function(bU,bV)return bU.y<bV.y end)for c7,e5 in ipairs(ju)do local c8,fq,i,jI,bO,bP,jJ,ah=e5.planet,e5.size,e5.i,e5.atmoSize,e5.x,e5.y,e5.displayString,e5.distance;local j8,jQ,jR,jS;local jT=15;local bR="pdim"if c8.systemId~=0 then jR=g2(string.len(jJ)*5)jT=-(15+jR)jS=g3(10)bR="pdimfill"else jR=g2(string.len(jJ)*9)jS=g3(15)end;if fq*2>jR then j8=t(bO,iW+jR/2,jg-jR/2)jQ=t(bP,iX+jS,jh-5)j8=t(j8,bO-fq+jR/2,bO+fq-jR/2)jQ=t(jQ,bP-fq+jS,bP+fq)else j8=bO+jT;jQ=bP end;for jU,e5 in pairs(ev)do local jV=e5.textPositions;local jW=jV.y-jQ;if jU~=i and g(jW)<jV.height and jV.x+jV.width>j8 and jV.x<j8+jR then if fq>jR then jQ=t(jQ+jS,iX+15,jh-5)else jQ=jV.y+jV.height+1 end end end;local jX=jJ~=c8.name or j8<=je and j8+jR>=je and jQ-jS<=jf and jQ>=jf;e5.hovered=jX;local jY=1;if jX then jY=2;if fq*2<jR then jY=10 end;if jJ==c8.name then jJ=jJ.." - "..ah end;bR="pbright"if c8.systemId~=0 then jR=g2(string.len(jJ)*5)jT=-(15+jR)else jR=g2(string.len(jJ)*7)end;if fq*2>jR then j8=t(bO,iW+jR/2,jg-jR/2)j8=t(j8,bO-fq+jR/2,bO+fq-jR/2)else j8=bO+jT end end;ev[i]={}ev[i].textPositions={}ev[i].textPositions.y=jQ;ev[i].textPositions.x=j8;ev[i].textPositions.width=jR;ev[i].textPositions.height=jS;ev[i].output=""if fq*2>jR then bR=bR.." txtmid"else bR=bR.." txtstart"end;if jI-fq>2 then ev[i].output=j('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',bO,bP,jI,ax,0.1*jY)end;ev[i].output=ev[i].output..j('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',bO,bP,fq,ax,0.2*jY)if c8.systemId==0 then ev[i].output=ev[i].output..j([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j8,jQ,aw,bR,jJ)if fq*2<=jR then ev[i].output=ev[i].output..j("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j8+jR,jQ+2,j8,jQ+2,bO,bP)end else ev[i].output=ev[i].output..j([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j8,jQ,ax,bR,jJ)if fq*2<=jR then ev[i].output=ev[i].output..j("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j8,jQ+2,j8+jR,jQ+2,bO,bP)end end end;for c7=#bx,1,-1 do if ev[c7]then gJ[#gJ+1]=ev[c7].output end end;if jx~=nil and by<90 and not jx.hovered then local jZ=jx.planet.atmosphereRadius/jx.atmoSize;local j_=A(jw)*jZ;local k0=bW(j_,1)local jR=g2(math.max(string.len(k0)*7,string.len(jx.planet.name)*7))local jS=g3(12)local j8=t(jx.x+(je-jx.x)/2,iW+jR/2,jg-jR/2)local jQ=t(jx.y+(jf-jx.y)/2,iX+jS*2,jh-5)gJ[#gJ+1]=j("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",jx.x,jx.y,je,jf)gJ[#gJ+1]=j([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j8,jQ,"white",k0)if not jx.visible then gJ[#gJ+1]=j([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j8,jQ-jS,"white",jx.planet.name)end end;if ba>1 then local eu=b9;local jz=eu:normalize()local jC=eu:project_on_plane(b6):len()local jA=eu:cross(b6):normalize()local jB=math.acos(jA:dot(b7))if jB~=jB then jB=0 end;if jA:cross(b7):dot(b6)<0 then jB=-jB end;local jD=math.sin(jB)*math.asin(jC/eu:len())*constants.rad2deg;local jE=math.cos(jB)*math.asin(jC/eu:len())*constants.rad2deg;if jz:dot(b6)<0 then jE=90*math.cos(jB)+90*math.cos(jB)-jE;jD=90*math.sin(jB)+90*math.sin(jB)-jD end;local bO=je+jD/jt*ja;local bP=jf+jE/jt*ja;local hF=14;local hG=hF/2;local hJ=[[<circle
                                    cx="]]..bO..[["
                                    cy="]]..bP..[["
                                    r="]]..hG/hF..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..bO..[["
                                    cy="]]..bP..[["
                                    r="]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bO-hF..[[,]]..bP..[[ h ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bO+hG..[[,]]..bP..[[ h ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bO..[[,]]..bP-hF..[[ v ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]gJ[#gJ+1]=hJ end;gJ[#gJ+1]=j("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",je,jf-10,je,jf+10)gJ[#gJ+1]=j("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",je-10,jf,je+10,jf)gJ[#gJ+1]='</g>'else return gJ end end;local function k1(k2,k3)local k4;local k5=(k3-k2):normalize()local e3=(bd-k2):dot(k5)/k5:dot(k5)if e3<=0.then return(bd-k2):len()elseif e3>=(k3-k2):len()then return(bd-k3):len()end;local k6=k2+e3*k5;k4=(k6-bd):len()return k4 end;local function k7()local k4;local k8=nil;local k9=nil;local ka=nil;for c7,kb in pairs(e[0])do if kb.hasAtmosphere then local ah=k1(planet.center,kb.center)if k8==nil or ah<k8 then k9=kb;k8=ah;ka=planet end;if aa and aa.hasAtmosphere and aa.name~=planet.name then local dp=k1(aa.center,kb.center)if dp<k8 then k9=kb;k8=dp;ka=aa end end end end;local kc=g2(1770)local kd=g3(330)if k8 then local ke="txttick "local kf=500000;if k8<k9.radius+kf or k8<ka.radius+kf then if bl then ke="txttick red "else ke="txttick orange "end end;k4=bW(k8,2)fU=bN(kc,kd,"Pipe ("..ka.name.."--"..k9.name.."): "..k4,ke.."pbright txtmid")end end;local function kg(bO,bP,kh,ki,hS)local kj={x=bO,y=bP,width=kh,height=ki,label=hS}bu[hS]=kj;return kj end;local function kk(kl,km,kh,ki,bO,bP,kn,ko,kp,kq,bR)local kj={enableName=kl,disableName=km,width=kh,height=ki,x=bO,y=bP,toggleVar=kn,toggleFunction=ko,drawCondition=kp,hovered=false,class=bR}if kq then table.insert(fO,kj)else table.insert(fN,kj)end;return kj end;local function kr(ks)if not fS then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif ks=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif ks=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif ks=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fT=bG(ks)showHud=false else fT={}showHud=true end end;local function kt()fS=not fS;if fS then fM=fO;a4="Hold SHIFT to see Settings"bz=showHud else fM=fN;a4="Hold SHIFT to see Control Buttons"kr()showHud=bz end end;local function ku()local function kv(c8)_G[c8]=not _G[c8]if _G[c8]then a4=c8 .." set to true"else a4=c8 .." set to false"end;if c8=="showHud"then bz=_G[c8]elseif c8=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local kw=50;local kx=340;local bO=500;local bP=aB/2-400;local ky=0;for c7,c8 in pairs(bG("boolean"))do if type(_G[c8])=="boolean"then kk(c8,c8,kx,kw,bO,bP,function()return _G[c8]end,function()kv(c8)end,function()return true end,true)bP=bP+kw+20;if ky==9 then bO=bO+kx+20;bP=aB/2-400;ky=0 else ky=ky+1 end end end;kk("Control View","Control View",kx,kw,10,aB/2-500,function()return true end,kt,function()return true end,true)kk("View Handling Settings",'Hide Handling Settings',kx,kw,10,aB/2-(500-kw),function()return showHandlingVariables end,function()kr("handling")end,function()return true end,true)kk("View Hud Settings",'Hide Hud Settings',kx,kw,10,aB/2-(500-kw*2),function()return showHudVariables end,function()kr("hud")end,function()return true end,true)kk("View Physics Settings",'Hide Physics Settings',kx,kw,10,aB/2-(500-kw*3),function()return showPhysicsVariables end,function()kr("physics")end,function()return true end,true)end;local function kz()local function kA()local position=bd;local ft=planet.name..". "..#SavedLocations;if radar_1 then ft=aP.GetClosestName(ft)end;return aN.AddNewLocation(ft,position,false,true)end;local function kB()TurnBurn=not TurnBurn end;local function kC(kD)if kD==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a2=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kE()aN.UpdatePosition()end;local function kF()aN.ClearCurrentPosition()end;local function kG(fe)local iO=aO.routeWP(true)if#iO>0 then return"Engage Route: "..iM(iO[1])end;return"Engage Autopilot: "..iM(fe)end;local function kH(fe)local iO=aO.routeWP(true)if#iO>0 then return"Next Route Point: "..iM(iO[1])end;return"Disable Autopilot: "..iM(fe)end;local function kI()if p()==1 then a2=not a2;if a2 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;d.control.retractLandingGears()u:setTargetGroundAltitude(TargetHoverHeight)bA("folOn","F")else bA("folOff","F")BrakeIsOn=true;aT=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then d.control.extendLandingGears()u:setTargetGroundAltitude(LandingGearGroundHeight)end end else a4="Follow Mode only works with Remote controller"a2=false end end;local kw=50;local kx=260;local kJ=g2(30)local kK=OrbitMapX+OrbitMapSize*2+2;local kL=OrbitMapY+1;kk("+","+",kJ,kJ,kK,kL+kJ+1,function()return false end,function()by=by/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")kk("-","-",kJ,kJ,kK,kL,function()return false end,function()by=math.min(by*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")kk("0","0",kJ,kJ,kK,kL+kJ*2+2,function()return false end,function()by=90 end,function()return SelectedTab=="SCOPE"and by~=90 end,nil,"ZoomButton")local kM=kk("Enable Brake Toggle","Disable Brake Toggle",kx,kw,aA/2-kx/2,aB/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a4="Brakes in Toggle Mode"else a4="Brakes in Default Mode"end end)kk("Align Prograde","Disable Prograde",kx,kw,aA/2-kx/2-50-kM.width,aB/2-kw+380,function()return ProgradeIsOn end,function()kC(1)end)kk("Align Retrograde","Disable Retrograde",kx,kw,aA/2-kx/2+kM.width+50,aB/2-kw+380,function()return RetrogradeIsOn end,kC,function()return ap==0 end)apbutton=kk(kG,kH,600,60,aA/2-600/2,aB/2-60/2-330,function()return Autopilot or VectorToTarget or ak or IntoOrbit end,function()end)local i;local function kN(kO)local iO=aO.routeWP(true)if#iO>0 then return iO[1]end;local fe=bt+kO;if fe>#bk then fe=fe-#bk-1 end;if fe<0 then fe=#bk+fe end;return fe end;apExtraButtons={}for i=0,10 do local button=kk(function(bV)local fe=kN(bV.apExtraIndex)if Autopilot or VectorToTarget or ak or IntoOrbit then return"Redirect: "..iM(fe)end;return kG(fe)end,function(bV)local fe=kN(bV.apExtraIndex)return kH(fe)end,600,60,aA/2-600/2,aB/2-60/2-330+60*i,function(bV)local fe=kN(bV.apExtraIndex)return fe==AutopilotTargetIndex and(Autopilot or VectorToTarget or ak or IntoOrbit)end,function(bV)local fe=kN(bV.apExtraIndex)local kP=AutopilotTargetIndex==fe;AutopilotTargetIndex=fe;aN.UpdateAutopilotTarget()aO.ToggleAutopilot()if not kP and not(Autopilot or VectorToTarget or ak or IntoOrbit)then aO.ToggleAutopilot()end end,function()return bs and(#aO.routeWP(true)==0 or i==0)end)button.apExtraIndex=i;apExtraButtons[i]=button end;kk("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kA,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)kk("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kE,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kk("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kF,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kk("Save Route","Save Route",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y+apbutton.height+20,function()return false end,function()aO.routeWP(false,false,2)end,function()return#aO.routeWP(true)>0 end)kk("Load Route","Clear Route",200,apbutton.height,apbutton.x-200-30,apbutton.y+apbutton.height+20,function()return#aO.routeWP(true)>0 end,function()if#aO.routeWP(true)>0 then aO.routeWP(false,true)elseif Autopilot or VectorToTarget then a4="Disable Autopilot before loading route"return else aO.routeWP(false,false,1)end end,function()return true end)kw=60;kx=300;local bO=0;local bP=aB/2-150;kk("View Settings","View Settings",kx,kw,bO,bP,function()return true end,kt)bP=bP+kw+20;kk("Enable Turn and Burn","Disable Turn and Burn",kx,kw,bO,bP,function()return TurnBurn end,kB)bO=10;bP=aB/2-300;kk("Horizontal Takeoff Mode","Vertical Takeoff Mode",kx,kw,bO+kx+20,bP,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a4="Vertical Takeoff Mode"else a4="Horizontal Takeoff Mode"end end,function()return be end)bP=bP+kw+20;kk("Engage Orbiting","Cancel Orbiting",kx,kw,bO+kx+20,bP,function()return IntoOrbit end,aO.ToggleIntoOrbit,function()return ap==0 and bp end)bP=aB/2-150;kk("Glide Re-Entry","Cancel Glide Re-Entry",kx,kw,bO+kx+20,bP,function()return Reentry end,function()aj=1;kC(1)end,function()return planet.hasAtmosphere and not ao end)bP=bP+kw+20;kk("Parachute Re-Entry","Cancel Parachute Re-Entry",kx,kw,bO+kx+20,bP,function()return Reentry end,aO.BeginReentry,function()return planet.hasAtmosphere and not ao end)bP=bP+kw+20;kk("Engage Follow Mode","Disable Follow Mode",kx,kw,bO,bP,function()return a2 end,kI,function()return p()==1 end)kk("Enable Repair Arrows","Disable Repair Arrows",kx,kw,bO+kx+20,bP,function()return aG end,function()aG=not aG;if aG then a4="Repair Arrows Enabled"else a4="Repair Arrows Diabled"end end,function()return p()==1 end)bP=bP+kw+20;if not ExternalAGG then kk("Enable AGG","Disable AGG",kx,kw,bO,bP,function()return bf end,aO.ToggleAntigrav,function()return antigrav~=nil end)end;kk(function()return j("Switch IPH Mode - Current: %s",iphCondition)end,function()return j("IPH Mode: %s",iphCondition)end,kx*2,kw,bO,bP,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a4="IPH Mode: "..iphCondition end)bP=bP+kw+20;kk(function()return j("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return j("Control Scheme: %s",userControlScheme)end,kx*2,kw,bO,bP,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a4="New Control Scheme: "..userControlScheme end)local kQ=g3(20)local button=kg(0,0,g2(70),kQ,"HELP")button=kg(button.x+button.width,button.y,g2(80),kQ,"INFO")button=kg(button.x+button.width,button.y,g2(70),kQ,"ORBIT")button=kg(button.x+button.width,button.y,g2(70),kQ,"SCOPE")kg(button.x+button.width,button.y,g2(70),kQ,"HIDE")end;local kR={}local kS=nil;function kR.HUDPrologue(gJ)bl,bm=g0(bd)if not bl then J=PvPR;L=PvPG;K=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else J=SafeR;L=SafeG;K=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;aw=[[rgb(]]..h(J+0.6)..","..h(L+0.6)..","..h(K+0.6)..[[)]]ax=[[rgb(]]..h(J*0.8+0.5)..","..h(L*0.8+0.5)..","..h(K*0.8+0.5)..[[)]]local kT=aw;local kU=ax;local kV=[[rgb(]]..h(J*0.4+0.5)..","..h(L*0.4+0.5)..","..h(K*0.4+0.5)..[[)]]local kW=aw;local kX=ax;local kY=kV;if g4()and not brightHud then kT=[[rgb(]]..h(J*0.5+0.5)..","..h(L*0.5+0.5)..","..h(K*0.5+0.5)..[[)]]kU=[[rgb(]]..h(J*0.3+0.5)..","..h(L*0.3+0.5)..","..h(K*0.2+0.5)..[[)]]kV=[[rgb(]]..h(J*0.2+0.5)..","..h(L*0.2+0.5)..","..h(K*0.2+0.5)..[[)]]end;local iB=g2;local iC=g3;gJ[#gJ+1]=j([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],kT,kT,kT,kW,kW,kU,kU,kX,kX,kU,kT,kV,kX,kT,kT,kV,kV,kY,kV,aA,aB,kU,kU,kU,kU,kU,kW,kU,kX,kY,kX,kX,kY)if not kS then kS=j([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iB(630),iC(0),iB(675),iC(45),iB(960),iC(55),iB(1245),iC(45),iB(1290),iC(0),iB(1000),iC(105),iB(1040),iC(59),iB(1250),iC(51),iB(1300),iC(0),iB(1920),iC(0),iB(1920),iC(20),iB(1400),iC(20),iB(1300),iC(105),iB(920),iC(105),iB(880),iC(59),iB(670),iC(51),iB(620),iC(0),iB(0),iC(0),iB(0),iC(20),iB(520),iC(20),iB(620),iC(105),iB(890),iC(59),iB(960),iC(62),iB(1030),iC(59),iB(985),iC(112),iB(1150),iC(112),iB(1100),iC(152),iB(820),iC(152),iB(780),iC(112),iB(935),iC(112),iB(890),iC(59),iB(960),iC(62),iB(1030),iC(59),iB(985),iC(112),iB(1150),iC(112),iB(1100),iC(152),iB(820),iC(152),iB(780),iC(112),iB(935),iC(112))end;if showHud and DisplayOdometer then gJ[#gJ+1]=kS end;return gJ end;function kR.DrawVerticalSpeed(gJ,cJ)gI(gJ,cJ)end;function kR.UpdateHud(gJ)local hy=bi;local kZ=bj;local gR=kZ;local h5=hy;local hQ=h(c.getThrottle())local hV=ba*3.6;local hR=c.getAxisCommandValue(0)local k_=g2(1770)local l0=g3(310)if AtmoSpeedAssist and bh then hR=M;hQ=M*100 end;local g6=g5()local gS="ROLL"if hQ==nil then hQ=0 end;if not bp then if ba>5 then hy=hx(b8)kZ=hz(b8)else hy=0;kZ=0 end;gS="YAW"end;if bm>50000 and not ao then local l1;l1=bW(bm)gJ[#gJ+1]=bN(k_,l0,"PvP Boundary: "..l1,"pbright txtbig txtmid")end;gJ[#gJ+1]=ai;gJ[#gJ+1]=az;gJ[#gJ+1]=fI;if fU~=""then gJ[#gJ+1]=fU end;if g8~=""then gJ[#gJ+1]=g8 end;if g9~=""then gJ[#gJ+1]=g9 end;gI(gJ,aq)if p()==0 or RemoteHud then if bp then gQ(gJ,centerX,centerY,gR,gS,bp)else gQ(gJ,centerX,centerY,kZ,gS,bp)end;if not g4()or brightHud then if bp then gQ(gJ,centerX,centerY,gR,gS,bp)h4(gJ,h5,gR,centerX,centerY,bp,h(hz(b8)),ba)else gQ(gJ,centerX,centerY,kZ,gS,bp)h4(gJ,hy,kZ,centerX,centerY,bp,h(kZ),ba)end;hb(gJ,aq,bp)hA(gJ,b8,ba,centerX,centerY)end end;hP(gJ,g6,hQ,hR)hU(gJ,hV)hY(gJ)iV(gJ)if not fS and a3 then iN(gJ)end;return gJ end;function kR.HUDEpilogue(gJ)gJ[#gJ+1]="</svg>"return gJ end;function kR.ExtraData(gJ)local l2=g2(1240)local l3=g3(55)local l4=l3+10;local l5;local iB=g2;local iC=g3;local l6=0;local g6=g5()if VertTakeOffEngine then g6=g6 .."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and ba>20 then g6=g6 .."-COLLISION ON"end;if UseExtra~="Off"then g6="("..UseExtra..")-"..g6 end;if TurnBurn then g6="TB-"..g6 end;if not stablized then g6=g6 .."-DeCoupled"end;local l7=iC(99)local l8=iC(80)local l9=iC(85)local la=iC(31)local lb=0;local lc=0;local ld=at>1000000 and C(at/1000000,2).."kT"or C(at/1000,2).."T"if ao then l6=LastMaxBrakeInAtmo else l6=LastMaxBrake end;local le,lf=aJ.computeDistanceAndTime(ba,0,at,0,0,l6)if le<0 then le=0 end;l6=C(l6/(at*fL),2).."g"local lg=d:maxForceForward()l5=b.g()if l5>0.1 then lc=at*l5;lc=C(lc/(at*fL),2).."g"lb=0.5*lg/l5;lb=lb>1000000 and C(lb/1000000,2).."kT"or C(lb/1000,2).."T"end;lg=C(lg/(at*fL),2).."g"local lh=vec3(b.getWorldAcceleration()):len()/9.80665;l5=b.g()gJ[#gJ+1]=[[<g class="dim txt txtend size14">]]if p()==1 and not RemoteHud then l2=g2(1120)l3=g3(55)l4=l3+10 elseif ao and DisplayOdometer then local li=g2(770)gJ[#gJ+1]=bN(iB(895),l7,"ATMO","")gJ[#gJ+1]=j([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iB(895),l9,iB(-80))gJ[#gJ+1]=bN(iB(815),l8,j("%.1f%%",ap*100),"txtstart size20")end;if DisplayOdometer then gJ[#gJ+1]=bN(iB(1025),l7,"GRAVITY","txtstart")gJ[#gJ+1]=j([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1025),l9,iB(80))gJ[#gJ+1]=bN(iB(1105),l8,j("%.2fg",l5/9.80665),"size20")gJ[#gJ+1]=bN(iB(1125),l7,"ACCEL","txtstart")gJ[#gJ+1]=j([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1125),l9,iB(80))gJ[#gJ+1]=bN(iB(1205),l8,j("%.2fg",lh),"size20")gJ[#gJ+1]=bN(iB(695),l7,"BRK TIME","")gJ[#gJ+1]=j([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(695),l9,iB(-80))gJ[#gJ+1]=bN(iB(615),l8,j("%s",bZ(lf)),"txtstart size20")gJ[#gJ+1]=bN(iB(635),iC(45),"TRIP","")gJ[#gJ+1]=j([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(635),iC(31),iB(-90))if travelTime then gJ[#gJ+1]=bN(iB(532),iC(23),j("%s",bZ(travelTime)),"txtstart size20")end;gJ[#gJ+1]=bN(iB(795),l7,"BRK DIST","")gJ[#gJ+1]=j([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(795),l9,iB(-80))gJ[#gJ+1]=bN(iB(715),l8,j("%s",bW(le)),"txtstart size20")gJ[#gJ+1]=bN(iB(1285),iC(45),"MASS","txtstart")gJ[#gJ+1]=j([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1285),iC(31),iB(90))gJ[#gJ+1]=bN(iB(1388),iC(23),j("%s",ld),"size20")gJ[#gJ+1]=bN(iB(1220),l7,"THRUST","txtstart")gJ[#gJ+1]=j([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1220),l9,iB(80))gJ[#gJ+1]=bN(iB(1300),l8,j("%s",lg),"size20")gJ[#gJ+1]=bN(g2(960),g3(175),g6,"pbright txtbig txtmid size20")end;gJ[#gJ+1]="</g>"end;function kR.DrawOdometer(gJ,ab,TotalDistanceTravelled,ac)if SelectedTab~="INFO"then return gJ end;local l5;local lb=0;local lc=0;local l6=0;local ld=at>1000000 and C(at/1000000,2).." kTons"or C(at/1000,2).." Tons"if ao then l6=LastMaxBrakeInAtmo else l6=LastMaxBrake end;local le,lf=aJ.computeDistanceAndTime(ba,0,at,0,0,l6)l6=C(l6/(at*fL),2).." g"local lg=d:maxForceForward()l5=b.g()if l5>0.1 then lc=at*l5;lc=C(lc/(at*fL),2).." g"lb=0.5*lg/l5;lb=lb>1000000 and C(lb/1000000,2).." kTons"or C(lb/1000,2).." Tons"end;lg=C(lg/(at*fL),2).." g"if p()==0 or RemoteHud then local lj=g2(OrbitMapX+10)local lk=g3(OrbitMapY+20)local ll=g2(OrbitMapX+10+OrbitMapSize/1.25)local ki=25;gJ[#gJ+1]="<g class='txtstart size14 bright'>"gJ[#gJ+1]=bN(lj,lk,j("BrkTime: %s",bZ(lf)))gJ[#gJ+1]=bN(ll,lk,j("Trip: %.2f km",ab))gJ[#gJ+1]=bN(lj,lk+ki,j("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gJ[#gJ+1]=bN(ll,lk+ki,j("BrkDist: %s",bW(le)))gJ[#gJ+1]=bN(lj,lk+ki*2,"Trip Time: "..bZ(ac))gJ[#gJ+1]=bN(ll,lk+ki*2,"Total Time: "..bZ(TotalFlightTime))gJ[#gJ+1]=bN(lj,lk+ki*3,j("Mass: %s",ld))gJ[#gJ+1]=bN(ll,lk+ki*3,j("Max Brake: %s",l6))gJ[#gJ+1]=bN(lj,lk+ki*4,j("Max Thrust: %s",lg))if l5>0.1 then gJ[#gJ+1]=bN(ll,lk+ki*4,j("Max Thrust Mass: %s",lb))gJ[#gJ+1]=bN(lj,lk+ki*5,j("Req Thrust: %s",lc))else gJ[#gJ+1]=bN(ll,lk+ki*5,"Max Mass: n/a")gJ[#gJ+1]=bN(lj,lk+ki*6,"Req Thrust: n/a")end end;gJ[#gJ+1]="</g></g>"return gJ end;function kR.DrawWarnings(gJ)return hY(gJ)end;function kR.DisplayOrbitScreen(gJ)return iV(gJ)end;function kR.DisplayMessage(gJ,ik)if ik~="empty"then local bP=310;for lm in string.gmatch(ik,"([^\n]+)")do bP=bP+35;gJ[#gJ+1]=bN("50%",bP,lm,"msg")end end;if ag~=0 then c.setTimer("msgTick",ag)ag=0 end end;function kR.DrawDeadZone(gJ)gJ[#gJ+1]=j([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kR.UpdatePipe()if ao then fU=""return end;k7()end;function kR.DrawSettings(gJ)if#fT>0 then local bO=g2(640)local bP=g3(200)gJ[#gJ+1]=[[<g class="pbright txtvspd txtstart">]]for c7,c8 in pairs(fT)do gJ[#gJ+1]=bN(bO,bP,c8 ..": ".._G[c8])bP=bP+20;if c7%12==0 then bO=bO+g2(350)bP=g3(200)end end;gJ[#gJ+1]=bN(g2(640),g3(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gJ[#gJ+1]="</g>"end;return gJ end;local perisPanelID;local fF=g2(1770)local fG=g3(350)local fE=g3(15)local fD=g2(1370)local fJ,ln;local peris=0;function kR.DrawRadarInfo()fI=aP.GetRadarHud(fD,fE,fF,fG)end;function kR.DrawTanks()if fuelX~=0 and fuelY~=0 then g8=bN(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gp(fuelX,"Atmospheric ","ATMO",aC,gn,go)gp(fuelX,"Space Fuel T","SPACE",aD,gl,gm)gp(fuelX,"Rocket Fuel ","ROCKET",aE,gj,gk)end end;function kR.DrawShield()local lo=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local lp=b.getPvPTimer()local lq=shield_1.getResistances()local lr="A: "..10+lq[1]*100 .."% / E: "..10+lq[2]*100 .."% / K:"..10+lq[3]*100 .."% / T: "..10+lq[4]*100 .."%"local bO,bP=shieldX-60,shieldY+30;local ls=h(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gD=h(ls*2.55)local gE=j("rgb(%d,%d,%d)",255-gD,gD,0)local bR=""g9=bN(bO,bP,"","txtmid pdim txtfuel")if ls<10 and lo~="Shield Disabled"then bR="red "end;lp=lp>0 and"   PvPTime: "..bZ(lp)or""g9=g9 ..j([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bO,bP,gE,ls*2,bO,bP,bO+2,bP+10,ls,lp)g9=g9 ..bN(bO,bP-5,lo,bR.."txtstart pbright txtbig")g9=g9 ..bN(bO,bP+30,lr,bR.."txtstart pbright txtsmall")end;function kR.hudtick()if not planet then return end;local function lt(gJ)local gG=h(t(ah/(aA/4)*255,0,255))gJ[#gJ+1]=j("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ae,af,h(J+0.5)+gG,h(L+0.5)-gG,h(K+0.5)-gG)end;local function lu()for _,c8 in pairs(fM)do if c8.hovered then if not c8.drawCondition or c8.drawCondition(c8)then c8.toggleFunction(c8)end;c8.hovered=false end end;for _,c8 in pairs(bu)do if c8.hovered then SelectedTab=c8.label;c8.hovered=false end end end;local function lv()local function lw(lx,ly,bO,bP,kh,ki)if lx>=bO and lx<=bO+kh and ly>=bP and ly<=bP+ki then return true else return false end end;local bO=ae+aA/2;local bP=af+aB/2;for _,c8 in pairs(fM)do c8.hovered=lw(bO,bP,c8.x,c8.y,c8.width,c8.height)end;for _,c8 in pairs(bu)do c8.hovered=lw(bO,bP,c8.x,c8.y,c8.width,c8.height)end;if bs then local jX=false;for _,bV in ipairs(apExtraButtons)do if bV.hovered then jX=true;break end end;if apbutton.hovered then jX=true end;bs=jX else bs=apbutton.hovered;if not bs then bt=AutopilotTargetIndex end end end;local function lz(gJ)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;if showHud then for c7,c8 in pairs(bu)do local bR="dim brightstroke"local lA=0.2;if SelectedTab==c7 then bR="pbright dimstroke"lA=0.6 end;local lB=""if c8.hovered then lA=0.8;lB=";stroke:white"end;gJ[#gJ+1]=j([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],c8.width,c8.height,c8.x,c8.y,bR,lA,lB)gJ[#gJ+1]=bN(c8.x+c8.width/2,c8.y+c8.height/2+5,c8.label,"txt txtmid pdim")end end end;local function lC(gJ)local function lD(gJ,lE,hover,bO,bP,dS,lF,lG,lH,lI,lJ,button)if type(lI)=="function"then lI=lI(button)end;if type(lJ)=="function"then lJ=lJ(button)end;gJ[#gJ+1]=j("<rect x='%f' y='%f' width='%f' height='%f' fill='",bO,bP,dS,lF)if lE then gJ[#gJ+1]=j("%s'",lG)else gJ[#gJ+1]=lH end;if hover then gJ[#gJ+1]=j(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gJ[#gJ+1]=j(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",C(SafeR*0.5,0),C(SafeG*0.5,0),C(SafeB*0.5,0))end;gJ[#gJ+1]=" rx='5'></rect>"gJ[#gJ+1]=j("<text x='%f' y='%f' font-size='24' fill='",bO+dS/2,bP+lF/2+5)if lE then gJ[#gJ+1]="black"else gJ[#gJ+1]="white"end;gJ[#gJ+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lE then gJ[#gJ+1]=j("%s</text>",lI)else gJ[#gJ+1]=j("%s</text>",lJ)end end;local lK=j("rgb(%d,%d,%d)'",C(SafeR*0.1,0),C(SafeG*0.1,0),C(SafeB*0.1,0))local lL=j("rgb(%d,%d,%d)",C(SafeR*0.8,0),C(SafeG*0.8,0),C(SafeB*0.8,0))local lM=lD;for _,c8 in pairs(fM)do local km=c8.disableName;local kl=c8.enableName;if type(km)=="function"then km=km(c8)end;if type(kl)=="function"then kl=kl(c8)end;if not c8.drawCondition or c8.drawCondition(c8)then lM(gJ,c8.toggleVar(c8),c8.hovered,c8.x,c8.y,c8.width,c8.height,lL,lK,km,kl,c8)end end end;local lN=C(aA/2,0)local lO=C(aB/2,0)local gJ={}aM.HUDPrologue(gJ)if showHud then aM.UpdateHud(gJ)else if AlwaysVSpd then aM.DrawVerticalSpeed(gJ,aq)end;aM.DrawWarnings(gJ)end;if fS and fT~={}then aM.DrawSettings(gJ)end;if radar_1 then aM.DrawRadarInfo()end;aM.HUDEpilogue(gJ)gJ[#gJ+1]=j([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aA,aB)if a4~="empty"then aM.DisplayMessage(gJ,a4)end;if p()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aM.DrawDeadZone(gJ)end end;lz(gJ)if z()==0 then if p()==1 and a3 then if not AltIsOn then lv()lC(gJ)end;if not aR and not aS then local lP=table.concat(gJ,"")gJ={}gJ[#gJ+1]=j("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aA,aB)gJ[#gJ+1]=lP;gJ[#gJ+1]="</body>"aR=true;gJ[#gJ+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local content=table.concat(gJ,"")a.setScreen(content)elseif aS then local lP=table.concat(gJ,"")gJ={}gJ[#gJ+1]=j("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aA,aB)gJ[#gJ+1]=lP;gJ[#gJ+1]="</body>"end;if not aR then gJ[#gJ+1]=j([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lN,lO,ae,af)end else lu()end else if not a3 and p()==0 then lu()if ah>DeadZone then if DisplayDeadZone then lt(gJ)end end elseif a3 and(not AltIsOn or not freeLookToggle)then lv()lC(gJ)end;gJ[#gJ+1]=j([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lN,lO,ae,af)end;gJ[#gJ+1]=[[</svg></body>]]content=table.concat(gJ,"")end;function kR.TenthTick()aM.DrawTanks()if shield_1 then aM.DrawShield()end end;function kR.OneSecond(gJ)local function lQ()local gz=s()local hV=ba;local lR=gz-as;if hV>1.38889 then hV=hV/1000;local lS=hV*(gz-as)TotalDistanceTravelled=TotalDistanceTravelled+lS;ab=ab+lS end;ac=ac+lR;TotalFlightTime=TotalFlightTime+lR;as=gz end;lQ()aM.UpdatePipe()aM.ExtraData(gJ)end;function kR.ButtonSetup()ku()kz()fM=fN end;return kR end;local function lT()local function lU(position)local cE=sys:closestBody(position)if(position-cE.center):len()>cE.radius+cE.noAtmosphericDensityAltitude then cE=e[0][0]end;return cE end;local function lV()local function lW(lX,lY)return lX.name<lY.name end;bk={}for c7,c8 in pairs(e[0])do bk[#bk+1]={name=c8.name,index=c7}end;table.sort(bk,lW)end;local function lZ(l_)for c7,c8 in pairs(l_)do if c8.name and c8.name==CustomTarget.name then return c7 end end;return-1 end;local function m0()bt=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"aa=nil;CustomTarget=nil;return true end;local m1=bk[AutopilotTargetIndex].index;local m2=e[0][m1]if m2.center then AutopilotTargetName=m2.name;aa=aI[0][m1]if CustomTarget~=nil then if ap==0 then if w(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then x(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if w(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then x(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if w(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then x(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if w(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then x(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if w(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then x(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if w(widgetMaxMassText,widgetMaxMass)~=1 then x(widgetMaxMassText,widgetMaxMass)end;if w(widgetTravelTimeText,widgetTravelTime)~=1 then x(widgetTravelTimeText,widgetTravelTime)end;if w(widgetTargetOrbitText,widgetTargetOrbit)~=1 then x(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=m2;for _,c8 in pairs(aI[0])do if c8.name==CustomTarget.planetname then aa=c8;AutopilotTargetName=CustomTarget.name;break end end;if w(widgetMaxMassText,widgetMaxMass)~=1 then x(widgetMaxMassText,widgetMaxMass)end;if w(widgetTravelTimeText,widgetTravelTime)~=1 then x(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(aa.center)else AutopilotTargetCoords=CustomTarget.position end;if aa.planetname~="Space"then if aa.hasAtmosphere then AutopilotTargetOrbit=h(aa.radius*(TargetOrbitRadius-1)+aa.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=h(aa.radius*(TargetOrbitRadius-1)+aa.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aL(aa):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function m3(gN)if not Autopilot and not VectorToTarget and not ak and not IntoOrbit and not Reentry and not al then if gN==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bk then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bk end end;if AutopilotTargetIndex==0 then m0()else local m1=bk[AutopilotTargetIndex].index;local m2=e[0][m1]if m2~=nil and m2.name=="Space"or iphCondition=="Custom Only"and m2.center or iphCondition=="No Moons"and string.find(m2.name,"Moon")~=nil then if gN==nil then m3()else m3(1)end else m0()end end else a4="Disengage autopilot before changing Interplanetary Helper"bA("iph","AP")end end;local function kF()local fe=-1;fe=lZ(e[0])if fe>-1 then table.remove(e[0],fe)end;fe=-1;fe=lZ(SavedLocations)if fe~=-1 then a4=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fe)end;m3()lV()end;local function kA(ft,position,hu,m4)if dbHud_1 or hu then local cE=lU(position)local l5=cE.gravity;if m4 then l5=c.getClosestPlanetInfluence()end;local m5={position=position,name=ft,planetname=cE.name,gravity=l5,safe=m4}if not hu then SavedLocations[#SavedLocations+1]=m5 else for c7,c8 in pairs(e[0])do if c8.name and ft==c8.name then table.remove(e[0],c7)end end end;table.insert(e[0],m5)lV()m0()a4="Location saved as "..ft.."("..cE.name..")"else a4="Databank must be installed to save permanent locations"end end;local m6={}function m6.UpdateAtlasLocationsList()lV()end;function m6.UpdateAutopilotTarget()m0()end;function m6.adjustAutopilotTargetIndex(gN)m3(gN)end;function m6.findAtlasIndex(l_)lZ(l_)end;function m6.UpdatePosition(m7)local fe=lZ(SavedLocations)if fe~=-1 then if m7~=nil then SavedLocations[fe].name=m7;AutopilotTargetIndex=AutopilotTargetIndex-1;m3()else local m8=SavedLocations[fe]m8.gravity=c.getClosestPlanetInfluence()m8.position=bd;m8.safe=true end;a4=SavedLocations[fe].name.." position updated ("..SavedLocations[fe].planetname..")"else a4="Name Not Found"end end;function m6.AddNewLocation(ft,position,hu,m4)kA(ft,position,hu,m4)end;function m6.ClearCurrentPosition()kF()end;for c7,c8 in pairs(SavedLocations)do table.insert(e[0],c8)end;lV()if AutopilotTargetIndex>#bk then AutopilotTargetIndex=0 end;m6.UpdateAutopilotTarget()return m6 end;local function m9()local ma={}local function mb(dZ)local mc=AutopilotEndSpeed;if not Autopilot then mc=0 end;if not ao then return aJ.computeDistanceAndTime(dZ,mc,at,0,0,LastMaxBrake-AutopilotPlanetGravity*at)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aJ.computeDistanceAndTime(dZ,mc,at,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*at)else return 0,0 end end end;local function md(dZ)local mc=AutopilotEndSpeed;if not Autopilot then mc=0 end;return aJ.computeDistanceAndTime(dZ,mc,at,d:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*at)end;local me=false;local mf=0;local mg=0;local mh=0;local mi=s()local mj=0;local mk=0;local ml=0;local mm=0;local mn=false;local mo=false;local mp=false;local mq=nil;local mr=0;local ms={}function ma.GetAutopilotBrakeDistanceAndTime(dZ)return mb(dZ)end;function ma.GetAutopilotTBBrakeDistanceAndTime(dZ)return md(dZ)end;local function mt(mu,mv,mw)mv=mv:project_on_plane(mu)mw=mw:project_on_plane(mu)return q(mv:cross(mw):dot(mu),mv:dot(mw))end;local function mx()local function my()local mz=-1;local mA=-1;if vBooster then mz=vBooster.getDistance()end;if hover then mA=hover.getDistance()end;if mz~=-1 and mA~=-1 then if mz<mA then return mz else return mA end elseif mz~=-1 then return mz elseif mA~=-1 then return mA else return-1 end end;local mB=my()local mC=-1;if telemeter_1 then mC=telemeter_1.getDistance()end;if mB~=-1 and mC~=-1 then if mB<mC then return mB else return mC end elseif mB~=-1 then return mB else return mC end end;local function mD(planet,dk,mE)local function mF(mG,cC)local dr=vec3(cC)if mG.id==0 then return setmetatable({latitude=dr.x,longitude=dr.y,altitude=dr.z,id=0,systemId=mG.systemId},MapPosition)end;local ds=dr-mG.center;local ah=ds:len()local cJ=ah-mG.radius;local cH=0;local cI=0;if not bT(ah,0)then local dt=q(ds.y,ds.x)cI=dt>=0 and dt or 2*math.pi+dt;cH=math.pi/2-math.acos(ds.z/ah)end;return setmetatable({latitude=math.deg(cH),longitude=math.deg(cI),altitude=cJ,id=mG.id,systemId=mG.systemId},MapPosition)end;local mH=mF(planet,dk)mH="::pos{"..mH.systemId..","..mH.id..","..mH.latitude..","..mH.longitude..","..mH.altitude.."}"if mE then return mH else a.setWaypoint(mH)return true end end;local mI=false;function ma.changeSpd(mJ)local F=1;if mJ then F=-1 end;if not a3 then if AtmoSpeedAssist and not AltIsOn and au then local mK=M;M=C(t(M+F*speedChangeLarge/100,-1,1),2)if M>=0 and mK<0 then M=0;au=false end elseif AltIsOn then if ap>0 or Reentry then aX=t(aX+F*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=t(MaxGameVelocity+F*speedChangeLarge/3.6*100,0,8333.00)end else u:updateCommandFromActionStart(axisCommandId.longitudinal,F*speedChangeLarge)end else if Autopilot or VectorToTarget or ak or IntoOrbit then bt=bt+1*F*-1;if bt>#bk then bt=1 end;if bt<1 then bt=#bk end else if not mJ then F=1 else F=nil end;aN.adjustAutopilotTargetIndex(F)end end end;function ma.showWayPoint(planet,dk,mE)return mD(planet,dk,mE)end;function ma.APTick()local function mL()if br and not BrakeLanding then local d3=br[1]local fu,fv=br[2],br[3]local mM=math.min(fu,fv or fu)local mN=mM/ba;local mO=AutoTakeoff and(ba<42 or am~=-1)local mP=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mP and not mO and(a6*1.5>mM or mN<1)then BrakeIsOn=true;aO.cmdThrottle(0)if AltitudeHold then aO.ToggleAltitudeHold()end;if LockPitch then ToggleLockPitch()end;a4="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then ms={}aO.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aT=true end;if mN<11 then bq=d3.name.." COLLISION "..bZ(mN).." / "..bW(mM,2)else bq=d3.name.." collision "..bZ(mN)end;if mN<6 then bA("alarm","AL",2)end else bq=false end end;local function mQ(mR,mS,mT)local function mU(mR,d5)mR=vec3(mR)d5=vec3(d5):normalize()local cn=mR*d5;return cn.x+cn.y+cn.z end;local mV=0.001;local mW=1;if not ao or not aV or am~=-1 or ba<S then if mT==nil then mT=DampingMultiplier end;if mS==nil then mS=mV end;mR=vec3(mR):normalize()local mX=vec3()-mR;local mY=-mU(mX,b.getConstructWorldOrientationRight())*mW;local mZ=-mU(mX,b.getConstructWorldOrientationUp())*mW;if mg==0 then mg=mY/2 end;if mh==0 then mh=mZ/2 end;if g(mY)<0.1 then X=X-mY*2 else X=X-(mY+(mY-mg)*mT)end;if g(mZ)<0.1 then W=W+mZ*2 else W=W+mZ+(mZ-mh)*mT end;mg=mY;mh=mZ;if g(mY)<mS and g(mZ)<mS then return true end;return false elseif aV and am==-1 then mR=b9;if mT==nil then mT=DampingMultiplier end;if mS==nil then mS=mV end;mR=vec3(mR):normalize()local mX=b6-mR;local mY=-mU(mX,b.getConstructWorldOrientationRight())*mW;local mZ=-mU(mX,b.getConstructWorldOrientationUp())*mW;if mg==0 then mg=mY/2 end;if mh==0 then mh=mZ/2 end;if g(mY)<0.1 then X=X-mY*5 else X=X-(mY+(mY-mg)*mT)end;if g(mZ)<0.1 then W=W+mZ*5 else W=W+mZ+(mZ-mh)*mT end;mg=mY;mh=mZ;if g(mY)<mS and g(mZ)<mS then return true end;return false end end;ao=n()>0;ap=n()aq=b.getAltitude()am=mx()G=s()mi=G;if CollisionSystem then mL()end;if antigrav then bf=antigrav.getState()==1 end;local m_=1;local n0=1;local n1=G-mi;local n2=-math.deg(mt(b5,b9,b6))local n3=math.deg(mt(b7,b9,b6))local gN=bb*-1;aV=ao and n2<-YawStallAngle or n2>YawStallAngle or n3<-PitchStallAngle or n3>PitchStallAngle;local n4=a.getMouseDeltaX()local n5=a.getMouseDeltaY()if InvertMouse and not a3 then n5=-n5 end;X=0;a1=0;W=0;sys=aI[0]planet=sys:closestBody(b.getConstructWorldPos())kepPlanet=aL(planet)orbit=kepPlanet:orbitalParameters(b.getConstructWorldPos(),b9)if aq==0 then aq=(bd-planet.center):len()-planet.radius end;bp=c.getClosestPlanetInfluence()>0 or aq>0 and aq<200000;local l5=planet:getGravity(b.getConstructWorldPos()):len()*at;aW=0;aK=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if z()==0 then if p()==1 and a3 then if not aR then ae=t(ae+n4,-aA/2,aA/2)af=t(af+n5,-aB/2,aB/2)end else ae=0;af=0 end else ae=t(ae+n4,-aA/2,aA/2)af=t(af+n5,-aB/2,aB/2)ah=A(ae*ae+af*af)if not a3 and p()==0 then local hH,hI=1,1;if SelectedTab=="SCOPE"then hH,hI=by/90,by/90 end;if userControlScheme=="virtual joystick"then if ae>0 and ae>DeadZone then X=X-(ae-DeadZone)*MouseXSensitivity*hH elseif ae<0 and ae<DeadZone*-1 then X=X-(ae+DeadZone)*MouseXSensitivity*hH else X=0 end;if af>0 and af>DeadZone then W=W-(af-DeadZone)*MouseYSensitivity*hI elseif af<0 and af<DeadZone*-1 then W=W-(af+DeadZone)*MouseYSensitivity*hI else W=0 end else ae=0;af=0;if userControlScheme=="mouse"then W=(-utils.smoothstep(n5,-100,100)+0.5)*2*m_;X=(-utils.smoothstep(n4,-100,100)+0.5)*2*n0 end end end end;local n6=ba>8334;if ba>SpaceSpeedLimit/3.6 and not ao and not Autopilot and not n6 then a4="Space Speed Engine Shutoff reached"aO.cmdThrottle(0)end;if not n6 and LastIsWarping then if not BrakeIsOn then aO.BrakeToggle()end;if Autopilot then aO.ToggleAutopilot()end end;LastIsWarping=n6;if ao and ap>0.09 then if ba>aX/3.6 and not AtmoSpeedAssist and not me then BrakeIsOn=true;me=true elseif not AtmoSpeedAssist and me then if ba<aX/3.6 then BrakeIsOn=false;me=false end end end;if BrakeIsOn then a0=1 else a0=0 end;if ProgradeIsOn then if aj then BrakeIsOn=false;local n7=false;if CustomTarget and aj~=1 then n7=mQ(CustomTarget.position-bd,0.1)else n7=mQ(vec3(b9),0.01)end;aT=true;if n7 then aO.cmdCruise(h(aX))if(g(bj)<2 or g(bi)>85)and ba>=aX/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;T=true;if aj~=1 then al=true end;aj=false;Autopilot=false;aO.BeginReentry()end elseif ao and AtmoSpeedAssist then aO.cmdThrottle(1)end elseif ba>S then mQ(vec3(b9),0.01)end end;if RetrogradeIsOn then if ao then RetrogradeIsOn=false elseif ba>S then mQ(-vec3(b9))end end;if not ProgradeIsOn and aj and not IntoOrbit then if ap==0 then T=true;aO.BeginReentry()aj=false;al=true else aj=false;aO.ToggleAutopilot()end end;if al and CustomTarget and(aq<HoldAltitude+250 and aq>HoldAltitude-250)and ba*3.6>aX-250 and g(bc)<25 and ap>=0.1 and(CustomTarget.position-bd):len()>2000+aq then aO.ToggleAutopilot()al=false end;if VertTakeOff then aT=true;local n8=HoldAltitude;if bc<-30 then a4="Unable to achieve lift. Safety Landing."ad=0;aT=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bf or HoldAltitude<planet.spaceEngineMinAltitude then if bf then n8=antigrav.getBaseAltitude()end;if aq<n8-100 then aY=0;ad=15;BrakeIsOn=false elseif bc>0 then BrakeIsOn=true;ad=0 elseif bc<-30 then BrakeIsOn=true;ad=15 elseif aq>=n8 then if bf then if Autopilot or VectorToTarget then aO.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a4="Takeoff complete. Singularity engaged"bA("aggLk","AG")else BrakeIsOn=false;a4="VTO complete. Engaging Horizontal Flight"bA("vtoc","VT")aO.ToggleVerticalTakeoff()end;ad=0 end else if ap>0.08 then aY=0;BrakeIsOn=false;ad=20 elseif ap<0.08 and ap>0 then BrakeIsOn=false;if b3 then aY=0;ad=20 else ad=0;aY=36;aO.cmdCruise(3500)end else aT=autoRollPreference;IntoOrbit=true;b1=false;CancelIntoOrbit=false;mn=false;ml=nil;mm=nil;if mq==nil then mq=planet end;b0=n8;mp=true;VertTakeOff=false end end;if aY~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local n9=t(aY-bi,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(n9)local na=t(vTpitchPID:get(),-1,1)W=na end end;if IntoOrbit then local mX;local nb=false;local nc=bW(b0)if mq==nil then mq=planet;if VectorToTarget then mq=aa end end;if not mp then b0=h(mq.radius+mq.surfaceMaxAltitude+LowOrbitHeight)if mq.hasAtmosphere then b0=h(mq.radius+mq.noAtmosphericDensityAltitude+LowOrbitHeight)end;mp=true end;if a_.VectorToTarget and CustomTarget then mX=CustomTarget.position-bd end;local nd,ne=aL(mq):escapeAndOrbitalSpeed((bd-mq.center):len()-mq.radius)local nf=bj;if not mn then local ng=false;local nh=false;aO.cmdThrottle(0)mm=0;aZ="Aligning to orbital path - OrbitHeight: "..nc;if a_.VectorToTarget then mQ(mX:normalize():project_on_plane(bb))nb=b6:dot(mX:project_on_plane(b5):normalize())>0.95 else mQ(b9)nb=n2<0.5;if ba<150 then nb=true end end;W=0;ml=0;if bi<=ml+1 and bi>=ml-1 then ng=true else ng=false end;if nf<=mm+1 and nf>=mm-1 then nh=true else nh=false end;if ng and nh and nb then ml=nil;mm=nil;mn=true end else if a_.VectorToTarget then mQ(mX:normalize():project_on_plane(bb))elseif ba>150 then mQ(b9)end;W=0;if a_.VectorToTarget and CustomTarget then local a6,_=aJ.computeDistanceAndTime(ba,aX/3.6,at,0,0,LastMaxBrake)if b1 and mX:len()>15000+a6+aq then aZ="Orbiting to Target"if aq-100<=mq.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<mq.noAtmosphericDensityAltitude then b1=false end elseif b1 or mX:len()<15000+a6+aq then a4="Orbit complete, proceeding with reentry"bA("orCom","OB")AutopilotTargetCoords=CustomTarget.position;T=true;al=true;a_.VectorToTarget,a_.AutopilotAlign=false,false;aO.ToggleIntoOrbit()aO.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and aq>b0*0.9 and aq<b0*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=b0*0.99 and orbit.apoapsis.altitude>=b0*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or b1 then if b1 then BrakeIsOn=false;aO.cmdThrottle(0)ml=0;if not a_.VectorToTarget then a4="Orbit complete"bA("orCom","OB")aO.ToggleIntoOrbit()end else mr=mr+1;if mr>=2 then b1=true end end else aZ="Adjusting Orbit - OrbitHeight: "..nc;mo=true;aO.cmdCruise(ne*3.6+1)local ni=b0-aq;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(ni-bc*t(utils.smoothstep(2000-ni,-2000,2000)^6*10,1,10))ml=t(VSpdPID:get(),-60,60)end end else local nj=2.75;local nk=g(C(nd*nj))local nl=nk%50;if nl>0 then nk=nk-nl+50 end;BrakeIsOn=false;if aq<b0*0.8 then aZ="Escaping planet gravity - OrbitHeight: "..nc;ml=utils.map(bc,200,0,-15,80)elseif aq>=b0*0.8 and aq<b0*1.15 then aZ="Approaching orbital corridor - OrbitHeight: "..nc;nk=nk*0.75;ml=utils.map(bc,100,-100,-15,65)elseif aq>=b0*1.15 and aq<b0*1.5 then aZ="Approaching orbital corridor - OrbitHeight: "..nc;nk=nk*0.75;if bc<0 or mo then ml=utils.map(aq,b0*1.5,b0*1.01,-30,0)else ml=utils.map(aq,b0*0.99,b0*1.5,0,30)end elseif aq>b0*1.5 then aZ="Reentering orbital corridor - OrbitHeight: "..nc;ml=-65;local nm=utils.map(bc,-150,-400,1,0.55)nk=nk*nm end;aO.cmdCruise(h(nk))end end;if ml~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local nn=ml-bi;OrbitPitchPID:inject(nn)local no=t(OrbitPitchPID:get(),-0.5,0.5)W=no end end;if Autopilot and ap==0 and not aj then local function np(fJ,orbit)a.print(fJ)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aO.cmdThrottle(0)R=false;a4=fJ;bA("apCom","AP")if orbit or aj then if orbit and AutopilotTargetOrbit~=nil and not aj then if not aq or aq==0 then return end;b0=aq;mp=true end;aO.ToggleIntoOrbit()end end;local nq,nr=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local ns=(CustomTarget.position-aa.center):normalize()local nt=ns:project_on_plane((aa.center-bd):normalize()):normalize()local nu=aa.center+nt*(aa.radius+AutopilotTargetOrbit)local nw=CustomTarget.position+(CustomTarget.position-aa.center):normalize()*(AutopilotTargetOrbit-aa:getAltitude(CustomTarget.position))if(bd-nu):len()<(bd-nw):len()then nq=nu else nq=nw;AutopilotEndSpeed=0 end;AutopilotTargetCoords=nq;aO.showWayPoint(aa,AutopilotTargetCoords)nr=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;nr=true;AutopilotRealigned=true;TargetSet=true;nq=CustomTarget.position+(bd-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=nq end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local ns=(bd+b9*100000-aa.center):normalize()local nt=ns:project_on_plane((aa.center-bd):normalize()):normalize()if nt:len()<1 then ns=(bd+b6*100000-aa.center):normalize()nt=ns:project_on_plane((aa.center-bd):normalize()):normalize()end;nq=aa.center+nt*(aa.radius+AutopilotTargetOrbit)AutopilotTargetCoords=nq;TargetSet=true;nr=true;AutopilotRealigned=true;aO.showWayPoint(aa,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(nq)-bd):len()local iv,di,dj=aI:getPlanetarySystem(0):castIntersections(bd,b9:normalize(),function(d3)if d3.noAtmosphericDensityAltitude>0 then return d3.radius+d3.noAtmosphericDensityAltitude else return d3.radius+d3.surfaceMaxAltitude*1.5 end end)local iw=di;if dj~=nil and di~=nil then iw=math.min(dj,di)end;if iw~=nil and iw<AutopilotDistance and iv.name==aa.name then AutopilotDistance=iw end;local n7=true;local nx=(aa.center-(bd+vec3(b9):normalize()*AutopilotDistance)):len()-aa.radius;local ik=bW(nx)w(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ik..'"}')local a6,a7;if not TurnBurn then a6,a7=mb(ba)else a6,a7=md(ba)end;if ba>50 and AutopilotAccelerating then local mX=vec3(nq)-bd;local ny=t(math.deg(mt(b5,b9:normalize(),mX:normalize()))*ba/500,-90,90)local nz=t(math.deg(mt(b7,b9:normalize(),mX:normalize()))*ba/500,-90,90)if g(ny)<20 and g(nz)<20 then ny=ny*2;nz=nz*2 end;if g(ny)<2 and g(nz)<2 then ny=ny*2;nz=nz*2 end;local n2=-math.deg(mt(b5,b6,b9:normalize()))local n3=-math.deg(mt(b7,b6,b9:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(nz-n3)local nA=t(apPitchPID:get(),-1,1)W=W+nA;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(ny-n2)local nB=t(apYawPID:get(),-1,1)X=X+nB;nr=true;if g(ny)>2 or g(nz)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bA("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bA("apAcc","AP")end end elseif AutopilotAccelerating and ba<=50 then mQ((nq-bd):normalize())end;if nx<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aL(aa):escapeAndOrbitalSpeed(nx)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local iv,iw=aO.checkLOS((AutopilotTargetCoords-bd):normalize())if aa.name~=planet.name then if iv~=nil and aa.name~=iv.name and iw<AutopilotDistance then a4="Collision with "..iv.name.." in "..bW(iw).."\nClear LOS to continue."ag=5;mI=true else mI=false;a4=""end end end;if not mI then if not AutopilotCruising and not AutopilotBraking and not nr then n7=mQ((nq-bd):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then n7=mQ(-vec3(b9):normalize())end end;if AutopilotAccelerating then if not R then BrakeIsOn=false;aO.cmdThrottle(AutopilotInterplanetaryThrottle)M=C(AutopilotInterplanetaryThrottle,2)R=true end;local nC=c.getThrottle()if AtmoSpeedAssist then nC=M end;local nD=99999;local lh=-vec3(b.getWorldAcceleration()):dot(b9:normalize())local nE=t(b9:dot((nq-bd):normalize()),0,ba)if nE>0 or lh>0 then nD=aJ.computeTravelTime(nE,lh,AutopilotDistance-a6)end;if b8:len()>=MaxGameVelocity or nC==0 and R or warmup/4>nD then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bA("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aO.cmdThrottle(0)end;local nF=AutopilotDistance;if nF<=a6 or PreventPvP and bm<=a6+10000 and bl then if PreventPvP and bm<=a6+10000 and bl then if bm<mf and bm>2000 then aO.ToggleAutopilot()a4="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mf=bm else mf=bm;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bA("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aO.cmdThrottle(0)R=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;a0=1 end;if TurnBurn then aO.cmdThrottle(1,true)end;local _,ne=aL(aa):escapeAndOrbitalSpeed((bd-planet.center):len()-planet.radius)local mX;if CustomTarget then mX=CustomTarget.position-bd end;if CustomTarget and CustomTarget.planetname=="Space"and ba<50 then if#ms>0 then BrakeIsOn=false;aO.ToggleAutopilot()aO.ToggleAutopilot()return end;np("Autopilot complete, arrived at space location")BrakeIsOn=true;a0=1 elseif CustomTarget and CustomTarget.planetname~="Space"and ba<=ne and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then np("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;aj=true;aO.showWayPoint(aa,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bA("apCir","AP")AutopilotStatus="Circularizing"end;if ba<=ne then if CustomTarget then if b9:normalize():dot(mX:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bA("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aO.showWayPoint(aa,CustomTarget.position)WaypointSet=true end else np("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;aj=true;aO.showWayPoint(aa,CustomTarget.position)WaypointSet=false end else np("Autopilot completed, setting orbit",true)a0=0 end end elseif AutopilotStatus=="Circularizing"then np("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nF=AutopilotDistance;if nF<=a6 or PreventPvP and bm<=a6+10000 and bl then if PreventPvP and bm<=a6+10000 and bl then if bm<mf and bm>2000 then aO.ToggleAutopilot()a4="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mf=bm else mf=bm;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bA("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local nC=c.getThrottle()if AtmoSpeedAssist then nC=M end;if nC>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bA("apAcc","AP")end;AutopilotCruising=false end else if n7 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not aj then AutopilotTargetCoords=vec3(aa.center)+(AutopilotTargetOrbit+aa.radius)*b7;AutopilotShipUp=b5;AutopilotShipRight=b7 end;AutopilotRealigned=true elseif n7 and not mI then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bA("apAcc","AP")end;if not R then aO.cmdThrottle(AutopilotInterplanetaryThrottle,true)M=C(AutopilotInterplanetaryThrottle,2)R=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ap>0)then a4="Autopilot complete, starting reentry"bA("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"a0=0;aO.cmdThrottle(0)R=false;ProgradeIsOn=true;aj=true;aO.showWayPoint(aa,CustomTarget.position)end;if a2 then aT=true;local nz=0;local e2=bd+vec3(c.getMasterPlayerRelativePosition())local nG=e2-bd;local nH=vec3(nG):project_on(b6):len()local nI=vec3(nG):project_on(b7):len()local ah=A(nH*nH+nI*nI)mQ(nG:normalize())local jy=40;local nJ=ah<jy;local nK=100;local nL=t((ah-jy)/2,10,nK)W=0;local n7=g(X)<0.1;if n7 and ba<nL and not nJ then BrakeIsOn=false;nz=-20 else BrakeIsOn=true;nz=0 end;local nM=0;if g(nz-bi)>nM then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(nz-bi)local nA=pitchPID:get()W=nA end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local nN=LastMaxBrakeInAtmo;if nN then nN=nN*t(ba/100,0.1,1)*ap else nN=LastMaxBrake end;if ap<0.01 then nN=LastMaxBrake end;local nO=b6:project_on_plane(bb):normalize():dot(b9)local nP=vec3(b.getWorldAirFrictionAcceleration())local nQ=nP:len()*at;if nO>100 then a6,a7=aJ.computeDistanceAndTime(nO,100,at,0,0,nN)local nR,nS=aJ.computeDistanceAndTime(100,0,at,0,0,nN*0.55)a6=a6+nR else a6,a7=aJ.computeDistanceAndTime(nO,0,at,0,0,nN*0.55)end;local ni=HoldAltitude-aq-bc;local nT=200+ba;if Reentry or aj then minMax=2000+ba end;local nU=1;if AutoTakeoff then nU=t(ba/100,0.1,1)end;local nz=(utils.smoothstep(ni,-nT,nT)-0.5)*2*MaxPitch*nU;if not Reentry and not aj and not VectorToTarget and b6:dot(b9:normalize())<0.99 then nz=(utils.smoothstep(ni,-nT*t(20-19*ap*10,1,20),nT*t(20-19*ap*10,1,20))-0.5)*2*MaxPitch*t(2-ap*10,1,2)*nU end;if not AltitudeHold then nz=0 end;if LockPitch~=nil then if bp and not IntoOrbit then nz=LockPitch else LockPitch=nil end end;aT=true;local nV=W;if Reentry then local nW=h(aX)local nX,nY=aJ.computeDistanceAndTime(ba,nW/3.6,at,0,0,LastMaxBrake-planet.gravity*9.8*at)nX=nX==-1 and 5000 or nX;local nZ=aq-(planet.noAtmosphericDensityAltitude+nX)local n_=aq>planet.noAtmosphericDensityAltitude+nX*1.35;if n_ then nz=ReEntryPitch;if ba<=nW/3.6 and ba>nW/3.6-10 and g(b9:normalize():dot(b6))>0.9 and not bh then Q=false;aO.cmdThrottle(1)end elseif bh and not n_ and not ao then aO.cmdCruise(nW,true)end;if bh then if ba>nW/3.6 and not n_ then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bc>0 then BrakeIsOn=true end;if not T then nz=-80;if ap>0.02 then a4="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;nz=0;aT=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and n_ then aT=true elseif not n_ then if not ao and(bh or u:getTargetSpeed(axisCommandId.longitudinal)~=nW)then aO.cmdCruise(nW)end;if ba<nW/3.6+1 then BrakeIsOn=false;T=false;Reentry=false;aT=true end end end;if ba>S and not ak and not VectorToTarget and not BrakeLanding and ForceAlignment then mQ(vec3(b9))end;if bn or(VectorToTarget or ak)and AutopilotTargetIndex>0 and ap>0.01 then local mX;if bn then if type(bn)=="table"then mX=bn elseif bn<3 and bn>0 then mX=-bb:cross(b9)*5000 elseif bn>=3 then mX=bb:cross(b9)*5000 elseif bn<0 then mX=b9*25000 end elseif CustomTarget~=nil then mX=CustomTarget.position-bd else mX=aa.center-bd end;local ny=math.deg(mt(bb:normalize(),b9,mX))*2;local jB=math.rad(g(bj))if ba>minRollVelocity and ap>0.01 then local o0=1000+ba;local o1=(utils.smoothstep(ni-bc*10,-o0,o0)-0.5)*2*MaxPitch;local o2=t(90-o1,0,180)aW=t(ny*2,-o2,o2)local o3=ny;ny=t(t(ny,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jB)+4*(bi-nz)*math.sin(math.rad(bj)),-YawStallAngle*0.80,YawStallAngle*0.80)local o4=1;if aW~=0 then o4=g(jB/aW)end;o4=(90-t(g(aW-bj),0,90))/90;local o5=nz;if g(bj)>90 then o5=-o5 end;nz=o4*t(t(o5*math.cos(jB),-PitchStallAngle*0.8,PitchStallAngle*0.8)+g(t(g(o3)*math.sin(jB),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aW=0;ny=t(ny,-YawStallAngle*0.80,YawStallAngle*0.80)end;local o6=n2-ny;if bn and g(o6)<=0.0001 and(type(bn)=="table"or type(bn)~="table"and bn<0 and g(bj)<1)then if bn==-2 then aO.ToggleAltitudeHold()end;bn=nil;bA("180Off","BR")return end;if not aV and ba>minRollVelocity and ap>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(o6)local nB=t(yawPID:get(),-1,1)X=X+nB elseif ao and am>-1 or ba<minRollVelocity then mQ(mX)elseif aV and ap>0.01 then if(n2<-YawStallAngle or n2>YawStallAngle)and ap>0.01 then mQ(b9)end;if(n3<-PitchStallAngle or n3>PitchStallAngle)and ap>0.01 then nz=t(bi-n3,bi-PitchStallAngle*0.80,bi+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ak then local n8=planet:getAltitude(CustomTarget.position)local nZ=mX:project_on_plane(bb):len()StrongBrakes=true;if not ak and not Reentry and nZ<=a6 and(b9:project_on_plane(bb):normalize():dot(mX:project_on_plane(bb):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"if#ms>0 then aO.ToggleAutopilot()aO.ToggleAutopilot()return end;aO.cmdThrottle(0)if AltitudeHold then aO.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(nO<0.1 or nZ<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<nZ)then if not bf then bA("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bq=false end;LastDistanceToTarget=nZ end elseif VectorToTarget and ap==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ak or Reentry)then if CustomTarget~=nil and aa.name==planet.name then local mX=CustomTarget.position-bd;local n8=planet:getAltitude(CustomTarget.position)local nZ=A(mX:len()^2-(aq-n8)^2)local nN=LastMaxBrakeInAtmo;if nN then a6,a7=aJ.computeDistanceAndTime(ba,0,at,0,0,nN/2)StrongBrakes=true;if nZ<=a6+ba*n1/2 and b9:project_on_plane(bb):normalize():dot(mX:project_on_plane(bb):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;T=true;aj=false;al=true;Autopilot=false;aO.BeginReentry()end end;LastDistanceToTarget=nZ end end end;if ap==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ak or IntoOrbit or Reentry)then if not b1 and not IntoOrbit then b0=HoldAltitude;mp=true;if VectorToTarget then a_.VectorToTarget=true end;aO.ToggleIntoOrbit()VectorToTarget=false;mn=true end end;if aV and ap>0.01 and am==-1 and ba>minRollVelocity and VectorStatus~="Finalizing Approach"then mQ(b9)nz=t(bi-n3,bi-PitchStallAngle*0.80,bi+PitchStallAngle*0.80)end;W=nV;local mC=-1;if BrakeLanding then nz=0;local o7=false;local o8=30;if aK~=nil and aK>0 then local o9=t(ap,0.4,2)local nN=LastMaxBrakeInAtmo*t(ba/100,0.1,1)*o9;local oa=aK*o9+nN-l5;local ob=nN/2-l5;local oc=ba-A(g(ob/2)*20/(0.5*at))*utils.sign(ob)if oc<0 then oc=0 end;local od;if ba>100 then local oe,_=aJ.computeDistanceAndTime(ba,100,at,0,0,nN)local of,_=aJ.computeDistanceAndTime(100,0,at,0,0,A(nN))od=oe+of else od=aJ.computeDistanceAndTime(ba,0,at,0,0,A(nN))end;if od<20 then BrakeIsOn=false else local og=0;if oc>100 then local oh,_=aJ.computeDistanceAndTime(oc,100,at,0,0,oa)local oi,_=aJ.computeDistanceAndTime(100,0,at,0,0,aK*o9+A(nN)-l5)og=oh+oi else og,_=aJ.computeDistanceAndTime(oc,0,at,0,0,aK*o9+A(nN)-l5)end;og=(og+15+ba*n1)*1.1;local oj=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if oj then local n8=planet:getAltitude(CustomTarget.position)local ok=aq-n8-100;local mX=CustomTarget.position-bd;local ol=A(mX:len()^2-(aq-n8)^2)if ol>100 then oj=false elseif ok<=og or og==-1 then BrakeIsOn=true;o7=true else BrakeIsOn=false;o7=true end end;if not oj and CalculateBrakeLandingSpeed then if og>=o8 then BrakeIsOn=true else BrakeIsOn=false end;o7=true end end end;if not bh then aO.cmdThrottle(0)end;u:setTargetGroundAltitude(500)u:activateGroundEngineAltitudeStabilization(500)stablized=true;mC=am;if mC>-1 then aT=autoRollPreference;if ba<1 or b9:normalize():dot(bb)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if U then d.control.extendLandingGears()bA("grOut","LG",1)end;u:setTargetGroundAltitude(LandingGearGroundHeight)ad=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and b9:normalize():dot(-gN)<0.999 then BrakeIsOn=true elseif bc<-brakeLandingRate and not o7 then BrakeIsOn=true elseif not o7 then BrakeIsOn=false end end;if AutoTakeoff or ak then local iv,dj,di;if AutopilotTargetCoords~=nil then iv,dj,di=aI:getPlanetarySystem(0):castIntersections(bd,(AutopilotTargetCoords-bd):normalize(),function(d3)return d3.radius+d3.noAtmosphericDensityAltitude end)end;if bf then if aq>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aO.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif g(nz)<15 and aq/HoldAltitude>0.75 then AutoTakeoff=false;if not ak then if bh and not AtmoSpeedAssist then d.control.cancelCurrentControlMasterMode()end elseif ak and ba<S then Autopilot=true;ak=false;AltitudeHold=false;AutoTakeoff=false;aO.cmdThrottle(0)elseif ak then aO.cmdThrottle(0)BrakeIsOn=true end elseif ak and ap==0 and aa~=nil and(iv==nil or iv.name==aa.name)then Autopilot=true;ak=false;AltitudeHold=false;AutoTakeoff=false;if not bh then aO.cmdThrottle(0)end;AutopilotAccelerating=true end end;local om=am>-1;local on=bi;if(VectorToTarget or ak or bn)and not om and ba>minRollVelocity and ap>0.01 then local jB=math.rad(g(bj))on=bi*g(math.cos(jB))+n3*math.sin(jB)end;local oo=t(nz-on,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ap<0.01 and VectorToTarget then oo=t(nz-on,-85,MaxPitch)elseif ap<0.01 then oo=t(nz-on,-MaxPitch,MaxPitch)end;if g(bj)<5 or VectorToTarget or bn or BrakeLanding or om or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(oo)local nA=pitchPID:get()W=W+nA end end;if antigrav~=nil and(antigrav and not ExternalAGG and aq<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function ma.ToggleIntoOrbit()b1=false;ml=nil;mm=nil;mr=0;if ap==0 then if IntoOrbit then bA("orOff","AP")IntoOrbit=false;mn=false;mq=nil;aT=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;a_.VectorToTarget=false;a_.AutopilotAlign=false;mp=false elseif bp then bA("orOn","AP")IntoOrbit=true;aT=true;if mq==nil then mq=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a4="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;mn=false;mq=nil;aT=autoRollPreference;if AltitudeHold then AltitudeHold=false end;a_.VectorToTarget=false;a_.AutopilotAlign=false;mp=false end end;function ma.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aT=true;ad=0;if ao and am==-1 then BrakeLanding=false;AltitudeHold=true;ad=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aO.cmdCruise(h(aX))end else b1=false;GearExtended=false;d.control.retractLandingGears()u:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function ma.checkLOS(mR)local iv,di,dj=aI:getPlanetarySystem(0):castIntersections(bd,mR,function(d3)if d3.noAtmosphericDensityAltitude>0 then return d3.radius+d3.noAtmosphericDensityAltitude else return d3.radius+d3.surfaceMaxAltitude*1.5 end end)local iw=di;if dj~=nil and di~=nil then iw=math.min(dj,di)end;if iw~=nil then return iv,iw else return nil,nil end end;function ma.ToggleAutopilot()local function op(SpaceTarget)bq=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aO.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;local oq=false;if G-mk<1.5 and ap>0 then if not b4 then a4="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ap>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bA("orH","OH")end;mk=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else mk=G end;TargetSet=false;if(AutopilotTargetIndex>0 or#ms>0)and not Autopilot and not VectorToTarget and not ak and not IntoOrbit then if 0.5*d:maxForceForward()/b.g()<at then a4="WARNING: Heavy Loads may affect autopilot performance."ag=5 end;if#ms>0 and not al then AutopilotTargetIndex=ms[1]aN.UpdateAutopilotTarget()table.remove(ms,1)a4="Route Autopilot in Progress"local mX=CustomTarget.position-bd;local nZ=mX:project_on_plane(bb):len()if nZ>50000 and CustomTarget.planetname==planet.name then oq=true end end;aN.UpdateAutopilotTarget()aO.showWayPoint(aa,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bA("apSpc","AP")if ap~=0 then ak=true;aO.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ap>0 then if not VectorToTarget then bA("vtt","AP")op(SpaceTarget)if oq then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight end end else bA("apOn","AP")if not(aa.name==planet.name and aq<AutopilotTargetOrbit*1.5)then b1=false;Autopilot=true elseif not ao then if IntoOrbit then aO.ToggleIntoOrbit()end;b0=planet.noAtmosphericDensityAltitude+LowOrbitHeight;mp=true;a_.AutopilotAlign=true;a_.VectorToTarget=true;mn=false;if not IntoOrbit then aO.ToggleIntoOrbit()end end end else bA("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ap~=0 then ak=true;aO.ToggleAltitudeHold()else Autopilot=true end end elseif ap==0 then if CustomTarget==nil and(aa.name==planet.name and bp)and not IntoOrbit then WaypointSet=false;b1=false;mn=false;aO.ToggleIntoOrbit()else bA("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a2=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;R=false;LockPitch=nil;WaypointSet=false end else bA("apP","AP")ak=true;aO.ToggleAltitudeHold()end else bA("apOff","AP")aO.ResetAutopilots(1)end end;function ma.routeWP(os,ot,ou)if ou then if ou==1 then ms={}ms=bD(ms,saveRoute)if#ms>0 then a4="Route Loaded"else a4="No Saved Route found on Databank"end;return ms else saveRoute={}saveRoute=bD(saveRoute,ms)a4="Route Saved"c3()return end end;if os then return ms end;if ot then ms={}a4="Current Route Cleared"else ms[#ms+1]=AutopilotTargetIndex;a4="Added "..CustomTarget.name.." to route. "end;return ms end;function ma.cmdThrottle(cs,ov)if u:getAxisCommandType(0)~=axisCommandType.byThrottle and not ov then d.control.cancelCurrentControlMasterMode()end;u:setThrottleCommand(axisCommandId.longitudinal,cs)M=t(C(cs*100,0)/100,-1,1)bg=nil end;function ma.cmdCruise(cs,ov)if u:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ov then d.control.cancelCurrentControlMasterMode()end;u:setTargetSpeedCommand(axisCommandId.longitudinal,cs)bg=cs end;function ma.ToggleLockPitch()if LockPitch==nil then bA("lkPOn","LP")if not a3 then LockPitch=bi else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bA("lkPOff","LP")LockPitch=nil end end;function ma.ToggleAltitudeHold()if G-mj<1.5 then if planet.hasAtmosphere then if ap>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bA("11","EP")else if bp then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b0=HoldAltitude;mp=true;if not IntoOrbit then aO.ToggleIntoOrbit()end;mn=true end end;mj=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else mj=G end;if bp and ap==0 then b0=aq;mp=true;mn=true;aO.ToggleIntoOrbit()if IntoOrbit then mj=G else mj=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a2=false;aT=true;LockPitch=nil;b1=false;if am~=-1 and ba<20 then bA("lfs","LS")AutoTakeoff=true;if mj>-1 then HoldAltitude=aq+AutoTakeoffAltitude end;GearExtended=false;d.control.retractLandingGears()BrakeIsOn=true;u:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and be then aO.ToggleVerticalTakeoff()end else bA("altOn","AH")AutoTakeoff=false;if mj>-1 then if bp then HoldAltitude=aq end end;if VertTakeOff then aO.ToggleVerticalTakeoff()end end;if ak then HoldAltitude=100000 end else bA("altOff","AH")if IntoOrbit then aO.ToggleIntoOrbit()end;if VertTakeOff then aO.ToggleVerticalTakeoff()end;aT=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;mj=0 end end;function ma.ResetAutopilots(ma)if ma then ak=false;Autopilot=false;AutopilotRealigned=false;R=false;HoldAltitude=aq;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bn=nil;if not bf then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aO.ToggleVerticalTakeoff()end;if IntoOrbit then aO.ToggleIntoOrbit()end;aT=autoRollPreference;aj=false;al=false;ad=0 end;function ma.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aT=autoRollPreference end;if BrakeIsOn then bA("bkOn","B",1)aO.ResetAutopilots()else bA("bkOff","B",1)end end;function ma.BeginReentry()if Reentry then a4="Re-Entry cancelled"bA("reOff","RE")Reentry=false;aT=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a4="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ag=5 elseif not T then Reentry=true;if u:getAxisCommandType(0)~=controlMasterModeId.cruise then d.control.cancelCurrentControlMasterMode()end;aT=true;BrakeIsOn=false;a4="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aX;bA("par","RE")else Reentry=true;AltitudeHold=true;aT=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bQ=bW(HoldAltitude)a4="Beginning Re-entry.  Target speed: "..aX.." Target Altitude: "..bQ;bA("glide","RE")aO.cmdCruise(h(aX))end;AutoTakeoff=false end;function ma.ToggleAntigrav()if antigrav and not ExternalAGG then if bf then bA("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=aq end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bA("aggOn","AG")antigrav.activate()antigrav.show()end end end;am=mx()return ma end;local function ow()local ox={}local oy=true;local oz=5;local oA=5;local oB=oz;local oC=oA;function ox.startControl(oD)local function oE(mJ)local F=1;local function oF(oG,mJ)local oH={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local oI=oG;for _,c8 in ipairs(oH)do if mJ and oI>c8 then oG=c8 elseif oG<c8 and not mJ then oG=c8;break end end;return oG end;if mJ then F=-1 end;if not ExternalAGG and bf then if a3 and mJ then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+F*oA;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+F*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a3 then b0=oF(b0,mJ)else b0=b0+F*oz end;if b0<planet.noAtmosphericDensityAltitude then b0=planet.noAtmosphericDensityAltitude end else if a3 and ao then HoldAltitude=oF(HoldAltitude,mJ)else HoldAltitude=HoldAltitude+F*oz end end else u:updateTargetGroundAltitudeFromActionStart(F*1.0)end end;local function oJ(oK)if not ao then a4="Flight Assist in Atmo only"return end;local ce=type(oK)if bn==nil then if ce=="table"then if Autopilot or VectorToTarget then aO.ToggleAutopilot()end;bA("180On","BR")elseif oK==1 then bA("bnkLft","BR")else bA("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aO.ToggleAltitudeHold()if ce~="table"then oK=oK+1 end end;bn=oK else bA("180Off","BR")bn=nil end end;if oD=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aO.cmdThrottle(0)if vBooster or hover then if ao and am==-1 then bA("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aT=true;GearExtended=false else if U then bA("grOut","LG",1)d.control.extendLandingGears()end;u:setTargetGroundAltitude(LandingGearGroundHeight)if ao then BrakeIsOn=true end end end;if U and not BrakeLanding and not(vBooster or hover)then bA("grOut","LG",1)d.control.extendLandingGears()end else if U then bA("grIn","LG",1)d.control.retractLandingGears()end;u:setTargetGroundAltitude(TargetHoverHeight)end elseif oD=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif oD=="forward"then V=V-1 elseif oD=="backward"then if AltIsOn then oJ(-b9*5000)else V=V+1 end elseif oD=="left"then if AltIsOn then oJ(1)else Y=Y-1 end elseif oD=="right"then if AltIsOn then oJ(3)else Y=Y+1 end elseif oD=="yawright"then Z=Z-1 elseif oD=="yawleft"then Z=Z+1 elseif oD=="straferight"then u:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif oD=="strafeleft"then u:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif oD=="up"then ad=ad+1;u:deactivateGroundEngineAltitudeStabilization()u:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif oD=="down"then ad=ad-1;u:deactivateGroundEngineAltitudeStabilization()u:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif oD=="groundaltitudeup"then oE()elseif oD=="groundaltitudedown"then oE(true)elseif oD=="option1"then toggleView=false;if AltIsOn and a3 then local oL=""for i=1,#bv do oL=oL.."| Name: "..a.getPlayerName(bv[i]).." Mass: "..C(b.getBoardedPlayerMass(bv[i])/1000,1).."t "end;a.print("Onboard: "..oL)return end;aN.adjustAutopilotTargetIndex()elseif oD=="option2"then toggleView=false;if AltIsOn and a3 then for i=1,#bv do b.forceDeboard(bv[i])end;a4="Deboarded All Passengers"return end;aN.adjustAutopilotTargetIndex(1)elseif oD=="option3"then local function oM()oy=not oy;if not oy then bA("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,"Atmo Fuel","fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,"Space Fuel","fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,"Rocket Fuel","fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=a.createWidgetPanel("Docking")parentingWidgetId=a.createWidget(parentingPanelId,"parenting")a.addDataToWidget(c.getDataId(),parentingWidgetId)coreCombatStressPanelId=a.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=a.createWidget(coreCombatStressPanelId,"core_stress")a.addDataToWidget(b.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bA("hud","DH")c.hide()b.hide()if fuelPanelID~=nil then v(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then v(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then v(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then v(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then v(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;toggleView=false;if AltIsOn and a3 then local oL=""for i=1,#bw do oL=oL.."| ID: "..bw[i].." Mass: "..C(b.getDockedConstructMass(bw[i])/1000,1).."t "end;a.print("Docked Ships: "..oL)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oM()elseif oD=="option4"then toggleView=false;if AltIsOn and a3 then for i=1,#bw do b.forceUndock(bw[i])end;a4="Undocked all ships"return end;bn=nil;aO.ToggleAutopilot()elseif oD=="option5"then toggleView=false;aO.ToggleLockPitch()elseif oD=="option6"then toggleView=false;if AltIsOn and a3 then if shield_1 then local oN=shield_1.getVentingCooldown()if oN>0 then a4="Cannot vent again for "..oN.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a4="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a4="Shields already at max hitpoints"end;return else a4="No shield found"return end end;aO.ToggleAltitudeHold()elseif oD=="option7"then toggleView=false;if AltIsOn and a3 then if shield_1 then shield_1.toggle()return else a4="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a4="Collision System Enabled"else a4="Collision System Secured"end elseif oD=="option8"then toggleView=false;if AltIsOn and a3 then if AutopilotTargetIndex>0 and CustomTarget~=nil then aO.routeWP()else a4="Select a saved wp on IPH to add to or remove from route"end;return end;stablized=not stablized;if not stablized then a4="DeCoupled Mode - Ground Stabilization off"u:deactivateGroundEngineAltitudeStabilization()bA("gsOff","GS")else a4="Coupled Mode - Ground Stabilization on"u:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)d:setEngineForceCommand('hover',vec3(),1)bA("gsOn","GS")end elseif oD=="option9"then toggleView=false;if AltIsOn and a3 then u:resetCommand(axisCommandId.longitudinal)u:resetCommand(axisCommandId.lateral)u:resetCommand(axisCommandId.vertical)aO.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()av=gyro.getState()==1;if av then bA("gyOn","GA")else bA("gyOff","GA")end else a4="No gyro found"end elseif oD=="lshift"then bs=false;if AltIsOn then a3=true end;if z()==1 then a3=true;PrevViewLock=z()y(1)elseif p()==1 and ShiftShowsRemoteButtons then a3=true;aS=false;aR=false end elseif oD=="brake"then if BrakeToggleStatus or AltIsOn then aO.BrakeToggle()elseif not BrakeIsOn then aO.BrakeToggle()else BrakeIsOn=true end elseif oD=="lalt"then toggleView=true;AltIsOn=true;if p()==0 and not freeLookToggle and userControlScheme=="keyboard"then y(1)end elseif oD=="booster"then if VanillaRockets then d:toggleBoosters()elseif not a5 then if not IsRocketOn then d:toggleBoosters()IsRocketOn=true end;a5=true else if IsRocketOn then d:toggleBoosters()IsRocketOn=false end;a5=false end elseif oD=="stopengines"then local function oO()if G-H<1.5 then bA("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bn=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a2=false;R=false;aj=false;ak=false;T=false;aT=autoRollPreference;VectorToTarget=false;TurnBurn=false;av=false;LockPitch=nil;IntoOrbit=false end end;oO()H=G;if u:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if M~=0 then u:resetCommand(axisCommandId.longitudinal)aO.cmdThrottle(0)else aO.cmdThrottle(100)end else if u:getTargetSpeed(axisCommandId.longitudinal)~=0 then u:resetCommand(axisCommandId.longitudinal)else if ao then aO.cmdCruise(AtmoSpeedLimit)else aO.cmdCruise(MaxGameVelocity*3.6)end end end elseif oD=="speedup"then aO.changeSpd()elseif oD=="speeddown"then aO.changeSpd(true)elseif oD=="antigravity"and not ExternalAGG then if antigrav~=nil then aO.ToggleAntigrav()else a4="No antigrav found"end end end;function ox.stopControl(oD)local function oP()if not ExternalAGG and bf then oC=oA end;if AltitudeHold or VertTakeOff or IntoOrbit then oB=oz end end;if oD=="forward"then V=0 elseif oD=="backward"then V=0 elseif oD=="left"then if bn then if bn==2 then bn=-2 else bn=-1 end end;Y=0 elseif oD=="right"then if bn then if bn==4 then bn=-2 else bn=-1 end end;Y=0 elseif oD=="yawright"then Z=0 elseif oD=="yawleft"then Z=0 elseif oD=="straferight"then u:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif oD=="strafeleft"then u:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif oD=="up"then ad=0;u:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then u:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)d:setEngineForceCommand('hover',vec3(),1)end elseif oD=="down"then ad=0;u:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then u:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)d:setEngineForceCommand('hover',vec3(),1)end elseif oD=="groundaltitudeup"then oP()toggleView=false elseif oD=="groundaltitudedown"then oP()toggleView=false elseif oD=="lshift"then if z()==1 then ae=0;af=0;y(PrevViewLock)elseif p()==1 and ShiftShowsRemoteButtons then aS=false;aR=false end;a3=false elseif oD=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aO.BrakeToggle()else BrakeIsOn=false end end elseif oD=="lalt"then if p()==0 and freeLookToggle then if toggleView then if z()==1 then y(0)else y(1)end else toggleView=true end elseif p()==0 and not freeLookToggle and userControlScheme=="keyboard"then y(0)end;AltIsOn=false end end;function ox.loopControl(oD)local function oQ(mJ)local F=1;if mJ then F=-1 end;if not ExternalAGG and bf then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+F*oC;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;oC=t(oC*1.05,oA,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+F*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then b0=b0+F*oB;if b0<planet.noAtmosphericDensityAltitude then b0=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+F*oB end;oB=t(oB*1.05,oz,50)else u:updateTargetGroundAltitudeFromActionLoop(F*1.0)end end;local function oR(mJ)local F=1;if mJ then F=-1 end;if not a3 then if AtmoSpeedAssist and not AltIsOn then M=t(M+F*speedChangeSmall/100,-1,1)else u:updateCommandFromActionLoop(axisCommandId.longitudinal,F*speedChangeSmall)end end end;if oD=="groundaltitudeup"then if not a3 then oQ()end elseif oD=="groundaltitudedown"then if not a3 then oQ(true)end elseif oD=="speedup"then oR()elseif oD=="speeddown"then oR(true)end end;function ox.inputTextControl(bQ)local function oS(oT,e2,hu)local function oU(e2)local D=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cl='::pos{'..D..','..D..','..D..','..D..','..D..'}'local cz,cA,cH,cI,cJ=r(e2,cl)if cz=="0"and cA=="0"then return vec3(B(cH),B(cI),B(cJ))end;cI=math.rad(cI)cH=math.rad(cH)local planet=e[B(cz)][B(cA)]local du=math.cos(cH)local oV=vec3(du*math.cos(cI),du*math.sin(cI),math.sin(cH))return planet.center+(planet.radius+cJ)*oV end;local position=oU(e2)return aN.AddNewLocation(oT,position,hu)end;local i;local oW,oX=nil,nil;local oY="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp"i=string.find(bQ," ")oW=bQ;if i~=nil then oW=string.sub(bQ,0,i-1)oX=string.sub(bQ,i+1)end;if oW=="/help"or oW=="/commands"then for lm in string.gmatch(oY,"([^\n]+)")do a.print(lm)end;return elseif oW=="/setname"then if oX==nil or oX==""then a4="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aN.UpdatePosition(oX)else a4="Select a saved target to rename first"end elseif shield_1 and oW=="/resist"then if not shield_1 then a4="No shield found"return elseif oX==nil or shield_1.getResistancesCooldown()>0 then a4="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local D=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cl=D..', '..D..', '..D..', '..D;local oZ,o_,p0,p1=r(oX,cl)if p1==nil or oZ+o_+p0+p1>0.6 then a4="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(oZ,o_,p0,p1)==1 then a4="Shield Resistances set"else a4="Resistance setting failed."end elseif oW=="/addlocation"or string.find(bQ,"::pos")~=nil then local hu=false;local oT="0-Temp"if oX==nil or oX==""then oX=oW;hu=true end;i=string.find(oX,"::")if not hu then oT=string.sub(oX,1,i-2)end;local e2=string.sub(oX,i)oS(oT,e2,hu)elseif oW=="/agg"then if oX==nil or oX==""then a4="Usage: /agg targetheight"return end;oX=B(oX)if oX<1000 then oX=1000 end;AntigravTargetAltitude=oX;a4="AGG Target Height set to "..oX elseif oW=="/G"then if oX==nil or oX==""then a4="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oX=="dump"then for c7,c8 in pairs(bG())do if type(_G[c8])=="boolean"then if _G[c8]==true then a.print(c8 .." true")else a.print(c8 .." false")end elseif _G[c8]==nil then a.print(c8 .." nil")else a.print(c8 .." ".._G[c8])end end;return end;i=string.find(oX," ")local p2=string.sub(oX,0,i-1)local p3=string.sub(oX,i+1)for c7,c8 in pairs(bG())do if c8==p2 then a4="Variable "..p2 .." changed to "..p3;local p4=type(_G[c8])if p4=="number"then p3=B(p3)if c8=="AtmoSpeedLimit"then aX=p3 end elseif p4=="boolean"then if string.lower(p3)=="true"then p3=true else p3=false end end;_G[c8]=p3;return end end;a4="No such global variable: "..p2 elseif oW=="/deletewp"then if AutopilotTargetIndex>0 and CustomTarget~=nil then aN.ClearCurrentPosition()else a4="Select a custom wp to delete first in IPH"end elseif oW=="/copydatabank"then if dbHud_2 then c3(true)else a4="Spare Databank required to copy databank"end elseif oW=="/iphWP"then if AutopilotTargetIndex>0 then a.print(aO.showWayPoint(aa,AutopilotTargetCoords,true))a4="::pos waypoint shown in lua chat"else a4="No target selected in IPH"end end end;return ox end;function script.onStart()local p5=false;local function p6()local function p7(p8)local p9=dbHud_1.hasKey;for c7,c8 in pairs(p8)do if p9(c8)then local cn=k(dbHud_1.getStringValue(c8))if cn~=nil then _G[c8]=cn;p5=true end end end end;if dbHud_1 then if not useTheseSettings then p7(bG())coroutine.yield()p7(f)else p7(f)a4="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ag=5;p5=false end;coroutine.yield()if p5 then a4="Loaded Saved Variables"aA=ResolutionX;aB=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aT=autoRollPreference;aX=AtmoSpeedLimit;aw=[[rgb(]]..h(J+0.5)..","..h(L+0.5)..","..h(K+0.5)..[[)]]ax=[[rgb(]]..h(J*0.9+0.5)..","..h(L*0.9+0.5)..","..h(K*0.9+0.5)..[[)]]elseif not useTheseSettings then a4="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a4="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a4="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<G then LastMaxBrakeInAtmo=0 end;LastStartTime=G;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a4="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ag=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=aq end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function pa()local function pb(pc,pd)if pc>pd then pd=pc end;local pe,pf=0,0;if ContainerOptimization>0 then pe=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then pf=FuelTankOptimization*0.05 end;pd=pd*(1-(pe+pf))return pd end;local pg=b.getElementNameById;local ph=fuelX~=0 and fuelY~=0;for c7 in pairs(ar)do local type=b.getElementTypeById(ar[c7])if r(type,'^.*Atmospheric Engine$')then if r(tostring(b.getElementTagsById(ar[c7])),'^.*vertical.*$')and b.getElementForwardById(ar[c7])[3]>0 then be=true end end;if r(type,'^.*Space Engine$')then b4=true;if r(tostring(b.getElementTagsById(ar[c7])),'^.*vertical.*$')then local pi=b.getElementForwardById(ar[c7])if pi[3]<0 then b2=true else b3=true end end end;if type=="Landing Gear"then U=true end;if type=="Dynamic Core Unit"then local pj=m(ar[c7])if pj>10000 then I=110 elseif pj>1000 then I=55 elseif pj>150 then I=27 end end;aF=aF+m(ar[c7])if ph and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pj=m(ar[c7])local ld=o(ar[c7])local pc=0;local gz=s()if type=="Atmospheric Fuel Tank"then local pd=400;local pk=35.03;if pj>10000 then pd=51200;pk=5480 elseif pj>1300 then pd=6400;pk=988.67 elseif pj>150 then pd=1600;pk=182.67 end;pc=ld-pk;if fuelTankHandlingAtmo>0 then pd=pd+pd*fuelTankHandlingAtmo*0.2 end;pd=pb(pc,pd)aC[#aC+1]={ar[c7],pg(ar[c7]),pd,pk,pc,gz}end;if type=="Rocket Fuel Tank"then local pd=320;local pk=173.42;if pj>65000 then pd=40000;pk=25740 elseif pj>6000 then pd=5120;pk=4720 elseif pj>700 then pd=640;pk=886.72 end;pc=ld-pk;if fuelTankHandlingRocket>0 then pd=pd+pd*fuelTankHandlingRocket*0.1 end;pd=pb(pc,pd)aE[#aE+1]={ar[c7],pg(ar[c7]),pd,pk,pc,gz}end;if type=="Space Fuel Tank"then local pd=600;local pk=35.03;if pj>10000 then pd=76800;pk=5480 elseif pj>1300 then pd=9600;pk=988.67 elseif pj>150 then pd=2400;pk=182.67 end;pc=ld-pk;if fuelTankHandlingSpace>0 then pd=pd+pd*fuelTankHandlingSpace*0.2 end;pd=pb(pc,pd)aD[#aD+1]={ar[c7],pg(ar[c7]),pd,pk,pc,gz}end end end;if not be then VertTakeOff,VertTakeOffEngine=false,false end end;local function pl()if gyro~=nil then av=gyro.getState()==1 end;if not stablized then u:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then y(1)else y(0)end;if door and(ao or not ao and aq<10000)then for _,c8 in pairs(door)do c8.toggle()end end;if switch then for _,c8 in pairs(switch)do c8.toggle()end end;if forcefield and(ao or not ao==0 and aq<10000)then for _,c8 in pairs(forcefield)do c8.toggle()end end;if antigrav then bf=antigrav.getState()==1;if bf and not ExternalAGG then antigrav.show()end end;if p()==1 and RemoteFreeze then a.freeze(1)else a.freeze(0)end;if U then GearExtended=d.control.isAnyLandingGearExtended()==1;if GearExtended then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if am~=-1 or not ao and b8:len()<50 then BrakeIsOn=true;GearExtended=true;if U then d.control.extendLandingGears()end else BrakeIsOn=false end;u:setTargetGroundAltitude(aU)if ao and am~=-1 then aK=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;WasInAtmo=ao end;local function pm()local pn={}local function po()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local pp={[1]=4480,[6]=4480,[7]=6270}for pq,pr in pairs(e)do e[pq][0]=po()e[pq][0].systemId=pq;pn[pq]={}for ps,planet in pairs(e[pq])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=pp[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=pq;planet.bodyId=planet.id;pn[pq][ps]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bx[#bx+1]=planet end end end;aH=c9()aI=aH(pn)aJ=dx()aL=e0()aN=lT()end;SetupComplete=false;beginSetup=coroutine.create(function()u:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})p6()coroutine.yield()pa()coroutine.yield()aO=m9()pl()coroutine.yield()pm()aP=eo()aM=fK()aM.ButtonSetup()aQ=ow()coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",apTickRate)c.setTimer("radarTick",apTickRate)c.setTimer("hudTick",hudTickRate)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)bA("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ap>0 or ap==0 and aq<10000)then for _,c8 in pairs(door)do c8.toggle()end end;if switch then for _,c8 in pairs(switch)do c8.toggle()end end;if forcefield and(ap>0 or ap==0 and aq<10000)then for _,c8 in pairs(forcefield)do c8.toggle()end end;showHud=bz;c3()if button then button.activate()end;if SetWaypointOnExit then aO.showWayPoint(planet,bd)end;bA("stop","SU")end;function script.onTick(pt)local pu=nil;if pt=="contact"then if not contactTimer then contactTimer=0 end;if G>contactTimer+10 then a4="Radar Contact"bA("rdrCon","RC")contactTimer=G end;c.stopTimer("contact")elseif pt=="tenthSecond"then local function pv()local pw=a.createData;local px=a.createWidget;panelInterplanetary=a.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=px(panelInterplanetary,"value")interplanetaryHeaderText=pw('{"label": "Target Planet", "value": "N/A", "u":""}')x(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=px(panelInterplanetary,"value")widgetDistanceText=pw('{"label": "distance", "value": "N/A", "u":""}')x(widgetDistanceText,widgetDistance)widgetTravelTime=px(panelInterplanetary,"value")widgetTravelTimeText=pw('{"label": "Travel Time", "value": "N/A", "u":""}')x(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=px(panelInterplanetary,"value")widgetMaxMassText=pw('{"label": "Maximum Mass", "value": "N/A", "u":""}')x(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=px(panelInterplanetary,"value")widgetTargetOrbitText=pw('{"label": "Target Altitude", "value": "N/A", "u":""}')x(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=px(panelInterplanetary,"value")widgetCurBrakeDistanceText=pw('{"label": "Cur Brake distance", "value": "N/A", "u":""}')widgetCurBrakeTime=px(panelInterplanetary,"value")widgetCurBrakeTimeText=pw('{"label": "Cur Brake Time", "value": "N/A", "u":""}')widgetMaxBrakeDistance=px(panelInterplanetary,"value")widgetMaxBrakeDistanceText=pw('{"label": "Max Brake distance", "value": "N/A", "u":""}')widgetMaxBrakeTime=px(panelInterplanetary,"value")widgetMaxBrakeTimeText=pw('{"label": "Max Brake Time", "value": "N/A", "u":""}')widgetTrajectoryAltitude=px(panelInterplanetary,"value")widgetTrajectoryAltitudeText=pw('{"label": "Projected Altitude", "value": "N/A", "u":""}')if not ao then x(widgetCurBrakeDistanceText,widgetCurBrakeDistance)x(widgetCurBrakeTimeText,widgetCurBrakeTime)x(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)x(widgetMaxBrakeTimeText,widgetMaxBrakeTime)x(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function py()v(panelInterplanetary)panelInterplanetary=nil end;local function pz()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(aa.center-bd):len()else AutopilotDistance=(CustomTarget.position-bd):len()end end;local dZ=ba;local nC=c.getThrottle()/100;if AtmoSpeedAssist then nC=M end;local pA,pB=aJ.computeDistanceAndTime(ba,MaxGameVelocity,at,d:maxForceForward()*nC,warmup,0)local a6,a7;if not TurnBurn then a6,a7=aO.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=aO.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,pC;if not TurnBurn and dZ>0 then _,pC=aO.GetAutopilotBrakeDistanceAndTime(dZ)else _,pC=aO.GetAutopilotTBBrakeDistanceAndTime(dZ)end;local pD=0;local pE=0;if AutopilotCruising or not Autopilot and dZ>5 then pE=aJ.computeTravelTime(dZ,0,AutopilotDistance)elseif a6+pA<AutopilotDistance then pD=AutopilotDistance-(a6+pA)pE=aJ.computeTravelTime(8333.0556,0,pD)else local pF=(AutopilotDistance-a6)/pA;pA=AutopilotDistance-a6;pB=pB*pF end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return pE elseif AutopilotBraking then return pC elseif AutopilotCruising then return pE+pC else return pB+a7+pE end end;local function pG(l5,pH)if l5==nil then l5=b.g()end;l5=C(l5,5)if pH~=nil and pH or(pu==nil or pu~=l5)then local dZ=b8:len()local pI=k(c.getData()).maxBrake;if pI~=nil and pI>0 and ao then pI=pI/t(dZ/100,0.1,1)pI=pI/ap;if ap>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+pI)/2 else LastMaxBrakeInAtmo=pI end end end;if pI~=nil and pI>0 then LastMaxBrake=pI end;pu=l5 end end;pG(nil,true)if bg~=nil then if u:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or u:getTargetSpeed(axisCommandId.longitudinal)~=bg then aO.cmdCruise(bg)else bg=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then pv()end;if AutopilotTargetName~=nil then local pJ=CustomTarget~=nil;local pK=0.5*LastMaxBrakeInAtmo/aa:getGravity(aa.center+vec3(0,0,1)*aa.radius):len()pK=pK>1000000 and C(pK/1000000,2).." kTons"or C(pK/1000,2).." Tons"w(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "u":""}')travelTime=pz()if pJ and not Autopilot then ah=(bd-CustomTarget.position):len()else ah=(AutopilotTargetCoords-bd):len()end;if not TurnBurn then a6,a7=aO.GetAutopilotBrakeDistanceAndTime(ba)a8,a9=aO.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=aO.GetAutopilotTBBrakeDistanceAndTime(ba)a8,a9=aO.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ik=bW(ah)w(widgetDistanceText,'{"label": "distance", "value": "'..ik..'"}')w(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..bZ(travelTime)..'", "u":""}')ik=bW(a6)w(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ik..'"}')w(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..bZ(a7)..'", "u":""}')ik=bW(a8)w(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ik..'"}')w(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..bZ(a9)..'", "u":""}')w(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..j("%s",pK)..'", "u":""}')ik=bW(AutopilotTargetOrbit)w(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ik..'"}')if ap>0 and not WasInAtmo then a.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)a.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)a.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)a.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)a.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bh and AtmoSpeedAssist and(AltitudeHold or Reentry or al)then aO.cmdThrottle(1)BrakeIsOn=false;Q=false end end;if ap==0 and WasInAtmo then if w(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then x(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if w(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then x(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if w(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then x(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if w(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then x(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if w(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then x(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else py()end;if warpdrive~=nil then if k(warpdrive.getData()).destination~="Unknown"and k(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aM.TenthTick()elseif pt=="oneSecond"then local function pL(gJ)local pM=0;az=""local pN=aF;local pO=0;local pP=0;local pQ=0;local gD=0;local gE=""local pR=b.getElementHitPointsById;for c7 in pairs(ar)do local pj=0;local pS=0;pS=m(ar[c7])pj=pR(ar[c7])pO=pO+pj;if pj<pS then if pj==0 then pQ=pQ+1 else pP=pP+1 end;if aG and#ay==0 then position=vec3(b.getElementPositionById(ar[c7]))local bO=position.x;local bP=position.y;local eW=position.z;table.insert(ay,b.spawnArrowSticker(bO,bP,eW+1,"down"))table.insert(ay,b.spawnArrowSticker(bO,bP,eW+1,"down"))b.rotateSticker(ay[2],0,0,90)table.insert(ay,b.spawnArrowSticker(bO+1,bP,eW,"north"))table.insert(ay,b.spawnArrowSticker(bO+1,bP,eW,"north"))b.rotateSticker(ay[4],90,90,0)table.insert(ay,b.spawnArrowSticker(bO-1,bP,eW,"south"))table.insert(ay,b.spawnArrowSticker(bO-1,bP,eW,"south"))b.rotateSticker(ay[6],90,-90,0)table.insert(ay,b.spawnArrowSticker(bO,bP-1,eW,"east"))table.insert(ay,b.spawnArrowSticker(bO,bP-1,eW,"east"))b.rotateSticker(ay[8],90,0,90)table.insert(ay,b.spawnArrowSticker(bO,bP+1,eW,"west"))table.insert(ay,b.spawnArrowSticker(bO,bP+1,eW,"west"))b.rotateSticker(ay[10],-90,0,90)table.insert(ay,ar[c7])end elseif aG and#ay>0 and ay[11]==ar[c7]then for gy in pairs(ay)do b.deleteSticker(ay[gy])end;ay={}end end;pM=h(pO/pN*100)if pM<100 then gJ[#gJ+1]=bN(0,0,"","pbright txt")gD=h(pM*2.55)gE=j("rgb(%d,%d,%d)",255-gD,gD,0)if pM<100 then gJ[#gJ+1]=bN("50%",1035,"Elemental Integrity: "..pM.."%","txtbig txtmid","fill:"..gE)if pQ>0 then gJ[#gJ+1]=bN("50%",1055,"Disabled Modules: "..pQ.." Damaged Modules: "..pP,"txtbig txtmid","fill:"..gE)elseif pP>0 then gJ[#gJ+1]=bN("50%",1055,"Damaged Modules: "..pP,"txtbig txtmid","fill:"..gE)end end end end;local function pT()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,"Weapons","weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then v(WeaponPanelID)WeaponPanelID=nil end end end;bv=b.getPlayersOnBoard()bw=b.getDockedConstructs()pT()local gJ={}aM.OneSecond(gJ)if ShouldCheckDamage then pL(gJ)end;ai=table.concat(gJ,"")collectgarbage("collect")elseif pt=="fiveSecond"then if not UseSatNav then return end;an=dbHud_1.getStringValue("SPBAutopilotTargetName")if an~=nil and an~=""and an~="SatNavNotChanged"then local cn=k(dbHud_1.getStringValue("SavedLocations"))if cn~=nil then _G["SavedLocations"]=cn;local fe=-1;local m5;for c7,c8 in pairs(SavedLocations)do if c8.name and c8.name=="SatNav Location"then fe=c7;break end end;if fe~=-1 then m5=SavedLocations[fe]fe=-1;for c7,c8 in pairs(e[0])do if c8.name and c8.name=="SatNav Location"then fe=c7;break end end;if fe>-1 then e[0][fe]=m5 end;aN.UpdateAtlasLocationsList()a4=m5.name.." position updated"end end;for i=1,#bk do if bk[i].name==an then AutopilotTargetIndex=i;a.print("Index = "..AutopilotTargetIndex.." "..bk[i].name)aN.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif pt=="msgTick"then local gJ={}aM.DisplayMessage(gJ,"empty")a4="empty"c.stopTimer("msgTick")ag=3 elseif pt=="animateTick"then aS=true;aR=false;ae=0;af=0;c.stopTimer("animateTick")elseif pt=="hudTick"then aM.hudtick()elseif pt=="apTick"then aO.APTick()elseif pt=="radarTick"then aP.UpdateRadar()elseif pt=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a4="Extra Engine Tags: "..UseExtra;c.stopTimer("tagTick")end end;function script.onFlush()local function pU(pV,nL)local pW=vec3()local pX=vec3()if pV==axisCommandId.longitudinal then pW=vec3(b.getConstructOrientationForward())pX=b6 elseif pV==axisCommandId.vertical then pW=vec3(b.getConstructOrientationUp())pX=b5 elseif pV==axisCommandId.lateral then pW=vec3(b.getConstructOrientationRight())pX=b7 else return vec3()end;local pY=vec3(b.getWorldGravity())local pZ=pY:dot(pX)local p_=vec3(b.getWorldAirFrictionAcceleration())local q0=p_:dot(pX)local q1=b8:dot(pW)local q2=nL*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(q2-q1)local q3=targetSpeedPID2:get()local q4=(q3-q0-pZ)*pX;return q4 end;local function q5(pV,nL)local pW=vec3()local pX=vec3()if pV==axisCommandId.longitudinal then pW=vec3(b.getConstructOrientationForward())pX=b6 elseif pV==axisCommandId.vertical then pW=vec3(b.getConstructOrientationUp())pX=b5 elseif pV==axisCommandId.lateral then pW=vec3(b.getConstructOrientationRight())pX=b7 else return vec3()end;local pY=vec3(b.getWorldGravity())local pZ=pY:dot(pX)local p_=vec3(b.getWorldAirFrictionAcceleration())local q0=p_:dot(pX)local q1=b8:dot(pW)local q2=nL*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(q2-q1)local q3=targetSpeedPID:get()local q4=(q3-q0-pZ)*pX;return q4 end;local function q6(q7,gM,lY)local q8=q7:cross(lY):normalize_inplace()local hy=math.acos(t(q8:dot(-gM),-1,1))*constants.rad2deg;if q8:cross(-gM):dot(lY)<0 then hy=-hy end;return hy end;if antigrav and not ExternalAGG then if not bf and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bh=u:getAxisCommandType(0)==axisCommandType.byThrottle;if bh and Q then aO.cmdThrottle(0)Q=false elseif not bh and not Q then M=0;Q=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local q9=t(V+W+a.getControlDeviceForwardInput(),-1,1)local qa=t(Y+a1+a.getControlDeviceYawInput(),-1,1)local qb=t(Z+X-a.getControlDeviceLeftRightInput(),-1,1)local qc=a0;bb=vec3(b.getWorldVertical())if bb==nil or bb:len()==0 then bb=(planet.center-bd):normalize()end;b5=vec3(b.getConstructWorldOrientationUp())b6=vec3(b.getConstructWorldOrientationForward())b7=vec3(b.getConstructWorldOrientationRight())b9=vec3(b.getWorldVelocity())b8=vec3(b.getVelocity())bd=vec3(b.getConstructWorldPos())at=b.getConstructMass()ba=vec3(b9):len()bc=-bb:dot(b9)bj=getRoll(bb,b6,b7)local qd=bj/180*math.pi;local qe=math.cos(qd)local qf=math.sin(qd)bi=q6(bb,b6,b7*qe+b5*qf)local qg=b9:normalize()local qh=g(bj)local qi=utils.sign(bj)local qj=vec3(b.getWorldAngularVelocity())local qk=q9*pitchSpeedFactor*b7+qa*rollSpeedFactor*b6+qb*yawSpeedFactor*b5;if aT==true and bb:len()>0.01 then local ql=g(aW-bj)if((ProgradeIsOn or Reentry or BrakeLanding or aj or AltitudeHold or IntoOrbit)and ql>0 or ap>0.0 and ql<autoRollRollThreshold and autoRollPreference)and qa==0 and g(bi)<85 then local qm=aW;local qn=autoRollFactor;if ap==0 then qn=qn/4;aW=0;qm=0 end;if rollPID==nil then rollPID=pid.new(qn*0.01,0,qn*0.1)end;rollPID:inject(qm-bj)local qo=rollPID:get()qk=qk+qo*b6 end end;local qp=1;local qq=0;local qr=1;local qs=a.getMouseWheel()if qs>0 then aO.changeSpd()elseif qs<0 then aO.changeSpd(true)else au=true end;N=0;if ao and AtmoSpeedAssist and bh then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aX/3.6-b9:dot(b6))local qt=throttlePID:get()P=t(qt,-1,1)if P<M and ap>0.005 then O=true;u:setThrottleCommand(axisCommandId.longitudinal,t(P,0.01,1))else O=false;u:setThrottleCommand(axisCommandId.longitudinal,M)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(b9:len()-aX/3.6)local qu=t(brakePID:get(),0,1)if ap>0 and bc<-80 or ap>0.005 then N=qu end;if N>0 then if O and P==0.01 then u:setThrottleCommand(axisCommandId.longitudinal,0)end else P=t(P,0.01,1)end;local qv=''local qw=vec3()local qx=pU(axisCommandId.vertical,ad*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",qx,qq)local qy='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then qy=qy..ExtraLongitudeTags end;local qz=u:getAxisCommandType(axisCommandId.longitudinal)local qA=u:composeAxisAccelerationFromThrottle(qy,axisCommandId.longitudinal)local qB=q5(axisCommandId.lateral,LeftAmount*1000)qv=qv..' , '.."lateral airfoil , lateral ground "qw=qw+qB;if qw:len()>constants.epsilon then d:setEngineForceCommand(qv,qw,qq,'','','',qr)end;d:setEngineForceCommand(qy,qA,qp)local qC='thrust analog vertical fueled 'local qD='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then qD=qD..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then qC=qC..ExtraVerticalTags end;if ad~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then d:setEngineForceCommand(qC,qx,qp)else d:setEngineForceCommand(qC,vec3(),qp)end;if LeftAmount~=0 then d:setEngineForceCommand(qD,qB,qp)else d:setEngineForceCommand(qD,vec3(),qp)end;if qc==0 then qc=N end;local qE=-qc*(brakeSpeedFactor*b9+brakeFlatFactor*qg)d:setEngineForceCommand('brake',qE)else if AtmoSpeedAssist then u:setThrottleCommand(axisCommandId.longitudinal,M)end;local nL=c.getAxisCommandValue(0)if not bh then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(b9:len()-nL/3.6)local qu=t(brakePID:get(),0,1)qc=t(qc+qu,0,1)end;local qE=-qc*(brakeSpeedFactor*b9+brakeFlatFactor*qg)d:setEngineForceCommand('brake',qE)local qv=''local qw=vec3()local qF=false;local qy='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then qy=qy..ExtraLongitudeTags end;local qz=u:getAxisCommandType(axisCommandId.longitudinal)if qz==axisCommandType.byThrottle then local qA=u:composeAxisAccelerationFromThrottle(qy,axisCommandId.longitudinal)d:setEngineForceCommand(qy,qA,qp)elseif qz==axisCommandType.byTargetSpeed then local qA=u:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)qv=qv..' , '..qy;qw=qw+qA;if u:getTargetSpeed(axisCommandId.longitudinal)==0 or u:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-u:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then qF=true end end;local qD='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then qD=qD..ExtraLateralTags end;local qG=u:getAxisCommandType(axisCommandId.lateral)if qG==axisCommandType.byThrottle then local qH=u:composeAxisAccelerationFromThrottle(qD,axisCommandId.lateral)d:setEngineForceCommand(qD,qH,qp)elseif qG==axisCommandType.byTargetSpeed then local qB=u:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)qv=qv..' , '..qD;qw=qw+qB end;local qC='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then qC=qC..ExtraVerticalTags end;local qI=u:getAxisCommandType(axisCommandId.vertical)if qI==axisCommandType.byThrottle then local qx=u:composeAxisAccelerationFromThrottle(qC,axisCommandId.vertical)if ad~=0 or BrakeLanding and BrakeIsOn then d:setEngineForceCommand(qC,qx,qp,'airfoil','ground','',qr)else d:setEngineForceCommand(qC,vec3(),qp)d:setEngineForceCommand('airfoil vertical',qx,qp,'airfoil','','',qr)d:setEngineForceCommand('ground vertical',qx,qp,'ground','','',qr)end elseif qI==axisCommandType.byTargetSpeed then if ad<0 then d:setEngineForceCommand('hover',vec3(),qp)end;local qJ=u:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)qv=qv..' , '..qC;qw=qw+qJ end;if qw:len()>constants.epsilon then if a0~=0 or qF or g(qg:dot(b6))<0.5 then qv=qv..', brake'end;d:setEngineForceCommand(qv,qw,qq,'','','',qr)end end;local qK=torqueFactor*(qk-qj)local qL=vec3(b.getWorldAirFrictionAngularAcceleration())qK=qK-qL;d:setEngineTorqueCommand('torque',qK,qp,'airfoil','','',qr)d:setBoosterCommand('rocket_engine')if a5 and not VanillaRockets then local dZ=b8:len()local qM=0.15;if not bh then local qN=u:getTargetSpeed(axisCommandId.longitudinal)if dZ*3.6>qN*(1-qM)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif dZ*3.6<qN*(1-qM)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end else local nC=c.getThrottle()if AtmoSpeedAssist then nC=M*100 end;local nL=nC/100;if n==0 then nL=nL*MaxGameVelocity;if dZ>=nL*(1-qM)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif dZ<nL*(1-qM)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end else local nW=h(aX)nL=nL*nW/3.6;if dZ>=nL*(1-qM)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif dZ<nL*(1-qM)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fB=coroutine.status(beginSetup)if fB=="suspended"then local cs,fC=coroutine.resume(beginSetup)if fC then a.print("ERROR STARTUP: "..fC)end elseif fB=="dead"then SetupComplete=true end end;if SetupComplete then d:update()if not aR and content~=LastContent then a.setScreen(content)end;LastContent=content end end;function script.onActionStart(oD)aQ.startControl(oD)end;function script.onActionStop(oD)aQ.stopControl(oD)end;function script.onActionLoop(oD)aQ.loopControl(oD)end;function script.onInputText(bQ)aQ.inputTextControl(bQ)end;function script.onEnter(cA)if radar_1 and not ao and not bl then c.setTimer("contact",0.1)end end;function script.onLeave(cA)if radar_1 and CollisionSystem then if#bo>650 then cA=tostring(cA)bo[cA]=nil end end end;script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
