name: ArchHud - Archaegeo v1.151 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export: (Default: false)
        userControlScheme = "virtual joystick" --export: (Default: "virtual joystick") Set to "virtual joystick", "mouse", or "keyboard"
        freeLookToggle = true --export: (Default: true)
        BrakeToggleDefault = true --export: (Default: true)
        RemoteFreeze = false --export: (Default: false)
        RemoteHud = true --export: (Default: true)
        brightHud = false --export: (Default: false)
        VanillaRockets = false --export: (Default: false)
        InvertMouse = false --export: (Default: false)
        autoRollPreference = false --export: (Default: false)
        turnAssist = true --export: (Default: true)
        ExternalAGG = false --export: (Default: false)
        UseSatNav = false --export: (Default: false)
        ShouldCheckDamage = true --export: (Default: true)
        CalculateBrakeLandingSpeed = false --export: (Default: false)
        AtmoSpeedAssist = true --export: (Default: true)
        ForceAlignment = false --export: (Default: false)
        DisplayDeadZone = true --export: (Default: true)
        showHud = true --export: (Default: true) 
        ShowOdometer = true --export: (Default: true)
        hideHudOnToggleWidgets = true --export: (Default: true)
        ShiftShowsRemoteButtons = true --export: (Default: true)
        DisplayOrbit = true --export: (Default: true) 
        YawStallAngle = 35 --export: (Default: 35)
        PitchStallAngle = 35 --export: (Default: 35)
        brakeLandingRate = 30 --export: (Default: 30)
        MaxPitch = 30 --export: (Default: 30)
        TargetOrbitRadius = 1.4 --export: (Default: 1.4)
        LowOrbitHeight = 1000 --export: (Default: 1000)
        AtmoSpeedLimit = 1050 --export: (Default: 1050)
        SpaceSpeedLimit = 30000 --export: (Default: 30000).
        AutoTakeoffAltitude = 1000 --export: (Default: 1000)
        TargetHoverHeight = 50 --export: (Default: 50)
        LandingGearGroundHeight = 0 --export: (Default: 0)
        MaxGameVelocity = 8333.00 --export: (Default: 8333.00)
        AutopilotInterplanetaryThrottle = 1.0 --export: (Default: 1.0)
        warmup = 32 --export: (Default: 32)
        fuelTankHandlingAtmo = 0 --export: (Default: 0)
        fuelTankHandlingSpace = 0 --export: (Default: 0)
        fuelTankHandlingRocket = 0 --export: (Default: 0)
        ContainerOptimization = 0 --export: (Default: 0)
        FuelTankOptimization = 0 --export: (Default: 0)
        ResolutionX = 1920 --export: (Default: 1920)
        ResolutionY = 1080 --export: (Default: 1080) 
        circleRad = 400 --export: (Default: 400)
        SafeR = 130 --export: (Default: 130)
        SafeG = 224 --export: (Default: 224)
        SafeB = 255 --export: (Default: 255)
        PvPR = 255 --export: (Default: 255)
        PvPG = 0 --export: (Default: 0)
        PvPB = 0 --export: (Default: 0)
        centerX = 960 --export: (Default: 960)
        centerY = 540 --export: (Default: 540)
        throtPosX = 1300 --export: (Default: 1300)
        throtPosY = 540 --export: (Default: 540)
        vSpdMeterX = 1525  --export: (Default: 1525)
        vSpdMeterY = 325 --export: (Default: 325)
        altMeterX = 550  --export: (Default: 550)
        altMeterY = 540 --export: (Default: 540) 
        fuelX = 100 --export: (Default: 100)
        fuelY = 300 --export: (Default: 300)
        DeadZone = 50 --export: (Default: 50)
        OrbitMapSize = 250 --export: (Default: 250)
        OrbitMapX = 75 --export: (Default: 75)
        OrbitMapY = 0 --export: (Default: 0)
        speedChangeLarge = 5 --export: (Default: 5)
        speedChangeSmall = 1 --export: (Default: 1)
        MouseXSensitivity = 0.003 --export: (Default: 0.003)
        MouseYSensitivity = 0.003 --export: (Default: 0.003)
        autoRollFactor = 2 --export: (Default: 2)
        rollSpeedFactor = 1.5 --export: (Default: 1.5)
        autoRollRollThreshold = 0 --export: (Default: 0)
        minRollVelocity = 150 --export: (Default: 150)    
        turnAssistFactor = 2 --export: (Default: 2)
        TrajectoryAlignmentStrength = 0.002 --export: (Default: 0.002)
        torqueFactor = 2 --export: (Default: 2)
        pitchSpeedFactor = 0.8 --export: (Default: 0.8)
        yawSpeedFactor = 1 --export: (Default: 1)
        brakeSpeedFactor = 3 --export: (Default: 3)
        brakeFlatFactor = 1 --export: (Default: 1)
        DampingMultiplier = 40 --export: (Default: 40) 
        apTickRate = 0.0166667 --export: (Default: 0.0166667)  
        hudTickRate = 0.0666667 --export: (Default: 0.0666667)
        ExtraLongitudeTags = "none" --export: (Default: "none")
        ExtraLateralTags = "none" --export: (Default: "none")
        ExtraVerticalTags = "none" --export: (Default: "none")
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.151;SetWaypointOnExit=true;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;showHelp=true;local b={"showHelp","VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=core.getConstructMass;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local tostring=tostring;local p=utils.round;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local function y(z,A)local B=10^(A or 0)return d(z*B+0.5)/B end;local C=16;local D=SafeR;local E=SafeB;local F=SafeG;local G=0;local H=0;local I=false;local J=0;local K=false;local L=y(ResolutionX/2,0)local M=y(ResolutionY/2,0)local N=false;local O=55;local P=false;local Q=false;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=false;local Z=false;local a0="empty"local a1=5;local a2=5;local a3=a1;local a4=a2;local a5=false;local a6,a7=0;local a8,a9=0;local aa=nil;local ab=0;local ac=0;local ad=false;local ae=0;local af=0;local ag=0;local ah=3;local ai=0;local aj=""local ak=""local al=0;local am=false;local an=false;local ao=false;local ap=-1;local aq=false;local ar=""local as=j()>0;local at=j()local au=core.getAltitude()local av=core.getElementIdList()local aw=q()local ax=false;local ay=nil;local az=false;local aA=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]local aB=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]local aC={}local aD=0;local aE=0;local aF=""local aG=true;local aH={}local aI={}local aJ={}local aK=ResolutionX;local aL=ResolutionY;local aM=false;local aN=false;local aO=0;local aP=nil;local aQ={}local aR={}local aS={}local aT=0;local aU=false;local aV={}local aW={}local aX=d(1/apTickRate)*2;local aY={}local aZ={}local a_={}local b0={}local b1=false;local b2=0;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=nil;local bd=nil;local be=nil;local bf=false;local bg=false;local bh=autoRollPreference;local bi=LandingGearGroundHeight;local bj=false;local bk=q()local bl=0;local bm=0;local bn=0;local bo=AtmoSpeedLimit;local bp=0;local bq=nil;local br=0;local bs=0;local bt=false;local bu=false;local bv={VectorToTarget=false}local bw=false;local bx=0;local by=nil;local bz=false;local bA=false;local bB=false;local bC=false;local bD=0;local bE=q()local bF=vec3(core.getConstructWorldOrientationUp())local bG=vec3(core.getConstructWorldOrientationForward())local bH=vec3(core.getConstructWorldOrientationRight())local bI=vec3(core.getWorldVelocity())local bJ=vec3(bI):len()local bK=vec3(core.getWorldVertical())local bL=-bK:dot(bI)local bM=vec3(core.getConstructWorldPos())local bN=false;local bO=false;local bP=nil;local bQ=true;local bR=0;local bS=0;local bT=false;local bU={}local bV=showHud;local bW={}local function bX(bY,bZ)for i=1,#bZ do bY[#bY+1]=bZ[i]end;return bY end;local function b_(c0)local c1={}local c2={"userControlScheme","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit"}local c3={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c4={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY"}local c5={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c0 then bX(c1,c2)bX(c1,c3)bX(c1,c4)bX(c1,c5)return c1 elseif c0=="boolean"then return c2 elseif c0=="handling"then return c3 elseif c0=="hud"then return c4 elseif c0=="physics"then return c5 end end;local function c6(c7,c8,c9,ca,cb)if ca==nil then ca=""end;if cb==nil then cb=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ca,c7,c8,cb,c9)end;local function cc(cd,ce)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ce then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cd)G=r(y(cd*100,0)/100,-1,1)end;local function cf(cd,ce)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ce then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cd)bP=cd end;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*epsilon end;local function cj(ai,ck)local cl=ai>100000;local cm,cn=""if ck==nil then ck=1 end;if cl then cm,cn=y(ai/1000/200,ck),"SU"elseif ai<1000 then cm,cn=y(ai,ck),"M"else cm,cn=y(ai/1000,ck),"KM"end;return cm,cn end;local function co()if VertTakeOff then AltitudeHold=false;StrongBrakes=true;Reentry=false;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=true;VertTakeOff=false;bh=true;ae=0;if as and ap==-1 then BrakeLanding=false;AltitudeHold=true;ae=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cf(d(bo))end else VertTakeOff=true;AltitudeHold=false;bz=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end end;local function cp()bz=false;br=nil;bs=nil;bD=0;if at==0 then if IntoOrbit then IntoOrbit=false;bt=false;by=nil;bh=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bv.VectorToTarget=false;bv.AutopilotAlign=false;bw=false elseif unit.getClosestPlanetInfluence()>0 then IntoOrbit=true;bh=true;if by==nil then by=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a0="Unable to engage orbiting, not near planet"end else IntoOrbit=false;bt=false;by=nil;bh=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bv.VectorToTarget=false;bv.AutopilotAlign=false;bw=false end end;local function cq()if bE-bm<1.5 then if planet.hasAtmosphere then if at>0 then HoldAltitude=planet.spaceEngineMinAltitude-50 else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bx=HoldAltitude;bw=true;if not IntoOrbit then cp()end;bt=true end end;bm=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bm=bE end;if unit.getClosestPlanetInfluence()>0 and at==0 then bx=au;bw=true;bt=true;cp()if IntoOrbit then bm=bE else bm=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Y=false;bh=true;LockPitch=nil;bz=false;if ap==-1 then AutoTakeoff=false;if bm>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=au end end;if VertTakeOff then co()end else AutoTakeoff=true;if bm>-1 then HoldAltitude=au+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bN then co()end end;if an then HoldAltitude=100000 end else if IntoOrbit then cp()end;if VertTakeOff then co()end;bh=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bm=0 end end;local function cr()if m()==1 then Y=not Y;if Y then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)else BrakeIsOn=true;bh=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a0="Follow Mode only works with Remote controller"Y=false end end;local function cs(planet,ct)local function cu(cv,cw)local cx=vec3(cw)if cv.bodyId==0 then return setmetatable({latitude=cx.x,longitude=cx.y,altitude=cx.z,bodyId=0,systemId=cv.planetarySystemId},MapPosition)end;local cy=cx-cv.center;local ai=cy:len()local cz=ai-cv.radius;local cA=0;local cB=0;if not cg(ai,0)then local cC=n(cy.y,cy.x)cB=cC>=0 and cC or 2*math.pi+cC;cA=math.pi/2-math.acos(cy.z/ai)end;return setmetatable({latitude=math.deg(cA),longitude=math.deg(cB),altitude=cz,bodyId=cv.bodyId,systemId=cv.planetarySystemId},MapPosition)end;local cD=cu(planet,ct)cD="::pos{"..cD.systemId..","..cD.bodyId..","..cD.latitude..","..cD.longitude..","..cD.altitude.."}"system.setWaypoint(cD)end;local function cE()local function cF(SpaceTarget)VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cq()end end;VectorStatus="Proceeding to Waypoint"end;if bE-bn<1.5 and at>0 then if not bC then a0="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if at>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight end;bn=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bn=bE end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not an and not IntoOrbit then bd.UpdateAutopilotTarget()cs(aa,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then if at~=0 then an=true;cq()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if at>0 then if not VectorToTarget then cF(SpaceTarget)end else if au>AutopilotTargetOrbit*1.5 or au==0 then bz=false;Autopilot=true elseif not as then if IntoOrbit then cp()end;bx=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bw=true;bv.AutopilotAlign=true;bv.VectorToTarget=true;bt=false;if not IntoOrbit then cp()end end end else RetrogradeIsOn=false;ProgradeIsOn=false;if at~=0 then an=true;cq()else Autopilot=true end end elseif at==0 then local cG=unit.getClosestPlanetInfluence()>0;if CustomTarget==nil and(aa.name==planet.name and cG)and not IntoOrbit then WaypointSet=false;bz=false;bt=false;cp()else Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Y=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;N=false;LockPitch=nil;WaypointSet=false end else an=true;cq()end else an=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;N=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=au;TargetSet=false;Reentry=false;if IntoOrbit then cp()end end end;local function cH(cI)local cJ=-1;local cK;cJ=bd.findAtlasIndex(SavedLocations)if cJ~=-1 then local cL;if cI~=nil then cK={position=SavedLocations[cJ].position,name=cI,atmosphere=SavedLocations[cJ].atmosphere,planetname=SavedLocations[cJ].planetname,gravity=SavedLocations[cJ].gravity}else cK={position=bM,name=SavedLocations[cJ].name,atmosphere=at,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cJ]=cK;cJ=-1;cJ=bd.findAtlasIndex(b3[0])if cJ>-1 then b3[0][cJ]=cK end;bd.UpdateAtlasLocationsList()a0=CustomTarget.name.." position updated"bd.UpdateAutopilotTarget()else a0="Name Not Found"end end;local function cM()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bh=autoRollPreference end;if BrakeIsOn then AltitudeHold=false;VectorToTarget=false;AutoTakeoff=false;VertTakeOff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;AltitudeHold=false;if VertTakeOff then co()end;if IntoOrbit then cp()end;LockPitch=nil;bh=autoRollPreference;am=false;ao=false;ae=0 end end;local function cN(cO,cP,cQ)local function cR(cO,cS)cO=vec3(cO)cS=vec3(cS):normalize()local cm=cO*cS;return cm.x+cm.y+cm.z end;local cT=0.001;local cU=1;if not as or not bj or ap~=-1 or bJ<O then local cV=cQ;if cV==nil then cV=DampingMultiplier end;if cP==nil then cP=cT end;cO=vec3(cO):normalize()local cW=vec3()-cO;local cX=-cR(cW,core.getConstructWorldOrientationRight())*cU;local cY=-cR(cW,core.getConstructWorldOrientationUp())*cU;if aD==0 then aD=cX/2 end;if aE==0 then aE=cY/2 end;if c(cX)<0.1 then T=T-cX*2 else T=T-(cX+(cX-aD)*cV)end;if c(cY)<0.1 then S=S+cY*2 else S=S+cY+(cY-aE)*cV end;aD=cX;aE=cY;if c(cX)<cP and c(cY)<cP then return true end;return false elseif bj and ap==-1 then cO=bI;local cV=cQ;if cV==nil then cV=DampingMultiplier end;if cP==nil then cP=cT end;cO=vec3(cO):normalize()local cW=bG-cO;local cX=-cR(cW,core.getConstructWorldOrientationRight())*cU;local cY=-cR(cW,core.getConstructWorldOrientationUp())*cU;if aD==0 then aD=cX/2 end;if aE==0 then aE=cY/2 end;if c(cX)<0.1 then T=T-cX*5 else T=T-(cX+(cX-aD)*cV)end;if c(cY)<0.1 then S=S+cY*5 else S=S+cY+(cY-aE)*cV end;aD=cX;aE=cY;if c(cX)<cP and c(cY)<cP then return true end;return false end end;local function cZ()if Reentry then a0="Re-Entry cancelled"Reentry=false;bh=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ah=5 elseif not P then StrongBrakes=planet.gravity*9.80665*l()<LastMaxBrakeInAtmo;if not StrongBrakes then a0="WARNING: Insufficient Brakes for Parachute Re-Entry"else Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bh=true;BrakeIsOn=false;a0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bo end else Reentry=true;AltitudeHold=true;bh=true;BrakeIsOn=false;HoldAltitude=planet.spaceEngineMinAltitude-50;local c9,c_=cj(HoldAltitude)a0="Beginning Re-entry.  Target speed: "..bo.." Target Altitude: "..c9 ..c_;cf(d(bo))end;AutoTakeoff=false end;local function d0()if antigrav and not ExternalAGG then if bO then antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=au end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;antigrav.activate()antigrav.show()end end end;local function d1(d2)local d3=0;local d4=0;local d5=0;if d2<60 then d2=d(d2)elseif d2<3600 then d3=d(d2/60)d2=d(d2%60)elseif d2<86400 then d4=d(d2/3600)d3=d(d2%3600/60)else d5=d(d2/86400)d4=d(d2%86400/3600)end;if d5>0 then return d5 .."d "..d4 .."h "elseif d4>0 then return d4 .."h "..d3 .."m "elseif d3>0 then return d3 .."m "..d2 .."s"elseif d2>0 then return d2 .."s"else return"0s"end end;local function d6(d7)local function d8(d9)for da,db in pairs(d9)do dbHud_1.setStringValue(db,g(_G[db]))if d7 and dbHud_2 then dbHud_2.setStringValue(db,g(_G[db]))end end end;if dbHud_1 then if not ad then d8(b)d8(b_())system.print("Saved Variables to Datacore")if d7 and dbHud_2 then a0="Databank copied.  Remove copy when ready."end end end end;local function dc()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function dd()local function de(df)return type(df)=='number'end;local function dg(df)return type(tonumber(df))=='number'end;local function dh(di)return type(di)=='table'end;local function dj(dk)return type(dk)=='string'end;local function dl(db)return dh(db)and de(db.x and db.y and db.z)end;local function dm(dn)return dh(dn)and de(dn.latitude and dn.longitude and dn.altitude and dn.bodyId and dn.systemId)end;local dp=math.pi/180;local dq=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dr='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local ds=r;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*epsilon end;local function dt(df)local cm=string.gsub(string.reverse(e('%.4f',df)),'^0*%.?','')return cm==''and'0'or string.reverse(cm)end;local function du(dv)if dl(dv)then return e('{x=%.3f,y=%.3f,z=%.3f}',dv.x,dv.y,dv.z)end;if dh(dv)and not getmetatable(dv)then local dw={}local dx=next(dv)if type(dx)=='nil'or dx==1 then dw=dv else for da,db in pairs(dv)do local cd=du(db)if type(da)=='number'then table.insert(dw,e('[%s]=%s',da,cd))else table.insert(dw,e('%s=%s',da,cd))end end end;return e('{%s}',table.concat(dw,','))end;if dj(dv)then return e("'%s'",dv:gsub("'",[[\']]))end;return tostring(dv)end;local dy={}dy.__index=dy;dy.__tostring=function(dv,dz)local dA={}for da in pairs(dv)do table.insert(dA,da)end;table.sort(dA)local dw={}for _,da in ipairs(dA)do local cd=du(dv[da])if type(da)=='number'then table.insert(dw,e('[%s]=%s',da,cd))else table.insert(dw,e('%s=%s',da,cd))end end;if dz then return e('%s%s',dz,table.concat(dw,',\n'..dz))end;return e('{%s}',table.concat(dw,','))end;dy.__eq=function(dB,dC)return dB.planetarySystemId==dC.planetarySystemId and dB.bodyId==dC.bodyId and cg(dB.radius,dC.radius)and cg(dB.center.x,dC.center.x)and cg(dB.center.y,dC.center.y)and cg(dB.center.z,dC.center.z)and cg(dB.GM,dC.GM)end;local function dD(dE,dF,dG,cw,dH)assert(dg(dE),'Argument 1 (planetarySystemId) must be a number:'..type(dE))assert(dg(dF),'Argument 2 (bodyId) must be a number:'..type(dF))assert(dg(dG),'Argument 3 (radius) must be a number:'..type(dG))assert(dh(cw),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cw))assert(dg(dH),'Argument 5 (GM) must be a number:'..type(dH))return setmetatable({planetarySystemId=tonumber(dE),bodyId=tonumber(dF),radius=tonumber(dG),center=vec3(cw),GM=tonumber(dH)},dy)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dI)return e('::pos{%d,%d,%s,%s,%s}',dI.systemId,dI.bodyId,dt(dI.latitude*dq),dt(dI.longitude*dq),dt(dI.altitude))end;MapPosition.__eq=function(dB,dC)return dB.bodyId==dC.bodyId and dB.systemId==dC.systemId and cg(dB.latitude,dC.latitude)and cg(dB.altitude,dC.altitude)and(cg(dB.longitude,dC.longitude)or cg(dB.latitude,math.pi/2)or cg(dB.latitude,-math.pi/2))end;local function dJ(dK,dF,cA,cB,cz)local dE=dK;if dj(dK)and not cB and not cz and not dF and not cA then dE,dF,cA,cB,cz=o(dK,dr)assert(dE,'Argument 1 (position string) is malformed.')else assert(dg(dE),'Argument 1 (systemId) must be a number:'..type(dE))assert(dg(dF),'Argument 2 (bodyId) must be a number:'..type(dF))assert(dg(cA),'Argument 3 (latitude) must be in degrees:'..type(cA))assert(dg(cB),'Argument 4 (longitude) must be in degrees:'..type(cB))assert(dg(cz),'Argument 5 (altitude) must be in meters:'..type(cz))end;dE=tonumber(dE)dF=tonumber(dF)cA=tonumber(cA)cB=tonumber(cB)cz=tonumber(cz)if dF==0 then return setmetatable({latitude=cA,longitude=cB,altitude=cz,bodyId=dF,systemId=dE},MapPosition)end;return setmetatable({latitude=dp*ds(cA,-90,90),longitude=dp*(cB%360),altitude=cz,bodyId=dF,systemId=dE},MapPosition)end;local dL={}dL.__index=dL;dL.__tostring=function(dv,dz)local dM=dz and dz..'  'local dN={}local dA={}for da in pairs(dv)do table.insert(dA,da)end;table.sort(dA)for _,dO in ipairs(dA)do bdy=dv[dO]local dP=dy.__tostring(bdy,dM)if dz then table.insert(dN,e('[%s]={\n%s\n%s}',dO,dP,dz))else table.insert(dN,e('  [%s]=%s',dO,dP))end end;if dz then return e('\n%s%s%s',dz,table.concat(dN,',\n'..dz),dz)end;return e('{\n%s\n}',table.concat(dN,',\n'))end;local function dQ(dR)local b3={}local pid;for _,db in pairs(dR)do local dS=db.planetarySystemId;if type(dS)~='number'then error('Invalid planetary system ID: '..tostring(dS))elseif pid and dS~=pid then error('Mistringmatch planetary system IDs: '..dS..' and '..pid)end;local dT=db.bodyId;if type(dT)~='number'then error('Invalid body ID: '..tostring(dT))elseif b3[dT]then error('Duplicate body ID: '..tostring(dT))end;setmetatable(db.center,getmetatable(vec3.unit_x))b3[dT]=setmetatable(db,dy)pid=dS end;return setmetatable(b3,dL)end;b7={}local function dU(dR)return setmetatable({galaxyAtlas=dR or{}},b7)end;b7.__index=function(di,i)if type(i)=='number'then local system=di.galaxyAtlas[i]return dQ(system)end;return rawget(b7,i)end;b7.__pairs=function(dv)return function(di,da)local dV,nv=next(di,da)return dV,nv and dQ(nv)end,dv.galaxyAtlas,nil end;b7.__tostring=function(dv)local dW={}for _,dX in pairs(dv or{})do local dY=dX:getPlanetarySystemId()local dZ=dL.__tostring(dX,'    ')table.insert(dW,e('  [%s]={%s\n  }',dY,dZ))end;return e('{\n%s\n}\n',table.concat(dW,',\n'))end;b7.BodyParameters=dD;b7.MapPosition=dJ;b7.PlanetarySystem=dQ;function b7.createBodyParameters(d_,dF,e0,e1,e2,e3,e4)assert(dg(d_),'Argument 1 (planetarySystemId) must be a number:'..type(d_))assert(dg(dF),'Argument 2 (bodyId) must be a number:'..type(dF))assert(dg(e0),'Argument 3 (surfaceArea) must be a number:'..type(e0))assert(dh(e1),'Argument 4 (aPosition) must be an array or vec3:'..type(e1))assert(dh(e2),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(e2))assert(dg(e3),'Argument 6 (altitude) must be in meters:'..type(e3))assert(dg(e4),'Argument 7 (gravityAtPosition) must be number:'..type(e4))local dG=math.sqrt(e0/4/math.pi)local ai=dG+e3;local e5=vec3(e1)+ai*vec3(e2)local dH=e4*ai*ai;return dD(d_,dF,dG,e5,dH)end;b7.isMapPosition=dm;function b7:getPlanetarySystem(dK)if i==nil then i=0 end;if nv==nil then nv=0 end;local d_=dK;if dm(dK)then d_=dK.systemId end;if type(d_)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dL then system=dQ(system)end;return system end end end;function dL:castIntersections(e6,cS,e7,e8)local e7=e7 or function(e9)return 1.05*e9.radius end;local ea={}if e8 then for _,i in ipairs(e8)do ea[i]=self[i]end else e8={}for da,e9 in pairs(self)do table.insert(e8,da)ea[da]=e9 end end;local function eb(ec,ed)local ee=ea[ec].center-e6;local ef=ea[ed].center-e6;return ee:len()<ef:len()end;table.sort(e8,eb)local eg=cS:normalize()for i,dS in ipairs(e8)do local e9=ea[dS]local eh=e9.center-e6;local dG=e7(e9)local ei=eh:dot(eg)local ej=ei^2-(eh:len2()-dG^2)if ej>=0 then local ek=math.sqrt(ej)local el=ei+ek;local em=ei-ek;if em>0 then return e9,el,em elseif el>0 then return e9,el,nil end end end;return nil,nil,nil end;function dL:closestBody(ct)assert(type(ct)=='table','Invalid coordinates.')local en,e9;local eo=vec3(ct)for _,ep in pairs(self)do local eq=(ep.center-eo):len2()if(not e9 or eq<en)and ep.name~="Space"then e9=ep;en=eq end end;return e9 end;function dL:convertToBodyIdAndWorldCoordinates(dK)local er=dK;if dj(dK)then er=dJ(dK)end;if er.bodyId==0 then return 0,vec3(er.latitude,er.longitude,er.altitude)end;local ep=self:getBodyParameters(er)if ep then return er.bodyId,ep:convertToWorldCoordinates(er)end end;function dL:getBodyParameters(dK)local dF=dK;if dm(dK)then dF=dK.bodyId end;assert(dg(dF),'Argument 1 (bodyId) must be a number:'..type(dF))return self[dF]end;function dL:getPlanetarySystemId()local _,db=next(self)return db and db.planetarySystemId end;function dy:convertToMapPosition(cw)assert(dh(cw),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cw))local cx=vec3(cw)if self.bodyId==0 then return setmetatable({latitude=cx.x,longitude=cx.y,altitude=cx.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local cy=cx-self.center;local ai=cy:len()local cz=ai-self.radius;local cA=0;local cB=0;if not cg(ai,0)then local cC=n(cy.y,cy.x)cB=cC>=0 and cC or 2*math.pi+cC;cA=math.pi/2-math.acos(cy.z/ai)end;return setmetatable({latitude=cA,longitude=cB,altitude=cz,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dy:convertToWorldCoordinates(dK)local er=dj(dK)and dJ(dK)or dK;if er.bodyId==0 then return vec3(er.latitude,er.longitude,er.altitude)end;assert(dm(er),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(er.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(er.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local es=math.cos(er.latitude)return self.center+(self.radius+er.altitude)*vec3(es*math.cos(er.longitude),es*math.sin(er.longitude),math.sin(er.latitude))end;function dy:getAltitude(cw)return(vec3(cw)-self.center):len()-self.radius end;function dy:getDistance(cw)return(vec3(cw)-self.center):len()end;function dy:getGravity(cw)local et=self.center-vec3(cw)local eu=et:len2()return self.GM/eu*et/math.sqrt(eu)end;return setmetatable(b7,{__call=function(_,...)return dU(...)end})end;local function ev()local b9={}local ew=30000000/3600;local ex=ew*ew;local ey=100;local function ez(db)return 1/math.sqrt(1-db*db/ex)end;function b9.computeAccelerationTime(eA,eB,eC)local eD=ew*math.asin(eA/ew)return(ew*math.asin(eC/ew)-eD)/eB end;function b9.computeDistanceAndTime(eA,eC,eE,eF,eG,eH)eG=eG or 0;eH=eH or 0;local eI=eA<=eC;local eJ=eF*(eI and 1 or-1)/eE;local eK=-eH/eE;local eL=eJ+eK;if eI and eL<=0 or not eI and eL>=0 then return-1,-1 end;local eM,eN=0,0;if eJ~=0 and eG>0 then local eD=math.asin(eA/ew)local eO=math.pi*(eJ/2+eK)local eP=eJ*eG;local eQ=ew*math.pi;local db=function(di)local eR=(eO*di-eP*math.sin(math.pi*di/2/eG)+eQ*eD)/eQ;local eS=math.tan(eR)return ew*eS/math.sqrt(eS*eS+1)end;local eT=eI and function(dk)return dk>=eC end or function(dk)return dk<=eC end;eN=2*eG;if eT(db(eN))then local eU=0;while c(eN-eU)>0.5 do local di=(eN+eU)/2;if eT(db(di))then eN=di else eU=di end end end;local eV=eA;local eW=eN/ey;for eX=1,ey do local eY=db(eX*eW)eM=eM+(eY+eV)*eW/2;eV=eY end;if eN<2*eG then return eM,eN end;eA=eV end;local eD=ew*math.asin(eA/ew)local bE=(ew*math.asin(eC/ew)-eD)/eL;local eZ=ex*math.cos(eD/ew)/eL;local ai=eZ-ex*math.cos((eL*bE+eD)/ew)/eL;return ai+eM,bE+eN end;function b9.computeTravelTime(eA,eB,ai)if ai==0 then return 0 end;if eB>0 then local eD=ew*math.asin(eA/ew)local eZ=ex*math.cos(eD/ew)/eB;return(ew*math.acos(eB*(eZ-ai)/ex)-eD)/eB end;if eA==0 then return-1 end;assert(eA>0,'Acceleration and initial speed are both zero.')return ai/eA end;function b9.lorentz(db)return ez(db)end;return b9 end;local function e_()local vec3=require('cpml.vec3')local dd=dd()local function dj(dk)return type(dk)=='string'end;local function dh(di)return type(di)=='table'end;local function cg(ch,ci)if ch==0 then return c(ci)<1e-09 end;if ci==0 then return c(ch)<1e-09 end;return c(ch-ci)<math.max(c(ch),c(ci))*constants.epsilon end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cz)assert(self.body)local ai=cz+self.body.radius;if not cg(ai,0)then local orbit=math.sqrt(self.body.GM/ai)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dK,f0)assert(self.body)assert(dh(dK)or dj(dK))assert(dh(f0))local f1=(dj(dK)or dd.isMapPosition(dK))and self.body:convertToWorldCoordinates(dK)or vec3(dK)local db=vec3(f0)local f2=f1-self.body.center;local ef=db:len2()local f3=f2:len()local f4=self.body.GM;local f5=((ef-f4/f3)*f2-f2:dot(db)*db)/f4;local ch=f4/(2*f4/f3-ef)local f6=f5:len()local eg=f5:normalize()local f7=ch*(1-f6)local f8=ch*(1+f6)local f9=f7*eg+self.body.center;local fa=f6<=1 and-f8*eg+self.body.center or nil;local fb=math.sqrt(ch*f4*(1-f6*f6))local fc=fa and 2*math.pi*math.sqrt(ch^3/f4)local fd=math.acos(f5:dot(f2)/(f6*f3))if f2:dot(db)<0 then fd=-(fd-2*math.pi)end;local fe=math.acos((math.cos(fd)+f6)/(1+f6*math.cos(fd)))local ff=fe;if ff<0 then ff=ff+2*math.pi end;local fg=ff-f6*math.sin(ff)local fh=0;local fi=0;local fj=0;if fc~=nil then fh=fg/(2*math.pi/fc)fi=fc-fh;fj=fi+fc/2;if fd-math.pi>0 then fi=fh;fj=fi+fc/2 end;if fj>fc then fj=fj-fc end end;return{periapsis={position=f9,speed=fb/f7,circularOrbitSpeed=math.sqrt(f4/f7),altitude=f7-self.body.radius},apoapsis=fa and{position=fa,speed=fb/f8,circularOrbitSpeed=math.sqrt(f4/f8),altitude=f8-self.body.radius},currentVelocity=db,currentPosition=f1,eccentricity=f6,period=fc,eccentricAnomaly=fe,meanAnomaly=fg,timeToPeriapsis=fi,timeToApoapsis=fj}end;local function fk(fl)local ep=dd.BodyParameters(fl.planetarySystemId,fl.bodyId,fl.radius,fl.center,fl.GM)return setmetatable({body=ep},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return fk(...)end})end;local function fm()local fn=false;local fo=0;local function fp(fq)local dG=500000;local fr,fs,ft=math.huge;local fu=false;local fv=vec3({13771471,7435803,-128971})local fw=18000000;fr=vec3(fq):dist(fv)if fr<fw then return true,c(fr-fw),"Safe Zone",0 end;fs=vec3(fq):dist(vec3(planet.center))if fs<dG then fu=true end;if c(fs-dG)<c(fr-fw)then return fu,c(fs-dG),planet.name,planet.bodyId else return fu,c(fr-fw),"Safe Zone",0 end end;local function fx(db)if aK==1920 then return db else return y(aK*db/1920,0)end end;local function fy(db)if aL==1080 then return db else return y(aL*db/1080,0)end end;local function fz()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function fA()local fB="TRAVEL"if not bQ then fB="CRUISE"end;if Autopilot then fB="AUTOPILOT"end;return fB end;local function fC(fD,b1,c7,fE,fF,fG,fH,fI)local fJ=1;local fK=2;local fL=3;local fM=4;local fN=5;local fO=6;local fP=""local fQ=0;local fR=fuelY;local fS=fuelY+10;if m()==1 and not RemoteHud then fR=fR-50;fS=fS-50 end;if fF=="ATMO"then fP="atmofueltank"elseif fF=="SPACE"then fP="spacefueltank"else fP="rocketfueltank"end;fQ=_G[fP.."_size"]if#fG>0 then for i=1,#fG do local fT=string.sub(fG[i][fK],1,12)local fU=0;for fV=1,fQ do if fG[i][fK]==f(unit[fP.."_"..fV].getData()).name then fU=fV;break end end;if b1 or fH[i]==nil or fI[i]==nil then local fW=0;local fX=0;local fY=0;local fZ=0;local f_=q()if fU~=0 then fI[i]=f(unit[fP.."_"..fU].getData()).percentage;fH[i]=f(unit[fP.."_"..fU].getData()).timeLeft;if fH[i]=="n/a"then fH[i]=0 end else fY=k(fG[i][fJ])-fG[i][fM]fW=fG[i][fL]fI[i]=d(0.5+fY*100/fW)fX=fG[i][fN]fZ=fG[i][fO]if fX<=fY then fH[i]=0 else fH[i]=d(0.5+fY/((fX-fY)/(f_-fZ)))end;fG[i][fN]=fY;fG[i][fO]=f_ end end;if fT==fE then fT=e("%s %d",fF,i)end;if fU==0 then fT=fT.." *"end;local g0;if fH[i]==0 then g0="n/a"else g0=d1(fH[i])end;if fI[i]~=nil then local g1=d(fI[i]*2.55)local g2=e("rgb(%d,%d,%d)",255-g1,g1,0)local ca=""if g0~="n/a"and fH[i]<120 or fI[i]<5 then if b1 then ca=[[class="red"]]end end;fD[#fD+1]=c6(c7,fR,fT,ca.." pdim txtfuel")fD[#fD+1]=c6(c7,fS,e("%d%% %s",fI[i],g0),"pdim txtfuel","fill:"..g2)fR=fR+30;fS=fS+30 end end end end;local function g3(fD,cz)if cz<200000 and not as or cz and as then local g4=0;if c(bL)>1 then g4=45*math.log(c(bL),10)if bL<0 then g4=-g4 end end;fD[#fD+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bL),d(g4))end;return fD end;local function g5(g6)local g7=-bK;g6=g6-g6:project_on(g7)local g8=vec3(0,0,1)g8=g8-g8:project_on(g7)local g9=g8:cross(g7)local g4=g8:angle_between(g6)*constants.rad2deg;if g6:dot(g9)<0 then g4=360-g4 end;return g4 end;local function ga(fD,centerX,centerY,gb,gc,cG)local gd=circleRad;local ge=20;local gf=d(gb)if cG then for i=-45,45,5 do local gg=i;fD[#fD+1]=e([[<g transform="rotate(%f,%d,%d)">]],gg,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fD[#fD+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gd+ge-len,centerX,centerY+gd+ge)end;fD[#fD+1]=c6(centerX,centerY+gd+ge-35,gc,"pdim txt txtmid")fD[#fD+1]=c6(centerX,centerY+gd+ge-25,gf.." deg","pdim txt txtmid")fD[#fD+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gb,centerX,centerY)fD[#fD+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gd+ge-20,centerX+5,centerY+gd+ge-20,centerX,centerY+gd+ge-15)fD[#fD+1]="</g>"end;local gh=gf;if cG then gh=g5(bG)end;local gi=20;local gj=d(gh)local gk=0;local gl=centerY+gd+ge+20;local gm=centerX;if gc~="YAW"then gl=fy(130)gm=fx(960)end;local gn=[[<path class="txttick line" d="]]for i=d(gj-(gi+10)-gj%5+0.5),d(gj+gi+10+gj%5+0.5),5 do local c7=gm+-i*5+gh*5;if i%10==0 then gk=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;fD[#fD+1]=c6(c7+5,gl-12,z)elseif i%5==0 then gk=5 end;if gk==10 then gn=e([[%s M %f %f v %d]],gn,c7,gl-5,gk)else gn=e([[%s M %f %f v %d]],gn,c7,gl-2.5,gk)end end;fD[#fD+1]=gn..[["/>]]fD[#fD+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],gm-5,gl+10,gm+5,gl+10,gm,gl+5)if cG then gc="HDG"end;fD[#fD+1]=c6(gm,gl+25,gj.."deg","pdim txt txtmid","")fD[#fD+1]=c6(gm,gl+35,gc,"pdim txt txtmid","")end;local function go(fD,gp,gb,centerX,centerY,cG,gq,eY)local gd=circleRad;local gr=d(gd*3/5)if gd>0 then local gs=d(gp)local len=0;local gn=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gb,centerX,centerY)if not as then gn=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fD[#fD+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gd-1,centerX,centerY)fD[#fD+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gs-30-gs%5+0.5),d(gs+30+gs%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local c8=centerY+-i*5+gp*5;if len==30 then gn=e([[%s M %d %f h %d]],gn,centerX-gr-len,c8,len)if as then fD[#fD+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gb,centerX,centerY,centerX-gr+10,c8,i)fD[#fD+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gb,centerX,centerY,centerX+gr-10,c8,i)if i==0 or i==180 or i==-180 then fD[#fD+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gb,centerX,centerY,centerX-gr+20,c8,gr*2-40)end else fD[#fD+1]=c6(centerX-gr+10,c8,i,"pdim txt txtmid")fD[#fD+1]=c6(centerX+gr-10,c8,i,"pdim txt txtmid")end;gn=e([[%s M %d %f h %d]],gn,centerX+gr,c8,len)else gn=e([[%s M %d %f h %d]],gn,centerX-gr-len,c8,len)gn=e([[%s M %d %f h %d]],gn,centerX+gr,c8,len)end end;fD[#fD+1]=gn..[["/>]]local gt="PITCH"if not cG then gt="REL PITCH"end;if gp>90 and not as then gp=90-(gp-90)elseif gp<-90 and not as then gp=-90-(gp+90)end;if gd>200 then if as then if eY>O then fD[#fD+1]=c6(centerX,centerY-15,"Yaw","pdim txt txtmid")fD[#fD+1]=c6(centerX,centerY+20,gq,"pdim txt txtmid")end;fD[#fD+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gb,centerX,centerY)else fD[#fD+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fD[#fD+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gr+25,centerY-5,centerX-gr+20,centerY,centerX-gr+25,centerY+5,centerX-gr+50,centerY+4,gs)fD[#fD+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gr-25,centerY-5,centerX+gr-20,centerY,centerX+gr-25,centerY+5,centerX+gr-30,centerY+4,gs)fD[#fD+1]="</g>"end;local gu=d(gd/3)fD[#fD+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gu,centerY,gd-gu)if not as and cG then fD[#fD+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gb,centerX,centerY,centerX-gr+10,centerY,gr*2-20)end;fD[#fD+1]="</g>"if gd<200 then if as and eY>O then fD[#fD+1]=c6(centerX,centerY-gd,gt,"pdim txt txtmid")fD[#fD+1]=c6(centerX,centerY-gd+10,gs,"pdim txt txtmid")fD[#fD+1]=c6(centerX,centerY-15,"Yaw","pdim txt txtmid")fD[#fD+1]=c6(centerX,centerY+20,gq,"pdim txt txtmid")else fD[#fD+1]=c6(centerX,centerY-gd,gt,"pdim txt txtmid")fD[#fD+1]=c6(centerX,centerY-gd+15,gs,"pdim txt txtmid")end end end end;local function gv(fD,cz,cG)local gw=altMeterX;local gx=altMeterY;local gy=78;local gz=19;local gA=ap;if ap~=-1 then fD[#fD+1]=c6(gw+gy,gx+gz+20,e("AGL: %.1fm",ap),"pdim altsm txtend")end;if cG and(cz<200000 and not as or cz and as)then table.insert(fD,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gw-1,gx-4,gy+2,gz+6,gw+1,gx-1,gy-4,gz))local cJ=0;local gB=1;local gC=0;local gD=cz<0;local gE=9;if gD then gE=0 end;local cz=c(cz)while cJ<6 do local gF=11;local gG=16;local gH=9;local gI=14;local ca="altsm"if cJ>2 then gG=gG+3;gF=gF+2;gI=gI+2;gH=gH-6;ca="altbig"end;if gD then ca=ca.." red"end;local gJ=cz/gB%10;local gK=d(gJ)local gL=d((gK+1)%10)local gM=gC;if cJ==0 then gM=gJ-gK;if gD then gM=1-gM end end;if gD and(cJ==0 or gC~=0)then local gN=gL;gL=gK;gK=gN end;local gO=gG*(gM-1)local gP=gO+gG;local c7=gw+gH+(6-cJ)*gF;local c8=gx+gI;fD[#fD+1]=c6(c7,c8+gO,gL,ca)fD[#fD+1]=c6(c7,c8+gP,gK,ca)cJ=cJ+1;gB=gB*10;if gK==gE then gC=gM else gC=0 end end;table.insert(fD,[[</g></g>]])end end;local function gQ(f0)f0=vec3(f0)local gR=-math.deg(n(f0.y,f0.z))+180;gR=gR-90;if gR<0 then gR=360+gR end;if gR>180 then gR=-180+gR-180 end;return-gR end;local function gS(f0)f0=vec3(f0)local gh=math.deg(n(f0.y,f0.x))-90;if gh<-180 then gh=360+gh end;return gh end;local function gT(fD,f0,eY,centerX,centerY)if eY>5 and not as or eY>O then local gd=circleRad;local gU=20;local gV=20;local gW=vec3(f0)local gX=gQ(gW)local gY=gS(gW)local gZ=14;local g_=gZ/2;local h0=-gY/gV*gd;local h1=gX/gU*gd;local c7=centerX+h0;local c8=centerY+h1;local ai=math.sqrt(h0^2+h1^2)local h2=[[<circle
                            cx="]]..c7 ..[["
                            cy="]]..c8 ..[["
                            r="]]..g_/gZ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c7 ..[["
                            cy="]]..c8 ..[["
                            r="]]..g_..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c7-gZ..[[,]]..c8 ..[[ h ]]..g_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c7+g_..[[,]]..c8 ..[[ h ]]..g_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c7 ..[[,]]..c8-gZ..[[ v ]]..g_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ai<gd then fD[#fD+1]=h2 else local g4=n(h1,h0)local h3=4;local h4=centerX+gd*math.cos(g4)local h5=centerY+gd*math.sin(g4)fD[#fD+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',g4*180/math.pi,h4,h5,h4-h3,h5-h3/2,h3*2,h3,h4+h3,h5-h3,h3,h3,-h3,h3)end;if not as then gX=gQ(-gW)gY=gS(-gW)h0=-gY/gV*gd;h1=gX/gU*gd;c7=centerX+h0;c8=centerY+h1;ai=math.sqrt(h0^2+h1^2)if ai<gd then local h6=[[<circle
                                    cx="]]..c7 ..[["
                                    cy="]]..c8 ..[["
                                    r="]]..g_..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c7 ..[[,]]..c8-gZ..[[ v ]]..g_..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c7 ..[[,]]..c8 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c7 ..[[,]]..c8 ..[[)" />
                                <path
                                    d="M ]]..c7-g_..[[,]]..c8 ..[[ h ]]..gZ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c7 ..[[,]]..c8 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c7 ..[[,]]..c8 ..[[)"/>]]fD[#fD+1]=h6 end end end end;local function h7(fD,fB,h8,h9)h8=d(h8+0.5)local fR=throtPosY+10;local fS=throtPosY+20;if m()==1 and not RemoteHud then fR=55;fS=65 end;local ha="CRUISE"local unit="km/h"local cd=h9;if fB=="TRAVEL"or fB=="AUTOPILOT"then ha="THROT"unit="%"cd=h8;local hb="dim"if h8<0 then hb="red"end;fD[#fD+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hb,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(h8),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fD[#fD+1]=c6(throtPosX+10,fR,ha,"pbright txtstart")fD[#fD+1]=c6(throtPosX+10,fS,e("%.0f %s",cd,unit),"pbright txtstart")if as and AtmoSpeedAssist and bQ and I then h8=d(J*100+0.5)local hb="red"if h8<0 then hb="red"end;fD[#fD+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hb,1-c(h8),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fD[#fD+1]=c6(throtPosX+10,fR+40,"LIMIT","pbright txtstart")fD[#fD+1]=c6(throtPosX+10,fS+40,h8 .."%","pbright txtstart")end;if as and AtmoSpeedAssist or Reentry then fD[#fD+1]=c6(throtPosX+10,fR-40,"LIMIT: "..bo.." km/h","dim txtstart")elseif not as and Autopilot then fD[#fD+1]=c6(throtPosX+10,fR-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hc(fD,hd)local he=throtPosY-10;local hf=throtPosX+10;fD[#fD+1]=c6(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then he=75 end;fD[#fD+1]=c6(hf,he,d(hd).." km/h","pbright txtbig txtstart")end;local function hg(fD)fD[#fD+1]=c6(fx(1900),fy(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fD[#fD+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fD[#fD+1]=c6(fx(960),fy(550),"Warning: Invalid Control Scheme Detected","warnings")fD[#fD+1]=c6(fx(960),fy(600),"Keyboard Scheme must be selected","warnings")fD[#fD+1]=c6(fx(960),fy(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hh=fx(960)local hi=fy(860)local hj=fy(880)local hk=fy(900)local hl=fy(960)local hm=fy(200)local hn=fy(150)local ho=fy(960)if m()==1 and not RemoteHud then hi=fy(135)hj=fy(155)hk=fy(175)hm=fy(115)hn=fy(95)end;if BrakeIsOn then fD[#fD+1]=c6(hh,hi,"Brake Engaged","warnings")elseif H>0 then fD[#fD+1]=c6(hh,hi,"Auto-Brake Engaged","warnings","opacity:"..H)end;if as and bj and ap==-1 then fD[#fD+1]=c6(hh,hm+50,"** STALL WARNING **","warnings")end;if ay then fD[#fD+1]=c6(hh,ho,"Gyro Enabled","warnings")end;if GearExtended then if Q then fD[#fD+1]=c6(hh,hj,"Gear Extended","warn")else fD[#fD+1]=c6(hh,hj,"Landed (G: Takeoff)","warnings")end;local hp,cn=cj(a:getTargetGroundAltitude())fD[#fD+1]=c6(hh,hk,"Hover Height: "..hp..cn,"warn")end;if a5 then fD[#fD+1]=c6(hh,hl+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bO and AntigravTargetAltitude~=nil then if c(au-antigrav.getBaseAltitude())<501 then fD[#fD+1]=c6(hh,hm+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fD[#fD+1]=c6(hh,hm+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fD[#fD+1]=c6(hh,hm+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fD[#fD+1]=c6(hh,hm+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Y then fD[#fD+1]=c6(hh,hm+20,"Follow Mode Engaged","warn")elseif Reentry then fD[#fD+1]=c6(hh,hm+20,"Re-entry in Progress","warn")end;local hq,el,em=b8:getPlanetarySystem(0):castIntersections(bM,bI:normalize(),function(e9)if e9.noAtmosphericDensityAltitude>0 then return e9.radius+e9.noAtmosphericDensityAltitude else return e9.radius+e9.surfaceMaxAltitude*1.5 end end)local hr=el;if em~=nil and el~=nil then hr=math.min(em,el)end;if AltitudeHold or VertTakeOff then local hp,cn=cj(HoldAltitude,2)if VertTakeOff then if bO then hp,cn=cj(antigrav.getBaseAltitude(),2)end;fD[#fD+1]=c6(hh,hm,"AGG VTO to "..hp..cn,"warn")elseif AutoTakeoff and not IntoOrbit then fD[#fD+1]=c6(hh,hm,"Takeoff to "..hp..cn,"warn")if BrakeIsOn and not VertTakeOff then fD[#fD+1]=c6(hh,hm+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fD[#fD+1]=c6(hh,hm,"Altitude Hold: "..hp..cn,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if at>0.1 then fD[#fD+1]=c6(hh,hm+20,"Beginning ascent","warn")elseif at<0.09 and at>0.05 then fD[#fD+1]=c6(hh,hm+20,"Aligning trajectory","warn")elseif at<0.05 then fD[#fD+1]=c6(hh,hm+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bq~=nil then fD[#fD+1]=c6(hh,hm,bq,"warn")end end;if BrakeLanding then if StrongBrakes then fD[#fD+1]=c6(hh,hm,"Brake-Landing","warnings")else fD[#fD+1]=c6(hh,hm,"Coast-Landing","warnings")end end;if ProgradeIsOn then fD[#fD+1]=c6(hh,hm,"Prograde Alignment","crit")end;if RetrogradeIsOn then fD[#fD+1]=c6(hh,hm,"Retrograde Alignment","crit")end;if hr~=nil and at==0 then local hp,cn=cj(hr)local travelTime=b9.computeTravelTime(bJ,0,hr)local hs="Collision"if hq.noAtmosphericDensityAltitude>0 then hs="Atmosphere"end;fD[#fD+1]=c6(hh,hn,hq.name.." "..hs.." "..d1(travelTime).." In "..hp..cn,"crit")end;if VectorToTarget and not IntoOrbit then fD[#fD+1]=c6(hh,hm+35,VectorStatus,"warn")end;fD[#fD+1]="</g>"return fD end;local function ht(eY)return d(y(eY*3.6,0)+0.5).." km/h"end;local function hu(fD)local hv=OrbitMapX;local hw=OrbitMapY;local hx=OrbitMapSize;local hy=4;local hz=15;local c7=0;local c8=0;local hA,hB,hC,hD;local function hE(type)local hF,bE,eY,hG;if type=="Periapsis"then hF=orbit.periapsis.altitude;bE=orbit.timeToPeriapsis;eY=orbit.periapsis.speed;hG=35 else hF=orbit.apoapsis.altitude;bE=orbit.timeToApoapsis;eY=orbit.apoapsis.speed;hG=-35 end;fD[#fD+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c7+hG,c8-5,hv+hx/2-hA+hD,c8-5)fD[#fD+1]=c6(c7,c8,type)c8=c8+hz;local hp,cn=cj(hF)fD[#fD+1]=c6(c7,c8,hp..cn)c8=c8+hz;fD[#fD+1]=c6(c7,c8,d1(bE))c8=c8+hz;fD[#fD+1]=c6(c7,c8,ht(eY))end;if orbit~=nil and at<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hw=hw+hy;c7=hv+hx+hv/2+hy;c8=hw+hx/2+5+hy;hA=hx/4;hD=0;fD[#fD+1]=[[<g class="pbright txtorb txtmid">]]fD[#fD+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hx+hv*2,hx+hw,hy,hy)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hC=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hA*2)hB=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hC*(1-orbit.eccentricity)hD=hA-orbit.periapsis.altitude/hC-planet.radius/hC;local hH=""if orbit.periapsis.altitude<=0 then hH='redout'end;fD[#fD+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hH,hv+hx/2+hD+hy,hw+hx/2+hy,hA,hB)fD[#fD+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hv+hx/2+hy,hw+hx/2+hy,planet.radius/hC)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hE("Apoapsis")end;c8=hw+hx/2+5+hy;c7=hv-hv/2+10+hy;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hE("Periapsis")end;fD[#fD+1]=c6(hv+hx/2+hy,planet.name,20+hy,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hI=orbit.timeToApoapsis/orbit.period*2*math.pi;local hJ=hA*math.cos(hI)local hK=hB*math.sin(hI)fD[#fD+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hv+hx/2+hJ+hD+hy,hw+hx/2+hK+hy)end;fD[#fD+1]=[[</g>]]return fD else return fD end end;local function hL()if radarPanelID~=nil and al==0 then t(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then t(perisPanelID)perisPanelID=nil end else if al==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;al=0 end end;local function hM(fD)local c7=50;local c8=525;local hN={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hO={"Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to +1k over atmosphere and orbit to target","Alt-5: Lock Pitch at current pitch","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-9: Activate Gyroscope"}local hP={"Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at 1k over atmosphere","Alt-9: Activate Gyroscope"}local hQ={"CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if as then bX(hN,hO)table.insert(hN,"---------------------------------------")if VertTakeOff then table.insert(hN,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ap~=-1 then if antigrav then if bO then table.insert(hN,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hN,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hN,"Alt-6: Begins Vertical Takeoff.")else table.insert(hN,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hN,"G: Begin BrakeLanding or Land")end else bX(hN,hP)end;if AltitudeHold then table.insert(hN,"Alt-Spacebar/Alt-C will raise/lower target height")end;table.insert(hN,"---------------------------------------")bX(hN,hQ)for i=1,#hN do c8=c8+12;fD[#fD+1]=c6(c7,c8,hN[i],"pdim txttick txtstart")end end;local hR={}function hR.HUDPrologue(fD)if not fn then D=PvPR;F=PvPG;E=PvPB else D=SafeR;F=SafeG;E=SafeB end;aA=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]aB=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]local hS=aA;local hT=aB;local hU=aA;local hV=aB;if fz()and not brightHud then hS=[[rgb(]]..d(D*0.4+0.5)..","..d(F*0.4+0.5)..","..d(E*0.3+0.5)..[[)]]hT=[[rgb(]]..d(D*0.3+0.5)..","..d(F*0.3+0.5)..","..d(E*0.2+0.5)..[[)]]end;fD[#fD+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],hS,hS,hU,hU,hT,hT,hV,hV,aK,aL)return fD end;function hR.UpdateHud(fD)local cz=au;local f0=core.getVelocity()local eY=vec3(f0):len()local gR=bR;local hW=bS;local gb=hW;local gp=bR;local h8=d(unit.getThrottle())local hd=eY*3.6;local h9=unit.getAxisCommandValue(0)local hX=fx(1770)local hY=fy(310)if AtmoSpeedAssist and bQ then h9=G;h8=G*100 end;local fB=fA()local gc="ROLL"local cG=unit.getClosestPlanetInfluence()>0;if h8==nil then h8=0 end;if not cG then if eY>5 then gR=gQ(f0)hW=gS(f0)else gR=0;hW=0 end;gc="YAW"end;if not as then fn,fo,_,_=fp(bM)else fn=true end;if fo>50000 and not as then local hZ;if fo>200000 then hZ=y(fo/200000,2).." su"else hZ=y(fo/1000,1).." km"end;fD[#fD+1]=c6(hX,hY,"PvP Boundary: "..hZ,"pbright txtbig txtmid")end;fD[#fD+1]=ak;fD[#fD+1]=aF;fD[#fD+1]=aj;if b2%aX==0 then b1=true end;if fuelX~=0 and fuelY~=0 then fC(fD,b1,fuelX,"Atmospheric ","ATMO",aQ,a_,b0)fC(fD,b1,fuelX+100,"Space fuel t","SPACE",aR,aY,aZ)fC(fD,b1,fuelX+200,"Rocket fuel ","ROCKET",aS,aV,aW)end;if b1 then b1=false;b2=0 end;b2=b2+1;g3(fD,cz)if m()==0 or RemoteHud then if not fz()or brightHud then if cG then ga(fD,centerX,centerY,gb,gc,cG)go(fD,gp,gb,centerX,centerY,cG,d(gS(f0)),eY)else ga(fD,centerX,centerY,hW,gc,cG)go(fD,gR,hW,centerX,centerY,cG,d(hW),eY)end;gv(fD,cz,cG)gT(fD,f0,eY,centerX,centerY)end end;h7(fD,fB,h8,h9)hc(fD,hd)hg(fD)hu(fD)if showHelp then hM(fD)end;return fD end;function hR.HUDEpilogue(fD)fD[#fD+1]="</svg>"return fD end;function hR.ExtraData(fD)local h_=fx(1240)local i0=fy(55)local i1=i0+10;local i2;local i3=0;local fB=fA()if VertTakeOffEngine then fB=fB.."-VERTICAL"end;if TurnBurn then fB="TB-"..fB end;local i4=vec3(core.getWorldAcceleration()):len()/9.80665;i2=core.g()fD[#fD+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then h_=fx(1120)i0=fy(55)i1=i0+10 elseif as then local i5=fx(770)fD[#fD+1]=c6(i5,i0,"ATMOSPHERE","pdim txt txtend")fD[#fD+1]=c6(i5,i1,e("%.2f",at),"pdim txt txtend","")end;fD[#fD+1]=c6(h_,i0,"GRAVITY","pdim txt txtend")fD[#fD+1]=c6(h_,i1,e("%.2f",i2/9.80665),"pdim txt txtend")fD[#fD+1]=c6(h_,i0+20,"ACCEL","pdim txt txtend")fD[#fD+1]=c6(h_,i1+20,e("%.2f",i4),"pdim txt txtend")fD[#fD+1]=c6(fx(960),fy(180),fB,"txtbig txtmid")end;function hR.DrawOdometer(fD,ab,TotalDistanceTravelled,ac)local i2;local i6=0;local i7=0;local i3=0;if as then i3=LastMaxBrakeInAtmo else i3=LastMaxBrake end;maxThrust=a:maxForceForward()aO=l()i2=core.g()if i2>0.1 then i7=aO*i2;i6=maxThrust/i2 end;fD[#fD+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fx(660),fx(700),fy(35),fx(960),fy(55),fx(1240),fy(35),fx(1280))if m()==0 or RemoteHud then fD[#fD+1]=c6(fx(700),fy(20),e("Trip: %.2f km",ab),"txtstart")fD[#fD+1]=c6(fx(700),fy(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fD[#fD+1]=c6(fx(830),fy(20),"Trip Time: "..d1(ac),"txtstart")fD[#fD+1]=c6(fx(830),fy(30),"Total Time: "..d1(TotalFlightTime),"txtstart")fD[#fD+1]=c6(fx(970),fy(20),e("Mass: %.2f Tons",aO/1000),"txtstart")fD[#fD+1]=c6(fx(1240),fy(10),e("Max Brake: %.2f kN",i3/1000),"txtend")fD[#fD+1]=c6(fx(1240),fy(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if i2>0.1 then fD[#fD+1]=c6(fx(970),fy(30),e("Max Mass: %.2f Tons",i6/1000),"txtstart")fD[#fD+1]=c6(fx(1240),fy(20),e("Req Thrust: %.2f kN",i7/1000),"txtend")else fD[#fD+1]=c6(fx(970),fy(30),"Max Mass: n/a","txtstart")fD[#fD+1]=c6(fx(1240),fy(20),"Req Thrust: n/a","txtend")end end;fD[#fD+1]="</g>"return fD end;function hR.DrawWarnings(fD)return hg(fD)end;function hR.DisplayOrbitScreen(fD)return hu(fD)end;function hR.DisplayMessage(fD,hp)if hp~="empty"then local c8=310;for i8 in string.gmatch(hp,"([^\n]+)")do c8=c8+35;fD[#fD+1]=c6("50%",c8,i8,"msg")end end;if ah~=0 then unit.setTimer("msgTick",ah)ah=0 end end;function hR.DrawDeadZone(fD)fD[#fD+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function hR.UpdateRadar()if radar_1 then local i9=radar_1.getEntries()local ia=radar_1.getData()local ib=fx(1770)local ic=fy(330)if#i9>0 then local id=ia:find('identifiedConstructs":%[%]')if id==nil and perisPanelID==nil then al=1;hL()end;if id~=nil and perisPanelID~=nil then hL()end;if radarPanelID==nil then hL()end;aj=c6(ib,ic,"Radar: "..#i9 .." contacts","pbright txtbig txtmid")local ie={}for da,db in pairs(i9)do if radar_1.hasMatchingTransponder(db)==1 then table.insert(ie,db)end end;if#ie>0 then local c8=fy(15)local c7=fx(1370)aj=aj..c6(c7,c8,"Friendlies In Range","pbright txtbig txtmid")for da,db in pairs(ie)do c8=c8+20;aj=aj..c6(c7,c8,radar_1.getConstructName(db),"pdim txtmid")end end else local ig;ig=ia:find('worksInEnvironment":false')if ig then aj=c6(ib,ic,"Radar: Jammed","pbright txtbig txtmid")else aj=c6(ib,ic,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then al=0;hL()end end end end;function hR.DrawSettings(fD)if#bU>0 then local c7=fx(640)local c8=fy(200)fD[#fD+1]=[[<g class="pbright txtvspd txtstart">]]for da,db in pairs(bU)do fD[#fD+1]=c6(c7,c8,db..": ".._G[db])c8=c8+20;if da%12==0 then c7=c7+fx(350)c8=fy(200)end end;fD[#fD+1]=c6(fx(640),fy(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fD[#fD+1]="</g>"end;return fD end;return hR end;local function ih()local function ii()local function ij(ik,il)return ik.name<il.name end;bW={}for da,db in pairs(b3[0])do bW[#bW+1]={name=db.name,index=da}end;table.sort(bW,ij)end;local dc={}function dc.UpdateAtlasLocationsList()ii()end;function dc.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"aa=nil;CustomTarget=nil;return true end;local im=bW[AutopilotTargetIndex].index;local io=b3[0][im]if io.center then AutopilotTargetName=io.name;aa=b8[0][im]if CustomTarget~=nil then if at==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=io;for _,db in pairs(b8[0])do if db.name==CustomTarget.planetname then aa=db;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(aa.center)else AutopilotTargetCoords=CustomTarget.position end;if aa.planetname~="Space"then if aa.hasAtmosphere then AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=bb(aa):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function dc.adjustAutopilotTargetIndex(g7)if not Autopilot and not VectorToTarget and not an and not IntoOrbit then if g7==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bW then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bW end end;if AutopilotTargetIndex==0 then bd.UpdateAutopilotTarget()else local im=bW[AutopilotTargetIndex].index;local io=b3[0][im]if io.name=="Space"then if g7==nil then bd.adjustAutopilotTargetIndex()else bd.adjustAutopilotTargetIndex(1)end else bd.UpdateAutopilotTarget()end end else a0="Disengage autopilot before changing Interplanetary Helper"end end;function dc.findAtlasIndex(ip)for da,db in pairs(ip)do if db.name and db.name==CustomTarget.name then return da end end;return-1 end;for da,db in pairs(SavedLocations)do table.insert(b3[0],db)end;ii()dc.UpdateAutopilotTarget()return dc end;local function iq()local ir={}local function is(eY)local it=AutopilotEndSpeed;if not Autopilot then it=0 end;if not as then return b9.computeDistanceAndTime(eY,it,l(),0,0,LastMaxBrake-AutopilotPlanetGravity*l())else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b9.computeDistanceAndTime(eY,it,l(),0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*l())else return 0,0 end end end;local function iu(eY)local it=AutopilotEndSpeed;if not Autopilot then it=0 end;return b9.computeDistanceAndTime(eY,it,l(),a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*l())end;function ir.GetAutopilotBrakeDistanceAndTime(eY)return is(eY)end;function ir.GetAutopilotTBBrakeDistanceAndTime(eY)return iu(eY)end;local function iv(iw,ix,iy)ix=ix:project_on_plane(iw)iy=iy:project_on_plane(iw)return n(ix:cross(iy):dot(iw),ix:dot(iy))end;local function iz()local function iA()local iB=-1;local iC=-1;if vBooster then iB=vBooster.distance()end;if hover then iC=hover.distance()end;if iB~=-1 and iC~=-1 then if iB<iC then return iB else return iC end elseif iB~=-1 then return iB elseif iC~=-1 then return iC else return-1 end end;local iD=iA()local iE=-1;if telemeter_1 then iE=telemeter_1.getDistance()end;if iD~=-1 and iE~=-1 then if iD<iE then return iD else return iE end elseif iD~=-1 then return iD else return iE end end;function ir.APTick()as=j()>0;at=j()au=core.getAltitude()ap=iz()bE=q()bk=bE;if antigrav then bO=antigrav.getState()==1 end;local iF=1;local iG=1;local iH=bE-bk;local iI=-math.deg(iv(bF,bI,bG))local iJ=math.deg(iv(bH,bI,bG))local g7=bK*-1;bj=as and iI<-YawStallAngle or iI>YawStallAngle or iJ<-PitchStallAngle or iJ>PitchStallAngle;local iK=system.getMouseDeltaX()local iL=system.getMouseDeltaY()if InvertMouse and not Z then iL=-iL end;T=0;X=0;S=0;sys=b8[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=bb(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bI)if au==0 then au=(bM-planet.center):len()-planet.radius end;local i2=planet:getGravity(core.getConstructWorldPos()):len()*l()bl=0;ba=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and Z then if not bf then af=af+iK;ag=ag+iL end else af=0;ag=0 end else af=af+iK;ag=ag+iL;ai=math.sqrt(af*af+ag*ag)if not Z and m()==0 then if userControlScheme=="virtual joystick"then if af>0 and af>DeadZone then T=T-(af-DeadZone)*MouseXSensitivity elseif af<0 and af<DeadZone*-1 then T=T-(af+DeadZone)*MouseXSensitivity else T=0 end;if ag>0 and ag>DeadZone then S=S-(ag-DeadZone)*MouseYSensitivity elseif ag<0 and ag<DeadZone*-1 then S=S-(ag+DeadZone)*MouseYSensitivity else S=0 end else af=0;ag=0;if userControlScheme=="mouse"then S=(-utils.smoothstep(iL,-100,100)+0.5)*2*iF;T=(-utils.smoothstep(iK,-100,100)+0.5)*2*iG end end end end;local iM=bJ>8334;if bJ>SpaceSpeedLimit/3.6 and not as and not Autopilot and not iM then a0="Space Speed Engine Shutoff reached"cc(0)end;if not iM and LastIsWarping then if not BrakeIsOn then cM()end;if Autopilot then cE()end end;LastIsWarping=iM;if as and at>0.09 then if bJ>bo/3.6 and not AtmoSpeedAssist and not az then BrakeIsOn=true;az=true elseif not AtmoSpeedAssist and az then if bJ<bo/3.6 then BrakeIsOn=false;az=false end end end;if BrakeIsOn then W=1 else W=0 end;if ProgradeIsOn then if am then BrakeIsOn=false;local iN=false;if CustomTarget~=nil then iN=cN(CustomTarget.position-bM,0.01)else iN=cN(vec3(bI),0.01)end;bh=true;if iN and(c(bS)<2 or c(bR)>85)and bJ>=bo/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;P=true;am=false;ao=true;Autopilot=false;cZ()elseif as and AtmoSpeedAssist then cc(1)else cf(d(bo))end elseif bJ>O then cN(vec3(bI),0.01)end end;if RetrogradeIsOn then if as then RetrogradeIsOn=false elseif bJ>O then cN(-vec3(bI))end end;if not ProgradeIsOn and am and not IntoOrbit then if at==0 then P=true;cZ()am=false;ao=true else am=false;cE()end end;if ao and CustomTarget~=nil and(au<HoldAltitude+200 and au>HoldAltitude-200)and bJ*3.6>bo-100 and c(bL)<20 and at>=0.1 and(CustomTarget.position-bM):len()>2000+au then cE()ao=false end;if VertTakeOff then bh=true;local iO=HoldAltitude;if bL<-30 then a0="Unable to achieve lift. Safety Landing."ae=0;bh=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bO or HoldAltitude<planet.spaceEngineMinAltitude then if bO then iO=antigrav.getBaseAltitude()end;if au<iO-100 then bp=0;ae=15;BrakeIsOn=false elseif bL>0 then BrakeIsOn=true;ae=0 elseif bL<-30 then BrakeIsOn=true;ae=15 elseif au>=iO then if bO then if Autopilot or VectorToTarget then co()else BrakeIsOn=true;VertTakeOff=false end;a0="Takeoff complete. Singularity engaged"else BrakeIsOn=false;a0="VTO complete. Engaging Horizontal Flight"co()end;ae=0 end else if at>0.08 then bp=0;BrakeIsOn=false;ae=20 elseif at<0.08 and at>0 then BrakeIsOn=false;if bB then bp=0;ae=20 else ae=0;bp=36;cf(3500)end else bh=autoRollPreference;IntoOrbit=true;bz=false;CancelIntoOrbit=false;bt=false;br=nil;bs=nil;if by==nil then by=planet end;bx=iO;bw=true;VertTakeOff=false end end;if bp~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local iP=r(bp-bR,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(iP)local iQ=r(vTpitchPID:get(),-1,1)S=iQ end end;if IntoOrbit then local cW;local iR=false;local iS,iT=cj(bx)local iU=iS..iT;if by==nil then by=planet;if VectorToTarget then by=aa end end;if not bw then bx=math.floor(by.radius+by.surfaceMaxAltitude+LowOrbitHeight)if by.hasAtmosphere then bx=math.floor(by.radius+by.noAtmosphericDensityAltitude+LowOrbitHeight)end;bw=true end;if bv.VectorToTarget then cW=CustomTarget.position-bM end;local iV,iW=bb(by):escapeAndOrbitalSpeed((bM-by.center):len()-by.radius)local iX=bS;if not bt then local iY=false;local iZ=false;cc(0)bs=0;bq="Aligning to orbital path - OrbitHeight: "..iU;if bv.VectorToTarget then cN(cW:normalize():project_on_plane(bK))iR=bG:dot(cW:project_on_plane(bF):normalize())>0.95 else cN(bI)iR=iI<0.5;if bJ<150 then iR=true end end;S=0;br=0;if bR<=br+1 and bR>=br-1 then iY=true else iY=false end;if iX<=bs+1 and iX>=bs-1 then iZ=true else iZ=false end;if iY and iZ and iR then br=nil;bs=nil;bt=true end else if bv.VectorToTarget then cN(cW:normalize():project_on_plane(bK))elseif bJ>150 then cN(bI)end;S=0;if bv.VectorToTarget then local a6,_=b9.computeDistanceAndTime(bJ,bo/3.6,l(),0,0,LastMaxBrake)if bz and cW:len()>15000+a6+au then bq="Orbiting to Target"if orbit.periapsis.altitude<by.noAtmosphericDensityAltitude then bz=false end elseif bz or cW:len()<15000+a6+au then a0="Orbit complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;P=true;ao=true;bv.VectorToTarget,bv.AutopilotAlign=false,false;cp()cZ()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and au>bx*0.9 and au<bx*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bx*0.99 and orbit.apoapsis.altitude>=bx*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bz then if bz then BrakeIsOn=false;cc(0)br=0;if not bv.VectorToTarget then a0="Orbit complete"cp()end else bD=bD+1;if bD>=2 then bz=true end end else bq="Adjusting Orbit - OrbitHeight: "..iU;bu=true;cf(iW*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local i_=bL;local j0=au-bx;local j1=c(j0)if bL<10 and c(bR)<10 and j1<100 then i_=bL*2 end;if i_<10 and c(bR)<10 and j1<100 then i_=i_*2 end;if i_<5 and c(bR)<5 and j1<100 then i_=i_*4 end;VSpdPID:inject(i_)br=r(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(j0)br=r(br-r(OrbitAltPID:get(),-15,15),-90,90)end end else local j2=2.75;local j3=c(p(iV*j2))local j4=j3%50;if j4>0 then j3=j3-j4+50 end;BrakeIsOn=false;if au<bx*0.8 then bq="Escaping planet gravity - OrbitHeight: "..iU;br=utils.map(bL,200,0,-15,80)elseif au>=bx*0.8 and au<bx*1.15 then bq="Approaching orbital corridor - OrbitHeight: "..iU;j3=j3*0.75;br=utils.map(bL,100,-100,-15,65)elseif au>=bx*1.15 and au<bx*1.5 then bq="Approaching orbital corridor - OrbitHeight: "..iU;j3=j3*0.75;if bL<0 or bu then br=utils.map(au,bx*1.5,bx*1.01,-30,0)else br=utils.map(au,bx*0.99,bx*1.5,0,30)end elseif au>bx*1.5 then bq="Reentering orbital corridor - OrbitHeight: "..iU;br=-85;local j5=utils.map(bL,-150,-400,1,0.55)j3=j3*j5 end;cf(d(j3))end end;if br~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local j6=br-bR;OrbitPitchPID:inject(j6)local j7=r(OrbitPitchPID:get(),-0.5,0.5)S=j7 end end;if Autopilot and at==0 and not am then local j8,j9=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local ja=(CustomTarget.position-aa.center):normalize()local jb=ja:project_on_plane((aa.center-bM):normalize()):normalize()local jc=aa.center+jb*(aa.radius+AutopilotTargetOrbit)local jd=CustomTarget.position+(CustomTarget.position-aa.center):normalize()*(AutopilotTargetOrbit-aa:getAltitude(CustomTarget.position))if(bM-jc):len()<(bM-jd):len()then j8=jc;AutopilotTargetCoords=j8 else j8=CustomTarget.position+(CustomTarget.position-aa.center):normalize()*(AutopilotTargetOrbit-aa:getAltitude(CustomTarget.position))AutopilotTargetCoords=j8 end;cs(aa,AutopilotTargetCoords)j9=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;j9=true;TargetSet=true;AutopilotRealigned=true;j8=CustomTarget.position+(bM-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local ja=(bM+bI*100000-aa.center):normalize()local jb=ja:project_on_plane((aa.center-bM):normalize()):normalize()if jb:len()<1 then ja=(bM+bG*100000-aa.center):normalize()jb=ja:project_on_plane((aa.center-bM):normalize()):normalize()end;j8=aa.center+jb*(aa.radius+AutopilotTargetOrbit)AutopilotTargetCoords=j8;TargetSet=true;j9=true;AutopilotRealigned=true;cs(aa,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(j8)-bM):len()local hq,el,em=b8:getPlanetarySystem(0):castIntersections(bM,bI:normalize(),function(e9)if e9.noAtmosphericDensityAltitude>0 then return e9.radius+e9.noAtmosphericDensityAltitude else return e9.radius+e9.surfaceMaxAltitude*1.5 end end)local hr=el;if em~=nil and el~=nil then hr=math.min(em,el)end;if hr~=nil and hr<AutopilotDistance and hq.name==aa.name then AutopilotDistance=hr end;local iN=true;local je=(aa.center-(bM+vec3(bI):normalize()*AutopilotDistance)):len()-aa.radius;local hp,cn=cj(je)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hp..'", "unit":"'..cn..'"}')local a6,a7;if not TurnBurn then a6,a7=is(bJ)else a6,a7=iu(bJ)end;if bJ>300 and AutopilotAccelerating then local cW=vec3(j8)-bM;local jf=r(math.deg(iv(bF,bI:normalize(),cW:normalize()))*bJ/500,-90,90)local jg=r(math.deg(iv(bH,bI:normalize(),cW:normalize()))*bJ/500,-90,90)if c(jf)<20 and c(jg)<20 then jf=jf*2;jg=jg*2 end;if c(jf)<2 and c(jg)<2 then jf=jf*2;jg=jg*2 end;local iI=-math.deg(iv(bF,bG,bI:normalize()))local iJ=-math.deg(iv(bH,bG,bI:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(jg-iJ)local jh=r(apPitchPID:get(),-1,1)S=S+jh;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(jf-iI)local ji=r(apYawPID:get(),-1,1)T=T+ji;j9=true;if c(jf)>2 or c(jg)>2 then AutopilotStatus="Adjusting Trajectory"else AutopilotStatus="Accelerating"end end;if je<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=bb(aa):escapeAndOrbitalSpeed(je)end end;if not AutopilotCruising and not AutopilotBraking and not j9 then iN=cN((j8-bM):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then iN=cN(-vec3(bI):normalize())end;if AutopilotAccelerating then if not N then BrakeIsOn=false;cc(AutopilotInterplanetaryThrottle)G=y(AutopilotInterplanetaryThrottle,2)N=true end;local jj=unit.getThrottle()if AtmoSpeedAssist then jj=G end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or jj==0 and N then AutopilotAccelerating=false;AutopilotStatus="Cruising"AutopilotCruising=true;cc(0)end;if AutopilotDistance<=a6 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true;cc(0)N=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;W=1 end;if TurnBurn then cc(1,true)end;local _,iW=bb(aa):escapeAndOrbitalSpeed((bM-planet.center):len()-planet.radius)local cW;if CustomTarget~=nil then cW=CustomTarget.position-bM end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bJ<50 then a0="Autopilot complete, arrived at space location"AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bJ<=iW and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then a0="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cc(0)N=false;ProgradeIsOn=true;am=true;cs(aa,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 then AutopilotStatus="Circularizing"local _,iW=bb(aa):escapeAndOrbitalSpeed((bM-planet.center):len()-planet.radius)if bJ<=iW then if CustomTarget~=nil then if bI:normalize():dot(cW:normalize())>0.4 then AutopilotStatus="Orbiting to Target"if not WaypointSet then BrakeIsOn=false;cs(aa,CustomTarget.position)WaypointSet=true end else a0="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cc(0)N=false;ProgradeIsOn=true;am=true;BrakeIsOn=false;cs(aa,CustomTarget.position)WaypointSet=false end else BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"a0="Autopilot completed, orbit established"W=0;cc(0)N=false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then ProgradeIsOn=true;am=true end end end end elseif AutopilotCruising then if AutopilotDistance<=a6 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true end;local jj=unit.getThrottle()if AtmoSpeedAssist then jj=G end;if jj>0 then AutopilotAccelerating=true;AutopilotStatus="Accelerating"AutopilotCruising=false end else if iN then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not am then AutopilotTargetCoords=vec3(aa.center)+(AutopilotTargetOrbit+aa.radius)*bH;AutopilotShipUp=bF;AutopilotShipRight=bH end;AutopilotRealigned=true elseif iN then AutopilotAccelerating=true;AutopilotStatus="Accelerating"if not N then cc(AutopilotInterplanetaryThrottle,true)G=y(AutopilotInterplanetaryThrottle,2)N=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and at>0)then a0="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"W=0;cc(0)N=false;ProgradeIsOn=true;am=true;cs(aa,CustomTarget.position)end;if Y then bh=true;local jg=0;local f1=bM+vec3(unit.getMasterPlayerRelativePosition())local jk=f1-bM;local jl=vec3(jk):project_on(bG):len()local jm=vec3(jk):project_on(bH):len()local ai=math.sqrt(jl*jl+jm*jm)cN(jk:normalize())local jn=40;local jo=ai<jn;local jp=100;local jq=r((ai-jn)/2,10,jp)S=0;local iN=c(T)<0.1;if iN and bJ<jq and not jo then BrakeIsOn=false;jg=-20 else BrakeIsOn=true;jg=0 end;local jr=0;if c(jg-bR)>jr then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(jg-bR)local jh=pitchPID:get()S=jh end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local cG=unit.getClosestPlanetInfluence()>0;local js=HoldAltitude-au;local jt=500+bJ;local ju=1;if AutoTakeoff then ju=r(bJ/100,0.1,1)end;local jg=(utils.smoothstep(js,-jt,jt)-0.5)*2*MaxPitch*ju;if not Reentry and not am and not VectorToTarget and bG:dot(bI:normalize())<0.99 then jg=(utils.smoothstep(js,-jt*r(20-19*at*10,1,20),jt*r(20-19*at*10,1,20))-0.5)*2*MaxPitch*r(2-at*10,1,2)*ju end;if not AltitudeHold then jg=0 end;if LockPitch~=nil then if cG and not IntoOrbit then jg=LockPitch else LockPitch=nil end end;bh=true;local jv=S;if Reentry then local jw=d(bo)local jx,jy=b9.computeDistanceAndTime(bJ,jw/3.6,l(),0,0,LastMaxBrake-planet.gravity*9.8*l())local jz=au-(planet.noAtmosphericDensityAltitude+5000)if not bQ and au>planet.noAtmosphericDensityAltitude+5000 and bJ<=jw/3.6 and bJ>jw/3.6-10 and c(bI:normalize():dot(bG))>0.9 then cc(0)elseif bQ and(jx>-1 and jz<=jx or au<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cf(jw,true)if not P then jg=-80;if at>0.02 then a0="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;jg=0;bh=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and au>planet.noAtmosphericDensityAltitude+5000 then bh=true elseif au<=planet.noAtmosphericDensityAltitude+5000 then cf(jw)if not bQ and s:getTargetSpeed(axisCommandId.longitudinal)==bo then P=false;Reentry=false;bh=true end end end;if bJ>O and not an and not VectorToTarget and not BrakeLanding and ForceAlignment then cN(vec3(bI))end;if(VectorToTarget or an)and AutopilotTargetIndex>0 and at>0.01 then local cW;if CustomTarget~=nil then cW=CustomTarget.position-bM else cW=aa.center-bM end;local jf=math.deg(iv(bK:normalize(),bI,cW))*2;local jA=math.rad(c(bS))if bJ>minRollVelocity and at>0.01 then local jB=r(90-jg*2,-90,90)bl=r(jf*2,-jB,jB)local jC=jf;jf=r(r(jf,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jA)+4*(bR-jg)*math.sin(math.rad(bS)),-YawStallAngle*0.80,YawStallAngle*0.80)jg=r(r(jg*math.cos(jA),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(r(c(jC)*math.sin(jA),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bl=0;jf=r(jf,-YawStallAngle*0.80,YawStallAngle*0.80)end;local jD=iI-jf;if not bj and bJ>minRollVelocity and at>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(jD)local ji=r(yawPID:get(),-1,1)T=T+ji elseif as and ap>-1 or bJ<minRollVelocity then cN(cW)elseif bj and at>0.01 then if(iI<-YawStallAngle or iI>YawStallAngle)and at>0.01 then cN(bI)end;if(iJ<-PitchStallAngle or iJ>PitchStallAngle)and at>0.01 then jg=r(bR-iJ,bR-PitchStallAngle*0.80,bR+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not an then local iO=planet:getAltitude(CustomTarget.position)local jz=math.sqrt(cW:len()^2-(au-iO)^2)local jE=LastMaxBrakeInAtmo;if jE then jE=jE*r(bJ/100,0.1,1)*at else jE=LastMaxBrake end;if at<0.01 then jE=LastMaxBrake end;local jF=bI:len()-c(bL)local jG=vec3(core.getWorldAirFrictionAcceleration())local jH=math.sqrt(jG:len()-jG:project_on(g7):len())*l()if bJ>100 then a6,a7=b9.computeDistanceAndTime(bJ,100,l(),0,0,jE+jH)local jI,jJ=b9.computeDistanceAndTime(100,0,l(),0,0,jE/2)a6=a6+jI else a6,a7=b9.computeDistanceAndTime(bJ,0,l(),0,0,jE/2)end;StrongBrakes=true;if not an and not Reentry and jz<=a6+bJ*iH/2 and(bI:project_on_plane(bK):normalize():dot(cW:project_on_plane(bK):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cc(0)if AltitudeHold then cq()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(jF<0.1 or jz<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<jz)then if not bO then BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"end;LastDistanceToTarget=jz end elseif VectorToTarget and at==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(an or Reentry)then if CustomTarget~=nil and aa.name==planet.name then local cW=CustomTarget.position-bM;local iO=planet:getAltitude(CustomTarget.position)local jz=math.sqrt(cW:len()^2-(au-iO)^2)local jE=LastMaxBrakeInAtmo;if jE then a6,a7=b9.computeDistanceAndTime(bJ,0,l(),0,0,jE/2)StrongBrakes=true;if jz<=a6+bJ*iH/2 and bI:project_on_plane(bK):normalize():dot(cW:project_on_plane(bK):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;P=true;am=false;ao=true;Autopilot=false;cZ()end end;LastDistanceToTarget=jz end end end;if at==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(an or IntoOrbit or Reentry)then if not bz and not IntoOrbit then bx=HoldAltitude;bw=true;if VectorToTarget then bv.VectorToTarget=true end;cp()VectorToTarget=false;bt=true end end;if bj and at>0.01 and ap==-1 and bJ>minRollVelocity and VectorStatus~="Finalizing Approach"then cN(bI)jg=r(bR-iJ,bR-PitchStallAngle*0.80,bR+PitchStallAngle*0.80)end;S=jv;local iE=-1;if BrakeLanding then jg=0;local jK=false;local jL=30;if ba~=nil and ba>0 then local jH=0;local jM=r(at,0.4,2)local jE=LastMaxBrakeInAtmo*r(bJ/100,0.1,1)*jM;local jN=ba*jM+jE+jH-i2;local jO=jE/2+jH-i2;local jP=bJ-math.sqrt(c(jO/2)*20/(0.5*l()))*utils.sign(jO)if jP<0 then jP=0 end;local jQ;if bJ>100 then local jR,_=b9.computeDistanceAndTime(bJ,100,l(),0,0,jE)local jS,_=b9.computeDistanceAndTime(100,0,l(),0,0,math.sqrt(jE))jQ=jR+jS else jQ=b9.computeDistanceAndTime(bJ,0,l(),0,0,math.sqrt(jE))end;if jQ<20 then BrakeIsOn=false else local jT=0;if jP>100 then local jU,_=b9.computeDistanceAndTime(jP,100,l(),0,0,jN)local jV,_=b9.computeDistanceAndTime(100,0,l(),0,0,ba*jM+math.sqrt(jE)+jH-i2)jT=jU+jV else jT,_=b9.computeDistanceAndTime(jP,0,l(),0,0,ba*jM+math.sqrt(jE)+jH-i2)end;jT=(jT+15+bJ*iH)*1.1;local jW=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if jW then local iO=planet:getAltitude(CustomTarget.position)local jX=au-iO-100;local cW=CustomTarget.position-bM;local jY=math.sqrt(cW:len()^2-(au-iO)^2)if jY>100 then jW=false elseif jX<=jT or jT==-1 then BrakeIsOn=true;jK=true else BrakeIsOn=false;jK=true end end;if not jW and CalculateBrakeLandingSpeed then if jT>=jL then BrakeIsOn=true else BrakeIsOn=false end;jK=true end end end;if not bQ then cc(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)iE=ap;if iE>-1 then bh=autoRollPreference;if bJ<1 or bI:normalize():dot(bK)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)ae=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bI:normalize():dot(-g7)<0.999 then BrakeIsOn=true elseif bL<-brakeLandingRate and not jK then BrakeIsOn=true elseif not jK then BrakeIsOn=false end end;if AutoTakeoff or an then local hq,em,el;if AutopilotTargetCoords~=nil then hq,em,el=b8:getPlanetarySystem(0):castIntersections(bM,(AutopilotTargetCoords-bM):normalize(),function(e9)return e9.radius+e9.noAtmosphericDensityAltitude end)end;if bO then if au>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cc(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(jg)<15 and au/HoldAltitude>0.75 then AutoTakeoff=false;if not an then if bQ and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif an and bJ<O then Autopilot=true;an=false;AltitudeHold=false;AutoTakeoff=false;cc(0)elseif an then cc(0)BrakeIsOn=true end elseif an and at==0 and aa~=nil and(hq==nil or hq.name==aa.name)then Autopilot=true;an=false;AltitudeHold=false;AutoTakeoff=false;if not bQ then cc(0)end;AutopilotAccelerating=true end end;local jZ=ap>-1;local j_=bR;if(VectorToTarget or an)and not jZ and bJ>minRollVelocity and at>0.01 then local jA=math.rad(c(bS))j_=bR*c(math.cos(jA))+iJ*math.sin(jA)end;local k0=r(jg-j_,-PitchStallAngle*0.80,PitchStallAngle*0.80)if at<0.01 and VectorToTarget then k0=r(jg-j_,-85,MaxPitch)elseif at<0.01 then k0=r(jg-j_,-MaxPitch,MaxPitch)end;if c(bS)<5 or VectorToTarget or BrakeLanding or jZ or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(k0)local jh=pitchPID:get()S=S+jh end end;if antigrav~=nil and(antigrav and not ExternalAGG and au<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ap=iz()return ir end;function script.onStart()local function k1()local function k2(k3)local k4=dbHud_1.hasKey;for da,db in pairs(k3)do if k4(db)then local cm=f(dbHud_1.getStringValue(db))if cm~=nil then _G[db]=cm;aM=true end end end end;if dbHud_1 then local k4=dbHud_1.hasKey;if not useTheseSettings then k2(b_())coroutine.yield()k2(b)else k2(b)a0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ah=5;aM=false end;coroutine.yield()if aM then a0="Loaded Saved Variables"L=y(ResolutionX/2,0)M=y(ResolutionY/2,0)aK=ResolutionX;aL=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bh=autoRollPreference;bo=AtmoSpeedLimit;aA=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]aB=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]elseif not useTheseSettings then a0="No Saved Variables Found - Exit HUD to save settings"end else a0="No databank found. Attach one to control unit and rerun the autoconfigure to save preferences and locations"end;if LastStartTime+180<bE then LastMaxBrakeInAtmo=0 end;LastStartTime=bE;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ah=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=au end;antigrav.setBaseAltitude(AntigravTargetAltitude)end end;local function k5()local function k6(k7,k8)if k7>k8 then k8=k7 end;if ContainerOptimization>0 then k8=k8-k8*ContainerOptimization*0.05 end;if FuelTankOptimization>0 then k8=k8-k8*FuelTankOptimization*0.05 end;return k8 end;local k9=core.getElementNameById;local ka=fuelX~=0 and fuelY~=0;for da in pairs(av)do local type=core.getElementTypeById(av[da])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(av[da])),'^.*vertical.*$')then bN=true end end;if o(type,'^.*Space Engine$')then bC=true;if o(tostring(core.getElementTagsById(av[da])),'^.*vertical.*$')then local kb=core.getElementRotationById(av[da])if kb[4]<0 then if p(-kb[4],0.1)==0.5 then bA=true end else if p(kb[4],0.1)==0.5 then bB=true end end end end;if type=="Landing Gear"then Q=true end;if type=="Dynamic Core Unit"then local kc=h(av[da])if kc>10000 then C=128 elseif kc>1000 then C=64 elseif kc>150 then C=32 end end;aT=aT+h(av[da])if ka and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local kc=h(av[da])local kd=k(av[da])local k7=0;local f_=q()if type=="Atmospheric Fuel Tank"then local k8=400;local ke=35.03;if kc>10000 then k8=51200;ke=5480 elseif kc>1300 then k8=6400;ke=988.67 elseif kc>150 then k8=1600;ke=182.67 end;k7=kd-ke;if fuelTankHandlingAtmo>0 then k8=k8+k8*fuelTankHandlingAtmo*0.2 end;k8=k6(k7,k8)aQ[#aQ+1]={av[da],k9(av[da]),k8,ke,k7,f_}end;if type=="Rocket Fuel Tank"then local k8=320;local ke=173.42;if kc>65000 then k8=40000;ke=25740 elseif kc>6000 then k8=5120;ke=4720 elseif kc>700 then k8=640;ke=886.72 end;k7=kd-ke;if fuelTankHandlingRocket>0 then k8=k8+k8*fuelTankHandlingRocket*0.1 end;k8=k6(k7,k8)aS[#aS+1]={av[da],k9(av[da]),k8,ke,k7,f_}end;if type=="Space Fuel Tank"then local k8=2400;local ke=182.67;if kc>10000 then k8=76800;ke=5480 elseif kc>1300 then k8=9600;ke=988.67 end;k7=kd-ke;if fuelTankHandlingSpace>0 then k8=k8+k8*fuelTankHandlingSpace*0.2 end;k8=k6(k7,k8)aR[#aR+1]={av[da],k9(av[da]),k8,ke,k7,f_}end end end;if not bN then VertTakeOff,VertTakeOffEngine=false,false end end;local function kf()if gyro~=nil then ay=gyro.getState()==1 end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(as or not as and au<10000)then for _,db in pairs(door)do db.toggle()end end;if switch then for _,db in pairs(switch)do db.toggle()end end;if forcefield and(as or not as==0 and au<10000)then for _,db in pairs(forcefield)do db.toggle()end end;if antigrav then bO=antigrav.getState()==1;if bO and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if Q then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ap~=-1 or not as and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;if not Q then GearExtended=true end else BrakeIsOn=false end;if bi~=nil then s:setTargetGroundAltitude(bi)if bi==0 and not Q then GearExtended=true;BrakeIsOn=true end else bi=a:getTargetGroundAltitude()if GearExtended then s:setTargetGroundAltitude(LandingGearGroundHeight)else s:setTargetGroundAltitude(TargetHoverHeight)end end;if as and ap~=-1 then ba=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=as end;local function kg(kh,ki,kj,kk,c7,c8,kl,km,kn,ko)local kp={enableName=kh,disableName=ki,width=kj,height=kk,x=c7,y=c8,toggleVar=kl,toggleFunction=km,drawCondition=kn,hovered=false}if ko then table.insert(aJ,kp)else table.insert(aI,kp)end;return kp end;local function kq(kr)if not bT then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif kr=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif kr=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif kr=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bU=b_(kr)showHud=false else bU={}showHud=true end end;local function ks()bT=not bT;if bT then aH=aJ;a0="Hold SHIFT to see Settings"bV=showHud else aH=aI;a0="Hold SHIFT to see Control Buttons"kq()showHud=bV end end;local function kt(db)_G[db]=not _G[db]if _G[db]then a0=db.." set to true"else a0=db.." set to false"end;if db=="showHud"then bV=_G[db]elseif db=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function ku()local kv=50;local kw=340;local c7=500;local c8=aL/2-400;local kx=0;for da,db in pairs(b_("boolean"))do if type(_G[db])=="boolean"then kg(db,db,kw,kv,c7,c8,function()return _G[db]end,function()kt(db)end,function()return true end,true)c8=c8+kv+20;if kx==7 then c7=c7+kw+20;c8=aL/2-400;kx=0 else kx=kx+1 end end end;kg("Control View","Control View",kw,kv,10,aL/2-500,function()return true end,ks,function()return true end,true)kg("View Handling Settings",'Hide Handling Settings',kw,kv,10,aL/2-(500-kv),function()return showHandlingVariables end,function()kq("handling")end,function()return true end,true)kg("View Hud Settings",'Hide Hud Settings',kw,kv,10,aL/2-(500-kv*2),function()return showHudVariables end,function()kq("hud")end,function()return true end,true)kg("View Physics Settings",'Hide Physics Settings',kw,kv,10,aL/2-(500-kv*3),function()return showPhysicsVariables end,function()kq("physics")end,function()return true end,true)end;local function ky()local function kz()if dbHud_1 then local position=bM;local fT=planet.name..". "..#SavedLocations;if radar_1 then local dS,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dS~=nil and dS~=""then fT=fT.." "..radar_1.getConstructName(dS)end end;local cK={}cK={position=position,name=fT,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cK;table.insert(b3[0],cK)bd.UpdateAtlasLocationsList()a0="Location saved as "..fT else a0="Databank must be installed to save locations"end end;local function kA()TurnBurn=not TurnBurn end;local function kB(kC)if kC==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Y=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kD()kB(1)end;local function kE()local cJ=-1;cJ=bd.findAtlasIndex(b3[0])if cJ>-1 then table.remove(b3[0],cJ)end;cJ=-1;cJ=bd.findAtlasIndex(SavedLocations)if cJ~=-1 then a0=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cJ)end;bd.adjustAutopilotTargetIndex()bd.UpdateAtlasLocationsList()end;local function kF()local fT=AutopilotTargetName;if fT==nil then local hp,cn=cj((bM-CustomTarget.position):len())fT=CustomTarget.name.." "..hp..cn end;if fT==nil then fT="None"end;return"Engage Autopilot: "..fT end;local function kG()local fT=AutopilotTargetName;if fT==nil then fT=CustomTarget.name end;if fT==nil then fT="None"end;return"Disable Autopilot: "..fT end;local kv=50;local kw=260;local kH=kg("Enable Brake Toggle","Disable Brake Toggle",kw,kv,aK/2-kw/2,aL/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a0="Brakes in Toggle Mode"else a0="Brakes in Default Mode"end end)kg("Align Prograde","Disable Prograde",kw,kv,aK/2-kw/2-50-kH.width,aL/2-kv+380,function()return ProgradeIsOn end,kD)kg("Align Retrograde","Disable Retrograde",kw,kv,aK/2-kw/2+kH.width+50,aL/2-kv+380,function()return RetrogradeIsOn end,kB,function()return at==0 end)local kI=kg(kF,kG,600,60,aK/2-600/2,aL/2-60/2-400,function()return Autopilot end,cE)kg("Save Position","Save Position",200,kI.height,kI.x+kI.width+30,kI.y,function()return false end,kz,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)kg("Update Position","Update Position",200,kI.height,kI.x+kI.width+30,kI.y,function()return false end,cH,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kg("Clear Position","Clear Position",200,kI.height,kI.x-200-30,kI.y,function()return true end,kE,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kv=60;kw=300;local c7=10;local c8=aL/2-500;kg("Show Help","Hide Help",kw,kv,c7,c8,function()return showHelp end,function()showHelp=not showHelp end)c8=c8+kv+20;kg("View Settings","View Settings",kw,kv,c7,c8,function()return true end,ks)local c8=aL/2-300;kg("Enable Turn and Burn","Disable Turn and Burn",kw,kv,c7,c8,function()return TurnBurn end,kA)kg("Horizontal Takeoff Mode","Vertical Takeoff Mode",kw,kv,c7+kw+20,c8,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a0="Vertical Takeoff Mode"else a0="Horizontal Takeoff Mode"end end,function()return bN end)c8=c8+kv+20;kg("Show Orbit Display","Hide Orbit Display",kw,kv,c7,c8,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a0="Orbit Display Enabled"else a0="Orbit Display Disabled"end end)kg("Engage Orbiting","Cancel Orbiting",kw,kv,c7+kw+20,c8,function()return IntoOrbit end,cp,function()return at==0 and unit.getClosestPlanetInfluence()>0 end)c8=c8+kv+20;kg("Glide Re-Entry","Cancel Glide Re-Entry",kw,kv,c7,c8,function()return Reentry end,function()am=true;kD()end,function()return planet.hasAtmosphere and not as end)kg("Parachute Re-Entry","Cancel Parachute Re-Entry",kw,kv,c7+kw+20,c8,function()return Reentry end,cZ,function()return planet.hasAtmosphere and not as end)c8=c8+kv+20;kg("Engage Follow Mode","Disable Follow Mode",kw,kv,c7,c8,function()return Y end,cr,function()return m()==1 end)kg("Enable Repair Arrows","Disable Repair Arrows",kw,kv,c7+kw+20,c8,function()return aU end,function()aU=not aU;if aU then a0="Repair Arrows Enabled"else a0="Repair Arrows Diabled"end end,function()return m()==1 end)c8=c8+kv+20;if not ExternalAGG then kg("Enable AGG","Disable AGG",kw,kv,c7,c8,function()return bO end,d0,function()return antigrav~=nil end)end;c8=c8+kv+20;kg(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,kw*2,kv,c7,c8,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end end)end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})k1()coroutine.yield()k5()coroutine.yield()be=iq()kf()ku()ky()aH=aI;coroutine.yield()b3=dc()b7=dd()b8=b7(dc())b9=ev()bb=e_()bc=fm()bd=ih()be=iq()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)if UseSatNav then unit.setTimer("fiveSecond",5)end end)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(at>0 or at==0 and au<10000)then for _,db in pairs(door)do db.toggle()end end;if switch then for _,db in pairs(switch)do db.toggle()end end;if forcefield and(at>0 or at==0 and au<10000)then for _,db in pairs(forcefield)do db.toggle()end end;d6()if button then button.activate()end;if SetWaypointOnExit then cs(planet,bM)end end;function script.onTick(kJ)if kJ=="tenthSecond"then local function kK()local kL=system.createData;local kM=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=kM(panelInterplanetary,"value")interplanetaryHeaderText=kL('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=kM(panelInterplanetary,"value")widgetDistanceText=kL('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=kM(panelInterplanetary,"value")widgetTravelTimeText=kL('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=kM(panelInterplanetary,"value")widgetMaxMassText=kL('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=kM(panelInterplanetary,"value")widgetTargetOrbitText=kL('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=kM(panelInterplanetary,"value")widgetCurBrakeDistanceText=kL('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=kM(panelInterplanetary,"value")widgetCurBrakeTimeText=kL('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=kM(panelInterplanetary,"value")widgetMaxBrakeDistanceText=kL('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=kM(panelInterplanetary,"value")widgetMaxBrakeTimeText=kL('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=kM(panelInterplanetary,"value")widgetTrajectoryAltitudeText=kL('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not as then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function kN()t(panelInterplanetary)panelInterplanetary=nil end;local function kO()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(aa.center-bM):len()else AutopilotDistance=(CustomTarget.position-bM):len()end end;local eY=bJ;local jj=unit.getThrottle()/100;if AtmoSpeedAssist then jj=G end;local kP,kQ=b9.computeDistanceAndTime(bJ,MaxGameVelocity,l(),a:maxForceForward()*jj,warmup,0)local a6,a7;if not TurnBurn then a6,a7=be.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=be.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,kR;if not TurnBurn and eY>0 then _,kR=be.GetAutopilotBrakeDistanceAndTime(eY)else _,kR=be.GetAutopilotTBBrakeDistanceAndTime(eY)end;local kS=0;local kT=0;if AutopilotCruising or not Autopilot and eY>5 then kT=b9.computeTravelTime(eY,0,AutopilotDistance)elseif a6+kP<AutopilotDistance then kS=AutopilotDistance-(a6+kP)kT=b9.computeTravelTime(8333.0556,0,kS)else local kU=(AutopilotDistance-a6)/kP;kP=AutopilotDistance-a6;kQ=kQ*kU end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return kT elseif AutopilotBraking then return kR elseif AutopilotCruising then return kT+kR else return kQ+a7+kT end end;if at>0 and not WasInAtmo then if not bQ and AtmoSpeedAssist and(AltitudeHold or Reentry)then cc(1)K=false end end;if bP~=nil then if s:getTargetSpeed(axisCommandId.longitudinal)~=bP then cf(bP,TRUE)else bP=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then kK()end;if AutopilotTargetName~=nil then local kV=CustomTarget~=nil;planetMaxMass=LastMaxBrakeInAtmo/aa:getGravity(aa.center+vec3(0,0,1)*aa.radius):len()u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=kO()if kV and not Autopilot then ai=(bM-CustomTarget.position):len()else ai=(AutopilotTargetCoords-bM):len()end;if not TurnBurn then a6,a7=be.GetAutopilotBrakeDistanceAndTime(bJ)a8,a9=be.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=be.GetAutopilotTBBrakeDistanceAndTime(bJ)a8,a9=be.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hp,cn=cj(ai)u(widgetDistanceText,'{"label": "distance", "value": "'..hp..'", "unit":"'..cn..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d1(travelTime)..'", "unit":""}')hp,cn=cj(a6)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hp..'", "unit":"'..cn..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d1(a7)..'", "unit":""}')hp,cn=cj(a8)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hp..'", "unit":"'..cn..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d1(a9)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",planetMaxMass/1000)..'", "unit":" Tons"}')hp,cn=cj(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..e("%.2f",hp)..'", "unit":"'..cn..'"}')if at>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if at==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else kN()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif kJ=="oneSecond"then local function kW(i2,kX)if i2==nil then i2=core.g()end;i2=y(i2,5)if kX~=nil and kX or(aP==nil or aP~=i2)then local f0=core.getVelocity()local eY=vec3(f0):len()local kY=f(unit.getData()).maxBrake;if kY~=nil and kY>0 and as then kY=kY/r(eY/100,0.1,1)kY=kY/at;if at>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+kY)/2 else LastMaxBrakeInAtmo=kY end end end;if kY~=nil and kY>0 then LastMaxBrake=kY end;aP=i2 end end;local function kZ(fD)local k_=0;aF=""local l0=aT;local l1=0;local l2=0;local l3=0;local g1=0;local g2=""local l4=core.getElementHitPointsById;for da in pairs(av)do local kc=0;local l5=0;l5=h(av[da])kc=l4(av[da])l1=l1+kc;if kc<l5 then if kc==0 then l3=l3+1 else l2=l2+1 end;if aU and#aC==0 then position=vec3(core.getElementPositionById(av[da]))local c7=position.x-C;local c8=position.y-C;local l6=position.z-C;table.insert(aC,core.spawnArrowSticker(c7,c8,l6+1,"down"))table.insert(aC,core.spawnArrowSticker(c7,c8,l6+1,"down"))core.rotateSticker(aC[2],0,0,90)table.insert(aC,core.spawnArrowSticker(c7+1,c8,l6,"north"))table.insert(aC,core.spawnArrowSticker(c7+1,c8,l6,"north"))core.rotateSticker(aC[4],90,90,0)table.insert(aC,core.spawnArrowSticker(c7-1,c8,l6,"south"))table.insert(aC,core.spawnArrowSticker(c7-1,c8,l6,"south"))core.rotateSticker(aC[6],90,-90,0)table.insert(aC,core.spawnArrowSticker(c7,c8-1,l6,"east"))table.insert(aC,core.spawnArrowSticker(c7,c8-1,l6,"east"))core.rotateSticker(aC[8],90,0,90)table.insert(aC,core.spawnArrowSticker(c7,c8+1,l6,"west"))table.insert(aC,core.spawnArrowSticker(c7,c8+1,l6,"west"))core.rotateSticker(aC[10],-90,0,90)table.insert(aC,av[da])end elseif aU and#aC>0 and aC[11]==av[da]then for fV in pairs(aC)do core.deleteSticker(aC[fV])end;aC={}end end;k_=d(l1/l0*100)if k_<100 then fD[#fD+1]=c6(0,0,"","pbright txt")g1=d(k_*2.55)g2=e("rgb(%d,%d,%d)",255-g1,g1,0)if k_<100 then fD[#fD+1]=c6("50%",1035,"Elemental Integrity: "..k_.."%","txtbig txtmid","fill:"..g2)if l3>0 then fD[#fD+1]=c6("50%",1055,"Disabled Modules: "..l3 .." Damaged Modules: "..l2,"txtbig txtmid","fill:"..g2)elseif l2>0 then fD[#fD+1]=c6("50%",1055,"Damaged Modules: "..l2,"txtbig txtmid","fill:"..g2)end end end end;local function l7()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function l8()local f_=q()local hd=bJ;local l9=f_-aw;if hd>1.38889 then hd=hd/1000;local la=hd*(f_-aw)TotalDistanceTravelled=TotalDistanceTravelled+la;ab=ab+la end;ac=ac+l9;TotalFlightTime=TotalFlightTime+l9;aw=f_ end;aq=false;kW(nil,true)l8()bc.UpdateRadar()l7()local fD={}bc.ExtraData(fD)if ShowOdometer then fD=bc.DrawOdometer(fD,ab,TotalDistanceTravelled,ac)end;if ShouldCheckDamage then kZ(fD)end;ak=table.concat(fD,"")collectgarbage("collect")elseif kJ=="fiveSecond"then ar=dbHud_1.getStringValue("SPBAutopilotTargetName")if ar~=nil and ar~=""and ar~="SatNavNotChanged"then local cm=f(dbHud_1.getStringValue("SavedLocations"))if cm~=nil then _G["SavedLocations"]=cm;local cJ=-1;local cK;for da,db in pairs(SavedLocations)do if db.name and db.name=="SatNav Location"then cJ=da;break end end;if cJ~=-1 then cK=SavedLocations[cJ]cJ=-1;for da,db in pairs(b3[0])do if db.name and db.name=="SatNav Location"then cJ=da;break end end;if cJ>-1 then b3[0][cJ]=cK end;bd.UpdateAtlasLocationsList()a0=cK.name.." position updated"end end;for i=1,#bW do if bW[i].name==ar then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bW[i].name)bd.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif kJ=="msgTick"then local fD={}bc.DisplayMessage(fD,"empty")a0="empty"unit.stopTimer("msgTick")ah=3 elseif kJ=="animateTick"then bg=true;bf=false;af=0;ag=0;unit.stopTimer("animateTick")elseif kJ=="hudTick"then local function lb(fD)local lc=d(r(ai/(aK/4)*255,0,255))fD[#fD+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",af,ag,d(D+0.5)+lc,d(F+0.5)-lc,d(E+0.5)-lc)end;local function ld()for _,db in pairs(aH)do if db.hovered then if not db.drawCondition or db.drawCondition()then db.toggleFunction()end;db.hovered=false end end end;local function le()local function lf(lg,lh,c7,c8,kj,kk)if lg>c7 and lg<c7+kj and lh>c8 and lh<c8+kk then return true else return false end end;local c7=af+aK/2;local c8=ag+aL/2;for _,db in pairs(aH)do db.hovered=lf(c7,c8,db.x,db.y,db.width,db.height)end end;local function li(fD)local function lj(fD,lk,hover,c7,c8,eR,ll,lm,ln,lo,lp)if type(lo)=="function"then lo=lo()end;if type(lp)=="function"then lp=lp()end;fD[#fD+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c7,c8,eR,ll)if lk then fD[#fD+1]=e("%s'",lm)else fD[#fD+1]=ln end;if hover then fD[#fD+1]=" style='stroke:white; stroke-width:2'"else fD[#fD+1]=" style='stroke:black; stroke-width:1'"end;fD[#fD+1]="></rect>"fD[#fD+1]=e("<text x='%f' y='%f' font-size='24' fill='",c7+eR/2,c8+ll/2+5)if lk then fD[#fD+1]="black"else fD[#fD+1]="white"end;fD[#fD+1]="' text-anchor='middle' font-family='Montserrat'>"if lk then fD[#fD+1]=e("%s</text>",lo)else fD[#fD+1]=e("%s</text>",lp)end end;local lq="rgb(50,50,50)'"local lr="rgb(210,200,200)"local ls=lj;for _,db in pairs(aH)do local ki=db.disableName;local kh=db.enableName;if type(ki)=="function"then ki=ki()end;if type(kh)=="function"then kh=kh()end;if not db.drawCondition or db.drawCondition()then ls(fD,db.toggleVar(),db.hovered,db.x,db.y,db.width,db.height,lr,lq,ki,kh)end end end;local fD={}bc.HUDPrologue(fD)if showHud then bc.UpdateHud(fD)else bc.DisplayOrbitScreen(fD)bc.DrawWarnings(fD)end;if bT and bU~={}then bc.DrawSettings(fD)end;bc.HUDEpilogue(fD)fD[#fD+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aK,aL)if a0~="empty"then bc.DisplayMessage(fD,a0)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then bc.DrawDeadZone(fD)end end;if x()==0 then if m()==1 and Z then le()li(fD)if not bf and not bg then local lt=table.concat(fD,"")fD={}fD[#fD+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fD[#fD+1]=lt;fD[#fD+1]="</body>"bf=true;fD[#fD+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fD,"")system.setScreen(content)elseif bg then local lt=table.concat(fD,"")fD={}fD[#fD+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fD[#fD+1]=lt;fD[#fD+1]="</body>"end;if not bf then fD[#fD+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],L,M,af,ag)end else ld()end else if not Z and m()==0 then ld()if ai>DeadZone then if DisplayDeadZone then lb(fD)end end else le()li(fD)end;fD[#fD+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],L,M,af,ag)end;fD[#fD+1]=[[</svg></body>]]content=table.concat(fD,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif kJ=="apTick"then be.APTick()end end;function script.onFlush()local function lu(lv,jq)local lw=vec3()local lx=vec3()if lv==axisCommandId.longitudinal then lw=vec3(core.getConstructOrientationForward())lx=bG elseif lv==axisCommandId.vertical then lw=vec3(core.getConstructOrientationUp())lx=bF elseif lv==axisCommandId.lateral then lw=vec3(core.getConstructOrientationRight())lx=bH else return vec3()end;local ly=vec3(core.getWorldGravity())local lz=ly:dot(lx)local lA=vec3(core.getWorldAirFrictionAcceleration())local lB=lA:dot(lx)local lC=vec3(core.getVelocity())local lD=lC:dot(lw)local lE=jq*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(lE-lD)local lF=targetSpeedPID2:get()local lG=(lF-lB-lz)*lx;return lG end;local function lH(lv,jq)local lw=vec3()local lx=vec3()if lv==axisCommandId.longitudinal then lw=vec3(core.getConstructOrientationForward())lx=bG elseif lv==axisCommandId.vertical then lw=vec3(core.getConstructOrientationUp())lx=bF elseif lv==axisCommandId.lateral then lw=vec3(core.getConstructOrientationRight())lx=bH else return vec3()end;local ly=vec3(core.getWorldGravity())local lz=ly:dot(lx)local lA=vec3(core.getWorldAirFrictionAcceleration())local lB=lA:dot(lx)local lC=vec3(core.getVelocity())local lD=lC:dot(lw)local lE=jq*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(lE-lD)local lF=targetSpeedPID:get()local lG=(lF-lB-lz)*lx;return lG end;local function lI(lJ,g6,il)local lK=lJ:cross(il):normalize_inplace()local gR=math.acos(r(lK:dot(-g6),-1,1))*constants.rad2deg;if lK:cross(-g6):dot(il)<0 then gR=-gR end;return gR end;if antigrav and not ExternalAGG then if not bO and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bQ=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bQ and K then cc(0)K=false elseif not bQ and not K then G=0;K=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local lL=r(R+S+system.getControlDeviceForwardInput(),-1,1)local lM=r(U+X+system.getControlDeviceYawInput(),-1,1)local lN=r(V+T-system.getControlDeviceLeftRightInput(),-1,1)local lO=W;bK=vec3(core.getWorldVertical())if bK==nil or bK:len()==0 then bK=(planet.center-bM):normalize()end;bM=vec3(core.getConstructWorldPos())bF=vec3(core.getConstructWorldOrientationUp())bG=vec3(core.getConstructWorldOrientationForward())bH=vec3(core.getConstructWorldOrientationRight())bI=vec3(core.getWorldVelocity())bJ=vec3(bI):len()bL=-bK:dot(bI)bS=getRoll(bK,bG,bH)local lP=bS/180*math.pi;local lQ=math.cos(lP)local lR=math.sin(lP)bR=lI(bK,bG,bH*lQ+bF*lR)local lS=bI:normalize()local lT=getRoll(bK,bG,bH)local lU=c(lT)local lV=utils.sign(lT)local lW=vec3(core.getWorldAngularVelocity())local lX=lL*pitchSpeedFactor*bH+lM*rollSpeedFactor*bG+lN*yawSpeedFactor*bF;if bK:len()>0.01 and(at>0.0 or ProgradeIsOn or Reentry or am or AltitudeHold or IntoOrbit)then if bh==true and c(bl-lT)>autoRollRollThreshold and lM==0 and c(bR)<85 then local lY=bl;local lZ=autoRollFactor;if at==0 then lZ=lZ/4;bl=0;lY=0 end;if rollPID==nil then rollPID=pid.new(lZ*0.01,0,lZ*0.1)end;rollPID:inject(lY-lT)local l_=rollPID:get()lX=lX+l_*bG end end;if bK:len()>0.01 and at>0.0 then local m0=20.0;if turnAssist==true and lU>m0 and lL==0 and lN==0 then local m1=turnAssistFactor*0.1;local m2=turnAssistFactor*0.025;local m3=(lU-m0)/(180-m0)*180;local m4=0;if m3<90 then m4=m3/90 elseif m3<180 then m4=(180-m3)/90 end;m4=m4*m4;local m5=-lV*m2*(1.0-m4)local m6=m1*m4;lX=lX+m6*bH+m5*bF end end;local m7=1;local m8=0;local m9=1;if system.getMouseWheel()>0 then if AltIsOn then if at>0 or Reentry then bo=r(bo+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif ax then local ma=G;G=y(r(G+speedChangeLarge/100,-1,1),2)if G>=0 and ma<0 then G=0;ax=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if at>0 or Reentry then bo=r(bo-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif ax then local ma=G;G=y(r(G-speedChangeLarge/100,-1,1),2)if G<=0 and ma>0 then G=0;ax=false end end else ax=true end;H=0;if as and AtmoSpeedAssist and bQ then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bo/3.6-bI:dot(bG))local mb=throttlePID:get()J=r(mb,-1,1)if J<G and at>0.005 then I=true;s:setThrottleCommand(axisCommandId.longitudinal,r(J,0.01,1))else I=false;s:setThrottleCommand(axisCommandId.longitudinal,G)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bI:len()-bo/3.6)local mc=r(brakePID:get(),0,1)if at>0 and bL<-80 or at>0.005 then H=mc end;if H>0 then if I and J==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else J=r(J,0.01,1)end;local md=''local me=vec3()local mf=lu(axisCommandId.vertical,ae*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",mf,m8)local mg='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then mg=mg..ExtraLongitudeTags end;local mh=s:getAxisCommandType(axisCommandId.longitudinal)local mi=s:composeAxisAccelerationFromThrottle(mg,axisCommandId.longitudinal)local mj=lH(axisCommandId.lateral,LeftAmount*1000)md=md..' , '.."lateral airfoil , lateral ground "me=me+mj;if me:len()>constants.epsilon then a:setEngineForceCommand(md,me,m8,'','','',m9)end;a:setEngineForceCommand(mg,mi,m7)local mk='thrust analog vertical fueled 'local ml='thrust analog lateral fueled 'if ExtraLateralTags~="none"then ml=ml..ExtraLateralTags end;if ExtraVerticalTags~="none"then mk=mk..ExtraVerticalTags end;if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mk,mf,m7)else a:setEngineForceCommand(mk,vec3(),m7)end;if LeftAmount~=0 then a:setEngineForceCommand(ml,mj,m7)else a:setEngineForceCommand(ml,vec3(),m7)end;if lO==0 then lO=H end;local mm=-lO*(brakeSpeedFactor*bI+brakeFlatFactor*lS)a:setEngineForceCommand('brake',mm)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,G)end;local jq=unit.getAxisCommandValue(0)if not bQ then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bI:len()-jq/3.6)local mc=r(brakePID:get(),0,1)lO=r(lO+mc,0,1)end;local mm=-lO*(brakeSpeedFactor*bI+brakeFlatFactor*lS)a:setEngineForceCommand('brake',mm)local md=''local me=vec3()local mn=false;local mg='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then mg=mg..ExtraLongitudeTags end;local mh=s:getAxisCommandType(axisCommandId.longitudinal)if mh==axisCommandType.byThrottle then local mi=s:composeAxisAccelerationFromThrottle(mg,axisCommandId.longitudinal)a:setEngineForceCommand(mg,mi,m7)elseif mh==axisCommandType.byTargetSpeed then local mi=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)md=md..' , '..mg;me=me+mi;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then mn=true end end;local ml='thrust analog lateral 'if ExtraLateralTags~="none"then ml=ml..ExtraLateralTags end;local mo=s:getAxisCommandType(axisCommandId.lateral)if mo==axisCommandType.byThrottle then local mp=s:composeAxisAccelerationFromThrottle(ml,axisCommandId.lateral)a:setEngineForceCommand(ml,mp,m7)elseif mo==axisCommandType.byTargetSpeed then local mj=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)md=md..' , '..ml;me=me+mj end;local mk='thrust analog vertical 'if ExtraVerticalTags~="none"then mk=mk..ExtraVerticalTags end;local mq=s:getAxisCommandType(axisCommandId.vertical)if mq==axisCommandType.byThrottle then local mf=s:composeAxisAccelerationFromThrottle(mk,axisCommandId.vertical)if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mk,mf,m7,'airfoil','ground','',m9)else a:setEngineForceCommand(mk,vec3(),m7)a:setEngineForceCommand('airfoil vertical',mf,m7,'airfoil','','',m9)a:setEngineForceCommand('ground vertical',mf,m7,'ground','','',m9)end elseif mq==axisCommandType.byTargetSpeed then if ae<0 then a:setEngineForceCommand('hover',vec3(),m7)end;local mr=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)md=md..' , '..mk;me=me+mr end;if me:len()>constants.epsilon then if W~=0 or mn or c(lS:dot(bG))<0.8 then md=md..', brake'end;a:setEngineForceCommand(md,me,m8,'','','',m9)end end;local ms=torqueFactor*(lX-lW)local mt=vec3(core.getWorldAirFrictionAngularAcceleration())ms=ms-mt;a:setEngineTorqueCommand('torque',ms,m7,'airfoil','','',m9)a:setBoosterCommand('rocket_engine')if a5 and not VanillaRockets then local eY=vec3(core.getVelocity()):len()local mu=0.15;if not bQ then local mv=s:getTargetSpeed(axisCommandId.longitudinal)if eY*3.6>mv*(1-mu)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eY*3.6<mv*(1-mu)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jj=unit.getThrottle()if AtmoSpeedAssist then jj=G*100 end;local jq=jj/100;if j==0 then jq=jq*MaxGameVelocity;if eY>=jq*(1-mu)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eY<jq*(1-mu)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jw=d(bo)jq=jq*jw/3.6;if eY>=jq*(1-mu)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eY<jq*(1-mu)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local _,cm=coroutine.resume(beginSetup)if cm then SetupComplete=true end else a:update()if not bf and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(mw)local B=1;local function mx(my)if my then B=-1 end;if not ExternalAGG and bO then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a2;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bx=bx+B*a1;if bx<planet.noAtmosphericDensityAltitude then bx=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a1 end else s:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function mz(my)if my then B=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then G=r(G+B*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if my then B=1 else B=nil end;bd.adjustAutopilotTargetIndex(B)end end;if mw=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cc(0)if vBooster or hover then if as and ap==-1 then StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bh=true;GearExtended=false elseif as then BrakeIsOn=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)else a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end;if Q and not BrakeLanding then a.control.extendLandingGears()end else if Q then a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif mw=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif mw=="forward"then R=R-1 elseif mw=="backward"then R=R+1 elseif mw=="left"then U=U-1 elseif mw=="right"then U=U+1 elseif mw=="yawright"then V=V-1 elseif mw=="yawleft"then V=V+1 elseif mw=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif mw=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif mw=="up"then ae=ae+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif mw=="down"then ae=ae-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif mw=="groundaltitudeup"then mx()elseif mw=="groundaltitudedown"then mx(true)elseif mw=="option1"then bd.adjustAutopilotTargetIndex()toggleView=false elseif mw=="option2"then bd.adjustAutopilotTargetIndex(1)toggleView=false elseif mw=="option3"then local function mA()aG=not aG;if not aG then unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;mA()toggleView=false elseif mw=="option4"then cE()toggleView=false elseif mw=="option5"then local function mB()if LockPitch==nil then LockPitch=bR;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else LockPitch=nil end end;mB()toggleView=false elseif mw=="option6"then cq()toggleView=false elseif mw=="option7"then toggleView=false elseif mw=="option8"then cr()toggleView=false elseif mw=="option9"then if gyro~=nil then gyro.toggle()ay=gyro.getState()==1 end;toggleView=false elseif mw=="lshift"then if x()==1 then Z=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then Z=true;bg=false;bf=false end elseif mw=="brake"then if BrakeToggleStatus then cM()elseif not BrakeIsOn then cM()else BrakeIsOn=true end elseif mw=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif mw=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a5 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a5=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a5=false end elseif mw=="stopengines"then local function mC()if aq then aq=false;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Y=false;N=false;am=false;an=false;P=false;bh=autoRollPreference;VectorToTarget=false;TurnBurn=false;ay=false;LockPitch=nil;IntoOrbit=false else aq=true end end;s:resetCommand(axisCommandId.longitudinal)mC()G=0 elseif mw=="speedup"then mz()elseif mw=="speeddown"then mz(true)elseif mw=="antigravity"and not ExternalAGG then if antigrav~=nil then d0()end end end;function script.onActionStop(mw)local function mD()if not ExternalAGG and bO then a4=a2 end;if AltitudeHold or VertTakeOff or IntoOrbit then a3=a1 end end;if mw=="forward"then R=0 elseif mw=="backward"then R=0 elseif mw=="left"then U=0 elseif mw=="right"then U=0 elseif mw=="yawright"then V=0 elseif mw=="yawleft"then V=0 elseif mw=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif mw=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif mw=="up"then ae=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mw=="down"then ae=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mw=="groundaltitudeup"then mD()toggleView=false elseif mw=="groundaltitudedown"then mD()toggleView=false elseif mw=="lshift"then if x()==1 then Z=false;af=0;ag=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then Z=false;bg=false;bf=false end elseif mw=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cM()else BrakeIsOn=false end end elseif mw=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(mw)local B=1;local function mE(my)if my then B=-1 end;if not ExternalAGG and bO then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a4=a4*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bx=bx+B*a3;if bx<planet.noAtmosphericDensityAltitude then bx=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a3 end;a3=a3*1.05 else s:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function mF(my)if my then B=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then G=r(G+B*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if mw=="groundaltitudeup"then mE()elseif mw=="groundaltitudedown"then mE(true)elseif mw=="speedup"then mF()elseif mw=="speeddown"then mF(true)end end;function script.onInputText(c9)local function mG()for da,db in pairs(b_())do dbHud_1.setStringValue(db,g(nil))end;for da,db in pairs(b)do if db~="SavedLocations"then dbHud_1.setStringValue(db,g(nil))end end;a0="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ah=5;aM=false;ad=true end;local function mH(mI,planet,f1)local function mJ(f1)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dr='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dE,dF,cA,cB,cz=o(f1,dr)if dE=="0"and dF=="0"then return vec3(tonumber(cA),tonumber(cB),tonumber(cz))end;cB=math.rad(cB)cA=math.rad(cA)local planet=b3[tonumber(dE)][tonumber(dF)]local es=math.cos(cA)local mK=vec3(es*math.cos(cB),es*math.sin(cB),math.sin(cA))return planet.center+(planet.radius+cz)*mK end;if dbHud_1 then local cK={}local position=mJ(f1)if planet.name=="Space"then cK={position=position,name=mI,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cK={position=position,name=mI,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;SavedLocations[#SavedLocations+1]=cK;table.insert(b3[0],cK)bd.UpdateAtlasLocationsList()else a0="Databank must be installed to save locations"end end;local i;local mL="/commands /setname /G /agg /addlocation /copydatabank /wipedatabank"local mM,mN=nil,nil;local mO="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all updatable variables with /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572} - adds a saved location by waypoint, not as accurate as making one at location\n".."/copydatabank - copies dbHud databank to a blank databank\n/wipedatabank - wipes the databank of all hud variables but not save variables"i=string.find(c9," ")mM=c9;if i~=nil then mM=string.sub(c9,0,i-1)mN=string.sub(c9,i+1)end;if mM=="/help"or mM=="/commands"then for i8 in string.gmatch(mO,"([^\n]+)")do system.print(i8)end;return elseif mM=="/setname"then if mN==nil or mN==""then a0="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cH(mN)else a0="Select a saved target to rename first"end elseif mM=="/addlocation"then if mN==nil or mN==""or string.find(mN,"::")==nil then a0="Usage: ah-addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572}"return end;i=string.find(mN,"::")local mI=string.sub(mN,1,i-2)local f1=string.sub(mN,i)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dr='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dE,dF,cA,cB,cz=o(f1,dr)local planet=b3[tonumber(dE)][tonumber(dF)]mH(mI,planet,f1)a0="Added "..mI.." to saved locations,\nplanet "..planet.name.." at "..f1;ah=5 elseif mM=="/agg"then if mN==nil or mN==""then a0="Usage: ah-agg targetheight"return end;mN=tonumber(mN)if mN<1000 then mN=1000 end;AntigravTargetAltitude=mN;a0="AGG Target Height set to "..mN elseif mM=="/G"then if mN==nil or mN==""then a0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if mN=="dump"then for da,db in pairs(b_())do if type(_G[db])=="boolean"then if _G[db]==true then system.print(db.." true")else system.print(db.." false")end elseif _G[db]==nil then system.print(db.." nil")else system.print(db.." ".._G[db])end end;return end;i=string.find(mN," ")local mP=string.sub(mN,0,i-1)local mQ=string.sub(mN,i+1)for da,db in pairs(b_())do if db==mP then a0="Variable "..mP.." changed to "..mQ;local mR=type(_G[db])if mR=="number"then mQ=tonumber(mQ)elseif mR=="boolean"then if string.lower(mQ)=="true"then mQ=true else mQ=false end end;_G[db]=mQ;return end end;a0="No such global variable: "..mP elseif mM=="/copydatabank"then if dbHud_2 then d6(true)else a0="Spare Databank required to copy databank"end elseif mM=="/wipedatabank"then if dbHud_1 then mG()else a0="No databank found."end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
