name: ArchHud - Archaegeo v0.005 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.005;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.2;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab=2;ac={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end},DockingMode={set=function(M)ab=M end,get=function()return ab end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV=1.0;aW="none"aX="none"aY="none"aZ={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aV=M end,get=function()return aV end},ExtraLongitudeTags={set=function(M)aW=M end,get=function()return aW end},ExtraLateralTags={set=function(M)aX=M end,get=function()return aX end},ExtraVerticalTags={set=function(M)aY=M end,get=function()return aY end}}a_=k;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=1000;bc=false;bd=false;be=false;bf=false;bg=0;bh="Aligning"bi=0;bj=1;bk="None"bl=nil;bm=0;bn=nil;bo=0.0;bp=0;bq={}br=false;bs=0;bt=0;bu=nil;bv=0;bw=1000;bx=0;by=false;bz=0;bA=false;bB="All"bC=true;bD="Off"bE=0.000;bF={}bG={}bH={}bI=false;bJ={VertTakeOff={set=function(M)ba=M end,get=function()return ba end},VertTakeOffEngine={set=function(M)b0=M end,get=function()return b0 end},SpaceTarget={set=function(M)by=M end,get=function()return by end},BrakeToggleStatus={set=function(M)a_=M end,get=function()return a_ end},BrakeIsOn={set=function(M)b1=M end,get=function()return b1 end},RetrogradeIsOn={set=function(M)b2=M end,get=function()return b2 end},ProgradeIsOn={set=function(M)b3=M end,get=function()return b3 end},Autopilot={set=function(M)b4=M end,get=function()return b4 end},TurnBurn={set=function(M)b5=M end,get=function()return b5 end},AltitudeHold={set=function(M)b6=M end,get=function()return b6 end},BrakeLanding={set=function(M)b7=M end,get=function()return b7 end},Reentry={set=function(M)b9=M end,get=function()return b9 end},AutoTakeoff={set=function(M)b8=M end,get=function()return b8 end},HoldAltitude={set=function(M)bb=M end,get=function()return bb end},AutopilotAccelerating={set=function(M)bc=M end,get=function()return bc end},AutopilotBraking={set=function(M)be=M end,get=function()return be end},AutopilotCruising={set=function(M)bf=M end,get=function()return bf end},AutopilotRealigned={set=function(M)bd=M end,get=function()return bd end},AutopilotEndSpeed={set=function(M)bg=M end,get=function()return bg end},AutopilotStatus={set=function(M)bh=M end,get=function()return bh end},AutopilotPlanetGravity={set=function(M)bi=M end,get=function()return bi end},PrevViewLock={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetName={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetCoords={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetIndex={set=function(M)bm=M end,get=function()return bm end},TotalDistanceTravelled={set=function(M)bo=M end,get=function()return bo end},TotalFlightTime={set=function(M)bp=M end,get=function()return bp end},SavedLocations={set=function(M)bq=M end,get=function()return bq end},VectorToTarget={set=function(M)br=M end,get=function()return br end},LocationIndex={set=function(M)bs=M end,get=function()return bs end},LastMaxBrake={set=function(M)bt=M end,get=function()return bt end},LockPitch={set=function(M)bu=M end,get=function()return bu end},LastMaxBrakeInAtmo={set=function(M)bv=M end,get=function()return bv end},AntigravTargetAltitude={set=function(M)bw=M end,get=function()return bw end},LastStartTime={set=function(M)bx=M end,get=function()return bx end},iphCondition={set=function(M)bB=M end,get=function()return bB end},stablized={set=function(M)bC=M end,get=function()return bC end},UseExtra={set=function(M)bD=M end,get=function()return bD end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bF=M end,get=function()return bF end},apRoute={set=function(M)bG=M end,get=function()return bG end},ecuThrottle={set=function(M)bH=M end,get=function()return bH end},HoverMode={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=q;cA=false;cB=W;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2=nil;d3=nil;d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()if shield then dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dh(di)a.print(bQ..": "..di)end;local function dj(d,b,c,a,dk,dl,dm,dn,dp)local function dq(dr)return type(dr)=='number'end;local function ds(dr)return type(dm(dr))=='number'end;local function dt(du)return type(du)=='table'end;local function dv(a)return type(a)=='string'end;local function dw(dx)return dt(dx)and dq(dx.x and dx.y and dx.z)end;local function dy(dz)return dt(dz)and dq(dz.latitude and dz.longitude and dz.altitude and dz.id and dz.systemId)end;local dA=math.pi/180;local dB=180/math.pi;local dC=1e-10;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local utils=utils;local vec3=vec3;local function dF(dr)local dG=string.gsub(string.reverse(dk('%.4f',dr)),'^0*%.?','')return dG==''and'0'or string.reverse(dG)end;local function dH(dI)if dw(dI)then return dk('{x=%.3f,y=%.3f,z=%.3f}',dI.x,dI.y,dI.z)end;if dt(dI)and not getmetatable(dI)then local dJ={}local dK=next(dI)if type(dK)=='nil'or dK==1 then dJ=dI else for dL,dx in pairs(dI)do local dM=dH(dx)if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end end;return dk('{%s}',table.concat(dJ,','))end;if dv(dI)then return dk("'%s'",dI:gsub("'",[[\']]))end;return tostring(dI)end;local dN={}dN.__index=dN;dN.__tostring=function(dI,dO)local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)local dJ={}for dQ,dL in ipairs(dP)do local dM=dH(dI[dL])if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end;if dO then return dk('%s%s',dO,table.concat(dJ,',\n'..dO))end;return dk('{%s}',table.concat(dJ,','))end;dN.__eq=function(dR,dS)return dR.systemId==dS.systemId and dR.id==dS.id and dp(dR.radius,dS.radius)and dp(dR.center.x,dS.center.x)and dp(dR.center.y,dS.center.y)and dp(dR.center.z,dS.center.z)and dp(dR.GM,dS.GM)end;local function dT(dU,dV,dW,dX,dY)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(dW),'Argument 3 (radius) must be a number:'..type(dW))assert(dt(dX),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dX))assert(ds(dY),'Argument 5 (GM) must be a number:'..type(dY))return setmetatable({systemId=dm(dU),id=dm(dV),radius=dm(dW),center=vec3(dX),GM=dm(dY)},dN)end;local dZ={}dZ.__index=dZ;dZ.__tostring=function(dh)return dk('::pos{%d,%d,%s,%s,%s}',dh.systemId,dh.id,dF(dh.latitude*dB),dF(dh.longitude*dB),dF(dh.altitude))end;dZ.__eq=function(dR,dS)return dR.id==dS.id and dR.systemId==dS.systemId and dp(dR.latitude,dS.latitude)and dp(dR.altitude,dS.altitude)and(dp(dR.longitude,dS.longitude)or dp(dR.latitude,math.pi/2)or dp(dR.latitude,-math.pi/2))end;local function d_(e0,dV,e1,e2,e3)local dU=e0;if dv(e0)and not e2 and not e3 and not dV and not e1 then dU,dV,e1,e2,e3=e4(e0,dE)assert(dU,'Argument 1 (position string) is malformed.')else assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(e1),'Argument 3 (latitude) must be in degrees:'..type(e1))assert(ds(e2),'Argument 4 (longitude) must be in degrees:'..type(e2))assert(ds(e3),'Argument 5 (altitude) must be in meters:'..type(e3))end;dU=dm(dU)dV=dm(dV)e1=dm(e1)e2=dm(e2)e3=dm(e3)if dV==0 then return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=dV,systemId=dU},dZ)end;return setmetatable({latitude=dA*dl(e1,-90,90),longitude=dA*(e2%360),altitude=e3,id=dV,systemId=dU},dZ)end;local e5={}e5.__index=e5;e5.__tostring=function(dI,dO)local e6=dO and dO..'  'local e7={}local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)for dQ,e8 in ipairs(dP)do e9=dI[e8]local ea=dN.__tostring(e9,e6)if dO then table.insert(e7,dk('[%s]={\n%s\n%s}',e8,ea,dO))else table.insert(e7,dk('  [%s]=%s',e8,ea))end end;if dO then return dk('\n%s%s%s',dO,table.concat(e7,',\n'..dO),dO)end;return dk('{\n%s\n}',table.concat(e7,',\n'))end;local function eb(ec)local e={}local pid;for dQ,dx in pairs(ec)do local dV=dx.planetarySystemId;if type(dV)~='number'then error('Invalid planetary s ID: '..tostring(dV))elseif pid and dV~=pid then error('Mistringmatch planetary s IDs: '..dV..' and '..pid)end;local ed=dx.bodyId;if type(ed)~='number'then error('Invalid body ID: '..tostring(ed))elseif e[ed]then error('Duplicate body ID: '..tostring(ed))end;setmetatable(dx.center,getmetatable(vec3.unit_x))e[ed]=setmetatable(dx,dN)pid=dV end;return setmetatable(e,e5)end;ee={}local function ef(ec)return setmetatable({galaxyAtlas=ec or{}},ee)end;ee.__index=function(du,M)if type(M)=='number'then local a=du.galaxyAtlas[M]return eb(a)end;return rawget(ee,M)end;ee.__pairs=function(dI)return function(du,dL)local eg,eh=next(du,dL)return eg,eh and eb(eh)end,dI.galaxyAtlas,nil end;ee.__tostring=function(dI)local ei={}for dQ,ej in pairs(dI or{})do local ek=ej:getPlanetarySystemId()local el=e5.__tostring(ej,'    ')table.insert(ei,dk('  [%s]={%s\n  }',ek,el))end;return dk('{\n%s\n}\n',table.concat(ei,',\n'))end;ee.BodyParameters=dT;ee.MapPosition=d_;ee.PlanetarySystem=eb;function ee.createBodyParameters(dU,dV,em,en,eo,ep,eq)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(em),'Argument 3 (surfaceArea) must be a number:'..type(em))assert(dt(en),'Argument 4 (aPosition) must be an array or vec3:'..type(en))assert(dt(eo),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eo))assert(ds(ep),'Argument 6 (altitude) must be in meters:'..type(ep))assert(ds(eq),'Argument 7 (gravityAtPosition) must be number:'..type(eq))local dW=dn(em/4/math.pi)local cb=dW+ep;local er=vec3(en)+cb*vec3(eo)local dY=eq*cb*cb;return dT(dU,dV,dW,er,dY)end;ee.isMapPosition=dy;function ee:getPlanetarySystem(e0)if M==nil then M=0 end;if eh==nil then eh=0 end;local dU=e0;if dy(e0)then dU=e0.systemId end;if type(dU)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eh)~=e5 then a=eb(a)end;return a end end end;function e5:sizeCalculator(es)return 1.05*es.radius end;function e5:castIntersections(et,eu,ev,ew,ex,ey)local ez={}if ex then for dQ,es in pairs(ex)do table.insert(ez,es)end else ez=d4 end;if not ey then table.sort(ez,function(eA,eB)local eC=eA.center;local eD=eB.center;return(eC.x-et.x)^2+(eC.y-et.y)^2+(eC.z-et.z)^2<(eD.x-et.x)^2+(eD.y-et.y)^2+(eD.z-et.z)^2 end)end;local eE=eu:normalize()for dQ,es in ipairs(ez)do local eF=es.center-et;local dW;if ev then dW=ev(es)else dW=self:sizeCalculator(es)end;local eG=eF:dot(eE)local eH=eG^2-(eF:len2()-dW^2)if eH>=0 then local eI=dn(eH)local eJ=eG+eI;local eK=eG-eI;if eK>0 then return es,eJ,eK elseif eJ>0 then return es,eJ,nil end end end;return nil,nil,nil end;function e5:closestBody(eL)assert(type(eL)=='table','Invalid coordinates.')local eM,es;local eN=vec3(eL)for dQ,eO in pairs(self)do local eP=(eO.center-eN):len2()if(not es or eP<eM)and eO.name~="Space"then es=eO;eM=eP end end;return es end;function e5:convertToBodyIdAndWorldCoordinates(e0)local eQ=e0;if dv(e0)then eQ=d_(e0)end;if eQ.id==0 then return 0,vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;local eO=self:getBodyParameters(eQ)if eO then return eQ.id,eO:convertToWorldCoordinates(eQ)end end;function e5:getBodyParameters(e0)local dV=e0;if dy(e0)then dV=e0.id end;assert(ds(dV),'Argument 1 (id) must be a number:'..type(dV))return self[dV]end;function e5:getPlanetarySystemId()local dQ,dx=next(self)return dx and dx.systemId end;function dN:convertToMapPosition(dX)assert(dt(dX),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dX))local eR=vec3(dX)if self.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=self.systemId},dZ)end;local eS=eR-self.center;local cb=eS:len()local e3=cb-self.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=self.id,systemId=self.systemId},dZ)end;function dN:convertToWorldCoordinates(e0)local eQ=dv(e0)and d_(e0)or e0;if eQ.id==0 then return vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;assert(dy(eQ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eQ.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eQ.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eV=math.cos(eQ.latitude)return self.center+(self.radius+eQ.altitude)*vec3(eV*math.cos(eQ.longitude),eV*math.sin(eQ.longitude),math.sin(eQ.latitude))end;function dN:getAltitude(dX)return(vec3(dX)-self.center):len()-self.radius end;function dN:getDistance(dX)return(vec3(dX)-self.center):len()end;function dN:getGravity(dX)local eW=self.center-vec3(dX)local eX=eW:len2()return self.GM/eX*eW/dn(eX)end;return setmetatable(ee,{__call=function(dQ,...)return ef(...)end})end;local function eY(d,b,c,a,dn,eZ)local cp={}local bP=100000000/3600;local e_=bP*bP;local f0=100;function cp.computeAccelerationTime(f1,f2,f3)local f4=bP*math.asin(f1/bP)return(bP*math.asin(f3/bP)-f4)/f2 end;function cp.computeDistanceAndTime(f1,f3,f5,f6,f7,f8)f7=f7 or 0;f8=f8 or 0;local f9=f1<=f3;local fa=f6*(f9 and 1 or-1)/f5;local fb=-f8/f5;local fc=fa+fb;if f9 and fc<=0 or not f9 and fc>=0 then return-1,-1 end;local fd,fe=0,0;if fa~=0 and f7>0 then local f4=math.asin(f1/bP)local ff=math.pi*(fa/2+fb)local fg=fa*f7;local fh=bP*math.pi;local dx=function(du)local fi=(ff*du-fg*math.sin(math.pi*du/2/f7)+fh*f4)/fh;local fj=math.tan(fi)return bP*fj/dn(fj*fj+1)end;local fk=f9 and function(a)return a>=f3 end or function(a)return a<=f3 end;fe=2*f7;if fk(dx(fe))then local fl=0;while eZ(fe-fl)>0.5 do local du=(fe+fl)/2;if fk(dx(du))then fe=du else fl=du end end end;local fm=f1;local fn=fe/f0;for fo=1,f0 do local fp=dx(fo*fn)fd=fd+(fp+fm)*fn/2;fm=fp end;if fe<2*f7 then return fd,fe end;f1=fm end;local f4=bP*math.asin(f1/bP)local bQ=(bP*math.asin(f3/bP)-f4)/fc;local fq=e_*math.cos(f4/bP)/fc;local cb=fq-e_*math.cos((fc*bQ+f4)/bP)/fc;return cb+fd,bQ+fe end;function cp.computeTravelTime(f1,f2,cb)if cb==0 then return 0 end;if f2>0 then local f4=bP*math.asin(f1/bP)local fq=e_*math.cos(f4/bP)/f2;return(bP*math.acos(f2*(fq-cb)/e_)-f4)/f2 end;if f1==0 then return-1 end;assert(f1>0,'Acceleration and initial speed are both zero.')return cb/f1 end;return cp end;local function fr(d,b,c,a,dk,dl,dm,dn,dp)local vec3=vec3;local dj=dj(d,b,c,a,dk,dl,dm,dn,dp)local function dv(a)return type(a)=='string'end;local function dt(du)return type(du)=='table'end;fs={}fs.__index=fs;function fs:escapeAndOrbitalSpeed(e3)assert(self.body)local cb=e3+self.body.radius;if not dp(cb,0)then local ft=dn(self.body.GM/cb)return dn(2)*ft,ft end;return nil,nil end;function fs:orbitalParameters(e0,fu)assert(self.body)assert(dt(e0)or dv(e0))assert(dt(fu))local fv=(dv(e0)or dj.isMapPosition(e0))and self.body:convertToWorldCoordinates(e0)or vec3(e0)local dx=vec3(fu)local fw=fv-self.body.center;local fx=dx:len2()local fy=fw:len()local fz=self.body.GM;local fA=((fx-fz/fy)*fw-fw:dot(dx)*dx)/fz;local eC=fz/(2*fz/fy-fx)local fB=fA:len()local eE=fA:normalize()local fC=eC*(1-fB)local fD=eC*(1+fB)local fE=fC*eE+self.body.center;local fF=fB<=1 and-fD*eE+self.body.center or nil;local fG=dn(eC*fz*(1-fB*fB))local fH=fF and 2*math.pi*dn(eC^3/fz)local fI=math.acos(fA:dot(fw)/(fB*fy))if fw:dot(dx)<0 then fI=-(fI-2*math.pi)end;local fJ=math.acos((math.cos(fI)+fB)/(1+fB*math.cos(fI)))local fK=fJ;if fK<0 then fK=fK+2*math.pi end;local fL=fK-fB*math.sin(fK)local fM=0;local fN=0;local fO=0;if fH~=nil then fM=fL/(2*math.pi/fH)fN=fH-fM;fO=fN+fH/2;if fI-math.pi>0 then fN=fM;fO=fN+fH/2 end;if fO>fH then fO=fO-fH end end;return{periapsis={position=fE,speed=fG/fC,circularOrbitSpeed=dn(fz/fC),altitude=fC-self.body.radius},apoapsis=fF and{position=fF,speed=fG/fD,circularOrbitSpeed=dn(fz/fD),altitude=fD-self.body.radius},currentVelocity=dx,currentPosition=fv,eccentricity=fB,period=fH,eccentricAnomaly=fJ,meanAnomaly=fL,timeToPeriapsis=fN,timeToApoapsis=fO,trueAnomaly=fI}end;local function fP(fQ)local eO=dj.BodyParameters(fQ.systemId,fQ.id,fQ.radius,fQ.center,fQ.GM)return setmetatable({body=eO},fs)end;return setmetatable(fs,{__call=function(dQ,...)return fP(...)end})end;local function fR(d,b,c,a,dbHud_1,e,fS,fT,bN,dm,dn,fU,fV)local function fW(fX)local dh=fY:closestBody(fX)if(fX-dh.center):len()>dh.radius+dh.noAtmosphericDensityAltitude then dh=e[0][0]end;return dh end;local function fZ()local function f_(g0,g1)return g0.name<g1.name end;cU={}for dL,dx in pairs(e[0])do cU[#cU+1]={name=dx.name,index=dL}end;table.sort(cU,f_)end;local function g2(g3,g4)if not g4 then g4=g5.name end;for dL,dx in pairs(g3)do if dx.name and dx.name==g4 then return dL end end;return-1 end;local function g6()d1=bm;if bm==0 then bk="None"c8=nil;g5=nil;return true end;local g7=cU[bm].index;local g8=e[0][g7]if g8.center then bk=g8.name;c8=co[0][g7]if g5~=nil then if ch==0 then if fS(g9,ga)~=1 then fT(g9,ga)end;if fS(gb,gc)~=1 then fT(gb,gc)end;if fS(gd,ge)~=1 then fT(gd,ge)end;if fS(gf,gg)~=1 then fT(gf,gg)end;if fS(gh,gi)~=1 then fT(gh,gi)end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end;if fS(gn,go)~=1 then fT(gn,go)end end;g5=nil else g5=g8;for dQ,dx in pairs(co[0])do if dx.name==g5.planetname then c8=dx;bk=g5.name;break end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end end;if g5==nil then bl=vec3(c8.center)else bl=g5.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gp=bN(c8.radius*(U-1)+c8.noAtmosphericDensityAltitude)else gp=bN(c8.radius*(U-1)+c8.surfaceMaxAltitude)end else gp=T end;if g5~=nil and g5.planetname=="Space"then bg=0 else dQ,bg=cq(c8):escapeAndOrbitalSpeed(gp)end;bi=0;bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"return true end;local function gq(gr)if not b4 and not br and not cd and not bA and not b9 and not ce then if gr==nil then bm=bm+1;if bm>#cU then bm=0 end else bm=bm-1;if bm<0 then bm=#cU end end;if bm==0 then g6()else local g7=cU[bm].index;local g8=e[0][g7]if g8 and(g8~=nil and g8.name=="Space"or bB=="Custom Only"and g8.center or bB=="No Moons-Asteroids"and(string.find(g8.name,"Moon")~=nil or string.find(g8.name,"Asteroid")~=nil))then if gr==nil then gq()else gq(1)end else g6()end end else c3="Disengage autopilot before changing Interplanetary Helper"fU("iph","AP")end end;local function gs()local function gt(gu)local gv;if gu then gv=d9 else gv=bq end;local gw=-1;gw=g2(e[0])if gw>-1 then table.remove(e[0],gw)end;gw=-1;gw=g2(gv)if gw~=-1 then c3=g5.name.." saved location cleared"table.remove(gv,gw)end;gq()fZ()return gv end;if string.sub(bk,1,1)=="*"then d9=gt(true)else bq=gt(false)end end;local function gx(gy,fX,gz,gA)local function gB(gu)if gu then gv=d9 else gv=bq end;if dbHud_1 or gz or gu then local dh=fW(fX)local gC={position=fX,name=gy,planetname=dh.name,gravity=b.getGravityIntensity(),safe=gA}if not gz then gv[#gv+1]=gC else for dL,dx in pairs(e[0])do if dx.name and gy==dx.name then table.remove(e[0],dL)end end end;table.insert(e[0],gC)fZ()g6()c3="Location saved as "..gy.."("..dh.name..")"return gv else c3="Databank must be installed to save permanent locations"end end;if string.sub(gy,1,1)=="*"then d9=gB(true)else bq=gB(false)end end;local gD={}function gD.UpdateAtlasLocationsList()fZ()end;function gD.UpdateAutopilotTarget()g6()end;function gD.adjustAutopilotTargetIndex(gr)gq(gr)end;function gD.findAtlasIndex(g3,g4)return g2(g3,g4)end;function gD.UpdatePosition(gE,gF,gG)local function gH(gu)local gv;if gu then gv=d9 else gv=bq end;local gw=g2(gv)if gw~=-1 then if gE~=nil then if gu then gE="*"..gE end;gv[gw].name=gE;bm=bm-1;gq()elseif gG~=nil then if gG then local gI=ci;if gI<1000 then gI=1000 end;gv[gw].agg=fV(gI,0)c3=gv[gw].name.." AGG Altitude:"..gv[gw].agg.." saved ("..gv[gw].planetname..")"return elseif gG==false then gv[gw].agg=nil;c3=gv[gw].name.." AGG Altitude cleared ("..gv[gw].planetname..")"return end else local gJ=gv[gw]if gF then gJ.heading=cI:cross(cM)*5000;c3=gv[gw].name.." heading saved ("..gv[gw].planetname..")"return elseif gF==false then gJ.heading=nil;c3=gv[gw].name.." heading cleared ("..gv[gw].planetname..")"return end;gJ.gravity=b.getGravityIntensity()gJ.position=cO;gJ.safe=true end;c3=gv[gw].name.." position updated ("..gv[gw].planetname..")"else c3="Name Not Found"end end;if string.sub(bk,1,1)=="*"then gH(true)else gH(false)end end;function gD.AddNewLocation(gy,fX,gz,gA)gx(gy,fX,gz,gA)end;function gD.ClearCurrentPosition()gs()end;for dL,dx in pairs(da)do table.insert(e[0],dx)end;if gK then for dL,dx in pairs(gK)do gD[dL]=dx end end;fZ()if bm>#cU then bm=0 end;gD.UpdateAutopilotTarget()return gD end;local function gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU)local gP={}local gQ={}local gR={XS=13,S=27,M=55,L=110,XL=221}local gS={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gT={}local gU=0;local gV;local gW;local gX=0;local gY;local gZ={gY}local g_="Atmo"local h0;local h1;local h2=0;local h3={}local h4;local h5=0;local h6=table.insert;local h7=-4;local h8={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h9,ha;local hb,hc;local hd;local he;local hf;local hg;local hh;local hi;local hj;local function hk()if hl~=nil and h2==0 then gM(hl)a.destroyWidget(h9)a.destroyData(hb)h9,hb,hl=nil,nil,nil;if h1~=nil then gM(h1)a.destroyWidget(ha)a.destroyData(hc)h1,ha,hc=nil,nil,nil end else if h2==1 then h1=a.createWidgetPanel("PeriWinkle")ha=a.createWidget(h1,'periscope')hc=gY.getWidgetDataId()a.addDataToWidget(hc,ha)end;if hl==nil and gU>0 then hl=a.createWidgetPanel(g_)h9=a.createWidget(hl,'radar')hb=gY.getWidgetDataId()a.addDataToWidget(hb,h9)end;h2=0 end end;local function hm()local function hn(ho,hp,hq,hr,hs,ht,hu,hv)hp,hr,ht,hv=vec3(hp),vec3(hr),vec3(ht),vec3(hv)local hw,hx,hy=ho*ho,hq*hq,hs*hs;local fx=hr-hp;local hz=fx:normalize()local hA=fx:len()local hB=ht-hp;local hC=(hB-hB:project_on(hz)):normalize()local hD,hE=hB:dot(hz),hB:dot(hC)local hF=hD*hD+hE*hE;local hG=hz:cross(hC)local hH=(hw-hx+hA*hA)/(2*hA)local hI=(hw-hy+hF-2*hD*hH)/(2*hE)local dz=hw-hH^2-hI^2;local hJ=dn(dz)local hK=hp+hz*hH+hC*hI+hG*hJ;local hL=hp+hz*hH+hC*hI-hG*hJ;if eZ((hv-hK):len()-hu)<eZ((hv-hL):len()-hu)then return hK else return hL end end;local function hM(hN,fy,hO)local hP=hN.pts;local gw=#hP;local hQ=hN.ref;if gw>3 then local hR,hS,hT,hU=hP[gw],hP[gw-1],hP[gw-2],hP[gw-3]hN.ref=hO;local fv=hn(hR[1],hR[2],hS[1],hS[2],hT[1],hT[2],hU[1],hU[2])local hH,hI,hJ=fv.x,fv.y,fv.z;if hH==hH and hI==hI and hJ==hJ then hH=hH+hQ[1]hI=hI+hQ[2]hJ=hJ+hQ[3]local hV=vec3(hH,hI,hJ)hN.center=hV;if hN.lastPos then if(hN.lastPos-hV):len()<2 then local hW=(hV-vec3(hO)):len()if eZ(hW-fy)<10 then hN.skipCalc=true end end end;hN.lastPos=hV end;hN.pts={}else local hX={hO[1]-hQ[1],hO[2]-hQ[2],hO[3]-hQ[3]}hP[gw+1]={fy,hX}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gY then if#h4>0 then local hY,hZ=0,0;local h_=cL*10;local cY=cY;gX,gW=0,0;gQ={}for dQ,dx in pairs(h4)do local cb=hh(dx)if cb>0.0 then if hd(dx)==1 then h6(gQ,dx)end;if not cV and warpdrive and cb<aa and warpdrive.getStatus()==15 then c3="INITIATING WARP"c4=7;warpdrive.initiate()end;local i0=F and hf(dx)==1;if E or i0 then local i1=hi(dx)local i2=gR[i1]local i3=he(dx)if i0 or cb<h_ and(i2>27 or i3==4 or i3==6)then gX=gX+1;local hO={cO["x"],cO["y"],cO["z"]}local hN=h3[dx]if hN==nil then i2=i2+gO;h3[dx]={pts={},ref=hO,name=hg(dx),i=0,radius=i2,skipCalc=false}hN=h3[dx]end;if not hN.skipCalc then if i0 or i3==4 or i3==6 then hN.center=vec3(hj(dx))hN.skipCalc=true else hM(hN,cb,hO)hZ=hZ+1 end;if i0 and not hN.abandoned then local bQ=a.getArkTime()if h5+5<bQ then h5=bQ;fU("abRdr","RD")end;a.print("Abandoned Construct: "..hN.name.." ("..i1 .." "..gS[i3]..") at ::pos{0,0,"..hN.center.x..","..hN.center.y..","..hN.center.z.."}")c3="Abandoned Radar Contact ("..i1 .." "..gS[i3]..") detected"hN.abandoned=true end else h6(gT,hN)end end;hY=hY+1;if hY>300 or hZ>30 then coroutine.yield()hY,hZ=0,0 end end end end;gW=#gT;if gW>0 and(cL>20 or b7)then local es,i4,i5,i6;local i7=0;local i8=co:getPlanetarySystem(0)i6=cK:normalize()while i7<gW do coroutine.yield()local i9={table.unpack(gT,i7,math.min(i7+75,gW))}es,i4,i5=i8:castIntersections(cO,i6,nil,nil,i9,true)if es and i5 then c_={es,i4,i5}break end;i7=i7+75 end;if not es then c_=nil end else c_=nil end;gT={}gV=gY.getTargetId()end end end;local function ia()if gY then g_="Atmo"if string.find(gY.getName(),"Space")then g_="Space"end end end;function gP.pickType()ia()end;function gP.assignRadar()if radar_2 and h7~=1 then if h7==-1 then if gY==radar_2 then gY=radar_1 else gY=radar_2 end end;gZ={gY}hd=gY.hasMatchingTransponder;he=gY.getConstructKind;hf=gY.isConstructAbandoned;hg=gY.getConstructName;hh=gY.getConstructDistance;hi=gY.getConstructCoreSize;hj=gY.getConstructWorldPos;h4=gY.getConstructIds()ia()else h4=gY.getConstructIds()end;h7=gY.getOperationalState()end;function gP.UpdateRadar()local ib=coroutine.status(h0)if ib=="suspended"then local dM,ic=coroutine.resume(h0)if ic then a.print("ERROR UPDATE RADAR: "..ic)end elseif ib=="dead"then h0=coroutine.create(hm)local dM,ic=coroutine.resume(h0)end end;function gP.GetRadarHud(id,ie,ay,az)local ig,di;local dD=gW or 0;gU=#h4;if gU>0 then if E then di=dD.."/"..gX.." Known/InRange : "..gU.." Total"else di="Radar Contacts: "..gU end;ig=gN(ay,az,di,"pbright txtbig txtmid")if#gQ>0 then ig=ig..gN(id,ie,"Friendlies In Range","pbright txtbig txtmid")for dL,dx in pairs(gQ)do ie=ie+20;ig=ig..gN(id,ie,gY.getConstructName(dx),"pdim txtmid")end end;local ih=#gY.getIdentifiedConstructIds()if h1==nil and ih>0 then h2=1;cu.ToggleRadarPanel()end;if h1~=nil and ih==0 then cu.ToggleRadarPanel()end;if hl==nil then if w then cu.ToggleRadarPanel()end end else if h7~=1 then ig=gN(ay,az,g_.." Radar: "..h8[h7],"pbright txtbig txtmid")else ig=gN(ay,az,"Radar: No "..g_.." Contacts","pbright txtbig txtmid")end;if hl~=nil then h2=0;cu.ToggleRadarPanel()end end;return ig end;function gP.GetClosestName(gy)if gY then local ii=gY.getConstructName(gY.getConstructIds()[1])if ii then gy=gy.." "..ii end end;return gy end;function gP.ToggleRadarPanel()hk()end;function gP.ContactTick()if not ij then ij=0 end;if bQ>ij+10 then c3="Radar Contact"fU("rdrCon","RC")ij=bQ end;c.stopTimer("contact")end;function gP.onEnter(dV)if gY and not cg and not cV then c.setTimer("contact",0.1)end end;function gP.onLeave(dV)if gY and E then if#h3>650 then dV=tostring(dV)h3[dV]=nil end end end;local function ik()gY=nil;if radar_2 and radar_2.getOperationalState()==1 then gY=radar_2 else gY=radar_1 end;h7=gY.getOperationalState()hd=gY.hasMatchingTransponder;he=gY.getConstructKind;hf=gY.isConstructAbandoned;hg=gY.getConstructName;hh=gY.getConstructDistance;hi=gY.getConstructCoreSize;hj=gY.getConstructWorldPos;gZ={gY}h4=gY.getConstructIds()ia()h0=coroutine.create(hm)if il then for dL,dx in pairs(il)do gP[dL]=dx end end end;ik()return gP end;local function im(shield,e4,bN)local io={}local ip=shield.getResistancesCooldown()local function iq()local ir=shield.isActive()if G then if not cV and ir==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and ir==1 then shield.toggle()end end end;local function is()local it=shield.getStressRatioRaw()local iu=0.5999;if it[1]==0.0 and it[2]==0.0 and it[3]==0.0 and it[4]==0.0 then return end;local iv=shield.setResistances(iu*it[1],iu*it[2],iu*it[3],iu*it[4])if iv==1 then c3="Shield Resistances updated"else c3="Value Exceeded. Failed to update Shield Resistances"end end;function io.shieldTick()dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())iq()ip=shield.getResistancesCooldown()if ip==0 and dg<a9 then is()end end;function io.setResist(iw)if not shield then c3="No shield found"return elseif iw==nil or ip>0 then c3="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE=dD..', '..dD..', '..dD..', '..dD;local ix,iy,iz,iA=e4(iw,dE)if iA==nil or ix+iy+iz+iA>0.6 then c3="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(ix,iy,iz,iA)==1 then c3="Shield Resistances set"else c3="Resistance setting failed."end end;function io.ventShield()local iB=shield.getVentingCooldown()if iB>0 then c3="Cannot vent again for "..iB.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c3="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c3="Shields already at max hitpoints"end end;if iC then for dL,dx in pairs(iC)do io[dL]=dx end end;return io end;local function iD(d,b,c,a,e,antigrav,hover,shield,warpdrive,iE,eZ,bN,dk,iF,bO,iG,iH,eU,bM,dl,iI,fT,fS,gM,iJ,dn,fV,gN,fU,iK,iL,iM,iN,iO,iP)local bP=DUConstruct;local iQ=9.80665;local iR={}local iS={}local iT={}local iU={}local iV=nil;local iW=nil;local iX=nil;local iY=false;local iZ="none"local i_=""local j0=55;local j1=0;local j2=0;local j3=nil;local j4=ag;local j5=ah;local j6=ai;local j7=[[rgb(]]..bN(j4+0.5)..","..bN(j5+0.5)..","..bN(j6+0.5)..[[)]]local j8=[[rgb(]]..bN(j4*0.9+0.5)..","..bN(j5*0.9+0.5)..","..bN(j6*0.9+0.5)..[[)]]local j9=0;local ja=0;local jb=""local jc=bM()local jd=false;local je=false;local gY=false;local function jf(dx)if ad==1920 then return dx else return fV(ad*dx/1920,0)end end;local function jg(dx)if ae==1080 then return dx else return fV(ae*dx/1080,0)end end;local function jh()return iJ()==0 and g~="keyboard"and iH()==0 end;local function ji()local jj="TRAVEL"if not cR then jj="CRUISE"end;if b4 then jj="AUTOPILOT"end;return jj end;local ig=""local jk=""local jl=""local jm=1;local jn=2;local jo=3;local jp=4;local jq=5;local jr=6;local js=7;local jt=""local ju=0;local jv=90.0*aU;local jw={}local jx={}local jy={}local jz={}local jA={}local jB={}local jC={}jC["atmofueltank"],jC["spacefueltank"],jC["rocketfueltank"]=0,0,0;local jD=0;local function jE(hH,jF,jG,jH,jI,jJ)local jK=jD;local jL=jD+5;if not B then jL=jL+5 end;if iH()==1 and not m then jK=jK-50;jL=jL-50 end;if jG=="ATMO"then jt="atmofueltank"elseif jG=="SPACE"then jt="spacefueltank"else jt="rocketfueltank"end;ju=_G[jt.."_size"]if#jH>0 then for M=1,#jH do local gy=jH[M][jn]local jM=jH[M][js]for jN=1,ju do if jH[M][jn]==iF(c[jt.."_"..jN].getWidgetData()).name then jM=jN;break end end;local jO=bM()if jI[M]==nil or jJ[M]==nil or jO-jH[M][jr]>jv then local jP;local jQ=0;jQ=iG(jH[M][jm])-jH[M][jp]jP=jH[M][jq]local jR=jP>jQ or false;if jR then jC[jt]=jC[jt]+jP-jQ end;if jM~=0 then local jS=iF(c[jt.."_"..jM].getWidgetData())jJ[M]=jS.percentage;jI[M]=jS.timeLeft;if jI[M]=="n/a"then jI[M]=0 end else jJ[M]=bN(0.5+jQ*100/jH[M][jo])if jR then jI[M]=bN(0.5+jQ/((jP-jQ)/(jO-jH[M][jr])))else jI[M]=0 end end;jH[M][jr]=jO;jH[M][jq]=jQ end;if gy==jF then gy=dk("%s %d",jG,M)end;if jM==0 then gy=gy.." *"end;local jT;jT=iN(jI[M])if jI[M]==0 or jT==">1y"then jT=""end;if jJ[M]~=nil then local jU=bN(jJ[M]*2.55)local jV=dk("rgb(%d,%d,%d)",255-jU,jU,0)local jW=""if jT~=""and jI[M]<120 or jJ[M]<5 then jW="red "end;local jX=dk("rgb(%d,%d,%d)",dl(bN((255-jU)/2.55),50,100),dl(bN(jU/2.55),0,50),50)local jY="rgb(196,0,255)"if jG=="ATMO"then jY="rgb(0,188,255)"elseif jG=="SPACE"then jY="rgb(239,255,0)"end;local jZ=false;if j_~=jY then jZ=true end;j_=jY;if B then if jZ then jK=jK-5;jL=jL-5 end;jk=jk..dk([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jX,jY,hH,jL,jV,bN(jJ[M]*1.7+0.5)-2,hH+1,jL+1,hH+5,jL+14,gy,jJ[M],jT)jK=jK-22;jL=jL-22 else jk=jk..gN(hH,jK,gy,jW.."pdim txtfuel")jk=jk..gN(hH,jL,dk("%d%% %s",jJ[M],jT),"pdim txtfuel","fill:"..jV)jK=jK+30;jL=jL+30 end end end end;jD=jK end;local function k0(k1,e3)if aq==0 and ar==0 then return end;if e3<200000 and not cg or e3 and cg then local k2=0;if eZ(cN)>1 then k2=45*math.log(eZ(cN),10)if cN<0 then k2=-k2 end end;k1[#k1+1]=dk([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bN(cN),bN(k2))end;return k1 end;local function k3(k4)local gr=-cM;k4=k4-k4:project_on(gr)local k5=vec3(0,0,1)k5=k5-k5:project_on(gr)local k6=k5:cross(gr)local k2=k5:angle_between(k4)*constants.rad2deg;if k4:dot(k6)<0 then k2=360-k2 end;return k2 end;local function k7(k1,am,an,k8,k9,cY)if af==0 then return end;local ka=af;local kb=20;local kc=bN(k8)if cY then for M=-45,45,5 do local kd=M;k1[#k1+1]=dk([[<g transform="rotate(%f,%d,%d)">]],kd,am,an)ke=5;if M%15==0 then ke=15 elseif M%10==0 then ke=10 end;k1[#k1+1]=dk([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+ka+kb-ke,am,an+ka+kb)end;k1[#k1+1]=gN(am,an+ka+kb-35,k9,"pdim txt txtmid")k1[#k1+1]=gN(am,an+ka+kb-25,kc.." deg","pdim txt txtmid")k1[#k1+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k8,am,an)k1[#k1+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+ka+kb-20,am+5,an+ka+kb-20,am,an+ka+kb-15)k1[#k1+1]="</g>"end;k1[#k1+1]=[[<g style="clip-path: url(#headingClip);">]]local kf=kc;if cY then kf=k3(cH)end;local kg=20;local kh=bN(kf)local ki=0;local kj=an+ka+kb+20;local kk=am;if k9~="YAW"then kj=jg(130)kk=jf(960)end;local kl=[[<path class="txttick line" d="]]local km=bN(kh-(kg+10)-kh%5+0.5)for M=km+70,km,-5 do local hH=kk-(-M*5+kf*5)if M%10==0 then ki=10;local dD=M;if dD==360 then dD=0 elseif dD>360 then dD=dD-360 elseif dD<0 then dD=dD+360 end;k1[#k1+1]=gN(hH,kj+15,dD,"txtmid bright")elseif M%5==0 then ki=5 end;if ki==10 then kl=dk([[%s M %f %f v %d]],kl,hH,kj-5,ki)else kl=dk([[%s M %f %f v %d]],kl,hH,kj-2.5,ki)end end;k1[#k1+1]=kl..[["/>]]k1[#k1+1]=dk([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kk-5,kj-20,kk+5,kj-20,kk,kj-10)if cY then k9="HDG"end;k1[#k1+1]=gN(jf(960),jg(100),kh.."°","dim txt txtmid size14","")k1[#k1+1]=gN(jf(960),jg(85),k9,"dim txt txtmid size20","")k1[#k1+1]=[[</g>]]end;local function kn(k1,ko,k8,am,an,cY,kp,fp)if af==0 then return end;local ka=af;local kq=bN(ka*3/5)if ka>0 then local kr=bN(ko)local ke=0;local kl=dk([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k8,am,an)if not cg then kl=dk([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;k1[#k1+1]=dk([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],ka-1,am,an)k1[#k1+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(kr-30-kr%5+0.5),bN(kr+30+kr%5+0.5),5 do if M%10==0 then ke=30 elseif M%5==0 then ke=20 end;local hI=an+-M*5+ko*5;if ke==30 then kl=dk([[%s M %d %f h %d]],kl,am-kq-ke,hI,ke)if cg then k1[#k1+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k8,am,an,am-kq+10,hI+4,M)k1[#k1+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k8,am,an,am+kq-10,hI+4,M)if M==0 or M==180 or M==-180 then k1[#k1+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k8,am,an,am-kq+20,hI,kq*2-40)end else k1[#k1+1]=gN(am-kq+10,hI,M,"pdim txt txtmid")k1[#k1+1]=gN(am+kq-10,hI,M,"pdim txt txtmid")end;kl=dk([[%s M %d %f h %d]],kl,am+kq,hI,ke)else kl=dk([[%s M %d %f h %d]],kl,am-kq-ke,hI,ke)kl=dk([[%s M %d %f h %d]],kl,am+kq,hI,ke)end end;k1[#k1+1]=kl..[["/>]]local ks="PITCH"if not cY then ks="REL PITCH"end;if ko>90 and not cg then ko=90-(ko-90)elseif ko<-90 and not cg then ko=-90-(ko+90)end;if ka>200 then if cg then if fp>j0 then k1[#k1+1]=gN(am,an-15,"Yaw","pdim txt txtmid")k1[#k1+1]=gN(am,an+20,kp,"pdim txt txtmid")end;k1[#k1+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k8,am,an)else k1[#k1+1]=dk([[<g transform="rotate(0,%d,%d)">]],am,an)end;k1[#k1+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-kq+25,an-5,am-kq+20,an,am-kq+25,an+5,am-kq+50,an+4,kr)k1[#k1+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+kq-25,an-5,am+kq-20,an,am+kq-25,an+5,am+kq-30,an+4,kr)k1[#k1+1]="</g>"end;local kt=bN(ka/3)k1[#k1+1]=dk([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-kt,an,ka-kt)if not cg and cY then k1[#k1+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k8,am,an,am-kq+10,an,kq*2-20)end;k1[#k1+1]="</g>"if ka<200 then if cg and fp>j0 then k1[#k1+1]=gN(am,an-ka,ks,"pdim txt txtmid")k1[#k1+1]=gN(am,an-ka+10,kr,"pdim txt txtmid")k1[#k1+1]=gN(am,an-15,"Yaw","pdim txt txtmid")k1[#k1+1]=gN(am,an+20,kp,"pdim txt txtmid")else k1[#k1+1]=gN(am,an-ka,ks,"pdim txt txtmid")k1[#k1+1]=gN(am,an-ka+15,kr,"pdim txt txtmid")end end end end;local function ku(k1,e3,cY)local kv=as;local kw=at;if kv==0 and kw==0 then return end;local kx=78;local ky=19;local kz=cf;if cf~=-1 then k1[#k1+1]=gN(kv+kx,kw+ky+20,dk("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(e3<200000 and not cg or e3 and cg)then table.insert(k1,dk([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kv-1,kw-4,kx+2,ky+6,kv+1,kw-1,kx-4,ky))local gw=0;local kA=1;local kB=0;local kC=e3<0;local kD=e3<kE.surfaceMaxAltitude;local kF=9;if kC then kF=0 end;local e3=eZ(e3)while gw<6 do local kG=11;local kH=16;local kI=9;local kJ=14;local jW="altsm"if gw>2 then kH=kH+3;kG=kG+2;kJ=kJ+2;kI=kI-6;jW="altbig"end;if kC then jW=jW.." red"elseif kD then jW=jW.." orange"end;local kK=e3/kA%10;local kL=bN(kK)local kM=bN((kL+1)%10)local kN=kB;if gw==0 then kN=kK-kL;if kC then kN=1-kN end end;if kC and(gw==0 or kB~=0)then local gz=kM;kM=kL;kL=gz end;local kO=kH*(kN-1)local kP=kO+kH;local hH=kv+kI+(6-gw)*kG;local hI=kw+kJ;k1[#k1+1]=gN(hH,hI+kO,kM,jW)k1[#k1+1]=gN(hH,hI+kP,kL,jW)gw=gw+1;kA=kA*10;if kL==kF then kB=kN else kB=0 end end;table.insert(k1,[[</g></g>]])end end;local function kQ(fu)local kR=-math.deg(eU(fu.y,fu.z))+180;kR=kR-90;if kR<0 then kR=360+kR end;if kR>180 then kR=-180+kR-180 end;return-kR end;local function kS(fu)local kf=math.deg(eU(fu.y,fu.x))-90;if kf<-180 then kf=360+kf end;return kf end;local function kT(k1,fu,fp,am,an)if fp>5 and not cg or fp>j0 then local ka=af;local kU=20;local kV=20;local kW=kQ(fu)local kX=kS(fu)local kY=14;local kZ=kY/2;local k_=-kX/kV*ka;local l0=kW/kU*ka;local hH=am+k_;local hI=an+l0;local cb=dn(k_^2+l0^2)local l1=[[<circle
                            cx="]]..hH..[["
                            cy="]]..hI..[["
                            r="]]..kZ/kY..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hH..[["
                            cy="]]..hI..[["
                            r="]]..kZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hH-kY..[[,]]..hI..[[ h ]]..kZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hH+kZ..[[,]]..hI..[[ h ]]..kZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hH..[[,]]..hI-kY..[[ v ]]..kZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<ka then k1[#k1+1]=l1 else local k2=eU(l0,k_)local l2=4;local l3=am+ka*math.cos(k2)local l4=an+ka*math.sin(k2)k1[#k1+1]=dk('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',k2*180/math.pi,l3,l4,l3-l2,l4-l2/2,l2*2,l2,l3+l2,l4-l2,l2,l2,-l2,l2)end;if not cg then local l5=vec3(fu)kW=kQ(-l5)kX=kS(-l5)k_=-kX/kV*ka;l0=kW/kU*ka;hH=am+k_;hI=an+l0;cb=dn(k_^2+l0^2)if cb<ka then local l6=[[<circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hH..[[,]]..hI-kY..[[ v ]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hH..[[,]]..hI..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hH..[[,]]..hI..[[)" />
                                <path
                                    d="M ]]..hH-kZ..[[,]]..hI..[[ h ]]..kY..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hH..[[,]]..hI..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hH..[[,]]..hI..[[)"/>]]k1[#k1+1]=l6 end end end end;local function l7(k1,jj,l8,l9)if ao==0 and ap==0 then return end;l8=bN(l8+0.5)local jK=ap+10;local jL=ap+20;if iH()==1 and not m then jK=55;jL=65 end;local la="CRUISE"local c="km/h"local dM=l9;if jj=="TRAVEL"or jj=="AUTOPILOT"then la="THROT"c="%"dM=l8;local lb="dim"if l8<0 then lb="red"end;k1[#k1+1]=dk([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],lb,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-eZ(l8),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;k1[#k1+1]=gN(ao+10,jK,la,"pbright txtstart")k1[#k1+1]=gN(ao+10,jL,dk("%.0f %s",dM,c),"pbright txtstart")if cg and t and cR and bT then l8=bN(bU*100+0.5)local lb="red"if l8<0 then lb="red"end;k1[#k1+1]=dk([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],lb,1-eZ(l8),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)k1[#k1+1]=gN(ao+10,jK+40,"LIMIT","pbright txtstart")k1[#k1+1]=gN(ao+10,jL+40,l8 .."%","pbright txtstart")end;if cg and t or b9 then k1[#k1+1]=gN(ao+10,jK-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b4 then k1[#k1+1]=gN(ao+10,jK-40,"LIMIT: "..bN(a1*3.6+0.5).." km/h","dim txtstart")end end;local function lc(k1,ld)if ao==0 and ap==0 then return end;local le=ap-10;local lf=ao+10;k1[#k1+1]=gN(0,0,"","pdim txt txtend")if iH()==1 and not m then le=75 end;k1[#k1+1]=gN(lf,le,bN(ld).." km/h","pbright txtbig txtstart")end;local lg=40;local function lh(k1)k1[#k1+1]=gN(jf(150),jg(1070),dk("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")k1[#k1+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then k1[#k1+1]=gN(jf(960),jg(550),"Warning: Invalid Control Scheme Detected","warnings")k1[#k1+1]=gN(jf(960),jg(600),"Keyboard Scheme must be selected","warnings")k1[#k1+1]=gN(jf(960),jg(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local li=jf(960)local lj=jg(860)local lk=jg(880)local ll=jg(900)local lm=jg(960)local ln=jg(200)local lo=jg(250)local lp=jg(960)if iH()==1 and not m then lj=jg(135)lk=jg(155)ll=jg(175)ln=jg(115)lo=jg(95)end;if b1 then local lq=""if type(b1)=="string"then lq="-"..b1 end;k1[#k1+1]=gN(li,lj,"Brake Engaged"..lq,"warnings")elseif bS>0 then k1[#k1+1]=gN(li,lj,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b4 and not br and not b7 and not cQ and not ba and not b8 then k1[#k1+1]=gN(li,ln+50,"** STALL WARNING **","warnings")fU("stall","SW",2)end end;if cX then k1[#k1+1]=gN(li,ln+90,"Flight Assist in Progress","warnings")end;if ck then k1[#k1+1]=gN(li,lp,"Gyro Enabled","warnings")end;if lr then lg=lg-1;if lg>20 then k1[#k1+1]=gN(li,lp-20,"ECU Enabled","warnings")elseif lg<0 then lg=40 end end;if bn then if bW then k1[#k1+1]=gN(li,lk,"Gear Extended","warn")else k1[#k1+1]=gN(li,lk,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local ls=iM(d:getTargetGroundAltitude())k1[#k1+1]=gN(li,ll,"Hover Height: "..ls,"warn")end;if c5 then k1[#k1+1]=gN(li,lm+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cQ and bw~=nil then local lt="warnings"if eZ(ci-antigrav.getBaseAltitude())<501 then lt="warn"end;k1[#k1+1]=gN(li,ln+40,dk("Target Altitude: %d Singularity Altitude: %d",bN(bw),bN(antigrav.getBaseAltitude())),lt)end;if b4 and bk~="None"then k1[#k1+1]=gN(li,ln,"Autopilot "..bh,"warn")elseif bu~=nil then k1[#k1+1]=gN(li,ln+20,dk("LockedPitch: %d",bN(bu)),"warn")elseif c0 then k1[#k1+1]=gN(li,ln+20,"Follow Mode Engaged","warn")elseif b9 or ce then k1[#k1+1]=gN(li,ln+20,"Re-entry in Progress","warn")end;if b6 or ba then local ls=iM(bb,2)if ba then if cQ then ls=iM(antigrav.getBaseAltitude(),2).." AGG singularity height"end;k1[#k1+1]=gN(li,ln,"VTO to "..ls,"warn")elseif b8 and not bA then if cd then k1[#k1+1]=gN(li,ln,"Takeoff to "..bk,"warn")else k1[#k1+1]=gN(li,ln,"Takeoff to "..ls,"warn")end;if b1 and not ba then k1[#k1+1]=gN(li,ln+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else k1[#k1+1]=gN(li,ln,"Altitude Hold: "..dk("%.1fm",bb),"warn")end end;if ba and(antigrav~=nil and antigrav)then if ch>0.1 then k1[#k1+1]=gN(li,ln+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then k1[#k1+1]=gN(li,ln+20,"Aligning trajectory","warn")elseif ch<0.05 then k1[#k1+1]=gN(li,ln+20,"Leaving atmosphere","warn")end end;if bA then if cC~=nil then k1[#k1+1]=gN(li,ln,cC,"warn")end end;if b7 then if lu then local lv="Brake Landing"if dc then lv=lv.."-Aligning"end;if db then lv=lv.."-Drift Limited"end;k1[#k1+1]=gN(li,ln,lv,"warnings")else k1[#k1+1]=gN(li,ln,"Coast-Landing","warnings")end end;if b3 then k1[#k1+1]=gN(li,ln+20,"Prograde Alignment","crit")end;if b2 then k1[#k1+1]=gN(li,ln,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;k1[#k1+1]=gN(li,lo+20,cZ,type)elseif ch==0 then local lw,lx=ct.checkLOS(cK:normalize())if lx~=nil then local ls=iM(lx)local ly=cp.computeTravelTime(cL,0,lx)local lz="Collision"if lw.noAtmosphericDensityAltitude>0 then lz="Atmosphere"end;k1[#k1+1]=gN(li,lo+20,lw.name.." "..lz.." "..iN(ly).." In "..ls,"crit")end end;if br and not bA then k1[#k1+1]=gN(li,ln+60,lA,"warn")end;if d2 and#d2>1 then end;local lB=jf;local lC=jg;local lD="topButton"local lE="topButtonActive"local lF=lD;if b4 or br or cd or bA then lF=lE end;local lG=lD;if b3 then lG=lE end;local lH=lD;if b7 or bn then lH=lE end;local lI=lD;if b6 or br then lI=lE end;local lJ=lD;if b2 then lJ=lE end;local lK=lD;if bA or cE and b4 then lK=lE end;if w and I then local lL=lC(30)k1[#k1+1]=dk([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lF,lB(960),lC(54),lC(-53),lB(-120),lB(25),lC(50))k1[#k1+1]=gN(lB(910),lL,"AUTOPILOT")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lB(865),lC(51),lB(-25),lC(-50),lB(-110),lB(25),lC(46))k1[#k1+1]=gN(lB(800),lL,"PROGRADE")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,lB(755),lC(47),lB(-25),lC(-46),lB(-98),lB(44),lC(44))k1[#k1+1]=gN(lB(700),lL,"LAND")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lI,lB(960),lC(54),lC(-53),lB(120),lB(-25),lC(50))k1[#k1+1]=gN(lB(1010),lL,"ALT HOLD")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lB(1055),lC(51),lB(25),lC(-50),lB(110),lB(-25),lC(46))k1[#k1+1]=gN(lB(1122),lL,"RETROGRADE")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lK,lB(1165),lC(47),lB(25),lC(-46),lB(98),lB(-44),lC(44))k1[#k1+1]=gN(lB(1220),lL,"ORBIT")k1[#k1+1]=[[
                                    </g>
                                </g>]]k1[#k1+1]="</g>"end;return k1 end;local function lM(fp)return bN(fV(fp*3.6,0)+0.5).." km/h"end;local function lN(gw)local gy=bk;if gw~=nil and type(gw)=="number"then if gw==0 then return"None"end;gy=cU[gw].name end;if gy==nil then gy=g5.name end;if gy==nil then gy="None"end;return gy end;local function lO(k1)local lP=ct.routeWP(true)if not lP or#lP==0 then return end;local hH=jf(750)local hI=jg(360)if b4 or br then k1[#k1+1]=gN(hH,hI,"REMAINING ROUTE","pdim txtstart size20")else k1[#k1+1]=gN(hH,hI,"LOADED ROUTE","pdim txtstart size20")end;for dL,M in pairs(lP)do hI=hI+20;k1[#k1+1]=gN(hH,hI,dL..". "..lP[dL],"pdim txtstart size20")end end;local function lQ(k1)local hH=aC+10;local hI=aD+20;local lR={}local lS={"Alt-4: AutoTakeoff to Target"}local lT={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lU={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lV={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lR,"--------------DYNAMIC-----------------")if cg then if cf~=-1 then iK(lR,lS)if c8 and kE and c8.name==kE.name then table.insert(lR,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b0 then if antigrav then if cQ then table.insert(lR,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lR,"Turn on AGG to takeoff to AGG Height")end end;if b0 then table.insert(lR,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lR,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lR,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bn then table.insert(lR,"G: Takeoff to hover height, raise gear")else table.insert(lR,"G: Lowergear and Land")end else iK(lR,lT)table.insert(lR,"G: Begin BrakeLanding or Land")end;if ba then table.insert(lR,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iK(lR,lU)if shield then table.insert(lR,"Alt-Shift-6: Vent shields")if not G then table.insert(lR,"Alt-Shift-7: Toggle shield off/on")end end end;if g5~=nil then table.insert(lR,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lR,"Alt-9: Activate Gyroscope")end;if aX~="none"or aW~="none"or aY~="none"then table.insert(lR,"Alt-Shift-9: Cycles engines with Extra tags")end;if b6 then table.insert(lR,"Alt-Spacebar/C will raise/lower target height")table.insert(lR,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cg then table.insert(lR,"LALT+Mousewheel will lower/raise speed limit")end;iK(lR,lV)for M=1,#lR do hI=hI+12;k1[#k1+1]=gN(hH,hI,lR[M],"pdim txtbig txtstart")end end;local function lW(k1)local lX=aC;local lY=aD;local lZ=aB;local l_=4;local m0=15;local hH=0;local hI=0;local m1,m2,m3,m4;local m5;local function m6(type)local gI,bQ,fp,m7,jW,m8;if type=="Periapsis"then gI=m5.periapsis.altitude;bQ=m5.timeToPeriapsis;fp=m5.periapsis.speed;jW="txtend"m7=12;m8=math.min(hH,lX+lZ-kE.radius/m3-l_*2)else gI=m5.apoapsis.altitude;bQ=m5.timeToApoapsis;fp=m5.apoapsis.speed;m7=-12;jW="txtstart"m8=hH end;if cL<1 then bQ=0 end;k1[#k1+1]=dk([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m8+m7,hI-5,hH,hI-5)k1[#k1+1]=dk([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m8-m7*4,hI+2,hH,hI+2)k1[#k1+1]=gN(m8,hI,type,jW)hH=m8-m7*2;hI=hI+m0;local ls=iM(gI)k1[#k1+1]=gN(hH,hI,ls,jW)hI=hI+m0;k1[#k1+1]=gN(hH,hI,iN(bQ),jW)hI=hI+m0;k1[#k1+1]=gN(hH,hI,lM(fp),jW)end;local m9=lZ*1.5;if bK=="INFO"then m9=25*10 end;if bK=="ORBIT"and ci<kE.spaceEngineMinAltitude then return k1 end;if bK~="HIDE"then k1[#k1+1]=[[<g class="pbright txtorb txtmid">]]k1[#k1+1]=dk('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lZ*2,m9,lX,lY)k1[#k1+1]=dk([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lZ*2,m9,lX,lY)end;local ma=lZ*1.5;local mb=lZ*2;local mc=ma/2;local md=lZ;local me=lX+md;local mf=lY+mc;local mg=lX+mb;local mh=lY+ma;if bK=="ORBIT"then lY=lY+l_;m1=lZ/2;m4=0;m5={}m5.periapsis={}m5.apoapsis={}if ft~=nil then if ft.periapsis~=nil then m5.periapsis.altitude=ft.periapsis.altitude;m5.periapsis.speed=ft.periapsis.speed end;if ft.apoapsis~=nil then m5.apoapsis.altitude=ft.apoapsis.altitude;m5.apoapsis.speed=ft.apoapsis.speed end;m5.period=ft.period;m5.eccentricity=ft.eccentricity;m5.timeToApoapsis=ft.timeToApoapsis;m5.timeToPeriapsis=ft.timeToPeriapsis;m5.eccentricAnomaly=ft.eccentricAnomaly;m5.trueAnomaly=ft.trueAnomaly end;if m5.periapsis==nil then m5.periapsis={}m5.periapsis.altitude=-kE.radius;m5.periapsis.speed=a1 end;if m5.eccentricity==nil then m5.eccentricity=1 end;if m5.apoapsis==nil then m5.apoapsis={}m5.apoapsis.altitude=ci;m5.apoapsis.speed=0 end;if cL<1 then m5.apoapsis.altitude=ci;m5.apoapsis.speed=0 end;if m5.apoapsis.altitude then m3=(m5.apoapsis.altitude+m5.periapsis.altitude+kE.radius*2)/(m1*2)m2=(kE.radius+m5.apoapsis.altitude)/m3*(1-m5.eccentricity)m4=m1-m5.periapsis.altitude/m3-kE.radius/m3;local mi=math.pi;if m5.period~=nil and m5.period>0 and m5.timeToApoapsis~=nil then mi=m5.eccentricAnomaly;if m5.timeToPeriapsis<m5.timeToApoapsis then mi=2*math.pi-mi end end;if cL<1 or mi~=mi then mi=math.pi end;local mj=-m1*math.cos(mi)+lX+md+l_;local mk=m2*math.sin(mi)+lY+mc+l_;local ml=""k1[#k1+1]='<g clip-path="url(#orbitRect)">'k1[#k1+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ml,lX+lZ+l_,lY+lZ*1.5/2+l_,m1,m2)if m2<1 then k1[#k1+1]=dk([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lX+lZ+l_-m4,lY+lZ*1.5/2+l_,mj,mk)end;k1[#k1+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,(kE.radius+kE.noAtmosphericDensityAltitude)/m3)k1[#k1+1]=dk('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,(kE.radius+kE.noAtmosphericDensityAltitude)/m3)k1[#k1+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lX+lZ+l_,lY+lZ*1.5/2+l_,m1,m2)k1[#k1+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,kE.radius/m3)k1[#k1+1]='</g>'local mm=math.floor(kE.radius/m3+0.5)hH=lX+lZ+l_*4+m1;hI=lY+lZ*1.5/2+5+l_;if m5.apoapsis~=nil and m5.apoapsis.speed<a1 then m6("Apoapsis")end;hI=lY+lZ*1.5/2+5+l_;hH=lX+lZ-l_*2-m1;if m5.periapsis~=nil and m5.periapsis.speed<a1 and m5.periapsis.altitude>0 then m6("Periapsis")end;k1[#k1+1]=gN(lX+lZ+l_,lY+20+l_,kE.name,"txtorbbig")k1[#k1+1]=dk('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mj,mk)k1[#k1+1]=[[</g>]]return k1 else k1[#k1+1]='<g clip-path="url(#orbitRect)">'local mn=""local mo=1.2*(mp-mq)/(lZ*2)local mr=1.4*(ms-mt)/(lZ*1.5)for dL,dx in pairs(e[0])do if dx.center then local hH=lX+lZ+dx.center.x/mo;local hI=lY+lZ*1.5/2+dx.center.y/mr;mn=mn..'<circle cx="'..hH..'" cy="'..hI..'" r="'..dx.radius/mo*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dx.name,"Moon")and not string.match(dx.name,"Sanctuary")and not string.match(dx.name,"Space")then mn=mn.."<text x='"..hH.."' y='"..hI+dx.radius/mo*30+20 .."' font-size='12' fill="..j7 .." text-anchor='middle' font-family='Montserrat'>"..dx.name.."</text>"end end end;local fv=vec3(bP.getWorldPosition())local hH=lX+lZ+fv.x/mo;local hI=lY+lZ*1.5/2+fv.y/mr;mn=mn..'<circle cx="'..hH..'" cy="'..hI..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mn=mn.."<text x='"..hH.."' y='"..hI-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iV=mo;iW=mr;local mu=fv+cK*1000000;local mv=lX+lZ+mu.x/mo;local jL=lY+lZ*1.5/2+mu.y/mr;mn=mn..'<line x1="'..hH..'" y1="'..hI..'" x2="'..mv..'" y2="'..jL..'" stroke="purple" stroke-width="1"/>'k1[#k1+1]=mn;k1[#k1+1]='</g>'end elseif bK=="INFO"then k1=cr.DrawOdometer(k1,j9,bo,ja)elseif bK=="HELP"then k1=lQ(k1)elseif bK=="SCOPE"then k1[#k1+1]='<g clip-path="url(#orbitRect)">'local mw=d5;if ch>0 then table.sort(d4,function(eA,eB)local eC,eD=eA.center,eB.center;return(eC.x-cO.x)^2+(eC.y-cO.y)^2+(eC.z-cO.z)^2<(eD.x-cO.x)^2+(eD.y-cO.y)^2+(eD.z-cO.z)^2 end)end;local mx={}local my={}local mz=120;local mA=nil;local mB=nil;for M,dx in ipairs(d4)do local gV=dx.center-cO;local mC=gV:len()local mD=gV:normalize()local mE=gV:cross(cH):normalize()local mF=math.acos(mE:dot(cI))if mF~=mF then mF=0 end;if mE:cross(cI):dot(cH)<0 then mF=-mF end;local mG=gV:project_on_plane(cH):len()local mH=math.sin(mF)*math.asin(mG/mC)*constants.rad2deg;local mI=math.cos(mF)*math.asin(mG/mC)*constants.rad2deg;if mD:dot(cH)<0 then mI=90*math.cos(mF)+90*math.cos(mF)-mI;mH=90*math.sin(mF)+90*math.sin(mF)-mH end;local hH=me+mH/mw*ma;local hI=mf+mI/mw*ma;local mJ=(hH-me)*(hH-me)+(hI-mf)*(hI-mf)local mK=math.asin((dx.radius+dx.surfaceMaxAltitude)/mC)*constants.rad2deg;if mK~=mK then mK=mw end;local i1=mK/mw*ma;local mL=math.asin(dx.atmosphereRadius/mC)*constants.rad2deg;if mL~=mL then mL=mK end;local mM=mL/mw*ma;local cb=iM(mC,1)local mN=dx.name;local mO=false;if hI>lY then if hI>mh then if hI-mM<=mh then mO=true end else mO=true end else if hI+mM>=lY then mO=true end end;local mP=false;local mQ=hH;if dx.systemId==0 then mQ=hH+mz else mQ=hH-mz end;if mQ+mz>lX then if mQ+mz>mg then if mQ-mM-mz<=mg then mP=true end else mP=true end else if mQ+mM+mz>=lX then mP=true end end;local mR={}mR.x=hH;mR.y=hI;mR.planet=dx;mR.atmoSize=mM;if not mA or mJ<mA then mA=mJ;mB=mR end;if mP and mO then local mS=math.max(mM,5)if mJ<mS*mS then mN=mN.." - "..cb end;mR.size=i1;mR.i=M;mR.displayString=mN;mR.distance=cb;mR.visible=true;my[#my+1]=mR else mR.visible=false end end;local mT=false;table.sort(my,function(eC,eD)return eC.y<eD.y end)for dL,fy in ipairs(my)do local dx,i1,M,mM,hH,hI,mN,cb=fy.planet,fy.size,fy.i,fy.atmoSize,fy.x,fy.y,fy.displayString,fy.distance;local m8,mU,mV,mW;local mX=15;local jW="pdim"if dx.systemId~=0 then mV=jf(string.len(mN)*5)mX=-(15+mV)mW=jg(10)jW="pdimfill"else mV=jf(string.len(mN)*9)mW=jg(15)end;if i1*2>mV then m8=dl(hH,lX+mV/2,mg-mV/2)mU=dl(hI,lY+mW,mh-5)m8=dl(m8,hH-i1+mV/2,hH+i1-mV/2)mU=dl(mU,hI-i1+mW,hI+i1)else m8=hH+mX;mU=hI end;for mY,fy in pairs(mx)do local mZ=fy.textPositions;local m_=mZ.y-mU;if mY~=M and eZ(m_)<mZ.height and mZ.x+mZ.width>m8 and mZ.x<m8+mV then if i1>mV then mU=dl(mU+mW,lY+15,mh-5)else mU=mZ.y+mZ.height+1 end end end;local n0=mN~=dx.name or m8<=me and m8+mV>=me and mU-mW<=mf and mU>=mf;fy.hovered=n0;local n1=1;if n0 then n1=2;if i1*2<mV then n1=10 end;if mN==dx.name then mN=mN.." - "..cb end;jW="pbright"if dx.systemId~=0 then mV=jf(string.len(mN)*5)mX=-(15+mV)else mV=jf(string.len(mN)*7)end;if i1*2>mV then m8=dl(hH,lX+mV/2,mg-mV/2)m8=dl(m8,hH-i1+mV/2,hH+i1-mV/2)else m8=hH+mX end end;mx[M]={}mx[M].textPositions={}mx[M].textPositions.y=mU;mx[M].textPositions.x=m8;mx[M].textPositions.width=mV;mx[M].textPositions.height=mW;mx[M].output=""if i1*2>mV then jW=jW.." txtmid"else jW=jW.." txtstart"end;if mM-i1>2 then mx[M].output=dk('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hH,hI,mM,j8,0.1*n1)end;mx[M].output=mx[M].output..dk('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hH,hI,i1,j8,0.2*n1)if dx.systemId==0 then mx[M].output=mx[M].output..dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m8,mU,j7,jW,mN)if i1*2<=mV then mx[M].output=mx[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m8+mV,mU+2,m8,mU+2,hH,hI)end else mx[M].output=mx[M].output..dk([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m8,mU,j8,jW,mN)if i1*2<=mV then mx[M].output=mx[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m8,mU+2,m8+mV,mU+2,hH,hI)end end end;for dL=#d4,1,-1 do if mx[dL]then k1[#k1+1]=mx[dL].output end end;if mB~=nil and d5<90 and not mB.hovered then local n2=mB.planet.atmosphereRadius/mB.atmoSize;local n3=dn(mA)*n2;local n4=iM(n3,1)local mV=jf(math.max(string.len(n4)*7,string.len(mB.planet.name)*7))local mW=jg(12)local m8=dl(mB.x+(me-mB.x)/2,lX+mV/2,mg-mV/2)local mU=dl(mB.y+(mf-mB.y)/2,lY+mW*2,mh-5)k1[#k1+1]=dk("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mB.x,mB.y,me,mf)k1[#k1+1]=dk([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m8,mU,"white",n4)if not mB.visible then k1[#k1+1]=dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m8,mU-mW,"white",mB.planet.name)end end;if cL>1 then local gV=cK;local mD=gV:normalize()local mG=gV:project_on_plane(cH):len()local mE=gV:cross(cH):normalize()local mF=math.acos(mE:dot(cI))if mF~=mF then mF=0 end;if mE:cross(cI):dot(cH)<0 then mF=-mF end;local mH=math.sin(mF)*math.asin(mG/gV:len())*constants.rad2deg;local mI=math.cos(mF)*math.asin(mG/gV:len())*constants.rad2deg;if mD:dot(cH)<0 then mI=90*math.cos(mF)+90*math.cos(mF)-mI;mH=90*math.sin(mF)+90*math.sin(mF)-mH end;local hH=me+mH/mw*ma;local hI=mf+mI/mw*ma;local kY=14;local kZ=kY/2;local l1=[[<circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kZ/kY..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hH-kY..[[,]]..hI..[[ h ]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hH+kZ..[[,]]..hI..[[ h ]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hH..[[,]]..hI-kY..[[ v ]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]k1[#k1+1]=l1 end;k1[#k1+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",me,mf-10,me,mf+10)k1[#k1+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",me-10,mf,me+10,mf)k1[#k1+1]='</g>'else return k1 end end;local function n5(n6,n7)local n8;local n9=(n7-n6):normalize()local fw=(cO-n6):dot(n9)/n9:dot(n9)if fw<=0. then return(cO-n6):len()elseif fw>=(n7-n6):len()then return(cO-n7):len()end;local na=n6+fw*n9;n8=(na-cO):len()return n8 end;local function nb()local n8;local nc=nil;local nd=nil;local ne=nil;for dL,nf in pairs(e[0])do if nf.hasAtmosphere then local cb=n5(kE.center,nf.center)if nc==nil or cb<nc then nd=nf;nc=cb;ne=kE end;if c8 and c8.hasAtmosphere and c8.name~=kE.name then local eP=n5(c8.center,nf.center)if eP<nc then nd=nf;nc=eP;ne=c8 end end end end;local ng=jf(1770)local nh=jg(330)if nc then local ni="txttick "local nj=500000;if nc<nd.radius+nj or nc<ne.radius+nj then if cV then ni="txttick red "else ni="txttick orange "end end;n8=iM(nc,2)i_=gN(ng,nh,"Pipe ("..ne.name.."--"..nd.name.."): "..n8,ni.."pbright txtmid")end end;local function nk(hH,hI,nl,nm,la)local nn={x=hH,y=hI,width=nl,height=nm,label=la}iU[la]=nn;return nn end;local function no(np,nq,nl,nm,hH,hI,nr,ns,nt,nu,jW)local nn={enableName=np,disableName=nq,width=nl,height=nm,x=hH,y=hI,toggleVar=nr,toggleFunction=ns,drawCondition=nt,hovered=false,class=jW}if nu then table.insert(iT,nn)else table.insert(iS,nn)end;return nn end;local function nv(nw)if not iY then nx=false;ny=false;nz=false;w=true;return elseif nw=="handling"then nx=not nx;ny=false;nz=false elseif nw=="hud"then ny=not ny;nx=false;nz=false elseif nw=="physics"then nz=not nz;nx=false;ny=false end;if nz or ny or nx then iZ=iL(nw)w=false else iZ="none"w=true end end;local function nA()iY=not iY;if iY then iR=iT;c3="Tap LMB to see Settings"d6=w else iR=iS;c3="Tap LMB to see Control Buttons"nv()w=d6 end end;local function nB()local function nC(dx,dL)dx.set(not dx.get())if dx.get()then c3=dL.." set to true"else c3=dL.." set to false"end;if dL=="showHud"then d6=dx.get()elseif dL=="BrakeToggleDefault"then a_=k end end;local nD=50;local nE=340;local hH=500;local hI=ae/2-400;local nF=0;for dL,dx in pairs(iL("boolean"))do if type(dx.get())=="boolean"then no(dL,dL,nE,nD,hH,hI,function()return dx.get()end,function()nC(dx,dL)end,function()return true end,true)hI=hI+nD+20;if nF==9 then hH=hH+nE+20;hI=ae/2-400;nF=0 else nF=nF+1 end end end;no("Control View","Control View",nE,nD,10,ae/2-500,function()return true end,nA,function()return true end,true)no("View Handling Settings",'Hide Handling Settings',nE,nD,10,ae/2-(500-nD),function()return nx end,function()nv("handling")end,function()return true end,true)no("View Hud Settings",'Hide Hud Settings',nE,nD,10,ae/2-(500-nD*2),function()return ny end,function()nv("hud")end,function()return true end,true)no("View Physics Settings",'Hide Physics Settings',nE,nD,10,ae/2-(500-nD*3),function()return nz end,function()nv("physics")end,function()return true end,true)end;local function nG()local function gx()local fX=cO;local gy=kE.name..". "..#bq;if cu then gy=cu.GetClosestName(gy)end;return cs.AddNewLocation(gy,fX,false,true)end;local function nH()b5=not b5 end;local function nI(nJ)if nJ==1 then b3=not b3;b2=false else b2=not b2;b3=false end;b4=false;b6=false;c0=false;b7=false;bu=nil;b9=false;b8=false end;local function nK(nL,nM)cs.UpdatePosition(nil,nL,nM)end;local function gs()cs.ClearCurrentPosition()end;local function nN(gw)local lP=ct.routeWP(true)if lP and#lP>0 then return"Engage Route: "..lP[1]end;return"Engage Autopilot: "..lN(gw)end;local function nO(gw)local lP=ct.routeWP(true)if lP and#lP>0 then return"Next Route Point: "..lP[1]end;return"Disable Autopilot: "..lN(gw)end;local function nP()if iH()==1 then c0=not c0;if c0 then b4=false;b2=false;b3=false;b6=false;b9=false;b7=false;b8=false;nQ=bn;bn=false;d.control.retractLandingGears()iI:setTargetGroundAltitude(Z)fU("folOn","F")else fU("folOff","F")b1="Follow Off"cz=q;bn=nQ;if bn then d.control.deployLandingGears()iI:setTargetGroundAltitude(_)end end else c3="Follow Mode only works with Remote controller"c0=false end end;local nD=50;local nE=260;local nR=jf(30)local nS=aC+aB*2+2;local nT=aD+1;no("+","+",nR,nR,nS,nT+nR+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")no("-","-",nR,nR,nS,nT,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")no("0","0",nR,nR,nS,nT+nR*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nU=no("Enable Brake Toggle","Disable Brake Toggle",nE,nD,ad/2-nE/2,ae/2+350,function()return a_ end,function()a_=not a_;if a_ then c3="Brakes in Toggle Mode"else c3="Brakes in Default Mode"end end)no("Align Prograde","Disable Prograde",nE,nD,ad/2-nE/2-50-nU.width,ae/2-nD+380,function()return b3 end,function()nI(1)end)no("Align Retrograde","Disable Retrograde",nE,nD,ad/2-nE/2+nU.width+50,ae/2-nD+380,function()return b2 end,nI,function()return ch==0 end)nV=no(nN,nO,600,60,ad/2-600/2,ae/2-60/2-330,function()return b4 or br or cd or bA end,function()end)local M;local function nW(nX)local gw=d1+nX;if gw>#cU then gw=gw-#cU-1 end;if gw<0 then gw=#cU+gw end;return gw end;nY={}for M=0,10 do local nZ=no(function(eD)local gw=nW(eD.apExtraIndex)if b4 or br or cd or bA then return"Redirect: "..lN(gw)end;return nN(gw)end,function(eD)local gw=nW(eD.apExtraIndex)return nO(gw)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eD)local gw=nW(eD.apExtraIndex)return gw==bm and(b4 or br or cd or bA)end,function(eD)local gw=nW(eD.apExtraIndex)local n_=bm==gw;bm=gw;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not n_ and not(b4 or br or cd or bA)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nZ.apExtraIndex=M;nY[M]=nZ end;no("Save Position","Save Position",200,nV.height,nV.x+nV.width+30,nV.y,function()return false end,gx,function()return bm==0 or g5==nil end)no("Update Position","Update Position",200,nV.height,nV.x+nV.width+30,nV.y,function()return false end,function()nK(nil)end,function()return bm>0 and g5~=nil end)no("Save Heading","Clear Heading",200,nV.height,nV.x+nV.width+30,nV.y+nV.height+20,function()return g5.heading~=nil end,function()if g5.heading~=nil then nK(false)else nK(true)end end,function()return bm>0 and g5~=nil end)no("Save AGG Alt","Clear AGG Alt",200,nV.height,nV.x+nV.width+30,nV.y+nV.height*2+40,function()return g5.agg~=nil end,function()if g5.agg~=nil then nK(nil,false)else nK(nil,true)end end,function()return bm>0 and g5~=nil and antigrav end)no("Clear Position","Clear Position",200,nV.height,nV.x-200-30,nV.y,function()return true end,gs,function()return bm>0 and g5~=nil end)no("Save Route","Save Route",200,nV.height,nV.x-200-30,nV.y+nV.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)no("Load Route","Clear Route",200,nV.height,nV.x-200-30,nV.y+nV.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b4 or br then c3="Disable Autopilot before loading route"return else ct.routeWP(false,false,1)end end,function()return true end)nD=60;nE=300;local hH=0;local hI=ae/2-150;no("Enable Check Damage","Disable Check Damage",nE,nD,hH,hI-nD-20,function()return s end,function()s=not s end)no("View Settings","View Settings",nE,nD,hH,hI,function()return true end,nA)hI=hI+nD+20;no("Enable Turn and Burn","Disable Turn and Burn",nE,nD,hH,hI,function()return b5 end,nH)hH=10;hI=ae/2-300;no("Horizontal Takeoff Mode","Vertical Takeoff Mode",nE,nD,ad/2-nE/2,hI+20,function()return b0 end,function()b0=not b0;if b0 then c3="Vertical Takeoff Mode"else c3="Horizontal Takeoff Mode"end end,function()return cP end)hI=hI+nD+20;no("Engage Orbiting","Cancel Orbiting",nE,nD,hH+nE+20,hI,function()return bA end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hI=ae/2-150;no("Glide Re-Entry","Cancel Glide Re-Entry",nE,nD,hH+nE+20,hI,function()return b9 end,function()cc=1;nI(1)end,function()return kE.hasAtmosphere and not cg end)hI=hI+nD+20;no("Parachute Re-Entry","Cancel Parachute Re-Entry",nE,nD,hH+nE+20,hI,function()return b9 end,function()cc=2;nI(1)end,function()return kE.hasAtmosphere and not cg end)hI=hI+nD+20;no("Engage Follow Mode","Disable Follow Mode",nE,nD,hH,hI,function()return c0 end,nP,function()return iH()==1 end)no("Enable Repair Arrows","Disable Repair Arrows",nE,nD,hH+nE+20,hI,function()return jd end,function()jd=not jd;if jd then c3="Repair Arrows Enabled"else c3="Repair Arrows Diabled"end end,function()return iH()==1 end)hI=hI+nD+20;if not r then no("Enable AGG","Disable AGG",nE,nD,hH,hI,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;no(function()return dk("Switch IPH Mode - Current: %s",bB)end,function()return dk("IPH Mode: %s",bB)end,nE*2,nD,hH,hI,function()return false end,function()if bB=="All"then bB="Custom Only"elseif bB=="Custom Only"then bB="No Moons-Asteroids"else bB="All"end;c3="IPH Mode: "..bB end)hI=hI+nD+20;no(function()return dk("Toggle Control Scheme - Current: %s",g)end,function()return dk("Control Scheme: %s",g)end,nE*2,nD,hH,hI,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c3="New Control Scheme: "..g end)local o0=jg(20)local nZ=nk(0,0,jf(70),o0,"HELP")nZ=nk(nZ.x+nZ.width,nZ.y,jf(80),o0,"INFO")nZ=nk(nZ.x+nZ.width,nZ.y,jf(70),o0,"ORBIT")nZ=nk(nZ.x+nZ.width,nZ.y,jf(70),o0,"SCOPE")nk(nZ.x+nZ.width,nZ.y,jf(70),o0,"HIDE")end;local o1={}local o2=nil;function o1.HUDPrologue(k1)if not cV then j4=aj;j5=ak;j6=al else j4=ag;j5=ah;j6=ai end;j7=[[rgb(]]..bN(j4+0.6)..","..bN(j5+0.6)..","..bN(j6+0.6)..[[)]]j8=[[rgb(]]..bN(j4*0.8+0.5)..","..bN(j5*0.8+0.5)..","..bN(j6*0.8+0.5)..[[)]]local o3=j7;local o4=j8;local o5=[[rgb(]]..bN(j4*0.4+0.5)..","..bN(j5*0.4+0.5)..","..bN(j6*0.4+0.5)..[[)]]local o6=j7;local o7=j8;local o8=o5;if jh()and not n then o3=[[rgb(]]..bN(j4*0.5+0.5)..","..bN(j5*0.5+0.5)..","..bN(j6*0.5+0.5)..[[)]]o4=[[rgb(]]..bN(j4*0.3+0.5)..","..bN(j5*0.3+0.5)..","..bN(j6*0.2+0.5)..[[)]]o5=[[rgb(]]..bN(j4*0.2+0.5)..","..bN(j5*0.2+0.5)..","..bN(j6*0.2+0.5)..[[)]]end;local lB=jf;local lC=jg;k1[#k1+1]=dk([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o3,o3,o3,o6,o6,o4,o4,o7,o7,o4,o3,o5,o7,o3,o3,o5,o5,o8,o5,ad,ae,o4,o4,o4,o4,o4,o6,o4,o7,o8,o7,o7,o8)if not o2 then o2=dk([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lB(630),lC(0),lB(675),lC(45),lB(960),lC(55),lB(1245),lC(45),lB(1290),lC(0),lB(1000),lC(105),lB(1040),lC(59),lB(1250),lC(51),lB(1300),lC(0),lB(1920),lC(0),lB(1920),lC(20),lB(1400),lC(20),lB(1300),lC(105),lB(920),lC(105),lB(880),lC(59),lB(670),lC(51),lB(620),lC(0),lB(0),lC(0),lB(0),lC(20),lB(520),lC(20),lB(620),lC(105),lB(890),lC(59),lB(960),lC(62),lB(1030),lC(59),lB(985),lC(112),lB(1150),lC(112),lB(1100),lC(152),lB(820),lC(152),lB(780),lC(112),lB(935),lC(112),lB(890),lC(59),lB(960),lC(62),lB(1030),lC(59),lB(985),lC(112),lB(1150),lC(112),lB(1100),lC(152),lB(820),lC(152),lB(780),lC(112),lB(935),lC(112))end;if w and I then k1[#k1+1]=o2 end;return k1 end;function o1.DrawVerticalSpeed(k1,e3)k0(k1,e3)end;function o1.UpdateHud(k1)local kR=cS;local o9=cT;local k8=o9;local ko=kR;local l8=bN(c.getThrottle())local ld=cL*3.6;local l9=c.getAxisCommandValue(0)local oa=jf(1770)local ob=jg(310)if t and cR then l9=bR;l8=bR*100 end;local jj=ji()local k9="ROLL"if l8==nil then l8=0 end;if not cY then if cL>5 then kR=kQ(cJ)o9=kS(cJ)else kR=0;o9=0 end;k9="YAW"end;if cW>50000 and not cg then local oc;oc=iM(cW)k1[#k1+1]=gN(oa,ob,"PvP Boundary: "..oc,"pbright txtbig txtmid")end;k1[#k1+1]=jb;k1[#k1+1]=ig;if i_~=""then k1[#k1+1]=i_ end;if jk~=""then k1[#k1+1]=jk end;if jl~=""then k1[#k1+1]=jl end;k0(k1,ci)if iH()==0 or m then if not jh()or n then if cY then k7(k1,am,an,k8,k9,cY)kn(k1,ko,k8,am,an,cY,bN(kS(cJ)),cL)else k7(k1,am,an,o9,k9,cY)kn(k1,kR,o9,am,an,cY,bN(o9),cL)end;ku(k1,ci,cY)kT(k1,cJ,cL,am,an)end end;l7(k1,jj,l8,l9)lc(k1,ld)lh(k1)lW(k1)if not iY and c1 then lO(k1)end;return k1 end;function o1.HUDEpilogue(k1)k1[#k1+1]="</svg>"return k1 end;function o1.ExtraData(k1)local od=jf(1240)local oe=jg(55)local of=oe+10;local og;local lB=jf;local lC=jg;local oh=0;local jj=ji()if b0 then jj=jj.."-VERTICAL"end;if E and gY and not b8 and not b7 and cL>20 then jj=jj.."-COLLISION ON"end;if bD~="Off"then jj="("..bD..")-"..jj end;if b5 then jj="TB-"..jj end;if bI then jj="HOVERMODE-"..jj end;if not bC then jj=jj.."-DeCoupled"end;local oi=lC(99)local oj=lC(80)local ok=lC(85)local ol=lC(31)local om=0;local on=0;local oo=cj>1000000 and fV(cj/1000000,2).."kT"or fV(cj/1000,2).."T"if cg then oh=bv else oh=bt end;local op,oq=cp.computeDistanceAndTime(cL,0,cj,0,0,oh)if op<0 then op=0 end;oh=fV(oh/(cj*iQ),2).."g"local os=d:maxForceForward()og=b.getGravityIntensity()if og>0.1 then on=cj*og;on=fV(on/(cj*iQ),2).."g"om=0.5*os/og;om=om>1000000 and fV(om/1000000,2).."kT"or fV(om/1000,2).."T"end;os=fV(os/(cj*iQ),2).."g"local ot=vec3(bP.getWorldAcceleration()):len()/9.80665;og=b.getGravityIntensity()k1[#k1+1]=[[<g class="dim txt txtend size14">]]if iH()==1 and not m then od=jf(1120)oe=jg(55)of=oe+10 elseif cg and I then local ou=jf(770)k1[#k1+1]=gN(lB(895),oi,"ATMO","")k1[#k1+1]=dk([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lB(895),ok,lB(-80))k1[#k1+1]=gN(lB(815),oj,dk("%.1f%%",ch*100),"txtstart size20")end;if I then k1[#k1+1]=gN(lB(1025),oi,"GRAVITY","txtstart")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1025),ok,lB(80))k1[#k1+1]=gN(lB(1105),oj,dk("%.2fg",og/9.80665),"size20")k1[#k1+1]=gN(lB(1125),oi,"ACCEL","txtstart")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1125),ok,lB(80))k1[#k1+1]=gN(lB(1205),oj,dk("%.2fg",ot),"size20")k1[#k1+1]=gN(lB(695),oi,"BRK TIME","")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(695),ok,lB(-80))k1[#k1+1]=gN(lB(615),oj,dk("%s",iN(oq)),"txtstart size20")k1[#k1+1]=gN(lB(635),lC(45),"TRIP","")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(635),lC(31),lB(-90))if ly then k1[#k1+1]=gN(lB(545),lC(26),dk("%s",iN(ly)),"txtstart size20")end;k1[#k1+1]=gN(lB(795),oi,"BRK DIST","")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(795),ok,lB(-80))k1[#k1+1]=gN(lB(715),oj,dk("%s",iM(op)),"txtstart size20")k1[#k1+1]=gN(lB(1285),lC(45),"MASS","txtstart")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1285),lC(31),lB(90))k1[#k1+1]=gN(lB(1375),lC(26),dk("%s",oo),"size20")k1[#k1+1]=gN(lB(1220),oi,"THRUST","txtstart")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1220),ok,lB(80))k1[#k1+1]=gN(lB(1300),oj,dk("%s",os),"size20")k1[#k1+1]=gN(jf(960),jg(175),jj,"pbright txtbig txtmid size20")end;k1[#k1+1]="</g>"end;local ov=1-(a7*0.05+a8*0.05)function o1.FuelUsed(ow)local ox;if ow=="atmofueltank"then ox=dk("Atmo Fuel Used: %.1f L",jC[ow]/(4*ov))elseif ow=="spacefueltank"then ox=dk("Space Fuel Used: %.1f L",jC[ow]/(6*ov))else ox=dk("Rocket Fuel Used: %.1f L",jC[ow]/(0.8*ov))end;return ox end;local oy,oz,oA,oB,oC=0,0,0,{},0;local oD=0;local oE=0;local oF=0;function o1.DrawOdometer(k1,j9,bo,ja)if bK~="INFO"then return k1 end;local og;local oh=0;local on=0;local oo=cj>1000000 and fV(cj/1000000,2).." kTons"or fV(cj/1000,2).." Tons"if cg then oh=bv else oh=bt end;local op,oq=cp.computeDistanceAndTime(cL,0,cj,0,0,oh)oh=fV(oh/(cj*iQ),2).." g"local os=d:maxForceForward()og=b.getGravityIntensity()if cL<5 then local oG=vec3(bP.getOrientationForward())local oH=bP.getMaxThrustAlongAxis('thrust analog longitudinal ',{oG:unpack()})oD=0.5*oH[1]/og;oD=oD>1000000 and fV(oD/1000000,1).." kTons"or fV(oD/1000,1).." Tons"oE=0.5*oH[3]/og;oE=oE>1000000 and fV(oE/1000000,1).." kTons"or fV(oE/1000,1).." Tons"oG=vec3(bP.getOrientationUp())oH=bP.getMaxThrustAlongAxis('hover_engine, booster_engine',{oG:unpack()})oF=0.5*oH[1]/og;oF=oF>1000000 and fV(oF/1000000,1).." kTons"or fV(oF/1000,1).." Tons"end;if og>0.1 then on=cj*og;on=fV(on/(cj*iQ),2).." g"else on="n/a"end;os=fV(os/(cj*iQ),2).." g"if iH()==0 or m then local oI=jf(aC+10)local oJ=jg(aD+20)local oK=jf(aC+10+aB/1.25)local nm=25;local oL=bN(1/aU)if oA<oL then oC=oC+a.getActionUpdateDeltaTime()oA=oA+1 else oy=1/(oC/oL)table.insert(oB,oy)oA,oC=0,0 end;oz=0;for dL,dx in pairs(oB)do oz=oz+dx end;if#oB>0 then oz=bN(oz/#oB)end;if#oB>29 then table.remove(oB,1)end;k1[#k1+1]="<g class='txtstart size14 bright'>"k1[#k1+1]=gN(oI,oJ,dk("BrkTime: %s",iN(oq)))k1[#k1+1]=gN(oK,oJ,dk("Trip: %.2f km",j9))k1[#k1+1]=gN(oI,oJ+nm,dk("Lifetime: %.2f kSU",bo/200000))k1[#k1+1]=gN(oK,oJ+nm,dk("BrkDist: %s",iM(op)))k1[#k1+1]=gN(oI,oJ+nm*2,"Trip Time: "..iN(ja))k1[#k1+1]=gN(oK,oJ+nm*2,"Total Time: "..iN(bp))k1[#k1+1]=gN(oI,oJ+nm*3,dk("Mass: %s",oo))k1[#k1+1]=gN(oK,oJ+nm*3,dk("Max Brake: %s",oh))k1[#k1+1]=gN(oI,oJ+nm*4,dk("Max Thrust: %s",os))k1[#k1+1]=gN(oK,oJ+nm*4,dk("Safe Atmo Mass: %s",oD))k1[#k1+1]=gN(oI,oJ+nm*5,dk("Req Thrust: %s",on))k1[#k1+1]=gN(oK,oJ+nm*5,dk("Safe Space Mass: %s",oE))k1[#k1+1]=gN(oK,oJ+nm*6,dk("Safe Hover Mass: %s",oF))k1[#k1+1]=gN(oI,oJ+nm*7,dk("Set Max Speed: %s",bN(a1*3.6+0.5)))k1[#k1+1]=gN(oK,oJ+nm*7,dk("Actual Max Speed: %s",bN(df*3.6+0.5)))k1[#k1+1]=gN(oI,oJ+nm*8,dk("Friction Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))k1[#k1+1]=gN(oK,oJ+nm*8,dk("FPS (Avg): %s (%s)",bN(oy),oz))end;k1[#k1+1]="</g></g>"return k1 end;function o1.DrawWarnings(k1)return lh(k1)end;function o1.DisplayOrbitScreen(k1)return lW(k1)end;function o1.DisplayMessage(k1,ls)if ls~="empty"then local hI=310;for lv in string.gmatch(ls,"([^\n]+)")do hI=hI+35;k1[#k1+1]=gN("50%",hI,lv,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;function o1.DrawDeadZone(k1)k1[#k1+1]=dk([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function o1.UpdatePipe()if cg then i_=""return end;nb()end;function o1.DrawSettings(k1)local hH=jf(640)local hI=jg(200)k1[#k1+1]=[[<g class="pbright txtvspd txtstart">]]local hY=0;for dL,dx in pairs(iZ)do hY=hY+1;k1[#k1+1]=gN(hH,hI,dL..": "..dx.get())hI=hI+20;if hY%12==0 then hH=hH+jf(350)hI=jg(200)end end;k1[#k1+1]=gN(jf(640),jg(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")k1[#k1+1]="</g>"return k1 end;local ie=jg(125)local id=jf(1225)function o1.DrawRadarInfo()ig=cu.GetRadarHud(id,ie,ay,az)if ig then gY=true end end;function o1.DrawTanks()if au~=0 and av~=0 then jk=gN(au,av,"","txtstart pdim txtfuel")jD=av;jE(au,"Atmospheric ","ATMO",cl,jA,jB)jE(au,"Space Fuel T","SPACE",cm,jy,jz)jE(au,"Rocket Fuel ","ROCKET",cn,jw,jx)end end;function o1.DrawShield()local ir=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oM=bP.getPvPTimer()local oN=shield.getResistances()local oO="A: "..10+oN[1]*100 .."% / E: "..10+oN[2]*100 .."% / K:"..10+oN[3]*100 .."% / T: "..10+oN[4]*100 .."%"local hH,hI=aw-60,ax+30;local jU=bN(dg*2.55)local jV=dk("rgb(%d,%d,%d)",255-jU,jU,0)local jW=""jl=gN(hH,hI,"","txtmid pdim txtfuel")if dg<10 and ir~="Shield Disabled"then jW="red "end;oM=oM>0 and"   PvPTime: "..iN(oM)or""jl=jl..dk([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hH,hI,jV,dg*2,hH,hI,hH+2,hI+10,dg,oM)jl=jl..gN(hH,hI-5,ir,jW.."txtstart pbright txtbig")jl=jl..gN(hH,hI+30,oO,jW.."txtstart pbright txtsmall")end;function o1.hudtick()if not kE then return end;local function oP(k1)local jY=bN(dl(dd/(ad/4)*255,0,255))k1[#k1+1]=dk("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(j4+0.5)+jY,bN(j5+0.5)-jY,bN(j6+0.5)-jY)end;local function oQ()if c2 then for dQ,dx in pairs(iR)do if dx.hovered then if not dx.drawCondition or dx.drawCondition(dx)then dx.toggleFunction(dx)end;dx.hovered=false end end;for dQ,dx in pairs(iU)do if dx.hovered then bK=dx.label;dx.hovered=false end end;c2=false end end;local function oR()local function oS(oT,oU,hH,hI,nl,nm)if oT>=hH and oT<=hH+nl and oU>=hI and oU<=hI+nm then return true else return false end end;local hH=c9+ad/2;local hI=ca+ae/2;for dQ,dx in pairs(iR)do dx.hovered=oS(hH,hI,dx.x,dx.y,dx.width,dx.height)end;for dQ,dx in pairs(iU)do dx.hovered=oS(hH,hI,dx.x,dx.y,dx.width,dx.height)end;if d0 then local n0=false;for dQ,eD in ipairs(nY)do if eD.hovered then n0=true;break end end;if nV.hovered then n0=true end;d0=n0 else d0=nV.hovered;if not d0 then d1=bm end end end;local function oV(k1)if not bK or bK==""then bK="HELP"end;if w then for dL,dx in pairs(iU)do local jW="dim brightstroke"local oW=0.2;if bK==dL then jW="pbright dimstroke"oW=0.6 end;local oX=""if dx.hovered then oW=0.8;oX=";stroke:white"end;k1[#k1+1]=dk([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dx.width,dx.height,dx.x,dx.y,jW,oW,oX)k1[#k1+1]=gN(dx.x+dx.width/2,dx.y+dx.height/2+5,dx.label,"txt txtmid pdim")end end end;local function oY(k1)local function oZ(k1,o_,hover,hH,hI,fi,p0,p1,p2,p3,p4,nZ)if type(p3)=="function"then p3=p3(nZ)end;if type(p4)=="function"then p4=p4(nZ)end;k1[#k1+1]=dk("<rect x='%f' y='%f' width='%f' height='%f' fill='",hH,hI,fi,p0)if o_ then k1[#k1+1]=dk("%s'",p1)else k1[#k1+1]=p2 end;if hover then k1[#k1+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else k1[#k1+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fV(ag*0.5,0),fV(ah*0.5,0),fV(ai*0.5,0))end;k1[#k1+1]=" rx='5'></rect>"k1[#k1+1]=dk("<text x='%f' y='%f' font-size='24' fill='",hH+fi/2,hI+p0/2+5)if o_ then k1[#k1+1]="black"else k1[#k1+1]="white"end;k1[#k1+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if o_ then k1[#k1+1]=dk("%s</text>",p3)else k1[#k1+1]=dk("%s</text>",p4)end end;local p5=dk("rgb(%d,%d,%d)'",fV(ag*0.1,0),fV(ah*0.1,0),fV(ai*0.1,0))local p6=dk("rgb(%d,%d,%d)",fV(ag*0.8,0),fV(ah*0.8,0),fV(ai*0.8,0))local p7=oZ;for dQ,dx in pairs(iR)do local nq=dx.disableName;local np=dx.enableName;if type(nq)=="function"then nq=nq(dx)end;if type(np)=="function"then np=np(dx)end;if not dx.drawCondition or dx.drawCondition(dx)then p7(k1,dx.toggleVar(dx),dx.hovered,dx.x,dx.y,dx.width,dx.height,p6,p5,nq,np,dx)end end end;local p8=fV(ad/2,0)local p9=fV(ae/2,0)local k1={}if pa then k1[#k1+1]=pa end;cr.HUDPrologue(k1)if w then cr.UpdateHud(k1)else if A then cr.DrawVerticalSpeed(k1,ci)end;cr.DrawWarnings(k1)end;if iY and iZ~="none"then cr.DrawSettings(k1)end;if cu then cr.DrawRadarInfo()else ig=""end;cr.HUDEpilogue(k1)k1[#k1+1]=dk([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c3~="empty"then cr.DisplayMessage(k1,c3)end;if iH()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(k1)end end;oV(k1)if iJ()==0 then if iH()==1 and c1 then if not pb then oR()oY(k1)end;if not cx and not cy then local pc=table.concat(k1,"")k1={}k1[#k1+1]=dk("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)k1[#k1+1]=pc;k1[#k1+1]="</body>"cx=true;k1[#k1+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local pc=table.concat(k1,"")k1={}k1[#k1+1]=dk("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)k1[#k1+1]=pc;k1[#k1+1]="</body>"end;if not cx then k1[#k1+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p8,p9,c9,ca)end else oQ()end else if not c1 and iH()==0 then oQ()if dd>aA then if v then oP(k1)end end elseif c1 and(not pb or not j)then oR()oY(k1)end;k1[#k1+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p8,p9,c9,ca)end;k1[#k1+1]=[[</svg></body>]]pd=table.concat(k1,"")end;function o1.TenthTick()local function pe()local pf=a.createData;local pg=a.createWidget;ph=a.createWidgetPanel("Interplanetary Helper")pi=pg(ph,"value")pj=pf('{"label": "Target Planet", "value": "N/A", "unit":""}')fT(pj,pi)pk=pg(ph,"value")pl=pf('{"label": "distance", "value": "N/A", "unit":""}')fT(pl,pk)gm=pg(ph,"value")gl=pf('{"label": "Travel Time", "value": "N/A", "unit":""}')fT(gl,gm)gk=pg(ph,"value")gj=pf('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fT(gj,gk)go=pg(ph,"value")gn=pf('{"label": "Target Altitude", "value": "N/A", "unit":""}')fT(gn,go)gg=pg(ph,"value")gf=pf('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ge=pg(ph,"value")gd=pf('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gc=pg(ph,"value")gb=pf('{"label": "Max Brake distance", "value": "N/A", "unit":""}')ga=pg(ph,"value")g9=pf('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gi=pg(ph,"value")gh=pf('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fT(gf,gg)fT(gd,ge)fT(gb,gc)fT(g9,ga)fT(gh,gi)end end;local function pm()gM(ph)ph=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bk~="None"then if ph==nil then pe()end;if bk~=nil then local mC;local pn=g5~=nil;local po=0.5*bv/c8:getGravity(c8.center+vec3(0,0,1)*c8.radius):len()po=po>1000000 and fV(po/1000000,2).." kTons"or fV(po/1000,2).." Tons"fS(pj,'{"label": "Target", "value": "'..bk..'", "unit":""}')if pn and not b4 then mC=(cO-g5.position):len()else mC=(bl-cO):len()end;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)j1,j2=ct.GetAutopilotBrakeDistanceAndTime(a1)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)j1,j2=ct.GetAutopilotTBBrakeDistanceAndTime(a1)end;local ls=iM(mC)fS(pl,'{"label": "distance", "value": "'..ls..'"}')fS(gl,'{"label": "Travel Time", "value": "'..iN(ly)..'", "unit":""}')ls=iM(c6)fS(gf,'{"label": "Cur Brake distance", "value": "'..ls..'"}')fS(gd,'{"label": "Cur Brake Time", "value": "'..iN(c7)..'", "unit":""}')ls=iM(j1)fS(gb,'{"label": "Max Brake distance", "value": "'..ls..'"}')fS(g9,'{"label": "Max Brake Time", "value": "'..iN(j2)..'", "unit":""}')fS(gj,'{"label": "Max Brake Mass", "value": "'..dk("%s",po)..'", "unit":""}')ls=iM(gp)fS(gn,'{"label": "Target Orbit", "value": "'..ls..'"}')if cg and not pp then a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)a.removeDataFromWidget(gf,gg)a.removeDataFromWidget(gh,gi)pp=true;if not cR and t and(b6 or b9 or ce)then ct.cmdThrottle(1)b1=false;bV=false end end;if not cg and pp then if fS(g9,ga)==1 then fT(g9,ga)end;if fS(gb,gc)==1 then fT(gb,gc)end;if fS(gd,ge)==1 then fT(gd,ge)end;if fS(gf,gg)==1 then fT(gf,gg)end;if fS(gh,gi)==1 then fT(gh,gi)end;pp=false end end else pm()end;if warpdrive~=nil then local pq=iF(warpdrive.getWidgetData())if pq.destination~="Unknown"and pq.distance>400000 then if not je then warpdrive.showWidget()je=true end elseif je then warpdrive.hideWidget()je=false end end end;function o1.OneSecondTick()local function pr()local jO=bM()local ld=cL;local ps=jO-jc;if ld>1.38889 then ld=ld/1000;local pt=ld*(jO-jc)bo=bo+pt;j9=j9+pt end;ja=ja+ps;bp=bp+ps;jc=jO end;local function pu(k1)local pv=0;local pw=iP;local px=0;local py=0;local pz=0;local jU=0;local jV=""local pA=b.getElementHitPointsById;local pB=b.getElementMaxHitPointsById;local pC={}for dL in pairs(iO)do local pD=0;local pE=0;pE=pB(iO[dL])pD=pA(iO[dL])px=px+pD;if pD+1<pE then if pD==0 then pz=pz+1 else py=py+1 end;if jd and#pC==0 then fX=vec3(b.getElementPositionById(iO[dL]))local hH=fX.x;local hI=fX.y;local hJ=fX.z;table.insert(pC,b.spawnArrowSticker(hH,hI,hJ+1,"down"))table.insert(pC,b.spawnArrowSticker(hH,hI,hJ+1,"down"))b.rotateSticker(pC[2],0,0,90)table.insert(pC,b.spawnArrowSticker(hH+1,hI,hJ,"north"))table.insert(pC,b.spawnArrowSticker(hH+1,hI,hJ,"north"))b.rotateSticker(pC[4],90,90,0)table.insert(pC,b.spawnArrowSticker(hH-1,hI,hJ,"south"))table.insert(pC,b.spawnArrowSticker(hH-1,hI,hJ,"south"))b.rotateSticker(pC[6],90,-90,0)table.insert(pC,b.spawnArrowSticker(hH,hI-1,hJ,"east"))table.insert(pC,b.spawnArrowSticker(hH,hI-1,hJ,"east"))b.rotateSticker(pC[8],90,0,90)table.insert(pC,b.spawnArrowSticker(hH,hI+1,hJ,"west"))table.insert(pC,b.spawnArrowSticker(hH,hI+1,hJ,"west"))b.rotateSticker(pC[10],-90,0,90)table.insert(pC,iO[dL])end elseif jd and#pC>0 and pC[11]==iO[dL]then for jN in pairs(pC)do b.deleteSticker(pC[jN])end;pC={}end end;pv=fV(px/pw*100,2)if pz>0 or py>0 then k1[#k1+1]=gN(0,0,"","pbright txt")jU=bN(pv*2.55)jV=dk("rgb(%d,%d,%d)",255-jU,jU,0)k1[#k1+1]=gN("50%",1035,"Elemental Integrity: "..pv.."%","txtbig txtmid","fill:"..jV)if pz>0 then k1[#k1+1]=gN("50%",1055,"Disabled Modules: "..pz.." Damaged Modules: "..py,"txtbig txtmid","fill:"..jV)elseif py>0 then k1[#k1+1]=gN("50%",1055,"Damaged Modules: "..py,"txtbig txtmid","fill:"..jV)end end end;local function pF()if iE then if j3==nil and(hl~=nil or bn)then _autoconf.displayCategoryPanel(iE,weapon_size,"Weapons","weapon",true)j3=_autoconf.panels[_autoconf.panels_size]elseif j3~=nil and hl==nil and not bn then gM(j3)j3=nil end end end;local k1={}pr()if s then pu(k1)end;pF()cr.UpdatePipe()cr.ExtraData(k1)jb=table.concat(k1,"")end;function o1.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function o1.MsgTick()local k1={}cr.DisplayMessage(k1,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function o1.ButtonSetup()nB()nG()iR=iS end;if pG then for dL,dx in pairs(pG)do o1[dL]=dx end end;return o1 end;local function pH(d,b,c,e,vBooster,hover,pI,antigrav,dbHud_1,eZ,bN,bO,iH,eU,bM,dl,iI,fS,iJ,dn,fV,fU,iK,dp,iM,iN,pJ,iF)local a=DUSystem;local bP=DUConstruct;local pK={}local pL=false;local pM=0;local pN=0;local pO=0;local pP=bM()local pQ=0;local pR=0;local pS=0;local pT=0;local pU=false;local pV=false;local pW=false;local pX=nil;local pY=0;local j0=55;local pZ=nil;local p_=false;local q0=false;local q1=false;local q2=0;local q3=0;local q4=0;local q5=0;local q6=0;local q7={VectorToTarget=false}local q8=vec3(bP.getWorldOrientationUp())local q9=nil;local qa=0;local qb=-1;local qc=-1;local qd=false;local qe=false;local qf=0;local qg=false;local qh=false;local qi=false;local qj=false;local qk=""local ql=false;local qm=false;local qn=""local qo=false;local qp=0;local qq=0;local function qr()return bP.isInPvPZone()~=1,eZ(bP.getDistanceToSafeZone())end;local function qs(fp)local qt=bg;if not b4 then qt=0 end;local qu=bt;if cg then if bv and bv>0 then qu=bv else return 0,0 end end;return cp.computeDistanceAndTime(fp,qt,cj,0,0,qu-bi*cj)end;local function qv(fp)local qt=bg;if not b4 then qt=0 end;return cp.computeDistanceAndTime(fp,qt,cj,d:maxForceForward(),a3,bt-bi*cj)end;local function qw(qx,qy,qz)qy=qy:project_on_plane(qx)qz=qz:project_on_plane(qx)return eU(qy:cross(qz):dot(qx),qy:dot(qz))end;local qA;local qB;if hover then qB=hover.getMaxDistance()*2 end;if vBooster then qA=vBooster.getMaxDistance()*2 end;local function qC()local function qD()local qE=-1;local qF=-1;if vBooster then qE=vBooster.getDistance()if qE>qA then qE=-1 end end;if hover then qF=hover.getDistance()if qF>qB then qF=-1 end end;if qE~=-1 and qF~=-1 then if qE<qF then return qE else return qF end elseif qE~=-1 then return qE elseif qF~=-1 then return qF else return-1 end end;local qG=qD()local qH=-1;if antigrav and antigrav.isActive()==1 and not r and cL<j0 then local qI=eZ(ci-antigrav.getBaseAltitude())if qI<50 then return qI end end;if pI then qH=pI.raycast().distance;if qH==0 then qH=-1 end end;if qG~=-1 and qH~=-1 then if qG<qH then return qG else return qH end elseif qG~=-1 then return qG else return qH end end;local function qJ(kE,eL,qK)local function qL(qM,dX)local eR=vec3(dX)if qM.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=qM.systemId},dZ)end;local eS=eR-qM.center;local cb=eS:len()local e3=cb-qM.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=math.deg(e1),longitude=math.deg(e2),altitude=e3,id=qM.id,systemId=qM.systemId},dZ)end;local qN=qL(kE,eL)qN="::pos{"..qN.systemId..","..qN.id..","..qN.latitude..","..qN.longitude..","..qN.altitude.."}"if qK then return qN else qi=qN;return true end end;local function qO(qP,qQ,qR)local function qS(qP,eu)qP=vec3(qP)eu=vec3(eu):normalize()local dG=qP*eu;return dG.x+dG.y+dG.z end;local qT=0.001;local qU=1;if not cg or not cA or cf~=-1 or cL<j0 then if qR==nil then qR=aT end;if qQ==nil then qQ=qT end;qP=vec3(qP):normalize()local qV=vec3()-qP;local qW=-qS(qV,bP.getWorldOrientationRight())*qU;local qX=-qS(qV,bP.getWorldOrientationUp())*qU;if pN==0 then pN=qW/2 end;if pO==0 then pO=qX/2 end;if eZ(qW)<0.1 then q3=q3-qW*2 else q3=q3-(qW+(qW-pN)*qR)end;if eZ(qX)<0.1 then q2=q2+qX*2 else q2=q2+qX+(qX-pO)*qR end;pN=qW;pO=qX;if eZ(qW)<qQ and eZ(qX)<qQ then return true end;return false elseif cA and cf==-1 then qP=cK;if qR==nil then qR=aT end;if qQ==nil then qQ=qT end;qP=vec3(qP):normalize()local qV=cH-qP;local qW=-qS(qV,bP.getWorldOrientationRight())*qU;local qX=-qS(qV,bP.getWorldOrientationUp())*qU;if pN==0 then pN=qW/2 end;if pO==0 then pO=qX/2 end;if eZ(qW)<0.1 then q3=q3-qW*5 else q3=q3-(qW+(qW-pN)*qR)end;if eZ(qX)<0.1 then q2=q2+qX*5 else q2=q2+qX+(qX-pO)*qR end;pN=qW;pO=qX;if eZ(qW)<qQ and eZ(qX)<qQ then return true end;return false end end;function pK.clearAll()bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"b2=false;b3=false;cX=nil;b6=false;b9=false;b7=false;b8=false;ba=false;c0=false;q0=false;cc=false;cd=false;q1=false;cz=q;br=false;b5=false;ck=false;bu=nil;bA=false;db=false;dc=nil end;function pK.GetAutopilotBrakeDistanceAndTime(fp)return qs(fp)end;function pK.GetAutopilotTBBrakeDistanceAndTime(fp)return qv(fp)end;function pK.showWayPoint(kE,eL,qK)return qJ(kE,eL,qK)end;function pK.APTick()local qY=a.getMouseWheel()if qY>0 then ct.changeSpd()elseif qY<0 then ct.changeSpd(true)else p_=true end;qf=iJ()if qi then a.setWaypoint(qi)qi=false end;if ql then antigrav.setTargetAltitude(ql)ql=false end;if qj then fS(qj,qk)qj=false;qk=""end;if qc~=-1 then ct.cmdCruise(qc,qd)qd=false;qc=-1 end;if q9~=nil then if iI:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iI:getTargetSpeed(axisCommandId.longitudinal)~=q9 then iI:setTargetSpeedCommand(axisCommandId.longitudinal,q9)else q9=nil end end;if qb~=-1 then ct.cmdThrottle(qb,qd)qd=false;qb=-1 end;if qe then cv.landingGear(qe)qe=false end;if qm then ct.ToggleAutopilot()end end;function pK.ToggleIntoOrbit()cE=false;pS=nil;pT=nil;pY=0;if not cg then if bA then fU("orOff","AP")bA=false;pU=false;pX=nil;cz=q;if b6 then b6=false;b8=false end;q7.VectorToTarget=false;q7.AutopilotAlign=false;pW=false elseif cY then fU("orOn","AP")bA=true;cz=true;if pX==nil then pX=kE end;if b6 then b6=false;b8=false end else c3="Unable to engage auto-orbit, not near a planet"end else bA=false;pU=false;pX=nil;cz=q;if b6 then b6=false end;q7.VectorToTarget=false;q7.AutopilotAlign=false;pW=false end end;function pK.ToggleVerticalTakeoff()b6=false;if ba then lu=true;b9=false;b8=false;b7=true;cz=true;b_=0;if cg and cf==-1 then b7=false;b6=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qc=bN(cB)end else cE=false;bn=false;d.control.retractLandingGears()iI:setTargetGroundAltitude(Z)b1="VTO Takeoff"end;ba=not ba end;function pK.checkLOS(qP)local lw,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,qP,function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local lx=eJ;if eK~=nil and eJ~=nil then lx=math.min(eK,eJ)end;if lx~=nil then return lw,lx else return nil,nil end end;local function qZ(q_,r0)if r0 then b_=0;iI:updateCommandFromActionStop(axisCommandId.vertical,r0)if bC then iI:activateGroundEngineAltitudeStabilization(r1)de=true end else b_=b_+q_;iI:deactivateGroundEngineAltitudeStabilization()iI:updateCommandFromActionStart(axisCommandId.vertical,q_)end end;function pK.vertical(q_,r0)qZ(q_,r0)end;function pK.ToggleAutopilot()local function r2(by)cZ=false;br=not br;if br then b5=false;if not b6 and not by then ct.ToggleAltitudeHold()end end;lA="Proceeding to Waypoint"end;local function r3(gy)if gy then for M,dL in pairs(cU)do if dL.name and dL.name==gy then return M end end else return 0 end end;local r4=false;bI=false;if bQ-pR<1.5 and cg then if not cG then if cg then bb=kE.spaceEngineMinAltitude-0.01*kE.noAtmosphericDensityAltitude;fU("11","EP")pR=-1;if b4 or br or bA then return end else c3="No space engines detected, Orbital Hop not supported"return end elseif kE.hasAtmosphere then if cg then bb=kE.noAtmosphericDensityAltitude+V;fU("orH","OH")end;pR=-1;if b4 or br or bA then return end end else pR=bQ end;r5=false;if(bm>0 or#bG>0)and not b4 and not br and not cd and not bA then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then c3="WARNING: Heavy Loads may affect autopilot performance."c4=5 end;if#bG>0 and not ce then bm=r3(bG[1])cs.UpdateAutopilotTarget()c3="Route Autopilot in Progress"local qV=g5.position-cO;local r6=qV:project_on_plane(cM):len()if r6>50000 and g5.planetname==kE.name then r4=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c8,bl)if g5~=nil then if g5.agg and not r and antigrav then if not cQ then ct.ToggleAntigrav()end;bw=g5.agg end;bu=nil;by=g5.planetname=="Space"if by then fU("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end elseif kE.name==g5.planetname then lu=true;if cg then if not br then fU("vtt","AP")r2(by)if r4 then bb=kE.noAtmosphericDensityAltitude+V end end else fU("apOn","AP")if not(c8.name==kE.name and ci<gp*1.5)then cE=false;b4=true elseif not cg then if bA then ct.ToggleIntoOrbit()end;cD=kE.noAtmosphericDensityAltitude+V;pW=true;q7.AutopilotAlign=true;q7.VectorToTarget=true;pU=false;if not bA then ct.ToggleIntoOrbit()end end end else fU("apP","AP")b2=false;b3=false;if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end end elseif not cg then if g5==nil and(c8.name==kE.name and cY)and not bA then r7=false;cE=false;pU=false;ct.ToggleIntoOrbit()else fU("apP","AP")b4=true;b2=false;b3=false;bd=false;c0=false;b6=false;b7=false;b9=false;b8=false;q0=false;bu=nil;r7=false end else fU("apP","AP")cd=true;ct.ToggleAltitudeHold()end;qm=false else fU("apOff","AP")ct.ResetAutopilots(1)if qm==2 then qm=true end end end;function pK.routeWP(r8,r9,ra)if ra then if ra==1 then bG={}bG=iK(bG,bF)if#bG>0 then c3="Route Loaded"else c3="No Saved Route found on Databank"end;return bG else bF={}bF=iK(bF,bG)c3="Route Saved"pJ()return end end;if r8 then return bG end;if r9 then bG={}c3="Current Route Cleared"else bG[#bG+1]=g5.name;c3="Added "..g5.name.." to route. "end;return bG end;function pK.cmdThrottle(dM,rb)if iI:getAxisCommandType(0)~=axisCommandType.byThrottle and not rb then d.control.cancelCurrentControlMasterMode()end;iI:setThrottleCommand(axisCommandId.longitudinal,dM)bR=dl(fV(dM*100,0)/100,-1,1)q9=nil end;function pK.cmdCruise(dM,rb)if iI:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rb then d.control.cancelCurrentControlMasterMode()end;iI:setTargetSpeedCommand(axisCommandId.longitudinal,dM)q9=dM end;function pK.ToggleLockPitch()if bu==nil then fU("lkPOn","LP")if not c1 then bu=cS else bu=S end;b8=false;b6=false;b7=false else fU("lkPOff","LP")bu=nil end end;function pK.ToggleAltitudeHold()if bQ-pQ<1.5 then bI=false;if kE.hasAtmosphere then if cg then bb=kE.spaceEngineMinAltitude-0.01*kE.noAtmosphericDensityAltitude;fU("11","EP")else if cY then bb=kE.noAtmosphericDensityAltitude+V;cD=bb;pW=true;if not bA then ct.ToggleIntoOrbit()end;pU=true end end;pQ=-1;if b6 or bA or ba then return end end else pQ=bQ end;if cY and not cg and cf==-1 then cD=ci;pW=true;pU=true;ct.ToggleIntoOrbit()if bA then pQ=bQ else pQ=0 end;return end;b6=not b6;b7=false;b9=false;if b6 then b4=false;b3=false;b2=false;c0=false;cz=true;bu=nil;cE=false;if cf~=-1 then if not bn and not br then bb=ci;bI=cf;iI:setTargetGroundAltitude(bI)elseif cL<20 then if bn then cv.landingGear()end;fU("lfs","LS")b8=true;if cg then bb=ci+Y else bb=kE.surfaceMaxAltitude+100 end;b1="ATO Hold"iI:setTargetGroundAltitude(Z)if b0 and cP then ct.ToggleVerticalTakeoff()end end else fU("altOn","AH")b8=false;if pQ>-1 then if cY then bb=ci end end;if ba then ct.ToggleVerticalTakeoff()end end;if cQ and not r then local rc=antigrav.getBaseAltitude()if br and g5.agg and g5.agg>ci then bb=g5.agg elseif b8 then bb=rc end;if eZ(ci-rc)<100 and cL<20 then bb=rc;b1="AGG Hold"qb=0 end end;if cd then bb=200000 end else fU("altOff","AH")if bA then ct.ToggleIntoOrbit()end;if ba then ct.ToggleVerticalTakeoff()end;cz=q;b8=false;br=false;pQ=0;bI=false end end;function pK.ResetAutopilots(pK)if pK then cd=false;b4=false;bd=false;q0=false;bb=ci;r5=false;db=false;bh="Aligning"end;br=false;b8=false;b9=false;b3=false;b7=false;dc=nil;rd=false;cX=nil;db=false;if not cQ then b6=false;bu=nil end;if ba then ct.ToggleVerticalTakeoff()end;if bA then ct.ToggleIntoOrbit()end;cz=q;cc=false;ce=false;b_=0 end;function pK.BrakeToggle(re)if not b1 then if re then b1=re else b1=true end else b1=false end;if b7 then b7=false;cz=q;db=false end;if b1 then fU("bkOn","B",1)ct.ResetAutopilots()else fU("bkOff","B",1)end end;function pK.BeginReentry()if b9 then c3="Re-Entry cancelled"fU("reOff","RE")b9=false;cz=q;b6=false elseif not kE.hasAtmosphere then c3="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c4=5 elseif not q1 then b9=true;if iI:getAxisCommandType(0)~=rf.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b1=false;c3="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB;fU("par","RE")else b9=true;b6=true;cz=true;b1=false;bb=kE.surfaceMaxAltitude+a0;if bb>kE.spaceEngineMinAltitude then bb=kE.spaceEngineMinAltitude-0.01*kE.noAtmosphericDensityAltitude end;local rg=iM(bb)c3="Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..rg;fU("glide","RE")qc=bN(cB)end;b8=false end;function pK.ToggleAntigrav()if antigrav and not r then if cQ then fU("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bw==nil then bw=ci end;if bw<1000 then bw=1000 end;fU("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pK.changeSpd(rh)local ri=1;if rh then ri=-1 end;if not c1 then if t and not pb and p_ then local rj=bR;bR=fV(dl(bR+ri*aF/100,-1,1),2)if bR>=0 and rj<0 then bR=0;p_=false end elseif pb then if cg or b9 then cB=dl(cB+ri*aF,0,W)elseif b4 then a1=dl(a1+ri*aF/3.6*100,0,df-0.2)end else iI:updateCommandFromActionStart(axisCommandId.longitudinal,ri*aF/10)end else if b4 or br or cd or bA then d1=d1+1*ri*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not rh then ri=1 else ri=nil end;cs.adjustAutopilotTargetIndex(ri)end end end;function pK.TenthTick()local function rk()if not b4 then if g5==nil or g5.planetname~=kE.name then rl=(c8.center-cO):len()else rl=(g5.position-cO):len()end end;local fp=cL;local rm=c.getThrottle()/100;if t then rm=bR end;local rn,ro=cp.computeDistanceAndTime(cL,a1,cj,d:maxForceForward()*rm,a3,0)local c6,c7;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(a1)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dQ,rp;if not b5 and fp>0 then dQ,rp=ct.GetAutopilotBrakeDistanceAndTime(fp)else dQ,rp=ct.GetAutopilotTBBrakeDistanceAndTime(fp)end;local rq=0;local rr=0;if bf or not b4 and fp>5 then rr=cp.computeTravelTime(fp,0,rl)elseif c6+rn<rl then rq=rl-(c6+rn)rr=cp.computeTravelTime(8333.0556,0,rq)else local rs=(rl-c6)/rn;rn=rl-c6;ro=ro*rs end;if g5~=nil and g5.planetname==kE.name and not b4 then return rr elseif be then return rp elseif bf then return rr+rp else return ro+c7+rr end end;local function rt(og,ru)if og==nil then og=b.getGravityIntensity()end;og=fV(og,5)if ru~=nil and ru or(pZ==nil or pZ~=og)then local fp=cJ:len()local rv=iF(c.getWidgetData()).maxBrake;if rv~=nil and rv>0 and cg then rv=rv/dl(fp/100,0.1,1)rv=rv/ch;if ch>0.10 then if bv then bv=(bv+rv)/2 else bv=rv end end end;if rv~=nil and rv>0 then bt=rv end;pZ=og end end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()qq=0;for M=1,#d3 do qq=qq+bP.getDockedConstructMass(d3[M])end;local rw=0;for M=1,#d2 do rw=rw+bP.getBoardedPlayerMass(d2[M])end;if rw>20000 then qq=qq+rw-20000 end;cV,cW=qr()df=bP.getMaxSpeed()if bk~="None"and(c8 or g5)then ly=rk()end;rt(nil,true)end;local function rx(ry,rz)local oG=vec3()local rA=vec3()if ry==axisCommandId.longitudinal then oG=vec3(bP.getOrientationForward())rA=cH elseif ry==axisCommandId.vertical then oG=vec3(bP.getOrientationUp())rA=q8 elseif ry==axisCommandId.lateral then oG=vec3(bP.getOrientationRight())rA=cI else return vec3()end;local rB=vec3(b.getWorldGravity())local rC=rB:dot(rA)local rD=vec3(bP.getWorldAirFrictionAcceleration())local rE=rD:dot(rA)local rF=cJ:dot(oG)local rG=rz*constants.kph2m;if rH==nil then rH=pid.new(10,0,10.0)end;rH:inject(rG-rF)local rI=rH:get()local rJ=(rI-rE-rC)*rA;return rJ end;local function rK(ry,rz)local oG=vec3()local rA=vec3()if ry==axisCommandId.longitudinal then oG=vec3(bP.getOrientationForward())rA=cH elseif ry==axisCommandId.vertical then oG=vec3(bP.getOrientationUp())rA=q8 elseif ry==axisCommandId.lateral then oG=vec3(bP.getOrientationRight())rA=cI else return vec3()end;local rB=vec3(b.getWorldGravity())local rC=rB:dot(rA)local rD=vec3(bP.getWorldAirFrictionAcceleration())local rE=rD:dot(rA)local rF=cJ:dot(oG)local rG=rz*constants.kph2m;if rL==nil then rL=pid.new(10,0,10.0)end;rL:inject(rG-rF)local rI=rL:get()local rJ=(rI-rE-rC)*rA;return rJ end;local function rM(rN,k4,g1)local rO=rN:cross(g1):normalize_inplace()local kR=math.acos(dl(rO:dot(-k4),-1,1))*constants.rad2deg;if rO:cross(-k4):dot(g1)<0 then kR=-kR end;return kR end;local function rP()if c_ and not b7 then local es=c_[1]local i4,i5=c_[2],c_[3]local rQ=math.min(i4,i5 or i4)local rR=rQ/cL;local rS=b8 and(cL<42 or cf~=-1)local rT=b6 or br or bu or b4;if rT and not rS and(c6*1.5>rQ or rR<1)then b1="Collision"bG={}qb=0;if b6 then ct.ToggleAltitudeHold()end;if bu then ct.ToggleLockPitch()end;c3="Autopilot Cancelled due to possible collision"a.print(es.name.." COLLISION "..iN(rR).." / "..iM(rQ,2))ct.ResetAutopilots(1)lu=true;if cg then b7=true end;cz=true end;if rR<11 then cZ=es.name.." COLLISION "..iN(rR).." / "..iM(rQ,2)else cZ=es.name.." collision "..iN(rR)end;if rR<6 then fU("alarm","AL",2)end else cZ=false end end;local rU=1;local rV=0;local rW=1;local rX=1;local rY=1;local rZ=false;function pK.onFlush()if antigrav and not r and not cQ and antigrav.getBaseAltitude()~=bw then ql=bw end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iI:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local r_=dl(bX+q2+a.getControlDeviceForwardInput(),-1,1)local s0=dl(bY+q4+a.getControlDeviceYawInput(),-1,1)local s1=dl(bZ+q3-a.getControlDeviceLeftRightInput(),-1,1)local s2=b1 and 1 or 0;cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(kE.center-cO):normalize()end;q8=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()+qq;cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local s3=cT/180*math.pi;local s4=math.cos(s3)local s5=math.sin(s3)cS=rM(cM,cH,cI*s4+q8*s5)local s6=cK:normalize()local s7=eZ(cT)local s8=utils.sign(cT)local s9=vec3(bP.getWorldAngularVelocity())local sa=r_*aP*cI+s0*aK*cH+s1*aQ*q8;if cz==true and cM:len()>0.01 then local sb=eZ(q5-cT)if((b3 or b9 or b7 or cc or b6 or bA)and sb>0 or cg and sb<aL and q)and s0==0 and eZ(cS)<85 then local sc=q5;local sd=aJ;if not cg then sd=sd/4;q5=0;sc=0 end;if se==nil then se=pid.new(sd*0.01,0,sd*0.1)end;se:inject(sc-cT)local sf=se:get()sa=sa+sf*cH end end;bS=0;ch=bO()cg=false or ci<kE.noAtmosphericDensityAltitude and ch>0.00001;ci=b.getAltitude()cf=qC()bQ=bM()pP=bQ;if bn and cf>-1 and cf-3<_ then if iI.targetGroundAltitudeActivated then iI:deactivateGroundEngineAltitudeStabilization()end end;if cu then qo=not qo;if qo then cu.UpdateRadar()end;if E then rP()end end;if antigrav then cQ=antigrav.isActive()==1 end;local sg=bQ-pP;local sh=-math.deg(qw(q8,cK,cH))local si=math.deg(qw(cI,cK,cH))local gr=cM*-1;cA=cg and sh<-N or sh>N or si<-O or si>O;local sj=a.getMouseDeltaX()local sk=a.getMouseDeltaY()if qp then local sl=bM()-qp;sj=sj*sl/0.016;sk=sk*sl/0.016 end;qp=bM()if p and not c1 then sk=-sk end;q3=0;q4=0;q2=0;local sm=bP.getWorldPosition()kE=fY:closestBody(sm)sn=cq(kE)ft=sn:orbitalParameters(sm,cK)if ci==0 then ci=(cO-kE.center):len()-kE.radius end;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local og=kE:getGravity(sm):len()*cj;q5=0;local so=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if qf==0 then if iH()==1 and c1 then if not cx then c9=dl(c9+sj/2,-ad/2,ad/2)ca=dl(ca+sk/2,-ae/2,ae/2)end else c9=0;ca=0 end else c9=dl(c9+sj/2,-ad/2,ad/2)ca=dl(ca+sk/2,-ae/2,ae/2)dd=dn(c9*c9+ca*ca)if not c1 and iH()==0 then local k_,l0=1,1;if bK=="SCOPE"then k_,l0=d5/90,d5/90 end;if g=="virtual joystick"then if dd>aA then q3=q3-dl(eZ(c9)-aA,0,ad/2)*utils.sign(c9)*aH*k_;q2=q2-dl(eZ(ca)-aA,0,ae/2)*utils.sign(ca)*aI*l0 end else c9=0;ca=0;if g=="mouse"then q2=(-utils.smoothstep(sk,-100,100)+0.5)*2*rX;q3=(-utils.smoothstep(sj,-100,100)+0.5)*2*rY end end end end;local sp=cL>27777;if cL>X/3.6 and not cg and not b4 and not sp then c3="Space Speed Engine Shutoff reached"qb=0 end;if not sp and sq then if not b1 then ct.BrakeToggle()end;if b4 then ct.ResetAutopilots(1)end;qb=0 end;sq=sp;if ch>0.09 then if cL>cB/3.6 and not t and not pL then b1="SpdLmt"pL=true elseif not t and pL then if cL<cB/3.6 then b1=false;pL=false end end end;if b3 then if cc then b1=false;local sr=false;sr=qO(g5.position-cO,0.1)cz=true;if sr then qc=bN(cB)if(eZ(cT)<2 or eZ(cS)>85)and cL>=cB/3.6-1 then b1=false;b3=false;if cc~=2 then q1=true end;if cc==true then ce=true end;cc=false;b4=false;ct.BeginReentry()end elseif cg and t then qb=1 end elseif cL>j0 then qO(vec3(cK),0.01)end end;if b2 then if cg then b2=false elseif cL>j0 then qO(-vec3(cK))end end;if not b3 and cc and not bA then if not cg then if cc~=2 then q1=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not qm then qm=true end end end;if ce and g5 and(ci<bb+250 and ci>bb-250)and cL*3.6>cB-250 and eZ(cN)<25 and ch>=0.1 and(g5.position-cO):len()>2000+ci then if not qm then qm=true end;ce=false end;if ba then cz=true;local ss=bb;if cN<-30 then c3="Unable to achieve lift. Safety Landing."b_=0;cz=q;ba=false;b7=true elseif not r and cQ or bb<kE.spaceEngineMinAltitude then if cQ then ss=antigrav.getBaseAltitude()end;if ci<ss-100 then q6=0;b_=15;b1=false elseif cN>0 then b1="VTO Limit"b_=0 elseif cN<-30 then b1="VTO Fall"b_=15 elseif ci>=ss then if cQ then if b4 or br then ct.ToggleVerticalTakeoff()else b1="VTO Complete"ba=false end;c3="Takeoff complete. Singularity engaged"fU("aggLk","AG")else b1=false;c3="VTO complete. Engaging Horizontal Flight"fU("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then q6=0;b1=false;b_=20 elseif ch<0.08 and cg then b1=false;if cF then q6=0;b_=20 else b_=0;q6=36;qc=3500 end else cz=q;bA=true;cE=false;st=false;pU=false;pS=nil;pT=nil;if pX==nil then pX=kE end;cD=ss;pW=true;ba=false end end;if q6~=nil then if su==nil then su=pid.new(2*0.01,0,2*0.1)end;local sv=dl(q6-cS,-O*0.80,O*0.80)su:inject(sv)local sw=dl(su:get(),-1,1)q2=sw end end;if bA then local function sx()if ft.periapsis.altitude>=cD*0.99 and ft.apoapsis.altitude>=cD*0.99 and ft.periapsis.altitude<ft.apoapsis.altitude and ft.periapsis.altitude*1.05>=ft.apoapsis.altitude and eZ(cD-ci)<1000 then return true else return false end end;local qV;local sy=false;local sz=iM(cD,3)if pX==nil then pX=kE;if br then pX=c8 end end;if not pW then cD=bN(pX.radius+pX.surfaceMaxAltitude+V)if pX.hasAtmosphere then cD=bN(pX.radius+pX.noAtmosphericDensityAltitude+V)end;pW=true end;if q7.VectorToTarget and g5 then qV=g5.position-cO end;local sA,sB=cq(pX):escapeAndOrbitalSpeed((cO-pX.center):len()-pX.radius)local sC=cT;if not pU then local sD=false;local sE=false;qb=0;pT=0;cC="Aligning to orbital path - OrbitHeight: "..sz;if q7.VectorToTarget then qO(qV:normalize():project_on_plane(cM))sy=cH:dot(qV:project_on_plane(q8):normalize())>0.95 else qO(cK)sy=sh<0.5;if cL<150 then sy=true end end;q2=0;pS=0;if cS<=pS+2 and cS>=pS-2 then sD=true else sD=false end;if sC<=pT+2 and sC>=pT-2 then sE=true else sE=false end;if sD and sE and sy then pS=nil;pT=nil;pU=true end else if q7.VectorToTarget then qO(qV:normalize():project_on_plane(cM))elseif cL>150 then qO(cK)end;q2=0;if q7.VectorToTarget and g5 then local c6,dQ=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bt)if cE and qV:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pX.noAtmosphericDensityAltitude or ly>ft.timeToPeriapsis and ft.periapsis.altitude<pX.noAtmosphericDensityAltitude or not sx()and ft.eccentricity>0.1 then c3="Re-Aligning Orbit"cE=false end elseif cE or qV:len()<15000+c6+ci then c3="Orbit complete, proceeding with reentry"fU("orCom","OB")bl=g5.position;q1=true;ce=true;q7.VectorToTarget,q7.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if ft.periapsis~=nil and ft.apoapsis~=nil and ft.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if ft.apoapsis~=nil then if(sx()or cE)and not K then if cE then b1=false;qb=0;pS=0;if not q7.VectorToTarget then c3="Orbit complete"fU("orCom","OB")ct.ToggleIntoOrbit()end else pY=pY+1;if pY>=2 then cE=true end end else if sx()then cC="Maintaining "else cC="Adjusting "pV=true;qc=sB*3.6+1;local sF=cD-ci;if sG==nil then sG=pid.new(0.1,0,1*0.1)end;sG:inject(sF-cN*dl(utils.smoothstep(2000-sF,-2000,2000)^6*10,1,10))pS=dl(sG:get(),-60,60)end;cC=cC.." - OrbitHeight: "..sz end end else local sH=2.75;local sI=eZ(fV(sA*sH))local ov=sI%50;if ov>0 then sI=sI-ov+50 end;b1=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sz;pS=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sz;sI=sI*0.75;pS=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sz;sI=sI*0.75;if cN<0 or pV then pS=utils.map(ci,cD*1.5,cD*1.01,-30,0)else pS=utils.map(ci,cD*0.99,cD*1.5,0,30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sz;pS=-65;local sJ=utils.map(cN,-150,-400,1,0.55)sI=sI*sJ end;qc=bN(sI)end end;if pS~=nil then if sK==nil then sK=pid.new(1*0.01,0,5*0.1)end;local sL=pS-cS;sK:inject(sL)local sM=dl(sK:get(),-0.5,0.5)q2=sM end end;if b4 and not cg and not cc then local function sN(di,ft)a.print(di)b3=false;b1=false;be=false;b4=false;r5=false;bh="Aligning"qb=0;q0=false;c3=di;fU("apCom","AP")if ft or cc then if ft and gp~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pW=true end;ct.ToggleIntoOrbit()end end;local sO,sP=bl,false;if g5 and g5.planetname~="Space"then bd=true;if not r5 then local sQ=(g5.position-c8.center):normalize()local sR=sQ:project_on_plane((c8.center-cO):normalize()):normalize()local sS=c8.center+sR*(c8.radius+gp)local sT=g5.position+(g5.position-c8.center):normalize()*(gp-c8:getAltitude(g5.position))if(cO-sS):len()<(cO-sT):len()then sO=sS else sO=sT;bg=0 end;bl=sO;ct.showWayPoint(c8,bl)sP=true;r5=true end;bi=0 elseif g5 and g5.planetname=="Space"then if not r5 then bi=0;sP=true;bd=true;r5=true;sO=g5.position+(cO-g5.position):normalize()*T;bl=sO end elseif g5==nil then bi=0;if not r5 then local sQ=(cO+cK*100000-c8.center):normalize()local sR=sQ:project_on_plane((c8.center-cO):normalize()):normalize()if sR:len()<1 then sQ=(cO+cH*100000-c8.center):normalize()sR=sQ:project_on_plane((c8.center-cO):normalize()):normalize()end;sO=c8.center+sR*(c8.radius+gp)bl=sO;r5=true;sP=true;bd=true;ct.showWayPoint(c8,bl)end end;rl=(vec3(sO)-cO):len()local lw,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local lx=eJ;if eK~=nil and eJ~=nil then lx=math.min(eK,eJ)end;if lx~=nil and lx<rl and lw.name==c8.name then rl=lx end;local sr=true;local sU=(c8.center-(cO+vec3(cK):normalize()*rl)):len()-c8.radius;local ls=iM(sU)qj=gh;qk='{"label": "Projected Altitude", "value": "'..ls..'"}'if cL>50 and bc then local qV=vec3(sO)-cO;local sV=dl(math.deg(qw(q8,cK:normalize(),qV:normalize()))*cL/500,-90,90)local sW=dl(math.deg(qw(cI,cK:normalize(),qV:normalize()))*cL/500,-90,90)if eZ(sV)<20 and eZ(sW)<20 then sV=sV*2;sW=sW*2 end;if eZ(sV)<2 and eZ(sW)<2 then sV=sV*2;sW=sW*2 end;local sh=-math.deg(qw(q8,cH,cK:normalize()))local si=-math.deg(qw(cI,cH,cK:normalize()))if sX==nil then sX=pid.new(2*0.01,0,2*0.1)end;sX:inject(sW-si)local sY=dl(sX:get(),-1,1)q2=q2+sY;if sZ==nil then sZ=pid.new(2*0.01,0,2*0.1)end;sZ:inject(sV-sh)local s_=dl(sZ:get(),-1,1)q3=q3+s_;sP=true;if eZ(sV)>2 or eZ(sW)>2 then if bh~="Adjusting Trajectory"then bh="Adjusting Trajectory"fU("apAdj","AP")end else if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end end elseif bc and cL<=50 then qO((sO-cO):normalize())end;if sU<gp*1.5 then bg=cB/3.6;if g5==nil then dQ,bg=cq(c8):escapeAndOrbitalSpeed(sU)end end;local c6,c7;if not b5 then c6,c7=qs(cL)else c6,c7=qv(cL)end;if b4 and not bc and not bf and not be then local lw,lx=ct.checkLOS((bl-cO):normalize())if c8.name~=kE.name then if lw~=nil and c8.name~=lw.name and lx<rl then c3="Collision with "..lw.name.." in "..iM(lx).."\nClear LOS to continue."c4=5;qg=true else qg=false;c3=""end end end;if not qg then if not bf and not be and not sP then sr=qO((sO-cO):normalize())elseif b5 and(be or bf)then sr=qO(-vec3(cK):normalize())end end;if bc then if not q0 then b1=false;qb=a2;bR=fV(a2,2)q0=true end;local rm=c.getThrottle()if t then rm=bR end;local t0=99999;local ot=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local t1=dl(cK:dot((sO-cO):normalize()),0,cL)if t1>0 or ot>0 then t0=cp.computeTravelTime(t1,ot,rl-c6)end;if a1>df then a1=df-0.2 end;if cJ:len()>=a1 or rm==0 and q0 or a3/4>t0 then bc=false;if bh~="Cruising"then fU("apCru","AP")bh="Cruising"end;bf=true;qb=0 end;local t2=rl;if t2<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pM and cW>2000 then ct.ResetAutopilots(1)c3="Autopilot cancelled to prevent crossing PvP Line"b1="PvP Prevent"pM=cW else pM=cW;return end end;bc=false;if bh~="Braking"then fU("apBrk","AP")bh="Braking"end;be=true;if not b5 then b3=true;cz=true end;qb=0;q0=false end elseif be then if bh~="Orbiting to Target"then b1="AP Brk"end;if b5 then qb=1;qd=true end;local dQ,sB=cq(c8):escapeAndOrbitalSpeed((cO-kE.center):len()-kE.radius)local qV;if g5 then qV=g5.position-cO end;if g5 and g5.planetname=="Space"and cL<50 then if#bG>0 then if not qm then table.remove(bG,1)end;if#bG>0 then b1=false;if not qm then qm=2 end;return end end;sN("Autopilot complete, arrived at space location")b1="Space Arrival"elseif g5 and g5.planetname~="Space"and cL<=sB and(ft.apoapsis==nil or ft.periapsis==nil or ft.apoapsis.altitude<=0 or ft.periapsis.altitude<=0)then sN("Autopilot complete, commencing reentry")bl=g5.position;cc=true;ct.showWayPoint(c8,bl)elseif(g5 and g5.planetname~="Space"or g5==nil)and ft.periapsis~=nil and ft.periapsis.altitude>0 and ft.eccentricity<1 or bh=="Circularizing"then if bh~="Circularizing"then fU("apCir","AP")bh="Circularizing"end;if cL<=sB then if g5 then if cK:normalize():dot(qV:normalize())>0.4 then if bh~="Orbiting to Target"then fU("apOrb","OB")bh="Orbiting to Target"end;if not r7 then b1=false;ct.showWayPoint(c8,g5.position)r7=true end else sN("Autopilot complete, proceeding with reentry")bl=g5.position;cc=true;ct.showWayPoint(c8,g5.position)r7=false end else sN("Autopilot completed, setting orbit",true)b1=false end end elseif bh=="Circularizing"then sN("Autopilot complete, fixing Orbit",true)end elseif bf then local t2=rl;if t2<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pM and cW>2000 then if not qm then qm=true end;c3="Autopilot cancelled to prevent crossing PvP Line"b1="Prevent PvP"pM=cW else pM=cW;return end end;bc=false;if bh~="Braking"then fU("apBrk","AP")bh="Braking"end;be=true;if not b5 then b3=true;cz=true end end;local rm=c.getThrottle()if t then rm=bR end;if rm>0 then bc=true;if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end;bf=false end else if sr then if not bd and g5==nil or not bd and g5 and g5.planetname~="Space"then if not cc then bl=vec3(c8.center)+(gp+c8.radius)*cI;t3=q8;t4=cI end;bd=true elseif sr and not qg then bc=true;if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end;if not q0 then qb=a2;qd=true;bR=fV(a2,2)q0=true;b1=false end end end end elseif b4 and(g5~=nil and g5.planetname~="Space"and cg)then c3="Autopilot complete, starting reentry"fU("apCom","AP")bl=g5.position;b1=false;be=false;b4=false;r5=false;bh="Aligning"qb=0;q0=false;b3=true;cc=true;ct.showWayPoint(c8,g5.position)end;if c0 then cz=true;local sW=0;local fv=vec3(DUPlayer.getWorldPosition())local t5=fv-cO;local t6=vec3(t5):project_on(cH):len()local t7=vec3(t5):project_on(cI):len()local cb=dn(t6*t6+t7*t7)qO(t5:normalize())local mC=40;local t8=cb<mC;local t9=100;local rz=dl((cb-mC)/2,10,t9)q2=0;local sr=eZ(q3)<0.1;if sr and cL<rz and not t8 then b1=false;sW=-20 else b1="Follow"sW=0 end;local ta=0;if eZ(sW-cS)>ta then if tb==nil then tb=pid.new(2*0.01,0,2*0.1)end;tb:inject(sW-cS)local sY=tb:get()q2=sY end end;if b6 or b7 or b9 or br or bu~=nil then if bI then if cf==-1 then bb=bb-0.2 else bb=ci+bI-cf end end;local tc=bv;if tc then tc=tc*dl(cL/100,0.1,1)*ch else tc=bt end;if not cg then tc=bt end;qa=cH:project_on_plane(cM):normalize():dot(cK)if qa>100 then c6,c7=cp.computeDistanceAndTime(qa,100,cj,0,0,tc)local td,te=cp.computeDistanceAndTime(100,0,cj,0,0,tc*0.55)c6=c6+td else c6,c7=cp.computeDistanceAndTime(qa,0,cj,0,0,tc*0.55)end;local sF=bb-ci-cN;local tf=200+cL;if b9 or cc then tg=2000+cL end;local th=1;if b8 then th=dl(cL/100,0.1,1)end;local sW=(utils.smoothstep(sF,-tf,tf)-0.5)*2*Q*th;if not b9 and not cc and not br and cH:dot(cK:normalize())<0.99 then sW=(utils.smoothstep(sF,-tf*dl(20-19*ch*10,1,20),tf*dl(20-19*ch*10,1,20))-0.5)*2*Q*dl(2-ch*10,1,2)*th end;if not b6 then sW=0 end;if bu~=nil then if cY and not bA then sW=bu else bu=nil end end;cz=true;local ti=q2;if b9 then local tj=bN(cB)local tk,tl=cp.computeDistanceAndTime(cL,tj/3.6,cj,0,0,bt-kE.gravity*9.8*cj)tk=tk==-1 and 5000 or tk;local r6=ci-(kE.noAtmosphericDensityAltitude+tk)local tm=ci>kE.noAtmosphericDensityAltitude+tk*1.35;if tm then sW=R;if cL<=tj/3.6 and cL>tj/3.6-10 and eZ(cK:normalize():dot(cH))>0.9 and not cR then bV=false;qb=1 end elseif(cR or iI:getTargetSpeed(axisCommandId.longitudinal)~=tj)and not tm and not cg then qc=tj;qd=true end;if cR then if cL>tj/3.6 and not tm then b1="Reentry Limit"if bR>0 then qb=0 end else b1=false end else b1=false end;if cN>0 then b1="Reentry vSpd"end;if not q1 then sW=-80;if ci<kE.surfaceMaxAltitude+(kE.atmosphereThickness-kE.surfaceMaxAltitude)*0.25 then c3="PARACHUTE DEPLOYED at "..fV(ci,0)b9=false;b7=true;lu=true;qb=0;sW=0;cz=q end elseif kE.noAtmosphericDensityAltitude>0 and tm then cz=true elseif not tm then if not cg and(cR or iI:getTargetSpeed(axisCommandId.longitudinal)~=tj)then qc=tj end;if cL<tj/3.6+1 then b1=false;q1=false;b9=false;cz=true;qb=1 end end end;if cL>j0 and not cd and not br and not b7 and u then qO(vec3(cK))end;if cX or(br or cd)and bm>0 and cg then local qV;if cX then if type(cX)=="table"then qV=cX elseif cX<3 and cX>0 then qV=-cM:cross(cK)*5000 elseif cX>=3 then qV=cM:cross(cK)*5000 elseif cX<0 then qV=cK*25000 end elseif g5~=nil then qV=g5.position-cO else qV=c8.center-cO end;local sV=math.deg(qw(cM:normalize(),cK,qV))*2;local mF=math.rad(eZ(cT))if cL>aM and cg then local tn=1000+cL;local to=(utils.smoothstep(sF-cN*10,-tn,tn)-0.5)*2*Q;local tp=dl(90-to,0,180)q5=dl(sV*2,-tp,tp)local tq=sV;sV=dl(dl(sV,-N*0.80,N*0.80)*math.cos(mF)+4*(cS-sW)*math.sin(math.rad(cT)),-N*0.80,N*0.80)local tr=1;if q5~=0 then tr=eZ(mF/q5)end;tr=(90-dl(eZ(q5-cT),0,90))/90;local ts=sW;if eZ(cT)>90 then ts=-ts end;sW=tr*dl(dl(ts*math.cos(mF),-O*0.8,O*0.8)+eZ(dl(eZ(tq)*math.sin(mF),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q5=0;sV=dl(sV,-N*0.80,N*0.80)end;local tt=sh-sV;if cX and eZ(tt)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and eZ(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fU("180Off","BR")return end;if not cA and cL>aM and cg then if tu==nil then tu=pid.new(2*0.01,0,2*0.1)end;tu:inject(tt)local s_=dl(tu:get(),-1,1)q3=q3+s_ elseif cg and cf>-1 or cL<aM then qO(qV)elseif cA and cg then if(sh<-N or sh>N)and cg then qO(cK)end;if(si<-O or si>O)and cg then sW=dl(cS-si,cS-O*0.80,cS+O*0.80)end end;if g5~=nil and not cd then local ss=kE:getAltitude(g5.position)local r6=qV:project_on_plane(cM):len()lu=true;if bb<kE.noAtmosphericDensityAltitude and not cd and not b8 and not b9 and(r6<=c6 and qV:len()<kE.radius)and(cK:project_on_plane(cM):normalize():dot(qV:project_on_plane(cM):normalize())>0.99 or lA=="Finalizing Approach")then lA="Finalizing Approach"if#bG>0 then if not qm then table.remove(bG,1)end;if#bG>0 then if not qm then qm=2 end;return end end;qb=0;if b6 then ct.ToggleAltitudeHold()br=true end;b1="AP Finalizing"elseif not b8 then b1=false end;if lA=="Finalizing Approach"and(qa<0.1 or r6<0.1 or tv~=nil and tv<r6)then fU("bklOn","BL")b7=true;db=true;if g5.heading then dc=g5.heading else dc=nil end;br=false;lA="Proceeding to Waypoint"cZ=false end;tv=r6 end elseif br and not cg and bb>kE.noAtmosphericDensityAltitude and not(cd or b9)then if g5~=nil and c8.name==kE.name then local qV=g5.position-cO;local ss=kE:getAltitude(g5.position)local r6=dn(qV:len()^2-(ci-ss)^2)local tc=bv;if tc then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,tc/2)lu=true;if r6<=c6+cL*sg/2 and cK:project_on_plane(cM):normalize():dot(qV:project_on_plane(cM):normalize())>0.99 then if kE.hasAtmosphere then b1=false;b3=false;q1=true;cc=false;ce=true;b4=false;ct.BeginReentry()end end;tv=r6 end end end;if not cg and cf==-1 and(b6 and bb>kE.noAtmosphericDensityAltitude)and not(cd or bA or b9)then if not cE and not bA then cD=bb;pW=true;if br then q7.VectorToTarget=true end;ct.ToggleIntoOrbit()br=false;pU=true end end;if cA and cg and cf==-1 and cL>aM and lA~="Finalizing Approach"then qO(cK)sW=dl(cS-si,cS-O*0.80,cS+O*0.80)end;q2=ti;local qH=-1;if b7 then if not qh then rZ=false;if not cR then qb=0 end;iI:setTargetGroundAltitude(500)iI:activateGroundEngineAltitudeStabilization(500)bC=true;if not cg then rZ=true end;qh=true end;sW=0;local tw=false;local tx=math.abs(qa)if not r and cQ then tw=antigrav.getBaseAltitude()if tw<kE.surfaceMaxAltitude and g5==nil or g5~=nil and kE:getAltitude(g5.position)>tw then tw=false end else tw=false end;if dc then if tx<0.05 then if cN>-P then b1=false else b1="BL Align BLR"end;if qO(dc,0.001)then dc=nil;cz=q else q2=0;cz=true end else b1="BL Align Hzn"end;if tw and eZ(ci-tw)<250 then b1="AGG Align"end else local ty=false;local tz=30;if tx<10 and so~=nil and so>0 then local tA=dl(ch,0.4,2)local tc=bv*dl(cL/100,0.1,1)*tA;local tB=so*tA+tc-og;local tC=tc/2-og;local tD=cL-dn(eZ(tC/2)*20/(0.5*cj))*utils.sign(tC)if tD<0 then tD=0 end;local tE;if cL>100 then local tF,dQ=cp.computeDistanceAndTime(cL,100,cj,0,0,tc)local tG,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,dn(tc))tE=tF+tG else tE=cp.computeDistanceAndTime(cL,0,cj,0,0,dn(tc))end;if tE<20 then b1=false else local tH=0;if tD>100 then local tI,dQ=cp.computeDistanceAndTime(tD,100,cj,0,0,tB)local tJ,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,so*tA+dn(tc)-og)tH=tI+tJ else tH,dQ=cp.computeDistanceAndTime(tD,0,cj,0,0,so*tA+dn(tc)-og)end;tH=(tH+15+cL*sg)*1.1;local tK=db and g5~=nil and kE:getAltitude(g5.position)>0 and g5.safe;local ss=nil;if tw and tw<ci then ss=tw elseif tK then ss=kE:getAltitude(g5.position)+250 elseif ci>kE.surfaceMaxAltitude then ss=kE.surfaceMaxAltitude end;if c_ then local tL=kE:getAltitude(c_[1].center)if ss then if tL>ss then ss=tL end else ss=tL end end;if ss~=nil then local tM=ci-ss;ty=true;if tM<=tH or tH==-1 or tx>0.05 and db then if tx>0.05 and db then b1="BL AP Hzn"else b1="BL Stop Dist"end else b1=false end end end end;qH=cf;if qH>-1 then if not tw and not bn then qe=true;iI:setTargetGroundAltitude(_)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qH-5<_ then b7=false;b6=false;b_=0;if rZ then qZ(0,1)end;b1="BL Complete"cz=q;db=false;qh=false else if cN<-5 or tx>0.05 then b1="BL Slowing"else b1=false end end elseif not ty then if lu and cK:normalize():dot(-gr)<0.999 then b1="BL Strong"qO()elseif tx>10 or tx>0.05 and db then b1="BL hSpd"elseif cN<-P then b1="BL BLR"if rZ then qZ(0,1)end else if rZ then qZ(-1)end;b1=false end end end else qh=false end;if b8 or cd then local lw,eK,eJ;if bl~=nil then lw,eK,eJ=co:getPlanetarySystem(0):castIntersections(cO,(bl-cO):normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)end;if cQ and not cd then if ci>=bb-50 and cL>j0 then b8=false;if not b4 and not br then b1="ATO Agg Arrive"qb=0 end end elseif eZ(sW)<15 and ci/bb>0.75 then b8=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<j0 then b4=true;cd=false;b6=false;b8=false;qb=0 elseif cd then qb=0;b1="ATO Space"end elseif cd and not cg and c8~=nil and(lw==nil or lw.name==c8.name)then b4=true;cd=false;b6=false;b8=false;if not cR then qb=0 end;bc=true end end;local tN=cf>-1;local tO=cS;if(br or cd or cX)and not tN and cL>aM and cg then local mF=math.rad(eZ(cT))tO=cS*eZ(math.cos(mF))+si*math.sin(mF)end;local tP=dl(sW-tO,-O*0.80,O*0.80)if not cg and br then tP=dl(sW-tO,-85,Q)elseif not cg then tP=dl(sW-tO,-Q,Q)end;if eZ(cT)<5 or br or cX or b7 or tN or b6 then if tb==nil then tb=pid.new(5*0.01,0,5*0.1)end;tb:inject(tP)local sY=tb:get()q2=q2+sY end end;if antigrav~=nil and(antigrav and not r and ci<200000)then if bw==nil or bw<1000 then bw=1000 end;if tQ~=bw then tQ=bw;ql=tQ end end;if(cg or b9 or ce)and t and cR then if tR==nil then tR=pid.new(0.1,0,1)end;local tS=0;if aV>0 and not b9 and ch>0.005 and ch<0.1 and cN>-10 then local tT=bP.getFrictionBurnSpeed()*aV;local tU=cB/3.6;if tT>tU then tS=tT-tU-1 end end;tR:inject(cB/3.6+tS-cK:dot(cH))local tV=tR:get()bU=dl(tV,-1,1)if not d7 then if bU<bR and(ch>0.005 or b9 or ce)then bT=true;d7=dl(bU,0.01,1)else bT=false;d7=bR end end;if tW==nil then tW=pid.new(1*0.01,0,1*0.1)end;tW:inject(cK:len()-cB/3.6-tS)local tX=dl(tW:get(),0,1)if cg and cN<-80 or(ch>0.005 or b9 or ce)then bS=tX end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dl(bU,0.01,1)end;local tY=''local tZ=vec3()local t_=rx(axisCommandId.vertical,b_*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",t_,rV)local u0='thrust analog longitudinal 'if bD=="All"or bD=="Longitude"then u0=u0 ..aW end;local u1=iI:getAxisCommandType(axisCommandId.longitudinal)local u2=iI:composeAxisAccelerationFromThrottle(u0,axisCommandId.longitudinal)local u3=rK(axisCommandId.lateral,bz*1000)tY=tY..' , '.."lateral airfoil , lateral ground "tZ=tZ+u3;if tZ:len()>constants.epsilon then d:setEngineForceCommand(tY,tZ,rV,'','','',rW)end;d:setEngineForceCommand(u0,u2,rU)local u4='thrust analog vertical fueled 'local u5='thrust analog lateral fueled 'if bD=="All"or bD=="Lateral"then u5=u5 ..aX end;if bD=="All"or bD=="Vertical"then u4=u4 ..aY end;if b_~=0 or b7 and b1 or not bn and not bC then d:setEngineForceCommand(u4,t_,rU)else d:setEngineForceCommand(u4,vec3(),rU)end;if bz~=0 then d:setEngineForceCommand(u5,u3,rU)else d:setEngineForceCommand(u5,vec3(),rU)end;if s2==0 then s2=bS end;local u6=-s2*(aR*cK+aS*s6)d:setEngineForceCommand('brake',u6)else if t then if not d7 then d7=bR end end;local rz=c.getAxisCommandValue(0)if not cR then if tW==nil then tW=pid.new(1*0.01,0,1*0.1)end;tW:inject(cK:len()-rz/3.6)local tX=dl(tW:get(),0,1)s2=dl(s2+tX,0,1)end;local u6=-s2*(aR*cK+aS*s6)d:setEngineForceCommand('brake',u6)local tY=''local tZ=vec3()local u7=false;local u0='thrust analog longitudinal 'if aW~="none"and(bD=="All"or bD=="Longitude")then u0=u0 ..aW end;local u1=iI:getAxisCommandType(axisCommandId.longitudinal)if u1==axisCommandType.byThrottle then local u2=iI:composeAxisAccelerationFromThrottle(u0,axisCommandId.longitudinal)d:setEngineForceCommand(u0,u2,rU)elseif u1==axisCommandType.byTargetSpeed then local u2=iI:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tY=tY..' , '..u0;tZ=tZ+u2;if iI:getTargetSpeed(axisCommandId.longitudinal)==0 or iI:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iI:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u7=true end end;local u5='thrust analog lateral 'if aX~="none"and(bD=="All"or bD=="Lateral")then u5=u5 ..aX end;local u8=iI:getAxisCommandType(axisCommandId.lateral)if u8==axisCommandType.byThrottle then local u9=iI:composeAxisAccelerationFromThrottle(u5,axisCommandId.lateral)d:setEngineForceCommand(u5,u9,rU)elseif u8==axisCommandType.byTargetSpeed then local u3=iI:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tY=tY..' , '..u5;tZ=tZ+u3 end;local u4='thrust analog vertical 'if aY~="none"and(bD=="All"or bD=="Vertical")then u4=u4 ..aY end;local ua=iI:getAxisCommandType(axisCommandId.vertical)if ua==axisCommandType.byThrottle then local t_=iI:composeAxisAccelerationFromThrottle(u4,axisCommandId.vertical)if b_~=0 or b7 and b1 then d:setEngineForceCommand(u4,t_,rU,'airfoil','ground','',rW)else d:setEngineForceCommand(u4,vec3(),rU)d:setEngineForceCommand('airfoil vertical',t_,rU,'airfoil','','',rW)d:setEngineForceCommand('ground vertical',t_,rU,'ground','','',rW)end elseif ua==axisCommandType.byTargetSpeed then if b_<0 then d:setEngineForceCommand('hover',vec3(),rU)end;local ub=iI:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tY=tY..' , '..u4;tZ=tZ+ub end;if tZ:len()>constants.epsilon then if s2~=0 or u7 or eZ(s6:dot(cH))<0.5 then tY=tY..', brake'end;d:setEngineForceCommand(tY,tZ,rV,'','','',rW)end end;local uc=aO*(sa-s9)local ud=vec3(bP.getWorldAirFrictionAngularAcceleration())uc=uc-ud;d:setEngineTorqueCommand('torque',uc,rU,'airfoil','','',rW)d:setBoosterCommand('rocket_engine')if c5 and not o then local fp=cJ:len()local ue=0.15;if not cR then local uf=iI:getTargetSpeed(axisCommandId.longitudinal)if fp*3.6>uf*(1-ue)and ug then ug=false;d:toggleBoosters()elseif fp*3.6<uf*(1-ue)and not ug then ug=true;d:toggleBoosters()end else local rm=c.getThrottle()if t then rm=bR*100 end;local rz=rm/100;if not cg then rz=rz*a1;if fp>=rz*(1-ue)and ug then ug=false;d:toggleBoosters()elseif fp<rz*(1-ue)and not ug then ug=true;d:toggleBoosters()end else local tj=bN(cB)rz=rz*tj/3.6;if fp>=rz*(1-ue)and ug then ug=false;d:toggleBoosters()elseif fp<rz*(1-ue)and not ug then ug=true;d:toggleBoosters()end end end end end;if uh then for dL,dx in pairs(uh)do pK[dL]=dx end end;cf=qC()return pK end;local function ui(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uj,iH,iI,iJ,uk,gM,fV,e4,dm,dl,fU,iL,pJ)local bP=DUConstruct;local ul={}local um=true;local un=5;local uo=5;local up=un;local uq=uo;local ur=bQ;function ul.landingGear(qe)bn=not bn;if bn then br=false;bu=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not qe then fU("bklOn","BL")lu=true;b9=false;b8=false;ba=false;if bA then ct.ToggleIntoOrbit()end;if b7 then db=not db end;b7=true;cz=true;bn=false else if bW then fU("grOut","LG",1)d.control.deployLandingGears()end;db=false;iI:setTargetGroundAltitude(_)if cg then b1="Landing"end end;b6=false;bI=false elseif bW and not b7 then fU("grOut","LG",1)d.control.deployLandingGears()end else if bW then fU("grIn","LG",1)d.control.retractLandingGears()end;iI:activateGroundEngineAltitudeStabilization(r1)if bC then if _<iI.targetGroundAltitude then iI:setTargetGroundAltitude(iI.targetGroundAltitude)else iI:setTargetGroundAltitude(Z)end end end end;function ul.startControl(us)local function ut(rh)local ri=1;local function uu(uv,rh)local uw={kE.surfaceMaxAltitude+100,kE.spaceEngineMinAltitude-0.01*kE.noAtmosphericDensityAltitude,kE.noAtmosphericDensityAltitude+V,kE.radius*(U-1)+kE.noAtmosphericDensityAltitude}local ux=uv;for dQ,dx in ipairs(uw)do if rh and ux>dx then uv=dx elseif uv<dx and not rh then uv=dx;break end end;return uv end;if rh then ri=-1 end;if not r and cQ then if c1 and rh then bw=1000 elseif bw~=nil then bw=bw+ri*uo;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end else bw=tQ+ri*100 end elseif b6 or ba or bA then if bA then if c1 then cD=uu(cD,rh)else cD=cD+ri*un end;if cD<kE.noAtmosphericDensityAltitude then cD=kE.noAtmosphericDensityAltitude end else if c1 and cg then bb=uu(bb,rh)bI=false else bb=bb+ri*un;if bI then if bb>100 then bI=false else iI:updateTargetGroundAltitudeFromActionStart(ri*1.0)bI=d:getTargetGroundAltitude()end end end end else iI:updateTargetGroundAltitudeFromActionStart(ri*1.0)end end;local function uy(uz)if not cg then c3="Flight Assist in Atmo only"return end;local du=type(uz)if cX==nil then if du=="table"then if b4 or br then ct.ToggleAutopilot()end;fU("180On","BR")elseif uz==1 then fU("bnkLft","BR")else fU("bnkRht","BR")end;if not b6 and not b4 and not br then ct.ToggleAltitudeHold()if du~="table"then uz=uz+1 end end;cX=uz else fU("180Off","BR")cX=nil end end;local function uA()if iJ()==1 then c9=0;ca=0;uk(bj)elseif iH()==1 and y then cy=false;cx=false end;c1=false end;if us=="gear"then cv.landingGear()elseif us=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif us=="forward"then if pb and not cg and not b4 then b3=not b3;b2=false else bX=bX-1 end elseif us=="backward"then if pb then if not cg then if not b4 then b2=not b2;b3=false else b5=not b5 end else uy(-cK*5000)end else bX=bX+1 end elseif us=="left"then if pb then uy(1)else bY=bY-1 end elseif us=="right"then if pb then uy(3)else bY=bY+1 end elseif us=="yawright"then bZ=bZ-1;dc=nil elseif us=="yawleft"then bZ=bZ+1;dc=nil elseif us=="straferight"then iI:updateCommandFromActionStart(axisCommandId.lateral,1.0)bz=1 elseif us=="strafeleft"then iI:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bz=-1 elseif us=="up"then ct.vertical(1)if cf-3<_ and ci>0 and bn then cv.landingGear()end elseif us=="down"then ct.vertical(-1)elseif us=="groundaltitudeup"then ut()elseif us=="groundaltitudedown"then ut(true)elseif us=="option1"then uB=false;if pb and c1 then local uC=""for M=1,#d2 do uC=uC.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fV(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..uC)return end;cs.adjustAutopilotTargetIndex()elseif us=="option2"then uB=false;if pb and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;c3="Deboarded All Passengers"return end;cs.adjustAutopilotTargetIndex(1)elseif us=="option3"then uB=false;if pb and c1 then local uC=""for M=1,#d3 do uC=uC.."| ID: "..d3[M].." Mass: "..fV(b.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..uC)return end;if x then if w then w=false else w=true end;if cu then cu.ToggleRadarPanel()end end elseif us=="option4"then uB=false;if pb and c1 then for M=1,#d3 do b.forceUndock(d3[M])end;c3="Undocked all ships"return end;cX=nil;ct.ToggleAutopilot()elseif us=="option5"then uB=false;ct.ToggleLockPitch()elseif us=="option6"then uB=false;if pb and c1 then if shield then cw.ventShield()else c3="No shield found"end;return end;ct.ToggleAltitudeHold()elseif us=="option7"then uB=false;if pb and c1 then if shield then shield.toggle()return else c3="No shield found"return end end;E=not E;if E then c3="Collision System Enabled"else c3="Collision System Secured"end elseif us=="option8"then uB=false;if pb and c1 then if bm>0 and g5~=nil then ct.routeWP()else c3="Select a saved wp on IPH to add to or remove from route"end;return end;bC=not bC;if not bC then c3="DeCoupled Mode - Ground Stabilization off"iI:deactivateGroundEngineAltitudeStabilization()fU("gsOff","GS")else c3="Coupled Mode - Ground Stabilization on"iI:activateGroundEngineAltitudeStabilization(r1)de=true;fU("gsOn","GS")end elseif us=="option9"then uB=false;if pb and c1 then iI:resetCommand(axisCommandId.longitudinal)iI:resetCommand(axisCommandId.lateral)iI:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()==1;if ck then fU("gyOn","GA")else fU("gyOff","GA")end else c3="No gyro found"end elseif us=="lshift"then if pb then c1=true end elseif us=="brake"then if a_ or pb then ct.BrakeToggle("Manual")elseif not b1 then ct.BrakeToggle("Manual")else b1="Manual"end elseif us=="lalt"then uB=true;pb=true;if iH()==0 and not j and g=="keyboard"then uk(1)end elseif us=="booster"then if o then d:toggleBoosters()elseif not c5 then if not ug then d:toggleBoosters()ug=true end;c5=true else if ug then d:toggleBoosters()ug=false end;c5=false end elseif us=="stopengines"then local function uD()if bQ-ur<1.5 then fU("clear","CA")ct.clearAll()end end;uD()ur=bQ;if iI:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if pb then if cB>0 then cB=0 else cB=W end elseif bR~=0 then iI:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iI:getTargetSpeed(axisCommandId.longitudinal)~=0 then iI:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(a1*3.6)end end end elseif us=="speedup"then ct.changeSpd()elseif us=="speeddown"then ct.changeSpd(true)elseif us=="antigravity"and not r then if antigrav~=nil then ct.ToggleAntigrav()else c3="No antigrav found"end elseif us=="leftmouse"then c2=true;if c1 then uA()uB=false else c1=true;bj=iJ()uk(1)end end end;function ul.stopControl(us)local function uE()if not r and cQ then uq=uo end;if b6 or ba or bA then up=un end end;if us=="forward"then bX=0 elseif us=="backward"then bX=0 elseif us=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif us=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif us=="yawright"then bZ=0 elseif us=="yawleft"then bZ=0 elseif us=="straferight"then iI:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bz=0 elseif us=="strafeleft"then iI:updateCommandFromActionStop(axisCommandId.lateral,1.0)bz=0 elseif us=="up"then ct.vertical(0,-1)elseif us=="down"then ct.vertical(0,1)elseif us=="groundaltitudeup"then uE()uB=false elseif us=="groundaltitudedown"then uE()uB=false elseif us=="brake"then if not a_ and not pb then if b1 then ct.BrakeToggle()else b1=false end end elseif us=="lalt"then if c1 then c1=false end;if iH()==0 and j then if uB then if iJ()==1 then uk(0)else uk(1)end else uB=true end elseif iH()==0 and not j and g=="keyboard"then uk(0)end;pb=false end end;function ul.loopControl(us)local function uF(rh)local ri=1;if rh then ri=-1 end;if not r and cQ then if bw~=nil then bw=bw+ri*uq;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end;uq=dl(uq*1.05,uo,50)else bw=tQ+ri*100 end elseif b6 or ba or bA then if bA then cD=cD+ri*up;if cD<kE.noAtmosphericDensityAltitude then cD=kE.noAtmosphericDensityAltitude end else bb=bb+ri*up end;up=dl(up*1.05,un,50)else iI:updateTargetGroundAltitudeFromActionLoop(ri*1.0)end end;local function uG(rh)local ri=1;if rh then ri=-1 end;if not c1 then if t and not pb then bR=dl(bR+ri*aG/100,-1,1)else iI:updateCommandFromActionLoop(axisCommandId.longitudinal,ri*aG)end end end;if us=="groundaltitudeup"then if not c1 then uF()end elseif us=="groundaltitudedown"then if not c1 then uF(true)end elseif us=="speedup"then uG()elseif us=="speeddown"then uG(true)end end;function ul.inputTextControl(rg)local function uH(uI,fv,gz)local function uJ(fv)local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local dU,dV,e1,e2,e3=e4(fv,dE)if dU=="0"and dV=="0"then return vec3(dm(e1),dm(e2),dm(e3))end;e2=math.rad(e2)e1=math.rad(e1)local kE=e[dm(dU)][dm(dV)]local eV=math.cos(e1)local uK=vec3(eV*math.cos(e2),eV*math.sin(e2),math.sin(e1))return kE.center+(kE.radius+e3)*uK end;local fX=uJ(fv)return cs.AddNewLocation(uI,fX,gz)end;local M;local uL,iw=nil,nil;local uM="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(rg," ")uL=rg;if M~=nil then uL=string.sub(rg,0,M-1)iw=string.sub(rg,M+1)end;if uL=="/help"or uL=="/commands"then for lv in string.gmatch(uM,"([^\n]+)")do a.print(lv)end;return elseif uL=="/setname"then if iw==nil or iw==""then c3="Usage: ah-setname Newname"return end;if bm>0 and g5~=nil then cs.UpdatePosition(iw)else c3="Select a saved target to rename first"end elseif shield and uL=="/resist"then cw.setResist(iw)elseif uL=="/addlocation"or string.find(rg,"::pos")~=nil then local gz=false;local uI="0-Temp"if iw==nil or iw==""or uL~="/addlocation"then iw=uL;gz=true end;M=string.find(iw,"::")if not gz then uI=string.sub(iw,1,M-2)end;local fv=string.sub(iw,M)uH(uI,fv,gz)elseif uL=="/agg"then if iw==nil or iw==""then c3="Usage: /agg targetheight"return end;iw=dm(iw)if iw<1000 then iw=1000 end;bw=iw;c3="AGG Target Height set to "..iw elseif uL=="/G"then if iw==nil or iw==""then c3="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if iw=="dump"then for dL,dx in pairs(iL())do if type(dx.get())=="boolean"then if dx.get()==true then a.print(dL.." true")else a.print(dL.." false")end elseif dx.get()==nil then a.print(dL.." nil")else a.print(dL.." "..dx.get())end end;return end;M=string.find(iw," ")local uN=string.sub(iw,0,M-1)local uO=string.sub(iw,M+1)for dL,dx in pairs(iL())do if dL==uN then local uP=type(dx.get())if uP=="number"then uO=dm(uO)if dL=="AtmoSpeedLimit"then cB=uO end end;c3="Variable "..uN.." changed to "..uO;if dL=="MaxGameVelocity"then uO=uO/3.6;if uO>df-0.2 then uO=df-0.2;c3="Variable "..uN.." changed to "..fV(uO*3.6,1)end end;if uP=="boolean"then if string.lower(uO)=="true"then uO=true else uO=false end end;dx.set(uO)return end end;c3="No such global variable: "..uN elseif uL=="/deletewp"then if bm>0 and g5~=nil then cs.ClearCurrentPosition()else c3="Select a custom wp to delete first in IPH"end elseif uL=="/copydatabank"then if dbHud_2 then pJ(true)else c3="Spare Databank required to copy databank"end elseif uL=="/iphWP"then if bm>0 then a.print(ct.showWayPoint(c8,bl,true))a.print(json.encode(bl))c3="::pos waypoint shown in lua chat in local and world format"else c3="No target selected in IPH"end elseif uL=="/createPrivate"then local uQ="privatelocations = {\n"local uR=""if#d9>0 then for dL,dx in pairs(d9)do uQ=uQ.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uQ=uQ.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uQ=uQ.."safe = true},\n"else uQ=uQ.."safe = false},\n"end end end;uR=#d9 .."-Private "if iw=="all"then for dL,dx in pairs(bq)do uQ=uQ.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '*"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uQ=uQ.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uQ=uQ.." safe = true},\n"else uQ=uQ.."safe = false},\n"end end;uR=uR..#bq.."-Public "end;uQ=uQ.."}\n return privatelocations"if uj then uj.setHTML(uQ)end;c3=uR.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c4=7 end end;function ul.tagTick()if bD=="Off"then bD="All"elseif bD=="All"then bD="Longitude"elseif bD=="Longitude"then bD="Lateral"elseif bD=="Lateral"then bD="Vertical"else bD="Off"end;c3="Extra Engine Tags: "..bD;c.stopTimer("tagTick")end;if uS then for dL,dx in pairs(uS)do ul[dL]=dx end end;return ul end;local function uT(d,b,c,e,vBooster,hover,pI,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iE,uj)local a=DUSystem;local bP=DUConstruct;local uU=DUPlayer;local uV=DULibrary;local uW={}local dk=string.format;local iF=json.decode;local uX=json.encode;local pB=b.getElementMaxHitPointsById;local iG=b.getElementMassById;local iH=d.control.isRemoteControlled;local e4=string.match;local gM=a.destroyWidgetPanel;local fS=a.updateData;local fT=a.addDataToWidget;local uk=a.lockView;local iJ=a.isViewLocked;local dn=math.sqrt;local dm=tonumber;local eZ=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local eU=math.atan;local bM=a.getArkTime;local dl=utils.clamp;local iI=d.axisCommandManager;local gO=13;local iO=b.getElementIdList()local iP=0;local function dp(eC,eD)if eC==0 then return eZ(eD)<1e-09 elseif eD==0 then return eZ(eC)<1e-09 else return eZ(eC-eD)<math.max(eZ(eC),eZ(eD))*dC end end;local function fV(dD,uY)local ri=10^(uY or 0)return bN(dD*ri+0.5)/ri end;local function iK(uZ,u_)for dL,dx in pairs(u_)do if type(dL)=="string"then uZ[dL]=dx else uZ[#uZ+1]=u_[dL]end end;return uZ end;local function iL(v0)local v1={}if not v0 then iK(v1,L)iK(v1,ac)iK(v1,aE)iK(v1,aZ)return v1 elseif v0=="boolean"then return L elseif v0=="handling"then return ac elseif v0=="hud"then return aE elseif v0=="physics"then return aZ end end;local function pJ(v2)local function v3(v4)for dL,dx in pairs(v4)do dbHud_1.setStringValue(dL,uX(dx.get()))if v2 and dbHud_2 then dbHud_2.setStringValue(dL,uX(dx.get()))end end end;if dbHud_1 then v3(bJ)v3(iL())a.print("Saved Variables to Datacore")if v2 and dbHud_2 then c3="Databank copied.  Remove copy when ready."end end end;local function fU(v5,v6,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v5 ..".mp3")end;local function gN(hH,hI,rg,jW,v7)return dk([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jW or"",hH,hI,v7 or"",rg)end;local function iM(cb,v8)v8=v8 or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fV(cb,v8)..unit end;local function iN(v9)local va=0;local vb=0;local vc=0;if v9<60 then v9=bN(v9)elseif v9<3600 then va=bN(v9/60)v9=bN(v9%60)elseif v9<86400 then vb=bN(v9/3600)va=bN(v9%3600/60)else vc=bN(v9/86400)vb=bN(v9%86400/3600)end;if vc>365 then return">1y"elseif vc>0 then return vc.."d "..vb.."h "elseif vb>0 then return vb.."h "..va.."m "elseif va>0 then return va.."m "..v9 .."s"elseif v9>0 then return v9 .."s"else return"0s"end end;local function vd()if radar_1 then cu=gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU)end end;function uW.radarSetup()vd()end;function uW.onStart()local ve=false;local function vf()local function vg(vh)local vi=dbHud_1.hasKey;for dL,dx in pairs(vh)do if vi(dL)then local dG=iF(dbHud_1.getStringValue(dL))if dG~=nil then dx.set(dG)ve=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vg(iL())coroutine.yield()vg(bJ)else vg(bJ)c3="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values"c4=5;ve=false end;coroutine.yield()if ve then c3="Loaded Saved Variables"elseif not f then c3="No Databank Saved Variables Found\nVariables will save to Databank on standing"c4=5 end;if#bq>0 then da=iK(da,bq)end else c3="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;a_=k;g=string.lower(g)cz=q;cB=W;if bx+180<bQ then bv=0 end;bx=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c3="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c4=7 end;if antigrav and not r then if bw==nil then bw=ci end;antigrav.setTargetAltitude(bw)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d9>0 then da=iK(da,d9)end end;lA="Proceeding to Waypoint"if not a1 or a1<0 then a1=bP.getMaxSpeed()-0.1 end end;local function vj()local function vk(vl,vm)if vl>vm then vm=vl end;local vn,vo=0,0;if a7>0 then vn=a7*0.05 end;if a8>0 then vo=a8*0.05 end;vm=vm*(1-(vn+vo))return vm end;local vp=b.getElementNameById;local vq=au~=0 and av~=0;local vr=_G["atmofueltank_size"]local vs=_G["spacefueltank_size"]local vt=_G["rocketfueltank_size"]for dL in pairs(iO)do local type=b.getElementDisplayNameById(iO[dL])if e4(type,'^.*Atmospheric Engine$')then if e4(tostring(b.getElementTagsById(iO[dL])),'^.*vertical.*$')and b.getElementForwardById(iO[dL])[3]>0 then cP=true end end;if e4(type,'^.*Space Engine$')then cG=true;if e4(tostring(b.getElementTagsById(iO[dL])),'^.*vertical.*$')then local vu=b.getElementForwardById(iO[dL])if vu[3]<0 then vv=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local pD=pB(iO[dL])if pD>10000 then gO=110 elseif pD>1000 then gO=55 elseif pD>150 then gO=27 end end;iP=iP+pB(iO[dL])if vq and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pD=pB(iO[dL])local oo=iG(iO[dL])local vl=0;local jO=bM()if type=="Atmospheric Fuel Tank"then local vm=400;local vw=35.03;if pD>10000 then vm=51200;vw=5480 elseif pD>1300 then vm=6400;vw=988.67 elseif pD>150 then vm=1600;vw=182.67 end;vl=oo-vw;if a4>0 then vm=vm+vm*a4*0.2 end;vm=vk(vl,vm)local gy=vp(iO[dL])local jM=0;for jN=1,vr do if gy==iF(c["atmofueltank_"..jN].getWidgetData()).name then jM=jN;break end end;local vx={iO[dL],string.sub(gy,1,12),vm,vw,vl,jO,jM}cl[#cl+1]=vx end;if type=="Rocket Fuel Tank"then local vm=320;local vw=173.42;if pD>65000 then vm=40000;vw=25740 elseif pD>6000 then vm=5120;vw=4720 elseif pD>700 then vm=640;vw=886.72 end;vl=oo-vw;if a6>0 then vm=vm+vm*a6*0.1 end;vm=vk(vl,vm)local gy=vp(iO[dL])local jM=0;for jN=1,vt do if gy==iF(c["rocketfueltank_"..jN].getWidgetData()).name then jM=jN;break end end;local vx={iO[dL],string.sub(gy,1,12),vm,vw,vl,jO,jM}cn[#cn+1]=vx end;if type=="Space Fuel Tank"then local vm=600;local vw=35.03;if pD>10000 then vm=76800;vw=5480 elseif pD>1300 then vm=9600;vw=988.67 elseif pD>150 then vm=2400;vw=182.67 end;vl=oo-vw;if a5>0 then vm=vm+vm*a5*0.2 end;vm=vk(vl,vm)local gy=vp(iO[dL])local jM=0;for jN=1,vs do if gy==iF(c["spacefueltank_"..jN].getWidgetData()).name then jM=jN;break end end;local vx={iO[dL],string.sub(gy,1,12),vm,vw,vl,jO,jM}cm[#cm+1]=vx end end end;if not cP then ba,b0=false,false end end;local function vy()if gyro~=nil then ck=gyro.isActive()==1 end;if not bC then iI:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then uk(1)else uk(0)end;if door and(cg or not cg and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not r then antigrav.showWidget()end end;if iH()==1 and l then uU.freeze(1)else uU.freeze(0)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bn=d.control.isAnyLandingGearDeployed()==1 or cf~=-1 and cf-3<_;if cf~=-1 or not cg and cJ:len()<50 then b1="Startup"else b1=false end;iI:setTargetGroundAltitude(_)pp=cg end;local function vz()local vA={}local function vB()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vC={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vD,vE in pairs(e)do e[vD][0]=vB()e[vD][0].systemId=vD;vA[vD]={}for vF,kE in pairs(e[vD])do kE.gravity=kE.gravity/9.8;kE.center=vec3(kE.center)kE.name=kE.name[1]kE.noAtmosphericDensityAltitude=kE.atmosphereThickness;kE.spaceEngineMinAltitude=vC[kE.id]or 0.5353125*kE.atmosphereThickness;kE.planetarySystemId=vD;kE.bodyId=kE.id;vA[vD][vF]=kE;if mq==nil or kE.center.x<mq then mq=kE.center.x end;if mp==nil or kE.center.x>mp then mp=kE.center.x end;if mt==nil or kE.center.y<mt then mt=kE.center.y end;if ms==nil or kE.center.y>ms then ms=kE.center.y end;if kE.center and kE.name~="Space"then d4[#d4+1]=kE end end end;ee=dj(d,b,c,a,dk,dl,dm,dn,dp)co=ee(vA)fY=co[0]cp=eY(d,b,c,a,dn,eZ)cq=fr(d,b,c,a,dk,dl,dm,dn,dp)cs=fR(d,b,c,a,dbHud_1,e,fS,fT,bN,dm,dn,fU,fV)kE=co[0]:closestBody(bP.getWorldPosition())end;vG=false;vH=coroutine.create(function()iI:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vf()coroutine.yield()vj()coroutine.yield()ct=pH(d,b,c,e,vBooster,hover,pI,antigrav,dbHud_1,eZ,bN,bO,iH,eU,bM,dl,iI,fS,iJ,dn,fV,fU,iK,dp,iM,iN,pJ,iF)vy()coroutine.yield()vz()vd()if iD then cr=iD(d,b,c,a,e,antigrav,hover,shield,warpdrive,iE,eZ,bN,dk,iF,bO,iG,iH,eU,bM,dl,iI,fT,fS,gM,iJ,dn,fV,gN,fU,iK,iL,iM,iN,iO,iP)end;if cr then cr.ButtonSetup()end;cv=ui(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uj,iH,iI,iJ,uk,gM,fV,e4,dm,dl,fU,iL,pJ)if shield then cw=im(shield,e4,bN)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uj then uj.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bP.setDockingMode(ab)if shield then c.setTimer("shieldTick",0.0166667)end;if vI then vJ.ExtraOnStart()end;fU("start","SU")local function vK()if bH[1]==0 then ct.cmdThrottle(bH[2])else if ch>0 then cB=bH[2]ct.cmdThrottle(1)end end end;lr=string.find(c.getName(),"Emergency")or false;if lr then if cf>-1 and cL<1 and cf-3<_ then c.exit()else if J then vK()else if ch==0 then b1="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bH[3]+3>bM()then vK()end end)coroutine.resume(vH)end;function uW.onUpdate()if vG then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iI:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and pd~=vL then a.setScreen(pd)end;vL=pd;if lr and not J and ch>0 and cf==-1 then cv.landingGear()end;if lr and cf>-1 and cL<1 and cf-3<_ then c.exit()end;if vI then vJ.ExtraOnUpdate()end else local ib=coroutine.status(vH)if ib=="suspended"then local dM,ic=coroutine.resume(vH)if ic then a.print("ERROR STARTUP: "..ic)end elseif ib=="dead"then vG=true end end end;function uW.onFlush()if vG then ct.onFlush()if vI then vJ.ExtraOnFlush()end end end;function uW.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;w=d6;local vM=0;if lr then vM=bM()end;if iI:getAxisCommandType(0)==0 then bH={0,bR,vM}else bH={1,iI:getTargetSpeed(axisCommandId.longitudinal),vM}end;pJ()if nZ then nZ.activate()end;if z then ct.showWayPoint(kE,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vI then vJ.ExtraOnStop()end;fU("stop","SU")end;function uW.controlStart(us)if vG then cv.startControl(us)end end;function uW.controlStop(us)if vG then cv.stopControl(us)end end;function uW.controlLoop(us)if vG then cv.loopControl(us)end end;function uW.controlInput(rg)if vG then cv.inputTextControl(rg)end end;function uW.radarEnter(dV)if cu then cu.onEnter(dV)end end;function uW.radarLeave(dV)if cu then cu.onLeave(dV)end end;function uW.onTick(vN)if vN=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vN=="oneSecond"then if cr then cr.OneSecondTick()end elseif vN=="msgTick"then if cr then cr.MsgTick()end elseif vN=="animateTick"then if cr then cr.AnimateTick()end elseif vN=="hudTick"then if cr then cr.hudtick()end elseif vN=="apTick"then if ct then ct.APTick()end elseif vN=="shieldTick"then cw.shieldTick()elseif vN=="tagTick"then cv.tagTick()elseif vN=="contact"then cu.ContactTick()end end;if vI then for dL,dx in pairs(vI)do uW[dL]=dx end end;return uW end;function script.onStart()vJ.onStart()end;function script.onOnStop()vJ.onStop()end;function script.onTick(vN)vJ.onTick(vN)end;function script.onOnFlush()vJ.onFlush()end;function script.onOnUpdate()vJ.onUpdate()end;function script.onActionStart(us)vJ.controlStart(us)end;function script.onActionStop(us)vJ.controlStop(us)end;function script.onActionLoop(us)vJ.controlLoop(us)end;function script.onInputText(rg)vJ.controlInput(rg)end;function script.onEnter(dV)vJ.radarEnter(dV)end;function script.onLeave(dV)vJ.radarLeave(dV)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vJ=uT(d,core,unit,e,vBooster,hover,pI,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iE,uj)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
