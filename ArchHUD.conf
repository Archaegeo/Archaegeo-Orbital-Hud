name: ArchHud - Archaegeo v0.750 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.750;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=true;K=false;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},freeLookToggle={set=function(M)i=M end,get=function()return i end},BrakeToggleDefault={set=function(M)j=M end,get=function()return j end},RemoteFreeze={set=function(M)k=M end,get=function()return k end},brightHud={set=function(M)m=M end,get=function()return m end},RemoteHud={set=function(M)l=M end,get=function()return l end},VanillaRockets={set=function(M)n=M end,get=function()return n end},InvertMouse={set=function(M)o=M end,get=function()return o end},autoRollPreference={set=function(M)p=M end,get=function()return p end},ExternalAGG={set=function(M)q=M end,get=function()return q end},UseSatNav={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},FullRadar={set=function(M)J=M end,get=function()return J end},ECUHud={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.2;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)ab=M end,get=function()return ab end},AutopilotInterplanetaryThrottle={set=function(M)a1=M end,get=function()return a1 end},warmup={set=function(M)a2=M end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingSpace={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingRocket={set=function(M)a5=M end,get=function()return a5 end},ContainerOptimization={set=function(M)a6=M end,get=function()return a6 end},FuelTankOptimization={set=function(M)a7=M end,get=function()return a7 end},AutoShieldPercent={set=function(M)a8=M end,get=function()return a8 end},EmergencyWarp={set=function(M)a9=M end,get=function()return a9 end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=0.0;aV="none"aW="none"aX="none"aY={speedChangeLarge={set=function(M)aE=M end,get=function()return aE end},speedChangeSmall={set=function(M)aF=M end,get=function()return aF end},MouseXSensitivity={set=function(M)aG=M end,get=function()return aG end},MouseYSensitivity={set=function(M)aH=M end,get=function()return aH end},autoRollFactor={set=function(M)aI=M end,get=function()return aI end},rollSpeedFactor={set=function(M)aJ=M end,get=function()return aJ end},autoRollRollThreshold={set=function(M)aK=M end,get=function()return aK end},minRollVelocity={set=function(M)aL=M end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(M)aM=M end,get=function()return aM end},torqueFactor={set=function(M)aN=M end,get=function()return aN end},pitchSpeedFactor={set=function(M)aO=M end,get=function()return aO end},yawSpeedFactor={set=function(M)aP=M end,get=function()return aP end},brakeSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeFlatFactor={set=function(M)aR=M end,get=function()return aR end},DampingMultiplier={set=function(M)aS=M end,get=function()return aS end},hudTickRate={set=function(M)aT=M end,get=function()return aT end},ExtraEscapeThrust={set=function(M)aU=M end,get=function()return aU end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end}}aZ=j;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=1000;bb=false;bc=false;bd=false;be=false;bf=0;bg="Aligning"bh=0;bi=1;bj="None"bk=nil;bl=0;bm=nil;bn=0.0;bo=0;bp={}bq=false;br=0;bs=0;bt=nil;bu=0;bv=1000;bw=0;bx=false;by=0;bz=false;bA="All"bB=true;bC="Off"bD=0.000;bE={}bF={}bG={}bH=false;bI={VertTakeOff={set=function(M)b9=M end,get=function()return b9 end},VertTakeOffEngine={set=function(M)a_=M end,get=function()return a_ end},SpaceTarget={set=function(M)bx=M end,get=function()return bx end},BrakeToggleStatus={set=function(M)aZ=M end,get=function()return aZ end},BrakeIsOn={set=function(M)b0=M end,get=function()return b0 end},RetrogradeIsOn={set=function(M)b1=M end,get=function()return b1 end},ProgradeIsOn={set=function(M)b2=M end,get=function()return b2 end},Autopilot={set=function(M)b3=M end,get=function()return b3 end},TurnBurn={set=function(M)b4=M end,get=function()return b4 end},AltitudeHold={set=function(M)b5=M end,get=function()return b5 end},BrakeLanding={set=function(M)b6=M end,get=function()return b6 end},Reentry={set=function(M)b8=M end,get=function()return b8 end},AutoTakeoff={set=function(M)b7=M end,get=function()return b7 end},HoldAltitude={set=function(M)ba=M end,get=function()return ba end},AutopilotAccelerating={set=function(M)bb=M end,get=function()return bb end},AutopilotBraking={set=function(M)bd=M end,get=function()return bd end},AutopilotCruising={set=function(M)be=M end,get=function()return be end},AutopilotRealigned={set=function(M)bc=M end,get=function()return bc end},AutopilotEndSpeed={set=function(M)bf=M end,get=function()return bf end},AutopilotStatus={set=function(M)bg=M end,get=function()return bg end},AutopilotPlanetGravity={set=function(M)bh=M end,get=function()return bh end},PrevViewLock={set=function(M)bi=M end,get=function()return bi end},AutopilotTargetName={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetCoords={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetIndex={set=function(M)bl=M end,get=function()return bl end},TotalDistanceTravelled={set=function(M)bn=M end,get=function()return bn end},TotalFlightTime={set=function(M)bo=M end,get=function()return bo end},SavedLocations={set=function(M)bp=M end,get=function()return bp end},VectorToTarget={set=function(M)bq=M end,get=function()return bq end},LocationIndex={set=function(M)br=M end,get=function()return br end},LastMaxBrake={set=function(M)bs=M end,get=function()return bs end},LockPitch={set=function(M)bt=M end,get=function()return bt end},LastMaxBrakeInAtmo={set=function(M)bu=M end,get=function()return bu end},AntigravTargetAltitude={set=function(M)bv=M end,get=function()return bv end},LastStartTime={set=function(M)bw=M end,get=function()return bw end},iphCondition={set=function(M)bA=M end,get=function()return bA end},stablized={set=function(M)bB=M end,get=function()return bB end},UseExtra={set=function(M)bC=M end,get=function()return bC end},SelectedTab={set=function(M)bJ=M end,get=function()return bJ end},saveRoute={set=function(M)bE=M end,get=function()return bE end},apRoute={set=function(M)bF=M end,get=function()return bF end},ecuThrottle={set=function(M)bG=M end,get=function()return bG end},HoverMode={set=function(M)bH=M end,get=function()return bH end}}local function bK(b,c,bL,bM,bN)local a=DUSystem;local bO=DUConstruct;bP=bL()bQ=0;bR=0;bS=false;bT=0;bU=false;bV=false;bW=0;bX=0;bY=0;bZ=0;b_=false;c0=false;c1=false;c2="empty"c3=3;c4=false;c5=0;c6=0;c7=nil;c8=0;c9=0;ca=0;cb=false;cc=false;cd=false;ce=-1;cf=bN()>0;cg=bN()ch=b.getAltitude()ci=DUConstruct.getMass()cj=nil;ck=ac;cl=ad;cm={}cn={}co={}cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=nil;cy=false;cz=false;cA=p;cB=false;cC=W;cD=nil;cE=0;cF=false;cG=false;cH=false;cI=vec3(bO.getWorldOrientationForward())cJ=vec3(bO.getWorldOrientationRight())cK=vec3(bO.getVelocity())cL=vec3(bO.getWorldVelocity())cM=vec3(cL):len()cN=vec3(b.getWorldVertical())cO=-cN:dot(cL)cP=vec3(bO.getWorldPosition())cQ=false;cR=false;cS=true;cT=0;cU=0;cV={}cW=false;cX=50000;cY=nil;cZ=c.getClosestPlanetInfluence()>0 or ch>0 and ch<200000;c_=false;d0=nil;d1=false;d2=0;d3=nil;d4=nil;d5={}d6=90;d7=w;d8=nil;d9=nil;da={}db={}dc=false;dd=nil;de=0;df=false;dg=bO.getMaxSpeed()if shield then dh=bM(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function di(dj)a.print(bP..": "..dj)end;local function dk(d,b,c,a,dl,dm,dn,dp,dq)local function dr(ds)return type(ds)=='number'end;local function dt(ds)return type(dn(ds))=='number'end;local function du(dv)return type(dv)=='table'end;local function dw(a)return type(a)=='string'end;local function dx(dy)return du(dy)and dr(dy.x and dy.y and dy.z)end;local function dz(dA)return du(dA)and dr(dA.latitude and dA.longitude and dA.altitude and dA.id and dA.systemId)end;local dB=math.pi/180;local dC=180/math.pi;local dD=1e-10;local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF='::pos{'..dE..','..dE..','..dE..','..dE..','..dE..'}'local utils=utils;local vec3=vec3;local function dG(ds)local dH=string.gsub(string.reverse(dl('%.4f',ds)),'^0*%.?','')return dH==''and'0'or string.reverse(dH)end;local function dI(dJ)if dx(dJ)then return dl('{x=%.3f,y=%.3f,z=%.3f}',dJ.x,dJ.y,dJ.z)end;if du(dJ)and not getmetatable(dJ)then local dK={}local dL=next(dJ)if type(dL)=='nil'or dL==1 then dK=dJ else for dM,dy in pairs(dJ)do local dN=dI(dy)if type(dM)=='number'then table.insert(dK,dl('[%s]=%s',dM,dN))else table.insert(dK,dl('%s=%s',dM,dN))end end end;return dl('{%s}',table.concat(dK,','))end;if dw(dJ)then return dl("'%s'",dJ:gsub("'",[[\']]))end;return tostring(dJ)end;local dO={}dO.__index=dO;dO.__tostring=function(dJ,dP)local dQ={}for dM in pairs(dJ)do table.insert(dQ,dM)end;table.sort(dQ)local dK={}for dR,dM in ipairs(dQ)do local dN=dI(dJ[dM])if type(dM)=='number'then table.insert(dK,dl('[%s]=%s',dM,dN))else table.insert(dK,dl('%s=%s',dM,dN))end end;if dP then return dl('%s%s',dP,table.concat(dK,',\n'..dP))end;return dl('{%s}',table.concat(dK,','))end;dO.__eq=function(dS,dT)return dS.systemId==dT.systemId and dS.id==dT.id and dq(dS.radius,dT.radius)and dq(dS.center.x,dT.center.x)and dq(dS.center.y,dT.center.y)and dq(dS.center.z,dT.center.z)and dq(dS.GM,dT.GM)end;local function dU(dV,dW,dX,dY,dZ)assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(dX),'Argument 3 (radius) must be a number:'..type(dX))assert(du(dY),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dY))assert(dt(dZ),'Argument 5 (GM) must be a number:'..type(dZ))return setmetatable({systemId=dn(dV),id=dn(dW),radius=dn(dX),center=vec3(dY),GM=dn(dZ)},dO)end;local d_={}d_.__index=d_;d_.__tostring=function(di)return dl('::pos{%d,%d,%s,%s,%s}',di.systemId,di.id,dG(di.latitude*dC),dG(di.longitude*dC),dG(di.altitude))end;d_.__eq=function(dS,dT)return dS.id==dT.id and dS.systemId==dT.systemId and dq(dS.latitude,dT.latitude)and dq(dS.altitude,dT.altitude)and(dq(dS.longitude,dT.longitude)or dq(dS.latitude,math.pi/2)or dq(dS.latitude,-math.pi/2))end;local function e0(e1,dW,e2,e3,e4)local dV=e1;if dw(e1)and not e3 and not e4 and not dW and not e2 then dV,dW,e2,e3,e4=e5(e1,dF)assert(dV,'Argument 1 (position string) is malformed.')else assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(e2),'Argument 3 (latitude) must be in degrees:'..type(e2))assert(dt(e3),'Argument 4 (longitude) must be in degrees:'..type(e3))assert(dt(e4),'Argument 5 (altitude) must be in meters:'..type(e4))end;dV=dn(dV)dW=dn(dW)e2=dn(e2)e3=dn(e3)e4=dn(e4)if dW==0 then return setmetatable({latitude=e2,longitude=e3,altitude=e4,id=dW,systemId=dV},d_)end;return setmetatable({latitude=dB*dm(e2,-90,90),longitude=dB*(e3%360),altitude=e4,id=dW,systemId=dV},d_)end;local e6={}e6.__index=e6;e6.__tostring=function(dJ,dP)local e7=dP and dP..'  'local e8={}local dQ={}for dM in pairs(dJ)do table.insert(dQ,dM)end;table.sort(dQ)for dR,e9 in ipairs(dQ)do ea=dJ[e9]local eb=dO.__tostring(ea,e7)if dP then table.insert(e8,dl('[%s]={\n%s\n%s}',e9,eb,dP))else table.insert(e8,dl('  [%s]=%s',e9,eb))end end;if dP then return dl('\n%s%s%s',dP,table.concat(e8,',\n'..dP),dP)end;return dl('{\n%s\n}',table.concat(e8,',\n'))end;local function ec(ed)local e={}local pid;for dR,dy in pairs(ed)do local dW=dy.planetarySystemId;if type(dW)~='number'then error('Invalid planetary s ID: '..tostring(dW))elseif pid and dW~=pid then error('Mistringmatch planetary s IDs: '..dW..' and '..pid)end;local ee=dy.bodyId;if type(ee)~='number'then error('Invalid body ID: '..tostring(ee))elseif e[ee]then error('Duplicate body ID: '..tostring(ee))end;setmetatable(dy.center,getmetatable(vec3.unit_x))e[ee]=setmetatable(dy,dO)pid=dW end;return setmetatable(e,e6)end;ef={}local function eg(ed)return setmetatable({galaxyAtlas=ed or{}},ef)end;ef.__index=function(dv,M)if type(M)=='number'then local a=dv.galaxyAtlas[M]return ec(a)end;return rawget(ef,M)end;ef.__pairs=function(dJ)return function(dv,dM)local eh,ei=next(dv,dM)return eh,ei and ec(ei)end,dJ.galaxyAtlas,nil end;ef.__tostring=function(dJ)local ej={}for dR,ek in pairs(dJ or{})do local el=ek:getPlanetarySystemId()local em=e6.__tostring(ek,'    ')table.insert(ej,dl('  [%s]={%s\n  }',el,em))end;return dl('{\n%s\n}\n',table.concat(ej,',\n'))end;ef.BodyParameters=dU;ef.MapPosition=e0;ef.PlanetarySystem=ec;function ef.createBodyParameters(dV,dW,en,eo,ep,eq,er)assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(en),'Argument 3 (surfaceArea) must be a number:'..type(en))assert(du(eo),'Argument 4 (aPosition) must be an array or vec3:'..type(eo))assert(du(ep),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ep))assert(dt(eq),'Argument 6 (altitude) must be in meters:'..type(eq))assert(dt(er),'Argument 7 (gravityAtPosition) must be number:'..type(er))local dX=dp(en/4/math.pi)local ca=dX+eq;local es=vec3(eo)+ca*vec3(ep)local dZ=er*ca*ca;return dU(dV,dW,dX,es,dZ)end;ef.isMapPosition=dz;function ef:getPlanetarySystem(e1)if M==nil then M=0 end;if ei==nil then ei=0 end;local dV=e1;if dz(e1)then dV=e1.systemId end;if type(dV)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(ei)~=e6 then a=ec(a)end;return a end end end;function e6:sizeCalculator(et)return 1.05*et.radius end;function e6:castIntersections(eu,ev,ew,ex,ey,ez)local eA={}if ey then for dR,et in pairs(ey)do table.insert(eA,et)end else eA=d5 end;if not ez then table.sort(eA,function(eB,eC)local eD=eB.center;local eE=eC.center;return(eD.x-eu.x)^2+(eD.y-eu.y)^2+(eD.z-eu.z)^2<(eE.x-eu.x)^2+(eE.y-eu.y)^2+(eE.z-eu.z)^2 end)end;local eF=ev:normalize()for dR,et in ipairs(eA)do local eG=et.center-eu;local dX;if ew then dX=ew(et)else dX=self:sizeCalculator(et)end;local eH=eG:dot(eF)local eI=eH^2-(eG:len2()-dX^2)if eI>=0 then local eJ=dp(eI)local eK=eH+eJ;local eL=eH-eJ;if eL>0 then return et,eK,eL elseif eK>0 then return et,eK,nil end end end;return nil,nil,nil end;function e6:closestBody(eM)assert(type(eM)=='table','Invalid coordinates.')local eN,et;local eO=vec3(eM)for dR,eP in pairs(self)do local eQ=(eP.center-eO):len2()if(not et or eQ<eN)and eP.name~="Space"then et=eP;eN=eQ end end;return et end;function e6:convertToBodyIdAndWorldCoordinates(e1)local eR=e1;if dw(e1)then eR=e0(e1)end;if eR.id==0 then return 0,vec3(eR.latitude,eR.longitude,eR.altitude)end;local eP=self:getBodyParameters(eR)if eP then return eR.id,eP:convertToWorldCoordinates(eR)end end;function e6:getBodyParameters(e1)local dW=e1;if dz(e1)then dW=e1.id end;assert(dt(dW),'Argument 1 (id) must be a number:'..type(dW))return self[dW]end;function e6:getPlanetarySystemId()local dR,dy=next(self)return dy and dy.systemId end;function dO:convertToMapPosition(dY)assert(du(dY),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dY))local eS=vec3(dY)if self.id==0 then return setmetatable({latitude=eS.x,longitude=eS.y,altitude=eS.z,id=0,systemId=self.systemId},d_)end;local eT=eS-self.center;local ca=eT:len()local e4=ca-self.radius;local e2=0;local e3=0;if not dq(ca,0)then local eU=eV(eT.y,eT.x)e3=eU>=0 and eU or 2*math.pi+eU;e2=math.pi/2-math.acos(eT.z/ca)end;return setmetatable({latitude=e2,longitude=e3,altitude=e4,id=self.id,systemId=self.systemId},d_)end;function dO:convertToWorldCoordinates(e1)local eR=dw(e1)and e0(e1)or e1;if eR.id==0 then return vec3(eR.latitude,eR.longitude,eR.altitude)end;assert(dz(eR),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eR.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eR.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eW=math.cos(eR.latitude)return self.center+(self.radius+eR.altitude)*vec3(eW*math.cos(eR.longitude),eW*math.sin(eR.longitude),math.sin(eR.latitude))end;function dO:getAltitude(dY)return(vec3(dY)-self.center):len()-self.radius end;function dO:getDistance(dY)return(vec3(dY)-self.center):len()end;function dO:getGravity(dY)local eX=self.center-vec3(dY)local eY=eX:len2()return self.GM/eY*eX/dp(eY)end;return setmetatable(ef,{__call=function(dR,...)return eg(...)end})end;local function eZ(d,b,c,a,dp,e_)local cq={}local bO=100000000/3600;local f0=bO*bO;local f1=100;function cq.computeAccelerationTime(f2,f3,f4)local f5=bO*math.asin(f2/bO)return(bO*math.asin(f4/bO)-f5)/f3 end;function cq.computeDistanceAndTime(f2,f4,f6,f7,f8,f9)f8=f8 or 0;f9=f9 or 0;local fa=f2<=f4;local fb=f7*(fa and 1 or-1)/f6;local fc=-f9/f6;local fd=fb+fc;if fa and fd<=0 or not fa and fd>=0 then return-1,-1 end;local fe,ff=0,0;if fb~=0 and f8>0 then local f5=math.asin(f2/bO)local fg=math.pi*(fb/2+fc)local fh=fb*f8;local fi=bO*math.pi;local dy=function(dv)local fj=(fg*dv-fh*math.sin(math.pi*dv/2/f8)+fi*f5)/fi;local fk=math.tan(fj)return bO*fk/dp(fk*fk+1)end;local fl=fa and function(a)return a>=f4 end or function(a)return a<=f4 end;ff=2*f8;if fl(dy(ff))then local fm=0;while e_(ff-fm)>0.5 do local dv=(ff+fm)/2;if fl(dy(dv))then ff=dv else fm=dv end end end;local fn=f2;local fo=ff/f1;for fp=1,f1 do local fq=dy(fp*fo)fe=fe+(fq+fn)*fo/2;fn=fq end;if ff<2*f8 then return fe,ff end;f2=fn end;local f5=bO*math.asin(f2/bO)local bP=(bO*math.asin(f4/bO)-f5)/fd;local fr=f0*math.cos(f5/bO)/fd;local ca=fr-f0*math.cos((fd*bP+f5)/bO)/fd;return ca+fe,bP+ff end;function cq.computeTravelTime(f2,f3,ca)if ca==0 then return 0 end;if f3>0 then local f5=bO*math.asin(f2/bO)local fr=f0*math.cos(f5/bO)/f3;return(bO*math.acos(f3*(fr-ca)/f0)-f5)/f3 end;if f2==0 then return-1 end;assert(f2>0,'Acceleration and initial speed are both zero.')return ca/f2 end;return cq end;local function fs(d,b,c,a,dl,dm,dn,dp,dq)local vec3=vec3;local dk=dk(d,b,c,a,dl,dm,dn,dp,dq)local function dw(a)return type(a)=='string'end;local function du(dv)return type(dv)=='table'end;ft={}ft.__index=ft;function ft:escapeAndOrbitalSpeed(e4)assert(self.body)local ca=e4+self.body.radius;if not dq(ca,0)then local fu=dp(self.body.GM/ca)return dp(2)*fu,fu end;return nil,nil end;function ft:orbitalParameters(e1,fv)assert(self.body)assert(du(e1)or dw(e1))assert(du(fv))local fw=(dw(e1)or dk.isMapPosition(e1))and self.body:convertToWorldCoordinates(e1)or vec3(e1)local dy=vec3(fv)local fx=fw-self.body.center;local fy=dy:len2()local fz=fx:len()local fA=self.body.GM;local fB=((fy-fA/fz)*fx-fx:dot(dy)*dy)/fA;local eD=fA/(2*fA/fz-fy)local fC=fB:len()local eF=fB:normalize()local fD=eD*(1-fC)local fE=eD*(1+fC)local fF=fD*eF+self.body.center;local fG=fC<=1 and-fE*eF+self.body.center or nil;local fH=dp(eD*fA*(1-fC*fC))local fI=fG and 2*math.pi*dp(eD^3/fA)local fJ=math.acos(fB:dot(fx)/(fC*fz))if fx:dot(dy)<0 then fJ=-(fJ-2*math.pi)end;local fK=math.acos((math.cos(fJ)+fC)/(1+fC*math.cos(fJ)))local fL=fK;if fL<0 then fL=fL+2*math.pi end;local fM=fL-fC*math.sin(fL)local fN=0;local fO=0;local fP=0;if fI~=nil then fN=fM/(2*math.pi/fI)fO=fI-fN;fP=fO+fI/2;if fJ-math.pi>0 then fO=fN;fP=fO+fI/2 end;if fP>fI then fP=fP-fI end end;return{periapsis={position=fF,speed=fH/fD,circularOrbitSpeed=dp(fA/fD),altitude=fD-self.body.radius},apoapsis=fG and{position=fG,speed=fH/fE,circularOrbitSpeed=dp(fA/fE),altitude=fE-self.body.radius},currentVelocity=dy,currentPosition=fw,eccentricity=fC,period=fI,eccentricAnomaly=fK,meanAnomaly=fM,timeToPeriapsis=fO,timeToApoapsis=fP,trueAnomaly=fJ}end;local function fQ(fR)local eP=dk.BodyParameters(fR.systemId,fR.id,fR.radius,fR.center,fR.GM)return setmetatable({body=eP},ft)end;return setmetatable(ft,{__call=function(dR,...)return fQ(...)end})end;local function fS(d,b,c,a,dbHud_1,e,fT,fU,bM,dn,dp,fV,fW)local function fX(fY)local di=fZ:closestBody(fY)if(fY-di.center):len()>di.radius+di.noAtmosphericDensityAltitude then di=e[0][0]end;return di end;local function f_()local function g0(g1,g2)return g1.name<g2.name end;cV={}for dM,dy in pairs(e[0])do cV[#cV+1]={name=dy.name,index=dM}end;table.sort(cV,g0)end;local function g3(g4,g5)if not g5 then g5=g6.name end;for dM,dy in pairs(g4)do if dy.name and dy.name==g5 then return dM end end;return-1 end;local function g7()d2=bl;if bl==0 then bj="None"c7=nil;g6=nil;return true end;local g8=cV[bl].index;local g9=e[0][g8]if g9.center then bj=g9.name;c7=cp[0][g8]if g6~=nil then if cg==0 then if fT(ga,gb)~=1 then fU(ga,gb)end;if fT(gc,gd)~=1 then fU(gc,gd)end;if fT(ge,gf)~=1 then fU(ge,gf)end;if fT(gg,gh)~=1 then fU(gg,gh)end;if fT(gi,gj)~=1 then fU(gi,gj)end end;if fT(gk,gl)~=1 then fU(gk,gl)end;if fT(gm,gn)~=1 then fU(gm,gn)end;if fT(go,gp)~=1 then fU(go,gp)end end;g6=nil else g6=g9;for dR,dy in pairs(cp[0])do if dy.name==g6.planetname then c7=dy;bj=g6.name;break end end;if fT(gk,gl)~=1 then fU(gk,gl)end;if fT(gm,gn)~=1 then fU(gm,gn)end end;if g6==nil then bk=vec3(c7.center)else bk=g6.position end;if c7.planetname~="Space"then if c7.hasAtmosphere then gq=bM(c7.radius*(U-1)+c7.noAtmosphericDensityAltitude)else gq=bM(c7.radius*(U-1)+c7.surfaceMaxAltitude)end else gq=T end;if g6~=nil and g6.planetname=="Space"then bf=0 else dR,bf=cr(c7):escapeAndOrbitalSpeed(gq)end;bh=0;bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"return true end;local function gr(gs)if not b3 and not bq and not cc and not bz and not b8 and not cd then if gs==nil then bl=bl+1;if bl>#cV then bl=0 end else bl=bl-1;if bl<0 then bl=#cV end end;if bl==0 then g7()else local g8=cV[bl].index;local g9=e[0][g8]if g9 and(g9~=nil and g9.name=="Space"or bA=="Custom Only"and g9.center or bA=="No Moons"and string.find(g9.name,"Moon")~=nil)then if gs==nil then gr()else gr(1)end else g7()end end else c2="Disengage autopilot before changing Interplanetary Helper"fV("iph","AP")end end;local function gt()local function gu(gv)local gw;if gv then gw=da else gw=bp end;local gx=-1;gx=g3(e[0])if gx>-1 then table.remove(e[0],gx)end;gx=-1;gx=g3(gw)if gx~=-1 then c2=g6.name.." saved location cleared"table.remove(gw,gx)end;gr()f_()return gw end;if string.sub(bj,1,1)=="*"then da=gu(true)else bp=gu(false)end end;local function gy(gz,fY,gA,gB)local function gC(gv)if gv then gw=da else gw=bp end;if dbHud_1 or gA or gv then local di=fX(fY)local gD={position=fY,name=gz,planetname=di.name,gravity=b.getGravityIntensity(),safe=gB}if not gA then gw[#gw+1]=gD else for dM,dy in pairs(e[0])do if dy.name and gz==dy.name then table.remove(e[0],dM)end end end;table.insert(e[0],gD)f_()g7()c2="Location saved as "..gz.."("..di.name..")"return gw else c2="Databank must be installed to save permanent locations"end end;if string.sub(gz,1,1)=="*"then da=gC(true)else bp=gC(false)end end;local gE={}function gE.UpdateAtlasLocationsList()f_()end;function gE.UpdateAutopilotTarget()g7()end;function gE.adjustAutopilotTargetIndex(gs)gr(gs)end;function gE.findAtlasIndex(g4,g5)return g3(g4,g5)end;function gE.UpdatePosition(gF,gG,gH)local function gI(gv)local gw;if gv then gw=da else gw=bp end;local gx=g3(gw)if gx~=-1 then if gF~=nil then if gv then gF="*"..gF end;gw[gx].name=gF;bl=bl-1;gr()elseif gH~=nil then if gH then local gJ=ch;if gJ<1000 then gJ=1000 end;gw[gx].agg=fW(gJ,0)c2=gw[gx].name.." AGG Altitude:"..gw[gx].agg.." saved ("..gw[gx].planetname..")"return elseif gH==false then gw[gx].agg=nil;c2=gw[gx].name.." AGG Altitude cleared ("..gw[gx].planetname..")"return end else local gK=gw[gx]if gG then gK.heading=cJ:cross(cN)*5000;c2=gw[gx].name.." heading saved ("..gw[gx].planetname..")"return elseif gG==false then gK.heading=nil;c2=gw[gx].name.." heading cleared ("..gw[gx].planetname..")"return end;gK.gravity=b.getGravityIntensity()gK.position=cP;gK.safe=true end;c2=gw[gx].name.." position updated ("..gw[gx].planetname..")"else c2="Name Not Found"end end;if string.sub(bj,1,1)=="*"then gI(true)else gI(false)end end;function gE.AddNewLocation(gz,fY,gA,gB)gy(gz,fY,gA,gB)end;function gE.ClearCurrentPosition()gt()end;for dM,dy in pairs(db)do table.insert(e[0],dy)end;if gL then for dM,dy in pairs(gL)do gE[dM]=dy end end;f_()if bl>#cV then bl=0 end;gE.UpdateAutopilotTarget()return gE end;local function gM(b,a,c,radar_1,radar_2,warpdrive,e_,gN,dp,gO,dn,gP,fV)local gQ={}local gR={}local gS={XS=13,S=27,M=55,L=110,XL=221}local gT={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gU={}local gV=0;local gW;local gX;local gY;local gZ;local g_={gZ}local h0="Atmo"local h1;local h2;local h3=0;local h4={}local h5;local h6=0;local vec3=vec3;local h7=table.insert;local h8=-4;local h9={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local ha,hb;local hc,hd;local function he()if hf~=nil and h3==0 then gN(hf)a.destroyWidget(ha)a.destroyData(hc)ha,hc,hf=nil,nil,nil;if h2~=nil then gN(h2)a.destroyWidget(hb)a.destroyData(hd)h2,hb,hd=nil,nil,nil end else if h3==1 then gN(hf)hf=nil;h2=a.createWidgetPanel("PeriWinkle")hb=a.createWidget(h2,'periscope')hd=gZ.getWidgetDataId()a.addDataToWidget(hd,hb)end;if hf==nil and gV>0 then hf=a.createWidgetPanel(h0)ha=a.createWidget(hf,'radar')hc=gZ.getWidgetDataId()a.addDataToWidget(hc,ha)end;h3=0 end end;local function hg()local function hh(hi,hj,hk,hl,hm,hn,ho,hp)hj,hl,hn,hp=vec3(hj),vec3(hl),vec3(hn),vec3(hp)local hq,hr,hs=hi*hi,hk*hk,hm*hm;local fy=hl-hj;local ht=fy:normalize()local hu=fy:len()local hv=hn-hj;local hw=(hv-hv:project_on(ht)):normalize()local hx,hy=hv:dot(ht),hv:dot(hw)local hz=hx*hx+hy*hy;local hA=ht:cross(hw)local hB=(hq-hr+hu*hu)/(2*hu)local hC=(hq-hs+hz-2*hx*hB)/(2*hy)local dA=hq-hB^2-hC^2;local hD=dp(dA)local hE=hj+ht*hB+hw*hC+hA*hD;local hF=hj+ht*hB+hw*hC-hA*hD;if e_((hp-hE):len()-ho)<e_((hp-hF):len()-ho)then return hE else return hF end end;local function hG(hH,fz,hI)local hJ=hH.pts;local gx=#hJ;local hK=hH.ref;if gx>3 then local hL,hM,hN,hO=hJ[gx],hJ[gx-1],hJ[gx-2],hJ[gx-3]hH.ref=hI;local fw=hh(hL[1],hL[2],hM[1],hM[2],hN[1],hN[2],hO[1],hO[2])local hB,hC,hD=fw.x,fw.y,fw.z;if hB==hB and hC==hC and hD==hD then hB=hB+hK[1]hC=hC+hK[2]hD=hD+hK[3]local hP=vec3(hB,hC,hD)hH.center=hP;if hH.lastPos then if(hH.lastPos-hP):len()<2 then local hQ=(hP-vec3(hI)):len()if e_(hQ-fz)<10 then hH.skipCalc=true end end end;hH.lastPos=hP end;hH.pts={}else local hR={hI[1]-hK[1],hI[2]-hK[2],hI[3]-hK[3]}hJ[gx+1]={fz,hR}end end;if radar_1 or radar_2 then cv.assignRadar()end;if gZ then gV=#gZ.getConstructIds()if gV>0 then local hS=h5:gmatch('{"constructId[^}]*}[^}]*}')local hT=gZ.hasMatchingTransponder;local hU=gZ.getConstructKind;local hV=gZ.isConstructAbandoned;local hW=gZ.getConstructName;local hI={cP["x"],cP["y"],cP["z"]}local hX,hY=0,0;local hZ=cM*10;local cZ=cZ;gY,gX=0,0;gR={}for dy in hS do local dW,ca,h_=dy:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local i0=gS[h_]ca=dn(ca)if hT(dW)==1 then h7(gR,dW)end;if not cW and warpdrive and ca<a9 and warpdrive.getStatus()==15 then c2="INITIATING WARP"c3=7;warpdrive.initiate()end;if E then local i1=hU(dW)local i2=F and hV(dW)==1;if i2 or ca<hZ and(i0>27 or i1==4 or i1==6)then gY=gY+1;local gz=hW(dW)local hH=h4[dW]if hH==nil then i0=i0+gP;h4[dW]={pts={},ref=hI,name=gz,i=0,radius=i0,skipCalc=false}hH=h4[dW]end;if not hH.skipCalc then hG(hH,ca,hI)if i2 and not hH.abandoned and hH.center then local bP=a.getArkTime()if h6+5<bP then h6=bP;fV("abRdr","RD")end;a.print("Abandoned Construct: "..gz.." ("..h_.." "..gT[i1]..") at estimated ::pos{0,0,"..hH.center.x..","..hH.center.y..","..hH.center.z.."}")c2="Abandoned Radar Contact ("..h_.." "..gT[i1]..") detected"hH.abandoned=true end;hY=hY+1 else h7(gU,hH)end end;hX=hX+1;if cZ and hX>700 or hY>70 or(not cZ and hX>300 or hY>30)then coroutine.yield()hX,hY=0,0 end end end;gX=#gU;if gX>0 and(cM>20 or b6)then local et,i3,i4,i5;local i6=0;local i7=cp:getPlanetarySystem(0)i5=cL:normalize()while i6<gX do coroutine.yield()local i8={table.unpack(gU,i6,math.min(i6+75,gX))}et,i3,i4=i7:castIntersections(cP,i5,nil,nil,i8,true)if et and i4 then d0={et,i3,i4}break end;i6=i6+75 end;if not et then d0=nil end else d0=nil end;gU={}gW=h5:find('identifiedConstructs":%[%]')end end end;local function i9()if gZ then h0="Atmo"if h5:find('worksInAtmosphere":false')then h0="Space"end end end;function gQ.pickType()i9()end;function gQ.assignRadar()if radar_2 and h8~=1 then if h8==-1 then if gZ==radar_2 then gZ=radar_1 else gZ=radar_2 end end;g_={gZ}h5=gZ.getWidgetData()i9()else h5=gZ.getWidgetData()end;h8=gZ.getOperationalState()end;function gQ.UpdateRadar()local ia=coroutine.status(h1)if ia=="suspended"then local dN,ib=coroutine.resume(h1)if ib then a.print("ERROR UPDATE RADAR: "..ib)end elseif ia=="dead"then h1=coroutine.create(hg)local dN,ib=coroutine.resume(h1)end end;function gQ.GetRadarHud(ic,id,ax,ay)local ie,dj;local dE=gX or 0;if gV>0 then if E then dj=dE.."/"..gY.." Plotted : "..gV-gY.." Ignored"else dj="Radar Contacts: "..gV end;ie=gO(ax,ay,dj,"pbright txtbig txtmid")if#gR>0 then ie=ie..gO(ic,id,"Friendlies In Range","pbright txtbig txtmid")for dM,dy in pairs(gR)do id=id+20;ie=ie..gO(ic,id,gZ.getConstructName(dy),"pdim txtmid")end end;if gW==nil and h2==nil then h3=1;cv.ToggleRadarPanel()end;if gW~=nil and h2~=nil then cv.ToggleRadarPanel()end;if hf==nil then cv.ToggleRadarPanel()end else if h8~=1 then ie=gO(ax,ay,h0 .." Radar: "..h9[h8],"pbright txtbig txtmid")else ie=gO(ax,ay,"Radar: No "..h0 .." Contacts","pbright txtbig txtmid")end;if hf~=nil then h3=0;cv.ToggleRadarPanel()end end;return ie end;function gQ.GetClosestName(gz)if gZ then local dW,dR=gZ.getWidgetData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dW~=nil and dW~=""then gz=gz.." "..gZ.getConstructName(dW)end end;return gz end;function gQ.ToggleRadarPanel()he()end;function gQ.ContactTick()if not ig then ig=0 end;if bP>ig+10 then c2="Radar Contact"fV("rdrCon","RC")ig=bP end;c.stopTimer("contact")end;function gQ.onEnter(dW)if gZ and not cf and not cW then c.setTimer("contact",0.1)end end;function gQ.onLeave(dW)if gZ and E then if#h4>650 then dW=tostring(dW)h4[dW]=nil end end end;local function ih()gZ=nil;if radar_2 and radar_2.getOperationalState()==1 then gZ=radar_2 else gZ=radar_1 end;h8=gZ.getOperationalState()g_={gZ}h5=gZ.getWidgetData()i9()h1=coroutine.create(hg)if ii then for dM,dy in pairs(ii)do gQ[dM]=dy end end end;ih()return gQ end;local function ij(shield,e5,bM)local ik={}local il=shield.getResistancesCooldown()local function im()local io=shield.isActive()if G then if not cW and io==0 and shield.isVenting()~=1 then shield.toggle()elseif cW and io==1 then shield.toggle()end end end;local function ip()local iq=shield.getStressRatioRaw()local ir=0.5999;if iq[1]==0.0 and iq[2]==0.0 and iq[3]==0.0 and iq[4]==0.0 then return end;local is=shield.setResistances(ir*iq[1],ir*iq[2],ir*iq[3],ir*iq[4])if is==1 then c2="Shield Resistances updated"else c2="Value Exceeded. Failed to update Shield Resistances"end end;function ik.shieldTick()dh=bM(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())im()il=shield.getResistancesCooldown()if il==0 and dh<a8 then ip()end end;function ik.setResist(it)if not shield then c2="No shield found"return elseif it==nil or il>0 then c2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF=dE..', '..dE..', '..dE..', '..dE;local iu,iv,iw,ix=e5(it,dF)if ix==nil or iu+iv+iw+ix>0.6 then c2="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(iu,iv,iw,ix)==1 then c2="Shield Resistances set"else c2="Resistance setting failed."end end;function ik.ventShield()local iy=shield.getVentingCooldown()if iy>0 then c2="Cannot vent again for "..iy.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c2="Shields already at max hitpoints"end end;if iz then for dM,dy in pairs(iz)do ik[dM]=dy end end;return ik end;local function iA(d,b,c,a,e,antigrav,hover,shield,warpdrive,iB,e_,bM,dl,iC,bN,iD,iE,eV,bL,dm,iF,fU,fT,gN,iG,dp,fW,gO,fV,iH,iI,iJ,iK,iL,iM)local bO=DUConstruct;local iN=9.80665;local iO={}local iP={}local iQ={}local iR={}local iS=nil;local iT=nil;local iU=nil;local iV=false;local iW="none"local iX=""local iY=55;local iZ=0;local i_=0;local j0=nil;local j1=af;local j2=ag;local j3=ah;local j4=[[rgb(]]..bM(j1+0.5)..","..bM(j2+0.5)..","..bM(j3+0.5)..[[)]]local j5=[[rgb(]]..bM(j1*0.9+0.5)..","..bM(j2*0.9+0.5)..","..bM(j3*0.9+0.5)..[[)]]local j6=0;local j7=0;local j8=""local j9=bL()local ja=false;local jb=false;local function jc(dy)if ck==1920 then return dy else return fW(ck*dy/1920,0)end end;local function jd(dy)if cl==1080 then return dy else return fW(cl*dy/1080,0)end end;local function je()return iG()==0 and g~="keyboard"and iE()==0 end;local function jf()local jg="TRAVEL"if not cS then jg="CRUISE"end;if b3 then jg="AUTOPILOT"end;return jg end;local ie=""local jh=""local ji=""local jj=1;local jk=2;local jl=3;local jm=4;local jn=5;local jo=6;local jp=7;local jq=""local jr=0;local js=120.0*aT;local jt={}local ju={}local jv={}local jw={}local jx={}local jy={}local jz={}jz["atmofueltank"],jz["spacefueltank"],jz["rocketfueltank"]=0,0,0;local jA=0;local function jB(hB,jC,jD,jE,jF,jG)local jH=jA;local jI=jA+5;if not B then jI=jI+5 end;if iE()==1 and not l then jH=jH-50;jI=jI-50 end;if jD=="ATMO"then jq="atmofueltank"elseif jD=="SPACE"then jq="spacefueltank"else jq="rocketfueltank"end;jr=_G[jq.."_size"]if#jE>0 then for M=1,#jE do local gz=jE[M][jk]local jJ=jE[M][jp]for jK=1,jr do if jE[M][jk]==iC(c[jq.."_"..jK].getWidgetData()).name then jJ=jK;break end end;local jL=bL()if jF[M]==nil or jG[M]==nil or jL-jE[M][jo]>js then local jM;local jN=0;jN=iD(jE[M][jj])-jE[M][jm]jM=jE[M][jn]if jM>jN then jz[jq]=jz[jq]+jM-jN end;if jJ~=0 then local jO=iC(c[jq.."_"..jJ].getWidgetData())jG[M]=jO.percentage;jF[M]=jO.timeLeft;if jF[M]=="n/a"then jF[M]=0 end else jG[M]=bM(0.5+jN*100/jE[M][jl])if jM<=jN then jF[M]=0 else jF[M]=bM(0.5+jN/((jM-jN)/(jL-jE[M][jo])))end end;jE[M][jo]=jL;jE[M][jn]=jN end;if gz==jC then gz=dl("%s %d",jD,M)end;if jJ==0 then gz=gz.." *"end;local jP;if jF[M]==0 then jP=""else jP=iK(jF[M])end;if jG[M]~=nil then local jQ=bM(jG[M]*2.55)local jR=dl("rgb(%d,%d,%d)",255-jQ,jQ,0)local jS=""if jP~=""and jF[M]<120 or jG[M]<5 then jS="red "end;local jT=dl("rgb(%d,%d,%d)",dm(bM((255-jQ)/2.55),50,100),dm(bM(jQ/2.55),0,50),50)local jU="rgb(196,0,255)"if jD=="ATMO"then jU="rgb(0,188,255)"elseif jD=="SPACE"then jU="rgb(239,255,0)"end;local jV=false;if jW~=jU then jV=true end;jW=jU;if B then if jV then jH=jH-5;jI=jI-5 end;jh=jh..dl([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jT,jU,hB,jI,jR,bM(jG[M]*1.7+0.5)-2,hB+1,jI+1,hB+5,jI+14,gz,jG[M],jP)jH=jH-22;jI=jI-22 else jh=jh..gO(hB,jH,gz,jS.."pdim txtfuel")jh=jh..gO(hB,jI,dl("%d%% %s",jG[M],jP),"pdim txtfuel","fill:"..jR)jH=jH+30;jI=jI+30 end end end end;jA=jH end;local function jX(jY,e4)if ap==0 and aq==0 then return end;if e4<200000 and not cf or e4 and cf then local jZ=0;if e_(cO)>1 then jZ=45*math.log(e_(cO),10)if cO<0 then jZ=-jZ end end;jY[#jY+1]=dl([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bM(cO),bM(jZ))end;return jY end;local function j_(k0)local gs=-cN;k0=k0-k0:project_on(gs)local k1=vec3(0,0,1)k1=k1-k1:project_on(gs)local k2=k1:cross(gs)local jZ=k1:angle_between(k0)*constants.rad2deg;if k0:dot(k2)<0 then jZ=360-jZ end;return jZ end;local function k3(jY,al,am,k4,k5,cZ)if ae==0 then return end;local k6=ae;local k7=20;local k8=bM(k4)if cZ then for M=-45,45,5 do local k9=M;jY[#jY+1]=dl([[<g transform="rotate(%f,%d,%d)">]],k9,al,am)ka=5;if M%15==0 then ka=15 elseif M%10==0 then ka=10 end;jY[#jY+1]=dl([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+k6+k7-ka,al,am+k6+k7)end;jY[#jY+1]=gO(al,am+k6+k7-35,k5,"pdim txt txtmid")jY[#jY+1]=gO(al,am+k6+k7-25,k8 .." deg","pdim txt txtmid")jY[#jY+1]=dl([[<g transform="rotate(%f,%d,%d)">]],-k4,al,am)jY[#jY+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+k6+k7-20,al+5,am+k6+k7-20,al,am+k6+k7-15)jY[#jY+1]="</g>"end;jY[#jY+1]=[[<g style="clip-path: url(#headingClip);">]]local kb=k8;if cZ then kb=j_(cI)end;local kc=20;local kd=bM(kb)local ke=0;local kf=am+k6+k7+20;local kg=al;if k5~="YAW"then kf=jd(130)kg=jc(960)end;local kh=[[<path class="txttick line" d="]]local ki=bM(kd-(kc+10)-kd%5+0.5)for M=ki+70,ki,-5 do local hB=kg-(-M*5+kb*5)if M%10==0 then ke=10;local dE=M;if dE==360 then dE=0 elseif dE>360 then dE=dE-360 elseif dE<0 then dE=dE+360 end;jY[#jY+1]=gO(hB,kf+15,dE,"txtmid bright")elseif M%5==0 then ke=5 end;if ke==10 then kh=dl([[%s M %f %f v %d]],kh,hB,kf-5,ke)else kh=dl([[%s M %f %f v %d]],kh,hB,kf-2.5,ke)end end;jY[#jY+1]=kh..[["/>]]jY[#jY+1]=dl([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kg-5,kf-20,kg+5,kf-20,kg,kf-10)if cZ then k5="HDG"end;jY[#jY+1]=gO(jc(960),jd(100),kd.."°","dim txt txtmid size14","")jY[#jY+1]=gO(jc(960),jd(85),k5,"dim txt txtmid size20","")jY[#jY+1]=[[</g>]]end;local function kj(jY,kk,k4,al,am,cZ,kl,fq)if ae==0 then return end;local k6=ae;local km=bM(k6*3/5)if k6>0 then local kn=bM(kk)local ka=0;local kh=dl([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k4,al,am)if not cf then kh=dl([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;jY[#jY+1]=dl([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k6-1,al,am)jY[#jY+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bM(kn-30-kn%5+0.5),bM(kn+30+kn%5+0.5),5 do if M%10==0 then ka=30 elseif M%5==0 then ka=20 end;local hC=am+-M*5+kk*5;if ka==30 then kh=dl([[%s M %d %f h %d]],kh,al-km-ka,hC,ka)if cf then jY[#jY+1]=dl([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k4,al,am,al-km+10,hC+4,M)jY[#jY+1]=dl([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k4,al,am,al+km-10,hC+4,M)if M==0 or M==180 or M==-180 then jY[#jY+1]=dl([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k4,al,am,al-km+20,hC,km*2-40)end else jY[#jY+1]=gO(al-km+10,hC,M,"pdim txt txtmid")jY[#jY+1]=gO(al+km-10,hC,M,"pdim txt txtmid")end;kh=dl([[%s M %d %f h %d]],kh,al+km,hC,ka)else kh=dl([[%s M %d %f h %d]],kh,al-km-ka,hC,ka)kh=dl([[%s M %d %f h %d]],kh,al+km,hC,ka)end end;jY[#jY+1]=kh..[["/>]]local ko="PITCH"if not cZ then ko="REL PITCH"end;if kk>90 and not cf then kk=90-(kk-90)elseif kk<-90 and not cf then kk=-90-(kk+90)end;if k6>200 then if cf then if fq>iY then jY[#jY+1]=gO(al,am-15,"Yaw","pdim txt txtmid")jY[#jY+1]=gO(al,am+20,kl,"pdim txt txtmid")end;jY[#jY+1]=dl([[<g transform="rotate(%f,%d,%d)">]],-k4,al,am)else jY[#jY+1]=dl([[<g transform="rotate(0,%d,%d)">]],al,am)end;jY[#jY+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-km+25,am-5,al-km+20,am,al-km+25,am+5,al-km+50,am+4,kn)jY[#jY+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+km-25,am-5,al+km-20,am,al+km-25,am+5,al+km-30,am+4,kn)jY[#jY+1]="</g>"end;local kp=bM(k6/3)jY[#jY+1]=dl([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-kp,am,k6-kp)if not cf and cZ then jY[#jY+1]=dl([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k4,al,am,al-km+10,am,km*2-20)end;jY[#jY+1]="</g>"if k6<200 then if cf and fq>iY then jY[#jY+1]=gO(al,am-k6,ko,"pdim txt txtmid")jY[#jY+1]=gO(al,am-k6+10,kn,"pdim txt txtmid")jY[#jY+1]=gO(al,am-15,"Yaw","pdim txt txtmid")jY[#jY+1]=gO(al,am+20,kl,"pdim txt txtmid")else jY[#jY+1]=gO(al,am-k6,ko,"pdim txt txtmid")jY[#jY+1]=gO(al,am-k6+15,kn,"pdim txt txtmid")end end end end;local function kq(jY,e4,cZ)local kr=ar;local ks=as;if kr==0 and ks==0 then return end;local kt=78;local ku=19;local kv=ce;if ce~=-1 then jY[#jY+1]=gO(kr+kt,ks+ku+20,dl("AGL: %.1fm",ce),"pdim altsm txtend")end;if cZ and(e4<200000 and not cf or e4 and cf)then table.insert(jY,dl([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kr-1,ks-4,kt+2,ku+6,kr+1,ks-1,kt-4,ku))local gx=0;local kw=1;local kx=0;local ky=e4<0;local kz=e4<kA.surfaceMaxAltitude;local kB=9;if ky then kB=0 end;local e4=e_(e4)while gx<6 do local kC=11;local kD=16;local kE=9;local kF=14;local jS="altsm"if gx>2 then kD=kD+3;kC=kC+2;kF=kF+2;kE=kE-6;jS="altbig"end;if ky then jS=jS.." red"elseif kz then jS=jS.." orange"end;local kG=e4/kw%10;local kH=bM(kG)local kI=bM((kH+1)%10)local kJ=kx;if gx==0 then kJ=kG-kH;if ky then kJ=1-kJ end end;if ky and(gx==0 or kx~=0)then local gA=kI;kI=kH;kH=gA end;local kK=kD*(kJ-1)local kL=kK+kD;local hB=kr+kE+(6-gx)*kC;local hC=ks+kF;jY[#jY+1]=gO(hB,hC+kK,kI,jS)jY[#jY+1]=gO(hB,hC+kL,kH,jS)gx=gx+1;kw=kw*10;if kH==kB then kx=kJ else kx=0 end end;table.insert(jY,[[</g></g>]])end end;local function kM(fv)local kN=-math.deg(eV(fv.y,fv.z))+180;kN=kN-90;if kN<0 then kN=360+kN end;if kN>180 then kN=-180+kN-180 end;return-kN end;local function kO(fv)local kb=math.deg(eV(fv.y,fv.x))-90;if kb<-180 then kb=360+kb end;return kb end;local function kP(jY,fv,fq,al,am)if fq>5 and not cf or fq>iY then local k6=ae;local kQ=20;local kR=20;local kS=kM(fv)local kT=kO(fv)local kU=14;local kV=kU/2;local kW=-kT/kR*k6;local kX=kS/kQ*k6;local hB=al+kW;local hC=am+kX;local ca=dp(kW^2+kX^2)local kY=[[<circle
                            cx="]]..hB..[["
                            cy="]]..hC..[["
                            r="]]..kV/kU..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hB..[["
                            cy="]]..hC..[["
                            r="]]..kV..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hB-kU..[[,]]..hC..[[ h ]]..kV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hB+kV..[[,]]..hC..[[ h ]]..kV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hB..[[,]]..hC-kU..[[ v ]]..kV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ca<k6 then jY[#jY+1]=kY else local jZ=eV(kX,kW)local kZ=4;local k_=al+k6*math.cos(jZ)local l0=am+k6*math.sin(jZ)jY[#jY+1]=dl('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jZ*180/math.pi,k_,l0,k_-kZ,l0-kZ/2,kZ*2,kZ,k_+kZ,l0-kZ,kZ,kZ,-kZ,kZ)end;if not cf then local l1=vec3(fv)kS=kM(-l1)kT=kO(-l1)kW=-kT/kR*k6;kX=kS/kQ*k6;hB=al+kW;hC=am+kX;ca=dp(kW^2+kX^2)if ca<k6 then local l2=[[<circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hB..[[,]]..hC-kU..[[ v ]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hB..[[,]]..hC..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hB..[[,]]..hC..[[)" />
                                <path
                                    d="M ]]..hB-kV..[[,]]..hC..[[ h ]]..kU..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hB..[[,]]..hC..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hB..[[,]]..hC..[[)"/>]]jY[#jY+1]=l2 end end end end;local function l3(jY,jg,l4,l5)if an==0 and ao==0 then return end;l4=bM(l4+0.5)local jH=ao+10;local jI=ao+20;if iE()==1 and not l then jH=55;jI=65 end;local l6="CRUISE"local c="km/h"local dN=l5;if jg=="TRAVEL"or jg=="AUTOPILOT"then l6="THROT"c="%"dN=l4;local l7="dim"if l4<0 then l7="red"end;jY[#jY+1]=dl([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l7,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-e_(l4),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;jY[#jY+1]=gO(an+10,jH,l6,"pbright txtstart")jY[#jY+1]=gO(an+10,jI,dl("%.0f %s",dN,c),"pbright txtstart")if cf and t and cS and bS then l4=bM(bT*100+0.5)local l7="red"if l4<0 then l7="red"end;jY[#jY+1]=dl([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l7,1-e_(l4),an-10,ao+50,an-15,ao+53,an-15,ao+47)jY[#jY+1]=gO(an+10,jH+40,"LIMIT","pbright txtstart")jY[#jY+1]=gO(an+10,jI+40,l4 .."%","pbright txtstart")end;if cf and t or b8 then jY[#jY+1]=gO(an+10,jH-40,"LIMIT: "..cC.." km/h","dim txtstart")elseif not cf and b3 then jY[#jY+1]=gO(an+10,jH-40,"LIMIT: "..bM(ab*3.6+0.5).." km/h","dim txtstart")end end;local function l8(jY,l9)if an==0 and ao==0 then return end;local la=ao-10;local lb=an+10;jY[#jY+1]=gO(0,0,"","pdim txt txtend")if iE()==1 and not l then la=75 end;jY[#jY+1]=gO(lb,la,bM(l9).." km/h","pbright txtbig txtstart")end;local lc=40;local function ld(jY)jY[#jY+1]=gO(jc(150),jd(1070),dl("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jY[#jY+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jY[#jY+1]=gO(jc(960),jd(550),"Warning: Invalid Control Scheme Detected","warnings")jY[#jY+1]=gO(jc(960),jd(600),"Keyboard Scheme must be selected","warnings")jY[#jY+1]=gO(jc(960),jd(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local le=jc(960)local lf=jd(860)local lg=jd(880)local lh=jd(900)local li=jd(960)local lj=jd(200)local lk=jd(250)local ll=jd(960)if iE()==1 and not l then lf=jd(135)lg=jd(155)lh=jd(175)lj=jd(115)lk=jd(95)end;if b0 then local lm=""if type(b0)=="string"then lm="-"..b0 end;jY[#jY+1]=gO(le,lf,"Brake Engaged"..lm,"warnings")elseif bR>0 then jY[#jY+1]=gO(le,lf,"Auto-Brake Engaged","warnings","opacity:"..bR)end;if cf and cB and ce==-1 then if not b3 and not bq and not b6 and not cR and not b9 and not b7 then jY[#jY+1]=gO(le,lj+50,"** STALL WARNING **","warnings")fV("stall","SW",2)end end;if cY then jY[#jY+1]=gO(le,lj+90,"Flight Assist in Progress","warnings")end;if cj then jY[#jY+1]=gO(le,ll,"Gyro Enabled","warnings")end;if ln then lc=lc-1;if lc>20 then jY[#jY+1]=gO(le,ll-20,"ECU Enabled","warnings")elseif lc<0 then lc=40 end end;if bm then if bV then jY[#jY+1]=gO(le,lg,"Gear Extended","warn")else jY[#jY+1]=gO(le,lg,"Landed (G: Takeoff)","warnings")end end;if ce>-1 and(not cR or ch<100)then local lo=iJ(d:getTargetGroundAltitude())jY[#jY+1]=gO(le,lh,"Hover Height: "..lo,"warn")end;if c4 then jY[#jY+1]=gO(le,li+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not q and cR and bv~=nil then local lp="warnings"if e_(ch-antigrav.getBaseAltitude())<501 then lp="warn"end;jY[#jY+1]=gO(le,lj+40,dl("Target Altitude: %d Singularity Altitude: %d",bM(bv),bM(antigrav.getBaseAltitude())),lp)end;if b3 and bj~="None"then jY[#jY+1]=gO(le,lj,"Autopilot "..bg,"warn")elseif bt~=nil then jY[#jY+1]=gO(le,lj+20,dl("LockedPitch: %d",bM(bt)),"warn")elseif b_ then jY[#jY+1]=gO(le,lj+20,"Follow Mode Engaged","warn")elseif b8 or cd then jY[#jY+1]=gO(le,lj+20,"Re-entry in Progress","warn")end;if b5 or b9 then local lo=iJ(ba,2)if b9 then if cR then lo=iJ(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jY[#jY+1]=gO(le,lj,"VTO to "..lo,"warn")elseif b7 and not bz then if cc then jY[#jY+1]=gO(le,lj,"Takeoff to "..bj,"warn")else jY[#jY+1]=gO(le,lj,"Takeoff to "..lo,"warn")end;if b0 and not b9 then jY[#jY+1]=gO(le,lj+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jY[#jY+1]=gO(le,lj,"Altitude Hold: "..dl("%.1fm",ba),"warn")end end;if b9 and(antigrav~=nil and antigrav)then if cg>0.1 then jY[#jY+1]=gO(le,lj+20,"Beginning ascent","warn")elseif cg<0.09 and cg>0.05 then jY[#jY+1]=gO(le,lj+20,"Aligning trajectory","warn")elseif cg<0.05 then jY[#jY+1]=gO(le,lj+20,"Leaving atmosphere","warn")end end;if bz then if cD~=nil then jY[#jY+1]=gO(le,lj,cD,"warn")end end;if b6 then if lq then local lr="Brake Landing"if dd then lr=lr.."-Aligning"end;if dc then lr=lr.."-Drift Limited"end;jY[#jY+1]=gO(le,lj,lr,"warnings")else jY[#jY+1]=gO(le,lj,"Coast-Landing","warnings")end end;if b2 then jY[#jY+1]=gO(le,lj,"Prograde Alignment","crit")end;if b1 then jY[#jY+1]=gO(le,lj,"Retrograde Alignment","crit")end;if c_ then local type;if string.find(c_,"COLLISION")then type="warnings"else type="crit"end;jY[#jY+1]=gO(le,lk+20,c_,type)elseif cg==0 then local ls,lt=cu.checkLOS(cL:normalize())if lt~=nil then local lo=iJ(lt)local lu=cq.computeTravelTime(cM,0,lt)local lv="Collision"if ls.noAtmosphericDensityAltitude>0 then lv="Atmosphere"end;jY[#jY+1]=gO(le,lk+20,ls.name.." "..lv.." "..iK(lu).." In "..lo,"crit")end end;if bq and not bz then jY[#jY+1]=gO(le,lj+60,lw,"warn")end;if d3 and#d3>1 then end;local lx=jc;local ly=jd;local lz="topButton"local lA="topButtonActive"local lB=lz;if b3 or bq or cc or bz then lB=lA end;local lC=lz;if b2 then lC=lA end;local lD=lz;if b6 or bm then lD=lA end;local lE=lz;if b5 or bq then lE=lA end;local lF=lz;if b1 then lF=lA end;local lG=lz;if bz or cF and b3 then lG=lA end;if w and I then local lH=ly(30)jY[#jY+1]=dl([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lB,lx(960),ly(54),ly(-53),lx(-120),lx(25),ly(50))jY[#jY+1]=gO(lx(910),lH,"AUTOPILOT")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lC,lx(865),ly(51),lx(-25),ly(-50),lx(-110),lx(25),ly(46))jY[#jY+1]=gO(lx(800),lH,"PROGRADE")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,lx(755),ly(47),lx(-25),ly(-46),lx(-98),lx(44),ly(44))jY[#jY+1]=gO(lx(700),lH,"LAND")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lE,lx(960),ly(54),ly(-53),lx(120),lx(-25),ly(50))jY[#jY+1]=gO(lx(1010),lH,"ALT HOLD")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lx(1055),ly(51),lx(25),ly(-50),lx(110),lx(-25),ly(46))jY[#jY+1]=gO(lx(1122),lH,"RETROGRADE")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lx(1165),ly(47),lx(25),ly(-46),lx(98),lx(-44),ly(44))jY[#jY+1]=gO(lx(1220),lH,"ORBIT")jY[#jY+1]=[[
                                    </g>
                                </g>]]jY[#jY+1]="</g>"end;return jY end;local function lI(fq)return bM(fW(fq*3.6,0)+0.5).." km/h"end;local function lJ(gx)local gz=bj;if gx~=nil and type(gx)=="number"then if gx==0 then return"None"end;gz=cV[gx].name end;if gz==nil then gz=g6.name end;if gz==nil then gz="None"end;return gz end;local function lK(jY)local lL=cu.routeWP(true)if not lL or#lL==0 then return end;local hB=jc(750)local hC=jd(360)if b3 or bq then jY[#jY+1]=gO(hB,hC,"REMAINING ROUTE","pdim txtstart size20")else jY[#jY+1]=gO(hB,hC,"LOADED ROUTE","pdim txtstart size20")end;for dM,M in pairs(lL)do hC=hC+20;jY[#jY+1]=gO(hB,hC,dM..". "..lL[dM],"pdim txtstart size20")end end;local function lM(jY)local hB=aB+10;local hC=aC+20;local lN={}local lO={"Alt-4: AutoTakeoff to Target"}local lP={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lQ={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lR={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lN,"--------------DYNAMIC-----------------")if cf then if ce~=-1 then iH(lN,lO)if c7 and kA and c7.name==kA.name then table.insert(lN,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or a_ then if antigrav then if cR then table.insert(lN,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lN,"Turn on AGG to takeoff to AGG Height")end end;if a_ then table.insert(lN,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lN,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lN,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bm then table.insert(lN,"G: Takeoff to hover height, raise gear")else table.insert(lN,"G: Lowergear and Land")end else iH(lN,lP)table.insert(lN,"G: Begin BrakeLanding or Land")end;if b9 then table.insert(lN,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iH(lN,lQ)if shield then table.insert(lN,"Alt-Shift-6: Vent shields")if not G then table.insert(lN,"Alt-Shift-7: Toggle shield off/on")end end end;if g6~=nil then table.insert(lN,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lN,"Alt-9: Activate Gyroscope")end;if aW~="none"or aV~="none"or aX~="none"then table.insert(lN,"Alt-Shift-9: Cycles engines with Extra tags")end;if b5 then table.insert(lN,"Alt-Spacebar/C will raise/lower target height")table.insert(lN,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cf then table.insert(lN,"LALT+Mousewheel will lower/raise speed limit")end;iH(lN,lR)for M=1,#lN do hC=hC+12;jY[#jY+1]=gO(hB,hC,lN[M],"pdim txtbig txtstart")end end;local function lS(jY)local lT=aB;local lU=aC;local lV=aA;local lW=4;local lX=15;local hB=0;local hC=0;local lY,lZ,l_,m0;local m1;local function m2(type)local gJ,bP,fq,m3,jS,m4;if type=="Periapsis"then gJ=m1.periapsis.altitude;bP=m1.timeToPeriapsis;fq=m1.periapsis.speed;jS="txtend"m3=12;m4=math.min(hB,lT+lV-kA.radius/l_-lW*2)else gJ=m1.apoapsis.altitude;bP=m1.timeToApoapsis;fq=m1.apoapsis.speed;m3=-12;jS="txtstart"m4=hB end;if cM<1 then bP=0 end;jY[#jY+1]=dl([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m4+m3,hC-5,hB,hC-5)jY[#jY+1]=dl([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m4-m3*4,hC+2,hB,hC+2)jY[#jY+1]=gO(m4,hC,type,jS)hB=m4-m3*2;hC=hC+lX;local lo=iJ(gJ)jY[#jY+1]=gO(hB,hC,lo,jS)hC=hC+lX;jY[#jY+1]=gO(hB,hC,iK(bP),jS)hC=hC+lX;jY[#jY+1]=gO(hB,hC,lI(fq),jS)end;local m5=lV*1.5;if bJ=="INFO"then m5=25*10 end;if bJ=="ORBIT"and ch<kA.spaceEngineMinAltitude then return jY end;if bJ~="HIDE"then jY[#jY+1]=[[<g class="pbright txtorb txtmid">]]jY[#jY+1]=dl('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lV*2,m5,lT,lU)jY[#jY+1]=dl([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lV*2,m5,lT,lU)end;local m6=lV*1.5;local m7=lV*2;local m8=m6/2;local m9=lV;local ma=lT+m9;local mb=lU+m8;local mc=lT+m7;local md=lU+m6;if bJ=="ORBIT"then lU=lU+lW;lY=lV/2;m0=0;m1={}m1.periapsis={}m1.apoapsis={}if fu~=nil then if fu.periapsis~=nil then m1.periapsis.altitude=fu.periapsis.altitude;m1.periapsis.speed=fu.periapsis.speed end;if fu.apoapsis~=nil then m1.apoapsis.altitude=fu.apoapsis.altitude;m1.apoapsis.speed=fu.apoapsis.speed end;m1.period=fu.period;m1.eccentricity=fu.eccentricity;m1.timeToApoapsis=fu.timeToApoapsis;m1.timeToPeriapsis=fu.timeToPeriapsis;m1.eccentricAnomaly=fu.eccentricAnomaly;m1.trueAnomaly=fu.trueAnomaly end;if m1.periapsis==nil then m1.periapsis={}m1.periapsis.altitude=-kA.radius;m1.periapsis.speed=ab end;if m1.eccentricity==nil then m1.eccentricity=1 end;if m1.apoapsis==nil then m1.apoapsis={}m1.apoapsis.altitude=ch;m1.apoapsis.speed=0 end;if cM<1 then m1.apoapsis.altitude=ch;m1.apoapsis.speed=0 end;if m1.apoapsis.altitude then l_=(m1.apoapsis.altitude+m1.periapsis.altitude+kA.radius*2)/(lY*2)lZ=(kA.radius+m1.apoapsis.altitude)/l_*(1-m1.eccentricity)m0=lY-m1.periapsis.altitude/l_-kA.radius/l_;local me=math.pi;if m1.period~=nil and m1.period>0 and m1.timeToApoapsis~=nil then me=m1.eccentricAnomaly;if m1.timeToPeriapsis<m1.timeToApoapsis then me=2*math.pi-me end end;if cM<1 or me~=me then me=math.pi end;local mf=-lY*math.cos(me)+lT+m9+lW;local mg=lZ*math.sin(me)+lU+m8+lW;local mh=""jY[#jY+1]='<g clip-path="url(#orbitRect)">'jY[#jY+1]=dl([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mh,lT+lV+lW,lU+lV*1.5/2+lW,lY,lZ)if lZ<1 then jY[#jY+1]=dl([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lT+lV+lW-m0,lU+lV*1.5/2+lW,mf,mg)end;jY[#jY+1]=dl('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lT+lV+lW-m0,lU+lV*1.5/2+lW,(kA.radius+kA.noAtmosphericDensityAltitude)/l_)jY[#jY+1]=dl('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lT+lV+lW-m0,lU+lV*1.5/2+lW,(kA.radius+kA.noAtmosphericDensityAltitude)/l_)jY[#jY+1]=dl([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lT+lV+lW,lU+lV*1.5/2+lW,lY,lZ)jY[#jY+1]=dl('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lT+lV+lW-m0,lU+lV*1.5/2+lW,kA.radius/l_)jY[#jY+1]='</g>'local mi=math.floor(kA.radius/l_+0.5)hB=lT+lV+lW*4+lY;hC=lU+lV*1.5/2+5+lW;if m1.apoapsis~=nil and m1.apoapsis.speed<ab then m2("Apoapsis")end;hC=lU+lV*1.5/2+5+lW;hB=lT+lV-lW*2-lY;if m1.periapsis~=nil and m1.periapsis.speed<ab and m1.periapsis.altitude>0 then m2("Periapsis")end;jY[#jY+1]=gO(lT+lV+lW,lU+20+lW,kA.name,"txtorbbig")jY[#jY+1]=dl('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mf,mg)jY[#jY+1]=[[</g>]]return jY else jY[#jY+1]='<g clip-path="url(#orbitRect)">'local mj=""local mk=1.2*(ml-mm)/(lV*2)local mn=1.4*(mo-mp)/(lV*1.5)for dM,dy in pairs(e[0])do if dy.center then local hB=lT+lV+dy.center.x/mk;local hC=lU+lV*1.5/2+dy.center.y/mn;mj=mj..'<circle cx="'..hB..'" cy="'..hC..'" r="'..dy.radius/mk*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dy.name,"Moon")and not string.match(dy.name,"Sanctuary")and not string.match(dy.name,"Space")then mj=mj.."<text x='"..hB.."' y='"..hC+dy.radius/mk*30+20 .."' font-size='12' fill="..j4 .." text-anchor='middle' font-family='Montserrat'>"..dy.name.."</text>"end end end;local fw=vec3(bO.getWorldPosition())local hB=lT+lV+fw.x/mk;local hC=lU+lV*1.5/2+fw.y/mn;mj=mj..'<circle cx="'..hB..'" cy="'..hC..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mj=mj.."<text x='"..hB.."' y='"..hC-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iS=mk;iT=mn;local mq=fw+cL*1000000;local mr=lT+lV+mq.x/mk;local jI=lU+lV*1.5/2+mq.y/mn;mj=mj..'<line x1="'..hB..'" y1="'..hC..'" x2="'..mr..'" y2="'..jI..'" stroke="purple" stroke-width="1"/>'jY[#jY+1]=mj;jY[#jY+1]='</g>'end elseif bJ=="INFO"then jY=cs.DrawOdometer(jY,j6,bn,j7)elseif bJ=="HELP"then jY=lM(jY)elseif bJ=="SCOPE"then jY[#jY+1]='<g clip-path="url(#orbitRect)">'local ms=d6;if cg>0 then table.sort(d5,function(eB,eC)local eD,eE=eB.center,eC.center;return(eD.x-cP.x)^2+(eD.y-cP.y)^2+(eD.z-cP.z)^2<(eE.x-cP.x)^2+(eE.y-cP.y)^2+(eE.z-cP.z)^2 end)end;local mt={}local mu={}local mv=120;local mw=nil;local mx=nil;for M,dy in ipairs(d5)do local gW=dy.center-cP;local my=gW:len()local mz=gW:normalize()local mA=gW:cross(cI):normalize()local mB=math.acos(mA:dot(cJ))if mB~=mB then mB=0 end;if mA:cross(cJ):dot(cI)<0 then mB=-mB end;local mC=gW:project_on_plane(cI):len()local mD=math.sin(mB)*math.asin(mC/my)*constants.rad2deg;local mE=math.cos(mB)*math.asin(mC/my)*constants.rad2deg;if mz:dot(cI)<0 then mE=90*math.cos(mB)+90*math.cos(mB)-mE;mD=90*math.sin(mB)+90*math.sin(mB)-mD end;local hB=ma+mD/ms*m6;local hC=mb+mE/ms*m6;local mF=(hB-ma)*(hB-ma)+(hC-mb)*(hC-mb)local mG=math.asin((dy.radius+dy.surfaceMaxAltitude)/my)*constants.rad2deg;if mG~=mG then mG=ms end;local h_=mG/ms*m6;local mH=math.asin(dy.atmosphereRadius/my)*constants.rad2deg;if mH~=mH then mH=mG end;local mI=mH/ms*m6;local ca=iJ(my,1)local mJ=dy.name;local mK=false;if hC>lU then if hC>md then if hC-mI<=md then mK=true end else mK=true end else if hC+mI>=lU then mK=true end end;local mL=false;local mM=hB;if dy.systemId==0 then mM=hB+mv else mM=hB-mv end;if mM+mv>lT then if mM+mv>mc then if mM-mI-mv<=mc then mL=true end else mL=true end else if mM+mI+mv>=lT then mL=true end end;local mN={}mN.x=hB;mN.y=hC;mN.planet=dy;mN.atmoSize=mI;if not mw or mF<mw then mw=mF;mx=mN end;if mL and mK then local mO=math.max(mI,5)if mF<mO*mO then mJ=mJ.." - "..ca end;mN.size=h_;mN.i=M;mN.displayString=mJ;mN.distance=ca;mN.visible=true;mu[#mu+1]=mN else mN.visible=false end end;local mP=false;table.sort(mu,function(eD,eE)return eD.y<eE.y end)for dM,fz in ipairs(mu)do local dy,h_,M,mI,hB,hC,mJ,ca=fz.planet,fz.size,fz.i,fz.atmoSize,fz.x,fz.y,fz.displayString,fz.distance;local m4,mQ,mR,mS;local mT=15;local jS="pdim"if dy.systemId~=0 then mR=jc(string.len(mJ)*5)mT=-(15+mR)mS=jd(10)jS="pdimfill"else mR=jc(string.len(mJ)*9)mS=jd(15)end;if h_*2>mR then m4=dm(hB,lT+mR/2,mc-mR/2)mQ=dm(hC,lU+mS,md-5)m4=dm(m4,hB-h_+mR/2,hB+h_-mR/2)mQ=dm(mQ,hC-h_+mS,hC+h_)else m4=hB+mT;mQ=hC end;for mU,fz in pairs(mt)do local mV=fz.textPositions;local mW=mV.y-mQ;if mU~=M and e_(mW)<mV.height and mV.x+mV.width>m4 and mV.x<m4+mR then if h_>mR then mQ=dm(mQ+mS,lU+15,md-5)else mQ=mV.y+mV.height+1 end end end;local mX=mJ~=dy.name or m4<=ma and m4+mR>=ma and mQ-mS<=mb and mQ>=mb;fz.hovered=mX;local mY=1;if mX then mY=2;if h_*2<mR then mY=10 end;if mJ==dy.name then mJ=mJ.." - "..ca end;jS="pbright"if dy.systemId~=0 then mR=jc(string.len(mJ)*5)mT=-(15+mR)else mR=jc(string.len(mJ)*7)end;if h_*2>mR then m4=dm(hB,lT+mR/2,mc-mR/2)m4=dm(m4,hB-h_+mR/2,hB+h_-mR/2)else m4=hB+mT end end;mt[M]={}mt[M].textPositions={}mt[M].textPositions.y=mQ;mt[M].textPositions.x=m4;mt[M].textPositions.width=mR;mt[M].textPositions.height=mS;mt[M].output=""if h_*2>mR then jS=jS.." txtmid"else jS=jS.." txtstart"end;if mI-h_>2 then mt[M].output=dl('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hB,hC,mI,j5,0.1*mY)end;mt[M].output=mt[M].output..dl('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hB,hC,h_,j5,0.2*mY)if dy.systemId==0 then mt[M].output=mt[M].output..dl([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m4,mQ,j4,jS,mJ)if h_*2<=mR then mt[M].output=mt[M].output..dl("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m4+mR,mQ+2,m4,mQ+2,hB,hC)end else mt[M].output=mt[M].output..dl([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m4,mQ,j5,jS,mJ)if h_*2<=mR then mt[M].output=mt[M].output..dl("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m4,mQ+2,m4+mR,mQ+2,hB,hC)end end end;for dM=#d5,1,-1 do if mt[dM]then jY[#jY+1]=mt[dM].output end end;if mx~=nil and d6<90 and not mx.hovered then local mZ=mx.planet.atmosphereRadius/mx.atmoSize;local m_=dp(mw)*mZ;local n0=iJ(m_,1)local mR=jc(math.max(string.len(n0)*7,string.len(mx.planet.name)*7))local mS=jd(12)local m4=dm(mx.x+(ma-mx.x)/2,lT+mR/2,mc-mR/2)local mQ=dm(mx.y+(mb-mx.y)/2,lU+mS*2,md-5)jY[#jY+1]=dl("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mx.x,mx.y,ma,mb)jY[#jY+1]=dl([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m4,mQ,"white",n0)if not mx.visible then jY[#jY+1]=dl([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m4,mQ-mS,"white",mx.planet.name)end end;if cM>1 then local gW=cL;local mz=gW:normalize()local mC=gW:project_on_plane(cI):len()local mA=gW:cross(cI):normalize()local mB=math.acos(mA:dot(cJ))if mB~=mB then mB=0 end;if mA:cross(cJ):dot(cI)<0 then mB=-mB end;local mD=math.sin(mB)*math.asin(mC/gW:len())*constants.rad2deg;local mE=math.cos(mB)*math.asin(mC/gW:len())*constants.rad2deg;if mz:dot(cI)<0 then mE=90*math.cos(mB)+90*math.cos(mB)-mE;mD=90*math.sin(mB)+90*math.sin(mB)-mD end;local hB=ma+mD/ms*m6;local hC=mb+mE/ms*m6;local kU=14;local kV=kU/2;local kY=[[<circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kV/kU..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hB-kU..[[,]]..hC..[[ h ]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hB+kV..[[,]]..hC..[[ h ]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hB..[[,]]..hC-kU..[[ v ]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jY[#jY+1]=kY end;jY[#jY+1]=dl("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",ma,mb-10,ma,mb+10)jY[#jY+1]=dl("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",ma-10,mb,ma+10,mb)jY[#jY+1]='</g>'else return jY end end;local function n1(n2,n3)local n4;local n5=(n3-n2):normalize()local fx=(cP-n2):dot(n5)/n5:dot(n5)if fx<=0. then return(cP-n2):len()elseif fx>=(n3-n2):len()then return(cP-n3):len()end;local n6=n2+fx*n5;n4=(n6-cP):len()return n4 end;local function n7()local n4;local n8=nil;local n9=nil;local na=nil;for dM,nb in pairs(e[0])do if nb.hasAtmosphere then local ca=n1(kA.center,nb.center)if n8==nil or ca<n8 then n9=nb;n8=ca;na=kA end;if c7 and c7.hasAtmosphere and c7.name~=kA.name then local eQ=n1(c7.center,nb.center)if eQ<n8 then n9=nb;n8=eQ;na=c7 end end end end;local nc=jc(1770)local nd=jd(330)if n8 then local ne="txttick "local nf=500000;if n8<n9.radius+nf or n8<na.radius+nf then if cW then ne="txttick red "else ne="txttick orange "end end;n4=iJ(n8,2)iX=gO(nc,nd,"Pipe ("..na.name.."--"..n9.name.."): "..n4,ne.."pbright txtmid")end end;local function ng(hB,hC,nh,ni,l6)local nj={x=hB,y=hC,width=nh,height=ni,label=l6}iR[l6]=nj;return nj end;local function nk(nl,nm,nh,ni,hB,hC,nn,no,np,nq,jS)local nj={enableName=nl,disableName=nm,width=nh,height=ni,x=hB,y=hC,toggleVar=nn,toggleFunction=no,drawCondition=np,hovered=false,class=jS}if nq then table.insert(iQ,nj)else table.insert(iP,nj)end;return nj end;local function nr(ns)if not iV then nt=false;nu=false;nv=false;w=true;return elseif ns=="handling"then nt=not nt;nu=false;nv=false elseif ns=="hud"then nu=not nu;nt=false;nv=false elseif ns=="physics"then nv=not nv;nt=false;nu=false end;if nv or nu or nt then iW=iI(ns)w=false else iW="none"w=true end end;local function nw()iV=not iV;if iV then iO=iQ;c2="Tap SHIFT to see Settings"d7=w else iO=iP;c2="Tap SHIFT to see Control Buttons"nr()w=d7 end end;local function nx()local function ny(dy,dM)dy.set(not dy.get())if dy.get()then c2=dM.." set to true"else c2=dM.." set to false"end;if dM=="showHud"then d7=dy.get()elseif dM=="BrakeToggleDefault"then aZ=j elseif dM=="FullRadar"then if cv then cv.ToggleRadarPanel()cv=nil;J=false else J=true;nz.radarSetup()end end end;local nA=50;local nB=340;local hB=500;local hC=cl/2-400;local nC=0;for dM,dy in pairs(iI("boolean"))do if type(dy.get())=="boolean"then nk(dM,dM,nB,nA,hB,hC,function()return dy.get()end,function()ny(dy,dM)end,function()return true end,true)hC=hC+nA+20;if nC==9 then hB=hB+nB+20;hC=cl/2-400;nC=0 else nC=nC+1 end end end;nk("Control View","Control View",nB,nA,10,cl/2-500,function()return true end,nw,function()return true end,true)nk("View Handling Settings",'Hide Handling Settings',nB,nA,10,cl/2-(500-nA),function()return nt end,function()nr("handling")end,function()return true end,true)nk("View Hud Settings",'Hide Hud Settings',nB,nA,10,cl/2-(500-nA*2),function()return nu end,function()nr("hud")end,function()return true end,true)nk("View Physics Settings",'Hide Physics Settings',nB,nA,10,cl/2-(500-nA*3),function()return nv end,function()nr("physics")end,function()return true end,true)end;local function nD()local function gy()local fY=cP;local gz=kA.name..". "..#bp;if cv then gz=cv.GetClosestName(gz)end;return ct.AddNewLocation(gz,fY,false,true)end;local function nE()b4=not b4 end;local function nF(nG)if nG==1 then b2=not b2;b1=false else b1=not b1;b2=false end;b3=false;b5=false;b_=false;b6=false;bt=nil;b8=false;b7=false end;local function nH(nI,nJ)ct.UpdatePosition(nil,nI,nJ)end;local function gt()ct.ClearCurrentPosition()end;local function nK(gx)local lL=cu.routeWP(true)if lL and#lL>0 then return"Engage Route: "..lL[1]end;return"Engage Autopilot: "..lJ(gx)end;local function nL(gx)local lL=cu.routeWP(true)if lL and#lL>0 then return"Next Route Point: "..lL[1]end;return"Disable Autopilot: "..lJ(gx)end;local function nM()if iE()==1 then b_=not b_;if b_ then b3=false;b1=false;b2=false;b5=false;b8=false;b6=false;b7=false;nN=bm;bm=false;d.control.retractLandingGears()iF:setTargetGroundAltitude(Z)fV("folOn","F")else fV("folOff","F")b0="Follow Off"cA=p;bm=nN;if bm then d.control.deployLandingGears()iF:setTargetGroundAltitude(_)end end else c2="Follow Mode only works with Remote controller"b_=false end end;local nA=50;local nB=260;local nO=jc(30)local nP=aB+aA*2+2;local nQ=aC+1;nk("+","+",nO,nO,nP,nQ+nO+1,function()return false end,function()d6=d6/8 end,function()return bJ=="SCOPE"end,nil,"ZoomButton")nk("-","-",nO,nO,nP,nQ,function()return false end,function()d6=math.min(d6*8,90)end,function()return bJ=="SCOPE"end,nil,"ZoomButton")nk("0","0",nO,nO,nP,nQ+nO*2+2,function()return false end,function()d6=90 end,function()return bJ=="SCOPE"and d6~=90 end,nil,"ZoomButton")local nR=nk("Enable Brake Toggle","Disable Brake Toggle",nB,nA,ck/2-nB/2,cl/2+350,function()return aZ end,function()aZ=not aZ;if aZ then c2="Brakes in Toggle Mode"else c2="Brakes in Default Mode"end end)nk("Align Prograde","Disable Prograde",nB,nA,ck/2-nB/2-50-nR.width,cl/2-nA+380,function()return b2 end,function()nF(1)end)nk("Align Retrograde","Disable Retrograde",nB,nA,ck/2-nB/2+nR.width+50,cl/2-nA+380,function()return b1 end,nF,function()return cg==0 end)nS=nk(nK,nL,600,60,ck/2-600/2,cl/2-60/2-330,function()return b3 or bq or cc or bz end,function()end)local M;local function nT(nU)local gx=d2+nU;if gx>#cV then gx=gx-#cV-1 end;if gx<0 then gx=#cV+gx end;return gx end;nV={}for M=0,10 do local nW=nk(function(eE)local gx=nT(eE.apExtraIndex)if b3 or bq or cc or bz then return"Redirect: "..lJ(gx)end;return nK(gx)end,function(eE)local gx=nT(eE.apExtraIndex)return nL(gx)end,600,60,ck/2-600/2,cl/2-60/2-330+60*M,function(eE)local gx=nT(eE.apExtraIndex)return gx==bl and(b3 or bq or cc or bz)end,function(eE)local gx=nT(eE.apExtraIndex)local nX=bl==gx;bl=gx;ct.UpdateAutopilotTarget()cu.ToggleAutopilot()if not nX and not(b3 or bq or cc or bz)then cu.ToggleAutopilot()end end,function()return d1 and(#cu.routeWP(true)==0 or M==0)end)nW.apExtraIndex=M;nV[M]=nW end;nk("Save Position","Save Position",200,nS.height,nS.x+nS.width+30,nS.y,function()return false end,gy,function()return bl==0 or g6==nil end)nk("Update Position","Update Position",200,nS.height,nS.x+nS.width+30,nS.y,function()return false end,function()nH(nil)end,function()return bl>0 and g6~=nil end)nk("Save Heading","Clear Heading",200,nS.height,nS.x+nS.width+30,nS.y+nS.height+20,function()return g6.heading~=nil end,function()if g6.heading~=nil then nH(false)else nH(true)end end,function()return bl>0 and g6~=nil end)nk("Save AGG Alt","Clear AGG Alt",200,nS.height,nS.x+nS.width+30,nS.y+nS.height*2+40,function()return g6.agg~=nil end,function()if g6.agg~=nil then nH(nil,false)else nH(nil,true)end end,function()return bl>0 and g6~=nil and antigrav end)nk("Clear Position","Clear Position",200,nS.height,nS.x-200-30,nS.y,function()return true end,gt,function()return bl>0 and g6~=nil end)nk("Save Route","Save Route",200,nS.height,nS.x-200-30,nS.y+nS.height*2+40,function()return false end,function()cu.routeWP(false,false,2)end,function()return#cu.routeWP(true)>0 end)nk("Load Route","Clear Route",200,nS.height,nS.x-200-30,nS.y+nS.height+20,function()return#cu.routeWP(true)>0 end,function()if#cu.routeWP(true)>0 then cu.routeWP(false,true)elseif b3 or bq then c2="Disable Autopilot before loading route"return else cu.routeWP(false,false,1)end end,function()return true end)nA=60;nB=300;local hB=0;local hC=cl/2-150;nk("Enable Check Damage","Disable Check Damage",nB,nA,hB,hC-nA-20,function()return s end,function()s=not s end)nk("View Settings","View Settings",nB,nA,hB,hC,function()return true end,nw)hC=hC+nA+20;nk("Enable Turn and Burn","Disable Turn and Burn",nB,nA,hB,hC,function()return b4 end,nE)hB=10;hC=cl/2-300;nk("Horizontal Takeoff Mode","Vertical Takeoff Mode",nB,nA,ck/2-nB/2,hC+20,function()return a_ end,function()a_=not a_;if a_ then c2="Vertical Takeoff Mode"else c2="Horizontal Takeoff Mode"end end,function()return cQ end)hC=hC+nA+20;nk("Engage Orbiting","Cancel Orbiting",nB,nA,hB+nB+20,hC,function()return bz end,cu.ToggleIntoOrbit,function()return cg==0 and cZ end)hC=cl/2-150;nk("Glide Re-Entry","Cancel Glide Re-Entry",nB,nA,hB+nB+20,hC,function()return b8 end,function()cb=1;nF(1)end,function()return kA.hasAtmosphere and not cf end)hC=hC+nA+20;nk("Parachute Re-Entry","Cancel Parachute Re-Entry",nB,nA,hB+nB+20,hC,function()return b8 end,function()cb=2;nF(1)end,function()return kA.hasAtmosphere and not cf end)hC=hC+nA+20;nk("Engage Follow Mode","Disable Follow Mode",nB,nA,hB,hC,function()return b_ end,nM,function()return iE()==1 end)nk("Enable Repair Arrows","Disable Repair Arrows",nB,nA,hB+nB+20,hC,function()return ja end,function()ja=not ja;if ja then c2="Repair Arrows Enabled"else c2="Repair Arrows Diabled"end end,function()return iE()==1 end)hC=hC+nA+20;if not q then nk("Enable AGG","Disable AGG",nB,nA,hB,hC,function()return cR end,cu.ToggleAntigrav,function()return antigrav~=nil end)end;nk(function()return dl("Switch IPH Mode - Current: %s",bA)end,function()return dl("IPH Mode: %s",bA)end,nB*2,nA,hB,hC,function()return false end,function()if bA=="All"then bA="Custom Only"elseif bA=="Custom Only"then bA="No Moons"else bA="All"end;c2="IPH Mode: "..bA end)hC=hC+nA+20;nk(function()return dl("Toggle Control Scheme - Current: %s",g)end,function()return dl("Control Scheme: %s",g)end,nB*2,nA,hB,hC,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c2="New Control Scheme: "..g end)local nY=jd(20)local nW=ng(0,0,jc(70),nY,"HELP")nW=ng(nW.x+nW.width,nW.y,jc(80),nY,"INFO")nW=ng(nW.x+nW.width,nW.y,jc(70),nY,"ORBIT")nW=ng(nW.x+nW.width,nW.y,jc(70),nY,"SCOPE")ng(nW.x+nW.width,nW.y,jc(70),nY,"HIDE")end;local nZ={}local n_=nil;function nZ.HUDPrologue(jY)if not cW then j1=ai;j2=aj;j3=ak else j1=af;j2=ag;j3=ah end;j4=[[rgb(]]..bM(j1+0.6)..","..bM(j2+0.6)..","..bM(j3+0.6)..[[)]]j5=[[rgb(]]..bM(j1*0.8+0.5)..","..bM(j2*0.8+0.5)..","..bM(j3*0.8+0.5)..[[)]]local o0=j4;local o1=j5;local o2=[[rgb(]]..bM(j1*0.4+0.5)..","..bM(j2*0.4+0.5)..","..bM(j3*0.4+0.5)..[[)]]local o3=j4;local o4=j5;local o5=o2;if je()and not m then o0=[[rgb(]]..bM(j1*0.5+0.5)..","..bM(j2*0.5+0.5)..","..bM(j3*0.5+0.5)..[[)]]o1=[[rgb(]]..bM(j1*0.3+0.5)..","..bM(j2*0.3+0.5)..","..bM(j3*0.2+0.5)..[[)]]o2=[[rgb(]]..bM(j1*0.2+0.5)..","..bM(j2*0.2+0.5)..","..bM(j3*0.2+0.5)..[[)]]end;local lx=jc;local ly=jd;jY[#jY+1]=dl([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o0,o0,o0,o3,o3,o1,o1,o4,o4,o1,o0,o2,o4,o0,o0,o2,o2,o5,o2,ck,cl,o1,o1,o1,o1,o1,o3,o1,o4,o5,o4,o4,o5)if not n_ then n_=dl([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lx(630),ly(0),lx(675),ly(45),lx(960),ly(55),lx(1245),ly(45),lx(1290),ly(0),lx(1000),ly(105),lx(1040),ly(59),lx(1250),ly(51),lx(1300),ly(0),lx(1920),ly(0),lx(1920),ly(20),lx(1400),ly(20),lx(1300),ly(105),lx(920),ly(105),lx(880),ly(59),lx(670),ly(51),lx(620),ly(0),lx(0),ly(0),lx(0),ly(20),lx(520),ly(20),lx(620),ly(105),lx(890),ly(59),lx(960),ly(62),lx(1030),ly(59),lx(985),ly(112),lx(1150),ly(112),lx(1100),ly(152),lx(820),ly(152),lx(780),ly(112),lx(935),ly(112),lx(890),ly(59),lx(960),ly(62),lx(1030),ly(59),lx(985),ly(112),lx(1150),ly(112),lx(1100),ly(152),lx(820),ly(152),lx(780),ly(112),lx(935),ly(112))end;if w and I then jY[#jY+1]=n_ end;return jY end;function nZ.DrawVerticalSpeed(jY,e4)jX(jY,e4)end;function nZ.UpdateHud(jY)local kN=cT;local o6=cU;local k4=o6;local kk=kN;local l4=bM(c.getThrottle())local l9=cM*3.6;local l5=c.getAxisCommandValue(0)local o7=jc(1770)local o8=jd(310)if t and cS then l5=bQ;l4=bQ*100 end;local jg=jf()local k5="ROLL"if l4==nil then l4=0 end;if not cZ then if cM>5 then kN=kM(cK)o6=kO(cK)else kN=0;o6=0 end;k5="YAW"end;if cX>50000 and not cf then local o9;o9=iJ(cX)jY[#jY+1]=gO(o7,o8,"PvP Boundary: "..o9,"pbright txtbig txtmid")end;jY[#jY+1]=j8;jY[#jY+1]=ie;if iX~=""then jY[#jY+1]=iX end;if jh~=""then jY[#jY+1]=jh end;if ji~=""then jY[#jY+1]=ji end;jX(jY,ch)if iE()==0 or l then if not je()or m then if cZ then k3(jY,al,am,k4,k5,cZ)kj(jY,kk,k4,al,am,cZ,bM(kO(cK)),cM)else k3(jY,al,am,o6,k5,cZ)kj(jY,kN,o6,al,am,cZ,bM(o6),cM)end;kq(jY,ch,cZ)kP(jY,cK,cM,al,am)end end;l3(jY,jg,l4,l5)l8(jY,l9)ld(jY)lS(jY)if not iV and c0 then lK(jY)end;return jY end;function nZ.HUDEpilogue(jY)jY[#jY+1]="</svg>"return jY end;function nZ.ExtraData(jY)local oa=jc(1240)local ob=jd(55)local oc=ob+10;local od;local lx=jc;local ly=jd;local oe=0;local jg=jf()if a_ then jg=jg.."-VERTICAL"end;if E and not b7 and not b6 and cM>20 then jg=jg.."-COLLISION ON"end;if bC~="Off"then jg="("..bC..")-"..jg end;if b4 then jg="TB-"..jg end;if bH then jg="HOVERMODE-"..jg end;if not bB then jg=jg.."-DeCoupled"end;local of=ly(99)local og=ly(80)local oh=ly(85)local oi=ly(31)local oj=0;local ok=0;local ol=ci>1000000 and fW(ci/1000000,2).."kT"or fW(ci/1000,2).."T"if cf then oe=bu else oe=bs end;local om,on=cq.computeDistanceAndTime(cM,0,ci,0,0,oe)if om<0 then om=0 end;oe=fW(oe/(ci*iN),2).."g"local oo=d:maxForceForward()od=b.getGravityIntensity()if od>0.1 then ok=ci*od;ok=fW(ok/(ci*iN),2).."g"oj=0.5*oo/od;oj=oj>1000000 and fW(oj/1000000,2).."kT"or fW(oj/1000,2).."T"end;oo=fW(oo/(ci*iN),2).."g"local op=vec3(bO.getWorldAcceleration()):len()/9.80665;od=b.getGravityIntensity()jY[#jY+1]=[[<g class="dim txt txtend size14">]]if iE()==1 and not l then oa=jc(1120)ob=jd(55)oc=ob+10 elseif cf and I then local oq=jc(770)jY[#jY+1]=gO(lx(895),of,"ATMO","")jY[#jY+1]=dl([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lx(895),oh,lx(-80))jY[#jY+1]=gO(lx(815),og,dl("%.1f%%",cg*100),"txtstart size20")end;if I then jY[#jY+1]=gO(lx(1025),of,"GRAVITY","txtstart")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(1025),oh,lx(80))jY[#jY+1]=gO(lx(1105),og,dl("%.2fg",od/9.80665),"size20")jY[#jY+1]=gO(lx(1125),of,"ACCEL","txtstart")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(1125),oh,lx(80))jY[#jY+1]=gO(lx(1205),og,dl("%.2fg",op),"size20")jY[#jY+1]=gO(lx(695),of,"BRK TIME","")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(695),oh,lx(-80))jY[#jY+1]=gO(lx(615),og,dl("%s",iK(on)),"txtstart size20")jY[#jY+1]=gO(lx(635),ly(45),"TRIP","")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(635),ly(31),lx(-90))if lu then jY[#jY+1]=gO(lx(545),ly(26),dl("%s",iK(lu)),"txtstart size20")end;jY[#jY+1]=gO(lx(795),of,"BRK DIST","")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(795),oh,lx(-80))jY[#jY+1]=gO(lx(715),og,dl("%s",iJ(om)),"txtstart size20")jY[#jY+1]=gO(lx(1285),ly(45),"MASS","txtstart")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(1285),ly(31),lx(90))jY[#jY+1]=gO(lx(1375),ly(26),dl("%s",ol),"size20")jY[#jY+1]=gO(lx(1220),of,"THRUST","txtstart")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(1220),oh,lx(80))jY[#jY+1]=gO(lx(1300),og,dl("%s",oo),"size20")jY[#jY+1]=gO(jc(960),jd(175),jg,"pbright txtbig txtmid size20")end;jY[#jY+1]="</g>"end;local os=1-(a6*0.05+a7*0.05)function nZ.FuelUsed(ot)local ou;if ot=="atmofueltank"then ou=dl("Atmo Fuel Used: %.1f L",jz[ot]/(4*os))elseif ot=="spacefueltank"then ou=dl("Space Fuel Used: %.1f L",jz[ot]/(6*os))else ou=dl("Rocket Fuel Used: %.1f L",jz[ot]/(0.8*os))end;return ou end;local ov,ow,ox,oy,oz=0,0,0,{},0;function nZ.DrawOdometer(jY,j6,bn,j7)if bJ~="INFO"then return jY end;local od;local oj=0;local ok=0;local oe=0;local ol=ci>1000000 and fW(ci/1000000,2).." kTons"or fW(ci/1000,2).." Tons"if cf then oe=bu else oe=bs end;local om,on=cq.computeDistanceAndTime(cM,0,ci,0,0,oe)oe=fW(oe/(ci*iN),2).." g"local oo=d:maxForceForward()od=b.getGravityIntensity()if od>0.1 then ok=ci*od;ok=fW(ok/(ci*iN),2).." g"oj=0.5*oo/od;oj=oj>1000000 and fW(oj/1000000,2).." kTons"or fW(oj/1000,2).." Tons"end;oo=fW(oo/(ci*iN),2).." g"if iE()==0 or l then local oA=jc(aB+10)local oB=jd(aC+20)local oC=jc(aB+10+aA/1.25)local ni=25;local oD=bM(1/aT)if ox<oD then oz=oz+a.getActionUpdateDeltaTime()ox=ox+1 else ov=1/(oz/oD)table.insert(oy,ov)ox,oz=0,0 end;ow=0;for dM,dy in pairs(oy)do ow=ow+dy end;if#oy>0 then ow=bM(ow/#oy)end;if#oy>29 then table.remove(oy,1)end;jY[#jY+1]="<g class='txtstart size14 bright'>"jY[#jY+1]=gO(oA,oB,dl("BrkTime: %s",iK(on)))jY[#jY+1]=gO(oC,oB,dl("Trip: %.2f km",j6))jY[#jY+1]=gO(oA,oB+ni,dl("Lifetime: %.2f kSU",bn/200000))jY[#jY+1]=gO(oC,oB+ni,dl("BrkDist: %s",iJ(om)))jY[#jY+1]=gO(oA,oB+ni*2,"Trip Time: "..iK(j7))jY[#jY+1]=gO(oC,oB+ni*2,"Total Time: "..iK(bo))jY[#jY+1]=gO(oA,oB+ni*3,dl("Mass: %s",ol))jY[#jY+1]=gO(oC,oB+ni*3,dl("Max Brake: %s",oe))jY[#jY+1]=gO(oA,oB+ni*4,dl("Max Thrust: %s",oo))if od>0.1 then jY[#jY+1]=gO(oC,oB+ni*4,dl("Max Thrust Mass: %s",oj))jY[#jY+1]=gO(oA,oB+ni*5,dl("Req Thrust: %s",ok))else jY[#jY+1]=gO(oC,oB+ni*4,"Max Mass: n/a")jY[#jY+1]=gO(oA,oB+ni*5,"Req Thrust: n/a")end;jY[#jY+1]=gO(oC,oB+ni*5,cs.FuelUsed("atmofueltank"))jY[#jY+1]=gO(oA,oB+ni*6,cs.FuelUsed("spacefueltank"))jY[#jY+1]=gO(oC,oB+ni*6,cs.FuelUsed("rocketfueltank"))jY[#jY+1]=gO(oA,oB+ni*7,dl("Set Max Speed: %s",bM(ab*3.6+0.5)))jY[#jY+1]=gO(oC,oB+ni*7,dl("Actual Max Speed: %s",bM(dg*3.6+0.5)))jY[#jY+1]=gO(oA,oB+ni*8,dl("Friction Burn Speed: %s",bM(bO.getFrictionBurnSpeed()*3.6)))jY[#jY+1]=gO(oC,oB+ni*8,dl("FPS (Avg): %s (%s)",bM(ov),ow))end;jY[#jY+1]="</g></g>"return jY end;function nZ.DrawWarnings(jY)return ld(jY)end;function nZ.DisplayOrbitScreen(jY)return lS(jY)end;function nZ.DisplayMessage(jY,lo)if lo~="empty"then local hC=310;for lr in string.gmatch(lo,"([^\n]+)")do hC=hC+35;jY[#jY+1]=gO("50%",hC,lr,"msg")end end;if c3~=0 then c.setTimer("msgTick",c3)c3=0 end end;function nZ.DrawDeadZone(jY)jY[#jY+1]=dl([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;function nZ.UpdatePipe()if cf then iX=""return end;n7()end;function nZ.DrawSettings(jY)local hB=jc(640)local hC=jd(200)jY[#jY+1]=[[<g class="pbright txtvspd txtstart">]]local hX=0;for dM,dy in pairs(iW)do hX=hX+1;jY[#jY+1]=gO(hB,hC,dM..": "..dy.get())hC=hC+20;if hX%12==0 then hB=hB+jc(350)hC=jd(200)end end;jY[#jY+1]=gO(jc(640),jd(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jY[#jY+1]="</g>"return jY end;local id=jd(125)local ic=jc(1225)function nZ.DrawRadarInfo()ie=cv.GetRadarHud(ic,id,ax,ay)end;function nZ.DrawTanks()if at~=0 and au~=0 then jh=gO(at,au,"","txtstart pdim txtfuel")jA=au;jB(at,"Atmospheric ","ATMO",cm,jx,jy)jB(at,"Space Fuel T","SPACE",cn,jv,jw)jB(at,"Rocket Fuel ","ROCKET",co,jt,ju)end end;function nZ.DrawShield()local io=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oE=bO.getPvPTimer()local oF=shield.getResistances()local oG="A: "..10+oF[1]*100 .."% / E: "..10+oF[2]*100 .."% / K:"..10+oF[3]*100 .."% / T: "..10+oF[4]*100 .."%"local hB,hC=av-60,aw+30;local jQ=bM(dh*2.55)local jR=dl("rgb(%d,%d,%d)",255-jQ,jQ,0)local jS=""ji=gO(hB,hC,"","txtmid pdim txtfuel")if dh<10 and io~="Shield Disabled"then jS="red "end;oE=oE>0 and"   PvPTime: "..iK(oE)or""ji=ji..dl([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hB,hC,jR,dh*2,hB,hC,hB+2,hC+10,dh,oE)ji=ji..gO(hB,hC-5,io,jS.."txtstart pbright txtbig")ji=ji..gO(hB,hC+30,oG,jS.."txtstart pbright txtsmall")end;function nZ.hudtick()if not kA then return end;local function oH(jY)local jU=bM(dm(de/(ck/4)*255,0,255))jY[#jY+1]=dl("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c8,c9,bM(j1+0.5)+jU,bM(j2+0.5)-jU,bM(j3+0.5)-jU)end;local function oI()if c1 then for dR,dy in pairs(iO)do if dy.hovered then if not dy.drawCondition or dy.drawCondition(dy)then dy.toggleFunction(dy)end;dy.hovered=false end end;for dR,dy in pairs(iR)do if dy.hovered then bJ=dy.label;dy.hovered=false end end;c1=false end end;local function oJ()local function oK(oL,oM,hB,hC,nh,ni)if oL>=hB and oL<=hB+nh and oM>=hC and oM<=hC+ni then return true else return false end end;local hB=c8+ck/2;local hC=c9+cl/2;for dR,dy in pairs(iO)do dy.hovered=oK(hB,hC,dy.x,dy.y,dy.width,dy.height)end;for dR,dy in pairs(iR)do dy.hovered=oK(hB,hC,dy.x,dy.y,dy.width,dy.height)end;if d1 then local mX=false;for dR,eE in ipairs(nV)do if eE.hovered then mX=true;break end end;if nS.hovered then mX=true end;d1=mX else d1=nS.hovered;if not d1 then d2=bl end end end;local function oN(jY)if not bJ or bJ==""then bJ="HELP"end;if w then for dM,dy in pairs(iR)do local jS="dim brightstroke"local oO=0.2;if bJ==dM then jS="pbright dimstroke"oO=0.6 end;local oP=""if dy.hovered then oO=0.8;oP=";stroke:white"end;jY[#jY+1]=dl([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dy.width,dy.height,dy.x,dy.y,jS,oO,oP)jY[#jY+1]=gO(dy.x+dy.width/2,dy.y+dy.height/2+5,dy.label,"txt txtmid pdim")end end end;local function oQ(jY)local function oR(jY,oS,hover,hB,hC,fj,oT,oU,oV,oW,oX,nW)if type(oW)=="function"then oW=oW(nW)end;if type(oX)=="function"then oX=oX(nW)end;jY[#jY+1]=dl("<rect x='%f' y='%f' width='%f' height='%f' fill='",hB,hC,fj,oT)if oS then jY[#jY+1]=dl("%s'",oU)else jY[#jY+1]=oV end;if hover then jY[#jY+1]=dl(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else jY[#jY+1]=dl(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fW(af*0.5,0),fW(ag*0.5,0),fW(ah*0.5,0))end;jY[#jY+1]=" rx='5'></rect>"jY[#jY+1]=dl("<text x='%f' y='%f' font-size='24' fill='",hB+fj/2,hC+oT/2+5)if oS then jY[#jY+1]="black"else jY[#jY+1]="white"end;jY[#jY+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oS then jY[#jY+1]=dl("%s</text>",oW)else jY[#jY+1]=dl("%s</text>",oX)end end;local oY=dl("rgb(%d,%d,%d)'",fW(af*0.1,0),fW(ag*0.1,0),fW(ah*0.1,0))local oZ=dl("rgb(%d,%d,%d)",fW(af*0.8,0),fW(ag*0.8,0),fW(ah*0.8,0))local o_=oR;for dR,dy in pairs(iO)do local nm=dy.disableName;local nl=dy.enableName;if type(nm)=="function"then nm=nm(dy)end;if type(nl)=="function"then nl=nl(dy)end;if not dy.drawCondition or dy.drawCondition(dy)then o_(jY,dy.toggleVar(dy),dy.hovered,dy.x,dy.y,dy.width,dy.height,oZ,oY,nm,nl,dy)end end end;local p0=fW(ck/2,0)local p1=fW(cl/2,0)local jY={}if p2 then jY[#jY+1]=p2 end;cs.HUDPrologue(jY)if w then cs.UpdateHud(jY)else if A then cs.DrawVerticalSpeed(jY,ch)end;cs.DrawWarnings(jY)end;if iV and iW~="none"then cs.DrawSettings(jY)end;if cv then cs.DrawRadarInfo()else ie=""end;cs.HUDEpilogue(jY)jY[#jY+1]=dl([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ck,cl)if c2~="empty"then cs.DisplayMessage(jY,c2)end;if iE()==0 and g=="virtual joystick"then if v then cs.DrawDeadZone(jY)end end;oN(jY)if iG()==0 then if iE()==1 and c0 then if not p3 then oJ()oQ(jY)end;if not cy and not cz then local p4=table.concat(jY,"")jY={}jY[#jY+1]=dl("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ck,cl)jY[#jY+1]=p4;jY[#jY+1]="</body>"cy=true;jY[#jY+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cz then local p4=table.concat(jY,"")jY={}jY[#jY+1]=dl("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ck,cl)jY[#jY+1]=p4;jY[#jY+1]="</body>"end;if not cy then jY[#jY+1]=dl([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p0,p1,c8,c9)end else oI()end else if not c0 and iE()==0 then oI()if de>az then if v then oH(jY)end end elseif c0 and(not p3 or not i)then oJ()oQ(jY)end;jY[#jY+1]=dl([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p0,p1,c8,c9)end;jY[#jY+1]=[[</svg></body>]]p5=table.concat(jY,"")end;function nZ.TenthTick()local function p6()local p7=a.createData;local p8=a.createWidget;p9=a.createWidgetPanel("Interplanetary Helper")pa=p8(p9,"value")pb=p7('{"label": "Target Planet", "value": "N/A", "unit":""}')fU(pb,pa)pc=p8(p9,"value")pd=p7('{"label": "distance", "value": "N/A", "unit":""}')fU(pd,pc)gn=p8(p9,"value")gm=p7('{"label": "Travel Time", "value": "N/A", "unit":""}')fU(gm,gn)gl=p8(p9,"value")gk=p7('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fU(gk,gl)gp=p8(p9,"value")go=p7('{"label": "Target Altitude", "value": "N/A", "unit":""}')fU(go,gp)gh=p8(p9,"value")gg=p7('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gf=p8(p9,"value")ge=p7('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gd=p8(p9,"value")gc=p7('{"label": "Max Brake distance", "value": "N/A", "unit":""}')gb=p8(p9,"value")ga=p7('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gj=p8(p9,"value")gi=p7('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cf then fU(gg,gh)fU(ge,gf)fU(gc,gd)fU(ga,gb)fU(gi,gj)end end;local function pe()gN(p9)p9=nil end;cs.DrawTanks()if shield then cs.DrawShield()end;if bj~="None"then if p9==nil then p6()end;if bj~=nil then local my;local pf=g6~=nil;local pg=0.5*bu/c7:getGravity(c7.center+vec3(0,0,1)*c7.radius):len()pg=pg>1000000 and fW(pg/1000000,2).." kTons"or fW(pg/1000,2).." Tons"fT(pb,'{"label": "Target", "value": "'..bj..'", "unit":""}')if pf and not b3 then my=(cP-g6.position):len()else my=(bk-cP):len()end;if not b4 then c5,c6=cu.GetAutopilotBrakeDistanceAndTime(cM)iZ,i_=cu.GetAutopilotBrakeDistanceAndTime(ab)else c5,c6=cu.GetAutopilotTBBrakeDistanceAndTime(cM)iZ,i_=cu.GetAutopilotTBBrakeDistanceAndTime(ab)end;local lo=iJ(my)fT(pd,'{"label": "distance", "value": "'..lo..'"}')fT(gm,'{"label": "Travel Time", "value": "'..iK(lu)..'", "unit":""}')lo=iJ(c5)fT(gg,'{"label": "Cur Brake distance", "value": "'..lo..'"}')fT(ge,'{"label": "Cur Brake Time", "value": "'..iK(c6)..'", "unit":""}')lo=iJ(iZ)fT(gc,'{"label": "Max Brake distance", "value": "'..lo..'"}')fT(ga,'{"label": "Max Brake Time", "value": "'..iK(i_)..'", "unit":""}')fT(gk,'{"label": "Max Brake Mass", "value": "'..dl("%s",pg)..'", "unit":""}')lo=iJ(gq)fT(go,'{"label": "Target Orbit", "value": "'..lo..'"}')if cf and not ph then a.removeDataFromWidget(ga,gb)a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)a.removeDataFromWidget(gi,gj)ph=true;if not cS and t and(b5 or b8 or cd)then cu.cmdThrottle(1)b0=false;bU=false end end;if not cf and ph then if fT(ga,gb)==1 then fU(ga,gb)end;if fT(gc,gd)==1 then fU(gc,gd)end;if fT(ge,gf)==1 then fU(ge,gf)end;if fT(gg,gh)==1 then fU(gg,gh)end;if fT(gi,gj)==1 then fU(gi,gj)end;ph=false end end else pe()end;if warpdrive~=nil then local pi=iC(warpdrive.getWidgetData())if pi.destination~="Unknown"and pi.distance>400000 then if not jb then warpdrive.showWidget()jb=true end elseif jb then warpdrive.hideWidget()jb=false end end end;function nZ.OneSecondTick()local function pj()local jL=bL()local l9=cM;local pk=jL-j9;if l9>1.38889 then l9=l9/1000;local pl=l9*(jL-j9)bn=bn+pl;j6=j6+pl end;j7=j7+pk;bo=bo+pk;j9=jL end;local function pm(jY)local pn=0;local po=iM;local pp=0;local pq=0;local pr=0;local jQ=0;local jR=""local ps=b.getElementHitPointsById;local pt=b.getElementMaxHitPointsById;local pu={}for dM in pairs(iL)do local pv=0;local pw=0;pw=pt(iL[dM])pv=ps(iL[dM])pp=pp+pv;if pv+1<pw then if pv==0 then pr=pr+1 else pq=pq+1 end;if ja and#pu==0 then fY=vec3(b.getElementPositionById(iL[dM]))local hB=fY.x;local hC=fY.y;local hD=fY.z;table.insert(pu,b.spawnArrowSticker(hB,hC,hD+1,"down"))table.insert(pu,b.spawnArrowSticker(hB,hC,hD+1,"down"))b.rotateSticker(pu[2],0,0,90)table.insert(pu,b.spawnArrowSticker(hB+1,hC,hD,"north"))table.insert(pu,b.spawnArrowSticker(hB+1,hC,hD,"north"))b.rotateSticker(pu[4],90,90,0)table.insert(pu,b.spawnArrowSticker(hB-1,hC,hD,"south"))table.insert(pu,b.spawnArrowSticker(hB-1,hC,hD,"south"))b.rotateSticker(pu[6],90,-90,0)table.insert(pu,b.spawnArrowSticker(hB,hC-1,hD,"east"))table.insert(pu,b.spawnArrowSticker(hB,hC-1,hD,"east"))b.rotateSticker(pu[8],90,0,90)table.insert(pu,b.spawnArrowSticker(hB,hC+1,hD,"west"))table.insert(pu,b.spawnArrowSticker(hB,hC+1,hD,"west"))b.rotateSticker(pu[10],-90,0,90)table.insert(pu,iL[dM])end elseif ja and#pu>0 and pu[11]==iL[dM]then for jK in pairs(pu)do b.deleteSticker(pu[jK])end;pu={}end end;pn=fW(pp/po*100,2)if pr>0 or pq>0 then jY[#jY+1]=gO(0,0,"","pbright txt")jQ=bM(pn*2.55)jR=dl("rgb(%d,%d,%d)",255-jQ,jQ,0)jY[#jY+1]=gO("50%",1035,"Elemental Integrity: "..pn.."%","txtbig txtmid","fill:"..jR)if pr>0 then jY[#jY+1]=gO("50%",1055,"Disabled Modules: "..pr.." Damaged Modules: "..pq,"txtbig txtmid","fill:"..jR)elseif pq>0 then jY[#jY+1]=gO("50%",1055,"Damaged Modules: "..pq,"txtbig txtmid","fill:"..jR)end end end;local function px()if iB then if j0==nil and(hf~=nil or bm)then _autoconf.displayCategoryPanel(iB,weapon_size,"Weapons","weapon",true)j0=_autoconf.panels[_autoconf.panels_size]elseif j0~=nil and hf==nil and not bm then gN(j0)j0=nil end end end;d3=bO.getPlayersOnBoard()d4=bO.getDockedConstructs()local jY={}pj()if s then pm(jY)end;px()cs.UpdatePipe()cs.ExtraData(jY)j8=table.concat(jY,"")end;function nZ.AnimateTick()cz=true;cy=false;c8=0;c9=0;c.stopTimer("animateTick")end;function nZ.MsgTick()local jY={}cs.DisplayMessage(jY,"empty")c2="empty"c.stopTimer("msgTick")c3=3 end;function nZ.ButtonSetup()nx()nD()iO=iP end;if py then for dM,dy in pairs(py)do nZ[dM]=dy end end;return nZ end;local function pz(d,b,c,e,vBooster,hover,pA,antigrav,dbHud_1,e_,bM,bN,iE,eV,bL,dm,iF,fT,iG,dp,fW,fV,iH,dq,iJ,iK,pB,iC)local a=DUSystem;local bO=DUConstruct;local pC={}local pD=false;local pE=0;local pF=0;local pG=0;local pH=bL()local pI=0;local pJ=0;local pK=0;local pL=0;local pM=false;local pN=false;local pO=false;local pP=nil;local pQ=0;local iY=55;local pR=nil;local pS=false;local pT=false;local pU=false;local pV=0;local pW=0;local pX=0;local pY=0;local pZ=0;local p_={VectorToTarget=false}local q0=vec3(bO.getWorldOrientationUp())local q1=nil;local q2=0;local q3=-1;local q4=-1;local q5=false;local q6=false;local q7=0;local q8=false;local q9=false;local qa=false;local qb=false;local qc=""local qd=false;local qe=false;local qf=""local qg=false;local qh=0;local function qi()return bO.isInPvPZone()~=1,e_(bO.getDistanceToSafeZone())end;local function qj(fq)local qk=bf;if not b3 then qk=0 end;local ql=bs;if cf then if bu and bu>0 then ql=bu else return 0,0 end end;return cq.computeDistanceAndTime(fq,qk,ci,0,0,ql-bh*ci)end;local function qm(fq)local qk=bf;if not b3 then qk=0 end;return cq.computeDistanceAndTime(fq,qk,ci,d:maxForceForward(),a2,bs-bh*ci)end;local function qn(qo,qp,qq)qp=qp:project_on_plane(qo)qq=qq:project_on_plane(qo)return eV(qp:cross(qq):dot(qo),qp:dot(qq))end;local function qr()local function qs()local qt=-1;local qu=-1;if vBooster then qt=vBooster.getDistance()end;if hover then qu=hover.getDistance()end;if qt~=-1 and qu~=-1 then if qt<qu then return qt else return qu end elseif qt~=-1 then return qt elseif qu~=-1 then return qu else return-1 end end;local qv=qs()local qw=-1;if antigrav and antigrav.isActive()==1 and not q and cM<iY then local qx=e_(ch-antigrav.getBaseAltitude())if qx<50 then return qx end end;if pA then qw=pA.raycast().distance end;if qv~=-1 and qw~=-1 then if qv<qw then return qv else return qw end elseif qv~=-1 then return qv else return qw end end;local function qy(kA,eM,qz)local function qA(qB,dY)local eS=vec3(dY)if qB.id==0 then return setmetatable({latitude=eS.x,longitude=eS.y,altitude=eS.z,id=0,systemId=qB.systemId},d_)end;local eT=eS-qB.center;local ca=eT:len()local e4=ca-qB.radius;local e2=0;local e3=0;if not dq(ca,0)then local eU=eV(eT.y,eT.x)e3=eU>=0 and eU or 2*math.pi+eU;e2=math.pi/2-math.acos(eT.z/ca)end;return setmetatable({latitude=math.deg(e2),longitude=math.deg(e3),altitude=e4,id=qB.id,systemId=qB.systemId},d_)end;local qC=qA(kA,eM)qC="::pos{"..qC.systemId..","..qC.id..","..qC.latitude..","..qC.longitude..","..qC.altitude.."}"if qz then return qC else qa=qC;return true end end;local function qD(qE,qF,qG)local function qH(qE,ev)qE=vec3(qE)ev=vec3(ev):normalize()local dH=qE*ev;return dH.x+dH.y+dH.z end;local qI=0.001;local qJ=1;if not cf or not cB or ce~=-1 or cM<iY then if qG==nil then qG=aS end;if qF==nil then qF=qI end;qE=vec3(qE):normalize()local qK=vec3()-qE;local qL=-qH(qK,bO.getWorldOrientationRight())*qJ;local qM=-qH(qK,bO.getWorldOrientationUp())*qJ;if pF==0 then pF=qL/2 end;if pG==0 then pG=qM/2 end;if e_(qL)<0.1 then pW=pW-qL*2 else pW=pW-(qL+(qL-pF)*qG)end;if e_(qM)<0.1 then pV=pV+qM*2 else pV=pV+qM+(qM-pG)*qG end;pF=qL;pG=qM;if e_(qL)<qF and e_(qM)<qF then return true end;return false elseif cB and ce==-1 then qE=cL;if qG==nil then qG=aS end;if qF==nil then qF=qI end;qE=vec3(qE):normalize()local qK=cI-qE;local qL=-qH(qK,bO.getWorldOrientationRight())*qJ;local qM=-qH(qK,bO.getWorldOrientationUp())*qJ;if pF==0 then pF=qL/2 end;if pG==0 then pG=qM/2 end;if e_(qL)<0.1 then pW=pW-qL*5 else pW=pW-(qL+(qL-pF)*qG)end;if e_(qM)<0.1 then pV=pV+qM*5 else pV=pV+qM+(qM-pG)*qG end;pF=qL;pG=qM;if e_(qL)<qF and e_(qM)<qF then return true end;return false end end;function pC.clearAll()bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"b1=false;b2=false;cY=nil;b5=false;b8=false;b6=false;b7=false;b9=false;b_=false;pT=false;cb=false;cc=false;pU=false;cA=p;bq=false;b4=false;cj=false;bt=nil;bz=false;dc=false;dd=nil end;function pC.GetAutopilotBrakeDistanceAndTime(fq)return qj(fq)end;function pC.GetAutopilotTBBrakeDistanceAndTime(fq)return qm(fq)end;function pC.showWayPoint(kA,eM,qz)return qy(kA,eM,qz)end;function pC.APTick()local qN=a.getMouseWheel()if qN>0 then cu.changeSpd()elseif qN<0 then cu.changeSpd(true)else pS=true end;q7=iG()if qa then a.setWaypoint(qa)qa=false end;if qd then antigrav.setTargetAltitude(qd)qd=false end;if qb then fT(qb,qc)qb=false;qc=""end;if q4~=-1 then cu.cmdCruise(q4,q5)q5=false;q4=-1 end;if q1~=nil then if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iF:getTargetSpeed(axisCommandId.longitudinal)~=q1 then iF:setTargetSpeedCommand(axisCommandId.longitudinal,q1)else q1=nil end end;if q3~=-1 then cu.cmdThrottle(q3,q5)q5=false;q3=-1 end;if q6 then cw.landingGear()q6=false end;if qe then cu.ToggleAutopilot()end end;function pC.ToggleIntoOrbit()cF=false;pK=nil;pL=nil;pQ=0;if not cf then if bz then fV("orOff","AP")bz=false;pM=false;pP=nil;cA=p;if b5 then b5=false;b7=false end;p_.VectorToTarget=false;p_.AutopilotAlign=false;pO=false elseif cZ then fV("orOn","AP")bz=true;cA=true;if pP==nil then pP=kA end;if b5 then b5=false;b7=false end else c2="Unable to engage auto-orbit, not near a planet"end else bz=false;pM=false;pP=nil;cA=p;if b5 then b5=false end;p_.VectorToTarget=false;p_.AutopilotAlign=false;pO=false end end;function pC.ToggleVerticalTakeoff()b5=false;if b9 then lq=true;b8=false;b7=false;b6=true;cA=true;bZ=0;if cf and ce==-1 then b6=false;b5=true;bZ=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q4=bM(cC)end else cF=false;bm=false;d.control.retractLandingGears()iF:setTargetGroundAltitude(Z)b0="VTO Takeoff"end;b9=not b9 end;function pC.checkLOS(qE)local ls,eK,eL=cp:getPlanetarySystem(0):castIntersections(cP,qE,function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)local lt=eK;if eL~=nil and eK~=nil then lt=math.min(eL,eK)end;if lt~=nil then return ls,lt else return nil,nil end end;function pC.ToggleAutopilot()local function qO(bx)c_=false;bq=not bq;if bq then b4=false;if not b5 and not bx then cu.ToggleAltitudeHold()end end;lw="Proceeding to Waypoint"end;local function qP(gz)if gz then for M,dM in pairs(cV)do if dM.name and dM.name==gz then return M end end else return 0 end end;local qQ=false;bH=false;if bP-pJ<1.5 and cf then if not cH then if cf then ba=kA.spaceEngineMinAltitude-0.01*kA.noAtmosphericDensityAltitude;fV("11","EP")pJ=-1;if b3 or bq or bz then return end else c2="No space engines detected, Orbital Hop not supported"return end elseif kA.hasAtmosphere then if cf then ba=kA.noAtmosphericDensityAltitude+V;fV("orH","OH")end;pJ=-1;if b3 or bq or bz then return end end else pJ=bP end;qR=false;if(bl>0 or#bF>0)and not b3 and not bq and not cc and not bz then if 0.5*d:maxForceForward()/b.getGravityIntensity()<ci then c2="WARNING: Heavy Loads may affect autopilot performance."c3=5 end;if#bF>0 and not cd then bl=qP(bF[1])ct.UpdateAutopilotTarget()c2="Route Autopilot in Progress"local qK=g6.position-cP;local qS=qK:project_on_plane(cN):len()if qS>50000 and g6.planetname==kA.name then qQ=true end end;ct.UpdateAutopilotTarget()cu.showWayPoint(c7,bk)if g6~=nil then if g6.agg and not q and antigrav then if not cR then cu.ToggleAntigrav()end;bv=g6.agg end;bt=nil;bx=g6.planetname=="Space"if bx then fV("apSpc","AP")if cf then cc=true;cu.ToggleAltitudeHold()else b3=true end elseif kA.name==g6.planetname then lq=true;if cf then if not bq then fV("vtt","AP")qO(bx)if qQ then ba=kA.noAtmosphericDensityAltitude+V end end else fV("apOn","AP")if not(c7.name==kA.name and ch<gq*1.5)then cF=false;b3=true elseif not cf then if bz then cu.ToggleIntoOrbit()end;cE=kA.noAtmosphericDensityAltitude+V;pO=true;p_.AutopilotAlign=true;p_.VectorToTarget=true;pM=false;if not bz then cu.ToggleIntoOrbit()end end end else fV("apP","AP")b1=false;b2=false;if cf then cc=true;cu.ToggleAltitudeHold()else b3=true end end elseif not cf then if g6==nil and(c7.name==kA.name and cZ)and not bz then qT=false;cF=false;pM=false;cu.ToggleIntoOrbit()else fV("apP","AP")b3=true;b1=false;b2=false;bc=false;b_=false;b5=false;b6=false;b8=false;b7=false;pT=false;bt=nil;qT=false end else fV("apP","AP")cc=true;cu.ToggleAltitudeHold()end;qe=false else fV("apOff","AP")cu.ResetAutopilots(1)if qe==2 then qe=true end end end;function pC.routeWP(qU,qV,qW)if qW then if qW==1 then bF={}bF=iH(bF,bE)if#bF>0 then c2="Route Loaded"else c2="No Saved Route found on Databank"end;return bF else bE={}bE=iH(bE,bF)c2="Route Saved"pB()return end end;if qU then return bF end;if qV then bF={}c2="Current Route Cleared"else bF[#bF+1]=g6.name;c2="Added "..g6.name.." to route. "end;return bF end;function pC.cmdThrottle(dN,qX)if iF:getAxisCommandType(0)~=axisCommandType.byThrottle and not qX then d.control.cancelCurrentControlMasterMode()end;iF:setThrottleCommand(axisCommandId.longitudinal,dN)bQ=dm(fW(dN*100,0)/100,-1,1)q1=nil end;function pC.cmdCruise(dN,qX)if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not qX then d.control.cancelCurrentControlMasterMode()end;iF:setTargetSpeedCommand(axisCommandId.longitudinal,dN)q1=dN end;function pC.ToggleLockPitch()if bt==nil then fV("lkPOn","LP")if not c0 then bt=cT else bt=S end;b7=false;b5=false;b6=false else fV("lkPOff","LP")bt=nil end end;function pC.ToggleAltitudeHold()if bP-pI<1.5 then bH=false;if kA.hasAtmosphere then if cf then ba=kA.spaceEngineMinAltitude-0.01*kA.noAtmosphericDensityAltitude;fV("11","EP")else if cZ then ba=kA.noAtmosphericDensityAltitude+V;cE=ba;pO=true;if not bz then cu.ToggleIntoOrbit()end;pM=true end end;pI=-1;if b5 or bz or b9 then return end end else pI=bP end;if cZ and not cf then cE=ch;pO=true;pM=true;cu.ToggleIntoOrbit()if bz then pI=bP else pI=0 end;return end;b5=not b5;b6=false;b8=false;if b5 then b3=false;b2=false;b1=false;b_=false;cA=true;bt=nil;cF=false;if ce~=-1 then if not bm and not bq then ba=ch;bH=ce;iF:setTargetGroundAltitude(bH)elseif cM<20 then if bm then cw.landingGear()end;fV("lfs","LS")b7=true;if pI>-1 then ba=ch+Y end;b0="ATO Hold"iF:setTargetGroundAltitude(Z)if a_ and cQ then cu.ToggleVerticalTakeoff()end end else fV("altOn","AH")b7=false;if pI>-1 then if cZ then ba=ch end end;if b9 then cu.ToggleVerticalTakeoff()end end;if cR and not q then local qY=antigrav.getBaseAltitude()if bq and g6.agg and g6.agg>ch then ba=g6.agg elseif b7 then ba=qY end;if e_(ch-qY)<100 and cM<20 then ba=qY;b0="AGG Hold"q3=0 end end;if cc then ba=200000 end else fV("altOff","AH")if bz then cu.ToggleIntoOrbit()end;if b9 then cu.ToggleVerticalTakeoff()end;cA=p;b7=false;bq=false;pI=0;bH=false end end;function pC.ResetAutopilots(pC)if pC then cc=false;b3=false;bc=false;pT=false;ba=ch;qR=false;dc=false;bg="Aligning"end;bq=false;b7=false;b8=false;b2=false;b6=false;dd=nil;qZ=false;cY=nil;dc=false;if not cR then b5=false;bt=nil end;if b9 then cu.ToggleVerticalTakeoff()end;if bz then cu.ToggleIntoOrbit()end;cA=p;cb=false;cd=false;bZ=0 end;function pC.BrakeToggle(q_)if not b0 then if q_ then b0=q_ else b0=true end else b0=false end;if b6 then b6=false;cA=p;dc=false end;if b0 then fV("bkOn","B",1)cu.ResetAutopilots()else fV("bkOff","B",1)end end;function pC.BeginReentry()if b8 then c2="Re-Entry cancelled"fV("reOff","RE")b8=false;cA=p;b5=false elseif not kA.hasAtmosphere then c2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c3=5 elseif not pU then b8=true;if iF:getAxisCommandType(0)~=r0.cruise then d.control.cancelCurrentControlMasterMode()end;cA=true;b0=false;c2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cC;fV("par","RE")else b8=true;b5=true;cA=true;b0=false;ba=kA.surfaceMaxAltitude+a0;if ba>kA.spaceEngineMinAltitude then ba=kA.spaceEngineMinAltitude-0.01*kA.noAtmosphericDensityAltitude end;local r1=iJ(ba)c2="Beginning Re-entry.  Target speed: "..cC.." Target Altitude: "..r1;fV("glide","RE")q4=bM(cC)end;b7=false end;function pC.ToggleAntigrav()if antigrav and not q then if cR then fV("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bv==nil then bv=ch end;if bv<1000 then bv=1000 end;fV("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pC.changeSpd(r2)local r3=1;if r2 then r3=-1 end;if not c0 then if t and not p3 and pS then local r4=bQ;bQ=fW(dm(bQ+r3*aE/100,-1,1),2)if bQ>=0 and r4<0 then bQ=0;pS=false end elseif p3 then if cf or b8 then cC=dm(cC+r3*aE,0,W)elseif b3 then ab=dm(ab+r3*aE/3.6*100,0,dg-0.2)end else iF:updateCommandFromActionStart(axisCommandId.longitudinal,r3*aE/10)end else if b3 or bq or cc or bz then d2=d2+1*r3*-1;if d2>#cV then d2=1 end;if d2<1 then d2=#cV end else if not r2 then r3=1 else r3=nil end;ct.adjustAutopilotTargetIndex(r3)end end end;function pC.TenthTick()local function r5()if not b3 then if g6==nil or g6.planetname~=kA.name then r6=(c7.center-cP):len()else r6=(g6.position-cP):len()end end;local fq=cM;local r7=c.getThrottle()/100;if t then r7=bQ end;local r8,r9=cq.computeDistanceAndTime(cM,ab,ci,d:maxForceForward()*r7,a2,0)local c5,c6;if not b4 then c5,c6=cu.GetAutopilotBrakeDistanceAndTime(ab)else c5,c6=cu.GetAutopilotTBBrakeDistanceAndTime(ab)end;local dR,ra;if not b4 and fq>0 then dR,ra=cu.GetAutopilotBrakeDistanceAndTime(fq)else dR,ra=cu.GetAutopilotTBBrakeDistanceAndTime(fq)end;local rb=0;local rc=0;if be or not b3 and fq>5 then rc=cq.computeTravelTime(fq,0,r6)elseif c5+r8<r6 then rb=r6-(c5+r8)rc=cq.computeTravelTime(8333.0556,0,rb)else local rd=(r6-c5)/r8;r8=r6-c5;r9=r9*rd end;if g6~=nil and g6.planetname==kA.name and not b3 then return rc elseif bd then return ra elseif be then return rc+ra else return r9+c6+rc end end;local function re(od,rf)if od==nil then od=b.getGravityIntensity()end;od=fW(od,5)if rf~=nil and rf or(pR==nil or pR~=od)then local fq=cK:len()local rg=iC(c.getWidgetData()).maxBrake;if rg~=nil and rg>0 and cf then rg=rg/dm(fq/100,0.1,1)rg=rg/cg;if cg>0.10 then if bu then bu=(bu+rg)/2 else bu=rg end end end;if rg~=nil and rg>0 then bs=rg end;pR=od end end;cW,cX=qi()dg=bO.getMaxSpeed()if bj~="None"and(c7 or g6)then lu=r5()end;re(nil,true)end;function pC.SatNavTick()if not r then return end;qf=dbHud_1.getStringValue("SPBAutopilotTargetName")if qf~=nil and qf~=""and qf~="SatNavNotChanged"then local dH=iC(dbHud_1.getStringValue("SavedLocations"))if dH~=nil then bp=dH;local gx=-1;local gD;for dM,dy in pairs(bp)do if dy.name and dy.name=="SatNav Location"then gx=dM;break end end;if gx~=-1 then gD=bp[gx]gx=-1;for dM,dy in pairs(e[0])do if dy.name and dy.name=="SatNav Location"then gx=dM;break end end;if gx>-1 then e[0][gx]=gD end;ct.UpdateAtlasLocationsList()c2=gD.name.." position updated"end end;for M=1,#cV do if cV[M].name==qf then bl=M;a.print("Index = "..bl.." "..cV[M].name)ct.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;local function rh(ri,rj)local rk=vec3()local rl=vec3()if ri==axisCommandId.longitudinal then rk=vec3(bO.getOrientationForward())rl=cI elseif ri==axisCommandId.vertical then rk=vec3(bO.getOrientationUp())rl=q0 elseif ri==axisCommandId.lateral then rk=vec3(bO.getOrientationRight())rl=cJ else return vec3()end;local rm=vec3(b.getWorldGravity())local rn=rm:dot(rl)local ro=vec3(bO.getWorldAirFrictionAcceleration())local rp=ro:dot(rl)local rq=cK:dot(rk)local rr=rj*constants.kph2m;if rs==nil then rs=pid.new(10,0,10.0)end;rs:inject(rr-rq)local rt=rs:get()local ru=(rt-rp-rn)*rl;return ru end;local function rv(ri,rj)local rk=vec3()local rl=vec3()if ri==axisCommandId.longitudinal then rk=vec3(bO.getOrientationForward())rl=cI elseif ri==axisCommandId.vertical then rk=vec3(bO.getOrientationUp())rl=q0 elseif ri==axisCommandId.lateral then rk=vec3(bO.getOrientationRight())rl=cJ else return vec3()end;local rm=vec3(b.getWorldGravity())local rn=rm:dot(rl)local ro=vec3(bO.getWorldAirFrictionAcceleration())local rp=ro:dot(rl)local rq=cK:dot(rk)local rr=rj*constants.kph2m;if rw==nil then rw=pid.new(10,0,10.0)end;rw:inject(rr-rq)local rt=rw:get()local ru=(rt-rp-rn)*rl;return ru end;local function rx(ry,k0,g2)local rz=ry:cross(g2):normalize_inplace()local kN=math.acos(dm(rz:dot(-k0),-1,1))*constants.rad2deg;if rz:cross(-k0):dot(g2)<0 then kN=-kN end;return kN end;local function rA()if d0 and not b6 then local et=d0[1]local i3,i4=d0[2],d0[3]local rB=math.min(i3,i4 or i3)local rC=rB/cM;local rD=b7 and(cM<42 or ce~=-1)local rE=b5 or bq or bt or b3;if rE and not rD and(c5*1.5>rB or rC<1)then b0="Collision"bF={}q3=0;if b5 then cu.ToggleAltitudeHold()end;if bt then cu.ToggleLockPitch()end;c2="Autopilot Cancelled due to possible collision"a.print(et.name.." COLLISION "..iK(rC).." / "..iJ(rB,2))cu.ResetAutopilots(1)lq=true;if cf then b6=true end;cA=true end;if rC<11 then c_=et.name.." COLLISION "..iK(rC).." / "..iJ(rB,2)else c_=et.name.." collision "..iK(rC)end;if rC<6 then fV("alarm","AL",2)end else c_=false end end;local rF=1;local rG=0;local rH=1;local rI=1;local rJ=1;function pC.onFlush()if antigrav and not q and not cR and antigrav.getBaseAltitude()~=bv then qd=bv end;if df then d:setEngineForceCommand('hover',vec3(),1)df=false end;cS=iF:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local rK=dm(bW+pV+a.getControlDeviceForwardInput(),-1,1)local rL=dm(bX+pX+a.getControlDeviceYawInput(),-1,1)local rM=dm(bY+pW-a.getControlDeviceLeftRightInput(),-1,1)local rN=b0 and 1 or 0;cN=vec3(b.getWorldVertical())if cN==nil or cN:len()==0 then cN=(kA.center-cP):normalize()end;q0=vec3(bO.getWorldOrientationUp())cI=vec3(bO.getWorldOrientationForward())cJ=vec3(bO.getWorldOrientationRight())cL=vec3(bO.getWorldVelocity())cK=vec3(bO.getVelocity())cP=vec3(bO.getWorldPosition())ci=bO.getMass()cM=vec3(cL):len()cO=-cN:dot(cL)cU=getRoll(cN,cI,cJ)local rO=cU/180*math.pi;local rP=math.cos(rO)local rQ=math.sin(rO)cT=rx(cN,cI,cJ*rP+q0*rQ)local rR=cL:normalize()local rS=e_(cU)local rT=utils.sign(cU)local rU=vec3(bO.getWorldAngularVelocity())local rV=rK*aO*cJ+rL*aJ*cI+rM*aP*q0;if cA==true and cN:len()>0.01 then local rW=e_(pY-cU)if((b2 or b8 or b6 or cb or b5 or bz)and rW>0 or cf and rW<aK and p)and rL==0 and e_(cT)<85 then local rX=pY;local rY=aI;if not cf then rY=rY/4;pY=0;rX=0 end;if rZ==nil then rZ=pid.new(rY*0.01,0,rY*0.1)end;rZ:inject(rX-cU)local r_=rZ:get()rV=rV+r_*cI end end;bR=0;cg=bN()cf=false or ch<kA.noAtmosphericDensityAltitude and cg>0.00001;ch=b.getAltitude()ce=qr()bP=bL()pH=bP;if bm and ce>-1 and ce-3<_ then if iF.targetGroundAltitudeActivated then iF:deactivateGroundEngineAltitudeStabilization()end end;if cv then qg=not qg;if qg then cv.UpdateRadar()end;if E then rA()end end;if antigrav then cR=antigrav.isActive()==1 end;local s0=bP-pH;local s1=-math.deg(qn(q0,cL,cI))local s2=math.deg(qn(cJ,cL,cI))local gs=cN*-1;cB=cf and s1<-N or s1>N or s2<-O or s2>O;local s3=a.getMouseDeltaX()local s4=a.getMouseDeltaY()if qh then local s5=bL()-qh;s3=s3*s5/0.016;s4=s4*s5/0.016 end;qh=bL()if o and not c0 then s4=-s4 end;pW=0;pX=0;pV=0;local s6=bO.getWorldPosition()kA=fZ:closestBody(s6)s7=cr(kA)fu=s7:orbitalParameters(s6,cL)if ch==0 then ch=(cP-kA.center):len()-kA.radius end;cZ=c.getClosestPlanetInfluence()>0 or ch>0 and ch<200000;local od=kA:getGravity(s6):len()*ci;pY=0;local s8=bO.getMaxThrustAlongAxis("ground",bO.getOrientationUp())[1]if q7==0 then if iE()==1 and c0 then if not cy then c8=dm(c8+s3/2,-ck/2,ck/2)c9=dm(c9+s4/2,-cl/2,cl/2)end else c8=0;c9=0 end else c8=dm(c8+s3/2,-ck/2,ck/2)c9=dm(c9+s4/2,-cl/2,cl/2)de=dp(c8*c8+c9*c9)if not c0 and iE()==0 then local kW,kX=1,1;if bJ=="SCOPE"then kW,kX=d6/90,d6/90 end;if g=="virtual joystick"then if de>az then pW=pW-dm(e_(c8)-az,0,ck/2)*utils.sign(c8)*aG*kW;pV=pV-dm(e_(c9)-az,0,cl/2)*utils.sign(c9)*aH*kX end else c8=0;c9=0;if g=="mouse"then pV=(-utils.smoothstep(s4,-100,100)+0.5)*2*rI;pW=(-utils.smoothstep(s3,-100,100)+0.5)*2*rJ end end end end;local s9=cM>27777;if cM>X/3.6 and not cf and not b3 and not s9 then c2="Space Speed Engine Shutoff reached"q3=0 end;if not s9 and sa then if not b0 then cu.BrakeToggle()end;if b3 then cu.ResetAutopilots(1)end;q3=0 end;sa=s9;if cg>0.09 then if cM>cC/3.6 and not t and not pD then b0="SpdLmt"pD=true elseif not t and pD then if cM<cC/3.6 then b0=false;pD=false end end end;if b2 then if cb then b0=false;local sb=false;if g6 and cb==true then sb=qD(g6.position-cP,0.1)else sb=qD(vec3(cL),0.01)end;cA=true;if sb then q4=bM(cC)if(e_(cU)<2 or e_(cT)>85)and cM>=cC/3.6-1 then b0=false;b2=false;if cb~=2 then pU=true end;if cb==true then cd=true end;cb=false;b3=false;cu.BeginReentry()end elseif cf and t then q3=1 end elseif cM>iY then qD(vec3(cL),0.01)end end;if b1 then if cf then b1=false elseif cM>iY then qD(-vec3(cL))end end;if not b2 and cb and not bz then if not cf then if cb~=2 then pU=true end;cu.BeginReentry()cb=false;cd=true else cb=false;if not qe then qe=true end end end;if cd and g6 and(ch<ba+250 and ch>ba-250)and cM*3.6>cC-250 and e_(cO)<25 and cg>=0.1 and(g6.position-cP):len()>2000+ch then if not qe then qe=true end;cd=false end;if b9 then cA=true;local sc=ba;if cO<-30 then c2="Unable to achieve lift. Safety Landing."bZ=0;cA=p;b9=false;b6=true elseif not q and cR or ba<kA.spaceEngineMinAltitude then if cR then sc=antigrav.getBaseAltitude()end;if ch<sc-100 then pZ=0;bZ=15;b0=false elseif cO>0 then b0="VTO Limit"bZ=0 elseif cO<-30 then b0="VTO Fall"bZ=15 elseif ch>=sc then if cR then if b3 or bq then cu.ToggleVerticalTakeoff()else b0="VTO Complete"b9=false end;c2="Takeoff complete. Singularity engaged"fV("aggLk","AG")else b0=false;c2="VTO complete. Engaging Horizontal Flight"fV("vtoc","VT")cu.ToggleVerticalTakeoff()end;bZ=0 end else if cg>0.08 then pZ=0;b0=false;bZ=20 elseif cg<0.08 and cf then b0=false;if cG then pZ=0;bZ=20 else bZ=0;pZ=36;q4=3500 end else cA=p;bz=true;cF=false;sd=false;pM=false;pK=nil;pL=nil;if pP==nil then pP=kA end;cE=sc;pO=true;b9=false end end;if pZ~=nil then if se==nil then se=pid.new(2*0.01,0,2*0.1)end;local sf=dm(pZ-cT,-O*0.80,O*0.80)se:inject(sf)local sg=dm(se:get(),-1,1)pV=sg end end;if bz then local function sh()if fu.periapsis.altitude>=cE*0.99 and fu.apoapsis.altitude>=cE*0.99 and fu.periapsis.altitude<fu.apoapsis.altitude and fu.periapsis.altitude*1.05>=fu.apoapsis.altitude and e_(cE-ch)<1000 then return true else return false end end;local qK;local si=false;local sj=iJ(cE)if pP==nil then pP=kA;if bq then pP=c7 end end;if not pO then cE=bM(pP.radius+pP.surfaceMaxAltitude+V)if pP.hasAtmosphere then cE=bM(pP.radius+pP.noAtmosphericDensityAltitude+V)end;pO=true end;if p_.VectorToTarget and g6 then qK=g6.position-cP end;local sk,sl=cr(pP):escapeAndOrbitalSpeed((cP-pP.center):len()-pP.radius)local sm=cU;if not pM then local sn=false;local so=false;q3=0;pL=0;cD="Aligning to orbital path - OrbitHeight: "..sj;if p_.VectorToTarget then qD(qK:normalize():project_on_plane(cN))si=cI:dot(qK:project_on_plane(q0):normalize())>0.95 else qD(cL)si=s1<0.5;if cM<150 then si=true end end;pV=0;pK=0;if cT<=pK+2 and cT>=pK-2 then sn=true else sn=false end;if sm<=pL+2 and sm>=pL-2 then so=true else so=false end;if sn and so and si then pK=nil;pL=nil;pM=true end else if p_.VectorToTarget then qD(qK:normalize():project_on_plane(cN))elseif cM>150 then qD(cL)end;pV=0;if p_.VectorToTarget and g6 then local c5,dR=cq.computeDistanceAndTime(cM,cC/3.6,ci,0,0,bs)if cF and qK:len()>15000+c5+ch then cD="Orbiting to Target"if ch-100<=pP.noAtmosphericDensityAltitude or lu>fu.timeToPeriapsis and fu.periapsis.altitude<pP.noAtmosphericDensityAltitude or not sh()and fu.eccentricity>0.1 then c2="Re-Aligning Orbit"cF=false end elseif cF or qK:len()<15000+c5+ch then c2="Orbit complete, proceeding with reentry"fV("orCom","OB")bk=g6.position;pU=true;cd=true;p_.VectorToTarget,p_.AutopilotAlign=false,false;cu.ToggleIntoOrbit()cu.BeginReentry()return end end;if fu.periapsis~=nil and fu.apoapsis~=nil and fu.eccentricity<1 and ch>cE*0.9 and ch<cE*1.4 then if fu.apoapsis~=nil then if sh()or cF then if cF then b0=false;q3=0;pK=0;if not p_.VectorToTarget then c2="Orbit complete"fV("orCom","OB")cu.ToggleIntoOrbit()end else pQ=pQ+1;if pQ>=2 then cF=true end end else cD="Adjusting Orbit - OrbitHeight: "..sj;pN=true;q4=sl*3.6+1;local sp=cE-ch;if sq==nil then sq=pid.new(0.1,0,1*0.1)end;sq:inject(sp-cO*dm(utils.smoothstep(2000-sp,-2000,2000)^6*10,1,10))pK=dm(sq:get(),-60,60)end end else local sr=2.75;local ss=e_(fW(sk*sr))local os=ss%50;if os>0 then ss=ss-os+50 end;b0=false;if ch<cE*0.8 then cD="Escaping planet gravity - OrbitHeight: "..sj;pK=utils.map(cO,200,0,-15,80)elseif ch>=cE*0.8 and ch<cE*1.15 then cD="Approaching orbital corridor - OrbitHeight: "..sj;ss=ss*0.75;pK=utils.map(cO,100,-100,-15,65)elseif ch>=cE*1.15 and ch<cE*1.5 then cD="Approaching orbital corridor - OrbitHeight: "..sj;ss=ss*0.75;if cO<0 or pN then pK=utils.map(ch,cE*1.5,cE*1.01,-30,0)else pK=utils.map(ch,cE*0.99,cE*1.5,0,30)end elseif ch>cE*1.5 then cD="Reentering orbital corridor - OrbitHeight: "..sj;pK=-65;local st=utils.map(cO,-150,-400,1,0.55)ss=ss*st end;q4=bM(ss)end end;if pK~=nil then if su==nil then su=pid.new(1*0.01,0,5*0.1)end;local sv=pK-cT;su:inject(sv)local sw=dm(su:get(),-0.5,0.5)pV=sw end end;if b3 and not cf and not cb then local function sx(dj,fu)a.print(dj)b0=false;bd=false;b3=false;qR=false;bg="Aligning"q3=0;pT=false;c2=dj;fV("apCom","AP")if fu or cb then if fu and gq~=nil and not cb then if not ch or ch==0 then return end;cE=ch;pO=true end;cu.ToggleIntoOrbit()end end;local sy,sz=bk,false;if g6 and g6.planetname~="Space"then bc=true;if not qR then local sA=(g6.position-c7.center):normalize()local sB=sA:project_on_plane((c7.center-cP):normalize()):normalize()local sC=c7.center+sB*(c7.radius+gq)local sD=g6.position+(g6.position-c7.center):normalize()*(gq-c7:getAltitude(g6.position))if(cP-sC):len()<(cP-sD):len()then sy=sC else sy=sD;bf=0 end;bk=sy;cu.showWayPoint(c7,bk)sz=true;qR=true end;bh=0 elseif g6 and g6.planetname=="Space"then if not qR then bh=0;sz=true;bc=true;qR=true;sy=g6.position+(cP-g6.position):normalize()*T;bk=sy end elseif g6==nil then bh=0;if not qR then local sA=(cP+cL*100000-c7.center):normalize()local sB=sA:project_on_plane((c7.center-cP):normalize()):normalize()if sB:len()<1 then sA=(cP+cI*100000-c7.center):normalize()sB=sA:project_on_plane((c7.center-cP):normalize()):normalize()end;sy=c7.center+sB*(c7.radius+gq)bk=sy;qR=true;sz=true;bc=true;cu.showWayPoint(c7,bk)end end;r6=(vec3(sy)-cP):len()local ls,eK,eL=cp:getPlanetarySystem(0):castIntersections(cP,cL:normalize(),function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)local lt=eK;if eL~=nil and eK~=nil then lt=math.min(eL,eK)end;if lt~=nil and lt<r6 and ls.name==c7.name then r6=lt end;local sb=true;local sE=(c7.center-(cP+vec3(cL):normalize()*r6)):len()-c7.radius;local lo=iJ(sE)qb=gi;qc='{"label": "Projected Altitude", "value": "'..lo..'"}'if cM>50 and bb then local qK=vec3(sy)-cP;local sF=dm(math.deg(qn(q0,cL:normalize(),qK:normalize()))*cM/500,-90,90)local sG=dm(math.deg(qn(cJ,cL:normalize(),qK:normalize()))*cM/500,-90,90)if e_(sF)<20 and e_(sG)<20 then sF=sF*2;sG=sG*2 end;if e_(sF)<2 and e_(sG)<2 then sF=sF*2;sG=sG*2 end;local s1=-math.deg(qn(q0,cI,cL:normalize()))local s2=-math.deg(qn(cJ,cI,cL:normalize()))if sH==nil then sH=pid.new(2*0.01,0,2*0.1)end;sH:inject(sG-s2)local sI=dm(sH:get(),-1,1)pV=pV+sI;if sJ==nil then sJ=pid.new(2*0.01,0,2*0.1)end;sJ:inject(sF-s1)local sK=dm(sJ:get(),-1,1)pW=pW+sK;sz=true;if e_(sF)>2 or e_(sG)>2 then if bg~="Adjusting Trajectory"then bg="Adjusting Trajectory"fV("apAdj","AP")end else if bg~="Accelerating"then bg="Accelerating"fV("apAcc","AP")end end elseif bb and cM<=50 then qD((sy-cP):normalize())end;if sE<gq*1.5 then bf=cC/3.6;if g6==nil then dR,bf=cr(c7):escapeAndOrbitalSpeed(sE)end end;local c5,c6;if not b4 then c5,c6=qj(cM)else c5,c6=qm(cM)end;if b3 and not bb and not be and not bd then local ls,lt=cu.checkLOS((bk-cP):normalize())if c7.name~=kA.name then if ls~=nil and c7.name~=ls.name and lt<r6 then c2="Collision with "..ls.name.." in "..iJ(lt).."\nClear LOS to continue."c3=5;q8=true else q8=false;c2=""end end end;if not q8 then if not be and not bd and not sz then sb=qD((sy-cP):normalize())elseif b4 and(bd or be)then sb=qD(-vec3(cL):normalize())end end;if bb then if not pT then b0=false;q3=a1;bQ=fW(a1,2)pT=true end;local r7=c.getThrottle()if t then r7=bQ end;local sL=99999;local op=-vec3(bO.getWorldAcceleration()):dot(cL:normalize())local sM=dm(cL:dot((sy-cP):normalize()),0,cM)if sM>0 or op>0 then sL=cq.computeTravelTime(sM,op,r6-c5)end;if ab>dg then ab=dg-0.2 end;if cK:len()>=ab or r7==0 and pT or a2/4>sL then bb=false;if bg~="Cruising"then fV("apCru","AP")bg="Cruising"end;be=true;q3=0 end;local sN=r6;if sN<=c5 or H and cX<=c5+10000 and cW then if H and cX<=c5+10000 and cW then if cX<pE and cX>2000 then cu.ResetAutopilots(1)c2="Autopilot cancelled to prevent crossing PvP Line"b0="PvP Prevent"pE=cX else pE=cX;return end end;bb=false;if bg~="Braking"then fV("apBrk","AP")bg="Braking"end;bd=true;q3=0;pT=false end elseif bd then if bg~="Orbiting to Target"then b0="AP Brk"end;if b4 then q3=1;q5=true end;local dR,sl=cr(c7):escapeAndOrbitalSpeed((cP-kA.center):len()-kA.radius)local qK;if g6 then qK=g6.position-cP end;if g6 and g6.planetname=="Space"and cM<50 then if#bF>0 then if not qe then table.remove(bF,1)end;if#bF>0 then b0=false;if not qe then qe=2 end;return end end;sx("Autopilot complete, arrived at space location")b0="Space Arrival"elseif g6 and g6.planetname~="Space"and cM<=sl and(fu.apoapsis==nil or fu.periapsis==nil or fu.apoapsis.altitude<=0 or fu.periapsis.altitude<=0)then sx("Autopilot complete, commencing reentry")bk=g6.position;cb=true;cu.showWayPoint(c7,bk)elseif(g6 and g6.planetname~="Space"or g6==nil)and fu.periapsis~=nil and fu.periapsis.altitude>0 and fu.eccentricity<1 or bg=="Circularizing"then if bg~="Circularizing"then fV("apCir","AP")bg="Circularizing"end;if cM<=sl then if g6 then if cL:normalize():dot(qK:normalize())>0.4 then if bg~="Orbiting to Target"then fV("apOrb","OB")bg="Orbiting to Target"end;if not qT then b0=false;cu.showWayPoint(c7,g6.position)qT=true end else sx("Autopilot complete, proceeding with reentry")bk=g6.position;cb=true;cu.showWayPoint(c7,g6.position)qT=false end else sx("Autopilot completed, setting orbit",true)b0=false end end elseif bg=="Circularizing"then sx("Autopilot complete, fixing Orbit",true)end elseif be then local sN=r6;if sN<=c5 or H and cX<=c5+10000 and cW then if H and cX<=c5+10000 and cW then if cX<pE and cX>2000 then if not qe then qe=true end;c2="Autopilot cancelled to prevent crossing PvP Line"b0="Prevent PvP"pE=cX else pE=cX;return end end;bb=false;if bg~="Braking"then fV("apBrk","AP")bg="Braking"end;bd=true end;local r7=c.getThrottle()if t then r7=bQ end;if r7>0 then bb=true;if bg~="Accelerating"then bg="Accelerating"fV("apAcc","AP")end;be=false end else if sb then if not bc and g6==nil or not bc and g6 and g6.planetname~="Space"then if not cb then bk=vec3(c7.center)+(gq+c7.radius)*cJ;sO=q0;sP=cJ end;bc=true elseif sb and not q8 then bb=true;if bg~="Accelerating"then bg="Accelerating"fV("apAcc","AP")end;if not pT then q3=a1;q5=true;bQ=fW(a1,2)pT=true;b0=false end end end end elseif b3 and(g6~=nil and g6.planetname~="Space"and cf)then c2="Autopilot complete, starting reentry"fV("apCom","AP")bk=g6.position;b0=false;bd=false;b3=false;qR=false;bg="Aligning"q3=0;pT=false;b2=true;cb=true;cu.showWayPoint(c7,g6.position)end;if b_ then cA=true;local sG=0;local fw=vec3(DUPlayer.getWorldPosition())local sQ=fw-cP;local sR=vec3(sQ):project_on(cI):len()local sS=vec3(sQ):project_on(cJ):len()local ca=dp(sR*sR+sS*sS)qD(sQ:normalize())local my=40;local sT=ca<my;local sU=100;local rj=dm((ca-my)/2,10,sU)pV=0;local sb=e_(pW)<0.1;if sb and cM<rj and not sT then b0=false;sG=-20 else b0="Follow"sG=0 end;local sV=0;if e_(sG-cT)>sV then if sW==nil then sW=pid.new(2*0.01,0,2*0.1)end;sW:inject(sG-cT)local sI=sW:get()pV=sI end end;if b5 or b6 or b8 or bq or bt~=nil then if bH then if ce==-1 then ba=ba-0.2 else ba=ch+bH-ce end end;local sX=bu;if sX then sX=sX*dm(cM/100,0.1,1)*cg else sX=bs end;if not cf then sX=bs end;q2=cI:project_on_plane(cN):normalize():dot(cL)if q2>100 then c5,c6=cq.computeDistanceAndTime(q2,100,ci,0,0,sX)local sY,sZ=cq.computeDistanceAndTime(100,0,ci,0,0,sX*0.55)c5=c5+sY else c5,c6=cq.computeDistanceAndTime(q2,0,ci,0,0,sX*0.55)end;local sp=ba-ch-cO;local s_=200+cM;if b8 or cb then t0=2000+cM end;local t1=1;if b7 then t1=dm(cM/100,0.1,1)end;local sG=(utils.smoothstep(sp,-s_,s_)-0.5)*2*Q*t1;if not b8 and not cb and not bq and cI:dot(cL:normalize())<0.99 then sG=(utils.smoothstep(sp,-s_*dm(20-19*cg*10,1,20),s_*dm(20-19*cg*10,1,20))-0.5)*2*Q*dm(2-cg*10,1,2)*t1 end;if not b5 then sG=0 end;if bt~=nil then if cZ and not bz then sG=bt else bt=nil end end;cA=true;local t2=pV;if b8 then local t3=bM(cC)local t4,t5=cq.computeDistanceAndTime(cM,t3/3.6,ci,0,0,bs-kA.gravity*9.8*ci)t4=t4==-1 and 5000 or t4;local qS=ch-(kA.noAtmosphericDensityAltitude+t4)local t6=ch>kA.noAtmosphericDensityAltitude+t4*1.35;if t6 then sG=R;if cM<=t3/3.6 and cM>t3/3.6-10 and e_(cL:normalize():dot(cI))>0.9 and not cS then bU=false;q3=1 end elseif(cS or iF:getTargetSpeed(axisCommandId.longitudinal)~=t3)and not t6 and not cf then q4=t3;q5=true end;if cS then if cM>t3/3.6 and not t6 then b0="Reentry Limit"if bQ>0 then q3=0 end else b0=false end else b0=false end;if cO>0 then b0="Reentry vSpd"end;if not pU then sG=-80;if ch<kA.surfaceMaxAltitude+(kA.atmosphereThickness-kA.surfaceMaxAltitude)*0.25 then c2="PARACHUTE DEPLOYED at "..fW(ch,0)b8=false;b6=true;lq=true;q3=0;sG=0;cA=p end elseif kA.noAtmosphericDensityAltitude>0 and t6 then cA=true elseif not t6 then if not cf and(cS or iF:getTargetSpeed(axisCommandId.longitudinal)~=t3)then q4=t3 end;if cM<t3/3.6+1 then b0=false;pU=false;b8=false;cA=true;q3=1 end end end;if cM>iY and not cc and not bq and not b6 and u then qD(vec3(cL))end;if cY or(bq or cc)and bl>0 and cf then local qK;if cY then if type(cY)=="table"then qK=cY elseif cY<3 and cY>0 then qK=-cN:cross(cL)*5000 elseif cY>=3 then qK=cN:cross(cL)*5000 elseif cY<0 then qK=cL*25000 end elseif g6~=nil then qK=g6.position-cP else qK=c7.center-cP end;local sF=math.deg(qn(cN:normalize(),cL,qK))*2;local mB=math.rad(e_(cU))if cM>aL and cf then local t7=1000+cM;local t8=(utils.smoothstep(sp-cO*10,-t7,t7)-0.5)*2*Q;local t9=dm(90-t8,0,180)pY=dm(sF*2,-t9,t9)local ta=sF;sF=dm(dm(sF,-N*0.80,N*0.80)*math.cos(mB)+4*(cT-sG)*math.sin(math.rad(cU)),-N*0.80,N*0.80)local tb=1;if pY~=0 then tb=e_(mB/pY)end;tb=(90-dm(e_(pY-cU),0,90))/90;local tc=sG;if e_(cU)>90 then tc=-tc end;sG=tb*dm(dm(tc*math.cos(mB),-O*0.8,O*0.8)+e_(dm(e_(ta)*math.sin(mB),-O*0.80,O*0.80)),-O*0.80,O*0.80)else pY=0;sF=dm(sF,-N*0.80,N*0.80)end;local td=s1-sF;if cY and e_(td)<=0.0001 and(type(cY)=="table"or type(cY)~="table"and cY<0 and e_(cU)<1)then if cY==-2 then cu.ToggleAltitudeHold()end;cY=nil;fV("180Off","BR")return end;if not cB and cM>aL and cf then if te==nil then te=pid.new(2*0.01,0,2*0.1)end;te:inject(td)local sK=dm(te:get(),-1,1)pW=pW+sK elseif cf and ce>-1 or cM<aL then qD(qK)elseif cB and cf then if(s1<-N or s1>N)and cf then qD(cL)end;if(s2<-O or s2>O)and cf then sG=dm(cT-s2,cT-O*0.80,cT+O*0.80)end end;if g6~=nil and not cc then local sc=kA:getAltitude(g6.position)local qS=qK:project_on_plane(cN):len()lq=true;if ba<kA.noAtmosphericDensityAltitude and not cc and not b7 and not b8 and(qS<=c5 and qK:len()<kA.radius)and(cL:project_on_plane(cN):normalize():dot(qK:project_on_plane(cN):normalize())>0.99 or lw=="Finalizing Approach")then lw="Finalizing Approach"if#bF>0 then if not qe then table.remove(bF,1)end;if#bF>0 then if not qe then qe=2 end;return end end;q3=0;if b5 then cu.ToggleAltitudeHold()bq=true end;b0="AP Finalizing"elseif not b7 then b0=false end;if lw=="Finalizing Approach"and(q2<0.1 or qS<0.1 or tf~=nil and tf<qS)then fV("bklOn","BL")b6=true;dc=true;if g6.heading then dd=g6.heading else dd=nil end;bq=false;lw="Proceeding to Waypoint"c_=false end;tf=qS end elseif bq and not cf and ba>kA.noAtmosphericDensityAltitude and not(cc or b8)then if g6~=nil and c7.name==kA.name then local qK=g6.position-cP;local sc=kA:getAltitude(g6.position)local qS=dp(qK:len()^2-(ch-sc)^2)local sX=bu;if sX then c5,c6=cq.computeDistanceAndTime(cM,0,ci,0,0,sX/2)lq=true;if qS<=c5+cM*s0/2 and cL:project_on_plane(cN):normalize():dot(qK:project_on_plane(cN):normalize())>0.99 then if kA.hasAtmosphere then b0=false;b2=false;pU=true;cb=false;cd=true;b3=false;cu.BeginReentry()end end;tf=qS end end end;if not cf and(b5 and ba>kA.noAtmosphericDensityAltitude)and not(cc or bz or b8)then if not cF and not bz then cE=ba;pO=true;if bq then p_.VectorToTarget=true end;cu.ToggleIntoOrbit()bq=false;pM=true end end;if cB and cf and ce==-1 and cM>aL and lw~="Finalizing Approach"then qD(cL)sG=dm(cT-s2,cT-O*0.80,cT+O*0.80)end;pV=t2;local qw=-1;if b6 then if not q9 then if not cS then q3=0 end;iF:setTargetGroundAltitude(500)iF:activateGroundEngineAltitudeStabilization(500)bB=true;q9=true end;sG=0;local tg=false;local th=math.abs(q2)if not q and cR then tg=antigrav.getBaseAltitude()if tg<kA.surfaceMaxAltitude and g6==nil or g6~=nil and kA:getAltitude(g6.position)>tg then tg=false end else tg=false end;if dd then if th<0.05 then if cO>-P then b0=false else b0="BL Align BLR"end;if qD(dd,0.001)then dd=nil;cA=p else pV=0;cA=true end else b0="BL Align Hzn"end;if tg and e_(ch-tg)<250 then b0="AGG Align"end else local ti=false;local tj=30;if th<10 and s8~=nil and s8>0 then local tk=dm(cg,0.4,2)local sX=bu*dm(cM/100,0.1,1)*tk;local tl=s8*tk+sX-od;local tm=sX/2-od;local tn=cM-dp(e_(tm/2)*20/(0.5*ci))*utils.sign(tm)if tn<0 then tn=0 end;local to;if cM>100 then local tp,dR=cq.computeDistanceAndTime(cM,100,ci,0,0,sX)local tq,dR=cq.computeDistanceAndTime(100,0,ci,0,0,dp(sX))to=tp+tq else to=cq.computeDistanceAndTime(cM,0,ci,0,0,dp(sX))end;if to<20 then b0=false else local tr=0;if tn>100 then local ts,dR=cq.computeDistanceAndTime(tn,100,ci,0,0,tl)local tt,dR=cq.computeDistanceAndTime(100,0,ci,0,0,s8*tk+dp(sX)-od)tr=ts+tt else tr,dR=cq.computeDistanceAndTime(tn,0,ci,0,0,s8*tk+dp(sX)-od)end;tr=(tr+15+cM*s0)*1.1;local tu=dc and g6~=nil and kA:getAltitude(g6.position)>0 and g6.safe;local sc=nil;if tg and tg<ch then sc=tg elseif tu then sc=kA:getAltitude(g6.position)+250 elseif ch>kA.surfaceMaxAltitude then sc=kA.surfaceMaxAltitude end;if d0 then local tv=kA:getAltitude(d0[1].center)if sc then if tv>sc then sc=tv end else sc=tv end end;if sc~=nil then local tw=ch-sc;ti=true;if tw<=tr or tr==-1 or th>0.05 and dc then if th>0.05 and dc then b0="BL AP Hzn"else b0="BL Stop Dist"end else b0=false end end end end;qw=ce;if qw>-1 then if(cM<1 or cL:normalize():dot(cN)<0)and not dd then b6=false;b5=false;if not tg then q6=true;iF:setTargetGroundAltitude(_)end;bZ=0;b0="BL Complete"cA=p;dc=false else b0="BL Slowing"end elseif not ti then if lq and cL:normalize():dot(-gs)<0.999 then b0="BL Strong"qD()elseif th>10 or th>0.05 and dc then b0="BL hSpd"elseif cO<-P then b0="BL BLR"else b0=false end end end else q9=false end;if b7 or cc then local ls,eL,eK;if bk~=nil then ls,eL,eK=cp:getPlanetarySystem(0):castIntersections(cP,(bk-cP):normalize(),function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)end;if cR and not cc then if ch>=ba-50 and cM>iY then b7=false;if not b3 and not bq then b0="ATO Agg Arrive"q3=0 end end elseif e_(sG)<15 and ch/ba>0.75 then b7=false;if not cc then if cS and not t then d.control.cancelCurrentControlMasterMode()end elseif cc and cM<iY then b3=true;cc=false;b5=false;b7=false;q3=0 elseif cc then q3=0;b0="ATO Space"end elseif cc and not cf and c7~=nil and(ls==nil or ls.name==c7.name)then b3=true;cc=false;b5=false;b7=false;if not cS then q3=0 end;bb=true end end;local tx=ce>-1;local ty=cT;if(bq or cc or cY)and not tx and cM>aL and cf then local mB=math.rad(e_(cU))ty=cT*e_(math.cos(mB))+s2*math.sin(mB)end;local tz=dm(sG-ty,-O*0.80,O*0.80)if not cf and bq then tz=dm(sG-ty,-85,Q)elseif not cf then tz=dm(sG-ty,-Q,Q)end;if e_(cU)<5 or bq or cY or b6 or tx or b5 then if sW==nil then sW=pid.new(5*0.01,0,5*0.1)end;sW:inject(tz)local sI=sW:get()pV=pV+sI end end;if antigrav~=nil and(antigrav and not q and ch<200000)then if bv==nil or bv<1000 then bv=1000 end;if tA~=bv then tA=bv;qd=tA end end;if(cf or b8 or cd)and t and cS then if tB==nil then tB=pid.new(0.1,0,1)end;local tC=0;if aU>0 and not b8 and cg>0.005 and cg<0.1 and cO>-50 then tC=(0.1-cg)*cC*aU end;tB:inject(cC/3.6+tC-cL:dot(cI))local tD=tB:get()bT=dm(tD,-1,1)if not d8 then if bT<bQ and(cg>0.005 or b8 or cd)then bS=true;d8=dm(bT,0.01,1)else bS=false;d8=bQ end end;if tE==nil then tE=pid.new(1*0.01,0,1*0.1)end;tE:inject(cL:len()-cC/3.6-tC)local tF=dm(tE:get(),0,1)if cf and cO<-80 or(cg>0.005 or b8 or cd)then bR=tF end;if bR>0 then if bS and bT==0.01 and not d8 then d8=0 end else bT=dm(bT,0.01,1)end;local tG=''local tH=vec3()local tI=rh(axisCommandId.vertical,bZ*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tI,rG)local tJ='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then tJ=tJ..aV end;local tK=iF:getAxisCommandType(axisCommandId.longitudinal)local tL=iF:composeAxisAccelerationFromThrottle(tJ,axisCommandId.longitudinal)local tM=rv(axisCommandId.lateral,by*1000)tG=tG..' , '.."lateral airfoil , lateral ground "tH=tH+tM;if tH:len()>constants.epsilon then d:setEngineForceCommand(tG,tH,rG,'','','',rH)end;d:setEngineForceCommand(tJ,tL,rF)local tN='thrust analog vertical fueled 'local tO='thrust analog lateral fueled 'if bC=="All"or bC=="Lateral"then tO=tO..aW end;if bC=="All"or bC=="Vertical"then tN=tN..aX end;if bZ~=0 or b6 and b0 or not bm and not bB then d:setEngineForceCommand(tN,tI,rF)else d:setEngineForceCommand(tN,vec3(),rF)end;if by~=0 then d:setEngineForceCommand(tO,tM,rF)else d:setEngineForceCommand(tO,vec3(),rF)end;if rN==0 then rN=bR end;local tP=-rN*(aQ*cL+aR*rR)d:setEngineForceCommand('brake',tP)else if t then if not d8 then d8=bQ end end;local rj=c.getAxisCommandValue(0)if not cS then if tE==nil then tE=pid.new(1*0.01,0,1*0.1)end;tE:inject(cL:len()-rj/3.6)local tF=dm(tE:get(),0,1)rN=dm(rN+tF,0,1)end;local tP=-rN*(aQ*cL+aR*rR)d:setEngineForceCommand('brake',tP)local tG=''local tH=vec3()local tQ=false;local tJ='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then tJ=tJ..aV end;local tK=iF:getAxisCommandType(axisCommandId.longitudinal)if tK==axisCommandType.byThrottle then local tL=iF:composeAxisAccelerationFromThrottle(tJ,axisCommandId.longitudinal)d:setEngineForceCommand(tJ,tL,rF)elseif tK==axisCommandType.byTargetSpeed then local tL=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tG=tG..' , '..tJ;tH=tH+tL;if iF:getTargetSpeed(axisCommandId.longitudinal)==0 or iF:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iF:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tQ=true end end;local tO='thrust analog lateral 'if bC=="All"or bC=="Lateral"then tO=tO..aW end;local tR=iF:getAxisCommandType(axisCommandId.lateral)if tR==axisCommandType.byThrottle then local tS=iF:composeAxisAccelerationFromThrottle(tO,axisCommandId.lateral)d:setEngineForceCommand(tO,tS,rF)elseif tR==axisCommandType.byTargetSpeed then local tM=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tG=tG..' , '..tO;tH=tH+tM end;local tN='thrust analog vertical 'if bC=="All"or bC=="Vertical"then tN=tN..aX end;local tT=iF:getAxisCommandType(axisCommandId.vertical)if tT==axisCommandType.byThrottle then local tI=iF:composeAxisAccelerationFromThrottle(tN,axisCommandId.vertical)if bZ~=0 or b6 and b0 then d:setEngineForceCommand(tN,tI,rF,'airfoil','ground','',rH)else d:setEngineForceCommand(tN,vec3(),rF)d:setEngineForceCommand('airfoil vertical',tI,rF,'airfoil','','',rH)d:setEngineForceCommand('ground vertical',tI,rF,'ground','','',rH)end elseif tT==axisCommandType.byTargetSpeed then if bZ<0 then d:setEngineForceCommand('hover',vec3(),rF)end;local tU=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tG=tG..' , '..tN;tH=tH+tU end;if tH:len()>constants.epsilon then if rN~=0 or tQ or e_(rR:dot(cI))<0.5 then tG=tG..', brake'end;d:setEngineForceCommand(tG,tH,rG,'','','',rH)end end;local tV=aN*(rV-rU)local tW=vec3(bO.getWorldAirFrictionAngularAcceleration())tV=tV-tW;d:setEngineTorqueCommand('torque',tV,rF,'airfoil','','',rH)d:setBoosterCommand('rocket_engine')if c4 and not n then local fq=cK:len()local tX=0.15;if not cS then local tY=iF:getTargetSpeed(axisCommandId.longitudinal)if fq*3.6>tY*(1-tX)and tZ then tZ=false;d:toggleBoosters()elseif fq*3.6<tY*(1-tX)and not tZ then tZ=true;d:toggleBoosters()end else local r7=c.getThrottle()if t then r7=bQ*100 end;local rj=r7/100;if not cf then rj=rj*ab;if fq>=rj*(1-tX)and tZ then tZ=false;d:toggleBoosters()elseif fq<rj*(1-tX)and not tZ then tZ=true;d:toggleBoosters()end else local t3=bM(cC)rj=rj*t3/3.6;if fq>=rj*(1-tX)and tZ then tZ=false;d:toggleBoosters()elseif fq<rj*(1-tX)and not tZ then tZ=true;d:toggleBoosters()end end end end end;if t_ then for dM,dy in pairs(t_)do pC[dM]=dy end end;ce=qr()return pC end;local function u0(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u1,iE,iF,iG,u2,gN,fW,e5,dn,dm,fV,iI,pB)local bO=DUConstruct;local u3={}local u4=true;local u5=5;local u6=5;local u7=u5;local u8=u6;local u9=bP;function u3.landingGear()bm=not bm;if bm then bq=false;bt=nil;cu.cmdThrottle(0)if vBooster or hover then if cf and ce==-1 then fV("bklOn","BL")lq=true;b8=false;b7=false;b9=false;if b6 then dc=not dc end;b6=true;cA=true;bm=false else if bV then fV("grOut","LG",1)d.control.deployLandingGears()end;dc=false;iF:setTargetGroundAltitude(_)if cf then b0="Landing"end end;b5=false;bH=false elseif bV and not b6 then fV("grOut","LG",1)d.control.deployLandingGears()end else if bV then fV("grIn","LG",1)d.control.retractLandingGears()end;iF:activateGroundEngineAltitudeStabilization(ua)if bB then if _<iF.targetGroundAltitude then iF:setTargetGroundAltitude(iF.targetGroundAltitude)else iF:setTargetGroundAltitude(Z)end end end end;function u3.startControl(ub)local function uc(r2)local r3=1;local function ud(ue,r2)local uf={kA.surfaceMaxAltitude+100,kA.spaceEngineMinAltitude-0.01*kA.noAtmosphericDensityAltitude,kA.noAtmosphericDensityAltitude+V,kA.radius*(U-1)+kA.noAtmosphericDensityAltitude}local ug=ue;for dR,dy in ipairs(uf)do if r2 and ug>dy then ue=dy elseif ue<dy and not r2 then ue=dy;break end end;return ue end;if r2 then r3=-1 end;if not q and cR then if c0 and r2 then bv=1000 elseif bv~=nil then bv=bv+r3*u6;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end else bv=tA+r3*100 end elseif b5 or b9 or bz then if bz then if c0 then cE=ud(cE,r2)else cE=cE+r3*u5 end;if cE<kA.noAtmosphericDensityAltitude then cE=kA.noAtmosphericDensityAltitude end else if c0 and cf then ba=ud(ba,r2)bH=false else ba=ba+r3*u5;if bH then if ba>100 then bH=false else iF:updateTargetGroundAltitudeFromActionStart(r3*1.0)bH=d:getTargetGroundAltitude()end end end end else iF:updateTargetGroundAltitudeFromActionStart(r3*1.0)end end;local function uh(ui)if not cf then c2="Flight Assist in Atmo only"return end;local dv=type(ui)if cY==nil then if dv=="table"then if b3 or bq then cu.ToggleAutopilot()end;fV("180On","BR")elseif ui==1 then fV("bnkLft","BR")else fV("bnkRht","BR")end;if not b5 and not b3 and not bq then cu.ToggleAltitudeHold()if dv~="table"then ui=ui+1 end end;cY=ui else fV("180Off","BR")cY=nil end end;local function uj()if iG()==1 then c8=0;c9=0;u2(bi)elseif iE()==1 and y then cz=false;cy=false end;c0=false end;if ub=="gear"then cw.landingGear()elseif ub=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ub=="forward"then if p3 and not cf and not b3 then b2=not b2;b1=false else bW=bW-1 end elseif ub=="backward"then if p3 then if not cf then if not b3 then b1=not b1;b2=false else b4=not b4 end else uh(-cL*5000)end else bW=bW+1 end elseif ub=="left"then if p3 then uh(1)else bX=bX-1 end elseif ub=="right"then if p3 then uh(3)else bX=bX+1 end elseif ub=="yawright"then bY=bY-1;dd=nil elseif ub=="yawleft"then bY=bY+1;dd=nil elseif ub=="straferight"then iF:updateCommandFromActionStart(axisCommandId.lateral,1.0)by=1 elseif ub=="strafeleft"then iF:updateCommandFromActionStart(axisCommandId.lateral,-1.0)by=-1 elseif ub=="up"then bZ=bZ+1;if ce-3<_ and ch>0 and bm then cw.landingGear()end;iF:deactivateGroundEngineAltitudeStabilization()iF:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ub=="down"then bZ=bZ-1;iF:deactivateGroundEngineAltitudeStabilization()iF:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ub=="groundaltitudeup"then uc()elseif ub=="groundaltitudedown"then uc(true)elseif ub=="option1"then uk=false;if p3 and c0 then local ul=""for M=1,#d3 do ul=ul.."| Name: "..a.getPlayerName(d3[M]).." Mass: "..fW(bO.getBoardedPlayerMass(d3[M])/1000,1).."t "end;a.print("Onboard: "..ul)return end;ct.adjustAutopilotTargetIndex()elseif ub=="option2"then uk=false;if p3 and c0 then for M=1,#d3 do bO.forceDeboard(d3[M])bO.forceInterruptVRSession(d3[M])end;c2="Deboarded All Passengers"return end;ct.adjustAutopilotTargetIndex(1)elseif ub=="option3"then local function um()u4=not u4;if not u4 then fV("wid","DH")c.showWidget()b.showWidget()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(un,atmofueltank_size,"Atmo Fuel","fuel_container")uo=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(up,spacefueltank_size,"Space Fuel","fuel_container")uq=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(ur,rocketfueltank_size,"Rocket Fuel","fuel_container")us=_autoconf.panels[_autoconf.panels_size]end;ut=a.createWidgetPanel("Docking")uu=a.createWidget(ut,"parenting")a.addDataToWidget(c.getWidgetDataId(),uu)uv=a.createWidgetPanel("Core combat stress")uw=a.createWidget(uv,"core_stress")a.addDataToWidget(b.getWidgetDataId(),uw)if shield~=nil then shield.showWidget()end else fV("hud","DH")c.hideWidget()b.hideWidget()if uo~=nil then gN(uo)uo=nil end;if ut~=nil then gN(ut)ut=nil end;if uv~=nil then gN(uv)uv=nil end;if uq~=nil then gN(uq)uq=nil end;if us~=nil then gN(us)us=nil end;if shield~=nil then shield.hideWidget()end end end;uk=false;if p3 and c0 then local ul=""for M=1,#d4 do ul=ul.."| ID: "..d4[M].." Mass: "..fW(b.getDockedConstructMass(d4[M])/1000,1).."t "end;a.print("Docked Ships: "..ul)return end;if x then if w then w=false else w=true end end;um()elseif ub=="option4"then uk=false;if p3 and c0 then for M=1,#d4 do b.forceUndock(d4[M])end;c2="Undocked all ships"return end;cY=nil;cu.ToggleAutopilot()elseif ub=="option5"then uk=false;cu.ToggleLockPitch()elseif ub=="option6"then uk=false;if p3 and c0 then if shield then cx.ventShield()else c2="No shield found"end;return end;cu.ToggleAltitudeHold()elseif ub=="option7"then uk=false;if p3 and c0 then if shield then shield.toggle()return else c2="No shield found"return end end;E=not E;if E then c2="Collision System Enabled"else c2="Collision System Secured"end elseif ub=="option8"then uk=false;if p3 and c0 then if bl>0 and g6~=nil then cu.routeWP()else c2="Select a saved wp on IPH to add to or remove from route"end;return end;bB=not bB;if not bB then c2="DeCoupled Mode - Ground Stabilization off"iF:deactivateGroundEngineAltitudeStabilization()fV("gsOff","GS")else c2="Coupled Mode - Ground Stabilization on"iF:activateGroundEngineAltitudeStabilization(ua)df=true;fV("gsOn","GS")end elseif ub=="option9"then uk=false;if p3 and c0 then iF:resetCommand(axisCommandId.longitudinal)iF:resetCommand(axisCommandId.lateral)iF:resetCommand(axisCommandId.vertical)cu.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cj=gyro.isActive()==1;if cj then fV("gyOn","GA")else fV("gyOff","GA")end else c2="No gyro found"end elseif ub=="lshift"then d1=false;if p3 then c0=true elseif c0 then uj()else if iG()==1 then c0=true;bi=iG()u2(1)elseif iE()==1 and y then c0=true;cz=false;cy=false end end elseif ub=="brake"then if aZ or p3 then cu.BrakeToggle("Manual")elseif not b0 then cu.BrakeToggle("Manual")else b0="Manual"end elseif ub=="lalt"then uk=true;p3=true;if iE()==0 and not i and g=="keyboard"then u2(1)end elseif ub=="booster"then if n then d:toggleBoosters()elseif not c4 then if not tZ then d:toggleBoosters()tZ=true end;c4=true else if tZ then d:toggleBoosters()tZ=false end;c4=false end elseif ub=="stopengines"then local function ux()if bP-u9<1.5 then fV("clear","CA")cu.clearAll()end end;ux()u9=bP;if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p3 then if cC>0 then cC=0 else cC=W end elseif bQ~=0 then iF:resetCommand(axisCommandId.longitudinal)cu.cmdThrottle(0)else cu.cmdThrottle(100)end else if iF:getTargetSpeed(axisCommandId.longitudinal)~=0 then iF:resetCommand(axisCommandId.longitudinal)else if cf then cu.cmdCruise(cC)else cu.cmdCruise(ab*3.6)end end end elseif ub=="speedup"then cu.changeSpd()elseif ub=="speeddown"then cu.changeSpd(true)elseif ub=="antigravity"and not q then if antigrav~=nil then cu.ToggleAntigrav()else c2="No antigrav found"end elseif ub=="leftmouse"then c1=true;uj()uk=false end end;function u3.stopControl(ub)local function uy()if not q and cR then u8=u6 end;if b5 or b9 or bz then u7=u5 end end;if ub=="forward"then bW=0 elseif ub=="backward"then bW=0 elseif ub=="left"then if cY then if cY==2 then cY=-2 else cY=-1 end end;bX=0 elseif ub=="right"then if cY then if cY==4 then cY=-2 else cY=-1 end end;bX=0 elseif ub=="yawright"then bY=0 elseif ub=="yawleft"then bY=0 elseif ub=="straferight"then iF:updateCommandFromActionStop(axisCommandId.lateral,-1.0)by=0 elseif ub=="strafeleft"then iF:updateCommandFromActionStop(axisCommandId.lateral,1.0)by=0 elseif ub=="up"then bZ=0;iF:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bB then iF:activateGroundEngineAltitudeStabilization(ua)df=true end elseif ub=="down"then bZ=0;iF:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bB then iF:activateGroundEngineAltitudeStabilization(ua)df=true end elseif ub=="groundaltitudeup"then uy()uk=false elseif ub=="groundaltitudedown"then uy()uk=false elseif ub=="brake"then if not aZ and not p3 then if b0 then cu.BrakeToggle()else b0=false end end elseif ub=="lalt"then if c0 then c0=false end;if iE()==0 and i then if uk then if iG()==1 then u2(0)else u2(1)end else uk=true end elseif iE()==0 and not i and g=="keyboard"then u2(0)end;p3=false end end;function u3.loopControl(ub)local function uz(r2)local r3=1;if r2 then r3=-1 end;if not q and cR then if bv~=nil then bv=bv+r3*u8;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end;u8=dm(u8*1.05,u6,50)else bv=tA+r3*100 end elseif b5 or b9 or bz then if bz then cE=cE+r3*u7;if cE<kA.noAtmosphericDensityAltitude then cE=kA.noAtmosphericDensityAltitude end else ba=ba+r3*u7 end;u7=dm(u7*1.05,u5,50)else iF:updateTargetGroundAltitudeFromActionLoop(r3*1.0)end end;local function uA(r2)local r3=1;if r2 then r3=-1 end;if not c0 then if t and not p3 then bQ=dm(bQ+r3*aF/100,-1,1)else iF:updateCommandFromActionLoop(axisCommandId.longitudinal,r3*aF)end end end;if ub=="groundaltitudeup"then if not c0 then uz()end elseif ub=="groundaltitudedown"then if not c0 then uz(true)end elseif ub=="speedup"then uA()elseif ub=="speeddown"then uA(true)end end;function u3.inputTextControl(r1)local function uB(uC,fw,gA)local function uD(fw)local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF='::pos{'..dE..','..dE..','..dE..','..dE..','..dE..'}'local dV,dW,e2,e3,e4=e5(fw,dF)if dV=="0"and dW=="0"then return vec3(dn(e2),dn(e3),dn(e4))end;e3=math.rad(e3)e2=math.rad(e2)local kA=e[dn(dV)][dn(dW)]local eW=math.cos(e2)local uE=vec3(eW*math.cos(e3),eW*math.sin(e3),math.sin(e2))return kA.center+(kA.radius+e4)*uE end;local fY=uD(fw)return ct.AddNewLocation(uC,fY,gA)end;local M;local uF,it=nil,nil;local uG="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(r1," ")uF=r1;if M~=nil then uF=string.sub(r1,0,M-1)it=string.sub(r1,M+1)end;if uF=="/help"or uF=="/commands"then for lr in string.gmatch(uG,"([^\n]+)")do a.print(lr)end;return elseif uF=="/setname"then if it==nil or it==""then c2="Usage: ah-setname Newname"return end;if bl>0 and g6~=nil then ct.UpdatePosition(it)else c2="Select a saved target to rename first"end elseif shield and uF=="/resist"then cx.setResist(it)elseif uF=="/addlocation"or string.find(r1,"::pos")~=nil then local gA=false;local uC="0-Temp"if it==nil or it==""or uF~="/addlocation"then it=uF;gA=true end;M=string.find(it,"::")if not gA then uC=string.sub(it,1,M-2)end;local fw=string.sub(it,M)uB(uC,fw,gA)elseif uF=="/agg"then if it==nil or it==""then c2="Usage: /agg targetheight"return end;it=dn(it)if it<1000 then it=1000 end;bv=it;c2="AGG Target Height set to "..it elseif uF=="/G"then if it==nil or it==""then c2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if it=="dump"then for dM,dy in pairs(iI())do if type(dy.get())=="boolean"then if dy.get()==true then a.print(dM.." true")else a.print(dM.." false")end elseif dy.get()==nil then a.print(dM.." nil")else a.print(dM.." "..dy.get())end end;return end;M=string.find(it," ")local uH=string.sub(it,0,M-1)local uI=string.sub(it,M+1)for dM,dy in pairs(iI())do if dM==uH then local uJ=type(dy.get())if uJ=="number"then uI=dn(uI)if dM=="AtmoSpeedLimit"then cC=uI end end;c2="Variable "..uH.." changed to "..uI;if dM=="MaxGameVelocity"then uI=uI/3.6;if uI>dg-0.2 then uI=dg-0.2;c2="Variable "..uH.." changed to "..fW(uI*3.6,1)end end;if uJ=="boolean"then if string.lower(uI)=="true"then uI=true else uI=false end end;dy.set(uI)return end end;c2="No such global variable: "..uH elseif uF=="/deletewp"then if bl>0 and g6~=nil then ct.ClearCurrentPosition()else c2="Select a custom wp to delete first in IPH"end elseif uF=="/copydatabank"then if dbHud_2 then pB(true)else c2="Spare Databank required to copy databank"end elseif uF=="/iphWP"then if bl>0 then a.print(cu.showWayPoint(c7,bk,true))a.print(json.encode(bk))c2="::pos waypoint shown in lua chat in local and world format"else c2="No target selected in IPH"end elseif uF=="/createPrivate"then local uK="privatelocations = {\n"local uL=""if#da>0 then for dM,dy in pairs(da)do uK=uK.."{position = {x = "..dy.position.x..", y = "..dy.position.y..", z = "..dy.position.z.."},\n ".."name = '"..dy.name.."',\n planetname = '"..dy.planetname.."',\n gravity = "..dy.gravity..",\n"if dy.heading then uK=uK.."heading = {x = "..dy.heading.x..", y = "..dy.heading.y..", z = "..dy.heading.z.."},\n"end;if dy.safe then uK=uK.."safe = true},\n"else uK=uK.."safe = false},\n"end end end;uL=#da.."-Private "if it=="all"then for dM,dy in pairs(bp)do uK=uK.."{position = {x = "..dy.position.x..", y = "..dy.position.y..", z = "..dy.position.z.."},\n ".."name = '*"..dy.name.."',\n planetname = '"..dy.planetname.."',\n gravity = "..dy.gravity..",\n"if dy.heading then uK=uK.."heading = {x = "..dy.heading.x..", y = "..dy.heading.y..", z = "..dy.heading.z.."},\n"end;if dy.safe then uK=uK.." safe = true},\n"else uK=uK.."safe = false},\n"end end;uL=uL..#bp.."-Public "end;uK=uK.."}\n return privatelocations"if u1 then u1.setHTML(uK)end;c2=uL.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c3=7 end end;function u3.tagTick()if bC=="Off"then bC="All"elseif bC=="All"then bC="Longitude"elseif bC=="Longitude"then bC="Lateral"elseif bC=="Lateral"then bC="Vertical"else bC="Off"end;c2="Extra Engine Tags: "..bC;c.stopTimer("tagTick")end;if uM then for dM,dy in pairs(uM)do u3[dM]=dy end end;return u3 end;local function uN(d,b,c,e,vBooster,hover,pA,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iB,u1)local a=DUSystem;local bO=DUConstruct;local uO=DUPlayer;local uP=DULibrary;local uQ={}local dl=string.format;local iC=json.decode;local uR=json.encode;local pt=b.getElementMaxHitPointsById;local iD=b.getElementMassById;local iE=d.control.isRemoteControlled;local e5=string.match;local gN=a.destroyWidgetPanel;local fT=a.updateData;local fU=a.addDataToWidget;local u2=a.lockView;local iG=a.isViewLocked;local dp=math.sqrt;local dn=tonumber;local e_=math.abs;local bM=math.floor;local bN=c.getAtmosphereDensity;local eV=math.atan;local bL=a.getArkTime;local dm=utils.clamp;local iF=d.axisCommandManager;local uS=_;local gP=13;local iL=b.getElementIdList()local iM=0;local function dq(eD,eE)if eD==0 then return e_(eE)<1e-09 end;if eE==0 then return e_(eD)<1e-09 end;return e_(eD-eE)<math.max(e_(eD),e_(eE))*dD end;local function fW(dE,uT)local r3=10^(uT or 0)return bM(dE*r3+0.5)/r3 end;local function iH(uU,uV)for dM,dy in pairs(uV)do if type(dM)=="string"then uU[dM]=dy else uU[#uU+1]=uV[dM]end end;return uU end;local function iI(uW)local uX={}if not uW then iH(uX,L)iH(uX,aa)iH(uX,aD)iH(uX,aY)return uX elseif uW=="boolean"then return L elseif uW=="handling"then return aa elseif uW=="hud"then return aD elseif uW=="physics"then return aY end end;local function pB(uY)local function uZ(u_)for dM,dy in pairs(u_)do dbHud_1.setStringValue(dM,uR(dy.get()))if uY and dbHud_2 then dbHud_2.setStringValue(dM,uR(dy.get()))end end end;if dbHud_1 then uZ(bI)uZ(iI())a.print("Saved Variables to Datacore")if uY and dbHud_2 then c2="Databank copied.  Remove copy when ready."end end end;local function fV(v0,v1,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v0 ..".mp3")end;local function gO(hB,hC,r1,jS,v2)if jS==nil then jS=""end;if v2==nil then v2=""end;return dl([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jS,hB,hC,v2,r1)end;local function iJ(ca,v3)local v4=ca>100000;if v3==nil then v3=1 end;if v4 then return fW(ca/1000/200,v3).."SU"elseif ca<1000 then return fW(ca,v3).."M"else return fW(ca/1000,v3).."KM"end end;local function iK(v5)local v6=0;local v7=0;local v8=0;if v5<60 then v5=bM(v5)elseif v5<3600 then v6=bM(v5/60)v5=bM(v5%60)elseif v5<86400 then v7=bM(v5/3600)v6=bM(v5%3600/60)else v8=bM(v5/86400)v7=bM(v5%86400/3600)end;if v8>0 then return v8 .."d "..v7 .."h "elseif v7>0 then return v7 .."h "..v6 .."m "elseif v6>0 then return v6 .."m "..v5 .."s"elseif v5>0 then return v5 .."s"else return"0s"end end;local function v9()if radar_1 and J then cv=gM(b,a,c,radar_1,radar_2,warpdrive,e_,gN,dp,gO,dn,gP,fV)end end;function uQ.radarSetup()v9()end;function uQ.onStart()local va=false;local function vb()local function vc(vd)local ve=dbHud_1.hasKey;for dM,dy in pairs(vd)do if ve(dM)then local dH=iC(dbHud_1.getStringValue(dM))if dH~=nil then dy.set(dH)va=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vc(iI())coroutine.yield()vc(bI)else vc(bI)c2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"c3=5;va=false end;coroutine.yield()if va then c2="Loaded Saved Variables"elseif not f then c2="No Databank Saved Variables Found\nVariables will save to Databank on standing"c3=5 end;if#bp>0 then db=iH(db,bp)end else c2="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;ck=ac;cl=ad;aZ=j;g=string.lower(g)cA=p;cC=W;if bw+180<bP then bu=0 end;bw=bP;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c3=7 end;if antigrav and not q then if bv==nil then bv=ch end;antigrav.setTargetAltitude(bv)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#da>0 then db=iH(db,da)end end;lw="Proceeding to Waypoint"if not ab or ab<0 then ab=bO.getMaxSpeed()-0.1 end end;local function vf()local function vg(vh,vi)if vh>vi then vi=vh end;local vj,vk=0,0;if a6>0 then vj=a6*0.05 end;if a7>0 then vk=a7*0.05 end;vi=vi*(1-(vj+vk))return vi end;local vl=b.getElementNameById;local vm=at~=0 and au~=0;local vn=_G["atmofueltank_size"]local vo=_G["spacefueltank_size"]local vp=_G["rocketfueltank_size"]for dM in pairs(iL)do local type=b.getElementDisplayNameById(iL[dM])if e5(type,'^.*Atmospheric Engine$')then if e5(tostring(b.getElementTagsById(iL[dM])),'^.*vertical.*$')and b.getElementForwardById(iL[dM])[3]>0 then cQ=true end end;if e5(type,'^.*Space Engine$')then cH=true;if e5(tostring(b.getElementTagsById(iL[dM])),'^.*vertical.*$')then local vq=b.getElementForwardById(iL[dM])if vq[3]<0 then vr=true else cG=true end end end;if type=="Landing Gear"then bV=true end;if type=="Dynamic Core Unit"then local pv=pt(iL[dM])if pv>10000 then gP=110 elseif pv>1000 then gP=55 elseif pv>150 then gP=27 end end;iM=iM+pt(iL[dM])if vm and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pv=pt(iL[dM])local ol=iD(iL[dM])local vh=0;local jL=bL()if type=="Atmospheric Fuel Tank"then local vi=400;local vs=35.03;if pv>10000 then vi=51200;vs=5480 elseif pv>1300 then vi=6400;vs=988.67 elseif pv>150 then vi=1600;vs=182.67 end;vh=ol-vs;if a3>0 then vi=vi+vi*a3*0.2 end;vi=vg(vh,vi)local gz=vl(iL[dM])local jJ=0;for jK=1,vn do if gz==iC(c["atmofueltank_"..jK].getWidgetData()).name then jJ=jK;break end end;local vt={iL[dM],string.sub(gz,1,12),vi,vs,vh,jL,jJ}cm[#cm+1]=vt end;if type=="Rocket Fuel Tank"then local vi=320;local vs=173.42;if pv>65000 then vi=40000;vs=25740 elseif pv>6000 then vi=5120;vs=4720 elseif pv>700 then vi=640;vs=886.72 end;vh=ol-vs;if a5>0 then vi=vi+vi*a5*0.1 end;vi=vg(vh,vi)local gz=vl(iL[dM])local jJ=0;for jK=1,vp do if gz==iC(c["rocketfueltank_"..jK].getWidgetData()).name then jJ=jK;break end end;local vt={iL[dM],string.sub(gz,1,12),vi,vs,vh,jL,jJ}co[#co+1]=vt end;if type=="Space Fuel Tank"then local vi=600;local vs=35.03;if pv>10000 then vi=76800;vs=5480 elseif pv>1300 then vi=9600;vs=988.67 elseif pv>150 then vi=2400;vs=182.67 end;vh=ol-vs;if a4>0 then vi=vi+vi*a4*0.2 end;vi=vg(vh,vi)local gz=vl(iL[dM])local jJ=0;for jK=1,vo do if gz==iC(c["spacefueltank_"..jK].getWidgetData()).name then jJ=jK;break end end;local vt={iL[dM],string.sub(gz,1,12),vi,vs,vh,jL,jJ}cn[#cn+1]=vt end end end;if not cQ then b9,a_=false,false end end;local function vu()if gyro~=nil then cj=gyro.isActive()==1 end;if not bB then iF:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u2(1)else u2(0)end;if door and(cf or not cf and ch<10000)then for dR,dy in pairs(door)do dy.toggle()end end;if switch then for dR,dy in pairs(switch)do dy.toggle()end end;if forcefield and(cf or not cf==0 and ch<10000)then for dR,dy in pairs(forcefield)do dy.toggle()end end;if antigrav then cR=antigrav.isActive()==1;if cR and not q then antigrav.showWidget()end end;if iE()==1 and k then uO.freeze(1)else uO.freeze(0)end;if bV then if ce~=-1 and not cR then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bm=d.control.isAnyLandingGearDeployed()==1 or ce~=-1 and ce-3<_;if ce~=-1 or not cf and cK:len()<50 then b0="Startup"else b0=false end;iF:setTargetGroundAltitude(uS)ph=cf end;local function vv()local vw={}local function vx()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vy={[1]=4480,[6]=4480,[7]=6270,[27]=4150}local vz={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=7700,[100]=12511,[110]=7792,[120]=11766}for vA,vB in pairs(e)do e[vA][0]=vx()e[vA][0].systemId=vA;vw[vA]={}for vC,kA in pairs(e[vA])do kA.gravity=kA.gravity/9.8;kA.center=vec3(kA.center)kA.name=kA.name[1]kA.noAtmosphericDensityAltitude=vz[kA.id]or kA.atmosphereThickness or kA.atmosphereRadius-kA.radius;kA.spaceEngineMinAltitude=vy[kA.id]or 0.68377*kA.atmosphereThickness;kA.planetarySystemId=vA;kA.bodyId=kA.id;vw[vA][vC]=kA;if mm==nil or kA.center.x<mm then mm=kA.center.x end;if ml==nil or kA.center.x>ml then ml=kA.center.x end;if mp==nil or kA.center.y<mp then mp=kA.center.y end;if mo==nil or kA.center.y>mo then mo=kA.center.y end;if kA.center and kA.name~="Space"then d5[#d5+1]=kA end end end;ef=dk(d,b,c,a,dl,dm,dn,dp,dq)cp=ef(vw)fZ=cp[0]cq=eZ(d,b,c,a,dp,e_)cr=fs(d,b,c,a,dl,dm,dn,dp,dq)ct=fS(d,b,c,a,dbHud_1,e,fT,fU,bM,dn,dp,fV,fW)kA=cp[0]:closestBody(bO.getWorldPosition())end;vD=false;vE=coroutine.create(function()iF:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vb()coroutine.yield()vf()coroutine.yield()cu=pz(d,b,c,e,vBooster,hover,pA,antigrav,dbHud_1,e_,bM,bN,iE,eV,bL,dm,iF,fT,iG,dp,fW,fV,iH,dq,iJ,iK,pB,iC)vu()coroutine.yield()vv()v9()if iA then cs=iA(d,b,c,a,e,antigrav,hover,shield,warpdrive,iB,e_,bM,dl,iC,bN,iD,iE,eV,bL,dm,iF,fU,fT,gN,iG,dp,fW,gO,fV,iH,iI,iJ,iK,iL,iM)end;if cs then cs.ButtonSetup()end;cw=u0(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u1,iE,iF,iG,u2,gN,fW,e5,dn,dm,fV,iI,pB)if shield then cx=ij(shield,e5,bM)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if u1 then u1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vF then nz.ExtraOnStart()end;fV("start","SU")local function vG()if bG[1]==0 then cu.cmdThrottle(bG[2])else if cg>0 then cC=bG[2]cu.cmdThrottle(1)end end end;ln=string.find(c.getName(),"Emergency")or false;if ln then if ce>-1 and cM<1 and ce-3<_ then c.exit()else if K then vG()else if cg==0 then b0="ECU Braking"elseif ce==-1 then cw.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif K and bG[3]+3>bL()then vG()end end)coroutine.resume(vE)end;function uQ.onUpdate()if not vD then local ia=coroutine.status(vE)if ia=="suspended"then local dN,ib=coroutine.resume(vE)if ib then a.print("ERROR STARTUP: "..ib)end elseif ia=="dead"then vD=true end end;if vD then d:update()if cf and t and cS then if cS and bU then cu.cmdThrottle(0)bU=false elseif not cS and not bU then bQ=0;bU=true end end;if d8 then iF:setThrottleCommand(axisCommandId.longitudinal,d8)d8=nil end;if not cy and p5~=vH then a.setScreen(p5)end;vH=p5;if ln and not K and cg>0 and ce==-1 then cw.landingGear()end;if ln and ce>-1 and cM<1 and ce-3<_ then c.exit()end;if vF then nz.ExtraOnUpdate()end end end;function uQ.onFlush()if vD then cu.onFlush()if vF then nz.ExtraOnFlush()end end end;function uQ.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cg>0 or cg==0 and ch<10000)then for dR,dy in pairs(door)do dy.toggle()end end;if switch then for dR,dy in pairs(switch)do dy.toggle()end end;if forcefield and(cg>0 or cg==0 and ch<10000)then for dR,dy in pairs(forcefield)do dy.toggle()end end;w=d7;local vI=0;if ln then vI=bL()end;if iF:getAxisCommandType(0)==0 then bG={0,bQ,vI}else bG={1,iF:getTargetSpeed(axisCommandId.longitudinal),vI}end;pB()if nW then nW.activate()end;if z then cu.showWayPoint(kA,cP)end;if cs then a.print(cs.FuelUsed("atmofueltank")..", "..cs.FuelUsed("spacefueltank")..", "..cs.FuelUsed("rocketfueltank"))end;if vF then nz.ExtraOnStop()end;fV("stop","SU")end;function uQ.controlStart(ub)if vD then cw.startControl(ub)end end;function uQ.controlStop(ub)if vD then cw.stopControl(ub)end end;function uQ.controlLoop(ub)if vD then cw.loopControl(ub)end end;function uQ.controlInput(r1)if vD then cw.inputTextControl(r1)end end;function uQ.radarEnter(dW)if cv then cv.onEnter(dW)end end;function uQ.radarLeave(dW)if cv then cv.onLeave(dW)end end;function uQ.onTick(vJ)if vJ=="tenthSecond"then if cu then cu.TenthTick()end;if cs then cs.TenthTick()end elseif vJ=="oneSecond"then if cs then cs.OneSecondTick()end elseif vJ=="fiveSecond"then cu.SatNavTick()elseif vJ=="msgTick"then if cs then cs.MsgTick()end elseif vJ=="animateTick"then if cs then cs.AnimateTick()end elseif vJ=="hudTick"then if cs then cs.hudtick()end elseif vJ=="apTick"then if cu then cu.APTick()end elseif vJ=="shieldTick"then cx.shieldTick()elseif vJ=="tagTick"then cw.tagTick()elseif vJ=="contact"then cv.ContactTick()end end;if vF then for dM,dy in pairs(vF)do uQ[dM]=dy end end;return uQ end;function script.onStart()nz.onStart()end;function script.onOnStop()nz.onStop()end;function script.onTick(vJ)nz.onTick(vJ)end;function script.onOnFlush()nz.onFlush()end;function script.onOnUpdate()nz.onUpdate()end;function script.onActionStart(ub)nz.controlStart(ub)end;function script.onActionStop(ub)nz.controlStop(ub)end;function script.onActionLoop(ub)nz.controlLoop(ub)end;function script.onInputText(r1)nz.controlInput(r1)end;function script.onEnter(dW)nz.radarEnter(dW)end;function script.onLeave(dW)nz.radarLeave(dW)end;bK(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)nz=uN(d,core,unit,e,vBooster,hover,pA,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iB,u1)script.onStart()
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
