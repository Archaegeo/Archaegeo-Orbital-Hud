name: ArchHud - Archaegeo v1.359 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        LockPitchTarget = 0 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.359;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=utils.round;local p=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local x=math.sqrt;local y=tonumber;local core=core;local function z(A,B)local mult=10^(B or 0)return d(A*mult+0.5)/mult end;local C=p()local D=p()local E=16;local F=13;local G=SafeR;local H=SafeB;local I=SafeG;local J=0;local K=0;local L=false;local M=0;local N=false;local O=false;local P=55;local Q=false;local R=false;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=false;local a0=false;local a1="empty"local a2=5;local a3=5;local a4=a2;local a5=a3;local a6=false;local a7,a8=0;local a9,aa=0;local ab=nil;local ac=0;local ad=0;local ae=0;local af=0;local ag=0;local ah=3;local ai=0;local aj=""local ak=0;local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=j()>0;local ar=j()local as=core.getAltitude()local at=core.getElementIdList()local au=p()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]local az=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN={}local aO={}local aP=d(1/apTickRate)*2;local aQ={}local aR={}local aS={}local aT={}local aU=false;local aV=0;local aW=nil;local aX=nil;local aY=nil;local aZ=nil;local a_=nil;local b0=nil;local b1=nil;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=false;local b9=false;local ba=autoRollPreference;local bb=LandingGearGroundHeight;local bc=false;local bd=p()local be=0;local bf=0;local bg=0;local bh=AtmoSpeedLimit;local bi=0;local bj=nil;local bk=0;local bl=0;local bm=false;local bn=false;local bo={VectorToTarget=false}local bp=false;local bq=0;local br=nil;local bs=false;local bt=false;local bu=false;local bv=false;local bw=0;local bx=vec3(core.getConstructWorldOrientationUp())local by=vec3(core.getConstructWorldOrientationForward())local bz=vec3(core.getConstructWorldOrientationRight())local bA=vec3(core.getWorldVelocity())local bB=vec3(bA):len()local bC=vec3(core.getWorldVertical())local bD=-bC:dot(bA)local bE=vec3(core.getConstructWorldPos())local bF=0;local bG=false;local bH=false;local bI=nil;local bJ=true;local bK=0;local bL=0;local bM=false;local bN={}local bO=showHud;local bP={}local bQ=false;local bR=""local bS=""local bT=nil;local bU={}local bV=unit.getClosestPlanetInfluence()>0;local bW=false;local bX=nil;function Log(bY,bZ)local self={}self.Name=bY or'Log'self.Value=bZ=='number'and 0 or{}self.Type=bZ or'mean'function self.Update(b_)if self.Type=='number'then self.Value=b_ else self.Value[#self.Value]=b_ end end;function self.getString()if self.Type=='number'then return tostring(self.Value)elseif self.Type=='time'then return utils.round(self.getMean()*1000,0.0001)..'ms ('..#self.Value..")"elseif self.Type=='mean'then return tostring(utils.round(self.getMean(),0.01))end end;function self.getValue()if self.Type=='number'then return self.value else return self.getMean()end end;function self.addValue(b_)if self.Type=='number'then return end;table.insert(self.Value,1,b_)if#self.Value>1000 then self.Value[1001]=nil end end;function self.getMean()local c0=0;for i=1,#self.Value do c0=c0+self.Value[i]end;return c0/#self.Value end;return self end;function Logger()local self={}self.Logs={}function self.CreateLog(bY,type)local c1=Log(bY,type)Register(c1)return c1 end;function self.getLogs()local c2={}for _,c3 in pairs(self.Logs)do c2[#c2+1]=c3.Name..': '..c3.getString()end;return c2 end;function Register(c1)self.Logs[#self.Logs+1]=c1 end;return self end;local function c4(c5)local c6,c7,c8=b0:getPlanetarySystem(0):castIntersections(bE,c5,function(c9)if c9.noAtmosphericDensityAltitude>0 then return c9.radius+c9.noAtmosphericDensityAltitude else return c9.radius+c9.surfaceMaxAltitude*1.5 end end)local ca=c7;if c8~=nil and c7~=nil then ca=math.min(c8,c7)end;if ca~=nil then return c6,ca else return nil,nil end end;local function cb(cc,cd,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)end end;local function ce(cf,cg)for i=1,#cg do cf[#cf+1]=cg[i]end;return cf end;local function ch(ci)local cj={}local ck={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local cl={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","LockPitchTarget","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local cm={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cn={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not ci then ce(cj,ck)ce(cj,cl)ce(cj,cm)ce(cj,cn)return cj elseif ci=="boolean"then return ck elseif ci=="handling"then return cl elseif ci=="hud"then return cm elseif ci=="physics"then return cn end end;local function co(cp,cq,cr,cs,ct)if cs==nil then cs=""end;if ct==nil then ct=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cs,cp,cq,ct,cr)end;local function cu(cv,cw)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not cw then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,cv)J=q(z(cv*100,0)/100,-1,1)end;local function cx(cv,cw)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cw then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,cv)bI=cv end;local function cy(cz,cA)if cz==0 then return c(cA)<1e-09 end;if cA==0 then return c(cz)<1e-09 end;return c(cz-cA)<math.max(c(cz),c(cA))*epsilon end;local function cB(ai,cC)local cD=ai>100000;if cC==nil then cC=1 end;if cD then return z(ai/1000/200,cC).."SU"elseif ai<1000 then return z(ai,cC).."M"else return z(ai/1000,cC).."KM"end end;local function cE()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;ba=true;ae=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;ae=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cx(d(bh))end else bs=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cF()bs=false;bk=nil;bl=nil;bw=0;if ar==0 then if IntoOrbit then cb("orOff","AP")IntoOrbit=false;bm=false;br=nil;ba=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bo.VectorToTarget=false;bo.AutopilotAlign=false;bp=false elseif bV then cb("orOn","AP")IntoOrbit=true;ba=true;if br==nil then br=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a1="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bm=false;br=nil;ba=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bo.VectorToTarget=false;bo.AutopilotAlign=false;bp=false end end;local function cG()if C-bf<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;cb("11","EP")else if bV then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bq=HoldAltitude;bp=true;if not IntoOrbit then cF()end;bm=true end end;bf=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bf=C end;if bV and ar==0 then bq=as;bp=true;bm=true;cF()if IntoOrbit then bf=C else bf=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Z=false;ba=true;LockPitch=nil;bs=false;if ao==-1 then cb("altOn","AH")AutoTakeoff=false;if bf>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=as end end;if VertTakeOff then cE()end else cb("lfs","LS")AutoTakeoff=true;if bf>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bG then cE()end end;if am then HoldAltitude=100000 end else cb("altOff","AH")if IntoOrbit then cF()end;if VertTakeOff then cE()end;ba=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bf=0 end end;local function cH()local function cI(SpaceTarget)bW=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cG()end end;VectorStatus="Proceeding to Waypoint"end;if C-bg<1.5 and ar>0 then if not bv then a1="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;cb("orH","OH")end;bg=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bg=C end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then b5.UpdateAutopilotTarget()b6.showWayPoint(ab,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then cb("apSpc","AP")if ar~=0 then am=true;cG()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then cb("vtt","AP")cI(SpaceTarget)end else cb("apOn","AP")if not(ab.name==planet.name and bV)then bs=false;Autopilot=true elseif not aq then if IntoOrbit then cF()end;bq=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bp=true;bo.AutopilotAlign=true;bo.VectorToTarget=true;bm=false;if not IntoOrbit then cF()end end end else cb("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cG()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ab.name==planet.name and bV)and not IntoOrbit then WaypointSet=false;bs=false;bm=false;cF()else cb("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Z=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;O=false;LockPitch=nil;WaypointSet=false end else cb("apP","AP")am=true;cG()end else cb("apOff","AP")am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;O=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=as;TargetSet=false;Reentry=false;if IntoOrbit then cF()end end end;local function cJ()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;ba=autoRollPreference end;if BrakeIsOn then cb("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bT=nil;if not bH then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cE()end;if IntoOrbit then cF()end;ba=autoRollPreference;al=false;an=false;ae=0 else cb("bkOff","B",1)end end;local function cK()if Reentry then a1="Re-Entry cancelled"cb("reOff","RE")Reentry=false;ba=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ah=5 elseif not Q then Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;ba=true;BrakeIsOn=false;a1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bh;cb("par","RE")else Reentry=true;AltitudeHold=true;ba=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local cr=cB(HoldAltitude)a1="Beginning Re-entry.  Target speed: "..bh.." Target Altitude: "..cr;cb("glide","RE")cx(d(bh))end;AutoTakeoff=false end;local function cL()if antigrav and not ExternalAGG then if bH then cb("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;cb("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cM(cN)local cO=0;local cP=0;local cQ=0;if cN<60 then cN=d(cN)elseif cN<3600 then cO=d(cN/60)cN=d(cN%60)elseif cN<86400 then cP=d(cN/3600)cO=d(cN%3600/60)else cQ=d(cN/86400)cP=d(cN%86400/3600)end;if cQ>0 then return cQ.."d "..cP.."h "elseif cP>0 then return cP.."h "..cO.."m "elseif cO>0 then return cO.."m "..cN.."s"elseif cN>0 then return cN.."s"else return"0s"end end;local function cR(cS)local function cT(cU)for cV,b_ in pairs(cU)do dbHud_1.setStringValue(b_,g(_G[b_]))if cS and dbHud_2 then dbHud_2.setStringValue(b_,g(_G[b_]))end end end;if dbHud_1 then cT(b)cT(ch())system.print("Saved Variables to Datacore")if cS and dbHud_2 then a1="Databank copied.  Remove copy when ready."end end end;local function cW()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function cX()local function cY(cZ)return type(cZ)=='number'end;local function c_(cZ)return type(y(cZ))=='number'end;local function d0(d1)return type(d1)=='table'end;local function d2(d3)return type(d3)=='string'end;local function d4(b_)return d0(b_)and cY(b_.x and b_.y and b_.z)end;local function d5(c0)return d0(c0)and cY(c0.latitude and c0.longitude and c0.altitude and c0.bodyId and c0.systemId)end;local d6=math.pi/180;local d7=180/math.pi;local epsilon=1e-10;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d8='::pos{'..A..','..A..','..A..','..A..','..A..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function d9(cZ)local da=string.gsub(string.reverse(e('%.4f',cZ)),'^0*%.?','')return da==''and'0'or string.reverse(da)end;local function db(dc)if d4(dc)then return e('{x=%.3f,y=%.3f,z=%.3f}',dc.x,dc.y,dc.z)end;if d0(dc)and not getmetatable(dc)then local dd={}local de=next(dc)if type(de)=='nil'or de==1 then dd=dc else for cV,b_ in pairs(dc)do local cv=db(b_)if type(cV)=='number'then table.insert(dd,e('[%s]=%s',cV,cv))else table.insert(dd,e('%s=%s',cV,cv))end end end;return e('{%s}',table.concat(dd,','))end;if d2(dc)then return e("'%s'",dc:gsub("'",[[\']]))end;return tostring(dc)end;local df={}df.__index=df;df.__tostring=function(dc,dg)local dh={}for cV in pairs(dc)do table.insert(dh,cV)end;table.sort(dh)local dd={}for _,cV in ipairs(dh)do local cv=db(dc[cV])if type(cV)=='number'then table.insert(dd,e('[%s]=%s',cV,cv))else table.insert(dd,e('%s=%s',cV,cv))end end;if dg then return e('%s%s',dg,table.concat(dd,',\n'..dg))end;return e('{%s}',table.concat(dd,','))end;df.__eq=function(di,dj)return di.planetarySystemId==dj.planetarySystemId and di.bodyId==dj.bodyId and cy(di.radius,dj.radius)and cy(di.center.x,dj.center.x)and cy(di.center.y,dj.center.y)and cy(di.center.z,dj.center.z)and cy(di.GM,dj.GM)end;local function dk(dl,dm,dn,dp,dq)assert(c_(dl),'Argument 1 (planetarySystemId) must be a number:'..type(dl))assert(c_(dm),'Argument 2 (bodyId) must be a number:'..type(dm))assert(c_(dn),'Argument 3 (radius) must be a number:'..type(dn))assert(d0(dp),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dp))assert(c_(dq),'Argument 5 (GM) must be a number:'..type(dq))return setmetatable({planetarySystemId=y(dl),bodyId=y(dm),radius=y(dn),center=vec3(dp),GM=y(dq)},df)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dr)return e('::pos{%d,%d,%s,%s,%s}',dr.systemId,dr.bodyId,d9(dr.latitude*d7),d9(dr.longitude*d7),d9(dr.altitude))end;MapPosition.__eq=function(di,dj)return di.bodyId==dj.bodyId and di.systemId==dj.systemId and cy(di.latitude,dj.latitude)and cy(di.altitude,dj.altitude)and(cy(di.longitude,dj.longitude)or cy(di.latitude,math.pi/2)or cy(di.latitude,-math.pi/2))end;local function ds(dt,dm,du,dv,dw)local dl=dt;if d2(dt)and not dv and not dw and not dm and not du then dl,dm,du,dv,dw=n(dt,d8)assert(dl,'Argument 1 (position string) is malformed.')else assert(c_(dl),'Argument 1 (systemId) must be a number:'..type(dl))assert(c_(dm),'Argument 2 (bodyId) must be a number:'..type(dm))assert(c_(du),'Argument 3 (latitude) must be in degrees:'..type(du))assert(c_(dv),'Argument 4 (longitude) must be in degrees:'..type(dv))assert(c_(dw),'Argument 5 (altitude) must be in meters:'..type(dw))end;dl=y(dl)dm=y(dm)du=y(du)dv=y(dv)dw=y(dw)if dm==0 then return setmetatable({latitude=du,longitude=dv,altitude=dw,bodyId=dm,systemId=dl},MapPosition)end;return setmetatable({latitude=d6*q(du,-90,90),longitude=d6*(dv%360),altitude=dw,bodyId=dm,systemId=dl},MapPosition)end;local dx={}dx.__index=dx;dx.__tostring=function(dc,dg)local dy=dg and dg..'  'local dz={}local dh={}for cV in pairs(dc)do table.insert(dh,cV)end;table.sort(dh)for _,dA in ipairs(dh)do bdy=dc[dA]local dB=df.__tostring(bdy,dy)if dg then table.insert(dz,e('[%s]={\n%s\n%s}',dA,dB,dg))else table.insert(dz,e('  [%s]=%s',dA,dB))end end;if dg then return e('\n%s%s%s',dg,table.concat(dz,',\n'..dg),dg)end;return e('{\n%s\n}',table.concat(dz,',\n'))end;local function dC(dD)local aW={}local pid;for _,b_ in pairs(dD)do local dE=b_.planetarySystemId;if type(dE)~='number'then error('Invalid planetary system ID: '..tostring(dE))elseif pid and dE~=pid then error('Mistringmatch planetary system IDs: '..dE..' and '..pid)end;local dF=b_.bodyId;if type(dF)~='number'then error('Invalid body ID: '..tostring(dF))elseif aW[dF]then error('Duplicate body ID: '..tostring(dF))end;setmetatable(b_.center,getmetatable(vec3.unit_x))aW[dF]=setmetatable(b_,df)pid=dE end;return setmetatable(aW,dx)end;a_={}local function dG(dD)return setmetatable({galaxyAtlas=dD or{}},a_)end;a_.__index=function(d1,i)if type(i)=='number'then local system=d1.galaxyAtlas[i]return dC(system)end;return rawget(a_,i)end;a_.__pairs=function(dc)return function(d1,cV)local dH,nv=next(d1,cV)return dH,nv and dC(nv)end,dc.galaxyAtlas,nil end;a_.__tostring=function(dc)local dI={}for _,dJ in pairs(dc or{})do local dK=dJ:getPlanetarySystemId()local dL=dx.__tostring(dJ,'    ')table.insert(dI,e('  [%s]={%s\n  }',dK,dL))end;return e('{\n%s\n}\n',table.concat(dI,',\n'))end;a_.BodyParameters=dk;a_.MapPosition=ds;a_.PlanetarySystem=dC;function a_.createBodyParameters(dM,dm,dN,dO,dP,dQ,dR)assert(c_(dM),'Argument 1 (planetarySystemId) must be a number:'..type(dM))assert(c_(dm),'Argument 2 (bodyId) must be a number:'..type(dm))assert(c_(dN),'Argument 3 (surfaceArea) must be a number:'..type(dN))assert(d0(dO),'Argument 4 (aPosition) must be an array or vec3:'..type(dO))assert(d0(dP),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dP))assert(c_(dQ),'Argument 6 (altitude) must be in meters:'..type(dQ))assert(c_(dR),'Argument 7 (gravityAtPosition) must be number:'..type(dR))local dn=x(dN/4/math.pi)local ai=dn+dQ;local dS=vec3(dO)+ai*vec3(dP)local dq=dR*ai*ai;return dk(dM,dm,dn,dS,dq)end;a_.isMapPosition=d5;function a_:getPlanetarySystem(dt)if i==nil then i=0 end;if nv==nil then nv=0 end;local dM=dt;if d5(dt)then dM=dt.systemId end;if type(dM)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dx then system=dC(system)end;return system end end end;function dx:sizeCalculator(c9)return 1.05*c9.radius end;function dx:castIntersections(dT,dU,dV,dW,dX,dY)local dZ={}local d_=dX or self;for _,c9 in pairs(d_)do table.insert(dZ,c9)end;if not dY then table.sort(dZ,function(e0,e1)return(e0.center-dT):len()<(e1.center-dT):len()end)end;local e2=dU:normalize()for _,c9 in ipairs(dZ)do local e3=c9.center-dT;local dn=self:sizeCalculator(c9)local e4=e3:dot(e2)local e5=e4^2-(e3:len2()-dn^2)if e5>=0 then local e6=x(e5)local c7=e4+e6;local c8=e4-e6;if c8>0 then return c9,c7,c8 elseif c7>0 then return c9,c7,nil end end end;return nil,nil,nil end;function dx:closestBody(e7)assert(type(e7)=='table','Invalid coordinates.')local e8,c9;local e9=vec3(e7)for _,ea in pairs(self)do local eb=(ea.center-e9):len2()if(not c9 or eb<e8)and ea.name~="Space"then c9=ea;e8=eb end end;return c9 end;function dx:convertToBodyIdAndWorldCoordinates(dt)local ec=dt;if d2(dt)then ec=ds(dt)end;if ec.bodyId==0 then return 0,vec3(ec.latitude,ec.longitude,ec.altitude)end;local ea=self:getBodyParameters(ec)if ea then return ec.bodyId,ea:convertToWorldCoordinates(ec)end end;function dx:getBodyParameters(dt)local dm=dt;if d5(dt)then dm=dt.bodyId end;assert(c_(dm),'Argument 1 (bodyId) must be a number:'..type(dm))return self[dm]end;function dx:getPlanetarySystemId()local _,b_=next(self)return b_ and b_.planetarySystemId end;function df:convertToMapPosition(dp)assert(d0(dp),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dp))local ed=vec3(dp)if self.bodyId==0 then return setmetatable({latitude=ed.x,longitude=ed.y,altitude=ed.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local ee=ed-self.center;local ai=ee:len()local dw=ai-self.radius;local du=0;local dv=0;if not cy(ai,0)then local ef=m(ee.y,ee.x)dv=ef>=0 and ef or 2*math.pi+ef;du=math.pi/2-math.acos(ee.z/ai)end;return setmetatable({latitude=du,longitude=dv,altitude=dw,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function df:convertToWorldCoordinates(dt)local ec=d2(dt)and ds(dt)or dt;if ec.bodyId==0 then return vec3(ec.latitude,ec.longitude,ec.altitude)end;assert(d5(ec),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(ec.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(ec.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local eg=math.cos(ec.latitude)return self.center+(self.radius+ec.altitude)*vec3(eg*math.cos(ec.longitude),eg*math.sin(ec.longitude),math.sin(ec.latitude))end;function df:getAltitude(dp)return(vec3(dp)-self.center):len()-self.radius end;function df:getDistance(dp)return(vec3(dp)-self.center):len()end;function df:getGravity(dp)local eh=self.center-vec3(dp)local ei=eh:len2()return self.GM/ei*eh/x(ei)end;return setmetatable(a_,{__call=function(_,...)return dG(...)end})end;local function ej()local b1={}local ek=30000000/3600;local el=ek*ek;local em=100;local function en(b_)return 1/x(1-b_*b_/el)end;function b1.computeAccelerationTime(eo,ep,eq)local er=ek*math.asin(eo/ek)return(ek*math.asin(eq/ek)-er)/ep end;function b1.computeDistanceAndTime(eo,eq,es,et,eu,ev)eu=eu or 0;ev=ev or 0;local ew=eo<=eq;local ex=et*(ew and 1 or-1)/es;local ey=-ev/es;local ez=ex+ey;if ew and ez<=0 or not ew and ez>=0 then return-1,-1 end;local eA,eB=0,0;if ex~=0 and eu>0 then local er=math.asin(eo/ek)local eC=math.pi*(ex/2+ey)local eD=ex*eu;local eE=ek*math.pi;local b_=function(d1)local eF=(eC*d1-eD*math.sin(math.pi*d1/2/eu)+eE*er)/eE;local eG=math.tan(eF)return ek*eG/x(eG*eG+1)end;local eH=ew and function(d3)return d3>=eq end or function(d3)return d3<=eq end;eB=2*eu;if eH(b_(eB))then local eI=0;while c(eB-eI)>0.5 do local d1=(eB+eI)/2;if eH(b_(d1))then eB=d1 else eI=d1 end end end;local eJ=eo;local eK=eB/em;for eL=1,em do local eM=b_(eL*eK)eA=eA+(eM+eJ)*eK/2;eJ=eM end;if eB<2*eu then return eA,eB end;eo=eJ end;local er=ek*math.asin(eo/ek)local C=(ek*math.asin(eq/ek)-er)/ez;local eN=el*math.cos(er/ek)/ez;local ai=eN-el*math.cos((ez*C+er)/ek)/ez;return ai+eA,C+eB end;function b1.computeTravelTime(eo,ep,ai)if ai==0 then return 0 end;if ep>0 then local er=ek*math.asin(eo/ek)local eN=el*math.cos(er/ek)/ep;return(ek*math.acos(ep*(eN-ai)/el)-er)/ep end;if eo==0 then return-1 end;assert(eo>0,'Acceleration and initial speed are both zero.')return ai/eo end;function b1.lorentz(b_)return en(b_)end;return b1 end;local function eO()local vec3=require('cpml.vec3')local cX=cX()local function d2(d3)return type(d3)=='string'end;local function d0(d1)return type(d1)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dw)assert(self.body)local ai=dw+self.body.radius;if not cy(ai,0)then local orbit=x(self.body.GM/ai)return x(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dt,eP)assert(self.body)assert(d0(dt)or d2(dt))assert(d0(eP))local eQ=(d2(dt)or cX.isMapPosition(dt))and self.body:convertToWorldCoordinates(dt)or vec3(dt)local b_=vec3(eP)local eR=eQ-self.body.center;local eS=b_:len2()local eT=eR:len()local eU=self.body.GM;local eV=((eS-eU/eT)*eR-eR:dot(b_)*b_)/eU;local cz=eU/(2*eU/eT-eS)local eW=eV:len()local e2=eV:normalize()local eX=cz*(1-eW)local eY=cz*(1+eW)local eZ=eX*e2+self.body.center;local e_=eW<=1 and-eY*e2+self.body.center or nil;local f0=x(cz*eU*(1-eW*eW))local f1=e_ and 2*math.pi*x(cz^3/eU)local f2=math.acos(eV:dot(eR)/(eW*eT))if eR:dot(b_)<0 then f2=-(f2-2*math.pi)end;local f3=math.acos((math.cos(f2)+eW)/(1+eW*math.cos(f2)))local f4=f3;if f4<0 then f4=f4+2*math.pi end;local f5=f4-eW*math.sin(f4)local f6=0;local f7=0;local f8=0;if f1~=nil then f6=f5/(2*math.pi/f1)f7=f1-f6;f8=f7+f1/2;if f2-math.pi>0 then f7=f6;f8=f7+f1/2 end;if f8>f1 then f8=f8-f1 end end;return{periapsis={position=eZ,speed=f0/eX,circularOrbitSpeed=x(eU/eX),altitude=eX-self.body.radius},apoapsis=e_ and{position=e_,speed=f0/eY,circularOrbitSpeed=x(eU/eY),altitude=eY-self.body.radius},currentVelocity=b_,currentPosition=eQ,eccentricity=eW,period=f1,eccentricAnomaly=f3,meanAnomaly=f5,timeToPeriapsis=f7,timeToApoapsis=f8}end;local function f9(fa)local ea=cX.BodyParameters(fa.planetarySystemId,fa.bodyId,fa.radius,fa.center,fa.GM)return setmetatable({body=ea},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return f9(...)end})end;local function fb()local fc={}local fd={}local fe={XS=13,S=27,M=55,L=110,XL=221}local ff={}local fg;local fh;local fi;local fj;local fk;local function fl()local fm=system.getTime()local function fn(fo,fp,fq,fr,fs,ft,fu,fv)fp,fr,ft,fv=vec3(fp),vec3(fr),vec3(ft),vec3(fv)local fw,fx,fy=fo*fo,fq*fq,fs*fs;local eS=fr-fp;local fz=eS:normalize()local fA=eS:len()local fB=ft-fp;local fC=(fB-fB:project_on(fz)):normalize()local fD,fE=fB:dot(fz),fB:dot(fC)local fF=fD*fD+fE*fE;local fG=fz:cross(fC)local cp=(fw-fx+fA*fA)/(2*fA)local cq=(fw-fy+fF-2*fD*cp)/(2*fE)local c0=fw-cp^2-cq^2;local fH=x(c0)local fI=fp+fz*cp+fC*cq+fG*fH;local fJ=fp+fz*cp+fC*cq-fG*fH;if c((fv-fI):len()-fu)<c((fv-fJ):len()-fu)then return fI else return fJ end end;local function fK()local function fL()local fM=core.getConstructWorldOrientationRight()local eS=core.getConstructWorldOrientationForward()local fB=core.getConstructWorldOrientationUp()local fN=library.systemResolution3(fM,eS,fB,{1,0,0})local fO=library.systemResolution3(fM,eS,fB,{0,1,0})local fP=library.systemResolution3(fM,eS,fB,{0,0,1})return function(fQ)return library.systemResolution3(fN,fO,fP,fQ)end end;local fR=fL()local fS=core.getConstructWorldPos()local eQ=core.getElementPositionById(1)local fT={eQ[1]-E,eQ[2]-E,eQ[3]-E}local fU=fR(fT)local fV={fS[1]-fU[1],fS[2]-fU[2],fS[3]-fU[3]}return fV end;local function fW(fX,eT,fY)local fZ=fX.pts;local f_=#fZ;local g0=fX.ref;if f_>3 then local g1,g2,g3,g4=fZ[f_],fZ[f_-1],fZ[f_-2],fZ[f_-3]fX.ref=fY;local eQ=fn(g1[1],g1[2],g2[1],g2[2],g3[1],g3[2],g4[1],g4[2])local cp,cq,fH=eQ.x,eQ.y,eQ.z;if cp==cp and cq==cq and fH==fH then cp=cp+g0[1]cq=cq+g0[2]fH=fH+g0[3]local g5=vec3(cp,cq,fH)if not fX.lastPos then fX.center=g5 elseif(fX.lastPos-g5):len()<2 then fX.center=g5;fX.skipCalc=true end;fX.lastPos=g5 end;fX.pts={}else local g6={fY[1]-g0[1],fY[2]-g0[2],fY[3]-g0[3]}fZ[f_+1]={eT,g6}end end;if radar_1 then fg=#radar_1.getEntries()local g7=radar_1.getData()local g8=g7:gmatch('{"constructId[^}]*}[^}]*}')if fg>0 then local fY=fK()local g9,ga=0,0;fk=0;for b_ in g8 do local dE,ai,gb=b_:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local gc=fe[gb]ai=y(ai)if radar_1.hasMatchingTransponder(dE)==1 then table.insert(fd,dE)end;local gd=radar_1.getConstructType(dE)if CollisionSystem then if gc>27 or gd=="static"or gd=="space"then fk=fk+1;local bY=radar_1.getConstructName(dE)local fX=bU[dE]if fX==nil then gc=gc+F;bU[dE]={pts={},ref=fY,name=bY,i=0,radius=gc,skipCalc=false}fX=bU[dE]end;if not fX.skipCalc then fW(fX,ai,fY)ga=ga+1 end;if fX.center then table.insert(ff,fX)end end;g9=g9+1;if bV and g9>700 or ga>70 or(not bV and g9>300 or ga>30)then coroutine.yield()g9,ga=0,0 end end end;fj=#ff;if fj>0 and bB>20 then local c9,ge,gf,gg;local gh=0;local gi=b0:getPlanetarySystem(0)gg=bA:normalize()while gh<fj do coroutine.yield()local gj={table.unpack(ff,gh,math.min(gh+75,fj))}c9,ge,gf=gi:castIntersections(bE,gg,nil,nil,gj,true)if c9 and gf then bX={c9,ge,gf}break end;gh=gh+75 end;if not c9 then bX=nil end else bX=nil end;ff={}fh=g7:find('identifiedConstructs":%[%]')else fi=g7:find('worksInEnvironment":false')end end;_logCompute.addValue(system.getTime()-fm)end;function fc.UpdateRadar()local gk=coroutine.status(UpdateRadarCoroutine)if gk=="suspended"then local cv,gl=coroutine.resume(UpdateRadarCoroutine)if gl then system.print("ERROR UPDATE RADAR: "..gl)end elseif gk=="dead"then UpdateRadarCoroutine=coroutine.create(fl)local cv,gl=coroutine.resume(UpdateRadarCoroutine)end end;function fc.GetRadarHud()return fh,fi,fg,fj,fk,fd end;UpdateRadarCoroutine=coroutine.create(fl)return fc end;local function gm()local gn=0;local function go(gp)local dn=500000;local gq,gr,gs=math.huge;local gt=false;local gu=vec3({13771471,7435803,-128971})local gv=18000000;gq=vec3(gp):dist(gu)if gq<gv then return true,c(gq-gv),"Safe Zone",0 end;gr=vec3(gp):dist(vec3(planet.center))if gr<dn then gt=true end;if c(gr-dn)<c(gq-gv)then return gt,c(gr-dn),planet.name,planet.bodyId else return gt,c(gq-gv),"Safe Zone",0 end end;local function gw(b_)if aG==1920 then return b_ else return z(aG*b_/1920,0)end end;local function gx(b_)if aH==1080 then return b_ else return z(aH*b_/1080,0)end end;local function gy()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function gz()local gA="TRAVEL"if not bJ then gA="CRUISE"end;if Autopilot then gA="AUTOPILOT"end;return gA end;local function gB(gC,aU,cp,gD,gE,gF,gG,gH)local gI=1;local gJ=2;local gK=3;local gL=4;local gM=5;local gN=6;local gO=""local gP=0;local gQ=fuelY;local gR=fuelY+5;if not BarFuelDisplay then gR=gR+5 end;if l()==1 and not RemoteHud then gQ=gQ-50;gR=gR-50 end;if gE=="ATMO"then gO="atmofueltank"elseif gE=="SPACE"then gO="spacefueltank"else gO="rocketfueltank"end;gP=_G[gO.."_size"]if#gF>0 then for i=1,#gF do local bY=string.sub(gF[i][gJ],1,12)local gS=0;for gT=1,gP do if gF[i][gJ]==f(unit[gO.."_"..gT].getData()).name then gS=gT;break end end;if aU or gG[i]==nil or gH[i]==nil then local gU=0;local gV=0;local gW=0;local gX=0;local gY=p()if gS~=0 then gH[i]=f(unit[gO.."_"..gS].getData()).percentage;gG[i]=f(unit[gO.."_"..gS].getData()).timeLeft;if gG[i]=="n/a"then gG[i]=0 end else gW=k(gF[i][gI])-gF[i][gL]gU=gF[i][gK]gH[i]=d(0.5+gW*100/gU)gV=gF[i][gM]gX=gF[i][gN]if gV<=gW then gG[i]=0 else gG[i]=d(0.5+gW/((gV-gW)/(gY-gX)))end;gF[i][gM]=gW;gF[i][gN]=gY end end;if bY==gD then bY=e("%s %d",gE,i)end;if gS==0 then bY=bY.." *"end;local gZ;if gG[i]==0 then gZ=""else gZ=cM(gG[i])end;if gH[i]~=nil then local g_=d(gH[i]*2.55)local h0=e("rgb(%d,%d,%d)",255-g_,g_,0)local cs=""if gZ~=""and gG[i]<120 or gH[i]<5 then if aU then cs=[[class="red"]]end end;if BarFuelDisplay then table.insert(gC,e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cp,gR,h0,gH[i],cp,gR,cp+2,gR+10,gH[i],gZ))gC[#gC+1]=co(cp,gQ,bY,cs.."txtstart pdim txtfuel")gQ=gQ-30;gR=gR-30 else gC[#gC+1]=co(cp,gQ,bY,cs.." pdim txtfuel")gC[#gC+1]=co(cp,gR,e("%d%% %s",gH[i],gZ),"pdim txtfuel","fill:"..h0)gQ=gQ+30;gR=gR+30 end end end end end;local function h1(gC,dw)if dw<200000 and not aq or dw and aq then local h2=0;if c(bD)>1 then h2=45*math.log(c(bD),10)if bD<0 then h2=-h2 end end;gC[#gC+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bD),d(h2))end;return gC end;local function h3(h4)local h5=-bC;h4=h4-h4:project_on(h5)local h6=vec3(0,0,1)h6=h6-h6:project_on(h5)local h7=h6:cross(h5)local h2=h6:angle_between(h4)*constants.rad2deg;if h4:dot(h7)<0 then h2=360-h2 end;return h2 end;local function h8(gC,centerX,centerY,h9,ha,bV)local hb=circleRad;local hc=20;local hd=d(h9)if bV then for i=-45,45,5 do local he=i;gC[#gC+1]=e([[<g transform="rotate(%f,%d,%d)">]],he,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gC[#gC+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+hb+hc-len,centerX,centerY+hb+hc)end;gC[#gC+1]=co(centerX,centerY+hb+hc-35,ha,"pdim txt txtmid")gC[#gC+1]=co(centerX,centerY+hb+hc-25,hd.." deg","pdim txt txtmid")gC[#gC+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h9,centerX,centerY)gC[#gC+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+hb+hc-20,centerX+5,centerY+hb+hc-20,centerX,centerY+hb+hc-15)gC[#gC+1]="</g>"end;local hf=hd;if bV then hf=h3(by)end;local hg=20;local hh=d(hf)local hi=0;local hj=centerY+hb+hc+20;local hk=centerX;if ha~="YAW"then hj=gx(130)hk=gw(960)end;local hl=[[<path class="txttick line" d="]]local hm=d(hh-(hg+10)-hh%5+0.5)for i=hm+60,hm,-5 do local cp=hk-(-i*5+hf*5)if i%10==0 then hi=10;local A=i;if A==360 then A=0 elseif A>360 then A=A-360 elseif A<0 then A=A+360 end;gC[#gC+1]=co(cp+5,hj-12,A)elseif i%5==0 then hi=5 end;if hi==10 then hl=e([[%s M %f %f v %d]],hl,cp,hj-5,hi)else hl=e([[%s M %f %f v %d]],hl,cp,hj-2.5,hi)end end;gC[#gC+1]=hl..[["/>]]gC[#gC+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],hk-5,hj+10,hk+5,hj+10,hk,hj+5)if bV then ha="HDG"end;gC[#gC+1]=co(hk,hj+25,hh.."deg","pdim txt txtmid","")gC[#gC+1]=co(hk,hj+35,ha,"pdim txt txtmid","")end;local function hn(gC,ho,h9,centerX,centerY,bV,hp,eM)local hb=circleRad;local hq=d(hb*3/5)if hb>0 then local hr=d(ho)local len=0;local hl=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h9,centerX,centerY)if not aq then hl=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gC[#gC+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],hb-1,centerX,centerY)gC[#gC+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(hr-30-hr%5+0.5),d(hr+30+hr%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cq=centerY+-i*5+ho*5;if len==30 then hl=e([[%s M %d %f h %d]],hl,centerX-hq-len,cq,len)if aq then gC[#gC+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h9,centerX,centerY,centerX-hq+10,cq,i)gC[#gC+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h9,centerX,centerY,centerX+hq-10,cq,i)if i==0 or i==180 or i==-180 then gC[#gC+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h9,centerX,centerY,centerX-hq+20,cq,hq*2-40)end else gC[#gC+1]=co(centerX-hq+10,cq,i,"pdim txt txtmid")gC[#gC+1]=co(centerX+hq-10,cq,i,"pdim txt txtmid")end;hl=e([[%s M %d %f h %d]],hl,centerX+hq,cq,len)else hl=e([[%s M %d %f h %d]],hl,centerX-hq-len,cq,len)hl=e([[%s M %d %f h %d]],hl,centerX+hq,cq,len)end end;gC[#gC+1]=hl..[["/>]]local hs="PITCH"if not bV then hs="REL PITCH"end;if ho>90 and not aq then ho=90-(ho-90)elseif ho<-90 and not aq then ho=-90-(ho+90)end;if hb>200 then if aq then if eM>P then gC[#gC+1]=co(centerX,centerY-15,"Yaw","pdim txt txtmid")gC[#gC+1]=co(centerX,centerY+20,hp,"pdim txt txtmid")end;gC[#gC+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h9,centerX,centerY)else gC[#gC+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gC[#gC+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hq+25,centerY-5,centerX-hq+20,centerY,centerX-hq+25,centerY+5,centerX-hq+50,centerY+4,hr)gC[#gC+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hq-25,centerY-5,centerX+hq-20,centerY,centerX+hq-25,centerY+5,centerX+hq-30,centerY+4,hr)gC[#gC+1]="</g>"end;local ht=d(hb/3)gC[#gC+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-ht,centerY,hb-ht)if not aq and bV then gC[#gC+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h9,centerX,centerY,centerX-hq+10,centerY,hq*2-20)end;gC[#gC+1]="</g>"if hb<200 then if aq and eM>P then gC[#gC+1]=co(centerX,centerY-hb,hs,"pdim txt txtmid")gC[#gC+1]=co(centerX,centerY-hb+10,hr,"pdim txt txtmid")gC[#gC+1]=co(centerX,centerY-15,"Yaw","pdim txt txtmid")gC[#gC+1]=co(centerX,centerY+20,hp,"pdim txt txtmid")else gC[#gC+1]=co(centerX,centerY-hb,hs,"pdim txt txtmid")gC[#gC+1]=co(centerX,centerY-hb+15,hr,"pdim txt txtmid")end end end end;local function hu(gC,dw,bV)local hv=altMeterX;local hw=altMeterY;local hx=78;local hy=19;local hz=ao;if ao~=-1 then gC[#gC+1]=co(hv+hx,hw+hy+20,e("AGL: %.1fm",ao),"pdim altsm txtend")end;if bV and(dw<200000 and not aq or dw and aq)then table.insert(gC,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hv-1,hw-4,hx+2,hy+6,hv+1,hw-1,hx-4,hy))local f_=0;local hA=1;local hB=0;local hC=dw<0;local hD=dw<planet.surfaceMaxAltitude;local hE=9;if hC then hE=0 end;local dw=c(dw)while f_<6 do local hF=11;local hG=16;local hH=9;local hI=14;local cs="altsm"if f_>2 then hG=hG+3;hF=hF+2;hI=hI+2;hH=hH-6;cs="altbig"end;if hC then cs=cs.." red"elseif hD then cs=cs.." orange"end;local hJ=dw/hA%10;local hK=d(hJ)local hL=d((hK+1)%10)local hM=hB;if f_==0 then hM=hJ-hK;if hC then hM=1-hM end end;if hC and(f_==0 or hB~=0)then local hN=hL;hL=hK;hK=hN end;local hO=hG*(hM-1)local hP=hO+hG;local cp=hv+hH+(6-f_)*hF;local cq=hw+hI;gC[#gC+1]=co(cp,cq+hO,hL,cs)gC[#gC+1]=co(cp,cq+hP,hK,cs)f_=f_+1;hA=hA*10;if hK==hE then hB=hM else hB=0 end end;table.insert(gC,[[</g></g>]])end end;local function hQ(eP)eP=vec3(eP)local hR=-math.deg(m(eP.y,eP.z))+180;hR=hR-90;if hR<0 then hR=360+hR end;if hR>180 then hR=-180+hR-180 end;return-hR end;local function hS(eP)eP=vec3(eP)local hf=math.deg(m(eP.y,eP.x))-90;if hf<-180 then hf=360+hf end;return hf end;local function hT(gC,eP,eM,centerX,centerY)if eM>5 and not aq or eM>P then local hb=circleRad;local hU=20;local hV=20;local hW=vec3(eP)local hX=hQ(hW)local hY=hS(hW)local hZ=14;local h_=hZ/2;local i0=-hY/hV*hb;local i1=hX/hU*hb;local cp=centerX+i0;local cq=centerY+i1;local ai=x(i0^2+i1^2)local i2=[[<circle
                            cx="]]..cp..[["
                            cy="]]..cq..[["
                            r="]]..h_/hZ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cp..[["
                            cy="]]..cq..[["
                            r="]]..h_..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cp-hZ..[[,]]..cq..[[ h ]]..h_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cp+h_..[[,]]..cq..[[ h ]]..h_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cp..[[,]]..cq-hZ..[[ v ]]..h_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ai<hb then gC[#gC+1]=i2 else local h2=m(i1,i0)local i3=4;local i4=centerX+hb*math.cos(h2)local i5=centerY+hb*math.sin(h2)gC[#gC+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',h2*180/math.pi,i4,i5,i4-i3,i5-i3/2,i3*2,i3,i4+i3,i5-i3,i3,i3,-i3,i3)end;if not aq then hX=hQ(-hW)hY=hS(-hW)i0=-hY/hV*hb;i1=hX/hU*hb;cp=centerX+i0;cq=centerY+i1;ai=x(i0^2+i1^2)if ai<hb then local i6=[[<circle
                                    cx="]]..cp..[["
                                    cy="]]..cq..[["
                                    r="]]..h_..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cp..[[,]]..cq-hZ..[[ v ]]..h_..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cp..[[,]]..cq..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cp..[[,]]..cq..[[)" />
                                <path
                                    d="M ]]..cp-h_..[[,]]..cq..[[ h ]]..hZ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cp..[[,]]..cq..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cp..[[,]]..cq..[[)"/>]]gC[#gC+1]=i6 end end end end;local function i7(gC,gA,i8,i9)i8=d(i8+0.5)local gQ=throtPosY+10;local gR=throtPosY+20;if l()==1 and not RemoteHud then gQ=55;gR=65 end;local ia="CRUISE"local unit="km/h"local cv=i9;if gA=="TRAVEL"or gA=="AUTOPILOT"then ia="THROT"unit="%"cv=i8;local ib="dim"if i8<0 then ib="red"end;gC[#gC+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],ib,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(i8),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gC[#gC+1]=co(throtPosX+10,gQ,ia,"pbright txtstart")gC[#gC+1]=co(throtPosX+10,gR,e("%.0f %s",cv,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bJ and L then i8=d(M*100+0.5)local ib="red"if i8<0 then ib="red"end;gC[#gC+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],ib,1-c(i8),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gC[#gC+1]=co(throtPosX+10,gQ+40,"LIMIT","pbright txtstart")gC[#gC+1]=co(throtPosX+10,gR+40,i8 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gC[#gC+1]=co(throtPosX+10,gQ-40,"LIMIT: "..bh.." km/h","dim txtstart")elseif not aq and Autopilot then gC[#gC+1]=co(throtPosX+10,gQ-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function ic(gC,id)local ie=throtPosY-10;local ig=throtPosX+10;gC[#gC+1]=co(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then ie=75 end;gC[#gC+1]=co(ig,ie,d(id).." km/h","pbright txtbig txtstart")end;local function ih(gC)gC[#gC+1]=co(gw(1900),gx(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gC[#gC+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gC[#gC+1]=co(gw(960),gx(550),"Warning: Invalid Control Scheme Detected","warnings")gC[#gC+1]=co(gw(960),gx(600),"Keyboard Scheme must be selected","warnings")gC[#gC+1]=co(gw(960),gx(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ii=gw(960)local ij=gx(860)local ik=gx(880)local il=gx(900)local im=gx(960)local io=gx(200)local ip=gx(250)local iq=gx(960)if l()==1 and not RemoteHud then ij=gx(135)ik=gx(155)il=gx(175)io=gx(115)ip=gx(95)end;if BrakeIsOn then gC[#gC+1]=co(ii,ij,"Brake Engaged","warnings")elseif K>0 then gC[#gC+1]=co(ii,ij,"Auto-Brake Engaged","warnings","opacity:"..K)end;if aq and bc and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bH and not VertTakeOff and not AutoTakeoff then gC[#gC+1]=co(ii,io+50,"** STALL WARNING **","warnings")cb("stall","SW",2)end end;if bT then gC[#gC+1]=co(ii,io+90,"Flight Assist in Progress","warnings")end;if ax then gC[#gC+1]=co(ii,iq,"Gyro Enabled","warnings")end;if GearExtended then if R then gC[#gC+1]=co(ii,ik,"Gear Extended","warn")else gC[#gC+1]=co(ii,ik,"Landed (G: Takeoff)","warnings")end;local ir=cB(a:getTargetGroundAltitude())gC[#gC+1]=co(ii,il,"Hover Height: "..ir,"warn")end;if a6 then gC[#gC+1]=co(ii,im+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bH and AntigravTargetAltitude~=nil then if c(as-antigrav.getBaseAltitude())<501 then gC[#gC+1]=co(ii,io+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else gC[#gC+1]=co(ii,io+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gC[#gC+1]=co(ii,io+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gC[#gC+1]=co(ii,io+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Z then gC[#gC+1]=co(ii,io+20,"Follow Mode Engaged","warn")elseif Reentry then gC[#gC+1]=co(ii,io+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ir=cB(HoldAltitude,2)if VertTakeOff then if bH then ir=cB(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gC[#gC+1]=co(ii,io,"VTO to "..ir,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gC[#gC+1]=co(ii,io,"Takeoff to "..AutopilotTargetName,"warn")else gC[#gC+1]=co(ii,io,"Takeoff to "..ir,"warn")end;if BrakeIsOn and not VertTakeOff then gC[#gC+1]=co(ii,io+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gC[#gC+1]=co(ii,io,"Altitude Hold: "..ir,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gC[#gC+1]=co(ii,io+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gC[#gC+1]=co(ii,io+20,"Aligning trajectory","warn")elseif ar<0.05 then gC[#gC+1]=co(ii,io+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bj~=nil then gC[#gC+1]=co(ii,io,bj,"warn")end end;if IntruderAlertSystem and safeMass==-1 then gC[#gC+1]=co(ii,io+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bF.."kg DETECTED","warnings")cb("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then gC[#gC+1]=co(ii,io,"Brake-Landing","warnings")else gC[#gC+1]=co(ii,io,"Coast-Landing","warnings")end end;if ProgradeIsOn then gC[#gC+1]=co(ii,io,"Prograde Alignment","crit")end;if RetrogradeIsOn then gC[#gC+1]=co(ii,io,"Retrograde Alignment","crit")end;if bW then local type;if string.find(bW,"COLLISION")then type="warnings"else type="crit"end;gC[#gC+1]=co(ii,ip+20,bW,type)elseif ar==0 then local c6,ca=c4(bA:normalize())if ca~=nil then local ir=cB(ca)local travelTime=b1.computeTravelTime(bB,0,ca)local is="Collision"if c6.noAtmosphericDensityAltitude>0 then is="Atmosphere"end;gC[#gC+1]=co(ii,ip+20,c6.name.." "..is.." "..cM(travelTime).." In "..ir,"crit")end end;if VectorToTarget and not IntoOrbit then gC[#gC+1]=co(ii,io+35,VectorStatus,"warn")end;gC[#gC+1]="</g>"return gC end;local function it(eM)return d(z(eM*3.6,0)+0.5).." km/h"end;local function iu(gC)local iv=OrbitMapX;local iw=OrbitMapY;local ix=OrbitMapSize;local iy=4;local iz=15;local cp=0;local cq=0;local iA,iB,iC,iD;local function iE(type)local iF,C,eM,iG;if type=="Periapsis"then iF=orbit.periapsis.altitude;C=orbit.timeToPeriapsis;eM=orbit.periapsis.speed;iG=35 else iF=orbit.apoapsis.altitude;C=orbit.timeToApoapsis;eM=orbit.apoapsis.speed;iG=-35 end;gC[#gC+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cp+iG,cq-5,iv+ix/2-iA+iD,cq-5)gC[#gC+1]=co(cp,cq,type)cq=cq+iz;local ir=cB(iF)gC[#gC+1]=co(cp,cq,ir)cq=cq+iz;gC[#gC+1]=co(cp,cq,cM(C))cq=cq+iz;gC[#gC+1]=co(cp,cq,it(eM))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then iw=iw+iy;cp=iv+ix+iv/2+iy;cq=iw+ix/2+5+iy;iA=ix/4;iD=0;gC[#gC+1]=[[<g class="pbright txtorb txtmid">]]gC[#gC+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',ix+iv*2,ix+iw,iy,iy)if orbit.periapsis~=nil and orbit.apoapsis~=nil then iC=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(iA*2)iB=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/iC*(1-orbit.eccentricity)iD=iA-orbit.periapsis.altitude/iC-planet.radius/iC;local iH=""if orbit.periapsis.altitude<=0 then iH='redout'end;gC[#gC+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iH,iv+ix/2+iD+iy,iw+ix/2+iy,iA,iB)gC[#gC+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',iv+ix/2+iy,iw+ix/2+iy,planet.radius/iC)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iE("Apoapsis")end;cq=iw+ix/2+5+iy;cp=iv-iv/2+10+iy;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iE("Periapsis")end;gC[#gC+1]=co(iv+ix/2+iy,planet.name,20+iy,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iI=orbit.timeToApoapsis/orbit.period*2*math.pi;local iJ=iA*math.cos(iI)local iK=iB*math.sin(iI)gC[#gC+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',iv+ix/2+iJ+iD+iy,iw+ix/2+iK+iy)end;gC[#gC+1]=[[</g>]]return gC else return gC end end;local function iL(gC)local cp=30;local cq=275;local iM={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local iN={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iO={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iP={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and offset","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if aq then ce(iM,iN)table.insert(iM,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(iM,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ao~=-1 then if antigrav then if bH then table.insert(iM,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iM,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iM,"Alt-6: Begins Vertical Takeoff.")else table.insert(iM,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(iM,"G: Begin BrakeLanding or Land")end else ce(iM,iO)end;if AltitudeHold then table.insert(iM,"Alt-Spacebar/Alt-C will raise/lower target height")end;ce(iM,iP)for i=1,#iM do cq=cq+12;gC[#gC+1]=co(cp,cq,iM[i],"pdim txttick txtstart")end end;local function iQ(iR,iS)local iT;local iU=(iS-iR):normalize()local eR=(bE-iR):dot(iU)/iU:dot(iU)if eR<=0.then return(bE-iR):len()elseif eR>=(iS-iR):len()then return(bE-iS):len()end;local iV=iR+eR*iU;iT=(iV-bE):len()return iT end;local function iW()local iT;local iX=nil;local iY=nil;local iZ=nil;for cV,i_ in pairs(aW[0])do if i_.hasAtmosphere then local ai=iQ(planet.center,i_.center)if iX==nil or ai<iX then iY=i_;iX=ai;iZ=planet end;if ab and ab.hasAtmosphere and ab.name~=planet.name then local eb=iQ(ab.center,i_.center)if eb<iX then iY=i_;iX=eb;iZ=ab end end end end;local j0=gw(1770)local j1=gx(330)if iX then local j2="txttick "local j3=500000;if iX<iY.radius+j3 or iX<iZ.radius+j3 then if bQ then j2="txttick red "else j2="txttick orange "end end;iT=cB(iX,2)bS=co(j0,j1,"Pipe ("..iZ.name.."--"..iY.name.."): "..iT,j2 .."pbright txtmid")end end;local j4;local j5=gw(1770)local j6=gx(350)local j7=gx(15)local j8=gw(1370)local j9,ja;local jb={}function jb.HUDPrologue(gC)bQ,gn,_,_=go(bE)if not bQ then G=PvPR;I=PvPG;H=PvPB else G=SafeR;I=SafeG;H=SafeB end;ay=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]az=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local jc=ay;local jd=az;local je=ay;local jf=az;if gy()and not brightHud then jc=[[rgb(]]..d(G*0.4+0.5)..","..d(I*0.4+0.5)..","..d(H*0.3+0.5)..[[)]]jd=[[rgb(]]..d(G*0.3+0.5)..","..d(I*0.3+0.5)..","..d(H*0.2+0.5)..[[)]]end;gC[#gC+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],jc,jc,je,je,jd,jd,jf,jf,aG,aH)return gC end;function jb.DrawVerticalSpeed(gC,dw)h1(gC,dw)end;function jb.UpdateHud(gC)local dw=as;local eP=core.getVelocity()local eM=vec3(eP):len()local hR=bK;local jg=bL;local h9=jg;local ho=bK;local i8=d(unit.getThrottle())local id=eM*3.6;local i9=unit.getAxisCommandValue(0)local jh=gw(1770)local ji=gx(310)if AtmoSpeedAssist and bJ then i9=J;i8=J*100 end;local gA=gz()local ha="ROLL"if i8==nil then i8=0 end;if not bV then if eM>5 then hR=hQ(eP)jg=hS(eP)else hR=0;jg=0 end;ha="YAW"end;if gn>50000 and not aq then local jj;if gn>200000 then jj=z(gn/200000,2).." su"else jj=z(gn/1000,1).." km"end;gC[#gC+1]=co(jh,ji,"PvP Boundary: "..jj,"pbright txtbig txtmid")end;gC[#gC+1]=aj;gC[#gC+1]=aD;gC[#gC+1]=bR;if bS~=""then gC[#gC+1]=bS end;if aV%aP==0 then aU=true end;if fuelX~=0 and fuelY~=0 then gB(gC,aU,fuelX,"Atmospheric ","ATMO",aI,aS,aT)gB(gC,aU,fuelX+120,"Space fuel t","SPACE",aJ,aQ,aR)gB(gC,aU,fuelX+240,"Rocket fuel ","ROCKET",aK,aN,aO)end;if aU then aU=false;aV=0 end;aV=aV+1;h1(gC,dw)if l()==0 or RemoteHud then if not gy()or brightHud then if bV then h8(gC,centerX,centerY,h9,ha,bV)hn(gC,ho,h9,centerX,centerY,bV,d(hS(eP)),eM)else h8(gC,centerX,centerY,jg,ha,bV)hn(gC,hR,jg,centerX,centerY,bV,d(jg),eM)end;hu(gC,dw,bV)hT(gC,eP,eM,centerX,centerY)end end;i7(gC,gA,i8,i9)ic(gC,id)ih(gC)iu(gC)if showHelp then iL(gC)end;return gC end;function jb.HUDEpilogue(gC)gC[#gC+1]="</svg>"return gC end;function jb.ExtraData(gC)local jk=gw(1240)local jl=gx(55)local jm=jl+10;local jn;local jo=0;local gA=gz()if VertTakeOffEngine then gA=gA.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bB>20 then gA=gA.."-COLLISION ON"end;if TurnBurn then gA="TB-"..gA end;if not stablized then gA=gA.."-DeCoupled"end;local jp=vec3(core.getWorldAcceleration()):len()/9.80665;jn=core.g()gC[#gC+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then jk=gw(1120)jl=gx(55)jm=jl+10 elseif aq then local jq=gw(770)gC[#gC+1]=co(jq,jl,"ATMOSPHERE","pdim txt txtend")gC[#gC+1]=co(jq,jm,e("%.2f",ar),"pdim txt txtend","")end;gC[#gC+1]=co(jk,jl,"GRAVITY","pdim txt txtend")gC[#gC+1]=co(jk,jm,e("%.2f",jn/9.80665),"pdim txt txtend")gC[#gC+1]=co(jk,jl+20,"ACCEL","pdim txt txtend")gC[#gC+1]=co(jk,jm+20,e("%.2f",jp),"pdim txt txtend")gC[#gC+1]=co(gw(960),gx(180),gA,"txtbig txtmid")end;function jb.DrawOdometer(gC,ac,TotalDistanceTravelled,ad)local jn;local jr=0;local js=0;local jo=0;if aq then jo=LastMaxBrakeInAtmo else jo=LastMaxBrake end;maxThrust=a:maxForceForward()jn=core.g()if jn>0.1 then js=av*jn;jr=maxThrust/jn end;gC[#gC+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gw(660),gw(700),gx(35),gw(960),gx(55),gw(1240),gx(35),gw(1280))if l()==0 or RemoteHud then gC[#gC+1]=co(gw(700),gx(20),e("Trip: %.2f km",ac),"txtstart")gC[#gC+1]=co(gw(700),gx(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gC[#gC+1]=co(gw(830),gx(20),"Trip Time: "..cM(ad),"txtstart")gC[#gC+1]=co(gw(830),gx(30),"Total Time: "..cM(TotalFlightTime),"txtstart")gC[#gC+1]=co(gw(970),gx(20),e("Mass: %.2f Tons",av/1000),"txtstart")gC[#gC+1]=co(gw(1240),gx(10),e("Max Brake: %.2f kN",jo/1000),"txtend")gC[#gC+1]=co(gw(1240),gx(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if jn>0.1 then gC[#gC+1]=co(gw(970),gx(30),e("Max Mass: %.2f Tons",jr/1000),"txtstart")gC[#gC+1]=co(gw(1240),gx(20),e("Req Thrust: %.2f kN",js/1000),"txtend")else gC[#gC+1]=co(gw(970),gx(30),"Max Mass: n/a","txtstart")gC[#gC+1]=co(gw(1240),gx(20),"Req Thrust: n/a","txtend")end end;gC[#gC+1]="</g>"return gC end;function jb.DrawWarnings(gC)return ih(gC)end;function jb.DisplayOrbitScreen(gC)return iu(gC)end;function jb.DisplayMessage(gC,ir)if ir~="empty"then local cq=310;for jt in string.gmatch(ir,"([^\n]+)")do cq=cq+35;gC[#gC+1]=co("50%",cq,jt,"msg")end end;if ah~=0 then unit.setTimer("msgTick",ah)ah=0 end end;function jb.DrawDeadZone(gC)gC[#gC+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function jb.UpdatePipe()if aq then bS=""return end;iW()end;function jb.DrawSettings(gC)if#bN>0 then local cp=gw(640)local cq=gx(200)gC[#gC+1]=[[<g class="pbright txtvspd txtstart">]]for cV,b_ in pairs(bN)do gC[#gC+1]=co(cp,cq,b_..": ".._G[b_])cq=cq+20;if cV%12==0 then cp=cp+gw(350)cq=gx(200)end end;gC[#gC+1]=co(gw(640),gx(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gC[#gC+1]="</g>"end;return gC end;function jb.DrawRadarInfo()local function ju()if radarPanelID~=nil and ak==0 then s(radarPanelID)radarPanelID=nil;if j4~=nil then s(j4)j4=nil end else if ak==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")j4=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;ak=0 end end;local fh,fi,fg,fj,fk,fd=b7.GetRadarHud()if fg>0 then if CollisionSystem then j9=fj.."/"..fk.." Plotted : "..fg-fk.." Ignored"else j9="Radar Contacts: "..fg end;bR=co(j5,j6,j9,"pbright txtbig txtmid")if#fd>0 then bR=bR..co(j8,j7,"Friendlies In Range","pbright txtbig txtmid")for cV,b_ in pairs(fd)do j7=j7+20;bR=bR..co(j8,j7,radar_1.getConstructName(b_),"pdim txtmid")end;fd={}end;if fh==nil and j4==nil then ak=1;ju()end;if fh~=nil and j4~=nil then ju()end;if radarPanelID==nil then ju()end else if fi then bR=co(j5,j6,"Radar: Jammed","pbright txtbig txtmid")else bR=co(j5,j6,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ak=0;ju()end end end;return jb end;local function jv()local function jw(position)local dr=sys:closestBody(position)if(position-dr.center):len()>dr.radius+dr.noAtmosphericDensityAltitude then dr=aW[0][0]end;return dr end;local function jx()local function jy(jz,jA)return jz.name<jA.name end;bP={}for cV,b_ in pairs(aW[0])do bP[#bP+1]={name=b_.name,index=cV}end;table.sort(bP,jy)end;local function jB(jC)for cV,b_ in pairs(jC)do if b_.name and b_.name==CustomTarget.name then return cV end end;return-1 end;local function jD()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ab=nil;CustomTarget=nil;return true end;local jE=bP[AutopilotTargetIndex].index;local jF=aW[0][jE]if jF.center then AutopilotTargetName=jF.name;ab=b0[0][jE]if CustomTarget~=nil then if ar==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jF;for _,b_ in pairs(b0[0])do if b_.name==CustomTarget.planetname then ab=b_;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ab.center)else AutopilotTargetCoords=CustomTarget.position end;if ab.planetname~="Space"then if ab.hasAtmosphere then AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=b3(ab):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jG(h5)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if h5==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bP then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bP end end;if AutopilotTargetIndex==0 then jD()else local jE=bP[AutopilotTargetIndex].index;local jF=aW[0][jE]if jF.name=="Space"or iphCondition=="Custom Only"and jF.center or iphCondition=="No Moons"and string.find(jF.name,"Moon")~=nil then if h5==nil then jG()else jG(1)end else jD()end end else a1="Disengage autopilot before changing Interplanetary Helper"cb("iph","AP")end end;local function jH()local f_=-1;f_=jB(aW[0])if f_>-1 then table.remove(aW[0],f_)end;f_=-1;f_=jB(SavedLocations)if f_~=-1 then a1=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,f_)end;jG()jx()end;local function jI(bY,position,hN,gt)if dbHud_1 or hN then local dr=jw(position)local jn=dr.gravity;local jJ=dr.atmosphericDensityAboveSurface;if gt then jJ=ar;jn=unit.getClosestPlanetInfluence()end;local jK={position=position,name=bY,atmosphere=jJ,planetname=dr.name,gravity=jn,safe=gt}if not hN then SavedLocations[#SavedLocations+1]=jK else for cV,b_ in pairs(aW[0])do if b_.name and bY==b_.name then table.remove(aW[0],cV)end end end;table.insert(aW[0],jK)jx()jD()a1="Location saved as "..bY.."("..dr.name..")"else a1="Databank must be installed to save permanent locations"end end;local cW={}function cW.UpdateAtlasLocationsList()jx()end;function cW.UpdateAutopilotTarget()jD()end;function cW.adjustAutopilotTargetIndex(h5)jG(h5)end;function cW.findAtlasIndex(jC)jB(jC)end;function cW.UpdatePosition(jL)local f_=jB(SavedLocations)if f_~=-1 then if jL~=nil then SavedLocations[f_].name=jL else local jM=SavedLocations[f_]jH()jI(jM.name,bE,false,true)end;a1=SavedLocations[f_].name.." position updated ("..SavedLocations[f_].planetname..")"else a1="Name Not Found"end end;function cW.AddNewLocation(bY,position,hN,gt)jI(bY,position,hN,gt)end;function cW.ClearCurrentPosition()jH()end;for cV,b_ in pairs(SavedLocations)do table.insert(aW[0],b_)end;jx()cW.UpdateAutopilotTarget()return cW end;local function jN()local jO={}local function jP(eM)local jQ=AutopilotEndSpeed;if not Autopilot then jQ=0 end;if not aq then return b1.computeDistanceAndTime(eM,jQ,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b1.computeDistanceAndTime(eM,jQ,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jR(eM)local jQ=AutopilotEndSpeed;if not Autopilot then jQ=0 end;return b1.computeDistanceAndTime(eM,jQ,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local jS=false;function jO.GetAutopilotBrakeDistanceAndTime(eM)return jP(eM)end;function jO.GetAutopilotTBBrakeDistanceAndTime(eM)return jR(eM)end;local function jT(jU,jV,jW)jV=jV:project_on_plane(jU)jW=jW:project_on_plane(jU)return m(jV:cross(jW):dot(jU),jV:dot(jW))end;local function jX()local function jY()local jZ=-1;local j_=-1;if vBooster then jZ=vBooster.distance()end;if hover then j_=hover.distance()end;if jZ~=-1 and j_~=-1 then if jZ<j_ then return jZ else return j_ end elseif jZ~=-1 then return jZ elseif j_~=-1 then return j_ else return-1 end end;local k0=jY()local k1=-1;if telemeter_1 then k1=telemeter_1.getDistance()end;if k0~=-1 and k1~=-1 then if k0<k1 then return k0 else return k1 end elseif k0~=-1 then return k0 else return k1 end end;local function k2(planet,e7,k3)local function k4(k5,dp)local ed=vec3(dp)if k5.bodyId==0 then return setmetatable({latitude=ed.x,longitude=ed.y,altitude=ed.z,bodyId=0,systemId=k5.planetarySystemId},MapPosition)end;local ee=ed-k5.center;local ai=ee:len()local dw=ai-k5.radius;local du=0;local dv=0;if not cy(ai,0)then local ef=m(ee.y,ee.x)dv=ef>=0 and ef or 2*math.pi+ef;du=math.pi/2-math.acos(ee.z/ai)end;return setmetatable({latitude=math.deg(du),longitude=math.deg(dv),altitude=dw,bodyId=k5.bodyId,systemId=k5.planetarySystemId},MapPosition)end;local k6=k4(planet,e7)k6="::pos{"..k6.systemId..","..k6.bodyId..","..k6.latitude..","..k6.longitude..","..k6.altitude.."}"if k3 then return k6 else system.setWaypoint(k6)return true end end;local k7=false;function jO.showWayPoint(planet,e7,k3)return k2(planet,e7,k3)end;function jO.APTick()local function k8()if bX and not BrakeLanding then local c9=bX[1]local ge,gf=bX[2],bX[3]local k9=math.min(ge,gf or ge)local ka=k9/bB;if(AltitudeHold or VectorToTarget or LockPitch or Autopilot)and not AutoTakeoff and(a7*1.5>k9 or ka<1)then BrakeIsOn=true;cu(0)if AltitudeHold then cG()end;if LockPitch then ToggleLockPitch()end;a1="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cH()end;StrongBrakes=true;BrakeLanding=true;ba=true end;if ka<11 then bW=c9.name.." COLLISION "..cM(ka).." / "..cB(k9,2)else bW=c9.name.." collision "..cM(ka)end;if ka<6 then cb("alarm","AL",2)end else bW=false end end;local function kb(c5,kc,kd)local function ke(c5,dU)c5=vec3(c5)dU=vec3(dU):normalize()local da=c5*dU;return da.x+da.y+da.z end;local kf=0.001;local kg=1;if not aq or not bc or ao~=-1 or bB<P then if kd==nil then kd=DampingMultiplier end;if kc==nil then kc=kf end;c5=vec3(c5):normalize()local kh=vec3()-c5;local ki=-ke(kh,core.getConstructWorldOrientationRight())*kg;local kj=-ke(kh,core.getConstructWorldOrientationUp())*kg;if aB==0 then aB=ki/2 end;if aC==0 then aC=kj/2 end;if c(ki)<0.1 then U=U-ki*2 else U=U-(ki+(ki-aB)*kd)end;if c(kj)<0.1 then T=T+kj*2 else T=T+kj+(kj-aC)*kd end;aB=ki;aC=kj;if c(ki)<kc and c(kj)<kc then return true end;return false elseif bc and ao==-1 then c5=bA;if kd==nil then kd=DampingMultiplier end;if kc==nil then kc=kf end;c5=vec3(c5):normalize()local kh=by-c5;local ki=-ke(kh,core.getConstructWorldOrientationRight())*kg;local kj=-ke(kh,core.getConstructWorldOrientationUp())*kg;if aB==0 then aB=ki/2 end;if aC==0 then aC=kj/2 end;if c(ki)<0.1 then U=U-ki*5 else U=U-(ki+(ki-aB)*kd)end;if c(kj)<0.1 then T=T+kj*5 else T=T+kj+(kj-aC)*kd end;aB=ki;aC=kj;if c(ki)<kc and c(kj)<kc then return true end;return false end end;aq=j()>0;ar=j()as=core.getAltitude()ao=jX()C=p()bd=C;bV=unit.getClosestPlanetInfluence()>0;if CollisionSystem then k8()end;if antigrav then bH=antigrav.getState()==1 end;local kk=1;local kl=1;local km=C-bd;local kn=-math.deg(jT(bx,bA,by))local ko=math.deg(jT(bz,bA,by))local h5=bC*-1;bc=aq and kn<-YawStallAngle or kn>YawStallAngle or ko<-PitchStallAngle or ko>PitchStallAngle;local kp=system.getMouseDeltaX()local kq=system.getMouseDeltaY()if InvertMouse and not a0 then kq=-kq end;U=0;Y=0;T=0;sys=b0[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=b3(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bA)if as==0 then as=(bE-planet.center):len()-planet.radius end;local jn=planet:getGravity(core.getConstructWorldPos()):len()*av;be=0;b2=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and a0 then if not b8 then af=af+kp;ag=ag+kq end else af=0;ag=0 end else af=af+kp;ag=ag+kq;ai=x(af*af+ag*ag)if not a0 and l()==0 then if userControlScheme=="virtual joystick"then if af>0 and af>DeadZone then U=U-(af-DeadZone)*MouseXSensitivity elseif af<0 and af<DeadZone*-1 then U=U-(af+DeadZone)*MouseXSensitivity else U=0 end;if ag>0 and ag>DeadZone then T=T-(ag-DeadZone)*MouseYSensitivity elseif ag<0 and ag<DeadZone*-1 then T=T-(ag+DeadZone)*MouseYSensitivity else T=0 end else af=0;ag=0;if userControlScheme=="mouse"then T=(-utils.smoothstep(kq,-100,100)+0.5)*2*kk;U=(-utils.smoothstep(kp,-100,100)+0.5)*2*kl end end end end;local kr=bB>8334;if bB>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not kr then a1="Space Speed Engine Shutoff reached"cu(0)end;if not kr and LastIsWarping then if not BrakeIsOn then cJ()end;if Autopilot then cH()end end;LastIsWarping=kr;if aq and ar>0.09 then if bB>bh/3.6 and not AtmoSpeedAssist and not jS then BrakeIsOn=true;jS=true elseif not AtmoSpeedAssist and jS then if bB<bh/3.6 then BrakeIsOn=false;jS=false end end end;if BrakeIsOn then X=1 else X=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local ks=false;if CustomTarget~=nil then ks=kb(CustomTarget.position-bE,0.1)else ks=kb(vec3(bA),0.01)end;ba=true;if ks then cx(d(bh))if(c(bL)<2 or c(bK)>85)and bB>=bh/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;Q=true;al=false;an=true;Autopilot=false;cK()end elseif aq and AtmoSpeedAssist then cu(1)end elseif bB>P then kb(vec3(bA),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bB>P then kb(-vec3(bA))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then Q=true;cK()al=false;an=true else al=false;cH()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bB*3.6>bh-250 and c(bD)<25 and ar>=0.1 and(CustomTarget.position-bE):len()>2000+as then cH()an=false end;if VertTakeOff then ba=true;local kt=HoldAltitude;if bD<-30 then a1="Unable to achieve lift. Safety Landing."ae=0;ba=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bH or HoldAltitude<planet.spaceEngineMinAltitude then if bH then kt=antigrav.getBaseAltitude()end;if as<kt-100 then bi=0;ae=15;BrakeIsOn=false elseif bD>0 then BrakeIsOn=true;ae=0 elseif bD<-30 then BrakeIsOn=true;ae=15 elseif as>=kt then if bH then if Autopilot or VectorToTarget then cE()else BrakeIsOn=true;VertTakeOff=false end;a1="Takeoff complete. Singularity engaged"cb("aggLk","AG")else BrakeIsOn=false;a1="VTO complete. Engaging Horizontal Flight"cb("vtoc","VT")cE()end;ae=0 end else if ar>0.08 then bi=0;BrakeIsOn=false;ae=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bu then bi=0;ae=20 else ae=0;bi=36;cx(3500)end else ba=autoRollPreference;IntoOrbit=true;bs=false;CancelIntoOrbit=false;bm=false;bk=nil;bl=nil;if br==nil then br=planet end;bq=kt;bp=true;VertTakeOff=false end end;if bi~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ku=q(bi-bK,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ku)local kv=q(vTpitchPID:get(),-1,1)T=kv end end;if IntoOrbit then local kh;local kw=false;local kx=cB(bq)if br==nil then br=planet;if VectorToTarget then br=ab end end;if not bp then bq=d(br.radius+br.surfaceMaxAltitude+LowOrbitHeight)if br.hasAtmosphere then bq=d(br.radius+br.noAtmosphericDensityAltitude+LowOrbitHeight)end;bp=true end;if bo.VectorToTarget then kh=CustomTarget.position-bE end;local ky,kz=b3(br):escapeAndOrbitalSpeed((bE-br.center):len()-br.radius)local kA=bL;if not bm then local kB=false;local kC=false;cu(0)bl=0;bj="Aligning to orbital path - OrbitHeight: "..kx;if bo.VectorToTarget then kb(kh:normalize():project_on_plane(bC))kw=by:dot(kh:project_on_plane(bx):normalize())>0.95 else kb(bA)kw=kn<0.5;if bB<150 then kw=true end end;T=0;bk=0;if bK<=bk+1 and bK>=bk-1 then kB=true else kB=false end;if kA<=bl+1 and kA>=bl-1 then kC=true else kC=false end;if kB and kC and kw then bk=nil;bl=nil;bm=true end else if bo.VectorToTarget then kb(kh:normalize():project_on_plane(bC))elseif bB>150 then kb(bA)end;T=0;if bo.VectorToTarget then local a7,_=b1.computeDistanceAndTime(bB,bh/3.6,av,0,0,LastMaxBrake)if bs and kh:len()>15000+a7+as then bj="Orbiting to Target"if as-100<=br.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<br.noAtmosphericDensityAltitude then bs=false end elseif bs or kh:len()<15000+a7+as then a1="Orbit complete, proceeding with reentry"cb("orCom","OB")AutopilotTargetCoords=CustomTarget.position;Q=true;an=true;bo.VectorToTarget,bo.AutopilotAlign=false,false;cF()cK()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bq*0.9 and as<bq*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bq*0.99 and orbit.apoapsis.altitude>=bq*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bs then if bs then BrakeIsOn=false;cu(0)bk=0;if not bo.VectorToTarget then a1="Orbit complete"cb("orCom","OB")cF()end else bw=bw+1;if bw>=2 then bs=true end end else bj="Adjusting Orbit - OrbitHeight: "..kx;bn=true;cx(kz*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kD=bD;local kE=as-bq;local kF=c(kE)if bD<10 and c(bK)<10 and kF<100 then kD=bD*2 end;if kD<10 and c(bK)<10 and kF<100 then kD=kD*2 end;if kD<5 and c(bK)<5 and kF<100 then kD=kD*4 end;VSpdPID:inject(kD)bk=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kE)bk=q(bk-q(OrbitAltPID:get(),-15,15),-90,90)end end else local kG=2.75;local kH=c(o(ky*kG))local kI=kH%50;if kI>0 then kH=kH-kI+50 end;BrakeIsOn=false;if as<bq*0.8 then bj="Escaping planet gravity - OrbitHeight: "..kx;bk=utils.map(bD,200,0,-15,80)elseif as>=bq*0.8 and as<bq*1.15 then bj="Approaching orbital corridor - OrbitHeight: "..kx;kH=kH*0.75;bk=utils.map(bD,100,-100,-15,65)elseif as>=bq*1.15 and as<bq*1.5 then bj="Approaching orbital corridor - OrbitHeight: "..kx;kH=kH*0.75;if bD<0 or bn then bk=utils.map(as,bq*1.5,bq*1.01,-30,0)else bk=utils.map(as,bq*0.99,bq*1.5,0,30)end elseif as>bq*1.5 then bj="Reentering orbital corridor - OrbitHeight: "..kx;bk=-65;local kJ=utils.map(bD,-150,-400,1,0.55)kH=kH*kJ end;cx(d(kH))end end;if bk~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kK=bk-bK;OrbitPitchPID:inject(kK)local kL=q(OrbitPitchPID:get(),-0.5,0.5)T=kL end end;if Autopilot and ar==0 and not al then local function kM(j9,orbit)system.print(j9)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cu(0)O=false;a1=j9;cb("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bq=as;bp=true end;cF()end end;local kN,kO=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kP=(CustomTarget.position-ab.center):normalize()local kQ=kP:project_on_plane((ab.center-bE):normalize()):normalize()local kR=ab.center+kQ*(ab.radius+AutopilotTargetOrbit)local kS=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))if(bE-kR):len()<(bE-kS):len()then kN=kR else kN=kS;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kN;b6.showWayPoint(ab,AutopilotTargetCoords)kO=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kO=true;TargetSet=true;AutopilotRealigned=true;kN=CustomTarget.position+(bE-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kP=(bE+bA*100000-ab.center):normalize()local kQ=kP:project_on_plane((ab.center-bE):normalize()):normalize()if kQ:len()<1 then kP=(bE+by*100000-ab.center):normalize()kQ=kP:project_on_plane((ab.center-bE):normalize()):normalize()end;kN=ab.center+kQ*(ab.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kN;TargetSet=true;kO=true;AutopilotRealigned=true;b6.showWayPoint(ab,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kN)-bE):len()local c6,c7,c8=b0:getPlanetarySystem(0):castIntersections(bE,bA:normalize(),function(c9)if c9.noAtmosphericDensityAltitude>0 then return c9.radius+c9.noAtmosphericDensityAltitude else return c9.radius+c9.surfaceMaxAltitude*1.5 end end)local ca=c7;if c8~=nil and c7~=nil then ca=math.min(c8,c7)end;if ca~=nil and ca<AutopilotDistance and c6.name==ab.name then AutopilotDistance=ca end;local ks=true;local kT=(ab.center-(bE+vec3(bA):normalize()*AutopilotDistance)):len()-ab.radius;local ir=cB(kT)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ir..'"}')local a7,a8;if not TurnBurn then a7,a8=jP(bB)else a7,a8=jR(bB)end;if bB>300 and AutopilotAccelerating then local kh=vec3(kN)-bE;local kU=q(math.deg(jT(bx,bA:normalize(),kh:normalize()))*bB/500,-90,90)local kV=q(math.deg(jT(bz,bA:normalize(),kh:normalize()))*bB/500,-90,90)if c(kU)<20 and c(kV)<20 then kU=kU*2;kV=kV*2 end;if c(kU)<2 and c(kV)<2 then kU=kU*2;kV=kV*2 end;local kn=-math.deg(jT(bx,by,bA:normalize()))local ko=-math.deg(jT(bz,by,bA:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kV-ko)local kW=q(apPitchPID:get(),-1,1)T=T+kW;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kU-kn)local kX=q(apYawPID:get(),-1,1)U=U+kX;kO=true;if c(kU)>2 or c(kV)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"cb("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end end end;if kT<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=b3(ab):escapeAndOrbitalSpeed(kT)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local c6,ca=c4((AutopilotTargetCoords-bE):normalize())if ab.name~=planet.name then if c6~=nil then a1="Collision with "..c6.name.." in "..cB(ca).."\nClear LOS to continue."ah=5;k7=true else k7=false;a1=""end end end;if not k7 then if not AutopilotCruising and not AutopilotBraking and not kO then ks=kb((kN-bE):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then ks=kb(-vec3(bA):normalize())end end;if AutopilotAccelerating then if not O then BrakeIsOn=false;cu(AutopilotInterplanetaryThrottle)J=z(AutopilotInterplanetaryThrottle,2)O=true end;local kY=unit.getThrottle()if AtmoSpeedAssist then kY=J end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or kY==0 and O then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then cb("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cu(0)end;if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then cb("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cu(0)O=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;X=1 end;if TurnBurn then cu(1,true)end;local _,kz=b3(ab):escapeAndOrbitalSpeed((bE-planet.center):len()-planet.radius)local kh;if CustomTarget~=nil then kh=CustomTarget.position-bE end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bB<50 then kM("Autopilot complete, arrived at space location")BrakeIsOn=true;X=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bB<=kz and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kM("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;b6.showWayPoint(ab,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then cb("apCir","AP")AutopilotStatus="Circularizing"end;if bB<=kz then if CustomTarget~=nil then if bA:normalize():dot(kh:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then cb("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;b6.showWayPoint(ab,CustomTarget.position)WaypointSet=true end else kM("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;b6.showWayPoint(ab,CustomTarget.position)WaypointSet=false end else kM("Autopilot completed, setting orbit",true)X=0 end end elseif AutopilotStatus=="Circularizing"then kM("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then cb("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kY=unit.getThrottle()if AtmoSpeedAssist then kY=J end;if kY>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end;AutopilotCruising=false end else if ks then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ab.center)+(AutopilotTargetOrbit+ab.radius)*bz;AutopilotShipUp=bx;AutopilotShipRight=bz end;AutopilotRealigned=true elseif ks and not k7 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end;if not O then cu(AutopilotInterplanetaryThrottle,true)J=z(AutopilotInterplanetaryThrottle,2)O=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a1="Autopilot complete, proceeding with reentry"cb("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"X=0;cu(0)O=false;ProgradeIsOn=true;al=true;b6.showWayPoint(ab,CustomTarget.position)end;if Z then ba=true;local kV=0;local eQ=bE+vec3(unit.getMasterPlayerRelativePosition())local kZ=eQ-bE;local k_=vec3(kZ):project_on(by):len()local l0=vec3(kZ):project_on(bz):len()local ai=x(k_*k_+l0*l0)kb(kZ:normalize())local l1=40;local l2=ai<l1;local l3=100;local l4=q((ai-l1)/2,10,l3)T=0;local ks=c(U)<0.1;if ks and bB<l4 and not l2 then BrakeIsOn=false;kV=-20 else BrakeIsOn=true;kV=0 end;local l5=0;if c(kV-bK)>l5 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kV-bK)local kW=pitchPID:get()T=kW end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l6=LastMaxBrakeInAtmo;if l6 then l6=l6*q(bB/100,0.1,1)*ar else l6=LastMaxBrake end;if ar<0.01 then l6=LastMaxBrake end;local l7=vec3(core.getWorldAirFrictionAcceleration())local l8=x(l7:len()-l7:project_on(h5):len())*av;if bB>100 then a7,a8=b1.computeDistanceAndTime(bB,100,av,0,0,l6+l8)local l9,la=b1.computeDistanceAndTime(100,0,av,0,0,l6/2)a7=a7+l9 else a7,a8=b1.computeDistanceAndTime(bB,0,av,0,0,l6/2)end;local lb=HoldAltitude-as;local lc=500+bB;local ld=1;if AutoTakeoff then ld=q(bB/100,0.1,1)end;local kV=(utils.smoothstep(lb,-lc,lc)-0.5)*2*MaxPitch*ld;if not Reentry and not al and not VectorToTarget and by:dot(bA:normalize())<0.99 then kV=(utils.smoothstep(lb,-lc*q(20-19*ar*10,1,20),lc*q(20-19*ar*10,1,20))-0.5)*2*MaxPitch*q(2-ar*10,1,2)*ld end;if not AltitudeHold then kV=0 end;if LockPitch~=nil then if bV and not IntoOrbit then kV=LockPitch else LockPitch=nil end end;ba=true;local le=T;if Reentry then local lf=d(bh)local lg,lh=b1.computeDistanceAndTime(bB,lf/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)local li=as-(planet.noAtmosphericDensityAltitude+5000)if not bJ and as>planet.noAtmosphericDensityAltitude+5000 and bB<=lf/3.6 and bB>lf/3.6-10 and c(bA:normalize():dot(by))>0.9 then cu(0)elseif bJ and bB>lf/3.6 and(lg>-1 and li<=lg or as<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cx(lf,true)if not Q then kV=-80;if ar>0.02 then a1="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kV=0;ba=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and as>planet.noAtmosphericDensityAltitude+5000 then ba=true elseif as<=planet.noAtmosphericDensityAltitude+5000 then cx(lf)if not bJ and r:getTargetSpeed(axisCommandId.longitudinal)==bh then Q=false;Reentry=false;ba=true end end end;if bB>P and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then kb(vec3(bA))end;if bT or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local kh;if bT then if type(bT)=="table"then kh=bT elseif bT<3 and bT>0 then kh=-bC:cross(bA)*5000 elseif bT>=3 then kh=bC:cross(bA)*5000 elseif bT<0 then kh=bA*25000 end elseif CustomTarget~=nil then kh=CustomTarget.position-bE else kh=ab.center-bE end;local kU=math.deg(jT(bC:normalize(),bA,kh))*2;local lj=math.rad(c(bL))if bB>minRollVelocity and ar>0.01 then local lk=q(90-kV*2,-90,90)be=q(kU*2,-lk,lk)local ll=kU;kU=q(q(kU,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(lj)+4*(bK-kV)*math.sin(math.rad(bL)),-YawStallAngle*0.80,YawStallAngle*0.80)kV=q(q(kV*math.cos(lj),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(ll)*math.sin(lj),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else be=0;kU=q(kU,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lm=kn-kU;if bT and c(lm)<=0.0001 and(type(bT)=="table"or type(bT)~="table"and bT<0 and c(bL)<1)then if bT==-2 then cG()end;bT=nil;cb("180Off","BR")return end;if not bc and bB>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lm)local kX=q(yawPID:get(),-1,1)U=U+kX elseif aq and ao>-1 or bB<minRollVelocity then kb(kh)elseif bc and ar>0.01 then if(kn<-YawStallAngle or kn>YawStallAngle)and ar>0.01 then kb(bA)end;if(ko<-PitchStallAngle or ko>PitchStallAngle)and ar>0.01 then kV=q(bK-ko,bK-PitchStallAngle*0.80,bK+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local kt=planet:getAltitude(CustomTarget.position)local li=x(kh:len()^2-(as-kt)^2)local ln=bA:len()-c(bD)StrongBrakes=true;if not am and not Reentry and li<=a7+bB*km/2 and(bA:project_on_plane(bC):normalize():dot(kh:project_on_plane(bC):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cu(0)if AltitudeHold then cG()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(ln<0.1 or li<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<li)then if not bH then cb("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bW=false end;LastDistanceToTarget=li end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ab.name==planet.name then local kh=CustomTarget.position-bE;local kt=planet:getAltitude(CustomTarget.position)local li=x(kh:len()^2-(as-kt)^2)local l6=LastMaxBrakeInAtmo;if l6 then a7,a8=b1.computeDistanceAndTime(bB,0,av,0,0,l6/2)StrongBrakes=true;if li<=a7+bB*km/2 and bA:project_on_plane(bC):normalize():dot(kh:project_on_plane(bC):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;Q=true;al=false;an=true;Autopilot=false;cK()end end;LastDistanceToTarget=li end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bs and not IntoOrbit then bq=HoldAltitude;bp=true;if VectorToTarget then bo.VectorToTarget=true end;cF()VectorToTarget=false;bm=true end end;if bc and ar>0.01 and ao==-1 and bB>minRollVelocity and VectorStatus~="Finalizing Approach"then kb(bA)kV=q(bK-ko,bK-PitchStallAngle*0.80,bK+PitchStallAngle*0.80)end;T=le;local k1=-1;if BrakeLanding then kV=0;local lo=false;local lp=30;if b2~=nil and b2>0 then local lq=q(ar,0.4,2)local l6=LastMaxBrakeInAtmo*q(bB/100,0.1,1)*lq;local lr=b2*lq+l6-jn;local ls=l6/2-jn;local lt=bB-x(c(ls/2)*20/(0.5*av))*utils.sign(ls)if lt<0 then lt=0 end;local lu;if bB>100 then local lv,_=b1.computeDistanceAndTime(bB,100,av,0,0,l6)local lw,_=b1.computeDistanceAndTime(100,0,av,0,0,x(l6))lu=lv+lw else lu=b1.computeDistanceAndTime(bB,0,av,0,0,x(l6))end;if lu<20 then BrakeIsOn=false else local lx=0;if lt>100 then local ly,_=b1.computeDistanceAndTime(lt,100,av,0,0,lr)local lz,_=b1.computeDistanceAndTime(100,0,av,0,0,b2*lq+x(l6)-jn)lx=ly+lz else lx,_=b1.computeDistanceAndTime(lt,0,av,0,0,b2*lq+x(l6)-jn)end;lx=(lx+15+bB*km)*1.1;local lA=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lA then local kt=planet:getAltitude(CustomTarget.position)local lB=as-kt-100;local kh=CustomTarget.position-bE;local lC=x(kh:len()^2-(as-kt)^2)if lC>100 then lA=false elseif lB<=lx or lx==-1 then BrakeIsOn=true;lo=true else BrakeIsOn=false;lo=true end end;if not lA and CalculateBrakeLandingSpeed then if lx>=lp then BrakeIsOn=true else BrakeIsOn=false end;lo=true end end end;if not bJ then cu(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)stablized=true;k1=ao;if k1>-1 then ba=autoRollPreference;if bB<1 or bA:normalize():dot(bC)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if R then a.control.extendLandingGears()cb("grOut","LG",1)end;r:setTargetGroundAltitude(LandingGearGroundHeight)ae=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bA:normalize():dot(-h5)<0.999 then BrakeIsOn=true elseif bD<-brakeLandingRate and not lo then BrakeIsOn=true elseif not lo then BrakeIsOn=false end end;if AutoTakeoff or am then local c6,c8,c7;if AutopilotTargetCoords~=nil then c6,c8,c7=b0:getPlanetarySystem(0):castIntersections(bE,(AutopilotTargetCoords-bE):normalize(),function(c9)return c9.radius+c9.noAtmosphericDensityAltitude end)end;if bH then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cu(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kV)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bJ and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bB<P then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cu(0)elseif am then cu(0)BrakeIsOn=true end elseif am and ar==0 and ab~=nil and(c6==nil or c6.name==ab.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bJ then cu(0)end;AutopilotAccelerating=true end end;local lD=ao>-1;local lE=bK;if(VectorToTarget or am or bT)and not lD and bB>minRollVelocity and ar>0.01 then local lj=math.rad(c(bL))lE=bK*c(math.cos(lj))+ko*math.sin(lj)end;local lF=q(kV-lE,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then lF=q(kV-lE,-85,MaxPitch)elseif ar<0.01 then lF=q(kV-lE,-MaxPitch,MaxPitch)end;if c(bL)<5 or VectorToTarget or bT or BrakeLanding or lD or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lF)local kW=pitchPID:get()T=T+kW end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=jX()return jO end;function script.onStart()local lG={}local lH={}local lI=false;local function lJ()local function lK(lL)local lM=dbHud_1.hasKey;for cV,b_ in pairs(lL)do if lM(b_)then local da=f(dbHud_1.getStringValue(b_))if da~=nil then _G[b_]=da;lI=true end end end end;if dbHud_1 then if not useTheseSettings then lK(ch())coroutine.yield()lK(b)else lK(b)a1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ah=5;lI=false end;coroutine.yield()if lI then a1="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)ba=autoRollPreference;bh=AtmoSpeedLimit;ay=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]az=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]elseif not useTheseSettings then a1="No Saved Variables Found - Exit HUD to save settings"end else a1="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<C then LastMaxBrakeInAtmo=0 end;LastStartTime=C;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ah=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=av end;VectorStatus="Proceeding to Waypoint"end;local function lN()local function lO(lP,lQ)if lP>lQ then lQ=lP end;local lR,lS=0,0;if ContainerOptimization>0 then lR=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lS=FuelTankOptimization*0.05 end;lQ=lQ*(1-(lR+lS))return lQ end;local lT=core.getElementNameById;local lU=fuelX~=0 and fuelY~=0;for cV in pairs(at)do local type=core.getElementTypeById(at[cV])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(at[cV])),'^.*vertical.*$')then bG=true end end;if n(type,'^.*Space Engine$')then bv=true;if n(tostring(core.getElementTagsById(at[cV])),'^.*vertical.*$')then local lV=core.getElementRotationById(at[cV])if lV[4]<0 then if o(-lV[4],0.1)==0.5 then bt=true end else if o(lV[4],0.1)==0.5 then bu=true end end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local lW=h(at[cV])if lW>10000 then E=128;F=110 elseif lW>1000 then E=64;F=55 elseif lW>150 then E=32;F=27 end end;aL=aL+h(at[cV])if lU and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lW=h(at[cV])local lX=k(at[cV])local lP=0;local gY=p()if type=="Atmospheric Fuel Tank"then local lQ=400;local lY=35.03;if lW>10000 then lQ=51200;lY=5480 elseif lW>1300 then lQ=6400;lY=988.67 elseif lW>150 then lQ=1600;lY=182.67 end;lP=lX-lY;if fuelTankHandlingAtmo>0 then lQ=lQ+lQ*fuelTankHandlingAtmo*0.2 end;lQ=lO(lP,lQ)aI[#aI+1]={at[cV],lT(at[cV]),lQ,lY,lP,gY}end;if type=="Rocket Fuel Tank"then local lQ=320;local lY=173.42;if lW>65000 then lQ=40000;lY=25740 elseif lW>6000 then lQ=5120;lY=4720 elseif lW>700 then lQ=640;lY=886.72 end;lP=lX-lY;if fuelTankHandlingRocket>0 then lQ=lQ+lQ*fuelTankHandlingRocket*0.1 end;lQ=lO(lP,lQ)aK[#aK+1]={at[cV],lT(at[cV]),lQ,lY,lP,gY}end;if type=="Space Fuel Tank"then local lQ=2400;local lY=182.67;if lW>10000 then lQ=76800;lY=5480 elseif lW>1300 then lQ=9600;lY=988.67 end;lP=lX-lY;if fuelTankHandlingSpace>0 then lQ=lQ+lQ*fuelTankHandlingSpace*0.2 end;lQ=lO(lP,lQ)aJ[#aJ+1]={at[cV],lT(at[cV]),lQ,lY,lP,gY}end end end;if not bG then VertTakeOff,VertTakeOffEngine=false,false end end;local function lZ()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(aq or not aq and as<10000)then for _,b_ in pairs(door)do b_.toggle()end end;if switch then for _,b_ in pairs(switch)do b_.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,b_ in pairs(forcefield)do b_.toggle()end end;if antigrav then bH=antigrav.getState()==1;if bH and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if R then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;GearExtended=true;if R then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(bb)if aq and ao~=-1 then b2=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function l_(m0,m1,m2,m3,cp,cq,m4,m5,m6,m7)local m8={enableName=m0,disableName=m1,width=m2,height=m3,x=cp,y=cq,toggleVar=m4,toggleFunction=m5,drawCondition=m6,hovered=false}if m7 then table.insert(lH,m8)else table.insert(lG,m8)end;return m8 end;local function m9(ma)if not bM then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif ma=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif ma=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif ma=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bN=ch(ma)showHud=false else bN={}showHud=true end end;local function mb()bM=not bM;if bM then aF=lH;a1="Hold SHIFT to see Settings"bO=showHud else aF=lG;a1="Hold SHIFT to see Control Buttons"m9()showHud=bO end end;local function mc(b_)_G[b_]=not _G[b_]if _G[b_]then a1=b_.." set to true"else a1=b_.." set to false"end;if b_=="showHud"then bO=_G[b_]elseif b_=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif b_=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function md()local me=50;local mf=340;local cp=500;local cq=aH/2-400;local mg=0;for cV,b_ in pairs(ch("boolean"))do if type(_G[b_])=="boolean"then l_(b_,b_,mf,me,cp,cq,function()return _G[b_]end,function()mc(b_)end,function()return true end,true)cq=cq+me+20;if mg==9 then cp=cp+mf+20;cq=aH/2-400;mg=0 else mg=mg+1 end end end;l_("Control View","Control View",mf,me,10,aH/2-500,function()return true end,mb,function()return true end,true)l_("View Handling Settings",'Hide Handling Settings',mf,me,10,aH/2-(500-me),function()return showHandlingVariables end,function()m9("handling")end,function()return true end,true)l_("View Hud Settings",'Hide Hud Settings',mf,me,10,aH/2-(500-me*2),function()return showHudVariables end,function()m9("hud")end,function()return true end,true)l_("View Physics Settings",'Hide Physics Settings',mf,me,10,aH/2-(500-me*3),function()return showPhysicsVariables end,function()m9("physics")end,function()return true end,true)end;local function mh()local function jI()local position=bE;local bY=planet.name..". "..#SavedLocations;if radar_1 then local dE,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dE~=nil and dE~=""then bY=bY.." "..radar_1.getConstructName(dE)end end;return b5.AddNewLocation(bY,position,false,true)end;local function mi()TurnBurn=not TurnBurn end;local function mj(mk)if mk==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Z=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function ml()mj(1)end;local function mm()b5.UpdatePosition()end;local function jH()b5.ClearCurrentPosition()end;local function mn()local bY=AutopilotTargetName;if bY==nil then local ir=cB((bE-CustomTarget.position):len())bY=CustomTarget.name.." "..ir end;if bY==nil then bY="None"end;return"Engage Autopilot: "..bY end;local function mo()local bY=AutopilotTargetName;if bY==nil then bY=CustomTarget.name end;if bY==nil then bY="None"end;return"Disable Autopilot: "..bY end;local function mp()if safeMass>0 then a1="Safe Mass set to "..z(av,2).." kg"else a1="Intruder Detection reset\nSafe Mass set to "..z(av,2).." kg"ah=5;bF=0 end;safeMass=av end;local function mq()if l()==1 then Z=not Z;if Z then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)cb("folOn","F")else cb("folOff","F")BrakeIsOn=true;ba=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else a1="Follow Mode only works with Remote controller"Z=false end end;local me=50;local mf=260;local mr=l_("Enable Brake Toggle","Disable Brake Toggle",mf,me,aG/2-mf/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a1="Brakes in Toggle Mode"else a1="Brakes in Default Mode"end end)l_("Align Prograde","Disable Prograde",mf,me,aG/2-mf/2-50-mr.width,aH/2-me+380,function()return ProgradeIsOn end,ml)l_("Align Retrograde","Disable Retrograde",mf,me,aG/2-mf/2+mr.width+50,aH/2-me+380,function()return RetrogradeIsOn end,mj,function()return ar==0 end)local ms=l_(mn,mo,600,60,aG/2-600/2,aH/2-60/2-400,function()return Autopilot end,cH)l_("Save Position","Save Position",200,ms.height,ms.x+ms.width+30,ms.y,function()return false end,jI,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)l_("Update Position","Update Position",200,ms.height,ms.x+ms.width+30,ms.y,function()return false end,mm,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)l_("Clear Position","Clear Position",200,ms.height,ms.x-200-30,ms.y,function()return true end,jH,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)me=60;mf=300;local cp=10;local cq=aH/2-500;l_("Show Help","Hide Help",mf,me,cp,cq,function()return showHelp end,function()showHelp=not showHelp end)cq=cq+me+20;l_("View Settings","View Settings",mf,me,cp,cq,function()return true end,mb)local cq=aH/2-300;l_("Enable Turn and Burn","Disable Turn and Burn",mf,me,cp,cq,function()return TurnBurn end,mi)l_("Horizontal Takeoff Mode","Vertical Takeoff Mode",mf,me,cp+mf+20,cq,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a1="Vertical Takeoff Mode"else a1="Horizontal Takeoff Mode"end end,function()return bG end)cq=cq+me+20;l_("Show Orbit Display","Hide Orbit Display",mf,me,cp,cq,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a1="Orbit Display Enabled"else a1="Orbit Display Disabled"end end)l_("Engage Orbiting","Cancel Orbiting",mf,me,cp+mf+20,cq,function()return IntoOrbit end,cF,function()return ar==0 and bV end)cq=cq+me+20;l_("Glide Re-Entry","Cancel Glide Re-Entry",mf,me,cp,cq,function()return Reentry end,function()al=true;ml()end,function()return planet.hasAtmosphere and not aq end)l_("Parachute Re-Entry","Cancel Parachute Re-Entry",mf,me,cp+mf+20,cq,function()return Reentry end,cK,function()return planet.hasAtmosphere and not aq end)cq=cq+me+20;l_("Engage Follow Mode","Disable Follow Mode",mf,me,cp,cq,function()return Z end,mq,function()return l()==1 end)l_("Enable Repair Arrows","Disable Repair Arrows",mf,me,cp+mf+20,cq,function()return aM end,function()aM=not aM;if aM then a1="Repair Arrows Enabled"else a1="Repair Arrows Diabled"end end,function()return l()==1 end)cq=cq+me+20;if not ExternalAGG then l_("Enable AGG","Disable AGG",mf,me,cp,cq,function()return bH end,cL,function()return antigrav~=nil end)end;l_("Reset Intruder Alert","Set Safe Mass",mf,me,cp+mf+20,cq,function()return safeMass>0 end,mp,function()return IntruderAlertSystem end)cq=cq+me+20;l_(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,mf*2,me,cp,cq,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a1="IPH Mode: "..iphCondition end)cq=cq+me+20;l_(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,mf*2,me,cp,cq,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a1="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()Logs=Logger()_logCompute=Logs.CreateLog("Computation","time")r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lJ()coroutine.yield()lN()coroutine.yield()b6=jN()lZ()md()mh()aF=lG;coroutine.yield()aW=cW()a_=cX()b0=a_(cW())b1=ej()b3=eO()b7=fb()b4=gm()b5=jv()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)cb("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,b_ in pairs(door)do b_.toggle()end end;if switch then for _,b_ in pairs(switch)do b_.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,b_ in pairs(forcefield)do b_.toggle()end end;safeMass=av;cR()if button then button.activate()end;if SetWaypointOnExit then b6.showWayPoint(planet,bE)end;cb("stop","SU")for _,d3 in pairs(Logs.getLogs())do system.print(d3)end end;function script.onTick(mt)local mu=nil;if mt=="contact"then if not contactTimer then contactTimer=0 end;if C>contactTimer+10 then a1="Radar Contact"cb("rdrCon","RC")contactTimer=C end;unit.stopTimer("contact")elseif mt=="tenthSecond"then local function mv()local mw=system.createData;local mx=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mx(panelInterplanetary,"value")interplanetaryHeaderText=mw('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mx(panelInterplanetary,"value")widgetDistanceText=mw('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=mx(panelInterplanetary,"value")widgetTravelTimeText=mw('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mx(panelInterplanetary,"value")widgetMaxMassText=mw('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mx(panelInterplanetary,"value")widgetTargetOrbitText=mw('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mx(panelInterplanetary,"value")widgetCurBrakeDistanceText=mw('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mx(panelInterplanetary,"value")widgetCurBrakeTimeText=mw('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mx(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mw('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mx(panelInterplanetary,"value")widgetMaxBrakeTimeText=mw('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mx(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mw('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function my()s(panelInterplanetary)panelInterplanetary=nil end;local function mz()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ab.center-bE):len()else AutopilotDistance=(CustomTarget.position-bE):len()end end;local eM=bB;local kY=unit.getThrottle()/100;if AtmoSpeedAssist then kY=J end;local mA,mB=b1.computeDistanceAndTime(bB,MaxGameVelocity,av,a:maxForceForward()*kY,warmup,0)local a7,a8;if not TurnBurn then a7,a8=b6.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=b6.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mC;if not TurnBurn and eM>0 then _,mC=b6.GetAutopilotBrakeDistanceAndTime(eM)else _,mC=b6.GetAutopilotTBBrakeDistanceAndTime(eM)end;local mD=0;local mE=0;if AutopilotCruising or not Autopilot and eM>5 then mE=b1.computeTravelTime(eM,0,AutopilotDistance)elseif a7+mA<AutopilotDistance then mD=AutopilotDistance-(a7+mA)mE=b1.computeTravelTime(8333.0556,0,mD)else local mF=(AutopilotDistance-a7)/mA;mA=AutopilotDistance-a7;mB=mB*mF end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mE elseif AutopilotBraking then return mC elseif AutopilotCruising then return mE+mC else return mB+a8+mE end end;local function mG(jn,mH)if jn==nil then jn=core.g()end;jn=z(jn,5)if mH~=nil and mH or(mu==nil or mu~=jn)then local eP=core.getVelocity()local eM=vec3(eP):len()local mI=f(unit.getData()).maxBrake;if mI~=nil and mI>0 and aq then mI=mI/q(eM/100,0.1,1)mI=mI/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mI)/2 else LastMaxBrakeInAtmo=mI end end end;if mI~=nil and mI>0 then LastMaxBrake=mI end;mu=jn end end;mG(nil,true)if ar>0 and not WasInAtmo then if not bJ and AtmoSpeedAssist and(AltitudeHold or Reentry)then cu(1)N=false end end;if bI~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bI then cx(bI,TRUE)else bI=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mv()end;if AutopilotTargetName~=nil then local mJ=CustomTarget~=nil;local mK=LastMaxBrakeInAtmo/ab:getGravity(ab.center+vec3(0,0,1)*ab.radius):len()t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mz()if mJ and not Autopilot then ai=(bE-CustomTarget.position):len()else ai=(AutopilotTargetCoords-bE):len()end;if not TurnBurn then a7,a8=b6.GetAutopilotBrakeDistanceAndTime(bB)a9,aa=b6.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=b6.GetAutopilotTBBrakeDistanceAndTime(bB)a9,aa=b6.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ir=cB(ai)t(widgetDistanceText,'{"label": "distance", "value": "'..ir..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cM(travelTime)..'", "unit":""}')ir=cB(a7)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ir..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cM(a8)..'", "unit":""}')ir=cB(a9)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ir..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cM(aa)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",mK/1000)..'", "unit":" Tons"}')ir=cB(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ir..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if ar==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else my()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;b4.DrawRadarInfo()elseif mt=="oneSecond"then local function mL(gC)local mM=0;aD=""local mN=aL;local mO=0;local mP=0;local mQ=0;local g_=0;local h0=""local mR=core.getElementHitPointsById;for cV in pairs(at)do local lW=0;local mS=0;mS=h(at[cV])lW=mR(at[cV])mO=mO+lW;if lW<mS then if lW==0 then mQ=mQ+1 else mP=mP+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cV]))local cp=position.x-E;local cq=position.y-E;local fH=position.z-E;table.insert(aA,core.spawnArrowSticker(cp,cq,fH+1,"down"))table.insert(aA,core.spawnArrowSticker(cp,cq,fH+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(cp+1,cq,fH,"north"))table.insert(aA,core.spawnArrowSticker(cp+1,cq,fH,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(cp-1,cq,fH,"south"))table.insert(aA,core.spawnArrowSticker(cp-1,cq,fH,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(cp,cq-1,fH,"east"))table.insert(aA,core.spawnArrowSticker(cp,cq-1,fH,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(cp,cq+1,fH,"west"))table.insert(aA,core.spawnArrowSticker(cp,cq+1,fH,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cV])end elseif aM and#aA>0 and aA[11]==at[cV]then for gT in pairs(aA)do core.deleteSticker(aA[gT])end;aA={}end end;mM=d(mO/mN*100)if mM<100 then gC[#gC+1]=co(0,0,"","pbright txt")g_=d(mM*2.55)h0=e("rgb(%d,%d,%d)",255-g_,g_,0)if mM<100 then gC[#gC+1]=co("50%",1035,"Elemental Integrity: "..mM.."%","txtbig txtmid","fill:"..h0)if mQ>0 then gC[#gC+1]=co("50%",1055,"Disabled Modules: "..mQ.." Damaged Modules: "..mP,"txtbig txtmid","fill:"..h0)elseif mP>0 then gC[#gC+1]=co("50%",1055,"Damaged Modules: "..mP,"txtbig txtmid","fill:"..h0)end end end end;local function mT()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function mU()local gY=p()local id=bB;local mV=gY-au;if id>1.38889 then id=id/1000;local mW=id*(gY-au)TotalDistanceTravelled=TotalDistanceTravelled+mW;ac=ac+mW end;ad=ad+mV;TotalFlightTime=TotalFlightTime+mV;au=gY end;local function mX()if safeMass>0 then if av>safeMass+50 then bF=d(av-safeMass)safeMass=-1 elseif av<safeMass then safeMass=av end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mX()end;mU()b4.UpdatePipe()mT()local gC={}b4.ExtraData(gC)if ShowOdometer then gC=b4.DrawOdometer(gC,ac,TotalDistanceTravelled,ad)end;if ShouldCheckDamage then mL(gC)end;aj=table.concat(gC,"")collectgarbage("collect")elseif mt=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local da=f(dbHud_1.getStringValue("SavedLocations"))if da~=nil then _G["SavedLocations"]=da;local f_=-1;local jK;for cV,b_ in pairs(SavedLocations)do if b_.name and b_.name=="SatNav Location"then f_=cV;break end end;if f_~=-1 then jK=SavedLocations[f_]f_=-1;for cV,b_ in pairs(aW[0])do if b_.name and b_.name=="SatNav Location"then f_=cV;break end end;if f_>-1 then aW[0][f_]=jK end;b5.UpdateAtlasLocationsList()a1=jK.name.." position updated"end end;for i=1,#bP do if bP[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bP[i].name)b5.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mt=="msgTick"then local gC={}b4.DisplayMessage(gC,"empty")a1="empty"unit.stopTimer("msgTick")ah=3 elseif mt=="animateTick"then b9=true;b8=false;af=0;ag=0;unit.stopTimer("animateTick")elseif mt=="hudTick"then local function mY(gC)local mZ=d(q(ai/(aG/4)*255,0,255))gC[#gC+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",af,ag,d(G+0.5)+mZ,d(I+0.5)-mZ,d(H+0.5)-mZ)end;local function m_()for _,b_ in pairs(aF)do if b_.hovered then if not b_.drawCondition or b_.drawCondition()then b_.toggleFunction()end;b_.hovered=false end end end;local function n0()local function n1(n2,n3,cp,cq,m2,m3)if n2>cp and n2<cp+m2 and n3>cq and n3<cq+m3 then return true else return false end end;local cp=af+aG/2;local cq=ag+aH/2;for _,b_ in pairs(aF)do b_.hovered=n1(cp,cq,b_.x,b_.y,b_.width,b_.height)end end;local function n4(gC)local function n5(gC,n6,hover,cp,cq,eF,n7,n8,n9,na,nb)if type(na)=="function"then na=na()end;if type(nb)=="function"then nb=nb()end;gC[#gC+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",cp,cq,eF,n7)if n6 then gC[#gC+1]=e("%s'",n8)else gC[#gC+1]=n9 end;if hover then gC[#gC+1]=" style='stroke:white; stroke-width:2'"else gC[#gC+1]=" style='stroke:black; stroke-width:1'"end;gC[#gC+1]="></rect>"gC[#gC+1]=e("<text x='%f' y='%f' font-size='24' fill='",cp+eF/2,cq+n7/2+5)if n6 then gC[#gC+1]="black"else gC[#gC+1]="white"end;gC[#gC+1]="' text-anchor='middle' font-family='Montserrat'>"if n6 then gC[#gC+1]=e("%s</text>",na)else gC[#gC+1]=e("%s</text>",nb)end end;local nc="rgb(50,50,50)'"local nd="rgb(210,200,200)"local ne=n5;for _,b_ in pairs(aF)do local m1=b_.disableName;local m0=b_.enableName;if type(m1)=="function"then m1=m1()end;if type(m0)=="function"then m0=m0()end;if not b_.drawCondition or b_.drawCondition()then ne(gC,b_.toggleVar(),b_.hovered,b_.x,b_.y,b_.width,b_.height,nd,nc,m1,m0)end end end;local nf=z(ResolutionX/2,0)local ng=z(ResolutionY/2,0)local gC={}b4.HUDPrologue(gC)if showHud then b4.UpdateHud(gC)else if AlwaysVSpd then b4.DrawVerticalSpeed(gC,as)end;b4.DisplayOrbitScreen(gC)b4.DrawWarnings(gC)end;if bM and bN~={}then b4.DrawSettings(gC)end;b4.HUDEpilogue(gC)gC[#gC+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a1~="empty"then b4.DisplayMessage(gC,a1)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then b4.DrawDeadZone(gC)end end;if w()==0 then if l()==1 and a0 then if not AltIsOn then n0()n4(gC)end;if not b8 and not b9 then local nh=table.concat(gC,"")gC={}gC[#gC+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gC[#gC+1]=nh;gC[#gC+1]="</body>"b8=true;gC[#gC+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gC,"")system.setScreen(content)elseif b9 then local nh=table.concat(gC,"")gC={}gC[#gC+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gC[#gC+1]=nh;gC[#gC+1]="</body>"end;if not b8 then gC[#gC+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nf,ng,af,ag)end else m_()end else if not a0 and l()==0 then m_()if ai>DeadZone then if DisplayDeadZone then mY(gC)end end elseif not AltIsOn or AltIsOn and a0 then n0()n4(gC)end;gC[#gC+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nf,ng,af,ag)end;gC[#gC+1]=[[</svg></body>]]content=table.concat(gC,"")elseif mt=="apTick"then b6.APTick()elseif mt=="radarTick"then b7.UpdateRadar()end end;function script.onFlush()local function ni(nj,l4)local nk=vec3()local nl=vec3()if nj==axisCommandId.longitudinal then nk=vec3(core.getConstructOrientationForward())nl=by elseif nj==axisCommandId.vertical then nk=vec3(core.getConstructOrientationUp())nl=bx elseif nj==axisCommandId.lateral then nk=vec3(core.getConstructOrientationRight())nl=bz else return vec3()end;local nm=vec3(core.getWorldGravity())local nn=nm:dot(nl)local no=vec3(core.getWorldAirFrictionAcceleration())local np=no:dot(nl)local nq=vec3(core.getVelocity())local nr=nq:dot(nk)local ns=l4*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(ns-nr)local nt=targetSpeedPID2:get()local nu=(nt-np-nn)*nl;return nu end;local function nw(nj,l4)local nk=vec3()local nl=vec3()if nj==axisCommandId.longitudinal then nk=vec3(core.getConstructOrientationForward())nl=by elseif nj==axisCommandId.vertical then nk=vec3(core.getConstructOrientationUp())nl=bx elseif nj==axisCommandId.lateral then nk=vec3(core.getConstructOrientationRight())nl=bz else return vec3()end;local nm=vec3(core.getWorldGravity())local nn=nm:dot(nl)local no=vec3(core.getWorldAirFrictionAcceleration())local np=no:dot(nl)local nq=vec3(core.getVelocity())local nr=nq:dot(nk)local ns=l4*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(ns-nr)local nt=targetSpeedPID:get()local nu=(nt-np-nn)*nl;return nu end;local function nx(ny,h4,jA)local nz=ny:cross(jA):normalize_inplace()local hR=math.acos(q(nz:dot(-h4),-1,1))*constants.rad2deg;if nz:cross(-h4):dot(jA)<0 then hR=-hR end;return hR end;if antigrav and not ExternalAGG then if not bH and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bJ=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bJ and N then cu(0)N=false elseif not bJ and not N then J=0;N=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local nA=q(S+T+system.getControlDeviceForwardInput(),-1,1)local nB=q(V+Y+system.getControlDeviceYawInput(),-1,1)local nC=q(W+U-system.getControlDeviceLeftRightInput(),-1,1)local nD=X;bC=vec3(core.getWorldVertical())if bC==nil or bC:len()==0 then bC=(planet.center-bE):normalize()end;bx=vec3(core.getConstructWorldOrientationUp())by=vec3(core.getConstructWorldOrientationForward())bz=vec3(core.getConstructWorldOrientationRight())bA=vec3(core.getWorldVelocity())bE=vec3(core.getConstructWorldPos())av=core.getConstructMass()bB=vec3(bA):len()bD=-bC:dot(bA)bL=getRoll(bC,by,bz)local nE=bL/180*math.pi;local nF=math.cos(nE)local nG=math.sin(nE)bK=nx(bC,by,bz*nF+bx*nG)local nH=bA:normalize()local nI=c(bL)local nJ=utils.sign(bL)local nK=vec3(core.getWorldAngularVelocity())local nL=nA*pitchSpeedFactor*bz+nB*rollSpeedFactor*by+nC*yawSpeedFactor*bx;if ba==true and bC:len()>0.01 then local nM=c(be-bL)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and nM>0 or ar>0.0 and nM<autoRollRollThreshold and autoRollPreference)and nB==0 and c(bK)<85 then local nN=be;local nO=autoRollFactor;if ar==0 then nO=nO/4;be=0;nN=0 end;if rollPID==nil then rollPID=pid.new(nO*0.01,0,nO*0.1)end;rollPID:inject(nN-bL)local nP=rollPID:get()nL=nL+nP*by end end;if bC:len()>0.01 and ar>0.0 then local nQ=20.0;if turnAssist==true and nI>nQ and nA==0 and nC==0 then local nR=turnAssistFactor*0.1;local nS=turnAssistFactor*0.025;local nT=(nI-nQ)/(180-nQ)*180;local nU=0;if nT<90 then nU=nT/90 elseif nT<180 then nU=(180-nT)/90 end;nU=nU*nU;local nV=-nJ*nS*(1.0-nU)local nW=nR*nU;nL=nL+nW*bz+nV*bx end end;local nX=1;local nY=0;local nZ=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then bh=q(bh+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local n_=J;J=z(q(J+speedChangeLarge/100,-1,1),2)if J>=0 and n_<0 then J=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then bh=q(bh-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local n_=J;J=z(q(J-speedChangeLarge/100,-1,1),2)if J<=0 and n_>0 then J=0;aw=false end end else aw=true end;K=0;if aq and AtmoSpeedAssist and bJ then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bh/3.6-bA:dot(by))local o0=throttlePID:get()M=q(o0,-1,1)if M<J and ar>0.005 then L=true;r:setThrottleCommand(axisCommandId.longitudinal,q(M,0.01,1))else L=false;r:setThrottleCommand(axisCommandId.longitudinal,J)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bA:len()-bh/3.6)local o1=q(brakePID:get(),0,1)if ar>0 and bD<-80 or ar>0.005 then K=o1 end;if K>0 then if L and M==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else M=q(M,0.01,1)end;local o2=''local o3=vec3()local o4=ni(axisCommandId.vertical,ae*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",o4,nY)local o5='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then o5=o5 ..ExtraLongitudeTags end;local o6=r:getAxisCommandType(axisCommandId.longitudinal)local o7=r:composeAxisAccelerationFromThrottle(o5,axisCommandId.longitudinal)local o8=nw(axisCommandId.lateral,LeftAmount*1000)o2=o2 ..' , '.."lateral airfoil , lateral ground "o3=o3+o8;if o3:len()>constants.epsilon then a:setEngineForceCommand(o2,o3,nY,'','','',nZ)end;a:setEngineForceCommand(o5,o7,nX)local o9='thrust analog vertical fueled 'local oa='thrust analog lateral fueled 'if ExtraLateralTags~="none"then oa=oa..ExtraLateralTags end;if ExtraVerticalTags~="none"then o9=o9 ..ExtraVerticalTags end;if ae~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(o9,o4,nX)else a:setEngineForceCommand(o9,vec3(),nX)end;if LeftAmount~=0 then a:setEngineForceCommand(oa,o8,nX)else a:setEngineForceCommand(oa,vec3(),nX)end;if nD==0 then nD=K end;local ob=-nD*(brakeSpeedFactor*bA+brakeFlatFactor*nH)a:setEngineForceCommand('brake',ob)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,J)end;local l4=unit.getAxisCommandValue(0)if not bJ then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bA:len()-l4/3.6)local o1=q(brakePID:get(),0,1)nD=q(nD+o1,0,1)end;local ob=-nD*(brakeSpeedFactor*bA+brakeFlatFactor*nH)a:setEngineForceCommand('brake',ob)local o2=''local o3=vec3()local oc=false;local o5='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then o5=o5 ..ExtraLongitudeTags end;local o6=r:getAxisCommandType(axisCommandId.longitudinal)if o6==axisCommandType.byThrottle then local o7=r:composeAxisAccelerationFromThrottle(o5,axisCommandId.longitudinal)a:setEngineForceCommand(o5,o7,nX)elseif o6==axisCommandType.byTargetSpeed then local o7=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)o2=o2 ..' , '..o5;o3=o3+o7;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then oc=true end end;local oa='thrust analog lateral 'if ExtraLateralTags~="none"then oa=oa..ExtraLateralTags end;local od=r:getAxisCommandType(axisCommandId.lateral)if od==axisCommandType.byThrottle then local oe=r:composeAxisAccelerationFromThrottle(oa,axisCommandId.lateral)a:setEngineForceCommand(oa,oe,nX)elseif od==axisCommandType.byTargetSpeed then local o8=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)o2=o2 ..' , '..oa;o3=o3+o8 end;local o9='thrust analog vertical 'if ExtraVerticalTags~="none"then o9=o9 ..ExtraVerticalTags end;local of=r:getAxisCommandType(axisCommandId.vertical)if of==axisCommandType.byThrottle then local o4=r:composeAxisAccelerationFromThrottle(o9,axisCommandId.vertical)if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(o9,o4,nX,'airfoil','ground','',nZ)else a:setEngineForceCommand(o9,vec3(),nX)a:setEngineForceCommand('airfoil vertical',o4,nX,'airfoil','','',nZ)a:setEngineForceCommand('ground vertical',o4,nX,'ground','','',nZ)end elseif of==axisCommandType.byTargetSpeed then if ae<0 then a:setEngineForceCommand('hover',vec3(),nX)end;local og=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)o2=o2 ..' , '..o9;o3=o3+og end;if o3:len()>constants.epsilon then if X~=0 or oc or c(nH:dot(by))<0.8 then o2=o2 ..', brake'end;a:setEngineForceCommand(o2,o3,nY,'','','',nZ)end end;local oh=torqueFactor*(nL-nK)local oi=vec3(core.getWorldAirFrictionAngularAcceleration())oh=oh-oi;a:setEngineTorqueCommand('torque',oh,nX,'airfoil','','',nZ)a:setBoosterCommand('rocket_engine')if a6 and not VanillaRockets then local eM=vec3(core.getVelocity()):len()local oj=0.15;if not bJ then local ok=r:getTargetSpeed(axisCommandId.longitudinal)if eM*3.6>ok*(1-oj)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eM*3.6<ok*(1-oj)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kY=unit.getThrottle()if AtmoSpeedAssist then kY=J*100 end;local l4=kY/100;if j==0 then l4=l4*MaxGameVelocity;if eM>=l4*(1-oj)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eM<l4*(1-oj)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local lf=d(bh)l4=l4*lf/3.6;if eM>=l4*(1-oj)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eM<l4*(1-oj)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local gk=coroutine.status(beginSetup)if gk=="suspended"then local cv,gl=coroutine.resume(beginSetup)if gl then system.print("ERROR STARTUP: "..gl)end elseif gk=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not b8 and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(ol)local mult=1;local function om(on)local function oo(op,on)local oq={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local os=op;for _,b_ in ipairs(oq)do if on and os>b_ then op=b_ elseif op<b_ and not on then op=b_;break end end;return op end;if on then mult=-1 end;if not ExternalAGG and bH then if a0 and on then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+mult*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+mult*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a0 then bq=oo(bq,on)else bq=bq+mult*a2 end;if bq<planet.noAtmosphericDensityAltitude then bq=planet.noAtmosphericDensityAltitude end else if a0 and aq then HoldAltitude=oo(HoldAltitude,on)else HoldAltitude=HoldAltitude+mult*a2 end end else r:updateTargetGroundAltitudeFromActionStart(mult*1.0)end end;local function ot(on)if on then mult=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=q(J+mult*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,mult*speedChangeLarge)end else if on then mult=1 else mult=nil end;b5.adjustAutopilotTargetIndex(mult)end end;local function ou(ov)if not aq then a1="Flight Assist in Atmo only"return end;local d1=type(ov)if bT==nil then if d1=="table"then if Autopilot or VectorToTarget then cH()end;cb("180On","BR")elseif ov==1 then cb("bnkLft","BR")else cb("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cG()if d1~="table"then ov=ov+1 end end;bT=ov else cb("180Off","BR")bT=nil end end;if ol=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cu(0)if vBooster or hover then if aq and ao==-1 then cb("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;ba=true;GearExtended=false else if R then cb("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if R and not BrakeLanding and not(vBooster or hover)then cb("grOut","LG",1)a.control.extendLandingGears()end else if R then cb("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif ol=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif ol=="forward"then S=S-1 elseif ol=="backward"then if AltIsOn then ou(-bA*5000)else S=S+1 end elseif ol=="left"then if AltIsOn then ou(1)else V=V-1 end elseif ol=="right"then if AltIsOn then ou(3)else V=V+1 end elseif ol=="yawright"then W=W-1 elseif ol=="yawleft"then W=W+1 elseif ol=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif ol=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif ol=="up"then ae=ae+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ol=="down"then ae=ae-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ol=="groundaltitudeup"then om()elseif ol=="groundaltitudedown"then om(true)elseif ol=="option1"then b5.adjustAutopilotTargetIndex()toggleView=false elseif ol=="option2"then b5.adjustAutopilotTargetIndex(1)toggleView=false elseif ol=="option3"then local function ow()aE=not aE;if not aE then cb("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else cb("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ow()toggleView=false elseif ol=="option4"then bT=nil;cH()toggleView=false elseif ol=="option5"then function ToggleLockPitch()if LockPitch==nil then cb("lkPOn","LP")if not a0 then LockPitch=bK else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else cb("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif ol=="option6"then cG()toggleView=false elseif ol=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a1="Collision System Enabled"else a1="Collision System Secured"end;toggleView=false elseif ol=="option8"then stablized=not stablized;if not stablized then a1="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()cb("gsOff","GS")else a1="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)cb("gsOn","GS")end;toggleView=false elseif ol=="option9"then if gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then cb("gyOn","GA")else cb("gyOff","GA")end end;toggleView=false elseif ol=="lshift"then if AltIsOn then a0=true end;if w()==1 then a0=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then a0=true;b9=false;b8=false end elseif ol=="brake"then if BrakeToggleStatus then cJ()elseif not BrakeIsOn then cJ()else BrakeIsOn=true end elseif ol=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif ol=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a6 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a6=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a6=false end elseif ol=="stopengines"then local function ox()if C-D<1.5 then cb("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bT=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Z=false;O=false;al=false;am=false;Q=false;ba=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;ox()D=C;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if J~=0 then r:resetCommand(axisCommandId.longitudinal)cu(0)else cu(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if aq then cx(AtmoSpeedLimit)else cx(MaxGameVelocity*3.6)end end end elseif ol=="speedup"then ot()elseif ol=="speeddown"then ot(true)elseif ol=="antigravity"and not ExternalAGG then if antigrav~=nil then cL()end end end;function script.onActionStop(ol)local function oy()if not ExternalAGG and bH then a5=a3 end;if AltitudeHold or VertTakeOff or IntoOrbit then a4=a2 end end;if ol=="forward"then S=0 elseif ol=="backward"then S=0 elseif ol=="left"then if bT then if bT==2 then bT=-2 else bT=-1 end end;V=0 elseif ol=="right"then if bT then if bT==4 then bT=-2 else bT=-1 end end;V=0 elseif ol=="yawright"then W=0 elseif ol=="yawleft"then W=0 elseif ol=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif ol=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif ol=="up"then ae=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ol=="down"then ae=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ol=="groundaltitudeup"then oy()toggleView=false elseif ol=="groundaltitudedown"then oy()toggleView=false elseif ol=="lshift"then if w()==1 then af=0;ag=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then b9=false;b8=false end;a0=false elseif ol=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cJ()else BrakeIsOn=false end end elseif ol=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(ol)local function oz(on)local mult=1;if on then mult=-1 end;if not ExternalAGG and bH then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+mult*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a5=q(a5*1.05,a3,500)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+mult*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bq=bq+mult*a4;if bq<planet.noAtmosphericDensityAltitude then bq=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+mult*a4 end;a4=q(a4*1.05,a2,500)else r:updateTargetGroundAltitudeFromActionLoop(mult*1.0)end end;local function oA(on)if on then mult=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=q(J+mult*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,mult*speedChangeSmall)end end end;if ol=="groundaltitudeup"then if not a0 then oz()end elseif ol=="groundaltitudedown"then if not a0 then oz(true)end elseif ol=="speedup"then oA()elseif ol=="speeddown"then oA(true)end end;function script.onInputText(cr)local function oB()for cV,b_ in pairs(ch())do dbHud_1.setStringValue(b_,g(nil))end;for cV,b_ in pairs(b)do if b_~="SavedLocations"then dbHud_1.setStringValue(b_,g(nil))end end;a1="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ah=5 end;local function oC(oD,eQ,hN)local function oE(eQ)local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d8='::pos{'..A..','..A..','..A..','..A..','..A..'}'local dl,dm,du,dv,dw=n(eQ,d8)if dl=="0"and dm=="0"then return vec3(y(du),y(dv),y(dw))end;dv=math.rad(dv)du=math.rad(du)local planet=aW[y(dl)][y(dm)]local eg=math.cos(du)local oF=vec3(eg*math.cos(dv),eg*math.sin(dv),math.sin(du))return planet.center+(planet.radius+dw)*oF end;local position=oE(eQ)return b5.AddNewLocation(oD,position,hN)end;local i;local oG,oH=nil,nil;local oI="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cr," ")oG=cr;if i~=nil then oG=string.sub(cr,0,i-1)oH=string.sub(cr,i+1)end;if oG=="/help"or oG=="/commands"then for jt in string.gmatch(oI,"([^\n]+)")do system.print(jt)end;return elseif oG=="/setname"then if oH==nil or oH==""then a1="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then b5.UpdatePosition(oH)else a1="Select a saved target to rename first"end elseif oG=="/addlocation"or string.find(cr,"::pos")~=nil then local hN=false;local oD="0-Temp"if oH==nil or oH==""then oH=oG;hN=true end;i=string.find(oH,"::")if not hN then oD=string.sub(oH,1,i-2)end;local eQ=string.sub(oH,i)oC(oD,eQ,hN)elseif oG=="/agg"then if oH==nil or oH==""then a1="Usage: /agg targetheight"return end;oH=y(oH)if oH<1000 then oH=1000 end;AntigravTargetAltitude=oH;a1="AGG Target Height set to "..oH elseif oG=="/G"then if oH==nil or oH==""then a1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oH=="dump"then for cV,b_ in pairs(ch())do if type(_G[b_])=="boolean"then if _G[b_]==true then system.print(b_.." true")else system.print(b_.." false")end elseif _G[b_]==nil then system.print(b_.." nil")else system.print(b_.." ".._G[b_])end end;return end;i=string.find(oH," ")local oJ=string.sub(oH,0,i-1)local oK=string.sub(oH,i+1)for cV,b_ in pairs(ch())do if b_==oJ then a1="Variable "..oJ.." changed to "..oK;local oL=type(_G[b_])if oL=="number"then oK=y(oK)elseif oL=="boolean"then if string.lower(oK)=="true"then oK=true else oK=false end end;_G[b_]=oK;return end end;a1="No such global variable: "..oJ elseif oG=="/copydatabank"then if dbHud_2 then cR(true)else a1="Spare Databank required to copy databank"end elseif oG=="/iphWP"then if AutopilotTargetIndex>0 then system.print(b6.showWayPoint(ab,AutopilotTargetCoords,true))a1="::pos waypoint shown in lua chat"else a1="No target selected in IPH"end end end;function script.onEnter(dE)if radar_1 and not aq and not bQ then unit.setTimer("contact",0.1)end end;function script.onLeave(dE)if radar_1 and CollisionSystem then if#bU>650 then dE=tostring(dE)bU[dE]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
