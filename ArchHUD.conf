name: ArchHud - Archaegeo v0.716 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.716;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J=true;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(L)t=L end,get=function()return t end},AtmoSpeedAssist={set=function(L)u=L end,get=function()return u end},ForceAlignment={set=function(L)v=L end,get=function()return v end},DisplayDeadZone={set=function(L)w=L end,get=function()return w end},showHud={set=function(L)x=L end,get=function()return x end},hideHudOnToggleWidgets={set=function(L)y=L end,get=function()return y end},ShiftShowsRemoteButtons={set=function(L)z=L end,get=function()return z end},SetWaypointOnExit={set=function(L)A=L end,get=function()return A end},AlwaysVSpd={set=function(L)B=L end,get=function()return B end},BarFuelDisplay={set=function(L)C=L end,get=function()return C end},voices={set=function(L)D=L end,get=function()return D end},alerts={set=function(L)E=L end,get=function()return E end},CollisionSystem={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},SaveStartingLocation={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1050;W=30000;X=1000;Y=50;Z=0;_=100000;a0=8333.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)a0=L end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(L)a1=L end,get=function()return a1 end},warmup={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingSpace={set=function(L)a4=L end,get=function()return a4 end},fuelTankHandlingRocket={set=function(L)a5=L end,get=function()return a5 end},ContainerOptimization={set=function(L)a6=L end,get=function()return a6 end},FuelTankOptimization={set=function(L)a7=L end,get=function()return a7 end},AutoShieldPercent={set=function(L)a8=L end,get=function()return a8 end}}aa=1920;ab=1080;ac=400;ad=130;ae=224;af=255;ag=255;ah=0;ai=0;aj=960;ak=540;al=1300;am=540;an=1525;ao=325;ap=550;aq=540;ar=30;as=700;at=1750;au=250;av=50;aw=250;ax=0;ay=30;az=100;aA={ResolutionX={set=function(L)aa=L end,get=function()return aa end},ResolutionY={set=function(L)ab=L end,get=function()return ab end},circleRad={set=function(L)ac=L end,get=function()return ac end},SafeR={set=function(L)ad=L end,get=function()return ad end},SafeG={set=function(L)ae=L end,get=function()return ae end},SafeB={set=function(L)af=L end,get=function()return af end},PvPR={set=function(L)ag=L end,get=function()return ag end},PvPG={set=function(L)ah=L end,get=function()return ah end},PvPB={set=function(L)ai=L end,get=function()return ai end},centerX={set=function(L)aj=L end,get=function()return aj end},centerY={set=function(L)ak=L end,get=function()return ak end},throtPosX={set=function(L)al=L end,get=function()return al end},throtPosY={set=function(L)am=L end,get=function()return am end},vSpdMeterX={set=function(L)an=L end,get=function()return an end},vSpdMeterY={set=function(L)ao=L end,get=function()return ao end},altMeterX={set=function(L)ap=L end,get=function()return ap end},altMeterY={set=function(L)aq=L end,get=function()return aq end},fuelX={set=function(L)ar=L end,get=function()return ar end},fuelY={set=function(L)as=L end,get=function()return as end},shieldX={set=function(L)at=L end,get=function()return at end},shieldY={set=function(L)au=L end,get=function()return au end},DeadZone={set=function(L)av=L end,get=function()return av end},OrbitMapSize={set=function(L)aw=L end,get=function()return aw end},OrbitMapX={set=function(L)ax=L end,get=function()return ax end},OrbitMapY={set=function(L)ay=L end,get=function()return ay end},soundVolume={set=function(L)az=L end,get=function()return az end}}aB=5;aC=1;aD=0.003;aE=0.003;aF=2;aG=1.5;aH=180;aI=150;aJ=0.002;aK=2;aL=0.8;aM=1;aN=3;aO=1;aP=40;aQ=0.0166667;aR=0.0666667;aS=0.0;aT="none"aU="none"aV="none"aW={speedChangeLarge={set=function(L)aB=L end,get=function()return aB end},speedChangeSmall={set=function(L)aC=L end,get=function()return aC end},MouseXSensitivity={set=function(L)aD=L end,get=function()return aD end},MouseYSensitivity={set=function(L)aE=L end,get=function()return aE end},autoRollFactor={set=function(L)aF=L end,get=function()return aF end},rollSpeedFactor={set=function(L)aG=L end,get=function()return aG end},autoRollRollThreshold={set=function(L)aH=L end,get=function()return aH end},minRollVelocity={set=function(L)aI=L end,get=function()return aI end},TrajectoryAlignmentStrength={set=function(L)aJ=L end,get=function()return aJ end},torqueFactor={set=function(L)aK=L end,get=function()return aK end},pitchSpeedFactor={set=function(L)aL=L end,get=function()return aL end},yawSpeedFactor={set=function(L)aM=L end,get=function()return aM end},brakeSpeedFactor={set=function(L)aN=L end,get=function()return aN end},brakeFlatFactor={set=function(L)aO=L end,get=function()return aO end},DampingMultiplier={set=function(L)aP=L end,get=function()return aP end},apTickRate={set=function(L)aQ=L end,get=function()return aQ end},hudTickRate={set=function(L)aR=L end,get=function()return aR end},ExtraEscapeThrust={set=function(L)aS=L end,get=function()return aS end},ExtraLongitudeTags={set=function(L)aT=L end,get=function()return aT end},ExtraLateralTags={set=function(L)aU=L end,get=function()return aU end},ExtraVerticalTags={set=function(L)aV=L end,get=function()return aV end}}aX=j;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=1000;b9=false;ba=false;bb=false;bc=false;bd=0;be="Aligning"bf=0;bg=1;bh="None"bi=nil;bj=0;bk=nil;bl=0.0;bm=0;bn={}bo=false;bp=0;bq=0;br=nil;bs=0;bt=1000;bu=0;bv=false;bw=0;bx=false;by="All"bz=true;bA="Off"bB=0.000;bC={}bD={VertTakeOff={set=function(L)b7=L end,get=function()return b7 end},VertTakeOffEngine={set=function(L)aY=L end,get=function()return aY end},SpaceTarget={set=function(L)bv=L end,get=function()return bv end},BrakeToggleStatus={set=function(L)aX=L end,get=function()return aX end},BrakeIsOn={set=function(L)aZ=L end,get=function()return aZ end},RetrogradeIsOn={set=function(L)a_=L end,get=function()return a_ end},ProgradeIsOn={set=function(L)b0=L end,get=function()return b0 end},Autopilot={set=function(L)b1=L end,get=function()return b1 end},TurnBurn={set=function(L)b2=L end,get=function()return b2 end},AltitudeHold={set=function(L)b3=L end,get=function()return b3 end},BrakeLanding={set=function(L)b4=L end,get=function()return b4 end},Reentry={set=function(L)b6=L end,get=function()return b6 end},AutoTakeoff={set=function(L)b5=L end,get=function()return b5 end},HoldAltitude={set=function(L)b8=L end,get=function()return b8 end},AutopilotAccelerating={set=function(L)b9=L end,get=function()return b9 end},AutopilotBraking={set=function(L)bb=L end,get=function()return bb end},AutopilotCruising={set=function(L)bc=L end,get=function()return bc end},AutopilotRealigned={set=function(L)ba=L end,get=function()return ba end},AutopilotEndSpeed={set=function(L)bd=L end,get=function()return bd end},AutopilotStatus={set=function(L)be=L end,get=function()return be end},AutopilotPlanetGravity={set=function(L)bf=L end,get=function()return bf end},PrevViewLock={set=function(L)bg=L end,get=function()return bg end},AutopilotTargetName={set=function(L)bh=L end,get=function()return bh end},AutopilotTargetCoords={set=function(L)bi=L end,get=function()return bi end},AutopilotTargetIndex={set=function(L)bj=L end,get=function()return bj end},TotalDistanceTravelled={set=function(L)bl=L end,get=function()return bl end},TotalFlightTime={set=function(L)bm=L end,get=function()return bm end},SavedLocations={set=function(L)bn=L end,get=function()return bn end},VectorToTarget={set=function(L)bo=L end,get=function()return bo end},LocationIndex={set=function(L)bp=L end,get=function()return bp end},LastMaxBrake={set=function(L)bq=L end,get=function()return bq end},LockPitch={set=function(L)br=L end,get=function()return br end},LastMaxBrakeInAtmo={set=function(L)bs=L end,get=function()return bs end},AntigravTargetAltitude={set=function(L)bt=L end,get=function()return bt end},LastStartTime={set=function(L)bu=L end,get=function()return bu end},iphCondition={set=function(L)by=L end,get=function()return by end},stablized={set=function(L)bz=L end,get=function()return bz end},UseExtra={set=function(L)bA=L end,get=function()return bA end},SelectedTab={set=function(L)bE=L end,get=function()return bE end},saveRoute={set=function(L)bC=L end,get=function()return bC end}}local function bF(a,b,c,bG,bH,bI)bJ=bG()bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=0;bR=0;bS=0;bT=0;bU=false;bV=false;bW="empty"bX=3;bY=false;bZ=0;b_=0;c0=nil;c1=0;c2=0;c3=0;c4=false;c5=false;c6=false;c7=-1;c8=bI()>0;c9=bI()ca=b.getAltitude()cb=b.getConstructMass()cc=nil;cd=aa;ce=ab;cf={}cg={}ch={}ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=false;ct=false;cu=p;cv=false;cw=V;cx=nil;cy=0;cz=false;cA=false;cB=false;cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getVelocity())cF=vec3(b.getWorldVelocity())cG=vec3(cF):len()cH=vec3(b.getWorldVertical())cI=-cH:dot(cF)cJ=vec3(b.getConstructWorldPos())cK=false;cL=false;cM=true;cN=0;cO=0;cP={}cQ=false;cR=50000;cS=nil;cT=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;cU=false;cV=nil;cW=false;cX=0;cY=nil;cZ=nil;c_={}d0=90;d1=x;d2=nil;d3=nil;d4={}d5={}d6=false;d7=nil;if shield_1 then d8=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())end end;local function d9(d,b,c,a,da,db,dc,dd,de)local function df(dg)return type(dg)=='number'end;local function dh(dg)return type(dc(dg))=='number'end;local function di(dj)return type(dj)=='table'end;local function dk(a)return type(a)=='string'end;local function dl(dm)return di(dm)and df(dm.x and dm.y and dm.z)end;local function dn(dp)return di(dp)and df(dp.latitude and dp.longitude and dp.altitude and dp.id and dp.systemId)end;local dq=math.pi/180;local dr=180/math.pi;local ds=1e-10;local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..dt..','..dt..','..dt..','..dt..','..dt..'}'local utils=utils;local vec3=vec3;local function dv(dg)local dw=string.gsub(string.reverse(da('%.4f',dg)),'^0*%.?','')return dw==''and'0'or string.reverse(dw)end;local function dx(dy)if dl(dy)then return da('{x=%.3f,y=%.3f,z=%.3f}',dy.x,dy.y,dy.z)end;if di(dy)and not getmetatable(dy)then local dz={}local dA=next(dy)if type(dA)=='nil'or dA==1 then dz=dy else for dB,dm in pairs(dy)do local dC=dx(dm)if type(dB)=='number'then table.insert(dz,da('[%s]=%s',dB,dC))else table.insert(dz,da('%s=%s',dB,dC))end end end;return da('{%s}',table.concat(dz,','))end;if dk(dy)then return da("'%s'",dy:gsub("'",[[\']]))end;return tostring(dy)end;local dD={}dD.__index=dD;dD.__tostring=function(dy,dE)local dF={}for dB in pairs(dy)do table.insert(dF,dB)end;table.sort(dF)local dz={}for dG,dB in ipairs(dF)do local dC=dx(dy[dB])if type(dB)=='number'then table.insert(dz,da('[%s]=%s',dB,dC))else table.insert(dz,da('%s=%s',dB,dC))end end;if dE then return da('%s%s',dE,table.concat(dz,',\n'..dE))end;return da('{%s}',table.concat(dz,','))end;dD.__eq=function(dH,dI)return dH.systemId==dI.systemId and dH.id==dI.id and de(dH.radius,dI.radius)and de(dH.center.x,dI.center.x)and de(dH.center.y,dI.center.y)and de(dH.center.z,dI.center.z)and de(dH.GM,dI.GM)end;local function dJ(dK,dL,dM,dN,dO)assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(dM),'Argument 3 (radius) must be a number:'..type(dM))assert(di(dN),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dN))assert(dh(dO),'Argument 5 (GM) must be a number:'..type(dO))return setmetatable({systemId=dc(dK),id=dc(dL),radius=dc(dM),center=vec3(dN),GM=dc(dO)},dD)end;local dP={}dP.__index=dP;dP.__tostring=function(dQ)return da('::pos{%d,%d,%s,%s,%s}',dQ.systemId,dQ.id,dv(dQ.latitude*dr),dv(dQ.longitude*dr),dv(dQ.altitude))end;dP.__eq=function(dH,dI)return dH.id==dI.id and dH.systemId==dI.systemId and de(dH.latitude,dI.latitude)and de(dH.altitude,dI.altitude)and(de(dH.longitude,dI.longitude)or de(dH.latitude,math.pi/2)or de(dH.latitude,-math.pi/2))end;local function dR(dS,dL,dT,dU,dV)local dK=dS;if dk(dS)and not dU and not dV and not dL and not dT then dK,dL,dT,dU,dV=dW(dS,du)assert(dK,'Argument 1 (position string) is malformed.')else assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(dT),'Argument 3 (latitude) must be in degrees:'..type(dT))assert(dh(dU),'Argument 4 (longitude) must be in degrees:'..type(dU))assert(dh(dV),'Argument 5 (altitude) must be in meters:'..type(dV))end;dK=dc(dK)dL=dc(dL)dT=dc(dT)dU=dc(dU)dV=dc(dV)if dL==0 then return setmetatable({latitude=dT,longitude=dU,altitude=dV,id=dL,systemId=dK},dP)end;return setmetatable({latitude=dq*db(dT,-90,90),longitude=dq*(dU%360),altitude=dV,id=dL,systemId=dK},dP)end;local dX={}dX.__index=dX;dX.__tostring=function(dy,dE)local dY=dE and dE..'  'local dZ={}local dF={}for dB in pairs(dy)do table.insert(dF,dB)end;table.sort(dF)for dG,d_ in ipairs(dF)do e0=dy[d_]local e1=dD.__tostring(e0,dY)if dE then table.insert(dZ,da('[%s]={\n%s\n%s}',d_,e1,dE))else table.insert(dZ,da('  [%s]=%s',d_,e1))end end;if dE then return da('\n%s%s%s',dE,table.concat(dZ,',\n'..dE),dE)end;return da('{\n%s\n}',table.concat(dZ,',\n'))end;local function e2(e3)local e={}local pid;for dG,dm in pairs(e3)do local dL=dm.planetarySystemId;if type(dL)~='number'then error('Invalid planetary s ID: '..tostring(dL))elseif pid and dL~=pid then error('Mistringmatch planetary s IDs: '..dL..' and '..pid)end;local e4=dm.bodyId;if type(e4)~='number'then error('Invalid body ID: '..tostring(e4))elseif e[e4]then error('Duplicate body ID: '..tostring(e4))end;setmetatable(dm.center,getmetatable(vec3.unit_x))e[e4]=setmetatable(dm,dD)pid=dL end;return setmetatable(e,dX)end;e5={}local function e6(e3)return setmetatable({galaxyAtlas=e3 or{}},e5)end;e5.__index=function(dj,L)if type(L)=='number'then local a=dj.galaxyAtlas[L]return e2(a)end;return rawget(e5,L)end;e5.__pairs=function(dy)return function(dj,dB)local e7,e8=next(dj,dB)return e7,e8 and e2(e8)end,dy.galaxyAtlas,nil end;e5.__tostring=function(dy)local e9={}for dG,ea in pairs(dy or{})do local eb=ea:getPlanetarySystemId()local ec=dX.__tostring(ea,'    ')table.insert(e9,da('  [%s]={%s\n  }',eb,ec))end;return da('{\n%s\n}\n',table.concat(e9,',\n'))end;e5.BodyParameters=dJ;e5.MapPosition=dR;e5.PlanetarySystem=e2;function e5.createBodyParameters(dK,dL,ed,ee,ef,eg,eh)assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(ed),'Argument 3 (surfaceArea) must be a number:'..type(ed))assert(di(ee),'Argument 4 (aPosition) must be an array or vec3:'..type(ee))assert(di(ef),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ef))assert(dh(eg),'Argument 6 (altitude) must be in meters:'..type(eg))assert(dh(eh),'Argument 7 (gravityAtPosition) must be number:'..type(eh))local dM=dd(ed/4/math.pi)local c3=dM+eg;local ei=vec3(ee)+c3*vec3(ef)local dO=eh*c3*c3;return dJ(dK,dL,dM,ei,dO)end;e5.isMapPosition=dn;function e5:getPlanetarySystem(dS)if L==nil then L=0 end;if e8==nil then e8=0 end;local dK=dS;if dn(dS)then dK=dS.systemId end;if type(dK)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(e8)~=dX then a=e2(a)end;return a end end end;function dX:sizeCalculator(ej)return 1.05*ej.radius end;function dX:castIntersections(ek,el,em,en,eo,ep)local eq={}if eo then for dG,ej in pairs(eo)do table.insert(eq,ej)end else eq=c_ end;if not ep then table.sort(eq,function(er,es)local et=er.center;local eu=es.center;return(et.x-ek.x)^2+(et.y-ek.y)^2+(et.z-ek.z)^2<(eu.x-ek.x)^2+(eu.y-ek.y)^2+(eu.z-ek.z)^2 end)end;local ev=el:normalize()for dG,ej in ipairs(eq)do local ew=ej.center-ek;local dM=self:sizeCalculator(ej)local ex=ew:dot(ev)local ey=ex^2-(ew:len2()-dM^2)if ey>=0 then local ez=dd(ey)local eA=ex+ez;local eB=ex-ez;if eB>0 then return ej,eA,eB elseif eA>0 then return ej,eA,nil end end end;return nil,nil,nil end;function dX:closestBody(eC)assert(type(eC)=='table','Invalid coordinates.')local eD,ej;local eE=vec3(eC)for dG,eF in pairs(self)do local eG=(eF.center-eE):len2()if(not ej or eG<eD)and eF.name~="Space"then ej=eF;eD=eG end end;return ej end;function dX:convertToBodyIdAndWorldCoordinates(dS)local eH=dS;if dk(dS)then eH=dR(dS)end;if eH.id==0 then return 0,vec3(eH.latitude,eH.longitude,eH.altitude)end;local eF=self:getBodyParameters(eH)if eF then return eH.id,eF:convertToWorldCoordinates(eH)end end;function dX:getBodyParameters(dS)local dL=dS;if dn(dS)then dL=dS.id end;assert(dh(dL),'Argument 1 (id) must be a number:'..type(dL))return self[dL]end;function dX:getPlanetarySystemId()local dG,dm=next(self)return dm and dm.systemId end;function dD:convertToMapPosition(dN)assert(di(dN),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dN))local eI=vec3(dN)if self.id==0 then return setmetatable({latitude=eI.x,longitude=eI.y,altitude=eI.z,id=0,systemId=self.systemId},dP)end;local eJ=eI-self.center;local c3=eJ:len()local dV=c3-self.radius;local dT=0;local dU=0;if not de(c3,0)then local eK=eL(eJ.y,eJ.x)dU=eK>=0 and eK or 2*math.pi+eK;dT=math.pi/2-math.acos(eJ.z/c3)end;return setmetatable({latitude=dT,longitude=dU,altitude=dV,id=self.id,systemId=self.systemId},dP)end;function dD:convertToWorldCoordinates(dS)local eH=dk(dS)and dR(dS)or dS;if eH.id==0 then return vec3(eH.latitude,eH.longitude,eH.altitude)end;assert(dn(eH),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eH.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eH.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eM=math.cos(eH.latitude)return self.center+(self.radius+eH.altitude)*vec3(eM*math.cos(eH.longitude),eM*math.sin(eH.longitude),math.sin(eH.latitude))end;function dD:getAltitude(dN)return(vec3(dN)-self.center):len()-self.radius end;function dD:getDistance(dN)return(vec3(dN)-self.center):len()end;function dD:getGravity(dN)local eN=self.center-vec3(dN)local eO=eN:len2()return self.GM/eO*eN/dd(eO)end;return setmetatable(e5,{__call=function(dG,...)return e6(...)end})end;local function eP(d,b,c,a,dd,eQ)local cj={}local eR=30000000/3600;local eS=eR*eR;local eT=100;function cj.computeAccelerationTime(eU,eV,eW)local eX=eR*math.asin(eU/eR)return(eR*math.asin(eW/eR)-eX)/eV end;function cj.computeDistanceAndTime(eU,eW,eY,eZ,e_,f0)e_=e_ or 0;f0=f0 or 0;local f1=eU<=eW;local f2=eZ*(f1 and 1 or-1)/eY;local f3=-f0/eY;local f4=f2+f3;if f1 and f4<=0 or not f1 and f4>=0 then return-1,-1 end;local f5,f6=0,0;if f2~=0 and e_>0 then local eX=math.asin(eU/eR)local f7=math.pi*(f2/2+f3)local f8=f2*e_;local f9=eR*math.pi;local dm=function(dj)local fa=(f7*dj-f8*math.sin(math.pi*dj/2/e_)+f9*eX)/f9;local fb=math.tan(fa)return eR*fb/dd(fb*fb+1)end;local fc=f1 and function(a)return a>=eW end or function(a)return a<=eW end;f6=2*e_;if fc(dm(f6))then local fd=0;while eQ(f6-fd)>0.5 do local dj=(f6+fd)/2;if fc(dm(dj))then f6=dj else fd=dj end end end;local fe=eU;local ff=f6/eT;for fg=1,eT do local fh=dm(fg*ff)f5=f5+(fh+fe)*ff/2;fe=fh end;if f6<2*e_ then return f5,f6 end;eU=fe end;local eX=eR*math.asin(eU/eR)local bJ=(eR*math.asin(eW/eR)-eX)/f4;local fi=eS*math.cos(eX/eR)/f4;local c3=fi-eS*math.cos((f4*bJ+eX)/eR)/f4;return c3+f5,bJ+f6 end;function cj.computeTravelTime(eU,eV,c3)if c3==0 then return 0 end;if eV>0 then local eX=eR*math.asin(eU/eR)local fi=eS*math.cos(eX/eR)/eV;return(eR*math.acos(eV*(fi-c3)/eS)-eX)/eV end;if eU==0 then return-1 end;assert(eU>0,'Acceleration and initial speed are both zero.')return c3/eU end;return cj end;local function fj(d,b,c,a,da,db,dc,dd,de)local vec3=vec3;local d9=d9(d,b,c,a,da,db,dc,dd,de)local function dk(a)return type(a)=='string'end;local function di(dj)return type(dj)=='table'end;fk={}fk.__index=fk;function fk:escapeAndOrbitalSpeed(dV)assert(self.body)local c3=dV+self.body.radius;if not de(c3,0)then local fl=dd(self.body.GM/c3)return dd(2)*fl,fl end;return nil,nil end;function fk:orbitalParameters(dS,fm)assert(self.body)assert(di(dS)or dk(dS))assert(di(fm))local fn=(dk(dS)or d9.isMapPosition(dS))and self.body:convertToWorldCoordinates(dS)or vec3(dS)local dm=vec3(fm)local fo=fn-self.body.center;local fp=dm:len2()local fq=fo:len()local fr=self.body.GM;local fs=((fp-fr/fq)*fo-fo:dot(dm)*dm)/fr;local et=fr/(2*fr/fq-fp)local ft=fs:len()local ev=fs:normalize()local fu=et*(1-ft)local fv=et*(1+ft)local fw=fu*ev+self.body.center;local fx=ft<=1 and-fv*ev+self.body.center or nil;local fy=dd(et*fr*(1-ft*ft))local fz=fx and 2*math.pi*dd(et^3/fr)local fA=math.acos(fs:dot(fo)/(ft*fq))if fo:dot(dm)<0 then fA=-(fA-2*math.pi)end;local fB=math.acos((math.cos(fA)+ft)/(1+ft*math.cos(fA)))local fC=fB;if fC<0 then fC=fC+2*math.pi end;local fD=fC-ft*math.sin(fC)local fE=0;local fF=0;local fG=0;if fz~=nil then fE=fD/(2*math.pi/fz)fF=fz-fE;fG=fF+fz/2;if fA-math.pi>0 then fF=fE;fG=fF+fz/2 end;if fG>fz then fG=fG-fz end end;return{periapsis={position=fw,speed=fy/fu,circularOrbitSpeed=dd(fr/fu),altitude=fu-self.body.radius},apoapsis=fx and{position=fx,speed=fy/fv,circularOrbitSpeed=dd(fr/fv),altitude=fv-self.body.radius},currentVelocity=dm,currentPosition=fn,eccentricity=ft,period=fz,eccentricAnomaly=fB,meanAnomaly=fD,timeToPeriapsis=fF,timeToApoapsis=fG,trueAnomaly=fA}end;local function fH(fI)local eF=d9.BodyParameters(fI.systemId,fI.id,fI.radius,fI.center,fI.GM)return setmetatable({body=eF},fk)end;return setmetatable(fk,{__call=function(dG,...)return fH(...)end})end;local function fJ(d,b,c,a,dbHud_1,e,fK,fL,bH,dc,dd,fM)local function fN(fO)local dQ=fP:closestBody(fO)if(fO-dQ.center):len()>dQ.radius+dQ.noAtmosphericDensityAltitude then dQ=e[0][0]end;return dQ end;local function fQ()local function fR(fS,fT)return fS.name<fT.name end;cP={}for dB,dm in pairs(e[0])do cP[#cP+1]={name=dm.name,index=dB}end;table.sort(cP,fR)end;local function fU(fV,fW)if not fW then fW=fX.name end;for dB,dm in pairs(fV)do if dm.name and dm.name==fW then return dB end end;return-1 end;local function fY()cX=bj;if bj==0 then bh="None"c0=nil;fX=nil;return true end;local fZ=cP[bj].index;local f_=e[0][fZ]if f_.center then bh=f_.name;c0=ci[0][fZ]if fX~=nil then if c9==0 then if fK(g0,g1)~=1 then fL(g0,g1)end;if fK(g2,g3)~=1 then fL(g2,g3)end;if fK(g4,g5)~=1 then fL(g4,g5)end;if fK(g6,g7)~=1 then fL(g6,g7)end;if fK(g8,g9)~=1 then fL(g8,g9)end end;if fK(ga,gb)~=1 then fL(ga,gb)end;if fK(gc,gd)~=1 then fL(gc,gd)end;if fK(ge,gf)~=1 then fL(ge,gf)end end;fX=nil else fX=f_;for dG,dm in pairs(ci[0])do if dm.name==fX.planetname then c0=dm;bh=fX.name;break end end;if fK(ga,gb)~=1 then fL(ga,gb)end;if fK(gc,gd)~=1 then fL(gc,gd)end end;if fX==nil then bi=vec3(c0.center)else bi=fX.position end;if c0.planetname~="Space"then if c0.hasAtmosphere then gg=bH(c0.radius*(T-1)+c0.noAtmosphericDensityAltitude)else gg=bH(c0.radius*(T-1)+c0.surfaceMaxAltitude)end else gg=S end;if fX~=nil and fX.planetname=="Space"then bd=0 else dG,bd=cl(c0):escapeAndOrbitalSpeed(gg)end;bf=0;b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"return true end;local function gh(gi)if not b1 and not bo and not c5 and not bx and not b6 and not c6 then if gi==nil then bj=bj+1;if bj>#cP then bj=0 end else bj=bj-1;if bj<0 then bj=#cP end end;if bj==0 then fY()else local fZ=cP[bj].index;local f_=e[0][fZ]if f_ and(f_~=nil and f_.name=="Space"or by=="Custom Only"and f_.center or by=="No Moons"and string.find(f_.name,"Moon")~=nil)then if gi==nil then gh()else gh(1)end else fY()end end else bW="Disengage autopilot before changing Interplanetary Helper"fM("iph","AP")end end;local function gj()local function gk(gl)local gm;if gl then gm=d4 else gm=bn end;local gn=-1;gn=fU(e[0])if gn>-1 then table.remove(e[0],gn)end;gn=-1;gn=fU(gm)if gn~=-1 then bW=fX.name.." saved location cleared"table.remove(gm,gn)end;gh()fQ()return gm end;if string.sub(bh,1,1)=="*"then d4=gk(true)else bn=gk(false)end end;local function go(gp,fO,gq,gr)local function gs(gl)if gl then gm=d4 else gm=bn end;if dbHud_1 or gq or gl then local dQ=fN(fO)local gt={position=fO,name=gp,planetname=dQ.name,gravity=b.g(),safe=gr}if not gq then gm[#gm+1]=gt else for dB,dm in pairs(e[0])do if dm.name and gp==dm.name then table.remove(e[0],dB)end end end;table.insert(e[0],gt)fQ()fY()bW="Location saved as "..gp.."("..dQ.name..")"return gm else bW="Databank must be installed to save permanent locations"end end;if string.sub(gp,1,1)=="*"then d4=gs(true)else bn=gs(false)end end;local gu={}function gu.UpdateAtlasLocationsList()fQ()end;function gu.UpdateAutopilotTarget()fY()end;function gu.adjustAutopilotTargetIndex(gi)gh(gi)end;function gu.findAtlasIndex(fV,fW)return fU(fV,fW)end;function gu.UpdatePosition(gv,gw)local function gx(gl)local gm;if gl then gm=d4 else gm=bn end;local gn=fU(gm)if gn~=-1 then if gv~=nil then if gl then gv="*"..gv end;gm[gn].name=gv;bj=bj-1;gh()else local gy=gm[gn]if gw then gy.heading=cD:cross(cH)*5000;bW=gm[gn].name.." heading saved ("..gm[gn].planetname..")"return elseif gw==false then gy.heading=nil;bW=gm[gn].name.." heading cleared ("..gm[gn].planetname..")"return end;gy.gravity=b.g()gy.position=cJ;gy.safe=true end;bW=gm[gn].name.." position updated ("..gm[gn].planetname..")"else bW="Name Not Found"end end;if string.sub(bh,1,1)=="*"then gx(true)else gx(false)end end;function gu.AddNewLocation(gp,fO,gq,gr)go(gp,fO,gq,gr)end;function gu.ClearCurrentPosition()gj()end;for dB,dm in pairs(d5)do table.insert(e[0],dm)end;fQ()if bj>#cP then bj=0 end;gu.UpdateAutopilotTarget()return gu end;local function gz(b,a,c,library,radar_1,radar_2,eQ,gA,dd,gB,dc,gC,fM)local gD={}local gE={}local gF={XS=13,S=27,M=55,L=110,XL=221}local gG={}local gH;local gI;local gJ;local gK;local gL;local gM={}local gN="Atmo"local gO;local gP;local gQ=0;local gR={}local function gS()local function gT(gU,gV,gW,gX,gY,gZ,g_,h0)gV,gX,gZ,h0=vec3(gV),vec3(gX),vec3(gZ),vec3(h0)local h1,h2,h3=gU*gU,gW*gW,gY*gY;local fp=gX-gV;local h4=fp:normalize()local h5=fp:len()local h6=gZ-gV;local h7=(h6-h6:project_on(h4)):normalize()local h8,h9=h6:dot(h4),h6:dot(h7)local ha=h8*h8+h9*h9;local hb=h4:cross(h7)local hc=(h1-h2+h5*h5)/(2*h5)local hd=(h1-h3+ha-2*h8*hc)/(2*h9)local dp=h1-hc^2-hd^2;local he=dd(dp)local hf=gV+h4*hc+h7*hd+hb*he;local hg=gV+h4*hc+h7*hd-hb*he;if eQ((h0-hf):len()-g_)<eQ((h0-hg):len()-g_)then return hf else return hg end end;local function hh()local function hi()local hj=b.getConstructWorldOrientationRight()local fp=b.getConstructWorldOrientationForward()local h6=b.getConstructWorldOrientationUp()local hk=library.systemResolution3(hj,fp,h6,{1,0,0})local hl=library.systemResolution3(hj,fp,h6,{0,1,0})local hm=library.systemResolution3(hj,fp,h6,{0,0,1})return function(hn)return library.systemResolution3(hk,hl,hm,hn)end end;local ho=hi()local hp=b.getConstructWorldPos()local fn=b.getElementPositionById(1)local hq={fn[1],fn[2],fn[3]}local hr=ho(hq)local hs={hp[1]-hr[1],hp[2]-hr[2],hp[3]-hr[3]}return hs end;local function ht(hu,fq,hv)local hw=hu.pts;local gn=#hw;local hx=hu.ref;if gn>3 then local hy,hz,hA,hB=hw[gn],hw[gn-1],hw[gn-2],hw[gn-3]hu.ref=hv;local fn=gT(hy[1],hy[2],hz[1],hz[2],hA[1],hA[2],hB[1],hB[2])local hc,hd,he=fn.x,fn.y,fn.z;if hc==hc and hd==hd and he==he then hc=hc+hx[1]hd=hd+hx[2]he=he+hx[3]local hC=vec3(hc,hd,he)if not hu.lastPos then hu.center=hC elseif(hu.lastPos-hC):len()<2 then hu.center=hC;hu.skipCalc=true end;hu.lastPos=hC end;hu.pts={}else local hD={hv[1]-hx[1],hv[2]-hx[2],hv[3]-hx[3]}hw[gn+1]={fq,hD}end end;if radar_1 or radar_2 then cp.assignRadar()end;if gM[1]then gH=#gM[1].getConstructIds()local hE=gM[1].getData()local hF=hE:gmatch('{"constructId[^}]*}[^}]*}')if gH>0 then local hv=hh()local hG,hH=0,0;gL,gK=0,0;for dm in hF do local dL,c3,hI=dm:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hJ=gF[hI]c3=dc(c3)if gM[1].hasMatchingTransponder(dL)==1 then table.insert(gE,dL)end;local hK=gM[1].getConstructType(dL)if F then if hJ>27 or hK=="static"or hK=="space"then gL=gL+1;local gp=gM[1].getConstructName(dL)local hu=gR[dL]if hu==nil then hJ=hJ+gC;gR[dL]={pts={},ref=hv,name=gp,i=0,radius=hJ,skipCalc=false}hu=gR[dL]end;if not hu.skipCalc then ht(hu,c3,hv)hH=hH+1 end;if hu.center then table.insert(gG,hu)end end;hG=hG+1;if cT and hG>700 or hH>70 or(not cT and hG>300 or hH>30)then coroutine.yield()hG,hH=0,0 end end end;gK=#gG;if gK>0 and cG>20 then local ej,hL,hM,hN;local hO=0;local hP=ci:getPlanetarySystem(0)hN=cF:normalize()while hO<gK do coroutine.yield()local hQ={table.unpack(gG,hO,math.min(hO+75,gK))}ej,hL,hM=hP:castIntersections(cJ,hN,nil,nil,hQ,true)if ej and hM then cV={ej,hL,hM}break end;hO=hO+75 end;if not ej then cV=nil end else cV=nil end;gG={}gI=hE:find('identifiedConstructs":%[%]')else gJ=hE:find('worksInEnvironment":false')end end end;local function hR()if gM[1]then gN="Atmo"if gM[1].getData():find('worksInAtmosphere":false')then gN="Space"end end end;function gD.pickType()hR()end;function gD.assignRadar()if radar_1 and gM[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gM[1]=radar_2 end;if gM[1]==radar_2 then hR()end elseif radar_2 and gM[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gM[1]=radar_1 end;if gM[1]==radar_1 then hR()end end end;function gD.UpdateRadar()local hS=coroutine.status(gO)if hS=="suspended"then local dC,hT=coroutine.resume(gO)if hT then a.print("ERROR UPDATE RADAR: "..hT)end elseif hS=="dead"then gO=coroutine.create(gS)local dC,hT=coroutine.resume(gO)end end;function gD.GetRadarHud(hU,hV,hW,hX)local hY=gE;local hZ,h_;gE={}local dt=gK or 0;if gH>0 then if F then h_=dt.."/"..gL.." Plotted : "..gH-gL.." Ignored"else h_="Radar Contacts: "..gH end;hZ=gB(hW,hX,h_,"pbright txtbig txtmid")if#gE>0 then hZ=hZ..gB(hU,hV,"Friendlies In Range","pbright txtbig txtmid")for dB,dm in pairs(gE)do hV=hV+20;hZ=hZ..gB(hU,hV,gM[1].getConstructName(dm),"pdim txtmid")end end;if gI==nil and gP==nil then gQ=1;cp.ToggleRadarPanel()end;if gI~=nil and gP~=nil then cp.ToggleRadarPanel()end;if d3==nil then cp.ToggleRadarPanel()end else if gJ then hZ=gB(hW,hX,gN.." Radar: Jammed","pbright txtbig txtmid")else hZ=gB(hW,hX,"Radar: No "..gN.." Contacts","pbright txtbig txtmid")end;if d3~=nil then gQ=0;cp.ToggleRadarPanel()end end;return hZ end;function gD.GetClosestName(gp)if gM[1]then local dL,dG=gM[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dL~=nil and dL~=""then gp=gp.." "..gM[1].getConstructName(dL)end end;return gp end;function gD.ToggleRadarPanel()if d3~=nil and gQ==0 then gA(d3)d3=nil;if gP~=nil then gA(gP)gP=nil end else if gQ==1 then gA(d3)d3=nil;_autoconf.displayCategoryPanel(gM,1,"Periscope","periscope")gP=_autoconf.panels[_autoconf.panels_size]end;if d3==nil then _autoconf.displayCategoryPanel(gM,1,"Radar","radar")d3=_autoconf.panels[_autoconf.panels_size]end;gQ=0 end end;function gD.ContactTick()if not i0 then i0=0 end;if bJ>i0+10 then bW="Radar Contact"fM("rdrCon","RC")i0=bJ end;c.stopTimer("contact")end;function gD.onEnter(dL)if radar_1 and not c8 and not cQ then c.setTimer("contact",0.1)end end;function gD.onLeave(dL)if radar_1 and F then if#gR>650 then dL=tostring(dL)gR[dL]=nil end end end;gM[1]=nil;if radar_1 then gM[1]=radar_1;hR()end;gO=coroutine.create(gS)return gD end;local function i1(shield_1,dW,bH)local i2={}local i3=shield_1.getResistancesCooldown()local function i4()local i5=shield_1.getState()if G then if not cQ and i5==0 then shield_1.toggle()elseif cQ and i5==1 then shield_1.toggle()end end end;local function i6()local i7=shield_1.getStressRatioRaw()local i8=0.5999;if i7[1]==0.0 and i7[2]==0.0 and i7[3]==0.0 and i7[4]==0.0 then return end;local i9=shield_1.setResistances(i8*i7[1],i8*i7[2],i8*i7[3],i8*i7[4])if i9==1 then bW="Shield Resistances updated"else bW="Value Exceeded. Failed to update Shield Resistances"end end;function i2.shieldTick()d8=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())i4()i3=shield_1.getResistancesCooldown()if i3==0 and d8<a8 then i6()end end;function i2.setResist(ia)if not shield_1 then bW="No shield found"return elseif ia==nil or i3>0 then bW="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du=dt..', '..dt..', '..dt..', '..dt;local ib,ic,id,ie=dW(ia,du)if ie==nil or ib+ic+id+ie>0.6 then bW="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(ib,ic,id,ie)==1 then bW="Shield Resistances set"else bW="Resistance setting failed."end end;function i2.ventShield()local ig=shield_1.getVentingCooldown()if ig>0 then bW="Cannot vent again for "..ig.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()bW="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bW="Shields already at max hitpoints"end end;return i2 end;local function ih(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ii,eQ,bH,da,ij,bI,ik,il,eL,bG,db,im,fL,fK,gA,io,dd,ip,gB,fM,iq,ir,is,it,iu,iv)local iw=9.80665;local ix={}local iy={}local iz={}local iA={}local iB=nil;local iC=nil;local iD=nil;local iE=false;local iF="none"local iG=""local iH=55;local iI=0;local iJ=0;local iK=""local iL=nil;local iM=ad;local iN=ae;local iO=af;local iP=[[rgb(]]..bH(iM+0.5)..","..bH(iN+0.5)..","..bH(iO+0.5)..[[)]]local iQ=[[rgb(]]..bH(iM*0.9+0.5)..","..bH(iN*0.9+0.5)..","..bH(iO*0.9+0.5)..[[)]]local iR=0;local iS=0;local iT=""local iU=bG()local iV=false;local iW=vec3({13771471,7435803,-128971})local iX=18000000;local iY=500000;local iZ,i_=math.huge;local j0;local function j1(j2)iZ=vec3(j2):dist(iW)if iZ<iX then return true,eQ(iZ-iX)end;i_=vec3(j2):dist(vec3(j3.center))if i_<iY then j0=true else j0=false end;if eQ(i_-iY)<eQ(iZ-iX)then return j0,eQ(i_-iY)else return j0,eQ(iZ-iX)end end;local function j4(dm)if cd==1920 then return dm else return ip(cd*dm/1920,0)end end;local function j5(dm)if ce==1080 then return dm else return ip(ce*dm/1080,0)end end;local function j6()return io()==0 and g~="keyboard"and il()==0 end;local function j7()local j8="TRAVEL"if not cM then j8="CRUISE"end;if b1 then j8="AUTOPILOT"end;return j8 end;local hZ=""local j9=""local ja=""local jb=1;local jc=2;local jd=3;local je=4;local jf=5;local jg=6;local jh=""local ji=0;local jj=bH(1/aQ)*2*aR;local jk={}local jl={}local jm={}local jn={}local jo={}local jp={}local jq={}jq["atmofueltank"],jq["spacefueltank"],jq["rocketfueltank"]=0,0,0;local jr=0;local function js(hc,jt,ju,jv,jw,jx)local jy=jr;local jz=jr+5;if not C then jz=jz+5 end;if il()==1 and not l then jy=jy-50;jz=jz-50 end;if ju=="ATMO"then jh="atmofueltank"elseif ju=="SPACE"then jh="spacefueltank"else jh="rocketfueltank"end;ji=_G[jh.."_size"]if#jv>0 then for L=1,#jv do local gp=string.sub(jv[L][jc],1,12)local jA=0;for jB=1,ji do if jv[L][jc]==ij(c[jh.."_"..jB].getData()).name then jA=jB;break end end;local jC=bG()if jw[L]==nil or jx[L]==nil or jC-jv[L][jg]>jj then local jD;local jE=0;jE=ik(jv[L][jb])-jv[L][je]jD=jv[L][jf]if jD>jE then jq[jh]=jq[jh]+jD-jE end;if jA~=0 then jx[L]=ij(c[jh.."_"..jA].getData()).percentage;jw[L]=ij(c[jh.."_"..jA].getData()).timeLeft;if jw[L]=="n/a"then jw[L]=0 end else jx[L]=bH(0.5+jE*100/jv[L][jd])if jD<=jE then jw[L]=0 else jw[L]=bH(0.5+jE/((jD-jE)/(jC-jv[L][jg])))end end;jv[L][jg]=jC;jv[L][jf]=jE end;if gp==jt then gp=da("%s %d",ju,L)end;if jA==0 then gp=gp.." *"end;local jF;if jw[L]==0 then jF=""else jF=it(jw[L])end;if jx[L]~=nil then local jG=bH(jx[L]*2.55)local jH=da("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""if jF~=""and jw[L]<120 or jx[L]<5 then jI="red "end;local jJ=da("rgb(%d,%d,%d)",db(bH((255-jG)/2.55),50,100),db(bH(jG/2.55),0,50),50)local jK="rgb(196,0,255)"if ju=="ATMO"then jK="rgb(0,188,255)"elseif ju=="SPACE"then jK="rgb(239,255,0)"end;local jL=false;if jM~=jK then jL=true end;jM=jK;if C then if jL then jy=jy-5;jz=jz-5 end;j9=j9 ..da([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jJ,jK,hc,jz,jH,bH(jx[L]*1.7+0.5)-2,hc+1,jz+1,hc+5,jz+14,gp,jx[L],jF)jy=jy-22;jz=jz-22 else j9=j9 ..gB(hc,jy,gp,jI.."pdim txtfuel")j9=j9 ..gB(hc,jz,da("%d%% %s",jx[L],jF),"pdim txtfuel","fill:"..jH)jy=jy+30;jz=jz+30 end end end end;jr=jy end;local function jN(jO,dV)if an==0 and ao==0 then return end;if dV<200000 and not c8 or dV and c8 then local jP=0;if eQ(cI)>1 then jP=45*math.log(eQ(cI),10)if cI<0 then jP=-jP end end;jO[#jO+1]=da([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],an,ao,bH(cI),bH(jP))end;return jO end;local function jQ(jR)local gi=-cH;jR=jR-jR:project_on(gi)local jS=vec3(0,0,1)jS=jS-jS:project_on(gi)local jT=jS:cross(gi)local jP=jS:angle_between(jR)*constants.rad2deg;if jR:dot(jT)<0 then jP=360-jP end;return jP end;local function jU(jO,aj,ak,jV,jW,cT)if ac==0 then return end;local jX=ac;local jY=20;local jZ=bH(jV)if cT then for L=-45,45,5 do local j_=L;jO[#jO+1]=da([[<g transform="rotate(%f,%d,%d)">]],j_,aj,ak)k0=5;if L%15==0 then k0=15 elseif L%10==0 then k0=10 end;jO[#jO+1]=da([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],aj,ak+jX+jY-k0,aj,ak+jX+jY)end;jO[#jO+1]=gB(aj,ak+jX+jY-35,jW,"pdim txt txtmid")jO[#jO+1]=gB(aj,ak+jX+jY-25,jZ.." deg","pdim txt txtmid")jO[#jO+1]=da([[<g transform="rotate(%f,%d,%d)">]],-jV,aj,ak)jO[#jO+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/>]],aj-5,ak+jX+jY-20,aj+5,ak+jX+jY-20,aj,ak+jX+jY-15)jO[#jO+1]="</g>"end;jO[#jO+1]=[[<g style="clip-path: url(#headingClip);">]]local k1=jZ;if cT then k1=jQ(cC)end;local k2=20;local k3=bH(k1)local k4=0;local k5=ak+jX+jY+20;local k6=aj;if jW~="YAW"then k5=j5(130)k6=j4(960)end;local k7=[[<path class="txttick line" d="]]local k8=bH(k3-(k2+10)-k3%5+0.5)for L=k8+70,k8,-5 do local hc=k6-(-L*5+k1*5)if L%10==0 then k4=10;local dt=L;if dt==360 then dt=0 elseif dt>360 then dt=dt-360 elseif dt<0 then dt=dt+360 end;jO[#jO+1]=gB(hc,k5+15,dt,"txtmid bright")elseif L%5==0 then k4=5 end;if k4==10 then k7=da([[%s M %f %f v %d]],k7,hc,k5-5,k4)else k7=da([[%s M %f %f v %d]],k7,hc,k5-2.5,k4)end end;jO[#jO+1]=k7 ..[["/>]]jO[#jO+1]=da([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k6-5,k5-20,k6+5,k5-20,k6,k5-10)if I then if cT then jW="HDG"end;jO[#jO+1]=gB(j4(960),j5(100),k3 .."°","dim txt txtmid size14","")jO[#jO+1]=gB(j4(960),j5(85),jW,"dim txt txtmid size20","")end;jO[#jO+1]=[[</g>]]end;local function k9(jO,ka,jV,aj,ak,cT,kb,fh)if ac==0 then return end;local jX=ac;local kc=bH(jX*3/5)if jX>0 then local kd=bH(ka)local k0=0;local k7=da([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jV,aj,ak)if not c8 then k7=da([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],aj,ak)end;jO[#jO+1]=da([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jX-1,aj,ak)jO[#jO+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bH(kd-30-kd%5+0.5),bH(kd+30+kd%5+0.5),5 do if L%10==0 then k0=30 elseif L%5==0 then k0=20 end;local hd=ak+-L*5+ka*5;if k0==30 then k7=da([[%s M %d %f h %d]],k7,aj-kc-k0,hd,k0)if c8 then jO[#jO+1]=da([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,aj,ak,aj-kc+10,hd+4,L)jO[#jO+1]=da([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,aj,ak,aj+kc-10,hd+4,L)if L==0 or L==180 or L==-180 then jO[#jO+1]=da([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,aj,ak,aj-kc+20,hd,kc*2-40)end else jO[#jO+1]=gB(aj-kc+10,hd,L,"pdim txt txtmid")jO[#jO+1]=gB(aj+kc-10,hd,L,"pdim txt txtmid")end;k7=da([[%s M %d %f h %d]],k7,aj+kc,hd,k0)else k7=da([[%s M %d %f h %d]],k7,aj-kc-k0,hd,k0)k7=da([[%s M %d %f h %d]],k7,aj+kc,hd,k0)end end;jO[#jO+1]=k7 ..[["/>]]local ke="PITCH"if not cT then ke="REL PITCH"end;if ka>90 and not c8 then ka=90-(ka-90)elseif ka<-90 and not c8 then ka=-90-(ka+90)end;if jX>200 then if c8 then if fh>iH then jO[#jO+1]=gB(aj,ak-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gB(aj,ak+20,kb,"pdim txt txtmid")end;jO[#jO+1]=da([[<g transform="rotate(%f,%d,%d)">]],-jV,aj,ak)else jO[#jO+1]=da([[<g transform="rotate(0,%d,%d)">]],aj,ak)end;jO[#jO+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],aj-kc+25,ak-5,aj-kc+20,ak,aj-kc+25,ak+5,aj-kc+50,ak+4,kd)jO[#jO+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],aj+kc-25,ak-5,aj+kc-20,ak,aj+kc-25,ak+5,aj+kc-30,ak+4,kd)jO[#jO+1]="</g>"end;local kf=bH(jX/3)jO[#jO+1]=da([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],aj-kf,ak,jX-kf)if not c8 and cT then jO[#jO+1]=da([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,aj,ak,aj-kc+10,ak,kc*2-20)end;jO[#jO+1]="</g>"if jX<200 then if c8 and fh>iH then jO[#jO+1]=gB(aj,ak-jX,ke,"pdim txt txtmid")jO[#jO+1]=gB(aj,ak-jX+10,kd,"pdim txt txtmid")jO[#jO+1]=gB(aj,ak-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gB(aj,ak+20,kb,"pdim txt txtmid")else jO[#jO+1]=gB(aj,ak-jX,ke,"pdim txt txtmid")jO[#jO+1]=gB(aj,ak-jX+15,kd,"pdim txt txtmid")end end end end;local function kg(jO,dV,cT)local kh=ap;local ki=aq;if kh==0 and ki==0 then return end;local kj=78;local kk=19;local kl=c7;if c7~=-1 then jO[#jO+1]=gB(kh+kj,ki+kk+20,da("AGL: %.1fm",c7),"pdim altsm txtend")end;if cT and(dV<200000 and not c8 or dV and c8)then table.insert(jO,da([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kh-1,ki-4,kj+2,kk+6,kh+1,ki-1,kj-4,kk))local gn=0;local km=1;local kn=0;local ko=dV<0;local kp=dV<j3.surfaceMaxAltitude;local kq=9;if ko then kq=0 end;local dV=eQ(dV)while gn<6 do local kr=11;local ks=16;local kt=9;local ku=14;local jI="altsm"if gn>2 then ks=ks+3;kr=kr+2;ku=ku+2;kt=kt-6;jI="altbig"end;if ko then jI=jI.." red"elseif kp then jI=jI.." orange"end;local kv=dV/km%10;local kw=bH(kv)local kx=bH((kw+1)%10)local ky=kn;if gn==0 then ky=kv-kw;if ko then ky=1-ky end end;if ko and(gn==0 or kn~=0)then local gq=kx;kx=kw;kw=gq end;local kz=ks*(ky-1)local kA=kz+ks;local hc=kh+kt+(6-gn)*kr;local hd=ki+ku;jO[#jO+1]=gB(hc,hd+kz,kx,jI)jO[#jO+1]=gB(hc,hd+kA,kw,jI)gn=gn+1;km=km*10;if kw==kq then kn=ky else kn=0 end end;table.insert(jO,[[</g></g>]])end end;local function kB(fm)local kC=-math.deg(eL(fm.y,fm.z))+180;kC=kC-90;if kC<0 then kC=360+kC end;if kC>180 then kC=-180+kC-180 end;return-kC end;local function kD(fm)local k1=math.deg(eL(fm.y,fm.x))-90;if k1<-180 then k1=360+k1 end;return k1 end;local function kE(jO,fm,fh,aj,ak)if fh>5 and not c8 or fh>iH then local jX=ac;local kF=20;local kG=20;local kH=kB(fm)local kI=kD(fm)local kJ=14;local kK=kJ/2;local kL=-kI/kG*jX;local kM=kH/kF*jX;local hc=aj+kL;local hd=ak+kM;local c3=dd(kL^2+kM^2)local kN=[[<circle
                            cx="]]..hc..[["
                            cy="]]..hd..[["
                            r="]]..kK/kJ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hc..[["
                            cy="]]..hd..[["
                            r="]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hc-kJ..[[,]]..hd..[[ h ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hc+kK..[[,]]..hd..[[ h ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hc..[[,]]..hd-kJ..[[ v ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c3<jX then jO[#jO+1]=kN else local jP=eL(kM,kL)local kO=4;local kP=aj+jX*math.cos(jP)local kQ=ak+jX*math.sin(jP)jO[#jO+1]=da('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jP*180/math.pi,kP,kQ,kP-kO,kQ-kO/2,kO*2,kO,kP+kO,kQ-kO,kO,kO,-kO,kO)end;if not c8 then local kR=vec3(fm)kH=kB(-kR)kI=kD(-kR)kL=-kI/kG*jX;kM=kH/kF*jX;hc=aj+kL;hd=ak+kM;c3=dd(kL^2+kM^2)if c3<jX then local kS=[[<circle
                                    cx="]]..hc..[["
                                    cy="]]..hd..[["
                                    r="]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hc..[[,]]..hd-kJ..[[ v ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hc..[[,]]..hd..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hc..[[,]]..hd..[[)" />
                                <path
                                    d="M ]]..hc-kK..[[,]]..hd..[[ h ]]..kJ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hc..[[,]]..hd..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hc..[[,]]..hd..[[)"/>]]jO[#jO+1]=kS end end end end;local function kT(jO,j8,kU,kV)if al==0 and am==0 then return end;kU=bH(kU+0.5)local jy=am+10;local jz=am+20;if il()==1 and not l then jy=55;jz=65 end;local kW="CRUISE"local c="km/h"local dC=kV;if j8=="TRAVEL"or j8=="AUTOPILOT"then kW="THROT"c="%"dC=kU;local kX="dim"if kU<0 then kX="red"end;jO[#jO+1]=da([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kX,al-7,am-50,al,am-50,al,am+50,al-7,am+50,1-eQ(kU),al-10,am+50,al-15,am+53,al-15,am+47)end;jO[#jO+1]=gB(al+10,jy,kW,"pbright txtstart")jO[#jO+1]=gB(al+10,jz,da("%.0f %s",dC,c),"pbright txtstart")if c8 and u and cM and bM then kU=bH(bN*100+0.5)local kX="red"if kU<0 then kX="red"end;jO[#jO+1]=da([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kX,1-eQ(kU),al-10,am+50,al-15,am+53,al-15,am+47)jO[#jO+1]=gB(al+10,jy+40,"LIMIT","pbright txtstart")jO[#jO+1]=gB(al+10,jz+40,kU.."%","pbright txtstart")end;if c8 and u or b6 then jO[#jO+1]=gB(al+10,jy-40,"LIMIT: "..cw.." km/h","dim txtstart")elseif not c8 and b1 then jO[#jO+1]=gB(al+10,jy-40,"LIMIT: "..bH(a0*3.6+0.5).." km/h","dim txtstart")end end;local function kY(jO,kZ)if al==0 and am==0 then return end;local k_=am-10;local l0=al+10;jO[#jO+1]=gB(0,0,"","pdim txt txtend")if il()==1 and not l then k_=75 end;jO[#jO+1]=gB(l0,k_,bH(kZ).." km/h","pbright txtbig txtstart")end;local function l1(jO)jO[#jO+1]=gB(j4(1900),j5(1070),da("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jO[#jO+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jO[#jO+1]=gB(j4(960),j5(550),"Warning: Invalid Control Scheme Detected","warnings")jO[#jO+1]=gB(j4(960),j5(600),"Keyboard Scheme must be selected","warnings")jO[#jO+1]=gB(j4(960),j5(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l2=j4(960)local l3=j5(860)local l4=j5(880)local l5=j5(900)local l6=j5(960)local l7=j5(200)local l8=j5(250)local l9=j5(960)if il()==1 and not l then l3=j5(135)l4=j5(155)l5=j5(175)l7=j5(115)l8=j5(95)end;local la="#222222"local lb="white"local lc="dimmer"local ld="pbright"local le="#110000"local lf=la;local lg=lc;if aZ then jO[#jO+1]=gB(l2,l3,"Brake Engaged","warnings")le="#440000"lf=lb;lg=ld elseif bL>0 then jO[#jO+1]=gB(l2,l3,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local lh="#110000"local li=la;local lj=lc;if c8 and cv and c7==-1 then if not b1 and not bo and not b4 and not cL and not b7 and not b5 then jO[#jO+1]=gB(l2,l7+50,"** STALL WARNING **","warnings")lh="#ff0000"li=lb;lj=ld;fM("stall","SW",2)end end;if cS then jO[#jO+1]=gB(l2,l7+90,"Flight Assist in Progress","warnings")end;if cc then jO[#jO+1]=gB(l2,l9,"Gyro Enabled","warnings")end;local lk="#111100"local ll=la;local lm=lc;if bk then lk="#775500"ll=lb;lm=ld;if bP then jO[#jO+1]=gB(l2,l4,"Gear Extended","warn")else jO[#jO+1]=gB(l2,l4,"Landed (G: Takeoff)","warnings")end;local ln=is(d:getTargetGroundAltitude())jO[#jO+1]=gB(l2,l5,"Hover Height: "..ln,"warn")end;local lo="#000011"local lp=la;local lq=lc;if bY then lo="#0000DD"lp=lb;lq=ld;jO[#jO+1]=gB(l2,l6+20,"ROCKET BOOST ENABLED","warn")end;local lr="#001100"local ls=la;local lt=lc;if antigrav and not q and cL and bt~=nil then lr="#00DD00"ls=lb;lt=ld;if eQ(ca-antigrav.getBaseAltitude())<501 then jO[#jO+1]=gB(l2,l7+15,da("Target Altitude: %d Singularity Altitude: %d",bH(bt),bH(antigrav.getBaseAltitude())),"warn")else jO[#jO+1]=gB(l2,l7+15,da("Target Altitude: %d Singluarity Altitude: %d",bH(bt),bH(antigrav.getBaseAltitude())),"warnings")end elseif b1 and bh~="None"then jO[#jO+1]=gB(l2,l7+20,"Autopilot "..be,"warn")elseif br~=nil then jO[#jO+1]=gB(l2,l7+20,da("LockedPitch: %d",bH(br)),"warn")elseif bU then jO[#jO+1]=gB(l2,l7+20,"Follow Mode Engaged","warn")elseif b6 or c6 then jO[#jO+1]=gB(l2,l7+20,"Re-entry in Progress","warn")end;if b3 or b7 then local ln=is(b8,2)if b7 then if cL then ln=is(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jO[#jO+1]=gB(l2,l7,"VTO to "..ln,"warn")elseif b5 and not bx then if c5 then jO[#jO+1]=gB(l2,l7,"Takeoff to "..bh,"warn")else jO[#jO+1]=gB(l2,l7,"Takeoff to "..ln,"warn")end;if aZ and not b7 then jO[#jO+1]=gB(l2,l7+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jO[#jO+1]=gB(l2,l7,"Altitude Hold: "..ln,"warn")end end;if b7 and(antigrav~=nil and antigrav)then if c9>0.1 then jO[#jO+1]=gB(l2,l7+20,"Beginning ascent","warn")elseif c9<0.09 and c9>0.05 then jO[#jO+1]=gB(l2,l7+20,"Aligning trajectory","warn")elseif c9<0.05 then jO[#jO+1]=gB(l2,l7+20,"Leaving atmosphere","warn")end end;if bx then if cx~=nil then jO[#jO+1]=gB(l2,l7,cx,"warn")end end;if b4 then if lu then local lv="Brake-Landing"if d7 then lv=lv..": Aligning"end;jO[#jO+1]=gB(l2,l7,lv,"warnings")else jO[#jO+1]=gB(l2,l7,"Coast-Landing","warnings")end end;if b0 then jO[#jO+1]=gB(l2,l7,"Prograde Alignment","crit")end;if a_ then jO[#jO+1]=gB(l2,l7,"Retrograde Alignment","crit")end;local lw="#110000"local lx=la;local ly=lc;if cU then lw="#FF0000"lx=lb;ly=ld;local type;if string.find(cU,"COLLISION")then type="warnings"else type="crit"end;jO[#jO+1]=gB(l2,l8+20,cU,type)elseif c9==0 then local lz,lA=co.checkLOS(cF:normalize())if lA~=nil then ly=ld;lw="#FF0000"lx=lb;local ln=is(lA)local lB=cj.computeTravelTime(cG,0,lA)local lC="Collision"if lz.noAtmosphericDensityAltitude>0 then lC="Atmosphere"end;jO[#jO+1]=gB(l2,l8+20,lz.name.." "..lC.." "..it(lB).." In "..ln,"crit")end end;if bo and not bx then jO[#jO+1]=gB(l2,l7+35,lD,"warn")end;local lE="#111100"local lF=la;local lG=lc;if cY and#cY>1 then lE="#DDDD00"lF=lb;lG=ld end;local lH=j4;local lI=j5;local lc="topButton"local lJ="topButtonActive"local lK=lc;if b1 or bo or c5 or bx then lK=lJ end;local lL=lc;if b0 then lL=lJ end;local lM=lc;if b4 or bk then lM=lJ end;local lN=lc;if b3 or bo then lN=lJ end;local lO=lc;if a_ then lO=lJ end;local lP=lc;if bx or cz and b1 then lP=lJ end;if x and I then local lQ=lI(30)jO[#jO+1]=da([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lK,lH(960),lI(54),lI(-53),lH(-120),lH(25),lI(50))jO[#jO+1]=gB(lH(910),lQ,"AUTOPILOT")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lL,lH(865),lI(51),lH(-25),lI(-50),lH(-110),lH(25),lI(46))jO[#jO+1]=gB(lH(800),lQ,"PROGRADE")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lM,lH(755),lI(47),lH(-25),lI(-46),lH(-98),lH(44),lI(44))jO[#jO+1]=gB(lH(700),lQ,"LAND")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lN,lH(960),lI(54),lI(-53),lH(120),lH(-25),lI(50))jO[#jO+1]=gB(lH(1010),lQ,"ALT HOLD")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lO,lH(1055),lI(51),lH(25),lI(-50),lH(110),lH(-25),lI(46))jO[#jO+1]=gB(lH(1122),lQ,"RETROGRADE")jO[#jO+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lP,lH(1165),lI(47),lH(25),lI(-46),lH(98),lH(-44),lI(44))jO[#jO+1]=gB(lH(1220),lQ,"ORBIT")jO[#jO+1]=[[
                                    </g>
                                </g>]]jO[#jO+1]="</g>"end;return jO end;local function lR(fh)return bH(ip(fh*3.6,0)+0.5).." km/h"end;local function lS(gn)local gp=bh;if gn~=nil and type(gn)=="number"then if gn==0 then return"None"end;gp=cP[gn].name end;if gp==nil then gp=fX.name end;if gp==nil then gp="None"end;return gp end;local function lT(jO)local lU=co.routeWP(true)if not lU or#lU==0 then return end;local hc=j4(750)local hd=j5(360)if b1 or bo then jO[#jO+1]=gB(hc,hd,"REMAINING ROUTE","pdim txtstart size20")else jO[#jO+1]=gB(hc,hd,"LOADED ROUTE","pdim txtstart size20")end;for dB,L in pairs(lU)do hd=hd+20;jO[#jO+1]=gB(hc,hd,dB..". "..lU[dB],"pdim txtstart size20")end end;local function lV(jO)local hc=ax+10;local hd=ay+20;local lW={}local lX={"Alt-4: AutoTakeoff to Target"}local lY={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lZ={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local l_={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lW,"--------------DYNAMIC-----------------")if c8 then if c7~=-1 then iq(lW,lX)if c0 and j3 and c0.name==j3.name then table.insert(lW,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aY then if antigrav then if cL then table.insert(lW,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lW,"Turn on AGG to takeoff to AGG Height")end end;if aY then table.insert(lW,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lW,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lW,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bk then table.insert(lW,"G: Takeoff to hover height, raise gear")else table.insert(lW,"G: Lowergear and Land")end else iq(lW,lY)table.insert(lW,"G: Begin BrakeLanding or Land")end;if b7 then table.insert(lW,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iq(lW,lZ)if shield_1 then table.insert(lW,"Alt-Shift-6: Vent shields")if not G then table.insert(lW,"Alt-Shift-7: Toggle shield off/on")end end end;if fX~=nil then table.insert(lW,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lW,"Alt-9: Activate Gyroscope")end;if aU~="none"or aT~="none"or aV~="none"then table.insert(lW,"Alt-Shift-9: Cycles engines with Extra tags")end;if b3 then table.insert(lW,"Alt-Spacebar/C will raise/lower target height")table.insert(lW,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not c8 then table.insert(lW,"LALT+Mousewheel will lower/raise speed limit")end;iq(lW,l_)for L=1,#lW do hd=hd+12;jO[#jO+1]=gB(hc,hd,lW[L],"pdim txtbig txtstart")end end;local function m0(jO)local m1=ax;local m2=ay;local m3=aw;local m4=4;local m5=15;local hc=0;local hd=0;local m6,m7,m8,m9;local ma;local function mb(type)local mc,bJ,fh,md,jI,me;if type=="Periapsis"then mc=ma.periapsis.altitude;bJ=ma.timeToPeriapsis;fh=ma.periapsis.speed;jI="txtend"md=12;me=math.min(hc,m1+m3-j3.radius/m8-m4*2)else mc=ma.apoapsis.altitude;bJ=ma.timeToApoapsis;fh=ma.apoapsis.speed;md=-12;jI="txtstart"me=hc end;if cG<1 then bJ=0 end;jO[#jO+1]=da([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],me+md,hd-5,hc,hd-5)jO[#jO+1]=da([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],me-md*4,hd+2,hc,hd+2)jO[#jO+1]=gB(me,hd,type,jI)hc=me-md*2;hd=hd+m5;local ln=is(mc)jO[#jO+1]=gB(hc,hd,ln,jI)hd=hd+m5;jO[#jO+1]=gB(hc,hd,it(bJ),jI)hd=hd+m5;jO[#jO+1]=gB(hc,hd,lR(fh),jI)end;local mf=m3*1.5;if bE=="INFO"then mf=25*9 end;if bE~="HIDE"then jO[#jO+1]=[[<g class="pbright txtorb txtmid">]]jO[#jO+1]=da('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m3*2,mf,m1,m2)jO[#jO+1]=da([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m3*2,mf,m1,m2)end;local mg=m3*1.5;local mh=m3*2;local mi=mg/2;local mj=m3;local mk=m1+mj;local ml=m2+mi;local mm=m1+mh;local mn=m2+mg;if bE=="ORBIT"then m2=m2+m4;m6=m3/2;m9=0;ma={}ma.periapsis={}ma.apoapsis={}if fl~=nil then if fl.periapsis~=nil then ma.periapsis.altitude=fl.periapsis.altitude;ma.periapsis.speed=fl.periapsis.speed end;if fl.apoapsis~=nil then ma.apoapsis.altitude=fl.apoapsis.altitude;ma.apoapsis.speed=fl.apoapsis.speed end;ma.period=fl.period;ma.eccentricity=fl.eccentricity;ma.timeToApoapsis=fl.timeToApoapsis;ma.timeToPeriapsis=fl.timeToPeriapsis;ma.eccentricAnomaly=fl.eccentricAnomaly;ma.trueAnomaly=fl.trueAnomaly end;if ma.periapsis==nil then ma.periapsis={}ma.periapsis.altitude=-j3.radius;ma.periapsis.speed=a0 end;if ma.eccentricity==nil then ma.eccentricity=1 end;if ma.apoapsis==nil then ma.apoapsis={}ma.apoapsis.altitude=ca;ma.apoapsis.speed=0 end;if cG<1 then ma.apoapsis.altitude=ca;ma.apoapsis.speed=0 end;if ma.apoapsis.altitude then m8=(ma.apoapsis.altitude+ma.periapsis.altitude+j3.radius*2)/(m6*2)m7=(j3.radius+ma.apoapsis.altitude)/m8*(1-ma.eccentricity)m9=m6-ma.periapsis.altitude/m8-j3.radius/m8;local mo=math.pi;if ma.period~=nil and ma.period>0 and ma.timeToApoapsis~=nil then mo=ma.eccentricAnomaly;if ma.timeToPeriapsis<ma.timeToApoapsis then mo=2*math.pi-mo end end;if cG<1 or mo~=mo then mo=math.pi end;local mp=-m6*math.cos(mo)+m1+mj+m4;local mq=m7*math.sin(mo)+m2+mi+m4;local mr=""jO[#jO+1]='<g clip-path="url(#orbitRect)">'jO[#jO+1]=da([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mr,m1+m3+m4,m2+m3*1.5/2+m4,m6,m7)if m7<1 then jO[#jO+1]=da([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m1+m3+m4-m9,m2+m3*1.5/2+m4,mp,mq)end;jO[#jO+1]=da('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m1+m3+m4-m9,m2+m3*1.5/2+m4,(j3.radius+j3.noAtmosphericDensityAltitude)/m8)jO[#jO+1]=da('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m1+m3+m4-m9,m2+m3*1.5/2+m4,(j3.radius+j3.noAtmosphericDensityAltitude)/m8)jO[#jO+1]=da([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m1+m3+m4,m2+m3*1.5/2+m4,m6,m7)jO[#jO+1]=da('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m1+m3+m4-m9,m2+m3*1.5/2+m4,j3.radius/m8)jO[#jO+1]='</g>'local ms=math.floor(j3.radius/m8+0.5)hc=m1+m3+m4*4+m6;hd=m2+m3*1.5/2+5+m4;if ma.apoapsis~=nil and ma.apoapsis.speed<a0 then mb("Apoapsis")end;hd=m2+m3*1.5/2+5+m4;hc=m1+m3-m4*2-m6;if ma.periapsis~=nil and ma.periapsis.speed<a0 and ma.periapsis.altitude>0 then mb("Periapsis")end;jO[#jO+1]=gB(m1+m3+m4,m2+20+m4,j3.name,"txtorbbig")jO[#jO+1]=da('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mp,mq)jO[#jO+1]=[[</g>]]return jO else jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mt=""local mu=1.2*(mv-mw)/(m3*2)local mx=1.4*(my-mz)/(m3*1.5)for dB,dm in pairs(e[0])do if dm.center then local hc=m1+m3+dm.center.x/mu;local hd=m2+m3*1.5/2+dm.center.y/mx;mt=mt..'<circle cx="'..hc..'" cy="'..hd..'" r="'..dm.radius/mu*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dm.name,"Moon")and not string.match(dm.name,"Sanctuary")and not string.match(dm.name,"Space")then mt=mt.."<text x='"..hc.."' y='"..hd+dm.radius/mu*30+20 .."' font-size='12' fill="..iP.." text-anchor='middle' font-family='Montserrat'>"..dm.name.."</text>"end end end;local fn=vec3(b.getConstructWorldPos())local hc=m1+m3+fn.x/mu;local hd=m2+m3*1.5/2+fn.y/mx;mt=mt..'<circle cx="'..hc..'" cy="'..hd..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mt=mt.."<text x='"..hc.."' y='"..hd-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iB=mu;iC=mx;local mA=fn+cF*1000000;local mB=m1+m3+mA.x/mu;local jz=m2+m3*1.5/2+mA.y/mx;mt=mt..'<line x1="'..hc..'" y1="'..hd..'" x2="'..mB..'" y2="'..jz..'" stroke="purple" stroke-width="1"/>'jO[#jO+1]=mt;jO[#jO+1]='</g>'end elseif bE=="INFO"then jO=cm.DrawOdometer(jO,iR,bl,iS)elseif bE=="HELP"then jO=lV(jO)elseif bE=="SCOPE"then jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mC=d0;if c9>0 then table.sort(c_,function(er,es)local et,eu=er.center,es.center;return(et.x-cJ.x)^2+(et.y-cJ.y)^2+(et.z-cJ.z)^2<(eu.x-cJ.x)^2+(eu.y-cJ.y)^2+(eu.z-cJ.z)^2 end)end;local gJ={}local mD={}local mE=120;local mF=nil;local mG=nil;for L,dm in ipairs(c_)do local gI=dm.center-cJ;local mH=gI:len()local mI=gI:normalize()local mJ=gI:cross(cC):normalize()local mK=math.acos(mJ:dot(cD))if mK~=mK then mK=0 end;if mJ:cross(cD):dot(cC)<0 then mK=-mK end;local mL=gI:project_on_plane(cC):len()local mM=math.sin(mK)*math.asin(mL/mH)*constants.rad2deg;local mN=math.cos(mK)*math.asin(mL/mH)*constants.rad2deg;if mI:dot(cC)<0 then mN=90*math.cos(mK)+90*math.cos(mK)-mN;mM=90*math.sin(mK)+90*math.sin(mK)-mM end;local hc=mk+mM/mC*mg;local hd=ml+mN/mC*mg;local mO=(hc-mk)*(hc-mk)+(hd-ml)*(hd-ml)local mP=math.asin((dm.radius+dm.surfaceMaxAltitude)/mH)*constants.rad2deg;if mP~=mP then mP=mC end;local hI=mP/mC*mg;local mQ=math.asin(dm.atmosphereRadius/mH)*constants.rad2deg;if mQ~=mQ then mQ=mP end;local mR=mQ/mC*mg;local c3=is(mH,1)local mS=dm.name;local mT=false;if hd>m2 then if hd>mn then if hd-mR<=mn then mT=true end else mT=true end else if hd+mR>=m2 then mT=true end end;local mU=false;local mV=hc;if dm.systemId==0 then mV=hc+mE else mV=hc-mE end;if mV+mE>m1 then if mV+mE>mm then if mV-mR-mE<=mm then mU=true end else mU=true end else if mV+mR+mE>=m1 then mU=true end end;local mW={}mW.x=hc;mW.y=hd;mW.planet=dm;mW.atmoSize=mR;if not mF or mO<mF then mF=mO;mG=mW end;if mU and mT then local mX=math.max(mR,5)if mO<mX*mX then mS=mS.." - "..c3 end;mW.size=hI;mW.i=L;mW.displayString=mS;mW.distance=c3;mW.visible=true;mD[#mD+1]=mW else mW.visible=false end end;local mY=false;table.sort(mD,function(et,eu)return et.y<eu.y end)for dB,fq in ipairs(mD)do local dm,hI,L,mR,hc,hd,mS,c3=fq.planet,fq.size,fq.i,fq.atmoSize,fq.x,fq.y,fq.displayString,fq.distance;local me,mZ,m_,n0;local n1=15;local jI="pdim"if dm.systemId~=0 then m_=j4(string.len(mS)*5)n1=-(15+m_)n0=j5(10)jI="pdimfill"else m_=j4(string.len(mS)*9)n0=j5(15)end;if hI*2>m_ then me=db(hc,m1+m_/2,mm-m_/2)mZ=db(hd,m2+n0,mn-5)me=db(me,hc-hI+m_/2,hc+hI-m_/2)mZ=db(mZ,hd-hI+n0,hd+hI)else me=hc+n1;mZ=hd end;for n2,fq in pairs(gJ)do local n3=fq.textPositions;local n4=n3.y-mZ;if n2~=L and eQ(n4)<n3.height and n3.x+n3.width>me and n3.x<me+m_ then if hI>m_ then mZ=db(mZ+n0,m2+15,mn-5)else mZ=n3.y+n3.height+1 end end end;local n5=mS~=dm.name or me<=mk and me+m_>=mk and mZ-n0<=ml and mZ>=ml;fq.hovered=n5;local n6=1;if n5 then n6=2;if hI*2<m_ then n6=10 end;if mS==dm.name then mS=mS.." - "..c3 end;jI="pbright"if dm.systemId~=0 then m_=j4(string.len(mS)*5)n1=-(15+m_)else m_=j4(string.len(mS)*7)end;if hI*2>m_ then me=db(hc,m1+m_/2,mm-m_/2)me=db(me,hc-hI+m_/2,hc+hI-m_/2)else me=hc+n1 end end;gJ[L]={}gJ[L].textPositions={}gJ[L].textPositions.y=mZ;gJ[L].textPositions.x=me;gJ[L].textPositions.width=m_;gJ[L].textPositions.height=n0;gJ[L].output=""if hI*2>m_ then jI=jI.." txtmid"else jI=jI.." txtstart"end;if mR-hI>2 then gJ[L].output=da('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hc,hd,mR,iQ,0.1*n6)end;gJ[L].output=gJ[L].output..da('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hc,hd,hI,iQ,0.2*n6)if dm.systemId==0 then gJ[L].output=gJ[L].output..da([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],me,mZ,iP,jI,mS)if hI*2<=m_ then gJ[L].output=gJ[L].output..da("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",me+m_,mZ+2,me,mZ+2,hc,hd)end else gJ[L].output=gJ[L].output..da([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],me,mZ,iQ,jI,mS)if hI*2<=m_ then gJ[L].output=gJ[L].output..da("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",me,mZ+2,me+m_,mZ+2,hc,hd)end end end;for dB=#c_,1,-1 do if gJ[dB]then jO[#jO+1]=gJ[dB].output end end;if mG~=nil and d0<90 and not mG.hovered then local n7=mG.planet.atmosphereRadius/mG.atmoSize;local n8=dd(mF)*n7;local n9=is(n8,1)local m_=j4(math.max(string.len(n9)*7,string.len(mG.planet.name)*7))local n0=j5(12)local me=db(mG.x+(mk-mG.x)/2,m1+m_/2,mm-m_/2)local mZ=db(mG.y+(ml-mG.y)/2,m2+n0*2,mn-5)jO[#jO+1]=da("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mG.x,mG.y,mk,ml)jO[#jO+1]=da([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],me,mZ,"white",n9)if not mG.visible then jO[#jO+1]=da([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],me,mZ-n0,"white",mG.planet.name)end end;if cG>1 then local gI=cF;local mI=gI:normalize()local mL=gI:project_on_plane(cC):len()local mJ=gI:cross(cC):normalize()local mK=math.acos(mJ:dot(cD))if mK~=mK then mK=0 end;if mJ:cross(cD):dot(cC)<0 then mK=-mK end;local mM=math.sin(mK)*math.asin(mL/gI:len())*constants.rad2deg;local mN=math.cos(mK)*math.asin(mL/gI:len())*constants.rad2deg;if mI:dot(cC)<0 then mN=90*math.cos(mK)+90*math.cos(mK)-mN;mM=90*math.sin(mK)+90*math.sin(mK)-mM end;local hc=mk+mM/mC*mg;local hd=ml+mN/mC*mg;local kJ=14;local kK=kJ/2;local kN=[[<circle
                                    cx="]]..hc..[["
                                    cy="]]..hd..[["
                                    r="]]..kK/kJ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hc..[["
                                    cy="]]..hd..[["
                                    r="]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hc-kJ..[[,]]..hd..[[ h ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hc+kK..[[,]]..hd..[[ h ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hc..[[,]]..hd-kJ..[[ v ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jO[#jO+1]=kN end;jO[#jO+1]=da("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mk,ml-10,mk,ml+10)jO[#jO+1]=da("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mk-10,ml,mk+10,ml)jO[#jO+1]='</g>'else return jO end end;local function na(nb,nc)local nd;local ne=(nc-nb):normalize()local fo=(cJ-nb):dot(ne)/ne:dot(ne)if fo<=0. then return(cJ-nb):len()elseif fo>=(nc-nb):len()then return(cJ-nc):len()end;local nf=nb+fo*ne;nd=(nf-cJ):len()return nd end;local function ng()local nd;local nh=nil;local ni=nil;local nj=nil;for dB,nk in pairs(e[0])do if nk.hasAtmosphere then local c3=na(j3.center,nk.center)if nh==nil or c3<nh then ni=nk;nh=c3;nj=j3 end;if c0 and c0.hasAtmosphere and c0.name~=j3.name then local eG=na(c0.center,nk.center)if eG<nh then ni=nk;nh=eG;nj=c0 end end end end;local nl=j4(1770)local nm=j5(330)if nh then local nn="txttick "local no=500000;if nh<ni.radius+no or nh<nj.radius+no then if cQ then nn="txttick red "else nn="txttick orange "end end;nd=is(nh,2)iG=gB(nl,nm,"Pipe ("..nj.name.."--"..ni.name.."): "..nd,nn.."pbright txtmid")end end;local function np(hc,hd,nq,nr,kW)local ns={x=hc,y=hd,width=nq,height=nr,label=kW}iA[kW]=ns;return ns end;local function nt(nu,nv,nq,nr,hc,hd,nw,nx,ny,nz,jI)local ns={enableName=nu,disableName=nv,width=nq,height=nr,x=hc,y=hd,toggleVar=nw,toggleFunction=nx,drawCondition=ny,hovered=false,class=jI}if nz then table.insert(iz,ns)else table.insert(iy,ns)end;return ns end;local function nA(nB)if not iE then nC=false;nD=false;nE=false;x=true;return elseif nB=="handling"then nC=not nC;nD=false;nE=false elseif nB=="hud"then nD=not nD;nC=false;nE=false elseif nB=="physics"then nE=not nE;nC=false;nD=false end;if nE or nD or nC then iF=ir(nB)x=false else iF="none"x=true end end;local function nF()iE=not iE;if iE then ix=iz;bW="Hold SHIFT to see Settings"d1=x else ix=iy;bW="Hold SHIFT to see Control Buttons"nA()x=d1 end end;local function nG()local function nH(dm,dB)dm.set(not dm.get())if dm.get()then bW=dB.." set to true"else bW=dB.." set to false"end;if dB=="showHud"then d1=dm.get()elseif dB=="BrakeToggleDefault"then aX=j end end;local nI=50;local nJ=340;local hc=500;local hd=ce/2-400;local nK=0;for dB,dm in pairs(ir("boolean"))do if type(dm.get())=="boolean"then nt(dB,dB,nJ,nI,hc,hd,function()return dm.get()end,function()nH(dm,dB)end,function()return true end,true)hd=hd+nI+20;if nK==9 then hc=hc+nJ+20;hd=ce/2-400;nK=0 else nK=nK+1 end end end;nt("Control View","Control View",nJ,nI,10,ce/2-500,function()return true end,nF,function()return true end,true)nt("View Handling Settings",'Hide Handling Settings',nJ,nI,10,ce/2-(500-nI),function()return nC end,function()nA("handling")end,function()return true end,true)nt("View Hud Settings",'Hide Hud Settings',nJ,nI,10,ce/2-(500-nI*2),function()return nD end,function()nA("hud")end,function()return true end,true)nt("View Physics Settings",'Hide Physics Settings',nJ,nI,10,ce/2-(500-nI*3),function()return nE end,function()nA("physics")end,function()return true end,true)end;local function nL()local function go()local fO=cJ;local gp=j3.name..". "..#bn;if radar_1 then gp=cp.GetClosestName(gp)end;return cn.AddNewLocation(gp,fO,false,true)end;local function nM()b2=not b2 end;local function nN(nO)if nO==1 then b0=not b0;a_=false else a_=not a_;b0=false end;b1=false;b3=false;bU=false;b4=false;br=nil;b6=false;b5=false end;local function nP(nQ)cn.UpdatePosition(nil,nQ)end;local function gj()cn.ClearCurrentPosition()end;local function nR(gn)local lU=co.routeWP(true)if lU and#lU>0 then return"Engage Route: "..lU[1]end;return"Engage Autopilot: "..lS(gn)end;local function nS(gn)local lU=co.routeWP(true)if lU and#lU>0 then return"Next Route Point: "..lU[1]end;return"Disable Autopilot: "..lS(gn)end;local function nT()if il()==1 then bU=not bU;if bU then b1=false;a_=false;b0=false;b3=false;b6=false;b4=false;b5=false;nU=bk;bk=false;d.control.retractLandingGears()im:setTargetGroundAltitude(Y)fM("folOn","F")else fM("folOff","F")aZ=true;cu=p;bk=nU;if bk then d.control.extendLandingGears()im:setTargetGroundAltitude(Z)end end else bW="Follow Mode only works with Remote controller"bU=false end end;local nI=50;local nJ=260;local nV=j4(30)local nW=ax+aw*2+2;local nX=ay+1;nt("+","+",nV,nV,nW,nX+nV+1,function()return false end,function()d0=d0/8 end,function()return bE=="SCOPE"end,nil,"ZoomButton")nt("-","-",nV,nV,nW,nX,function()return false end,function()d0=math.min(d0*8,90)end,function()return bE=="SCOPE"end,nil,"ZoomButton")nt("0","0",nV,nV,nW,nX+nV*2+2,function()return false end,function()d0=90 end,function()return bE=="SCOPE"and d0~=90 end,nil,"ZoomButton")local nY=nt("Enable Brake Toggle","Disable Brake Toggle",nJ,nI,cd/2-nJ/2,ce/2+350,function()return aX end,function()aX=not aX;if aX then bW="Brakes in Toggle Mode"else bW="Brakes in Default Mode"end end)nt("Align Prograde","Disable Prograde",nJ,nI,cd/2-nJ/2-50-nY.width,ce/2-nI+380,function()return b0 end,function()nN(1)end)nt("Align Retrograde","Disable Retrograde",nJ,nI,cd/2-nJ/2+nY.width+50,ce/2-nI+380,function()return a_ end,nN,function()return c9==0 end)nZ=nt(nR,nS,600,60,cd/2-600/2,ce/2-60/2-330,function()return b1 or bo or c5 or bx end,function()end)local L;local function n_(o0)local gn=cX+o0;if gn>#cP then gn=gn-#cP-1 end;if gn<0 then gn=#cP+gn end;return gn end;o1={}for L=0,10 do local o2=nt(function(eu)local gn=n_(eu.apExtraIndex)if b1 or bo or c5 or bx then return"Redirect: "..lS(gn)end;return nR(gn)end,function(eu)local gn=n_(eu.apExtraIndex)return nS(gn)end,600,60,cd/2-600/2,ce/2-60/2-330+60*L,function(eu)local gn=n_(eu.apExtraIndex)return gn==bj and(b1 or bo or c5 or bx)end,function(eu)local gn=n_(eu.apExtraIndex)local o3=bj==gn;bj=gn;cn.UpdateAutopilotTarget()co.ToggleAutopilot()if not o3 and not(b1 or bo or c5 or bx)then co.ToggleAutopilot()end end,function()return cW and(#co.routeWP(true)==0 or L==0)end)o2.apExtraIndex=L;o1[L]=o2 end;nt("Save Position","Save Position",200,nZ.height,nZ.x+nZ.width+30,nZ.y,function()return false end,go,function()return bj==0 or fX==nil end)nt("Update Position","Update Position",200,nZ.height,nZ.x+nZ.width+30,nZ.y,function()return false end,function()nP(nil)end,function()return bj>0 and fX~=nil end)nt("Save Heading","Clear Heading",200,nZ.height,nZ.x+nZ.width+30,nZ.y+nZ.height+20,function()return fX.heading~=nil end,function()if fX.heading~=nil then nP(false)else nP(true)end end,function()return bj>0 and fX~=nil end)nt("Clear Position","Clear Position",200,nZ.height,nZ.x-200-30,nZ.y,function()return true end,gj,function()return bj>0 and fX~=nil end)nt("Save Route","Save Route",200,nZ.height,nZ.x-200-30,nZ.y+nZ.height*2+40,function()return false end,function()co.routeWP(false,false,2)end,function()return#co.routeWP(true)>0 end)nt("Load Route","Clear Route",200,nZ.height,nZ.x-200-30,nZ.y+nZ.height+20,function()return#co.routeWP(true)>0 end,function()if#co.routeWP(true)>0 then co.routeWP(false,true)elseif b1 or bo then bW="Disable Autopilot before loading route"return else co.routeWP(false,false,1)end end,function()return true end)nI=60;nJ=300;local hc=0;local hd=ce/2-150;nt("Enable Check Damage","Disable Check Damage",nJ,nI,hc,hd-nI-20,function()return s end,function()s=not s end)nt("View Settings","View Settings",nJ,nI,hc,hd,function()return true end,nF)hd=hd+nI+20;nt("Enable Turn and Burn","Disable Turn and Burn",nJ,nI,hc,hd,function()return b2 end,nM)hc=10;hd=ce/2-300;nt("Horizontal Takeoff Mode","Vertical Takeoff Mode",nJ,nI,hc+nJ+20,hd,function()return aY end,function()aY=not aY;if aY then bW="Vertical Takeoff Mode"else bW="Horizontal Takeoff Mode"end end,function()return cK end)hd=hd+nI+20;nt("Engage Orbiting","Cancel Orbiting",nJ,nI,hc+nJ+20,hd,function()return bx end,co.ToggleIntoOrbit,function()return c9==0 and cT end)hd=ce/2-150;nt("Glide Re-Entry","Cancel Glide Re-Entry",nJ,nI,hc+nJ+20,hd,function()return b6 end,function()c4=1;nN(1)end,function()return j3.hasAtmosphere and not c8 end)hd=hd+nI+20;nt("Parachute Re-Entry","Cancel Parachute Re-Entry",nJ,nI,hc+nJ+20,hd,function()return b6 end,function()c4=2;nN(1)end,function()return j3.hasAtmosphere and not c8 end)hd=hd+nI+20;nt("Engage Follow Mode","Disable Follow Mode",nJ,nI,hc,hd,function()return bU end,nT,function()return il()==1 end)nt("Enable Repair Arrows","Disable Repair Arrows",nJ,nI,hc+nJ+20,hd,function()return iV end,function()iV=not iV;if iV then bW="Repair Arrows Enabled"else bW="Repair Arrows Diabled"end end,function()return il()==1 end)hd=hd+nI+20;if not q then nt("Enable AGG","Disable AGG",nJ,nI,hc,hd,function()return cL end,co.ToggleAntigrav,function()return antigrav~=nil end)end;nt(function()return da("Switch IPH Mode - Current: %s",by)end,function()return da("IPH Mode: %s",by)end,nJ*2,nI,hc,hd,function()return false end,function()if by=="All"then by="Custom Only"elseif by=="Custom Only"then by="No Moons"else by="All"end;bW="IPH Mode: "..by end)hd=hd+nI+20;nt(function()return da("Toggle Control Scheme - Current: %s",g)end,function()return da("Control Scheme: %s",g)end,nJ*2,nI,hc,hd,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bW="New Control Scheme: "..g end)local o4=j5(20)local o2=np(0,0,j4(70),o4,"HELP")o2=np(o2.x+o2.width,o2.y,j4(80),o4,"INFO")o2=np(o2.x+o2.width,o2.y,j4(70),o4,"ORBIT")o2=np(o2.x+o2.width,o2.y,j4(70),o4,"SCOPE")np(o2.x+o2.width,o2.y,j4(70),o4,"HIDE")end;local o5={}local o6=nil;function o5.HUDPrologue(jO)cQ,cR=j1(cJ)if not cQ then iM=ag;iN=ah;iO=ai else iM=ad;iN=ae;iO=af end;iP=[[rgb(]]..bH(iM+0.6)..","..bH(iN+0.6)..","..bH(iO+0.6)..[[)]]iQ=[[rgb(]]..bH(iM*0.8+0.5)..","..bH(iN*0.8+0.5)..","..bH(iO*0.8+0.5)..[[)]]local o7=iP;local o8=iQ;local o9=[[rgb(]]..bH(iM*0.4+0.5)..","..bH(iN*0.4+0.5)..","..bH(iO*0.4+0.5)..[[)]]local oa=iP;local ob=iQ;local oc=o9;if j6()and not m then o7=[[rgb(]]..bH(iM*0.5+0.5)..","..bH(iN*0.5+0.5)..","..bH(iO*0.5+0.5)..[[)]]o8=[[rgb(]]..bH(iM*0.3+0.5)..","..bH(iN*0.3+0.5)..","..bH(iO*0.2+0.5)..[[)]]o9=[[rgb(]]..bH(iM*0.2+0.5)..","..bH(iN*0.2+0.5)..","..bH(iO*0.2+0.5)..[[)]]end;local lH=j4;local lI=j5;jO[#jO+1]=da([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o7,o7,o7,oa,oa,o8,o8,ob,ob,o8,o7,o9,ob,o7,o7,o9,o9,oc,o9,cd,ce,o8,o8,o8,o8,o8,oa,o8,ob,oc,ob,ob,oc)if not o6 then o6=da([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lH(630),lI(0),lH(675),lI(45),lH(960),lI(55),lH(1245),lI(45),lH(1290),lI(0),lH(1000),lI(105),lH(1040),lI(59),lH(1250),lI(51),lH(1300),lI(0),lH(1920),lI(0),lH(1920),lI(20),lH(1400),lI(20),lH(1300),lI(105),lH(920),lI(105),lH(880),lI(59),lH(670),lI(51),lH(620),lI(0),lH(0),lI(0),lH(0),lI(20),lH(520),lI(20),lH(620),lI(105),lH(890),lI(59),lH(960),lI(62),lH(1030),lI(59),lH(985),lI(112),lH(1150),lI(112),lH(1100),lI(152),lH(820),lI(152),lH(780),lI(112),lH(935),lI(112),lH(890),lI(59),lH(960),lI(62),lH(1030),lI(59),lH(985),lI(112),lH(1150),lI(112),lH(1100),lI(152),lH(820),lI(152),lH(780),lI(112),lH(935),lI(112))end;if x and I then jO[#jO+1]=o6 end;return jO end;function o5.DrawVerticalSpeed(jO,dV)jN(jO,dV)end;function o5.UpdateHud(jO)local kC=cN;local od=cO;local jV=od;local ka=kC;local kU=bH(c.getThrottle())local kZ=cG*3.6;local kV=c.getAxisCommandValue(0)local oe=j4(1770)local of=j5(310)if u and cM then kV=bK;kU=bK*100 end;local j8=j7()local jW="ROLL"if kU==nil then kU=0 end;if not cT then if cG>5 then kC=kB(cE)od=kD(cE)else kC=0;od=0 end;jW="YAW"end;if cR>50000 and not c8 then local og;og=is(cR)jO[#jO+1]=gB(oe,of,"PvP Boundary: "..og,"pbright txtbig txtmid")end;jO[#jO+1]=iT;jO[#jO+1]=iK;jO[#jO+1]=hZ;if iG~=""then jO[#jO+1]=iG end;if j9~=""then jO[#jO+1]=j9 end;if ja~=""then jO[#jO+1]=ja end;jN(jO,ca)if il()==0 or l then if cT then jU(jO,aj,ak,jV,jW,cT)else jU(jO,aj,ak,od,jW,cT)end;if not j6()or m then if cT then jU(jO,aj,ak,jV,jW,cT)k9(jO,ka,jV,aj,ak,cT,bH(kD(cE)),cG)else jU(jO,aj,ak,od,jW,cT)k9(jO,kC,od,aj,ak,cT,bH(od),cG)end;kg(jO,ca,cT)kE(jO,cE,cG,aj,ak)end end;kT(jO,j8,kU,kV)kY(jO,kZ)l1(jO)m0(jO)if not iE and bV then lT(jO)end;return jO end;function o5.HUDEpilogue(jO)jO[#jO+1]="</svg>"return jO end;function o5.ExtraData(jO)local oh=j4(1240)local oi=j5(55)local oj=oi+10;local ok;local lH=j4;local lI=j5;local ol=0;local j8=j7()if aY then j8=j8 .."-VERTICAL"end;if F and not b5 and not b4 and cG>20 then j8=j8 .."-COLLISION ON"end;if bA~="Off"then j8="("..bA..")-"..j8 end;if b2 then j8="TB-"..j8 end;if not bz then j8=j8 .."-DeCoupled"end;local om=lI(99)local on=lI(80)local oo=lI(85)local op=lI(31)local oq=0;local os=0;local ot=cb>1000000 and ip(cb/1000000,2).."kT"or ip(cb/1000,2).."T"if c8 then ol=bs else ol=bq end;local ou,ov=cj.computeDistanceAndTime(cG,0,cb,0,0,ol)if ou<0 then ou=0 end;ol=ip(ol/(cb*iw),2).."g"local ow=d:maxForceForward()ok=b.g()if ok>0.1 then os=cb*ok;os=ip(os/(cb*iw),2).."g"oq=0.5*ow/ok;oq=oq>1000000 and ip(oq/1000000,2).."kT"or ip(oq/1000,2).."T"end;ow=ip(ow/(cb*iw),2).."g"local ox=vec3(b.getWorldAcceleration()):len()/9.80665;ok=b.g()jO[#jO+1]=[[<g class="dim txt txtend size14">]]if il()==1 and not l then oh=j4(1120)oi=j5(55)oj=oi+10 elseif c8 and I then local oy=j4(770)jO[#jO+1]=gB(lH(895),om,"ATMO","")jO[#jO+1]=da([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lH(895),oo,lH(-80))jO[#jO+1]=gB(lH(815),on,da("%.1f%%",c9*100),"txtstart size20")end;if I then jO[#jO+1]=gB(lH(1025),om,"GRAVITY","txtstart")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lH(1025),oo,lH(80))jO[#jO+1]=gB(lH(1105),on,da("%.2fg",ok/9.80665),"size20")jO[#jO+1]=gB(lH(1125),om,"ACCEL","txtstart")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lH(1125),oo,lH(80))jO[#jO+1]=gB(lH(1205),on,da("%.2fg",ox),"size20")jO[#jO+1]=gB(lH(695),om,"BRK TIME","")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lH(695),oo,lH(-80))jO[#jO+1]=gB(lH(615),on,da("%s",it(ov)),"txtstart size20")jO[#jO+1]=gB(lH(635),lI(45),"TRIP","")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lH(635),lI(31),lH(-90))if lB then jO[#jO+1]=gB(lH(545),lI(26),da("%s",it(lB)),"txtstart size20")end;jO[#jO+1]=gB(lH(795),om,"BRK DIST","")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lH(795),oo,lH(-80))jO[#jO+1]=gB(lH(715),on,da("%s",is(ou)),"txtstart size20")jO[#jO+1]=gB(lH(1285),lI(45),"MASS","txtstart")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lH(1285),lI(31),lH(90))jO[#jO+1]=gB(lH(1375),lI(26),da("%s",ot),"size20")jO[#jO+1]=gB(lH(1220),om,"THRUST","txtstart")jO[#jO+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lH(1220),oo,lH(80))jO[#jO+1]=gB(lH(1300),on,da("%s",ow),"size20")jO[#jO+1]=gB(j4(960),j5(175),j8,"pbright txtbig txtmid size20")end;jO[#jO+1]="</g>"end;local oz=1-(a6*0.05+a7*0.05)function o5.FuelUsed(oA)local oB;if oA=="atmofueltank"then oB=da("Atmo Fuel Used: %.1f L",jq[oA]/(4*oz))elseif oA=="spacefueltank"then oB=da("Space Fuel Used: %.1f L",jq[oA]/(6*oz))else oB=da("Rocket Fuel Used: %.1f L",jq[oA]/(0.8*oz))end;return oB end;function o5.DrawOdometer(jO,iR,bl,iS)if bE~="INFO"then return jO end;local ok;local oq=0;local os=0;local ol=0;local ot=cb>1000000 and ip(cb/1000000,2).." kTons"or ip(cb/1000,2).." Tons"if c8 then ol=bs else ol=bq end;local ou,ov=cj.computeDistanceAndTime(cG,0,cb,0,0,ol)ol=ip(ol/(cb*iw),2).." g"local ow=d:maxForceForward()ok=b.g()if ok>0.1 then os=cb*ok;os=ip(os/(cb*iw),2).." g"oq=0.5*ow/ok;oq=oq>1000000 and ip(oq/1000000,2).." kTons"or ip(oq/1000,2).." Tons"end;ow=ip(ow/(cb*iw),2).." g"if il()==0 or l then local oC=j4(ax+10)local oD=j5(ay+20)local oE=j4(ax+10+aw/1.25)local nr=25;jO[#jO+1]="<g class='txtstart size14 bright'>"jO[#jO+1]=gB(oC,oD,da("BrkTime: %s",it(ov)))jO[#jO+1]=gB(oE,oD,da("Trip: %.2f km",iR))jO[#jO+1]=gB(oC,oD+nr,da("Lifetime: %.2f kSU",bl/200000))jO[#jO+1]=gB(oE,oD+nr,da("BrkDist: %s",is(ou)))jO[#jO+1]=gB(oC,oD+nr*2,"Trip Time: "..it(iS))jO[#jO+1]=gB(oE,oD+nr*2,"Total Time: "..it(bm))jO[#jO+1]=gB(oC,oD+nr*3,da("Mass: %s",ot))jO[#jO+1]=gB(oE,oD+nr*3,da("Max Brake: %s",ol))jO[#jO+1]=gB(oC,oD+nr*4,da("Max Thrust: %s",ow))if ok>0.1 then jO[#jO+1]=gB(oE,oD+nr*4,da("Max Thrust Mass: %s",oq))jO[#jO+1]=gB(oC,oD+nr*5,da("Req Thrust: %s",os))else jO[#jO+1]=gB(oE,oD+nr*4,"Max Mass: n/a")jO[#jO+1]=gB(oC,oD+nr*5,"Req Thrust: n/a")end;jO[#jO+1]=gB(oE,oD+nr*5,cm.FuelUsed("atmofueltank"))jO[#jO+1]=gB(oC,oD+nr*6,cm.FuelUsed("spacefueltank"))jO[#jO+1]=gB(oE,oD+nr*6,cm.FuelUsed("rocketfueltank"))if cG>833 then local oF=cb/math.sqrt(1-(cG/8333.33)^2)local ot=oF>1000000 and ip(oF/1000000,2).." kTons"or ip(oF/1000,2).." Tons"jO[#jO+1]=gB(oE,oD+nr*7,da("Rel. Mass: %s",ot))end end;jO[#jO+1]="</g></g>"return jO end;function o5.DrawWarnings(jO)return l1(jO)end;function o5.DisplayOrbitScreen(jO)return m0(jO)end;function o5.DisplayMessage(jO,ln)if ln~="empty"then local hd=310;for lv in string.gmatch(ln,"([^\n]+)")do hd=hd+35;jO[#jO+1]=gB("50%",hd,lv,"msg")end end;if bX~=0 then c.setTimer("msgTick",bX)bX=0 end end;function o5.DrawDeadZone(jO)jO[#jO+1]=da([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],av)end;function o5.UpdatePipe()if c8 then iG=""return end;ng()end;function o5.DrawSettings(jO)local hc=j4(640)local hd=j5(200)jO[#jO+1]=[[<g class="pbright txtvspd txtstart">]]local hG=0;for dB,dm in pairs(iF)do hG=hG+1;jO[#jO+1]=gB(hc,hd,dB..": "..dm.get())hd=hd+20;if hG%12==0 then hc=hc+j4(350)hd=j5(200)end end;jO[#jO+1]=gB(j4(640),j5(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jO[#jO+1]="</g>"return jO end;local hW=j4(1770)local hX=j5(350)local hV=j5(15)local hU=j4(1370)local h_,oG;function o5.DrawRadarInfo()hZ=cp.GetRadarHud(hU,hV,hW,hX)end;function o5.DrawTanks()if ar~=0 and as~=0 then j9=gB(ar,as,"","txtstart pdim txtfuel")jr=as;js(ar,"Atmospheric ","ATMO",cf,jo,jp)js(ar,"Space Fuel T","SPACE",cg,jm,jn)js(ar,"Rocket Fuel ","ROCKET",ch,jk,jl)end end;function o5.DrawShield()local i5=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local oH=b.getPvPTimer()local oI=shield_1.getResistances()local oJ="A: "..10+oI[1]*100 .."% / E: "..10+oI[2]*100 .."% / K:"..10+oI[3]*100 .."% / T: "..10+oI[4]*100 .."%"local hc,hd=at-60,au+30;local jG=bH(d8*2.55)local jH=da("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""ja=gB(hc,hd,"","txtmid pdim txtfuel")if d8<10 and i5~="Shield Disabled"then jI="red "end;oH=oH>0 and"   PvPTime: "..it(oH)or""ja=ja..da([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hc,hd,jH,d8*2,hc,hd,hc+2,hd+10,d8,oH)ja=ja..gB(hc,hd-5,i5,jI.."txtstart pbright txtbig")ja=ja..gB(hc,hd+30,oJ,jI.."txtstart pbright txtsmall")end;function o5.hudtick()if not j3 then return end;local function oK(jO)local jK=bH(db(c3/(cd/4)*255,0,255))jO[#jO+1]=da("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c1,c2,bH(iM+0.5)+jK,bH(iN+0.5)-jK,bH(iO+0.5)-jK)end;local function oL()for dG,dm in pairs(ix)do if dm.hovered then if not dm.drawCondition or dm.drawCondition(dm)then dm.toggleFunction(dm)end;dm.hovered=false end end;for dG,dm in pairs(iA)do if dm.hovered then bE=dm.label;dm.hovered=false end end end;local function oM()local function oN(oO,oP,hc,hd,nq,nr)if oO>=hc and oO<=hc+nq and oP>=hd and oP<=hd+nr then return true else return false end end;local hc=c1+cd/2;local hd=c2+ce/2;for dG,dm in pairs(ix)do dm.hovered=oN(hc,hd,dm.x,dm.y,dm.width,dm.height)end;for dG,dm in pairs(iA)do dm.hovered=oN(hc,hd,dm.x,dm.y,dm.width,dm.height)end;if cW then local n5=false;for dG,eu in ipairs(o1)do if eu.hovered then n5=true;break end end;if nZ.hovered then n5=true end;cW=n5 else cW=nZ.hovered;if not cW then cX=bj end end end;local function oQ(jO)if not bE or bE==""then bE="HELP"end;if x then for dB,dm in pairs(iA)do local jI="dim brightstroke"local oR=0.2;if bE==dB then jI="pbright dimstroke"oR=0.6 end;local oS=""if dm.hovered then oR=0.8;oS=";stroke:white"end;jO[#jO+1]=da([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dm.width,dm.height,dm.x,dm.y,jI,oR,oS)jO[#jO+1]=gB(dm.x+dm.width/2,dm.y+dm.height/2+5,dm.label,"txt txtmid pdim")end end end;local function oT(jO)local function oU(jO,oV,hover,hc,hd,fa,oW,oX,oY,oZ,o_,o2)if type(oZ)=="function"then oZ=oZ(o2)end;if type(o_)=="function"then o_=o_(o2)end;jO[#jO+1]=da("<rect x='%f' y='%f' width='%f' height='%f' fill='",hc,hd,fa,oW)if oV then jO[#jO+1]=da("%s'",oX)else jO[#jO+1]=oY end;if hover then jO[#jO+1]=da(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ad,ae,af)else jO[#jO+1]=da(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",ip(ad*0.5,0),ip(ae*0.5,0),ip(af*0.5,0))end;jO[#jO+1]=" rx='5'></rect>"jO[#jO+1]=da("<text x='%f' y='%f' font-size='24' fill='",hc+fa/2,hd+oW/2+5)if oV then jO[#jO+1]="black"else jO[#jO+1]="white"end;jO[#jO+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oV then jO[#jO+1]=da("%s</text>",oZ)else jO[#jO+1]=da("%s</text>",o_)end end;local p0=da("rgb(%d,%d,%d)'",ip(ad*0.1,0),ip(ae*0.1,0),ip(af*0.1,0))local p1=da("rgb(%d,%d,%d)",ip(ad*0.8,0),ip(ae*0.8,0),ip(af*0.8,0))local p2=oU;for dG,dm in pairs(ix)do local nv=dm.disableName;local nu=dm.enableName;if type(nv)=="function"then nv=nv(dm)end;if type(nu)=="function"then nu=nu(dm)end;if not dm.drawCondition or dm.drawCondition(dm)then p2(jO,dm.toggleVar(dm),dm.hovered,dm.x,dm.y,dm.width,dm.height,p1,p0,nv,nu,dm)end end end;local p3=ip(cd/2,0)local p4=ip(ce/2,0)local jO={}cm.HUDPrologue(jO)if x then cm.UpdateHud(jO)else if B then cm.DrawVerticalSpeed(jO,ca)end;cm.DrawWarnings(jO)end;if iE and iF~="none"then cm.DrawSettings(jO)end;if radar_1 then cm.DrawRadarInfo()end;cm.HUDEpilogue(jO)jO[#jO+1]=da([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cd,ce)if bW~="empty"then cm.DisplayMessage(jO,bW)end;if il()==0 and g=="virtual joystick"then if w then cm.DrawDeadZone(jO)end end;oQ(jO)if io()==0 then if il()==1 and bV then if not p5 then oM()oT(jO)end;if not cs and not ct then local p6=table.concat(jO,"")jO={}jO[#jO+1]=da("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jO[#jO+1]=p6;jO[#jO+1]="</body>"cs=true;jO[#jO+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local p7=table.concat(jO,"")a.setScreen(p7)elseif ct then local p6=table.concat(jO,"")jO={}jO[#jO+1]=da("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jO[#jO+1]=p6;jO[#jO+1]="</body>"end;if not cs then jO[#jO+1]=da([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p3,p4,c1,c2)end else oL()end else if not bV and il()==0 then oL()if c3>av then if w then oK(jO)end end elseif bV and(not p5 or not i)then oM()oT(jO)end;jO[#jO+1]=da([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p3,p4,c1,c2)end;jO[#jO+1]=[[</svg></body>]]p7=table.concat(jO,"")end;function o5.TenthTick()local function p8()local p9=a.createData;local pa=a.createWidget;pb=a.createWidgetPanel("Interplanetary Helper")pc=pa(pb,"value")pd=p9('{"label": "Target Planet", "value": "N/A", "unit":""}')fL(pd,pc)pe=pa(pb,"value")pf=p9('{"label": "distance", "value": "N/A", "unit":""}')fL(pf,pe)gd=pa(pb,"value")gc=p9('{"label": "Travel Time", "value": "N/A", "unit":""}')fL(gc,gd)gb=pa(pb,"value")ga=p9('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fL(ga,gb)gf=pa(pb,"value")ge=p9('{"label": "Target Altitude", "value": "N/A", "unit":""}')fL(ge,gf)g7=pa(pb,"value")g6=p9('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g5=pa(pb,"value")g4=p9('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g3=pa(pb,"value")g2=p9('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g1=pa(pb,"value")g0=p9('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g9=pa(pb,"value")g8=p9('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c8 then fL(g6,g7)fL(g4,g5)fL(g2,g3)fL(g0,g1)fL(g8,g9)end end;local function pg()gA(pb)pb=nil end;local function ph()if not b1 then if fX==nil or fX.planetname~=j3.name then pi=(c0.center-cJ):len()else pi=(fX.position-cJ):len()end end;local fh=cG;local pj=c.getThrottle()/100;if u then pj=bK end;local pk,pl=cj.computeDistanceAndTime(cG,a0,cb,d:maxForceForward()*pj,a2,0)local bZ,b_;if not b2 then bZ,b_=co.GetAutopilotBrakeDistanceAndTime(a0)else bZ,b_=co.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dG,pm;if not b2 and fh>0 then dG,pm=co.GetAutopilotBrakeDistanceAndTime(fh)else dG,pm=co.GetAutopilotTBBrakeDistanceAndTime(fh)end;local pn=0;local po=0;if bc or not b1 and fh>5 then po=cj.computeTravelTime(fh,0,pi)elseif bZ+pk<pi then pn=pi-(bZ+pk)po=cj.computeTravelTime(8333.0556,0,pn)else local pp=(pi-bZ)/pk;pk=pi-bZ;pl=pl*pp end;if fX~=nil and fX.planetname==j3.name and not b1 then return po elseif bb then return pm elseif bc then return po+pm else return pl+b_+po end end;cm.DrawTanks()if shield_1 then cm.DrawShield()end;if bh~="None"then if pb==nil then p8()end;if bh~=nil then local pq=fX~=nil;local pr=0.5*bs/c0:getGravity(c0.center+vec3(0,0,1)*c0.radius):len()pr=pr>1000000 and ip(pr/1000000,2).." kTons"or ip(pr/1000,2).." Tons"fK(pd,'{"label": "Target", "value": "'..bh..'", "unit":""}')lB=ph()if pq and not b1 then c3=(cJ-fX.position):len()else c3=(bi-cJ):len()end;if not b2 then bZ,b_=co.GetAutopilotBrakeDistanceAndTime(cG)iI,iJ=co.GetAutopilotBrakeDistanceAndTime(a0)else bZ,b_=co.GetAutopilotTBBrakeDistanceAndTime(cG)iI,iJ=co.GetAutopilotTBBrakeDistanceAndTime(a0)end;local ln=is(c3)fK(pf,'{"label": "distance", "value": "'..ln..'"}')fK(gc,'{"label": "Travel Time", "value": "'..it(lB)..'", "unit":""}')ln=is(bZ)fK(g6,'{"label": "Cur Brake distance", "value": "'..ln..'"}')fK(g4,'{"label": "Cur Brake Time", "value": "'..it(b_)..'", "unit":""}')ln=is(iI)fK(g2,'{"label": "Max Brake distance", "value": "'..ln..'"}')fK(g0,'{"label": "Max Brake Time", "value": "'..it(iJ)..'", "unit":""}')fK(ga,'{"label": "Max Brake Mass", "value": "'..da("%s",pr)..'", "unit":""}')ln=is(gg)fK(ge,'{"label": "Target Orbit", "value": "'..ln..'"}')if c9>0 and not ps then a.removeDataFromWidget(g0,g1)a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)ps=true;if not cM and u and(b3 or b6 or c6)then co.cmdThrottle(1)aZ=false;bO=false end end;if c9==0 and ps then if fK(g0,g1)==1 then fL(g0,g1)end;if fK(g2,g3)==1 then fL(g2,g3)end;if fK(g4,g5)==1 then fL(g4,g5)end;if fK(g6,g7)==1 then fL(g6,g7)end;if fK(g8,g9)==1 then fL(g8,g9)end;ps=false end end else pg()end;if warpdrive~=nil then if ij(warpdrive.getData()).destination~="Unknown"and ij(warpdrive.getData()).distance>400000 then warpdrive.show()pt=true else warpdrive.hide()pt=false end end end;function o5.OneSecondTick()local function pu()local jC=bG()local kZ=cG;local pv=jC-iU;if kZ>1.38889 then kZ=kZ/1000;local pw=kZ*(jC-iU)bl=bl+pw;iR=iR+pw end;iS=iS+pv;bm=bm+pv;iU=jC end;local function px(jO)local py=0;iK=""local pz=iv;local pA=0;local pB=0;local pC=0;local jG=0;local jH=""local pD=b.getElementHitPointsById;local pE=b.getElementMaxHitPointsById;local pF={}for dB in pairs(iu)do local pG=0;local pH=0;pH=pE(iu[dB])pG=pD(iu[dB])pA=pA+pG;if pG<pH then if pG==0 then pC=pC+1 else pB=pB+1 end;if iV and#pF==0 then fO=vec3(b.getElementPositionById(iu[dB]))local hc=fO.x;local hd=fO.y;local he=fO.z;table.insert(pF,b.spawnArrowSticker(hc,hd,he+1,"down"))table.insert(pF,b.spawnArrowSticker(hc,hd,he+1,"down"))b.rotateSticker(pF[2],0,0,90)table.insert(pF,b.spawnArrowSticker(hc+1,hd,he,"north"))table.insert(pF,b.spawnArrowSticker(hc+1,hd,he,"north"))b.rotateSticker(pF[4],90,90,0)table.insert(pF,b.spawnArrowSticker(hc-1,hd,he,"south"))table.insert(pF,b.spawnArrowSticker(hc-1,hd,he,"south"))b.rotateSticker(pF[6],90,-90,0)table.insert(pF,b.spawnArrowSticker(hc,hd-1,he,"east"))table.insert(pF,b.spawnArrowSticker(hc,hd-1,he,"east"))b.rotateSticker(pF[8],90,0,90)table.insert(pF,b.spawnArrowSticker(hc,hd+1,he,"west"))table.insert(pF,b.spawnArrowSticker(hc,hd+1,he,"west"))b.rotateSticker(pF[10],-90,0,90)table.insert(pF,iu[dB])end elseif iV and#pF>0 and pF[11]==iu[dB]then for jB in pairs(pF)do b.deleteSticker(pF[jB])end;pF={}end end;py=bH(pA/pz*100)if py<100 then jO[#jO+1]=gB(0,0,"","pbright txt")jG=bH(py*2.55)jH=da("rgb(%d,%d,%d)",255-jG,jG,0)if py<100 then jO[#jO+1]=gB("50%",1035,"Elemental Integrity: "..py.."%","txtbig txtmid","fill:"..jH)if pC>0 then jO[#jO+1]=gB("50%",1055,"Disabled Modules: "..pC.." Damaged Modules: "..pB,"txtbig txtmid","fill:"..jH)elseif pB>0 then jO[#jO+1]=gB("50%",1055,"Damaged Modules: "..pB,"txtbig txtmid","fill:"..jH)end end end end;local function pI()if ii then if iL==nil and(d3~=nil or bk)then _autoconf.displayCategoryPanel(ii,weapon_size,"Weapons","weapon",true)iL=_autoconf.panels[_autoconf.panels_size]elseif iL~=nil and d3==nil and not bk then gA(iL)iL=nil end end end;cY=b.getPlayersOnBoard()cZ=b.getDockedConstructs()local jO={}pu()if s then px(jO)end;pI()cm.UpdatePipe()cm.ExtraData(jO)iT=table.concat(jO,"")collectgarbage("collect")end;function o5.AnimateTick()ct=true;cs=false;c1=0;c2=0;c.stopTimer("animateTick")end;function o5.MsgTick()local jO={}cm.DisplayMessage(jO,"empty")bW="empty"c.stopTimer("msgTick")bX=3 end;function o5.ButtonSetup()nG()nL()ix=iy end;return o5 end;local function pJ(d,b,c,a,e,vBooster,hover,pK,antigrav,warpdrive,dbHud_1,eQ,bH,bI,il,eL,bG,db,im,fK,io,dd,ip,fM,iq,de,is,it,pL,ij,da,fL)local pM={}local function pN(fh)local pO=bd;if not b1 then pO=0 end;if not c8 then return cj.computeDistanceAndTime(fh,pO,cb,0,0,bq-bf*cb)else if bs and bs>0 then return cj.computeDistanceAndTime(fh,pO,cb,0,0,bs-bf*cb)else return 0,0 end end end;local function pP(fh)local pO=bd;if not b1 then pO=0 end;return cj.computeDistanceAndTime(fh,pO,cb,d:maxForceForward(),a2,bq-bf*cb)end;local pQ=false;local pR=0;local pS=0;local pT=0;local pU=bG()local pV=0;local pW=0;local pX=0;local pY=0;local pZ=false;local p_=false;local q0=false;local q1=nil;local q2=0;local q3={}local iH=55;local q4=nil;local q5=false;local q6=false;local q7=false;local q8=0;local q9=0;local qa=0;local qb=0;local qc=0;local qd=0;local qe={VectorToTarget=false}local qf=vec3(b.getConstructWorldOrientationUp())local qg=nil;local qh=""function pM.clearAll()b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"a_=false;b0=false;cS=nil;b3=false;b6=false;b4=false;aZ=false;b5=false;b7=false;bU=false;q6=false;c4=false;c5=false;q7=false;cu=p;bo=false;b2=false;cc=false;br=nil;bx=false;d6=false;d7=nil end;function pM.GetAutopilotBrakeDistanceAndTime(fh)return pN(fh)end;function pM.GetAutopilotTBBrakeDistanceAndTime(fh)return pP(fh)end;local function qi(qj,qk,ql)qk=qk:project_on_plane(qj)ql=ql:project_on_plane(qj)return eL(qk:cross(ql):dot(qj),qk:dot(ql))end;local function qm()local function qn()local qo=-1;local qp=-1;if vBooster then qo=vBooster.getDistance()end;if hover then qp=hover.getDistance()end;if qo~=-1 and qp~=-1 then if qo<qp then return qo else return qp end elseif qo~=-1 then return qo elseif qp~=-1 then return qp else return-1 end end;local qq=qn()local qr=-1;if pK then qr=pK.getDistance()end;if qq~=-1 and qr~=-1 then if qq<qr then return qq else return qr end elseif qq~=-1 then return qq else return qr end end;local function qs(j3,eC,qt)local function qu(qv,dN)local eI=vec3(dN)if qv.id==0 then return setmetatable({latitude=eI.x,longitude=eI.y,altitude=eI.z,id=0,systemId=qv.systemId},dP)end;local eJ=eI-qv.center;local c3=eJ:len()local dV=c3-qv.radius;local dT=0;local dU=0;if not de(c3,0)then local eK=eL(eJ.y,eJ.x)dU=eK>=0 and eK or 2*math.pi+eK;dT=math.pi/2-math.acos(eJ.z/c3)end;return setmetatable({latitude=math.deg(dT),longitude=math.deg(dU),altitude=dV,id=qv.id,systemId=qv.systemId},dP)end;local qw=qu(j3,eC)qw="::pos{"..qw.systemId..","..qw.id..","..qw.latitude..","..qw.longitude..","..qw.altitude.."}"if qt then return qw else a.setWaypoint(qw)return true end end;local qx=false;function pM.showWayPoint(j3,eC,qt)return qs(j3,eC,qt)end;function pM.APTick()local function qy()if cV and not b4 then local ej=cV[1]local hL,hM=cV[2],cV[3]local qz=math.min(hL,hM or hL)local qA=qz/cG;local qB=b5 and(cG<42 or c7~=-1)local qC=b3 or bo or br or b1;if qC and not qB and(bZ*1.5>qz or qA<1)then aZ=true;q3={}co.cmdThrottle(0)if b3 then co.ToggleAltitudeHold()end;if br then co.ToggleLockPitch()end;bW="Autopilot Cancelled due to possible collision"if bo or b1 then co.ToggleAutopilot()end;lu=true;b4=true;cu=true end;if qA<11 then cU=ej.name.." COLLISION "..it(qA).." / "..is(qz,2)else cU=ej.name.." collision "..it(qA)end;if qA<6 then fM("alarm","AL",2)end else cU=false end end;local function qD(qE,qF,qG)local function qH(qE,el)qE=vec3(qE)el=vec3(el):normalize()local dw=qE*el;return dw.x+dw.y+dw.z end;local qI=0.001;local qJ=1;if not c8 or not cv or c7~=-1 or cG<iH then if qG==nil then qG=aP end;if qF==nil then qF=qI end;qE=vec3(qE):normalize()local qK=vec3()-qE;local qL=-qH(qK,b.getConstructWorldOrientationRight())*qJ;local qM=-qH(qK,b.getConstructWorldOrientationUp())*qJ;if pS==0 then pS=qL/2 end;if pT==0 then pT=qM/2 end;if eQ(qL)<0.1 then q9=q9-qL*2 else q9=q9-(qL+(qL-pS)*qG)end;if eQ(qM)<0.1 then q8=q8+qM*2 else q8=q8+qM+(qM-pT)*qG end;pS=qL;pT=qM;if eQ(qL)<qF and eQ(qM)<qF then return true end;return false elseif cv and c7==-1 then qE=cF;if qG==nil then qG=aP end;if qF==nil then qF=qI end;qE=vec3(qE):normalize()local qK=cC-qE;local qL=-qH(qK,b.getConstructWorldOrientationRight())*qJ;local qM=-qH(qK,b.getConstructWorldOrientationUp())*qJ;if pS==0 then pS=qL/2 end;if pT==0 then pT=qM/2 end;if eQ(qL)<0.1 then q9=q9-qL*5 else q9=q9-(qL+(qL-pS)*qG)end;if eQ(qM)<0.1 then q8=q8+qM*5 else q8=q8+qM+(qM-pT)*qG end;pS=qL;pT=qM;if eQ(qL)<qF and eQ(qM)<qF then return true end;return false end end;c8=bI()>0;c9=bI()ca=b.getAltitude()c7=qm()bJ=bG()pU=bJ;if F then qy()end;if antigrav then cL=antigrav.getState()==1 end;local qN=a.getMouseWheel()if qN>0 then co.changeSpd()elseif qN<0 then co.changeSpd(true)else q5=true end;local qO=1;local qP=1;local qQ=bJ-pU;local qR=-math.deg(qi(qf,cF,cC))local qS=math.deg(qi(cD,cF,cC))local gi=cH*-1;cv=c8 and qR<-M or qR>M or qS<-N or qS>N;local qT=a.getMouseDeltaX()local qU=a.getMouseDeltaY()if o and not bV then qU=-qU end;q9=0;qb=0;q8=0;fP=ci[0]j3=fP:closestBody(b.getConstructWorldPos())qV=cl(j3)fl=qV:orbitalParameters(b.getConstructWorldPos(),cF)if ca==0 then ca=(cJ-j3.center):len()-j3.radius end;cT=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;local ok=j3:getGravity(b.getConstructWorldPos()):len()*cb;qc=0;ck=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if io()==0 then if il()==1 and bV then if not cs then c1=db(c1+qT,-cd/2,cd/2)c2=db(c2+qU,-ce/2,ce/2)end else c1=0;c2=0 end else c1=db(c1+qT,-cd/2,cd/2)c2=db(c2+qU,-ce/2,ce/2)c3=dd(c1*c1+c2*c2)if not bV and il()==0 then local kL,kM=1,1;if bE=="SCOPE"then kL,kM=d0/90,d0/90 end;if g=="virtual joystick"then if c1>0 and c1>av then q9=q9-(c1-av)*aD*kL elseif c1<0 and c1<av*-1 then q9=q9-(c1+av)*aD*kL else q9=0 end;if c2>0 and c2>av then q8=q8-(c2-av)*aE*kM elseif c2<0 and c2<av*-1 then q8=q8-(c2+av)*aE*kM else q8=0 end else c1=0;c2=0;if g=="mouse"then q8=(-utils.smoothstep(qU,-100,100)+0.5)*2*qO;q9=(-utils.smoothstep(qT,-100,100)+0.5)*2*qP end end end end;local qW=cG>8334;if cG>W/3.6 and not c8 and not b1 and not qW then bW="Space Speed Engine Shutoff reached"co.cmdThrottle(0)end;if not qW and qX then if not aZ then co.BrakeToggle()end;if b1 then co.ToggleAutopilot()end end;qX=qW;if c8 and c9>0.09 then if cG>cw/3.6 and not u and not pQ then aZ=true;pQ=true elseif not u and pQ then if cG<cw/3.6 then aZ=false;pQ=false end end end;if aZ then qa=1 else qa=0 end;if b0 then if c4 then aZ=false;local qY=false;if fX and c4==true then qY=qD(fX.position-cJ,0.1)else qY=qD(vec3(cF),0.01)end;cu=true;if qY then co.cmdCruise(bH(cw))if(eQ(cO)<2 or eQ(cN)>85)and cG>=cw/3.6-1 then aZ=false;b0=false;if c4~=2 then q7=true end;if c4==true then c6=true end;c4=false;b1=false;co.BeginReentry()end elseif c8 and u then co.cmdThrottle(1)end elseif cG>iH then qD(vec3(cF),0.01)end end;if a_ then if c8 then a_=false elseif cG>iH then qD(-vec3(cF))end end;if not b0 and c4 and not bx then if c9==0 then if c4~=2 then q7=true end;co.BeginReentry()c4=false;c6=true else c4=false;co.ToggleAutopilot()end end;if c6 and fX and(ca<b8+250 and ca>b8-250)and cG*3.6>cw-250 and eQ(cI)<25 and c9>=0.1 and(fX.position-cJ):len()>2000+ca then co.ToggleAutopilot()c6=false end;if b7 then cu=true;local qZ=b8;if cI<-30 then bW="Unable to achieve lift. Safety Landing."bT=0;cu=p;b7=false;b4=true elseif not q and cL or b8<j3.spaceEngineMinAltitude then if cL then qZ=antigrav.getBaseAltitude()end;if ca<qZ-100 then qd=0;bT=15;aZ=false elseif cI>0 then aZ=true;bT=0 elseif cI<-30 then aZ=true;bT=15 elseif ca>=qZ then if cL then if b1 or bo then co.ToggleVerticalTakeoff()else aZ=true;b7=false end;bW="Takeoff complete. Singularity engaged"fM("aggLk","AG")else aZ=false;bW="VTO complete. Engaging Horizontal Flight"fM("vtoc","VT")co.ToggleVerticalTakeoff()end;bT=0 end else if c9>0.08 then qd=0;aZ=false;bT=20 elseif c9<0.08 and c9>0 then aZ=false;if cA then qd=0;bT=20 else bT=0;qd=36;co.cmdCruise(3500)end else cu=p;bx=true;cz=false;q_=false;pZ=false;pX=nil;pY=nil;if q1==nil then q1=j3 end;cy=qZ;q0=true;b7=false end end;if qd~=nil then if r0==nil then r0=pid.new(2*0.01,0,2*0.1)end;local r1=db(qd-cN,-N*0.80,N*0.80)r0:inject(r1)local r2=db(r0:get(),-1,1)q8=r2 end end;if bx then local qK;local r3=false;local r4=is(cy)if q1==nil then q1=j3;if bo then q1=c0 end end;if not q0 then cy=bH(q1.radius+q1.surfaceMaxAltitude+U)if q1.hasAtmosphere then cy=bH(q1.radius+q1.noAtmosphericDensityAltitude+U)end;q0=true end;if qe.VectorToTarget and fX then qK=fX.position-cJ end;local r5,r6=cl(q1):escapeAndOrbitalSpeed((cJ-q1.center):len()-q1.radius)local r7=cO;if not pZ then local r8=false;local r9=false;co.cmdThrottle(0)pY=0;cx="Aligning to orbital path - OrbitHeight: "..r4;if qe.VectorToTarget then qD(qK:normalize():project_on_plane(cH))r3=cC:dot(qK:project_on_plane(qf):normalize())>0.95 else qD(cF)r3=qR<0.5;if cG<150 then r3=true end end;q8=0;pX=0;if cN<=pX+2 and cN>=pX-2 then r8=true else r8=false end;if r7<=pY+2 and r7>=pY-2 then r9=true else r9=false end;if r8 and r9 and r3 then pX=nil;pY=nil;pZ=true end else if qe.VectorToTarget then qD(qK:normalize():project_on_plane(cH))elseif cG>150 then qD(cF)end;q8=0;if qe.VectorToTarget and fX then local bZ,dG=cj.computeDistanceAndTime(cG,cw/3.6,cb,0,0,bq)if cz and qK:len()>15000+bZ+ca then cx="Orbiting to Target"if ca-100<=q1.noAtmosphericDensityAltitude or lB>fl.timeToPeriapsis and fl.periapsis.altitude<q1.noAtmosphericDensityAltitude then cz=false end elseif cz or qK:len()<15000+bZ+ca then bW="Orbit complete, proceeding with reentry"fM("orCom","OB")bi=fX.position;q7=true;c6=true;qe.VectorToTarget,qe.AutopilotAlign=false,false;co.ToggleIntoOrbit()co.BeginReentry()return end end;if fl.periapsis~=nil and fl.apoapsis~=nil and fl.eccentricity<1 and ca>cy*0.9 and ca<cy*1.4 then if fl.apoapsis~=nil then if fl.periapsis.altitude>=cy*0.99 and fl.apoapsis.altitude>=cy*0.99 and fl.periapsis.altitude<fl.apoapsis.altitude and fl.periapsis.altitude*1.05>=fl.apoapsis.altitude or cz then if cz then aZ=false;co.cmdThrottle(0)pX=0;if not qe.VectorToTarget then bW="Orbit complete"fM("orCom","OB")co.ToggleIntoOrbit()end else q2=q2+1;if q2>=2 then cz=true end end else cx="Adjusting Orbit - OrbitHeight: "..r4;p_=true;co.cmdCruise(r6*3.6+1)local ra=cy-ca;if rb==nil then rb=pid.new(0.1,0,1*0.1)end;rb:inject(ra-cI*db(utils.smoothstep(2000-ra,-2000,2000)^6*10,1,10))pX=db(rb:get(),-60,60)end end else local rc=2.75;local rd=eQ(ip(r5*rc))local oz=rd%50;if oz>0 then rd=rd-oz+50 end;aZ=false;if ca<cy*0.8 then cx="Escaping planet gravity - OrbitHeight: "..r4;pX=utils.map(cI,200,0,-15,80)elseif ca>=cy*0.8 and ca<cy*1.15 then cx="Approaching orbital corridor - OrbitHeight: "..r4;rd=rd*0.75;pX=utils.map(cI,100,-100,-15,65)elseif ca>=cy*1.15 and ca<cy*1.5 then cx="Approaching orbital corridor - OrbitHeight: "..r4;rd=rd*0.75;if cI<0 or p_ then pX=utils.map(ca,cy*1.5,cy*1.01,-30,0)else pX=utils.map(ca,cy*0.99,cy*1.5,0,30)end elseif ca>cy*1.5 then cx="Reentering orbital corridor - OrbitHeight: "..r4;pX=-65;local re=utils.map(cI,-150,-400,1,0.55)rd=rd*re end;co.cmdCruise(bH(rd))end end;if pX~=nil then if rf==nil then rf=pid.new(1*0.01,0,5*0.1)end;local rg=pX-cN;rf:inject(rg)local rh=db(rf:get(),-0.5,0.5)q8=rh end end;if b1 and c9==0 and not c4 then local function ri(h_,fl)a.print(h_)aZ=false;bb=false;b1=false;rj=false;be="Aligning"co.cmdThrottle(0)q6=false;bW=h_;fM("apCom","AP")if fl or c4 then if fl and gg~=nil and not c4 then if not ca or ca==0 then return end;cy=ca;q0=true end;co.ToggleIntoOrbit()end end;local rk,rl=bi,false;if fX and fX.planetname~="Space"then ba=true;if not rj then local rm=(fX.position-c0.center):normalize()local rn=rm:project_on_plane((c0.center-cJ):normalize()):normalize()local ro=c0.center+rn*(c0.radius+gg)local rp=fX.position+(fX.position-c0.center):normalize()*(gg-c0:getAltitude(fX.position))if(cJ-ro):len()<(cJ-rp):len()then rk=ro else rk=rp;bd=0 end;bi=rk;co.showWayPoint(c0,bi)rl=true;rj=true end;bf=0 elseif fX and fX.planetname=="Space"then if not rj then bf=0;rl=true;ba=true;rj=true;rk=fX.position+(cJ-fX.position):normalize()*S;bi=rk end elseif fX==nil then bf=0;if not rj then local rm=(cJ+cF*100000-c0.center):normalize()local rn=rm:project_on_plane((c0.center-cJ):normalize()):normalize()if rn:len()<1 then rm=(cJ+cC*100000-c0.center):normalize()rn=rm:project_on_plane((c0.center-cJ):normalize()):normalize()end;rk=c0.center+rn*(c0.radius+gg)bi=rk;rj=true;rl=true;ba=true;co.showWayPoint(c0,bi)end end;pi=(vec3(rk)-cJ):len()local lz,eA,eB=ci:getPlanetarySystem(0):castIntersections(cJ,cF:normalize(),function(ej)if ej.noAtmosphericDensityAltitude>0 then return ej.radius+ej.noAtmosphericDensityAltitude else return ej.radius+ej.surfaceMaxAltitude*1.5 end end)local lA=eA;if eB~=nil and eA~=nil then lA=math.min(eB,eA)end;if lA~=nil and lA<pi and lz.name==c0.name then pi=lA end;local qY=true;local rq=(c0.center-(cJ+vec3(cF):normalize()*pi)):len()-c0.radius;local ln=is(rq)fK(g8,'{"label": "Projected Altitude", "value": "'..ln..'"}')local bZ,b_;if not b2 then bZ,b_=pN(cG)else bZ,b_=pP(cG)end;if cG>50 and b9 then local qK=vec3(rk)-cJ;local rr=db(math.deg(qi(qf,cF:normalize(),qK:normalize()))*cG/500,-90,90)local rs=db(math.deg(qi(cD,cF:normalize(),qK:normalize()))*cG/500,-90,90)if eQ(rr)<20 and eQ(rs)<20 then rr=rr*2;rs=rs*2 end;if eQ(rr)<2 and eQ(rs)<2 then rr=rr*2;rs=rs*2 end;local qR=-math.deg(qi(qf,cC,cF:normalize()))local qS=-math.deg(qi(cD,cC,cF:normalize()))if rt==nil then rt=pid.new(2*0.01,0,2*0.1)end;rt:inject(rs-qS)local ru=db(rt:get(),-1,1)q8=q8+ru;if rv==nil then rv=pid.new(2*0.01,0,2*0.1)end;rv:inject(rr-qR)local rw=db(rv:get(),-1,1)q9=q9+rw;rl=true;if eQ(rr)>2 or eQ(rs)>2 then if be~="Adjusting Trajectory"then be="Adjusting Trajectory"fM("apAdj","AP")end else if be~="Accelerating"then be="Accelerating"fM("apAcc","AP")end end elseif b9 and cG<=50 then qD((rk-cJ):normalize())end;if rq<gg*1.5 then if fX and fX.planetname=="Space"then bd=0 elseif fX==nil then dG,bd=cl(c0):escapeAndOrbitalSpeed(rq)end end;if b1 and not b9 and not bc and not bb then local lz,lA=co.checkLOS((bi-cJ):normalize())if c0.name~=j3.name then if lz~=nil and c0.name~=lz.name and lA<pi then bW="Collision with "..lz.name.." in "..is(lA).."\nClear LOS to continue."bX=5;qx=true else qx=false;bW=""end end end;if not qx then if not bc and not bb and not rl then qY=qD((rk-cJ):normalize())elseif b2 and(bb or bc)then qY=qD(-vec3(cF):normalize())end end;if b9 then if not q6 then aZ=false;co.cmdThrottle(a1)bK=ip(a1,2)q6=true end;local pj=c.getThrottle()if u then pj=bK end;local rx=99999;local ox=-vec3(b.getWorldAcceleration()):dot(cF:normalize())local ry=db(cF:dot((rk-cJ):normalize()),0,cG)if ry>0 or ox>0 then rx=cj.computeTravelTime(ry,ox,pi-bZ)end;if cE:len()>=a0 or pj==0 and q6 or a2/4>rx then b9=false;if be~="Cruising"then fM("apCru","AP")be="Cruising"end;bc=true;co.cmdThrottle(0)end;local rz=pi;if rz<=bZ or H and cR<=bZ+10000 and cQ then if H and cR<=bZ+10000 and cQ then if cR<pR and cR>2000 then co.ToggleAutopilot()bW="Autopilot cancelled to prevent crossing PvP Line"aZ=true;pR=cR else pR=cR;return end end;b9=false;if be~="Braking"then fM("apBrk","AP")be="Braking"end;bb=true;co.cmdThrottle(0)q6=false end elseif bb then if be~="Orbiting to Target"then aZ=true;qa=1 end;if b2 then co.cmdThrottle(1,true)end;local dG,r6=cl(c0):escapeAndOrbitalSpeed((cJ-j3.center):len()-j3.radius)local qK;if fX then qK=fX.position-cJ end;if fX and fX.planetname=="Space"and cG<50 then if#q3>0 then aZ=false;co.ToggleAutopilot()co.ToggleAutopilot()return end;ri("Autopilot complete, arrived at space location")aZ=true;qa=1 elseif fX and fX.planetname~="Space"and cG<=r6 and(fl.apoapsis==nil or fl.periapsis==nil or fl.apoapsis.altitude<=0 or fl.periapsis.altitude<=0)then ri("Autopilot complete, commencing reentry")bi=fX.position;c4=true;co.showWayPoint(c0,bi)elseif(fX and fX.planetname~="Space"or fX==nil)and fl.periapsis~=nil and fl.periapsis.altitude>0 and fl.eccentricity<1 or be=="Circularizing"then if be~="Circularizing"then fM("apCir","AP")be="Circularizing"end;if cG<=r6 then if fX then if cF:normalize():dot(qK:normalize())>0.4 then if be~="Orbiting to Target"then fM("apOrb","OB")be="Orbiting to Target"end;if not rA then aZ=false;co.showWayPoint(c0,fX.position)rA=true end else ri("Autopilot complete, proceeding with reentry")bi=fX.position;c4=true;co.showWayPoint(c0,fX.position)rA=false end else ri("Autopilot completed, setting orbit",true)qa=0 end end elseif be=="Circularizing"then ri("Autopilot complete, fixing Orbit",true)end elseif bc then local rz=pi;if rz<=bZ or H and cR<=bZ+10000 and cQ then if H and cR<=bZ+10000 and cQ then if cR<pR and cR>2000 then co.ToggleAutopilot()bW="Autopilot cancelled to prevent crossing PvP Line"aZ=true;pR=cR else pR=cR;return end end;b9=false;if be~="Braking"then fM("apBrk","AP")be="Braking"end;bb=true end;local pj=c.getThrottle()if u then pj=bK end;if pj>0 then b9=true;if be~="Accelerating"then be="Accelerating"fM("apAcc","AP")end;bc=false end else if qY then if not ba and fX==nil or not ba and fX and fX.planetname~="Space"then if not c4 then bi=vec3(c0.center)+(gg+c0.radius)*cD;rB=qf;rC=cD end;ba=true elseif qY and not qx then b9=true;if be~="Accelerating"then be="Accelerating"fM("apAcc","AP")end;if not q6 then co.cmdThrottle(a1,true)bK=ip(a1,2)q6=true;aZ=false end end end end elseif b1 and(fX~=nil and fX.planetname~="Space"and c9>0)then bW="Autopilot complete, starting reentry"fM("apCom","AP")bi=fX.position;aZ=false;bb=false;b1=false;rj=false;be="Aligning"qa=0;co.cmdThrottle(0)q6=false;b0=true;c4=true;co.showWayPoint(c0,fX.position)end;if bU then cu=true;local rs=0;local fn=cJ+vec3(c.getMasterPlayerRelativePosition())local rD=fn-cJ;local rE=vec3(rD):project_on(cC):len()local rF=vec3(rD):project_on(cD):len()local c3=dd(rE*rE+rF*rF)qD(rD:normalize())local mH=40;local rG=c3<mH;local rH=100;local rI=db((c3-mH)/2,10,rH)q8=0;local qY=eQ(q9)<0.1;if qY and cG<rI and not rG then aZ=false;rs=-20 else aZ=true;rs=0 end;local rJ=0;if eQ(rs-cN)>rJ then if rK==nil then rK=pid.new(2*0.01,0,2*0.1)end;rK:inject(rs-cN)local ru=rK:get()q8=ru end end;if b3 or b4 or b6 or bo or br~=nil then local rL=bs;if rL then rL=rL*db(cG/100,0.1,1)*c9 else rL=bq end;if c9<0.01 then rL=bq end;local rM=cC:project_on_plane(cH):normalize():dot(cF)local rN=vec3(b.getWorldAirFrictionAcceleration())local rO=rN:len()*cb;if rM>100 then bZ,b_=cj.computeDistanceAndTime(rM,100,cb,0,0,rL)local rP,rQ=cj.computeDistanceAndTime(100,0,cb,0,0,rL*0.55)bZ=bZ+rP else bZ,b_=cj.computeDistanceAndTime(rM,0,cb,0,0,rL*0.55)end;local ra=b8-ca-cI;local rR=200+cG;if b6 or c4 then rS=2000+cG end;local rT=1;if b5 then rT=db(cG/100,0.1,1)end;local rs=(utils.smoothstep(ra,-rR,rR)-0.5)*2*P*rT;if not b6 and not c4 and not bo and cC:dot(cF:normalize())<0.99 then rs=(utils.smoothstep(ra,-rR*db(20-19*c9*10,1,20),rR*db(20-19*c9*10,1,20))-0.5)*2*P*db(2-c9*10,1,2)*rT end;if not b3 then rs=0 end;if br~=nil then if cT and not bx then rs=br else br=nil end end;cu=true;local rU=q8;if b6 then local rV=bH(cw)local rW,rX=cj.computeDistanceAndTime(cG,rV/3.6,cb,0,0,bq-j3.gravity*9.8*cb)rW=rW==-1 and 5000 or rW;local rY=ca-(j3.noAtmosphericDensityAltitude+rW)local rZ=ca>j3.noAtmosphericDensityAltitude+rW*1.35;if rZ then rs=Q;if cG<=rV/3.6 and cG>rV/3.6-10 and eQ(cF:normalize():dot(cC))>0.9 and not cM then bO=false;co.cmdThrottle(1)end elseif(cM or im:getTargetSpeed(axisCommandId.longitudinal)~=rV)and not rZ and not c8 then co.cmdCruise(rV,true)end;if cM then if cG>rV/3.6 and not rZ then aZ=true else aZ=false end else aZ=false end;if cI>0 then aZ=true end;if not q7 then rs=-80;if ca<j3.surfaceMaxAltitude+(j3.atmosphereThickness-j3.surfaceMaxAltitude)*0.25 then bW="PARACHUTE DEPLOYED at "..ip(ca,0)b6=false;b4=true;lu=true;co.cmdThrottle(0)rs=0;cu=p end elseif j3.noAtmosphericDensityAltitude>0 and rZ then cu=true elseif not rZ then if not c8 and(cM or im:getTargetSpeed(axisCommandId.longitudinal)~=rV)then co.cmdCruise(rV)end;if cG<rV/3.6+1 then aZ=false;q7=false;b6=false;cu=true end end end;if cG>iH and not c5 and not bo and not b4 and v then qD(vec3(cF))end;if cS or(bo or c5)and bj>0 and c9>0.01 then local qK;if cS then if type(cS)=="table"then qK=cS elseif cS<3 and cS>0 then qK=-cH:cross(cF)*5000 elseif cS>=3 then qK=cH:cross(cF)*5000 elseif cS<0 then qK=cF*25000 end elseif fX~=nil then qK=fX.position-cJ else qK=c0.center-cJ end;local rr=math.deg(qi(cH:normalize(),cF,qK))*2;local mK=math.rad(eQ(cO))if cG>aI and c9>0.01 then local r_=1000+cG;local s0=(utils.smoothstep(ra-cI*10,-r_,r_)-0.5)*2*P;local s1=db(90-s0,0,180)qc=db(rr*2,-s1,s1)local s2=rr;rr=db(db(rr,-M*0.80,M*0.80)*math.cos(mK)+4*(cN-rs)*math.sin(math.rad(cO)),-M*0.80,M*0.80)local s3=1;if qc~=0 then s3=eQ(mK/qc)end;s3=(90-db(eQ(qc-cO),0,90))/90;local s4=rs;if eQ(cO)>90 then s4=-s4 end;rs=s3*db(db(s4*math.cos(mK),-N*0.8,N*0.8)+eQ(db(eQ(s2)*math.sin(mK),-N*0.80,N*0.80)),-N*0.80,N*0.80)else qc=0;rr=db(rr,-M*0.80,M*0.80)end;local s5=qR-rr;if cS and eQ(s5)<=0.0001 and(type(cS)=="table"or type(cS)~="table"and cS<0 and eQ(cO)<1)then if cS==-2 then co.ToggleAltitudeHold()end;cS=nil;fM("180Off","BR")return end;if not cv and cG>aI and c9>0.01 then if s6==nil then s6=pid.new(2*0.01,0,2*0.1)end;s6:inject(s5)local rw=db(s6:get(),-1,1)q9=q9+rw elseif c8 and c7>-1 or cG<aI then qD(qK)elseif cv and c9>0.01 then if(qR<-M or qR>M)and c9>0.01 then qD(cF)end;if(qS<-N or qS>N)and c9>0.01 then rs=db(cN-qS,cN-N*0.80,cN+N*0.80)end end;if fX~=nil and not c5 then local qZ=j3:getAltitude(fX.position)local rY=qK:project_on_plane(cH):len()lu=true;if not c5 and not b6 and rY<=bZ and(cF:project_on_plane(cH):normalize():dot(qK:project_on_plane(cH):normalize())>0.99 or lD=="Finalizing Approach")then lD="Finalizing Approach"if#q3>0 then co.ToggleAutopilot()co.ToggleAutopilot()return end;co.cmdThrottle(0)if b3 then co.ToggleAltitudeHold()bo=true end;aZ=true elseif not b5 then aZ=false end;if lD=="Finalizing Approach"and(rM<0.1 or rY<0.1 or s7~=nil and s7<rY)then fM("bklOn","BL")b4=true;d6=true;if fX.heading then d7=fX.heading else d7=nil end;bo=false;if bh=="STARTINGPOINT"then cn.ClearCurrentPosition()end;lD="Proceeding to Waypoint"cU=false end;s7=rY end elseif bo and c9==0 and b8>j3.noAtmosphericDensityAltitude and not(c5 or b6)then if fX~=nil and c0.name==j3.name then local qK=fX.position-cJ;local qZ=j3:getAltitude(fX.position)local rY=dd(qK:len()^2-(ca-qZ)^2)local rL=bs;if rL then bZ,b_=cj.computeDistanceAndTime(cG,0,cb,0,0,rL/2)lu=true;if rY<=bZ+cG*qQ/2 and cF:project_on_plane(cH):normalize():dot(qK:project_on_plane(cH):normalize())>0.99 then if j3.hasAtmosphere then aZ=false;b0=false;q7=true;c4=false;c6=true;b1=false;co.BeginReentry()end end;s7=rY end end end;if c9==0 and(b3 and b8>j3.noAtmosphericDensityAltitude)and not(c5 or bx or b6)then if not cz and not bx then cy=b8;q0=true;if bo then qe.VectorToTarget=true end;co.ToggleIntoOrbit()bo=false;pZ=true end end;if cv and c9>0.01 and c7==-1 and cG>aI and lD~="Finalizing Approach"then qD(cF)rs=db(cN-qS,cN-N*0.80,cN+N*0.80)end;q8=rU;local qr=-1;if b4 then rs=0;local s8=false;if not q and cL then s8=antigrav.getBaseAltitude()end;if d7 then if math.abs(rM)>0.05 then if cI>-O then aZ=false else aZ=true end;if qD(d7,0.0001)then d7=nil;cu=p else q8=0;cu=true end else aZ=true end;if s8 and ca-s8<100 then aZ=true end else local s9=false;local sa=30;if ck~=nil and ck>0 then local sb=db(c9,0.4,2)local rL=bs*db(cG/100,0.1,1)*sb;local sc=ck*sb+rL-ok;local sd=rL/2-ok;local se=cG-dd(eQ(sd/2)*20/(0.5*cb))*utils.sign(sd)if se<0 then se=0 end;local sf;if cG>100 then local sg,dG=cj.computeDistanceAndTime(cG,100,cb,0,0,rL)local sh,dG=cj.computeDistanceAndTime(100,0,cb,0,0,dd(rL))sf=sg+sh else sf=cj.computeDistanceAndTime(cG,0,cb,0,0,dd(rL))end;if sf<20 then aZ=false else local si=0;if se>100 then local sj,dG=cj.computeDistanceAndTime(se,100,cb,0,0,sc)local sk,dG=cj.computeDistanceAndTime(100,0,cb,0,0,ck*sb+dd(rL)-ok)si=sj+sk else si,dG=cj.computeDistanceAndTime(se,0,cb,0,0,ck*sb+dd(rL)-ok)end;si=(si+15+cG*qQ)*1.1;local sl=fX~=nil and j3:getAltitude(fX.position)>0 and fX.safe;if sl then local qZ;if s8 and s8<ca then qZ=s8 else qZ=j3:getAltitude(fX.position)end;local sm=ca-qZ-100;local qK=fX.position-cJ;local sn=dd(qK:len()^2-(ca-qZ)^2)if sn>100 then sl=false elseif sm<=si or si==-1 then aZ=true;s9=true else aZ=false;s9=true end elseif t then if si>=sa then aZ=true else aZ=false end;s9=true end end end;if not cM then co.cmdThrottle(0)end;im:setTargetGroundAltitude(500)im:activateGroundEngineAltitudeStabilization(500)bz=true;qr=c7;if qr==-1 and s8 and ca-s8<100 then b4=false;aZ=true;cu=p;d6=false elseif qr>-1 then if(cG<1 or cF:normalize():dot(cH)<0)and not d7 then b4=false;b3=false;bk=true;if bP then d.control.extendLandingGears()fM("grOut","LG",1)end;im:setTargetGroundAltitude(Z)bT=0;aZ=true;cu=p;d6=false else aZ=true end elseif lu and cF:normalize():dot(-gi)<0.999 then aZ=true;qD()elseif cI<-O and not s9 or math.abs(rM)>0.05 and d6 then aZ=true elseif not s9 then aZ=false end end end;if b5 or c5 then local lz,eB,eA;if bi~=nil then lz,eB,eA=ci:getPlanetarySystem(0):castIntersections(cJ,(bi-cJ):normalize(),function(ej)return ej.radius+ej.noAtmosphericDensityAltitude end)end;if cL then if ca>=b8-50 then b5=false;if not b1 and not bo then aZ=true;co.cmdThrottle(0)end else b8=antigrav.getBaseAltitude()end elseif eQ(rs)<15 and ca/b8>0.75 then b5=false;if not c5 then if cM and not u then d.control.cancelCurrentControlMasterMode()end elseif c5 and cG<iH then b1=true;c5=false;b3=false;b5=false;co.cmdThrottle(0)elseif c5 then co.cmdThrottle(0)aZ=true end elseif c5 and c9==0 and c0~=nil and(lz==nil or lz.name==c0.name)then b1=true;c5=false;b3=false;b5=false;if not cM then co.cmdThrottle(0)end;b9=true end end;local so=c7>-1;local sp=cN;if(bo or c5 or cS)and not so and cG>aI and c9>0.01 then local mK=math.rad(eQ(cO))sp=cN*eQ(math.cos(mK))+qS*math.sin(mK)end;local sq=db(rs-sp,-N*0.80,N*0.80)if c9<0.01 and bo then sq=db(rs-sp,-85,P)elseif c9<0.01 then sq=db(rs-sp,-P,P)end;if eQ(cO)<5 or bo or cS or b4 or so or b3 then if rK==nil then rK=pid.new(5*0.01,0,5*0.1)end;rK:inject(sq)local ru=rK:get()q8=q8+ru end end;if antigrav~=nil and(antigrav and not q and ca<200000)then if bt==nil or bt<1000 then bt=1000 end;if sr~=bt then sr=bt;antigrav.setBaseAltitude(sr)end end end;function pM.ToggleIntoOrbit()cz=false;pX=nil;pY=nil;q2=0;if c9==0 then if bx then fM("orOff","AP")bx=false;pZ=false;q1=nil;cu=p;if b3 then b3=false;b5=false end;qe.VectorToTarget=false;qe.AutopilotAlign=false;q0=false elseif cT then fM("orOn","AP")bx=true;cu=true;if q1==nil then q1=j3 end;if b3 then b3=false;b5=false end else bW="Unable to engage auto-orbit, not near a planet"end else bx=false;pZ=false;q1=nil;cu=p;if b3 then b3=false end;qe.VectorToTarget=false;qe.AutopilotAlign=false;q0=false end end;function pM.ToggleVerticalTakeoff()b3=false;if b7 then lu=true;b6=false;b5=false;b4=true;cu=true;bT=0;if c8 and c7==-1 then b4=false;b3=true;bT=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)co.cmdCruise(bH(cw))end else cz=false;bk=false;d.control.retractLandingGears()im:setTargetGroundAltitude(Y)aZ=true end;b7=not b7 end;function pM.checkLOS(qE)local lz,eA,eB=ci:getPlanetarySystem(0):castIntersections(cJ,qE,function(ej)if ej.noAtmosphericDensityAltitude>0 then return ej.radius+ej.noAtmosphericDensityAltitude else return ej.radius+ej.surfaceMaxAltitude*1.5 end end)local lA=eA;if eB~=nil and eA~=nil then lA=math.min(eB,eA)end;if lA~=nil then return lz,lA else return nil,nil end end;function pM.ToggleAutopilot()local function ss(bv)cU=false;bo=not bo;if bo then b2=false;if not b3 and not bv then co.ToggleAltitudeHold()end end;lD="Proceeding to Waypoint"end;local function st(gp)if gp then for L,dB in pairs(cP)do if dB.name and dB.name==gp then return L end end else return 0 end end;local su=false;if bJ-pW<1.5 and c9>0 then if not cB then bW="No space engines detected, Orbital Hop not supported"return end;if j3.hasAtmosphere then if c9>0 then b8=j3.noAtmosphericDensityAltitude+U;fM("orH","OH")end;pW=-1;if b1 or bo or bx then return end end else pW=bJ end;rj=false;if(bj>0 or#q3>0)and not b1 and not bo and not c5 and not bx then if 0.5*d:maxForceForward()/b.g()<cb then bW="WARNING: Heavy Loads may affect autopilot performance."bX=5 end;if#q3>0 and not c6 then bj=st(q3[1])cn.UpdateAutopilotTarget()table.remove(q3,1)bW="Route Autopilot in Progress"local qK=fX.position-cJ;local rY=qK:project_on_plane(cH):len()if rY>50000 and fX.planetname==j3.name then su=true end end;cn.UpdateAutopilotTarget()co.showWayPoint(c0,bi)if J and#q3==0 and bh~="STARTINGPOINT"and cn.findAtlasIndex(bn,"STARTINGPOINT")==-1 and c7>-1 then cn.AddNewLocation("STARTINGPOINT",cJ,false,true)end;if fX~=nil then br=nil;bv=fX.planetname=="Space"if bv then fM("apSpc","AP")if c9~=0 then c5=true;co.ToggleAltitudeHold()else b1=true end elseif j3.name==fX.planetname then lu=true;if c9>0 then if not bo then fM("vtt","AP")ss(bv)if su then b8=j3.noAtmosphericDensityAltitude+U end end else fM("apOn","AP")if not(c0.name==j3.name and ca<gg*1.5)then cz=false;b1=true elseif not c8 then if bx then co.ToggleIntoOrbit()end;cy=j3.noAtmosphericDensityAltitude+U;q0=true;qe.AutopilotAlign=true;qe.VectorToTarget=true;pZ=false;if not bx then co.ToggleIntoOrbit()end end end else fM("apP","AP")a_=false;b0=false;if c9~=0 then c5=true;co.ToggleAltitudeHold()else b1=true end end elseif c9==0 then if fX==nil and(c0.name==j3.name and cT)and not bx then rA=false;cz=false;pZ=false;co.ToggleIntoOrbit()else fM("apP","AP")b1=true;a_=false;b0=false;ba=false;bU=false;b3=false;b4=false;b6=false;b5=false;q6=false;br=nil;rA=false end else fM("apP","AP")c5=true;co.ToggleAltitudeHold()end else fM("apOff","AP")co.ResetAutopilots(1)end end;function pM.routeWP(sv,sw,sx)if sx then if sx==1 then q3={}q3=iq(q3,bC)if#q3>0 then bW="Route Loaded"else bW="No Saved Route found on Databank"end;return q3 else bC={}bC=iq(bC,q3)bW="Route Saved"pL()return end end;if sv then return q3 end;if sw then q3={}bW="Current Route Cleared"else q3[#q3+1]=fX.name;bW="Added "..fX.name.." to route. "end;return q3 end;function pM.cmdThrottle(dC,sy)if im:getAxisCommandType(0)~=axisCommandType.byThrottle and not sy then d.control.cancelCurrentControlMasterMode()end;im:setThrottleCommand(axisCommandId.longitudinal,dC)bK=db(ip(dC*100,0)/100,-1,1)qg=nil end;function pM.cmdCruise(dC,sy)if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not sy then d.control.cancelCurrentControlMasterMode()end;im:setTargetSpeedCommand(axisCommandId.longitudinal,dC)qg=dC end;function pM.ToggleLockPitch()if br==nil then fM("lkPOn","LP")if not bV then br=cN else br=R end;b5=false;b3=false;b4=false else fM("lkPOff","LP")br=nil end end;function pM.ToggleAltitudeHold()if bJ-pV<1.5 then if j3.hasAtmosphere then if c9>0 then b8=j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude;fM("11","EP")else if cT then b8=j3.noAtmosphericDensityAltitude+U;cy=b8;q0=true;if not bx then co.ToggleIntoOrbit()end;pZ=true end end;pV=-1;if b3 or bx or b7 then return end end else pV=bJ end;if cT and c9==0 then cy=ca;q0=true;pZ=true;co.ToggleIntoOrbit()if bx then pV=bJ else pV=0 end;return end;b3=not b3;b4=false;b6=false;if b3 then b1=false;b0=false;a_=false;bU=false;cu=true;br=nil;cz=false;if c7~=-1 and cG<20 then fM("lfs","LS")b5=true;if pV>-1 then b8=ca+X end;bk=false;d.control.retractLandingGears()aZ=true;im:setTargetGroundAltitude(Y)if aY and cK then co.ToggleVerticalTakeoff()end else fM("altOn","AH")b5=false;if pV>-1 then if cT then b8=ca end end;if b7 then co.ToggleVerticalTakeoff()end end;if c5 then b8=100000 end else fM("altOff","AH")if bx then co.ToggleIntoOrbit()end;if b7 then co.ToggleVerticalTakeoff()end;cu=p;b5=false;bo=false;pV=0 end end;function pM.ResetAutopilots(pM)if pM then c5=false;b1=false;ba=false;q6=false;b8=ca;rj=false;d6=false end;bo=false;b5=false;b6=false;b0=false;b4=false;d7=nil;sz=false;cS=nil;d6=false;if not cL then b3=false;br=nil end;if b7 then co.ToggleVerticalTakeoff()end;if bx then co.ToggleIntoOrbit()end;cu=p;c4=false;c6=false;bT=0 end;function pM.BrakeToggle()aZ=not aZ;if b4 then b4=false;cu=p;d6=false end;if aZ then fM("bkOn","B",1)co.ResetAutopilots()else fM("bkOff","B",1)end end;function pM.BeginReentry()if b6 then bW="Re-Entry cancelled"fM("reOff","RE")b6=false;cu=p;b3=false elseif not j3.hasAtmosphere then bW="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bX=5 elseif not q7 then b6=true;if im:getAxisCommandType(0)~=sA.cruise then d.control.cancelCurrentControlMasterMode()end;cu=true;aZ=false;bW="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cw;fM("par","RE")else b6=true;b3=true;cu=true;aZ=false;b8=j3.surfaceMaxAltitude+_;if b8>j3.spaceEngineMinAltitude then b8=j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude end;local sB=is(b8)bW="Beginning Re-entry.  Target speed: "..cw.." Target Altitude: "..sB;fM("glide","RE")co.cmdCruise(bH(cw))end;b5=false end;function pM.ToggleAntigrav()if antigrav and not q then if cL then fM("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bt==nil then bt=ca end;if bt<1000 then bt=1000 end;fM("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pM.changeSpd(sC)local sD=1;if sC then sD=-1 end;if not bV then if u and not p5 and q5 then local sE=bK;bK=ip(db(bK+sD*aB/100,-1,1),2)if bK>=0 and sE<0 then bK=0;q5=false end elseif p5 then if c9>0 or b6 then cw=db(cw+sD*aB,0,V)elseif b1 then a0=db(a0+sD*aB/3.6*100,0,8333.00)end else im:updateCommandFromActionStart(axisCommandId.longitudinal,sD*aB/10)end else if b1 or bo or c5 or bx then cX=cX+1*sD*-1;if cX>#cP then cX=1 end;if cX<1 then cX=#cP end else if not sC then sD=1 else sD=nil end;cn.adjustAutopilotTargetIndex(sD)end end end;function pM.TenthTick()local function sF(ok,sG)if ok==nil then ok=b.g()end;ok=ip(ok,5)if sG~=nil and sG or(q4==nil or q4~=ok)then local fh=cE:len()local sH=ij(c.getData()).maxBrake;if sH~=nil and sH>0 and c8 then sH=sH/db(fh/100,0.1,1)sH=sH/c9;if c9>0.10 then if bs then bs=(bs+sH)/2 else bs=sH end end end;if sH~=nil and sH>0 then bq=sH end;q4=ok end end;sF(nil,true)if qg~=nil then if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or im:getTargetSpeed(axisCommandId.longitudinal)~=qg then co.cmdCruise(qg)else qg=nil end end end;function pM.SatNavTick()if not r then return end;qh=dbHud_1.getStringValue("SPBAutopilotTargetName")if qh~=nil and qh~=""and qh~="SatNavNotChanged"then local dw=ij(dbHud_1.getStringValue("SavedLocations"))if dw~=nil then bn=dw;local gn=-1;local gt;for dB,dm in pairs(bn)do if dm.name and dm.name=="SatNav Location"then gn=dB;break end end;if gn~=-1 then gt=bn[gn]gn=-1;for dB,dm in pairs(e[0])do if dm.name and dm.name=="SatNav Location"then gn=dB;break end end;if gn>-1 then e[0][gn]=gt end;cn.UpdateAtlasLocationsList()bW=gt.name.." position updated"end end;for L=1,#cP do if cP[L].name==qh then bj=L;a.print("Index = "..bj.." "..cP[L].name)cn.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pM.onFlush()local function sI(sJ,rI)local sK=vec3()local sL=vec3()if sJ==axisCommandId.longitudinal then sK=vec3(b.getConstructOrientationForward())sL=cC elseif sJ==axisCommandId.vertical then sK=vec3(b.getConstructOrientationUp())sL=qf elseif sJ==axisCommandId.lateral then sK=vec3(b.getConstructOrientationRight())sL=cD else return vec3()end;local sM=vec3(b.getWorldGravity())local sN=sM:dot(sL)local sO=vec3(b.getWorldAirFrictionAcceleration())local sP=sO:dot(sL)local sQ=cE:dot(sK)local sR=rI*constants.kph2m;if sS==nil then sS=pid.new(10,0,10.0)end;sS:inject(sR-sQ)local sT=sS:get()local sU=(sT-sP-sN)*sL;return sU end;local function sV(sJ,rI)local sK=vec3()local sL=vec3()if sJ==axisCommandId.longitudinal then sK=vec3(b.getConstructOrientationForward())sL=cC elseif sJ==axisCommandId.vertical then sK=vec3(b.getConstructOrientationUp())sL=qf elseif sJ==axisCommandId.lateral then sK=vec3(b.getConstructOrientationRight())sL=cD else return vec3()end;local sM=vec3(b.getWorldGravity())local sN=sM:dot(sL)local sO=vec3(b.getWorldAirFrictionAcceleration())local sP=sO:dot(sL)local sQ=cE:dot(sK)local sR=rI*constants.kph2m;if sW==nil then sW=pid.new(10,0,10.0)end;sW:inject(sR-sQ)local sT=sW:get()local sU=(sT-sP-sN)*sL;return sU end;local function sX(sY,jR,fT)local sZ=sY:cross(fT):normalize_inplace()local kC=math.acos(db(sZ:dot(-jR),-1,1))*constants.rad2deg;if sZ:cross(-jR):dot(fT)<0 then kC=-kC end;return kC end;if antigrav and not q then if not cL and antigrav.getBaseAltitude()~=bt then antigrav.setBaseAltitude(bt)end end;cM=im:getAxisCommandType(0)==axisCommandType.byThrottle;aL=math.max(aL,0.01)aM=math.max(aM,0.01)aG=math.max(aG,0.01)aK=math.max(aK,0.01)aN=math.max(aN,0.01)aO=math.max(aO,0.01)aF=math.max(aF,0.01)local s_=db(bQ+q8+a.getControlDeviceForwardInput(),-1,1)local t0=db(bR+qb+a.getControlDeviceYawInput(),-1,1)local t1=db(bS+q9-a.getControlDeviceLeftRightInput(),-1,1)local t2=qa;cH=vec3(b.getWorldVertical())if cH==nil or cH:len()==0 then cH=(j3.center-cJ):normalize()end;qf=vec3(b.getConstructWorldOrientationUp())cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cF=vec3(b.getWorldVelocity())cE=vec3(b.getVelocity())cJ=vec3(b.getConstructWorldPos())cb=b.getConstructMass()cG=vec3(cF):len()cI=-cH:dot(cF)cO=getRoll(cH,cC,cD)local t3=cO/180*math.pi;local t4=math.cos(t3)local t5=math.sin(t3)cN=sX(cH,cC,cD*t4+qf*t5)local t6=cF:normalize()local t7=eQ(cO)local t8=utils.sign(cO)local t9=vec3(b.getWorldAngularVelocity())local ta=s_*aL*cD+t0*aG*cC+t1*aM*qf;if cu==true and cH:len()>0.01 then local tb=eQ(qc-cO)if((b0 or b6 or b4 or c4 or b3 or bx)and tb>0 or c9>0.0 and tb<aH and p)and t0==0 and eQ(cN)<85 then local tc=qc;local td=aF;if c9==0 then td=td/4;qc=0;tc=0 end;if te==nil then te=pid.new(td*0.01,0,td*0.1)end;te:inject(tc-cO)local tf=te:get()ta=ta+tf*cC end end;local tg=1;local th=0;local ti=1;bL=0;if c8 and u and cM then if tj==nil then tj=pid.new(0.1,0,1)end;local tk=0;if aS>0 and not b6 and c9>0.005 and c9<0.1 and cI>-50 then tk=(0.1-c9)*cw*aS end;tj:inject(cw/3.6+tk-cF:dot(cC))local tl=tj:get()bN=db(tl,-1,1)if not d2 then if bN<bK and c9>0.005 then bM=true;d2=db(bN,0.01,1)else bM=false;d2=bK end end;if tm==nil then tm=pid.new(1*0.01,0,1*0.1)end;tm:inject(cF:len()-cw/3.6-tk)local tn=db(tm:get(),0,1)if c9>0 and cI<-80 or c9>0.005 then bL=tn end;if bL>0 then if bM and bN==0.01 and not d2 then d2=0 end else bN=db(bN,0.01,1)end;local to=''local tp=vec3()local tq=sI(axisCommandId.vertical,bT*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tq,th)local tr='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tr=tr..aT end;local ts=im:getAxisCommandType(axisCommandId.longitudinal)local tt=im:composeAxisAccelerationFromThrottle(tr,axisCommandId.longitudinal)local tu=sV(axisCommandId.lateral,bw*1000)to=to..' , '.."lateral airfoil , lateral ground "tp=tp+tu;if tp:len()>constants.epsilon then d:setEngineForceCommand(to,tp,th,'','','',ti)end;d:setEngineForceCommand(tr,tt,tg)local tv='thrust analog vertical fueled 'local tw='thrust analog lateral fueled 'if bA=="All"or bA=="Lateral"then tw=tw..aU end;if bA=="All"or bA=="Vertical"then tv=tv..aV end;if bT~=0 or b4 and aZ or not bk and not bz then d:setEngineForceCommand(tv,tq,tg)else d:setEngineForceCommand(tv,vec3(),tg)end;if bw~=0 then d:setEngineForceCommand(tw,tu,tg)else d:setEngineForceCommand(tw,vec3(),tg)end;if t2==0 then t2=bL end;local tx=-t2*(aN*cF+aO*t6)d:setEngineForceCommand('brake',tx)else if u then if not d2 then d2=bK end end;local rI=c.getAxisCommandValue(0)if not cM then if tm==nil then tm=pid.new(1*0.01,0,1*0.1)end;tm:inject(cF:len()-rI/3.6)local tn=db(tm:get(),0,1)t2=db(t2+tn,0,1)end;local tx=-t2*(aN*cF+aO*t6)d:setEngineForceCommand('brake',tx)local to=''local tp=vec3()local ty=false;local tr='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tr=tr..aT end;local ts=im:getAxisCommandType(axisCommandId.longitudinal)if ts==axisCommandType.byThrottle then local tt=im:composeAxisAccelerationFromThrottle(tr,axisCommandId.longitudinal)d:setEngineForceCommand(tr,tt,tg)elseif ts==axisCommandType.byTargetSpeed then local tt=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)to=to..' , '..tr;tp=tp+tt;if im:getTargetSpeed(axisCommandId.longitudinal)==0 or im:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-im:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ty=true end end;local tw='thrust analog lateral 'if bA=="All"or bA=="Lateral"then tw=tw..aU end;local tz=im:getAxisCommandType(axisCommandId.lateral)if tz==axisCommandType.byThrottle then local tA=im:composeAxisAccelerationFromThrottle(tw,axisCommandId.lateral)d:setEngineForceCommand(tw,tA,tg)elseif tz==axisCommandType.byTargetSpeed then local tu=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)to=to..' , '..tw;tp=tp+tu end;local tv='thrust analog vertical 'if bA=="All"or bA=="Vertical"then tv=tv..aV end;local tB=im:getAxisCommandType(axisCommandId.vertical)if tB==axisCommandType.byThrottle then local tq=im:composeAxisAccelerationFromThrottle(tv,axisCommandId.vertical)if bT~=0 or b4 and aZ then d:setEngineForceCommand(tv,tq,tg,'airfoil','ground','',ti)else d:setEngineForceCommand(tv,vec3(),tg)d:setEngineForceCommand('airfoil vertical',tq,tg,'airfoil','','',ti)d:setEngineForceCommand('ground vertical',tq,tg,'ground','','',ti)end elseif tB==axisCommandType.byTargetSpeed then if bT<0 then d:setEngineForceCommand('hover',vec3(),tg)end;local tC=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)to=to..' , '..tv;tp=tp+tC end;if tp:len()>constants.epsilon then if qa~=0 or ty or eQ(t6:dot(cC))<0.5 then to=to..', brake'end;d:setEngineForceCommand(to,tp,th,'','','',ti)end end;local tD=aK*(ta-t9)local tE=vec3(b.getWorldAirFrictionAngularAcceleration())tD=tD-tE;d:setEngineTorqueCommand('torque',tD,tg,'airfoil','','',ti)d:setBoosterCommand('rocket_engine')if bY and not n then local fh=cE:len()local tF=0.15;if not cM then local tG=im:getTargetSpeed(axisCommandId.longitudinal)if fh*3.6>tG*(1-tF)and tH then tH=false;d:toggleBoosters()elseif fh*3.6<tG*(1-tF)and not tH then tH=true;d:toggleBoosters()end else local pj=c.getThrottle()if u then pj=bK*100 end;local rI=pj/100;if bI==0 then rI=rI*a0;if fh>=rI*(1-tF)and tH then tH=false;d:toggleBoosters()elseif fh<rI*(1-tF)and not tH then tH=true;d:toggleBoosters()end else local rV=bH(cw)rI=rI*rV/3.6;if fh>=rI*(1-tF)and tH then tH=false;d:toggleBoosters()elseif fh<rI*(1-tF)and not tH then tH=true;d:toggleBoosters()end end end end end;c7=qm()return pM end;local function tI(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,il,im,io,tJ,gA,ip,dW,dc,db,fM,ir,pL)local tK={}local tL=true;local tM=5;local tN=5;local tO=tM;local tP=tN;local tQ=bJ;function tK.startControl(tR)local function tS(sC)local sD=1;local function tT(tU,sC)local tV={j3.surfaceMaxAltitude+100,j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude,j3.noAtmosphericDensityAltitude+U,j3.radius*(T-1)+j3.noAtmosphericDensityAltitude}local tW=tU;for dG,dm in ipairs(tV)do if sC and tW>dm then tU=dm elseif tU<dm and not sC then tU=dm;break end end;return tU end;if sC then sD=-1 end;if not q and cL then if bV and sC then bt=1000 elseif bt~=nil then bt=bt+sD*tN;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end else bt=sr+sD*100 end elseif b3 or b7 or bx then if bx then if bV then cy=tT(cy,sC)else cy=cy+sD*tM end;if cy<j3.noAtmosphericDensityAltitude then cy=j3.noAtmosphericDensityAltitude end else if bV and c8 then b8=tT(b8,sC)else b8=b8+sD*tM end end else im:updateTargetGroundAltitudeFromActionStart(sD*1.0)end end;local function tX(tY)if not c8 then bW="Flight Assist in Atmo only"return end;local dj=type(tY)if cS==nil then if dj=="table"then if b1 or bo then co.ToggleAutopilot()end;fM("180On","BR")elseif tY==1 then fM("bnkLft","BR")else fM("bnkRht","BR")end;if not b3 and not b1 and not bo then co.ToggleAltitudeHold()if dj~="table"then tY=tY+1 end end;cS=tY else fM("180Off","BR")cS=nil end end;if tR=="gear"then bk=not bk;if bk then bo=false;br=nil;co.cmdThrottle(0)if vBooster or hover then if c8 and c7==-1 then fM("bklOn","BL")lu=true;b6=false;b5=false;b7=false;b3=false;b4=true;d6=false;cu=true;bk=false else if bP then fM("grOut","LG",1)d.control.extendLandingGears()end;im:setTargetGroundAltitude(Z)if c8 then aZ=true end end end;if bP and not b4 and not(vBooster or hover)then fM("grOut","LG",1)d.control.extendLandingGears()end else if bP then fM("grIn","LG",1)d.control.retractLandingGears()end;im:setTargetGroundAltitude(Y)end elseif tR=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif tR=="forward"then bQ=bQ-1 elseif tR=="backward"then if p5 then tX(-cF*5000)else bQ=bQ+1 end elseif tR=="left"then if p5 then tX(1)else bR=bR-1 end elseif tR=="right"then if p5 then tX(3)else bR=bR+1 end elseif tR=="yawright"then bS=bS-1;d7=nil elseif tR=="yawleft"then bS=bS+1;d7=nil elseif tR=="straferight"then im:updateCommandFromActionStart(axisCommandId.lateral,1.0)bw=1 elseif tR=="strafeleft"then im:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bw=-1 elseif tR=="up"then bT=bT+1;im:deactivateGroundEngineAltitudeStabilization()im:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif tR=="down"then bT=bT-1;im:deactivateGroundEngineAltitudeStabilization()im:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif tR=="groundaltitudeup"then tS()elseif tR=="groundaltitudedown"then tS(true)elseif tR=="option1"then tZ=false;if p5 and bV then local t_=""for L=1,#cY do t_=t_.."| Name: "..a.getPlayerName(cY[L]).." Mass: "..ip(b.getBoardedPlayerMass(cY[L])/1000,1).."t "end;a.print("Onboard: "..t_)return end;cn.adjustAutopilotTargetIndex()elseif tR=="option2"then tZ=false;if p5 and bV then for L=1,#cY do b.forceDeboard(cY[L])end;bW="Deboarded All Passengers"return end;cn.adjustAutopilotTargetIndex(1)elseif tR=="option3"then local function u0()tL=not tL;if not tL then fM("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(u1,atmofueltank_size,"Atmo Fuel","fuel_container")u2=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(u3,spacefueltank_size,"Space Fuel","fuel_container")u4=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(u5,rocketfueltank_size,"Rocket Fuel","fuel_container")u6=_autoconf.panels[_autoconf.panels_size]end;u7=a.createWidgetPanel("Docking")u8=a.createWidget(u7,"parenting")a.addDataToWidget(c.getDataId(),u8)u9=a.createWidgetPanel("Core combat stress")ua=a.createWidget(u9,"core_stress")a.addDataToWidget(b.getDataId(),ua)if shield_1~=nil then shield_1.show()end else fM("hud","DH")c.hide()b.hide()if u2~=nil then gA(u2)u2=nil end;if u7~=nil then gA(u7)u7=nil end;if u9~=nil then gA(u9)u9=nil end;if u4~=nil then gA(u4)u4=nil end;if u6~=nil then gA(u6)u6=nil end;if shield_1~=nil then shield_1.hide()end end end;tZ=false;if p5 and bV then local t_=""for L=1,#cZ do t_=t_.."| ID: "..cZ[L].." Mass: "..ip(b.getDockedConstructMass(cZ[L])/1000,1).."t "end;a.print("Docked Ships: "..t_)return end;if y then if x then x=false else x=true end end;u0()elseif tR=="option4"then tZ=false;if p5 and bV then for L=1,#cZ do b.forceUndock(cZ[L])end;bW="Undocked all ships"return end;cS=nil;co.ToggleAutopilot()elseif tR=="option5"then tZ=false;co.ToggleLockPitch()elseif tR=="option6"then tZ=false;if p5 and bV then if shield_1 then cr.ventShield()else bW="No shield found"end;return end;co.ToggleAltitudeHold()elseif tR=="option7"then tZ=false;if p5 and bV then if shield_1 then shield_1.toggle()return else bW="No shield found"return end end;F=not F;if F then bW="Collision System Enabled"else bW="Collision System Secured"end elseif tR=="option8"then tZ=false;if p5 and bV then if bj>0 and fX~=nil then co.routeWP()else bW="Select a saved wp on IPH to add to or remove from route"end;return end;bz=not bz;if not bz then bW="DeCoupled Mode - Ground Stabilization off"im:deactivateGroundEngineAltitudeStabilization()fM("gsOff","GS")else bW="Coupled Mode - Ground Stabilization on"im:activateGroundEngineAltitudeStabilization(ub)d:setEngineForceCommand('hover',vec3(),1)fM("gsOn","GS")end elseif tR=="option9"then tZ=false;if p5 and bV then im:resetCommand(axisCommandId.longitudinal)im:resetCommand(axisCommandId.lateral)im:resetCommand(axisCommandId.vertical)co.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cc=gyro.getState()==1;if cc then fM("gyOn","GA")else fM("gyOff","GA")end else bW="No gyro found"end elseif tR=="lshift"then cW=false;if p5 then bV=true end;if io()==1 then bV=true;bg=io()tJ(1)elseif il()==1 and z then bV=true;ct=false;cs=false end elseif tR=="brake"then if aX or p5 then co.BrakeToggle()elseif not aZ then co.BrakeToggle()else aZ=true end elseif tR=="lalt"then tZ=true;p5=true;if il()==0 and not i and g=="keyboard"then tJ(1)end elseif tR=="booster"then if n then d:toggleBoosters()elseif not bY then if not tH then d:toggleBoosters()tH=true end;bY=true else if tH then d:toggleBoosters()tH=false end;bY=false end elseif tR=="stopengines"then local function uc()if bJ-tQ<1.5 then fM("clear","CA")co.clearAll()end end;uc()tQ=bJ;if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then im:resetCommand(axisCommandId.longitudinal)co.cmdThrottle(0)else co.cmdThrottle(100)end else if im:getTargetSpeed(axisCommandId.longitudinal)~=0 then im:resetCommand(axisCommandId.longitudinal)else if c8 then co.cmdCruise(V)else co.cmdCruise(a0*3.6)end end end elseif tR=="speedup"then co.changeSpd()elseif tR=="speeddown"then co.changeSpd(true)elseif tR=="antigravity"and not q then if antigrav~=nil then co.ToggleAntigrav()else bW="No antigrav found"end end end;function tK.stopControl(tR)local function ud()if not q and cL then tP=tN end;if b3 or b7 or bx then tO=tM end end;if tR=="forward"then bQ=0 elseif tR=="backward"then bQ=0 elseif tR=="left"then if cS then if cS==2 then cS=-2 else cS=-1 end end;bR=0 elseif tR=="right"then if cS then if cS==4 then cS=-2 else cS=-1 end end;bR=0 elseif tR=="yawright"then bS=0 elseif tR=="yawleft"then bS=0 elseif tR=="straferight"then im:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bw=0 elseif tR=="strafeleft"then im:updateCommandFromActionStop(axisCommandId.lateral,1.0)bw=0 elseif tR=="up"then bT=0;im:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bz then im:activateGroundEngineAltitudeStabilization(ub)d:setEngineForceCommand('hover',vec3(),1)end elseif tR=="down"then bT=0;im:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bz then im:activateGroundEngineAltitudeStabilization(ub)d:setEngineForceCommand('hover',vec3(),1)end elseif tR=="groundaltitudeup"then ud()tZ=false elseif tR=="groundaltitudedown"then ud()tZ=false elseif tR=="lshift"then if io()==1 then c1=0;c2=0;tJ(bg)elseif il()==1 and z then ct=false;cs=false end;bV=false elseif tR=="brake"then if not aX and not p5 then if aZ then co.BrakeToggle()else aZ=false end end elseif tR=="lalt"then if il()==0 and i then if tZ then if io()==1 then tJ(0)else tJ(1)end else tZ=true end elseif il()==0 and not i and g=="keyboard"then tJ(0)end;p5=false end end;function tK.loopControl(tR)local function ue(sC)local sD=1;if sC then sD=-1 end;if not q and cL then if bt~=nil then bt=bt+sD*tP;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end;tP=db(tP*1.05,tN,50)else bt=sr+sD*100 end elseif b3 or b7 or bx then if bx then cy=cy+sD*tO;if cy<j3.noAtmosphericDensityAltitude then cy=j3.noAtmosphericDensityAltitude end else b8=b8+sD*tO end;tO=db(tO*1.05,tM,50)else im:updateTargetGroundAltitudeFromActionLoop(sD*1.0)end end;local function uf(sC)local sD=1;if sC then sD=-1 end;if not bV then if u and not p5 then bK=db(bK+sD*aC/100,-1,1)else im:updateCommandFromActionLoop(axisCommandId.longitudinal,sD*aC)end end end;if tR=="groundaltitudeup"then if not bV then ue()end elseif tR=="groundaltitudedown"then if not bV then ue(true)end elseif tR=="speedup"then uf()elseif tR=="speeddown"then uf(true)end end;function tK.inputTextControl(sB)local function ug(uh,fn,gq)local function ui(fn)local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..dt..','..dt..','..dt..','..dt..','..dt..'}'local dK,dL,dT,dU,dV=dW(fn,du)if dK=="0"and dL=="0"then return vec3(dc(dT),dc(dU),dc(dV))end;dU=math.rad(dU)dT=math.rad(dT)local j3=e[dc(dK)][dc(dL)]local eM=math.cos(dT)local uj=vec3(eM*math.cos(dU),eM*math.sin(dU),math.sin(dT))return j3.center+(j3.radius+dV)*uj end;local fO=ui(fn)return cn.AddNewLocation(uh,fO,gq)end;local L;local uk,ia=nil,nil;local ul="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to logfile and screen to cut and paste to privatelocations.lua, all if present will make it include all databank locations."L=string.find(sB," ")uk=sB;if L~=nil then uk=string.sub(sB,0,L-1)ia=string.sub(sB,L+1)end;if uk=="/help"or uk=="/commands"then for lv in string.gmatch(ul,"([^\n]+)")do a.print(lv)end;return elseif uk=="/setname"then if ia==nil or ia==""then bW="Usage: ah-setname Newname"return end;if bj>0 and fX~=nil then cn.UpdatePosition(ia)else bW="Select a saved target to rename first"end elseif shield_1 and uk=="/resist"then cr.setResist(ia)elseif uk=="/addlocation"or string.find(sB,"::pos")~=nil then local gq=false;local uh="0-Temp"if ia==nil or ia==""then ia=uk;gq=true end;L=string.find(ia,"::")if not gq then uh=string.sub(ia,1,L-2)end;local fn=string.sub(ia,L)ug(uh,fn,gq)elseif uk=="/agg"then if ia==nil or ia==""then bW="Usage: /agg targetheight"return end;ia=dc(ia)if ia<1000 then ia=1000 end;bt=ia;bW="AGG Target Height set to "..ia elseif uk=="/G"then if ia==nil or ia==""then bW="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ia=="dump"then for dB,dm in pairs(ir())do if type(dm.get())=="boolean"then if dm.get()==true then a.print(dB.." true")else a.print(dB.." false")end elseif dm.get()==nil then a.print(dB.." nil")else a.print(dB.." "..dm.get())end end;return end;L=string.find(ia," ")local um=string.sub(ia,0,L-1)local un=string.sub(ia,L+1)for dB,dm in pairs(ir())do if dB==um then bW="Variable "..um.." changed to "..un;local uo=type(dm.get())if uo=="number"then un=dc(un)if dB=="AtmoSpeedLimit"then cw=un end elseif uo=="boolean"then if string.lower(un)=="true"then un=true else un=false end end;dm.set(un)return end end;bW="No such global variable: "..um elseif uk=="/deletewp"then if bj>0 and fX~=nil then cn.ClearCurrentPosition()else bW="Select a custom wp to delete first in IPH"end elseif uk=="/copydatabank"then if dbHud_2 then pL(true)else bW="Spare Databank required to copy databank"end elseif uk=="/iphWP"then if bj>0 then a.print(co.showWayPoint(c0,bi,true))a.print(json.encode(bi))bW="::pos waypoint shown in lua chat in local and world format"else bW="No target selected in IPH"end elseif uk=="/createPrivate"then local up="privatelocations = {\n"local uq=""if#d4>0 then for dB,dm in pairs(d4)do up=up.."{position = {x = "..dm.position.x..", y = "..dm.position.y..", z = "..dm.position.z.."},\n ".."name = '"..dm.name.."',\n planetname = '"..dm.planetname.."',\n gravity = "..dm.gravity..",\n"if dm.heading then up=up.."heading = {x = "..dm.heading.x..", y = "..dm.heading.y..", z = "..dm.heading.z.."},\n"end;if dm.safe then up=up.."safe = true},\n"else up=up.."safe = false},\n"end end end;uq=#d4 .."-Private "if ia=="all"then for dB,dm in pairs(bn)do if dm.name~="STARTINGPOINT"then up=up.."{position = {x = "..dm.position.x..", y = "..dm.position.y..", z = "..dm.position.z.."},\n ".."name = '*"..dm.name.."',\n planetname = '"..dm.planetname.."',\n gravity = "..dm.gravity..",\n"if dm.heading then up=up.."heading = {x = "..dm.heading.x..", y = "..dm.heading.y..", z = "..dm.heading.z.."},\n"end;if dm.safe then up=up.."safe = true},\n"else up=up.."safe = false},\n"end end end;uq=uq..#bn.."-Public "end;up=up.."}\n return privatelocations"a.logInfo("PRIVATELOCATIONS:"..up)if screenHud_1 then screenHud_1.setHTML(up)end;bW=uq.."locations dumped to logfile and screen if present.\n Cut and paste to privatelocations.lua to use"bX=7 end end;function tK.tagTick()if bA=="Off"then bA="All"elseif bA=="All"then bA="Longitude"elseif bA=="Longitude"then bA="Lateral"elseif bA=="Lateral"then bA="Vertical"else bA="Off"end;bW="Extra Engine Tags: "..bA;c.stopTimer("tagTick")end;return tK end;local function ur(d,b,c,a,library,e,vBooster,hover,pK,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ii,screenHud_1)local us={}local da=string.format;local ij=json.decode;local ut=json.encode;local pE=b.getElementMaxHitPointsById;local ik=b.getElementMassById;local il=d.control.isRemoteControlled;local dW=string.match;local gA=a.destroyWidgetPanel;local fK=a.updateData;local fL=a.addDataToWidget;local tJ=a.lockView;local io=a.isViewLocked;local dd=math.sqrt;local dc=tonumber;local eQ=math.abs;local bH=math.floor;local bI=c.getAtmosphereDensity;local eL=math.atan;local bG=a.getTime;local db=utils.clamp;local im=d.axisCommandManager;local uu=Z;local gC=13;local iu=b.getElementIdList()local iv=0;local function de(et,eu)if et==0 then return eQ(eu)<1e-09 end;if eu==0 then return eQ(et)<1e-09 end;return eQ(et-eu)<math.max(eQ(et),eQ(eu))*ds end;local function ip(dt,uv)local sD=10^(uv or 0)return bH(dt*sD+0.5)/sD end;local function iq(uw,ux)for dB,dm in pairs(ux)do if type(dB)=="string"then uw[dB]=dm else uw[#uw+1]=ux[dB]end end;return uw end;local function ir(uy)local uz={}if not uy then iq(uz,K)iq(uz,a9)iq(uz,aA)iq(uz,aW)return uz elseif uy=="boolean"then return K elseif uy=="handling"then return a9 elseif uy=="hud"then return aA elseif uy=="physics"then return aW end end;local function pL(uA)local function uB(uC)for dB,dm in pairs(uC)do dbHud_1.setStringValue(dB,ut(dm.get()))if uA and dbHud_2 then dbHud_2.setStringValue(dB,ut(dm.get()))end end end;if dbHud_1 then uB(bD)uB(ir())a.print("Saved Variables to Datacore")if uA and dbHud_2 then bW="Databank copied.  Remove copy when ready."end end end;local function fM(uD,uE,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..uD.."|"..uE.."|"..az)else a.logInfo("sound_notification|audiopacks/"..h.."/"..uD.."|"..uE.."|"..az)end else a.logInfo("sound_q|audiopacks/"..h.."/"..uD.."|"..uE.."|"..az)end end;local function gB(hc,hd,sB,jI,uF)if jI==nil then jI=""end;if uF==nil then uF=""end;return da([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jI,hc,hd,uF,sB)end;local function is(c3,uG)local uH=c3>100000;if uG==nil then uG=1 end;if uH then return ip(c3/1000/200,uG).."SU"elseif c3<1000 then return ip(c3,uG).."M"else return ip(c3/1000,uG).."KM"end end;local function it(uI)local uJ=0;local uK=0;local uL=0;if uI<60 then uI=bH(uI)elseif uI<3600 then uJ=bH(uI/60)uI=bH(uI%60)elseif uI<86400 then uK=bH(uI/3600)uJ=bH(uI%3600/60)else uL=bH(uI/86400)uK=bH(uI%86400/3600)end;if uL>0 then return uL.."d "..uK.."h "elseif uK>0 then return uK.."h "..uJ.."m "elseif uJ>0 then return uJ.."m "..uI.."s"elseif uI>0 then return uI.."s"else return"0s"end end;function us.onStart()local uM=false;local function uN()local function uO(uP)local uQ=dbHud_1.hasKey;for dB,dm in pairs(uP)do if uQ(dB)then local dw=ij(dbHud_1.getStringValue(dB))if dw~=nil then dm.set(dw)uM=true end end end end;if dbHud_1 then if not f then uO(ir())coroutine.yield()uO(bD)else uO(bD)bW="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bX=5;uM=false end;coroutine.yield()if uM then bW="Loaded Saved Variables"cd=aa;ce=ab;aX=j;g=string.lower(g)cu=p;cw=V elseif not f then bW="No Saved Variables Found - Exit HUD to save settings"end;if bB<1.500 then if U<2000 then bW="Updating LowOrbitHeight to new minimum default of 2000."U=2000 end end;bB=VERSION_NUMBER;if#bn>0 then d5=iq(d5,bn)end else bW="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bu+180<bJ then bs=0 end;bu=bJ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bW="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bX=7 end;if antigrav and not q then if bt==nil then bt=ca end;antigrav.setBaseAltitude(bt)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then d4=require("autoconf/custom/archhud/privatelocations")if#d4>0 then d5=iq(d5,d4)end end;lD="Proceeding to Waypoint"end;local function uR()local function uS(uT,uU)if uT>uU then uU=uT end;local uV,uW=0,0;if a6>0 then uV=a6*0.05 end;if a7>0 then uW=a7*0.05 end;uU=uU*(1-(uV+uW))return uU end;local uX=b.getElementNameById;local uY=ar~=0 and as~=0;for dB in pairs(iu)do local type=b.getElementTypeById(iu[dB])if dW(type,'^.*Atmospheric Engine$')then if dW(tostring(b.getElementTagsById(iu[dB])),'^.*vertical.*$')and b.getElementForwardById(iu[dB])[3]>0 then cK=true end end;if dW(type,'^.*Space Engine$')then cB=true;if dW(tostring(b.getElementTagsById(iu[dB])),'^.*vertical.*$')then local uZ=b.getElementForwardById(iu[dB])if uZ[3]<0 then u_=true else cA=true end end end;if type=="Landing Gear"then bP=true end;if type=="Dynamic Core Unit"then local pG=pE(iu[dB])if pG>10000 then gC=110 elseif pG>1000 then gC=55 elseif pG>150 then gC=27 end end;iv=iv+pE(iu[dB])if uY and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pG=pE(iu[dB])local ot=ik(iu[dB])local uT=0;local jC=bG()if type=="Atmospheric Fuel Tank"then local uU=400;local v0=35.03;if pG>10000 then uU=51200;v0=5480 elseif pG>1300 then uU=6400;v0=988.67 elseif pG>150 then uU=1600;v0=182.67 end;uT=ot-v0;if a3>0 then uU=uU+uU*a3*0.2 end;uU=uS(uT,uU)cf[#cf+1]={iu[dB],uX(iu[dB]),uU,v0,uT,jC}end;if type=="Rocket Fuel Tank"then local uU=320;local v0=173.42;if pG>65000 then uU=40000;v0=25740 elseif pG>6000 then uU=5120;v0=4720 elseif pG>700 then uU=640;v0=886.72 end;uT=ot-v0;if a5>0 then uU=uU+uU*a5*0.1 end;uU=uS(uT,uU)ch[#ch+1]={iu[dB],uX(iu[dB]),uU,v0,uT,jC}end;if type=="Space Fuel Tank"then local uU=600;local v0=35.03;if pG>10000 then uU=76800;v0=5480 elseif pG>1300 then uU=9600;v0=988.67 elseif pG>150 then uU=2400;v0=182.67 end;uT=ot-v0;if a4>0 then uU=uU+uU*a4*0.2 end;uU=uS(uT,uU)cg[#cg+1]={iu[dB],uX(iu[dB]),uU,v0,uT,jC}end end end;if not cK then b7,aY=false,false end end;local function v1()if gyro~=nil then cc=gyro.getState()==1 end;if not bz then im:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then tJ(1)else tJ(0)end;if door and(c8 or not c8 and ca<10000)then for dG,dm in pairs(door)do dm.toggle()end end;if switch then for dG,dm in pairs(switch)do dm.toggle()end end;if forcefield and(c8 or not c8==0 and ca<10000)then for dG,dm in pairs(forcefield)do dm.toggle()end end;if antigrav then cL=antigrav.getState()==1;if cL and not q then antigrav.show()end end;if il()==1 and k then a.freeze(1)else a.freeze(0)end;if bP then bk=d.control.isAnyLandingGearExtended()==1;if bk then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if c7~=-1 or not c8 and cE:len()<50 then aZ=true;bk=true;if bP then d.control.extendLandingGears()end else aZ=false end;im:setTargetGroundAltitude(uu)if c8 and c7~=-1 then ck=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;ps=c8 end;local function v2()local v3={}local function v4()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local v5={[1]=4480,[6]=4480,[7]=6270}for v6,v7 in pairs(e)do e[v6][0]=v4()e[v6][0].systemId=v6;v3[v6]={}for v8,j3 in pairs(e[v6])do j3.gravity=j3.gravity/9.8;j3.center=vec3(j3.center)j3.name=j3.name[1]j3.noAtmosphericDensityAltitude=j3.atmosphereThickness or j3.atmosphereRadius-j3.radius;if j3.name=="Lacobus"then j3.noAtmosphericDensityAltitude=12510 end;j3.spaceEngineMinAltitude=v5[j3.id]or 0.68377*j3.atmosphereThickness;j3.planetarySystemId=v6;j3.bodyId=j3.id;v3[v6][v8]=j3;if mw==nil or j3.center.x<mw then mw=j3.center.x end;if mv==nil or j3.center.x>mv then mv=j3.center.x end;if mz==nil or j3.center.y<mz then mz=j3.center.y end;if my==nil or j3.center.y>my then my=j3.center.y end;if j3.center and j3.name~="Space"then c_[#c_+1]=j3 end end end;e5=d9(d,b,c,a,da,db,dc,dd,de)ci=e5(v3)cj=eP(d,b,c,a,dd,eQ)cl=fj(d,b,c,a,da,db,dc,dd,de)cn=fJ(d,b,c,a,dbHud_1,e,fK,fL,bH,dc,dd,fM)end;v9=false;va=coroutine.create(function()im:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})uN()coroutine.yield()uR()coroutine.yield()co=pJ(d,b,c,a,e,vBooster,hover,pK,antigrav,warpdrive,dbHud_1,eQ,bH,bI,il,eL,bG,db,im,fK,io,dd,ip,fM,iq,de,is,it,pL,ij,da,fL)v1()coroutine.yield()v2()if radar_1 then cp=gz(b,a,c,library,radar_1,radar_2,eQ,gA,dd,gB,dc,gC,fM)end;cm=ih(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ii,eQ,bH,da,ij,bI,ik,il,eL,bG,db,im,fL,fK,gA,io,dd,ip,gB,fM,iq,ir,is,it,iu,iv)cm.ButtonSetup()cq=tI(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,il,im,io,tJ,gA,ip,dW,dc,db,fM,ir,pL)if shield_1 then cr=i1(shield_1,dW,bH)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aQ)if radar_1 then c.setTimer("radarTick",aQ)end;c.setTimer("hudTick",aR)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield_1 then c.setTimer("shieldTick",aQ)end;fM("start","SU")end)coroutine.resume(va)end;function us.onUpdate()if not v9 then local hS=coroutine.status(va)if hS=="suspended"then local dC,hT=coroutine.resume(va)if hT then a.print("ERROR STARTUP: "..hT)end elseif hS=="dead"then v9=true end end;if v9 then d:update()if c8 and u and cM then if cM and bO then co.cmdThrottle(0)bO=false elseif not cM and not bO then bK=0;bO=true end end;if d2 then im:setThrottleCommand(axisCommandId.longitudinal,d2)d2=nil end;if not cs and p7~=vb then a.setScreen(p7)end;vb=p7 end end;function us.onFlush()if v9 then co.onFlush()end end;function us.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c9>0 or c9==0 and ca<10000)then for dG,dm in pairs(door)do dm.toggle()end end;if switch then for dG,dm in pairs(switch)do dm.toggle()end end;if forcefield and(c9>0 or c9==0 and ca<10000)then for dG,dm in pairs(forcefield)do dm.toggle()end end;x=d1;pL()if o2 then o2.activate()end;if A then co.showWayPoint(j3,cJ)end;a.print(cm.FuelUsed("atmofueltank")..", "..cm.FuelUsed("spacefueltank")..", "..cm.FuelUsed("rocketfueltank"))fM("stop","SU")end;function us.controlStart(tR)if v9 then cq.startControl(tR)end end;function us.controlStop(tR)if v9 then cq.stopControl(tR)end end;function us.controlLoop(tR)if v9 then cq.loopControl(tR)end end;function us.controlInput(sB)if v9 then cq.inputTextControl(sB)end end;function us.radarEnter(dL)cp.onEnter(dL)end;function us.radarLeave(dL)cp.onLeave(dL)end;function us.onTick(vc)if vc=="tenthSecond"then co.TenthTick()cm.TenthTick()elseif vc=="oneSecond"then cm.OneSecondTick()elseif vc=="fiveSecond"then co.SatNavTick()elseif vc=="msgTick"then cm.MsgTick()elseif vc=="animateTick"then cm.AnimateTick()elseif vc=="hudTick"then cm.hudtick()elseif vc=="apTick"then co.APTick()elseif vc=="radarTick"then cp.UpdateRadar()elseif vc=="shieldTick"then cr.shieldTick()elseif vc=="tagTick"then cq.tagTick()elseif vc=="contact"then cp.ContactTick()end end;return us end;function script.onStart()vd.onStart()end;function script.onStop()vd.onStop()end;function script.onTick(vc)vd.onTick(vc)end;function script.onFlush()vd.onFlush()end;function script.onUpdate()vd.onUpdate()end;function script.onActionStart(tR)vd.controlStart(tR)end;function script.onActionStop(tR)vd.controlStop(tR)end;function script.onActionLoop(tR)vd.controlLoop(tR)end;function script.onInputText(sB)vd.controlInput(sB)end;function script.onEnter(dL)vd.radarEnter(dL)end;function script.onLeave(dL)vd.radarLeave(dL)end;bF(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)vd=ur(d,b,c,a,library,e,vBooster,hover,pK,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ii,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
