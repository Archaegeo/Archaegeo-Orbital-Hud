name: ArchHud - Archaegeo v0.102 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
  transponder:
    class: TransponderUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.102;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=5000;T=1.3;U=2000;V=1175;W=66000;X=1000;Y=50;Z=0;_=100000;a0=-1.00;a1=1;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=1;ab={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},AutopilotSpaceDistance={set=function(M)S=M end,get=function()return S end},TargetOrbitRadius={set=function(M)T=M end,get=function()return T end},LowOrbitHeight={set=function(M)U=M end,get=function()return U end},AtmoSpeedLimit={set=function(M)V=M end,get=function()return V end},SpaceSpeedLimit={set=function(M)W=M end,get=function()return W end},AutoTakeoffAltitude={set=function(M)X=M end,get=function()return X end},TargetHoverHeight={set=function(M)Y=M end,get=function()return Y end},LandingGearGroundHeight={set=function(M)Z=M end,get=function()return Z end},ReEntryHeight={set=function(M)_=M end,get=function()return _ end},MaxGameVelocity={set=function(M)a0=M end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(M)a1=M end,get=function()return a1 end},warmup={set=function(M)a2=M end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingSpace={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingRocket={set=function(M)a5=M end,get=function()return a5 end},ContainerOptimization={set=function(M)a6=M end,get=function()return a6 end},FuelTankOptimization={set=function(M)a7=M end,get=function()return a7 end},AutoShieldPercent={set=function(M)a8=M end,get=function()return a8 end},EmergencyWarp={set=function(M)a9=M end,get=function()return a9 end},DockingMode={set=function(M)aa=M end,get=function()return aa end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=1.0;aV="none"aW="none"aX="none"aY=0.05;aZ=0.0;a_={speedChangeLarge={set=function(M)aE=M end,get=function()return aE end},speedChangeSmall={set=function(M)aF=M end,get=function()return aF end},MouseXSensitivity={set=function(M)aG=M end,get=function()return aG end},MouseYSensitivity={set=function(M)aH=M end,get=function()return aH end},autoRollFactor={set=function(M)aI=M end,get=function()return aI end},rollSpeedFactor={set=function(M)aJ=M end,get=function()return aJ end},autoRollRollThreshold={set=function(M)aK=M end,get=function()return aK end},minRollVelocity={set=function(M)aL=M end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(M)aM=M end,get=function()return aM end},torqueFactor={set=function(M)aN=M end,get=function()return aN end},pitchSpeedFactor={set=function(M)aO=M end,get=function()return aO end},yawSpeedFactor={set=function(M)aP=M end,get=function()return aP end},brakeSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeFlatFactor={set=function(M)aR=M end,get=function()return aR end},DampingMultiplier={set=function(M)aS=M end,get=function()return aS end},hudTickRate={set=function(M)aT=M end,get=function()return aT end},ExtraEscapeThrust={set=function(M)aU=M end,get=function()return aU end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end},allowedHorizontalDrift={set=function(M)aY=M end,get=function()return aY end},FastOrbit={set=function(M)aZ=M end,get=function()return aZ end}}b0=k;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=false;bc=1000;bd=false;be=false;bf=false;bg=false;bh=0;bi="Aligning"bj=true;bk="None"bl=nil;bm=0;bn=nil;bo=0.0;bp=0;bq={}br=false;bs=0;bt=0;bu=nil;bv=0;bw=1000;bx=0;by=false;bz=0;bA=false;bB="All"bC=true;bD="Off"bE=0.000;bF={}bG={}bH={}bI=9000;bJ={VertTakeOff={set=function(M)bb=M end,get=function()return bb end},VertTakeOffEngine={set=function(M)b1=M end,get=function()return b1 end},SpaceTarget={set=function(M)by=M end,get=function()return by end},BrakeToggleStatus={set=function(M)b0=M end,get=function()return b0 end},BrakeIsOn={set=function(M)b2=M end,get=function()return b2 end},RetrogradeIsOn={set=function(M)b3=M end,get=function()return b3 end},ProgradeIsOn={set=function(M)b4=M end,get=function()return b4 end},Autopilot={set=function(M)b5=M end,get=function()return b5 end},TurnBurn={set=function(M)b6=M end,get=function()return b6 end},AltitudeHold={set=function(M)b7=M end,get=function()return b7 end},BrakeLanding={set=function(M)b8=M end,get=function()return b8 end},Reentry={set=function(M)ba=M end,get=function()return ba end},AutoTakeoff={set=function(M)b9=M end,get=function()return b9 end},HoldAltitude={set=function(M)bc=M end,get=function()return bc end},AutopilotAccelerating={set=function(M)bd=M end,get=function()return bd end},AutopilotBraking={set=function(M)bf=M end,get=function()return bf end},AutopilotCruising={set=function(M)bg=M end,get=function()return bg end},AutopilotRealigned={set=function(M)be=M end,get=function()return be end},AutopilotEndSpeed={set=function(M)bh=M end,get=function()return bh end},AutopilotStatus={set=function(M)bi=M end,get=function()return bi end},PrevViewLock={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetName={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetCoords={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetIndex={set=function(M)bm=M end,get=function()return bm end},TotalDistanceTravelled={set=function(M)bo=M end,get=function()return bo end},TotalFlightTime={set=function(M)bp=M end,get=function()return bp end},SavedLocations={set=function(M)bq=M end,get=function()return bq end},VectorToTarget={set=function(M)br=M end,get=function()return br end},LocationIndex={set=function(M)bs=M end,get=function()return bs end},LastMaxBrake={set=function(M)bt=M end,get=function()return bt end},LockPitch={set=function(M)bu=M end,get=function()return bu end},LastMaxBrakeInAtmo={set=function(M)bv=M end,get=function()return bv end},AntigravTargetAltitude={set=function(M)bw=M end,get=function()return bw end},LastStartTime={set=function(M)bx=M end,get=function()return bx end},iphCondition={set=function(M)bB=M end,get=function()return bB end},stablized={set=function(M)bC=M end,get=function()return bC end},UseExtra={set=function(M)bD=M end,get=function()return bD end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bF=M end,get=function()return bF end},apRoute={set=function(M)bG=M end,get=function()return bG end},ecuThrottle={set=function(M)bH=M end,get=function()return bH end},adjMaxGameVelocity={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=q;cA=false;cB=V;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2={}d3={}d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()dg=nil;dh=nil;di=nil;dj=nil;dk=nil;dl=nil;dm=false;if shield then dn=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dp(dq)a.print(bQ..": "..dq)end;local function dr(d,b,c,a,ds,dt,du,dv,dw)local function dx(dy)return type(dy)=='number'end;local function dz(dy)return type(du(dy))=='number'end;local function dA(dB)return type(dB)=='table'end;local function dC(a)return type(a)=='string'end;local function dD(dE)return dA(dE)and dx(dE.x and dE.y and dE.z)end;local function dF(dG)return dA(dG)and dx(dG.latitude and dG.longitude and dG.altitude and dG.id and dG.systemId)end;local dH=math.pi/180;local dI=180/math.pi;local dJ=1e-10;local dK=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dL='::pos{'..dK..','..dK..','..dK..','..dK..','..dK..'}'local utils=utils;local vec3=vec3;local function dM(dy)local dN=string.gsub(string.reverse(ds('%.4f',dy)),'^0*%.?','')return dN==''and'0'or string.reverse(dN)end;local function dO(dP)if dD(dP)then return ds('{x=%.3f,y=%.3f,z=%.3f}',dP.x,dP.y,dP.z)end;if dA(dP)and not getmetatable(dP)then local dQ={}local dR=next(dP)if type(dR)=='nil'or dR==1 then dQ=dP else for dS,dE in pairs(dP)do local dT=dO(dE)if type(dS)=='number'then table.insert(dQ,ds('[%s]=%s',dS,dT))else table.insert(dQ,ds('%s=%s',dS,dT))end end end;return ds('{%s}',table.concat(dQ,','))end;if dC(dP)then return ds("'%s'",dP:gsub("'",[[\']]))end;return tostring(dP)end;local dU={}dU.__index=dU;dU.__tostring=function(dP,dV)local dW={}for dS in pairs(dP)do table.insert(dW,dS)end;table.sort(dW)local dQ={}for dX,dS in ipairs(dW)do local dT=dO(dP[dS])if type(dS)=='number'then table.insert(dQ,ds('[%s]=%s',dS,dT))else table.insert(dQ,ds('%s=%s',dS,dT))end end;if dV then return ds('%s%s',dV,table.concat(dQ,',\n'..dV))end;return ds('{%s}',table.concat(dQ,','))end;dU.__eq=function(dY,dZ)return dY.systemId==dZ.systemId and dY.id==dZ.id and dw(dY.radius,dZ.radius)and dw(dY.center.x,dZ.center.x)and dw(dY.center.y,dZ.center.y)and dw(dY.center.z,dZ.center.z)and dw(dY.GM,dZ.GM)end;local function d_(e0,e1,e2,e3,e4)assert(dz(e0),'Argument 1 (systemId) must be a number:'..type(e0))assert(dz(e1),'Argument 2 (id) must be a number:'..type(e1))assert(dz(e2),'Argument 3 (radius) must be a number:'..type(e2))assert(dA(e3),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e3))assert(dz(e4),'Argument 5 (GM) must be a number:'..type(e4))return setmetatable({systemId=du(e0),id=du(e1),radius=du(e2),center=vec3(e3),GM=du(e4)},dU)end;local e5={}e5.__index=e5;e5.__tostring=function(dp)return ds('::pos{%d,%d,%s,%s,%s}',dp.systemId,dp.id,dM(dp.latitude*dI),dM(dp.longitude*dI),dM(dp.altitude))end;e5.__eq=function(dY,dZ)return dY.id==dZ.id and dY.systemId==dZ.systemId and dw(dY.latitude,dZ.latitude)and dw(dY.altitude,dZ.altitude)and(dw(dY.longitude,dZ.longitude)or dw(dY.latitude,math.pi/2)or dw(dY.latitude,-math.pi/2))end;local function e6(e7,e1,e8,e9,ea)local e0=e7;if dC(e7)and not e9 and not ea and not e1 and not e8 then e0,e1,e8,e9,ea=eb(e7,dL)assert(e0,'Argument 1 (position string) is malformed.')else assert(dz(e0),'Argument 1 (systemId) must be a number:'..type(e0))assert(dz(e1),'Argument 2 (id) must be a number:'..type(e1))assert(dz(e8),'Argument 3 (latitude) must be in degrees:'..type(e8))assert(dz(e9),'Argument 4 (longitude) must be in degrees:'..type(e9))assert(dz(ea),'Argument 5 (altitude) must be in meters:'..type(ea))end;e0=du(e0)e1=du(e1)e8=du(e8)e9=du(e9)ea=du(ea)if e1==0 then return setmetatable({latitude=e8,longitude=e9,altitude=ea,id=e1,systemId=e0},e5)end;return setmetatable({latitude=dH*dt(e8,-90,90),longitude=dH*(e9%360),altitude=ea,id=e1,systemId=e0},e5)end;local ec={}ec.__index=ec;ec.__tostring=function(dP,dV)local ed=dV and dV..'  'local ee={}local dW={}for dS in pairs(dP)do table.insert(dW,dS)end;table.sort(dW)for dX,ef in ipairs(dW)do eg=dP[ef]local eh=dU.__tostring(eg,ed)if dV then table.insert(ee,ds('[%s]={\n%s\n%s}',ef,eh,dV))else table.insert(ee,ds('  [%s]=%s',ef,eh))end end;if dV then return ds('\n%s%s%s',dV,table.concat(ee,',\n'..dV),dV)end;return ds('{\n%s\n}',table.concat(ee,',\n'))end;local function ei(ej)local e={}local pid;for dX,dE in pairs(ej)do local e1=dE.planetarySystemId;if type(e1)~='number'then error('Invalid planetary s ID: '..tostring(e1))elseif pid and e1~=pid then error('Mistringmatch planetary s IDs: '..e1 ..' and '..pid)end;local ek=dE.bodyId;if type(ek)~='number'then error('Invalid body ID: '..tostring(ek))elseif e[ek]then error('Duplicate body ID: '..tostring(ek))end;setmetatable(dE.center,getmetatable(vec3.unit_x))e[ek]=setmetatable(dE,dU)pid=e1 end;return setmetatable(e,ec)end;el={}local function em(ej)return setmetatable({galaxyAtlas=ej or{}},el)end;el.__index=function(dB,M)if type(M)=='number'then local a=dB.galaxyAtlas[M]return ei(a)end;return rawget(el,M)end;el.__pairs=function(dP)return function(dB,dS)local en,eo=next(dB,dS)return en,eo and ei(eo)end,dP.galaxyAtlas,nil end;el.__tostring=function(dP)local ep={}for dX,eq in pairs(dP or{})do local er=eq:getPlanetarySystemId()local es=ec.__tostring(eq,'    ')table.insert(ep,ds('  [%s]={%s\n  }',er,es))end;return ds('{\n%s\n}\n',table.concat(ep,',\n'))end;el.BodyParameters=d_;el.MapPosition=e6;el.PlanetarySystem=ei;function el.createBodyParameters(e0,e1,et,eu,ev,ew,ex)assert(dz(e0),'Argument 1 (systemId) must be a number:'..type(e0))assert(dz(e1),'Argument 2 (id) must be a number:'..type(e1))assert(dz(et),'Argument 3 (surfaceArea) must be a number:'..type(et))assert(dA(eu),'Argument 4 (aPosition) must be an array or vec3:'..type(eu))assert(dA(ev),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ev))assert(dz(ew),'Argument 6 (altitude) must be in meters:'..type(ew))assert(dz(ex),'Argument 7 (gravityAtPosition) must be number:'..type(ex))local e2=dv(et/4/math.pi)local cb=e2+ew;local ey=vec3(eu)+cb*vec3(ev)local e4=ex*cb*cb;return d_(e0,e1,e2,ey,e4)end;el.isMapPosition=dF;function el:getPlanetarySystem(e7)if M==nil then M=0 end;if eo==nil then eo=0 end;local e0=e7;if dF(e7)then e0=e7.systemId end;if type(e0)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eo)~=ec then a=ei(a)end;return a end end end;function ec:sizeCalculator(ez)return 1.05*ez.radius end;function ec:castIntersections(eA,eB,eC,eD,eE,eF)local eG={}if eE then for dX,ez in pairs(eE)do table.insert(eG,ez)end else eG=d4 end;if not eF then table.sort(eG,function(eH,eI)local eJ=eH.center;local eK=eI.center;return(eJ.x-eA.x)^2+(eJ.y-eA.y)^2+(eJ.z-eA.z)^2<(eK.x-eA.x)^2+(eK.y-eA.y)^2+(eK.z-eA.z)^2 end)end;local eL=eB:normalize()for dX,ez in ipairs(eG)do local eM=ez.center-eA;local e2;if eC then e2=eC(ez)else e2=self:sizeCalculator(ez)end;local eN=eM:dot(eL)local eO=eN^2-(eM:len2()-e2^2)if eO>=0 then local eP=dv(eO)local eQ=eN+eP;local eR=eN-eP;if eR>0 then return ez,eQ,eR elseif eQ>0 then return ez,eQ,nil end end end;return nil,nil,nil end;function ec:closestBody(eS)assert(type(eS)=='table','Invalid coordinates.')local eT,ez;local eU=vec3(eS)for dX,eV in pairs(self)do local eW=(eU-eV.center):len()-eV.radius-eV.atmosphereThickness;if(not ez or eW<eT)and eV.name~="Space"and eV.name~="Aegis"then ez=eV;eT=eW end end;return ez end;function ec:convertToBodyIdAndWorldCoordinates(e7)local eX=e7;if dC(e7)then eX=e6(e7)end;if eX.id==0 then return 0,vec3(eX.latitude,eX.longitude,eX.altitude)end;local eV=self:getBodyParameters(eX)if eV then return eX.id,eV:convertToWorldCoordinates(eX)end end;function ec:getBodyParameters(e7)local e1=e7;if dF(e7)then e1=e7.id end;assert(dz(e1),'Argument 1 (id) must be a number:'..type(e1))return self[e1]end;function ec:getPlanetarySystemId()local dX,dE=next(self)return dE and dE.systemId end;function dU:convertToMapPosition(e3)assert(dA(e3),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e3))local eY=vec3(e3)if self.id==0 then return setmetatable({latitude=eY.x,longitude=eY.y,altitude=eY.z,id=0,systemId=self.systemId},e5)end;local eZ=eY-self.center;local cb=eZ:len()local ea=cb-self.radius;local e8=0;local e9=0;if not dw(cb,0)then local e_=f0(eZ.y,eZ.x)e9=e_>=0 and e_ or 2*math.pi+e_;e8=math.pi/2-math.acos(eZ.z/cb)end;return setmetatable({latitude=e8,longitude=e9,altitude=ea,id=self.id,systemId=self.systemId},e5)end;function dU:convertToWorldCoordinates(e7)local eX=dC(e7)and e6(e7)or e7;if eX.id==0 then return vec3(eX.latitude,eX.longitude,eX.altitude)end;assert(dF(eX),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eX.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eX.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local f1=math.cos(eX.latitude)return self.center+(self.radius+eX.altitude)*vec3(f1*math.cos(eX.longitude),f1*math.sin(eX.longitude),math.sin(eX.latitude))end;function dU:getAltitude(e3)return(vec3(e3)-self.center):len()-self.radius end;function dU:getDistance(e3)return(vec3(e3)-self.center):len()end;function dU:getGravity(e3)local f2=self.center-vec3(e3)local f3=f2:len2()return self.GM/f3*f2/dv(f3)end;return setmetatable(el,{__call=function(dX,...)return em(...)end})end;local function f4(d,b,c,a,dv,f5)local cp={}local f6=100;function cp.computeAccelerationTime(f7,f8,f9)return(f9-f7)/f8 end;function cp.computeDistanceAndTime(f7,f9,fa,fb,fc,fd)fc=fc or 0;fd=fd or 0;local fe=f7<f9;local ff=fb/(fe and fa or-fa)local fg=-fd/fa;local fh=ff+fg;if f7==f9 then return 0,0 elseif fe and fh<=0 or not fe and fh>=0 then return-1,-1 end;local fi,fj=0,0;if ff~=0 and fc>0 then local fk=math.pi/fc/2;local dE=function(dB)return ff*(dB/2-fc*math.sin(fk*dB)/math.pi)+fg*dB+f7 end;local fl=fe and function(a)return a>=f9 end or function(a)return a<=f9 end;fj=2*fc;if fl(dE(fj))then local fm=0;while math.abs(fj-fm)>0.25 do local dB=(fj+fm)/2;if fl(dE(dB))then fj=dB else fm=dB end end end;local fn=2*ff*fc^2/math.pi^2;fi=fn*(math.cos(fk*fj)-1)+(ff+2*fg)*fj^2/4+f7*fj;if fj<2*fc then return fi,fj end;f7=dE(fj)end;local eJ=ff+fg;local dB=cp.computeAccelerationTime(f7,eJ,f9)local fo=f7*dB+eJ*dB*dB/2;return fi+fo,fj+dB end;function cp.computeTravelTime(f7,f8,cb)if cb==0 then return 0 end;if f8~=0 then return(math.sqrt(2*f8*cb+f7^2)-f7)/f8 end;assert(f7>0,'Acceleration and initial speed are both zero.')return cb/f7 end;return cp end;local function fp(d,b,c,a,ds,dt,du,dv,dw)local vec3=vec3;local dr=dr(d,b,c,a,ds,dt,du,dv,dw)local function dC(a)return type(a)=='string'end;local function dA(dB)return type(dB)=='table'end;fq={}fq.__index=fq;function fq:escapeAndOrbitalSpeed(ea)assert(self.body)local cb=ea+self.body.radius;if not dw(cb,0)then local fr=dv(self.body.GM/cb)return dv(2)*fr,fr end;return nil,nil end;function fq:orbitalParameters(e7,fs)assert(self.body)assert(dA(e7)or dC(e7))assert(dA(fs))local ft=(dC(e7)or dr.isMapPosition(e7))and self.body:convertToWorldCoordinates(e7)or vec3(e7)local dE=vec3(fs)local fu=ft-self.body.center;local fv=dE:len2()local fo=fu:len()local fw=self.body.GM;local fx=((fv-fw/fo)*fu-fu:dot(dE)*dE)/fw;local eJ=fw/(2*fw/fo-fv)local fy=fx:len()local eL=fx:normalize()local fz=eJ*(1-fy)local fA=eJ*(1+fy)local fB=fz*eL+self.body.center;local fC=fy<=1 and-fA*eL+self.body.center or nil;local fD=dv(eJ*fw*(1-fy*fy))local fE=fC and 2*math.pi*dv(eJ^3/fw)local fF=math.acos(fx:dot(fu)/(fy*fo))if fu:dot(dE)<0 then fF=-(fF-2*math.pi)end;local fG=math.acos((math.cos(fF)+fy)/(1+fy*math.cos(fF)))local fH=fG;if fH<0 then fH=fH+2*math.pi end;local fI=fH-fy*math.sin(fH)local fJ=0;local fK=0;local fL=0;if fE~=nil then fJ=fI/(2*math.pi/fE)fK=fE-fJ;fL=fK+fE/2;if fF-math.pi>0 then fK=fJ;fL=fK+fE/2 end;if fL>fE then fL=fL-fE end end;return{periapsis={position=fB,speed=fD/fz,circularOrbitSpeed=dv(fw/fz),altitude=fz-self.body.radius},apoapsis=fC and{position=fC,speed=fD/fA,circularOrbitSpeed=dv(fw/fA),altitude=fA-self.body.radius},currentVelocity=dE,currentPosition=ft,eccentricity=fy,period=fE,eccentricAnomaly=fG,meanAnomaly=fI,timeToPeriapsis=fK,timeToApoapsis=fL,trueAnomaly=fF}end;local function fM(fN)local eV=dr.BodyParameters(fN.systemId,fN.id,fN.radius,fN.center,fN.GM)return setmetatable({body=eV},fq)end;return setmetatable(fq,{__call=function(dX,...)return fM(...)end})end;local function fO(d,b,c,a,dbHud_1,e,fP,fQ,bN,du,dv,fR,fS,dq)local function fT(fU)local dp=fV:closestBody(fU)if(fU-dp.center):len()>dp.radius+dp.noAtmosphericDensityAltitude then dp=e[0][0]end;return dp end;local function fW()local function fX(fY,fZ)return fY.name<fZ.name end;cU={}for dS,dE in pairs(e[0])do cU[#cU+1]={name=dE.name,index=dS}end;table.sort(cU,fX)end;local function f_(g0,g1)if not g1 then g1=g2.name end;for dS,dE in pairs(g0)do if dE.name and dE.name==g1 then return dS end end;return-1 end;local function g3()d1=bm;if bm==0 then bk="None"c8=nil;g2=nil;return true end;local g4=cU[bm].index;local g5=e[0][g4]if g5.center then bk=g5.name;c8=co[0][g4]if g2~=nil then if ch==0 then if not fP(g6,g7)then fQ(g6,g7)end;if not fP(g8,g9)then fQ(g8,g9)end;if not fP(ga,gb)then fQ(ga,gb)end;if not fP(gc,gd)then fQ(gc,gd)end;if not fP(ge,gf)then fQ(ge,gf)end end;if not fP(gg,gh)then fQ(gg,gh)end;if not fP(gi,gj)then fQ(gi,gj)end;if not fP(gk,gl)then fQ(gk,gl)end end;g2=nil else g2=g5;for dX,dE in pairs(co[0])do if dE.name==g2.planetname then c8=dE;bk=g2.name;break end end;if not fP(gg,gh)then fQ(gg,gh)end;if not fP(gi,gj)then fQ(gi,gj)end end;if g2==nil then bl=vec3(c8.center)else bl=g2.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gm=bN(c8.radius*(T-1)+c8.noAtmosphericDensityAltitude)else gm=bN(U+c8.surfaceMaxAltitude)end else gm=S end;if g2~=nil and g2.planetname=="Space"then bh=0 else dX,bh=cq(c8):escapeAndOrbitalSpeed(gm)end;bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"return true end;local function gn(go)if not dm and not b5 and not br and not cd and not bA and not ba and not ce then if go==nil then bm=bm+1;if bm>#cU then bm=0 end else bm=bm-1;if bm<0 then bm=#cU end end;if bm==0 then g3()else local g4=cU[bm].index;local g5=e[0][g4]if g5 and(g5~=nil and g5.name=="Space"or bB=="Custom Only"and g5.center or bB=="No Moons-Asteroids"and(string.find(g5.name,"Moon")~=nil or string.find(g5.name,"Asteroid")~=nil))then if go==nil then gn()else gn(1)end else g3()end end else dq("Disengage autopilot before changing Interplanetary Helper")fR("iph","AP")end end;local function gp()local function gq(gr)local gs;if gr then gs=d9 else gs=bq end;local gt=-1;gt=f_(e[0])if gt>-1 then table.remove(e[0],gt)end;gt=-1;gt=f_(gs)if gt~=-1 then dq(g2.name.." saved location cleared")table.remove(gs,gt)end;gn()fW()return gs end;if string.sub(bk,1,1)=="*"then d9=gq(true)else bq=gq(false)end end;local function gu(gv,fU,gw,gx)local function gy(gr)if gr then gs=d9 else gs=bq end;if dbHud_1 or gw or gr then local dp=fT(fU)local gz={position=fU,name=gv,planetname=dp.name,gravity=b.getGravityIntensity(),safe=gx}if not gw then gs[#gs+1]=gz else for dS,dE in pairs(e[0])do if dE.name and gv==dE.name then table.remove(e[0],dS)end end end;table.insert(e[0],gz)fW()if gw then bm=1 end;g3()dq("Location saved as "..gv.."("..dp.name..")")return gs else dq("Databank must be installed to save permanent locations")end end;if string.sub(gv,1,1)=="*"then d9=gy(true)else bq=gy(false)end end;local gA={}function gA.UpdateAtlasLocationsList()fW()end;function gA.UpdateAutopilotTarget()g3()end;function gA.adjustAutopilotTargetIndex(go)gn(go)end;function gA.findAtlasIndex(g0,g1)return f_(g0,g1)end;function gA.UpdatePosition(gB,gC,gD)local function gE(gr)local gs;if gr then gs=d9 else gs=bq end;local gt=f_(gs)if gt~=-1 then if gB~=nil then if gr then gB="*"..gB end;gs[gt].name=gB;bm=bm-1;gn()elseif gD~=nil then if gD then local gF=ci;if gF<1000 then gF=1000 end;gs[gt].agg=fS(gF,0)dq(gs[gt].name.." AGG Altitude:"..gs[gt].agg.." saved ("..gs[gt].planetname..")")return elseif gD==false then gs[gt].agg=nil;dq(gs[gt].name.." AGG Altitude cleared ("..gs[gt].planetname..")")return end else local gG=gs[gt]if gC then gG.heading=cI:cross(cM)*5000;dq(gs[gt].name.." heading saved ("..gs[gt].planetname..")")return elseif gC==false then gG.heading=nil;dq(gs[gt].name.." heading cleared ("..gs[gt].planetname..")")return end;gG.gravity=b.getGravityIntensity()gG.position=cO;gG.safe=true end;dq(gs[gt].name.." position updated ("..gs[gt].planetname..")")else dq("Name Not Found")end end;if string.sub(bk,1,1)=="*"then gE(true)else gE(false)end end;function gA.AddNewLocation(gv,fU,gw,gx)gu(gv,fU,gw,gx)end;function gA.ClearCurrentPosition()gp()end;for dS,dE in pairs(da)do table.insert(e[0],dE)end;if gH then for dS,dE in pairs(gH)do gA[dS]=dE end end;fW()if bm>#cU then bm=0 end;gA.UpdateAutopilotTarget()return gA end;local function gI(b,a,c,radar_1,radar_2,warpdrive,f5,gJ,dv,gK,du,gL,fR,dq)local gM={}local gN={}local gO={XS=13,S=27,M=55,L=110,XL=221}local gP={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gQ={}local gR=0;local gS;local gT;local gU=0;local gV;local gW={gV}local gX="Atmo"local gY;local gZ;local g_=0;local h0={}local h1;local h2=0;local h3=table.insert;local h4=-4;local h5={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h6,h7;local h8,h9;local ha;local hb;local hc;local hd;local he;local hf;local hg;local function hh()if hi~=nil and g_==0 then gJ(hi)a.destroyWidget(h6)a.destroyData(h8)h6,h8,hi=nil,nil,nil;if gZ~=nil then gJ(gZ)a.destroyWidget(h7)a.destroyData(h9)gZ,h7,h9=nil,nil,nil end else if g_==1 then gZ=a.createWidgetPanel("PeriWinkle")h7=a.createWidget(gZ,'periscope')h9=gV.getWidgetDataId()a.addDataToWidget(h9,h7)end;if hi==nil and gR>0 then hi=a.createWidgetPanel(gX)h6=a.createWidget(hi,'radar')h8=gV.getWidgetDataId()a.addDataToWidget(h8,h6)end;g_=0 end end;local function hj()local function hk(hl,hm,hn,ho,hp,hq,hr,hs)hm,ho,hq,hs=vec3(hm),vec3(ho),vec3(hq),vec3(hs)local ht,hu,hv=hl*hl,hn*hn,hp*hp;local fv=ho-hm;local hw=fv:normalize()local hx=fv:len()local hy=hq-hm;local hz=(hy-hy:project_on(hw)):normalize()local hA,hB=hy:dot(hw),hy:dot(hz)local hC=hA*hA+hB*hB;local hD=hw:cross(hz)local hE=(ht-hu+hx*hx)/(2*hx)local hF=(ht-hv+hC-2*hA*hE)/(2*hB)local dG=ht-hE^2-hF^2;local hG=dv(dG)local hH=hm+hw*hE+hz*hF+hD*hG;local hI=hm+hw*hE+hz*hF-hD*hG;if f5((hs-hH):len()-hr)<f5((hs-hI):len()-hr)then return hH else return hI end end;local function hJ(hK,fo,hL)local hM=hK.pts;local gt=#hM;local hN=hK.ref;if gt>3 then local hO,hP,hQ,hR=hM[gt],hM[gt-1],hM[gt-2],hM[gt-3]hK.ref=hL;local ft=hk(hO[1],hO[2],hP[1],hP[2],hQ[1],hQ[2],hR[1],hR[2])local hE,hF,hG=ft.x,ft.y,ft.z;if hE==hE and hF==hF and hG==hG then hE=hE+hN[1]hF=hF+hN[2]hG=hG+hN[3]local hS=vec3(hE,hF,hG)hK.center=hS;if hK.lastPos then if(hK.lastPos-hS):len()<2 then local hT=(hS-vec3(hL)):len()if f5(hT-fo)<10 then hK.skipCalc=true end end end;hK.lastPos=hS end;hK.pts={}else local hU={hL[1]-hN[1],hL[2]-hN[2],hL[3]-hN[3]}hM[gt+1]={fo,hU}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gV then if#h1>0 then local hV,hW=0,0;local hX=cL*10;local cY=cY;gU,gT=0,0;gN={}for dX,dE in pairs(h1)do local cb=he(dE)if cb>0.0 then if ha(dE)then h3(gN,dE)end;if not cV and warpdrive and cb<a9 and warpdrive.getStatus()==15 then dq("INITIATING WARP")c4=7;warpdrive.initiate()end;local hY=F and hc(dE)if E or hY then local hZ=hf(dE)local h_=gO[hZ]local i0=hb(dE)if hY or cb<hX and(h_>27 or i0==4 or i0==6)then gU=gU+1;local hL={cO["x"],cO["y"],cO["z"]}local hK=h0[dE]if hK==nil then h_=h_+gL;h0[dE]={pts={},ref=hL,name=hd(dE),i=0,radius=h_,skipCalc=false}hK=h0[dE]end;if not hK.skipCalc then if hY or i0==4 or i0==6 then hK.center=vec3(hg(dE))hK.skipCalc=true else hJ(hK,cb,hL)hW=hW+1 end;if hY and not hK.abandoned then local bQ=a.getArkTime()if h2+5<bQ then h2=bQ;fR("abRdr","RD")end;a.print("Abandoned Construct: "..hK.name.." ("..hZ.." "..gP[i0]..") at ::pos{0,0,"..hK.center.x..","..hK.center.y..","..hK.center.z.."}")dq("Abandoned Radar Contact ("..hZ.." "..gP[i0]..") detected")hK.abandoned=true end else h3(gQ,hK)end end;hV=hV+1;if hV>300 or hW>30 then coroutine.yield()hV,hW=0,0 end end end end;gT=#gQ;if gT>0 and(cL>20 or b8)then local ez,i1,i2,i3;local i4=0;local i5=co:getPlanetarySystem(0)i3=cK:normalize()while i4<gT do coroutine.yield()local i6={table.unpack(gQ,i4,math.min(i4+75,gT))}ez,i1,i2=i5:castIntersections(cO,i3,nil,nil,i6,true)if ez and i2 then c_={ez,i1,i2}break end;i4=i4+75 end;if not ez then c_=nil end else c_=nil end;gQ={}gS=gV.getTargetId()end end end;local function i7()if gV then gX="Atmo"if string.find(gV.getName(),"Space")then gX="Space"end end end;function gM.pickType()i7()end;function gM.assignRadar()if radar_2 and h4~=1 then if h4==-1 then if gV==radar_2 then gV=radar_1 else gV=radar_2 end end;gW={gV}ha=gV.hasMatchingTransponder;hb=gV.getConstructKind;hc=gV.isConstructAbandoned;hd=gV.getConstructName;he=gV.getConstructDistance;hf=gV.getConstructCoreSize;hg=gV.getConstructWorldPos;h1=gV.getConstructIds()i7()else h1=gV.getConstructIds()end;h4=gV.getOperationalState()end;function gM.UpdateRadar()local i8=coroutine.status(gY)if i8=="suspended"then local dT,i9=coroutine.resume(gY)if i9 then a.print("ERROR UPDATE RADAR: "..i9)end elseif i8=="dead"then gY=coroutine.create(hj)local dT,i9=coroutine.resume(gY)end end;function gM.GetRadarHud(ia,ib,ax,ay)local ic,dq;local dK=gT or 0;gR=#h1;if gR>0 then if E then dq=dK.."/"..gU.." Known/InRange : "..gR.." Total"else dq="Radar Contacts: "..gR end;ic=gK(ax,ay,dq,"pbright txtbig txtmid")if#gN>0 then ic=ic..gK(ia,ib,"Friendlies In Range","pbright txtbig txtmid")for dS,dE in pairs(gN)do ib=ib+20;ic=ic..gK(ia,ib,gV.getConstructName(dE),"pdim txtmid")end end;local id=#gV.getIdentifiedConstructIds()if gZ==nil and id>0 then g_=1;cu.ToggleRadarPanel()end;if gZ~=nil and id==0 then cu.ToggleRadarPanel()end;if hi==nil then if w then cu.ToggleRadarPanel()end end else if h4~=1 then ic=gK(ax,ay,gX.." Radar: "..h5[h4],"pbright txtbig txtmid")else ic=gK(ax,ay,"Radar: No "..gX.." Contacts","pbright txtbig txtmid")end;if hi~=nil then g_=0;cu.ToggleRadarPanel()end end;return ic end;function gM.GetClosestName(gv)if gV then local ie=gV.getConstructName(gV.getConstructIds()[1])if ie then gv=gv.." "..ie end end;return gv end;function gM.ToggleRadarPanel()hh()end;function gM.ContactTick()if not ig then ig=0 end;if bQ>ig+10 then dq("Radar Contact")fR("rdrCon","RC")ig=bQ end;c.stopTimer("contact")end;function gM.onEnter(e1)if gV and not cg and not cV then c.setTimer("contact",0.1)end end;function gM.onLeave(e1)if gV and E then if#h0>650 then e1=tostring(e1)h0[e1]=nil end end end;local function ih()gV=nil;if radar_2 and radar_2.getOperationalState()then gV=radar_2 else gV=radar_1 end;h4=gV.getOperationalState()ha=gV.hasMatchingTransponder;hb=gV.getConstructKind;hc=gV.isConstructAbandoned;hd=gV.getConstructName;he=gV.getConstructDistance;hf=gV.getConstructCoreSize;hg=gV.getConstructWorldPos;gW={gV}h1=gV.getConstructIds()i7()gY=coroutine.create(hj)if ii then for dS,dE in pairs(ii)do gM[dS]=dE end end end;ih()return gM end;local function ij(shield,eb,bN,dq)local ik={}local il=shield.getResistancesCooldown()local function im()local io=shield.isActive()if G then if not cV and not io and not shield.isVenting()then shield.toggle()elseif cV and io then shield.toggle()end end end;local function ip()local iq=shield.getStressRatioRaw()local ir=0.5999;if iq[1]==0.0 and iq[2]==0.0 and iq[3]==0.0 and iq[4]==0.0 then return end;local is=shield.setResistances(ir*iq[1],ir*iq[2],ir*iq[3],ir*iq[4])if is then dq("Shield Resistances updated")else dq("Value Exceeded. Failed to update Shield Resistances")end end;function ik.shieldTick()dn=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())im()il=shield.getResistancesCooldown()if il==0 and dn<a8 then ip()end end;function ik.setResist(it)if not shield then dq("No shield found")return elseif it==nil or il>0 then dq("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dK=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dL=dK..', '..dK..', '..dK..', '..dK;local iu,iv,iw,ix=eb(it,dL)if ix==nil or iu+iv+iw+ix>0.6 then dq("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(iu,iv,iw,ix)then dq("Shield Resistances set")else dq("Resistance setting failed.")end end;function ik.ventShield()local iy=shield.getVentingCooldown()if iy>0 then dq("Cannot vent again for "..iy.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()dq("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else dq("Shields already at max hitpoints")end end;if iz then for dS,dE in pairs(iz)do ik[dS]=dE end end;return ik end;local function iA(d,b,c,a,e,antigrav,hover,shield,warpdrive,iB,f5,bN,ds,iC,bO,iD,iE,f0,bM,dt,iF,fQ,fP,gJ,iG,dv,fS,gK,fR,iH,iI,iJ,iK,iL,iM,dq)local bP=DUConstruct;local iN=9.80665;local iO={}local iP={}local iQ={}local iR={}local iS=nil;local iT=nil;local iU=nil;local iV=false;local iW="none"local iX=""local iY=55;local iZ=0;local i_=0;local j0=nil;local j1=af;local j2=ag;local j3=ah;local j4=[[rgb(]]..bN(j1+0.5)..","..bN(j2+0.5)..","..bN(j3+0.5)..[[)]]local j5=[[rgb(]]..bN(j1*0.9+0.5)..","..bN(j2*0.9+0.5)..","..bN(j3*0.9+0.5)..[[)]]local j6=0;local j7=0;local j8=""local j9=bM()local ja=false;local jb=false;local gV=false;local jc=""local jd=""local je=""local function jf(dE)if ac==1920 then return dE else return fS(ac*dE/1920,0)end end;local function jg(dE)if ad==1080 then return dE else return fS(ad*dE/1080,0)end end;local function jh()return not iG()and g~="keyboard"and not iE()end;local ic=""local ji=""local jj=""local function jk(jl,ea)if ap==0 and aq==0 then return end;if ea<200000 and not cg or ea and cg then local jm=0;if f5(cN)>1 then jm=45*math.log(f5(cN),10)if cN<0 then jm=-jm end end;jl[#jl+1]=ds([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bN(cN),bN(jm))end;return jl end;local function jn(jl,ea,cY)local jo=ar;local jp=as;if jo==0 and jp==0 then return end;local jq=78;local jr=19;local js=cf;if cf~=-1 then jl[#jl+1]=gK(jo+jq,jp+jr+20,ds("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(ea<200000 and not cg or ea and cg)then jl[#jl+1]=gK(jo+jq,jp-10,ds("%s",jt.name),"pdim altsm txtend")table.insert(jl,ds([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],jo-1,jp-4,jq+2,jr+6,jo+1,jp-1,jq-4,jr))local gt=0;local ju=1;local jv=0;local jw=ea<0;local jx=ea<jt.surfaceMaxAltitude;local jy=9;if jw then jy=0 end;local ea=f5(ea)while gt<6 do local jz=11;local jA=16;local jB=9;local jC=14;local jD="altsm"if gt>2 then jA=jA+3;jz=jz+2;jC=jC+2;jB=jB-6;jD="altbig"end;if jw then jD=jD.." red"elseif jx then jD=jD.." orange"end;local jE=ea/ju%10;local jF=bN(jE)local jG=bN((jF+1)%10)local jH=jv;if gt==0 then jH=jE-jF;if jw then jH=1-jH end end;if jw and(gt==0 or jv~=0)then local gw=jG;jG=jF;jF=gw end;local jI=jA*(jH-1)local jJ=jI+jA;local hE=jo+jB+(6-gt)*jz;local hF=jp+jC;jl[#jl+1]=gK(hE,hF+jI,jG,jD)jl[#jl+1]=gK(hE,hF+jJ,jF,jD)gt=gt+1;ju=ju*10;if jF==jy then jv=jH else jv=0 end end;table.insert(jl,[[</g></g>]])end end;local function jK(fs)local jL=-math.deg(f0(fs.y,fs.z))+180;jL=jL-90;if jL<0 then jL=360+jL end;if jL>180 then jL=-180+jL-180 end;return-jL end;local function jM(fs)local jN=math.deg(f0(fs.y,fs.x))-90;if jN<-180 then jN=360+jN end;return jN end;local function jO(jl,fs,jP,al,am)if jP>5 and not cg or jP>iY then local jQ=ae;local jR=20;local jS=20;local jT=jK(fs)local jU=jM(fs)local jV=14;local jW=jV/2;local jX=-jU/jS*jQ;local jY=jT/jR*jQ;local hE=al+jX;local hF=am+jY;local cb=dv(jX^2+jY^2)local jZ=[[<circle
                            cx="]]..hE..[["
                            cy="]]..hF..[["
                            r="]]..jW/jV..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hE..[["
                            cy="]]..hF..[["
                            r="]]..jW..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hE-jV..[[,]]..hF..[[ h ]]..jW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hE+jW..[[,]]..hF..[[ h ]]..jW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hE..[[,]]..hF-jV..[[ v ]]..jW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<jQ then jl[#jl+1]=jZ else local jm=f0(jY,jX)local j_=4;local k0=al+jQ*math.cos(jm)local k1=am+jQ*math.sin(jm)jl[#jl+1]=ds('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jm*180/math.pi,k0,k1,k0-j_,k1-j_/2,j_*2,j_,k0+j_,k1-j_,j_,j_,-j_,j_)end;if not cg then local k2=vec3(fs)jT=jK(-k2)jU=jM(-k2)jX=-jU/jS*jQ;jY=jT/jR*jQ;hE=al+jX;hF=am+jY;cb=dv(jX^2+jY^2)if cb<jQ then local k3=[[<circle
                                    cx="]]..hE..[["
                                    cy="]]..hF..[["
                                    r="]]..jW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hE..[[,]]..hF-jV..[[ v ]]..jW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hE..[[,]]..hF..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hE..[[,]]..hF..[[)" />
                                <path
                                    d="M ]]..hE-jW..[[,]]..hF..[[ h ]]..jV..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hE..[[,]]..hF..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hE..[[,]]..hF..[[)"/>]]jl[#jl+1]=k3 end end end end;local function k4(jl,je,k5,k6)if an==0 and ao==0 then return end;k5=bN(k5+0.5)local k7=ao+10;local k8=ao+20;if iE()and not m then k7=55;k8=65 end;local k9="CRUISE"local c="km/h"local dT=k6;if string.find(je,"TRAVEL")or string.find(je,"AUTOPILOT")then k9="THROT"c="%"dT=k5;local ka="dim"if k5<0 then ka="red"end;jl[#jl+1]=ds([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],ka,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-f5(k5),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;jl[#jl+1]=gK(an+10,k7,k9,"pbright txtstart")jl[#jl+1]=gK(an+10,k8,ds("%.0f %s",dT,c),"pbright txtstart")if cg and t and cR and bT then k5=bN(bU*100+0.5)local ka="red"if k5<0 then ka="red"end;jl[#jl+1]=ds([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],ka,1-f5(k5),an-10,ao+50,an-15,ao+53,an-15,ao+47)jl[#jl+1]=gK(an+10,k7+40,"LIMIT","pbright txtstart")jl[#jl+1]=gK(an+10,k8+40,k5 .."%","pbright txtstart")end;if cg and t or ba then jl[#jl+1]=gK(an+10,k7-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b5 then jl[#jl+1]=gK(an+10,k7-40,"LIMIT: "..bN(bI*3.6+0.5).." km/h","dim txtstart")end end;local function kb(jl,kc)if an==0 and ao==0 then return end;local kd=ao-10;local ke=an+10;jl[#jl+1]=gK(0,0,"","pdim txt txtend")if iE()and not m then kd=75 end;jl[#jl+1]=gK(ke,kd,bN(kc).." km/h","pbright txtbig txtstart")end;local kf=40;local function kg(jl)jl[#jl+1]=gK(jf(150),jg(1070),ds("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jl[#jl+1]=[[<g class="warnings">]]if c.isMouseControlActivated()then jl[#jl+1]=gK(jf(960),jg(550),"Warning: Invalid Control Scheme Detected","warnings")jl[#jl+1]=gK(jf(960),jg(600),"Keyboard Scheme must be selected","warnings")jl[#jl+1]=gK(jf(960),jg(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kh=jf(960)local ki=jg(860)local kj=jg(880)local kk=jg(900)local kl=jg(960)local km=jg(200)local kn=jg(250)local ko=jg(960)if iE()and not m then ki=jg(135)kj=jg(155)kk=jg(175)km=jg(115)kn=jg(95)end;if b2 then local kp=""if type(b2)=="string"then kp="-"..b2 end;jl[#jl+1]=gK(kh,ki,"Brake Engaged"..kp,"warnings")elseif bS>0 then jl[#jl+1]=gK(kh,ki,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b5 and not br and not b8 and not cQ and not bb and not b9 then jl[#jl+1]=gK(kh,km+50,"** STALL WARNING **","warnings")fR("stall","SW",2)end end;if cX then jl[#jl+1]=gK(kh,km+90,"Flight Assist in Progress","warnings")end;if ck then jl[#jl+1]=gK(kh,ko,"Gyro Enabled","warnings")end;if kq then kf=kf-1;if kf>20 then jl[#jl+1]=gK(kh,ko-20,"ECU Enabled","warnings")elseif kf<0 then kf=40 end end;if bn then if bW then jl[#jl+1]=gK(kh,kj,"Gear Extended","warn")else jl[#jl+1]=gK(kh,kj,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local kr=iJ(d:getTargetGroundAltitude())jl[#jl+1]=gK(kh,kk,"Hover Height: "..kr,"warn")end;if c5 then jl[#jl+1]=gK(kh,kl+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cQ and bw~=nil then local ks="warnings"if f5(ci-antigrav.getBaseAltitude())<501 then ks="warn"end;jl[#jl+1]=gK(kh,km+40,ds("Target Altitude: %d Singularity Altitude: %d",bN(bw),bN(antigrav.getBaseAltitude())),ks)end;if b5 and bk~="None"then jl[#jl+1]=gK(kh,km,"Autopilot "..bi,"warn")elseif bu~=nil then jl[#jl+1]=gK(kh,km+20,ds("LockedPitch: %d",bN(bu)),"warn")elseif c0 then jl[#jl+1]=gK(kh,km+20,"Follow Mode Engaged","warn")elseif ba or ce then jl[#jl+1]=gK(kh,km+20,"Re-entry in Progress","warn")end;if b7 or bb then local kr=iJ(bc,2)if bb then if cQ then kr=iJ(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jl[#jl+1]=gK(kh,km,"VTO to "..kr,"warn")elseif(b9 or cd)and not bA then if cd then jl[#jl+1]=gK(kh,km,"Takeoff to "..bk,"warn")else jl[#jl+1]=gK(kh,km,"Takeoff to "..kr,"warn")end;if b2 and not bb then jl[#jl+1]=gK(kh,km+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jl[#jl+1]=gK(kh,km,"Altitude Hold: "..ds("%.1fm",bc),"warn")end end;if bb and(antigrav~=nil and antigrav)then if ch>0.1 then jl[#jl+1]=gK(kh,km+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then jl[#jl+1]=gK(kh,km+20,"Aligning trajectory","warn")elseif ch<0.05 then jl[#jl+1]=gK(kh,km+20,"Leaving atmosphere","warn")end end;if bA then if cC~=nil then jl[#jl+1]=gK(kh,km,cC,"warn")end end;if b8 then local kt="Brake Landing"if dc then kt=kt.."-Aligning"end;if db then kt=kt.."-Drift Limited"end;jl[#jl+1]=gK(kh,km,kt,"warnings")end;if b4 then jl[#jl+1]=gK(kh,km+20,"Prograde Alignment","crit")end;if b3 then jl[#jl+1]=gK(kh,km,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;jl[#jl+1]=gK(kh,kn+20,cZ,type)elseif ch==0 and not b5 then local ku,kv=ct.checkLOS(cK:normalize())if kv~=nil and cL>0 then local kr=iJ(kv)local kw=cp.computeTravelTime(cL,0,kv)local kx="Collision"if ku.noAtmosphericDensityAltitude>0 then kx="Atmosphere"end;jl[#jl+1]=gK(kh,kn+20,ku.name.." "..kx.." "..iK(kw).." In "..kr,"crit")end end;if br and not bA then jl[#jl+1]=gK(kh,km+60,ky,"warn")end;if w and I then jl[#jl+1]=jd end;return jl end;local function kz(jP)return bN(fS(jP*3.6,0)+0.5).." km/h"end;local function kA(gt)local gv=bk;if gt~=nil and type(gt)=="number"then if gt==0 then return"None"end;gv=cU[gt].name end;if gv==nil then gv=g2.name end;if gv==nil then gv="None"end;return gv end;local function kB(jl)local kC=ct.routeWP(true)if not kC or#kC==0 then return end;local hE=jf(960)local hF=jg(360)if b5 or br then jl[#jl+1]=gK(hE,hF,"REMAINING ROUTE","pdim txtmid size20")else jl[#jl+1]=gK(hE,hF,"LOADED ROUTE","pdim txtmid size20")end;for dS,M in pairs(kC)do hF=hF+20;jl[#jl+1]=gK(hE,hF,dS..". "..kC[dS],"pdim txtmid size20")end end;local function kD(jl)local kE=aB;local kF=aC;local kG=aA;local kH=4;local kI=15;local hE=0;local hF=0;local kJ,kK,kL,kM;local kN;local function kO(type)local gF,bQ,jP,kP,jD,kQ;if type=="Periapsis"then gF=kN.periapsis.altitude;bQ=kN.timeToPeriapsis;jP=kN.periapsis.speed;jD="txtend"kP=12;kQ=math.min(hE,kE+kG-jt.radius/kL-kH*2)else gF=kN.apoapsis.altitude;bQ=kN.timeToApoapsis;jP=kN.apoapsis.speed;kP=-12;jD="txtstart"kQ=hE end;if cL<1 then bQ=0 end;jl[#jl+1]=ds([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],kQ+kP,hF-5,hE,hF-5)jl[#jl+1]=ds([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],kQ-kP*4,hF+2,hE,hF+2)jl[#jl+1]=gK(kQ,hF,type,jD)hE=kQ-kP*2;hF=hF+kI;local kr=iJ(gF)jl[#jl+1]=gK(hE,hF,kr,jD)hF=hF+kI;jl[#jl+1]=gK(hE,hF,iK(bQ),jD)hF=hF+kI;jl[#jl+1]=gK(hE,hF,kz(jP),jD)end;local kR=kG*1.5;if bK=="INFO"then kR=25*10 end;if bK=="ORBIT"and ci<jt.spaceEngineMinAltitude then return jl end;if bK~="HIDE"then jl[#jl+1]=[[<g class="pbright txtorb txtmid">]]jl[#jl+1]=ds('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',kG*2,kR,kE,kF)jl[#jl+1]=ds([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],kG*2,kR,kE,kF)end;local kS=kG*1.5;local kT=kG*2;local kU=kS/2;local kV=kG;local kW=kE+kV;local kX=kF+kU;local kY=kE+kT;local kZ=kF+kS;if bK=="ORBIT"then kF=kF+kH;kJ=kG/2;kM=0;kN={}kN.periapsis={}kN.apoapsis={}if fr~=nil then if fr.periapsis~=nil then kN.periapsis.altitude=fr.periapsis.altitude;kN.periapsis.speed=fr.periapsis.speed end;if fr.apoapsis~=nil then kN.apoapsis.altitude=fr.apoapsis.altitude;kN.apoapsis.speed=fr.apoapsis.speed end;kN.period=fr.period;kN.eccentricity=fr.eccentricity;kN.timeToApoapsis=fr.timeToApoapsis;kN.timeToPeriapsis=fr.timeToPeriapsis;kN.eccentricAnomaly=fr.eccentricAnomaly;kN.trueAnomaly=fr.trueAnomaly end;if kN.periapsis==nil then kN.periapsis={}kN.periapsis.altitude=-jt.radius;kN.periapsis.speed=bI end;if kN.eccentricity==nil then kN.eccentricity=1 end;if kN.apoapsis==nil then kN.apoapsis={}kN.apoapsis.altitude=ci;kN.apoapsis.speed=0 end;if cL<1 then kN.apoapsis.altitude=ci;kN.apoapsis.speed=0 end;if kN.apoapsis.altitude then kL=(kN.apoapsis.altitude+kN.periapsis.altitude+jt.radius*2)/(kJ*2)kK=(jt.radius+kN.apoapsis.altitude)/kL*(1-kN.eccentricity)kM=kJ-kN.periapsis.altitude/kL-jt.radius/kL;local k_=math.pi;if kN.period~=nil and kN.period>0 and kN.timeToApoapsis~=nil then k_=kN.eccentricAnomaly;if kN.timeToPeriapsis<kN.timeToApoapsis then k_=2*math.pi-k_ end end;if cL<1 or k_~=k_ then k_=math.pi end;local l0=-kJ*math.cos(k_)+kE+kV+kH;local l1=kK*math.sin(k_)+kF+kU+kH;local l2=""jl[#jl+1]='<g clip-path="url(#orbitRect)">'jl[#jl+1]=ds([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],l2,kE+kG+kH,kF+kG*1.5/2+kH,kJ,kK)if kK<1 then jl[#jl+1]=ds([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],kE+kG+kH-kM,kF+kG*1.5/2+kH,l0,l1)end;jl[#jl+1]=ds('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',kE+kG+kH-kM,kF+kG*1.5/2+kH,(jt.radius+jt.noAtmosphericDensityAltitude)/kL)jl[#jl+1]=ds('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',kE+kG+kH-kM,kF+kG*1.5/2+kH,(jt.radius+jt.noAtmosphericDensityAltitude)/kL)jl[#jl+1]=ds([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",kE+kG+kH,kF+kG*1.5/2+kH,kJ,kK)jl[#jl+1]=ds('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',kE+kG+kH-kM,kF+kG*1.5/2+kH,jt.radius/kL)jl[#jl+1]='</g>'local l3=math.floor(jt.radius/kL+0.5)hE=kE+kG+kH*4+kJ;hF=kF+kG*1.5/2+5+kH;if kN.apoapsis~=nil and kN.apoapsis.speed<bI then kO("Apoapsis")end;hF=kF+kG*1.5/2+5+kH;hE=kE+kG-kH*2-kJ;if kN.periapsis~=nil and kN.periapsis.speed<bI and kN.periapsis.altitude>0 then kO("Periapsis")end;jl[#jl+1]=gK(kE+kG+kH,kF+20+kH,jt.name,"txtorbbig")jl[#jl+1]=ds('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',l0,l1)jl[#jl+1]=[[</g>]]return jl else jl[#jl+1]='<g clip-path="url(#orbitRect)">'local l4=""local l5=1.2*(l6-l7)/(kG*2)local l8=1.4*(l9-la)/(kG*1.5)for dS,dE in pairs(e[0])do if dE.center then local hE=kE+kG+dE.center.x/l5;local hF=kF+kG*1.5/2+dE.center.y/l8;l4=l4 ..'<circle cx="'..hE..'" cy="'..hF..'" r="'..dE.radius/l5*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dE.name,"Moon")and not string.match(dE.name,"Sanctuary")and not string.match(dE.name,"Space")then l4=l4 .."<text x='"..hE.."' y='"..hF+dE.radius/l5*30+20 .."' font-size='12' fill="..j4 .." text-anchor='middle' font-family='Montserrat'>"..dE.name.."</text>"end end end;local ft=vec3(bP.getWorldPosition())local hE=kE+kG+ft.x/l5;local hF=kF+kG*1.5/2+ft.y/l8;l4=l4 ..'<circle cx="'..hE..'" cy="'..hF..'" r="2" stroke="white" stroke-width="1" fill="red"/>'l4=l4 .."<text x='"..hE.."' y='"..hF-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iS=l5;iT=l8;local lb=ft+cK*1000000;local lc=kE+kG+lb.x/l5;local k8=kF+kG*1.5/2+lb.y/l8;l4=l4 ..'<line x1="'..hE..'" y1="'..hF..'" x2="'..lc..'" y2="'..k8 ..'" stroke="purple" stroke-width="1"/>'jl[#jl+1]=l4;jl[#jl+1]='</g>'end elseif bK=="INFO"then jl[#jl+1]=jc elseif bK=="SCOPE"then jl[#jl+1]='<g clip-path="url(#orbitRect)">'local ld=d5;local le=vec3(DUSystem.getCameraWorldPos())local lf=vec3(DUSystem.getCameraWorldRight())local lg=vec3(DUSystem.getCameraWorldForward())if iG()then le=cO;lf=cI;lg=cH end;if ch>0 then table.sort(d4,function(eH,eI)local eJ,eK=eH.center,eI.center;return(eJ.x-le.x)^2+(eJ.y-le.y)^2+(eJ.z-le.z)^2<(eK.x-le.x)^2+(eK.y-le.y)^2+(eK.z-le.z)^2 end)end;local lh={}local li={}local lj=120;local lk=nil;local ll=nil;for M,dE in ipairs(d4)do local gS=dE.center-le;local lm=gS:len()local ln=gS:normalize()local lo=gS:cross(lg):normalize()local lp=math.acos(lo:dot(lf))if lp~=lp then lp=0 end;if lo:cross(lf):dot(lg)<0 then lp=-lp end;local lq=gS:project_on_plane(lg):len()local lr=math.sin(lp)*math.asin(lq/lm)*constants.rad2deg;local ls=math.cos(lp)*math.asin(lq/lm)*constants.rad2deg;if ln:dot(lg)<0 then ls=90*math.cos(lp)+90*math.cos(lp)-ls;lr=90*math.sin(lp)+90*math.sin(lp)-lr end;local hE=kW+lr/ld*kS;local hF=kX+ls/ld*kS;local lt=(hE-kW)*(hE-kW)+(hF-kX)*(hF-kX)local lu=math.asin((dE.radius+dE.surfaceMaxAltitude)/lm)*constants.rad2deg;if lu~=lu then lu=ld end;local hZ=lu/ld*kS;local lv=math.asin(dE.atmosphereRadius/lm)*constants.rad2deg;if lv~=lv then lv=lu end;local lw=lv/ld*kS;local cb=iJ(lm,1)local lx=dE.name;local ly=false;if hF>kF then if hF>kZ then if hF-lw<=kZ then ly=true end else ly=true end else if hF+lw>=kF then ly=true end end;local lz=false;local lA=hE;if dE.systemId==0 then lA=hE+lj else lA=hE-lj end;if lA+lj>kE then if lA+lj>kY then if lA-lw-lj<=kY then lz=true end else lz=true end else if lA+lw+lj>=kE then lz=true end end;local lB={}lB.x=hE;lB.y=hF;lB.planet=dE;lB.atmoSize=lw;if not lk or lt<lk then lk=lt;ll=lB end;if lz and ly then local lC=math.max(lw,5)if lt<lC*lC then lx=lx.." - "..cb end;lB.size=hZ;lB.i=M;lB.displayString=lx;lB.distance=cb;lB.visible=true;li[#li+1]=lB else lB.visible=false end end;local lD=false;table.sort(li,function(eJ,eK)return eJ.y<eK.y end)for dS,fo in ipairs(li)do local dE,hZ,M,lw,hE,hF,lx,cb=fo.planet,fo.size,fo.i,fo.atmoSize,fo.x,fo.y,fo.displayString,fo.distance;local kQ,lE,lF,lG;local lH=15;local jD="pdim"if dE.systemId~=0 then lF=jf(string.len(lx)*5)lH=-(15+lF)lG=jg(10)jD="pdimfill"else lF=jf(string.len(lx)*9)lG=jg(15)end;if hZ*2>lF then kQ=dt(hE,kE+lF/2,kY-lF/2)lE=dt(hF,kF+lG,kZ-5)kQ=dt(kQ,hE-hZ+lF/2,hE+hZ-lF/2)lE=dt(lE,hF-hZ+lG,hF+hZ)else kQ=hE+lH;lE=hF end;for lI,fo in pairs(lh)do local lJ=fo.textPositions;local lK=lJ.y-lE;if lI~=M and f5(lK)<lJ.height and lJ.x+lJ.width>kQ and lJ.x<kQ+lF then if hZ>lF then lE=dt(lE+lG,kF+15,kZ-5)else lE=lJ.y+lJ.height+1 end end end;local lL=lx~=dE.name or kQ<=kW and kQ+lF>=kW and lE-lG<=kX and lE>=kX;fo.hovered=lL;local lM=1;if lL then lM=2;if hZ*2<lF then lM=10 end;if lx==dE.name then lx=lx.." - "..cb end;jD="pbright"if dE.systemId~=0 then lF=jf(string.len(lx)*5)lH=-(15+lF)else lF=jf(string.len(lx)*7)end;if hZ*2>lF then kQ=dt(hE,kE+lF/2,kY-lF/2)kQ=dt(kQ,hE-hZ+lF/2,hE+hZ-lF/2)else kQ=hE+lH end end;lh[M]={}lh[M].textPositions={}lh[M].textPositions.y=lE;lh[M].textPositions.x=kQ;lh[M].textPositions.width=lF;lh[M].textPositions.height=lG;lh[M].output=""if hZ*2>lF then jD=jD.." txtmid"else jD=jD.." txtstart"end;if lw-hZ>2 then lh[M].output=ds('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hE,hF,lw,j5,0.1*lM)end;lh[M].output=lh[M].output..ds('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hE,hF,hZ,j5,0.2*lM)if dE.systemId==0 then lh[M].output=lh[M].output..ds([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],kQ,lE,j4,jD,lx)if hZ*2<=lF then lh[M].output=lh[M].output..ds("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",kQ+lF,lE+2,kQ,lE+2,hE,hF)end else lh[M].output=lh[M].output..ds([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],kQ,lE,j5,jD,lx)if hZ*2<=lF then lh[M].output=lh[M].output..ds("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",kQ,lE+2,kQ+lF,lE+2,hE,hF)end end end;for dS=#d4,1,-1 do if lh[dS]then jl[#jl+1]=lh[dS].output end end;if ll~=nil and d5<90 and not ll.hovered then local lN=ll.planet.atmosphereRadius/ll.atmoSize;local lO=dv(lk)*lN;local lP=iJ(lO,1)local lF=jf(math.max(string.len(lP)*7,string.len(ll.planet.name)*7))local lG=jg(12)local kQ=dt(ll.x+(kW-ll.x)/2,kE+lF/2,kY-lF/2)local lE=dt(ll.y+(kX-ll.y)/2,kF+lG*2,kZ-5)jl[#jl+1]=ds("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",ll.x,ll.y,kW,kX)jl[#jl+1]=ds([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],kQ,lE,"white",lP)if not ll.visible then jl[#jl+1]=ds([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],kQ,lE-lG,"white",ll.planet.name)end end;if cL>1 then local gS=cK;local ln=gS:normalize()local lq=gS:project_on_plane(lg):len()local lo=gS:cross(lg):normalize()local lp=math.acos(lo:dot(lf))if lp~=lp then lp=0 end;if lo:cross(lf):dot(lg)<0 then lp=-lp end;local lr=math.sin(lp)*math.asin(lq/gS:len())*constants.rad2deg;local ls=math.cos(lp)*math.asin(lq/gS:len())*constants.rad2deg;if ln:dot(lg)<0 then ls=90*math.cos(lp)+90*math.cos(lp)-ls;lr=90*math.sin(lp)+90*math.sin(lp)-lr end;local hE=kW+lr/ld*kS;local hF=kX+ls/ld*kS;local jV=14;local jW=jV/2;local jZ=[[<circle
                                    cx="]]..hE..[["
                                    cy="]]..hF..[["
                                    r="]]..jW/jV..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hE..[["
                                    cy="]]..hF..[["
                                    r="]]..jW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hE-jV..[[,]]..hF..[[ h ]]..jW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hE+jW..[[,]]..hF..[[ h ]]..jW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hE..[[,]]..hF-jV..[[ v ]]..jW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jl[#jl+1]=jZ end;jl[#jl+1]=ds("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",kW,kX-10,kW,kX+10)jl[#jl+1]=ds("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",kW-10,kX,kW+10,kX)jl[#jl+1]='</g>'else return jl end end;local function lQ(hE,hF,lR,lS,k9)local lT={x=hE,y=hF,width=lR,height=lS,label=k9}iR[k9]=lT;return lT end;local function lU(lV,lW,lR,lS,hE,hF,lX,lY,lZ,l_,jD)local lT={enableName=lV,disableName=lW,width=lR,height=lS,x=hE,y=hF,toggleVar=lX,toggleFunction=lY,drawCondition=lZ,hovered=false,class=jD}if l_ then table.insert(iQ,lT)else table.insert(iP,lT)end;return lT end;local function m0(m1)if not iV then m2=false;m3=false;m4=false;w=true;return elseif m1=="handling"then m2=not m2;m3=false;m4=false elseif m1=="hud"then m3=not m3;m2=false;m4=false elseif m1=="physics"then m4=not m4;m2=false;m3=false end;if m4 or m3 or m2 then iW=iI(m1)w=false else iW="none"w=true end end;local function m5()iV=not iV;if iV then iO=iQ;dq("Tap LMB to see Settings")d6=w else iO=iP;dq("Tap LMB to see Control Buttons")m0()w=d6 end end;local function m6()local function m7(dE,dS)dE.set(not dE.get())if dE.get()then dq(dS.." set to true")else dq(dS.." set to false")end;if dS=="showHud"then d6=dE.get()elseif dS=="BrakeToggleDefault"then b0=k end end;local m8=50;local m9=340;local hE=ac/2-530;local hF=ad/2-330+m8/2;local ma=0;for dS,dE in pairs(iI("boolean"))do if type(dE.get())=="boolean"then lU(dS,dS,m9,m8,hE,hF,function()return dE.get()end,function()m7(dE,dS)end,function()return true end,true)hF=hF+m8+20;if ma==9 then hE=hE+m9+20;hF=ad/2-330+m8/2;ma=0 else if hE>ac/2-m9 and hE<ac/2+m9/2 and hF>ad/2-m8 and hF<ad/2+m8 then hF=hF+m8+20;ma=ma+1 end;ma=ma+1 end end end;lU("Control View","Control View",m9,m8,10,ad/2-500,function()return true end,m5,function()return true end,true)lU("View Handling Settings",'Hide Handling Settings',m9,m8,10,ad/2-(500-m8),function()return m2 end,function()m0("handling")end,function()return true end,true)lU("View Hud Settings",'Hide Hud Settings',m9,m8,10,ad/2-(500-m8*2),function()return m3 end,function()m0("hud")end,function()return true end,true)lU("View Physics Settings",'Hide Physics Settings',m9,m8,10,ad/2-(500-m8*3),function()return m4 end,function()m0("physics")end,function()return true end,true)end;local function mb()local function gu()local fU=cO;local gv=jt.name..". "..#bq;if cu then gv=cu.GetClosestName(gv)end;return cs.AddNewLocation(gv,fU,false,true)end;local function mc()b6=not b6 end;local function md(me)if me==1 then b4=not b4;b3=false else b3=not b3;b4=false end;b5=false;b7=false;c0=false;b8=false;bu=nil;ba=false;b9=false end;local function mf(mg,mh)cs.UpdatePosition(nil,mg,mh)end;local function gp()cs.ClearCurrentPosition()end;local function mi(gt)local kC=ct.routeWP(true)if kC and#kC>0 then return"Engage Route: "..kC[1]end;return"Engage Autopilot: "..kA(gt)end;local function mj(gt)local kC=ct.routeWP(true)if kC and#kC>0 then return"Next Route Point: "..kC[1]end;return"Disable Autopilot: "..kA(gt)end;local function mk()if iE()then c0=not c0;if c0 then b5=false;b3=false;b4=false;b7=false;ba=false;b8=false;b9=false;ml=bn;bn=false;d.control.retractLandingGears()iF:setTargetGroundAltitude(Y)fR("folOn","F")else fR("folOff","F")b2="Follow Off"cz=q;bn=ml;if bn then d.control.deployLandingGears()iF:setTargetGroundAltitude(Z)end end else dq("Follow Mode only works with Remote controller")c0=false end end;local m8=50;local m9=260;local mm=jf(30)local mn=aB+aA*2+2;local mo=aC+1;lU("+","+",mm,mm,mn,mo+mm+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")lU("-","-",mm,mm,mn,mo,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")lU("0","0",mm,mm,mn,mo+mm*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local mp=lU("Enable Brake Toggle","Disable Brake Toggle",m9,m8,ac/2-m9/2,ad/2+350,function()return b0 end,function()b0=not b0;if b0 then dq("Brakes in Toggle Mode")else dq("Brakes in Default Mode")end end)lU("Align Prograde","Disable Prograde",m9,m8,ac/2-m9/2-50-mp.width,ad/2-m8+380,function()return b4 end,function()md(1)end)lU("Align Retrograde","Disable Retrograde",m9,m8,ac/2-m9/2+mp.width+50,ad/2-m8+380,function()return b3 end,md,function()return ch==0 end)mq=lU(mi,mj,600,60,ac/2-600/2,ad/2-60/2-330,function()return b5 or br or cd or bA end,function()end)local M;local function mr(ms)local gt=d1+ms;if gt>#cU then gt=gt-#cU-1 end;if gt<0 then gt=#cU+gt end;return gt end;mt={}for M=0,10 do local mu=lU(function(eK)local gt=mr(eK.apExtraIndex)if b5 or br or cd or bA then return"Redirect: "..kA(gt)end;return mi(gt)end,function(eK)local gt=mr(eK.apExtraIndex)return mj(gt)end,600,60,ac/2-600/2,ad/2-60/2-330+60*M,function(eK)local gt=mr(eK.apExtraIndex)return gt==bm and(b5 or br or cd or bA)end,function(eK)local gt=mr(eK.apExtraIndex)local mv=bm==gt;bm=gt;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not mv and not(b5 or br or cd or bA)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)mu.apExtraIndex=M;mt[M]=mu end;lU("Save Position","Save Position",200,mq.height,mq.x+mq.width+30,mq.y,function()return false end,gu,function()return bm==0 or g2==nil end)lU("Update Position","Update Position",200,mq.height,mq.x+mq.width+30,mq.y,function()return false end,function()mf(nil)end,function()return bm>0 and g2~=nil end)lU("Save Heading","Clear Heading",200,mq.height,mq.x+mq.width+30,mq.y+mq.height+20,function()return g2.heading~=nil end,function()if g2.heading~=nil then mf(false)else mf(true)end end,function()return bm>0 and g2~=nil end)lU("Save AGG Alt","Clear AGG Alt",200,mq.height,mq.x+mq.width+30,mq.y+mq.height*2+40,function()return g2.agg~=nil end,function()if g2.agg~=nil then mf(nil,false)else mf(nil,true)end end,function()return bm>0 and g2~=nil and antigrav end)lU("Clear Position","Clear Position",200,mq.height,mq.x-200-30,mq.y,function()return true end,gp,function()return bm>0 and g2~=nil end)lU("Save Route","Save Route",200,mq.height,mq.x-200-30,mq.y+mq.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)lU("Load Route","Clear Route",200,mq.height,mq.x-200-30,mq.y+mq.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b5 or br then dq("Disable Autopilot before loading route")return else ct.routeWP(false,false,1)end end,function()return true end)m8=60;m9=300;local hE=0;local hF=ad/2-150;lU("Enable Check Damage","Disable Check Damage",m9,m8,hE,hF-m8-20,function()return s end,function()s=not s end)lU("View Settings","View Settings",m9,m8,hE,hF,function()return true end,m5)hF=hF+m8+20;lU("Enable Turn and Burn","Disable Turn and Burn",m9,m8,hE,hF,function()return b6 end,mc)hE=10;hF=ad/2-300;lU("Horizontal Takeoff Mode","Vertical Takeoff Mode",m9,m8,ac/2-m9/2,hF+20,function()return b1 end,function()b1=not b1;if b1 then dq("Vertical Takeoff Mode")else dq("Horizontal Takeoff Mode")end end,function()return cP end)hF=hF+m8+20;lU("Engage Orbiting","Cancel Orbiting",m9,m8,hE+m9+20,hF,function()return bA end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hF=ad/2-150;lU("Glide Re-Entry","Cancel Glide Re-Entry",m9,m8,hE+m9+20,hF,function()return ba end,function()cc=1;md(1)end,function()return jt.hasAtmosphere and not cg end)hF=hF+m8+20;lU("Parachute Re-Entry","Cancel Parachute Re-Entry",m9,m8,hE+m9+20,hF,function()return ba end,function()cc=2;md(1)end,function()return jt.hasAtmosphere and not cg end)hF=hF+m8+20;lU("Engage Follow Mode","Disable Follow Mode",m9,m8,hE,hF,function()return c0 end,mk,function()return iE()end)lU("Enable Repair Arrows","Disable Repair Arrows",m9,m8,hE+m9+20,hF,function()return ja end,function()ja=not ja;if ja then dq("Repair Arrows Enabled")else dq("Repair Arrows Diabled")end end,function()return iE()end)hF=hF+m8+20;if not r then lU("Enable AGG","Disable AGG",m9,m8,hE,hF,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;lU(function()return ds("Switch IPH Mode - Current: %s",bB)end,function()return ds("IPH Mode: %s",bB)end,m9*2,m8,hE,hF,function()return false end,function()if bB=="All"then bB="Custom Only"elseif bB=="Custom Only"then bB="No Moons-Asteroids"else bB="All"end;dq("IPH Mode: "..bB)end)hF=hF+m8+20;lU(function()return ds("Toggle Control Scheme - Current: %s",g)end,function()return ds("Control Scheme: %s",g)end,m9*2,m8,hE,hF,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;dq("New Control Scheme: "..g)end)local mw=jg(20)local mu=lQ(0,0,jf(80),mw,"INFO")mu=lQ(mu.x+mu.width,mu.y,jf(70),mw,"ORBIT")mu=lQ(mu.x+mu.width,mu.y,jf(70),mw,"SCOPE")lQ(mu.x+mu.width,mu.y,jf(70),mw,"HIDE")end;local function mx(jl,kr)if kr~="empty"then local hF=310;for kt in string.gmatch(kr,"([^\n]+)")do hF=hF+35;jl[#jl+1]=gK("50%",hF,kt,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;local my={}local mz=nil;local function mA(jl)local jL=cS;local mB=cT;local mC=mB;local mD=jL;local k5=bN(c.getThrottle())local kc=cL*3.6;local k6=c.getAxisCommandValue(0)local function mE(jl,mD,mC,al,am,cY,mF,jP)if ae==0 then return end;local jQ=ae;local mG=bN(jQ*3/5)if jQ>0 then local mH=bN(mD)local mI=0;local mJ=ds([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*mC,al,am)if not cg then mJ=ds([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;jl[#jl+1]=ds([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jQ-1,al,am)jl[#jl+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(mH-30-mH%5+0.5),bN(mH+30+mH%5+0.5),5 do if M%10==0 then mI=30 elseif M%5==0 then mI=20 end;local hF=am+-M*5+mD*5;if mI==30 then mJ=ds([[%s M %d %f h %d]],mJ,al-mG-mI,hF,mI)if cg then jl[#jl+1]=ds([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*mC,al,am,al-mG+10,hF+4,M)jl[#jl+1]=ds([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*mC,al,am,al+mG-10,hF+4,M)if M==0 or M==180 or M==-180 then jl[#jl+1]=ds([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*mC,al,am,al-mG+20,hF,mG*2-40)end else jl[#jl+1]=gK(al-mG+10,hF,M,"pdim txt txtmid")jl[#jl+1]=gK(al+mG-10,hF,M,"pdim txt txtmid")end;mJ=ds([[%s M %d %f h %d]],mJ,al+mG,hF,mI)else mJ=ds([[%s M %d %f h %d]],mJ,al-mG-mI,hF,mI)mJ=ds([[%s M %d %f h %d]],mJ,al+mG,hF,mI)end end;jl[#jl+1]=mJ..[["/>]]local mK="PITCH"if not cY then mK="REL PITCH"end;if mD>90 and not cg then mD=90-(mD-90)elseif mD<-90 and not cg then mD=-90-(mD+90)end;if jQ>200 then if cg then if jP>iY then jl[#jl+1]=gK(al,am-15,"Yaw","pdim txt txtmid")jl[#jl+1]=gK(al,am+20,mF,"pdim txt txtmid")end;jl[#jl+1]=ds([[<g transform="rotate(%f,%d,%d)">]],-mC,al,am)else jl[#jl+1]=ds([[<g transform="rotate(0,%d,%d)">]],al,am)end;jl[#jl+1]=ds([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-mG+25,am-5,al-mG+20,am,al-mG+25,am+5,al-mG+50,am+4,mH)jl[#jl+1]=ds([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+mG-25,am-5,al+mG-20,am,al+mG-25,am+5,al+mG-30,am+4,mH)jl[#jl+1]="</g>"end;local mL=bN(jQ/3)jl[#jl+1]=ds([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-mL,am,jQ-mL)if not cg and cY then jl[#jl+1]=ds([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*mC,al,am,al-mG+10,am,mG*2-20)end;jl[#jl+1]="</g>"if jQ<200 then if cg and jP>iY then jl[#jl+1]=gK(al,am-jQ,mK,"pdim txt txtmid")jl[#jl+1]=gK(al,am-jQ+10,mH,"pdim txt txtmid")jl[#jl+1]=gK(al,am-15,"Yaw","pdim txt txtmid")jl[#jl+1]=gK(al,am+20,mF,"pdim txt txtmid")else jl[#jl+1]=gK(al,am-jQ,mK,"pdim txt txtmid")jl[#jl+1]=gK(al,am-jQ+15,mH,"pdim txt txtmid")end end end end;local function mM(jl,al,am,mC,mN,cY)local function mO(mP)local go=-cM;mP=mP-mP:project_on(go)local mQ=vec3(0,0,1)mQ=mQ-mQ:project_on(go)local mR=mQ:cross(go)local jm=mQ:angle_between(mP)*constants.rad2deg;if mP:dot(mR)<0 then jm=360-jm end;return jm end;if ae==0 then return end;local jQ=ae;local mS=20;local mT=bN(mC)if cY then for M=-45,45,5 do local mU=M;jl[#jl+1]=ds([[<g transform="rotate(%f,%d,%d)">]],mU,al,am)mI=5;if M%15==0 then mI=15 elseif M%10==0 then mI=10 end;jl[#jl+1]=ds([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+jQ+mS-mI,al,am+jQ+mS)end;jl[#jl+1]=gK(al,am+jQ+mS-35,mN,"pdim txt txtmid")jl[#jl+1]=gK(al,am+jQ+mS-25,mT.." deg","pdim txt txtmid")jl[#jl+1]=ds([[<g transform="rotate(%f,%d,%d)">]],-mC,al,am)jl[#jl+1]=ds([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+jQ+mS-20,al+5,am+jQ+mS-20,al,am+jQ+mS-15)jl[#jl+1]="</g>"end;jl[#jl+1]=[[<g style="clip-path: url(#headingClip);">]]local jN=mT;if cY then jN=mO(cH)end;local mV=20;local mW=bN(jN)local mX=0;local mY=am+jQ+mS+20;local mZ=al;if mN~="YAW"then mY=jg(130)mZ=jf(960)end;local mJ=[[<path class="txttick line" d="]]local m_=bN(mW-(mV+10)-mW%5+0.5)for M=m_+70,m_,-5 do local hE=mZ-(-M*5+jN*5)if M%10==0 then mX=10;local dK=M;if dK==360 then dK=0 elseif dK>360 then dK=dK-360 elseif dK<0 then dK=dK+360 end;jl[#jl+1]=gK(hE,mY+15,dK,"txtmid bright")elseif M%5==0 then mX=5 end;if mX==10 then mJ=ds([[%s M %f %f v %d]],mJ,hE,mY-5,mX)else mJ=ds([[%s M %f %f v %d]],mJ,hE,mY-2.5,mX)end end;jl[#jl+1]=mJ..[["/>]]jl[#jl+1]=ds([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],mZ-5,mY-20,mZ+5,mY-20,mZ,mY-10)if cY then mN="HDG"end;jl[#jl+1]=gK(jf(960),jg(100),mW.."°","dim txt txtmid size14","")jl[#jl+1]=gK(jf(960),jg(85),mN,"dim txt txtmid size20","")jl[#jl+1]=[[</g>]]end;if t and cR then k6=bR;k5=bR*100 end;local mN="ROLL"if k5==nil then k5=0 end;if not cY then if cL>5 then jL=jK(cJ)mB=jM(cJ)else jL=0;mB=0 end;mN="YAW"end;jl[#jl+1]=j8;jl[#jl+1]=ic;if iX~=""then jl[#jl+1]=iX end;if ji~=""then jl[#jl+1]=ji end;if jj~=""then jl[#jl+1]=jj end;jk(jl,ci)if not iE()or m then if not jh()or n then if cY then mM(jl,al,am,mC,mN,cY)mE(jl,mD,mC,al,am,cY,bN(jM(cJ)),cL)else mM(jl,al,am,mB,mN,cY)mE(jl,jL,mB,al,am,cY,bN(mB),cL)end;jn(jl,ci,cY)jO(jl,cJ,cL,al,am)end end;k4(jl,je,k5,k6)kb(jl,kc)kg(jl)kD(jl)if not iV and c1 then kB(jl)end;return jl end;local n0=0;local n1=0;local n2=0;local n3=0;function my.DisplayOrbitScreen(jl)return kD(jl)end;function my.hudtick()if not jt then return end;local function n4(jl)local n5=bN(dt(dd/(ac/4)*255,0,255))jl[#jl+1]=ds("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(j1+0.5)+n5,bN(j2+0.5)-n5,bN(j3+0.5)-n5)end;local function n6()if c2 then for dX,dE in pairs(iO)do if dE.hovered then if not dE.drawCondition or dE.drawCondition(dE)then dE.toggleFunction(dE)end;dE.hovered=false end end;for dX,dE in pairs(iR)do if dE.hovered then bK=dE.label;dE.hovered=false end end;c2=false end end;local function n7()local function n8(n9,na,hE,hF,lR,lS)if n9>=hE and n9<=hE+lR and na>=hF and na<=hF+lS then return true else return false end end;local hE=c9+ac/2;local hF=ca+ad/2;for dX,dE in pairs(iO)do dE.hovered=n8(hE,hF,dE.x,dE.y,dE.width,dE.height)end;for dX,dE in pairs(iR)do dE.hovered=n8(hE,hF,dE.x,dE.y,dE.width,dE.height)end;if d0 then local lL=false;for dX,eK in ipairs(mt)do if eK.hovered then lL=true;break end end;if mq.hovered then lL=true end;d0=lL else d0=mq.hovered;if not d0 then d1=bm end end end;local function nb(jl)local function nc(jl,nd,hover,hE,hF,ne,nf,ng,nh,ni,nj,mu)if type(ni)=="function"then ni=ni(mu)end;if type(nj)=="function"then nj=nj(mu)end;jl[#jl+1]=ds("<rect x='%f' y='%f' width='%f' height='%f' fill='",hE,hF,ne,nf)if nd then jl[#jl+1]=ds("%s'",ng)else jl[#jl+1]=nh end;if hover then jl[#jl+1]=ds(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else jl[#jl+1]=ds(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fS(af*0.5,0),fS(ag*0.5,0),fS(ah*0.5,0))end;jl[#jl+1]=" rx='5'></rect>"jl[#jl+1]=ds("<text x='%f' y='%f' font-size='24' fill='",hE+ne/2,hF+nf/2+5)if nd then jl[#jl+1]="black"else jl[#jl+1]="white"end;jl[#jl+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if nd then jl[#jl+1]=ds("%s</text>",ni)else jl[#jl+1]=ds("%s</text>",nj)end end;local nk=ds("rgb(%d,%d,%d)'",fS(af*0.1,0),fS(ag*0.1,0),fS(ah*0.1,0))local nl=ds("rgb(%d,%d,%d)",fS(af*0.8,0),fS(ag*0.8,0),fS(ah*0.8,0))local nm=nc;for dX,dE in pairs(iO)do local lW=dE.disableName;local lV=dE.enableName;if type(lW)=="function"then lW=lW(dE)end;if type(lV)=="function"then lV=lV(dE)end;if not dE.drawCondition or dE.drawCondition(dE)then nm(jl,dE.toggleVar(dE),dE.hovered,dE.x,dE.y,dE.width,dE.height,nl,nk,lW,lV,dE)end end end;local function nn(jl)if not cV then j1=ai;j2=aj;j3=ak else j1=af;j2=ag;j3=ah end;j4=[[rgb(]]..bN(j1+0.6)..","..bN(j2+0.6)..","..bN(j3+0.6)..[[)]]j5=[[rgb(]]..bN(j1*0.8+0.5)..","..bN(j2*0.8+0.5)..","..bN(j3*0.8+0.5)..[[)]]local no=j4;local np=j5;local nq=[[rgb(]]..bN(j1*0.4+0.5)..","..bN(j2*0.4+0.5)..","..bN(j3*0.4+0.5)..[[)]]local nr=j4;local ns=j5;local nt=nq;if jh()and not n then no=[[rgb(]]..bN(j1*0.5+0.5)..","..bN(j2*0.5+0.5)..","..bN(j3*0.5+0.5)..[[)]]np=[[rgb(]]..bN(j1*0.3+0.5)..","..bN(j2*0.3+0.5)..","..bN(j3*0.2+0.5)..[[)]]nq=[[rgb(]]..bN(j1*0.2+0.5)..","..bN(j2*0.2+0.5)..","..bN(j3*0.2+0.5)..[[)]]end;jl[#jl+1]=ds([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],no,no,no,nr,nr,np,np,ns,ns,np,no,nq,ns,no,no,nq,nq,nt,nq,ac,ad,np,np,np,np,np,nr,np,ns,nt,ns,ns,nt)if w and I then jl[#jl+1]=mz end;return jl end;local function nu(jl)jl[#jl+1]=ds([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;local function nv(jl)local hE=jf(640)local hF=jg(200)jl[#jl+1]=[[<g class="pbright txtvspd txtstart">]]local hV=0;for dS,dE in pairs(iW)do hV=hV+1;jl[#jl+1]=gK(hE,hF,dS..": "..dE.get())hF=hF+20;if hV%12==0 then hE=hE+jf(350)hF=jg(200)end end;jl[#jl+1]=gK(jf(640),jg(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jl[#jl+1]="</g>"return jl end;local ib=jg(125)local ia=jf(1225)local function nw()ic=cu.GetRadarHud(ia,ib,ax,ay)if ic then gV=true end end;local nx=fS(ac/2,0)local ny=fS(ad/2,0)local jl={}if nz then jl[#jl+1]=nz end;nn(jl)if w then mA(jl)else if A then jk(jl,ci)end;kg(jl)end;if iV and iW~="none"then nv(jl)end;if cu then nw()else ic=""end;jl[#jl+1]="</svg>"jl[#jl+1]=ds([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ac,ad)if c3~="empty"then mx(jl,c3)end;if not iE()and g=="virtual joystick"then if v then nu(jl)end end;if not iG()then if iE()and c1 then if not nA then n7()nb(jl)end;if not cx and not cy then local nB=table.concat(jl,"")jl={}jl[#jl+1]=ds("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jl[#jl+1]=nB;jl[#jl+1]="</body>"cx=true;jl[#jl+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local nB=table.concat(jl,"")jl={}jl[#jl+1]=ds("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jl[#jl+1]=nB;jl[#jl+1]="</body>"end;if not cx then jl[#jl+1]=ds([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nx,ny,c9,ca)end else n6()end else if not c1 and not iE()then n6()if dd>az then if v then n4(jl)end end elseif c1 and(not nA or not j)then n7()nb(jl)end;jl[#jl+1]=ds([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nx,ny,c9,ca)end;jl[#jl+1]=[[</svg></body>]]nC=table.concat(jl,"")end;local nD=1;local nE=2;local nF=3;local nG=4;local nH=5;local nI=6;local nJ=7;local nK=""local nL=0;local nM=90.0*aT;local nN={}local nO={}local nP={}local nQ={}local nR={}local nS={}local nT={}nT["atmofueltank"],nT["spacefueltank"],nT["rocketfueltank"]=0,0,0;local nU=0;local nV=1-(a6*0.05+a7*0.05)function my.FuelUsed(nW)local nX;if nW=="atmofueltank"then nX=ds("Atmo Fuel Used: %.1f L",nT[nW]/(4*nV))elseif nW=="spacefueltank"then nX=ds("Space Fuel Used: %.1f L",nT[nW]/(6*nV))else nX=ds("Rocket Fuel Used: %.1f L",nT[nW]/(0.8*nV))end;return nX end;function my.TenthTick()local function nY()local nZ=a.createData;local n_=a.createWidget;o0=a.createWidgetPanel("Interplanetary Helper")o1=n_(o0,"value")o2=nZ('{"label": "Target Planet", "value": "N/A", "unit":""}')fQ(o2,o1)o3=n_(o0,"value")o4=nZ('{"label": "distance", "value": "N/A", "unit":""}')fQ(o4,o3)gj=n_(o0,"value")gi=nZ('{"label": "Travel Time", "value": "N/A", "unit":""}')fQ(gi,gj)gl=n_(o0,"value")gk=nZ('{"label": "Target Altitude", "value": "N/A", "unit":""}')fQ(gk,gl)o5=n_(o0,"value")o6=nZ('{"label": "Space Engine", "value": "N/A", "unit":""}')fQ(o6,o5)o7=n_(o0,"value")o8=nZ('{"label": "End Speed", "value": "N/A", "unit":""}')gd=n_(o0,"value")gc=nZ('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gb=n_(o0,"value")ga=nZ('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g9=n_(o0,"value")g8=nZ('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g7=n_(o0,"value")g6=nZ('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gf=n_(o0,"value")ge=nZ('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fQ(o8,o7)fQ(gc,gd)fQ(ga,gb)fQ(g8,g9)fQ(g6,g7)fQ(ge,gf)end end;local function o9()gJ(o0)o0=nil end;local function oa()local function ob(hE,oc,od,oe,of,og)local k7=nU;local k8=nU+5;if not B then k8=k8+5 end;if iE()and not m then k7=k7-50;k8=k8-50 end;if od=="ATMO"then nK="atmofueltank"elseif od=="SPACE"then nK="spacefueltank"else nK="rocketfueltank"end;nL=_G[nK.."_size"]if#oe>0 then for M=1,#oe do local gv=oe[M][nE]local oh=oe[M][nJ]for oi=1,nL do if oe[M][nE]==iC(c[nK.."_"..oi].getWidgetData()).name then oh=oi;break end end;local oj=bM()if of[M]==nil or og[M]==nil or oj-oe[M][nI]>nM then local ok;local ol=0;ol=iD(oe[M][nD])-oe[M][nG]ok=oe[M][nH]local om=ok>ol or false;if om then nT[nK]=nT[nK]+ok-ol end;if oh~=0 then local on=iC(c[nK.."_"..oh].getWidgetData())og[M]=on.percentage;of[M]=on.timeLeft;if of[M]=="n/a"then of[M]=0 end else og[M]=bN(0.5+ol*100/oe[M][nF])if om then of[M]=bN(0.5+ol/((ok-ol)/(oj-oe[M][nI])))else of[M]=0 end end;oe[M][nI]=oj;oe[M][nH]=ol end;if gv==oc then gv=ds("%s %d",od,M)end;if oh==0 then gv=gv.." *"end;local oo;oo=iK(of[M])if of[M]==0 or oo==">1y"then oo=""end;if og[M]~=nil then local op=bN(og[M]*2.55)local oq=ds("rgb(%d,%d,%d)",255-op,op,0)local jD=""if oo~=""and of[M]<120 or og[M]<5 then jD="red "end;local os=ds("rgb(%d,%d,%d)",dt(bN((255-op)/2.55),50,100),dt(bN(op/2.55),0,50),50)local n5="rgb(196,0,255)"if od=="ATMO"then n5="rgb(0,188,255)"elseif od=="SPACE"then n5="rgb(239,255,0)"end;local ot=false;if ou~=n5 then ot=true end;ou=n5;if B then if ot then k7=k7-5;k8=k8-5 end;ji=ji..ds([[
                                                    <g class="pdim">                        
                                                    <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                                    <g class="bar txtstart">
                                                    <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                                    <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                                    </g>]],os,n5,hE,k8,oq,bN(og[M]*1.7+0.5)-2,hE+1,k8+1,hE+5,k8+14,gv,og[M],oo)k7=k7-22;k8=k8-22 else ji=ji..gK(hE,k7,gv,jD.."pdim txtfuel")ji=ji..gK(hE,k8,ds("%d%% %s",og[M],oo),"pdim txtfuel","fill:"..oq)k7=k7+30;k8=k8+30 end end end end;nU=k7 end;if at~=0 and au~=0 then ji=gK(at,au,"","txtstart pdim txtfuel")nU=au;ob(at,"Atmospheric ","ATMO",cl,nR,nS)ob(at,"Space Fuel T","SPACE",cm,nP,nQ)ob(at,"Rocket Fuel ","ROCKET",cn,nN,nO)end end;local function ov()local io=shield.isActive()and"Shield Active"or"Shield Disabled"local ow=bP.getPvPTimer()local ox=shield.getResistances()local oy="A: "..10+ox[1]*100 .."% / E: "..10+ox[2]*100 .."% / K:"..10+ox[3]*100 .."% / T: "..10+ox[4]*100 .."%"local hE,hF=av-60,aw+30;local op=bN(dn*2.55)local oq=ds("rgb(%d,%d,%d)",255-op,op,0)local jD=""jj=gK(hE,hF,"","txtmid pdim txtfuel")if dn<10 and io~="Shield Disabled"then jD="red "end;ow=ow>0 and"   PvPTime: "..iK(ow)or""jj=jj..ds([[
                                <g class="pdim">                        
                                <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                                <g class="bar txtstart">
                                <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                <text fill=black x="%d" y="%d">%s%%%s</text>
                                </g>]],hE,hF,oq,dn*2,hE,hF,hE+2,hF+10,dn,ow)jj=jj..gK(hE,hF-5,io,jD.."txtstart pbright txtbig")jj=jj..gK(hE,hF+30,oy,jD.."txtstart pbright txtsmall")end;local function oz()local je="TRAVEL"if not cR then je="CRUISE"end;if b5 then je="AUTOPILOT"end;return je end;oa()je=oz()if shield then ov()end;if bk~="None"then if o0==nil then nY()end;if bk~=nil then local lm;local oA=g2~=nil;local oB=b5 and bh*3.6 or 0;fP(o2,'{"label": "Target", "value": "'..bk..'", "unit":""}')if oA and not b5 then lm=(cO-g2.position):len()else lm=(bl-cO):len()end;if not b6 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)iZ,i_=ct.GetAutopilotBrakeDistanceAndTime(bI)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)iZ,i_=ct.GetAutopilotTBBrakeDistanceAndTime(bI)end;local kr=iJ(lm)fP(o4,'{"label": "distance", "value": "'..kr..'"}')fP(gi,'{"label": "Travel Time", "value": "'..iK(kw)..'", "unit":""}')kr=iJ(c6)fP(gc,'{"label": "Cur Brake distance", "value": "'..kr..'"}')fP(ga,'{"label": "Cur Brake Time", "value": "'..iK(c7)..'", "unit":""}')kr=iJ(iZ)fP(g8,'{"label": "Max Brake distance", "value": "'..kr..'"}')fP(g6,'{"label": "Max Brake Time", "value": "'..iK(i_)..'", "unit":""}')fP(o8,'{"label": "End Speed", "value": "'..ds("%.0fkph",oB)..'", "unit":""}')kr=iJ(gm)fP(gk,'{"label": "High Orbit", "value": "'..kr..'"}')fP(o6,'{"label": "Space Engine Alt", "value": "'..c8.spaceEngineMinAltitude..'m"}')if cg and not oC then a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(o8,o7)a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)oC=true;if not cR and t and(b7 or ba or ce)then ct.cmdThrottle(1)b2=false;bV=false end end;if not cg and oC then if fP(g6,g7)then fQ(g6,g7)end;if fP(g6,o7)then fQ(o8,o7)end;if fP(g8,g9)then fQ(g8,g9)end;if fP(ga,gb)then fQ(ga,gb)end;if fP(gc,gd)then fQ(gc,gd)end;if fP(ge,gf)then fQ(ge,gf)end;oC=false end end else o9()end;if warpdrive~=nil then local oD=iC(warpdrive.getWidgetData())if oD.destination~="Unknown"and oD.distance>400000 then if not jb then warpdrive.showWidget()jb=true end elseif jb then warpdrive.hideWidget()jb=false end end end;function my.OneSecondTick()local function oE()local oj=bM()local kc=cL;local oF=oj-j9;if kc>1.38889 then kc=kc/1000;local oG=kc*(oj-j9)bo=bo+oG;j6=j6+oG end;j7=j7+oF;bp=bp+oF;j9=oj end;local function oH(jl)local oI=0;local oJ=iM;local oK=0;local oL=0;local oM=0;local op=0;local oq=""local oN=b.getElementHitPointsById;local oO=b.getElementMaxHitPointsById;local oP={}for dS in pairs(iL)do local oQ=0;local oR=0;oR=oO(iL[dS])oQ=oN(iL[dS])oK=oK+oQ;if oQ+1<oR then if oQ==0 then oM=oM+1 else oL=oL+1 end;if ja and#oP==0 then fU=vec3(b.getElementPositionById(iL[dS]))local hE=fU.x;local hF=fU.y;local hG=fU.z;table.insert(oP,b.spawnArrowSticker(hE,hF,hG+1,"down"))table.insert(oP,b.spawnArrowSticker(hE,hF,hG+1,"down"))b.rotateSticker(oP[2],0,0,90)table.insert(oP,b.spawnArrowSticker(hE+1,hF,hG,"north"))table.insert(oP,b.spawnArrowSticker(hE+1,hF,hG,"north"))b.rotateSticker(oP[4],90,90,0)table.insert(oP,b.spawnArrowSticker(hE-1,hF,hG,"south"))table.insert(oP,b.spawnArrowSticker(hE-1,hF,hG,"south"))b.rotateSticker(oP[6],90,-90,0)table.insert(oP,b.spawnArrowSticker(hE,hF-1,hG,"east"))table.insert(oP,b.spawnArrowSticker(hE,hF-1,hG,"east"))b.rotateSticker(oP[8],90,0,90)table.insert(oP,b.spawnArrowSticker(hE,hF+1,hG,"west"))table.insert(oP,b.spawnArrowSticker(hE,hF+1,hG,"west"))b.rotateSticker(oP[10],-90,0,90)table.insert(oP,iL[dS])end elseif ja and#oP>0 and oP[11]==iL[dS]then for oi in pairs(oP)do b.deleteSticker(oP[oi])end;oP={}end end;oI=fS(oK/oJ*100,2)if oM>0 or oL>0 then jl[#jl+1]=gK(0,0,"","pbright txt")op=bN(oI*2.55)oq=ds("rgb(%d,%d,%d)",255-op,op,0)jl[#jl+1]=gK("50%",1035,"Elemental Integrity: "..oI.."%","txtbig txtmid","fill:"..oq)if oM>0 then jl[#jl+1]=gK("50%",1055,"Disabled Modules: "..oM.." Damaged Modules: "..oL,"txtbig txtmid","fill:"..oq)elseif oL>0 then jl[#jl+1]=gK("50%",1055,"Damaged Modules: "..oL,"txtbig txtmid","fill:"..oq)end end end;local function oS()if iB then if j0==nil and(hi~=nil or bn)then _autoconf.displayCategoryPanel(iB,weapon_size,"Weapons","weapon",true)j0=_autoconf.panels[_autoconf.panels_size]elseif j0~=nil and hi==nil and not bn then gJ(j0)j0=nil end end end;local function oT()jd=""local oU="topButton"local oV="topButtonActive"local oW=oU;if b5 or br or cd or bA then oW=oV end;local oX=oU;if b4 then oX=oV end;local oY=oU;if b8 or bn then oY=oV end;local oZ=oU;if b7 or br then oZ=oV end;local o_=oU;if b3 then o_=oV end;local p0=oU;if bA or cE and b5 then p0=oV end;local p1=jg(30)jd=jd..ds([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],oW,jf(960),jg(54),jg(-53),jf(-120),jf(25),jg(50))jd=jd..gK(jf(910),p1,"AUTOPILOT")jd=jd..ds([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],oX,jf(865),jg(51),jf(-25),jg(-50),jf(-110),jf(25),jg(46))jd=jd..gK(jf(800),p1,"PROGRADE")jd=jd..ds([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],oY,jf(755),jg(47),jf(-25),jg(-46),jf(-98),jf(44),jg(44))jd=jd..gK(jf(700),p1,"LAND")jd=jd..ds([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],oZ,jf(960),jg(54),jg(-53),jf(120),jf(-25),jg(50))jd=jd..gK(jf(1010),p1,"ALT HOLD")jd=jd..ds([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],o_,jf(1055),jg(51),jf(25),jg(-50),jf(110),jf(-25),jg(46))jd=jd..gK(jf(1122),p1,"RETROGRADE")jd=jd..ds([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],p0,jf(1165),jg(47),jf(25),jg(-46),jf(98),jf(-44),jg(44))jd=jd..gK(jf(1220),p1,"ORBIT")jd=jd..[[
                                </g>
                            </g>]]jd=jd.."</g>"end;local function p2()local function p3()local p4;local dp=jt;local p5=jf(1770)local p6=jg(330)if dh then local p7="txttick "local p8=500000;if dh<dp.radius+p8 then if cV then p7="txttick red "else p7="txttick orange "end end;p4=iJ(dh,2)iX=gK(p5,p6,"Closest Pipe ("..dp.name.."--"..dg.name.."): "..p4,p7 .."pbright txtmid")if c8 and c8.name~=jt.name and c8.name~="Space"then p4=iJ(dl,2)iX=iX..gK(p5,p6+15,"Target Pipe ("..dp.name.."--"..c8.name.."): "..p4,p7 .."pbright txtmid")end end end;if cg then iX=""return end;p3()end;local function p9(jl)local pa=jf(1240)local pb=jg(55)local pc=pb+10;local pd;local pe=0;if b1 then je=je.."-VERTICAL"end;if E and gV and not b9 and not b8 and cL>20 then je=je.."-COLLISION ON"end;if bD~="Off"then je="("..bD..")-"..je end;if b6 then je="TB-"..je end;if not bC then je=je.."-DeCoupled"end;if dm then je="Alignment Lock-"..je end;local pf=jg(99)local pg=jg(80)local ph=jg(85)local pi=jg(31)local pj=0;local pk=0;local fa=cj>1000000 and fS(cj/1000000,2).."kT"or fS(cj/1000,2).."T"if cg then pe=bv else pe=bt end;local pl,pm=cp.computeDistanceAndTime(cL,0,cj,0,0,pe)if pl<0 then pl=0 end;pe=fS(pe/(cj*iN),2).."g"local pn=d:maxForceForward()pd=b.getGravityIntensity()if pd>0.1 then pk=cj*pd;pk=fS(pk/(cj*iN),2).."g"pj=0.5*pn/pd;pj=pj>1000000 and fS(pj/1000000,2).."kT"or fS(pj/1000,2).."T"end;pn=fS(pn/(cj*iN),2).."g"local po=vec3(bP.getWorldAcceleration()):len()/9.80665;pd=b.getGravityIntensity()jl[#jl+1]=[[<g class="dim txt txtend size14">]]if iE()and not m then pa=jf(1120)pb=jg(55)pc=pb+10 elseif cg and I then local pp=jf(770)jl[#jl+1]=gK(jf(895),pf,"ATMO","")jl[#jl+1]=ds([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],jf(895),ph,jf(-80))jl[#jl+1]=gK(jf(815),pg,ds("%.1f%%",ch*100),"txtstart size20")end;if I then jl[#jl+1]=gK(jf(1025),pf,"GRAVITY","txtstart")jl[#jl+1]=ds([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],jf(1025),ph,jf(80))jl[#jl+1]=gK(jf(1105),pg,ds("%.2fg",pd/9.80665),"size20")jl[#jl+1]=gK(jf(1125),pf,"ACCEL","txtstart")jl[#jl+1]=ds([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],jf(1125),ph,jf(80))jl[#jl+1]=gK(jf(1205),pg,ds("%.2fg",po),"size20")jl[#jl+1]=gK(jf(695),pf,"BRK TIME","")jl[#jl+1]=ds([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],jf(695),ph,jf(-80))jl[#jl+1]=gK(jf(615),pg,ds("%s",iK(pm)),"txtstart size20")jl[#jl+1]=gK(jf(635),jg(45),"TRIP","")jl[#jl+1]=ds([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],jf(635),jg(31),jf(-90))if kw then jl[#jl+1]=gK(jf(545),jg(26),ds("%s",iK(kw)),"txtstart size20")end;jl[#jl+1]=gK(jf(795),pf,"BRK DIST","")jl[#jl+1]=ds([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],jf(795),ph,jf(-80))jl[#jl+1]=gK(jf(715),pg,ds("%s",iJ(pl)),"txtstart size20")jl[#jl+1]=gK(jf(1285),jg(45),"MASS","txtstart")jl[#jl+1]=ds([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],jf(1285),jg(31),jf(90))jl[#jl+1]=gK(jf(1375),jg(26),ds("%s",fa),"size20")jl[#jl+1]=gK(jf(1220),pf,"THRUST","txtstart")jl[#jl+1]=ds([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],jf(1220),ph,jf(80))jl[#jl+1]=gK(jf(1300),pg,ds("%s",pn),"size20")jl[#jl+1]=gK(jf(960),jg(175),je,"pbright txtbig txtmid size20")end;jl[#jl+1]="</g>"end;local function pq(jl)if not bK or bK==""then bK="INFO"end;for dS,dE in pairs(iR)do local jD="dim brightstroke"local pr=0.2;if bK==dS then jD="pbright dimstroke"pr=0.6 end;local ps=""if dE.hovered then pr=0.8;ps=";stroke:white"end;jl[#jl+1]=ds([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dE.width,dE.height,dE.x,dE.y,jD,pr,ps)jl[#jl+1]=gK(dE.x+dE.width/2,dE.y+dE.height/2+5,dE.label,"txt txtmid pdim")end end;local function pt(j6,bo,j7)jc=""local pd;local pe=0;local pk=0;local fa=cj>1000000 and fS(cj/1000000,2).." kTons"or fS(cj/1000,2).." Tons"if cg then pe=bv else pe=bt end;local pl,pm=cp.computeDistanceAndTime(cL,0,cj,0,0,pe)local pn=d:maxForceForward()pd=b.getGravityIntensity()if pd<0.1 then pd=9.80665 end;local pu=vec3(bP.getOrientationForward())local pv=bP.getMaxThrustAlongAxis('thrust analog longitudinal ',{pu:unpack()})n0=0.5*pv[1]/pd;n0=n0>1000000 and fS(n0/1000000,1).." kTons"or fS(n0/1000,1).." Tons"n1=0.5*pv[3]/pd;n1=n1>1000000 and fS(n1/1000000,1).." kTons"or fS(n1/1000,1).." Tons"pu=vec3(bP.getOrientationUp())pv=bP.getMaxThrustAlongAxis('hover_engine, booster_engine',{pu:unpack()})n2=0.5*pv[1]/pd;n2=n2>1000000 and fS(n2/1000000,1).." kTons"or fS(n2/1000,1).." Tons"n3=0.5*pe/pd;n3=n3>1000000 and fS(n3/1000000,1).." kTons"or fS(n3/1000,1).." Tons"pe=fS(pe/(cj*iN),2).." g"pk=cj*pd;pk=fS(pk/(cj*iN),2).." g"pn=fS(pn/(cj*iN),2).." g"if not iE()or m then local pw=jf(aB+10)local px=jg(aC+20)local py=jf(aB+60*1920/ac+aA/2)local lS=25;jc=jc.."<g class='txtstart size14 bright'>"jc=jc..gK(pw,px,ds("BrkTime: %s",iK(pm)))jc=jc..gK(py,px,ds("Trip: %.2f km",j6))jc=jc..gK(pw,px+lS,ds("Lifetime: %.2f kSU",bo/200000))jc=jc..gK(py,px+lS,ds("BrkDist: %s",iJ(pl)))jc=jc..gK(pw,px+lS*2,"Trip Time: "..iK(j7))jc=jc..gK(py,px+lS*2,"Total Time: "..iK(bp))jc=jc..gK(pw,px+lS*3,ds("Mass: %s",fa))jc=jc..gK(py,px+lS*3,ds("Req Thrust: %s",pk))jc=jc..gK(py,px+lS*4,ds("Safe Brake Mass: %s",n3))jc=jc..gK(pw,px+lS*4,ds("Max Thrust: %s",pn))jc=jc..gK(py,px+lS*5,ds("Safe Atmo Mass: %s",n0))jc=jc..gK(pw,px+lS*5,ds("Max Brake: %s",pe))jc=jc..gK(py,px+lS*6,ds("Safe Space Mass: %s",n1))jc=jc..gK(py,px+lS*7,ds("Safe Hover Mass: %s",n2))jc=jc..gK(pw,px+lS*6,ds("Influence: %s",jt.name))jc=jc..gK(pw,px+lS*7,ds("Set Max Speed: %s",bN(bI*3.6+0.5)))jc=jc..gK(py,px+lS*8,ds("Actual Max Speed: %s",bN(df*3.6+0.5)))jc=jc..gK(pw,px+lS*8,ds("Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))end;jc=jc.."</g></g>"end;local jl={}oE()if s then oH(jl)end;oS()p2()p9(jl)if bK=="INFO"then pt(j6,bo,j7)end;if w then pq(jl)if I then oT()end end;if cW>50000 and not cg then local pz=jf(1770)local pA=jg(310)local pB;pB=iJ(cW)jl[#jl+1]=gK(pz,pA,"PvP Boundary: "..pB,"pbright txtbig txtmid")end;j8=table.concat(jl,"")end;function my.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function my.MsgTick()local jl={}mx(jl,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function my.ButtonSetup()m6()mb()iO=iP end;mz=ds([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                
                <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                
                <clipPath id="headingClip">
                    <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                </clipPath>
                <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],jf(630),jg(0),jf(675),jg(45),jf(960),jg(55),jf(1245),jg(45),jf(1290),jg(0),jf(1000),jg(105),jf(1040),jg(59),jf(1250),jg(51),jf(1300),jg(0),jf(1920),jg(0),jf(1920),jg(20),jf(1400),jg(20),jf(1300),jg(105),jf(920),jg(105),jf(880),jg(59),jf(670),jg(51),jf(620),jg(0),jf(0),jg(0),jf(0),jg(20),jf(520),jg(20),jf(620),jg(105),jf(890),jg(59),jf(960),jg(62),jf(1030),jg(59),jf(985),jg(112),jf(1150),jg(112),jf(1100),jg(152),jf(820),jg(152),jf(780),jg(112),jf(935),jg(112),jf(890),jg(59),jf(960),jg(62),jf(1030),jg(59),jf(985),jg(112),jf(1150),jg(112),jf(1100),jg(152),jf(820),jg(152),jf(780),jg(112),jf(935),jg(112))if pC then for dS,dE in pairs(pC)do my[dS]=dE end end;return my end;local function pD(d,b,c,e,vBooster,hover,pE,antigrav,dbHud_1,f5,bN,bO,iE,f0,bM,dt,iF,fP,iG,dv,fS,fR,iH,dw,iJ,iK,pF,iC,dq)local a=DUSystem;local bP=DUConstruct;local pG={}local pH=false;local pI=0;local pJ=0;local pK=0;local pL=bM()local pM=0;local pN=0;local pO=0;local pP=0;local pQ=false;local pR=false;local pS=false;local pT=nil;local pU=0;local iY=55;local pV=nil;local pW=false;local pX=false;local pY=false;local pZ=0;local p_=0;local q0=0;local q1=0;local q2=0;local q3={VectorToTarget=false}local q4=vec3(bP.getWorldOrientationUp())local q5=nil;local q6=0;local q7=false;local q8=false;local q9=false;local qa=false;local qb=false;local qc=false;local qd=""local qe=false;local qf=false;local qg=""local qh=false;local qi=0;local qj=0;local qk=c.getThrottle()local function ql()return not bP.isInPvPZone(),f5(bP.getDistanceToSafeZone())end;local function qm(jP)local qn=bh;if not b5 then qn=0 end;local qo=bt;if cg then if bv and bv>0 then qo=bv else return 0,0 end end;return cp.computeDistanceAndTime(jP,qn,cj,0,0,qo)end;local function qp(jP)local qn=bh;if not b5 then qn=0 end;return cp.computeDistanceAndTime(jP,qn,cj,d:maxForceForward(),a2,bt)end;local function qq(qr,qs,qt)qs=qs:project_on_plane(qr)qt=qt:project_on_plane(qr)return f0(qs:cross(qt):dot(qr),qs:dot(qt))end;local qu=-1;local qv=-1;local function qw()local function qx()local qy=-1;local qz=-1;if vBooster then qy=vBooster.getDistance()if qy>-1 and qy<0.01 then qy=qu else qu=qy end end;if hover then qz=hover.getDistance()if qz>-1 and qz<0.01 then qz=qv else qv=qz end end;if qy~=-1 and qz~=-1 then if qy<qz then return qy else return qz end elseif qy~=-1 then return qy elseif qz~=-1 then return qz else return-1 end end;local qA=qx()local qB=-1;if antigrav and antigrav.isActive()and not r and cL<iY then local qC=f5(ci-antigrav.getBaseAltitude())if qC<50 then return qC end end;if pE then qB=pE.raycast().distance;if qB==0 then qB=-1 end end;if qA~=-1 and qB~=-1 then if qA<qB then return qA else return qB end elseif qA~=-1 then return qA else return qB end end;local function qD(jt,eS,qE)local function qF(qG,e3)local eY=vec3(e3)if qG.id==0 then return setmetatable({latitude=eY.x,longitude=eY.y,altitude=eY.z,id=0,systemId=qG.systemId},e5)end;local eZ=eY-qG.center;local cb=eZ:len()local ea=cb-qG.radius;local e8=0;local e9=0;if not dw(cb,0)then local e_=f0(eZ.y,eZ.x)e9=e_>=0 and e_ or 2*math.pi+e_;e8=math.pi/2-math.acos(eZ.z/cb)end;return setmetatable({latitude=math.deg(e8),longitude=math.deg(e9),altitude=ea,id=qG.id,systemId=qG.systemId},e5)end;local qH=qF(jt,eS)qH="::pos{"..qH.systemId..","..qH.id..","..qH.latitude..","..qH.longitude..","..qH.altitude.."}"if qE then return qH else qb=qH;return true end end;local function qI(qJ,qK,qL)local function qM(qJ,eB)qJ=vec3(qJ)eB=vec3(eB):normalize()local dN=qJ*eB;return dN.x+dN.y+dN.z end;local qN=0.001;local qO=1;if not cg or not cA or cf~=-1 or cL<iY then if qL==nil then qL=aS end;if qK==nil then qK=qN end;qJ=vec3(qJ):normalize()local qP=vec3()-qJ;local qQ=-qM(qP,bP.getWorldOrientationRight())*qO;local qR=-qM(qP,bP.getWorldOrientationUp())*qO;if pJ==0 then pJ=qQ/2 end;if pK==0 then pK=qR/2 end;if f5(qQ)<0.1 then p_=p_-qQ*2 else p_=p_-(qQ+(qQ-pJ)*qL)end;if f5(qR)<0.1 then pZ=pZ+qR*2 else pZ=pZ+qR+(qR-pK)*qL end;pJ=qQ;pK=qR;if f5(qQ)<qK and f5(qR)<qK then return true end;return false elseif cA and cf==-1 then qJ=cK;if qL==nil then qL=aS end;if qK==nil then qK=qN end;qJ=vec3(qJ):normalize()local qP=cH-qJ;local qQ=-qM(qP,bP.getWorldOrientationRight())*qO;local qR=-qM(qP,bP.getWorldOrientationUp())*qO;if pJ==0 then pJ=qQ/2 end;if pK==0 then pK=qR/2 end;if f5(qQ)<0.1 then p_=p_-qQ*5 else p_=p_-(qQ+(qQ-pJ)*qL)end;if f5(qR)<0.1 then pZ=pZ+qR*5 else pZ=pZ+qR+(qR-pK)*qL end;pJ=qQ;pK=qR;if f5(qQ)<qK and f5(qR)<qK then return true end;return false end end;function pG.clearAll()bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"b3=false;b4=false;cX=nil;b7=false;ba=false;b8=false;b9=false;bb=false;c0=false;pX=false;cc=false;cd=false;pY=false;cz=q;br=false;b6=false;ck=false;bu=nil;bA=false;db=false;dc=nil;ce=false;ct.ResetAutopilots(1)end;function pG.GetAutopilotBrakeDistanceAndTime(jP)return qm(jP)end;function pG.GetAutopilotTBBrakeDistanceAndTime(jP)return qp(jP)end;function pG.showWayPoint(jt,eS,qE)return qD(jt,eS,qE)end;local qS=a.getAxisValue(3)local qT=a.getAxisValue(4)local qU=a.getAxisValue(5)function pG.APTick()local qV=a.getMouseWheel()if cR then local qW=a.getAxisValue(3)if qW~=qS then if t then bR=qW else iF:setThrottleCommand(axisCommandId.longitudinal,qW)end;qS=qW end;qW=a.getAxisValue(4)if qW~=qT then iF:setThrottleCommand(axisCommandId.lateral,qW)bz=qW;qT=qW end;qW=a.getAxisValue(5)if qW~=qU then iF:setThrottleCommand(axisCommandId.vertical,qW)b_=qW;qU=qW end end;if qV>0 then ct.changeSpd()elseif qV<0 then ct.changeSpd(true)else pW=true end;q8=iG()if qb then a.setWaypoint(qb)qb=false end;if qe then antigrav.setTargetAltitude(qe)qe=false end;if qc then fP(qc,qd)qc=false;qd=""end;if q5~=nil then if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then d.control.cancelCurrentControlMasterMode()end;if iF:getTargetSpeed(axisCommandId.longitudinal)~=q5 then iF:setTargetSpeedCommand(axisCommandId.longitudinal,q5)else q5=nil end end;if q7 then cv.landingGear(q7)q7=false end;if qf then ct.ToggleAutopilot()end end;function pG.ToggleIntoOrbit(qX)cE=false;pO=nil;pP=nil;pU=0;pR=false;if not cg then if bA then fR("orOff","AP")bA=false;pQ=false;pT=nil;cz=q;if b7 then b7=false;b9=false end;q3.VectorToTarget=false;q3.AutopilotAlign=false;pS=false elseif cY then fR("orOn","AP")bA=true;cz=true;if pT==nil then pT=qX or jt end;if b7 then b7=false;b9=false end else dq("Unable to engage auto-orbit, not near a planet")end else bA=false;pQ=false;pT=nil;cz=q;if b7 then b7=false end;q3.VectorToTarget=false;q3.AutopilotAlign=false;pS=false end end;function pG.ToggleVerticalTakeoff()b7=false;if bb then qY=true;ba=false;b9=false;b8=true;cz=true;b_=0;if cg and cf==-1 then b8=false;b7=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ct.cmdCruise(bN(cB))end else cE=false;bn=false;d.control.retractLandingGears()iF:setTargetGroundAltitude(Y)b2="VTO Takeoff"end;bb=not bb end;function pG.checkLOS(qJ)local ku,eQ,eR=co:getPlanetarySystem(0):castIntersections(cO,qJ,function(ez)if ez.noAtmosphericDensityAltitude>0 then return ez.radius+ez.noAtmosphericDensityAltitude else return ez.radius+ez.surfaceMaxAltitude*1.1 end end)local kv=eQ;if eR~=nil and eQ~=nil then kv=math.min(eR,eQ)end;if kv~=nil then return ku,kv else return nil,nil end end;local function qZ(q_,r0)if r0 then b_=0;iF:updateCommandFromActionStop(axisCommandId.vertical,r0)if bC then iF:activateGroundEngineAltitudeStabilization(r1)de=true end else b_=b_+q_;iF:deactivateGroundEngineAltitudeStabilization()iF:updateCommandFromActionStart(axisCommandId.vertical,q_)end end;function pG.vertical(q_,r0)qZ(q_,r0)end;function pG.ToggleAutopilot()local function r2(by)cZ=false;br=not br;if br then b6=false;if not b7 and not by then ct.ToggleAltitudeHold()end end;ky="Proceeding to Waypoint"end;local function r3(gv)if gv then for M,dS in pairs(cU)do if dS.name and dS.name==gv then return M end end else return 0 end end;local r4=false;if bQ-pN<1.5 and cg then if not cG then if cg then bc=jt.spaceEngineMinAltitude-0.01*jt.noAtmosphericDensityAltitude;fR("11","EP")pN=-1;if b5 or br or bA then return end else dq("No space engines detected, Orbital Hop not supported")return end elseif jt.hasAtmosphere then if cg then bc=jt.noAtmosphericDensityAltitude+U;fR("orH","OH")end;pN=-1;if b5 or br or bA then return end end else pN=bQ end;r5=false;dm=false;if(bm>0 or#bG>0)and not b5 and not br and not cd and not bA then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then dq("WARNING: Heavy Loads may affect autopilot performance.")end;bm=#bG>0 and not ce and r3(bG[1])or bm;cs.UpdateAutopilotTarget()if#bG>0 and not ce then dq("Route Autopilot in Progress")if(g2.position-cO):project_on_plane(cM):len()>50000 and g2.planetname==jt.name then r4=true end end;ct.showWayPoint(c8,bl)if g2~=nil then if g2.agg and not r and antigrav then if not cQ then ct.ToggleAntigrav()end;bw=g2.agg end;bu=nil;by=g2.planetname=="Space"if by then fR("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b5=true end elseif jt.name==g2.planetname then qY=true;if cg then if not br then fR("vtt","AP")r2(by)if r4 then bc=jt.noAtmosphericDensityAltitude+U end end else fR("apOn","AP")if not(c8.name==jt.name and ci<gm*1.5)then cE=false;b5=true elseif not cg then if bA then ct.ToggleIntoOrbit()end;cD=(c8.noAtmosphericDensityAltitude>0 and c8.noAtmosphericDensityAltitude or c8.surfaceMaxAltitude)+U;pS=true;q3.AutopilotAlign=true;q3.VectorToTarget=true;pQ=false;if not bA then ct.ToggleIntoOrbit(c8)end end end else fR("apP","AP")b3=false;b4=false;if cg then cd=true;ct.ToggleAltitudeHold()else b5=true end end elseif not cg then if g2==nil and(c8.name==jt.name and cY)and not bA then r6=false;cE=false;pQ=false;cD=(jt.noAtmosphericDensityAltitude>0 and jt.noAtmosphericDensityAltitude or jt.surfaceMaxAltitude)+U;pS=true;ct.ToggleIntoOrbit()else fR("apP","AP")b5=true;b3=false;b4=false;be=false;c0=false;b7=false;b8=false;ba=false;b9=false;pX=false;bu=nil;r6=false end else fR("apP","AP")cd=true;ct.ToggleAltitudeHold()end;qf=false else fR("apOff","AP")ct.clearAll()if qf==2 then qf=true end end end;function pG.routeWP(r7,r8,r9)if r9 then if r9==1 then bG={}bG=iH(bG,bF)if#bG>0 then dq("Route Loaded")else dq("No Saved Route found on Databank")end;return bG else bF={}bF=iH(bF,bG)dq("Route Saved")pF()return end end;if r7 then return bG end;if r8 then bG={}dq("Current Route Cleared")else bG[#bG+1]=g2.name;dq("Added "..g2.name.." to route. ")end;return bG end;function pG.cmdThrottle(dT,ra)if iF:getAxisCommandType(0)~=axisCommandType.byThrottle and not ra then d.control.cancelCurrentControlMasterMode()end;iF:setThrottleCommand(axisCommandId.longitudinal,dT)bR=dt(fS(dT*100,0)/100,-1,1)q5=nil end;function pG.cmdCruise(dT,ra)if q5 then q5=dT;return end;if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ra then d.control.cancelCurrentControlMasterMode()end;iF:setTargetSpeedCommand(axisCommandId.longitudinal,dT)q5=dT end;function pG.ToggleLockPitch()if bu==nil then fR("lkPOn","LP")bu=cS;b9=false;b7=false;b8=false else fR("lkPOff","LP")bu=nil end end;function pG.ToggleAltitudeHold()if bQ-pM<1.5 then if jt.hasAtmosphere then if cg then bc=jt.spaceEngineMinAltitude-0.01*jt.noAtmosphericDensityAltitude;fR("11","EP")else if cY then bc=jt.noAtmosphericDensityAltitude+U;cD=bc;pS=true;if not bA then ct.ToggleIntoOrbit()end;pQ=true end end;pM=-1;if b7 or bA or bb then return end end else pM=bQ end;if cY and not cg and cf==-1 then cD=ci;pS=true;pQ=true;ct.ToggleIntoOrbit()if bA then pM=bQ else pM=0 end;return end;b7=not b7;b8=false;ba=false;dm=false;if b7 then b5=false;b4=false;b3=false;c0=false;cz=true;bu=nil;cE=false;if cf~=-1 then if cL<20 then if bn then cv.landingGear()end;fR("lfs","LS")b9=true;if cg then bc=ci+X else bc=jt.surfaceMaxAltitude+100 end;b2="ATO Hold"iF:setTargetGroundAltitude(Y)if b1 and cP then ct.ToggleVerticalTakeoff()end end else fR("altOn","AH")b9=false;if pM>-1 then if cY then bc=ci end end;if bb then ct.ToggleVerticalTakeoff()end end;if cQ and not r then local rb=antigrav.getBaseAltitude()if br and g2.agg and g2.agg>ci then bc=g2.agg elseif b9 then bc=rb end;if f5(ci-rb)<100 and cL<20 then bc=rb;b2="AGG Hold"ct.cmdThrottle(0)end end;if cd then bc=200000 end else fR("altOff","AH")if bA then ct.ToggleIntoOrbit()end;if bb then ct.ToggleVerticalTakeoff()end;cz=q;b9=false;br=false;pM=0 end end;function pG.ResetAutopilots(pG)if pG then cd=false;b5=false;be=false;pX=false;bc=ci;r5=false;db=false;bi="Aligning"end;br=false;b9=false;ba=false;dm=false;b4=false;b8=false;dc=nil;rc=false;cX=nil;db=false;if not cQ then b7=false;bu=nil end;if bb then ct.ToggleVerticalTakeoff()end;if bA then ct.ToggleIntoOrbit()end;cz=q;cc=false;ce=false;b_=0 end;function pG.BrakeToggle(rd)if not b2 then if rd then b2=rd else b2=true end else b2=false end;if b8 then b8=false;cz=q;db=false end;if b2 then fR("bkOn","B",1)ct.ResetAutopilots()else fR("bkOff","B",1)end end;function pG.BeginReentry()if ba then dq("Re-Entry cancelled")fR("reOff","RE")ba=false;cz=q;b7=false elseif not jt.hasAtmosphere then dq("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c4=5 elseif not pY then ba=true;if iF:getAxisCommandType(0)~=re.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b2=false;dq("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB)fR("par","RE")else ba=true;b7=true;cz=true;b2=false;bc=jt.surfaceMaxAltitude+_;if bc>jt.spaceEngineMinAltitude then bc=jt.spaceEngineMinAltitude-0.01*jt.noAtmosphericDensityAltitude end;local rf=iJ(bc)dq("Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..rf)fR("glide","RE")ct.cmdCruise(bN(cB))end;b9=false end;function pG.ToggleAntigrav()if antigrav and not r then if cQ then fR("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bw==nil then bw=ci end;if bw<1000 then bw=1000 end;fR("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pG.changeSpd(rg)local rh=1;if rg then rh=-1 end;if not c1 then if t and not nA and pW then local ri=bR;bR=fS(dt(bR+rh*aE/100,-1,1),2)if bR>=0 and ri<0 then bR=0;pW=false end elseif nA then if cg or ba then cB=dt(cB+rh*aE,0,V)elseif b5 then bI=dt(bI+rh*aE/3.6*100,0,df-0.2)end else iF:updateCommandFromActionStart(axisCommandId.longitudinal,rh*aE/10)end else if b5 or br or cd or bA then d1=d1+1*rh*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not rg then rh=1 else rh=nil end;cs.adjustAutopilotTargetIndex(rh)end end end;function pG.TenthTick()local function rj()if not b5 then if g2==nil or g2.planetname~=jt.name then rk=(c8.center-cO):len()else rk=(g2.position-cO):len()end end;local jP=cL;local rl=t and bR or qk/100;local rm,rn=cp.computeDistanceAndTime(cL,bI,cj,d:maxForceForward()*rl,a2,0)local c6,c7;if not b6 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(bI)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(bI)end;local dX,ro;if not b6 and jP>0 then dX,ro=ct.GetAutopilotBrakeDistanceAndTime(jP)else dX,ro=ct.GetAutopilotTBBrakeDistanceAndTime(jP)end;local rp=0;local rq=0;if bg or not b5 and jP>5 then rq=cp.computeTravelTime(jP,0,rk)elseif c6+rm<rk then rp=rk-(c6+rm)rq=cp.computeTravelTime(bI,0,rp)else local rr=(rk-c6)/rm;rm=rk-c6;rn=rn*rr end;if g2~=nil and g2.planetname==jt.name and not b5 then return rq elseif bf then return ro elseif bg then return rq+ro else return rn+c7+rq end end;local function rs()local pd=b.getGravityIntensity()pd=fS(pd,5)if pV==nil or pV~=pd then local jP=cJ:len()local rt=bP.getMaxBrake()if rt~=nil and rt>0 and cg then rt=rt/dt(jP/100,0.1,1)rt=rt/ch;if ch>0.10 then bv=rt end end;if rt~=nil and rt>0 then bt=rt end;pV=pd end end;local function ru(rv,rw)local p4;local rx=(rw-rv):normalize()local fu=(cO-rv):dot(rx)/rx:dot(rx)local ry=rv+fu*rx;p4=(ry-cO):len()return p4,ry end;local function rz()local rA,rB=nil,nil;local rC=nil;local rD=nil;local rE,rF,rG=jt.center,nil,jt.name;for dS,rH in pairs(e[0])do rF=rH.center;if rF and rH.name~=rG and string.find(rH.name,"Asteroid")==nil and rH.name~="Space"then local cb,rA=ru(rE,rF)if rC==nil or cb<rC then rD=rH;rB=rA;rC=cb end end end;if rB then di=rB;dg=rD;dh=rC end;if c8 then if c8.name~=rG and c8.name~="Space"then dl,dj=ru(rE,c8.center)dk=c8 end end end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()qj=0;for M=1,#d3 do qj=qj+bP.getDockedConstructMass(d3[M])end;local rI=0;for M=1,#d2 do rI=rI+bP.getBoardedPlayerMass(d2[M])end;if rI>20000 then qj=qj+rI-20000 end;cV,cW=ql()df=bP.getMaxSpeed()if bk~="None"and(c8 or g2)then kw=rj()end;rs()rz()end;local rJ=pid.new(10,0,10.0)local function rK(rL,rM)local pu=vec3()local rN=vec3()if rL==axisCommandId.longitudinal then pu=vec3(bP.getOrientationForward())rN=cH elseif rL==axisCommandId.vertical then pu=vec3(bP.getOrientationUp())rN=q4 elseif rL==axisCommandId.lateral then pu=vec3(bP.getOrientationRight())rN=cI else return vec3()end;local rO=vec3(b.getWorldGravity())local rP=rO:dot(rN)local rQ=vec3(bP.getWorldAirFrictionAcceleration())local rR=rQ:dot(rN)local rS=cJ:dot(pu)local rT=rM*constants.kph2m;rJ:inject(rT-rS)local rU=rJ:get()local rV=(rU-rR-rP)*rN;return rV end;local rW=pid.new(10,0,10.0)local function rX(rL,rM)local pu=vec3()local rN=vec3()if rL==axisCommandId.longitudinal then pu=vec3(bP.getOrientationForward())rN=cH elseif rL==axisCommandId.vertical then pu=vec3(bP.getOrientationUp())rN=q4 elseif rL==axisCommandId.lateral then pu=vec3(bP.getOrientationRight())rN=cI else return vec3()end;local rO=vec3(b.getWorldGravity())local rP=rO:dot(rN)local rQ=vec3(bP.getWorldAirFrictionAcceleration())local rR=rQ:dot(rN)local rS=cJ:dot(pu)local rT=rM*constants.kph2m;rW:inject(rT-rS)local rU=rW:get()local rV=(rU-rR-rP)*rN;return rV end;local function rY(rZ,mP,fZ)local r_=rZ:cross(fZ):normalize_inplace()local jL=math.acos(dt(r_:dot(-mP),-1,1))*constants.rad2deg;if r_:cross(-mP):dot(fZ)<0 then jL=-jL end;return jL end;local function s0()if c_ and not b8 then local ez=c_[1]local i1,i2=c_[2],c_[3]local s1=math.min(i1,i2 or i1)local s2=s1/cL;local s3=b9 and(cL<42 or cf~=-1)local s4=b7 or br or bu or b5;if s4 and not s3 and(c6*1.5>s1 or s2<1)then b2="Collision"bG={}ct.cmdThrottle(0)if b7 then ct.ToggleAltitudeHold()end;if bu then ct.ToggleLockPitch()end;dq("Autopilot Cancelled due to possible collision")a.print(ez.name.." COLLISION "..iK(s2).." / "..iJ(s1,2))ct.clearAll()qY=true;if cg then b8=true end;cz=true end;if s2<11 then cZ=ez.name.." COLLISION "..iK(s2).." / "..iJ(s1,2)else cZ=ez.name.." collision "..iK(s2)end;if s2<6 then fR("alarm","AL",2)end else cZ=false end end;local s5=1;local s6=0;local s7=1;local s8=1;local s9=1;local sa=false;local sb=pid.new(0.1,0,1*0.1)local sc=pid.new(1*0.01,0,5*0.1)local sd=pid.new(aI*0.01,0,aI*0.1)local se=pid.new(2*0.01,0,2*0.1)local sc=pid.new(1*0.01,0,5*0.1)local sf=pid.new(2*0.01,0,2*0.1)local sg=pid.new(2*0.01,0,2*0.1)local sh=pid.new(2*0.01,0,2*0.1)local si=pid.new(2*0.01,0,2*0.1)local sj=pid.new(0.1,0,1)local sk=pid.new(1*0.01,0,1*0.1)function pG.onFlush()if antigrav and not r and not cQ and antigrav.getBaseAltitude()~=bw then qe=bw end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iF:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)qk=c.getThrottle()local sl=a.getAxisValue(1)if sl==0 then sl=a.getControlDeviceForwardInput()end;local sm=dt(bX+pZ+sl,-1,1)local sn=a.getAxisValue(0)if sn==0 then sn=a.getControlDeviceYawInput()end;local so=dt(bY+q0+sn,-1,1)local sp=a.getAxisValue(2)if sp==0 then sp=a.getControlDeviceLeftRightInput()end;local sq=dt(bZ+p_-sp,-1,1)local sr=b2 and 1 or 0;if cg then cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(jt.center-cO):normalize()end else cM=(jt.center-cO):normalize()end;q4=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()+qj;cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local ss=cT/180*math.pi;local st=math.cos(ss)local su=math.sin(ss)cS=rY(cM,cH,cI*st+q4*su)local sv=cK:normalize()local sw=f5(cT)local sx=utils.sign(cT)local sy=vec3(bP.getWorldAngularVelocity())local sz=sm*aO*cI+so*aJ*cH+sq*aP*q4;if cz==true and cM:len()>0.01 then local sA=f5(q1-cT)if((b4 or ba or b8 or cc or b7 or bA)and sA>0 or cg and sA<aK and q)and so==0 and f5(cS)<85 then local sB=q1;if not cg then q1=0;sB=0 end;sd:inject(sB-cT)local sC=sd:get()sz=sz+sC*cH end end;local function sD()local sE=(cO+cK*100000-c8.center):normalize()local sF=sE:project_on_plane((c8.center-cO):normalize()):normalize()if sF:len()<1 then sE=(cO+cH*100000-c8.center):normalize()sF=sE:project_on_plane((c8.center-cO):normalize()):normalize()end;return c8.center+sF*(c8.radius+gm)end;bS=0;ch=bO()cg=false or ci<jt.noAtmosphericDensityAltitude and ch>0.00001;ci=(cO-jt.center):len()-jt.radius;cf=qw()bQ=bM()pL=bQ;if bn and cf>-1 and cf-3<Z then if iF.targetGroundAltitudeActivated then iF:deactivateGroundEngineAltitudeStabilization()end;iF:updateCommandFromActionStart(axisCommandId.vertical,-1)end;if cu then qh=not qh;if qh then cu.UpdateRadar()end;if E then s0()end end;if antigrav then cQ=antigrav.isActive()end;local sG=bQ-pL;local sH=-math.deg(qq(q4,cK,cH))local sI=math.deg(qq(cI,cK,cH))local go=cM*-1;cA=cg and sH<-N or sH>N or sI<-O or sI>O;local sJ=a.getMouseDeltaX()local sK=a.getMouseDeltaY()if qi then local sL=bM()-qi;sJ=sJ*sL/0.016;sK=sK*sL/0.016 end;qi=bM()if p and not c1 then sK=-sK end;p_=0;q0=0;pZ=0;local sM=bP.getWorldPosition()jt=fV:closestBody(sM)sN=cq(jt)fr=sN:orbitalParameters(sM,cK)cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local pd=jt:getGravity(sM):len()*cj;q1=0;local sO=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if not q8 then if iE()and c1 then if not cx then c9=dt(c9+sJ/2,-ac/2,ac/2)ca=dt(ca+sK/2,-ad/2,ad/2)end else c9=0;ca=0 end else c9=dt(c9+sJ/2,-ac/2,ac/2)ca=dt(ca+sK/2,-ad/2,ad/2)dd=dv(c9*c9+ca*ca)if not c1 and not iE()then local jX,jY=1,1;if bK=="SCOPE"then jX,jY=d5/90,d5/90 end;if g=="virtual joystick"then if dd>az then p_=p_-dt(f5(c9)-az,0,ac/2)*utils.sign(c9)*aG*jX;pZ=pZ-dt(f5(ca)-az,0,ad/2)*utils.sign(ca)*aH*jY end else c9=0;ca=0;if g=="mouse"then pZ=(-utils.smoothstep(sK,-100,100)+0.5)*2*s8;p_=(-utils.smoothstep(sJ,-100,100)+0.5)*2*s9 end end end end;local sP=cL>27777;if cL>W/3.6 and not cg and not b5 and not sP then dq("Space Speed Engine Shutoff reached")ct.cmdThrottle(0)end;if not sP and sQ then ct.clearAll()if not b2 then ct.BrakeToggle()end;ct.cmdThrottle(0)end;sQ=sP;if ch>0.09 then if cL>cB/3.6 and not t and not pH then b2="SpdLmt"pH=true elseif not t and pH then if cL<cB/3.6 then b2=false;pH=false end end end;if b4 then if cc then b2=false;local sR,gS=false,g2;if not gS then gS=vec3(cK)end;sR=qI(g2.position-cO,0.1)cz=true;if sR then ct.cmdCruise(bN(cB))if(f5(cT)<2 or f5(cS)>85)and cL>=cB/3.6-1 then b2=false;b4=false;if cc~=2 then pY=true end;if cc==true then ce=true end;cc=false;b5=false;ct.BeginReentry()end elseif cg and t then ct.cmdThrottle(1)end elseif cL>iY then qI(vec3(cK),0.01)end end;if b3 then if cg then b3=false elseif cL>iY then qI(-vec3(cK))end end;if not b4 and cc and not bA then if not cg then if cc~=2 then pY=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not qf then qf=true end end end;if ce and g2 and(f5(ci-bc)<500 or ch>=0.11)and(g2.position-cO):len()-f5(ci-c8:getAltitude(g2.position))>3000 then if not qf then qf=true end;ce=false end;if bb then cz=true;local sS=bc;if cN<-30 then dq("Unable to achieve lift. Safety Landing.")b_=0;cz=q;bb=false;b8=true elseif not r and cQ or bc<jt.spaceEngineMinAltitude then if cQ then sS=antigrav.getBaseAltitude()end;if ci<sS-100 then q2=0;b_=15;b2=false elseif cN>0 then b2="VTO Limit"b_=0 elseif cN<-30 then b2="VTO Fall"b_=15 elseif ci>=sS then if cQ then if b5 or br then ct.ToggleVerticalTakeoff()else b2="VTO Complete"bb=false end;dq("Takeoff complete. Singularity engaged")fR("aggLk","AG")else b2=false;dq("VTO complete. Engaging Horizontal Flight")fR("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then q2=0;b2=false;b_=20 elseif ch<0.08 and cg then b2=false;if cF then q2=0;b_=20 else b_=0;q2=36;ct.cmdCruise(3500)end else cz=q;bA=true;cE=false;sT=false;pQ=false;pO=nil;pP=nil;if pT==nil then pT=jt end;cD=sS;pS=true;bb=false end end;if q2~=nil then local sU=dt(q2-cS,-O*0.80,O*0.80)se:inject(sU)local sV=dt(se:get(),-1,1)pZ=sV end end;if dm then local gS=dm*(bl-cO)qI(gS,0.1)end;if bA then local function sW()if not fr.apoapsis or not fr.periapsis then return false end;if fr.periapsis.altitude>=cD*0.99 and fr.apoapsis.altitude>=cD*0.99 and fr.periapsis.altitude<fr.apoapsis.altitude and fr.periapsis.altitude*1.05>=fr.apoapsis.altitude and f5(cD-ci)<1000 then return true else return false end end;local qP;local sX=false;local sY=iJ(cD,4)if pT==nil then pT=jt;if br then pT=c8 end end;if not pS then cD=bN(pT.radius+pT.surfaceMaxAltitude+U)if pT.hasAtmosphere then cD=bN(pT.radius+pT.noAtmosphericDensityAltitude+U)end;pS=true end;if q3.VectorToTarget and g2 then qP=g2.position-cO end;local sZ,s_=cq(pT):escapeAndOrbitalSpeed((cO-pT.center):len()-pT.radius)s_=s_*3.6+1+(K and aZ*s_*3.6 or 0)local t0=cT;if not pQ then local t1=false;local t2=false;if bR>0 then ct.cmdThrottle(0)end;pP=0;cC="Aligning to orbital path - OrbitHeight: "..sY;if q3.VectorToTarget then qI(qP:normalize():project_on_plane(cM))sX=cH:dot(qP:project_on_plane(q4):normalize())>0.95 else qI(cK)sX=sH<0.5;if cL<150 then sX=true end end;pZ=0;pO=0;if cS<=pO+2 and cS>=pO-2 then t1=true else t1=false end;if t0<=pP+2 and t0>=pP-2 then t2=true else t2=false end;if t1 and t2 and sX then pO=nil;pP=nil;pQ=true end else if ci<cD*1.5 then if q3.VectorToTarget then qI(qP:normalize():project_on_plane(cM))elseif cL>150 then qI(cK)end end;pZ=0;if q3.VectorToTarget and g2 then local c6,dX=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bt)if cE and qP:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pT.noAtmosphericDensityAltitude or kw>fr.timeToPeriapsis and fr.periapsis.altitude<pT.noAtmosphericDensityAltitude or not sW()and fr.eccentricity>0.1 then dq("Re-Aligning Orbit")cE=false end elseif cE or qP:len()<15000+c6+ci then dq("Orbit complete, proceeding with reentry")fR("orCom","OB")bl=g2.position;pY=true;ce=true;q3.VectorToTarget,q3.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if pR or fr.periapsis~=nil and fr.apoapsis~=nil and fr.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if fr.apoapsis~=nil or pR then if(sW()or cE)and not K then if cE then b2=false;if not cR or bR>0 then ct.cmdThrottle(0)end;pO=0;if not q3.VectorToTarget then dq("Orbit complete")fR("orCom","OB")ct.ToggleIntoOrbit()end else pU=pU+1;if pU>=2 then cE=true end end else if sW()then cC="Maintaining "pR=false else cC="Adjusting "pR=true;ct.cmdCruise(s_)local t3=cD-ci;sb:inject(t3-cN*dt(utils.smoothstep(2000-t3,-2000,2000)^6*10,1,10))pO=dt(sb:get(),-75,75)end;cC=cC.." - OrbitHeight: "..sY end end else local t4=2.75;local t5=f5(fS(sZ*t4))local nV=t5%50;if nV>0 then t5=t5-nV+50 end;b2=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sY;pO=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sY;t5=t5*0.75;pO=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sY;t5=t5*0.75;if cN<0 or pR then pO=utils.map(ci,cD*1.5,cD*1.01,-30,60)else pO=utils.map(ci,cD*0.99,cD*1.5,0,-30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sY;pO=-65;local t6=utils.map(cN,-150,-400,1,0.15)t5=t5*t6 end;ct.cmdCruise(t5)end end;if pO~=nil then local t7=pO-cS;sc:inject(t7)local t8=dt(sc:get(),-0.5,0.5)pZ=t8 end end;if b5 and not cg and not cc then local function t9(ta,fr)a.print(ta)b4=false;b2=false;bf=false;b5=false;r5=false;bi="Aligning"ct.cmdThrottle(0)pX=false;dq(ta)fR("apCom","AP")if fr or cc then if fr and gm~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pS=true;ct.ToggleIntoOrbit(c8)elseif cc then cc=false;qf=true end end end;local tb,tc=bl,false;if g2 and g2.planetname~="Space"then be=true;if not r5 then local sE=(g2.position-c8.center):normalize()local sF=sE:project_on_plane((c8.center-cO):normalize()):normalize()local td=c8.center+sF*(c8.radius+gm)local te=g2.position+(g2.position-c8.center):normalize()*(gm-c8:getAltitude(g2.position))if(cO-td):len()<(cO-te):len()then tb=td else tb=te;bh=0 end;bl=tb;local tf,tg=ct.checkLOS((bl-cO):normalize())if tf and tg<(cO-bl):len()then bl=sD()end;ct.showWayPoint(c8,bl)tc=true;r5=true end elseif g2 and g2.planetname=="Space"then if not r5 then tc=true;be=true;r5=true;tb=g2.position+(cO-g2.position):normalize()*S;bl=tb end elseif g2==nil then if not r5 then tb=sD()bl=tb;r5=true;tc=true;be=true;ct.showWayPoint(c8,bl)end end;rk=(vec3(tb)-cO):len()local ku,kv=ct.checkLOS(cK:normalize())if kv~=nil and kv<rk and ku.name==c8.name then rk=kv end;local sR=true;local th=(c8.center-(cO+vec3(cK):normalize()*rk)):len()-c8.radius;local kr=iJ(th)qc=ge;qd='{"label": "Projected Altitude", "value": "'..kr..'"}'if cL>50 and bd then local qP=vec3(tb)-cO;local ti=dt(math.deg(qq(q4,cK:normalize(),qP:normalize()))*cL/500,-90,90)local tj=dt(math.deg(qq(cI,cK:normalize(),qP:normalize()))*cL/500,-90,90)if f5(ti)<20 and f5(tj)<20 then ti=ti*2;tj=tj*2 end;if f5(ti)<2 and f5(tj)<2 then ti=ti*2;tj=tj*2 end;local sH=-math.deg(qq(q4,cH,cK:normalize()))local sI=-math.deg(qq(cI,cH,cK:normalize()))sf:inject(tj-sI)local tk=dt(sf:get(),-1,1)pZ=pZ+tk;sg:inject(ti-sH)local tl=dt(sg:get(),-1,1)p_=p_+tl;tc=true;if f5(ti)>2 or f5(tj)>2 then if bi~="Adjusting Trajectory"then bi="Adjusting Trajectory"fR("apAdj","AP")end else if bi~="Accelerating"then bi="Accelerating"fR("apAcc","AP")end end elseif bd and cL<=50 then qI((tb-cO):normalize())end;if th<gm*1.5 then bh=cB/3.6;if g2==nil then dX,bh=cq(c8):escapeAndOrbitalSpeed(th)end end;local c6,c7;if not b6 then c6,c7=qm(cL)else c6,c7=qp(cL)end;if b5 and not bd and not bg and not bf then local ku,kv=ct.checkLOS((bl-cO):normalize())if ku then local tm=ku.name;if c8.name~=jt.name then if c8.name~=tm and kv<rk then cZ="Attempting to clear LOS between "..tm.." and waypoint."bl=sD()q9=true end end else q9=false;cZ=false end end;if not q9 then if not bg and not bf and not tc then sR=qI((tb-cO):normalize())elseif b6 and(bf or bg)then sR=qI(-vec3(cK):normalize())end end;if bd then if not pX then b2=false;ct.cmdThrottle(a1)bR=fS(a1,2)pX=true end;local rl=t and bR or qk;local tn=99999;local po=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local to=dt(cK:dot((tb-cO):normalize()),0,cL)if to>0 or po>0 then tn=cp.computeTravelTime(to,po,rk-c6)end;if bI>df or a0==-1 and bI<df then bI=df-0.2 end;if cJ:len()>=bI or rl==0 and pX or a2/4>tn then bd=false;if bi~="Cruising"then fR("apCru","AP")bi="Cruising"end;bg=true;ct.cmdThrottle(0)end;local tp=rk;if tp<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV and not sP then if cW<pI and cW>2000 then ct.clearAll()dq("Autopilot cancelled to prevent crossing PvP Line")b2="PvP Prevent"pI=cW else pI=cW;return end end;bd=false;if bi~="Braking"then fR("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cz=true end;ct.cmdThrottle(0)pX=false end elseif bf then if bi~="Orbiting to Target"then b2="AP Brk"end;if b6 then ct.cmdThrottle(1,true)end;local dX,s_=cq(c8):escapeAndOrbitalSpeed((cO-c8.center):len()-c8.radius)local qP;if g2 then qP=g2.position-cO end;if g2 and g2.planetname=="Space"and(cL<50 or cL<555 and#bG>0)then if#bG>0 then if not qf then table.remove(bG,1)end;if#bG>0 then b2=false;if not qf then qf=2 end;return end end;t9("Autopilot complete, arrived at space location")b2="Space Arrival"elseif g2 and g2.planetname~="Space"and cL<=s_ and(fr.apoapsis==nil or fr.periapsis==nil or fr.apoapsis.altitude<=0 or fr.periapsis.altitude<=0)then bl=g2.position;cc=true;t9("Autopilot complete, commencing reentry")ct.showWayPoint(c8,bl)elseif(g2 and g2.planetname~="Space"or g2==nil)and fr.periapsis~=nil and fr.periapsis.altitude>0 and fr.eccentricity<1 or bi=="Circularizing"then if bi~="Circularizing"then fR("apCir","AP")bi="Circularizing"end;if cL<=s_ then if g2 then bl=g2.position;ct.showWayPoint(c8,g2.position)r6=false;cc=true;t9("Autopilot complete, establishing low orbit")else t9("Autopilot completed, setting orbit",true)b2=false end end elseif bi=="Circularizing"then t9("Autopilot complete, fixing Orbit",true)end elseif bg then local tp=rk;if tp<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pI and cW>2000 then if not qf then qf=true end;dq("Autopilot cancelled to prevent crossing PvP Line")b2="Prevent PvP"pI=cW else pI=cW;return end end;bd=false;if bi~="Braking"then fR("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cz=true end end;local rl=t and bR or qk;if rl>0 then bd=true;if bi~="Accelerating"then bi="Accelerating"fR("apAcc","AP")end;bg=false end else if sR then if not be and g2==nil or not be and g2 and g2.planetname~="Space"then if not cc then bl=vec3(c8.center)+(gm+c8.radius)*cI;tq=q4;tr=cI end;be=true elseif sR and not q9 then bd=true;if bi~="Accelerating"then bi="Accelerating"fR("apAcc","AP")end;if not pX then ct.cmdThrottle(a1,true)bR=fS(a1,2)pX=true;b2=false end end end end elseif b5 and(g2~=nil and g2.planetname~="Space"and cg)then dq("Autopilot complete, starting reentry")fR("apCom","AP")bl=g2.position;b2=false;bf=false;b5=false;r5=false;bi="Aligning"ct.cmdThrottle(0)pX=false;b4=true;cc=true;ct.showWayPoint(c8,g2.position)end;if c0 then cz=true;local tj=0;local ft=vec3(DUPlayer.getWorldPosition())local ts=ft-cO;local tt=vec3(ts):project_on(cH):len()local tu=vec3(ts):project_on(cI):len()local cb=dv(tt*tt+tu*tu)qI(ts:normalize())local lm=40;local tv=cb<lm;local tw=100;local rM=dt((cb-lm)/2,10,tw)pZ=0;local sR=f5(p_)<0.1;if sR and cL<rM and not tv then b2=false;tj=-20 else b2="Follow"tj=0 end;local tx=0;if f5(tj-cS)>tx then sh:inject(tj-cS)local tk=sh:get()pZ=tk end end;if b7 or b8 or ba or br or bu~=nil then local ty=bv;if ty then ty=ty*dt(cL/100,0.1,1)*ch else ty=bt end;if not cg then ty=bt end;q6=cH:project_on_plane(cM):normalize():dot(cK)if q6>100 then c6,c7=cp.computeDistanceAndTime(q6,100,cj,0,0,ty)local tz,dX=cp.computeDistanceAndTime(100,0,cj,0,0,ty*0.55)c6=c6+tz else c6,c7=cp.computeDistanceAndTime(q6,0,cj,0,0,ty*0.55)end;local t3=bc-ci-cN;local tA=200+cL;if ba or cc then tB=2000+cL end;local tC=1;if b9 then tC=dt(cL/100,0.1,1)end;local tj=(utils.smoothstep(t3,-tA,tA)-0.5)*2*Q*tC;if not ba and not cc and not br and cH:dot(cK:normalize())<0.99 then tj=(utils.smoothstep(t3,-tA*dt(20-19*ch*10,1,20),tA*dt(20-19*ch*10,1,20))-0.5)*2*Q*dt(2-ch*10,1,2)*tC end;if not b7 then tj=0 end;if bu~=nil then if cY and not bA then tj=bu else bu=nil end end;cz=true;local tD=pZ;if ba then local tE=bN(cB)local tF,tG=cp.computeDistanceAndTime(cL,tE/3.6,cj,0,0,bt-jt.gravity*9.8*cj)tF=tF==-1 and 5000 or tF;local tH=ci-(jt.noAtmosphericDensityAltitude+tF)local tI=ci>jt.noAtmosphericDensityAltitude+tF*1.35;if tI then tj=R;if cL<=tE/3.6 and cL>tE/3.6-10 and f5(cK:normalize():dot(cH))>0.9 and not cR then bV=false;ct.cmdThrottle(1)end elseif(cR or iF:getTargetSpeed(axisCommandId.longitudinal)~=tE)and not tI and not cg then ct.cmdCruise(tE)end;if cR then if cL>tE/3.6 and not tI then b2="Reentry Limit"if bR>0 then ct.cmdThrottle(0)end else b2=false end else b2=false end;if cN>0 then b2="Reentry vSpd"end;if not pY then tj=-80;if ci<jt.surfaceMaxAltitude+(jt.atmosphereThickness-jt.surfaceMaxAltitude)*0.25 then dq("PARACHUTE DEPLOYED at "..fS(ci,0))ba=false;b8=true;qY=true;ct.cmdThrottle(0)tj=0;cz=q end elseif jt.noAtmosphericDensityAltitude>0 and tI then cz=true elseif not tI then if not cg and(cR or iF:getTargetSpeed(axisCommandId.longitudinal)~=tE)then ct.cmdCruise(tE)end;if cL<tE/3.6+1 then b2=false;pY=false;ba=false;cz=true;ct.cmdThrottle(1)end end end;if cL>iY and not cd and not br and not b8 and u then qI(vec3(cK))end;if cX or(br or cd)and bm>0 and cg then local qP;if cX then if type(cX)=="table"then qP=cX elseif cX<3 and cX>0 then qP=-cM:cross(cK)*5000 elseif cX>=3 then qP=cM:cross(cK)*5000 elseif cX<0 then qP=cK*25000 end elseif g2~=nil then qP=g2.position-cO else qP=c8.center-cO end;local ti=math.deg(qq(cM:normalize(),cK,qP))*2;local lp=math.rad(f5(cT))if cL>aL and cg then local tJ=1000+cL;local tK=(utils.smoothstep(t3-cN*10,-tJ,tJ)-0.5)*2*Q;local tL=dt(90-tK,0,180)q1=dt(ti*2,-tL,tL)local tM=ti;ti=dt(dt(ti,-N*0.80,N*0.80)*math.cos(lp)+4*(cS-tj)*math.sin(math.rad(cT)),-N*0.80,N*0.80)local tN=1;if q1~=0 then tN=f5(lp/q1)end;tN=(90-dt(f5(q1-cT),0,90))/90;local tO=tj;if f5(cT)>90 then tO=-tO end;tj=tN*dt(dt(tO*math.cos(lp),-O*0.8,O*0.8)+f5(dt(f5(tM)*math.sin(lp),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q1=0;ti=dt(ti,-N*0.80,N*0.80)end;local tP=sH-ti;if cX and f5(tP)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and f5(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fR("180Off","BR")return end;if not cA and cL>aL and cg then si:inject(tP)local tl=dt(si:get(),-1,1)p_=p_+tl elseif cg and cf>-1 or cL<aL then qI(qP)elseif cA and cg then if(sH<-N or sH>N)and cg then qI(cK)end;if(sI<-O or sI>O)and cg then tj=dt(cS-sI,cS-O*0.80,cS+O*0.80)end end;if g2~=nil and not cd then local sS=jt:getAltitude(g2.position)local tH=qP:project_on_plane(cM):len()qY=true;if bc<jt.noAtmosphericDensityAltitude and not cd and not b9 and not ba and(tH<=c6 and qP:len()<jt.radius)and(cK:project_on_plane(cM):normalize():dot(qP:project_on_plane(cM):normalize())>0.99 or ky=="Finalizing Approach")then ky="Finalizing Approach"if#bG>0 then if not qf then table.remove(bG,1)end;if#bG>0 then if not qf then qf=2 end;return end end;if not cR or bR>0 then ct.cmdThrottle(0)end;if b7 then ct.ToggleAltitudeHold()br=true end;b2="AP Finalizing"elseif not b9 then b2=false end;if ky=="Finalizing Approach"and(q6<0.1 or tH<0.1 or tQ~=nil and tQ<tH)then fR("bklOn","BL")b8=true;db=true;if g2.heading then dc=g2.heading else dc=nil end;br=false;ky="Proceeding to Waypoint"cZ=false end;tQ=tH end elseif br and not cg and bc>jt.noAtmosphericDensityAltitude and not(cd or ba)then if g2~=nil and c8.name==jt.name then local qP=g2.position-cO;local sS=jt:getAltitude(g2.position)local tH=dv(qP:len()^2-(ci-sS)^2)local ty=bv;if ty then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,ty/2)qY=true;if tH<=c6+cL*sG/2 and cK:project_on_plane(cM):normalize():dot(qP:project_on_plane(cM):normalize())>0.99 then if jt.hasAtmosphere then b2=false;b4=false;pY=true;cc=false;ce=true;b5=false;ct.BeginReentry()end end;tQ=tH end end end;if not cg and cf==-1 and(b7 and bc>jt.noAtmosphericDensityAltitude)and not(cd or bA or ba)then if not cE and not bA then cD=bc;pS=true;if br then q3.VectorToTarget=true end;ct.ToggleIntoOrbit()br=false;pQ=true end end;if cA and cg and cf==-1 and cL>aL and ky~="Finalizing Approach"then qI(cK)tj=dt(cS-sI,cS-O*0.80,cS+O*0.80)end;pZ=tD;local qB=-1;if b8 then local tR=aY or 0.05;if not qa then sa=false;if not cR then ct.cmdThrottle(0)end;if cf==-1 then iF:setTargetGroundAltitude(500)iF:activateGroundEngineAltitudeStabilization(500)end;if not cg then sa=true end;qa=true end;tj=0;local tS=false;local tT=math.abs(q6)if not r and cQ then tS=antigrav.getBaseAltitude()if tS<jt.surfaceMaxAltitude and g2==nil or g2~=nil and jt:getAltitude(g2.position)>tS then tS=false end else tS=false end;if dc then if tT<tR then if cN>-P then b2=false else b2="BL Align BLR"end;if qI(dc,0.001)then dc=nil;cz=q else pZ=0;cz=true end else b2="BL Align Hzn"end;if tS and f5(ci-tS)<250 then b2="AGG Align"end else local tU=false;local tV=30;if tT<10 and sO~=nil and sO>0 then local tW=dt(ch,0.4,2)local ty=bv*dt(cL/100,0.1,1)*tW;local tX=sO*tW+ty-pd;local tY=ty/2-pd;local tZ=cL-dv(f5(tY/2)*20/(0.5*cj))*utils.sign(tY)if tZ<0 then tZ=0 end;local t_;if cL>100 then local u0,dX=cp.computeDistanceAndTime(cL,100,cj,0,0,ty)local u1,dX=cp.computeDistanceAndTime(100,0,cj,0,0,dv(ty))t_=u0+u1 else t_=cp.computeDistanceAndTime(cL,0,cj,0,0,dv(ty))end;if t_<20 then b2=false else local u2=0;if tZ>100 then local u3,dX=cp.computeDistanceAndTime(tZ,100,cj,0,0,tX)local u4,dX=cp.computeDistanceAndTime(100,0,cj,0,0,sO*tW+dv(ty)-pd)u2=u3+u4 else u2,dX=cp.computeDistanceAndTime(tZ,0,cj,0,0,sO*tW+dv(ty)-pd)end;u2=(u2+15+cL*sG)*1.1;local u5=db and g2~=nil and jt:getAltitude(g2.position)>0 and g2.safe;local sS=nil;if tS and tS<ci then sS=tS elseif u5 then sS=jt:getAltitude(g2.position)+250 elseif ci>jt.surfaceMaxAltitude then sS=jt.surfaceMaxAltitude end;if c_ then local u6=jt:getAltitude(c_[1].center)if sS then if u6>sS then sS=u6 end else sS=u6 end end;if sS~=nil then local u7=ci-sS;tU=true;if u7<=u2 or u2==-1 or tT>tR and db then if sS==jt.surfaceMaxAltitude and cN<-P then b2="BL Stop BLR"elseif tT>tR and db then b2="BL AP Hzn"else b2="BL Stop Dist"end else b2=false end end end end;qB=cf;if qB>-1 then b2=false;if not tS and not bn then q7=true;iF:setTargetGroundAltitude(Z)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qB-3<Z and(bC or cL==0)then b8=false;b7=false;b_=0;qZ(0,1)b2="BL Complete"cz=q;db=false;qa=false else if cN<-5 or tT>tR*10 then qZ(0,1)b2="BL Slowing"else b2=false;qZ(-1)end end elseif not tU then if qY and cK:normalize():dot(-go)<0.999 then b2="BL Strong"qI()elseif tT>10 or tT>tR and db then b2="BL hSpd"elseif cN<-P then b2="BL BLR"qZ(0,1)else qZ(-1)b2=false end end end else qa=false end;if b9 or cd then local ku,cb,tm;if bl~=nil then ku,cb=ct.checkLOS((bl-cO):normalize())if ku~=nil then tm=ku.name;if c8 and tm~=c8.name and not cg then cZ="Takeoff LOS blocked by "..tm.." in "..iJ(cb,1)if tm~=jt.name then bl=sD()end end end end;if cQ and not cd then if ci>=bc-50 and cL>iY then b9=false;if not b5 and not br then b2="ATO Agg Arrive"ct.cmdThrottle(0)end end elseif f5(tj)<15 and ci/bc>0.75 then b9=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<iY then b5=true;cd=false;b7=false;b9=false;ct.cmdThrottle(0)elseif cd then ct.cmdThrottle(0)b2="ATO Space"end elseif cd and not cg and c8~=nil and(ku==nil or tm==c8.name)then b5=true;cZ=false;cd=false;b7=false;b9=false;if not cR then ct.cmdThrottle(0)end;bd=true end end;local u8=cf>-1;local u9=cS;if(br or cd or cX)and not u8 and cL>aL and cg then local lp=math.rad(f5(cT))u9=cS*f5(math.cos(lp))+sI*math.sin(lp)end;local ua=dt(tj-u9,-O*0.80,O*0.80)if not cg and br then ua=dt(tj-u9,-85,Q)elseif not cg then ua=dt(tj-u9,-Q,Q)end;if f5(cT)<5 or br or cX or b8 or u8 or b7 then sh:inject(ua)local tk=sh:get()pZ=pZ+tk end end;if antigrav~=nil and not r then if bw==nil or bw<1000 then bw=1000 end;if ub~=bw then ub=bw;qe=ub end end;if(cg or ba or ce)and t and cR then local uc=0;if aU>0 and not ba and ch>0.005 and ch<0.1 and cN>-50 then local ud=bP.getFrictionBurnSpeed()*aU;local ue=cB/3.6;if ud>ue then uc=ud-ue-1 end end;sj:inject(cB/3.6+uc-cK:dot(cH))local uf=sj:get()bU=dt(uf,-1,1)if not d7 then if bU<bR and(ch>0.005 or ba or ce)then bT=true;d7=dt(bU,0.01,1)else bT=false;d7=bR end end;sk:inject(cK:len()-cB/3.6-uc)local ug=dt(sk:get(),0,1)if cg and cN<-80 or(ch>0.005 or ba or ce)then bS=ug end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dt(bU,0.01,1)end;local uh=''local ui=vec3()local uj=rK(axisCommandId.vertical,b_*100)d:setEngineForceCommand("vertical airfoil , vertical ground ",uj,s6)local uk='thrust analog longitudinal 'if bD=="All"or bD=="Longitude"then uk=uk..aV end;local ul=iF:getAxisCommandType(axisCommandId.longitudinal)local um=iF:composeAxisAccelerationFromThrottle(uk,axisCommandId.longitudinal)local un=rX(axisCommandId.lateral,bz)local uo=iF:composeAxisAccelerationFromThrottle(up,axisCommandId.lateral)uh=uh..' , '.."lateral airfoil , lateral ground "ui=ui+un;if ui:len()>constants.epsilon then d:setEngineForceCommand(uh,ui,s6,'','','',s7)end;d:setEngineForceCommand(uk,um,s5)local uq='thrust analog vertical fueled 'local up='thrust analog lateral fueled 'if bD=="All"or bD=="Lateral"then up=up..aW end;if bD=="All"or bD=="Vertical"then uq=uq..aX end;if b_~=0 or qU~=0 or b8 and b2 or not bn and not bC then d:setEngineForceCommand(uq,uj,s5)else d:setEngineForceCommand(uq,vec3(),s5)end;if bz~=0 or qT~=0 then d:setEngineForceCommand(up,un,s5)else d:setEngineForceCommand(up,vec3(),s5)end;if sr==0 then sr=bS end;local ur=-sr*(aQ*cK+aR*sv)d:setEngineForceCommand('brake',ur)else if t then if not d7 then d7=bR end end;local rM=c.getAxisCommandValue(0)if not cR then sk:inject(cK:len()-rM/3.6)local ug=dt(sk:get(),0,1)sr=dt(sr+ug,0,1)end;local ur=-sr*(aQ*cK+aR*sv)d:setEngineForceCommand('brake',ur)local uh=''local ui=vec3()local us=false;local uk='thrust analog longitudinal 'if aV~="none"and(bD=="All"or bD=="Longitude")then uk=uk..aV end;local ul=iF:getAxisCommandType(axisCommandId.longitudinal)if ul==axisCommandType.byThrottle then local um=iF:composeAxisAccelerationFromThrottle(uk,axisCommandId.longitudinal)d:setEngineForceCommand(uk,um,s5)elseif ul==axisCommandType.byTargetSpeed then local um=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)uh=uh..' , '..uk;ui=ui+um;if iF:getTargetSpeed(axisCommandId.longitudinal)==0 or iF:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iF:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then us=true end end;local up='thrust analog lateral 'if aW~="none"and(bD=="All"or bD=="Lateral")then up=up..aW end;local ut=iF:getAxisCommandType(axisCommandId.lateral)if ut==axisCommandType.byThrottle then local uo=iF:composeAxisAccelerationFromThrottle(up,axisCommandId.lateral)d:setEngineForceCommand(up,uo,s5)elseif ut==axisCommandType.byTargetSpeed then local un=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)uh=uh..' , '..up;ui=ui+un end;local uq='thrust analog vertical 'if aX~="none"and(bD=="All"or bD=="Vertical")then uq=uq..aX end;local uu=iF:getAxisCommandType(axisCommandId.vertical)if uu==axisCommandType.byThrottle then local uj=iF:composeAxisAccelerationFromThrottle(uq,axisCommandId.vertical)if b_~=0 or qU~=0 or b8 and b2 then d:setEngineForceCommand(uq,uj,s5,'airfoil','ground','',s7)else d:setEngineForceCommand(uq,vec3(),s5)d:setEngineForceCommand('airfoil vertical',uj,s5,'airfoil','','',s7)d:setEngineForceCommand('ground vertical',uj,s5,'ground','','',s7)end elseif uu==axisCommandType.byTargetSpeed then if b_<0 or qU<0 then d:setEngineForceCommand('hover',vec3(),s5)end;local uv=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)uh=uh..' , '..uq;ui=ui+uv end;if ui:len()>constants.epsilon then if sr~=0 or us or f5(sv:dot(cH))<0.5 then uh=uh..', brake'end;d:setEngineForceCommand(uh,ui,s6,'','','',s7)end end;local uw=aN*(sz-sy)local ux=vec3(bP.getWorldAirFrictionAngularAcceleration())uw=uw-ux;d:setEngineTorqueCommand('torque',uw,s5,'airfoil','','',s7)d:setBoosterCommand('rocket_engine')if c5 and not o then local jP=cJ:len()local uy=0.15;if not cR then local uz=iF:getTargetSpeed(axisCommandId.longitudinal)if jP*3.6>uz*(1-uy)and uA then uA=false;d:toggleBoosters()elseif jP*3.6<uz*(1-uy)and not uA then uA=true;d:toggleBoosters()end else local rl=t and bR*100 or qk;local rM=rl/100;if not cg then rM=rM*bI;if jP>=rM*(1-uy)and uA then uA=false;d:toggleBoosters()elseif jP<rM*(1-uy)and not uA then uA=true;d:toggleBoosters()end else local tE=bN(cB)rM=rM*tE/3.6;if jP>=rM*(1-uy)and uA then uA=false;d:toggleBoosters()elseif jP<rM*(1-uy)and not uA then uA=true;d:toggleBoosters()end end end end end;if uB then for dS,dE in pairs(uB)do pG[dS]=dE end end;cf=qw()return pG end;local function uC(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uD,iE,iF,iG,uE,gJ,fS,eb,du,dt,fR,iI,pF,dq,uF,uG)local bP=DUConstruct;local uH={}local uI=true;local uJ=5;local uK=5;local uL=uJ;local uM=uK;local uN=bQ;local uO=bQ;function uH.landingGear(q7)bn=not bn;if bn then if b5 or br or cd or bA then ct.ResetAutopilots(true)end;bu=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not q7 and cf==-1 then fR("bklOn","BL")qY=true;ba=false;b9=false;bb=false;if b8 then db=not db end;cz=true;bn=false;b8=true else if bW then fR("grOut","LG",1)d.control.deployLandingGears()end;db=false;if cg then cz=q;b2="Landing"end end;if q7 or cf~=-1 and cf>Z-3 or not bC then b8=true end;iF:activateGroundEngineAltitudeStabilization(r1)iF:setTargetGroundAltitude(Z)b7=false elseif bW and not b8 then fR("grOut","LG",1)d.control.deployLandingGears()end else if b8 then b8=false end;if bW then fR("grIn","LG",1)d.control.retractLandingGears()end;iF:activateGroundEngineAltitudeStabilization(r1)if bC then if Z<iF.targetGroundAltitude then iF:setTargetGroundAltitude(iF.targetGroundAltitude)else iF:setTargetGroundAltitude(Y)end else iF:setTargetGroundAltitude(Y)end end end;function uH.startControl(uP)local function uQ(rg)local rh=1;local function uR(uS,rg)local uT={jt.surfaceMaxAltitude+100,jt.spaceEngineMinAltitude-0.01*jt.noAtmosphericDensityAltitude,jt.noAtmosphericDensityAltitude+U,jt.radius*(T-1)+jt.noAtmosphericDensityAltitude}local uU=uS;for dX,dE in ipairs(uT)do if rg and uU>dE then uS=dE elseif uS<dE and not rg then uS=dE;break end end;return uS end;if rg then rh=-1 end;if not r and cQ then if c1 and rg then bw=1000 elseif bw~=nil then bw=bw+rh*uK;if bw<1000 then bw=1000 end;if b7 and bw<bc+10 and bw>bc-10 then bc=bw end else bw=ub+rh*100 end elseif b7 or bb or bA then if bA then if c1 then cD=uR(cD,rg)else cD=cD+rh*uJ end;if cD<jt.noAtmosphericDensityAltitude then cD=jt.noAtmosphericDensityAltitude end else if c1 and cg then bc=uR(bc,rg)else bc=bc+rh*uJ end end else iF:updateTargetGroundAltitudeFromActionStart(rh*1.0)end end;local function uV(uW)if not cg then dq("Flight Assist in Atmo only")return end;local dB=type(uW)if cX==nil then if dB=="table"then if b5 or br then ct.ToggleAutopilot()end;fR("180On","BR")elseif uW==1 then fR("bnkLft","BR")else fR("bnkRht","BR")end;if not b7 and not b5 and not br then ct.ToggleAltitudeHold()if dB~="table"then uW=uW+1 end end;cX=uW else fR("180Off","BR")cX=nil end end;local function uX()if iG()then c9=0;ca=0;uE(bj)elseif iE()and y then cy=false;cx=false end;c1=false end;if uP=="gear"then cv.landingGear()elseif uP=="light"then if nA then if iE()then if DUPlayer.isFrozen()then DUPlayer.freeze(false)dq("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(true)dq("Player Frozen, pitch/yaw/roll enabled")end else dq("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uP=="forward"then if nA and not cg and not b5 then b4=not b4;b3=false else bX=bX-1 end elseif uP=="backward"then if nA then if not cg then if not b5 then b3=not b3;b4=false else b6=not b6 end else uV(-cK*5000)end else bX=bX+1 end elseif uP=="left"then if nA then uV(1)else bY=bY-1 end elseif uP=="right"then if nA then uV(3)else bY=bY+1 end elseif uP=="yawright"then bZ=bZ-1;dc=nil elseif uP=="yawleft"then bZ=bZ+1;dc=nil elseif uP=="straferight"then iF:updateCommandFromActionStart(axisCommandId.lateral,1.0)bz=1 elseif uP=="strafeleft"then iF:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bz=-1 elseif uP=="up"then ct.vertical(1)if cf-3<Z and ci>0 and bn then cv.landingGear()end elseif uP=="down"then ct.vertical(-1)elseif uP=="groundaltitudeup"then uQ()elseif uP=="groundaltitudedown"then uQ(true)elseif uP=="option1"then uY=false;if nA and c1 then local uZ=""for M=1,#d2 do uZ=uZ.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fS(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..uZ)return end;cs.adjustAutopilotTargetIndex()elseif uP=="option2"then uY=false;if nA and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;dq("Deboarded All Passengers")return end;cs.adjustAutopilotTargetIndex(1)elseif uP=="option3"then uY=false;if nA and c1 then local uZ=""for M=1,#d3 do uZ=uZ.."| ID: "..d3[M].." Mass: "..fS(bP.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..uZ)return end;if x then if w then w=false else w=true end end elseif uP=="option4"then uY=false;if nA and c1 then for M=1,#d3 do bP.forceUndock(d3[M])end;dq("Undocked all ships")return end;cX=nil;if not cg and(bm>0 or#bG>0)and not b5 and not br and not cd and not bA then ct.cmdThrottle(1)end;ct.ToggleAutopilot()elseif uP=="option5"then uY=false;if nA and c1 then dm=false;ct.ToggleLockPitch()return end;if bQ-uO<1.5 then if dm then dm=-1;dq("Retrograde Alignment lock to "..bk)return end end;uO=bQ;if dm then dm=false;dq("Alignment cancelled")elseif not b5 and not br and not cd and not bA and not ba and not ce and not b7 then dm=1;dq("Alignment lock to "..bk)else dq("Disengage autopilot before using Alignment Lock")end elseif uP=="option6"then uY=false;if nA and c1 then if shield then cw.ventShield()else dq("No shield found")end;return end;ct.ToggleAltitudeHold()elseif uP=="option7"then uY=false;if nA and c1 then if shield then shield.toggle()return else dq("No shield found")return end end;E=not E;if E then dq("Collision System Enabled")else dq("Collision System Secured")end elseif uP=="option8"then uY=false;if nA and c1 then if bm>0 and g2~=nil then ct.routeWP()else dq("Select a saved wp on IPH to add to or remove from route")end;return end;bC=not bC;if not bC then dq("DeCoupled Mode - Ground Stabilization off")iF:deactivateGroundEngineAltitudeStabilization()fR("gsOff","GS")else dq("Coupled Mode - Ground Stabilization on")iF:activateGroundEngineAltitudeStabilization(r1)de=true;fR("gsOn","GS")end elseif uP=="option9"then uY=false;if nA and c1 then iF:resetCommand(axisCommandId.longitudinal)iF:resetCommand(axisCommandId.lateral)iF:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()if ck then fR("gyOn","GA")else fR("gyOff","GA")end else dq("No gyro found")end elseif uP=="lshift"then if nA then c1=true end elseif uP=="brake"then if b0 or nA then ct.BrakeToggle("Manual")elseif not b2 then ct.BrakeToggle("Manual")else b2="Manual"end elseif uP=="lalt"then uY=true;nA=true;if not iE()and not j and g=="keyboard"then uE(true)end elseif uP=="booster"then if nA then if uF then uF.toggle()if uF.isActive()then dq("Transponder On")else dq("Transponder Off")end else dq("No transponder found")end else if o then d:toggleBoosters()elseif not c5 then if not uA then d:toggleBoosters()uA=true end;c5=true else if uA then d:toggleBoosters()uA=false end;c5=false end end elseif uP=="stopengines"then local function u_()if bQ-uN<1.5 then fR("clear","CA")ct.clearAll()end end;u_()uN=bQ;if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if nA then if cB>0 then cB=0 else cB=V end elseif bR~=0 then iF:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(1)end else if iF:getTargetSpeed(axisCommandId.longitudinal)~=0 then iF:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(bI*3.6)end end end elseif uP=="speedup"then ct.changeSpd()elseif uP=="speeddown"then ct.changeSpd(true)elseif uP=="antigravity"and not r then if antigrav~=nil then ct.ToggleAntigrav()else dq("No antigrav found")end elseif uP=="leftmouse"then c2=true;if c1 then uX()uY=false else c1=true;bj=iG()uE(true)end end end;function uH.stopControl(uP)local function v0()if not r and cQ then uM=uK end;if b7 or bb or bA then uL=uJ end end;if uP=="forward"then bX=0 elseif uP=="backward"then bX=0 elseif uP=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif uP=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif uP=="yawright"then bZ=0 elseif uP=="yawleft"then bZ=0 elseif uP=="straferight"then iF:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bz=0 elseif uP=="strafeleft"then iF:updateCommandFromActionStop(axisCommandId.lateral,1.0)bz=0 elseif uP=="up"then ct.vertical(0,-1)elseif uP=="down"then ct.vertical(0,1)elseif uP=="groundaltitudeup"then v0()uY=false elseif uP=="groundaltitudedown"then v0()uY=false elseif uP=="brake"then if not b0 and not nA then if b2 then ct.BrakeToggle()else b2=false end end elseif uP=="lalt"then if c1 then c1=false end;if not iE()and j then if uY then if iG()then uE(false)else uE(true)end else uY=true end elseif not iE()and not j and g=="keyboard"then uE(false)end;nA=false end end;function uH.loopControl(uP)local function v1(rg)local rh=1;if rg then rh=-1 end;if not r and cQ then if bw~=nil then bw=bw+rh*uM;if bw<1000 then bw=1000 end;if b7 and bw<bc+10 and bw>bc-10 then bc=bw end;uM=dt(uM*1.05,uK,50)else bw=ub+rh*100 end elseif b7 or bb or bA then if bA then cD=cD+rh*uL;if cD<jt.noAtmosphericDensityAltitude then cD=jt.noAtmosphericDensityAltitude end else bc=bc+rh*uL end;uL=dt(uL*1.05,uJ,50)else iF:updateTargetGroundAltitudeFromActionLoop(rh*1.0)end end;local function v2(rg)local rh=1;if rg then rh=-1 end;if not c1 then if t and not nA then bR=dt(bR+rh*aF/100,-1,1)else iF:updateCommandFromActionLoop(axisCommandId.longitudinal,rh*aF)end end end;if uP=="groundaltitudeup"then if not c1 then v1()end elseif uP=="groundaltitudedown"then if not c1 then v1(true)end elseif uP=="speedup"then v2()elseif uP=="speeddown"then v2(true)end end;function uH.inputTextControl(rf)local function v3(v4,ft,gw)local function v5(ft)local dK=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dL='::pos{'..dK..','..dK..','..dK..','..dK..','..dK..'}'local e0,e1,e8,e9,ea=eb(ft,dL)if e0=="0"and e1=="0"then return vec3(du(e8),du(e9),du(ea))end;e9=math.rad(e9)e8=math.rad(e8)local jt=e[du(e0)][du(e1)]local f1=math.cos(e8)local v6=vec3(f1*math.cos(e9),f1*math.sin(e9),math.sin(e8))return jt.center+(jt.radius+ea)*v6 end;local fU=v5(ft)return cs.AddNewLocation(v4,fU,gw)end;local M;local v7,it=nil,nil;local v8="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations.\n".."/trans (whatever) - shows the current transponder setting, whatever, if present, is the new tag that is set.\n".."/pipecenter - Shows a waypoint to closest pipe center and prints loc in lua chat and sets it to 1-Temp in IPH for use with autopilot"M=string.find(rf," ")v7=rf;if M~=nil and string.find(rf,"::")~=1 then v7=string.sub(rf,0,M-1)it=string.sub(rf,M+1)end;if v7=="/help"or v7=="/commands"then for kt in string.gmatch(v8,"([^\n]+)")do a.print(kt)end;return elseif v7=="/setname"then if it==nil or it==""then dq("Usage: ah-setname Newname")return end;if bm>0 and g2~=nil then cs.UpdatePosition(it)else dq("Select a saved target to rename first")end elseif shield and v7=="/resist"then cw.setResist(it)elseif v7=="/addlocation"or string.find(rf,"::pos")~=nil then local gw=false;local v4="0-Temp"if it==nil or it==""or v7~="/addlocation"then it=v7;gw=true end;if not dm and not b5 and not br and not cd and not bA and not ba and not ce then M=string.find(it,"::")if not gw then v4=string.sub(it,1,M-2)end;local ft=string.sub(it,M)ft=ft:gsub("%s+","")v3(v4,ft,gw)else dq("Disengage Autopilot before adding waypoints")end elseif v7=="/agg"then if it==nil or it==""then dq("Usage: /agg targetheight")return end;it=du(it)if it<1000 then it=1000 end;bw=it;dq("AGG Target Height set to "..it)elseif v7=="/G"then if it==nil or it==""then dq("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if it=="dump"then for dS,dE in pairs(iI())do if type(dE.get())=="boolean"then if dE.get()==true then a.print(dS.." true")else a.print(dS.." false")end elseif dE.get()==nil then a.print(dS.." nil")else a.print(dS.." "..dE.get())end end;return end;M=string.find(it," ")local v9=string.sub(it,0,M-1)local va=string.sub(it,M+1)for dS,dE in pairs(iI())do if dS==v9 then local vb=type(dE.get())if vb=="number"then va=du(va)if dS=="AtmoSpeedLimit"then cB=va end end;dq("Variable "..v9 .." changed to "..va)if dS=="MaxGameVelocity"and va~=-1 then va=va/3.6;if va>df-0.2 then va=df-0.2;dq("Updated "..v9 .." changed to "..fS(va*3.6,1))end end;if vb=="boolean"then if string.lower(va)=="true"then va=true else va=false end end;dE.set(va)return end end;dq("No such global variable: "..v9)elseif v7=="/deletewp"then if bm>0 and g2~=nil then cs.ClearCurrentPosition()else dq("Select a custom wp to delete first in IPH")end elseif v7=="/copydatabank"then if dbHud_2 then pF(true)else dq("Spare Databank required to copy databank")end elseif v7=="/iphWP"then if bm>0 then a.print(ct.showWayPoint(c8,bl,true))a.print(json.encode(bl))dq("::pos waypoint shown in lua chat in local and world format")else dq("No target selected in IPH")end elseif v7=="/trans"then if uF then if it==nil or it==""then dq("Current tag: "..uG(uF.getTags()))return else uF.setTags({it})dq("Transponder tag set to: "..it)end else dq("No transponder found.")end elseif v7=="/createPrivate"then local vc="privatelocations = {\n"local vd=""if#d9>0 then for dS,dE in pairs(d9)do vc=vc.."{position = {x = "..dE.position.x..", y = "..dE.position.y..", z = "..dE.position.z.."},\n ".."name = '"..dE.name.."',\n planetname = '"..dE.planetname.."',\n gravity = "..dE.gravity..",\n"if dE.heading then vc=vc.."heading = {x = "..dE.heading.x..", y = "..dE.heading.y..", z = "..dE.heading.z.."},\n"end;if dE.safe then vc=vc.."safe = true},\n"else vc=vc.."safe = false},\n"end end end;vd=#d9 .."-Private "if it=="all"then for dS,dE in pairs(bq)do vc=vc.."{position = {x = "..dE.position.x..", y = "..dE.position.y..", z = "..dE.position.z.."},\n ".."name = '*"..dE.name.."',\n planetname = '"..dE.planetname.."',\n gravity = "..dE.gravity..",\n"if dE.heading then vc=vc.."heading = {x = "..dE.heading.x..", y = "..dE.heading.y..", z = "..dE.heading.z.."},\n"end;if dE.safe then vc=vc.." safe = true},\n"else vc=vc.."safe = false},\n"end end;vd=vd..#bq.."-Public "end;vc=vc.."}\n return privatelocations"if uD then uD.setHTML(vc)end;dq(vd.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c4=7 elseif v7=="/pipecenter"then if b5 then dq("Disengage autopilot before using /pipecenter")elseif di~=nil then local ve=di;local ft="::pos{0,0,"..ve["x"]..","..ve["y"]..","..ve["z"].."}"v3("1-ClosestPipeCenter",ft,true)if dj then ve=dj;ft="::pos{0,0,"..ve["x"]..","..ve["y"]..","..ve["z"].."}"v3("2-"..dk.name.."PipeCenter",ft,true)ft=cO+dk.center-ve;ft="::pos{0,0,"..ft["x"]..","..ft["y"]..","..ft["z"].."}"v3("3-"..dk.name.."PipeParallel",ft,true)end else dq("No Pipe Center known")end end end;function uH.tagTick()if bD=="Off"then bD="All"elseif bD=="All"then bD="Longitude"elseif bD=="Longitude"then bD="Lateral"elseif bD=="Lateral"then bD="Vertical"else bD="Off"end;dq("Extra Engine Tags: "..bD)c.stopTimer("tagTick")end;if vf then for dS,dE in pairs(vf)do uH[dS]=dE end end;return uH end;local function vg(d,b,c,e,vBooster,hover,pE,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iB,uD,uF)local a=DUSystem;local bP=DUConstruct;local vh=DUPlayer;local vi=DULibrary;local vj={}local ds=string.format;local iC=json.decode;local uG=json.encode;local oO=b.getElementMaxHitPointsById;local iD=b.getElementMassById;local iE=d.control.isRemoteControlled;local eb=string.match;local gJ=a.destroyWidgetPanel;local fP=a.updateData;local fQ=a.addDataToWidget;local uE=a.lockView;local iG=a.isViewLocked;local dv=math.sqrt;local du=tonumber;local f5=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local f0=math.atan;local bM=a.getArkTime;local dt=utils.clamp;local iF=d.axisCommandManager;local gL=13;local iL=b.getElementIdList()local iM=0;local function dw(eJ,eK)if eJ==0 then return f5(eK)<1e-09 elseif eK==0 then return f5(eJ)<1e-09 else return f5(eJ-eK)<math.max(f5(eJ),f5(eK))*dJ end end;local function fS(dK,vk)local rh=10^(vk or 0)return bN(dK*rh+0.5)/rh end;local function iH(vl,vm)for dS,dE in pairs(vm)do if type(dS)=="string"then vl[dS]=dE else vl[#vl+1]=vm[dS]end end;return vl end;local function iI(vn)local vo={}if not vn then iH(vo,L)iH(vo,ab)iH(vo,aD)iH(vo,a_)return vo elseif vn=="boolean"then return L elseif vn=="handling"then return ab elseif vn=="hud"then return aD elseif vn=="physics"then return a_ end end;local function dq(ta)if not ta then return end;if c3~="empty"then if not string.find(c3,ta)then c3=c3 .."\n"..ta;c4=7 end else c3=ta end end;local function pF(vp)local function vq(vr)for dS,dE in pairs(vr)do dbHud_1.setStringValue(dS,uG(dE.get()))if vp and dbHud_2 then dbHud_2.setStringValue(dS,uG(dE.get()))end end end;if dbHud_1 then vq(bJ)vq(iI())a.print("Saved Variables to Datacore")if vp and dbHud_2 then dq("Databank copied.  Remove copy when ready.")end end end;local function fR(vs,vt,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..vs..".mp3")end;local function gK(hE,hF,rf,jD,vu)return ds([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jD or"",hE,hF,vu or"",rf)end;local function iJ(cb,vv)vv=vv or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fS(cb,vv)..unit end;local function iK(vw)local vx=0;local vy=0;local vz=0;if vw<60 then vw=bN(vw)elseif vw<3600 then vx=bN(vw/60)vw=bN(vw%60)elseif vw<86400 then vy=bN(vw/3600)vx=bN(vw%3600/60)else vz=bN(vw/86400)vy=bN(vw%86400/3600)end;if vz>365 then return">1y"elseif vz>0 then return vz.."d "..vy.."h "elseif vy>0 then return vy.."h "..vx.."m "elseif vx>0 then return vx.."m "..vw.."s"elseif vw>0 then return vw.."s"else return"0s"end end;local function vA()if radar_1 then cu=gI(b,a,c,radar_1,radar_2,warpdrive,f5,gJ,dv,gK,du,gL,fR,dq)end end;function vj.radarSetup()vA()end;function vj.onStart()local vB=false;local function vC()local function vD(vE)local vF=dbHud_1.hasKey;for dS,dE in pairs(vE)do if vF(dS)then local dN=iC(dbHud_1.getStringValue(dS))if dN~=nil then dE.set(dN)vB=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vD(iI())coroutine.yield()vD(bJ)else vD(bJ)dq("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c4=5;vB=false end;coroutine.yield()if vB then dq("Loaded Saved Variables")elseif not f then dq("Databank Found, No Saved Variables Found\nVariables will save to Databank on standing")c4=5 end;if#bq>0 then da=iH(da,bq)end else dq("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;b0=k;g=string.lower(g)cz=q;cB=V;if bx+180<bQ then bv=0 end;bx=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then dq("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c4=7 end;if antigrav and not r then if bw==nil then bw=ci end;antigrav.setTargetAltitude(bw)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d9>0 then da=iH(da,d9)end end;ky="Proceeding to Waypoint"if a0==-1 then bI=bP.getMaxSpeed()end end;local function vG()local function vH(vI,vJ)if vI>vJ then vJ=vI end;local vK,vL=0,0;if a6>0 then vK=a6*0.05 end;if a7>0 then vL=a7*0.05 end;vJ=vJ*(1-(vK+vL))return vJ end;local vM=b.getElementNameById;local vN=at~=0 and au~=0;local vO=_G["atmofueltank_size"]local vP=_G["spacefueltank_size"]local vQ=_G["rocketfueltank_size"]for dS in pairs(iL)do local type=b.getElementDisplayNameById(iL[dS])if eb(type,'^.*Atmospheric Engine$')then if eb(tostring(b.getEngineTagsById(iL[dS])),'^.*vertical.*$')and b.getElementForwardById(iL[dS])[3]>0 then cP=true end end;if eb(type,'^.*Space Engine$')then cG=true;if eb(tostring(b.getEngineTagsById(iL[dS])),'^.*vertical.*$')then local vR=b.getElementForwardById(iL[dS])if vR[3]<0 then vS=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local oQ=oO(iL[dS])if oQ>10000 then gL=110 elseif oQ>1000 then gL=55 elseif oQ>150 then gL=27 end end;iM=iM+oO(iL[dS])if vN and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local oQ=oO(iL[dS])local fa=iD(iL[dS])local vI=0;local oj=bM()if type=="Atmospheric Fuel Tank"then local vJ=400;local vT=35.03;if oQ>10000 then vJ=51200;vT=5480 elseif oQ>1300 then vJ=6400;vT=988.67 elseif oQ>150 then vJ=1600;vT=182.67 end;vI=fa-vT;if a3>0 then vJ=vJ+vJ*a3*0.2 end;vJ=vH(vI,vJ)local gv=vM(iL[dS])local oh=0;for oi=1,vO do if gv==iC(c["atmofueltank_"..oi].getWidgetData()).name then oh=oi;break end end;local vU={iL[dS],string.sub(gv,1,12),vJ,vT,vI,oj,oh}cl[#cl+1]=vU end;if type=="Rocket Fuel Tank"then local vJ=320;local vT=173.42;if oQ>65000 then vJ=40000;vT=25740 elseif oQ>6000 then vJ=5120;vT=4720 elseif oQ>700 then vJ=640;vT=886.72 end;vI=fa-vT;if a5>0 then vJ=vJ+vJ*a5*0.1 end;vJ=vH(vI,vJ)local gv=vM(iL[dS])local oh=0;for oi=1,vQ do if gv==iC(c["rocketfueltank_"..oi].getWidgetData()).name then oh=oi;break end end;local vU={iL[dS],string.sub(gv,1,12),vJ,vT,vI,oj,oh}cn[#cn+1]=vU end;if type=="Space Fuel Tank"then local vJ=600;local vT=35.03;if oQ>10000 then vJ=76800;vT=5480 elseif oQ>1300 then vJ=9600;vT=988.67 elseif oQ>150 then vJ=2400;vT=182.67 end;vI=fa-vT;if a4>0 then vJ=vJ+vJ*a4*0.2 end;vJ=vH(vI,vJ)local gv=vM(iL[dS])local oh=0;for oi=1,vP do if gv==iC(c["spacefueltank_"..oi].getWidgetData()).name then oh=oi;break end end;local vU={iL[dS],string.sub(gv,1,12),vJ,vT,vI,oj,oh}cm[#cm+1]=vU end end end;if not cP then bb,b1=false,false end end;local function vV()if gyro~=nil then ck=gyro.isActive()end;if not bC then iF:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then uE(true)else uE(false)end;if door and(cg or not cg and ci<10000)then for dX,dE in pairs(door)do dE.toggle()end end;if switch then for dX,dE in pairs(switch)do dE.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dX,dE in pairs(forcefield)do dE.toggle()end end;if antigrav then cQ=antigrav.isActive()if cQ and not r then antigrav.showWidget()end end;if iE()and l then vh.freeze(true)else vh.freeze(false)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bn=d.control.isAnyLandingGearDeployed()or not bC or cf~=-1 and cf-3<Z;local vW=cJ:len()<30;if cf~=-1 and vX or(not cg or not vX)and vW then b2="Startup"else b2=false end;iF:setTargetGroundAltitude(Z)oC=cg end;local function vY()local vZ={}local function v_()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local function w0()return{id=1000,name={"Aegis","Aegis","Aegis"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=1000,satellites={},center={13856549.3576,7386341.6738,-258459.8925},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local w1={[1]=6637,[2]=3426,[4]=7580,[26]=4242,[27]=4150,[3]=21452,[6]=4498,[7]=6285,[8]=3434,[9]=5916}for w2,w3 in pairs(e)do e[w2][0]=v_()e[w2][0].systemId=w2;e[w2][1000]=w0()vZ[w2]={}for w4,jt in pairs(e[w2])do jt.gravity=jt.gravity/9.8;jt.center=vec3(jt.center)jt.name=jt.name[1]jt.noAtmosphericDensityAltitude=jt.atmosphereThickness;jt.spaceEngineMinAltitude=w1[jt.id]or 0.5353125*jt.atmosphereThickness;jt.planetarySystemId=w2;jt.bodyId=jt.id;vZ[w2][w4]=jt;if l7==nil or jt.center.x<l7 then l7=jt.center.x end;if l6==nil or jt.center.x>l6 then l6=jt.center.x end;if la==nil or jt.center.y<la then la=jt.center.y end;if l9==nil or jt.center.y>l9 then l9=jt.center.y end;if jt.center and jt.name~="Space"then d4[#d4+1]=jt end end end;el=dr(d,b,c,a,ds,dt,du,dv,dw)co=el(vZ)fV=co[0]cp=f4(d,b,c,a,dv,f5)cq=fp(d,b,c,a,ds,dt,du,dv,dw)cs=fO(d,b,c,a,dbHud_1,e,fP,fQ,bN,du,dv,fR,fS,dq)jt=co[0]:closestBody(bP.getWorldPosition())end;w5=false;w6=coroutine.create(function()iF:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vC()coroutine.yield()vG()coroutine.yield()ct=pD(d,b,c,e,vBooster,hover,pE,antigrav,dbHud_1,f5,bN,bO,iE,f0,bM,dt,iF,fP,iG,dv,fS,fR,iH,dw,iJ,iK,pF,iC,dq)vV()coroutine.yield()vY()vA()if iA then cr=iA(d,b,c,a,e,antigrav,hover,shield,warpdrive,iB,f5,bN,ds,iC,bO,iD,iE,f0,bM,dt,iF,fQ,fP,gJ,iG,dv,fS,gK,fR,iH,iI,iJ,iK,iL,iM,dq)end;if cr then cr.ButtonSetup()end;cv=uC(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uD,iE,iF,iG,uE,gJ,fS,eb,du,dt,fR,iI,pF,dq,uF,uG)if shield then cw=ij(shield,eb,bN,dq)end;coroutine.yield()c.hideWidget()a.showScreen(true)a.showHelper(false)if uD then uD.setCenteredText("")end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bP.setDockingMode(aa)if shield then c.setTimer("shieldTick",0.0166667)end;if w7 then w8.ExtraOnStart()end;local function w9()if bH[1]==0 then ct.cmdThrottle(bH[2])else if ch>0 then cB=bH[2]ct.cmdThrottle(1)end end end;kq=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if kq then if cf>-1 and cL<1 and cf-3<Z then c.exit()else if J then w9()else if ch==0 then b2="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bH[3]+3>bM()then w9()end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()local wa;wa=#d2>1 and"Passengers: "..#d2-1 .." "or""wa=wa..(#d3>0 and"Ships: "..#d3 or"")if wa~=""then dq("NOTICE: Docked "..wa)end;fR("start","SU")end)coroutine.resume(w6)end;function vj.onUpdate()if w5 then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iF:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and nC~=wb then a.setScreen(nC)end;wb=nC;if kq and not J and ch>0 and cf==-1 then cv.landingGear()end;if kq and cf>-1 and cL<1 and cf-3<Z then c.exit()end;if w7 then w8.ExtraOnUpdate()end else local i8=coroutine.status(w6)if i8=="suspended"then local dT,i9=coroutine.resume(w6)if i9 then a.print("ERROR STARTUP: "..i9)end elseif i8=="dead"then w5=true end end end;function vj.onFlush()if w5 then ct.onFlush()if w7 then w8.ExtraOnFlush()end end end;function vj.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dX,dE in pairs(door)do dE.toggle()end end;if switch then for dX,dE in pairs(switch)do dE.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dX,dE in pairs(forcefield)do dE.toggle()end end;w=d6;local wc=0;if kq then wc=bM()end;if iF:getAxisCommandType(0)==0 then bH={0,bR,wc}else bH={1,iF:getTargetSpeed(axisCommandId.longitudinal),wc}end;pF()if mu then mu.activate()end;if z then ct.showWayPoint(jt,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if w7 then w8.ExtraOnStop()end;fR("stop","SU")end;function vj.controlStart(uP)if w5 then cv.startControl(uP)end end;function vj.controlStop(uP)if w5 then cv.stopControl(uP)end end;function vj.controlLoop(uP)if w5 then cv.loopControl(uP)end end;function vj.controlInput(rf)if w5 then cv.inputTextControl(rf)end end;function vj.radarEnter(e1)if cu then cu.onEnter(e1)end end;function vj.radarLeave(e1)if cu then cu.onLeave(e1)end end;function vj.onTick(wd)if wd=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif wd=="oneSecond"then if cr then cr.OneSecondTick()end elseif wd=="msgTick"then if cr then cr.MsgTick()end elseif wd=="animateTick"then if cr then cr.AnimateTick()end elseif wd=="hudTick"then if cr then cr.hudtick()end elseif wd=="apTick"then if ct then ct.APTick()end elseif wd=="shieldTick"then cw.shieldTick()elseif wd=="tagTick"then cv.tagTick()elseif wd=="contact"then cu.ContactTick()end end;if w7 then for dS,dE in pairs(w7)do vj[dS]=dE end end;return vj end;function script.onStart()w8.onStart()end;function script.onOnStop()w8.onStop()end;function script.onTick(wd)w8.onTick(wd)end;function script.onOnFlush()w8.onFlush()end;function script.onOnUpdate()w8.onUpdate()end;function script.onActionStart(uP)w8.controlStart(uP)end;function script.onActionStop(uP)w8.controlStop(uP)end;function script.onActionLoop(uP)w8.controlLoop(uP)end;function script.onInputText(rf)w8.controlInput(rf)end;function script.onEnter(e1)w8.radarEnter(e1)end;function script.onLeave(e1)w8.radarLeave(e1)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)w8=vg(d,core,unit,e,vBooster,hover,pE,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iB,uD,we)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
