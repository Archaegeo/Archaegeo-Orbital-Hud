name: ArchHud - Archaegeo v1.153 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export: (Default: false)
        userControlScheme = "virtual joystick" --export: (Default: "virtual joystick") Set to "virtual joystick", "mouse", or "keyboard"
        freeLookToggle = true --export: (Default: true)
        BrakeToggleDefault = true --export: (Default: true)
        RemoteFreeze = false --export: (Default: false)
        RemoteHud = true --export: (Default: true)
        brightHud = false --export: (Default: false)
        VanillaRockets = false --export: (Default: false)
        InvertMouse = false --export: (Default: false)
        autoRollPreference = false --export: (Default: false)
        turnAssist = true --export: (Default: true)
        ExternalAGG = false --export: (Default: false)
        UseSatNav = false --export: (Default: false)
        ShouldCheckDamage = true --export: (Default: true)
        CalculateBrakeLandingSpeed = false --export: (Default: false)
        AtmoSpeedAssist = true --export: (Default: true)
        ForceAlignment = false --export: (Default: false)
        DisplayDeadZone = true --export: (Default: true)
        showHud = true --export: (Default: true) 
        ShowOdometer = true --export: (Default: true)
        hideHudOnToggleWidgets = true --export: (Default: true)
        ShiftShowsRemoteButtons = true --export: (Default: true)
        DisplayOrbit = true --export: (Default: true) 
        YawStallAngle = 35 --export: (Default: 35)
        PitchStallAngle = 35 --export: (Default: 35)
        brakeLandingRate = 30 --export: (Default: 30)
        MaxPitch = 30 --export: (Default: 30)
        TargetOrbitRadius = 1.4 --export: (Default: 1.4)
        LowOrbitHeight = 1000 --export: (Default: 1000)
        AtmoSpeedLimit = 1050 --export: (Default: 1050)
        SpaceSpeedLimit = 30000 --export: (Default: 30000).
        AutoTakeoffAltitude = 1000 --export: (Default: 1000)
        TargetHoverHeight = 50 --export: (Default: 50)
        LandingGearGroundHeight = 0 --export: (Default: 0)
        MaxGameVelocity = 8333.00 --export: (Default: 8333.00)
        AutopilotInterplanetaryThrottle = 1.0 --export: (Default: 1.0)
        warmup = 32 --export: (Default: 32)
        fuelTankHandlingAtmo = 0 --export: (Default: 0)
        fuelTankHandlingSpace = 0 --export: (Default: 0)
        fuelTankHandlingRocket = 0 --export: (Default: 0)
        ContainerOptimization = 0 --export: (Default: 0)
        FuelTankOptimization = 0 --export: (Default: 0)
        ResolutionX = 1920 --export: (Default: 1920)
        ResolutionY = 1080 --export: (Default: 1080) 
        circleRad = 400 --export: (Default: 400)
        SafeR = 130 --export: (Default: 130)
        SafeG = 224 --export: (Default: 224)
        SafeB = 255 --export: (Default: 255)
        PvPR = 255 --export: (Default: 255)
        PvPG = 0 --export: (Default: 0)
        PvPB = 0 --export: (Default: 0)
        centerX = 960 --export: (Default: 960)
        centerY = 540 --export: (Default: 540)
        throtPosX = 1300 --export: (Default: 1300)
        throtPosY = 540 --export: (Default: 540)
        vSpdMeterX = 1525  --export: (Default: 1525)
        vSpdMeterY = 325 --export: (Default: 325)
        altMeterX = 550  --export: (Default: 550)
        altMeterY = 540 --export: (Default: 540) 
        fuelX = 100 --export: (Default: 100)
        fuelY = 300 --export: (Default: 300)
        DeadZone = 50 --export: (Default: 50)
        OrbitMapSize = 250 --export: (Default: 250)
        OrbitMapX = 75 --export: (Default: 75)
        OrbitMapY = 0 --export: (Default: 0)
        speedChangeLarge = 5 --export: (Default: 5)
        speedChangeSmall = 1 --export: (Default: 1)
        MouseXSensitivity = 0.003 --export: (Default: 0.003)
        MouseYSensitivity = 0.003 --export: (Default: 0.003)
        autoRollFactor = 2 --export: (Default: 2)
        rollSpeedFactor = 1.5 --export: (Default: 1.5)
        autoRollRollThreshold = 0 --export: (Default: 0)
        minRollVelocity = 150 --export: (Default: 150)    
        turnAssistFactor = 2 --export: (Default: 2)
        TrajectoryAlignmentStrength = 0.002 --export: (Default: 0.002)
        torqueFactor = 2 --export: (Default: 2)
        pitchSpeedFactor = 0.8 --export: (Default: 0.8)
        yawSpeedFactor = 1 --export: (Default: 1)
        brakeSpeedFactor = 3 --export: (Default: 3)
        brakeFlatFactor = 1 --export: (Default: 1)
        DampingMultiplier = 40 --export: (Default: 40) 
        apTickRate = 0.0166667 --export: (Default: 0.0166667)  
        hudTickRate = 0.0666667 --export: (Default: 0.0666667)
        ExtraLongitudeTags = "none" --export: (Default: "none")
        ExtraLateralTags = "none" --export: (Default: "none")
        ExtraVerticalTags = "none" --export: (Default: "none")
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.153;SetWaypointOnExit=true;IntruderAlertSystem=false;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;showHelp=true;safeMass=0;local b={"showHelp","VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local tostring=tostring;local o=utils.round;local p=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local function x(y,z)local A=10^(z or 0)return d(y*A+0.5)/A end;local B=16;local C=SafeR;local D=SafeB;local E=SafeG;local F=0;local G=0;local H=false;local I=0;local J=false;local K=x(ResolutionX/2,0)local L=x(ResolutionY/2,0)local M=false;local N=55;local O=false;local P=false;local Q=0;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=false;local Y=false;local Z="empty"local a0=5;local a1=5;local a2=a0;local a3=a1;local a4=false;local a5,a6=0;local a7,a8=0;local a9=nil;local aa=0;local ab=0;local ac=false;local ad=0;local ae=0;local af=0;local ag=3;local ah=0;local ai=""local aj=""local ak=0;local al=false;local am=false;local an=false;local ao=-1;local ap=false;local aq=""local ar=j()>0;local as=j()local at=core.getAltitude()local au=core.getElementIdList()local av=p()local aw=core.getConstructMass()local ax=false;local ay=nil;local az=false;local aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]local aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local aC={}local aD=0;local aE=0;local aF=""local aG=true;local aH={}local aI={}local aJ={}local aK=ResolutionX;local aL=ResolutionY;local aM=false;local aN=false;local aO=nil;local aP={}local aQ={}local aR={}local aS=0;local aT=false;local aU={}local aV={}local aW=d(1/apTickRate)*2;local aX={}local aY={}local aZ={}local a_={}local b0=false;local b1=0;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=nil;local bd=nil;local be=false;local bf=false;local bg=autoRollPreference;local bh=LandingGearGroundHeight;local bi=false;local bj=p()local bk=0;local bl=0;local bm=0;local bn=AtmoSpeedLimit;local bo=0;local bp=nil;local bq=0;local br=0;local bs=false;local bt=false;local bu={VectorToTarget=false}local bv=false;local bw=0;local bx=nil;local by=false;local bz=false;local bA=false;local bB=false;local bC=0;local bD=p()local bE=vec3(core.getConstructWorldOrientationUp())local bF=vec3(core.getConstructWorldOrientationForward())local bG=vec3(core.getConstructWorldOrientationRight())local bH=vec3(core.getWorldVelocity())local bI=vec3(bH):len()local bJ=vec3(core.getWorldVertical())local bK=-bJ:dot(bH)local bL=vec3(core.getConstructWorldPos())local bM=nil;local bN=false;local bO=false;local bP=false;local bQ=nil;local bR=true;local bS=0;local bT=0;local bU=false;local bV={}local bW=showHud;local bX={}local function bY(bZ,b_)for i=1,#b_ do bZ[#bZ+1]=b_[i]end;return bZ end;local function c0(c1)local c2={}local c3={"userControlScheme","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem"}local c4={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c5={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY"}local c6={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c1 then bY(c2,c3)bY(c2,c4)bY(c2,c5)bY(c2,c6)return c2 elseif c1=="boolean"then return c3 elseif c1=="handling"then return c4 elseif c1=="hud"then return c5 elseif c1=="physics"then return c6 end end;local function c7(c8,c9,ca,cb,cc)if cb==nil then cb=""end;if cc==nil then cc=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cb,c8,c9,cc,ca)end;local function cd(ce,cf)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not cf then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,ce)F=q(x(ce*100,0)/100,-1,1)end;local function cg(ce,cf)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cf then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,ce)bQ=ce end;local function ch(ci,cj)if ci==0 then return c(cj)<1e-09 end;if cj==0 then return c(ci)<1e-09 end;return c(ci-cj)<math.max(c(ci),c(cj))*epsilon end;local function ck(ah,cl)local cm=ah>100000;local cn,co=""if cl==nil then cl=1 end;if cm then cn,co=x(ah/1000/200,cl),"SU"elseif ah<1000 then cn,co=x(ah,cl),"M"else cn,co=x(ah/1000,cl),"KM"end;return cn,co end;local function cp()if VertTakeOff then AltitudeHold=false;StrongBrakes=true;Reentry=false;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=true;VertTakeOff=false;bg=true;ad=0;if ar and ao==-1 then BrakeLanding=false;AltitudeHold=true;ad=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cg(d(bn))end else VertTakeOff=true;AltitudeHold=false;by=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end end;local function cq()by=false;bq=nil;br=nil;bC=0;if as==0 then if IntoOrbit then IntoOrbit=false;bs=false;bx=nil;bg=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bu.VectorToTarget=false;bu.AutopilotAlign=false;bv=false elseif unit.getClosestPlanetInfluence()>0 then IntoOrbit=true;bg=true;if bx==nil then bx=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else Z="Unable to engage orbiting, not near planet"end else IntoOrbit=false;bs=false;bx=nil;bg=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bu.VectorToTarget=false;bu.AutopilotAlign=false;bv=false end end;local function cr()if bD-bl<1.5 then if planet.hasAtmosphere then if as>0 then HoldAltitude=planet.spaceEngineMinAltitude-50 else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bw=HoldAltitude;bv=true;if not IntoOrbit then cq()end;bs=true end end;bl=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bl=bD end;if unit.getClosestPlanetInfluence()>0 and as==0 then bw=at;bv=true;bs=true;cq()if IntoOrbit then bl=bD else bl=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;X=false;bg=true;LockPitch=nil;by=false;if ao==-1 then AutoTakeoff=false;if bl>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=at end end;if VertTakeOff then cp()end else AutoTakeoff=true;if bl>-1 then HoldAltitude=at+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bO then cp()end end;if am then HoldAltitude=100000 end else if IntoOrbit then cq()end;if VertTakeOff then cp()end;bg=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bl=0 end end;local function cs()if l()==1 then X=not X;if X then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)else BrakeIsOn=true;bg=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else Z="Follow Mode only works with Remote controller"X=false end end;local function ct(planet,cu)local function cv(cw,cx)local cy=vec3(cx)if cw.bodyId==0 then return setmetatable({latitude=cy.x,longitude=cy.y,altitude=cy.z,bodyId=0,systemId=cw.planetarySystemId},MapPosition)end;local cz=cy-cw.center;local ah=cz:len()local cA=ah-cw.radius;local cB=0;local cC=0;if not ch(ah,0)then local cD=m(cz.y,cz.x)cC=cD>=0 and cD or 2*math.pi+cD;cB=math.pi/2-math.acos(cz.z/ah)end;return setmetatable({latitude=math.deg(cB),longitude=math.deg(cC),altitude=cA,bodyId=cw.bodyId,systemId=cw.planetarySystemId},MapPosition)end;local cE=cv(planet,cu)cE="::pos{"..cE.systemId..","..cE.bodyId..","..cE.latitude..","..cE.longitude..","..cE.altitude.."}"if not bN then bM=cE end;system.setWaypoint(cE)end;local function cF()local function cG(SpaceTarget)VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cr()end end;VectorStatus="Proceeding to Waypoint"end;if bD-bm<1.5 and as>0 then if not bB then Z="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if as>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight end;bm=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bm=bD end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then bc.UpdateAutopilotTarget()ct(a9,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then if as~=0 then am=true;cr()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if as>0 then if not VectorToTarget then cG(SpaceTarget)end else if at>AutopilotTargetOrbit*1.5 or at==0 then by=false;Autopilot=true elseif not ar then if IntoOrbit then cq()end;bw=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bv=true;bu.AutopilotAlign=true;bu.VectorToTarget=true;bs=false;if not IntoOrbit then cq()end end end else RetrogradeIsOn=false;ProgradeIsOn=false;if as~=0 then am=true;cr()else Autopilot=true end end elseif as==0 then local cH=unit.getClosestPlanetInfluence()>0;if CustomTarget==nil and(a9.name==planet.name and cH)and not IntoOrbit then WaypointSet=false;by=false;bs=false;cq()else Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;X=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;M=false;LockPitch=nil;WaypointSet=false end else am=true;cr()end else am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;M=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=at;TargetSet=false;Reentry=false;if IntoOrbit then cq()end end end;local function cI(cJ)local cK=-1;local cL;cK=bc.findAtlasIndex(SavedLocations)if cK~=-1 then local cM;if cJ~=nil then cL={position=SavedLocations[cK].position,name=cJ,atmosphere=SavedLocations[cK].atmosphere,planetname=SavedLocations[cK].planetname,gravity=SavedLocations[cK].gravity}else cL={position=bL,name=SavedLocations[cK].name,atmosphere=as,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cK]=cL;cK=-1;cK=bc.findAtlasIndex(b2[0])if cK>-1 then b2[0][cK]=cL end;bc.UpdateAtlasLocationsList()Z=CustomTarget.name.." position updated"bc.UpdateAutopilotTarget()else Z="Name Not Found"end end;local function cN()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bg=autoRollPreference end;if BrakeIsOn then AltitudeHold=false;VectorToTarget=false;AutoTakeoff=false;VertTakeOff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;AltitudeHold=false;if VertTakeOff then cp()end;if IntoOrbit then cq()end;LockPitch=nil;bg=autoRollPreference;al=false;an=false;ad=0 end end;local function cO(cP,cQ,cR)local function cS(cP,cT)cP=vec3(cP)cT=vec3(cT):normalize()local cn=cP*cT;return cn.x+cn.y+cn.z end;local cU=0.001;local cV=1;if not ar or not bi or ao~=-1 or bI<N then local cW=cR;if cW==nil then cW=DampingMultiplier end;if cQ==nil then cQ=cU end;cP=vec3(cP):normalize()local cX=vec3()-cP;local cY=-cS(cX,core.getConstructWorldOrientationRight())*cV;local cZ=-cS(cX,core.getConstructWorldOrientationUp())*cV;if aD==0 then aD=cY/2 end;if aE==0 then aE=cZ/2 end;if c(cY)<0.1 then S=S-cY*2 else S=S-(cY+(cY-aD)*cW)end;if c(cZ)<0.1 then R=R+cZ*2 else R=R+cZ+(cZ-aE)*cW end;aD=cY;aE=cZ;if c(cY)<cQ and c(cZ)<cQ then return true end;return false elseif bi and ao==-1 then cP=bH;local cW=cR;if cW==nil then cW=DampingMultiplier end;if cQ==nil then cQ=cU end;cP=vec3(cP):normalize()local cX=bF-cP;local cY=-cS(cX,core.getConstructWorldOrientationRight())*cV;local cZ=-cS(cX,core.getConstructWorldOrientationUp())*cV;if aD==0 then aD=cY/2 end;if aE==0 then aE=cZ/2 end;if c(cY)<0.1 then S=S-cY*5 else S=S-(cY+(cY-aD)*cW)end;if c(cZ)<0.1 then R=R+cZ*5 else R=R+cZ+(cZ-aE)*cW end;aD=cY;aE=cZ;if c(cY)<cQ and c(cZ)<cQ then return true end;return false end end;local function c_()if Reentry then Z="Re-Entry cancelled"Reentry=false;bg=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then Z="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ag=5 elseif not O then StrongBrakes=planet.gravity*9.80665*aw<LastMaxBrakeInAtmo;if not StrongBrakes then Z="WARNING: Insufficient Brakes for Parachute Re-Entry"else Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bg=true;BrakeIsOn=false;Z="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bn end else Reentry=true;AltitudeHold=true;bg=true;BrakeIsOn=false;HoldAltitude=planet.spaceEngineMinAltitude-50;local ca,d0=ck(HoldAltitude)Z="Beginning Re-entry.  Target speed: "..bn.." Target Altitude: "..ca..d0;cg(d(bn))end;AutoTakeoff=false end;local function d1()if antigrav and not ExternalAGG then if bP then antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=at end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;antigrav.activate()antigrav.show()end end end;local function d2(d3)local d4=0;local d5=0;local d6=0;if d3<60 then d3=d(d3)elseif d3<3600 then d4=d(d3/60)d3=d(d3%60)elseif d3<86400 then d5=d(d3/3600)d4=d(d3%3600/60)else d6=d(d3/86400)d5=d(d3%86400/3600)end;if d6>0 then return d6 .."d "..d5 .."h "elseif d5>0 then return d5 .."h "..d4 .."m "elseif d4>0 then return d4 .."m "..d3 .."s"elseif d3>0 then return d3 .."s"else return"0s"end end;local function d7(d8)local function d9(da)for db,dc in pairs(da)do dbHud_1.setStringValue(dc,g(_G[dc]))if d8 and dbHud_2 then dbHud_2.setStringValue(dc,g(_G[dc]))end end end;if dbHud_1 then if not ac then d9(b)d9(c0())system.print("Saved Variables to Datacore")if d8 and dbHud_2 then Z="Databank copied.  Remove copy when ready."end end end end;local function dd()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function de()local function df(dg)return type(dg)=='number'end;local function dh(dg)return type(tonumber(dg))=='number'end;local function di(dj)return type(dj)=='table'end;local function dk(dl)return type(dl)=='string'end;local function dm(dc)return di(dc)and df(dc.x and dc.y and dc.z)end;local function dn(dp)return di(dp)and df(dp.latitude and dp.longitude and dp.altitude and dp.bodyId and dp.systemId)end;local dq=math.pi/180;local dr=180/math.pi;local epsilon=1e-10;local y=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local ds='::pos{'..y..','..y..','..y..','..y..','..y..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local dt=q;local function ch(ci,cj)if ci==0 then return c(cj)<1e-09 end;if cj==0 then return c(ci)<1e-09 end;return c(ci-cj)<math.max(c(ci),c(cj))*epsilon end;local function du(dg)local cn=string.gsub(string.reverse(e('%.4f',dg)),'^0*%.?','')return cn==''and'0'or string.reverse(cn)end;local function dv(dw)if dm(dw)then return e('{x=%.3f,y=%.3f,z=%.3f}',dw.x,dw.y,dw.z)end;if di(dw)and not getmetatable(dw)then local dx={}local dy=next(dw)if type(dy)=='nil'or dy==1 then dx=dw else for db,dc in pairs(dw)do local ce=dv(dc)if type(db)=='number'then table.insert(dx,e('[%s]=%s',db,ce))else table.insert(dx,e('%s=%s',db,ce))end end end;return e('{%s}',table.concat(dx,','))end;if dk(dw)then return e("'%s'",dw:gsub("'",[[\']]))end;return tostring(dw)end;local dz={}dz.__index=dz;dz.__tostring=function(dw,dA)local dB={}for db in pairs(dw)do table.insert(dB,db)end;table.sort(dB)local dx={}for _,db in ipairs(dB)do local ce=dv(dw[db])if type(db)=='number'then table.insert(dx,e('[%s]=%s',db,ce))else table.insert(dx,e('%s=%s',db,ce))end end;if dA then return e('%s%s',dA,table.concat(dx,',\n'..dA))end;return e('{%s}',table.concat(dx,','))end;dz.__eq=function(dC,dD)return dC.planetarySystemId==dD.planetarySystemId and dC.bodyId==dD.bodyId and ch(dC.radius,dD.radius)and ch(dC.center.x,dD.center.x)and ch(dC.center.y,dD.center.y)and ch(dC.center.z,dD.center.z)and ch(dC.GM,dD.GM)end;local function dE(dF,dG,dH,cx,dI)assert(dh(dF),'Argument 1 (planetarySystemId) must be a number:'..type(dF))assert(dh(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(dh(dH),'Argument 3 (radius) must be a number:'..type(dH))assert(di(cx),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cx))assert(dh(dI),'Argument 5 (GM) must be a number:'..type(dI))return setmetatable({planetarySystemId=tonumber(dF),bodyId=tonumber(dG),radius=tonumber(dH),center=vec3(cx),GM=tonumber(dI)},dz)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dJ)return e('::pos{%d,%d,%s,%s,%s}',dJ.systemId,dJ.bodyId,du(dJ.latitude*dr),du(dJ.longitude*dr),du(dJ.altitude))end;MapPosition.__eq=function(dC,dD)return dC.bodyId==dD.bodyId and dC.systemId==dD.systemId and ch(dC.latitude,dD.latitude)and ch(dC.altitude,dD.altitude)and(ch(dC.longitude,dD.longitude)or ch(dC.latitude,math.pi/2)or ch(dC.latitude,-math.pi/2))end;local function dK(dL,dG,cB,cC,cA)local dF=dL;if dk(dL)and not cC and not cA and not dG and not cB then dF,dG,cB,cC,cA=n(dL,ds)assert(dF,'Argument 1 (position string) is malformed.')else assert(dh(dF),'Argument 1 (systemId) must be a number:'..type(dF))assert(dh(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(dh(cB),'Argument 3 (latitude) must be in degrees:'..type(cB))assert(dh(cC),'Argument 4 (longitude) must be in degrees:'..type(cC))assert(dh(cA),'Argument 5 (altitude) must be in meters:'..type(cA))end;dF=tonumber(dF)dG=tonumber(dG)cB=tonumber(cB)cC=tonumber(cC)cA=tonumber(cA)if dG==0 then return setmetatable({latitude=cB,longitude=cC,altitude=cA,bodyId=dG,systemId=dF},MapPosition)end;return setmetatable({latitude=dq*dt(cB,-90,90),longitude=dq*(cC%360),altitude=cA,bodyId=dG,systemId=dF},MapPosition)end;local dM={}dM.__index=dM;dM.__tostring=function(dw,dA)local dN=dA and dA..'  'local dO={}local dB={}for db in pairs(dw)do table.insert(dB,db)end;table.sort(dB)for _,dP in ipairs(dB)do bdy=dw[dP]local dQ=dz.__tostring(bdy,dN)if dA then table.insert(dO,e('[%s]={\n%s\n%s}',dP,dQ,dA))else table.insert(dO,e('  [%s]=%s',dP,dQ))end end;if dA then return e('\n%s%s%s',dA,table.concat(dO,',\n'..dA),dA)end;return e('{\n%s\n}',table.concat(dO,',\n'))end;local function dR(dS)local b2={}local pid;for _,dc in pairs(dS)do local dT=dc.planetarySystemId;if type(dT)~='number'then error('Invalid planetary system ID: '..tostring(dT))elseif pid and dT~=pid then error('Mistringmatch planetary system IDs: '..dT..' and '..pid)end;local dU=dc.bodyId;if type(dU)~='number'then error('Invalid body ID: '..tostring(dU))elseif b2[dU]then error('Duplicate body ID: '..tostring(dU))end;setmetatable(dc.center,getmetatable(vec3.unit_x))b2[dU]=setmetatable(dc,dz)pid=dT end;return setmetatable(b2,dM)end;b6={}local function dV(dS)return setmetatable({galaxyAtlas=dS or{}},b6)end;b6.__index=function(dj,i)if type(i)=='number'then local system=dj.galaxyAtlas[i]return dR(system)end;return rawget(b6,i)end;b6.__pairs=function(dw)return function(dj,db)local dW,nv=next(dj,db)return dW,nv and dR(nv)end,dw.galaxyAtlas,nil end;b6.__tostring=function(dw)local dX={}for _,dY in pairs(dw or{})do local dZ=dY:getPlanetarySystemId()local d_=dM.__tostring(dY,'    ')table.insert(dX,e('  [%s]={%s\n  }',dZ,d_))end;return e('{\n%s\n}\n',table.concat(dX,',\n'))end;b6.BodyParameters=dE;b6.MapPosition=dK;b6.PlanetarySystem=dR;function b6.createBodyParameters(e0,dG,e1,e2,e3,e4,e5)assert(dh(e0),'Argument 1 (planetarySystemId) must be a number:'..type(e0))assert(dh(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(dh(e1),'Argument 3 (surfaceArea) must be a number:'..type(e1))assert(di(e2),'Argument 4 (aPosition) must be an array or vec3:'..type(e2))assert(di(e3),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(e3))assert(dh(e4),'Argument 6 (altitude) must be in meters:'..type(e4))assert(dh(e5),'Argument 7 (gravityAtPosition) must be number:'..type(e5))local dH=math.sqrt(e1/4/math.pi)local ah=dH+e4;local e6=vec3(e2)+ah*vec3(e3)local dI=e5*ah*ah;return dE(e0,dG,dH,e6,dI)end;b6.isMapPosition=dn;function b6:getPlanetarySystem(dL)if i==nil then i=0 end;if nv==nil then nv=0 end;local e0=dL;if dn(dL)then e0=dL.systemId end;if type(e0)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dM then system=dR(system)end;return system end end end;function dM:castIntersections(e7,cT,e8,e9)local e8=e8 or function(ea)return 1.05*ea.radius end;local eb={}if e9 then for _,i in ipairs(e9)do eb[i]=self[i]end else e9={}for db,ea in pairs(self)do table.insert(e9,db)eb[db]=ea end end;local function ec(ed,ee)local ef=eb[ed].center-e7;local eg=eb[ee].center-e7;return ef:len()<eg:len()end;table.sort(e9,ec)local eh=cT:normalize()for i,dT in ipairs(e9)do local ea=eb[dT]local ei=ea.center-e7;local dH=e8(ea)local ej=ei:dot(eh)local ek=ej^2-(ei:len2()-dH^2)if ek>=0 then local el=math.sqrt(ek)local em=ej+el;local en=ej-el;if en>0 then return ea,em,en elseif em>0 then return ea,em,nil end end end;return nil,nil,nil end;function dM:closestBody(cu)assert(type(cu)=='table','Invalid coordinates.')local eo,ea;local ep=vec3(cu)for _,eq in pairs(self)do local er=(eq.center-ep):len2()if(not ea or er<eo)and eq.name~="Space"then ea=eq;eo=er end end;return ea end;function dM:convertToBodyIdAndWorldCoordinates(dL)local es=dL;if dk(dL)then es=dK(dL)end;if es.bodyId==0 then return 0,vec3(es.latitude,es.longitude,es.altitude)end;local eq=self:getBodyParameters(es)if eq then return es.bodyId,eq:convertToWorldCoordinates(es)end end;function dM:getBodyParameters(dL)local dG=dL;if dn(dL)then dG=dL.bodyId end;assert(dh(dG),'Argument 1 (bodyId) must be a number:'..type(dG))return self[dG]end;function dM:getPlanetarySystemId()local _,dc=next(self)return dc and dc.planetarySystemId end;function dz:convertToMapPosition(cx)assert(di(cx),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cx))local cy=vec3(cx)if self.bodyId==0 then return setmetatable({latitude=cy.x,longitude=cy.y,altitude=cy.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local cz=cy-self.center;local ah=cz:len()local cA=ah-self.radius;local cB=0;local cC=0;if not ch(ah,0)then local cD=m(cz.y,cz.x)cC=cD>=0 and cD or 2*math.pi+cD;cB=math.pi/2-math.acos(cz.z/ah)end;return setmetatable({latitude=cB,longitude=cC,altitude=cA,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dz:convertToWorldCoordinates(dL)local es=dk(dL)and dK(dL)or dL;if es.bodyId==0 then return vec3(es.latitude,es.longitude,es.altitude)end;assert(dn(es),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(es.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(es.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local et=math.cos(es.latitude)return self.center+(self.radius+es.altitude)*vec3(et*math.cos(es.longitude),et*math.sin(es.longitude),math.sin(es.latitude))end;function dz:getAltitude(cx)return(vec3(cx)-self.center):len()-self.radius end;function dz:getDistance(cx)return(vec3(cx)-self.center):len()end;function dz:getGravity(cx)local eu=self.center-vec3(cx)local ev=eu:len2()return self.GM/ev*eu/math.sqrt(ev)end;return setmetatable(b6,{__call=function(_,...)return dV(...)end})end;local function ew()local b8={}local ex=30000000/3600;local ey=ex*ex;local ez=100;local function eA(dc)return 1/math.sqrt(1-dc*dc/ey)end;function b8.computeAccelerationTime(eB,eC,eD)local eE=ex*math.asin(eB/ex)return(ex*math.asin(eD/ex)-eE)/eC end;function b8.computeDistanceAndTime(eB,eD,eF,eG,eH,eI)eH=eH or 0;eI=eI or 0;local eJ=eB<=eD;local eK=eG*(eJ and 1 or-1)/eF;local eL=-eI/eF;local eM=eK+eL;if eJ and eM<=0 or not eJ and eM>=0 then return-1,-1 end;local eN,eO=0,0;if eK~=0 and eH>0 then local eE=math.asin(eB/ex)local eP=math.pi*(eK/2+eL)local eQ=eK*eH;local eR=ex*math.pi;local dc=function(dj)local eS=(eP*dj-eQ*math.sin(math.pi*dj/2/eH)+eR*eE)/eR;local eT=math.tan(eS)return ex*eT/math.sqrt(eT*eT+1)end;local eU=eJ and function(dl)return dl>=eD end or function(dl)return dl<=eD end;eO=2*eH;if eU(dc(eO))then local eV=0;while c(eO-eV)>0.5 do local dj=(eO+eV)/2;if eU(dc(dj))then eO=dj else eV=dj end end end;local eW=eB;local eX=eO/ez;for eY=1,ez do local eZ=dc(eY*eX)eN=eN+(eZ+eW)*eX/2;eW=eZ end;if eO<2*eH then return eN,eO end;eB=eW end;local eE=ex*math.asin(eB/ex)local bD=(ex*math.asin(eD/ex)-eE)/eM;local e_=ey*math.cos(eE/ex)/eM;local ah=e_-ey*math.cos((eM*bD+eE)/ex)/eM;return ah+eN,bD+eO end;function b8.computeTravelTime(eB,eC,ah)if ah==0 then return 0 end;if eC>0 then local eE=ex*math.asin(eB/ex)local e_=ey*math.cos(eE/ex)/eC;return(ex*math.acos(eC*(e_-ah)/ey)-eE)/eC end;if eB==0 then return-1 end;assert(eB>0,'Acceleration and initial speed are both zero.')return ah/eB end;function b8.lorentz(dc)return eA(dc)end;return b8 end;local function f0()local vec3=require('cpml.vec3')local de=de()local function dk(dl)return type(dl)=='string'end;local function di(dj)return type(dj)=='table'end;local function ch(ci,cj)if ci==0 then return c(cj)<1e-09 end;if cj==0 then return c(ci)<1e-09 end;return c(ci-cj)<math.max(c(ci),c(cj))*constants.epsilon end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cA)assert(self.body)local ah=cA+self.body.radius;if not ch(ah,0)then local orbit=math.sqrt(self.body.GM/ah)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dL,f1)assert(self.body)assert(di(dL)or dk(dL))assert(di(f1))local f2=(dk(dL)or de.isMapPosition(dL))and self.body:convertToWorldCoordinates(dL)or vec3(dL)local dc=vec3(f1)local f3=f2-self.body.center;local eg=dc:len2()local f4=f3:len()local f5=self.body.GM;local f6=((eg-f5/f4)*f3-f3:dot(dc)*dc)/f5;local ci=f5/(2*f5/f4-eg)local f7=f6:len()local eh=f6:normalize()local f8=ci*(1-f7)local f9=ci*(1+f7)local fa=f8*eh+self.body.center;local fb=f7<=1 and-f9*eh+self.body.center or nil;local fc=math.sqrt(ci*f5*(1-f7*f7))local fd=fb and 2*math.pi*math.sqrt(ci^3/f5)local fe=math.acos(f6:dot(f3)/(f7*f4))if f3:dot(dc)<0 then fe=-(fe-2*math.pi)end;local ff=math.acos((math.cos(fe)+f7)/(1+f7*math.cos(fe)))local fg=ff;if fg<0 then fg=fg+2*math.pi end;local fh=fg-f7*math.sin(fg)local fi=0;local fj=0;local fk=0;if fd~=nil then fi=fh/(2*math.pi/fd)fj=fd-fi;fk=fj+fd/2;if fe-math.pi>0 then fj=fi;fk=fj+fd/2 end;if fk>fd then fk=fk-fd end end;return{periapsis={position=fa,speed=fc/f8,circularOrbitSpeed=math.sqrt(f5/f8),altitude=f8-self.body.radius},apoapsis=fb and{position=fb,speed=fc/f9,circularOrbitSpeed=math.sqrt(f5/f9),altitude=f9-self.body.radius},currentVelocity=dc,currentPosition=f2,eccentricity=f7,period=fd,eccentricAnomaly=ff,meanAnomaly=fh,timeToPeriapsis=fj,timeToApoapsis=fk}end;local function fl(fm)local eq=de.BodyParameters(fm.planetarySystemId,fm.bodyId,fm.radius,fm.center,fm.GM)return setmetatable({body=eq},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return fl(...)end})end;local function fn()local fo=false;local fp=0;local function fq(fr)local dH=500000;local fs,ft,fu=math.huge;local fv=false;local fw=vec3({13771471,7435803,-128971})local fx=18000000;fs=vec3(fr):dist(fw)if fs<fx then return true,c(fs-fx),"Safe Zone",0 end;ft=vec3(fr):dist(vec3(planet.center))if ft<dH then fv=true end;if c(ft-dH)<c(fs-fx)then return fv,c(ft-dH),planet.name,planet.bodyId else return fv,c(fs-fx),"Safe Zone",0 end end;local function fy(dc)if aK==1920 then return dc else return x(aK*dc/1920,0)end end;local function fz(dc)if aL==1080 then return dc else return x(aL*dc/1080,0)end end;local function fA()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function fB()local fC="TRAVEL"if not bR then fC="CRUISE"end;if Autopilot then fC="AUTOPILOT"end;return fC end;local function fD(fE,b0,c8,fF,fG,fH,fI,fJ)local fK=1;local fL=2;local fM=3;local fN=4;local fO=5;local fP=6;local fQ=""local fR=0;local fS=fuelY;local fT=fuelY+10;if l()==1 and not RemoteHud then fS=fS-50;fT=fT-50 end;if fG=="ATMO"then fQ="atmofueltank"elseif fG=="SPACE"then fQ="spacefueltank"else fQ="rocketfueltank"end;fR=_G[fQ.."_size"]if#fH>0 then for i=1,#fH do local fU=string.sub(fH[i][fL],1,12)local fV=0;for fW=1,fR do if fH[i][fL]==f(unit[fQ.."_"..fW].getData()).name then fV=fW;break end end;if b0 or fI[i]==nil or fJ[i]==nil then local fX=0;local fY=0;local fZ=0;local f_=0;local g0=p()if fV~=0 then fJ[i]=f(unit[fQ.."_"..fV].getData()).percentage;fI[i]=f(unit[fQ.."_"..fV].getData()).timeLeft;if fI[i]=="n/a"then fI[i]=0 end else fZ=k(fH[i][fK])-fH[i][fN]fX=fH[i][fM]fJ[i]=d(0.5+fZ*100/fX)fY=fH[i][fO]f_=fH[i][fP]if fY<=fZ then fI[i]=0 else fI[i]=d(0.5+fZ/((fY-fZ)/(g0-f_)))end;fH[i][fO]=fZ;fH[i][fP]=g0 end end;if fU==fF then fU=e("%s %d",fG,i)end;if fV==0 then fU=fU.." *"end;local g1;if fI[i]==0 then g1="n/a"else g1=d2(fI[i])end;if fJ[i]~=nil then local g2=d(fJ[i]*2.55)local g3=e("rgb(%d,%d,%d)",255-g2,g2,0)local cb=""if g1~="n/a"and fI[i]<120 or fJ[i]<5 then if b0 then cb=[[class="red"]]end end;fE[#fE+1]=c7(c8,fS,fU,cb.." pdim txtfuel")fE[#fE+1]=c7(c8,fT,e("%d%% %s",fJ[i],g1),"pdim txtfuel","fill:"..g3)fS=fS+30;fT=fT+30 end end end end;local function g4(fE,cA)if cA<200000 and not ar or cA and ar then local g5=0;if c(bK)>1 then g5=45*math.log(c(bK),10)if bK<0 then g5=-g5 end end;fE[#fE+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bK),d(g5))end;return fE end;local function g6(g7)local g8=-bJ;g7=g7-g7:project_on(g8)local g9=vec3(0,0,1)g9=g9-g9:project_on(g8)local ga=g9:cross(g8)local g5=g9:angle_between(g7)*constants.rad2deg;if g7:dot(ga)<0 then g5=360-g5 end;return g5 end;local function gb(fE,centerX,centerY,gc,gd,cH)local ge=circleRad;local gf=20;local gg=d(gc)if cH then for i=-45,45,5 do local gh=i;fE[#fE+1]=e([[<g transform="rotate(%f,%d,%d)">]],gh,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fE[#fE+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+ge+gf-len,centerX,centerY+ge+gf)end;fE[#fE+1]=c7(centerX,centerY+ge+gf-35,gd,"pdim txt txtmid")fE[#fE+1]=c7(centerX,centerY+ge+gf-25,gg.." deg","pdim txt txtmid")fE[#fE+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gc,centerX,centerY)fE[#fE+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+ge+gf-20,centerX+5,centerY+ge+gf-20,centerX,centerY+ge+gf-15)fE[#fE+1]="</g>"end;local gi=gg;if cH then gi=g6(bF)end;local gj=20;local gk=d(gi)local gl=0;local gm=centerY+ge+gf+20;local gn=centerX;if gd~="YAW"then gm=fz(130)gn=fy(960)end;local go=[[<path class="txttick line" d="]]for i=d(gk-(gj+10)-gk%5+0.5),d(gk+gj+10+gk%5+0.5),5 do local c8=gn+-i*5+gi*5;if i%10==0 then gl=10;local y=i;if y==360 then y=0 elseif y>360 then y=y-360 elseif y<0 then y=y+360 end;fE[#fE+1]=c7(c8+5,gm-12,y)elseif i%5==0 then gl=5 end;if gl==10 then go=e([[%s M %f %f v %d]],go,c8,gm-5,gl)else go=e([[%s M %f %f v %d]],go,c8,gm-2.5,gl)end end;fE[#fE+1]=go..[["/>]]fE[#fE+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],gn-5,gm+10,gn+5,gm+10,gn,gm+5)if cH then gd="HDG"end;fE[#fE+1]=c7(gn,gm+25,gk.."deg","pdim txt txtmid","")fE[#fE+1]=c7(gn,gm+35,gd,"pdim txt txtmid","")end;local function gp(fE,gq,gc,centerX,centerY,cH,gr,eZ)local ge=circleRad;local gs=d(ge*3/5)if ge>0 then local gt=d(gq)local len=0;local go=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gc,centerX,centerY)if not ar then go=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fE[#fE+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],ge-1,centerX,centerY)fE[#fE+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gt-30-gt%5+0.5),d(gt+30+gt%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local c9=centerY+-i*5+gq*5;if len==30 then go=e([[%s M %d %f h %d]],go,centerX-gs-len,c9,len)if ar then fE[#fE+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gc,centerX,centerY,centerX-gs+10,c9,i)fE[#fE+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gc,centerX,centerY,centerX+gs-10,c9,i)if i==0 or i==180 or i==-180 then fE[#fE+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gc,centerX,centerY,centerX-gs+20,c9,gs*2-40)end else fE[#fE+1]=c7(centerX-gs+10,c9,i,"pdim txt txtmid")fE[#fE+1]=c7(centerX+gs-10,c9,i,"pdim txt txtmid")end;go=e([[%s M %d %f h %d]],go,centerX+gs,c9,len)else go=e([[%s M %d %f h %d]],go,centerX-gs-len,c9,len)go=e([[%s M %d %f h %d]],go,centerX+gs,c9,len)end end;fE[#fE+1]=go..[["/>]]local gu="PITCH"if not cH then gu="REL PITCH"end;if gq>90 and not ar then gq=90-(gq-90)elseif gq<-90 and not ar then gq=-90-(gq+90)end;if ge>200 then if ar then if eZ>N then fE[#fE+1]=c7(centerX,centerY-15,"Yaw","pdim txt txtmid")fE[#fE+1]=c7(centerX,centerY+20,gr,"pdim txt txtmid")end;fE[#fE+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gc,centerX,centerY)else fE[#fE+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fE[#fE+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gs+25,centerY-5,centerX-gs+20,centerY,centerX-gs+25,centerY+5,centerX-gs+50,centerY+4,gt)fE[#fE+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gs-25,centerY-5,centerX+gs-20,centerY,centerX+gs-25,centerY+5,centerX+gs-30,centerY+4,gt)fE[#fE+1]="</g>"end;local gv=d(ge/3)fE[#fE+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gv,centerY,ge-gv)if not ar and cH then fE[#fE+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gc,centerX,centerY,centerX-gs+10,centerY,gs*2-20)end;fE[#fE+1]="</g>"if ge<200 then if ar and eZ>N then fE[#fE+1]=c7(centerX,centerY-ge,gu,"pdim txt txtmid")fE[#fE+1]=c7(centerX,centerY-ge+10,gt,"pdim txt txtmid")fE[#fE+1]=c7(centerX,centerY-15,"Yaw","pdim txt txtmid")fE[#fE+1]=c7(centerX,centerY+20,gr,"pdim txt txtmid")else fE[#fE+1]=c7(centerX,centerY-ge,gu,"pdim txt txtmid")fE[#fE+1]=c7(centerX,centerY-ge+15,gt,"pdim txt txtmid")end end end end;local function gw(fE,cA,cH)local gx=altMeterX;local gy=altMeterY;local gz=78;local gA=19;local gB=ao;if ao~=-1 then fE[#fE+1]=c7(gx+gz,gy+gA+20,e("AGL: %.1fm",ao),"pdim altsm txtend")end;if cH and(cA<200000 and not ar or cA and ar)then table.insert(fE,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gx-1,gy-4,gz+2,gA+6,gx+1,gy-1,gz-4,gA))local cK=0;local gC=1;local gD=0;local gE=cA<0;local gF=9;if gE then gF=0 end;local cA=c(cA)while cK<6 do local gG=11;local gH=16;local gI=9;local gJ=14;local cb="altsm"if cK>2 then gH=gH+3;gG=gG+2;gJ=gJ+2;gI=gI-6;cb="altbig"end;if gE then cb=cb.." red"end;local gK=cA/gC%10;local gL=d(gK)local gM=d((gL+1)%10)local gN=gD;if cK==0 then gN=gK-gL;if gE then gN=1-gN end end;if gE and(cK==0 or gD~=0)then local gO=gM;gM=gL;gL=gO end;local gP=gH*(gN-1)local gQ=gP+gH;local c8=gx+gI+(6-cK)*gG;local c9=gy+gJ;fE[#fE+1]=c7(c8,c9+gP,gM,cb)fE[#fE+1]=c7(c8,c9+gQ,gL,cb)cK=cK+1;gC=gC*10;if gL==gF then gD=gN else gD=0 end end;table.insert(fE,[[</g></g>]])end end;local function gR(f1)f1=vec3(f1)local gS=-math.deg(m(f1.y,f1.z))+180;gS=gS-90;if gS<0 then gS=360+gS end;if gS>180 then gS=-180+gS-180 end;return-gS end;local function gT(f1)f1=vec3(f1)local gi=math.deg(m(f1.y,f1.x))-90;if gi<-180 then gi=360+gi end;return gi end;local function gU(fE,f1,eZ,centerX,centerY)if eZ>5 and not ar or eZ>N then local ge=circleRad;local gV=20;local gW=20;local gX=vec3(f1)local gY=gR(gX)local gZ=gT(gX)local g_=14;local h0=g_/2;local h1=-gZ/gW*ge;local h2=gY/gV*ge;local c8=centerX+h1;local c9=centerY+h2;local ah=math.sqrt(h1^2+h2^2)local h3=[[<circle
                            cx="]]..c8 ..[["
                            cy="]]..c9 ..[["
                            r="]]..h0/g_..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c8 ..[["
                            cy="]]..c9 ..[["
                            r="]]..h0 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c8-g_..[[,]]..c9 ..[[ h ]]..h0 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c8+h0 ..[[,]]..c9 ..[[ h ]]..h0 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c8 ..[[,]]..c9-g_..[[ v ]]..h0 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ah<ge then fE[#fE+1]=h3 else local g5=m(h2,h1)local h4=4;local h5=centerX+ge*math.cos(g5)local h6=centerY+ge*math.sin(g5)fE[#fE+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',g5*180/math.pi,h5,h6,h5-h4,h6-h4/2,h4*2,h4,h5+h4,h6-h4,h4,h4,-h4,h4)end;if not ar then gY=gR(-gX)gZ=gT(-gX)h1=-gZ/gW*ge;h2=gY/gV*ge;c8=centerX+h1;c9=centerY+h2;ah=math.sqrt(h1^2+h2^2)if ah<ge then local h7=[[<circle
                                    cx="]]..c8 ..[["
                                    cy="]]..c9 ..[["
                                    r="]]..h0 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c8 ..[[,]]..c9-g_..[[ v ]]..h0 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c8 ..[[,]]..c9 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c8 ..[[,]]..c9 ..[[)" />
                                <path
                                    d="M ]]..c8-h0 ..[[,]]..c9 ..[[ h ]]..g_..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c8 ..[[,]]..c9 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c8 ..[[,]]..c9 ..[[)"/>]]fE[#fE+1]=h7 end end end end;local function h8(fE,fC,h9,ha)h9=d(h9+0.5)local fS=throtPosY+10;local fT=throtPosY+20;if l()==1 and not RemoteHud then fS=55;fT=65 end;local hb="CRUISE"local unit="km/h"local ce=ha;if fC=="TRAVEL"or fC=="AUTOPILOT"then hb="THROT"unit="%"ce=h9;local hc="dim"if h9<0 then hc="red"end;fE[#fE+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hc,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(h9),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fE[#fE+1]=c7(throtPosX+10,fS,hb,"pbright txtstart")fE[#fE+1]=c7(throtPosX+10,fT,e("%.0f %s",ce,unit),"pbright txtstart")if ar and AtmoSpeedAssist and bR and H then h9=d(I*100+0.5)local hc="red"if h9<0 then hc="red"end;fE[#fE+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hc,1-c(h9),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fE[#fE+1]=c7(throtPosX+10,fS+40,"LIMIT","pbright txtstart")fE[#fE+1]=c7(throtPosX+10,fT+40,h9 .."%","pbright txtstart")end;if ar and AtmoSpeedAssist or Reentry then fE[#fE+1]=c7(throtPosX+10,fS-40,"LIMIT: "..bn.." km/h","dim txtstart")elseif not ar and Autopilot then fE[#fE+1]=c7(throtPosX+10,fS-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hd(fE,he)local hf=throtPosY-10;local hg=throtPosX+10;fE[#fE+1]=c7(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then hf=75 end;fE[#fE+1]=c7(hg,hf,d(he).." km/h","pbright txtbig txtstart")end;local function hh(fE)fE[#fE+1]=c7(fy(1900),fz(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fE[#fE+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fE[#fE+1]=c7(fy(960),fz(550),"Warning: Invalid Control Scheme Detected","warnings")fE[#fE+1]=c7(fy(960),fz(600),"Keyboard Scheme must be selected","warnings")fE[#fE+1]=c7(fy(960),fz(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hi=fy(960)local hj=fz(860)local hk=fz(880)local hl=fz(900)local hm=fz(960)local hn=fz(200)local ho=fz(150)local hp=fz(960)if l()==1 and not RemoteHud then hj=fz(135)hk=fz(155)hl=fz(175)hn=fz(115)ho=fz(95)end;if BrakeIsOn then fE[#fE+1]=c7(hi,hj,"Brake Engaged","warnings")elseif G>0 then fE[#fE+1]=c7(hi,hj,"Auto-Brake Engaged","warnings","opacity:"..G)end;if ar and bi and ao==-1 then fE[#fE+1]=c7(hi,hn+50,"** STALL WARNING **","warnings")end;if ay then fE[#fE+1]=c7(hi,hp,"Gyro Enabled","warnings")end;if GearExtended then if P then fE[#fE+1]=c7(hi,hk,"Gear Extended","warn")else fE[#fE+1]=c7(hi,hk,"Landed (G: Takeoff)","warnings")end;local hq,co=ck(a:getTargetGroundAltitude())fE[#fE+1]=c7(hi,hl,"Hover Height: "..hq..co,"warn")end;if a4 then fE[#fE+1]=c7(hi,hm+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bP and AntigravTargetAltitude~=nil then if c(at-antigrav.getBaseAltitude())<501 then fE[#fE+1]=c7(hi,hn+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fE[#fE+1]=c7(hi,hn+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fE[#fE+1]=c7(hi,hn+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fE[#fE+1]=c7(hi,hn+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif X then fE[#fE+1]=c7(hi,hn+20,"Follow Mode Engaged","warn")elseif Reentry then fE[#fE+1]=c7(hi,hn+20,"Re-entry in Progress","warn")end;local hr,em,en=b7:getPlanetarySystem(0):castIntersections(bL,bH:normalize(),function(ea)if ea.noAtmosphericDensityAltitude>0 then return ea.radius+ea.noAtmosphericDensityAltitude else return ea.radius+ea.surfaceMaxAltitude*1.5 end end)local hs=em;if en~=nil and em~=nil then hs=math.min(en,em)end;if AltitudeHold or VertTakeOff then local hq,co=ck(HoldAltitude,2)if VertTakeOff then if bP then hq,co=ck(antigrav.getBaseAltitude(),2)end;fE[#fE+1]=c7(hi,hn,"AGG VTO to "..hq..co,"warn")elseif AutoTakeoff and not IntoOrbit then fE[#fE+1]=c7(hi,hn,"Takeoff to "..hq..co,"warn")if BrakeIsOn and not VertTakeOff then fE[#fE+1]=c7(hi,hn+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fE[#fE+1]=c7(hi,hn,"Altitude Hold: "..hq..co,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if as>0.1 then fE[#fE+1]=c7(hi,hn+20,"Beginning ascent","warn")elseif as<0.09 and as>0.05 then fE[#fE+1]=c7(hi,hn+20,"Aligning trajectory","warn")elseif as<0.05 then fE[#fE+1]=c7(hi,hn+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bp~=nil then fE[#fE+1]=c7(hi,hn,bp,"warn")end end;if IntruderAlertSystem and safeMass==-1 then fE[#fE+1]=c7(hi,hn+70,"POSSIBLE INTRUDER ALERT - MASS GAIN DETECTED","warnings")end;if BrakeLanding then if StrongBrakes then fE[#fE+1]=c7(hi,hn,"Brake-Landing","warnings")else fE[#fE+1]=c7(hi,hn,"Coast-Landing","warnings")end end;if ProgradeIsOn then fE[#fE+1]=c7(hi,hn,"Prograde Alignment","crit")end;if RetrogradeIsOn then fE[#fE+1]=c7(hi,hn,"Retrograde Alignment","crit")end;if hs~=nil and as==0 then local hq,co=ck(hs)local travelTime=b8.computeTravelTime(bI,0,hs)local ht="Collision"if hr.noAtmosphericDensityAltitude>0 then ht="Atmosphere"end;fE[#fE+1]=c7(hi,ho,hr.name.." "..ht.." "..d2(travelTime).." In "..hq..co,"crit")end;if VectorToTarget and not IntoOrbit then fE[#fE+1]=c7(hi,hn+35,VectorStatus,"warn")end;fE[#fE+1]="</g>"return fE end;local function hu(eZ)return d(x(eZ*3.6,0)+0.5).." km/h"end;local function hv(fE)local hw=OrbitMapX;local hx=OrbitMapY;local hy=OrbitMapSize;local hz=4;local hA=15;local c8=0;local c9=0;local hB,hC,hD,hE;local function hF(type)local hG,bD,eZ,hH;if type=="Periapsis"then hG=orbit.periapsis.altitude;bD=orbit.timeToPeriapsis;eZ=orbit.periapsis.speed;hH=35 else hG=orbit.apoapsis.altitude;bD=orbit.timeToApoapsis;eZ=orbit.apoapsis.speed;hH=-35 end;fE[#fE+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c8+hH,c9-5,hw+hy/2-hB+hE,c9-5)fE[#fE+1]=c7(c8,c9,type)c9=c9+hA;local hq,co=ck(hG)fE[#fE+1]=c7(c8,c9,hq..co)c9=c9+hA;fE[#fE+1]=c7(c8,c9,d2(bD))c9=c9+hA;fE[#fE+1]=c7(c8,c9,hu(eZ))end;if orbit~=nil and as<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hx=hx+hz;c8=hw+hy+hw/2+hz;c9=hx+hy/2+5+hz;hB=hy/4;hE=0;fE[#fE+1]=[[<g class="pbright txtorb txtmid">]]fE[#fE+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hy+hw*2,hy+hx,hz,hz)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hD=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hB*2)hC=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hD*(1-orbit.eccentricity)hE=hB-orbit.periapsis.altitude/hD-planet.radius/hD;local hI=""if orbit.periapsis.altitude<=0 then hI='redout'end;fE[#fE+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hI,hw+hy/2+hE+hz,hx+hy/2+hz,hB,hC)fE[#fE+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hw+hy/2+hz,hx+hy/2+hz,planet.radius/hD)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hF("Apoapsis")end;c9=hx+hy/2+5+hz;c8=hw-hw/2+10+hz;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hF("Periapsis")end;fE[#fE+1]=c7(hw+hy/2+hz,planet.name,20+hz,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hJ=orbit.timeToApoapsis/orbit.period*2*math.pi;local hK=hB*math.cos(hJ)local hL=hC*math.sin(hJ)fE[#fE+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hw+hy/2+hK+hE+hz,hx+hy/2+hL+hz)end;fE[#fE+1]=[[</g>]]return fE else return fE end end;local function hM()if radarPanelID~=nil and ak==0 then s(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then s(perisPanelID)perisPanelID=nil end else if ak==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;ak=0 end end;local function hN(fE)local c8=50;local c9=525;local hO={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hP={"Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to +1k over atmosphere and orbit to target","Alt-5: Lock Pitch at current pitch","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-9: Activate Gyroscope"}local hQ={"Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at 1k over atmosphere","Alt-9: Activate Gyroscope"}local hR={"CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if ar then bY(hO,hP)table.insert(hO,"---------------------------------------")if VertTakeOff then table.insert(hO,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ao~=-1 then if antigrav then if bP then table.insert(hO,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hO,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hO,"Alt-6: Begins Vertical Takeoff.")else table.insert(hO,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hO,"G: Begin BrakeLanding or Land")end else bY(hO,hQ)end;if AltitudeHold then table.insert(hO,"Alt-Spacebar/Alt-C will raise/lower target height")end;table.insert(hO,"---------------------------------------")bY(hO,hR)for i=1,#hO do c9=c9+12;fE[#fE+1]=c7(c8,c9,hO[i],"pdim txttick txtstart")end end;local hS={}function hS.HUDPrologue(fE)if not fo then C=PvPR;E=PvPG;D=PvPB else C=SafeR;E=SafeG;D=SafeB end;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local hT=aA;local hU=aB;local hV=aA;local hW=aB;if fA()and not brightHud then hT=[[rgb(]]..d(C*0.4+0.5)..","..d(E*0.4+0.5)..","..d(D*0.3+0.5)..[[)]]hU=[[rgb(]]..d(C*0.3+0.5)..","..d(E*0.3+0.5)..","..d(D*0.2+0.5)..[[)]]end;fE[#fE+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],hT,hT,hV,hV,hU,hU,hW,hW,aK,aL)return fE end;function hS.UpdateHud(fE)local cA=at;local f1=core.getVelocity()local eZ=vec3(f1):len()local gS=bS;local hX=bT;local gc=hX;local gq=bS;local h9=d(unit.getThrottle())local he=eZ*3.6;local ha=unit.getAxisCommandValue(0)local hY=fy(1770)local hZ=fz(310)if AtmoSpeedAssist and bR then ha=F;h9=F*100 end;local fC=fB()local gd="ROLL"local cH=unit.getClosestPlanetInfluence()>0;if h9==nil then h9=0 end;if not cH then if eZ>5 then gS=gR(f1)hX=gT(f1)else gS=0;hX=0 end;gd="YAW"end;if not ar then fo,fp,_,_=fq(bL)else fo=true end;if fp>50000 and not ar then local h_;if fp>200000 then h_=x(fp/200000,2).." su"else h_=x(fp/1000,1).." km"end;fE[#fE+1]=c7(hY,hZ,"PvP Boundary: "..h_,"pbright txtbig txtmid")end;fE[#fE+1]=aj;fE[#fE+1]=aF;fE[#fE+1]=ai;if b1%aW==0 then b0=true end;if fuelX~=0 and fuelY~=0 then fD(fE,b0,fuelX,"Atmospheric ","ATMO",aP,aZ,a_)fD(fE,b0,fuelX+100,"Space fuel t","SPACE",aQ,aX,aY)fD(fE,b0,fuelX+200,"Rocket fuel ","ROCKET",aR,aU,aV)end;if b0 then b0=false;b1=0 end;b1=b1+1;g4(fE,cA)if l()==0 or RemoteHud then if not fA()or brightHud then if cH then gb(fE,centerX,centerY,gc,gd,cH)gp(fE,gq,gc,centerX,centerY,cH,d(gT(f1)),eZ)else gb(fE,centerX,centerY,hX,gd,cH)gp(fE,gS,hX,centerX,centerY,cH,d(hX),eZ)end;gw(fE,cA,cH)gU(fE,f1,eZ,centerX,centerY)end end;h8(fE,fC,h9,ha)hd(fE,he)hh(fE)hv(fE)if showHelp then hN(fE)end;return fE end;function hS.HUDEpilogue(fE)fE[#fE+1]="</svg>"return fE end;function hS.ExtraData(fE)local i0=fy(1240)local i1=fz(55)local i2=i1+10;local i3;local i4=0;local fC=fB()if VertTakeOffEngine then fC=fC.."-VERTICAL"end;if TurnBurn then fC="TB-"..fC end;local i5=vec3(core.getWorldAcceleration()):len()/9.80665;i3=core.g()fE[#fE+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then i0=fy(1120)i1=fz(55)i2=i1+10 elseif ar then local i6=fy(770)fE[#fE+1]=c7(i6,i1,"ATMOSPHERE","pdim txt txtend")fE[#fE+1]=c7(i6,i2,e("%.2f",as),"pdim txt txtend","")end;fE[#fE+1]=c7(i0,i1,"GRAVITY","pdim txt txtend")fE[#fE+1]=c7(i0,i2,e("%.2f",i3/9.80665),"pdim txt txtend")fE[#fE+1]=c7(i0,i1+20,"ACCEL","pdim txt txtend")fE[#fE+1]=c7(i0,i2+20,e("%.2f",i5),"pdim txt txtend")fE[#fE+1]=c7(fy(960),fz(180),fC,"txtbig txtmid")end;function hS.DrawOdometer(fE,aa,TotalDistanceTravelled,ab)local i3;local i7=0;local i8=0;local i4=0;if ar then i4=LastMaxBrakeInAtmo else i4=LastMaxBrake end;maxThrust=a:maxForceForward()i3=core.g()if i3>0.1 then i8=aw*i3;i7=maxThrust/i3 end;fE[#fE+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fy(660),fy(700),fz(35),fy(960),fz(55),fy(1240),fz(35),fy(1280))if l()==0 or RemoteHud then fE[#fE+1]=c7(fy(700),fz(20),e("Trip: %.2f km",aa),"txtstart")fE[#fE+1]=c7(fy(700),fz(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fE[#fE+1]=c7(fy(830),fz(20),"Trip Time: "..d2(ab),"txtstart")fE[#fE+1]=c7(fy(830),fz(30),"Total Time: "..d2(TotalFlightTime),"txtstart")fE[#fE+1]=c7(fy(970),fz(20),e("Mass: %.2f Tons",aw/1000),"txtstart")fE[#fE+1]=c7(fy(1240),fz(10),e("Max Brake: %.2f kN",i4/1000),"txtend")fE[#fE+1]=c7(fy(1240),fz(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if i3>0.1 then fE[#fE+1]=c7(fy(970),fz(30),e("Max Mass: %.2f Tons",i7/1000),"txtstart")fE[#fE+1]=c7(fy(1240),fz(20),e("Req Thrust: %.2f kN",i8/1000),"txtend")else fE[#fE+1]=c7(fy(970),fz(30),"Max Mass: n/a","txtstart")fE[#fE+1]=c7(fy(1240),fz(20),"Req Thrust: n/a","txtend")end end;fE[#fE+1]="</g>"return fE end;function hS.DrawWarnings(fE)return hh(fE)end;function hS.DisplayOrbitScreen(fE)return hv(fE)end;function hS.DisplayMessage(fE,hq)if hq~="empty"then local c9=310;for i9 in string.gmatch(hq,"([^\n]+)")do c9=c9+35;fE[#fE+1]=c7("50%",c9,i9,"msg")end end;if ag~=0 then unit.setTimer("msgTick",ag)ag=0 end end;function hS.DrawDeadZone(fE)fE[#fE+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function hS.UpdateRadar()if radar_1 then local ia=radar_1.getEntries()local ib=radar_1.getData()local ic=fy(1770)local id=fz(330)if#ia>0 then local ie=ib:find('identifiedConstructs":%[%]')if ie==nil and perisPanelID==nil then ak=1;hM()end;if ie~=nil and perisPanelID~=nil then hM()end;if radarPanelID==nil then hM()end;ai=c7(ic,id,"Radar: "..#ia.." contacts","pbright txtbig txtmid")local ig={}for db,dc in pairs(ia)do if radar_1.hasMatchingTransponder(dc)==1 then table.insert(ig,dc)end end;if#ig>0 then local c9=fz(15)local c8=fy(1370)ai=ai..c7(c8,c9,"Friendlies In Range","pbright txtbig txtmid")for db,dc in pairs(ig)do c9=c9+20;ai=ai..c7(c8,c9,radar_1.getConstructName(dc),"pdim txtmid")end end else local ih;ih=ib:find('worksInEnvironment":false')if ih then ai=c7(ic,id,"Radar: Jammed","pbright txtbig txtmid")else ai=c7(ic,id,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ak=0;hM()end end end end;function hS.DrawSettings(fE)if#bV>0 then local c8=fy(640)local c9=fz(200)fE[#fE+1]=[[<g class="pbright txtvspd txtstart">]]for db,dc in pairs(bV)do fE[#fE+1]=c7(c8,c9,dc..": ".._G[dc])c9=c9+20;if db%12==0 then c8=c8+fy(350)c9=fz(200)end end;fE[#fE+1]=c7(fy(640),fz(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fE[#fE+1]="</g>"end;return fE end;return hS end;local function ii()local function ij()local function ik(il,im)return il.name<im.name end;bX={}for db,dc in pairs(b2[0])do bX[#bX+1]={name=dc.name,index=db}end;table.sort(bX,ik)end;local dd={}function dd.UpdateAtlasLocationsList()ij()end;function dd.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"a9=nil;CustomTarget=nil;return true end;local io=bX[AutopilotTargetIndex].index;local ip=b2[0][io]if ip.center then AutopilotTargetName=ip.name;a9=b7[0][io]if CustomTarget~=nil then if as==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=ip;for _,dc in pairs(b7[0])do if dc.name==CustomTarget.planetname then a9=dc;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(a9.center)else AutopilotTargetCoords=CustomTarget.position end;if a9.planetname~="Space"then if a9.hasAtmosphere then AutopilotTargetOrbit=d(a9.radius*(TargetOrbitRadius-1)+a9.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(a9.radius*(TargetOrbitRadius-1)+a9.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=ba(a9):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function dd.adjustAutopilotTargetIndex(g8)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if g8==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bX then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bX end end;if AutopilotTargetIndex==0 then bc.UpdateAutopilotTarget()else local io=bX[AutopilotTargetIndex].index;local ip=b2[0][io]if ip.name=="Space"then if g8==nil then bc.adjustAutopilotTargetIndex()else bc.adjustAutopilotTargetIndex(1)end else bc.UpdateAutopilotTarget()end end else Z="Disengage autopilot before changing Interplanetary Helper"end end;function dd.findAtlasIndex(iq)for db,dc in pairs(iq)do if dc.name and dc.name==CustomTarget.name then return db end end;return-1 end;for db,dc in pairs(SavedLocations)do table.insert(b2[0],dc)end;ij()dd.UpdateAutopilotTarget()return dd end;local function ir()local is={}local function it(eZ)local iu=AutopilotEndSpeed;if not Autopilot then iu=0 end;if not ar then return b8.computeDistanceAndTime(eZ,iu,aw,0,0,LastMaxBrake-AutopilotPlanetGravity*aw)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b8.computeDistanceAndTime(eZ,iu,aw,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*aw)else return 0,0 end end end;local function iv(eZ)local iu=AutopilotEndSpeed;if not Autopilot then iu=0 end;return b8.computeDistanceAndTime(eZ,iu,aw,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*aw)end;function is.GetAutopilotBrakeDistanceAndTime(eZ)return it(eZ)end;function is.GetAutopilotTBBrakeDistanceAndTime(eZ)return iv(eZ)end;local function iw(ix,iy,iz)iy=iy:project_on_plane(ix)iz=iz:project_on_plane(ix)return m(iy:cross(iz):dot(ix),iy:dot(iz))end;local function iA()local function iB()local iC=-1;local iD=-1;if vBooster then iC=vBooster.distance()end;if hover then iD=hover.distance()end;if iC~=-1 and iD~=-1 then if iC<iD then return iC else return iD end elseif iC~=-1 then return iC elseif iD~=-1 then return iD else return-1 end end;local iE=iB()local iF=-1;if telemeter_1 then iF=telemeter_1.getDistance()end;if iE~=-1 and iF~=-1 then if iE<iF then return iE else return iF end elseif iE~=-1 then return iE else return iF end end;function is.APTick()ar=j()>0;as=j()at=core.getAltitude()ao=iA()bD=p()bj=bD;if antigrav then bP=antigrav.getState()==1 end;local iG=1;local iH=1;local iI=bD-bj;local iJ=-math.deg(iw(bE,bH,bF))local iK=math.deg(iw(bG,bH,bF))local g8=bJ*-1;bi=ar and iJ<-YawStallAngle or iJ>YawStallAngle or iK<-PitchStallAngle or iK>PitchStallAngle;local iL=system.getMouseDeltaX()local iM=system.getMouseDeltaY()if InvertMouse and not Y then iM=-iM end;S=0;W=0;R=0;sys=b7[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=ba(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bH)if at==0 then at=(bL-planet.center):len()-planet.radius end;local i3=planet:getGravity(core.getConstructWorldPos()):len()*aw;bk=0;b9=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and Y then if not be then ae=ae+iL;af=af+iM end else ae=0;af=0 end else ae=ae+iL;af=af+iM;ah=math.sqrt(ae*ae+af*af)if not Y and l()==0 then if userControlScheme=="virtual joystick"then if ae>0 and ae>DeadZone then S=S-(ae-DeadZone)*MouseXSensitivity elseif ae<0 and ae<DeadZone*-1 then S=S-(ae+DeadZone)*MouseXSensitivity else S=0 end;if af>0 and af>DeadZone then R=R-(af-DeadZone)*MouseYSensitivity elseif af<0 and af<DeadZone*-1 then R=R-(af+DeadZone)*MouseYSensitivity else R=0 end else ae=0;af=0;if userControlScheme=="mouse"then R=(-utils.smoothstep(iM,-100,100)+0.5)*2*iG;S=(-utils.smoothstep(iL,-100,100)+0.5)*2*iH end end end end;local iN=bI>8334;if bI>SpaceSpeedLimit/3.6 and not ar and not Autopilot and not iN then Z="Space Speed Engine Shutoff reached"cd(0)end;if not iN and LastIsWarping then if not BrakeIsOn then cN()end;if Autopilot then cF()end end;LastIsWarping=iN;if ar and as>0.09 then if bI>bn/3.6 and not AtmoSpeedAssist and not az then BrakeIsOn=true;az=true elseif not AtmoSpeedAssist and az then if bI<bn/3.6 then BrakeIsOn=false;az=false end end end;if BrakeIsOn then V=1 else V=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local iO=false;if CustomTarget~=nil then iO=cO(CustomTarget.position-bL,0.01)else iO=cO(vec3(bH),0.01)end;bg=true;if iO and(c(bT)<2 or c(bS)>85)and bI>=bn/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;O=true;al=false;an=true;Autopilot=false;c_()elseif ar and AtmoSpeedAssist then cd(1)else cg(d(bn))end elseif bI>N then cO(vec3(bH),0.01)end end;if RetrogradeIsOn then if ar then RetrogradeIsOn=false elseif bI>N then cO(-vec3(bH))end end;if not ProgradeIsOn and al and not IntoOrbit then if as==0 then O=true;c_()al=false;an=true else al=false;cF()end end;if an and CustomTarget~=nil and(at<HoldAltitude+200 and at>HoldAltitude-200)and bI*3.6>bn-100 and c(bK)<20 and as>=0.1 and(CustomTarget.position-bL):len()>2000+at then cF()an=false end;if VertTakeOff then bg=true;local iP=HoldAltitude;if bK<-30 then Z="Unable to achieve lift. Safety Landing."ad=0;bg=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bP or HoldAltitude<planet.spaceEngineMinAltitude then if bP then iP=antigrav.getBaseAltitude()end;if at<iP-100 then bo=0;ad=15;BrakeIsOn=false elseif bK>0 then BrakeIsOn=true;ad=0 elseif bK<-30 then BrakeIsOn=true;ad=15 elseif at>=iP then if bP then if Autopilot or VectorToTarget then cp()else BrakeIsOn=true;VertTakeOff=false end;Z="Takeoff complete. Singularity engaged"else BrakeIsOn=false;Z="VTO complete. Engaging Horizontal Flight"cp()end;ad=0 end else if as>0.08 then bo=0;BrakeIsOn=false;ad=20 elseif as<0.08 and as>0 then BrakeIsOn=false;if bA then bo=0;ad=20 else ad=0;bo=36;cg(3500)end else bg=autoRollPreference;IntoOrbit=true;by=false;CancelIntoOrbit=false;bs=false;bq=nil;br=nil;if bx==nil then bx=planet end;bw=iP;bv=true;VertTakeOff=false end end;if bo~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local iQ=q(bo-bS,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(iQ)local iR=q(vTpitchPID:get(),-1,1)R=iR end end;if IntoOrbit then local cX;local iS=false;local iT,iU=ck(bw)local iV=iT..iU;if bx==nil then bx=planet;if VectorToTarget then bx=a9 end end;if not bv then bw=math.floor(bx.radius+bx.surfaceMaxAltitude+LowOrbitHeight)if bx.hasAtmosphere then bw=math.floor(bx.radius+bx.noAtmosphericDensityAltitude+LowOrbitHeight)end;bv=true end;if bu.VectorToTarget then cX=CustomTarget.position-bL end;local iW,iX=ba(bx):escapeAndOrbitalSpeed((bL-bx.center):len()-bx.radius)local iY=bT;if not bs then local iZ=false;local i_=false;cd(0)br=0;bp="Aligning to orbital path - OrbitHeight: "..iV;if bu.VectorToTarget then cO(cX:normalize():project_on_plane(bJ))iS=bF:dot(cX:project_on_plane(bE):normalize())>0.95 else cO(bH)iS=iJ<0.5;if bI<150 then iS=true end end;R=0;bq=0;if bS<=bq+1 and bS>=bq-1 then iZ=true else iZ=false end;if iY<=br+1 and iY>=br-1 then i_=true else i_=false end;if iZ and i_ and iS then bq=nil;br=nil;bs=true end else if bu.VectorToTarget then cO(cX:normalize():project_on_plane(bJ))elseif bI>150 then cO(bH)end;R=0;if bu.VectorToTarget then local a5,_=b8.computeDistanceAndTime(bI,bn/3.6,aw,0,0,LastMaxBrake)if by and cX:len()>15000+a5+at then bp="Orbiting to Target"if orbit.periapsis.altitude<bx.noAtmosphericDensityAltitude then by=false end elseif by or cX:len()<15000+a5+at then Z="Orbit complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;O=true;an=true;bu.VectorToTarget,bu.AutopilotAlign=false,false;cq()c_()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and at>bw*0.9 and at<bw*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bw*0.99 and orbit.apoapsis.altitude>=bw*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or by then if by then BrakeIsOn=false;cd(0)bq=0;if not bu.VectorToTarget then Z="Orbit complete"cq()end else bC=bC+1;if bC>=2 then by=true end end else bp="Adjusting Orbit - OrbitHeight: "..iV;bt=true;cg(iX*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local j0=bK;local j1=at-bw;local j2=c(j1)if bK<10 and c(bS)<10 and j2<100 then j0=bK*2 end;if j0<10 and c(bS)<10 and j2<100 then j0=j0*2 end;if j0<5 and c(bS)<5 and j2<100 then j0=j0*4 end;VSpdPID:inject(j0)bq=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(j1)bq=q(bq-q(OrbitAltPID:get(),-15,15),-90,90)end end else local j3=2.75;local j4=c(o(iW*j3))local j5=j4%50;if j5>0 then j4=j4-j5+50 end;BrakeIsOn=false;if at<bw*0.8 then bp="Escaping planet gravity - OrbitHeight: "..iV;bq=utils.map(bK,200,0,-15,80)elseif at>=bw*0.8 and at<bw*1.15 then bp="Approaching orbital corridor - OrbitHeight: "..iV;j4=j4*0.75;bq=utils.map(bK,100,-100,-15,65)elseif at>=bw*1.15 and at<bw*1.5 then bp="Approaching orbital corridor - OrbitHeight: "..iV;j4=j4*0.75;if bK<0 or bt then bq=utils.map(at,bw*1.5,bw*1.01,-30,0)else bq=utils.map(at,bw*0.99,bw*1.5,0,30)end elseif at>bw*1.5 then bp="Reentering orbital corridor - OrbitHeight: "..iV;bq=-85;local j6=utils.map(bK,-150,-400,1,0.55)j4=j4*j6 end;cg(d(j4))end end;if bq~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local j7=bq-bS;OrbitPitchPID:inject(j7)local j8=q(OrbitPitchPID:get(),-0.5,0.5)R=j8 end end;if Autopilot and as==0 and not al then local j9,ja=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local jb=(CustomTarget.position-a9.center):normalize()local jc=jb:project_on_plane((a9.center-bL):normalize()):normalize()local jd=a9.center+jc*(a9.radius+AutopilotTargetOrbit)local je=CustomTarget.position+(CustomTarget.position-a9.center):normalize()*(AutopilotTargetOrbit-a9:getAltitude(CustomTarget.position))if(bL-jd):len()<(bL-je):len()then j9=jd;AutopilotTargetCoords=j9 else j9=CustomTarget.position+(CustomTarget.position-a9.center):normalize()*(AutopilotTargetOrbit-a9:getAltitude(CustomTarget.position))AutopilotTargetCoords=j9 end;ct(a9,AutopilotTargetCoords)ja=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;ja=true;TargetSet=true;AutopilotRealigned=true;j9=CustomTarget.position+(bL-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local jb=(bL+bH*100000-a9.center):normalize()local jc=jb:project_on_plane((a9.center-bL):normalize()):normalize()if jc:len()<1 then jb=(bL+bF*100000-a9.center):normalize()jc=jb:project_on_plane((a9.center-bL):normalize()):normalize()end;j9=a9.center+jc*(a9.radius+AutopilotTargetOrbit)AutopilotTargetCoords=j9;TargetSet=true;ja=true;AutopilotRealigned=true;ct(a9,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(j9)-bL):len()local hr,em,en=b7:getPlanetarySystem(0):castIntersections(bL,bH:normalize(),function(ea)if ea.noAtmosphericDensityAltitude>0 then return ea.radius+ea.noAtmosphericDensityAltitude else return ea.radius+ea.surfaceMaxAltitude*1.5 end end)local hs=em;if en~=nil and em~=nil then hs=math.min(en,em)end;if hs~=nil and hs<AutopilotDistance and hr.name==a9.name then AutopilotDistance=hs end;local iO=true;local jf=(a9.center-(bL+vec3(bH):normalize()*AutopilotDistance)):len()-a9.radius;local hq,co=ck(jf)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hq..'", "unit":"'..co..'"}')local a5,a6;if not TurnBurn then a5,a6=it(bI)else a5,a6=iv(bI)end;if bI>300 and AutopilotAccelerating then local cX=vec3(j9)-bL;local jg=q(math.deg(iw(bE,bH:normalize(),cX:normalize()))*bI/500,-90,90)local jh=q(math.deg(iw(bG,bH:normalize(),cX:normalize()))*bI/500,-90,90)if c(jg)<20 and c(jh)<20 then jg=jg*2;jh=jh*2 end;if c(jg)<2 and c(jh)<2 then jg=jg*2;jh=jh*2 end;local iJ=-math.deg(iw(bE,bF,bH:normalize()))local iK=-math.deg(iw(bG,bF,bH:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(jh-iK)local ji=q(apPitchPID:get(),-1,1)R=R+ji;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(jg-iJ)local jj=q(apYawPID:get(),-1,1)S=S+jj;ja=true;if c(jg)>2 or c(jh)>2 then AutopilotStatus="Adjusting Trajectory"else AutopilotStatus="Accelerating"end end;if jf<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=ba(a9):escapeAndOrbitalSpeed(jf)end end;if not AutopilotCruising and not AutopilotBraking and not ja then iO=cO((j9-bL):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then iO=cO(-vec3(bH):normalize())end;if AutopilotAccelerating then if not M then BrakeIsOn=false;cd(AutopilotInterplanetaryThrottle)F=x(AutopilotInterplanetaryThrottle,2)M=true end;local jk=unit.getThrottle()if AtmoSpeedAssist then jk=F end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or jk==0 and M then AutopilotAccelerating=false;AutopilotStatus="Cruising"AutopilotCruising=true;cd(0)end;if AutopilotDistance<=a5 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true;cd(0)M=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;V=1 end;if TurnBurn then cd(1,true)end;local _,iX=ba(a9):escapeAndOrbitalSpeed((bL-planet.center):len()-planet.radius)local cX;if CustomTarget~=nil then cX=CustomTarget.position-bL end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bI<50 then Z="Autopilot complete, arrived at space location"AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bI<=iX and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then Z="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cd(0)M=false;ProgradeIsOn=true;al=true;ct(a9,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 then AutopilotStatus="Circularizing"local _,iX=ba(a9):escapeAndOrbitalSpeed((bL-planet.center):len()-planet.radius)if bI<=iX then if CustomTarget~=nil then if bH:normalize():dot(cX:normalize())>0.4 then AutopilotStatus="Orbiting to Target"if not WaypointSet then BrakeIsOn=false;ct(a9,CustomTarget.position)WaypointSet=true end else Z="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cd(0)M=false;ProgradeIsOn=true;al=true;BrakeIsOn=false;ct(a9,CustomTarget.position)WaypointSet=false end else BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Z="Autopilot completed, orbit established"V=0;cd(0)M=false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then ProgradeIsOn=true;al=true end end end end elseif AutopilotCruising then if AutopilotDistance<=a5 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true end;local jk=unit.getThrottle()if AtmoSpeedAssist then jk=F end;if jk>0 then AutopilotAccelerating=true;AutopilotStatus="Accelerating"AutopilotCruising=false end else if iO then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(a9.center)+(AutopilotTargetOrbit+a9.radius)*bG;AutopilotShipUp=bE;AutopilotShipRight=bG end;AutopilotRealigned=true elseif iO then AutopilotAccelerating=true;AutopilotStatus="Accelerating"if not M then cd(AutopilotInterplanetaryThrottle,true)F=x(AutopilotInterplanetaryThrottle,2)M=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and as>0)then Z="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"V=0;cd(0)M=false;ProgradeIsOn=true;al=true;ct(a9,CustomTarget.position)end;if X then bg=true;local jh=0;local f2=bL+vec3(unit.getMasterPlayerRelativePosition())local jl=f2-bL;local jm=vec3(jl):project_on(bF):len()local jn=vec3(jl):project_on(bG):len()local ah=math.sqrt(jm*jm+jn*jn)cO(jl:normalize())local jo=40;local jp=ah<jo;local jq=100;local jr=q((ah-jo)/2,10,jq)R=0;local iO=c(S)<0.1;if iO and bI<jr and not jp then BrakeIsOn=false;jh=-20 else BrakeIsOn=true;jh=0 end;local js=0;if c(jh-bS)>js then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(jh-bS)local ji=pitchPID:get()R=ji end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local cH=unit.getClosestPlanetInfluence()>0;local jt=HoldAltitude-at;local ju=500+bI;local jv=1;if AutoTakeoff then jv=q(bI/100,0.1,1)end;local jh=(utils.smoothstep(jt,-ju,ju)-0.5)*2*MaxPitch*jv;if not Reentry and not al and not VectorToTarget and bF:dot(bH:normalize())<0.99 then jh=(utils.smoothstep(jt,-ju*q(20-19*as*10,1,20),ju*q(20-19*as*10,1,20))-0.5)*2*MaxPitch*q(2-as*10,1,2)*jv end;if not AltitudeHold then jh=0 end;if LockPitch~=nil then if cH and not IntoOrbit then jh=LockPitch else LockPitch=nil end end;bg=true;local jw=R;if Reentry then local jx=d(bn)local jy,jz=b8.computeDistanceAndTime(bI,jx/3.6,aw,0,0,LastMaxBrake-planet.gravity*9.8*aw)local jA=at-(planet.noAtmosphericDensityAltitude+5000)if not bR and at>planet.noAtmosphericDensityAltitude+5000 and bI<=jx/3.6 and bI>jx/3.6-10 and c(bH:normalize():dot(bF))>0.9 then cd(0)elseif bR and(jy>-1 and jA<=jy or at<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cg(jx,true)if not O then jh=-80;if as>0.02 then Z="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;jh=0;bg=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and at>planet.noAtmosphericDensityAltitude+5000 then bg=true elseif at<=planet.noAtmosphericDensityAltitude+5000 then cg(jx)if not bR and r:getTargetSpeed(axisCommandId.longitudinal)==bn then O=false;Reentry=false;bg=true end end end;if bI>N and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then cO(vec3(bH))end;if(VectorToTarget or am)and AutopilotTargetIndex>0 and as>0.01 then local cX;if CustomTarget~=nil then cX=CustomTarget.position-bL else cX=a9.center-bL end;local jg=math.deg(iw(bJ:normalize(),bH,cX))*2;local jB=math.rad(c(bT))if bI>minRollVelocity and as>0.01 then local jC=q(90-jh*2,-90,90)bk=q(jg*2,-jC,jC)local jD=jg;jg=q(q(jg,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jB)+4*(bS-jh)*math.sin(math.rad(bT)),-YawStallAngle*0.80,YawStallAngle*0.80)jh=q(q(jh*math.cos(jB),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(jD)*math.sin(jB),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bk=0;jg=q(jg,-YawStallAngle*0.80,YawStallAngle*0.80)end;local jE=iJ-jg;if not bi and bI>minRollVelocity and as>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(jE)local jj=q(yawPID:get(),-1,1)S=S+jj elseif ar and ao>-1 or bI<minRollVelocity then cO(cX)elseif bi and as>0.01 then if(iJ<-YawStallAngle or iJ>YawStallAngle)and as>0.01 then cO(bH)end;if(iK<-PitchStallAngle or iK>PitchStallAngle)and as>0.01 then jh=q(bS-iK,bS-PitchStallAngle*0.80,bS+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local iP=planet:getAltitude(CustomTarget.position)local jA=math.sqrt(cX:len()^2-(at-iP)^2)local jF=LastMaxBrakeInAtmo;if jF then jF=jF*q(bI/100,0.1,1)*as else jF=LastMaxBrake end;if as<0.01 then jF=LastMaxBrake end;local jG=bH:len()-c(bK)local jH=vec3(core.getWorldAirFrictionAcceleration())local jI=math.sqrt(jH:len()-jH:project_on(g8):len())*aw;if bI>100 then a5,a6=b8.computeDistanceAndTime(bI,100,aw,0,0,jF+jI)local jJ,jK=b8.computeDistanceAndTime(100,0,aw,0,0,jF/2)a5=a5+jJ else a5,a6=b8.computeDistanceAndTime(bI,0,aw,0,0,jF/2)end;StrongBrakes=true;if not am and not Reentry and jA<=a5+bI*iI/2 and(bH:project_on_plane(bJ):normalize():dot(cX:project_on_plane(bJ):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cd(0)if AltitudeHold then cr()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(jG<0.1 or jA<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<jA)then if not bP then BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"end;LastDistanceToTarget=jA end elseif VectorToTarget and as==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and a9.name==planet.name then local cX=CustomTarget.position-bL;local iP=planet:getAltitude(CustomTarget.position)local jA=math.sqrt(cX:len()^2-(at-iP)^2)local jF=LastMaxBrakeInAtmo;if jF then a5,a6=b8.computeDistanceAndTime(bI,0,aw,0,0,jF/2)StrongBrakes=true;if jA<=a5+bI*iI/2 and bH:project_on_plane(bJ):normalize():dot(cX:project_on_plane(bJ):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;O=true;al=false;an=true;Autopilot=false;c_()end end;LastDistanceToTarget=jA end end end;if as==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not by and not IntoOrbit then bw=HoldAltitude;bv=true;if VectorToTarget then bu.VectorToTarget=true end;cq()VectorToTarget=false;bs=true end end;if bi and as>0.01 and ao==-1 and bI>minRollVelocity and VectorStatus~="Finalizing Approach"then cO(bH)jh=q(bS-iK,bS-PitchStallAngle*0.80,bS+PitchStallAngle*0.80)end;R=jw;local iF=-1;if BrakeLanding then jh=0;local jL=false;local jM=30;if b9~=nil and b9>0 then local jI=0;local jN=q(as,0.4,2)local jF=LastMaxBrakeInAtmo*q(bI/100,0.1,1)*jN;local jO=b9*jN+jF+jI-i3;local jP=jF/2+jI-i3;local jQ=bI-math.sqrt(c(jP/2)*20/(0.5*aw))*utils.sign(jP)if jQ<0 then jQ=0 end;local jR;if bI>100 then local jS,_=b8.computeDistanceAndTime(bI,100,aw,0,0,jF)local jT,_=b8.computeDistanceAndTime(100,0,aw,0,0,math.sqrt(jF))jR=jS+jT else jR=b8.computeDistanceAndTime(bI,0,aw,0,0,math.sqrt(jF))end;if jR<20 then BrakeIsOn=false else local jU=0;if jQ>100 then local jV,_=b8.computeDistanceAndTime(jQ,100,aw,0,0,jO)local jW,_=b8.computeDistanceAndTime(100,0,aw,0,0,b9*jN+math.sqrt(jF)+jI-i3)jU=jV+jW else jU,_=b8.computeDistanceAndTime(jQ,0,aw,0,0,b9*jN+math.sqrt(jF)+jI-i3)end;jU=(jU+15+bI*iI)*1.1;local jX=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if jX then local iP=planet:getAltitude(CustomTarget.position)local jY=at-iP-100;local cX=CustomTarget.position-bL;local jZ=math.sqrt(cX:len()^2-(at-iP)^2)if jZ>100 then jX=false elseif jY<=jU or jU==-1 then BrakeIsOn=true;jL=true else BrakeIsOn=false;jL=true end end;if not jX and CalculateBrakeLandingSpeed then if jU>=jM then BrakeIsOn=true else BrakeIsOn=false end;jL=true end end end;if not bR then cd(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)iF=ao;if iF>-1 then bg=autoRollPreference;if bI<1 or bH:normalize():dot(bJ)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)ad=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bH:normalize():dot(-g8)<0.999 then BrakeIsOn=true elseif bK<-brakeLandingRate and not jL then BrakeIsOn=true elseif not jL then BrakeIsOn=false end end;if AutoTakeoff or am then local hr,en,em;if AutopilotTargetCoords~=nil then hr,en,em=b7:getPlanetarySystem(0):castIntersections(bL,(AutopilotTargetCoords-bL):normalize(),function(ea)return ea.radius+ea.noAtmosphericDensityAltitude end)end;if bP then if at>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cd(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(jh)<15 and at/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bR and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bI<N then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cd(0)elseif am then cd(0)BrakeIsOn=true end elseif am and as==0 and a9~=nil and(hr==nil or hr.name==a9.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bR then cd(0)end;AutopilotAccelerating=true end end;local j_=ao>-1;local k0=bS;if(VectorToTarget or am)and not j_ and bI>minRollVelocity and as>0.01 then local jB=math.rad(c(bT))k0=bS*c(math.cos(jB))+iK*math.sin(jB)end;local k1=q(jh-k0,-PitchStallAngle*0.80,PitchStallAngle*0.80)if as<0.01 and VectorToTarget then k1=q(jh-k0,-85,MaxPitch)elseif as<0.01 then k1=q(jh-k0,-MaxPitch,MaxPitch)end;if c(bT)<5 or VectorToTarget or BrakeLanding or j_ or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(k1)local ji=pitchPID:get()R=R+ji end end;if antigrav~=nil and(antigrav and not ExternalAGG and at<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=iA()return is end;function script.onStart()local function k2()local function k3(k4)local k5=dbHud_1.hasKey;for db,dc in pairs(k4)do if k5(dc)then local cn=f(dbHud_1.getStringValue(dc))if cn~=nil then _G[dc]=cn;aM=true end end end end;if dbHud_1 then local k5=dbHud_1.hasKey;if not useTheseSettings then k3(c0())coroutine.yield()k3(b)else k3(b)Z="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ag=5;aM=false end;coroutine.yield()if aM then Z="Loaded Saved Variables"K=x(ResolutionX/2,0)L=x(ResolutionY/2,0)aK=ResolutionX;aL=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bg=autoRollPreference;bn=AtmoSpeedLimit;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]elseif not useTheseSettings then Z="No Saved Variables Found - Exit HUD to save settings"end else Z="No databank found. Attach one to control unit and rerun the autoconfigure to save preferences and locations"end;if LastStartTime+180<bD then LastMaxBrakeInAtmo=0 end;LastStartTime=bD;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then Z="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ag=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=at end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=aw end end;local function k6()local function k7(k8,k9)if k8>k9 then k9=k8 end;if ContainerOptimization>0 then k9=k9-k9*ContainerOptimization*0.05 end;if FuelTankOptimization>0 then k9=k9-k9*FuelTankOptimization*0.05 end;return k9 end;local ka=core.getElementNameById;local kb=fuelX~=0 and fuelY~=0;for db in pairs(au)do local type=core.getElementTypeById(au[db])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(au[db])),'^.*vertical.*$')then bO=true end end;if n(type,'^.*Space Engine$')then bB=true;if n(tostring(core.getElementTagsById(au[db])),'^.*vertical.*$')then local kc=core.getElementRotationById(au[db])if kc[4]<0 then if o(-kc[4],0.1)==0.5 then bz=true end else if o(kc[4],0.1)==0.5 then bA=true end end end end;if type=="Landing Gear"then P=true end;if type=="Dynamic Core Unit"then local kd=h(au[db])if kd>10000 then B=128 elseif kd>1000 then B=64 elseif kd>150 then B=32 end end;aS=aS+h(au[db])if kb and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local kd=h(au[db])local ke=k(au[db])local k8=0;local g0=p()if type=="Atmospheric Fuel Tank"then local k9=400;local kf=35.03;if kd>10000 then k9=51200;kf=5480 elseif kd>1300 then k9=6400;kf=988.67 elseif kd>150 then k9=1600;kf=182.67 end;k8=ke-kf;if fuelTankHandlingAtmo>0 then k9=k9+k9*fuelTankHandlingAtmo*0.2 end;k9=k7(k8,k9)aP[#aP+1]={au[db],ka(au[db]),k9,kf,k8,g0}end;if type=="Rocket Fuel Tank"then local k9=320;local kf=173.42;if kd>65000 then k9=40000;kf=25740 elseif kd>6000 then k9=5120;kf=4720 elseif kd>700 then k9=640;kf=886.72 end;k8=ke-kf;if fuelTankHandlingRocket>0 then k9=k9+k9*fuelTankHandlingRocket*0.1 end;k9=k7(k8,k9)aR[#aR+1]={au[db],ka(au[db]),k9,kf,k8,g0}end;if type=="Space Fuel Tank"then local k9=2400;local kf=182.67;if kd>10000 then k9=76800;kf=5480 elseif kd>1300 then k9=9600;kf=988.67 end;k8=ke-kf;if fuelTankHandlingSpace>0 then k9=k9+k9*fuelTankHandlingSpace*0.2 end;k9=k7(k8,k9)aQ[#aQ+1]={au[db],ka(au[db]),k9,kf,k8,g0}end end end;if not bO then VertTakeOff,VertTakeOffEngine=false,false end end;local function kg()if gyro~=nil then ay=gyro.getState()==1 end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(ar or not ar and at<10000)then for _,dc in pairs(door)do dc.toggle()end end;if switch then for _,dc in pairs(switch)do dc.toggle()end end;if forcefield and(ar or not ar==0 and at<10000)then for _,dc in pairs(forcefield)do dc.toggle()end end;if antigrav then bP=antigrav.getState()==1;if bP and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if P then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not ar and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;if not P then GearExtended=true end else BrakeIsOn=false end;if bh~=nil then r:setTargetGroundAltitude(bh)if bh==0 and not P then GearExtended=true;BrakeIsOn=true end else bh=a:getTargetGroundAltitude()if GearExtended then r:setTargetGroundAltitude(LandingGearGroundHeight)else r:setTargetGroundAltitude(TargetHoverHeight)end end;if ar and ao~=-1 then b9=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ar end;local function kh(ki,kj,kk,kl,c8,c9,km,kn,ko,kp)local kq={enableName=ki,disableName=kj,width=kk,height=kl,x=c8,y=c9,toggleVar=km,toggleFunction=kn,drawCondition=ko,hovered=false}if kp then table.insert(aJ,kq)else table.insert(aI,kq)end;return kq end;local function kr(ks)if not bU then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif ks=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif ks=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif ks=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bV=c0(ks)showHud=false else bV={}showHud=true end end;local function kt()bU=not bU;if bU then aH=aJ;Z="Hold SHIFT to see Settings"bW=showHud else aH=aI;Z="Hold SHIFT to see Control Buttons"kr()showHud=bW end end;local function ku(dc)_G[dc]=not _G[dc]if _G[dc]then Z=dc.." set to true"else Z=dc.." set to false"end;if dc=="showHud"then bW=_G[dc]elseif dc=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function kv()local kw=50;local kx=340;local c8=500;local c9=aL/2-400;local ky=0;for db,dc in pairs(c0("boolean"))do if type(_G[dc])=="boolean"then kh(dc,dc,kx,kw,c8,c9,function()return _G[dc]end,function()ku(dc)end,function()return true end,true)c9=c9+kw+20;if ky==7 then c8=c8+kx+20;c9=aL/2-400;ky=0 else ky=ky+1 end end end;kh("Control View","Control View",kx,kw,10,aL/2-500,function()return true end,kt,function()return true end,true)kh("View Handling Settings",'Hide Handling Settings',kx,kw,10,aL/2-(500-kw),function()return showHandlingVariables end,function()kr("handling")end,function()return true end,true)kh("View Hud Settings",'Hide Hud Settings',kx,kw,10,aL/2-(500-kw*2),function()return showHudVariables end,function()kr("hud")end,function()return true end,true)kh("View Physics Settings",'Hide Physics Settings',kx,kw,10,aL/2-(500-kw*3),function()return showPhysicsVariables end,function()kr("physics")end,function()return true end,true)end;local function kz()local function kA()if dbHud_1 then local position=bL;local fU=planet.name..". "..#SavedLocations;if radar_1 then local dT,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dT~=nil and dT~=""then fU=fU.." "..radar_1.getConstructName(dT)end end;local cL={}cL={position=position,name=fU,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cL;table.insert(b2[0],cL)bc.UpdateAtlasLocationsList()Z="Location saved as "..fU else Z="Databank must be installed to save locations"end end;local function kB()TurnBurn=not TurnBurn end;local function kC(kD)if kD==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;X=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kE()kC(1)end;local function kF()local cK=-1;cK=bc.findAtlasIndex(b2[0])if cK>-1 then table.remove(b2[0],cK)end;cK=-1;cK=bc.findAtlasIndex(SavedLocations)if cK~=-1 then Z=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cK)end;bc.adjustAutopilotTargetIndex()bc.UpdateAtlasLocationsList()end;local function kG()local fU=AutopilotTargetName;if fU==nil then local hq,co=ck((bL-CustomTarget.position):len())fU=CustomTarget.name.." "..hq..co end;if fU==nil then fU="None"end;return"Engage Autopilot: "..fU end;local function kH()local fU=AutopilotTargetName;if fU==nil then fU=CustomTarget.name end;if fU==nil then fU="None"end;return"Disable Autopilot: "..fU end;local function kI()if safeMass>0 then Z="Safe Mass set to "..x(aw,2).." kg"else Z="Intruder Detection reset\nSafe Mass set to "..x(aw,2).." kg"ag=5;bN=false;if bM then system.setWaypoint(bM)end end;safeMass=aw end;local kw=50;local kx=260;local kJ=kh("Enable Brake Toggle","Disable Brake Toggle",kx,kw,aK/2-kx/2,aL/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then Z="Brakes in Toggle Mode"else Z="Brakes in Default Mode"end end)kh("Align Prograde","Disable Prograde",kx,kw,aK/2-kx/2-50-kJ.width,aL/2-kw+380,function()return ProgradeIsOn end,kE)kh("Align Retrograde","Disable Retrograde",kx,kw,aK/2-kx/2+kJ.width+50,aL/2-kw+380,function()return RetrogradeIsOn end,kC,function()return as==0 end)local kK=kh(kG,kH,600,60,aK/2-600/2,aL/2-60/2-400,function()return Autopilot end,cF)kh("Save Position","Save Position",200,kK.height,kK.x+kK.width+30,kK.y,function()return false end,kA,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)kh("Update Position","Update Position",200,kK.height,kK.x+kK.width+30,kK.y,function()return false end,cI,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kh("Clear Position","Clear Position",200,kK.height,kK.x-200-30,kK.y,function()return true end,kF,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kw=60;kx=300;local c8=10;local c9=aL/2-500;kh("Show Help","Hide Help",kx,kw,c8,c9,function()return showHelp end,function()showHelp=not showHelp end)c9=c9+kw+20;kh("View Settings","View Settings",kx,kw,c8,c9,function()return true end,kt)local c9=aL/2-300;kh("Enable Turn and Burn","Disable Turn and Burn",kx,kw,c8,c9,function()return TurnBurn end,kB)kh("Horizontal Takeoff Mode","Vertical Takeoff Mode",kx,kw,c8+kx+20,c9,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then Z="Vertical Takeoff Mode"else Z="Horizontal Takeoff Mode"end end,function()return bO end)c9=c9+kw+20;kh("Show Orbit Display","Hide Orbit Display",kx,kw,c8,c9,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then Z="Orbit Display Enabled"else Z="Orbit Display Disabled"end end)kh("Engage Orbiting","Cancel Orbiting",kx,kw,c8+kx+20,c9,function()return IntoOrbit end,cq,function()return as==0 and unit.getClosestPlanetInfluence()>0 end)c9=c9+kw+20;kh("Glide Re-Entry","Cancel Glide Re-Entry",kx,kw,c8,c9,function()return Reentry end,function()al=true;kE()end,function()return planet.hasAtmosphere and not ar end)kh("Parachute Re-Entry","Cancel Parachute Re-Entry",kx,kw,c8+kx+20,c9,function()return Reentry end,c_,function()return planet.hasAtmosphere and not ar end)c9=c9+kw+20;kh("Engage Follow Mode","Disable Follow Mode",kx,kw,c8,c9,function()return X end,cs,function()return l()==1 end)kh("Enable Repair Arrows","Disable Repair Arrows",kx,kw,c8+kx+20,c9,function()return aT end,function()aT=not aT;if aT then Z="Repair Arrows Enabled"else Z="Repair Arrows Diabled"end end,function()return l()==1 end)c9=c9+kw+20;if not ExternalAGG then kh("Enable AGG","Disable AGG",kx,kw,c8,c9,function()return bP end,d1,function()return antigrav~=nil end)end;kh("Reset Intruder Alert","Set Safe Mass",kx,kw,c8+kx+20,c9,function()return safeMass>0 end,kI,function()return IntruderAlertSystem end)c9=c9+kw+20;kh(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,kx*2,kw,c8,c9,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})k2()coroutine.yield()k6()coroutine.yield()bd=ir()kg()kv()kz()aH=aI;coroutine.yield()b2=dd()b6=de()b7=b6(dd())b8=ew()ba=f0()bb=fn()bc=ii()bd=ir()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)if UseSatNav then unit.setTimer("fiveSecond",5)end end)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(as>0 or as==0 and at<10000)then for _,dc in pairs(door)do dc.toggle()end end;if switch then for _,dc in pairs(switch)do dc.toggle()end end;if forcefield and(as>0 or as==0 and at<10000)then for _,dc in pairs(forcefield)do dc.toggle()end end;safeMass=aw;d7()if button then button.activate()end;if SetWaypointOnExit then ct(planet,bL)end end;function script.onTick(kL)if kL=="tenthSecond"then local function kM()local kN=system.createData;local kO=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=kO(panelInterplanetary,"value")interplanetaryHeaderText=kN('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=kO(panelInterplanetary,"value")widgetDistanceText=kN('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=kO(panelInterplanetary,"value")widgetTravelTimeText=kN('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=kO(panelInterplanetary,"value")widgetMaxMassText=kN('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=kO(panelInterplanetary,"value")widgetTargetOrbitText=kN('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=kO(panelInterplanetary,"value")widgetCurBrakeDistanceText=kN('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=kO(panelInterplanetary,"value")widgetCurBrakeTimeText=kN('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=kO(panelInterplanetary,"value")widgetMaxBrakeDistanceText=kN('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=kO(panelInterplanetary,"value")widgetMaxBrakeTimeText=kN('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=kO(panelInterplanetary,"value")widgetTrajectoryAltitudeText=kN('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ar then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function kP()s(panelInterplanetary)panelInterplanetary=nil end;local function kQ()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(a9.center-bL):len()else AutopilotDistance=(CustomTarget.position-bL):len()end end;local eZ=bI;local jk=unit.getThrottle()/100;if AtmoSpeedAssist then jk=F end;local kR,kS=b8.computeDistanceAndTime(bI,MaxGameVelocity,aw,a:maxForceForward()*jk,warmup,0)local a5,a6;if not TurnBurn then a5,a6=bd.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a5,a6=bd.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,kT;if not TurnBurn and eZ>0 then _,kT=bd.GetAutopilotBrakeDistanceAndTime(eZ)else _,kT=bd.GetAutopilotTBBrakeDistanceAndTime(eZ)end;local kU=0;local kV=0;if AutopilotCruising or not Autopilot and eZ>5 then kV=b8.computeTravelTime(eZ,0,AutopilotDistance)elseif a5+kR<AutopilotDistance then kU=AutopilotDistance-(a5+kR)kV=b8.computeTravelTime(8333.0556,0,kU)else local kW=(AutopilotDistance-a5)/kR;kR=AutopilotDistance-a5;kS=kS*kW end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return kV elseif AutopilotBraking then return kT elseif AutopilotCruising then return kV+kT else return kS+a6+kV end end;if as>0 and not WasInAtmo then if not bR and AtmoSpeedAssist and(AltitudeHold or Reentry)then cd(1)J=false end end;if bQ~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bQ then cg(bQ,TRUE)else bQ=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then kM()end;if AutopilotTargetName~=nil then local kX=CustomTarget~=nil;planetMaxMass=LastMaxBrakeInAtmo/a9:getGravity(a9.center+vec3(0,0,1)*a9.radius):len()t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=kQ()if kX and not Autopilot then ah=(bL-CustomTarget.position):len()else ah=(AutopilotTargetCoords-bL):len()end;if not TurnBurn then a5,a6=bd.GetAutopilotBrakeDistanceAndTime(bI)a7,a8=bd.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a5,a6=bd.GetAutopilotTBBrakeDistanceAndTime(bI)a7,a8=bd.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hq,co=ck(ah)t(widgetDistanceText,'{"label": "distance", "value": "'..hq..'", "unit":"'..co..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d2(travelTime)..'", "unit":""}')hq,co=ck(a5)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hq..'", "unit":"'..co..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d2(a6)..'", "unit":""}')hq,co=ck(a7)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hq..'", "unit":"'..co..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d2(a8)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",planetMaxMass/1000)..'", "unit":" Tons"}')hq,co=ck(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..e("%.2f",hq)..'", "unit":"'..co..'"}')if as>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if as==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else kP()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;if bN then system.setWaypoint(system.getWaypointFromPlayerPos())end elseif kL=="oneSecond"then local function kY(i3,kZ)if i3==nil then i3=core.g()end;i3=x(i3,5)if kZ~=nil and kZ or(aO==nil or aO~=i3)then local f1=core.getVelocity()local eZ=vec3(f1):len()local k_=f(unit.getData()).maxBrake;if k_~=nil and k_>0 and ar then k_=k_/q(eZ/100,0.1,1)k_=k_/as;if as>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+k_)/2 else LastMaxBrakeInAtmo=k_ end end end;if k_~=nil and k_>0 then LastMaxBrake=k_ end;aO=i3 end end;local function l0(fE)local l1=0;aF=""local l2=aS;local l3=0;local l4=0;local l5=0;local g2=0;local g3=""local l6=core.getElementHitPointsById;for db in pairs(au)do local kd=0;local l7=0;l7=h(au[db])kd=l6(au[db])l3=l3+kd;if kd<l7 then if kd==0 then l5=l5+1 else l4=l4+1 end;if aT and#aC==0 then position=vec3(core.getElementPositionById(au[db]))local c8=position.x-B;local c9=position.y-B;local l8=position.z-B;table.insert(aC,core.spawnArrowSticker(c8,c9,l8+1,"down"))table.insert(aC,core.spawnArrowSticker(c8,c9,l8+1,"down"))core.rotateSticker(aC[2],0,0,90)table.insert(aC,core.spawnArrowSticker(c8+1,c9,l8,"north"))table.insert(aC,core.spawnArrowSticker(c8+1,c9,l8,"north"))core.rotateSticker(aC[4],90,90,0)table.insert(aC,core.spawnArrowSticker(c8-1,c9,l8,"south"))table.insert(aC,core.spawnArrowSticker(c8-1,c9,l8,"south"))core.rotateSticker(aC[6],90,-90,0)table.insert(aC,core.spawnArrowSticker(c8,c9-1,l8,"east"))table.insert(aC,core.spawnArrowSticker(c8,c9-1,l8,"east"))core.rotateSticker(aC[8],90,0,90)table.insert(aC,core.spawnArrowSticker(c8,c9+1,l8,"west"))table.insert(aC,core.spawnArrowSticker(c8,c9+1,l8,"west"))core.rotateSticker(aC[10],-90,0,90)table.insert(aC,au[db])end elseif aT and#aC>0 and aC[11]==au[db]then for fW in pairs(aC)do core.deleteSticker(aC[fW])end;aC={}end end;l1=d(l3/l2*100)if l1<100 then fE[#fE+1]=c7(0,0,"","pbright txt")g2=d(l1*2.55)g3=e("rgb(%d,%d,%d)",255-g2,g2,0)if l1<100 then fE[#fE+1]=c7("50%",1035,"Elemental Integrity: "..l1 .."%","txtbig txtmid","fill:"..g3)if l5>0 then fE[#fE+1]=c7("50%",1055,"Disabled Modules: "..l5 .." Damaged Modules: "..l4,"txtbig txtmid","fill:"..g3)elseif l4>0 then fE[#fE+1]=c7("50%",1055,"Damaged Modules: "..l4,"txtbig txtmid","fill:"..g3)end end end end;local function l9()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function la()local g0=p()local he=bI;local lb=g0-av;if he>1.38889 then he=he/1000;local lc=he*(g0-av)TotalDistanceTravelled=TotalDistanceTravelled+lc;aa=aa+lc end;ab=ab+lb;TotalFlightTime=TotalFlightTime+lb;av=g0 end;local function ld()if safeMass>0 then if aw>safeMass+50 then bN=true;safeMass=-1 elseif aw<safeMass then safeMass=aw end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;ap=false;kY(nil,true)if IntruderAlertSystem then ld()end;la()bb.UpdateRadar()l9()local fE={}bb.ExtraData(fE)if ShowOdometer then fE=bb.DrawOdometer(fE,aa,TotalDistanceTravelled,ab)end;if ShouldCheckDamage then l0(fE)end;aj=table.concat(fE,"")collectgarbage("collect")elseif kL=="fiveSecond"then aq=dbHud_1.getStringValue("SPBAutopilotTargetName")if aq~=nil and aq~=""and aq~="SatNavNotChanged"then local cn=f(dbHud_1.getStringValue("SavedLocations"))if cn~=nil then _G["SavedLocations"]=cn;local cK=-1;local cL;for db,dc in pairs(SavedLocations)do if dc.name and dc.name=="SatNav Location"then cK=db;break end end;if cK~=-1 then cL=SavedLocations[cK]cK=-1;for db,dc in pairs(b2[0])do if dc.name and dc.name=="SatNav Location"then cK=db;break end end;if cK>-1 then b2[0][cK]=cL end;bc.UpdateAtlasLocationsList()Z=cL.name.." position updated"end end;for i=1,#bX do if bX[i].name==aq then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bX[i].name)bc.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif kL=="msgTick"then local fE={}bb.DisplayMessage(fE,"empty")Z="empty"unit.stopTimer("msgTick")ag=3 elseif kL=="animateTick"then bf=true;be=false;ae=0;af=0;unit.stopTimer("animateTick")elseif kL=="hudTick"then local function le(fE)local lf=d(q(ah/(aK/4)*255,0,255))fE[#fE+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ae,af,d(C+0.5)+lf,d(E+0.5)-lf,d(D+0.5)-lf)end;local function lg()for _,dc in pairs(aH)do if dc.hovered then if not dc.drawCondition or dc.drawCondition()then dc.toggleFunction()end;dc.hovered=false end end end;local function lh()local function li(lj,lk,c8,c9,kk,kl)if lj>c8 and lj<c8+kk and lk>c9 and lk<c9+kl then return true else return false end end;local c8=ae+aK/2;local c9=af+aL/2;for _,dc in pairs(aH)do dc.hovered=li(c8,c9,dc.x,dc.y,dc.width,dc.height)end end;local function ll(fE)local function lm(fE,ln,hover,c8,c9,eS,lo,lp,lq,lr,ls)if type(lr)=="function"then lr=lr()end;if type(ls)=="function"then ls=ls()end;fE[#fE+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c8,c9,eS,lo)if ln then fE[#fE+1]=e("%s'",lp)else fE[#fE+1]=lq end;if hover then fE[#fE+1]=" style='stroke:white; stroke-width:2'"else fE[#fE+1]=" style='stroke:black; stroke-width:1'"end;fE[#fE+1]="></rect>"fE[#fE+1]=e("<text x='%f' y='%f' font-size='24' fill='",c8+eS/2,c9+lo/2+5)if ln then fE[#fE+1]="black"else fE[#fE+1]="white"end;fE[#fE+1]="' text-anchor='middle' font-family='Montserrat'>"if ln then fE[#fE+1]=e("%s</text>",lr)else fE[#fE+1]=e("%s</text>",ls)end end;local lt="rgb(50,50,50)'"local lu="rgb(210,200,200)"local lv=lm;for _,dc in pairs(aH)do local kj=dc.disableName;local ki=dc.enableName;if type(kj)=="function"then kj=kj()end;if type(ki)=="function"then ki=ki()end;if not dc.drawCondition or dc.drawCondition()then lv(fE,dc.toggleVar(),dc.hovered,dc.x,dc.y,dc.width,dc.height,lu,lt,kj,ki)end end end;local fE={}bb.HUDPrologue(fE)if showHud then bb.UpdateHud(fE)else bb.DisplayOrbitScreen(fE)bb.DrawWarnings(fE)end;if bU and bV~={}then bb.DrawSettings(fE)end;bb.HUDEpilogue(fE)fE[#fE+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aK,aL)if Z~="empty"then bb.DisplayMessage(fE,Z)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then bb.DrawDeadZone(fE)end end;if w()==0 then if l()==1 and Y then lh()ll(fE)if not be and not bf then local lw=table.concat(fE,"")fE={}fE[#fE+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fE[#fE+1]=lw;fE[#fE+1]="</body>"be=true;fE[#fE+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fE,"")system.setScreen(content)elseif bf then local lw=table.concat(fE,"")fE={}fE[#fE+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fE[#fE+1]=lw;fE[#fE+1]="</body>"end;if not be then fE[#fE+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],K,L,ae,af)end else lg()end else if not Y and l()==0 then lg()if ah>DeadZone then if DisplayDeadZone then le(fE)end end else lh()ll(fE)end;fE[#fE+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],K,L,ae,af)end;fE[#fE+1]=[[</svg></body>]]content=table.concat(fE,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif kL=="apTick"then bd.APTick()end end;function script.onFlush()local function lx(ly,jr)local lz=vec3()local lA=vec3()if ly==axisCommandId.longitudinal then lz=vec3(core.getConstructOrientationForward())lA=bF elseif ly==axisCommandId.vertical then lz=vec3(core.getConstructOrientationUp())lA=bE elseif ly==axisCommandId.lateral then lz=vec3(core.getConstructOrientationRight())lA=bG else return vec3()end;local lB=vec3(core.getWorldGravity())local lC=lB:dot(lA)local lD=vec3(core.getWorldAirFrictionAcceleration())local lE=lD:dot(lA)local lF=vec3(core.getVelocity())local lG=lF:dot(lz)local lH=jr*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(lH-lG)local lI=targetSpeedPID2:get()local lJ=(lI-lE-lC)*lA;return lJ end;local function lK(ly,jr)local lz=vec3()local lA=vec3()if ly==axisCommandId.longitudinal then lz=vec3(core.getConstructOrientationForward())lA=bF elseif ly==axisCommandId.vertical then lz=vec3(core.getConstructOrientationUp())lA=bE elseif ly==axisCommandId.lateral then lz=vec3(core.getConstructOrientationRight())lA=bG else return vec3()end;local lB=vec3(core.getWorldGravity())local lC=lB:dot(lA)local lD=vec3(core.getWorldAirFrictionAcceleration())local lE=lD:dot(lA)local lF=vec3(core.getVelocity())local lG=lF:dot(lz)local lH=jr*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(lH-lG)local lI=targetSpeedPID:get()local lJ=(lI-lE-lC)*lA;return lJ end;local function lL(lM,g7,im)local lN=lM:cross(im):normalize_inplace()local gS=math.acos(q(lN:dot(-g7),-1,1))*constants.rad2deg;if lN:cross(-g7):dot(im)<0 then gS=-gS end;return gS end;if antigrav and not ExternalAGG then if not bP and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bR=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bR and J then cd(0)J=false elseif not bR and not J then F=0;J=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local lO=q(Q+R+system.getControlDeviceForwardInput(),-1,1)local lP=q(T+W+system.getControlDeviceYawInput(),-1,1)local lQ=q(U+S-system.getControlDeviceLeftRightInput(),-1,1)local lR=V;bJ=vec3(core.getWorldVertical())if bJ==nil or bJ:len()==0 then bJ=(planet.center-bL):normalize()end;bL=vec3(core.getConstructWorldPos())bE=vec3(core.getConstructWorldOrientationUp())bF=vec3(core.getConstructWorldOrientationForward())bG=vec3(core.getConstructWorldOrientationRight())bH=vec3(core.getWorldVelocity())aw=core.getConstructMass()bI=vec3(bH):len()bK=-bJ:dot(bH)bT=getRoll(bJ,bF,bG)local lS=bT/180*math.pi;local lT=math.cos(lS)local lU=math.sin(lS)bS=lL(bJ,bF,bG*lT+bE*lU)local lV=bH:normalize()local lW=getRoll(bJ,bF,bG)local lX=c(lW)local lY=utils.sign(lW)local lZ=vec3(core.getWorldAngularVelocity())local l_=lO*pitchSpeedFactor*bG+lP*rollSpeedFactor*bF+lQ*yawSpeedFactor*bE;if bJ:len()>0.01 and(as>0.0 or ProgradeIsOn or Reentry or al or AltitudeHold or IntoOrbit)then if bg==true and c(bk-lW)>autoRollRollThreshold and lP==0 and c(bS)<85 then local m0=bk;local m1=autoRollFactor;if as==0 then m1=m1/4;bk=0;m0=0 end;if rollPID==nil then rollPID=pid.new(m1*0.01,0,m1*0.1)end;rollPID:inject(m0-lW)local m2=rollPID:get()l_=l_+m2*bF end end;if bJ:len()>0.01 and as>0.0 then local m3=20.0;if turnAssist==true and lX>m3 and lO==0 and lQ==0 then local m4=turnAssistFactor*0.1;local m5=turnAssistFactor*0.025;local m6=(lX-m3)/(180-m3)*180;local m7=0;if m6<90 then m7=m6/90 elseif m6<180 then m7=(180-m6)/90 end;m7=m7*m7;local m8=-lY*m5*(1.0-m7)local m9=m4*m7;l_=l_+m9*bG+m8*bE end end;local ma=1;local mb=0;local mc=1;if system.getMouseWheel()>0 then if AltIsOn then if as>0 or Reentry then bn=q(bn+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif ax then local md=F;F=x(q(F+speedChangeLarge/100,-1,1),2)if F>=0 and md<0 then F=0;ax=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if as>0 or Reentry then bn=q(bn-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif ax then local md=F;F=x(q(F-speedChangeLarge/100,-1,1),2)if F<=0 and md>0 then F=0;ax=false end end else ax=true end;G=0;if ar and AtmoSpeedAssist and bR then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bn/3.6-bH:dot(bF))local me=throttlePID:get()I=q(me,-1,1)if I<F and as>0.005 then H=true;r:setThrottleCommand(axisCommandId.longitudinal,q(I,0.01,1))else H=false;r:setThrottleCommand(axisCommandId.longitudinal,F)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bH:len()-bn/3.6)local mf=q(brakePID:get(),0,1)if as>0 and bK<-80 or as>0.005 then G=mf end;if G>0 then if H and I==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else I=q(I,0.01,1)end;local mg=''local mh=vec3()local mi=lx(axisCommandId.vertical,ad*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",mi,mb)local mj='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then mj=mj..ExtraLongitudeTags end;local mk=r:getAxisCommandType(axisCommandId.longitudinal)local ml=r:composeAxisAccelerationFromThrottle(mj,axisCommandId.longitudinal)local mm=lK(axisCommandId.lateral,LeftAmount*1000)mg=mg..' , '.."lateral airfoil , lateral ground "mh=mh+mm;if mh:len()>constants.epsilon then a:setEngineForceCommand(mg,mh,mb,'','','',mc)end;a:setEngineForceCommand(mj,ml,ma)local mn='thrust analog vertical fueled 'local mo='thrust analog lateral fueled 'if ExtraLateralTags~="none"then mo=mo..ExtraLateralTags end;if ExtraVerticalTags~="none"then mn=mn..ExtraVerticalTags end;if ad~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mn,mi,ma)else a:setEngineForceCommand(mn,vec3(),ma)end;if LeftAmount~=0 then a:setEngineForceCommand(mo,mm,ma)else a:setEngineForceCommand(mo,vec3(),ma)end;if lR==0 then lR=G end;local mp=-lR*(brakeSpeedFactor*bH+brakeFlatFactor*lV)a:setEngineForceCommand('brake',mp)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,F)end;local jr=unit.getAxisCommandValue(0)if not bR then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bH:len()-jr/3.6)local mf=q(brakePID:get(),0,1)lR=q(lR+mf,0,1)end;local mp=-lR*(brakeSpeedFactor*bH+brakeFlatFactor*lV)a:setEngineForceCommand('brake',mp)local mg=''local mh=vec3()local mq=false;local mj='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then mj=mj..ExtraLongitudeTags end;local mk=r:getAxisCommandType(axisCommandId.longitudinal)if mk==axisCommandType.byThrottle then local ml=r:composeAxisAccelerationFromThrottle(mj,axisCommandId.longitudinal)a:setEngineForceCommand(mj,ml,ma)elseif mk==axisCommandType.byTargetSpeed then local ml=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)mg=mg..' , '..mj;mh=mh+ml;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then mq=true end end;local mo='thrust analog lateral 'if ExtraLateralTags~="none"then mo=mo..ExtraLateralTags end;local mr=r:getAxisCommandType(axisCommandId.lateral)if mr==axisCommandType.byThrottle then local ms=r:composeAxisAccelerationFromThrottle(mo,axisCommandId.lateral)a:setEngineForceCommand(mo,ms,ma)elseif mr==axisCommandType.byTargetSpeed then local mm=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)mg=mg..' , '..mo;mh=mh+mm end;local mn='thrust analog vertical 'if ExtraVerticalTags~="none"then mn=mn..ExtraVerticalTags end;local mt=r:getAxisCommandType(axisCommandId.vertical)if mt==axisCommandType.byThrottle then local mi=r:composeAxisAccelerationFromThrottle(mn,axisCommandId.vertical)if ad~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mn,mi,ma,'airfoil','ground','',mc)else a:setEngineForceCommand(mn,vec3(),ma)a:setEngineForceCommand('airfoil vertical',mi,ma,'airfoil','','',mc)a:setEngineForceCommand('ground vertical',mi,ma,'ground','','',mc)end elseif mt==axisCommandType.byTargetSpeed then if ad<0 then a:setEngineForceCommand('hover',vec3(),ma)end;local mu=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)mg=mg..' , '..mn;mh=mh+mu end;if mh:len()>constants.epsilon then if V~=0 or mq or c(lV:dot(bF))<0.8 then mg=mg..', brake'end;a:setEngineForceCommand(mg,mh,mb,'','','',mc)end end;local mv=torqueFactor*(l_-lZ)local mw=vec3(core.getWorldAirFrictionAngularAcceleration())mv=mv-mw;a:setEngineTorqueCommand('torque',mv,ma,'airfoil','','',mc)a:setBoosterCommand('rocket_engine')if a4 and not VanillaRockets then local eZ=vec3(core.getVelocity()):len()local mx=0.15;if not bR then local my=r:getTargetSpeed(axisCommandId.longitudinal)if eZ*3.6>my*(1-mx)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eZ*3.6<my*(1-mx)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jk=unit.getThrottle()if AtmoSpeedAssist then jk=F*100 end;local jr=jk/100;if j==0 then jr=jr*MaxGameVelocity;if eZ>=jr*(1-mx)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eZ<jr*(1-mx)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jx=d(bn)jr=jr*jx/3.6;if eZ>=jr*(1-mx)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eZ<jr*(1-mx)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local _,cn=coroutine.resume(beginSetup)if cn then SetupComplete=true end else a:update()if not be and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(mz)local A=1;local function mA(mB)if mB then A=-1 end;if not ExternalAGG and bP then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+A*a1;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+A*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bw=bw+A*a0;if bw<planet.noAtmosphericDensityAltitude then bw=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+A*a0 end else r:updateTargetGroundAltitudeFromActionStart(A*1.0)end end;local function mC(mB)if mB then A=-1 end;if not Y then if AtmoSpeedAssist and not AltIsOn then F=q(F+A*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,A*speedChangeLarge)end else if mB then A=1 else A=nil end;bc.adjustAutopilotTargetIndex(A)end end;if mz=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cd(0)if vBooster or hover then if ar and ao==-1 then StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bg=true;GearExtended=false elseif ar then BrakeIsOn=true;a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)else a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end;if P and not BrakeLanding then a.control.extendLandingGears()end else if P then a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif mz=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif mz=="forward"then Q=Q-1 elseif mz=="backward"then Q=Q+1 elseif mz=="left"then T=T-1 elseif mz=="right"then T=T+1 elseif mz=="yawright"then U=U-1 elseif mz=="yawleft"then U=U+1 elseif mz=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif mz=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif mz=="up"then ad=ad+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif mz=="down"then ad=ad-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif mz=="groundaltitudeup"then mA()elseif mz=="groundaltitudedown"then mA(true)elseif mz=="option1"then bc.adjustAutopilotTargetIndex()toggleView=false elseif mz=="option2"then bc.adjustAutopilotTargetIndex(1)toggleView=false elseif mz=="option3"then local function mD()aG=not aG;if not aG then unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;mD()toggleView=false elseif mz=="option4"then cF()toggleView=false elseif mz=="option5"then local function mE()if LockPitch==nil then LockPitch=bS;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else LockPitch=nil end end;mE()toggleView=false elseif mz=="option6"then cr()toggleView=false elseif mz=="option7"then toggleView=false elseif mz=="option8"then cs()toggleView=false elseif mz=="option9"then if gyro~=nil then gyro.toggle()ay=gyro.getState()==1 end;toggleView=false elseif mz=="lshift"then if w()==1 then Y=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then Y=true;bf=false;be=false end elseif mz=="brake"then if BrakeToggleStatus then cN()elseif not BrakeIsOn then cN()else BrakeIsOn=true end elseif mz=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif mz=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a4 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a4=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a4=false end elseif mz=="stopengines"then local function mF()if ap then ap=false;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;X=false;M=false;al=false;am=false;O=false;bg=autoRollPreference;VectorToTarget=false;TurnBurn=false;ay=false;LockPitch=nil;IntoOrbit=false else ap=true end end;r:resetCommand(axisCommandId.longitudinal)mF()F=0 elseif mz=="speedup"then mC()elseif mz=="speeddown"then mC(true)elseif mz=="antigravity"and not ExternalAGG then if antigrav~=nil then d1()end end end;function script.onActionStop(mz)local function mG()if not ExternalAGG and bP then a3=a1 end;if AltitudeHold or VertTakeOff or IntoOrbit then a2=a0 end end;if mz=="forward"then Q=0 elseif mz=="backward"then Q=0 elseif mz=="left"then T=0 elseif mz=="right"then T=0 elseif mz=="yawright"then U=0 elseif mz=="yawleft"then U=0 elseif mz=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif mz=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif mz=="up"then ad=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mz=="down"then ad=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mz=="groundaltitudeup"then mG()toggleView=false elseif mz=="groundaltitudedown"then mG()toggleView=false elseif mz=="lshift"then if w()==1 then Y=false;ae=0;af=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then Y=false;bf=false;be=false end elseif mz=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cN()else BrakeIsOn=false end end elseif mz=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(mz)local A=1;local function mH(mB)if mB then A=-1 end;if not ExternalAGG and bP then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+A*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a3=a3*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+A*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bw=bw+A*a2;if bw<planet.noAtmosphericDensityAltitude then bw=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+A*a2 end;a2=a2*1.05 else r:updateTargetGroundAltitudeFromActionLoop(A*1.0)end end;local function mI(mB)if mB then A=-1 end;if not Y then if AtmoSpeedAssist and not AltIsOn then F=q(F+A*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,A*speedChangeSmall)end end end;if mz=="groundaltitudeup"then mH()elseif mz=="groundaltitudedown"then mH(true)elseif mz=="speedup"then mI()elseif mz=="speeddown"then mI(true)end end;function script.onInputText(ca)local function mJ()for db,dc in pairs(c0())do dbHud_1.setStringValue(dc,g(nil))end;for db,dc in pairs(b)do if dc~="SavedLocations"then dbHud_1.setStringValue(dc,g(nil))end end;Z="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ag=5;aM=false;ac=true end;local function mK(mL,planet,f2)local function mM(f2)local y=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local ds='::pos{'..y..','..y..','..y..','..y..','..y..'}'local dF,dG,cB,cC,cA=n(f2,ds)if dF=="0"and dG=="0"then return vec3(tonumber(cB),tonumber(cC),tonumber(cA))end;cC=math.rad(cC)cB=math.rad(cB)local planet=b2[tonumber(dF)][tonumber(dG)]local et=math.cos(cB)local mN=vec3(et*math.cos(cC),et*math.sin(cC),math.sin(cB))return planet.center+(planet.radius+cA)*mN end;if dbHud_1 then local cL={}local position=mM(f2)if planet.name=="Space"then cL={position=position,name=mL,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cL={position=position,name=mL,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;SavedLocations[#SavedLocations+1]=cL;table.insert(b2[0],cL)bc.UpdateAtlasLocationsList()else Z="Databank must be installed to save locations"end end;local i;local mO="/commands /setname /G /agg /addlocation /copydatabank /wipedatabank"local mP,mQ=nil,nil;local mR="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all updatable variables with /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572} - adds a saved location by waypoint, not as accurate as making one at location\n".."/copydatabank - copies dbHud databank to a blank databank\n/wipedatabank - wipes the databank of all hud variables but not save variables"i=string.find(ca," ")mP=ca;if i~=nil then mP=string.sub(ca,0,i-1)mQ=string.sub(ca,i+1)end;if mP=="/help"or mP=="/commands"then for i9 in string.gmatch(mR,"([^\n]+)")do system.print(i9)end;return elseif mP=="/setname"then if mQ==nil or mQ==""then Z="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cI(mQ)else Z="Select a saved target to rename first"end elseif mP=="/addlocation"then if mQ==nil or mQ==""or string.find(mQ,"::")==nil then Z="Usage: ah-addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572}"return end;i=string.find(mQ,"::")local mL=string.sub(mQ,1,i-2)local f2=string.sub(mQ,i)local y=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local ds='::pos{'..y..','..y..','..y..','..y..','..y..'}'local dF,dG,cB,cC,cA=n(f2,ds)local planet=b2[tonumber(dF)][tonumber(dG)]mK(mL,planet,f2)Z="Added "..mL.." to saved locations,\nplanet "..planet.name.." at "..f2;ag=5 elseif mP=="/agg"then if mQ==nil or mQ==""then Z="Usage: ah-agg targetheight"return end;mQ=tonumber(mQ)if mQ<1000 then mQ=1000 end;AntigravTargetAltitude=mQ;Z="AGG Target Height set to "..mQ elseif mP=="/G"then if mQ==nil or mQ==""then Z="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if mQ=="dump"then for db,dc in pairs(c0())do if type(_G[dc])=="boolean"then if _G[dc]==true then system.print(dc.." true")else system.print(dc.." false")end elseif _G[dc]==nil then system.print(dc.." nil")else system.print(dc.." ".._G[dc])end end;return end;i=string.find(mQ," ")local mS=string.sub(mQ,0,i-1)local mT=string.sub(mQ,i+1)for db,dc in pairs(c0())do if dc==mS then Z="Variable "..mS.." changed to "..mT;local mU=type(_G[dc])if mU=="number"then mT=tonumber(mT)elseif mU=="boolean"then if string.lower(mT)=="true"then mT=true else mT=false end end;_G[dc]=mT;return end end;Z="No such global variable: "..mS elseif mP=="/copydatabank"then if dbHud_2 then d7(true)else Z="Spare Databank required to copy databank"end elseif mP=="/wipedatabank"then if dbHud_1 then mJ()else Z="No databank found."end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
