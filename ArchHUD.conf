name: ArchHud - Archaegeo v0.736 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.736;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=66000;W=1000;X=50;Y=0;Z=100000;_=13888.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=1750;av=350;aw=50;ax=250;ay=0;az=30;aA=100;aB={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},radarX={set=function(K)au=K end,get=function()return au end},radarY={set=function(K)av=K end,get=function()return av end},DeadZone={set=function(K)aw=K end,get=function()return aw end},OrbitMapSize={set=function(K)ax=K end,get=function()return ax end},OrbitMapX={set=function(K)ay=K end,get=function()return ay end},OrbitMapY={set=function(K)az=K end,get=function()return az end},soundVolume={set=function(K)aA=K end,get=function()return aA end}}aC=5.0;aD=1.0;aE=0.003;aF=0.003;aG=2;aH=1.5;aI=180;aJ=150;aK=0.002;aL=2;aM=0.8;aN=1;aO=3;aP=1;aQ=40;aR=0.0666667;aS=0.0;aT="none"aU="none"aV="none"aW={speedChangeLarge={set=function(K)aC=K end,get=function()return aC end},speedChangeSmall={set=function(K)aD=K end,get=function()return aD end},MouseXSensitivity={set=function(K)aE=K end,get=function()return aE end},MouseYSensitivity={set=function(K)aF=K end,get=function()return aF end},autoRollFactor={set=function(K)aG=K end,get=function()return aG end},rollSpeedFactor={set=function(K)aH=K end,get=function()return aH end},autoRollRollThreshold={set=function(K)aI=K end,get=function()return aI end},minRollVelocity={set=function(K)aJ=K end,get=function()return aJ end},TrajectoryAlignmentStrength={set=function(K)aK=K end,get=function()return aK end},torqueFactor={set=function(K)aL=K end,get=function()return aL end},pitchSpeedFactor={set=function(K)aM=K end,get=function()return aM end},yawSpeedFactor={set=function(K)aN=K end,get=function()return aN end},brakeSpeedFactor={set=function(K)aO=K end,get=function()return aO end},brakeFlatFactor={set=function(K)aP=K end,get=function()return aP end},DampingMultiplier={set=function(K)aQ=K end,get=function()return aQ end},hudTickRate={set=function(K)aR=K end,get=function()return aR end},ExtraEscapeThrust={set=function(K)aS=K end,get=function()return aS end},ExtraLongitudeTags={set=function(K)aT=K end,get=function()return aT end},ExtraLateralTags={set=function(K)aU=K end,get=function()return aU end},ExtraVerticalTags={set=function(K)aV=K end,get=function()return aV end}}aX=j;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=1000;b9=false;ba=false;bb=false;bc=false;bd=0;be="Aligning"bf=0;bg=1;bh="None"bi=nil;bj=0;bk=nil;bl=0.0;bm=0;bn={}bo=false;bp=0;bq=0;br=nil;bs=0;bt=1000;bu=0;bv=false;bw=0;bx=false;by="All"bz=true;bA="Off"bB=0.000;bC={}bD={}bE={VertTakeOff={set=function(K)b7=K end,get=function()return b7 end},VertTakeOffEngine={set=function(K)aY=K end,get=function()return aY end},SpaceTarget={set=function(K)bv=K end,get=function()return bv end},BrakeToggleStatus={set=function(K)aX=K end,get=function()return aX end},BrakeIsOn={set=function(K)aZ=K end,get=function()return aZ end},RetrogradeIsOn={set=function(K)a_=K end,get=function()return a_ end},ProgradeIsOn={set=function(K)b0=K end,get=function()return b0 end},Autopilot={set=function(K)b1=K end,get=function()return b1 end},TurnBurn={set=function(K)b2=K end,get=function()return b2 end},AltitudeHold={set=function(K)b3=K end,get=function()return b3 end},BrakeLanding={set=function(K)b4=K end,get=function()return b4 end},Reentry={set=function(K)b6=K end,get=function()return b6 end},AutoTakeoff={set=function(K)b5=K end,get=function()return b5 end},HoldAltitude={set=function(K)b8=K end,get=function()return b8 end},AutopilotAccelerating={set=function(K)b9=K end,get=function()return b9 end},AutopilotBraking={set=function(K)bb=K end,get=function()return bb end},AutopilotCruising={set=function(K)bc=K end,get=function()return bc end},AutopilotRealigned={set=function(K)ba=K end,get=function()return ba end},AutopilotEndSpeed={set=function(K)bd=K end,get=function()return bd end},AutopilotStatus={set=function(K)be=K end,get=function()return be end},AutopilotPlanetGravity={set=function(K)bf=K end,get=function()return bf end},PrevViewLock={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetName={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetCoords={set=function(K)bi=K end,get=function()return bi end},AutopilotTargetIndex={set=function(K)bj=K end,get=function()return bj end},TotalDistanceTravelled={set=function(K)bl=K end,get=function()return bl end},TotalFlightTime={set=function(K)bm=K end,get=function()return bm end},SavedLocations={set=function(K)bn=K end,get=function()return bn end},VectorToTarget={set=function(K)bo=K end,get=function()return bo end},LocationIndex={set=function(K)bp=K end,get=function()return bp end},LastMaxBrake={set=function(K)bq=K end,get=function()return bq end},LockPitch={set=function(K)br=K end,get=function()return br end},LastMaxBrakeInAtmo={set=function(K)bs=K end,get=function()return bs end},AntigravTargetAltitude={set=function(K)bt=K end,get=function()return bt end},LastStartTime={set=function(K)bu=K end,get=function()return bu end},iphCondition={set=function(K)by=K end,get=function()return by end},stablized={set=function(K)bz=K end,get=function()return bz end},UseExtra={set=function(K)bA=K end,get=function()return bA end},SelectedTab={set=function(K)bF=K end,get=function()return bF end},saveRoute={set=function(K)bC=K end,get=function()return bC end},apRoute={set=function(K)bD=K end,get=function()return bD end}}local function bG(a,b,c,bH,bI,bJ)bK=bH()bL=0;bM=0;bN=false;bO=0;bP=false;bQ=false;bR=0;bS=0;bT=0;bU=0;bV=false;bW=false;bX="empty"bY=3;bZ=false;b_=0;c0=0;c1=nil;c2=0;c3=0;c4=0;c5=false;c6=false;c7=false;c8=-1;c9=bJ()>0;ca=bJ()cb=b.getAltitude()cc=b.getConstructMass()cd=nil;ce=a9;cf=aa;cg={}ch={}ci={}cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=false;ct=false;cu=p;cv=false;cw=U;cx=nil;cy=0;cz=false;cA=false;cB=false;cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getVelocity())cF=vec3(b.getWorldVelocity())cG=vec3(cF):len()cH=vec3(b.getWorldVertical())cI=-cH:dot(cF)cJ=vec3(b.getConstructWorldPos())cK=false;cL=false;cM=true;cN=0;cO=0;cP={}cQ=false;cR=50000;cS=nil;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;cU=false;cV=nil;cW=false;cX=0;cY=nil;cZ=nil;c_={}d0=90;d1=w;d2=nil;d3=nil;d4={}d5={}d6=false;d7=nil;d8=0;d9=false;da=b.getMaxSpeed()if shield then db=bI(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dc(dd)a.print(bK..": "..dd)end;local function de(d,b,c,a,df,dg,dh,di,dj)local function dk(dl)return type(dl)=='number'end;local function dm(dl)return type(dh(dl))=='number'end;local function dn(dp)return type(dp)=='table'end;local function dq(a)return type(a)=='string'end;local function dr(ds)return dn(ds)and dk(ds.x and ds.y and ds.z)end;local function dt(du)return dn(du)and dk(du.latitude and du.longitude and du.altitude and du.id and du.systemId)end;local dv=math.pi/180;local dw=180/math.pi;local dx=1e-10;local dy=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dz='::pos{'..dy..','..dy..','..dy..','..dy..','..dy..'}'local utils=utils;local vec3=vec3;local function dA(dl)local dB=string.gsub(string.reverse(df('%.4f',dl)),'^0*%.?','')return dB==''and'0'or string.reverse(dB)end;local function dC(dD)if dr(dD)then return df('{x=%.3f,y=%.3f,z=%.3f}',dD.x,dD.y,dD.z)end;if dn(dD)and not getmetatable(dD)then local dE={}local dF=next(dD)if type(dF)=='nil'or dF==1 then dE=dD else for dG,ds in pairs(dD)do local dH=dC(ds)if type(dG)=='number'then table.insert(dE,df('[%s]=%s',dG,dH))else table.insert(dE,df('%s=%s',dG,dH))end end end;return df('{%s}',table.concat(dE,','))end;if dq(dD)then return df("'%s'",dD:gsub("'",[[\']]))end;return tostring(dD)end;local dI={}dI.__index=dI;dI.__tostring=function(dD,dJ)local dK={}for dG in pairs(dD)do table.insert(dK,dG)end;table.sort(dK)local dE={}for dL,dG in ipairs(dK)do local dH=dC(dD[dG])if type(dG)=='number'then table.insert(dE,df('[%s]=%s',dG,dH))else table.insert(dE,df('%s=%s',dG,dH))end end;if dJ then return df('%s%s',dJ,table.concat(dE,',\n'..dJ))end;return df('{%s}',table.concat(dE,','))end;dI.__eq=function(dM,dN)return dM.systemId==dN.systemId and dM.id==dN.id and dj(dM.radius,dN.radius)and dj(dM.center.x,dN.center.x)and dj(dM.center.y,dN.center.y)and dj(dM.center.z,dN.center.z)and dj(dM.GM,dN.GM)end;local function dO(dP,dQ,dR,dS,dT)assert(dm(dP),'Argument 1 (systemId) must be a number:'..type(dP))assert(dm(dQ),'Argument 2 (id) must be a number:'..type(dQ))assert(dm(dR),'Argument 3 (radius) must be a number:'..type(dR))assert(dn(dS),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dS))assert(dm(dT),'Argument 5 (GM) must be a number:'..type(dT))return setmetatable({systemId=dh(dP),id=dh(dQ),radius=dh(dR),center=vec3(dS),GM=dh(dT)},dI)end;local dU={}dU.__index=dU;dU.__tostring=function(dc)return df('::pos{%d,%d,%s,%s,%s}',dc.systemId,dc.id,dA(dc.latitude*dw),dA(dc.longitude*dw),dA(dc.altitude))end;dU.__eq=function(dM,dN)return dM.id==dN.id and dM.systemId==dN.systemId and dj(dM.latitude,dN.latitude)and dj(dM.altitude,dN.altitude)and(dj(dM.longitude,dN.longitude)or dj(dM.latitude,math.pi/2)or dj(dM.latitude,-math.pi/2))end;local function dV(dW,dQ,dX,dY,dZ)local dP=dW;if dq(dW)and not dY and not dZ and not dQ and not dX then dP,dQ,dX,dY,dZ=d_(dW,dz)assert(dP,'Argument 1 (position string) is malformed.')else assert(dm(dP),'Argument 1 (systemId) must be a number:'..type(dP))assert(dm(dQ),'Argument 2 (id) must be a number:'..type(dQ))assert(dm(dX),'Argument 3 (latitude) must be in degrees:'..type(dX))assert(dm(dY),'Argument 4 (longitude) must be in degrees:'..type(dY))assert(dm(dZ),'Argument 5 (altitude) must be in meters:'..type(dZ))end;dP=dh(dP)dQ=dh(dQ)dX=dh(dX)dY=dh(dY)dZ=dh(dZ)if dQ==0 then return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=dQ,systemId=dP},dU)end;return setmetatable({latitude=dv*dg(dX,-90,90),longitude=dv*(dY%360),altitude=dZ,id=dQ,systemId=dP},dU)end;local e0={}e0.__index=e0;e0.__tostring=function(dD,dJ)local e1=dJ and dJ..'  'local e2={}local dK={}for dG in pairs(dD)do table.insert(dK,dG)end;table.sort(dK)for dL,e3 in ipairs(dK)do e4=dD[e3]local e5=dI.__tostring(e4,e1)if dJ then table.insert(e2,df('[%s]={\n%s\n%s}',e3,e5,dJ))else table.insert(e2,df('  [%s]=%s',e3,e5))end end;if dJ then return df('\n%s%s%s',dJ,table.concat(e2,',\n'..dJ),dJ)end;return df('{\n%s\n}',table.concat(e2,',\n'))end;local function e6(e7)local e={}local pid;for dL,ds in pairs(e7)do local dQ=ds.planetarySystemId;if type(dQ)~='number'then error('Invalid planetary s ID: '..tostring(dQ))elseif pid and dQ~=pid then error('Mistringmatch planetary s IDs: '..dQ..' and '..pid)end;local e8=ds.bodyId;if type(e8)~='number'then error('Invalid body ID: '..tostring(e8))elseif e[e8]then error('Duplicate body ID: '..tostring(e8))end;setmetatable(ds.center,getmetatable(vec3.unit_x))e[e8]=setmetatable(ds,dI)pid=dQ end;return setmetatable(e,e0)end;e9={}local function ea(e7)return setmetatable({galaxyAtlas=e7 or{}},e9)end;e9.__index=function(dp,K)if type(K)=='number'then local a=dp.galaxyAtlas[K]return e6(a)end;return rawget(e9,K)end;e9.__pairs=function(dD)return function(dp,dG)local eb,ec=next(dp,dG)return eb,ec and e6(ec)end,dD.galaxyAtlas,nil end;e9.__tostring=function(dD)local ed={}for dL,ee in pairs(dD or{})do local ef=ee:getPlanetarySystemId()local eg=e0.__tostring(ee,'    ')table.insert(ed,df('  [%s]={%s\n  }',ef,eg))end;return df('{\n%s\n}\n',table.concat(ed,',\n'))end;e9.BodyParameters=dO;e9.MapPosition=dV;e9.PlanetarySystem=e6;function e9.createBodyParameters(dP,dQ,eh,ei,ej,ek,el)assert(dm(dP),'Argument 1 (systemId) must be a number:'..type(dP))assert(dm(dQ),'Argument 2 (id) must be a number:'..type(dQ))assert(dm(eh),'Argument 3 (surfaceArea) must be a number:'..type(eh))assert(dn(ei),'Argument 4 (aPosition) must be an array or vec3:'..type(ei))assert(dn(ej),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ej))assert(dm(ek),'Argument 6 (altitude) must be in meters:'..type(ek))assert(dm(el),'Argument 7 (gravityAtPosition) must be number:'..type(el))local dR=di(eh/4/math.pi)local c4=dR+ek;local em=vec3(ei)+c4*vec3(ej)local dT=el*c4*c4;return dO(dP,dQ,dR,em,dT)end;e9.isMapPosition=dt;function e9:getPlanetarySystem(dW)if K==nil then K=0 end;if ec==nil then ec=0 end;local dP=dW;if dt(dW)then dP=dW.systemId end;if type(dP)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(ec)~=e0 then a=e6(a)end;return a end end end;function e0:sizeCalculator(en)return 1.05*en.radius end;function e0:castIntersections(eo,ep,eq,er,es,et)local eu={}if es then for dL,en in pairs(es)do table.insert(eu,en)end else eu=c_ end;if not et then table.sort(eu,function(ev,ew)local ex=ev.center;local ey=ew.center;return(ex.x-eo.x)^2+(ex.y-eo.y)^2+(ex.z-eo.z)^2<(ey.x-eo.x)^2+(ey.y-eo.y)^2+(ey.z-eo.z)^2 end)end;local ez=ep:normalize()for dL,en in ipairs(eu)do local eA=en.center-eo;local dR=self:sizeCalculator(en)local eB=eA:dot(ez)local eC=eB^2-(eA:len2()-dR^2)if eC>=0 then local eD=di(eC)local eE=eB+eD;local eF=eB-eD;if eF>0 then return en,eE,eF elseif eE>0 then return en,eE,nil end end end;return nil,nil,nil end;function e0:closestBody(eG)assert(type(eG)=='table','Invalid coordinates.')local eH,en;local eI=vec3(eG)for dL,eJ in pairs(self)do local eK=(eJ.center-eI):len2()if(not en or eK<eH)and eJ.name~="Space"then en=eJ;eH=eK end end;return en end;function e0:convertToBodyIdAndWorldCoordinates(dW)local eL=dW;if dq(dW)then eL=dV(dW)end;if eL.id==0 then return 0,vec3(eL.latitude,eL.longitude,eL.altitude)end;local eJ=self:getBodyParameters(eL)if eJ then return eL.id,eJ:convertToWorldCoordinates(eL)end end;function e0:getBodyParameters(dW)local dQ=dW;if dt(dW)then dQ=dW.id end;assert(dm(dQ),'Argument 1 (id) must be a number:'..type(dQ))return self[dQ]end;function e0:getPlanetarySystemId()local dL,ds=next(self)return ds and ds.systemId end;function dI:convertToMapPosition(dS)assert(dn(dS),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dS))local eM=vec3(dS)if self.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=self.systemId},dU)end;local eN=eM-self.center;local c4=eN:len()local dZ=c4-self.radius;local dX=0;local dY=0;if not dj(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=self.id,systemId=self.systemId},dU)end;function dI:convertToWorldCoordinates(dW)local eL=dq(dW)and dV(dW)or dW;if eL.id==0 then return vec3(eL.latitude,eL.longitude,eL.altitude)end;assert(dt(eL),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eL.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eL.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eQ=math.cos(eL.latitude)return self.center+(self.radius+eL.altitude)*vec3(eQ*math.cos(eL.longitude),eQ*math.sin(eL.longitude),math.sin(eL.latitude))end;function dI:getAltitude(dS)return(vec3(dS)-self.center):len()-self.radius end;function dI:getDistance(dS)return(vec3(dS)-self.center):len()end;function dI:getGravity(dS)local eR=self.center-vec3(dS)local eS=eR:len2()return self.GM/eS*eR/di(eS)end;return setmetatable(e9,{__call=function(dL,...)return ea(...)end})end;local function eT(d,b,c,a,di,eU)local ck={}local eV=100000000/3600;local eW=eV*eV;local eX=100;function ck.computeAccelerationTime(eY,eZ,e_)local f0=eV*math.asin(eY/eV)return(eV*math.asin(e_/eV)-f0)/eZ end;function ck.computeDistanceAndTime(eY,e_,f1,f2,f3,f4)f3=f3 or 0;f4=f4 or 0;local f5=eY<=e_;local f6=f2*(f5 and 1 or-1)/f1;local f7=-f4/f1;local f8=f6+f7;if f5 and f8<=0 or not f5 and f8>=0 then return-1,-1 end;local f9,fa=0,0;if f6~=0 and f3>0 then local f0=math.asin(eY/eV)local fb=math.pi*(f6/2+f7)local fc=f6*f3;local fd=eV*math.pi;local ds=function(dp)local fe=(fb*dp-fc*math.sin(math.pi*dp/2/f3)+fd*f0)/fd;local ff=math.tan(fe)return eV*ff/di(ff*ff+1)end;local fg=f5 and function(a)return a>=e_ end or function(a)return a<=e_ end;fa=2*f3;if fg(ds(fa))then local fh=0;while eU(fa-fh)>0.5 do local dp=(fa+fh)/2;if fg(ds(dp))then fa=dp else fh=dp end end end;local fi=eY;local fj=fa/eX;for fk=1,eX do local fl=ds(fk*fj)f9=f9+(fl+fi)*fj/2;fi=fl end;if fa<2*f3 then return f9,fa end;eY=fi end;local f0=eV*math.asin(eY/eV)local bK=(eV*math.asin(e_/eV)-f0)/f8;local fm=eW*math.cos(f0/eV)/f8;local c4=fm-eW*math.cos((f8*bK+f0)/eV)/f8;return c4+f9,bK+fa end;function ck.computeTravelTime(eY,eZ,c4)if c4==0 then return 0 end;if eZ>0 then local f0=eV*math.asin(eY/eV)local fm=eW*math.cos(f0/eV)/eZ;return(eV*math.acos(eZ*(fm-c4)/eW)-f0)/eZ end;if eY==0 then return-1 end;assert(eY>0,'Acceleration and initial speed are both zero.')return c4/eY end;return ck end;local function fn(d,b,c,a,df,dg,dh,di,dj)local vec3=vec3;local de=de(d,b,c,a,df,dg,dh,di,dj)local function dq(a)return type(a)=='string'end;local function dn(dp)return type(dp)=='table'end;fo={}fo.__index=fo;function fo:escapeAndOrbitalSpeed(dZ)assert(self.body)local c4=dZ+self.body.radius;if not dj(c4,0)then local fp=di(self.body.GM/c4)return di(2)*fp,fp end;return nil,nil end;function fo:orbitalParameters(dW,fq)assert(self.body)assert(dn(dW)or dq(dW))assert(dn(fq))local fr=(dq(dW)or de.isMapPosition(dW))and self.body:convertToWorldCoordinates(dW)or vec3(dW)local ds=vec3(fq)local fs=fr-self.body.center;local ft=ds:len2()local fu=fs:len()local fv=self.body.GM;local fw=((ft-fv/fu)*fs-fs:dot(ds)*ds)/fv;local ex=fv/(2*fv/fu-ft)local fx=fw:len()local ez=fw:normalize()local fy=ex*(1-fx)local fz=ex*(1+fx)local fA=fy*ez+self.body.center;local fB=fx<=1 and-fz*ez+self.body.center or nil;local fC=di(ex*fv*(1-fx*fx))local fD=fB and 2*math.pi*di(ex^3/fv)local fE=math.acos(fw:dot(fs)/(fx*fu))if fs:dot(ds)<0 then fE=-(fE-2*math.pi)end;local fF=math.acos((math.cos(fE)+fx)/(1+fx*math.cos(fE)))local fG=fF;if fG<0 then fG=fG+2*math.pi end;local fH=fG-fx*math.sin(fG)local fI=0;local fJ=0;local fK=0;if fD~=nil then fI=fH/(2*math.pi/fD)fJ=fD-fI;fK=fJ+fD/2;if fE-math.pi>0 then fJ=fI;fK=fJ+fD/2 end;if fK>fD then fK=fK-fD end end;return{periapsis={position=fA,speed=fC/fy,circularOrbitSpeed=di(fv/fy),altitude=fy-self.body.radius},apoapsis=fB and{position=fB,speed=fC/fz,circularOrbitSpeed=di(fv/fz),altitude=fz-self.body.radius},currentVelocity=ds,currentPosition=fr,eccentricity=fx,period=fD,eccentricAnomaly=fF,meanAnomaly=fH,timeToPeriapsis=fJ,timeToApoapsis=fK,trueAnomaly=fE}end;local function fL(fM)local eJ=de.BodyParameters(fM.systemId,fM.id,fM.radius,fM.center,fM.GM)return setmetatable({body=eJ},fo)end;return setmetatable(fo,{__call=function(dL,...)return fL(...)end})end;local function fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dh,di,fQ,fR)local function fS(fT)local dc=fU:closestBody(fT)if(fT-dc.center):len()>dc.radius+dc.noAtmosphericDensityAltitude then dc=e[0][0]end;return dc end;local function fV()local function fW(fX,fY)return fX.name<fY.name end;cP={}for dG,ds in pairs(e[0])do cP[#cP+1]={name=ds.name,index=dG}end;table.sort(cP,fW)end;local function fZ(f_,g0)if not g0 then g0=g1.name end;for dG,ds in pairs(f_)do if ds.name and ds.name==g0 then return dG end end;return-1 end;local function g2()cX=bj;if bj==0 then bh="None"c1=nil;g1=nil;return true end;local g3=cP[bj].index;local g4=e[0][g3]if g4.center then bh=g4.name;c1=cj[0][g3]if g1~=nil then if ca==0 then if fO(g5,g6)~=1 then fP(g5,g6)end;if fO(g7,g8)~=1 then fP(g7,g8)end;if fO(g9,ga)~=1 then fP(g9,ga)end;if fO(gb,gc)~=1 then fP(gb,gc)end;if fO(gd,ge)~=1 then fP(gd,ge)end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end;if fO(gj,gk)~=1 then fP(gj,gk)end end;g1=nil else g1=g4;for dL,ds in pairs(cj[0])do if ds.name==g1.planetname then c1=ds;bh=g1.name;break end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end end;if g1==nil then bi=vec3(c1.center)else bi=g1.position end;if c1.planetname~="Space"then if c1.hasAtmosphere then gl=bI(c1.radius*(S-1)+c1.noAtmosphericDensityAltitude)else gl=bI(c1.radius*(S-1)+c1.surfaceMaxAltitude)end else gl=R end;if g1~=nil and g1.planetname=="Space"then bd=0 else dL,bd=cl(c1):escapeAndOrbitalSpeed(gl)end;bf=0;b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"return true end;local function gm(gn)if not b1 and not bo and not c6 and not bx and not b6 and not c7 then if gn==nil then bj=bj+1;if bj>#cP then bj=0 end else bj=bj-1;if bj<0 then bj=#cP end end;if bj==0 then g2()else local g3=cP[bj].index;local g4=e[0][g3]if g4 and(g4~=nil and g4.name=="Space"or by=="Custom Only"and g4.center or by=="No Moons"and string.find(g4.name,"Moon")~=nil)then if gn==nil then gm()else gm(1)end else g2()end end else bX="Disengage autopilot before changing Interplanetary Helper"fQ("iph","AP")end end;local function go()local function gp(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=-1;gs=fZ(e[0])if gs>-1 then table.remove(e[0],gs)end;gs=-1;gs=fZ(gr)if gs~=-1 then bX=g1.name.." saved location cleared"table.remove(gr,gs)end;gm()fV()return gr end;if string.sub(bh,1,1)=="*"then d4=gp(true)else bn=gp(false)end end;local function gt(gu,fT,gv,gw)local function gx(gq)if gq then gr=d4 else gr=bn end;if dbHud_1 or gv or gq then local dc=fS(fT)local gy={position=fT,name=gu,planetname=dc.name,gravity=b.g(),safe=gw}if not gv then gr[#gr+1]=gy else for dG,ds in pairs(e[0])do if ds.name and gu==ds.name then table.remove(e[0],dG)end end end;table.insert(e[0],gy)fV()g2()bX="Location saved as "..gu.."("..dc.name..")"return gr else bX="Databank must be installed to save permanent locations"end end;if string.sub(gu,1,1)=="*"then d4=gx(true)else bn=gx(false)end end;local gz={}function gz.UpdateAtlasLocationsList()fV()end;function gz.UpdateAutopilotTarget()g2()end;function gz.adjustAutopilotTargetIndex(gn)gm(gn)end;function gz.findAtlasIndex(f_,g0)return fZ(f_,g0)end;function gz.UpdatePosition(gA,gB,gC)local function gD(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=fZ(gr)if gs~=-1 then if gA~=nil then if gq then gA="*"..gA end;gr[gs].name=gA;bj=bj-1;gm()elseif gC~=nil then if gC then local gE=cb;if gE<1000 then gE=1000 end;gr[gs].agg=fR(gE,0)bX=gr[gs].name.." AGG Altitude:"..gr[gs].agg.." saved ("..gr[gs].planetname..")"return elseif gC==false then gr[gs].agg=nil;bX=gr[gs].name.." AGG Altitude cleared ("..gr[gs].planetname..")"return end else local gF=gr[gs]if gB then gF.heading=cD:cross(cH)*5000;bX=gr[gs].name.." heading saved ("..gr[gs].planetname..")"return elseif gB==false then gF.heading=nil;bX=gr[gs].name.." heading cleared ("..gr[gs].planetname..")"return end;gF.gravity=b.g()gF.position=cJ;gF.safe=true end;bX=gr[gs].name.." position updated ("..gr[gs].planetname..")"else bX="Name Not Found"end end;if string.sub(bh,1,1)=="*"then gD(true)else gD(false)end end;function gz.AddNewLocation(gu,fT,gv,gw)gt(gu,fT,gv,gw)end;function gz.ClearCurrentPosition()go()end;for dG,ds in pairs(d5)do table.insert(e[0],ds)end;if gG then for dG,ds in pairs(gG)do gz[dG]=ds end end;fV()if bj>#cP then bj=0 end;gz.UpdateAutopilotTarget()return gz end;local function gH(b,a,c,library,radar_1,radar_2,eU,gI,di,gJ,dh,gK,fQ)local gL={}local gM={}local gN={XS=13,S=27,M=55,L=110,XL=221}local gO={}local gP=0;local gQ;local gR;local gS;local gT;local gU={}local gV="Atmo"local gW;local gX;local gY=0;local gZ={}local function g_()local function h0(h1,h2,h3,h4,h5,h6,h7,h8)h2,h4,h6,h8=vec3(h2),vec3(h4),vec3(h6),vec3(h8)local h9,ha,hb=h1*h1,h3*h3,h5*h5;local ft=h4-h2;local hc=ft:normalize()local hd=ft:len()local he=h6-h2;local hf=(he-he:project_on(hc)):normalize()local hg,hh=he:dot(hc),he:dot(hf)local hi=hg*hg+hh*hh;local hj=hc:cross(hf)local hk=(h9-ha+hd*hd)/(2*hd)local hl=(h9-hb+hi-2*hg*hk)/(2*hh)local du=h9-hk^2-hl^2;local hm=di(du)local hn=h2+hc*hk+hf*hl+hj*hm;local ho=h2+hc*hk+hf*hl-hj*hm;if eU((h8-hn):len()-h7)<eU((h8-ho):len()-h7)then return hn else return ho end end;local function hp(hq,fu,hr)local hs=hq.pts;local gs=#hs;local ht=hq.ref;if gs>3 then local hu,hv,hw,hx=hs[gs],hs[gs-1],hs[gs-2],hs[gs-3]hq.ref=hr;local fr=h0(hu[1],hu[2],hv[1],hv[2],hw[1],hw[2],hx[1],hx[2])local hk,hl,hm=fr.x,fr.y,fr.z;if hk==hk and hl==hl and hm==hm then hk=hk+ht[1]hl=hl+ht[2]hm=hm+ht[3]local hy=vec3(hk,hl,hm)hq.center=hy;if hq.lastPos then if(hq.lastPos-hy):len()<2 then local hz=(hy-vec3(hr)):len()if eU(hz-fu)<10 then hq.skipCalc=true end end end;hq.lastPos=hy end;hq.pts={}else local hA={hr[1]-ht[1],hr[2]-ht[2],hr[3]-ht[3]}hs[gs+1]={fu,hA}end end;if radar_1 or radar_2 then cp.assignRadar()end;if gU[1]then gP=#gU[1].getConstructIds()local hB=gU[1].getData()local hC=hB:gmatch('{"constructId[^}]*}[^}]*}')if gP>0 then local hr={cJ["x"],cJ["y"],cJ["z"]}local hD,hE=0,0;local hF=cG*10;gT,gS=0,0;for ds in hC do local dQ,c4,hG=ds:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hH=gN[hG]c4=dh(c4)if gU[1].hasMatchingTransponder(dQ)==1 then table.insert(gM,dQ)end;if E then local hI=gU[1].getConstructType(dQ)if F and gU[1].isConstructAbandoned(dQ)==1 or c4<hF and(hH>27 or hI=="static"or hI=="space")then gT=gT+1;local gu=gU[1].getConstructName(dQ)local hq=gZ[dQ]if hq==nil then hH=hH+gK;gZ[dQ]={pts={},ref=hr,name=gu,i=0,radius=hH,skipCalc=false}hq=gZ[dQ]end;if not hq.skipCalc then hp(hq,c4,hr)if F and not hq.abandoned and gU[1].isConstructAbandoned(dQ)==1 and hq.center then fQ("abRdr","RD")a.print("Abandoned Construct: "..gu.." ("..hI..") rough ::pos{0,0,"..hq.center.x..","..hq.center.y..","..hq.center.z.."}")bX="Abandoned Radar Contact ("..hI..") detected"hq.abandoned=true end;hE=hE+1 else table.insert(gO,hq)end end;hD=hD+1;if cT and hD>700 or hE>70 or(not cT and hD>300 or hE>30)then coroutine.yield()hD,hE=0,0 end end end;gS=#gO;if gS>0 and(cG>20 or b4)then local en,hJ,hK,hL;local hM=0;local hN=cj:getPlanetarySystem(0)hL=cF:normalize()while hM<gS do coroutine.yield()local hO={table.unpack(gO,hM,math.min(hM+75,gS))}en,hJ,hK=hN:castIntersections(cJ,hL,nil,nil,hO,true)if en and hK then cV={en,hJ,hK}break end;hM=hM+75 end;if not en then cV=nil end else cV=nil end;gO={}gQ=hB:find('identifiedConstructs":%[%]')else gR=hB:find('worksInEnvironment":false')end end end;local function hP()if gU[1]then gV="Atmo"if gU[1].getData():find('worksInAtmosphere":false')then gV="Space"end end end;function gL.pickType()hP()end;function gL.assignRadar()if radar_1 and gU[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gU[1]=radar_2 end;if gU[1]==radar_2 then hP()end elseif radar_2 and gU[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gU[1]=radar_1 end;if gU[1]==radar_1 then hP()end end end;function gL.UpdateRadar()local hQ=coroutine.status(gW)if hQ=="suspended"then local dH,hR=coroutine.resume(gW)if hR then a.print("ERROR UPDATE RADAR: "..hR)end elseif hQ=="dead"then gW=coroutine.create(g_)local dH,hR=coroutine.resume(gW)end end;function gL.GetRadarHud(hS,hT,au,av)local hU=gM;local hV,dd;gM={}local dy=gS or 0;if gP>0 then if E then dd=dy.."/"..gT.." Plotted : "..gP-gT.." Ignored"else dd="Radar Contacts: "..gP end;hV=gJ(au,av,dd,"pbright txtbig txtmid")if#gM>0 then hV=hV..gJ(hS,hT,"Friendlies In Range","pbright txtbig txtmid")for dG,ds in pairs(gM)do hT=hT+20;hV=hV..gJ(hS,hT,gU[1].getConstructName(ds),"pdim txtmid")end end;if gQ==nil and gX==nil then gY=1;cp.ToggleRadarPanel()end;if gQ~=nil and gX~=nil then cp.ToggleRadarPanel()end;if d3==nil then cp.ToggleRadarPanel()end else if gR then hV=gJ(au,av,gV.." Radar: Jammed","pbright txtbig txtmid")else hV=gJ(au,av,"Radar: No "..gV.." Contacts","pbright txtbig txtmid")end;if d3~=nil then gY=0;cp.ToggleRadarPanel()end end;return hV end;function gL.GetClosestName(gu)if gU[1]then local dQ,dL=gU[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dQ~=nil and dQ~=""then gu=gu.." "..gU[1].getConstructName(dQ)end end;return gu end;function gL.ToggleRadarPanel()if d3~=nil and gY==0 then gI(d3)d3=nil;if gX~=nil then gI(gX)gX=nil end else if gY==1 then gI(d3)d3=nil;_autoconf.displayCategoryPanel(gU,1,"Periscope","periscope")gX=_autoconf.panels[_autoconf.panels_size]end;if d3==nil then _autoconf.displayCategoryPanel(gU,1,"Radar","radar")d3=_autoconf.panels[_autoconf.panels_size]end;gY=0 end end;function gL.ContactTick()if not hW then hW=0 end;if bK>hW+10 then bX="Radar Contact"fQ("rdrCon","RC")hW=bK end;c.stopTimer("contact")end;function gL.onEnter(dQ)if radar_1 and not c9 and not cQ then c.setTimer("contact",0.1)end end;function gL.onLeave(dQ)if radar_1 and E then if#gZ>650 then dQ=tostring(dQ)gZ[dQ]=nil end end end;gU[1]=nil;if radar_1 then gU[1]=radar_1;hP()end;gW=coroutine.create(g_)if hX then for dG,ds in pairs(hX)do gL[dG]=ds end end;return gL end;local function hY(shield,d_,bI)local hZ={}local h_=shield.getResistancesCooldown()local function i0()local i1=shield.getState()if G then if not cQ and i1==0 then shield.toggle()elseif cQ and i1==1 then shield.toggle()end end end;local function i2()local i3=shield.getStressRatioRaw()local i4=0.5999;if i3[1]==0.0 and i3[2]==0.0 and i3[3]==0.0 and i3[4]==0.0 then return end;local i5=shield.setResistances(i4*i3[1],i4*i3[2],i4*i3[3],i4*i3[4])if i5==1 then bX="Shield Resistances updated"else bX="Value Exceeded. Failed to update Shield Resistances"end end;function hZ.shieldTick()db=bI(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())i0()h_=shield.getResistancesCooldown()if h_==0 and db<a7 then i2()end end;function hZ.setResist(i6)if not shield then bX="No shield found"return elseif i6==nil or h_>0 then bX="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dy=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dz=dy..', '..dy..', '..dy..', '..dy;local i7,i8,i9,ia=d_(i6,dz)if ia==nil or i7+i8+i9+ia>0.6 then bX="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(i7,i8,i9,ia)==1 then bX="Shield Resistances set"else bX="Resistance setting failed."end end;function hZ.ventShield()local ib=shield.getVentingCooldown()if ib>0 then bX="Cannot vent again for "..ib.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()bX="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bX="Shields already at max hitpoints"end end;if ic then for dG,ds in pairs(ic)do hZ[dG]=ds end end;return hZ end;local function id(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield,warpdrive,ie,eU,bI,df,ig,bJ,ih,ii,eP,bH,dg,ij,fP,fO,gI,ik,di,fR,gJ,fQ,il,im,io,ip,iq,ir)local is=9.80665;local it={}local iu={}local iv={}local iw={}local ix=nil;local iy=nil;local iz=nil;local iA=false;local iB="none"local iC=""local iD=55;local iE=0;local iF=0;local iG=nil;local iH=ac;local iI=ad;local iJ=ae;local iK=[[rgb(]]..bI(iH+0.5)..","..bI(iI+0.5)..","..bI(iJ+0.5)..[[)]]local iL=[[rgb(]]..bI(iH*0.9+0.5)..","..bI(iI*0.9+0.5)..","..bI(iJ*0.9+0.5)..[[)]]local iM=0;local iN=0;local iO=""local iP=bH()local iQ=false;local iR=false;local function iS(ds)if ce==1920 then return ds else return fR(ce*ds/1920,0)end end;local function iT(ds)if cf==1080 then return ds else return fR(cf*ds/1080,0)end end;local function iU()return ik()==0 and g~="keyboard"and ii()==0 end;local function iV()local iW="TRAVEL"if not cM then iW="CRUISE"end;if b1 then iW="AUTOPILOT"end;return iW end;local hV=""local iX=""local iY=""local iZ=1;local i_=2;local j0=3;local j1=4;local j2=5;local j3=6;local j4=7;local j5=""local j6=0;local j7=120.0*aR;local j8={}local j9={}local ja={}local jb={}local jc={}local jd={}local je={}je["atmofueltank"],je["spacefueltank"],je["rocketfueltank"]=0,0,0;local jf=0;local function jg(hk,jh,ji,jj,jk,jl)local jm=jf;local jn=jf+5;if not B then jn=jn+5 end;if ii()==1 and not l then jm=jm-50;jn=jn-50 end;if ji=="ATMO"then j5="atmofueltank"elseif ji=="SPACE"then j5="spacefueltank"else j5="rocketfueltank"end;j6=_G[j5 .."_size"]if#jj>0 then for K=1,#jj do local gu=jj[K][i_]local jo=jj[K][j4]for jp=1,j6 do if jj[K][i_]==ig(c[j5 .."_"..jp].getData()).name then jo=jp;break end end;local jq=bH()if jk[K]==nil or jl[K]==nil or jq-jj[K][j3]>j7 then local jr;local js=0;js=ih(jj[K][iZ])-jj[K][j1]jr=jj[K][j2]if jr>js then je[j5]=je[j5]+jr-js end;if jo~=0 then local jt=ig(c[j5 .."_"..jo].getData())jl[K]=jt.percentage;jk[K]=jt.timeLeft;if jk[K]=="n/a"then jk[K]=0 end else jl[K]=bI(0.5+js*100/jj[K][j0])if jr<=js then jk[K]=0 else jk[K]=bI(0.5+js/((jr-js)/(jq-jj[K][j3])))end end;jj[K][j3]=jq;jj[K][j2]=js end;if gu==jh then gu=df("%s %d",ji,K)end;if jo==0 then gu=gu.." *"end;local ju;if jk[K]==0 then ju=""else ju=ip(jk[K])end;if jl[K]~=nil then local jv=bI(jl[K]*2.55)local jw=df("rgb(%d,%d,%d)",255-jv,jv,0)local jx=""if ju~=""and jk[K]<120 or jl[K]<5 then jx="red "end;local jy=df("rgb(%d,%d,%d)",dg(bI((255-jv)/2.55),50,100),dg(bI(jv/2.55),0,50),50)local jz="rgb(196,0,255)"if ji=="ATMO"then jz="rgb(0,188,255)"elseif ji=="SPACE"then jz="rgb(239,255,0)"end;local jA=false;if jB~=jz then jA=true end;jB=jz;if B then if jA then jm=jm-5;jn=jn-5 end;iX=iX..df([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jy,jz,hk,jn,jw,bI(jl[K]*1.7+0.5)-2,hk+1,jn+1,hk+5,jn+14,gu,jl[K],ju)jm=jm-22;jn=jn-22 else iX=iX..gJ(hk,jm,gu,jx.."pdim txtfuel")iX=iX..gJ(hk,jn,df("%d%% %s",jl[K],ju),"pdim txtfuel","fill:"..jw)jm=jm+30;jn=jn+30 end end end end;jf=jm end;local function jC(jD,dZ)if am==0 and an==0 then return end;if dZ<200000 and not c9 or dZ and c9 then local jE=0;if eU(cI)>1 then jE=45*math.log(eU(cI),10)if cI<0 then jE=-jE end end;jD[#jD+1]=df([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bI(cI),bI(jE))end;return jD end;local function jF(jG)local gn=-cH;jG=jG-jG:project_on(gn)local jH=vec3(0,0,1)jH=jH-jH:project_on(gn)local jI=jH:cross(gn)local jE=jH:angle_between(jG)*constants.rad2deg;if jG:dot(jI)<0 then jE=360-jE end;return jE end;local function jJ(jD,ai,aj,jK,jL,cT)if ab==0 then return end;local jM=ab;local jN=20;local jO=bI(jK)if cT then for K=-45,45,5 do local jP=K;jD[#jD+1]=df([[<g transform="rotate(%f,%d,%d)">]],jP,ai,aj)jQ=5;if K%15==0 then jQ=15 elseif K%10==0 then jQ=10 end;jD[#jD+1]=df([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jM+jN-jQ,ai,aj+jM+jN)end;jD[#jD+1]=gJ(ai,aj+jM+jN-35,jL,"pdim txt txtmid")jD[#jD+1]=gJ(ai,aj+jM+jN-25,jO.." deg","pdim txt txtmid")jD[#jD+1]=df([[<g transform="rotate(%f,%d,%d)">]],-jK,ai,aj)jD[#jD+1]=df([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jM+jN-20,ai+5,aj+jM+jN-20,ai,aj+jM+jN-15)jD[#jD+1]="</g>"end;jD[#jD+1]=[[<g style="clip-path: url(#headingClip);">]]local jR=jO;if cT then jR=jF(cC)end;local jS=20;local jT=bI(jR)local jU=0;local jV=aj+jM+jN+20;local jW=ai;if jL~="YAW"then jV=iT(130)jW=iS(960)end;local jX=[[<path class="txttick line" d="]]local jY=bI(jT-(jS+10)-jT%5+0.5)for K=jY+70,jY,-5 do local hk=jW-(-K*5+jR*5)if K%10==0 then jU=10;local dy=K;if dy==360 then dy=0 elseif dy>360 then dy=dy-360 elseif dy<0 then dy=dy+360 end;jD[#jD+1]=gJ(hk,jV+15,dy,"txtmid bright")elseif K%5==0 then jU=5 end;if jU==10 then jX=df([[%s M %f %f v %d]],jX,hk,jV-5,jU)else jX=df([[%s M %f %f v %d]],jX,hk,jV-2.5,jU)end end;jD[#jD+1]=jX..[["/>]]jD[#jD+1]=df([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jW-5,jV-20,jW+5,jV-20,jW,jV-10)if I then if cT then jL="HDG"end;jD[#jD+1]=gJ(iS(960),iT(100),jT.."Â°","dim txt txtmid size14","")jD[#jD+1]=gJ(iS(960),iT(85),jL,"dim txt txtmid size20","")end;jD[#jD+1]=[[</g>]]end;local function jZ(jD,j_,jK,ai,aj,cT,k0,fl)if ab==0 then return end;local jM=ab;local k1=bI(jM*3/5)if jM>0 then local k2=bI(j_)local jQ=0;local jX=df([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jK,ai,aj)if not c9 then jX=df([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jD[#jD+1]=df([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jM-1,ai,aj)jD[#jD+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bI(k2-30-k2%5+0.5),bI(k2+30+k2%5+0.5),5 do if K%10==0 then jQ=30 elseif K%5==0 then jQ=20 end;local hl=aj+-K*5+j_*5;if jQ==30 then jX=df([[%s M %d %f h %d]],jX,ai-k1-jQ,hl,jQ)if c9 then jD[#jD+1]=df([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jK,ai,aj,ai-k1+10,hl+4,K)jD[#jD+1]=df([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jK,ai,aj,ai+k1-10,hl+4,K)if K==0 or K==180 or K==-180 then jD[#jD+1]=df([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jK,ai,aj,ai-k1+20,hl,k1*2-40)end else jD[#jD+1]=gJ(ai-k1+10,hl,K,"pdim txt txtmid")jD[#jD+1]=gJ(ai+k1-10,hl,K,"pdim txt txtmid")end;jX=df([[%s M %d %f h %d]],jX,ai+k1,hl,jQ)else jX=df([[%s M %d %f h %d]],jX,ai-k1-jQ,hl,jQ)jX=df([[%s M %d %f h %d]],jX,ai+k1,hl,jQ)end end;jD[#jD+1]=jX..[["/>]]local k3="PITCH"if not cT then k3="REL PITCH"end;if j_>90 and not c9 then j_=90-(j_-90)elseif j_<-90 and not c9 then j_=-90-(j_+90)end;if jM>200 then if c9 then if fl>iD then jD[#jD+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jD[#jD+1]=gJ(ai,aj+20,k0,"pdim txt txtmid")end;jD[#jD+1]=df([[<g transform="rotate(%f,%d,%d)">]],-jK,ai,aj)else jD[#jD+1]=df([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jD[#jD+1]=df([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k1+25,aj-5,ai-k1+20,aj,ai-k1+25,aj+5,ai-k1+50,aj+4,k2)jD[#jD+1]=df([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k1-25,aj-5,ai+k1-20,aj,ai+k1-25,aj+5,ai+k1-30,aj+4,k2)jD[#jD+1]="</g>"end;local k4=bI(jM/3)jD[#jD+1]=df([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-k4,aj,jM-k4)if not c9 and cT then jD[#jD+1]=df([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jK,ai,aj,ai-k1+10,aj,k1*2-20)end;jD[#jD+1]="</g>"if jM<200 then if c9 and fl>iD then jD[#jD+1]=gJ(ai,aj-jM,k3,"pdim txt txtmid")jD[#jD+1]=gJ(ai,aj-jM+10,k2,"pdim txt txtmid")jD[#jD+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jD[#jD+1]=gJ(ai,aj+20,k0,"pdim txt txtmid")else jD[#jD+1]=gJ(ai,aj-jM,k3,"pdim txt txtmid")jD[#jD+1]=gJ(ai,aj-jM+15,k2,"pdim txt txtmid")end end end end;local function k5(jD,dZ,cT)local k6=ao;local k7=ap;if k6==0 and k7==0 then return end;local k8=78;local k9=19;local ka=c8;if c8~=-1 then jD[#jD+1]=gJ(k6+k8,k7+k9+20,df("AGL: %.1fm",c8),"pdim altsm txtend")end;if cT and(dZ<200000 and not c9 or dZ and c9)then table.insert(jD,df([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],k6-1,k7-4,k8+2,k9+6,k6+1,k7-1,k8-4,k9))local gs=0;local kb=1;local kc=0;local kd=dZ<0;local ke=dZ<kf.surfaceMaxAltitude;local kg=9;if kd then kg=0 end;local dZ=eU(dZ)while gs<6 do local kh=11;local ki=16;local kj=9;local kk=14;local jx="altsm"if gs>2 then ki=ki+3;kh=kh+2;kk=kk+2;kj=kj-6;jx="altbig"end;if kd then jx=jx.." red"elseif ke then jx=jx.." orange"end;local kl=dZ/kb%10;local km=bI(kl)local kn=bI((km+1)%10)local ko=kc;if gs==0 then ko=kl-km;if kd then ko=1-ko end end;if kd and(gs==0 or kc~=0)then local gv=kn;kn=km;km=gv end;local kp=ki*(ko-1)local kq=kp+ki;local hk=k6+kj+(6-gs)*kh;local hl=k7+kk;jD[#jD+1]=gJ(hk,hl+kp,kn,jx)jD[#jD+1]=gJ(hk,hl+kq,km,jx)gs=gs+1;kb=kb*10;if km==kg then kc=ko else kc=0 end end;table.insert(jD,[[</g></g>]])end end;local function kr(fq)local ks=-math.deg(eP(fq.y,fq.z))+180;ks=ks-90;if ks<0 then ks=360+ks end;if ks>180 then ks=-180+ks-180 end;return-ks end;local function kt(fq)local jR=math.deg(eP(fq.y,fq.x))-90;if jR<-180 then jR=360+jR end;return jR end;local function ku(jD,fq,fl,ai,aj)if fl>5 and not c9 or fl>iD then local jM=ab;local kv=20;local kw=20;local kx=kr(fq)local ky=kt(fq)local kz=14;local kA=kz/2;local kB=-ky/kw*jM;local kC=kx/kv*jM;local hk=ai+kB;local hl=aj+kC;local c4=di(kB^2+kC^2)local kD=[[<circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kA/kz..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kA..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hk-kz..[[,]]..hl..[[ h ]]..kA..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk+kA..[[,]]..hl..[[ h ]]..kA..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk..[[,]]..hl-kz..[[ v ]]..kA..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c4<jM then jD[#jD+1]=kD else local jE=eP(kC,kB)local kE=4;local kF=ai+jM*math.cos(jE)local kG=aj+jM*math.sin(jE)jD[#jD+1]=df('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jE*180/math.pi,kF,kG,kF-kE,kG-kE/2,kE*2,kE,kF+kE,kG-kE,kE,kE,-kE,kE)end;if not c9 then local kH=vec3(fq)kx=kr(-kH)ky=kt(-kH)kB=-ky/kw*jM;kC=kx/kv*jM;hk=ai+kB;hl=aj+kC;c4=di(kB^2+kC^2)if c4<jM then local kI=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kz..[[ v ]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hk..[[,]]..hl..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hk..[[,]]..hl..[[)" />
                                <path
                                    d="M ]]..hk-kA..[[,]]..hl..[[ h ]]..kz..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hk..[[,]]..hl..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hk..[[,]]..hl..[[)"/>]]jD[#jD+1]=kI end end end end;local function kJ(jD,iW,kK,kL)if ak==0 and al==0 then return end;kK=bI(kK+0.5)local jm=al+10;local jn=al+20;if ii()==1 and not l then jm=55;jn=65 end;local kM="CRUISE"local c="km/h"local dH=kL;if iW=="TRAVEL"or iW=="AUTOPILOT"then kM="THROT"c="%"dH=kK;local kN="dim"if kK<0 then kN="red"end;jD[#jD+1]=df([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kN,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eU(kK),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jD[#jD+1]=gJ(ak+10,jm,kM,"pbright txtstart")jD[#jD+1]=gJ(ak+10,jn,df("%.0f %s",dH,c),"pbright txtstart")if c9 and t and cM and bN then kK=bI(bO*100+0.5)local kN="red"if kK<0 then kN="red"end;jD[#jD+1]=df([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kN,1-eU(kK),ak-10,al+50,ak-15,al+53,ak-15,al+47)jD[#jD+1]=gJ(ak+10,jm+40,"LIMIT","pbright txtstart")jD[#jD+1]=gJ(ak+10,jn+40,kK.."%","pbright txtstart")end;if c9 and t or b6 then jD[#jD+1]=gJ(ak+10,jm-40,"LIMIT: "..cw.." km/h","dim txtstart")elseif not c9 and b1 then jD[#jD+1]=gJ(ak+10,jm-40,"LIMIT: "..bI(_*3.6+0.5).." km/h","dim txtstart")end end;local function kO(jD,kP)if ak==0 and al==0 then return end;local kQ=al-10;local kR=ak+10;jD[#jD+1]=gJ(0,0,"","pdim txt txtend")if ii()==1 and not l then kQ=75 end;jD[#jD+1]=gJ(kR,kQ,bI(kP).." km/h","pbright txtbig txtstart")end;local function kS(jD)jD[#jD+1]=gJ(iS(150),iT(1070),df("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jD[#jD+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jD[#jD+1]=gJ(iS(960),iT(550),"Warning: Invalid Control Scheme Detected","warnings")jD[#jD+1]=gJ(iS(960),iT(600),"Keyboard Scheme must be selected","warnings")jD[#jD+1]=gJ(iS(960),iT(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kT=iS(960)local kU=iT(860)local kV=iT(880)local kW=iT(900)local kX=iT(960)local kY=iT(200)local kZ=iT(250)local k_=iT(960)if ii()==1 and not l then kU=iT(135)kV=iT(155)kW=iT(175)kY=iT(115)kZ=iT(95)end;local l0="#222222"local l1="white"local l2="dimmer"local l3="pbright"local l4="#110000"local l5=l0;local l6=l2;if aZ then local l7=""if type(aZ)=="string"then l7="-"..aZ end;jD[#jD+1]=gJ(kT,kU,"Brake Engaged"..l7,"warnings")l4="#440000"l5=l1;l6=l3 elseif bM>0 then jD[#jD+1]=gJ(kT,kU,"Auto-Brake Engaged","warnings","opacity:"..bM)end;local l8="#110000"local l9=l0;local la=l2;if c9 and cv and c8==-1 then if not b1 and not bo and not b4 and not cL and not b7 and not b5 then jD[#jD+1]=gJ(kT,kY+50,"** STALL WARNING **","warnings")l8="#ff0000"l9=l1;la=l3;fQ("stall","SW",2)end end;if cS then jD[#jD+1]=gJ(kT,kY+90,"Flight Assist in Progress","warnings")end;if cd then jD[#jD+1]=gJ(kT,k_,"Gyro Enabled","warnings")end;local lb="#111100"local lc=l0;local ld=l2;if bk then lb="#775500"lc=l1;ld=l3;if bQ then jD[#jD+1]=gJ(kT,kV,"Gear Extended","warn")else jD[#jD+1]=gJ(kT,kV,"Landed (G: Takeoff)","warnings")end end;if c8>-1 and(not cL or cb<100)then local le=io(d:getTargetGroundAltitude())jD[#jD+1]=gJ(kT,kW,"Hover Height: "..le,"warn")end;local lf="#000011"local lg=l0;local lh=l2;if bZ then lf="#0000DD"lg=l1;lh=l3;jD[#jD+1]=gJ(kT,kX+20,"ROCKET BOOST ENABLED","warn")end;local li="#001100"local lj=l0;local lk=l2;if antigrav and not q and cL and bt~=nil then li="#00DD00"lj=l1;lk=l3;local ll="warnings"if eU(cb-antigrav.getBaseAltitude())<501 then ll="warn"end;jD[#jD+1]=gJ(kT,kY+40,df("Target Altitude: %d Singularity Altitude: %d",bI(bt),bI(antigrav.getBaseAltitude())),ll)end;if b1 and bh~="None"then jD[#jD+1]=gJ(kT,kY,"Autopilot "..be,"warn")elseif br~=nil then jD[#jD+1]=gJ(kT,kY+20,df("LockedPitch: %d",bI(br)),"warn")elseif bV then jD[#jD+1]=gJ(kT,kY+20,"Follow Mode Engaged","warn")elseif b6 or c7 then jD[#jD+1]=gJ(kT,kY+20,"Re-entry in Progress","warn")end;if b3 or b7 then local le=io(b8,2)if b7 then if cL then le=io(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jD[#jD+1]=gJ(kT,kY,"VTO to "..le,"warn")elseif b5 and not bx then if c6 then jD[#jD+1]=gJ(kT,kY,"Takeoff to "..bh,"warn")else jD[#jD+1]=gJ(kT,kY,"Takeoff to "..le,"warn")end;if aZ and not b7 then jD[#jD+1]=gJ(kT,kY+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jD[#jD+1]=gJ(kT,kY,"Altitude Hold: "..df("%.1fm",b8),"warn")end end;if b7 and(antigrav~=nil and antigrav)then if ca>0.1 then jD[#jD+1]=gJ(kT,kY+20,"Beginning ascent","warn")elseif ca<0.09 and ca>0.05 then jD[#jD+1]=gJ(kT,kY+20,"Aligning trajectory","warn")elseif ca<0.05 then jD[#jD+1]=gJ(kT,kY+20,"Leaving atmosphere","warn")end end;if bx then if cx~=nil then jD[#jD+1]=gJ(kT,kY,cx,"warn")end end;if b4 then if lm then local ln="Brake Landing"if d7 then ln=ln.."-Aligning"end;if d6 then ln=ln.."-Drift Limited"end;jD[#jD+1]=gJ(kT,kY,ln,"warnings")else jD[#jD+1]=gJ(kT,kY,"Coast-Landing","warnings")end end;if b0 then jD[#jD+1]=gJ(kT,kY,"Prograde Alignment","crit")end;if a_ then jD[#jD+1]=gJ(kT,kY,"Retrograde Alignment","crit")end;local lo="#110000"local lp=l0;local lq=l2;if cU then lo="#FF0000"lp=l1;lq=l3;local type;if string.find(cU,"COLLISION")then type="warnings"else type="crit"end;jD[#jD+1]=gJ(kT,kZ+20,cU,type)elseif ca==0 then local lr,ls=co.checkLOS(cF:normalize())if ls~=nil then lq=l3;lo="#FF0000"lp=l1;local le=io(ls)local lt=ck.computeTravelTime(cG,0,ls)local lu="Collision"if lr.noAtmosphericDensityAltitude>0 then lu="Atmosphere"end;jD[#jD+1]=gJ(kT,kZ+20,lr.name.." "..lu.." "..ip(lt).." In "..le,"crit")end end;if bo and not bx then jD[#jD+1]=gJ(kT,kY+60,lv,"warn")end;local lw="#111100"local lx=l0;local ly=l2;if cY and#cY>1 then lw="#DDDD00"lx=l1;ly=l3 end;local lz=iS;local lA=iT;local l2="topButton"local lB="topButtonActive"local lC=l2;if b1 or bo or c6 or bx then lC=lB end;local lD=l2;if b0 then lD=lB end;local lE=l2;if b4 or bk then lE=lB end;local lF=l2;if b3 or bo then lF=lB end;local lG=l2;if a_ then lG=lB end;local lH=l2;if bx or cz and b1 then lH=lB end;if w and I then local lI=lA(30)jD[#jD+1]=df([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lC,lz(960),lA(54),lA(-53),lz(-120),lz(25),lA(50))jD[#jD+1]=gJ(lz(910),lI,"AUTOPILOT")jD[#jD+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,lz(865),lA(51),lz(-25),lA(-50),lz(-110),lz(25),lA(46))jD[#jD+1]=gJ(lz(800),lI,"PROGRADE")jD[#jD+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,lz(755),lA(47),lz(-25),lA(-46),lz(-98),lz(44),lA(44))jD[#jD+1]=gJ(lz(700),lI,"LAND")jD[#jD+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lF,lz(960),lA(54),lA(-53),lz(120),lz(-25),lA(50))jD[#jD+1]=gJ(lz(1010),lI,"ALT HOLD")jD[#jD+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lz(1055),lA(51),lz(25),lA(-50),lz(110),lz(-25),lA(46))jD[#jD+1]=gJ(lz(1122),lI,"RETROGRADE")jD[#jD+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,lz(1165),lA(47),lz(25),lA(-46),lz(98),lz(-44),lA(44))jD[#jD+1]=gJ(lz(1220),lI,"ORBIT")jD[#jD+1]=[[
                                    </g>
                                </g>]]jD[#jD+1]="</g>"end;return jD end;local function lJ(fl)return bI(fR(fl*3.6,0)+0.5).." km/h"end;local function lK(gs)local gu=bh;if gs~=nil and type(gs)=="number"then if gs==0 then return"None"end;gu=cP[gs].name end;if gu==nil then gu=g1.name end;if gu==nil then gu="None"end;return gu end;local function lL(jD)local lM=co.routeWP(true)if not lM or#lM==0 then return end;local hk=iS(750)local hl=iT(360)if b1 or bo then jD[#jD+1]=gJ(hk,hl,"REMAINING ROUTE","pdim txtstart size20")else jD[#jD+1]=gJ(hk,hl,"LOADED ROUTE","pdim txtstart size20")end;for dG,K in pairs(lM)do hl=hl+20;jD[#jD+1]=gJ(hk,hl,dG..". "..lM[dG],"pdim txtstart size20")end end;local function lN(jD)local hk=ay+10;local hl=az+20;local lO={}local lP={"Alt-4: AutoTakeoff to Target"}local lQ={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lR={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lS={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lO,"--------------DYNAMIC-----------------")if c9 then if c8~=-1 then il(lO,lP)if c1 and kf and c1.name==kf.name then table.insert(lO,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aY then if antigrav then if cL then table.insert(lO,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lO,"Turn on AGG to takeoff to AGG Height")end end;if aY then table.insert(lO,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lO,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lO,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bk then table.insert(lO,"G: Takeoff to hover height, raise gear")else table.insert(lO,"G: Lowergear and Land")end else il(lO,lQ)table.insert(lO,"G: Begin BrakeLanding or Land")end;if b7 then table.insert(lO,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else il(lO,lR)if shield then table.insert(lO,"Alt-Shift-6: Vent shields")if not G then table.insert(lO,"Alt-Shift-7: Toggle shield off/on")end end end;if g1~=nil then table.insert(lO,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lO,"Alt-9: Activate Gyroscope")end;if aU~="none"or aT~="none"or aV~="none"then table.insert(lO,"Alt-Shift-9: Cycles engines with Extra tags")end;if b3 then table.insert(lO,"Alt-Spacebar/C will raise/lower target height")table.insert(lO,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c9 then table.insert(lO,"LALT+Mousewheel will lower/raise speed limit")end;il(lO,lS)for K=1,#lO do hl=hl+12;jD[#jD+1]=gJ(hk,hl,lO[K],"pdim txtbig txtstart")end end;local function lT(jD)local lU=ay;local lV=az;local lW=ax;local lX=4;local lY=15;local hk=0;local hl=0;local lZ,l_,m0,m1;local m2;local function m3(type)local gE,bK,fl,m4,jx,m5;if type=="Periapsis"then gE=m2.periapsis.altitude;bK=m2.timeToPeriapsis;fl=m2.periapsis.speed;jx="txtend"m4=12;m5=math.min(hk,lU+lW-kf.radius/m0-lX*2)else gE=m2.apoapsis.altitude;bK=m2.timeToApoapsis;fl=m2.apoapsis.speed;m4=-12;jx="txtstart"m5=hk end;if cG<1 then bK=0 end;jD[#jD+1]=df([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m5+m4,hl-5,hk,hl-5)jD[#jD+1]=df([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m5-m4*4,hl+2,hk,hl+2)jD[#jD+1]=gJ(m5,hl,type,jx)hk=m5-m4*2;hl=hl+lY;local le=io(gE)jD[#jD+1]=gJ(hk,hl,le,jx)hl=hl+lY;jD[#jD+1]=gJ(hk,hl,ip(bK),jx)hl=hl+lY;jD[#jD+1]=gJ(hk,hl,lJ(fl),jx)end;local m6=lW*1.5;if bF=="INFO"then m6=25*9 end;if bF~="HIDE"then jD[#jD+1]=[[<g class="pbright txtorb txtmid">]]jD[#jD+1]=df('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lW*2,m6,lU,lV)jD[#jD+1]=df([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lW*2,m6,lU,lV)end;local m7=lW*1.5;local m8=lW*2;local m9=m7/2;local ma=lW;local mb=lU+ma;local mc=lV+m9;local md=lU+m8;local me=lV+m7;if bF=="ORBIT"then lV=lV+lX;lZ=lW/2;m1=0;m2={}m2.periapsis={}m2.apoapsis={}if fp~=nil then if fp.periapsis~=nil then m2.periapsis.altitude=fp.periapsis.altitude;m2.periapsis.speed=fp.periapsis.speed end;if fp.apoapsis~=nil then m2.apoapsis.altitude=fp.apoapsis.altitude;m2.apoapsis.speed=fp.apoapsis.speed end;m2.period=fp.period;m2.eccentricity=fp.eccentricity;m2.timeToApoapsis=fp.timeToApoapsis;m2.timeToPeriapsis=fp.timeToPeriapsis;m2.eccentricAnomaly=fp.eccentricAnomaly;m2.trueAnomaly=fp.trueAnomaly end;if m2.periapsis==nil then m2.periapsis={}m2.periapsis.altitude=-kf.radius;m2.periapsis.speed=_ end;if m2.eccentricity==nil then m2.eccentricity=1 end;if m2.apoapsis==nil then m2.apoapsis={}m2.apoapsis.altitude=cb;m2.apoapsis.speed=0 end;if cG<1 then m2.apoapsis.altitude=cb;m2.apoapsis.speed=0 end;if m2.apoapsis.altitude then m0=(m2.apoapsis.altitude+m2.periapsis.altitude+kf.radius*2)/(lZ*2)l_=(kf.radius+m2.apoapsis.altitude)/m0*(1-m2.eccentricity)m1=lZ-m2.periapsis.altitude/m0-kf.radius/m0;local mf=math.pi;if m2.period~=nil and m2.period>0 and m2.timeToApoapsis~=nil then mf=m2.eccentricAnomaly;if m2.timeToPeriapsis<m2.timeToApoapsis then mf=2*math.pi-mf end end;if cG<1 or mf~=mf then mf=math.pi end;local mg=-lZ*math.cos(mf)+lU+ma+lX;local mh=l_*math.sin(mf)+lV+m9+lX;local mi=""jD[#jD+1]='<g clip-path="url(#orbitRect)">'jD[#jD+1]=df([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mi,lU+lW+lX,lV+lW*1.5/2+lX,lZ,l_)if l_<1 then jD[#jD+1]=df([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lU+lW+lX-m1,lV+lW*1.5/2+lX,mg,mh)end;jD[#jD+1]=df('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lU+lW+lX-m1,lV+lW*1.5/2+lX,(kf.radius+kf.noAtmosphericDensityAltitude)/m0)jD[#jD+1]=df('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lU+lW+lX-m1,lV+lW*1.5/2+lX,(kf.radius+kf.noAtmosphericDensityAltitude)/m0)jD[#jD+1]=df([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lU+lW+lX,lV+lW*1.5/2+lX,lZ,l_)jD[#jD+1]=df('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lU+lW+lX-m1,lV+lW*1.5/2+lX,kf.radius/m0)jD[#jD+1]='</g>'local mj=math.floor(kf.radius/m0+0.5)hk=lU+lW+lX*4+lZ;hl=lV+lW*1.5/2+5+lX;if m2.apoapsis~=nil and m2.apoapsis.speed<_ then m3("Apoapsis")end;hl=lV+lW*1.5/2+5+lX;hk=lU+lW-lX*2-lZ;if m2.periapsis~=nil and m2.periapsis.speed<_ and m2.periapsis.altitude>0 then m3("Periapsis")end;jD[#jD+1]=gJ(lU+lW+lX,lV+20+lX,kf.name,"txtorbbig")jD[#jD+1]=df('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mg,mh)jD[#jD+1]=[[</g>]]return jD else jD[#jD+1]='<g clip-path="url(#orbitRect)">'local mk=""local ml=1.2*(mm-mn)/(lW*2)local mo=1.4*(mp-mq)/(lW*1.5)for dG,ds in pairs(e[0])do if ds.center then local hk=lU+lW+ds.center.x/ml;local hl=lV+lW*1.5/2+ds.center.y/mo;mk=mk..'<circle cx="'..hk..'" cy="'..hl..'" r="'..ds.radius/ml*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(ds.name,"Moon")and not string.match(ds.name,"Sanctuary")and not string.match(ds.name,"Space")then mk=mk.."<text x='"..hk.."' y='"..hl+ds.radius/ml*30+20 .."' font-size='12' fill="..iK.." text-anchor='middle' font-family='Montserrat'>"..ds.name.."</text>"end end end;local fr=vec3(b.getConstructWorldPos())local hk=lU+lW+fr.x/ml;local hl=lV+lW*1.5/2+fr.y/mo;mk=mk..'<circle cx="'..hk..'" cy="'..hl..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mk=mk.."<text x='"..hk.."' y='"..hl-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"ix=ml;iy=mo;local mr=fr+cF*1000000;local ms=lU+lW+mr.x/ml;local jn=lV+lW*1.5/2+mr.y/mo;mk=mk..'<line x1="'..hk..'" y1="'..hl..'" x2="'..ms..'" y2="'..jn..'" stroke="purple" stroke-width="1"/>'jD[#jD+1]=mk;jD[#jD+1]='</g>'end elseif bF=="INFO"then jD=cm.DrawOdometer(jD,iM,bl,iN)elseif bF=="HELP"then jD=lN(jD)elseif bF=="SCOPE"then jD[#jD+1]='<g clip-path="url(#orbitRect)">'local mt=d0;if ca>0 then table.sort(c_,function(ev,ew)local ex,ey=ev.center,ew.center;return(ex.x-cJ.x)^2+(ex.y-cJ.y)^2+(ex.z-cJ.z)^2<(ey.x-cJ.x)^2+(ey.y-cJ.y)^2+(ey.z-cJ.z)^2 end)end;local gR={}local mu={}local mv=120;local mw=nil;local mx=nil;for K,ds in ipairs(c_)do local gQ=ds.center-cJ;local my=gQ:len()local mz=gQ:normalize()local mA=gQ:cross(cC):normalize()local mB=math.acos(mA:dot(cD))if mB~=mB then mB=0 end;if mA:cross(cD):dot(cC)<0 then mB=-mB end;local mC=gQ:project_on_plane(cC):len()local mD=math.sin(mB)*math.asin(mC/my)*constants.rad2deg;local mE=math.cos(mB)*math.asin(mC/my)*constants.rad2deg;if mz:dot(cC)<0 then mE=90*math.cos(mB)+90*math.cos(mB)-mE;mD=90*math.sin(mB)+90*math.sin(mB)-mD end;local hk=mb+mD/mt*m7;local hl=mc+mE/mt*m7;local mF=(hk-mb)*(hk-mb)+(hl-mc)*(hl-mc)local mG=math.asin((ds.radius+ds.surfaceMaxAltitude)/my)*constants.rad2deg;if mG~=mG then mG=mt end;local hG=mG/mt*m7;local mH=math.asin(ds.atmosphereRadius/my)*constants.rad2deg;if mH~=mH then mH=mG end;local mI=mH/mt*m7;local c4=io(my,1)local mJ=ds.name;local mK=false;if hl>lV then if hl>me then if hl-mI<=me then mK=true end else mK=true end else if hl+mI>=lV then mK=true end end;local mL=false;local mM=hk;if ds.systemId==0 then mM=hk+mv else mM=hk-mv end;if mM+mv>lU then if mM+mv>md then if mM-mI-mv<=md then mL=true end else mL=true end else if mM+mI+mv>=lU then mL=true end end;local mN={}mN.x=hk;mN.y=hl;mN.planet=ds;mN.atmoSize=mI;if not mw or mF<mw then mw=mF;mx=mN end;if mL and mK then local mO=math.max(mI,5)if mF<mO*mO then mJ=mJ.." - "..c4 end;mN.size=hG;mN.i=K;mN.displayString=mJ;mN.distance=c4;mN.visible=true;mu[#mu+1]=mN else mN.visible=false end end;local mP=false;table.sort(mu,function(ex,ey)return ex.y<ey.y end)for dG,fu in ipairs(mu)do local ds,hG,K,mI,hk,hl,mJ,c4=fu.planet,fu.size,fu.i,fu.atmoSize,fu.x,fu.y,fu.displayString,fu.distance;local m5,mQ,mR,mS;local mT=15;local jx="pdim"if ds.systemId~=0 then mR=iS(string.len(mJ)*5)mT=-(15+mR)mS=iT(10)jx="pdimfill"else mR=iS(string.len(mJ)*9)mS=iT(15)end;if hG*2>mR then m5=dg(hk,lU+mR/2,md-mR/2)mQ=dg(hl,lV+mS,me-5)m5=dg(m5,hk-hG+mR/2,hk+hG-mR/2)mQ=dg(mQ,hl-hG+mS,hl+hG)else m5=hk+mT;mQ=hl end;for mU,fu in pairs(gR)do local mV=fu.textPositions;local mW=mV.y-mQ;if mU~=K and eU(mW)<mV.height and mV.x+mV.width>m5 and mV.x<m5+mR then if hG>mR then mQ=dg(mQ+mS,lV+15,me-5)else mQ=mV.y+mV.height+1 end end end;local mX=mJ~=ds.name or m5<=mb and m5+mR>=mb and mQ-mS<=mc and mQ>=mc;fu.hovered=mX;local mY=1;if mX then mY=2;if hG*2<mR then mY=10 end;if mJ==ds.name then mJ=mJ.." - "..c4 end;jx="pbright"if ds.systemId~=0 then mR=iS(string.len(mJ)*5)mT=-(15+mR)else mR=iS(string.len(mJ)*7)end;if hG*2>mR then m5=dg(hk,lU+mR/2,md-mR/2)m5=dg(m5,hk-hG+mR/2,hk+hG-mR/2)else m5=hk+mT end end;gR[K]={}gR[K].textPositions={}gR[K].textPositions.y=mQ;gR[K].textPositions.x=m5;gR[K].textPositions.width=mR;gR[K].textPositions.height=mS;gR[K].output=""if hG*2>mR then jx=jx.." txtmid"else jx=jx.." txtstart"end;if mI-hG>2 then gR[K].output=df('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hk,hl,mI,iL,0.1*mY)end;gR[K].output=gR[K].output..df('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hk,hl,hG,iL,0.2*mY)if ds.systemId==0 then gR[K].output=gR[K].output..df([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m5,mQ,iK,jx,mJ)if hG*2<=mR then gR[K].output=gR[K].output..df("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m5+mR,mQ+2,m5,mQ+2,hk,hl)end else gR[K].output=gR[K].output..df([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m5,mQ,iL,jx,mJ)if hG*2<=mR then gR[K].output=gR[K].output..df("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m5,mQ+2,m5+mR,mQ+2,hk,hl)end end end;for dG=#c_,1,-1 do if gR[dG]then jD[#jD+1]=gR[dG].output end end;if mx~=nil and d0<90 and not mx.hovered then local mZ=mx.planet.atmosphereRadius/mx.atmoSize;local m_=di(mw)*mZ;local n0=io(m_,1)local mR=iS(math.max(string.len(n0)*7,string.len(mx.planet.name)*7))local mS=iT(12)local m5=dg(mx.x+(mb-mx.x)/2,lU+mR/2,md-mR/2)local mQ=dg(mx.y+(mc-mx.y)/2,lV+mS*2,me-5)jD[#jD+1]=df("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mx.x,mx.y,mb,mc)jD[#jD+1]=df([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m5,mQ,"white",n0)if not mx.visible then jD[#jD+1]=df([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m5,mQ-mS,"white",mx.planet.name)end end;if cG>1 then local gQ=cF;local mz=gQ:normalize()local mC=gQ:project_on_plane(cC):len()local mA=gQ:cross(cC):normalize()local mB=math.acos(mA:dot(cD))if mB~=mB then mB=0 end;if mA:cross(cD):dot(cC)<0 then mB=-mB end;local mD=math.sin(mB)*math.asin(mC/gQ:len())*constants.rad2deg;local mE=math.cos(mB)*math.asin(mC/gQ:len())*constants.rad2deg;if mz:dot(cC)<0 then mE=90*math.cos(mB)+90*math.cos(mB)-mE;mD=90*math.sin(mB)+90*math.sin(mB)-mD end;local hk=mb+mD/mt*m7;local hl=mc+mE/mt*m7;local kz=14;local kA=kz/2;local kD=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kA/kz..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk-kz..[[,]]..hl..[[ h ]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk+kA..[[,]]..hl..[[ h ]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kz..[[ v ]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jD[#jD+1]=kD end;jD[#jD+1]=df("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mb,mc-10,mb,mc+10)jD[#jD+1]=df("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mb-10,mc,mb+10,mc)jD[#jD+1]='</g>'else return jD end end;local function n1(n2,n3)local n4;local n5=(n3-n2):normalize()local fs=(cJ-n2):dot(n5)/n5:dot(n5)if fs<=0. then return(cJ-n2):len()elseif fs>=(n3-n2):len()then return(cJ-n3):len()end;local n6=n2+fs*n5;n4=(n6-cJ):len()return n4 end;local function n7()local n4;local n8=nil;local n9=nil;local na=nil;for dG,nb in pairs(e[0])do if nb.hasAtmosphere then local c4=n1(kf.center,nb.center)if n8==nil or c4<n8 then n9=nb;n8=c4;na=kf end;if c1 and c1.hasAtmosphere and c1.name~=kf.name then local eK=n1(c1.center,nb.center)if eK<n8 then n9=nb;n8=eK;na=c1 end end end end;local nc=iS(1770)local nd=iT(330)if n8 then local ne="txttick "local nf=500000;if n8<n9.radius+nf or n8<na.radius+nf then if cQ then ne="txttick red "else ne="txttick orange "end end;n4=io(n8,2)iC=gJ(nc,nd,"Pipe ("..na.name.."--"..n9.name.."): "..n4,ne.."pbright txtmid")end end;local function ng(hk,hl,nh,ni,kM)local nj={x=hk,y=hl,width=nh,height=ni,label=kM}iw[kM]=nj;return nj end;local function nk(nl,nm,nh,ni,hk,hl,nn,no,np,nq,jx)local nj={enableName=nl,disableName=nm,width=nh,height=ni,x=hk,y=hl,toggleVar=nn,toggleFunction=no,drawCondition=np,hovered=false,class=jx}if nq then table.insert(iv,nj)else table.insert(iu,nj)end;return nj end;local function nr(ns)if not iA then nt=false;nu=false;nv=false;w=true;return elseif ns=="handling"then nt=not nt;nu=false;nv=false elseif ns=="hud"then nu=not nu;nt=false;nv=false elseif ns=="physics"then nv=not nv;nt=false;nu=false end;if nv or nu or nt then iB=im(ns)w=false else iB="none"w=true end end;local function nw()iA=not iA;if iA then it=iv;bX="Hold SHIFT to see Settings"d1=w else it=iu;bX="Hold SHIFT to see Control Buttons"nr()w=d1 end end;local function nx()local function ny(ds,dG)ds.set(not ds.get())if ds.get()then bX=dG.." set to true"else bX=dG.." set to false"end;if dG=="showHud"then d1=ds.get()elseif dG=="BrakeToggleDefault"then aX=j end end;local nz=50;local nA=340;local hk=500;local hl=cf/2-400;local nB=0;for dG,ds in pairs(im("boolean"))do if type(ds.get())=="boolean"then nk(dG,dG,nA,nz,hk,hl,function()return ds.get()end,function()ny(ds,dG)end,function()return true end,true)hl=hl+nz+20;if nB==9 then hk=hk+nA+20;hl=cf/2-400;nB=0 else nB=nB+1 end end end;nk("Control View","Control View",nA,nz,10,cf/2-500,function()return true end,nw,function()return true end,true)nk("View Handling Settings",'Hide Handling Settings',nA,nz,10,cf/2-(500-nz),function()return nt end,function()nr("handling")end,function()return true end,true)nk("View Hud Settings",'Hide Hud Settings',nA,nz,10,cf/2-(500-nz*2),function()return nu end,function()nr("hud")end,function()return true end,true)nk("View Physics Settings",'Hide Physics Settings',nA,nz,10,cf/2-(500-nz*3),function()return nv end,function()nr("physics")end,function()return true end,true)end;local function nC()local function gt()local fT=cJ;local gu=kf.name..". "..#bn;if radar_1 then gu=cp.GetClosestName(gu)end;return cn.AddNewLocation(gu,fT,false,true)end;local function nD()b2=not b2 end;local function nE(nF)if nF==1 then b0=not b0;a_=false else a_=not a_;b0=false end;b1=false;b3=false;bV=false;b4=false;br=nil;b6=false;b5=false end;local function nG(nH,nI)cn.UpdatePosition(nil,nH,nI)end;local function go()cn.ClearCurrentPosition()end;local function nJ(gs)local lM=co.routeWP(true)if lM and#lM>0 then return"Engage Route: "..lM[1]end;return"Engage Autopilot: "..lK(gs)end;local function nK(gs)local lM=co.routeWP(true)if lM and#lM>0 then return"Next Route Point: "..lM[1]end;return"Disable Autopilot: "..lK(gs)end;local function nL()if ii()==1 then bV=not bV;if bV then b1=false;a_=false;b0=false;b3=false;b6=false;b4=false;b5=false;nM=bk;bk=false;d.control.retractLandingGears()ij:setTargetGroundAltitude(X)fQ("folOn","F")else fQ("folOff","F")aZ="Follow Off"cu=p;bk=nM;if bk then d.control.extendLandingGears()ij:setTargetGroundAltitude(Y)end end else bX="Follow Mode only works with Remote controller"bV=false end end;local nz=50;local nA=260;local nN=iS(30)local nO=ay+ax*2+2;local nP=az+1;nk("+","+",nN,nN,nO,nP+nN+1,function()return false end,function()d0=d0/8 end,function()return bF=="SCOPE"end,nil,"ZoomButton")nk("-","-",nN,nN,nO,nP,function()return false end,function()d0=math.min(d0*8,90)end,function()return bF=="SCOPE"end,nil,"ZoomButton")nk("0","0",nN,nN,nO,nP+nN*2+2,function()return false end,function()d0=90 end,function()return bF=="SCOPE"and d0~=90 end,nil,"ZoomButton")local nQ=nk("Enable Brake Toggle","Disable Brake Toggle",nA,nz,ce/2-nA/2,cf/2+350,function()return aX end,function()aX=not aX;if aX then bX="Brakes in Toggle Mode"else bX="Brakes in Default Mode"end end)nk("Align Prograde","Disable Prograde",nA,nz,ce/2-nA/2-50-nQ.width,cf/2-nz+380,function()return b0 end,function()nE(1)end)nk("Align Retrograde","Disable Retrograde",nA,nz,ce/2-nA/2+nQ.width+50,cf/2-nz+380,function()return a_ end,nE,function()return ca==0 end)nR=nk(nJ,nK,600,60,ce/2-600/2,cf/2-60/2-330,function()return b1 or bo or c6 or bx end,function()end)local K;local function nS(nT)local gs=cX+nT;if gs>#cP then gs=gs-#cP-1 end;if gs<0 then gs=#cP+gs end;return gs end;nU={}for K=0,10 do local nV=nk(function(ey)local gs=nS(ey.apExtraIndex)if b1 or bo or c6 or bx then return"Redirect: "..lK(gs)end;return nJ(gs)end,function(ey)local gs=nS(ey.apExtraIndex)return nK(gs)end,600,60,ce/2-600/2,cf/2-60/2-330+60*K,function(ey)local gs=nS(ey.apExtraIndex)return gs==bj and(b1 or bo or c6 or bx)end,function(ey)local gs=nS(ey.apExtraIndex)local nW=bj==gs;bj=gs;cn.UpdateAutopilotTarget()co.ToggleAutopilot()if not nW and not(b1 or bo or c6 or bx)then co.ToggleAutopilot()end end,function()return cW and(#co.routeWP(true)==0 or K==0)end)nV.apExtraIndex=K;nU[K]=nV end;nk("Save Position","Save Position",200,nR.height,nR.x+nR.width+30,nR.y,function()return false end,gt,function()return bj==0 or g1==nil end)nk("Update Position","Update Position",200,nR.height,nR.x+nR.width+30,nR.y,function()return false end,function()nG(nil)end,function()return bj>0 and g1~=nil end)nk("Save Heading","Clear Heading",200,nR.height,nR.x+nR.width+30,nR.y+nR.height+20,function()return g1.heading~=nil end,function()if g1.heading~=nil then nG(false)else nG(true)end end,function()return bj>0 and g1~=nil end)nk("Save AGG Alt","Clear AGG Alt",200,nR.height,nR.x+nR.width+30,nR.y+nR.height*2+40,function()return g1.agg~=nil end,function()if g1.agg~=nil then nG(nil,false)else nG(nil,true)end end,function()return bj>0 and g1~=nil and antigrav end)nk("Clear Position","Clear Position",200,nR.height,nR.x-200-30,nR.y,function()return true end,go,function()return bj>0 and g1~=nil end)nk("Save Route","Save Route",200,nR.height,nR.x-200-30,nR.y+nR.height*2+40,function()return false end,function()co.routeWP(false,false,2)end,function()return#co.routeWP(true)>0 end)nk("Load Route","Clear Route",200,nR.height,nR.x-200-30,nR.y+nR.height+20,function()return#co.routeWP(true)>0 end,function()if#co.routeWP(true)>0 then co.routeWP(false,true)elseif b1 or bo then bX="Disable Autopilot before loading route"return else co.routeWP(false,false,1)end end,function()return true end)nz=60;nA=300;local hk=0;local hl=cf/2-150;nk("Enable Check Damage","Disable Check Damage",nA,nz,hk,hl-nz-20,function()return s end,function()s=not s end)nk("View Settings","View Settings",nA,nz,hk,hl,function()return true end,nw)hl=hl+nz+20;nk("Enable Turn and Burn","Disable Turn and Burn",nA,nz,hk,hl,function()return b2 end,nD)hk=10;hl=cf/2-300;nk("Horizontal Takeoff Mode","Vertical Takeoff Mode",nA,nz,hk+nA+20,hl,function()return aY end,function()aY=not aY;if aY then bX="Vertical Takeoff Mode"else bX="Horizontal Takeoff Mode"end end,function()return cK end)hl=hl+nz+20;nk("Engage Orbiting","Cancel Orbiting",nA,nz,hk+nA+20,hl,function()return bx end,co.ToggleIntoOrbit,function()return ca==0 and cT end)hl=cf/2-150;nk("Glide Re-Entry","Cancel Glide Re-Entry",nA,nz,hk+nA+20,hl,function()return b6 end,function()c5=1;nE(1)end,function()return kf.hasAtmosphere and not c9 end)hl=hl+nz+20;nk("Parachute Re-Entry","Cancel Parachute Re-Entry",nA,nz,hk+nA+20,hl,function()return b6 end,function()c5=2;nE(1)end,function()return kf.hasAtmosphere and not c9 end)hl=hl+nz+20;nk("Engage Follow Mode","Disable Follow Mode",nA,nz,hk,hl,function()return bV end,nL,function()return ii()==1 end)nk("Enable Repair Arrows","Disable Repair Arrows",nA,nz,hk+nA+20,hl,function()return iQ end,function()iQ=not iQ;if iQ then bX="Repair Arrows Enabled"else bX="Repair Arrows Diabled"end end,function()return ii()==1 end)hl=hl+nz+20;if not q then nk("Enable AGG","Disable AGG",nA,nz,hk,hl,function()return cL end,co.ToggleAntigrav,function()return antigrav~=nil end)end;nk(function()return df("Switch IPH Mode - Current: %s",by)end,function()return df("IPH Mode: %s",by)end,nA*2,nz,hk,hl,function()return false end,function()if by=="All"then by="Custom Only"elseif by=="Custom Only"then by="No Moons"else by="All"end;bX="IPH Mode: "..by end)hl=hl+nz+20;nk(function()return df("Toggle Control Scheme - Current: %s",g)end,function()return df("Control Scheme: %s",g)end,nA*2,nz,hk,hl,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bX="New Control Scheme: "..g end)local nX=iT(20)local nV=ng(0,0,iS(70),nX,"HELP")nV=ng(nV.x+nV.width,nV.y,iS(80),nX,"INFO")nV=ng(nV.x+nV.width,nV.y,iS(70),nX,"ORBIT")nV=ng(nV.x+nV.width,nV.y,iS(70),nX,"SCOPE")ng(nV.x+nV.width,nV.y,iS(70),nX,"HIDE")end;local nY={}local nZ=nil;function nY.HUDPrologue(jD)if not cQ then iH=af;iI=ag;iJ=ah else iH=ac;iI=ad;iJ=ae end;iK=[[rgb(]]..bI(iH+0.6)..","..bI(iI+0.6)..","..bI(iJ+0.6)..[[)]]iL=[[rgb(]]..bI(iH*0.8+0.5)..","..bI(iI*0.8+0.5)..","..bI(iJ*0.8+0.5)..[[)]]local n_=iK;local o0=iL;local o1=[[rgb(]]..bI(iH*0.4+0.5)..","..bI(iI*0.4+0.5)..","..bI(iJ*0.4+0.5)..[[)]]local o2=iK;local o3=iL;local o4=o1;if iU()and not m then n_=[[rgb(]]..bI(iH*0.5+0.5)..","..bI(iI*0.5+0.5)..","..bI(iJ*0.5+0.5)..[[)]]o0=[[rgb(]]..bI(iH*0.3+0.5)..","..bI(iI*0.3+0.5)..","..bI(iJ*0.2+0.5)..[[)]]o1=[[rgb(]]..bI(iH*0.2+0.5)..","..bI(iI*0.2+0.5)..","..bI(iJ*0.2+0.5)..[[)]]end;local lz=iS;local lA=iT;jD[#jD+1]=df([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],n_,n_,n_,o2,o2,o0,o0,o3,o3,o0,n_,o1,o3,n_,n_,o1,o1,o4,o1,ce,cf,o0,o0,o0,o0,o0,o2,o0,o3,o4,o3,o3,o4)if not nZ then nZ=df([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lz(630),lA(0),lz(675),lA(45),lz(960),lA(55),lz(1245),lA(45),lz(1290),lA(0),lz(1000),lA(105),lz(1040),lA(59),lz(1250),lA(51),lz(1300),lA(0),lz(1920),lA(0),lz(1920),lA(20),lz(1400),lA(20),lz(1300),lA(105),lz(920),lA(105),lz(880),lA(59),lz(670),lA(51),lz(620),lA(0),lz(0),lA(0),lz(0),lA(20),lz(520),lA(20),lz(620),lA(105),lz(890),lA(59),lz(960),lA(62),lz(1030),lA(59),lz(985),lA(112),lz(1150),lA(112),lz(1100),lA(152),lz(820),lA(152),lz(780),lA(112),lz(935),lA(112),lz(890),lA(59),lz(960),lA(62),lz(1030),lA(59),lz(985),lA(112),lz(1150),lA(112),lz(1100),lA(152),lz(820),lA(152),lz(780),lA(112),lz(935),lA(112))end;if w and I then jD[#jD+1]=nZ end;return jD end;function nY.DrawVerticalSpeed(jD,dZ)jC(jD,dZ)end;function nY.UpdateHud(jD)local ks=cN;local o5=cO;local jK=o5;local j_=ks;local kK=bI(c.getThrottle())local kP=cG*3.6;local kL=c.getAxisCommandValue(0)local o6=iS(1770)local o7=iT(310)if t and cM then kL=bL;kK=bL*100 end;local iW=iV()local jL="ROLL"if kK==nil then kK=0 end;if not cT then if cG>5 then ks=kr(cE)o5=kt(cE)else ks=0;o5=0 end;jL="YAW"end;if cR>50000 and not c9 then local o8;o8=io(cR)jD[#jD+1]=gJ(o6,o7,"PvP Boundary: "..o8,"pbright txtbig txtmid")end;jD[#jD+1]=iO;jD[#jD+1]=hV;if iC~=""then jD[#jD+1]=iC end;if iX~=""then jD[#jD+1]=iX end;if iY~=""then jD[#jD+1]=iY end;jC(jD,cb)if ii()==0 or l then if not iU()or m then if cT then jJ(jD,ai,aj,jK,jL,cT)jZ(jD,j_,jK,ai,aj,cT,bI(kt(cE)),cG)else jJ(jD,ai,aj,o5,jL,cT)jZ(jD,ks,o5,ai,aj,cT,bI(o5),cG)end;k5(jD,cb,cT)ku(jD,cE,cG,ai,aj)end end;kJ(jD,iW,kK,kL)kO(jD,kP)kS(jD)lT(jD)if not iA and bW then lL(jD)end;return jD end;function nY.HUDEpilogue(jD)jD[#jD+1]="</svg>"return jD end;function nY.ExtraData(jD)local o9=iS(1240)local oa=iT(55)local ob=oa+10;local oc;local lz=iS;local lA=iT;local od=0;local iW=iV()if aY then iW=iW.."-VERTICAL"end;if E and not b5 and not b4 and cG>20 then iW=iW.."-COLLISION ON"end;if bA~="Off"then iW="("..bA..")-"..iW end;if b2 then iW="TB-"..iW end;if not bz then iW=iW.."-DeCoupled"end;local oe=lA(99)local of=lA(80)local og=lA(85)local oh=lA(31)local oi=0;local oj=0;local ok=cc>1000000 and fR(cc/1000000,2).."kT"or fR(cc/1000,2).."T"if c9 then od=bs else od=bq end;local ol,om=ck.computeDistanceAndTime(cG,0,cc,0,0,od)if ol<0 then ol=0 end;od=fR(od/(cc*is),2).."g"local on=d:maxForceForward()oc=b.g()if oc>0.1 then oj=cc*oc;oj=fR(oj/(cc*is),2).."g"oi=0.5*on/oc;oi=oi>1000000 and fR(oi/1000000,2).."kT"or fR(oi/1000,2).."T"end;on=fR(on/(cc*is),2).."g"local oo=vec3(b.getWorldAcceleration()):len()/9.80665;oc=b.g()jD[#jD+1]=[[<g class="dim txt txtend size14">]]if ii()==1 and not l then o9=iS(1120)oa=iT(55)ob=oa+10 elseif c9 and I then local op=iS(770)jD[#jD+1]=gJ(lz(895),oe,"ATMO","")jD[#jD+1]=df([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lz(895),og,lz(-80))jD[#jD+1]=gJ(lz(815),of,df("%.1f%%",ca*100),"txtstart size20")end;if I then jD[#jD+1]=gJ(lz(1025),oe,"GRAVITY","txtstart")jD[#jD+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(1025),og,lz(80))jD[#jD+1]=gJ(lz(1105),of,df("%.2fg",oc/9.80665),"size20")jD[#jD+1]=gJ(lz(1125),oe,"ACCEL","txtstart")jD[#jD+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(1125),og,lz(80))jD[#jD+1]=gJ(lz(1205),of,df("%.2fg",oo),"size20")jD[#jD+1]=gJ(lz(695),oe,"BRK TIME","")jD[#jD+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(695),og,lz(-80))jD[#jD+1]=gJ(lz(615),of,df("%s",ip(om)),"txtstart size20")jD[#jD+1]=gJ(lz(635),lA(45),"TRIP","")jD[#jD+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(635),lA(31),lz(-90))if lt then jD[#jD+1]=gJ(lz(545),lA(26),df("%s",ip(lt)),"txtstart size20")end;jD[#jD+1]=gJ(lz(795),oe,"BRK DIST","")jD[#jD+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(795),og,lz(-80))jD[#jD+1]=gJ(lz(715),of,df("%s",io(ol)),"txtstart size20")jD[#jD+1]=gJ(lz(1285),lA(45),"MASS","txtstart")jD[#jD+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(1285),lA(31),lz(90))jD[#jD+1]=gJ(lz(1375),lA(26),df("%s",ok),"size20")jD[#jD+1]=gJ(lz(1220),oe,"THRUST","txtstart")jD[#jD+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lz(1220),og,lz(80))jD[#jD+1]=gJ(lz(1300),of,df("%s",on),"size20")jD[#jD+1]=gJ(iS(960),iT(175),iW,"pbright txtbig txtmid size20")end;jD[#jD+1]="</g>"end;local oq=1-(a5*0.05+a6*0.05)function nY.FuelUsed(os)local ot;if os=="atmofueltank"then ot=df("Atmo Fuel Used: %.1f L",je[os]/(4*oq))elseif os=="spacefueltank"then ot=df("Space Fuel Used: %.1f L",je[os]/(6*oq))else ot=df("Rocket Fuel Used: %.1f L",je[os]/(0.8*oq))end;return ot end;function nY.DrawOdometer(jD,iM,bl,iN)if bF~="INFO"then return jD end;local oc;local oi=0;local oj=0;local od=0;local ok=cc>1000000 and fR(cc/1000000,2).." kTons"or fR(cc/1000,2).." Tons"if c9 then od=bs else od=bq end;local ol,om=ck.computeDistanceAndTime(cG,0,cc,0,0,od)od=fR(od/(cc*is),2).." g"local on=d:maxForceForward()oc=b.g()if oc>0.1 then oj=cc*oc;oj=fR(oj/(cc*is),2).." g"oi=0.5*on/oc;oi=oi>1000000 and fR(oi/1000000,2).." kTons"or fR(oi/1000,2).." Tons"end;on=fR(on/(cc*is),2).." g"if ii()==0 or l then local ou=iS(ay+10)local ov=iT(az+20)local ow=iS(ay+10+ax/1.25)local ni=25;jD[#jD+1]="<g class='txtstart size14 bright'>"jD[#jD+1]=gJ(ou,ov,df("BrkTime: %s",ip(om)))jD[#jD+1]=gJ(ow,ov,df("Trip: %.2f km",iM))jD[#jD+1]=gJ(ou,ov+ni,df("Lifetime: %.2f kSU",bl/200000))jD[#jD+1]=gJ(ow,ov+ni,df("BrkDist: %s",io(ol)))jD[#jD+1]=gJ(ou,ov+ni*2,"Trip Time: "..ip(iN))jD[#jD+1]=gJ(ow,ov+ni*2,"Total Time: "..ip(bm))jD[#jD+1]=gJ(ou,ov+ni*3,df("Mass: %s",ok))jD[#jD+1]=gJ(ow,ov+ni*3,df("Max Brake: %s",od))jD[#jD+1]=gJ(ou,ov+ni*4,df("Max Thrust: %s",on))if oc>0.1 then jD[#jD+1]=gJ(ow,ov+ni*4,df("Max Thrust Mass: %s",oi))jD[#jD+1]=gJ(ou,ov+ni*5,df("Req Thrust: %s",oj))else jD[#jD+1]=gJ(ow,ov+ni*4,"Max Mass: n/a")jD[#jD+1]=gJ(ou,ov+ni*5,"Req Thrust: n/a")end;jD[#jD+1]=gJ(ow,ov+ni*5,cm.FuelUsed("atmofueltank"))jD[#jD+1]=gJ(ou,ov+ni*6,cm.FuelUsed("spacefueltank"))jD[#jD+1]=gJ(ow,ov+ni*6,cm.FuelUsed("rocketfueltank"))jD[#jD+1]=gJ(ou,ov+ni*7,df("Set Max Speed: %s",bI(_*3.6+0.5)))jD[#jD+1]=gJ(ow,ov+ni*7,df("Actual Max Speed: %s",bI(da*3.6+0.5)))end;jD[#jD+1]="</g></g>"return jD end;function nY.DrawWarnings(jD)return kS(jD)end;function nY.DisplayOrbitScreen(jD)return lT(jD)end;function nY.DisplayMessage(jD,le)if le~="empty"then local hl=310;for ln in string.gmatch(le,"([^\n]+)")do hl=hl+35;jD[#jD+1]=gJ("50%",hl,ln,"msg")end end;if bY~=0 then c.setTimer("msgTick",bY)bY=0 end end;function nY.DrawDeadZone(jD)jD[#jD+1]=df([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aw)end;function nY.UpdatePipe()if c9 then iC=""return end;n7()end;function nY.DrawSettings(jD)local hk=iS(640)local hl=iT(200)jD[#jD+1]=[[<g class="pbright txtvspd txtstart">]]local hD=0;for dG,ds in pairs(iB)do hD=hD+1;jD[#jD+1]=gJ(hk,hl,dG..": "..ds.get())hl=hl+20;if hD%12==0 then hk=hk+iS(350)hl=iT(200)end end;jD[#jD+1]=gJ(iS(640),iT(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jD[#jD+1]="</g>"return jD end;local hT=iT(15)local hS=iS(1370)local dd,ox;function nY.DrawRadarInfo()hV=cp.GetRadarHud(hS,hT,au,av)end;function nY.DrawTanks()if aq~=0 and ar~=0 then iX=gJ(aq,ar,"","txtstart pdim txtfuel")jf=ar;jg(aq,"Atmospheric ","ATMO",cg,jc,jd)jg(aq,"Space Fuel T","SPACE",ch,ja,jb)jg(aq,"Rocket Fuel ","ROCKET",ci,j8,j9)end end;function nY.DrawShield()local i1=shield.getState()==1 and"Shield Active"or"Shield Disabled"local oy=b.getPvPTimer()local oz=shield.getResistances()local oA="A: "..10+oz[1]*100 .."% / E: "..10+oz[2]*100 .."% / K:"..10+oz[3]*100 .."% / T: "..10+oz[4]*100 .."%"local hk,hl=as-60,at+30;local jv=bI(db*2.55)local jw=df("rgb(%d,%d,%d)",255-jv,jv,0)local jx=""iY=gJ(hk,hl,"","txtmid pdim txtfuel")if db<10 and i1~="Shield Disabled"then jx="red "end;oy=oy>0 and"   PvPTime: "..ip(oy)or""iY=iY..df([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hk,hl,jw,db*2,hk,hl,hk+2,hl+10,db,oy)iY=iY..gJ(hk,hl-5,i1,jx.."txtstart pbright txtbig")iY=iY..gJ(hk,hl+30,oA,jx.."txtstart pbright txtsmall")end;function nY.hudtick()if not kf then return end;local function oB(jD)local jz=bI(dg(d8/(ce/4)*255,0,255))jD[#jD+1]=df("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c2,c3,bI(iH+0.5)+jz,bI(iI+0.5)-jz,bI(iJ+0.5)-jz)end;local function oC()for dL,ds in pairs(it)do if ds.hovered then if not ds.drawCondition or ds.drawCondition(ds)then ds.toggleFunction(ds)end;ds.hovered=false end end;for dL,ds in pairs(iw)do if ds.hovered then bF=ds.label;ds.hovered=false end end end;local function oD()local function oE(oF,oG,hk,hl,nh,ni)if oF>=hk and oF<=hk+nh and oG>=hl and oG<=hl+ni then return true else return false end end;local hk=c2+ce/2;local hl=c3+cf/2;for dL,ds in pairs(it)do ds.hovered=oE(hk,hl,ds.x,ds.y,ds.width,ds.height)end;for dL,ds in pairs(iw)do ds.hovered=oE(hk,hl,ds.x,ds.y,ds.width,ds.height)end;if cW then local mX=false;for dL,ey in ipairs(nU)do if ey.hovered then mX=true;break end end;if nR.hovered then mX=true end;cW=mX else cW=nR.hovered;if not cW then cX=bj end end end;local function oH(jD)if not bF or bF==""then bF="HELP"end;if w then for dG,ds in pairs(iw)do local jx="dim brightstroke"local oI=0.2;if bF==dG then jx="pbright dimstroke"oI=0.6 end;local oJ=""if ds.hovered then oI=0.8;oJ=";stroke:white"end;jD[#jD+1]=df([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],ds.width,ds.height,ds.x,ds.y,jx,oI,oJ)jD[#jD+1]=gJ(ds.x+ds.width/2,ds.y+ds.height/2+5,ds.label,"txt txtmid pdim")end end end;local function oK(jD)local function oL(jD,oM,hover,hk,hl,fe,oN,oO,oP,oQ,oR,nV)if type(oQ)=="function"then oQ=oQ(nV)end;if type(oR)=="function"then oR=oR(nV)end;jD[#jD+1]=df("<rect x='%f' y='%f' width='%f' height='%f' fill='",hk,hl,fe,oN)if oM then jD[#jD+1]=df("%s'",oO)else jD[#jD+1]=oP end;if hover then jD[#jD+1]=df(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jD[#jD+1]=df(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fR(ac*0.5,0),fR(ad*0.5,0),fR(ae*0.5,0))end;jD[#jD+1]=" rx='5'></rect>"jD[#jD+1]=df("<text x='%f' y='%f' font-size='24' fill='",hk+fe/2,hl+oN/2+5)if oM then jD[#jD+1]="black"else jD[#jD+1]="white"end;jD[#jD+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oM then jD[#jD+1]=df("%s</text>",oQ)else jD[#jD+1]=df("%s</text>",oR)end end;local oS=df("rgb(%d,%d,%d)'",fR(ac*0.1,0),fR(ad*0.1,0),fR(ae*0.1,0))local oT=df("rgb(%d,%d,%d)",fR(ac*0.8,0),fR(ad*0.8,0),fR(ae*0.8,0))local oU=oL;for dL,ds in pairs(it)do local nm=ds.disableName;local nl=ds.enableName;if type(nm)=="function"then nm=nm(ds)end;if type(nl)=="function"then nl=nl(ds)end;if not ds.drawCondition or ds.drawCondition(ds)then oU(jD,ds.toggleVar(ds),ds.hovered,ds.x,ds.y,ds.width,ds.height,oT,oS,nm,nl,ds)end end end;local oV=fR(ce/2,0)local oW=fR(cf/2,0)local jD={}if oX then jD[#jD+1]=oX end;cm.HUDPrologue(jD)if w then cm.UpdateHud(jD)else if A then cm.DrawVerticalSpeed(jD,cb)end;cm.DrawWarnings(jD)end;if iA and iB~="none"then cm.DrawSettings(jD)end;if radar_1 then cm.DrawRadarInfo()end;cm.HUDEpilogue(jD)jD[#jD+1]=df([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ce,cf)if bX~="empty"then cm.DisplayMessage(jD,bX)end;if ii()==0 and g=="virtual joystick"then if v then cm.DrawDeadZone(jD)end end;oH(jD)if ik()==0 then if ii()==1 and bW then if not oY then oD()oK(jD)end;if not cs and not ct then local oZ=table.concat(jD,"")jD={}jD[#jD+1]=df("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jD[#jD+1]=oZ;jD[#jD+1]="</body>"cs=true;jD[#jD+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif ct then local oZ=table.concat(jD,"")jD={}jD[#jD+1]=df("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jD[#jD+1]=oZ;jD[#jD+1]="</body>"end;if not cs then jD[#jD+1]=df([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oV,oW,c2,c3)end else oC()end else if not bW and ii()==0 then oC()if d8>aw then if v then oB(jD)end end elseif bW and(not oY or not i)then oD()oK(jD)end;jD[#jD+1]=df([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oV,oW,c2,c3)end;jD[#jD+1]=[[</svg></body>]]o_=table.concat(jD,"")end;function nY.TenthTick()local function p0()local p1=a.createData;local p2=a.createWidget;p3=a.createWidgetPanel("Interplanetary Helper")p4=p2(p3,"value")p5=p1('{"label": "Target Planet", "value": "N/A", "unit":""}')fP(p5,p4)p6=p2(p3,"value")p7=p1('{"label": "distance", "value": "N/A", "unit":""}')fP(p7,p6)gi=p2(p3,"value")gh=p1('{"label": "Travel Time", "value": "N/A", "unit":""}')fP(gh,gi)gg=p2(p3,"value")gf=p1('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fP(gf,gg)gk=p2(p3,"value")gj=p1('{"label": "Target Altitude", "value": "N/A", "unit":""}')fP(gj,gk)gc=p2(p3,"value")gb=p1('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ga=p2(p3,"value")g9=p1('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g8=p2(p3,"value")g7=p1('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g6=p2(p3,"value")g5=p1('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ge=p2(p3,"value")gd=p1('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c9 then fP(gb,gc)fP(g9,ga)fP(g7,g8)fP(g5,g6)fP(gd,ge)end end;local function p8()gI(p3)p3=nil end;cm.DrawTanks()if shield then cm.DrawShield()end;if bh~="None"then if p3==nil then p0()end;if bh~=nil then local my;local p9=g1~=nil;local pa=0.5*bs/c1:getGravity(c1.center+vec3(0,0,1)*c1.radius):len()pa=pa>1000000 and fR(pa/1000000,2).." kTons"or fR(pa/1000,2).." Tons"fO(p5,'{"label": "Target", "value": "'..bh..'", "unit":""}')if p9 and not b1 then my=(cJ-g1.position):len()else my=(bi-cJ):len()end;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(cG)iE,iF=co.GetAutopilotBrakeDistanceAndTime(_)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(cG)iE,iF=co.GetAutopilotTBBrakeDistanceAndTime(_)end;local le=io(my)fO(p7,'{"label": "distance", "value": "'..le..'"}')fO(gh,'{"label": "Travel Time", "value": "'..ip(lt)..'", "unit":""}')le=io(b_)fO(gb,'{"label": "Cur Brake distance", "value": "'..le..'"}')fO(g9,'{"label": "Cur Brake Time", "value": "'..ip(c0)..'", "unit":""}')le=io(iE)fO(g7,'{"label": "Max Brake distance", "value": "'..le..'"}')fO(g5,'{"label": "Max Brake Time", "value": "'..ip(iF)..'", "unit":""}')fO(gf,'{"label": "Max Brake Mass", "value": "'..df("%s",pa)..'", "unit":""}')le=io(gl)fO(gj,'{"label": "Target Orbit", "value": "'..le..'"}')if c9 and not pb then a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)pb=true;if not cM and t and(b3 or b6 or c7)then co.cmdThrottle(1)aZ=false;bP=false end end;if not c9 and pb then if fO(g5,g6)==1 then fP(g5,g6)end;if fO(g7,g8)==1 then fP(g7,g8)end;if fO(g9,ga)==1 then fP(g9,ga)end;if fO(gb,gc)==1 then fP(gb,gc)end;if fO(gd,ge)==1 then fP(gd,ge)end;pb=false end end else p8()end;if warpdrive~=nil then local pc=ig(warpdrive.getData())if pc.destination~="Unknown"and pc.distance>400000 then if not iR then warpdrive.show()iR=true end elseif iR then warpdrive.hide()iR=false end end end;function nY.OneSecondTick()local function pd()local jq=bH()local kP=cG;local pe=jq-iP;if kP>1.38889 then kP=kP/1000;local pf=kP*(jq-iP)bl=bl+pf;iM=iM+pf end;iN=iN+pe;bm=bm+pe;iP=jq end;local function pg(jD)local ph=0;local pi=ir;local pj=0;local pk=0;local pl=0;local jv=0;local jw=""local pm=b.getElementHitPointsById;local pn=b.getElementMaxHitPointsById;local po={}for dG in pairs(iq)do local pp=0;local pq=0;pq=pn(iq[dG])pp=pm(iq[dG])pj=pj+pp;if pp+1<pq then if pp==0 then pl=pl+1 else pk=pk+1 end;if iQ and#po==0 then fT=vec3(b.getElementPositionById(iq[dG]))local hk=fT.x;local hl=fT.y;local hm=fT.z;table.insert(po,b.spawnArrowSticker(hk,hl,hm+1,"down"))table.insert(po,b.spawnArrowSticker(hk,hl,hm+1,"down"))b.rotateSticker(po[2],0,0,90)table.insert(po,b.spawnArrowSticker(hk+1,hl,hm,"north"))table.insert(po,b.spawnArrowSticker(hk+1,hl,hm,"north"))b.rotateSticker(po[4],90,90,0)table.insert(po,b.spawnArrowSticker(hk-1,hl,hm,"south"))table.insert(po,b.spawnArrowSticker(hk-1,hl,hm,"south"))b.rotateSticker(po[6],90,-90,0)table.insert(po,b.spawnArrowSticker(hk,hl-1,hm,"east"))table.insert(po,b.spawnArrowSticker(hk,hl-1,hm,"east"))b.rotateSticker(po[8],90,0,90)table.insert(po,b.spawnArrowSticker(hk,hl+1,hm,"west"))table.insert(po,b.spawnArrowSticker(hk,hl+1,hm,"west"))b.rotateSticker(po[10],-90,0,90)table.insert(po,iq[dG])end elseif iQ and#po>0 and po[11]==iq[dG]then for jp in pairs(po)do b.deleteSticker(po[jp])end;po={}end end;ph=fR(pj/pi*100,2)if pl>0 or pk>0 then jD[#jD+1]=gJ(0,0,"","pbright txt")jv=bI(ph*2.55)jw=df("rgb(%d,%d,%d)",255-jv,jv,0)jD[#jD+1]=gJ("50%",1035,"Elemental Integrity: "..ph.."%","txtbig txtmid","fill:"..jw)if pl>0 then jD[#jD+1]=gJ("50%",1055,"Disabled Modules: "..pl.." Damaged Modules: "..pk,"txtbig txtmid","fill:"..jw)elseif pk>0 then jD[#jD+1]=gJ("50%",1055,"Damaged Modules: "..pk,"txtbig txtmid","fill:"..jw)end end end;local function pr()if ie then if iG==nil and(d3~=nil or bk)then _autoconf.displayCategoryPanel(ie,weapon_size,"Weapons","weapon",true)iG=_autoconf.panels[_autoconf.panels_size]elseif iG~=nil and d3==nil and not bk then gI(iG)iG=nil end end end;cY=b.getPlayersOnBoard()cZ=b.getDockedConstructs()local jD={}pd()if s then pg(jD)end;pr()cm.UpdatePipe()cm.ExtraData(jD)iO=table.concat(jD,"")end;function nY.AnimateTick()ct=true;cs=false;c2=0;c3=0;c.stopTimer("animateTick")end;function nY.MsgTick()local jD={}cm.DisplayMessage(jD,"empty")bX="empty"c.stopTimer("msgTick")bY=3 end;function nY.ButtonSetup()nx()nC()it=iu end;if ps then for dG,ds in pairs(ps)do nY[dG]=ds end end;return nY end;local function pt(d,b,c,a,e,vBooster,hover,pu,antigrav,warpdrive,dbHud_1,radar_1,eU,bI,bJ,ii,eP,bH,dg,ij,fO,ik,di,fR,fQ,il,dj,io,ip,pv,ig,df,fP)local pw={}local px=false;local py=0;local pz=0;local pA=0;local pB=bH()local pC=0;local pD=0;local pE=0;local pF=0;local pG=false;local pH=false;local pI=false;local pJ=nil;local pK=0;local iD=55;local pL=nil;local pM=false;local pN=false;local pO=false;local pP=0;local pQ=0;local pR=0;local pS=0;local pT=0;local pU={VectorToTarget=false}local pV=vec3(b.getConstructWorldOrientationUp())local pW=nil;local pX=0;local pY=-1;local pZ=-1;local p_=false;local q0=false;local q1=0;local q2=false;local q3=false;local q4=false;local q5=false;local q6=""local q7=false;local q8=false;local q9=""local qa=false;local qb=0;local qc=vec3({13771471,7435803,-128971})local qd=18000000;local qe=500000;local qf,qg=math.huge;local qh;local function qi(qj)qf=vec3(qj):dist(qc)if qf<qd then return true,eU(qf-qd)end;qg=vec3(qj):dist(vec3(kf.center))if qg<qe then qh=true else qh=false end;if eU(qg-qe)<eU(qf-qd)then return qh,eU(qg-qe)else return qh,eU(qf-qd)end end;local function qk(fl)local ql=bd;if not b1 then ql=0 end;local qm=bq;if c9 then if bs and bs>0 then qm=bs else return 0,0 end end;return ck.computeDistanceAndTime(fl,ql,cc,0,0,qm-bf*cc)end;local function qn(fl)local ql=bd;if not b1 then ql=0 end;return ck.computeDistanceAndTime(fl,ql,cc,d:maxForceForward(),a1,bq-bf*cc)end;local function qo(qp,qq,qr)qq=qq:project_on_plane(qp)qr=qr:project_on_plane(qp)return eP(qq:cross(qr):dot(qp),qq:dot(qr))end;local function qs()local function qt()local qu=-1;local qv=-1;if vBooster then qu=vBooster.getDistance()end;if hover then qv=hover.getDistance()end;if qu~=-1 and qv~=-1 then if qu<qv then return qu else return qv end elseif qu~=-1 then return qu elseif qv~=-1 then return qv else return-1 end end;local qw=qt()local qx=-1;if antigrav and antigrav.getState()==1 and not q and cG<iD then local qy=eU(cb-antigrav.getBaseAltitude())if qy<50 then return qy end end;if pu then qx=pu.getDistance()end;if qw~=-1 and qx~=-1 then if qw<qx then return qw else return qx end elseif qw~=-1 then return qw else return qx end end;local function qz(kf,eG,qA)local function qB(qC,dS)local eM=vec3(dS)if qC.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=qC.systemId},dU)end;local eN=eM-qC.center;local c4=eN:len()local dZ=c4-qC.radius;local dX=0;local dY=0;if not dj(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=math.deg(dX),longitude=math.deg(dY),altitude=dZ,id=qC.id,systemId=qC.systemId},dU)end;local qD=qB(kf,eG)qD="::pos{"..qD.systemId..","..qD.id..","..qD.latitude..","..qD.longitude..","..qD.altitude.."}"if qA then return qD else q4=qD;return true end end;local function qE(qF,qG,qH)local function qI(qF,ep)qF=vec3(qF)ep=vec3(ep):normalize()local dB=qF*ep;return dB.x+dB.y+dB.z end;local qJ=0.001;local qK=1;if not c9 or not cv or c8~=-1 or cG<iD then if qH==nil then qH=aQ end;if qG==nil then qG=qJ end;qF=vec3(qF):normalize()local qL=vec3()-qF;local qM=-qI(qL,b.getConstructWorldOrientationRight())*qK;local qN=-qI(qL,b.getConstructWorldOrientationUp())*qK;if pz==0 then pz=qM/2 end;if pA==0 then pA=qN/2 end;if eU(qM)<0.1 then pQ=pQ-qM*2 else pQ=pQ-(qM+(qM-pz)*qH)end;if eU(qN)<0.1 then pP=pP+qN*2 else pP=pP+qN+(qN-pA)*qH end;pz=qM;pA=qN;if eU(qM)<qG and eU(qN)<qG then return true end;return false elseif cv and c8==-1 then qF=cF;if qH==nil then qH=aQ end;if qG==nil then qG=qJ end;qF=vec3(qF):normalize()local qL=cC-qF;local qM=-qI(qL,b.getConstructWorldOrientationRight())*qK;local qN=-qI(qL,b.getConstructWorldOrientationUp())*qK;if pz==0 then pz=qM/2 end;if pA==0 then pA=qN/2 end;if eU(qM)<0.1 then pQ=pQ-qM*5 else pQ=pQ-(qM+(qM-pz)*qH)end;if eU(qN)<0.1 then pP=pP+qN*5 else pP=pP+qN+(qN-pA)*qH end;pz=qM;pA=qN;if eU(qM)<qG and eU(qN)<qG then return true end;return false end end;function pw.clearAll()b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"a_=false;b0=false;cS=nil;b3=false;b6=false;b4=false;b5=false;b7=false;bV=false;pN=false;c5=false;c6=false;pO=false;cu=p;bo=false;b2=false;cd=false;br=nil;bx=false;d6=false;d7=nil end;function pw.GetAutopilotBrakeDistanceAndTime(fl)return qk(fl)end;function pw.GetAutopilotTBBrakeDistanceAndTime(fl)return qn(fl)end;function pw.showWayPoint(kf,eG,qA)return qz(kf,eG,qA)end;function pw.APTick()local qO=a.getMouseWheel()if qO>0 then co.changeSpd()elseif qO<0 then co.changeSpd(true)else pM=true end;q1=ik()if q4 then a.setWaypoint(q4)q4=false end;if q7 then antigrav.setBaseAltitude(q7)q7=false end;if q5 then fO(q5,q6)q5=false;q6=""end;if pZ~=-1 then co.cmdCruise(pZ,p_)p_=false;pZ=-1 end;if pW~=nil then if ij:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ij:getTargetSpeed(axisCommandId.longitudinal)~=pW then ij:setTargetSpeedCommand(axisCommandId.longitudinal,pW)else pW=nil end end;if pY~=-1 then co.cmdThrottle(pY,p_)p_=false;pY=-1 end;if q0 then cq.landingGear()q0=false end;if q8 then co.ToggleAutopilot()end end;function pw.ToggleIntoOrbit()cz=false;pE=nil;pF=nil;pK=0;if not c9 then if bx then fQ("orOff","AP")bx=false;pG=false;pJ=nil;cu=p;if b3 then b3=false;b5=false end;pU.VectorToTarget=false;pU.AutopilotAlign=false;pI=false elseif cT then fQ("orOn","AP")bx=true;cu=true;if pJ==nil then pJ=kf end;if b3 then b3=false;b5=false end else bX="Unable to engage auto-orbit, not near a planet"end else bx=false;pG=false;pJ=nil;cu=p;if b3 then b3=false end;pU.VectorToTarget=false;pU.AutopilotAlign=false;pI=false end end;function pw.ToggleVerticalTakeoff()b3=false;if b7 then lm=true;b6=false;b5=false;b4=true;cu=true;bU=0;if c9 and c8==-1 then b4=false;b3=true;bU=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)pZ=bI(cw)end else cz=false;bk=false;d.control.retractLandingGears()ij:setTargetGroundAltitude(X)aZ="VTO Takeoff"end;b7=not b7 end;function pw.checkLOS(qF)local lr,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,qF,function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local ls=eE;if eF~=nil and eE~=nil then ls=math.min(eF,eE)end;if ls~=nil then return lr,ls else return nil,nil end end;function pw.ToggleAutopilot()local function qP(bv)cU=false;bo=not bo;if bo then b2=false;if not b3 and not bv then co.ToggleAltitudeHold()end end;lv="Proceeding to Waypoint"end;local function qQ(gu)if gu then for K,dG in pairs(cP)do if dG.name and dG.name==gu then return K end end else return 0 end end;local qR=false;if bK-pD<1.5 and c9 then if not cB then if c9 then b8=kf.spaceEngineMinAltitude-0.01*kf.noAtmosphericDensityAltitude;fQ("11","EP")pD=-1;if b1 or bo or bx then return end else bX="No space engines detected, Orbital Hop not supported"return end elseif kf.hasAtmosphere then if c9 then b8=kf.noAtmosphericDensityAltitude+T;fQ("orH","OH")end;pD=-1;if b1 or bo or bx then return end end else pD=bK end;qS=false;if(bj>0 or#bD>0)and not b1 and not bo and not c6 and not bx then if 0.5*d:maxForceForward()/b.g()<cc then bX="WARNING: Heavy Loads may affect autopilot performance."bY=5 end;if#bD>0 and not c7 then bj=qQ(bD[1])cn.UpdateAutopilotTarget()bX="Route Autopilot in Progress"local qL=g1.position-cJ;local qT=qL:project_on_plane(cH):len()if qT>50000 and g1.planetname==kf.name then qR=true end end;cn.UpdateAutopilotTarget()co.showWayPoint(c1,bi)if g1~=nil then if g1.agg and not q and antigrav then if not cL then co.ToggleAntigrav()end;bt=g1.agg end;br=nil;bv=g1.planetname=="Space"if bv then fQ("apSpc","AP")if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end elseif kf.name==g1.planetname then lm=true;if c9 then if not bo then fQ("vtt","AP")qP(bv)if qR then b8=kf.noAtmosphericDensityAltitude+T end end else fQ("apOn","AP")if not(c1.name==kf.name and cb<gl*1.5)then cz=false;b1=true elseif not c9 then if bx then co.ToggleIntoOrbit()end;cy=kf.noAtmosphericDensityAltitude+T;pI=true;pU.AutopilotAlign=true;pU.VectorToTarget=true;pG=false;if not bx then co.ToggleIntoOrbit()end end end else fQ("apP","AP")a_=false;b0=false;if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end end elseif not c9 then if g1==nil and(c1.name==kf.name and cT)and not bx then qU=false;cz=false;pG=false;co.ToggleIntoOrbit()else fQ("apP","AP")b1=true;a_=false;b0=false;ba=false;bV=false;b3=false;b4=false;b6=false;b5=false;pN=false;br=nil;qU=false end else fQ("apP","AP")c6=true;co.ToggleAltitudeHold()end;q8=false else fQ("apOff","AP")co.ResetAutopilots(1)if q8==2 then q8=true end end end;function pw.routeWP(qV,qW,qX)if qX then if qX==1 then bD={}bD=il(bD,bC)if#bD>0 then bX="Route Loaded"else bX="No Saved Route found on Databank"end;return bD else bC={}bC=il(bC,bD)bX="Route Saved"pv()return end end;if qV then return bD end;if qW then bD={}bX="Current Route Cleared"else bD[#bD+1]=g1.name;bX="Added "..g1.name.." to route. "end;return bD end;function pw.cmdThrottle(dH,qY)if ij:getAxisCommandType(0)~=axisCommandType.byThrottle and not qY then d.control.cancelCurrentControlMasterMode()end;ij:setThrottleCommand(axisCommandId.longitudinal,dH)bL=dg(fR(dH*100,0)/100,-1,1)pW=nil end;function pw.cmdCruise(dH,qY)if ij:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not qY then d.control.cancelCurrentControlMasterMode()end;ij:setTargetSpeedCommand(axisCommandId.longitudinal,dH)pW=dH end;function pw.ToggleLockPitch()if br==nil then fQ("lkPOn","LP")if not bW then br=cN else br=Q end;b5=false;b3=false;b4=false else fQ("lkPOff","LP")br=nil end end;function pw.ToggleAltitudeHold()if bK-pC<1.5 then if kf.hasAtmosphere then if c9 then b8=kf.spaceEngineMinAltitude-0.01*kf.noAtmosphericDensityAltitude;fQ("11","EP")else if cT then b8=kf.noAtmosphericDensityAltitude+T;cy=b8;pI=true;if not bx then co.ToggleIntoOrbit()end;pG=true end end;pC=-1;if b3 or bx or b7 then return end end else pC=bK end;if cT and not c9 then cy=cb;pI=true;pG=true;co.ToggleIntoOrbit()if bx then pC=bK else pC=0 end;return end;b3=not b3;b4=false;b6=false;if b3 then b1=false;b0=false;a_=false;bV=false;cu=true;br=nil;cz=false;if c8~=-1 and cG<20 then if bk then cq.landingGear()end;fQ("lfs","LS")b5=true;if pC>-1 then b8=cb+W end;aZ="ATO Hold"ij:setTargetGroundAltitude(X)if aY and cK then co.ToggleVerticalTakeoff()end else fQ("altOn","AH")b5=false;if pC>-1 then if cT then b8=cb end end;if b7 then co.ToggleVerticalTakeoff()end end;if cL and not q then local qZ=antigrav.getBaseAltitude()if bo and g1.agg and g1.agg>cb then b8=g1.agg elseif b5 then b8=qZ end;if eU(cb-qZ)<100 and cG<20 then b8=qZ;aZ="AGG Hold"pY=0 end end;if c6 then b8=200000 end else fQ("altOff","AH")if bx then co.ToggleIntoOrbit()end;if b7 then co.ToggleVerticalTakeoff()end;cu=p;b5=false;bo=false;pC=0 end end;function pw.ResetAutopilots(pw)if pw then c6=false;b1=false;ba=false;pN=false;b8=cb;qS=false;d6=false;be="Aligning"end;bo=false;b5=false;b6=false;b0=false;b4=false;d7=nil;q_=false;cS=nil;d6=false;if not cL then b3=false;br=nil end;if b7 then co.ToggleVerticalTakeoff()end;if bx then co.ToggleIntoOrbit()end;cu=p;c5=false;c7=false;bU=0 end;function pw.BrakeToggle(r0)if not aZ then if r0 then aZ=r0 else aZ=true end else aZ=false end;if b4 then b4=false;cu=p;d6=false end;if aZ then fQ("bkOn","B",1)co.ResetAutopilots()else fQ("bkOff","B",1)end end;function pw.BeginReentry()if b6 then bX="Re-Entry cancelled"fQ("reOff","RE")b6=false;cu=p;b3=false elseif not kf.hasAtmosphere then bX="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bY=5 elseif not pO then b6=true;if ij:getAxisCommandType(0)~=r1.cruise then d.control.cancelCurrentControlMasterMode()end;cu=true;aZ=false;bX="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cw;fQ("par","RE")else b6=true;b3=true;cu=true;aZ=false;b8=kf.surfaceMaxAltitude+Z;if b8>kf.spaceEngineMinAltitude then b8=kf.spaceEngineMinAltitude-0.01*kf.noAtmosphericDensityAltitude end;local r2=io(b8)bX="Beginning Re-entry.  Target speed: "..cw.." Target Altitude: "..r2;fQ("glide","RE")pZ=bI(cw)end;b5=false end;function pw.ToggleAntigrav()if antigrav and not q then if cL then fQ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bt==nil then bt=cb end;if bt<1000 then bt=1000 end;fQ("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pw.changeSpd(r3)local r4=1;if r3 then r4=-1 end;if not bW then if t and not oY and pM then local r5=bL;bL=fR(dg(bL+r4*aC/100,-1,1),2)if bL>=0 and r5<0 then bL=0;pM=false end elseif oY then if c9 or b6 then cw=dg(cw+r4*aC,0,U)elseif b1 then _=dg(_+r4*aC/3.6*100,0,da-0.2)end else ij:updateCommandFromActionStart(axisCommandId.longitudinal,r4*aC/10)end else if b1 or bo or c6 or bx then cX=cX+1*r4*-1;if cX>#cP then cX=1 end;if cX<1 then cX=#cP end else if not r3 then r4=1 else r4=nil end;cn.adjustAutopilotTargetIndex(r4)end end end;function pw.TenthTick()local function r6()if not b1 then if g1==nil or g1.planetname~=kf.name then r7=(c1.center-cJ):len()else r7=(g1.position-cJ):len()end end;local fl=cG;local r8=c.getThrottle()/100;if t then r8=bL end;local r9,ra=ck.computeDistanceAndTime(cG,_,cc,d:maxForceForward()*r8,a1,0)local b_,c0;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(_)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(_)end;local dL,rb;if not b2 and fl>0 then dL,rb=co.GetAutopilotBrakeDistanceAndTime(fl)else dL,rb=co.GetAutopilotTBBrakeDistanceAndTime(fl)end;local rc=0;local rd=0;if bc or not b1 and fl>5 then rd=ck.computeTravelTime(fl,0,r7)elseif b_+r9<r7 then rc=r7-(b_+r9)rd=ck.computeTravelTime(8333.0556,0,rc)else local re=(r7-b_)/r9;r9=r7-b_;ra=ra*re end;if g1~=nil and g1.planetname==kf.name and not b1 then return rd elseif bb then return rb elseif bc then return rd+rb else return ra+c0+rd end end;local function rf(oc,rg)if oc==nil then oc=b.g()end;oc=fR(oc,5)if rg~=nil and rg or(pL==nil or pL~=oc)then local fl=cE:len()local rh=ig(c.getData()).maxBrake;if rh~=nil and rh>0 and c9 then rh=rh/dg(fl/100,0.1,1)rh=rh/ca;if ca>0.10 then if bs then bs=(bs+rh)/2 else bs=rh end end end;if rh~=nil and rh>0 then bq=rh end;pL=oc end end;cQ,cR=qi(cJ)da=b.getMaxSpeed()if bh~="None"and(c1 or g1)then lt=r6()end;rf(nil,true)end;function pw.SatNavTick()if not r then return end;q9=dbHud_1.getStringValue("SPBAutopilotTargetName")if q9~=nil and q9~=""and q9~="SatNavNotChanged"then local dB=ig(dbHud_1.getStringValue("SavedLocations"))if dB~=nil then bn=dB;local gs=-1;local gy;for dG,ds in pairs(bn)do if ds.name and ds.name=="SatNav Location"then gs=dG;break end end;if gs~=-1 then gy=bn[gs]gs=-1;for dG,ds in pairs(e[0])do if ds.name and ds.name=="SatNav Location"then gs=dG;break end end;if gs>-1 then e[0][gs]=gy end;cn.UpdateAtlasLocationsList()bX=gy.name.." position updated"end end;for K=1,#cP do if cP[K].name==q9 then bj=K;a.print("Index = "..bj.." "..cP[K].name)cn.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pw.onFlush()local function ri(rj,rk)local rl=vec3()local rm=vec3()if rj==axisCommandId.longitudinal then rl=vec3(b.getConstructOrientationForward())rm=cC elseif rj==axisCommandId.vertical then rl=vec3(b.getConstructOrientationUp())rm=pV elseif rj==axisCommandId.lateral then rl=vec3(b.getConstructOrientationRight())rm=cD else return vec3()end;local rn=vec3(b.getWorldGravity())local ro=rn:dot(rm)local rp=vec3(b.getWorldAirFrictionAcceleration())local rq=rp:dot(rm)local rr=cE:dot(rl)local rs=rk*constants.kph2m;if rt==nil then rt=pid.new(10,0,10.0)end;rt:inject(rs-rr)local ru=rt:get()local rv=(ru-rq-ro)*rm;return rv end;local function rw(rj,rk)local rl=vec3()local rm=vec3()if rj==axisCommandId.longitudinal then rl=vec3(b.getConstructOrientationForward())rm=cC elseif rj==axisCommandId.vertical then rl=vec3(b.getConstructOrientationUp())rm=pV elseif rj==axisCommandId.lateral then rl=vec3(b.getConstructOrientationRight())rm=cD else return vec3()end;local rn=vec3(b.getWorldGravity())local ro=rn:dot(rm)local rp=vec3(b.getWorldAirFrictionAcceleration())local rq=rp:dot(rm)local rr=cE:dot(rl)local rs=rk*constants.kph2m;if rx==nil then rx=pid.new(10,0,10.0)end;rx:inject(rs-rr)local ru=rx:get()local rv=(ru-rq-ro)*rm;return rv end;local function ry(rz,jG,fY)local rA=rz:cross(fY):normalize_inplace()local ks=math.acos(dg(rA:dot(-jG),-1,1))*constants.rad2deg;if rA:cross(-jG):dot(fY)<0 then ks=-ks end;return ks end;local function rB()if cV and not b4 then local en=cV[1]local hJ,hK=cV[2],cV[3]local rC=math.min(hJ,hK or hJ)local rD=rC/cG;local rE=b5 and(cG<42 or c8~=-1)local rF=b3 or bo or br or b1;if rF and not rE and(b_*1.5>rC or rD<1)then aZ="Collision"bD={}pY=0;if b3 then co.ToggleAltitudeHold()end;if br then co.ToggleLockPitch()end;bX="Autopilot Cancelled due to possible collision"a.print(en.name.." COLLISION "..ip(rD).." / "..io(rC,2))co.ResetAutopilots(1)lm=true;if c9 then b4=true end;cu=true end;if rD<11 then cU=en.name.." COLLISION "..ip(rD).." / "..io(rC,2)else cU=en.name.." collision "..ip(rD)end;if rD<6 then fQ("alarm","AL",2)end else cU=false end end;if antigrav and not q then if not cL and antigrav.getBaseAltitude()~=bt then q7=bt end end;if d9 then d:setEngineForceCommand('hover',vec3(),1)d9=false end;cM=ij:getAxisCommandType(0)==axisCommandType.byThrottle;aM=math.max(aM,0.01)aN=math.max(aN,0.01)aH=math.max(aH,0.01)aL=math.max(aL,0.01)aO=math.max(aO,0.01)aP=math.max(aP,0.01)aG=math.max(aG,0.01)local rG=dg(bR+pP+a.getControlDeviceForwardInput(),-1,1)local rH=dg(bS+pR+a.getControlDeviceYawInput(),-1,1)local rI=dg(bT+pQ-a.getControlDeviceLeftRightInput(),-1,1)local rJ=aZ and 1 or 0;cH=vec3(b.getWorldVertical())if cH==nil or cH:len()==0 then cH=(kf.center-cJ):normalize()end;pV=vec3(b.getConstructWorldOrientationUp())cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cF=vec3(b.getWorldVelocity())cE=vec3(b.getVelocity())cJ=vec3(b.getConstructWorldPos())cc=b.getConstructMass()cG=vec3(cF):len()cI=-cH:dot(cF)cO=getRoll(cH,cC,cD)local rK=cO/180*math.pi;local rL=math.cos(rK)local rM=math.sin(rK)cN=ry(cH,cC,cD*rL+pV*rM)local rN=cF:normalize()local rO=eU(cO)local rP=utils.sign(cO)local rQ=vec3(b.getWorldAngularVelocity())local rR=rG*aM*cD+rH*aH*cC+rI*aN*pV;if cu==true and cH:len()>0.01 then local rS=eU(pS-cO)if((b0 or b6 or b4 or c5 or b3 or bx)and rS>0 or c9 and rS<aI and p)and rH==0 and eU(cN)<85 then local rT=pS;local rU=aG;if not c9 then rU=rU/4;pS=0;rT=0 end;if rV==nil then rV=pid.new(rU*0.01,0,rU*0.1)end;rV:inject(rT-cO)local rW=rV:get()rR=rR+rW*cC end end;local rX=1;local rY=0;local rZ=1;bM=0;ca=bJ()c9=false or cb<kf.noAtmosphericDensityAltitude and ca>0.00001;cb=b.getAltitude()c8=qs()bK=bH()pB=bK;if bk and c8>-1 and c8-3<Y then if ij.targetGroundAltitudeActivated then ij:deactivateGroundEngineAltitudeStabilization()end end;if radar_1 then qa=not qa;if qa then cp.UpdateRadar()end;if E then rB()end end;if antigrav then cL=antigrav.getState()==1 end;local r_=1;local s0=1;local s1=bK-pB;local s2=-math.deg(qo(pV,cF,cC))local s3=math.deg(qo(cD,cF,cC))local gn=cH*-1;cv=c9 and s2<-L or s2>L or s3<-M or s3>M;local s4=a.getMouseDeltaX()local s5=a.getMouseDeltaY()if qb then local s6=bH()-qb;s4=s4*s6/0.016;s5=s5*s6/0.016 end;qb=bH()if o and not bW then s5=-s5 end;pQ=0;pR=0;pP=0;fU=cj[0]kf=fU:closestBody(b.getConstructWorldPos())s7=cl(kf)fp=s7:orbitalParameters(b.getConstructWorldPos(),cF)if cb==0 then cb=(cJ-kf.center):len()-kf.radius end;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;local oc=kf:getGravity(b.getConstructWorldPos()):len()*cc;pS=0;local s8=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if q1==0 then if ii()==1 and bW then if not cs then c2=dg(c2+s4/2,-ce/2,ce/2)c3=dg(c3+s5/2,-cf/2,cf/2)end else c2=0;c3=0 end else c2=dg(c2+s4/2,-ce/2,ce/2)c3=dg(c3+s5/2,-cf/2,cf/2)d8=di(c2*c2+c3*c3)if not bW and ii()==0 then local kB,kC=1,1;if bF=="SCOPE"then kB,kC=d0/90,d0/90 end;if g=="virtual joystick"then if d8>aw then pQ=pQ-dg(eU(c2)-aw,0,ce/2)*utils.sign(c2)*aE*kB;pP=pP-dg(eU(c3)-aw,0,cf/2)*utils.sign(c3)*aF*kC end else c2=0;c3=0;if g=="mouse"then pP=(-utils.smoothstep(s5,-100,100)+0.5)*2*r_;pQ=(-utils.smoothstep(s4,-100,100)+0.5)*2*s0 end end end end;local s9=cG>27777;if cG>V/3.6 and not c9 and not b1 and not s9 then bX="Space Speed Engine Shutoff reached"pY=0 end;if not s9 and sa then if not aZ then co.BrakeToggle()end;if b1 then co.ResetAutopilots(1)end;pY=0 end;sa=s9;if ca>0.09 then if cG>cw/3.6 and not t and not px then aZ="SpdLmt"px=true elseif not t and px then if cG<cw/3.6 then aZ=false;px=false end end end;if b0 then if c5 then aZ=false;local sb=false;if g1 and c5==true then sb=qE(g1.position-cJ,0.1)else sb=qE(vec3(cF),0.01)end;cu=true;if sb then pZ=bI(cw)if(eU(cO)<2 or eU(cN)>85)and cG>=cw/3.6-1 then aZ=false;b0=false;if c5~=2 then pO=true end;if c5==true then c7=true end;c5=false;b1=false;co.BeginReentry()end elseif c9 and t then pY=1 end elseif cG>iD then qE(vec3(cF),0.01)end end;if a_ then if c9 then a_=false elseif cG>iD then qE(-vec3(cF))end end;if not b0 and c5 and not bx then if not c9 then if c5~=2 then pO=true end;co.BeginReentry()c5=false;c7=true else c5=false;if not q8 then q8=true end end end;if c7 and g1 and(cb<b8+250 and cb>b8-250)and cG*3.6>cw-250 and eU(cI)<25 and ca>=0.1 and(g1.position-cJ):len()>2000+cb then if not q8 then q8=true end;c7=false end;if b7 then cu=true;local sc=b8;if cI<-30 then bX="Unable to achieve lift. Safety Landing."bU=0;cu=p;b7=false;b4=true elseif not q and cL or b8<kf.spaceEngineMinAltitude then if cL then sc=antigrav.getBaseAltitude()end;if cb<sc-100 then pT=0;bU=15;aZ=false elseif cI>0 then aZ="VTO Limit"bU=0 elseif cI<-30 then aZ="VTO Fall"bU=15 elseif cb>=sc then if cL then if b1 or bo then co.ToggleVerticalTakeoff()else aZ="VTO Complete"b7=false end;bX="Takeoff complete. Singularity engaged"fQ("aggLk","AG")else aZ=false;bX="VTO complete. Engaging Horizontal Flight"fQ("vtoc","VT")co.ToggleVerticalTakeoff()end;bU=0 end else if ca>0.08 then pT=0;aZ=false;bU=20 elseif ca<0.08 and c9 then aZ=false;if cA then pT=0;bU=20 else bU=0;pT=36;pZ=3500 end else cu=p;bx=true;cz=false;sd=false;pG=false;pE=nil;pF=nil;if pJ==nil then pJ=kf end;cy=sc;pI=true;b7=false end end;if pT~=nil then if se==nil then se=pid.new(2*0.01,0,2*0.1)end;local sf=dg(pT-cN,-M*0.80,M*0.80)se:inject(sf)local sg=dg(se:get(),-1,1)pP=sg end end;if bx then local function sh()if fp.periapsis.altitude>=cy*0.99 and fp.apoapsis.altitude>=cy*0.99 and fp.periapsis.altitude<fp.apoapsis.altitude and fp.periapsis.altitude*1.05>=fp.apoapsis.altitude and eU(cy-cb)<1000 then return true else return false end end;local qL;local si=false;local sj=io(cy)if pJ==nil then pJ=kf;if bo then pJ=c1 end end;if not pI then cy=bI(pJ.radius+pJ.surfaceMaxAltitude+T)if pJ.hasAtmosphere then cy=bI(pJ.radius+pJ.noAtmosphericDensityAltitude+T)end;pI=true end;if pU.VectorToTarget and g1 then qL=g1.position-cJ end;local sk,sl=cl(pJ):escapeAndOrbitalSpeed((cJ-pJ.center):len()-pJ.radius)local sm=cO;if not pG then local sn=false;local so=false;pY=0;pF=0;cx="Aligning to orbital path - OrbitHeight: "..sj;if pU.VectorToTarget then qE(qL:normalize():project_on_plane(cH))si=cC:dot(qL:project_on_plane(pV):normalize())>0.95 else qE(cF)si=s2<0.5;if cG<150 then si=true end end;pP=0;pE=0;if cN<=pE+2 and cN>=pE-2 then sn=true else sn=false end;if sm<=pF+2 and sm>=pF-2 then so=true else so=false end;if sn and so and si then pE=nil;pF=nil;pG=true end else if pU.VectorToTarget then qE(qL:normalize():project_on_plane(cH))elseif cG>150 then qE(cF)end;pP=0;if pU.VectorToTarget and g1 then local b_,dL=ck.computeDistanceAndTime(cG,cw/3.6,cc,0,0,bq)if cz and qL:len()>15000+b_+cb then cx="Orbiting to Target"if cb-100<=pJ.noAtmosphericDensityAltitude or lt>fp.timeToPeriapsis and fp.periapsis.altitude<pJ.noAtmosphericDensityAltitude or not sh()and fp.eccentricity>0.1 then bX="Re-Aligning Orbit"cz=false end elseif cz or qL:len()<15000+b_+cb then bX="Orbit complete, proceeding with reentry"fQ("orCom","OB")bi=g1.position;pO=true;c7=true;pU.VectorToTarget,pU.AutopilotAlign=false,false;co.ToggleIntoOrbit()co.BeginReentry()return end end;if fp.periapsis~=nil and fp.apoapsis~=nil and fp.eccentricity<1 and cb>cy*0.9 and cb<cy*1.4 then if fp.apoapsis~=nil then if sh()or cz then if cz then aZ=false;pY=0;pE=0;if not pU.VectorToTarget then bX="Orbit complete"fQ("orCom","OB")co.ToggleIntoOrbit()end else pK=pK+1;if pK>=2 then cz=true end end else cx="Adjusting Orbit - OrbitHeight: "..sj;pH=true;pZ=sl*3.6+1;local sp=cy-cb;if sq==nil then sq=pid.new(0.1,0,1*0.1)end;sq:inject(sp-cI*dg(utils.smoothstep(2000-sp,-2000,2000)^6*10,1,10))pE=dg(sq:get(),-60,60)end end else local sr=2.75;local ss=eU(fR(sk*sr))local oq=ss%50;if oq>0 then ss=ss-oq+50 end;aZ=false;if cb<cy*0.8 then cx="Escaping planet gravity - OrbitHeight: "..sj;pE=utils.map(cI,200,0,-15,80)elseif cb>=cy*0.8 and cb<cy*1.15 then cx="Approaching orbital corridor - OrbitHeight: "..sj;ss=ss*0.75;pE=utils.map(cI,100,-100,-15,65)elseif cb>=cy*1.15 and cb<cy*1.5 then cx="Approaching orbital corridor - OrbitHeight: "..sj;ss=ss*0.75;if cI<0 or pH then pE=utils.map(cb,cy*1.5,cy*1.01,-30,0)else pE=utils.map(cb,cy*0.99,cy*1.5,0,30)end elseif cb>cy*1.5 then cx="Reentering orbital corridor - OrbitHeight: "..sj;pE=-65;local st=utils.map(cI,-150,-400,1,0.55)ss=ss*st end;pZ=bI(ss)end end;if pE~=nil then if su==nil then su=pid.new(1*0.01,0,5*0.1)end;local sv=pE-cN;su:inject(sv)local sw=dg(su:get(),-0.5,0.5)pP=sw end end;if b1 and not c9 and not c5 then local function sx(dd,fp)a.print(dd)aZ=false;bb=false;b1=false;qS=false;be="Aligning"pY=0;pN=false;bX=dd;fQ("apCom","AP")if fp or c5 then if fp and gl~=nil and not c5 then if not cb or cb==0 then return end;cy=cb;pI=true end;co.ToggleIntoOrbit()end end;local sy,sz=bi,false;if g1 and g1.planetname~="Space"then ba=true;if not qS then local sA=(g1.position-c1.center):normalize()local sB=sA:project_on_plane((c1.center-cJ):normalize()):normalize()local sC=c1.center+sB*(c1.radius+gl)local sD=g1.position+(g1.position-c1.center):normalize()*(gl-c1:getAltitude(g1.position))if(cJ-sC):len()<(cJ-sD):len()then sy=sC else sy=sD;bd=0 end;bi=sy;co.showWayPoint(c1,bi)sz=true;qS=true end;bf=0 elseif g1 and g1.planetname=="Space"then if not qS then bf=0;sz=true;ba=true;qS=true;sy=g1.position+(cJ-g1.position):normalize()*R;bi=sy end elseif g1==nil then bf=0;if not qS then local sA=(cJ+cF*100000-c1.center):normalize()local sB=sA:project_on_plane((c1.center-cJ):normalize()):normalize()if sB:len()<1 then sA=(cJ+cC*100000-c1.center):normalize()sB=sA:project_on_plane((c1.center-cJ):normalize()):normalize()end;sy=c1.center+sB*(c1.radius+gl)bi=sy;qS=true;sz=true;ba=true;co.showWayPoint(c1,bi)end end;r7=(vec3(sy)-cJ):len()local lr,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,cF:normalize(),function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local ls=eE;if eF~=nil and eE~=nil then ls=math.min(eF,eE)end;if ls~=nil and ls<r7 and lr.name==c1.name then r7=ls end;local sb=true;local sE=(c1.center-(cJ+vec3(cF):normalize()*r7)):len()-c1.radius;local le=io(sE)q5=gd;q6='{"label": "Projected Altitude", "value": "'..le..'"}'if cG>50 and b9 then local qL=vec3(sy)-cJ;local sF=dg(math.deg(qo(pV,cF:normalize(),qL:normalize()))*cG/500,-90,90)local sG=dg(math.deg(qo(cD,cF:normalize(),qL:normalize()))*cG/500,-90,90)if eU(sF)<20 and eU(sG)<20 then sF=sF*2;sG=sG*2 end;if eU(sF)<2 and eU(sG)<2 then sF=sF*2;sG=sG*2 end;local s2=-math.deg(qo(pV,cC,cF:normalize()))local s3=-math.deg(qo(cD,cC,cF:normalize()))if sH==nil then sH=pid.new(2*0.01,0,2*0.1)end;sH:inject(sG-s3)local sI=dg(sH:get(),-1,1)pP=pP+sI;if sJ==nil then sJ=pid.new(2*0.01,0,2*0.1)end;sJ:inject(sF-s2)local sK=dg(sJ:get(),-1,1)pQ=pQ+sK;sz=true;if eU(sF)>2 or eU(sG)>2 then if be~="Adjusting Trajectory"then be="Adjusting Trajectory"fQ("apAdj","AP")end else if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end end elseif b9 and cG<=50 then qE((sy-cJ):normalize())end;if sE<gl*1.5 then bd=cw/3.6;if g1==nil then dL,bd=cl(c1):escapeAndOrbitalSpeed(sE)end end;local b_,c0;if not b2 then b_,c0=qk(cG)else b_,c0=qn(cG)end;if b1 and not b9 and not bc and not bb then local lr,ls=co.checkLOS((bi-cJ):normalize())if c1.name~=kf.name then if lr~=nil and c1.name~=lr.name and ls<r7 then bX="Collision with "..lr.name.." in "..io(ls).."\nClear LOS to continue."bY=5;q2=true else q2=false;bX=""end end end;if not q2 then if not bc and not bb and not sz then sb=qE((sy-cJ):normalize())elseif b2 and(bb or bc)then sb=qE(-vec3(cF):normalize())end end;if b9 then if not pN then aZ=false;pY=a0;bL=fR(a0,2)pN=true end;local r8=c.getThrottle()if t then r8=bL end;local sL=99999;local oo=-vec3(b.getWorldAcceleration()):dot(cF:normalize())local sM=dg(cF:dot((sy-cJ):normalize()),0,cG)if sM>0 or oo>0 then sL=ck.computeTravelTime(sM,oo,r7-b_)end;if cE:len()>=_ or r8==0 and pN or a1/4>sL then b9=false;if be~="Cruising"then fQ("apCru","AP")be="Cruising"end;bc=true;pY=0 end;local sN=r7;if sN<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<py and cR>2000 then co.ResetAutopilots(1)bX="Autopilot cancelled to prevent crossing PvP Line"aZ="PvP Prevent"py=cR else py=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true;pY=0;pN=false end elseif bb then if be~="Orbiting to Target"then aZ="AP Brk"end;if b2 then pY=1;p_=true end;local dL,sl=cl(c1):escapeAndOrbitalSpeed((cJ-kf.center):len()-kf.radius)local qL;if g1 then qL=g1.position-cJ end;if g1 and g1.planetname=="Space"and cG<50 then if#bD>0 then if not q8 then table.remove(bD,1)end;if#bD>0 then aZ=false;if not q8 then q8=2 end;return end end;sx("Autopilot complete, arrived at space location")aZ="Space Arrival"elseif g1 and g1.planetname~="Space"and cG<=sl and(fp.apoapsis==nil or fp.periapsis==nil or fp.apoapsis.altitude<=0 or fp.periapsis.altitude<=0)then sx("Autopilot complete, commencing reentry")bi=g1.position;c5=true;co.showWayPoint(c1,bi)elseif(g1 and g1.planetname~="Space"or g1==nil)and fp.periapsis~=nil and fp.periapsis.altitude>0 and fp.eccentricity<1 or be=="Circularizing"then if be~="Circularizing"then fQ("apCir","AP")be="Circularizing"end;if cG<=sl then if g1 then if cF:normalize():dot(qL:normalize())>0.4 then if be~="Orbiting to Target"then fQ("apOrb","OB")be="Orbiting to Target"end;if not qU then aZ=false;co.showWayPoint(c1,g1.position)qU=true end else sx("Autopilot complete, proceeding with reentry")bi=g1.position;c5=true;co.showWayPoint(c1,g1.position)qU=false end else sx("Autopilot completed, setting orbit",true)aZ=false end end elseif be=="Circularizing"then sx("Autopilot complete, fixing Orbit",true)end elseif bc then local sN=r7;if sN<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<py and cR>2000 then if not q8 then q8=true end;bX="Autopilot cancelled to prevent crossing PvP Line"aZ="Prevent PvP"py=cR else py=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true end;local r8=c.getThrottle()if t then r8=bL end;if r8>0 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;bc=false end else if sb then if not ba and g1==nil or not ba and g1 and g1.planetname~="Space"then if not c5 then bi=vec3(c1.center)+(gl+c1.radius)*cD;sO=pV;sP=cD end;ba=true elseif sb and not q2 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;if not pN then pY=a0;p_=true;bL=fR(a0,2)pN=true;aZ=false end end end end elseif b1 and(g1~=nil and g1.planetname~="Space"and c9)then bX="Autopilot complete, starting reentry"fQ("apCom","AP")bi=g1.position;aZ=false;bb=false;b1=false;qS=false;be="Aligning"pY=0;pN=false;b0=true;c5=true;co.showWayPoint(c1,g1.position)end;if bV then cu=true;local sG=0;local fr=cJ+vec3(c.getMasterPlayerRelativePosition())local sQ=fr-cJ;local sR=vec3(sQ):project_on(cC):len()local sS=vec3(sQ):project_on(cD):len()local c4=di(sR*sR+sS*sS)qE(sQ:normalize())local my=40;local sT=c4<my;local sU=100;local rk=dg((c4-my)/2,10,sU)pP=0;local sb=eU(pQ)<0.1;if sb and cG<rk and not sT then aZ=false;sG=-20 else aZ="Follow"sG=0 end;local sV=0;if eU(sG-cN)>sV then if sW==nil then sW=pid.new(2*0.01,0,2*0.1)end;sW:inject(sG-cN)local sI=sW:get()pP=sI end end;if b3 or b4 or b6 or bo or br~=nil then local sX=bs;if sX then sX=sX*dg(cG/100,0.1,1)*ca else sX=bq end;if not c9 then sX=bq end;pX=cC:project_on_plane(cH):normalize():dot(cF)if pX>100 then b_,c0=ck.computeDistanceAndTime(pX,100,cc,0,0,sX)local sY,sZ=ck.computeDistanceAndTime(100,0,cc,0,0,sX*0.55)b_=b_+sY else b_,c0=ck.computeDistanceAndTime(pX,0,cc,0,0,sX*0.55)end;local sp=b8-cb-cI;local s_=200+cG;if b6 or c5 then t0=2000+cG end;local t1=1;if b5 then t1=dg(cG/100,0.1,1)end;local sG=(utils.smoothstep(sp,-s_,s_)-0.5)*2*O*t1;if not b6 and not c5 and not bo and cC:dot(cF:normalize())<0.99 then sG=(utils.smoothstep(sp,-s_*dg(20-19*ca*10,1,20),s_*dg(20-19*ca*10,1,20))-0.5)*2*O*dg(2-ca*10,1,2)*t1 end;if not b3 then sG=0 end;if br~=nil then if cT and not bx then sG=br else br=nil end end;cu=true;local t2=pP;if b6 then local t3=bI(cw)local t4,t5=ck.computeDistanceAndTime(cG,t3/3.6,cc,0,0,bq-kf.gravity*9.8*cc)t4=t4==-1 and 5000 or t4;local qT=cb-(kf.noAtmosphericDensityAltitude+t4)local t6=cb>kf.noAtmosphericDensityAltitude+t4*1.35;if t6 then sG=P;if cG<=t3/3.6 and cG>t3/3.6-10 and eU(cF:normalize():dot(cC))>0.9 and not cM then bP=false;pY=1 end elseif(cM or ij:getTargetSpeed(axisCommandId.longitudinal)~=t3)and not t6 and not c9 then pZ=t3;p_=true end;if cM then if cG>t3/3.6 and not t6 then aZ="Reentry Limit"if bL>0 then pY=0 end else aZ=false end else aZ=false end;if cI>0 then aZ="Reentry vSpd"end;if not pO then sG=-80;if cb<kf.surfaceMaxAltitude+(kf.atmosphereThickness-kf.surfaceMaxAltitude)*0.25 then bX="PARACHUTE DEPLOYED at "..fR(cb,0)b6=false;b4=true;lm=true;pY=0;sG=0;cu=p end elseif kf.noAtmosphericDensityAltitude>0 and t6 then cu=true elseif not t6 then if not c9 and(cM or ij:getTargetSpeed(axisCommandId.longitudinal)~=t3)then pZ=t3 end;if cG<t3/3.6+1 then aZ=false;pO=false;b6=false;cu=true;pY=1 end end end;if cG>iD and not c6 and not bo and not b4 and u then qE(vec3(cF))end;if cS or(bo or c6)and bj>0 and c9 then local qL;if cS then if type(cS)=="table"then qL=cS elseif cS<3 and cS>0 then qL=-cH:cross(cF)*5000 elseif cS>=3 then qL=cH:cross(cF)*5000 elseif cS<0 then qL=cF*25000 end elseif g1~=nil then qL=g1.position-cJ else qL=c1.center-cJ end;local sF=math.deg(qo(cH:normalize(),cF,qL))*2;local mB=math.rad(eU(cO))if cG>aJ and c9 then local t7=1000+cG;local t8=(utils.smoothstep(sp-cI*10,-t7,t7)-0.5)*2*O;local t9=dg(90-t8,0,180)pS=dg(sF*2,-t9,t9)local ta=sF;sF=dg(dg(sF,-L*0.80,L*0.80)*math.cos(mB)+4*(cN-sG)*math.sin(math.rad(cO)),-L*0.80,L*0.80)local tb=1;if pS~=0 then tb=eU(mB/pS)end;tb=(90-dg(eU(pS-cO),0,90))/90;local tc=sG;if eU(cO)>90 then tc=-tc end;sG=tb*dg(dg(tc*math.cos(mB),-M*0.8,M*0.8)+eU(dg(eU(ta)*math.sin(mB),-M*0.80,M*0.80)),-M*0.80,M*0.80)else pS=0;sF=dg(sF,-L*0.80,L*0.80)end;local td=s2-sF;if cS and eU(td)<=0.0001 and(type(cS)=="table"or type(cS)~="table"and cS<0 and eU(cO)<1)then if cS==-2 then co.ToggleAltitudeHold()end;cS=nil;fQ("180Off","BR")return end;if not cv and cG>aJ and c9 then if te==nil then te=pid.new(2*0.01,0,2*0.1)end;te:inject(td)local sK=dg(te:get(),-1,1)pQ=pQ+sK elseif c9 and c8>-1 or cG<aJ then qE(qL)elseif cv and c9 then if(s2<-L or s2>L)and c9 then qE(cF)end;if(s3<-M or s3>M)and c9 then sG=dg(cN-s3,cN-M*0.80,cN+M*0.80)end end;if g1~=nil and not c6 then local sc=kf:getAltitude(g1.position)local qT=qL:project_on_plane(cH):len()lm=true;if b8<kf.noAtmosphericDensityAltitude and not c6 and not b5 and not b6 and(qT<=b_ and qL:len()<kf.radius)and(cF:project_on_plane(cH):normalize():dot(qL:project_on_plane(cH):normalize())>0.99 or lv=="Finalizing Approach")then lv="Finalizing Approach"if#bD>0 then if not q8 then table.remove(bD,1)end;if#bD>0 then if not q8 then q8=2 end;return end end;pY=0;if b3 then co.ToggleAltitudeHold()bo=true end;aZ="AP Finalizing"elseif not b5 then aZ=false end;if lv=="Finalizing Approach"and(pX<0.1 or qT<0.1 or tf~=nil and tf<qT)then fQ("bklOn","BL")b4=true;d6=true;if g1.heading then d7=g1.heading else d7=nil end;bo=false;lv="Proceeding to Waypoint"cU=false end;tf=qT end elseif bo and not c9 and b8>kf.noAtmosphericDensityAltitude and not(c6 or b6)then if g1~=nil and c1.name==kf.name then local qL=g1.position-cJ;local sc=kf:getAltitude(g1.position)local qT=di(qL:len()^2-(cb-sc)^2)local sX=bs;if sX then b_,c0=ck.computeDistanceAndTime(cG,0,cc,0,0,sX/2)lm=true;if qT<=b_+cG*s1/2 and cF:project_on_plane(cH):normalize():dot(qL:project_on_plane(cH):normalize())>0.99 then if kf.hasAtmosphere then aZ=false;b0=false;pO=true;c5=false;c7=true;b1=false;co.BeginReentry()end end;tf=qT end end end;if not c9 and(b3 and b8>kf.noAtmosphericDensityAltitude)and not(c6 or bx or b6)then if not cz and not bx then cy=b8;pI=true;if bo then pU.VectorToTarget=true end;co.ToggleIntoOrbit()bo=false;pG=true end end;if cv and c9 and c8==-1 and cG>aJ and lv~="Finalizing Approach"then qE(cF)sG=dg(cN-s3,cN-M*0.80,cN+M*0.80)end;pP=t2;local qx=-1;if b4 then if not q3 then if not cM then pY=0 end;ij:setTargetGroundAltitude(500)ij:activateGroundEngineAltitudeStabilization(500)bz=true;q3=true end;sG=0;local tg=false;local th=math.abs(pX)if not q and cL then tg=antigrav.getBaseAltitude()if tg<kf.surfaceMaxAltitude and g1==nil or g1~=nil and kf:getAltitude(g1.position)>tg then tg=false end else tg=false end;if d7 then if th<0.05 then if cI>-N then aZ=false else aZ="BL Align BLR"end;if qE(d7,0.001)then d7=nil;cu=p else pP=0;cu=true end else aZ="BL Align Hzn"end;if tg and eU(cb-tg)<250 then aZ="AGG Align"end else local ti=false;local tj=30;if th<10 and s8~=nil and s8>0 then local tk=dg(ca,0.4,2)local sX=bs*dg(cG/100,0.1,1)*tk;local tl=s8*tk+sX-oc;local tm=sX/2-oc;local tn=cG-di(eU(tm/2)*20/(0.5*cc))*utils.sign(tm)if tn<0 then tn=0 end;local to;if cG>100 then local tp,dL=ck.computeDistanceAndTime(cG,100,cc,0,0,sX)local tq,dL=ck.computeDistanceAndTime(100,0,cc,0,0,di(sX))to=tp+tq else to=ck.computeDistanceAndTime(cG,0,cc,0,0,di(sX))end;if to<20 then aZ=false else local tr=0;if tn>100 then local ts,dL=ck.computeDistanceAndTime(tn,100,cc,0,0,tl)local tt,dL=ck.computeDistanceAndTime(100,0,cc,0,0,s8*tk+di(sX)-oc)tr=ts+tt else tr,dL=ck.computeDistanceAndTime(tn,0,cc,0,0,s8*tk+di(sX)-oc)end;tr=(tr+15+cG*s1)*1.1;local tu=d6 and g1~=nil and kf:getAltitude(g1.position)>0 and g1.safe;local sc=nil;if tg and tg<cb then sc=tg elseif tu then sc=kf:getAltitude(g1.position)+250 elseif cb>kf.surfaceMaxAltitude then sc=kf.surfaceMaxAltitude end;if cV then local tv=kf:getAltitude(cV[1].center)if sc then if tv>sc then sc=tv end else sc=tv end end;if sc~=nil then local tw=cb-sc;ti=true;if tw<=tr or tr==-1 or th>0.05 and d6 then if th>0.05 and d6 then aZ="BL AP Hzn"else aZ="BL Stop Dist"end else aZ=false end end end end;qx=c8;if qx>-1 then if(cG<1 or cF:normalize():dot(cH)<0)and not d7 then b4=false;b3=false;if not tg then q0=true;ij:setTargetGroundAltitude(Y)end;bU=0;aZ="BL Complete"cu=p;d6=false else aZ="BL Slowing"end elseif not ti then if lm and cF:normalize():dot(-gn)<0.999 then aZ="BL Strong"qE()elseif th>10 or th>0.05 and d6 then aZ="BL hSpd"elseif cI<-N then aZ="BL BLR"else aZ=false end end end else q3=false end;if b5 or c6 then local lr,eF,eE;if bi~=nil then lr,eF,eE=cj:getPlanetarySystem(0):castIntersections(cJ,(bi-cJ):normalize(),function(en)return en.radius+en.noAtmosphericDensityAltitude end)end;if cL and not c6 then if cb>=b8-50 and cG>iD then b5=false;if not b1 and not bo then aZ="ATO Agg Arrive"pY=0 end end elseif eU(sG)<15 and cb/b8>0.75 then b5=false;if not c6 then if cM and not t then d.control.cancelCurrentControlMasterMode()end elseif c6 and cG<iD then b1=true;c6=false;b3=false;b5=false;pY=0 elseif c6 then pY=0;aZ="ATO Space"end elseif c6 and not c9 and c1~=nil and(lr==nil or lr.name==c1.name)then b1=true;c6=false;b3=false;b5=false;if not cM then pY=0 end;b9=true end end;local tx=c8>-1;local ty=cN;if(bo or c6 or cS)and not tx and cG>aJ and c9 then local mB=math.rad(eU(cO))ty=cN*eU(math.cos(mB))+s3*math.sin(mB)end;local tz=dg(sG-ty,-M*0.80,M*0.80)if not c9 and bo then tz=dg(sG-ty,-85,O)elseif not c9 then tz=dg(sG-ty,-O,O)end;if eU(cO)<5 or bo or cS or b4 or tx or b3 then if sW==nil then sW=pid.new(5*0.01,0,5*0.1)end;sW:inject(tz)local sI=sW:get()pP=pP+sI end end;if antigrav~=nil and(antigrav and not q and cb<200000)then if bt==nil or bt<1000 then bt=1000 end;if tA~=bt then tA=bt;q7=tA end end;if(c9 or b6 or c7)and t and cM then if tB==nil then tB=pid.new(0.1,0,1)end;local tC=0;if aS>0 and not b6 and ca>0.005 and ca<0.1 and cI>-50 then tC=(0.1-ca)*cw*aS end;tB:inject(cw/3.6+tC-cF:dot(cC))local tD=tB:get()bO=dg(tD,-1,1)if not d2 then if bO<bL and(ca>0.005 or b6 or c7)then bN=true;d2=dg(bO,0.01,1)else bN=false;d2=bL end end;if tE==nil then tE=pid.new(1*0.01,0,1*0.1)end;tE:inject(cF:len()-cw/3.6-tC)local tF=dg(tE:get(),0,1)if c9 and cI<-80 or(ca>0.005 or b6 or c7)then bM=tF end;if bM>0 then if bN and bO==0.01 and not d2 then d2=0 end else bO=dg(bO,0.01,1)end;local tG=''local tH=vec3()local tI=ri(axisCommandId.vertical,bU*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tI,rY)local tJ='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tJ=tJ..aT end;local tK=ij:getAxisCommandType(axisCommandId.longitudinal)local tL=ij:composeAxisAccelerationFromThrottle(tJ,axisCommandId.longitudinal)local tM=rw(axisCommandId.lateral,bw*1000)tG=tG..' , '.."lateral airfoil , lateral ground "tH=tH+tM;if tH:len()>constants.epsilon then d:setEngineForceCommand(tG,tH,rY,'','','',rZ)end;d:setEngineForceCommand(tJ,tL,rX)local tN='thrust analog vertical fueled 'local tO='thrust analog lateral fueled 'if bA=="All"or bA=="Lateral"then tO=tO..aU end;if bA=="All"or bA=="Vertical"then tN=tN..aV end;if bU~=0 or b4 and aZ or not bk and not bz then d:setEngineForceCommand(tN,tI,rX)else d:setEngineForceCommand(tN,vec3(),rX)end;if bw~=0 then d:setEngineForceCommand(tO,tM,rX)else d:setEngineForceCommand(tO,vec3(),rX)end;if rJ==0 then rJ=bM end;local tP=-rJ*(aO*cF+aP*rN)d:setEngineForceCommand('brake',tP)else if t then if not d2 then d2=bL end end;local rk=c.getAxisCommandValue(0)if not cM then if tE==nil then tE=pid.new(1*0.01,0,1*0.1)end;tE:inject(cF:len()-rk/3.6)local tF=dg(tE:get(),0,1)rJ=dg(rJ+tF,0,1)end;local tP=-rJ*(aO*cF+aP*rN)d:setEngineForceCommand('brake',tP)local tG=''local tH=vec3()local tQ=false;local tJ='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tJ=tJ..aT end;local tK=ij:getAxisCommandType(axisCommandId.longitudinal)if tK==axisCommandType.byThrottle then local tL=ij:composeAxisAccelerationFromThrottle(tJ,axisCommandId.longitudinal)d:setEngineForceCommand(tJ,tL,rX)elseif tK==axisCommandType.byTargetSpeed then local tL=ij:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tG=tG..' , '..tJ;tH=tH+tL;if ij:getTargetSpeed(axisCommandId.longitudinal)==0 or ij:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ij:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tQ=true end end;local tO='thrust analog lateral 'if bA=="All"or bA=="Lateral"then tO=tO..aU end;local tR=ij:getAxisCommandType(axisCommandId.lateral)if tR==axisCommandType.byThrottle then local tS=ij:composeAxisAccelerationFromThrottle(tO,axisCommandId.lateral)d:setEngineForceCommand(tO,tS,rX)elseif tR==axisCommandType.byTargetSpeed then local tM=ij:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tG=tG..' , '..tO;tH=tH+tM end;local tN='thrust analog vertical 'if bA=="All"or bA=="Vertical"then tN=tN..aV end;local tT=ij:getAxisCommandType(axisCommandId.vertical)if tT==axisCommandType.byThrottle then local tI=ij:composeAxisAccelerationFromThrottle(tN,axisCommandId.vertical)if bU~=0 or b4 and aZ then d:setEngineForceCommand(tN,tI,rX,'airfoil','ground','',rZ)else d:setEngineForceCommand(tN,vec3(),rX)d:setEngineForceCommand('airfoil vertical',tI,rX,'airfoil','','',rZ)d:setEngineForceCommand('ground vertical',tI,rX,'ground','','',rZ)end elseif tT==axisCommandType.byTargetSpeed then if bU<0 then d:setEngineForceCommand('hover',vec3(),rX)end;local tU=ij:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tG=tG..' , '..tN;tH=tH+tU end;if tH:len()>constants.epsilon then if rJ~=0 or tQ or eU(rN:dot(cC))<0.5 then tG=tG..', brake'end;d:setEngineForceCommand(tG,tH,rY,'','','',rZ)end end;local tV=aL*(rR-rQ)local tW=vec3(b.getWorldAirFrictionAngularAcceleration())tV=tV-tW;d:setEngineTorqueCommand('torque',tV,rX,'airfoil','','',rZ)d:setBoosterCommand('rocket_engine')if bZ and not n then local fl=cE:len()local tX=0.15;if not cM then local tY=ij:getTargetSpeed(axisCommandId.longitudinal)if fl*3.6>tY*(1-tX)and tZ then tZ=false;d:toggleBoosters()elseif fl*3.6<tY*(1-tX)and not tZ then tZ=true;d:toggleBoosters()end else local r8=c.getThrottle()if t then r8=bL*100 end;local rk=r8/100;if not c9 then rk=rk*_;if fl>=rk*(1-tX)and tZ then tZ=false;d:toggleBoosters()elseif fl<rk*(1-tX)and not tZ then tZ=true;d:toggleBoosters()end else local t3=bI(cw)rk=rk*t3/3.6;if fl>=rk*(1-tX)and tZ then tZ=false;d:toggleBoosters()elseif fl<rk*(1-tX)and not tZ then tZ=true;d:toggleBoosters()end end end end end;if t_ then for dG,ds in pairs(t_)do pw[dG]=ds end end;c8=qs()return pw end;local function u0(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u1,ii,ij,ik,u2,gI,fR,d_,dh,dg,fQ,im,pv)local u3={}local u4=true;local u5=5;local u6=5;local u7=u5;local u8=u6;local u9=bK;function u3.landingGear()bk=not bk;if bk then bo=false;br=nil;co.cmdThrottle(0)if vBooster or hover then if c9 and c8==-1 then fQ("bklOn","BL")lm=true;b6=false;b5=false;b7=false;b3=false;if b4 then d6=not d6 end;b4=true;cu=true;bk=false else if bQ then fQ("grOut","LG",1)d.control.extendLandingGears()end;d6=false;ij:setTargetGroundAltitude(Y)if c9 then aZ="Landing"end end end;if bQ and not b4 and not(vBooster or hover)then fQ("grOut","LG",1)d.control.extendLandingGears()end else if bQ then fQ("grIn","LG",1)d.control.retractLandingGears()end;ij:activateGroundEngineAltitudeStabilization(ua)if bz then ij:setTargetGroundAltitude(X)end end end;function u3.startControl(ub)local function uc(r3)local r4=1;local function ud(ue,r3)local uf={kf.surfaceMaxAltitude+100,kf.spaceEngineMinAltitude-0.01*kf.noAtmosphericDensityAltitude,kf.noAtmosphericDensityAltitude+T,kf.radius*(S-1)+kf.noAtmosphericDensityAltitude}local ug=ue;for dL,ds in ipairs(uf)do if r3 and ug>ds then ue=ds elseif ue<ds and not r3 then ue=ds;break end end;return ue end;if r3 then r4=-1 end;if not q and cL then if bW and r3 then bt=1000 elseif bt~=nil then bt=bt+r4*u6;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end else bt=tA+r4*100 end elseif b3 or b7 or bx then if bx then if bW then cy=ud(cy,r3)else cy=cy+r4*u5 end;if cy<kf.noAtmosphericDensityAltitude then cy=kf.noAtmosphericDensityAltitude end else if bW and c9 then b8=ud(b8,r3)else b8=b8+r4*u5 end end else if not r3 and c8-3<Y and cb>0 and bk then cq.landingGear()end;ij:updateTargetGroundAltitudeFromActionStart(r4*1.0)end end;local function uh(ui)if not c9 then bX="Flight Assist in Atmo only"return end;local dp=type(ui)if cS==nil then if dp=="table"then if b1 or bo then co.ToggleAutopilot()end;fQ("180On","BR")elseif ui==1 then fQ("bnkLft","BR")else fQ("bnkRht","BR")end;if not b3 and not b1 and not bo then co.ToggleAltitudeHold()if dp~="table"then ui=ui+1 end end;cS=ui else fQ("180Off","BR")cS=nil end end;if ub=="gear"then cq.landingGear()elseif ub=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ub=="forward"then if oY and not c9 and not b1 then b0=not b0;a_=false else bR=bR-1 end elseif ub=="backward"then if oY then if not c9 then if not b1 then a_=not a_;b0=false else b2=not b2 end else uh(-cF*5000)end else bR=bR+1 end elseif ub=="left"then if oY then uh(1)else bS=bS-1 end elseif ub=="right"then if oY then uh(3)else bS=bS+1 end elseif ub=="yawright"then bT=bT-1;d7=nil elseif ub=="yawleft"then bT=bT+1;d7=nil elseif ub=="straferight"then ij:updateCommandFromActionStart(axisCommandId.lateral,1.0)bw=1 elseif ub=="strafeleft"then ij:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bw=-1 elseif ub=="up"then bU=bU+1;if c8-3<Y and cb>0 and bk then cq.landingGear()end;ij:deactivateGroundEngineAltitudeStabilization()ij:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ub=="down"then bU=bU-1;ij:deactivateGroundEngineAltitudeStabilization()ij:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ub=="groundaltitudeup"then uc()elseif ub=="groundaltitudedown"then uc(true)elseif ub=="option1"then uj=false;if oY and bW then local uk=""for K=1,#cY do uk=uk.."| Name: "..a.getPlayerName(cY[K]).." Mass: "..fR(b.getBoardedPlayerMass(cY[K])/1000,1).."t "end;a.print("Onboard: "..uk)return end;cn.adjustAutopilotTargetIndex()elseif ub=="option2"then uj=false;if oY and bW then for K=1,#cY do b.forceDeboard(cY[K])end;bX="Deboarded All Passengers"return end;cn.adjustAutopilotTargetIndex(1)elseif ub=="option3"then local function ul()u4=not u4;if not u4 then fQ("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(um,atmofueltank_size,"Atmo Fuel","fuel_container")un=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uo,spacefueltank_size,"Space Fuel","fuel_container")up=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uq,rocketfueltank_size,"Rocket Fuel","fuel_container")ur=_autoconf.panels[_autoconf.panels_size]end;us=a.createWidgetPanel("Docking")ut=a.createWidget(us,"parenting")a.addDataToWidget(c.getDataId(),ut)uu=a.createWidgetPanel("Core combat stress")uv=a.createWidget(uu,"core_stress")a.addDataToWidget(b.getDataId(),uv)if shield~=nil then shield.show()end else fQ("hud","DH")c.hide()b.hide()if un~=nil then gI(un)un=nil end;if us~=nil then gI(us)us=nil end;if uu~=nil then gI(uu)uu=nil end;if up~=nil then gI(up)up=nil end;if ur~=nil then gI(ur)ur=nil end;if shield~=nil then shield.hide()end end end;uj=false;if oY and bW then local uk=""for K=1,#cZ do uk=uk.."| ID: "..cZ[K].." Mass: "..fR(b.getDockedConstructMass(cZ[K])/1000,1).."t "end;a.print("Docked Ships: "..uk)return end;if x then if w then w=false else w=true end end;ul()elseif ub=="option4"then uj=false;if oY and bW then for K=1,#cZ do b.forceUndock(cZ[K])end;bX="Undocked all ships"return end;cS=nil;co.ToggleAutopilot()elseif ub=="option5"then uj=false;co.ToggleLockPitch()elseif ub=="option6"then uj=false;if oY and bW then if shield then cr.ventShield()else bX="No shield found"end;return end;co.ToggleAltitudeHold()elseif ub=="option7"then uj=false;if oY and bW then if shield then shield.toggle()return else bX="No shield found"return end end;E=not E;if E then bX="Collision System Enabled"else bX="Collision System Secured"end elseif ub=="option8"then uj=false;if oY and bW then if bj>0 and g1~=nil then co.routeWP()else bX="Select a saved wp on IPH to add to or remove from route"end;return end;bz=not bz;if not bz then bX="DeCoupled Mode - Ground Stabilization off"ij:deactivateGroundEngineAltitudeStabilization()fQ("gsOff","GS")else bX="Coupled Mode - Ground Stabilization on"ij:activateGroundEngineAltitudeStabilization(ua)d9=true;fQ("gsOn","GS")end elseif ub=="option9"then uj=false;if oY and bW then ij:resetCommand(axisCommandId.longitudinal)ij:resetCommand(axisCommandId.lateral)ij:resetCommand(axisCommandId.vertical)co.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cd=gyro.getState()==1;if cd then fQ("gyOn","GA")else fQ("gyOff","GA")end else bX="No gyro found"end elseif ub=="lshift"then cW=false;if oY then bW=true end;if ik()==1 then bW=true;bg=ik()u2(1)elseif ii()==1 and y then bW=true;ct=false;cs=false end elseif ub=="brake"then if aX or oY then co.BrakeToggle("Manual")elseif not aZ then co.BrakeToggle("Manual")else aZ="Manual"end elseif ub=="lalt"then uj=true;oY=true;if ii()==0 and not i and g=="keyboard"then u2(1)end elseif ub=="booster"then if n then d:toggleBoosters()elseif not bZ then if not tZ then d:toggleBoosters()tZ=true end;bZ=true else if tZ then d:toggleBoosters()tZ=false end;bZ=false end elseif ub=="stopengines"then local function uw()if bK-u9<1.5 then fQ("clear","CA")co.clearAll()end end;uw()u9=bK;if ij:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bL~=0 then ij:resetCommand(axisCommandId.longitudinal)co.cmdThrottle(0)else co.cmdThrottle(100)end else if ij:getTargetSpeed(axisCommandId.longitudinal)~=0 then ij:resetCommand(axisCommandId.longitudinal)else if c9 then co.cmdCruise(cw)else co.cmdCruise(_*3.6)end end end elseif ub=="speedup"then co.changeSpd()elseif ub=="speeddown"then co.changeSpd(true)elseif ub=="antigravity"and not q then if antigrav~=nil then co.ToggleAntigrav()else bX="No antigrav found"end end end;function u3.stopControl(ub)local function ux()if not q and cL then u8=u6 end;if b3 or b7 or bx then u7=u5 end end;if ub=="forward"then bR=0 elseif ub=="backward"then bR=0 elseif ub=="left"then if cS then if cS==2 then cS=-2 else cS=-1 end end;bS=0 elseif ub=="right"then if cS then if cS==4 then cS=-2 else cS=-1 end end;bS=0 elseif ub=="yawright"then bT=0 elseif ub=="yawleft"then bT=0 elseif ub=="straferight"then ij:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bw=0 elseif ub=="strafeleft"then ij:updateCommandFromActionStop(axisCommandId.lateral,1.0)bw=0 elseif ub=="up"then bU=0;ij:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bz then ij:activateGroundEngineAltitudeStabilization(ua)d9=true end elseif ub=="down"then bU=0;ij:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bz then ij:activateGroundEngineAltitudeStabilization(ua)d9=true end elseif ub=="groundaltitudeup"then ux()uj=false elseif ub=="groundaltitudedown"then ux()uj=false elseif ub=="lshift"then if ik()==1 then c2=0;c3=0;u2(bg)elseif ii()==1 and y then ct=false;cs=false end;bW=false elseif ub=="brake"then if not aX and not oY then if aZ then co.BrakeToggle()else aZ=false end end elseif ub=="lalt"then if ii()==0 and i then if uj then if ik()==1 then u2(0)else u2(1)end else uj=true end elseif ii()==0 and not i and g=="keyboard"then u2(0)end;oY=false end end;function u3.loopControl(ub)local function uy(r3)local r4=1;if r3 then r4=-1 end;if not q and cL then if bt~=nil then bt=bt+r4*u8;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end;u8=dg(u8*1.05,u6,50)else bt=tA+r4*100 end elseif b3 or b7 or bx then if bx then cy=cy+r4*u7;if cy<kf.noAtmosphericDensityAltitude then cy=kf.noAtmosphericDensityAltitude end else b8=b8+r4*u7 end;u7=dg(u7*1.05,u5,50)else ij:updateTargetGroundAltitudeFromActionLoop(r4*1.0)end end;local function uz(r3)local r4=1;if r3 then r4=-1 end;if not bW then if t and not oY then bL=dg(bL+r4*aD/100,-1,1)else ij:updateCommandFromActionLoop(axisCommandId.longitudinal,r4*aD)end end end;if ub=="groundaltitudeup"then if not bW then uy()end elseif ub=="groundaltitudedown"then if not bW then uy(true)end elseif ub=="speedup"then uz()elseif ub=="speeddown"then uz(true)end end;function u3.inputTextControl(r2)local function uA(uB,fr,gv)local function uC(fr)local dy=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dz='::pos{'..dy..','..dy..','..dy..','..dy..','..dy..'}'local dP,dQ,dX,dY,dZ=d_(fr,dz)if dP=="0"and dQ=="0"then return vec3(dh(dX),dh(dY),dh(dZ))end;dY=math.rad(dY)dX=math.rad(dX)local kf=e[dh(dP)][dh(dQ)]local eQ=math.cos(dX)local uD=vec3(eQ*math.cos(dY),eQ*math.sin(dY),math.sin(dX))return kf.center+(kf.radius+dZ)*uD end;local fT=uC(fr)return cn.AddNewLocation(uB,fT,gv)end;local K;local uE,i6=nil,nil;local uF="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(r2," ")uE=r2;if K~=nil then uE=string.sub(r2,0,K-1)i6=string.sub(r2,K+1)end;if uE=="/help"or uE=="/commands"then for ln in string.gmatch(uF,"([^\n]+)")do a.print(ln)end;return elseif uE=="/setname"then if i6==nil or i6==""then bX="Usage: ah-setname Newname"return end;if bj>0 and g1~=nil then cn.UpdatePosition(i6)else bX="Select a saved target to rename first"end elseif shield and uE=="/resist"then cr.setResist(i6)elseif uE=="/addlocation"or string.find(r2,"::pos")~=nil then local gv=false;local uB="0-Temp"if i6==nil or i6==""or uE~="/addlocation"then i6=uE;gv=true end;K=string.find(i6,"::")if not gv then uB=string.sub(i6,1,K-2)end;local fr=string.sub(i6,K)uA(uB,fr,gv)elseif uE=="/agg"then if i6==nil or i6==""then bX="Usage: /agg targetheight"return end;i6=dh(i6)if i6<1000 then i6=1000 end;bt=i6;bX="AGG Target Height set to "..i6 elseif uE=="/G"then if i6==nil or i6==""then bX="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if i6=="dump"then for dG,ds in pairs(im())do if type(ds.get())=="boolean"then if ds.get()==true then a.print(dG.." true")else a.print(dG.." false")end elseif ds.get()==nil then a.print(dG.." nil")else a.print(dG.." "..ds.get())end end;return end;K=string.find(i6," ")local uG=string.sub(i6,0,K-1)local uH=string.sub(i6,K+1)for dG,ds in pairs(im())do if dG==uG then local uI=type(ds.get())if uI=="number"then uH=dh(uH)if dG=="AtmoSpeedLimit"then cw=uH end end;bX="Variable "..uG.." changed to "..uH;if dG=="MaxGameVelocity"then uH=uH/3.6;if uH>da-0.2 then uH=da-0.2;bX="Variable "..uG.." changed to "..fR(uH*3.6,1)end end;if uI=="boolean"then if string.lower(uH)=="true"then uH=true else uH=false end end;ds.set(uH)return end end;bX="No such global variable: "..uG elseif uE=="/deletewp"then if bj>0 and g1~=nil then cn.ClearCurrentPosition()else bX="Select a custom wp to delete first in IPH"end elseif uE=="/copydatabank"then if dbHud_2 then pv(true)else bX="Spare Databank required to copy databank"end elseif uE=="/iphWP"then if bj>0 then a.print(co.showWayPoint(c1,bi,true))a.print(json.encode(bi))bX="::pos waypoint shown in lua chat in local and world format"else bX="No target selected in IPH"end elseif uE=="/createPrivate"then local uJ="privatelocations = {\n"local uK=""if#d4>0 then for dG,ds in pairs(d4)do uJ=uJ.."{position = {x = "..ds.position.x..", y = "..ds.position.y..", z = "..ds.position.z.."},\n ".."name = '"..ds.name.."',\n planetname = '"..ds.planetname.."',\n gravity = "..ds.gravity..",\n"if ds.heading then uJ=uJ.."heading = {x = "..ds.heading.x..", y = "..ds.heading.y..", z = "..ds.heading.z.."},\n"end;if ds.safe then uJ=uJ.."safe = true},\n"else uJ=uJ.."safe = false},\n"end end end;uK=#d4 .."-Private "if i6=="all"then for dG,ds in pairs(bn)do uJ=uJ.."{position = {x = "..ds.position.x..", y = "..ds.position.y..", z = "..ds.position.z.."},\n ".."name = '*"..ds.name.."',\n planetname = '"..ds.planetname.."',\n gravity = "..ds.gravity..",\n"if ds.heading then uJ=uJ.."heading = {x = "..ds.heading.x..", y = "..ds.heading.y..", z = "..ds.heading.z.."},\n"end;if ds.safe then uJ=uJ.." safe = true},\n"else uJ=uJ.."safe = false},\n"end end;uK=uK..#bn.."-Public "end;uJ=uJ.."}\n return privatelocations"if u1 then u1.setHTML(uJ)end;bX=uK.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bY=7 end end;function u3.tagTick()if bA=="Off"then bA="All"elseif bA=="All"then bA="Longitude"elseif bA=="Longitude"then bA="Lateral"elseif bA=="Lateral"then bA="Vertical"else bA="Off"end;bX="Extra Engine Tags: "..bA;c.stopTimer("tagTick")end;if uL then for dG,ds in pairs(uL)do u3[dG]=ds end end;return u3 end;local function uM(d,b,c,a,library,e,vBooster,hover,pu,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ie,u1)local uN={}local df=string.format;local ig=json.decode;local uO=json.encode;local pn=b.getElementMaxHitPointsById;local ih=b.getElementMassById;local ii=d.control.isRemoteControlled;local d_=string.match;local gI=a.destroyWidgetPanel;local fO=a.updateData;local fP=a.addDataToWidget;local u2=a.lockView;local ik=a.isViewLocked;local di=math.sqrt;local dh=tonumber;local eU=math.abs;local bI=math.floor;local bJ=c.getAtmosphereDensity;local eP=math.atan;local bH=a.getArkTime;local dg=utils.clamp;local ij=d.axisCommandManager;local uP=Y;local gK=13;local iq=b.getElementIdList()local ir=0;local function dj(ex,ey)if ex==0 then return eU(ey)<1e-09 end;if ey==0 then return eU(ex)<1e-09 end;return eU(ex-ey)<math.max(eU(ex),eU(ey))*dx end;local function fR(dy,uQ)local r4=10^(uQ or 0)return bI(dy*r4+0.5)/r4 end;local function il(uR,uS)for dG,ds in pairs(uS)do if type(dG)=="string"then uR[dG]=ds else uR[#uR+1]=uS[dG]end end;return uR end;local function im(uT)local uU={}if not uT then il(uU,J)il(uU,a8)il(uU,aB)il(uU,aW)return uU elseif uT=="boolean"then return J elseif uT=="handling"then return a8 elseif uT=="hud"then return aB elseif uT=="physics"then return aW end end;local function pv(uV)local function uW(uX)for dG,ds in pairs(uX)do dbHud_1.setStringValue(dG,uO(ds.get()))if uV and dbHud_2 then dbHud_2.setStringValue(dG,uO(ds.get()))end end end;if dbHud_1 then uW(bE)uW(im())a.print("Saved Variables to Datacore")if uV and dbHud_2 then bX="Databank copied.  Remove copy when ready."end end end;local function fQ(uY,uZ,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uY..".mp3")end;local function gJ(hk,hl,r2,jx,u_)if jx==nil then jx=""end;if u_==nil then u_=""end;return df([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jx,hk,hl,u_,r2)end;local function io(c4,v0)local v1=c4>100000;if v0==nil then v0=1 end;if v1 then return fR(c4/1000/200,v0).."SU"elseif c4<1000 then return fR(c4,v0).."M"else return fR(c4/1000,v0).."KM"end end;local function ip(v2)local v3=0;local v4=0;local v5=0;if v2<60 then v2=bI(v2)elseif v2<3600 then v3=bI(v2/60)v2=bI(v2%60)elseif v2<86400 then v4=bI(v2/3600)v3=bI(v2%3600/60)else v5=bI(v2/86400)v4=bI(v2%86400/3600)end;if v5>0 then return v5 .."d "..v4 .."h "elseif v4>0 then return v4 .."h "..v3 .."m "elseif v3>0 then return v3 .."m "..v2 .."s"elseif v2>0 then return v2 .."s"else return"0s"end end;function uN.onStart()local v6=false;local function v7()local function v8(v9)local va=dbHud_1.hasKey;for dG,ds in pairs(v9)do if va(dG)then local dB=ig(dbHud_1.getStringValue(dG))if dB~=nil then ds.set(dB)v6=true end end end end;if dbHud_1 then if not f then v8(im())coroutine.yield()v8(bE)else v8(bE)bX="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bY=5;v6=false end;coroutine.yield()if v6 then bX="Loaded Saved Variables"ce=a9;cf=aa;aX=j;g=string.lower(g)cu=p;cw=U elseif not f then bX="No Saved Variables Found - Exit HUD to save settings"end;if bB<1.500 then if T<2000 then bX="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bB=VERSION_NUMBER;if#bn>0 then d5=il(d5,bn)end else bX="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bu+180<bK then bs=0 end;bu=bK;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bX="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bY=7 end;if antigrav and not q then if bt==nil then bt=cb end;antigrav.setBaseAltitude(bt)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d4>0 then d5=il(d5,d4)end end;lv="Proceeding to Waypoint"end;local function vb()local function vc(vd,ve)if vd>ve then ve=vd end;local vf,vg=0,0;if a5>0 then vf=a5*0.05 end;if a6>0 then vg=a6*0.05 end;ve=ve*(1-(vf+vg))return ve end;local vh=b.getElementNameById;local vi=aq~=0 and ar~=0;local vj=_G["atmofueltank_size"]local vk=_G["spacefueltank_size"]local vl=_G["rocketfueltank_size"]for dG in pairs(iq)do local type=b.getElementTypeById(iq[dG])if d_(type,'^.*Atmospheric Engine$')then if d_(tostring(b.getElementTagsById(iq[dG])),'^.*vertical.*$')and b.getElementForwardById(iq[dG])[3]>0 then cK=true end end;if d_(type,'^.*Space Engine$')then cB=true;if d_(tostring(b.getElementTagsById(iq[dG])),'^.*vertical.*$')then local vm=b.getElementForwardById(iq[dG])if vm[3]<0 then vn=true else cA=true end end end;if type=="Landing Gear"then bQ=true end;if type=="Dynamic Core Unit"then local pp=pn(iq[dG])if pp>10000 then gK=110 elseif pp>1000 then gK=55 elseif pp>150 then gK=27 end end;ir=ir+pn(iq[dG])if vi and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pp=pn(iq[dG])local ok=ih(iq[dG])local vd=0;local jq=bH()if type=="Atmospheric Fuel Tank"then local ve=400;local vo=35.03;if pp>10000 then ve=51200;vo=5480 elseif pp>1300 then ve=6400;vo=988.67 elseif pp>150 then ve=1600;vo=182.67 end;vd=ok-vo;if a2>0 then ve=ve+ve*a2*0.2 end;ve=vc(vd,ve)local gu=vh(iq[dG])local jo=0;for jp=1,vj do if gu==ig(c["atmofueltank_"..jp].getData()).name then jo=jp;break end end;local vp={iq[dG],string.sub(gu,1,12),ve,vo,vd,jq,jo}cg[#cg+1]=vp end;if type=="Rocket Fuel Tank"then local ve=320;local vo=173.42;if pp>65000 then ve=40000;vo=25740 elseif pp>6000 then ve=5120;vo=4720 elseif pp>700 then ve=640;vo=886.72 end;vd=ok-vo;if a4>0 then ve=ve+ve*a4*0.1 end;ve=vc(vd,ve)local gu=vh(iq[dG])local jo=0;for jp=1,vl do if gu==ig(c["rocketfueltank_"..jp].getData()).name then jo=jp;break end end;local vp={iq[dG],string.sub(gu,1,12),ve,vo,vd,jq,jo}ci[#ci+1]=vp end;if type=="Space Fuel Tank"then local ve=600;local vo=35.03;if pp>10000 then ve=76800;vo=5480 elseif pp>1300 then ve=9600;vo=988.67 elseif pp>150 then ve=2400;vo=182.67 end;vd=ok-vo;if a3>0 then ve=ve+ve*a3*0.2 end;ve=vc(vd,ve)local gu=vh(iq[dG])local jo=0;for jp=1,vk do if gu==ig(c["spacefueltank_"..jp].getData()).name then jo=jp;break end end;local vp={iq[dG],string.sub(gu,1,12),ve,vo,vd,jq,jo}ch[#ch+1]=vp end end end;if not cK then b7,aY=false,false end end;local function vq()if gyro~=nil then cd=gyro.getState()==1 end;if not bz then ij:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u2(1)else u2(0)end;if door and(c9 or not c9 and cb<10000)then for dL,ds in pairs(door)do ds.toggle()end end;if switch then for dL,ds in pairs(switch)do ds.toggle()end end;if forcefield and(c9 or not c9==0 and cb<10000)then for dL,ds in pairs(forcefield)do ds.toggle()end end;if antigrav then cL=antigrav.getState()==1;if cL and not q then antigrav.show()end end;if ii()==1 and k then a.freeze(1)else a.freeze(0)end;if bQ then if c8~=-1 and not cL then d.control.extendLandingGears()else d.control.retractLandingGears()end end;bk=d.control.isAnyLandingGearExtended()==1 or c8~=-1 and c8-3<Y;if c8~=-1 or not c9 and cE:len()<50 then aZ="Startup"else aZ=false end;ij:setTargetGroundAltitude(uP)pb=c9 end;local function vr()local vs={}local function vt()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vu={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vv={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vw,vx in pairs(e)do e[vw][0]=vt()e[vw][0].systemId=vw;vs[vw]={}for vy,kf in pairs(e[vw])do kf.gravity=kf.gravity/9.8;kf.center=vec3(kf.center)kf.name=kf.name[1]kf.noAtmosphericDensityAltitude=vv[kf.id]or kf.atmosphereThickness or kf.atmosphereRadius-kf.radius;kf.spaceEngineMinAltitude=vu[kf.id]or 0.68377*kf.atmosphereThickness;kf.planetarySystemId=vw;kf.bodyId=kf.id;vs[vw][vy]=kf;if mn==nil or kf.center.x<mn then mn=kf.center.x end;if mm==nil or kf.center.x>mm then mm=kf.center.x end;if mq==nil or kf.center.y<mq then mq=kf.center.y end;if mp==nil or kf.center.y>mp then mp=kf.center.y end;if kf.center and kf.name~="Space"then c_[#c_+1]=kf end end end;e9=de(d,b,c,a,df,dg,dh,di,dj)cj=e9(vs)ck=eT(d,b,c,a,di,eU)cl=fn(d,b,c,a,df,dg,dh,di,dj)cn=fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dh,di,fQ,fR)kf=cj[0]:closestBody(b.getConstructWorldPos())end;vz=false;vA=coroutine.create(function()ij:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v7()coroutine.yield()vb()coroutine.yield()co=pt(d,b,c,a,e,vBooster,hover,pu,antigrav,warpdrive,dbHud_1,radar_1,eU,bI,bJ,ii,eP,bH,dg,ij,fO,ik,di,fR,fQ,il,dj,io,ip,pv,ig,df,fP)vq()coroutine.yield()vr()if radar_1 then cp=gH(b,a,c,library,radar_1,radar_2,eU,gI,di,gJ,dh,gK,fQ)end;if id then cm=id(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield,warpdrive,ie,eU,bI,df,ig,bJ,ih,ii,eP,bH,dg,ij,fP,fO,gI,ik,di,fR,gJ,fQ,il,im,io,ip,iq,ir)end;if cm then cm.ButtonSetup()end;cq=u0(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u1,ii,ij,ik,u2,gI,fR,d_,dh,dg,fQ,im,pv)if shield then cr=hY(shield,d_,bI)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if u1 then u1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aR)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vB then vC.ExtraOnStart()end;fQ("start","SU")end)coroutine.resume(vA)end;function uN.onUpdate()if not vz then local hQ=coroutine.status(vA)if hQ=="suspended"then local dH,hR=coroutine.resume(vA)if hR then a.print("ERROR STARTUP: "..hR)end elseif hQ=="dead"then vz=true end end;if vz then d:update()if c9 and t and cM then if cM and bP then co.cmdThrottle(0)bP=false elseif not cM and not bP then bL=0;bP=true end end;if d2 then ij:setThrottleCommand(axisCommandId.longitudinal,d2)d2=nil end;if not cs and o_~=vD then a.setScreen(o_)end;vD=o_;if vB then vC.ExtraOnUpdate()end end end;function uN.onFlush()if vz then co.onFlush()if vB then vC.ExtraOnFlush()end end end;function uN.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ca>0 or ca==0 and cb<10000)then for dL,ds in pairs(door)do ds.toggle()end end;if switch then for dL,ds in pairs(switch)do ds.toggle()end end;if forcefield and(ca>0 or ca==0 and cb<10000)then for dL,ds in pairs(forcefield)do ds.toggle()end end;w=d1;pv()if nV then nV.activate()end;if z then co.showWayPoint(kf,cJ)end;if cm then a.print(cm.FuelUsed("atmofueltank")..", "..cm.FuelUsed("spacefueltank")..", "..cm.FuelUsed("rocketfueltank"))end;if vB then vC.ExtraOnStop()end;fQ("stop","SU")end;function uN.controlStart(ub)if vz then cq.startControl(ub)end end;function uN.controlStop(ub)if vz then cq.stopControl(ub)end end;function uN.controlLoop(ub)if vz then cq.loopControl(ub)end end;function uN.controlInput(r2)if vz then cq.inputTextControl(r2)end end;function uN.radarEnter(dQ)cp.onEnter(dQ)end;function uN.radarLeave(dQ)cp.onLeave(dQ)end;function uN.onTick(vE)if vE=="tenthSecond"then co.TenthTick()if cm then cm.TenthTick()end elseif vE=="oneSecond"then if cm then cm.OneSecondTick()end elseif vE=="fiveSecond"then co.SatNavTick()elseif vE=="msgTick"then if cm then cm.MsgTick()end elseif vE=="animateTick"then if cm then cm.AnimateTick()end elseif vE=="hudTick"then if cm then cm.hudtick()end elseif vE=="apTick"then co.APTick()elseif vE=="shieldTick"then cr.shieldTick()elseif vE=="tagTick"then cq.tagTick()elseif vE=="contact"then cp.ContactTick()end end;if vB then for dG,ds in pairs(vB)do uN[dG]=ds end end;return uN end;function script.onStart()vC.onStart()end;function script.onStop()vC.onStop()end;function script.onTick(vE)vC.onTick(vE)end;function script.onFlush()vC.onFlush()end;function script.onUpdate()vC.onUpdate()end;function script.onActionStart(ub)vC.controlStart(ub)end;function script.onActionStop(ub)vC.controlStop(ub)end;function script.onActionLoop(ub)vC.controlLoop(ub)end;function script.onInputText(r2)vC.controlInput(r2)end;function script.onEnter(dQ)vC.radarEnter(dQ)end;function script.onLeave(dQ)vC.radarLeave(dQ)end;bG(a,b,c,a.getArkTime,math.floor,c.getAtmosphereDensity)vC=uM(d,b,c,a,library,e,vBooster,hover,pu,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ie,u1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua:       if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua:       if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua:       if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
