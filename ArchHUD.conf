name: ArchHud - Archaegeo v0.001 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
        brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
        autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01
        turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
        turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=DUConstruct;local e=Navigator.new(a,b,c)local f=require("atlas")script={}VERSION_NUMBER=0.001;g=2;function h(i)a.print(j..": "..i)end;function script.onStart()k=0;l=0;m=0;n=0;e=Navigator.new(system,core,unit)e.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})e.axisCommandManager:setTargetGroundAltitude(4)o=system.createWidgetPanel("Docking")p=system.createWidget(o,"parenting")system.addDataToWidget(unit.getWidgetDataId(),p)q=system.createWidgetPanel("Core combat stress")r=system.createWidget(q,"core_stress")system.addDataToWidget(core.getWidgetDataId(),r)_autoconf.displayCategoryPanel(s,weapon_size,t("ui_lua_widget_weapon","Weapons"),"weapon",true)core.showWidget()_autoconf.displayCategoryPanel(u,radar_size,t("ui_lua_widget_periscope","Periscope"),"periscope")v=true;if atmofueltank_size>0 then _autoconf.displayCategoryPanel(w,atmofueltank_size,t("ui_lua_widget_atmofuel","Atmo Fuel"),"fuel_container")if v then _autoconf.displayCategoryPanel(u,radar_size,t("ui_lua_widget_radar","Radar"),"radar")v=false end end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(x,spacefueltank_size,t("ui_lua_widget_spacefuel","Space Fuel"),"fuel_container")if v then _autoconf.displayCategoryPanel(u,radar_size,t("ui_lua_widget_radar","Radar"),"radar")v=false end end;_autoconf.displayCategoryPanel(y,rocketfueltank_size,t("ui_lua_widget_rocketfuel","Rocket Fuel"),"fuel_container")if v then _autoconf.displayCategoryPanel(u,radar_size,t("ui_lua_widget_radar","Radar"),"radar")v=false end;if antigrav~=nil then antigrav.showWidget()end;if warpdrive~=nil then warpdrive.showWidget()end;if gyro~=nil then gyro.showWidget()end;if shield~=nil then shield.showWidget()end;if unit.isRemoteControlled()==1 then z.freeze(1)end;A=unit.isAnyLandingGearDeployed()==1;if A then unit.deployLandingGears()else unit.retractLandingGears()end end;function script.onOnStop()_autoconf.hideCategoryPanels()if antigrav~=nil then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;if gyro~=nil then gyro.hideWidget()end;core.hideWidget()unit.switchOffHeadlights()end;function script.onTick(B)end;function script.onOnFlush()C=math.max(C,0.01)D=math.max(D,0.01)E=math.max(E,0.01)g=math.max(g,0.01)F=math.max(F,0.01)G=math.max(G,0.01)H=math.max(H,0.01)I=math.max(I,0.01)local J=k+system.getControlDeviceForwardInput()local K=l+system.getControlDeviceYawInput()local L=m-system.getControlDeviceLeftRightInput()local M=n;local N=vec3(core.getWorldVertical())local O=vec3(P.getWorldOrientationUp())local Q=vec3(P.getWorldOrientationForward())local R=vec3(P.getWorldOrientationRight())local S=vec3(P.getWorldVelocity())local T=vec3(P.getWorldVelocity()):normalize()local U=getRoll(N,Q,R)local V=math.abs(U)local W=utils.sign(U)local X=vec3(P.getWorldAngularVelocity())local Y=J*C*R+K*E*Q+L*D*O;if N:len()>0.01 and unit.getAtmosphereDensity()>0.0 then local Z=1.0;if _==true and V>Z and K==0 then local a0=utils.clamp(0,V-30,V+30)if a1==nil then a1=pid.new(H*0.01,0,H*0.1)end;a1:inject(a0-U)local a2=a1:get()Y=Y+a2*Q end;local a3=20.0;if a4==true and V>a3 and J==0 and L==0 then local a5=I*0.1;local a6=I*0.025;local a7=(V-a3)/(180-a3)*180;local a8=0;if a7<90 then a8=a7/90 elseif a7<180 then a8=(180-a7)/90 end;a8=a8*a8;local a9=-W*a6*(1.0-a8)local aa=a5*a8;Y=Y+aa*R+a9*O end end;local ab=1;local ac=0;local ad=1;local ae=g*(Y-X)local af=vec3(P.getWorldAirFrictionAngularAcceleration())ae=ae-af;e:setEngineTorqueCommand('torque',ae,ab,'airfoil','','',ad)local ag=-M*(F*S+G*T)e:setEngineForceCommand('brake',ag)local ah=''local ai=vec3()local aj=false;local ak='thrust analog longitudinal'local al=e.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)if al==axisCommandType.byThrottle then local am=e.axisCommandManager:composeAxisAccelerationFromThrottle(ak,axisCommandId.longitudinal)e:setEngineForceCommand(ak,am,ab)elseif al==axisCommandType.byTargetSpeed then local am=e.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ah=ah..' , '..ak;ai=ai+am;if e.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)==0 or e.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-e.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then aj=true end end;local an='thrust analog lateral'local ao=e.axisCommandManager:getAxisCommandType(axisCommandId.lateral)if ao==axisCommandType.byThrottle then local ap=e.axisCommandManager:composeAxisAccelerationFromThrottle(an,axisCommandId.lateral)e:setEngineForceCommand(an,ap,ab)elseif ao==axisCommandType.byTargetSpeed then local aq=e.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ah=ah..' , '..an;ai=ai+aq end;local ar='thrust analog vertical'local as=e.axisCommandManager:getAxisCommandType(axisCommandId.vertical)if as==axisCommandType.byThrottle then local at=e.axisCommandManager:composeAxisAccelerationFromThrottle(ar,axisCommandId.vertical)e:setEngineForceCommand(ar,at,ab,'airfoil','ground','',ad)elseif as==axisCommandType.byTargetSpeed then local au=e.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ah=ah..' , '..ar;ai=ai+au end;if ai:len()>constants.epsilon then if n~=0 or aj or math.abs(T:dot(Q))<0.95 then ah=ah..', brake'end;e:setEngineForceCommand(ah,ai,ac,'','','',ad)end;e:setBoosterCommand('rocket_engine')end;function script.onOnUpdate()e:update()end;function script.onActionStart(av)if av=="gear"then A=not A;if A then unit.deployLandingGears()else unit.retractLandingGears()end elseif av=="light"then if unit.isAnyHeadlightSwitchedOn()==1 then unit.switchOffHeadlights()else unit.switchOnHeadlights()end elseif av=="forward"then k=k-1 elseif av=="backward"then k=k+1 elseif av=="left"then l=l-1 elseif av=="right"then l=l+1 elseif av=="strafeleft"then e.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral,-1.0)elseif av=="straferight"then e.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral,1.0)elseif av=="up"then e.axisCommandManager:deactivateGroundEngineAltitudeStabilization()e.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif av=="down"then e.axisCommandManager:deactivateGroundEngineAltitudeStabilization()e.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif av=="groundaltitudeup"then e.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)elseif av=="groundaltitudedown"then e.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)elseif av=="yawleft"then m=m+1 elseif av=="yawright"then m=m-1 elseif av=="brake"then n=n+1;local al=e.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)if al==axisCommandType.byTargetSpeed then local aw=e.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)if math.abs(aw)>constants.epsilon then e.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,-utils.sign(aw))end end elseif av=="booster"then e:toggleBoosters()elseif av=="stopengines"then e.axisCommandManager:resetCommand(axisCommandId.longitudinal)elseif av=="speedup"then e.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,5.0)elseif av=="speeddown"then e.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,-5.0)elseif av=="antigravity"then if antigrav~=nil then antigrav.toggle()end end end;function script.onActionStop(av)if av=="forward"then k=k+1 elseif av=="backward"then k=k-1 elseif av=="left"then l=l+1 elseif av=="right"then l=l-1 elseif av=="strafeleft"then e.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral,1.0)elseif av=="straferight"then e.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral,-1.0)elseif av=="up"then e.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical,-1.0)e.axisCommandManager:activateGroundEngineAltitudeStabilization(ax)elseif av=="down"then e.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical,1.0)e.axisCommandManager:activateGroundEngineAltitudeStabilization(ax)elseif av=="yawleft"then m=m-1 elseif av=="yawright"then m=m+1 elseif av=="brake"then n=n-1 end end;function script.onActionLoop(av)if av=="groundaltitudeup"then e.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)elseif av=="groundaltitudedown"then e.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)elseif av=="brake"then local al=e.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)if al==axisCommandType.byTargetSpeed then local aw=e.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)if math.abs(aw)>constants.epsilon then e.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,-utils.sign(aw))end end elseif av=="speedup"then e.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,1.0)elseif av=="speeddown"then e.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,-1.0)end end;function script.onInputText(ay)end;function script.onEnter(az)end;function script.onLeave(az)end;script.onStart()
        pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
        brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
        autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01
        turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
        turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
