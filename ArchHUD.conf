name: ArchHud - Archaegeo v1.354 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.354;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;sounds=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized","sounds"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=utils.round;local p=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local x=math.sqrt;local y=tonumber;local function z(num,A)local B=10^(A or 0)return d(num*B+0.5)/B end;local C=p()local D=p()local E=16;local F=13;local G=SafeR;local H=SafeB;local I=SafeG;local J=0;local K=0;local L=false;local M=0;local N=false;local O=false;local P=55;local Q=false;local R=false;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=false;local a0=false;local a1="empty"local a2=5;local a3=5;local a4=a2;local a5=a3;local a6=false;local a7,a8=0;local a9,aa=0;local ab=nil;local ac=0;local ad=0;local ae=0;local af=0;local ag=0;local ah=3;local ai=0;local aj=""local ak=0;local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=j()>0;local ar=j()local as=core.getAltitude()local at=core.getElementIdList()local au=p()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=false;local az=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]local aA=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local aB={}local aC=0;local aD=0;local aE=""local aF=true;local aG={}local aH=ResolutionX;local aI=ResolutionY;local aJ={}local aK={}local aL={}local aM=0;local aN=false;local aO={}local aP={}local aQ=d(1/apTickRate)*2;local aR={}local aS={}local aT={}local aU={}local aV=false;local aW=0;local aX=nil;local aY=nil;local aZ=nil;local a_=nil;local b0=nil;local b1=nil;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=false;local b9=false;local ba=autoRollPreference;local bb=LandingGearGroundHeight;local bc=false;local bd=p()local be=0;local bf=0;local bg=0;local bh=AtmoSpeedLimit;local bi=0;local bj=nil;local bk=0;local bl=0;local bm=false;local bn=false;local bo={VectorToTarget=false}local bp=false;local bq=0;local br=nil;local bs=false;local bt=false;local bu=false;local bv=false;local bw=0;local bx=vec3(core.getConstructWorldOrientationUp())local by=vec3(core.getConstructWorldOrientationForward())local bz=vec3(core.getConstructWorldOrientationRight())local bA=vec3(core.getWorldVelocity())local bB=vec3(bA):len()local bC=vec3(core.getWorldVertical())local bD=-bC:dot(bA)local bE=vec3(core.getConstructWorldPos())local bF=0;local bG=false;local bH=false;local bI=nil;local bJ=true;local bK=0;local bL=0;local bM=false;local bN={}local bO=showHud;local bP={}local bQ=false;local bR=""local bS=""local bT=nil;local bU={}local bV=unit.getClosestPlanetInfluence()>0;local bW=false;local bX=nil;timeCount=0;totalTime=0;function getTrueWorldPos()local function bY()local bZ=core.getConstructWorldOrientationRight()local b_=core.getConstructWorldOrientationForward()local c0=core.getConstructWorldOrientationUp()local c1=library.systemResolution3(bZ,b_,c0,{1,0,0})local c2=library.systemResolution3(bZ,b_,c0,{0,1,0})local c3=library.systemResolution3(bZ,b_,c0,{0,0,1})return function(c4)return library.systemResolution3(c1,c2,c3,c4)end end;local c5=bY()local c6=core.getConstructWorldPos()local c7=core.getElementPositionById(1)local c8={c7[1]-E,c7[2]-E,c7[3]-E}local c9=c5(c8)local ca={c6[1]-c9[1],c6[2]-c9[2],c6[3]-c9[3]}return ca end;local function cb(cc,cd,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"or not sounds then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)end end;local function ce(cf,cg)for i=1,#cg do cf[#cf+1]=cg[i]end;return cf end;local function ch(ci)local cj={}local ck={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local cl={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local cm={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cn={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not ci then ce(cj,ck)ce(cj,cl)ce(cj,cm)ce(cj,cn)return cj elseif ci=="boolean"then return ck elseif ci=="handling"then return cl elseif ci=="hud"then return cm elseif ci=="physics"then return cn end end;local function co(cp,cq,cr,cs,ct)if cs==nil then cs=""end;if ct==nil then ct=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cs,cp,cq,ct,cr)end;local function cu(cv,cw)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not cw then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,cv)J=q(z(cv*100,0)/100,-1,1)end;local function cx(cv,cw)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cw then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,cv)bI=cv end;local function cy(cz,cA)if cz==0 then return c(cA)<1e-09 end;if cA==0 then return c(cz)<1e-09 end;return c(cz-cA)<math.max(c(cz),c(cA))*epsilon end;local function cB(ai,cC)local cD=ai>100000;if cC==nil then cC=1 end;if cD then return z(ai/1000/200,cC).."SU"elseif ai<1000 then return z(ai,cC).."M"else return z(ai/1000,cC).."KM"end end;local function cE()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;ba=true;ae=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;ae=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cx(d(bh))end else bs=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cF()bs=false;bk=nil;bl=nil;bw=0;if ar==0 then if IntoOrbit then cb("orOff","AP")IntoOrbit=false;bm=false;br=nil;ba=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bo.VectorToTarget=false;bo.AutopilotAlign=false;bp=false elseif bV then cb("orOn","AP")IntoOrbit=true;ba=true;if br==nil then br=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a1="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bm=false;br=nil;ba=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bo.VectorToTarget=false;bo.AutopilotAlign=false;bp=false end end;local function cG()if C-bf<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;cb("11","EP")else if bV then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bq=HoldAltitude;bp=true;if not IntoOrbit then cF()end;bm=true end end;bf=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bf=C end;if bV and ar==0 then bq=as;bp=true;bm=true;cF()if IntoOrbit then bf=C else bf=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Z=false;ba=true;LockPitch=nil;bs=false;if ao==-1 then cb("altOn","AH")AutoTakeoff=false;if bf>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=as end end;if VertTakeOff then cE()end else cb("lfs","LS")AutoTakeoff=true;if bf>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bG then cE()end end;if am then HoldAltitude=100000 end else cb("altOff","AH")if IntoOrbit then cF()end;if VertTakeOff then cE()end;ba=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bf=0 end end;local function cH()if l()==1 then Z=not Z;if Z then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)cb("folOn","F")else cb("folOff","F")BrakeIsOn=true;ba=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else a1="Follow Mode only works with Remote controller"Z=false end end;local function cI()local function cJ(SpaceTarget)bW=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cG()end end;VectorStatus="Proceeding to Waypoint"end;if C-bg<1.5 and ar>0 then if not bv then a1="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;cb("orH","OH")end;bg=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bg=C end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then b6.UpdateAutopilotTarget()b7.showWayPoint(ab,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then cb("apSpc","AP")if ar~=0 then am=true;cG()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then cb("vtt","AP")cJ(SpaceTarget)end else cb("apOn","AP")if not(ab.name==planet.name and bV)then bs=false;Autopilot=true elseif not aq then if IntoOrbit then cF()end;bq=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bp=true;bo.AutopilotAlign=true;bo.VectorToTarget=true;bm=false;if not IntoOrbit then cF()end end end else cb("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cG()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ab.name==planet.name and bV)and not IntoOrbit then WaypointSet=false;bs=false;bm=false;cF()else cb("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Z=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;O=false;LockPitch=nil;WaypointSet=false end else cb("apP","AP")am=true;cG()end else cb("apOff","AP")am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;O=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=as;TargetSet=false;Reentry=false;if IntoOrbit then cF()end end end;local function cK(cL)local cM=-1;local cN;cM=b6.findAtlasIndex(SavedLocations)if cM~=-1 then local cO;if cL~=nil then cN={position=SavedLocations[cM].position,name=cL,atmosphere=SavedLocations[cM].atmosphere,planetname=SavedLocations[cM].planetname,gravity=SavedLocations[cM].gravity}else cN={position=bE,name=SavedLocations[cM].name,atmosphere=ar,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cM]=cN;cM=-1;cM=b6.findAtlasIndex(aX[0])if cM>-1 then aX[0][cM]=cN end;b6.UpdateAtlasLocationsList()a1=CustomTarget.name.." position updated"b6.UpdateAutopilotTarget()else a1="Name Not Found"end end;local function cP()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;ba=autoRollPreference end;if BrakeIsOn then cb("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bT=nil;if not bH then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cE()end;if IntoOrbit then cF()end;ba=autoRollPreference;al=false;an=false;ae=0 else cb("bkOff","B",1)end end;local function cQ(cR,cS,cT)local function cU(cR,cV)cR=vec3(cR)cV=vec3(cV):normalize()local cW=cR*cV;return cW.x+cW.y+cW.z end;local cX=0.001;local cY=1;if not aq or not bc or ao~=-1 or bB<P then if cT==nil then cT=DampingMultiplier end;if cS==nil then cS=cX end;cR=vec3(cR):normalize()local cZ=vec3()-cR;local c_=-cU(cZ,core.getConstructWorldOrientationRight())*cY;local d0=-cU(cZ,core.getConstructWorldOrientationUp())*cY;if aC==0 then aC=c_/2 end;if aD==0 then aD=d0/2 end;if c(c_)<0.1 then U=U-c_*2 else U=U-(c_+(c_-aC)*cT)end;if c(d0)<0.1 then T=T+d0*2 else T=T+d0+(d0-aD)*cT end;aC=c_;aD=d0;if c(c_)<cS and c(d0)<cS then return true end;return false elseif bc and ao==-1 then cR=bA;if cT==nil then cT=DampingMultiplier end;if cS==nil then cS=cX end;cR=vec3(cR):normalize()local cZ=by-cR;local c_=-cU(cZ,core.getConstructWorldOrientationRight())*cY;local d0=-cU(cZ,core.getConstructWorldOrientationUp())*cY;if aC==0 then aC=c_/2 end;if aD==0 then aD=d0/2 end;if c(c_)<0.1 then U=U-c_*5 else U=U-(c_+(c_-aC)*cT)end;if c(d0)<0.1 then T=T+d0*5 else T=T+d0+(d0-aD)*cT end;aC=c_;aD=d0;if c(c_)<cS and c(d0)<cS then return true end;return false end end;local function d1()if Reentry then a1="Re-Entry cancelled"cb("reOff","RE")Reentry=false;ba=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ah=5 elseif not Q then Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;ba=true;BrakeIsOn=false;a1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bh;cb("par","RE")else Reentry=true;AltitudeHold=true;ba=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local cr=cB(HoldAltitude)a1="Beginning Re-entry.  Target speed: "..bh.." Target Altitude: "..cr;cb("glide","RE")cx(d(bh))end;AutoTakeoff=false end;local function d2()if antigrav and not ExternalAGG then if bH then cb("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;cb("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function d3(d4)local d5=0;local d6=0;local d7=0;if d4<60 then d4=d(d4)elseif d4<3600 then d5=d(d4/60)d4=d(d4%60)elseif d4<86400 then d6=d(d4/3600)d5=d(d4%3600/60)else d7=d(d4/86400)d6=d(d4%86400/3600)end;if d7>0 then return d7 .."d "..d6 .."h "elseif d6>0 then return d6 .."h "..d5 .."m "elseif d5>0 then return d5 .."m "..d4 .."s"elseif d4>0 then return d4 .."s"else return"0s"end end;local function d8(d9)local function da(db)for dc,dd in pairs(db)do dbHud_1.setStringValue(dd,g(_G[dd]))if d9 and dbHud_2 then dbHud_2.setStringValue(dd,g(_G[dd]))end end end;if dbHud_1 then da(b)da(ch())system.print("Saved Variables to Datacore")if d9 and dbHud_2 then a1="Databank copied.  Remove copy when ready."end end end;local function de()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function df()local function dg(dh)return type(dh)=='number'end;local function di(dh)return type(y(dh))=='number'end;local function dj(dk)return type(dk)=='table'end;local function dl(dm)return type(dm)=='string'end;local function dn(dd)return dj(dd)and dg(dd.x and dd.y and dd.z)end;local function dp(dq)return dj(dq)and dg(dq.latitude and dq.longitude and dq.altitude and dq.bodyId and dq.systemId)end;local dr=math.pi/180;local ds=180/math.pi;local epsilon=1e-10;local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..num..','..num..','..num..','..num..','..num..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function du(dh)local cW=string.gsub(string.reverse(e('%.4f',dh)),'^0*%.?','')return cW==''and'0'or string.reverse(cW)end;local function dv(dw)if dn(dw)then return e('{x=%.3f,y=%.3f,z=%.3f}',dw.x,dw.y,dw.z)end;if dj(dw)and not getmetatable(dw)then local dx={}local dy=next(dw)if type(dy)=='nil'or dy==1 then dx=dw else for dc,dd in pairs(dw)do local cv=dv(dd)if type(dc)=='number'then table.insert(dx,e('[%s]=%s',dc,cv))else table.insert(dx,e('%s=%s',dc,cv))end end end;return e('{%s}',table.concat(dx,','))end;if dl(dw)then return e("'%s'",dw:gsub("'",[[\']]))end;return tostring(dw)end;local dz={}dz.__index=dz;dz.__tostring=function(dw,dA)local dB={}for dc in pairs(dw)do table.insert(dB,dc)end;table.sort(dB)local dx={}for _,dc in ipairs(dB)do local cv=dv(dw[dc])if type(dc)=='number'then table.insert(dx,e('[%s]=%s',dc,cv))else table.insert(dx,e('%s=%s',dc,cv))end end;if dA then return e('%s%s',dA,table.concat(dx,',\n'..dA))end;return e('{%s}',table.concat(dx,','))end;dz.__eq=function(dC,dD)return dC.planetarySystemId==dD.planetarySystemId and dC.bodyId==dD.bodyId and cy(dC.radius,dD.radius)and cy(dC.center.x,dD.center.x)and cy(dC.center.y,dD.center.y)and cy(dC.center.z,dD.center.z)and cy(dC.GM,dD.GM)end;local function dE(dF,dG,dH,dI,dJ)assert(di(dF),'Argument 1 (planetarySystemId) must be a number:'..type(dF))assert(di(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(di(dH),'Argument 3 (radius) must be a number:'..type(dH))assert(dj(dI),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dI))assert(di(dJ),'Argument 5 (GM) must be a number:'..type(dJ))return setmetatable({planetarySystemId=y(dF),bodyId=y(dG),radius=y(dH),center=vec3(dI),GM=y(dJ)},dz)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dK)return e('::pos{%d,%d,%s,%s,%s}',dK.systemId,dK.bodyId,du(dK.latitude*ds),du(dK.longitude*ds),du(dK.altitude))end;MapPosition.__eq=function(dC,dD)return dC.bodyId==dD.bodyId and dC.systemId==dD.systemId and cy(dC.latitude,dD.latitude)and cy(dC.altitude,dD.altitude)and(cy(dC.longitude,dD.longitude)or cy(dC.latitude,math.pi/2)or cy(dC.latitude,-math.pi/2))end;local function dL(dM,dG,dN,dO,dP)local dF=dM;if dl(dM)and not dO and not dP and not dG and not dN then dF,dG,dN,dO,dP=n(dM,dt)assert(dF,'Argument 1 (position string) is malformed.')else assert(di(dF),'Argument 1 (systemId) must be a number:'..type(dF))assert(di(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(di(dN),'Argument 3 (latitude) must be in degrees:'..type(dN))assert(di(dO),'Argument 4 (longitude) must be in degrees:'..type(dO))assert(di(dP),'Argument 5 (altitude) must be in meters:'..type(dP))end;dF=y(dF)dG=y(dG)dN=y(dN)dO=y(dO)dP=y(dP)if dG==0 then return setmetatable({latitude=dN,longitude=dO,altitude=dP,bodyId=dG,systemId=dF},MapPosition)end;return setmetatable({latitude=dr*q(dN,-90,90),longitude=dr*(dO%360),altitude=dP,bodyId=dG,systemId=dF},MapPosition)end;local dQ={}dQ.__index=dQ;dQ.__tostring=function(dw,dA)local dR=dA and dA..'  'local dS={}local dB={}for dc in pairs(dw)do table.insert(dB,dc)end;table.sort(dB)for _,dT in ipairs(dB)do bdy=dw[dT]local dU=dz.__tostring(bdy,dR)if dA then table.insert(dS,e('[%s]={\n%s\n%s}',dT,dU,dA))else table.insert(dS,e('  [%s]=%s',dT,dU))end end;if dA then return e('\n%s%s%s',dA,table.concat(dS,',\n'..dA),dA)end;return e('{\n%s\n}',table.concat(dS,',\n'))end;local function dV(dW)local aX={}local pid;for _,dd in pairs(dW)do local dX=dd.planetarySystemId;if type(dX)~='number'then error('Invalid planetary system ID: '..tostring(dX))elseif pid and dX~=pid then error('Mistringmatch planetary system IDs: '..dX..' and '..pid)end;local dY=dd.bodyId;if type(dY)~='number'then error('Invalid body ID: '..tostring(dY))elseif aX[dY]then error('Duplicate body ID: '..tostring(dY))end;setmetatable(dd.center,getmetatable(vec3.unit_x))aX[dY]=setmetatable(dd,dz)pid=dX end;return setmetatable(aX,dQ)end;b0={}local function dZ(dW)return setmetatable({galaxyAtlas=dW or{}},b0)end;b0.__index=function(dk,i)if type(i)=='number'then local system=dk.galaxyAtlas[i]return dV(system)end;return rawget(b0,i)end;b0.__pairs=function(dw)return function(dk,dc)local d_,nv=next(dk,dc)return d_,nv and dV(nv)end,dw.galaxyAtlas,nil end;b0.__tostring=function(dw)local e0={}for _,e1 in pairs(dw or{})do local e2=e1:getPlanetarySystemId()local e3=dQ.__tostring(e1,'    ')table.insert(e0,e('  [%s]={%s\n  }',e2,e3))end;return e('{\n%s\n}\n',table.concat(e0,',\n'))end;b0.BodyParameters=dE;b0.MapPosition=dL;b0.PlanetarySystem=dV;function b0.createBodyParameters(e4,dG,e5,e6,e7,e8,e9)assert(di(e4),'Argument 1 (planetarySystemId) must be a number:'..type(e4))assert(di(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(di(e5),'Argument 3 (surfaceArea) must be a number:'..type(e5))assert(dj(e6),'Argument 4 (aPosition) must be an array or vec3:'..type(e6))assert(dj(e7),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(e7))assert(di(e8),'Argument 6 (altitude) must be in meters:'..type(e8))assert(di(e9),'Argument 7 (gravityAtPosition) must be number:'..type(e9))local dH=x(e5/4/math.pi)local ai=dH+e8;local ea=vec3(e6)+ai*vec3(e7)local dJ=e9*ai*ai;return dE(e4,dG,dH,ea,dJ)end;b0.isMapPosition=dp;function b0:getPlanetarySystem(dM)if i==nil then i=0 end;if nv==nil then nv=0 end;local e4=dM;if dp(dM)then e4=dM.systemId end;if type(e4)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dQ then system=dV(system)end;return system end end end;function dQ:sizeCalculator(eb)return 1.05*eb.radius end;function dQ:castIntersections(ec,cV,ed,ee,ef,eg)local eh={}local ei=ef or self;for _,eb in pairs(ei)do table.insert(eh,eb)end;if not eg then table.sort(eh,function(ej,ek)return(ej.center-ec):len()<(ek.center-ec):len()end)end;local el=cV:normalize()for _,eb in ipairs(eh)do local em=eb.center-ec;local dH=self:sizeCalculator(eb)local en=em:dot(el)local eo=en^2-(em:len2()-dH^2)if eo>=0 then local ep=x(eo)local eq=en+ep;local er=en-ep;if er>0 then return eb,eq,er elseif eq>0 then return eb,eq,nil end end end;return nil,nil,nil end;function dQ:closestBody(es)assert(type(es)=='table','Invalid coordinates.')local et,eb;local eu=vec3(es)for _,ev in pairs(self)do local ew=(ev.center-eu):len2()if(not eb or ew<et)and ev.name~="Space"then eb=ev;et=ew end end;return eb end;function dQ:convertToBodyIdAndWorldCoordinates(dM)local ex=dM;if dl(dM)then ex=dL(dM)end;if ex.bodyId==0 then return 0,vec3(ex.latitude,ex.longitude,ex.altitude)end;local ev=self:getBodyParameters(ex)if ev then return ex.bodyId,ev:convertToWorldCoordinates(ex)end end;function dQ:getBodyParameters(dM)local dG=dM;if dp(dM)then dG=dM.bodyId end;assert(di(dG),'Argument 1 (bodyId) must be a number:'..type(dG))return self[dG]end;function dQ:getPlanetarySystemId()local _,dd=next(self)return dd and dd.planetarySystemId end;function dz:convertToMapPosition(dI)assert(dj(dI),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dI))local ey=vec3(dI)if self.bodyId==0 then return setmetatable({latitude=ey.x,longitude=ey.y,altitude=ey.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local ez=ey-self.center;local ai=ez:len()local dP=ai-self.radius;local dN=0;local dO=0;if not cy(ai,0)then local eA=m(ez.y,ez.x)dO=eA>=0 and eA or 2*math.pi+eA;dN=math.pi/2-math.acos(ez.z/ai)end;return setmetatable({latitude=dN,longitude=dO,altitude=dP,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dz:convertToWorldCoordinates(dM)local ex=dl(dM)and dL(dM)or dM;if ex.bodyId==0 then return vec3(ex.latitude,ex.longitude,ex.altitude)end;assert(dp(ex),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(ex.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(ex.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local eB=math.cos(ex.latitude)return self.center+(self.radius+ex.altitude)*vec3(eB*math.cos(ex.longitude),eB*math.sin(ex.longitude),math.sin(ex.latitude))end;function dz:getAltitude(dI)return(vec3(dI)-self.center):len()-self.radius end;function dz:getDistance(dI)return(vec3(dI)-self.center):len()end;function dz:getGravity(dI)local eC=self.center-vec3(dI)local eD=eC:len2()return self.GM/eD*eC/x(eD)end;return setmetatable(b0,{__call=function(_,...)return dZ(...)end})end;local function eE()local b2={}local eF=30000000/3600;local eG=eF*eF;local eH=100;local function eI(dd)return 1/x(1-dd*dd/eG)end;function b2.computeAccelerationTime(eJ,eK,eL)local eM=eF*math.asin(eJ/eF)return(eF*math.asin(eL/eF)-eM)/eK end;function b2.computeDistanceAndTime(eJ,eL,eN,eO,eP,eQ)eP=eP or 0;eQ=eQ or 0;local eR=eJ<=eL;local eS=eO*(eR and 1 or-1)/eN;local eT=-eQ/eN;local eU=eS+eT;if eR and eU<=0 or not eR and eU>=0 then return-1,-1 end;local eV,eW=0,0;if eS~=0 and eP>0 then local eM=math.asin(eJ/eF)local eX=math.pi*(eS/2+eT)local eY=eS*eP;local eZ=eF*math.pi;local dd=function(dk)local e_=(eX*dk-eY*math.sin(math.pi*dk/2/eP)+eZ*eM)/eZ;local f0=math.tan(e_)return eF*f0/x(f0*f0+1)end;local f1=eR and function(dm)return dm>=eL end or function(dm)return dm<=eL end;eW=2*eP;if f1(dd(eW))then local f2=0;while c(eW-f2)>0.5 do local dk=(eW+f2)/2;if f1(dd(dk))then eW=dk else f2=dk end end end;local f3=eJ;local f4=eW/eH;for f5=1,eH do local f6=dd(f5*f4)eV=eV+(f6+f3)*f4/2;f3=f6 end;if eW<2*eP then return eV,eW end;eJ=f3 end;local eM=eF*math.asin(eJ/eF)local C=(eF*math.asin(eL/eF)-eM)/eU;local f7=eG*math.cos(eM/eF)/eU;local ai=f7-eG*math.cos((eU*C+eM)/eF)/eU;return ai+eV,C+eW end;function b2.computeTravelTime(eJ,eK,ai)if ai==0 then return 0 end;if eK>0 then local eM=eF*math.asin(eJ/eF)local f7=eG*math.cos(eM/eF)/eK;return(eF*math.acos(eK*(f7-ai)/eG)-eM)/eK end;if eJ==0 then return-1 end;assert(eJ>0,'Acceleration and initial speed are both zero.')return ai/eJ end;function b2.lorentz(dd)return eI(dd)end;return b2 end;local function f8()local vec3=require('cpml.vec3')local df=df()local function dl(dm)return type(dm)=='string'end;local function dj(dk)return type(dk)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dP)assert(self.body)local ai=dP+self.body.radius;if not cy(ai,0)then local orbit=x(self.body.GM/ai)return x(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dM,f9)assert(self.body)assert(dj(dM)or dl(dM))assert(dj(f9))local c7=(dl(dM)or df.isMapPosition(dM))and self.body:convertToWorldCoordinates(dM)or vec3(dM)local dd=vec3(f9)local fa=c7-self.body.center;local b_=dd:len2()local fb=fa:len()local fc=self.body.GM;local fd=((b_-fc/fb)*fa-fa:dot(dd)*dd)/fc;local cz=fc/(2*fc/fb-b_)local fe=fd:len()local el=fd:normalize()local ff=cz*(1-fe)local fg=cz*(1+fe)local fh=ff*el+self.body.center;local fi=fe<=1 and-fg*el+self.body.center or nil;local fj=x(cz*fc*(1-fe*fe))local fk=fi and 2*math.pi*x(cz^3/fc)local fl=math.acos(fd:dot(fa)/(fe*fb))if fa:dot(dd)<0 then fl=-(fl-2*math.pi)end;local fm=math.acos((math.cos(fl)+fe)/(1+fe*math.cos(fl)))local fn=fm;if fn<0 then fn=fn+2*math.pi end;local fo=fn-fe*math.sin(fn)local fp=0;local fq=0;local fr=0;if fk~=nil then fp=fo/(2*math.pi/fk)fq=fk-fp;fr=fq+fk/2;if fl-math.pi>0 then fq=fp;fr=fq+fk/2 end;if fr>fk then fr=fr-fk end end;return{periapsis={position=fh,speed=fj/ff,circularOrbitSpeed=x(fc/ff),altitude=ff-self.body.radius},apoapsis=fi and{position=fi,speed=fj/fg,circularOrbitSpeed=x(fc/fg),altitude=fg-self.body.radius},currentVelocity=dd,currentPosition=c7,eccentricity=fe,period=fk,eccentricAnomaly=fm,meanAnomaly=fo,timeToPeriapsis=fq,timeToApoapsis=fr}end;local function fs(ft)local ev=df.BodyParameters(ft.planetarySystemId,ft.bodyId,ft.radius,ft.center,ft.GM)return setmetatable({body=ev},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return fs(...)end})end;local function fu()local fv=0;local function fw(fx)local dH=500000;local fy,fz,fA=math.huge;local fB=false;local fC=vec3({13771471,7435803,-128971})local fD=18000000;fy=vec3(fx):dist(fC)if fy<fD then return true,c(fy-fD),"Safe Zone",0 end;fz=vec3(fx):dist(vec3(planet.center))if fz<dH then fB=true end;if c(fz-dH)<c(fy-fD)then return fB,c(fz-dH),planet.name,planet.bodyId else return fB,c(fy-fD),"Safe Zone",0 end end;local function fE(dd)if aH==1920 then return dd else return z(aH*dd/1920,0)end end;local function fF(dd)if aI==1080 then return dd else return z(aI*dd/1080,0)end end;local function fG()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function fH()local fI="TRAVEL"if not bJ then fI="CRUISE"end;if Autopilot then fI="AUTOPILOT"end;return fI end;local function fJ(fK,aV,cp,fL,fM,fN,fO,fP)local fQ=1;local fR=2;local fS=3;local fT=4;local fU=5;local fV=6;local fW=""local fX=0;local fY=fuelY;local fZ=fuelY+5;if not BarFuelDisplay then fZ=fZ+5 end;if l()==1 and not RemoteHud then fY=fY-50;fZ=fZ-50 end;if fM=="ATMO"then fW="atmofueltank"elseif fM=="SPACE"then fW="spacefueltank"else fW="rocketfueltank"end;fX=_G[fW.."_size"]if#fN>0 then for i=1,#fN do local f_=string.sub(fN[i][fR],1,12)local g0=0;for g1=1,fX do if fN[i][fR]==f(unit[fW.."_"..g1].getData()).name then g0=g1;break end end;if aV or fO[i]==nil or fP[i]==nil then local g2=0;local g3=0;local g4=0;local g5=0;local g6=p()if g0~=0 then fP[i]=f(unit[fW.."_"..g0].getData()).percentage;fO[i]=f(unit[fW.."_"..g0].getData()).timeLeft;if fO[i]=="n/a"then fO[i]=0 end else g4=k(fN[i][fQ])-fN[i][fT]g2=fN[i][fS]fP[i]=d(0.5+g4*100/g2)g3=fN[i][fU]g5=fN[i][fV]if g3<=g4 then fO[i]=0 else fO[i]=d(0.5+g4/((g3-g4)/(g6-g5)))end;fN[i][fU]=g4;fN[i][fV]=g6 end end;if f_==fL then f_=e("%s %d",fM,i)end;if g0==0 then f_=f_.." *"end;local g7;if fO[i]==0 then g7=""else g7=d3(fO[i])end;if fP[i]~=nil then local g8=d(fP[i]*2.55)local g9=e("rgb(%d,%d,%d)",255-g8,g8,0)local cs=""if g7~=""and fO[i]<120 or fP[i]<5 then if aV then cs=[[class="red"]]end end;if BarFuelDisplay then table.insert(fK,e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cp,fZ,g9,fP[i],cp,fZ,cp+2,fZ+10,fP[i],g7))fK[#fK+1]=co(cp,fY,f_,cs.."txtstart pdim txtfuel")fY=fY-30;fZ=fZ-30 else fK[#fK+1]=co(cp,fY,f_,cs.." pdim txtfuel")fK[#fK+1]=co(cp,fZ,e("%d%% %s",fP[i],g7),"pdim txtfuel","fill:"..g9)fY=fY+30;fZ=fZ+30 end end end end end;local function ga(fK,dP)if dP<200000 and not aq or dP and aq then local gb=0;if c(bD)>1 then gb=45*math.log(c(bD),10)if bD<0 then gb=-gb end end;fK[#fK+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bD),d(gb))end;return fK end;local function gc(gd)local ge=-bC;gd=gd-gd:project_on(ge)local gf=vec3(0,0,1)gf=gf-gf:project_on(ge)local gg=gf:cross(ge)local gb=gf:angle_between(gd)*constants.rad2deg;if gd:dot(gg)<0 then gb=360-gb end;return gb end;local function gh(fK,centerX,centerY,gi,gj,bV)local gk=circleRad;local gl=20;local gm=d(gi)if bV then for i=-45,45,5 do local gn=i;fK[#fK+1]=e([[<g transform="rotate(%f,%d,%d)">]],gn,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fK[#fK+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gk+gl-len,centerX,centerY+gk+gl)end;fK[#fK+1]=co(centerX,centerY+gk+gl-35,gj,"pdim txt txtmid")fK[#fK+1]=co(centerX,centerY+gk+gl-25,gm.." deg","pdim txt txtmid")fK[#fK+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gi,centerX,centerY)fK[#fK+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gk+gl-20,centerX+5,centerY+gk+gl-20,centerX,centerY+gk+gl-15)fK[#fK+1]="</g>"end;local go=gm;if bV then go=gc(by)end;local gp=20;local gq=d(go)local gr=0;local gs=centerY+gk+gl+20;local gt=centerX;if gj~="YAW"then gs=fF(130)gt=fE(960)end;local gu=[[<path class="txttick line" d="]]local gv=d(gq-(gp+10)-gq%5+0.5)for i=gv+60,gv,-5 do local cp=gt-(-i*5+go*5)if i%10==0 then gr=10;local num=i;if num==360 then num=0 elseif num>360 then num=num-360 elseif num<0 then num=num+360 end;fK[#fK+1]=co(cp+5,gs-12,num)elseif i%5==0 then gr=5 end;if gr==10 then gu=e([[%s M %f %f v %d]],gu,cp,gs-5,gr)else gu=e([[%s M %f %f v %d]],gu,cp,gs-2.5,gr)end end;fK[#fK+1]=gu..[["/>]]fK[#fK+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],gt-5,gs+10,gt+5,gs+10,gt,gs+5)if bV then gj="HDG"end;fK[#fK+1]=co(gt,gs+25,gq.."deg","pdim txt txtmid","")fK[#fK+1]=co(gt,gs+35,gj,"pdim txt txtmid","")end;local function gw(fK,gx,gi,centerX,centerY,bV,gy,f6)local gk=circleRad;local gz=d(gk*3/5)if gk>0 then local gA=d(gx)local len=0;local gu=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gi,centerX,centerY)if not aq then gu=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fK[#fK+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gk-1,centerX,centerY)fK[#fK+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gA-30-gA%5+0.5),d(gA+30+gA%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cq=centerY+-i*5+gx*5;if len==30 then gu=e([[%s M %d %f h %d]],gu,centerX-gz-len,cq,len)if aq then fK[#fK+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gi,centerX,centerY,centerX-gz+10,cq,i)fK[#fK+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gi,centerX,centerY,centerX+gz-10,cq,i)if i==0 or i==180 or i==-180 then fK[#fK+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gi,centerX,centerY,centerX-gz+20,cq,gz*2-40)end else fK[#fK+1]=co(centerX-gz+10,cq,i,"pdim txt txtmid")fK[#fK+1]=co(centerX+gz-10,cq,i,"pdim txt txtmid")end;gu=e([[%s M %d %f h %d]],gu,centerX+gz,cq,len)else gu=e([[%s M %d %f h %d]],gu,centerX-gz-len,cq,len)gu=e([[%s M %d %f h %d]],gu,centerX+gz,cq,len)end end;fK[#fK+1]=gu..[["/>]]local gB="PITCH"if not bV then gB="REL PITCH"end;if gx>90 and not aq then gx=90-(gx-90)elseif gx<-90 and not aq then gx=-90-(gx+90)end;if gk>200 then if aq then if f6>P then fK[#fK+1]=co(centerX,centerY-15,"Yaw","pdim txt txtmid")fK[#fK+1]=co(centerX,centerY+20,gy,"pdim txt txtmid")end;fK[#fK+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gi,centerX,centerY)else fK[#fK+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fK[#fK+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gz+25,centerY-5,centerX-gz+20,centerY,centerX-gz+25,centerY+5,centerX-gz+50,centerY+4,gA)fK[#fK+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gz-25,centerY-5,centerX+gz-20,centerY,centerX+gz-25,centerY+5,centerX+gz-30,centerY+4,gA)fK[#fK+1]="</g>"end;local gC=d(gk/3)fK[#fK+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gC,centerY,gk-gC)if not aq and bV then fK[#fK+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gi,centerX,centerY,centerX-gz+10,centerY,gz*2-20)end;fK[#fK+1]="</g>"if gk<200 then if aq and f6>P then fK[#fK+1]=co(centerX,centerY-gk,gB,"pdim txt txtmid")fK[#fK+1]=co(centerX,centerY-gk+10,gA,"pdim txt txtmid")fK[#fK+1]=co(centerX,centerY-15,"Yaw","pdim txt txtmid")fK[#fK+1]=co(centerX,centerY+20,gy,"pdim txt txtmid")else fK[#fK+1]=co(centerX,centerY-gk,gB,"pdim txt txtmid")fK[#fK+1]=co(centerX,centerY-gk+15,gA,"pdim txt txtmid")end end end end;local function gD(fK,dP,bV)local gE=altMeterX;local gF=altMeterY;local gG=78;local gH=19;local gI=ao;if ao~=-1 then fK[#fK+1]=co(gE+gG,gF+gH+20,e("AGL: %.1fm",ao),"pdim altsm txtend")end;if bV and(dP<200000 and not aq or dP and aq)then table.insert(fK,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gE-1,gF-4,gG+2,gH+6,gE+1,gF-1,gG-4,gH))local cM=0;local gJ=1;local gK=0;local gL=dP<0;local gM=9;if gL then gM=0 end;local dP=c(dP)while cM<6 do local gN=11;local gO=16;local gP=9;local gQ=14;local cs="altsm"if cM>2 then gO=gO+3;gN=gN+2;gQ=gQ+2;gP=gP-6;cs="altbig"end;if gL then cs=cs.." red"end;local gR=dP/gJ%10;local gS=d(gR)local gT=d((gS+1)%10)local gU=gK;if cM==0 then gU=gR-gS;if gL then gU=1-gU end end;if gL and(cM==0 or gK~=0)then local gV=gT;gT=gS;gS=gV end;local gW=gO*(gU-1)local gX=gW+gO;local cp=gE+gP+(6-cM)*gN;local cq=gF+gQ;fK[#fK+1]=co(cp,cq+gW,gT,cs)fK[#fK+1]=co(cp,cq+gX,gS,cs)cM=cM+1;gJ=gJ*10;if gS==gM then gK=gU else gK=0 end end;table.insert(fK,[[</g></g>]])end end;local function gY(f9)f9=vec3(f9)local gZ=-math.deg(m(f9.y,f9.z))+180;gZ=gZ-90;if gZ<0 then gZ=360+gZ end;if gZ>180 then gZ=-180+gZ-180 end;return-gZ end;local function g_(f9)f9=vec3(f9)local go=math.deg(m(f9.y,f9.x))-90;if go<-180 then go=360+go end;return go end;local function h0(fK,f9,f6,centerX,centerY)if f6>5 and not aq or f6>P then local gk=circleRad;local h1=20;local h2=20;local h3=vec3(f9)local h4=gY(h3)local h5=g_(h3)local h6=14;local h7=h6/2;local h8=-h5/h2*gk;local h9=h4/h1*gk;local cp=centerX+h8;local cq=centerY+h9;local ai=x(h8^2+h9^2)local ha=[[<circle
                            cx="]]..cp..[["
                            cy="]]..cq..[["
                            r="]]..h7/h6 ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cp..[["
                            cy="]]..cq..[["
                            r="]]..h7 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cp-h6 ..[[,]]..cq..[[ h ]]..h7 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cp+h7 ..[[,]]..cq..[[ h ]]..h7 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cp..[[,]]..cq-h6 ..[[ v ]]..h7 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ai<gk then fK[#fK+1]=ha else local gb=m(h9,h8)local hb=4;local hc=centerX+gk*math.cos(gb)local hd=centerY+gk*math.sin(gb)fK[#fK+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gb*180/math.pi,hc,hd,hc-hb,hd-hb/2,hb*2,hb,hc+hb,hd-hb,hb,hb,-hb,hb)end;if not aq then h4=gY(-h3)h5=g_(-h3)h8=-h5/h2*gk;h9=h4/h1*gk;cp=centerX+h8;cq=centerY+h9;ai=x(h8^2+h9^2)if ai<gk then local he=[[<circle
                                    cx="]]..cp..[["
                                    cy="]]..cq..[["
                                    r="]]..h7 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cp..[[,]]..cq-h6 ..[[ v ]]..h7 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cp..[[,]]..cq..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cp..[[,]]..cq..[[)" />
                                <path
                                    d="M ]]..cp-h7 ..[[,]]..cq..[[ h ]]..h6 ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cp..[[,]]..cq..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cp..[[,]]..cq..[[)"/>]]fK[#fK+1]=he end end end end;local function hf(fK,fI,hg,hh)hg=d(hg+0.5)local fY=throtPosY+10;local fZ=throtPosY+20;if l()==1 and not RemoteHud then fY=55;fZ=65 end;local hi="CRUISE"local unit="km/h"local cv=hh;if fI=="TRAVEL"or fI=="AUTOPILOT"then hi="THROT"unit="%"cv=hg;local hj="dim"if hg<0 then hj="red"end;fK[#fK+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hj,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(hg),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fK[#fK+1]=co(throtPosX+10,fY,hi,"pbright txtstart")fK[#fK+1]=co(throtPosX+10,fZ,e("%.0f %s",cv,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bJ and L then hg=d(M*100+0.5)local hj="red"if hg<0 then hj="red"end;fK[#fK+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hj,1-c(hg),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fK[#fK+1]=co(throtPosX+10,fY+40,"LIMIT","pbright txtstart")fK[#fK+1]=co(throtPosX+10,fZ+40,hg.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then fK[#fK+1]=co(throtPosX+10,fY-40,"LIMIT: "..bh.." km/h","dim txtstart")elseif not aq and Autopilot then fK[#fK+1]=co(throtPosX+10,fY-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hk(fK,hl)local hm=throtPosY-10;local hn=throtPosX+10;fK[#fK+1]=co(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then hm=75 end;fK[#fK+1]=co(hn,hm,d(hl).." km/h","pbright txtbig txtstart")end;local function ho(fK)fK[#fK+1]=co(fE(1900),fF(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fK[#fK+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fK[#fK+1]=co(fE(960),fF(550),"Warning: Invalid Control Scheme Detected","warnings")fK[#fK+1]=co(fE(960),fF(600),"Keyboard Scheme must be selected","warnings")fK[#fK+1]=co(fE(960),fF(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hp=fE(960)local hq=fF(860)local hr=fF(880)local hs=fF(900)local ht=fF(960)local hu=fF(200)local hv=fF(250)local hw=fF(960)if l()==1 and not RemoteHud then hq=fF(135)hr=fF(155)hs=fF(175)hu=fF(115)hv=fF(95)end;if BrakeIsOn then fK[#fK+1]=co(hp,hq,"Brake Engaged","warnings")elseif K>0 then fK[#fK+1]=co(hp,hq,"Auto-Brake Engaged","warnings","opacity:"..K)end;if aq and bc and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bH and not VertTakeOff and not AutoTakeoff then fK[#fK+1]=co(hp,hu+50,"** STALL WARNING **","warnings")cb("stall","SW",2)end end;if bT then fK[#fK+1]=co(hp,hu+70,"Flight Assist in Progress","warnings")end;if ax then fK[#fK+1]=co(hp,hw,"Gyro Enabled","warnings")end;if GearExtended then if R then fK[#fK+1]=co(hp,hr,"Gear Extended","warn")else fK[#fK+1]=co(hp,hr,"Landed (G: Takeoff)","warnings")end;local hx=cB(a:getTargetGroundAltitude())fK[#fK+1]=co(hp,hs,"Hover Height: "..hx,"warn")end;if a6 then fK[#fK+1]=co(hp,ht+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bH and AntigravTargetAltitude~=nil then if c(as-antigrav.getBaseAltitude())<501 then fK[#fK+1]=co(hp,hu+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fK[#fK+1]=co(hp,hu+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fK[#fK+1]=co(hp,hu+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fK[#fK+1]=co(hp,hu+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Z then fK[#fK+1]=co(hp,hu+20,"Follow Mode Engaged","warn")elseif Reentry then fK[#fK+1]=co(hp,hu+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local hx=cB(HoldAltitude,2)if VertTakeOff then if bH then hx=cB(antigrav.getBaseAltitude(),2).." AGG singularity height"end;fK[#fK+1]=co(hp,hu,"VTO to "..hx,"warn")elseif AutoTakeoff and not IntoOrbit then if am then fK[#fK+1]=co(hp,hu,"Takeoff to "..AutopilotTargetName,"warn")else fK[#fK+1]=co(hp,hu,"Takeoff to "..hx,"warn")end;if BrakeIsOn and not VertTakeOff then fK[#fK+1]=co(hp,hu+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fK[#fK+1]=co(hp,hu,"Altitude Hold: "..hx,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then fK[#fK+1]=co(hp,hu+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then fK[#fK+1]=co(hp,hu+20,"Aligning trajectory","warn")elseif ar<0.05 then fK[#fK+1]=co(hp,hu+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bj~=nil then fK[#fK+1]=co(hp,hu,bj,"warn")end end;if IntruderAlertSystem and safeMass==-1 then fK[#fK+1]=co(hp,hu+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bF.."kg DETECTED","warnings")cb("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then fK[#fK+1]=co(hp,hu,"Brake-Landing","warnings")else fK[#fK+1]=co(hp,hu,"Coast-Landing","warnings")end end;if ProgradeIsOn then fK[#fK+1]=co(hp,hu,"Prograde Alignment","crit")end;if RetrogradeIsOn then fK[#fK+1]=co(hp,hu,"Retrograde Alignment","crit")end;local hy,eq,er=b1:getPlanetarySystem(0):castIntersections(bE,bA:normalize(),function(eb)if eb.noAtmosphericDensityAltitude>0 then return eb.radius+eb.noAtmosphericDensityAltitude else return eb.radius+eb.surfaceMaxAltitude*1.5 end end)local hz=eq;if er~=nil and eq~=nil then hz=math.min(er,eq)end;if hz~=nil and ar==0 then local hx=cB(hz)local travelTime=b2.computeTravelTime(bB,0,hz)local hA="Collision"if hy.noAtmosphericDensityAltitude>0 then hA="Atmosphere"end;fK[#fK+1]=co(hp,hv+20,hy.name.." "..hA.." "..d3(travelTime).." In "..hx,"crit")end;if bW then local type;if string.find(bW,"COLLISION")then type="warnings"else type="crit"end;fK[#fK+1]=co(hp,hv+20,bW,type)end;if VectorToTarget and not IntoOrbit then fK[#fK+1]=co(hp,hu+35,VectorStatus,"warn")end;fK[#fK+1]="</g>"return fK end;local function hB(f6)return d(z(f6*3.6,0)+0.5).." km/h"end;local function hC(fK)local hD=OrbitMapX;local hE=OrbitMapY;local hF=OrbitMapSize;local hG=4;local hH=15;local cp=0;local cq=0;local hI,hJ,hK,hL;local function hM(type)local hN,C,f6,hO;if type=="Periapsis"then hN=orbit.periapsis.altitude;C=orbit.timeToPeriapsis;f6=orbit.periapsis.speed;hO=35 else hN=orbit.apoapsis.altitude;C=orbit.timeToApoapsis;f6=orbit.apoapsis.speed;hO=-35 end;fK[#fK+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cp+hO,cq-5,hD+hF/2-hI+hL,cq-5)fK[#fK+1]=co(cp,cq,type)cq=cq+hH;local hx=cB(hN)fK[#fK+1]=co(cp,cq,hx)cq=cq+hH;fK[#fK+1]=co(cp,cq,d3(C))cq=cq+hH;fK[#fK+1]=co(cp,cq,hB(f6))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hE=hE+hG;cp=hD+hF+hD/2+hG;cq=hE+hF/2+5+hG;hI=hF/4;hL=0;fK[#fK+1]=[[<g class="pbright txtorb txtmid">]]fK[#fK+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hF+hD*2,hF+hE,hG,hG)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hK=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hI*2)hJ=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hK*(1-orbit.eccentricity)hL=hI-orbit.periapsis.altitude/hK-planet.radius/hK;local hP=""if orbit.periapsis.altitude<=0 then hP='redout'end;fK[#fK+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hP,hD+hF/2+hL+hG,hE+hF/2+hG,hI,hJ)fK[#fK+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hD+hF/2+hG,hE+hF/2+hG,planet.radius/hK)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hM("Apoapsis")end;cq=hE+hF/2+5+hG;cp=hD-hD/2+10+hG;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hM("Periapsis")end;fK[#fK+1]=co(hD+hF/2+hG,planet.name,20+hG,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hQ=orbit.timeToApoapsis/orbit.period*2*math.pi;local hR=hI*math.cos(hQ)local hS=hJ*math.sin(hQ)fK[#fK+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hD+hF/2+hR+hL+hG,hE+hF/2+hS+hG)end;fK[#fK+1]=[[</g>]]return fK else return fK end end;local function hT()if radarPanelID~=nil and ak==0 then s(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then s(perisPanelID)perisPanelID=nil end else if ak==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;ak=0 end end;local function hU(fK)local cp=30;local cq=275;local hV={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hW={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere"}local hX={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local hY={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle InHud Sounds","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if aq then ce(hV,hW)table.insert(hV,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(hV,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ao~=-1 then if antigrav then if bH then table.insert(hV,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hV,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hV,"Alt-6: Begins Vertical Takeoff.")else table.insert(hV,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hV,"G: Begin BrakeLanding or Land")end else ce(hV,hX)end;if AltitudeHold then table.insert(hV,"Alt-Spacebar/Alt-C will raise/lower target height")end;ce(hV,hY)for i=1,#hV do cq=cq+12;fK[#fK+1]=co(cp,cq,hV[i],"pdim txttick txtstart")end end;local function hZ(h_,i0)local i1;local i2=(i0-h_):normalize()local fa=(bE-h_):dot(i2)/i2:dot(i2)if fa<=0.then return(bE-h_):len()elseif fa>=(i0-h_):len()then return(bE-i0):len()end;local i3=h_+fa*i2;i1=(i3-bE):len()return i1 end;local function i4()local i1;local i5=nil;local i6=nil;local i7=nil;for dc,i8 in pairs(aX[0])do if i8.hasAtmosphere then local ai=hZ(planet.center,i8.center)if i5==nil or ai<i5 then i6=i8;i5=ai;i7=planet end;if ab and ab.hasAtmosphere and ab.name~=planet.name then local ew=hZ(ab.center,i8.center)if ew<i5 then i6=i8;i5=ew;i7=ab end end end end;local i9=fE(1770)local ia=fF(330)if i5 then local ib="txttick "local ic=500000;if i5<i6.radius+ic or i5<i7.radius+ic then if bQ then ib="txttick red "else ib="txttick orange "end end;i1=cB(i5,2)bS=co(i9,ia,"Pipe ("..i7.name.."--"..i6.name.."): "..i1,ib.."pbright txtmid")end end;local id={}function id.HUDPrologue(fK)bQ,fv,_,_=fw(bE)if not bQ then G=PvPR;I=PvPG;H=PvPB else G=SafeR;I=SafeG;H=SafeB end;az=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]aA=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local ie=az;local ig=aA;local ih=az;local ii=aA;if fG()and not brightHud then ie=[[rgb(]]..d(G*0.4+0.5)..","..d(I*0.4+0.5)..","..d(H*0.3+0.5)..[[)]]ig=[[rgb(]]..d(G*0.3+0.5)..","..d(I*0.3+0.5)..","..d(H*0.2+0.5)..[[)]]end;fK[#fK+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],ie,ie,ih,ih,ig,ig,ii,ii,aH,aI)return fK end;function id.DrawVerticalSpeed(fK,dP)ga(fK,dP)end;function id.UpdateHud(fK)local dP=as;local f9=core.getVelocity()local f6=vec3(f9):len()local gZ=bK;local ij=bL;local gi=ij;local gx=bK;local hg=d(unit.getThrottle())local hl=f6*3.6;local hh=unit.getAxisCommandValue(0)local ik=fE(1770)local il=fF(310)if AtmoSpeedAssist and bJ then hh=J;hg=J*100 end;local fI=fH()local gj="ROLL"if hg==nil then hg=0 end;if not bV then if f6>5 then gZ=gY(f9)ij=g_(f9)else gZ=0;ij=0 end;gj="YAW"end;if fv>50000 and not aq then local im;if fv>200000 then im=z(fv/200000,2).." su"else im=z(fv/1000,1).." km"end;fK[#fK+1]=co(ik,il,"PvP Boundary: "..im,"pbright txtbig txtmid")end;fK[#fK+1]=aj;fK[#fK+1]=aE;fK[#fK+1]=bR;if bS~=""then fK[#fK+1]=bS end;if aW%aQ==0 then aV=true end;if fuelX~=0 and fuelY~=0 then fJ(fK,aV,fuelX,"Atmospheric ","ATMO",aJ,aT,aU)fJ(fK,aV,fuelX+120,"Space fuel t","SPACE",aK,aR,aS)fJ(fK,aV,fuelX+240,"Rocket fuel ","ROCKET",aL,aO,aP)end;if aV then aV=false;aW=0 end;aW=aW+1;ga(fK,dP)if l()==0 or RemoteHud then if not fG()or brightHud then if bV then gh(fK,centerX,centerY,gi,gj,bV)gw(fK,gx,gi,centerX,centerY,bV,d(g_(f9)),f6)else gh(fK,centerX,centerY,ij,gj,bV)gw(fK,gZ,ij,centerX,centerY,bV,d(ij),f6)end;gD(fK,dP,bV)h0(fK,f9,f6,centerX,centerY)end end;hf(fK,fI,hg,hh)hk(fK,hl)ho(fK)hC(fK)if showHelp then hU(fK)end;return fK end;function id.HUDEpilogue(fK)fK[#fK+1]="</svg>"return fK end;function id.ExtraData(fK)local io=fE(1240)local ip=fF(55)local iq=ip+10;local ir;local is=0;local fI=fH()if VertTakeOffEngine then fI=fI.."-VERTICAL"end;if TurnBurn then fI="TB-"..fI end;if not stablized then fI=fI.."-DeCoupled"end;local it=vec3(core.getWorldAcceleration()):len()/9.80665;ir=core.g()fK[#fK+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then io=fE(1120)ip=fF(55)iq=ip+10 elseif aq then local iu=fE(770)fK[#fK+1]=co(iu,ip,"ATMOSPHERE","pdim txt txtend")fK[#fK+1]=co(iu,iq,e("%.2f",ar),"pdim txt txtend","")end;fK[#fK+1]=co(io,ip,"GRAVITY","pdim txt txtend")fK[#fK+1]=co(io,iq,e("%.2f",ir/9.80665),"pdim txt txtend")fK[#fK+1]=co(io,ip+20,"ACCEL","pdim txt txtend")fK[#fK+1]=co(io,iq+20,e("%.2f",it),"pdim txt txtend")fK[#fK+1]=co(fE(960),fF(180),fI,"txtbig txtmid")end;function id.DrawOdometer(fK,ac,TotalDistanceTravelled,ad)local ir;local iv=0;local iw=0;local is=0;if aq then is=LastMaxBrakeInAtmo else is=LastMaxBrake end;maxThrust=a:maxForceForward()ir=core.g()if ir>0.1 then iw=av*ir;iv=maxThrust/ir end;fK[#fK+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fE(660),fE(700),fF(35),fE(960),fF(55),fE(1240),fF(35),fE(1280))if l()==0 or RemoteHud then fK[#fK+1]=co(fE(700),fF(20),e("Trip: %.2f km",ac),"txtstart")fK[#fK+1]=co(fE(700),fF(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fK[#fK+1]=co(fE(830),fF(20),"Trip Time: "..d3(ad),"txtstart")fK[#fK+1]=co(fE(830),fF(30),"Total Time: "..d3(TotalFlightTime),"txtstart")fK[#fK+1]=co(fE(970),fF(20),e("Mass: %.2f Tons",av/1000),"txtstart")fK[#fK+1]=co(fE(1240),fF(10),e("Max Brake: %.2f kN",is/1000),"txtend")fK[#fK+1]=co(fE(1240),fF(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if ir>0.1 then fK[#fK+1]=co(fE(970),fF(30),e("Max Mass: %.2f Tons",iv/1000),"txtstart")fK[#fK+1]=co(fE(1240),fF(20),e("Req Thrust: %.2f kN",iw/1000),"txtend")else fK[#fK+1]=co(fE(970),fF(30),"Max Mass: n/a","txtstart")fK[#fK+1]=co(fE(1240),fF(20),"Req Thrust: n/a","txtend")end end;fK[#fK+1]="</g>"return fK end;function id.DrawWarnings(fK)return ho(fK)end;function id.DisplayOrbitScreen(fK)return hC(fK)end;function id.DisplayMessage(fK,hx)if hx~="empty"then local cq=310;for ix in string.gmatch(hx,"([^\n]+)")do cq=cq+35;fK[#fK+1]=co("50%",cq,ix,"msg")end end;if ah~=0 then unit.setTimer("msgTick",ah)ah=0 end end;function id.DrawDeadZone(fK)fK[#fK+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function id.UpdatePipe()if aq then bS=""return end;i4()end;function id.UpdateRadarRoutine()local function iy(iz,iA,iB,iC,iD,iE,iF,iG)iA,iC,iE,iG=vec3(iA),vec3(iC),vec3(iE),vec3(iG)local iH,iI,iJ=iz*iz,iB*iB,iD*iD;local b_=iC-iA;local iK=b_:normalize()local iL=b_:len()local c0=iE-iA;local iM=(c0-c0:project_on(iK)):normalize()local iN,iO=c0:dot(iK),c0:dot(iM)local iP=iN*iN+iO*iO;local iQ=iK:cross(iM)local cp=(iH-iI+iL*iL)/(2*iL)local cq=(iH-iJ+iP-2*iN*cp)/(2*iO)local dq=iH-cp^2-cq^2;local iR=x(dq)local iS=iA+iK*cp+iM*cq+iQ*iR;local iT=iA+iK*cp+iM*cq-iQ*iR;if c((iG-iS):len()-iF)<c((iG-iT):len()-iF)then return iS else return iT end end;local function iU(iV,fb,iW)local iX=iV.pts;local cM=#iX;local iY=iV.ref;if cM>3 then local iZ,i_,j0,j1=iX[cM],iX[cM-1],iX[cM-2],iX[cM-3]iV.ref=iW;local c7=iy(iZ[1],iZ[2],i_[1],i_[2],j0[1],j0[2],j1[1],j1[2])local cp,cq,iR=c7.x,c7.y,c7.z;if cp==cp and cq==cq and iR==iR then cp=cp+iY[1]cq=cq+iY[2]iR=iR+iY[3]local j2=vec3(cp,cq,iR)if not iV.lastPos then iV.center=j2 elseif(iV.lastPos-j2):len()<2 then iV.center=j2;iV.skipCalc=true end;iV.lastPos=j2 end;iV.pts={}else local j3={iW[1]-iY[1],iW[2]-iY[2],iW[3]-iY[3]}iX[cM+1]={fb,j3}end end;if radar_1 then local j4=radar_1.getEntries()local j5={}local j6=radar_1.getData()local j7=j6:gmatch('{"constructId[^}]*}[^}]*}')local j8=fE(1770)local j9=fF(350)local iW=getTrueWorldPos()if#j4>0 then local ja={}local jb,jc,jd,je=0,0,0,0;for dd in j7 do local dX,ai,jf=dd:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local jg=13;ai=y(ai)if radar_1.hasMatchingTransponder(dX)==1 then table.insert(ja,dX)end;if ai>0 and radar_1.getConstructType(dX)=="static"or radar_1.getConstructType(dX)=="space"then jd=jd+1;if CollisionSystem then local f_=radar_1.getConstructName(dX)local iV=bU[dX]if iV==nil then bU[dX]={pts={},ref=iW,name=f_,i=0,radius=jg,skipCalc=false}local jh={XS=13,S=27,M=55,L=110,XL=221}jg=jh[jf]bU[dX].radius=jg+F;iV=bU[dX]end;if not iV.skipCalc then iU(iV,ai,iW)end;if iV.center then table.insert(j5,iV)end;jc=jc+1 end end;jb=jb+1;if jb>500 or jc>50 then coroutine.yield()jb,jc=0,0 end end;if#j5>0 then local eb,ji,jj,jk;local jl=0;local jm=b1:getPlanetarySystem(0)jk=bA:normalize()while jl<#j5 do coroutine.yield()local jn={table.unpack(j5,jl,math.min(jl+75,#j5))}eb,ji,jj=jm:castIntersections(bE,jk,nil,nil,jn)if eb and jj then bX={eb,ji,jj}break end;jl=jl+75 end;if not eb then bX=nil end;je=#j5;j5={}else bX=nil end;local jo=j6:find('identifiedConstructs":%[%]')if jo==nil and perisPanelID==nil then ak=1;hT()end;if jo~=nil and perisPanelID~=nil then hT()end;if radarPanelID==nil then hT()end;local jp,jq;if bV then jq="Buildings"else jq="Stations"end;if CollisionSystem then jp=je.."/"..jd.." "..jq.." : "..#j4-jd.." Ships"else jp=jd.." "..jq.." : "..#j4-jd.." Ships"end;bR=co(j8,j9,jp,"pbright txtbig txtmid")if#ja>0 then local cq=fF(15)local cp=fE(1370)bR=bR..co(cp,cq,"Friendlies In Range","pbright txtbig txtmid")for dc,dd in pairs(ja)do cq=cq+20;bR=bR..co(cp,cq,radar_1.getConstructName(dd),"pdim txtmid")end end else local jr;jr=j6:find('worksInEnvironment":false')if jr then bR=co(j8,j9,"Radar: Jammed","pbright txtbig txtmid")else bR=co(j8,j9,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ak=0;hT()end end end end;function id.UpdateRadar()local js=coroutine.status(UpdateRadarCoroutine)if js=="suspended"then local cv,jt=coroutine.resume(UpdateRadarCoroutine)if jt then system.print("ERROR UPDATE RADAR: "..jt)end elseif js=="dead"then UpdateRadarCoroutine=coroutine.create(id.UpdateRadarRoutine)local cv,jt=coroutine.resume(UpdateRadarCoroutine)end end;function id.DrawSettings(fK)if#bN>0 then local cp=fE(640)local cq=fF(200)fK[#fK+1]=[[<g class="pbright txtvspd txtstart">]]for dc,dd in pairs(bN)do fK[#fK+1]=co(cp,cq,dd..": ".._G[dd])cq=cq+20;if dc%12==0 then cp=cp+fE(350)cq=fF(200)end end;fK[#fK+1]=co(fE(640),fF(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fK[#fK+1]="</g>"end;return fK end;UpdateRadarCoroutine=coroutine.create(id.UpdateRadarRoutine)return id end;local function ju()local function jv()local function jw(jx,jy)return jx.name<jy.name end;bP={}for dc,dd in pairs(aX[0])do bP[#bP+1]={name=dd.name,index=dc}end;table.sort(bP,jw)end;local de={}function de.UpdateAtlasLocationsList()jv()end;function de.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ab=nil;CustomTarget=nil;return true end;local jz=bP[AutopilotTargetIndex].index;local jA=aX[0][jz]if jA.center then AutopilotTargetName=jA.name;ab=b1[0][jz]if CustomTarget~=nil then if ar==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jA;for _,dd in pairs(b1[0])do if dd.name==CustomTarget.planetname then ab=dd;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ab.center)else AutopilotTargetCoords=CustomTarget.position end;if ab.planetname~="Space"then if ab.hasAtmosphere then AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=b4(ab):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function de.adjustAutopilotTargetIndex(ge)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if ge==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bP then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bP end end;if AutopilotTargetIndex==0 then b6.UpdateAutopilotTarget()else local jz=bP[AutopilotTargetIndex].index;local jA=aX[0][jz]if jA.name=="Space"or iphCondition=="Custom Only"and jA.center or iphCondition=="No Moons"and string.find(jA.name,"Moon")~=nil then if ge==nil then b6.adjustAutopilotTargetIndex()else b6.adjustAutopilotTargetIndex(1)end else b6.UpdateAutopilotTarget()end end else a1="Disengage autopilot before changing Interplanetary Helper"cb("iph","AP")end end;function de.findAtlasIndex(jB)for dc,dd in pairs(jB)do if dd.name and dd.name==CustomTarget.name then return dc end end;return-1 end;for dc,dd in pairs(SavedLocations)do table.insert(aX[0],dd)end;jv()de.UpdateAutopilotTarget()return de end;local function jC()local jD={}local jE={vec3(bA),-vec3(bA),vec3(bx),-vec3(bx),vec3(bz),-vec3(bz)}local function jF(f6)local jG=AutopilotEndSpeed;if not Autopilot then jG=0 end;if not aq then return b2.computeDistanceAndTime(f6,jG,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b2.computeDistanceAndTime(f6,jG,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jH(f6)local jG=AutopilotEndSpeed;if not Autopilot then jG=0 end;return b2.computeDistanceAndTime(f6,jG,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;function jD.GetAutopilotBrakeDistanceAndTime(f6)return jF(f6)end;function jD.GetAutopilotTBBrakeDistanceAndTime(f6)return jH(f6)end;local function jI(jJ,jK,jL)jK=jK:project_on_plane(jJ)jL=jL:project_on_plane(jJ)return m(jK:cross(jL):dot(jJ),jK:dot(jL))end;local function jM()local function jN()local jO=-1;local jP=-1;if vBooster then jO=vBooster.distance()end;if hover then jP=hover.distance()end;if jO~=-1 and jP~=-1 then if jO<jP then return jO else return jP end elseif jO~=-1 then return jO elseif jP~=-1 then return jP else return-1 end end;local jQ=jN()local jR=-1;if telemeter_1 then jR=telemeter_1.getDistance()end;if jQ~=-1 and jR~=-1 then if jQ<jR then return jQ else return jR end elseif jQ~=-1 then return jQ else return jR end end;local function jS(planet,es,jT)local function jU(jV,dI)local ey=vec3(dI)if jV.bodyId==0 then return setmetatable({latitude=ey.x,longitude=ey.y,altitude=ey.z,bodyId=0,systemId=jV.planetarySystemId},MapPosition)end;local ez=ey-jV.center;local ai=ez:len()local dP=ai-jV.radius;local dN=0;local dO=0;if not cy(ai,0)then local eA=m(ez.y,ez.x)dO=eA>=0 and eA or 2*math.pi+eA;dN=math.pi/2-math.acos(ez.z/ai)end;return setmetatable({latitude=math.deg(dN),longitude=math.deg(dO),altitude=dP,bodyId=jV.bodyId,systemId=jV.planetarySystemId},MapPosition)end;local jW=jU(planet,es)jW="::pos{"..jW.systemId..","..jW.bodyId..","..jW.latitude..","..jW.longitude..","..jW.altitude.."}"if jT then return jW else system.setWaypoint(jW)return true end end;function jD.showWayPoint(planet,es,jT)return jS(planet,es,jT)end;function jD.APTick()local function jX()if bX and not BrakeLanding then local eb=bX[1]local ji,jj=bX[2],bX[3]local jY=math.min(ji,jj or ji)local jZ=jY/bB;if(AltitudeHold or VectorToTarget or LockPitch)and not AutoTakeoff and(a7*1.5>jY or jZ<1)then BrakeIsOn=true;cu(0)if AltitudeHold then cG()end;if LockPitch then ToggleLockPitch()end;a1="Autopilot Cancelled due to possible collision"if VectorToTarget then cI()end;StrongBrakes=true;BrakeLanding=true;ba=true end;if jZ<11 then bW=eb.name.." COLLISION "..d3(jZ).." / "..cB(jY,2)else bW=eb.name.." collision "..d3(jZ)end;if jZ<6 then cb("alarm","AL",2)end else bW=false end end;aq=j()>0;ar=j()as=core.getAltitude()ao=jM()C=p()bd=C;bV=unit.getClosestPlanetInfluence()>0;if CollisionSystem then jX()end;if antigrav then bH=antigrav.getState()==1 end;local j_=1;local k0=1;local k1=C-bd;local k2=-math.deg(jI(bx,bA,by))local k3=math.deg(jI(bz,bA,by))local ge=bC*-1;bc=aq and k2<-YawStallAngle or k2>YawStallAngle or k3<-PitchStallAngle or k3>PitchStallAngle;local k4=system.getMouseDeltaX()local k5=system.getMouseDeltaY()if InvertMouse and not a0 then k5=-k5 end;U=0;Y=0;T=0;sys=b1[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=b4(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bA)if as==0 then as=(bE-planet.center):len()-planet.radius end;local ir=planet:getGravity(core.getConstructWorldPos()):len()*av;be=0;b3=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and a0 then if not b8 then af=af+k4;ag=ag+k5 end else af=0;ag=0 end else af=af+k4;ag=ag+k5;ai=x(af*af+ag*ag)if not a0 and l()==0 then if userControlScheme=="virtual joystick"then if af>0 and af>DeadZone then U=U-(af-DeadZone)*MouseXSensitivity elseif af<0 and af<DeadZone*-1 then U=U-(af+DeadZone)*MouseXSensitivity else U=0 end;if ag>0 and ag>DeadZone then T=T-(ag-DeadZone)*MouseYSensitivity elseif ag<0 and ag<DeadZone*-1 then T=T-(ag+DeadZone)*MouseYSensitivity else T=0 end else af=0;ag=0;if userControlScheme=="mouse"then T=(-utils.smoothstep(k5,-100,100)+0.5)*2*j_;U=(-utils.smoothstep(k4,-100,100)+0.5)*2*k0 end end end end;local k6=bB>8334;if bB>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not k6 then a1="Space Speed Engine Shutoff reached"cu(0)end;if not k6 and LastIsWarping then if not BrakeIsOn then cP()end;if Autopilot then cI()end end;LastIsWarping=k6;if aq and ar>0.09 then if bB>bh/3.6 and not AtmoSpeedAssist and not ay then BrakeIsOn=true;ay=true elseif not AtmoSpeedAssist and ay then if bB<bh/3.6 then BrakeIsOn=false;ay=false end end end;if BrakeIsOn then X=1 else X=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local k7=false;if CustomTarget~=nil then k7=cQ(CustomTarget.position-bE,0.1)else k7=cQ(vec3(bA),0.01)end;ba=true;if k7 then cx(d(bh))if(c(bL)<2 or c(bK)>85)and bB>=bh/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;Q=true;al=false;an=true;Autopilot=false;d1()end elseif aq and AtmoSpeedAssist then cu(1)end elseif bB>P then cQ(vec3(bA),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bB>P then cQ(-vec3(bA))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then Q=true;d1()al=false;an=true else al=false;cI()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bB*3.6>bh-250 and c(bD)<25 and ar>=0.1 and(CustomTarget.position-bE):len()>2000+as then cI()an=false end;if VertTakeOff then ba=true;local k8=HoldAltitude;if bD<-30 then a1="Unable to achieve lift. Safety Landing."ae=0;ba=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bH or HoldAltitude<planet.spaceEngineMinAltitude then if bH then k8=antigrav.getBaseAltitude()end;if as<k8-100 then bi=0;ae=15;BrakeIsOn=false elseif bD>0 then BrakeIsOn=true;ae=0 elseif bD<-30 then BrakeIsOn=true;ae=15 elseif as>=k8 then if bH then if Autopilot or VectorToTarget then cE()else BrakeIsOn=true;VertTakeOff=false end;a1="Takeoff complete. Singularity engaged"cb("aggLk","AG")else BrakeIsOn=false;a1="VTO complete. Engaging Horizontal Flight"cb("vtoc","VT")cE()end;ae=0 end else if ar>0.08 then bi=0;BrakeIsOn=false;ae=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bu then bi=0;ae=20 else ae=0;bi=36;cx(3500)end else ba=autoRollPreference;IntoOrbit=true;bs=false;CancelIntoOrbit=false;bm=false;bk=nil;bl=nil;if br==nil then br=planet end;bq=k8;bp=true;VertTakeOff=false end end;if bi~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local k9=q(bi-bK,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(k9)local ka=q(vTpitchPID:get(),-1,1)T=ka end end;if IntoOrbit then local cZ;local kb=false;local kc=cB(bq)if br==nil then br=planet;if VectorToTarget then br=ab end end;if not bp then bq=d(br.radius+br.surfaceMaxAltitude+LowOrbitHeight)if br.hasAtmosphere then bq=d(br.radius+br.noAtmosphericDensityAltitude+LowOrbitHeight)end;bp=true end;if bo.VectorToTarget then cZ=CustomTarget.position-bE end;local kd,ke=b4(br):escapeAndOrbitalSpeed((bE-br.center):len()-br.radius)local kf=bL;if not bm then local kg=false;local kh=false;cu(0)bl=0;bj="Aligning to orbital path - OrbitHeight: "..kc;if bo.VectorToTarget then cQ(cZ:normalize():project_on_plane(bC))kb=by:dot(cZ:project_on_plane(bx):normalize())>0.95 else cQ(bA)kb=k2<0.5;if bB<150 then kb=true end end;T=0;bk=0;if bK<=bk+1 and bK>=bk-1 then kg=true else kg=false end;if kf<=bl+1 and kf>=bl-1 then kh=true else kh=false end;if kg and kh and kb then bk=nil;bl=nil;bm=true end else if bo.VectorToTarget then cQ(cZ:normalize():project_on_plane(bC))elseif bB>150 then cQ(bA)end;T=0;if bo.VectorToTarget then local a7,_=b2.computeDistanceAndTime(bB,bh/3.6,av,0,0,LastMaxBrake)if bs and cZ:len()>15000+a7+as then bj="Orbiting to Target"if as-100<=br.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<br.noAtmosphericDensityAltitude then bs=false end elseif bs or cZ:len()<15000+a7+as then a1="Orbit complete, proceeding with reentry"cb("orCom","OB")AutopilotTargetCoords=CustomTarget.position;Q=true;an=true;bo.VectorToTarget,bo.AutopilotAlign=false,false;cF()d1()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bq*0.9 and as<bq*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bq*0.99 and orbit.apoapsis.altitude>=bq*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bs then if bs then BrakeIsOn=false;cu(0)bk=0;if not bo.VectorToTarget then a1="Orbit complete"cb("orCom","OB")cF()end else bw=bw+1;if bw>=2 then bs=true end end else bj="Adjusting Orbit - OrbitHeight: "..kc;bn=true;cx(ke*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local ki=bD;local kj=as-bq;local kk=c(kj)if bD<10 and c(bK)<10 and kk<100 then ki=bD*2 end;if ki<10 and c(bK)<10 and kk<100 then ki=ki*2 end;if ki<5 and c(bK)<5 and kk<100 then ki=ki*4 end;VSpdPID:inject(ki)bk=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kj)bk=q(bk-q(OrbitAltPID:get(),-15,15),-90,90)end end else local kl=2.75;local km=c(o(kd*kl))local kn=km%50;if kn>0 then km=km-kn+50 end;BrakeIsOn=false;if as<bq*0.8 then bj="Escaping planet gravity - OrbitHeight: "..kc;bk=utils.map(bD,200,0,-15,80)elseif as>=bq*0.8 and as<bq*1.15 then bj="Approaching orbital corridor - OrbitHeight: "..kc;km=km*0.75;bk=utils.map(bD,100,-100,-15,65)elseif as>=bq*1.15 and as<bq*1.5 then bj="Approaching orbital corridor - OrbitHeight: "..kc;km=km*0.75;if bD<0 or bn then bk=utils.map(as,bq*1.5,bq*1.01,-30,0)else bk=utils.map(as,bq*0.99,bq*1.5,0,30)end elseif as>bq*1.5 then bj="Reentering orbital corridor - OrbitHeight: "..kc;bk=-65;local ko=utils.map(bD,-150,-400,1,0.55)km=km*ko end;cx(d(km))end end;if bk~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kp=bk-bK;OrbitPitchPID:inject(kp)local kq=q(OrbitPitchPID:get(),-0.5,0.5)T=kq end end;if Autopilot and ar==0 and not al then local function kr(jp,orbit)system.print(jp)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cu(0)O=false;a1=jp;cb("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bq=as;bp=true end;cF()end end;local ks,kt=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local ku=(CustomTarget.position-ab.center):normalize()local kv=ku:project_on_plane((ab.center-bE):normalize()):normalize()local kw=ab.center+kv*(ab.radius+AutopilotTargetOrbit)local kx=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))if(bE-kw):len()<(bE-kx):len()then ks=kw else ks=kx;AutopilotEndSpeed=0 end;AutopilotTargetCoords=ks;b7.showWayPoint(ab,AutopilotTargetCoords)kt=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kt=true;TargetSet=true;AutopilotRealigned=true;ks=CustomTarget.position+(bE-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local ku=(bE+bA*100000-ab.center):normalize()local kv=ku:project_on_plane((ab.center-bE):normalize()):normalize()if kv:len()<1 then ku=(bE+by*100000-ab.center):normalize()kv=ku:project_on_plane((ab.center-bE):normalize()):normalize()end;ks=ab.center+kv*(ab.radius+AutopilotTargetOrbit)AutopilotTargetCoords=ks;TargetSet=true;kt=true;AutopilotRealigned=true;b7.showWayPoint(ab,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(ks)-bE):len()local hy,eq,er=b1:getPlanetarySystem(0):castIntersections(bE,bA:normalize(),function(eb)if eb.noAtmosphericDensityAltitude>0 then return eb.radius+eb.noAtmosphericDensityAltitude else return eb.radius+eb.surfaceMaxAltitude*1.5 end end)local hz=eq;if er~=nil and eq~=nil then hz=math.min(er,eq)end;if hz~=nil and hz<AutopilotDistance and hy.name==ab.name then AutopilotDistance=hz end;local k7=true;local ky=(ab.center-(bE+vec3(bA):normalize()*AutopilotDistance)):len()-ab.radius;local hx=cB(ky)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hx..'"}')local a7,a8;if not TurnBurn then a7,a8=jF(bB)else a7,a8=jH(bB)end;if bB>300 and AutopilotAccelerating then local cZ=vec3(ks)-bE;local kz=q(math.deg(jI(bx,bA:normalize(),cZ:normalize()))*bB/500,-90,90)local kA=q(math.deg(jI(bz,bA:normalize(),cZ:normalize()))*bB/500,-90,90)if c(kz)<20 and c(kA)<20 then kz=kz*2;kA=kA*2 end;if c(kz)<2 and c(kA)<2 then kz=kz*2;kA=kA*2 end;local k2=-math.deg(jI(bx,by,bA:normalize()))local k3=-math.deg(jI(bz,by,bA:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kA-k3)local kB=q(apPitchPID:get(),-1,1)T=T+kB;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kz-k2)local kC=q(apYawPID:get(),-1,1)U=U+kC;kt=true;if c(kz)>2 or c(kA)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"cb("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end end end;if ky<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=b4(ab):escapeAndOrbitalSpeed(ky)end end;if not AutopilotCruising and not AutopilotBraking and not kt then k7=cQ((ks-bE):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then k7=cQ(-vec3(bA):normalize())end;if AutopilotAccelerating then if not O then BrakeIsOn=false;cu(AutopilotInterplanetaryThrottle)J=z(AutopilotInterplanetaryThrottle,2)O=true end;local kD=unit.getThrottle()if AtmoSpeedAssist then kD=J end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or kD==0 and O then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then cb("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cu(0)end;if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then cb("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cu(0)O=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;X=1 end;if TurnBurn then cu(1,true)end;local _,ke=b4(ab):escapeAndOrbitalSpeed((bE-planet.center):len()-planet.radius)local cZ;if CustomTarget~=nil then cZ=CustomTarget.position-bE end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bB<50 then kr("Autopilot complete, arrived at space location")BrakeIsOn=true;X=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bB<=ke and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kr("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;b7.showWayPoint(ab,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then cb("apCir","AP")AutopilotStatus="Circularizing"end;if bB<=ke then if CustomTarget~=nil then if bA:normalize():dot(cZ:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then cb("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;b7.showWayPoint(ab,CustomTarget.position)WaypointSet=true end else kr("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;b7.showWayPoint(ab,CustomTarget.position)WaypointSet=false end else kr("Autopilot completed, setting orbit",true)X=0 end end elseif AutopilotStatus=="Circularizing"then kr("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then cb("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kD=unit.getThrottle()if AtmoSpeedAssist then kD=J end;if kD>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end;AutopilotCruising=false end else if k7 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ab.center)+(AutopilotTargetOrbit+ab.radius)*bz;AutopilotShipUp=bx;AutopilotShipRight=bz end;AutopilotRealigned=true elseif k7 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end;if not O then cu(AutopilotInterplanetaryThrottle,true)J=z(AutopilotInterplanetaryThrottle,2)O=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a1="Autopilot complete, proceeding with reentry"cb("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"X=0;cu(0)O=false;ProgradeIsOn=true;al=true;b7.showWayPoint(ab,CustomTarget.position)end;if Z then ba=true;local kA=0;local c7=bE+vec3(unit.getMasterPlayerRelativePosition())local kE=c7-bE;local kF=vec3(kE):project_on(by):len()local kG=vec3(kE):project_on(bz):len()local ai=x(kF*kF+kG*kG)cQ(kE:normalize())local kH=40;local kI=ai<kH;local kJ=100;local kK=q((ai-kH)/2,10,kJ)T=0;local k7=c(U)<0.1;if k7 and bB<kK and not kI then BrakeIsOn=false;kA=-20 else BrakeIsOn=true;kA=0 end;local kL=0;if c(kA-bK)>kL then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kA-bK)local kB=pitchPID:get()T=kB end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local kM=LastMaxBrakeInAtmo;if kM then kM=kM*q(bB/100,0.1,1)*ar else kM=LastMaxBrake end;if ar<0.01 then kM=LastMaxBrake end;local kN=vec3(core.getWorldAirFrictionAcceleration())local kO=x(kN:len()-kN:project_on(ge):len())*av;if bB>100 then a7,a8=b2.computeDistanceAndTime(bB,100,av,0,0,kM+kO)local kP,kQ=b2.computeDistanceAndTime(100,0,av,0,0,kM/2)a7=a7+kP else a7,a8=b2.computeDistanceAndTime(bB,0,av,0,0,kM/2)end;local kR=HoldAltitude-as;local kS=500+bB;local kT=1;if AutoTakeoff then kT=q(bB/100,0.1,1)end;local kA=(utils.smoothstep(kR,-kS,kS)-0.5)*2*MaxPitch*kT;if not Reentry and not al and not VectorToTarget and by:dot(bA:normalize())<0.99 then kA=(utils.smoothstep(kR,-kS*q(20-19*ar*10,1,20),kS*q(20-19*ar*10,1,20))-0.5)*2*MaxPitch*q(2-ar*10,1,2)*kT end;if not AltitudeHold then kA=0 end;if LockPitch~=nil then if bV and not IntoOrbit then kA=LockPitch else LockPitch=nil end end;ba=true;local kU=T;if Reentry then local kV=d(bh)local kW,kX=b2.computeDistanceAndTime(bB,kV/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)local kY=as-(planet.noAtmosphericDensityAltitude+5000)if not bJ and as>planet.noAtmosphericDensityAltitude+5000 and bB<=kV/3.6 and bB>kV/3.6-10 and c(bA:normalize():dot(by))>0.9 then cu(0)elseif bJ and bB>kV/3.6 and(kW>-1 and kY<=kW or as<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cx(kV,true)if not Q then kA=-80;if ar>0.02 then a1="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kA=0;ba=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and as>planet.noAtmosphericDensityAltitude+5000 then ba=true elseif as<=planet.noAtmosphericDensityAltitude+5000 then cx(kV)if not bJ and r:getTargetSpeed(axisCommandId.longitudinal)==bh then Q=false;Reentry=false;ba=true end end end;if bB>P and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then cQ(vec3(bA))end;if bT or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local cZ;if bT then if type(bT)=="table"then cZ=bT elseif bT<3 and bT>0 then cZ=-bC:cross(bA)*5000 elseif bT>=3 then cZ=bC:cross(bA)*5000 elseif bT==0 then cZ=bA*25000 end elseif CustomTarget~=nil then cZ=CustomTarget.position-bE else cZ=ab.center-bE end;local kz=math.deg(jI(bC:normalize(),bA,cZ))*2;local kZ=math.rad(c(bL))if bB>minRollVelocity and ar>0.01 then local k_=q(90-kA*2,-90,90)be=q(kz*2,-k_,k_)local l0=kz;kz=q(q(kz,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(kZ)+4*(bK-kA)*math.sin(math.rad(bL)),-YawStallAngle*0.80,YawStallAngle*0.80)kA=q(q(kA*math.cos(kZ),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(l0)*math.sin(kZ),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else be=0;kz=q(kz,-YawStallAngle*0.80,YawStallAngle*0.80)end;local l1=k2-kz;if(type(bT)=="table"or bT==0)and c(l1)<=0.0001 then if bT==0 then cG()end;bT=nil;cb("180Off","BR")return end;if not bc and bB>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(l1)local kC=q(yawPID:get(),-1,1)U=U+kC elseif aq and ao>-1 or bB<minRollVelocity then cQ(cZ)elseif bc and ar>0.01 then if(k2<-YawStallAngle or k2>YawStallAngle)and ar>0.01 then cQ(bA)end;if(k3<-PitchStallAngle or k3>PitchStallAngle)and ar>0.01 then kA=q(bK-k3,bK-PitchStallAngle*0.80,bK+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local k8=planet:getAltitude(CustomTarget.position)local kY=x(cZ:len()^2-(as-k8)^2)local l2=bA:len()-c(bD)StrongBrakes=true;if not am and not Reentry and kY<=a7+bB*k1/2 and(bA:project_on_plane(bC):normalize():dot(cZ:project_on_plane(bC):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cu(0)if AltitudeHold then cG()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l2<0.1 or kY<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<kY)then if not bH then cb("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bW=false end;LastDistanceToTarget=kY end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ab.name==planet.name then local cZ=CustomTarget.position-bE;local k8=planet:getAltitude(CustomTarget.position)local kY=x(cZ:len()^2-(as-k8)^2)local kM=LastMaxBrakeInAtmo;if kM then a7,a8=b2.computeDistanceAndTime(bB,0,av,0,0,kM/2)StrongBrakes=true;if kY<=a7+bB*k1/2 and bA:project_on_plane(bC):normalize():dot(cZ:project_on_plane(bC):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;Q=true;al=false;an=true;Autopilot=false;d1()end end;LastDistanceToTarget=kY end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bs and not IntoOrbit then bq=HoldAltitude;bp=true;if VectorToTarget then bo.VectorToTarget=true end;cF()VectorToTarget=false;bm=true end end;if bc and ar>0.01 and ao==-1 and bB>minRollVelocity and VectorStatus~="Finalizing Approach"then cQ(bA)kA=q(bK-k3,bK-PitchStallAngle*0.80,bK+PitchStallAngle*0.80)end;T=kU;local jR=-1;if BrakeLanding then kA=0;local l3=false;local l4=30;if b3~=nil and b3>0 then local l5=q(ar,0.4,2)local kM=LastMaxBrakeInAtmo*q(bB/100,0.1,1)*l5;local l6=b3*l5+kM-ir;local l7=kM/2-ir;local l8=bB-x(c(l7/2)*20/(0.5*av))*utils.sign(l7)if l8<0 then l8=0 end;local l9;if bB>100 then local la,_=b2.computeDistanceAndTime(bB,100,av,0,0,kM)local lb,_=b2.computeDistanceAndTime(100,0,av,0,0,x(kM))l9=la+lb else l9=b2.computeDistanceAndTime(bB,0,av,0,0,x(kM))end;if l9<20 then BrakeIsOn=false else local lc=0;if l8>100 then local ld,_=b2.computeDistanceAndTime(l8,100,av,0,0,l6)local le,_=b2.computeDistanceAndTime(100,0,av,0,0,b3*l5+x(kM)-ir)lc=ld+le else lc,_=b2.computeDistanceAndTime(l8,0,av,0,0,b3*l5+x(kM)-ir)end;lc=(lc+15+bB*k1)*1.1;local lf=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lf then local k8=planet:getAltitude(CustomTarget.position)local lg=as-k8-100;local cZ=CustomTarget.position-bE;local lh=x(cZ:len()^2-(as-k8)^2)if lh>100 then lf=false elseif lg<=lc or lc==-1 then BrakeIsOn=true;l3=true else BrakeIsOn=false;l3=true end end;if not lf and CalculateBrakeLandingSpeed then if lc>=l4 then BrakeIsOn=true else BrakeIsOn=false end;l3=true end end end;if not bJ then cu(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)stablized=true;jR=ao;if jR>-1 then ba=autoRollPreference;if bB<1 or bA:normalize():dot(bC)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if R then a.control.extendLandingGears()cb("grOut","LG",1)end;r:setTargetGroundAltitude(LandingGearGroundHeight)ae=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bA:normalize():dot(-ge)<0.999 then BrakeIsOn=true elseif bD<-brakeLandingRate and not l3 then BrakeIsOn=true elseif not l3 then BrakeIsOn=false end end;if AutoTakeoff or am then local hy,er,eq;if AutopilotTargetCoords~=nil then hy,er,eq=b1:getPlanetarySystem(0):castIntersections(bE,(AutopilotTargetCoords-bE):normalize(),function(eb)return eb.radius+eb.noAtmosphericDensityAltitude end)end;if bH then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cu(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kA)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bJ and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bB<P then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cu(0)elseif am then cu(0)BrakeIsOn=true end elseif am and ar==0 and ab~=nil and(hy==nil or hy.name==ab.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bJ then cu(0)end;AutopilotAccelerating=true end end;local li=ao>-1;local lj=bK;if(VectorToTarget or am or bT)and not li and bB>minRollVelocity and ar>0.01 then local kZ=math.rad(c(bL))lj=bK*c(math.cos(kZ))+k3*math.sin(kZ)end;local lk=q(kA-lj,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then lk=q(kA-lj,-85,MaxPitch)elseif ar<0.01 then lk=q(kA-lj,-MaxPitch,MaxPitch)end;if c(bL)<5 or VectorToTarget or bT or BrakeLanding or li or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lk)local kB=pitchPID:get()T=T+kB end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=jM()return jD end;function script.onStart()local ll={}local lm={}local ln=false;local function lo()local function lp(lq)local lr=dbHud_1.hasKey;for dc,dd in pairs(lq)do if lr(dd)then local cW=f(dbHud_1.getStringValue(dd))if cW~=nil then _G[dd]=cW;ln=true end end end end;if dbHud_1 then if not useTheseSettings then lp(ch())coroutine.yield()lp(b)else lp(b)a1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ah=5;ln=false end;coroutine.yield()if ln then a1="Loaded Saved Variables"aH=ResolutionX;aI=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)ba=autoRollPreference;bh=AtmoSpeedLimit;az=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]aA=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]elseif not useTheseSettings then a1="No Saved Variables Found - Exit HUD to save settings"end else a1="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<C then LastMaxBrakeInAtmo=0 end;LastStartTime=C;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ah=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=av end;VectorStatus="Proceeding to Waypoint"end;local function ls()local function lt(lu,lv)if lu>lv then lv=lu end;local lw,lx=0,0;if ContainerOptimization>0 then lw=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lx=FuelTankOptimization*0.05 end;lv=lv*(1-(lw+lx))return lv end;local ly=core.getElementNameById;local lz=fuelX~=0 and fuelY~=0;for dc in pairs(at)do local type=core.getElementTypeById(at[dc])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(at[dc])),'^.*vertical.*$')then bG=true end end;if n(type,'^.*Space Engine$')then bv=true;if n(tostring(core.getElementTagsById(at[dc])),'^.*vertical.*$')then local lA=core.getElementRotationById(at[dc])if lA[4]<0 then if o(-lA[4],0.1)==0.5 then bt=true end else if o(lA[4],0.1)==0.5 then bu=true end end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local lB=h(at[dc])if lB>10000 then E=128;F=110 elseif lB>1000 then E=64;F=55 elseif lB>150 then E=32;F=27 end end;aM=aM+h(at[dc])if lz and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lB=h(at[dc])local lC=k(at[dc])local lu=0;local g6=p()if type=="Atmospheric Fuel Tank"then local lv=400;local lD=35.03;if lB>10000 then lv=51200;lD=5480 elseif lB>1300 then lv=6400;lD=988.67 elseif lB>150 then lv=1600;lD=182.67 end;lu=lC-lD;if fuelTankHandlingAtmo>0 then lv=lv+lv*fuelTankHandlingAtmo*0.2 end;lv=lt(lu,lv)aJ[#aJ+1]={at[dc],ly(at[dc]),lv,lD,lu,g6}end;if type=="Rocket Fuel Tank"then local lv=320;local lD=173.42;if lB>65000 then lv=40000;lD=25740 elseif lB>6000 then lv=5120;lD=4720 elseif lB>700 then lv=640;lD=886.72 end;lu=lC-lD;if fuelTankHandlingRocket>0 then lv=lv+lv*fuelTankHandlingRocket*0.1 end;lv=lt(lu,lv)aL[#aL+1]={at[dc],ly(at[dc]),lv,lD,lu,g6}end;if type=="Space Fuel Tank"then local lv=2400;local lD=182.67;if lB>10000 then lv=76800;lD=5480 elseif lB>1300 then lv=9600;lD=988.67 end;lu=lC-lD;if fuelTankHandlingSpace>0 then lv=lv+lv*fuelTankHandlingSpace*0.2 end;lv=lt(lu,lv)aK[#aK+1]={at[dc],ly(at[dc]),lv,lD,lu,g6}end end end;if not bG then VertTakeOff,VertTakeOffEngine=false,false end end;local function lE()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(aq or not aq and as<10000)then for _,dd in pairs(door)do dd.toggle()end end;if switch then for _,dd in pairs(switch)do dd.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,dd in pairs(forcefield)do dd.toggle()end end;if antigrav then bH=antigrav.getState()==1;if bH and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if R then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;GearExtended=true;if R then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(bb)if aq and ao~=-1 then b3=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function lF(lG,lH,lI,lJ,cp,cq,lK,lL,lM,lN)local lO={enableName=lG,disableName=lH,width=lI,height=lJ,x=cp,y=cq,toggleVar=lK,toggleFunction=lL,drawCondition=lM,hovered=false}if lN then table.insert(lm,lO)else table.insert(ll,lO)end;return lO end;local function lP(lQ)if not bM then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif lQ=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif lQ=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif lQ=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bN=ch(lQ)showHud=false else bN={}showHud=true end end;local function lR()bM=not bM;if bM then aG=lm;a1="Hold SHIFT to see Settings"bO=showHud else aG=ll;a1="Hold SHIFT to see Control Buttons"lP()showHud=bO end end;local function lS(dd)_G[dd]=not _G[dd]if _G[dd]then a1=dd.." set to true"else a1=dd.." set to false"end;if dd=="showHud"then bO=_G[dd]elseif dd=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif dd=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function lT()local lU=50;local lV=340;local cp=500;local cq=aI/2-400;local lW=0;for dc,dd in pairs(ch("boolean"))do if type(_G[dd])=="boolean"then lF(dd,dd,lV,lU,cp,cq,function()return _G[dd]end,function()lS(dd)end,function()return true end,true)cq=cq+lU+20;if lW==9 then cp=cp+lV+20;cq=aI/2-400;lW=0 else lW=lW+1 end end end;lF("Control View","Control View",lV,lU,10,aI/2-500,function()return true end,lR,function()return true end,true)lF("View Handling Settings",'Hide Handling Settings',lV,lU,10,aI/2-(500-lU),function()return showHandlingVariables end,function()lP("handling")end,function()return true end,true)lF("View Hud Settings",'Hide Hud Settings',lV,lU,10,aI/2-(500-lU*2),function()return showHudVariables end,function()lP("hud")end,function()return true end,true)lF("View Physics Settings",'Hide Physics Settings',lV,lU,10,aI/2-(500-lU*3),function()return showPhysicsVariables end,function()lP("physics")end,function()return true end,true)end;local function lX()local function lY()if dbHud_1 then local position=bE;local f_=planet.name..". "..#SavedLocations;if radar_1 then local dX,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dX~=nil and dX~=""then f_=f_.." "..radar_1.getConstructName(dX)end end;local cN={}cN={position=position,name=f_,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cN;table.insert(aX[0],cN)b6.UpdateAtlasLocationsList()a1="Location saved as "..f_ else a1="Databank must be installed to save locations"end end;local function lZ()TurnBurn=not TurnBurn end;local function l_(m0)if m0==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Z=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function m1()l_(1)end;local function m2()local cM=-1;cM=b6.findAtlasIndex(aX[0])if cM>-1 then table.remove(aX[0],cM)end;cM=-1;cM=b6.findAtlasIndex(SavedLocations)if cM~=-1 then a1=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cM)end;b6.adjustAutopilotTargetIndex()b6.UpdateAtlasLocationsList()end;local function m3()local f_=AutopilotTargetName;if f_==nil then local hx=cB((bE-CustomTarget.position):len())f_=CustomTarget.name.." "..hx end;if f_==nil then f_="None"end;return"Engage Autopilot: "..f_ end;local function m4()local f_=AutopilotTargetName;if f_==nil then f_=CustomTarget.name end;if f_==nil then f_="None"end;return"Disable Autopilot: "..f_ end;local function m5()if safeMass>0 then a1="Safe Mass set to "..z(av,2).." kg"else a1="Intruder Detection reset\nSafe Mass set to "..z(av,2).." kg"ah=5;bF=0 end;safeMass=av end;local lU=50;local lV=260;local m6=lF("Enable Brake Toggle","Disable Brake Toggle",lV,lU,aH/2-lV/2,aI/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a1="Brakes in Toggle Mode"else a1="Brakes in Default Mode"end end)lF("Align Prograde","Disable Prograde",lV,lU,aH/2-lV/2-50-m6.width,aI/2-lU+380,function()return ProgradeIsOn end,m1)lF("Align Retrograde","Disable Retrograde",lV,lU,aH/2-lV/2+m6.width+50,aI/2-lU+380,function()return RetrogradeIsOn end,l_,function()return ar==0 end)local m7=lF(m3,m4,600,60,aH/2-600/2,aI/2-60/2-400,function()return Autopilot end,cI)lF("Save Position","Save Position",200,m7.height,m7.x+m7.width+30,m7.y,function()return false end,lY,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)lF("Update Position","Update Position",200,m7.height,m7.x+m7.width+30,m7.y,function()return false end,cK,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lF("Clear Position","Clear Position",200,m7.height,m7.x-200-30,m7.y,function()return true end,m2,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lU=60;lV=300;local cp=10;local cq=aI/2-500;lF("Show Help","Hide Help",lV,lU,cp,cq,function()return showHelp end,function()showHelp=not showHelp end)cq=cq+lU+20;lF("View Settings","View Settings",lV,lU,cp,cq,function()return true end,lR)local cq=aI/2-300;lF("Enable Turn and Burn","Disable Turn and Burn",lV,lU,cp,cq,function()return TurnBurn end,lZ)lF("Horizontal Takeoff Mode","Vertical Takeoff Mode",lV,lU,cp+lV+20,cq,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a1="Vertical Takeoff Mode"else a1="Horizontal Takeoff Mode"end end,function()return bG end)cq=cq+lU+20;lF("Show Orbit Display","Hide Orbit Display",lV,lU,cp,cq,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a1="Orbit Display Enabled"else a1="Orbit Display Disabled"end end)lF("Engage Orbiting","Cancel Orbiting",lV,lU,cp+lV+20,cq,function()return IntoOrbit end,cF,function()return ar==0 and bV end)cq=cq+lU+20;lF("Glide Re-Entry","Cancel Glide Re-Entry",lV,lU,cp,cq,function()return Reentry end,function()al=true;m1()end,function()return planet.hasAtmosphere and not aq end)lF("Parachute Re-Entry","Cancel Parachute Re-Entry",lV,lU,cp+lV+20,cq,function()return Reentry end,d1,function()return planet.hasAtmosphere and not aq end)cq=cq+lU+20;lF("Engage Follow Mode","Disable Follow Mode",lV,lU,cp,cq,function()return Z end,cH,function()return l()==1 end)lF("Enable Repair Arrows","Disable Repair Arrows",lV,lU,cp+lV+20,cq,function()return aN end,function()aN=not aN;if aN then a1="Repair Arrows Enabled"else a1="Repair Arrows Diabled"end end,function()return l()==1 end)cq=cq+lU+20;if not ExternalAGG then lF("Enable AGG","Disable AGG",lV,lU,cp,cq,function()return bH end,d2,function()return antigrav~=nil end)end;lF("Reset Intruder Alert","Set Safe Mass",lV,lU,cp+lV+20,cq,function()return safeMass>0 end,m5,function()return IntruderAlertSystem end)cq=cq+lU+20;lF(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,lV*2,lU,cp,cq,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a1="IPH Mode: "..iphCondition end)cq=cq+lU+20;lF(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,lV*2,lU,cp,cq,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a1="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lo()coroutine.yield()ls()coroutine.yield()b7=jC()lE()lT()lX()aG=ll;coroutine.yield()aX=de()b0=df()b1=b0(de())b2=eE()b4=f8()b5=fu()b6=ju()b7=jC()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)cb("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,dd in pairs(door)do dd.toggle()end end;if switch then for _,dd in pairs(switch)do dd.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,dd in pairs(forcefield)do dd.toggle()end end;safeMass=av;d8()if button then button.activate()end;if SetWaypointOnExit then b7.showWayPoint(planet,bE)end;cb("stop","SU")end;function script.onTick(m8)local m9=nil;if m8=="contact"then if not contactTimer then contactTimer=0 end;if C>contactTimer+10 then a1="Radar Contact"cb("rdrCon","RC")contactTimer=C end;unit.stopTimer("contact")elseif m8=="tenthSecond"then local function ma()local mb=system.createData;local mc=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mc(panelInterplanetary,"value")interplanetaryHeaderText=mb('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mc(panelInterplanetary,"value")widgetDistanceText=mb('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=mc(panelInterplanetary,"value")widgetTravelTimeText=mb('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mc(panelInterplanetary,"value")widgetMaxMassText=mb('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mc(panelInterplanetary,"value")widgetTargetOrbitText=mb('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mc(panelInterplanetary,"value")widgetCurBrakeDistanceText=mb('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mc(panelInterplanetary,"value")widgetCurBrakeTimeText=mb('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mc(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mb('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mc(panelInterplanetary,"value")widgetMaxBrakeTimeText=mb('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mc(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mb('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function md()s(panelInterplanetary)panelInterplanetary=nil end;local function me()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ab.center-bE):len()else AutopilotDistance=(CustomTarget.position-bE):len()end end;local f6=bB;local kD=unit.getThrottle()/100;if AtmoSpeedAssist then kD=J end;local mf,mg=b2.computeDistanceAndTime(bB,MaxGameVelocity,av,a:maxForceForward()*kD,warmup,0)local a7,a8;if not TurnBurn then a7,a8=b7.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=b7.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mh;if not TurnBurn and f6>0 then _,mh=b7.GetAutopilotBrakeDistanceAndTime(f6)else _,mh=b7.GetAutopilotTBBrakeDistanceAndTime(f6)end;local mi=0;local mj=0;if AutopilotCruising or not Autopilot and f6>5 then mj=b2.computeTravelTime(f6,0,AutopilotDistance)elseif a7+mf<AutopilotDistance then mi=AutopilotDistance-(a7+mf)mj=b2.computeTravelTime(8333.0556,0,mi)else local mk=(AutopilotDistance-a7)/mf;mf=AutopilotDistance-a7;mg=mg*mk end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mj elseif AutopilotBraking then return mh elseif AutopilotCruising then return mj+mh else return mg+a8+mj end end;local function ml(ir,mm)if ir==nil then ir=core.g()end;ir=z(ir,5)if mm~=nil and mm or(m9==nil or m9~=ir)then local f9=core.getVelocity()local f6=vec3(f9):len()local mn=f(unit.getData()).maxBrake;if mn~=nil and mn>0 and aq then mn=mn/q(f6/100,0.1,1)mn=mn/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mn)/2 else LastMaxBrakeInAtmo=mn end end end;if mn~=nil and mn>0 then LastMaxBrake=mn end;m9=ir end end;ml(nil,true)if ar>0 and not WasInAtmo then if not bJ and AtmoSpeedAssist and(AltitudeHold or Reentry)then cu(1)N=false end end;if bI~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bI then cx(bI,TRUE)else bI=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then ma()end;if AutopilotTargetName~=nil then local mo=CustomTarget~=nil;local mp=LastMaxBrakeInAtmo/ab:getGravity(ab.center+vec3(0,0,1)*ab.radius):len()t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=me()if mo and not Autopilot then ai=(bE-CustomTarget.position):len()else ai=(AutopilotTargetCoords-bE):len()end;if not TurnBurn then a7,a8=b7.GetAutopilotBrakeDistanceAndTime(bB)a9,aa=b7.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=b7.GetAutopilotTBBrakeDistanceAndTime(bB)a9,aa=b7.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hx=cB(ai)t(widgetDistanceText,'{"label": "distance", "value": "'..hx..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d3(travelTime)..'", "unit":""}')hx=cB(a7)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hx..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d3(a8)..'", "unit":""}')hx=cB(a9)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hx..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d3(aa)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",mp/1000)..'", "unit":" Tons"}')hx=cB(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..hx..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if ar==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else md()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif m8=="oneSecond"then local function mq(fK)local mr=0;aE=""local ms=aM;local mt=0;local mu=0;local mv=0;local g8=0;local g9=""local mw=core.getElementHitPointsById;for dc in pairs(at)do local lB=0;local mx=0;mx=h(at[dc])lB=mw(at[dc])mt=mt+lB;if lB<mx then if lB==0 then mv=mv+1 else mu=mu+1 end;if aN and#aB==0 then position=vec3(core.getElementPositionById(at[dc]))local cp=position.x-E;local cq=position.y-E;local iR=position.z-E;table.insert(aB,core.spawnArrowSticker(cp,cq,iR+1,"down"))table.insert(aB,core.spawnArrowSticker(cp,cq,iR+1,"down"))core.rotateSticker(aB[2],0,0,90)table.insert(aB,core.spawnArrowSticker(cp+1,cq,iR,"north"))table.insert(aB,core.spawnArrowSticker(cp+1,cq,iR,"north"))core.rotateSticker(aB[4],90,90,0)table.insert(aB,core.spawnArrowSticker(cp-1,cq,iR,"south"))table.insert(aB,core.spawnArrowSticker(cp-1,cq,iR,"south"))core.rotateSticker(aB[6],90,-90,0)table.insert(aB,core.spawnArrowSticker(cp,cq-1,iR,"east"))table.insert(aB,core.spawnArrowSticker(cp,cq-1,iR,"east"))core.rotateSticker(aB[8],90,0,90)table.insert(aB,core.spawnArrowSticker(cp,cq+1,iR,"west"))table.insert(aB,core.spawnArrowSticker(cp,cq+1,iR,"west"))core.rotateSticker(aB[10],-90,0,90)table.insert(aB,at[dc])end elseif aN and#aB>0 and aB[11]==at[dc]then for g1 in pairs(aB)do core.deleteSticker(aB[g1])end;aB={}end end;mr=d(mt/ms*100)if mr<100 then fK[#fK+1]=co(0,0,"","pbright txt")g8=d(mr*2.55)g9=e("rgb(%d,%d,%d)",255-g8,g8,0)if mr<100 then fK[#fK+1]=co("50%",1035,"Elemental Integrity: "..mr.."%","txtbig txtmid","fill:"..g9)if mv>0 then fK[#fK+1]=co("50%",1055,"Disabled Modules: "..mv.." Damaged Modules: "..mu,"txtbig txtmid","fill:"..g9)elseif mu>0 then fK[#fK+1]=co("50%",1055,"Damaged Modules: "..mu,"txtbig txtmid","fill:"..g9)end end end end;local function my()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function mz()local g6=p()local hl=bB;local mA=g6-au;if hl>1.38889 then hl=hl/1000;local mB=hl*(g6-au)TotalDistanceTravelled=TotalDistanceTravelled+mB;ac=ac+mB end;ad=ad+mA;TotalFlightTime=TotalFlightTime+mA;au=g6 end;local function mC()if safeMass>0 then if av>safeMass+50 then bF=d(av-safeMass)safeMass=-1 elseif av<safeMass then safeMass=av end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mC()end;mz()b5.UpdatePipe()my()local fK={}b5.ExtraData(fK)if ShowOdometer then fK=b5.DrawOdometer(fK,ac,TotalDistanceTravelled,ad)end;if ShouldCheckDamage then mq(fK)end;aj=table.concat(fK,"")collectgarbage("collect")elseif m8=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cW=f(dbHud_1.getStringValue("SavedLocations"))if cW~=nil then _G["SavedLocations"]=cW;local cM=-1;local cN;for dc,dd in pairs(SavedLocations)do if dd.name and dd.name=="SatNav Location"then cM=dc;break end end;if cM~=-1 then cN=SavedLocations[cM]cM=-1;for dc,dd in pairs(aX[0])do if dd.name and dd.name=="SatNav Location"then cM=dc;break end end;if cM>-1 then aX[0][cM]=cN end;b6.UpdateAtlasLocationsList()a1=cN.name.." position updated"end end;for i=1,#bP do if bP[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bP[i].name)b6.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif m8=="msgTick"then local fK={}b5.DisplayMessage(fK,"empty")a1="empty"unit.stopTimer("msgTick")ah=3 elseif m8=="animateTick"then b9=true;b8=false;af=0;ag=0;unit.stopTimer("animateTick")elseif m8=="hudTick"then local function mD(fK)local mE=d(q(ai/(aH/4)*255,0,255))fK[#fK+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",af,ag,d(G+0.5)+mE,d(I+0.5)-mE,d(H+0.5)-mE)end;local function mF()for _,dd in pairs(aG)do if dd.hovered then if not dd.drawCondition or dd.drawCondition()then dd.toggleFunction()end;dd.hovered=false end end end;local function mG()local function mH(mI,mJ,cp,cq,lI,lJ)if mI>cp and mI<cp+lI and mJ>cq and mJ<cq+lJ then return true else return false end end;local cp=af+aH/2;local cq=ag+aI/2;for _,dd in pairs(aG)do dd.hovered=mH(cp,cq,dd.x,dd.y,dd.width,dd.height)end end;local function mK(fK)local function mL(fK,mM,hover,cp,cq,e_,mN,mO,mP,mQ,mR)if type(mQ)=="function"then mQ=mQ()end;if type(mR)=="function"then mR=mR()end;fK[#fK+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",cp,cq,e_,mN)if mM then fK[#fK+1]=e("%s'",mO)else fK[#fK+1]=mP end;if hover then fK[#fK+1]=" style='stroke:white; stroke-width:2'"else fK[#fK+1]=" style='stroke:black; stroke-width:1'"end;fK[#fK+1]="></rect>"fK[#fK+1]=e("<text x='%f' y='%f' font-size='24' fill='",cp+e_/2,cq+mN/2+5)if mM then fK[#fK+1]="black"else fK[#fK+1]="white"end;fK[#fK+1]="' text-anchor='middle' font-family='Montserrat'>"if mM then fK[#fK+1]=e("%s</text>",mQ)else fK[#fK+1]=e("%s</text>",mR)end end;local mS="rgb(50,50,50)'"local mT="rgb(210,200,200)"local mU=mL;for _,dd in pairs(aG)do local lH=dd.disableName;local lG=dd.enableName;if type(lH)=="function"then lH=lH()end;if type(lG)=="function"then lG=lG()end;if not dd.drawCondition or dd.drawCondition()then mU(fK,dd.toggleVar(),dd.hovered,dd.x,dd.y,dd.width,dd.height,mT,mS,lH,lG)end end end;local mV=z(ResolutionX/2,0)local mW=z(ResolutionY/2,0)local fK={}b5.HUDPrologue(fK)if showHud then b5.UpdateHud(fK)else if AlwaysVSpd then b5.DrawVerticalSpeed(fK,as)end;b5.DisplayOrbitScreen(fK)b5.DrawWarnings(fK)end;if bM and bN~={}then b5.DrawSettings(fK)end;b5.HUDEpilogue(fK)fK[#fK+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aH,aI)if a1~="empty"then b5.DisplayMessage(fK,a1)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then b5.DrawDeadZone(fK)end end;if w()==0 then if l()==1 and a0 then if not AltIsOn then mG()mK(fK)end;if not b8 and not b9 then local mX=table.concat(fK,"")fK={}fK[#fK+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aH,aI)fK[#fK+1]=mX;fK[#fK+1]="</body>"b8=true;fK[#fK+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fK,"")system.setScreen(content)elseif b9 then local mX=table.concat(fK,"")fK={}fK[#fK+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aH,aI)fK[#fK+1]=mX;fK[#fK+1]="</body>"end;if not b8 then fK[#fK+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],mV,mW,af,ag)end else mF()end else if not a0 and l()==0 then mF()if ai>DeadZone then if DisplayDeadZone then mD(fK)end end elseif not AltIsOn then mG()mK(fK)end;fK[#fK+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],mV,mW,af,ag)end;fK[#fK+1]=[[</svg></body>]]content=table.concat(fK,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif m8=="apTick"then b7.APTick()b5.UpdateRadar()end end;function script.onFlush()local function mY(mZ,kK)local m_=vec3()local n0=vec3()if mZ==axisCommandId.longitudinal then m_=vec3(core.getConstructOrientationForward())n0=by elseif mZ==axisCommandId.vertical then m_=vec3(core.getConstructOrientationUp())n0=bx elseif mZ==axisCommandId.lateral then m_=vec3(core.getConstructOrientationRight())n0=bz else return vec3()end;local n1=vec3(core.getWorldGravity())local n2=n1:dot(n0)local n3=vec3(core.getWorldAirFrictionAcceleration())local n4=n3:dot(n0)local n5=vec3(core.getVelocity())local n6=n5:dot(m_)local n7=kK*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(n7-n6)local n8=targetSpeedPID2:get()local n9=(n8-n4-n2)*n0;return n9 end;local function na(mZ,kK)local m_=vec3()local n0=vec3()if mZ==axisCommandId.longitudinal then m_=vec3(core.getConstructOrientationForward())n0=by elseif mZ==axisCommandId.vertical then m_=vec3(core.getConstructOrientationUp())n0=bx elseif mZ==axisCommandId.lateral then m_=vec3(core.getConstructOrientationRight())n0=bz else return vec3()end;local n1=vec3(core.getWorldGravity())local n2=n1:dot(n0)local n3=vec3(core.getWorldAirFrictionAcceleration())local n4=n3:dot(n0)local n5=vec3(core.getVelocity())local n6=n5:dot(m_)local n7=kK*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(n7-n6)local n8=targetSpeedPID:get()local n9=(n8-n4-n2)*n0;return n9 end;local function nb(nc,gd,jy)local nd=nc:cross(jy):normalize_inplace()local gZ=math.acos(q(nd:dot(-gd),-1,1))*constants.rad2deg;if nd:cross(-gd):dot(jy)<0 then gZ=-gZ end;return gZ end;if antigrav and not ExternalAGG then if not bH and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bJ=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bJ and N then cu(0)N=false elseif not bJ and not N then J=0;N=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local ne=q(S+T+system.getControlDeviceForwardInput(),-1,1)local nf=q(V+Y+system.getControlDeviceYawInput(),-1,1)local ng=q(W+U-system.getControlDeviceLeftRightInput(),-1,1)local nh=X;bC=vec3(core.getWorldVertical())if bC==nil or bC:len()==0 then bC=(planet.center-bE):normalize()end;bx=vec3(core.getConstructWorldOrientationUp())by=vec3(core.getConstructWorldOrientationForward())bz=vec3(core.getConstructWorldOrientationRight())bA=vec3(core.getWorldVelocity())bE=vec3(core.getConstructWorldPos())av=core.getConstructMass()bB=vec3(bA):len()bD=-bC:dot(bA)bL=getRoll(bC,by,bz)local ni=bL/180*math.pi;local nj=math.cos(ni)local nk=math.sin(ni)bK=nb(bC,by,bz*nj+bx*nk)local nl=bA:normalize()local nm=c(bL)local nn=utils.sign(bL)local no=vec3(core.getWorldAngularVelocity())local np=ne*pitchSpeedFactor*bz+nf*rollSpeedFactor*by+ng*yawSpeedFactor*bx;if ba==true and bC:len()>0.01 then local nq=c(be-bL)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and nq>0 or ar>0.0 and nq<autoRollRollThreshold and autoRollPreference)and nf==0 and c(bK)<85 then local nr=be;local ns=autoRollFactor;if ar==0 then ns=ns/4;be=0;nr=0 end;if rollPID==nil then rollPID=pid.new(ns*0.01,0,ns*0.1)end;rollPID:inject(nr-bL)local nt=rollPID:get()np=np+nt*by end end;if bC:len()>0.01 and ar>0.0 then local nu=20.0;if turnAssist==true and nm>nu and ne==0 and ng==0 then local nw=turnAssistFactor*0.1;local nx=turnAssistFactor*0.025;local ny=(nm-nu)/(180-nu)*180;local nz=0;if ny<90 then nz=ny/90 elseif ny<180 then nz=(180-ny)/90 end;nz=nz*nz;local nA=-nn*nx*(1.0-nz)local nB=nw*nz;np=np+nB*bz+nA*bx end end;local nC=1;local nD=0;local nE=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then bh=q(bh+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nF=J;J=z(q(J+speedChangeLarge/100,-1,1),2)if J>=0 and nF<0 then J=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then bh=q(bh-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nF=J;J=z(q(J-speedChangeLarge/100,-1,1),2)if J<=0 and nF>0 then J=0;aw=false end end else aw=true end;K=0;if aq and AtmoSpeedAssist and bJ then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bh/3.6-bA:dot(by))local nG=throttlePID:get()M=q(nG,-1,1)if M<J and ar>0.005 then L=true;r:setThrottleCommand(axisCommandId.longitudinal,q(M,0.01,1))else L=false;r:setThrottleCommand(axisCommandId.longitudinal,J)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bA:len()-bh/3.6)local nH=q(brakePID:get(),0,1)if ar>0 and bD<-80 or ar>0.005 then K=nH end;if K>0 then if L and M==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else M=q(M,0.01,1)end;local nI=''local nJ=vec3()local nK=mY(axisCommandId.vertical,ae*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",nK,nD)local nL='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nL=nL..ExtraLongitudeTags end;local nM=r:getAxisCommandType(axisCommandId.longitudinal)local nN=r:composeAxisAccelerationFromThrottle(nL,axisCommandId.longitudinal)local nO=na(axisCommandId.lateral,LeftAmount*1000)nI=nI..' , '.."lateral airfoil , lateral ground "nJ=nJ+nO;if nJ:len()>constants.epsilon then a:setEngineForceCommand(nI,nJ,nD,'','','',nE)end;a:setEngineForceCommand(nL,nN,nC)local nP='thrust analog vertical fueled 'local nQ='thrust analog lateral fueled 'if ExtraLateralTags~="none"then nQ=nQ..ExtraLateralTags end;if ExtraVerticalTags~="none"then nP=nP..ExtraVerticalTags end;if ae~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(nP,nK,nC)else a:setEngineForceCommand(nP,vec3(),nC)end;if LeftAmount~=0 then a:setEngineForceCommand(nQ,nO,nC)else a:setEngineForceCommand(nQ,vec3(),nC)end;if nh==0 then nh=K end;local nR=-nh*(brakeSpeedFactor*bA+brakeFlatFactor*nl)a:setEngineForceCommand('brake',nR)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,J)end;local kK=unit.getAxisCommandValue(0)if not bJ then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bA:len()-kK/3.6)local nH=q(brakePID:get(),0,1)nh=q(nh+nH,0,1)end;local nR=-nh*(brakeSpeedFactor*bA+brakeFlatFactor*nl)a:setEngineForceCommand('brake',nR)local nI=''local nJ=vec3()local nS=false;local nL='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nL=nL..ExtraLongitudeTags end;local nM=r:getAxisCommandType(axisCommandId.longitudinal)if nM==axisCommandType.byThrottle then local nN=r:composeAxisAccelerationFromThrottle(nL,axisCommandId.longitudinal)a:setEngineForceCommand(nL,nN,nC)elseif nM==axisCommandType.byTargetSpeed then local nN=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)nI=nI..' , '..nL;nJ=nJ+nN;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then nS=true end end;local nQ='thrust analog lateral 'if ExtraLateralTags~="none"then nQ=nQ..ExtraLateralTags end;local nT=r:getAxisCommandType(axisCommandId.lateral)if nT==axisCommandType.byThrottle then local nU=r:composeAxisAccelerationFromThrottle(nQ,axisCommandId.lateral)a:setEngineForceCommand(nQ,nU,nC)elseif nT==axisCommandType.byTargetSpeed then local nO=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)nI=nI..' , '..nQ;nJ=nJ+nO end;local nP='thrust analog vertical 'if ExtraVerticalTags~="none"then nP=nP..ExtraVerticalTags end;local nV=r:getAxisCommandType(axisCommandId.vertical)if nV==axisCommandType.byThrottle then local nK=r:composeAxisAccelerationFromThrottle(nP,axisCommandId.vertical)if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(nP,nK,nC,'airfoil','ground','',nE)else a:setEngineForceCommand(nP,vec3(),nC)a:setEngineForceCommand('airfoil vertical',nK,nC,'airfoil','','',nE)a:setEngineForceCommand('ground vertical',nK,nC,'ground','','',nE)end elseif nV==axisCommandType.byTargetSpeed then if ae<0 then a:setEngineForceCommand('hover',vec3(),nC)end;local nW=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)nI=nI..' , '..nP;nJ=nJ+nW end;if nJ:len()>constants.epsilon then if X~=0 or nS or c(nl:dot(by))<0.8 then nI=nI..', brake'end;a:setEngineForceCommand(nI,nJ,nD,'','','',nE)end end;local nX=torqueFactor*(np-no)local nY=vec3(core.getWorldAirFrictionAngularAcceleration())nX=nX-nY;a:setEngineTorqueCommand('torque',nX,nC,'airfoil','','',nE)a:setBoosterCommand('rocket_engine')if a6 and not VanillaRockets then local f6=vec3(core.getVelocity()):len()local nZ=0.15;if not bJ then local n_=r:getTargetSpeed(axisCommandId.longitudinal)if f6*3.6>n_*(1-nZ)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f6*3.6<n_*(1-nZ)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kD=unit.getThrottle()if AtmoSpeedAssist then kD=J*100 end;local kK=kD/100;if j==0 then kK=kK*MaxGameVelocity;if f6>=kK*(1-nZ)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f6<kK*(1-nZ)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kV=d(bh)kK=kK*kV/3.6;if f6>=kK*(1-nZ)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f6<kK*(1-nZ)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local js=coroutine.status(beginSetup)if js=="suspended"then local cv,jt=coroutine.resume(beginSetup)if jt then system.print("ERROR STARTUP: "..jt)end elseif js=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not b8 and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(o0)local B=1;local function o1(o2)local function o3(o4,o2)local o5={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local o6=o4;for _,dd in ipairs(o5)do if o2 and o6>dd then o4=dd elseif o4<dd and not o2 then o4=dd;break end end;return o4 end;if o2 then B=-1 end;if not ExternalAGG and bH then if a0 and o2 then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a0 then bq=o3(bq,o2)else bq=bq+B*a2 end;if bq<planet.noAtmosphericDensityAltitude then bq=planet.noAtmosphericDensityAltitude end else if a0 and aq then HoldAltitude=o3(HoldAltitude,o2)else HoldAltitude=HoldAltitude+B*a2 end end else r:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function o7(o2)if o2 then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=q(J+B*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if o2 then B=1 else B=nil end;b6.adjustAutopilotTargetIndex(B)end end;local function o8(o9)if not aq then a1="Flight Assist in Atmo only"return end;local dk=type(o9)if bT==nil then if dk=="table"then if Autopilot or VectorToTarget then cI()end;cb("180On","BR")elseif dk==1 then cb("bnkLft","BR")else cb("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cG()if dk~="table"then o9=o9+1 end end;bT=o9 elseif dk=="table"then cb("180Off","BR")bT=nil end end;if o0=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cu(0)if vBooster or hover then if aq and ao==-1 then cb("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;ba=true;GearExtended=false else if R then cb("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if R and not BrakeLanding and not(vBooster or hover)then cb("grOut","LG",1)a.control.extendLandingGears()end else if R then cb("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif o0=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif o0=="forward"then S=S-1 elseif o0=="backward"then if AltIsOn then o8(-bA*5000)else S=S+1 end elseif o0=="left"then if AltIsOn then o8(1)else V=V-1 end elseif o0=="right"then if AltIsOn then o8(3)else V=V+1 end elseif o0=="yawright"then W=W-1 elseif o0=="yawleft"then W=W+1 elseif o0=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif o0=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif o0=="up"then ae=ae+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif o0=="down"then ae=ae-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif o0=="groundaltitudeup"then o1()elseif o0=="groundaltitudedown"then o1(true)elseif o0=="option1"then b6.adjustAutopilotTargetIndex()toggleView=false elseif o0=="option2"then b6.adjustAutopilotTargetIndex(1)toggleView=false elseif o0=="option3"then local function oa()aF=not aF;if not aF then cb("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else cb("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oa()toggleView=false elseif o0=="option4"then bT=nil;cI()toggleView=false elseif o0=="option5"then function ToggleLockPitch()if LockPitch==nil then cb("lkPOn","LP")LockPitch=bK;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else cb("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif o0=="option6"then cG()toggleView=false elseif o0=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a1="Collision System Enabled"else a1="Collision System Secured"end;toggleView=false elseif o0=="option8"then stablized=not stablized;if not stablized then a1="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()cb("gsOff","GS")else a1="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)cb("gsOn","GS")end;toggleView=false elseif o0=="option9"then if gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then cb("gyOn","GA")else cb("gyOff","GA")end end;toggleView=false elseif o0=="lshift"then if AltIsOn then a0=true end;if w()==1 then a0=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then a0=true;b9=false;b8=false end elseif o0=="brake"then if BrakeToggleStatus then cP()elseif not BrakeIsOn then cP()else BrakeIsOn=true end elseif o0=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif o0=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a6 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a6=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a6=false end elseif o0=="stopengines"then local function ob()if C-D<1.5 then cb("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bT=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Z=false;O=false;al=false;am=false;Q=false;ba=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;ob()D=C;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if J~=0 then r:resetCommand(axisCommandId.longitudinal)cu(0)else cu(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if aq then cx(AtmoSpeedLimit)else cx(MaxGameVelocity*3.6)end end end elseif o0=="speedup"then o7()elseif o0=="speeddown"then o7(true)elseif o0=="antigravity"and not ExternalAGG then if antigrav~=nil then d2()end end end;function script.onActionStop(o0)local function oc()if not ExternalAGG and bH then a5=a3 end;if AltitudeHold or VertTakeOff or IntoOrbit then a4=a2 end end;if o0=="forward"then S=0 elseif o0=="backward"then S=0 elseif o0=="left"then if bT==2 then bT=0 else bT=nil end;V=0 elseif o0=="right"then if bT==4 then bT=0 else bT=nil end;V=0 elseif o0=="yawright"then W=0 elseif o0=="yawleft"then W=0 elseif o0=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif o0=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif o0=="up"then ae=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif o0=="down"then ae=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif o0=="groundaltitudeup"then oc()toggleView=false elseif o0=="groundaltitudedown"then oc()toggleView=false elseif o0=="lshift"then if w()==1 then af=0;ag=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then b9=false;b8=false end;a0=false elseif o0=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cP()else BrakeIsOn=false end end elseif o0=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(o0)local B=1;local function od(o2)if o2 then B=-1 end;if not ExternalAGG and bH then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a5=a5*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bq=bq+B*a4;if bq<planet.noAtmosphericDensityAltitude then bq=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a4 end;a4=a4*1.05 else r:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function oe(o2)if o2 then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=q(J+B*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if o0=="groundaltitudeup"then if not a0 then od()end elseif o0=="groundaltitudedown"then if not a0 then od(true)end elseif o0=="speedup"then oe()elseif o0=="speeddown"then oe(true)end end;function script.onInputText(cr)local function of()for dc,dd in pairs(ch())do dbHud_1.setStringValue(dd,g(nil))end;for dc,dd in pairs(b)do if dd~="SavedLocations"then dbHud_1.setStringValue(dd,g(nil))end end;a1="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ah=5 end;local function og(f_,c7)local oh=false;local dt='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dF,dG,dN,dO,dP=n(c7,dt)for _,dd in pairs(b1[0])do if dd.name==f_ then dO=math.rad(dO)dN=math.rad(dN)local planet=aX[y(dF)][y(dG)]local eB=math.cos(dN)local oi=vec3(eB*math.cos(dO),eB*math.sin(dO),math.sin(dN))return planet.center+(planet.radius+dP)*oi end end;return f_.." not found"end;local function oj(ok,planet,c7,gV)local function ol(c7)local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dF,dG,dN,dO,dP=n(c7,dt)if dF=="0"and dG=="0"then return vec3(y(dN),y(dO),y(dP))end;dO=math.rad(dO)dN=math.rad(dN)local planet=aX[y(dF)][y(dG)]local eB=math.cos(dN)local oi=vec3(eB*math.cos(dO),eB*math.sin(dO),math.sin(dN))return planet.center+(planet.radius+dP)*oi end;if dbHud_1 or gV then local cN={}local position=ol(c7)if planet.name=="Space"then cN={position=position,name=ok,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cN={position=position,name=ok,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;if not gV then SavedLocations[#SavedLocations+1]=cN else for dc,dd in pairs(aX[0])do if dd.name and ok==dd.name then table.remove(aX[0],dc)end end end;table.insert(aX[0],cN)b6.UpdateAtlasLocationsList()else a1="Databank must be installed to save permanent locations"end end;local i;local om,on=nil,nil;local oo="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cr," ")om=cr;if i~=nil then om=string.sub(cr,0,i-1)on=string.sub(cr,i+1)end;if om=="/help"or om=="/commands"then for ix in string.gmatch(oo,"([^\n]+)")do system.print(ix)end;return elseif om=="/setname"then if on==nil or on==""then a1="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cK(on)else a1="Select a saved target to rename first"end elseif om=="/addlocation"or string.find(cr,"::pos")~=nil then local gV=false;local ok="0-Temp"if on==nil or on==""then on=om;gV=true end;i=string.find(on,"::")if not gV then ok=string.sub(on,1,i-2)end;local c7=string.sub(on,i)local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dF,dG,dN,dO,dP=n(c7,dt)local planet=aX[y(dF)][y(dG)]if planet.name=="Space"then local j2=vec3(y(dN),y(dO),y(dP))local dK=sys:closestBody(j2)if(j2-dK.center):len()<dK.radius+dK.noAtmosphericDensityAltitude then planet=dK end end;oj(ok,planet,c7,gV)a1="Added "..ok.." to saved locations,\nplanet "..planet.name.." at "..c7;ah=5 elseif om=="/agg"then if on==nil or on==""then a1="Usage: /agg targetheight"return end;on=y(on)if on<1000 then on=1000 end;AntigravTargetAltitude=on;a1="AGG Target Height set to "..on elseif om=="/G"then if on==nil or on==""then a1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if on=="dump"then for dc,dd in pairs(ch())do if type(_G[dd])=="boolean"then if _G[dd]==true then system.print(dd.." true")else system.print(dd.." false")end elseif _G[dd]==nil then system.print(dd.." nil")else system.print(dd.." ".._G[dd])end end;return end;i=string.find(on," ")local op=string.sub(on,0,i-1)local oq=string.sub(on,i+1)for dc,dd in pairs(ch())do if dd==op then a1="Variable "..op.." changed to "..oq;local os=type(_G[dd])if os=="number"then oq=y(oq)elseif os=="boolean"then if string.lower(oq)=="true"then oq=true else oq=false end end;_G[dd]=oq;return end end;a1="No such global variable: "..op elseif om=="/copydatabank"then if dbHud_2 then d8(true)else a1="Spare Databank required to copy databank"end elseif om=="/iphWP"then if AutopilotTargetIndex>0 then system.print(b7.showWayPoint(ab,AutopilotTargetCoords,true))a1="::pos waypoint shown in lua chat"else a1="No target selected in IPH"end end end;function script.onEnter(dX)if radar_1 and not aq and not bQ then unit.setTimer("contact",0.1)end end;function script.onLeave(dX)if radar_1 and CollisionSystem then if#bU>650 then dX=tostring(dX)bU[dX]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
