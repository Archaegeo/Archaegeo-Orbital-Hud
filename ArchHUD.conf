name: ArchHud - Archaegeo v1.354 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.354;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;sounds=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized","sounds"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=utils.round;local p=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local function x(num,y)local z=10^(y or 0)return d(num*z+0.5)/z end;local A=p()local B=p()local C=16;local D=13;local E=SafeR;local F=SafeB;local G=SafeG;local H=0;local I=0;local J=false;local K=0;local L=false;local M=false;local N=55;local O=false;local P=false;local Q=0;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=false;local Y=false;local Z="empty"local a0=5;local a1=5;local a2=a0;local a3=a1;local a4=false;local a5,a6=0;local a7,a8=0;local a9=nil;local aa=0;local ab=0;local ac=0;local ad=0;local ae=0;local af=3;local ag=0;local ah=""local ai=0;local aj=false;local ak=false;local al=false;local am=-1;local an=""local ao=j()>0;local ap=j()local aq=core.getAltitude()local ar=core.getElementIdList()local as=p()local at=core.getConstructMass()local au=false;local av=nil;local aw=false;local ax=[[rgb(]]..d(E+0.5)..","..d(G+0.5)..","..d(F+0.5)..[[)]]local ay=[[rgb(]]..d(E*0.9+0.5)..","..d(G*0.9+0.5)..","..d(F*0.9+0.5)..[[)]]local az={}local aA=0;local aB=0;local aC=""local aD=true;local aE={}local aF={}local aG={}local aH=ResolutionX;local aI=ResolutionY;local aJ=false;local aK=false;local aL=nil;local aM={}local aN={}local aO={}local aP=0;local aQ=false;local aR={}local aS={}local aT=d(1/apTickRate)*2;local aU={}local aV={}local aW={}local aX={}local aY=false;local aZ=0;local a_=nil;local b0=nil;local b1=nil;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=false;local bc=false;local bd=autoRollPreference;local be=LandingGearGroundHeight;local bf=false;local bg=p()local bh=0;local bi=0;local bj=0;local bk=AtmoSpeedLimit;local bl=0;local bm=nil;local bn=0;local bo=0;local bp=false;local bq=false;local br={VectorToTarget=false}local bs=false;local bt=0;local bu=nil;local bv=false;local bw=false;local bx=false;local by=false;local bz=0;local bA=vec3(core.getConstructWorldOrientationUp())local bB=vec3(core.getConstructWorldOrientationForward())local bC=vec3(core.getConstructWorldOrientationRight())local bD=vec3(core.getWorldVelocity())local bE=vec3(bD):len()local bF=vec3(core.getWorldVertical())local bG=-bF:dot(bD)local bH=vec3(core.getConstructWorldPos())local bI=0;local bJ=false;local bK=false;local bL=nil;local bM=true;local bN=0;local bO=0;local bP=false;local bQ={}local bR=showHud;local bS={}local bT=false;local bU=""local bV=""local bW=nil;local bX={}nearPlanet=unit.getClosestPlanetInfluence()>0;timeCount=0;totalTime=0;collisionAlertStatus=false;collisionTarget=nil;function getTrueWorldPos()local function bY()local bZ=core.getConstructWorldOrientationRight()local b_=core.getConstructWorldOrientationForward()local c0=core.getConstructWorldOrientationUp()local c1=library.systemResolution3(bZ,b_,c0,{1,0,0})local c2=library.systemResolution3(bZ,b_,c0,{0,1,0})local c3=library.systemResolution3(bZ,b_,c0,{0,0,1})return function(c4)return library.systemResolution3(c1,c2,c3,c4)end end;local c5=bY()local c6=core.getConstructWorldPos()local c7=core.getElementPositionById(1)local c8={c7[1]-C,c7[2]-C,c7[3]-C}local c9=c5(c8)local ca={c6[1]-c9[1],c6[2]-c9[2],c6[3]-c9[3]}return ca end;local function cb(cc,cd,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"or not sounds then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)end end;local function ce(cf,cg)for i=1,#cg do cf[#cf+1]=cg[i]end;return cf end;local function ch(ci)local cj={}local ck={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local cl={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local cm={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cn={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not ci then ce(cj,ck)ce(cj,cl)ce(cj,cm)ce(cj,cn)return cj elseif ci=="boolean"then return ck elseif ci=="handling"then return cl elseif ci=="hud"then return cm elseif ci=="physics"then return cn end end;local function co(cp,cq,cr,cs,ct)if cs==nil then cs=""end;if ct==nil then ct=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cs,cp,cq,ct,cr)end;local function cu(cv,cw)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not cw then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,cv)H=q(x(cv*100,0)/100,-1,1)end;local function cx(cv,cw)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cw then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,cv)bL=cv end;local function cy(cz,cA)if cz==0 then return c(cA)<1e-09 end;if cA==0 then return c(cz)<1e-09 end;return c(cz-cA)<math.max(c(cz),c(cA))*epsilon end;local function cB(ag,cC)local cD=ag>100000;if cC==nil then cC=1 end;if cD then return x(ag/1000/200,cC).."SU"elseif ag<1000 then return x(ag,cC).."M"else return x(ag/1000,cC).."KM"end end;local function cE()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;bd=true;ac=0;if ao and am==-1 then BrakeLanding=false;AltitudeHold=true;ac=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cx(d(bk))end else bv=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cF()bv=false;bn=nil;bo=nil;bz=0;if ap==0 then if IntoOrbit then cb("orOff","AP")IntoOrbit=false;bp=false;bu=nil;bd=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;br.VectorToTarget=false;br.AutopilotAlign=false;bs=false elseif nearPlanet then cb("orOn","AP")IntoOrbit=true;bd=true;if bu==nil then bu=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else Z="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bp=false;bu=nil;bd=autoRollPreference;if AltitudeHold then AltitudeHold=false end;br.VectorToTarget=false;br.AutopilotAlign=false;bs=false end end;local function cG()if A-bi<1.5 then if planet.hasAtmosphere then if ap>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;cb("11","EP")else if nearPlanet then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bt=HoldAltitude;bs=true;if not IntoOrbit then cF()end;bp=true end end;bi=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bi=A end;if nearPlanet and ap==0 then bt=aq;bs=true;bp=true;cF()if IntoOrbit then bi=A else bi=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;X=false;bd=true;LockPitch=nil;bv=false;if am==-1 then cb("altOn","AH")AutoTakeoff=false;if bi>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=aq end end;if VertTakeOff then cE()end else cb("lfs","LS")AutoTakeoff=true;if bi>-1 then HoldAltitude=aq+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bJ then cE()end end;if ak then HoldAltitude=100000 end else cb("altOff","AH")if IntoOrbit then cF()end;if VertTakeOff then cE()end;bd=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bi=0 end end;local function cH()if l()==1 then X=not X;if X then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)cb("folOn","F")else cb("folOff","F")BrakeIsOn=true;bd=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else Z="Follow Mode only works with Remote controller"X=false end end;local function cI()local function cJ(SpaceTarget)collisionAlertStatus=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cG()end end;VectorStatus="Proceeding to Waypoint"end;if A-bj<1.5 and ap>0 then if not by then Z="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ap>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;cb("orH","OH")end;bj=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bj=A end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not ak and not IntoOrbit then b9.UpdateAutopilotTarget()ba.showWayPoint(a9,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then cb("apSpc","AP")if ap~=0 then ak=true;cG()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ap>0 then if not VectorToTarget then cb("vtt","AP")cJ(SpaceTarget)end else cb("apOn","AP")if not(a9.name==planet.name and nearPlanet)then bv=false;Autopilot=true elseif not ao then if IntoOrbit then cF()end;bt=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bs=true;br.AutopilotAlign=true;br.VectorToTarget=true;bp=false;if not IntoOrbit then cF()end end end else cb("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ap~=0 then ak=true;cG()else Autopilot=true end end elseif ap==0 then if CustomTarget==nil and(a9.name==planet.name and nearPlanet)and not IntoOrbit then WaypointSet=false;bv=false;bp=false;cF()else cb("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;X=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;M=false;LockPitch=nil;WaypointSet=false end else cb("apP","AP")ak=true;cG()end else cb("apOff","AP")ak=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;M=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=aq;TargetSet=false;Reentry=false;if IntoOrbit then cF()end end end;local function cK(cL)local cM=-1;local cN;cM=b9.findAtlasIndex(SavedLocations)if cM~=-1 then local cO;if cL~=nil then cN={position=SavedLocations[cM].position,name=cL,atmosphere=SavedLocations[cM].atmosphere,planetname=SavedLocations[cM].planetname,gravity=SavedLocations[cM].gravity}else cN={position=bH,name=SavedLocations[cM].name,atmosphere=ap,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cM]=cN;cM=-1;cM=b9.findAtlasIndex(a_[0])if cM>-1 then a_[0][cM]=cN end;b9.UpdateAtlasLocationsList()Z=CustomTarget.name.." position updated"b9.UpdateAutopilotTarget()else Z="Name Not Found"end end;local function cP()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bd=autoRollPreference end;if BrakeIsOn then cb("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bW=nil;if not bK then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cE()end;if IntoOrbit then cF()end;bd=autoRollPreference;aj=false;al=false;ac=0 else cb("bkOff","B",1)end end;local function cQ(cR,cS,cT)local function cU(cR,cV)cR=vec3(cR)cV=vec3(cV):normalize()local cW=cR*cV;return cW.x+cW.y+cW.z end;local cX=0.001;local cY=1;if not ao or not bf or am~=-1 or bE<N then if cT==nil then cT=DampingMultiplier end;if cS==nil then cS=cX end;cR=vec3(cR):normalize()local cZ=vec3()-cR;local c_=-cU(cZ,core.getConstructWorldOrientationRight())*cY;local d0=-cU(cZ,core.getConstructWorldOrientationUp())*cY;if aA==0 then aA=c_/2 end;if aB==0 then aB=d0/2 end;if c(c_)<0.1 then S=S-c_*2 else S=S-(c_+(c_-aA)*cT)end;if c(d0)<0.1 then R=R+d0*2 else R=R+d0+(d0-aB)*cT end;aA=c_;aB=d0;if c(c_)<cS and c(d0)<cS then return true end;return false elseif bf and am==-1 then cR=bD;if cT==nil then cT=DampingMultiplier end;if cS==nil then cS=cX end;cR=vec3(cR):normalize()local cZ=bB-cR;local c_=-cU(cZ,core.getConstructWorldOrientationRight())*cY;local d0=-cU(cZ,core.getConstructWorldOrientationUp())*cY;if aA==0 then aA=c_/2 end;if aB==0 then aB=d0/2 end;if c(c_)<0.1 then S=S-c_*5 else S=S-(c_+(c_-aA)*cT)end;if c(d0)<0.1 then R=R+d0*5 else R=R+d0+(d0-aB)*cT end;aA=c_;aB=d0;if c(c_)<cS and c(d0)<cS then return true end;return false end end;local function d1()if Reentry then Z="Re-Entry cancelled"cb("reOff","RE")Reentry=false;bd=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then Z="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"af=5 elseif not O then Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bd=true;BrakeIsOn=false;Z="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bk;cb("par","RE")else Reentry=true;AltitudeHold=true;bd=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local cr=cB(HoldAltitude)Z="Beginning Re-entry.  Target speed: "..bk.." Target Altitude: "..cr;cb("glide","RE")cx(d(bk))end;AutoTakeoff=false end;local function d2()if antigrav and not ExternalAGG then if bK then cb("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=aq end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;cb("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function d3(d4)local d5=0;local d6=0;local d7=0;if d4<60 then d4=d(d4)elseif d4<3600 then d5=d(d4/60)d4=d(d4%60)elseif d4<86400 then d6=d(d4/3600)d5=d(d4%3600/60)else d7=d(d4/86400)d6=d(d4%86400/3600)end;if d7>0 then return d7 .."d "..d6 .."h "elseif d6>0 then return d6 .."h "..d5 .."m "elseif d5>0 then return d5 .."m "..d4 .."s"elseif d4>0 then return d4 .."s"else return"0s"end end;local function d8(d9)local function da(db)for dc,dd in pairs(db)do dbHud_1.setStringValue(dd,g(_G[dd]))if d9 and dbHud_2 then dbHud_2.setStringValue(dd,g(_G[dd]))end end end;if dbHud_1 then da(b)da(ch())system.print("Saved Variables to Datacore")if d9 and dbHud_2 then Z="Databank copied.  Remove copy when ready."end end end;local function de()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function df()local function dg(dh)return type(dh)=='number'end;local function di(dh)return type(tonumber(dh))=='number'end;local function dj(dk)return type(dk)=='table'end;local function dl(dm)return type(dm)=='string'end;local function dn(dd)return dj(dd)and dg(dd.x and dd.y and dd.z)end;local function dp(dq)return dj(dq)and dg(dq.latitude and dq.longitude and dq.altitude and dq.bodyId and dq.systemId)end;local dr=math.pi/180;local ds=180/math.pi;local epsilon=1e-10;local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..num..','..num..','..num..','..num..','..num..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function du(dh)local cW=string.gsub(string.reverse(e('%.4f',dh)),'^0*%.?','')return cW==''and'0'or string.reverse(cW)end;local function dv(dw)if dn(dw)then return e('{x=%.3f,y=%.3f,z=%.3f}',dw.x,dw.y,dw.z)end;if dj(dw)and not getmetatable(dw)then local dx={}local dy=next(dw)if type(dy)=='nil'or dy==1 then dx=dw else for dc,dd in pairs(dw)do local cv=dv(dd)if type(dc)=='number'then table.insert(dx,e('[%s]=%s',dc,cv))else table.insert(dx,e('%s=%s',dc,cv))end end end;return e('{%s}',table.concat(dx,','))end;if dl(dw)then return e("'%s'",dw:gsub("'",[[\']]))end;return tostring(dw)end;local dz={}dz.__index=dz;dz.__tostring=function(dw,dA)local dB={}for dc in pairs(dw)do table.insert(dB,dc)end;table.sort(dB)local dx={}for _,dc in ipairs(dB)do local cv=dv(dw[dc])if type(dc)=='number'then table.insert(dx,e('[%s]=%s',dc,cv))else table.insert(dx,e('%s=%s',dc,cv))end end;if dA then return e('%s%s',dA,table.concat(dx,',\n'..dA))end;return e('{%s}',table.concat(dx,','))end;dz.__eq=function(dC,dD)return dC.planetarySystemId==dD.planetarySystemId and dC.bodyId==dD.bodyId and cy(dC.radius,dD.radius)and cy(dC.center.x,dD.center.x)and cy(dC.center.y,dD.center.y)and cy(dC.center.z,dD.center.z)and cy(dC.GM,dD.GM)end;local function dE(dF,dG,dH,dI,dJ)assert(di(dF),'Argument 1 (planetarySystemId) must be a number:'..type(dF))assert(di(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(di(dH),'Argument 3 (radius) must be a number:'..type(dH))assert(dj(dI),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dI))assert(di(dJ),'Argument 5 (GM) must be a number:'..type(dJ))return setmetatable({planetarySystemId=tonumber(dF),bodyId=tonumber(dG),radius=tonumber(dH),center=vec3(dI),GM=tonumber(dJ)},dz)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dK)return e('::pos{%d,%d,%s,%s,%s}',dK.systemId,dK.bodyId,du(dK.latitude*ds),du(dK.longitude*ds),du(dK.altitude))end;MapPosition.__eq=function(dC,dD)return dC.bodyId==dD.bodyId and dC.systemId==dD.systemId and cy(dC.latitude,dD.latitude)and cy(dC.altitude,dD.altitude)and(cy(dC.longitude,dD.longitude)or cy(dC.latitude,math.pi/2)or cy(dC.latitude,-math.pi/2))end;local function dL(dM,dG,dN,dO,dP)local dF=dM;if dl(dM)and not dO and not dP and not dG and not dN then dF,dG,dN,dO,dP=n(dM,dt)assert(dF,'Argument 1 (position string) is malformed.')else assert(di(dF),'Argument 1 (systemId) must be a number:'..type(dF))assert(di(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(di(dN),'Argument 3 (latitude) must be in degrees:'..type(dN))assert(di(dO),'Argument 4 (longitude) must be in degrees:'..type(dO))assert(di(dP),'Argument 5 (altitude) must be in meters:'..type(dP))end;dF=tonumber(dF)dG=tonumber(dG)dN=tonumber(dN)dO=tonumber(dO)dP=tonumber(dP)if dG==0 then return setmetatable({latitude=dN,longitude=dO,altitude=dP,bodyId=dG,systemId=dF},MapPosition)end;return setmetatable({latitude=dr*q(dN,-90,90),longitude=dr*(dO%360),altitude=dP,bodyId=dG,systemId=dF},MapPosition)end;local dQ={}dQ.__index=dQ;dQ.__tostring=function(dw,dA)local dR=dA and dA..'  'local dS={}local dB={}for dc in pairs(dw)do table.insert(dB,dc)end;table.sort(dB)for _,dT in ipairs(dB)do bdy=dw[dT]local dU=dz.__tostring(bdy,dR)if dA then table.insert(dS,e('[%s]={\n%s\n%s}',dT,dU,dA))else table.insert(dS,e('  [%s]=%s',dT,dU))end end;if dA then return e('\n%s%s%s',dA,table.concat(dS,',\n'..dA),dA)end;return e('{\n%s\n}',table.concat(dS,',\n'))end;local function dV(dW)local a_={}local pid;for _,dd in pairs(dW)do local id=dd.planetarySystemId;if type(id)~='number'then error('Invalid planetary system ID: '..tostring(id))elseif pid and id~=pid then error('Mistringmatch planetary system IDs: '..id..' and '..pid)end;local dX=dd.bodyId;if type(dX)~='number'then error('Invalid body ID: '..tostring(dX))elseif a_[dX]then error('Duplicate body ID: '..tostring(dX))end;setmetatable(dd.center,getmetatable(vec3.unit_x))a_[dX]=setmetatable(dd,dz)pid=id end;return setmetatable(a_,dQ)end;b3={}local function dY(dW)return setmetatable({galaxyAtlas=dW or{}},b3)end;b3.__index=function(dk,i)if type(i)=='number'then local system=dk.galaxyAtlas[i]return dV(system)end;return rawget(b3,i)end;b3.__pairs=function(dw)return function(dk,dc)local dZ,nv=next(dk,dc)return dZ,nv and dV(nv)end,dw.galaxyAtlas,nil end;b3.__tostring=function(dw)local d_={}for _,e0 in pairs(dw or{})do local e1=e0:getPlanetarySystemId()local e2=dQ.__tostring(e0,'    ')table.insert(d_,e('  [%s]={%s\n  }',e1,e2))end;return e('{\n%s\n}\n',table.concat(d_,',\n'))end;b3.BodyParameters=dE;b3.MapPosition=dL;b3.PlanetarySystem=dV;function b3.createBodyParameters(e3,dG,e4,e5,e6,e7,e8)assert(di(e3),'Argument 1 (planetarySystemId) must be a number:'..type(e3))assert(di(dG),'Argument 2 (bodyId) must be a number:'..type(dG))assert(di(e4),'Argument 3 (surfaceArea) must be a number:'..type(e4))assert(dj(e5),'Argument 4 (aPosition) must be an array or vec3:'..type(e5))assert(dj(e6),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(e6))assert(di(e7),'Argument 6 (altitude) must be in meters:'..type(e7))assert(di(e8),'Argument 7 (gravityAtPosition) must be number:'..type(e8))local dH=math.sqrt(e4/4/math.pi)local ag=dH+e7;local e9=vec3(e5)+ag*vec3(e6)local dJ=e8*ag*ag;return dE(e3,dG,dH,e9,dJ)end;b3.isMapPosition=dp;function b3:getPlanetarySystem(dM)if i==nil then i=0 end;if nv==nil then nv=0 end;local e3=dM;if dp(dM)then e3=dM.systemId end;if type(e3)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dQ then system=dV(system)end;return system end end end;function dQ:castIntersections(ea,cV,eb,ec,ed)local eb=eb or function(ee)return 1.05*ee.radius end;local ef={}local eg;if ed then eg=ed else eg=self end;if ec then for _,i in ipairs(ec)do ef[i]=eg[i]end else ec={}for dc,ee in pairs(eg)do table.insert(ec,dc)ef[dc]=ee end end;local function eh(ei,ej)local bZ=ef[ei].center-ea;local b_=ef[ej].center-ea;return bZ:len()<b_:len()end;table.sort(ec,eh)local ek=cV:normalize()for i,id in ipairs(ec)do local ee=ef[id]local el=ee.center-ea;local dH=eb(ee)local em=el:dot(ek)local en=em^2-(el:len2()-dH^2)if en>=0 then local eo=math.sqrt(en)local ep=em+eo;local eq=em-eo;if eq>0 then return ee,ep,eq elseif ep>0 then return ee,ep,nil end end end;return nil,nil,nil end;function dQ:closestBody(er)assert(type(er)=='table','Invalid coordinates.')local es,ee;local et=vec3(er)for _,eu in pairs(self)do local ev=(eu.center-et):len2()if(not ee or ev<es)and eu.name~="Space"then ee=eu;es=ev end end;return ee end;function dQ:convertToBodyIdAndWorldCoordinates(dM)local ew=dM;if dl(dM)then ew=dL(dM)end;if ew.bodyId==0 then return 0,vec3(ew.latitude,ew.longitude,ew.altitude)end;local eu=self:getBodyParameters(ew)if eu then return ew.bodyId,eu:convertToWorldCoordinates(ew)end end;function dQ:getBodyParameters(dM)local dG=dM;if dp(dM)then dG=dM.bodyId end;assert(di(dG),'Argument 1 (bodyId) must be a number:'..type(dG))return self[dG]end;function dQ:getPlanetarySystemId()local _,dd=next(self)return dd and dd.planetarySystemId end;function dz:convertToMapPosition(dI)assert(dj(dI),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dI))local ex=vec3(dI)if self.bodyId==0 then return setmetatable({latitude=ex.x,longitude=ex.y,altitude=ex.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local ey=ex-self.center;local ag=ey:len()local dP=ag-self.radius;local dN=0;local dO=0;if not cy(ag,0)then local ez=m(ey.y,ey.x)dO=ez>=0 and ez or 2*math.pi+ez;dN=math.pi/2-math.acos(ey.z/ag)end;return setmetatable({latitude=dN,longitude=dO,altitude=dP,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dz:convertToWorldCoordinates(dM)local ew=dl(dM)and dL(dM)or dM;if ew.bodyId==0 then return vec3(ew.latitude,ew.longitude,ew.altitude)end;assert(dp(ew),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(ew.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(ew.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local eA=math.cos(ew.latitude)return self.center+(self.radius+ew.altitude)*vec3(eA*math.cos(ew.longitude),eA*math.sin(ew.longitude),math.sin(ew.latitude))end;function dz:getAltitude(dI)return(vec3(dI)-self.center):len()-self.radius end;function dz:getDistance(dI)return(vec3(dI)-self.center):len()end;function dz:getGravity(dI)local eB=self.center-vec3(dI)local eC=eB:len2()return self.GM/eC*eB/math.sqrt(eC)end;return setmetatable(b3,{__call=function(_,...)return dY(...)end})end;local function eD()local b5={}local eE=30000000/3600;local eF=eE*eE;local eG=100;local function eH(dd)return 1/math.sqrt(1-dd*dd/eF)end;function b5.computeAccelerationTime(eI,eJ,eK)local eL=eE*math.asin(eI/eE)return(eE*math.asin(eK/eE)-eL)/eJ end;function b5.computeDistanceAndTime(eI,eK,eM,eN,eO,eP)eO=eO or 0;eP=eP or 0;local eQ=eI<=eK;local eR=eN*(eQ and 1 or-1)/eM;local eS=-eP/eM;local eT=eR+eS;if eQ and eT<=0 or not eQ and eT>=0 then return-1,-1 end;local eU,eV=0,0;if eR~=0 and eO>0 then local eL=math.asin(eI/eE)local eW=math.pi*(eR/2+eS)local eX=eR*eO;local eY=eE*math.pi;local dd=function(dk)local eZ=(eW*dk-eX*math.sin(math.pi*dk/2/eO)+eY*eL)/eY;local e_=math.tan(eZ)return eE*e_/math.sqrt(e_*e_+1)end;local f0=eQ and function(dm)return dm>=eK end or function(dm)return dm<=eK end;eV=2*eO;if f0(dd(eV))then local f1=0;while c(eV-f1)>0.5 do local dk=(eV+f1)/2;if f0(dd(dk))then eV=dk else f1=dk end end end;local f2=eI;local f3=eV/eG;for f4=1,eG do local f5=dd(f4*f3)eU=eU+(f5+f2)*f3/2;f2=f5 end;if eV<2*eO then return eU,eV end;eI=f2 end;local eL=eE*math.asin(eI/eE)local A=(eE*math.asin(eK/eE)-eL)/eT;local f6=eF*math.cos(eL/eE)/eT;local ag=f6-eF*math.cos((eT*A+eL)/eE)/eT;return ag+eU,A+eV end;function b5.computeTravelTime(eI,eJ,ag)if ag==0 then return 0 end;if eJ>0 then local eL=eE*math.asin(eI/eE)local f6=eF*math.cos(eL/eE)/eJ;return(eE*math.acos(eJ*(f6-ag)/eF)-eL)/eJ end;if eI==0 then return-1 end;assert(eI>0,'Acceleration and initial speed are both zero.')return ag/eI end;function b5.lorentz(dd)return eH(dd)end;return b5 end;local function f7()local vec3=require('cpml.vec3')local df=df()local function dl(dm)return type(dm)=='string'end;local function dj(dk)return type(dk)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dP)assert(self.body)local ag=dP+self.body.radius;if not cy(ag,0)then local orbit=math.sqrt(self.body.GM/ag)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dM,f8)assert(self.body)assert(dj(dM)or dl(dM))assert(dj(f8))local c7=(dl(dM)or df.isMapPosition(dM))and self.body:convertToWorldCoordinates(dM)or vec3(dM)local dd=vec3(f8)local f9=c7-self.body.center;local b_=dd:len2()local fa=f9:len()local fb=self.body.GM;local fc=((b_-fb/fa)*f9-f9:dot(dd)*dd)/fb;local cz=fb/(2*fb/fa-b_)local fd=fc:len()local ek=fc:normalize()local fe=cz*(1-fd)local ff=cz*(1+fd)local fg=fe*ek+self.body.center;local fh=fd<=1 and-ff*ek+self.body.center or nil;local fi=math.sqrt(cz*fb*(1-fd*fd))local fj=fh and 2*math.pi*math.sqrt(cz^3/fb)local fk=math.acos(fc:dot(f9)/(fd*fa))if f9:dot(dd)<0 then fk=-(fk-2*math.pi)end;local fl=math.acos((math.cos(fk)+fd)/(1+fd*math.cos(fk)))local fm=fl;if fm<0 then fm=fm+2*math.pi end;local fn=fm-fd*math.sin(fm)local fo=0;local fp=0;local fq=0;if fj~=nil then fo=fn/(2*math.pi/fj)fp=fj-fo;fq=fp+fj/2;if fk-math.pi>0 then fp=fo;fq=fp+fj/2 end;if fq>fj then fq=fq-fj end end;return{periapsis={position=fg,speed=fi/fe,circularOrbitSpeed=math.sqrt(fb/fe),altitude=fe-self.body.radius},apoapsis=fh and{position=fh,speed=fi/ff,circularOrbitSpeed=math.sqrt(fb/ff),altitude=ff-self.body.radius},currentVelocity=dd,currentPosition=c7,eccentricity=fd,period=fj,eccentricAnomaly=fl,meanAnomaly=fn,timeToPeriapsis=fp,timeToApoapsis=fq}end;local function fr(fs)local eu=df.BodyParameters(fs.planetarySystemId,fs.bodyId,fs.radius,fs.center,fs.GM)return setmetatable({body=eu},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return fr(...)end})end;local function ft()local fu=0;local function fv(fw)local dH=500000;local fx,fy,fz=math.huge;local fA=false;local fB=vec3({13771471,7435803,-128971})local fC=18000000;fx=vec3(fw):dist(fB)if fx<fC then return true,c(fx-fC),"Safe Zone",0 end;fy=vec3(fw):dist(vec3(planet.center))if fy<dH then fA=true end;if c(fy-dH)<c(fx-fC)then return fA,c(fy-dH),planet.name,planet.bodyId else return fA,c(fx-fC),"Safe Zone",0 end end;local function fD(dd)if aH==1920 then return dd else return x(aH*dd/1920,0)end end;local function fE(dd)if aI==1080 then return dd else return x(aI*dd/1080,0)end end;local function fF()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function fG()local fH="TRAVEL"if not bM then fH="CRUISE"end;if Autopilot then fH="AUTOPILOT"end;return fH end;local function fI(fJ,aY,cp,fK,fL,fM,fN,fO)local fP=1;local fQ=2;local fR=3;local fS=4;local fT=5;local fU=6;local fV=""local fW=0;local fX=fuelY;local fY=fuelY+5;if not BarFuelDisplay then fY=fY+5 end;if l()==1 and not RemoteHud then fX=fX-50;fY=fY-50 end;if fL=="ATMO"then fV="atmofueltank"elseif fL=="SPACE"then fV="spacefueltank"else fV="rocketfueltank"end;fW=_G[fV.."_size"]if#fM>0 then for i=1,#fM do local fZ=string.sub(fM[i][fQ],1,12)local f_=0;for g0=1,fW do if fM[i][fQ]==f(unit[fV.."_"..g0].getData()).name then f_=g0;break end end;if aY or fN[i]==nil or fO[i]==nil then local g1=0;local g2=0;local g3=0;local g4=0;local g5=p()if f_~=0 then fO[i]=f(unit[fV.."_"..f_].getData()).percentage;fN[i]=f(unit[fV.."_"..f_].getData()).timeLeft;if fN[i]=="n/a"then fN[i]=0 end else g3=k(fM[i][fP])-fM[i][fS]g1=fM[i][fR]fO[i]=d(0.5+g3*100/g1)g2=fM[i][fT]g4=fM[i][fU]if g2<=g3 then fN[i]=0 else fN[i]=d(0.5+g3/((g2-g3)/(g5-g4)))end;fM[i][fT]=g3;fM[i][fU]=g5 end end;if fZ==fK then fZ=e("%s %d",fL,i)end;if f_==0 then fZ=fZ.." *"end;local g6;if fN[i]==0 then g6=""else g6=d3(fN[i])end;if fO[i]~=nil then local g7=d(fO[i]*2.55)local g8=e("rgb(%d,%d,%d)",255-g7,g7,0)local cs=""if g6~=""and fN[i]<120 or fO[i]<5 then if aY then cs=[[class="red"]]end end;if BarFuelDisplay then table.insert(fJ,e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cp,fY,g8,fO[i],cp,fY,cp+2,fY+10,fO[i],g6))fJ[#fJ+1]=co(cp,fX,fZ,cs.."txtstart pdim txtfuel")fX=fX-30;fY=fY-30 else fJ[#fJ+1]=co(cp,fX,fZ,cs.." pdim txtfuel")fJ[#fJ+1]=co(cp,fY,e("%d%% %s",fO[i],g6),"pdim txtfuel","fill:"..g8)fX=fX+30;fY=fY+30 end end end end end;local function g9(fJ,dP)if dP<200000 and not ao or dP and ao then local ga=0;if c(bG)>1 then ga=45*math.log(c(bG),10)if bG<0 then ga=-ga end end;fJ[#fJ+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bG),d(ga))end;return fJ end;local function gb(gc)local gd=-bF;gc=gc-gc:project_on(gd)local ge=vec3(0,0,1)ge=ge-ge:project_on(gd)local gf=ge:cross(gd)local ga=ge:angle_between(gc)*constants.rad2deg;if gc:dot(gf)<0 then ga=360-ga end;return ga end;local function gg(fJ,centerX,centerY,gh,gi,nearPlanet)local gj=circleRad;local gk=20;local gl=d(gh)if nearPlanet then for i=-45,45,5 do local gm=i;fJ[#fJ+1]=e([[<g transform="rotate(%f,%d,%d)">]],gm,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fJ[#fJ+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gj+gk-len,centerX,centerY+gj+gk)end;fJ[#fJ+1]=co(centerX,centerY+gj+gk-35,gi,"pdim txt txtmid")fJ[#fJ+1]=co(centerX,centerY+gj+gk-25,gl.." deg","pdim txt txtmid")fJ[#fJ+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gh,centerX,centerY)fJ[#fJ+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gj+gk-20,centerX+5,centerY+gj+gk-20,centerX,centerY+gj+gk-15)fJ[#fJ+1]="</g>"end;local gn=gl;if nearPlanet then gn=gb(bB)end;local go=20;local gp=d(gn)local gq=0;local gr=centerY+gj+gk+20;local gs=centerX;if gi~="YAW"then gr=fE(130)gs=fD(960)end;local gt=[[<path class="txttick line" d="]]local gu=d(gp-(go+10)-gp%5+0.5)for i=gu+60,gu,-5 do local cp=gs-(-i*5+gn*5)if i%10==0 then gq=10;local num=i;if num==360 then num=0 elseif num>360 then num=num-360 elseif num<0 then num=num+360 end;fJ[#fJ+1]=co(cp+5,gr-12,num)elseif i%5==0 then gq=5 end;if gq==10 then gt=e([[%s M %f %f v %d]],gt,cp,gr-5,gq)else gt=e([[%s M %f %f v %d]],gt,cp,gr-2.5,gq)end end;fJ[#fJ+1]=gt..[["/>]]fJ[#fJ+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],gs-5,gr+10,gs+5,gr+10,gs,gr+5)if nearPlanet then gi="HDG"end;fJ[#fJ+1]=co(gs,gr+25,gp.."deg","pdim txt txtmid","")fJ[#fJ+1]=co(gs,gr+35,gi,"pdim txt txtmid","")end;local function gv(fJ,gw,gh,centerX,centerY,nearPlanet,gx,f5)local gj=circleRad;local gy=d(gj*3/5)if gj>0 then local gz=d(gw)local len=0;local gt=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gh,centerX,centerY)if not ao then gt=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fJ[#fJ+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gj-1,centerX,centerY)fJ[#fJ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gz-30-gz%5+0.5),d(gz+30+gz%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cq=centerY+-i*5+gw*5;if len==30 then gt=e([[%s M %d %f h %d]],gt,centerX-gy-len,cq,len)if ao then fJ[#fJ+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gh,centerX,centerY,centerX-gy+10,cq,i)fJ[#fJ+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gh,centerX,centerY,centerX+gy-10,cq,i)if i==0 or i==180 or i==-180 then fJ[#fJ+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gh,centerX,centerY,centerX-gy+20,cq,gy*2-40)end else fJ[#fJ+1]=co(centerX-gy+10,cq,i,"pdim txt txtmid")fJ[#fJ+1]=co(centerX+gy-10,cq,i,"pdim txt txtmid")end;gt=e([[%s M %d %f h %d]],gt,centerX+gy,cq,len)else gt=e([[%s M %d %f h %d]],gt,centerX-gy-len,cq,len)gt=e([[%s M %d %f h %d]],gt,centerX+gy,cq,len)end end;fJ[#fJ+1]=gt..[["/>]]local gA="PITCH"if not nearPlanet then gA="REL PITCH"end;if gw>90 and not ao then gw=90-(gw-90)elseif gw<-90 and not ao then gw=-90-(gw+90)end;if gj>200 then if ao then if f5>N then fJ[#fJ+1]=co(centerX,centerY-15,"Yaw","pdim txt txtmid")fJ[#fJ+1]=co(centerX,centerY+20,gx,"pdim txt txtmid")end;fJ[#fJ+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gh,centerX,centerY)else fJ[#fJ+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fJ[#fJ+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gy+25,centerY-5,centerX-gy+20,centerY,centerX-gy+25,centerY+5,centerX-gy+50,centerY+4,gz)fJ[#fJ+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gy-25,centerY-5,centerX+gy-20,centerY,centerX+gy-25,centerY+5,centerX+gy-30,centerY+4,gz)fJ[#fJ+1]="</g>"end;local gB=d(gj/3)fJ[#fJ+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gB,centerY,gj-gB)if not ao and nearPlanet then fJ[#fJ+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gh,centerX,centerY,centerX-gy+10,centerY,gy*2-20)end;fJ[#fJ+1]="</g>"if gj<200 then if ao and f5>N then fJ[#fJ+1]=co(centerX,centerY-gj,gA,"pdim txt txtmid")fJ[#fJ+1]=co(centerX,centerY-gj+10,gz,"pdim txt txtmid")fJ[#fJ+1]=co(centerX,centerY-15,"Yaw","pdim txt txtmid")fJ[#fJ+1]=co(centerX,centerY+20,gx,"pdim txt txtmid")else fJ[#fJ+1]=co(centerX,centerY-gj,gA,"pdim txt txtmid")fJ[#fJ+1]=co(centerX,centerY-gj+15,gz,"pdim txt txtmid")end end end end;local function gC(fJ,dP,nearPlanet)local gD=altMeterX;local gE=altMeterY;local gF=78;local gG=19;local gH=am;if am~=-1 then fJ[#fJ+1]=co(gD+gF,gE+gG+20,e("AGL: %.1fm",am),"pdim altsm txtend")end;if nearPlanet and(dP<200000 and not ao or dP and ao)then table.insert(fJ,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gD-1,gE-4,gF+2,gG+6,gD+1,gE-1,gF-4,gG))local cM=0;local gI=1;local gJ=0;local gK=dP<0;local gL=9;if gK then gL=0 end;local dP=c(dP)while cM<6 do local gM=11;local gN=16;local gO=9;local gP=14;local cs="altsm"if cM>2 then gN=gN+3;gM=gM+2;gP=gP+2;gO=gO-6;cs="altbig"end;if gK then cs=cs.." red"end;local gQ=dP/gI%10;local gR=d(gQ)local gS=d((gR+1)%10)local gT=gJ;if cM==0 then gT=gQ-gR;if gK then gT=1-gT end end;if gK and(cM==0 or gJ~=0)then local gU=gS;gS=gR;gR=gU end;local gV=gN*(gT-1)local gW=gV+gN;local cp=gD+gO+(6-cM)*gM;local cq=gE+gP;fJ[#fJ+1]=co(cp,cq+gV,gS,cs)fJ[#fJ+1]=co(cp,cq+gW,gR,cs)cM=cM+1;gI=gI*10;if gR==gL then gJ=gT else gJ=0 end end;table.insert(fJ,[[</g></g>]])end end;local function gX(f8)f8=vec3(f8)local gY=-math.deg(m(f8.y,f8.z))+180;gY=gY-90;if gY<0 then gY=360+gY end;if gY>180 then gY=-180+gY-180 end;return-gY end;local function gZ(f8)f8=vec3(f8)local gn=math.deg(m(f8.y,f8.x))-90;if gn<-180 then gn=360+gn end;return gn end;local function g_(fJ,f8,f5,centerX,centerY)if f5>5 and not ao or f5>N then local gj=circleRad;local h0=20;local h1=20;local h2=vec3(f8)local h3=gX(h2)local h4=gZ(h2)local h5=14;local h6=h5/2;local h7=-h4/h1*gj;local h8=h3/h0*gj;local cp=centerX+h7;local cq=centerY+h8;local ag=math.sqrt(h7^2+h8^2)local h9=[[<circle
                            cx="]]..cp..[["
                            cy="]]..cq..[["
                            r="]]..h6/h5 ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cp..[["
                            cy="]]..cq..[["
                            r="]]..h6 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cp-h5 ..[[,]]..cq..[[ h ]]..h6 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cp+h6 ..[[,]]..cq..[[ h ]]..h6 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cp..[[,]]..cq-h5 ..[[ v ]]..h6 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ag<gj then fJ[#fJ+1]=h9 else local ga=m(h8,h7)local ha=4;local hb=centerX+gj*math.cos(ga)local hc=centerY+gj*math.sin(ga)fJ[#fJ+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',ga*180/math.pi,hb,hc,hb-ha,hc-ha/2,ha*2,ha,hb+ha,hc-ha,ha,ha,-ha,ha)end;if not ao then h3=gX(-h2)h4=gZ(-h2)h7=-h4/h1*gj;h8=h3/h0*gj;cp=centerX+h7;cq=centerY+h8;ag=math.sqrt(h7^2+h8^2)if ag<gj then local hd=[[<circle
                                    cx="]]..cp..[["
                                    cy="]]..cq..[["
                                    r="]]..h6 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cp..[[,]]..cq-h5 ..[[ v ]]..h6 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cp..[[,]]..cq..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cp..[[,]]..cq..[[)" />
                                <path
                                    d="M ]]..cp-h6 ..[[,]]..cq..[[ h ]]..h5 ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cp..[[,]]..cq..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cp..[[,]]..cq..[[)"/>]]fJ[#fJ+1]=hd end end end end;local function he(fJ,fH,hf,hg)hf=d(hf+0.5)local fX=throtPosY+10;local fY=throtPosY+20;if l()==1 and not RemoteHud then fX=55;fY=65 end;local hh="CRUISE"local unit="km/h"local cv=hg;if fH=="TRAVEL"or fH=="AUTOPILOT"then hh="THROT"unit="%"cv=hf;local hi="dim"if hf<0 then hi="red"end;fJ[#fJ+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hi,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(hf),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fJ[#fJ+1]=co(throtPosX+10,fX,hh,"pbright txtstart")fJ[#fJ+1]=co(throtPosX+10,fY,e("%.0f %s",cv,unit),"pbright txtstart")if ao and AtmoSpeedAssist and bM and J then hf=d(K*100+0.5)local hi="red"if hf<0 then hi="red"end;fJ[#fJ+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hi,1-c(hf),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fJ[#fJ+1]=co(throtPosX+10,fX+40,"LIMIT","pbright txtstart")fJ[#fJ+1]=co(throtPosX+10,fY+40,hf.."%","pbright txtstart")end;if ao and AtmoSpeedAssist or Reentry then fJ[#fJ+1]=co(throtPosX+10,fX-40,"LIMIT: "..bk.." km/h","dim txtstart")elseif not ao and Autopilot then fJ[#fJ+1]=co(throtPosX+10,fX-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hj(fJ,hk)local hl=throtPosY-10;local hm=throtPosX+10;fJ[#fJ+1]=co(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then hl=75 end;fJ[#fJ+1]=co(hm,hl,d(hk).." km/h","pbright txtbig txtstart")end;local function hn(fJ)fJ[#fJ+1]=co(fD(1900),fE(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fJ[#fJ+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fJ[#fJ+1]=co(fD(960),fE(550),"Warning: Invalid Control Scheme Detected","warnings")fJ[#fJ+1]=co(fD(960),fE(600),"Keyboard Scheme must be selected","warnings")fJ[#fJ+1]=co(fD(960),fE(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ho=fD(960)local hp=fE(860)local hq=fE(880)local hr=fE(900)local hs=fE(960)local ht=fE(200)local hu=fE(250)local hv=fE(960)if l()==1 and not RemoteHud then hp=fE(135)hq=fE(155)hr=fE(175)ht=fE(115)hu=fE(95)end;if BrakeIsOn then fJ[#fJ+1]=co(ho,hp,"Brake Engaged","warnings")elseif I>0 then fJ[#fJ+1]=co(ho,hp,"Auto-Brake Engaged","warnings","opacity:"..I)end;if ao and bf and am==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bK and not VertTakeOff and not AutoTakeoff then fJ[#fJ+1]=co(ho,ht+50,"** STALL WARNING **","warnings")cb("stall","SW",2)end end;if bW then fJ[#fJ+1]=co(ho,ht+70,"Flight Assist in Progress","warnings")end;if av then fJ[#fJ+1]=co(ho,hv,"Gyro Enabled","warnings")end;if GearExtended then if P then fJ[#fJ+1]=co(ho,hq,"Gear Extended","warn")else fJ[#fJ+1]=co(ho,hq,"Landed (G: Takeoff)","warnings")end;local hw=cB(a:getTargetGroundAltitude())fJ[#fJ+1]=co(ho,hr,"Hover Height: "..hw,"warn")end;if a4 then fJ[#fJ+1]=co(ho,hs+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bK and AntigravTargetAltitude~=nil then if c(aq-antigrav.getBaseAltitude())<501 then fJ[#fJ+1]=co(ho,ht+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fJ[#fJ+1]=co(ho,ht+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fJ[#fJ+1]=co(ho,ht+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fJ[#fJ+1]=co(ho,ht+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif X then fJ[#fJ+1]=co(ho,ht+20,"Follow Mode Engaged","warn")elseif Reentry then fJ[#fJ+1]=co(ho,ht+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local hw=cB(HoldAltitude,2)if VertTakeOff then if bK then hw=cB(antigrav.getBaseAltitude(),2).." AGG singularity height"end;fJ[#fJ+1]=co(ho,ht,"VTO to "..hw,"warn")elseif AutoTakeoff and not IntoOrbit then if ak then fJ[#fJ+1]=co(ho,ht,"Takeoff to "..AutopilotTargetName,"warn")else fJ[#fJ+1]=co(ho,ht,"Takeoff to "..hw,"warn")end;if BrakeIsOn and not VertTakeOff then fJ[#fJ+1]=co(ho,ht+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fJ[#fJ+1]=co(ho,ht,"Altitude Hold: "..hw,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ap>0.1 then fJ[#fJ+1]=co(ho,ht+20,"Beginning ascent","warn")elseif ap<0.09 and ap>0.05 then fJ[#fJ+1]=co(ho,ht+20,"Aligning trajectory","warn")elseif ap<0.05 then fJ[#fJ+1]=co(ho,ht+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bm~=nil then fJ[#fJ+1]=co(ho,ht,bm,"warn")end end;if IntruderAlertSystem and safeMass==-1 then fJ[#fJ+1]=co(ho,ht+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bI.."kg DETECTED","warnings")cb("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then fJ[#fJ+1]=co(ho,ht,"Brake-Landing","warnings")else fJ[#fJ+1]=co(ho,ht,"Coast-Landing","warnings")end end;if ProgradeIsOn then fJ[#fJ+1]=co(ho,ht,"Prograde Alignment","crit")end;if RetrogradeIsOn then fJ[#fJ+1]=co(ho,ht,"Retrograde Alignment","crit")end;local hx,ep,eq=b4:getPlanetarySystem(0):castIntersections(bH,bD:normalize(),function(ee)if ee.noAtmosphericDensityAltitude>0 then return ee.radius+ee.noAtmosphericDensityAltitude else return ee.radius+ee.surfaceMaxAltitude*1.5 end end)local hy=ep;if eq~=nil and ep~=nil then hy=math.min(eq,ep)end;if hy~=nil and ap==0 then local hw=cB(hy)local travelTime=b5.computeTravelTime(bE,0,hy)local hz="Collision"if hx.noAtmosphericDensityAltitude>0 then hz="Atmosphere"end;fJ[#fJ+1]=co(ho,hu+20,hx.name.." "..hz.." "..d3(travelTime).." In "..hw,"crit")end;if collisionAlertStatus then local type;if string.find(collisionAlertStatus,"COLLISION")then type="warnings"else type="crit"end;fJ[#fJ+1]=co(ho,hu+20,collisionAlertStatus,type)end;if VectorToTarget and not IntoOrbit then fJ[#fJ+1]=co(ho,ht+35,VectorStatus,"warn")end;fJ[#fJ+1]="</g>"return fJ end;local function hA(f5)return d(x(f5*3.6,0)+0.5).." km/h"end;local function hB(fJ)local hC=OrbitMapX;local hD=OrbitMapY;local hE=OrbitMapSize;local hF=4;local hG=15;local cp=0;local cq=0;local hH,hI,hJ,hK;local function hL(type)local hM,A,f5,hN;if type=="Periapsis"then hM=orbit.periapsis.altitude;A=orbit.timeToPeriapsis;f5=orbit.periapsis.speed;hN=35 else hM=orbit.apoapsis.altitude;A=orbit.timeToApoapsis;f5=orbit.apoapsis.speed;hN=-35 end;fJ[#fJ+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cp+hN,cq-5,hC+hE/2-hH+hK,cq-5)fJ[#fJ+1]=co(cp,cq,type)cq=cq+hG;local hw=cB(hM)fJ[#fJ+1]=co(cp,cq,hw)cq=cq+hG;fJ[#fJ+1]=co(cp,cq,d3(A))cq=cq+hG;fJ[#fJ+1]=co(cp,cq,hA(f5))end;if orbit~=nil and ap<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hD=hD+hF;cp=hC+hE+hC/2+hF;cq=hD+hE/2+5+hF;hH=hE/4;hK=0;fJ[#fJ+1]=[[<g class="pbright txtorb txtmid">]]fJ[#fJ+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hE+hC*2,hE+hD,hF,hF)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hJ=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hH*2)hI=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hJ*(1-orbit.eccentricity)hK=hH-orbit.periapsis.altitude/hJ-planet.radius/hJ;local hO=""if orbit.periapsis.altitude<=0 then hO='redout'end;fJ[#fJ+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hO,hC+hE/2+hK+hF,hD+hE/2+hF,hH,hI)fJ[#fJ+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hC+hE/2+hF,hD+hE/2+hF,planet.radius/hJ)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hL("Apoapsis")end;cq=hD+hE/2+5+hF;cp=hC-hC/2+10+hF;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hL("Periapsis")end;fJ[#fJ+1]=co(hC+hE/2+hF,planet.name,20+hF,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hP=orbit.timeToApoapsis/orbit.period*2*math.pi;local hQ=hH*math.cos(hP)local hR=hI*math.sin(hP)fJ[#fJ+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hC+hE/2+hQ+hK+hF,hD+hE/2+hR+hF)end;fJ[#fJ+1]=[[</g>]]return fJ else return fJ end end;local function hS()if radarPanelID~=nil and ai==0 then s(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then s(perisPanelID)perisPanelID=nil end else if ai==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;ai=0 end end;local function hT(fJ)local cp=30;local cq=275;local hU={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hV={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere"}local hW={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local hX={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle InHud Sounds","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if ao then ce(hU,hV)table.insert(hU,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(hU,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if am~=-1 then if antigrav then if bK then table.insert(hU,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hU,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hU,"Alt-6: Begins Vertical Takeoff.")else table.insert(hU,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hU,"G: Begin BrakeLanding or Land")end else ce(hU,hW)end;if AltitudeHold then table.insert(hU,"Alt-Spacebar/Alt-C will raise/lower target height")end;ce(hU,hX)for i=1,#hU do cq=cq+12;fJ[#fJ+1]=co(cp,cq,hU[i],"pdim txttick txtstart")end end;local function hY(hZ,h_)local i0;local i1=(h_-hZ):normalize()local f9=(bH-hZ):dot(i1)/i1:dot(i1)if f9<=0.then return(bH-hZ):len()elseif f9>=(h_-hZ):len()then return(bH-h_):len()end;local i2=hZ+f9*i1;i0=(i2-bH):len()return i0 end;local function i3()local i0;local i4=nil;local i5=nil;local i6=nil;for dc,i7 in pairs(a_[0])do if i7.hasAtmosphere then local ag=hY(planet.center,i7.center)if i4==nil or ag<i4 then i5=i7;i4=ag;i6=planet end;if a9 and a9.hasAtmosphere and a9.name~=planet.name then local ev=hY(a9.center,i7.center)if ev<i4 then i5=i7;i4=ev;i6=a9 end end end end;local i8=fD(1770)local i9=fE(330)if i4 then local ia="txttick "local ib=500000;if i4<i5.radius+ib or i4<i6.radius+ib then if bT then ia="txttick red "else ia="txttick orange "end end;i0=cB(i4,2)bV=co(i8,i9,"Pipe ("..i6.name.."--"..i5.name.."): "..i0,ia.."pbright txtmid")end end;local ic={}function ic.HUDPrologue(fJ)bT,fu,_,_=fv(bH)if not bT then E=PvPR;G=PvPG;F=PvPB else E=SafeR;G=SafeG;F=SafeB end;ax=[[rgb(]]..d(E+0.5)..","..d(G+0.5)..","..d(F+0.5)..[[)]]ay=[[rgb(]]..d(E*0.9+0.5)..","..d(G*0.9+0.5)..","..d(F*0.9+0.5)..[[)]]local ie=ax;local ig=ay;local ih=ax;local ii=ay;if fF()and not brightHud then ie=[[rgb(]]..d(E*0.4+0.5)..","..d(G*0.4+0.5)..","..d(F*0.3+0.5)..[[)]]ig=[[rgb(]]..d(E*0.3+0.5)..","..d(G*0.3+0.5)..","..d(F*0.2+0.5)..[[)]]end;fJ[#fJ+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],ie,ie,ih,ih,ig,ig,ii,ii,aH,aI)return fJ end;function ic.DrawVerticalSpeed(fJ,dP)g9(fJ,dP)end;function ic.UpdateHud(fJ)local dP=aq;local f8=core.getVelocity()local f5=vec3(f8):len()local gY=bN;local ij=bO;local gh=ij;local gw=bN;local hf=d(unit.getThrottle())local hk=f5*3.6;local hg=unit.getAxisCommandValue(0)local ik=fD(1770)local il=fE(310)if AtmoSpeedAssist and bM then hg=H;hf=H*100 end;local fH=fG()local gi="ROLL"if hf==nil then hf=0 end;if not nearPlanet then if f5>5 then gY=gX(f8)ij=gZ(f8)else gY=0;ij=0 end;gi="YAW"end;if fu>50000 and not ao then local im;if fu>200000 then im=x(fu/200000,2).." su"else im=x(fu/1000,1).." km"end;fJ[#fJ+1]=co(ik,il,"PvP Boundary: "..im,"pbright txtbig txtmid")end;fJ[#fJ+1]=ah;fJ[#fJ+1]=aC;fJ[#fJ+1]=bU;if bV~=""then fJ[#fJ+1]=bV end;if aZ%aT==0 then aY=true end;if fuelX~=0 and fuelY~=0 then fI(fJ,aY,fuelX,"Atmospheric ","ATMO",aM,aW,aX)fI(fJ,aY,fuelX+120,"Space fuel t","SPACE",aN,aU,aV)fI(fJ,aY,fuelX+240,"Rocket fuel ","ROCKET",aO,aR,aS)end;if aY then aY=false;aZ=0 end;aZ=aZ+1;g9(fJ,dP)if l()==0 or RemoteHud then if not fF()or brightHud then if nearPlanet then gg(fJ,centerX,centerY,gh,gi,nearPlanet)gv(fJ,gw,gh,centerX,centerY,nearPlanet,d(gZ(f8)),f5)else gg(fJ,centerX,centerY,ij,gi,nearPlanet)gv(fJ,gY,ij,centerX,centerY,nearPlanet,d(ij),f5)end;gC(fJ,dP,nearPlanet)g_(fJ,f8,f5,centerX,centerY)end end;he(fJ,fH,hf,hg)hj(fJ,hk)hn(fJ)hB(fJ)if showHelp then hT(fJ)end;return fJ end;function ic.HUDEpilogue(fJ)fJ[#fJ+1]="</svg>"return fJ end;function ic.ExtraData(fJ)local io=fD(1240)local ip=fE(55)local iq=ip+10;local ir;local is=0;local fH=fG()if VertTakeOffEngine then fH=fH.."-VERTICAL"end;if TurnBurn then fH="TB-"..fH end;if not stablized then fH=fH.."-DeCoupled"end;local it=vec3(core.getWorldAcceleration()):len()/9.80665;ir=core.g()fJ[#fJ+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then io=fD(1120)ip=fE(55)iq=ip+10 elseif ao then local iu=fD(770)fJ[#fJ+1]=co(iu,ip,"ATMOSPHERE","pdim txt txtend")fJ[#fJ+1]=co(iu,iq,e("%.2f",ap),"pdim txt txtend","")end;fJ[#fJ+1]=co(io,ip,"GRAVITY","pdim txt txtend")fJ[#fJ+1]=co(io,iq,e("%.2f",ir/9.80665),"pdim txt txtend")fJ[#fJ+1]=co(io,ip+20,"ACCEL","pdim txt txtend")fJ[#fJ+1]=co(io,iq+20,e("%.2f",it),"pdim txt txtend")fJ[#fJ+1]=co(fD(960),fE(180),fH,"txtbig txtmid")end;function ic.DrawOdometer(fJ,aa,TotalDistanceTravelled,ab)local ir;local iv=0;local iw=0;local is=0;if ao then is=LastMaxBrakeInAtmo else is=LastMaxBrake end;maxThrust=a:maxForceForward()ir=core.g()if ir>0.1 then iw=at*ir;iv=maxThrust/ir end;fJ[#fJ+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fD(660),fD(700),fE(35),fD(960),fE(55),fD(1240),fE(35),fD(1280))if l()==0 or RemoteHud then fJ[#fJ+1]=co(fD(700),fE(20),e("Trip: %.2f km",aa),"txtstart")fJ[#fJ+1]=co(fD(700),fE(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fJ[#fJ+1]=co(fD(830),fE(20),"Trip Time: "..d3(ab),"txtstart")fJ[#fJ+1]=co(fD(830),fE(30),"Total Time: "..d3(TotalFlightTime),"txtstart")fJ[#fJ+1]=co(fD(970),fE(20),e("Mass: %.2f Tons",at/1000),"txtstart")fJ[#fJ+1]=co(fD(1240),fE(10),e("Max Brake: %.2f kN",is/1000),"txtend")fJ[#fJ+1]=co(fD(1240),fE(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if ir>0.1 then fJ[#fJ+1]=co(fD(970),fE(30),e("Max Mass: %.2f Tons",iv/1000),"txtstart")fJ[#fJ+1]=co(fD(1240),fE(20),e("Req Thrust: %.2f kN",iw/1000),"txtend")else fJ[#fJ+1]=co(fD(970),fE(30),"Max Mass: n/a","txtstart")fJ[#fJ+1]=co(fD(1240),fE(20),"Req Thrust: n/a","txtend")end end;fJ[#fJ+1]="</g>"return fJ end;function ic.DrawWarnings(fJ)return hn(fJ)end;function ic.DisplayOrbitScreen(fJ)return hB(fJ)end;function ic.DisplayMessage(fJ,hw)if hw~="empty"then local cq=310;for ix in string.gmatch(hw,"([^\n]+)")do cq=cq+35;fJ[#fJ+1]=co("50%",cq,ix,"msg")end end;if af~=0 then unit.setTimer("msgTick",af)af=0 end end;function ic.DrawDeadZone(fJ)fJ[#fJ+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function ic.UpdatePipe()if ao then bV=""return end;i3()end;function ic.UpdateRadarRoutine()local iy=A;local function iz(iA,iB,iC,iD,iE,iF,iG,iH)iB,iD,iF,iH=vec3(iB),vec3(iD),vec3(iF),vec3(iH)local iI,iJ,iK=iA*iA,iC*iC,iE*iE;local b_=iD-iB;local iL=b_:normalize()local iM=b_:len()local c0=iF-iB;local iN=(c0-c0:project_on(iL)):normalize()local iO,iP=c0:dot(iL),c0:dot(iN)local iQ=iO*iO+iP*iP;local iR=iL:cross(iN)local cp=(iI-iJ+iM*iM)/(2*iM)local cq=(iI-iK+iQ-2*iO*cp)/(2*iP)local dq=iI-cp^2-cq^2;local iS=math.sqrt(dq)local iT=iB+iL*cp+iN*cq+iR*iS;local iU=iB+iL*cp+iN*cq-iR*iS;if math.abs((iH-iT):len()-iG)<math.abs((iH-iU):len()-iG)then return iT else return iU end end;local function iV(iW,fa,iX)local iY=iW.pts;local cM=#iY;local iZ=iW.ref;if cM>3 then local i_,j0,j1,j2=iY[cM],iY[cM-1],iY[cM-2],iY[cM-3]iW.ref=iX;local c7=iz(i_[1],i_[2],j0[1],j0[2],j1[1],j1[2],j2[1],j2[2])local cp,cq,iS=c7.x,c7.y,c7.z;if cp==cp and cq==cq and iS==iS then cp=cp+iZ[1]cq=cq+iZ[2]iS=iS+iZ[3]local j3=iW.center;if j3==nil or iW.i>2 then iW.center=vec3(cp,cq,iS)iW.i=0 elseif c(j3.x-cp)>2 or c(j3.y-cq)>2 then iW.i=iW.i+1 else iW.i=0 end end;iW.pts={}else local j4={iX[1]-iZ[1],iX[2]-iZ[2],iX[3]-iZ[3]}iY[cM+1]={fa,j4}end end;if radar_1 then local j5=radar_1.getEntries()local j6={}local j7=radar_1.getData()local j8=j7:gmatch('{"constructId[^}]*}[^}]*}')local j9=fD(1770)local ja=fE(350)local iX=getTrueWorldPos()if#j5>0 then local friendlies={}local jb,jc,jd,je=0,0,0,0;for dd in j8 do local id,ag,jf=dd:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local jg=13;ag=tonumber(ag)if radar_1.hasMatchingTransponder(id)==1 then table.insert(friendlies,id)end;if ag>0 and radar_1.getConstructType(id)=="static"or radar_1.getConstructType(id)=="space"then jd=jd+1;if CollisionSystem then local fZ=radar_1.getConstructName(id)local iW=bX[id]if iW==nil then bX[id]={pts={},ref=iX,name=fZ,i=0,radius=jg}local jh={XS=13,S=27,M=55,L=110}jg=jh[jf]bX[id].radius=jg+D;iW=bX[id]end;iV(iW,ag,iX)if iW.center then table.insert(j6,iW)end;jc=jc+1 end end;jb=jb+1;if jb>500 or jc>50 then coroutine.yield()jb,jc=0,0 end end;if#j6>0 then local ee,ji,jj,jk;local jl=0;local jm=b4:getPlanetarySystem(0)jk=bD:normalize()while jl<#j6 do coroutine.yield()local jn={table.unpack(j6,jl,math.min(jl+75,#j6))}ee,ji,jj=jm:castIntersections(bH,jk,nil,nil,jn)if ee and jj then collisionTarget={ee,ji,jj}break end;jl=jl+75 end;if not ee then collisionTarget=nil end;je=#j6;j6={}else collisionTarget=nil end;local jo=j7:find('identifiedConstructs":%[%]')if jo==nil and perisPanelID==nil then ai=1;hS()end;if jo~=nil and perisPanelID~=nil then hS()end;if radarPanelID==nil then hS()end;local jp,jq;if nearPlanet then jq="Buildings"else jq="Stations"end;if CollisionSystem then jp=je.."/"..jd.." "..jq.." : "..#j5-jd.." Ships"else jp=jd.." "..jq.." : "..#j5-jd.." Ships"end;bU=co(j9,ja,jp,"pbright txtbig txtmid")if#friendlies>0 then local cq=fE(15)local cp=fD(1370)bU=bU..co(cp,cq,"Friendlies In Range","pbright txtbig txtmid")for dc,dd in pairs(friendlies)do cq=cq+20;bU=bU..co(cp,cq,radar_1.getConstructName(dd),"pdim txtmid")end end else local jr;jr=j7:find('worksInEnvironment":false')if jr then bU=co(j9,ja,"Radar: Jammed","pbright txtbig txtmid")else bU=co(j9,ja,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ai=0;hS()end end end;if timeCount<250 then totalTime=totalTime+A-iy;timeCount=timeCount+1 else system.print("Avg of 250 URR: "..totalTime/250)timeCount=0;totalTime=0 end end;function ic.UpdateRadar()local js=coroutine.status(UpdateRadarCoroutine)if js=="suspended"then local cv,jt=coroutine.resume(UpdateRadarCoroutine)if jt then system.print("ERROR UPDATE RADAR: "..jt)end elseif js=="dead"then UpdateRadarCoroutine=coroutine.create(ic.UpdateRadarRoutine)local cv,jt=coroutine.resume(UpdateRadarCoroutine)end end;function ic.DrawSettings(fJ)if#bQ>0 then local cp=fD(640)local cq=fE(200)fJ[#fJ+1]=[[<g class="pbright txtvspd txtstart">]]for dc,dd in pairs(bQ)do fJ[#fJ+1]=co(cp,cq,dd..": ".._G[dd])cq=cq+20;if dc%12==0 then cp=cp+fD(350)cq=fE(200)end end;fJ[#fJ+1]=co(fD(640),fE(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fJ[#fJ+1]="</g>"end;return fJ end;UpdateRadarCoroutine=coroutine.create(ic.UpdateRadarRoutine)return ic end;local function ju()local function jv()local function jw(jx,jy)return jx.name<jy.name end;bS={}for dc,dd in pairs(a_[0])do bS[#bS+1]={name=dd.name,index=dc}end;table.sort(bS,jw)end;local de={}function de.UpdateAtlasLocationsList()jv()end;function de.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"a9=nil;CustomTarget=nil;return true end;local jz=bS[AutopilotTargetIndex].index;local jA=a_[0][jz]if jA.center then AutopilotTargetName=jA.name;a9=b4[0][jz]if CustomTarget~=nil then if ap==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jA;for _,dd in pairs(b4[0])do if dd.name==CustomTarget.planetname then a9=dd;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(a9.center)else AutopilotTargetCoords=CustomTarget.position end;if a9.planetname~="Space"then if a9.hasAtmosphere then AutopilotTargetOrbit=d(a9.radius*(TargetOrbitRadius-1)+a9.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(a9.radius*(TargetOrbitRadius-1)+a9.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=b7(a9):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function de.adjustAutopilotTargetIndex(gd)if not Autopilot and not VectorToTarget and not ak and not IntoOrbit then if gd==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bS then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bS end end;if AutopilotTargetIndex==0 then b9.UpdateAutopilotTarget()else local jz=bS[AutopilotTargetIndex].index;local jA=a_[0][jz]if jA.name=="Space"or iphCondition=="Custom Only"and jA.center or iphCondition=="No Moons"and string.find(jA.name,"Moon")~=nil then if gd==nil then b9.adjustAutopilotTargetIndex()else b9.adjustAutopilotTargetIndex(1)end else b9.UpdateAutopilotTarget()end end else Z="Disengage autopilot before changing Interplanetary Helper"cb("iph","AP")end end;function de.findAtlasIndex(jB)for dc,dd in pairs(jB)do if dd.name and dd.name==CustomTarget.name then return dc end end;return-1 end;for dc,dd in pairs(SavedLocations)do table.insert(a_[0],dd)end;jv()de.UpdateAutopilotTarget()return de end;local function jC()local jD={}local jE={vec3(bD),-vec3(bD),vec3(bA),-vec3(bA),vec3(bC),-vec3(bC)}local function jF(f5)local jG=AutopilotEndSpeed;if not Autopilot then jG=0 end;if not ao then return b5.computeDistanceAndTime(f5,jG,at,0,0,LastMaxBrake-AutopilotPlanetGravity*at)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b5.computeDistanceAndTime(f5,jG,at,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*at)else return 0,0 end end end;local function jH(f5)local jG=AutopilotEndSpeed;if not Autopilot then jG=0 end;return b5.computeDistanceAndTime(f5,jG,at,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*at)end;function jD.GetAutopilotBrakeDistanceAndTime(f5)return jF(f5)end;function jD.GetAutopilotTBBrakeDistanceAndTime(f5)return jH(f5)end;local function jI(jJ,jK,jL)jK=jK:project_on_plane(jJ)jL=jL:project_on_plane(jJ)return m(jK:cross(jL):dot(jJ),jK:dot(jL))end;local function jM()local function jN()local jO=-1;local jP=-1;if vBooster then jO=vBooster.distance()end;if hover then jP=hover.distance()end;if jO~=-1 and jP~=-1 then if jO<jP then return jO else return jP end elseif jO~=-1 then return jO elseif jP~=-1 then return jP else return-1 end end;local jQ=jN()local jR=-1;if telemeter_1 then jR=telemeter_1.getDistance()end;if jQ~=-1 and jR~=-1 then if jQ<jR then return jQ else return jR end elseif jQ~=-1 then return jQ else return jR end end;local function jS(planet,er,jT)local function jU(jV,dI)local ex=vec3(dI)if jV.bodyId==0 then return setmetatable({latitude=ex.x,longitude=ex.y,altitude=ex.z,bodyId=0,systemId=jV.planetarySystemId},MapPosition)end;local ey=ex-jV.center;local ag=ey:len()local dP=ag-jV.radius;local dN=0;local dO=0;if not cy(ag,0)then local ez=m(ey.y,ey.x)dO=ez>=0 and ez or 2*math.pi+ez;dN=math.pi/2-math.acos(ey.z/ag)end;return setmetatable({latitude=math.deg(dN),longitude=math.deg(dO),altitude=dP,bodyId=jV.bodyId,systemId=jV.planetarySystemId},MapPosition)end;local jW=jU(planet,er)jW="::pos{"..jW.systemId..","..jW.bodyId..","..jW.latitude..","..jW.longitude..","..jW.altitude.."}"if jT then return jW else system.setWaypoint(jW)return true end end;function jD.showWayPoint(planet,er,jT)return jS(planet,er,jT)end;function jD.APTick()local function jX()if collisionTarget and not BrakeLanding then local ee=collisionTarget[1]local ji,jj=collisionTarget[2],collisionTarget[3]local jY=math.min(ji,jj or ji)local jZ=jY/bE;if(AltitudeHold or VectorToTarget or LockPitch)and not AutoTakeoff and(a5*1.5>jY or jZ<1)then BrakeIsOn=true;cu(0)if AltitudeHold then cG()end;if LockPitch then ToggleLockPitch()end;Z="Autopilot Cancelled due to possible collision"if VectorToTarget then cI()end;StrongBrakes=true;BrakeLanding=true;bd=true end;if jZ<11 then collisionAlertStatus=ee.name.." COLLISION "..d3(jZ).." / "..cB(jY,2)else collisionAlertStatus=ee.name.." collision "..d3(jZ)end;if jZ<6 then cb("alarm","AL",2)end else collisionAlertStatus=false end end;ao=j()>0;ap=j()aq=core.getAltitude()am=jM()A=p()bg=A;nearPlanet=unit.getClosestPlanetInfluence()>0;if CollisionSystem then jX()end;if antigrav then bK=antigrav.getState()==1 end;local j_=1;local k0=1;local k1=A-bg;local k2=-math.deg(jI(bA,bD,bB))local k3=math.deg(jI(bC,bD,bB))local gd=bF*-1;bf=ao and k2<-YawStallAngle or k2>YawStallAngle or k3<-PitchStallAngle or k3>PitchStallAngle;local k4=system.getMouseDeltaX()local k5=system.getMouseDeltaY()if InvertMouse and not Y then k5=-k5 end;S=0;W=0;R=0;sys=b4[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=b7(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bD)if aq==0 then aq=(bH-planet.center):len()-planet.radius end;local ir=planet:getGravity(core.getConstructWorldPos()):len()*at;bh=0;b6=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and Y then if not bb then ad=ad+k4;ae=ae+k5 end else ad=0;ae=0 end else ad=ad+k4;ae=ae+k5;ag=math.sqrt(ad*ad+ae*ae)if not Y and l()==0 then if userControlScheme=="virtual joystick"then if ad>0 and ad>DeadZone then S=S-(ad-DeadZone)*MouseXSensitivity elseif ad<0 and ad<DeadZone*-1 then S=S-(ad+DeadZone)*MouseXSensitivity else S=0 end;if ae>0 and ae>DeadZone then R=R-(ae-DeadZone)*MouseYSensitivity elseif ae<0 and ae<DeadZone*-1 then R=R-(ae+DeadZone)*MouseYSensitivity else R=0 end else ad=0;ae=0;if userControlScheme=="mouse"then R=(-utils.smoothstep(k5,-100,100)+0.5)*2*j_;S=(-utils.smoothstep(k4,-100,100)+0.5)*2*k0 end end end end;local k6=bE>8334;if bE>SpaceSpeedLimit/3.6 and not ao and not Autopilot and not k6 then Z="Space Speed Engine Shutoff reached"cu(0)end;if not k6 and LastIsWarping then if not BrakeIsOn then cP()end;if Autopilot then cI()end end;LastIsWarping=k6;if ao and ap>0.09 then if bE>bk/3.6 and not AtmoSpeedAssist and not aw then BrakeIsOn=true;aw=true elseif not AtmoSpeedAssist and aw then if bE<bk/3.6 then BrakeIsOn=false;aw=false end end end;if BrakeIsOn then V=1 else V=0 end;if ProgradeIsOn then if aj then BrakeIsOn=false;local k7=false;if CustomTarget~=nil then k7=cQ(CustomTarget.position-bH,0.1)else k7=cQ(vec3(bD),0.01)end;bd=true;if k7 then cx(d(bk))if(c(bO)<2 or c(bN)>85)and bE>=bk/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;O=true;aj=false;al=true;Autopilot=false;d1()end elseif ao and AtmoSpeedAssist then cu(1)end elseif bE>N then cQ(vec3(bD),0.01)end end;if RetrogradeIsOn then if ao then RetrogradeIsOn=false elseif bE>N then cQ(-vec3(bD))end end;if not ProgradeIsOn and aj and not IntoOrbit then if ap==0 then O=true;d1()aj=false;al=true else aj=false;cI()end end;if al and CustomTarget~=nil and(aq<HoldAltitude+250 and aq>HoldAltitude-250)and bE*3.6>bk-250 and c(bG)<25 and ap>=0.1 and(CustomTarget.position-bH):len()>2000+aq then cI()al=false end;if VertTakeOff then bd=true;local k8=HoldAltitude;if bG<-30 then Z="Unable to achieve lift. Safety Landing."ac=0;bd=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bK or HoldAltitude<planet.spaceEngineMinAltitude then if bK then k8=antigrav.getBaseAltitude()end;if aq<k8-100 then bl=0;ac=15;BrakeIsOn=false elseif bG>0 then BrakeIsOn=true;ac=0 elseif bG<-30 then BrakeIsOn=true;ac=15 elseif aq>=k8 then if bK then if Autopilot or VectorToTarget then cE()else BrakeIsOn=true;VertTakeOff=false end;Z="Takeoff complete. Singularity engaged"cb("aggLk","AG")else BrakeIsOn=false;Z="VTO complete. Engaging Horizontal Flight"cb("vtoc","VT")cE()end;ac=0 end else if ap>0.08 then bl=0;BrakeIsOn=false;ac=20 elseif ap<0.08 and ap>0 then BrakeIsOn=false;if bx then bl=0;ac=20 else ac=0;bl=36;cx(3500)end else bd=autoRollPreference;IntoOrbit=true;bv=false;CancelIntoOrbit=false;bp=false;bn=nil;bo=nil;if bu==nil then bu=planet end;bt=k8;bs=true;VertTakeOff=false end end;if bl~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local k9=q(bl-bN,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(k9)local ka=q(vTpitchPID:get(),-1,1)R=ka end end;if IntoOrbit then local cZ;local kb=false;local kc=cB(bt)if bu==nil then bu=planet;if VectorToTarget then bu=a9 end end;if not bs then bt=d(bu.radius+bu.surfaceMaxAltitude+LowOrbitHeight)if bu.hasAtmosphere then bt=d(bu.radius+bu.noAtmosphericDensityAltitude+LowOrbitHeight)end;bs=true end;if br.VectorToTarget then cZ=CustomTarget.position-bH end;local kd,ke=b7(bu):escapeAndOrbitalSpeed((bH-bu.center):len()-bu.radius)local kf=bO;if not bp then local kg=false;local kh=false;cu(0)bo=0;bm="Aligning to orbital path - OrbitHeight: "..kc;if br.VectorToTarget then cQ(cZ:normalize():project_on_plane(bF))kb=bB:dot(cZ:project_on_plane(bA):normalize())>0.95 else cQ(bD)kb=k2<0.5;if bE<150 then kb=true end end;R=0;bn=0;if bN<=bn+1 and bN>=bn-1 then kg=true else kg=false end;if kf<=bo+1 and kf>=bo-1 then kh=true else kh=false end;if kg and kh and kb then bn=nil;bo=nil;bp=true end else if br.VectorToTarget then cQ(cZ:normalize():project_on_plane(bF))elseif bE>150 then cQ(bD)end;R=0;if br.VectorToTarget then local a5,_=b5.computeDistanceAndTime(bE,bk/3.6,at,0,0,LastMaxBrake)if bv and cZ:len()>15000+a5+aq then bm="Orbiting to Target"if aq-100<=bu.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bu.noAtmosphericDensityAltitude then bv=false end elseif bv or cZ:len()<15000+a5+aq then Z="Orbit complete, proceeding with reentry"cb("orCom","OB")AutopilotTargetCoords=CustomTarget.position;O=true;al=true;br.VectorToTarget,br.AutopilotAlign=false,false;cF()d1()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and aq>bt*0.9 and aq<bt*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bt*0.99 and orbit.apoapsis.altitude>=bt*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bv then if bv then BrakeIsOn=false;cu(0)bn=0;if not br.VectorToTarget then Z="Orbit complete"cb("orCom","OB")cF()end else bz=bz+1;if bz>=2 then bv=true end end else bm="Adjusting Orbit - OrbitHeight: "..kc;bq=true;cx(ke*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local ki=bG;local kj=aq-bt;local kk=c(kj)if bG<10 and c(bN)<10 and kk<100 then ki=bG*2 end;if ki<10 and c(bN)<10 and kk<100 then ki=ki*2 end;if ki<5 and c(bN)<5 and kk<100 then ki=ki*4 end;VSpdPID:inject(ki)bn=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kj)bn=q(bn-q(OrbitAltPID:get(),-15,15),-90,90)end end else local kl=2.75;local km=c(o(kd*kl))local kn=km%50;if kn>0 then km=km-kn+50 end;BrakeIsOn=false;if aq<bt*0.8 then bm="Escaping planet gravity - OrbitHeight: "..kc;bn=utils.map(bG,200,0,-15,80)elseif aq>=bt*0.8 and aq<bt*1.15 then bm="Approaching orbital corridor - OrbitHeight: "..kc;km=km*0.75;bn=utils.map(bG,100,-100,-15,65)elseif aq>=bt*1.15 and aq<bt*1.5 then bm="Approaching orbital corridor - OrbitHeight: "..kc;km=km*0.75;if bG<0 or bq then bn=utils.map(aq,bt*1.5,bt*1.01,-30,0)else bn=utils.map(aq,bt*0.99,bt*1.5,0,30)end elseif aq>bt*1.5 then bm="Reentering orbital corridor - OrbitHeight: "..kc;bn=-65;local ko=utils.map(bG,-150,-400,1,0.55)km=km*ko end;cx(d(km))end end;if bn~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kp=bn-bN;OrbitPitchPID:inject(kp)local kq=q(OrbitPitchPID:get(),-0.5,0.5)R=kq end end;if Autopilot and ap==0 and not aj then local function kr(jp,orbit)system.print(jp)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cu(0)M=false;Z=jp;cb("apCom","AP")if orbit or aj then if orbit and AutopilotTargetOrbit~=nil and not aj then if not aq or aq==0 then return end;bt=aq;bs=true end;cF()end end;local ks,kt=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local ku=(CustomTarget.position-a9.center):normalize()local kv=ku:project_on_plane((a9.center-bH):normalize()):normalize()local kw=a9.center+kv*(a9.radius+AutopilotTargetOrbit)local kx=CustomTarget.position+(CustomTarget.position-a9.center):normalize()*(AutopilotTargetOrbit-a9:getAltitude(CustomTarget.position))if(bH-kw):len()<(bH-kx):len()then ks=kw else ks=kx;AutopilotEndSpeed=0 end;AutopilotTargetCoords=ks;ba.showWayPoint(a9,AutopilotTargetCoords)kt=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kt=true;TargetSet=true;AutopilotRealigned=true;ks=CustomTarget.position+(bH-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local ku=(bH+bD*100000-a9.center):normalize()local kv=ku:project_on_plane((a9.center-bH):normalize()):normalize()if kv:len()<1 then ku=(bH+bB*100000-a9.center):normalize()kv=ku:project_on_plane((a9.center-bH):normalize()):normalize()end;ks=a9.center+kv*(a9.radius+AutopilotTargetOrbit)AutopilotTargetCoords=ks;TargetSet=true;kt=true;AutopilotRealigned=true;ba.showWayPoint(a9,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(ks)-bH):len()local hx,ep,eq=b4:getPlanetarySystem(0):castIntersections(bH,bD:normalize(),function(ee)if ee.noAtmosphericDensityAltitude>0 then return ee.radius+ee.noAtmosphericDensityAltitude else return ee.radius+ee.surfaceMaxAltitude*1.5 end end)local hy=ep;if eq~=nil and ep~=nil then hy=math.min(eq,ep)end;if hy~=nil and hy<AutopilotDistance and hx.name==a9.name then AutopilotDistance=hy end;local k7=true;local ky=(a9.center-(bH+vec3(bD):normalize()*AutopilotDistance)):len()-a9.radius;local hw=cB(ky)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hw..'"}')local a5,a6;if not TurnBurn then a5,a6=jF(bE)else a5,a6=jH(bE)end;if bE>300 and AutopilotAccelerating then local cZ=vec3(ks)-bH;local kz=q(math.deg(jI(bA,bD:normalize(),cZ:normalize()))*bE/500,-90,90)local kA=q(math.deg(jI(bC,bD:normalize(),cZ:normalize()))*bE/500,-90,90)if c(kz)<20 and c(kA)<20 then kz=kz*2;kA=kA*2 end;if c(kz)<2 and c(kA)<2 then kz=kz*2;kA=kA*2 end;local k2=-math.deg(jI(bA,bB,bD:normalize()))local k3=-math.deg(jI(bC,bB,bD:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kA-k3)local kB=q(apPitchPID:get(),-1,1)R=R+kB;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kz-k2)local kC=q(apYawPID:get(),-1,1)S=S+kC;kt=true;if c(kz)>2 or c(kA)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"cb("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end end end;if ky<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=b7(a9):escapeAndOrbitalSpeed(ky)end end;if not AutopilotCruising and not AutopilotBraking and not kt then k7=cQ((ks-bH):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then k7=cQ(-vec3(bD):normalize())end;if AutopilotAccelerating then if not M then BrakeIsOn=false;cu(AutopilotInterplanetaryThrottle)H=x(AutopilotInterplanetaryThrottle,2)M=true end;local kD=unit.getThrottle()if AtmoSpeedAssist then kD=H end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or kD==0 and M then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then cb("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cu(0)end;if AutopilotDistance<=a5 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then cb("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cu(0)M=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;V=1 end;if TurnBurn then cu(1,true)end;local _,ke=b7(a9):escapeAndOrbitalSpeed((bH-planet.center):len()-planet.radius)local cZ;if CustomTarget~=nil then cZ=CustomTarget.position-bH end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bE<50 then kr("Autopilot complete, arrived at space location")BrakeIsOn=true;V=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bE<=ke and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kr("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;aj=true;ba.showWayPoint(a9,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then cb("apCir","AP")AutopilotStatus="Circularizing"end;if bE<=ke then if CustomTarget~=nil then if bD:normalize():dot(cZ:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then cb("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;ba.showWayPoint(a9,CustomTarget.position)WaypointSet=true end else kr("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;aj=true;ba.showWayPoint(a9,CustomTarget.position)WaypointSet=false end else kr("Autopilot completed, setting orbit",true)V=0 end end elseif AutopilotStatus=="Circularizing"then kr("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a5 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then cb("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kD=unit.getThrottle()if AtmoSpeedAssist then kD=H end;if kD>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end;AutopilotCruising=false end else if k7 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not aj then AutopilotTargetCoords=vec3(a9.center)+(AutopilotTargetOrbit+a9.radius)*bC;AutopilotShipUp=bA;AutopilotShipRight=bC end;AutopilotRealigned=true elseif k7 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end;if not M then cu(AutopilotInterplanetaryThrottle,true)H=x(AutopilotInterplanetaryThrottle,2)M=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ap>0)then Z="Autopilot complete, proceeding with reentry"cb("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"V=0;cu(0)M=false;ProgradeIsOn=true;aj=true;ba.showWayPoint(a9,CustomTarget.position)end;if X then bd=true;local kA=0;local c7=bH+vec3(unit.getMasterPlayerRelativePosition())local kE=c7-bH;local kF=vec3(kE):project_on(bB):len()local kG=vec3(kE):project_on(bC):len()local ag=math.sqrt(kF*kF+kG*kG)cQ(kE:normalize())local kH=40;local kI=ag<kH;local kJ=100;local kK=q((ag-kH)/2,10,kJ)R=0;local k7=c(S)<0.1;if k7 and bE<kK and not kI then BrakeIsOn=false;kA=-20 else BrakeIsOn=true;kA=0 end;local kL=0;if c(kA-bN)>kL then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kA-bN)local kB=pitchPID:get()R=kB end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local kM=LastMaxBrakeInAtmo;if kM then kM=kM*q(bE/100,0.1,1)*ap else kM=LastMaxBrake end;if ap<0.01 then kM=LastMaxBrake end;local kN=vec3(core.getWorldAirFrictionAcceleration())local kO=math.sqrt(kN:len()-kN:project_on(gd):len())*at;if bE>100 then a5,a6=b5.computeDistanceAndTime(bE,100,at,0,0,kM+kO)local kP,kQ=b5.computeDistanceAndTime(100,0,at,0,0,kM/2)a5=a5+kP else a5,a6=b5.computeDistanceAndTime(bE,0,at,0,0,kM/2)end;local kR=HoldAltitude-aq;local kS=500+bE;local kT=1;if AutoTakeoff then kT=q(bE/100,0.1,1)end;local kA=(utils.smoothstep(kR,-kS,kS)-0.5)*2*MaxPitch*kT;if not Reentry and not aj and not VectorToTarget and bB:dot(bD:normalize())<0.99 then kA=(utils.smoothstep(kR,-kS*q(20-19*ap*10,1,20),kS*q(20-19*ap*10,1,20))-0.5)*2*MaxPitch*q(2-ap*10,1,2)*kT end;if not AltitudeHold then kA=0 end;if LockPitch~=nil then if nearPlanet and not IntoOrbit then kA=LockPitch else LockPitch=nil end end;bd=true;local kU=R;if Reentry then local kV=d(bk)local kW,kX=b5.computeDistanceAndTime(bE,kV/3.6,at,0,0,LastMaxBrake-planet.gravity*9.8*at)local kY=aq-(planet.noAtmosphericDensityAltitude+5000)if not bM and aq>planet.noAtmosphericDensityAltitude+5000 and bE<=kV/3.6 and bE>kV/3.6-10 and c(bD:normalize():dot(bB))>0.9 then cu(0)elseif bM and bE>kV/3.6 and(kW>-1 and kY<=kW or aq<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cx(kV,true)if not O then kA=-80;if ap>0.02 then Z="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kA=0;bd=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and aq>planet.noAtmosphericDensityAltitude+5000 then bd=true elseif aq<=planet.noAtmosphericDensityAltitude+5000 then cx(kV)if not bM and r:getTargetSpeed(axisCommandId.longitudinal)==bk then O=false;Reentry=false;bd=true end end end;if bE>N and not ak and not VectorToTarget and not BrakeLanding and ForceAlignment then cQ(vec3(bD))end;if bW or(VectorToTarget or ak)and AutopilotTargetIndex>0 and ap>0.01 then local cZ;if bW then if type(bW)=="table"then cZ=bW elseif bW<3 and bW>0 then cZ=-bF:cross(bD)*5000 elseif bW>=3 then cZ=bF:cross(bD)*5000 elseif bW==0 then cZ=bD*25000 end elseif CustomTarget~=nil then cZ=CustomTarget.position-bH else cZ=a9.center-bH end;local kz=math.deg(jI(bF:normalize(),bD,cZ))*2;local kZ=math.rad(c(bO))if bE>minRollVelocity and ap>0.01 then local k_=q(90-kA*2,-90,90)bh=q(kz*2,-k_,k_)local l0=kz;kz=q(q(kz,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(kZ)+4*(bN-kA)*math.sin(math.rad(bO)),-YawStallAngle*0.80,YawStallAngle*0.80)kA=q(q(kA*math.cos(kZ),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(l0)*math.sin(kZ),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bh=0;kz=q(kz,-YawStallAngle*0.80,YawStallAngle*0.80)end;local l1=k2-kz;if(type(bW)=="table"or bW==0)and c(l1)<=0.0001 then if bW==0 then cG()end;bW=nil;cb("180Off","BR")return end;if not bf and bE>minRollVelocity and ap>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(l1)local kC=q(yawPID:get(),-1,1)S=S+kC elseif ao and am>-1 or bE<minRollVelocity then cQ(cZ)elseif bf and ap>0.01 then if(k2<-YawStallAngle or k2>YawStallAngle)and ap>0.01 then cQ(bD)end;if(k3<-PitchStallAngle or k3>PitchStallAngle)and ap>0.01 then kA=q(bN-k3,bN-PitchStallAngle*0.80,bN+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ak then local k8=planet:getAltitude(CustomTarget.position)local kY=math.sqrt(cZ:len()^2-(aq-k8)^2)local l2=bD:len()-c(bG)StrongBrakes=true;if not ak and not Reentry and kY<=a5+bE*k1/2 and(bD:project_on_plane(bF):normalize():dot(cZ:project_on_plane(bF):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cu(0)if AltitudeHold then cG()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l2<0.1 or kY<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<kY)then if not bK then cb("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"collisionAlertStatus=false end;LastDistanceToTarget=kY end elseif VectorToTarget and ap==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ak or Reentry)then if CustomTarget~=nil and a9.name==planet.name then local cZ=CustomTarget.position-bH;local k8=planet:getAltitude(CustomTarget.position)local kY=math.sqrt(cZ:len()^2-(aq-k8)^2)local kM=LastMaxBrakeInAtmo;if kM then a5,a6=b5.computeDistanceAndTime(bE,0,at,0,0,kM/2)StrongBrakes=true;if kY<=a5+bE*k1/2 and bD:project_on_plane(bF):normalize():dot(cZ:project_on_plane(bF):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;O=true;aj=false;al=true;Autopilot=false;d1()end end;LastDistanceToTarget=kY end end end;if ap==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ak or IntoOrbit or Reentry)then if not bv and not IntoOrbit then bt=HoldAltitude;bs=true;if VectorToTarget then br.VectorToTarget=true end;cF()VectorToTarget=false;bp=true end end;if bf and ap>0.01 and am==-1 and bE>minRollVelocity and VectorStatus~="Finalizing Approach"then cQ(bD)kA=q(bN-k3,bN-PitchStallAngle*0.80,bN+PitchStallAngle*0.80)end;R=kU;local jR=-1;if BrakeLanding then kA=0;local l3=false;local l4=30;if b6~=nil and b6>0 then local l5=q(ap,0.4,2)local kM=LastMaxBrakeInAtmo*q(bE/100,0.1,1)*l5;local l6=b6*l5+kM-ir;local l7=kM/2-ir;local l8=bE-math.sqrt(c(l7/2)*20/(0.5*at))*utils.sign(l7)if l8<0 then l8=0 end;local l9;if bE>100 then local la,_=b5.computeDistanceAndTime(bE,100,at,0,0,kM)local lb,_=b5.computeDistanceAndTime(100,0,at,0,0,math.sqrt(kM))l9=la+lb else l9=b5.computeDistanceAndTime(bE,0,at,0,0,math.sqrt(kM))end;if l9<20 then BrakeIsOn=false else local lc=0;if l8>100 then local ld,_=b5.computeDistanceAndTime(l8,100,at,0,0,l6)local le,_=b5.computeDistanceAndTime(100,0,at,0,0,b6*l5+math.sqrt(kM)-ir)lc=ld+le else lc,_=b5.computeDistanceAndTime(l8,0,at,0,0,b6*l5+math.sqrt(kM)-ir)end;lc=(lc+15+bE*k1)*1.1;local lf=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lf then local k8=planet:getAltitude(CustomTarget.position)local lg=aq-k8-100;local cZ=CustomTarget.position-bH;local lh=math.sqrt(cZ:len()^2-(aq-k8)^2)if lh>100 then lf=false elseif lg<=lc or lc==-1 then BrakeIsOn=true;l3=true else BrakeIsOn=false;l3=true end end;if not lf and CalculateBrakeLandingSpeed then if lc>=l4 then BrakeIsOn=true else BrakeIsOn=false end;l3=true end end end;if not bM then cu(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)stablized=true;jR=am;if jR>-1 then bd=autoRollPreference;if bE<1 or bD:normalize():dot(bF)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if P then a.control.extendLandingGears()cb("grOut","LG",1)end;r:setTargetGroundAltitude(LandingGearGroundHeight)ac=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bD:normalize():dot(-gd)<0.999 then BrakeIsOn=true elseif bG<-brakeLandingRate and not l3 then BrakeIsOn=true elseif not l3 then BrakeIsOn=false end end;if AutoTakeoff or ak then local hx,eq,ep;if AutopilotTargetCoords~=nil then hx,eq,ep=b4:getPlanetarySystem(0):castIntersections(bH,(AutopilotTargetCoords-bH):normalize(),function(ee)return ee.radius+ee.noAtmosphericDensityAltitude end)end;if bK then if aq>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cu(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kA)<15 and aq/HoldAltitude>0.75 then AutoTakeoff=false;if not ak then if bM and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ak and bE<N then Autopilot=true;ak=false;AltitudeHold=false;AutoTakeoff=false;cu(0)elseif ak then cu(0)BrakeIsOn=true end elseif ak and ap==0 and a9~=nil and(hx==nil or hx.name==a9.name)then Autopilot=true;ak=false;AltitudeHold=false;AutoTakeoff=false;if not bM then cu(0)end;AutopilotAccelerating=true end end;local li=am>-1;local lj=bN;if(VectorToTarget or ak or bW)and not li and bE>minRollVelocity and ap>0.01 then local kZ=math.rad(c(bO))lj=bN*c(math.cos(kZ))+k3*math.sin(kZ)end;local lk=q(kA-lj,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ap<0.01 and VectorToTarget then lk=q(kA-lj,-85,MaxPitch)elseif ap<0.01 then lk=q(kA-lj,-MaxPitch,MaxPitch)end;if c(bO)<5 or VectorToTarget or bW or BrakeLanding or li or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lk)local kB=pitchPID:get()R=R+kB end end;if antigrav~=nil and(antigrav and not ExternalAGG and aq<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;am=jM()return jD end;function script.onStart()local function ll()local function lm(ln)local lo=dbHud_1.hasKey;for dc,dd in pairs(ln)do if lo(dd)then local cW=f(dbHud_1.getStringValue(dd))if cW~=nil then _G[dd]=cW;aJ=true end end end end;if dbHud_1 then if not useTheseSettings then lm(ch())coroutine.yield()lm(b)else lm(b)Z="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"af=5;aJ=false end;coroutine.yield()if aJ then Z="Loaded Saved Variables"aH=ResolutionX;aI=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bd=autoRollPreference;bk=AtmoSpeedLimit;ax=[[rgb(]]..d(E+0.5)..","..d(G+0.5)..","..d(F+0.5)..[[)]]ay=[[rgb(]]..d(E*0.9+0.5)..","..d(G*0.9+0.5)..","..d(F*0.9+0.5)..[[)]]elseif not useTheseSettings then Z="No Saved Variables Found - Exit HUD to save settings"end else Z="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<A then LastMaxBrakeInAtmo=0 end;LastStartTime=A;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then Z="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"af=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=aq end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=at end;VectorStatus="Proceeding to Waypoint"end;local function lp()local function lq(lr,ls)if lr>ls then ls=lr end;local lt,lu=0,0;if ContainerOptimization>0 then lt=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lu=FuelTankOptimization*0.05 end;ls=ls*(1-(lt+lu))return ls end;local lv=core.getElementNameById;local lw=fuelX~=0 and fuelY~=0;for dc in pairs(ar)do local type=core.getElementTypeById(ar[dc])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(ar[dc])),'^.*vertical.*$')then bJ=true end end;if n(type,'^.*Space Engine$')then by=true;if n(tostring(core.getElementTagsById(ar[dc])),'^.*vertical.*$')then local lx=core.getElementRotationById(ar[dc])if lx[4]<0 then if o(-lx[4],0.1)==0.5 then bw=true end else if o(lx[4],0.1)==0.5 then bx=true end end end end;if type=="Landing Gear"then P=true end;local jg=13.8564064606;ag=tonumber(ag)if radar_1.hasMatchingTransponder(id)==1 then table.insert(friendlies,id)end;if type=="Dynamic Core Unit"then local ly=h(ar[dc])if ly>10000 then C=128;D=110 elseif ly>1000 then C=64;D=55 elseif ly>150 then C=32;D=27 end end;aP=aP+h(ar[dc])if lw and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local ly=h(ar[dc])local lz=k(ar[dc])local lr=0;local g5=p()if type=="Atmospheric Fuel Tank"then local ls=400;local lA=35.03;if ly>10000 then ls=51200;lA=5480 elseif ly>1300 then ls=6400;lA=988.67 elseif ly>150 then ls=1600;lA=182.67 end;lr=lz-lA;if fuelTankHandlingAtmo>0 then ls=ls+ls*fuelTankHandlingAtmo*0.2 end;ls=lq(lr,ls)aM[#aM+1]={ar[dc],lv(ar[dc]),ls,lA,lr,g5}end;if type=="Rocket Fuel Tank"then local ls=320;local lA=173.42;if ly>65000 then ls=40000;lA=25740 elseif ly>6000 then ls=5120;lA=4720 elseif ly>700 then ls=640;lA=886.72 end;lr=lz-lA;if fuelTankHandlingRocket>0 then ls=ls+ls*fuelTankHandlingRocket*0.1 end;ls=lq(lr,ls)aO[#aO+1]={ar[dc],lv(ar[dc]),ls,lA,lr,g5}end;if type=="Space Fuel Tank"then local ls=2400;local lA=182.67;if ly>10000 then ls=76800;lA=5480 elseif ly>1300 then ls=9600;lA=988.67 end;lr=lz-lA;if fuelTankHandlingSpace>0 then ls=ls+ls*fuelTankHandlingSpace*0.2 end;ls=lq(lr,ls)aN[#aN+1]={ar[dc],lv(ar[dc]),ls,lA,lr,g5}end end end;if not bJ then VertTakeOff,VertTakeOffEngine=false,false end end;local function lB()if gyro~=nil then av=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(ao or not ao and aq<10000)then for _,dd in pairs(door)do dd.toggle()end end;if switch then for _,dd in pairs(switch)do dd.toggle()end end;if forcefield and(ao or not ao==0 and aq<10000)then for _,dd in pairs(forcefield)do dd.toggle()end end;if antigrav then bK=antigrav.getState()==1;if bK and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if P then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if am~=-1 or not ao and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;GearExtended=true;if P then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(be)if ao and am~=-1 then b6=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ao end;local function lC(lD,lE,lF,lG,cp,cq,lH,lI,lJ,lK)local lL={enableName=lD,disableName=lE,width=lF,height=lG,x=cp,y=cq,toggleVar=lH,toggleFunction=lI,drawCondition=lJ,hovered=false}if lK then table.insert(aG,lL)else table.insert(aF,lL)end;return lL end;local function lM(lN)if not bP then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif lN=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif lN=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif lN=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bQ=ch(lN)showHud=false else bQ={}showHud=true end end;local function lO()bP=not bP;if bP then aE=aG;Z="Hold SHIFT to see Settings"bR=showHud else aE=aF;Z="Hold SHIFT to see Control Buttons"lM()showHud=bR end end;local function lP(dd)_G[dd]=not _G[dd]if _G[dd]then Z=dd.." set to true"else Z=dd.." set to false"end;if dd=="showHud"then bR=_G[dd]elseif dd=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif dd=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function lQ()local lR=50;local lS=340;local cp=500;local cq=aI/2-400;local lT=0;for dc,dd in pairs(ch("boolean"))do if type(_G[dd])=="boolean"then lC(dd,dd,lS,lR,cp,cq,function()return _G[dd]end,function()lP(dd)end,function()return true end,true)cq=cq+lR+20;if lT==9 then cp=cp+lS+20;cq=aI/2-400;lT=0 else lT=lT+1 end end end;lC("Control View","Control View",lS,lR,10,aI/2-500,function()return true end,lO,function()return true end,true)lC("View Handling Settings",'Hide Handling Settings',lS,lR,10,aI/2-(500-lR),function()return showHandlingVariables end,function()lM("handling")end,function()return true end,true)lC("View Hud Settings",'Hide Hud Settings',lS,lR,10,aI/2-(500-lR*2),function()return showHudVariables end,function()lM("hud")end,function()return true end,true)lC("View Physics Settings",'Hide Physics Settings',lS,lR,10,aI/2-(500-lR*3),function()return showPhysicsVariables end,function()lM("physics")end,function()return true end,true)end;local function lU()local function lV()if dbHud_1 then local position=bH;local fZ=planet.name..". "..#SavedLocations;if radar_1 then local id,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if id~=nil and id~=""then fZ=fZ.." "..radar_1.getConstructName(id)end end;local cN={}cN={position=position,name=fZ,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cN;table.insert(a_[0],cN)b9.UpdateAtlasLocationsList()Z="Location saved as "..fZ else Z="Databank must be installed to save locations"end end;local function lW()TurnBurn=not TurnBurn end;local function lX(lY)if lY==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;X=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function lZ()lX(1)end;local function l_()local cM=-1;cM=b9.findAtlasIndex(a_[0])if cM>-1 then table.remove(a_[0],cM)end;cM=-1;cM=b9.findAtlasIndex(SavedLocations)if cM~=-1 then Z=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cM)end;b9.adjustAutopilotTargetIndex()b9.UpdateAtlasLocationsList()end;local function m0()local fZ=AutopilotTargetName;if fZ==nil then local hw=cB((bH-CustomTarget.position):len())fZ=CustomTarget.name.." "..hw end;if fZ==nil then fZ="None"end;return"Engage Autopilot: "..fZ end;local function m1()local fZ=AutopilotTargetName;if fZ==nil then fZ=CustomTarget.name end;if fZ==nil then fZ="None"end;return"Disable Autopilot: "..fZ end;local function m2()if safeMass>0 then Z="Safe Mass set to "..x(at,2).." kg"else Z="Intruder Detection reset\nSafe Mass set to "..x(at,2).." kg"af=5;bI=0 end;safeMass=at end;local lR=50;local lS=260;local m3=lC("Enable Brake Toggle","Disable Brake Toggle",lS,lR,aH/2-lS/2,aI/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then Z="Brakes in Toggle Mode"else Z="Brakes in Default Mode"end end)lC("Align Prograde","Disable Prograde",lS,lR,aH/2-lS/2-50-m3.width,aI/2-lR+380,function()return ProgradeIsOn end,lZ)lC("Align Retrograde","Disable Retrograde",lS,lR,aH/2-lS/2+m3.width+50,aI/2-lR+380,function()return RetrogradeIsOn end,lX,function()return ap==0 end)local m4=lC(m0,m1,600,60,aH/2-600/2,aI/2-60/2-400,function()return Autopilot end,cI)lC("Save Position","Save Position",200,m4.height,m4.x+m4.width+30,m4.y,function()return false end,lV,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)lC("Update Position","Update Position",200,m4.height,m4.x+m4.width+30,m4.y,function()return false end,cK,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lC("Clear Position","Clear Position",200,m4.height,m4.x-200-30,m4.y,function()return true end,l_,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lR=60;lS=300;local cp=10;local cq=aI/2-500;lC("Show Help","Hide Help",lS,lR,cp,cq,function()return showHelp end,function()showHelp=not showHelp end)cq=cq+lR+20;lC("View Settings","View Settings",lS,lR,cp,cq,function()return true end,lO)local cq=aI/2-300;lC("Enable Turn and Burn","Disable Turn and Burn",lS,lR,cp,cq,function()return TurnBurn end,lW)lC("Horizontal Takeoff Mode","Vertical Takeoff Mode",lS,lR,cp+lS+20,cq,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then Z="Vertical Takeoff Mode"else Z="Horizontal Takeoff Mode"end end,function()return bJ end)cq=cq+lR+20;lC("Show Orbit Display","Hide Orbit Display",lS,lR,cp,cq,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then Z="Orbit Display Enabled"else Z="Orbit Display Disabled"end end)lC("Engage Orbiting","Cancel Orbiting",lS,lR,cp+lS+20,cq,function()return IntoOrbit end,cF,function()return ap==0 and nearPlanet end)cq=cq+lR+20;lC("Glide Re-Entry","Cancel Glide Re-Entry",lS,lR,cp,cq,function()return Reentry end,function()aj=true;lZ()end,function()return planet.hasAtmosphere and not ao end)lC("Parachute Re-Entry","Cancel Parachute Re-Entry",lS,lR,cp+lS+20,cq,function()return Reentry end,d1,function()return planet.hasAtmosphere and not ao end)cq=cq+lR+20;lC("Engage Follow Mode","Disable Follow Mode",lS,lR,cp,cq,function()return X end,cH,function()return l()==1 end)lC("Enable Repair Arrows","Disable Repair Arrows",lS,lR,cp+lS+20,cq,function()return aQ end,function()aQ=not aQ;if aQ then Z="Repair Arrows Enabled"else Z="Repair Arrows Diabled"end end,function()return l()==1 end)cq=cq+lR+20;if not ExternalAGG then lC("Enable AGG","Disable AGG",lS,lR,cp,cq,function()return bK end,d2,function()return antigrav~=nil end)end;lC("Reset Intruder Alert","Set Safe Mass",lS,lR,cp+lS+20,cq,function()return safeMass>0 end,m2,function()return IntruderAlertSystem end)cq=cq+lR+20;lC(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,lS*2,lR,cp,cq,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;Z="IPH Mode: "..iphCondition end)cq=cq+lR+20;lC(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,lS*2,lR,cp,cq,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;Z="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})ll()coroutine.yield()lp()coroutine.yield()ba=jC()lB()lQ()lU()aE=aF;coroutine.yield()a_=de()b3=df()b4=b3(de())b5=eD()b7=f7()b8=ft()b9=ju()ba=jC()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)cb("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ap>0 or ap==0 and aq<10000)then for _,dd in pairs(door)do dd.toggle()end end;if switch then for _,dd in pairs(switch)do dd.toggle()end end;if forcefield and(ap>0 or ap==0 and aq<10000)then for _,dd in pairs(forcefield)do dd.toggle()end end;safeMass=at;d8()if button then button.activate()end;if SetWaypointOnExit then ba.showWayPoint(planet,bH)end;cb("stop","SU")end;function script.onTick(m5)if m5=="contact"then if not contactTimer then contactTimer=0 end;if A>contactTimer+10 then Z="Radar Contact"cb("rdrCon","RC")contactTimer=A end;unit.stopTimer("contact")elseif m5=="tenthSecond"then local function m6()local m7=system.createData;local m8=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=m8(panelInterplanetary,"value")interplanetaryHeaderText=m7('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=m8(panelInterplanetary,"value")widgetDistanceText=m7('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=m8(panelInterplanetary,"value")widgetTravelTimeText=m7('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=m8(panelInterplanetary,"value")widgetMaxMassText=m7('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=m8(panelInterplanetary,"value")widgetTargetOrbitText=m7('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=m8(panelInterplanetary,"value")widgetCurBrakeDistanceText=m7('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=m8(panelInterplanetary,"value")widgetCurBrakeTimeText=m7('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=m8(panelInterplanetary,"value")widgetMaxBrakeDistanceText=m7('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=m8(panelInterplanetary,"value")widgetMaxBrakeTimeText=m7('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=m8(panelInterplanetary,"value")widgetTrajectoryAltitudeText=m7('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ao then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function m9()s(panelInterplanetary)panelInterplanetary=nil end;local function ma()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(a9.center-bH):len()else AutopilotDistance=(CustomTarget.position-bH):len()end end;local f5=bE;local kD=unit.getThrottle()/100;if AtmoSpeedAssist then kD=H end;local mb,mc=b5.computeDistanceAndTime(bE,MaxGameVelocity,at,a:maxForceForward()*kD,warmup,0)local a5,a6;if not TurnBurn then a5,a6=ba.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a5,a6=ba.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,md;if not TurnBurn and f5>0 then _,md=ba.GetAutopilotBrakeDistanceAndTime(f5)else _,md=ba.GetAutopilotTBBrakeDistanceAndTime(f5)end;local me=0;local mf=0;if AutopilotCruising or not Autopilot and f5>5 then mf=b5.computeTravelTime(f5,0,AutopilotDistance)elseif a5+mb<AutopilotDistance then me=AutopilotDistance-(a5+mb)mf=b5.computeTravelTime(8333.0556,0,me)else local mg=(AutopilotDistance-a5)/mb;mb=AutopilotDistance-a5;mc=mc*mg end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mf elseif AutopilotBraking then return md elseif AutopilotCruising then return mf+md else return mc+a6+mf end end;local function mh(ir,mi)if ir==nil then ir=core.g()end;ir=x(ir,5)if mi~=nil and mi or(aL==nil or aL~=ir)then local f8=core.getVelocity()local f5=vec3(f8):len()local mj=f(unit.getData()).maxBrake;if mj~=nil and mj>0 and ao then mj=mj/q(f5/100,0.1,1)mj=mj/ap;if ap>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mj)/2 else LastMaxBrakeInAtmo=mj end end end;if mj~=nil and mj>0 then LastMaxBrake=mj end;aL=ir end end;mh(nil,true)if ap>0 and not WasInAtmo then if not bM and AtmoSpeedAssist and(AltitudeHold or Reentry)then cu(1)L=false end end;if bL~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bL then cx(bL,TRUE)else bL=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then m6()end;if AutopilotTargetName~=nil then local mk=CustomTarget~=nil;local ml=LastMaxBrakeInAtmo/a9:getGravity(a9.center+vec3(0,0,1)*a9.radius):len()t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=ma()if mk and not Autopilot then ag=(bH-CustomTarget.position):len()else ag=(AutopilotTargetCoords-bH):len()end;if not TurnBurn then a5,a6=ba.GetAutopilotBrakeDistanceAndTime(bE)a7,a8=ba.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a5,a6=ba.GetAutopilotTBBrakeDistanceAndTime(bE)a7,a8=ba.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hw=cB(ag)t(widgetDistanceText,'{"label": "distance", "value": "'..hw..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d3(travelTime)..'", "unit":""}')hw=cB(a5)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hw..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d3(a6)..'", "unit":""}')hw=cB(a7)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hw..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d3(a8)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",ml/1000)..'", "unit":" Tons"}')hw=cB(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..hw..'"}')if ap>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if ap==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else m9()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif m5=="oneSecond"then local function mm(fJ)local mn=0;aC=""local mo=aP;local mp=0;local mq=0;local mr=0;local g7=0;local g8=""local ms=core.getElementHitPointsById;for dc in pairs(ar)do local ly=0;local mt=0;mt=h(ar[dc])ly=ms(ar[dc])mp=mp+ly;if ly<mt then if ly==0 then mr=mr+1 else mq=mq+1 end;if aQ and#az==0 then position=vec3(core.getElementPositionById(ar[dc]))local cp=position.x-C;local cq=position.y-C;local iS=position.z-C;table.insert(az,core.spawnArrowSticker(cp,cq,iS+1,"down"))table.insert(az,core.spawnArrowSticker(cp,cq,iS+1,"down"))core.rotateSticker(az[2],0,0,90)table.insert(az,core.spawnArrowSticker(cp+1,cq,iS,"north"))table.insert(az,core.spawnArrowSticker(cp+1,cq,iS,"north"))core.rotateSticker(az[4],90,90,0)table.insert(az,core.spawnArrowSticker(cp-1,cq,iS,"south"))table.insert(az,core.spawnArrowSticker(cp-1,cq,iS,"south"))core.rotateSticker(az[6],90,-90,0)table.insert(az,core.spawnArrowSticker(cp,cq-1,iS,"east"))table.insert(az,core.spawnArrowSticker(cp,cq-1,iS,"east"))core.rotateSticker(az[8],90,0,90)table.insert(az,core.spawnArrowSticker(cp,cq+1,iS,"west"))table.insert(az,core.spawnArrowSticker(cp,cq+1,iS,"west"))core.rotateSticker(az[10],-90,0,90)table.insert(az,ar[dc])end elseif aQ and#az>0 and az[11]==ar[dc]then for g0 in pairs(az)do core.deleteSticker(az[g0])end;az={}end end;mn=d(mp/mo*100)if mn<100 then fJ[#fJ+1]=co(0,0,"","pbright txt")g7=d(mn*2.55)g8=e("rgb(%d,%d,%d)",255-g7,g7,0)if mn<100 then fJ[#fJ+1]=co("50%",1035,"Elemental Integrity: "..mn.."%","txtbig txtmid","fill:"..g8)if mr>0 then fJ[#fJ+1]=co("50%",1055,"Disabled Modules: "..mr.." Damaged Modules: "..mq,"txtbig txtmid","fill:"..g8)elseif mq>0 then fJ[#fJ+1]=co("50%",1055,"Damaged Modules: "..mq,"txtbig txtmid","fill:"..g8)end end end end;local function mu()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function mv()local g5=p()local hk=bE;local mw=g5-as;if hk>1.38889 then hk=hk/1000;local mx=hk*(g5-as)TotalDistanceTravelled=TotalDistanceTravelled+mx;aa=aa+mx end;ab=ab+mw;TotalFlightTime=TotalFlightTime+mw;as=g5 end;local function my()if safeMass>0 then if at>safeMass+50 then bI=d(at-safeMass)safeMass=-1 elseif at<safeMass then safeMass=at end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then my()end;mv()b8.UpdatePipe()mu()local fJ={}b8.ExtraData(fJ)if ShowOdometer then fJ=b8.DrawOdometer(fJ,aa,TotalDistanceTravelled,ab)end;if ShouldCheckDamage then mm(fJ)end;ah=table.concat(fJ,"")collectgarbage("collect")elseif m5=="fiveSecond"then if not UseSatNav then return end;an=dbHud_1.getStringValue("SPBAutopilotTargetName")if an~=nil and an~=""and an~="SatNavNotChanged"then local cW=f(dbHud_1.getStringValue("SavedLocations"))if cW~=nil then _G["SavedLocations"]=cW;local cM=-1;local cN;for dc,dd in pairs(SavedLocations)do if dd.name and dd.name=="SatNav Location"then cM=dc;break end end;if cM~=-1 then cN=SavedLocations[cM]cM=-1;for dc,dd in pairs(a_[0])do if dd.name and dd.name=="SatNav Location"then cM=dc;break end end;if cM>-1 then a_[0][cM]=cN end;b9.UpdateAtlasLocationsList()Z=cN.name.." position updated"end end;for i=1,#bS do if bS[i].name==an then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bS[i].name)b9.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif m5=="msgTick"then local fJ={}b8.DisplayMessage(fJ,"empty")Z="empty"unit.stopTimer("msgTick")af=3 elseif m5=="animateTick"then bc=true;bb=false;ad=0;ae=0;unit.stopTimer("animateTick")elseif m5=="hudTick"then local function mz(fJ)local mA=d(q(ag/(aH/4)*255,0,255))fJ[#fJ+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ad,ae,d(E+0.5)+mA,d(G+0.5)-mA,d(F+0.5)-mA)end;local function mB()for _,dd in pairs(aE)do if dd.hovered then if not dd.drawCondition or dd.drawCondition()then dd.toggleFunction()end;dd.hovered=false end end end;local function mC()local function mD(mE,mF,cp,cq,lF,lG)if mE>cp and mE<cp+lF and mF>cq and mF<cq+lG then return true else return false end end;local cp=ad+aH/2;local cq=ae+aI/2;for _,dd in pairs(aE)do dd.hovered=mD(cp,cq,dd.x,dd.y,dd.width,dd.height)end end;local function mG(fJ)local function mH(fJ,mI,hover,cp,cq,eZ,mJ,mK,mL,mM,mN)if type(mM)=="function"then mM=mM()end;if type(mN)=="function"then mN=mN()end;fJ[#fJ+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",cp,cq,eZ,mJ)if mI then fJ[#fJ+1]=e("%s'",mK)else fJ[#fJ+1]=mL end;if hover then fJ[#fJ+1]=" style='stroke:white; stroke-width:2'"else fJ[#fJ+1]=" style='stroke:black; stroke-width:1'"end;fJ[#fJ+1]="></rect>"fJ[#fJ+1]=e("<text x='%f' y='%f' font-size='24' fill='",cp+eZ/2,cq+mJ/2+5)if mI then fJ[#fJ+1]="black"else fJ[#fJ+1]="white"end;fJ[#fJ+1]="' text-anchor='middle' font-family='Montserrat'>"if mI then fJ[#fJ+1]=e("%s</text>",mM)else fJ[#fJ+1]=e("%s</text>",mN)end end;local mO="rgb(50,50,50)'"local mP="rgb(210,200,200)"local mQ=mH;for _,dd in pairs(aE)do local lE=dd.disableName;local lD=dd.enableName;if type(lE)=="function"then lE=lE()end;if type(lD)=="function"then lD=lD()end;if not dd.drawCondition or dd.drawCondition()then mQ(fJ,dd.toggleVar(),dd.hovered,dd.x,dd.y,dd.width,dd.height,mP,mO,lE,lD)end end end;local mR=x(ResolutionX/2,0)local mS=x(ResolutionY/2,0)local fJ={}b8.HUDPrologue(fJ)if showHud then b8.UpdateHud(fJ)else if AlwaysVSpd then b8.DrawVerticalSpeed(fJ,aq)end;b8.DisplayOrbitScreen(fJ)b8.DrawWarnings(fJ)end;if bP and bQ~={}then b8.DrawSettings(fJ)end;b8.UpdateRadar()b8.HUDEpilogue(fJ)fJ[#fJ+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aH,aI)if Z~="empty"then b8.DisplayMessage(fJ,Z)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then b8.DrawDeadZone(fJ)end end;if w()==0 then if l()==1 and Y then if not AltIsOn then mC()mG(fJ)end;if not bb and not bc then local mT=table.concat(fJ,"")fJ={}fJ[#fJ+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aH,aI)fJ[#fJ+1]=mT;fJ[#fJ+1]="</body>"bb=true;fJ[#fJ+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fJ,"")system.setScreen(content)elseif bc then local mT=table.concat(fJ,"")fJ={}fJ[#fJ+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aH,aI)fJ[#fJ+1]=mT;fJ[#fJ+1]="</body>"end;if not bb then fJ[#fJ+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],mR,mS,ad,ae)end else mB()end else if not Y and l()==0 then mB()if ag>DeadZone then if DisplayDeadZone then mz(fJ)end end elseif not AltIsOn then mC()mG(fJ)end;fJ[#fJ+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],mR,mS,ad,ae)end;fJ[#fJ+1]=[[</svg></body>]]content=table.concat(fJ,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif m5=="apTick"then ba.APTick()end end;function script.onFlush()local function mU(mV,kK)local mW=vec3()local mX=vec3()if mV==axisCommandId.longitudinal then mW=vec3(core.getConstructOrientationForward())mX=bB elseif mV==axisCommandId.vertical then mW=vec3(core.getConstructOrientationUp())mX=bA elseif mV==axisCommandId.lateral then mW=vec3(core.getConstructOrientationRight())mX=bC else return vec3()end;local mY=vec3(core.getWorldGravity())local mZ=mY:dot(mX)local m_=vec3(core.getWorldAirFrictionAcceleration())local n0=m_:dot(mX)local n1=vec3(core.getVelocity())local n2=n1:dot(mW)local n3=kK*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(n3-n2)local n4=targetSpeedPID2:get()local n5=(n4-n0-mZ)*mX;return n5 end;local function n6(mV,kK)local mW=vec3()local mX=vec3()if mV==axisCommandId.longitudinal then mW=vec3(core.getConstructOrientationForward())mX=bB elseif mV==axisCommandId.vertical then mW=vec3(core.getConstructOrientationUp())mX=bA elseif mV==axisCommandId.lateral then mW=vec3(core.getConstructOrientationRight())mX=bC else return vec3()end;local mY=vec3(core.getWorldGravity())local mZ=mY:dot(mX)local m_=vec3(core.getWorldAirFrictionAcceleration())local n0=m_:dot(mX)local n1=vec3(core.getVelocity())local n2=n1:dot(mW)local n3=kK*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(n3-n2)local n4=targetSpeedPID:get()local n5=(n4-n0-mZ)*mX;return n5 end;local function n7(n8,gc,jy)local n9=n8:cross(jy):normalize_inplace()local gY=math.acos(q(n9:dot(-gc),-1,1))*constants.rad2deg;if n9:cross(-gc):dot(jy)<0 then gY=-gY end;return gY end;if antigrav and not ExternalAGG then if not bK and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bM=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bM and L then cu(0)L=false elseif not bM and not L then H=0;L=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local na=q(Q+R+system.getControlDeviceForwardInput(),-1,1)local nb=q(T+W+system.getControlDeviceYawInput(),-1,1)local nc=q(U+S-system.getControlDeviceLeftRightInput(),-1,1)local nd=V;bF=vec3(core.getWorldVertical())if bF==nil or bF:len()==0 then bF=(planet.center-bH):normalize()end;bA=vec3(core.getConstructWorldOrientationUp())bB=vec3(core.getConstructWorldOrientationForward())bC=vec3(core.getConstructWorldOrientationRight())bD=vec3(core.getWorldVelocity())bH=vec3(core.getConstructWorldPos())at=core.getConstructMass()bE=vec3(bD):len()bG=-bF:dot(bD)bO=getRoll(bF,bB,bC)local ne=bO/180*math.pi;local nf=math.cos(ne)local ng=math.sin(ne)bN=n7(bF,bB,bC*nf+bA*ng)local nh=bD:normalize()local ni=c(bO)local nj=utils.sign(bO)local nk=vec3(core.getWorldAngularVelocity())local nl=na*pitchSpeedFactor*bC+nb*rollSpeedFactor*bB+nc*yawSpeedFactor*bA;if bd==true and bF:len()>0.01 then local nm=c(bh-bO)if((ProgradeIsOn or Reentry or BrakeLanding or aj or AltitudeHold or IntoOrbit)and nm>0 or ap>0.0 and nm<autoRollRollThreshold and autoRollPreference)and nb==0 and c(bN)<85 then local nn=bh;local no=autoRollFactor;if ap==0 then no=no/4;bh=0;nn=0 end;if rollPID==nil then rollPID=pid.new(no*0.01,0,no*0.1)end;rollPID:inject(nn-bO)local np=rollPID:get()nl=nl+np*bB end end;if bF:len()>0.01 and ap>0.0 then local nq=20.0;if turnAssist==true and ni>nq and na==0 and nc==0 then local nr=turnAssistFactor*0.1;local ns=turnAssistFactor*0.025;local nt=(ni-nq)/(180-nq)*180;local nu=0;if nt<90 then nu=nt/90 elseif nt<180 then nu=(180-nt)/90 end;nu=nu*nu;local nw=-nj*ns*(1.0-nu)local nx=nr*nu;nl=nl+nx*bC+nw*bA end end;local ny=1;local nz=0;local nA=1;if system.getMouseWheel()>0 then if AltIsOn then if ap>0 or Reentry then bk=q(bk+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif au then local nB=H;H=x(q(H+speedChangeLarge/100,-1,1),2)if H>=0 and nB<0 then H=0;au=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ap>0 or Reentry then bk=q(bk-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif au then local nB=H;H=x(q(H-speedChangeLarge/100,-1,1),2)if H<=0 and nB>0 then H=0;au=false end end else au=true end;I=0;if ao and AtmoSpeedAssist and bM then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bk/3.6-bD:dot(bB))local nC=throttlePID:get()K=q(nC,-1,1)if K<H and ap>0.005 then J=true;r:setThrottleCommand(axisCommandId.longitudinal,q(K,0.01,1))else J=false;r:setThrottleCommand(axisCommandId.longitudinal,H)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bD:len()-bk/3.6)local nD=q(brakePID:get(),0,1)if ap>0 and bG<-80 or ap>0.005 then I=nD end;if I>0 then if J and K==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else K=q(K,0.01,1)end;local nE=''local nF=vec3()local nG=mU(axisCommandId.vertical,ac*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",nG,nz)local nH='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nH=nH..ExtraLongitudeTags end;local nI=r:getAxisCommandType(axisCommandId.longitudinal)local nJ=r:composeAxisAccelerationFromThrottle(nH,axisCommandId.longitudinal)local nK=n6(axisCommandId.lateral,LeftAmount*1000)nE=nE..' , '.."lateral airfoil , lateral ground "nF=nF+nK;if nF:len()>constants.epsilon then a:setEngineForceCommand(nE,nF,nz,'','','',nA)end;a:setEngineForceCommand(nH,nJ,ny)local nL='thrust analog vertical fueled 'local nM='thrust analog lateral fueled 'if ExtraLateralTags~="none"then nM=nM..ExtraLateralTags end;if ExtraVerticalTags~="none"then nL=nL..ExtraVerticalTags end;if ac~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(nL,nG,ny)else a:setEngineForceCommand(nL,vec3(),ny)end;if LeftAmount~=0 then a:setEngineForceCommand(nM,nK,ny)else a:setEngineForceCommand(nM,vec3(),ny)end;if nd==0 then nd=I end;local nN=-nd*(brakeSpeedFactor*bD+brakeFlatFactor*nh)a:setEngineForceCommand('brake',nN)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,H)end;local kK=unit.getAxisCommandValue(0)if not bM then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bD:len()-kK/3.6)local nD=q(brakePID:get(),0,1)nd=q(nd+nD,0,1)end;local nN=-nd*(brakeSpeedFactor*bD+brakeFlatFactor*nh)a:setEngineForceCommand('brake',nN)local nE=''local nF=vec3()local nO=false;local nH='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nH=nH..ExtraLongitudeTags end;local nI=r:getAxisCommandType(axisCommandId.longitudinal)if nI==axisCommandType.byThrottle then local nJ=r:composeAxisAccelerationFromThrottle(nH,axisCommandId.longitudinal)a:setEngineForceCommand(nH,nJ,ny)elseif nI==axisCommandType.byTargetSpeed then local nJ=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)nE=nE..' , '..nH;nF=nF+nJ;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then nO=true end end;local nM='thrust analog lateral 'if ExtraLateralTags~="none"then nM=nM..ExtraLateralTags end;local nP=r:getAxisCommandType(axisCommandId.lateral)if nP==axisCommandType.byThrottle then local nQ=r:composeAxisAccelerationFromThrottle(nM,axisCommandId.lateral)a:setEngineForceCommand(nM,nQ,ny)elseif nP==axisCommandType.byTargetSpeed then local nK=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)nE=nE..' , '..nM;nF=nF+nK end;local nL='thrust analog vertical 'if ExtraVerticalTags~="none"then nL=nL..ExtraVerticalTags end;local nR=r:getAxisCommandType(axisCommandId.vertical)if nR==axisCommandType.byThrottle then local nG=r:composeAxisAccelerationFromThrottle(nL,axisCommandId.vertical)if ac~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(nL,nG,ny,'airfoil','ground','',nA)else a:setEngineForceCommand(nL,vec3(),ny)a:setEngineForceCommand('airfoil vertical',nG,ny,'airfoil','','',nA)a:setEngineForceCommand('ground vertical',nG,ny,'ground','','',nA)end elseif nR==axisCommandType.byTargetSpeed then if ac<0 then a:setEngineForceCommand('hover',vec3(),ny)end;local nS=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)nE=nE..' , '..nL;nF=nF+nS end;if nF:len()>constants.epsilon then if V~=0 or nO or c(nh:dot(bB))<0.8 then nE=nE..', brake'end;a:setEngineForceCommand(nE,nF,nz,'','','',nA)end end;local nT=torqueFactor*(nl-nk)local nU=vec3(core.getWorldAirFrictionAngularAcceleration())nT=nT-nU;a:setEngineTorqueCommand('torque',nT,ny,'airfoil','','',nA)a:setBoosterCommand('rocket_engine')if a4 and not VanillaRockets then local f5=vec3(core.getVelocity()):len()local nV=0.15;if not bM then local nW=r:getTargetSpeed(axisCommandId.longitudinal)if f5*3.6>nW*(1-nV)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f5*3.6<nW*(1-nV)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kD=unit.getThrottle()if AtmoSpeedAssist then kD=H*100 end;local kK=kD/100;if j==0 then kK=kK*MaxGameVelocity;if f5>=kK*(1-nV)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f5<kK*(1-nV)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kV=d(bk)kK=kK*kV/3.6;if f5>=kK*(1-nV)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f5<kK*(1-nV)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local js=coroutine.status(beginSetup)if js=="suspended"then local cv,jt=coroutine.resume(beginSetup)if jt then system.print("ERROR STARTUP: "..jt)end elseif js=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not bb and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(nX)local z=1;local function nY(nZ)local function n_(o0,nZ)local o1={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local o2=o0;for _,dd in ipairs(o1)do if nZ and o2>dd then o0=dd elseif o0<dd and not nZ then o0=dd;break end end;return o0 end;if nZ then z=-1 end;if not ExternalAGG and bK then if Y and nZ then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+z*a1;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+z*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if Y then bt=n_(bt,nZ)else bt=bt+z*a0 end;if bt<planet.noAtmosphericDensityAltitude then bt=planet.noAtmosphericDensityAltitude end else if Y and ao then HoldAltitude=n_(HoldAltitude,nZ)else HoldAltitude=HoldAltitude+z*a0 end end else r:updateTargetGroundAltitudeFromActionStart(z*1.0)end end;local function o3(nZ)if nZ then z=-1 end;if not Y then if AtmoSpeedAssist and not AltIsOn then H=q(H+z*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,z*speedChangeLarge)end else if nZ then z=1 else z=nil end;b9.adjustAutopilotTargetIndex(z)end end;local function o4(o5)if not ao then Z="Flight Assist in Atmo only"return end;local dk=type(o5)if bW==nil then if dk=="table"then if Autopilot or VectorToTarget then cI()end;cb("180On","BR")elseif dk==1 then cb("bnkLft","BR")else cb("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cG()if dk~="table"then o5=o5+1 end end;bW=o5 elseif dk=="table"then cb("180Off","BR")bW=nil end end;if nX=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cu(0)if vBooster or hover then if ao and am==-1 then cb("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bd=true;GearExtended=false else if P then cb("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if ao then BrakeIsOn=true end end end;if P and not BrakeLanding and not(vBooster or hover)then cb("grOut","LG",1)a.control.extendLandingGears()end else if P then cb("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif nX=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif nX=="forward"then Q=Q-1 elseif nX=="backward"then if AltIsOn then o4(-bD*5000)else Q=Q+1 end elseif nX=="left"then if AltIsOn then o4(1)else T=T-1 end elseif nX=="right"then if AltIsOn then o4(3)else T=T+1 end elseif nX=="yawright"then U=U-1 elseif nX=="yawleft"then U=U+1 elseif nX=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif nX=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif nX=="up"then ac=ac+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif nX=="down"then ac=ac-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif nX=="groundaltitudeup"then nY()elseif nX=="groundaltitudedown"then nY(true)elseif nX=="option1"then b9.adjustAutopilotTargetIndex()toggleView=false elseif nX=="option2"then b9.adjustAutopilotTargetIndex(1)toggleView=false elseif nX=="option3"then local function o6()aD=not aD;if not aD then cb("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else cb("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;o6()toggleView=false elseif nX=="option4"then bW=nil;cI()toggleView=false elseif nX=="option5"then function ToggleLockPitch()if LockPitch==nil then cb("lkPOn","LP")LockPitch=bN;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else cb("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif nX=="option6"then cG()toggleView=false elseif nX=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then Z="Collision System Enabled"else Z="Collision System Secured"end;toggleView=false elseif nX=="option8"then stablized=not stablized;if not stablized then Z="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()cb("gsOff","GS")else Z="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)cb("gsOn","GS")end;toggleView=false elseif nX=="option9"then if gyro~=nil then gyro.toggle()av=gyro.getState()==1;if av then cb("gyOn","GA")else cb("gyOff","GA")end end;toggleView=false elseif nX=="lshift"then if AltIsOn then Y=true end;if w()==1 then Y=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then Y=true;bc=false;bb=false end elseif nX=="brake"then if BrakeToggleStatus then cP()elseif not BrakeIsOn then cP()else BrakeIsOn=true end elseif nX=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif nX=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a4 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a4=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a4=false end elseif nX=="stopengines"then local function o7()if A-B<1.5 then cb("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bW=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;X=false;M=false;aj=false;ak=false;O=false;bd=autoRollPreference;VectorToTarget=false;TurnBurn=false;av=false;LockPitch=nil;IntoOrbit=false end end;o7()B=A;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if H~=0 then r:resetCommand(axisCommandId.longitudinal)cu(0)else cu(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if ao then cx(AtmoSpeedLimit)else cx(MaxGameVelocity*3.6)end end end elseif nX=="speedup"then o3()elseif nX=="speeddown"then o3(true)elseif nX=="antigravity"and not ExternalAGG then if antigrav~=nil then d2()end end end;function script.onActionStop(nX)local function o8()if not ExternalAGG and bK then a3=a1 end;if AltitudeHold or VertTakeOff or IntoOrbit then a2=a0 end end;if nX=="forward"then Q=0 elseif nX=="backward"then Q=0 elseif nX=="left"then if bW==2 then bW=0 else bW=nil end;T=0 elseif nX=="right"then if bW==4 then bW=0 else bW=nil end;T=0 elseif nX=="yawright"then U=0 elseif nX=="yawleft"then U=0 elseif nX=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif nX=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif nX=="up"then ac=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif nX=="down"then ac=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif nX=="groundaltitudeup"then o8()toggleView=false elseif nX=="groundaltitudedown"then o8()toggleView=false elseif nX=="lshift"then if w()==1 then ad=0;ae=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then bc=false;bb=false end;Y=false elseif nX=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cP()else BrakeIsOn=false end end elseif nX=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(nX)local z=1;local function o9(nZ)if nZ then z=-1 end;if not ExternalAGG and bK then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+z*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a3=a3*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+z*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bt=bt+z*a2;if bt<planet.noAtmosphericDensityAltitude then bt=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+z*a2 end;a2=a2*1.05 else r:updateTargetGroundAltitudeFromActionLoop(z*1.0)end end;local function oa(nZ)if nZ then z=-1 end;if not Y then if AtmoSpeedAssist and not AltIsOn then H=q(H+z*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,z*speedChangeSmall)end end end;if nX=="groundaltitudeup"then if not Y then o9()end elseif nX=="groundaltitudedown"then if not Y then o9(true)end elseif nX=="speedup"then oa()elseif nX=="speeddown"then oa(true)end end;function script.onInputText(cr)local function ob()for dc,dd in pairs(ch())do dbHud_1.setStringValue(dd,g(nil))end;for dc,dd in pairs(b)do if dd~="SavedLocations"then dbHud_1.setStringValue(dd,g(nil))end end;Z="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"af=5;aJ=false end;local function oc(fZ,c7)local od=false;local dt='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dF,dG,dN,dO,dP=n(c7,dt)for _,dd in pairs(b4[0])do if dd.name==fZ then dO=math.rad(dO)dN=math.rad(dN)local planet=a_[tonumber(dF)][tonumber(dG)]local eA=math.cos(dN)local oe=vec3(eA*math.cos(dO),eA*math.sin(dO),math.sin(dN))return planet.center+(planet.radius+dP)*oe end end;return fZ.." not found"end;local function of(og,planet,c7,gU)local function oh(c7)local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dF,dG,dN,dO,dP=n(c7,dt)if dF=="0"and dG=="0"then return vec3(tonumber(dN),tonumber(dO),tonumber(dP))end;dO=math.rad(dO)dN=math.rad(dN)local planet=a_[tonumber(dF)][tonumber(dG)]local eA=math.cos(dN)local oe=vec3(eA*math.cos(dO),eA*math.sin(dO),math.sin(dN))return planet.center+(planet.radius+dP)*oe end;if dbHud_1 or gU then local cN={}local position=oh(c7)if planet.name=="Space"then cN={position=position,name=og,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cN={position=position,name=og,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;if not gU then SavedLocations[#SavedLocations+1]=cN else for dc,dd in pairs(a_[0])do if dd.name and og==dd.name then table.remove(a_[0],dc)end end end;table.insert(a_[0],cN)b9.UpdateAtlasLocationsList()else Z="Databank must be installed to save permanent locations"end end;local i;local oi,oj=nil,nil;local ok="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cr," ")oi=cr;if i~=nil then oi=string.sub(cr,0,i-1)oj=string.sub(cr,i+1)end;if oi=="/help"or oi=="/commands"then for ix in string.gmatch(ok,"([^\n]+)")do system.print(ix)end;return elseif oi=="/setname"then if oj==nil or oj==""then Z="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cK(oj)else Z="Select a saved target to rename first"end elseif oi=="/addlocation"or string.find(cr,"::pos")~=nil then local gU=false;local og="0-Temp"if oj==nil or oj==""then oj=oi;gU=true end;i=string.find(oj,"::")if not gU then og=string.sub(oj,1,i-2)end;local c7=string.sub(oj,i)local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dF,dG,dN,dO,dP=n(c7,dt)local planet=a_[tonumber(dF)][tonumber(dG)]if planet.name=="Space"then local ol=vec3(tonumber(dN),tonumber(dO),tonumber(dP))local dK=sys:closestBody(ol)if(ol-dK.center):len()<dK.radius+dK.noAtmosphericDensityAltitude then planet=dK end end;of(og,planet,c7,gU)Z="Added "..og.." to saved locations,\nplanet "..planet.name.." at "..c7;af=5 elseif oi=="/agg"then if oj==nil or oj==""then Z="Usage: /agg targetheight"return end;oj=tonumber(oj)if oj<1000 then oj=1000 end;AntigravTargetAltitude=oj;Z="AGG Target Height set to "..oj elseif oi=="/G"then if oj==nil or oj==""then Z="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oj=="dump"then for dc,dd in pairs(ch())do if type(_G[dd])=="boolean"then if _G[dd]==true then system.print(dd.." true")else system.print(dd.." false")end elseif _G[dd]==nil then system.print(dd.." nil")else system.print(dd.." ".._G[dd])end end;return end;i=string.find(oj," ")local om=string.sub(oj,0,i-1)local on=string.sub(oj,i+1)for dc,dd in pairs(ch())do if dd==om then Z="Variable "..om.." changed to "..on;local oo=type(_G[dd])if oo=="number"then on=tonumber(on)elseif oo=="boolean"then if string.lower(on)=="true"then on=true else on=false end end;_G[dd]=on;return end end;Z="No such global variable: "..om elseif oi=="/copydatabank"then if dbHud_2 then d8(true)else Z="Spare Databank required to copy databank"end elseif oi=="/iphWP"then if AutopilotTargetIndex>0 then system.print(ba.showWayPoint(a9,AutopilotTargetCoords,true))Z="::pos waypoint shown in lua chat"else Z="No target selected in IPH"end end end;function script.onEnter(id)if radar_1 and not ao and not bT then unit.setTimer("contact",0.1)end end;function script.onLeave(id)if radar_1 and CollisionSystem then if#bX>650 then id=tostring(id)bX[id]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
