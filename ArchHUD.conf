name: ArchHud - Archaegeo v0.719 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.719;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=true;G=true;H=true;I={userControlScheme={set=function(J)g=J end,get=function()return g end},soundFolder={set=function(J)h=J end,get=function()return h end},freeLookToggle={set=function(J)i=J end,get=function()return i end},BrakeToggleDefault={set=function(J)j=J end,get=function()return j end},RemoteFreeze={set=function(J)k=J end,get=function()return k end},brightHud={set=function(J)m=J end,get=function()return m end},RemoteHud={set=function(J)l=J end,get=function()return l end},VanillaRockets={set=function(J)n=J end,get=function()return n end},InvertMouse={set=function(J)o=J end,get=function()return o end},autoRollPreference={set=function(J)p=J end,get=function()return p end},ExternalAGG={set=function(J)q=J end,get=function()return q end},UseSatNav={set=function(J)r=J end,get=function()return r end},ShouldCheckDamage={set=function(J)s=J end,get=function()return s end},AtmoSpeedAssist={set=function(J)t=J end,get=function()return t end},ForceAlignment={set=function(J)u=J end,get=function()return u end},DisplayDeadZone={set=function(J)v=J end,get=function()return v end},showHud={set=function(J)w=J end,get=function()return w end},hideHudOnToggleWidgets={set=function(J)x=J end,get=function()return x end},ShiftShowsRemoteButtons={set=function(J)y=J end,get=function()return y end},SetWaypointOnExit={set=function(J)z=J end,get=function()return z end},AlwaysVSpd={set=function(J)A=J end,get=function()return A end},BarFuelDisplay={set=function(J)B=J end,get=function()return B end},voices={set=function(J)C=J end,get=function()return C end},alerts={set=function(J)D=J end,get=function()return D end},CollisionSystem={set=function(J)E=J end,get=function()return E end},AutoShieldToggle={set=function(J)F=J end,get=function()return F end},PreventPvP={set=function(J)G=J end,get=function()return G end},DisplayOdometer={set=function(J)H=J end,get=function()return H end}}K=35;L=35;M=30;N=30;O=-30;P=0;Q=5000;R=1.2;S=2000;T=1050;U=30000;V=1000;W=50;X=0;Y=100000;Z=8333.00;_=1.0;a0=32;a1=0;a2=0;a3=0;a4=0;a5=0;a6=0;a7={YawStallAngle={set=function(J)K=J end,get=function()return K end},PitchStallAngle={set=function(J)L=J end,get=function()return L end},brakeLandingRate={set=function(J)M=J end,get=function()return M end},MaxPitch={set=function(J)N=J end,get=function()return N end},ReEntryPitch={set=function(J)O=J end,get=function()return O end},LockPitchTarget={set=function(J)P=J end,get=function()return P end},AutopilotSpaceDistance={set=function(J)Q=J end,get=function()return Q end},TargetOrbitRadius={set=function(J)R=J end,get=function()return R end},LowOrbitHeight={set=function(J)S=J end,get=function()return S end},AtmoSpeedLimit={set=function(J)T=J end,get=function()return T end},SpaceSpeedLimit={set=function(J)U=J end,get=function()return U end},AutoTakeoffAltitude={set=function(J)V=J end,get=function()return V end},TargetHoverHeight={set=function(J)W=J end,get=function()return W end},LandingGearGroundHeight={set=function(J)X=J end,get=function()return X end},ReEntryHeight={set=function(J)Y=J end,get=function()return Y end},MaxGameVelocity={set=function(J)Z=J end,get=function()return Z end},AutopilotInterplanetaryThrottle={set=function(J)_=J end,get=function()return _ end},warmup={set=function(J)a0=J end,get=function()return a0 end},fuelTankHandlingAtmo={set=function(J)a1=J end,get=function()return a1 end},fuelTankHandlingSpace={set=function(J)a2=J end,get=function()return a2 end},fuelTankHandlingRocket={set=function(J)a3=J end,get=function()return a3 end},ContainerOptimization={set=function(J)a4=J end,get=function()return a4 end},FuelTankOptimization={set=function(J)a5=J end,get=function()return a5 end},AutoShieldPercent={set=function(J)a6=J end,get=function()return a6 end}}a8=1920;a9=1080;aa=400;ab=130;ac=224;ad=255;ae=255;af=0;ag=0;ah=960;ai=540;aj=1300;ak=540;al=1525;am=325;an=550;ao=540;ap=30;aq=700;ar=1750;as=250;at=50;au=250;av=0;aw=30;ax=100;ay={ResolutionX={set=function(J)a8=J end,get=function()return a8 end},ResolutionY={set=function(J)a9=J end,get=function()return a9 end},circleRad={set=function(J)aa=J end,get=function()return aa end},SafeR={set=function(J)ab=J end,get=function()return ab end},SafeG={set=function(J)ac=J end,get=function()return ac end},SafeB={set=function(J)ad=J end,get=function()return ad end},PvPR={set=function(J)ae=J end,get=function()return ae end},PvPG={set=function(J)af=J end,get=function()return af end},PvPB={set=function(J)ag=J end,get=function()return ag end},centerX={set=function(J)ah=J end,get=function()return ah end},centerY={set=function(J)ai=J end,get=function()return ai end},throtPosX={set=function(J)aj=J end,get=function()return aj end},throtPosY={set=function(J)ak=J end,get=function()return ak end},vSpdMeterX={set=function(J)al=J end,get=function()return al end},vSpdMeterY={set=function(J)am=J end,get=function()return am end},altMeterX={set=function(J)an=J end,get=function()return an end},altMeterY={set=function(J)ao=J end,get=function()return ao end},fuelX={set=function(J)ap=J end,get=function()return ap end},fuelY={set=function(J)aq=J end,get=function()return aq end},shieldX={set=function(J)ar=J end,get=function()return ar end},shieldY={set=function(J)as=J end,get=function()return as end},DeadZone={set=function(J)at=J end,get=function()return at end},OrbitMapSize={set=function(J)au=J end,get=function()return au end},OrbitMapX={set=function(J)av=J end,get=function()return av end},OrbitMapY={set=function(J)aw=J end,get=function()return aw end},soundVolume={set=function(J)ax=J end,get=function()return ax end}}az=5.0;aA=1.0;aB=0.003;aC=0.003;aD=2;aE=1.5;aF=180;aG=150;aH=0.002;aI=2;aJ=0.8;aK=1;aL=3;aM=1;aN=40;aO=0.0166667;aP=0.0666667;aQ=0.0;aR="none"aS="none"aT="none"aU={speedChangeLarge={set=function(J)az=J end,get=function()return az end},speedChangeSmall={set=function(J)aA=J end,get=function()return aA end},MouseXSensitivity={set=function(J)aB=J end,get=function()return aB end},MouseYSensitivity={set=function(J)aC=J end,get=function()return aC end},autoRollFactor={set=function(J)aD=J end,get=function()return aD end},rollSpeedFactor={set=function(J)aE=J end,get=function()return aE end},autoRollRollThreshold={set=function(J)aF=J end,get=function()return aF end},minRollVelocity={set=function(J)aG=J end,get=function()return aG end},TrajectoryAlignmentStrength={set=function(J)aH=J end,get=function()return aH end},torqueFactor={set=function(J)aI=J end,get=function()return aI end},pitchSpeedFactor={set=function(J)aJ=J end,get=function()return aJ end},yawSpeedFactor={set=function(J)aK=J end,get=function()return aK end},brakeSpeedFactor={set=function(J)aL=J end,get=function()return aL end},brakeFlatFactor={set=function(J)aM=J end,get=function()return aM end},DampingMultiplier={set=function(J)aN=J end,get=function()return aN end},apTickRate={set=function(J)aO=J end,get=function()return aO end},hudTickRate={set=function(J)aP=J end,get=function()return aP end},ExtraEscapeThrust={set=function(J)aQ=J end,get=function()return aQ end},ExtraLongitudeTags={set=function(J)aR=J end,get=function()return aR end},ExtraLateralTags={set=function(J)aS=J end,get=function()return aS end},ExtraVerticalTags={set=function(J)aT=J end,get=function()return aT end}}aV=j;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=1000;b7=false;b8=false;b9=false;ba=false;bb=0;bc="Aligning"bd=0;be=1;bf="None"bg=nil;bh=0;bi=nil;bj=0.0;bk=0;bl={}bm=false;bn=0;bo=0;bp=nil;bq=0;br=1000;bs=0;bt=false;bu=0;bv=false;bw="All"bx=true;by="Off"bz=0.000;bA={}bB={}bC={VertTakeOff={set=function(J)b5=J end,get=function()return b5 end},VertTakeOffEngine={set=function(J)aW=J end,get=function()return aW end},SpaceTarget={set=function(J)bt=J end,get=function()return bt end},BrakeToggleStatus={set=function(J)aV=J end,get=function()return aV end},BrakeIsOn={set=function(J)aX=J end,get=function()return aX end},RetrogradeIsOn={set=function(J)aY=J end,get=function()return aY end},ProgradeIsOn={set=function(J)aZ=J end,get=function()return aZ end},Autopilot={set=function(J)a_=J end,get=function()return a_ end},TurnBurn={set=function(J)b0=J end,get=function()return b0 end},AltitudeHold={set=function(J)b1=J end,get=function()return b1 end},BrakeLanding={set=function(J)b2=J end,get=function()return b2 end},Reentry={set=function(J)b4=J end,get=function()return b4 end},AutoTakeoff={set=function(J)b3=J end,get=function()return b3 end},HoldAltitude={set=function(J)b6=J end,get=function()return b6 end},AutopilotAccelerating={set=function(J)b7=J end,get=function()return b7 end},AutopilotBraking={set=function(J)b9=J end,get=function()return b9 end},AutopilotCruising={set=function(J)ba=J end,get=function()return ba end},AutopilotRealigned={set=function(J)b8=J end,get=function()return b8 end},AutopilotEndSpeed={set=function(J)bb=J end,get=function()return bb end},AutopilotStatus={set=function(J)bc=J end,get=function()return bc end},AutopilotPlanetGravity={set=function(J)bd=J end,get=function()return bd end},PrevViewLock={set=function(J)be=J end,get=function()return be end},AutopilotTargetName={set=function(J)bf=J end,get=function()return bf end},AutopilotTargetCoords={set=function(J)bg=J end,get=function()return bg end},AutopilotTargetIndex={set=function(J)bh=J end,get=function()return bh end},TotalDistanceTravelled={set=function(J)bj=J end,get=function()return bj end},TotalFlightTime={set=function(J)bk=J end,get=function()return bk end},SavedLocations={set=function(J)bl=J end,get=function()return bl end},VectorToTarget={set=function(J)bm=J end,get=function()return bm end},LocationIndex={set=function(J)bn=J end,get=function()return bn end},LastMaxBrake={set=function(J)bo=J end,get=function()return bo end},LockPitch={set=function(J)bp=J end,get=function()return bp end},LastMaxBrakeInAtmo={set=function(J)bq=J end,get=function()return bq end},AntigravTargetAltitude={set=function(J)br=J end,get=function()return br end},LastStartTime={set=function(J)bs=J end,get=function()return bs end},iphCondition={set=function(J)bw=J end,get=function()return bw end},stablized={set=function(J)bx=J end,get=function()return bx end},UseExtra={set=function(J)by=J end,get=function()return by end},SelectedTab={set=function(J)bD=J end,get=function()return bD end},saveRoute={set=function(J)bA=J end,get=function()return bA end},apRoute={set=function(J)bB=J end,get=function()return bB end}}local function bE(a,b,c,bF,bG,bH)bI=bF()bJ=0;bK=0;bL=false;bM=0;bN=false;bO=false;bP=0;bQ=0;bR=0;bS=0;bT=false;bU=false;bV="empty"bW=3;bX=false;bY=0;bZ=0;b_=nil;c0=0;c1=0;c2=0;c3=false;c4=false;c5=false;c6=-1;c7=bH()>0;c8=bH()c9=b.getAltitude()ca=b.getConstructMass()cb=nil;cc=a8;cd=a9;ce={}cf={}cg={}ch=nil;ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=false;cr=false;cs=p;ct=false;cu=T;cv=nil;cw=0;cx=false;cy=false;cz=false;cA=vec3(b.getConstructWorldOrientationForward())cB=vec3(b.getConstructWorldOrientationRight())cC=vec3(b.getVelocity())cD=vec3(b.getWorldVelocity())cE=vec3(cD):len()cF=vec3(b.getWorldVertical())cG=-cF:dot(cD)cH=vec3(b.getConstructWorldPos())cI=false;cJ=false;cK=true;cL=0;cM=0;cN={}cO=false;cP=50000;cQ=nil;cR=c.getClosestPlanetInfluence()>0 or c9>0 and c9<200000;cS=false;cT=nil;cU=false;cV=0;cW=nil;cX=nil;cY={}cZ=90;c_=w;d0=nil;d1=nil;d2={}d3={}d4=false;d5=nil;if shield_1 then d6=bG(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())end end;local function d7(d,b,c,a,d8,d9,da,db,dc)local function dd(de)return type(de)=='number'end;local function df(de)return type(da(de))=='number'end;local function dg(dh)return type(dh)=='table'end;local function di(a)return type(a)=='string'end;local function dj(dk)return dg(dk)and dd(dk.x and dk.y and dk.z)end;local function dl(dm)return dg(dm)and dd(dm.latitude and dm.longitude and dm.altitude and dm.id and dm.systemId)end;local dn=math.pi/180;local dp=180/math.pi;local dq=1e-10;local dr=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local ds='::pos{'..dr..','..dr..','..dr..','..dr..','..dr..'}'local utils=utils;local vec3=vec3;local function dt(de)local du=string.gsub(string.reverse(d8('%.4f',de)),'^0*%.?','')return du==''and'0'or string.reverse(du)end;local function dv(dw)if dj(dw)then return d8('{x=%.3f,y=%.3f,z=%.3f}',dw.x,dw.y,dw.z)end;if dg(dw)and not getmetatable(dw)then local dx={}local dy=next(dw)if type(dy)=='nil'or dy==1 then dx=dw else for dz,dk in pairs(dw)do local dA=dv(dk)if type(dz)=='number'then table.insert(dx,d8('[%s]=%s',dz,dA))else table.insert(dx,d8('%s=%s',dz,dA))end end end;return d8('{%s}',table.concat(dx,','))end;if di(dw)then return d8("'%s'",dw:gsub("'",[[\']]))end;return tostring(dw)end;local dB={}dB.__index=dB;dB.__tostring=function(dw,dC)local dD={}for dz in pairs(dw)do table.insert(dD,dz)end;table.sort(dD)local dx={}for dE,dz in ipairs(dD)do local dA=dv(dw[dz])if type(dz)=='number'then table.insert(dx,d8('[%s]=%s',dz,dA))else table.insert(dx,d8('%s=%s',dz,dA))end end;if dC then return d8('%s%s',dC,table.concat(dx,',\n'..dC))end;return d8('{%s}',table.concat(dx,','))end;dB.__eq=function(dF,dG)return dF.systemId==dG.systemId and dF.id==dG.id and dc(dF.radius,dG.radius)and dc(dF.center.x,dG.center.x)and dc(dF.center.y,dG.center.y)and dc(dF.center.z,dG.center.z)and dc(dF.GM,dG.GM)end;local function dH(dI,dJ,dK,dL,dM)assert(df(dI),'Argument 1 (systemId) must be a number:'..type(dI))assert(df(dJ),'Argument 2 (id) must be a number:'..type(dJ))assert(df(dK),'Argument 3 (radius) must be a number:'..type(dK))assert(dg(dL),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dL))assert(df(dM),'Argument 5 (GM) must be a number:'..type(dM))return setmetatable({systemId=da(dI),id=da(dJ),radius=da(dK),center=vec3(dL),GM=da(dM)},dB)end;local dN={}dN.__index=dN;dN.__tostring=function(dO)return d8('::pos{%d,%d,%s,%s,%s}',dO.systemId,dO.id,dt(dO.latitude*dp),dt(dO.longitude*dp),dt(dO.altitude))end;dN.__eq=function(dF,dG)return dF.id==dG.id and dF.systemId==dG.systemId and dc(dF.latitude,dG.latitude)and dc(dF.altitude,dG.altitude)and(dc(dF.longitude,dG.longitude)or dc(dF.latitude,math.pi/2)or dc(dF.latitude,-math.pi/2))end;local function dP(dQ,dJ,dR,dS,dT)local dI=dQ;if di(dQ)and not dS and not dT and not dJ and not dR then dI,dJ,dR,dS,dT=dU(dQ,ds)assert(dI,'Argument 1 (position string) is malformed.')else assert(df(dI),'Argument 1 (systemId) must be a number:'..type(dI))assert(df(dJ),'Argument 2 (id) must be a number:'..type(dJ))assert(df(dR),'Argument 3 (latitude) must be in degrees:'..type(dR))assert(df(dS),'Argument 4 (longitude) must be in degrees:'..type(dS))assert(df(dT),'Argument 5 (altitude) must be in meters:'..type(dT))end;dI=da(dI)dJ=da(dJ)dR=da(dR)dS=da(dS)dT=da(dT)if dJ==0 then return setmetatable({latitude=dR,longitude=dS,altitude=dT,id=dJ,systemId=dI},dN)end;return setmetatable({latitude=dn*d9(dR,-90,90),longitude=dn*(dS%360),altitude=dT,id=dJ,systemId=dI},dN)end;local dV={}dV.__index=dV;dV.__tostring=function(dw,dC)local dW=dC and dC..'  'local dX={}local dD={}for dz in pairs(dw)do table.insert(dD,dz)end;table.sort(dD)for dE,dY in ipairs(dD)do dZ=dw[dY]local d_=dB.__tostring(dZ,dW)if dC then table.insert(dX,d8('[%s]={\n%s\n%s}',dY,d_,dC))else table.insert(dX,d8('  [%s]=%s',dY,d_))end end;if dC then return d8('\n%s%s%s',dC,table.concat(dX,',\n'..dC),dC)end;return d8('{\n%s\n}',table.concat(dX,',\n'))end;local function e0(e1)local e={}local pid;for dE,dk in pairs(e1)do local dJ=dk.planetarySystemId;if type(dJ)~='number'then error('Invalid planetary s ID: '..tostring(dJ))elseif pid and dJ~=pid then error('Mistringmatch planetary s IDs: '..dJ..' and '..pid)end;local e2=dk.bodyId;if type(e2)~='number'then error('Invalid body ID: '..tostring(e2))elseif e[e2]then error('Duplicate body ID: '..tostring(e2))end;setmetatable(dk.center,getmetatable(vec3.unit_x))e[e2]=setmetatable(dk,dB)pid=dJ end;return setmetatable(e,dV)end;e3={}local function e4(e1)return setmetatable({galaxyAtlas=e1 or{}},e3)end;e3.__index=function(dh,J)if type(J)=='number'then local a=dh.galaxyAtlas[J]return e0(a)end;return rawget(e3,J)end;e3.__pairs=function(dw)return function(dh,dz)local e5,e6=next(dh,dz)return e5,e6 and e0(e6)end,dw.galaxyAtlas,nil end;e3.__tostring=function(dw)local e7={}for dE,e8 in pairs(dw or{})do local e9=e8:getPlanetarySystemId()local ea=dV.__tostring(e8,'    ')table.insert(e7,d8('  [%s]={%s\n  }',e9,ea))end;return d8('{\n%s\n}\n',table.concat(e7,',\n'))end;e3.BodyParameters=dH;e3.MapPosition=dP;e3.PlanetarySystem=e0;function e3.createBodyParameters(dI,dJ,eb,ec,ed,ee,ef)assert(df(dI),'Argument 1 (systemId) must be a number:'..type(dI))assert(df(dJ),'Argument 2 (id) must be a number:'..type(dJ))assert(df(eb),'Argument 3 (surfaceArea) must be a number:'..type(eb))assert(dg(ec),'Argument 4 (aPosition) must be an array or vec3:'..type(ec))assert(dg(ed),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ed))assert(df(ee),'Argument 6 (altitude) must be in meters:'..type(ee))assert(df(ef),'Argument 7 (gravityAtPosition) must be number:'..type(ef))local dK=db(eb/4/math.pi)local c2=dK+ee;local eg=vec3(ec)+c2*vec3(ed)local dM=ef*c2*c2;return dH(dI,dJ,dK,eg,dM)end;e3.isMapPosition=dl;function e3:getPlanetarySystem(dQ)if J==nil then J=0 end;if e6==nil then e6=0 end;local dI=dQ;if dl(dQ)then dI=dQ.systemId end;if type(dI)=='number'then local a=self.galaxyAtlas[J]if a then if getmetatable(e6)~=dV then a=e0(a)end;return a end end end;function dV:sizeCalculator(eh)return 1.05*eh.radius end;function dV:castIntersections(ei,ej,ek,el,em,en)local eo={}if em then for dE,eh in pairs(em)do table.insert(eo,eh)end else eo=cY end;if not en then table.sort(eo,function(ep,eq)local er=ep.center;local es=eq.center;return(er.x-ei.x)^2+(er.y-ei.y)^2+(er.z-ei.z)^2<(es.x-ei.x)^2+(es.y-ei.y)^2+(es.z-ei.z)^2 end)end;local et=ej:normalize()for dE,eh in ipairs(eo)do local eu=eh.center-ei;local dK=self:sizeCalculator(eh)local ev=eu:dot(et)local ew=ev^2-(eu:len2()-dK^2)if ew>=0 then local ex=db(ew)local ey=ev+ex;local ez=ev-ex;if ez>0 then return eh,ey,ez elseif ey>0 then return eh,ey,nil end end end;return nil,nil,nil end;function dV:closestBody(eA)assert(type(eA)=='table','Invalid coordinates.')local eB,eh;local eC=vec3(eA)for dE,eD in pairs(self)do local eE=(eD.center-eC):len2()if(not eh or eE<eB)and eD.name~="Space"then eh=eD;eB=eE end end;return eh end;function dV:convertToBodyIdAndWorldCoordinates(dQ)local eF=dQ;if di(dQ)then eF=dP(dQ)end;if eF.id==0 then return 0,vec3(eF.latitude,eF.longitude,eF.altitude)end;local eD=self:getBodyParameters(eF)if eD then return eF.id,eD:convertToWorldCoordinates(eF)end end;function dV:getBodyParameters(dQ)local dJ=dQ;if dl(dQ)then dJ=dQ.id end;assert(df(dJ),'Argument 1 (id) must be a number:'..type(dJ))return self[dJ]end;function dV:getPlanetarySystemId()local dE,dk=next(self)return dk and dk.systemId end;function dB:convertToMapPosition(dL)assert(dg(dL),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dL))local eG=vec3(dL)if self.id==0 then return setmetatable({latitude=eG.x,longitude=eG.y,altitude=eG.z,id=0,systemId=self.systemId},dN)end;local eH=eG-self.center;local c2=eH:len()local dT=c2-self.radius;local dR=0;local dS=0;if not dc(c2,0)then local eI=eJ(eH.y,eH.x)dS=eI>=0 and eI or 2*math.pi+eI;dR=math.pi/2-math.acos(eH.z/c2)end;return setmetatable({latitude=dR,longitude=dS,altitude=dT,id=self.id,systemId=self.systemId},dN)end;function dB:convertToWorldCoordinates(dQ)local eF=di(dQ)and dP(dQ)or dQ;if eF.id==0 then return vec3(eF.latitude,eF.longitude,eF.altitude)end;assert(dl(eF),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eF.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eF.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eK=math.cos(eF.latitude)return self.center+(self.radius+eF.altitude)*vec3(eK*math.cos(eF.longitude),eK*math.sin(eF.longitude),math.sin(eF.latitude))end;function dB:getAltitude(dL)return(vec3(dL)-self.center):len()-self.radius end;function dB:getDistance(dL)return(vec3(dL)-self.center):len()end;function dB:getGravity(dL)local eL=self.center-vec3(dL)local eM=eL:len2()return self.GM/eM*eL/db(eM)end;return setmetatable(e3,{__call=function(dE,...)return e4(...)end})end;local function eN(d,b,c,a,db,eO)local ci={}local eP=30000000/3600;local eQ=eP*eP;local eR=100;function ci.computeAccelerationTime(eS,eT,eU)local eV=eP*math.asin(eS/eP)return(eP*math.asin(eU/eP)-eV)/eT end;function ci.computeDistanceAndTime(eS,eU,eW,eX,eY,eZ)eY=eY or 0;eZ=eZ or 0;local e_=eS<=eU;local f0=eX*(e_ and 1 or-1)/eW;local f1=-eZ/eW;local f2=f0+f1;if e_ and f2<=0 or not e_ and f2>=0 then return-1,-1 end;local f3,f4=0,0;if f0~=0 and eY>0 then local eV=math.asin(eS/eP)local f5=math.pi*(f0/2+f1)local f6=f0*eY;local f7=eP*math.pi;local dk=function(dh)local f8=(f5*dh-f6*math.sin(math.pi*dh/2/eY)+f7*eV)/f7;local f9=math.tan(f8)return eP*f9/db(f9*f9+1)end;local fa=e_ and function(a)return a>=eU end or function(a)return a<=eU end;f4=2*eY;if fa(dk(f4))then local fb=0;while eO(f4-fb)>0.5 do local dh=(f4+fb)/2;if fa(dk(dh))then f4=dh else fb=dh end end end;local fc=eS;local fd=f4/eR;for fe=1,eR do local ff=dk(fe*fd)f3=f3+(ff+fc)*fd/2;fc=ff end;if f4<2*eY then return f3,f4 end;eS=fc end;local eV=eP*math.asin(eS/eP)local bI=(eP*math.asin(eU/eP)-eV)/f2;local fg=eQ*math.cos(eV/eP)/f2;local c2=fg-eQ*math.cos((f2*bI+eV)/eP)/f2;return c2+f3,bI+f4 end;function ci.computeTravelTime(eS,eT,c2)if c2==0 then return 0 end;if eT>0 then local eV=eP*math.asin(eS/eP)local fg=eQ*math.cos(eV/eP)/eT;return(eP*math.acos(eT*(fg-c2)/eQ)-eV)/eT end;if eS==0 then return-1 end;assert(eS>0,'Acceleration and initial speed are both zero.')return c2/eS end;return ci end;local function fh(d,b,c,a,d8,d9,da,db,dc)local vec3=vec3;local d7=d7(d,b,c,a,d8,d9,da,db,dc)local function di(a)return type(a)=='string'end;local function dg(dh)return type(dh)=='table'end;fi={}fi.__index=fi;function fi:escapeAndOrbitalSpeed(dT)assert(self.body)local c2=dT+self.body.radius;if not dc(c2,0)then local fj=db(self.body.GM/c2)return db(2)*fj,fj end;return nil,nil end;function fi:orbitalParameters(dQ,fk)assert(self.body)assert(dg(dQ)or di(dQ))assert(dg(fk))local fl=(di(dQ)or d7.isMapPosition(dQ))and self.body:convertToWorldCoordinates(dQ)or vec3(dQ)local dk=vec3(fk)local fm=fl-self.body.center;local fn=dk:len2()local fo=fm:len()local fp=self.body.GM;local fq=((fn-fp/fo)*fm-fm:dot(dk)*dk)/fp;local er=fp/(2*fp/fo-fn)local fr=fq:len()local et=fq:normalize()local fs=er*(1-fr)local ft=er*(1+fr)local fu=fs*et+self.body.center;local fv=fr<=1 and-ft*et+self.body.center or nil;local fw=db(er*fp*(1-fr*fr))local fx=fv and 2*math.pi*db(er^3/fp)local fy=math.acos(fq:dot(fm)/(fr*fo))if fm:dot(dk)<0 then fy=-(fy-2*math.pi)end;local fz=math.acos((math.cos(fy)+fr)/(1+fr*math.cos(fy)))local fA=fz;if fA<0 then fA=fA+2*math.pi end;local fB=fA-fr*math.sin(fA)local fC=0;local fD=0;local fE=0;if fx~=nil then fC=fB/(2*math.pi/fx)fD=fx-fC;fE=fD+fx/2;if fy-math.pi>0 then fD=fC;fE=fD+fx/2 end;if fE>fx then fE=fE-fx end end;return{periapsis={position=fu,speed=fw/fs,circularOrbitSpeed=db(fp/fs),altitude=fs-self.body.radius},apoapsis=fv and{position=fv,speed=fw/ft,circularOrbitSpeed=db(fp/ft),altitude=ft-self.body.radius},currentVelocity=dk,currentPosition=fl,eccentricity=fr,period=fx,eccentricAnomaly=fz,meanAnomaly=fB,timeToPeriapsis=fD,timeToApoapsis=fE,trueAnomaly=fy}end;local function fF(fG)local eD=d7.BodyParameters(fG.systemId,fG.id,fG.radius,fG.center,fG.GM)return setmetatable({body=eD},fi)end;return setmetatable(fi,{__call=function(dE,...)return fF(...)end})end;local function fH(d,b,c,a,dbHud_1,e,fI,fJ,bG,da,db,fK,fL)local function fM(fN)local dO=fO:closestBody(fN)if(fN-dO.center):len()>dO.radius+dO.noAtmosphericDensityAltitude then dO=e[0][0]end;return dO end;local function fP()local function fQ(fR,fS)return fR.name<fS.name end;cN={}for dz,dk in pairs(e[0])do cN[#cN+1]={name=dk.name,index=dz}end;table.sort(cN,fQ)end;local function fT(fU,fV)if not fV then fV=fW.name end;for dz,dk in pairs(fU)do if dk.name and dk.name==fV then return dz end end;return-1 end;local function fX()cV=bh;if bh==0 then bf="None"b_=nil;fW=nil;return true end;local fY=cN[bh].index;local fZ=e[0][fY]if fZ.center then bf=fZ.name;b_=ch[0][fY]if fW~=nil then if c8==0 then if fI(f_,g0)~=1 then fJ(f_,g0)end;if fI(g1,g2)~=1 then fJ(g1,g2)end;if fI(g3,g4)~=1 then fJ(g3,g4)end;if fI(g5,g6)~=1 then fJ(g5,g6)end;if fI(g7,g8)~=1 then fJ(g7,g8)end end;if fI(g9,ga)~=1 then fJ(g9,ga)end;if fI(gb,gc)~=1 then fJ(gb,gc)end;if fI(gd,ge)~=1 then fJ(gd,ge)end end;fW=nil else fW=fZ;for dE,dk in pairs(ch[0])do if dk.name==fW.planetname then b_=dk;bf=fW.name;break end end;if fI(g9,ga)~=1 then fJ(g9,ga)end;if fI(gb,gc)~=1 then fJ(gb,gc)end end;if fW==nil then bg=vec3(b_.center)else bg=fW.position end;if b_.planetname~="Space"then if b_.hasAtmosphere then gf=bG(b_.radius*(R-1)+b_.noAtmosphericDensityAltitude)else gf=bG(b_.radius*(R-1)+b_.surfaceMaxAltitude)end else gf=Q end;if fW~=nil and fW.planetname=="Space"then bb=0 else dE,bb=cj(b_):escapeAndOrbitalSpeed(gf)end;bd=0;b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"return true end;local function gg(gh)if not a_ and not bm and not c4 and not bv and not b4 and not c5 then if gh==nil then bh=bh+1;if bh>#cN then bh=0 end else bh=bh-1;if bh<0 then bh=#cN end end;if bh==0 then fX()else local fY=cN[bh].index;local fZ=e[0][fY]if fZ and(fZ~=nil and fZ.name=="Space"or bw=="Custom Only"and fZ.center or bw=="No Moons"and string.find(fZ.name,"Moon")~=nil)then if gh==nil then gg()else gg(1)end else fX()end end else bV="Disengage autopilot before changing Interplanetary Helper"fK("iph","AP")end end;local function gi()local function gj(gk)local gl;if gk then gl=d2 else gl=bl end;local gm=-1;gm=fT(e[0])if gm>-1 then table.remove(e[0],gm)end;gm=-1;gm=fT(gl)if gm~=-1 then bV=fW.name.." saved location cleared"table.remove(gl,gm)end;gg()fP()return gl end;if string.sub(bf,1,1)=="*"then d2=gj(true)else bl=gj(false)end end;local function gn(go,fN,gp,gq)local function gr(gk)if gk then gl=d2 else gl=bl end;if dbHud_1 or gp or gk then local dO=fM(fN)local gs={position=fN,name=go,planetname=dO.name,gravity=b.g(),safe=gq}if not gp then gl[#gl+1]=gs else for dz,dk in pairs(e[0])do if dk.name and go==dk.name then table.remove(e[0],dz)end end end;table.insert(e[0],gs)fP()fX()bV="Location saved as "..go.."("..dO.name..")"return gl else bV="Databank must be installed to save permanent locations"end end;if string.sub(go,1,1)=="*"then d2=gr(true)else bl=gr(false)end end;local gt={}function gt.UpdateAtlasLocationsList()fP()end;function gt.UpdateAutopilotTarget()fX()end;function gt.adjustAutopilotTargetIndex(gh)gg(gh)end;function gt.findAtlasIndex(fU,fV)return fT(fU,fV)end;function gt.UpdatePosition(gu,gv,gw)local function gx(gk)local gl;if gk then gl=d2 else gl=bl end;local gm=fT(gl)if gm~=-1 then if gu~=nil then if gk then gu="*"..gu end;gl[gm].name=gu;bh=bh-1;gg()elseif gw~=nil then if gw then local gy=c9;if gy<1000 then gy=1000 end;gl[gm].agg=fL(gy,0)bV=gl[gm].name.." AGG Altitude:"..gl[gm].agg.." saved ("..gl[gm].planetname..")"return elseif gw==false then gl[gm].agg=nil;bV=gl[gm].name.." AGG Altitude cleared ("..gl[gm].planetname..")"return end else local gz=gl[gm]if gv then gz.heading=cB:cross(cF)*5000;bV=gl[gm].name.." heading saved ("..gl[gm].planetname..")"return elseif gv==false then gz.heading=nil;bV=gl[gm].name.." heading cleared ("..gl[gm].planetname..")"return end;gz.gravity=b.g()gz.position=cH;gz.safe=true end;bV=gl[gm].name.." position updated ("..gl[gm].planetname..")"else bV="Name Not Found"end end;if string.sub(bf,1,1)=="*"then gx(true)else gx(false)end end;function gt.AddNewLocation(go,fN,gp,gq)gn(go,fN,gp,gq)end;function gt.ClearCurrentPosition()gi()end;for dz,dk in pairs(d3)do table.insert(e[0],dk)end;fP()if bh>#cN then bh=0 end;gt.UpdateAutopilotTarget()return gt end;local function gA(b,a,c,library,radar_1,radar_2,eO,gB,db,gC,da,gD,fK)local gE={}local gF={}local gG={XS=13,S=27,M=55,L=110,XL=221}local gH={}local gI;local gJ;local gK;local gL;local gM;local gN={}local gO="Atmo"local gP;local gQ;local gR=0;local gS={}local function gT()local function gU(gV,gW,gX,gY,gZ,g_,h0,h1)gW,gY,g_,h1=vec3(gW),vec3(gY),vec3(g_),vec3(h1)local h2,h3,h4=gV*gV,gX*gX,gZ*gZ;local fn=gY-gW;local h5=fn:normalize()local h6=fn:len()local h7=g_-gW;local h8=(h7-h7:project_on(h5)):normalize()local h9,ha=h7:dot(h5),h7:dot(h8)local hb=h9*h9+ha*ha;local hc=h5:cross(h8)local hd=(h2-h3+h6*h6)/(2*h6)local he=(h2-h4+hb-2*h9*hd)/(2*ha)local dm=h2-hd^2-he^2;local hf=db(dm)local hg=gW+h5*hd+h8*he+hc*hf;local hh=gW+h5*hd+h8*he-hc*hf;if eO((h1-hg):len()-h0)<eO((h1-hh):len()-h0)then return hg else return hh end end;local function hi()local function hj()local hk=b.getConstructWorldOrientationRight()local fn=b.getConstructWorldOrientationForward()local h7=b.getConstructWorldOrientationUp()local hl=library.systemResolution3(hk,fn,h7,{1,0,0})local hm=library.systemResolution3(hk,fn,h7,{0,1,0})local hn=library.systemResolution3(hk,fn,h7,{0,0,1})return function(ho)return library.systemResolution3(hl,hm,hn,ho)end end;local hp=hj()local hq=b.getConstructWorldPos()local fl=b.getElementPositionById(1)local hr={fl[1],fl[2],fl[3]}local hs=hp(hr)local ht={hq[1]-hs[1],hq[2]-hs[2],hq[3]-hs[3]}return ht end;local function hu(hv,fo,hw)local hx=hv.pts;local gm=#hx;local hy=hv.ref;if gm>3 then local hz,hA,hB,hC=hx[gm],hx[gm-1],hx[gm-2],hx[gm-3]hv.ref=hw;local fl=gU(hz[1],hz[2],hA[1],hA[2],hB[1],hB[2],hC[1],hC[2])local hd,he,hf=fl.x,fl.y,fl.z;if hd==hd and he==he and hf==hf then hd=hd+hy[1]he=he+hy[2]hf=hf+hy[3]local hD=vec3(hd,he,hf)if not hv.lastPos then hv.center=hD elseif(hv.lastPos-hD):len()<2 then hv.center=hD;hv.skipCalc=true end;hv.lastPos=hD end;hv.pts={}else local hE={hw[1]-hy[1],hw[2]-hy[2],hw[3]-hy[3]}hx[gm+1]={fo,hE}end end;if radar_1 or radar_2 then cn.assignRadar()end;if gN[1]then gI=#gN[1].getConstructIds()local hF=gN[1].getData()local hG=hF:gmatch('{"constructId[^}]*}[^}]*}')if gI>0 then local hw=hi()local hH,hI=0,0;gM,gL=0,0;for dk in hG do local dJ,c2,hJ=dk:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hK=gG[hJ]c2=da(c2)if gN[1].hasMatchingTransponder(dJ)==1 then table.insert(gF,dJ)end;local hL=gN[1].getConstructType(dJ)if E then if hK>27 or hL=="static"or hL=="space"then gM=gM+1;local go=gN[1].getConstructName(dJ)local hv=gS[dJ]if hv==nil then hK=hK+gD;gS[dJ]={pts={},ref=hw,name=go,i=0,radius=hK,skipCalc=false}hv=gS[dJ]end;if not hv.skipCalc then hu(hv,c2,hw)hI=hI+1 end;if hv.center then table.insert(gH,hv)end end;hH=hH+1;if cR and hH>700 or hI>70 or(not cR and hH>300 or hI>30)then coroutine.yield()hH,hI=0,0 end end end;gL=#gH;if gL>0 and cE>20 then local eh,hM,hN,hO;local hP=0;local hQ=ch:getPlanetarySystem(0)hO=cD:normalize()while hP<gL do coroutine.yield()local hR={table.unpack(gH,hP,math.min(hP+75,gL))}eh,hM,hN=hQ:castIntersections(cH,hO,nil,nil,hR,true)if eh and hN then cT={eh,hM,hN}break end;hP=hP+75 end;if not eh then cT=nil end else cT=nil end;gH={}gJ=hF:find('identifiedConstructs":%[%]')else gK=hF:find('worksInEnvironment":false')end end end;local function hS()if gN[1]then gO="Atmo"if gN[1].getData():find('worksInAtmosphere":false')then gO="Space"end end end;function gE.pickType()hS()end;function gE.assignRadar()if radar_1 and gN[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gN[1]=radar_2 end;if gN[1]==radar_2 then hS()end elseif radar_2 and gN[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gN[1]=radar_1 end;if gN[1]==radar_1 then hS()end end end;function gE.UpdateRadar()local hT=coroutine.status(gP)if hT=="suspended"then local dA,hU=coroutine.resume(gP)if hU then a.print("ERROR UPDATE RADAR: "..hU)end elseif hT=="dead"then gP=coroutine.create(gT)local dA,hU=coroutine.resume(gP)end end;function gE.GetRadarHud(hV,hW,hX,hY)local hZ=gF;local h_,i0;gF={}local dr=gL or 0;if gI>0 then if E then i0=dr.."/"..gM.." Plotted : "..gI-gM.." Ignored"else i0="Radar Contacts: "..gI end;h_=gC(hX,hY,i0,"pbright txtbig txtmid")if#gF>0 then h_=h_..gC(hV,hW,"Friendlies In Range","pbright txtbig txtmid")for dz,dk in pairs(gF)do hW=hW+20;h_=h_..gC(hV,hW,gN[1].getConstructName(dk),"pdim txtmid")end end;if gJ==nil and gQ==nil then gR=1;cn.ToggleRadarPanel()end;if gJ~=nil and gQ~=nil then cn.ToggleRadarPanel()end;if d1==nil then cn.ToggleRadarPanel()end else if gK then h_=gC(hX,hY,gO.." Radar: Jammed","pbright txtbig txtmid")else h_=gC(hX,hY,"Radar: No "..gO.." Contacts","pbright txtbig txtmid")end;if d1~=nil then gR=0;cn.ToggleRadarPanel()end end;return h_ end;function gE.GetClosestName(go)if gN[1]then local dJ,dE=gN[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dJ~=nil and dJ~=""then go=go.." "..gN[1].getConstructName(dJ)end end;return go end;function gE.ToggleRadarPanel()if d1~=nil and gR==0 then gB(d1)d1=nil;if gQ~=nil then gB(gQ)gQ=nil end else if gR==1 then gB(d1)d1=nil;_autoconf.displayCategoryPanel(gN,1,"Periscope","periscope")gQ=_autoconf.panels[_autoconf.panels_size]end;if d1==nil then _autoconf.displayCategoryPanel(gN,1,"Radar","radar")d1=_autoconf.panels[_autoconf.panels_size]end;gR=0 end end;function gE.ContactTick()if not i1 then i1=0 end;if bI>i1+10 then bV="Radar Contact"fK("rdrCon","RC")i1=bI end;c.stopTimer("contact")end;function gE.onEnter(dJ)if radar_1 and not c7 and not cO then c.setTimer("contact",0.1)end end;function gE.onLeave(dJ)if radar_1 and E then if#gS>650 then dJ=tostring(dJ)gS[dJ]=nil end end end;gN[1]=nil;if radar_1 then gN[1]=radar_1;hS()end;gP=coroutine.create(gT)return gE end;local function i2(shield_1,dU,bG)local i3={}local i4=shield_1.getResistancesCooldown()local function i5()local i6=shield_1.getState()if F then if not cO and i6==0 then shield_1.toggle()elseif cO and i6==1 then shield_1.toggle()end end end;local function i7()local i8=shield_1.getStressRatioRaw()local i9=0.5999;if i8[1]==0.0 and i8[2]==0.0 and i8[3]==0.0 and i8[4]==0.0 then return end;local ia=shield_1.setResistances(i9*i8[1],i9*i8[2],i9*i8[3],i9*i8[4])if ia==1 then bV="Shield Resistances updated"else bV="Value Exceeded. Failed to update Shield Resistances"end end;function i3.shieldTick()d6=bG(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())i5()i4=shield_1.getResistancesCooldown()if i4==0 and d6<a6 then i7()end end;function i3.setResist(ib)if not shield_1 then bV="No shield found"return elseif ib==nil or i4>0 then bV="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dr=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local ds=dr..', '..dr..', '..dr..', '..dr;local ic,id,ie,ig=dU(ib,ds)if ig==nil or ic+id+ie+ig>0.6 then bV="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(ic,id,ie,ig)==1 then bV="Shield Resistances set"else bV="Resistance setting failed."end end;function i3.ventShield()local ih=shield_1.getVentingCooldown()if ih>0 then bV="Cannot vent again for "..ih.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()bV="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bV="Shields already at max hitpoints"end end;return i3 end;local function ii(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ij,eO,bG,d8,ik,bH,il,im,eJ,bF,d9,io,fJ,fI,gB,ip,db,fL,gC,fK,iq,ir,is,it,iu,iv)local iw=9.80665;local ix={}local iy={}local iz={}local iA={}local iB=nil;local iC=nil;local iD=nil;local iE=false;local iF="none"local iG=""local iH=55;local iI=0;local iJ=0;local iK=""local iL=nil;local iM=ab;local iN=ac;local iO=ad;local iP=[[rgb(]]..bG(iM+0.5)..","..bG(iN+0.5)..","..bG(iO+0.5)..[[)]]local iQ=[[rgb(]]..bG(iM*0.9+0.5)..","..bG(iN*0.9+0.5)..","..bG(iO*0.9+0.5)..[[)]]local iR=0;local iS=0;local iT=""local iU=bF()local iV=false;local iW=vec3({13771471,7435803,-128971})local iX=18000000;local iY=500000;local iZ,i_=math.huge;local j0;local function j1(j2)iZ=vec3(j2):dist(iW)if iZ<iX then return true,eO(iZ-iX)end;i_=vec3(j2):dist(vec3(j3.center))if i_<iY then j0=true else j0=false end;if eO(i_-iY)<eO(iZ-iX)then return j0,eO(i_-iY)else return j0,eO(iZ-iX)end end;local function j4(dk)if cc==1920 then return dk else return fL(cc*dk/1920,0)end end;local function j5(dk)if cd==1080 then return dk else return fL(cd*dk/1080,0)end end;local function j6()return ip()==0 and g~="keyboard"and im()==0 end;local function j7()local j8="TRAVEL"if not cK then j8="CRUISE"end;if a_ then j8="AUTOPILOT"end;return j8 end;local h_=""local j9=""local ja=""local jb=1;local jc=2;local jd=3;local je=4;local jf=5;local jg=6;local jh=""local ji=0;local jj=bG(1/aO)*2*aP;local jk={}local jl={}local jm={}local jn={}local jo={}local jp={}local jq={}jq["atmofueltank"],jq["spacefueltank"],jq["rocketfueltank"]=0,0,0;local jr=0;local function js(hd,jt,ju,jv,jw,jx)local jy=jr;local jz=jr+5;if not B then jz=jz+5 end;if im()==1 and not l then jy=jy-50;jz=jz-50 end;if ju=="ATMO"then jh="atmofueltank"elseif ju=="SPACE"then jh="spacefueltank"else jh="rocketfueltank"end;ji=_G[jh.."_size"]if#jv>0 then for J=1,#jv do local go=string.sub(jv[J][jc],1,12)local jA=0;for jB=1,ji do if jv[J][jc]==ik(c[jh.."_"..jB].getData()).name then jA=jB;break end end;local jC=bF()if jw[J]==nil or jx[J]==nil or jC-jv[J][jg]>jj then local jD;local jE=0;jE=il(jv[J][jb])-jv[J][je]jD=jv[J][jf]if jD>jE then jq[jh]=jq[jh]+jD-jE end;if jA~=0 then jx[J]=ik(c[jh.."_"..jA].getData()).percentage;jw[J]=ik(c[jh.."_"..jA].getData()).timeLeft;if jw[J]=="n/a"then jw[J]=0 end else jx[J]=bG(0.5+jE*100/jv[J][jd])if jD<=jE then jw[J]=0 else jw[J]=bG(0.5+jE/((jD-jE)/(jC-jv[J][jg])))end end;jv[J][jg]=jC;jv[J][jf]=jE end;if go==jt then go=d8("%s %d",ju,J)end;if jA==0 then go=go.." *"end;local jF;if jw[J]==0 then jF=""else jF=it(jw[J])end;if jx[J]~=nil then local jG=bG(jx[J]*2.55)local jH=d8("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""if jF~=""and jw[J]<120 or jx[J]<5 then jI="red "end;local jJ=d8("rgb(%d,%d,%d)",d9(bG((255-jG)/2.55),50,100),d9(bG(jG/2.55),0,50),50)local jK="rgb(196,0,255)"if ju=="ATMO"then jK="rgb(0,188,255)"elseif ju=="SPACE"then jK="rgb(239,255,0)"end;local jL=false;if jM~=jK then jL=true end;jM=jK;if B then if jL then jy=jy-5;jz=jz-5 end;j9=j9 ..d8([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jJ,jK,hd,jz,jH,bG(jx[J]*1.7+0.5)-2,hd+1,jz+1,hd+5,jz+14,go,jx[J],jF)jy=jy-22;jz=jz-22 else j9=j9 ..gC(hd,jy,go,jI.."pdim txtfuel")j9=j9 ..gC(hd,jz,d8("%d%% %s",jx[J],jF),"pdim txtfuel","fill:"..jH)jy=jy+30;jz=jz+30 end end end end;jr=jy end;local function jN(jO,dT)if al==0 and am==0 then return end;if dT<200000 and not c7 or dT and c7 then local jP=0;if eO(cG)>1 then jP=45*math.log(eO(cG),10)if cG<0 then jP=-jP end end;jO[#jO+1]=d8([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],al,am,bG(cG),bG(jP))end;return jO end;local function jQ(jR)local gh=-cF;jR=jR-jR:project_on(gh)local jS=vec3(0,0,1)jS=jS-jS:project_on(gh)local jT=jS:cross(gh)local jP=jS:angle_between(jR)*constants.rad2deg;if jR:dot(jT)<0 then jP=360-jP end;return jP end;local function jU(jO,ah,ai,jV,jW,cR)if aa==0 then return end;local jX=aa;local jY=20;local jZ=bG(jV)if cR then for J=-45,45,5 do local j_=J;jO[#jO+1]=d8([[<g transform="rotate(%f,%d,%d)">]],j_,ah,ai)k0=5;if J%15==0 then k0=15 elseif J%10==0 then k0=10 end;jO[#jO+1]=d8([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ah,ai+jX+jY-k0,ah,ai+jX+jY)end;jO[#jO+1]=gC(ah,ai+jX+jY-35,jW,"pdim txt txtmid")jO[#jO+1]=gC(ah,ai+jX+jY-25,jZ.." deg","pdim txt txtmid")jO[#jO+1]=d8([[<g transform="rotate(%f,%d,%d)">]],-jV,ah,ai)jO[#jO+1]=d8([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ah-5,ai+jX+jY-20,ah+5,ai+jX+jY-20,ah,ai+jX+jY-15)jO[#jO+1]="</g>"end;jO[#jO+1]=[[<g style="clip-path: url(#headingClip);">]]local k1=jZ;if cR then k1=jQ(cA)end;local k2=20;local k3=bG(k1)local k4=0;local k5=ai+jX+jY+20;local k6=ah;if jW~="YAW"then k5=j5(130)k6=j4(960)end;local k7=[[<path class="txttick line" d="]]local k8=bG(k3-(k2+10)-k3%5+0.5)for J=k8+70,k8,-5 do local hd=k6-(-J*5+k1*5)if J%10==0 then k4=10;local dr=J;if dr==360 then dr=0 elseif dr>360 then dr=dr-360 elseif dr<0 then dr=dr+360 end;jO[#jO+1]=gC(hd,k5+15,dr,"txtmid bright")elseif J%5==0 then k4=5 end;if k4==10 then k7=d8([[%s M %f %f v %d]],k7,hd,k5-5,k4)else k7=d8([[%s M %f %f v %d]],k7,hd,k5-2.5,k4)end end;jO[#jO+1]=k7 ..[["/>]]jO[#jO+1]=d8([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k6-5,k5-20,k6+5,k5-20,k6,k5-10)if H then if cR then jW="HDG"end;jO[#jO+1]=gC(j4(960),j5(100),k3 .."°","dim txt txtmid size14","")jO[#jO+1]=gC(j4(960),j5(85),jW,"dim txt txtmid size20","")end;jO[#jO+1]=[[</g>]]end;local function k9(jO,ka,jV,ah,ai,cR,kb,ff)if aa==0 then return end;local jX=aa;local kc=bG(jX*3/5)if jX>0 then local kd=bG(ka)local k0=0;local k7=d8([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jV,ah,ai)if not c7 then k7=d8([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ah,ai)end;jO[#jO+1]=d8([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jX-1,ah,ai)jO[#jO+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for J=bG(kd-30-kd%5+0.5),bG(kd+30+kd%5+0.5),5 do if J%10==0 then k0=30 elseif J%5==0 then k0=20 end;local he=ai+-J*5+ka*5;if k0==30 then k7=d8([[%s M %d %f h %d]],k7,ah-kc-k0,he,k0)if c7 then jO[#jO+1]=d8([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,ah,ai,ah-kc+10,he+4,J)jO[#jO+1]=d8([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,ah,ai,ah+kc-10,he+4,J)if J==0 or J==180 or J==-180 then jO[#jO+1]=d8([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,ah,ai,ah-kc+20,he,kc*2-40)end else jO[#jO+1]=gC(ah-kc+10,he,J,"pdim txt txtmid")jO[#jO+1]=gC(ah+kc-10,he,J,"pdim txt txtmid")end;k7=d8([[%s M %d %f h %d]],k7,ah+kc,he,k0)else k7=d8([[%s M %d %f h %d]],k7,ah-kc-k0,he,k0)k7=d8([[%s M %d %f h %d]],k7,ah+kc,he,k0)end end;jO[#jO+1]=k7 ..[["/>]]local ke="PITCH"if not cR then ke="REL PITCH"end;if ka>90 and not c7 then ka=90-(ka-90)elseif ka<-90 and not c7 then ka=-90-(ka+90)end;if jX>200 then if c7 then if ff>iH then jO[#jO+1]=gC(ah,ai-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gC(ah,ai+20,kb,"pdim txt txtmid")end;jO[#jO+1]=d8([[<g transform="rotate(%f,%d,%d)">]],-jV,ah,ai)else jO[#jO+1]=d8([[<g transform="rotate(0,%d,%d)">]],ah,ai)end;jO[#jO+1]=d8([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah-kc+25,ai-5,ah-kc+20,ai,ah-kc+25,ai+5,ah-kc+50,ai+4,kd)jO[#jO+1]=d8([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah+kc-25,ai-5,ah+kc-20,ai,ah+kc-25,ai+5,ah+kc-30,ai+4,kd)jO[#jO+1]="</g>"end;local kf=bG(jX/3)jO[#jO+1]=d8([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ah-kf,ai,jX-kf)if not c7 and cR then jO[#jO+1]=d8([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,ah,ai,ah-kc+10,ai,kc*2-20)end;jO[#jO+1]="</g>"if jX<200 then if c7 and ff>iH then jO[#jO+1]=gC(ah,ai-jX,ke,"pdim txt txtmid")jO[#jO+1]=gC(ah,ai-jX+10,kd,"pdim txt txtmid")jO[#jO+1]=gC(ah,ai-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gC(ah,ai+20,kb,"pdim txt txtmid")else jO[#jO+1]=gC(ah,ai-jX,ke,"pdim txt txtmid")jO[#jO+1]=gC(ah,ai-jX+15,kd,"pdim txt txtmid")end end end end;local function kg(jO,dT,cR)local kh=an;local ki=ao;if kh==0 and ki==0 then return end;local kj=78;local kk=19;local kl=c6;if c6~=-1 then jO[#jO+1]=gC(kh+kj,ki+kk+20,d8("AGL: %.1fm",c6),"pdim altsm txtend")end;if cR and(dT<200000 and not c7 or dT and c7)then table.insert(jO,d8([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kh-1,ki-4,kj+2,kk+6,kh+1,ki-1,kj-4,kk))local gm=0;local km=1;local kn=0;local ko=dT<0;local kp=dT<j3.surfaceMaxAltitude;local kq=9;if ko then kq=0 end;local dT=eO(dT)while gm<6 do local kr=11;local ks=16;local kt=9;local ku=14;local jI="altsm"if gm>2 then ks=ks+3;kr=kr+2;ku=ku+2;kt=kt-6;jI="altbig"end;if ko then jI=jI.." red"elseif kp then jI=jI.." orange"end;local kv=dT/km%10;local kw=bG(kv)local kx=bG((kw+1)%10)local ky=kn;if gm==0 then ky=kv-kw;if ko then ky=1-ky end end;if ko and(gm==0 or kn~=0)then local gp=kx;kx=kw;kw=gp end;local kz=ks*(ky-1)local kA=kz+ks;local hd=kh+kt+(6-gm)*kr;local he=ki+ku;jO[#jO+1]=gC(hd,he+kz,kx,jI)jO[#jO+1]=gC(hd,he+kA,kw,jI)gm=gm+1;km=km*10;if kw==kq then kn=ky else kn=0 end end;table.insert(jO,[[</g></g>]])end end;local function kB(fk)local kC=-math.deg(eJ(fk.y,fk.z))+180;kC=kC-90;if kC<0 then kC=360+kC end;if kC>180 then kC=-180+kC-180 end;return-kC end;local function kD(fk)local k1=math.deg(eJ(fk.y,fk.x))-90;if k1<-180 then k1=360+k1 end;return k1 end;local function kE(jO,fk,ff,ah,ai)if ff>5 and not c7 or ff>iH then local jX=aa;local kF=20;local kG=20;local kH=kB(fk)local kI=kD(fk)local kJ=14;local kK=kJ/2;local kL=-kI/kG*jX;local kM=kH/kF*jX;local hd=ah+kL;local he=ai+kM;local c2=db(kL^2+kM^2)local kN=[[<circle
                            cx="]]..hd..[["
                            cy="]]..he..[["
                            r="]]..kK/kJ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hd..[["
                            cy="]]..he..[["
                            r="]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hd-kJ..[[,]]..he..[[ h ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hd+kK..[[,]]..he..[[ h ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hd..[[,]]..he-kJ..[[ v ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c2<jX then jO[#jO+1]=kN else local jP=eJ(kM,kL)local kO=4;local kP=ah+jX*math.cos(jP)local kQ=ai+jX*math.sin(jP)jO[#jO+1]=d8('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jP*180/math.pi,kP,kQ,kP-kO,kQ-kO/2,kO*2,kO,kP+kO,kQ-kO,kO,kO,-kO,kO)end;if not c7 then local kR=vec3(fk)kH=kB(-kR)kI=kD(-kR)kL=-kI/kG*jX;kM=kH/kF*jX;hd=ah+kL;he=ai+kM;c2=db(kL^2+kM^2)if c2<jX then local kS=[[<circle
                                    cx="]]..hd..[["
                                    cy="]]..he..[["
                                    r="]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hd..[[,]]..he-kJ..[[ v ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hd..[[,]]..he..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hd..[[,]]..he..[[)" />
                                <path
                                    d="M ]]..hd-kK..[[,]]..he..[[ h ]]..kJ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hd..[[,]]..he..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hd..[[,]]..he..[[)"/>]]jO[#jO+1]=kS end end end end;local function kT(jO,j8,kU,kV)if aj==0 and ak==0 then return end;kU=bG(kU+0.5)local jy=ak+10;local jz=ak+20;if im()==1 and not l then jy=55;jz=65 end;local kW="CRUISE"local c="km/h"local dA=kV;if j8=="TRAVEL"or j8=="AUTOPILOT"then kW="THROT"c="%"dA=kU;local kX="dim"if kU<0 then kX="red"end;jO[#jO+1]=d8([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kX,aj-7,ak-50,aj,ak-50,aj,ak+50,aj-7,ak+50,1-eO(kU),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)end;jO[#jO+1]=gC(aj+10,jy,kW,"pbright txtstart")jO[#jO+1]=gC(aj+10,jz,d8("%.0f %s",dA,c),"pbright txtstart")if c7 and t and cK and bL then kU=bG(bM*100+0.5)local kX="red"if kU<0 then kX="red"end;jO[#jO+1]=d8([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kX,1-eO(kU),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)jO[#jO+1]=gC(aj+10,jy+40,"LIMIT","pbright txtstart")jO[#jO+1]=gC(aj+10,jz+40,kU.."%","pbright txtstart")end;if c7 and t or b4 then jO[#jO+1]=gC(aj+10,jy-40,"LIMIT: "..cu.." km/h","dim txtstart")elseif not c7 and a_ then jO[#jO+1]=gC(aj+10,jy-40,"LIMIT: "..bG(Z*3.6+0.5).." km/h","dim txtstart")end end;local function kY(jO,kZ)if aj==0 and ak==0 then return end;local k_=ak-10;local l0=aj+10;jO[#jO+1]=gC(0,0,"","pdim txt txtend")if im()==1 and not l then k_=75 end;jO[#jO+1]=gC(l0,k_,bG(kZ).." km/h","pbright txtbig txtstart")end;local function l1(jO)jO[#jO+1]=gC(j4(1900),j5(1070),d8("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jO[#jO+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jO[#jO+1]=gC(j4(960),j5(550),"Warning: Invalid Control Scheme Detected","warnings")jO[#jO+1]=gC(j4(960),j5(600),"Keyboard Scheme must be selected","warnings")jO[#jO+1]=gC(j4(960),j5(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l2=j4(960)local l3=j5(860)local l4=j5(880)local l5=j5(900)local l6=j5(960)local l7=j5(200)local l8=j5(250)local l9=j5(960)if im()==1 and not l then l3=j5(135)l4=j5(155)l5=j5(175)l7=j5(115)l8=j5(95)end;local la="#222222"local lb="white"local lc="dimmer"local ld="pbright"local le="#110000"local lf=la;local lg=lc;if aX then local lh=""if type(aX)=="string"then lh="-"..aX end;jO[#jO+1]=gC(l2,l3,"Brake Engaged"..lh,"warnings")le="#440000"lf=lb;lg=ld elseif bK>0 then jO[#jO+1]=gC(l2,l3,"Auto-Brake Engaged","warnings","opacity:"..bK)end;local li="#110000"local lj=la;local lk=lc;if c7 and ct and c6==-1 then if not a_ and not bm and not b2 and not cJ and not b5 and not b3 then jO[#jO+1]=gC(l2,l7+50,"** STALL WARNING **","warnings")li="#ff0000"lj=lb;lk=ld;fK("stall","SW",2)end end;if cQ then jO[#jO+1]=gC(l2,l7+90,"Flight Assist in Progress","warnings")end;if cb then jO[#jO+1]=gC(l2,l9,"Gyro Enabled","warnings")end;local ll="#111100"local lm=la;local ln=lc;if bi then ll="#775500"lm=lb;ln=ld;if bO then jO[#jO+1]=gC(l2,l4,"Gear Extended","warn")else jO[#jO+1]=gC(l2,l4,"Landed (G: Takeoff)","warnings")end;local lo=is(d:getTargetGroundAltitude())jO[#jO+1]=gC(l2,l5,"Hover Height: "..lo,"warn")end;local lp="#000011"local lq=la;local lr=lc;if bX then lp="#0000DD"lq=lb;lr=ld;jO[#jO+1]=gC(l2,l6+20,"ROCKET BOOST ENABLED","warn")end;local ls="#001100"local lt=la;local lu=lc;if antigrav and not q and cJ and br~=nil then ls="#00DD00"lt=lb;lu=ld;local lv="warnings"if eO(c9-antigrav.getBaseAltitude())<501 then lv="warn"end;jO[#jO+1]=gC(l2,l7+40,d8("Target Altitude: %d Singularity Altitude: %d",bG(br),bG(antigrav.getBaseAltitude())),lv)end;if a_ and bf~="None"then jO[#jO+1]=gC(l2,l7,"Autopilot "..bc,"warn")elseif bp~=nil then jO[#jO+1]=gC(l2,l7+20,d8("LockedPitch: %d",bG(bp)),"warn")elseif bT then jO[#jO+1]=gC(l2,l7+20,"Follow Mode Engaged","warn")elseif b4 or c5 then jO[#jO+1]=gC(l2,l7+20,"Re-entry in Progress","warn")end;if b1 or b5 then local lo=is(b6,2)if b5 then if cJ then lo=is(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jO[#jO+1]=gC(l2,l7,"VTO to "..lo,"warn")elseif b3 and not bv then if c4 then jO[#jO+1]=gC(l2,l7,"Takeoff to "..bf,"warn")else jO[#jO+1]=gC(l2,l7,"Takeoff to "..lo,"warn")end;if aX and not b5 then jO[#jO+1]=gC(l2,l7+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jO[#jO+1]=gC(l2,l7,"Altitude Hold: "..lo,"warn")end end;if b5 and(antigrav~=nil and antigrav)then if c8>0.1 then jO[#jO+1]=gC(l2,l7+20,"Beginning ascent","warn")elseif c8<0.09 and c8>0.05 then jO[#jO+1]=gC(l2,l7+20,"Aligning trajectory","warn")elseif c8<0.05 then jO[#jO+1]=gC(l2,l7+20,"Leaving atmosphere","warn")end end;if bv then if cv~=nil then jO[#jO+1]=gC(l2,l7,cv,"warn")end end;if b2 then if lw then local lx="Brake Landing"if d5 then lx=lx.."-Aligning"end;if d4 then lx=lx.."-Drift Limited"end;jO[#jO+1]=gC(l2,l7,lx,"warnings")else jO[#jO+1]=gC(l2,l7,"Coast-Landing","warnings")end end;if aZ then jO[#jO+1]=gC(l2,l7,"Prograde Alignment","crit")end;if aY then jO[#jO+1]=gC(l2,l7,"Retrograde Alignment","crit")end;local ly="#110000"local lz=la;local lA=lc;if cS then ly="#FF0000"lz=lb;lA=ld;local type;if string.find(cS,"COLLISION")then type="warnings"else type="crit"end;jO[#jO+1]=gC(l2,l8+20,cS,type)elseif c8==0 then local lB,lC=cm.checkLOS(cD:normalize())if lC~=nil then lA=ld;ly="#FF0000"lz=lb;local lo=is(lC)local lD=ci.computeTravelTime(cE,0,lC)local lE="Collision"if lB.noAtmosphericDensityAltitude>0 then lE="Atmosphere"end;jO[#jO+1]=gC(l2,l8+20,lB.name.." "..lE.." "..it(lD).." In "..lo,"crit")end end;if bm and not bv then jO[#jO+1]=gC(l2,l7+60,lF,"warn")end;local lG="#111100"local lH=la;local lI=lc;if cW and#cW>1 then lG="#DDDD00"lH=lb;lI=ld end;local lJ=j4;local lK=j5;local lc="topButton"local lL="topButtonActive"local lM=lc;if a_ or bm or c4 or bv then lM=lL end;local lN=lc;if aZ then lN=lL end;local lO=lc;if b2 or bi then lO=lL end;local lP=lc;if b1 or bm then lP=lL end;local lQ=lc;if aY then lQ=lL end;local lR=lc;if bv or cx and a_ then lR=lL end;if w and H then local lS=lK(30)jO[#jO+1]=d8([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lM,lJ(960),lK(54),lK(-53),lJ(-120),lJ(25),lK(50))jO[#jO+1]=gC(lJ(910),lS,"AUTOPILOT")jO[#jO+1]=d8([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lN,lJ(865),lK(51),lJ(-25),lK(-50),lJ(-110),lJ(25),lK(46))jO[#jO+1]=gC(lJ(800),lS,"PROGRADE")jO[#jO+1]=d8([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lO,lJ(755),lK(47),lJ(-25),lK(-46),lJ(-98),lJ(44),lK(44))jO[#jO+1]=gC(lJ(700),lS,"LAND")jO[#jO+1]=d8([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lP,lJ(960),lK(54),lK(-53),lJ(120),lJ(-25),lK(50))jO[#jO+1]=gC(lJ(1010),lS,"ALT HOLD")jO[#jO+1]=d8([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lQ,lJ(1055),lK(51),lJ(25),lK(-50),lJ(110),lJ(-25),lK(46))jO[#jO+1]=gC(lJ(1122),lS,"RETROGRADE")jO[#jO+1]=d8([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lR,lJ(1165),lK(47),lJ(25),lK(-46),lJ(98),lJ(-44),lK(44))jO[#jO+1]=gC(lJ(1220),lS,"ORBIT")jO[#jO+1]=[[
                                    </g>
                                </g>]]jO[#jO+1]="</g>"end;return jO end;local function lT(ff)return bG(fL(ff*3.6,0)+0.5).." km/h"end;local function lU(gm)local go=bf;if gm~=nil and type(gm)=="number"then if gm==0 then return"None"end;go=cN[gm].name end;if go==nil then go=fW.name end;if go==nil then go="None"end;return go end;local function lV(jO)local lW=cm.routeWP(true)if not lW or#lW==0 then return end;local hd=j4(750)local he=j5(360)if a_ or bm then jO[#jO+1]=gC(hd,he,"REMAINING ROUTE","pdim txtstart size20")else jO[#jO+1]=gC(hd,he,"LOADED ROUTE","pdim txtstart size20")end;for dz,J in pairs(lW)do he=he+20;jO[#jO+1]=gC(hd,he,dz..". "..lW[dz],"pdim txtstart size20")end end;local function lX(jO)local hd=av+10;local he=aw+20;local lY={}local lZ={"Alt-4: AutoTakeoff to Target"}local l_={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m0={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local m1={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lY,"--------------DYNAMIC-----------------")if c7 then if c6~=-1 then iq(lY,lZ)if b_ and j3 and b_.name==j3.name then table.insert(lY,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aW then if antigrav then if cJ then table.insert(lY,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lY,"Turn on AGG to takeoff to AGG Height")end end;if aW then table.insert(lY,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lY,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lY,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bi then table.insert(lY,"G: Takeoff to hover height, raise gear")else table.insert(lY,"G: Lowergear and Land")end else iq(lY,l_)table.insert(lY,"G: Begin BrakeLanding or Land")end;if b5 then table.insert(lY,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iq(lY,m0)if shield_1 then table.insert(lY,"Alt-Shift-6: Vent shields")if not F then table.insert(lY,"Alt-Shift-7: Toggle shield off/on")end end end;if fW~=nil then table.insert(lY,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lY,"Alt-9: Activate Gyroscope")end;if aS~="none"or aR~="none"or aT~="none"then table.insert(lY,"Alt-Shift-9: Cycles engines with Extra tags")end;if b1 then table.insert(lY,"Alt-Spacebar/C will raise/lower target height")table.insert(lY,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c7 then table.insert(lY,"LALT+Mousewheel will lower/raise speed limit")end;iq(lY,m1)for J=1,#lY do he=he+12;jO[#jO+1]=gC(hd,he,lY[J],"pdim txtbig txtstart")end end;local function m2(jO)local m3=av;local m4=aw;local m5=au;local m6=4;local m7=15;local hd=0;local he=0;local m8,m9,ma,mb;local mc;local function md(type)local gy,bI,ff,me,jI,mf;if type=="Periapsis"then gy=mc.periapsis.altitude;bI=mc.timeToPeriapsis;ff=mc.periapsis.speed;jI="txtend"me=12;mf=math.min(hd,m3+m5-j3.radius/ma-m6*2)else gy=mc.apoapsis.altitude;bI=mc.timeToApoapsis;ff=mc.apoapsis.speed;me=-12;jI="txtstart"mf=hd end;if cE<1 then bI=0 end;jO[#jO+1]=d8([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mf+me,he-5,hd,he-5)jO[#jO+1]=d8([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mf-me*4,he+2,hd,he+2)jO[#jO+1]=gC(mf,he,type,jI)hd=mf-me*2;he=he+m7;local lo=is(gy)jO[#jO+1]=gC(hd,he,lo,jI)he=he+m7;jO[#jO+1]=gC(hd,he,it(bI),jI)he=he+m7;jO[#jO+1]=gC(hd,he,lT(ff),jI)end;local mg=m5*1.5;if bD=="INFO"then mg=25*9 end;if bD~="HIDE"then jO[#jO+1]=[[<g class="pbright txtorb txtmid">]]jO[#jO+1]=d8('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m5*2,mg,m3,m4)jO[#jO+1]=d8([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m5*2,mg,m3,m4)end;local mh=m5*1.5;local mi=m5*2;local mj=mh/2;local mk=m5;local ml=m3+mk;local mm=m4+mj;local mn=m3+mi;local mo=m4+mh;if bD=="ORBIT"then m4=m4+m6;m8=m5/2;mb=0;mc={}mc.periapsis={}mc.apoapsis={}if fj~=nil then if fj.periapsis~=nil then mc.periapsis.altitude=fj.periapsis.altitude;mc.periapsis.speed=fj.periapsis.speed end;if fj.apoapsis~=nil then mc.apoapsis.altitude=fj.apoapsis.altitude;mc.apoapsis.speed=fj.apoapsis.speed end;mc.period=fj.period;mc.eccentricity=fj.eccentricity;mc.timeToApoapsis=fj.timeToApoapsis;mc.timeToPeriapsis=fj.timeToPeriapsis;mc.eccentricAnomaly=fj.eccentricAnomaly;mc.trueAnomaly=fj.trueAnomaly end;if mc.periapsis==nil then mc.periapsis={}mc.periapsis.altitude=-j3.radius;mc.periapsis.speed=Z end;if mc.eccentricity==nil then mc.eccentricity=1 end;if mc.apoapsis==nil then mc.apoapsis={}mc.apoapsis.altitude=c9;mc.apoapsis.speed=0 end;if cE<1 then mc.apoapsis.altitude=c9;mc.apoapsis.speed=0 end;if mc.apoapsis.altitude then ma=(mc.apoapsis.altitude+mc.periapsis.altitude+j3.radius*2)/(m8*2)m9=(j3.radius+mc.apoapsis.altitude)/ma*(1-mc.eccentricity)mb=m8-mc.periapsis.altitude/ma-j3.radius/ma;local mp=math.pi;if mc.period~=nil and mc.period>0 and mc.timeToApoapsis~=nil then mp=mc.eccentricAnomaly;if mc.timeToPeriapsis<mc.timeToApoapsis then mp=2*math.pi-mp end end;if cE<1 or mp~=mp then mp=math.pi end;local mq=-m8*math.cos(mp)+m3+mk+m6;local mr=m9*math.sin(mp)+m4+mj+m6;local ms=""jO[#jO+1]='<g clip-path="url(#orbitRect)">'jO[#jO+1]=d8([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ms,m3+m5+m6,m4+m5*1.5/2+m6,m8,m9)if m9<1 then jO[#jO+1]=d8([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m3+m5+m6-mb,m4+m5*1.5/2+m6,mq,mr)end;jO[#jO+1]=d8('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m3+m5+m6-mb,m4+m5*1.5/2+m6,(j3.radius+j3.noAtmosphericDensityAltitude)/ma)jO[#jO+1]=d8('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m3+m5+m6-mb,m4+m5*1.5/2+m6,(j3.radius+j3.noAtmosphericDensityAltitude)/ma)jO[#jO+1]=d8([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m3+m5+m6,m4+m5*1.5/2+m6,m8,m9)jO[#jO+1]=d8('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m3+m5+m6-mb,m4+m5*1.5/2+m6,j3.radius/ma)jO[#jO+1]='</g>'local mt=math.floor(j3.radius/ma+0.5)hd=m3+m5+m6*4+m8;he=m4+m5*1.5/2+5+m6;if mc.apoapsis~=nil and mc.apoapsis.speed<Z then md("Apoapsis")end;he=m4+m5*1.5/2+5+m6;hd=m3+m5-m6*2-m8;if mc.periapsis~=nil and mc.periapsis.speed<Z and mc.periapsis.altitude>0 then md("Periapsis")end;jO[#jO+1]=gC(m3+m5+m6,m4+20+m6,j3.name,"txtorbbig")jO[#jO+1]=d8('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mq,mr)jO[#jO+1]=[[</g>]]return jO else jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mu=""local mv=1.2*(mw-mx)/(m5*2)local my=1.4*(mz-mA)/(m5*1.5)for dz,dk in pairs(e[0])do if dk.center then local hd=m3+m5+dk.center.x/mv;local he=m4+m5*1.5/2+dk.center.y/my;mu=mu..'<circle cx="'..hd..'" cy="'..he..'" r="'..dk.radius/mv*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dk.name,"Moon")and not string.match(dk.name,"Sanctuary")and not string.match(dk.name,"Space")then mu=mu.."<text x='"..hd.."' y='"..he+dk.radius/mv*30+20 .."' font-size='12' fill="..iP.." text-anchor='middle' font-family='Montserrat'>"..dk.name.."</text>"end end end;local fl=vec3(b.getConstructWorldPos())local hd=m3+m5+fl.x/mv;local he=m4+m5*1.5/2+fl.y/my;mu=mu..'<circle cx="'..hd..'" cy="'..he..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mu=mu.."<text x='"..hd.."' y='"..he-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iB=mv;iC=my;local mB=fl+cD*1000000;local mC=m3+m5+mB.x/mv;local jz=m4+m5*1.5/2+mB.y/my;mu=mu..'<line x1="'..hd..'" y1="'..he..'" x2="'..mC..'" y2="'..jz..'" stroke="purple" stroke-width="1"/>'jO[#jO+1]=mu;jO[#jO+1]='</g>'end elseif bD=="INFO"then jO=ck.DrawOdometer(jO,iR,bj,iS)elseif bD=="HELP"then jO=lX(jO)elseif bD=="SCOPE"then jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mD=cZ;if c8>0 then table.sort(cY,function(ep,eq)local er,es=ep.center,eq.center;return(er.x-cH.x)^2+(er.y-cH.y)^2+(er.z-cH.z)^2<(es.x-cH.x)^2+(es.y-cH.y)^2+(es.z-cH.z)^2 end)end;local gK={}local mE={}local mF=120;local mG=nil;local mH=nil;for J,dk in ipairs(cY)do local gJ=dk.center-cH;local mI=gJ:len()local mJ=gJ:normalize()local mK=gJ:cross(cA):normalize()local mL=math.acos(mK:dot(cB))if mL~=mL then mL=0 end;if mK:cross(cB):dot(cA)<0 then mL=-mL end;local mM=gJ:project_on_plane(cA):len()local mN=math.sin(mL)*math.asin(mM/mI)*constants.rad2deg;local mO=math.cos(mL)*math.asin(mM/mI)*constants.rad2deg;if mJ:dot(cA)<0 then mO=90*math.cos(mL)+90*math.cos(mL)-mO;mN=90*math.sin(mL)+90*math.sin(mL)-mN end;local hd=ml+mN/mD*mh;local he=mm+mO/mD*mh;local mP=(hd-ml)*(hd-ml)+(he-mm)*(he-mm)local mQ=math.asin((dk.radius+dk.surfaceMaxAltitude)/mI)*constants.rad2deg;if mQ~=mQ then mQ=mD end;local hJ=mQ/mD*mh;local mR=math.asin(dk.atmosphereRadius/mI)*constants.rad2deg;if mR~=mR then mR=mQ end;local mS=mR/mD*mh;local c2=is(mI,1)local mT=dk.name;local mU=false;if he>m4 then if he>mo then if he-mS<=mo then mU=true end else mU=true end else if he+mS>=m4 then mU=true end end;local mV=false;local mW=hd;if dk.systemId==0 then mW=hd+mF else mW=hd-mF end;if mW+mF>m3 then if mW+mF>mn then if mW-mS-mF<=mn then mV=true end else mV=true end else if mW+mS+mF>=m3 then mV=true end end;local mX={}mX.x=hd;mX.y=he;mX.planet=dk;mX.atmoSize=mS;if not mG or mP<mG then mG=mP;mH=mX end;if mV and mU then local mY=math.max(mS,5)if mP<mY*mY then mT=mT.." - "..c2 end;mX.size=hJ;mX.i=J;mX.displayString=mT;mX.distance=c2;mX.visible=true;mE[#mE+1]=mX else mX.visible=false end end;local mZ=false;table.sort(mE,function(er,es)return er.y<es.y end)for dz,fo in ipairs(mE)do local dk,hJ,J,mS,hd,he,mT,c2=fo.planet,fo.size,fo.i,fo.atmoSize,fo.x,fo.y,fo.displayString,fo.distance;local mf,m_,n0,n1;local n2=15;local jI="pdim"if dk.systemId~=0 then n0=j4(string.len(mT)*5)n2=-(15+n0)n1=j5(10)jI="pdimfill"else n0=j4(string.len(mT)*9)n1=j5(15)end;if hJ*2>n0 then mf=d9(hd,m3+n0/2,mn-n0/2)m_=d9(he,m4+n1,mo-5)mf=d9(mf,hd-hJ+n0/2,hd+hJ-n0/2)m_=d9(m_,he-hJ+n1,he+hJ)else mf=hd+n2;m_=he end;for n3,fo in pairs(gK)do local n4=fo.textPositions;local n5=n4.y-m_;if n3~=J and eO(n5)<n4.height and n4.x+n4.width>mf and n4.x<mf+n0 then if hJ>n0 then m_=d9(m_+n1,m4+15,mo-5)else m_=n4.y+n4.height+1 end end end;local n6=mT~=dk.name or mf<=ml and mf+n0>=ml and m_-n1<=mm and m_>=mm;fo.hovered=n6;local n7=1;if n6 then n7=2;if hJ*2<n0 then n7=10 end;if mT==dk.name then mT=mT.." - "..c2 end;jI="pbright"if dk.systemId~=0 then n0=j4(string.len(mT)*5)n2=-(15+n0)else n0=j4(string.len(mT)*7)end;if hJ*2>n0 then mf=d9(hd,m3+n0/2,mn-n0/2)mf=d9(mf,hd-hJ+n0/2,hd+hJ-n0/2)else mf=hd+n2 end end;gK[J]={}gK[J].textPositions={}gK[J].textPositions.y=m_;gK[J].textPositions.x=mf;gK[J].textPositions.width=n0;gK[J].textPositions.height=n1;gK[J].output=""if hJ*2>n0 then jI=jI.." txtmid"else jI=jI.." txtstart"end;if mS-hJ>2 then gK[J].output=d8('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hd,he,mS,iQ,0.1*n7)end;gK[J].output=gK[J].output..d8('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hd,he,hJ,iQ,0.2*n7)if dk.systemId==0 then gK[J].output=gK[J].output..d8([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mf,m_,iP,jI,mT)if hJ*2<=n0 then gK[J].output=gK[J].output..d8("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mf+n0,m_+2,mf,m_+2,hd,he)end else gK[J].output=gK[J].output..d8([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mf,m_,iQ,jI,mT)if hJ*2<=n0 then gK[J].output=gK[J].output..d8("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mf,m_+2,mf+n0,m_+2,hd,he)end end end;for dz=#cY,1,-1 do if gK[dz]then jO[#jO+1]=gK[dz].output end end;if mH~=nil and cZ<90 and not mH.hovered then local n8=mH.planet.atmosphereRadius/mH.atmoSize;local n9=db(mG)*n8;local na=is(n9,1)local n0=j4(math.max(string.len(na)*7,string.len(mH.planet.name)*7))local n1=j5(12)local mf=d9(mH.x+(ml-mH.x)/2,m3+n0/2,mn-n0/2)local m_=d9(mH.y+(mm-mH.y)/2,m4+n1*2,mo-5)jO[#jO+1]=d8("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mH.x,mH.y,ml,mm)jO[#jO+1]=d8([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mf,m_,"white",na)if not mH.visible then jO[#jO+1]=d8([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mf,m_-n1,"white",mH.planet.name)end end;if cE>1 then local gJ=cD;local mJ=gJ:normalize()local mM=gJ:project_on_plane(cA):len()local mK=gJ:cross(cA):normalize()local mL=math.acos(mK:dot(cB))if mL~=mL then mL=0 end;if mK:cross(cB):dot(cA)<0 then mL=-mL end;local mN=math.sin(mL)*math.asin(mM/gJ:len())*constants.rad2deg;local mO=math.cos(mL)*math.asin(mM/gJ:len())*constants.rad2deg;if mJ:dot(cA)<0 then mO=90*math.cos(mL)+90*math.cos(mL)-mO;mN=90*math.sin(mL)+90*math.sin(mL)-mN end;local hd=ml+mN/mD*mh;local he=mm+mO/mD*mh;local kJ=14;local kK=kJ/2;local kN=[[<circle
                                    cx="]]..hd..[["
                                    cy="]]..he..[["
                                    r="]]..kK/kJ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hd..[["
                                    cy="]]..he..[["
                                    r="]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hd-kJ..[[,]]..he..[[ h ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hd+kK..[[,]]..he..[[ h ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hd..[[,]]..he-kJ..[[ v ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jO[#jO+1]=kN end;jO[#jO+1]=d8("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",ml,mm-10,ml,mm+10)jO[#jO+1]=d8("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",ml-10,mm,ml+10,mm)jO[#jO+1]='</g>'else return jO end end;local function nb(nc,nd)local ne;local nf=(nd-nc):normalize()local fm=(cH-nc):dot(nf)/nf:dot(nf)if fm<=0. then return(cH-nc):len()elseif fm>=(nd-nc):len()then return(cH-nd):len()end;local ng=nc+fm*nf;ne=(ng-cH):len()return ne end;local function nh()local ne;local ni=nil;local nj=nil;local nk=nil;for dz,nl in pairs(e[0])do if nl.hasAtmosphere then local c2=nb(j3.center,nl.center)if ni==nil or c2<ni then nj=nl;ni=c2;nk=j3 end;if b_ and b_.hasAtmosphere and b_.name~=j3.name then local eE=nb(b_.center,nl.center)if eE<ni then nj=nl;ni=eE;nk=b_ end end end end;local nm=j4(1770)local nn=j5(330)if ni then local no="txttick "local np=500000;if ni<nj.radius+np or ni<nk.radius+np then if cO then no="txttick red "else no="txttick orange "end end;ne=is(ni,2)iG=gC(nm,nn,"Pipe ("..nk.name.."--"..nj.name.."): "..ne,no.."pbright txtmid")end end;local function nq(hd,he,nr,ns,kW)local nt={x=hd,y=he,width=nr,height=ns,label=kW}iA[kW]=nt;return nt end;local function nu(nv,nw,nr,ns,hd,he,nx,ny,nz,nA,jI)local nt={enableName=nv,disableName=nw,width=nr,height=ns,x=hd,y=he,toggleVar=nx,toggleFunction=ny,drawCondition=nz,hovered=false,class=jI}if nA then table.insert(iz,nt)else table.insert(iy,nt)end;return nt end;local function nB(nC)if not iE then nD=false;nE=false;nF=false;w=true;return elseif nC=="handling"then nD=not nD;nE=false;nF=false elseif nC=="hud"then nE=not nE;nD=false;nF=false elseif nC=="physics"then nF=not nF;nD=false;nE=false end;if nF or nE or nD then iF=ir(nC)w=false else iF="none"w=true end end;local function nG()iE=not iE;if iE then ix=iz;bV="Hold SHIFT to see Settings"c_=w else ix=iy;bV="Hold SHIFT to see Control Buttons"nB()w=c_ end end;local function nH()local function nI(dk,dz)dk.set(not dk.get())if dk.get()then bV=dz.." set to true"else bV=dz.." set to false"end;if dz=="showHud"then c_=dk.get()elseif dz=="BrakeToggleDefault"then aV=j end end;local nJ=50;local nK=340;local hd=500;local he=cd/2-400;local nL=0;for dz,dk in pairs(ir("boolean"))do if type(dk.get())=="boolean"then nu(dz,dz,nK,nJ,hd,he,function()return dk.get()end,function()nI(dk,dz)end,function()return true end,true)he=he+nJ+20;if nL==9 then hd=hd+nK+20;he=cd/2-400;nL=0 else nL=nL+1 end end end;nu("Control View","Control View",nK,nJ,10,cd/2-500,function()return true end,nG,function()return true end,true)nu("View Handling Settings",'Hide Handling Settings',nK,nJ,10,cd/2-(500-nJ),function()return nD end,function()nB("handling")end,function()return true end,true)nu("View Hud Settings",'Hide Hud Settings',nK,nJ,10,cd/2-(500-nJ*2),function()return nE end,function()nB("hud")end,function()return true end,true)nu("View Physics Settings",'Hide Physics Settings',nK,nJ,10,cd/2-(500-nJ*3),function()return nF end,function()nB("physics")end,function()return true end,true)end;local function nM()local function gn()local fN=cH;local go=j3.name..". "..#bl;if radar_1 then go=cn.GetClosestName(go)end;return cl.AddNewLocation(go,fN,false,true)end;local function nN()b0=not b0 end;local function nO(nP)if nP==1 then aZ=not aZ;aY=false else aY=not aY;aZ=false end;a_=false;b1=false;bT=false;b2=false;bp=nil;b4=false;b3=false end;local function nQ(nR,nS)cl.UpdatePosition(nil,nR,nS)end;local function gi()cl.ClearCurrentPosition()end;local function nT(gm)local lW=cm.routeWP(true)if lW and#lW>0 then return"Engage Route: "..lW[1]end;return"Engage Autopilot: "..lU(gm)end;local function nU(gm)local lW=cm.routeWP(true)if lW and#lW>0 then return"Next Route Point: "..lW[1]end;return"Disable Autopilot: "..lU(gm)end;local function nV()if im()==1 then bT=not bT;if bT then a_=false;aY=false;aZ=false;b1=false;b4=false;b2=false;b3=false;nW=bi;bi=false;d.control.retractLandingGears()io:setTargetGroundAltitude(W)fK("folOn","F")else fK("folOff","F")aX="Follow Off"cs=p;bi=nW;if bi then d.control.extendLandingGears()io:setTargetGroundAltitude(X)end end else bV="Follow Mode only works with Remote controller"bT=false end end;local nJ=50;local nK=260;local nX=j4(30)local nY=av+au*2+2;local nZ=aw+1;nu("+","+",nX,nX,nY,nZ+nX+1,function()return false end,function()cZ=cZ/8 end,function()return bD=="SCOPE"end,nil,"ZoomButton")nu("-","-",nX,nX,nY,nZ,function()return false end,function()cZ=math.min(cZ*8,90)end,function()return bD=="SCOPE"end,nil,"ZoomButton")nu("0","0",nX,nX,nY,nZ+nX*2+2,function()return false end,function()cZ=90 end,function()return bD=="SCOPE"and cZ~=90 end,nil,"ZoomButton")local n_=nu("Enable Brake Toggle","Disable Brake Toggle",nK,nJ,cc/2-nK/2,cd/2+350,function()return aV end,function()aV=not aV;if aV then bV="Brakes in Toggle Mode"else bV="Brakes in Default Mode"end end)nu("Align Prograde","Disable Prograde",nK,nJ,cc/2-nK/2-50-n_.width,cd/2-nJ+380,function()return aZ end,function()nO(1)end)nu("Align Retrograde","Disable Retrograde",nK,nJ,cc/2-nK/2+n_.width+50,cd/2-nJ+380,function()return aY end,nO,function()return c8==0 end)o0=nu(nT,nU,600,60,cc/2-600/2,cd/2-60/2-330,function()return a_ or bm or c4 or bv end,function()end)local J;local function o1(o2)local gm=cV+o2;if gm>#cN then gm=gm-#cN-1 end;if gm<0 then gm=#cN+gm end;return gm end;o3={}for J=0,10 do local o4=nu(function(es)local gm=o1(es.apExtraIndex)if a_ or bm or c4 or bv then return"Redirect: "..lU(gm)end;return nT(gm)end,function(es)local gm=o1(es.apExtraIndex)return nU(gm)end,600,60,cc/2-600/2,cd/2-60/2-330+60*J,function(es)local gm=o1(es.apExtraIndex)return gm==bh and(a_ or bm or c4 or bv)end,function(es)local gm=o1(es.apExtraIndex)local o5=bh==gm;bh=gm;cl.UpdateAutopilotTarget()cm.ToggleAutopilot()if not o5 and not(a_ or bm or c4 or bv)then cm.ToggleAutopilot()end end,function()return cU and(#cm.routeWP(true)==0 or J==0)end)o4.apExtraIndex=J;o3[J]=o4 end;nu("Save Position","Save Position",200,o0.height,o0.x+o0.width+30,o0.y,function()return false end,gn,function()return bh==0 or fW==nil end)nu("Update Position","Update Position",200,o0.height,o0.x+o0.width+30,o0.y,function()return false end,function()nQ(nil)end,function()return bh>0 and fW~=nil end)nu("Save Heading","Clear Heading",200,o0.height,o0.x+o0.width+30,o0.y+o0.height+20,function()return fW.heading~=nil end,function()if fW.heading~=nil then nQ(false)else nQ(true)end end,function()return bh>0 and fW~=nil end)nu("Save AGG Alt","Clear AGG Alt",200,o0.height,o0.x+o0.width+30,o0.y+o0.height*2+40,function()return fW.agg~=nil end,function()if fW.agg~=nil then nQ(nil,false)else nQ(nil,true)end end,function()return bh>0 and fW~=nil and antigrav end)nu("Clear Position","Clear Position",200,o0.height,o0.x-200-30,o0.y,function()return true end,gi,function()return bh>0 and fW~=nil end)nu("Save Route","Save Route",200,o0.height,o0.x-200-30,o0.y+o0.height*2+40,function()return false end,function()cm.routeWP(false,false,2)end,function()return#cm.routeWP(true)>0 end)nu("Load Route","Clear Route",200,o0.height,o0.x-200-30,o0.y+o0.height+20,function()return#cm.routeWP(true)>0 end,function()if#cm.routeWP(true)>0 then cm.routeWP(false,true)elseif a_ or bm then bV="Disable Autopilot before loading route"return else cm.routeWP(false,false,1)end end,function()return true end)nJ=60;nK=300;local hd=0;local he=cd/2-150;nu("Enable Check Damage","Disable Check Damage",nK,nJ,hd,he-nJ-20,function()return s end,function()s=not s end)nu("View Settings","View Settings",nK,nJ,hd,he,function()return true end,nG)he=he+nJ+20;nu("Enable Turn and Burn","Disable Turn and Burn",nK,nJ,hd,he,function()return b0 end,nN)hd=10;he=cd/2-300;nu("Horizontal Takeoff Mode","Vertical Takeoff Mode",nK,nJ,hd+nK+20,he,function()return aW end,function()aW=not aW;if aW then bV="Vertical Takeoff Mode"else bV="Horizontal Takeoff Mode"end end,function()return cI end)he=he+nJ+20;nu("Engage Orbiting","Cancel Orbiting",nK,nJ,hd+nK+20,he,function()return bv end,cm.ToggleIntoOrbit,function()return c8==0 and cR end)he=cd/2-150;nu("Glide Re-Entry","Cancel Glide Re-Entry",nK,nJ,hd+nK+20,he,function()return b4 end,function()c3=1;nO(1)end,function()return j3.hasAtmosphere and not c7 end)he=he+nJ+20;nu("Parachute Re-Entry","Cancel Parachute Re-Entry",nK,nJ,hd+nK+20,he,function()return b4 end,function()c3=2;nO(1)end,function()return j3.hasAtmosphere and not c7 end)he=he+nJ+20;nu("Engage Follow Mode","Disable Follow Mode",nK,nJ,hd,he,function()return bT end,nV,function()return im()==1 end)nu("Enable Repair Arrows","Disable Repair Arrows",nK,nJ,hd+nK+20,he,function()return iV end,function()iV=not iV;if iV then bV="Repair Arrows Enabled"else bV="Repair Arrows Diabled"end end,function()return im()==1 end)he=he+nJ+20;if not q then nu("Enable AGG","Disable AGG",nK,nJ,hd,he,function()return cJ end,cm.ToggleAntigrav,function()return antigrav~=nil end)end;nu(function()return d8("Switch IPH Mode - Current: %s",bw)end,function()return d8("IPH Mode: %s",bw)end,nK*2,nJ,hd,he,function()return false end,function()if bw=="All"then bw="Custom Only"elseif bw=="Custom Only"then bw="No Moons"else bw="All"end;bV="IPH Mode: "..bw end)he=he+nJ+20;nu(function()return d8("Toggle Control Scheme - Current: %s",g)end,function()return d8("Control Scheme: %s",g)end,nK*2,nJ,hd,he,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bV="New Control Scheme: "..g end)local o6=j5(20)local o4=nq(0,0,j4(70),o6,"HELP")o4=nq(o4.x+o4.width,o4.y,j4(80),o6,"INFO")o4=nq(o4.x+o4.width,o4.y,j4(70),o6,"ORBIT")o4=nq(o4.x+o4.width,o4.y,j4(70),o6,"SCOPE")nq(o4.x+o4.width,o4.y,j4(70),o6,"HIDE")end;local o7={}local o8=nil;function o7.HUDPrologue(jO)cO,cP=j1(cH)if not cO then iM=ae;iN=af;iO=ag else iM=ab;iN=ac;iO=ad end;iP=[[rgb(]]..bG(iM+0.6)..","..bG(iN+0.6)..","..bG(iO+0.6)..[[)]]iQ=[[rgb(]]..bG(iM*0.8+0.5)..","..bG(iN*0.8+0.5)..","..bG(iO*0.8+0.5)..[[)]]local o9=iP;local oa=iQ;local ob=[[rgb(]]..bG(iM*0.4+0.5)..","..bG(iN*0.4+0.5)..","..bG(iO*0.4+0.5)..[[)]]local oc=iP;local od=iQ;local oe=ob;if j6()and not m then o9=[[rgb(]]..bG(iM*0.5+0.5)..","..bG(iN*0.5+0.5)..","..bG(iO*0.5+0.5)..[[)]]oa=[[rgb(]]..bG(iM*0.3+0.5)..","..bG(iN*0.3+0.5)..","..bG(iO*0.2+0.5)..[[)]]ob=[[rgb(]]..bG(iM*0.2+0.5)..","..bG(iN*0.2+0.5)..","..bG(iO*0.2+0.5)..[[)]]end;local lJ=j4;local lK=j5;jO[#jO+1]=d8([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o9,o9,o9,oc,oc,oa,oa,od,od,oa,o9,ob,od,o9,o9,ob,ob,oe,ob,cc,cd,oa,oa,oa,oa,oa,oc,oa,od,oe,od,od,oe)if not o8 then o8=d8([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lJ(630),lK(0),lJ(675),lK(45),lJ(960),lK(55),lJ(1245),lK(45),lJ(1290),lK(0),lJ(1000),lK(105),lJ(1040),lK(59),lJ(1250),lK(51),lJ(1300),lK(0),lJ(1920),lK(0),lJ(1920),lK(20),lJ(1400),lK(20),lJ(1300),lK(105),lJ(920),lK(105),lJ(880),lK(59),lJ(670),lK(51),lJ(620),lK(0),lJ(0),lK(0),lJ(0),lK(20),lJ(520),lK(20),lJ(620),lK(105),lJ(890),lK(59),lJ(960),lK(62),lJ(1030),lK(59),lJ(985),lK(112),lJ(1150),lK(112),lJ(1100),lK(152),lJ(820),lK(152),lJ(780),lK(112),lJ(935),lK(112),lJ(890),lK(59),lJ(960),lK(62),lJ(1030),lK(59),lJ(985),lK(112),lJ(1150),lK(112),lJ(1100),lK(152),lJ(820),lK(152),lJ(780),lK(112),lJ(935),lK(112))end;if w and H then jO[#jO+1]=o8 end;return jO end;function o7.DrawVerticalSpeed(jO,dT)jN(jO,dT)end;function o7.UpdateHud(jO)local kC=cL;local of=cM;local jV=of;local ka=kC;local kU=bG(c.getThrottle())local kZ=cE*3.6;local kV=c.getAxisCommandValue(0)local og=j4(1770)local oh=j5(310)if t and cK then kV=bJ;kU=bJ*100 end;local j8=j7()local jW="ROLL"if kU==nil then kU=0 end;if not cR then if cE>5 then kC=kB(cC)of=kD(cC)else kC=0;of=0 end;jW="YAW"end;if cP>50000 and not c7 then local oi;oi=is(cP)jO[#jO+1]=gC(og,oh,"PvP Boundary: "..oi,"pbright txtbig txtmid")end;jO[#jO+1]=iT;jO[#jO+1]=iK;jO[#jO+1]=h_;if iG~=""then jO[#jO+1]=iG end;if j9~=""then jO[#jO+1]=j9 end;if ja~=""then jO[#jO+1]=ja end;jN(jO,c9)if im()==0 or l then if cR then jU(jO,ah,ai,jV,jW,cR)else jU(jO,ah,ai,of,jW,cR)end;if not j6()or m then if cR then jU(jO,ah,ai,jV,jW,cR)k9(jO,ka,jV,ah,ai,cR,bG(kD(cC)),cE)else jU(jO,ah,ai,of,jW,cR)k9(jO,kC,of,ah,ai,cR,bG(of),cE)end;kg(jO,c9,cR)kE(jO,cC,cE,ah,ai)end end;kT(jO,j8,kU,kV)kY(jO,kZ)l1(jO)m2(jO)if not iE and bU then lV(jO)end;return jO end;function o7.HUDEpilogue(jO)jO[#jO+1]="</svg>"return jO end;function o7.ExtraData(jO)local oj=j4(1240)local ok=j5(55)local ol=ok+10;local om;local lJ=j4;local lK=j5;local on=0;local j8=j7()if aW then j8=j8 .."-VERTICAL"end;if E and not b3 and not b2 and cE>20 then j8=j8 .."-COLLISION ON"end;if by~="Off"then j8="("..by..")-"..j8 end;if b0 then j8="TB-"..j8 end;if not bx then j8=j8 .."-DeCoupled"end;local oo=lK(99)local op=lK(80)local oq=lK(85)local os=lK(31)local ot=0;local ou=0;local ov=ca>1000000 and fL(ca/1000000,2).."kT"or fL(ca/1000,2).."T"if c7 then on=bq else on=bo end;local ow,ox=ci.computeDistanceAndTime(cE,0,ca,0,0,on)if ow<0 then ow=0 end;on=fL(on/(ca*iw),2).."g"local oy=d:maxForceForward()om=b.g()if om>0.1 then ou=ca*om;ou=fL(ou/(ca*iw),2).."g"ot=0.5*oy/om;ot=ot>1000000 and fL(ot/1000000,2).."kT"or fL(ot/1000,2).."T"end;oy=fL(oy/(ca*iw),2).."g"local oz=vec3(b.getWorldAcceleration()):len()/9.80665;om=b.g()jO[#jO+1]=[[<g class="dim txt txtend size14">]]if im()==1 and not l then oj=j4(1120)ok=j5(55)ol=ok+10 elseif c7 and H then local oA=j4(770)jO[#jO+1]=gC(lJ(895),oo,"ATMO","")jO[#jO+1]=d8([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lJ(895),oq,lJ(-80))jO[#jO+1]=gC(lJ(815),op,d8("%.1f%%",c8*100),"txtstart size20")end;if H then jO[#jO+1]=gC(lJ(1025),oo,"GRAVITY","txtstart")jO[#jO+1]=d8([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(1025),oq,lJ(80))jO[#jO+1]=gC(lJ(1105),op,d8("%.2fg",om/9.80665),"size20")jO[#jO+1]=gC(lJ(1125),oo,"ACCEL","txtstart")jO[#jO+1]=d8([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(1125),oq,lJ(80))jO[#jO+1]=gC(lJ(1205),op,d8("%.2fg",oz),"size20")jO[#jO+1]=gC(lJ(695),oo,"BRK TIME","")jO[#jO+1]=d8([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(695),oq,lJ(-80))jO[#jO+1]=gC(lJ(615),op,d8("%s",it(ox)),"txtstart size20")jO[#jO+1]=gC(lJ(635),lK(45),"TRIP","")jO[#jO+1]=d8([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(635),lK(31),lJ(-90))if lD then jO[#jO+1]=gC(lJ(545),lK(26),d8("%s",it(lD)),"txtstart size20")end;jO[#jO+1]=gC(lJ(795),oo,"BRK DIST","")jO[#jO+1]=d8([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(795),oq,lJ(-80))jO[#jO+1]=gC(lJ(715),op,d8("%s",is(ow)),"txtstart size20")jO[#jO+1]=gC(lJ(1285),lK(45),"MASS","txtstart")jO[#jO+1]=d8([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(1285),lK(31),lJ(90))jO[#jO+1]=gC(lJ(1375),lK(26),d8("%s",ov),"size20")jO[#jO+1]=gC(lJ(1220),oo,"THRUST","txtstart")jO[#jO+1]=d8([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(1220),oq,lJ(80))jO[#jO+1]=gC(lJ(1300),op,d8("%s",oy),"size20")jO[#jO+1]=gC(j4(960),j5(175),j8,"pbright txtbig txtmid size20")end;jO[#jO+1]="</g>"end;local oB=1-(a4*0.05+a5*0.05)function o7.FuelUsed(oC)local oD;if oC=="atmofueltank"then oD=d8("Atmo Fuel Used: %.1f L",jq[oC]/(4*oB))elseif oC=="spacefueltank"then oD=d8("Space Fuel Used: %.1f L",jq[oC]/(6*oB))else oD=d8("Rocket Fuel Used: %.1f L",jq[oC]/(0.8*oB))end;return oD end;function o7.DrawOdometer(jO,iR,bj,iS)if bD~="INFO"then return jO end;local om;local ot=0;local ou=0;local on=0;local ov=ca>1000000 and fL(ca/1000000,2).." kTons"or fL(ca/1000,2).." Tons"if c7 then on=bq else on=bo end;local ow,ox=ci.computeDistanceAndTime(cE,0,ca,0,0,on)on=fL(on/(ca*iw),2).." g"local oy=d:maxForceForward()om=b.g()if om>0.1 then ou=ca*om;ou=fL(ou/(ca*iw),2).." g"ot=0.5*oy/om;ot=ot>1000000 and fL(ot/1000000,2).." kTons"or fL(ot/1000,2).." Tons"end;oy=fL(oy/(ca*iw),2).." g"if im()==0 or l then local oE=j4(av+10)local oF=j5(aw+20)local oG=j4(av+10+au/1.25)local ns=25;jO[#jO+1]="<g class='txtstart size14 bright'>"jO[#jO+1]=gC(oE,oF,d8("BrkTime: %s",it(ox)))jO[#jO+1]=gC(oG,oF,d8("Trip: %.2f km",iR))jO[#jO+1]=gC(oE,oF+ns,d8("Lifetime: %.2f kSU",bj/200000))jO[#jO+1]=gC(oG,oF+ns,d8("BrkDist: %s",is(ow)))jO[#jO+1]=gC(oE,oF+ns*2,"Trip Time: "..it(iS))jO[#jO+1]=gC(oG,oF+ns*2,"Total Time: "..it(bk))jO[#jO+1]=gC(oE,oF+ns*3,d8("Mass: %s",ov))jO[#jO+1]=gC(oG,oF+ns*3,d8("Max Brake: %s",on))jO[#jO+1]=gC(oE,oF+ns*4,d8("Max Thrust: %s",oy))if om>0.1 then jO[#jO+1]=gC(oG,oF+ns*4,d8("Max Thrust Mass: %s",ot))jO[#jO+1]=gC(oE,oF+ns*5,d8("Req Thrust: %s",ou))else jO[#jO+1]=gC(oG,oF+ns*4,"Max Mass: n/a")jO[#jO+1]=gC(oE,oF+ns*5,"Req Thrust: n/a")end;jO[#jO+1]=gC(oG,oF+ns*5,ck.FuelUsed("atmofueltank"))jO[#jO+1]=gC(oE,oF+ns*6,ck.FuelUsed("spacefueltank"))jO[#jO+1]=gC(oG,oF+ns*6,ck.FuelUsed("rocketfueltank"))if cE>833 then local oH=ca/math.sqrt(1-(cE/8333.33)^2)local ov=oH>1000000 and fL(oH/1000000,2).." kTons"or fL(oH/1000,2).." Tons"jO[#jO+1]=gC(oG,oF+ns*7,d8("Rel. Mass: %s",ov))end end;jO[#jO+1]="</g></g>"return jO end;function o7.DrawWarnings(jO)return l1(jO)end;function o7.DisplayOrbitScreen(jO)return m2(jO)end;function o7.DisplayMessage(jO,lo)if lo~="empty"then local he=310;for lx in string.gmatch(lo,"([^\n]+)")do he=he+35;jO[#jO+1]=gC("50%",he,lx,"msg")end end;if bW~=0 then c.setTimer("msgTick",bW)bW=0 end end;function o7.DrawDeadZone(jO)jO[#jO+1]=d8([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],at)end;function o7.UpdatePipe()if c7 then iG=""return end;nh()end;function o7.DrawSettings(jO)local hd=j4(640)local he=j5(200)jO[#jO+1]=[[<g class="pbright txtvspd txtstart">]]local hH=0;for dz,dk in pairs(iF)do hH=hH+1;jO[#jO+1]=gC(hd,he,dz..": "..dk.get())he=he+20;if hH%12==0 then hd=hd+j4(350)he=j5(200)end end;jO[#jO+1]=gC(j4(640),j5(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jO[#jO+1]="</g>"return jO end;local hX=j4(1770)local hY=j5(350)local hW=j5(15)local hV=j4(1370)local i0,oI;function o7.DrawRadarInfo()h_=cn.GetRadarHud(hV,hW,hX,hY)end;function o7.DrawTanks()if ap~=0 and aq~=0 then j9=gC(ap,aq,"","txtstart pdim txtfuel")jr=aq;js(ap,"Atmospheric ","ATMO",ce,jo,jp)js(ap,"Space Fuel T","SPACE",cf,jm,jn)js(ap,"Rocket Fuel ","ROCKET",cg,jk,jl)end end;function o7.DrawShield()local i6=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local oJ=b.getPvPTimer()local oK=shield_1.getResistances()local oL="A: "..10+oK[1]*100 .."% / E: "..10+oK[2]*100 .."% / K:"..10+oK[3]*100 .."% / T: "..10+oK[4]*100 .."%"local hd,he=ar-60,as+30;local jG=bG(d6*2.55)local jH=d8("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""ja=gC(hd,he,"","txtmid pdim txtfuel")if d6<10 and i6~="Shield Disabled"then jI="red "end;oJ=oJ>0 and"   PvPTime: "..it(oJ)or""ja=ja..d8([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hd,he,jH,d6*2,hd,he,hd+2,he+10,d6,oJ)ja=ja..gC(hd,he-5,i6,jI.."txtstart pbright txtbig")ja=ja..gC(hd,he+30,oL,jI.."txtstart pbright txtsmall")end;function o7.hudtick()if not j3 then return end;local function oM(jO)local jK=bG(d9(c2/(cc/4)*255,0,255))jO[#jO+1]=d8("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c0,c1,bG(iM+0.5)+jK,bG(iN+0.5)-jK,bG(iO+0.5)-jK)end;local function oN()for dE,dk in pairs(ix)do if dk.hovered then if not dk.drawCondition or dk.drawCondition(dk)then dk.toggleFunction(dk)end;dk.hovered=false end end;for dE,dk in pairs(iA)do if dk.hovered then bD=dk.label;dk.hovered=false end end end;local function oO()local function oP(oQ,oR,hd,he,nr,ns)if oQ>=hd and oQ<=hd+nr and oR>=he and oR<=he+ns then return true else return false end end;local hd=c0+cc/2;local he=c1+cd/2;for dE,dk in pairs(ix)do dk.hovered=oP(hd,he,dk.x,dk.y,dk.width,dk.height)end;for dE,dk in pairs(iA)do dk.hovered=oP(hd,he,dk.x,dk.y,dk.width,dk.height)end;if cU then local n6=false;for dE,es in ipairs(o3)do if es.hovered then n6=true;break end end;if o0.hovered then n6=true end;cU=n6 else cU=o0.hovered;if not cU then cV=bh end end end;local function oS(jO)if not bD or bD==""then bD="HELP"end;if w then for dz,dk in pairs(iA)do local jI="dim brightstroke"local oT=0.2;if bD==dz then jI="pbright dimstroke"oT=0.6 end;local oU=""if dk.hovered then oT=0.8;oU=";stroke:white"end;jO[#jO+1]=d8([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dk.width,dk.height,dk.x,dk.y,jI,oT,oU)jO[#jO+1]=gC(dk.x+dk.width/2,dk.y+dk.height/2+5,dk.label,"txt txtmid pdim")end end end;local function oV(jO)local function oW(jO,oX,hover,hd,he,f8,oY,oZ,o_,p0,p1,o4)if type(p0)=="function"then p0=p0(o4)end;if type(p1)=="function"then p1=p1(o4)end;jO[#jO+1]=d8("<rect x='%f' y='%f' width='%f' height='%f' fill='",hd,he,f8,oY)if oX then jO[#jO+1]=d8("%s'",oZ)else jO[#jO+1]=o_ end;if hover then jO[#jO+1]=d8(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ab,ac,ad)else jO[#jO+1]=d8(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fL(ab*0.5,0),fL(ac*0.5,0),fL(ad*0.5,0))end;jO[#jO+1]=" rx='5'></rect>"jO[#jO+1]=d8("<text x='%f' y='%f' font-size='24' fill='",hd+f8/2,he+oY/2+5)if oX then jO[#jO+1]="black"else jO[#jO+1]="white"end;jO[#jO+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oX then jO[#jO+1]=d8("%s</text>",p0)else jO[#jO+1]=d8("%s</text>",p1)end end;local p2=d8("rgb(%d,%d,%d)'",fL(ab*0.1,0),fL(ac*0.1,0),fL(ad*0.1,0))local p3=d8("rgb(%d,%d,%d)",fL(ab*0.8,0),fL(ac*0.8,0),fL(ad*0.8,0))local p4=oW;for dE,dk in pairs(ix)do local nw=dk.disableName;local nv=dk.enableName;if type(nw)=="function"then nw=nw(dk)end;if type(nv)=="function"then nv=nv(dk)end;if not dk.drawCondition or dk.drawCondition(dk)then p4(jO,dk.toggleVar(dk),dk.hovered,dk.x,dk.y,dk.width,dk.height,p3,p2,nw,nv,dk)end end end;local p5=fL(cc/2,0)local p6=fL(cd/2,0)local jO={}ck.HUDPrologue(jO)if w then ck.UpdateHud(jO)else if A then ck.DrawVerticalSpeed(jO,c9)end;ck.DrawWarnings(jO)end;if iE and iF~="none"then ck.DrawSettings(jO)end;if radar_1 then ck.DrawRadarInfo()end;ck.HUDEpilogue(jO)jO[#jO+1]=d8([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cc,cd)if bV~="empty"then ck.DisplayMessage(jO,bV)end;if im()==0 and g=="virtual joystick"then if v then ck.DrawDeadZone(jO)end end;oS(jO)if ip()==0 then if im()==1 and bU then if not p7 then oO()oV(jO)end;if not cq and not cr then local p8=table.concat(jO,"")jO={}jO[#jO+1]=d8("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cc,cd)jO[#jO+1]=p8;jO[#jO+1]="</body>"cq=true;jO[#jO+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local p9=table.concat(jO,"")a.setScreen(p9)elseif cr then local p8=table.concat(jO,"")jO={}jO[#jO+1]=d8("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cc,cd)jO[#jO+1]=p8;jO[#jO+1]="</body>"end;if not cq then jO[#jO+1]=d8([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p5,p6,c0,c1)end else oN()end else if not bU and im()==0 then oN()if c2>at then if v then oM(jO)end end elseif bU and(not p7 or not i)then oO()oV(jO)end;jO[#jO+1]=d8([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p5,p6,c0,c1)end;jO[#jO+1]=[[</svg></body>]]p9=table.concat(jO,"")end;function o7.TenthTick()local function pa()local pb=a.createData;local pc=a.createWidget;pd=a.createWidgetPanel("Interplanetary Helper")pe=pc(pd,"value")pf=pb('{"label": "Target Planet", "value": "N/A", "unit":""}')fJ(pf,pe)pg=pc(pd,"value")ph=pb('{"label": "distance", "value": "N/A", "unit":""}')fJ(ph,pg)gc=pc(pd,"value")gb=pb('{"label": "Travel Time", "value": "N/A", "unit":""}')fJ(gb,gc)ga=pc(pd,"value")g9=pb('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fJ(g9,ga)ge=pc(pd,"value")gd=pb('{"label": "Target Altitude", "value": "N/A", "unit":""}')fJ(gd,ge)g6=pc(pd,"value")g5=pb('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g4=pc(pd,"value")g3=pb('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g2=pc(pd,"value")g1=pb('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g0=pc(pd,"value")f_=pb('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g8=pc(pd,"value")g7=pb('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c7 then fJ(g5,g6)fJ(g3,g4)fJ(g1,g2)fJ(f_,g0)fJ(g7,g8)end end;local function pi()gB(pd)pd=nil end;local function pj()if not a_ then if fW==nil or fW.planetname~=j3.name then pk=(b_.center-cH):len()else pk=(fW.position-cH):len()end end;local ff=cE;local pl=c.getThrottle()/100;if t then pl=bJ end;local pm,pn=ci.computeDistanceAndTime(cE,Z,ca,d:maxForceForward()*pl,a0,0)local bY,bZ;if not b0 then bY,bZ=cm.GetAutopilotBrakeDistanceAndTime(Z)else bY,bZ=cm.GetAutopilotTBBrakeDistanceAndTime(Z)end;local dE,po;if not b0 and ff>0 then dE,po=cm.GetAutopilotBrakeDistanceAndTime(ff)else dE,po=cm.GetAutopilotTBBrakeDistanceAndTime(ff)end;local pp=0;local pq=0;if ba or not a_ and ff>5 then pq=ci.computeTravelTime(ff,0,pk)elseif bY+pm<pk then pp=pk-(bY+pm)pq=ci.computeTravelTime(8333.0556,0,pp)else local pr=(pk-bY)/pm;pm=pk-bY;pn=pn*pr end;if fW~=nil and fW.planetname==j3.name and not a_ then return pq elseif b9 then return po elseif ba then return pq+po else return pn+bZ+pq end end;ck.DrawTanks()if shield_1 then ck.DrawShield()end;if bf~="None"then if pd==nil then pa()end;if bf~=nil then local ps=fW~=nil;local pt=0.5*bq/b_:getGravity(b_.center+vec3(0,0,1)*b_.radius):len()pt=pt>1000000 and fL(pt/1000000,2).." kTons"or fL(pt/1000,2).." Tons"fI(pf,'{"label": "Target", "value": "'..bf..'", "unit":""}')lD=pj()if ps and not a_ then c2=(cH-fW.position):len()else c2=(bg-cH):len()end;if not b0 then bY,bZ=cm.GetAutopilotBrakeDistanceAndTime(cE)iI,iJ=cm.GetAutopilotBrakeDistanceAndTime(Z)else bY,bZ=cm.GetAutopilotTBBrakeDistanceAndTime(cE)iI,iJ=cm.GetAutopilotTBBrakeDistanceAndTime(Z)end;local lo=is(c2)fI(ph,'{"label": "distance", "value": "'..lo..'"}')fI(gb,'{"label": "Travel Time", "value": "'..it(lD)..'", "unit":""}')lo=is(bY)fI(g5,'{"label": "Cur Brake distance", "value": "'..lo..'"}')fI(g3,'{"label": "Cur Brake Time", "value": "'..it(bZ)..'", "unit":""}')lo=is(iI)fI(g1,'{"label": "Max Brake distance", "value": "'..lo..'"}')fI(f_,'{"label": "Max Brake Time", "value": "'..it(iJ)..'", "unit":""}')fI(g9,'{"label": "Max Brake Mass", "value": "'..d8("%s",pt)..'", "unit":""}')lo=is(gf)fI(gd,'{"label": "Target Orbit", "value": "'..lo..'"}')if c8>0 and not pu then a.removeDataFromWidget(f_,g0)a.removeDataFromWidget(g1,g2)a.removeDataFromWidget(g3,g4)a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)pu=true;if not cK and t and(b1 or b4 or c5)then cm.cmdThrottle(1)aX=false;bN=false end end;if c8==0 and pu then if fI(f_,g0)==1 then fJ(f_,g0)end;if fI(g1,g2)==1 then fJ(g1,g2)end;if fI(g3,g4)==1 then fJ(g3,g4)end;if fI(g5,g6)==1 then fJ(g5,g6)end;if fI(g7,g8)==1 then fJ(g7,g8)end;pu=false end end else pi()end;if warpdrive~=nil then if ik(warpdrive.getData()).destination~="Unknown"and ik(warpdrive.getData()).distance>400000 then warpdrive.show()pv=true else warpdrive.hide()pv=false end end end;function o7.OneSecondTick()local function pw()local jC=bF()local kZ=cE;local px=jC-iU;if kZ>1.38889 then kZ=kZ/1000;local py=kZ*(jC-iU)bj=bj+py;iR=iR+py end;iS=iS+px;bk=bk+px;iU=jC end;local function pz(jO)local pA=0;iK=""local pB=iv;local pC=0;local pD=0;local pE=0;local jG=0;local jH=""local pF=b.getElementHitPointsById;local pG=b.getElementMaxHitPointsById;local pH={}for dz in pairs(iu)do local pI=0;local pJ=0;pJ=pG(iu[dz])pI=pF(iu[dz])pC=pC+pI;if pI<pJ then if pI==0 then pE=pE+1 else pD=pD+1 end;if iV and#pH==0 then fN=vec3(b.getElementPositionById(iu[dz]))local hd=fN.x;local he=fN.y;local hf=fN.z;table.insert(pH,b.spawnArrowSticker(hd,he,hf+1,"down"))table.insert(pH,b.spawnArrowSticker(hd,he,hf+1,"down"))b.rotateSticker(pH[2],0,0,90)table.insert(pH,b.spawnArrowSticker(hd+1,he,hf,"north"))table.insert(pH,b.spawnArrowSticker(hd+1,he,hf,"north"))b.rotateSticker(pH[4],90,90,0)table.insert(pH,b.spawnArrowSticker(hd-1,he,hf,"south"))table.insert(pH,b.spawnArrowSticker(hd-1,he,hf,"south"))b.rotateSticker(pH[6],90,-90,0)table.insert(pH,b.spawnArrowSticker(hd,he-1,hf,"east"))table.insert(pH,b.spawnArrowSticker(hd,he-1,hf,"east"))b.rotateSticker(pH[8],90,0,90)table.insert(pH,b.spawnArrowSticker(hd,he+1,hf,"west"))table.insert(pH,b.spawnArrowSticker(hd,he+1,hf,"west"))b.rotateSticker(pH[10],-90,0,90)table.insert(pH,iu[dz])end elseif iV and#pH>0 and pH[11]==iu[dz]then for jB in pairs(pH)do b.deleteSticker(pH[jB])end;pH={}end end;pA=bG(pC/pB*100)if pA<100 then jO[#jO+1]=gC(0,0,"","pbright txt")jG=bG(pA*2.55)jH=d8("rgb(%d,%d,%d)",255-jG,jG,0)if pA<100 then jO[#jO+1]=gC("50%",1035,"Elemental Integrity: "..pA.."%","txtbig txtmid","fill:"..jH)if pE>0 then jO[#jO+1]=gC("50%",1055,"Disabled Modules: "..pE.." Damaged Modules: "..pD,"txtbig txtmid","fill:"..jH)elseif pD>0 then jO[#jO+1]=gC("50%",1055,"Damaged Modules: "..pD,"txtbig txtmid","fill:"..jH)end end end end;local function pK()if ij then if iL==nil and(d1~=nil or bi)then _autoconf.displayCategoryPanel(ij,weapon_size,"Weapons","weapon",true)iL=_autoconf.panels[_autoconf.panels_size]elseif iL~=nil and d1==nil and not bi then gB(iL)iL=nil end end end;cW=b.getPlayersOnBoard()cX=b.getDockedConstructs()local jO={}pw()if s then pz(jO)end;pK()ck.UpdatePipe()ck.ExtraData(jO)iT=table.concat(jO,"")collectgarbage("collect")end;function o7.AnimateTick()cr=true;cq=false;c0=0;c1=0;c.stopTimer("animateTick")end;function o7.MsgTick()local jO={}ck.DisplayMessage(jO,"empty")bV="empty"c.stopTimer("msgTick")bW=3 end;function o7.ButtonSetup()nH()nM()ix=iy end;return o7 end;local function pL(d,b,c,a,e,vBooster,hover,pM,antigrav,warpdrive,dbHud_1,eO,bG,bH,im,eJ,bF,d9,io,fI,ip,db,fL,fK,iq,dc,is,it,pN,ik,d8,fJ)local pO={}local function pP(ff)local pQ=bb;if not a_ then pQ=0 end;if not c7 then return ci.computeDistanceAndTime(ff,pQ,ca,0,0,bo-bd*ca)else if bq and bq>0 then return ci.computeDistanceAndTime(ff,pQ,ca,0,0,bq-bd*ca)else return 0,0 end end end;local function pR(ff)local pQ=bb;if not a_ then pQ=0 end;return ci.computeDistanceAndTime(ff,pQ,ca,d:maxForceForward(),a0,bo-bd*ca)end;local pS=false;local pT=0;local pU=0;local pV=0;local pW=bF()local pX=0;local pY=0;local pZ=0;local p_=0;local q0=false;local q1=false;local q2=false;local q3=nil;local q4=0;local iH=55;local q5=nil;local q6=false;local q7=false;local q8=false;local q9=0;local qa=0;local qb=0;local qc=0;local qd=0;local qe={VectorToTarget=false}local qf=vec3(b.getConstructWorldOrientationUp())local qg=nil;local qh=""function pO.clearAll()b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"aY=false;aZ=false;cQ=nil;b1=false;b4=false;b2=false;aX=false;b3=false;b5=false;bT=false;q7=false;c3=false;c4=false;q8=false;cs=p;bm=false;b0=false;cb=false;bp=nil;bv=false;d4=false;d5=nil end;function pO.GetAutopilotBrakeDistanceAndTime(ff)return pP(ff)end;function pO.GetAutopilotTBBrakeDistanceAndTime(ff)return pR(ff)end;local function qi(qj,qk,ql)qk=qk:project_on_plane(qj)ql=ql:project_on_plane(qj)return eJ(qk:cross(ql):dot(qj),qk:dot(ql))end;local function qm()local function qn()local qo=-1;local qp=-1;if vBooster then qo=vBooster.getDistance()end;if hover then qp=hover.getDistance()end;if qo~=-1 and qp~=-1 then if qo<qp then return qo else return qp end elseif qo~=-1 then return qo elseif qp~=-1 then return qp else return-1 end end;local qq=qn()local qr=-1;if pM then qr=pM.getDistance()end;if qq~=-1 and qr~=-1 then if qq<qr then return qq else return qr end elseif qq~=-1 then return qq else return qr end end;local function qs(j3,eA,qt)local function qu(qv,dL)local eG=vec3(dL)if qv.id==0 then return setmetatable({latitude=eG.x,longitude=eG.y,altitude=eG.z,id=0,systemId=qv.systemId},dN)end;local eH=eG-qv.center;local c2=eH:len()local dT=c2-qv.radius;local dR=0;local dS=0;if not dc(c2,0)then local eI=eJ(eH.y,eH.x)dS=eI>=0 and eI or 2*math.pi+eI;dR=math.pi/2-math.acos(eH.z/c2)end;return setmetatable({latitude=math.deg(dR),longitude=math.deg(dS),altitude=dT,id=qv.id,systemId=qv.systemId},dN)end;local qw=qu(j3,eA)qw="::pos{"..qw.systemId..","..qw.id..","..qw.latitude..","..qw.longitude..","..qw.altitude.."}"if qt then return qw else a.setWaypoint(qw)return true end end;local qx=false;function pO.showWayPoint(j3,eA,qt)return qs(j3,eA,qt)end;function pO.APTick()local function qy()if cT and not b2 then local eh=cT[1]local hM,hN=cT[2],cT[3]local qz=math.min(hM,hN or hM)local qA=qz/cE;local qB=b3 and(cE<42 or c6~=-1)local qC=b1 or bm or bp or a_;if qC and not qB and(bY*1.5>qz or qA<1)then aX="Collision"bB={}cm.cmdThrottle(0)if b1 then cm.ToggleAltitudeHold()end;if bp then cm.ToggleLockPitch()end;bV="Autopilot Cancelled due to possible collision"if bm or a_ then cm.ToggleAutopilot()end;lw=true;b2=true;cs=true end;if qA<11 then cS=eh.name.." COLLISION "..it(qA).." / "..is(qz,2)else cS=eh.name.." collision "..it(qA)end;if qA<6 then fK("alarm","AL",2)end else cS=false end end;local function qD(qE,qF,qG)local function qH(qE,ej)qE=vec3(qE)ej=vec3(ej):normalize()local du=qE*ej;return du.x+du.y+du.z end;local qI=0.001;local qJ=1;if not c7 or not ct or c6~=-1 or cE<iH then if qG==nil then qG=aN end;if qF==nil then qF=qI end;qE=vec3(qE):normalize()local qK=vec3()-qE;local qL=-qH(qK,b.getConstructWorldOrientationRight())*qJ;local qM=-qH(qK,b.getConstructWorldOrientationUp())*qJ;if pU==0 then pU=qL/2 end;if pV==0 then pV=qM/2 end;if eO(qL)<0.1 then qa=qa-qL*2 else qa=qa-(qL+(qL-pU)*qG)end;if eO(qM)<0.1 then q9=q9+qM*2 else q9=q9+qM+(qM-pV)*qG end;pU=qL;pV=qM;if eO(qL)<qF and eO(qM)<qF then return true end;return false elseif ct and c6==-1 then qE=cD;if qG==nil then qG=aN end;if qF==nil then qF=qI end;qE=vec3(qE):normalize()local qK=cA-qE;local qL=-qH(qK,b.getConstructWorldOrientationRight())*qJ;local qM=-qH(qK,b.getConstructWorldOrientationUp())*qJ;if pU==0 then pU=qL/2 end;if pV==0 then pV=qM/2 end;if eO(qL)<0.1 then qa=qa-qL*5 else qa=qa-(qL+(qL-pU)*qG)end;if eO(qM)<0.1 then q9=q9+qM*5 else q9=q9+qM+(qM-pV)*qG end;pU=qL;pV=qM;if eO(qL)<qF and eO(qM)<qF then return true end;return false end end;c7=bH()>0;c8=bH()c9=b.getAltitude()c6=qm()bI=bF()pW=bI;if E then qy()end;if antigrav then cJ=antigrav.getState()==1 end;local qN=a.getMouseWheel()if qN>0 then cm.changeSpd()elseif qN<0 then cm.changeSpd(true)else q6=true end;local qO=1;local qP=1;local qQ=bI-pW;local qR=-math.deg(qi(qf,cD,cA))local qS=math.deg(qi(cB,cD,cA))local gh=cF*-1;ct=c7 and qR<-K or qR>K or qS<-L or qS>L;local qT=a.getMouseDeltaX()local qU=a.getMouseDeltaY()if o and not bU then qU=-qU end;qa=0;qb=0;q9=0;fO=ch[0]j3=fO:closestBody(b.getConstructWorldPos())qV=cj(j3)fj=qV:orbitalParameters(b.getConstructWorldPos(),cD)if c9==0 then c9=(cH-j3.center):len()-j3.radius end;cR=c.getClosestPlanetInfluence()>0 or c9>0 and c9<200000;local om=j3:getGravity(b.getConstructWorldPos()):len()*ca;qc=0;local qW=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if ip()==0 then if im()==1 and bU then if not cq then c0=d9(c0+qT,-cc/2,cc/2)c1=d9(c1+qU,-cd/2,cd/2)end else c0=0;c1=0 end else c0=d9(c0+qT,-cc/2,cc/2)c1=d9(c1+qU,-cd/2,cd/2)c2=db(c0*c0+c1*c1)if not bU and im()==0 then local kL,kM=1,1;if bD=="SCOPE"then kL,kM=cZ/90,cZ/90 end;if g=="virtual joystick"then if c0>0 and c0>at then qa=qa-(c0-at)*aB*kL elseif c0<0 and c0<at*-1 then qa=qa-(c0+at)*aB*kL else qa=0 end;if c1>0 and c1>at then q9=q9-(c1-at)*aC*kM elseif c1<0 and c1<at*-1 then q9=q9-(c1+at)*aC*kM else q9=0 end else c0=0;c1=0;if g=="mouse"then q9=(-utils.smoothstep(qU,-100,100)+0.5)*2*qO;qa=(-utils.smoothstep(qT,-100,100)+0.5)*2*qP end end end end;local qX=cE>8334;if cE>U/3.6 and not c7 and not a_ and not qX then bV="Space Speed Engine Shutoff reached"cm.cmdThrottle(0)end;if not qX and qY then if not aX then cm.BrakeToggle()end;if a_ then cm.ToggleAutopilot()end end;qY=qX;if c7 and c8>0.09 then if cE>cu/3.6 and not t and not pS then aX="SpdLmt"pS=true elseif not t and pS then if cE<cu/3.6 then aX=false;pS=false end end end;if aZ then if c3 then aX=false;local qZ=false;if fW and c3==true then qZ=qD(fW.position-cH,0.1)else qZ=qD(vec3(cD),0.01)end;cs=true;if qZ then cm.cmdCruise(bG(cu))if(eO(cM)<2 or eO(cL)>85)and cE>=cu/3.6-1 then aX=false;aZ=false;if c3~=2 then q8=true end;if c3==true then c5=true end;c3=false;a_=false;cm.BeginReentry()end elseif c7 and t then cm.cmdThrottle(1)end elseif cE>iH then qD(vec3(cD),0.01)end end;if aY then if c7 then aY=false elseif cE>iH then qD(-vec3(cD))end end;if not aZ and c3 and not bv then if c8==0 then if c3~=2 then q8=true end;cm.BeginReentry()c3=false;c5=true else c3=false;cm.ToggleAutopilot()end end;if c5 and fW and(c9<b6+250 and c9>b6-250)and cE*3.6>cu-250 and eO(cG)<25 and c8>=0.1 and(fW.position-cH):len()>2000+c9 then cm.ToggleAutopilot()c5=false end;if b5 then cs=true;local q_=b6;if cG<-30 then bV="Unable to achieve lift. Safety Landing."bS=0;cs=p;b5=false;b2=true elseif not q and cJ or b6<j3.spaceEngineMinAltitude then if cJ then q_=antigrav.getBaseAltitude()end;if c9<q_-100 then qd=0;bS=15;aX=false elseif cG>0 then aX="VTO Limit"bS=0 elseif cG<-30 then aX="VTO Fall"bS=15 elseif c9>=q_ then if cJ then if a_ or bm then cm.ToggleVerticalTakeoff()else aX="VTO Complete"b5=false end;bV="Takeoff complete. Singularity engaged"fK("aggLk","AG")else aX=false;bV="VTO complete. Engaging Horizontal Flight"fK("vtoc","VT")cm.ToggleVerticalTakeoff()end;bS=0 end else if c8>0.08 then qd=0;aX=false;bS=20 elseif c8<0.08 and c8>0 then aX=false;if cy then qd=0;bS=20 else bS=0;qd=36;cm.cmdCruise(3500)end else cs=p;bv=true;cx=false;r0=false;q0=false;pZ=nil;p_=nil;if q3==nil then q3=j3 end;cw=q_;q2=true;b5=false end end;if qd~=nil then if r1==nil then r1=pid.new(2*0.01,0,2*0.1)end;local r2=d9(qd-cL,-L*0.80,L*0.80)r1:inject(r2)local r3=d9(r1:get(),-1,1)q9=r3 end end;if bv then local qK;local r4=false;local r5=is(cw)if q3==nil then q3=j3;if bm then q3=b_ end end;if not q2 then cw=bG(q3.radius+q3.surfaceMaxAltitude+S)if q3.hasAtmosphere then cw=bG(q3.radius+q3.noAtmosphericDensityAltitude+S)end;q2=true end;if qe.VectorToTarget and fW then qK=fW.position-cH end;local r6,r7=cj(q3):escapeAndOrbitalSpeed((cH-q3.center):len()-q3.radius)local r8=cM;if not q0 then local r9=false;local ra=false;cm.cmdThrottle(0)p_=0;cv="Aligning to orbital path - OrbitHeight: "..r5;if qe.VectorToTarget then qD(qK:normalize():project_on_plane(cF))r4=cA:dot(qK:project_on_plane(qf):normalize())>0.95 else qD(cD)r4=qR<0.5;if cE<150 then r4=true end end;q9=0;pZ=0;if cL<=pZ+2 and cL>=pZ-2 then r9=true else r9=false end;if r8<=p_+2 and r8>=p_-2 then ra=true else ra=false end;if r9 and ra and r4 then pZ=nil;p_=nil;q0=true end else if qe.VectorToTarget then qD(qK:normalize():project_on_plane(cF))elseif cE>150 then qD(cD)end;q9=0;if qe.VectorToTarget and fW then local bY,dE=ci.computeDistanceAndTime(cE,cu/3.6,ca,0,0,bo)if cx and qK:len()>15000+bY+c9 then cv="Orbiting to Target"if c9-100<=q3.noAtmosphericDensityAltitude or lD>fj.timeToPeriapsis and fj.periapsis.altitude<q3.noAtmosphericDensityAltitude then cx=false end elseif cx or qK:len()<15000+bY+c9 then bV="Orbit complete, proceeding with reentry"fK("orCom","OB")bg=fW.position;q8=true;c5=true;qe.VectorToTarget,qe.AutopilotAlign=false,false;cm.ToggleIntoOrbit()cm.BeginReentry()return end end;if fj.periapsis~=nil and fj.apoapsis~=nil and fj.eccentricity<1 and c9>cw*0.9 and c9<cw*1.4 then if fj.apoapsis~=nil then if fj.periapsis.altitude>=cw*0.99 and fj.apoapsis.altitude>=cw*0.99 and fj.periapsis.altitude<fj.apoapsis.altitude and fj.periapsis.altitude*1.05>=fj.apoapsis.altitude or cx then if cx then aX=false;cm.cmdThrottle(0)pZ=0;if not qe.VectorToTarget then bV="Orbit complete"fK("orCom","OB")cm.ToggleIntoOrbit()end else q4=q4+1;if q4>=2 then cx=true end end else cv="Adjusting Orbit - OrbitHeight: "..r5;q1=true;cm.cmdCruise(r7*3.6+1)local rb=cw-c9;if rc==nil then rc=pid.new(0.1,0,1*0.1)end;rc:inject(rb-cG*d9(utils.smoothstep(2000-rb,-2000,2000)^6*10,1,10))pZ=d9(rc:get(),-60,60)end end else local rd=2.75;local re=eO(fL(r6*rd))local oB=re%50;if oB>0 then re=re-oB+50 end;aX=false;if c9<cw*0.8 then cv="Escaping planet gravity - OrbitHeight: "..r5;pZ=utils.map(cG,200,0,-15,80)elseif c9>=cw*0.8 and c9<cw*1.15 then cv="Approaching orbital corridor - OrbitHeight: "..r5;re=re*0.75;pZ=utils.map(cG,100,-100,-15,65)elseif c9>=cw*1.15 and c9<cw*1.5 then cv="Approaching orbital corridor - OrbitHeight: "..r5;re=re*0.75;if cG<0 or q1 then pZ=utils.map(c9,cw*1.5,cw*1.01,-30,0)else pZ=utils.map(c9,cw*0.99,cw*1.5,0,30)end elseif c9>cw*1.5 then cv="Reentering orbital corridor - OrbitHeight: "..r5;pZ=-65;local rf=utils.map(cG,-150,-400,1,0.55)re=re*rf end;cm.cmdCruise(bG(re))end end;if pZ~=nil then if rg==nil then rg=pid.new(1*0.01,0,5*0.1)end;local rh=pZ-cL;rg:inject(rh)local ri=d9(rg:get(),-0.5,0.5)q9=ri end end;if a_ and c8==0 and not c3 then local function rj(i0,fj)a.print(i0)aX=false;b9=false;a_=false;rk=false;bc="Aligning"cm.cmdThrottle(0)q7=false;bV=i0;fK("apCom","AP")if fj or c3 then if fj and gf~=nil and not c3 then if not c9 or c9==0 then return end;cw=c9;q2=true end;cm.ToggleIntoOrbit()end end;local rl,rm=bg,false;if fW and fW.planetname~="Space"then b8=true;if not rk then local rn=(fW.position-b_.center):normalize()local ro=rn:project_on_plane((b_.center-cH):normalize()):normalize()local rp=b_.center+ro*(b_.radius+gf)local rq=fW.position+(fW.position-b_.center):normalize()*(gf-b_:getAltitude(fW.position))if(cH-rp):len()<(cH-rq):len()then rl=rp else rl=rq;bb=0 end;bg=rl;cm.showWayPoint(b_,bg)rm=true;rk=true end;bd=0 elseif fW and fW.planetname=="Space"then if not rk then bd=0;rm=true;b8=true;rk=true;rl=fW.position+(cH-fW.position):normalize()*Q;bg=rl end elseif fW==nil then bd=0;if not rk then local rn=(cH+cD*100000-b_.center):normalize()local ro=rn:project_on_plane((b_.center-cH):normalize()):normalize()if ro:len()<1 then rn=(cH+cA*100000-b_.center):normalize()ro=rn:project_on_plane((b_.center-cH):normalize()):normalize()end;rl=b_.center+ro*(b_.radius+gf)bg=rl;rk=true;rm=true;b8=true;cm.showWayPoint(b_,bg)end end;pk=(vec3(rl)-cH):len()local lB,ey,ez=ch:getPlanetarySystem(0):castIntersections(cH,cD:normalize(),function(eh)if eh.noAtmosphericDensityAltitude>0 then return eh.radius+eh.noAtmosphericDensityAltitude else return eh.radius+eh.surfaceMaxAltitude*1.5 end end)local lC=ey;if ez~=nil and ey~=nil then lC=math.min(ez,ey)end;if lC~=nil and lC<pk and lB.name==b_.name then pk=lC end;local qZ=true;local rr=(b_.center-(cH+vec3(cD):normalize()*pk)):len()-b_.radius;local lo=is(rr)fI(g7,'{"label": "Projected Altitude", "value": "'..lo..'"}')local bY,bZ;if not b0 then bY,bZ=pP(cE)else bY,bZ=pR(cE)end;if cE>50 and b7 then local qK=vec3(rl)-cH;local rs=d9(math.deg(qi(qf,cD:normalize(),qK:normalize()))*cE/500,-90,90)local rt=d9(math.deg(qi(cB,cD:normalize(),qK:normalize()))*cE/500,-90,90)if eO(rs)<20 and eO(rt)<20 then rs=rs*2;rt=rt*2 end;if eO(rs)<2 and eO(rt)<2 then rs=rs*2;rt=rt*2 end;local qR=-math.deg(qi(qf,cA,cD:normalize()))local qS=-math.deg(qi(cB,cA,cD:normalize()))if ru==nil then ru=pid.new(2*0.01,0,2*0.1)end;ru:inject(rt-qS)local rv=d9(ru:get(),-1,1)q9=q9+rv;if rw==nil then rw=pid.new(2*0.01,0,2*0.1)end;rw:inject(rs-qR)local rx=d9(rw:get(),-1,1)qa=qa+rx;rm=true;if eO(rs)>2 or eO(rt)>2 then if bc~="Adjusting Trajectory"then bc="Adjusting Trajectory"fK("apAdj","AP")end else if bc~="Accelerating"then bc="Accelerating"fK("apAcc","AP")end end elseif b7 and cE<=50 then qD((rl-cH):normalize())end;if rr<gf*1.5 then if fW and fW.planetname=="Space"then bb=0 elseif fW==nil then dE,bb=cj(b_):escapeAndOrbitalSpeed(rr)end end;if a_ and not b7 and not ba and not b9 then local lB,lC=cm.checkLOS((bg-cH):normalize())if b_.name~=j3.name then if lB~=nil and b_.name~=lB.name and lC<pk then bV="Collision with "..lB.name.." in "..is(lC).."\nClear LOS to continue."bW=5;qx=true else qx=false;bV=""end end end;if not qx then if not ba and not b9 and not rm then qZ=qD((rl-cH):normalize())elseif b0 and(b9 or ba)then qZ=qD(-vec3(cD):normalize())end end;if b7 then if not q7 then aX=false;cm.cmdThrottle(_)bJ=fL(_,2)q7=true end;local pl=c.getThrottle()if t then pl=bJ end;local ry=99999;local oz=-vec3(b.getWorldAcceleration()):dot(cD:normalize())local rz=d9(cD:dot((rl-cH):normalize()),0,cE)if rz>0 or oz>0 then ry=ci.computeTravelTime(rz,oz,pk-bY)end;if cC:len()>=Z or pl==0 and q7 or a0/4>ry then b7=false;if bc~="Cruising"then fK("apCru","AP")bc="Cruising"end;ba=true;cm.cmdThrottle(0)end;local rA=pk;if rA<=bY or G and cP<=bY+10000 and cO then if G and cP<=bY+10000 and cO then if cP<pT and cP>2000 then cm.ToggleAutopilot()bV="Autopilot cancelled to prevent crossing PvP Line"aX="PvP Prevent"pT=cP else pT=cP;return end end;b7=false;if bc~="Braking"then fK("apBrk","AP")bc="Braking"end;b9=true;cm.cmdThrottle(0)q7=false end elseif b9 then if bc~="Orbiting to Target"then aX="AP Brk"end;if b0 then cm.cmdThrottle(1,true)end;local dE,r7=cj(b_):escapeAndOrbitalSpeed((cH-j3.center):len()-j3.radius)local qK;if fW then qK=fW.position-cH end;if fW and fW.planetname=="Space"and cE<50 then if#bB>0 then table.remove(bB,1)if#bB>0 then aX=false;cm.ToggleAutopilot()cm.ToggleAutopilot()return end end;rj("Autopilot complete, arrived at space location")aX="Space Arrival"elseif fW and fW.planetname~="Space"and cE<=r7 and(fj.apoapsis==nil or fj.periapsis==nil or fj.apoapsis.altitude<=0 or fj.periapsis.altitude<=0)then rj("Autopilot complete, commencing reentry")bg=fW.position;c3=true;cm.showWayPoint(b_,bg)elseif(fW and fW.planetname~="Space"or fW==nil)and fj.periapsis~=nil and fj.periapsis.altitude>0 and fj.eccentricity<1 or bc=="Circularizing"then if bc~="Circularizing"then fK("apCir","AP")bc="Circularizing"end;if cE<=r7 then if fW then if cD:normalize():dot(qK:normalize())>0.4 then if bc~="Orbiting to Target"then fK("apOrb","OB")bc="Orbiting to Target"end;if not rB then aX=false;cm.showWayPoint(b_,fW.position)rB=true end else rj("Autopilot complete, proceeding with reentry")bg=fW.position;c3=true;cm.showWayPoint(b_,fW.position)rB=false end else rj("Autopilot completed, setting orbit",true)aX=false end end elseif bc=="Circularizing"then rj("Autopilot complete, fixing Orbit",true)end elseif ba then local rA=pk;if rA<=bY or G and cP<=bY+10000 and cO then if G and cP<=bY+10000 and cO then if cP<pT and cP>2000 then cm.ToggleAutopilot()bV="Autopilot cancelled to prevent crossing PvP Line"aX="Prevent PvP"pT=cP else pT=cP;return end end;b7=false;if bc~="Braking"then fK("apBrk","AP")bc="Braking"end;b9=true end;local pl=c.getThrottle()if t then pl=bJ end;if pl>0 then b7=true;if bc~="Accelerating"then bc="Accelerating"fK("apAcc","AP")end;ba=false end else if qZ then if not b8 and fW==nil or not b8 and fW and fW.planetname~="Space"then if not c3 then bg=vec3(b_.center)+(gf+b_.radius)*cB;rC=qf;rD=cB end;b8=true elseif qZ and not qx then b7=true;if bc~="Accelerating"then bc="Accelerating"fK("apAcc","AP")end;if not q7 then cm.cmdThrottle(_,true)bJ=fL(_,2)q7=true;aX=false end end end end elseif a_ and(fW~=nil and fW.planetname~="Space"and c8>0)then bV="Autopilot complete, starting reentry"fK("apCom","AP")bg=fW.position;aX=false;b9=false;a_=false;rk=false;bc="Aligning"cm.cmdThrottle(0)q7=false;aZ=true;c3=true;cm.showWayPoint(b_,fW.position)end;if bT then cs=true;local rt=0;local fl=cH+vec3(c.getMasterPlayerRelativePosition())local rE=fl-cH;local rF=vec3(rE):project_on(cA):len()local rG=vec3(rE):project_on(cB):len()local c2=db(rF*rF+rG*rG)qD(rE:normalize())local mI=40;local rH=c2<mI;local rI=100;local rJ=d9((c2-mI)/2,10,rI)q9=0;local qZ=eO(qa)<0.1;if qZ and cE<rJ and not rH then aX=false;rt=-20 else aX="Follow"rt=0 end;local rK=0;if eO(rt-cL)>rK then if rL==nil then rL=pid.new(2*0.01,0,2*0.1)end;rL:inject(rt-cL)local rv=rL:get()q9=rv end end;if b1 or b2 or b4 or bm or bp~=nil then local rM=bq;if rM then rM=rM*d9(cE/100,0.1,1)*c8 else rM=bo end;if c8<0.01 then rM=bo end;local rN=cA:project_on_plane(cF):normalize():dot(cD)local rO=vec3(b.getWorldAirFrictionAcceleration())local rP=rO:len()*ca;if rN>100 then bY,bZ=ci.computeDistanceAndTime(rN,100,ca,0,0,rM)local rQ,rR=ci.computeDistanceAndTime(100,0,ca,0,0,rM*0.55)bY=bY+rQ else bY,bZ=ci.computeDistanceAndTime(rN,0,ca,0,0,rM*0.55)end;if not q and cJ and not b4 and b6<antigrav.getBaseAltitude()then b6=antigrav.getBaseAltitude()end;local rb=b6-c9-cG;local rS=200+cE;if b4 or c3 then rT=2000+cE end;local rU=1;if b3 then rU=d9(cE/100,0.1,1)end;local rt=(utils.smoothstep(rb,-rS,rS)-0.5)*2*N*rU;if not b4 and not c3 and not bm and cA:dot(cD:normalize())<0.99 then rt=(utils.smoothstep(rb,-rS*d9(20-19*c8*10,1,20),rS*d9(20-19*c8*10,1,20))-0.5)*2*N*d9(2-c8*10,1,2)*rU end;if not b1 then rt=0 end;if bp~=nil then if cR and not bv then rt=bp else bp=nil end end;cs=true;local rV=q9;if b4 then local rW=bG(cu)local rX,rY=ci.computeDistanceAndTime(cE,rW/3.6,ca,0,0,bo-j3.gravity*9.8*ca)rX=rX==-1 and 5000 or rX;local rZ=c9-(j3.noAtmosphericDensityAltitude+rX)local r_=c9>j3.noAtmosphericDensityAltitude+rX*1.35;if r_ then rt=O;if cE<=rW/3.6 and cE>rW/3.6-10 and eO(cD:normalize():dot(cA))>0.9 and not cK then bN=false;cm.cmdThrottle(1)end elseif(cK or io:getTargetSpeed(axisCommandId.longitudinal)~=rW)and not r_ and not c7 then cm.cmdCruise(rW,true)end;if cK then if cE>rW/3.6 and not r_ then aX="Reentry Limit"else aX=false end else aX=false end;if cG>0 then aX="Reentry vSpd"end;if not q8 then rt=-80;if c9<j3.surfaceMaxAltitude+(j3.atmosphereThickness-j3.surfaceMaxAltitude)*0.25 then bV="PARACHUTE DEPLOYED at "..fL(c9,0)b4=false;b2=true;lw=true;cm.cmdThrottle(0)rt=0;cs=p end elseif j3.noAtmosphericDensityAltitude>0 and r_ then cs=true elseif not r_ then if not c7 and(cK or io:getTargetSpeed(axisCommandId.longitudinal)~=rW)then cm.cmdCruise(rW)end;if cE<rW/3.6+1 then aX=false;q8=false;b4=false;cs=true end end end;if cE>iH and not c4 and not bm and not b2 and u then qD(vec3(cD))end;if cQ or(bm or c4)and bh>0 and c8>0.01 then local qK;if cQ then if type(cQ)=="table"then qK=cQ elseif cQ<3 and cQ>0 then qK=-cF:cross(cD)*5000 elseif cQ>=3 then qK=cF:cross(cD)*5000 elseif cQ<0 then qK=cD*25000 end elseif fW~=nil then qK=fW.position-cH else qK=b_.center-cH end;local rs=math.deg(qi(cF:normalize(),cD,qK))*2;local mL=math.rad(eO(cM))if cE>aG and c8>0.01 then local s0=1000+cE;local s1=(utils.smoothstep(rb-cG*10,-s0,s0)-0.5)*2*N;local s2=d9(90-s1,0,180)qc=d9(rs*2,-s2,s2)local s3=rs;rs=d9(d9(rs,-K*0.80,K*0.80)*math.cos(mL)+4*(cL-rt)*math.sin(math.rad(cM)),-K*0.80,K*0.80)local s4=1;if qc~=0 then s4=eO(mL/qc)end;s4=(90-d9(eO(qc-cM),0,90))/90;local s5=rt;if eO(cM)>90 then s5=-s5 end;rt=s4*d9(d9(s5*math.cos(mL),-L*0.8,L*0.8)+eO(d9(eO(s3)*math.sin(mL),-L*0.80,L*0.80)),-L*0.80,L*0.80)else qc=0;rs=d9(rs,-K*0.80,K*0.80)end;local s6=qR-rs;if cQ and eO(s6)<=0.0001 and(type(cQ)=="table"or type(cQ)~="table"and cQ<0 and eO(cM)<1)then if cQ==-2 then cm.ToggleAltitudeHold()end;cQ=nil;fK("180Off","BR")return end;if not ct and cE>aG and c8>0.01 then if s7==nil then s7=pid.new(2*0.01,0,2*0.1)end;s7:inject(s6)local rx=d9(s7:get(),-1,1)qa=qa+rx elseif c7 and c6>-1 or cE<aG then qD(qK)elseif ct and c8>0.01 then if(qR<-K or qR>K)and c8>0.01 then qD(cD)end;if(qS<-L or qS>L)and c8>0.01 then rt=d9(cL-qS,cL-L*0.80,cL+L*0.80)end end;if fW~=nil and not c4 then local q_=j3:getAltitude(fW.position)local rZ=qK:project_on_plane(cF):len()lw=true;if not c4 and not b4 and rZ<=bY and(cD:project_on_plane(cF):normalize():dot(qK:project_on_plane(cF):normalize())>0.99 or lF=="Finalizing Approach")then lF="Finalizing Approach"if#bB>0 then table.remove(bB,1)if#bB>0 then cm.ToggleAutopilot()cm.ToggleAutopilot()return end end;cm.cmdThrottle(0)if b1 then cm.ToggleAltitudeHold()bm=true end;aX="AP Finalizing"elseif not b3 then aX=false end;if lF=="Finalizing Approach"and(rN<0.1 or rZ<0.1 or s8~=nil and s8<rZ)then fK("bklOn","BL")b2=true;d4=true;if fW.heading then d5=fW.heading else d5=nil end;bm=false;lF="Proceeding to Waypoint"cS=false end;s8=rZ end elseif bm and c8==0 and b6>j3.noAtmosphericDensityAltitude and not(c4 or b4)then if fW~=nil and b_.name==j3.name then local qK=fW.position-cH;local q_=j3:getAltitude(fW.position)local rZ=db(qK:len()^2-(c9-q_)^2)local rM=bq;if rM then bY,bZ=ci.computeDistanceAndTime(cE,0,ca,0,0,rM/2)lw=true;if rZ<=bY+cE*qQ/2 and cD:project_on_plane(cF):normalize():dot(qK:project_on_plane(cF):normalize())>0.99 then if j3.hasAtmosphere then aX=false;aZ=false;q8=true;c3=false;c5=true;a_=false;cm.BeginReentry()end end;s8=rZ end end end;if c8==0 and(b1 and b6>j3.noAtmosphericDensityAltitude)and not(c4 or bv or b4)then if not cx and not bv then cw=b6;q2=true;if bm then qe.VectorToTarget=true end;cm.ToggleIntoOrbit()bm=false;q0=true end end;if ct and c8>0.01 and c6==-1 and cE>aG and lF~="Finalizing Approach"then qD(cD)rt=d9(cL-qS,cL-L*0.80,cL+L*0.80)end;q9=rV;local qr=-1;if b2 then rt=0;local s9=false;local sa=math.abs(rN)if not q and cJ then s9=antigrav.getBaseAltitude()if s9<j3.surfaceMaxAltitude and fW==nil or fW~=nil and j3:getAltitude(fW.position)>s9 then s9=false end end;if d5 then if sa<0.05 then if cG>-M then aX=false else aX="BL Align BLR"end;if qD(d5,0.001)then d5=nil;cs=p else q9=0;cs=true end else aX="BL Align Hzn"end else local sb=false;local sc=30;if sa<10 and qW~=nil and qW>0 then local sd=d9(c8,0.4,2)local rM=bq*d9(cE/100,0.1,1)*sd;local se=qW*sd+rM-om;local sf=rM/2-om;local sg=cE-db(eO(sf/2)*20/(0.5*ca))*utils.sign(sf)if sg<0 then sg=0 end;local sh;if cE>100 then local si,dE=ci.computeDistanceAndTime(cE,100,ca,0,0,rM)local sj,dE=ci.computeDistanceAndTime(100,0,ca,0,0,db(rM))sh=si+sj else sh=ci.computeDistanceAndTime(cE,0,ca,0,0,db(rM))end;if sh<20 then aX=false else local sk=0;if sg>100 then local sl,dE=ci.computeDistanceAndTime(sg,100,ca,0,0,se)local sm,dE=ci.computeDistanceAndTime(100,0,ca,0,0,qW*sd+db(rM)-om)sk=sl+sm else sk,dE=ci.computeDistanceAndTime(sg,0,ca,0,0,qW*sd+db(rM)-om)end;sk=(sk+15+cE*qQ)*1.1;local sn=d4 and fW~=nil and j3:getAltitude(fW.position)>0 and fW.safe;local q_=nil;if s9 and s9<c9 then q_=s9 elseif sn then q_=j3:getAltitude(fW.position)+1000;if c9<q_ then q_=nil end elseif c9>j3.surfaceMaxAltitude then q_=j3.surfaceMaxAltitude end;if q_~=nil then local so=c9-q_;if so<=sk or sk==-1 then aX="BL Stop Dist"sb=true else aX=false;sb=true end end end end;if not cK then cm.cmdThrottle(0)end;io:setTargetGroundAltitude(500)io:activateGroundEngineAltitudeStabilization(500)bx=true;qr=c6;if qr==-1 and s9 and eO(c9-s9)<100 then if not d5 then b2=false;cs=p;d4=false end;aX="BL AGG Comp"elseif qr>-1 then if(cE<1 or cD:normalize():dot(cF)<0)and not d5 then b2=false;b1=false;bi=true;if bO then d.control.extendLandingGears()fK("grOut","LG",1)end;io:setTargetGroundAltitude(X)bS=0;aX="BL Complete"cs=p;d4=false else aX="BL Slowing"end elseif not sb then if lw and cD:normalize():dot(-gh)<0.999 then aX="BL Strong"qD()elseif sa>10 or sa>0.05 and d4 then aX="BL hSpd"elseif cG<-M then aX="BL BLR"else aX=false end end end end;if b3 or c4 then local lB,ez,ey;if bg~=nil then lB,ez,ey=ch:getPlanetarySystem(0):castIntersections(cH,(bg-cH):normalize(),function(eh)return eh.radius+eh.noAtmosphericDensityAltitude end)end;if cJ and not c4 then if c9>=b6-50 then b3=false;if not a_ and not bm then aX="ATO Agg Arrive"cm.cmdThrottle(0)end end elseif eO(rt)<15 and c9/b6>0.75 then b3=false;if not c4 then if cK and not t then d.control.cancelCurrentControlMasterMode()end elseif c4 and cE<iH then a_=true;c4=false;b1=false;b3=false;cm.cmdThrottle(0)elseif c4 then cm.cmdThrottle(0)aX="ATO Space"end elseif c4 and c8==0 and b_~=nil and(lB==nil or lB.name==b_.name)then a_=true;c4=false;b1=false;b3=false;if not cK then cm.cmdThrottle(0)end;b7=true end end;local sp=c6>-1;local sq=cL;if(bm or c4 or cQ)and not sp and cE>aG and c8>0.01 then local mL=math.rad(eO(cM))sq=cL*eO(math.cos(mL))+qS*math.sin(mL)end;local sr=d9(rt-sq,-L*0.80,L*0.80)if c8<0.01 and bm then sr=d9(rt-sq,-85,N)elseif c8<0.01 then sr=d9(rt-sq,-N,N)end;if eO(cM)<5 or bm or cQ or b2 or sp or b1 then if rL==nil then rL=pid.new(5*0.01,0,5*0.1)end;rL:inject(sr)local rv=rL:get()q9=q9+rv end end;if antigrav~=nil and(antigrav and not q and c9<200000)then if br==nil or br<1000 then br=1000 end;if ss~=br then ss=br;antigrav.setBaseAltitude(ss)end end end;function pO.ToggleIntoOrbit()cx=false;pZ=nil;p_=nil;q4=0;if c8==0 then if bv then fK("orOff","AP")bv=false;q0=false;q3=nil;cs=p;if b1 then b1=false;b3=false end;qe.VectorToTarget=false;qe.AutopilotAlign=false;q2=false elseif cR then fK("orOn","AP")bv=true;cs=true;if q3==nil then q3=j3 end;if b1 then b1=false;b3=false end else bV="Unable to engage auto-orbit, not near a planet"end else bv=false;q0=false;q3=nil;cs=p;if b1 then b1=false end;qe.VectorToTarget=false;qe.AutopilotAlign=false;q2=false end end;function pO.ToggleVerticalTakeoff()b1=false;if b5 then lw=true;b4=false;b3=false;b2=true;cs=true;bS=0;if c7 and c6==-1 then b2=false;b1=true;bS=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cm.cmdCruise(bG(cu))end else cx=false;bi=false;d.control.retractLandingGears()io:setTargetGroundAltitude(W)aX="VTO Takeoff"end;b5=not b5 end;function pO.checkLOS(qE)local lB,ey,ez=ch:getPlanetarySystem(0):castIntersections(cH,qE,function(eh)if eh.noAtmosphericDensityAltitude>0 then return eh.radius+eh.noAtmosphericDensityAltitude else return eh.radius+eh.surfaceMaxAltitude*1.5 end end)local lC=ey;if ez~=nil and ey~=nil then lC=math.min(ez,ey)end;if lC~=nil then return lB,lC else return nil,nil end end;function pO.ToggleAutopilot()local function st(bt)cS=false;bm=not bm;if bm then b0=false;if not b1 and not bt then cm.ToggleAltitudeHold()end end;lF="Proceeding to Waypoint"end;local function su(go)if go then for J,dz in pairs(cN)do if dz.name and dz.name==go then return J end end else return 0 end end;local sv=false;if bI-pY<1.5 and c8>0 then if not cz then bV="No space engines detected, Orbital Hop not supported"return end;if j3.hasAtmosphere then if c8>0 then b6=j3.noAtmosphericDensityAltitude+S;fK("orH","OH")end;pY=-1;if a_ or bm or bv then return end end else pY=bI end;rk=false;if(bh>0 or#bB>0)and not a_ and not bm and not c4 and not bv then if 0.5*d:maxForceForward()/b.g()<ca then bV="WARNING: Heavy Loads may affect autopilot performance."bW=5 end;if#bB>0 and not c5 then bh=su(bB[1])cl.UpdateAutopilotTarget()bV="Route Autopilot in Progress"local qK=fW.position-cH;local rZ=qK:project_on_plane(cF):len()if rZ>50000 and fW.planetname==j3.name then sv=true end end;cl.UpdateAutopilotTarget()cm.showWayPoint(b_,bg)if fW~=nil then if fW.agg and not q and antigrav then if not cJ then cm.ToggleAntigrav()end;br=fW.agg end;bp=nil;bt=fW.planetname=="Space"if bt then fK("apSpc","AP")if c8~=0 then c4=true;cm.ToggleAltitudeHold()else a_=true end elseif j3.name==fW.planetname then lw=true;if c8>0 then if not bm then fK("vtt","AP")st(bt)if sv then b6=j3.noAtmosphericDensityAltitude+S end end else fK("apOn","AP")if not(b_.name==j3.name and c9<gf*1.5)then cx=false;a_=true elseif not c7 then if bv then cm.ToggleIntoOrbit()end;cw=j3.noAtmosphericDensityAltitude+S;q2=true;qe.AutopilotAlign=true;qe.VectorToTarget=true;q0=false;if not bv then cm.ToggleIntoOrbit()end end end else fK("apP","AP")aY=false;aZ=false;if c8~=0 then c4=true;cm.ToggleAltitudeHold()else a_=true end end elseif c8==0 then if fW==nil and(b_.name==j3.name and cR)and not bv then rB=false;cx=false;q0=false;cm.ToggleIntoOrbit()else fK("apP","AP")a_=true;aY=false;aZ=false;b8=false;bT=false;b1=false;b2=false;b4=false;b3=false;q7=false;bp=nil;rB=false end else fK("apP","AP")c4=true;cm.ToggleAltitudeHold()end else fK("apOff","AP")cm.ResetAutopilots(1)end end;function pO.routeWP(sw,sx,sy)if sy then if sy==1 then bB={}bB=iq(bB,bA)if#bB>0 then bV="Route Loaded"else bV="No Saved Route found on Databank"end;return bB else bA={}bA=iq(bA,bB)bV="Route Saved"pN()return end end;if sw then return bB end;if sx then bB={}bV="Current Route Cleared"else bB[#bB+1]=fW.name;bV="Added "..fW.name.." to route. "end;return bB end;function pO.cmdThrottle(dA,sz)if io:getAxisCommandType(0)~=axisCommandType.byThrottle and not sz then d.control.cancelCurrentControlMasterMode()end;io:setThrottleCommand(axisCommandId.longitudinal,dA)bJ=d9(fL(dA*100,0)/100,-1,1)qg=nil end;function pO.cmdCruise(dA,sz)if io:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not sz then d.control.cancelCurrentControlMasterMode()end;io:setTargetSpeedCommand(axisCommandId.longitudinal,dA)qg=dA end;function pO.ToggleLockPitch()if bp==nil then fK("lkPOn","LP")if not bU then bp=cL else bp=P end;b3=false;b1=false;b2=false else fK("lkPOff","LP")bp=nil end end;function pO.ToggleAltitudeHold()if bI-pX<1.5 then if j3.hasAtmosphere then if c8>0 then b6=j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude;fK("11","EP")else if cR then b6=j3.noAtmosphericDensityAltitude+S;cw=b6;q2=true;if not bv then cm.ToggleIntoOrbit()end;q0=true end end;pX=-1;if b1 or bv or b5 then return end end else pX=bI end;if cR and c8==0 then cw=c9;q2=true;q0=true;cm.ToggleIntoOrbit()if bv then pX=bI else pX=0 end;return end;b1=not b1;b2=false;b4=false;if b1 then a_=false;aZ=false;aY=false;bT=false;cs=true;bp=nil;cx=false;if c6~=-1 and cE<20 then fK("lfs","LS")b3=true;if pX>-1 then b6=c9+V end;bi=false;d.control.retractLandingGears()aX="ATO Hold"io:setTargetGroundAltitude(W)if aW and cI then cm.ToggleVerticalTakeoff()end else fK("altOn","AH")b3=false;if pX>-1 then if cR then b6=c9 end end;if b5 then cm.ToggleVerticalTakeoff()end end;if cJ and not q then local sA=antigrav.getBaseAltitude()if fW.agg and fW.agg>c9 then b6=fW.agg else b6=sA end;if eO(c9-sA)<50 then aX="AGG Hold"end end;if c4 then b6=200000 end else fK("altOff","AH")if bv then cm.ToggleIntoOrbit()end;if b5 then cm.ToggleVerticalTakeoff()end;cs=p;b3=false;bm=false;pX=0 end end;function pO.ResetAutopilots(pO)if pO then c4=false;a_=false;b8=false;q7=false;b6=c9;rk=false;d4=false end;bm=false;b3=false;b4=false;aZ=false;b2=false;d5=nil;sB=false;cQ=nil;d4=false;if not cJ then b1=false;bp=nil end;if b5 then cm.ToggleVerticalTakeoff()end;if bv then cm.ToggleIntoOrbit()end;cs=p;c3=false;c5=false;bS=0 end;function pO.BrakeToggle(sC)if not aX then if sC then aX=sC else aX=true end else aX=false end;if b2 then b2=false;cs=p;d4=false end;if aX then fK("bkOn","B",1)cm.ResetAutopilots()else fK("bkOff","B",1)end end;function pO.BeginReentry()if b4 then bV="Re-Entry cancelled"fK("reOff","RE")b4=false;cs=p;b1=false elseif not j3.hasAtmosphere then bV="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bW=5 elseif not q8 then b4=true;if io:getAxisCommandType(0)~=sD.cruise then d.control.cancelCurrentControlMasterMode()end;cs=true;aX=false;bV="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cu;fK("par","RE")else b4=true;b1=true;cs=true;aX=false;b6=j3.surfaceMaxAltitude+Y;if b6>j3.spaceEngineMinAltitude then b6=j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude end;local sE=is(b6)bV="Beginning Re-entry.  Target speed: "..cu.." Target Altitude: "..sE;fK("glide","RE")cm.cmdCruise(bG(cu))end;b3=false end;function pO.ToggleAntigrav()if antigrav and not q then if cJ then fK("aggOff","AG")antigrav.deactivate()antigrav.hide()else if br==nil then br=c9 end;if br<1000 then br=1000 end;fK("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pO.changeSpd(sF)local sG=1;if sF then sG=-1 end;if not bU then if t and not p7 and q6 then local sH=bJ;bJ=fL(d9(bJ+sG*az/100,-1,1),2)if bJ>=0 and sH<0 then bJ=0;q6=false end elseif p7 then if c8>0 or b4 then cu=d9(cu+sG*az,0,T)elseif a_ then Z=d9(Z+sG*az/3.6*100,0,8333.00)end else io:updateCommandFromActionStart(axisCommandId.longitudinal,sG*az/10)end else if a_ or bm or c4 or bv then cV=cV+1*sG*-1;if cV>#cN then cV=1 end;if cV<1 then cV=#cN end else if not sF then sG=1 else sG=nil end;cl.adjustAutopilotTargetIndex(sG)end end end;function pO.TenthTick()local function sI(om,sJ)if om==nil then om=b.g()end;om=fL(om,5)if sJ~=nil and sJ or(q5==nil or q5~=om)then local ff=cC:len()local sK=ik(c.getData()).maxBrake;if sK~=nil and sK>0 and c7 then sK=sK/d9(ff/100,0.1,1)sK=sK/c8;if c8>0.10 then if bq then bq=(bq+sK)/2 else bq=sK end end end;if sK~=nil and sK>0 then bo=sK end;q5=om end end;sI(nil,true)if qg~=nil then if io:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or io:getTargetSpeed(axisCommandId.longitudinal)~=qg then cm.cmdCruise(qg)else qg=nil end end end;function pO.SatNavTick()if not r then return end;qh=dbHud_1.getStringValue("SPBAutopilotTargetName")if qh~=nil and qh~=""and qh~="SatNavNotChanged"then local du=ik(dbHud_1.getStringValue("SavedLocations"))if du~=nil then bl=du;local gm=-1;local gs;for dz,dk in pairs(bl)do if dk.name and dk.name=="SatNav Location"then gm=dz;break end end;if gm~=-1 then gs=bl[gm]gm=-1;for dz,dk in pairs(e[0])do if dk.name and dk.name=="SatNav Location"then gm=dz;break end end;if gm>-1 then e[0][gm]=gs end;cl.UpdateAtlasLocationsList()bV=gs.name.." position updated"end end;for J=1,#cN do if cN[J].name==qh then bh=J;a.print("Index = "..bh.." "..cN[J].name)cl.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pO.onFlush()local function sL(sM,rJ)local sN=vec3()local sO=vec3()if sM==axisCommandId.longitudinal then sN=vec3(b.getConstructOrientationForward())sO=cA elseif sM==axisCommandId.vertical then sN=vec3(b.getConstructOrientationUp())sO=qf elseif sM==axisCommandId.lateral then sN=vec3(b.getConstructOrientationRight())sO=cB else return vec3()end;local sP=vec3(b.getWorldGravity())local sQ=sP:dot(sO)local sR=vec3(b.getWorldAirFrictionAcceleration())local sS=sR:dot(sO)local sT=cC:dot(sN)local sU=rJ*constants.kph2m;if sV==nil then sV=pid.new(10,0,10.0)end;sV:inject(sU-sT)local sW=sV:get()local sX=(sW-sS-sQ)*sO;return sX end;local function sY(sM,rJ)local sN=vec3()local sO=vec3()if sM==axisCommandId.longitudinal then sN=vec3(b.getConstructOrientationForward())sO=cA elseif sM==axisCommandId.vertical then sN=vec3(b.getConstructOrientationUp())sO=qf elseif sM==axisCommandId.lateral then sN=vec3(b.getConstructOrientationRight())sO=cB else return vec3()end;local sP=vec3(b.getWorldGravity())local sQ=sP:dot(sO)local sR=vec3(b.getWorldAirFrictionAcceleration())local sS=sR:dot(sO)local sT=cC:dot(sN)local sU=rJ*constants.kph2m;if sZ==nil then sZ=pid.new(10,0,10.0)end;sZ:inject(sU-sT)local sW=sZ:get()local sX=(sW-sS-sQ)*sO;return sX end;local function s_(t0,jR,fS)local t1=t0:cross(fS):normalize_inplace()local kC=math.acos(d9(t1:dot(-jR),-1,1))*constants.rad2deg;if t1:cross(-jR):dot(fS)<0 then kC=-kC end;return kC end;if antigrav and not q then if not cJ and antigrav.getBaseAltitude()~=br then antigrav.setBaseAltitude(br)end end;cK=io:getAxisCommandType(0)==axisCommandType.byThrottle;aJ=math.max(aJ,0.01)aK=math.max(aK,0.01)aE=math.max(aE,0.01)aI=math.max(aI,0.01)aL=math.max(aL,0.01)aM=math.max(aM,0.01)aD=math.max(aD,0.01)local t2=d9(bP+q9+a.getControlDeviceForwardInput(),-1,1)local t3=d9(bQ+qb+a.getControlDeviceYawInput(),-1,1)local t4=d9(bR+qa-a.getControlDeviceLeftRightInput(),-1,1)local t5=aX and 1 or 0;cF=vec3(b.getWorldVertical())if cF==nil or cF:len()==0 then cF=(j3.center-cH):normalize()end;qf=vec3(b.getConstructWorldOrientationUp())cA=vec3(b.getConstructWorldOrientationForward())cB=vec3(b.getConstructWorldOrientationRight())cD=vec3(b.getWorldVelocity())cC=vec3(b.getVelocity())cH=vec3(b.getConstructWorldPos())ca=b.getConstructMass()cE=vec3(cD):len()cG=-cF:dot(cD)cM=getRoll(cF,cA,cB)local t6=cM/180*math.pi;local t7=math.cos(t6)local t8=math.sin(t6)cL=s_(cF,cA,cB*t7+qf*t8)local t9=cD:normalize()local ta=eO(cM)local tb=utils.sign(cM)local tc=vec3(b.getWorldAngularVelocity())local td=t2*aJ*cB+t3*aE*cA+t4*aK*qf;if cs==true and cF:len()>0.01 then local te=eO(qc-cM)if((aZ or b4 or b2 or c3 or b1 or bv)and te>0 or c8>0.0 and te<aF and p)and t3==0 and eO(cL)<85 then local tf=qc;local tg=aD;if c8==0 then tg=tg/4;qc=0;tf=0 end;if th==nil then th=pid.new(tg*0.01,0,tg*0.1)end;th:inject(tf-cM)local ti=th:get()td=td+ti*cA end end;local tj=1;local tk=0;local tl=1;bK=0;if c7 and t and cK then if tm==nil then tm=pid.new(0.1,0,1)end;local tn=0;if aQ>0 and not b4 and c8>0.005 and c8<0.1 and cG>-50 then tn=(0.1-c8)*cu*aQ end;tm:inject(cu/3.6+tn-cD:dot(cA))local to=tm:get()bM=d9(to,-1,1)if not d0 then if bM<bJ and c8>0.005 then bL=true;d0=d9(bM,0.01,1)else bL=false;d0=bJ end end;if tp==nil then tp=pid.new(1*0.01,0,1*0.1)end;tp:inject(cD:len()-cu/3.6-tn)local tq=d9(tp:get(),0,1)if c8>0 and cG<-80 or c8>0.005 then bK=tq end;if bK>0 then if bL and bM==0.01 and not d0 then d0=0 end else bM=d9(bM,0.01,1)end;local tr=''local ts=vec3()local tt=sL(axisCommandId.vertical,bS*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tt,tk)local tu='thrust analog longitudinal 'if by=="All"or by=="Longitude"then tu=tu..aR end;local tv=io:getAxisCommandType(axisCommandId.longitudinal)local tw=io:composeAxisAccelerationFromThrottle(tu,axisCommandId.longitudinal)local tx=sY(axisCommandId.lateral,bu*1000)tr=tr..' , '.."lateral airfoil , lateral ground "ts=ts+tx;if ts:len()>constants.epsilon then d:setEngineForceCommand(tr,ts,tk,'','','',tl)end;d:setEngineForceCommand(tu,tw,tj)local ty='thrust analog vertical fueled 'local tz='thrust analog lateral fueled 'if by=="All"or by=="Lateral"then tz=tz..aS end;if by=="All"or by=="Vertical"then ty=ty..aT end;if bS~=0 or b2 and aX or not bi and not bx then d:setEngineForceCommand(ty,tt,tj)else d:setEngineForceCommand(ty,vec3(),tj)end;if bu~=0 then d:setEngineForceCommand(tz,tx,tj)else d:setEngineForceCommand(tz,vec3(),tj)end;if t5==0 then t5=bK end;local tA=-t5*(aL*cD+aM*t9)d:setEngineForceCommand('brake',tA)else if t then if not d0 then d0=bJ end end;local rJ=c.getAxisCommandValue(0)if not cK then if tp==nil then tp=pid.new(1*0.01,0,1*0.1)end;tp:inject(cD:len()-rJ/3.6)local tq=d9(tp:get(),0,1)t5=d9(t5+tq,0,1)end;local tA=-t5*(aL*cD+aM*t9)d:setEngineForceCommand('brake',tA)local tr=''local ts=vec3()local tB=false;local tu='thrust analog longitudinal 'if by=="All"or by=="Longitude"then tu=tu..aR end;local tv=io:getAxisCommandType(axisCommandId.longitudinal)if tv==axisCommandType.byThrottle then local tw=io:composeAxisAccelerationFromThrottle(tu,axisCommandId.longitudinal)d:setEngineForceCommand(tu,tw,tj)elseif tv==axisCommandType.byTargetSpeed then local tw=io:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tr=tr..' , '..tu;ts=ts+tw;if io:getTargetSpeed(axisCommandId.longitudinal)==0 or io:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-io:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tB=true end end;local tz='thrust analog lateral 'if by=="All"or by=="Lateral"then tz=tz..aS end;local tC=io:getAxisCommandType(axisCommandId.lateral)if tC==axisCommandType.byThrottle then local tD=io:composeAxisAccelerationFromThrottle(tz,axisCommandId.lateral)d:setEngineForceCommand(tz,tD,tj)elseif tC==axisCommandType.byTargetSpeed then local tx=io:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tr=tr..' , '..tz;ts=ts+tx end;local ty='thrust analog vertical 'if by=="All"or by=="Vertical"then ty=ty..aT end;local tE=io:getAxisCommandType(axisCommandId.vertical)if tE==axisCommandType.byThrottle then local tt=io:composeAxisAccelerationFromThrottle(ty,axisCommandId.vertical)if bS~=0 or b2 and aX then d:setEngineForceCommand(ty,tt,tj,'airfoil','ground','',tl)else d:setEngineForceCommand(ty,vec3(),tj)d:setEngineForceCommand('airfoil vertical',tt,tj,'airfoil','','',tl)d:setEngineForceCommand('ground vertical',tt,tj,'ground','','',tl)end elseif tE==axisCommandType.byTargetSpeed then if bS<0 then d:setEngineForceCommand('hover',vec3(),tj)end;local tF=io:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tr=tr..' , '..ty;ts=ts+tF end;if ts:len()>constants.epsilon then if t5~=0 or tB or eO(t9:dot(cA))<0.5 then tr=tr..', brake'end;d:setEngineForceCommand(tr,ts,tk,'','','',tl)end end;local tG=aI*(td-tc)local tH=vec3(b.getWorldAirFrictionAngularAcceleration())tG=tG-tH;d:setEngineTorqueCommand('torque',tG,tj,'airfoil','','',tl)d:setBoosterCommand('rocket_engine')if bX and not n then local ff=cC:len()local tI=0.15;if not cK then local tJ=io:getTargetSpeed(axisCommandId.longitudinal)if ff*3.6>tJ*(1-tI)and tK then tK=false;d:toggleBoosters()elseif ff*3.6<tJ*(1-tI)and not tK then tK=true;d:toggleBoosters()end else local pl=c.getThrottle()if t then pl=bJ*100 end;local rJ=pl/100;if bH==0 then rJ=rJ*Z;if ff>=rJ*(1-tI)and tK then tK=false;d:toggleBoosters()elseif ff<rJ*(1-tI)and not tK then tK=true;d:toggleBoosters()end else local rW=bG(cu)rJ=rJ*rW/3.6;if ff>=rJ*(1-tI)and tK then tK=false;d:toggleBoosters()elseif ff<rJ*(1-tI)and not tK then tK=true;d:toggleBoosters()end end end end end;c6=qm()return pO end;local function tL(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,im,io,ip,tM,gB,fL,dU,da,d9,fK,ir,pN)local tN={}local tO=true;local tP=5;local tQ=5;local tR=tP;local tS=tQ;local tT=bI;function tN.startControl(tU)local function tV(sF)local sG=1;local function tW(tX,sF)local tY={j3.surfaceMaxAltitude+100,j3.spaceEngineMinAltitude-0.01*j3.noAtmosphericDensityAltitude,j3.noAtmosphericDensityAltitude+S,j3.radius*(R-1)+j3.noAtmosphericDensityAltitude}local tZ=tX;for dE,dk in ipairs(tY)do if sF and tZ>dk then tX=dk elseif tX<dk and not sF then tX=dk;break end end;return tX end;if sF then sG=-1 end;if not q and cJ then if bU and sF then br=1000 elseif br~=nil then br=br+sG*tQ;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end else br=ss+sG*100 end elseif b1 or b5 or bv then if bv then if bU then cw=tW(cw,sF)else cw=cw+sG*tP end;if cw<j3.noAtmosphericDensityAltitude then cw=j3.noAtmosphericDensityAltitude end else if bU and c7 then b6=tW(b6,sF)else b6=b6+sG*tP end end else io:updateTargetGroundAltitudeFromActionStart(sG*1.0)end end;local function t_(u0)if not c7 then bV="Flight Assist in Atmo only"return end;local dh=type(u0)if cQ==nil then if dh=="table"then if a_ or bm then cm.ToggleAutopilot()end;fK("180On","BR")elseif u0==1 then fK("bnkLft","BR")else fK("bnkRht","BR")end;if not b1 and not a_ and not bm then cm.ToggleAltitudeHold()if dh~="table"then u0=u0+1 end end;cQ=u0 else fK("180Off","BR")cQ=nil end end;if tU=="gear"then bi=not bi;if bi then bm=false;bp=nil;cm.cmdThrottle(0)if vBooster or hover then if c7 and c6==-1 then fK("bklOn","BL")lw=true;b4=false;b3=false;b5=false;b1=false;if b2 then d4=not d4 end;b2=true;cs=true;bi=false else if bO then fK("grOut","LG",1)d.control.extendLandingGears()end;d4=false;io:setTargetGroundAltitude(X)if c7 then aX="Landing"end end end;if bO and not b2 and not(vBooster or hover)then fK("grOut","LG",1)d.control.extendLandingGears()end else if bO then fK("grIn","LG",1)d.control.retractLandingGears()end;io:setTargetGroundAltitude(W)end elseif tU=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif tU=="forward"then bP=bP-1 elseif tU=="backward"then if p7 then t_(-cD*5000)else bP=bP+1 end elseif tU=="left"then if p7 then t_(1)else bQ=bQ-1 end elseif tU=="right"then if p7 then t_(3)else bQ=bQ+1 end elseif tU=="yawright"then bR=bR-1;d5=nil elseif tU=="yawleft"then bR=bR+1;d5=nil elseif tU=="straferight"then io:updateCommandFromActionStart(axisCommandId.lateral,1.0)bu=1 elseif tU=="strafeleft"then io:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bu=-1 elseif tU=="up"then bS=bS+1;io:deactivateGroundEngineAltitudeStabilization()io:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif tU=="down"then bS=bS-1;io:deactivateGroundEngineAltitudeStabilization()io:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif tU=="groundaltitudeup"then tV()elseif tU=="groundaltitudedown"then tV(true)elseif tU=="option1"then u1=false;if p7 and bU then local u2=""for J=1,#cW do u2=u2 .."| Name: "..a.getPlayerName(cW[J]).." Mass: "..fL(b.getBoardedPlayerMass(cW[J])/1000,1).."t "end;a.print("Onboard: "..u2)return end;cl.adjustAutopilotTargetIndex()elseif tU=="option2"then u1=false;if p7 and bU then for J=1,#cW do b.forceDeboard(cW[J])end;bV="Deboarded All Passengers"return end;cl.adjustAutopilotTargetIndex(1)elseif tU=="option3"then local function u3()tO=not tO;if not tO then fK("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(u4,atmofueltank_size,"Atmo Fuel","fuel_container")u5=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(u6,spacefueltank_size,"Space Fuel","fuel_container")u7=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(u8,rocketfueltank_size,"Rocket Fuel","fuel_container")u9=_autoconf.panels[_autoconf.panels_size]end;ua=a.createWidgetPanel("Docking")ub=a.createWidget(ua,"parenting")a.addDataToWidget(c.getDataId(),ub)uc=a.createWidgetPanel("Core combat stress")ud=a.createWidget(uc,"core_stress")a.addDataToWidget(b.getDataId(),ud)if shield_1~=nil then shield_1.show()end else fK("hud","DH")c.hide()b.hide()if u5~=nil then gB(u5)u5=nil end;if ua~=nil then gB(ua)ua=nil end;if uc~=nil then gB(uc)uc=nil end;if u7~=nil then gB(u7)u7=nil end;if u9~=nil then gB(u9)u9=nil end;if shield_1~=nil then shield_1.hide()end end end;u1=false;if p7 and bU then local u2=""for J=1,#cX do u2=u2 .."| ID: "..cX[J].." Mass: "..fL(b.getDockedConstructMass(cX[J])/1000,1).."t "end;a.print("Docked Ships: "..u2)return end;if x then if w then w=false else w=true end end;u3()elseif tU=="option4"then u1=false;if p7 and bU then for J=1,#cX do b.forceUndock(cX[J])end;bV="Undocked all ships"return end;cQ=nil;cm.ToggleAutopilot()elseif tU=="option5"then u1=false;cm.ToggleLockPitch()elseif tU=="option6"then u1=false;if p7 and bU then if shield_1 then cp.ventShield()else bV="No shield found"end;return end;cm.ToggleAltitudeHold()elseif tU=="option7"then u1=false;if p7 and bU then if shield_1 then shield_1.toggle()return else bV="No shield found"return end end;E=not E;if E then bV="Collision System Enabled"else bV="Collision System Secured"end elseif tU=="option8"then u1=false;if p7 and bU then if bh>0 and fW~=nil then cm.routeWP()else bV="Select a saved wp on IPH to add to or remove from route"end;return end;bx=not bx;if not bx then bV="DeCoupled Mode - Ground Stabilization off"io:deactivateGroundEngineAltitudeStabilization()fK("gsOff","GS")else bV="Coupled Mode - Ground Stabilization on"io:activateGroundEngineAltitudeStabilization(ue)d:setEngineForceCommand('hover',vec3(),1)fK("gsOn","GS")end elseif tU=="option9"then u1=false;if p7 and bU then io:resetCommand(axisCommandId.longitudinal)io:resetCommand(axisCommandId.lateral)io:resetCommand(axisCommandId.vertical)cm.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cb=gyro.getState()==1;if cb then fK("gyOn","GA")else fK("gyOff","GA")end else bV="No gyro found"end elseif tU=="lshift"then cU=false;if p7 then bU=true end;if ip()==1 then bU=true;be=ip()tM(1)elseif im()==1 and y then bU=true;cr=false;cq=false end elseif tU=="brake"then if aV or p7 then cm.BrakeToggle("Manual")elseif not aX then cm.BrakeToggle("Manual")else aX="Manual"end elseif tU=="lalt"then u1=true;p7=true;if im()==0 and not i and g=="keyboard"then tM(1)end elseif tU=="booster"then if n then d:toggleBoosters()elseif not bX then if not tK then d:toggleBoosters()tK=true end;bX=true else if tK then d:toggleBoosters()tK=false end;bX=false end elseif tU=="stopengines"then local function uf()if bI-tT<1.5 then fK("clear","CA")cm.clearAll()end end;uf()tT=bI;if io:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bJ~=0 then io:resetCommand(axisCommandId.longitudinal)cm.cmdThrottle(0)else cm.cmdThrottle(100)end else if io:getTargetSpeed(axisCommandId.longitudinal)~=0 then io:resetCommand(axisCommandId.longitudinal)else if c7 then cm.cmdCruise(T)else cm.cmdCruise(Z*3.6)end end end elseif tU=="speedup"then cm.changeSpd()elseif tU=="speeddown"then cm.changeSpd(true)elseif tU=="antigravity"and not q then if antigrav~=nil then cm.ToggleAntigrav()else bV="No antigrav found"end end end;function tN.stopControl(tU)local function ug()if not q and cJ then tS=tQ end;if b1 or b5 or bv then tR=tP end end;if tU=="forward"then bP=0 elseif tU=="backward"then bP=0 elseif tU=="left"then if cQ then if cQ==2 then cQ=-2 else cQ=-1 end end;bQ=0 elseif tU=="right"then if cQ then if cQ==4 then cQ=-2 else cQ=-1 end end;bQ=0 elseif tU=="yawright"then bR=0 elseif tU=="yawleft"then bR=0 elseif tU=="straferight"then io:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bu=0 elseif tU=="strafeleft"then io:updateCommandFromActionStop(axisCommandId.lateral,1.0)bu=0 elseif tU=="up"then bS=0;io:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bx then io:activateGroundEngineAltitudeStabilization(ue)d:setEngineForceCommand('hover',vec3(),1)end elseif tU=="down"then bS=0;io:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bx then io:activateGroundEngineAltitudeStabilization(ue)d:setEngineForceCommand('hover',vec3(),1)end elseif tU=="groundaltitudeup"then ug()u1=false elseif tU=="groundaltitudedown"then ug()u1=false elseif tU=="lshift"then if ip()==1 then c0=0;c1=0;tM(be)elseif im()==1 and y then cr=false;cq=false end;bU=false elseif tU=="brake"then if not aV and not p7 then if aX then cm.BrakeToggle()else aX=false end end elseif tU=="lalt"then if im()==0 and i then if u1 then if ip()==1 then tM(0)else tM(1)end else u1=true end elseif im()==0 and not i and g=="keyboard"then tM(0)end;p7=false end end;function tN.loopControl(tU)local function uh(sF)local sG=1;if sF then sG=-1 end;if not q and cJ then if br~=nil then br=br+sG*tS;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end;tS=d9(tS*1.05,tQ,50)else br=ss+sG*100 end elseif b1 or b5 or bv then if bv then cw=cw+sG*tR;if cw<j3.noAtmosphericDensityAltitude then cw=j3.noAtmosphericDensityAltitude end else b6=b6+sG*tR end;tR=d9(tR*1.05,tP,50)else io:updateTargetGroundAltitudeFromActionLoop(sG*1.0)end end;local function ui(sF)local sG=1;if sF then sG=-1 end;if not bU then if t and not p7 then bJ=d9(bJ+sG*aA/100,-1,1)else io:updateCommandFromActionLoop(axisCommandId.longitudinal,sG*aA)end end end;if tU=="groundaltitudeup"then if not bU then uh()end elseif tU=="groundaltitudedown"then if not bU then uh(true)end elseif tU=="speedup"then ui()elseif tU=="speeddown"then ui(true)end end;function tN.inputTextControl(sE)local function uj(uk,fl,gp)local function ul(fl)local dr=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local ds='::pos{'..dr..','..dr..','..dr..','..dr..','..dr..'}'local dI,dJ,dR,dS,dT=dU(fl,ds)if dI=="0"and dJ=="0"then return vec3(da(dR),da(dS),da(dT))end;dS=math.rad(dS)dR=math.rad(dR)local j3=e[da(dI)][da(dJ)]local eK=math.cos(dR)local um=vec3(eK*math.cos(dS),eK*math.sin(dS),math.sin(dR))return j3.center+(j3.radius+dT)*um end;local fN=ul(fl)return cl.AddNewLocation(uk,fN,gp)end;local J;local un,ib=nil,nil;local uo="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."J=string.find(sE," ")un=sE;if J~=nil then un=string.sub(sE,0,J-1)ib=string.sub(sE,J+1)end;if un=="/help"or un=="/commands"then for lx in string.gmatch(uo,"([^\n]+)")do a.print(lx)end;return elseif un=="/setname"then if ib==nil or ib==""then bV="Usage: ah-setname Newname"return end;if bh>0 and fW~=nil then cl.UpdatePosition(ib)else bV="Select a saved target to rename first"end elseif shield_1 and un=="/resist"then cp.setResist(ib)elseif un=="/addlocation"or string.find(sE,"::pos")~=nil then local gp=false;local uk="0-Temp"if ib==nil or ib==""then ib=un;gp=true end;J=string.find(ib,"::")if not gp then uk=string.sub(ib,1,J-2)end;local fl=string.sub(ib,J)uj(uk,fl,gp)elseif un=="/agg"then if ib==nil or ib==""then bV="Usage: /agg targetheight"return end;ib=da(ib)if ib<1000 then ib=1000 end;br=ib;bV="AGG Target Height set to "..ib elseif un=="/G"then if ib==nil or ib==""then bV="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ib=="dump"then for dz,dk in pairs(ir())do if type(dk.get())=="boolean"then if dk.get()==true then a.print(dz.." true")else a.print(dz.." false")end elseif dk.get()==nil then a.print(dz.." nil")else a.print(dz.." "..dk.get())end end;return end;J=string.find(ib," ")local up=string.sub(ib,0,J-1)local uq=string.sub(ib,J+1)for dz,dk in pairs(ir())do if dz==up then bV="Variable "..up.." changed to "..uq;local ur=type(dk.get())if ur=="number"then uq=da(uq)if dz=="AtmoSpeedLimit"then cu=uq end elseif ur=="boolean"then if string.lower(uq)=="true"then uq=true else uq=false end end;dk.set(uq)return end end;bV="No such global variable: "..up elseif un=="/deletewp"then if bh>0 and fW~=nil then cl.ClearCurrentPosition()else bV="Select a custom wp to delete first in IPH"end elseif un=="/copydatabank"then if dbHud_2 then pN(true)else bV="Spare Databank required to copy databank"end elseif un=="/iphWP"then if bh>0 then a.print(cm.showWayPoint(b_,bg,true))a.print(json.encode(bg))bV="::pos waypoint shown in lua chat in local and world format"else bV="No target selected in IPH"end elseif un=="/createPrivate"then local us="privatelocations = {\n"local ut=""if#d2>0 then for dz,dk in pairs(d2)do us=us.."{position = {x = "..dk.position.x..", y = "..dk.position.y..", z = "..dk.position.z.."},\n ".."name = '"..dk.name.."',\n planetname = '"..dk.planetname.."',\n gravity = "..dk.gravity..",\n"if dk.heading then us=us.."heading = {x = "..dk.heading.x..", y = "..dk.heading.y..", z = "..dk.heading.z.."},\n"end;if dk.safe then us=us.."safe = true},\n"else us=us.."safe = false},\n"end end end;ut=#d2 .."-Private "if ib=="all"then for dz,dk in pairs(bl)do us=us.."{position = {x = "..dk.position.x..", y = "..dk.position.y..", z = "..dk.position.z.."},\n ".."name = '*"..dk.name.."',\n planetname = '"..dk.planetname.."',\n gravity = "..dk.gravity..",\n"if dk.heading then us=us.."heading = {x = "..dk.heading.x..", y = "..dk.heading.y..", z = "..dk.heading.z.."},\n"end;if dk.safe then us=us.." safe = true},\n"else us=us.."safe = false},\n"end end;ut=ut..#bl.."-Public "end;us=us.."}\n return privatelocations"if screenHud_1 then screenHud_1.setHTML(us)end;bV=ut.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bW=7 end end;function tN.tagTick()if by=="Off"then by="All"elseif by=="All"then by="Longitude"elseif by=="Longitude"then by="Lateral"elseif by=="Lateral"then by="Vertical"else by="Off"end;bV="Extra Engine Tags: "..by;c.stopTimer("tagTick")end;return tN end;local function uu(d,b,c,a,library,e,vBooster,hover,pM,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ij,screenHud_1)local uv={}local d8=string.format;local ik=json.decode;local uw=json.encode;local pG=b.getElementMaxHitPointsById;local il=b.getElementMassById;local im=d.control.isRemoteControlled;local dU=string.match;local gB=a.destroyWidgetPanel;local fI=a.updateData;local fJ=a.addDataToWidget;local tM=a.lockView;local ip=a.isViewLocked;local db=math.sqrt;local da=tonumber;local eO=math.abs;local bG=math.floor;local bH=c.getAtmosphereDensity;local eJ=math.atan;local bF=a.getTime;local d9=utils.clamp;local io=d.axisCommandManager;local ux=X;local gD=13;local iu=b.getElementIdList()local iv=0;local function dc(er,es)if er==0 then return eO(es)<1e-09 end;if es==0 then return eO(er)<1e-09 end;return eO(er-es)<math.max(eO(er),eO(es))*dq end;local function fL(dr,uy)local sG=10^(uy or 0)return bG(dr*sG+0.5)/sG end;local function iq(uz,uA)for dz,dk in pairs(uA)do if type(dz)=="string"then uz[dz]=dk else uz[#uz+1]=uA[dz]end end;return uz end;local function ir(uB)local uC={}if not uB then iq(uC,I)iq(uC,a7)iq(uC,ay)iq(uC,aU)return uC elseif uB=="boolean"then return I elseif uB=="handling"then return a7 elseif uB=="hud"then return ay elseif uB=="physics"then return aU end end;local function pN(uD)local function uE(uF)for dz,dk in pairs(uF)do dbHud_1.setStringValue(dz,uw(dk.get()))if uD and dbHud_2 then dbHud_2.setStringValue(dz,uw(dk.get()))end end end;if dbHud_1 then uE(bC)uE(ir())a.print("Saved Variables to Datacore")if uD and dbHud_2 then bV="Databank copied.  Remove copy when ready."end end end;local function fK(uG,uH,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uG..".mp3")end;local function gC(hd,he,sE,jI,uI)if jI==nil then jI=""end;if uI==nil then uI=""end;return d8([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jI,hd,he,uI,sE)end;local function is(c2,uJ)local uK=c2>100000;if uJ==nil then uJ=1 end;if uK then return fL(c2/1000/200,uJ).."SU"elseif c2<1000 then return fL(c2,uJ).."M"else return fL(c2/1000,uJ).."KM"end end;local function it(uL)local uM=0;local uN=0;local uO=0;if uL<60 then uL=bG(uL)elseif uL<3600 then uM=bG(uL/60)uL=bG(uL%60)elseif uL<86400 then uN=bG(uL/3600)uM=bG(uL%3600/60)else uO=bG(uL/86400)uN=bG(uL%86400/3600)end;if uO>0 then return uO.."d "..uN.."h "elseif uN>0 then return uN.."h "..uM.."m "elseif uM>0 then return uM.."m "..uL.."s"elseif uL>0 then return uL.."s"else return"0s"end end;function uv.onStart()local uP=false;local function uQ()local function uR(uS)local uT=dbHud_1.hasKey;for dz,dk in pairs(uS)do if uT(dz)then local du=ik(dbHud_1.getStringValue(dz))if du~=nil then dk.set(du)uP=true end end end end;if dbHud_1 then if not f then uR(ir())coroutine.yield()uR(bC)else uR(bC)bV="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bW=5;uP=false end;coroutine.yield()if uP then bV="Loaded Saved Variables"cc=a8;cd=a9;aV=j;g=string.lower(g)cs=p;cu=T elseif not f then bV="No Saved Variables Found - Exit HUD to save settings"end;if bz<1.500 then if S<2000 then bV="Updating LowOrbitHeight to new minimum default of 2000."S=2000 end end;bz=VERSION_NUMBER;if#bl>0 then d3=iq(d3,bl)end else bV="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bs+180<bI then bq=0 end;bs=bI;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bV="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bW=7 end;if antigrav and not q then if br==nil then br=c9 end;antigrav.setBaseAltitude(br)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d2>0 then d3=iq(d3,d2)end end;lF="Proceeding to Waypoint"end;local function uU()local function uV(uW,uX)if uW>uX then uX=uW end;local uY,uZ=0,0;if a4>0 then uY=a4*0.05 end;if a5>0 then uZ=a5*0.05 end;uX=uX*(1-(uY+uZ))return uX end;local u_=b.getElementNameById;local v0=ap~=0 and aq~=0;for dz in pairs(iu)do local type=b.getElementTypeById(iu[dz])if dU(type,'^.*Atmospheric Engine$')then if dU(tostring(b.getElementTagsById(iu[dz])),'^.*vertical.*$')and b.getElementForwardById(iu[dz])[3]>0 then cI=true end end;if dU(type,'^.*Space Engine$')then cz=true;if dU(tostring(b.getElementTagsById(iu[dz])),'^.*vertical.*$')then local v1=b.getElementForwardById(iu[dz])if v1[3]<0 then v2=true else cy=true end end end;if type=="Landing Gear"then bO=true end;if type=="Dynamic Core Unit"then local pI=pG(iu[dz])if pI>10000 then gD=110 elseif pI>1000 then gD=55 elseif pI>150 then gD=27 end end;iv=iv+pG(iu[dz])if v0 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pI=pG(iu[dz])local ov=il(iu[dz])local uW=0;local jC=bF()if type=="Atmospheric Fuel Tank"then local uX=400;local v3=35.03;if pI>10000 then uX=51200;v3=5480 elseif pI>1300 then uX=6400;v3=988.67 elseif pI>150 then uX=1600;v3=182.67 end;uW=ov-v3;if a1>0 then uX=uX+uX*a1*0.2 end;uX=uV(uW,uX)ce[#ce+1]={iu[dz],u_(iu[dz]),uX,v3,uW,jC}end;if type=="Rocket Fuel Tank"then local uX=320;local v3=173.42;if pI>65000 then uX=40000;v3=25740 elseif pI>6000 then uX=5120;v3=4720 elseif pI>700 then uX=640;v3=886.72 end;uW=ov-v3;if a3>0 then uX=uX+uX*a3*0.1 end;uX=uV(uW,uX)cg[#cg+1]={iu[dz],u_(iu[dz]),uX,v3,uW,jC}end;if type=="Space Fuel Tank"then local uX=600;local v3=35.03;if pI>10000 then uX=76800;v3=5480 elseif pI>1300 then uX=9600;v3=988.67 elseif pI>150 then uX=2400;v3=182.67 end;uW=ov-v3;if a2>0 then uX=uX+uX*a2*0.2 end;uX=uV(uW,uX)cf[#cf+1]={iu[dz],u_(iu[dz]),uX,v3,uW,jC}end end end;if not cI then b5,aW=false,false end end;local function v4()if gyro~=nil then cb=gyro.getState()==1 end;if not bx then io:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then tM(1)else tM(0)end;if door and(c7 or not c7 and c9<10000)then for dE,dk in pairs(door)do dk.toggle()end end;if switch then for dE,dk in pairs(switch)do dk.toggle()end end;if forcefield and(c7 or not c7==0 and c9<10000)then for dE,dk in pairs(forcefield)do dk.toggle()end end;if antigrav then cJ=antigrav.getState()==1;if cJ and not q then antigrav.show()end end;if im()==1 and k then a.freeze(1)else a.freeze(0)end;if bO then bi=d.control.isAnyLandingGearExtended()==1;if bi then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if c6~=-1 or not c7 and cC:len()<50 then aX="Startup"bi=true;if bO then d.control.extendLandingGears()end else aX=false end;io:setTargetGroundAltitude(ux)pu=c7 end;local function v5()local v6={}local function v7()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local v8={[1]=4480,[6]=4480,[7]=6270}for v9,va in pairs(e)do e[v9][0]=v7()e[v9][0].systemId=v9;v6[v9]={}for vb,j3 in pairs(e[v9])do j3.gravity=j3.gravity/9.8;j3.center=vec3(j3.center)j3.name=j3.name[1]j3.noAtmosphericDensityAltitude=j3.atmosphereThickness or j3.atmosphereRadius-j3.radius;if j3.name=="Lacobus"then j3.noAtmosphericDensityAltitude=12510 end;j3.spaceEngineMinAltitude=v8[j3.id]or 0.68377*j3.atmosphereThickness;j3.planetarySystemId=v9;j3.bodyId=j3.id;v6[v9][vb]=j3;if mx==nil or j3.center.x<mx then mx=j3.center.x end;if mw==nil or j3.center.x>mw then mw=j3.center.x end;if mA==nil or j3.center.y<mA then mA=j3.center.y end;if mz==nil or j3.center.y>mz then mz=j3.center.y end;if j3.center and j3.name~="Space"then cY[#cY+1]=j3 end end end;e3=d7(d,b,c,a,d8,d9,da,db,dc)ch=e3(v6)ci=eN(d,b,c,a,db,eO)cj=fh(d,b,c,a,d8,d9,da,db,dc)cl=fH(d,b,c,a,dbHud_1,e,fI,fJ,bG,da,db,fK,fL)end;vc=false;vd=coroutine.create(function()io:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})uQ()coroutine.yield()uU()coroutine.yield()cm=pL(d,b,c,a,e,vBooster,hover,pM,antigrav,warpdrive,dbHud_1,eO,bG,bH,im,eJ,bF,d9,io,fI,ip,db,fL,fK,iq,dc,is,it,pN,ik,d8,fJ)v4()coroutine.yield()v5()if radar_1 then cn=gA(b,a,c,library,radar_1,radar_2,eO,gB,db,gC,da,gD,fK)end;ck=ii(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ij,eO,bG,d8,ik,bH,il,im,eJ,bF,d9,io,fJ,fI,gB,ip,db,fL,gC,fK,iq,ir,is,it,iu,iv)ck.ButtonSetup()co=tL(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,im,io,ip,tM,gB,fL,dU,da,d9,fK,ir,pN)if shield_1 then cp=i2(shield_1,dU,bG)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aO)if radar_1 then c.setTimer("radarTick",aO)end;c.setTimer("hudTick",aP)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield_1 then c.setTimer("shieldTick",aO)end;fK("start","SU")end)coroutine.resume(vd)end;function uv.onUpdate()if not vc then local hT=coroutine.status(vd)if hT=="suspended"then local dA,hU=coroutine.resume(vd)if hU then a.print("ERROR STARTUP: "..hU)end elseif hT=="dead"then vc=true end end;if vc then d:update()if c7 and t and cK then if cK and bN then cm.cmdThrottle(0)bN=false elseif not cK and not bN then bJ=0;bN=true end end;if d0 then io:setThrottleCommand(axisCommandId.longitudinal,d0)d0=nil end;if not cq and p9~=ve then a.setScreen(p9)end;ve=p9 end end;function uv.onFlush()if vc then cm.onFlush()end end;function uv.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c8>0 or c8==0 and c9<10000)then for dE,dk in pairs(door)do dk.toggle()end end;if switch then for dE,dk in pairs(switch)do dk.toggle()end end;if forcefield and(c8>0 or c8==0 and c9<10000)then for dE,dk in pairs(forcefield)do dk.toggle()end end;w=c_;pN()if o4 then o4.activate()end;if z then cm.showWayPoint(j3,cH)end;a.print(ck.FuelUsed("atmofueltank")..", "..ck.FuelUsed("spacefueltank")..", "..ck.FuelUsed("rocketfueltank"))fK("stop","SU")end;function uv.controlStart(tU)if vc then co.startControl(tU)end end;function uv.controlStop(tU)if vc then co.stopControl(tU)end end;function uv.controlLoop(tU)if vc then co.loopControl(tU)end end;function uv.controlInput(sE)if vc then co.inputTextControl(sE)end end;function uv.radarEnter(dJ)cn.onEnter(dJ)end;function uv.radarLeave(dJ)cn.onLeave(dJ)end;function uv.onTick(vf)if vf=="tenthSecond"then cm.TenthTick()ck.TenthTick()elseif vf=="oneSecond"then ck.OneSecondTick()elseif vf=="fiveSecond"then cm.SatNavTick()elseif vf=="msgTick"then ck.MsgTick()elseif vf=="animateTick"then ck.AnimateTick()elseif vf=="hudTick"then ck.hudtick()elseif vf=="apTick"then cm.APTick()elseif vf=="radarTick"then cn.UpdateRadar()elseif vf=="shieldTick"then cp.shieldTick()elseif vf=="tagTick"then co.tagTick()elseif vf=="contact"then cn.ContactTick()end end;return uv end;function script.onStart()vg.onStart()end;function script.onStop()vg.onStop()end;function script.onTick(vf)vg.onTick(vf)end;function script.onFlush()vg.onFlush()end;function script.onUpdate()vg.onUpdate()end;function script.onActionStart(tU)vg.controlStart(tU)end;function script.onActionStop(tU)vg.controlStop(tU)end;function script.onActionLoop(tU)vg.controlLoop(tU)end;function script.onInputText(sE)vg.controlInput(sE)end;function script.onEnter(dJ)vg.radarEnter(dJ)end;function script.onLeave(dJ)vg.radarLeave(dJ)end;bE(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)vg=uu(d,b,c,a,library,e,vBooster,hover,pM,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ij,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
