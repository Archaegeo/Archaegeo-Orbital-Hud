name: ArchHud - Archaegeo v0.015 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.015;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.3;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab=1;ac={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end},DockingMode={set=function(M)ab=M end,get=function()return ab end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV=1.0;aW="none"aX="none"aY="none"aZ=0.05;a_=0.0;b0={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aV=M end,get=function()return aV end},ExtraLongitudeTags={set=function(M)aW=M end,get=function()return aW end},ExtraLateralTags={set=function(M)aX=M end,get=function()return aX end},ExtraVerticalTags={set=function(M)aY=M end,get=function()return aY end},allowedHorizontalDrift={set=function(M)aZ=M end,get=function()return aZ end},FastOrbit={set=function(M)a_=M end,get=function()return a_ end}}b1=k;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=false;bc=false;bd=1000;be=false;bf=false;bg=false;bh=false;bi=0;bj="Aligning"bk=0;bl=1;bm="None"bn=nil;bo=0;bp=nil;bq=0.0;br=0;bs={}bt=false;bu=0;bv=0;bw=nil;bx=0;by=1000;bz=0;bA=false;bB=0;bC=false;bD="All"bE=true;bF="Off"bG=0.000;bH={}bI={}bJ={}bK=false;bL={VertTakeOff={set=function(M)bc=M end,get=function()return bc end},VertTakeOffEngine={set=function(M)b2=M end,get=function()return b2 end},SpaceTarget={set=function(M)bA=M end,get=function()return bA end},BrakeToggleStatus={set=function(M)b1=M end,get=function()return b1 end},BrakeIsOn={set=function(M)b3=M end,get=function()return b3 end},RetrogradeIsOn={set=function(M)b4=M end,get=function()return b4 end},ProgradeIsOn={set=function(M)b5=M end,get=function()return b5 end},Autopilot={set=function(M)b6=M end,get=function()return b6 end},TurnBurn={set=function(M)b7=M end,get=function()return b7 end},AltitudeHold={set=function(M)b8=M end,get=function()return b8 end},BrakeLanding={set=function(M)b9=M end,get=function()return b9 end},Reentry={set=function(M)bb=M end,get=function()return bb end},AutoTakeoff={set=function(M)ba=M end,get=function()return ba end},HoldAltitude={set=function(M)bd=M end,get=function()return bd end},AutopilotAccelerating={set=function(M)be=M end,get=function()return be end},AutopilotBraking={set=function(M)bg=M end,get=function()return bg end},AutopilotCruising={set=function(M)bh=M end,get=function()return bh end},AutopilotRealigned={set=function(M)bf=M end,get=function()return bf end},AutopilotEndSpeed={set=function(M)bi=M end,get=function()return bi end},AutopilotStatus={set=function(M)bj=M end,get=function()return bj end},AutopilotPlanetGravity={set=function(M)bk=M end,get=function()return bk end},PrevViewLock={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetName={set=function(M)bm=M end,get=function()return bm end},AutopilotTargetCoords={set=function(M)bn=M end,get=function()return bn end},AutopilotTargetIndex={set=function(M)bo=M end,get=function()return bo end},TotalDistanceTravelled={set=function(M)bq=M end,get=function()return bq end},TotalFlightTime={set=function(M)br=M end,get=function()return br end},SavedLocations={set=function(M)bs=M end,get=function()return bs end},VectorToTarget={set=function(M)bt=M end,get=function()return bt end},LocationIndex={set=function(M)bu=M end,get=function()return bu end},LastMaxBrake={set=function(M)bv=M end,get=function()return bv end},LockPitch={set=function(M)bw=M end,get=function()return bw end},LastMaxBrakeInAtmo={set=function(M)bx=M end,get=function()return bx end},AntigravTargetAltitude={set=function(M)by=M end,get=function()return by end},LastStartTime={set=function(M)bz=M end,get=function()return bz end},iphCondition={set=function(M)bD=M end,get=function()return bD end},stablized={set=function(M)bE=M end,get=function()return bE end},UseExtra={set=function(M)bF=M end,get=function()return bF end},SelectedTab={set=function(M)bM=M end,get=function()return bM end},saveRoute={set=function(M)bH=M end,get=function()return bH end},apRoute={set=function(M)bI=M end,get=function()return bI end},ecuThrottle={set=function(M)bJ=M end,get=function()return bJ end},HoverMode={set=function(M)bK=M end,get=function()return bK end}}local function bN(b,c,bO,bP,bQ)local a=DUSystem;local bR=DUConstruct;bS=bO()bT=0;bU=0;bV=false;bW=0;bX=false;bY=false;bZ=0;b_=0;c0=0;c1=0;c2=false;c3=false;c4=false;c5="empty"c6=3;c7=false;c8=0;c9=0;ca=nil;cb=0;cc=0;cd=0;ce=false;cf=false;cg=false;ch=-1;ci=bQ()>0;cj=bQ()ck=b.getAltitude()cl=DUConstruct.getMass()cm=nil;cn={}co={}cp={}cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=nil;cy=nil;cz=false;cA=false;cB=q;cC=false;cD=W;cE=nil;cF=0;cG=false;cH=false;cI=false;cJ=vec3(bR.getWorldOrientationForward())cK=vec3(bR.getWorldOrientationRight())cL=vec3(bR.getVelocity())cM=vec3(bR.getWorldVelocity())cN=vec3(cM):len()cO=vec3(b.getWorldVertical())cP=-cO:dot(cM)cQ=vec3(bR.getWorldPosition())cR=false;cS=false;cT=true;cU=0;cV=0;cW={}cX=false;cY=50000;cZ=nil;c_=c.getClosestPlanetInfluence()>0 or ck>0 and ck<200000;d0=false;d1=nil;d2=false;d3=0;d4={}d5={}d6={}d7=90;d8=w;d9=nil;da=nil;db={}dc={}dd=false;de=nil;df=0;dg=false;dh=bR.getMaxSpeed()if shield then di=bP(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dj(dk)a.print(bS..": "..dk)end;local function dl(d,b,c,a,dm,dn,dp,dq,dr)local function ds(dt)return type(dt)=='number'end;local function du(dt)return type(dp(dt))=='number'end;local function dv(dw)return type(dw)=='table'end;local function dx(a)return type(a)=='string'end;local function dy(dz)return dv(dz)and ds(dz.x and dz.y and dz.z)end;local function dA(dB)return dv(dB)and ds(dB.latitude and dB.longitude and dB.altitude and dB.id and dB.systemId)end;local dC=math.pi/180;local dD=180/math.pi;local dE=1e-10;local dF=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dG='::pos{'..dF..','..dF..','..dF..','..dF..','..dF..'}'local utils=utils;local vec3=vec3;local function dH(dt)local dI=string.gsub(string.reverse(dm('%.4f',dt)),'^0*%.?','')return dI==''and'0'or string.reverse(dI)end;local function dJ(dK)if dy(dK)then return dm('{x=%.3f,y=%.3f,z=%.3f}',dK.x,dK.y,dK.z)end;if dv(dK)and not getmetatable(dK)then local dL={}local dM=next(dK)if type(dM)=='nil'or dM==1 then dL=dK else for dN,dz in pairs(dK)do local dO=dJ(dz)if type(dN)=='number'then table.insert(dL,dm('[%s]=%s',dN,dO))else table.insert(dL,dm('%s=%s',dN,dO))end end end;return dm('{%s}',table.concat(dL,','))end;if dx(dK)then return dm("'%s'",dK:gsub("'",[[\']]))end;return tostring(dK)end;local dP={}dP.__index=dP;dP.__tostring=function(dK,dQ)local dR={}for dN in pairs(dK)do table.insert(dR,dN)end;table.sort(dR)local dL={}for dS,dN in ipairs(dR)do local dO=dJ(dK[dN])if type(dN)=='number'then table.insert(dL,dm('[%s]=%s',dN,dO))else table.insert(dL,dm('%s=%s',dN,dO))end end;if dQ then return dm('%s%s',dQ,table.concat(dL,',\n'..dQ))end;return dm('{%s}',table.concat(dL,','))end;dP.__eq=function(dT,dU)return dT.systemId==dU.systemId and dT.id==dU.id and dr(dT.radius,dU.radius)and dr(dT.center.x,dU.center.x)and dr(dT.center.y,dU.center.y)and dr(dT.center.z,dU.center.z)and dr(dT.GM,dU.GM)end;local function dV(dW,dX,dY,dZ,d_)assert(du(dW),'Argument 1 (systemId) must be a number:'..type(dW))assert(du(dX),'Argument 2 (id) must be a number:'..type(dX))assert(du(dY),'Argument 3 (radius) must be a number:'..type(dY))assert(dv(dZ),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dZ))assert(du(d_),'Argument 5 (GM) must be a number:'..type(d_))return setmetatable({systemId=dp(dW),id=dp(dX),radius=dp(dY),center=vec3(dZ),GM=dp(d_)},dP)end;local e0={}e0.__index=e0;e0.__tostring=function(dj)return dm('::pos{%d,%d,%s,%s,%s}',dj.systemId,dj.id,dH(dj.latitude*dD),dH(dj.longitude*dD),dH(dj.altitude))end;e0.__eq=function(dT,dU)return dT.id==dU.id and dT.systemId==dU.systemId and dr(dT.latitude,dU.latitude)and dr(dT.altitude,dU.altitude)and(dr(dT.longitude,dU.longitude)or dr(dT.latitude,math.pi/2)or dr(dT.latitude,-math.pi/2))end;local function e1(e2,dX,e3,e4,e5)local dW=e2;if dx(e2)and not e4 and not e5 and not dX and not e3 then dW,dX,e3,e4,e5=e6(e2,dG)assert(dW,'Argument 1 (position string) is malformed.')else assert(du(dW),'Argument 1 (systemId) must be a number:'..type(dW))assert(du(dX),'Argument 2 (id) must be a number:'..type(dX))assert(du(e3),'Argument 3 (latitude) must be in degrees:'..type(e3))assert(du(e4),'Argument 4 (longitude) must be in degrees:'..type(e4))assert(du(e5),'Argument 5 (altitude) must be in meters:'..type(e5))end;dW=dp(dW)dX=dp(dX)e3=dp(e3)e4=dp(e4)e5=dp(e5)if dX==0 then return setmetatable({latitude=e3,longitude=e4,altitude=e5,id=dX,systemId=dW},e0)end;return setmetatable({latitude=dC*dn(e3,-90,90),longitude=dC*(e4%360),altitude=e5,id=dX,systemId=dW},e0)end;local e7={}e7.__index=e7;e7.__tostring=function(dK,dQ)local e8=dQ and dQ..'  'local e9={}local dR={}for dN in pairs(dK)do table.insert(dR,dN)end;table.sort(dR)for dS,ea in ipairs(dR)do eb=dK[ea]local ec=dP.__tostring(eb,e8)if dQ then table.insert(e9,dm('[%s]={\n%s\n%s}',ea,ec,dQ))else table.insert(e9,dm('  [%s]=%s',ea,ec))end end;if dQ then return dm('\n%s%s%s',dQ,table.concat(e9,',\n'..dQ),dQ)end;return dm('{\n%s\n}',table.concat(e9,',\n'))end;local function ed(ee)local e={}local pid;for dS,dz in pairs(ee)do local dX=dz.planetarySystemId;if type(dX)~='number'then error('Invalid planetary s ID: '..tostring(dX))elseif pid and dX~=pid then error('Mistringmatch planetary s IDs: '..dX..' and '..pid)end;local ef=dz.bodyId;if type(ef)~='number'then error('Invalid body ID: '..tostring(ef))elseif e[ef]then error('Duplicate body ID: '..tostring(ef))end;setmetatable(dz.center,getmetatable(vec3.unit_x))e[ef]=setmetatable(dz,dP)pid=dX end;return setmetatable(e,e7)end;eg={}local function eh(ee)return setmetatable({galaxyAtlas=ee or{}},eg)end;eg.__index=function(dw,M)if type(M)=='number'then local a=dw.galaxyAtlas[M]return ed(a)end;return rawget(eg,M)end;eg.__pairs=function(dK)return function(dw,dN)local ei,ej=next(dw,dN)return ei,ej and ed(ej)end,dK.galaxyAtlas,nil end;eg.__tostring=function(dK)local ek={}for dS,el in pairs(dK or{})do local em=el:getPlanetarySystemId()local en=e7.__tostring(el,'    ')table.insert(ek,dm('  [%s]={%s\n  }',em,en))end;return dm('{\n%s\n}\n',table.concat(ek,',\n'))end;eg.BodyParameters=dV;eg.MapPosition=e1;eg.PlanetarySystem=ed;function eg.createBodyParameters(dW,dX,eo,ep,eq,er,es)assert(du(dW),'Argument 1 (systemId) must be a number:'..type(dW))assert(du(dX),'Argument 2 (id) must be a number:'..type(dX))assert(du(eo),'Argument 3 (surfaceArea) must be a number:'..type(eo))assert(dv(ep),'Argument 4 (aPosition) must be an array or vec3:'..type(ep))assert(dv(eq),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eq))assert(du(er),'Argument 6 (altitude) must be in meters:'..type(er))assert(du(es),'Argument 7 (gravityAtPosition) must be number:'..type(es))local dY=dq(eo/4/math.pi)local cd=dY+er;local et=vec3(ep)+cd*vec3(eq)local d_=es*cd*cd;return dV(dW,dX,dY,et,d_)end;eg.isMapPosition=dA;function eg:getPlanetarySystem(e2)if M==nil then M=0 end;if ej==nil then ej=0 end;local dW=e2;if dA(e2)then dW=e2.systemId end;if type(dW)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(ej)~=e7 then a=ed(a)end;return a end end end;function e7:sizeCalculator(eu)return 1.05*eu.radius end;function e7:castIntersections(ev,ew,ex,ey,ez,eA)local eB={}if ez then for dS,eu in pairs(ez)do table.insert(eB,eu)end else eB=d6 end;if not eA then table.sort(eB,function(eC,eD)local eE=eC.center;local eF=eD.center;return(eE.x-ev.x)^2+(eE.y-ev.y)^2+(eE.z-ev.z)^2<(eF.x-ev.x)^2+(eF.y-ev.y)^2+(eF.z-ev.z)^2 end)end;local eG=ew:normalize()for dS,eu in ipairs(eB)do local eH=eu.center-ev;local dY;if ex then dY=ex(eu)else dY=self:sizeCalculator(eu)end;local eI=eH:dot(eG)local eJ=eI^2-(eH:len2()-dY^2)if eJ>=0 then local eK=dq(eJ)local eL=eI+eK;local eM=eI-eK;if eM>0 then return eu,eL,eM elseif eL>0 then return eu,eL,nil end end end;return nil,nil,nil end;function e7:closestBody(eN)assert(type(eN)=='table','Invalid coordinates.')local eO,eu;local eP=vec3(eN)for dS,eQ in pairs(self)do local eR=(eQ.center-eP):len2()if(not eu or eR<eO)and eQ.name~="Space"then eu=eQ;eO=eR end end;return eu end;function e7:convertToBodyIdAndWorldCoordinates(e2)local eS=e2;if dx(e2)then eS=e1(e2)end;if eS.id==0 then return 0,vec3(eS.latitude,eS.longitude,eS.altitude)end;local eQ=self:getBodyParameters(eS)if eQ then return eS.id,eQ:convertToWorldCoordinates(eS)end end;function e7:getBodyParameters(e2)local dX=e2;if dA(e2)then dX=e2.id end;assert(du(dX),'Argument 1 (id) must be a number:'..type(dX))return self[dX]end;function e7:getPlanetarySystemId()local dS,dz=next(self)return dz and dz.systemId end;function dP:convertToMapPosition(dZ)assert(dv(dZ),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dZ))local eT=vec3(dZ)if self.id==0 then return setmetatable({latitude=eT.x,longitude=eT.y,altitude=eT.z,id=0,systemId=self.systemId},e0)end;local eU=eT-self.center;local cd=eU:len()local e5=cd-self.radius;local e3=0;local e4=0;if not dr(cd,0)then local eV=eW(eU.y,eU.x)e4=eV>=0 and eV or 2*math.pi+eV;e3=math.pi/2-math.acos(eU.z/cd)end;return setmetatable({latitude=e3,longitude=e4,altitude=e5,id=self.id,systemId=self.systemId},e0)end;function dP:convertToWorldCoordinates(e2)local eS=dx(e2)and e1(e2)or e2;if eS.id==0 then return vec3(eS.latitude,eS.longitude,eS.altitude)end;assert(dA(eS),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eS.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eS.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eX=math.cos(eS.latitude)return self.center+(self.radius+eS.altitude)*vec3(eX*math.cos(eS.longitude),eX*math.sin(eS.longitude),math.sin(eS.latitude))end;function dP:getAltitude(dZ)return(vec3(dZ)-self.center):len()-self.radius end;function dP:getDistance(dZ)return(vec3(dZ)-self.center):len()end;function dP:getGravity(dZ)local eY=self.center-vec3(dZ)local eZ=eY:len2()return self.GM/eZ*eY/dq(eZ)end;return setmetatable(eg,{__call=function(dS,...)return eh(...)end})end;local function e_(d,b,c,a,dq,f0)local cr={}local f1=100;function cr.computeAccelerationTime(f2,f3,f4)return(f4-f2)/f3 end;function cr.computeDistanceAndTime(f2,f4,f5,f6,f7,f8)f7=f7 or 0;f8=f8 or 0;local f9=f2<f4;local fa=f6/(f9 and f5 or-f5)local fb=-f8/f5;local fc=fa+fb;if f2==f4 then return 0,0 elseif f9 and fc<=0 or not f9 and fc>=0 then return-1,-1 end;local fd,fe=0,0;if fa~=0 and f7>0 then local ff=math.pi/f7/2;local dz=function(dw)return fa*(dw/2-f7*math.sin(ff*dw)/math.pi)+fb*dw+f2 end;local fg=f9 and function(a)return a>=f4 end or function(a)return a<=f4 end;fe=2*f7;if fg(dz(fe))then local fh=0;while math.abs(fe-fh)>0.25 do local dw=(fe+fh)/2;if fg(dz(dw))then fe=dw else fh=dw end end end;local fi=2*fa*f7^2/math.pi^2;fd=fi*(math.cos(ff*fe)-1)+(fa+2*fb)*fe^2/4+f2*fe;if fe<2*f7 then return fd,fe end;f2=dz(fe)end;local eE=fa+fb;local dw=cr.computeAccelerationTime(f2,eE,f4)local fj=f2*dw+eE*dw*dw/2;return fd+fj,fe+dw end;function cr.computeTravelTime(f2,f3,cd)if cd==0 then return 0 end;if f3~=0 then return(math.sqrt(2*f3*cd+f2^2)-f2)/f3 end;assert(f2>0,'Acceleration and initial speed are both zero.')return cd/f2 end;return cr end;local function fk(d,b,c,a,dm,dn,dp,dq,dr)local vec3=vec3;local dl=dl(d,b,c,a,dm,dn,dp,dq,dr)local function dx(a)return type(a)=='string'end;local function dv(dw)return type(dw)=='table'end;fl={}fl.__index=fl;function fl:escapeAndOrbitalSpeed(e5)assert(self.body)local cd=e5+self.body.radius;if not dr(cd,0)then local fm=dq(self.body.GM/cd)return dq(2)*fm,fm end;return nil,nil end;function fl:orbitalParameters(e2,fn)assert(self.body)assert(dv(e2)or dx(e2))assert(dv(fn))local fo=(dx(e2)or dl.isMapPosition(e2))and self.body:convertToWorldCoordinates(e2)or vec3(e2)local dz=vec3(fn)local fp=fo-self.body.center;local fq=dz:len2()local fj=fp:len()local fr=self.body.GM;local fs=((fq-fr/fj)*fp-fp:dot(dz)*dz)/fr;local eE=fr/(2*fr/fj-fq)local ft=fs:len()local eG=fs:normalize()local fu=eE*(1-ft)local fv=eE*(1+ft)local fw=fu*eG+self.body.center;local fx=ft<=1 and-fv*eG+self.body.center or nil;local fy=dq(eE*fr*(1-ft*ft))local fz=fx and 2*math.pi*dq(eE^3/fr)local fA=math.acos(fs:dot(fp)/(ft*fj))if fp:dot(dz)<0 then fA=-(fA-2*math.pi)end;local fB=math.acos((math.cos(fA)+ft)/(1+ft*math.cos(fA)))local fC=fB;if fC<0 then fC=fC+2*math.pi end;local fD=fC-ft*math.sin(fC)local fE=0;local fF=0;local fG=0;if fz~=nil then fE=fD/(2*math.pi/fz)fF=fz-fE;fG=fF+fz/2;if fA-math.pi>0 then fF=fE;fG=fF+fz/2 end;if fG>fz then fG=fG-fz end end;return{periapsis={position=fw,speed=fy/fu,circularOrbitSpeed=dq(fr/fu),altitude=fu-self.body.radius},apoapsis=fx and{position=fx,speed=fy/fv,circularOrbitSpeed=dq(fr/fv),altitude=fv-self.body.radius},currentVelocity=dz,currentPosition=fo,eccentricity=ft,period=fz,eccentricAnomaly=fB,meanAnomaly=fD,timeToPeriapsis=fF,timeToApoapsis=fG,trueAnomaly=fA}end;local function fH(fI)local eQ=dl.BodyParameters(fI.systemId,fI.id,fI.radius,fI.center,fI.GM)return setmetatable({body=eQ},fl)end;return setmetatable(fl,{__call=function(dS,...)return fH(...)end})end;local function fJ(d,b,c,a,dbHud_1,e,fK,fL,bP,dp,dq,fM,fN,dk)local function fO(fP)local dj=fQ:closestBody(fP)if(fP-dj.center):len()>dj.radius+dj.noAtmosphericDensityAltitude then dj=e[0][0]end;return dj end;local function fR()local function fS(fT,fU)return fT.name<fU.name end;cW={}for dN,dz in pairs(e[0])do cW[#cW+1]={name=dz.name,index=dN}end;table.sort(cW,fS)end;local function fV(fW,fX)if not fX then fX=fY.name end;for dN,dz in pairs(fW)do if dz.name and dz.name==fX then return dN end end;return-1 end;local function fZ()d3=bo;if bo==0 then bm="None"ca=nil;fY=nil;return true end;local f_=cW[bo].index;local g0=e[0][f_]if g0.center then bm=g0.name;ca=cq[0][f_]if fY~=nil then if cj==0 then if fK(g1,g2)~=1 then fL(g1,g2)end;if fK(g3,g4)~=1 then fL(g3,g4)end;if fK(g5,g6)~=1 then fL(g5,g6)end;if fK(g7,g8)~=1 then fL(g7,g8)end;if fK(g9,ga)~=1 then fL(g9,ga)end end;if fK(gb,gc)~=1 then fL(gb,gc)end;if fK(gd,ge)~=1 then fL(gd,ge)end;if fK(gf,gg)~=1 then fL(gf,gg)end end;fY=nil else fY=g0;for dS,dz in pairs(cq[0])do if dz.name==fY.planetname then ca=dz;bm=fY.name;break end end;if fK(gb,gc)~=1 then fL(gb,gc)end;if fK(gd,ge)~=1 then fL(gd,ge)end end;if fY==nil then bn=vec3(ca.center)else bn=fY.position end;if ca.planetname~="Space"then if ca.hasAtmosphere then gh=bP(ca.radius*(U-1)+ca.noAtmosphericDensityAltitude)else gh=bP(V+ca.surfaceMaxAltitude)end else gh=T end;if fY~=nil and fY.planetname=="Space"then bi=0 else dS,bi=cs(ca):escapeAndOrbitalSpeed(gh)end;bk=0;be=false;bg=false;bh=false;b6=false;bf=false;bj="Aligning"return true end;local function gi(gj)if not b6 and not bt and not cf and not bC and not bb and not cg then if gj==nil then bo=bo+1;if bo>#cW then bo=0 end else bo=bo-1;if bo<0 then bo=#cW end end;if bo==0 then fZ()else local f_=cW[bo].index;local g0=e[0][f_]if g0 and(g0~=nil and g0.name=="Space"or bD=="Custom Only"and g0.center or bD=="No Moons-Asteroids"and(string.find(g0.name,"Moon")~=nil or string.find(g0.name,"Asteroid")~=nil))then if gj==nil then gi()else gi(1)end else fZ()end end else dk("Disengage autopilot before changing Interplanetary Helper")fM("iph","AP")end end;local function gk()local function gl(gm)local gn;if gm then gn=db else gn=bs end;local go=-1;go=fV(e[0])if go>-1 then table.remove(e[0],go)end;go=-1;go=fV(gn)if go~=-1 then dk(fY.name.." saved location cleared")table.remove(gn,go)end;gi()fR()return gn end;if string.sub(bm,1,1)=="*"then db=gl(true)else bs=gl(false)end end;local function gp(gq,fP,gr,gs)local function gt(gm)if gm then gn=db else gn=bs end;if dbHud_1 or gr or gm then local dj=fO(fP)local gu={position=fP,name=gq,planetname=dj.name,gravity=b.getGravityIntensity(),safe=gs}if not gr then gn[#gn+1]=gu else for dN,dz in pairs(e[0])do if dz.name and gq==dz.name then table.remove(e[0],dN)end end end;table.insert(e[0],gu)fR()fZ()dk("Location saved as "..gq.."("..dj.name..")")return gn else dk("Databank must be installed to save permanent locations")end end;if string.sub(gq,1,1)=="*"then db=gt(true)else bs=gt(false)end end;local gv={}function gv.UpdateAtlasLocationsList()fR()end;function gv.UpdateAutopilotTarget()fZ()end;function gv.adjustAutopilotTargetIndex(gj)gi(gj)end;function gv.findAtlasIndex(fW,fX)return fV(fW,fX)end;function gv.UpdatePosition(gw,gx,gy)local function gz(gm)local gn;if gm then gn=db else gn=bs end;local go=fV(gn)if go~=-1 then if gw~=nil then if gm then gw="*"..gw end;gn[go].name=gw;bo=bo-1;gi()elseif gy~=nil then if gy then local gA=ck;if gA<1000 then gA=1000 end;gn[go].agg=fN(gA,0)dk(gn[go].name.." AGG Altitude:"..gn[go].agg.." saved ("..gn[go].planetname..")")return elseif gy==false then gn[go].agg=nil;dk(gn[go].name.." AGG Altitude cleared ("..gn[go].planetname..")")return end else local gB=gn[go]if gx then gB.heading=cK:cross(cO)*5000;dk(gn[go].name.." heading saved ("..gn[go].planetname..")")return elseif gx==false then gB.heading=nil;dk(gn[go].name.." heading cleared ("..gn[go].planetname..")")return end;gB.gravity=b.getGravityIntensity()gB.position=cQ;gB.safe=true end;dk(gn[go].name.." position updated ("..gn[go].planetname..")")else dk("Name Not Found")end end;if string.sub(bm,1,1)=="*"then gz(true)else gz(false)end end;function gv.AddNewLocation(gq,fP,gr,gs)gp(gq,fP,gr,gs)end;function gv.ClearCurrentPosition()gk()end;for dN,dz in pairs(dc)do table.insert(e[0],dz)end;if gC then for dN,dz in pairs(gC)do gv[dN]=dz end end;fR()if bo>#cW then bo=0 end;gv.UpdateAutopilotTarget()return gv end;local function gD(b,a,c,radar_1,radar_2,warpdrive,f0,gE,dq,gF,dp,gG,fM,dk)local gH={}local gI={}local gJ={XS=13,S=27,M=55,L=110,XL=221}local gK={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gL={}local gM=0;local gN;local gO;local gP=0;local gQ;local gR={gQ}local gS="Atmo"local gT;local gU;local gV=0;local gW={}local gX;local gY=0;local gZ=table.insert;local g_=-4;local h0={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h1,h2;local h3,h4;local h5;local h6;local h7;local h8;local h9;local ha;local hb;local function hc()if hd~=nil and gV==0 then gE(hd)a.destroyWidget(h1)a.destroyData(h3)h1,h3,hd=nil,nil,nil;if gU~=nil then gE(gU)a.destroyWidget(h2)a.destroyData(h4)gU,h2,h4=nil,nil,nil end else if gV==1 then gU=a.createWidgetPanel("PeriWinkle")h2=a.createWidget(gU,'periscope')h4=gQ.getWidgetDataId()a.addDataToWidget(h4,h2)end;if hd==nil and gM>0 then hd=a.createWidgetPanel(gS)h1=a.createWidget(hd,'radar')h3=gQ.getWidgetDataId()a.addDataToWidget(h3,h1)end;gV=0 end end;local function he()local function hf(hg,hh,hi,hj,hk,hl,hm,hn)hh,hj,hl,hn=vec3(hh),vec3(hj),vec3(hl),vec3(hn)local ho,hp,hq=hg*hg,hi*hi,hk*hk;local fq=hj-hh;local hr=fq:normalize()local hs=fq:len()local ht=hl-hh;local hu=(ht-ht:project_on(hr)):normalize()local hv,hw=ht:dot(hr),ht:dot(hu)local hx=hv*hv+hw*hw;local hy=hr:cross(hu)local hz=(ho-hp+hs*hs)/(2*hs)local hA=(ho-hq+hx-2*hv*hz)/(2*hw)local dB=ho-hz^2-hA^2;local hB=dq(dB)local hC=hh+hr*hz+hu*hA+hy*hB;local hD=hh+hr*hz+hu*hA-hy*hB;if f0((hn-hC):len()-hm)<f0((hn-hD):len()-hm)then return hC else return hD end end;local function hE(hF,fj,hG)local hH=hF.pts;local go=#hH;local hI=hF.ref;if go>3 then local hJ,hK,hL,hM=hH[go],hH[go-1],hH[go-2],hH[go-3]hF.ref=hG;local fo=hf(hJ[1],hJ[2],hK[1],hK[2],hL[1],hL[2],hM[1],hM[2])local hz,hA,hB=fo.x,fo.y,fo.z;if hz==hz and hA==hA and hB==hB then hz=hz+hI[1]hA=hA+hI[2]hB=hB+hI[3]local hN=vec3(hz,hA,hB)hF.center=hN;if hF.lastPos then if(hF.lastPos-hN):len()<2 then local hO=(hN-vec3(hG)):len()if f0(hO-fj)<10 then hF.skipCalc=true end end end;hF.lastPos=hN end;hF.pts={}else local hP={hG[1]-hI[1],hG[2]-hI[2],hG[3]-hI[3]}hH[go+1]={fj,hP}end end;if radar_1 or radar_2 then cw.assignRadar()end;if gQ then if#gX>0 then local hQ,hR=0,0;local hS=cN*10;local c_=c_;gP,gO=0,0;gI={}for dS,dz in pairs(gX)do local cd=h9(dz)if cd>0.0 then if h5(dz)==1 then gZ(gI,dz)end;if not cX and warpdrive and cd<aa and warpdrive.getStatus()==15 then dk("INITIATING WARP")c6=7;warpdrive.initiate()end;local hT=F and h7(dz)==1;if E or hT then local hU=ha(dz)local hV=gJ[hU]local hW=h6(dz)if hT or cd<hS and(hV>27 or hW==4 or hW==6)then gP=gP+1;local hG={cQ["x"],cQ["y"],cQ["z"]}local hF=gW[dz]if hF==nil then hV=hV+gG;gW[dz]={pts={},ref=hG,name=h8(dz),i=0,radius=hV,skipCalc=false}hF=gW[dz]end;if not hF.skipCalc then if hT or hW==4 or hW==6 then hF.center=vec3(hb(dz))hF.skipCalc=true else hE(hF,cd,hG)hR=hR+1 end;if hT and not hF.abandoned then local bS=a.getArkTime()if gY+5<bS then gY=bS;fM("abRdr","RD")end;a.print("Abandoned Construct: "..hF.name.." ("..hU.." "..gK[hW]..") at ::pos{0,0,"..hF.center.x..","..hF.center.y..","..hF.center.z.."}")dk("Abandoned Radar Contact ("..hU.." "..gK[hW]..") detected")hF.abandoned=true end else gZ(gL,hF)end end;hQ=hQ+1;if hQ>300 or hR>30 then coroutine.yield()hQ,hR=0,0 end end end end;gO=#gL;if gO>0 and(cN>20 or b9)then local eu,hX,hY,hZ;local h_=0;local i0=cq:getPlanetarySystem(0)hZ=cM:normalize()while h_<gO do coroutine.yield()local i1={table.unpack(gL,h_,math.min(h_+75,gO))}eu,hX,hY=i0:castIntersections(cQ,hZ,nil,nil,i1,true)if eu and hY then d1={eu,hX,hY}break end;h_=h_+75 end;if not eu then d1=nil end else d1=nil end;gL={}gN=gQ.getTargetId()end end end;local function i2()if gQ then gS="Atmo"if string.find(gQ.getName(),"Space")then gS="Space"end end end;function gH.pickType()i2()end;function gH.assignRadar()if radar_2 and g_~=1 then if g_==-1 then if gQ==radar_2 then gQ=radar_1 else gQ=radar_2 end end;gR={gQ}h5=gQ.hasMatchingTransponder;h6=gQ.getConstructKind;h7=gQ.isConstructAbandoned;h8=gQ.getConstructName;h9=gQ.getConstructDistance;ha=gQ.getConstructCoreSize;hb=gQ.getConstructWorldPos;gX=gQ.getConstructIds()i2()else gX=gQ.getConstructIds()end;g_=gQ.getOperationalState()end;function gH.UpdateRadar()local i3=coroutine.status(gT)if i3=="suspended"then local dO,i4=coroutine.resume(gT)if i4 then a.print("ERROR UPDATE RADAR: "..i4)end elseif i3=="dead"then gT=coroutine.create(he)local dO,i4=coroutine.resume(gT)end end;function gH.GetRadarHud(i5,i6,ay,az)local i7,dk;local dF=gO or 0;gM=#gX;if gM>0 then if E then dk=dF.."/"..gP.." Known/InRange : "..gM.." Total"else dk="Radar Contacts: "..gM end;i7=gF(ay,az,dk,"pbright txtbig txtmid")if#gI>0 then i7=i7 ..gF(i5,i6,"Friendlies In Range","pbright txtbig txtmid")for dN,dz in pairs(gI)do i6=i6+20;i7=i7 ..gF(i5,i6,gQ.getConstructName(dz),"pdim txtmid")end end;local i8=#gQ.getIdentifiedConstructIds()if gU==nil and i8>0 then gV=1;cw.ToggleRadarPanel()end;if gU~=nil and i8==0 then cw.ToggleRadarPanel()end;if hd==nil then if w then cw.ToggleRadarPanel()end end else if g_~=1 then i7=gF(ay,az,gS.." Radar: "..h0[g_],"pbright txtbig txtmid")else i7=gF(ay,az,"Radar: No "..gS.." Contacts","pbright txtbig txtmid")end;if hd~=nil then gV=0;cw.ToggleRadarPanel()end end;return i7 end;function gH.GetClosestName(gq)if gQ then local i9=gQ.getConstructName(gQ.getConstructIds()[1])if i9 then gq=gq.." "..i9 end end;return gq end;function gH.ToggleRadarPanel()hc()end;function gH.ContactTick()if not ia then ia=0 end;if bS>ia+10 then dk("Radar Contact")fM("rdrCon","RC")ia=bS end;c.stopTimer("contact")end;function gH.onEnter(dX)if gQ and not ci and not cX then c.setTimer("contact",0.1)end end;function gH.onLeave(dX)if gQ and E then if#gW>650 then dX=tostring(dX)gW[dX]=nil end end end;local function ib()gQ=nil;if radar_2 and radar_2.getOperationalState()==1 then gQ=radar_2 else gQ=radar_1 end;g_=gQ.getOperationalState()h5=gQ.hasMatchingTransponder;h6=gQ.getConstructKind;h7=gQ.isConstructAbandoned;h8=gQ.getConstructName;h9=gQ.getConstructDistance;ha=gQ.getConstructCoreSize;hb=gQ.getConstructWorldPos;gR={gQ}gX=gQ.getConstructIds()i2()gT=coroutine.create(he)if ic then for dN,dz in pairs(ic)do gH[dN]=dz end end end;ib()return gH end;local function id(shield,e6,bP,dk)local ie={}local ig=shield.getResistancesCooldown()local function ih()local ii=shield.isActive()if G then if not cX and ii==0 and shield.isVenting()~=1 then shield.toggle()elseif cX and ii==1 then shield.toggle()end end end;local function ij()local ik=shield.getStressRatioRaw()local il=0.5999;if ik[1]==0.0 and ik[2]==0.0 and ik[3]==0.0 and ik[4]==0.0 then return end;local im=shield.setResistances(il*ik[1],il*ik[2],il*ik[3],il*ik[4])if im==1 then dk("Shield Resistances updated")else dk("Value Exceeded. Failed to update Shield Resistances")end end;function ie.shieldTick()di=bP(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ih()ig=shield.getResistancesCooldown()if ig==0 and di<a9 then ij()end end;function ie.setResist(io)if not shield then dk("No shield found")return elseif io==nil or ig>0 then dk("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dF=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dG=dF..', '..dF..', '..dF..', '..dF;local ip,iq,ir,is=e6(io,dG)if is==nil or ip+iq+ir+is>0.6 then dk("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(ip,iq,ir,is)==1 then dk("Shield Resistances set")else dk("Resistance setting failed.")end end;function ie.ventShield()local it=shield.getVentingCooldown()if it>0 then dk("Cannot vent again for "..it.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()dk("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else dk("Shields already at max hitpoints")end end;if iu then for dN,dz in pairs(iu)do ie[dN]=dz end end;return ie end;local function iv(d,b,c,a,e,antigrav,hover,shield,warpdrive,iw,f0,bP,dm,ix,bQ,iy,iz,eW,bO,dn,iA,fL,fK,gE,iB,dq,fN,gF,fM,iC,iD,iE,iF,iG,iH,dk)local bR=DUConstruct;local iI=9.80665;local iJ={}local iK={}local iL={}local iM={}local iN=nil;local iO=nil;local iP=nil;local iQ=false;local iR="none"local iS=""local iT=55;local iU=0;local iV=0;local iW=nil;local iX=ag;local iY=ah;local iZ=ai;local i_=[[rgb(]]..bP(iX+0.5)..","..bP(iY+0.5)..","..bP(iZ+0.5)..[[)]]local j0=[[rgb(]]..bP(iX*0.9+0.5)..","..bP(iY*0.9+0.5)..","..bP(iZ*0.9+0.5)..[[)]]local j1=0;local j2=0;local j3=""local j4=bO()local j5=false;local j6=false;local gQ=false;local function j7(dz)if ad==1920 then return dz else return fN(ad*dz/1920,0)end end;local function j8(dz)if ae==1080 then return dz else return fN(ae*dz/1080,0)end end;local function j9()return iB()==0 and g~="keyboard"and iz()==0 end;local function ja()local jb="TRAVEL"if not cT then jb="CRUISE"end;if b6 then jb="AUTOPILOT"end;return jb end;local i7=""local jc=""local jd=""local je=1;local jf=2;local jg=3;local jh=4;local ji=5;local jj=6;local jk=7;local jl=""local jm=0;local jn=90.0*aU;local jo={}local jp={}local jq={}local jr={}local js={}local jt={}local ju={}ju["atmofueltank"],ju["spacefueltank"],ju["rocketfueltank"]=0,0,0;local jv=0;local function jw(hz,jx,jy,jz,jA,jB)local jC=jv;local jD=jv+5;if not B then jD=jD+5 end;if iz()==1 and not m then jC=jC-50;jD=jD-50 end;if jy=="ATMO"then jl="atmofueltank"elseif jy=="SPACE"then jl="spacefueltank"else jl="rocketfueltank"end;jm=_G[jl.."_size"]if#jz>0 then for M=1,#jz do local gq=jz[M][jf]local jE=jz[M][jk]for jF=1,jm do if jz[M][jf]==ix(c[jl.."_"..jF].getWidgetData()).name then jE=jF;break end end;local jG=bO()if jA[M]==nil or jB[M]==nil or jG-jz[M][jj]>jn then local jH;local jI=0;jI=iy(jz[M][je])-jz[M][jh]jH=jz[M][ji]local jJ=jH>jI or false;if jJ then ju[jl]=ju[jl]+jH-jI end;if jE~=0 then local jK=ix(c[jl.."_"..jE].getWidgetData())jB[M]=jK.percentage;jA[M]=jK.timeLeft;if jA[M]=="n/a"then jA[M]=0 end else jB[M]=bP(0.5+jI*100/jz[M][jg])if jJ then jA[M]=bP(0.5+jI/((jH-jI)/(jG-jz[M][jj])))else jA[M]=0 end end;jz[M][jj]=jG;jz[M][ji]=jI end;if gq==jx then gq=dm("%s %d",jy,M)end;if jE==0 then gq=gq.." *"end;local jL;jL=iF(jA[M])if jA[M]==0 or jL==">1y"then jL=""end;if jB[M]~=nil then local jM=bP(jB[M]*2.55)local jN=dm("rgb(%d,%d,%d)",255-jM,jM,0)local jO=""if jL~=""and jA[M]<120 or jB[M]<5 then jO="red "end;local jP=dm("rgb(%d,%d,%d)",dn(bP((255-jM)/2.55),50,100),dn(bP(jM/2.55),0,50),50)local jQ="rgb(196,0,255)"if jy=="ATMO"then jQ="rgb(0,188,255)"elseif jy=="SPACE"then jQ="rgb(239,255,0)"end;local jR=false;if jS~=jQ then jR=true end;jS=jQ;if B then if jR then jC=jC-5;jD=jD-5 end;jc=jc..dm([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jP,jQ,hz,jD,jN,bP(jB[M]*1.7+0.5)-2,hz+1,jD+1,hz+5,jD+14,gq,jB[M],jL)jC=jC-22;jD=jD-22 else jc=jc..gF(hz,jC,gq,jO.."pdim txtfuel")jc=jc..gF(hz,jD,dm("%d%% %s",jB[M],jL),"pdim txtfuel","fill:"..jN)jC=jC+30;jD=jD+30 end end end end;jv=jC end;local function jT(jU,e5)if aq==0 and ar==0 then return end;if e5<200000 and not ci or e5 and ci then local jV=0;if f0(cP)>1 then jV=45*math.log(f0(cP),10)if cP<0 then jV=-jV end end;jU[#jU+1]=dm([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bP(cP),bP(jV))end;return jU end;local function jW(jX)local gj=-cO;jX=jX-jX:project_on(gj)local jY=vec3(0,0,1)jY=jY-jY:project_on(gj)local jZ=jY:cross(gj)local jV=jY:angle_between(jX)*constants.rad2deg;if jX:dot(jZ)<0 then jV=360-jV end;return jV end;local function j_(jU,am,an,k0,k1,c_)if af==0 then return end;local k2=af;local k3=20;local k4=bP(k0)if c_ then for M=-45,45,5 do local k5=M;jU[#jU+1]=dm([[<g transform="rotate(%f,%d,%d)">]],k5,am,an)k6=5;if M%15==0 then k6=15 elseif M%10==0 then k6=10 end;jU[#jU+1]=dm([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+k2+k3-k6,am,an+k2+k3)end;jU[#jU+1]=gF(am,an+k2+k3-35,k1,"pdim txt txtmid")jU[#jU+1]=gF(am,an+k2+k3-25,k4 .." deg","pdim txt txtmid")jU[#jU+1]=dm([[<g transform="rotate(%f,%d,%d)">]],-k0,am,an)jU[#jU+1]=dm([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+k2+k3-20,am+5,an+k2+k3-20,am,an+k2+k3-15)jU[#jU+1]="</g>"end;jU[#jU+1]=[[<g style="clip-path: url(#headingClip);">]]local k7=k4;if c_ then k7=jW(cJ)end;local k8=20;local k9=bP(k7)local ka=0;local kb=an+k2+k3+20;local kc=am;if k1~="YAW"then kb=j8(130)kc=j7(960)end;local kd=[[<path class="txttick line" d="]]local ke=bP(k9-(k8+10)-k9%5+0.5)for M=ke+70,ke,-5 do local hz=kc-(-M*5+k7*5)if M%10==0 then ka=10;local dF=M;if dF==360 then dF=0 elseif dF>360 then dF=dF-360 elseif dF<0 then dF=dF+360 end;jU[#jU+1]=gF(hz,kb+15,dF,"txtmid bright")elseif M%5==0 then ka=5 end;if ka==10 then kd=dm([[%s M %f %f v %d]],kd,hz,kb-5,ka)else kd=dm([[%s M %f %f v %d]],kd,hz,kb-2.5,ka)end end;jU[#jU+1]=kd..[["/>]]jU[#jU+1]=dm([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kc-5,kb-20,kc+5,kb-20,kc,kb-10)if c_ then k1="HDG"end;jU[#jU+1]=gF(j7(960),j8(100),k9 .."°","dim txt txtmid size14","")jU[#jU+1]=gF(j7(960),j8(85),k1,"dim txt txtmid size20","")jU[#jU+1]=[[</g>]]end;local function kf(jU,kg,k0,am,an,c_,kh,ki)if af==0 then return end;local k2=af;local kj=bP(k2*3/5)if k2>0 then local kk=bP(kg)local k6=0;local kd=dm([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k0,am,an)if not ci then kd=dm([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;jU[#jU+1]=dm([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k2-1,am,an)jU[#jU+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bP(kk-30-kk%5+0.5),bP(kk+30+kk%5+0.5),5 do if M%10==0 then k6=30 elseif M%5==0 then k6=20 end;local hA=an+-M*5+kg*5;if k6==30 then kd=dm([[%s M %d %f h %d]],kd,am-kj-k6,hA,k6)if ci then jU[#jU+1]=dm([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k0,am,an,am-kj+10,hA+4,M)jU[#jU+1]=dm([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k0,am,an,am+kj-10,hA+4,M)if M==0 or M==180 or M==-180 then jU[#jU+1]=dm([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k0,am,an,am-kj+20,hA,kj*2-40)end else jU[#jU+1]=gF(am-kj+10,hA,M,"pdim txt txtmid")jU[#jU+1]=gF(am+kj-10,hA,M,"pdim txt txtmid")end;kd=dm([[%s M %d %f h %d]],kd,am+kj,hA,k6)else kd=dm([[%s M %d %f h %d]],kd,am-kj-k6,hA,k6)kd=dm([[%s M %d %f h %d]],kd,am+kj,hA,k6)end end;jU[#jU+1]=kd..[["/>]]local kl="PITCH"if not c_ then kl="REL PITCH"end;if kg>90 and not ci then kg=90-(kg-90)elseif kg<-90 and not ci then kg=-90-(kg+90)end;if k2>200 then if ci then if ki>iT then jU[#jU+1]=gF(am,an-15,"Yaw","pdim txt txtmid")jU[#jU+1]=gF(am,an+20,kh,"pdim txt txtmid")end;jU[#jU+1]=dm([[<g transform="rotate(%f,%d,%d)">]],-k0,am,an)else jU[#jU+1]=dm([[<g transform="rotate(0,%d,%d)">]],am,an)end;jU[#jU+1]=dm([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-kj+25,an-5,am-kj+20,an,am-kj+25,an+5,am-kj+50,an+4,kk)jU[#jU+1]=dm([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+kj-25,an-5,am+kj-20,an,am+kj-25,an+5,am+kj-30,an+4,kk)jU[#jU+1]="</g>"end;local km=bP(k2/3)jU[#jU+1]=dm([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-km,an,k2-km)if not ci and c_ then jU[#jU+1]=dm([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k0,am,an,am-kj+10,an,kj*2-20)end;jU[#jU+1]="</g>"if k2<200 then if ci and ki>iT then jU[#jU+1]=gF(am,an-k2,kl,"pdim txt txtmid")jU[#jU+1]=gF(am,an-k2+10,kk,"pdim txt txtmid")jU[#jU+1]=gF(am,an-15,"Yaw","pdim txt txtmid")jU[#jU+1]=gF(am,an+20,kh,"pdim txt txtmid")else jU[#jU+1]=gF(am,an-k2,kl,"pdim txt txtmid")jU[#jU+1]=gF(am,an-k2+15,kk,"pdim txt txtmid")end end end end;local function kn(jU,e5,c_)local ko=as;local kp=at;if ko==0 and kp==0 then return end;local kq=78;local kr=19;local ks=ch;if ch~=-1 then jU[#jU+1]=gF(ko+kq,kp+kr+20,dm("AGL: %.1fm",ch),"pdim altsm txtend")end;if c_ and(e5<200000 and not ci or e5 and ci)then jU[#jU+1]=gF(ko+kq,kp-10,dm("%s",kt.name),"pdim altsm txtend")table.insert(jU,dm([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ko-1,kp-4,kq+2,kr+6,ko+1,kp-1,kq-4,kr))local go=0;local ku=1;local kv=0;local kw=e5<0;local kx=e5<kt.surfaceMaxAltitude;local ky=9;if kw then ky=0 end;local e5=f0(e5)while go<6 do local kz=11;local kA=16;local kB=9;local kC=14;local jO="altsm"if go>2 then kA=kA+3;kz=kz+2;kC=kC+2;kB=kB-6;jO="altbig"end;if kw then jO=jO.." red"elseif kx then jO=jO.." orange"end;local kD=e5/ku%10;local kE=bP(kD)local kF=bP((kE+1)%10)local kG=kv;if go==0 then kG=kD-kE;if kw then kG=1-kG end end;if kw and(go==0 or kv~=0)then local gr=kF;kF=kE;kE=gr end;local kH=kA*(kG-1)local kI=kH+kA;local hz=ko+kB+(6-go)*kz;local hA=kp+kC;jU[#jU+1]=gF(hz,hA+kH,kF,jO)jU[#jU+1]=gF(hz,hA+kI,kE,jO)go=go+1;ku=ku*10;if kE==ky then kv=kG else kv=0 end end;table.insert(jU,[[</g></g>]])end end;local function kJ(fn)local kK=-math.deg(eW(fn.y,fn.z))+180;kK=kK-90;if kK<0 then kK=360+kK end;if kK>180 then kK=-180+kK-180 end;return-kK end;local function kL(fn)local k7=math.deg(eW(fn.y,fn.x))-90;if k7<-180 then k7=360+k7 end;return k7 end;local function kM(jU,fn,ki,am,an)if ki>5 and not ci or ki>iT then local k2=af;local kN=20;local kO=20;local kP=kJ(fn)local kQ=kL(fn)local kR=14;local kS=kR/2;local kT=-kQ/kO*k2;local kU=kP/kN*k2;local hz=am+kT;local hA=an+kU;local cd=dq(kT^2+kU^2)local kV=[[<circle
                            cx="]]..hz..[["
                            cy="]]..hA..[["
                            r="]]..kS/kR..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hz..[["
                            cy="]]..hA..[["
                            r="]]..kS..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hz-kR..[[,]]..hA..[[ h ]]..kS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hz+kS..[[,]]..hA..[[ h ]]..kS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hz..[[,]]..hA-kR..[[ v ]]..kS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cd<k2 then jU[#jU+1]=kV else local jV=eW(kU,kT)local kW=4;local kX=am+k2*math.cos(jV)local kY=an+k2*math.sin(jV)jU[#jU+1]=dm('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jV*180/math.pi,kX,kY,kX-kW,kY-kW/2,kW*2,kW,kX+kW,kY-kW,kW,kW,-kW,kW)end;if not ci then local kZ=vec3(fn)kP=kJ(-kZ)kQ=kL(-kZ)kT=-kQ/kO*k2;kU=kP/kN*k2;hz=am+kT;hA=an+kU;cd=dq(kT^2+kU^2)if cd<k2 then local k_=[[<circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hz..[[,]]..hA-kR..[[ v ]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hz..[[,]]..hA..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hz..[[,]]..hA..[[)" />
                                <path
                                    d="M ]]..hz-kS..[[,]]..hA..[[ h ]]..kR..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hz..[[,]]..hA..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hz..[[,]]..hA..[[)"/>]]jU[#jU+1]=k_ end end end end;local function l0(jU,jb,l1,l2)if ao==0 and ap==0 then return end;l1=bP(l1+0.5)local jC=ap+10;local jD=ap+20;if iz()==1 and not m then jC=55;jD=65 end;local l3="CRUISE"local c="km/h"local dO=l2;if jb=="TRAVEL"or jb=="AUTOPILOT"then l3="THROT"c="%"dO=l1;local l4="dim"if l1<0 then l4="red"end;jU[#jU+1]=dm([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l4,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-f0(l1),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;jU[#jU+1]=gF(ao+10,jC,l3,"pbright txtstart")jU[#jU+1]=gF(ao+10,jD,dm("%.0f %s",dO,c),"pbright txtstart")if ci and t and cT and bV then l1=bP(bW*100+0.5)local l4="red"if l1<0 then l4="red"end;jU[#jU+1]=dm([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l4,1-f0(l1),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)jU[#jU+1]=gF(ao+10,jC+40,"LIMIT","pbright txtstart")jU[#jU+1]=gF(ao+10,jD+40,l1 .."%","pbright txtstart")end;if ci and t or bb then jU[#jU+1]=gF(ao+10,jC-40,"LIMIT: "..cD.." km/h","dim txtstart")elseif not ci and b6 then jU[#jU+1]=gF(ao+10,jC-40,"LIMIT: "..bP(a1*3.6+0.5).." km/h","dim txtstart")end end;local function l5(jU,l6)if ao==0 and ap==0 then return end;local l7=ap-10;local l8=ao+10;jU[#jU+1]=gF(0,0,"","pdim txt txtend")if iz()==1 and not m then l7=75 end;jU[#jU+1]=gF(l8,l7,bP(l6).." km/h","pbright txtbig txtstart")end;local l9=40;local function la(jU)jU[#jU+1]=gF(j7(150),j8(1070),dm("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jU[#jU+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jU[#jU+1]=gF(j7(960),j8(550),"Warning: Invalid Control Scheme Detected","warnings")jU[#jU+1]=gF(j7(960),j8(600),"Keyboard Scheme must be selected","warnings")jU[#jU+1]=gF(j7(960),j8(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lb=j7(960)local lc=j8(860)local ld=j8(880)local le=j8(900)local lf=j8(960)local lg=j8(200)local lh=j8(250)local li=j8(960)if iz()==1 and not m then lc=j8(135)ld=j8(155)le=j8(175)lg=j8(115)lh=j8(95)end;if b3 then local lj=""if type(b3)=="string"then lj="-"..b3 end;jU[#jU+1]=gF(lb,lc,"Brake Engaged"..lj,"warnings")elseif bU>0 then jU[#jU+1]=gF(lb,lc,"Auto-Brake Engaged","warnings","opacity:"..bU)end;if ci and cC and ch==-1 then if not b6 and not bt and not b9 and not cS and not bc and not ba then jU[#jU+1]=gF(lb,lg+50,"** STALL WARNING **","warnings")fM("stall","SW",2)end end;if cZ then jU[#jU+1]=gF(lb,lg+90,"Flight Assist in Progress","warnings")end;if cm then jU[#jU+1]=gF(lb,li,"Gyro Enabled","warnings")end;if lk then l9=l9-1;if l9>20 then jU[#jU+1]=gF(lb,li-20,"ECU Enabled","warnings")elseif l9<0 then l9=40 end end;if bp then if bY then jU[#jU+1]=gF(lb,ld,"Gear Extended","warn")else jU[#jU+1]=gF(lb,ld,"Landed (G: Takeoff)","warnings")end end;if ch>-1 and(not cS or ck<100)then local ll=iE(d:getTargetGroundAltitude())jU[#jU+1]=gF(lb,le,"Hover Height: "..ll,"warn")end;if c7 then jU[#jU+1]=gF(lb,lf+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cS and by~=nil then local lm="warnings"if f0(ck-antigrav.getBaseAltitude())<501 then lm="warn"end;jU[#jU+1]=gF(lb,lg+40,dm("Target Altitude: %d Singularity Altitude: %d",bP(by),bP(antigrav.getBaseAltitude())),lm)end;if b6 and bm~="None"then jU[#jU+1]=gF(lb,lg,"Autopilot "..bj,"warn")elseif bw~=nil then jU[#jU+1]=gF(lb,lg+20,dm("LockedPitch: %d",bP(bw)),"warn")elseif c2 then jU[#jU+1]=gF(lb,lg+20,"Follow Mode Engaged","warn")elseif bb or cg then jU[#jU+1]=gF(lb,lg+20,"Re-entry in Progress","warn")end;if b8 or bc then local ll=iE(bd,2)if bc then if cS then ll=iE(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jU[#jU+1]=gF(lb,lg,"VTO to "..ll,"warn")elseif(ba or cf)and not bC then if cf then jU[#jU+1]=gF(lb,lg,"Takeoff to "..bm,"warn")else jU[#jU+1]=gF(lb,lg,"Takeoff to "..ll,"warn")end;if b3 and not bc then jU[#jU+1]=gF(lb,lg+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jU[#jU+1]=gF(lb,lg,"Altitude Hold: "..dm("%.1fm",bd),"warn")end end;if bc and(antigrav~=nil and antigrav)then if cj>0.1 then jU[#jU+1]=gF(lb,lg+20,"Beginning ascent","warn")elseif cj<0.09 and cj>0.05 then jU[#jU+1]=gF(lb,lg+20,"Aligning trajectory","warn")elseif cj<0.05 then jU[#jU+1]=gF(lb,lg+20,"Leaving atmosphere","warn")end end;if bC then if cE~=nil then jU[#jU+1]=gF(lb,lg,cE,"warn")end end;if b9 then local ln="Brake Landing"if de then ln=ln.."-Aligning"end;if dd then ln=ln.."-Drift Limited"end;jU[#jU+1]=gF(lb,lg,ln,"warnings")end;if b5 then jU[#jU+1]=gF(lb,lg+20,"Prograde Alignment","crit")end;if b4 then jU[#jU+1]=gF(lb,lg,"Retrograde Alignment","crit")end;if d0 then local type;if string.find(d0,"COLLISION")then type="warnings"else type="crit"end;jU[#jU+1]=gF(lb,lh+20,d0,type)elseif cj==0 then local lo,lp=cv.checkLOS(cM:normalize())if lp~=nil and cN>0 then local ll=iE(lp)local lq=cr.computeTravelTime(cN,0,lp)local lr="Collision"if lo.noAtmosphericDensityAltitude>0 then lr="Atmosphere"end;jU[#jU+1]=gF(lb,lh+20,lo.name.." "..lr.." "..iF(lq).." In "..ll,"crit")end end;if bt and not bC then jU[#jU+1]=gF(lb,lg+60,ls,"warn")end;if d4 and#d4>1 then end;local lt=j7;local lu=j8;local lv="topButton"local lw="topButtonActive"local lx=lv;if b6 or bt or cf or bC then lx=lw end;local ly=lv;if b5 then ly=lw end;local lz=lv;if b9 or bp then lz=lw end;local lA=lv;if b8 or bt then lA=lw end;local lB=lv;if b4 then lB=lw end;local lC=lv;if bC or cG and b6 then lC=lw end;if w and I then local lD=lu(30)jU[#jU+1]=dm([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lx,lt(960),lu(54),lu(-53),lt(-120),lt(25),lu(50))jU[#jU+1]=gF(lt(910),lD,"AUTOPILOT")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ly,lt(865),lu(51),lt(-25),lu(-50),lt(-110),lt(25),lu(46))jU[#jU+1]=gF(lt(800),lD,"PROGRADE")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lz,lt(755),lu(47),lt(-25),lu(-46),lt(-98),lt(44),lu(44))jU[#jU+1]=gF(lt(700),lD,"LAND")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lA,lt(960),lu(54),lu(-53),lt(120),lt(-25),lu(50))jU[#jU+1]=gF(lt(1010),lD,"ALT HOLD")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lB,lt(1055),lu(51),lt(25),lu(-50),lt(110),lt(-25),lu(46))jU[#jU+1]=gF(lt(1122),lD,"RETROGRADE")jU[#jU+1]=dm([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lC,lt(1165),lu(47),lt(25),lu(-46),lt(98),lt(-44),lu(44))jU[#jU+1]=gF(lt(1220),lD,"ORBIT")jU[#jU+1]=[[
                                    </g>
                                </g>]]jU[#jU+1]="</g>"end;return jU end;local function lE(ki)return bP(fN(ki*3.6,0)+0.5).." km/h"end;local function lF(go)local gq=bm;if go~=nil and type(go)=="number"then if go==0 then return"None"end;gq=cW[go].name end;if gq==nil then gq=fY.name end;if gq==nil then gq="None"end;return gq end;local function lG(jU)local lH=cv.routeWP(true)if not lH or#lH==0 then return end;local hz=j7(750)local hA=j8(360)if b6 or bt then jU[#jU+1]=gF(hz,hA,"REMAINING ROUTE","pdim txtstart size20")else jU[#jU+1]=gF(hz,hA,"LOADED ROUTE","pdim txtstart size20")end;for dN,M in pairs(lH)do hA=hA+20;jU[#jU+1]=gF(hz,hA,dN..". "..lH[dN],"pdim txtstart size20")end end;local function lI(jU)local hz=aC+10;local hA=aD+20;local lJ={}local lK={"Alt-4: AutoTakeoff to Target"}local lL={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lM={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lN={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lJ,"--------------DYNAMIC-----------------")if ci then if ch~=-1 then iC(lJ,lK)if ca and kt and ca.name==kt.name then table.insert(lJ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b2 then if antigrav then if cS then table.insert(lJ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lJ,"Turn on AGG to takeoff to AGG Height")end end;if b2 then table.insert(lJ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lJ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lJ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bp then table.insert(lJ,"G: Takeoff to hover height, raise gear")else table.insert(lJ,"G: Lowergear and Land")end else iC(lJ,lL)table.insert(lJ,"G: Begin BrakeLanding or Land")end;if bc then table.insert(lJ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iC(lJ,lM)if shield then table.insert(lJ,"Alt-Shift-6: Vent shields")if not G then table.insert(lJ,"Alt-Shift-7: Toggle shield off/on")end end end;if fY~=nil then table.insert(lJ,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lJ,"Alt-9: Activate Gyroscope")end;if aX~="none"or aW~="none"or aY~="none"then table.insert(lJ,"Alt-Shift-9: Cycles engines with Extra tags")end;if b8 then table.insert(lJ,"Alt-Spacebar/C will raise/lower target height")table.insert(lJ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not ci then table.insert(lJ,"LALT+Mousewheel will lower/raise speed limit")end;iC(lJ,lN)for M=1,#lJ do hA=hA+12;jU[#jU+1]=gF(hz,hA,lJ[M],"pdim txtbig txtstart")end end;local function lO(jU)local lP=aC;local lQ=aD;local lR=aB;local lS=4;local lT=15;local hz=0;local hA=0;local lU,lV,lW,lX;local lY;local function lZ(type)local gA,bS,ki,l_,jO,m0;if type=="Periapsis"then gA=lY.periapsis.altitude;bS=lY.timeToPeriapsis;ki=lY.periapsis.speed;jO="txtend"l_=12;m0=math.min(hz,lP+lR-kt.radius/lW-lS*2)else gA=lY.apoapsis.altitude;bS=lY.timeToApoapsis;ki=lY.apoapsis.speed;l_=-12;jO="txtstart"m0=hz end;if cN<1 then bS=0 end;jU[#jU+1]=dm([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m0+l_,hA-5,hz,hA-5)jU[#jU+1]=dm([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m0-l_*4,hA+2,hz,hA+2)jU[#jU+1]=gF(m0,hA,type,jO)hz=m0-l_*2;hA=hA+lT;local ll=iE(gA)jU[#jU+1]=gF(hz,hA,ll,jO)hA=hA+lT;jU[#jU+1]=gF(hz,hA,iF(bS),jO)hA=hA+lT;jU[#jU+1]=gF(hz,hA,lE(ki),jO)end;local m1=lR*1.5;if bM=="INFO"then m1=25*10 end;if bM=="ORBIT"and ck<kt.spaceEngineMinAltitude then return jU end;if bM~="HIDE"then jU[#jU+1]=[[<g class="pbright txtorb txtmid">]]jU[#jU+1]=dm('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lR*2,m1,lP,lQ)jU[#jU+1]=dm([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lR*2,m1,lP,lQ)end;local m2=lR*1.5;local m3=lR*2;local m4=m2/2;local m5=lR;local m6=lP+m5;local m7=lQ+m4;local m8=lP+m3;local m9=lQ+m2;if bM=="ORBIT"then lQ=lQ+lS;lU=lR/2;lX=0;lY={}lY.periapsis={}lY.apoapsis={}if fm~=nil then if fm.periapsis~=nil then lY.periapsis.altitude=fm.periapsis.altitude;lY.periapsis.speed=fm.periapsis.speed end;if fm.apoapsis~=nil then lY.apoapsis.altitude=fm.apoapsis.altitude;lY.apoapsis.speed=fm.apoapsis.speed end;lY.period=fm.period;lY.eccentricity=fm.eccentricity;lY.timeToApoapsis=fm.timeToApoapsis;lY.timeToPeriapsis=fm.timeToPeriapsis;lY.eccentricAnomaly=fm.eccentricAnomaly;lY.trueAnomaly=fm.trueAnomaly end;if lY.periapsis==nil then lY.periapsis={}lY.periapsis.altitude=-kt.radius;lY.periapsis.speed=a1 end;if lY.eccentricity==nil then lY.eccentricity=1 end;if lY.apoapsis==nil then lY.apoapsis={}lY.apoapsis.altitude=ck;lY.apoapsis.speed=0 end;if cN<1 then lY.apoapsis.altitude=ck;lY.apoapsis.speed=0 end;if lY.apoapsis.altitude then lW=(lY.apoapsis.altitude+lY.periapsis.altitude+kt.radius*2)/(lU*2)lV=(kt.radius+lY.apoapsis.altitude)/lW*(1-lY.eccentricity)lX=lU-lY.periapsis.altitude/lW-kt.radius/lW;local ma=math.pi;if lY.period~=nil and lY.period>0 and lY.timeToApoapsis~=nil then ma=lY.eccentricAnomaly;if lY.timeToPeriapsis<lY.timeToApoapsis then ma=2*math.pi-ma end end;if cN<1 or ma~=ma then ma=math.pi end;local mb=-lU*math.cos(ma)+lP+m5+lS;local mc=lV*math.sin(ma)+lQ+m4+lS;local md=""jU[#jU+1]='<g clip-path="url(#orbitRect)">'jU[#jU+1]=dm([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],md,lP+lR+lS,lQ+lR*1.5/2+lS,lU,lV)if lV<1 then jU[#jU+1]=dm([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lP+lR+lS-lX,lQ+lR*1.5/2+lS,mb,mc)end;jU[#jU+1]=dm('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lP+lR+lS-lX,lQ+lR*1.5/2+lS,(kt.radius+kt.noAtmosphericDensityAltitude)/lW)jU[#jU+1]=dm('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lP+lR+lS-lX,lQ+lR*1.5/2+lS,(kt.radius+kt.noAtmosphericDensityAltitude)/lW)jU[#jU+1]=dm([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lP+lR+lS,lQ+lR*1.5/2+lS,lU,lV)jU[#jU+1]=dm('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lP+lR+lS-lX,lQ+lR*1.5/2+lS,kt.radius/lW)jU[#jU+1]='</g>'local me=math.floor(kt.radius/lW+0.5)hz=lP+lR+lS*4+lU;hA=lQ+lR*1.5/2+5+lS;if lY.apoapsis~=nil and lY.apoapsis.speed<a1 then lZ("Apoapsis")end;hA=lQ+lR*1.5/2+5+lS;hz=lP+lR-lS*2-lU;if lY.periapsis~=nil and lY.periapsis.speed<a1 and lY.periapsis.altitude>0 then lZ("Periapsis")end;jU[#jU+1]=gF(lP+lR+lS,lQ+20+lS,kt.name,"txtorbbig")jU[#jU+1]=dm('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mb,mc)jU[#jU+1]=[[</g>]]return jU else jU[#jU+1]='<g clip-path="url(#orbitRect)">'local mf=""local mg=1.2*(mh-mi)/(lR*2)local mj=1.4*(mk-ml)/(lR*1.5)for dN,dz in pairs(e[0])do if dz.center then local hz=lP+lR+dz.center.x/mg;local hA=lQ+lR*1.5/2+dz.center.y/mj;mf=mf..'<circle cx="'..hz..'" cy="'..hA..'" r="'..dz.radius/mg*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dz.name,"Moon")and not string.match(dz.name,"Sanctuary")and not string.match(dz.name,"Space")then mf=mf.."<text x='"..hz.."' y='"..hA+dz.radius/mg*30+20 .."' font-size='12' fill="..i_.." text-anchor='middle' font-family='Montserrat'>"..dz.name.."</text>"end end end;local fo=vec3(bR.getWorldPosition())local hz=lP+lR+fo.x/mg;local hA=lQ+lR*1.5/2+fo.y/mj;mf=mf..'<circle cx="'..hz..'" cy="'..hA..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mf=mf.."<text x='"..hz.."' y='"..hA-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iN=mg;iO=mj;local mm=fo+cM*1000000;local mn=lP+lR+mm.x/mg;local jD=lQ+lR*1.5/2+mm.y/mj;mf=mf..'<line x1="'..hz..'" y1="'..hA..'" x2="'..mn..'" y2="'..jD..'" stroke="purple" stroke-width="1"/>'jU[#jU+1]=mf;jU[#jU+1]='</g>'end elseif bM=="INFO"then jU=ct.DrawOdometer(jU,j1,bq,j2)elseif bM=="HELP"then jU=lI(jU)elseif bM=="SCOPE"then jU[#jU+1]='<g clip-path="url(#orbitRect)">'local mo=d7;local mp=vec3(DUSystem.getCameraWorldPos())local mq=vec3(DUSystem.getCameraWorldRight())local mr=vec3(DUSystem.getCameraWorldForward())if iB()==1 then mp=cQ;mq=cK;mr=cJ end;if cj>0 then table.sort(d6,function(eC,eD)local eE,eF=eC.center,eD.center;return(eE.x-mp.x)^2+(eE.y-mp.y)^2+(eE.z-mp.z)^2<(eF.x-mp.x)^2+(eF.y-mp.y)^2+(eF.z-mp.z)^2 end)end;local ms={}local mt={}local mu=120;local mv=nil;local mw=nil;for M,dz in ipairs(d6)do local gN=dz.center-mp;local mx=gN:len()local my=gN:normalize()local mz=gN:cross(mr):normalize()local mA=math.acos(mz:dot(mq))if mA~=mA then mA=0 end;if mz:cross(mq):dot(mr)<0 then mA=-mA end;local mB=gN:project_on_plane(mr):len()local mC=math.sin(mA)*math.asin(mB/mx)*constants.rad2deg;local mD=math.cos(mA)*math.asin(mB/mx)*constants.rad2deg;if my:dot(mr)<0 then mD=90*math.cos(mA)+90*math.cos(mA)-mD;mC=90*math.sin(mA)+90*math.sin(mA)-mC end;local hz=m6+mC/mo*m2;local hA=m7+mD/mo*m2;local mE=(hz-m6)*(hz-m6)+(hA-m7)*(hA-m7)local mF=math.asin((dz.radius+dz.surfaceMaxAltitude)/mx)*constants.rad2deg;if mF~=mF then mF=mo end;local hU=mF/mo*m2;local mG=math.asin(dz.atmosphereRadius/mx)*constants.rad2deg;if mG~=mG then mG=mF end;local mH=mG/mo*m2;local cd=iE(mx,1)local mI=dz.name;local mJ=false;if hA>lQ then if hA>m9 then if hA-mH<=m9 then mJ=true end else mJ=true end else if hA+mH>=lQ then mJ=true end end;local mK=false;local mL=hz;if dz.systemId==0 then mL=hz+mu else mL=hz-mu end;if mL+mu>lP then if mL+mu>m8 then if mL-mH-mu<=m8 then mK=true end else mK=true end else if mL+mH+mu>=lP then mK=true end end;local mM={}mM.x=hz;mM.y=hA;mM.planet=dz;mM.atmoSize=mH;if not mv or mE<mv then mv=mE;mw=mM end;if mK and mJ then local mN=math.max(mH,5)if mE<mN*mN then mI=mI.." - "..cd end;mM.size=hU;mM.i=M;mM.displayString=mI;mM.distance=cd;mM.visible=true;mt[#mt+1]=mM else mM.visible=false end end;local mO=false;table.sort(mt,function(eE,eF)return eE.y<eF.y end)for dN,fj in ipairs(mt)do local dz,hU,M,mH,hz,hA,mI,cd=fj.planet,fj.size,fj.i,fj.atmoSize,fj.x,fj.y,fj.displayString,fj.distance;local m0,mP,mQ,mR;local mS=15;local jO="pdim"if dz.systemId~=0 then mQ=j7(string.len(mI)*5)mS=-(15+mQ)mR=j8(10)jO="pdimfill"else mQ=j7(string.len(mI)*9)mR=j8(15)end;if hU*2>mQ then m0=dn(hz,lP+mQ/2,m8-mQ/2)mP=dn(hA,lQ+mR,m9-5)m0=dn(m0,hz-hU+mQ/2,hz+hU-mQ/2)mP=dn(mP,hA-hU+mR,hA+hU)else m0=hz+mS;mP=hA end;for mT,fj in pairs(ms)do local mU=fj.textPositions;local mV=mU.y-mP;if mT~=M and f0(mV)<mU.height and mU.x+mU.width>m0 and mU.x<m0+mQ then if hU>mQ then mP=dn(mP+mR,lQ+15,m9-5)else mP=mU.y+mU.height+1 end end end;local mW=mI~=dz.name or m0<=m6 and m0+mQ>=m6 and mP-mR<=m7 and mP>=m7;fj.hovered=mW;local mX=1;if mW then mX=2;if hU*2<mQ then mX=10 end;if mI==dz.name then mI=mI.." - "..cd end;jO="pbright"if dz.systemId~=0 then mQ=j7(string.len(mI)*5)mS=-(15+mQ)else mQ=j7(string.len(mI)*7)end;if hU*2>mQ then m0=dn(hz,lP+mQ/2,m8-mQ/2)m0=dn(m0,hz-hU+mQ/2,hz+hU-mQ/2)else m0=hz+mS end end;ms[M]={}ms[M].textPositions={}ms[M].textPositions.y=mP;ms[M].textPositions.x=m0;ms[M].textPositions.width=mQ;ms[M].textPositions.height=mR;ms[M].output=""if hU*2>mQ then jO=jO.." txtmid"else jO=jO.." txtstart"end;if mH-hU>2 then ms[M].output=dm('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hz,hA,mH,j0,0.1*mX)end;ms[M].output=ms[M].output..dm('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hz,hA,hU,j0,0.2*mX)if dz.systemId==0 then ms[M].output=ms[M].output..dm([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m0,mP,i_,jO,mI)if hU*2<=mQ then ms[M].output=ms[M].output..dm("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m0+mQ,mP+2,m0,mP+2,hz,hA)end else ms[M].output=ms[M].output..dm([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m0,mP,j0,jO,mI)if hU*2<=mQ then ms[M].output=ms[M].output..dm("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m0,mP+2,m0+mQ,mP+2,hz,hA)end end end;for dN=#d6,1,-1 do if ms[dN]then jU[#jU+1]=ms[dN].output end end;if mw~=nil and d7<90 and not mw.hovered then local mY=mw.planet.atmosphereRadius/mw.atmoSize;local mZ=dq(mv)*mY;local m_=iE(mZ,1)local mQ=j7(math.max(string.len(m_)*7,string.len(mw.planet.name)*7))local mR=j8(12)local m0=dn(mw.x+(m6-mw.x)/2,lP+mQ/2,m8-mQ/2)local mP=dn(mw.y+(m7-mw.y)/2,lQ+mR*2,m9-5)jU[#jU+1]=dm("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mw.x,mw.y,m6,m7)jU[#jU+1]=dm([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m0,mP,"white",m_)if not mw.visible then jU[#jU+1]=dm([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m0,mP-mR,"white",mw.planet.name)end end;if cN>1 then local gN=cM;local my=gN:normalize()local mB=gN:project_on_plane(mr):len()local mz=gN:cross(mr):normalize()local mA=math.acos(mz:dot(mq))if mA~=mA then mA=0 end;if mz:cross(mq):dot(mr)<0 then mA=-mA end;local mC=math.sin(mA)*math.asin(mB/gN:len())*constants.rad2deg;local mD=math.cos(mA)*math.asin(mB/gN:len())*constants.rad2deg;if my:dot(mr)<0 then mD=90*math.cos(mA)+90*math.cos(mA)-mD;mC=90*math.sin(mA)+90*math.sin(mA)-mC end;local hz=m6+mC/mo*m2;local hA=m7+mD/mo*m2;local kR=14;local kS=kR/2;local kV=[[<circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kS/kR..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hz-kR..[[,]]..hA..[[ h ]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hz+kS..[[,]]..hA..[[ h ]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hz..[[,]]..hA-kR..[[ v ]]..kS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jU[#jU+1]=kV end;jU[#jU+1]=dm("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m6,m7-10,m6,m7+10)jU[#jU+1]=dm("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m6-10,m7,m6+10,m7)jU[#jU+1]='</g>'else return jU end end;local function n0(n1,n2)local n3;local n4=(n2-n1):normalize()local fp=(cQ-n1):dot(n4)/n4:dot(n4)if fp<=0. then return(cQ-n1):len()elseif fp>=(n2-n1):len()then return(cQ-n2):len()end;local n5=n1+fp*n4;n3=(n5-cQ):len()return n3 end;local function n6()local n3;local n7=nil;local n8=nil;local n9=nil;for dN,na in pairs(e[0])do if na.hasAtmosphere then local cd=n0(kt.center,na.center)if n7==nil or cd<n7 then n8=na;n7=cd;n9=kt end;if ca and ca.hasAtmosphere and ca.name~=kt.name then local eR=n0(ca.center,na.center)if eR<n7 then n8=na;n7=eR;n9=ca end end end end;local nb=j7(1770)local nc=j8(330)if n7 then local nd="txttick "local ne=500000;if n7<n8.radius+ne or n7<n9.radius+ne then if cX then nd="txttick red "else nd="txttick orange "end end;n3=iE(n7,2)iS=gF(nb,nc,"Pipe ("..n9.name.."--"..n8.name.."): "..n3,nd.."pbright txtmid")end end;local function nf(hz,hA,ng,nh,l3)local ni={x=hz,y=hA,width=ng,height=nh,label=l3}iM[l3]=ni;return ni end;local function nj(nk,nl,ng,nh,hz,hA,nm,nn,no,np,jO)local ni={enableName=nk,disableName=nl,width=ng,height=nh,x=hz,y=hA,toggleVar=nm,toggleFunction=nn,drawCondition=no,hovered=false,class=jO}if np then table.insert(iL,ni)else table.insert(iK,ni)end;return ni end;local function nq(nr)if not iQ then ns=false;nt=false;nu=false;w=true;return elseif nr=="handling"then ns=not ns;nt=false;nu=false elseif nr=="hud"then nt=not nt;ns=false;nu=false elseif nr=="physics"then nu=not nu;ns=false;nt=false end;if nu or nt or ns then iR=iD(nr)w=false else iR="none"w=true end end;local function nv()iQ=not iQ;if iQ then iJ=iL;dk("Tap LMB to see Settings")d8=w else iJ=iK;dk("Tap LMB to see Control Buttons")nq()w=d8 end end;local function nw()local function nx(dz,dN)dz.set(not dz.get())if dz.get()then dk(dN.." set to true")else dk(dN.." set to false")end;if dN=="showHud"then d8=dz.get()elseif dN=="BrakeToggleDefault"then b1=k end end;local ny=50;local nz=340;local hz=ad/2-530;local hA=ae/2-330+ny/2;local nA=0;for dN,dz in pairs(iD("boolean"))do if type(dz.get())=="boolean"then nj(dN,dN,nz,ny,hz,hA,function()return dz.get()end,function()nx(dz,dN)end,function()return true end,true)hA=hA+ny+20;if nA==9 then hz=hz+nz+20;hA=ae/2-400+ny/2;nA=0 else if hz>ad/2-nz and hz<ad/2+nz/2 and hA>ae/2-ny and hA<ae/2+ny then hA=hA+ny+20;nA=nA+1 end;nA=nA+1 end end end;nj("Control View","Control View",nz,ny,10,ae/2-500,function()return true end,nv,function()return true end,true)nj("View Handling Settings",'Hide Handling Settings',nz,ny,10,ae/2-(500-ny),function()return ns end,function()nq("handling")end,function()return true end,true)nj("View Hud Settings",'Hide Hud Settings',nz,ny,10,ae/2-(500-ny*2),function()return nt end,function()nq("hud")end,function()return true end,true)nj("View Physics Settings",'Hide Physics Settings',nz,ny,10,ae/2-(500-ny*3),function()return nu end,function()nq("physics")end,function()return true end,true)end;local function nB()local function gp()local fP=cQ;local gq=kt.name..". "..#bs;if cw then gq=cw.GetClosestName(gq)end;return cu.AddNewLocation(gq,fP,false,true)end;local function nC()b7=not b7 end;local function nD(nE)if nE==1 then b5=not b5;b4=false else b4=not b4;b5=false end;b6=false;b8=false;c2=false;b9=false;bw=nil;bb=false;ba=false end;local function nF(nG,nH)cu.UpdatePosition(nil,nG,nH)end;local function gk()cu.ClearCurrentPosition()end;local function nI(go)local lH=cv.routeWP(true)if lH and#lH>0 then return"Engage Route: "..lH[1]end;return"Engage Autopilot: "..lF(go)end;local function nJ(go)local lH=cv.routeWP(true)if lH and#lH>0 then return"Next Route Point: "..lH[1]end;return"Disable Autopilot: "..lF(go)end;local function nK()if iz()==1 then c2=not c2;if c2 then b6=false;b4=false;b5=false;b8=false;bb=false;b9=false;ba=false;nL=bp;bp=false;d.control.retractLandingGears()iA:setTargetGroundAltitude(Z)fM("folOn","F")else fM("folOff","F")b3="Follow Off"cB=q;bp=nL;if bp then d.control.deployLandingGears()iA:setTargetGroundAltitude(_)end end else dk("Follow Mode only works with Remote controller")c2=false end end;local ny=50;local nz=260;local nM=j7(30)local nN=aC+aB*2+2;local nO=aD+1;nj("+","+",nM,nM,nN,nO+nM+1,function()return false end,function()d7=d7/8 end,function()return bM=="SCOPE"end,nil,"ZoomButton")nj("-","-",nM,nM,nN,nO,function()return false end,function()d7=math.min(d7*8,90)end,function()return bM=="SCOPE"end,nil,"ZoomButton")nj("0","0",nM,nM,nN,nO+nM*2+2,function()return false end,function()d7=90 end,function()return bM=="SCOPE"and d7~=90 end,nil,"ZoomButton")local nP=nj("Enable Brake Toggle","Disable Brake Toggle",nz,ny,ad/2-nz/2,ae/2+350,function()return b1 end,function()b1=not b1;if b1 then dk("Brakes in Toggle Mode")else dk("Brakes in Default Mode")end end)nj("Align Prograde","Disable Prograde",nz,ny,ad/2-nz/2-50-nP.width,ae/2-ny+380,function()return b5 end,function()nD(1)end)nj("Align Retrograde","Disable Retrograde",nz,ny,ad/2-nz/2+nP.width+50,ae/2-ny+380,function()return b4 end,nD,function()return cj==0 end)nQ=nj(nI,nJ,600,60,ad/2-600/2,ae/2-60/2-330,function()return b6 or bt or cf or bC end,function()end)local M;local function nR(nS)local go=d3+nS;if go>#cW then go=go-#cW-1 end;if go<0 then go=#cW+go end;return go end;nT={}for M=0,10 do local nU=nj(function(eF)local go=nR(eF.apExtraIndex)if b6 or bt or cf or bC then return"Redirect: "..lF(go)end;return nI(go)end,function(eF)local go=nR(eF.apExtraIndex)return nJ(go)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eF)local go=nR(eF.apExtraIndex)return go==bo and(b6 or bt or cf or bC)end,function(eF)local go=nR(eF.apExtraIndex)local nV=bo==go;bo=go;cu.UpdateAutopilotTarget()cv.ToggleAutopilot()if not nV and not(b6 or bt or cf or bC)then cv.ToggleAutopilot()end end,function()return d2 and(#cv.routeWP(true)==0 or M==0)end)nU.apExtraIndex=M;nT[M]=nU end;nj("Save Position","Save Position",200,nQ.height,nQ.x+nQ.width+30,nQ.y,function()return false end,gp,function()return bo==0 or fY==nil end)nj("Update Position","Update Position",200,nQ.height,nQ.x+nQ.width+30,nQ.y,function()return false end,function()nF(nil)end,function()return bo>0 and fY~=nil end)nj("Save Heading","Clear Heading",200,nQ.height,nQ.x+nQ.width+30,nQ.y+nQ.height+20,function()return fY.heading~=nil end,function()if fY.heading~=nil then nF(false)else nF(true)end end,function()return bo>0 and fY~=nil end)nj("Save AGG Alt","Clear AGG Alt",200,nQ.height,nQ.x+nQ.width+30,nQ.y+nQ.height*2+40,function()return fY.agg~=nil end,function()if fY.agg~=nil then nF(nil,false)else nF(nil,true)end end,function()return bo>0 and fY~=nil and antigrav end)nj("Clear Position","Clear Position",200,nQ.height,nQ.x-200-30,nQ.y,function()return true end,gk,function()return bo>0 and fY~=nil end)nj("Save Route","Save Route",200,nQ.height,nQ.x-200-30,nQ.y+nQ.height*2+40,function()return false end,function()cv.routeWP(false,false,2)end,function()return#cv.routeWP(true)>0 end)nj("Load Route","Clear Route",200,nQ.height,nQ.x-200-30,nQ.y+nQ.height+20,function()return#cv.routeWP(true)>0 end,function()if#cv.routeWP(true)>0 then cv.routeWP(false,true)elseif b6 or bt then dk("Disable Autopilot before loading route")return else cv.routeWP(false,false,1)end end,function()return true end)ny=60;nz=300;local hz=0;local hA=ae/2-150;nj("Enable Check Damage","Disable Check Damage",nz,ny,hz,hA-ny-20,function()return s end,function()s=not s end)nj("View Settings","View Settings",nz,ny,hz,hA,function()return true end,nv)hA=hA+ny+20;nj("Enable Turn and Burn","Disable Turn and Burn",nz,ny,hz,hA,function()return b7 end,nC)hz=10;hA=ae/2-300;nj("Horizontal Takeoff Mode","Vertical Takeoff Mode",nz,ny,ad/2-nz/2,hA+20,function()return b2 end,function()b2=not b2;if b2 then dk("Vertical Takeoff Mode")else dk("Horizontal Takeoff Mode")end end,function()return cR end)hA=hA+ny+20;nj("Engage Orbiting","Cancel Orbiting",nz,ny,hz+nz+20,hA,function()return bC end,cv.ToggleIntoOrbit,function()return cj==0 and c_ end)hA=ae/2-150;nj("Glide Re-Entry","Cancel Glide Re-Entry",nz,ny,hz+nz+20,hA,function()return bb end,function()ce=1;nD(1)end,function()return kt.hasAtmosphere and not ci end)hA=hA+ny+20;nj("Parachute Re-Entry","Cancel Parachute Re-Entry",nz,ny,hz+nz+20,hA,function()return bb end,function()ce=2;nD(1)end,function()return kt.hasAtmosphere and not ci end)hA=hA+ny+20;nj("Engage Follow Mode","Disable Follow Mode",nz,ny,hz,hA,function()return c2 end,nK,function()return iz()==1 end)nj("Enable Repair Arrows","Disable Repair Arrows",nz,ny,hz+nz+20,hA,function()return j5 end,function()j5=not j5;if j5 then dk("Repair Arrows Enabled")else dk("Repair Arrows Diabled")end end,function()return iz()==1 end)hA=hA+ny+20;if not r then nj("Enable AGG","Disable AGG",nz,ny,hz,hA,function()return cS end,cv.ToggleAntigrav,function()return antigrav~=nil end)end;nj(function()return dm("Switch IPH Mode - Current: %s",bD)end,function()return dm("IPH Mode: %s",bD)end,nz*2,ny,hz,hA,function()return false end,function()if bD=="All"then bD="Custom Only"elseif bD=="Custom Only"then bD="No Moons-Asteroids"else bD="All"end;dk("IPH Mode: "..bD)end)hA=hA+ny+20;nj(function()return dm("Toggle Control Scheme - Current: %s",g)end,function()return dm("Control Scheme: %s",g)end,nz*2,ny,hz,hA,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;dk("New Control Scheme: "..g)end)local nW=j8(20)local nU=nf(0,0,j7(70),nW,"HELP")nU=nf(nU.x+nU.width,nU.y,j7(80),nW,"INFO")nU=nf(nU.x+nU.width,nU.y,j7(70),nW,"ORBIT")nU=nf(nU.x+nU.width,nU.y,j7(70),nW,"SCOPE")nf(nU.x+nU.width,nU.y,j7(70),nW,"HIDE")end;local nX={}local nY=nil;function nX.HUDPrologue(jU)if not cX then iX=aj;iY=ak;iZ=al else iX=ag;iY=ah;iZ=ai end;i_=[[rgb(]]..bP(iX+0.6)..","..bP(iY+0.6)..","..bP(iZ+0.6)..[[)]]j0=[[rgb(]]..bP(iX*0.8+0.5)..","..bP(iY*0.8+0.5)..","..bP(iZ*0.8+0.5)..[[)]]local nZ=i_;local n_=j0;local o0=[[rgb(]]..bP(iX*0.4+0.5)..","..bP(iY*0.4+0.5)..","..bP(iZ*0.4+0.5)..[[)]]local o1=i_;local o2=j0;local o3=o0;if j9()and not n then nZ=[[rgb(]]..bP(iX*0.5+0.5)..","..bP(iY*0.5+0.5)..","..bP(iZ*0.5+0.5)..[[)]]n_=[[rgb(]]..bP(iX*0.3+0.5)..","..bP(iY*0.3+0.5)..","..bP(iZ*0.2+0.5)..[[)]]o0=[[rgb(]]..bP(iX*0.2+0.5)..","..bP(iY*0.2+0.5)..","..bP(iZ*0.2+0.5)..[[)]]end;local lt=j7;local lu=j8;jU[#jU+1]=dm([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nZ,nZ,nZ,o1,o1,n_,n_,o2,o2,n_,nZ,o0,o2,nZ,nZ,o0,o0,o3,o0,ad,ae,n_,n_,n_,n_,n_,o1,n_,o2,o3,o2,o2,o3)if not nY then nY=dm([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lt(630),lu(0),lt(675),lu(45),lt(960),lu(55),lt(1245),lu(45),lt(1290),lu(0),lt(1000),lu(105),lt(1040),lu(59),lt(1250),lu(51),lt(1300),lu(0),lt(1920),lu(0),lt(1920),lu(20),lt(1400),lu(20),lt(1300),lu(105),lt(920),lu(105),lt(880),lu(59),lt(670),lu(51),lt(620),lu(0),lt(0),lu(0),lt(0),lu(20),lt(520),lu(20),lt(620),lu(105),lt(890),lu(59),lt(960),lu(62),lt(1030),lu(59),lt(985),lu(112),lt(1150),lu(112),lt(1100),lu(152),lt(820),lu(152),lt(780),lu(112),lt(935),lu(112),lt(890),lu(59),lt(960),lu(62),lt(1030),lu(59),lt(985),lu(112),lt(1150),lu(112),lt(1100),lu(152),lt(820),lu(152),lt(780),lu(112),lt(935),lu(112))end;if w and I then jU[#jU+1]=nY end;return jU end;function nX.DrawVerticalSpeed(jU,e5)jT(jU,e5)end;function nX.UpdateHud(jU)local kK=cU;local o4=cV;local k0=o4;local kg=kK;local l1=bP(c.getThrottle())local l6=cN*3.6;local l2=c.getAxisCommandValue(0)local o5=j7(1770)local o6=j8(310)if t and cT then l2=bT;l1=bT*100 end;local jb=ja()local k1="ROLL"if l1==nil then l1=0 end;if not c_ then if cN>5 then kK=kJ(cL)o4=kL(cL)else kK=0;o4=0 end;k1="YAW"end;if cY>50000 and not ci then local o7;o7=iE(cY)jU[#jU+1]=gF(o5,o6,"PvP Boundary: "..o7,"pbright txtbig txtmid")end;jU[#jU+1]=j3;jU[#jU+1]=i7;if iS~=""then jU[#jU+1]=iS end;if jc~=""then jU[#jU+1]=jc end;if jd~=""then jU[#jU+1]=jd end;jT(jU,ck)if iz()==0 or m then if not j9()or n then if c_ then j_(jU,am,an,k0,k1,c_)kf(jU,kg,k0,am,an,c_,bP(kL(cL)),cN)else j_(jU,am,an,o4,k1,c_)kf(jU,kK,o4,am,an,c_,bP(o4),cN)end;kn(jU,ck,c_)kM(jU,cL,cN,am,an)end end;l0(jU,jb,l1,l2)l5(jU,l6)la(jU)lO(jU)if not iQ and c3 then lG(jU)end;return jU end;function nX.HUDEpilogue(jU)jU[#jU+1]="</svg>"return jU end;function nX.ExtraData(jU)local o8=j7(1240)local o9=j8(55)local oa=o9+10;local ob;local lt=j7;local lu=j8;local oc=0;local jb=ja()if b2 then jb=jb.."-VERTICAL"end;if E and gQ and not ba and not b9 and cN>20 then jb=jb.."-COLLISION ON"end;if bF~="Off"then jb="("..bF..")-"..jb end;if b7 then jb="TB-"..jb end;if bK then jb="HOVERMODE-"..jb end;if not bE then jb=jb.."-DeCoupled"end;local od=lu(99)local oe=lu(80)local of=lu(85)local og=lu(31)local oh=0;local oi=0;local f5=cl>1000000 and fN(cl/1000000,2).."kT"or fN(cl/1000,2).."T"if ci then oc=bx else oc=bv end;local oj,ok=cr.computeDistanceAndTime(cN,0,cl,0,0,oc)if oj<0 then oj=0 end;oc=fN(oc/(cl*iI),2).."g"local ol=d:maxForceForward()ob=b.getGravityIntensity()if ob>0.1 then oi=cl*ob;oi=fN(oi/(cl*iI),2).."g"oh=0.5*ol/ob;oh=oh>1000000 and fN(oh/1000000,2).."kT"or fN(oh/1000,2).."T"end;ol=fN(ol/(cl*iI),2).."g"local om=vec3(bR.getWorldAcceleration()):len()/9.80665;ob=b.getGravityIntensity()jU[#jU+1]=[[<g class="dim txt txtend size14">]]if iz()==1 and not m then o8=j7(1120)o9=j8(55)oa=o9+10 elseif ci and I then local on=j7(770)jU[#jU+1]=gF(lt(895),od,"ATMO","")jU[#jU+1]=dm([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lt(895),of,lt(-80))jU[#jU+1]=gF(lt(815),oe,dm("%.1f%%",cj*100),"txtstart size20")end;if I then jU[#jU+1]=gF(lt(1025),od,"GRAVITY","txtstart")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(1025),of,lt(80))jU[#jU+1]=gF(lt(1105),oe,dm("%.2fg",ob/9.80665),"size20")jU[#jU+1]=gF(lt(1125),od,"ACCEL","txtstart")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(1125),of,lt(80))jU[#jU+1]=gF(lt(1205),oe,dm("%.2fg",om),"size20")jU[#jU+1]=gF(lt(695),od,"BRK TIME","")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(695),of,lt(-80))jU[#jU+1]=gF(lt(615),oe,dm("%s",iF(ok)),"txtstart size20")jU[#jU+1]=gF(lt(635),lu(45),"TRIP","")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(635),lu(31),lt(-90))if lq then jU[#jU+1]=gF(lt(545),lu(26),dm("%s",iF(lq)),"txtstart size20")end;jU[#jU+1]=gF(lt(795),od,"BRK DIST","")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(795),of,lt(-80))jU[#jU+1]=gF(lt(715),oe,dm("%s",iE(oj)),"txtstart size20")jU[#jU+1]=gF(lt(1285),lu(45),"MASS","txtstart")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(1285),lu(31),lt(90))jU[#jU+1]=gF(lt(1375),lu(26),dm("%s",f5),"size20")jU[#jU+1]=gF(lt(1220),od,"THRUST","txtstart")jU[#jU+1]=dm([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lt(1220),of,lt(80))jU[#jU+1]=gF(lt(1300),oe,dm("%s",ol),"size20")jU[#jU+1]=gF(j7(960),j8(175),jb,"pbright txtbig txtmid size20")end;jU[#jU+1]="</g>"end;local oo=1-(a7*0.05+a8*0.05)function nX.FuelUsed(op)local oq;if op=="atmofueltank"then oq=dm("Atmo Fuel Used: %.1f L",ju[op]/(4*oo))elseif op=="spacefueltank"then oq=dm("Space Fuel Used: %.1f L",ju[op]/(6*oo))else oq=dm("Rocket Fuel Used: %.1f L",ju[op]/(0.8*oo))end;return oq end;local os,ot,ou,ov,ow=0,0,0,{},0;local ox=0;local oy=0;local oz=0;local oA=0;function nX.DrawOdometer(jU,j1,bq,j2)if bM~="INFO"then return jU end;local ob;local oc=0;local oi=0;local f5=cl>1000000 and fN(cl/1000000,2).." kTons"or fN(cl/1000,2).." Tons"if ci then oc=bx else oc=bv end;local oj,ok=cr.computeDistanceAndTime(cN,0,cl,0,0,oc)local ol=d:maxForceForward()ob=b.getGravityIntensity()if cN<5 and ch~=-1 then local oB=vec3(bR.getOrientationForward())local oC=bR.getMaxThrustAlongAxis('thrust analog longitudinal ',{oB:unpack()})ox=0.5*oC[1]/ob;ox=ox>1000000 and fN(ox/1000000,1).." kTons"or fN(ox/1000,1).." Tons"oy=0.5*oC[3]/ob;oy=oy>1000000 and fN(oy/1000000,1).." kTons"or fN(oy/1000,1).." Tons"oB=vec3(bR.getOrientationUp())oC=bR.getMaxThrustAlongAxis('hover_engine, booster_engine',{oB:unpack()})oz=0.5*oC[1]/ob;oz=oz>1000000 and fN(oz/1000000,1).." kTons"or fN(oz/1000,1).." Tons"oA=0.5*oc/ob;oA=oA>1000000 and fN(oA/1000000,1).." kTons"or fN(oA/1000,1).." Tons"end;oc=fN(oc/(cl*iI),2).." g"if ob>0.1 then oi=cl*ob;oi=fN(oi/(cl*iI),2).." g"else oi="n/a"end;ol=fN(ol/(cl*iI),2).." g"if iz()==0 or m then local oD=j7(aC+10)local oE=j8(aD+20)local oF=j7(aC+10+aB/1.25)local nh=25;local oG=bP(1/aU)if ou<oG then ow=ow+a.getActionUpdateDeltaTime()ou=ou+1 else os=1/(ow/oG)table.insert(ov,os)ou,ow=0,0 end;ot=0;for dN,dz in pairs(ov)do ot=ot+dz end;if#ov>0 then ot=bP(ot/#ov)end;if#ov>29 then table.remove(ov,1)end;jU[#jU+1]="<g class='txtstart size14 bright'>"jU[#jU+1]=gF(oD,oE,dm("BrkTime: %s",iF(ok)))jU[#jU+1]=gF(oF,oE,dm("Trip: %.2f km",j1))jU[#jU+1]=gF(oD,oE+nh,dm("Lifetime: %.2f kSU",bq/200000))jU[#jU+1]=gF(oF,oE+nh,dm("BrkDist: %s",iE(oj)))jU[#jU+1]=gF(oD,oE+nh*2,"Trip Time: "..iF(j2))jU[#jU+1]=gF(oF,oE+nh*2,"Total Time: "..iF(br))jU[#jU+1]=gF(oD,oE+nh*3,dm("Mass: %s",f5))jU[#jU+1]=gF(oF,oE+nh*3,dm("Safe Brake Mass: %s",oA))jU[#jU+1]=gF(oD,oE+nh*4,dm("Max Thrust: %s",ol))jU[#jU+1]=gF(oF,oE+nh*4,dm("Safe Atmo Mass: %s",ox))jU[#jU+1]=gF(oD,oE+nh*5,dm("Max Brake: %s",oc))jU[#jU+1]=gF(oF,oE+nh*5,dm("Safe Space Mass: %s",oy))jU[#jU+1]=gF(oF,oE+nh*6,dm("Safe Hover Mass: %s",oz))jU[#jU+1]=gF(oD,oE+nh*6,dm("Influence: %s",kt.name))jU[#jU+1]=gF(oD,oE+nh*7,dm("Set Max Speed: %s",bP(a1*3.6+0.5)))jU[#jU+1]=gF(oF,oE+nh*7,dm("Actual Max Speed: %s",bP(dh*3.6+0.5)))jU[#jU+1]=gF(oD,oE+nh*8,dm("Friction Burn Speed: %s",bP(bR.getFrictionBurnSpeed()*3.6)))jU[#jU+1]=gF(oF,oE+nh*8,dm("FPS (Avg): %s (%s)",bP(os),ot))end;jU[#jU+1]="</g></g>"return jU end;function nX.DrawWarnings(jU)return la(jU)end;function nX.DisplayOrbitScreen(jU)return lO(jU)end;function nX.DisplayMessage(jU,ll)if ll~="empty"then local hA=310;for ln in string.gmatch(ll,"([^\n]+)")do hA=hA+35;jU[#jU+1]=gF("50%",hA,ln,"msg")end end;if c6~=0 then c.setTimer("msgTick",c6)c6=0 end end;function nX.DrawDeadZone(jU)jU[#jU+1]=dm([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function nX.UpdatePipe()if ci then iS=""return end;n6()end;function nX.DrawSettings(jU)local hz=j7(640)local hA=j8(200)jU[#jU+1]=[[<g class="pbright txtvspd txtstart">]]local hQ=0;for dN,dz in pairs(iR)do hQ=hQ+1;jU[#jU+1]=gF(hz,hA,dN..": "..dz.get())hA=hA+20;if hQ%12==0 then hz=hz+j7(350)hA=j8(200)end end;jU[#jU+1]=gF(j7(640),j8(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jU[#jU+1]="</g>"return jU end;local i6=j8(125)local i5=j7(1225)function nX.DrawRadarInfo()i7=cw.GetRadarHud(i5,i6,ay,az)if i7 then gQ=true end end;function nX.DrawTanks()if au~=0 and av~=0 then jc=gF(au,av,"","txtstart pdim txtfuel")jv=av;jw(au,"Atmospheric ","ATMO",cn,js,jt)jw(au,"Space Fuel T","SPACE",co,jq,jr)jw(au,"Rocket Fuel ","ROCKET",cp,jo,jp)end end;function nX.DrawShield()local ii=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oH=bR.getPvPTimer()local oI=shield.getResistances()local oJ="A: "..10+oI[1]*100 .."% / E: "..10+oI[2]*100 .."% / K:"..10+oI[3]*100 .."% / T: "..10+oI[4]*100 .."%"local hz,hA=aw-60,ax+30;local jM=bP(di*2.55)local jN=dm("rgb(%d,%d,%d)",255-jM,jM,0)local jO=""jd=gF(hz,hA,"","txtmid pdim txtfuel")if di<10 and ii~="Shield Disabled"then jO="red "end;oH=oH>0 and"   PvPTime: "..iF(oH)or""jd=jd..dm([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hz,hA,jN,di*2,hz,hA,hz+2,hA+10,di,oH)jd=jd..gF(hz,hA-5,ii,jO.."txtstart pbright txtbig")jd=jd..gF(hz,hA+30,oJ,jO.."txtstart pbright txtsmall")end;function nX.hudtick()if not kt then return end;local function oK(jU)local jQ=bP(dn(df/(ad/4)*255,0,255))jU[#jU+1]=dm("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",cb,cc,bP(iX+0.5)+jQ,bP(iY+0.5)-jQ,bP(iZ+0.5)-jQ)end;local function oL()if c4 then for dS,dz in pairs(iJ)do if dz.hovered then if not dz.drawCondition or dz.drawCondition(dz)then dz.toggleFunction(dz)end;dz.hovered=false end end;for dS,dz in pairs(iM)do if dz.hovered then bM=dz.label;dz.hovered=false end end;c4=false end end;local function oM()local function oN(oO,oP,hz,hA,ng,nh)if oO>=hz and oO<=hz+ng and oP>=hA and oP<=hA+nh then return true else return false end end;local hz=cb+ad/2;local hA=cc+ae/2;for dS,dz in pairs(iJ)do dz.hovered=oN(hz,hA,dz.x,dz.y,dz.width,dz.height)end;for dS,dz in pairs(iM)do dz.hovered=oN(hz,hA,dz.x,dz.y,dz.width,dz.height)end;if d2 then local mW=false;for dS,eF in ipairs(nT)do if eF.hovered then mW=true;break end end;if nQ.hovered then mW=true end;d2=mW else d2=nQ.hovered;if not d2 then d3=bo end end end;local function oQ(jU)if not bM or bM==""then bM="HELP"end;if w then for dN,dz in pairs(iM)do local jO="dim brightstroke"local oR=0.2;if bM==dN then jO="pbright dimstroke"oR=0.6 end;local oS=""if dz.hovered then oR=0.8;oS=";stroke:white"end;jU[#jU+1]=dm([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dz.width,dz.height,dz.x,dz.y,jO,oR,oS)jU[#jU+1]=gF(dz.x+dz.width/2,dz.y+dz.height/2+5,dz.label,"txt txtmid pdim")end end end;local function oT(jU)local function oU(jU,oV,hover,hz,hA,oW,oX,oY,oZ,o_,p0,nU)if type(o_)=="function"then o_=o_(nU)end;if type(p0)=="function"then p0=p0(nU)end;jU[#jU+1]=dm("<rect x='%f' y='%f' width='%f' height='%f' fill='",hz,hA,oW,oX)if oV then jU[#jU+1]=dm("%s'",oY)else jU[#jU+1]=oZ end;if hover then jU[#jU+1]=dm(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else jU[#jU+1]=dm(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fN(ag*0.5,0),fN(ah*0.5,0),fN(ai*0.5,0))end;jU[#jU+1]=" rx='5'></rect>"jU[#jU+1]=dm("<text x='%f' y='%f' font-size='24' fill='",hz+oW/2,hA+oX/2+5)if oV then jU[#jU+1]="black"else jU[#jU+1]="white"end;jU[#jU+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oV then jU[#jU+1]=dm("%s</text>",o_)else jU[#jU+1]=dm("%s</text>",p0)end end;local p1=dm("rgb(%d,%d,%d)'",fN(ag*0.1,0),fN(ah*0.1,0),fN(ai*0.1,0))local p2=dm("rgb(%d,%d,%d)",fN(ag*0.8,0),fN(ah*0.8,0),fN(ai*0.8,0))local p3=oU;for dS,dz in pairs(iJ)do local nl=dz.disableName;local nk=dz.enableName;if type(nl)=="function"then nl=nl(dz)end;if type(nk)=="function"then nk=nk(dz)end;if not dz.drawCondition or dz.drawCondition(dz)then p3(jU,dz.toggleVar(dz),dz.hovered,dz.x,dz.y,dz.width,dz.height,p2,p1,nl,nk,dz)end end end;local p4=fN(ad/2,0)local p5=fN(ae/2,0)local jU={}if p6 then jU[#jU+1]=p6 end;ct.HUDPrologue(jU)if w then ct.UpdateHud(jU)else if A then ct.DrawVerticalSpeed(jU,ck)end;ct.DrawWarnings(jU)end;if iQ and iR~="none"then ct.DrawSettings(jU)end;if cw then ct.DrawRadarInfo()else i7=""end;ct.HUDEpilogue(jU)jU[#jU+1]=dm([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c5~="empty"then ct.DisplayMessage(jU,c5)end;if iz()==0 and g=="virtual joystick"then if v then ct.DrawDeadZone(jU)end end;oQ(jU)if iB()==0 then if iz()==1 and c3 then if not p7 then oM()oT(jU)end;if not cz and not cA then local p8=table.concat(jU,"")jU={}jU[#jU+1]=dm("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jU[#jU+1]=p8;jU[#jU+1]="</body>"cz=true;jU[#jU+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cA then local p8=table.concat(jU,"")jU={}jU[#jU+1]=dm("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jU[#jU+1]=p8;jU[#jU+1]="</body>"end;if not cz then jU[#jU+1]=dm([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p4,p5,cb,cc)end else oL()end else if not c3 and iz()==0 then oL()if df>aA then if v then oK(jU)end end elseif c3 and(not p7 or not j)then oM()oT(jU)end;jU[#jU+1]=dm([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p4,p5,cb,cc)end;jU[#jU+1]=[[</svg></body>]]p9=table.concat(jU,"")end;function nX.TenthTick()local function pa()local pb=a.createData;local pc=a.createWidget;pd=a.createWidgetPanel("Interplanetary Helper")pe=pc(pd,"value")pf=pb('{"label": "Target Planet", "value": "N/A", "unit":""}')fL(pf,pe)pg=pc(pd,"value")ph=pb('{"label": "distance", "value": "N/A", "unit":""}')fL(ph,pg)ge=pc(pd,"value")gd=pb('{"label": "Travel Time", "value": "N/A", "unit":""}')fL(gd,ge)gg=pc(pd,"value")gf=pb('{"label": "Target Altitude", "value": "N/A", "unit":""}')fL(gf,gg)pi=pc(pd,"value")pj=pb('{"label": "End Speed", "value": "N/A", "unit":""}')g8=pc(pd,"value")g7=pb('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g6=pc(pd,"value")g5=pb('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g4=pc(pd,"value")g3=pb('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g2=pc(pd,"value")g1=pb('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ga=pc(pd,"value")g9=pb('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ci then fL(pj,pi)fL(g7,g8)fL(g5,g6)fL(g3,g4)fL(g1,g2)fL(g9,ga)end end;local function pk()gE(pd)pd=nil end;ct.DrawTanks()if shield then ct.DrawShield()end;if bm~="None"then if pd==nil then pa()end;if bm~=nil then local mx;local pl=fY~=nil;local pm=b6 and bi*3.6 or 0;fK(pf,'{"label": "Target", "value": "'..bm..'", "unit":""}')if pl and not b6 then mx=(cQ-fY.position):len()else mx=(bn-cQ):len()end;if not b7 then c8,c9=cv.GetAutopilotBrakeDistanceAndTime(cN)iU,iV=cv.GetAutopilotBrakeDistanceAndTime(a1)else c8,c9=cv.GetAutopilotTBBrakeDistanceAndTime(cN)iU,iV=cv.GetAutopilotTBBrakeDistanceAndTime(a1)end;local ll=iE(mx)fK(ph,'{"label": "distance", "value": "'..ll..'"}')fK(gd,'{"label": "Travel Time", "value": "'..iF(lq)..'", "unit":""}')ll=iE(c8)fK(g7,'{"label": "Cur Brake distance", "value": "'..ll..'"}')fK(g5,'{"label": "Cur Brake Time", "value": "'..iF(c9)..'", "unit":""}')ll=iE(iU)fK(g3,'{"label": "Max Brake distance", "value": "'..ll..'"}')fK(g1,'{"label": "Max Brake Time", "value": "'..iF(iV)..'", "unit":""}')fK(pj,'{"label": "End Speed", "value": "'..dm("%.0fkph",pm)..'", "unit":""}')ll=iE(gh)fK(gf,'{"label": "Target Orbit", "value": "'..ll..'"}')if ci and not pn then a.removeDataFromWidget(g1,g2)a.removeDataFromWidget(pj,pi)a.removeDataFromWidget(g3,g4)a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)pn=true;if not cT and t and(b8 or bb or cg)then cv.cmdThrottle(1)b3=false;bX=false end end;if not ci and pn then if fK(g1,g2)==1 then fL(g1,g2)end;if fK(g1,pi)==1 then fL(pj,pi)end;if fK(g3,g4)==1 then fL(g3,g4)end;if fK(g5,g6)==1 then fL(g5,g6)end;if fK(g7,g8)==1 then fL(g7,g8)end;if fK(g9,ga)==1 then fL(g9,ga)end;pn=false end end else pk()end;if warpdrive~=nil then local po=ix(warpdrive.getWidgetData())if po.destination~="Unknown"and po.distance>400000 then if not j6 then warpdrive.showWidget()j6=true end elseif j6 then warpdrive.hideWidget()j6=false end end end;function nX.OneSecondTick()local function pp()local jG=bO()local l6=cN;local pq=jG-j4;if l6>1.38889 then l6=l6/1000;local pr=l6*(jG-j4)bq=bq+pr;j1=j1+pr end;j2=j2+pq;br=br+pq;j4=jG end;local function ps(jU)local pt=0;local pu=iH;local pv=0;local pw=0;local px=0;local jM=0;local jN=""local py=b.getElementHitPointsById;local pz=b.getElementMaxHitPointsById;local pA={}for dN in pairs(iG)do local pB=0;local pC=0;pC=pz(iG[dN])pB=py(iG[dN])pv=pv+pB;if pB+1<pC then if pB==0 then px=px+1 else pw=pw+1 end;if j5 and#pA==0 then fP=vec3(b.getElementPositionById(iG[dN]))local hz=fP.x;local hA=fP.y;local hB=fP.z;table.insert(pA,b.spawnArrowSticker(hz,hA,hB+1,"down"))table.insert(pA,b.spawnArrowSticker(hz,hA,hB+1,"down"))b.rotateSticker(pA[2],0,0,90)table.insert(pA,b.spawnArrowSticker(hz+1,hA,hB,"north"))table.insert(pA,b.spawnArrowSticker(hz+1,hA,hB,"north"))b.rotateSticker(pA[4],90,90,0)table.insert(pA,b.spawnArrowSticker(hz-1,hA,hB,"south"))table.insert(pA,b.spawnArrowSticker(hz-1,hA,hB,"south"))b.rotateSticker(pA[6],90,-90,0)table.insert(pA,b.spawnArrowSticker(hz,hA-1,hB,"east"))table.insert(pA,b.spawnArrowSticker(hz,hA-1,hB,"east"))b.rotateSticker(pA[8],90,0,90)table.insert(pA,b.spawnArrowSticker(hz,hA+1,hB,"west"))table.insert(pA,b.spawnArrowSticker(hz,hA+1,hB,"west"))b.rotateSticker(pA[10],-90,0,90)table.insert(pA,iG[dN])end elseif j5 and#pA>0 and pA[11]==iG[dN]then for jF in pairs(pA)do b.deleteSticker(pA[jF])end;pA={}end end;pt=fN(pv/pu*100,2)if px>0 or pw>0 then jU[#jU+1]=gF(0,0,"","pbright txt")jM=bP(pt*2.55)jN=dm("rgb(%d,%d,%d)",255-jM,jM,0)jU[#jU+1]=gF("50%",1035,"Elemental Integrity: "..pt.."%","txtbig txtmid","fill:"..jN)if px>0 then jU[#jU+1]=gF("50%",1055,"Disabled Modules: "..px.." Damaged Modules: "..pw,"txtbig txtmid","fill:"..jN)elseif pw>0 then jU[#jU+1]=gF("50%",1055,"Damaged Modules: "..pw,"txtbig txtmid","fill:"..jN)end end end;local function pD()if iw then if iW==nil and(hd~=nil or bp)then _autoconf.displayCategoryPanel(iw,weapon_size,"Weapons","weapon",true)iW=_autoconf.panels[_autoconf.panels_size]elseif iW~=nil and hd==nil and not bp then gE(iW)iW=nil end end end;local jU={}pp()if s then ps(jU)end;pD()ct.UpdatePipe()ct.ExtraData(jU)j3=table.concat(jU,"")end;function nX.AnimateTick()cA=true;cz=false;cb=0;cc=0;c.stopTimer("animateTick")end;function nX.MsgTick()local jU={}ct.DisplayMessage(jU,"empty")c5="empty"c.stopTimer("msgTick")c6=3 end;function nX.ButtonSetup()nw()nB()iJ=iK end;if pE then for dN,dz in pairs(pE)do nX[dN]=dz end end;return nX end;local function pF(d,b,c,e,vBooster,hover,pG,antigrav,dbHud_1,f0,bP,bQ,iz,eW,bO,dn,iA,fK,iB,dq,fN,fM,iC,dr,iE,iF,pH,ix,dk)local a=DUSystem;local bR=DUConstruct;local pI={}local pJ=false;local pK=0;local pL=0;local pM=0;local pN=bO()local pO=0;local pP=0;local pQ=0;local pR=0;local pS=false;local pT=false;local pU=false;local pV=nil;local pW=0;local iT=55;local pX=nil;local pY=false;local pZ=false;local p_=false;local q0=0;local q1=0;local q2=0;local q3=0;local q4=0;local q5={VectorToTarget=false}local q6=vec3(bR.getWorldOrientationUp())local q7=nil;local q8=0;local q9=-1;local qa=-1;local qb=false;local qc=false;local qd=0;local qe=false;local qf=false;local qg=false;local qh=false;local qi=""local qj=false;local qk=false;local ql=""local qm=false;local qn=0;local qo=0;local function qp()return bR.isInPvPZone()~=1,f0(bR.getDistanceToSafeZone())end;local function qq(ki)local qr=bi;if not b6 then qr=0 end;local qs=bv;if ci then if bx and bx>0 then qs=bx else return 0,0 end end;return cr.computeDistanceAndTime(ki,qr,cl,0,0,qs-bk*cl)end;local function qt(ki)local qr=bi;if not b6 then qr=0 end;return cr.computeDistanceAndTime(ki,qr,cl,d:maxForceForward(),a3,bv-bk*cl)end;local function qu(qv,qw,qx)qw=qw:project_on_plane(qv)qx=qx:project_on_plane(qv)return eW(qw:cross(qx):dot(qv),qw:dot(qx))end;local qy=-1;local qz=-1;local function qA()local function qB()local qC=-1;local qD=-1;if vBooster then qC=vBooster.getDistance()if qC>-1 and qC<0.01 then qC=qy else qy=qC end end;if hover then qD=hover.getDistance()if qD>-1 and qD<0.01 then qD=qz else qz=qD end end;if qC~=-1 and qD~=-1 then if qC<qD then return qC else return qD end elseif qC~=-1 then return qC elseif qD~=-1 then return qD else return-1 end end;local qE=qB()local qF=-1;if antigrav and antigrav.isActive()==1 and not r and cN<iT then local qG=f0(ck-antigrav.getBaseAltitude())if qG<50 then return qG end end;if pG then qF=pG.raycast().distance;if qF==0 then qF=-1 end end;if qE~=-1 and qF~=-1 then if qE<qF then return qE else return qF end elseif qE~=-1 then return qE else return qF end end;local function qH(kt,eN,qI)local function qJ(qK,dZ)local eT=vec3(dZ)if qK.id==0 then return setmetatable({latitude=eT.x,longitude=eT.y,altitude=eT.z,id=0,systemId=qK.systemId},e0)end;local eU=eT-qK.center;local cd=eU:len()local e5=cd-qK.radius;local e3=0;local e4=0;if not dr(cd,0)then local eV=eW(eU.y,eU.x)e4=eV>=0 and eV or 2*math.pi+eV;e3=math.pi/2-math.acos(eU.z/cd)end;return setmetatable({latitude=math.deg(e3),longitude=math.deg(e4),altitude=e5,id=qK.id,systemId=qK.systemId},e0)end;local qL=qJ(kt,eN)qL="::pos{"..qL.systemId..","..qL.id..","..qL.latitude..","..qL.longitude..","..qL.altitude.."}"if qI then return qL else qg=qL;return true end end;local function qM(qN,qO,qP)local function qQ(qN,ew)qN=vec3(qN)ew=vec3(ew):normalize()local dI=qN*ew;return dI.x+dI.y+dI.z end;local qR=0.001;local qS=1;if not ci or not cC or ch~=-1 or cN<iT then if qP==nil then qP=aT end;if qO==nil then qO=qR end;qN=vec3(qN):normalize()local qT=vec3()-qN;local qU=-qQ(qT,bR.getWorldOrientationRight())*qS;local qV=-qQ(qT,bR.getWorldOrientationUp())*qS;if pL==0 then pL=qU/2 end;if pM==0 then pM=qV/2 end;if f0(qU)<0.1 then q1=q1-qU*2 else q1=q1-(qU+(qU-pL)*qP)end;if f0(qV)<0.1 then q0=q0+qV*2 else q0=q0+qV+(qV-pM)*qP end;pL=qU;pM=qV;if f0(qU)<qO and f0(qV)<qO then return true end;return false elseif cC and ch==-1 then qN=cM;if qP==nil then qP=aT end;if qO==nil then qO=qR end;qN=vec3(qN):normalize()local qT=cJ-qN;local qU=-qQ(qT,bR.getWorldOrientationRight())*qS;local qV=-qQ(qT,bR.getWorldOrientationUp())*qS;if pL==0 then pL=qU/2 end;if pM==0 then pM=qV/2 end;if f0(qU)<0.1 then q1=q1-qU*5 else q1=q1-(qU+(qU-pL)*qP)end;if f0(qV)<0.1 then q0=q0+qV*5 else q0=q0+qV+(qV-pM)*qP end;pL=qU;pM=qV;if f0(qU)<qO and f0(qV)<qO then return true end;return false end end;function pI.clearAll()be=false;bg=false;bh=false;b6=false;bf=false;bj="Aligning"b4=false;b5=false;cZ=nil;b8=false;bb=false;b9=false;ba=false;bc=false;c2=false;pZ=false;ce=false;cf=false;p_=false;cB=q;bt=false;b7=false;cm=false;bw=nil;bC=false;dd=false;de=nil;cg=false end;function pI.GetAutopilotBrakeDistanceAndTime(ki)return qq(ki)end;function pI.GetAutopilotTBBrakeDistanceAndTime(ki)return qt(ki)end;function pI.showWayPoint(kt,eN,qI)return qH(kt,eN,qI)end;function pI.APTick()local qW=a.getMouseWheel()if qW>0 then cv.changeSpd()elseif qW<0 then cv.changeSpd(true)else pY=true end;qd=iB()if qg then a.setWaypoint(qg)qg=false end;if qj then antigrav.setTargetAltitude(qj)qj=false end;if qh then fK(qh,qi)qh=false;qi=""end;if qa~=-1 then cv.cmdCruise(qa,qb)qb=false;qa=-1 end;if q7~=nil then if iA:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iA:getTargetSpeed(axisCommandId.longitudinal)~=q7 then iA:setTargetSpeedCommand(axisCommandId.longitudinal,q7)else q7=nil end end;if q9~=-1 then cv.cmdThrottle(q9,qb)qb=false;q9=-1 end;if qc then cx.landingGear(qc)qc=false end;if qk then cv.ToggleAutopilot()end end;function pI.ToggleIntoOrbit()cG=false;pQ=nil;pR=nil;pW=0;pT=false;if not ci then if bC then fM("orOff","AP")bC=false;pS=false;pV=nil;cB=q;if b8 then b8=false;ba=false end;q5.VectorToTarget=false;q5.AutopilotAlign=false;pU=false elseif c_ then fM("orOn","AP")bC=true;cB=true;if pV==nil then pV=kt end;if b8 then b8=false;ba=false end else dk("Unable to engage auto-orbit, not near a planet")end else bC=false;pS=false;pV=nil;cB=q;if b8 then b8=false end;q5.VectorToTarget=false;q5.AutopilotAlign=false;pU=false end end;function pI.ToggleVerticalTakeoff()b8=false;if bc then qX=true;bb=false;ba=false;b9=true;cB=true;c1=0;if ci and ch==-1 then b9=false;b8=true;c1=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qa=bP(cD)end else cG=false;bp=false;d.control.retractLandingGears()iA:setTargetGroundAltitude(Z)b3="VTO Takeoff"end;bc=not bc end;function pI.checkLOS(qN)local lo,eL,eM=cq:getPlanetarySystem(0):castIntersections(cQ,qN,function(eu)if eu.noAtmosphericDensityAltitude>0 then return eu.radius+eu.noAtmosphericDensityAltitude else return eu.radius+eu.surfaceMaxAltitude*1.5 end end)local lp=eL;if eM~=nil and eL~=nil then lp=math.min(eM,eL)end;if lp~=nil then return lo,lp else return nil,nil end end;local function qY(qZ,q_)if q_ then c1=0;iA:updateCommandFromActionStop(axisCommandId.vertical,q_)if bE then iA:activateGroundEngineAltitudeStabilization(r0)dg=true end else c1=c1+qZ;iA:deactivateGroundEngineAltitudeStabilization()iA:updateCommandFromActionStart(axisCommandId.vertical,qZ)end end;function pI.vertical(qZ,q_)qY(qZ,q_)end;function pI.ToggleAutopilot()local function r1(bA)d0=false;bt=not bt;if bt then b7=false;if not b8 and not bA then cv.ToggleAltitudeHold()end end;ls="Proceeding to Waypoint"end;local function r2(gq)if gq then for M,dN in pairs(cW)do if dN.name and dN.name==gq then return M end end else return 0 end end;local r3=false;bK=false;if bS-pP<1.5 and ci then if not cI then if ci then bd=kt.spaceEngineMinAltitude-0.01*kt.noAtmosphericDensityAltitude;fM("11","EP")pP=-1;if b6 or bt or bC then return end else dk("No space engines detected, Orbital Hop not supported")return end elseif kt.hasAtmosphere then if ci then bd=kt.noAtmosphericDensityAltitude+V;fM("orH","OH")end;pP=-1;if b6 or bt or bC then return end end else pP=bS end;r4=false;if(bo>0 or#bI>0)and not b6 and not bt and not cf and not bC then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cl then dk("WARNING: Heavy Loads may affect autopilot performance.")end;if#bI>0 and not cg then bo=r2(bI[1])cu.UpdateAutopilotTarget()dk("Route Autopilot in Progress")local qT=fY.position-cQ;local r5=qT:project_on_plane(cO):len()if r5>50000 and fY.planetname==kt.name then r3=true end end;cu.UpdateAutopilotTarget()cv.showWayPoint(ca,bn)if fY~=nil then if fY.agg and not r and antigrav then if not cS then cv.ToggleAntigrav()end;by=fY.agg end;bw=nil;bA=fY.planetname=="Space"if bA then fM("apSpc","AP")if ci then cf=true;cv.ToggleAltitudeHold()else b6=true end elseif kt.name==fY.planetname then qX=true;if ci then if not bt then fM("vtt","AP")r1(bA)if r3 then bd=kt.noAtmosphericDensityAltitude+V end end else fM("apOn","AP")if not(ca.name==kt.name and ck<gh*1.5)then cG=false;b6=true elseif not ci then if bC then cv.ToggleIntoOrbit()end;cF=(kt.noAtmosphericDensityAltitude>0 and kt.noAtmosphericDensityAltitude or kt.surfaceMaxAltitude)+V;pU=true;q5.AutopilotAlign=true;q5.VectorToTarget=true;pS=false;if not bC then cv.ToggleIntoOrbit()end end end else fM("apP","AP")b4=false;b5=false;if ci then cf=true;cv.ToggleAltitudeHold()else b6=true end end elseif not ci then if fY==nil and(ca.name==kt.name and c_)and not bC then r6=false;cG=false;pS=false;cF=(kt.noAtmosphericDensityAltitude>0 and kt.noAtmosphericDensityAltitude or kt.surfaceMaxAltitude)+V;pU=true;cv.ToggleIntoOrbit()else fM("apP","AP")b6=true;b4=false;b5=false;bf=false;c2=false;b8=false;b9=false;bb=false;ba=false;pZ=false;bw=nil;r6=false end else fM("apP","AP")cf=true;cv.ToggleAltitudeHold()end;qk=false else fM("apOff","AP")cv.ResetAutopilots(1)if qk==2 then qk=true end end end;function pI.routeWP(r7,r8,r9)if r9 then if r9==1 then bI={}bI=iC(bI,bH)if#bI>0 then dk("Route Loaded")else dk("No Saved Route found on Databank")end;return bI else bH={}bH=iC(bH,bI)dk("Route Saved")pH()return end end;if r7 then return bI end;if r8 then bI={}dk("Current Route Cleared")else bI[#bI+1]=fY.name;dk("Added "..fY.name.." to route. ")end;return bI end;function pI.cmdThrottle(dO,ra)if iA:getAxisCommandType(0)~=axisCommandType.byThrottle and not ra then d.control.cancelCurrentControlMasterMode()end;iA:setThrottleCommand(axisCommandId.longitudinal,dO)bT=dn(fN(dO*100,0)/100,-1,1)q7=nil end;function pI.cmdCruise(dO,ra)if iA:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ra then d.control.cancelCurrentControlMasterMode()end;iA:setTargetSpeedCommand(axisCommandId.longitudinal,dO)q7=dO end;function pI.ToggleLockPitch()if bw==nil then fM("lkPOn","LP")if not c3 then bw=cU else bw=S end;ba=false;b8=false;b9=false else fM("lkPOff","LP")bw=nil end end;function pI.ToggleAltitudeHold()if bS-pO<1.5 then bK=false;if kt.hasAtmosphere then if ci then bd=kt.spaceEngineMinAltitude-0.01*kt.noAtmosphericDensityAltitude;fM("11","EP")else if c_ then bd=kt.noAtmosphericDensityAltitude+V;cF=bd;pU=true;if not bC then cv.ToggleIntoOrbit()end;pS=true end end;pO=-1;if b8 or bC or bc then return end end else pO=bS end;if c_ and not ci and ch==-1 then cF=ck;pU=true;pS=true;cv.ToggleIntoOrbit()if bC then pO=bS else pO=0 end;return end;b8=not b8;b9=false;bb=false;if b8 then b6=false;b5=false;b4=false;c2=false;cB=true;bw=nil;cG=false;if ch~=-1 then if not bp and not bt and not cf then bd=ck;bK=ch;iA:setTargetGroundAltitude(bK)elseif cN<20 then if bp then cx.landingGear()end;fM("lfs","LS")ba=true;if ci then bd=ck+Y else bd=kt.surfaceMaxAltitude+100 end;b3="ATO Hold"iA:setTargetGroundAltitude(Z)if b2 and cR then cv.ToggleVerticalTakeoff()end end else fM("altOn","AH")ba=false;if pO>-1 then if c_ then bd=ck end end;if bc then cv.ToggleVerticalTakeoff()end end;if cS and not r then local rb=antigrav.getBaseAltitude()if bt and fY.agg and fY.agg>ck then bd=fY.agg elseif ba then bd=rb end;if f0(ck-rb)<100 and cN<20 then bd=rb;b3="AGG Hold"q9=0 end end;if cf then bd=200000 end else fM("altOff","AH")if bC then cv.ToggleIntoOrbit()end;if bc then cv.ToggleVerticalTakeoff()end;cB=q;ba=false;bt=false;pO=0;bK=false end end;function pI.ResetAutopilots(pI)if pI then cf=false;b6=false;bf=false;pZ=false;bd=ck;r4=false;dd=false;bj="Aligning"end;bt=false;ba=false;bb=false;b5=false;b9=false;de=nil;rc=false;cZ=nil;dd=false;if not cS then b8=false;bw=nil end;if bc then cv.ToggleVerticalTakeoff()end;if bC then cv.ToggleIntoOrbit()end;cB=q;ce=false;cg=false;c1=0 end;function pI.BrakeToggle(rd)if not b3 then if rd then b3=rd else b3=true end else b3=false end;if b9 then b9=false;cB=q;dd=false end;if b3 then fM("bkOn","B",1)cv.ResetAutopilots()else fM("bkOff","B",1)end end;function pI.BeginReentry()if bb then dk("Re-Entry cancelled")fM("reOff","RE")bb=false;cB=q;b8=false elseif not kt.hasAtmosphere then dk("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c6=5 elseif not p_ then bb=true;if iA:getAxisCommandType(0)~=re.cruise then d.control.cancelCurrentControlMasterMode()end;cB=true;b3=false;dk("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cD)fM("par","RE")else bb=true;b8=true;cB=true;b3=false;bd=kt.surfaceMaxAltitude+a0;if bd>kt.spaceEngineMinAltitude then bd=kt.spaceEngineMinAltitude-0.01*kt.noAtmosphericDensityAltitude end;local rf=iE(bd)dk("Beginning Re-entry.  Target speed: "..cD.." Target Altitude: "..rf)fM("glide","RE")qa=bP(cD)end;ba=false end;function pI.ToggleAntigrav()if antigrav and not r then if cS then fM("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if by==nil then by=ck end;if by<1000 then by=1000 end;fM("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pI.changeSpd(rg)local rh=1;if rg then rh=-1 end;if not c3 then if t and not p7 and pY then local ri=bT;bT=fN(dn(bT+rh*aF/100,-1,1),2)if bT>=0 and ri<0 then bT=0;pY=false end elseif p7 then if ci or bb then cD=dn(cD+rh*aF,0,W)elseif b6 then a1=dn(a1+rh*aF/3.6*100,0,dh-0.2)end else iA:updateCommandFromActionStart(axisCommandId.longitudinal,rh*aF/10)end else if b6 or bt or cf or bC then d3=d3+1*rh*-1;if d3>#cW then d3=1 end;if d3<1 then d3=#cW end else if not rg then rh=1 else rh=nil end;cu.adjustAutopilotTargetIndex(rh)end end end;function pI.TenthTick()local function rj()if not b6 then if fY==nil or fY.planetname~=kt.name then rk=(ca.center-cQ):len()else rk=(fY.position-cQ):len()end end;local ki=cN;local rl=c.getThrottle()/100;if t then rl=bT end;local rm,rn=cr.computeDistanceAndTime(cN,a1,cl,d:maxForceForward()*rl,a3,0)local c8,c9;if not b7 then c8,c9=cv.GetAutopilotBrakeDistanceAndTime(a1)else c8,c9=cv.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dS,ro;if not b7 and ki>0 then dS,ro=cv.GetAutopilotBrakeDistanceAndTime(ki)else dS,ro=cv.GetAutopilotTBBrakeDistanceAndTime(ki)end;local rp=0;local rq=0;if bh or not b6 and ki>5 then rq=cr.computeTravelTime(ki,0,rk)elseif c8+rm<rk then rp=rk-(c8+rm)rq=cr.computeTravelTime(a1,0,rp)else local rr=(rk-c8)/rm;rm=rk-c8;rn=rn*rr end;if fY~=nil and fY.planetname==kt.name and not b6 then return rq elseif bg then return ro elseif bh then return rq+ro else return rn+c9+rq end end;local function rs()local ob=b.getGravityIntensity()ob=fN(ob,5)if pX==nil or pX~=ob then local ki=cL:len()local rt=bR.getMaxBrake()if rt~=nil and rt>0 and ci then rt=rt/dn(ki/100,0.1,1)rt=rt/cj;if cj>0.10 then bx=rt end end;if rt~=nil and rt>0 then bv=rt end;pX=ob end end;d5=bR.getDockedConstructs()d4=bR.getPlayersOnBoard()qo=0;for M=1,#d5 do qo=qo+bR.getDockedConstructMass(d5[M])end;local ru=0;for M=1,#d4 do ru=ru+bR.getBoardedPlayerMass(d4[M])end;if ru>20000 then qo=qo+ru-20000 end;cX,cY=qp()dh=bR.getMaxSpeed()if bm~="None"and(ca or fY)then lq=rj()end;rs()end;local rv=pid.new(10,0,10.0)local function rw(rx,ry)local oB=vec3()local rz=vec3()if rx==axisCommandId.longitudinal then oB=vec3(bR.getOrientationForward())rz=cJ elseif rx==axisCommandId.vertical then oB=vec3(bR.getOrientationUp())rz=q6 elseif rx==axisCommandId.lateral then oB=vec3(bR.getOrientationRight())rz=cK else return vec3()end;local rA=vec3(b.getWorldGravity())local rB=rA:dot(rz)local rC=vec3(bR.getWorldAirFrictionAcceleration())local rD=rC:dot(rz)local rE=cL:dot(oB)local rF=ry*constants.kph2m;rv:inject(rF-rE)local rG=rv:get()local rH=(rG-rD-rB)*rz;return rH end;local rI=pid.new(10,0,10.0)local function rJ(rx,ry)local oB=vec3()local rz=vec3()if rx==axisCommandId.longitudinal then oB=vec3(bR.getOrientationForward())rz=cJ elseif rx==axisCommandId.vertical then oB=vec3(bR.getOrientationUp())rz=q6 elseif rx==axisCommandId.lateral then oB=vec3(bR.getOrientationRight())rz=cK else return vec3()end;local rA=vec3(b.getWorldGravity())local rB=rA:dot(rz)local rC=vec3(bR.getWorldAirFrictionAcceleration())local rD=rC:dot(rz)local rE=cL:dot(oB)local rF=ry*constants.kph2m;rI:inject(rF-rE)local rG=rI:get()local rH=(rG-rD-rB)*rz;return rH end;local function rK(rL,jX,fU)local rM=rL:cross(fU):normalize_inplace()local kK=math.acos(dn(rM:dot(-jX),-1,1))*constants.rad2deg;if rM:cross(-jX):dot(fU)<0 then kK=-kK end;return kK end;local function rN()if d1 and not b9 then local eu=d1[1]local hX,hY=d1[2],d1[3]local rO=math.min(hX,hY or hX)local rP=rO/cN;local rQ=ba and(cN<42 or ch~=-1)local rR=b8 or bt or bw or b6;if rR and not rQ and(c8*1.5>rO or rP<1)then b3="Collision"bI={}q9=0;if b8 then cv.ToggleAltitudeHold()end;if bw then cv.ToggleLockPitch()end;dk("Autopilot Cancelled due to possible collision")a.print(eu.name.." COLLISION "..iF(rP).." / "..iE(rO,2))cv.ResetAutopilots(1)qX=true;if ci then b9=true end;cB=true end;if rP<11 then d0=eu.name.." COLLISION "..iF(rP).." / "..iE(rO,2)else d0=eu.name.." collision "..iF(rP)end;if rP<6 then fM("alarm","AL",2)end else d0=false end end;local rS=1;local rT=0;local rU=1;local rV=1;local rW=1;local rX=false;local rY=pid.new(0.1,0,1*0.1)local rZ=pid.new(1*0.01,0,5*0.1)local r_=pid.new(aJ*0.01,0,aJ*0.1)local s0=pid.new(2*0.01,0,2*0.1)local rZ=pid.new(1*0.01,0,5*0.1)local s1=pid.new(2*0.01,0,2*0.1)local s2=pid.new(2*0.01,0,2*0.1)local s3=pid.new(2*0.01,0,2*0.1)local s4=pid.new(2*0.01,0,2*0.1)local s5=pid.new(0.1,0,1)local s6=pid.new(1*0.01,0,1*0.1)function pI.onFlush()if antigrav and not r and not cS and antigrav.getBaseAltitude()~=by then qj=by end;if dg then d:setEngineForceCommand('hover',vec3(),1)dg=false end;cT=iA:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local s7=dn(bZ+q0+a.getControlDeviceForwardInput(),-1,1)local s8=dn(b_+q2+a.getControlDeviceYawInput(),-1,1)local s9=dn(c0+q1-a.getControlDeviceLeftRightInput(),-1,1)local sa=b3 and 1 or 0;if ci then cO=vec3(b.getWorldVertical())if cO==nil or cO:len()==0 then cO=(kt.center-cQ):normalize()end else cO=(kt.center-cQ):normalize()end;q6=vec3(bR.getWorldOrientationUp())cJ=vec3(bR.getWorldOrientationForward())cK=vec3(bR.getWorldOrientationRight())cM=vec3(bR.getWorldVelocity())cL=vec3(bR.getVelocity())cQ=vec3(bR.getWorldPosition())cl=bR.getMass()+qo;cN=vec3(cM):len()cP=-cO:dot(cM)cV=getRoll(cO,cJ,cK)local sb=cV/180*math.pi;local sc=math.cos(sb)local sd=math.sin(sb)cU=rK(cO,cJ,cK*sc+q6*sd)local se=cM:normalize()local sf=f0(cV)local sg=utils.sign(cV)local sh=vec3(bR.getWorldAngularVelocity())local si=s7*aP*cK+s8*aK*cJ+s9*aQ*q6;if cB==true and cO:len()>0.01 then local sj=f0(q3-cV)if((b5 or bb or b9 or ce or b8 or bC)and sj>0 or ci and sj<aL and q)and s8==0 and f0(cU)<85 then local sk=q3;if not ci then q3=0;sk=0 end;r_:inject(sk-cV)local sl=r_:get()si=si+sl*cJ end end;bU=0;cj=bQ()ci=false or ck<kt.noAtmosphericDensityAltitude and cj>0.00001;ck=(cQ-kt.center):len()-kt.radius;ch=qA()bS=bO()pN=bS;if bp and ch>-1 and ch-3<_ then if iA.targetGroundAltitudeActivated then iA:deactivateGroundEngineAltitudeStabilization()end;iA:updateCommandFromActionStart(axisCommandId.vertical,-1)end;if cw then qm=not qm;if qm then cw.UpdateRadar()end;if E then rN()end end;if antigrav then cS=antigrav.isActive()==1 end;local sm=bS-pN;local sn=-math.deg(qu(q6,cM,cJ))local so=math.deg(qu(cK,cM,cJ))local gj=cO*-1;cC=ci and sn<-N or sn>N or so<-O or so>O;local sp=a.getMouseDeltaX()local sq=a.getMouseDeltaY()if qn then local sr=bO()-qn;sp=sp*sr/0.016;sq=sq*sr/0.016 end;qn=bO()if p and not c3 then sq=-sq end;q1=0;q2=0;q0=0;local ss=bR.getWorldPosition()kt=fQ:closestBody(ss)st=cs(kt)fm=st:orbitalParameters(ss,cM)c_=c.getClosestPlanetInfluence()>0 or ck>0 and ck<200000;local ob=kt:getGravity(ss):len()*cl;q3=0;local su=bR.getMaxThrustAlongAxis("ground",bR.getOrientationUp())[1]if qd==0 then if iz()==1 and c3 then if not cz then cb=dn(cb+sp/2,-ad/2,ad/2)cc=dn(cc+sq/2,-ae/2,ae/2)end else cb=0;cc=0 end else cb=dn(cb+sp/2,-ad/2,ad/2)cc=dn(cc+sq/2,-ae/2,ae/2)df=dq(cb*cb+cc*cc)if not c3 and iz()==0 then local kT,kU=1,1;if bM=="SCOPE"then kT,kU=d7/90,d7/90 end;if g=="virtual joystick"then if df>aA then q1=q1-dn(f0(cb)-aA,0,ad/2)*utils.sign(cb)*aH*kT;q0=q0-dn(f0(cc)-aA,0,ae/2)*utils.sign(cc)*aI*kU end else cb=0;cc=0;if g=="mouse"then q0=(-utils.smoothstep(sq,-100,100)+0.5)*2*rV;q1=(-utils.smoothstep(sp,-100,100)+0.5)*2*rW end end end end;local sv=cN>27777;if cN>X/3.6 and not ci and not b6 and not sv then dk("Space Speed Engine Shutoff reached")q9=0 end;if not sv and sw then if not b3 then cv.BrakeToggle()end;if b6 then cv.ResetAutopilots(1)end;q9=0 end;sw=sv;if cj>0.09 then if cN>cD/3.6 and not t and not pJ then b3="SpdLmt"pJ=true elseif not t and pJ then if cN<cD/3.6 then b3=false;pJ=false end end end;if b5 then if ce then b3=false;local sx=false;sx=qM(fY.position-cQ,0.1)cB=true;if sx then qa=bP(cD)if(f0(cV)<2 or f0(cU)>85)and cN>=cD/3.6-1 then b3=false;b5=false;if ce~=2 then p_=true end;if ce==true then cg=true end;ce=false;b6=false;cv.BeginReentry()end elseif ci and t then q9=1 end elseif cN>iT then qM(vec3(cM),0.01)end end;if b4 then if ci then b4=false elseif cN>iT then qM(-vec3(cM))end end;if not b5 and ce and not bC then if not ci then if ce~=2 then p_=true end;cv.BeginReentry()ce=false;cg=true else ce=false;if not qk then qk=true end end end;if cg and fY and(ck<bd+250 and ck>bd-250)and f0(cP)<25 and cj>=0.1 and(fY.position-cQ):len()>2000+ck then if not qk then qk=true end;cg=false end;if bc then cB=true;local sy=bd;if cP<-30 then dk("Unable to achieve lift. Safety Landing.")c1=0;cB=q;bc=false;b9=true elseif not r and cS or bd<kt.spaceEngineMinAltitude then if cS then sy=antigrav.getBaseAltitude()end;if ck<sy-100 then q4=0;c1=15;b3=false elseif cP>0 then b3="VTO Limit"c1=0 elseif cP<-30 then b3="VTO Fall"c1=15 elseif ck>=sy then if cS then if b6 or bt then cv.ToggleVerticalTakeoff()else b3="VTO Complete"bc=false end;dk("Takeoff complete. Singularity engaged")fM("aggLk","AG")else b3=false;dk("VTO complete. Engaging Horizontal Flight")fM("vtoc","VT")cv.ToggleVerticalTakeoff()end;c1=0 end else if cj>0.08 then q4=0;b3=false;c1=20 elseif cj<0.08 and ci then b3=false;if cH then q4=0;c1=20 else c1=0;q4=36;qa=3500 end else cB=q;bC=true;cG=false;sz=false;pS=false;pQ=nil;pR=nil;if pV==nil then pV=kt end;cF=sy;pU=true;bc=false end end;if q4~=nil then local sA=dn(q4-cU,-O*0.80,O*0.80)s0:inject(sA)local sB=dn(s0:get(),-1,1)q0=sB end end;if bC then local function sC()if not fm.apoapsis or not fm.periapsis then return false end;if fm.periapsis.altitude>=cF*0.99 and fm.apoapsis.altitude>=cF*0.99 and fm.periapsis.altitude<fm.apoapsis.altitude and fm.periapsis.altitude*1.05>=fm.apoapsis.altitude and f0(cF-ck)<1000 then return true else return false end end;local qT;local sD=false;local sE=iE(cF,4)if pV==nil then pV=kt;if bt then pV=ca end end;if not pU then cF=bP(pV.radius+pV.surfaceMaxAltitude+V)if pV.hasAtmosphere then cF=bP(pV.radius+pV.noAtmosphericDensityAltitude+V)end;pU=true end;if q5.VectorToTarget and fY then qT=fY.position-cQ end;local sF,sG=cs(pV):escapeAndOrbitalSpeed((cQ-pV.center):len()-pV.radius)sG=sG*3.6+1+(K and a_*sG*3.6 or 0)local sH=cV;if not pS then local sI=false;local sJ=false;q9=0;pR=0;cE="Aligning to orbital path - OrbitHeight: "..sE;if q5.VectorToTarget then qM(qT:normalize():project_on_plane(cO))sD=cJ:dot(qT:project_on_plane(q6):normalize())>0.95 else qM(cM)sD=sn<0.5;if cN<150 then sD=true end end;q0=0;pQ=0;if cU<=pQ+2 and cU>=pQ-2 then sI=true else sI=false end;if sH<=pR+2 and sH>=pR-2 then sJ=true else sJ=false end;if sI and sJ and sD then pQ=nil;pR=nil;pS=true end else if q5.VectorToTarget then qM(qT:normalize():project_on_plane(cO))elseif cN>150 then qM(cM)end;q0=0;if q5.VectorToTarget and fY then local c8,dS=cr.computeDistanceAndTime(cN,cD/3.6,cl,0,0,bv)if cG and qT:len()>15000+c8+ck then cE="Orbiting to Target"if ck-100<=pV.noAtmosphericDensityAltitude or lq>fm.timeToPeriapsis and fm.periapsis.altitude<pV.noAtmosphericDensityAltitude or not sC()and fm.eccentricity>0.1 then dk("Re-Aligning Orbit")cG=false end elseif cG or qT:len()<15000+c8+ck then dk("Orbit complete, proceeding with reentry")fM("orCom","OB")bn=fY.position;p_=true;cg=true;q5.VectorToTarget,q5.AutopilotAlign=false,false;cv.ToggleIntoOrbit()cv.BeginReentry()return end end;if pT or fm.periapsis~=nil and fm.apoapsis~=nil and fm.eccentricity<1 and ck>cF*0.9 and ck<cF*1.4 then if fm.apoapsis~=nil or pT then if(sC()or cG)and not K then if cG then b3=false;q9=0;pQ=0;if not q5.VectorToTarget then dk("Orbit complete")fM("orCom","OB")cv.ToggleIntoOrbit()end else pW=pW+1;if pW>=2 then cG=true end end else if sC()then cE="Maintaining "else cE="Adjusting "pT=true;qa=sG;local sK=cF-ck;rY:inject(sK-cP*dn(utils.smoothstep(2000-sK,-2000,2000)^6*10,1,10))pQ=dn(rY:get(),-75,75)end;cE=cE.." - OrbitHeight: "..sE end end else local sL=2.75;local sM=f0(fN(sF*sL))local oo=sM%50;if oo>0 then sM=sM-oo+50 end;b3=false;if ck<cF*0.8 then cE="Escaping planet gravity - OrbitHeight: "..sE;pQ=utils.map(cP,200,0,-15,80)elseif ck>=cF*0.8 and ck<cF*1.15 then cE="Approaching orbital corridor - OrbitHeight: "..sE;sM=sM*0.75;pQ=utils.map(cP,100,-100,-15,65)elseif ck>=cF*1.15 and ck<cF*1.5 then cE="Approaching orbital corridor - OrbitHeight: "..sE;sM=sM*0.75;if cP<0 or pT then pQ=utils.map(ck,cF*1.5,cF*1.01,-30,0)else pQ=utils.map(ck,cF*0.99,cF*1.5,0,30)end elseif ck>cF*1.5 then cE="Reentering orbital corridor - OrbitHeight: "..sE;pQ=-65;local sN=utils.map(cP,-150,-400,1,0.55)sM=sM*sN end;qa=bP(sM)end end;if pQ~=nil then local sO=pQ-cU;rZ:inject(sO)local sP=dn(rZ:get(),-0.5,0.5)q0=sP end end;if b6 and not ci and not ce then local function sQ(sR,fm)a.print(sR)b5=false;b3=false;bg=false;b6=false;r4=false;bj="Aligning"q9=0;pZ=false;dk(sR)fM("apCom","AP")if fm or ce then if fm and gh~=nil and not ce then if not ck or ck==0 then return end;cF=ck;pU=true end;cv.ToggleIntoOrbit()end end;local sS,sT=bn,false;if fY and fY.planetname~="Space"then bf=true;if not r4 then local sU=(fY.position-ca.center):normalize()local sV=sU:project_on_plane((ca.center-cQ):normalize()):normalize()local sW=ca.center+sV*(ca.radius+gh)local sX=fY.position+(fY.position-ca.center):normalize()*(gh-ca:getAltitude(fY.position))if(cQ-sW):len()<(cQ-sX):len()then sS=sW else sS=sX;bi=0 end;bn=sS;cv.showWayPoint(ca,bn)sT=true;r4=true end;bk=0 elseif fY and fY.planetname=="Space"then if not r4 then bk=0;sT=true;bf=true;r4=true;sS=fY.position+(cQ-fY.position):normalize()*T;bn=sS end elseif fY==nil then bk=0;if not r4 then local sU=(cQ+cM*100000-ca.center):normalize()local sV=sU:project_on_plane((ca.center-cQ):normalize()):normalize()if sV:len()<1 then sU=(cQ+cJ*100000-ca.center):normalize()sV=sU:project_on_plane((ca.center-cQ):normalize()):normalize()end;sS=ca.center+sV*(ca.radius+gh)bn=sS;r4=true;sT=true;bf=true;cv.showWayPoint(ca,bn)end end;rk=(vec3(sS)-cQ):len()local lo,eL,eM=cq:getPlanetarySystem(0):castIntersections(cQ,cM:normalize(),function(eu)if eu.noAtmosphericDensityAltitude>0 then return eu.radius+eu.noAtmosphericDensityAltitude else return eu.radius+eu.surfaceMaxAltitude*1.5 end end)local lp=eL;if eM~=nil and eL~=nil then lp=math.min(eM,eL)end;if lp~=nil and lp<rk and lo.name==ca.name then rk=lp end;local sx=true;local sY=(ca.center-(cQ+vec3(cM):normalize()*rk)):len()-ca.radius;local ll=iE(sY)qh=g9;qi='{"label": "Projected Altitude", "value": "'..ll..'"}'if cN>50 and be then local qT=vec3(sS)-cQ;local sZ=dn(math.deg(qu(q6,cM:normalize(),qT:normalize()))*cN/500,-90,90)local s_=dn(math.deg(qu(cK,cM:normalize(),qT:normalize()))*cN/500,-90,90)if f0(sZ)<20 and f0(s_)<20 then sZ=sZ*2;s_=s_*2 end;if f0(sZ)<2 and f0(s_)<2 then sZ=sZ*2;s_=s_*2 end;local sn=-math.deg(qu(q6,cJ,cM:normalize()))local so=-math.deg(qu(cK,cJ,cM:normalize()))s1:inject(s_-so)local t0=dn(s1:get(),-1,1)q0=q0+t0;s2:inject(sZ-sn)local t1=dn(s2:get(),-1,1)q1=q1+t1;sT=true;if f0(sZ)>2 or f0(s_)>2 then if bj~="Adjusting Trajectory"then bj="Adjusting Trajectory"fM("apAdj","AP")end else if bj~="Accelerating"then bj="Accelerating"fM("apAcc","AP")end end elseif be and cN<=50 then qM((sS-cQ):normalize())end;if sY<gh*1.5 then bi=cD/3.6;if fY==nil then dS,bi=cs(ca):escapeAndOrbitalSpeed(sY)end end;local c8,c9;if not b7 then c8,c9=qq(cN)else c8,c9=qt(cN)end;if b6 and not be and not bh and not bg then local lo,lp=cv.checkLOS((bn-cQ):normalize())if ca.name~=kt.name then if lo~=nil and ca.name~=lo.name and lp<rk then d0="Attempting to clear LOS between "..lo.name.." and waypoint."qe=true else qe=false;d0=false end end end;if not qe then if not bh and not bg and not sT then sx=qM((sS-cQ):normalize())elseif b7 and(bg or bh)then sx=qM(-vec3(cM):normalize())end end;if be then if not pZ then b3=false;q9=a2;bT=fN(a2,2)pZ=true end;local rl=c.getThrottle()if t then rl=bT end;local t2=99999;local om=-vec3(bR.getWorldAcceleration()):dot(cM:normalize())local t3=dn(cM:dot((sS-cQ):normalize()),0,cN)if t3>0 or om>0 then t2=cr.computeTravelTime(t3,om,rk-c8)end;if a1>dh then a1=dh-0.2 end;if cL:len()>=a1 or rl==0 and pZ or a3/4>t2 then be=false;if bj~="Cruising"then fM("apCru","AP")bj="Cruising"end;bh=true;q9=0 end;local t4=rk;if t4<=c8 or H and cY<=c8+10000 and cX then if H and cY<=c8+10000 and cX then if cY<pK and cY>2000 then cv.ResetAutopilots(1)dk("Autopilot cancelled to prevent crossing PvP Line")b3="PvP Prevent"pK=cY else pK=cY;return end end;be=false;if bj~="Braking"then fM("apBrk","AP")bj="Braking"end;bg=true;if not b7 then b5=true;cB=true end;q9=0;pZ=false end elseif bg then if bj~="Orbiting to Target"then b3="AP Brk"end;if b7 then q9=1;qb=true end;local dS,sG=cs(ca):escapeAndOrbitalSpeed((cQ-kt.center):len()-kt.radius)local qT;if fY then qT=fY.position-cQ end;if fY and fY.planetname=="Space"and cN<50 then if#bI>0 then if not qk then table.remove(bI,1)end;if#bI>0 then b3=false;if not qk then qk=2 end;return end end;sQ("Autopilot complete, arrived at space location")b3="Space Arrival"elseif fY and fY.planetname~="Space"and cN<=sG and(fm.apoapsis==nil or fm.periapsis==nil or fm.apoapsis.altitude<=0 or fm.periapsis.altitude<=0)then sQ("Autopilot complete, commencing reentry")bn=fY.position;ce=true;cv.showWayPoint(ca,bn)elseif(fY and fY.planetname~="Space"or fY==nil)and fm.periapsis~=nil and fm.periapsis.altitude>0 and fm.eccentricity<1 or bj=="Circularizing"then if bj~="Circularizing"then fM("apCir","AP")bj="Circularizing"end;if cN<=sG then if fY then if cM:normalize():dot(qT:normalize())>0.4 then if bj~="Orbiting to Target"then fM("apOrb","OB")bj="Orbiting to Target"end;if not r6 then b3=false;cv.showWayPoint(ca,fY.position)r6=true end else sQ("Autopilot complete, proceeding with reentry")bn=fY.position;ce=true;cv.showWayPoint(ca,fY.position)r6=false end else sQ("Autopilot completed, setting orbit",true)b3=false end end elseif bj=="Circularizing"then sQ("Autopilot complete, fixing Orbit",true)end elseif bh then local t4=rk;if t4<=c8 or H and cY<=c8+10000 and cX then if H and cY<=c8+10000 and cX then if cY<pK and cY>2000 then if not qk then qk=true end;dk("Autopilot cancelled to prevent crossing PvP Line")b3="Prevent PvP"pK=cY else pK=cY;return end end;be=false;if bj~="Braking"then fM("apBrk","AP")bj="Braking"end;bg=true;if not b7 then b5=true;cB=true end end;local rl=c.getThrottle()if t then rl=bT end;if rl>0 then be=true;if bj~="Accelerating"then bj="Accelerating"fM("apAcc","AP")end;bh=false end else if sx then if not bf and fY==nil or not bf and fY and fY.planetname~="Space"then if not ce then bn=vec3(ca.center)+(gh+ca.radius)*cK;t5=q6;t6=cK end;bf=true elseif sx and not qe then be=true;if bj~="Accelerating"then bj="Accelerating"fM("apAcc","AP")end;if not pZ then q9=a2;qb=true;bT=fN(a2,2)pZ=true;b3=false end end end end elseif b6 and(fY~=nil and fY.planetname~="Space"and ci)then dk("Autopilot complete, starting reentry")fM("apCom","AP")bn=fY.position;b3=false;bg=false;b6=false;r4=false;bj="Aligning"q9=0;pZ=false;b5=true;ce=true;cv.showWayPoint(ca,fY.position)end;if c2 then cB=true;local s_=0;local fo=vec3(DUPlayer.getWorldPosition())local t7=fo-cQ;local t8=vec3(t7):project_on(cJ):len()local t9=vec3(t7):project_on(cK):len()local cd=dq(t8*t8+t9*t9)qM(t7:normalize())local mx=40;local ta=cd<mx;local tb=100;local ry=dn((cd-mx)/2,10,tb)q0=0;local sx=f0(q1)<0.1;if sx and cN<ry and not ta then b3=false;s_=-20 else b3="Follow"s_=0 end;local tc=0;if f0(s_-cU)>tc then s3:inject(s_-cU)local t0=s3:get()q0=t0 end end;if b8 or b9 or bb or bt or bw~=nil then if bK then if ch==-1 then bd=bd-0.2 else bd=ck+bK-ch end end;local td=bx;if td then td=td*dn(cN/100,0.1,1)*cj else td=bv end;if not ci then td=bv end;q8=cJ:project_on_plane(cO):normalize():dot(cM)if q8>100 then c8,c9=cr.computeDistanceAndTime(q8,100,cl,0,0,td)local te,dS=cr.computeDistanceAndTime(100,0,cl,0,0,td*0.55)c8=c8+te else c8,c9=cr.computeDistanceAndTime(q8,0,cl,0,0,td*0.55)end;local sK=bd-ck-cP;local tf=200+cN;if bb or ce then tg=2000+cN end;local th=1;if ba then th=dn(cN/100,0.1,1)end;local s_=(utils.smoothstep(sK,-tf,tf)-0.5)*2*Q*th;if not bb and not ce and not bt and cJ:dot(cM:normalize())<0.99 then s_=(utils.smoothstep(sK,-tf*dn(20-19*cj*10,1,20),tf*dn(20-19*cj*10,1,20))-0.5)*2*Q*dn(2-cj*10,1,2)*th end;if not b8 then s_=0 end;if bw~=nil then if c_ and not bC then s_=bw else bw=nil end end;cB=true;local ti=q0;if bb then local tj=bP(cD)local tk,tl=cr.computeDistanceAndTime(cN,tj/3.6,cl,0,0,bv-kt.gravity*9.8*cl)tk=tk==-1 and 5000 or tk;local r5=ck-(kt.noAtmosphericDensityAltitude+tk)local tm=ck>kt.noAtmosphericDensityAltitude+tk*1.35;if tm then s_=R;if cN<=tj/3.6 and cN>tj/3.6-10 and f0(cM:normalize():dot(cJ))>0.9 and not cT then bX=false;q9=1 end elseif(cT or iA:getTargetSpeed(axisCommandId.longitudinal)~=tj)and not tm and not ci then qa=tj;qb=true end;if cT then if cN>tj/3.6 and not tm then b3="Reentry Limit"if bT>0 then q9=0 end else b3=false end else b3=false end;if cP>0 then b3="Reentry vSpd"end;if not p_ then s_=-80;if ck<kt.surfaceMaxAltitude+(kt.atmosphereThickness-kt.surfaceMaxAltitude)*0.25 then dk("PARACHUTE DEPLOYED at "..fN(ck,0))bb=false;b9=true;qX=true;q9=0;s_=0;cB=q end elseif kt.noAtmosphericDensityAltitude>0 and tm then cB=true elseif not tm then if not ci and(cT or iA:getTargetSpeed(axisCommandId.longitudinal)~=tj)then qa=tj end;if cN<tj/3.6+1 then b3=false;p_=false;bb=false;cB=true;q9=1 end end end;if cN>iT and not cf and not bt and not b9 and u then qM(vec3(cM))end;if cZ or(bt or cf)and bo>0 and ci then local qT;if cZ then if type(cZ)=="table"then qT=cZ elseif cZ<3 and cZ>0 then qT=-cO:cross(cM)*5000 elseif cZ>=3 then qT=cO:cross(cM)*5000 elseif cZ<0 then qT=cM*25000 end elseif fY~=nil then qT=fY.position-cQ else qT=ca.center-cQ end;local sZ=math.deg(qu(cO:normalize(),cM,qT))*2;local mA=math.rad(f0(cV))if cN>aM and ci then local tn=1000+cN;local to=(utils.smoothstep(sK-cP*10,-tn,tn)-0.5)*2*Q;local tp=dn(90-to,0,180)q3=dn(sZ*2,-tp,tp)local tq=sZ;sZ=dn(dn(sZ,-N*0.80,N*0.80)*math.cos(mA)+4*(cU-s_)*math.sin(math.rad(cV)),-N*0.80,N*0.80)local tr=1;if q3~=0 then tr=f0(mA/q3)end;tr=(90-dn(f0(q3-cV),0,90))/90;local ts=s_;if f0(cV)>90 then ts=-ts end;s_=tr*dn(dn(ts*math.cos(mA),-O*0.8,O*0.8)+f0(dn(f0(tq)*math.sin(mA),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q3=0;sZ=dn(sZ,-N*0.80,N*0.80)end;local tt=sn-sZ;if cZ and f0(tt)<=0.0001 and(type(cZ)=="table"or type(cZ)~="table"and cZ<0 and f0(cV)<1)then if cZ==-2 then cv.ToggleAltitudeHold()end;cZ=nil;fM("180Off","BR")return end;if not cC and cN>aM and ci then s4:inject(tt)local t1=dn(s4:get(),-1,1)q1=q1+t1 elseif ci and ch>-1 or cN<aM then qM(qT)elseif cC and ci then if(sn<-N or sn>N)and ci then qM(cM)end;if(so<-O or so>O)and ci then s_=dn(cU-so,cU-O*0.80,cU+O*0.80)end end;if fY~=nil and not cf then local sy=kt:getAltitude(fY.position)local r5=qT:project_on_plane(cO):len()qX=true;if bd<kt.noAtmosphericDensityAltitude and not cf and not ba and not bb and(r5<=c8 and qT:len()<kt.radius)and(cM:project_on_plane(cO):normalize():dot(qT:project_on_plane(cO):normalize())>0.99 or ls=="Finalizing Approach")then ls="Finalizing Approach"if#bI>0 then if not qk then table.remove(bI,1)end;if#bI>0 then if not qk then qk=2 end;return end end;q9=0;if b8 then cv.ToggleAltitudeHold()bt=true end;b3="AP Finalizing"elseif not ba then b3=false end;if ls=="Finalizing Approach"and(q8<0.1 or r5<0.1 or tu~=nil and tu<r5)then fM("bklOn","BL")b9=true;dd=true;if fY.heading then de=fY.heading else de=nil end;bt=false;ls="Proceeding to Waypoint"d0=false end;tu=r5 end elseif bt and not ci and bd>kt.noAtmosphericDensityAltitude and not(cf or bb)then if fY~=nil and ca.name==kt.name then local qT=fY.position-cQ;local sy=kt:getAltitude(fY.position)local r5=dq(qT:len()^2-(ck-sy)^2)local td=bx;if td then c8,c9=cr.computeDistanceAndTime(cN,0,cl,0,0,td/2)qX=true;if r5<=c8+cN*sm/2 and cM:project_on_plane(cO):normalize():dot(qT:project_on_plane(cO):normalize())>0.99 then if kt.hasAtmosphere then b3=false;b5=false;p_=true;ce=false;cg=true;b6=false;cv.BeginReentry()end end;tu=r5 end end end;if not ci and ch==-1 and(b8 and bd>kt.noAtmosphericDensityAltitude)and not(cf or bC or bb)then if not cG and not bC then cF=bd;pU=true;if bt then q5.VectorToTarget=true end;cv.ToggleIntoOrbit()bt=false;pS=true end end;if cC and ci and ch==-1 and cN>aM and ls~="Finalizing Approach"then qM(cM)s_=dn(cU-so,cU-O*0.80,cU+O*0.80)end;q0=ti;local qF=-1;if b9 then local tv=aZ or 0.05;if not qf then rX=false;if not cT then q9=0 end;if ch==-1 then iA:setTargetGroundAltitude(500)iA:activateGroundEngineAltitudeStabilization(500)end;if not ci then rX=true end;qf=true end;s_=0;local tw=false;local tx=math.abs(q8)if not r and cS then tw=antigrav.getBaseAltitude()if tw<kt.surfaceMaxAltitude and fY==nil or fY~=nil and kt:getAltitude(fY.position)>tw then tw=false end else tw=false end;if de then if tx<tv then if cP>-P then b3=false else b3="BL Align BLR"end;if qM(de,0.001)then de=nil;cB=q else q0=0;cB=true end else b3="BL Align Hzn"end;if tw and f0(ck-tw)<250 then b3="AGG Align"end else local ty=false;local tz=30;if tx<10 and su~=nil and su>0 then local tA=dn(cj,0.4,2)local td=bx*dn(cN/100,0.1,1)*tA;local tB=su*tA+td-ob;local tC=td/2-ob;local tD=cN-dq(f0(tC/2)*20/(0.5*cl))*utils.sign(tC)if tD<0 then tD=0 end;local tE;if cN>100 then local tF,dS=cr.computeDistanceAndTime(cN,100,cl,0,0,td)local tG,dS=cr.computeDistanceAndTime(100,0,cl,0,0,dq(td))tE=tF+tG else tE=cr.computeDistanceAndTime(cN,0,cl,0,0,dq(td))end;if tE<20 then b3=false else local tH=0;if tD>100 then local tI,dS=cr.computeDistanceAndTime(tD,100,cl,0,0,tB)local tJ,dS=cr.computeDistanceAndTime(100,0,cl,0,0,su*tA+dq(td)-ob)tH=tI+tJ else tH,dS=cr.computeDistanceAndTime(tD,0,cl,0,0,su*tA+dq(td)-ob)end;tH=(tH+15+cN*sm)*1.1;local tK=dd and fY~=nil and kt:getAltitude(fY.position)>0 and fY.safe;local sy=nil;if tw and tw<ck then sy=tw elseif tK then sy=kt:getAltitude(fY.position)+250 elseif ck>kt.surfaceMaxAltitude then sy=kt.surfaceMaxAltitude end;if d1 then local tL=kt:getAltitude(d1[1].center)if sy then if tL>sy then sy=tL end else sy=tL end end;if sy~=nil then local tM=ck-sy;ty=true;if tM<=tH or tH==-1 or tx>tv and dd then if sy==kt.surfaceMaxAltitude and cP<-P then b3="BL Stop BLR"elseif tx>tv and dd then b3="BL AP Hzn"else b3="BL Stop Dist"end else b3=false end end end end;qF=ch;if qF>-1 then b3=false;if not tw and not bp then qc=true;iA:setTargetGroundAltitude(_)end;if(cN<1 or cM:normalize():dot(cO)<0)and not de and qF-3<_ and(bE or cN==0)then b9=false;b8=false;c1=0;qY(0,1)b3="BL Complete"cB=q;dd=false;qf=false else if cP<-5 or tx>tv*10 then qY(0,1)b3="BL Slowing"else b3=false;qY(-1)end end elseif not ty then if qX and cM:normalize():dot(-gj)<0.999 then b3="BL Strong"qM()elseif tx>10 or tx>tv and dd then b3="BL hSpd"elseif cP<-P then b3="BL BLR"qY(0,1)else qY(-1)b3=false end end end else qf=false end;if ba or cf then local lo,eM,eL;if bn~=nil then lo,eM,eL=cq:getPlanetarySystem(0):castIntersections(cQ,(bn-cQ):normalize(),function(eu)if eu.noAtmosphericDensityAltitude>0 then return eu.radius+eu.noAtmosphericDensityAltitude else return eu.radius+eu.surfaceMaxAltitude*1.5 end end)end;if lo~=nil then if lo.name~=ca.name and not ci then d0="Clearing LOS between "..lo.name.." and waypoint."end end;if cS and not cf then if ck>=bd-50 and cN>iT then ba=false;if not b6 and not bt then b3="ATO Agg Arrive"q9=0 end end elseif f0(s_)<15 and ck/bd>0.75 then ba=false;if not cf then if cT and not t then d.control.cancelCurrentControlMasterMode()end elseif cf and cN<iT then b6=true;cf=false;b8=false;ba=false;q9=0 elseif cf then q9=0;b3="ATO Space"end elseif cf and not ci and ca~=nil and(lo==nil or lo.name==ca.name)then b6=true;d0=false;cf=false;b8=false;ba=false;if not cT then q9=0 end;be=true end end;local tN=ch>-1;local tO=cU;if(bt or cf or cZ)and not tN and cN>aM and ci then local mA=math.rad(f0(cV))tO=cU*f0(math.cos(mA))+so*math.sin(mA)end;local tP=dn(s_-tO,-O*0.80,O*0.80)if not ci and bt then tP=dn(s_-tO,-85,Q)elseif not ci then tP=dn(s_-tO,-Q,Q)end;if f0(cV)<5 or bt or cZ or b9 or tN or b8 then s3:inject(tP)local t0=s3:get()q0=q0+t0 end end;if antigrav~=nil and(antigrav and not r and ck<200000)then if by==nil or by<1000 then by=1000 end;if tQ~=by then tQ=by;qj=tQ end end;if(ci or bb or cg)and t and cT then local tR=0;if aV>0 and not bb and cj>0.005 and cj<0.1 and cP>-50 then local tS=bR.getFrictionBurnSpeed()*aV;local tT=cD/3.6;if tS>tT then tR=tS-tT-1 end end;s5:inject(cD/3.6+tR-cM:dot(cJ))local tU=s5:get()bW=dn(tU,-1,1)if not d9 then if bW<bT and(cj>0.005 or bb or cg)then bV=true;d9=dn(bW,0.01,1)else bV=false;d9=bT end end;s6:inject(cM:len()-cD/3.6-tR)local tV=dn(s6:get(),0,1)if ci and cP<-80 or(cj>0.005 or bb or cg)then bU=tV end;if bU>0 then if bV and bW==0.01 and not d9 then d9=0 end else bW=dn(bW,0.01,1)end;local tW=''local tX=vec3()local tY=rw(axisCommandId.vertical,c1*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tY,rT)local tZ='thrust analog longitudinal 'if bF=="All"or bF=="Longitude"then tZ=tZ..aW end;local t_=iA:getAxisCommandType(axisCommandId.longitudinal)local u0=iA:composeAxisAccelerationFromThrottle(tZ,axisCommandId.longitudinal)local u1=rJ(axisCommandId.lateral,bB*1000)tW=tW..' , '.."lateral airfoil , lateral ground "tX=tX+u1;if tX:len()>constants.epsilon then d:setEngineForceCommand(tW,tX,rT,'','','',rU)end;d:setEngineForceCommand(tZ,u0,rS)local u2='thrust analog vertical fueled 'local u3='thrust analog lateral fueled 'if bF=="All"or bF=="Lateral"then u3=u3 ..aX end;if bF=="All"or bF=="Vertical"then u2=u2 ..aY end;if c1~=0 or b9 and b3 or not bp and not bE then d:setEngineForceCommand(u2,tY,rS)else d:setEngineForceCommand(u2,vec3(),rS)end;if bB~=0 then d:setEngineForceCommand(u3,u1,rS)else d:setEngineForceCommand(u3,vec3(),rS)end;if sa==0 then sa=bU end;local u4=-sa*(aR*cM+aS*se)d:setEngineForceCommand('brake',u4)else if t then if not d9 then d9=bT end end;local ry=c.getAxisCommandValue(0)if not cT then s6:inject(cM:len()-ry/3.6)local tV=dn(s6:get(),0,1)sa=dn(sa+tV,0,1)end;local u4=-sa*(aR*cM+aS*se)d:setEngineForceCommand('brake',u4)local tW=''local tX=vec3()local u5=false;local tZ='thrust analog longitudinal 'if aW~="none"and(bF=="All"or bF=="Longitude")then tZ=tZ..aW end;local t_=iA:getAxisCommandType(axisCommandId.longitudinal)if t_==axisCommandType.byThrottle then local u0=iA:composeAxisAccelerationFromThrottle(tZ,axisCommandId.longitudinal)d:setEngineForceCommand(tZ,u0,rS)elseif t_==axisCommandType.byTargetSpeed then local u0=iA:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tW=tW..' , '..tZ;tX=tX+u0;if iA:getTargetSpeed(axisCommandId.longitudinal)==0 or iA:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iA:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u5=true end end;local u3='thrust analog lateral 'if aX~="none"and(bF=="All"or bF=="Lateral")then u3=u3 ..aX end;local u6=iA:getAxisCommandType(axisCommandId.lateral)if u6==axisCommandType.byThrottle then local u7=iA:composeAxisAccelerationFromThrottle(u3,axisCommandId.lateral)d:setEngineForceCommand(u3,u7,rS)elseif u6==axisCommandType.byTargetSpeed then local u1=iA:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tW=tW..' , '..u3;tX=tX+u1 end;local u2='thrust analog vertical 'if aY~="none"and(bF=="All"or bF=="Vertical")then u2=u2 ..aY end;local u8=iA:getAxisCommandType(axisCommandId.vertical)if u8==axisCommandType.byThrottle then local tY=iA:composeAxisAccelerationFromThrottle(u2,axisCommandId.vertical)if c1~=0 or b9 and b3 then d:setEngineForceCommand(u2,tY,rS,'airfoil','ground','',rU)else d:setEngineForceCommand(u2,vec3(),rS)d:setEngineForceCommand('airfoil vertical',tY,rS,'airfoil','','',rU)d:setEngineForceCommand('ground vertical',tY,rS,'ground','','',rU)end elseif u8==axisCommandType.byTargetSpeed then if c1<0 then d:setEngineForceCommand('hover',vec3(),rS)end;local u9=iA:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tW=tW..' , '..u2;tX=tX+u9 end;if tX:len()>constants.epsilon then if sa~=0 or u5 or f0(se:dot(cJ))<0.5 then tW=tW..', brake'end;d:setEngineForceCommand(tW,tX,rT,'','','',rU)end end;local ua=aO*(si-sh)local ub=vec3(bR.getWorldAirFrictionAngularAcceleration())ua=ua-ub;d:setEngineTorqueCommand('torque',ua,rS,'airfoil','','',rU)d:setBoosterCommand('rocket_engine')if c7 and not o then local ki=cL:len()local uc=0.15;if not cT then local ud=iA:getTargetSpeed(axisCommandId.longitudinal)if ki*3.6>ud*(1-uc)and ue then ue=false;d:toggleBoosters()elseif ki*3.6<ud*(1-uc)and not ue then ue=true;d:toggleBoosters()end else local rl=c.getThrottle()if t then rl=bT*100 end;local ry=rl/100;if not ci then ry=ry*a1;if ki>=ry*(1-uc)and ue then ue=false;d:toggleBoosters()elseif ki<ry*(1-uc)and not ue then ue=true;d:toggleBoosters()end else local tj=bP(cD)ry=ry*tj/3.6;if ki>=ry*(1-uc)and ue then ue=false;d:toggleBoosters()elseif ki<ry*(1-uc)and not ue then ue=true;d:toggleBoosters()end end end end end;if uf then for dN,dz in pairs(uf)do pI[dN]=dz end end;ch=qA()return pI end;local function ug(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uh,iz,iA,iB,ui,gE,fN,e6,dp,dn,fM,iD,pH,dk)local bR=DUConstruct;local uj={}local uk=true;local ul=5;local um=5;local un=ul;local uo=um;local up=bS;function uj.landingGear(qc)bp=not bp;if bp then if b6 or bt or cf or bC then cv.ResetAutopilots(true)end;bw=nil;cv.cmdThrottle(0)if vBooster or hover then if(ci or ck<20000)and not qc and ch==-1 then fM("bklOn","BL")qX=true;bb=false;ba=false;bc=false;if b9 then dd=not dd end;cB=true;bp=false;b9=true else if bY then fM("grOut","LG",1)d.control.deployLandingGears()end;dd=false;if ci then cB=q;b3="Landing"end end;if qc or ch~=-1 and ch>_-3 or not bE then b9=true end;iA:activateGroundEngineAltitudeStabilization(r0)iA:setTargetGroundAltitude(_)b8=false;bK=false elseif bY and not b9 then fM("grOut","LG",1)d.control.deployLandingGears()end else if b9 then b9=false end;if bY then fM("grIn","LG",1)d.control.retractLandingGears()end;iA:activateGroundEngineAltitudeStabilization(r0)if bE then if _<iA.targetGroundAltitude then iA:setTargetGroundAltitude(iA.targetGroundAltitude)else iA:setTargetGroundAltitude(Z)end else iA:setTargetGroundAltitude(Z)end end end;function uj.startControl(uq)local function ur(rg)local rh=1;local function us(ut,rg)local uu={kt.surfaceMaxAltitude+100,kt.spaceEngineMinAltitude-0.01*kt.noAtmosphericDensityAltitude,kt.noAtmosphericDensityAltitude+V,kt.radius*(U-1)+kt.noAtmosphericDensityAltitude}local uv=ut;for dS,dz in ipairs(uu)do if rg and uv>dz then ut=dz elseif ut<dz and not rg then ut=dz;break end end;return ut end;if rg then rh=-1 end;if not r and cS then if c3 and rg then by=1000 elseif by~=nil then by=by+rh*um;if by<1000 then by=1000 end;if b8 and by<bd+10 and by>bd-10 then bd=by end else by=tQ+rh*100 end elseif b8 or bc or bC then if bC then if c3 then cF=us(cF,rg)else cF=cF+rh*ul end;if cF<kt.noAtmosphericDensityAltitude then cF=kt.noAtmosphericDensityAltitude end else if c3 and ci then bd=us(bd,rg)bK=false else bd=bd+rh*ul;if bK then if bd>100 then bK=false else iA:updateTargetGroundAltitudeFromActionStart(rh*1.0)bK=d:getTargetGroundAltitude()end end end end else iA:updateTargetGroundAltitudeFromActionStart(rh*1.0)end end;local function uw(ux)if not ci then dk("Flight Assist in Atmo only")return end;local dw=type(ux)if cZ==nil then if dw=="table"then if b6 or bt then cv.ToggleAutopilot()end;fM("180On","BR")elseif ux==1 then fM("bnkLft","BR")else fM("bnkRht","BR")end;if not b8 and not b6 and not bt then cv.ToggleAltitudeHold()if dw~="table"then ux=ux+1 end end;cZ=ux else fM("180Off","BR")cZ=nil end end;local function uy()if iB()==1 then cb=0;cc=0;ui(bl)elseif iz()==1 and y then cA=false;cz=false end;c3=false end;if uq=="gear"then cx.landingGear()elseif uq=="light"then if p7 then if iz()==1 then if DUPlayer.isFrozen()==1 then DUPlayer.freeze(0)dk("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(1)dk("Player Frozen, pitch/yaw/roll enabled")end else dk("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uq=="forward"then if p7 and not ci and not b6 then b5=not b5;b4=false else bZ=bZ-1 end elseif uq=="backward"then if p7 then if not ci then if not b6 then b4=not b4;b5=false else b7=not b7 end else uw(-cM*5000)end else bZ=bZ+1 end elseif uq=="left"then if p7 then uw(1)else b_=b_-1 end elseif uq=="right"then if p7 then uw(3)else b_=b_+1 end elseif uq=="yawright"then c0=c0-1;de=nil elseif uq=="yawleft"then c0=c0+1;de=nil elseif uq=="straferight"then iA:updateCommandFromActionStart(axisCommandId.lateral,1.0)bB=1 elseif uq=="strafeleft"then iA:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bB=-1 elseif uq=="up"then cv.vertical(1)if ch-3<_ and ck>0 and bp then cx.landingGear()end elseif uq=="down"then cv.vertical(-1)elseif uq=="groundaltitudeup"then ur()elseif uq=="groundaltitudedown"then ur(true)elseif uq=="option1"then uz=false;if p7 and c3 then local uA=""for M=1,#d4 do uA=uA.."| Name: "..a.getPlayerName(d4[M]).." Mass: "..fN(bR.getBoardedPlayerMass(d4[M])/1000,1).."t "end;a.print("Onboard: "..uA)return end;cu.adjustAutopilotTargetIndex()elseif uq=="option2"then uz=false;if p7 and c3 then for M=1,#d4 do bR.forceDeboard(d4[M])bR.forceInterruptVRSession(d4[M])end;dk("Deboarded All Passengers")return end;cu.adjustAutopilotTargetIndex(1)elseif uq=="option3"then uz=false;if p7 and c3 then local uA=""for M=1,#d5 do uA=uA.."| ID: "..d5[M].." Mass: "..fN(bR.getDockedConstructMass(d5[M])/1000,1).."t "end;a.print("Docked Ships: "..uA)return end;if x then if w then w=false else w=true end;if cw then cw.ToggleRadarPanel()end end elseif uq=="option4"then uz=false;if p7 and c3 then for M=1,#d5 do bR.forceUndock(d5[M])end;dk("Undocked all ships")return end;cZ=nil;cv.ToggleAutopilot()elseif uq=="option5"then uz=false;cv.ToggleLockPitch()elseif uq=="option6"then uz=false;if p7 and c3 then if shield then cy.ventShield()else dk("No shield found")end;return end;cv.ToggleAltitudeHold()elseif uq=="option7"then uz=false;if p7 and c3 then if shield then shield.toggle()return else dk("No shield found")return end end;E=not E;if E then dk("Collision System Enabled")else dk("Collision System Secured")end elseif uq=="option8"then uz=false;if p7 and c3 then if bo>0 and fY~=nil then cv.routeWP()else dk("Select a saved wp on IPH to add to or remove from route")end;return end;bE=not bE;if not bE then dk("DeCoupled Mode - Ground Stabilization off")iA:deactivateGroundEngineAltitudeStabilization()fM("gsOff","GS")else dk("Coupled Mode - Ground Stabilization on")iA:activateGroundEngineAltitudeStabilization(r0)dg=true;fM("gsOn","GS")end elseif uq=="option9"then uz=false;if p7 and c3 then iA:resetCommand(axisCommandId.longitudinal)iA:resetCommand(axisCommandId.lateral)iA:resetCommand(axisCommandId.vertical)cv.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cm=gyro.isActive()==1;if cm then fM("gyOn","GA")else fM("gyOff","GA")end else dk("No gyro found")end elseif uq=="lshift"then if p7 then c3=true end elseif uq=="brake"then if b1 or p7 then cv.BrakeToggle("Manual")elseif not b3 then cv.BrakeToggle("Manual")else b3="Manual"end elseif uq=="lalt"then uz=true;p7=true;if iz()==0 and not j and g=="keyboard"then ui(1)end elseif uq=="booster"then if o then d:toggleBoosters()elseif not c7 then if not ue then d:toggleBoosters()ue=true end;c7=true else if ue then d:toggleBoosters()ue=false end;c7=false end elseif uq=="stopengines"then local function uB()if bS-up<1.5 then fM("clear","CA")cv.clearAll()end end;uB()up=bS;if iA:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p7 then if cD>0 then cD=0 else cD=W end elseif bT~=0 then iA:resetCommand(axisCommandId.longitudinal)cv.cmdThrottle(0)else cv.cmdThrottle(100)end else if iA:getTargetSpeed(axisCommandId.longitudinal)~=0 then iA:resetCommand(axisCommandId.longitudinal)else if ci then cv.cmdCruise(cD)else cv.cmdCruise(a1*3.6)end end end elseif uq=="speedup"then cv.changeSpd()elseif uq=="speeddown"then cv.changeSpd(true)elseif uq=="antigravity"and not r then if antigrav~=nil then cv.ToggleAntigrav()else dk("No antigrav found")end elseif uq=="leftmouse"then c4=true;if c3 then uy()uz=false else c3=true;bl=iB()ui(1)end end end;function uj.stopControl(uq)local function uC()if not r and cS then uo=um end;if b8 or bc or bC then un=ul end end;if uq=="forward"then bZ=0 elseif uq=="backward"then bZ=0 elseif uq=="left"then if cZ then if cZ==2 then cZ=-2 else cZ=-1 end end;b_=0 elseif uq=="right"then if cZ then if cZ==4 then cZ=-2 else cZ=-1 end end;b_=0 elseif uq=="yawright"then c0=0 elseif uq=="yawleft"then c0=0 elseif uq=="straferight"then iA:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bB=0 elseif uq=="strafeleft"then iA:updateCommandFromActionStop(axisCommandId.lateral,1.0)bB=0 elseif uq=="up"then cv.vertical(0,-1)elseif uq=="down"then cv.vertical(0,1)elseif uq=="groundaltitudeup"then uC()uz=false elseif uq=="groundaltitudedown"then uC()uz=false elseif uq=="brake"then if not b1 and not p7 then if b3 then cv.BrakeToggle()else b3=false end end elseif uq=="lalt"then if c3 then c3=false end;if iz()==0 and j then if uz then if iB()==1 then ui(0)else ui(1)end else uz=true end elseif iz()==0 and not j and g=="keyboard"then ui(0)end;p7=false end end;function uj.loopControl(uq)local function uD(rg)local rh=1;if rg then rh=-1 end;if not r and cS then if by~=nil then by=by+rh*uo;if by<1000 then by=1000 end;if b8 and by<bd+10 and by>bd-10 then bd=by end;uo=dn(uo*1.05,um,50)else by=tQ+rh*100 end elseif b8 or bc or bC then if bC then cF=cF+rh*un;if cF<kt.noAtmosphericDensityAltitude then cF=kt.noAtmosphericDensityAltitude end else bd=bd+rh*un end;un=dn(un*1.05,ul,50)else iA:updateTargetGroundAltitudeFromActionLoop(rh*1.0)end end;local function uE(rg)local rh=1;if rg then rh=-1 end;if not c3 then if t and not p7 then bT=dn(bT+rh*aG/100,-1,1)else iA:updateCommandFromActionLoop(axisCommandId.longitudinal,rh*aG)end end end;if uq=="groundaltitudeup"then if not c3 then uD()end elseif uq=="groundaltitudedown"then if not c3 then uD(true)end elseif uq=="speedup"then uE()elseif uq=="speeddown"then uE(true)end end;function uj.inputTextControl(rf)local function uF(uG,fo,gr)local function uH(fo)local dF=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dG='::pos{'..dF..','..dF..','..dF..','..dF..','..dF..'}'local dW,dX,e3,e4,e5=e6(fo,dG)if dW=="0"and dX=="0"then return vec3(dp(e3),dp(e4),dp(e5))end;e4=math.rad(e4)e3=math.rad(e3)local kt=e[dp(dW)][dp(dX)]local eX=math.cos(e3)local uI=vec3(eX*math.cos(e4),eX*math.sin(e4),math.sin(e3))return kt.center+(kt.radius+e5)*uI end;local fP=uH(fo)return cu.AddNewLocation(uG,fP,gr)end;local M;local uJ,io=nil,nil;local uK="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(rf," ")uJ=rf;if M~=nil and string.find(rf,"::")~=1 then uJ=string.sub(rf,0,M-1)io=string.sub(rf,M+1)end;if uJ=="/help"or uJ=="/commands"then for ln in string.gmatch(uK,"([^\n]+)")do a.print(ln)end;return elseif uJ=="/setname"then if io==nil or io==""then dk("Usage: ah-setname Newname")return end;if bo>0 and fY~=nil then cu.UpdatePosition(io)else dk("Select a saved target to rename first")end elseif shield and uJ=="/resist"then cy.setResist(io)elseif uJ=="/addlocation"or string.find(rf,"::pos")~=nil then local gr=false;local uG="0-Temp"if io==nil or io==""or uJ~="/addlocation"then io=uJ;gr=true end;M=string.find(io,"::")if not gr then uG=string.sub(io,1,M-2)end;local fo=string.sub(io,M)fo=fo:gsub("%s+","")uF(uG,fo,gr)elseif uJ=="/agg"then if io==nil or io==""then dk("Usage: /agg targetheight")return end;io=dp(io)if io<1000 then io=1000 end;by=io;dk("AGG Target Height set to "..io)elseif uJ=="/G"then if io==nil or io==""then dk("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if io=="dump"then for dN,dz in pairs(iD())do if type(dz.get())=="boolean"then if dz.get()==true then a.print(dN.." true")else a.print(dN.." false")end elseif dz.get()==nil then a.print(dN.." nil")else a.print(dN.." "..dz.get())end end;return end;M=string.find(io," ")local uL=string.sub(io,0,M-1)local uM=string.sub(io,M+1)for dN,dz in pairs(iD())do if dN==uL then local uN=type(dz.get())if uN=="number"then uM=dp(uM)if dN=="AtmoSpeedLimit"then cD=uM end end;dk("Variable "..uL.." changed to "..uM)if dN=="MaxGameVelocity"then uM=uM/3.6;if uM>dh-0.2 then uM=dh-0.2;dk("Variable "..uL.." changed to "..fN(uM*3.6,1))end end;if uN=="boolean"then if string.lower(uM)=="true"then uM=true else uM=false end end;dz.set(uM)return end end;dk("No such global variable: "..uL)elseif uJ=="/deletewp"then if bo>0 and fY~=nil then cu.ClearCurrentPosition()else dk("Select a custom wp to delete first in IPH")end elseif uJ=="/copydatabank"then if dbHud_2 then pH(true)else dk("Spare Databank required to copy databank")end elseif uJ=="/iphWP"then if bo>0 then a.print(cv.showWayPoint(ca,bn,true))a.print(json.encode(bn))dk("::pos waypoint shown in lua chat in local and world format")else dk("No target selected in IPH")end elseif uJ=="/createPrivate"then local uO="privatelocations = {\n"local uP=""if#db>0 then for dN,dz in pairs(db)do uO=uO.."{position = {x = "..dz.position.x..", y = "..dz.position.y..", z = "..dz.position.z.."},\n ".."name = '"..dz.name.."',\n planetname = '"..dz.planetname.."',\n gravity = "..dz.gravity..",\n"if dz.heading then uO=uO.."heading = {x = "..dz.heading.x..", y = "..dz.heading.y..", z = "..dz.heading.z.."},\n"end;if dz.safe then uO=uO.."safe = true},\n"else uO=uO.."safe = false},\n"end end end;uP=#db.."-Private "if io=="all"then for dN,dz in pairs(bs)do uO=uO.."{position = {x = "..dz.position.x..", y = "..dz.position.y..", z = "..dz.position.z.."},\n ".."name = '*"..dz.name.."',\n planetname = '"..dz.planetname.."',\n gravity = "..dz.gravity..",\n"if dz.heading then uO=uO.."heading = {x = "..dz.heading.x..", y = "..dz.heading.y..", z = "..dz.heading.z.."},\n"end;if dz.safe then uO=uO.." safe = true},\n"else uO=uO.."safe = false},\n"end end;uP=uP..#bs.."-Public "end;uO=uO.."}\n return privatelocations"if uh then uh.setHTML(uO)end;dk(uP.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c6=7 end end;function uj.tagTick()if bF=="Off"then bF="All"elseif bF=="All"then bF="Longitude"elseif bF=="Longitude"then bF="Lateral"elseif bF=="Lateral"then bF="Vertical"else bF="Off"end;dk("Extra Engine Tags: "..bF)c.stopTimer("tagTick")end;if uQ then for dN,dz in pairs(uQ)do uj[dN]=dz end end;return uj end;local function uR(d,b,c,e,vBooster,hover,pG,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iw,uh)local a=DUSystem;local bR=DUConstruct;local uS=DUPlayer;local uT=DULibrary;local uU={}local dm=string.format;local ix=json.decode;local uV=json.encode;local pz=b.getElementMaxHitPointsById;local iy=b.getElementMassById;local iz=d.control.isRemoteControlled;local e6=string.match;local gE=a.destroyWidgetPanel;local fK=a.updateData;local fL=a.addDataToWidget;local ui=a.lockView;local iB=a.isViewLocked;local dq=math.sqrt;local dp=tonumber;local f0=math.abs;local bP=math.floor;local bQ=c.getAtmosphereDensity;local eW=math.atan;local bO=a.getArkTime;local dn=utils.clamp;local iA=d.axisCommandManager;local gG=13;local iG=b.getElementIdList()local iH=0;local function dr(eE,eF)if eE==0 then return f0(eF)<1e-09 elseif eF==0 then return f0(eE)<1e-09 else return f0(eE-eF)<math.max(f0(eE),f0(eF))*dE end end;local function fN(dF,uW)local rh=10^(uW or 0)return bP(dF*rh+0.5)/rh end;local function iC(uX,uY)for dN,dz in pairs(uY)do if type(dN)=="string"then uX[dN]=dz else uX[#uX+1]=uY[dN]end end;return uX end;local function iD(uZ)local u_={}if not uZ then iC(u_,L)iC(u_,ac)iC(u_,aE)iC(u_,b0)return u_ elseif uZ=="boolean"then return L elseif uZ=="handling"then return ac elseif uZ=="hud"then return aE elseif uZ=="physics"then return b0 end end;local function dk(sR)if not sR then return end;if c5~="empty"then if c5~=sR then c5=c5 .."\n"..sR;c6=7 end else c5=sR end end;local function pH(v0)local function v1(v2)for dN,dz in pairs(v2)do dbHud_1.setStringValue(dN,uV(dz.get()))if v0 and dbHud_2 then dbHud_2.setStringValue(dN,uV(dz.get()))end end end;if dbHud_1 then v1(bL)v1(iD())a.print("Saved Variables to Datacore")if v0 and dbHud_2 then dk("Databank copied.  Remove copy when ready.")end end end;local function fM(v3,v4,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v3 ..".mp3")end;local function gF(hz,hA,rf,jO,v5)return dm([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jO or"",hz,hA,v5 or"",rf)end;local function iE(cd,v6)v6=v6 or 1;local unit="m"if cd>100000 then cd=cd/200000;unit="su"elseif cd>1000 then cd=cd/1000;unit="km"end;return fN(cd,v6)..unit end;local function iF(v7)local v8=0;local v9=0;local va=0;if v7<60 then v7=bP(v7)elseif v7<3600 then v8=bP(v7/60)v7=bP(v7%60)elseif v7<86400 then v9=bP(v7/3600)v8=bP(v7%3600/60)else va=bP(v7/86400)v9=bP(v7%86400/3600)end;if va>365 then return">1y"elseif va>0 then return va.."d "..v9 .."h "elseif v9>0 then return v9 .."h "..v8 .."m "elseif v8>0 then return v8 .."m "..v7 .."s"elseif v7>0 then return v7 .."s"else return"0s"end end;local function vb()if radar_1 then cw=gD(b,a,c,radar_1,radar_2,warpdrive,f0,gE,dq,gF,dp,gG,fM,dk)end end;function uU.radarSetup()vb()end;function uU.onStart()local vc=false;local function vd()local function ve(vf)local vg=dbHud_1.hasKey;for dN,dz in pairs(vf)do if vg(dN)then local dI=ix(dbHud_1.getStringValue(dN))if dI~=nil then dz.set(dI)vc=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then ve(iD())coroutine.yield()ve(bL)else ve(bL)dk("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c6=5;vc=false end;coroutine.yield()if vc then dk("Loaded Saved Variables")elseif not f then dk("No Databank Saved Variables Found\nVariables will save to Databank on standing")c6=5 end;if#bs>0 then dc=iC(dc,bs)end else dk("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;b1=k;g=string.lower(g)cB=q;cD=W;if bz+180<bS then bx=0 end;bz=bS;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then dk("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c6=7 end;if antigrav and not r then if by==nil then by=ck end;antigrav.setTargetAltitude(by)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#db>0 then dc=iC(dc,db)end end;ls="Proceeding to Waypoint"if not a1 or a1<0 then a1=bR.getMaxSpeed()-0.1 end end;local function vh()local function vi(vj,vk)if vj>vk then vk=vj end;local vl,vm=0,0;if a7>0 then vl=a7*0.05 end;if a8>0 then vm=a8*0.05 end;vk=vk*(1-(vl+vm))return vk end;local vn=b.getElementNameById;local vo=au~=0 and av~=0;local vp=_G["atmofueltank_size"]local vq=_G["spacefueltank_size"]local vr=_G["rocketfueltank_size"]for dN in pairs(iG)do local type=b.getElementDisplayNameById(iG[dN])if e6(type,'^.*Atmospheric Engine$')then if e6(tostring(b.getElementTagsById(iG[dN])),'^.*vertical.*$')and b.getElementForwardById(iG[dN])[3]>0 then cR=true end end;if e6(type,'^.*Space Engine$')then cI=true;if e6(tostring(b.getElementTagsById(iG[dN])),'^.*vertical.*$')then local vs=b.getElementForwardById(iG[dN])if vs[3]<0 then vt=true else cH=true end end end;if type=="Landing Gear"then bY=true end;if type=="Dynamic Core Unit"then local pB=pz(iG[dN])if pB>10000 then gG=110 elseif pB>1000 then gG=55 elseif pB>150 then gG=27 end end;iH=iH+pz(iG[dN])if vo and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pB=pz(iG[dN])local f5=iy(iG[dN])local vj=0;local jG=bO()if type=="Atmospheric Fuel Tank"then local vk=400;local vu=35.03;if pB>10000 then vk=51200;vu=5480 elseif pB>1300 then vk=6400;vu=988.67 elseif pB>150 then vk=1600;vu=182.67 end;vj=f5-vu;if a4>0 then vk=vk+vk*a4*0.2 end;vk=vi(vj,vk)local gq=vn(iG[dN])local jE=0;for jF=1,vp do if gq==ix(c["atmofueltank_"..jF].getWidgetData()).name then jE=jF;break end end;local vv={iG[dN],string.sub(gq,1,12),vk,vu,vj,jG,jE}cn[#cn+1]=vv end;if type=="Rocket Fuel Tank"then local vk=320;local vu=173.42;if pB>65000 then vk=40000;vu=25740 elseif pB>6000 then vk=5120;vu=4720 elseif pB>700 then vk=640;vu=886.72 end;vj=f5-vu;if a6>0 then vk=vk+vk*a6*0.1 end;vk=vi(vj,vk)local gq=vn(iG[dN])local jE=0;for jF=1,vr do if gq==ix(c["rocketfueltank_"..jF].getWidgetData()).name then jE=jF;break end end;local vv={iG[dN],string.sub(gq,1,12),vk,vu,vj,jG,jE}cp[#cp+1]=vv end;if type=="Space Fuel Tank"then local vk=600;local vu=35.03;if pB>10000 then vk=76800;vu=5480 elseif pB>1300 then vk=9600;vu=988.67 elseif pB>150 then vk=2400;vu=182.67 end;vj=f5-vu;if a5>0 then vk=vk+vk*a5*0.2 end;vk=vi(vj,vk)local gq=vn(iG[dN])local jE=0;for jF=1,vq do if gq==ix(c["spacefueltank_"..jF].getWidgetData()).name then jE=jF;break end end;local vv={iG[dN],string.sub(gq,1,12),vk,vu,vj,jG,jE}co[#co+1]=vv end end end;if not cR then bc,b2=false,false end end;local function vw()if gyro~=nil then cm=gyro.isActive()==1 end;if not bE then iA:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ui(1)else ui(0)end;if door and(ci or not ci and ck<10000)then for dS,dz in pairs(door)do dz.toggle()end end;if switch then for dS,dz in pairs(switch)do dz.toggle()end end;if forcefield and(ci or not ci==0 and ck<10000)then for dS,dz in pairs(forcefield)do dz.toggle()end end;if antigrav then cS=antigrav.isActive()==1;if cS and not r then antigrav.showWidget()end end;if iz()==1 and l then uS.freeze(1)else uS.freeze(0)end;if bY then if ch~=-1 and not cS then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bp=d.control.isAnyLandingGearDeployed()==1 or not bE or ch~=-1 and ch-3<_;local vx=cL:len()<30;if ch~=-1 and vy or(not ci or not vy)and vx then b3="Startup"else b3=false end;iA:setTargetGroundAltitude(_)pn=ci end;local function vz()local vA={}local function vB()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vC={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vD,vE in pairs(e)do e[vD][0]=vB()e[vD][0].systemId=vD;vA[vD]={}for vF,kt in pairs(e[vD])do kt.gravity=kt.gravity/9.8;kt.center=vec3(kt.center)kt.name=kt.name[1]kt.noAtmosphericDensityAltitude=kt.atmosphereThickness;kt.spaceEngineMinAltitude=vC[kt.id]or 0.5353125*kt.atmosphereThickness;kt.planetarySystemId=vD;kt.bodyId=kt.id;vA[vD][vF]=kt;if mi==nil or kt.center.x<mi then mi=kt.center.x end;if mh==nil or kt.center.x>mh then mh=kt.center.x end;if ml==nil or kt.center.y<ml then ml=kt.center.y end;if mk==nil or kt.center.y>mk then mk=kt.center.y end;if kt.center and kt.name~="Space"then d6[#d6+1]=kt end end end;eg=dl(d,b,c,a,dm,dn,dp,dq,dr)cq=eg(vA)fQ=cq[0]cr=e_(d,b,c,a,dq,f0)cs=fk(d,b,c,a,dm,dn,dp,dq,dr)cu=fJ(d,b,c,a,dbHud_1,e,fK,fL,bP,dp,dq,fM,fN,dk)kt=cq[0]:closestBody(bR.getWorldPosition())end;vG=false;vH=coroutine.create(function()iA:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vd()coroutine.yield()vh()coroutine.yield()cv=pF(d,b,c,e,vBooster,hover,pG,antigrav,dbHud_1,f0,bP,bQ,iz,eW,bO,dn,iA,fK,iB,dq,fN,fM,iC,dr,iE,iF,pH,ix,dk)vw()coroutine.yield()vz()vb()if iv then ct=iv(d,b,c,a,e,antigrav,hover,shield,warpdrive,iw,f0,bP,dm,ix,bQ,iy,iz,eW,bO,dn,iA,fL,fK,gE,iB,dq,fN,gF,fM,iC,iD,iE,iF,iG,iH,dk)end;if ct then ct.ButtonSetup()end;cx=ug(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uh,iz,iA,iB,ui,gE,fN,e6,dp,dn,fM,iD,pH,dk)if shield then cy=id(shield,e6,bP,dk)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uh then uh.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bR.setDockingMode(ab)if shield then c.setTimer("shieldTick",0.0166667)end;if vI then vJ.ExtraOnStart()end;fM("start","SU")local function vK()if bJ[1]==0 then cv.cmdThrottle(bJ[2])else if cj>0 then cD=bJ[2]cv.cmdThrottle(1)end end end;lk=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if lk then if ch>-1 and cN<1 and ch-3<_ then c.exit()else if J then vK()else if cj==0 then b3="ECU Braking"elseif ch==-1 then cx.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bJ[3]+3>bO()then vK()end;d5=bR.getDockedConstructs()d4=bR.getPlayersOnBoard()local vL;vL=#d4>1 and"Passengers: "..#d4-1 .." "or""vL=vL..(#d5>0 and"Ships: "..#d5 or"")if vL~=""then dk("NOTICE: Docked "..vL)end end)coroutine.resume(vH)end;function uU.onUpdate()if vG then d:update()if ci and t and cT then if cT and bX then cv.cmdThrottle(0)bX=false elseif not cT and not bX then bT=0;bX=true end end;if d9 then iA:setThrottleCommand(axisCommandId.longitudinal,d9)d9=nil end;if not cz and p9~=vM then a.setScreen(p9)end;vM=p9;if lk and not J and cj>0 and ch==-1 then cx.landingGear()end;if lk and ch>-1 and cN<1 and ch-3<_ then c.exit()end;if vI then vJ.ExtraOnUpdate()end else local i3=coroutine.status(vH)if i3=="suspended"then local dO,i4=coroutine.resume(vH)if i4 then a.print("ERROR STARTUP: "..i4)end elseif i3=="dead"then vG=true end end end;function uU.onFlush()if vG then cv.onFlush()if vI then vJ.ExtraOnFlush()end end end;function uU.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cj>0 or cj==0 and ck<10000)then for dS,dz in pairs(door)do dz.toggle()end end;if switch then for dS,dz in pairs(switch)do dz.toggle()end end;if forcefield and(cj>0 or cj==0 and ck<10000)then for dS,dz in pairs(forcefield)do dz.toggle()end end;w=d8;local vN=0;if lk then vN=bO()end;if iA:getAxisCommandType(0)==0 then bJ={0,bT,vN}else bJ={1,iA:getTargetSpeed(axisCommandId.longitudinal),vN}end;pH()if nU then nU.activate()end;if z then cv.showWayPoint(kt,cQ)end;if ct then a.print(ct.FuelUsed("atmofueltank")..", "..ct.FuelUsed("spacefueltank")..", "..ct.FuelUsed("rocketfueltank"))end;if vI then vJ.ExtraOnStop()end;fM("stop","SU")end;function uU.controlStart(uq)if vG then cx.startControl(uq)end end;function uU.controlStop(uq)if vG then cx.stopControl(uq)end end;function uU.controlLoop(uq)if vG then cx.loopControl(uq)end end;function uU.controlInput(rf)if vG then cx.inputTextControl(rf)end end;function uU.radarEnter(dX)if cw then cw.onEnter(dX)end end;function uU.radarLeave(dX)if cw then cw.onLeave(dX)end end;function uU.onTick(vO)if vO=="tenthSecond"then if cv then cv.TenthTick()end;if ct then ct.TenthTick()end elseif vO=="oneSecond"then if ct then ct.OneSecondTick()end elseif vO=="msgTick"then if ct then ct.MsgTick()end elseif vO=="animateTick"then if ct then ct.AnimateTick()end elseif vO=="hudTick"then if ct then ct.hudtick()end elseif vO=="apTick"then if cv then cv.APTick()end elseif vO=="shieldTick"then cy.shieldTick()elseif vO=="tagTick"then cx.tagTick()elseif vO=="contact"then cw.ContactTick()end end;if vI then for dN,dz in pairs(vI)do uU[dN]=dz end end;return uU end;function script.onStart()vJ.onStart()end;function script.onOnStop()vJ.onStop()end;function script.onTick(vO)vJ.onTick(vO)end;function script.onOnFlush()vJ.onFlush()end;function script.onOnUpdate()vJ.onUpdate()end;function script.onActionStart(uq)vJ.controlStart(uq)end;function script.onActionStop(uq)vJ.controlStop(uq)end;function script.onActionLoop(uq)vJ.controlLoop(uq)end;function script.onInputText(rf)vJ.controlInput(rf)end;function script.onEnter(dX)vJ.radarEnter(dX)end;function script.onLeave(dX)vJ.radarLeave(dX)end;bN(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vJ=uR(d,core,unit,e,vBooster,hover,pG,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iw,uh)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
