name: ArchHud - Archaegeo v0.739 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.739;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=66000;W=1000;X=50;Y=0;Z=100000;_=1.0;a0=32;a1=0;a2=0;a3=0;a4=0;a5=0;a6=0;a7={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)a8=K end,get=function()return a8 end},AutopilotInterplanetaryThrottle={set=function(K)_=K end,get=function()return _ end},warmup={set=function(K)a0=K end,get=function()return a0 end},fuelTankHandlingAtmo={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingSpace={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingRocket={set=function(K)a3=K end,get=function()return a3 end},ContainerOptimization={set=function(K)a4=K end,get=function()return a4 end},FuelTankOptimization={set=function(K)a5=K end,get=function()return a5 end},AutoShieldPercent={set=function(K)a6=K end,get=function()return a6 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=1750;av=350;aw=50;ax=250;ay=0;az=30;aA=100;aB={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},radarX={set=function(K)au=K end,get=function()return au end},radarY={set=function(K)av=K end,get=function()return av end},DeadZone={set=function(K)aw=K end,get=function()return aw end},OrbitMapSize={set=function(K)ax=K end,get=function()return ax end},OrbitMapX={set=function(K)ay=K end,get=function()return ay end},OrbitMapY={set=function(K)az=K end,get=function()return az end},soundVolume={set=function(K)aA=K end,get=function()return aA end}}aC=5.0;aD=1.0;aE=0.003;aF=0.003;aG=2;aH=1.5;aI=180;aJ=150;aK=0.002;aL=2;aM=0.8;aN=1;aO=3;aP=1;aQ=40;aR=0.0666667;aS=0.0;aT="none"aU="none"aV="none"aW={speedChangeLarge={set=function(K)aC=K end,get=function()return aC end},speedChangeSmall={set=function(K)aD=K end,get=function()return aD end},MouseXSensitivity={set=function(K)aE=K end,get=function()return aE end},MouseYSensitivity={set=function(K)aF=K end,get=function()return aF end},autoRollFactor={set=function(K)aG=K end,get=function()return aG end},rollSpeedFactor={set=function(K)aH=K end,get=function()return aH end},autoRollRollThreshold={set=function(K)aI=K end,get=function()return aI end},minRollVelocity={set=function(K)aJ=K end,get=function()return aJ end},TrajectoryAlignmentStrength={set=function(K)aK=K end,get=function()return aK end},torqueFactor={set=function(K)aL=K end,get=function()return aL end},pitchSpeedFactor={set=function(K)aM=K end,get=function()return aM end},yawSpeedFactor={set=function(K)aN=K end,get=function()return aN end},brakeSpeedFactor={set=function(K)aO=K end,get=function()return aO end},brakeFlatFactor={set=function(K)aP=K end,get=function()return aP end},DampingMultiplier={set=function(K)aQ=K end,get=function()return aQ end},hudTickRate={set=function(K)aR=K end,get=function()return aR end},ExtraEscapeThrust={set=function(K)aS=K end,get=function()return aS end},ExtraLongitudeTags={set=function(K)aT=K end,get=function()return aT end},ExtraLateralTags={set=function(K)aU=K end,get=function()return aU end},ExtraVerticalTags={set=function(K)aV=K end,get=function()return aV end}}aX=j;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=1000;b9=false;ba=false;bb=false;bc=false;bd=0;be="Aligning"bf=0;bg=1;bh="None"bi=nil;bj=0;bk=nil;bl=0.0;bm=0;bn={}bo=false;bp=0;bq=0;br=nil;bs=0;bt=1000;bu=0;bv=false;bw=0;bx=false;by="All"bz=true;bA="Off"bB=0.000;bC={}bD={}bE={VertTakeOff={set=function(K)b7=K end,get=function()return b7 end},VertTakeOffEngine={set=function(K)aY=K end,get=function()return aY end},SpaceTarget={set=function(K)bv=K end,get=function()return bv end},BrakeToggleStatus={set=function(K)aX=K end,get=function()return aX end},BrakeIsOn={set=function(K)aZ=K end,get=function()return aZ end},RetrogradeIsOn={set=function(K)a_=K end,get=function()return a_ end},ProgradeIsOn={set=function(K)b0=K end,get=function()return b0 end},Autopilot={set=function(K)b1=K end,get=function()return b1 end},TurnBurn={set=function(K)b2=K end,get=function()return b2 end},AltitudeHold={set=function(K)b3=K end,get=function()return b3 end},BrakeLanding={set=function(K)b4=K end,get=function()return b4 end},Reentry={set=function(K)b6=K end,get=function()return b6 end},AutoTakeoff={set=function(K)b5=K end,get=function()return b5 end},HoldAltitude={set=function(K)b8=K end,get=function()return b8 end},AutopilotAccelerating={set=function(K)b9=K end,get=function()return b9 end},AutopilotBraking={set=function(K)bb=K end,get=function()return bb end},AutopilotCruising={set=function(K)bc=K end,get=function()return bc end},AutopilotRealigned={set=function(K)ba=K end,get=function()return ba end},AutopilotEndSpeed={set=function(K)bd=K end,get=function()return bd end},AutopilotStatus={set=function(K)be=K end,get=function()return be end},AutopilotPlanetGravity={set=function(K)bf=K end,get=function()return bf end},PrevViewLock={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetName={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetCoords={set=function(K)bi=K end,get=function()return bi end},AutopilotTargetIndex={set=function(K)bj=K end,get=function()return bj end},TotalDistanceTravelled={set=function(K)bl=K end,get=function()return bl end},TotalFlightTime={set=function(K)bm=K end,get=function()return bm end},SavedLocations={set=function(K)bn=K end,get=function()return bn end},VectorToTarget={set=function(K)bo=K end,get=function()return bo end},LocationIndex={set=function(K)bp=K end,get=function()return bp end},LastMaxBrake={set=function(K)bq=K end,get=function()return bq end},LockPitch={set=function(K)br=K end,get=function()return br end},LastMaxBrakeInAtmo={set=function(K)bs=K end,get=function()return bs end},AntigravTargetAltitude={set=function(K)bt=K end,get=function()return bt end},LastStartTime={set=function(K)bu=K end,get=function()return bu end},iphCondition={set=function(K)by=K end,get=function()return by end},stablized={set=function(K)bz=K end,get=function()return bz end},UseExtra={set=function(K)bA=K end,get=function()return bA end},SelectedTab={set=function(K)bF=K end,get=function()return bF end},saveRoute={set=function(K)bC=K end,get=function()return bC end},apRoute={set=function(K)bD=K end,get=function()return bD end}}local function bG(a,b,c,bH,bI,bJ)bK=bH()bL=0;bM=0;bN=false;bO=0;bP=false;bQ=false;bR=0;bS=0;bT=0;bU=0;bV=false;bW=false;bX="empty"bY=3;bZ=false;b_=0;c0=0;c1=nil;c2=0;c3=0;c4=0;c5=false;c6=false;c7=false;c8=-1;c9=bJ()>0;ca=bJ()cb=b.getAltitude()cc=b.getConstructMass()cd=nil;ce=a9;cf=aa;cg={}ch={}ci={}cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=false;ct=false;cu=p;cv=false;cw=U;cx=nil;cy=0;cz=false;cA=false;cB=false;cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getVelocity())cF=vec3(b.getWorldVelocity())cG=vec3(cF):len()cH=vec3(b.getWorldVertical())cI=-cH:dot(cF)cJ=vec3(b.getConstructWorldPos())cK=false;cL=false;cM=true;cN=0;cO=0;cP={}cQ=false;cR=50000;cS=nil;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;cU=false;cV=nil;cW=false;cX=0;cY=nil;cZ=nil;c_={}d0=90;d1=w;d2=nil;d3=nil;d4={}d5={}d6=false;d7=nil;d8=0;d9=false;da=b.getMaxSpeed()if shield then db=bI(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dc(dd)a.print(bK..": "..dd)end;local function de(d,b,c,a,df,dg,dh,di,dj)local function dk(dl)return type(dl)=='number'end;local function dm(dl)return type(dh(dl))=='number'end;local function dn(dp)return type(dp)=='table'end;local function dq(a)return type(a)=='string'end;local function dr(ds)return dn(ds)and dk(ds.x and ds.y and ds.z)end;local function dt(du)return dn(du)and dk(du.latitude and du.longitude and du.altitude and du.id and du.systemId)end;local dv=math.pi/180;local dw=180/math.pi;local dx=1e-10;local dy=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dz='::pos{'..dy..','..dy..','..dy..','..dy..','..dy..'}'local utils=utils;local vec3=vec3;local function dA(dl)local dB=string.gsub(string.reverse(df('%.4f',dl)),'^0*%.?','')return dB==''and'0'or string.reverse(dB)end;local function dC(dD)if dr(dD)then return df('{x=%.3f,y=%.3f,z=%.3f}',dD.x,dD.y,dD.z)end;if dn(dD)and not getmetatable(dD)then local dE={}local dF=next(dD)if type(dF)=='nil'or dF==1 then dE=dD else for dG,ds in pairs(dD)do local dH=dC(ds)if type(dG)=='number'then table.insert(dE,df('[%s]=%s',dG,dH))else table.insert(dE,df('%s=%s',dG,dH))end end end;return df('{%s}',table.concat(dE,','))end;if dq(dD)then return df("'%s'",dD:gsub("'",[[\']]))end;return tostring(dD)end;local dI={}dI.__index=dI;dI.__tostring=function(dD,dJ)local dK={}for dG in pairs(dD)do table.insert(dK,dG)end;table.sort(dK)local dE={}for dL,dG in ipairs(dK)do local dH=dC(dD[dG])if type(dG)=='number'then table.insert(dE,df('[%s]=%s',dG,dH))else table.insert(dE,df('%s=%s',dG,dH))end end;if dJ then return df('%s%s',dJ,table.concat(dE,',\n'..dJ))end;return df('{%s}',table.concat(dE,','))end;dI.__eq=function(dM,dN)return dM.systemId==dN.systemId and dM.id==dN.id and dj(dM.radius,dN.radius)and dj(dM.center.x,dN.center.x)and dj(dM.center.y,dN.center.y)and dj(dM.center.z,dN.center.z)and dj(dM.GM,dN.GM)end;local function dO(dP,dQ,dR,dS,dT)assert(dm(dP),'Argument 1 (systemId) must be a number:'..type(dP))assert(dm(dQ),'Argument 2 (id) must be a number:'..type(dQ))assert(dm(dR),'Argument 3 (radius) must be a number:'..type(dR))assert(dn(dS),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dS))assert(dm(dT),'Argument 5 (GM) must be a number:'..type(dT))return setmetatable({systemId=dh(dP),id=dh(dQ),radius=dh(dR),center=vec3(dS),GM=dh(dT)},dI)end;local dU={}dU.__index=dU;dU.__tostring=function(dc)return df('::pos{%d,%d,%s,%s,%s}',dc.systemId,dc.id,dA(dc.latitude*dw),dA(dc.longitude*dw),dA(dc.altitude))end;dU.__eq=function(dM,dN)return dM.id==dN.id and dM.systemId==dN.systemId and dj(dM.latitude,dN.latitude)and dj(dM.altitude,dN.altitude)and(dj(dM.longitude,dN.longitude)or dj(dM.latitude,math.pi/2)or dj(dM.latitude,-math.pi/2))end;local function dV(dW,dQ,dX,dY,dZ)local dP=dW;if dq(dW)and not dY and not dZ and not dQ and not dX then dP,dQ,dX,dY,dZ=d_(dW,dz)assert(dP,'Argument 1 (position string) is malformed.')else assert(dm(dP),'Argument 1 (systemId) must be a number:'..type(dP))assert(dm(dQ),'Argument 2 (id) must be a number:'..type(dQ))assert(dm(dX),'Argument 3 (latitude) must be in degrees:'..type(dX))assert(dm(dY),'Argument 4 (longitude) must be in degrees:'..type(dY))assert(dm(dZ),'Argument 5 (altitude) must be in meters:'..type(dZ))end;dP=dh(dP)dQ=dh(dQ)dX=dh(dX)dY=dh(dY)dZ=dh(dZ)if dQ==0 then return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=dQ,systemId=dP},dU)end;return setmetatable({latitude=dv*dg(dX,-90,90),longitude=dv*(dY%360),altitude=dZ,id=dQ,systemId=dP},dU)end;local e0={}e0.__index=e0;e0.__tostring=function(dD,dJ)local e1=dJ and dJ..'  'local e2={}local dK={}for dG in pairs(dD)do table.insert(dK,dG)end;table.sort(dK)for dL,e3 in ipairs(dK)do e4=dD[e3]local e5=dI.__tostring(e4,e1)if dJ then table.insert(e2,df('[%s]={\n%s\n%s}',e3,e5,dJ))else table.insert(e2,df('  [%s]=%s',e3,e5))end end;if dJ then return df('\n%s%s%s',dJ,table.concat(e2,',\n'..dJ),dJ)end;return df('{\n%s\n}',table.concat(e2,',\n'))end;local function e6(e7)local e={}local pid;for dL,ds in pairs(e7)do local dQ=ds.planetarySystemId;if type(dQ)~='number'then error('Invalid planetary s ID: '..tostring(dQ))elseif pid and dQ~=pid then error('Mistringmatch planetary s IDs: '..dQ..' and '..pid)end;local e8=ds.bodyId;if type(e8)~='number'then error('Invalid body ID: '..tostring(e8))elseif e[e8]then error('Duplicate body ID: '..tostring(e8))end;setmetatable(ds.center,getmetatable(vec3.unit_x))e[e8]=setmetatable(ds,dI)pid=dQ end;return setmetatable(e,e0)end;e9={}local function ea(e7)return setmetatable({galaxyAtlas=e7 or{}},e9)end;e9.__index=function(dp,K)if type(K)=='number'then local a=dp.galaxyAtlas[K]return e6(a)end;return rawget(e9,K)end;e9.__pairs=function(dD)return function(dp,dG)local eb,ec=next(dp,dG)return eb,ec and e6(ec)end,dD.galaxyAtlas,nil end;e9.__tostring=function(dD)local ed={}for dL,ee in pairs(dD or{})do local ef=ee:getPlanetarySystemId()local eg=e0.__tostring(ee,'    ')table.insert(ed,df('  [%s]={%s\n  }',ef,eg))end;return df('{\n%s\n}\n',table.concat(ed,',\n'))end;e9.BodyParameters=dO;e9.MapPosition=dV;e9.PlanetarySystem=e6;function e9.createBodyParameters(dP,dQ,eh,ei,ej,ek,el)assert(dm(dP),'Argument 1 (systemId) must be a number:'..type(dP))assert(dm(dQ),'Argument 2 (id) must be a number:'..type(dQ))assert(dm(eh),'Argument 3 (surfaceArea) must be a number:'..type(eh))assert(dn(ei),'Argument 4 (aPosition) must be an array or vec3:'..type(ei))assert(dn(ej),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ej))assert(dm(ek),'Argument 6 (altitude) must be in meters:'..type(ek))assert(dm(el),'Argument 7 (gravityAtPosition) must be number:'..type(el))local dR=di(eh/4/math.pi)local c4=dR+ek;local em=vec3(ei)+c4*vec3(ej)local dT=el*c4*c4;return dO(dP,dQ,dR,em,dT)end;e9.isMapPosition=dt;function e9:getPlanetarySystem(dW)if K==nil then K=0 end;if ec==nil then ec=0 end;local dP=dW;if dt(dW)then dP=dW.systemId end;if type(dP)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(ec)~=e0 then a=e6(a)end;return a end end end;function e0:sizeCalculator(en)return 1.05*en.radius end;function e0:castIntersections(eo,ep,eq,er,es,et)local eu={}if es then for dL,en in pairs(es)do table.insert(eu,en)end else eu=c_ end;if not et then table.sort(eu,function(ev,ew)local ex=ev.center;local ey=ew.center;return(ex.x-eo.x)^2+(ex.y-eo.y)^2+(ex.z-eo.z)^2<(ey.x-eo.x)^2+(ey.y-eo.y)^2+(ey.z-eo.z)^2 end)end;local ez=ep:normalize()for dL,en in ipairs(eu)do local eA=en.center-eo;local dR;if eq then dR=eq(en)else dR=self:sizeCalculator(en)end;local eB=eA:dot(ez)local eC=eB^2-(eA:len2()-dR^2)if eC>=0 then local eD=di(eC)local eE=eB+eD;local eF=eB-eD;if eF>0 then return en,eE,eF elseif eE>0 then return en,eE,nil end end end;return nil,nil,nil end;function e0:closestBody(eG)assert(type(eG)=='table','Invalid coordinates.')local eH,en;local eI=vec3(eG)for dL,eJ in pairs(self)do local eK=(eJ.center-eI):len2()if(not en or eK<eH)and eJ.name~="Space"then en=eJ;eH=eK end end;return en end;function e0:convertToBodyIdAndWorldCoordinates(dW)local eL=dW;if dq(dW)then eL=dV(dW)end;if eL.id==0 then return 0,vec3(eL.latitude,eL.longitude,eL.altitude)end;local eJ=self:getBodyParameters(eL)if eJ then return eL.id,eJ:convertToWorldCoordinates(eL)end end;function e0:getBodyParameters(dW)local dQ=dW;if dt(dW)then dQ=dW.id end;assert(dm(dQ),'Argument 1 (id) must be a number:'..type(dQ))return self[dQ]end;function e0:getPlanetarySystemId()local dL,ds=next(self)return ds and ds.systemId end;function dI:convertToMapPosition(dS)assert(dn(dS),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dS))local eM=vec3(dS)if self.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=self.systemId},dU)end;local eN=eM-self.center;local c4=eN:len()local dZ=c4-self.radius;local dX=0;local dY=0;if not dj(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=self.id,systemId=self.systemId},dU)end;function dI:convertToWorldCoordinates(dW)local eL=dq(dW)and dV(dW)or dW;if eL.id==0 then return vec3(eL.latitude,eL.longitude,eL.altitude)end;assert(dt(eL),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eL.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eL.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eQ=math.cos(eL.latitude)return self.center+(self.radius+eL.altitude)*vec3(eQ*math.cos(eL.longitude),eQ*math.sin(eL.longitude),math.sin(eL.latitude))end;function dI:getAltitude(dS)return(vec3(dS)-self.center):len()-self.radius end;function dI:getDistance(dS)return(vec3(dS)-self.center):len()end;function dI:getGravity(dS)local eR=self.center-vec3(dS)local eS=eR:len2()return self.GM/eS*eR/di(eS)end;return setmetatable(e9,{__call=function(dL,...)return ea(...)end})end;local function eT(d,b,c,a,di,eU)local ck={}local eV=100000000/3600;local eW=eV*eV;local eX=100;function ck.computeAccelerationTime(eY,eZ,e_)local f0=eV*math.asin(eY/eV)return(eV*math.asin(e_/eV)-f0)/eZ end;function ck.computeDistanceAndTime(eY,e_,f1,f2,f3,f4)f3=f3 or 0;f4=f4 or 0;local f5=eY<=e_;local f6=f2*(f5 and 1 or-1)/f1;local f7=-f4/f1;local f8=f6+f7;if f5 and f8<=0 or not f5 and f8>=0 then return-1,-1 end;local f9,fa=0,0;if f6~=0 and f3>0 then local f0=math.asin(eY/eV)local fb=math.pi*(f6/2+f7)local fc=f6*f3;local fd=eV*math.pi;local ds=function(dp)local fe=(fb*dp-fc*math.sin(math.pi*dp/2/f3)+fd*f0)/fd;local ff=math.tan(fe)return eV*ff/di(ff*ff+1)end;local fg=f5 and function(a)return a>=e_ end or function(a)return a<=e_ end;fa=2*f3;if fg(ds(fa))then local fh=0;while eU(fa-fh)>0.5 do local dp=(fa+fh)/2;if fg(ds(dp))then fa=dp else fh=dp end end end;local fi=eY;local fj=fa/eX;for fk=1,eX do local fl=ds(fk*fj)f9=f9+(fl+fi)*fj/2;fi=fl end;if fa<2*f3 then return f9,fa end;eY=fi end;local f0=eV*math.asin(eY/eV)local bK=(eV*math.asin(e_/eV)-f0)/f8;local fm=eW*math.cos(f0/eV)/f8;local c4=fm-eW*math.cos((f8*bK+f0)/eV)/f8;return c4+f9,bK+fa end;function ck.computeTravelTime(eY,eZ,c4)if c4==0 then return 0 end;if eZ>0 then local f0=eV*math.asin(eY/eV)local fm=eW*math.cos(f0/eV)/eZ;return(eV*math.acos(eZ*(fm-c4)/eW)-f0)/eZ end;if eY==0 then return-1 end;assert(eY>0,'Acceleration and initial speed are both zero.')return c4/eY end;return ck end;local function fn(d,b,c,a,df,dg,dh,di,dj)local vec3=vec3;local de=de(d,b,c,a,df,dg,dh,di,dj)local function dq(a)return type(a)=='string'end;local function dn(dp)return type(dp)=='table'end;fo={}fo.__index=fo;function fo:escapeAndOrbitalSpeed(dZ)assert(self.body)local c4=dZ+self.body.radius;if not dj(c4,0)then local fp=di(self.body.GM/c4)return di(2)*fp,fp end;return nil,nil end;function fo:orbitalParameters(dW,fq)assert(self.body)assert(dn(dW)or dq(dW))assert(dn(fq))local fr=(dq(dW)or de.isMapPosition(dW))and self.body:convertToWorldCoordinates(dW)or vec3(dW)local ds=vec3(fq)local fs=fr-self.body.center;local ft=ds:len2()local fu=fs:len()local fv=self.body.GM;local fw=((ft-fv/fu)*fs-fs:dot(ds)*ds)/fv;local ex=fv/(2*fv/fu-ft)local fx=fw:len()local ez=fw:normalize()local fy=ex*(1-fx)local fz=ex*(1+fx)local fA=fy*ez+self.body.center;local fB=fx<=1 and-fz*ez+self.body.center or nil;local fC=di(ex*fv*(1-fx*fx))local fD=fB and 2*math.pi*di(ex^3/fv)local fE=math.acos(fw:dot(fs)/(fx*fu))if fs:dot(ds)<0 then fE=-(fE-2*math.pi)end;local fF=math.acos((math.cos(fE)+fx)/(1+fx*math.cos(fE)))local fG=fF;if fG<0 then fG=fG+2*math.pi end;local fH=fG-fx*math.sin(fG)local fI=0;local fJ=0;local fK=0;if fD~=nil then fI=fH/(2*math.pi/fD)fJ=fD-fI;fK=fJ+fD/2;if fE-math.pi>0 then fJ=fI;fK=fJ+fD/2 end;if fK>fD then fK=fK-fD end end;return{periapsis={position=fA,speed=fC/fy,circularOrbitSpeed=di(fv/fy),altitude=fy-self.body.radius},apoapsis=fB and{position=fB,speed=fC/fz,circularOrbitSpeed=di(fv/fz),altitude=fz-self.body.radius},currentVelocity=ds,currentPosition=fr,eccentricity=fx,period=fD,eccentricAnomaly=fF,meanAnomaly=fH,timeToPeriapsis=fJ,timeToApoapsis=fK,trueAnomaly=fE}end;local function fL(fM)local eJ=de.BodyParameters(fM.systemId,fM.id,fM.radius,fM.center,fM.GM)return setmetatable({body=eJ},fo)end;return setmetatable(fo,{__call=function(dL,...)return fL(...)end})end;local function fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dh,di,fQ,fR)local function fS(fT)local dc=fU:closestBody(fT)if(fT-dc.center):len()>dc.radius+dc.noAtmosphericDensityAltitude then dc=e[0][0]end;return dc end;local function fV()local function fW(fX,fY)return fX.name<fY.name end;cP={}for dG,ds in pairs(e[0])do cP[#cP+1]={name=ds.name,index=dG}end;table.sort(cP,fW)end;local function fZ(f_,g0)if not g0 then g0=g1.name end;for dG,ds in pairs(f_)do if ds.name and ds.name==g0 then return dG end end;return-1 end;local function g2()cX=bj;if bj==0 then bh="None"c1=nil;g1=nil;return true end;local g3=cP[bj].index;local g4=e[0][g3]if g4.center then bh=g4.name;c1=cj[0][g3]if g1~=nil then if ca==0 then if fO(g5,g6)~=1 then fP(g5,g6)end;if fO(g7,g8)~=1 then fP(g7,g8)end;if fO(g9,ga)~=1 then fP(g9,ga)end;if fO(gb,gc)~=1 then fP(gb,gc)end;if fO(gd,ge)~=1 then fP(gd,ge)end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end;if fO(gj,gk)~=1 then fP(gj,gk)end end;g1=nil else g1=g4;for dL,ds in pairs(cj[0])do if ds.name==g1.planetname then c1=ds;bh=g1.name;break end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end end;if g1==nil then bi=vec3(c1.center)else bi=g1.position end;if c1.planetname~="Space"then if c1.hasAtmosphere then gl=bI(c1.radius*(S-1)+c1.noAtmosphericDensityAltitude)else gl=bI(c1.radius*(S-1)+c1.surfaceMaxAltitude)end else gl=R end;if g1~=nil and g1.planetname=="Space"then bd=0 else dL,bd=cl(c1):escapeAndOrbitalSpeed(gl)end;bf=0;b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"return true end;local function gm(gn)if not b1 and not bo and not c6 and not bx and not b6 and not c7 then if gn==nil then bj=bj+1;if bj>#cP then bj=0 end else bj=bj-1;if bj<0 then bj=#cP end end;if bj==0 then g2()else local g3=cP[bj].index;local g4=e[0][g3]if g4 and(g4~=nil and g4.name=="Space"or by=="Custom Only"and g4.center or by=="No Moons"and string.find(g4.name,"Moon")~=nil)then if gn==nil then gm()else gm(1)end else g2()end end else bX="Disengage autopilot before changing Interplanetary Helper"fQ("iph","AP")end end;local function go()local function gp(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=-1;gs=fZ(e[0])if gs>-1 then table.remove(e[0],gs)end;gs=-1;gs=fZ(gr)if gs~=-1 then bX=g1.name.." saved location cleared"table.remove(gr,gs)end;gm()fV()return gr end;if string.sub(bh,1,1)=="*"then d4=gp(true)else bn=gp(false)end end;local function gt(gu,fT,gv,gw)local function gx(gq)if gq then gr=d4 else gr=bn end;if dbHud_1 or gv or gq then local dc=fS(fT)local gy={position=fT,name=gu,planetname=dc.name,gravity=b.g(),safe=gw}if not gv then gr[#gr+1]=gy else for dG,ds in pairs(e[0])do if ds.name and gu==ds.name then table.remove(e[0],dG)end end end;table.insert(e[0],gy)fV()g2()bX="Location saved as "..gu.."("..dc.name..")"return gr else bX="Databank must be installed to save permanent locations"end end;if string.sub(gu,1,1)=="*"then d4=gx(true)else bn=gx(false)end end;local gz={}function gz.UpdateAtlasLocationsList()fV()end;function gz.UpdateAutopilotTarget()g2()end;function gz.adjustAutopilotTargetIndex(gn)gm(gn)end;function gz.findAtlasIndex(f_,g0)return fZ(f_,g0)end;function gz.UpdatePosition(gA,gB,gC)local function gD(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=fZ(gr)if gs~=-1 then if gA~=nil then if gq then gA="*"..gA end;gr[gs].name=gA;bj=bj-1;gm()elseif gC~=nil then if gC then local gE=cb;if gE<1000 then gE=1000 end;gr[gs].agg=fR(gE,0)bX=gr[gs].name.." AGG Altitude:"..gr[gs].agg.." saved ("..gr[gs].planetname..")"return elseif gC==false then gr[gs].agg=nil;bX=gr[gs].name.." AGG Altitude cleared ("..gr[gs].planetname..")"return end else local gF=gr[gs]if gB then gF.heading=cD:cross(cH)*5000;bX=gr[gs].name.." heading saved ("..gr[gs].planetname..")"return elseif gB==false then gF.heading=nil;bX=gr[gs].name.." heading cleared ("..gr[gs].planetname..")"return end;gF.gravity=b.g()gF.position=cJ;gF.safe=true end;bX=gr[gs].name.." position updated ("..gr[gs].planetname..")"else bX="Name Not Found"end end;if string.sub(bh,1,1)=="*"then gD(true)else gD(false)end end;function gz.AddNewLocation(gu,fT,gv,gw)gt(gu,fT,gv,gw)end;function gz.ClearCurrentPosition()go()end;for dG,ds in pairs(d5)do table.insert(e[0],ds)end;if gG then for dG,ds in pairs(gG)do gz[dG]=ds end end;fV()if bj>#cP then bj=0 end;gz.UpdateAutopilotTarget()return gz end;local function gH(b,a,c,library,radar_1,radar_2,eU,gI,di,gJ,dh,gK,fQ)local gL={}local gM={}local gN={XS=13,S=27,M=55,L=110,XL=221}local gO={}local gP=0;local gQ;local gR;local gS;local gT={}local gU="Atmo"local gV;local gW;local gX=0;local gY={}local gZ;local g_=a.getArkTime()local function h0()local function h1(h2,h3,h4,h5,h6,h7,h8,h9)h3,h5,h7,h9=vec3(h3),vec3(h5),vec3(h7),vec3(h9)local ha,hb,hc=h2*h2,h4*h4,h6*h6;local ft=h5-h3;local hd=ft:normalize()local he=ft:len()local hf=h7-h3;local hg=(hf-hf:project_on(hd)):normalize()local hh,hi=hf:dot(hd),hf:dot(hg)local hj=hh*hh+hi*hi;local hk=hd:cross(hg)local hl=(ha-hb+he*he)/(2*he)local hm=(ha-hc+hj-2*hh*hl)/(2*hi)local du=ha-hl^2-hm^2;local hn=di(du)local ho=h3+hd*hl+hg*hm+hk*hn;local hp=h3+hd*hl+hg*hm-hk*hn;if eU((h9-ho):len()-h8)<eU((h9-hp):len()-h8)then return ho else return hp end end;local function hq(hr,fu,hs)local ht=hr.pts;local gs=#ht;local hu=hr.ref;if gs>3 then local hv,hw,hx,hy=ht[gs],ht[gs-1],ht[gs-2],ht[gs-3]hr.ref=hs;local fr=h1(hv[1],hv[2],hw[1],hw[2],hx[1],hx[2],hy[1],hy[2])local hl,hm,hn=fr.x,fr.y,fr.z;if hl==hl and hm==hm and hn==hn then hl=hl+hu[1]hm=hm+hu[2]hn=hn+hu[3]local hz=vec3(hl,hm,hn)hr.center=hz;if hr.lastPos then if(hr.lastPos-hz):len()<2 then local hA=(hz-vec3(hs)):len()if eU(hA-fu)<10 then hr.skipCalc=true end end end;hr.lastPos=hz end;hr.pts={}else local hB={hs[1]-hu[1],hs[2]-hu[2],hs[3]-hu[3]}ht[gs+1]={fu,hB}end end;if radar_1 or radar_2 then cp.assignRadar()end;if gT[1]then gP=#gT[1].getConstructIds()local hC=gZ:gmatch('{"constructId[^}]*}[^}]*}')if gP>0 then local hs={cJ["x"],cJ["y"],cJ["z"]}local hD,hE=0,0;local hF=cG*10;gS,gR=0,0;for ds in hC do local dQ,c4,hG=ds:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hH=gN[hG]c4=dh(c4)if gT[1].hasMatchingTransponder(dQ)==1 then table.insert(gM,dQ)end;if E then local hI=gT[1].getConstructType(dQ)if F and gT[1].isConstructAbandoned(dQ)==1 or c4<hF and(hH>27 or hI=="static"or hI=="space")then gS=gS+1;local gu=gT[1].getConstructName(dQ)local hr=gY[dQ]if hr==nil then hH=hH+gK;gY[dQ]={pts={},ref=hs,name=gu,i=0,radius=hH,skipCalc=false}hr=gY[dQ]end;if not hr.skipCalc then hq(hr,c4,hs)if F and not hr.abandoned and gT[1].isConstructAbandoned(dQ)==1 and hr.center then local bK=a.getArkTime()if g_+5<bK then g_=bK;fQ("abRdr","RD")end;a.print("Abandoned Construct: "..gu.." ("..hG.." "..hI..") at estimated ::pos{0,0,"..hr.center.x..","..hr.center.y..","..hr.center.z.."}")bX="Abandoned Radar Contact ("..hI..") detected"hr.abandoned=true end;hE=hE+1 else table.insert(gO,hr)end end;hD=hD+1;if cT and hD>700 or hE>70 or(not cT and hD>300 or hE>30)then coroutine.yield()hD,hE=0,0 end end end;gR=#gO;if gR>0 and(cG>20 or b4)then local en,hJ,hK,hL;local hM=0;local hN=cj:getPlanetarySystem(0)hL=cF:normalize()while hM<gR do coroutine.yield()local hO={table.unpack(gO,hM,math.min(hM+75,gR))}en,hJ,hK=hN:castIntersections(cJ,hL,nil,nil,hO,true)if en and hK then cV={en,hJ,hK}break end;hM=hM+75 end;if not en then cV=nil end else cV=nil end;gO={}gQ=gZ:find('identifiedConstructs":%[%]')end end end;local function hP()if gT[1]then gU="Atmo"if gZ:find('worksInAtmosphere":false')then gU="Space"end end end;function gL.pickType()hP()end;function gL.assignRadar()if radar_2 and gT[1].isOperational()~=1 then local hQ=gZ:find('errorMessage":"Jammed')or gZ:find('errorMessage":"Out')if hQ then if gT[1]==radar_2 then gT[1]=radar_1 else gT[1]=radar_2 end end;gZ=gT[1].getData()hP()else gZ=gT[1].getData()end end;function gL.UpdateRadar()local hR=coroutine.status(gV)if hR=="suspended"then local dH,hS=coroutine.resume(gV)if hS then a.print("ERROR UPDATE RADAR: "..hS)end elseif hR=="dead"then gV=coroutine.create(h0)local dH,hS=coroutine.resume(gV)end end;function gL.GetRadarHud(hT,hU,au,av)local hV=gM;local hW,dd;gM={}local dy=gR or 0;if gP>0 then if E then dd=dy.."/"..gS.." Plotted : "..gP-gS.." Ignored"else dd="Radar Contacts: "..gP end;hW=gJ(au,av,dd,"pbright txtbig txtmid")if#gM>0 then hW=hW..gJ(hT,hU,"Friendlies In Range","pbright txtbig txtmid")for dG,ds in pairs(gM)do hU=hU+20;hW=hW..gJ(hT,hU,gT[1].getConstructName(ds),"pdim txtmid")end end;if gQ==nil and gW==nil then gX=1;cp.ToggleRadarPanel()end;if gQ~=nil and gW~=nil then cp.ToggleRadarPanel()end;if d3==nil then cp.ToggleRadarPanel()end else if gT[1].isOperational()~=1 then if gZ:find('errorMessage":"Obstructed')then hW=gJ(au,av,gU.." Radar: Obstructed","pbright txtbig txtmid")elseif gZ:find('errorMessage":"Jammed')then hW=gJ(au,av,gU.." Radar: Jammed","pbright txtbig txtmid")else hW=gJ(au,av,gU.." Radar: Destroyed","pbright txtbig txtmid")end else hW=gJ(au,av,"Radar: No "..gU.." Contacts","pbright txtbig txtmid")end;if d3~=nil then gX=0;cp.ToggleRadarPanel()end end;return hW end;function gL.GetClosestName(gu)if gT[1]then local dQ,dL=gT[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dQ~=nil and dQ~=""then gu=gu.." "..gT[1].getConstructName(dQ)end end;return gu end;function gL.ToggleRadarPanel()if d3~=nil and gX==0 then gI(d3)d3=nil;if gW~=nil then gI(gW)gW=nil end else if gX==1 then gI(d3)d3=nil;_autoconf.displayCategoryPanel(gT,1,"Periscope","periscope")gW=_autoconf.panels[_autoconf.panels_size]end;if d3==nil then _autoconf.displayCategoryPanel(gT,1,"Radar","radar")d3=_autoconf.panels[_autoconf.panels_size]end;gX=0 end end;function gL.ContactTick()if not hX then hX=0 end;if bK>hX+10 then bX="Radar Contact"fQ("rdrCon","RC")hX=bK end;c.stopTimer("contact")end;function gL.onEnter(dQ)if gT[1]and not c9 and not cQ then c.setTimer("contact",0.1)end end;function gL.onLeave(dQ)if gT[1]and E then if#gY>650 then dQ=tostring(dQ)gY[dQ]=nil end end end;gT[1]=nil;if radar_2 and radar_2.isOperational()==1 then gT[1]=radar_2 else gT[1]=radar_1 end;gZ=gT[1].getData()hP()gV=coroutine.create(h0)if hY then for dG,ds in pairs(hY)do gL[dG]=ds end end;return gL end;local function hZ(shield,d_,bI)local h_={}local i0=shield.getResistancesCooldown()local function i1()local i2=shield.getState()if G then if not cQ and i2==0 and shield.isVenting()~=1 then shield.toggle()elseif cQ and i2==1 then shield.toggle()end end end;local function i3()local i4=shield.getStressRatioRaw()local i5=0.5999;if i4[1]==0.0 and i4[2]==0.0 and i4[3]==0.0 and i4[4]==0.0 then return end;local i6=shield.setResistances(i5*i4[1],i5*i4[2],i5*i4[3],i5*i4[4])if i6==1 then bX="Shield Resistances updated"else bX="Value Exceeded. Failed to update Shield Resistances"end end;function h_.shieldTick()db=bI(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())i1()i0=shield.getResistancesCooldown()if i0==0 and db<a6 then i3()end end;function h_.setResist(i7)if not shield then bX="No shield found"return elseif i7==nil or i0>0 then bX="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dy=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dz=dy..', '..dy..', '..dy..', '..dy;local i8,i9,ia,ib=d_(i7,dz)if ib==nil or i8+i9+ia+ib>0.6 then bX="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(i8,i9,ia,ib)==1 then bX="Shield Resistances set"else bX="Resistance setting failed."end end;function h_.ventShield()local ic=shield.getVentingCooldown()if ic>0 then bX="Cannot vent again for "..ic.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()bX="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bX="Shields already at max hitpoints"end end;if id then for dG,ds in pairs(id)do h_[dG]=ds end end;return h_ end;local function ie(d,b,c,a,e,antigrav,hover,shield,warpdrive,ig,eU,bI,df,ih,bJ,ii,ij,eP,bH,dg,ik,fP,fO,gI,il,di,fR,gJ,fQ,im,io,ip,iq,ir,is)local it=9.80665;local iu={}local iv={}local iw={}local ix={}local iy=nil;local iz=nil;local iA=nil;local iB=false;local iC="none"local iD=""local iE=55;local iF=0;local iG=0;local iH=nil;local iI=ac;local iJ=ad;local iK=ae;local iL=[[rgb(]]..bI(iI+0.5)..","..bI(iJ+0.5)..","..bI(iK+0.5)..[[)]]local iM=[[rgb(]]..bI(iI*0.9+0.5)..","..bI(iJ*0.9+0.5)..","..bI(iK*0.9+0.5)..[[)]]local iN=0;local iO=0;local iP=""local iQ=bH()local iR=false;local iS=false;local function iT(ds)if ce==1920 then return ds else return fR(ce*ds/1920,0)end end;local function iU(ds)if cf==1080 then return ds else return fR(cf*ds/1080,0)end end;local function iV()return il()==0 and g~="keyboard"and ij()==0 end;local function iW()local iX="TRAVEL"if not cM then iX="CRUISE"end;if b1 then iX="AUTOPILOT"end;return iX end;local hW=""local iY=""local iZ=""local i_=1;local j0=2;local j1=3;local j2=4;local j3=5;local j4=6;local j5=7;local j6=""local j7=0;local j8=120.0*aR;local j9={}local ja={}local jb={}local jc={}local jd={}local je={}local jf={}jf["atmofueltank"],jf["spacefueltank"],jf["rocketfueltank"]=0,0,0;local jg=0;local function jh(hl,ji,jj,jk,jl,jm)local jn=jg;local jo=jg+5;if not B then jo=jo+5 end;if ij()==1 and not l then jn=jn-50;jo=jo-50 end;if jj=="ATMO"then j6="atmofueltank"elseif jj=="SPACE"then j6="spacefueltank"else j6="rocketfueltank"end;j7=_G[j6 .."_size"]if#jk>0 then for K=1,#jk do local gu=jk[K][j0]local jp=jk[K][j5]for jq=1,j7 do if jk[K][j0]==ih(c[j6 .."_"..jq].getData()).name then jp=jq;break end end;local jr=bH()if jl[K]==nil or jm[K]==nil or jr-jk[K][j4]>j8 then local js;local jt=0;jt=ii(jk[K][i_])-jk[K][j2]js=jk[K][j3]if js>jt then jf[j6]=jf[j6]+js-jt end;if jp~=0 then local ju=ih(c[j6 .."_"..jp].getData())jm[K]=ju.percentage;jl[K]=ju.timeLeft;if jl[K]=="n/a"then jl[K]=0 end else jm[K]=bI(0.5+jt*100/jk[K][j1])if js<=jt then jl[K]=0 else jl[K]=bI(0.5+jt/((js-jt)/(jr-jk[K][j4])))end end;jk[K][j4]=jr;jk[K][j3]=jt end;if gu==ji then gu=df("%s %d",jj,K)end;if jp==0 then gu=gu.." *"end;local jv;if jl[K]==0 then jv=""else jv=iq(jl[K])end;if jm[K]~=nil then local jw=bI(jm[K]*2.55)local jx=df("rgb(%d,%d,%d)",255-jw,jw,0)local jy=""if jv~=""and jl[K]<120 or jm[K]<5 then jy="red "end;local jz=df("rgb(%d,%d,%d)",dg(bI((255-jw)/2.55),50,100),dg(bI(jw/2.55),0,50),50)local jA="rgb(196,0,255)"if jj=="ATMO"then jA="rgb(0,188,255)"elseif jj=="SPACE"then jA="rgb(239,255,0)"end;local jB=false;if jC~=jA then jB=true end;jC=jA;if B then if jB then jn=jn-5;jo=jo-5 end;iY=iY..df([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jz,jA,hl,jo,jx,bI(jm[K]*1.7+0.5)-2,hl+1,jo+1,hl+5,jo+14,gu,jm[K],jv)jn=jn-22;jo=jo-22 else iY=iY..gJ(hl,jn,gu,jy.."pdim txtfuel")iY=iY..gJ(hl,jo,df("%d%% %s",jm[K],jv),"pdim txtfuel","fill:"..jx)jn=jn+30;jo=jo+30 end end end end;jg=jn end;local function jD(jE,dZ)if am==0 and an==0 then return end;if dZ<200000 and not c9 or dZ and c9 then local jF=0;if eU(cI)>1 then jF=45*math.log(eU(cI),10)if cI<0 then jF=-jF end end;jE[#jE+1]=df([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bI(cI),bI(jF))end;return jE end;local function jG(jH)local gn=-cH;jH=jH-jH:project_on(gn)local jI=vec3(0,0,1)jI=jI-jI:project_on(gn)local jJ=jI:cross(gn)local jF=jI:angle_between(jH)*constants.rad2deg;if jH:dot(jJ)<0 then jF=360-jF end;return jF end;local function jK(jE,ai,aj,jL,jM,cT)if ab==0 then return end;local jN=ab;local jO=20;local jP=bI(jL)if cT then for K=-45,45,5 do local jQ=K;jE[#jE+1]=df([[<g transform="rotate(%f,%d,%d)">]],jQ,ai,aj)jR=5;if K%15==0 then jR=15 elseif K%10==0 then jR=10 end;jE[#jE+1]=df([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jN+jO-jR,ai,aj+jN+jO)end;jE[#jE+1]=gJ(ai,aj+jN+jO-35,jM,"pdim txt txtmid")jE[#jE+1]=gJ(ai,aj+jN+jO-25,jP.." deg","pdim txt txtmid")jE[#jE+1]=df([[<g transform="rotate(%f,%d,%d)">]],-jL,ai,aj)jE[#jE+1]=df([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jN+jO-20,ai+5,aj+jN+jO-20,ai,aj+jN+jO-15)jE[#jE+1]="</g>"end;jE[#jE+1]=[[<g style="clip-path: url(#headingClip);">]]local jS=jP;if cT then jS=jG(cC)end;local jT=20;local jU=bI(jS)local jV=0;local jW=aj+jN+jO+20;local jX=ai;if jM~="YAW"then jW=iU(130)jX=iT(960)end;local jY=[[<path class="txttick line" d="]]local jZ=bI(jU-(jT+10)-jU%5+0.5)for K=jZ+70,jZ,-5 do local hl=jX-(-K*5+jS*5)if K%10==0 then jV=10;local dy=K;if dy==360 then dy=0 elseif dy>360 then dy=dy-360 elseif dy<0 then dy=dy+360 end;jE[#jE+1]=gJ(hl,jW+15,dy,"txtmid bright")elseif K%5==0 then jV=5 end;if jV==10 then jY=df([[%s M %f %f v %d]],jY,hl,jW-5,jV)else jY=df([[%s M %f %f v %d]],jY,hl,jW-2.5,jV)end end;jE[#jE+1]=jY..[["/>]]jE[#jE+1]=df([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jX-5,jW-20,jX+5,jW-20,jX,jW-10)if I then if cT then jM="HDG"end;jE[#jE+1]=gJ(iT(960),iU(100),jU.."Â°","dim txt txtmid size14","")jE[#jE+1]=gJ(iT(960),iU(85),jM,"dim txt txtmid size20","")end;jE[#jE+1]=[[</g>]]end;local function j_(jE,k0,jL,ai,aj,cT,k1,fl)if ab==0 then return end;local jN=ab;local k2=bI(jN*3/5)if jN>0 then local k3=bI(k0)local jR=0;local jY=df([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jL,ai,aj)if not c9 then jY=df([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jE[#jE+1]=df([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jN-1,ai,aj)jE[#jE+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bI(k3-30-k3%5+0.5),bI(k3+30+k3%5+0.5),5 do if K%10==0 then jR=30 elseif K%5==0 then jR=20 end;local hm=aj+-K*5+k0*5;if jR==30 then jY=df([[%s M %d %f h %d]],jY,ai-k2-jR,hm,jR)if c9 then jE[#jE+1]=df([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jL,ai,aj,ai-k2+10,hm+4,K)jE[#jE+1]=df([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jL,ai,aj,ai+k2-10,hm+4,K)if K==0 or K==180 or K==-180 then jE[#jE+1]=df([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jL,ai,aj,ai-k2+20,hm,k2*2-40)end else jE[#jE+1]=gJ(ai-k2+10,hm,K,"pdim txt txtmid")jE[#jE+1]=gJ(ai+k2-10,hm,K,"pdim txt txtmid")end;jY=df([[%s M %d %f h %d]],jY,ai+k2,hm,jR)else jY=df([[%s M %d %f h %d]],jY,ai-k2-jR,hm,jR)jY=df([[%s M %d %f h %d]],jY,ai+k2,hm,jR)end end;jE[#jE+1]=jY..[["/>]]local k4="PITCH"if not cT then k4="REL PITCH"end;if k0>90 and not c9 then k0=90-(k0-90)elseif k0<-90 and not c9 then k0=-90-(k0+90)end;if jN>200 then if c9 then if fl>iE then jE[#jE+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jE[#jE+1]=gJ(ai,aj+20,k1,"pdim txt txtmid")end;jE[#jE+1]=df([[<g transform="rotate(%f,%d,%d)">]],-jL,ai,aj)else jE[#jE+1]=df([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jE[#jE+1]=df([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k2+25,aj-5,ai-k2+20,aj,ai-k2+25,aj+5,ai-k2+50,aj+4,k3)jE[#jE+1]=df([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k2-25,aj-5,ai+k2-20,aj,ai+k2-25,aj+5,ai+k2-30,aj+4,k3)jE[#jE+1]="</g>"end;local k5=bI(jN/3)jE[#jE+1]=df([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-k5,aj,jN-k5)if not c9 and cT then jE[#jE+1]=df([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jL,ai,aj,ai-k2+10,aj,k2*2-20)end;jE[#jE+1]="</g>"if jN<200 then if c9 and fl>iE then jE[#jE+1]=gJ(ai,aj-jN,k4,"pdim txt txtmid")jE[#jE+1]=gJ(ai,aj-jN+10,k3,"pdim txt txtmid")jE[#jE+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jE[#jE+1]=gJ(ai,aj+20,k1,"pdim txt txtmid")else jE[#jE+1]=gJ(ai,aj-jN,k4,"pdim txt txtmid")jE[#jE+1]=gJ(ai,aj-jN+15,k3,"pdim txt txtmid")end end end end;local function k6(jE,dZ,cT)local k7=ao;local k8=ap;if k7==0 and k8==0 then return end;local k9=78;local ka=19;local kb=c8;if c8~=-1 then jE[#jE+1]=gJ(k7+k9,k8+ka+20,df("AGL: %.1fm",c8),"pdim altsm txtend")end;if cT and(dZ<200000 and not c9 or dZ and c9)then table.insert(jE,df([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],k7-1,k8-4,k9+2,ka+6,k7+1,k8-1,k9-4,ka))local gs=0;local kc=1;local kd=0;local ke=dZ<0;local kf=dZ<kg.surfaceMaxAltitude;local kh=9;if ke then kh=0 end;local dZ=eU(dZ)while gs<6 do local ki=11;local kj=16;local kk=9;local kl=14;local jy="altsm"if gs>2 then kj=kj+3;ki=ki+2;kl=kl+2;kk=kk-6;jy="altbig"end;if ke then jy=jy.." red"elseif kf then jy=jy.." orange"end;local km=dZ/kc%10;local kn=bI(km)local ko=bI((kn+1)%10)local kp=kd;if gs==0 then kp=km-kn;if ke then kp=1-kp end end;if ke and(gs==0 or kd~=0)then local gv=ko;ko=kn;kn=gv end;local kq=kj*(kp-1)local kr=kq+kj;local hl=k7+kk+(6-gs)*ki;local hm=k8+kl;jE[#jE+1]=gJ(hl,hm+kq,ko,jy)jE[#jE+1]=gJ(hl,hm+kr,kn,jy)gs=gs+1;kc=kc*10;if kn==kh then kd=kp else kd=0 end end;table.insert(jE,[[</g></g>]])end end;local function ks(fq)local kt=-math.deg(eP(fq.y,fq.z))+180;kt=kt-90;if kt<0 then kt=360+kt end;if kt>180 then kt=-180+kt-180 end;return-kt end;local function ku(fq)local jS=math.deg(eP(fq.y,fq.x))-90;if jS<-180 then jS=360+jS end;return jS end;local function kv(jE,fq,fl,ai,aj)if fl>5 and not c9 or fl>iE then local jN=ab;local kw=20;local kx=20;local ky=ks(fq)local kz=ku(fq)local kA=14;local kB=kA/2;local kC=-kz/kx*jN;local kD=ky/kw*jN;local hl=ai+kC;local hm=aj+kD;local c4=di(kC^2+kD^2)local kE=[[<circle
                            cx="]]..hl..[["
                            cy="]]..hm..[["
                            r="]]..kB/kA..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hl..[["
                            cy="]]..hm..[["
                            r="]]..kB..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hl-kA..[[,]]..hm..[[ h ]]..kB..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hl+kB..[[,]]..hm..[[ h ]]..kB..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hl..[[,]]..hm-kA..[[ v ]]..kB..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c4<jN then jE[#jE+1]=kE else local jF=eP(kD,kC)local kF=4;local kG=ai+jN*math.cos(jF)local kH=aj+jN*math.sin(jF)jE[#jE+1]=df('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jF*180/math.pi,kG,kH,kG-kF,kH-kF/2,kF*2,kF,kG+kF,kH-kF,kF,kF,-kF,kF)end;if not c9 then local kI=vec3(fq)ky=ks(-kI)kz=ku(-kI)kC=-kz/kx*jN;kD=ky/kw*jN;hl=ai+kC;hm=aj+kD;c4=di(kC^2+kD^2)if c4<jN then local kJ=[[<circle
                                    cx="]]..hl..[["
                                    cy="]]..hm..[["
                                    r="]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hl..[[,]]..hm-kA..[[ v ]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hl..[[,]]..hm..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hl..[[,]]..hm..[[)" />
                                <path
                                    d="M ]]..hl-kB..[[,]]..hm..[[ h ]]..kA..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hl..[[,]]..hm..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hl..[[,]]..hm..[[)"/>]]jE[#jE+1]=kJ end end end end;local function kK(jE,iX,kL,kM)if ak==0 and al==0 then return end;kL=bI(kL+0.5)local jn=al+10;local jo=al+20;if ij()==1 and not l then jn=55;jo=65 end;local kN="CRUISE"local c="km/h"local dH=kM;if iX=="TRAVEL"or iX=="AUTOPILOT"then kN="THROT"c="%"dH=kL;local kO="dim"if kL<0 then kO="red"end;jE[#jE+1]=df([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kO,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eU(kL),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jE[#jE+1]=gJ(ak+10,jn,kN,"pbright txtstart")jE[#jE+1]=gJ(ak+10,jo,df("%.0f %s",dH,c),"pbright txtstart")if c9 and t and cM and bN then kL=bI(bO*100+0.5)local kO="red"if kL<0 then kO="red"end;jE[#jE+1]=df([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kO,1-eU(kL),ak-10,al+50,ak-15,al+53,ak-15,al+47)jE[#jE+1]=gJ(ak+10,jn+40,"LIMIT","pbright txtstart")jE[#jE+1]=gJ(ak+10,jo+40,kL.."%","pbright txtstart")end;if c9 and t or b6 then jE[#jE+1]=gJ(ak+10,jn-40,"LIMIT: "..cw.." km/h","dim txtstart")elseif not c9 and b1 then jE[#jE+1]=gJ(ak+10,jn-40,"LIMIT: "..bI(a8*3.6+0.5).." km/h","dim txtstart")end end;local function kP(jE,kQ)if ak==0 and al==0 then return end;local kR=al-10;local kS=ak+10;jE[#jE+1]=gJ(0,0,"","pdim txt txtend")if ij()==1 and not l then kR=75 end;jE[#jE+1]=gJ(kS,kR,bI(kQ).." km/h","pbright txtbig txtstart")end;local function kT(jE)jE[#jE+1]=gJ(iT(150),iU(1070),df("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jE[#jE+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jE[#jE+1]=gJ(iT(960),iU(550),"Warning: Invalid Control Scheme Detected","warnings")jE[#jE+1]=gJ(iT(960),iU(600),"Keyboard Scheme must be selected","warnings")jE[#jE+1]=gJ(iT(960),iU(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kU=iT(960)local kV=iU(860)local kW=iU(880)local kX=iU(900)local kY=iU(960)local kZ=iU(200)local k_=iU(250)local l0=iU(960)if ij()==1 and not l then kV=iU(135)kW=iU(155)kX=iU(175)kZ=iU(115)k_=iU(95)end;local l1="#222222"local l2="white"local l3="dimmer"local l4="pbright"local l5="#110000"local l6=l1;local l7=l3;if aZ then local l8=""if type(aZ)=="string"then l8="-"..aZ end;jE[#jE+1]=gJ(kU,kV,"Brake Engaged"..l8,"warnings")l5="#440000"l6=l2;l7=l4 elseif bM>0 then jE[#jE+1]=gJ(kU,kV,"Auto-Brake Engaged","warnings","opacity:"..bM)end;local l9="#110000"local la=l1;local lb=l3;if c9 and cv and c8==-1 then if not b1 and not bo and not b4 and not cL and not b7 and not b5 then jE[#jE+1]=gJ(kU,kZ+50,"** STALL WARNING **","warnings")l9="#ff0000"la=l2;lb=l4;fQ("stall","SW",2)end end;if cS then jE[#jE+1]=gJ(kU,kZ+90,"Flight Assist in Progress","warnings")end;if cd then jE[#jE+1]=gJ(kU,l0,"Gyro Enabled","warnings")end;local lc="#111100"local ld=l1;local le=l3;if bk then lc="#775500"ld=l2;le=l4;if bQ then jE[#jE+1]=gJ(kU,kW,"Gear Extended","warn")else jE[#jE+1]=gJ(kU,kW,"Landed (G: Takeoff)","warnings")end end;if c8>-1 and(not cL or cb<100)then local lf=ip(d:getTargetGroundAltitude())jE[#jE+1]=gJ(kU,kX,"Hover Height: "..lf,"warn")end;local lg="#000011"local lh=l1;local li=l3;if bZ then lg="#0000DD"lh=l2;li=l4;jE[#jE+1]=gJ(kU,kY+20,"ROCKET BOOST ENABLED","warn")end;local lj="#001100"local lk=l1;local ll=l3;if antigrav and not q and cL and bt~=nil then lj="#00DD00"lk=l2;ll=l4;local lm="warnings"if eU(cb-antigrav.getBaseAltitude())<501 then lm="warn"end;jE[#jE+1]=gJ(kU,kZ+40,df("Target Altitude: %d Singularity Altitude: %d",bI(bt),bI(antigrav.getBaseAltitude())),lm)end;if b1 and bh~="None"then jE[#jE+1]=gJ(kU,kZ,"Autopilot "..be,"warn")elseif br~=nil then jE[#jE+1]=gJ(kU,kZ+20,df("LockedPitch: %d",bI(br)),"warn")elseif bV then jE[#jE+1]=gJ(kU,kZ+20,"Follow Mode Engaged","warn")elseif b6 or c7 then jE[#jE+1]=gJ(kU,kZ+20,"Re-entry in Progress","warn")end;if b3 or b7 then local lf=ip(b8,2)if b7 then if cL then lf=ip(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jE[#jE+1]=gJ(kU,kZ,"VTO to "..lf,"warn")elseif b5 and not bx then if c6 then jE[#jE+1]=gJ(kU,kZ,"Takeoff to "..bh,"warn")else jE[#jE+1]=gJ(kU,kZ,"Takeoff to "..lf,"warn")end;if aZ and not b7 then jE[#jE+1]=gJ(kU,kZ+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jE[#jE+1]=gJ(kU,kZ,"Altitude Hold: "..df("%.1fm",b8),"warn")end end;if b7 and(antigrav~=nil and antigrav)then if ca>0.1 then jE[#jE+1]=gJ(kU,kZ+20,"Beginning ascent","warn")elseif ca<0.09 and ca>0.05 then jE[#jE+1]=gJ(kU,kZ+20,"Aligning trajectory","warn")elseif ca<0.05 then jE[#jE+1]=gJ(kU,kZ+20,"Leaving atmosphere","warn")end end;if bx then if cx~=nil then jE[#jE+1]=gJ(kU,kZ,cx,"warn")end end;if b4 then if ln then local lo="Brake Landing"if d7 then lo=lo.."-Aligning"end;if d6 then lo=lo.."-Drift Limited"end;jE[#jE+1]=gJ(kU,kZ,lo,"warnings")else jE[#jE+1]=gJ(kU,kZ,"Coast-Landing","warnings")end end;if b0 then jE[#jE+1]=gJ(kU,kZ,"Prograde Alignment","crit")end;if a_ then jE[#jE+1]=gJ(kU,kZ,"Retrograde Alignment","crit")end;local lp="#110000"local lq=l1;local lr=l3;if cU then lp="#FF0000"lq=l2;lr=l4;local type;if string.find(cU,"COLLISION")then type="warnings"else type="crit"end;jE[#jE+1]=gJ(kU,k_+20,cU,type)elseif ca==0 then local ls,lt=co.checkLOS(cF:normalize())if lt~=nil then lr=l4;lp="#FF0000"lq=l2;local lf=ip(lt)local lu=ck.computeTravelTime(cG,0,lt)local lv="Collision"if ls.noAtmosphericDensityAltitude>0 then lv="Atmosphere"end;jE[#jE+1]=gJ(kU,k_+20,ls.name.." "..lv.." "..iq(lu).." In "..lf,"crit")end end;if bo and not bx then jE[#jE+1]=gJ(kU,kZ+60,lw,"warn")end;local lx="#111100"local ly=l1;local lz=l3;if cY and#cY>1 then lx="#DDDD00"ly=l2;lz=l4 end;local lA=iT;local lB=iU;local l3="topButton"local lC="topButtonActive"local lD=l3;if b1 or bo or c6 or bx then lD=lC end;local lE=l3;if b0 then lE=lC end;local lF=l3;if b4 or bk then lF=lC end;local lG=l3;if b3 or bo then lG=lC end;local lH=l3;if a_ then lH=lC end;local lI=l3;if bx or cz and b1 then lI=lC end;if w and I then local lJ=lB(30)jE[#jE+1]=df([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lD,lA(960),lB(54),lB(-53),lA(-120),lA(25),lB(50))jE[#jE+1]=gJ(lA(910),lJ,"AUTOPILOT")jE[#jE+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,lA(865),lB(51),lA(-25),lB(-50),lA(-110),lA(25),lB(46))jE[#jE+1]=gJ(lA(800),lJ,"PROGRADE")jE[#jE+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lA(755),lB(47),lA(-25),lB(-46),lA(-98),lA(44),lB(44))jE[#jE+1]=gJ(lA(700),lJ,"LAND")jE[#jE+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lG,lA(960),lB(54),lB(-53),lA(120),lA(-25),lB(50))jE[#jE+1]=gJ(lA(1010),lJ,"ALT HOLD")jE[#jE+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,lA(1055),lB(51),lA(25),lB(-50),lA(110),lA(-25),lB(46))jE[#jE+1]=gJ(lA(1122),lJ,"RETROGRADE")jE[#jE+1]=df([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lI,lA(1165),lB(47),lA(25),lB(-46),lA(98),lA(-44),lB(44))jE[#jE+1]=gJ(lA(1220),lJ,"ORBIT")jE[#jE+1]=[[
                                    </g>
                                </g>]]jE[#jE+1]="</g>"end;return jE end;local function lK(fl)return bI(fR(fl*3.6,0)+0.5).." km/h"end;local function lL(gs)local gu=bh;if gs~=nil and type(gs)=="number"then if gs==0 then return"None"end;gu=cP[gs].name end;if gu==nil then gu=g1.name end;if gu==nil then gu="None"end;return gu end;local function lM(jE)local lN=co.routeWP(true)if not lN or#lN==0 then return end;local hl=iT(750)local hm=iU(360)if b1 or bo then jE[#jE+1]=gJ(hl,hm,"REMAINING ROUTE","pdim txtstart size20")else jE[#jE+1]=gJ(hl,hm,"LOADED ROUTE","pdim txtstart size20")end;for dG,K in pairs(lN)do hm=hm+20;jE[#jE+1]=gJ(hl,hm,dG..". "..lN[dG],"pdim txtstart size20")end end;local function lO(jE)local hl=ay+10;local hm=az+20;local lP={}local lQ={"Alt-4: AutoTakeoff to Target"}local lR={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lS={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lT={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lP,"--------------DYNAMIC-----------------")if c9 then if c8~=-1 then im(lP,lQ)if c1 and kg and c1.name==kg.name then table.insert(lP,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aY then if antigrav then if cL then table.insert(lP,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lP,"Turn on AGG to takeoff to AGG Height")end end;if aY then table.insert(lP,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lP,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lP,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bk then table.insert(lP,"G: Takeoff to hover height, raise gear")else table.insert(lP,"G: Lowergear and Land")end else im(lP,lR)table.insert(lP,"G: Begin BrakeLanding or Land")end;if b7 then table.insert(lP,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else im(lP,lS)if shield then table.insert(lP,"Alt-Shift-6: Vent shields")if not G then table.insert(lP,"Alt-Shift-7: Toggle shield off/on")end end end;if g1~=nil then table.insert(lP,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lP,"Alt-9: Activate Gyroscope")end;if aU~="none"or aT~="none"or aV~="none"then table.insert(lP,"Alt-Shift-9: Cycles engines with Extra tags")end;if b3 then table.insert(lP,"Alt-Spacebar/C will raise/lower target height")table.insert(lP,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c9 then table.insert(lP,"LALT+Mousewheel will lower/raise speed limit")end;im(lP,lT)for K=1,#lP do hm=hm+12;jE[#jE+1]=gJ(hl,hm,lP[K],"pdim txtbig txtstart")end end;local function lU(jE)local lV=ay;local lW=az;local lX=ax;local lY=4;local lZ=15;local hl=0;local hm=0;local l_,m0,m1,m2;local m3;local function m4(type)local gE,bK,fl,m5,jy,m6;if type=="Periapsis"then gE=m3.periapsis.altitude;bK=m3.timeToPeriapsis;fl=m3.periapsis.speed;jy="txtend"m5=12;m6=math.min(hl,lV+lX-kg.radius/m1-lY*2)else gE=m3.apoapsis.altitude;bK=m3.timeToApoapsis;fl=m3.apoapsis.speed;m5=-12;jy="txtstart"m6=hl end;if cG<1 then bK=0 end;jE[#jE+1]=df([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m6+m5,hm-5,hl,hm-5)jE[#jE+1]=df([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m6-m5*4,hm+2,hl,hm+2)jE[#jE+1]=gJ(m6,hm,type,jy)hl=m6-m5*2;hm=hm+lZ;local lf=ip(gE)jE[#jE+1]=gJ(hl,hm,lf,jy)hm=hm+lZ;jE[#jE+1]=gJ(hl,hm,iq(bK),jy)hm=hm+lZ;jE[#jE+1]=gJ(hl,hm,lK(fl),jy)end;local m7=lX*1.5;if bF=="INFO"then m7=25*9 end;if bF~="HIDE"then jE[#jE+1]=[[<g class="pbright txtorb txtmid">]]jE[#jE+1]=df('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lX*2,m7,lV,lW)jE[#jE+1]=df([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lX*2,m7,lV,lW)end;local m8=lX*1.5;local m9=lX*2;local ma=m8/2;local mb=lX;local mc=lV+mb;local md=lW+ma;local me=lV+m9;local mf=lW+m8;if bF=="ORBIT"then lW=lW+lY;l_=lX/2;m2=0;m3={}m3.periapsis={}m3.apoapsis={}if fp~=nil then if fp.periapsis~=nil then m3.periapsis.altitude=fp.periapsis.altitude;m3.periapsis.speed=fp.periapsis.speed end;if fp.apoapsis~=nil then m3.apoapsis.altitude=fp.apoapsis.altitude;m3.apoapsis.speed=fp.apoapsis.speed end;m3.period=fp.period;m3.eccentricity=fp.eccentricity;m3.timeToApoapsis=fp.timeToApoapsis;m3.timeToPeriapsis=fp.timeToPeriapsis;m3.eccentricAnomaly=fp.eccentricAnomaly;m3.trueAnomaly=fp.trueAnomaly end;if m3.periapsis==nil then m3.periapsis={}m3.periapsis.altitude=-kg.radius;m3.periapsis.speed=a8 end;if m3.eccentricity==nil then m3.eccentricity=1 end;if m3.apoapsis==nil then m3.apoapsis={}m3.apoapsis.altitude=cb;m3.apoapsis.speed=0 end;if cG<1 then m3.apoapsis.altitude=cb;m3.apoapsis.speed=0 end;if m3.apoapsis.altitude then m1=(m3.apoapsis.altitude+m3.periapsis.altitude+kg.radius*2)/(l_*2)m0=(kg.radius+m3.apoapsis.altitude)/m1*(1-m3.eccentricity)m2=l_-m3.periapsis.altitude/m1-kg.radius/m1;local mg=math.pi;if m3.period~=nil and m3.period>0 and m3.timeToApoapsis~=nil then mg=m3.eccentricAnomaly;if m3.timeToPeriapsis<m3.timeToApoapsis then mg=2*math.pi-mg end end;if cG<1 or mg~=mg then mg=math.pi end;local mh=-l_*math.cos(mg)+lV+mb+lY;local mi=m0*math.sin(mg)+lW+ma+lY;local mj=""jE[#jE+1]='<g clip-path="url(#orbitRect)">'jE[#jE+1]=df([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mj,lV+lX+lY,lW+lX*1.5/2+lY,l_,m0)if m0<1 then jE[#jE+1]=df([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lV+lX+lY-m2,lW+lX*1.5/2+lY,mh,mi)end;jE[#jE+1]=df('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lV+lX+lY-m2,lW+lX*1.5/2+lY,(kg.radius+kg.noAtmosphericDensityAltitude)/m1)jE[#jE+1]=df('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lV+lX+lY-m2,lW+lX*1.5/2+lY,(kg.radius+kg.noAtmosphericDensityAltitude)/m1)jE[#jE+1]=df([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lV+lX+lY,lW+lX*1.5/2+lY,l_,m0)jE[#jE+1]=df('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lV+lX+lY-m2,lW+lX*1.5/2+lY,kg.radius/m1)jE[#jE+1]='</g>'local mk=math.floor(kg.radius/m1+0.5)hl=lV+lX+lY*4+l_;hm=lW+lX*1.5/2+5+lY;if m3.apoapsis~=nil and m3.apoapsis.speed<a8 then m4("Apoapsis")end;hm=lW+lX*1.5/2+5+lY;hl=lV+lX-lY*2-l_;if m3.periapsis~=nil and m3.periapsis.speed<a8 and m3.periapsis.altitude>0 then m4("Periapsis")end;jE[#jE+1]=gJ(lV+lX+lY,lW+20+lY,kg.name,"txtorbbig")jE[#jE+1]=df('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mh,mi)jE[#jE+1]=[[</g>]]return jE else jE[#jE+1]='<g clip-path="url(#orbitRect)">'local ml=""local mm=1.2*(mn-mo)/(lX*2)local mp=1.4*(mq-mr)/(lX*1.5)for dG,ds in pairs(e[0])do if ds.center then local hl=lV+lX+ds.center.x/mm;local hm=lW+lX*1.5/2+ds.center.y/mp;ml=ml..'<circle cx="'..hl..'" cy="'..hm..'" r="'..ds.radius/mm*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(ds.name,"Moon")and not string.match(ds.name,"Sanctuary")and not string.match(ds.name,"Space")then ml=ml.."<text x='"..hl.."' y='"..hm+ds.radius/mm*30+20 .."' font-size='12' fill="..iL.." text-anchor='middle' font-family='Montserrat'>"..ds.name.."</text>"end end end;local fr=vec3(b.getConstructWorldPos())local hl=lV+lX+fr.x/mm;local hm=lW+lX*1.5/2+fr.y/mp;ml=ml..'<circle cx="'..hl..'" cy="'..hm..'" r="2" stroke="white" stroke-width="1" fill="red"/>'ml=ml.."<text x='"..hl.."' y='"..hm-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iy=mm;iz=mp;local ms=fr+cF*1000000;local mt=lV+lX+ms.x/mm;local jo=lW+lX*1.5/2+ms.y/mp;ml=ml..'<line x1="'..hl..'" y1="'..hm..'" x2="'..mt..'" y2="'..jo..'" stroke="purple" stroke-width="1"/>'jE[#jE+1]=ml;jE[#jE+1]='</g>'end elseif bF=="INFO"then jE=cm.DrawOdometer(jE,iN,bl,iO)elseif bF=="HELP"then jE=lO(jE)elseif bF=="SCOPE"then jE[#jE+1]='<g clip-path="url(#orbitRect)">'local mu=d0;if ca>0 then table.sort(c_,function(ev,ew)local ex,ey=ev.center,ew.center;return(ex.x-cJ.x)^2+(ex.y-cJ.y)^2+(ex.z-cJ.z)^2<(ey.x-cJ.x)^2+(ey.y-cJ.y)^2+(ey.z-cJ.z)^2 end)end;local mv={}local mw={}local mx=120;local my=nil;local mz=nil;for K,ds in ipairs(c_)do local gQ=ds.center-cJ;local mA=gQ:len()local mB=gQ:normalize()local mC=gQ:cross(cC):normalize()local mD=math.acos(mC:dot(cD))if mD~=mD then mD=0 end;if mC:cross(cD):dot(cC)<0 then mD=-mD end;local mE=gQ:project_on_plane(cC):len()local mF=math.sin(mD)*math.asin(mE/mA)*constants.rad2deg;local mG=math.cos(mD)*math.asin(mE/mA)*constants.rad2deg;if mB:dot(cC)<0 then mG=90*math.cos(mD)+90*math.cos(mD)-mG;mF=90*math.sin(mD)+90*math.sin(mD)-mF end;local hl=mc+mF/mu*m8;local hm=md+mG/mu*m8;local mH=(hl-mc)*(hl-mc)+(hm-md)*(hm-md)local mI=math.asin((ds.radius+ds.surfaceMaxAltitude)/mA)*constants.rad2deg;if mI~=mI then mI=mu end;local hG=mI/mu*m8;local mJ=math.asin(ds.atmosphereRadius/mA)*constants.rad2deg;if mJ~=mJ then mJ=mI end;local mK=mJ/mu*m8;local c4=ip(mA,1)local mL=ds.name;local mM=false;if hm>lW then if hm>mf then if hm-mK<=mf then mM=true end else mM=true end else if hm+mK>=lW then mM=true end end;local mN=false;local mO=hl;if ds.systemId==0 then mO=hl+mx else mO=hl-mx end;if mO+mx>lV then if mO+mx>me then if mO-mK-mx<=me then mN=true end else mN=true end else if mO+mK+mx>=lV then mN=true end end;local mP={}mP.x=hl;mP.y=hm;mP.planet=ds;mP.atmoSize=mK;if not my or mH<my then my=mH;mz=mP end;if mN and mM then local mQ=math.max(mK,5)if mH<mQ*mQ then mL=mL.." - "..c4 end;mP.size=hG;mP.i=K;mP.displayString=mL;mP.distance=c4;mP.visible=true;mw[#mw+1]=mP else mP.visible=false end end;local mR=false;table.sort(mw,function(ex,ey)return ex.y<ey.y end)for dG,fu in ipairs(mw)do local ds,hG,K,mK,hl,hm,mL,c4=fu.planet,fu.size,fu.i,fu.atmoSize,fu.x,fu.y,fu.displayString,fu.distance;local m6,mS,mT,mU;local mV=15;local jy="pdim"if ds.systemId~=0 then mT=iT(string.len(mL)*5)mV=-(15+mT)mU=iU(10)jy="pdimfill"else mT=iT(string.len(mL)*9)mU=iU(15)end;if hG*2>mT then m6=dg(hl,lV+mT/2,me-mT/2)mS=dg(hm,lW+mU,mf-5)m6=dg(m6,hl-hG+mT/2,hl+hG-mT/2)mS=dg(mS,hm-hG+mU,hm+hG)else m6=hl+mV;mS=hm end;for mW,fu in pairs(mv)do local mX=fu.textPositions;local mY=mX.y-mS;if mW~=K and eU(mY)<mX.height and mX.x+mX.width>m6 and mX.x<m6+mT then if hG>mT then mS=dg(mS+mU,lW+15,mf-5)else mS=mX.y+mX.height+1 end end end;local mZ=mL~=ds.name or m6<=mc and m6+mT>=mc and mS-mU<=md and mS>=md;fu.hovered=mZ;local m_=1;if mZ then m_=2;if hG*2<mT then m_=10 end;if mL==ds.name then mL=mL.." - "..c4 end;jy="pbright"if ds.systemId~=0 then mT=iT(string.len(mL)*5)mV=-(15+mT)else mT=iT(string.len(mL)*7)end;if hG*2>mT then m6=dg(hl,lV+mT/2,me-mT/2)m6=dg(m6,hl-hG+mT/2,hl+hG-mT/2)else m6=hl+mV end end;mv[K]={}mv[K].textPositions={}mv[K].textPositions.y=mS;mv[K].textPositions.x=m6;mv[K].textPositions.width=mT;mv[K].textPositions.height=mU;mv[K].output=""if hG*2>mT then jy=jy.." txtmid"else jy=jy.." txtstart"end;if mK-hG>2 then mv[K].output=df('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hl,hm,mK,iM,0.1*m_)end;mv[K].output=mv[K].output..df('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hl,hm,hG,iM,0.2*m_)if ds.systemId==0 then mv[K].output=mv[K].output..df([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m6,mS,iL,jy,mL)if hG*2<=mT then mv[K].output=mv[K].output..df("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m6+mT,mS+2,m6,mS+2,hl,hm)end else mv[K].output=mv[K].output..df([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m6,mS,iM,jy,mL)if hG*2<=mT then mv[K].output=mv[K].output..df("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m6,mS+2,m6+mT,mS+2,hl,hm)end end end;for dG=#c_,1,-1 do if mv[dG]then jE[#jE+1]=mv[dG].output end end;if mz~=nil and d0<90 and not mz.hovered then local n0=mz.planet.atmosphereRadius/mz.atmoSize;local n1=di(my)*n0;local n2=ip(n1,1)local mT=iT(math.max(string.len(n2)*7,string.len(mz.planet.name)*7))local mU=iU(12)local m6=dg(mz.x+(mc-mz.x)/2,lV+mT/2,me-mT/2)local mS=dg(mz.y+(md-mz.y)/2,lW+mU*2,mf-5)jE[#jE+1]=df("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mz.x,mz.y,mc,md)jE[#jE+1]=df([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m6,mS,"white",n2)if not mz.visible then jE[#jE+1]=df([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m6,mS-mU,"white",mz.planet.name)end end;if cG>1 then local gQ=cF;local mB=gQ:normalize()local mE=gQ:project_on_plane(cC):len()local mC=gQ:cross(cC):normalize()local mD=math.acos(mC:dot(cD))if mD~=mD then mD=0 end;if mC:cross(cD):dot(cC)<0 then mD=-mD end;local mF=math.sin(mD)*math.asin(mE/gQ:len())*constants.rad2deg;local mG=math.cos(mD)*math.asin(mE/gQ:len())*constants.rad2deg;if mB:dot(cC)<0 then mG=90*math.cos(mD)+90*math.cos(mD)-mG;mF=90*math.sin(mD)+90*math.sin(mD)-mF end;local hl=mc+mF/mu*m8;local hm=md+mG/mu*m8;local kA=14;local kB=kA/2;local kE=[[<circle
                                    cx="]]..hl..[["
                                    cy="]]..hm..[["
                                    r="]]..kB/kA..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hl..[["
                                    cy="]]..hm..[["
                                    r="]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hl-kA..[[,]]..hm..[[ h ]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hl+kB..[[,]]..hm..[[ h ]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hl..[[,]]..hm-kA..[[ v ]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jE[#jE+1]=kE end;jE[#jE+1]=df("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mc,md-10,mc,md+10)jE[#jE+1]=df("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mc-10,md,mc+10,md)jE[#jE+1]='</g>'else return jE end end;local function n3(n4,n5)local n6;local n7=(n5-n4):normalize()local fs=(cJ-n4):dot(n7)/n7:dot(n7)if fs<=0. then return(cJ-n4):len()elseif fs>=(n5-n4):len()then return(cJ-n5):len()end;local n8=n4+fs*n7;n6=(n8-cJ):len()return n6 end;local function n9()local n6;local na=nil;local nb=nil;local nc=nil;for dG,nd in pairs(e[0])do if nd.hasAtmosphere then local c4=n3(kg.center,nd.center)if na==nil or c4<na then nb=nd;na=c4;nc=kg end;if c1 and c1.hasAtmosphere and c1.name~=kg.name then local eK=n3(c1.center,nd.center)if eK<na then nb=nd;na=eK;nc=c1 end end end end;local ne=iT(1770)local nf=iU(330)if na then local ng="txttick "local nh=500000;if na<nb.radius+nh or na<nc.radius+nh then if cQ then ng="txttick red "else ng="txttick orange "end end;n6=ip(na,2)iD=gJ(ne,nf,"Pipe ("..nc.name.."--"..nb.name.."): "..n6,ng.."pbright txtmid")end end;local function ni(hl,hm,nj,nk,kN)local nl={x=hl,y=hm,width=nj,height=nk,label=kN}ix[kN]=nl;return nl end;local function nm(nn,no,nj,nk,hl,hm,np,nq,nr,ns,jy)local nl={enableName=nn,disableName=no,width=nj,height=nk,x=hl,y=hm,toggleVar=np,toggleFunction=nq,drawCondition=nr,hovered=false,class=jy}if ns then table.insert(iw,nl)else table.insert(iv,nl)end;return nl end;local function nt(nu)if not iB then nv=false;nw=false;nx=false;w=true;return elseif nu=="handling"then nv=not nv;nw=false;nx=false elseif nu=="hud"then nw=not nw;nv=false;nx=false elseif nu=="physics"then nx=not nx;nv=false;nw=false end;if nx or nw or nv then iC=io(nu)w=false else iC="none"w=true end end;local function ny()iB=not iB;if iB then iu=iw;bX="Hold SHIFT to see Settings"d1=w else iu=iv;bX="Hold SHIFT to see Control Buttons"nt()w=d1 end end;local function nz()local function nA(ds,dG)ds.set(not ds.get())if ds.get()then bX=dG.." set to true"else bX=dG.." set to false"end;if dG=="showHud"then d1=ds.get()elseif dG=="BrakeToggleDefault"then aX=j end end;local nB=50;local nC=340;local hl=500;local hm=cf/2-400;local nD=0;for dG,ds in pairs(io("boolean"))do if type(ds.get())=="boolean"then nm(dG,dG,nC,nB,hl,hm,function()return ds.get()end,function()nA(ds,dG)end,function()return true end,true)hm=hm+nB+20;if nD==9 then hl=hl+nC+20;hm=cf/2-400;nD=0 else nD=nD+1 end end end;nm("Control View","Control View",nC,nB,10,cf/2-500,function()return true end,ny,function()return true end,true)nm("View Handling Settings",'Hide Handling Settings',nC,nB,10,cf/2-(500-nB),function()return nv end,function()nt("handling")end,function()return true end,true)nm("View Hud Settings",'Hide Hud Settings',nC,nB,10,cf/2-(500-nB*2),function()return nw end,function()nt("hud")end,function()return true end,true)nm("View Physics Settings",'Hide Physics Settings',nC,nB,10,cf/2-(500-nB*3),function()return nx end,function()nt("physics")end,function()return true end,true)end;local function nE()local function gt()local fT=cJ;local gu=kg.name..". "..#bn;if cp then gu=cp.GetClosestName(gu)end;return cn.AddNewLocation(gu,fT,false,true)end;local function nF()b2=not b2 end;local function nG(nH)if nH==1 then b0=not b0;a_=false else a_=not a_;b0=false end;b1=false;b3=false;bV=false;b4=false;br=nil;b6=false;b5=false end;local function nI(nJ,nK)cn.UpdatePosition(nil,nJ,nK)end;local function go()cn.ClearCurrentPosition()end;local function nL(gs)local lN=co.routeWP(true)if lN and#lN>0 then return"Engage Route: "..lN[1]end;return"Engage Autopilot: "..lL(gs)end;local function nM(gs)local lN=co.routeWP(true)if lN and#lN>0 then return"Next Route Point: "..lN[1]end;return"Disable Autopilot: "..lL(gs)end;local function nN()if ij()==1 then bV=not bV;if bV then b1=false;a_=false;b0=false;b3=false;b6=false;b4=false;b5=false;nO=bk;bk=false;d.control.retractLandingGears()ik:setTargetGroundAltitude(X)fQ("folOn","F")else fQ("folOff","F")aZ="Follow Off"cu=p;bk=nO;if bk then d.control.extendLandingGears()ik:setTargetGroundAltitude(Y)end end else bX="Follow Mode only works with Remote controller"bV=false end end;local nB=50;local nC=260;local nP=iT(30)local nQ=ay+ax*2+2;local nR=az+1;nm("+","+",nP,nP,nQ,nR+nP+1,function()return false end,function()d0=d0/8 end,function()return bF=="SCOPE"end,nil,"ZoomButton")nm("-","-",nP,nP,nQ,nR,function()return false end,function()d0=math.min(d0*8,90)end,function()return bF=="SCOPE"end,nil,"ZoomButton")nm("0","0",nP,nP,nQ,nR+nP*2+2,function()return false end,function()d0=90 end,function()return bF=="SCOPE"and d0~=90 end,nil,"ZoomButton")local nS=nm("Enable Brake Toggle","Disable Brake Toggle",nC,nB,ce/2-nC/2,cf/2+350,function()return aX end,function()aX=not aX;if aX then bX="Brakes in Toggle Mode"else bX="Brakes in Default Mode"end end)nm("Align Prograde","Disable Prograde",nC,nB,ce/2-nC/2-50-nS.width,cf/2-nB+380,function()return b0 end,function()nG(1)end)nm("Align Retrograde","Disable Retrograde",nC,nB,ce/2-nC/2+nS.width+50,cf/2-nB+380,function()return a_ end,nG,function()return ca==0 end)nT=nm(nL,nM,600,60,ce/2-600/2,cf/2-60/2-330,function()return b1 or bo or c6 or bx end,function()end)local K;local function nU(nV)local gs=cX+nV;if gs>#cP then gs=gs-#cP-1 end;if gs<0 then gs=#cP+gs end;return gs end;nW={}for K=0,10 do local nX=nm(function(ey)local gs=nU(ey.apExtraIndex)if b1 or bo or c6 or bx then return"Redirect: "..lL(gs)end;return nL(gs)end,function(ey)local gs=nU(ey.apExtraIndex)return nM(gs)end,600,60,ce/2-600/2,cf/2-60/2-330+60*K,function(ey)local gs=nU(ey.apExtraIndex)return gs==bj and(b1 or bo or c6 or bx)end,function(ey)local gs=nU(ey.apExtraIndex)local nY=bj==gs;bj=gs;cn.UpdateAutopilotTarget()co.ToggleAutopilot()if not nY and not(b1 or bo or c6 or bx)then co.ToggleAutopilot()end end,function()return cW and(#co.routeWP(true)==0 or K==0)end)nX.apExtraIndex=K;nW[K]=nX end;nm("Save Position","Save Position",200,nT.height,nT.x+nT.width+30,nT.y,function()return false end,gt,function()return bj==0 or g1==nil end)nm("Update Position","Update Position",200,nT.height,nT.x+nT.width+30,nT.y,function()return false end,function()nI(nil)end,function()return bj>0 and g1~=nil end)nm("Save Heading","Clear Heading",200,nT.height,nT.x+nT.width+30,nT.y+nT.height+20,function()return g1.heading~=nil end,function()if g1.heading~=nil then nI(false)else nI(true)end end,function()return bj>0 and g1~=nil end)nm("Save AGG Alt","Clear AGG Alt",200,nT.height,nT.x+nT.width+30,nT.y+nT.height*2+40,function()return g1.agg~=nil end,function()if g1.agg~=nil then nI(nil,false)else nI(nil,true)end end,function()return bj>0 and g1~=nil and antigrav end)nm("Clear Position","Clear Position",200,nT.height,nT.x-200-30,nT.y,function()return true end,go,function()return bj>0 and g1~=nil end)nm("Save Route","Save Route",200,nT.height,nT.x-200-30,nT.y+nT.height*2+40,function()return false end,function()co.routeWP(false,false,2)end,function()return#co.routeWP(true)>0 end)nm("Load Route","Clear Route",200,nT.height,nT.x-200-30,nT.y+nT.height+20,function()return#co.routeWP(true)>0 end,function()if#co.routeWP(true)>0 then co.routeWP(false,true)elseif b1 or bo then bX="Disable Autopilot before loading route"return else co.routeWP(false,false,1)end end,function()return true end)nB=60;nC=300;local hl=0;local hm=cf/2-150;nm("Enable Check Damage","Disable Check Damage",nC,nB,hl,hm-nB-20,function()return s end,function()s=not s end)nm("View Settings","View Settings",nC,nB,hl,hm,function()return true end,ny)hm=hm+nB+20;nm("Enable Turn and Burn","Disable Turn and Burn",nC,nB,hl,hm,function()return b2 end,nF)hl=10;hm=cf/2-300;nm("Horizontal Takeoff Mode","Vertical Takeoff Mode",nC,nB,hl+nC+20,hm,function()return aY end,function()aY=not aY;if aY then bX="Vertical Takeoff Mode"else bX="Horizontal Takeoff Mode"end end,function()return cK end)hm=hm+nB+20;nm("Engage Orbiting","Cancel Orbiting",nC,nB,hl+nC+20,hm,function()return bx end,co.ToggleIntoOrbit,function()return ca==0 and cT end)hm=cf/2-150;nm("Glide Re-Entry","Cancel Glide Re-Entry",nC,nB,hl+nC+20,hm,function()return b6 end,function()c5=1;nG(1)end,function()return kg.hasAtmosphere and not c9 end)hm=hm+nB+20;nm("Parachute Re-Entry","Cancel Parachute Re-Entry",nC,nB,hl+nC+20,hm,function()return b6 end,function()c5=2;nG(1)end,function()return kg.hasAtmosphere and not c9 end)hm=hm+nB+20;nm("Engage Follow Mode","Disable Follow Mode",nC,nB,hl,hm,function()return bV end,nN,function()return ij()==1 end)nm("Enable Repair Arrows","Disable Repair Arrows",nC,nB,hl+nC+20,hm,function()return iR end,function()iR=not iR;if iR then bX="Repair Arrows Enabled"else bX="Repair Arrows Diabled"end end,function()return ij()==1 end)hm=hm+nB+20;if not q then nm("Enable AGG","Disable AGG",nC,nB,hl,hm,function()return cL end,co.ToggleAntigrav,function()return antigrav~=nil end)end;nm(function()return df("Switch IPH Mode - Current: %s",by)end,function()return df("IPH Mode: %s",by)end,nC*2,nB,hl,hm,function()return false end,function()if by=="All"then by="Custom Only"elseif by=="Custom Only"then by="No Moons"else by="All"end;bX="IPH Mode: "..by end)hm=hm+nB+20;nm(function()return df("Toggle Control Scheme - Current: %s",g)end,function()return df("Control Scheme: %s",g)end,nC*2,nB,hl,hm,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bX="New Control Scheme: "..g end)local nZ=iU(20)local nX=ni(0,0,iT(70),nZ,"HELP")nX=ni(nX.x+nX.width,nX.y,iT(80),nZ,"INFO")nX=ni(nX.x+nX.width,nX.y,iT(70),nZ,"ORBIT")nX=ni(nX.x+nX.width,nX.y,iT(70),nZ,"SCOPE")ni(nX.x+nX.width,nX.y,iT(70),nZ,"HIDE")end;local n_={}local o0=nil;function n_.HUDPrologue(jE)if not cQ then iI=af;iJ=ag;iK=ah else iI=ac;iJ=ad;iK=ae end;iL=[[rgb(]]..bI(iI+0.6)..","..bI(iJ+0.6)..","..bI(iK+0.6)..[[)]]iM=[[rgb(]]..bI(iI*0.8+0.5)..","..bI(iJ*0.8+0.5)..","..bI(iK*0.8+0.5)..[[)]]local o1=iL;local o2=iM;local o3=[[rgb(]]..bI(iI*0.4+0.5)..","..bI(iJ*0.4+0.5)..","..bI(iK*0.4+0.5)..[[)]]local o4=iL;local o5=iM;local o6=o3;if iV()and not m then o1=[[rgb(]]..bI(iI*0.5+0.5)..","..bI(iJ*0.5+0.5)..","..bI(iK*0.5+0.5)..[[)]]o2=[[rgb(]]..bI(iI*0.3+0.5)..","..bI(iJ*0.3+0.5)..","..bI(iK*0.2+0.5)..[[)]]o3=[[rgb(]]..bI(iI*0.2+0.5)..","..bI(iJ*0.2+0.5)..","..bI(iK*0.2+0.5)..[[)]]end;local lA=iT;local lB=iU;jE[#jE+1]=df([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o1,o1,o1,o4,o4,o2,o2,o5,o5,o2,o1,o3,o5,o1,o1,o3,o3,o6,o3,ce,cf,o2,o2,o2,o2,o2,o4,o2,o5,o6,o5,o5,o6)if not o0 then o0=df([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lA(630),lB(0),lA(675),lB(45),lA(960),lB(55),lA(1245),lB(45),lA(1290),lB(0),lA(1000),lB(105),lA(1040),lB(59),lA(1250),lB(51),lA(1300),lB(0),lA(1920),lB(0),lA(1920),lB(20),lA(1400),lB(20),lA(1300),lB(105),lA(920),lB(105),lA(880),lB(59),lA(670),lB(51),lA(620),lB(0),lA(0),lB(0),lA(0),lB(20),lA(520),lB(20),lA(620),lB(105),lA(890),lB(59),lA(960),lB(62),lA(1030),lB(59),lA(985),lB(112),lA(1150),lB(112),lA(1100),lB(152),lA(820),lB(152),lA(780),lB(112),lA(935),lB(112),lA(890),lB(59),lA(960),lB(62),lA(1030),lB(59),lA(985),lB(112),lA(1150),lB(112),lA(1100),lB(152),lA(820),lB(152),lA(780),lB(112),lA(935),lB(112))end;if w and I then jE[#jE+1]=o0 end;return jE end;function n_.DrawVerticalSpeed(jE,dZ)jD(jE,dZ)end;function n_.UpdateHud(jE)local kt=cN;local o7=cO;local jL=o7;local k0=kt;local kL=bI(c.getThrottle())local kQ=cG*3.6;local kM=c.getAxisCommandValue(0)local o8=iT(1770)local o9=iU(310)if t and cM then kM=bL;kL=bL*100 end;local iX=iW()local jM="ROLL"if kL==nil then kL=0 end;if not cT then if cG>5 then kt=ks(cE)o7=ku(cE)else kt=0;o7=0 end;jM="YAW"end;if cR>50000 and not c9 then local oa;oa=ip(cR)jE[#jE+1]=gJ(o8,o9,"PvP Boundary: "..oa,"pbright txtbig txtmid")end;jE[#jE+1]=iP;jE[#jE+1]=hW;if iD~=""then jE[#jE+1]=iD end;if iY~=""then jE[#jE+1]=iY end;if iZ~=""then jE[#jE+1]=iZ end;jD(jE,cb)if ij()==0 or l then if not iV()or m then if cT then jK(jE,ai,aj,jL,jM,cT)j_(jE,k0,jL,ai,aj,cT,bI(ku(cE)),cG)else jK(jE,ai,aj,o7,jM,cT)j_(jE,kt,o7,ai,aj,cT,bI(o7),cG)end;k6(jE,cb,cT)kv(jE,cE,cG,ai,aj)end end;kK(jE,iX,kL,kM)kP(jE,kQ)kT(jE)lU(jE)if not iB and bW then lM(jE)end;return jE end;function n_.HUDEpilogue(jE)jE[#jE+1]="</svg>"return jE end;function n_.ExtraData(jE)local ob=iT(1240)local oc=iU(55)local od=oc+10;local oe;local lA=iT;local lB=iU;local of=0;local iX=iW()if aY then iX=iX.."-VERTICAL"end;if E and not b5 and not b4 and cG>20 then iX=iX.."-COLLISION ON"end;if bA~="Off"then iX="("..bA..")-"..iX end;if b2 then iX="TB-"..iX end;if not bz then iX=iX.."-DeCoupled"end;local og=lB(99)local oh=lB(80)local oi=lB(85)local oj=lB(31)local ok=0;local ol=0;local om=cc>1000000 and fR(cc/1000000,2).."kT"or fR(cc/1000,2).."T"if c9 then of=bs else of=bq end;local on,oo=ck.computeDistanceAndTime(cG,0,cc,0,0,of)if on<0 then on=0 end;of=fR(of/(cc*it),2).."g"local op=d:maxForceForward()oe=b.g()if oe>0.1 then ol=cc*oe;ol=fR(ol/(cc*it),2).."g"ok=0.5*op/oe;ok=ok>1000000 and fR(ok/1000000,2).."kT"or fR(ok/1000,2).."T"end;op=fR(op/(cc*it),2).."g"local oq=vec3(b.getWorldAcceleration()):len()/9.80665;oe=b.g()jE[#jE+1]=[[<g class="dim txt txtend size14">]]if ij()==1 and not l then ob=iT(1120)oc=iU(55)od=oc+10 elseif c9 and I then local os=iT(770)jE[#jE+1]=gJ(lA(895),og,"ATMO","")jE[#jE+1]=df([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lA(895),oi,lA(-80))jE[#jE+1]=gJ(lA(815),oh,df("%.1f%%",ca*100),"txtstart size20")end;if I then jE[#jE+1]=gJ(lA(1025),og,"GRAVITY","txtstart")jE[#jE+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1025),oi,lA(80))jE[#jE+1]=gJ(lA(1105),oh,df("%.2fg",oe/9.80665),"size20")jE[#jE+1]=gJ(lA(1125),og,"ACCEL","txtstart")jE[#jE+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1125),oi,lA(80))jE[#jE+1]=gJ(lA(1205),oh,df("%.2fg",oq),"size20")jE[#jE+1]=gJ(lA(695),og,"BRK TIME","")jE[#jE+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(695),oi,lA(-80))jE[#jE+1]=gJ(lA(615),oh,df("%s",iq(oo)),"txtstart size20")jE[#jE+1]=gJ(lA(635),lB(45),"TRIP","")jE[#jE+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(635),lB(31),lA(-90))if lu then jE[#jE+1]=gJ(lA(545),lB(26),df("%s",iq(lu)),"txtstart size20")end;jE[#jE+1]=gJ(lA(795),og,"BRK DIST","")jE[#jE+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(795),oi,lA(-80))jE[#jE+1]=gJ(lA(715),oh,df("%s",ip(on)),"txtstart size20")jE[#jE+1]=gJ(lA(1285),lB(45),"MASS","txtstart")jE[#jE+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1285),lB(31),lA(90))jE[#jE+1]=gJ(lA(1375),lB(26),df("%s",om),"size20")jE[#jE+1]=gJ(lA(1220),og,"THRUST","txtstart")jE[#jE+1]=df([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1220),oi,lA(80))jE[#jE+1]=gJ(lA(1300),oh,df("%s",op),"size20")jE[#jE+1]=gJ(iT(960),iU(175),iX,"pbright txtbig txtmid size20")end;jE[#jE+1]="</g>"end;local ot=1-(a4*0.05+a5*0.05)function n_.FuelUsed(ou)local ov;if ou=="atmofueltank"then ov=df("Atmo Fuel Used: %.1f L",jf[ou]/(4*ot))elseif ou=="spacefueltank"then ov=df("Space Fuel Used: %.1f L",jf[ou]/(6*ot))else ov=df("Rocket Fuel Used: %.1f L",jf[ou]/(0.8*ot))end;return ov end;function n_.DrawOdometer(jE,iN,bl,iO)if bF~="INFO"then return jE end;local oe;local ok=0;local ol=0;local of=0;local om=cc>1000000 and fR(cc/1000000,2).." kTons"or fR(cc/1000,2).." Tons"if c9 then of=bs else of=bq end;local on,oo=ck.computeDistanceAndTime(cG,0,cc,0,0,of)of=fR(of/(cc*it),2).." g"local op=d:maxForceForward()oe=b.g()if oe>0.1 then ol=cc*oe;ol=fR(ol/(cc*it),2).." g"ok=0.5*op/oe;ok=ok>1000000 and fR(ok/1000000,2).." kTons"or fR(ok/1000,2).." Tons"end;op=fR(op/(cc*it),2).." g"if ij()==0 or l then local ow=iT(ay+10)local ox=iU(az+20)local oy=iT(ay+10+ax/1.25)local nk=25;jE[#jE+1]="<g class='txtstart size14 bright'>"jE[#jE+1]=gJ(ow,ox,df("BrkTime: %s",iq(oo)))jE[#jE+1]=gJ(oy,ox,df("Trip: %.2f km",iN))jE[#jE+1]=gJ(ow,ox+nk,df("Lifetime: %.2f kSU",bl/200000))jE[#jE+1]=gJ(oy,ox+nk,df("BrkDist: %s",ip(on)))jE[#jE+1]=gJ(ow,ox+nk*2,"Trip Time: "..iq(iO))jE[#jE+1]=gJ(oy,ox+nk*2,"Total Time: "..iq(bm))jE[#jE+1]=gJ(ow,ox+nk*3,df("Mass: %s",om))jE[#jE+1]=gJ(oy,ox+nk*3,df("Max Brake: %s",of))jE[#jE+1]=gJ(ow,ox+nk*4,df("Max Thrust: %s",op))if oe>0.1 then jE[#jE+1]=gJ(oy,ox+nk*4,df("Max Thrust Mass: %s",ok))jE[#jE+1]=gJ(ow,ox+nk*5,df("Req Thrust: %s",ol))else jE[#jE+1]=gJ(oy,ox+nk*4,"Max Mass: n/a")jE[#jE+1]=gJ(ow,ox+nk*5,"Req Thrust: n/a")end;jE[#jE+1]=gJ(oy,ox+nk*5,cm.FuelUsed("atmofueltank"))jE[#jE+1]=gJ(ow,ox+nk*6,cm.FuelUsed("spacefueltank"))jE[#jE+1]=gJ(oy,ox+nk*6,cm.FuelUsed("rocketfueltank"))jE[#jE+1]=gJ(ow,ox+nk*7,df("Set Max Speed: %s",bI(a8*3.6+0.5)))jE[#jE+1]=gJ(oy,ox+nk*7,df("Actual Max Speed: %s",bI(da*3.6+0.5)))end;jE[#jE+1]="</g></g>"return jE end;function n_.DrawWarnings(jE)return kT(jE)end;function n_.DisplayOrbitScreen(jE)return lU(jE)end;function n_.DisplayMessage(jE,lf)if lf~="empty"then local hm=310;for lo in string.gmatch(lf,"([^\n]+)")do hm=hm+35;jE[#jE+1]=gJ("50%",hm,lo,"msg")end end;if bY~=0 then c.setTimer("msgTick",bY)bY=0 end end;function n_.DrawDeadZone(jE)jE[#jE+1]=df([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aw)end;function n_.UpdatePipe()if c9 then iD=""return end;n9()end;function n_.DrawSettings(jE)local hl=iT(640)local hm=iU(200)jE[#jE+1]=[[<g class="pbright txtvspd txtstart">]]local hD=0;for dG,ds in pairs(iC)do hD=hD+1;jE[#jE+1]=gJ(hl,hm,dG..": "..ds.get())hm=hm+20;if hD%12==0 then hl=hl+iT(350)hm=iU(200)end end;jE[#jE+1]=gJ(iT(640),iU(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jE[#jE+1]="</g>"return jE end;local hU=iU(15)local hT=iT(1370)local dd,oz;function n_.DrawRadarInfo()hW=cp.GetRadarHud(hT,hU,au,av)end;function n_.DrawTanks()if aq~=0 and ar~=0 then iY=gJ(aq,ar,"","txtstart pdim txtfuel")jg=ar;jh(aq,"Atmospheric ","ATMO",cg,jd,je)jh(aq,"Space Fuel T","SPACE",ch,jb,jc)jh(aq,"Rocket Fuel ","ROCKET",ci,j9,ja)end end;function n_.DrawShield()local i2=shield.getState()==1 and"Shield Active"or"Shield Disabled"local oA=b.getPvPTimer()local oB=shield.getResistances()local oC="A: "..10+oB[1]*100 .."% / E: "..10+oB[2]*100 .."% / K:"..10+oB[3]*100 .."% / T: "..10+oB[4]*100 .."%"local hl,hm=as-60,at+30;local jw=bI(db*2.55)local jx=df("rgb(%d,%d,%d)",255-jw,jw,0)local jy=""iZ=gJ(hl,hm,"","txtmid pdim txtfuel")if db<10 and i2~="Shield Disabled"then jy="red "end;oA=oA>0 and"   PvPTime: "..iq(oA)or""iZ=iZ..df([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hl,hm,jx,db*2,hl,hm,hl+2,hm+10,db,oA)iZ=iZ..gJ(hl,hm-5,i2,jy.."txtstart pbright txtbig")iZ=iZ..gJ(hl,hm+30,oC,jy.."txtstart pbright txtsmall")end;function n_.hudtick()if not kg then return end;local function oD(jE)local jA=bI(dg(d8/(ce/4)*255,0,255))jE[#jE+1]=df("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c2,c3,bI(iI+0.5)+jA,bI(iJ+0.5)-jA,bI(iK+0.5)-jA)end;local function oE()for dL,ds in pairs(iu)do if ds.hovered then if not ds.drawCondition or ds.drawCondition(ds)then ds.toggleFunction(ds)end;ds.hovered=false end end;for dL,ds in pairs(ix)do if ds.hovered then bF=ds.label;ds.hovered=false end end end;local function oF()local function oG(oH,oI,hl,hm,nj,nk)if oH>=hl and oH<=hl+nj and oI>=hm and oI<=hm+nk then return true else return false end end;local hl=c2+ce/2;local hm=c3+cf/2;for dL,ds in pairs(iu)do ds.hovered=oG(hl,hm,ds.x,ds.y,ds.width,ds.height)end;for dL,ds in pairs(ix)do ds.hovered=oG(hl,hm,ds.x,ds.y,ds.width,ds.height)end;if cW then local mZ=false;for dL,ey in ipairs(nW)do if ey.hovered then mZ=true;break end end;if nT.hovered then mZ=true end;cW=mZ else cW=nT.hovered;if not cW then cX=bj end end end;local function oJ(jE)if not bF or bF==""then bF="HELP"end;if w then for dG,ds in pairs(ix)do local jy="dim brightstroke"local oK=0.2;if bF==dG then jy="pbright dimstroke"oK=0.6 end;local oL=""if ds.hovered then oK=0.8;oL=";stroke:white"end;jE[#jE+1]=df([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],ds.width,ds.height,ds.x,ds.y,jy,oK,oL)jE[#jE+1]=gJ(ds.x+ds.width/2,ds.y+ds.height/2+5,ds.label,"txt txtmid pdim")end end end;local function oM(jE)local function oN(jE,oO,hover,hl,hm,fe,oP,oQ,oR,oS,oT,nX)if type(oS)=="function"then oS=oS(nX)end;if type(oT)=="function"then oT=oT(nX)end;jE[#jE+1]=df("<rect x='%f' y='%f' width='%f' height='%f' fill='",hl,hm,fe,oP)if oO then jE[#jE+1]=df("%s'",oQ)else jE[#jE+1]=oR end;if hover then jE[#jE+1]=df(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jE[#jE+1]=df(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fR(ac*0.5,0),fR(ad*0.5,0),fR(ae*0.5,0))end;jE[#jE+1]=" rx='5'></rect>"jE[#jE+1]=df("<text x='%f' y='%f' font-size='24' fill='",hl+fe/2,hm+oP/2+5)if oO then jE[#jE+1]="black"else jE[#jE+1]="white"end;jE[#jE+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oO then jE[#jE+1]=df("%s</text>",oS)else jE[#jE+1]=df("%s</text>",oT)end end;local oU=df("rgb(%d,%d,%d)'",fR(ac*0.1,0),fR(ad*0.1,0),fR(ae*0.1,0))local oV=df("rgb(%d,%d,%d)",fR(ac*0.8,0),fR(ad*0.8,0),fR(ae*0.8,0))local oW=oN;for dL,ds in pairs(iu)do local no=ds.disableName;local nn=ds.enableName;if type(no)=="function"then no=no(ds)end;if type(nn)=="function"then nn=nn(ds)end;if not ds.drawCondition or ds.drawCondition(ds)then oW(jE,ds.toggleVar(ds),ds.hovered,ds.x,ds.y,ds.width,ds.height,oV,oU,no,nn,ds)end end end;local oX=fR(ce/2,0)local oY=fR(cf/2,0)local jE={}if oZ then jE[#jE+1]=oZ end;cm.HUDPrologue(jE)if w then cm.UpdateHud(jE)else if A then cm.DrawVerticalSpeed(jE,cb)end;cm.DrawWarnings(jE)end;if iB and iC~="none"then cm.DrawSettings(jE)end;if cp then cm.DrawRadarInfo()end;cm.HUDEpilogue(jE)jE[#jE+1]=df([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ce,cf)if bX~="empty"then cm.DisplayMessage(jE,bX)end;if ij()==0 and g=="virtual joystick"then if v then cm.DrawDeadZone(jE)end end;oJ(jE)if il()==0 then if ij()==1 and bW then if not o_ then oF()oM(jE)end;if not cs and not ct then local p0=table.concat(jE,"")jE={}jE[#jE+1]=df("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jE[#jE+1]=p0;jE[#jE+1]="</body>"cs=true;jE[#jE+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif ct then local p0=table.concat(jE,"")jE={}jE[#jE+1]=df("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jE[#jE+1]=p0;jE[#jE+1]="</body>"end;if not cs then jE[#jE+1]=df([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oX,oY,c2,c3)end else oE()end else if not bW and ij()==0 then oE()if d8>aw then if v then oD(jE)end end elseif bW and(not o_ or not i)then oF()oM(jE)end;jE[#jE+1]=df([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oX,oY,c2,c3)end;jE[#jE+1]=[[</svg></body>]]p1=table.concat(jE,"")end;function n_.TenthTick()local function p2()local p3=a.createData;local p4=a.createWidget;p5=a.createWidgetPanel("Interplanetary Helper")p6=p4(p5,"value")p7=p3('{"label": "Target Planet", "value": "N/A", "unit":""}')fP(p7,p6)p8=p4(p5,"value")p9=p3('{"label": "distance", "value": "N/A", "unit":""}')fP(p9,p8)gi=p4(p5,"value")gh=p3('{"label": "Travel Time", "value": "N/A", "unit":""}')fP(gh,gi)gg=p4(p5,"value")gf=p3('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fP(gf,gg)gk=p4(p5,"value")gj=p3('{"label": "Target Altitude", "value": "N/A", "unit":""}')fP(gj,gk)gc=p4(p5,"value")gb=p3('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ga=p4(p5,"value")g9=p3('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g8=p4(p5,"value")g7=p3('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g6=p4(p5,"value")g5=p3('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ge=p4(p5,"value")gd=p3('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c9 then fP(gb,gc)fP(g9,ga)fP(g7,g8)fP(g5,g6)fP(gd,ge)end end;local function pa()gI(p5)p5=nil end;cm.DrawTanks()if shield then cm.DrawShield()end;if bh~="None"then if p5==nil then p2()end;if bh~=nil then local mA;local pb=g1~=nil;local pc=0.5*bs/c1:getGravity(c1.center+vec3(0,0,1)*c1.radius):len()pc=pc>1000000 and fR(pc/1000000,2).." kTons"or fR(pc/1000,2).." Tons"fO(p7,'{"label": "Target", "value": "'..bh..'", "unit":""}')if pb and not b1 then mA=(cJ-g1.position):len()else mA=(bi-cJ):len()end;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(cG)iF,iG=co.GetAutopilotBrakeDistanceAndTime(a8)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(cG)iF,iG=co.GetAutopilotTBBrakeDistanceAndTime(a8)end;local lf=ip(mA)fO(p9,'{"label": "distance", "value": "'..lf..'"}')fO(gh,'{"label": "Travel Time", "value": "'..iq(lu)..'", "unit":""}')lf=ip(b_)fO(gb,'{"label": "Cur Brake distance", "value": "'..lf..'"}')fO(g9,'{"label": "Cur Brake Time", "value": "'..iq(c0)..'", "unit":""}')lf=ip(iF)fO(g7,'{"label": "Max Brake distance", "value": "'..lf..'"}')fO(g5,'{"label": "Max Brake Time", "value": "'..iq(iG)..'", "unit":""}')fO(gf,'{"label": "Max Brake Mass", "value": "'..df("%s",pc)..'", "unit":""}')lf=ip(gl)fO(gj,'{"label": "Target Orbit", "value": "'..lf..'"}')if c9 and not pd then a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)pd=true;if not cM and t and(b3 or b6 or c7)then co.cmdThrottle(1)aZ=false;bP=false end end;if not c9 and pd then if fO(g5,g6)==1 then fP(g5,g6)end;if fO(g7,g8)==1 then fP(g7,g8)end;if fO(g9,ga)==1 then fP(g9,ga)end;if fO(gb,gc)==1 then fP(gb,gc)end;if fO(gd,ge)==1 then fP(gd,ge)end;pd=false end end else pa()end;if warpdrive~=nil then local pe=ih(warpdrive.getData())if pe.destination~="Unknown"and pe.distance>400000 then if not iS then warpdrive.show()iS=true end elseif iS then warpdrive.hide()iS=false end end end;function n_.OneSecondTick()local function pf()local jr=bH()local kQ=cG;local pg=jr-iQ;if kQ>1.38889 then kQ=kQ/1000;local ph=kQ*(jr-iQ)bl=bl+ph;iN=iN+ph end;iO=iO+pg;bm=bm+pg;iQ=jr end;local function pi(jE)local pj=0;local pk=is;local pl=0;local pm=0;local pn=0;local jw=0;local jx=""local po=b.getElementHitPointsById;local pp=b.getElementMaxHitPointsById;local pq={}for dG in pairs(ir)do local pr=0;local ps=0;ps=pp(ir[dG])pr=po(ir[dG])pl=pl+pr;if pr+1<ps then if pr==0 then pn=pn+1 else pm=pm+1 end;if iR and#pq==0 then fT=vec3(b.getElementPositionById(ir[dG]))local hl=fT.x;local hm=fT.y;local hn=fT.z;table.insert(pq,b.spawnArrowSticker(hl,hm,hn+1,"down"))table.insert(pq,b.spawnArrowSticker(hl,hm,hn+1,"down"))b.rotateSticker(pq[2],0,0,90)table.insert(pq,b.spawnArrowSticker(hl+1,hm,hn,"north"))table.insert(pq,b.spawnArrowSticker(hl+1,hm,hn,"north"))b.rotateSticker(pq[4],90,90,0)table.insert(pq,b.spawnArrowSticker(hl-1,hm,hn,"south"))table.insert(pq,b.spawnArrowSticker(hl-1,hm,hn,"south"))b.rotateSticker(pq[6],90,-90,0)table.insert(pq,b.spawnArrowSticker(hl,hm-1,hn,"east"))table.insert(pq,b.spawnArrowSticker(hl,hm-1,hn,"east"))b.rotateSticker(pq[8],90,0,90)table.insert(pq,b.spawnArrowSticker(hl,hm+1,hn,"west"))table.insert(pq,b.spawnArrowSticker(hl,hm+1,hn,"west"))b.rotateSticker(pq[10],-90,0,90)table.insert(pq,ir[dG])end elseif iR and#pq>0 and pq[11]==ir[dG]then for jq in pairs(pq)do b.deleteSticker(pq[jq])end;pq={}end end;pj=fR(pl/pk*100,2)if pn>0 or pm>0 then jE[#jE+1]=gJ(0,0,"","pbright txt")jw=bI(pj*2.55)jx=df("rgb(%d,%d,%d)",255-jw,jw,0)jE[#jE+1]=gJ("50%",1035,"Elemental Integrity: "..pj.."%","txtbig txtmid","fill:"..jx)if pn>0 then jE[#jE+1]=gJ("50%",1055,"Disabled Modules: "..pn.." Damaged Modules: "..pm,"txtbig txtmid","fill:"..jx)elseif pm>0 then jE[#jE+1]=gJ("50%",1055,"Damaged Modules: "..pm,"txtbig txtmid","fill:"..jx)end end end;local function pt()if ig then if iH==nil and(d3~=nil or bk)then _autoconf.displayCategoryPanel(ig,weapon_size,"Weapons","weapon",true)iH=_autoconf.panels[_autoconf.panels_size]elseif iH~=nil and d3==nil and not bk then gI(iH)iH=nil end end end;cY=b.getPlayersOnBoard()cZ=b.getDockedConstructs()local jE={}pf()if s then pi(jE)end;pt()cm.UpdatePipe()cm.ExtraData(jE)iP=table.concat(jE,"")end;function n_.AnimateTick()ct=true;cs=false;c2=0;c3=0;c.stopTimer("animateTick")end;function n_.MsgTick()local jE={}cm.DisplayMessage(jE,"empty")bX="empty"c.stopTimer("msgTick")bY=3 end;function n_.ButtonSetup()nz()nE()iu=iv end;if pu then for dG,ds in pairs(pu)do n_[dG]=ds end end;return n_ end;local function pv(d,b,c,a,e,vBooster,hover,pw,antigrav,warpdrive,dbHud_1,eU,bI,bJ,ij,eP,bH,dg,ik,fO,il,di,fR,fQ,im,dj,ip,iq,px,ih,df,fP)local py={}local pz=false;local pA=0;local pB=0;local pC=0;local pD=bH()local pE=0;local pF=0;local pG=0;local pH=0;local pI=false;local pJ=false;local pK=false;local pL=nil;local pM=0;local iE=55;local pN=nil;local pO=false;local pP=false;local pQ=false;local pR=0;local pS=0;local pT=0;local pU=0;local pV=0;local pW={VectorToTarget=false}local pX=vec3(b.getConstructWorldOrientationUp())local pY=nil;local pZ=0;local p_=-1;local q0=-1;local q1=false;local q2=false;local q3=0;local q4=false;local q5=false;local q6=false;local q7=false;local q8=""local q9=false;local qa=false;local qb=""local qc=false;local qd=0;local qe=vec3({13771471,7435803,-128971})local qf=18000000;local qg=500000;local qh,qi=math.huge;local qj;local function qk(ql)qh=vec3(ql):dist(qe)if qh<qf then return true,eU(qh-qf)end;qi=vec3(ql):dist(vec3(kg.center))if qi<qg then qj=true else qj=false end;if eU(qi-qg)<eU(qh-qf)then return qj,eU(qi-qg)else return qj,eU(qh-qf)end end;local function qm(fl)local qn=bd;if not b1 then qn=0 end;local qo=bq;if c9 then if bs and bs>0 then qo=bs else return 0,0 end end;return ck.computeDistanceAndTime(fl,qn,cc,0,0,qo-bf*cc)end;local function qp(fl)local qn=bd;if not b1 then qn=0 end;return ck.computeDistanceAndTime(fl,qn,cc,d:maxForceForward(),a0,bq-bf*cc)end;local function qq(qr,qs,qt)qs=qs:project_on_plane(qr)qt=qt:project_on_plane(qr)return eP(qs:cross(qt):dot(qr),qs:dot(qt))end;local function qu()local function qv()local qw=-1;local qx=-1;if vBooster then qw=vBooster.getDistance()end;if hover then qx=hover.getDistance()end;if qw~=-1 and qx~=-1 then if qw<qx then return qw else return qx end elseif qw~=-1 then return qw elseif qx~=-1 then return qx else return-1 end end;local qy=qv()local qz=-1;if antigrav and antigrav.getState()==1 and not q and cG<iE then local qA=eU(cb-antigrav.getBaseAltitude())if qA<50 then return qA end end;if pw then qz=pw.getDistance()end;if qy~=-1 and qz~=-1 then if qy<qz then return qy else return qz end elseif qy~=-1 then return qy else return qz end end;local function qB(kg,eG,qC)local function qD(qE,dS)local eM=vec3(dS)if qE.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=qE.systemId},dU)end;local eN=eM-qE.center;local c4=eN:len()local dZ=c4-qE.radius;local dX=0;local dY=0;if not dj(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=math.deg(dX),longitude=math.deg(dY),altitude=dZ,id=qE.id,systemId=qE.systemId},dU)end;local qF=qD(kg,eG)qF="::pos{"..qF.systemId..","..qF.id..","..qF.latitude..","..qF.longitude..","..qF.altitude.."}"if qC then return qF else q6=qF;return true end end;local function qG(qH,qI,qJ)local function qK(qH,ep)qH=vec3(qH)ep=vec3(ep):normalize()local dB=qH*ep;return dB.x+dB.y+dB.z end;local qL=0.001;local qM=1;if not c9 or not cv or c8~=-1 or cG<iE then if qJ==nil then qJ=aQ end;if qI==nil then qI=qL end;qH=vec3(qH):normalize()local qN=vec3()-qH;local qO=-qK(qN,b.getConstructWorldOrientationRight())*qM;local qP=-qK(qN,b.getConstructWorldOrientationUp())*qM;if pB==0 then pB=qO/2 end;if pC==0 then pC=qP/2 end;if eU(qO)<0.1 then pS=pS-qO*2 else pS=pS-(qO+(qO-pB)*qJ)end;if eU(qP)<0.1 then pR=pR+qP*2 else pR=pR+qP+(qP-pC)*qJ end;pB=qO;pC=qP;if eU(qO)<qI and eU(qP)<qI then return true end;return false elseif cv and c8==-1 then qH=cF;if qJ==nil then qJ=aQ end;if qI==nil then qI=qL end;qH=vec3(qH):normalize()local qN=cC-qH;local qO=-qK(qN,b.getConstructWorldOrientationRight())*qM;local qP=-qK(qN,b.getConstructWorldOrientationUp())*qM;if pB==0 then pB=qO/2 end;if pC==0 then pC=qP/2 end;if eU(qO)<0.1 then pS=pS-qO*5 else pS=pS-(qO+(qO-pB)*qJ)end;if eU(qP)<0.1 then pR=pR+qP*5 else pR=pR+qP+(qP-pC)*qJ end;pB=qO;pC=qP;if eU(qO)<qI and eU(qP)<qI then return true end;return false end end;function py.clearAll()b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"a_=false;b0=false;cS=nil;b3=false;b6=false;b4=false;b5=false;b7=false;bV=false;pP=false;c5=false;c6=false;pQ=false;cu=p;bo=false;b2=false;cd=false;br=nil;bx=false;d6=false;d7=nil end;function py.GetAutopilotBrakeDistanceAndTime(fl)return qm(fl)end;function py.GetAutopilotTBBrakeDistanceAndTime(fl)return qp(fl)end;function py.showWayPoint(kg,eG,qC)return qB(kg,eG,qC)end;function py.APTick()local qQ=a.getMouseWheel()if qQ>0 then co.changeSpd()elseif qQ<0 then co.changeSpd(true)else pO=true end;q3=il()if q6 then a.setWaypoint(q6)q6=false end;if q9 then antigrav.setBaseAltitude(q9)q9=false end;if q7 then fO(q7,q8)q7=false;q8=""end;if q0~=-1 then co.cmdCruise(q0,q1)q1=false;q0=-1 end;if pY~=nil then if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ik:getTargetSpeed(axisCommandId.longitudinal)~=pY then ik:setTargetSpeedCommand(axisCommandId.longitudinal,pY)else pY=nil end end;if p_~=-1 then co.cmdThrottle(p_,q1)q1=false;p_=-1 end;if q2 then cq.landingGear()q2=false end;if qa then co.ToggleAutopilot()end end;function py.ToggleIntoOrbit()cz=false;pG=nil;pH=nil;pM=0;if not c9 then if bx then fQ("orOff","AP")bx=false;pI=false;pL=nil;cu=p;if b3 then b3=false;b5=false end;pW.VectorToTarget=false;pW.AutopilotAlign=false;pK=false elseif cT then fQ("orOn","AP")bx=true;cu=true;if pL==nil then pL=kg end;if b3 then b3=false;b5=false end else bX="Unable to engage auto-orbit, not near a planet"end else bx=false;pI=false;pL=nil;cu=p;if b3 then b3=false end;pW.VectorToTarget=false;pW.AutopilotAlign=false;pK=false end end;function py.ToggleVerticalTakeoff()b3=false;if b7 then ln=true;b6=false;b5=false;b4=true;cu=true;bU=0;if c9 and c8==-1 then b4=false;b3=true;bU=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q0=bI(cw)end else cz=false;bk=false;d.control.retractLandingGears()ik:setTargetGroundAltitude(X)aZ="VTO Takeoff"end;b7=not b7 end;function py.checkLOS(qH)local ls,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,qH,function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local lt=eE;if eF~=nil and eE~=nil then lt=math.min(eF,eE)end;if lt~=nil then return ls,lt else return nil,nil end end;function py.ToggleAutopilot()local function qR(bv)cU=false;bo=not bo;if bo then b2=false;if not b3 and not bv then co.ToggleAltitudeHold()end end;lw="Proceeding to Waypoint"end;local function qS(gu)if gu then for K,dG in pairs(cP)do if dG.name and dG.name==gu then return K end end else return 0 end end;local qT=false;if bK-pF<1.5 and c9 then if not cB then if c9 then b8=kg.spaceEngineMinAltitude-0.01*kg.noAtmosphericDensityAltitude;fQ("11","EP")pF=-1;if b1 or bo or bx then return end else bX="No space engines detected, Orbital Hop not supported"return end elseif kg.hasAtmosphere then if c9 then b8=kg.noAtmosphericDensityAltitude+T;fQ("orH","OH")end;pF=-1;if b1 or bo or bx then return end end else pF=bK end;qU=false;if(bj>0 or#bD>0)and not b1 and not bo and not c6 and not bx then if 0.5*d:maxForceForward()/b.g()<cc then bX="WARNING: Heavy Loads may affect autopilot performance."bY=5 end;if#bD>0 and not c7 then bj=qS(bD[1])cn.UpdateAutopilotTarget()bX="Route Autopilot in Progress"local qN=g1.position-cJ;local qV=qN:project_on_plane(cH):len()if qV>50000 and g1.planetname==kg.name then qT=true end end;cn.UpdateAutopilotTarget()co.showWayPoint(c1,bi)if g1~=nil then if g1.agg and not q and antigrav then if not cL then co.ToggleAntigrav()end;bt=g1.agg end;br=nil;bv=g1.planetname=="Space"if bv then fQ("apSpc","AP")if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end elseif kg.name==g1.planetname then ln=true;if c9 then if not bo then fQ("vtt","AP")qR(bv)if qT then b8=kg.noAtmosphericDensityAltitude+T end end else fQ("apOn","AP")if not(c1.name==kg.name and cb<gl*1.5)then cz=false;b1=true elseif not c9 then if bx then co.ToggleIntoOrbit()end;cy=kg.noAtmosphericDensityAltitude+T;pK=true;pW.AutopilotAlign=true;pW.VectorToTarget=true;pI=false;if not bx then co.ToggleIntoOrbit()end end end else fQ("apP","AP")a_=false;b0=false;if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end end elseif not c9 then if g1==nil and(c1.name==kg.name and cT)and not bx then qW=false;cz=false;pI=false;co.ToggleIntoOrbit()else fQ("apP","AP")b1=true;a_=false;b0=false;ba=false;bV=false;b3=false;b4=false;b6=false;b5=false;pP=false;br=nil;qW=false end else fQ("apP","AP")c6=true;co.ToggleAltitudeHold()end;qa=false else fQ("apOff","AP")co.ResetAutopilots(1)if qa==2 then qa=true end end end;function py.routeWP(qX,qY,qZ)if qZ then if qZ==1 then bD={}bD=im(bD,bC)if#bD>0 then bX="Route Loaded"else bX="No Saved Route found on Databank"end;return bD else bC={}bC=im(bC,bD)bX="Route Saved"px()return end end;if qX then return bD end;if qY then bD={}bX="Current Route Cleared"else bD[#bD+1]=g1.name;bX="Added "..g1.name.." to route. "end;return bD end;function py.cmdThrottle(dH,q_)if ik:getAxisCommandType(0)~=axisCommandType.byThrottle and not q_ then d.control.cancelCurrentControlMasterMode()end;ik:setThrottleCommand(axisCommandId.longitudinal,dH)bL=dg(fR(dH*100,0)/100,-1,1)pY=nil end;function py.cmdCruise(dH,q_)if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not q_ then d.control.cancelCurrentControlMasterMode()end;ik:setTargetSpeedCommand(axisCommandId.longitudinal,dH)pY=dH end;function py.ToggleLockPitch()if br==nil then fQ("lkPOn","LP")if not bW then br=cN else br=Q end;b5=false;b3=false;b4=false else fQ("lkPOff","LP")br=nil end end;function py.ToggleAltitudeHold()if bK-pE<1.5 then if kg.hasAtmosphere then if c9 then b8=kg.spaceEngineMinAltitude-0.01*kg.noAtmosphericDensityAltitude;fQ("11","EP")else if cT then b8=kg.noAtmosphericDensityAltitude+T;cy=b8;pK=true;if not bx then co.ToggleIntoOrbit()end;pI=true end end;pE=-1;if b3 or bx or b7 then return end end else pE=bK end;if cT and not c9 then cy=cb;pK=true;pI=true;co.ToggleIntoOrbit()if bx then pE=bK else pE=0 end;return end;b3=not b3;b4=false;b6=false;if b3 then b1=false;b0=false;a_=false;bV=false;cu=true;br=nil;cz=false;if c8~=-1 and cG<20 then if bk then cq.landingGear()end;fQ("lfs","LS")b5=true;if pE>-1 then b8=cb+W end;aZ="ATO Hold"ik:setTargetGroundAltitude(X)if aY and cK then co.ToggleVerticalTakeoff()end else fQ("altOn","AH")b5=false;if pE>-1 then if cT then b8=cb end end;if b7 then co.ToggleVerticalTakeoff()end end;if cL and not q then local r0=antigrav.getBaseAltitude()if bo and g1.agg and g1.agg>cb then b8=g1.agg elseif b5 then b8=r0 end;if eU(cb-r0)<100 and cG<20 then b8=r0;aZ="AGG Hold"p_=0 end end;if c6 then b8=200000 end else fQ("altOff","AH")if bx then co.ToggleIntoOrbit()end;if b7 then co.ToggleVerticalTakeoff()end;cu=p;b5=false;bo=false;pE=0 end end;function py.ResetAutopilots(py)if py then c6=false;b1=false;ba=false;pP=false;b8=cb;qU=false;d6=false;be="Aligning"end;bo=false;b5=false;b6=false;b0=false;b4=false;d7=nil;r1=false;cS=nil;d6=false;if not cL then b3=false;br=nil end;if b7 then co.ToggleVerticalTakeoff()end;if bx then co.ToggleIntoOrbit()end;cu=p;c5=false;c7=false;bU=0 end;function py.BrakeToggle(r2)if not aZ then if r2 then aZ=r2 else aZ=true end else aZ=false end;if b4 then b4=false;cu=p;d6=false end;if aZ then fQ("bkOn","B",1)co.ResetAutopilots()else fQ("bkOff","B",1)end end;function py.BeginReentry()if b6 then bX="Re-Entry cancelled"fQ("reOff","RE")b6=false;cu=p;b3=false elseif not kg.hasAtmosphere then bX="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bY=5 elseif not pQ then b6=true;if ik:getAxisCommandType(0)~=r3.cruise then d.control.cancelCurrentControlMasterMode()end;cu=true;aZ=false;bX="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cw;fQ("par","RE")else b6=true;b3=true;cu=true;aZ=false;b8=kg.surfaceMaxAltitude+Z;if b8>kg.spaceEngineMinAltitude then b8=kg.spaceEngineMinAltitude-0.01*kg.noAtmosphericDensityAltitude end;local r4=ip(b8)bX="Beginning Re-entry.  Target speed: "..cw.." Target Altitude: "..r4;fQ("glide","RE")q0=bI(cw)end;b5=false end;function py.ToggleAntigrav()if antigrav and not q then if cL then fQ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bt==nil then bt=cb end;if bt<1000 then bt=1000 end;fQ("aggOn","AG")antigrav.activate()antigrav.show()end end end;function py.changeSpd(r5)local r6=1;if r5 then r6=-1 end;if not bW then if t and not o_ and pO then local r7=bL;bL=fR(dg(bL+r6*aC/100,-1,1),2)if bL>=0 and r7<0 then bL=0;pO=false end elseif o_ then if c9 or b6 then cw=dg(cw+r6*aC,0,U)elseif b1 then a8=dg(a8+r6*aC/3.6*100,0,da-0.2)end else ik:updateCommandFromActionStart(axisCommandId.longitudinal,r6*aC/10)end else if b1 or bo or c6 or bx then cX=cX+1*r6*-1;if cX>#cP then cX=1 end;if cX<1 then cX=#cP end else if not r5 then r6=1 else r6=nil end;cn.adjustAutopilotTargetIndex(r6)end end end;function py.TenthTick()local function r8()if not b1 then if g1==nil or g1.planetname~=kg.name then r9=(c1.center-cJ):len()else r9=(g1.position-cJ):len()end end;local fl=cG;local ra=c.getThrottle()/100;if t then ra=bL end;local rb,rc=ck.computeDistanceAndTime(cG,a8,cc,d:maxForceForward()*ra,a0,0)local b_,c0;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(a8)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(a8)end;local dL,rd;if not b2 and fl>0 then dL,rd=co.GetAutopilotBrakeDistanceAndTime(fl)else dL,rd=co.GetAutopilotTBBrakeDistanceAndTime(fl)end;local re=0;local rf=0;if bc or not b1 and fl>5 then rf=ck.computeTravelTime(fl,0,r9)elseif b_+rb<r9 then re=r9-(b_+rb)rf=ck.computeTravelTime(8333.0556,0,re)else local rg=(r9-b_)/rb;rb=r9-b_;rc=rc*rg end;if g1~=nil and g1.planetname==kg.name and not b1 then return rf elseif bb then return rd elseif bc then return rf+rd else return rc+c0+rf end end;local function rh(oe,ri)if oe==nil then oe=b.g()end;oe=fR(oe,5)if ri~=nil and ri or(pN==nil or pN~=oe)then local fl=cE:len()local rj=ih(c.getData()).maxBrake;if rj~=nil and rj>0 and c9 then rj=rj/dg(fl/100,0.1,1)rj=rj/ca;if ca>0.10 then if bs then bs=(bs+rj)/2 else bs=rj end end end;if rj~=nil and rj>0 then bq=rj end;pN=oe end end;cQ,cR=qk(cJ)da=b.getMaxSpeed()if bh~="None"and(c1 or g1)then lu=r8()end;rh(nil,true)end;function py.SatNavTick()if not r then return end;qb=dbHud_1.getStringValue("SPBAutopilotTargetName")if qb~=nil and qb~=""and qb~="SatNavNotChanged"then local dB=ih(dbHud_1.getStringValue("SavedLocations"))if dB~=nil then bn=dB;local gs=-1;local gy;for dG,ds in pairs(bn)do if ds.name and ds.name=="SatNav Location"then gs=dG;break end end;if gs~=-1 then gy=bn[gs]gs=-1;for dG,ds in pairs(e[0])do if ds.name and ds.name=="SatNav Location"then gs=dG;break end end;if gs>-1 then e[0][gs]=gy end;cn.UpdateAtlasLocationsList()bX=gy.name.." position updated"end end;for K=1,#cP do if cP[K].name==qb then bj=K;a.print("Index = "..bj.." "..cP[K].name)cn.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function py.onFlush()local function rk(rl,rm)local rn=vec3()local ro=vec3()if rl==axisCommandId.longitudinal then rn=vec3(b.getConstructOrientationForward())ro=cC elseif rl==axisCommandId.vertical then rn=vec3(b.getConstructOrientationUp())ro=pX elseif rl==axisCommandId.lateral then rn=vec3(b.getConstructOrientationRight())ro=cD else return vec3()end;local rp=vec3(b.getWorldGravity())local rq=rp:dot(ro)local rr=vec3(b.getWorldAirFrictionAcceleration())local rs=rr:dot(ro)local rt=cE:dot(rn)local ru=rm*constants.kph2m;if rv==nil then rv=pid.new(10,0,10.0)end;rv:inject(ru-rt)local rw=rv:get()local rx=(rw-rs-rq)*ro;return rx end;local function ry(rl,rm)local rn=vec3()local ro=vec3()if rl==axisCommandId.longitudinal then rn=vec3(b.getConstructOrientationForward())ro=cC elseif rl==axisCommandId.vertical then rn=vec3(b.getConstructOrientationUp())ro=pX elseif rl==axisCommandId.lateral then rn=vec3(b.getConstructOrientationRight())ro=cD else return vec3()end;local rp=vec3(b.getWorldGravity())local rq=rp:dot(ro)local rr=vec3(b.getWorldAirFrictionAcceleration())local rs=rr:dot(ro)local rt=cE:dot(rn)local ru=rm*constants.kph2m;if rz==nil then rz=pid.new(10,0,10.0)end;rz:inject(ru-rt)local rw=rz:get()local rx=(rw-rs-rq)*ro;return rx end;local function rA(rB,jH,fY)local rC=rB:cross(fY):normalize_inplace()local kt=math.acos(dg(rC:dot(-jH),-1,1))*constants.rad2deg;if rC:cross(-jH):dot(fY)<0 then kt=-kt end;return kt end;local function rD()if cV and not b4 then local en=cV[1]local hJ,hK=cV[2],cV[3]local rE=math.min(hJ,hK or hJ)local rF=rE/cG;local rG=b5 and(cG<42 or c8~=-1)local rH=b3 or bo or br or b1;if rH and not rG and(b_*1.5>rE or rF<1)then aZ="Collision"bD={}p_=0;if b3 then co.ToggleAltitudeHold()end;if br then co.ToggleLockPitch()end;bX="Autopilot Cancelled due to possible collision"a.print(en.name.." COLLISION "..iq(rF).." / "..ip(rE,2))co.ResetAutopilots(1)ln=true;if c9 then b4=true end;cu=true end;if rF<11 then cU=en.name.." COLLISION "..iq(rF).." / "..ip(rE,2)else cU=en.name.." collision "..iq(rF)end;if rF<6 then fQ("alarm","AL",2)end else cU=false end end;if antigrav and not q then if not cL and antigrav.getBaseAltitude()~=bt then q9=bt end end;if d9 then d:setEngineForceCommand('hover',vec3(),1)d9=false end;cM=ik:getAxisCommandType(0)==axisCommandType.byThrottle;aM=math.max(aM,0.01)aN=math.max(aN,0.01)aH=math.max(aH,0.01)aL=math.max(aL,0.01)aO=math.max(aO,0.01)aP=math.max(aP,0.01)aG=math.max(aG,0.01)local rI=dg(bR+pR+a.getControlDeviceForwardInput(),-1,1)local rJ=dg(bS+pT+a.getControlDeviceYawInput(),-1,1)local rK=dg(bT+pS-a.getControlDeviceLeftRightInput(),-1,1)local rL=aZ and 1 or 0;cH=vec3(b.getWorldVertical())if cH==nil or cH:len()==0 then cH=(kg.center-cJ):normalize()end;pX=vec3(b.getConstructWorldOrientationUp())cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cF=vec3(b.getWorldVelocity())cE=vec3(b.getVelocity())cJ=vec3(b.getConstructWorldPos())cc=b.getConstructMass()cG=vec3(cF):len()cI=-cH:dot(cF)cO=getRoll(cH,cC,cD)local rM=cO/180*math.pi;local rN=math.cos(rM)local rO=math.sin(rM)cN=rA(cH,cC,cD*rN+pX*rO)local rP=cF:normalize()local rQ=eU(cO)local rR=utils.sign(cO)local rS=vec3(b.getWorldAngularVelocity())local rT=rI*aM*cD+rJ*aH*cC+rK*aN*pX;if cu==true and cH:len()>0.01 then local rU=eU(pU-cO)if((b0 or b6 or b4 or c5 or b3 or bx)and rU>0 or c9 and rU<aI and p)and rJ==0 and eU(cN)<85 then local rV=pU;local rW=aG;if not c9 then rW=rW/4;pU=0;rV=0 end;if rX==nil then rX=pid.new(rW*0.01,0,rW*0.1)end;rX:inject(rV-cO)local rY=rX:get()rT=rT+rY*cC end end;local rZ=1;local r_=0;local s0=1;bM=0;ca=bJ()c9=false or cb<kg.noAtmosphericDensityAltitude and ca>0.00001;cb=b.getAltitude()c8=qu()bK=bH()pD=bK;if bk and c8>-1 and c8-3<Y then if ik.targetGroundAltitudeActivated then ik:deactivateGroundEngineAltitudeStabilization()end end;if cp then qc=not qc;if qc then cp.UpdateRadar()end;if E then rD()end end;if antigrav then cL=antigrav.getState()==1 end;local s1=1;local s2=1;local s3=bK-pD;local s4=-math.deg(qq(pX,cF,cC))local s5=math.deg(qq(cD,cF,cC))local gn=cH*-1;cv=c9 and s4<-L or s4>L or s5<-M or s5>M;local s6=a.getMouseDeltaX()local s7=a.getMouseDeltaY()if qd then local s8=bH()-qd;s6=s6*s8/0.016;s7=s7*s8/0.016 end;qd=bH()if o and not bW then s7=-s7 end;pS=0;pT=0;pR=0;fU=cj[0]kg=fU:closestBody(b.getConstructWorldPos())s9=cl(kg)fp=s9:orbitalParameters(b.getConstructWorldPos(),cF)if cb==0 then cb=(cJ-kg.center):len()-kg.radius end;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;local oe=kg:getGravity(b.getConstructWorldPos()):len()*cc;pU=0;local sa=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if q3==0 then if ij()==1 and bW then if not cs then c2=dg(c2+s6/2,-ce/2,ce/2)c3=dg(c3+s7/2,-cf/2,cf/2)end else c2=0;c3=0 end else c2=dg(c2+s6/2,-ce/2,ce/2)c3=dg(c3+s7/2,-cf/2,cf/2)d8=di(c2*c2+c3*c3)if not bW and ij()==0 then local kC,kD=1,1;if bF=="SCOPE"then kC,kD=d0/90,d0/90 end;if g=="virtual joystick"then if d8>aw then pS=pS-dg(eU(c2)-aw,0,ce/2)*utils.sign(c2)*aE*kC;pR=pR-dg(eU(c3)-aw,0,cf/2)*utils.sign(c3)*aF*kD end else c2=0;c3=0;if g=="mouse"then pR=(-utils.smoothstep(s7,-100,100)+0.5)*2*s1;pS=(-utils.smoothstep(s6,-100,100)+0.5)*2*s2 end end end end;local sb=cG>27777;if cG>V/3.6 and not c9 and not b1 and not sb then bX="Space Speed Engine Shutoff reached"p_=0 end;if not sb and sc then if not aZ then co.BrakeToggle()end;if b1 then co.ResetAutopilots(1)end;p_=0 end;sc=sb;if ca>0.09 then if cG>cw/3.6 and not t and not pz then aZ="SpdLmt"pz=true elseif not t and pz then if cG<cw/3.6 then aZ=false;pz=false end end end;if b0 then if c5 then aZ=false;local sd=false;if g1 and c5==true then sd=qG(g1.position-cJ,0.1)else sd=qG(vec3(cF),0.01)end;cu=true;if sd then q0=bI(cw)if(eU(cO)<2 or eU(cN)>85)and cG>=cw/3.6-1 then aZ=false;b0=false;if c5~=2 then pQ=true end;if c5==true then c7=true end;c5=false;b1=false;co.BeginReentry()end elseif c9 and t then p_=1 end elseif cG>iE then qG(vec3(cF),0.01)end end;if a_ then if c9 then a_=false elseif cG>iE then qG(-vec3(cF))end end;if not b0 and c5 and not bx then if not c9 then if c5~=2 then pQ=true end;co.BeginReentry()c5=false;c7=true else c5=false;if not qa then qa=true end end end;if c7 and g1 and(cb<b8+250 and cb>b8-250)and cG*3.6>cw-250 and eU(cI)<25 and ca>=0.1 and(g1.position-cJ):len()>2000+cb then if not qa then qa=true end;c7=false end;if b7 then cu=true;local se=b8;if cI<-30 then bX="Unable to achieve lift. Safety Landing."bU=0;cu=p;b7=false;b4=true elseif not q and cL or b8<kg.spaceEngineMinAltitude then if cL then se=antigrav.getBaseAltitude()end;if cb<se-100 then pV=0;bU=15;aZ=false elseif cI>0 then aZ="VTO Limit"bU=0 elseif cI<-30 then aZ="VTO Fall"bU=15 elseif cb>=se then if cL then if b1 or bo then co.ToggleVerticalTakeoff()else aZ="VTO Complete"b7=false end;bX="Takeoff complete. Singularity engaged"fQ("aggLk","AG")else aZ=false;bX="VTO complete. Engaging Horizontal Flight"fQ("vtoc","VT")co.ToggleVerticalTakeoff()end;bU=0 end else if ca>0.08 then pV=0;aZ=false;bU=20 elseif ca<0.08 and c9 then aZ=false;if cA then pV=0;bU=20 else bU=0;pV=36;q0=3500 end else cu=p;bx=true;cz=false;sf=false;pI=false;pG=nil;pH=nil;if pL==nil then pL=kg end;cy=se;pK=true;b7=false end end;if pV~=nil then if sg==nil then sg=pid.new(2*0.01,0,2*0.1)end;local sh=dg(pV-cN,-M*0.80,M*0.80)sg:inject(sh)local si=dg(sg:get(),-1,1)pR=si end end;if bx then local function sj()if fp.periapsis.altitude>=cy*0.99 and fp.apoapsis.altitude>=cy*0.99 and fp.periapsis.altitude<fp.apoapsis.altitude and fp.periapsis.altitude*1.05>=fp.apoapsis.altitude and eU(cy-cb)<1000 then return true else return false end end;local qN;local sk=false;local sl=ip(cy)if pL==nil then pL=kg;if bo then pL=c1 end end;if not pK then cy=bI(pL.radius+pL.surfaceMaxAltitude+T)if pL.hasAtmosphere then cy=bI(pL.radius+pL.noAtmosphericDensityAltitude+T)end;pK=true end;if pW.VectorToTarget and g1 then qN=g1.position-cJ end;local sm,sn=cl(pL):escapeAndOrbitalSpeed((cJ-pL.center):len()-pL.radius)local so=cO;if not pI then local sp=false;local sq=false;p_=0;pH=0;cx="Aligning to orbital path - OrbitHeight: "..sl;if pW.VectorToTarget then qG(qN:normalize():project_on_plane(cH))sk=cC:dot(qN:project_on_plane(pX):normalize())>0.95 else qG(cF)sk=s4<0.5;if cG<150 then sk=true end end;pR=0;pG=0;if cN<=pG+2 and cN>=pG-2 then sp=true else sp=false end;if so<=pH+2 and so>=pH-2 then sq=true else sq=false end;if sp and sq and sk then pG=nil;pH=nil;pI=true end else if pW.VectorToTarget then qG(qN:normalize():project_on_plane(cH))elseif cG>150 then qG(cF)end;pR=0;if pW.VectorToTarget and g1 then local b_,dL=ck.computeDistanceAndTime(cG,cw/3.6,cc,0,0,bq)if cz and qN:len()>15000+b_+cb then cx="Orbiting to Target"if cb-100<=pL.noAtmosphericDensityAltitude or lu>fp.timeToPeriapsis and fp.periapsis.altitude<pL.noAtmosphericDensityAltitude or not sj()and fp.eccentricity>0.1 then bX="Re-Aligning Orbit"cz=false end elseif cz or qN:len()<15000+b_+cb then bX="Orbit complete, proceeding with reentry"fQ("orCom","OB")bi=g1.position;pQ=true;c7=true;pW.VectorToTarget,pW.AutopilotAlign=false,false;co.ToggleIntoOrbit()co.BeginReentry()return end end;if fp.periapsis~=nil and fp.apoapsis~=nil and fp.eccentricity<1 and cb>cy*0.9 and cb<cy*1.4 then if fp.apoapsis~=nil then if sj()or cz then if cz then aZ=false;p_=0;pG=0;if not pW.VectorToTarget then bX="Orbit complete"fQ("orCom","OB")co.ToggleIntoOrbit()end else pM=pM+1;if pM>=2 then cz=true end end else cx="Adjusting Orbit - OrbitHeight: "..sl;pJ=true;q0=sn*3.6+1;local sr=cy-cb;if ss==nil then ss=pid.new(0.1,0,1*0.1)end;ss:inject(sr-cI*dg(utils.smoothstep(2000-sr,-2000,2000)^6*10,1,10))pG=dg(ss:get(),-60,60)end end else local st=2.75;local su=eU(fR(sm*st))local ot=su%50;if ot>0 then su=su-ot+50 end;aZ=false;if cb<cy*0.8 then cx="Escaping planet gravity - OrbitHeight: "..sl;pG=utils.map(cI,200,0,-15,80)elseif cb>=cy*0.8 and cb<cy*1.15 then cx="Approaching orbital corridor - OrbitHeight: "..sl;su=su*0.75;pG=utils.map(cI,100,-100,-15,65)elseif cb>=cy*1.15 and cb<cy*1.5 then cx="Approaching orbital corridor - OrbitHeight: "..sl;su=su*0.75;if cI<0 or pJ then pG=utils.map(cb,cy*1.5,cy*1.01,-30,0)else pG=utils.map(cb,cy*0.99,cy*1.5,0,30)end elseif cb>cy*1.5 then cx="Reentering orbital corridor - OrbitHeight: "..sl;pG=-65;local sv=utils.map(cI,-150,-400,1,0.55)su=su*sv end;q0=bI(su)end end;if pG~=nil then if sw==nil then sw=pid.new(1*0.01,0,5*0.1)end;local sx=pG-cN;sw:inject(sx)local sy=dg(sw:get(),-0.5,0.5)pR=sy end end;if b1 and not c9 and not c5 then local function sz(dd,fp)a.print(dd)aZ=false;bb=false;b1=false;qU=false;be="Aligning"p_=0;pP=false;bX=dd;fQ("apCom","AP")if fp or c5 then if fp and gl~=nil and not c5 then if not cb or cb==0 then return end;cy=cb;pK=true end;co.ToggleIntoOrbit()end end;local sA,sB=bi,false;if g1 and g1.planetname~="Space"then ba=true;if not qU then local sC=(g1.position-c1.center):normalize()local sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()local sE=c1.center+sD*(c1.radius+gl)local sF=g1.position+(g1.position-c1.center):normalize()*(gl-c1:getAltitude(g1.position))if(cJ-sE):len()<(cJ-sF):len()then sA=sE else sA=sF;bd=0 end;bi=sA;co.showWayPoint(c1,bi)sB=true;qU=true end;bf=0 elseif g1 and g1.planetname=="Space"then if not qU then bf=0;sB=true;ba=true;qU=true;sA=g1.position+(cJ-g1.position):normalize()*R;bi=sA end elseif g1==nil then bf=0;if not qU then local sC=(cJ+cF*100000-c1.center):normalize()local sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()if sD:len()<1 then sC=(cJ+cC*100000-c1.center):normalize()sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()end;sA=c1.center+sD*(c1.radius+gl)bi=sA;qU=true;sB=true;ba=true;co.showWayPoint(c1,bi)end end;r9=(vec3(sA)-cJ):len()local ls,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,cF:normalize(),function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local lt=eE;if eF~=nil and eE~=nil then lt=math.min(eF,eE)end;if lt~=nil and lt<r9 and ls.name==c1.name then r9=lt end;local sd=true;local sG=(c1.center-(cJ+vec3(cF):normalize()*r9)):len()-c1.radius;local lf=ip(sG)q7=gd;q8='{"label": "Projected Altitude", "value": "'..lf..'"}'if cG>50 and b9 then local qN=vec3(sA)-cJ;local sH=dg(math.deg(qq(pX,cF:normalize(),qN:normalize()))*cG/500,-90,90)local sI=dg(math.deg(qq(cD,cF:normalize(),qN:normalize()))*cG/500,-90,90)if eU(sH)<20 and eU(sI)<20 then sH=sH*2;sI=sI*2 end;if eU(sH)<2 and eU(sI)<2 then sH=sH*2;sI=sI*2 end;local s4=-math.deg(qq(pX,cC,cF:normalize()))local s5=-math.deg(qq(cD,cC,cF:normalize()))if sJ==nil then sJ=pid.new(2*0.01,0,2*0.1)end;sJ:inject(sI-s5)local sK=dg(sJ:get(),-1,1)pR=pR+sK;if sL==nil then sL=pid.new(2*0.01,0,2*0.1)end;sL:inject(sH-s4)local sM=dg(sL:get(),-1,1)pS=pS+sM;sB=true;if eU(sH)>2 or eU(sI)>2 then if be~="Adjusting Trajectory"then be="Adjusting Trajectory"fQ("apAdj","AP")end else if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end end elseif b9 and cG<=50 then qG((sA-cJ):normalize())end;if sG<gl*1.5 then bd=cw/3.6;if g1==nil then dL,bd=cl(c1):escapeAndOrbitalSpeed(sG)end end;local b_,c0;if not b2 then b_,c0=qm(cG)else b_,c0=qp(cG)end;if b1 and not b9 and not bc and not bb then local ls,lt=co.checkLOS((bi-cJ):normalize())if c1.name~=kg.name then if ls~=nil and c1.name~=ls.name and lt<r9 then bX="Collision with "..ls.name.." in "..ip(lt).."\nClear LOS to continue."bY=5;q4=true else q4=false;bX=""end end end;if not q4 then if not bc and not bb and not sB then sd=qG((sA-cJ):normalize())elseif b2 and(bb or bc)then sd=qG(-vec3(cF):normalize())end end;if b9 then if not pP then aZ=false;p_=_;bL=fR(_,2)pP=true end;local ra=c.getThrottle()if t then ra=bL end;local sN=99999;local oq=-vec3(b.getWorldAcceleration()):dot(cF:normalize())local sO=dg(cF:dot((sA-cJ):normalize()),0,cG)if sO>0 or oq>0 then sN=ck.computeTravelTime(sO,oq,r9-b_)end;if a8>da then a8=da-0.2 end;if cE:len()>=a8 or ra==0 and pP or a0/4>sN then b9=false;if be~="Cruising"then fQ("apCru","AP")be="Cruising"end;bc=true;p_=0 end;local sP=r9;if sP<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<pA and cR>2000 then co.ResetAutopilots(1)bX="Autopilot cancelled to prevent crossing PvP Line"aZ="PvP Prevent"pA=cR else pA=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true;p_=0;pP=false end elseif bb then if be~="Orbiting to Target"then aZ="AP Brk"end;if b2 then p_=1;q1=true end;local dL,sn=cl(c1):escapeAndOrbitalSpeed((cJ-kg.center):len()-kg.radius)local qN;if g1 then qN=g1.position-cJ end;if g1 and g1.planetname=="Space"and cG<50 then if#bD>0 then if not qa then table.remove(bD,1)end;if#bD>0 then aZ=false;if not qa then qa=2 end;return end end;sz("Autopilot complete, arrived at space location")aZ="Space Arrival"elseif g1 and g1.planetname~="Space"and cG<=sn and(fp.apoapsis==nil or fp.periapsis==nil or fp.apoapsis.altitude<=0 or fp.periapsis.altitude<=0)then sz("Autopilot complete, commencing reentry")bi=g1.position;c5=true;co.showWayPoint(c1,bi)elseif(g1 and g1.planetname~="Space"or g1==nil)and fp.periapsis~=nil and fp.periapsis.altitude>0 and fp.eccentricity<1 or be=="Circularizing"then if be~="Circularizing"then fQ("apCir","AP")be="Circularizing"end;if cG<=sn then if g1 then if cF:normalize():dot(qN:normalize())>0.4 then if be~="Orbiting to Target"then fQ("apOrb","OB")be="Orbiting to Target"end;if not qW then aZ=false;co.showWayPoint(c1,g1.position)qW=true end else sz("Autopilot complete, proceeding with reentry")bi=g1.position;c5=true;co.showWayPoint(c1,g1.position)qW=false end else sz("Autopilot completed, setting orbit",true)aZ=false end end elseif be=="Circularizing"then sz("Autopilot complete, fixing Orbit",true)end elseif bc then local sP=r9;if sP<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<pA and cR>2000 then if not qa then qa=true end;bX="Autopilot cancelled to prevent crossing PvP Line"aZ="Prevent PvP"pA=cR else pA=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true end;local ra=c.getThrottle()if t then ra=bL end;if ra>0 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;bc=false end else if sd then if not ba and g1==nil or not ba and g1 and g1.planetname~="Space"then if not c5 then bi=vec3(c1.center)+(gl+c1.radius)*cD;sQ=pX;sR=cD end;ba=true elseif sd and not q4 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;if not pP then p_=_;q1=true;bL=fR(_,2)pP=true;aZ=false end end end end elseif b1 and(g1~=nil and g1.planetname~="Space"and c9)then bX="Autopilot complete, starting reentry"fQ("apCom","AP")bi=g1.position;aZ=false;bb=false;b1=false;qU=false;be="Aligning"p_=0;pP=false;b0=true;c5=true;co.showWayPoint(c1,g1.position)end;if bV then cu=true;local sI=0;local fr=cJ+vec3(c.getMasterPlayerRelativePosition())local sS=fr-cJ;local sT=vec3(sS):project_on(cC):len()local sU=vec3(sS):project_on(cD):len()local c4=di(sT*sT+sU*sU)qG(sS:normalize())local mA=40;local sV=c4<mA;local sW=100;local rm=dg((c4-mA)/2,10,sW)pR=0;local sd=eU(pS)<0.1;if sd and cG<rm and not sV then aZ=false;sI=-20 else aZ="Follow"sI=0 end;local sX=0;if eU(sI-cN)>sX then if sY==nil then sY=pid.new(2*0.01,0,2*0.1)end;sY:inject(sI-cN)local sK=sY:get()pR=sK end end;if b3 or b4 or b6 or bo or br~=nil then local sZ=bs;if sZ then sZ=sZ*dg(cG/100,0.1,1)*ca else sZ=bq end;if not c9 then sZ=bq end;pZ=cC:project_on_plane(cH):normalize():dot(cF)if pZ>100 then b_,c0=ck.computeDistanceAndTime(pZ,100,cc,0,0,sZ)local s_,t0=ck.computeDistanceAndTime(100,0,cc,0,0,sZ*0.55)b_=b_+s_ else b_,c0=ck.computeDistanceAndTime(pZ,0,cc,0,0,sZ*0.55)end;local sr=b8-cb-cI;local t1=200+cG;if b6 or c5 then t2=2000+cG end;local t3=1;if b5 then t3=dg(cG/100,0.1,1)end;local sI=(utils.smoothstep(sr,-t1,t1)-0.5)*2*O*t3;if not b6 and not c5 and not bo and cC:dot(cF:normalize())<0.99 then sI=(utils.smoothstep(sr,-t1*dg(20-19*ca*10,1,20),t1*dg(20-19*ca*10,1,20))-0.5)*2*O*dg(2-ca*10,1,2)*t3 end;if not b3 then sI=0 end;if br~=nil then if cT and not bx then sI=br else br=nil end end;cu=true;local t4=pR;if b6 then local t5=bI(cw)local t6,t7=ck.computeDistanceAndTime(cG,t5/3.6,cc,0,0,bq-kg.gravity*9.8*cc)t6=t6==-1 and 5000 or t6;local qV=cb-(kg.noAtmosphericDensityAltitude+t6)local t8=cb>kg.noAtmosphericDensityAltitude+t6*1.35;if t8 then sI=P;if cG<=t5/3.6 and cG>t5/3.6-10 and eU(cF:normalize():dot(cC))>0.9 and not cM then bP=false;p_=1 end elseif(cM or ik:getTargetSpeed(axisCommandId.longitudinal)~=t5)and not t8 and not c9 then q0=t5;q1=true end;if cM then if cG>t5/3.6 and not t8 then aZ="Reentry Limit"if bL>0 then p_=0 end else aZ=false end else aZ=false end;if cI>0 then aZ="Reentry vSpd"end;if not pQ then sI=-80;if cb<kg.surfaceMaxAltitude+(kg.atmosphereThickness-kg.surfaceMaxAltitude)*0.25 then bX="PARACHUTE DEPLOYED at "..fR(cb,0)b6=false;b4=true;ln=true;p_=0;sI=0;cu=p end elseif kg.noAtmosphericDensityAltitude>0 and t8 then cu=true elseif not t8 then if not c9 and(cM or ik:getTargetSpeed(axisCommandId.longitudinal)~=t5)then q0=t5 end;if cG<t5/3.6+1 then aZ=false;pQ=false;b6=false;cu=true;p_=1 end end end;if cG>iE and not c6 and not bo and not b4 and u then qG(vec3(cF))end;if cS or(bo or c6)and bj>0 and c9 then local qN;if cS then if type(cS)=="table"then qN=cS elseif cS<3 and cS>0 then qN=-cH:cross(cF)*5000 elseif cS>=3 then qN=cH:cross(cF)*5000 elseif cS<0 then qN=cF*25000 end elseif g1~=nil then qN=g1.position-cJ else qN=c1.center-cJ end;local sH=math.deg(qq(cH:normalize(),cF,qN))*2;local mD=math.rad(eU(cO))if cG>aJ and c9 then local t9=1000+cG;local ta=(utils.smoothstep(sr-cI*10,-t9,t9)-0.5)*2*O;local tb=dg(90-ta,0,180)pU=dg(sH*2,-tb,tb)local tc=sH;sH=dg(dg(sH,-L*0.80,L*0.80)*math.cos(mD)+4*(cN-sI)*math.sin(math.rad(cO)),-L*0.80,L*0.80)local td=1;if pU~=0 then td=eU(mD/pU)end;td=(90-dg(eU(pU-cO),0,90))/90;local te=sI;if eU(cO)>90 then te=-te end;sI=td*dg(dg(te*math.cos(mD),-M*0.8,M*0.8)+eU(dg(eU(tc)*math.sin(mD),-M*0.80,M*0.80)),-M*0.80,M*0.80)else pU=0;sH=dg(sH,-L*0.80,L*0.80)end;local tf=s4-sH;if cS and eU(tf)<=0.0001 and(type(cS)=="table"or type(cS)~="table"and cS<0 and eU(cO)<1)then if cS==-2 then co.ToggleAltitudeHold()end;cS=nil;fQ("180Off","BR")return end;if not cv and cG>aJ and c9 then if tg==nil then tg=pid.new(2*0.01,0,2*0.1)end;tg:inject(tf)local sM=dg(tg:get(),-1,1)pS=pS+sM elseif c9 and c8>-1 or cG<aJ then qG(qN)elseif cv and c9 then if(s4<-L or s4>L)and c9 then qG(cF)end;if(s5<-M or s5>M)and c9 then sI=dg(cN-s5,cN-M*0.80,cN+M*0.80)end end;if g1~=nil and not c6 then local se=kg:getAltitude(g1.position)local qV=qN:project_on_plane(cH):len()ln=true;if b8<kg.noAtmosphericDensityAltitude and not c6 and not b5 and not b6 and(qV<=b_ and qN:len()<kg.radius)and(cF:project_on_plane(cH):normalize():dot(qN:project_on_plane(cH):normalize())>0.99 or lw=="Finalizing Approach")then lw="Finalizing Approach"if#bD>0 then if not qa then table.remove(bD,1)end;if#bD>0 then if not qa then qa=2 end;return end end;p_=0;if b3 then co.ToggleAltitudeHold()bo=true end;aZ="AP Finalizing"elseif not b5 then aZ=false end;if lw=="Finalizing Approach"and(pZ<0.1 or qV<0.1 or th~=nil and th<qV)then fQ("bklOn","BL")b4=true;d6=true;if g1.heading then d7=g1.heading else d7=nil end;bo=false;lw="Proceeding to Waypoint"cU=false end;th=qV end elseif bo and not c9 and b8>kg.noAtmosphericDensityAltitude and not(c6 or b6)then if g1~=nil and c1.name==kg.name then local qN=g1.position-cJ;local se=kg:getAltitude(g1.position)local qV=di(qN:len()^2-(cb-se)^2)local sZ=bs;if sZ then b_,c0=ck.computeDistanceAndTime(cG,0,cc,0,0,sZ/2)ln=true;if qV<=b_+cG*s3/2 and cF:project_on_plane(cH):normalize():dot(qN:project_on_plane(cH):normalize())>0.99 then if kg.hasAtmosphere then aZ=false;b0=false;pQ=true;c5=false;c7=true;b1=false;co.BeginReentry()end end;th=qV end end end;if not c9 and(b3 and b8>kg.noAtmosphericDensityAltitude)and not(c6 or bx or b6)then if not cz and not bx then cy=b8;pK=true;if bo then pW.VectorToTarget=true end;co.ToggleIntoOrbit()bo=false;pI=true end end;if cv and c9 and c8==-1 and cG>aJ and lw~="Finalizing Approach"then qG(cF)sI=dg(cN-s5,cN-M*0.80,cN+M*0.80)end;pR=t4;local qz=-1;if b4 then if not q5 then if not cM then p_=0 end;ik:setTargetGroundAltitude(500)ik:activateGroundEngineAltitudeStabilization(500)bz=true;q5=true end;sI=0;local ti=false;local tj=math.abs(pZ)if not q and cL then ti=antigrav.getBaseAltitude()if ti<kg.surfaceMaxAltitude and g1==nil or g1~=nil and kg:getAltitude(g1.position)>ti then ti=false end else ti=false end;if d7 then if tj<0.05 then if cI>-N then aZ=false else aZ="BL Align BLR"end;if qG(d7,0.001)then d7=nil;cu=p else pR=0;cu=true end else aZ="BL Align Hzn"end;if ti and eU(cb-ti)<250 then aZ="AGG Align"end else local tk=false;local tl=30;if tj<10 and sa~=nil and sa>0 then local tm=dg(ca,0.4,2)local sZ=bs*dg(cG/100,0.1,1)*tm;local tn=sa*tm+sZ-oe;local to=sZ/2-oe;local tp=cG-di(eU(to/2)*20/(0.5*cc))*utils.sign(to)if tp<0 then tp=0 end;local tq;if cG>100 then local tr,dL=ck.computeDistanceAndTime(cG,100,cc,0,0,sZ)local ts,dL=ck.computeDistanceAndTime(100,0,cc,0,0,di(sZ))tq=tr+ts else tq=ck.computeDistanceAndTime(cG,0,cc,0,0,di(sZ))end;if tq<20 then aZ=false else local tt=0;if tp>100 then local tu,dL=ck.computeDistanceAndTime(tp,100,cc,0,0,tn)local tv,dL=ck.computeDistanceAndTime(100,0,cc,0,0,sa*tm+di(sZ)-oe)tt=tu+tv else tt,dL=ck.computeDistanceAndTime(tp,0,cc,0,0,sa*tm+di(sZ)-oe)end;tt=(tt+15+cG*s3)*1.1;local tw=d6 and g1~=nil and kg:getAltitude(g1.position)>0 and g1.safe;local se=nil;if ti and ti<cb then se=ti elseif tw then se=kg:getAltitude(g1.position)+250 elseif cb>kg.surfaceMaxAltitude then se=kg.surfaceMaxAltitude end;if cV then local tx=kg:getAltitude(cV[1].center)if se then if tx>se then se=tx end else se=tx end end;if se~=nil then local ty=cb-se;tk=true;if ty<=tt or tt==-1 or tj>0.05 and d6 then if tj>0.05 and d6 then aZ="BL AP Hzn"else aZ="BL Stop Dist"end else aZ=false end end end end;qz=c8;if qz>-1 then if(cG<1 or cF:normalize():dot(cH)<0)and not d7 then b4=false;b3=false;if not ti then q2=true;ik:setTargetGroundAltitude(Y)end;bU=0;aZ="BL Complete"cu=p;d6=false else aZ="BL Slowing"end elseif not tk then if ln and cF:normalize():dot(-gn)<0.999 then aZ="BL Strong"qG()elseif tj>10 or tj>0.05 and d6 then aZ="BL hSpd"elseif cI<-N then aZ="BL BLR"else aZ=false end end end else q5=false end;if b5 or c6 then local ls,eF,eE;if bi~=nil then ls,eF,eE=cj:getPlanetarySystem(0):castIntersections(cJ,(bi-cJ):normalize(),function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)end;if cL and not c6 then if cb>=b8-50 and cG>iE then b5=false;if not b1 and not bo then aZ="ATO Agg Arrive"p_=0 end end elseif eU(sI)<15 and cb/b8>0.75 then b5=false;if not c6 then if cM and not t then d.control.cancelCurrentControlMasterMode()end elseif c6 and cG<iE then b1=true;c6=false;b3=false;b5=false;p_=0 elseif c6 then p_=0;aZ="ATO Space"end elseif c6 and not c9 and c1~=nil and(ls==nil or ls.name==c1.name)then b1=true;c6=false;b3=false;b5=false;if not cM then p_=0 end;b9=true end end;local tz=c8>-1;local tA=cN;if(bo or c6 or cS)and not tz and cG>aJ and c9 then local mD=math.rad(eU(cO))tA=cN*eU(math.cos(mD))+s5*math.sin(mD)end;local tB=dg(sI-tA,-M*0.80,M*0.80)if not c9 and bo then tB=dg(sI-tA,-85,O)elseif not c9 then tB=dg(sI-tA,-O,O)end;if eU(cO)<5 or bo or cS or b4 or tz or b3 then if sY==nil then sY=pid.new(5*0.01,0,5*0.1)end;sY:inject(tB)local sK=sY:get()pR=pR+sK end end;if antigrav~=nil and(antigrav and not q and cb<200000)then if bt==nil or bt<1000 then bt=1000 end;if tC~=bt then tC=bt;q9=tC end end;if(c9 or b6 or c7)and t and cM then if tD==nil then tD=pid.new(0.1,0,1)end;local tE=0;if aS>0 and not b6 and ca>0.005 and ca<0.1 and cI>-50 then tE=(0.1-ca)*cw*aS end;tD:inject(cw/3.6+tE-cF:dot(cC))local tF=tD:get()bO=dg(tF,-1,1)if not d2 then if bO<bL and(ca>0.005 or b6 or c7)then bN=true;d2=dg(bO,0.01,1)else bN=false;d2=bL end end;if tG==nil then tG=pid.new(1*0.01,0,1*0.1)end;tG:inject(cF:len()-cw/3.6-tE)local tH=dg(tG:get(),0,1)if c9 and cI<-80 or(ca>0.005 or b6 or c7)then bM=tH end;if bM>0 then if bN and bO==0.01 and not d2 then d2=0 end else bO=dg(bO,0.01,1)end;local tI=''local tJ=vec3()local tK=rk(axisCommandId.vertical,bU*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tK,r_)local tL='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tL=tL..aT end;local tM=ik:getAxisCommandType(axisCommandId.longitudinal)local tN=ik:composeAxisAccelerationFromThrottle(tL,axisCommandId.longitudinal)local tO=ry(axisCommandId.lateral,bw*1000)tI=tI..' , '.."lateral airfoil , lateral ground "tJ=tJ+tO;if tJ:len()>constants.epsilon then d:setEngineForceCommand(tI,tJ,r_,'','','',s0)end;d:setEngineForceCommand(tL,tN,rZ)local tP='thrust analog vertical fueled 'local tQ='thrust analog lateral fueled 'if bA=="All"or bA=="Lateral"then tQ=tQ..aU end;if bA=="All"or bA=="Vertical"then tP=tP..aV end;if bU~=0 or b4 and aZ or not bk and not bz then d:setEngineForceCommand(tP,tK,rZ)else d:setEngineForceCommand(tP,vec3(),rZ)end;if bw~=0 then d:setEngineForceCommand(tQ,tO,rZ)else d:setEngineForceCommand(tQ,vec3(),rZ)end;if rL==0 then rL=bM end;local tR=-rL*(aO*cF+aP*rP)d:setEngineForceCommand('brake',tR)else if t then if not d2 then d2=bL end end;local rm=c.getAxisCommandValue(0)if not cM then if tG==nil then tG=pid.new(1*0.01,0,1*0.1)end;tG:inject(cF:len()-rm/3.6)local tH=dg(tG:get(),0,1)rL=dg(rL+tH,0,1)end;local tR=-rL*(aO*cF+aP*rP)d:setEngineForceCommand('brake',tR)local tI=''local tJ=vec3()local tS=false;local tL='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tL=tL..aT end;local tM=ik:getAxisCommandType(axisCommandId.longitudinal)if tM==axisCommandType.byThrottle then local tN=ik:composeAxisAccelerationFromThrottle(tL,axisCommandId.longitudinal)d:setEngineForceCommand(tL,tN,rZ)elseif tM==axisCommandType.byTargetSpeed then local tN=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tI=tI..' , '..tL;tJ=tJ+tN;if ik:getTargetSpeed(axisCommandId.longitudinal)==0 or ik:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ik:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tS=true end end;local tQ='thrust analog lateral 'if bA=="All"or bA=="Lateral"then tQ=tQ..aU end;local tT=ik:getAxisCommandType(axisCommandId.lateral)if tT==axisCommandType.byThrottle then local tU=ik:composeAxisAccelerationFromThrottle(tQ,axisCommandId.lateral)d:setEngineForceCommand(tQ,tU,rZ)elseif tT==axisCommandType.byTargetSpeed then local tO=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tI=tI..' , '..tQ;tJ=tJ+tO end;local tP='thrust analog vertical 'if bA=="All"or bA=="Vertical"then tP=tP..aV end;local tV=ik:getAxisCommandType(axisCommandId.vertical)if tV==axisCommandType.byThrottle then local tK=ik:composeAxisAccelerationFromThrottle(tP,axisCommandId.vertical)if bU~=0 or b4 and aZ then d:setEngineForceCommand(tP,tK,rZ,'airfoil','ground','',s0)else d:setEngineForceCommand(tP,vec3(),rZ)d:setEngineForceCommand('airfoil vertical',tK,rZ,'airfoil','','',s0)d:setEngineForceCommand('ground vertical',tK,rZ,'ground','','',s0)end elseif tV==axisCommandType.byTargetSpeed then if bU<0 then d:setEngineForceCommand('hover',vec3(),rZ)end;local tW=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tI=tI..' , '..tP;tJ=tJ+tW end;if tJ:len()>constants.epsilon then if rL~=0 or tS or eU(rP:dot(cC))<0.5 then tI=tI..', brake'end;d:setEngineForceCommand(tI,tJ,r_,'','','',s0)end end;local tX=aL*(rT-rS)local tY=vec3(b.getWorldAirFrictionAngularAcceleration())tX=tX-tY;d:setEngineTorqueCommand('torque',tX,rZ,'airfoil','','',s0)d:setBoosterCommand('rocket_engine')if bZ and not n then local fl=cE:len()local tZ=0.15;if not cM then local t_=ik:getTargetSpeed(axisCommandId.longitudinal)if fl*3.6>t_*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl*3.6<t_*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end else local ra=c.getThrottle()if t then ra=bL*100 end;local rm=ra/100;if not c9 then rm=rm*a8;if fl>=rm*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl<rm*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end else local t5=bI(cw)rm=rm*t5/3.6;if fl>=rm*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl<rm*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end end end end end;if u1 then for dG,ds in pairs(u1)do py[dG]=ds end end;c8=qu()return py end;local function u2(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u3,ij,ik,il,u4,gI,fR,d_,dh,dg,fQ,io,px)local u5={}local u6=true;local u7=5;local u8=5;local u9=u7;local ua=u8;local ub=bK;function u5.landingGear()bk=not bk;if bk then bo=false;br=nil;co.cmdThrottle(0)if vBooster or hover then if c9 and c8==-1 then fQ("bklOn","BL")ln=true;b6=false;b5=false;b7=false;b3=false;if b4 then d6=not d6 end;b4=true;cu=true;bk=false else if bQ then fQ("grOut","LG",1)d.control.extendLandingGears()end;d6=false;ik:setTargetGroundAltitude(Y)if c9 then aZ="Landing"end end elseif bQ and not b4 then fQ("grOut","LG",1)d.control.extendLandingGears()end else if bQ then fQ("grIn","LG",1)d.control.retractLandingGears()end;ik:activateGroundEngineAltitudeStabilization(uc)if bz then if Y<ik.targetGroundAltitude then ik:setTargetGroundAltitude(ik.targetGroundAltitude)else ik:setTargetGroundAltitude(X)end end end end;function u5.startControl(ud)local function ue(r5)local r6=1;local function uf(ug,r5)local uh={kg.surfaceMaxAltitude+100,kg.spaceEngineMinAltitude-0.01*kg.noAtmosphericDensityAltitude,kg.noAtmosphericDensityAltitude+T,kg.radius*(S-1)+kg.noAtmosphericDensityAltitude}local ui=ug;for dL,ds in ipairs(uh)do if r5 and ui>ds then ug=ds elseif ug<ds and not r5 then ug=ds;break end end;return ug end;if r5 then r6=-1 end;if not q and cL then if bW and r5 then bt=1000 elseif bt~=nil then bt=bt+r6*u8;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end else bt=tC+r6*100 end elseif b3 or b7 or bx then if bx then if bW then cy=uf(cy,r5)else cy=cy+r6*u7 end;if cy<kg.noAtmosphericDensityAltitude then cy=kg.noAtmosphericDensityAltitude end else if bW and c9 then b8=uf(b8,r5)else b8=b8+r6*u7 end end else ik:updateTargetGroundAltitudeFromActionStart(r6*1.0)end end;local function uj(uk)if not c9 then bX="Flight Assist in Atmo only"return end;local dp=type(uk)if cS==nil then if dp=="table"then if b1 or bo then co.ToggleAutopilot()end;fQ("180On","BR")elseif uk==1 then fQ("bnkLft","BR")else fQ("bnkRht","BR")end;if not b3 and not b1 and not bo then co.ToggleAltitudeHold()if dp~="table"then uk=uk+1 end end;cS=uk else fQ("180Off","BR")cS=nil end end;if ud=="gear"then cq.landingGear()elseif ud=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ud=="forward"then if o_ and not c9 and not b1 then b0=not b0;a_=false else bR=bR-1 end elseif ud=="backward"then if o_ then if not c9 then if not b1 then a_=not a_;b0=false else b2=not b2 end else uj(-cF*5000)end else bR=bR+1 end elseif ud=="left"then if o_ then uj(1)else bS=bS-1 end elseif ud=="right"then if o_ then uj(3)else bS=bS+1 end elseif ud=="yawright"then bT=bT-1;d7=nil elseif ud=="yawleft"then bT=bT+1;d7=nil elseif ud=="straferight"then ik:updateCommandFromActionStart(axisCommandId.lateral,1.0)bw=1 elseif ud=="strafeleft"then ik:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bw=-1 elseif ud=="up"then bU=bU+1;if c8-3<Y and cb>0 and bk then cq.landingGear()end;ik:deactivateGroundEngineAltitudeStabilization()ik:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ud=="down"then bU=bU-1;ik:deactivateGroundEngineAltitudeStabilization()ik:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ud=="groundaltitudeup"then ue()elseif ud=="groundaltitudedown"then ue(true)elseif ud=="option1"then ul=false;if o_ and bW then local um=""for K=1,#cY do um=um.."| Name: "..a.getPlayerName(cY[K]).." Mass: "..fR(b.getBoardedPlayerMass(cY[K])/1000,1).."t "end;a.print("Onboard: "..um)return end;cn.adjustAutopilotTargetIndex()elseif ud=="option2"then ul=false;if o_ and bW then for K=1,#cY do b.forceDeboard(cY[K])b.forceInterruptVRSession(cY[K])end;bX="Deboarded All Passengers"return end;cn.adjustAutopilotTargetIndex(1)elseif ud=="option3"then local function un()u6=not u6;if not u6 then fQ("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(uo,atmofueltank_size,"Atmo Fuel","fuel_container")up=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uq,spacefueltank_size,"Space Fuel","fuel_container")ur=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(us,rocketfueltank_size,"Rocket Fuel","fuel_container")ut=_autoconf.panels[_autoconf.panels_size]end;uu=a.createWidgetPanel("Docking")uv=a.createWidget(uu,"parenting")a.addDataToWidget(c.getDataId(),uv)uw=a.createWidgetPanel("Core combat stress")ux=a.createWidget(uw,"core_stress")a.addDataToWidget(b.getDataId(),ux)if shield~=nil then shield.show()end else fQ("hud","DH")c.hide()b.hide()if up~=nil then gI(up)up=nil end;if uu~=nil then gI(uu)uu=nil end;if uw~=nil then gI(uw)uw=nil end;if ur~=nil then gI(ur)ur=nil end;if ut~=nil then gI(ut)ut=nil end;if shield~=nil then shield.hide()end end end;ul=false;if o_ and bW then local um=""for K=1,#cZ do um=um.."| ID: "..cZ[K].." Mass: "..fR(b.getDockedConstructMass(cZ[K])/1000,1).."t "end;a.print("Docked Ships: "..um)return end;if x then if w then w=false else w=true end end;un()elseif ud=="option4"then ul=false;if o_ and bW then for K=1,#cZ do b.forceUndock(cZ[K])end;bX="Undocked all ships"return end;cS=nil;co.ToggleAutopilot()elseif ud=="option5"then ul=false;co.ToggleLockPitch()elseif ud=="option6"then ul=false;if o_ and bW then if shield then cr.ventShield()else bX="No shield found"end;return end;co.ToggleAltitudeHold()elseif ud=="option7"then ul=false;if o_ and bW then if shield then shield.toggle()return else bX="No shield found"return end end;E=not E;if E then bX="Collision System Enabled"else bX="Collision System Secured"end elseif ud=="option8"then ul=false;if o_ and bW then if bj>0 and g1~=nil then co.routeWP()else bX="Select a saved wp on IPH to add to or remove from route"end;return end;bz=not bz;if not bz then bX="DeCoupled Mode - Ground Stabilization off"ik:deactivateGroundEngineAltitudeStabilization()fQ("gsOff","GS")else bX="Coupled Mode - Ground Stabilization on"ik:activateGroundEngineAltitudeStabilization(uc)d9=true;fQ("gsOn","GS")end elseif ud=="option9"then ul=false;if o_ and bW then ik:resetCommand(axisCommandId.longitudinal)ik:resetCommand(axisCommandId.lateral)ik:resetCommand(axisCommandId.vertical)co.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cd=gyro.getState()==1;if cd then fQ("gyOn","GA")else fQ("gyOff","GA")end else bX="No gyro found"end elseif ud=="lshift"then cW=false;if o_ then bW=true end;if il()==1 then bW=true;bg=il()u4(1)elseif ij()==1 and y then bW=true;ct=false;cs=false end elseif ud=="brake"then if aX or o_ then co.BrakeToggle("Manual")elseif not aZ then co.BrakeToggle("Manual")else aZ="Manual"end elseif ud=="lalt"then ul=true;o_=true;if ij()==0 and not i and g=="keyboard"then u4(1)end elseif ud=="booster"then if n then d:toggleBoosters()elseif not bZ then if not u0 then d:toggleBoosters()u0=true end;bZ=true else if u0 then d:toggleBoosters()u0=false end;bZ=false end elseif ud=="stopengines"then local function uy()if bK-ub<1.5 then fQ("clear","CA")co.clearAll()end end;uy()ub=bK;if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bL~=0 then ik:resetCommand(axisCommandId.longitudinal)co.cmdThrottle(0)else co.cmdThrottle(100)end else if ik:getTargetSpeed(axisCommandId.longitudinal)~=0 then ik:resetCommand(axisCommandId.longitudinal)else if c9 then co.cmdCruise(cw)else co.cmdCruise(a8*3.6)end end end elseif ud=="speedup"then co.changeSpd()elseif ud=="speeddown"then co.changeSpd(true)elseif ud=="antigravity"and not q then if antigrav~=nil then co.ToggleAntigrav()else bX="No antigrav found"end end end;function u5.stopControl(ud)local function uz()if not q and cL then ua=u8 end;if b3 or b7 or bx then u9=u7 end end;if ud=="forward"then bR=0 elseif ud=="backward"then bR=0 elseif ud=="left"then if cS then if cS==2 then cS=-2 else cS=-1 end end;bS=0 elseif ud=="right"then if cS then if cS==4 then cS=-2 else cS=-1 end end;bS=0 elseif ud=="yawright"then bT=0 elseif ud=="yawleft"then bT=0 elseif ud=="straferight"then ik:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bw=0 elseif ud=="strafeleft"then ik:updateCommandFromActionStop(axisCommandId.lateral,1.0)bw=0 elseif ud=="up"then bU=0;ik:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bz then ik:activateGroundEngineAltitudeStabilization(uc)d9=true end elseif ud=="down"then bU=0;ik:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bz then ik:activateGroundEngineAltitudeStabilization(uc)d9=true end elseif ud=="groundaltitudeup"then uz()ul=false elseif ud=="groundaltitudedown"then uz()ul=false elseif ud=="lshift"then if il()==1 then c2=0;c3=0;u4(bg)elseif ij()==1 and y then ct=false;cs=false end;bW=false elseif ud=="brake"then if not aX and not o_ then if aZ then co.BrakeToggle()else aZ=false end end elseif ud=="lalt"then if ij()==0 and i then if ul then if il()==1 then u4(0)else u4(1)end else ul=true end elseif ij()==0 and not i and g=="keyboard"then u4(0)end;o_=false end end;function u5.loopControl(ud)local function uA(r5)local r6=1;if r5 then r6=-1 end;if not q and cL then if bt~=nil then bt=bt+r6*ua;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end;ua=dg(ua*1.05,u8,50)else bt=tC+r6*100 end elseif b3 or b7 or bx then if bx then cy=cy+r6*u9;if cy<kg.noAtmosphericDensityAltitude then cy=kg.noAtmosphericDensityAltitude end else b8=b8+r6*u9 end;u9=dg(u9*1.05,u7,50)else ik:updateTargetGroundAltitudeFromActionLoop(r6*1.0)end end;local function uB(r5)local r6=1;if r5 then r6=-1 end;if not bW then if t and not o_ then bL=dg(bL+r6*aD/100,-1,1)else ik:updateCommandFromActionLoop(axisCommandId.longitudinal,r6*aD)end end end;if ud=="groundaltitudeup"then if not bW then uA()end elseif ud=="groundaltitudedown"then if not bW then uA(true)end elseif ud=="speedup"then uB()elseif ud=="speeddown"then uB(true)end end;function u5.inputTextControl(r4)local function uC(uD,fr,gv)local function uE(fr)local dy=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dz='::pos{'..dy..','..dy..','..dy..','..dy..','..dy..'}'local dP,dQ,dX,dY,dZ=d_(fr,dz)if dP=="0"and dQ=="0"then return vec3(dh(dX),dh(dY),dh(dZ))end;dY=math.rad(dY)dX=math.rad(dX)local kg=e[dh(dP)][dh(dQ)]local eQ=math.cos(dX)local uF=vec3(eQ*math.cos(dY),eQ*math.sin(dY),math.sin(dX))return kg.center+(kg.radius+dZ)*uF end;local fT=uE(fr)return cn.AddNewLocation(uD,fT,gv)end;local K;local uG,i7=nil,nil;local uH="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(r4," ")uG=r4;if K~=nil then uG=string.sub(r4,0,K-1)i7=string.sub(r4,K+1)end;if uG=="/help"or uG=="/commands"then for lo in string.gmatch(uH,"([^\n]+)")do a.print(lo)end;return elseif uG=="/setname"then if i7==nil or i7==""then bX="Usage: ah-setname Newname"return end;if bj>0 and g1~=nil then cn.UpdatePosition(i7)else bX="Select a saved target to rename first"end elseif shield and uG=="/resist"then cr.setResist(i7)elseif uG=="/addlocation"or string.find(r4,"::pos")~=nil then local gv=false;local uD="0-Temp"if i7==nil or i7==""or uG~="/addlocation"then i7=uG;gv=true end;K=string.find(i7,"::")if not gv then uD=string.sub(i7,1,K-2)end;local fr=string.sub(i7,K)uC(uD,fr,gv)elseif uG=="/agg"then if i7==nil or i7==""then bX="Usage: /agg targetheight"return end;i7=dh(i7)if i7<1000 then i7=1000 end;bt=i7;bX="AGG Target Height set to "..i7 elseif uG=="/G"then if i7==nil or i7==""then bX="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if i7=="dump"then for dG,ds in pairs(io())do if type(ds.get())=="boolean"then if ds.get()==true then a.print(dG.." true")else a.print(dG.." false")end elseif ds.get()==nil then a.print(dG.." nil")else a.print(dG.." "..ds.get())end end;return end;K=string.find(i7," ")local uI=string.sub(i7,0,K-1)local uJ=string.sub(i7,K+1)for dG,ds in pairs(io())do if dG==uI then local uK=type(ds.get())if uK=="number"then uJ=dh(uJ)if dG=="AtmoSpeedLimit"then cw=uJ end end;bX="Variable "..uI.." changed to "..uJ;if dG=="MaxGameVelocity"then uJ=uJ/3.6;if uJ>da-0.2 then uJ=da-0.2;bX="Variable "..uI.." changed to "..fR(uJ*3.6,1)end end;if uK=="boolean"then if string.lower(uJ)=="true"then uJ=true else uJ=false end end;ds.set(uJ)return end end;bX="No such global variable: "..uI elseif uG=="/deletewp"then if bj>0 and g1~=nil then cn.ClearCurrentPosition()else bX="Select a custom wp to delete first in IPH"end elseif uG=="/copydatabank"then if dbHud_2 then px(true)else bX="Spare Databank required to copy databank"end elseif uG=="/iphWP"then if bj>0 then a.print(co.showWayPoint(c1,bi,true))a.print(json.encode(bi))bX="::pos waypoint shown in lua chat in local and world format"else bX="No target selected in IPH"end elseif uG=="/createPrivate"then local uL="privatelocations = {\n"local uM=""if#d4>0 then for dG,ds in pairs(d4)do uL=uL.."{position = {x = "..ds.position.x..", y = "..ds.position.y..", z = "..ds.position.z.."},\n ".."name = '"..ds.name.."',\n planetname = '"..ds.planetname.."',\n gravity = "..ds.gravity..",\n"if ds.heading then uL=uL.."heading = {x = "..ds.heading.x..", y = "..ds.heading.y..", z = "..ds.heading.z.."},\n"end;if ds.safe then uL=uL.."safe = true},\n"else uL=uL.."safe = false},\n"end end end;uM=#d4 .."-Private "if i7=="all"then for dG,ds in pairs(bn)do uL=uL.."{position = {x = "..ds.position.x..", y = "..ds.position.y..", z = "..ds.position.z.."},\n ".."name = '*"..ds.name.."',\n planetname = '"..ds.planetname.."',\n gravity = "..ds.gravity..",\n"if ds.heading then uL=uL.."heading = {x = "..ds.heading.x..", y = "..ds.heading.y..", z = "..ds.heading.z.."},\n"end;if ds.safe then uL=uL.." safe = true},\n"else uL=uL.."safe = false},\n"end end;uM=uM..#bn.."-Public "end;uL=uL.."}\n return privatelocations"if u3 then u3.setHTML(uL)end;bX=uM.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bY=7 end end;function u5.tagTick()if bA=="Off"then bA="All"elseif bA=="All"then bA="Longitude"elseif bA=="Longitude"then bA="Lateral"elseif bA=="Lateral"then bA="Vertical"else bA="Off"end;bX="Extra Engine Tags: "..bA;c.stopTimer("tagTick")end;if uN then for dG,ds in pairs(uN)do u5[dG]=ds end end;return u5 end;local function uO(d,b,c,a,library,e,vBooster,hover,pw,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ig,u3)local uP={}local df=string.format;local ih=json.decode;local uQ=json.encode;local pp=b.getElementMaxHitPointsById;local ii=b.getElementMassById;local ij=d.control.isRemoteControlled;local d_=string.match;local gI=a.destroyWidgetPanel;local fO=a.updateData;local fP=a.addDataToWidget;local u4=a.lockView;local il=a.isViewLocked;local di=math.sqrt;local dh=tonumber;local eU=math.abs;local bI=math.floor;local bJ=c.getAtmosphereDensity;local eP=math.atan;local bH=a.getArkTime;local dg=utils.clamp;local ik=d.axisCommandManager;local uR=Y;local gK=13;local ir=b.getElementIdList()local is=0;local function dj(ex,ey)if ex==0 then return eU(ey)<1e-09 end;if ey==0 then return eU(ex)<1e-09 end;return eU(ex-ey)<math.max(eU(ex),eU(ey))*dx end;local function fR(dy,uS)local r6=10^(uS or 0)return bI(dy*r6+0.5)/r6 end;local function im(uT,uU)for dG,ds in pairs(uU)do if type(dG)=="string"then uT[dG]=ds else uT[#uT+1]=uU[dG]end end;return uT end;local function io(uV)local uW={}if not uV then im(uW,J)im(uW,a7)im(uW,aB)im(uW,aW)return uW elseif uV=="boolean"then return J elseif uV=="handling"then return a7 elseif uV=="hud"then return aB elseif uV=="physics"then return aW end end;local function px(uX)local function uY(uZ)for dG,ds in pairs(uZ)do dbHud_1.setStringValue(dG,uQ(ds.get()))if uX and dbHud_2 then dbHud_2.setStringValue(dG,uQ(ds.get()))end end end;if dbHud_1 then uY(bE)uY(io())a.print("Saved Variables to Datacore")if uX and dbHud_2 then bX="Databank copied.  Remove copy when ready."end end end;local function fQ(u_,v0,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..u_..".mp3")end;local function gJ(hl,hm,r4,jy,v1)if jy==nil then jy=""end;if v1==nil then v1=""end;return df([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jy,hl,hm,v1,r4)end;local function ip(c4,v2)local v3=c4>100000;if v2==nil then v2=1 end;if v3 then return fR(c4/1000/200,v2).."SU"elseif c4<1000 then return fR(c4,v2).."M"else return fR(c4/1000,v2).."KM"end end;local function iq(v4)local v5=0;local v6=0;local v7=0;if v4<60 then v4=bI(v4)elseif v4<3600 then v5=bI(v4/60)v4=bI(v4%60)elseif v4<86400 then v6=bI(v4/3600)v5=bI(v4%3600/60)else v7=bI(v4/86400)v6=bI(v4%86400/3600)end;if v7>0 then return v7 .."d "..v6 .."h "elseif v6>0 then return v6 .."h "..v5 .."m "elseif v5>0 then return v5 .."m "..v4 .."s"elseif v4>0 then return v4 .."s"else return"0s"end end;function uP.onStart()local v8=false;local function v9()local function va(vb)local vc=dbHud_1.hasKey;for dG,ds in pairs(vb)do if vc(dG)then local dB=ih(dbHud_1.getStringValue(dG))if dB~=nil then ds.set(dB)v8=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then va(io())coroutine.yield()va(bE)else va(bE)bX="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bY=5;v8=false end;coroutine.yield()if v8 then bX="Loaded Saved Variables"ce=a9;cf=aa;aX=j;g=string.lower(g)cu=p;cw=U elseif not f then bX="No Saved Variables Found - Exit HUD to save settings"end;if bB<1.500 then if T<2000 then bX="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bB=VERSION_NUMBER;if#bn>0 then d5=im(d5,bn)end else bX="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bu+180<bK then bs=0 end;bu=bK;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bX="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bY=7 end;if antigrav and not q then if bt==nil then bt=cb end;antigrav.setBaseAltitude(bt)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d4>0 then d5=im(d5,d4)end end;lw="Proceeding to Waypoint"if a8<0 then a8=b.getMaxSpeed()-0.1 end end;local function vd()local function ve(vf,vg)if vf>vg then vg=vf end;local vh,vi=0,0;if a4>0 then vh=a4*0.05 end;if a5>0 then vi=a5*0.05 end;vg=vg*(1-(vh+vi))return vg end;local vj=b.getElementNameById;local vk=aq~=0 and ar~=0;local vl=_G["atmofueltank_size"]local vm=_G["spacefueltank_size"]local vn=_G["rocketfueltank_size"]for dG in pairs(ir)do local type=b.getElementTypeById(ir[dG])if d_(type,'^.*Atmospheric Engine$')then if d_(tostring(b.getElementTagsById(ir[dG])),'^.*vertical.*$')and b.getElementForwardById(ir[dG])[3]>0 then cK=true end end;if d_(type,'^.*Space Engine$')then cB=true;if d_(tostring(b.getElementTagsById(ir[dG])),'^.*vertical.*$')then local vo=b.getElementForwardById(ir[dG])if vo[3]<0 then vp=true else cA=true end end end;if type=="Landing Gear"then bQ=true end;if type=="Dynamic Core Unit"then local pr=pp(ir[dG])if pr>10000 then gK=110 elseif pr>1000 then gK=55 elseif pr>150 then gK=27 end end;is=is+pp(ir[dG])if vk and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pr=pp(ir[dG])local om=ii(ir[dG])local vf=0;local jr=bH()if type=="Atmospheric Fuel Tank"then local vg=400;local vq=35.03;if pr>10000 then vg=51200;vq=5480 elseif pr>1300 then vg=6400;vq=988.67 elseif pr>150 then vg=1600;vq=182.67 end;vf=om-vq;if a1>0 then vg=vg+vg*a1*0.2 end;vg=ve(vf,vg)local gu=vj(ir[dG])local jp=0;for jq=1,vl do if gu==ih(c["atmofueltank_"..jq].getData()).name then jp=jq;break end end;local vr={ir[dG],string.sub(gu,1,12),vg,vq,vf,jr,jp}cg[#cg+1]=vr end;if type=="Rocket Fuel Tank"then local vg=320;local vq=173.42;if pr>65000 then vg=40000;vq=25740 elseif pr>6000 then vg=5120;vq=4720 elseif pr>700 then vg=640;vq=886.72 end;vf=om-vq;if a3>0 then vg=vg+vg*a3*0.1 end;vg=ve(vf,vg)local gu=vj(ir[dG])local jp=0;for jq=1,vn do if gu==ih(c["rocketfueltank_"..jq].getData()).name then jp=jq;break end end;local vr={ir[dG],string.sub(gu,1,12),vg,vq,vf,jr,jp}ci[#ci+1]=vr end;if type=="Space Fuel Tank"then local vg=600;local vq=35.03;if pr>10000 then vg=76800;vq=5480 elseif pr>1300 then vg=9600;vq=988.67 elseif pr>150 then vg=2400;vq=182.67 end;vf=om-vq;if a2>0 then vg=vg+vg*a2*0.2 end;vg=ve(vf,vg)local gu=vj(ir[dG])local jp=0;for jq=1,vm do if gu==ih(c["spacefueltank_"..jq].getData()).name then jp=jq;break end end;local vr={ir[dG],string.sub(gu,1,12),vg,vq,vf,jr,jp}ch[#ch+1]=vr end end end;if not cK then b7,aY=false,false end end;local function vs()if gyro~=nil then cd=gyro.getState()==1 end;if not bz then ik:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u4(1)else u4(0)end;if door and(c9 or not c9 and cb<10000)then for dL,ds in pairs(door)do ds.toggle()end end;if switch then for dL,ds in pairs(switch)do ds.toggle()end end;if forcefield and(c9 or not c9==0 and cb<10000)then for dL,ds in pairs(forcefield)do ds.toggle()end end;if antigrav then cL=antigrav.getState()==1;if cL and not q then antigrav.show()end end;if ij()==1 and k then a.freeze(1)else a.freeze(0)end;if bQ then if c8~=-1 and not cL then d.control.extendLandingGears()else d.control.retractLandingGears()end end;bk=d.control.isAnyLandingGearExtended()==1 or c8~=-1 and c8-3<Y;if c8~=-1 or not c9 and cE:len()<50 then aZ="Startup"else aZ=false end;ik:setTargetGroundAltitude(uR)pd=c9 end;local function vt()local vu={}local function vv()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vw={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vx={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vy,vz in pairs(e)do e[vy][0]=vv()e[vy][0].systemId=vy;vu[vy]={}for vA,kg in pairs(e[vy])do kg.gravity=kg.gravity/9.8;kg.center=vec3(kg.center)kg.name=kg.name[1]kg.noAtmosphericDensityAltitude=vx[kg.id]or kg.atmosphereThickness or kg.atmosphereRadius-kg.radius;kg.spaceEngineMinAltitude=vw[kg.id]or 0.68377*kg.atmosphereThickness;kg.planetarySystemId=vy;kg.bodyId=kg.id;vu[vy][vA]=kg;if mo==nil or kg.center.x<mo then mo=kg.center.x end;if mn==nil or kg.center.x>mn then mn=kg.center.x end;if mr==nil or kg.center.y<mr then mr=kg.center.y end;if mq==nil or kg.center.y>mq then mq=kg.center.y end;if kg.center and kg.name~="Space"then c_[#c_+1]=kg end end end;e9=de(d,b,c,a,df,dg,dh,di,dj)cj=e9(vu)ck=eT(d,b,c,a,di,eU)cl=fn(d,b,c,a,df,dg,dh,di,dj)cn=fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dh,di,fQ,fR)kg=cj[0]:closestBody(b.getConstructWorldPos())end;vB=false;vC=coroutine.create(function()ik:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v9()coroutine.yield()vd()coroutine.yield()co=pv(d,b,c,a,e,vBooster,hover,pw,antigrav,warpdrive,dbHud_1,eU,bI,bJ,ij,eP,bH,dg,ik,fO,il,di,fR,fQ,im,dj,ip,iq,px,ih,df,fP)vs()coroutine.yield()vt()if radar_1 then cp=gH(b,a,c,library,radar_1,radar_2,eU,gI,di,gJ,dh,gK,fQ)end;if ie then cm=ie(d,b,c,a,e,antigrav,hover,shield,warpdrive,ig,eU,bI,df,ih,bJ,ii,ij,eP,bH,dg,ik,fP,fO,gI,il,di,fR,gJ,fQ,im,io,ip,iq,ir,is)end;if cm then cm.ButtonSetup()end;cq=u2(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u3,ij,ik,il,u4,gI,fR,d_,dh,dg,fQ,io,px)if shield then cr=hZ(shield,d_,bI)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if u3 then u3.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aR)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vD then vE.ExtraOnStart()end;fQ("start","SU")end)coroutine.resume(vC)end;function uP.onUpdate()if not vB then local hR=coroutine.status(vC)if hR=="suspended"then local dH,hS=coroutine.resume(vC)if hS then a.print("ERROR STARTUP: "..hS)end elseif hR=="dead"then vB=true end end;if vB then d:update()if c9 and t and cM then if cM and bP then co.cmdThrottle(0)bP=false elseif not cM and not bP then bL=0;bP=true end end;if d2 then ik:setThrottleCommand(axisCommandId.longitudinal,d2)d2=nil end;if not cs and p1~=vF then a.setScreen(p1)end;vF=p1;if vD then vE.ExtraOnUpdate()end end end;function uP.onFlush()if vB then co.onFlush()if vD then vE.ExtraOnFlush()end end end;function uP.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ca>0 or ca==0 and cb<10000)then for dL,ds in pairs(door)do ds.toggle()end end;if switch then for dL,ds in pairs(switch)do ds.toggle()end end;if forcefield and(ca>0 or ca==0 and cb<10000)then for dL,ds in pairs(forcefield)do ds.toggle()end end;w=d1;px()if nX then nX.activate()end;if z then co.showWayPoint(kg,cJ)end;if cm then a.print(cm.FuelUsed("atmofueltank")..", "..cm.FuelUsed("spacefueltank")..", "..cm.FuelUsed("rocketfueltank"))end;if vD then vE.ExtraOnStop()end;fQ("stop","SU")end;function uP.controlStart(ud)if vB then cq.startControl(ud)end end;function uP.controlStop(ud)if vB then cq.stopControl(ud)end end;function uP.controlLoop(ud)if vB then cq.loopControl(ud)end end;function uP.controlInput(r4)if vB then cq.inputTextControl(r4)end end;function uP.radarEnter(dQ)if cp then cp.onEnter(dQ)end end;function uP.radarLeave(dQ)if cp then cp.onLeave(dQ)end end;function uP.onTick(vG)if vG=="tenthSecond"then co.TenthTick()if cm then cm.TenthTick()end elseif vG=="oneSecond"then if cm then cm.OneSecondTick()end elseif vG=="fiveSecond"then co.SatNavTick()elseif vG=="msgTick"then if cm then cm.MsgTick()end elseif vG=="animateTick"then if cm then cm.AnimateTick()end elseif vG=="hudTick"then if cm then cm.hudtick()end elseif vG=="apTick"then co.APTick()elseif vG=="shieldTick"then cr.shieldTick()elseif vG=="tagTick"then cq.tagTick()elseif vG=="contact"then cp.ContactTick()end end;if vD then for dG,ds in pairs(vD)do uP[dG]=ds end end;return uP end;function script.onStart()vE.onStart()end;function script.onStop()vE.onStop()end;function script.onTick(vG)vE.onTick(vG)end;function script.onFlush()vE.onFlush()end;function script.onUpdate()vE.onUpdate()end;function script.onActionStart(ud)vE.controlStart(ud)end;function script.onActionStop(ud)vE.controlStop(ud)end;function script.onActionLoop(ud)vE.controlLoop(ud)end;function script.onInputText(r4)vE.controlInput(r4)end;function script.onEnter(dQ)vE.radarEnter(dQ)end;function script.onLeave(dQ)vE.radarLeave(dQ)end;bG(a,b,c,a.getArkTime,math.floor,c.getAtmosphereDensity)vE=uO(d,b,c,a,library,e,vBooster,hover,pw,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ig,u3)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua:       if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua:       if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua:       if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
