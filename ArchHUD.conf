name: ArchHud - Archaegeo v0.010 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.010;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.3;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab=1;ac={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end},DockingMode={set=function(M)ab=M end,get=function()return ab end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV=1.0;aW="none"aX="none"aY="none"aZ={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aV=M end,get=function()return aV end},ExtraLongitudeTags={set=function(M)aW=M end,get=function()return aW end},ExtraLateralTags={set=function(M)aX=M end,get=function()return aX end},ExtraVerticalTags={set=function(M)aY=M end,get=function()return aY end}}a_=k;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=1000;bc=false;bd=false;be=false;bf=false;bg=0;bh="Aligning"bi=0;bj=1;bk="None"bl=nil;bm=0;bn=nil;bo=0.0;bp=0;bq={}br=false;bs=0;bt=0;bu=nil;bv=0;bw=1000;bx=0;by=false;bz=0;bA=false;bB="All"bC=true;bD="Off"bE=0.000;bF={}bG={}bH={}bI=false;bJ={VertTakeOff={set=function(M)ba=M end,get=function()return ba end},VertTakeOffEngine={set=function(M)b0=M end,get=function()return b0 end},SpaceTarget={set=function(M)by=M end,get=function()return by end},BrakeToggleStatus={set=function(M)a_=M end,get=function()return a_ end},BrakeIsOn={set=function(M)b1=M end,get=function()return b1 end},RetrogradeIsOn={set=function(M)b2=M end,get=function()return b2 end},ProgradeIsOn={set=function(M)b3=M end,get=function()return b3 end},Autopilot={set=function(M)b4=M end,get=function()return b4 end},TurnBurn={set=function(M)b5=M end,get=function()return b5 end},AltitudeHold={set=function(M)b6=M end,get=function()return b6 end},BrakeLanding={set=function(M)b7=M end,get=function()return b7 end},Reentry={set=function(M)b9=M end,get=function()return b9 end},AutoTakeoff={set=function(M)b8=M end,get=function()return b8 end},HoldAltitude={set=function(M)bb=M end,get=function()return bb end},AutopilotAccelerating={set=function(M)bc=M end,get=function()return bc end},AutopilotBraking={set=function(M)be=M end,get=function()return be end},AutopilotCruising={set=function(M)bf=M end,get=function()return bf end},AutopilotRealigned={set=function(M)bd=M end,get=function()return bd end},AutopilotEndSpeed={set=function(M)bg=M end,get=function()return bg end},AutopilotStatus={set=function(M)bh=M end,get=function()return bh end},AutopilotPlanetGravity={set=function(M)bi=M end,get=function()return bi end},PrevViewLock={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetName={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetCoords={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetIndex={set=function(M)bm=M end,get=function()return bm end},TotalDistanceTravelled={set=function(M)bo=M end,get=function()return bo end},TotalFlightTime={set=function(M)bp=M end,get=function()return bp end},SavedLocations={set=function(M)bq=M end,get=function()return bq end},VectorToTarget={set=function(M)br=M end,get=function()return br end},LocationIndex={set=function(M)bs=M end,get=function()return bs end},LastMaxBrake={set=function(M)bt=M end,get=function()return bt end},LockPitch={set=function(M)bu=M end,get=function()return bu end},LastMaxBrakeInAtmo={set=function(M)bv=M end,get=function()return bv end},AntigravTargetAltitude={set=function(M)bw=M end,get=function()return bw end},LastStartTime={set=function(M)bx=M end,get=function()return bx end},iphCondition={set=function(M)bB=M end,get=function()return bB end},stablized={set=function(M)bC=M end,get=function()return bC end},UseExtra={set=function(M)bD=M end,get=function()return bD end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bF=M end,get=function()return bF end},apRoute={set=function(M)bG=M end,get=function()return bG end},ecuThrottle={set=function(M)bH=M end,get=function()return bH end},HoverMode={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=q;cA=false;cB=W;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2={}d3={}d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()if shield then dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dh(di)a.print(bQ..": "..di)end;local function dj(d,b,c,a,dk,dl,dm,dn,dp)local function dq(dr)return type(dr)=='number'end;local function ds(dr)return type(dm(dr))=='number'end;local function dt(du)return type(du)=='table'end;local function dv(a)return type(a)=='string'end;local function dw(dx)return dt(dx)and dq(dx.x and dx.y and dx.z)end;local function dy(dz)return dt(dz)and dq(dz.latitude and dz.longitude and dz.altitude and dz.id and dz.systemId)end;local dA=math.pi/180;local dB=180/math.pi;local dC=1e-10;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local utils=utils;local vec3=vec3;local function dF(dr)local dG=string.gsub(string.reverse(dk('%.4f',dr)),'^0*%.?','')return dG==''and'0'or string.reverse(dG)end;local function dH(dI)if dw(dI)then return dk('{x=%.3f,y=%.3f,z=%.3f}',dI.x,dI.y,dI.z)end;if dt(dI)and not getmetatable(dI)then local dJ={}local dK=next(dI)if type(dK)=='nil'or dK==1 then dJ=dI else for dL,dx in pairs(dI)do local dM=dH(dx)if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end end;return dk('{%s}',table.concat(dJ,','))end;if dv(dI)then return dk("'%s'",dI:gsub("'",[[\']]))end;return tostring(dI)end;local dN={}dN.__index=dN;dN.__tostring=function(dI,dO)local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)local dJ={}for dQ,dL in ipairs(dP)do local dM=dH(dI[dL])if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end;if dO then return dk('%s%s',dO,table.concat(dJ,',\n'..dO))end;return dk('{%s}',table.concat(dJ,','))end;dN.__eq=function(dR,dS)return dR.systemId==dS.systemId and dR.id==dS.id and dp(dR.radius,dS.radius)and dp(dR.center.x,dS.center.x)and dp(dR.center.y,dS.center.y)and dp(dR.center.z,dS.center.z)and dp(dR.GM,dS.GM)end;local function dT(dU,dV,dW,dX,dY)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(dW),'Argument 3 (radius) must be a number:'..type(dW))assert(dt(dX),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dX))assert(ds(dY),'Argument 5 (GM) must be a number:'..type(dY))return setmetatable({systemId=dm(dU),id=dm(dV),radius=dm(dW),center=vec3(dX),GM=dm(dY)},dN)end;local dZ={}dZ.__index=dZ;dZ.__tostring=function(dh)return dk('::pos{%d,%d,%s,%s,%s}',dh.systemId,dh.id,dF(dh.latitude*dB),dF(dh.longitude*dB),dF(dh.altitude))end;dZ.__eq=function(dR,dS)return dR.id==dS.id and dR.systemId==dS.systemId and dp(dR.latitude,dS.latitude)and dp(dR.altitude,dS.altitude)and(dp(dR.longitude,dS.longitude)or dp(dR.latitude,math.pi/2)or dp(dR.latitude,-math.pi/2))end;local function d_(e0,dV,e1,e2,e3)local dU=e0;if dv(e0)and not e2 and not e3 and not dV and not e1 then dU,dV,e1,e2,e3=e4(e0,dE)assert(dU,'Argument 1 (position string) is malformed.')else assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(e1),'Argument 3 (latitude) must be in degrees:'..type(e1))assert(ds(e2),'Argument 4 (longitude) must be in degrees:'..type(e2))assert(ds(e3),'Argument 5 (altitude) must be in meters:'..type(e3))end;dU=dm(dU)dV=dm(dV)e1=dm(e1)e2=dm(e2)e3=dm(e3)if dV==0 then return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=dV,systemId=dU},dZ)end;return setmetatable({latitude=dA*dl(e1,-90,90),longitude=dA*(e2%360),altitude=e3,id=dV,systemId=dU},dZ)end;local e5={}e5.__index=e5;e5.__tostring=function(dI,dO)local e6=dO and dO..'  'local e7={}local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)for dQ,e8 in ipairs(dP)do e9=dI[e8]local ea=dN.__tostring(e9,e6)if dO then table.insert(e7,dk('[%s]={\n%s\n%s}',e8,ea,dO))else table.insert(e7,dk('  [%s]=%s',e8,ea))end end;if dO then return dk('\n%s%s%s',dO,table.concat(e7,',\n'..dO),dO)end;return dk('{\n%s\n}',table.concat(e7,',\n'))end;local function eb(ec)local e={}local pid;for dQ,dx in pairs(ec)do local dV=dx.planetarySystemId;if type(dV)~='number'then error('Invalid planetary s ID: '..tostring(dV))elseif pid and dV~=pid then error('Mistringmatch planetary s IDs: '..dV..' and '..pid)end;local ed=dx.bodyId;if type(ed)~='number'then error('Invalid body ID: '..tostring(ed))elseif e[ed]then error('Duplicate body ID: '..tostring(ed))end;setmetatable(dx.center,getmetatable(vec3.unit_x))e[ed]=setmetatable(dx,dN)pid=dV end;return setmetatable(e,e5)end;ee={}local function ef(ec)return setmetatable({galaxyAtlas=ec or{}},ee)end;ee.__index=function(du,M)if type(M)=='number'then local a=du.galaxyAtlas[M]return eb(a)end;return rawget(ee,M)end;ee.__pairs=function(dI)return function(du,dL)local eg,eh=next(du,dL)return eg,eh and eb(eh)end,dI.galaxyAtlas,nil end;ee.__tostring=function(dI)local ei={}for dQ,ej in pairs(dI or{})do local ek=ej:getPlanetarySystemId()local el=e5.__tostring(ej,'    ')table.insert(ei,dk('  [%s]={%s\n  }',ek,el))end;return dk('{\n%s\n}\n',table.concat(ei,',\n'))end;ee.BodyParameters=dT;ee.MapPosition=d_;ee.PlanetarySystem=eb;function ee.createBodyParameters(dU,dV,em,en,eo,ep,eq)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(em),'Argument 3 (surfaceArea) must be a number:'..type(em))assert(dt(en),'Argument 4 (aPosition) must be an array or vec3:'..type(en))assert(dt(eo),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eo))assert(ds(ep),'Argument 6 (altitude) must be in meters:'..type(ep))assert(ds(eq),'Argument 7 (gravityAtPosition) must be number:'..type(eq))local dW=dn(em/4/math.pi)local cb=dW+ep;local er=vec3(en)+cb*vec3(eo)local dY=eq*cb*cb;return dT(dU,dV,dW,er,dY)end;ee.isMapPosition=dy;function ee:getPlanetarySystem(e0)if M==nil then M=0 end;if eh==nil then eh=0 end;local dU=e0;if dy(e0)then dU=e0.systemId end;if type(dU)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eh)~=e5 then a=eb(a)end;return a end end end;function e5:sizeCalculator(es)return 1.05*es.radius end;function e5:castIntersections(et,eu,ev,ew,ex,ey)local ez={}if ex then for dQ,es in pairs(ex)do table.insert(ez,es)end else ez=d4 end;if not ey then table.sort(ez,function(eA,eB)local eC=eA.center;local eD=eB.center;return(eC.x-et.x)^2+(eC.y-et.y)^2+(eC.z-et.z)^2<(eD.x-et.x)^2+(eD.y-et.y)^2+(eD.z-et.z)^2 end)end;local eE=eu:normalize()for dQ,es in ipairs(ez)do local eF=es.center-et;local dW;if ev then dW=ev(es)else dW=self:sizeCalculator(es)end;local eG=eF:dot(eE)local eH=eG^2-(eF:len2()-dW^2)if eH>=0 then local eI=dn(eH)local eJ=eG+eI;local eK=eG-eI;if eK>0 then return es,eJ,eK elseif eJ>0 then return es,eJ,nil end end end;return nil,nil,nil end;function e5:closestBody(eL)assert(type(eL)=='table','Invalid coordinates.')local eM,es;local eN=vec3(eL)for dQ,eO in pairs(self)do local eP=(eO.center-eN):len2()if(not es or eP<eM)and eO.name~="Space"then es=eO;eM=eP end end;return es end;function e5:convertToBodyIdAndWorldCoordinates(e0)local eQ=e0;if dv(e0)then eQ=d_(e0)end;if eQ.id==0 then return 0,vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;local eO=self:getBodyParameters(eQ)if eO then return eQ.id,eO:convertToWorldCoordinates(eQ)end end;function e5:getBodyParameters(e0)local dV=e0;if dy(e0)then dV=e0.id end;assert(ds(dV),'Argument 1 (id) must be a number:'..type(dV))return self[dV]end;function e5:getPlanetarySystemId()local dQ,dx=next(self)return dx and dx.systemId end;function dN:convertToMapPosition(dX)assert(dt(dX),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dX))local eR=vec3(dX)if self.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=self.systemId},dZ)end;local eS=eR-self.center;local cb=eS:len()local e3=cb-self.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=self.id,systemId=self.systemId},dZ)end;function dN:convertToWorldCoordinates(e0)local eQ=dv(e0)and d_(e0)or e0;if eQ.id==0 then return vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;assert(dy(eQ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eQ.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eQ.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eV=math.cos(eQ.latitude)return self.center+(self.radius+eQ.altitude)*vec3(eV*math.cos(eQ.longitude),eV*math.sin(eQ.longitude),math.sin(eQ.latitude))end;function dN:getAltitude(dX)return(vec3(dX)-self.center):len()-self.radius end;function dN:getDistance(dX)return(vec3(dX)-self.center):len()end;function dN:getGravity(dX)local eW=self.center-vec3(dX)local eX=eW:len2()return self.GM/eX*eW/dn(eX)end;return setmetatable(ee,{__call=function(dQ,...)return ef(...)end})end;local function eY(d,b,c,a,dn,eZ)local cp={}local e_=100;function cp.computeAccelerationTime(f0,f1,f2)return(f2-f0)/f1 end;function cp.computeDistanceAndTime(f0,f2,f3,f4,f5,f6)f5=f5 or 0;f6=f6 or 0;local f7=f0<f2;local f8=f4/(f7 and f3 or-f3)local f9=-f6/f3;local fa=f8+f9;if f0==f2 then return 0,0 elseif f7 and fa<=0 or not f7 and fa>=0 then return-1,-1 end;local fb,fc=0,0;if f8~=0 and f5>0 then local fd=math.pi/f5/2;local dx=function(du)return f8*(du/2-f5*math.sin(fd*du)/math.pi)+f9*du+f0 end;local fe=f7 and function(a)return a>=f2 end or function(a)return a<=f2 end;fc=2*f5;if fe(dx(fc))then local ff=0;while math.abs(fc-ff)>0.25 do local du=(fc+ff)/2;if fe(dx(du))then fc=du else ff=du end end end;local fg=2*f8*f5^2/math.pi^2;fb=fg*(math.cos(fd*fc)-1)+(f8+2*f9)*fc^2/4+f0*fc;if fc<2*f5 then return fb,fc end;f0=dx(fc)end;local eC=f8+f9;local du=cp.computeAccelerationTime(f0,eC,f2)local fh=f0*du+eC*du*du/2;return fb+fh,fc+du end;function cp.computeTravelTime(f0,f1,cb)if cb==0 then return 0 end;if f1~=0 then return(math.sqrt(2*f1*cb+f0^2)-f0)/f1 end;assert(f0>0,'Acceleration and initial speed are both zero.')return cb/f0 end;return cp end;local function fi(d,b,c,a,dk,dl,dm,dn,dp)local vec3=vec3;local dj=dj(d,b,c,a,dk,dl,dm,dn,dp)local function dv(a)return type(a)=='string'end;local function dt(du)return type(du)=='table'end;fj={}fj.__index=fj;function fj:escapeAndOrbitalSpeed(e3)assert(self.body)local cb=e3+self.body.radius;if not dp(cb,0)then local fk=dn(self.body.GM/cb)return dn(2)*fk,fk end;return nil,nil end;function fj:orbitalParameters(e0,fl)assert(self.body)assert(dt(e0)or dv(e0))assert(dt(fl))local fm=(dv(e0)or dj.isMapPosition(e0))and self.body:convertToWorldCoordinates(e0)or vec3(e0)local dx=vec3(fl)local fn=fm-self.body.center;local fo=dx:len2()local fh=fn:len()local fp=self.body.GM;local fq=((fo-fp/fh)*fn-fn:dot(dx)*dx)/fp;local eC=fp/(2*fp/fh-fo)local fr=fq:len()local eE=fq:normalize()local fs=eC*(1-fr)local ft=eC*(1+fr)local fu=fs*eE+self.body.center;local fv=fr<=1 and-ft*eE+self.body.center or nil;local fw=dn(eC*fp*(1-fr*fr))local fx=fv and 2*math.pi*dn(eC^3/fp)local fy=math.acos(fq:dot(fn)/(fr*fh))if fn:dot(dx)<0 then fy=-(fy-2*math.pi)end;local fz=math.acos((math.cos(fy)+fr)/(1+fr*math.cos(fy)))local fA=fz;if fA<0 then fA=fA+2*math.pi end;local fB=fA-fr*math.sin(fA)local fC=0;local fD=0;local fE=0;if fx~=nil then fC=fB/(2*math.pi/fx)fD=fx-fC;fE=fD+fx/2;if fy-math.pi>0 then fD=fC;fE=fD+fx/2 end;if fE>fx then fE=fE-fx end end;return{periapsis={position=fu,speed=fw/fs,circularOrbitSpeed=dn(fp/fs),altitude=fs-self.body.radius},apoapsis=fv and{position=fv,speed=fw/ft,circularOrbitSpeed=dn(fp/ft),altitude=ft-self.body.radius},currentVelocity=dx,currentPosition=fm,eccentricity=fr,period=fx,eccentricAnomaly=fz,meanAnomaly=fB,timeToPeriapsis=fD,timeToApoapsis=fE,trueAnomaly=fy}end;local function fF(fG)local eO=dj.BodyParameters(fG.systemId,fG.id,fG.radius,fG.center,fG.GM)return setmetatable({body=eO},fj)end;return setmetatable(fj,{__call=function(dQ,...)return fF(...)end})end;local function fH(d,b,c,a,dbHud_1,e,fI,fJ,bN,dm,dn,fK,fL,di)local function fM(fN)local dh=fO:closestBody(fN)if(fN-dh.center):len()>dh.radius+dh.noAtmosphericDensityAltitude then dh=e[0][0]end;return dh end;local function fP()local function fQ(fR,fS)return fR.name<fS.name end;cU={}for dL,dx in pairs(e[0])do cU[#cU+1]={name=dx.name,index=dL}end;table.sort(cU,fQ)end;local function fT(fU,fV)if not fV then fV=fW.name end;for dL,dx in pairs(fU)do if dx.name and dx.name==fV then return dL end end;return-1 end;local function fX()d1=bm;if bm==0 then bk="None"c8=nil;fW=nil;return true end;local fY=cU[bm].index;local fZ=e[0][fY]if fZ.center then bk=fZ.name;c8=co[0][fY]if fW~=nil then if ch==0 then if fI(f_,g0)~=1 then fJ(f_,g0)end;if fI(g1,g2)~=1 then fJ(g1,g2)end;if fI(g3,g4)~=1 then fJ(g3,g4)end;if fI(g5,g6)~=1 then fJ(g5,g6)end;if fI(g7,g8)~=1 then fJ(g7,g8)end end;if fI(g9,ga)~=1 then fJ(g9,ga)end;if fI(gb,gc)~=1 then fJ(gb,gc)end;if fI(gd,ge)~=1 then fJ(gd,ge)end end;fW=nil else fW=fZ;for dQ,dx in pairs(co[0])do if dx.name==fW.planetname then c8=dx;bk=fW.name;break end end;if fI(g9,ga)~=1 then fJ(g9,ga)end;if fI(gb,gc)~=1 then fJ(gb,gc)end end;if fW==nil then bl=vec3(c8.center)else bl=fW.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gf=bN(c8.radius*(U-1)+c8.noAtmosphericDensityAltitude)else gf=bN(c8.radius*(U-1)+c8.surfaceMaxAltitude)end else gf=T end;if fW~=nil and fW.planetname=="Space"then bg=0 else dQ,bg=cq(c8):escapeAndOrbitalSpeed(gf)end;bi=0;bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"return true end;local function gg(gh)if not b4 and not br and not cd and not bA and not b9 and not ce then if gh==nil then bm=bm+1;if bm>#cU then bm=0 end else bm=bm-1;if bm<0 then bm=#cU end end;if bm==0 then fX()else local fY=cU[bm].index;local fZ=e[0][fY]if fZ and(fZ~=nil and fZ.name=="Space"or bB=="Custom Only"and fZ.center or bB=="No Moons-Asteroids"and(string.find(fZ.name,"Moon")~=nil or string.find(fZ.name,"Asteroid")~=nil))then if gh==nil then gg()else gg(1)end else fX()end end else di("Disengage autopilot before changing Interplanetary Helper")fK("iph","AP")end end;local function gi()local function gj(gk)local gl;if gk then gl=d9 else gl=bq end;local gm=-1;gm=fT(e[0])if gm>-1 then table.remove(e[0],gm)end;gm=-1;gm=fT(gl)if gm~=-1 then di(fW.name.." saved location cleared")table.remove(gl,gm)end;gg()fP()return gl end;if string.sub(bk,1,1)=="*"then d9=gj(true)else bq=gj(false)end end;local function gn(go,fN,gp,gq)local function gr(gk)if gk then gl=d9 else gl=bq end;if dbHud_1 or gp or gk then local dh=fM(fN)local gs={position=fN,name=go,planetname=dh.name,gravity=b.getGravityIntensity(),safe=gq}if not gp then gl[#gl+1]=gs else for dL,dx in pairs(e[0])do if dx.name and go==dx.name then table.remove(e[0],dL)end end end;table.insert(e[0],gs)fP()fX()di("Location saved as "..go.."("..dh.name..")")return gl else di("Databank must be installed to save permanent locations")end end;if string.sub(go,1,1)=="*"then d9=gr(true)else bq=gr(false)end end;local gt={}function gt.UpdateAtlasLocationsList()fP()end;function gt.UpdateAutopilotTarget()fX()end;function gt.adjustAutopilotTargetIndex(gh)gg(gh)end;function gt.findAtlasIndex(fU,fV)return fT(fU,fV)end;function gt.UpdatePosition(gu,gv,gw)local function gx(gk)local gl;if gk then gl=d9 else gl=bq end;local gm=fT(gl)if gm~=-1 then if gu~=nil then if gk then gu="*"..gu end;gl[gm].name=gu;bm=bm-1;gg()elseif gw~=nil then if gw then local gy=ci;if gy<1000 then gy=1000 end;gl[gm].agg=fL(gy,0)di(gl[gm].name.." AGG Altitude:"..gl[gm].agg.." saved ("..gl[gm].planetname..")")return elseif gw==false then gl[gm].agg=nil;di(gl[gm].name.." AGG Altitude cleared ("..gl[gm].planetname..")")return end else local gz=gl[gm]if gv then gz.heading=cI:cross(cM)*5000;di=gl[gm].name.." heading saved ("..gl[gm].planetname..")"return elseif gv==false then gz.heading=nil;di=gl[gm].name.." heading cleared ("..gl[gm].planetname..")"return end;gz.gravity=b.getGravityIntensity()gz.position=cO;gz.safe=true end;di(gl[gm].name.." position updated ("..gl[gm].planetname..")")else di("Name Not Found")end end;if string.sub(bk,1,1)=="*"then gx(true)else gx(false)end end;function gt.AddNewLocation(go,fN,gp,gq)gn(go,fN,gp,gq)end;function gt.ClearCurrentPosition()gi()end;for dL,dx in pairs(da)do table.insert(e[0],dx)end;if gA then for dL,dx in pairs(gA)do gt[dL]=dx end end;fP()if bm>#cU then bm=0 end;gt.UpdateAutopilotTarget()return gt end;local function gB(b,a,c,radar_1,radar_2,warpdrive,eZ,gC,dn,gD,dm,gE,fK,di)local gF={}local gG={}local gH={XS=13,S=27,M=55,L=110,XL=221}local gI={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gJ={}local gK=0;local gL;local gM;local gN=0;local gO;local gP={gO}local gQ="Atmo"local gR;local gS;local gT=0;local gU={}local gV;local gW=0;local gX=table.insert;local gY=-4;local gZ={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local g_,h0;local h1,h2;local h3;local h4;local h5;local h6;local h7;local h8;local h9;local function ha()if hb~=nil and gT==0 then gC(hb)a.destroyWidget(g_)a.destroyData(h1)g_,h1,hb=nil,nil,nil;if gS~=nil then gC(gS)a.destroyWidget(h0)a.destroyData(h2)gS,h0,h2=nil,nil,nil end else if gT==1 then gS=a.createWidgetPanel("PeriWinkle")h0=a.createWidget(gS,'periscope')h2=gO.getWidgetDataId()a.addDataToWidget(h2,h0)end;if hb==nil and gK>0 then hb=a.createWidgetPanel(gQ)g_=a.createWidget(hb,'radar')h1=gO.getWidgetDataId()a.addDataToWidget(h1,g_)end;gT=0 end end;local function hc()local function hd(he,hf,hg,hh,hi,hj,hk,hl)hf,hh,hj,hl=vec3(hf),vec3(hh),vec3(hj),vec3(hl)local hm,hn,ho=he*he,hg*hg,hi*hi;local fo=hh-hf;local hp=fo:normalize()local hq=fo:len()local hr=hj-hf;local hs=(hr-hr:project_on(hp)):normalize()local ht,hu=hr:dot(hp),hr:dot(hs)local hv=ht*ht+hu*hu;local hw=hp:cross(hs)local hx=(hm-hn+hq*hq)/(2*hq)local hy=(hm-ho+hv-2*ht*hx)/(2*hu)local dz=hm-hx^2-hy^2;local hz=dn(dz)local hA=hf+hp*hx+hs*hy+hw*hz;local hB=hf+hp*hx+hs*hy-hw*hz;if eZ((hl-hA):len()-hk)<eZ((hl-hB):len()-hk)then return hA else return hB end end;local function hC(hD,fh,hE)local hF=hD.pts;local gm=#hF;local hG=hD.ref;if gm>3 then local hH,hI,hJ,hK=hF[gm],hF[gm-1],hF[gm-2],hF[gm-3]hD.ref=hE;local fm=hd(hH[1],hH[2],hI[1],hI[2],hJ[1],hJ[2],hK[1],hK[2])local hx,hy,hz=fm.x,fm.y,fm.z;if hx==hx and hy==hy and hz==hz then hx=hx+hG[1]hy=hy+hG[2]hz=hz+hG[3]local hL=vec3(hx,hy,hz)hD.center=hL;if hD.lastPos then if(hD.lastPos-hL):len()<2 then local hM=(hL-vec3(hE)):len()if eZ(hM-fh)<10 then hD.skipCalc=true end end end;hD.lastPos=hL end;hD.pts={}else local hN={hE[1]-hG[1],hE[2]-hG[2],hE[3]-hG[3]}hF[gm+1]={fh,hN}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gO then if#gV>0 then local hO,hP=0,0;local hQ=cL*10;local cY=cY;gN,gM=0,0;gG={}for dQ,dx in pairs(gV)do local cb=h7(dx)if cb>0.0 then if h3(dx)==1 then gX(gG,dx)end;if not cV and warpdrive and cb<aa and warpdrive.getStatus()==15 then di("INITIATING WARP")c4=7;warpdrive.initiate()end;local hR=F and h5(dx)==1;if E or hR then local hS=h8(dx)local hT=gH[hS]local hU=h4(dx)if hR or cb<hQ and(hT>27 or hU==4 or hU==6)then gN=gN+1;local hE={cO["x"],cO["y"],cO["z"]}local hD=gU[dx]if hD==nil then hT=hT+gE;gU[dx]={pts={},ref=hE,name=h6(dx),i=0,radius=hT,skipCalc=false}hD=gU[dx]end;if not hD.skipCalc then if hR or hU==4 or hU==6 then hD.center=vec3(h9(dx))hD.skipCalc=true else hC(hD,cb,hE)hP=hP+1 end;if hR and not hD.abandoned then local bQ=a.getArkTime()if gW+5<bQ then gW=bQ;fK("abRdr","RD")end;a.print("Abandoned Construct: "..hD.name.." ("..hS.." "..gI[hU]..") at ::pos{0,0,"..hD.center.x..","..hD.center.y..","..hD.center.z.."}")di("Abandoned Radar Contact ("..hS.." "..gI[hU]..") detected")hD.abandoned=true end else gX(gJ,hD)end end;hO=hO+1;if hO>300 or hP>30 then coroutine.yield()hO,hP=0,0 end end end end;gM=#gJ;if gM>0 and(cL>20 or b7)then local es,hV,hW,hX;local hY=0;local hZ=co:getPlanetarySystem(0)hX=cK:normalize()while hY<gM do coroutine.yield()local h_={table.unpack(gJ,hY,math.min(hY+75,gM))}es,hV,hW=hZ:castIntersections(cO,hX,nil,nil,h_,true)if es and hW then c_={es,hV,hW}break end;hY=hY+75 end;if not es then c_=nil end else c_=nil end;gJ={}gL=gO.getTargetId()end end end;local function i0()if gO then gQ="Atmo"if string.find(gO.getName(),"Space")then gQ="Space"end end end;function gF.pickType()i0()end;function gF.assignRadar()if radar_2 and gY~=1 then if gY==-1 then if gO==radar_2 then gO=radar_1 else gO=radar_2 end end;gP={gO}h3=gO.hasMatchingTransponder;h4=gO.getConstructKind;h5=gO.isConstructAbandoned;h6=gO.getConstructName;h7=gO.getConstructDistance;h8=gO.getConstructCoreSize;h9=gO.getConstructWorldPos;gV=gO.getConstructIds()i0()else gV=gO.getConstructIds()end;gY=gO.getOperationalState()end;function gF.UpdateRadar()local i1=coroutine.status(gR)if i1=="suspended"then local dM,i2=coroutine.resume(gR)if i2 then a.print("ERROR UPDATE RADAR: "..i2)end elseif i1=="dead"then gR=coroutine.create(hc)local dM,i2=coroutine.resume(gR)end end;function gF.GetRadarHud(i3,i4,ay,az)local i5,di;local dD=gM or 0;gK=#gV;if gK>0 then if E then di=dD.."/"..gN.." Known/InRange : "..gK.." Total"else di="Radar Contacts: "..gK end;i5=gD(ay,az,di,"pbright txtbig txtmid")if#gG>0 then i5=i5 ..gD(i3,i4,"Friendlies In Range","pbright txtbig txtmid")for dL,dx in pairs(gG)do i4=i4+20;i5=i5 ..gD(i3,i4,gO.getConstructName(dx),"pdim txtmid")end end;local i6=#gO.getIdentifiedConstructIds()if gS==nil and i6>0 then gT=1;cu.ToggleRadarPanel()end;if gS~=nil and i6==0 then cu.ToggleRadarPanel()end;if hb==nil then if w then cu.ToggleRadarPanel()end end else if gY~=1 then i5=gD(ay,az,gQ.." Radar: "..gZ[gY],"pbright txtbig txtmid")else i5=gD(ay,az,"Radar: No "..gQ.." Contacts","pbright txtbig txtmid")end;if hb~=nil then gT=0;cu.ToggleRadarPanel()end end;return i5 end;function gF.GetClosestName(go)if gO then local i7=gO.getConstructName(gO.getConstructIds()[1])if i7 then go=go.." "..i7 end end;return go end;function gF.ToggleRadarPanel()ha()end;function gF.ContactTick()if not i8 then i8=0 end;if bQ>i8+10 then di("Radar Contact")fK("rdrCon","RC")i8=bQ end;c.stopTimer("contact")end;function gF.onEnter(dV)if gO and not cg and not cV then c.setTimer("contact",0.1)end end;function gF.onLeave(dV)if gO and E then if#gU>650 then dV=tostring(dV)gU[dV]=nil end end end;local function i9()gO=nil;if radar_2 and radar_2.getOperationalState()==1 then gO=radar_2 else gO=radar_1 end;gY=gO.getOperationalState()h3=gO.hasMatchingTransponder;h4=gO.getConstructKind;h5=gO.isConstructAbandoned;h6=gO.getConstructName;h7=gO.getConstructDistance;h8=gO.getConstructCoreSize;h9=gO.getConstructWorldPos;gP={gO}gV=gO.getConstructIds()i0()gR=coroutine.create(hc)if ia then for dL,dx in pairs(ia)do gF[dL]=dx end end end;i9()return gF end;local function ib(shield,e4,bN,di)local ic={}local id=shield.getResistancesCooldown()local function ie()local ig=shield.isActive()if G then if not cV and ig==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and ig==1 then shield.toggle()end end end;local function ih()local ii=shield.getStressRatioRaw()local ij=0.5999;if ii[1]==0.0 and ii[2]==0.0 and ii[3]==0.0 and ii[4]==0.0 then return end;local ik=shield.setResistances(ij*ii[1],ij*ii[2],ij*ii[3],ij*ii[4])if ik==1 then di("Shield Resistances updated")else di("Value Exceeded. Failed to update Shield Resistances")end end;function ic.shieldTick()dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ie()id=shield.getResistancesCooldown()if id==0 and dg<a9 then ih()end end;function ic.setResist(il)if not shield then di("No shield found")return elseif il==nil or id>0 then di("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE=dD..', '..dD..', '..dD..', '..dD;local im,io,ip,iq=e4(il,dE)if iq==nil or im+io+ip+iq>0.6 then di("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(im,io,ip,iq)==1 then di("Shield Resistances set")else di("Resistance setting failed.")end end;function ic.ventShield()local ir=shield.getVentingCooldown()if ir>0 then di("Cannot vent again for "..ir.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()di("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else di("Shields already at max hitpoints")end end;if is then for dL,dx in pairs(is)do ic[dL]=dx end end;return ic end;local function it(d,b,c,a,e,antigrav,hover,shield,warpdrive,iu,eZ,bN,dk,iv,bO,iw,ix,eU,bM,dl,iy,fJ,fI,gC,iz,dn,fL,gD,fK,iA,iB,iC,iD,iE,iF,di)local bP=DUConstruct;local iG=9.80665;local iH={}local iI={}local iJ={}local iK={}local iL=nil;local iM=nil;local iN=nil;local iO=false;local iP="none"local iQ=""local iR=55;local iS=0;local iT=0;local iU=nil;local iV=ag;local iW=ah;local iX=ai;local iY=[[rgb(]]..bN(iV+0.5)..","..bN(iW+0.5)..","..bN(iX+0.5)..[[)]]local iZ=[[rgb(]]..bN(iV*0.9+0.5)..","..bN(iW*0.9+0.5)..","..bN(iX*0.9+0.5)..[[)]]local i_=0;local j0=0;local j1=""local j2=bM()local j3=false;local j4=false;local gO=false;local function j5(dx)if ad==1920 then return dx else return fL(ad*dx/1920,0)end end;local function j6(dx)if ae==1080 then return dx else return fL(ae*dx/1080,0)end end;local function j7()return iz()==0 and g~="keyboard"and ix()==0 end;local function j8()local j9="TRAVEL"if not cR then j9="CRUISE"end;if b4 then j9="AUTOPILOT"end;return j9 end;local i5=""local ja=""local jb=""local jc=1;local jd=2;local je=3;local jf=4;local jg=5;local jh=6;local ji=7;local jj=""local jk=0;local jl=90.0*aU;local jm={}local jn={}local jo={}local jp={}local jq={}local jr={}local js={}js["atmofueltank"],js["spacefueltank"],js["rocketfueltank"]=0,0,0;local jt=0;local function ju(hx,jv,jw,jx,jy,jz)local jA=jt;local jB=jt+5;if not B then jB=jB+5 end;if ix()==1 and not m then jA=jA-50;jB=jB-50 end;if jw=="ATMO"then jj="atmofueltank"elseif jw=="SPACE"then jj="spacefueltank"else jj="rocketfueltank"end;jk=_G[jj.."_size"]if#jx>0 then for M=1,#jx do local go=jx[M][jd]local jC=jx[M][ji]for jD=1,jk do if jx[M][jd]==iv(c[jj.."_"..jD].getWidgetData()).name then jC=jD;break end end;local jE=bM()if jy[M]==nil or jz[M]==nil or jE-jx[M][jh]>jl then local jF;local jG=0;jG=iw(jx[M][jc])-jx[M][jf]jF=jx[M][jg]local jH=jF>jG or false;if jH then js[jj]=js[jj]+jF-jG end;if jC~=0 then local jI=iv(c[jj.."_"..jC].getWidgetData())jz[M]=jI.percentage;jy[M]=jI.timeLeft;if jy[M]=="n/a"then jy[M]=0 end else jz[M]=bN(0.5+jG*100/jx[M][je])if jH then jy[M]=bN(0.5+jG/((jF-jG)/(jE-jx[M][jh])))else jy[M]=0 end end;jx[M][jh]=jE;jx[M][jg]=jG end;if go==jv then go=dk("%s %d",jw,M)end;if jC==0 then go=go.." *"end;local jJ;jJ=iD(jy[M])if jy[M]==0 or jJ==">1y"then jJ=""end;if jz[M]~=nil then local jK=bN(jz[M]*2.55)local jL=dk("rgb(%d,%d,%d)",255-jK,jK,0)local jM=""if jJ~=""and jy[M]<120 or jz[M]<5 then jM="red "end;local jN=dk("rgb(%d,%d,%d)",dl(bN((255-jK)/2.55),50,100),dl(bN(jK/2.55),0,50),50)local jO="rgb(196,0,255)"if jw=="ATMO"then jO="rgb(0,188,255)"elseif jw=="SPACE"then jO="rgb(239,255,0)"end;local jP=false;if jQ~=jO then jP=true end;jQ=jO;if B then if jP then jA=jA-5;jB=jB-5 end;ja=ja..dk([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jN,jO,hx,jB,jL,bN(jz[M]*1.7+0.5)-2,hx+1,jB+1,hx+5,jB+14,go,jz[M],jJ)jA=jA-22;jB=jB-22 else ja=ja..gD(hx,jA,go,jM.."pdim txtfuel")ja=ja..gD(hx,jB,dk("%d%% %s",jz[M],jJ),"pdim txtfuel","fill:"..jL)jA=jA+30;jB=jB+30 end end end end;jt=jA end;local function jR(jS,e3)if aq==0 and ar==0 then return end;if e3<200000 and not cg or e3 and cg then local jT=0;if eZ(cN)>1 then jT=45*math.log(eZ(cN),10)if cN<0 then jT=-jT end end;jS[#jS+1]=dk([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bN(cN),bN(jT))end;return jS end;local function jU(jV)local gh=-cM;jV=jV-jV:project_on(gh)local jW=vec3(0,0,1)jW=jW-jW:project_on(gh)local jX=jW:cross(gh)local jT=jW:angle_between(jV)*constants.rad2deg;if jV:dot(jX)<0 then jT=360-jT end;return jT end;local function jY(jS,am,an,jZ,j_,cY)if af==0 then return end;local k0=af;local k1=20;local k2=bN(jZ)if cY then for M=-45,45,5 do local k3=M;jS[#jS+1]=dk([[<g transform="rotate(%f,%d,%d)">]],k3,am,an)k4=5;if M%15==0 then k4=15 elseif M%10==0 then k4=10 end;jS[#jS+1]=dk([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+k0+k1-k4,am,an+k0+k1)end;jS[#jS+1]=gD(am,an+k0+k1-35,j_,"pdim txt txtmid")jS[#jS+1]=gD(am,an+k0+k1-25,k2 .." deg","pdim txt txtmid")jS[#jS+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-jZ,am,an)jS[#jS+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+k0+k1-20,am+5,an+k0+k1-20,am,an+k0+k1-15)jS[#jS+1]="</g>"end;jS[#jS+1]=[[<g style="clip-path: url(#headingClip);">]]local k5=k2;if cY then k5=jU(cH)end;local k6=20;local k7=bN(k5)local k8=0;local k9=an+k0+k1+20;local ka=am;if j_~="YAW"then k9=j6(130)ka=j5(960)end;local kb=[[<path class="txttick line" d="]]local kc=bN(k7-(k6+10)-k7%5+0.5)for M=kc+70,kc,-5 do local hx=ka-(-M*5+k5*5)if M%10==0 then k8=10;local dD=M;if dD==360 then dD=0 elseif dD>360 then dD=dD-360 elseif dD<0 then dD=dD+360 end;jS[#jS+1]=gD(hx,k9+15,dD,"txtmid bright")elseif M%5==0 then k8=5 end;if k8==10 then kb=dk([[%s M %f %f v %d]],kb,hx,k9-5,k8)else kb=dk([[%s M %f %f v %d]],kb,hx,k9-2.5,k8)end end;jS[#jS+1]=kb..[["/>]]jS[#jS+1]=dk([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],ka-5,k9-20,ka+5,k9-20,ka,k9-10)if cY then j_="HDG"end;jS[#jS+1]=gD(j5(960),j6(100),k7 .."Â°","dim txt txtmid size14","")jS[#jS+1]=gD(j5(960),j6(85),j_,"dim txt txtmid size20","")jS[#jS+1]=[[</g>]]end;local function kd(jS,ke,jZ,am,an,cY,kf,kg)if af==0 then return end;local k0=af;local kh=bN(k0*3/5)if k0>0 then local ki=bN(ke)local k4=0;local kb=dk([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jZ,am,an)if not cg then kb=dk([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;jS[#jS+1]=dk([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k0-1,am,an)jS[#jS+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(ki-30-ki%5+0.5),bN(ki+30+ki%5+0.5),5 do if M%10==0 then k4=30 elseif M%5==0 then k4=20 end;local hy=an+-M*5+ke*5;if k4==30 then kb=dk([[%s M %d %f h %d]],kb,am-kh-k4,hy,k4)if cg then jS[#jS+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jZ,am,an,am-kh+10,hy+4,M)jS[#jS+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jZ,am,an,am+kh-10,hy+4,M)if M==0 or M==180 or M==-180 then jS[#jS+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jZ,am,an,am-kh+20,hy,kh*2-40)end else jS[#jS+1]=gD(am-kh+10,hy,M,"pdim txt txtmid")jS[#jS+1]=gD(am+kh-10,hy,M,"pdim txt txtmid")end;kb=dk([[%s M %d %f h %d]],kb,am+kh,hy,k4)else kb=dk([[%s M %d %f h %d]],kb,am-kh-k4,hy,k4)kb=dk([[%s M %d %f h %d]],kb,am+kh,hy,k4)end end;jS[#jS+1]=kb..[["/>]]local kj="PITCH"if not cY then kj="REL PITCH"end;if ke>90 and not cg then ke=90-(ke-90)elseif ke<-90 and not cg then ke=-90-(ke+90)end;if k0>200 then if cg then if kg>iR then jS[#jS+1]=gD(am,an-15,"Yaw","pdim txt txtmid")jS[#jS+1]=gD(am,an+20,kf,"pdim txt txtmid")end;jS[#jS+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-jZ,am,an)else jS[#jS+1]=dk([[<g transform="rotate(0,%d,%d)">]],am,an)end;jS[#jS+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-kh+25,an-5,am-kh+20,an,am-kh+25,an+5,am-kh+50,an+4,ki)jS[#jS+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+kh-25,an-5,am+kh-20,an,am+kh-25,an+5,am+kh-30,an+4,ki)jS[#jS+1]="</g>"end;local kk=bN(k0/3)jS[#jS+1]=dk([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-kk,an,k0-kk)if not cg and cY then jS[#jS+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jZ,am,an,am-kh+10,an,kh*2-20)end;jS[#jS+1]="</g>"if k0<200 then if cg and kg>iR then jS[#jS+1]=gD(am,an-k0,kj,"pdim txt txtmid")jS[#jS+1]=gD(am,an-k0+10,ki,"pdim txt txtmid")jS[#jS+1]=gD(am,an-15,"Yaw","pdim txt txtmid")jS[#jS+1]=gD(am,an+20,kf,"pdim txt txtmid")else jS[#jS+1]=gD(am,an-k0,kj,"pdim txt txtmid")jS[#jS+1]=gD(am,an-k0+15,ki,"pdim txt txtmid")end end end end;local function kl(jS,e3,cY)local km=as;local kn=at;if km==0 and kn==0 then return end;local ko=78;local kp=19;local kq=cf;if cf~=-1 then jS[#jS+1]=gD(km+ko,kn+kp+20,dk("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(e3<200000 and not cg or e3 and cg)then table.insert(jS,dk([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],km-1,kn-4,ko+2,kp+6,km+1,kn-1,ko-4,kp))local gm=0;local kr=1;local ks=0;local kt=e3<0;local ku=e3<kv.surfaceMaxAltitude;local kw=9;if kt then kw=0 end;local e3=eZ(e3)while gm<6 do local kx=11;local ky=16;local kz=9;local kA=14;local jM="altsm"if gm>2 then ky=ky+3;kx=kx+2;kA=kA+2;kz=kz-6;jM="altbig"end;if kt then jM=jM.." red"elseif ku then jM=jM.." orange"end;local kB=e3/kr%10;local kC=bN(kB)local kD=bN((kC+1)%10)local kE=ks;if gm==0 then kE=kB-kC;if kt then kE=1-kE end end;if kt and(gm==0 or ks~=0)then local gp=kD;kD=kC;kC=gp end;local kF=ky*(kE-1)local kG=kF+ky;local hx=km+kz+(6-gm)*kx;local hy=kn+kA;jS[#jS+1]=gD(hx,hy+kF,kD,jM)jS[#jS+1]=gD(hx,hy+kG,kC,jM)gm=gm+1;kr=kr*10;if kC==kw then ks=kE else ks=0 end end;table.insert(jS,[[</g></g>]])end end;local function kH(fl)local kI=-math.deg(eU(fl.y,fl.z))+180;kI=kI-90;if kI<0 then kI=360+kI end;if kI>180 then kI=-180+kI-180 end;return-kI end;local function kJ(fl)local k5=math.deg(eU(fl.y,fl.x))-90;if k5<-180 then k5=360+k5 end;return k5 end;local function kK(jS,fl,kg,am,an)if kg>5 and not cg or kg>iR then local k0=af;local kL=20;local kM=20;local kN=kH(fl)local kO=kJ(fl)local kP=14;local kQ=kP/2;local kR=-kO/kM*k0;local kS=kN/kL*k0;local hx=am+kR;local hy=an+kS;local cb=dn(kR^2+kS^2)local kT=[[<circle
                            cx="]]..hx..[["
                            cy="]]..hy..[["
                            r="]]..kQ/kP..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hx..[["
                            cy="]]..hy..[["
                            r="]]..kQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hx-kP..[[,]]..hy..[[ h ]]..kQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hx+kQ..[[,]]..hy..[[ h ]]..kQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hx..[[,]]..hy-kP..[[ v ]]..kQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<k0 then jS[#jS+1]=kT else local jT=eU(kS,kR)local kU=4;local kV=am+k0*math.cos(jT)local kW=an+k0*math.sin(jT)jS[#jS+1]=dk('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jT*180/math.pi,kV,kW,kV-kU,kW-kU/2,kU*2,kU,kV+kU,kW-kU,kU,kU,-kU,kU)end;if not cg then local kX=vec3(fl)kN=kH(-kX)kO=kJ(-kX)kR=-kO/kM*k0;kS=kN/kL*k0;hx=am+kR;hy=an+kS;cb=dn(kR^2+kS^2)if cb<k0 then local kY=[[<circle
                                    cx="]]..hx..[["
                                    cy="]]..hy..[["
                                    r="]]..kQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hx..[[,]]..hy-kP..[[ v ]]..kQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hx..[[,]]..hy..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hx..[[,]]..hy..[[)" />
                                <path
                                    d="M ]]..hx-kQ..[[,]]..hy..[[ h ]]..kP..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hx..[[,]]..hy..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hx..[[,]]..hy..[[)"/>]]jS[#jS+1]=kY end end end end;local function kZ(jS,j9,k_,l0)if ao==0 and ap==0 then return end;k_=bN(k_+0.5)local jA=ap+10;local jB=ap+20;if ix()==1 and not m then jA=55;jB=65 end;local l1="CRUISE"local c="km/h"local dM=l0;if j9=="TRAVEL"or j9=="AUTOPILOT"then l1="THROT"c="%"dM=k_;local l2="dim"if k_<0 then l2="red"end;jS[#jS+1]=dk([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l2,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-eZ(k_),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;jS[#jS+1]=gD(ao+10,jA,l1,"pbright txtstart")jS[#jS+1]=gD(ao+10,jB,dk("%.0f %s",dM,c),"pbright txtstart")if cg and t and cR and bT then k_=bN(bU*100+0.5)local l2="red"if k_<0 then l2="red"end;jS[#jS+1]=dk([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l2,1-eZ(k_),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)jS[#jS+1]=gD(ao+10,jA+40,"LIMIT","pbright txtstart")jS[#jS+1]=gD(ao+10,jB+40,k_.."%","pbright txtstart")end;if cg and t or b9 then jS[#jS+1]=gD(ao+10,jA-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b4 then jS[#jS+1]=gD(ao+10,jA-40,"LIMIT: "..bN(a1*3.6+0.5).." km/h","dim txtstart")end end;local function l3(jS,l4)if ao==0 and ap==0 then return end;local l5=ap-10;local l6=ao+10;jS[#jS+1]=gD(0,0,"","pdim txt txtend")if ix()==1 and not m then l5=75 end;jS[#jS+1]=gD(l6,l5,bN(l4).." km/h","pbright txtbig txtstart")end;local l7=40;local function l8(jS)jS[#jS+1]=gD(j5(150),j6(1070),dk("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jS[#jS+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jS[#jS+1]=gD(j5(960),j6(550),"Warning: Invalid Control Scheme Detected","warnings")jS[#jS+1]=gD(j5(960),j6(600),"Keyboard Scheme must be selected","warnings")jS[#jS+1]=gD(j5(960),j6(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l9=j5(960)local la=j6(860)local lb=j6(880)local lc=j6(900)local ld=j6(960)local le=j6(200)local lf=j6(250)local lg=j6(960)if ix()==1 and not m then la=j6(135)lb=j6(155)lc=j6(175)le=j6(115)lf=j6(95)end;if b1 then local lh=""if type(b1)=="string"then lh="-"..b1 end;jS[#jS+1]=gD(l9,la,"Brake Engaged"..lh,"warnings")elseif bS>0 then jS[#jS+1]=gD(l9,la,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b4 and not br and not b7 and not cQ and not ba and not b8 then jS[#jS+1]=gD(l9,le+50,"** STALL WARNING **","warnings")fK("stall","SW",2)end end;if cX then jS[#jS+1]=gD(l9,le+90,"Flight Assist in Progress","warnings")end;if ck then jS[#jS+1]=gD(l9,lg,"Gyro Enabled","warnings")end;if li then l7=l7-1;if l7>20 then jS[#jS+1]=gD(l9,lg-20,"ECU Enabled","warnings")elseif l7<0 then l7=40 end end;if bn then if bW then jS[#jS+1]=gD(l9,lb,"Gear Extended","warn")else jS[#jS+1]=gD(l9,lb,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local lj=iC(d:getTargetGroundAltitude())jS[#jS+1]=gD(l9,lc,"Hover Height: "..lj,"warn")end;if c5 then jS[#jS+1]=gD(l9,ld+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cQ and bw~=nil then local lk="warnings"if eZ(ci-antigrav.getBaseAltitude())<501 then lk="warn"end;jS[#jS+1]=gD(l9,le+40,dk("Target Altitude: %d Singularity Altitude: %d",bN(bw),bN(antigrav.getBaseAltitude())),lk)end;if b4 and bk~="None"then jS[#jS+1]=gD(l9,le,"Autopilot "..bh,"warn")elseif bu~=nil then jS[#jS+1]=gD(l9,le+20,dk("LockedPitch: %d",bN(bu)),"warn")elseif c0 then jS[#jS+1]=gD(l9,le+20,"Follow Mode Engaged","warn")elseif b9 or ce then jS[#jS+1]=gD(l9,le+20,"Re-entry in Progress","warn")end;if b6 or ba then local lj=iC(bb,2)if ba then if cQ then lj=iC(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jS[#jS+1]=gD(l9,le,"VTO to "..lj,"warn")elseif(b8 or cd)and not bA then if cd then jS[#jS+1]=gD(l9,le,"Takeoff to "..bk,"warn")else jS[#jS+1]=gD(l9,le,"Takeoff to "..lj,"warn")end;if b1 and not ba then jS[#jS+1]=gD(l9,le+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jS[#jS+1]=gD(l9,le,"Altitude Hold: "..dk("%.1fm",bb),"warn")end end;if ba and(antigrav~=nil and antigrav)then if ch>0.1 then jS[#jS+1]=gD(l9,le+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then jS[#jS+1]=gD(l9,le+20,"Aligning trajectory","warn")elseif ch<0.05 then jS[#jS+1]=gD(l9,le+20,"Leaving atmosphere","warn")end end;if bA then if cC~=nil then jS[#jS+1]=gD(l9,le,cC,"warn")end end;if b7 then local ll="Brake Landing"if dc then ll=ll.."-Aligning"end;if db then ll=ll.."-Drift Limited"end;jS[#jS+1]=gD(l9,le,ll,"warnings")end;if b3 then jS[#jS+1]=gD(l9,le+20,"Prograde Alignment","crit")end;if b2 then jS[#jS+1]=gD(l9,le,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;jS[#jS+1]=gD(l9,lf+20,cZ,type)elseif ch==0 then local lm,ln=ct.checkLOS(cK:normalize())if ln~=nil then local lj=iC(ln)local lo=cp.computeTravelTime(cL,0,ln)local lp="Collision"if lm.noAtmosphericDensityAltitude>0 then lp="Atmosphere"end;jS[#jS+1]=gD(l9,lf+20,lm.name.." "..lp.." "..iD(lo).." In "..lj,"crit")end end;if br and not bA then jS[#jS+1]=gD(l9,le+60,lq,"warn")end;if d2 and#d2>1 then end;local lr=j5;local ls=j6;local lt="topButton"local lu="topButtonActive"local lv=lt;if b4 or br or cd or bA then lv=lu end;local lw=lt;if b3 then lw=lu end;local lx=lt;if b7 or bn then lx=lu end;local ly=lt;if b6 or br then ly=lu end;local lz=lt;if b2 then lz=lu end;local lA=lt;if bA or cE and b4 then lA=lu end;if w and I then local lB=ls(30)jS[#jS+1]=dk([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lv,lr(960),ls(54),ls(-53),lr(-120),lr(25),ls(50))jS[#jS+1]=gD(lr(910),lB,"AUTOPILOT")jS[#jS+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lw,lr(865),ls(51),lr(-25),ls(-50),lr(-110),lr(25),ls(46))jS[#jS+1]=gD(lr(800),lB,"PROGRADE")jS[#jS+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lx,lr(755),ls(47),lr(-25),ls(-46),lr(-98),lr(44),ls(44))jS[#jS+1]=gD(lr(700),lB,"LAND")jS[#jS+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],ly,lr(960),ls(54),ls(-53),lr(120),lr(-25),ls(50))jS[#jS+1]=gD(lr(1010),lB,"ALT HOLD")jS[#jS+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lz,lr(1055),ls(51),lr(25),ls(-50),lr(110),lr(-25),ls(46))jS[#jS+1]=gD(lr(1122),lB,"RETROGRADE")jS[#jS+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lA,lr(1165),ls(47),lr(25),ls(-46),lr(98),lr(-44),ls(44))jS[#jS+1]=gD(lr(1220),lB,"ORBIT")jS[#jS+1]=[[
                                    </g>
                                </g>]]jS[#jS+1]="</g>"end;return jS end;local function lC(kg)return bN(fL(kg*3.6,0)+0.5).." km/h"end;local function lD(gm)local go=bk;if gm~=nil and type(gm)=="number"then if gm==0 then return"None"end;go=cU[gm].name end;if go==nil then go=fW.name end;if go==nil then go="None"end;return go end;local function lE(jS)local lF=ct.routeWP(true)if not lF or#lF==0 then return end;local hx=j5(750)local hy=j6(360)if b4 or br then jS[#jS+1]=gD(hx,hy,"REMAINING ROUTE","pdim txtstart size20")else jS[#jS+1]=gD(hx,hy,"LOADED ROUTE","pdim txtstart size20")end;for dL,M in pairs(lF)do hy=hy+20;jS[#jS+1]=gD(hx,hy,dL..". "..lF[dL],"pdim txtstart size20")end end;local function lG(jS)local hx=aC+10;local hy=aD+20;local lH={}local lI={"Alt-4: AutoTakeoff to Target"}local lJ={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lK={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lL={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lH,"--------------DYNAMIC-----------------")if cg then if cf~=-1 then iA(lH,lI)if c8 and kv and c8.name==kv.name then table.insert(lH,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b0 then if antigrav then if cQ then table.insert(lH,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lH,"Turn on AGG to takeoff to AGG Height")end end;if b0 then table.insert(lH,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lH,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lH,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bn then table.insert(lH,"G: Takeoff to hover height, raise gear")else table.insert(lH,"G: Lowergear and Land")end else iA(lH,lJ)table.insert(lH,"G: Begin BrakeLanding or Land")end;if ba then table.insert(lH,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iA(lH,lK)if shield then table.insert(lH,"Alt-Shift-6: Vent shields")if not G then table.insert(lH,"Alt-Shift-7: Toggle shield off/on")end end end;if fW~=nil then table.insert(lH,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lH,"Alt-9: Activate Gyroscope")end;if aX~="none"or aW~="none"or aY~="none"then table.insert(lH,"Alt-Shift-9: Cycles engines with Extra tags")end;if b6 then table.insert(lH,"Alt-Spacebar/C will raise/lower target height")table.insert(lH,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cg then table.insert(lH,"LALT+Mousewheel will lower/raise speed limit")end;iA(lH,lL)for M=1,#lH do hy=hy+12;jS[#jS+1]=gD(hx,hy,lH[M],"pdim txtbig txtstart")end end;local function lM(jS)local lN=aC;local lO=aD;local lP=aB;local lQ=4;local lR=15;local hx=0;local hy=0;local lS,lT,lU,lV;local lW;local function lX(type)local gy,bQ,kg,lY,jM,lZ;if type=="Periapsis"then gy=lW.periapsis.altitude;bQ=lW.timeToPeriapsis;kg=lW.periapsis.speed;jM="txtend"lY=12;lZ=math.min(hx,lN+lP-kv.radius/lU-lQ*2)else gy=lW.apoapsis.altitude;bQ=lW.timeToApoapsis;kg=lW.apoapsis.speed;lY=-12;jM="txtstart"lZ=hx end;if cL<1 then bQ=0 end;jS[#jS+1]=dk([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lZ+lY,hy-5,hx,hy-5)jS[#jS+1]=dk([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lZ-lY*4,hy+2,hx,hy+2)jS[#jS+1]=gD(lZ,hy,type,jM)hx=lZ-lY*2;hy=hy+lR;local lj=iC(gy)jS[#jS+1]=gD(hx,hy,lj,jM)hy=hy+lR;jS[#jS+1]=gD(hx,hy,iD(bQ),jM)hy=hy+lR;jS[#jS+1]=gD(hx,hy,lC(kg),jM)end;local l_=lP*1.5;if bK=="INFO"then l_=25*10 end;if bK=="ORBIT"and ci<kv.spaceEngineMinAltitude then return jS end;if bK~="HIDE"then jS[#jS+1]=[[<g class="pbright txtorb txtmid">]]jS[#jS+1]=dk('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lP*2,l_,lN,lO)jS[#jS+1]=dk([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lP*2,l_,lN,lO)end;local m0=lP*1.5;local m1=lP*2;local m2=m0/2;local m3=lP;local m4=lN+m3;local m5=lO+m2;local m6=lN+m1;local m7=lO+m0;if bK=="ORBIT"then lO=lO+lQ;lS=lP/2;lV=0;lW={}lW.periapsis={}lW.apoapsis={}if fk~=nil then if fk.periapsis~=nil then lW.periapsis.altitude=fk.periapsis.altitude;lW.periapsis.speed=fk.periapsis.speed end;if fk.apoapsis~=nil then lW.apoapsis.altitude=fk.apoapsis.altitude;lW.apoapsis.speed=fk.apoapsis.speed end;lW.period=fk.period;lW.eccentricity=fk.eccentricity;lW.timeToApoapsis=fk.timeToApoapsis;lW.timeToPeriapsis=fk.timeToPeriapsis;lW.eccentricAnomaly=fk.eccentricAnomaly;lW.trueAnomaly=fk.trueAnomaly end;if lW.periapsis==nil then lW.periapsis={}lW.periapsis.altitude=-kv.radius;lW.periapsis.speed=a1 end;if lW.eccentricity==nil then lW.eccentricity=1 end;if lW.apoapsis==nil then lW.apoapsis={}lW.apoapsis.altitude=ci;lW.apoapsis.speed=0 end;if cL<1 then lW.apoapsis.altitude=ci;lW.apoapsis.speed=0 end;if lW.apoapsis.altitude then lU=(lW.apoapsis.altitude+lW.periapsis.altitude+kv.radius*2)/(lS*2)lT=(kv.radius+lW.apoapsis.altitude)/lU*(1-lW.eccentricity)lV=lS-lW.periapsis.altitude/lU-kv.radius/lU;local m8=math.pi;if lW.period~=nil and lW.period>0 and lW.timeToApoapsis~=nil then m8=lW.eccentricAnomaly;if lW.timeToPeriapsis<lW.timeToApoapsis then m8=2*math.pi-m8 end end;if cL<1 or m8~=m8 then m8=math.pi end;local m9=-lS*math.cos(m8)+lN+m3+lQ;local ma=lT*math.sin(m8)+lO+m2+lQ;local mb=""jS[#jS+1]='<g clip-path="url(#orbitRect)">'jS[#jS+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mb,lN+lP+lQ,lO+lP*1.5/2+lQ,lS,lT)if lT<1 then jS[#jS+1]=dk([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lN+lP+lQ-lV,lO+lP*1.5/2+lQ,m9,ma)end;jS[#jS+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lN+lP+lQ-lV,lO+lP*1.5/2+lQ,(kv.radius+kv.noAtmosphericDensityAltitude)/lU)jS[#jS+1]=dk('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lN+lP+lQ-lV,lO+lP*1.5/2+lQ,(kv.radius+kv.noAtmosphericDensityAltitude)/lU)jS[#jS+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lN+lP+lQ,lO+lP*1.5/2+lQ,lS,lT)jS[#jS+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lN+lP+lQ-lV,lO+lP*1.5/2+lQ,kv.radius/lU)jS[#jS+1]='</g>'local mc=math.floor(kv.radius/lU+0.5)hx=lN+lP+lQ*4+lS;hy=lO+lP*1.5/2+5+lQ;if lW.apoapsis~=nil and lW.apoapsis.speed<a1 then lX("Apoapsis")end;hy=lO+lP*1.5/2+5+lQ;hx=lN+lP-lQ*2-lS;if lW.periapsis~=nil and lW.periapsis.speed<a1 and lW.periapsis.altitude>0 then lX("Periapsis")end;jS[#jS+1]=gD(lN+lP+lQ,lO+20+lQ,kv.name,"txtorbbig")jS[#jS+1]=dk('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m9,ma)jS[#jS+1]=[[</g>]]return jS else jS[#jS+1]='<g clip-path="url(#orbitRect)">'local md=""local me=1.2*(mf-mg)/(lP*2)local mh=1.4*(mi-mj)/(lP*1.5)for dL,dx in pairs(e[0])do if dx.center then local hx=lN+lP+dx.center.x/me;local hy=lO+lP*1.5/2+dx.center.y/mh;md=md..'<circle cx="'..hx..'" cy="'..hy..'" r="'..dx.radius/me*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dx.name,"Moon")and not string.match(dx.name,"Sanctuary")and not string.match(dx.name,"Space")then md=md.."<text x='"..hx.."' y='"..hy+dx.radius/me*30+20 .."' font-size='12' fill="..iY.." text-anchor='middle' font-family='Montserrat'>"..dx.name.."</text>"end end end;local fm=vec3(bP.getWorldPosition())local hx=lN+lP+fm.x/me;local hy=lO+lP*1.5/2+fm.y/mh;md=md..'<circle cx="'..hx..'" cy="'..hy..'" r="2" stroke="white" stroke-width="1" fill="red"/>'md=md.."<text x='"..hx.."' y='"..hy-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iL=me;iM=mh;local mk=fm+cK*1000000;local ml=lN+lP+mk.x/me;local jB=lO+lP*1.5/2+mk.y/mh;md=md..'<line x1="'..hx..'" y1="'..hy..'" x2="'..ml..'" y2="'..jB..'" stroke="purple" stroke-width="1"/>'jS[#jS+1]=md;jS[#jS+1]='</g>'end elseif bK=="INFO"then jS=cr.DrawOdometer(jS,i_,bo,j0)elseif bK=="HELP"then jS=lG(jS)elseif bK=="SCOPE"then jS[#jS+1]='<g clip-path="url(#orbitRect)">'local mm=d5;local mn=vec3(DUSystem.getCameraWorldPos())local mo=vec3(DUSystem.getCameraWorldRight())local mp=vec3(DUSystem.getCameraWorldForward())if iz()==1 then mn=cO;mo=cI;mp=cH end;if ch>0 then table.sort(d4,function(eA,eB)local eC,eD=eA.center,eB.center;return(eC.x-mn.x)^2+(eC.y-mn.y)^2+(eC.z-mn.z)^2<(eD.x-mn.x)^2+(eD.y-mn.y)^2+(eD.z-mn.z)^2 end)end;local mq={}local mr={}local ms=120;local mt=nil;local mu=nil;for M,dx in ipairs(d4)do local gL=dx.center-mn;local mv=gL:len()local mw=gL:normalize()local mx=gL:cross(mp):normalize()local my=math.acos(mx:dot(mo))if my~=my then my=0 end;if mx:cross(mo):dot(mp)<0 then my=-my end;local mz=gL:project_on_plane(mp):len()local mA=math.sin(my)*math.asin(mz/mv)*constants.rad2deg;local mB=math.cos(my)*math.asin(mz/mv)*constants.rad2deg;if mw:dot(mp)<0 then mB=90*math.cos(my)+90*math.cos(my)-mB;mA=90*math.sin(my)+90*math.sin(my)-mA end;local hx=m4+mA/mm*m0;local hy=m5+mB/mm*m0;local mC=(hx-m4)*(hx-m4)+(hy-m5)*(hy-m5)local mD=math.asin((dx.radius+dx.surfaceMaxAltitude)/mv)*constants.rad2deg;if mD~=mD then mD=mm end;local hS=mD/mm*m0;local mE=math.asin(dx.atmosphereRadius/mv)*constants.rad2deg;if mE~=mE then mE=mD end;local mF=mE/mm*m0;local cb=iC(mv,1)local mG=dx.name;local mH=false;if hy>lO then if hy>m7 then if hy-mF<=m7 then mH=true end else mH=true end else if hy+mF>=lO then mH=true end end;local mI=false;local mJ=hx;if dx.systemId==0 then mJ=hx+ms else mJ=hx-ms end;if mJ+ms>lN then if mJ+ms>m6 then if mJ-mF-ms<=m6 then mI=true end else mI=true end else if mJ+mF+ms>=lN then mI=true end end;local mK={}mK.x=hx;mK.y=hy;mK.planet=dx;mK.atmoSize=mF;if not mt or mC<mt then mt=mC;mu=mK end;if mI and mH then local mL=math.max(mF,5)if mC<mL*mL then mG=mG.." - "..cb end;mK.size=hS;mK.i=M;mK.displayString=mG;mK.distance=cb;mK.visible=true;mr[#mr+1]=mK else mK.visible=false end end;local mM=false;table.sort(mr,function(eC,eD)return eC.y<eD.y end)for dL,fh in ipairs(mr)do local dx,hS,M,mF,hx,hy,mG,cb=fh.planet,fh.size,fh.i,fh.atmoSize,fh.x,fh.y,fh.displayString,fh.distance;local lZ,mN,mO,mP;local mQ=15;local jM="pdim"if dx.systemId~=0 then mO=j5(string.len(mG)*5)mQ=-(15+mO)mP=j6(10)jM="pdimfill"else mO=j5(string.len(mG)*9)mP=j6(15)end;if hS*2>mO then lZ=dl(hx,lN+mO/2,m6-mO/2)mN=dl(hy,lO+mP,m7-5)lZ=dl(lZ,hx-hS+mO/2,hx+hS-mO/2)mN=dl(mN,hy-hS+mP,hy+hS)else lZ=hx+mQ;mN=hy end;for mR,fh in pairs(mq)do local mS=fh.textPositions;local mT=mS.y-mN;if mR~=M and eZ(mT)<mS.height and mS.x+mS.width>lZ and mS.x<lZ+mO then if hS>mO then mN=dl(mN+mP,lO+15,m7-5)else mN=mS.y+mS.height+1 end end end;local mU=mG~=dx.name or lZ<=m4 and lZ+mO>=m4 and mN-mP<=m5 and mN>=m5;fh.hovered=mU;local mV=1;if mU then mV=2;if hS*2<mO then mV=10 end;if mG==dx.name then mG=mG.." - "..cb end;jM="pbright"if dx.systemId~=0 then mO=j5(string.len(mG)*5)mQ=-(15+mO)else mO=j5(string.len(mG)*7)end;if hS*2>mO then lZ=dl(hx,lN+mO/2,m6-mO/2)lZ=dl(lZ,hx-hS+mO/2,hx+hS-mO/2)else lZ=hx+mQ end end;mq[M]={}mq[M].textPositions={}mq[M].textPositions.y=mN;mq[M].textPositions.x=lZ;mq[M].textPositions.width=mO;mq[M].textPositions.height=mP;mq[M].output=""if hS*2>mO then jM=jM.." txtmid"else jM=jM.." txtstart"end;if mF-hS>2 then mq[M].output=dk('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hx,hy,mF,iZ,0.1*mV)end;mq[M].output=mq[M].output..dk('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hx,hy,hS,iZ,0.2*mV)if dx.systemId==0 then mq[M].output=mq[M].output..dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lZ,mN,iY,jM,mG)if hS*2<=mO then mq[M].output=mq[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lZ+mO,mN+2,lZ,mN+2,hx,hy)end else mq[M].output=mq[M].output..dk([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lZ,mN,iZ,jM,mG)if hS*2<=mO then mq[M].output=mq[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lZ,mN+2,lZ+mO,mN+2,hx,hy)end end end;for dL=#d4,1,-1 do if mq[dL]then jS[#jS+1]=mq[dL].output end end;if mu~=nil and d5<90 and not mu.hovered then local mW=mu.planet.atmosphereRadius/mu.atmoSize;local mX=dn(mt)*mW;local mY=iC(mX,1)local mO=j5(math.max(string.len(mY)*7,string.len(mu.planet.name)*7))local mP=j6(12)local lZ=dl(mu.x+(m4-mu.x)/2,lN+mO/2,m6-mO/2)local mN=dl(mu.y+(m5-mu.y)/2,lO+mP*2,m7-5)jS[#jS+1]=dk("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mu.x,mu.y,m4,m5)jS[#jS+1]=dk([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lZ,mN,"white",mY)if not mu.visible then jS[#jS+1]=dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lZ,mN-mP,"white",mu.planet.name)end end;if cL>1 then local gL=cK;local mw=gL:normalize()local mz=gL:project_on_plane(mp):len()local mx=gL:cross(mp):normalize()local my=math.acos(mx:dot(mo))if my~=my then my=0 end;if mx:cross(mo):dot(mp)<0 then my=-my end;local mA=math.sin(my)*math.asin(mz/gL:len())*constants.rad2deg;local mB=math.cos(my)*math.asin(mz/gL:len())*constants.rad2deg;if mw:dot(mp)<0 then mB=90*math.cos(my)+90*math.cos(my)-mB;mA=90*math.sin(my)+90*math.sin(my)-mA end;local hx=m4+mA/mm*m0;local hy=m5+mB/mm*m0;local kP=14;local kQ=kP/2;local kT=[[<circle
                                    cx="]]..hx..[["
                                    cy="]]..hy..[["
                                    r="]]..kQ/kP..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hx..[["
                                    cy="]]..hy..[["
                                    r="]]..kQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hx-kP..[[,]]..hy..[[ h ]]..kQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hx+kQ..[[,]]..hy..[[ h ]]..kQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hx..[[,]]..hy-kP..[[ v ]]..kQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jS[#jS+1]=kT end;jS[#jS+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m4,m5-10,m4,m5+10)jS[#jS+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m4-10,m5,m4+10,m5)jS[#jS+1]='</g>'else return jS end end;local function mZ(m_,n0)local n1;local n2=(n0-m_):normalize()local fn=(cO-m_):dot(n2)/n2:dot(n2)if fn<=0. then return(cO-m_):len()elseif fn>=(n0-m_):len()then return(cO-n0):len()end;local n3=m_+fn*n2;n1=(n3-cO):len()return n1 end;local function n4()local n1;local n5=nil;local n6=nil;local n7=nil;for dL,n8 in pairs(e[0])do if n8.hasAtmosphere then local cb=mZ(kv.center,n8.center)if n5==nil or cb<n5 then n6=n8;n5=cb;n7=kv end;if c8 and c8.hasAtmosphere and c8.name~=kv.name then local eP=mZ(c8.center,n8.center)if eP<n5 then n6=n8;n5=eP;n7=c8 end end end end;local n9=j5(1770)local na=j6(330)if n5 then local nb="txttick "local nc=500000;if n5<n6.radius+nc or n5<n7.radius+nc then if cV then nb="txttick red "else nb="txttick orange "end end;n1=iC(n5,2)iQ=gD(n9,na,"Pipe ("..n7.name.."--"..n6.name.."): "..n1,nb.."pbright txtmid")end end;local function nd(hx,hy,ne,nf,l1)local ng={x=hx,y=hy,width=ne,height=nf,label=l1}iK[l1]=ng;return ng end;local function nh(ni,nj,ne,nf,hx,hy,nk,nl,nm,nn,jM)local ng={enableName=ni,disableName=nj,width=ne,height=nf,x=hx,y=hy,toggleVar=nk,toggleFunction=nl,drawCondition=nm,hovered=false,class=jM}if nn then table.insert(iJ,ng)else table.insert(iI,ng)end;return ng end;local function no(np)if not iO then nq=false;nr=false;ns=false;w=true;return elseif np=="handling"then nq=not nq;nr=false;ns=false elseif np=="hud"then nr=not nr;nq=false;ns=false elseif np=="physics"then ns=not ns;nq=false;nr=false end;if ns or nr or nq then iP=iB(np)w=false else iP="none"w=true end end;local function nt()iO=not iO;if iO then iH=iJ;di("Tap LMB to see Settings")d6=w else iH=iI;di("Tap LMB to see Control Buttons")no()w=d6 end end;local function nu()local function nv(dx,dL)dx.set(not dx.get())if dx.get()then di(dL.." set to true")else di(dL.." set to false")end;if dL=="showHud"then d6=dx.get()elseif dL=="BrakeToggleDefault"then a_=k end end;local nw=50;local nx=340;local hx=500;local hy=ae/2-400;local ny=0;for dL,dx in pairs(iB("boolean"))do if type(dx.get())=="boolean"then nh(dL,dL,nx,nw,hx,hy,function()return dx.get()end,function()nv(dx,dL)end,function()return true end,true)hy=hy+nw+20;if ny==9 then hx=hx+nx+20;hy=ae/2-400;ny=0 else ny=ny+1 end end end;nh("Control View","Control View",nx,nw,10,ae/2-500,function()return true end,nt,function()return true end,true)nh("View Handling Settings",'Hide Handling Settings',nx,nw,10,ae/2-(500-nw),function()return nq end,function()no("handling")end,function()return true end,true)nh("View Hud Settings",'Hide Hud Settings',nx,nw,10,ae/2-(500-nw*2),function()return nr end,function()no("hud")end,function()return true end,true)nh("View Physics Settings",'Hide Physics Settings',nx,nw,10,ae/2-(500-nw*3),function()return ns end,function()no("physics")end,function()return true end,true)end;local function nz()local function gn()local fN=cO;local go=kv.name..". "..#bq;if cu then go=cu.GetClosestName(go)end;return cs.AddNewLocation(go,fN,false,true)end;local function nA()b5=not b5 end;local function nB(nC)if nC==1 then b3=not b3;b2=false else b2=not b2;b3=false end;b4=false;b6=false;c0=false;b7=false;bu=nil;b9=false;b8=false end;local function nD(nE,nF)cs.UpdatePosition(nil,nE,nF)end;local function gi()cs.ClearCurrentPosition()end;local function nG(gm)local lF=ct.routeWP(true)if lF and#lF>0 then return"Engage Route: "..lF[1]end;return"Engage Autopilot: "..lD(gm)end;local function nH(gm)local lF=ct.routeWP(true)if lF and#lF>0 then return"Next Route Point: "..lF[1]end;return"Disable Autopilot: "..lD(gm)end;local function nI()if ix()==1 then c0=not c0;if c0 then b4=false;b2=false;b3=false;b6=false;b9=false;b7=false;b8=false;nJ=bn;bn=false;d.control.retractLandingGears()iy:setTargetGroundAltitude(Z)fK("folOn","F")else fK("folOff","F")b1="Follow Off"cz=q;bn=nJ;if bn then d.control.deployLandingGears()iy:setTargetGroundAltitude(_)end end else di("Follow Mode only works with Remote controller")c0=false end end;local nw=50;local nx=260;local nK=j5(30)local nL=aC+aB*2+2;local nM=aD+1;nh("+","+",nK,nK,nL,nM+nK+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")nh("-","-",nK,nK,nL,nM,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")nh("0","0",nK,nK,nL,nM+nK*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nN=nh("Enable Brake Toggle","Disable Brake Toggle",nx,nw,ad/2-nx/2,ae/2+350,function()return a_ end,function()a_=not a_;if a_ then di("Brakes in Toggle Mode")else di("Brakes in Default Mode")end end)nh("Align Prograde","Disable Prograde",nx,nw,ad/2-nx/2-50-nN.width,ae/2-nw+380,function()return b3 end,function()nB(1)end)nh("Align Retrograde","Disable Retrograde",nx,nw,ad/2-nx/2+nN.width+50,ae/2-nw+380,function()return b2 end,nB,function()return ch==0 end)nO=nh(nG,nH,600,60,ad/2-600/2,ae/2-60/2-330,function()return b4 or br or cd or bA end,function()end)local M;local function nP(nQ)local gm=d1+nQ;if gm>#cU then gm=gm-#cU-1 end;if gm<0 then gm=#cU+gm end;return gm end;nR={}for M=0,10 do local nS=nh(function(eD)local gm=nP(eD.apExtraIndex)if b4 or br or cd or bA then return"Redirect: "..lD(gm)end;return nG(gm)end,function(eD)local gm=nP(eD.apExtraIndex)return nH(gm)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eD)local gm=nP(eD.apExtraIndex)return gm==bm and(b4 or br or cd or bA)end,function(eD)local gm=nP(eD.apExtraIndex)local nT=bm==gm;bm=gm;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not nT and not(b4 or br or cd or bA)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nS.apExtraIndex=M;nR[M]=nS end;nh("Save Position","Save Position",200,nO.height,nO.x+nO.width+30,nO.y,function()return false end,gn,function()return bm==0 or fW==nil end)nh("Update Position","Update Position",200,nO.height,nO.x+nO.width+30,nO.y,function()return false end,function()nD(nil)end,function()return bm>0 and fW~=nil end)nh("Save Heading","Clear Heading",200,nO.height,nO.x+nO.width+30,nO.y+nO.height+20,function()return fW.heading~=nil end,function()if fW.heading~=nil then nD(false)else nD(true)end end,function()return bm>0 and fW~=nil end)nh("Save AGG Alt","Clear AGG Alt",200,nO.height,nO.x+nO.width+30,nO.y+nO.height*2+40,function()return fW.agg~=nil end,function()if fW.agg~=nil then nD(nil,false)else nD(nil,true)end end,function()return bm>0 and fW~=nil and antigrav end)nh("Clear Position","Clear Position",200,nO.height,nO.x-200-30,nO.y,function()return true end,gi,function()return bm>0 and fW~=nil end)nh("Save Route","Save Route",200,nO.height,nO.x-200-30,nO.y+nO.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)nh("Load Route","Clear Route",200,nO.height,nO.x-200-30,nO.y+nO.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b4 or br then di("Disable Autopilot before loading route")return else ct.routeWP(false,false,1)end end,function()return true end)nw=60;nx=300;local hx=0;local hy=ae/2-150;nh("Enable Check Damage","Disable Check Damage",nx,nw,hx,hy-nw-20,function()return s end,function()s=not s end)nh("View Settings","View Settings",nx,nw,hx,hy,function()return true end,nt)hy=hy+nw+20;nh("Enable Turn and Burn","Disable Turn and Burn",nx,nw,hx,hy,function()return b5 end,nA)hx=10;hy=ae/2-300;nh("Horizontal Takeoff Mode","Vertical Takeoff Mode",nx,nw,ad/2-nx/2,hy+20,function()return b0 end,function()b0=not b0;if b0 then di("Vertical Takeoff Mode")else di("Horizontal Takeoff Mode")end end,function()return cP end)hy=hy+nw+20;nh("Engage Orbiting","Cancel Orbiting",nx,nw,hx+nx+20,hy,function()return bA end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hy=ae/2-150;nh("Glide Re-Entry","Cancel Glide Re-Entry",nx,nw,hx+nx+20,hy,function()return b9 end,function()cc=1;nB(1)end,function()return kv.hasAtmosphere and not cg end)hy=hy+nw+20;nh("Parachute Re-Entry","Cancel Parachute Re-Entry",nx,nw,hx+nx+20,hy,function()return b9 end,function()cc=2;nB(1)end,function()return kv.hasAtmosphere and not cg end)hy=hy+nw+20;nh("Engage Follow Mode","Disable Follow Mode",nx,nw,hx,hy,function()return c0 end,nI,function()return ix()==1 end)nh("Enable Repair Arrows","Disable Repair Arrows",nx,nw,hx+nx+20,hy,function()return j3 end,function()j3=not j3;if j3 then di("Repair Arrows Enabled")else di("Repair Arrows Diabled")end end,function()return ix()==1 end)hy=hy+nw+20;if not r then nh("Enable AGG","Disable AGG",nx,nw,hx,hy,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;nh(function()return dk("Switch IPH Mode - Current: %s",bB)end,function()return dk("IPH Mode: %s",bB)end,nx*2,nw,hx,hy,function()return false end,function()if bB=="All"then bB="Custom Only"elseif bB=="Custom Only"then bB="No Moons-Asteroids"else bB="All"end;di("IPH Mode: "..bB)end)hy=hy+nw+20;nh(function()return dk("Toggle Control Scheme - Current: %s",g)end,function()return dk("Control Scheme: %s",g)end,nx*2,nw,hx,hy,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;di("New Control Scheme: "..g)end)local nU=j6(20)local nS=nd(0,0,j5(70),nU,"HELP")nS=nd(nS.x+nS.width,nS.y,j5(80),nU,"INFO")nS=nd(nS.x+nS.width,nS.y,j5(70),nU,"ORBIT")nS=nd(nS.x+nS.width,nS.y,j5(70),nU,"SCOPE")nd(nS.x+nS.width,nS.y,j5(70),nU,"HIDE")end;local nV={}local nW=nil;function nV.HUDPrologue(jS)if not cV then iV=aj;iW=ak;iX=al else iV=ag;iW=ah;iX=ai end;iY=[[rgb(]]..bN(iV+0.6)..","..bN(iW+0.6)..","..bN(iX+0.6)..[[)]]iZ=[[rgb(]]..bN(iV*0.8+0.5)..","..bN(iW*0.8+0.5)..","..bN(iX*0.8+0.5)..[[)]]local nX=iY;local nY=iZ;local nZ=[[rgb(]]..bN(iV*0.4+0.5)..","..bN(iW*0.4+0.5)..","..bN(iX*0.4+0.5)..[[)]]local n_=iY;local o0=iZ;local o1=nZ;if j7()and not n then nX=[[rgb(]]..bN(iV*0.5+0.5)..","..bN(iW*0.5+0.5)..","..bN(iX*0.5+0.5)..[[)]]nY=[[rgb(]]..bN(iV*0.3+0.5)..","..bN(iW*0.3+0.5)..","..bN(iX*0.2+0.5)..[[)]]nZ=[[rgb(]]..bN(iV*0.2+0.5)..","..bN(iW*0.2+0.5)..","..bN(iX*0.2+0.5)..[[)]]end;local lr=j5;local ls=j6;jS[#jS+1]=dk([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nX,nX,nX,n_,n_,nY,nY,o0,o0,nY,nX,nZ,o0,nX,nX,nZ,nZ,o1,nZ,ad,ae,nY,nY,nY,nY,nY,n_,nY,o0,o1,o0,o0,o1)if not nW then nW=dk([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lr(630),ls(0),lr(675),ls(45),lr(960),ls(55),lr(1245),ls(45),lr(1290),ls(0),lr(1000),ls(105),lr(1040),ls(59),lr(1250),ls(51),lr(1300),ls(0),lr(1920),ls(0),lr(1920),ls(20),lr(1400),ls(20),lr(1300),ls(105),lr(920),ls(105),lr(880),ls(59),lr(670),ls(51),lr(620),ls(0),lr(0),ls(0),lr(0),ls(20),lr(520),ls(20),lr(620),ls(105),lr(890),ls(59),lr(960),ls(62),lr(1030),ls(59),lr(985),ls(112),lr(1150),ls(112),lr(1100),ls(152),lr(820),ls(152),lr(780),ls(112),lr(935),ls(112),lr(890),ls(59),lr(960),ls(62),lr(1030),ls(59),lr(985),ls(112),lr(1150),ls(112),lr(1100),ls(152),lr(820),ls(152),lr(780),ls(112),lr(935),ls(112))end;if w and I then jS[#jS+1]=nW end;return jS end;function nV.DrawVerticalSpeed(jS,e3)jR(jS,e3)end;function nV.UpdateHud(jS)local kI=cS;local o2=cT;local jZ=o2;local ke=kI;local k_=bN(c.getThrottle())local l4=cL*3.6;local l0=c.getAxisCommandValue(0)local o3=j5(1770)local o4=j6(310)if t and cR then l0=bR;k_=bR*100 end;local j9=j8()local j_="ROLL"if k_==nil then k_=0 end;if not cY then if cL>5 then kI=kH(cJ)o2=kJ(cJ)else kI=0;o2=0 end;j_="YAW"end;if cW>50000 and not cg then local o5;o5=iC(cW)jS[#jS+1]=gD(o3,o4,"PvP Boundary: "..o5,"pbright txtbig txtmid")end;jS[#jS+1]=j1;jS[#jS+1]=i5;if iQ~=""then jS[#jS+1]=iQ end;if ja~=""then jS[#jS+1]=ja end;if jb~=""then jS[#jS+1]=jb end;jR(jS,ci)if ix()==0 or m then if not j7()or n then if cY then jY(jS,am,an,jZ,j_,cY)kd(jS,ke,jZ,am,an,cY,bN(kJ(cJ)),cL)else jY(jS,am,an,o2,j_,cY)kd(jS,kI,o2,am,an,cY,bN(o2),cL)end;kl(jS,ci,cY)kK(jS,cJ,cL,am,an)end end;kZ(jS,j9,k_,l0)l3(jS,l4)l8(jS)lM(jS)if not iO and c1 then lE(jS)end;return jS end;function nV.HUDEpilogue(jS)jS[#jS+1]="</svg>"return jS end;function nV.ExtraData(jS)local o6=j5(1240)local o7=j6(55)local o8=o7+10;local o9;local lr=j5;local ls=j6;local oa=0;local j9=j8()if b0 then j9=j9 .."-VERTICAL"end;if E and gO and not b8 and not b7 and cL>20 then j9=j9 .."-COLLISION ON"end;if bD~="Off"then j9="("..bD..")-"..j9 end;if b5 then j9="TB-"..j9 end;if bI then j9="HOVERMODE-"..j9 end;if not bC then j9=j9 .."-DeCoupled"end;local ob=ls(99)local oc=ls(80)local od=ls(85)local oe=ls(31)local of=0;local og=0;local f3=cj>1000000 and fL(cj/1000000,2).."kT"or fL(cj/1000,2).."T"if cg then oa=bv else oa=bt end;local oh,oi=cp.computeDistanceAndTime(cL,0,cj,0,0,oa)if oh<0 then oh=0 end;oa=fL(oa/(cj*iG),2).."g"local oj=d:maxForceForward()o9=b.getGravityIntensity()if o9>0.1 then og=cj*o9;og=fL(og/(cj*iG),2).."g"of=0.5*oj/o9;of=of>1000000 and fL(of/1000000,2).."kT"or fL(of/1000,2).."T"end;oj=fL(oj/(cj*iG),2).."g"local ok=vec3(bP.getWorldAcceleration()):len()/9.80665;o9=b.getGravityIntensity()jS[#jS+1]=[[<g class="dim txt txtend size14">]]if ix()==1 and not m then o6=j5(1120)o7=j6(55)o8=o7+10 elseif cg and I then local ol=j5(770)jS[#jS+1]=gD(lr(895),ob,"ATMO","")jS[#jS+1]=dk([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lr(895),od,lr(-80))jS[#jS+1]=gD(lr(815),oc,dk("%.1f%%",ch*100),"txtstart size20")end;if I then jS[#jS+1]=gD(lr(1025),ob,"GRAVITY","txtstart")jS[#jS+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lr(1025),od,lr(80))jS[#jS+1]=gD(lr(1105),oc,dk("%.2fg",o9/9.80665),"size20")jS[#jS+1]=gD(lr(1125),ob,"ACCEL","txtstart")jS[#jS+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lr(1125),od,lr(80))jS[#jS+1]=gD(lr(1205),oc,dk("%.2fg",ok),"size20")jS[#jS+1]=gD(lr(695),ob,"BRK TIME","")jS[#jS+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lr(695),od,lr(-80))jS[#jS+1]=gD(lr(615),oc,dk("%s",iD(oi)),"txtstart size20")jS[#jS+1]=gD(lr(635),ls(45),"TRIP","")jS[#jS+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lr(635),ls(31),lr(-90))if lo then jS[#jS+1]=gD(lr(545),ls(26),dk("%s",iD(lo)),"txtstart size20")end;jS[#jS+1]=gD(lr(795),ob,"BRK DIST","")jS[#jS+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lr(795),od,lr(-80))jS[#jS+1]=gD(lr(715),oc,dk("%s",iC(oh)),"txtstart size20")jS[#jS+1]=gD(lr(1285),ls(45),"MASS","txtstart")jS[#jS+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lr(1285),ls(31),lr(90))jS[#jS+1]=gD(lr(1375),ls(26),dk("%s",f3),"size20")jS[#jS+1]=gD(lr(1220),ob,"THRUST","txtstart")jS[#jS+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lr(1220),od,lr(80))jS[#jS+1]=gD(lr(1300),oc,dk("%s",oj),"size20")jS[#jS+1]=gD(j5(960),j6(175),j9,"pbright txtbig txtmid size20")end;jS[#jS+1]="</g>"end;local om=1-(a7*0.05+a8*0.05)function nV.FuelUsed(on)local oo;if on=="atmofueltank"then oo=dk("Atmo Fuel Used: %.1f L",js[on]/(4*om))elseif on=="spacefueltank"then oo=dk("Space Fuel Used: %.1f L",js[on]/(6*om))else oo=dk("Rocket Fuel Used: %.1f L",js[on]/(0.8*om))end;return oo end;local op,oq,os,ot,ou=0,0,0,{},0;local ov=0;local ow=0;local ox=0;function nV.DrawOdometer(jS,i_,bo,j0)if bK~="INFO"then return jS end;local o9;local oa=0;local og=0;local f3=cj>1000000 and fL(cj/1000000,2).." kTons"or fL(cj/1000,2).." Tons"if cg then oa=bv else oa=bt end;local oh,oi=cp.computeDistanceAndTime(cL,0,cj,0,0,oa)oa=fL(oa/(cj*iG),2).." g"local oj=d:maxForceForward()o9=b.getGravityIntensity()if cL<5 then local oy=vec3(bP.getOrientationForward())local oz=bP.getMaxThrustAlongAxis('thrust analog longitudinal ',{oy:unpack()})ov=0.5*oz[1]/o9;ov=ov>1000000 and fL(ov/1000000,1).." kTons"or fL(ov/1000,1).." Tons"ow=0.5*oz[3]/o9;ow=ow>1000000 and fL(ow/1000000,1).." kTons"or fL(ow/1000,1).." Tons"oy=vec3(bP.getOrientationUp())oz=bP.getMaxThrustAlongAxis('hover_engine, booster_engine',{oy:unpack()})ox=0.5*oz[1]/o9;ox=ox>1000000 and fL(ox/1000000,1).." kTons"or fL(ox/1000,1).." Tons"end;if o9>0.1 then og=cj*o9;og=fL(og/(cj*iG),2).." g"else og="n/a"end;oj=fL(oj/(cj*iG),2).." g"if ix()==0 or m then local oA=j5(aC+10)local oB=j6(aD+20)local oC=j5(aC+10+aB/1.25)local nf=25;local oD=bN(1/aU)if os<oD then ou=ou+a.getActionUpdateDeltaTime()os=os+1 else op=1/(ou/oD)table.insert(ot,op)os,ou=0,0 end;oq=0;for dL,dx in pairs(ot)do oq=oq+dx end;if#ot>0 then oq=bN(oq/#ot)end;if#ot>29 then table.remove(ot,1)end;jS[#jS+1]="<g class='txtstart size14 bright'>"jS[#jS+1]=gD(oA,oB,dk("BrkTime: %s",iD(oi)))jS[#jS+1]=gD(oC,oB,dk("Trip: %.2f km",i_))jS[#jS+1]=gD(oA,oB+nf,dk("Lifetime: %.2f kSU",bo/200000))jS[#jS+1]=gD(oC,oB+nf,dk("BrkDist: %s",iC(oh)))jS[#jS+1]=gD(oA,oB+nf*2,"Trip Time: "..iD(j0))jS[#jS+1]=gD(oC,oB+nf*2,"Total Time: "..iD(bp))jS[#jS+1]=gD(oA,oB+nf*3,dk("Mass: %s",f3))jS[#jS+1]=gD(oC,oB+nf*3,dk("Max Brake: %s",oa))jS[#jS+1]=gD(oA,oB+nf*4,dk("Max Thrust: %s",oj))jS[#jS+1]=gD(oC,oB+nf*4,dk("Safe Atmo Mass: %s",ov))jS[#jS+1]=gD(oA,oB+nf*5,dk("Req Thrust: %s",og))jS[#jS+1]=gD(oC,oB+nf*5,dk("Safe Space Mass: %s",ow))jS[#jS+1]=gD(oC,oB+nf*6,dk("Safe Hover Mass: %s",ox))jS[#jS+1]=gD(oA,oB+nf*6,dk("Influence: %s",kv.name))jS[#jS+1]=gD(oA,oB+nf*7,dk("Set Max Speed: %s",bN(a1*3.6+0.5)))jS[#jS+1]=gD(oC,oB+nf*7,dk("Actual Max Speed: %s",bN(df*3.6+0.5)))jS[#jS+1]=gD(oA,oB+nf*8,dk("Friction Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))jS[#jS+1]=gD(oC,oB+nf*8,dk("FPS (Avg): %s (%s)",bN(op),oq))end;jS[#jS+1]="</g></g>"return jS end;function nV.DrawWarnings(jS)return l8(jS)end;function nV.DisplayOrbitScreen(jS)return lM(jS)end;function nV.DisplayMessage(jS,lj)if lj~="empty"then local hy=310;for ll in string.gmatch(lj,"([^\n]+)")do hy=hy+35;jS[#jS+1]=gD("50%",hy,ll,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;function nV.DrawDeadZone(jS)jS[#jS+1]=dk([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function nV.UpdatePipe()if cg then iQ=""return end;n4()end;function nV.DrawSettings(jS)local hx=j5(640)local hy=j6(200)jS[#jS+1]=[[<g class="pbright txtvspd txtstart">]]local hO=0;for dL,dx in pairs(iP)do hO=hO+1;jS[#jS+1]=gD(hx,hy,dL..": "..dx.get())hy=hy+20;if hO%12==0 then hx=hx+j5(350)hy=j6(200)end end;jS[#jS+1]=gD(j5(640),j6(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jS[#jS+1]="</g>"return jS end;local i4=j6(125)local i3=j5(1225)function nV.DrawRadarInfo()i5=cu.GetRadarHud(i3,i4,ay,az)if i5 then gO=true end end;function nV.DrawTanks()if au~=0 and av~=0 then ja=gD(au,av,"","txtstart pdim txtfuel")jt=av;ju(au,"Atmospheric ","ATMO",cl,jq,jr)ju(au,"Space Fuel T","SPACE",cm,jo,jp)ju(au,"Rocket Fuel ","ROCKET",cn,jm,jn)end end;function nV.DrawShield()local ig=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oE=bP.getPvPTimer()local oF=shield.getResistances()local oG="A: "..10+oF[1]*100 .."% / E: "..10+oF[2]*100 .."% / K:"..10+oF[3]*100 .."% / T: "..10+oF[4]*100 .."%"local hx,hy=aw-60,ax+30;local jK=bN(dg*2.55)local jL=dk("rgb(%d,%d,%d)",255-jK,jK,0)local jM=""jb=gD(hx,hy,"","txtmid pdim txtfuel")if dg<10 and ig~="Shield Disabled"then jM="red "end;oE=oE>0 and"   PvPTime: "..iD(oE)or""jb=jb..dk([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hx,hy,jL,dg*2,hx,hy,hx+2,hy+10,dg,oE)jb=jb..gD(hx,hy-5,ig,jM.."txtstart pbright txtbig")jb=jb..gD(hx,hy+30,oG,jM.."txtstart pbright txtsmall")end;function nV.hudtick()if not kv then return end;local function oH(jS)local jO=bN(dl(dd/(ad/4)*255,0,255))jS[#jS+1]=dk("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(iV+0.5)+jO,bN(iW+0.5)-jO,bN(iX+0.5)-jO)end;local function oI()if c2 then for dQ,dx in pairs(iH)do if dx.hovered then if not dx.drawCondition or dx.drawCondition(dx)then dx.toggleFunction(dx)end;dx.hovered=false end end;for dQ,dx in pairs(iK)do if dx.hovered then bK=dx.label;dx.hovered=false end end;c2=false end end;local function oJ()local function oK(oL,oM,hx,hy,ne,nf)if oL>=hx and oL<=hx+ne and oM>=hy and oM<=hy+nf then return true else return false end end;local hx=c9+ad/2;local hy=ca+ae/2;for dQ,dx in pairs(iH)do dx.hovered=oK(hx,hy,dx.x,dx.y,dx.width,dx.height)end;for dQ,dx in pairs(iK)do dx.hovered=oK(hx,hy,dx.x,dx.y,dx.width,dx.height)end;if d0 then local mU=false;for dQ,eD in ipairs(nR)do if eD.hovered then mU=true;break end end;if nO.hovered then mU=true end;d0=mU else d0=nO.hovered;if not d0 then d1=bm end end end;local function oN(jS)if not bK or bK==""then bK="HELP"end;if w then for dL,dx in pairs(iK)do local jM="dim brightstroke"local oO=0.2;if bK==dL then jM="pbright dimstroke"oO=0.6 end;local oP=""if dx.hovered then oO=0.8;oP=";stroke:white"end;jS[#jS+1]=dk([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dx.width,dx.height,dx.x,dx.y,jM,oO,oP)jS[#jS+1]=gD(dx.x+dx.width/2,dx.y+dx.height/2+5,dx.label,"txt txtmid pdim")end end end;local function oQ(jS)local function oR(jS,oS,hover,hx,hy,oT,oU,oV,oW,oX,oY,nS)if type(oX)=="function"then oX=oX(nS)end;if type(oY)=="function"then oY=oY(nS)end;jS[#jS+1]=dk("<rect x='%f' y='%f' width='%f' height='%f' fill='",hx,hy,oT,oU)if oS then jS[#jS+1]=dk("%s'",oV)else jS[#jS+1]=oW end;if hover then jS[#jS+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else jS[#jS+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fL(ag*0.5,0),fL(ah*0.5,0),fL(ai*0.5,0))end;jS[#jS+1]=" rx='5'></rect>"jS[#jS+1]=dk("<text x='%f' y='%f' font-size='24' fill='",hx+oT/2,hy+oU/2+5)if oS then jS[#jS+1]="black"else jS[#jS+1]="white"end;jS[#jS+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oS then jS[#jS+1]=dk("%s</text>",oX)else jS[#jS+1]=dk("%s</text>",oY)end end;local oZ=dk("rgb(%d,%d,%d)'",fL(ag*0.1,0),fL(ah*0.1,0),fL(ai*0.1,0))local o_=dk("rgb(%d,%d,%d)",fL(ag*0.8,0),fL(ah*0.8,0),fL(ai*0.8,0))local p0=oR;for dQ,dx in pairs(iH)do local nj=dx.disableName;local ni=dx.enableName;if type(nj)=="function"then nj=nj(dx)end;if type(ni)=="function"then ni=ni(dx)end;if not dx.drawCondition or dx.drawCondition(dx)then p0(jS,dx.toggleVar(dx),dx.hovered,dx.x,dx.y,dx.width,dx.height,o_,oZ,nj,ni,dx)end end end;local p1=fL(ad/2,0)local p2=fL(ae/2,0)local jS={}if p3 then jS[#jS+1]=p3 end;cr.HUDPrologue(jS)if w then cr.UpdateHud(jS)else if A then cr.DrawVerticalSpeed(jS,ci)end;cr.DrawWarnings(jS)end;if iO and iP~="none"then cr.DrawSettings(jS)end;if cu then cr.DrawRadarInfo()else i5=""end;cr.HUDEpilogue(jS)jS[#jS+1]=dk([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c3~="empty"then cr.DisplayMessage(jS,c3)end;if ix()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(jS)end end;oN(jS)if iz()==0 then if ix()==1 and c1 then if not p4 then oJ()oQ(jS)end;if not cx and not cy then local p5=table.concat(jS,"")jS={}jS[#jS+1]=dk("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jS[#jS+1]=p5;jS[#jS+1]="</body>"cx=true;jS[#jS+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local p5=table.concat(jS,"")jS={}jS[#jS+1]=dk("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jS[#jS+1]=p5;jS[#jS+1]="</body>"end;if not cx then jS[#jS+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p1,p2,c9,ca)end else oI()end else if not c1 and ix()==0 then oI()if dd>aA then if v then oH(jS)end end elseif c1 and(not p4 or not j)then oJ()oQ(jS)end;jS[#jS+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p1,p2,c9,ca)end;jS[#jS+1]=[[</svg></body>]]p6=table.concat(jS,"")end;function nV.TenthTick()local function p7()local p8=a.createData;local p9=a.createWidget;pa=a.createWidgetPanel("Interplanetary Helper")pb=p9(pa,"value")pc=p8('{"label": "Target Planet", "value": "N/A", "unit":""}')fJ(pc,pb)pd=p9(pa,"value")pe=p8('{"label": "distance", "value": "N/A", "unit":""}')fJ(pe,pd)gc=p9(pa,"value")gb=p8('{"label": "Travel Time", "value": "N/A", "unit":""}')fJ(gb,gc)ge=p9(pa,"value")gd=p8('{"label": "Target Altitude", "value": "N/A", "unit":""}')fJ(gd,ge)pf=p9(pa,"value")pg=p8('{"label": "End Speed", "value": "N/A", "unit":""}')g6=p9(pa,"value")g5=p8('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g4=p9(pa,"value")g3=p8('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g2=p9(pa,"value")g1=p8('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g0=p9(pa,"value")f_=p8('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g8=p9(pa,"value")g7=p8('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fJ(pg,pf)fJ(g5,g6)fJ(g3,g4)fJ(g1,g2)fJ(f_,g0)fJ(g7,g8)end end;local function ph()gC(pa)pa=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bk~="None"then if pa==nil then p7()end;if bk~=nil then local mv;local pi=fW~=nil;local pj=b4 and bg*3.6 or 0;fI(pc,'{"label": "Target", "value": "'..bk..'", "unit":""}')if pi and not b4 then mv=(cO-fW.position):len()else mv=(bl-cO):len()end;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)iS,iT=ct.GetAutopilotBrakeDistanceAndTime(a1)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)iS,iT=ct.GetAutopilotTBBrakeDistanceAndTime(a1)end;local lj=iC(mv)fI(pe,'{"label": "distance", "value": "'..lj..'"}')fI(gb,'{"label": "Travel Time", "value": "'..iD(lo)..'", "unit":""}')lj=iC(c6)fI(g5,'{"label": "Cur Brake distance", "value": "'..lj..'"}')fI(g3,'{"label": "Cur Brake Time", "value": "'..iD(c7)..'", "unit":""}')lj=iC(iS)fI(g1,'{"label": "Max Brake distance", "value": "'..lj..'"}')fI(f_,'{"label": "Max Brake Time", "value": "'..iD(iT)..'", "unit":""}')fI(pg,'{"label": "End Speed", "value": "'..dk("%.0fkph",pj)..'", "unit":""}')lj=iC(gf)fI(gd,'{"label": "Target Orbit", "value": "'..lj..'"}')if cg and not pk then dh("HERE")a.removeDataFromWidget(f_,g0)a.removeDataFromWidget(pg,pf)a.removeDataFromWidget(g1,g2)a.removeDataFromWidget(g3,g4)a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)pk=true;if not cR and t and(b6 or b9 or ce)then ct.cmdThrottle(1)b1=false;bV=false end end;if not cg and pk then if fI(f_,g0)==1 then fJ(f_,g0)end;if fI(f_,pf)==1 then fJ(pg,pf)end;if fI(g1,g2)==1 then fJ(g1,g2)end;if fI(g3,g4)==1 then fJ(g3,g4)end;if fI(g5,g6)==1 then fJ(g5,g6)end;if fI(g7,g8)==1 then fJ(g7,g8)end;pk=false end end else ph()end;if warpdrive~=nil then local pl=iv(warpdrive.getWidgetData())if pl.destination~="Unknown"and pl.distance>400000 then if not j4 then warpdrive.showWidget()j4=true end elseif j4 then warpdrive.hideWidget()j4=false end end end;function nV.OneSecondTick()local function pm()local jE=bM()local l4=cL;local pn=jE-j2;if l4>1.38889 then l4=l4/1000;local po=l4*(jE-j2)bo=bo+po;i_=i_+po end;j0=j0+pn;bp=bp+pn;j2=jE end;local function pp(jS)local pq=0;local pr=iF;local ps=0;local pt=0;local pu=0;local jK=0;local jL=""local pv=b.getElementHitPointsById;local pw=b.getElementMaxHitPointsById;local px={}for dL in pairs(iE)do local py=0;local pz=0;pz=pw(iE[dL])py=pv(iE[dL])ps=ps+py;if py+1<pz then if py==0 then pu=pu+1 else pt=pt+1 end;if j3 and#px==0 then fN=vec3(b.getElementPositionById(iE[dL]))local hx=fN.x;local hy=fN.y;local hz=fN.z;table.insert(px,b.spawnArrowSticker(hx,hy,hz+1,"down"))table.insert(px,b.spawnArrowSticker(hx,hy,hz+1,"down"))b.rotateSticker(px[2],0,0,90)table.insert(px,b.spawnArrowSticker(hx+1,hy,hz,"north"))table.insert(px,b.spawnArrowSticker(hx+1,hy,hz,"north"))b.rotateSticker(px[4],90,90,0)table.insert(px,b.spawnArrowSticker(hx-1,hy,hz,"south"))table.insert(px,b.spawnArrowSticker(hx-1,hy,hz,"south"))b.rotateSticker(px[6],90,-90,0)table.insert(px,b.spawnArrowSticker(hx,hy-1,hz,"east"))table.insert(px,b.spawnArrowSticker(hx,hy-1,hz,"east"))b.rotateSticker(px[8],90,0,90)table.insert(px,b.spawnArrowSticker(hx,hy+1,hz,"west"))table.insert(px,b.spawnArrowSticker(hx,hy+1,hz,"west"))b.rotateSticker(px[10],-90,0,90)table.insert(px,iE[dL])end elseif j3 and#px>0 and px[11]==iE[dL]then for jD in pairs(px)do b.deleteSticker(px[jD])end;px={}end end;pq=fL(ps/pr*100,2)if pu>0 or pt>0 then jS[#jS+1]=gD(0,0,"","pbright txt")jK=bN(pq*2.55)jL=dk("rgb(%d,%d,%d)",255-jK,jK,0)jS[#jS+1]=gD("50%",1035,"Elemental Integrity: "..pq.."%","txtbig txtmid","fill:"..jL)if pu>0 then jS[#jS+1]=gD("50%",1055,"Disabled Modules: "..pu.." Damaged Modules: "..pt,"txtbig txtmid","fill:"..jL)elseif pt>0 then jS[#jS+1]=gD("50%",1055,"Damaged Modules: "..pt,"txtbig txtmid","fill:"..jL)end end end;local function pA()if iu then if iU==nil and(hb~=nil or bn)then _autoconf.displayCategoryPanel(iu,weapon_size,"Weapons","weapon",true)iU=_autoconf.panels[_autoconf.panels_size]elseif iU~=nil and hb==nil and not bn then gC(iU)iU=nil end end end;local jS={}pm()if s then pp(jS)end;pA()cr.UpdatePipe()cr.ExtraData(jS)j1=table.concat(jS,"")end;function nV.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function nV.MsgTick()local jS={}cr.DisplayMessage(jS,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function nV.ButtonSetup()nu()nz()iH=iI end;if pB then for dL,dx in pairs(pB)do nV[dL]=dx end end;return nV end;local function pC(d,b,c,e,vBooster,hover,pD,antigrav,dbHud_1,eZ,bN,bO,ix,eU,bM,dl,iy,fI,iz,dn,fL,fK,iA,dp,iC,iD,pE,iv,di)local a=DUSystem;local bP=DUConstruct;local pF={}local pG=false;local pH=0;local pI=0;local pJ=0;local pK=bM()local pL=0;local pM=0;local pN=0;local pO=0;local pP=false;local pQ=false;local pR=false;local pS=nil;local pT=0;local iR=55;local pU=nil;local pV=false;local pW=false;local pX=false;local pY=0;local pZ=0;local p_=0;local q0=0;local q1=0;local q2={VectorToTarget=false}local q3=vec3(bP.getWorldOrientationUp())local q4=nil;local q5=0;local q6=-1;local q7=-1;local q8=false;local q9=false;local qa=0;local qb=false;local qc=false;local qd=false;local qe=false;local qf=""local qg=false;local qh=false;local qi=""local qj=false;local qk=0;local ql=0;local function qm()return bP.isInPvPZone()~=1,eZ(bP.getDistanceToSafeZone())end;local function qn(kg)local qo=bg;if not b4 then qo=0 end;local qp=bt;if cg then if bv and bv>0 then qp=bv else return 0,0 end end;return cp.computeDistanceAndTime(kg,qo,cj,0,0,qp-bi*cj)end;local function qq(kg)local qo=bg;if not b4 then qo=0 end;return cp.computeDistanceAndTime(kg,qo,cj,d:maxForceForward(),a3,bt-bi*cj)end;local function qr(qs,qt,qu)qt=qt:project_on_plane(qs)qu=qu:project_on_plane(qs)return eU(qt:cross(qu):dot(qs),qt:dot(qu))end;local qv=-1;local qw=-1;local function qx()local function qy()local qz=-1;local qA=-1;if vBooster then qz=vBooster.getDistance()if qz>-1 and qz<0.01 then qz=qv else qv=qz end end;if hover then qA=hover.getDistance()if qA>-1 and qA<0.01 then qA=qw else qw=qA end end;if qz~=-1 and qA~=-1 then if qz<qA then return qz else return qA end elseif qz~=-1 then return qz elseif qA~=-1 then return qA else return-1 end end;local qB=qy()local qC=-1;if antigrav and antigrav.isActive()==1 and not r and cL<iR then local qD=eZ(ci-antigrav.getBaseAltitude())if qD<50 then return qD end end;if pD then qC=pD.raycast().distance;if qC==0 then qC=-1 end end;if qB~=-1 and qC~=-1 then if qB<qC then return qB else return qC end elseif qB~=-1 then return qB else return qC end end;local function qE(kv,eL,qF)local function qG(qH,dX)local eR=vec3(dX)if qH.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=qH.systemId},dZ)end;local eS=eR-qH.center;local cb=eS:len()local e3=cb-qH.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=math.deg(e1),longitude=math.deg(e2),altitude=e3,id=qH.id,systemId=qH.systemId},dZ)end;local qI=qG(kv,eL)qI="::pos{"..qI.systemId..","..qI.id..","..qI.latitude..","..qI.longitude..","..qI.altitude.."}"if qF then return qI else qd=qI;return true end end;local function qJ(qK,qL,qM)local function qN(qK,eu)qK=vec3(qK)eu=vec3(eu):normalize()local dG=qK*eu;return dG.x+dG.y+dG.z end;local qO=0.001;local qP=1;if not cg or not cA or cf~=-1 or cL<iR then if qM==nil then qM=aT end;if qL==nil then qL=qO end;qK=vec3(qK):normalize()local qQ=vec3()-qK;local qR=-qN(qQ,bP.getWorldOrientationRight())*qP;local qS=-qN(qQ,bP.getWorldOrientationUp())*qP;if pI==0 then pI=qR/2 end;if pJ==0 then pJ=qS/2 end;if eZ(qR)<0.1 then pZ=pZ-qR*2 else pZ=pZ-(qR+(qR-pI)*qM)end;if eZ(qS)<0.1 then pY=pY+qS*2 else pY=pY+qS+(qS-pJ)*qM end;pI=qR;pJ=qS;if eZ(qR)<qL and eZ(qS)<qL then return true end;return false elseif cA and cf==-1 then qK=cK;if qM==nil then qM=aT end;if qL==nil then qL=qO end;qK=vec3(qK):normalize()local qQ=cH-qK;local qR=-qN(qQ,bP.getWorldOrientationRight())*qP;local qS=-qN(qQ,bP.getWorldOrientationUp())*qP;if pI==0 then pI=qR/2 end;if pJ==0 then pJ=qS/2 end;if eZ(qR)<0.1 then pZ=pZ-qR*5 else pZ=pZ-(qR+(qR-pI)*qM)end;if eZ(qS)<0.1 then pY=pY+qS*5 else pY=pY+qS+(qS-pJ)*qM end;pI=qR;pJ=qS;if eZ(qR)<qL and eZ(qS)<qL then return true end;return false end end;function pF.clearAll()bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"b2=false;b3=false;cX=nil;b6=false;b9=false;b7=false;b8=false;ba=false;c0=false;pW=false;cc=false;cd=false;pX=false;cz=q;br=false;b5=false;ck=false;bu=nil;bA=false;db=false;dc=nil;ce=false end;function pF.GetAutopilotBrakeDistanceAndTime(kg)return qn(kg)end;function pF.GetAutopilotTBBrakeDistanceAndTime(kg)return qq(kg)end;function pF.showWayPoint(kv,eL,qF)return qE(kv,eL,qF)end;function pF.APTick()local qT=a.getMouseWheel()if qT>0 then ct.changeSpd()elseif qT<0 then ct.changeSpd(true)else pV=true end;qa=iz()if qd then a.setWaypoint(qd)qd=false end;if qg then antigrav.setTargetAltitude(qg)qg=false end;if qe then fI(qe,qf)qe=false;qf=""end;if q7~=-1 then ct.cmdCruise(q7,q8)q8=false;q7=-1 end;if q4~=nil then if iy:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iy:getTargetSpeed(axisCommandId.longitudinal)~=q4 then iy:setTargetSpeedCommand(axisCommandId.longitudinal,q4)else q4=nil end end;if q6~=-1 then ct.cmdThrottle(q6,q8)q8=false;q6=-1 end;if q9 then cv.landingGear(q9)q9=false end;if qh then ct.ToggleAutopilot()end end;function pF.ToggleIntoOrbit()cE=false;pN=nil;pO=nil;pT=0;if not cg then if bA then fK("orOff","AP")bA=false;pP=false;pS=nil;cz=q;if b6 then b6=false;b8=false end;q2.VectorToTarget=false;q2.AutopilotAlign=false;pR=false elseif cY then fK("orOn","AP")bA=true;cz=true;if pS==nil then pS=kv end;if b6 then b6=false;b8=false end else di("Unable to engage auto-orbit, not near a planet")end else bA=false;pP=false;pS=nil;cz=q;if b6 then b6=false end;q2.VectorToTarget=false;q2.AutopilotAlign=false;pR=false end end;function pF.ToggleVerticalTakeoff()b6=false;if ba then qU=true;b9=false;b8=false;b7=true;cz=true;b_=0;if cg and cf==-1 then b7=false;b6=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q7=bN(cB)end else cE=false;bn=false;d.control.retractLandingGears()iy:setTargetGroundAltitude(Z)b1="VTO Takeoff"end;ba=not ba end;function pF.checkLOS(qK)local lm,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,qK,function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local ln=eJ;if eK~=nil and eJ~=nil then ln=math.min(eK,eJ)end;if ln~=nil then return lm,ln else return nil,nil end end;local function qV(qW,qX)if qX then b_=0;iy:updateCommandFromActionStop(axisCommandId.vertical,qX)if bC then iy:activateGroundEngineAltitudeStabilization(qY)de=true end else b_=b_+qW;iy:deactivateGroundEngineAltitudeStabilization()iy:updateCommandFromActionStart(axisCommandId.vertical,qW)end end;function pF.vertical(qW,qX)qV(qW,qX)end;function pF.ToggleAutopilot()local function qZ(by)cZ=false;br=not br;if br then b5=false;if not b6 and not by then ct.ToggleAltitudeHold()end end;lq="Proceeding to Waypoint"end;local function q_(go)if go then for M,dL in pairs(cU)do if dL.name and dL.name==go then return M end end else return 0 end end;local r0=false;bI=false;if bQ-pM<1.5 and cg then if not cG then if cg then bb=kv.spaceEngineMinAltitude-0.01*kv.noAtmosphericDensityAltitude;fK("11","EP")pM=-1;if b4 or br or bA then return end else di("No space engines detected, Orbital Hop not supported")return end elseif kv.hasAtmosphere then if cg then bb=kv.noAtmosphericDensityAltitude+V;fK("orH","OH")end;pM=-1;if b4 or br or bA then return end end else pM=bQ end;r1=false;if(bm>0 or#bG>0)and not b4 and not br and not cd and not bA then if b6 then b6=false end;if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then di("WARNING: Heavy Loads may affect autopilot performance.")end;if#bG>0 and not ce then bm=q_(bG[1])cs.UpdateAutopilotTarget()di("Route Autopilot in Progress")local qQ=fW.position-cO;local r2=qQ:project_on_plane(cM):len()if r2>50000 and fW.planetname==kv.name then r0=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c8,bl)if fW~=nil then if fW.agg and not r and antigrav then if not cQ then ct.ToggleAntigrav()end;bw=fW.agg end;bu=nil;by=fW.planetname=="Space"if by then fK("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end elseif kv.name==fW.planetname then qU=true;if cg then if not br then fK("vtt","AP")qZ(by)if r0 then bb=kv.noAtmosphericDensityAltitude+V end end else fK("apOn","AP")if not(c8.name==kv.name and ci<gf*1.5)then cE=false;b4=true elseif not cg then if bA then ct.ToggleIntoOrbit()end;cD=kv.noAtmosphericDensityAltitude+V;pR=true;q2.AutopilotAlign=true;q2.VectorToTarget=true;pP=false;if not bA then ct.ToggleIntoOrbit()end end end else fK("apP","AP")b2=false;b3=false;if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end end elseif not cg then if fW==nil and(c8.name==kv.name and cY)and not bA then r3=false;cE=false;pP=false;ct.ToggleIntoOrbit()else fK("apP","AP")b4=true;b2=false;b3=false;bd=false;c0=false;b6=false;b7=false;b9=false;b8=false;pW=false;bu=nil;r3=false end else fK("apP","AP")cd=true;ct.ToggleAltitudeHold()end;qh=false else fK("apOff","AP")ct.ResetAutopilots(1)if qh==2 then qh=true end end end;function pF.routeWP(r4,r5,r6)if r6 then if r6==1 then bG={}bG=iA(bG,bF)if#bG>0 then di("Route Loaded")else di("No Saved Route found on Databank")end;return bG else bF={}bF=iA(bF,bG)di("Route Saved")pE()return end end;if r4 then return bG end;if r5 then bG={}di("Current Route Cleared")else bG[#bG+1]=fW.name;di("Added "..fW.name.." to route. ")end;return bG end;function pF.cmdThrottle(dM,r7)if iy:getAxisCommandType(0)~=axisCommandType.byThrottle and not r7 then d.control.cancelCurrentControlMasterMode()end;iy:setThrottleCommand(axisCommandId.longitudinal,dM)bR=dl(fL(dM*100,0)/100,-1,1)q4=nil end;function pF.cmdCruise(dM,r7)if iy:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r7 then d.control.cancelCurrentControlMasterMode()end;iy:setTargetSpeedCommand(axisCommandId.longitudinal,dM)q4=dM end;function pF.ToggleLockPitch()if bu==nil then fK("lkPOn","LP")if not c1 then bu=cS else bu=S end;b8=false;b6=false;b7=false else fK("lkPOff","LP")bu=nil end end;function pF.ToggleAltitudeHold()if bQ-pL<1.5 then bI=false;if kv.hasAtmosphere then if cg then bb=kv.spaceEngineMinAltitude-0.01*kv.noAtmosphericDensityAltitude;fK("11","EP")else if cY then bb=kv.noAtmosphericDensityAltitude+V;cD=bb;pR=true;if not bA then ct.ToggleIntoOrbit()end;pP=true end end;pL=-1;if b6 or bA or ba then return end end else pL=bQ end;if cY and not cg and cf==-1 then cD=ci;pR=true;pP=true;ct.ToggleIntoOrbit()if bA then pL=bQ else pL=0 end;return end;b6=not b6;b7=false;b9=false;if b6 then b4=false;b3=false;b2=false;c0=false;cz=true;bu=nil;cE=false;if cf~=-1 then if not bn and not br and not cd then bb=ci;bI=cf;iy:setTargetGroundAltitude(bI)elseif cL<20 then if bn then cv.landingGear()end;fK("lfs","LS")b8=true;if cg then bb=ci+Y else bb=kv.surfaceMaxAltitude+100 end;b1="ATO Hold"iy:setTargetGroundAltitude(Z)if b0 and cP then ct.ToggleVerticalTakeoff()end end else fK("altOn","AH")b8=false;if pL>-1 then if cY then bb=ci end end;if ba then ct.ToggleVerticalTakeoff()end end;if cQ and not r then local r8=antigrav.getBaseAltitude()if br and fW.agg and fW.agg>ci then bb=fW.agg elseif b8 then bb=r8 end;if eZ(ci-r8)<100 and cL<20 then bb=r8;b1="AGG Hold"q6=0 end end;if cd then bb=200000 end else fK("altOff","AH")if bA then ct.ToggleIntoOrbit()end;if ba then ct.ToggleVerticalTakeoff()end;cz=q;b8=false;br=false;pL=0;bI=false end end;function pF.ResetAutopilots(pF)if pF then cd=false;b4=false;bd=false;pW=false;bb=ci;r1=false;db=false;bh="Aligning"end;br=false;b8=false;b9=false;b3=false;b7=false;dc=nil;r9=false;cX=nil;db=false;if not cQ then b6=false;bu=nil end;if ba then ct.ToggleVerticalTakeoff()end;if bA then ct.ToggleIntoOrbit()end;cz=q;cc=false;ce=false;b_=0 end;function pF.BrakeToggle(ra)if not b1 then if ra then b1=ra else b1=true end else b1=false end;if b7 then b7=false;cz=q;db=false end;if b1 then fK("bkOn","B",1)ct.ResetAutopilots()else fK("bkOff","B",1)end end;function pF.BeginReentry()if b9 then di("Re-Entry cancelled")fK("reOff","RE")b9=false;cz=q;b6=false elseif not kv.hasAtmosphere then di("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c4=5 elseif not pX then b9=true;if iy:getAxisCommandType(0)~=rb.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b1=false;di("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB)fK("par","RE")else b9=true;b6=true;cz=true;b1=false;bb=kv.surfaceMaxAltitude+a0;if bb>kv.spaceEngineMinAltitude then bb=kv.spaceEngineMinAltitude-0.01*kv.noAtmosphericDensityAltitude end;local rc=iC(bb)di("Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..rc)fK("glide","RE")q7=bN(cB)end;b8=false end;function pF.ToggleAntigrav()if antigrav and not r then if cQ then fK("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bw==nil then bw=ci end;if bw<1000 then bw=1000 end;fK("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pF.changeSpd(rd)local re=1;if rd then re=-1 end;if not c1 then if t and not p4 and pV then local rf=bR;bR=fL(dl(bR+re*aF/100,-1,1),2)if bR>=0 and rf<0 then bR=0;pV=false end elseif p4 then if cg or b9 then cB=dl(cB+re*aF,0,W)elseif b4 then a1=dl(a1+re*aF/3.6*100,0,df-0.2)end else iy:updateCommandFromActionStart(axisCommandId.longitudinal,re*aF/10)end else if b4 or br or cd or bA then d1=d1+1*re*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not rd then re=1 else re=nil end;cs.adjustAutopilotTargetIndex(re)end end end;function pF.TenthTick()local function rg()if not b4 then if fW==nil or fW.planetname~=kv.name then rh=(c8.center-cO):len()else rh=(fW.position-cO):len()end end;local kg=cL;local ri=c.getThrottle()/100;if t then ri=bR end;local rj,rk=cp.computeDistanceAndTime(cL,a1,cj,d:maxForceForward()*ri,a3,0)local c6,c7;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(a1)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dQ,rl;if not b5 and kg>0 then dQ,rl=ct.GetAutopilotBrakeDistanceAndTime(kg)else dQ,rl=ct.GetAutopilotTBBrakeDistanceAndTime(kg)end;local rm=0;local rn=0;if bf or not b4 and kg>5 then rn=cp.computeTravelTime(kg,0,rh)elseif c6+rj<rh then rm=rh-(c6+rj)rn=cp.computeTravelTime(a1,0,rm)else local ro=(rh-c6)/rj;rj=rh-c6;rk=rk*ro end;if fW~=nil and fW.planetname==kv.name and not b4 then return rn elseif be then return rl elseif bf then return rn+rl else return rk+c7+rn end end;local function rp(o9,rq)if o9==nil then o9=b.getGravityIntensity()end;o9=fL(o9,5)if rq~=nil and rq or(pU==nil or pU~=o9)then local kg=cJ:len()local rr=bP.getMaxBrake()if rr~=nil and rr>0 and cg then rr=rr/dl(kg/100,0.1,1)if ch>0.10 then bv=rr end end;if rr~=nil and rr>0 then bt=rr end;pU=o9 end end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()ql=0;for M=1,#d3 do ql=ql+bP.getDockedConstructMass(d3[M])end;local rs=0;for M=1,#d2 do rs=rs+bP.getBoardedPlayerMass(d2[M])end;if rs>20000 then ql=ql+rs-20000 end;cV,cW=qm()df=bP.getMaxSpeed()if bk~="None"and(c8 or fW)then lo=rg()end;rp(nil,true)end;local function rt(ru,rv)local oy=vec3()local rw=vec3()if ru==axisCommandId.longitudinal then oy=vec3(bP.getOrientationForward())rw=cH elseif ru==axisCommandId.vertical then oy=vec3(bP.getOrientationUp())rw=q3 elseif ru==axisCommandId.lateral then oy=vec3(bP.getOrientationRight())rw=cI else return vec3()end;local rx=vec3(b.getWorldGravity())local ry=rx:dot(rw)local rz=vec3(bP.getWorldAirFrictionAcceleration())local rA=rz:dot(rw)local rB=cJ:dot(oy)local rC=rv*constants.kph2m;if rD==nil then rD=pid.new(10,0,10.0)end;rD:inject(rC-rB)local rE=rD:get()local rF=(rE-rA-ry)*rw;return rF end;local function rG(ru,rv)local oy=vec3()local rw=vec3()if ru==axisCommandId.longitudinal then oy=vec3(bP.getOrientationForward())rw=cH elseif ru==axisCommandId.vertical then oy=vec3(bP.getOrientationUp())rw=q3 elseif ru==axisCommandId.lateral then oy=vec3(bP.getOrientationRight())rw=cI else return vec3()end;local rx=vec3(b.getWorldGravity())local ry=rx:dot(rw)local rz=vec3(bP.getWorldAirFrictionAcceleration())local rA=rz:dot(rw)local rB=cJ:dot(oy)local rC=rv*constants.kph2m;if rH==nil then rH=pid.new(10,0,10.0)end;rH:inject(rC-rB)local rE=rH:get()local rF=(rE-rA-ry)*rw;return rF end;local function rI(rJ,jV,fS)local rK=rJ:cross(fS):normalize_inplace()local kI=math.acos(dl(rK:dot(-jV),-1,1))*constants.rad2deg;if rK:cross(-jV):dot(fS)<0 then kI=-kI end;return kI end;local function rL()if c_ and not b7 then local es=c_[1]local hV,hW=c_[2],c_[3]local rM=math.min(hV,hW or hV)local rN=rM/cL;local rO=b8 and(cL<42 or cf~=-1)local rP=b6 or br or bu or b4;if rP and not rO and(c6*1.5>rM or rN<1)then b1="Collision"bG={}q6=0;if b6 then ct.ToggleAltitudeHold()end;if bu then ct.ToggleLockPitch()end;di("Autopilot Cancelled due to possible collision")a.print(es.name.." COLLISION "..iD(rN).." / "..iC(rM,2))ct.ResetAutopilots(1)qU=true;if cg then b7=true end;cz=true end;if rN<11 then cZ=es.name.." COLLISION "..iD(rN).." / "..iC(rM,2)else cZ=es.name.." collision "..iD(rN)end;if rN<6 then fK("alarm","AL",2)end else cZ=false end end;local rQ=1;local rR=0;local rS=1;local rT=1;local rU=1;local rV=false;function pF.onFlush()if antigrav and not r and not cQ and antigrav.getBaseAltitude()~=bw then qg=bw end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iy:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local rW=dl(bX+pY+a.getControlDeviceForwardInput(),-1,1)local rX=dl(bY+p_+a.getControlDeviceYawInput(),-1,1)local rY=dl(bZ+pZ-a.getControlDeviceLeftRightInput(),-1,1)local rZ=b1 and 1 or 0;cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(kv.center-cO):normalize()end;q3=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()+ql;cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local r_=cT/180*math.pi;local s0=math.cos(r_)local s1=math.sin(r_)cS=rI(cM,cH,cI*s0+q3*s1)local s2=cK:normalize()local s3=eZ(cT)local s4=utils.sign(cT)local s5=vec3(bP.getWorldAngularVelocity())local s6=rW*aP*cI+rX*aK*cH+rY*aQ*q3;if cz==true and cM:len()>0.01 then local s7=eZ(q0-cT)if((b3 or b9 or b7 or cc or b6 or bA)and s7>0 or cg and s7<aL and q)and rX==0 and eZ(cS)<85 then local s8=q0;local s9=aJ;if not cg then s9=s9/4;q0=0;s8=0 end;if sa==nil then sa=pid.new(s9*0.01,0,s9*0.1)end;sa:inject(s8-cT)local sb=sa:get()s6=s6+sb*cH end end;bS=0;ch=bO()cg=false or ci<kv.noAtmosphericDensityAltitude and ch>0.00001;ci=b.getAltitude()cf=qx()bQ=bM()pK=bQ;if bn and cf>-1 and cf-3<_ then if iy.targetGroundAltitudeActivated then iy:deactivateGroundEngineAltitudeStabilization()end end;if cu then qj=not qj;if qj then cu.UpdateRadar()end;if E then rL()end end;if antigrav then cQ=antigrav.isActive()==1 end;local sc=bQ-pK;local sd=-math.deg(qr(q3,cK,cH))local se=math.deg(qr(cI,cK,cH))local gh=cM*-1;cA=cg and sd<-N or sd>N or se<-O or se>O;local sf=a.getMouseDeltaX()local sg=a.getMouseDeltaY()if qk then local sh=bM()-qk;sf=sf*sh/0.016;sg=sg*sh/0.016 end;qk=bM()if p and not c1 then sg=-sg end;pZ=0;p_=0;pY=0;local si=bP.getWorldPosition()kv=fO:closestBody(si)sj=cq(kv)fk=sj:orbitalParameters(si,cK)if ci==0 then ci=(cO-kv.center):len()-kv.radius end;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local o9=kv:getGravity(si):len()*cj;q0=0;local sk=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if qa==0 then if ix()==1 and c1 then if not cx then c9=dl(c9+sf/2,-ad/2,ad/2)ca=dl(ca+sg/2,-ae/2,ae/2)end else c9=0;ca=0 end else c9=dl(c9+sf/2,-ad/2,ad/2)ca=dl(ca+sg/2,-ae/2,ae/2)dd=dn(c9*c9+ca*ca)if not c1 and ix()==0 then local kR,kS=1,1;if bK=="SCOPE"then kR,kS=d5/90,d5/90 end;if g=="virtual joystick"then if dd>aA then pZ=pZ-dl(eZ(c9)-aA,0,ad/2)*utils.sign(c9)*aH*kR;pY=pY-dl(eZ(ca)-aA,0,ae/2)*utils.sign(ca)*aI*kS end else c9=0;ca=0;if g=="mouse"then pY=(-utils.smoothstep(sg,-100,100)+0.5)*2*rT;pZ=(-utils.smoothstep(sf,-100,100)+0.5)*2*rU end end end end;local sl=cL>27777;if cL>X/3.6 and not cg and not b4 and not sl then di("Space Speed Engine Shutoff reached")q6=0 end;if not sl and sm then if not b1 then ct.BrakeToggle()end;if b4 then ct.ResetAutopilots(1)end;q6=0 end;sm=sl;if ch>0.09 then if cL>cB/3.6 and not t and not pG then b1="SpdLmt"pG=true elseif not t and pG then if cL<cB/3.6 then b1=false;pG=false end end end;if b3 then if cc then b1=false;local sn=false;sn=qJ(fW.position-cO,0.1)cz=true;if sn then q7=bN(cB)if(eZ(cT)<2 or eZ(cS)>85)and cL>=cB/3.6-1 then b1=false;b3=false;if cc~=2 then pX=true end;if cc==true then ce=true end;cc=false;b4=false;ct.BeginReentry()end elseif cg and t then q6=1 end elseif cL>iR then qJ(vec3(cK),0.01)end end;if b2 then if cg then b2=false elseif cL>iR then qJ(-vec3(cK))end end;if not b3 and cc and not bA then if not cg then if cc~=2 then pX=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not qh then qh=true end end end;if ce and fW and(ci<bb+250 and ci>bb-250)and eZ(cN)<25 and ch>=0.1 and(fW.position-cO):len()>2000+ci then if not qh then qh=true end;ce=false end;if ba then cz=true;local so=bb;if cN<-30 then di("Unable to achieve lift. Safety Landing.")b_=0;cz=q;ba=false;b7=true elseif not r and cQ or bb<kv.spaceEngineMinAltitude then if cQ then so=antigrav.getBaseAltitude()end;if ci<so-100 then q1=0;b_=15;b1=false elseif cN>0 then b1="VTO Limit"b_=0 elseif cN<-30 then b1="VTO Fall"b_=15 elseif ci>=so then if cQ then if b4 or br then ct.ToggleVerticalTakeoff()else b1="VTO Complete"ba=false end;di("Takeoff complete. Singularity engaged")fK("aggLk","AG")else b1=false;di("VTO complete. Engaging Horizontal Flight")fK("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then q1=0;b1=false;b_=20 elseif ch<0.08 and cg then b1=false;if cF then q1=0;b_=20 else b_=0;q1=36;q7=3500 end else cz=q;bA=true;cE=false;sp=false;pP=false;pN=nil;pO=nil;if pS==nil then pS=kv end;cD=so;pR=true;ba=false end end;if q1~=nil then if sq==nil then sq=pid.new(2*0.01,0,2*0.1)end;local sr=dl(q1-cS,-O*0.80,O*0.80)sq:inject(sr)local ss=dl(sq:get(),-1,1)pY=ss end end;if bA then local function st()if fk.periapsis.altitude>=cD*0.99 and fk.apoapsis.altitude>=cD*0.99 and fk.periapsis.altitude<fk.apoapsis.altitude and fk.periapsis.altitude*1.05>=fk.apoapsis.altitude and eZ(cD-ci)<1000 then return true else return false end end;local qQ;local su=false;local sv=iC(cD,3)if pS==nil then pS=kv;if br then pS=c8 end end;if not pR then cD=bN(pS.radius+pS.surfaceMaxAltitude+V)if pS.hasAtmosphere then cD=bN(pS.radius+pS.noAtmosphericDensityAltitude+V)end;pR=true end;if q2.VectorToTarget and fW then qQ=fW.position-cO end;local sw,sx=cq(pS):escapeAndOrbitalSpeed((cO-pS.center):len()-pS.radius)local sy=cT;if not pP then local sz=false;local sA=false;q6=0;pO=0;cC="Aligning to orbital path - OrbitHeight: "..sv;if q2.VectorToTarget then qJ(qQ:normalize():project_on_plane(cM))su=cH:dot(qQ:project_on_plane(q3):normalize())>0.95 else qJ(cK)su=sd<0.5;if cL<150 then su=true end end;pY=0;pN=0;if cS<=pN+2 and cS>=pN-2 then sz=true else sz=false end;if sy<=pO+2 and sy>=pO-2 then sA=true else sA=false end;if sz and sA and su then pN=nil;pO=nil;pP=true end else if q2.VectorToTarget then qJ(qQ:normalize():project_on_plane(cM))elseif cL>150 then qJ(cK)end;pY=0;if q2.VectorToTarget and fW then local c6,dQ=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bt)if cE and qQ:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pS.noAtmosphericDensityAltitude or lo>fk.timeToPeriapsis and fk.periapsis.altitude<pS.noAtmosphericDensityAltitude or not st()and fk.eccentricity>0.1 then di("Re-Aligning Orbit")cE=false end elseif cE or qQ:len()<15000+c6+ci then di("Orbit complete, proceeding with reentry")fK("orCom","OB")bl=fW.position;pX=true;ce=true;q2.VectorToTarget,q2.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if fk.periapsis~=nil and fk.apoapsis~=nil and fk.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if fk.apoapsis~=nil then if(st()or cE)and not K then if cE then b1=false;q6=0;pN=0;if not q2.VectorToTarget then di("Orbit complete")fK("orCom","OB")ct.ToggleIntoOrbit()end else pT=pT+1;if pT>=2 then cE=true end end else if st()then cC="Maintaining "else cC="Adjusting "pQ=true;q7=sx*3.6+1;local sB=cD-ci;if sC==nil then sC=pid.new(0.1,0,1*0.1)end;sC:inject(sB-cN*dl(utils.smoothstep(2000-sB,-2000,2000)^6*10,1,10))pN=dl(sC:get(),-60,60)end;cC=cC.." - OrbitHeight: "..sv end end else local sD=2.75;local sE=eZ(fL(sw*sD))local om=sE%50;if om>0 then sE=sE-om+50 end;b1=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sv;pN=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sv;sE=sE*0.75;pN=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sv;sE=sE*0.75;if cN<0 or pQ then pN=utils.map(ci,cD*1.5,cD*1.01,-30,0)else pN=utils.map(ci,cD*0.99,cD*1.5,0,30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sv;pN=-65;local sF=utils.map(cN,-150,-400,1,0.55)sE=sE*sF end;q7=bN(sE)end end;if pN~=nil then if sG==nil then sG=pid.new(1*0.01,0,5*0.1)end;local sH=pN-cS;sG:inject(sH)local sI=dl(sG:get(),-0.5,0.5)pY=sI end end;if b4 and not cg and not cc then local function sJ(sK,fk)a.print(sK)b3=false;b1=false;be=false;b4=false;r1=false;bh="Aligning"q6=0;pW=false;di(sK)fK("apCom","AP")if fk or cc then if fk and gf~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pR=true end;ct.ToggleIntoOrbit()end end;local sL,sM=bl,false;if fW and fW.planetname~="Space"then bd=true;if not r1 then local sN=(fW.position-c8.center):normalize()local sO=sN:project_on_plane((c8.center-cO):normalize()):normalize()local sP=c8.center+sO*(c8.radius+gf)local sQ=fW.position+(fW.position-c8.center):normalize()*(gf-c8:getAltitude(fW.position))if(cO-sP):len()<(cO-sQ):len()then sL=sP else sL=sQ;bg=0 end;bl=sL;ct.showWayPoint(c8,bl)sM=true;r1=true end;bi=0 elseif fW and fW.planetname=="Space"then if not r1 then bi=0;sM=true;bd=true;r1=true;sL=fW.position+(cO-fW.position):normalize()*T;bl=sL end elseif fW==nil then bi=0;if not r1 then local sN=(cO+cK*100000-c8.center):normalize()local sO=sN:project_on_plane((c8.center-cO):normalize()):normalize()if sO:len()<1 then sN=(cO+cH*100000-c8.center):normalize()sO=sN:project_on_plane((c8.center-cO):normalize()):normalize()end;sL=c8.center+sO*(c8.radius+gf)bl=sL;r1=true;sM=true;bd=true;ct.showWayPoint(c8,bl)end end;rh=(vec3(sL)-cO):len()local lm,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local ln=eJ;if eK~=nil and eJ~=nil then ln=math.min(eK,eJ)end;if ln~=nil and ln<rh and lm.name==c8.name then rh=ln end;local sn=true;local sR=(c8.center-(cO+vec3(cK):normalize()*rh)):len()-c8.radius;local lj=iC(sR)qe=g7;qf='{"label": "Projected Altitude", "value": "'..lj..'"}'if cL>50 and bc then local qQ=vec3(sL)-cO;local sS=dl(math.deg(qr(q3,cK:normalize(),qQ:normalize()))*cL/500,-90,90)local sT=dl(math.deg(qr(cI,cK:normalize(),qQ:normalize()))*cL/500,-90,90)if eZ(sS)<20 and eZ(sT)<20 then sS=sS*2;sT=sT*2 end;if eZ(sS)<2 and eZ(sT)<2 then sS=sS*2;sT=sT*2 end;local sd=-math.deg(qr(q3,cH,cK:normalize()))local se=-math.deg(qr(cI,cH,cK:normalize()))if sU==nil then sU=pid.new(2*0.01,0,2*0.1)end;sU:inject(sT-se)local sV=dl(sU:get(),-1,1)pY=pY+sV;if sW==nil then sW=pid.new(2*0.01,0,2*0.1)end;sW:inject(sS-sd)local sX=dl(sW:get(),-1,1)pZ=pZ+sX;sM=true;if eZ(sS)>2 or eZ(sT)>2 then if bh~="Adjusting Trajectory"then bh="Adjusting Trajectory"fK("apAdj","AP")end else if bh~="Accelerating"then bh="Accelerating"fK("apAcc","AP")end end elseif bc and cL<=50 then qJ((sL-cO):normalize())end;if sR<gf*1.5 then bg=cB/3.6;if fW==nil then dQ,bg=cq(c8):escapeAndOrbitalSpeed(sR)end end;local c6,c7;if not b5 then c6,c7=qn(cL)else c6,c7=qq(cL)end;if b4 and not bc and not bf and not be then local lm,ln=ct.checkLOS((bl-cO):normalize())if c8.name~=kv.name then if lm~=nil and c8.name~=lm.name and ln<rh then cZ="Attempting to clear LOS between "..lm.name.." and waypoint."qb=true else qb=false;cZ=false end end end;if not qb then if not bf and not be and not sM then sn=qJ((sL-cO):normalize())elseif b5 and(be or bf)then sn=qJ(-vec3(cK):normalize())end end;if bc then if not pW then b1=false;q6=a2;bR=fL(a2,2)pW=true end;local ri=c.getThrottle()if t then ri=bR end;local sY=99999;local ok=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local sZ=dl(cK:dot((sL-cO):normalize()),0,cL)if sZ>0 or ok>0 then sY=cp.computeTravelTime(sZ,ok,rh-c6)end;if a1>df then a1=df-0.2 end;if cJ:len()>=a1 or ri==0 and pW or a3/4>sY then bc=false;if bh~="Cruising"then fK("apCru","AP")bh="Cruising"end;bf=true;q6=0 end;local s_=rh;if s_<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pH and cW>2000 then ct.ResetAutopilots(1)di("Autopilot cancelled to prevent crossing PvP Line")b1="PvP Prevent"pH=cW else pH=cW;return end end;bc=false;if bh~="Braking"then fK("apBrk","AP")bh="Braking"end;be=true;if not b5 then b3=true;cz=true end;q6=0;pW=false end elseif be then if bh~="Orbiting to Target"then b1="AP Brk"end;if b5 then q6=1;q8=true end;local dQ,sx=cq(c8):escapeAndOrbitalSpeed((cO-kv.center):len()-kv.radius)local qQ;if fW then qQ=fW.position-cO end;if fW and fW.planetname=="Space"and cL<50 then if#bG>0 then if not qh then table.remove(bG,1)end;if#bG>0 then b1=false;if not qh then qh=2 end;return end end;sJ("Autopilot complete, arrived at space location")b1="Space Arrival"elseif fW and fW.planetname~="Space"and cL<=sx and(fk.apoapsis==nil or fk.periapsis==nil or fk.apoapsis.altitude<=0 or fk.periapsis.altitude<=0)then sJ("Autopilot complete, commencing reentry")bl=fW.position;cc=true;ct.showWayPoint(c8,bl)elseif(fW and fW.planetname~="Space"or fW==nil)and fk.periapsis~=nil and fk.periapsis.altitude>0 and fk.eccentricity<1 or bh=="Circularizing"then if bh~="Circularizing"then fK("apCir","AP")bh="Circularizing"end;if cL<=sx then if fW then if cK:normalize():dot(qQ:normalize())>0.4 then if bh~="Orbiting to Target"then fK("apOrb","OB")bh="Orbiting to Target"end;if not r3 then b1=false;ct.showWayPoint(c8,fW.position)r3=true end else sJ("Autopilot complete, proceeding with reentry")bl=fW.position;cc=true;ct.showWayPoint(c8,fW.position)r3=false end else sJ("Autopilot completed, setting orbit",true)b1=false end end elseif bh=="Circularizing"then sJ("Autopilot complete, fixing Orbit",true)end elseif bf then local s_=rh;if s_<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pH and cW>2000 then if not qh then qh=true end;di("Autopilot cancelled to prevent crossing PvP Line")b1="Prevent PvP"pH=cW else pH=cW;return end end;bc=false;if bh~="Braking"then fK("apBrk","AP")bh="Braking"end;be=true;if not b5 then b3=true;cz=true end end;local ri=c.getThrottle()if t then ri=bR end;if ri>0 then bc=true;if bh~="Accelerating"then bh="Accelerating"fK("apAcc","AP")end;bf=false end else if sn then if not bd and fW==nil or not bd and fW and fW.planetname~="Space"then if not cc then bl=vec3(c8.center)+(gf+c8.radius)*cI;t0=q3;t1=cI end;bd=true elseif sn and not qb then bc=true;if bh~="Accelerating"then bh="Accelerating"fK("apAcc","AP")end;if not pW then q6=a2;q8=true;bR=fL(a2,2)pW=true;b1=false end end end end elseif b4 and(fW~=nil and fW.planetname~="Space"and cg)then di("Autopilot complete, starting reentry")fK("apCom","AP")bl=fW.position;b1=false;be=false;b4=false;r1=false;bh="Aligning"q6=0;pW=false;b3=true;cc=true;ct.showWayPoint(c8,fW.position)end;if c0 then cz=true;local sT=0;local fm=vec3(DUPlayer.getWorldPosition())local t2=fm-cO;local t3=vec3(t2):project_on(cH):len()local t4=vec3(t2):project_on(cI):len()local cb=dn(t3*t3+t4*t4)qJ(t2:normalize())local mv=40;local t5=cb<mv;local t6=100;local rv=dl((cb-mv)/2,10,t6)pY=0;local sn=eZ(pZ)<0.1;if sn and cL<rv and not t5 then b1=false;sT=-20 else b1="Follow"sT=0 end;local t7=0;if eZ(sT-cS)>t7 then if t8==nil then t8=pid.new(2*0.01,0,2*0.1)end;t8:inject(sT-cS)local sV=t8:get()pY=sV end end;if b6 or b7 or b9 or br or bu~=nil then if bI then if cf==-1 then bb=bb-0.2 else bb=ci+bI-cf end end;local t9=bv;if t9 then t9=t9*dl(cL/100,0.1,1)*ch else t9=bt end;if not cg then t9=bt end;q5=cH:project_on_plane(cM):normalize():dot(cK)if q5>100 then c6,c7=cp.computeDistanceAndTime(q5,100,cj,0,0,t9)local ta,tb=cp.computeDistanceAndTime(100,0,cj,0,0,t9*0.55)c6=c6+ta else c6,c7=cp.computeDistanceAndTime(q5,0,cj,0,0,t9*0.55)end;local sB=bb-ci-cN;local tc=200+cL;if b9 or cc then td=2000+cL end;local te=1;if b8 then te=dl(cL/100,0.1,1)end;local sT=(utils.smoothstep(sB,-tc,tc)-0.5)*2*Q*te;if not b9 and not cc and not br and cH:dot(cK:normalize())<0.99 then sT=(utils.smoothstep(sB,-tc*dl(20-19*ch*10,1,20),tc*dl(20-19*ch*10,1,20))-0.5)*2*Q*dl(2-ch*10,1,2)*te end;if not b6 then sT=0 end;if bu~=nil then if cY and not bA then sT=bu else bu=nil end end;cz=true;local tf=pY;if b9 then local tg=bN(cB)local th,ti=cp.computeDistanceAndTime(cL,tg/3.6,cj,0,0,bt-kv.gravity*9.8*cj)th=th==-1 and 5000 or th;local r2=ci-(kv.noAtmosphericDensityAltitude+th)local tj=ci>kv.noAtmosphericDensityAltitude+th*1.35;if tj then sT=R;if cL<=tg/3.6 and cL>tg/3.6-10 and eZ(cK:normalize():dot(cH))>0.9 and not cR then bV=false;q6=1 end elseif(cR or iy:getTargetSpeed(axisCommandId.longitudinal)~=tg)and not tj and not cg then q7=tg;q8=true end;if cR then if cL>tg/3.6 and not tj then b1="Reentry Limit"if bR>0 then q6=0 end else b1=false end else b1=false end;if cN>0 then b1="Reentry vSpd"end;if not pX then sT=-80;if ci<kv.surfaceMaxAltitude+(kv.atmosphereThickness-kv.surfaceMaxAltitude)*0.25 then di("PARACHUTE DEPLOYED at "..fL(ci,0))b9=false;b7=true;qU=true;q6=0;sT=0;cz=q end elseif kv.noAtmosphericDensityAltitude>0 and tj then cz=true elseif not tj then if not cg and(cR or iy:getTargetSpeed(axisCommandId.longitudinal)~=tg)then q7=tg end;if cL<tg/3.6+1 then b1=false;pX=false;b9=false;cz=true;q6=1 end end end;if cL>iR and not cd and not br and not b7 and u then qJ(vec3(cK))end;if cX or(br or cd)and bm>0 and cg then local qQ;if cX then if type(cX)=="table"then qQ=cX elseif cX<3 and cX>0 then qQ=-cM:cross(cK)*5000 elseif cX>=3 then qQ=cM:cross(cK)*5000 elseif cX<0 then qQ=cK*25000 end elseif fW~=nil then qQ=fW.position-cO else qQ=c8.center-cO end;local sS=math.deg(qr(cM:normalize(),cK,qQ))*2;local my=math.rad(eZ(cT))if cL>aM and cg then local tk=1000+cL;local tl=(utils.smoothstep(sB-cN*10,-tk,tk)-0.5)*2*Q;local tm=dl(90-tl,0,180)q0=dl(sS*2,-tm,tm)local tn=sS;sS=dl(dl(sS,-N*0.80,N*0.80)*math.cos(my)+4*(cS-sT)*math.sin(math.rad(cT)),-N*0.80,N*0.80)local to=1;if q0~=0 then to=eZ(my/q0)end;to=(90-dl(eZ(q0-cT),0,90))/90;local tp=sT;if eZ(cT)>90 then tp=-tp end;sT=to*dl(dl(tp*math.cos(my),-O*0.8,O*0.8)+eZ(dl(eZ(tn)*math.sin(my),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q0=0;sS=dl(sS,-N*0.80,N*0.80)end;local tq=sd-sS;if cX and eZ(tq)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and eZ(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fK("180Off","BR")return end;if not cA and cL>aM and cg then if tr==nil then tr=pid.new(2*0.01,0,2*0.1)end;tr:inject(tq)local sX=dl(tr:get(),-1,1)pZ=pZ+sX elseif cg and cf>-1 or cL<aM then qJ(qQ)elseif cA and cg then if(sd<-N or sd>N)and cg then qJ(cK)end;if(se<-O or se>O)and cg then sT=dl(cS-se,cS-O*0.80,cS+O*0.80)end end;if fW~=nil and not cd then local so=kv:getAltitude(fW.position)local r2=qQ:project_on_plane(cM):len()qU=true;if bb<kv.noAtmosphericDensityAltitude and not cd and not b8 and not b9 and(r2<=c6 and qQ:len()<kv.radius)and(cK:project_on_plane(cM):normalize():dot(qQ:project_on_plane(cM):normalize())>0.99 or lq=="Finalizing Approach")then lq="Finalizing Approach"if#bG>0 then if not qh then table.remove(bG,1)end;if#bG>0 then if not qh then qh=2 end;return end end;q6=0;if b6 then ct.ToggleAltitudeHold()br=true end;b1="AP Finalizing"elseif not b8 then b1=false end;if lq=="Finalizing Approach"and(q5<0.1 or r2<0.1 or ts~=nil and ts<r2)then fK("bklOn","BL")b7=true;db=true;if fW.heading then dc=fW.heading else dc=nil end;br=false;lq="Proceeding to Waypoint"cZ=false end;ts=r2 end elseif br and not cg and bb>kv.noAtmosphericDensityAltitude and not(cd or b9)then if fW~=nil and c8.name==kv.name then local qQ=fW.position-cO;local so=kv:getAltitude(fW.position)local r2=dn(qQ:len()^2-(ci-so)^2)local t9=bv;if t9 then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,t9/2)qU=true;if r2<=c6+cL*sc/2 and cK:project_on_plane(cM):normalize():dot(qQ:project_on_plane(cM):normalize())>0.99 then if kv.hasAtmosphere then b1=false;b3=false;pX=true;cc=false;ce=true;b4=false;ct.BeginReentry()end end;ts=r2 end end end;if not cg and cf==-1 and(b6 and bb>kv.noAtmosphericDensityAltitude)and not(cd or bA or b9)then if not cE and not bA then cD=bb;pR=true;if br then q2.VectorToTarget=true end;ct.ToggleIntoOrbit()br=false;pP=true end end;if cA and cg and cf==-1 and cL>aM and lq~="Finalizing Approach"then qJ(cK)sT=dl(cS-se,cS-O*0.80,cS+O*0.80)end;pY=tf;local qC=-1;if b7 then if not qc then rV=false;if not cR then q6=0 end;if cf==-1 then iy:setTargetGroundAltitude(500)iy:activateGroundEngineAltitudeStabilization(500)end;bC=true;if not cg then rV=true end;qc=true end;sT=0;local tt=false;local tu=math.abs(q5)if not r and cQ then tt=antigrav.getBaseAltitude()if tt<kv.surfaceMaxAltitude and fW==nil or fW~=nil and kv:getAltitude(fW.position)>tt then tt=false end else tt=false end;if dc then if tu<0.05 then if cN>-P then b1=false else b1="BL Align BLR"end;if qJ(dc,0.001)then dc=nil;cz=q else pY=0;cz=true end else b1="BL Align Hzn"end;if tt and eZ(ci-tt)<250 then b1="AGG Align"end else local tv=false;local tw=30;if tu<10 and sk~=nil and sk>0 then local tx=dl(ch,0.4,2)local t9=bv*dl(cL/100,0.1,1)*tx;local ty=sk*tx+t9-o9;local tz=t9/2-o9;local tA=cL-dn(eZ(tz/2)*20/(0.5*cj))*utils.sign(tz)if tA<0 then tA=0 end;local tB;if cL>100 then local tC,dQ=cp.computeDistanceAndTime(cL,100,cj,0,0,t9)local tD,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,dn(t9))tB=tC+tD else tB=cp.computeDistanceAndTime(cL,0,cj,0,0,dn(t9))end;if tB<20 then b1=false else local tE=0;if tA>100 then local tF,dQ=cp.computeDistanceAndTime(tA,100,cj,0,0,ty)local tG,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,sk*tx+dn(t9)-o9)tE=tF+tG else tE,dQ=cp.computeDistanceAndTime(tA,0,cj,0,0,sk*tx+dn(t9)-o9)end;tE=(tE+15+cL*sc)*1.1;local tH=db and fW~=nil and kv:getAltitude(fW.position)>0 and fW.safe;local so=nil;if tt and tt<ci then so=tt elseif tH then so=kv:getAltitude(fW.position)+250 elseif ci>kv.surfaceMaxAltitude then so=kv.surfaceMaxAltitude end;if c_ then local tI=kv:getAltitude(c_[1].center)if so then if tI>so then so=tI end else so=tI end end;if so~=nil then local tJ=ci-so;tv=true;if tJ<=tE or tE==-1 or tu>0.05 and db then if so==kv.surfaceMaxAltitude and cN<-P then b1="BL Stop BLR"elseif tu>0.05 and db then b1="BL AP Hzn"else b1="BL Stop Dist"end else b1=false end end end end;qC=cf;if qC>-1 then b1=false;if not tt and not bn then q9=true;iy:setTargetGroundAltitude(_)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qC-3<_ then b7=false;b6=false;b_=0;qV(0,1)b1="BL Complete"cz=q;db=false;qc=false else if cN<-5 or tu>0.5 then qV(0,1)b1="BL Slowing"else b1=false;qV(-1)end end elseif not tv then if qU and cK:normalize():dot(-gh)<0.999 then b1="BL Strong"qJ()elseif tu>10 or tu>0.05 and db then b1="BL hSpd"elseif cN<-P then b1="BL BLR"qV(0,1)else qV(-1)b1=false end end end else qc=false end;if b8 or cd then local lm,eK,eJ;if bl~=nil then lm,eK,eJ=co:getPlanetarySystem(0):castIntersections(cO,(bl-cO):normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)end;if lm~=nil then if lm.name~=c8.name and not cg then cZ="Clearing LOS between "..lm.name.." and waypoint."end end;if cQ and not cd then if ci>=bb-50 and cL>iR then b8=false;if not b4 and not br then b1="ATO Agg Arrive"q6=0 end end elseif eZ(sT)<15 and ci/bb>0.75 then b8=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<iR then b4=true;cd=false;b6=false;b8=false;q6=0 elseif cd then q6=0;b1="ATO Space"end elseif cd and not cg and c8~=nil and(lm==nil or lm.name==c8.name)then b4=true;cd=false;b6=false;b8=false;if not cR then q6=0 end;bc=true end end;local tK=cf>-1;local tL=cS;if(br or cd or cX)and not tK and cL>aM and cg then local my=math.rad(eZ(cT))tL=cS*eZ(math.cos(my))+se*math.sin(my)end;local tM=dl(sT-tL,-O*0.80,O*0.80)if not cg and br then tM=dl(sT-tL,-85,Q)elseif not cg then tM=dl(sT-tL,-Q,Q)end;if eZ(cT)<5 or br or cX or b7 or tK or b6 then if t8==nil then t8=pid.new(5*0.01,0,5*0.1)end;t8:inject(tM)local sV=t8:get()pY=pY+sV end end;if antigrav~=nil and(antigrav and not r and ci<200000)then if bw==nil or bw<1000 then bw=1000 end;if tN~=bw then tN=bw;qg=tN end end;if(cg or b9 or ce)and t and cR then if tO==nil then tO=pid.new(0.1,0,1)end;local tP=0;if aV>0 and not b9 and ch>0.005 and ch<0.1 and cN>-10 then local tQ=bP.getFrictionBurnSpeed()*aV;local tR=cB/3.6;if tQ>tR then tP=tQ-tR-1 end end;tO:inject(cB/3.6+tP-cK:dot(cH))local tS=tO:get()bU=dl(tS,-1,1)if not d7 then if bU<bR and(ch>0.005 or b9 or ce)then bT=true;d7=dl(bU,0.01,1)else bT=false;d7=bR end end;if tT==nil then tT=pid.new(1*0.01,0,1*0.1)end;tT:inject(cK:len()-cB/3.6-tP)local tU=dl(tT:get(),0,1)if cg and cN<-80 or(ch>0.005 or b9 or ce)then bS=tU end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dl(bU,0.01,1)end;local tV=''local tW=vec3()local tX=rt(axisCommandId.vertical,b_*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tX,rR)local tY='thrust analog longitudinal 'if bD=="All"or bD=="Longitude"then tY=tY..aW end;local tZ=iy:getAxisCommandType(axisCommandId.longitudinal)local t_=iy:composeAxisAccelerationFromThrottle(tY,axisCommandId.longitudinal)local u0=rG(axisCommandId.lateral,bz*1000)tV=tV..' , '.."lateral airfoil , lateral ground "tW=tW+u0;if tW:len()>constants.epsilon then d:setEngineForceCommand(tV,tW,rR,'','','',rS)end;d:setEngineForceCommand(tY,t_,rQ)local u1='thrust analog vertical fueled 'local u2='thrust analog lateral fueled 'if bD=="All"or bD=="Lateral"then u2=u2 ..aX end;if bD=="All"or bD=="Vertical"then u1=u1 ..aY end;if b_~=0 or b7 and b1 or not bn and not bC then d:setEngineForceCommand(u1,tX,rQ)else d:setEngineForceCommand(u1,vec3(),rQ)end;if bz~=0 then d:setEngineForceCommand(u2,u0,rQ)else d:setEngineForceCommand(u2,vec3(),rQ)end;if rZ==0 then rZ=bS end;local u3=-rZ*(aR*cK+aS*s2)d:setEngineForceCommand('brake',u3)else if t then if not d7 then d7=bR end end;local rv=c.getAxisCommandValue(0)if not cR then if tT==nil then tT=pid.new(1*0.01,0,1*0.1)end;tT:inject(cK:len()-rv/3.6)local tU=dl(tT:get(),0,1)rZ=dl(rZ+tU,0,1)end;local u3=-rZ*(aR*cK+aS*s2)d:setEngineForceCommand('brake',u3)local tV=''local tW=vec3()local u4=false;local tY='thrust analog longitudinal 'if aW~="none"and(bD=="All"or bD=="Longitude")then tY=tY..aW end;local tZ=iy:getAxisCommandType(axisCommandId.longitudinal)if tZ==axisCommandType.byThrottle then local t_=iy:composeAxisAccelerationFromThrottle(tY,axisCommandId.longitudinal)d:setEngineForceCommand(tY,t_,rQ)elseif tZ==axisCommandType.byTargetSpeed then local t_=iy:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tV=tV..' , '..tY;tW=tW+t_;if iy:getTargetSpeed(axisCommandId.longitudinal)==0 or iy:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iy:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u4=true end end;local u2='thrust analog lateral 'if aX~="none"and(bD=="All"or bD=="Lateral")then u2=u2 ..aX end;local u5=iy:getAxisCommandType(axisCommandId.lateral)if u5==axisCommandType.byThrottle then local u6=iy:composeAxisAccelerationFromThrottle(u2,axisCommandId.lateral)d:setEngineForceCommand(u2,u6,rQ)elseif u5==axisCommandType.byTargetSpeed then local u0=iy:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tV=tV..' , '..u2;tW=tW+u0 end;local u1='thrust analog vertical 'if aY~="none"and(bD=="All"or bD=="Vertical")then u1=u1 ..aY end;local u7=iy:getAxisCommandType(axisCommandId.vertical)if u7==axisCommandType.byThrottle then local tX=iy:composeAxisAccelerationFromThrottle(u1,axisCommandId.vertical)if b_~=0 or b7 and b1 then d:setEngineForceCommand(u1,tX,rQ,'airfoil','ground','',rS)else d:setEngineForceCommand(u1,vec3(),rQ)d:setEngineForceCommand('airfoil vertical',tX,rQ,'airfoil','','',rS)d:setEngineForceCommand('ground vertical',tX,rQ,'ground','','',rS)end elseif u7==axisCommandType.byTargetSpeed then if b_<0 then d:setEngineForceCommand('hover',vec3(),rQ)end;local u8=iy:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tV=tV..' , '..u1;tW=tW+u8 end;if tW:len()>constants.epsilon then if rZ~=0 or u4 or eZ(s2:dot(cH))<0.5 then tV=tV..', brake'end;d:setEngineForceCommand(tV,tW,rR,'','','',rS)end end;local u9=aO*(s6-s5)local ua=vec3(bP.getWorldAirFrictionAngularAcceleration())u9=u9-ua;d:setEngineTorqueCommand('torque',u9,rQ,'airfoil','','',rS)d:setBoosterCommand('rocket_engine')if c5 and not o then local kg=cJ:len()local ub=0.15;if not cR then local uc=iy:getTargetSpeed(axisCommandId.longitudinal)if kg*3.6>uc*(1-ub)and ud then ud=false;d:toggleBoosters()elseif kg*3.6<uc*(1-ub)and not ud then ud=true;d:toggleBoosters()end else local ri=c.getThrottle()if t then ri=bR*100 end;local rv=ri/100;if not cg then rv=rv*a1;if kg>=rv*(1-ub)and ud then ud=false;d:toggleBoosters()elseif kg<rv*(1-ub)and not ud then ud=true;d:toggleBoosters()end else local tg=bN(cB)rv=rv*tg/3.6;if kg>=rv*(1-ub)and ud then ud=false;d:toggleBoosters()elseif kg<rv*(1-ub)and not ud then ud=true;d:toggleBoosters()end end end end end;if ue then for dL,dx in pairs(ue)do pF[dL]=dx end end;cf=qx()return pF end;local function uf(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ug,ix,iy,iz,uh,gC,fL,e4,dm,dl,fK,iB,pE,di)local bP=DUConstruct;local ui={}local uj=true;local uk=5;local ul=5;local um=uk;local un=ul;local uo=bQ;function ui.landingGear(q9)bn=not bn;if bn then if b4 or br or cd or bA then ct.ResetAutopilots(true)end;bu=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not q9 and cf==-1 then fK("bklOn","BL")qU=true;b9=false;b8=false;ba=false;if b7 then db=not db end;cz=true;bn=false;b7=true else if bW then fK("grOut","LG",1)d.control.deployLandingGears()end;db=false;if cg then cz=q;b1="Landing"end end;if q9 or cf~=-1 and cf>_-3 then b7=true end;iy:setTargetGroundAltitude(_)b6=false;bI=false elseif bW and not b7 then fK("grOut","LG",1)d.control.deployLandingGears()end else if b7 then b7=false end;if bW then fK("grIn","LG",1)d.control.retractLandingGears()end;iy:activateGroundEngineAltitudeStabilization(qY)if bC then if _<iy.targetGroundAltitude then iy:setTargetGroundAltitude(iy.targetGroundAltitude)else iy:setTargetGroundAltitude(Z)end end end end;function ui.startControl(up)local function uq(rd)local re=1;local function ur(us,rd)local ut={kv.surfaceMaxAltitude+100,kv.spaceEngineMinAltitude-0.01*kv.noAtmosphericDensityAltitude,kv.noAtmosphericDensityAltitude+V,kv.radius*(U-1)+kv.noAtmosphericDensityAltitude}local uu=us;for dQ,dx in ipairs(ut)do if rd and uu>dx then us=dx elseif us<dx and not rd then us=dx;break end end;return us end;if rd then re=-1 end;if not r and cQ then if c1 and rd then bw=1000 elseif bw~=nil then bw=bw+re*ul;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end else bw=tN+re*100 end elseif b6 or ba or bA then if bA then if c1 then cD=ur(cD,rd)else cD=cD+re*uk end;if cD<kv.noAtmosphericDensityAltitude then cD=kv.noAtmosphericDensityAltitude end else if c1 and cg then bb=ur(bb,rd)bI=false else bb=bb+re*uk;if bI then if bb>100 then bI=false else iy:updateTargetGroundAltitudeFromActionStart(re*1.0)bI=d:getTargetGroundAltitude()end end end end else iy:updateTargetGroundAltitudeFromActionStart(re*1.0)end end;local function uv(uw)if not cg then di("Flight Assist in Atmo only")return end;local du=type(uw)if cX==nil then if du=="table"then if b4 or br then ct.ToggleAutopilot()end;fK("180On","BR")elseif uw==1 then fK("bnkLft","BR")else fK("bnkRht","BR")end;if not b6 and not b4 and not br then ct.ToggleAltitudeHold()if du~="table"then uw=uw+1 end end;cX=uw else fK("180Off","BR")cX=nil end end;local function ux()if iz()==1 then c9=0;ca=0;uh(bj)elseif ix()==1 and y then cy=false;cx=false end;c1=false end;if up=="gear"then cv.landingGear()elseif up=="light"then if p4 then if ix()==1 then if DUPlayer.isFrozen()==1 then DUPlayer.freeze(0)di("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(1)di("Player Frozen, pitch/yaw/roll enabled")end else di("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif up=="forward"then if p4 and not cg and not b4 then b3=not b3;b2=false else bX=bX-1 end elseif up=="backward"then if p4 then if not cg then if not b4 then b2=not b2;b3=false else b5=not b5 end else uv(-cK*5000)end else bX=bX+1 end elseif up=="left"then if p4 then uv(1)else bY=bY-1 end elseif up=="right"then if p4 then uv(3)else bY=bY+1 end elseif up=="yawright"then bZ=bZ-1;dc=nil elseif up=="yawleft"then bZ=bZ+1;dc=nil elseif up=="straferight"then iy:updateCommandFromActionStart(axisCommandId.lateral,1.0)bz=1 elseif up=="strafeleft"then iy:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bz=-1 elseif up=="up"then ct.vertical(1)if cf-3<_ and ci>0 and bn then cv.landingGear()end elseif up=="down"then ct.vertical(-1)elseif up=="groundaltitudeup"then uq()elseif up=="groundaltitudedown"then uq(true)elseif up=="option1"then uy=false;if p4 and c1 then local uz=""for M=1,#d2 do uz=uz.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fL(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..uz)return end;cs.adjustAutopilotTargetIndex()elseif up=="option2"then uy=false;if p4 and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;di("Deboarded All Passengers")return end;cs.adjustAutopilotTargetIndex(1)elseif up=="option3"then uy=false;if p4 and c1 then local uz=""for M=1,#d3 do uz=uz.."| ID: "..d3[M].." Mass: "..fL(bP.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..uz)return end;if x then if w then w=false else w=true end;if cu then cu.ToggleRadarPanel()end end elseif up=="option4"then uy=false;if p4 and c1 then for M=1,#d3 do bP.forceUndock(d3[M])end;di("Undocked all ships")return end;cX=nil;ct.ToggleAutopilot()elseif up=="option5"then uy=false;ct.ToggleLockPitch()elseif up=="option6"then uy=false;if p4 and c1 then if shield then cw.ventShield()else di("No shield found")end;return end;ct.ToggleAltitudeHold()elseif up=="option7"then uy=false;if p4 and c1 then if shield then shield.toggle()return else di("No shield found")return end end;E=not E;if E then di("Collision System Enabled")else di("Collision System Secured")end elseif up=="option8"then uy=false;if p4 and c1 then if bm>0 and fW~=nil then ct.routeWP()else di("Select a saved wp on IPH to add to or remove from route")end;return end;bC=not bC;if not bC then di("DeCoupled Mode - Ground Stabilization off")iy:deactivateGroundEngineAltitudeStabilization()fK("gsOff","GS")else di("Coupled Mode - Ground Stabilization on")iy:activateGroundEngineAltitudeStabilization(qY)de=true;fK("gsOn","GS")end elseif up=="option9"then uy=false;if p4 and c1 then iy:resetCommand(axisCommandId.longitudinal)iy:resetCommand(axisCommandId.lateral)iy:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()==1;if ck then fK("gyOn","GA")else fK("gyOff","GA")end else di("No gyro found")end elseif up=="lshift"then if p4 then c1=true end elseif up=="brake"then if a_ or p4 then ct.BrakeToggle("Manual")elseif not b1 then ct.BrakeToggle("Manual")else b1="Manual"end elseif up=="lalt"then uy=true;p4=true;if ix()==0 and not j and g=="keyboard"then uh(1)end elseif up=="booster"then if o then d:toggleBoosters()elseif not c5 then if not ud then d:toggleBoosters()ud=true end;c5=true else if ud then d:toggleBoosters()ud=false end;c5=false end elseif up=="stopengines"then local function uA()if bQ-uo<1.5 then fK("clear","CA")ct.clearAll()end end;uA()uo=bQ;if iy:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p4 then if cB>0 then cB=0 else cB=W end elseif bR~=0 then iy:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iy:getTargetSpeed(axisCommandId.longitudinal)~=0 then iy:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(a1*3.6)end end end elseif up=="speedup"then ct.changeSpd()elseif up=="speeddown"then ct.changeSpd(true)elseif up=="antigravity"and not r then if antigrav~=nil then ct.ToggleAntigrav()else di("No antigrav found")end elseif up=="leftmouse"then c2=true;if c1 then ux()uy=false else c1=true;bj=iz()uh(1)end end end;function ui.stopControl(up)local function uB()if not r and cQ then un=ul end;if b6 or ba or bA then um=uk end end;if up=="forward"then bX=0 elseif up=="backward"then bX=0 elseif up=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif up=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif up=="yawright"then bZ=0 elseif up=="yawleft"then bZ=0 elseif up=="straferight"then iy:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bz=0 elseif up=="strafeleft"then iy:updateCommandFromActionStop(axisCommandId.lateral,1.0)bz=0 elseif up=="up"then ct.vertical(0,-1)elseif up=="down"then ct.vertical(0,1)elseif up=="groundaltitudeup"then uB()uy=false elseif up=="groundaltitudedown"then uB()uy=false elseif up=="brake"then if not a_ and not p4 then if b1 then ct.BrakeToggle()else b1=false end end elseif up=="lalt"then if c1 then c1=false end;if ix()==0 and j then if uy then if iz()==1 then uh(0)else uh(1)end else uy=true end elseif ix()==0 and not j and g=="keyboard"then uh(0)end;p4=false end end;function ui.loopControl(up)local function uC(rd)local re=1;if rd then re=-1 end;if not r and cQ then if bw~=nil then bw=bw+re*un;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end;un=dl(un*1.05,ul,50)else bw=tN+re*100 end elseif b6 or ba or bA then if bA then cD=cD+re*um;if cD<kv.noAtmosphericDensityAltitude then cD=kv.noAtmosphericDensityAltitude end else bb=bb+re*um end;um=dl(um*1.05,uk,50)else iy:updateTargetGroundAltitudeFromActionLoop(re*1.0)end end;local function uD(rd)local re=1;if rd then re=-1 end;if not c1 then if t and not p4 then bR=dl(bR+re*aG/100,-1,1)else iy:updateCommandFromActionLoop(axisCommandId.longitudinal,re*aG)end end end;if up=="groundaltitudeup"then if not c1 then uC()end elseif up=="groundaltitudedown"then if not c1 then uC(true)end elseif up=="speedup"then uD()elseif up=="speeddown"then uD(true)end end;function ui.inputTextControl(rc)local function uE(uF,fm,gp)local function uG(fm)local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local dU,dV,e1,e2,e3=e4(fm,dE)if dU=="0"and dV=="0"then return vec3(dm(e1),dm(e2),dm(e3))end;e2=math.rad(e2)e1=math.rad(e1)local kv=e[dm(dU)][dm(dV)]local eV=math.cos(e1)local uH=vec3(eV*math.cos(e2),eV*math.sin(e2),math.sin(e1))return kv.center+(kv.radius+e3)*uH end;local fN=uG(fm)return cs.AddNewLocation(uF,fN,gp)end;local M;local uI,il=nil,nil;local uJ="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(rc," ")uI=rc;if M~=nil then uI=string.sub(rc,0,M-1)il=string.sub(rc,M+1)end;if uI=="/help"or uI=="/commands"then for ll in string.gmatch(uJ,"([^\n]+)")do a.print(ll)end;return elseif uI=="/setname"then if il==nil or il==""then di("Usage: ah-setname Newname")return end;if bm>0 and fW~=nil then cs.UpdatePosition(il)else di("Select a saved target to rename first")end elseif shield and uI=="/resist"then cw.setResist(il)elseif uI=="/addlocation"or string.find(rc,"::pos")~=nil then local gp=false;local uF="0-Temp"if il==nil or il==""or uI~="/addlocation"then il=uI;gp=true end;M=string.find(il,"::")if not gp then uF=string.sub(il,1,M-2)end;local fm=string.sub(il,M)uE(uF,fm,gp)elseif uI=="/agg"then if il==nil or il==""then di("Usage: /agg targetheight")return end;il=dm(il)if il<1000 then il=1000 end;bw=il;di("AGG Target Height set to "..il)elseif uI=="/G"then if il==nil or il==""then di("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if il=="dump"then for dL,dx in pairs(iB())do if type(dx.get())=="boolean"then if dx.get()==true then a.print(dL.." true")else a.print(dL.." false")end elseif dx.get()==nil then a.print(dL.." nil")else a.print(dL.." "..dx.get())end end;return end;M=string.find(il," ")local uK=string.sub(il,0,M-1)local uL=string.sub(il,M+1)for dL,dx in pairs(iB())do if dL==uK then local uM=type(dx.get())if uM=="number"then uL=dm(uL)if dL=="AtmoSpeedLimit"then cB=uL end end;di("Variable "..uK.." changed to "..uL)if dL=="MaxGameVelocity"then uL=uL/3.6;if uL>df-0.2 then uL=df-0.2;di="Variable "..uK.." changed to "..fL(uL*3.6,1)end end;if uM=="boolean"then if string.lower(uL)=="true"then uL=true else uL=false end end;dx.set(uL)return end end;di("No such global variable: "..uK)elseif uI=="/deletewp"then if bm>0 and fW~=nil then cs.ClearCurrentPosition()else di("Select a custom wp to delete first in IPH")end elseif uI=="/copydatabank"then if dbHud_2 then pE(true)else di("Spare Databank required to copy databank")end elseif uI=="/iphWP"then if bm>0 then a.print(ct.showWayPoint(c8,bl,true))a.print(json.encode(bl))di("::pos waypoint shown in lua chat in local and world format")else di("No target selected in IPH")end elseif uI=="/createPrivate"then local uN="privatelocations = {\n"local uO=""if#d9>0 then for dL,dx in pairs(d9)do uN=uN.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uN=uN.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uN=uN.."safe = true},\n"else uN=uN.."safe = false},\n"end end end;uO=#d9 .."-Private "if il=="all"then for dL,dx in pairs(bq)do uN=uN.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '*"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uN=uN.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uN=uN.." safe = true},\n"else uN=uN.."safe = false},\n"end end;uO=uO..#bq.."-Public "end;uN=uN.."}\n return privatelocations"if ug then ug.setHTML(uN)end;di(uO.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c4=7 end end;function ui.tagTick()if bD=="Off"then bD="All"elseif bD=="All"then bD="Longitude"elseif bD=="Longitude"then bD="Lateral"elseif bD=="Lateral"then bD="Vertical"else bD="Off"end;di("Extra Engine Tags: "..bD)c.stopTimer("tagTick")end;if uP then for dL,dx in pairs(uP)do ui[dL]=dx end end;return ui end;local function uQ(d,b,c,e,vBooster,hover,pD,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iu,ug)local a=DUSystem;local bP=DUConstruct;local uR=DUPlayer;local uS=DULibrary;local uT={}local dk=string.format;local iv=json.decode;local uU=json.encode;local pw=b.getElementMaxHitPointsById;local iw=b.getElementMassById;local ix=d.control.isRemoteControlled;local e4=string.match;local gC=a.destroyWidgetPanel;local fI=a.updateData;local fJ=a.addDataToWidget;local uh=a.lockView;local iz=a.isViewLocked;local dn=math.sqrt;local dm=tonumber;local eZ=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local eU=math.atan;local bM=a.getArkTime;local dl=utils.clamp;local iy=d.axisCommandManager;local gE=13;local iE=b.getElementIdList()local iF=0;local function dp(eC,eD)if eC==0 then return eZ(eD)<1e-09 elseif eD==0 then return eZ(eC)<1e-09 else return eZ(eC-eD)<math.max(eZ(eC),eZ(eD))*dC end end;local function fL(dD,uV)local re=10^(uV or 0)return bN(dD*re+0.5)/re end;local function iA(uW,uX)for dL,dx in pairs(uX)do if type(dL)=="string"then uW[dL]=dx else uW[#uW+1]=uX[dL]end end;return uW end;local function iB(uY)local uZ={}if not uY then iA(uZ,L)iA(uZ,ac)iA(uZ,aE)iA(uZ,aZ)return uZ elseif uY=="boolean"then return L elseif uY=="handling"then return ac elseif uY=="hud"then return aE elseif uY=="physics"then return aZ end end;local function di(sK)if c3~="empty"then if c3~=sK then c3=c3 .."\n"..sK;c4=7 end else c3=sK end end;local function pE(u_)local function v0(v1)for dL,dx in pairs(v1)do dbHud_1.setStringValue(dL,uU(dx.get()))if u_ and dbHud_2 then dbHud_2.setStringValue(dL,uU(dx.get()))end end end;if dbHud_1 then v0(bJ)v0(iB())a.print("Saved Variables to Datacore")if u_ and dbHud_2 then di("Databank copied.  Remove copy when ready.")end end end;local function fK(v2,v3,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v2 ..".mp3")end;local function gD(hx,hy,rc,jM,v4)return dk([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jM or"",hx,hy,v4 or"",rc)end;local function iC(cb,v5)v5=v5 or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fL(cb,v5)..unit end;local function iD(v6)local v7=0;local v8=0;local v9=0;if v6<60 then v6=bN(v6)elseif v6<3600 then v7=bN(v6/60)v6=bN(v6%60)elseif v6<86400 then v8=bN(v6/3600)v7=bN(v6%3600/60)else v9=bN(v6/86400)v8=bN(v6%86400/3600)end;if v9>365 then return">1y"elseif v9>0 then return v9 .."d "..v8 .."h "elseif v8>0 then return v8 .."h "..v7 .."m "elseif v7>0 then return v7 .."m "..v6 .."s"elseif v6>0 then return v6 .."s"else return"0s"end end;local function va()if radar_1 then cu=gB(b,a,c,radar_1,radar_2,warpdrive,eZ,gC,dn,gD,dm,gE,fK,di)end end;function uT.radarSetup()va()end;function uT.onStart()local vb=false;local function vc()local function vd(ve)local vf=dbHud_1.hasKey;for dL,dx in pairs(ve)do if vf(dL)then local dG=iv(dbHud_1.getStringValue(dL))if dG~=nil then dx.set(dG)vb=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vd(iB())coroutine.yield()vd(bJ)else vd(bJ)di("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c4=5;vb=false end;coroutine.yield()if vb then di("Loaded Saved Variables")elseif not f then di("No Databank Saved Variables Found\nVariables will save to Databank on standing")c4=5 end;if#bq>0 then da=iA(da,bq)end else di("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;a_=k;g=string.lower(g)cz=q;cB=W;if bx+180<bQ then bv=0 end;bx=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then di("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c4=7 end;if antigrav and not r then if bw==nil then bw=ci end;antigrav.setTargetAltitude(bw)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d9>0 then da=iA(da,d9)end end;lq="Proceeding to Waypoint"if not a1 or a1<0 then a1=bP.getMaxSpeed()-0.1 end end;local function vg()local function vh(vi,vj)if vi>vj then vj=vi end;local vk,vl=0,0;if a7>0 then vk=a7*0.05 end;if a8>0 then vl=a8*0.05 end;vj=vj*(1-(vk+vl))return vj end;local vm=b.getElementNameById;local vn=au~=0 and av~=0;local vo=_G["atmofueltank_size"]local vp=_G["spacefueltank_size"]local vq=_G["rocketfueltank_size"]for dL in pairs(iE)do local type=b.getElementDisplayNameById(iE[dL])if e4(type,'^.*Atmospheric Engine$')then if e4(tostring(b.getElementTagsById(iE[dL])),'^.*vertical.*$')and b.getElementForwardById(iE[dL])[3]>0 then cP=true end end;if e4(type,'^.*Space Engine$')then cG=true;if e4(tostring(b.getElementTagsById(iE[dL])),'^.*vertical.*$')then local vr=b.getElementForwardById(iE[dL])if vr[3]<0 then vs=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local py=pw(iE[dL])if py>10000 then gE=110 elseif py>1000 then gE=55 elseif py>150 then gE=27 end end;iF=iF+pw(iE[dL])if vn and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local py=pw(iE[dL])local f3=iw(iE[dL])local vi=0;local jE=bM()if type=="Atmospheric Fuel Tank"then local vj=400;local vt=35.03;if py>10000 then vj=51200;vt=5480 elseif py>1300 then vj=6400;vt=988.67 elseif py>150 then vj=1600;vt=182.67 end;vi=f3-vt;if a4>0 then vj=vj+vj*a4*0.2 end;vj=vh(vi,vj)local go=vm(iE[dL])local jC=0;for jD=1,vo do if go==iv(c["atmofueltank_"..jD].getWidgetData()).name then jC=jD;break end end;local vu={iE[dL],string.sub(go,1,12),vj,vt,vi,jE,jC}cl[#cl+1]=vu end;if type=="Rocket Fuel Tank"then local vj=320;local vt=173.42;if py>65000 then vj=40000;vt=25740 elseif py>6000 then vj=5120;vt=4720 elseif py>700 then vj=640;vt=886.72 end;vi=f3-vt;if a6>0 then vj=vj+vj*a6*0.1 end;vj=vh(vi,vj)local go=vm(iE[dL])local jC=0;for jD=1,vq do if go==iv(c["rocketfueltank_"..jD].getWidgetData()).name then jC=jD;break end end;local vu={iE[dL],string.sub(go,1,12),vj,vt,vi,jE,jC}cn[#cn+1]=vu end;if type=="Space Fuel Tank"then local vj=600;local vt=35.03;if py>10000 then vj=76800;vt=5480 elseif py>1300 then vj=9600;vt=988.67 elseif py>150 then vj=2400;vt=182.67 end;vi=f3-vt;if a5>0 then vj=vj+vj*a5*0.2 end;vj=vh(vi,vj)local go=vm(iE[dL])local jC=0;for jD=1,vp do if go==iv(c["spacefueltank_"..jD].getWidgetData()).name then jC=jD;break end end;local vu={iE[dL],string.sub(go,1,12),vj,vt,vi,jE,jC}cm[#cm+1]=vu end end end;if not cP then ba,b0=false,false end end;local function vv()if gyro~=nil then ck=gyro.isActive()==1 end;if not bC then iy:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then uh(1)else uh(0)end;if door and(cg or not cg and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not r then antigrav.showWidget()end end;if ix()==1 and l then uR.freeze(1)else uR.freeze(0)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bn=d.control.isAnyLandingGearDeployed()==1 or cf~=-1 and cf-3<_;if cf~=-1 or not cg and cJ:len()<50 then b1="Startup"else b1=false end;iy:setTargetGroundAltitude(_)pk=cg end;local function vw()local vx={}local function vy()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vz={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vA,vB in pairs(e)do e[vA][0]=vy()e[vA][0].systemId=vA;vx[vA]={}for vC,kv in pairs(e[vA])do kv.gravity=kv.gravity/9.8;kv.center=vec3(kv.center)kv.name=kv.name[1]kv.noAtmosphericDensityAltitude=kv.atmosphereThickness;kv.spaceEngineMinAltitude=vz[kv.id]or 0.5353125*kv.atmosphereThickness;kv.planetarySystemId=vA;kv.bodyId=kv.id;vx[vA][vC]=kv;if mg==nil or kv.center.x<mg then mg=kv.center.x end;if mf==nil or kv.center.x>mf then mf=kv.center.x end;if mj==nil or kv.center.y<mj then mj=kv.center.y end;if mi==nil or kv.center.y>mi then mi=kv.center.y end;if kv.center and kv.name~="Space"then d4[#d4+1]=kv end end end;ee=dj(d,b,c,a,dk,dl,dm,dn,dp)co=ee(vx)fO=co[0]cp=eY(d,b,c,a,dn,eZ)cq=fi(d,b,c,a,dk,dl,dm,dn,dp)cs=fH(d,b,c,a,dbHud_1,e,fI,fJ,bN,dm,dn,fK,fL,di)kv=co[0]:closestBody(bP.getWorldPosition())end;vD=false;vE=coroutine.create(function()iy:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vc()coroutine.yield()vg()coroutine.yield()ct=pC(d,b,c,e,vBooster,hover,pD,antigrav,dbHud_1,eZ,bN,bO,ix,eU,bM,dl,iy,fI,iz,dn,fL,fK,iA,dp,iC,iD,pE,iv,di)vv()coroutine.yield()vw()va()if it then cr=it(d,b,c,a,e,antigrav,hover,shield,warpdrive,iu,eZ,bN,dk,iv,bO,iw,ix,eU,bM,dl,iy,fJ,fI,gC,iz,dn,fL,gD,fK,iA,iB,iC,iD,iE,iF,di)end;if cr then cr.ButtonSetup()end;cv=uf(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ug,ix,iy,iz,uh,gC,fL,e4,dm,dl,fK,iB,pE,di)if shield then cw=ib(shield,e4,bN,di)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if ug then ug.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bP.setDockingMode(ab)if shield then c.setTimer("shieldTick",0.0166667)end;if vF then vG.ExtraOnStart()end;fK("start","SU")local function vH()if bH[1]==0 then ct.cmdThrottle(bH[2])else if ch>0 then cB=bH[2]ct.cmdThrottle(1)end end end;li=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if li then if cf>-1 and cL<1 and cf-3<_ then c.exit()else if J then vH()else if ch==0 then b1="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bH[3]+3>bM()then vH()end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()local vI;vI=#d2>1 and"Passengers: "..#d2-1 .." "or""vI=vI..(#d3>0 and"Ships: "..#d3 or"")if vI~=""then di("NOTICE: Docked "..vI)end end)coroutine.resume(vE)end;function uT.onUpdate()if vD then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iy:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and p6~=vJ then a.setScreen(p6)end;vJ=p6;if li and not J and ch>0 and cf==-1 then cv.landingGear()end;if li and cf>-1 and cL<1 and cf-3<_ then c.exit()end;if vF then vG.ExtraOnUpdate()end else local i1=coroutine.status(vE)if i1=="suspended"then local dM,i2=coroutine.resume(vE)if i2 then a.print("ERROR STARTUP: "..i2)end elseif i1=="dead"then vD=true end end end;function uT.onFlush()if vD then ct.onFlush()if vF then vG.ExtraOnFlush()end end end;function uT.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;w=d6;local vK=0;if li then vK=bM()end;if iy:getAxisCommandType(0)==0 then bH={0,bR,vK}else bH={1,iy:getTargetSpeed(axisCommandId.longitudinal),vK}end;pE()if nS then nS.activate()end;if z then ct.showWayPoint(kv,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vF then vG.ExtraOnStop()end;fK("stop","SU")end;function uT.controlStart(up)if vD then cv.startControl(up)end end;function uT.controlStop(up)if vD then cv.stopControl(up)end end;function uT.controlLoop(up)if vD then cv.loopControl(up)end end;function uT.controlInput(rc)if vD then cv.inputTextControl(rc)end end;function uT.radarEnter(dV)if cu then cu.onEnter(dV)end end;function uT.radarLeave(dV)if cu then cu.onLeave(dV)end end;function uT.onTick(vL)if vL=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vL=="oneSecond"then if cr then cr.OneSecondTick()end elseif vL=="msgTick"then if cr then cr.MsgTick()end elseif vL=="animateTick"then if cr then cr.AnimateTick()end elseif vL=="hudTick"then if cr then cr.hudtick()end elseif vL=="apTick"then if ct then ct.APTick()end elseif vL=="shieldTick"then cw.shieldTick()elseif vL=="tagTick"then cv.tagTick()elseif vL=="contact"then cu.ContactTick()end end;if vF then for dL,dx in pairs(vF)do uT[dL]=dx end end;return uT end;function script.onStart()vG.onStart()end;function script.onOnStop()vG.onStop()end;function script.onTick(vL)vG.onTick(vL)end;function script.onOnFlush()vG.onFlush()end;function script.onOnUpdate()vG.onUpdate()end;function script.onActionStart(up)vG.controlStart(up)end;function script.onActionStop(up)vG.controlStop(up)end;function script.onActionLoop(up)vG.controlLoop(up)end;function script.onInputText(rc)vG.controlInput(rc)end;function script.onEnter(dV)vG.radarEnter(dV)end;function script.onLeave(dV)vG.radarLeave(dV)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vG=uQ(d,core,unit,e,vBooster,hover,pD,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iu,ug)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
