name: ArchHud - Archaegeo v0.008 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.008;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.3;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab=1;ac={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end},DockingMode={set=function(M)ab=M end,get=function()return ab end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV=1.0;aW="none"aX="none"aY="none"aZ={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aV=M end,get=function()return aV end},ExtraLongitudeTags={set=function(M)aW=M end,get=function()return aW end},ExtraLateralTags={set=function(M)aX=M end,get=function()return aX end},ExtraVerticalTags={set=function(M)aY=M end,get=function()return aY end}}a_=k;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=1000;bc=false;bd=false;be=false;bf=false;bg=0;bh="Aligning"bi=0;bj=1;bk="None"bl=nil;bm=0;bn=nil;bo=0.0;bp=0;bq={}br=false;bs=0;bt=0;bu=nil;bv=0;bw=1000;bx=0;by=false;bz=0;bA=false;bB="All"bC=true;bD="Off"bE=0.000;bF={}bG={}bH={}bI=false;bJ={VertTakeOff={set=function(M)ba=M end,get=function()return ba end},VertTakeOffEngine={set=function(M)b0=M end,get=function()return b0 end},SpaceTarget={set=function(M)by=M end,get=function()return by end},BrakeToggleStatus={set=function(M)a_=M end,get=function()return a_ end},BrakeIsOn={set=function(M)b1=M end,get=function()return b1 end},RetrogradeIsOn={set=function(M)b2=M end,get=function()return b2 end},ProgradeIsOn={set=function(M)b3=M end,get=function()return b3 end},Autopilot={set=function(M)b4=M end,get=function()return b4 end},TurnBurn={set=function(M)b5=M end,get=function()return b5 end},AltitudeHold={set=function(M)b6=M end,get=function()return b6 end},BrakeLanding={set=function(M)b7=M end,get=function()return b7 end},Reentry={set=function(M)b9=M end,get=function()return b9 end},AutoTakeoff={set=function(M)b8=M end,get=function()return b8 end},HoldAltitude={set=function(M)bb=M end,get=function()return bb end},AutopilotAccelerating={set=function(M)bc=M end,get=function()return bc end},AutopilotBraking={set=function(M)be=M end,get=function()return be end},AutopilotCruising={set=function(M)bf=M end,get=function()return bf end},AutopilotRealigned={set=function(M)bd=M end,get=function()return bd end},AutopilotEndSpeed={set=function(M)bg=M end,get=function()return bg end},AutopilotStatus={set=function(M)bh=M end,get=function()return bh end},AutopilotPlanetGravity={set=function(M)bi=M end,get=function()return bi end},PrevViewLock={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetName={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetCoords={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetIndex={set=function(M)bm=M end,get=function()return bm end},TotalDistanceTravelled={set=function(M)bo=M end,get=function()return bo end},TotalFlightTime={set=function(M)bp=M end,get=function()return bp end},SavedLocations={set=function(M)bq=M end,get=function()return bq end},VectorToTarget={set=function(M)br=M end,get=function()return br end},LocationIndex={set=function(M)bs=M end,get=function()return bs end},LastMaxBrake={set=function(M)bt=M end,get=function()return bt end},LockPitch={set=function(M)bu=M end,get=function()return bu end},LastMaxBrakeInAtmo={set=function(M)bv=M end,get=function()return bv end},AntigravTargetAltitude={set=function(M)bw=M end,get=function()return bw end},LastStartTime={set=function(M)bx=M end,get=function()return bx end},iphCondition={set=function(M)bB=M end,get=function()return bB end},stablized={set=function(M)bC=M end,get=function()return bC end},UseExtra={set=function(M)bD=M end,get=function()return bD end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bF=M end,get=function()return bF end},apRoute={set=function(M)bG=M end,get=function()return bG end},ecuThrottle={set=function(M)bH=M end,get=function()return bH end},HoverMode={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=q;cA=false;cB=W;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2={}d3={}d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()if shield then dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dh(di)a.print(bQ..": "..di)end;local function dj(d,b,c,a,dk,dl,dm,dn,dp)local function dq(dr)return type(dr)=='number'end;local function ds(dr)return type(dm(dr))=='number'end;local function dt(du)return type(du)=='table'end;local function dv(a)return type(a)=='string'end;local function dw(dx)return dt(dx)and dq(dx.x and dx.y and dx.z)end;local function dy(dz)return dt(dz)and dq(dz.latitude and dz.longitude and dz.altitude and dz.id and dz.systemId)end;local dA=math.pi/180;local dB=180/math.pi;local dC=1e-10;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local utils=utils;local vec3=vec3;local function dF(dr)local dG=string.gsub(string.reverse(dk('%.4f',dr)),'^0*%.?','')return dG==''and'0'or string.reverse(dG)end;local function dH(dI)if dw(dI)then return dk('{x=%.3f,y=%.3f,z=%.3f}',dI.x,dI.y,dI.z)end;if dt(dI)and not getmetatable(dI)then local dJ={}local dK=next(dI)if type(dK)=='nil'or dK==1 then dJ=dI else for dL,dx in pairs(dI)do local dM=dH(dx)if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end end;return dk('{%s}',table.concat(dJ,','))end;if dv(dI)then return dk("'%s'",dI:gsub("'",[[\']]))end;return tostring(dI)end;local dN={}dN.__index=dN;dN.__tostring=function(dI,dO)local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)local dJ={}for dQ,dL in ipairs(dP)do local dM=dH(dI[dL])if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end;if dO then return dk('%s%s',dO,table.concat(dJ,',\n'..dO))end;return dk('{%s}',table.concat(dJ,','))end;dN.__eq=function(dR,dS)return dR.systemId==dS.systemId and dR.id==dS.id and dp(dR.radius,dS.radius)and dp(dR.center.x,dS.center.x)and dp(dR.center.y,dS.center.y)and dp(dR.center.z,dS.center.z)and dp(dR.GM,dS.GM)end;local function dT(dU,dV,dW,dX,dY)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(dW),'Argument 3 (radius) must be a number:'..type(dW))assert(dt(dX),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dX))assert(ds(dY),'Argument 5 (GM) must be a number:'..type(dY))return setmetatable({systemId=dm(dU),id=dm(dV),radius=dm(dW),center=vec3(dX),GM=dm(dY)},dN)end;local dZ={}dZ.__index=dZ;dZ.__tostring=function(dh)return dk('::pos{%d,%d,%s,%s,%s}',dh.systemId,dh.id,dF(dh.latitude*dB),dF(dh.longitude*dB),dF(dh.altitude))end;dZ.__eq=function(dR,dS)return dR.id==dS.id and dR.systemId==dS.systemId and dp(dR.latitude,dS.latitude)and dp(dR.altitude,dS.altitude)and(dp(dR.longitude,dS.longitude)or dp(dR.latitude,math.pi/2)or dp(dR.latitude,-math.pi/2))end;local function d_(e0,dV,e1,e2,e3)local dU=e0;if dv(e0)and not e2 and not e3 and not dV and not e1 then dU,dV,e1,e2,e3=e4(e0,dE)assert(dU,'Argument 1 (position string) is malformed.')else assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(e1),'Argument 3 (latitude) must be in degrees:'..type(e1))assert(ds(e2),'Argument 4 (longitude) must be in degrees:'..type(e2))assert(ds(e3),'Argument 5 (altitude) must be in meters:'..type(e3))end;dU=dm(dU)dV=dm(dV)e1=dm(e1)e2=dm(e2)e3=dm(e3)if dV==0 then return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=dV,systemId=dU},dZ)end;return setmetatable({latitude=dA*dl(e1,-90,90),longitude=dA*(e2%360),altitude=e3,id=dV,systemId=dU},dZ)end;local e5={}e5.__index=e5;e5.__tostring=function(dI,dO)local e6=dO and dO..'  'local e7={}local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)for dQ,e8 in ipairs(dP)do e9=dI[e8]local ea=dN.__tostring(e9,e6)if dO then table.insert(e7,dk('[%s]={\n%s\n%s}',e8,ea,dO))else table.insert(e7,dk('  [%s]=%s',e8,ea))end end;if dO then return dk('\n%s%s%s',dO,table.concat(e7,',\n'..dO),dO)end;return dk('{\n%s\n}',table.concat(e7,',\n'))end;local function eb(ec)local e={}local pid;for dQ,dx in pairs(ec)do local dV=dx.planetarySystemId;if type(dV)~='number'then error('Invalid planetary s ID: '..tostring(dV))elseif pid and dV~=pid then error('Mistringmatch planetary s IDs: '..dV..' and '..pid)end;local ed=dx.bodyId;if type(ed)~='number'then error('Invalid body ID: '..tostring(ed))elseif e[ed]then error('Duplicate body ID: '..tostring(ed))end;setmetatable(dx.center,getmetatable(vec3.unit_x))e[ed]=setmetatable(dx,dN)pid=dV end;return setmetatable(e,e5)end;ee={}local function ef(ec)return setmetatable({galaxyAtlas=ec or{}},ee)end;ee.__index=function(du,M)if type(M)=='number'then local a=du.galaxyAtlas[M]return eb(a)end;return rawget(ee,M)end;ee.__pairs=function(dI)return function(du,dL)local eg,eh=next(du,dL)return eg,eh and eb(eh)end,dI.galaxyAtlas,nil end;ee.__tostring=function(dI)local ei={}for dQ,ej in pairs(dI or{})do local ek=ej:getPlanetarySystemId()local el=e5.__tostring(ej,'    ')table.insert(ei,dk('  [%s]={%s\n  }',ek,el))end;return dk('{\n%s\n}\n',table.concat(ei,',\n'))end;ee.BodyParameters=dT;ee.MapPosition=d_;ee.PlanetarySystem=eb;function ee.createBodyParameters(dU,dV,em,en,eo,ep,eq)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(em),'Argument 3 (surfaceArea) must be a number:'..type(em))assert(dt(en),'Argument 4 (aPosition) must be an array or vec3:'..type(en))assert(dt(eo),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eo))assert(ds(ep),'Argument 6 (altitude) must be in meters:'..type(ep))assert(ds(eq),'Argument 7 (gravityAtPosition) must be number:'..type(eq))local dW=dn(em/4/math.pi)local cb=dW+ep;local er=vec3(en)+cb*vec3(eo)local dY=eq*cb*cb;return dT(dU,dV,dW,er,dY)end;ee.isMapPosition=dy;function ee:getPlanetarySystem(e0)if M==nil then M=0 end;if eh==nil then eh=0 end;local dU=e0;if dy(e0)then dU=e0.systemId end;if type(dU)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eh)~=e5 then a=eb(a)end;return a end end end;function e5:sizeCalculator(es)return 1.05*es.radius end;function e5:castIntersections(et,eu,ev,ew,ex,ey)local ez={}if ex then for dQ,es in pairs(ex)do table.insert(ez,es)end else ez=d4 end;if not ey then table.sort(ez,function(eA,eB)local eC=eA.center;local eD=eB.center;return(eC.x-et.x)^2+(eC.y-et.y)^2+(eC.z-et.z)^2<(eD.x-et.x)^2+(eD.y-et.y)^2+(eD.z-et.z)^2 end)end;local eE=eu:normalize()for dQ,es in ipairs(ez)do local eF=es.center-et;local dW;if ev then dW=ev(es)else dW=self:sizeCalculator(es)end;local eG=eF:dot(eE)local eH=eG^2-(eF:len2()-dW^2)if eH>=0 then local eI=dn(eH)local eJ=eG+eI;local eK=eG-eI;if eK>0 then return es,eJ,eK elseif eJ>0 then return es,eJ,nil end end end;return nil,nil,nil end;function e5:closestBody(eL)assert(type(eL)=='table','Invalid coordinates.')local eM,es;local eN=vec3(eL)for dQ,eO in pairs(self)do local eP=(eO.center-eN):len2()if(not es or eP<eM)and eO.name~="Space"then es=eO;eM=eP end end;return es end;function e5:convertToBodyIdAndWorldCoordinates(e0)local eQ=e0;if dv(e0)then eQ=d_(e0)end;if eQ.id==0 then return 0,vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;local eO=self:getBodyParameters(eQ)if eO then return eQ.id,eO:convertToWorldCoordinates(eQ)end end;function e5:getBodyParameters(e0)local dV=e0;if dy(e0)then dV=e0.id end;assert(ds(dV),'Argument 1 (id) must be a number:'..type(dV))return self[dV]end;function e5:getPlanetarySystemId()local dQ,dx=next(self)return dx and dx.systemId end;function dN:convertToMapPosition(dX)assert(dt(dX),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dX))local eR=vec3(dX)if self.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=self.systemId},dZ)end;local eS=eR-self.center;local cb=eS:len()local e3=cb-self.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=self.id,systemId=self.systemId},dZ)end;function dN:convertToWorldCoordinates(e0)local eQ=dv(e0)and d_(e0)or e0;if eQ.id==0 then return vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;assert(dy(eQ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eQ.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eQ.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eV=math.cos(eQ.latitude)return self.center+(self.radius+eQ.altitude)*vec3(eV*math.cos(eQ.longitude),eV*math.sin(eQ.longitude),math.sin(eQ.latitude))end;function dN:getAltitude(dX)return(vec3(dX)-self.center):len()-self.radius end;function dN:getDistance(dX)return(vec3(dX)-self.center):len()end;function dN:getGravity(dX)local eW=self.center-vec3(dX)local eX=eW:len2()return self.GM/eX*eW/dn(eX)end;return setmetatable(ee,{__call=function(dQ,...)return ef(...)end})end;local function eY(d,b,c,a,dn,eZ)local cp={}local bP=999000000000/3600;local e_=bP*bP;local f0=100;function cp.computeAccelerationTime(f1,f2,f3)local f4=bP*math.asin(f1/bP)return(bP*math.asin(f3/bP)-f4)/f2 end;function cp.computeDistanceAndTime(f1,f3,f5,f6,f7,f8)f7=f7 or 0;f8=f8 or 0;local f9=f1<=f3;local fa=f6*(f9 and 1 or-1)/f5;local fb=-f8/f5;local fc=fa+fb;if f9 and fc<=0 or not f9 and fc>=0 then return-1,-1 end;local fd,fe=0,0;if fa~=0 and f7>0 then local f4=math.asin(f1/bP)local ff=math.pi*(fa/2+fb)local fg=fa*f7;local fh=bP*math.pi;local dx=function(du)local fi=(ff*du-fg*math.sin(math.pi*du/2/f7)+fh*f4)/fh;local fj=math.tan(fi)return bP*fj/dn(fj*fj+1)end;local fk=f9 and function(a)return a>=f3 end or function(a)return a<=f3 end;fe=2*f7;if fk(dx(fe))then local fl=0;while eZ(fe-fl)>0.5 do local du=(fe+fl)/2;if fk(dx(du))then fe=du else fl=du end end end;local fm=f1;local fn=fe/f0;for fo=1,f0 do local fp=dx(fo*fn)fd=fd+(fp+fm)*fn/2;fm=fp end;if fe<2*f7 then return fd,fe end;f1=fm end;local f4=bP*math.asin(f1/bP)local bQ=(bP*math.asin(f3/bP)-f4)/fc;local fq=e_*math.cos(f4/bP)/fc;local cb=fq-e_*math.cos((fc*bQ+f4)/bP)/fc;return cb+fd,bQ+fe end;function cp.computeTravelTime(f1,f2,cb)if cb==0 then return 0 end;if f2>0 then local f4=bP*math.asin(f1/bP)local fq=e_*math.cos(f4/bP)/f2;return(bP*math.acos(f2*(fq-cb)/e_)-f4)/f2 end;if f1==0 then return-1 end;assert(f1>0,'Acceleration and initial speed are both zero.')return cb/f1 end;return cp end;local function fr(d,b,c,a,dk,dl,dm,dn,dp)local vec3=vec3;local dj=dj(d,b,c,a,dk,dl,dm,dn,dp)local function dv(a)return type(a)=='string'end;local function dt(du)return type(du)=='table'end;fs={}fs.__index=fs;function fs:escapeAndOrbitalSpeed(e3)assert(self.body)local cb=e3+self.body.radius;if not dp(cb,0)then local ft=dn(self.body.GM/cb)return dn(2)*ft,ft end;return nil,nil end;function fs:orbitalParameters(e0,fu)assert(self.body)assert(dt(e0)or dv(e0))assert(dt(fu))local fv=(dv(e0)or dj.isMapPosition(e0))and self.body:convertToWorldCoordinates(e0)or vec3(e0)local dx=vec3(fu)local fw=fv-self.body.center;local fx=dx:len2()local fy=fw:len()local fz=self.body.GM;local fA=((fx-fz/fy)*fw-fw:dot(dx)*dx)/fz;local eC=fz/(2*fz/fy-fx)local fB=fA:len()local eE=fA:normalize()local fC=eC*(1-fB)local fD=eC*(1+fB)local fE=fC*eE+self.body.center;local fF=fB<=1 and-fD*eE+self.body.center or nil;local fG=dn(eC*fz*(1-fB*fB))local fH=fF and 2*math.pi*dn(eC^3/fz)local fI=math.acos(fA:dot(fw)/(fB*fy))if fw:dot(dx)<0 then fI=-(fI-2*math.pi)end;local fJ=math.acos((math.cos(fI)+fB)/(1+fB*math.cos(fI)))local fK=fJ;if fK<0 then fK=fK+2*math.pi end;local fL=fK-fB*math.sin(fK)local fM=0;local fN=0;local fO=0;if fH~=nil then fM=fL/(2*math.pi/fH)fN=fH-fM;fO=fN+fH/2;if fI-math.pi>0 then fN=fM;fO=fN+fH/2 end;if fO>fH then fO=fO-fH end end;return{periapsis={position=fE,speed=fG/fC,circularOrbitSpeed=dn(fz/fC),altitude=fC-self.body.radius},apoapsis=fF and{position=fF,speed=fG/fD,circularOrbitSpeed=dn(fz/fD),altitude=fD-self.body.radius},currentVelocity=dx,currentPosition=fv,eccentricity=fB,period=fH,eccentricAnomaly=fJ,meanAnomaly=fL,timeToPeriapsis=fN,timeToApoapsis=fO,trueAnomaly=fI}end;local function fP(fQ)local eO=dj.BodyParameters(fQ.systemId,fQ.id,fQ.radius,fQ.center,fQ.GM)return setmetatable({body=eO},fs)end;return setmetatable(fs,{__call=function(dQ,...)return fP(...)end})end;local function fR(d,b,c,a,dbHud_1,e,fS,fT,bN,dm,dn,fU,fV,di)local function fW(fX)local dh=fY:closestBody(fX)if(fX-dh.center):len()>dh.radius+dh.noAtmosphericDensityAltitude then dh=e[0][0]end;return dh end;local function fZ()local function f_(g0,g1)return g0.name<g1.name end;cU={}for dL,dx in pairs(e[0])do cU[#cU+1]={name=dx.name,index=dL}end;table.sort(cU,f_)end;local function g2(g3,g4)if not g4 then g4=g5.name end;for dL,dx in pairs(g3)do if dx.name and dx.name==g4 then return dL end end;return-1 end;local function g6()d1=bm;if bm==0 then bk="None"c8=nil;g5=nil;return true end;local g7=cU[bm].index;local g8=e[0][g7]if g8.center then bk=g8.name;c8=co[0][g7]if g5~=nil then if ch==0 then if fS(g9,ga)~=1 then fT(g9,ga)end;if fS(gb,gc)~=1 then fT(gb,gc)end;if fS(gd,ge)~=1 then fT(gd,ge)end;if fS(gf,gg)~=1 then fT(gf,gg)end;if fS(gh,gi)~=1 then fT(gh,gi)end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end;if fS(gn,go)~=1 then fT(gn,go)end end;g5=nil else g5=g8;for dQ,dx in pairs(co[0])do if dx.name==g5.planetname then c8=dx;bk=g5.name;break end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end end;if g5==nil then bl=vec3(c8.center)else bl=g5.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gp=bN(c8.radius*(U-1)+c8.noAtmosphericDensityAltitude)else gp=bN(c8.radius*(U-1)+c8.surfaceMaxAltitude)end else gp=T end;if g5~=nil and g5.planetname=="Space"then bg=0 else dQ,bg=cq(c8):escapeAndOrbitalSpeed(gp)end;bi=0;bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"return true end;local function gq(gr)if not b4 and not br and not cd and not bA and not b9 and not ce then if gr==nil then bm=bm+1;if bm>#cU then bm=0 end else bm=bm-1;if bm<0 then bm=#cU end end;if bm==0 then g6()else local g7=cU[bm].index;local g8=e[0][g7]if g8 and(g8~=nil and g8.name=="Space"or bB=="Custom Only"and g8.center or bB=="No Moons-Asteroids"and(string.find(g8.name,"Moon")~=nil or string.find(g8.name,"Asteroid")~=nil))then if gr==nil then gq()else gq(1)end else g6()end end else di("Disengage autopilot before changing Interplanetary Helper")fU("iph","AP")end end;local function gs()local function gt(gu)local gv;if gu then gv=d9 else gv=bq end;local gw=-1;gw=g2(e[0])if gw>-1 then table.remove(e[0],gw)end;gw=-1;gw=g2(gv)if gw~=-1 then di(g5.name.." saved location cleared")table.remove(gv,gw)end;gq()fZ()return gv end;if string.sub(bk,1,1)=="*"then d9=gt(true)else bq=gt(false)end end;local function gx(gy,fX,gz,gA)local function gB(gu)if gu then gv=d9 else gv=bq end;if dbHud_1 or gz or gu then local dh=fW(fX)local gC={position=fX,name=gy,planetname=dh.name,gravity=b.getGravityIntensity(),safe=gA}if not gz then gv[#gv+1]=gC else for dL,dx in pairs(e[0])do if dx.name and gy==dx.name then table.remove(e[0],dL)end end end;table.insert(e[0],gC)fZ()g6()di("Location saved as "..gy.."("..dh.name..")")return gv else di("Databank must be installed to save permanent locations")end end;if string.sub(gy,1,1)=="*"then d9=gB(true)else bq=gB(false)end end;local gD={}function gD.UpdateAtlasLocationsList()fZ()end;function gD.UpdateAutopilotTarget()g6()end;function gD.adjustAutopilotTargetIndex(gr)gq(gr)end;function gD.findAtlasIndex(g3,g4)return g2(g3,g4)end;function gD.UpdatePosition(gE,gF,gG)local function gH(gu)local gv;if gu then gv=d9 else gv=bq end;local gw=g2(gv)if gw~=-1 then if gE~=nil then if gu then gE="*"..gE end;gv[gw].name=gE;bm=bm-1;gq()elseif gG~=nil then if gG then local gI=ci;if gI<1000 then gI=1000 end;gv[gw].agg=fV(gI,0)di(gv[gw].name.." AGG Altitude:"..gv[gw].agg.." saved ("..gv[gw].planetname..")")return elseif gG==false then gv[gw].agg=nil;di(gv[gw].name.." AGG Altitude cleared ("..gv[gw].planetname..")")return end else local gJ=gv[gw]if gF then gJ.heading=cI:cross(cM)*5000;di=gv[gw].name.." heading saved ("..gv[gw].planetname..")"return elseif gF==false then gJ.heading=nil;di=gv[gw].name.." heading cleared ("..gv[gw].planetname..")"return end;gJ.gravity=b.getGravityIntensity()gJ.position=cO;gJ.safe=true end;di(gv[gw].name.." position updated ("..gv[gw].planetname..")")else di("Name Not Found")end end;if string.sub(bk,1,1)=="*"then gH(true)else gH(false)end end;function gD.AddNewLocation(gy,fX,gz,gA)gx(gy,fX,gz,gA)end;function gD.ClearCurrentPosition()gs()end;for dL,dx in pairs(da)do table.insert(e[0],dx)end;if gK then for dL,dx in pairs(gK)do gD[dL]=dx end end;fZ()if bm>#cU then bm=0 end;gD.UpdateAutopilotTarget()return gD end;local function gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU,di)local gP={}local gQ={}local gR={XS=13,S=27,M=55,L=110,XL=221}local gS={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gT={}local gU=0;local gV;local gW;local gX=0;local gY;local gZ={gY}local g_="Atmo"local h0;local h1;local h2=0;local h3={}local h4;local h5=0;local h6=table.insert;local h7=-4;local h8={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h9,ha;local hb,hc;local hd;local he;local hf;local hg;local hh;local hi;local hj;local function hk()if hl~=nil and h2==0 then gM(hl)a.destroyWidget(h9)a.destroyData(hb)h9,hb,hl=nil,nil,nil;if h1~=nil then gM(h1)a.destroyWidget(ha)a.destroyData(hc)h1,ha,hc=nil,nil,nil end else if h2==1 then h1=a.createWidgetPanel("PeriWinkle")ha=a.createWidget(h1,'periscope')hc=gY.getWidgetDataId()a.addDataToWidget(hc,ha)end;if hl==nil and gU>0 then hl=a.createWidgetPanel(g_)h9=a.createWidget(hl,'radar')hb=gY.getWidgetDataId()a.addDataToWidget(hb,h9)end;h2=0 end end;local function hm()local function hn(ho,hp,hq,hr,hs,ht,hu,hv)hp,hr,ht,hv=vec3(hp),vec3(hr),vec3(ht),vec3(hv)local hw,hx,hy=ho*ho,hq*hq,hs*hs;local fx=hr-hp;local hz=fx:normalize()local hA=fx:len()local hB=ht-hp;local hC=(hB-hB:project_on(hz)):normalize()local hD,hE=hB:dot(hz),hB:dot(hC)local hF=hD*hD+hE*hE;local hG=hz:cross(hC)local hH=(hw-hx+hA*hA)/(2*hA)local hI=(hw-hy+hF-2*hD*hH)/(2*hE)local dz=hw-hH^2-hI^2;local hJ=dn(dz)local hK=hp+hz*hH+hC*hI+hG*hJ;local hL=hp+hz*hH+hC*hI-hG*hJ;if eZ((hv-hK):len()-hu)<eZ((hv-hL):len()-hu)then return hK else return hL end end;local function hM(hN,fy,hO)local hP=hN.pts;local gw=#hP;local hQ=hN.ref;if gw>3 then local hR,hS,hT,hU=hP[gw],hP[gw-1],hP[gw-2],hP[gw-3]hN.ref=hO;local fv=hn(hR[1],hR[2],hS[1],hS[2],hT[1],hT[2],hU[1],hU[2])local hH,hI,hJ=fv.x,fv.y,fv.z;if hH==hH and hI==hI and hJ==hJ then hH=hH+hQ[1]hI=hI+hQ[2]hJ=hJ+hQ[3]local hV=vec3(hH,hI,hJ)hN.center=hV;if hN.lastPos then if(hN.lastPos-hV):len()<2 then local hW=(hV-vec3(hO)):len()if eZ(hW-fy)<10 then hN.skipCalc=true end end end;hN.lastPos=hV end;hN.pts={}else local hX={hO[1]-hQ[1],hO[2]-hQ[2],hO[3]-hQ[3]}hP[gw+1]={fy,hX}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gY then if#h4>0 then local hY,hZ=0,0;local h_=cL*10;local cY=cY;gX,gW=0,0;gQ={}for dQ,dx in pairs(h4)do local cb=hh(dx)if cb>0.0 then if hd(dx)==1 then h6(gQ,dx)end;if not cV and warpdrive and cb<aa and warpdrive.getStatus()==15 then di("INITIATING WARP")c4=7;warpdrive.initiate()end;local i0=F and hf(dx)==1;if E or i0 then local i1=hi(dx)local i2=gR[i1]local i3=he(dx)if i0 or cb<h_ and(i2>27 or i3==4 or i3==6)then gX=gX+1;local hO={cO["x"],cO["y"],cO["z"]}local hN=h3[dx]if hN==nil then i2=i2+gO;h3[dx]={pts={},ref=hO,name=hg(dx),i=0,radius=i2,skipCalc=false}hN=h3[dx]end;if not hN.skipCalc then if i0 or i3==4 or i3==6 then hN.center=vec3(hj(dx))hN.skipCalc=true else hM(hN,cb,hO)hZ=hZ+1 end;if i0 and not hN.abandoned then local bQ=a.getArkTime()if h5+5<bQ then h5=bQ;fU("abRdr","RD")end;a.print("Abandoned Construct: "..hN.name.." ("..i1 .." "..gS[i3]..") at ::pos{0,0,"..hN.center.x..","..hN.center.y..","..hN.center.z.."}")di("Abandoned Radar Contact ("..i1 .." "..gS[i3]..") detected")hN.abandoned=true end else h6(gT,hN)end end;hY=hY+1;if hY>300 or hZ>30 then coroutine.yield()hY,hZ=0,0 end end end end;gW=#gT;if gW>0 and(cL>20 or b7)then local es,i4,i5,i6;local i7=0;local i8=co:getPlanetarySystem(0)i6=cK:normalize()while i7<gW do coroutine.yield()local i9={table.unpack(gT,i7,math.min(i7+75,gW))}es,i4,i5=i8:castIntersections(cO,i6,nil,nil,i9,true)if es and i5 then c_={es,i4,i5}break end;i7=i7+75 end;if not es then c_=nil end else c_=nil end;gT={}gV=gY.getTargetId()end end end;local function ia()if gY then g_="Atmo"if string.find(gY.getName(),"Space")then g_="Space"end end end;function gP.pickType()ia()end;function gP.assignRadar()if radar_2 and h7~=1 then if h7==-1 then if gY==radar_2 then gY=radar_1 else gY=radar_2 end end;gZ={gY}hd=gY.hasMatchingTransponder;he=gY.getConstructKind;hf=gY.isConstructAbandoned;hg=gY.getConstructName;hh=gY.getConstructDistance;hi=gY.getConstructCoreSize;hj=gY.getConstructWorldPos;h4=gY.getConstructIds()ia()else h4=gY.getConstructIds()end;h7=gY.getOperationalState()end;function gP.UpdateRadar()local ib=coroutine.status(h0)if ib=="suspended"then local dM,ic=coroutine.resume(h0)if ic then a.print("ERROR UPDATE RADAR: "..ic)end elseif ib=="dead"then h0=coroutine.create(hm)local dM,ic=coroutine.resume(h0)end end;function gP.GetRadarHud(id,ie,ay,az)local ig,di;local dD=gW or 0;gU=#h4;if gU>0 then if E then di=dD.."/"..gX.." Known/InRange : "..gU.." Total"else di="Radar Contacts: "..gU end;ig=gN(ay,az,di,"pbright txtbig txtmid")if#gQ>0 then ig=ig..gN(id,ie,"Friendlies In Range","pbright txtbig txtmid")for dL,dx in pairs(gQ)do ie=ie+20;ig=ig..gN(id,ie,gY.getConstructName(dx),"pdim txtmid")end end;local ih=#gY.getIdentifiedConstructIds()if h1==nil and ih>0 then h2=1;cu.ToggleRadarPanel()end;if h1~=nil and ih==0 then cu.ToggleRadarPanel()end;if hl==nil then if w then cu.ToggleRadarPanel()end end else if h7~=1 then ig=gN(ay,az,g_.." Radar: "..h8[h7],"pbright txtbig txtmid")else ig=gN(ay,az,"Radar: No "..g_.." Contacts","pbright txtbig txtmid")end;if hl~=nil then h2=0;cu.ToggleRadarPanel()end end;return ig end;function gP.GetClosestName(gy)if gY then local ii=gY.getConstructName(gY.getConstructIds()[1])if ii then gy=gy.." "..ii end end;return gy end;function gP.ToggleRadarPanel()hk()end;function gP.ContactTick()if not ij then ij=0 end;if bQ>ij+10 then di("Radar Contact")fU("rdrCon","RC")ij=bQ end;c.stopTimer("contact")end;function gP.onEnter(dV)if gY and not cg and not cV then c.setTimer("contact",0.1)end end;function gP.onLeave(dV)if gY and E then if#h3>650 then dV=tostring(dV)h3[dV]=nil end end end;local function ik()gY=nil;if radar_2 and radar_2.getOperationalState()==1 then gY=radar_2 else gY=radar_1 end;h7=gY.getOperationalState()hd=gY.hasMatchingTransponder;he=gY.getConstructKind;hf=gY.isConstructAbandoned;hg=gY.getConstructName;hh=gY.getConstructDistance;hi=gY.getConstructCoreSize;hj=gY.getConstructWorldPos;gZ={gY}h4=gY.getConstructIds()ia()h0=coroutine.create(hm)if il then for dL,dx in pairs(il)do gP[dL]=dx end end end;ik()return gP end;local function im(shield,e4,bN,di)local io={}local ip=shield.getResistancesCooldown()local function iq()local ir=shield.isActive()if G then if not cV and ir==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and ir==1 then shield.toggle()end end end;local function is()local it=shield.getStressRatioRaw()local iu=0.5999;if it[1]==0.0 and it[2]==0.0 and it[3]==0.0 and it[4]==0.0 then return end;local iv=shield.setResistances(iu*it[1],iu*it[2],iu*it[3],iu*it[4])if iv==1 then di("Shield Resistances updated")else di("Value Exceeded. Failed to update Shield Resistances")end end;function io.shieldTick()dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())iq()ip=shield.getResistancesCooldown()if ip==0 and dg<a9 then is()end end;function io.setResist(iw)if not shield then di("No shield found")return elseif iw==nil or ip>0 then di("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE=dD..', '..dD..', '..dD..', '..dD;local ix,iy,iz,iA=e4(iw,dE)if iA==nil or ix+iy+iz+iA>0.6 then di("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(ix,iy,iz,iA)==1 then di("Shield Resistances set")else di("Resistance setting failed.")end end;function io.ventShield()local iB=shield.getVentingCooldown()if iB>0 then di("Cannot vent again for "..iB.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()di("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else di("Shields already at max hitpoints")end end;if iC then for dL,dx in pairs(iC)do io[dL]=dx end end;return io end;local function iD(d,b,c,a,e,antigrav,hover,shield,warpdrive,iE,eZ,bN,dk,iF,bO,iG,iH,eU,bM,dl,iI,fT,fS,gM,iJ,dn,fV,gN,fU,iK,iL,iM,iN,iO,iP,di)local bP=DUConstruct;local iQ=9.80665;local iR={}local iS={}local iT={}local iU={}local iV=nil;local iW=nil;local iX=nil;local iY=false;local iZ="none"local i_=""local j0=55;local j1=0;local j2=0;local j3=nil;local j4=ag;local j5=ah;local j6=ai;local j7=[[rgb(]]..bN(j4+0.5)..","..bN(j5+0.5)..","..bN(j6+0.5)..[[)]]local j8=[[rgb(]]..bN(j4*0.9+0.5)..","..bN(j5*0.9+0.5)..","..bN(j6*0.9+0.5)..[[)]]local j9=0;local ja=0;local jb=""local jc=bM()local jd=false;local je=false;local gY=false;local function jf(dx)if ad==1920 then return dx else return fV(ad*dx/1920,0)end end;local function jg(dx)if ae==1080 then return dx else return fV(ae*dx/1080,0)end end;local function jh()return iJ()==0 and g~="keyboard"and iH()==0 end;local function ji()local jj="TRAVEL"if not cR then jj="CRUISE"end;if b4 then jj="AUTOPILOT"end;return jj end;local ig=""local jk=""local jl=""local jm=1;local jn=2;local jo=3;local jp=4;local jq=5;local jr=6;local js=7;local jt=""local ju=0;local jv=90.0*aU;local jw={}local jx={}local jy={}local jz={}local jA={}local jB={}local jC={}jC["atmofueltank"],jC["spacefueltank"],jC["rocketfueltank"]=0,0,0;local jD=0;local function jE(hH,jF,jG,jH,jI,jJ)local jK=jD;local jL=jD+5;if not B then jL=jL+5 end;if iH()==1 and not m then jK=jK-50;jL=jL-50 end;if jG=="ATMO"then jt="atmofueltank"elseif jG=="SPACE"then jt="spacefueltank"else jt="rocketfueltank"end;ju=_G[jt.."_size"]if#jH>0 then for M=1,#jH do local gy=jH[M][jn]local jM=jH[M][js]for jN=1,ju do if jH[M][jn]==iF(c[jt.."_"..jN].getWidgetData()).name then jM=jN;break end end;local jO=bM()if jI[M]==nil or jJ[M]==nil or jO-jH[M][jr]>jv then local jP;local jQ=0;jQ=iG(jH[M][jm])-jH[M][jp]jP=jH[M][jq]local jR=jP>jQ or false;if jR then jC[jt]=jC[jt]+jP-jQ end;if jM~=0 then local jS=iF(c[jt.."_"..jM].getWidgetData())jJ[M]=jS.percentage;jI[M]=jS.timeLeft;if jI[M]=="n/a"then jI[M]=0 end else jJ[M]=bN(0.5+jQ*100/jH[M][jo])if jR then jI[M]=bN(0.5+jQ/((jP-jQ)/(jO-jH[M][jr])))else jI[M]=0 end end;jH[M][jr]=jO;jH[M][jq]=jQ end;if gy==jF then gy=dk("%s %d",jG,M)end;if jM==0 then gy=gy.." *"end;local jT;jT=iN(jI[M])if jI[M]==0 or jT==">1y"then jT=""end;if jJ[M]~=nil then local jU=bN(jJ[M]*2.55)local jV=dk("rgb(%d,%d,%d)",255-jU,jU,0)local jW=""if jT~=""and jI[M]<120 or jJ[M]<5 then jW="red "end;local jX=dk("rgb(%d,%d,%d)",dl(bN((255-jU)/2.55),50,100),dl(bN(jU/2.55),0,50),50)local jY="rgb(196,0,255)"if jG=="ATMO"then jY="rgb(0,188,255)"elseif jG=="SPACE"then jY="rgb(239,255,0)"end;local jZ=false;if j_~=jY then jZ=true end;j_=jY;if B then if jZ then jK=jK-5;jL=jL-5 end;jk=jk..dk([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jX,jY,hH,jL,jV,bN(jJ[M]*1.7+0.5)-2,hH+1,jL+1,hH+5,jL+14,gy,jJ[M],jT)jK=jK-22;jL=jL-22 else jk=jk..gN(hH,jK,gy,jW.."pdim txtfuel")jk=jk..gN(hH,jL,dk("%d%% %s",jJ[M],jT),"pdim txtfuel","fill:"..jV)jK=jK+30;jL=jL+30 end end end end;jD=jK end;local function k0(k1,e3)if aq==0 and ar==0 then return end;if e3<200000 and not cg or e3 and cg then local k2=0;if eZ(cN)>1 then k2=45*math.log(eZ(cN),10)if cN<0 then k2=-k2 end end;k1[#k1+1]=dk([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bN(cN),bN(k2))end;return k1 end;local function k3(k4)local gr=-cM;k4=k4-k4:project_on(gr)local k5=vec3(0,0,1)k5=k5-k5:project_on(gr)local k6=k5:cross(gr)local k2=k5:angle_between(k4)*constants.rad2deg;if k4:dot(k6)<0 then k2=360-k2 end;return k2 end;local function k7(k1,am,an,k8,k9,cY)if af==0 then return end;local ka=af;local kb=20;local kc=bN(k8)if cY then for M=-45,45,5 do local kd=M;k1[#k1+1]=dk([[<g transform="rotate(%f,%d,%d)">]],kd,am,an)ke=5;if M%15==0 then ke=15 elseif M%10==0 then ke=10 end;k1[#k1+1]=dk([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+ka+kb-ke,am,an+ka+kb)end;k1[#k1+1]=gN(am,an+ka+kb-35,k9,"pdim txt txtmid")k1[#k1+1]=gN(am,an+ka+kb-25,kc.." deg","pdim txt txtmid")k1[#k1+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k8,am,an)k1[#k1+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+ka+kb-20,am+5,an+ka+kb-20,am,an+ka+kb-15)k1[#k1+1]="</g>"end;k1[#k1+1]=[[<g style="clip-path: url(#headingClip);">]]local kf=kc;if cY then kf=k3(cH)end;local kg=20;local kh=bN(kf)local ki=0;local kj=an+ka+kb+20;local kk=am;if k9~="YAW"then kj=jg(130)kk=jf(960)end;local kl=[[<path class="txttick line" d="]]local km=bN(kh-(kg+10)-kh%5+0.5)for M=km+70,km,-5 do local hH=kk-(-M*5+kf*5)if M%10==0 then ki=10;local dD=M;if dD==360 then dD=0 elseif dD>360 then dD=dD-360 elseif dD<0 then dD=dD+360 end;k1[#k1+1]=gN(hH,kj+15,dD,"txtmid bright")elseif M%5==0 then ki=5 end;if ki==10 then kl=dk([[%s M %f %f v %d]],kl,hH,kj-5,ki)else kl=dk([[%s M %f %f v %d]],kl,hH,kj-2.5,ki)end end;k1[#k1+1]=kl..[["/>]]k1[#k1+1]=dk([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kk-5,kj-20,kk+5,kj-20,kk,kj-10)if cY then k9="HDG"end;k1[#k1+1]=gN(jf(960),jg(100),kh.."Â°","dim txt txtmid size14","")k1[#k1+1]=gN(jf(960),jg(85),k9,"dim txt txtmid size20","")k1[#k1+1]=[[</g>]]end;local function kn(k1,ko,k8,am,an,cY,kp,fp)if af==0 then return end;local ka=af;local kq=bN(ka*3/5)if ka>0 then local kr=bN(ko)local ke=0;local kl=dk([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k8,am,an)if not cg then kl=dk([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;k1[#k1+1]=dk([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],ka-1,am,an)k1[#k1+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(kr-30-kr%5+0.5),bN(kr+30+kr%5+0.5),5 do if M%10==0 then ke=30 elseif M%5==0 then ke=20 end;local hI=an+-M*5+ko*5;if ke==30 then kl=dk([[%s M %d %f h %d]],kl,am-kq-ke,hI,ke)if cg then k1[#k1+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k8,am,an,am-kq+10,hI+4,M)k1[#k1+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k8,am,an,am+kq-10,hI+4,M)if M==0 or M==180 or M==-180 then k1[#k1+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k8,am,an,am-kq+20,hI,kq*2-40)end else k1[#k1+1]=gN(am-kq+10,hI,M,"pdim txt txtmid")k1[#k1+1]=gN(am+kq-10,hI,M,"pdim txt txtmid")end;kl=dk([[%s M %d %f h %d]],kl,am+kq,hI,ke)else kl=dk([[%s M %d %f h %d]],kl,am-kq-ke,hI,ke)kl=dk([[%s M %d %f h %d]],kl,am+kq,hI,ke)end end;k1[#k1+1]=kl..[["/>]]local ks="PITCH"if not cY then ks="REL PITCH"end;if ko>90 and not cg then ko=90-(ko-90)elseif ko<-90 and not cg then ko=-90-(ko+90)end;if ka>200 then if cg then if fp>j0 then k1[#k1+1]=gN(am,an-15,"Yaw","pdim txt txtmid")k1[#k1+1]=gN(am,an+20,kp,"pdim txt txtmid")end;k1[#k1+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k8,am,an)else k1[#k1+1]=dk([[<g transform="rotate(0,%d,%d)">]],am,an)end;k1[#k1+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-kq+25,an-5,am-kq+20,an,am-kq+25,an+5,am-kq+50,an+4,kr)k1[#k1+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+kq-25,an-5,am+kq-20,an,am+kq-25,an+5,am+kq-30,an+4,kr)k1[#k1+1]="</g>"end;local kt=bN(ka/3)k1[#k1+1]=dk([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-kt,an,ka-kt)if not cg and cY then k1[#k1+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k8,am,an,am-kq+10,an,kq*2-20)end;k1[#k1+1]="</g>"if ka<200 then if cg and fp>j0 then k1[#k1+1]=gN(am,an-ka,ks,"pdim txt txtmid")k1[#k1+1]=gN(am,an-ka+10,kr,"pdim txt txtmid")k1[#k1+1]=gN(am,an-15,"Yaw","pdim txt txtmid")k1[#k1+1]=gN(am,an+20,kp,"pdim txt txtmid")else k1[#k1+1]=gN(am,an-ka,ks,"pdim txt txtmid")k1[#k1+1]=gN(am,an-ka+15,kr,"pdim txt txtmid")end end end end;local function ku(k1,e3,cY)local kv=as;local kw=at;if kv==0 and kw==0 then return end;local kx=78;local ky=19;local kz=cf;if cf~=-1 then k1[#k1+1]=gN(kv+kx,kw+ky+20,dk("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(e3<200000 and not cg or e3 and cg)then table.insert(k1,dk([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kv-1,kw-4,kx+2,ky+6,kv+1,kw-1,kx-4,ky))local gw=0;local kA=1;local kB=0;local kC=e3<0;local kD=e3<kE.surfaceMaxAltitude;local kF=9;if kC then kF=0 end;local e3=eZ(e3)while gw<6 do local kG=11;local kH=16;local kI=9;local kJ=14;local jW="altsm"if gw>2 then kH=kH+3;kG=kG+2;kJ=kJ+2;kI=kI-6;jW="altbig"end;if kC then jW=jW.." red"elseif kD then jW=jW.." orange"end;local kK=e3/kA%10;local kL=bN(kK)local kM=bN((kL+1)%10)local kN=kB;if gw==0 then kN=kK-kL;if kC then kN=1-kN end end;if kC and(gw==0 or kB~=0)then local gz=kM;kM=kL;kL=gz end;local kO=kH*(kN-1)local kP=kO+kH;local hH=kv+kI+(6-gw)*kG;local hI=kw+kJ;k1[#k1+1]=gN(hH,hI+kO,kM,jW)k1[#k1+1]=gN(hH,hI+kP,kL,jW)gw=gw+1;kA=kA*10;if kL==kF then kB=kN else kB=0 end end;table.insert(k1,[[</g></g>]])end end;local function kQ(fu)local kR=-math.deg(eU(fu.y,fu.z))+180;kR=kR-90;if kR<0 then kR=360+kR end;if kR>180 then kR=-180+kR-180 end;return-kR end;local function kS(fu)local kf=math.deg(eU(fu.y,fu.x))-90;if kf<-180 then kf=360+kf end;return kf end;local function kT(k1,fu,fp,am,an)if fp>5 and not cg or fp>j0 then local ka=af;local kU=20;local kV=20;local kW=kQ(fu)local kX=kS(fu)local kY=14;local kZ=kY/2;local k_=-kX/kV*ka;local l0=kW/kU*ka;local hH=am+k_;local hI=an+l0;local cb=dn(k_^2+l0^2)local l1=[[<circle
                            cx="]]..hH..[["
                            cy="]]..hI..[["
                            r="]]..kZ/kY..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hH..[["
                            cy="]]..hI..[["
                            r="]]..kZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hH-kY..[[,]]..hI..[[ h ]]..kZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hH+kZ..[[,]]..hI..[[ h ]]..kZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hH..[[,]]..hI-kY..[[ v ]]..kZ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<ka then k1[#k1+1]=l1 else local k2=eU(l0,k_)local l2=4;local l3=am+ka*math.cos(k2)local l4=an+ka*math.sin(k2)k1[#k1+1]=dk('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',k2*180/math.pi,l3,l4,l3-l2,l4-l2/2,l2*2,l2,l3+l2,l4-l2,l2,l2,-l2,l2)end;if not cg then local l5=vec3(fu)kW=kQ(-l5)kX=kS(-l5)k_=-kX/kV*ka;l0=kW/kU*ka;hH=am+k_;hI=an+l0;cb=dn(k_^2+l0^2)if cb<ka then local l6=[[<circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hH..[[,]]..hI-kY..[[ v ]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hH..[[,]]..hI..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hH..[[,]]..hI..[[)" />
                                <path
                                    d="M ]]..hH-kZ..[[,]]..hI..[[ h ]]..kY..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hH..[[,]]..hI..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hH..[[,]]..hI..[[)"/>]]k1[#k1+1]=l6 end end end end;local function l7(k1,jj,l8,l9)if ao==0 and ap==0 then return end;l8=bN(l8+0.5)local jK=ap+10;local jL=ap+20;if iH()==1 and not m then jK=55;jL=65 end;local la="CRUISE"local c="km/h"local dM=l9;if jj=="TRAVEL"or jj=="AUTOPILOT"then la="THROT"c="%"dM=l8;local lb="dim"if l8<0 then lb="red"end;k1[#k1+1]=dk([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],lb,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-eZ(l8),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;k1[#k1+1]=gN(ao+10,jK,la,"pbright txtstart")k1[#k1+1]=gN(ao+10,jL,dk("%.0f %s",dM,c),"pbright txtstart")if cg and t and cR and bT then l8=bN(bU*100+0.5)local lb="red"if l8<0 then lb="red"end;k1[#k1+1]=dk([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],lb,1-eZ(l8),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)k1[#k1+1]=gN(ao+10,jK+40,"LIMIT","pbright txtstart")k1[#k1+1]=gN(ao+10,jL+40,l8 .."%","pbright txtstart")end;if cg and t or b9 then k1[#k1+1]=gN(ao+10,jK-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b4 then k1[#k1+1]=gN(ao+10,jK-40,"LIMIT: "..bN(a1*3.6+0.5).." km/h","dim txtstart")end end;local function lc(k1,ld)if ao==0 and ap==0 then return end;local le=ap-10;local lf=ao+10;k1[#k1+1]=gN(0,0,"","pdim txt txtend")if iH()==1 and not m then le=75 end;k1[#k1+1]=gN(lf,le,bN(ld).." km/h","pbright txtbig txtstart")end;local lg=40;local function lh(k1)k1[#k1+1]=gN(jf(150),jg(1070),dk("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")k1[#k1+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then k1[#k1+1]=gN(jf(960),jg(550),"Warning: Invalid Control Scheme Detected","warnings")k1[#k1+1]=gN(jf(960),jg(600),"Keyboard Scheme must be selected","warnings")k1[#k1+1]=gN(jf(960),jg(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local li=jf(960)local lj=jg(860)local lk=jg(880)local ll=jg(900)local lm=jg(960)local ln=jg(200)local lo=jg(250)local lp=jg(960)if iH()==1 and not m then lj=jg(135)lk=jg(155)ll=jg(175)ln=jg(115)lo=jg(95)end;if b1 then local lq=""if type(b1)=="string"then lq="-"..b1 end;k1[#k1+1]=gN(li,lj,"Brake Engaged"..lq,"warnings")elseif bS>0 then k1[#k1+1]=gN(li,lj,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b4 and not br and not b7 and not cQ and not ba and not b8 then k1[#k1+1]=gN(li,ln+50,"** STALL WARNING **","warnings")fU("stall","SW",2)end end;if cX then k1[#k1+1]=gN(li,ln+90,"Flight Assist in Progress","warnings")end;if ck then k1[#k1+1]=gN(li,lp,"Gyro Enabled","warnings")end;if lr then lg=lg-1;if lg>20 then k1[#k1+1]=gN(li,lp-20,"ECU Enabled","warnings")elseif lg<0 then lg=40 end end;if bn then if bW then k1[#k1+1]=gN(li,lk,"Gear Extended","warn")else k1[#k1+1]=gN(li,lk,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local ls=iM(d:getTargetGroundAltitude())k1[#k1+1]=gN(li,ll,"Hover Height: "..ls,"warn")end;if c5 then k1[#k1+1]=gN(li,lm+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cQ and bw~=nil then local lt="warnings"if eZ(ci-antigrav.getBaseAltitude())<501 then lt="warn"end;k1[#k1+1]=gN(li,ln+40,dk("Target Altitude: %d Singularity Altitude: %d",bN(bw),bN(antigrav.getBaseAltitude())),lt)end;if b4 and bk~="None"then k1[#k1+1]=gN(li,ln,"Autopilot "..bh,"warn")elseif bu~=nil then k1[#k1+1]=gN(li,ln+20,dk("LockedPitch: %d",bN(bu)),"warn")elseif c0 then k1[#k1+1]=gN(li,ln+20,"Follow Mode Engaged","warn")elseif b9 or ce then k1[#k1+1]=gN(li,ln+20,"Re-entry in Progress","warn")end;if b6 or ba then local ls=iM(bb,2)if ba then if cQ then ls=iM(antigrav.getBaseAltitude(),2).." AGG singularity height"end;k1[#k1+1]=gN(li,ln,"VTO to "..ls,"warn")elseif b8 and not bA then if cd then k1[#k1+1]=gN(li,ln,"Takeoff to "..bk,"warn")else k1[#k1+1]=gN(li,ln,"Takeoff to "..ls,"warn")end;if b1 and not ba then k1[#k1+1]=gN(li,ln+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else k1[#k1+1]=gN(li,ln,"Altitude Hold: "..dk("%.1fm",bb),"warn")end end;if ba and(antigrav~=nil and antigrav)then if ch>0.1 then k1[#k1+1]=gN(li,ln+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then k1[#k1+1]=gN(li,ln+20,"Aligning trajectory","warn")elseif ch<0.05 then k1[#k1+1]=gN(li,ln+20,"Leaving atmosphere","warn")end end;if bA then if cC~=nil then k1[#k1+1]=gN(li,ln,cC,"warn")end end;if b7 then local lu="Brake Landing"if dc then lu=lu.."-Aligning"end;if db then lu=lu.."-Drift Limited"end;k1[#k1+1]=gN(li,ln,lu,"warnings")end;if b3 then k1[#k1+1]=gN(li,ln+20,"Prograde Alignment","crit")end;if b2 then k1[#k1+1]=gN(li,ln,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;k1[#k1+1]=gN(li,lo+20,cZ,type)elseif ch==0 then local lv,lw=ct.checkLOS(cK:normalize())if lw~=nil then local ls=iM(lw)local lx=cp.computeTravelTime(cL,0,lw)local ly="Collision"if lv.noAtmosphericDensityAltitude>0 then ly="Atmosphere"end;k1[#k1+1]=gN(li,lo+20,lv.name.." "..ly.." "..iN(lx).." In "..ls,"crit")end end;if br and not bA then k1[#k1+1]=gN(li,ln+60,lz,"warn")end;if d2 and#d2>1 then end;local lA=jf;local lB=jg;local lC="topButton"local lD="topButtonActive"local lE=lC;if b4 or br or cd or bA then lE=lD end;local lF=lC;if b3 then lF=lD end;local lG=lC;if b7 or bn then lG=lD end;local lH=lC;if b6 or br then lH=lD end;local lI=lC;if b2 then lI=lD end;local lJ=lC;if bA or cE and b4 then lJ=lD end;if w and I then local lK=lB(30)k1[#k1+1]=dk([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lE,lA(960),lB(54),lB(-53),lA(-120),lA(25),lB(50))k1[#k1+1]=gN(lA(910),lK,"AUTOPILOT")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lA(865),lB(51),lA(-25),lB(-50),lA(-110),lA(25),lB(46))k1[#k1+1]=gN(lA(800),lK,"PROGRADE")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lA(755),lB(47),lA(-25),lB(-46),lA(-98),lA(44),lB(44))k1[#k1+1]=gN(lA(700),lK,"LAND")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lH,lA(960),lB(54),lB(-53),lA(120),lA(-25),lB(50))k1[#k1+1]=gN(lA(1010),lK,"ALT HOLD")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lI,lA(1055),lB(51),lA(25),lB(-50),lA(110),lA(-25),lB(46))k1[#k1+1]=gN(lA(1122),lK,"RETROGRADE")k1[#k1+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lA(1165),lB(47),lA(25),lB(-46),lA(98),lA(-44),lB(44))k1[#k1+1]=gN(lA(1220),lK,"ORBIT")k1[#k1+1]=[[
                                    </g>
                                </g>]]k1[#k1+1]="</g>"end;return k1 end;local function lL(fp)return bN(fV(fp*3.6,0)+0.5).." km/h"end;local function lM(gw)local gy=bk;if gw~=nil and type(gw)=="number"then if gw==0 then return"None"end;gy=cU[gw].name end;if gy==nil then gy=g5.name end;if gy==nil then gy="None"end;return gy end;local function lN(k1)local lO=ct.routeWP(true)if not lO or#lO==0 then return end;local hH=jf(750)local hI=jg(360)if b4 or br then k1[#k1+1]=gN(hH,hI,"REMAINING ROUTE","pdim txtstart size20")else k1[#k1+1]=gN(hH,hI,"LOADED ROUTE","pdim txtstart size20")end;for dL,M in pairs(lO)do hI=hI+20;k1[#k1+1]=gN(hH,hI,dL..". "..lO[dL],"pdim txtstart size20")end end;local function lP(k1)local hH=aC+10;local hI=aD+20;local lQ={}local lR={"Alt-4: AutoTakeoff to Target"}local lS={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lT={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lU={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lQ,"--------------DYNAMIC-----------------")if cg then if cf~=-1 then iK(lQ,lR)if c8 and kE and c8.name==kE.name then table.insert(lQ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b0 then if antigrav then if cQ then table.insert(lQ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lQ,"Turn on AGG to takeoff to AGG Height")end end;if b0 then table.insert(lQ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lQ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lQ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bn then table.insert(lQ,"G: Takeoff to hover height, raise gear")else table.insert(lQ,"G: Lowergear and Land")end else iK(lQ,lS)table.insert(lQ,"G: Begin BrakeLanding or Land")end;if ba then table.insert(lQ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iK(lQ,lT)if shield then table.insert(lQ,"Alt-Shift-6: Vent shields")if not G then table.insert(lQ,"Alt-Shift-7: Toggle shield off/on")end end end;if g5~=nil then table.insert(lQ,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lQ,"Alt-9: Activate Gyroscope")end;if aX~="none"or aW~="none"or aY~="none"then table.insert(lQ,"Alt-Shift-9: Cycles engines with Extra tags")end;if b6 then table.insert(lQ,"Alt-Spacebar/C will raise/lower target height")table.insert(lQ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cg then table.insert(lQ,"LALT+Mousewheel will lower/raise speed limit")end;iK(lQ,lU)for M=1,#lQ do hI=hI+12;k1[#k1+1]=gN(hH,hI,lQ[M],"pdim txtbig txtstart")end end;local function lV(k1)local lW=aC;local lX=aD;local lY=aB;local lZ=4;local l_=15;local hH=0;local hI=0;local m0,m1,m2,m3;local m4;local function m5(type)local gI,bQ,fp,m6,jW,m7;if type=="Periapsis"then gI=m4.periapsis.altitude;bQ=m4.timeToPeriapsis;fp=m4.periapsis.speed;jW="txtend"m6=12;m7=math.min(hH,lW+lY-kE.radius/m2-lZ*2)else gI=m4.apoapsis.altitude;bQ=m4.timeToApoapsis;fp=m4.apoapsis.speed;m6=-12;jW="txtstart"m7=hH end;if cL<1 then bQ=0 end;k1[#k1+1]=dk([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m7+m6,hI-5,hH,hI-5)k1[#k1+1]=dk([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m7-m6*4,hI+2,hH,hI+2)k1[#k1+1]=gN(m7,hI,type,jW)hH=m7-m6*2;hI=hI+l_;local ls=iM(gI)k1[#k1+1]=gN(hH,hI,ls,jW)hI=hI+l_;k1[#k1+1]=gN(hH,hI,iN(bQ),jW)hI=hI+l_;k1[#k1+1]=gN(hH,hI,lL(fp),jW)end;local m8=lY*1.5;if bK=="INFO"then m8=25*10 end;if bK=="ORBIT"and ci<kE.spaceEngineMinAltitude then return k1 end;if bK~="HIDE"then k1[#k1+1]=[[<g class="pbright txtorb txtmid">]]k1[#k1+1]=dk('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lY*2,m8,lW,lX)k1[#k1+1]=dk([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lY*2,m8,lW,lX)end;local m9=lY*1.5;local ma=lY*2;local mb=m9/2;local mc=lY;local md=lW+mc;local me=lX+mb;local mf=lW+ma;local mg=lX+m9;if bK=="ORBIT"then lX=lX+lZ;m0=lY/2;m3=0;m4={}m4.periapsis={}m4.apoapsis={}if ft~=nil then if ft.periapsis~=nil then m4.periapsis.altitude=ft.periapsis.altitude;m4.periapsis.speed=ft.periapsis.speed end;if ft.apoapsis~=nil then m4.apoapsis.altitude=ft.apoapsis.altitude;m4.apoapsis.speed=ft.apoapsis.speed end;m4.period=ft.period;m4.eccentricity=ft.eccentricity;m4.timeToApoapsis=ft.timeToApoapsis;m4.timeToPeriapsis=ft.timeToPeriapsis;m4.eccentricAnomaly=ft.eccentricAnomaly;m4.trueAnomaly=ft.trueAnomaly end;if m4.periapsis==nil then m4.periapsis={}m4.periapsis.altitude=-kE.radius;m4.periapsis.speed=a1 end;if m4.eccentricity==nil then m4.eccentricity=1 end;if m4.apoapsis==nil then m4.apoapsis={}m4.apoapsis.altitude=ci;m4.apoapsis.speed=0 end;if cL<1 then m4.apoapsis.altitude=ci;m4.apoapsis.speed=0 end;if m4.apoapsis.altitude then m2=(m4.apoapsis.altitude+m4.periapsis.altitude+kE.radius*2)/(m0*2)m1=(kE.radius+m4.apoapsis.altitude)/m2*(1-m4.eccentricity)m3=m0-m4.periapsis.altitude/m2-kE.radius/m2;local mh=math.pi;if m4.period~=nil and m4.period>0 and m4.timeToApoapsis~=nil then mh=m4.eccentricAnomaly;if m4.timeToPeriapsis<m4.timeToApoapsis then mh=2*math.pi-mh end end;if cL<1 or mh~=mh then mh=math.pi end;local mi=-m0*math.cos(mh)+lW+mc+lZ;local mj=m1*math.sin(mh)+lX+mb+lZ;local mk=""k1[#k1+1]='<g clip-path="url(#orbitRect)">'k1[#k1+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mk,lW+lY+lZ,lX+lY*1.5/2+lZ,m0,m1)if m1<1 then k1[#k1+1]=dk([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lW+lY+lZ-m3,lX+lY*1.5/2+lZ,mi,mj)end;k1[#k1+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,(kE.radius+kE.noAtmosphericDensityAltitude)/m2)k1[#k1+1]=dk('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,(kE.radius+kE.noAtmosphericDensityAltitude)/m2)k1[#k1+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lW+lY+lZ,lX+lY*1.5/2+lZ,m0,m1)k1[#k1+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,kE.radius/m2)k1[#k1+1]='</g>'local ml=math.floor(kE.radius/m2+0.5)hH=lW+lY+lZ*4+m0;hI=lX+lY*1.5/2+5+lZ;if m4.apoapsis~=nil and m4.apoapsis.speed<a1 then m5("Apoapsis")end;hI=lX+lY*1.5/2+5+lZ;hH=lW+lY-lZ*2-m0;if m4.periapsis~=nil and m4.periapsis.speed<a1 and m4.periapsis.altitude>0 then m5("Periapsis")end;k1[#k1+1]=gN(lW+lY+lZ,lX+20+lZ,kE.name,"txtorbbig")k1[#k1+1]=dk('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mi,mj)k1[#k1+1]=[[</g>]]return k1 else k1[#k1+1]='<g clip-path="url(#orbitRect)">'local mm=""local mn=1.2*(mo-mp)/(lY*2)local mq=1.4*(mr-ms)/(lY*1.5)for dL,dx in pairs(e[0])do if dx.center then local hH=lW+lY+dx.center.x/mn;local hI=lX+lY*1.5/2+dx.center.y/mq;mm=mm..'<circle cx="'..hH..'" cy="'..hI..'" r="'..dx.radius/mn*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dx.name,"Moon")and not string.match(dx.name,"Sanctuary")and not string.match(dx.name,"Space")then mm=mm.."<text x='"..hH.."' y='"..hI+dx.radius/mn*30+20 .."' font-size='12' fill="..j7 .." text-anchor='middle' font-family='Montserrat'>"..dx.name.."</text>"end end end;local fv=vec3(bP.getWorldPosition())local hH=lW+lY+fv.x/mn;local hI=lX+lY*1.5/2+fv.y/mq;mm=mm..'<circle cx="'..hH..'" cy="'..hI..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mm=mm.."<text x='"..hH.."' y='"..hI-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iV=mn;iW=mq;local mt=fv+cK*1000000;local mu=lW+lY+mt.x/mn;local jL=lX+lY*1.5/2+mt.y/mq;mm=mm..'<line x1="'..hH..'" y1="'..hI..'" x2="'..mu..'" y2="'..jL..'" stroke="purple" stroke-width="1"/>'k1[#k1+1]=mm;k1[#k1+1]='</g>'end elseif bK=="INFO"then k1=cr.DrawOdometer(k1,j9,bo,ja)elseif bK=="HELP"then k1=lP(k1)elseif bK=="SCOPE"then k1[#k1+1]='<g clip-path="url(#orbitRect)">'local mv=d5;if ch>0 then table.sort(d4,function(eA,eB)local eC,eD=eA.center,eB.center;return(eC.x-cO.x)^2+(eC.y-cO.y)^2+(eC.z-cO.z)^2<(eD.x-cO.x)^2+(eD.y-cO.y)^2+(eD.z-cO.z)^2 end)end;local mw={}local mx={}local my=120;local mz=nil;local mA=nil;for M,dx in ipairs(d4)do local gV=dx.center-cO;local mB=gV:len()local mC=gV:normalize()local mD=gV:cross(cH):normalize()local mE=math.acos(mD:dot(cI))if mE~=mE then mE=0 end;if mD:cross(cI):dot(cH)<0 then mE=-mE end;local mF=gV:project_on_plane(cH):len()local mG=math.sin(mE)*math.asin(mF/mB)*constants.rad2deg;local mH=math.cos(mE)*math.asin(mF/mB)*constants.rad2deg;if mC:dot(cH)<0 then mH=90*math.cos(mE)+90*math.cos(mE)-mH;mG=90*math.sin(mE)+90*math.sin(mE)-mG end;local hH=md+mG/mv*m9;local hI=me+mH/mv*m9;local mI=(hH-md)*(hH-md)+(hI-me)*(hI-me)local mJ=math.asin((dx.radius+dx.surfaceMaxAltitude)/mB)*constants.rad2deg;if mJ~=mJ then mJ=mv end;local i1=mJ/mv*m9;local mK=math.asin(dx.atmosphereRadius/mB)*constants.rad2deg;if mK~=mK then mK=mJ end;local mL=mK/mv*m9;local cb=iM(mB,1)local mM=dx.name;local mN=false;if hI>lX then if hI>mg then if hI-mL<=mg then mN=true end else mN=true end else if hI+mL>=lX then mN=true end end;local mO=false;local mP=hH;if dx.systemId==0 then mP=hH+my else mP=hH-my end;if mP+my>lW then if mP+my>mf then if mP-mL-my<=mf then mO=true end else mO=true end else if mP+mL+my>=lW then mO=true end end;local mQ={}mQ.x=hH;mQ.y=hI;mQ.planet=dx;mQ.atmoSize=mL;if not mz or mI<mz then mz=mI;mA=mQ end;if mO and mN then local mR=math.max(mL,5)if mI<mR*mR then mM=mM.." - "..cb end;mQ.size=i1;mQ.i=M;mQ.displayString=mM;mQ.distance=cb;mQ.visible=true;mx[#mx+1]=mQ else mQ.visible=false end end;local mS=false;table.sort(mx,function(eC,eD)return eC.y<eD.y end)for dL,fy in ipairs(mx)do local dx,i1,M,mL,hH,hI,mM,cb=fy.planet,fy.size,fy.i,fy.atmoSize,fy.x,fy.y,fy.displayString,fy.distance;local m7,mT,mU,mV;local mW=15;local jW="pdim"if dx.systemId~=0 then mU=jf(string.len(mM)*5)mW=-(15+mU)mV=jg(10)jW="pdimfill"else mU=jf(string.len(mM)*9)mV=jg(15)end;if i1*2>mU then m7=dl(hH,lW+mU/2,mf-mU/2)mT=dl(hI,lX+mV,mg-5)m7=dl(m7,hH-i1+mU/2,hH+i1-mU/2)mT=dl(mT,hI-i1+mV,hI+i1)else m7=hH+mW;mT=hI end;for mX,fy in pairs(mw)do local mY=fy.textPositions;local mZ=mY.y-mT;if mX~=M and eZ(mZ)<mY.height and mY.x+mY.width>m7 and mY.x<m7+mU then if i1>mU then mT=dl(mT+mV,lX+15,mg-5)else mT=mY.y+mY.height+1 end end end;local m_=mM~=dx.name or m7<=md and m7+mU>=md and mT-mV<=me and mT>=me;fy.hovered=m_;local n0=1;if m_ then n0=2;if i1*2<mU then n0=10 end;if mM==dx.name then mM=mM.." - "..cb end;jW="pbright"if dx.systemId~=0 then mU=jf(string.len(mM)*5)mW=-(15+mU)else mU=jf(string.len(mM)*7)end;if i1*2>mU then m7=dl(hH,lW+mU/2,mf-mU/2)m7=dl(m7,hH-i1+mU/2,hH+i1-mU/2)else m7=hH+mW end end;mw[M]={}mw[M].textPositions={}mw[M].textPositions.y=mT;mw[M].textPositions.x=m7;mw[M].textPositions.width=mU;mw[M].textPositions.height=mV;mw[M].output=""if i1*2>mU then jW=jW.." txtmid"else jW=jW.." txtstart"end;if mL-i1>2 then mw[M].output=dk('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hH,hI,mL,j8,0.1*n0)end;mw[M].output=mw[M].output..dk('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hH,hI,i1,j8,0.2*n0)if dx.systemId==0 then mw[M].output=mw[M].output..dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m7,mT,j7,jW,mM)if i1*2<=mU then mw[M].output=mw[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m7+mU,mT+2,m7,mT+2,hH,hI)end else mw[M].output=mw[M].output..dk([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m7,mT,j8,jW,mM)if i1*2<=mU then mw[M].output=mw[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m7,mT+2,m7+mU,mT+2,hH,hI)end end end;for dL=#d4,1,-1 do if mw[dL]then k1[#k1+1]=mw[dL].output end end;if mA~=nil and d5<90 and not mA.hovered then local n1=mA.planet.atmosphereRadius/mA.atmoSize;local n2=dn(mz)*n1;local n3=iM(n2,1)local mU=jf(math.max(string.len(n3)*7,string.len(mA.planet.name)*7))local mV=jg(12)local m7=dl(mA.x+(md-mA.x)/2,lW+mU/2,mf-mU/2)local mT=dl(mA.y+(me-mA.y)/2,lX+mV*2,mg-5)k1[#k1+1]=dk("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mA.x,mA.y,md,me)k1[#k1+1]=dk([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m7,mT,"white",n3)if not mA.visible then k1[#k1+1]=dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m7,mT-mV,"white",mA.planet.name)end end;if cL>1 then local gV=cK;local mC=gV:normalize()local mF=gV:project_on_plane(cH):len()local mD=gV:cross(cH):normalize()local mE=math.acos(mD:dot(cI))if mE~=mE then mE=0 end;if mD:cross(cI):dot(cH)<0 then mE=-mE end;local mG=math.sin(mE)*math.asin(mF/gV:len())*constants.rad2deg;local mH=math.cos(mE)*math.asin(mF/gV:len())*constants.rad2deg;if mC:dot(cH)<0 then mH=90*math.cos(mE)+90*math.cos(mE)-mH;mG=90*math.sin(mE)+90*math.sin(mE)-mG end;local hH=md+mG/mv*m9;local hI=me+mH/mv*m9;local kY=14;local kZ=kY/2;local l1=[[<circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kZ/kY..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hH..[["
                                    cy="]]..hI..[["
                                    r="]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hH-kY..[[,]]..hI..[[ h ]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hH+kZ..[[,]]..hI..[[ h ]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hH..[[,]]..hI-kY..[[ v ]]..kZ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]k1[#k1+1]=l1 end;k1[#k1+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",md,me-10,md,me+10)k1[#k1+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",md-10,me,md+10,me)k1[#k1+1]='</g>'else return k1 end end;local function n4(n5,n6)local n7;local n8=(n6-n5):normalize()local fw=(cO-n5):dot(n8)/n8:dot(n8)if fw<=0. then return(cO-n5):len()elseif fw>=(n6-n5):len()then return(cO-n6):len()end;local n9=n5+fw*n8;n7=(n9-cO):len()return n7 end;local function na()local n7;local nb=nil;local nc=nil;local nd=nil;for dL,ne in pairs(e[0])do if ne.hasAtmosphere then local cb=n4(kE.center,ne.center)if nb==nil or cb<nb then nc=ne;nb=cb;nd=kE end;if c8 and c8.hasAtmosphere and c8.name~=kE.name then local eP=n4(c8.center,ne.center)if eP<nb then nc=ne;nb=eP;nd=c8 end end end end;local nf=jf(1770)local ng=jg(330)if nb then local nh="txttick "local ni=500000;if nb<nc.radius+ni or nb<nd.radius+ni then if cV then nh="txttick red "else nh="txttick orange "end end;n7=iM(nb,2)i_=gN(nf,ng,"Pipe ("..nd.name.."--"..nc.name.."): "..n7,nh.."pbright txtmid")end end;local function nj(hH,hI,nk,nl,la)local nm={x=hH,y=hI,width=nk,height=nl,label=la}iU[la]=nm;return nm end;local function nn(no,np,nk,nl,hH,hI,nq,nr,ns,nt,jW)local nm={enableName=no,disableName=np,width=nk,height=nl,x=hH,y=hI,toggleVar=nq,toggleFunction=nr,drawCondition=ns,hovered=false,class=jW}if nt then table.insert(iT,nm)else table.insert(iS,nm)end;return nm end;local function nu(nv)if not iY then nw=false;nx=false;ny=false;w=true;return elseif nv=="handling"then nw=not nw;nx=false;ny=false elseif nv=="hud"then nx=not nx;nw=false;ny=false elseif nv=="physics"then ny=not ny;nw=false;nx=false end;if ny or nx or nw then iZ=iL(nv)w=false else iZ="none"w=true end end;local function nz()iY=not iY;if iY then iR=iT;di("Tap LMB to see Settings")d6=w else iR=iS;di("Tap LMB to see Control Buttons")nu()w=d6 end end;local function nA()local function nB(dx,dL)dx.set(not dx.get())if dx.get()then di(dL.." set to true")else di(dL.." set to false")end;if dL=="showHud"then d6=dx.get()elseif dL=="BrakeToggleDefault"then a_=k end end;local nC=50;local nD=340;local hH=500;local hI=ae/2-400;local nE=0;for dL,dx in pairs(iL("boolean"))do if type(dx.get())=="boolean"then nn(dL,dL,nD,nC,hH,hI,function()return dx.get()end,function()nB(dx,dL)end,function()return true end,true)hI=hI+nC+20;if nE==9 then hH=hH+nD+20;hI=ae/2-400;nE=0 else nE=nE+1 end end end;nn("Control View","Control View",nD,nC,10,ae/2-500,function()return true end,nz,function()return true end,true)nn("View Handling Settings",'Hide Handling Settings',nD,nC,10,ae/2-(500-nC),function()return nw end,function()nu("handling")end,function()return true end,true)nn("View Hud Settings",'Hide Hud Settings',nD,nC,10,ae/2-(500-nC*2),function()return nx end,function()nu("hud")end,function()return true end,true)nn("View Physics Settings",'Hide Physics Settings',nD,nC,10,ae/2-(500-nC*3),function()return ny end,function()nu("physics")end,function()return true end,true)end;local function nF()local function gx()local fX=cO;local gy=kE.name..". "..#bq;if cu then gy=cu.GetClosestName(gy)end;return cs.AddNewLocation(gy,fX,false,true)end;local function nG()b5=not b5 end;local function nH(nI)if nI==1 then b3=not b3;b2=false else b2=not b2;b3=false end;b4=false;b6=false;c0=false;b7=false;bu=nil;b9=false;b8=false end;local function nJ(nK,nL)cs.UpdatePosition(nil,nK,nL)end;local function gs()cs.ClearCurrentPosition()end;local function nM(gw)local lO=ct.routeWP(true)if lO and#lO>0 then return"Engage Route: "..lO[1]end;return"Engage Autopilot: "..lM(gw)end;local function nN(gw)local lO=ct.routeWP(true)if lO and#lO>0 then return"Next Route Point: "..lO[1]end;return"Disable Autopilot: "..lM(gw)end;local function nO()if iH()==1 then c0=not c0;if c0 then b4=false;b2=false;b3=false;b6=false;b9=false;b7=false;b8=false;nP=bn;bn=false;d.control.retractLandingGears()iI:setTargetGroundAltitude(Z)fU("folOn","F")else fU("folOff","F")b1="Follow Off"cz=q;bn=nP;if bn then d.control.deployLandingGears()iI:setTargetGroundAltitude(_)end end else di("Follow Mode only works with Remote controller")c0=false end end;local nC=50;local nD=260;local nQ=jf(30)local nR=aC+aB*2+2;local nS=aD+1;nn("+","+",nQ,nQ,nR,nS+nQ+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")nn("-","-",nQ,nQ,nR,nS,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")nn("0","0",nQ,nQ,nR,nS+nQ*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nT=nn("Enable Brake Toggle","Disable Brake Toggle",nD,nC,ad/2-nD/2,ae/2+350,function()return a_ end,function()a_=not a_;if a_ then di("Brakes in Toggle Mode")else di("Brakes in Default Mode")end end)nn("Align Prograde","Disable Prograde",nD,nC,ad/2-nD/2-50-nT.width,ae/2-nC+380,function()return b3 end,function()nH(1)end)nn("Align Retrograde","Disable Retrograde",nD,nC,ad/2-nD/2+nT.width+50,ae/2-nC+380,function()return b2 end,nH,function()return ch==0 end)nU=nn(nM,nN,600,60,ad/2-600/2,ae/2-60/2-330,function()return b4 or br or cd or bA end,function()end)local M;local function nV(nW)local gw=d1+nW;if gw>#cU then gw=gw-#cU-1 end;if gw<0 then gw=#cU+gw end;return gw end;nX={}for M=0,10 do local nY=nn(function(eD)local gw=nV(eD.apExtraIndex)if b4 or br or cd or bA then return"Redirect: "..lM(gw)end;return nM(gw)end,function(eD)local gw=nV(eD.apExtraIndex)return nN(gw)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eD)local gw=nV(eD.apExtraIndex)return gw==bm and(b4 or br or cd or bA)end,function(eD)local gw=nV(eD.apExtraIndex)local nZ=bm==gw;bm=gw;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not nZ and not(b4 or br or cd or bA)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nY.apExtraIndex=M;nX[M]=nY end;nn("Save Position","Save Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,gx,function()return bm==0 or g5==nil end)nn("Update Position","Update Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,function()nJ(nil)end,function()return bm>0 and g5~=nil end)nn("Save Heading","Clear Heading",200,nU.height,nU.x+nU.width+30,nU.y+nU.height+20,function()return g5.heading~=nil end,function()if g5.heading~=nil then nJ(false)else nJ(true)end end,function()return bm>0 and g5~=nil end)nn("Save AGG Alt","Clear AGG Alt",200,nU.height,nU.x+nU.width+30,nU.y+nU.height*2+40,function()return g5.agg~=nil end,function()if g5.agg~=nil then nJ(nil,false)else nJ(nil,true)end end,function()return bm>0 and g5~=nil and antigrav end)nn("Clear Position","Clear Position",200,nU.height,nU.x-200-30,nU.y,function()return true end,gs,function()return bm>0 and g5~=nil end)nn("Save Route","Save Route",200,nU.height,nU.x-200-30,nU.y+nU.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)nn("Load Route","Clear Route",200,nU.height,nU.x-200-30,nU.y+nU.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b4 or br then di("Disable Autopilot before loading route")return else ct.routeWP(false,false,1)end end,function()return true end)nC=60;nD=300;local hH=0;local hI=ae/2-150;nn("Enable Check Damage","Disable Check Damage",nD,nC,hH,hI-nC-20,function()return s end,function()s=not s end)nn("View Settings","View Settings",nD,nC,hH,hI,function()return true end,nz)hI=hI+nC+20;nn("Enable Turn and Burn","Disable Turn and Burn",nD,nC,hH,hI,function()return b5 end,nG)hH=10;hI=ae/2-300;nn("Horizontal Takeoff Mode","Vertical Takeoff Mode",nD,nC,ad/2-nD/2,hI+20,function()return b0 end,function()b0=not b0;if b0 then di("Vertical Takeoff Mode")else di("Horizontal Takeoff Mode")end end,function()return cP end)hI=hI+nC+20;nn("Engage Orbiting","Cancel Orbiting",nD,nC,hH+nD+20,hI,function()return bA end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hI=ae/2-150;nn("Glide Re-Entry","Cancel Glide Re-Entry",nD,nC,hH+nD+20,hI,function()return b9 end,function()cc=1;nH(1)end,function()return kE.hasAtmosphere and not cg end)hI=hI+nC+20;nn("Parachute Re-Entry","Cancel Parachute Re-Entry",nD,nC,hH+nD+20,hI,function()return b9 end,function()cc=2;nH(1)end,function()return kE.hasAtmosphere and not cg end)hI=hI+nC+20;nn("Engage Follow Mode","Disable Follow Mode",nD,nC,hH,hI,function()return c0 end,nO,function()return iH()==1 end)nn("Enable Repair Arrows","Disable Repair Arrows",nD,nC,hH+nD+20,hI,function()return jd end,function()jd=not jd;if jd then di("Repair Arrows Enabled")else di("Repair Arrows Diabled")end end,function()return iH()==1 end)hI=hI+nC+20;if not r then nn("Enable AGG","Disable AGG",nD,nC,hH,hI,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;nn(function()return dk("Switch IPH Mode - Current: %s",bB)end,function()return dk("IPH Mode: %s",bB)end,nD*2,nC,hH,hI,function()return false end,function()if bB=="All"then bB="Custom Only"elseif bB=="Custom Only"then bB="No Moons-Asteroids"else bB="All"end;di("IPH Mode: "..bB)end)hI=hI+nC+20;nn(function()return dk("Toggle Control Scheme - Current: %s",g)end,function()return dk("Control Scheme: %s",g)end,nD*2,nC,hH,hI,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;di("New Control Scheme: "..g)end)local n_=jg(20)local nY=nj(0,0,jf(70),n_,"HELP")nY=nj(nY.x+nY.width,nY.y,jf(80),n_,"INFO")nY=nj(nY.x+nY.width,nY.y,jf(70),n_,"ORBIT")nY=nj(nY.x+nY.width,nY.y,jf(70),n_,"SCOPE")nj(nY.x+nY.width,nY.y,jf(70),n_,"HIDE")end;local o0={}local o1=nil;function o0.HUDPrologue(k1)if not cV then j4=aj;j5=ak;j6=al else j4=ag;j5=ah;j6=ai end;j7=[[rgb(]]..bN(j4+0.6)..","..bN(j5+0.6)..","..bN(j6+0.6)..[[)]]j8=[[rgb(]]..bN(j4*0.8+0.5)..","..bN(j5*0.8+0.5)..","..bN(j6*0.8+0.5)..[[)]]local o2=j7;local o3=j8;local o4=[[rgb(]]..bN(j4*0.4+0.5)..","..bN(j5*0.4+0.5)..","..bN(j6*0.4+0.5)..[[)]]local o5=j7;local o6=j8;local o7=o4;if jh()and not n then o2=[[rgb(]]..bN(j4*0.5+0.5)..","..bN(j5*0.5+0.5)..","..bN(j6*0.5+0.5)..[[)]]o3=[[rgb(]]..bN(j4*0.3+0.5)..","..bN(j5*0.3+0.5)..","..bN(j6*0.2+0.5)..[[)]]o4=[[rgb(]]..bN(j4*0.2+0.5)..","..bN(j5*0.2+0.5)..","..bN(j6*0.2+0.5)..[[)]]end;local lA=jf;local lB=jg;k1[#k1+1]=dk([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o2,o2,o2,o5,o5,o3,o3,o6,o6,o3,o2,o4,o6,o2,o2,o4,o4,o7,o4,ad,ae,o3,o3,o3,o3,o3,o5,o3,o6,o7,o6,o6,o7)if not o1 then o1=dk([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lA(630),lB(0),lA(675),lB(45),lA(960),lB(55),lA(1245),lB(45),lA(1290),lB(0),lA(1000),lB(105),lA(1040),lB(59),lA(1250),lB(51),lA(1300),lB(0),lA(1920),lB(0),lA(1920),lB(20),lA(1400),lB(20),lA(1300),lB(105),lA(920),lB(105),lA(880),lB(59),lA(670),lB(51),lA(620),lB(0),lA(0),lB(0),lA(0),lB(20),lA(520),lB(20),lA(620),lB(105),lA(890),lB(59),lA(960),lB(62),lA(1030),lB(59),lA(985),lB(112),lA(1150),lB(112),lA(1100),lB(152),lA(820),lB(152),lA(780),lB(112),lA(935),lB(112),lA(890),lB(59),lA(960),lB(62),lA(1030),lB(59),lA(985),lB(112),lA(1150),lB(112),lA(1100),lB(152),lA(820),lB(152),lA(780),lB(112),lA(935),lB(112))end;if w and I then k1[#k1+1]=o1 end;return k1 end;function o0.DrawVerticalSpeed(k1,e3)k0(k1,e3)end;function o0.UpdateHud(k1)local kR=cS;local o8=cT;local k8=o8;local ko=kR;local l8=bN(c.getThrottle())local ld=cL*3.6;local l9=c.getAxisCommandValue(0)local o9=jf(1770)local oa=jg(310)if t and cR then l9=bR;l8=bR*100 end;local jj=ji()local k9="ROLL"if l8==nil then l8=0 end;if not cY then if cL>5 then kR=kQ(cJ)o8=kS(cJ)else kR=0;o8=0 end;k9="YAW"end;if cW>50000 and not cg then local ob;ob=iM(cW)k1[#k1+1]=gN(o9,oa,"PvP Boundary: "..ob,"pbright txtbig txtmid")end;k1[#k1+1]=jb;k1[#k1+1]=ig;if i_~=""then k1[#k1+1]=i_ end;if jk~=""then k1[#k1+1]=jk end;if jl~=""then k1[#k1+1]=jl end;k0(k1,ci)if iH()==0 or m then if not jh()or n then if cY then k7(k1,am,an,k8,k9,cY)kn(k1,ko,k8,am,an,cY,bN(kS(cJ)),cL)else k7(k1,am,an,o8,k9,cY)kn(k1,kR,o8,am,an,cY,bN(o8),cL)end;ku(k1,ci,cY)kT(k1,cJ,cL,am,an)end end;l7(k1,jj,l8,l9)lc(k1,ld)lh(k1)lV(k1)if not iY and c1 then lN(k1)end;return k1 end;function o0.HUDEpilogue(k1)k1[#k1+1]="</svg>"return k1 end;function o0.ExtraData(k1)local oc=jf(1240)local od=jg(55)local oe=od+10;local of;local lA=jf;local lB=jg;local og=0;local jj=ji()if b0 then jj=jj.."-VERTICAL"end;if E and gY and not b8 and not b7 and cL>20 then jj=jj.."-COLLISION ON"end;if bD~="Off"then jj="("..bD..")-"..jj end;if b5 then jj="TB-"..jj end;if bI then jj="HOVERMODE-"..jj end;if not bC then jj=jj.."-DeCoupled"end;local oh=lB(99)local oi=lB(80)local oj=lB(85)local ok=lB(31)local ol=0;local om=0;local on=cj>1000000 and fV(cj/1000000,2).."kT"or fV(cj/1000,2).."T"if cg then og=bv else og=bt end;local oo,op=cp.computeDistanceAndTime(cL,0,cj,0,0,og)if oo<0 then oo=0 end;og=fV(og/(cj*iQ),2).."g"local oq=d:maxForceForward()of=b.getGravityIntensity()if of>0.1 then om=cj*of;om=fV(om/(cj*iQ),2).."g"ol=0.5*oq/of;ol=ol>1000000 and fV(ol/1000000,2).."kT"or fV(ol/1000,2).."T"end;oq=fV(oq/(cj*iQ),2).."g"local os=vec3(bP.getWorldAcceleration()):len()/9.80665;of=b.getGravityIntensity()k1[#k1+1]=[[<g class="dim txt txtend size14">]]if iH()==1 and not m then oc=jf(1120)od=jg(55)oe=od+10 elseif cg and I then local ot=jf(770)k1[#k1+1]=gN(lA(895),oh,"ATMO","")k1[#k1+1]=dk([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lA(895),oj,lA(-80))k1[#k1+1]=gN(lA(815),oi,dk("%.1f%%",ch*100),"txtstart size20")end;if I then k1[#k1+1]=gN(lA(1025),oh,"GRAVITY","txtstart")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1025),oj,lA(80))k1[#k1+1]=gN(lA(1105),oi,dk("%.2fg",of/9.80665),"size20")k1[#k1+1]=gN(lA(1125),oh,"ACCEL","txtstart")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1125),oj,lA(80))k1[#k1+1]=gN(lA(1205),oi,dk("%.2fg",os),"size20")k1[#k1+1]=gN(lA(695),oh,"BRK TIME","")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(695),oj,lA(-80))k1[#k1+1]=gN(lA(615),oi,dk("%s",iN(op)),"txtstart size20")k1[#k1+1]=gN(lA(635),lB(45),"TRIP","")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(635),lB(31),lA(-90))if lx then k1[#k1+1]=gN(lA(545),lB(26),dk("%s",iN(lx)),"txtstart size20")end;k1[#k1+1]=gN(lA(795),oh,"BRK DIST","")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(795),oj,lA(-80))k1[#k1+1]=gN(lA(715),oi,dk("%s",iM(oo)),"txtstart size20")k1[#k1+1]=gN(lA(1285),lB(45),"MASS","txtstart")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1285),lB(31),lA(90))k1[#k1+1]=gN(lA(1375),lB(26),dk("%s",on),"size20")k1[#k1+1]=gN(lA(1220),oh,"THRUST","txtstart")k1[#k1+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1220),oj,lA(80))k1[#k1+1]=gN(lA(1300),oi,dk("%s",oq),"size20")k1[#k1+1]=gN(jf(960),jg(175),jj,"pbright txtbig txtmid size20")end;k1[#k1+1]="</g>"end;local ou=1-(a7*0.05+a8*0.05)function o0.FuelUsed(ov)local ow;if ov=="atmofueltank"then ow=dk("Atmo Fuel Used: %.1f L",jC[ov]/(4*ou))elseif ov=="spacefueltank"then ow=dk("Space Fuel Used: %.1f L",jC[ov]/(6*ou))else ow=dk("Rocket Fuel Used: %.1f L",jC[ov]/(0.8*ou))end;return ow end;local ox,oy,oz,oA,oB=0,0,0,{},0;local oC=0;local oD=0;local oE=0;function o0.DrawOdometer(k1,j9,bo,ja)if bK~="INFO"then return k1 end;local of;local og=0;local om=0;local on=cj>1000000 and fV(cj/1000000,2).." kTons"or fV(cj/1000,2).." Tons"if cg then og=bv else og=bt end;local oo,op=cp.computeDistanceAndTime(cL,0,cj,0,0,og)og=fV(og/(cj*iQ),2).." g"local oq=d:maxForceForward()of=b.getGravityIntensity()if cL<5 then local oF=vec3(bP.getOrientationForward())local oG=bP.getMaxThrustAlongAxis('thrust analog longitudinal ',{oF:unpack()})oC=0.5*oG[1]/of;oC=oC>1000000 and fV(oC/1000000,1).." kTons"or fV(oC/1000,1).." Tons"oD=0.5*oG[3]/of;oD=oD>1000000 and fV(oD/1000000,1).." kTons"or fV(oD/1000,1).." Tons"oF=vec3(bP.getOrientationUp())oG=bP.getMaxThrustAlongAxis('hover_engine, booster_engine',{oF:unpack()})oE=0.5*oG[1]/of;oE=oE>1000000 and fV(oE/1000000,1).." kTons"or fV(oE/1000,1).." Tons"end;if of>0.1 then om=cj*of;om=fV(om/(cj*iQ),2).." g"else om="n/a"end;oq=fV(oq/(cj*iQ),2).." g"if iH()==0 or m then local oH=jf(aC+10)local oI=jg(aD+20)local oJ=jf(aC+10+aB/1.25)local nl=25;local oK=bN(1/aU)if oz<oK then oB=oB+a.getActionUpdateDeltaTime()oz=oz+1 else ox=1/(oB/oK)table.insert(oA,ox)oz,oB=0,0 end;oy=0;for dL,dx in pairs(oA)do oy=oy+dx end;if#oA>0 then oy=bN(oy/#oA)end;if#oA>29 then table.remove(oA,1)end;k1[#k1+1]="<g class='txtstart size14 bright'>"k1[#k1+1]=gN(oH,oI,dk("BrkTime: %s",iN(op)))k1[#k1+1]=gN(oJ,oI,dk("Trip: %.2f km",j9))k1[#k1+1]=gN(oH,oI+nl,dk("Lifetime: %.2f kSU",bo/200000))k1[#k1+1]=gN(oJ,oI+nl,dk("BrkDist: %s",iM(oo)))k1[#k1+1]=gN(oH,oI+nl*2,"Trip Time: "..iN(ja))k1[#k1+1]=gN(oJ,oI+nl*2,"Total Time: "..iN(bp))k1[#k1+1]=gN(oH,oI+nl*3,dk("Mass: %s",on))k1[#k1+1]=gN(oJ,oI+nl*3,dk("Max Brake: %s",og))k1[#k1+1]=gN(oH,oI+nl*4,dk("Max Thrust: %s",oq))k1[#k1+1]=gN(oJ,oI+nl*4,dk("Safe Atmo Mass: %s",oC))k1[#k1+1]=gN(oH,oI+nl*5,dk("Req Thrust: %s",om))k1[#k1+1]=gN(oJ,oI+nl*5,dk("Safe Space Mass: %s",oD))k1[#k1+1]=gN(oJ,oI+nl*6,dk("Safe Hover Mass: %s",oE))k1[#k1+1]=gN(oH,oI+nl*6,dk("Influence: %s",kE.name))k1[#k1+1]=gN(oH,oI+nl*7,dk("Set Max Speed: %s",bN(a1*3.6+0.5)))k1[#k1+1]=gN(oJ,oI+nl*7,dk("Actual Max Speed: %s",bN(df*3.6+0.5)))k1[#k1+1]=gN(oH,oI+nl*8,dk("Friction Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))k1[#k1+1]=gN(oJ,oI+nl*8,dk("FPS (Avg): %s (%s)",bN(ox),oy))end;k1[#k1+1]="</g></g>"return k1 end;function o0.DrawWarnings(k1)return lh(k1)end;function o0.DisplayOrbitScreen(k1)return lV(k1)end;function o0.DisplayMessage(k1,ls)if ls~="empty"then local hI=310;for lu in string.gmatch(ls,"([^\n]+)")do hI=hI+35;k1[#k1+1]=gN("50%",hI,lu,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;function o0.DrawDeadZone(k1)k1[#k1+1]=dk([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function o0.UpdatePipe()if cg then i_=""return end;na()end;function o0.DrawSettings(k1)local hH=jf(640)local hI=jg(200)k1[#k1+1]=[[<g class="pbright txtvspd txtstart">]]local hY=0;for dL,dx in pairs(iZ)do hY=hY+1;k1[#k1+1]=gN(hH,hI,dL..": "..dx.get())hI=hI+20;if hY%12==0 then hH=hH+jf(350)hI=jg(200)end end;k1[#k1+1]=gN(jf(640),jg(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")k1[#k1+1]="</g>"return k1 end;local ie=jg(125)local id=jf(1225)function o0.DrawRadarInfo()ig=cu.GetRadarHud(id,ie,ay,az)if ig then gY=true end end;function o0.DrawTanks()if au~=0 and av~=0 then jk=gN(au,av,"","txtstart pdim txtfuel")jD=av;jE(au,"Atmospheric ","ATMO",cl,jA,jB)jE(au,"Space Fuel T","SPACE",cm,jy,jz)jE(au,"Rocket Fuel ","ROCKET",cn,jw,jx)end end;function o0.DrawShield()local ir=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oL=bP.getPvPTimer()local oM=shield.getResistances()local oN="A: "..10+oM[1]*100 .."% / E: "..10+oM[2]*100 .."% / K:"..10+oM[3]*100 .."% / T: "..10+oM[4]*100 .."%"local hH,hI=aw-60,ax+30;local jU=bN(dg*2.55)local jV=dk("rgb(%d,%d,%d)",255-jU,jU,0)local jW=""jl=gN(hH,hI,"","txtmid pdim txtfuel")if dg<10 and ir~="Shield Disabled"then jW="red "end;oL=oL>0 and"   PvPTime: "..iN(oL)or""jl=jl..dk([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hH,hI,jV,dg*2,hH,hI,hH+2,hI+10,dg,oL)jl=jl..gN(hH,hI-5,ir,jW.."txtstart pbright txtbig")jl=jl..gN(hH,hI+30,oN,jW.."txtstart pbright txtsmall")end;function o0.hudtick()if not kE then return end;local function oO(k1)local jY=bN(dl(dd/(ad/4)*255,0,255))k1[#k1+1]=dk("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(j4+0.5)+jY,bN(j5+0.5)-jY,bN(j6+0.5)-jY)end;local function oP()if c2 then for dQ,dx in pairs(iR)do if dx.hovered then if not dx.drawCondition or dx.drawCondition(dx)then dx.toggleFunction(dx)end;dx.hovered=false end end;for dQ,dx in pairs(iU)do if dx.hovered then bK=dx.label;dx.hovered=false end end;c2=false end end;local function oQ()local function oR(oS,oT,hH,hI,nk,nl)if oS>=hH and oS<=hH+nk and oT>=hI and oT<=hI+nl then return true else return false end end;local hH=c9+ad/2;local hI=ca+ae/2;for dQ,dx in pairs(iR)do dx.hovered=oR(hH,hI,dx.x,dx.y,dx.width,dx.height)end;for dQ,dx in pairs(iU)do dx.hovered=oR(hH,hI,dx.x,dx.y,dx.width,dx.height)end;if d0 then local m_=false;for dQ,eD in ipairs(nX)do if eD.hovered then m_=true;break end end;if nU.hovered then m_=true end;d0=m_ else d0=nU.hovered;if not d0 then d1=bm end end end;local function oU(k1)if not bK or bK==""then bK="HELP"end;if w then for dL,dx in pairs(iU)do local jW="dim brightstroke"local oV=0.2;if bK==dL then jW="pbright dimstroke"oV=0.6 end;local oW=""if dx.hovered then oV=0.8;oW=";stroke:white"end;k1[#k1+1]=dk([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dx.width,dx.height,dx.x,dx.y,jW,oV,oW)k1[#k1+1]=gN(dx.x+dx.width/2,dx.y+dx.height/2+5,dx.label,"txt txtmid pdim")end end end;local function oX(k1)local function oY(k1,oZ,hover,hH,hI,fi,o_,p0,p1,p2,p3,nY)if type(p2)=="function"then p2=p2(nY)end;if type(p3)=="function"then p3=p3(nY)end;k1[#k1+1]=dk("<rect x='%f' y='%f' width='%f' height='%f' fill='",hH,hI,fi,o_)if oZ then k1[#k1+1]=dk("%s'",p0)else k1[#k1+1]=p1 end;if hover then k1[#k1+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else k1[#k1+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fV(ag*0.5,0),fV(ah*0.5,0),fV(ai*0.5,0))end;k1[#k1+1]=" rx='5'></rect>"k1[#k1+1]=dk("<text x='%f' y='%f' font-size='24' fill='",hH+fi/2,hI+o_/2+5)if oZ then k1[#k1+1]="black"else k1[#k1+1]="white"end;k1[#k1+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oZ then k1[#k1+1]=dk("%s</text>",p2)else k1[#k1+1]=dk("%s</text>",p3)end end;local p4=dk("rgb(%d,%d,%d)'",fV(ag*0.1,0),fV(ah*0.1,0),fV(ai*0.1,0))local p5=dk("rgb(%d,%d,%d)",fV(ag*0.8,0),fV(ah*0.8,0),fV(ai*0.8,0))local p6=oY;for dQ,dx in pairs(iR)do local np=dx.disableName;local no=dx.enableName;if type(np)=="function"then np=np(dx)end;if type(no)=="function"then no=no(dx)end;if not dx.drawCondition or dx.drawCondition(dx)then p6(k1,dx.toggleVar(dx),dx.hovered,dx.x,dx.y,dx.width,dx.height,p5,p4,np,no,dx)end end end;local p7=fV(ad/2,0)local p8=fV(ae/2,0)local k1={}if p9 then k1[#k1+1]=p9 end;cr.HUDPrologue(k1)if w then cr.UpdateHud(k1)else if A then cr.DrawVerticalSpeed(k1,ci)end;cr.DrawWarnings(k1)end;if iY and iZ~="none"then cr.DrawSettings(k1)end;if cu then cr.DrawRadarInfo()else ig=""end;cr.HUDEpilogue(k1)k1[#k1+1]=dk([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c3~="empty"then cr.DisplayMessage(k1,c3)end;if iH()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(k1)end end;oU(k1)if iJ()==0 then if iH()==1 and c1 then if not pa then oQ()oX(k1)end;if not cx and not cy then local pb=table.concat(k1,"")k1={}k1[#k1+1]=dk("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)k1[#k1+1]=pb;k1[#k1+1]="</body>"cx=true;k1[#k1+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local pb=table.concat(k1,"")k1={}k1[#k1+1]=dk("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)k1[#k1+1]=pb;k1[#k1+1]="</body>"end;if not cx then k1[#k1+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p7,p8,c9,ca)end else oP()end else if not c1 and iH()==0 then oP()if dd>aA then if v then oO(k1)end end elseif c1 and(not pa or not j)then oQ()oX(k1)end;k1[#k1+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p7,p8,c9,ca)end;k1[#k1+1]=[[</svg></body>]]pc=table.concat(k1,"")end;function o0.TenthTick()local function pd()local pe=a.createData;local pf=a.createWidget;pg=a.createWidgetPanel("Interplanetary Helper")ph=pf(pg,"value")pi=pe('{"label": "Target Planet", "value": "N/A", "unit":""}')fT(pi,ph)pj=pf(pg,"value")pk=pe('{"label": "distance", "value": "N/A", "unit":""}')fT(pk,pj)gm=pf(pg,"value")gl=pe('{"label": "Travel Time", "value": "N/A", "unit":""}')fT(gl,gm)gk=pf(pg,"value")gj=pe('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fT(gj,gk)go=pf(pg,"value")gn=pe('{"label": "Target Altitude", "value": "N/A", "unit":""}')fT(gn,go)gg=pf(pg,"value")gf=pe('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ge=pf(pg,"value")gd=pe('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gc=pf(pg,"value")gb=pe('{"label": "Max Brake distance", "value": "N/A", "unit":""}')ga=pf(pg,"value")g9=pe('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gi=pf(pg,"value")gh=pe('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fT(gf,gg)fT(gd,ge)fT(gb,gc)fT(g9,ga)fT(gh,gi)end end;local function pl()gM(pg)pg=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bk~="None"then if pg==nil then pd()end;if bk~=nil then local mB;local pm=g5~=nil;local pn=0.5*bv/c8:getGravity(c8.center+vec3(0,0,1)*c8.radius):len()pn=pn>1000000 and fV(pn/1000000,2).." kTons"or fV(pn/1000,2).." Tons"fS(pi,'{"label": "Target", "value": "'..bk..'", "unit":""}')if pm and not b4 then mB=(cO-g5.position):len()else mB=(bl-cO):len()end;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)j1,j2=ct.GetAutopilotBrakeDistanceAndTime(a1)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)j1,j2=ct.GetAutopilotTBBrakeDistanceAndTime(a1)end;local ls=iM(mB)fS(pk,'{"label": "distance", "value": "'..ls..'"}')fS(gl,'{"label": "Travel Time", "value": "'..iN(lx)..'", "unit":""}')ls=iM(c6)fS(gf,'{"label": "Cur Brake distance", "value": "'..ls..'"}')fS(gd,'{"label": "Cur Brake Time", "value": "'..iN(c7)..'", "unit":""}')ls=iM(j1)fS(gb,'{"label": "Max Brake distance", "value": "'..ls..'"}')fS(g9,'{"label": "Max Brake Time", "value": "'..iN(j2)..'", "unit":""}')fS(gj,'{"label": "Max Brake Mass", "value": "'..dk("%s",pn)..'", "unit":""}')ls=iM(gp)fS(gn,'{"label": "Target Orbit", "value": "'..ls..'"}')if cg and not po then a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)a.removeDataFromWidget(gf,gg)a.removeDataFromWidget(gh,gi)po=true;if not cR and t and(b6 or b9 or ce)then ct.cmdThrottle(1)b1=false;bV=false end end;if not cg and po then if fS(g9,ga)==1 then fT(g9,ga)end;if fS(gb,gc)==1 then fT(gb,gc)end;if fS(gd,ge)==1 then fT(gd,ge)end;if fS(gf,gg)==1 then fT(gf,gg)end;if fS(gh,gi)==1 then fT(gh,gi)end;po=false end end else pl()end;if warpdrive~=nil then local pp=iF(warpdrive.getWidgetData())if pp.destination~="Unknown"and pp.distance>400000 then if not je then warpdrive.showWidget()je=true end elseif je then warpdrive.hideWidget()je=false end end end;function o0.OneSecondTick()local function pq()local jO=bM()local ld=cL;local pr=jO-jc;if ld>1.38889 then ld=ld/1000;local ps=ld*(jO-jc)bo=bo+ps;j9=j9+ps end;ja=ja+pr;bp=bp+pr;jc=jO end;local function pt(k1)local pu=0;local pv=iP;local pw=0;local px=0;local py=0;local jU=0;local jV=""local pz=b.getElementHitPointsById;local pA=b.getElementMaxHitPointsById;local pB={}for dL in pairs(iO)do local pC=0;local pD=0;pD=pA(iO[dL])pC=pz(iO[dL])pw=pw+pC;if pC+1<pD then if pC==0 then py=py+1 else px=px+1 end;if jd and#pB==0 then fX=vec3(b.getElementPositionById(iO[dL]))local hH=fX.x;local hI=fX.y;local hJ=fX.z;table.insert(pB,b.spawnArrowSticker(hH,hI,hJ+1,"down"))table.insert(pB,b.spawnArrowSticker(hH,hI,hJ+1,"down"))b.rotateSticker(pB[2],0,0,90)table.insert(pB,b.spawnArrowSticker(hH+1,hI,hJ,"north"))table.insert(pB,b.spawnArrowSticker(hH+1,hI,hJ,"north"))b.rotateSticker(pB[4],90,90,0)table.insert(pB,b.spawnArrowSticker(hH-1,hI,hJ,"south"))table.insert(pB,b.spawnArrowSticker(hH-1,hI,hJ,"south"))b.rotateSticker(pB[6],90,-90,0)table.insert(pB,b.spawnArrowSticker(hH,hI-1,hJ,"east"))table.insert(pB,b.spawnArrowSticker(hH,hI-1,hJ,"east"))b.rotateSticker(pB[8],90,0,90)table.insert(pB,b.spawnArrowSticker(hH,hI+1,hJ,"west"))table.insert(pB,b.spawnArrowSticker(hH,hI+1,hJ,"west"))b.rotateSticker(pB[10],-90,0,90)table.insert(pB,iO[dL])end elseif jd and#pB>0 and pB[11]==iO[dL]then for jN in pairs(pB)do b.deleteSticker(pB[jN])end;pB={}end end;pu=fV(pw/pv*100,2)if py>0 or px>0 then k1[#k1+1]=gN(0,0,"","pbright txt")jU=bN(pu*2.55)jV=dk("rgb(%d,%d,%d)",255-jU,jU,0)k1[#k1+1]=gN("50%",1035,"Elemental Integrity: "..pu.."%","txtbig txtmid","fill:"..jV)if py>0 then k1[#k1+1]=gN("50%",1055,"Disabled Modules: "..py.." Damaged Modules: "..px,"txtbig txtmid","fill:"..jV)elseif px>0 then k1[#k1+1]=gN("50%",1055,"Damaged Modules: "..px,"txtbig txtmid","fill:"..jV)end end end;local function pE()if iE then if j3==nil and(hl~=nil or bn)then _autoconf.displayCategoryPanel(iE,weapon_size,"Weapons","weapon",true)j3=_autoconf.panels[_autoconf.panels_size]elseif j3~=nil and hl==nil and not bn then gM(j3)j3=nil end end end;local k1={}pq()if s then pt(k1)end;pE()cr.UpdatePipe()cr.ExtraData(k1)jb=table.concat(k1,"")end;function o0.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function o0.MsgTick()local k1={}cr.DisplayMessage(k1,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function o0.ButtonSetup()nA()nF()iR=iS end;if pF then for dL,dx in pairs(pF)do o0[dL]=dx end end;return o0 end;local function pG(d,b,c,e,vBooster,hover,pH,antigrav,dbHud_1,eZ,bN,bO,iH,eU,bM,dl,iI,fS,iJ,dn,fV,fU,iK,dp,iM,iN,pI,iF,di)local a=DUSystem;local bP=DUConstruct;local pJ={}local pK=false;local pL=0;local pM=0;local pN=0;local pO=bM()local pP=0;local pQ=0;local pR=0;local pS=0;local pT=false;local pU=false;local pV=false;local pW=nil;local pX=0;local j0=55;local pY=nil;local pZ=false;local p_=false;local q0=false;local q1=0;local q2=0;local q3=0;local q4=0;local q5=0;local q6={VectorToTarget=false}local q7=vec3(bP.getWorldOrientationUp())local q8=nil;local q9=0;local qa=-1;local qb=-1;local qc=false;local qd=false;local qe=0;local qf=false;local qg=false;local qh=false;local qi=false;local qj=""local qk=false;local ql=false;local qm=""local qn=false;local qo=0;local qp=0;local function qq()return bP.isInPvPZone()~=1,eZ(bP.getDistanceToSafeZone())end;local function qr(fp)local qs=bg;if not b4 then qs=0 end;local qt=bt;if cg then if bv and bv>0 then qt=bv else return 0,0 end end;return cp.computeDistanceAndTime(fp,qs,cj,0,0,qt-bi*cj)end;local function qu(fp)local qs=bg;if not b4 then qs=0 end;return cp.computeDistanceAndTime(fp,qs,cj,d:maxForceForward(),a3,bt-bi*cj)end;local function qv(qw,qx,qy)qx=qx:project_on_plane(qw)qy=qy:project_on_plane(qw)return eU(qx:cross(qy):dot(qw),qx:dot(qy))end;local qz=-1;local qA=-1;local function qB()local function qC()local qD=-1;local qE=-1;if vBooster then qD=vBooster.getDistance()if qD>-1 and qD<0.01 then qD=qz else qz=qD end end;if hover then qE=hover.getDistance()if qE>-1 and qE<0.01 then qE=qA else qA=qE end end;if qD~=-1 and qE~=-1 then if qD<qE then return qD else return qE end elseif qD~=-1 then return qD elseif qE~=-1 then return qE else return-1 end end;local qF=qC()local qG=-1;if antigrav and antigrav.isActive()==1 and not r and cL<j0 then local qH=eZ(ci-antigrav.getBaseAltitude())if qH<50 then return qH end end;if pH then qG=pH.raycast().distance;if qG==0 then qG=-1 end end;if qF~=-1 and qG~=-1 then if qF<qG then return qF else return qG end elseif qF~=-1 then return qF else return qG end end;local function qI(kE,eL,qJ)local function qK(qL,dX)local eR=vec3(dX)if qL.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=qL.systemId},dZ)end;local eS=eR-qL.center;local cb=eS:len()local e3=cb-qL.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=math.deg(e1),longitude=math.deg(e2),altitude=e3,id=qL.id,systemId=qL.systemId},dZ)end;local qM=qK(kE,eL)qM="::pos{"..qM.systemId..","..qM.id..","..qM.latitude..","..qM.longitude..","..qM.altitude.."}"if qJ then return qM else qh=qM;return true end end;local function qN(qO,qP,qQ)local function qR(qO,eu)qO=vec3(qO)eu=vec3(eu):normalize()local dG=qO*eu;return dG.x+dG.y+dG.z end;local qS=0.001;local qT=1;if not cg or not cA or cf~=-1 or cL<j0 then if qQ==nil then qQ=aT end;if qP==nil then qP=qS end;qO=vec3(qO):normalize()local qU=vec3()-qO;local qV=-qR(qU,bP.getWorldOrientationRight())*qT;local qW=-qR(qU,bP.getWorldOrientationUp())*qT;if pM==0 then pM=qV/2 end;if pN==0 then pN=qW/2 end;if eZ(qV)<0.1 then q2=q2-qV*2 else q2=q2-(qV+(qV-pM)*qQ)end;if eZ(qW)<0.1 then q1=q1+qW*2 else q1=q1+qW+(qW-pN)*qQ end;pM=qV;pN=qW;if eZ(qV)<qP and eZ(qW)<qP then return true end;return false elseif cA and cf==-1 then qO=cK;if qQ==nil then qQ=aT end;if qP==nil then qP=qS end;qO=vec3(qO):normalize()local qU=cH-qO;local qV=-qR(qU,bP.getWorldOrientationRight())*qT;local qW=-qR(qU,bP.getWorldOrientationUp())*qT;if pM==0 then pM=qV/2 end;if pN==0 then pN=qW/2 end;if eZ(qV)<0.1 then q2=q2-qV*5 else q2=q2-(qV+(qV-pM)*qQ)end;if eZ(qW)<0.1 then q1=q1+qW*5 else q1=q1+qW+(qW-pN)*qQ end;pM=qV;pN=qW;if eZ(qV)<qP and eZ(qW)<qP then return true end;return false end end;function pJ.clearAll()bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"b2=false;b3=false;cX=nil;b6=false;b9=false;b7=false;b8=false;ba=false;c0=false;p_=false;cc=false;cd=false;q0=false;cz=q;br=false;b5=false;ck=false;bu=nil;bA=false;db=false;dc=nil;ce=false end;function pJ.GetAutopilotBrakeDistanceAndTime(fp)return qr(fp)end;function pJ.GetAutopilotTBBrakeDistanceAndTime(fp)return qu(fp)end;function pJ.showWayPoint(kE,eL,qJ)return qI(kE,eL,qJ)end;function pJ.APTick()local qX=a.getMouseWheel()if qX>0 then ct.changeSpd()elseif qX<0 then ct.changeSpd(true)else pZ=true end;qe=iJ()if qh then a.setWaypoint(qh)qh=false end;if qk then antigrav.setTargetAltitude(qk)qk=false end;if qi then fS(qi,qj)qi=false;qj=""end;if qb~=-1 then ct.cmdCruise(qb,qc)qc=false;qb=-1 end;if q8~=nil then if iI:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iI:getTargetSpeed(axisCommandId.longitudinal)~=q8 then iI:setTargetSpeedCommand(axisCommandId.longitudinal,q8)else q8=nil end end;if qa~=-1 then ct.cmdThrottle(qa,qc)qc=false;qa=-1 end;if qd then cv.landingGear(qd)qd=false end;if ql then ct.ToggleAutopilot()end end;function pJ.ToggleIntoOrbit()cE=false;pR=nil;pS=nil;pX=0;if not cg then if bA then fU("orOff","AP")bA=false;pT=false;pW=nil;cz=q;if b6 then b6=false;b8=false end;q6.VectorToTarget=false;q6.AutopilotAlign=false;pV=false elseif cY then fU("orOn","AP")bA=true;cz=true;if pW==nil then pW=kE end;if b6 then b6=false;b8=false end else di("Unable to engage auto-orbit, not near a planet")end else bA=false;pT=false;pW=nil;cz=q;if b6 then b6=false end;q6.VectorToTarget=false;q6.AutopilotAlign=false;pV=false end end;function pJ.ToggleVerticalTakeoff()b6=false;if ba then qY=true;b9=false;b8=false;b7=true;cz=true;b_=0;if cg and cf==-1 then b7=false;b6=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qb=bN(cB)end else cE=false;bn=false;d.control.retractLandingGears()iI:setTargetGroundAltitude(Z)b1="VTO Takeoff"end;ba=not ba end;function pJ.checkLOS(qO)local lv,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,qO,function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local lw=eJ;if eK~=nil and eJ~=nil then lw=math.min(eK,eJ)end;if lw~=nil then return lv,lw else return nil,nil end end;local function qZ(q_,r0)if r0 then b_=0;iI:updateCommandFromActionStop(axisCommandId.vertical,r0)if bC then iI:activateGroundEngineAltitudeStabilization(r1)de=true end else b_=b_+q_;iI:deactivateGroundEngineAltitudeStabilization()iI:updateCommandFromActionStart(axisCommandId.vertical,q_)end end;function pJ.vertical(q_,r0)qZ(q_,r0)end;function pJ.ToggleAutopilot()local function r2(by)cZ=false;br=not br;if br then b5=false;if not b6 and not by then ct.ToggleAltitudeHold()end end;lz="Proceeding to Waypoint"end;local function r3(gy)if gy then for M,dL in pairs(cU)do if dL.name and dL.name==gy then return M end end else return 0 end end;local r4=false;bI=false;if bQ-pQ<1.5 and cg then if not cG then if cg then bb=kE.spaceEngineMinAltitude-0.01*kE.noAtmosphericDensityAltitude;fU("11","EP")pQ=-1;if b4 or br or bA then return end else di("No space engines detected, Orbital Hop not supported")return end elseif kE.hasAtmosphere then if cg then bb=kE.noAtmosphericDensityAltitude+V;fU("orH","OH")end;pQ=-1;if b4 or br or bA then return end end else pQ=bQ end;r5=false;if(bm>0 or#bG>0)and not b4 and not br and not cd and not bA then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then di="WARNING: Heavy Loads may affect autopilot performance."c4=5 end;if#bG>0 and not ce then bm=r3(bG[1])cs.UpdateAutopilotTarget()di("Route Autopilot in Progress")local qU=g5.position-cO;local r6=qU:project_on_plane(cM):len()if r6>50000 and g5.planetname==kE.name then r4=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c8,bl)if g5~=nil then if g5.agg and not r and antigrav then if not cQ then ct.ToggleAntigrav()end;bw=g5.agg end;bu=nil;by=g5.planetname=="Space"if by then fU("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end elseif kE.name==g5.planetname then qY=true;if cg then if not br then fU("vtt","AP")r2(by)if r4 then bb=kE.noAtmosphericDensityAltitude+V end end else fU("apOn","AP")if not(c8.name==kE.name and ci<gp*1.5)then cE=false;b4=true elseif not cg then if bA then ct.ToggleIntoOrbit()end;cD=kE.noAtmosphericDensityAltitude+V;pV=true;q6.AutopilotAlign=true;q6.VectorToTarget=true;pT=false;if not bA then ct.ToggleIntoOrbit()end end end else fU("apP","AP")b2=false;b3=false;if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end end elseif not cg then if g5==nil and(c8.name==kE.name and cY)and not bA then r7=false;cE=false;pT=false;ct.ToggleIntoOrbit()else fU("apP","AP")b4=true;b2=false;b3=false;bd=false;c0=false;b6=false;b7=false;b9=false;b8=false;p_=false;bu=nil;r7=false end else fU("apP","AP")cd=true;ct.ToggleAltitudeHold()end;ql=false else fU("apOff","AP")ct.ResetAutopilots(1)if ql==2 then ql=true end end end;function pJ.routeWP(r8,r9,ra)if ra then if ra==1 then bG={}bG=iK(bG,bF)if#bG>0 then di("Route Loaded")else di("No Saved Route found on Databank")end;return bG else bF={}bF=iK(bF,bG)di("Route Saved")pI()return end end;if r8 then return bG end;if r9 then bG={}di("Current Route Cleared")else bG[#bG+1]=g5.name;di("Added "..g5.name.." to route. ")end;return bG end;function pJ.cmdThrottle(dM,rb)if iI:getAxisCommandType(0)~=axisCommandType.byThrottle and not rb then d.control.cancelCurrentControlMasterMode()end;iI:setThrottleCommand(axisCommandId.longitudinal,dM)bR=dl(fV(dM*100,0)/100,-1,1)q8=nil end;function pJ.cmdCruise(dM,rb)if iI:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rb then d.control.cancelCurrentControlMasterMode()end;iI:setTargetSpeedCommand(axisCommandId.longitudinal,dM)q8=dM end;function pJ.ToggleLockPitch()if bu==nil then fU("lkPOn","LP")if not c1 then bu=cS else bu=S end;b8=false;b6=false;b7=false else fU("lkPOff","LP")bu=nil end end;function pJ.ToggleAltitudeHold()if bQ-pP<1.5 then bI=false;if kE.hasAtmosphere then if cg then bb=kE.spaceEngineMinAltitude-0.01*kE.noAtmosphericDensityAltitude;fU("11","EP")else if cY then bb=kE.noAtmosphericDensityAltitude+V;cD=bb;pV=true;if not bA then ct.ToggleIntoOrbit()end;pT=true end end;pP=-1;if b6 or bA or ba then return end end else pP=bQ end;if cY and not cg and cf==-1 then cD=ci;pV=true;pT=true;ct.ToggleIntoOrbit()if bA then pP=bQ else pP=0 end;return end;b6=not b6;b7=false;b9=false;if b6 then b4=false;b3=false;b2=false;c0=false;cz=true;bu=nil;cE=false;if cf~=-1 then if not bn and not br then bb=ci;bI=cf;iI:setTargetGroundAltitude(bI)elseif cL<20 then if bn then cv.landingGear()end;fU("lfs","LS")b8=true;if cg then bb=ci+Y else bb=kE.surfaceMaxAltitude+100 end;b1="ATO Hold"iI:setTargetGroundAltitude(Z)if b0 and cP then ct.ToggleVerticalTakeoff()end end else fU("altOn","AH")b8=false;if pP>-1 then if cY then bb=ci end end;if ba then ct.ToggleVerticalTakeoff()end end;if cQ and not r then local rc=antigrav.getBaseAltitude()if br and g5.agg and g5.agg>ci then bb=g5.agg elseif b8 then bb=rc end;if eZ(ci-rc)<100 and cL<20 then bb=rc;b1="AGG Hold"qa=0 end end;if cd then bb=200000 end else fU("altOff","AH")if bA then ct.ToggleIntoOrbit()end;if ba then ct.ToggleVerticalTakeoff()end;cz=q;b8=false;br=false;pP=0;bI=false end end;function pJ.ResetAutopilots(pJ)if pJ then cd=false;b4=false;bd=false;p_=false;bb=ci;r5=false;db=false;bh="Aligning"end;br=false;b8=false;b9=false;b3=false;b7=false;dc=nil;rd=false;cX=nil;db=false;if not cQ then b6=false;bu=nil end;if ba then ct.ToggleVerticalTakeoff()end;if bA then ct.ToggleIntoOrbit()end;cz=q;cc=false;ce=false;b_=0 end;function pJ.BrakeToggle(re)if not b1 then if re then b1=re else b1=true end else b1=false end;if b7 then b7=false;cz=q;db=false end;if b1 then fU("bkOn","B",1)ct.ResetAutopilots()else fU("bkOff","B",1)end end;function pJ.BeginReentry()if b9 then di("Re-Entry cancelled")fU("reOff","RE")b9=false;cz=q;b6=false elseif not kE.hasAtmosphere then di("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c4=5 elseif not q0 then b9=true;if iI:getAxisCommandType(0)~=rf.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b1=false;di("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB)fU("par","RE")else b9=true;b6=true;cz=true;b1=false;bb=kE.surfaceMaxAltitude+a0;if bb>kE.spaceEngineMinAltitude then bb=kE.spaceEngineMinAltitude-0.01*kE.noAtmosphericDensityAltitude end;local rg=iM(bb)di("Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..rg)fU("glide","RE")qb=bN(cB)end;b8=false end;function pJ.ToggleAntigrav()if antigrav and not r then if cQ then fU("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bw==nil then bw=ci end;if bw<1000 then bw=1000 end;fU("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pJ.changeSpd(rh)local ri=1;if rh then ri=-1 end;if not c1 then if t and not pa and pZ then local rj=bR;bR=fV(dl(bR+ri*aF/100,-1,1),2)if bR>=0 and rj<0 then bR=0;pZ=false end elseif pa then if cg or b9 then cB=dl(cB+ri*aF,0,W)elseif b4 then a1=dl(a1+ri*aF/3.6*100,0,df-0.2)end else iI:updateCommandFromActionStart(axisCommandId.longitudinal,ri*aF/10)end else if b4 or br or cd or bA then d1=d1+1*ri*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not rh then ri=1 else ri=nil end;cs.adjustAutopilotTargetIndex(ri)end end end;function pJ.TenthTick()local function rk()if not b4 then if g5==nil or g5.planetname~=kE.name then rl=(c8.center-cO):len()else rl=(g5.position-cO):len()end end;local fp=cL;local rm=c.getThrottle()/100;if t then rm=bR end;local rn,ro=cp.computeDistanceAndTime(cL,a1,cj,d:maxForceForward()*rm,a3,0)local c6,c7;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(a1)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dQ,rp;if not b5 and fp>0 then dQ,rp=ct.GetAutopilotBrakeDistanceAndTime(fp)else dQ,rp=ct.GetAutopilotTBBrakeDistanceAndTime(fp)end;local rq=0;local rr=0;if bf or not b4 and fp>5 then rr=cp.computeTravelTime(fp,0,rl)elseif c6+rn<rl then rq=rl-(c6+rn)rr=cp.computeTravelTime(a1,0,rq)else local rs=(rl-c6)/rn;rn=rl-c6;ro=ro*rs end;if g5~=nil and g5.planetname==kE.name and not b4 then return rr elseif be then return rp elseif bf then return rr+rp else return ro+c7+rr end end;local function rt(of,ru)if of==nil then of=b.getGravityIntensity()end;of=fV(of,5)if ru~=nil and ru or(pY==nil or pY~=of)then local fp=cJ:len()local rv=bP.getMaxBrake()if rv~=nil and rv>0 and cg then rv=rv/dl(fp/100,0.1,1)rv=rv/ch;if ch>0.10 then if bv then bv=(bv+rv)/2 else bv=rv end end end;if rv~=nil and rv>0 then bt=rv end;pY=of end end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()qp=0;for M=1,#d3 do qp=qp+bP.getDockedConstructMass(d3[M])end;local rw=0;for M=1,#d2 do rw=rw+bP.getBoardedPlayerMass(d2[M])end;if rw>20000 then qp=qp+rw-20000 end;cV,cW=qq()df=bP.getMaxSpeed()if bk~="None"and(c8 or g5)then lx=rk()end;rt(nil,true)end;local function rx(ry,rz)local oF=vec3()local rA=vec3()if ry==axisCommandId.longitudinal then oF=vec3(bP.getOrientationForward())rA=cH elseif ry==axisCommandId.vertical then oF=vec3(bP.getOrientationUp())rA=q7 elseif ry==axisCommandId.lateral then oF=vec3(bP.getOrientationRight())rA=cI else return vec3()end;local rB=vec3(b.getWorldGravity())local rC=rB:dot(rA)local rD=vec3(bP.getWorldAirFrictionAcceleration())local rE=rD:dot(rA)local rF=cJ:dot(oF)local rG=rz*constants.kph2m;if rH==nil then rH=pid.new(10,0,10.0)end;rH:inject(rG-rF)local rI=rH:get()local rJ=(rI-rE-rC)*rA;return rJ end;local function rK(ry,rz)local oF=vec3()local rA=vec3()if ry==axisCommandId.longitudinal then oF=vec3(bP.getOrientationForward())rA=cH elseif ry==axisCommandId.vertical then oF=vec3(bP.getOrientationUp())rA=q7 elseif ry==axisCommandId.lateral then oF=vec3(bP.getOrientationRight())rA=cI else return vec3()end;local rB=vec3(b.getWorldGravity())local rC=rB:dot(rA)local rD=vec3(bP.getWorldAirFrictionAcceleration())local rE=rD:dot(rA)local rF=cJ:dot(oF)local rG=rz*constants.kph2m;if rL==nil then rL=pid.new(10,0,10.0)end;rL:inject(rG-rF)local rI=rL:get()local rJ=(rI-rE-rC)*rA;return rJ end;local function rM(rN,k4,g1)local rO=rN:cross(g1):normalize_inplace()local kR=math.acos(dl(rO:dot(-k4),-1,1))*constants.rad2deg;if rO:cross(-k4):dot(g1)<0 then kR=-kR end;return kR end;local function rP()if c_ and not b7 then local es=c_[1]local i4,i5=c_[2],c_[3]local rQ=math.min(i4,i5 or i4)local rR=rQ/cL;local rS=b8 and(cL<42 or cf~=-1)local rT=b6 or br or bu or b4;if rT and not rS and(c6*1.5>rQ or rR<1)then b1="Collision"bG={}qa=0;if b6 then ct.ToggleAltitudeHold()end;if bu then ct.ToggleLockPitch()end;di("Autopilot Cancelled due to possible collision")a.print(es.name.." COLLISION "..iN(rR).." / "..iM(rQ,2))ct.ResetAutopilots(1)qY=true;if cg then b7=true end;cz=true end;if rR<11 then cZ=es.name.." COLLISION "..iN(rR).." / "..iM(rQ,2)else cZ=es.name.." collision "..iN(rR)end;if rR<6 then fU("alarm","AL",2)end else cZ=false end end;local rU=1;local rV=0;local rW=1;local rX=1;local rY=1;local rZ=false;function pJ.onFlush()if antigrav and not r and not cQ and antigrav.getBaseAltitude()~=bw then qk=bw end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iI:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local r_=dl(bX+q1+a.getControlDeviceForwardInput(),-1,1)local s0=dl(bY+q3+a.getControlDeviceYawInput(),-1,1)local s1=dl(bZ+q2-a.getControlDeviceLeftRightInput(),-1,1)local s2=b1 and 1 or 0;cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(kE.center-cO):normalize()end;q7=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()+qp;cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local s3=cT/180*math.pi;local s4=math.cos(s3)local s5=math.sin(s3)cS=rM(cM,cH,cI*s4+q7*s5)local s6=cK:normalize()local s7=eZ(cT)local s8=utils.sign(cT)local s9=vec3(bP.getWorldAngularVelocity())local sa=r_*aP*cI+s0*aK*cH+s1*aQ*q7;if cz==true and cM:len()>0.01 then local sb=eZ(q4-cT)if((b3 or b9 or b7 or cc or b6 or bA)and sb>0 or cg and sb<aL and q)and s0==0 and eZ(cS)<85 then local sc=q4;local sd=aJ;if not cg then sd=sd/4;q4=0;sc=0 end;if se==nil then se=pid.new(sd*0.01,0,sd*0.1)end;se:inject(sc-cT)local sf=se:get()sa=sa+sf*cH end end;bS=0;ch=bO()cg=false or ci<kE.noAtmosphericDensityAltitude and ch>0.00001;ci=b.getAltitude()cf=qB()bQ=bM()pO=bQ;if bn and cf>-1 and cf-3<_ then if iI.targetGroundAltitudeActivated then iI:deactivateGroundEngineAltitudeStabilization()end end;if cu then qn=not qn;if qn then cu.UpdateRadar()end;if E then rP()end end;if antigrav then cQ=antigrav.isActive()==1 end;local sg=bQ-pO;local sh=-math.deg(qv(q7,cK,cH))local si=math.deg(qv(cI,cK,cH))local gr=cM*-1;cA=cg and sh<-N or sh>N or si<-O or si>O;local sj=a.getMouseDeltaX()local sk=a.getMouseDeltaY()if qo then local sl=bM()-qo;sj=sj*sl/0.016;sk=sk*sl/0.016 end;qo=bM()if p and not c1 then sk=-sk end;q2=0;q3=0;q1=0;local sm=bP.getWorldPosition()kE=fY:closestBody(sm)sn=cq(kE)ft=sn:orbitalParameters(sm,cK)if ci==0 then ci=(cO-kE.center):len()-kE.radius end;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local of=kE:getGravity(sm):len()*cj;q4=0;local so=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if qe==0 then if iH()==1 and c1 then if not cx then c9=dl(c9+sj/2,-ad/2,ad/2)ca=dl(ca+sk/2,-ae/2,ae/2)end else c9=0;ca=0 end else c9=dl(c9+sj/2,-ad/2,ad/2)ca=dl(ca+sk/2,-ae/2,ae/2)dd=dn(c9*c9+ca*ca)if not c1 and iH()==0 then local k_,l0=1,1;if bK=="SCOPE"then k_,l0=d5/90,d5/90 end;if g=="virtual joystick"then if dd>aA then q2=q2-dl(eZ(c9)-aA,0,ad/2)*utils.sign(c9)*aH*k_;q1=q1-dl(eZ(ca)-aA,0,ae/2)*utils.sign(ca)*aI*l0 end else c9=0;ca=0;if g=="mouse"then q1=(-utils.smoothstep(sk,-100,100)+0.5)*2*rX;q2=(-utils.smoothstep(sj,-100,100)+0.5)*2*rY end end end end;local sp=cL>27777;if cL>X/3.6 and not cg and not b4 and not sp then di("Space Speed Engine Shutoff reached")qa=0 end;if not sp and sq then if not b1 then ct.BrakeToggle()end;if b4 then ct.ResetAutopilots(1)end;qa=0 end;sq=sp;if ch>0.09 then if cL>cB/3.6 and not t and not pK then b1="SpdLmt"pK=true elseif not t and pK then if cL<cB/3.6 then b1=false;pK=false end end end;if b3 then if cc then b1=false;local sr=false;sr=qN(g5.position-cO,0.1)cz=true;if sr then qb=bN(cB)if(eZ(cT)<2 or eZ(cS)>85)and cL>=cB/3.6-1 then b1=false;b3=false;if cc~=2 then q0=true end;if cc==true then ce=true end;cc=false;b4=false;ct.BeginReentry()end elseif cg and t then qa=1 end elseif cL>j0 then qN(vec3(cK),0.01)end end;if b2 then if cg then b2=false elseif cL>j0 then qN(-vec3(cK))end end;if not b3 and cc and not bA then if not cg then if cc~=2 then q0=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not ql then ql=true end end end;if ce and g5 and(ci<bb+250 and ci>bb-250)and cL*3.6>cB-250 and eZ(cN)<25 and ch>=0.1 and(g5.position-cO):len()>2000+ci then if not ql then ql=true end;ce=false end;if ba then cz=true;local ss=bb;if cN<-30 then di("Unable to achieve lift. Safety Landing.")b_=0;cz=q;ba=false;b7=true elseif not r and cQ or bb<kE.spaceEngineMinAltitude then if cQ then ss=antigrav.getBaseAltitude()end;if ci<ss-100 then q5=0;b_=15;b1=false elseif cN>0 then b1="VTO Limit"b_=0 elseif cN<-30 then b1="VTO Fall"b_=15 elseif ci>=ss then if cQ then if b4 or br then ct.ToggleVerticalTakeoff()else b1="VTO Complete"ba=false end;di("Takeoff complete. Singularity engaged")fU("aggLk","AG")else b1=false;di("VTO complete. Engaging Horizontal Flight")fU("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then q5=0;b1=false;b_=20 elseif ch<0.08 and cg then b1=false;if cF then q5=0;b_=20 else b_=0;q5=36;qb=3500 end else cz=q;bA=true;cE=false;st=false;pT=false;pR=nil;pS=nil;if pW==nil then pW=kE end;cD=ss;pV=true;ba=false end end;if q5~=nil then if su==nil then su=pid.new(2*0.01,0,2*0.1)end;local sv=dl(q5-cS,-O*0.80,O*0.80)su:inject(sv)local sw=dl(su:get(),-1,1)q1=sw end end;if bA then local function sx()if ft.periapsis.altitude>=cD*0.99 and ft.apoapsis.altitude>=cD*0.99 and ft.periapsis.altitude<ft.apoapsis.altitude and ft.periapsis.altitude*1.05>=ft.apoapsis.altitude and eZ(cD-ci)<1000 then return true else return false end end;local qU;local sy=false;local sz=iM(cD,3)if pW==nil then pW=kE;if br then pW=c8 end end;if not pV then cD=bN(pW.radius+pW.surfaceMaxAltitude+V)if pW.hasAtmosphere then cD=bN(pW.radius+pW.noAtmosphericDensityAltitude+V)end;pV=true end;if q6.VectorToTarget and g5 then qU=g5.position-cO end;local sA,sB=cq(pW):escapeAndOrbitalSpeed((cO-pW.center):len()-pW.radius)local sC=cT;if not pT then local sD=false;local sE=false;qa=0;pS=0;cC="Aligning to orbital path - OrbitHeight: "..sz;if q6.VectorToTarget then qN(qU:normalize():project_on_plane(cM))sy=cH:dot(qU:project_on_plane(q7):normalize())>0.95 else qN(cK)sy=sh<0.5;if cL<150 then sy=true end end;q1=0;pR=0;if cS<=pR+2 and cS>=pR-2 then sD=true else sD=false end;if sC<=pS+2 and sC>=pS-2 then sE=true else sE=false end;if sD and sE and sy then pR=nil;pS=nil;pT=true end else if q6.VectorToTarget then qN(qU:normalize():project_on_plane(cM))elseif cL>150 then qN(cK)end;q1=0;if q6.VectorToTarget and g5 then local c6,dQ=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bt)if cE and qU:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pW.noAtmosphericDensityAltitude or lx>ft.timeToPeriapsis and ft.periapsis.altitude<pW.noAtmosphericDensityAltitude or not sx()and ft.eccentricity>0.1 then di("Re-Aligning Orbit")cE=false end elseif cE or qU:len()<15000+c6+ci then di("Orbit complete, proceeding with reentry")fU("orCom","OB")bl=g5.position;q0=true;ce=true;q6.VectorToTarget,q6.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if ft.periapsis~=nil and ft.apoapsis~=nil and ft.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if ft.apoapsis~=nil then if(sx()or cE)and not K then if cE then b1=false;qa=0;pR=0;if not q6.VectorToTarget then di("Orbit complete")fU("orCom","OB")ct.ToggleIntoOrbit()end else pX=pX+1;if pX>=2 then cE=true end end else if sx()then cC="Maintaining "else cC="Adjusting "pU=true;qb=sB*3.6+1;local sF=cD-ci;if sG==nil then sG=pid.new(0.1,0,1*0.1)end;sG:inject(sF-cN*dl(utils.smoothstep(2000-sF,-2000,2000)^6*10,1,10))pR=dl(sG:get(),-60,60)end;cC=cC.." - OrbitHeight: "..sz end end else local sH=2.75;local sI=eZ(fV(sA*sH))local ou=sI%50;if ou>0 then sI=sI-ou+50 end;b1=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sz;pR=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sz;sI=sI*0.75;pR=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sz;sI=sI*0.75;if cN<0 or pU then pR=utils.map(ci,cD*1.5,cD*1.01,-30,0)else pR=utils.map(ci,cD*0.99,cD*1.5,0,30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sz;pR=-65;local sJ=utils.map(cN,-150,-400,1,0.55)sI=sI*sJ end;qb=bN(sI)end end;if pR~=nil then if sK==nil then sK=pid.new(1*0.01,0,5*0.1)end;local sL=pR-cS;sK:inject(sL)local sM=dl(sK:get(),-0.5,0.5)q1=sM end end;if b4 and not cg and not cc then local function sN(sO,ft)a.print(sO)b3=false;b1=false;be=false;b4=false;r5=false;bh="Aligning"qa=0;p_=false;di(sO)fU("apCom","AP")if ft or cc then if ft and gp~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pV=true end;ct.ToggleIntoOrbit()end end;local sP,sQ=bl,false;if g5 and g5.planetname~="Space"then bd=true;if not r5 then local sR=(g5.position-c8.center):normalize()local sS=sR:project_on_plane((c8.center-cO):normalize()):normalize()local sT=c8.center+sS*(c8.radius+gp)local sU=g5.position+(g5.position-c8.center):normalize()*(gp-c8:getAltitude(g5.position))if(cO-sT):len()<(cO-sU):len()then sP=sT else sP=sU;bg=0 end;bl=sP;ct.showWayPoint(c8,bl)sQ=true;r5=true end;bi=0 elseif g5 and g5.planetname=="Space"then if not r5 then bi=0;sQ=true;bd=true;r5=true;sP=g5.position+(cO-g5.position):normalize()*T;bl=sP end elseif g5==nil then bi=0;if not r5 then local sR=(cO+cK*100000-c8.center):normalize()local sS=sR:project_on_plane((c8.center-cO):normalize()):normalize()if sS:len()<1 then sR=(cO+cH*100000-c8.center):normalize()sS=sR:project_on_plane((c8.center-cO):normalize()):normalize()end;sP=c8.center+sS*(c8.radius+gp)bl=sP;r5=true;sQ=true;bd=true;ct.showWayPoint(c8,bl)end end;rl=(vec3(sP)-cO):len()local lv,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local lw=eJ;if eK~=nil and eJ~=nil then lw=math.min(eK,eJ)end;if lw~=nil and lw<rl and lv.name==c8.name then rl=lw end;local sr=true;local sV=(c8.center-(cO+vec3(cK):normalize()*rl)):len()-c8.radius;local ls=iM(sV)qi=gh;qj='{"label": "Projected Altitude", "value": "'..ls..'"}'if cL>50 and bc then local qU=vec3(sP)-cO;local sW=dl(math.deg(qv(q7,cK:normalize(),qU:normalize()))*cL/500,-90,90)local sX=dl(math.deg(qv(cI,cK:normalize(),qU:normalize()))*cL/500,-90,90)if eZ(sW)<20 and eZ(sX)<20 then sW=sW*2;sX=sX*2 end;if eZ(sW)<2 and eZ(sX)<2 then sW=sW*2;sX=sX*2 end;local sh=-math.deg(qv(q7,cH,cK:normalize()))local si=-math.deg(qv(cI,cH,cK:normalize()))if sY==nil then sY=pid.new(2*0.01,0,2*0.1)end;sY:inject(sX-si)local sZ=dl(sY:get(),-1,1)q1=q1+sZ;if s_==nil then s_=pid.new(2*0.01,0,2*0.1)end;s_:inject(sW-sh)local t0=dl(s_:get(),-1,1)q2=q2+t0;sQ=true;if eZ(sW)>2 or eZ(sX)>2 then if bh~="Adjusting Trajectory"then bh="Adjusting Trajectory"fU("apAdj","AP")end else if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end end elseif bc and cL<=50 then qN((sP-cO):normalize())end;if sV<gp*1.5 then bg=cB/3.6;if g5==nil then dQ,bg=cq(c8):escapeAndOrbitalSpeed(sV)end end;local c6,c7;if not b5 then c6,c7=qr(cL)else c6,c7=qu(cL)end;if b4 and not bc and not bf and not be then local lv,lw=ct.checkLOS((bl-cO):normalize())if c8.name~=kE.name then if lv~=nil and c8.name~=lv.name and lw<rl then cZ="Collision with "..lv.name.." Clear LOS to continue."qf=true else qf=false;cZ=false end end end;if not qf then if not bf and not be and not sQ then sr=qN((sP-cO):normalize())elseif b5 and(be or bf)then sr=qN(-vec3(cK):normalize())end end;if bc then if not p_ then b1=false;qa=a2;bR=fV(a2,2)p_=true end;local rm=c.getThrottle()if t then rm=bR end;local t1=99999;local os=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local t2=dl(cK:dot((sP-cO):normalize()),0,cL)if t2>0 or os>0 then t1=cp.computeTravelTime(t2,os,rl-c6)end;if a1>df then a1=df-0.2 end;if cJ:len()>=a1 or rm==0 and p_ or a3/4>t1 then bc=false;if bh~="Cruising"then fU("apCru","AP")bh="Cruising"end;bf=true;qa=0 end;local t3=rl;if t3<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pL and cW>2000 then ct.ResetAutopilots(1)di("Autopilot cancelled to prevent crossing PvP Line")b1="PvP Prevent"pL=cW else pL=cW;return end end;bc=false;if bh~="Braking"then fU("apBrk","AP")bh="Braking"end;be=true;if not b5 then b3=true;cz=true end;qa=0;p_=false end elseif be then if bh~="Orbiting to Target"then b1="AP Brk"end;if b5 then qa=1;qc=true end;local dQ,sB=cq(c8):escapeAndOrbitalSpeed((cO-kE.center):len()-kE.radius)local qU;if g5 then qU=g5.position-cO end;if g5 and g5.planetname=="Space"and cL<50 then if#bG>0 then if not ql then table.remove(bG,1)end;if#bG>0 then b1=false;if not ql then ql=2 end;return end end;sN("Autopilot complete, arrived at space location")b1="Space Arrival"elseif g5 and g5.planetname~="Space"and cL<=sB and(ft.apoapsis==nil or ft.periapsis==nil or ft.apoapsis.altitude<=0 or ft.periapsis.altitude<=0)then sN("Autopilot complete, commencing reentry")bl=g5.position;cc=true;ct.showWayPoint(c8,bl)elseif(g5 and g5.planetname~="Space"or g5==nil)and ft.periapsis~=nil and ft.periapsis.altitude>0 and ft.eccentricity<1 or bh=="Circularizing"then if bh~="Circularizing"then fU("apCir","AP")bh="Circularizing"end;if cL<=sB then if g5 then if cK:normalize():dot(qU:normalize())>0.4 then if bh~="Orbiting to Target"then fU("apOrb","OB")bh="Orbiting to Target"end;if not r7 then b1=false;ct.showWayPoint(c8,g5.position)r7=true end else sN("Autopilot complete, proceeding with reentry")bl=g5.position;cc=true;ct.showWayPoint(c8,g5.position)r7=false end else sN("Autopilot completed, setting orbit",true)b1=false end end elseif bh=="Circularizing"then sN("Autopilot complete, fixing Orbit",true)end elseif bf then local t3=rl;if t3<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pL and cW>2000 then if not ql then ql=true end;di("Autopilot cancelled to prevent crossing PvP Line")b1="Prevent PvP"pL=cW else pL=cW;return end end;bc=false;if bh~="Braking"then fU("apBrk","AP")bh="Braking"end;be=true;if not b5 then b3=true;cz=true end end;local rm=c.getThrottle()if t then rm=bR end;if rm>0 then bc=true;if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end;bf=false end else if sr then if not bd and g5==nil or not bd and g5 and g5.planetname~="Space"then if not cc then bl=vec3(c8.center)+(gp+c8.radius)*cI;t4=q7;t5=cI end;bd=true elseif sr and not qf then bc=true;if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end;if not p_ then qa=a2;qc=true;bR=fV(a2,2)p_=true;b1=false end end end end elseif b4 and(g5~=nil and g5.planetname~="Space"and cg)then di("Autopilot complete, starting reentry")fU("apCom","AP")bl=g5.position;b1=false;be=false;b4=false;r5=false;bh="Aligning"qa=0;p_=false;b3=true;cc=true;ct.showWayPoint(c8,g5.position)end;if c0 then cz=true;local sX=0;local fv=vec3(DUPlayer.getWorldPosition())local t6=fv-cO;local t7=vec3(t6):project_on(cH):len()local t8=vec3(t6):project_on(cI):len()local cb=dn(t7*t7+t8*t8)qN(t6:normalize())local mB=40;local t9=cb<mB;local ta=100;local rz=dl((cb-mB)/2,10,ta)q1=0;local sr=eZ(q2)<0.1;if sr and cL<rz and not t9 then b1=false;sX=-20 else b1="Follow"sX=0 end;local tb=0;if eZ(sX-cS)>tb then if tc==nil then tc=pid.new(2*0.01,0,2*0.1)end;tc:inject(sX-cS)local sZ=tc:get()q1=sZ end end;if b6 or b7 or b9 or br or bu~=nil then if bI then if cf==-1 then bb=bb-0.2 else bb=ci+bI-cf end end;local td=bv;if td then td=td*dl(cL/100,0.1,1)*ch else td=bt end;if not cg then td=bt end;q9=cH:project_on_plane(cM):normalize():dot(cK)if q9>100 then c6,c7=cp.computeDistanceAndTime(q9,100,cj,0,0,td)local te,tf=cp.computeDistanceAndTime(100,0,cj,0,0,td*0.55)c6=c6+te else c6,c7=cp.computeDistanceAndTime(q9,0,cj,0,0,td*0.55)end;local sF=bb-ci-cN;local tg=200+cL;if b9 or cc then th=2000+cL end;local ti=1;if b8 then ti=dl(cL/100,0.1,1)end;local sX=(utils.smoothstep(sF,-tg,tg)-0.5)*2*Q*ti;if not b9 and not cc and not br and cH:dot(cK:normalize())<0.99 then sX=(utils.smoothstep(sF,-tg*dl(20-19*ch*10,1,20),tg*dl(20-19*ch*10,1,20))-0.5)*2*Q*dl(2-ch*10,1,2)*ti end;if not b6 then sX=0 end;if bu~=nil then if cY and not bA then sX=bu else bu=nil end end;cz=true;local tj=q1;if b9 then local tk=bN(cB)local tl,tm=cp.computeDistanceAndTime(cL,tk/3.6,cj,0,0,bt-kE.gravity*9.8*cj)tl=tl==-1 and 5000 or tl;local r6=ci-(kE.noAtmosphericDensityAltitude+tl)local tn=ci>kE.noAtmosphericDensityAltitude+tl*1.35;if tn then sX=R;if cL<=tk/3.6 and cL>tk/3.6-10 and eZ(cK:normalize():dot(cH))>0.9 and not cR then bV=false;qa=1 end elseif(cR or iI:getTargetSpeed(axisCommandId.longitudinal)~=tk)and not tn and not cg then qb=tk;qc=true end;if cR then if cL>tk/3.6 and not tn then b1="Reentry Limit"if bR>0 then qa=0 end else b1=false end else b1=false end;if cN>0 then b1="Reentry vSpd"end;if not q0 then sX=-80;if ci<kE.surfaceMaxAltitude+(kE.atmosphereThickness-kE.surfaceMaxAltitude)*0.25 then di("PARACHUTE DEPLOYED at "..fV(ci,0))b9=false;b7=true;qY=true;qa=0;sX=0;cz=q end elseif kE.noAtmosphericDensityAltitude>0 and tn then cz=true elseif not tn then if not cg and(cR or iI:getTargetSpeed(axisCommandId.longitudinal)~=tk)then qb=tk end;if cL<tk/3.6+1 then b1=false;q0=false;b9=false;cz=true;qa=1 end end end;if cL>j0 and not cd and not br and not b7 and u then qN(vec3(cK))end;if cX or(br or cd)and bm>0 and cg then local qU;if cX then if type(cX)=="table"then qU=cX elseif cX<3 and cX>0 then qU=-cM:cross(cK)*5000 elseif cX>=3 then qU=cM:cross(cK)*5000 elseif cX<0 then qU=cK*25000 end elseif g5~=nil then qU=g5.position-cO else qU=c8.center-cO end;local sW=math.deg(qv(cM:normalize(),cK,qU))*2;local mE=math.rad(eZ(cT))if cL>aM and cg then local to=1000+cL;local tp=(utils.smoothstep(sF-cN*10,-to,to)-0.5)*2*Q;local tq=dl(90-tp,0,180)q4=dl(sW*2,-tq,tq)local tr=sW;sW=dl(dl(sW,-N*0.80,N*0.80)*math.cos(mE)+4*(cS-sX)*math.sin(math.rad(cT)),-N*0.80,N*0.80)local ts=1;if q4~=0 then ts=eZ(mE/q4)end;ts=(90-dl(eZ(q4-cT),0,90))/90;local tt=sX;if eZ(cT)>90 then tt=-tt end;sX=ts*dl(dl(tt*math.cos(mE),-O*0.8,O*0.8)+eZ(dl(eZ(tr)*math.sin(mE),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q4=0;sW=dl(sW,-N*0.80,N*0.80)end;local tu=sh-sW;if cX and eZ(tu)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and eZ(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fU("180Off","BR")return end;if not cA and cL>aM and cg then if tv==nil then tv=pid.new(2*0.01,0,2*0.1)end;tv:inject(tu)local t0=dl(tv:get(),-1,1)q2=q2+t0 elseif cg and cf>-1 or cL<aM then qN(qU)elseif cA and cg then if(sh<-N or sh>N)and cg then qN(cK)end;if(si<-O or si>O)and cg then sX=dl(cS-si,cS-O*0.80,cS+O*0.80)end end;if g5~=nil and not cd then local ss=kE:getAltitude(g5.position)local r6=qU:project_on_plane(cM):len()qY=true;if bb<kE.noAtmosphericDensityAltitude and not cd and not b8 and not b9 and(r6<=c6 and qU:len()<kE.radius)and(cK:project_on_plane(cM):normalize():dot(qU:project_on_plane(cM):normalize())>0.99 or lz=="Finalizing Approach")then lz="Finalizing Approach"if#bG>0 then if not ql then table.remove(bG,1)end;if#bG>0 then if not ql then ql=2 end;return end end;qa=0;if b6 then ct.ToggleAltitudeHold()br=true end;b1="AP Finalizing"elseif not b8 then b1=false end;if lz=="Finalizing Approach"and(q9<0.1 or r6<0.1 or tw~=nil and tw<r6)then fU("bklOn","BL")b7=true;db=true;if g5.heading then dc=g5.heading else dc=nil end;br=false;lz="Proceeding to Waypoint"cZ=false end;tw=r6 end elseif br and not cg and bb>kE.noAtmosphericDensityAltitude and not(cd or b9)then if g5~=nil and c8.name==kE.name then local qU=g5.position-cO;local ss=kE:getAltitude(g5.position)local r6=dn(qU:len()^2-(ci-ss)^2)local td=bv;if td then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,td/2)qY=true;if r6<=c6+cL*sg/2 and cK:project_on_plane(cM):normalize():dot(qU:project_on_plane(cM):normalize())>0.99 then if kE.hasAtmosphere then b1=false;b3=false;q0=true;cc=false;ce=true;b4=false;ct.BeginReentry()end end;tw=r6 end end end;if not cg and cf==-1 and(b6 and bb>kE.noAtmosphericDensityAltitude)and not(cd or bA or b9)then if not cE and not bA then cD=bb;pV=true;if br then q6.VectorToTarget=true end;ct.ToggleIntoOrbit()br=false;pT=true end end;if cA and cg and cf==-1 and cL>aM and lz~="Finalizing Approach"then qN(cK)sX=dl(cS-si,cS-O*0.80,cS+O*0.80)end;q1=tj;local qG=-1;if b7 then if not qg then rZ=false;if not cR then qa=0 end;if cf==-1 then iI:setTargetGroundAltitude(500)iI:activateGroundEngineAltitudeStabilization(500)end;bC=true;if not cg then rZ=true end;qg=true end;sX=0;local tx=false;local ty=math.abs(q9)if not r and cQ then tx=antigrav.getBaseAltitude()if tx<kE.surfaceMaxAltitude and g5==nil or g5~=nil and kE:getAltitude(g5.position)>tx then tx=false end else tx=false end;if dc then if ty<0.05 then if cN>-P then b1=false else b1="BL Align BLR"end;if qN(dc,0.001)then dc=nil;cz=q else q1=0;cz=true end else b1="BL Align Hzn"end;if tx and eZ(ci-tx)<250 then b1="AGG Align"end else local tz=false;local tA=30;if ty<10 and so~=nil and so>0 then local tB=dl(ch,0.4,2)local td=bv*dl(cL/100,0.1,1)*tB;local tC=so*tB+td-of;local tD=td/2-of;local tE=cL-dn(eZ(tD/2)*20/(0.5*cj))*utils.sign(tD)if tE<0 then tE=0 end;local tF;if cL>100 then local tG,dQ=cp.computeDistanceAndTime(cL,100,cj,0,0,td)local tH,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,dn(td))tF=tG+tH else tF=cp.computeDistanceAndTime(cL,0,cj,0,0,dn(td))end;if tF<20 then b1=false else local tI=0;if tE>100 then local tJ,dQ=cp.computeDistanceAndTime(tE,100,cj,0,0,tC)local tK,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,so*tB+dn(td)-of)tI=tJ+tK else tI,dQ=cp.computeDistanceAndTime(tE,0,cj,0,0,so*tB+dn(td)-of)end;tI=(tI+15+cL*sg)*1.1;local tL=db and g5~=nil and kE:getAltitude(g5.position)>0 and g5.safe;local ss=nil;if tx and tx<ci then ss=tx elseif tL then ss=kE:getAltitude(g5.position)+250 elseif ci>kE.surfaceMaxAltitude then ss=kE.surfaceMaxAltitude end;if c_ then local tM=kE:getAltitude(c_[1].center)if ss then if tM>ss then ss=tM end else ss=tM end end;if ss~=nil then local tN=ci-ss;tz=true;if tN<=tI or tI==-1 or ty>0.05 and db then if ss==kE.surfaceMaxAltitude and cN<-P then b1="BL Stop BLR"elseif ty>0.05 and db then b1="BL AP Hzn"else b1="BL Stop Dist"end else b1=false end end end end;qG=cf;if qG>-1 then b1=false;if not tx and not bn then qd=true;iI:setTargetGroundAltitude(_)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qG-3<_ then b7=false;b6=false;b_=0;qZ(0,1)b1="BL Complete"cz=q;db=false;qg=false else if cN<-5 or ty>0.5 then qZ(0,1)b1="BL Slowing"else b1=false;qZ(-1)end end elseif not tz then if qY and cK:normalize():dot(-gr)<0.999 then b1="BL Strong"qN()elseif ty>10 or ty>0.05 and db then b1="BL hSpd"elseif cN<-P then b1="BL BLR"qZ(0,1)else qZ(-1)b1=false end end end else qg=false end;if b8 or cd then local lv,eK,eJ;if bl~=nil then lv,eK,eJ=co:getPlanetarySystem(0):castIntersections(cO,(bl-cO):normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)end;if cQ and not cd then if ci>=bb-50 and cL>j0 then b8=false;if not b4 and not br then b1="ATO Agg Arrive"qa=0 end end elseif eZ(sX)<15 and ci/bb>0.75 then b8=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<j0 then b4=true;cd=false;b6=false;b8=false;qa=0 elseif cd then qa=0;b1="ATO Space"end elseif cd and not cg and c8~=nil and(lv==nil or lv.name==c8.name)then b4=true;cd=false;b6=false;b8=false;if not cR then qa=0 end;bc=true end end;local tO=cf>-1;local tP=cS;if(br or cd or cX)and not tO and cL>aM and cg then local mE=math.rad(eZ(cT))tP=cS*eZ(math.cos(mE))+si*math.sin(mE)end;local tQ=dl(sX-tP,-O*0.80,O*0.80)if not cg and br then tQ=dl(sX-tP,-85,Q)elseif not cg then tQ=dl(sX-tP,-Q,Q)end;if eZ(cT)<5 or br or cX or b7 or tO or b6 then if tc==nil then tc=pid.new(5*0.01,0,5*0.1)end;tc:inject(tQ)local sZ=tc:get()q1=q1+sZ end end;if antigrav~=nil and(antigrav and not r and ci<200000)then if bw==nil or bw<1000 then bw=1000 end;if tR~=bw then tR=bw;qk=tR end end;if(cg or b9 or ce)and t and cR then if tS==nil then tS=pid.new(0.1,0,1)end;local tT=0;if aV>0 and not b9 and ch>0.005 and ch<0.1 and cN>-10 then local tU=bP.getFrictionBurnSpeed()*aV;local tV=cB/3.6;if tU>tV then tT=tU-tV-1 end end;tS:inject(cB/3.6+tT-cK:dot(cH))local tW=tS:get()bU=dl(tW,-1,1)if not d7 then if bU<bR and(ch>0.005 or b9 or ce)then bT=true;d7=dl(bU,0.01,1)else bT=false;d7=bR end end;if tX==nil then tX=pid.new(1*0.01,0,1*0.1)end;tX:inject(cK:len()-cB/3.6-tT)local tY=dl(tX:get(),0,1)if cg and cN<-80 or(ch>0.005 or b9 or ce)then bS=tY end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dl(bU,0.01,1)end;local tZ=''local t_=vec3()local u0=rx(axisCommandId.vertical,b_*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",u0,rV)local u1='thrust analog longitudinal 'if bD=="All"or bD=="Longitude"then u1=u1 ..aW end;local u2=iI:getAxisCommandType(axisCommandId.longitudinal)local u3=iI:composeAxisAccelerationFromThrottle(u1,axisCommandId.longitudinal)local u4=rK(axisCommandId.lateral,bz*1000)tZ=tZ..' , '.."lateral airfoil , lateral ground "t_=t_+u4;if t_:len()>constants.epsilon then d:setEngineForceCommand(tZ,t_,rV,'','','',rW)end;d:setEngineForceCommand(u1,u3,rU)local u5='thrust analog vertical fueled 'local u6='thrust analog lateral fueled 'if bD=="All"or bD=="Lateral"then u6=u6 ..aX end;if bD=="All"or bD=="Vertical"then u5=u5 ..aY end;if b_~=0 or b7 and b1 or not bn and not bC then d:setEngineForceCommand(u5,u0,rU)else d:setEngineForceCommand(u5,vec3(),rU)end;if bz~=0 then d:setEngineForceCommand(u6,u4,rU)else d:setEngineForceCommand(u6,vec3(),rU)end;if s2==0 then s2=bS end;local u7=-s2*(aR*cK+aS*s6)d:setEngineForceCommand('brake',u7)else if t then if not d7 then d7=bR end end;local rz=c.getAxisCommandValue(0)if not cR then if tX==nil then tX=pid.new(1*0.01,0,1*0.1)end;tX:inject(cK:len()-rz/3.6)local tY=dl(tX:get(),0,1)s2=dl(s2+tY,0,1)end;local u7=-s2*(aR*cK+aS*s6)d:setEngineForceCommand('brake',u7)local tZ=''local t_=vec3()local u8=false;local u1='thrust analog longitudinal 'if aW~="none"and(bD=="All"or bD=="Longitude")then u1=u1 ..aW end;local u2=iI:getAxisCommandType(axisCommandId.longitudinal)if u2==axisCommandType.byThrottle then local u3=iI:composeAxisAccelerationFromThrottle(u1,axisCommandId.longitudinal)d:setEngineForceCommand(u1,u3,rU)elseif u2==axisCommandType.byTargetSpeed then local u3=iI:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tZ=tZ..' , '..u1;t_=t_+u3;if iI:getTargetSpeed(axisCommandId.longitudinal)==0 or iI:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iI:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u8=true end end;local u6='thrust analog lateral 'if aX~="none"and(bD=="All"or bD=="Lateral")then u6=u6 ..aX end;local u9=iI:getAxisCommandType(axisCommandId.lateral)if u9==axisCommandType.byThrottle then local ua=iI:composeAxisAccelerationFromThrottle(u6,axisCommandId.lateral)d:setEngineForceCommand(u6,ua,rU)elseif u9==axisCommandType.byTargetSpeed then local u4=iI:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tZ=tZ..' , '..u6;t_=t_+u4 end;local u5='thrust analog vertical 'if aY~="none"and(bD=="All"or bD=="Vertical")then u5=u5 ..aY end;local ub=iI:getAxisCommandType(axisCommandId.vertical)if ub==axisCommandType.byThrottle then local u0=iI:composeAxisAccelerationFromThrottle(u5,axisCommandId.vertical)if b_~=0 or b7 and b1 then d:setEngineForceCommand(u5,u0,rU,'airfoil','ground','',rW)else d:setEngineForceCommand(u5,vec3(),rU)d:setEngineForceCommand('airfoil vertical',u0,rU,'airfoil','','',rW)d:setEngineForceCommand('ground vertical',u0,rU,'ground','','',rW)end elseif ub==axisCommandType.byTargetSpeed then if b_<0 then d:setEngineForceCommand('hover',vec3(),rU)end;local uc=iI:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tZ=tZ..' , '..u5;t_=t_+uc end;if t_:len()>constants.epsilon then if s2~=0 or u8 or eZ(s6:dot(cH))<0.5 then tZ=tZ..', brake'end;d:setEngineForceCommand(tZ,t_,rV,'','','',rW)end end;local ud=aO*(sa-s9)local ue=vec3(bP.getWorldAirFrictionAngularAcceleration())ud=ud-ue;d:setEngineTorqueCommand('torque',ud,rU,'airfoil','','',rW)d:setBoosterCommand('rocket_engine')if c5 and not o then local fp=cJ:len()local uf=0.15;if not cR then local ug=iI:getTargetSpeed(axisCommandId.longitudinal)if fp*3.6>ug*(1-uf)and uh then uh=false;d:toggleBoosters()elseif fp*3.6<ug*(1-uf)and not uh then uh=true;d:toggleBoosters()end else local rm=c.getThrottle()if t then rm=bR*100 end;local rz=rm/100;if not cg then rz=rz*a1;if fp>=rz*(1-uf)and uh then uh=false;d:toggleBoosters()elseif fp<rz*(1-uf)and not uh then uh=true;d:toggleBoosters()end else local tk=bN(cB)rz=rz*tk/3.6;if fp>=rz*(1-uf)and uh then uh=false;d:toggleBoosters()elseif fp<rz*(1-uf)and not uh then uh=true;d:toggleBoosters()end end end end end;if ui then for dL,dx in pairs(ui)do pJ[dL]=dx end end;cf=qB()return pJ end;local function uj(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uk,iH,iI,iJ,ul,gM,fV,e4,dm,dl,fU,iL,pI,di)local bP=DUConstruct;local um={}local un=true;local uo=5;local up=5;local uq=uo;local ur=up;local us=bQ;function um.landingGear(qd)bn=not bn;if bn then br=false;bu=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not qd and cf==-1 then fU("bklOn","BL")qY=true;b9=false;b8=false;ba=false;if bA then ct.ToggleIntoOrbit()end;if b7 then db=not db end;cz=true;bn=false;b7=true else if bW then fU("grOut","LG",1)d.control.deployLandingGears()end;db=false;if cg then cz=q;b1="Landing"end end;if qd or cf~=-1 and cf>_-3 then b7=true end;iI:setTargetGroundAltitude(_)b6=false;bI=false elseif bW and not b7 then fU("grOut","LG",1)d.control.deployLandingGears()end else if b7 then b7=false end;if bW then fU("grIn","LG",1)d.control.retractLandingGears()end;iI:activateGroundEngineAltitudeStabilization(r1)if bC then if _<iI.targetGroundAltitude then iI:setTargetGroundAltitude(iI.targetGroundAltitude)else iI:setTargetGroundAltitude(Z)end end end end;function um.startControl(ut)local function uu(rh)local ri=1;local function uv(uw,rh)local ux={kE.surfaceMaxAltitude+100,kE.spaceEngineMinAltitude-0.01*kE.noAtmosphericDensityAltitude,kE.noAtmosphericDensityAltitude+V,kE.radius*(U-1)+kE.noAtmosphericDensityAltitude}local uy=uw;for dQ,dx in ipairs(ux)do if rh and uy>dx then uw=dx elseif uw<dx and not rh then uw=dx;break end end;return uw end;if rh then ri=-1 end;if not r and cQ then if c1 and rh then bw=1000 elseif bw~=nil then bw=bw+ri*up;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end else bw=tR+ri*100 end elseif b6 or ba or bA then if bA then if c1 then cD=uv(cD,rh)else cD=cD+ri*uo end;if cD<kE.noAtmosphericDensityAltitude then cD=kE.noAtmosphericDensityAltitude end else if c1 and cg then bb=uv(bb,rh)bI=false else bb=bb+ri*uo;if bI then if bb>100 then bI=false else iI:updateTargetGroundAltitudeFromActionStart(ri*1.0)bI=d:getTargetGroundAltitude()end end end end else iI:updateTargetGroundAltitudeFromActionStart(ri*1.0)end end;local function uz(uA)if not cg then di("Flight Assist in Atmo only")return end;local du=type(uA)if cX==nil then if du=="table"then if b4 or br then ct.ToggleAutopilot()end;fU("180On","BR")elseif uA==1 then fU("bnkLft","BR")else fU("bnkRht","BR")end;if not b6 and not b4 and not br then ct.ToggleAltitudeHold()if du~="table"then uA=uA+1 end end;cX=uA else fU("180Off","BR")cX=nil end end;local function uB()if iJ()==1 then c9=0;ca=0;ul(bj)elseif iH()==1 and y then cy=false;cx=false end;c1=false end;if ut=="gear"then cv.landingGear()elseif ut=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ut=="forward"then if pa and not cg and not b4 then b3=not b3;b2=false else bX=bX-1 end elseif ut=="backward"then if pa then if not cg then if not b4 then b2=not b2;b3=false else b5=not b5 end else uz(-cK*5000)end else bX=bX+1 end elseif ut=="left"then if pa then uz(1)else bY=bY-1 end elseif ut=="right"then if pa then uz(3)else bY=bY+1 end elseif ut=="yawright"then bZ=bZ-1;dc=nil elseif ut=="yawleft"then bZ=bZ+1;dc=nil elseif ut=="straferight"then iI:updateCommandFromActionStart(axisCommandId.lateral,1.0)bz=1 elseif ut=="strafeleft"then iI:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bz=-1 elseif ut=="up"then ct.vertical(1)if cf-3<_ and ci>0 and bn then cv.landingGear()end elseif ut=="down"then ct.vertical(-1)elseif ut=="groundaltitudeup"then uu()elseif ut=="groundaltitudedown"then uu(true)elseif ut=="option1"then uC=false;if pa and c1 then local uD=""for M=1,#d2 do uD=uD.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fV(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..uD)return end;cs.adjustAutopilotTargetIndex()elseif ut=="option2"then uC=false;if pa and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;di("Deboarded All Passengers")return end;cs.adjustAutopilotTargetIndex(1)elseif ut=="option3"then uC=false;if pa and c1 then local uD=""for M=1,#d3 do uD=uD.."| ID: "..d3[M].." Mass: "..fV(bP.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..uD)return end;if x then if w then w=false else w=true end;if cu then cu.ToggleRadarPanel()end end elseif ut=="option4"then uC=false;if pa and c1 then for M=1,#d3 do bP.forceUndock(d3[M])end;di("Undocked all ships")return end;cX=nil;ct.ToggleAutopilot()elseif ut=="option5"then uC=false;ct.ToggleLockPitch()elseif ut=="option6"then uC=false;if pa and c1 then if shield then cw.ventShield()else di("No shield found")end;return end;ct.ToggleAltitudeHold()elseif ut=="option7"then uC=false;if pa and c1 then if shield then shield.toggle()return else di("No shield found")return end end;E=not E;if E then di("Collision System Enabled")else di("Collision System Secured")end elseif ut=="option8"then uC=false;if pa and c1 then if bm>0 and g5~=nil then ct.routeWP()else di("Select a saved wp on IPH to add to or remove from route")end;return end;bC=not bC;if not bC then di("DeCoupled Mode - Ground Stabilization off")iI:deactivateGroundEngineAltitudeStabilization()fU("gsOff","GS")else di("Coupled Mode - Ground Stabilization on")iI:activateGroundEngineAltitudeStabilization(r1)de=true;fU("gsOn","GS")end elseif ut=="option9"then uC=false;if pa and c1 then iI:resetCommand(axisCommandId.longitudinal)iI:resetCommand(axisCommandId.lateral)iI:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()==1;if ck then fU("gyOn","GA")else fU("gyOff","GA")end else di("No gyro found")end elseif ut=="lshift"then if pa then c1=true end elseif ut=="brake"then if a_ or pa then ct.BrakeToggle("Manual")elseif not b1 then ct.BrakeToggle("Manual")else b1="Manual"end elseif ut=="lalt"then uC=true;pa=true;if iH()==0 and not j and g=="keyboard"then ul(1)end elseif ut=="booster"then if o then d:toggleBoosters()elseif not c5 then if not uh then d:toggleBoosters()uh=true end;c5=true else if uh then d:toggleBoosters()uh=false end;c5=false end elseif ut=="stopengines"then local function uE()if bQ-us<1.5 then fU("clear","CA")ct.clearAll()end end;uE()us=bQ;if iI:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if pa then if cB>0 then cB=0 else cB=W end elseif bR~=0 then iI:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iI:getTargetSpeed(axisCommandId.longitudinal)~=0 then iI:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(a1*3.6)end end end elseif ut=="speedup"then ct.changeSpd()elseif ut=="speeddown"then ct.changeSpd(true)elseif ut=="antigravity"and not r then if antigrav~=nil then ct.ToggleAntigrav()else di("No antigrav found")end elseif ut=="leftmouse"then c2=true;if c1 then uB()uC=false else c1=true;bj=iJ()ul(1)end end end;function um.stopControl(ut)local function uF()if not r and cQ then ur=up end;if b6 or ba or bA then uq=uo end end;if ut=="forward"then bX=0 elseif ut=="backward"then bX=0 elseif ut=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif ut=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif ut=="yawright"then bZ=0 elseif ut=="yawleft"then bZ=0 elseif ut=="straferight"then iI:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bz=0 elseif ut=="strafeleft"then iI:updateCommandFromActionStop(axisCommandId.lateral,1.0)bz=0 elseif ut=="up"then ct.vertical(0,-1)elseif ut=="down"then ct.vertical(0,1)elseif ut=="groundaltitudeup"then uF()uC=false elseif ut=="groundaltitudedown"then uF()uC=false elseif ut=="brake"then if not a_ and not pa then if b1 then ct.BrakeToggle()else b1=false end end elseif ut=="lalt"then if c1 then c1=false end;if iH()==0 and j then if uC then if iJ()==1 then ul(0)else ul(1)end else uC=true end elseif iH()==0 and not j and g=="keyboard"then ul(0)end;pa=false end end;function um.loopControl(ut)local function uG(rh)local ri=1;if rh then ri=-1 end;if not r and cQ then if bw~=nil then bw=bw+ri*ur;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end;ur=dl(ur*1.05,up,50)else bw=tR+ri*100 end elseif b6 or ba or bA then if bA then cD=cD+ri*uq;if cD<kE.noAtmosphericDensityAltitude then cD=kE.noAtmosphericDensityAltitude end else bb=bb+ri*uq end;uq=dl(uq*1.05,uo,50)else iI:updateTargetGroundAltitudeFromActionLoop(ri*1.0)end end;local function uH(rh)local ri=1;if rh then ri=-1 end;if not c1 then if t and not pa then bR=dl(bR+ri*aG/100,-1,1)else iI:updateCommandFromActionLoop(axisCommandId.longitudinal,ri*aG)end end end;if ut=="groundaltitudeup"then if not c1 then uG()end elseif ut=="groundaltitudedown"then if not c1 then uG(true)end elseif ut=="speedup"then uH()elseif ut=="speeddown"then uH(true)end end;function um.inputTextControl(rg)local function uI(uJ,fv,gz)local function uK(fv)local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local dU,dV,e1,e2,e3=e4(fv,dE)if dU=="0"and dV=="0"then return vec3(dm(e1),dm(e2),dm(e3))end;e2=math.rad(e2)e1=math.rad(e1)local kE=e[dm(dU)][dm(dV)]local eV=math.cos(e1)local uL=vec3(eV*math.cos(e2),eV*math.sin(e2),math.sin(e1))return kE.center+(kE.radius+e3)*uL end;local fX=uK(fv)return cs.AddNewLocation(uJ,fX,gz)end;local M;local uM,iw=nil,nil;local uN="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(rg," ")uM=rg;if M~=nil then uM=string.sub(rg,0,M-1)iw=string.sub(rg,M+1)end;if uM=="/help"or uM=="/commands"then for lu in string.gmatch(uN,"([^\n]+)")do a.print(lu)end;return elseif uM=="/setname"then if iw==nil or iw==""then di("Usage: ah-setname Newname")return end;if bm>0 and g5~=nil then cs.UpdatePosition(iw)else di("Select a saved target to rename first")end elseif shield and uM=="/resist"then cw.setResist(iw)elseif uM=="/addlocation"or string.find(rg,"::pos")~=nil then local gz=false;local uJ="0-Temp"if iw==nil or iw==""or uM~="/addlocation"then iw=uM;gz=true end;M=string.find(iw,"::")if not gz then uJ=string.sub(iw,1,M-2)end;local fv=string.sub(iw,M)uI(uJ,fv,gz)elseif uM=="/agg"then if iw==nil or iw==""then di("Usage: /agg targetheight")return end;iw=dm(iw)if iw<1000 then iw=1000 end;bw=iw;di("AGG Target Height set to "..iw)elseif uM=="/G"then if iw==nil or iw==""then di("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if iw=="dump"then for dL,dx in pairs(iL())do if type(dx.get())=="boolean"then if dx.get()==true then a.print(dL.." true")else a.print(dL.." false")end elseif dx.get()==nil then a.print(dL.." nil")else a.print(dL.." "..dx.get())end end;return end;M=string.find(iw," ")local uO=string.sub(iw,0,M-1)local uP=string.sub(iw,M+1)for dL,dx in pairs(iL())do if dL==uO then local uQ=type(dx.get())if uQ=="number"then uP=dm(uP)if dL=="AtmoSpeedLimit"then cB=uP end end;di("Variable "..uO.." changed to "..uP)if dL=="MaxGameVelocity"then uP=uP/3.6;if uP>df-0.2 then uP=df-0.2;di="Variable "..uO.." changed to "..fV(uP*3.6,1)end end;if uQ=="boolean"then if string.lower(uP)=="true"then uP=true else uP=false end end;dx.set(uP)return end end;di("No such global variable: "..uO)elseif uM=="/deletewp"then if bm>0 and g5~=nil then cs.ClearCurrentPosition()else di("Select a custom wp to delete first in IPH")end elseif uM=="/copydatabank"then if dbHud_2 then pI(true)else di("Spare Databank required to copy databank")end elseif uM=="/iphWP"then if bm>0 then a.print(ct.showWayPoint(c8,bl,true))a.print(json.encode(bl))di("::pos waypoint shown in lua chat in local and world format")else di("No target selected in IPH")end elseif uM=="/createPrivate"then local uR="privatelocations = {\n"local uS=""if#d9>0 then for dL,dx in pairs(d9)do uR=uR.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uR=uR.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uR=uR.."safe = true},\n"else uR=uR.."safe = false},\n"end end end;uS=#d9 .."-Private "if iw=="all"then for dL,dx in pairs(bq)do uR=uR.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '*"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uR=uR.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uR=uR.." safe = true},\n"else uR=uR.."safe = false},\n"end end;uS=uS..#bq.."-Public "end;uR=uR.."}\n return privatelocations"if uk then uk.setHTML(uR)end;di(uS.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c4=7 end end;function um.tagTick()if bD=="Off"then bD="All"elseif bD=="All"then bD="Longitude"elseif bD=="Longitude"then bD="Lateral"elseif bD=="Lateral"then bD="Vertical"else bD="Off"end;di("Extra Engine Tags: "..bD)c.stopTimer("tagTick")end;if uT then for dL,dx in pairs(uT)do um[dL]=dx end end;return um end;local function uU(d,b,c,e,vBooster,hover,pH,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iE,uk)local a=DUSystem;local bP=DUConstruct;local uV=DUPlayer;local uW=DULibrary;local uX={}local dk=string.format;local iF=json.decode;local uY=json.encode;local pA=b.getElementMaxHitPointsById;local iG=b.getElementMassById;local iH=d.control.isRemoteControlled;local e4=string.match;local gM=a.destroyWidgetPanel;local fS=a.updateData;local fT=a.addDataToWidget;local ul=a.lockView;local iJ=a.isViewLocked;local dn=math.sqrt;local dm=tonumber;local eZ=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local eU=math.atan;local bM=a.getArkTime;local dl=utils.clamp;local iI=d.axisCommandManager;local gO=13;local iO=b.getElementIdList()local iP=0;local function dp(eC,eD)if eC==0 then return eZ(eD)<1e-09 elseif eD==0 then return eZ(eC)<1e-09 else return eZ(eC-eD)<math.max(eZ(eC),eZ(eD))*dC end end;local function fV(dD,uZ)local ri=10^(uZ or 0)return bN(dD*ri+0.5)/ri end;local function iK(u_,v0)for dL,dx in pairs(v0)do if type(dL)=="string"then u_[dL]=dx else u_[#u_+1]=v0[dL]end end;return u_ end;local function iL(v1)local v2={}if not v1 then iK(v2,L)iK(v2,ac)iK(v2,aE)iK(v2,aZ)return v2 elseif v1=="boolean"then return L elseif v1=="handling"then return ac elseif v1=="hud"then return aE elseif v1=="physics"then return aZ end end;local function di(di)if c3~="empty"then if c3~=di then c3=c3 .."\n"..di;c4=7 end else c3=di end end;local function pI(v3)local function v4(v5)for dL,dx in pairs(v5)do dbHud_1.setStringValue(dL,uY(dx.get()))if v3 and dbHud_2 then dbHud_2.setStringValue(dL,uY(dx.get()))end end end;if dbHud_1 then v4(bJ)v4(iL())a.print("Saved Variables to Datacore")if v3 and dbHud_2 then di("Databank copied.  Remove copy when ready.")end end end;local function fU(v6,v7,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v6 ..".mp3")end;local function gN(hH,hI,rg,jW,v8)return dk([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jW or"",hH,hI,v8 or"",rg)end;local function iM(cb,v9)v9=v9 or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fV(cb,v9)..unit end;local function iN(va)local vb=0;local vc=0;local vd=0;if va<60 then va=bN(va)elseif va<3600 then vb=bN(va/60)va=bN(va%60)elseif va<86400 then vc=bN(va/3600)vb=bN(va%3600/60)else vd=bN(va/86400)vc=bN(va%86400/3600)end;if vd>365 then return">1y"elseif vd>0 then return vd.."d "..vc.."h "elseif vc>0 then return vc.."h "..vb.."m "elseif vb>0 then return vb.."m "..va.."s"elseif va>0 then return va.."s"else return"0s"end end;local function ve()if radar_1 then cu=gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU,di)end end;function uX.radarSetup()ve()end;function uX.onStart()local vf=false;local function vg()local function vh(vi)local vj=dbHud_1.hasKey;for dL,dx in pairs(vi)do if vj(dL)then local dG=iF(dbHud_1.getStringValue(dL))if dG~=nil then dx.set(dG)vf=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vh(iL())coroutine.yield()vh(bJ)else vh(bJ)di("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c4=5;vf=false end;coroutine.yield()if vf then di("Loaded Saved Variables")elseif not f then di("No Databank Saved Variables Found\nVariables will save to Databank on standing")c4=5 end;if#bq>0 then da=iK(da,bq)end else di("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;a_=k;g=string.lower(g)cz=q;cB=W;if bx+180<bQ then bv=0 end;bx=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then di("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c4=7 end;if antigrav and not r then if bw==nil then bw=ci end;antigrav.setTargetAltitude(bw)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d9>0 then da=iK(da,d9)end end;lz="Proceeding to Waypoint"if not a1 or a1<0 then a1=bP.getMaxSpeed()-0.1 end end;local function vk()local function vl(vm,vn)if vm>vn then vn=vm end;local vo,vp=0,0;if a7>0 then vo=a7*0.05 end;if a8>0 then vp=a8*0.05 end;vn=vn*(1-(vo+vp))return vn end;local vq=b.getElementNameById;local vr=au~=0 and av~=0;local vs=_G["atmofueltank_size"]local vt=_G["spacefueltank_size"]local vu=_G["rocketfueltank_size"]for dL in pairs(iO)do local type=b.getElementDisplayNameById(iO[dL])if e4(type,'^.*Atmospheric Engine$')then if e4(tostring(b.getElementTagsById(iO[dL])),'^.*vertical.*$')and b.getElementForwardById(iO[dL])[3]>0 then cP=true end end;if e4(type,'^.*Space Engine$')then cG=true;if e4(tostring(b.getElementTagsById(iO[dL])),'^.*vertical.*$')then local vv=b.getElementForwardById(iO[dL])if vv[3]<0 then vw=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local pC=pA(iO[dL])if pC>10000 then gO=110 elseif pC>1000 then gO=55 elseif pC>150 then gO=27 end end;iP=iP+pA(iO[dL])if vr and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pC=pA(iO[dL])local on=iG(iO[dL])local vm=0;local jO=bM()if type=="Atmospheric Fuel Tank"then local vn=400;local vx=35.03;if pC>10000 then vn=51200;vx=5480 elseif pC>1300 then vn=6400;vx=988.67 elseif pC>150 then vn=1600;vx=182.67 end;vm=on-vx;if a4>0 then vn=vn+vn*a4*0.2 end;vn=vl(vm,vn)local gy=vq(iO[dL])local jM=0;for jN=1,vs do if gy==iF(c["atmofueltank_"..jN].getWidgetData()).name then jM=jN;break end end;local vy={iO[dL],string.sub(gy,1,12),vn,vx,vm,jO,jM}cl[#cl+1]=vy end;if type=="Rocket Fuel Tank"then local vn=320;local vx=173.42;if pC>65000 then vn=40000;vx=25740 elseif pC>6000 then vn=5120;vx=4720 elseif pC>700 then vn=640;vx=886.72 end;vm=on-vx;if a6>0 then vn=vn+vn*a6*0.1 end;vn=vl(vm,vn)local gy=vq(iO[dL])local jM=0;for jN=1,vu do if gy==iF(c["rocketfueltank_"..jN].getWidgetData()).name then jM=jN;break end end;local vy={iO[dL],string.sub(gy,1,12),vn,vx,vm,jO,jM}cn[#cn+1]=vy end;if type=="Space Fuel Tank"then local vn=600;local vx=35.03;if pC>10000 then vn=76800;vx=5480 elseif pC>1300 then vn=9600;vx=988.67 elseif pC>150 then vn=2400;vx=182.67 end;vm=on-vx;if a5>0 then vn=vn+vn*a5*0.2 end;vn=vl(vm,vn)local gy=vq(iO[dL])local jM=0;for jN=1,vt do if gy==iF(c["spacefueltank_"..jN].getWidgetData()).name then jM=jN;break end end;local vy={iO[dL],string.sub(gy,1,12),vn,vx,vm,jO,jM}cm[#cm+1]=vy end end end;if not cP then ba,b0=false,false end end;local function vz()if gyro~=nil then ck=gyro.isActive()==1 end;if not bC then iI:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ul(1)else ul(0)end;if door and(cg or not cg and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not r then antigrav.showWidget()end end;if iH()==1 and l then uV.freeze(1)else uV.freeze(0)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bn=d.control.isAnyLandingGearDeployed()==1 or cf~=-1 and cf-3<_;if cf~=-1 or not cg and cJ:len()<50 then b1="Startup"else b1=false end;iI:setTargetGroundAltitude(_)po=cg end;local function vA()local vB={}local function vC()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vD={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vE,vF in pairs(e)do e[vE][0]=vC()e[vE][0].systemId=vE;vB[vE]={}for vG,kE in pairs(e[vE])do kE.gravity=kE.gravity/9.8;kE.center=vec3(kE.center)kE.name=kE.name[1]kE.noAtmosphericDensityAltitude=kE.atmosphereThickness;kE.spaceEngineMinAltitude=vD[kE.id]or 0.5353125*kE.atmosphereThickness;kE.planetarySystemId=vE;kE.bodyId=kE.id;vB[vE][vG]=kE;if mp==nil or kE.center.x<mp then mp=kE.center.x end;if mo==nil or kE.center.x>mo then mo=kE.center.x end;if ms==nil or kE.center.y<ms then ms=kE.center.y end;if mr==nil or kE.center.y>mr then mr=kE.center.y end;if kE.center and kE.name~="Space"then d4[#d4+1]=kE end end end;ee=dj(d,b,c,a,dk,dl,dm,dn,dp)co=ee(vB)fY=co[0]cp=eY(d,b,c,a,dn,eZ)cq=fr(d,b,c,a,dk,dl,dm,dn,dp)cs=fR(d,b,c,a,dbHud_1,e,fS,fT,bN,dm,dn,fU,fV,di)kE=co[0]:closestBody(bP.getWorldPosition())end;vH=false;vI=coroutine.create(function()iI:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vg()coroutine.yield()vk()coroutine.yield()ct=pG(d,b,c,e,vBooster,hover,pH,antigrav,dbHud_1,eZ,bN,bO,iH,eU,bM,dl,iI,fS,iJ,dn,fV,fU,iK,dp,iM,iN,pI,iF,di)vz()coroutine.yield()vA()ve()if iD then cr=iD(d,b,c,a,e,antigrav,hover,shield,warpdrive,iE,eZ,bN,dk,iF,bO,iG,iH,eU,bM,dl,iI,fT,fS,gM,iJ,dn,fV,gN,fU,iK,iL,iM,iN,iO,iP,di)end;if cr then cr.ButtonSetup()end;cv=uj(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uk,iH,iI,iJ,ul,gM,fV,e4,dm,dl,fU,iL,pI,di)if shield then cw=im(shield,e4,bN,di)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uk then uk.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bP.setDockingMode(ab)if shield then c.setTimer("shieldTick",0.0166667)end;if vJ then vK.ExtraOnStart()end;fU("start","SU")local function vL()if bH[1]==0 then ct.cmdThrottle(bH[2])else if ch>0 then cB=bH[2]ct.cmdThrottle(1)end end end;lr=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if lr then if cf>-1 and cL<1 and cf-3<_ then c.exit()else if J then vL()else if ch==0 then b1="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bH[3]+3>bM()then vL()end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()local vM;vM=#d2>1 and"Passengers: "..#d2-1 .." "or""vM=vM..(#d3>0 and"Ships: "..#d3 or"")if vM~=""then di("NOTICE: Docked "..vM)end end)coroutine.resume(vI)end;function uX.onUpdate()if vH then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iI:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and pc~=vN then a.setScreen(pc)end;vN=pc;if lr and not J and ch>0 and cf==-1 then cv.landingGear()end;if lr and cf>-1 and cL<1 and cf-3<_ then c.exit()end;if vJ then vK.ExtraOnUpdate()end else local ib=coroutine.status(vI)if ib=="suspended"then local dM,ic=coroutine.resume(vI)if ic then a.print("ERROR STARTUP: "..ic)end elseif ib=="dead"then vH=true end end end;function uX.onFlush()if vH then ct.onFlush()if vJ then vK.ExtraOnFlush()end end end;function uX.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;w=d6;local vO=0;if lr then vO=bM()end;if iI:getAxisCommandType(0)==0 then bH={0,bR,vO}else bH={1,iI:getTargetSpeed(axisCommandId.longitudinal),vO}end;pI()if nY then nY.activate()end;if z then ct.showWayPoint(kE,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vJ then vK.ExtraOnStop()end;fU("stop","SU")end;function uX.controlStart(ut)if vH then cv.startControl(ut)end end;function uX.controlStop(ut)if vH then cv.stopControl(ut)end end;function uX.controlLoop(ut)if vH then cv.loopControl(ut)end end;function uX.controlInput(rg)if vH then cv.inputTextControl(rg)end end;function uX.radarEnter(dV)if cu then cu.onEnter(dV)end end;function uX.radarLeave(dV)if cu then cu.onLeave(dV)end end;function uX.onTick(vP)if vP=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vP=="oneSecond"then if cr then cr.OneSecondTick()end elseif vP=="msgTick"then if cr then cr.MsgTick()end elseif vP=="animateTick"then if cr then cr.AnimateTick()end elseif vP=="hudTick"then if cr then cr.hudtick()end elseif vP=="apTick"then if ct then ct.APTick()end elseif vP=="shieldTick"then cw.shieldTick()elseif vP=="tagTick"then cv.tagTick()elseif vP=="contact"then cu.ContactTick()end end;if vJ then for dL,dx in pairs(vJ)do uX[dL]=dx end end;return uX end;function script.onStart()vK.onStart()end;function script.onOnStop()vK.onStop()end;function script.onTick(vP)vK.onTick(vP)end;function script.onOnFlush()vK.onFlush()end;function script.onOnUpdate()vK.onUpdate()end;function script.onActionStart(ut)vK.controlStart(ut)end;function script.onActionStop(ut)vK.controlStop(ut)end;function script.onActionLoop(ut)vK.controlLoop(ut)end;function script.onInputText(rg)vK.controlInput(rg)end;function script.onEnter(dV)vK.radarEnter(dV)end;function script.onLeave(dV)vK.radarLeave(dV)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vK=uU(d,core,unit,e,vBooster,hover,pH,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iE,uk)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
