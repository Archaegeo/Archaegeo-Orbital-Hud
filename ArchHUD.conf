name: ArchHud - Archaegeo v0.012 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.012;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.3;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab=1;ac={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end},DockingMode={set=function(M)ab=M end,get=function()return ab end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV=1.0;aW="none"aX="none"aY="none"aZ=0.05;a_={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aV=M end,get=function()return aV end},ExtraLongitudeTags={set=function(M)aW=M end,get=function()return aW end},ExtraLateralTags={set=function(M)aX=M end,get=function()return aX end},ExtraVerticalTags={set=function(M)aY=M end,get=function()return aY end},allowedHorizontalDrift={set=function(M)aZ=M end,get=function()return aZ end}}b0=k;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=false;bc=1000;bd=false;be=false;bf=false;bg=false;bh=0;bi="Aligning"bj=0;bk=1;bl="None"bm=nil;bn=0;bo=nil;bp=0.0;bq=0;br={}bs=false;bt=0;bu=0;bv=nil;bw=0;bx=1000;by=0;bz=false;bA=0;bB=false;bC="All"bD=true;bE="Off"bF=0.000;bG={}bH={}bI={}bJ=false;bK={VertTakeOff={set=function(M)bb=M end,get=function()return bb end},VertTakeOffEngine={set=function(M)b1=M end,get=function()return b1 end},SpaceTarget={set=function(M)bz=M end,get=function()return bz end},BrakeToggleStatus={set=function(M)b0=M end,get=function()return b0 end},BrakeIsOn={set=function(M)b2=M end,get=function()return b2 end},RetrogradeIsOn={set=function(M)b3=M end,get=function()return b3 end},ProgradeIsOn={set=function(M)b4=M end,get=function()return b4 end},Autopilot={set=function(M)b5=M end,get=function()return b5 end},TurnBurn={set=function(M)b6=M end,get=function()return b6 end},AltitudeHold={set=function(M)b7=M end,get=function()return b7 end},BrakeLanding={set=function(M)b8=M end,get=function()return b8 end},Reentry={set=function(M)ba=M end,get=function()return ba end},AutoTakeoff={set=function(M)b9=M end,get=function()return b9 end},HoldAltitude={set=function(M)bc=M end,get=function()return bc end},AutopilotAccelerating={set=function(M)bd=M end,get=function()return bd end},AutopilotBraking={set=function(M)bf=M end,get=function()return bf end},AutopilotCruising={set=function(M)bg=M end,get=function()return bg end},AutopilotRealigned={set=function(M)be=M end,get=function()return be end},AutopilotEndSpeed={set=function(M)bh=M end,get=function()return bh end},AutopilotStatus={set=function(M)bi=M end,get=function()return bi end},AutopilotPlanetGravity={set=function(M)bj=M end,get=function()return bj end},PrevViewLock={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetName={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetCoords={set=function(M)bm=M end,get=function()return bm end},AutopilotTargetIndex={set=function(M)bn=M end,get=function()return bn end},TotalDistanceTravelled={set=function(M)bp=M end,get=function()return bp end},TotalFlightTime={set=function(M)bq=M end,get=function()return bq end},SavedLocations={set=function(M)br=M end,get=function()return br end},VectorToTarget={set=function(M)bs=M end,get=function()return bs end},LocationIndex={set=function(M)bt=M end,get=function()return bt end},LastMaxBrake={set=function(M)bu=M end,get=function()return bu end},LockPitch={set=function(M)bv=M end,get=function()return bv end},LastMaxBrakeInAtmo={set=function(M)bw=M end,get=function()return bw end},AntigravTargetAltitude={set=function(M)bx=M end,get=function()return bx end},LastStartTime={set=function(M)by=M end,get=function()return by end},iphCondition={set=function(M)bC=M end,get=function()return bC end},stablized={set=function(M)bD=M end,get=function()return bD end},UseExtra={set=function(M)bE=M end,get=function()return bE end},SelectedTab={set=function(M)bL=M end,get=function()return bL end},saveRoute={set=function(M)bG=M end,get=function()return bG end},apRoute={set=function(M)bH=M end,get=function()return bH end},ecuThrottle={set=function(M)bI=M end,get=function()return bI end},HoverMode={set=function(M)bJ=M end,get=function()return bJ end}}local function bM(b,c,bN,bO,bP)local a=DUSystem;local bQ=DUConstruct;bR=bN()bS=0;bT=0;bU=false;bV=0;bW=false;bX=false;bY=0;bZ=0;b_=0;c0=0;c1=false;c2=false;c3=false;c4="empty"c5=3;c6=false;c7=0;c8=0;c9=nil;ca=0;cb=0;cc=0;cd=false;ce=false;cf=false;cg=-1;ch=bP()>0;ci=bP()cj=b.getAltitude()ck=DUConstruct.getMass()cl=nil;cm={}cn={}co={}cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=nil;cy=false;cz=false;cA=q;cB=false;cC=W;cD=nil;cE=0;cF=false;cG=false;cH=false;cI=vec3(bQ.getWorldOrientationForward())cJ=vec3(bQ.getWorldOrientationRight())cK=vec3(bQ.getVelocity())cL=vec3(bQ.getWorldVelocity())cM=vec3(cL):len()cN=vec3(b.getWorldVertical())cO=-cN:dot(cL)cP=vec3(bQ.getWorldPosition())cQ=false;cR=false;cS=true;cT=0;cU=0;cV={}cW=false;cX=50000;cY=nil;cZ=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;c_=false;d0=nil;d1=false;d2=0;d3={}d4={}d5={}d6=90;d7=w;d8=nil;d9=nil;da={}db={}dc=false;dd=nil;de=0;df=false;dg=bQ.getMaxSpeed()if shield then dh=bO(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function di(dj)a.print(bR..": "..dj)end;local function dk(d,b,c,a,dl,dm,dn,dp,dq)local function dr(ds)return type(ds)=='number'end;local function dt(ds)return type(dn(ds))=='number'end;local function du(dv)return type(dv)=='table'end;local function dw(a)return type(a)=='string'end;local function dx(dy)return du(dy)and dr(dy.x and dy.y and dy.z)end;local function dz(dA)return du(dA)and dr(dA.latitude and dA.longitude and dA.altitude and dA.id and dA.systemId)end;local dB=math.pi/180;local dC=180/math.pi;local dD=1e-10;local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF='::pos{'..dE..','..dE..','..dE..','..dE..','..dE..'}'local utils=utils;local vec3=vec3;local function dG(ds)local dH=string.gsub(string.reverse(dl('%.4f',ds)),'^0*%.?','')return dH==''and'0'or string.reverse(dH)end;local function dI(dJ)if dx(dJ)then return dl('{x=%.3f,y=%.3f,z=%.3f}',dJ.x,dJ.y,dJ.z)end;if du(dJ)and not getmetatable(dJ)then local dK={}local dL=next(dJ)if type(dL)=='nil'or dL==1 then dK=dJ else for dM,dy in pairs(dJ)do local dN=dI(dy)if type(dM)=='number'then table.insert(dK,dl('[%s]=%s',dM,dN))else table.insert(dK,dl('%s=%s',dM,dN))end end end;return dl('{%s}',table.concat(dK,','))end;if dw(dJ)then return dl("'%s'",dJ:gsub("'",[[\']]))end;return tostring(dJ)end;local dO={}dO.__index=dO;dO.__tostring=function(dJ,dP)local dQ={}for dM in pairs(dJ)do table.insert(dQ,dM)end;table.sort(dQ)local dK={}for dR,dM in ipairs(dQ)do local dN=dI(dJ[dM])if type(dM)=='number'then table.insert(dK,dl('[%s]=%s',dM,dN))else table.insert(dK,dl('%s=%s',dM,dN))end end;if dP then return dl('%s%s',dP,table.concat(dK,',\n'..dP))end;return dl('{%s}',table.concat(dK,','))end;dO.__eq=function(dS,dT)return dS.systemId==dT.systemId and dS.id==dT.id and dq(dS.radius,dT.radius)and dq(dS.center.x,dT.center.x)and dq(dS.center.y,dT.center.y)and dq(dS.center.z,dT.center.z)and dq(dS.GM,dT.GM)end;local function dU(dV,dW,dX,dY,dZ)assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(dX),'Argument 3 (radius) must be a number:'..type(dX))assert(du(dY),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dY))assert(dt(dZ),'Argument 5 (GM) must be a number:'..type(dZ))return setmetatable({systemId=dn(dV),id=dn(dW),radius=dn(dX),center=vec3(dY),GM=dn(dZ)},dO)end;local d_={}d_.__index=d_;d_.__tostring=function(di)return dl('::pos{%d,%d,%s,%s,%s}',di.systemId,di.id,dG(di.latitude*dC),dG(di.longitude*dC),dG(di.altitude))end;d_.__eq=function(dS,dT)return dS.id==dT.id and dS.systemId==dT.systemId and dq(dS.latitude,dT.latitude)and dq(dS.altitude,dT.altitude)and(dq(dS.longitude,dT.longitude)or dq(dS.latitude,math.pi/2)or dq(dS.latitude,-math.pi/2))end;local function e0(e1,dW,e2,e3,e4)local dV=e1;if dw(e1)and not e3 and not e4 and not dW and not e2 then dV,dW,e2,e3,e4=e5(e1,dF)assert(dV,'Argument 1 (position string) is malformed.')else assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(e2),'Argument 3 (latitude) must be in degrees:'..type(e2))assert(dt(e3),'Argument 4 (longitude) must be in degrees:'..type(e3))assert(dt(e4),'Argument 5 (altitude) must be in meters:'..type(e4))end;dV=dn(dV)dW=dn(dW)e2=dn(e2)e3=dn(e3)e4=dn(e4)if dW==0 then return setmetatable({latitude=e2,longitude=e3,altitude=e4,id=dW,systemId=dV},d_)end;return setmetatable({latitude=dB*dm(e2,-90,90),longitude=dB*(e3%360),altitude=e4,id=dW,systemId=dV},d_)end;local e6={}e6.__index=e6;e6.__tostring=function(dJ,dP)local e7=dP and dP..'  'local e8={}local dQ={}for dM in pairs(dJ)do table.insert(dQ,dM)end;table.sort(dQ)for dR,e9 in ipairs(dQ)do ea=dJ[e9]local eb=dO.__tostring(ea,e7)if dP then table.insert(e8,dl('[%s]={\n%s\n%s}',e9,eb,dP))else table.insert(e8,dl('  [%s]=%s',e9,eb))end end;if dP then return dl('\n%s%s%s',dP,table.concat(e8,',\n'..dP),dP)end;return dl('{\n%s\n}',table.concat(e8,',\n'))end;local function ec(ed)local e={}local pid;for dR,dy in pairs(ed)do local dW=dy.planetarySystemId;if type(dW)~='number'then error('Invalid planetary s ID: '..tostring(dW))elseif pid and dW~=pid then error('Mistringmatch planetary s IDs: '..dW..' and '..pid)end;local ee=dy.bodyId;if type(ee)~='number'then error('Invalid body ID: '..tostring(ee))elseif e[ee]then error('Duplicate body ID: '..tostring(ee))end;setmetatable(dy.center,getmetatable(vec3.unit_x))e[ee]=setmetatable(dy,dO)pid=dW end;return setmetatable(e,e6)end;ef={}local function eg(ed)return setmetatable({galaxyAtlas=ed or{}},ef)end;ef.__index=function(dv,M)if type(M)=='number'then local a=dv.galaxyAtlas[M]return ec(a)end;return rawget(ef,M)end;ef.__pairs=function(dJ)return function(dv,dM)local eh,ei=next(dv,dM)return eh,ei and ec(ei)end,dJ.galaxyAtlas,nil end;ef.__tostring=function(dJ)local ej={}for dR,ek in pairs(dJ or{})do local el=ek:getPlanetarySystemId()local em=e6.__tostring(ek,'    ')table.insert(ej,dl('  [%s]={%s\n  }',el,em))end;return dl('{\n%s\n}\n',table.concat(ej,',\n'))end;ef.BodyParameters=dU;ef.MapPosition=e0;ef.PlanetarySystem=ec;function ef.createBodyParameters(dV,dW,en,eo,ep,eq,er)assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(en),'Argument 3 (surfaceArea) must be a number:'..type(en))assert(du(eo),'Argument 4 (aPosition) must be an array or vec3:'..type(eo))assert(du(ep),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ep))assert(dt(eq),'Argument 6 (altitude) must be in meters:'..type(eq))assert(dt(er),'Argument 7 (gravityAtPosition) must be number:'..type(er))local dX=dp(en/4/math.pi)local cc=dX+eq;local es=vec3(eo)+cc*vec3(ep)local dZ=er*cc*cc;return dU(dV,dW,dX,es,dZ)end;ef.isMapPosition=dz;function ef:getPlanetarySystem(e1)if M==nil then M=0 end;if ei==nil then ei=0 end;local dV=e1;if dz(e1)then dV=e1.systemId end;if type(dV)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(ei)~=e6 then a=ec(a)end;return a end end end;function e6:sizeCalculator(et)return 1.05*et.radius end;function e6:castIntersections(eu,ev,ew,ex,ey,ez)local eA={}if ey then for dR,et in pairs(ey)do table.insert(eA,et)end else eA=d5 end;if not ez then table.sort(eA,function(eB,eC)local eD=eB.center;local eE=eC.center;return(eD.x-eu.x)^2+(eD.y-eu.y)^2+(eD.z-eu.z)^2<(eE.x-eu.x)^2+(eE.y-eu.y)^2+(eE.z-eu.z)^2 end)end;local eF=ev:normalize()for dR,et in ipairs(eA)do local eG=et.center-eu;local dX;if ew then dX=ew(et)else dX=self:sizeCalculator(et)end;local eH=eG:dot(eF)local eI=eH^2-(eG:len2()-dX^2)if eI>=0 then local eJ=dp(eI)local eK=eH+eJ;local eL=eH-eJ;if eL>0 then return et,eK,eL elseif eK>0 then return et,eK,nil end end end;return nil,nil,nil end;function e6:closestBody(eM)assert(type(eM)=='table','Invalid coordinates.')local eN,et;local eO=vec3(eM)for dR,eP in pairs(self)do local eQ=(eP.center-eO):len2()if(not et or eQ<eN)and eP.name~="Space"then et=eP;eN=eQ end end;return et end;function e6:convertToBodyIdAndWorldCoordinates(e1)local eR=e1;if dw(e1)then eR=e0(e1)end;if eR.id==0 then return 0,vec3(eR.latitude,eR.longitude,eR.altitude)end;local eP=self:getBodyParameters(eR)if eP then return eR.id,eP:convertToWorldCoordinates(eR)end end;function e6:getBodyParameters(e1)local dW=e1;if dz(e1)then dW=e1.id end;assert(dt(dW),'Argument 1 (id) must be a number:'..type(dW))return self[dW]end;function e6:getPlanetarySystemId()local dR,dy=next(self)return dy and dy.systemId end;function dO:convertToMapPosition(dY)assert(du(dY),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dY))local eS=vec3(dY)if self.id==0 then return setmetatable({latitude=eS.x,longitude=eS.y,altitude=eS.z,id=0,systemId=self.systemId},d_)end;local eT=eS-self.center;local cc=eT:len()local e4=cc-self.radius;local e2=0;local e3=0;if not dq(cc,0)then local eU=eV(eT.y,eT.x)e3=eU>=0 and eU or 2*math.pi+eU;e2=math.pi/2-math.acos(eT.z/cc)end;return setmetatable({latitude=e2,longitude=e3,altitude=e4,id=self.id,systemId=self.systemId},d_)end;function dO:convertToWorldCoordinates(e1)local eR=dw(e1)and e0(e1)or e1;if eR.id==0 then return vec3(eR.latitude,eR.longitude,eR.altitude)end;assert(dz(eR),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eR.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eR.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eW=math.cos(eR.latitude)return self.center+(self.radius+eR.altitude)*vec3(eW*math.cos(eR.longitude),eW*math.sin(eR.longitude),math.sin(eR.latitude))end;function dO:getAltitude(dY)return(vec3(dY)-self.center):len()-self.radius end;function dO:getDistance(dY)return(vec3(dY)-self.center):len()end;function dO:getGravity(dY)local eX=self.center-vec3(dY)local eY=eX:len2()return self.GM/eY*eX/dp(eY)end;return setmetatable(ef,{__call=function(dR,...)return eg(...)end})end;local function eZ(d,b,c,a,dp,e_)local cq={}local f0=100;function cq.computeAccelerationTime(f1,f2,f3)return(f3-f1)/f2 end;function cq.computeDistanceAndTime(f1,f3,f4,f5,f6,f7)f6=f6 or 0;f7=f7 or 0;local f8=f1<f3;local f9=f5/(f8 and f4 or-f4)local fa=-f7/f4;local fb=f9+fa;if f1==f3 then return 0,0 elseif f8 and fb<=0 or not f8 and fb>=0 then return-1,-1 end;local fc,fd=0,0;if f9~=0 and f6>0 then local fe=math.pi/f6/2;local dy=function(dv)return f9*(dv/2-f6*math.sin(fe*dv)/math.pi)+fa*dv+f1 end;local ff=f8 and function(a)return a>=f3 end or function(a)return a<=f3 end;fd=2*f6;if ff(dy(fd))then local fg=0;while math.abs(fd-fg)>0.25 do local dv=(fd+fg)/2;if ff(dy(dv))then fd=dv else fg=dv end end end;local fh=2*f9*f6^2/math.pi^2;fc=fh*(math.cos(fe*fd)-1)+(f9+2*fa)*fd^2/4+f1*fd;if fd<2*f6 then return fc,fd end;f1=dy(fd)end;local eD=f9+fa;local dv=cq.computeAccelerationTime(f1,eD,f3)local fi=f1*dv+eD*dv*dv/2;return fc+fi,fd+dv end;function cq.computeTravelTime(f1,f2,cc)if cc==0 then return 0 end;if f2~=0 then return(math.sqrt(2*f2*cc+f1^2)-f1)/f2 end;assert(f1>0,'Acceleration and initial speed are both zero.')return cc/f1 end;return cq end;local function fj(d,b,c,a,dl,dm,dn,dp,dq)local vec3=vec3;local dk=dk(d,b,c,a,dl,dm,dn,dp,dq)local function dw(a)return type(a)=='string'end;local function du(dv)return type(dv)=='table'end;fk={}fk.__index=fk;function fk:escapeAndOrbitalSpeed(e4)assert(self.body)local cc=e4+self.body.radius;if not dq(cc,0)then local fl=dp(self.body.GM/cc)return dp(2)*fl,fl end;return nil,nil end;function fk:orbitalParameters(e1,fm)assert(self.body)assert(du(e1)or dw(e1))assert(du(fm))local fn=(dw(e1)or dk.isMapPosition(e1))and self.body:convertToWorldCoordinates(e1)or vec3(e1)local dy=vec3(fm)local fo=fn-self.body.center;local fp=dy:len2()local fi=fo:len()local fq=self.body.GM;local fr=((fp-fq/fi)*fo-fo:dot(dy)*dy)/fq;local eD=fq/(2*fq/fi-fp)local fs=fr:len()local eF=fr:normalize()local ft=eD*(1-fs)local fu=eD*(1+fs)local fv=ft*eF+self.body.center;local fw=fs<=1 and-fu*eF+self.body.center or nil;local fx=dp(eD*fq*(1-fs*fs))local fy=fw and 2*math.pi*dp(eD^3/fq)local fz=math.acos(fr:dot(fo)/(fs*fi))if fo:dot(dy)<0 then fz=-(fz-2*math.pi)end;local fA=math.acos((math.cos(fz)+fs)/(1+fs*math.cos(fz)))local fB=fA;if fB<0 then fB=fB+2*math.pi end;local fC=fB-fs*math.sin(fB)local fD=0;local fE=0;local fF=0;if fy~=nil then fD=fC/(2*math.pi/fy)fE=fy-fD;fF=fE+fy/2;if fz-math.pi>0 then fE=fD;fF=fE+fy/2 end;if fF>fy then fF=fF-fy end end;return{periapsis={position=fv,speed=fx/ft,circularOrbitSpeed=dp(fq/ft),altitude=ft-self.body.radius},apoapsis=fw and{position=fw,speed=fx/fu,circularOrbitSpeed=dp(fq/fu),altitude=fu-self.body.radius},currentVelocity=dy,currentPosition=fn,eccentricity=fs,period=fy,eccentricAnomaly=fA,meanAnomaly=fC,timeToPeriapsis=fE,timeToApoapsis=fF,trueAnomaly=fz}end;local function fG(fH)local eP=dk.BodyParameters(fH.systemId,fH.id,fH.radius,fH.center,fH.GM)return setmetatable({body=eP},fk)end;return setmetatable(fk,{__call=function(dR,...)return fG(...)end})end;local function fI(d,b,c,a,dbHud_1,e,fJ,fK,bO,dn,dp,fL,fM,dj)local function fN(fO)local di=fP:closestBody(fO)if(fO-di.center):len()>di.radius+di.noAtmosphericDensityAltitude then di=e[0][0]end;return di end;local function fQ()local function fR(fS,fT)return fS.name<fT.name end;cV={}for dM,dy in pairs(e[0])do cV[#cV+1]={name=dy.name,index=dM}end;table.sort(cV,fR)end;local function fU(fV,fW)if not fW then fW=fX.name end;for dM,dy in pairs(fV)do if dy.name and dy.name==fW then return dM end end;return-1 end;local function fY()d2=bn;if bn==0 then bl="None"c9=nil;fX=nil;return true end;local fZ=cV[bn].index;local f_=e[0][fZ]if f_.center then bl=f_.name;c9=cp[0][fZ]if fX~=nil then if ci==0 then if fJ(g0,g1)~=1 then fK(g0,g1)end;if fJ(g2,g3)~=1 then fK(g2,g3)end;if fJ(g4,g5)~=1 then fK(g4,g5)end;if fJ(g6,g7)~=1 then fK(g6,g7)end;if fJ(g8,g9)~=1 then fK(g8,g9)end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end;if fJ(ge,gf)~=1 then fK(ge,gf)end end;fX=nil else fX=f_;for dR,dy in pairs(cp[0])do if dy.name==fX.planetname then c9=dy;bl=fX.name;break end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end end;if fX==nil then bm=vec3(c9.center)else bm=fX.position end;if c9.planetname~="Space"then if c9.hasAtmosphere then gg=bO(c9.radius*(U-1)+c9.noAtmosphericDensityAltitude)else gg=bO(c9.radius*(U-1)+c9.surfaceMaxAltitude)end else gg=T end;if fX~=nil and fX.planetname=="Space"then bh=0 else dR,bh=cr(c9):escapeAndOrbitalSpeed(gg)end;bj=0;bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"return true end;local function gh(gi)if not b5 and not bs and not ce and not bB and not ba and not cf then if gi==nil then bn=bn+1;if bn>#cV then bn=0 end else bn=bn-1;if bn<0 then bn=#cV end end;if bn==0 then fY()else local fZ=cV[bn].index;local f_=e[0][fZ]if f_ and(f_~=nil and f_.name=="Space"or bC=="Custom Only"and f_.center or bC=="No Moons-Asteroids"and(string.find(f_.name,"Moon")~=nil or string.find(f_.name,"Asteroid")~=nil))then if gi==nil then gh()else gh(1)end else fY()end end else dj("Disengage autopilot before changing Interplanetary Helper")fL("iph","AP")end end;local function gj()local function gk(gl)local gm;if gl then gm=da else gm=br end;local gn=-1;gn=fU(e[0])if gn>-1 then table.remove(e[0],gn)end;gn=-1;gn=fU(gm)if gn~=-1 then dj(fX.name.." saved location cleared")table.remove(gm,gn)end;gh()fQ()return gm end;if string.sub(bl,1,1)=="*"then da=gk(true)else br=gk(false)end end;local function go(gp,fO,gq,gr)local function gs(gl)if gl then gm=da else gm=br end;if dbHud_1 or gq or gl then local di=fN(fO)local gt={position=fO,name=gp,planetname=di.name,gravity=b.getGravityIntensity(),safe=gr}if not gq then gm[#gm+1]=gt else for dM,dy in pairs(e[0])do if dy.name and gp==dy.name then table.remove(e[0],dM)end end end;table.insert(e[0],gt)fQ()fY()dj("Location saved as "..gp.."("..di.name..")")return gm else dj("Databank must be installed to save permanent locations")end end;if string.sub(gp,1,1)=="*"then da=gs(true)else br=gs(false)end end;local gu={}function gu.UpdateAtlasLocationsList()fQ()end;function gu.UpdateAutopilotTarget()fY()end;function gu.adjustAutopilotTargetIndex(gi)gh(gi)end;function gu.findAtlasIndex(fV,fW)return fU(fV,fW)end;function gu.UpdatePosition(gv,gw,gx)local function gy(gl)local gm;if gl then gm=da else gm=br end;local gn=fU(gm)if gn~=-1 then if gv~=nil then if gl then gv="*"..gv end;gm[gn].name=gv;bn=bn-1;gh()elseif gx~=nil then if gx then local gz=cj;if gz<1000 then gz=1000 end;gm[gn].agg=fM(gz,0)dj(gm[gn].name.." AGG Altitude:"..gm[gn].agg.." saved ("..gm[gn].planetname..")")return elseif gx==false then gm[gn].agg=nil;dj(gm[gn].name.." AGG Altitude cleared ("..gm[gn].planetname..")")return end else local gA=gm[gn]if gw then gA.heading=cJ:cross(cN)*5000;dj(gm[gn].name.." heading saved ("..gm[gn].planetname..")")return elseif gw==false then gA.heading=nil;dj(gm[gn].name.." heading cleared ("..gm[gn].planetname..")")return end;gA.gravity=b.getGravityIntensity()gA.position=cP;gA.safe=true end;dj(gm[gn].name.." position updated ("..gm[gn].planetname..")")else dj("Name Not Found")end end;if string.sub(bl,1,1)=="*"then gy(true)else gy(false)end end;function gu.AddNewLocation(gp,fO,gq,gr)go(gp,fO,gq,gr)end;function gu.ClearCurrentPosition()gj()end;for dM,dy in pairs(db)do table.insert(e[0],dy)end;if gB then for dM,dy in pairs(gB)do gu[dM]=dy end end;fQ()if bn>#cV then bn=0 end;gu.UpdateAutopilotTarget()return gu end;local function gC(b,a,c,radar_1,radar_2,warpdrive,e_,gD,dp,gE,dn,gF,fL,dj)local gG={}local gH={}local gI={XS=13,S=27,M=55,L=110,XL=221}local gJ={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gK={}local gL=0;local gM;local gN;local gO=0;local gP;local gQ={gP}local gR="Atmo"local gS;local gT;local gU=0;local gV={}local gW;local gX=0;local gY=table.insert;local gZ=-4;local g_={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h0,h1;local h2,h3;local h4;local h5;local h6;local h7;local h8;local h9;local ha;local function hb()if hc~=nil and gU==0 then gD(hc)a.destroyWidget(h0)a.destroyData(h2)h0,h2,hc=nil,nil,nil;if gT~=nil then gD(gT)a.destroyWidget(h1)a.destroyData(h3)gT,h1,h3=nil,nil,nil end else if gU==1 then gT=a.createWidgetPanel("PeriWinkle")h1=a.createWidget(gT,'periscope')h3=gP.getWidgetDataId()a.addDataToWidget(h3,h1)end;if hc==nil and gL>0 then hc=a.createWidgetPanel(gR)h0=a.createWidget(hc,'radar')h2=gP.getWidgetDataId()a.addDataToWidget(h2,h0)end;gU=0 end end;local function hd()local function he(hf,hg,hh,hi,hj,hk,hl,hm)hg,hi,hk,hm=vec3(hg),vec3(hi),vec3(hk),vec3(hm)local hn,ho,hp=hf*hf,hh*hh,hj*hj;local fp=hi-hg;local hq=fp:normalize()local hr=fp:len()local hs=hk-hg;local ht=(hs-hs:project_on(hq)):normalize()local hu,hv=hs:dot(hq),hs:dot(ht)local hw=hu*hu+hv*hv;local hx=hq:cross(ht)local hy=(hn-ho+hr*hr)/(2*hr)local hz=(hn-hp+hw-2*hu*hy)/(2*hv)local dA=hn-hy^2-hz^2;local hA=dp(dA)local hB=hg+hq*hy+ht*hz+hx*hA;local hC=hg+hq*hy+ht*hz-hx*hA;if e_((hm-hB):len()-hl)<e_((hm-hC):len()-hl)then return hB else return hC end end;local function hD(hE,fi,hF)local hG=hE.pts;local gn=#hG;local hH=hE.ref;if gn>3 then local hI,hJ,hK,hL=hG[gn],hG[gn-1],hG[gn-2],hG[gn-3]hE.ref=hF;local fn=he(hI[1],hI[2],hJ[1],hJ[2],hK[1],hK[2],hL[1],hL[2])local hy,hz,hA=fn.x,fn.y,fn.z;if hy==hy and hz==hz and hA==hA then hy=hy+hH[1]hz=hz+hH[2]hA=hA+hH[3]local hM=vec3(hy,hz,hA)hE.center=hM;if hE.lastPos then if(hE.lastPos-hM):len()<2 then local hN=(hM-vec3(hF)):len()if e_(hN-fi)<10 then hE.skipCalc=true end end end;hE.lastPos=hM end;hE.pts={}else local hO={hF[1]-hH[1],hF[2]-hH[2],hF[3]-hH[3]}hG[gn+1]={fi,hO}end end;if radar_1 or radar_2 then cv.assignRadar()end;if gP then if#gW>0 then local hP,hQ=0,0;local hR=cM*10;local cZ=cZ;gO,gN=0,0;gH={}for dR,dy in pairs(gW)do local cc=h8(dy)if cc>0.0 then if h4(dy)==1 then gY(gH,dy)end;if not cW and warpdrive and cc<aa and warpdrive.getStatus()==15 then dj("INITIATING WARP")c5=7;warpdrive.initiate()end;local hS=F and h6(dy)==1;if E or hS then local hT=h9(dy)local hU=gI[hT]local hV=h5(dy)if hS or cc<hR and(hU>27 or hV==4 or hV==6)then gO=gO+1;local hF={cP["x"],cP["y"],cP["z"]}local hE=gV[dy]if hE==nil then hU=hU+gF;gV[dy]={pts={},ref=hF,name=h7(dy),i=0,radius=hU,skipCalc=false}hE=gV[dy]end;if not hE.skipCalc then if hS or hV==4 or hV==6 then hE.center=vec3(ha(dy))hE.skipCalc=true else hD(hE,cc,hF)hQ=hQ+1 end;if hS and not hE.abandoned then local bR=a.getArkTime()if gX+5<bR then gX=bR;fL("abRdr","RD")end;a.print("Abandoned Construct: "..hE.name.." ("..hT.." "..gJ[hV]..") at ::pos{0,0,"..hE.center.x..","..hE.center.y..","..hE.center.z.."}")dj("Abandoned Radar Contact ("..hT.." "..gJ[hV]..") detected")hE.abandoned=true end else gY(gK,hE)end end;hP=hP+1;if hP>300 or hQ>30 then coroutine.yield()hP,hQ=0,0 end end end end;gN=#gK;if gN>0 and(cM>20 or b8)then local et,hW,hX,hY;local hZ=0;local h_=cp:getPlanetarySystem(0)hY=cL:normalize()while hZ<gN do coroutine.yield()local i0={table.unpack(gK,hZ,math.min(hZ+75,gN))}et,hW,hX=h_:castIntersections(cP,hY,nil,nil,i0,true)if et and hX then d0={et,hW,hX}break end;hZ=hZ+75 end;if not et then d0=nil end else d0=nil end;gK={}gM=gP.getTargetId()end end end;local function i1()if gP then gR="Atmo"if string.find(gP.getName(),"Space")then gR="Space"end end end;function gG.pickType()i1()end;function gG.assignRadar()if radar_2 and gZ~=1 then if gZ==-1 then if gP==radar_2 then gP=radar_1 else gP=radar_2 end end;gQ={gP}h4=gP.hasMatchingTransponder;h5=gP.getConstructKind;h6=gP.isConstructAbandoned;h7=gP.getConstructName;h8=gP.getConstructDistance;h9=gP.getConstructCoreSize;ha=gP.getConstructWorldPos;gW=gP.getConstructIds()i1()else gW=gP.getConstructIds()end;gZ=gP.getOperationalState()end;function gG.UpdateRadar()local i2=coroutine.status(gS)if i2=="suspended"then local dN,i3=coroutine.resume(gS)if i3 then a.print("ERROR UPDATE RADAR: "..i3)end elseif i2=="dead"then gS=coroutine.create(hd)local dN,i3=coroutine.resume(gS)end end;function gG.GetRadarHud(i4,i5,ay,az)local i6,dj;local dE=gN or 0;gL=#gW;if gL>0 then if E then dj=dE.."/"..gO.." Known/InRange : "..gL.." Total"else dj="Radar Contacts: "..gL end;i6=gE(ay,az,dj,"pbright txtbig txtmid")if#gH>0 then i6=i6 ..gE(i4,i5,"Friendlies In Range","pbright txtbig txtmid")for dM,dy in pairs(gH)do i5=i5+20;i6=i6 ..gE(i4,i5,gP.getConstructName(dy),"pdim txtmid")end end;local i7=#gP.getIdentifiedConstructIds()if gT==nil and i7>0 then gU=1;cv.ToggleRadarPanel()end;if gT~=nil and i7==0 then cv.ToggleRadarPanel()end;if hc==nil then if w then cv.ToggleRadarPanel()end end else if gZ~=1 then i6=gE(ay,az,gR.." Radar: "..g_[gZ],"pbright txtbig txtmid")else i6=gE(ay,az,"Radar: No "..gR.." Contacts","pbright txtbig txtmid")end;if hc~=nil then gU=0;cv.ToggleRadarPanel()end end;return i6 end;function gG.GetClosestName(gp)if gP then local i8=gP.getConstructName(gP.getConstructIds()[1])if i8 then gp=gp.." "..i8 end end;return gp end;function gG.ToggleRadarPanel()hb()end;function gG.ContactTick()if not i9 then i9=0 end;if bR>i9+10 then dj("Radar Contact")fL("rdrCon","RC")i9=bR end;c.stopTimer("contact")end;function gG.onEnter(dW)if gP and not ch and not cW then c.setTimer("contact",0.1)end end;function gG.onLeave(dW)if gP and E then if#gV>650 then dW=tostring(dW)gV[dW]=nil end end end;local function ia()gP=nil;if radar_2 and radar_2.getOperationalState()==1 then gP=radar_2 else gP=radar_1 end;gZ=gP.getOperationalState()h4=gP.hasMatchingTransponder;h5=gP.getConstructKind;h6=gP.isConstructAbandoned;h7=gP.getConstructName;h8=gP.getConstructDistance;h9=gP.getConstructCoreSize;ha=gP.getConstructWorldPos;gQ={gP}gW=gP.getConstructIds()i1()gS=coroutine.create(hd)if ib then for dM,dy in pairs(ib)do gG[dM]=dy end end end;ia()return gG end;local function ic(shield,e5,bO,dj)local id={}local ie=shield.getResistancesCooldown()local function ig()local ih=shield.isActive()if G then if not cW and ih==0 and shield.isVenting()~=1 then shield.toggle()elseif cW and ih==1 then shield.toggle()end end end;local function ii()local ij=shield.getStressRatioRaw()local ik=0.5999;if ij[1]==0.0 and ij[2]==0.0 and ij[3]==0.0 and ij[4]==0.0 then return end;local il=shield.setResistances(ik*ij[1],ik*ij[2],ik*ij[3],ik*ij[4])if il==1 then dj("Shield Resistances updated")else dj("Value Exceeded. Failed to update Shield Resistances")end end;function id.shieldTick()dh=bO(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ig()ie=shield.getResistancesCooldown()if ie==0 and dh<a9 then ii()end end;function id.setResist(im)if not shield then dj("No shield found")return elseif im==nil or ie>0 then dj("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF=dE..', '..dE..', '..dE..', '..dE;local io,ip,iq,ir=e5(im,dF)if ir==nil or io+ip+iq+ir>0.6 then dj("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(io,ip,iq,ir)==1 then dj("Shield Resistances set")else dj("Resistance setting failed.")end end;function id.ventShield()local is=shield.getVentingCooldown()if is>0 then dj("Cannot vent again for "..is.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()dj("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else dj("Shields already at max hitpoints")end end;if it then for dM,dy in pairs(it)do id[dM]=dy end end;return id end;local function iu(d,b,c,a,e,antigrav,hover,shield,warpdrive,iv,e_,bO,dl,iw,bP,ix,iy,eV,bN,dm,iz,fK,fJ,gD,iA,dp,fM,gE,fL,iB,iC,iD,iE,iF,iG,dj)local bQ=DUConstruct;local iH=9.80665;local iI={}local iJ={}local iK={}local iL={}local iM=nil;local iN=nil;local iO=nil;local iP=false;local iQ="none"local iR=""local iS=55;local iT=0;local iU=0;local iV=nil;local iW=ag;local iX=ah;local iY=ai;local iZ=[[rgb(]]..bO(iW+0.5)..","..bO(iX+0.5)..","..bO(iY+0.5)..[[)]]local i_=[[rgb(]]..bO(iW*0.9+0.5)..","..bO(iX*0.9+0.5)..","..bO(iY*0.9+0.5)..[[)]]local j0=0;local j1=0;local j2=""local j3=bN()local j4=false;local j5=false;local gP=false;local function j6(dy)if ad==1920 then return dy else return fM(ad*dy/1920,0)end end;local function j7(dy)if ae==1080 then return dy else return fM(ae*dy/1080,0)end end;local function j8()return iA()==0 and g~="keyboard"and iy()==0 end;local function j9()local ja="TRAVEL"if not cS then ja="CRUISE"end;if b5 then ja="AUTOPILOT"end;return ja end;local i6=""local jb=""local jc=""local jd=1;local je=2;local jf=3;local jg=4;local jh=5;local ji=6;local jj=7;local jk=""local jl=0;local jm=90.0*aU;local jn={}local jo={}local jp={}local jq={}local jr={}local js={}local jt={}jt["atmofueltank"],jt["spacefueltank"],jt["rocketfueltank"]=0,0,0;local ju=0;local function jv(hy,jw,jx,jy,jz,jA)local jB=ju;local jC=ju+5;if not B then jC=jC+5 end;if iy()==1 and not m then jB=jB-50;jC=jC-50 end;if jx=="ATMO"then jk="atmofueltank"elseif jx=="SPACE"then jk="spacefueltank"else jk="rocketfueltank"end;jl=_G[jk.."_size"]if#jy>0 then for M=1,#jy do local gp=jy[M][je]local jD=jy[M][jj]for jE=1,jl do if jy[M][je]==iw(c[jk.."_"..jE].getWidgetData()).name then jD=jE;break end end;local jF=bN()if jz[M]==nil or jA[M]==nil or jF-jy[M][ji]>jm then local jG;local jH=0;jH=ix(jy[M][jd])-jy[M][jg]jG=jy[M][jh]local jI=jG>jH or false;if jI then jt[jk]=jt[jk]+jG-jH end;if jD~=0 then local jJ=iw(c[jk.."_"..jD].getWidgetData())jA[M]=jJ.percentage;jz[M]=jJ.timeLeft;if jz[M]=="n/a"then jz[M]=0 end else jA[M]=bO(0.5+jH*100/jy[M][jf])if jI then jz[M]=bO(0.5+jH/((jG-jH)/(jF-jy[M][ji])))else jz[M]=0 end end;jy[M][ji]=jF;jy[M][jh]=jH end;if gp==jw then gp=dl("%s %d",jx,M)end;if jD==0 then gp=gp.." *"end;local jK;jK=iE(jz[M])if jz[M]==0 or jK==">1y"then jK=""end;if jA[M]~=nil then local jL=bO(jA[M]*2.55)local jM=dl("rgb(%d,%d,%d)",255-jL,jL,0)local jN=""if jK~=""and jz[M]<120 or jA[M]<5 then jN="red "end;local jO=dl("rgb(%d,%d,%d)",dm(bO((255-jL)/2.55),50,100),dm(bO(jL/2.55),0,50),50)local jP="rgb(196,0,255)"if jx=="ATMO"then jP="rgb(0,188,255)"elseif jx=="SPACE"then jP="rgb(239,255,0)"end;local jQ=false;if jR~=jP then jQ=true end;jR=jP;if B then if jQ then jB=jB-5;jC=jC-5 end;jb=jb..dl([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jO,jP,hy,jC,jM,bO(jA[M]*1.7+0.5)-2,hy+1,jC+1,hy+5,jC+14,gp,jA[M],jK)jB=jB-22;jC=jC-22 else jb=jb..gE(hy,jB,gp,jN.."pdim txtfuel")jb=jb..gE(hy,jC,dl("%d%% %s",jA[M],jK),"pdim txtfuel","fill:"..jM)jB=jB+30;jC=jC+30 end end end end;ju=jB end;local function jS(jT,e4)if aq==0 and ar==0 then return end;if e4<200000 and not ch or e4 and ch then local jU=0;if e_(cO)>1 then jU=45*math.log(e_(cO),10)if cO<0 then jU=-jU end end;jT[#jT+1]=dl([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bO(cO),bO(jU))end;return jT end;local function jV(jW)local gi=-cN;jW=jW-jW:project_on(gi)local jX=vec3(0,0,1)jX=jX-jX:project_on(gi)local jY=jX:cross(gi)local jU=jX:angle_between(jW)*constants.rad2deg;if jW:dot(jY)<0 then jU=360-jU end;return jU end;local function jZ(jT,am,an,j_,k0,cZ)if af==0 then return end;local k1=af;local k2=20;local k3=bO(j_)if cZ then for M=-45,45,5 do local k4=M;jT[#jT+1]=dl([[<g transform="rotate(%f,%d,%d)">]],k4,am,an)k5=5;if M%15==0 then k5=15 elseif M%10==0 then k5=10 end;jT[#jT+1]=dl([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+k1+k2-k5,am,an+k1+k2)end;jT[#jT+1]=gE(am,an+k1+k2-35,k0,"pdim txt txtmid")jT[#jT+1]=gE(am,an+k1+k2-25,k3 .." deg","pdim txt txtmid")jT[#jT+1]=dl([[<g transform="rotate(%f,%d,%d)">]],-j_,am,an)jT[#jT+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+k1+k2-20,am+5,an+k1+k2-20,am,an+k1+k2-15)jT[#jT+1]="</g>"end;jT[#jT+1]=[[<g style="clip-path: url(#headingClip);">]]local k6=k3;if cZ then k6=jV(cI)end;local k7=20;local k8=bO(k6)local k9=0;local ka=an+k1+k2+20;local kb=am;if k0~="YAW"then ka=j7(130)kb=j6(960)end;local kc=[[<path class="txttick line" d="]]local kd=bO(k8-(k7+10)-k8%5+0.5)for M=kd+70,kd,-5 do local hy=kb-(-M*5+k6*5)if M%10==0 then k9=10;local dE=M;if dE==360 then dE=0 elseif dE>360 then dE=dE-360 elseif dE<0 then dE=dE+360 end;jT[#jT+1]=gE(hy,ka+15,dE,"txtmid bright")elseif M%5==0 then k9=5 end;if k9==10 then kc=dl([[%s M %f %f v %d]],kc,hy,ka-5,k9)else kc=dl([[%s M %f %f v %d]],kc,hy,ka-2.5,k9)end end;jT[#jT+1]=kc..[["/>]]jT[#jT+1]=dl([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kb-5,ka-20,kb+5,ka-20,kb,ka-10)if cZ then k0="HDG"end;jT[#jT+1]=gE(j6(960),j7(100),k8 .."Â°","dim txt txtmid size14","")jT[#jT+1]=gE(j6(960),j7(85),k0,"dim txt txtmid size20","")jT[#jT+1]=[[</g>]]end;local function ke(jT,kf,j_,am,an,cZ,kg,kh)if af==0 then return end;local k1=af;local ki=bO(k1*3/5)if k1>0 then local kj=bO(kf)local k5=0;local kc=dl([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*j_,am,an)if not ch then kc=dl([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;jT[#jT+1]=dl([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k1-1,am,an)jT[#jT+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bO(kj-30-kj%5+0.5),bO(kj+30+kj%5+0.5),5 do if M%10==0 then k5=30 elseif M%5==0 then k5=20 end;local hz=an+-M*5+kf*5;if k5==30 then kc=dl([[%s M %d %f h %d]],kc,am-ki-k5,hz,k5)if ch then jT[#jT+1]=dl([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*j_,am,an,am-ki+10,hz+4,M)jT[#jT+1]=dl([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*j_,am,an,am+ki-10,hz+4,M)if M==0 or M==180 or M==-180 then jT[#jT+1]=dl([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*j_,am,an,am-ki+20,hz,ki*2-40)end else jT[#jT+1]=gE(am-ki+10,hz,M,"pdim txt txtmid")jT[#jT+1]=gE(am+ki-10,hz,M,"pdim txt txtmid")end;kc=dl([[%s M %d %f h %d]],kc,am+ki,hz,k5)else kc=dl([[%s M %d %f h %d]],kc,am-ki-k5,hz,k5)kc=dl([[%s M %d %f h %d]],kc,am+ki,hz,k5)end end;jT[#jT+1]=kc..[["/>]]local kk="PITCH"if not cZ then kk="REL PITCH"end;if kf>90 and not ch then kf=90-(kf-90)elseif kf<-90 and not ch then kf=-90-(kf+90)end;if k1>200 then if ch then if kh>iS then jT[#jT+1]=gE(am,an-15,"Yaw","pdim txt txtmid")jT[#jT+1]=gE(am,an+20,kg,"pdim txt txtmid")end;jT[#jT+1]=dl([[<g transform="rotate(%f,%d,%d)">]],-j_,am,an)else jT[#jT+1]=dl([[<g transform="rotate(0,%d,%d)">]],am,an)end;jT[#jT+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-ki+25,an-5,am-ki+20,an,am-ki+25,an+5,am-ki+50,an+4,kj)jT[#jT+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+ki-25,an-5,am+ki-20,an,am+ki-25,an+5,am+ki-30,an+4,kj)jT[#jT+1]="</g>"end;local kl=bO(k1/3)jT[#jT+1]=dl([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-kl,an,k1-kl)if not ch and cZ then jT[#jT+1]=dl([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*j_,am,an,am-ki+10,an,ki*2-20)end;jT[#jT+1]="</g>"if k1<200 then if ch and kh>iS then jT[#jT+1]=gE(am,an-k1,kk,"pdim txt txtmid")jT[#jT+1]=gE(am,an-k1+10,kj,"pdim txt txtmid")jT[#jT+1]=gE(am,an-15,"Yaw","pdim txt txtmid")jT[#jT+1]=gE(am,an+20,kg,"pdim txt txtmid")else jT[#jT+1]=gE(am,an-k1,kk,"pdim txt txtmid")jT[#jT+1]=gE(am,an-k1+15,kj,"pdim txt txtmid")end end end end;local function km(jT,e4,cZ)local kn=as;local ko=at;if kn==0 and ko==0 then return end;local kp=78;local kq=19;local kr=cg;if cg~=-1 then jT[#jT+1]=gE(kn+kp,ko+kq+20,dl("AGL: %.1fm",cg),"pdim altsm txtend")end;if cZ and(e4<200000 and not ch or e4 and ch)then table.insert(jT,dl([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kn-1,ko-4,kp+2,kq+6,kn+1,ko-1,kp-4,kq))local gn=0;local ks=1;local kt=0;local ku=e4<0;local kv=e4<kw.surfaceMaxAltitude;local kx=9;if ku then kx=0 end;local e4=e_(e4)while gn<6 do local ky=11;local kz=16;local kA=9;local kB=14;local jN="altsm"if gn>2 then kz=kz+3;ky=ky+2;kB=kB+2;kA=kA-6;jN="altbig"end;if ku then jN=jN.." red"elseif kv then jN=jN.." orange"end;local kC=e4/ks%10;local kD=bO(kC)local kE=bO((kD+1)%10)local kF=kt;if gn==0 then kF=kC-kD;if ku then kF=1-kF end end;if ku and(gn==0 or kt~=0)then local gq=kE;kE=kD;kD=gq end;local kG=kz*(kF-1)local kH=kG+kz;local hy=kn+kA+(6-gn)*ky;local hz=ko+kB;jT[#jT+1]=gE(hy,hz+kG,kE,jN)jT[#jT+1]=gE(hy,hz+kH,kD,jN)gn=gn+1;ks=ks*10;if kD==kx then kt=kF else kt=0 end end;table.insert(jT,[[</g></g>]])end end;local function kI(fm)local kJ=-math.deg(eV(fm.y,fm.z))+180;kJ=kJ-90;if kJ<0 then kJ=360+kJ end;if kJ>180 then kJ=-180+kJ-180 end;return-kJ end;local function kK(fm)local k6=math.deg(eV(fm.y,fm.x))-90;if k6<-180 then k6=360+k6 end;return k6 end;local function kL(jT,fm,kh,am,an)if kh>5 and not ch or kh>iS then local k1=af;local kM=20;local kN=20;local kO=kI(fm)local kP=kK(fm)local kQ=14;local kR=kQ/2;local kS=-kP/kN*k1;local kT=kO/kM*k1;local hy=am+kS;local hz=an+kT;local cc=dp(kS^2+kT^2)local kU=[[<circle
                            cx="]]..hy..[["
                            cy="]]..hz..[["
                            r="]]..kR/kQ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hy..[["
                            cy="]]..hz..[["
                            r="]]..kR..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hy-kQ..[[,]]..hz..[[ h ]]..kR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hy+kR..[[,]]..hz..[[ h ]]..kR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hy..[[,]]..hz-kQ..[[ v ]]..kR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cc<k1 then jT[#jT+1]=kU else local jU=eV(kT,kS)local kV=4;local kW=am+k1*math.cos(jU)local kX=an+k1*math.sin(jU)jT[#jT+1]=dl('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jU*180/math.pi,kW,kX,kW-kV,kX-kV/2,kV*2,kV,kW+kV,kX-kV,kV,kV,-kV,kV)end;if not ch then local kY=vec3(fm)kO=kI(-kY)kP=kK(-kY)kS=-kP/kN*k1;kT=kO/kM*k1;hy=am+kS;hz=an+kT;cc=dp(kS^2+kT^2)if cc<k1 then local kZ=[[<circle
                                    cx="]]..hy..[["
                                    cy="]]..hz..[["
                                    r="]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hy..[[,]]..hz-kQ..[[ v ]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hy..[[,]]..hz..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hy..[[,]]..hz..[[)" />
                                <path
                                    d="M ]]..hy-kR..[[,]]..hz..[[ h ]]..kQ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hy..[[,]]..hz..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hy..[[,]]..hz..[[)"/>]]jT[#jT+1]=kZ end end end end;local function k_(jT,ja,l0,l1)if ao==0 and ap==0 then return end;l0=bO(l0+0.5)local jB=ap+10;local jC=ap+20;if iy()==1 and not m then jB=55;jC=65 end;local l2="CRUISE"local c="km/h"local dN=l1;if ja=="TRAVEL"or ja=="AUTOPILOT"then l2="THROT"c="%"dN=l0;local l3="dim"if l0<0 then l3="red"end;jT[#jT+1]=dl([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l3,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-e_(l0),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;jT[#jT+1]=gE(ao+10,jB,l2,"pbright txtstart")jT[#jT+1]=gE(ao+10,jC,dl("%.0f %s",dN,c),"pbright txtstart")if ch and t and cS and bU then l0=bO(bV*100+0.5)local l3="red"if l0<0 then l3="red"end;jT[#jT+1]=dl([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l3,1-e_(l0),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)jT[#jT+1]=gE(ao+10,jB+40,"LIMIT","pbright txtstart")jT[#jT+1]=gE(ao+10,jC+40,l0 .."%","pbright txtstart")end;if ch and t or ba then jT[#jT+1]=gE(ao+10,jB-40,"LIMIT: "..cC.." km/h","dim txtstart")elseif not ch and b5 then jT[#jT+1]=gE(ao+10,jB-40,"LIMIT: "..bO(a1*3.6+0.5).." km/h","dim txtstart")end end;local function l4(jT,l5)if ao==0 and ap==0 then return end;local l6=ap-10;local l7=ao+10;jT[#jT+1]=gE(0,0,"","pdim txt txtend")if iy()==1 and not m then l6=75 end;jT[#jT+1]=gE(l7,l6,bO(l5).." km/h","pbright txtbig txtstart")end;local l8=40;local function l9(jT)jT[#jT+1]=gE(j6(150),j7(1070),dl("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jT[#jT+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jT[#jT+1]=gE(j6(960),j7(550),"Warning: Invalid Control Scheme Detected","warnings")jT[#jT+1]=gE(j6(960),j7(600),"Keyboard Scheme must be selected","warnings")jT[#jT+1]=gE(j6(960),j7(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local la=j6(960)local lb=j7(860)local lc=j7(880)local ld=j7(900)local le=j7(960)local lf=j7(200)local lg=j7(250)local lh=j7(960)if iy()==1 and not m then lb=j7(135)lc=j7(155)ld=j7(175)lf=j7(115)lg=j7(95)end;if b2 then local li=""if type(b2)=="string"then li="-"..b2 end;jT[#jT+1]=gE(la,lb,"Brake Engaged"..li,"warnings")elseif bT>0 then jT[#jT+1]=gE(la,lb,"Auto-Brake Engaged","warnings","opacity:"..bT)end;if ch and cB and cg==-1 then if not b5 and not bs and not b8 and not cR and not bb and not b9 then jT[#jT+1]=gE(la,lf+50,"** STALL WARNING **","warnings")fL("stall","SW",2)end end;if cY then jT[#jT+1]=gE(la,lf+90,"Flight Assist in Progress","warnings")end;if cl then jT[#jT+1]=gE(la,lh,"Gyro Enabled","warnings")end;if lj then l8=l8-1;if l8>20 then jT[#jT+1]=gE(la,lh-20,"ECU Enabled","warnings")elseif l8<0 then l8=40 end end;if bo then if bX then jT[#jT+1]=gE(la,lc,"Gear Extended","warn")else jT[#jT+1]=gE(la,lc,"Landed (G: Takeoff)","warnings")end end;if cg>-1 and(not cR or cj<100)then local lk=iD(d:getTargetGroundAltitude())jT[#jT+1]=gE(la,ld,"Hover Height: "..lk,"warn")end;if c6 then jT[#jT+1]=gE(la,le+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cR and bx~=nil then local ll="warnings"if e_(cj-antigrav.getBaseAltitude())<501 then ll="warn"end;jT[#jT+1]=gE(la,lf+40,dl("Target Altitude: %d Singularity Altitude: %d",bO(bx),bO(antigrav.getBaseAltitude())),ll)end;if b5 and bl~="None"then jT[#jT+1]=gE(la,lf,"Autopilot "..bi,"warn")elseif bv~=nil then jT[#jT+1]=gE(la,lf+20,dl("LockedPitch: %d",bO(bv)),"warn")elseif c1 then jT[#jT+1]=gE(la,lf+20,"Follow Mode Engaged","warn")elseif ba or cf then jT[#jT+1]=gE(la,lf+20,"Re-entry in Progress","warn")end;if b7 or bb then local lk=iD(bc,2)if bb then if cR then lk=iD(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jT[#jT+1]=gE(la,lf,"VTO to "..lk,"warn")elseif(b9 or ce)and not bB then if ce then jT[#jT+1]=gE(la,lf,"Takeoff to "..bl,"warn")else jT[#jT+1]=gE(la,lf,"Takeoff to "..lk,"warn")end;if b2 and not bb then jT[#jT+1]=gE(la,lf+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jT[#jT+1]=gE(la,lf,"Altitude Hold: "..dl("%.1fm",bc),"warn")end end;if bb and(antigrav~=nil and antigrav)then if ci>0.1 then jT[#jT+1]=gE(la,lf+20,"Beginning ascent","warn")elseif ci<0.09 and ci>0.05 then jT[#jT+1]=gE(la,lf+20,"Aligning trajectory","warn")elseif ci<0.05 then jT[#jT+1]=gE(la,lf+20,"Leaving atmosphere","warn")end end;if bB then if cD~=nil then jT[#jT+1]=gE(la,lf,cD,"warn")end end;if b8 then local lm="Brake Landing"if dd then lm=lm.."-Aligning"end;if dc then lm=lm.."-Drift Limited"end;jT[#jT+1]=gE(la,lf,lm,"warnings")end;if b4 then jT[#jT+1]=gE(la,lf+20,"Prograde Alignment","crit")end;if b3 then jT[#jT+1]=gE(la,lf,"Retrograde Alignment","crit")end;if c_ then local type;if string.find(c_,"COLLISION")then type="warnings"else type="crit"end;jT[#jT+1]=gE(la,lg+20,c_,type)elseif ci==0 then local ln,lo=cu.checkLOS(cL:normalize())if lo~=nil then local lk=iD(lo)local lp=cq.computeTravelTime(cM,0,lo)local lq="Collision"if ln.noAtmosphericDensityAltitude>0 then lq="Atmosphere"end;jT[#jT+1]=gE(la,lg+20,ln.name.." "..lq.." "..iE(lp).." In "..lk,"crit")end end;if bs and not bB then jT[#jT+1]=gE(la,lf+60,lr,"warn")end;if d3 and#d3>1 then end;local ls=j6;local lt=j7;local lu="topButton"local lv="topButtonActive"local lw=lu;if b5 or bs or ce or bB then lw=lv end;local lx=lu;if b4 then lx=lv end;local ly=lu;if b8 or bo then ly=lv end;local lz=lu;if b7 or bs then lz=lv end;local lA=lu;if b3 then lA=lv end;local lB=lu;if bB or cF and b5 then lB=lv end;if w and I then local lC=lt(30)jT[#jT+1]=dl([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lw,ls(960),lt(54),lt(-53),ls(-120),ls(25),lt(50))jT[#jT+1]=gE(ls(910),lC,"AUTOPILOT")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lx,ls(865),lt(51),ls(-25),lt(-50),ls(-110),ls(25),lt(46))jT[#jT+1]=gE(ls(800),lC,"PROGRADE")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ly,ls(755),lt(47),ls(-25),lt(-46),ls(-98),ls(44),lt(44))jT[#jT+1]=gE(ls(700),lC,"LAND")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lz,ls(960),lt(54),lt(-53),ls(120),ls(-25),lt(50))jT[#jT+1]=gE(ls(1010),lC,"ALT HOLD")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lA,ls(1055),lt(51),ls(25),lt(-50),ls(110),ls(-25),lt(46))jT[#jT+1]=gE(ls(1122),lC,"RETROGRADE")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lB,ls(1165),lt(47),ls(25),lt(-46),ls(98),ls(-44),lt(44))jT[#jT+1]=gE(ls(1220),lC,"ORBIT")jT[#jT+1]=[[
                                    </g>
                                </g>]]jT[#jT+1]="</g>"end;return jT end;local function lD(kh)return bO(fM(kh*3.6,0)+0.5).." km/h"end;local function lE(gn)local gp=bl;if gn~=nil and type(gn)=="number"then if gn==0 then return"None"end;gp=cV[gn].name end;if gp==nil then gp=fX.name end;if gp==nil then gp="None"end;return gp end;local function lF(jT)local lG=cu.routeWP(true)if not lG or#lG==0 then return end;local hy=j6(750)local hz=j7(360)if b5 or bs then jT[#jT+1]=gE(hy,hz,"REMAINING ROUTE","pdim txtstart size20")else jT[#jT+1]=gE(hy,hz,"LOADED ROUTE","pdim txtstart size20")end;for dM,M in pairs(lG)do hz=hz+20;jT[#jT+1]=gE(hy,hz,dM..". "..lG[dM],"pdim txtstart size20")end end;local function lH(jT)local hy=aC+10;local hz=aD+20;local lI={}local lJ={"Alt-4: AutoTakeoff to Target"}local lK={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lL={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lM={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lI,"--------------DYNAMIC-----------------")if ch then if cg~=-1 then iB(lI,lJ)if c9 and kw and c9.name==kw.name then table.insert(lI,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b1 then if antigrav then if cR then table.insert(lI,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lI,"Turn on AGG to takeoff to AGG Height")end end;if b1 then table.insert(lI,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lI,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lI,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bo then table.insert(lI,"G: Takeoff to hover height, raise gear")else table.insert(lI,"G: Lowergear and Land")end else iB(lI,lK)table.insert(lI,"G: Begin BrakeLanding or Land")end;if bb then table.insert(lI,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iB(lI,lL)if shield then table.insert(lI,"Alt-Shift-6: Vent shields")if not G then table.insert(lI,"Alt-Shift-7: Toggle shield off/on")end end end;if fX~=nil then table.insert(lI,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lI,"Alt-9: Activate Gyroscope")end;if aX~="none"or aW~="none"or aY~="none"then table.insert(lI,"Alt-Shift-9: Cycles engines with Extra tags")end;if b7 then table.insert(lI,"Alt-Spacebar/C will raise/lower target height")table.insert(lI,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not ch then table.insert(lI,"LALT+Mousewheel will lower/raise speed limit")end;iB(lI,lM)for M=1,#lI do hz=hz+12;jT[#jT+1]=gE(hy,hz,lI[M],"pdim txtbig txtstart")end end;local function lN(jT)local lO=aC;local lP=aD;local lQ=aB;local lR=4;local lS=15;local hy=0;local hz=0;local lT,lU,lV,lW;local lX;local function lY(type)local gz,bR,kh,lZ,jN,l_;if type=="Periapsis"then gz=lX.periapsis.altitude;bR=lX.timeToPeriapsis;kh=lX.periapsis.speed;jN="txtend"lZ=12;l_=math.min(hy,lO+lQ-kw.radius/lV-lR*2)else gz=lX.apoapsis.altitude;bR=lX.timeToApoapsis;kh=lX.apoapsis.speed;lZ=-12;jN="txtstart"l_=hy end;if cM<1 then bR=0 end;jT[#jT+1]=dl([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],l_+lZ,hz-5,hy,hz-5)jT[#jT+1]=dl([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],l_-lZ*4,hz+2,hy,hz+2)jT[#jT+1]=gE(l_,hz,type,jN)hy=l_-lZ*2;hz=hz+lS;local lk=iD(gz)jT[#jT+1]=gE(hy,hz,lk,jN)hz=hz+lS;jT[#jT+1]=gE(hy,hz,iE(bR),jN)hz=hz+lS;jT[#jT+1]=gE(hy,hz,lD(kh),jN)end;local m0=lQ*1.5;if bL=="INFO"then m0=25*10 end;if bL=="ORBIT"and cj<kw.spaceEngineMinAltitude then return jT end;if bL~="HIDE"then jT[#jT+1]=[[<g class="pbright txtorb txtmid">]]jT[#jT+1]=dl('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lQ*2,m0,lO,lP)jT[#jT+1]=dl([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lQ*2,m0,lO,lP)end;local m1=lQ*1.5;local m2=lQ*2;local m3=m1/2;local m4=lQ;local m5=lO+m4;local m6=lP+m3;local m7=lO+m2;local m8=lP+m1;if bL=="ORBIT"then lP=lP+lR;lT=lQ/2;lW=0;lX={}lX.periapsis={}lX.apoapsis={}if fl~=nil then if fl.periapsis~=nil then lX.periapsis.altitude=fl.periapsis.altitude;lX.periapsis.speed=fl.periapsis.speed end;if fl.apoapsis~=nil then lX.apoapsis.altitude=fl.apoapsis.altitude;lX.apoapsis.speed=fl.apoapsis.speed end;lX.period=fl.period;lX.eccentricity=fl.eccentricity;lX.timeToApoapsis=fl.timeToApoapsis;lX.timeToPeriapsis=fl.timeToPeriapsis;lX.eccentricAnomaly=fl.eccentricAnomaly;lX.trueAnomaly=fl.trueAnomaly end;if lX.periapsis==nil then lX.periapsis={}lX.periapsis.altitude=-kw.radius;lX.periapsis.speed=a1 end;if lX.eccentricity==nil then lX.eccentricity=1 end;if lX.apoapsis==nil then lX.apoapsis={}lX.apoapsis.altitude=cj;lX.apoapsis.speed=0 end;if cM<1 then lX.apoapsis.altitude=cj;lX.apoapsis.speed=0 end;if lX.apoapsis.altitude then lV=(lX.apoapsis.altitude+lX.periapsis.altitude+kw.radius*2)/(lT*2)lU=(kw.radius+lX.apoapsis.altitude)/lV*(1-lX.eccentricity)lW=lT-lX.periapsis.altitude/lV-kw.radius/lV;local m9=math.pi;if lX.period~=nil and lX.period>0 and lX.timeToApoapsis~=nil then m9=lX.eccentricAnomaly;if lX.timeToPeriapsis<lX.timeToApoapsis then m9=2*math.pi-m9 end end;if cM<1 or m9~=m9 then m9=math.pi end;local ma=-lT*math.cos(m9)+lO+m4+lR;local mb=lU*math.sin(m9)+lP+m3+lR;local mc=""jT[#jT+1]='<g clip-path="url(#orbitRect)">'jT[#jT+1]=dl([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mc,lO+lQ+lR,lP+lQ*1.5/2+lR,lT,lU)if lU<1 then jT[#jT+1]=dl([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lO+lQ+lR-lW,lP+lQ*1.5/2+lR,ma,mb)end;jT[#jT+1]=dl('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lO+lQ+lR-lW,lP+lQ*1.5/2+lR,(kw.radius+kw.noAtmosphericDensityAltitude)/lV)jT[#jT+1]=dl('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lO+lQ+lR-lW,lP+lQ*1.5/2+lR,(kw.radius+kw.noAtmosphericDensityAltitude)/lV)jT[#jT+1]=dl([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lO+lQ+lR,lP+lQ*1.5/2+lR,lT,lU)jT[#jT+1]=dl('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lO+lQ+lR-lW,lP+lQ*1.5/2+lR,kw.radius/lV)jT[#jT+1]='</g>'local md=math.floor(kw.radius/lV+0.5)hy=lO+lQ+lR*4+lT;hz=lP+lQ*1.5/2+5+lR;if lX.apoapsis~=nil and lX.apoapsis.speed<a1 then lY("Apoapsis")end;hz=lP+lQ*1.5/2+5+lR;hy=lO+lQ-lR*2-lT;if lX.periapsis~=nil and lX.periapsis.speed<a1 and lX.periapsis.altitude>0 then lY("Periapsis")end;jT[#jT+1]=gE(lO+lQ+lR,lP+20+lR,kw.name,"txtorbbig")jT[#jT+1]=dl('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',ma,mb)jT[#jT+1]=[[</g>]]return jT else jT[#jT+1]='<g clip-path="url(#orbitRect)">'local me=""local mf=1.2*(mg-mh)/(lQ*2)local mi=1.4*(mj-mk)/(lQ*1.5)for dM,dy in pairs(e[0])do if dy.center then local hy=lO+lQ+dy.center.x/mf;local hz=lP+lQ*1.5/2+dy.center.y/mi;me=me..'<circle cx="'..hy..'" cy="'..hz..'" r="'..dy.radius/mf*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dy.name,"Moon")and not string.match(dy.name,"Sanctuary")and not string.match(dy.name,"Space")then me=me.."<text x='"..hy.."' y='"..hz+dy.radius/mf*30+20 .."' font-size='12' fill="..iZ.." text-anchor='middle' font-family='Montserrat'>"..dy.name.."</text>"end end end;local fn=vec3(bQ.getWorldPosition())local hy=lO+lQ+fn.x/mf;local hz=lP+lQ*1.5/2+fn.y/mi;me=me..'<circle cx="'..hy..'" cy="'..hz..'" r="2" stroke="white" stroke-width="1" fill="red"/>'me=me.."<text x='"..hy.."' y='"..hz-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iM=mf;iN=mi;local ml=fn+cL*1000000;local mm=lO+lQ+ml.x/mf;local jC=lP+lQ*1.5/2+ml.y/mi;me=me..'<line x1="'..hy..'" y1="'..hz..'" x2="'..mm..'" y2="'..jC..'" stroke="purple" stroke-width="1"/>'jT[#jT+1]=me;jT[#jT+1]='</g>'end elseif bL=="INFO"then jT=cs.DrawOdometer(jT,j0,bp,j1)elseif bL=="HELP"then jT=lH(jT)elseif bL=="SCOPE"then jT[#jT+1]='<g clip-path="url(#orbitRect)">'local mn=d6;local mo=vec3(DUSystem.getCameraWorldPos())local mp=vec3(DUSystem.getCameraWorldRight())local mq=vec3(DUSystem.getCameraWorldForward())if iA()==1 then mo=cP;mp=cJ;mq=cI end;if ci>0 then table.sort(d5,function(eB,eC)local eD,eE=eB.center,eC.center;return(eD.x-mo.x)^2+(eD.y-mo.y)^2+(eD.z-mo.z)^2<(eE.x-mo.x)^2+(eE.y-mo.y)^2+(eE.z-mo.z)^2 end)end;local mr={}local ms={}local mt=120;local mu=nil;local mv=nil;for M,dy in ipairs(d5)do local gM=dy.center-mo;local mw=gM:len()local mx=gM:normalize()local my=gM:cross(mq):normalize()local mz=math.acos(my:dot(mp))if mz~=mz then mz=0 end;if my:cross(mp):dot(mq)<0 then mz=-mz end;local mA=gM:project_on_plane(mq):len()local mB=math.sin(mz)*math.asin(mA/mw)*constants.rad2deg;local mC=math.cos(mz)*math.asin(mA/mw)*constants.rad2deg;if mx:dot(mq)<0 then mC=90*math.cos(mz)+90*math.cos(mz)-mC;mB=90*math.sin(mz)+90*math.sin(mz)-mB end;local hy=m5+mB/mn*m1;local hz=m6+mC/mn*m1;local mD=(hy-m5)*(hy-m5)+(hz-m6)*(hz-m6)local mE=math.asin((dy.radius+dy.surfaceMaxAltitude)/mw)*constants.rad2deg;if mE~=mE then mE=mn end;local hT=mE/mn*m1;local mF=math.asin(dy.atmosphereRadius/mw)*constants.rad2deg;if mF~=mF then mF=mE end;local mG=mF/mn*m1;local cc=iD(mw,1)local mH=dy.name;local mI=false;if hz>lP then if hz>m8 then if hz-mG<=m8 then mI=true end else mI=true end else if hz+mG>=lP then mI=true end end;local mJ=false;local mK=hy;if dy.systemId==0 then mK=hy+mt else mK=hy-mt end;if mK+mt>lO then if mK+mt>m7 then if mK-mG-mt<=m7 then mJ=true end else mJ=true end else if mK+mG+mt>=lO then mJ=true end end;local mL={}mL.x=hy;mL.y=hz;mL.planet=dy;mL.atmoSize=mG;if not mu or mD<mu then mu=mD;mv=mL end;if mJ and mI then local mM=math.max(mG,5)if mD<mM*mM then mH=mH.." - "..cc end;mL.size=hT;mL.i=M;mL.displayString=mH;mL.distance=cc;mL.visible=true;ms[#ms+1]=mL else mL.visible=false end end;local mN=false;table.sort(ms,function(eD,eE)return eD.y<eE.y end)for dM,fi in ipairs(ms)do local dy,hT,M,mG,hy,hz,mH,cc=fi.planet,fi.size,fi.i,fi.atmoSize,fi.x,fi.y,fi.displayString,fi.distance;local l_,mO,mP,mQ;local mR=15;local jN="pdim"if dy.systemId~=0 then mP=j6(string.len(mH)*5)mR=-(15+mP)mQ=j7(10)jN="pdimfill"else mP=j6(string.len(mH)*9)mQ=j7(15)end;if hT*2>mP then l_=dm(hy,lO+mP/2,m7-mP/2)mO=dm(hz,lP+mQ,m8-5)l_=dm(l_,hy-hT+mP/2,hy+hT-mP/2)mO=dm(mO,hz-hT+mQ,hz+hT)else l_=hy+mR;mO=hz end;for mS,fi in pairs(mr)do local mT=fi.textPositions;local mU=mT.y-mO;if mS~=M and e_(mU)<mT.height and mT.x+mT.width>l_ and mT.x<l_+mP then if hT>mP then mO=dm(mO+mQ,lP+15,m8-5)else mO=mT.y+mT.height+1 end end end;local mV=mH~=dy.name or l_<=m5 and l_+mP>=m5 and mO-mQ<=m6 and mO>=m6;fi.hovered=mV;local mW=1;if mV then mW=2;if hT*2<mP then mW=10 end;if mH==dy.name then mH=mH.." - "..cc end;jN="pbright"if dy.systemId~=0 then mP=j6(string.len(mH)*5)mR=-(15+mP)else mP=j6(string.len(mH)*7)end;if hT*2>mP then l_=dm(hy,lO+mP/2,m7-mP/2)l_=dm(l_,hy-hT+mP/2,hy+hT-mP/2)else l_=hy+mR end end;mr[M]={}mr[M].textPositions={}mr[M].textPositions.y=mO;mr[M].textPositions.x=l_;mr[M].textPositions.width=mP;mr[M].textPositions.height=mQ;mr[M].output=""if hT*2>mP then jN=jN.." txtmid"else jN=jN.." txtstart"end;if mG-hT>2 then mr[M].output=dl('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hy,hz,mG,i_,0.1*mW)end;mr[M].output=mr[M].output..dl('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hy,hz,hT,i_,0.2*mW)if dy.systemId==0 then mr[M].output=mr[M].output..dl([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],l_,mO,iZ,jN,mH)if hT*2<=mP then mr[M].output=mr[M].output..dl("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",l_+mP,mO+2,l_,mO+2,hy,hz)end else mr[M].output=mr[M].output..dl([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],l_,mO,i_,jN,mH)if hT*2<=mP then mr[M].output=mr[M].output..dl("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",l_,mO+2,l_+mP,mO+2,hy,hz)end end end;for dM=#d5,1,-1 do if mr[dM]then jT[#jT+1]=mr[dM].output end end;if mv~=nil and d6<90 and not mv.hovered then local mX=mv.planet.atmosphereRadius/mv.atmoSize;local mY=dp(mu)*mX;local mZ=iD(mY,1)local mP=j6(math.max(string.len(mZ)*7,string.len(mv.planet.name)*7))local mQ=j7(12)local l_=dm(mv.x+(m5-mv.x)/2,lO+mP/2,m7-mP/2)local mO=dm(mv.y+(m6-mv.y)/2,lP+mQ*2,m8-5)jT[#jT+1]=dl("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mv.x,mv.y,m5,m6)jT[#jT+1]=dl([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],l_,mO,"white",mZ)if not mv.visible then jT[#jT+1]=dl([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],l_,mO-mQ,"white",mv.planet.name)end end;if cM>1 then local gM=cL;local mx=gM:normalize()local mA=gM:project_on_plane(mq):len()local my=gM:cross(mq):normalize()local mz=math.acos(my:dot(mp))if mz~=mz then mz=0 end;if my:cross(mp):dot(mq)<0 then mz=-mz end;local mB=math.sin(mz)*math.asin(mA/gM:len())*constants.rad2deg;local mC=math.cos(mz)*math.asin(mA/gM:len())*constants.rad2deg;if mx:dot(mq)<0 then mC=90*math.cos(mz)+90*math.cos(mz)-mC;mB=90*math.sin(mz)+90*math.sin(mz)-mB end;local hy=m5+mB/mn*m1;local hz=m6+mC/mn*m1;local kQ=14;local kR=kQ/2;local kU=[[<circle
                                    cx="]]..hy..[["
                                    cy="]]..hz..[["
                                    r="]]..kR/kQ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hy..[["
                                    cy="]]..hz..[["
                                    r="]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hy-kQ..[[,]]..hz..[[ h ]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hy+kR..[[,]]..hz..[[ h ]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hy..[[,]]..hz-kQ..[[ v ]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jT[#jT+1]=kU end;jT[#jT+1]=dl("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m5,m6-10,m5,m6+10)jT[#jT+1]=dl("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m5-10,m6,m5+10,m6)jT[#jT+1]='</g>'else return jT end end;local function m_(n0,n1)local n2;local n3=(n1-n0):normalize()local fo=(cP-n0):dot(n3)/n3:dot(n3)if fo<=0. then return(cP-n0):len()elseif fo>=(n1-n0):len()then return(cP-n1):len()end;local n4=n0+fo*n3;n2=(n4-cP):len()return n2 end;local function n5()local n2;local n6=nil;local n7=nil;local n8=nil;for dM,n9 in pairs(e[0])do if n9.hasAtmosphere then local cc=m_(kw.center,n9.center)if n6==nil or cc<n6 then n7=n9;n6=cc;n8=kw end;if c9 and c9.hasAtmosphere and c9.name~=kw.name then local eQ=m_(c9.center,n9.center)if eQ<n6 then n7=n9;n6=eQ;n8=c9 end end end end;local na=j6(1770)local nb=j7(330)if n6 then local nc="txttick "local nd=500000;if n6<n7.radius+nd or n6<n8.radius+nd then if cW then nc="txttick red "else nc="txttick orange "end end;n2=iD(n6,2)iR=gE(na,nb,"Pipe ("..n8.name.."--"..n7.name.."): "..n2,nc.."pbright txtmid")end end;local function ne(hy,hz,nf,ng,l2)local nh={x=hy,y=hz,width=nf,height=ng,label=l2}iL[l2]=nh;return nh end;local function ni(nj,nk,nf,ng,hy,hz,nl,nm,nn,no,jN)local nh={enableName=nj,disableName=nk,width=nf,height=ng,x=hy,y=hz,toggleVar=nl,toggleFunction=nm,drawCondition=nn,hovered=false,class=jN}if no then table.insert(iK,nh)else table.insert(iJ,nh)end;return nh end;local function np(nq)if not iP then nr=false;ns=false;nt=false;w=true;return elseif nq=="handling"then nr=not nr;ns=false;nt=false elseif nq=="hud"then ns=not ns;nr=false;nt=false elseif nq=="physics"then nt=not nt;nr=false;ns=false end;if nt or ns or nr then iQ=iC(nq)w=false else iQ="none"w=true end end;local function nu()iP=not iP;if iP then iI=iK;dj("Tap LMB to see Settings")d7=w else iI=iJ;dj("Tap LMB to see Control Buttons")np()w=d7 end end;local function nv()local function nw(dy,dM)dy.set(not dy.get())if dy.get()then dj(dM.." set to true")else dj(dM.." set to false")end;if dM=="showHud"then d7=dy.get()elseif dM=="BrakeToggleDefault"then b0=k end end;local nx=50;local ny=340;local hy=500;local hz=ae/2-400;local nz=0;for dM,dy in pairs(iC("boolean"))do if type(dy.get())=="boolean"then ni(dM,dM,ny,nx,hy,hz,function()return dy.get()end,function()nw(dy,dM)end,function()return true end,true)hz=hz+nx+20;if nz==9 then hy=hy+ny+20;hz=ae/2-400;nz=0 else nz=nz+1 end end end;ni("Control View","Control View",ny,nx,10,ae/2-500,function()return true end,nu,function()return true end,true)ni("View Handling Settings",'Hide Handling Settings',ny,nx,10,ae/2-(500-nx),function()return nr end,function()np("handling")end,function()return true end,true)ni("View Hud Settings",'Hide Hud Settings',ny,nx,10,ae/2-(500-nx*2),function()return ns end,function()np("hud")end,function()return true end,true)ni("View Physics Settings",'Hide Physics Settings',ny,nx,10,ae/2-(500-nx*3),function()return nt end,function()np("physics")end,function()return true end,true)end;local function nA()local function go()local fO=cP;local gp=kw.name..". "..#br;if cv then gp=cv.GetClosestName(gp)end;return ct.AddNewLocation(gp,fO,false,true)end;local function nB()b6=not b6 end;local function nC(nD)if nD==1 then b4=not b4;b3=false else b3=not b3;b4=false end;b5=false;b7=false;c1=false;b8=false;bv=nil;ba=false;b9=false end;local function nE(nF,nG)ct.UpdatePosition(nil,nF,nG)end;local function gj()ct.ClearCurrentPosition()end;local function nH(gn)local lG=cu.routeWP(true)if lG and#lG>0 then return"Engage Route: "..lG[1]end;return"Engage Autopilot: "..lE(gn)end;local function nI(gn)local lG=cu.routeWP(true)if lG and#lG>0 then return"Next Route Point: "..lG[1]end;return"Disable Autopilot: "..lE(gn)end;local function nJ()if iy()==1 then c1=not c1;if c1 then b5=false;b3=false;b4=false;b7=false;ba=false;b8=false;b9=false;nK=bo;bo=false;d.control.retractLandingGears()iz:setTargetGroundAltitude(Z)fL("folOn","F")else fL("folOff","F")b2="Follow Off"cA=q;bo=nK;if bo then d.control.deployLandingGears()iz:setTargetGroundAltitude(_)end end else dj("Follow Mode only works with Remote controller")c1=false end end;local nx=50;local ny=260;local nL=j6(30)local nM=aC+aB*2+2;local nN=aD+1;ni("+","+",nL,nL,nM,nN+nL+1,function()return false end,function()d6=d6/8 end,function()return bL=="SCOPE"end,nil,"ZoomButton")ni("-","-",nL,nL,nM,nN,function()return false end,function()d6=math.min(d6*8,90)end,function()return bL=="SCOPE"end,nil,"ZoomButton")ni("0","0",nL,nL,nM,nN+nL*2+2,function()return false end,function()d6=90 end,function()return bL=="SCOPE"and d6~=90 end,nil,"ZoomButton")local nO=ni("Enable Brake Toggle","Disable Brake Toggle",ny,nx,ad/2-ny/2,ae/2+350,function()return b0 end,function()b0=not b0;if b0 then dj("Brakes in Toggle Mode")else dj("Brakes in Default Mode")end end)ni("Align Prograde","Disable Prograde",ny,nx,ad/2-ny/2-50-nO.width,ae/2-nx+380,function()return b4 end,function()nC(1)end)ni("Align Retrograde","Disable Retrograde",ny,nx,ad/2-ny/2+nO.width+50,ae/2-nx+380,function()return b3 end,nC,function()return ci==0 end)nP=ni(nH,nI,600,60,ad/2-600/2,ae/2-60/2-330,function()return b5 or bs or ce or bB end,function()end)local M;local function nQ(nR)local gn=d2+nR;if gn>#cV then gn=gn-#cV-1 end;if gn<0 then gn=#cV+gn end;return gn end;nS={}for M=0,10 do local nT=ni(function(eE)local gn=nQ(eE.apExtraIndex)if b5 or bs or ce or bB then return"Redirect: "..lE(gn)end;return nH(gn)end,function(eE)local gn=nQ(eE.apExtraIndex)return nI(gn)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eE)local gn=nQ(eE.apExtraIndex)return gn==bn and(b5 or bs or ce or bB)end,function(eE)local gn=nQ(eE.apExtraIndex)local nU=bn==gn;bn=gn;ct.UpdateAutopilotTarget()cu.ToggleAutopilot()if not nU and not(b5 or bs or ce or bB)then cu.ToggleAutopilot()end end,function()return d1 and(#cu.routeWP(true)==0 or M==0)end)nT.apExtraIndex=M;nS[M]=nT end;ni("Save Position","Save Position",200,nP.height,nP.x+nP.width+30,nP.y,function()return false end,go,function()return bn==0 or fX==nil end)ni("Update Position","Update Position",200,nP.height,nP.x+nP.width+30,nP.y,function()return false end,function()nE(nil)end,function()return bn>0 and fX~=nil end)ni("Save Heading","Clear Heading",200,nP.height,nP.x+nP.width+30,nP.y+nP.height+20,function()return fX.heading~=nil end,function()if fX.heading~=nil then nE(false)else nE(true)end end,function()return bn>0 and fX~=nil end)ni("Save AGG Alt","Clear AGG Alt",200,nP.height,nP.x+nP.width+30,nP.y+nP.height*2+40,function()return fX.agg~=nil end,function()if fX.agg~=nil then nE(nil,false)else nE(nil,true)end end,function()return bn>0 and fX~=nil and antigrav end)ni("Clear Position","Clear Position",200,nP.height,nP.x-200-30,nP.y,function()return true end,gj,function()return bn>0 and fX~=nil end)ni("Save Route","Save Route",200,nP.height,nP.x-200-30,nP.y+nP.height*2+40,function()return false end,function()cu.routeWP(false,false,2)end,function()return#cu.routeWP(true)>0 end)ni("Load Route","Clear Route",200,nP.height,nP.x-200-30,nP.y+nP.height+20,function()return#cu.routeWP(true)>0 end,function()if#cu.routeWP(true)>0 then cu.routeWP(false,true)elseif b5 or bs then dj("Disable Autopilot before loading route")return else cu.routeWP(false,false,1)end end,function()return true end)nx=60;ny=300;local hy=0;local hz=ae/2-150;ni("Enable Check Damage","Disable Check Damage",ny,nx,hy,hz-nx-20,function()return s end,function()s=not s end)ni("View Settings","View Settings",ny,nx,hy,hz,function()return true end,nu)hz=hz+nx+20;ni("Enable Turn and Burn","Disable Turn and Burn",ny,nx,hy,hz,function()return b6 end,nB)hy=10;hz=ae/2-300;ni("Horizontal Takeoff Mode","Vertical Takeoff Mode",ny,nx,ad/2-ny/2,hz+20,function()return b1 end,function()b1=not b1;if b1 then dj("Vertical Takeoff Mode")else dj("Horizontal Takeoff Mode")end end,function()return cQ end)hz=hz+nx+20;ni("Engage Orbiting","Cancel Orbiting",ny,nx,hy+ny+20,hz,function()return bB end,cu.ToggleIntoOrbit,function()return ci==0 and cZ end)hz=ae/2-150;ni("Glide Re-Entry","Cancel Glide Re-Entry",ny,nx,hy+ny+20,hz,function()return ba end,function()cd=1;nC(1)end,function()return kw.hasAtmosphere and not ch end)hz=hz+nx+20;ni("Parachute Re-Entry","Cancel Parachute Re-Entry",ny,nx,hy+ny+20,hz,function()return ba end,function()cd=2;nC(1)end,function()return kw.hasAtmosphere and not ch end)hz=hz+nx+20;ni("Engage Follow Mode","Disable Follow Mode",ny,nx,hy,hz,function()return c1 end,nJ,function()return iy()==1 end)ni("Enable Repair Arrows","Disable Repair Arrows",ny,nx,hy+ny+20,hz,function()return j4 end,function()j4=not j4;if j4 then dj("Repair Arrows Enabled")else dj("Repair Arrows Diabled")end end,function()return iy()==1 end)hz=hz+nx+20;if not r then ni("Enable AGG","Disable AGG",ny,nx,hy,hz,function()return cR end,cu.ToggleAntigrav,function()return antigrav~=nil end)end;ni(function()return dl("Switch IPH Mode - Current: %s",bC)end,function()return dl("IPH Mode: %s",bC)end,ny*2,nx,hy,hz,function()return false end,function()if bC=="All"then bC="Custom Only"elseif bC=="Custom Only"then bC="No Moons-Asteroids"else bC="All"end;dj("IPH Mode: "..bC)end)hz=hz+nx+20;ni(function()return dl("Toggle Control Scheme - Current: %s",g)end,function()return dl("Control Scheme: %s",g)end,ny*2,nx,hy,hz,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;dj("New Control Scheme: "..g)end)local nV=j7(20)local nT=ne(0,0,j6(70),nV,"HELP")nT=ne(nT.x+nT.width,nT.y,j6(80),nV,"INFO")nT=ne(nT.x+nT.width,nT.y,j6(70),nV,"ORBIT")nT=ne(nT.x+nT.width,nT.y,j6(70),nV,"SCOPE")ne(nT.x+nT.width,nT.y,j6(70),nV,"HIDE")end;local nW={}local nX=nil;function nW.HUDPrologue(jT)if not cW then iW=aj;iX=ak;iY=al else iW=ag;iX=ah;iY=ai end;iZ=[[rgb(]]..bO(iW+0.6)..","..bO(iX+0.6)..","..bO(iY+0.6)..[[)]]i_=[[rgb(]]..bO(iW*0.8+0.5)..","..bO(iX*0.8+0.5)..","..bO(iY*0.8+0.5)..[[)]]local nY=iZ;local nZ=i_;local n_=[[rgb(]]..bO(iW*0.4+0.5)..","..bO(iX*0.4+0.5)..","..bO(iY*0.4+0.5)..[[)]]local o0=iZ;local o1=i_;local o2=n_;if j8()and not n then nY=[[rgb(]]..bO(iW*0.5+0.5)..","..bO(iX*0.5+0.5)..","..bO(iY*0.5+0.5)..[[)]]nZ=[[rgb(]]..bO(iW*0.3+0.5)..","..bO(iX*0.3+0.5)..","..bO(iY*0.2+0.5)..[[)]]n_=[[rgb(]]..bO(iW*0.2+0.5)..","..bO(iX*0.2+0.5)..","..bO(iY*0.2+0.5)..[[)]]end;local ls=j6;local lt=j7;jT[#jT+1]=dl([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nY,nY,nY,o0,o0,nZ,nZ,o1,o1,nZ,nY,n_,o1,nY,nY,n_,n_,o2,n_,ad,ae,nZ,nZ,nZ,nZ,nZ,o0,nZ,o1,o2,o1,o1,o2)if not nX then nX=dl([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],ls(630),lt(0),ls(675),lt(45),ls(960),lt(55),ls(1245),lt(45),ls(1290),lt(0),ls(1000),lt(105),ls(1040),lt(59),ls(1250),lt(51),ls(1300),lt(0),ls(1920),lt(0),ls(1920),lt(20),ls(1400),lt(20),ls(1300),lt(105),ls(920),lt(105),ls(880),lt(59),ls(670),lt(51),ls(620),lt(0),ls(0),lt(0),ls(0),lt(20),ls(520),lt(20),ls(620),lt(105),ls(890),lt(59),ls(960),lt(62),ls(1030),lt(59),ls(985),lt(112),ls(1150),lt(112),ls(1100),lt(152),ls(820),lt(152),ls(780),lt(112),ls(935),lt(112),ls(890),lt(59),ls(960),lt(62),ls(1030),lt(59),ls(985),lt(112),ls(1150),lt(112),ls(1100),lt(152),ls(820),lt(152),ls(780),lt(112),ls(935),lt(112))end;if w and I then jT[#jT+1]=nX end;return jT end;function nW.DrawVerticalSpeed(jT,e4)jS(jT,e4)end;function nW.UpdateHud(jT)local kJ=cT;local o3=cU;local j_=o3;local kf=kJ;local l0=bO(c.getThrottle())local l5=cM*3.6;local l1=c.getAxisCommandValue(0)local o4=j6(1770)local o5=j7(310)if t and cS then l1=bS;l0=bS*100 end;local ja=j9()local k0="ROLL"if l0==nil then l0=0 end;if not cZ then if cM>5 then kJ=kI(cK)o3=kK(cK)else kJ=0;o3=0 end;k0="YAW"end;if cX>50000 and not ch then local o6;o6=iD(cX)jT[#jT+1]=gE(o4,o5,"PvP Boundary: "..o6,"pbright txtbig txtmid")end;jT[#jT+1]=j2;jT[#jT+1]=i6;if iR~=""then jT[#jT+1]=iR end;if jb~=""then jT[#jT+1]=jb end;if jc~=""then jT[#jT+1]=jc end;jS(jT,cj)if iy()==0 or m then if not j8()or n then if cZ then jZ(jT,am,an,j_,k0,cZ)ke(jT,kf,j_,am,an,cZ,bO(kK(cK)),cM)else jZ(jT,am,an,o3,k0,cZ)ke(jT,kJ,o3,am,an,cZ,bO(o3),cM)end;km(jT,cj,cZ)kL(jT,cK,cM,am,an)end end;k_(jT,ja,l0,l1)l4(jT,l5)l9(jT)lN(jT)if not iP and c2 then lF(jT)end;return jT end;function nW.HUDEpilogue(jT)jT[#jT+1]="</svg>"return jT end;function nW.ExtraData(jT)local o7=j6(1240)local o8=j7(55)local o9=o8+10;local oa;local ls=j6;local lt=j7;local ob=0;local ja=j9()if b1 then ja=ja.."-VERTICAL"end;if E and gP and not b9 and not b8 and cM>20 then ja=ja.."-COLLISION ON"end;if bE~="Off"then ja="("..bE..")-"..ja end;if b6 then ja="TB-"..ja end;if bJ then ja="HOVERMODE-"..ja end;if not bD then ja=ja.."-DeCoupled"end;local oc=lt(99)local od=lt(80)local oe=lt(85)local of=lt(31)local og=0;local oh=0;local f4=ck>1000000 and fM(ck/1000000,2).."kT"or fM(ck/1000,2).."T"if ch then ob=bw else ob=bu end;local oi,oj=cq.computeDistanceAndTime(cM,0,ck,0,0,ob)if oi<0 then oi=0 end;ob=fM(ob/(ck*iH),2).."g"local ok=d:maxForceForward()oa=b.getGravityIntensity()if oa>0.1 then oh=ck*oa;oh=fM(oh/(ck*iH),2).."g"og=0.5*ok/oa;og=og>1000000 and fM(og/1000000,2).."kT"or fM(og/1000,2).."T"end;ok=fM(ok/(ck*iH),2).."g"local ol=vec3(bQ.getWorldAcceleration()):len()/9.80665;oa=b.getGravityIntensity()jT[#jT+1]=[[<g class="dim txt txtend size14">]]if iy()==1 and not m then o7=j6(1120)o8=j7(55)o9=o8+10 elseif ch and I then local om=j6(770)jT[#jT+1]=gE(ls(895),oc,"ATMO","")jT[#jT+1]=dl([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],ls(895),oe,ls(-80))jT[#jT+1]=gE(ls(815),od,dl("%.1f%%",ci*100),"txtstart size20")end;if I then jT[#jT+1]=gE(ls(1025),oc,"GRAVITY","txtstart")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(1025),oe,ls(80))jT[#jT+1]=gE(ls(1105),od,dl("%.2fg",oa/9.80665),"size20")jT[#jT+1]=gE(ls(1125),oc,"ACCEL","txtstart")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(1125),oe,ls(80))jT[#jT+1]=gE(ls(1205),od,dl("%.2fg",ol),"size20")jT[#jT+1]=gE(ls(695),oc,"BRK TIME","")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(695),oe,ls(-80))jT[#jT+1]=gE(ls(615),od,dl("%s",iE(oj)),"txtstart size20")jT[#jT+1]=gE(ls(635),lt(45),"TRIP","")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(635),lt(31),ls(-90))if lp then jT[#jT+1]=gE(ls(545),lt(26),dl("%s",iE(lp)),"txtstart size20")end;jT[#jT+1]=gE(ls(795),oc,"BRK DIST","")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(795),oe,ls(-80))jT[#jT+1]=gE(ls(715),od,dl("%s",iD(oi)),"txtstart size20")jT[#jT+1]=gE(ls(1285),lt(45),"MASS","txtstart")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(1285),lt(31),ls(90))jT[#jT+1]=gE(ls(1375),lt(26),dl("%s",f4),"size20")jT[#jT+1]=gE(ls(1220),oc,"THRUST","txtstart")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(1220),oe,ls(80))jT[#jT+1]=gE(ls(1300),od,dl("%s",ok),"size20")jT[#jT+1]=gE(j6(960),j7(175),ja,"pbright txtbig txtmid size20")end;jT[#jT+1]="</g>"end;local on=1-(a7*0.05+a8*0.05)function nW.FuelUsed(oo)local op;if oo=="atmofueltank"then op=dl("Atmo Fuel Used: %.1f L",jt[oo]/(4*on))elseif oo=="spacefueltank"then op=dl("Space Fuel Used: %.1f L",jt[oo]/(6*on))else op=dl("Rocket Fuel Used: %.1f L",jt[oo]/(0.8*on))end;return op end;local oq,os,ot,ou,ov=0,0,0,{},0;local ow=0;local ox=0;local oy=0;function nW.DrawOdometer(jT,j0,bp,j1)if bL~="INFO"then return jT end;local oa;local ob=0;local oh=0;local f4=ck>1000000 and fM(ck/1000000,2).." kTons"or fM(ck/1000,2).." Tons"if ch then ob=bw else ob=bu end;local oi,oj=cq.computeDistanceAndTime(cM,0,ck,0,0,ob)ob=fM(ob/(ck*iH),2).." g"local ok=d:maxForceForward()oa=b.getGravityIntensity()if cM<5 then local oz=vec3(bQ.getOrientationForward())local oA=bQ.getMaxThrustAlongAxis('thrust analog longitudinal ',{oz:unpack()})ow=0.5*oA[1]/oa;ow=ow>1000000 and fM(ow/1000000,1).." kTons"or fM(ow/1000,1).." Tons"ox=0.5*oA[3]/oa;ox=ox>1000000 and fM(ox/1000000,1).." kTons"or fM(ox/1000,1).." Tons"oz=vec3(bQ.getOrientationUp())oA=bQ.getMaxThrustAlongAxis('hover_engine, booster_engine',{oz:unpack()})oy=0.5*oA[1]/oa;oy=oy>1000000 and fM(oy/1000000,1).." kTons"or fM(oy/1000,1).." Tons"end;if oa>0.1 then oh=ck*oa;oh=fM(oh/(ck*iH),2).." g"else oh="n/a"end;ok=fM(ok/(ck*iH),2).." g"if iy()==0 or m then local oB=j6(aC+10)local oC=j7(aD+20)local oD=j6(aC+10+aB/1.25)local ng=25;local oE=bO(1/aU)if ot<oE then ov=ov+a.getActionUpdateDeltaTime()ot=ot+1 else oq=1/(ov/oE)table.insert(ou,oq)ot,ov=0,0 end;os=0;for dM,dy in pairs(ou)do os=os+dy end;if#ou>0 then os=bO(os/#ou)end;if#ou>29 then table.remove(ou,1)end;jT[#jT+1]="<g class='txtstart size14 bright'>"jT[#jT+1]=gE(oB,oC,dl("BrkTime: %s",iE(oj)))jT[#jT+1]=gE(oD,oC,dl("Trip: %.2f km",j0))jT[#jT+1]=gE(oB,oC+ng,dl("Lifetime: %.2f kSU",bp/200000))jT[#jT+1]=gE(oD,oC+ng,dl("BrkDist: %s",iD(oi)))jT[#jT+1]=gE(oB,oC+ng*2,"Trip Time: "..iE(j1))jT[#jT+1]=gE(oD,oC+ng*2,"Total Time: "..iE(bq))jT[#jT+1]=gE(oB,oC+ng*3,dl("Mass: %s",f4))jT[#jT+1]=gE(oD,oC+ng*3,dl("Max Brake: %s",ob))jT[#jT+1]=gE(oB,oC+ng*4,dl("Max Thrust: %s",ok))jT[#jT+1]=gE(oD,oC+ng*4,dl("Safe Atmo Mass: %s",ow))jT[#jT+1]=gE(oB,oC+ng*5,dl("Req Thrust: %s",oh))jT[#jT+1]=gE(oD,oC+ng*5,dl("Safe Space Mass: %s",ox))jT[#jT+1]=gE(oD,oC+ng*6,dl("Safe Hover Mass: %s",oy))jT[#jT+1]=gE(oB,oC+ng*6,dl("Influence: %s",kw.name))jT[#jT+1]=gE(oB,oC+ng*7,dl("Set Max Speed: %s",bO(a1*3.6+0.5)))jT[#jT+1]=gE(oD,oC+ng*7,dl("Actual Max Speed: %s",bO(dg*3.6+0.5)))jT[#jT+1]=gE(oB,oC+ng*8,dl("Friction Burn Speed: %s",bO(bQ.getFrictionBurnSpeed()*3.6)))jT[#jT+1]=gE(oD,oC+ng*8,dl("FPS (Avg): %s (%s)",bO(oq),os))end;jT[#jT+1]="</g></g>"return jT end;function nW.DrawWarnings(jT)return l9(jT)end;function nW.DisplayOrbitScreen(jT)return lN(jT)end;function nW.DisplayMessage(jT,lk)if lk~="empty"then local hz=310;for lm in string.gmatch(lk,"([^\n]+)")do hz=hz+35;jT[#jT+1]=gE("50%",hz,lm,"msg")end end;if c5~=0 then c.setTimer("msgTick",c5)c5=0 end end;function nW.DrawDeadZone(jT)jT[#jT+1]=dl([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function nW.UpdatePipe()if ch then iR=""return end;n5()end;function nW.DrawSettings(jT)local hy=j6(640)local hz=j7(200)jT[#jT+1]=[[<g class="pbright txtvspd txtstart">]]local hP=0;for dM,dy in pairs(iQ)do hP=hP+1;jT[#jT+1]=gE(hy,hz,dM..": "..dy.get())hz=hz+20;if hP%12==0 then hy=hy+j6(350)hz=j7(200)end end;jT[#jT+1]=gE(j6(640),j7(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jT[#jT+1]="</g>"return jT end;local i5=j7(125)local i4=j6(1225)function nW.DrawRadarInfo()i6=cv.GetRadarHud(i4,i5,ay,az)if i6 then gP=true end end;function nW.DrawTanks()if au~=0 and av~=0 then jb=gE(au,av,"","txtstart pdim txtfuel")ju=av;jv(au,"Atmospheric ","ATMO",cm,jr,js)jv(au,"Space Fuel T","SPACE",cn,jp,jq)jv(au,"Rocket Fuel ","ROCKET",co,jn,jo)end end;function nW.DrawShield()local ih=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oF=bQ.getPvPTimer()local oG=shield.getResistances()local oH="A: "..10+oG[1]*100 .."% / E: "..10+oG[2]*100 .."% / K:"..10+oG[3]*100 .."% / T: "..10+oG[4]*100 .."%"local hy,hz=aw-60,ax+30;local jL=bO(dh*2.55)local jM=dl("rgb(%d,%d,%d)",255-jL,jL,0)local jN=""jc=gE(hy,hz,"","txtmid pdim txtfuel")if dh<10 and ih~="Shield Disabled"then jN="red "end;oF=oF>0 and"   PvPTime: "..iE(oF)or""jc=jc..dl([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hy,hz,jM,dh*2,hy,hz,hy+2,hz+10,dh,oF)jc=jc..gE(hy,hz-5,ih,jN.."txtstart pbright txtbig")jc=jc..gE(hy,hz+30,oH,jN.."txtstart pbright txtsmall")end;function nW.hudtick()if not kw then return end;local function oI(jT)local jP=bO(dm(de/(ad/4)*255,0,255))jT[#jT+1]=dl("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ca,cb,bO(iW+0.5)+jP,bO(iX+0.5)-jP,bO(iY+0.5)-jP)end;local function oJ()if c3 then for dR,dy in pairs(iI)do if dy.hovered then if not dy.drawCondition or dy.drawCondition(dy)then dy.toggleFunction(dy)end;dy.hovered=false end end;for dR,dy in pairs(iL)do if dy.hovered then bL=dy.label;dy.hovered=false end end;c3=false end end;local function oK()local function oL(oM,oN,hy,hz,nf,ng)if oM>=hy and oM<=hy+nf and oN>=hz and oN<=hz+ng then return true else return false end end;local hy=ca+ad/2;local hz=cb+ae/2;for dR,dy in pairs(iI)do dy.hovered=oL(hy,hz,dy.x,dy.y,dy.width,dy.height)end;for dR,dy in pairs(iL)do dy.hovered=oL(hy,hz,dy.x,dy.y,dy.width,dy.height)end;if d1 then local mV=false;for dR,eE in ipairs(nS)do if eE.hovered then mV=true;break end end;if nP.hovered then mV=true end;d1=mV else d1=nP.hovered;if not d1 then d2=bn end end end;local function oO(jT)if not bL or bL==""then bL="HELP"end;if w then for dM,dy in pairs(iL)do local jN="dim brightstroke"local oP=0.2;if bL==dM then jN="pbright dimstroke"oP=0.6 end;local oQ=""if dy.hovered then oP=0.8;oQ=";stroke:white"end;jT[#jT+1]=dl([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dy.width,dy.height,dy.x,dy.y,jN,oP,oQ)jT[#jT+1]=gE(dy.x+dy.width/2,dy.y+dy.height/2+5,dy.label,"txt txtmid pdim")end end end;local function oR(jT)local function oS(jT,oT,hover,hy,hz,oU,oV,oW,oX,oY,oZ,nT)if type(oY)=="function"then oY=oY(nT)end;if type(oZ)=="function"then oZ=oZ(nT)end;jT[#jT+1]=dl("<rect x='%f' y='%f' width='%f' height='%f' fill='",hy,hz,oU,oV)if oT then jT[#jT+1]=dl("%s'",oW)else jT[#jT+1]=oX end;if hover then jT[#jT+1]=dl(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else jT[#jT+1]=dl(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fM(ag*0.5,0),fM(ah*0.5,0),fM(ai*0.5,0))end;jT[#jT+1]=" rx='5'></rect>"jT[#jT+1]=dl("<text x='%f' y='%f' font-size='24' fill='",hy+oU/2,hz+oV/2+5)if oT then jT[#jT+1]="black"else jT[#jT+1]="white"end;jT[#jT+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oT then jT[#jT+1]=dl("%s</text>",oY)else jT[#jT+1]=dl("%s</text>",oZ)end end;local o_=dl("rgb(%d,%d,%d)'",fM(ag*0.1,0),fM(ah*0.1,0),fM(ai*0.1,0))local p0=dl("rgb(%d,%d,%d)",fM(ag*0.8,0),fM(ah*0.8,0),fM(ai*0.8,0))local p1=oS;for dR,dy in pairs(iI)do local nk=dy.disableName;local nj=dy.enableName;if type(nk)=="function"then nk=nk(dy)end;if type(nj)=="function"then nj=nj(dy)end;if not dy.drawCondition or dy.drawCondition(dy)then p1(jT,dy.toggleVar(dy),dy.hovered,dy.x,dy.y,dy.width,dy.height,p0,o_,nk,nj,dy)end end end;local p2=fM(ad/2,0)local p3=fM(ae/2,0)local jT={}if p4 then jT[#jT+1]=p4 end;cs.HUDPrologue(jT)if w then cs.UpdateHud(jT)else if A then cs.DrawVerticalSpeed(jT,cj)end;cs.DrawWarnings(jT)end;if iP and iQ~="none"then cs.DrawSettings(jT)end;if cv then cs.DrawRadarInfo()else i6=""end;cs.HUDEpilogue(jT)jT[#jT+1]=dl([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c4~="empty"then cs.DisplayMessage(jT,c4)end;if iy()==0 and g=="virtual joystick"then if v then cs.DrawDeadZone(jT)end end;oO(jT)if iA()==0 then if iy()==1 and c2 then if not p5 then oK()oR(jT)end;if not cy and not cz then local p6=table.concat(jT,"")jT={}jT[#jT+1]=dl("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jT[#jT+1]=p6;jT[#jT+1]="</body>"cy=true;jT[#jT+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cz then local p6=table.concat(jT,"")jT={}jT[#jT+1]=dl("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jT[#jT+1]=p6;jT[#jT+1]="</body>"end;if not cy then jT[#jT+1]=dl([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,ca,cb)end else oJ()end else if not c2 and iy()==0 then oJ()if de>aA then if v then oI(jT)end end elseif c2 and(not p5 or not j)then oK()oR(jT)end;jT[#jT+1]=dl([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,ca,cb)end;jT[#jT+1]=[[</svg></body>]]p7=table.concat(jT,"")end;function nW.TenthTick()local function p8()local p9=a.createData;local pa=a.createWidget;pb=a.createWidgetPanel("Interplanetary Helper")pc=pa(pb,"value")pd=p9('{"label": "Target Planet", "value": "N/A", "unit":""}')fK(pd,pc)pe=pa(pb,"value")pf=p9('{"label": "distance", "value": "N/A", "unit":""}')fK(pf,pe)gd=pa(pb,"value")gc=p9('{"label": "Travel Time", "value": "N/A", "unit":""}')fK(gc,gd)gf=pa(pb,"value")ge=p9('{"label": "Target Altitude", "value": "N/A", "unit":""}')fK(ge,gf)pg=pa(pb,"value")ph=p9('{"label": "End Speed", "value": "N/A", "unit":""}')g7=pa(pb,"value")g6=p9('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g5=pa(pb,"value")g4=p9('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g3=pa(pb,"value")g2=p9('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g1=pa(pb,"value")g0=p9('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g9=pa(pb,"value")g8=p9('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ch then fK(ph,pg)fK(g6,g7)fK(g4,g5)fK(g2,g3)fK(g0,g1)fK(g8,g9)end end;local function pi()gD(pb)pb=nil end;cs.DrawTanks()if shield then cs.DrawShield()end;if bl~="None"then if pb==nil then p8()end;if bl~=nil then local mw;local pj=fX~=nil;local pk=b5 and bh*3.6 or 0;fJ(pd,'{"label": "Target", "value": "'..bl..'", "unit":""}')if pj and not b5 then mw=(cP-fX.position):len()else mw=(bm-cP):len()end;if not b6 then c7,c8=cu.GetAutopilotBrakeDistanceAndTime(cM)iT,iU=cu.GetAutopilotBrakeDistanceAndTime(a1)else c7,c8=cu.GetAutopilotTBBrakeDistanceAndTime(cM)iT,iU=cu.GetAutopilotTBBrakeDistanceAndTime(a1)end;local lk=iD(mw)fJ(pf,'{"label": "distance", "value": "'..lk..'"}')fJ(gc,'{"label": "Travel Time", "value": "'..iE(lp)..'", "unit":""}')lk=iD(c7)fJ(g6,'{"label": "Cur Brake distance", "value": "'..lk..'"}')fJ(g4,'{"label": "Cur Brake Time", "value": "'..iE(c8)..'", "unit":""}')lk=iD(iT)fJ(g2,'{"label": "Max Brake distance", "value": "'..lk..'"}')fJ(g0,'{"label": "Max Brake Time", "value": "'..iE(iU)..'", "unit":""}')fJ(ph,'{"label": "End Speed", "value": "'..dl("%.0fkph",pk)..'", "unit":""}')lk=iD(gg)fJ(ge,'{"label": "Target Orbit", "value": "'..lk..'"}')if ch and not pl then a.removeDataFromWidget(g0,g1)a.removeDataFromWidget(ph,pg)a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)pl=true;if not cS and t and(b7 or ba or cf)then cu.cmdThrottle(1)b2=false;bW=false end end;if not ch and pl then if fJ(g0,g1)==1 then fK(g0,g1)end;if fJ(g0,pg)==1 then fK(ph,pg)end;if fJ(g2,g3)==1 then fK(g2,g3)end;if fJ(g4,g5)==1 then fK(g4,g5)end;if fJ(g6,g7)==1 then fK(g6,g7)end;if fJ(g8,g9)==1 then fK(g8,g9)end;pl=false end end else pi()end;if warpdrive~=nil then local pm=iw(warpdrive.getWidgetData())if pm.destination~="Unknown"and pm.distance>400000 then if not j5 then warpdrive.showWidget()j5=true end elseif j5 then warpdrive.hideWidget()j5=false end end end;function nW.OneSecondTick()local function pn()local jF=bN()local l5=cM;local po=jF-j3;if l5>1.38889 then l5=l5/1000;local pp=l5*(jF-j3)bp=bp+pp;j0=j0+pp end;j1=j1+po;bq=bq+po;j3=jF end;local function pq(jT)local pr=0;local ps=iG;local pt=0;local pu=0;local pv=0;local jL=0;local jM=""local pw=b.getElementHitPointsById;local px=b.getElementMaxHitPointsById;local py={}for dM in pairs(iF)do local pz=0;local pA=0;pA=px(iF[dM])pz=pw(iF[dM])pt=pt+pz;if pz+1<pA then if pz==0 then pv=pv+1 else pu=pu+1 end;if j4 and#py==0 then fO=vec3(b.getElementPositionById(iF[dM]))local hy=fO.x;local hz=fO.y;local hA=fO.z;table.insert(py,b.spawnArrowSticker(hy,hz,hA+1,"down"))table.insert(py,b.spawnArrowSticker(hy,hz,hA+1,"down"))b.rotateSticker(py[2],0,0,90)table.insert(py,b.spawnArrowSticker(hy+1,hz,hA,"north"))table.insert(py,b.spawnArrowSticker(hy+1,hz,hA,"north"))b.rotateSticker(py[4],90,90,0)table.insert(py,b.spawnArrowSticker(hy-1,hz,hA,"south"))table.insert(py,b.spawnArrowSticker(hy-1,hz,hA,"south"))b.rotateSticker(py[6],90,-90,0)table.insert(py,b.spawnArrowSticker(hy,hz-1,hA,"east"))table.insert(py,b.spawnArrowSticker(hy,hz-1,hA,"east"))b.rotateSticker(py[8],90,0,90)table.insert(py,b.spawnArrowSticker(hy,hz+1,hA,"west"))table.insert(py,b.spawnArrowSticker(hy,hz+1,hA,"west"))b.rotateSticker(py[10],-90,0,90)table.insert(py,iF[dM])end elseif j4 and#py>0 and py[11]==iF[dM]then for jE in pairs(py)do b.deleteSticker(py[jE])end;py={}end end;pr=fM(pt/ps*100,2)if pv>0 or pu>0 then jT[#jT+1]=gE(0,0,"","pbright txt")jL=bO(pr*2.55)jM=dl("rgb(%d,%d,%d)",255-jL,jL,0)jT[#jT+1]=gE("50%",1035,"Elemental Integrity: "..pr.."%","txtbig txtmid","fill:"..jM)if pv>0 then jT[#jT+1]=gE("50%",1055,"Disabled Modules: "..pv.." Damaged Modules: "..pu,"txtbig txtmid","fill:"..jM)elseif pu>0 then jT[#jT+1]=gE("50%",1055,"Damaged Modules: "..pu,"txtbig txtmid","fill:"..jM)end end end;local function pB()if iv then if iV==nil and(hc~=nil or bo)then _autoconf.displayCategoryPanel(iv,weapon_size,"Weapons","weapon",true)iV=_autoconf.panels[_autoconf.panels_size]elseif iV~=nil and hc==nil and not bo then gD(iV)iV=nil end end end;local jT={}pn()if s then pq(jT)end;pB()cs.UpdatePipe()cs.ExtraData(jT)j2=table.concat(jT,"")end;function nW.AnimateTick()cz=true;cy=false;ca=0;cb=0;c.stopTimer("animateTick")end;function nW.MsgTick()local jT={}cs.DisplayMessage(jT,"empty")c4="empty"c.stopTimer("msgTick")c5=3 end;function nW.ButtonSetup()nv()nA()iI=iJ end;if pC then for dM,dy in pairs(pC)do nW[dM]=dy end end;return nW end;local function pD(d,b,c,e,vBooster,hover,pE,antigrav,dbHud_1,e_,bO,bP,iy,eV,bN,dm,iz,fJ,iA,dp,fM,fL,iB,dq,iD,iE,pF,iw,dj)local a=DUSystem;local bQ=DUConstruct;local pG={}local pH=false;local pI=0;local pJ=0;local pK=0;local pL=bN()local pM=0;local pN=0;local pO=0;local pP=0;local pQ=false;local pR=false;local pS=false;local pT=nil;local pU=0;local iS=55;local pV=nil;local pW=false;local pX=false;local pY=false;local pZ=0;local p_=0;local q0=0;local q1=0;local q2=0;local q3={VectorToTarget=false}local q4=vec3(bQ.getWorldOrientationUp())local q5=nil;local q6=0;local q7=-1;local q8=-1;local q9=false;local qa=false;local qb=0;local qc=false;local qd=false;local qe=false;local qf=false;local qg=""local qh=false;local qi=false;local qj=""local qk=false;local ql=0;local qm=0;local function qn()return bQ.isInPvPZone()~=1,e_(bQ.getDistanceToSafeZone())end;local function qo(kh)local qp=bh;if not b5 then qp=0 end;local qq=bu;if ch then if bw and bw>0 then qq=bw else return 0,0 end end;return cq.computeDistanceAndTime(kh,qp,ck,0,0,qq-bj*ck)end;local function qr(kh)local qp=bh;if not b5 then qp=0 end;return cq.computeDistanceAndTime(kh,qp,ck,d:maxForceForward(),a3,bu-bj*ck)end;local function qs(qt,qu,qv)qu=qu:project_on_plane(qt)qv=qv:project_on_plane(qt)return eV(qu:cross(qv):dot(qt),qu:dot(qv))end;local qw=-1;local qx=-1;local function qy()local function qz()local qA=-1;local qB=-1;if vBooster then qA=vBooster.getDistance()if qA>-1 and qA<0.01 then qA=qw else qw=qA end end;if hover then qB=hover.getDistance()if qB>-1 and qB<0.01 then qB=qx else qx=qB end end;if qA~=-1 and qB~=-1 then if qA<qB then return qA else return qB end elseif qA~=-1 then return qA elseif qB~=-1 then return qB else return-1 end end;local qC=qz()local qD=-1;if antigrav and antigrav.isActive()==1 and not r and cM<iS then local qE=e_(cj-antigrav.getBaseAltitude())if qE<50 then return qE end end;if pE then qD=pE.raycast().distance;if qD==0 then qD=-1 end end;if qC~=-1 and qD~=-1 then if qC<qD then return qC else return qD end elseif qC~=-1 then return qC else return qD end end;local function qF(kw,eM,qG)local function qH(qI,dY)local eS=vec3(dY)if qI.id==0 then return setmetatable({latitude=eS.x,longitude=eS.y,altitude=eS.z,id=0,systemId=qI.systemId},d_)end;local eT=eS-qI.center;local cc=eT:len()local e4=cc-qI.radius;local e2=0;local e3=0;if not dq(cc,0)then local eU=eV(eT.y,eT.x)e3=eU>=0 and eU or 2*math.pi+eU;e2=math.pi/2-math.acos(eT.z/cc)end;return setmetatable({latitude=math.deg(e2),longitude=math.deg(e3),altitude=e4,id=qI.id,systemId=qI.systemId},d_)end;local qJ=qH(kw,eM)qJ="::pos{"..qJ.systemId..","..qJ.id..","..qJ.latitude..","..qJ.longitude..","..qJ.altitude.."}"if qG then return qJ else qe=qJ;return true end end;local function qK(qL,qM,qN)local function qO(qL,ev)qL=vec3(qL)ev=vec3(ev):normalize()local dH=qL*ev;return dH.x+dH.y+dH.z end;local qP=0.001;local qQ=1;if not ch or not cB or cg~=-1 or cM<iS then if qN==nil then qN=aT end;if qM==nil then qM=qP end;qL=vec3(qL):normalize()local qR=vec3()-qL;local qS=-qO(qR,bQ.getWorldOrientationRight())*qQ;local qT=-qO(qR,bQ.getWorldOrientationUp())*qQ;if pJ==0 then pJ=qS/2 end;if pK==0 then pK=qT/2 end;if e_(qS)<0.1 then p_=p_-qS*2 else p_=p_-(qS+(qS-pJ)*qN)end;if e_(qT)<0.1 then pZ=pZ+qT*2 else pZ=pZ+qT+(qT-pK)*qN end;pJ=qS;pK=qT;if e_(qS)<qM and e_(qT)<qM then return true end;return false elseif cB and cg==-1 then qL=cL;if qN==nil then qN=aT end;if qM==nil then qM=qP end;qL=vec3(qL):normalize()local qR=cI-qL;local qS=-qO(qR,bQ.getWorldOrientationRight())*qQ;local qT=-qO(qR,bQ.getWorldOrientationUp())*qQ;if pJ==0 then pJ=qS/2 end;if pK==0 then pK=qT/2 end;if e_(qS)<0.1 then p_=p_-qS*5 else p_=p_-(qS+(qS-pJ)*qN)end;if e_(qT)<0.1 then pZ=pZ+qT*5 else pZ=pZ+qT+(qT-pK)*qN end;pJ=qS;pK=qT;if e_(qS)<qM and e_(qT)<qM then return true end;return false end end;function pG.clearAll()bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"b3=false;b4=false;cY=nil;b7=false;ba=false;b8=false;b9=false;bb=false;c1=false;pX=false;cd=false;ce=false;pY=false;cA=q;bs=false;b6=false;cl=false;bv=nil;bB=false;dc=false;dd=nil;cf=false end;function pG.GetAutopilotBrakeDistanceAndTime(kh)return qo(kh)end;function pG.GetAutopilotTBBrakeDistanceAndTime(kh)return qr(kh)end;function pG.showWayPoint(kw,eM,qG)return qF(kw,eM,qG)end;function pG.APTick()local qU=a.getMouseWheel()if qU>0 then cu.changeSpd()elseif qU<0 then cu.changeSpd(true)else pW=true end;qb=iA()if qe then a.setWaypoint(qe)qe=false end;if qh then antigrav.setTargetAltitude(qh)qh=false end;if qf then fJ(qf,qg)qf=false;qg=""end;if q8~=-1 then cu.cmdCruise(q8,q9)q9=false;q8=-1 end;if q5~=nil then if iz:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iz:getTargetSpeed(axisCommandId.longitudinal)~=q5 then iz:setTargetSpeedCommand(axisCommandId.longitudinal,q5)else q5=nil end end;if q7~=-1 then cu.cmdThrottle(q7,q9)q9=false;q7=-1 end;if qa then cw.landingGear(qa)qa=false end;if qi then cu.ToggleAutopilot()end end;function pG.ToggleIntoOrbit()cF=false;pO=nil;pP=nil;pU=0;if not ch then if bB then fL("orOff","AP")bB=false;pQ=false;pT=nil;cA=q;if b7 then b7=false;b9=false end;q3.VectorToTarget=false;q3.AutopilotAlign=false;pS=false elseif cZ then fL("orOn","AP")bB=true;cA=true;if pT==nil then pT=kw end;if b7 then b7=false;b9=false end else dj("Unable to engage auto-orbit, not near a planet")end else bB=false;pQ=false;pT=nil;cA=q;if b7 then b7=false end;q3.VectorToTarget=false;q3.AutopilotAlign=false;pS=false end end;function pG.ToggleVerticalTakeoff()b7=false;if bb then qV=true;ba=false;b9=false;b8=true;cA=true;c0=0;if ch and cg==-1 then b8=false;b7=true;c0=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q8=bO(cC)end else cF=false;bo=false;d.control.retractLandingGears()iz:setTargetGroundAltitude(Z)b2="VTO Takeoff"end;bb=not bb end;function pG.checkLOS(qL)local ln,eK,eL=cp:getPlanetarySystem(0):castIntersections(cP,qL,function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)local lo=eK;if eL~=nil and eK~=nil then lo=math.min(eL,eK)end;if lo~=nil then return ln,lo else return nil,nil end end;local function qW(qX,qY)if qY then c0=0;iz:updateCommandFromActionStop(axisCommandId.vertical,qY)if bD then iz:activateGroundEngineAltitudeStabilization(qZ)df=true end else c0=c0+qX;iz:deactivateGroundEngineAltitudeStabilization()iz:updateCommandFromActionStart(axisCommandId.vertical,qX)end end;function pG.vertical(qX,qY)qW(qX,qY)end;function pG.ToggleAutopilot()local function q_(bz)c_=false;bs=not bs;if bs then b6=false;if not b7 and not bz then cu.ToggleAltitudeHold()end end;lr="Proceeding to Waypoint"end;local function r0(gp)if gp then for M,dM in pairs(cV)do if dM.name and dM.name==gp then return M end end else return 0 end end;local r1=false;bJ=false;if bR-pN<1.5 and ch then if not cH then if ch then bc=kw.spaceEngineMinAltitude-0.01*kw.noAtmosphericDensityAltitude;fL("11","EP")pN=-1;if b5 or bs or bB then return end else dj("No space engines detected, Orbital Hop not supported")return end elseif kw.hasAtmosphere then if ch then bc=kw.noAtmosphericDensityAltitude+V;fL("orH","OH")end;pN=-1;if b5 or bs or bB then return end end else pN=bR end;r2=false;if(bn>0 or#bH>0)and not b5 and not bs and not ce and not bB then if b7 then b7=false end;if 0.5*d:maxForceForward()/b.getGravityIntensity()<ck then dj("WARNING: Heavy Loads may affect autopilot performance.")end;if#bH>0 and not cf then bn=r0(bH[1])ct.UpdateAutopilotTarget()dj("Route Autopilot in Progress")local qR=fX.position-cP;local r3=qR:project_on_plane(cN):len()if r3>50000 and fX.planetname==kw.name then r1=true end end;ct.UpdateAutopilotTarget()cu.showWayPoint(c9,bm)if fX~=nil then if fX.agg and not r and antigrav then if not cR then cu.ToggleAntigrav()end;bx=fX.agg end;bv=nil;bz=fX.planetname=="Space"if bz then fL("apSpc","AP")if ch then ce=true;cu.ToggleAltitudeHold()else b5=true end elseif kw.name==fX.planetname then qV=true;if ch then if not bs then fL("vtt","AP")q_(bz)if r1 then bc=kw.noAtmosphericDensityAltitude+V end end else fL("apOn","AP")if not(c9.name==kw.name and cj<gg*1.5)then cF=false;b5=true elseif not ch then if bB then cu.ToggleIntoOrbit()end;cE=kw.noAtmosphericDensityAltitude+V;pS=true;q3.AutopilotAlign=true;q3.VectorToTarget=true;pQ=false;if not bB then cu.ToggleIntoOrbit()end end end else fL("apP","AP")b3=false;b4=false;if ch then ce=true;cu.ToggleAltitudeHold()else b5=true end end elseif not ch then if fX==nil and(c9.name==kw.name and cZ)and not bB then r4=false;cF=false;pQ=false;cu.ToggleIntoOrbit()else fL("apP","AP")b5=true;b3=false;b4=false;be=false;c1=false;b7=false;b8=false;ba=false;b9=false;pX=false;bv=nil;r4=false end else fL("apP","AP")ce=true;cu.ToggleAltitudeHold()end;qi=false else fL("apOff","AP")cu.ResetAutopilots(1)if qi==2 then qi=true end end end;function pG.routeWP(r5,r6,r7)if r7 then if r7==1 then bH={}bH=iB(bH,bG)if#bH>0 then dj("Route Loaded")else dj("No Saved Route found on Databank")end;return bH else bG={}bG=iB(bG,bH)dj("Route Saved")pF()return end end;if r5 then return bH end;if r6 then bH={}dj("Current Route Cleared")else bH[#bH+1]=fX.name;dj("Added "..fX.name.." to route. ")end;return bH end;function pG.cmdThrottle(dN,r8)if iz:getAxisCommandType(0)~=axisCommandType.byThrottle and not r8 then d.control.cancelCurrentControlMasterMode()end;iz:setThrottleCommand(axisCommandId.longitudinal,dN)bS=dm(fM(dN*100,0)/100,-1,1)q5=nil end;function pG.cmdCruise(dN,r8)if iz:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r8 then d.control.cancelCurrentControlMasterMode()end;iz:setTargetSpeedCommand(axisCommandId.longitudinal,dN)q5=dN end;function pG.ToggleLockPitch()if bv==nil then fL("lkPOn","LP")if not c2 then bv=cT else bv=S end;b9=false;b7=false;b8=false else fL("lkPOff","LP")bv=nil end end;function pG.ToggleAltitudeHold()if bR-pM<1.5 then bJ=false;if kw.hasAtmosphere then if ch then bc=kw.spaceEngineMinAltitude-0.01*kw.noAtmosphericDensityAltitude;fL("11","EP")else if cZ then bc=kw.noAtmosphericDensityAltitude+V;cE=bc;pS=true;if not bB then cu.ToggleIntoOrbit()end;pQ=true end end;pM=-1;if b7 or bB or bb then return end end else pM=bR end;if cZ and not ch and cg==-1 then cE=cj;pS=true;pQ=true;cu.ToggleIntoOrbit()if bB then pM=bR else pM=0 end;return end;b7=not b7;b8=false;ba=false;if b7 then b5=false;b4=false;b3=false;c1=false;cA=true;bv=nil;cF=false;if cg~=-1 then if not bo and not bs and not ce then bc=cj;bJ=cg;iz:setTargetGroundAltitude(bJ)elseif cM<20 then if bo then cw.landingGear()end;fL("lfs","LS")b9=true;if ch then bc=cj+Y else bc=kw.surfaceMaxAltitude+100 end;b2="ATO Hold"iz:setTargetGroundAltitude(Z)if b1 and cQ then cu.ToggleVerticalTakeoff()end end else fL("altOn","AH")b9=false;if pM>-1 then if cZ then bc=cj end end;if bb then cu.ToggleVerticalTakeoff()end end;if cR and not r then local r9=antigrav.getBaseAltitude()if bs and fX.agg and fX.agg>cj then bc=fX.agg elseif b9 then bc=r9 end;if e_(cj-r9)<100 and cM<20 then bc=r9;b2="AGG Hold"q7=0 end end;if ce then bc=200000 end else fL("altOff","AH")if bB then cu.ToggleIntoOrbit()end;if bb then cu.ToggleVerticalTakeoff()end;cA=q;b9=false;bs=false;pM=0;bJ=false end end;function pG.ResetAutopilots(pG)if pG then ce=false;b5=false;be=false;pX=false;bc=cj;r2=false;dc=false;bi="Aligning"end;bs=false;b9=false;ba=false;b4=false;b8=false;dd=nil;ra=false;cY=nil;dc=false;if not cR then b7=false;bv=nil end;if bb then cu.ToggleVerticalTakeoff()end;if bB then cu.ToggleIntoOrbit()end;cA=q;cd=false;cf=false;c0=0 end;function pG.BrakeToggle(rb)if not b2 then if rb then b2=rb else b2=true end else b2=false end;if b8 then b8=false;cA=q;dc=false end;if b2 then fL("bkOn","B",1)cu.ResetAutopilots()else fL("bkOff","B",1)end end;function pG.BeginReentry()if ba then dj("Re-Entry cancelled")fL("reOff","RE")ba=false;cA=q;b7=false elseif not kw.hasAtmosphere then dj("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c5=5 elseif not pY then ba=true;if iz:getAxisCommandType(0)~=rc.cruise then d.control.cancelCurrentControlMasterMode()end;cA=true;b2=false;dj("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cC)fL("par","RE")else ba=true;b7=true;cA=true;b2=false;bc=kw.surfaceMaxAltitude+a0;if bc>kw.spaceEngineMinAltitude then bc=kw.spaceEngineMinAltitude-0.01*kw.noAtmosphericDensityAltitude end;local rd=iD(bc)dj("Beginning Re-entry.  Target speed: "..cC.." Target Altitude: "..rd)fL("glide","RE")q8=bO(cC)end;b9=false end;function pG.ToggleAntigrav()if antigrav and not r then if cR then fL("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bx==nil then bx=cj end;if bx<1000 then bx=1000 end;fL("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pG.changeSpd(re)local rf=1;if re then rf=-1 end;if not c2 then if t and not p5 and pW then local rg=bS;bS=fM(dm(bS+rf*aF/100,-1,1),2)if bS>=0 and rg<0 then bS=0;pW=false end elseif p5 then if ch or ba then cC=dm(cC+rf*aF,0,W)elseif b5 then a1=dm(a1+rf*aF/3.6*100,0,dg-0.2)end else iz:updateCommandFromActionStart(axisCommandId.longitudinal,rf*aF/10)end else if b5 or bs or ce or bB then d2=d2+1*rf*-1;if d2>#cV then d2=1 end;if d2<1 then d2=#cV end else if not re then rf=1 else rf=nil end;ct.adjustAutopilotTargetIndex(rf)end end end;function pG.TenthTick()local function rh()if not b5 then if fX==nil or fX.planetname~=kw.name then ri=(c9.center-cP):len()else ri=(fX.position-cP):len()end end;local kh=cM;local rj=c.getThrottle()/100;if t then rj=bS end;local rk,rl=cq.computeDistanceAndTime(cM,a1,ck,d:maxForceForward()*rj,a3,0)local c7,c8;if not b6 then c7,c8=cu.GetAutopilotBrakeDistanceAndTime(a1)else c7,c8=cu.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dR,rm;if not b6 and kh>0 then dR,rm=cu.GetAutopilotBrakeDistanceAndTime(kh)else dR,rm=cu.GetAutopilotTBBrakeDistanceAndTime(kh)end;local rn=0;local ro=0;if bg or not b5 and kh>5 then ro=cq.computeTravelTime(kh,0,ri)elseif c7+rk<ri then rn=ri-(c7+rk)ro=cq.computeTravelTime(a1,0,rn)else local rp=(ri-c7)/rk;rk=ri-c7;rl=rl*rp end;if fX~=nil and fX.planetname==kw.name and not b5 then return ro elseif bf then return rm elseif bg then return ro+rm else return rl+c8+ro end end;local function rq()local oa=b.getGravityIntensity()oa=fM(oa,5)if pV==nil or pV~=oa then local kh=cK:len()local rr=bQ.getMaxBrake()if rr~=nil and rr>0 and ch then rr=rr/dm(kh/100,0.1,1)rr=rr/ci;if ci>0.10 then bw=rr end end;if rr~=nil and rr>0 then bu=rr end;pV=oa end end;d4=bQ.getDockedConstructs()d3=bQ.getPlayersOnBoard()qm=0;for M=1,#d4 do qm=qm+bQ.getDockedConstructMass(d4[M])end;local rs=0;for M=1,#d3 do rs=rs+bQ.getBoardedPlayerMass(d3[M])end;if rs>20000 then qm=qm+rs-20000 end;cW,cX=qn()dg=bQ.getMaxSpeed()if bl~="None"and(c9 or fX)then lp=rh()end;rq()end;local function rt(ru,rv)local oz=vec3()local rw=vec3()if ru==axisCommandId.longitudinal then oz=vec3(bQ.getOrientationForward())rw=cI elseif ru==axisCommandId.vertical then oz=vec3(bQ.getOrientationUp())rw=q4 elseif ru==axisCommandId.lateral then oz=vec3(bQ.getOrientationRight())rw=cJ else return vec3()end;local rx=vec3(b.getWorldGravity())local ry=rx:dot(rw)local rz=vec3(bQ.getWorldAirFrictionAcceleration())local rA=rz:dot(rw)local rB=cK:dot(oz)local rC=rv*constants.kph2m;if rD==nil then rD=pid.new(10,0,10.0)end;rD:inject(rC-rB)local rE=rD:get()local rF=(rE-rA-ry)*rw;return rF end;local function rG(ru,rv)local oz=vec3()local rw=vec3()if ru==axisCommandId.longitudinal then oz=vec3(bQ.getOrientationForward())rw=cI elseif ru==axisCommandId.vertical then oz=vec3(bQ.getOrientationUp())rw=q4 elseif ru==axisCommandId.lateral then oz=vec3(bQ.getOrientationRight())rw=cJ else return vec3()end;local rx=vec3(b.getWorldGravity())local ry=rx:dot(rw)local rz=vec3(bQ.getWorldAirFrictionAcceleration())local rA=rz:dot(rw)local rB=cK:dot(oz)local rC=rv*constants.kph2m;if rH==nil then rH=pid.new(10,0,10.0)end;rH:inject(rC-rB)local rE=rH:get()local rF=(rE-rA-ry)*rw;return rF end;local function rI(rJ,jW,fT)local rK=rJ:cross(fT):normalize_inplace()local kJ=math.acos(dm(rK:dot(-jW),-1,1))*constants.rad2deg;if rK:cross(-jW):dot(fT)<0 then kJ=-kJ end;return kJ end;local function rL()if d0 and not b8 then local et=d0[1]local hW,hX=d0[2],d0[3]local rM=math.min(hW,hX or hW)local rN=rM/cM;local rO=b9 and(cM<42 or cg~=-1)local rP=b7 or bs or bv or b5;if rP and not rO and(c7*1.5>rM or rN<1)then b2="Collision"bH={}q7=0;if b7 then cu.ToggleAltitudeHold()end;if bv then cu.ToggleLockPitch()end;dj("Autopilot Cancelled due to possible collision")a.print(et.name.." COLLISION "..iE(rN).." / "..iD(rM,2))cu.ResetAutopilots(1)qV=true;if ch then b8=true end;cA=true end;if rN<11 then c_=et.name.." COLLISION "..iE(rN).." / "..iD(rM,2)else c_=et.name.." collision "..iE(rN)end;if rN<6 then fL("alarm","AL",2)end else c_=false end end;local rQ=1;local rR=0;local rS=1;local rT=1;local rU=1;local rV=false;function pG.onFlush()if antigrav and not r and not cR and antigrav.getBaseAltitude()~=bx then qh=bx end;if df then d:setEngineForceCommand('hover',vec3(),1)df=false end;cS=iz:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local rW=dm(bY+pZ+a.getControlDeviceForwardInput(),-1,1)local rX=dm(bZ+q0+a.getControlDeviceYawInput(),-1,1)local rY=dm(b_+p_-a.getControlDeviceLeftRightInput(),-1,1)local rZ=b2 and 1 or 0;cN=vec3(b.getWorldVertical())if cN==nil or cN:len()==0 then cN=(kw.center-cP):normalize()end;q4=vec3(bQ.getWorldOrientationUp())cI=vec3(bQ.getWorldOrientationForward())cJ=vec3(bQ.getWorldOrientationRight())cL=vec3(bQ.getWorldVelocity())cK=vec3(bQ.getVelocity())cP=vec3(bQ.getWorldPosition())ck=bQ.getMass()+qm;cM=vec3(cL):len()cO=-cN:dot(cL)cU=getRoll(cN,cI,cJ)local r_=cU/180*math.pi;local s0=math.cos(r_)local s1=math.sin(r_)cT=rI(cN,cI,cJ*s0+q4*s1)local s2=cL:normalize()local s3=e_(cU)local s4=utils.sign(cU)local s5=vec3(bQ.getWorldAngularVelocity())local s6=rW*aP*cJ+rX*aK*cI+rY*aQ*q4;if cA==true and cN:len()>0.01 then local s7=e_(q1-cU)if((b4 or ba or b8 or cd or b7 or bB)and s7>0 or ch and s7<aL and q)and rX==0 and e_(cT)<85 then local s8=q1;local s9=aJ;if not ch then s9=s9/4;q1=0;s8=0 end;if sa==nil then sa=pid.new(s9*0.01,0,s9*0.1)end;sa:inject(s8-cU)local sb=sa:get()s6=s6+sb*cI end end;bT=0;ci=bP()ch=false or cj<kw.noAtmosphericDensityAltitude and ci>0.00001;cj=b.getAltitude()cg=qy()bR=bN()pL=bR;if bo and cg>-1 and cg-3<_ then if iz.targetGroundAltitudeActivated then iz:deactivateGroundEngineAltitudeStabilization()end end;if cv then qk=not qk;if qk then cv.UpdateRadar()end;if E then rL()end end;if antigrav then cR=antigrav.isActive()==1 end;local sc=bR-pL;local sd=-math.deg(qs(q4,cL,cI))local se=math.deg(qs(cJ,cL,cI))local gi=cN*-1;cB=ch and sd<-N or sd>N or se<-O or se>O;local sf=a.getMouseDeltaX()local sg=a.getMouseDeltaY()if ql then local sh=bN()-ql;sf=sf*sh/0.016;sg=sg*sh/0.016 end;ql=bN()if p and not c2 then sg=-sg end;p_=0;q0=0;pZ=0;local si=bQ.getWorldPosition()kw=fP:closestBody(si)sj=cr(kw)fl=sj:orbitalParameters(si,cL)if cj==0 then cj=(cP-kw.center):len()-kw.radius end;cZ=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;local oa=kw:getGravity(si):len()*ck;q1=0;local sk=bQ.getMaxThrustAlongAxis("ground",bQ.getOrientationUp())[1]if qb==0 then if iy()==1 and c2 then if not cy then ca=dm(ca+sf/2,-ad/2,ad/2)cb=dm(cb+sg/2,-ae/2,ae/2)end else ca=0;cb=0 end else ca=dm(ca+sf/2,-ad/2,ad/2)cb=dm(cb+sg/2,-ae/2,ae/2)de=dp(ca*ca+cb*cb)if not c2 and iy()==0 then local kS,kT=1,1;if bL=="SCOPE"then kS,kT=d6/90,d6/90 end;if g=="virtual joystick"then if de>aA then p_=p_-dm(e_(ca)-aA,0,ad/2)*utils.sign(ca)*aH*kS;pZ=pZ-dm(e_(cb)-aA,0,ae/2)*utils.sign(cb)*aI*kT end else ca=0;cb=0;if g=="mouse"then pZ=(-utils.smoothstep(sg,-100,100)+0.5)*2*rT;p_=(-utils.smoothstep(sf,-100,100)+0.5)*2*rU end end end end;local sl=cM>27777;if cM>X/3.6 and not ch and not b5 and not sl then dj("Space Speed Engine Shutoff reached")q7=0 end;if not sl and sm then if not b2 then cu.BrakeToggle()end;if b5 then cu.ResetAutopilots(1)end;q7=0 end;sm=sl;if ci>0.09 then if cM>cC/3.6 and not t and not pH then b2="SpdLmt"pH=true elseif not t and pH then if cM<cC/3.6 then b2=false;pH=false end end end;if b4 then if cd then b2=false;local sn=false;sn=qK(fX.position-cP,0.1)cA=true;if sn then q8=bO(cC)if(e_(cU)<2 or e_(cT)>85)and cM>=cC/3.6-1 then b2=false;b4=false;if cd~=2 then pY=true end;if cd==true then cf=true end;cd=false;b5=false;cu.BeginReentry()end elseif ch and t then q7=1 end elseif cM>iS then qK(vec3(cL),0.01)end end;if b3 then if ch then b3=false elseif cM>iS then qK(-vec3(cL))end end;if not b4 and cd and not bB then if not ch then if cd~=2 then pY=true end;cu.BeginReentry()cd=false;cf=true else cd=false;if not qi then qi=true end end end;if cf and fX and(cj<bc+250 and cj>bc-250)and e_(cO)<25 and ci>=0.1 and(fX.position-cP):len()>2000+cj then if not qi then qi=true end;cf=false end;if bb then cA=true;local so=bc;if cO<-30 then dj("Unable to achieve lift. Safety Landing.")c0=0;cA=q;bb=false;b8=true elseif not r and cR or bc<kw.spaceEngineMinAltitude then if cR then so=antigrav.getBaseAltitude()end;if cj<so-100 then q2=0;c0=15;b2=false elseif cO>0 then b2="VTO Limit"c0=0 elseif cO<-30 then b2="VTO Fall"c0=15 elseif cj>=so then if cR then if b5 or bs then cu.ToggleVerticalTakeoff()else b2="VTO Complete"bb=false end;dj("Takeoff complete. Singularity engaged")fL("aggLk","AG")else b2=false;dj("VTO complete. Engaging Horizontal Flight")fL("vtoc","VT")cu.ToggleVerticalTakeoff()end;c0=0 end else if ci>0.08 then q2=0;b2=false;c0=20 elseif ci<0.08 and ch then b2=false;if cG then q2=0;c0=20 else c0=0;q2=36;q8=3500 end else cA=q;bB=true;cF=false;sp=false;pQ=false;pO=nil;pP=nil;if pT==nil then pT=kw end;cE=so;pS=true;bb=false end end;if q2~=nil then if sq==nil then sq=pid.new(2*0.01,0,2*0.1)end;local sr=dm(q2-cT,-O*0.80,O*0.80)sq:inject(sr)local ss=dm(sq:get(),-1,1)pZ=ss end end;if bB then local function st()if fl.periapsis.altitude>=cE*0.99 and fl.apoapsis.altitude>=cE*0.99 and fl.periapsis.altitude<fl.apoapsis.altitude and fl.periapsis.altitude*1.05>=fl.apoapsis.altitude and e_(cE-cj)<1000 then return true else return false end end;local qR;local su=false;local sv=iD(cE,3)if pT==nil then pT=kw;if bs then pT=c9 end end;if not pS then cE=bO(pT.radius+pT.surfaceMaxAltitude+V)if pT.hasAtmosphere then cE=bO(pT.radius+pT.noAtmosphericDensityAltitude+V)end;pS=true end;if q3.VectorToTarget and fX then qR=fX.position-cP end;local sw,sx=cr(pT):escapeAndOrbitalSpeed((cP-pT.center):len()-pT.radius)local sy=cU;if not pQ then local sz=false;local sA=false;q7=0;pP=0;cD="Aligning to orbital path - OrbitHeight: "..sv;if q3.VectorToTarget then qK(qR:normalize():project_on_plane(cN))su=cI:dot(qR:project_on_plane(q4):normalize())>0.95 else qK(cL)su=sd<0.5;if cM<150 then su=true end end;pZ=0;pO=0;if cT<=pO+2 and cT>=pO-2 then sz=true else sz=false end;if sy<=pP+2 and sy>=pP-2 then sA=true else sA=false end;if sz and sA and su then pO=nil;pP=nil;pQ=true end else if q3.VectorToTarget then qK(qR:normalize():project_on_plane(cN))elseif cM>150 then qK(cL)end;pZ=0;if q3.VectorToTarget and fX then local c7,dR=cq.computeDistanceAndTime(cM,cC/3.6,ck,0,0,bu)if cF and qR:len()>15000+c7+cj then cD="Orbiting to Target"if cj-100<=pT.noAtmosphericDensityAltitude or lp>fl.timeToPeriapsis and fl.periapsis.altitude<pT.noAtmosphericDensityAltitude or not st()and fl.eccentricity>0.1 then dj("Re-Aligning Orbit")cF=false end elseif cF or qR:len()<15000+c7+cj then dj("Orbit complete, proceeding with reentry")fL("orCom","OB")bm=fX.position;pY=true;cf=true;q3.VectorToTarget,q3.AutopilotAlign=false,false;cu.ToggleIntoOrbit()cu.BeginReentry()return end end;if fl.periapsis~=nil and fl.apoapsis~=nil and fl.eccentricity<1 and cj>cE*0.9 and cj<cE*1.4 then if fl.apoapsis~=nil then if(st()or cF)and not K then if cF then b2=false;q7=0;pO=0;if not q3.VectorToTarget then dj("Orbit complete")fL("orCom","OB")cu.ToggleIntoOrbit()end else pU=pU+1;if pU>=2 then cF=true end end else if st()then cD="Maintaining "else cD="Adjusting "pR=true;q8=sx*3.6+1;local sB=cE-cj;if sC==nil then sC=pid.new(0.1,0,1*0.1)end;sC:inject(sB-cO*dm(utils.smoothstep(2000-sB,-2000,2000)^6*10,1,10))pO=dm(sC:get(),-60,60)end;cD=cD.." - OrbitHeight: "..sv end end else local sD=2.75;local sE=e_(fM(sw*sD))local on=sE%50;if on>0 then sE=sE-on+50 end;b2=false;if cj<cE*0.8 then cD="Escaping planet gravity - OrbitHeight: "..sv;pO=utils.map(cO,200,0,-15,80)elseif cj>=cE*0.8 and cj<cE*1.15 then cD="Approaching orbital corridor - OrbitHeight: "..sv;sE=sE*0.75;pO=utils.map(cO,100,-100,-15,65)elseif cj>=cE*1.15 and cj<cE*1.5 then cD="Approaching orbital corridor - OrbitHeight: "..sv;sE=sE*0.75;if cO<0 or pR then pO=utils.map(cj,cE*1.5,cE*1.01,-30,0)else pO=utils.map(cj,cE*0.99,cE*1.5,0,30)end elseif cj>cE*1.5 then cD="Reentering orbital corridor - OrbitHeight: "..sv;pO=-65;local sF=utils.map(cO,-150,-400,1,0.55)sE=sE*sF end;q8=bO(sE)end end;if pO~=nil then if sG==nil then sG=pid.new(1*0.01,0,5*0.1)end;local sH=pO-cT;sG:inject(sH)local sI=dm(sG:get(),-0.5,0.5)pZ=sI end end;if b5 and not ch and not cd then local function sJ(sK,fl)a.print(sK)b4=false;b2=false;bf=false;b5=false;r2=false;bi="Aligning"q7=0;pX=false;dj(sK)fL("apCom","AP")if fl or cd then if fl and gg~=nil and not cd then if not cj or cj==0 then return end;cE=cj;pS=true end;cu.ToggleIntoOrbit()end end;local sL,sM=bm,false;if fX and fX.planetname~="Space"then be=true;if not r2 then local sN=(fX.position-c9.center):normalize()local sO=sN:project_on_plane((c9.center-cP):normalize()):normalize()local sP=c9.center+sO*(c9.radius+gg)local sQ=fX.position+(fX.position-c9.center):normalize()*(gg-c9:getAltitude(fX.position))if(cP-sP):len()<(cP-sQ):len()then sL=sP else sL=sQ;bh=0 end;bm=sL;cu.showWayPoint(c9,bm)sM=true;r2=true end;bj=0 elseif fX and fX.planetname=="Space"then if not r2 then bj=0;sM=true;be=true;r2=true;sL=fX.position+(cP-fX.position):normalize()*T;bm=sL end elseif fX==nil then bj=0;if not r2 then local sN=(cP+cL*100000-c9.center):normalize()local sO=sN:project_on_plane((c9.center-cP):normalize()):normalize()if sO:len()<1 then sN=(cP+cI*100000-c9.center):normalize()sO=sN:project_on_plane((c9.center-cP):normalize()):normalize()end;sL=c9.center+sO*(c9.radius+gg)bm=sL;r2=true;sM=true;be=true;cu.showWayPoint(c9,bm)end end;ri=(vec3(sL)-cP):len()local ln,eK,eL=cp:getPlanetarySystem(0):castIntersections(cP,cL:normalize(),function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)local lo=eK;if eL~=nil and eK~=nil then lo=math.min(eL,eK)end;if lo~=nil and lo<ri and ln.name==c9.name then ri=lo end;local sn=true;local sR=(c9.center-(cP+vec3(cL):normalize()*ri)):len()-c9.radius;local lk=iD(sR)qf=g8;qg='{"label": "Projected Altitude", "value": "'..lk..'"}'if cM>50 and bd then local qR=vec3(sL)-cP;local sS=dm(math.deg(qs(q4,cL:normalize(),qR:normalize()))*cM/500,-90,90)local sT=dm(math.deg(qs(cJ,cL:normalize(),qR:normalize()))*cM/500,-90,90)if e_(sS)<20 and e_(sT)<20 then sS=sS*2;sT=sT*2 end;if e_(sS)<2 and e_(sT)<2 then sS=sS*2;sT=sT*2 end;local sd=-math.deg(qs(q4,cI,cL:normalize()))local se=-math.deg(qs(cJ,cI,cL:normalize()))if sU==nil then sU=pid.new(2*0.01,0,2*0.1)end;sU:inject(sT-se)local sV=dm(sU:get(),-1,1)pZ=pZ+sV;if sW==nil then sW=pid.new(2*0.01,0,2*0.1)end;sW:inject(sS-sd)local sX=dm(sW:get(),-1,1)p_=p_+sX;sM=true;if e_(sS)>2 or e_(sT)>2 then if bi~="Adjusting Trajectory"then bi="Adjusting Trajectory"fL("apAdj","AP")end else if bi~="Accelerating"then bi="Accelerating"fL("apAcc","AP")end end elseif bd and cM<=50 then qK((sL-cP):normalize())end;if sR<gg*1.5 then bh=cC/3.6;if fX==nil then dR,bh=cr(c9):escapeAndOrbitalSpeed(sR)end end;local c7,c8;if not b6 then c7,c8=qo(cM)else c7,c8=qr(cM)end;if b5 and not bd and not bg and not bf then local ln,lo=cu.checkLOS((bm-cP):normalize())if c9.name~=kw.name then if ln~=nil and c9.name~=ln.name and lo<ri then c_="Attempting to clear LOS between "..ln.name.." and waypoint."qc=true else qc=false;c_=false end end end;if not qc then if not bg and not bf and not sM then sn=qK((sL-cP):normalize())elseif b6 and(bf or bg)then sn=qK(-vec3(cL):normalize())end end;if bd then if not pX then b2=false;q7=a2;bS=fM(a2,2)pX=true end;local rj=c.getThrottle()if t then rj=bS end;local sY=99999;local ol=-vec3(bQ.getWorldAcceleration()):dot(cL:normalize())local sZ=dm(cL:dot((sL-cP):normalize()),0,cM)if sZ>0 or ol>0 then sY=cq.computeTravelTime(sZ,ol,ri-c7)end;if a1>dg then a1=dg-0.2 end;if cK:len()>=a1 or rj==0 and pX or a3/4>sY then bd=false;if bi~="Cruising"then fL("apCru","AP")bi="Cruising"end;bg=true;q7=0 end;local s_=ri;if s_<=c7 or H and cX<=c7+10000 and cW then if H and cX<=c7+10000 and cW then if cX<pI and cX>2000 then cu.ResetAutopilots(1)dj("Autopilot cancelled to prevent crossing PvP Line")b2="PvP Prevent"pI=cX else pI=cX;return end end;bd=false;if bi~="Braking"then fL("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cA=true end;q7=0;pX=false end elseif bf then if bi~="Orbiting to Target"then b2="AP Brk"end;if b6 then q7=1;q9=true end;local dR,sx=cr(c9):escapeAndOrbitalSpeed((cP-kw.center):len()-kw.radius)local qR;if fX then qR=fX.position-cP end;if fX and fX.planetname=="Space"and cM<50 then if#bH>0 then if not qi then table.remove(bH,1)end;if#bH>0 then b2=false;if not qi then qi=2 end;return end end;sJ("Autopilot complete, arrived at space location")b2="Space Arrival"elseif fX and fX.planetname~="Space"and cM<=sx and(fl.apoapsis==nil or fl.periapsis==nil or fl.apoapsis.altitude<=0 or fl.periapsis.altitude<=0)then sJ("Autopilot complete, commencing reentry")bm=fX.position;cd=true;cu.showWayPoint(c9,bm)elseif(fX and fX.planetname~="Space"or fX==nil)and fl.periapsis~=nil and fl.periapsis.altitude>0 and fl.eccentricity<1 or bi=="Circularizing"then if bi~="Circularizing"then fL("apCir","AP")bi="Circularizing"end;if cM<=sx then if fX then if cL:normalize():dot(qR:normalize())>0.4 then if bi~="Orbiting to Target"then fL("apOrb","OB")bi="Orbiting to Target"end;if not r4 then b2=false;cu.showWayPoint(c9,fX.position)r4=true end else sJ("Autopilot complete, proceeding with reentry")bm=fX.position;cd=true;cu.showWayPoint(c9,fX.position)r4=false end else sJ("Autopilot completed, setting orbit",true)b2=false end end elseif bi=="Circularizing"then sJ("Autopilot complete, fixing Orbit",true)end elseif bg then local s_=ri;if s_<=c7 or H and cX<=c7+10000 and cW then if H and cX<=c7+10000 and cW then if cX<pI and cX>2000 then if not qi then qi=true end;dj("Autopilot cancelled to prevent crossing PvP Line")b2="Prevent PvP"pI=cX else pI=cX;return end end;bd=false;if bi~="Braking"then fL("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cA=true end end;local rj=c.getThrottle()if t then rj=bS end;if rj>0 then bd=true;if bi~="Accelerating"then bi="Accelerating"fL("apAcc","AP")end;bg=false end else if sn then if not be and fX==nil or not be and fX and fX.planetname~="Space"then if not cd then bm=vec3(c9.center)+(gg+c9.radius)*cJ;t0=q4;t1=cJ end;be=true elseif sn and not qc then bd=true;if bi~="Accelerating"then bi="Accelerating"fL("apAcc","AP")end;if not pX then q7=a2;q9=true;bS=fM(a2,2)pX=true;b2=false end end end end elseif b5 and(fX~=nil and fX.planetname~="Space"and ch)then dj("Autopilot complete, starting reentry")fL("apCom","AP")bm=fX.position;b2=false;bf=false;b5=false;r2=false;bi="Aligning"q7=0;pX=false;b4=true;cd=true;cu.showWayPoint(c9,fX.position)end;if c1 then cA=true;local sT=0;local fn=vec3(DUPlayer.getWorldPosition())local t2=fn-cP;local t3=vec3(t2):project_on(cI):len()local t4=vec3(t2):project_on(cJ):len()local cc=dp(t3*t3+t4*t4)qK(t2:normalize())local mw=40;local t5=cc<mw;local t6=100;local rv=dm((cc-mw)/2,10,t6)pZ=0;local sn=e_(p_)<0.1;if sn and cM<rv and not t5 then b2=false;sT=-20 else b2="Follow"sT=0 end;local t7=0;if e_(sT-cT)>t7 then if t8==nil then t8=pid.new(2*0.01,0,2*0.1)end;t8:inject(sT-cT)local sV=t8:get()pZ=sV end end;if b7 or b8 or ba or bs or bv~=nil then if bJ then if cg==-1 then bc=bc-0.2 else bc=cj+bJ-cg end end;local t9=bw;if t9 then t9=t9*dm(cM/100,0.1,1)*ci else t9=bu end;if not ch then t9=bu end;q6=cI:project_on_plane(cN):normalize():dot(cL)if q6>100 then c7,c8=cq.computeDistanceAndTime(q6,100,ck,0,0,t9)local ta,tb=cq.computeDistanceAndTime(100,0,ck,0,0,t9*0.55)c7=c7+ta else c7,c8=cq.computeDistanceAndTime(q6,0,ck,0,0,t9*0.55)end;local sB=bc-cj-cO;local tc=200+cM;if ba or cd then td=2000+cM end;local te=1;if b9 then te=dm(cM/100,0.1,1)end;local sT=(utils.smoothstep(sB,-tc,tc)-0.5)*2*Q*te;if not ba and not cd and not bs and cI:dot(cL:normalize())<0.99 then sT=(utils.smoothstep(sB,-tc*dm(20-19*ci*10,1,20),tc*dm(20-19*ci*10,1,20))-0.5)*2*Q*dm(2-ci*10,1,2)*te end;if not b7 then sT=0 end;if bv~=nil then if cZ and not bB then sT=bv else bv=nil end end;cA=true;local tf=pZ;if ba then local tg=bO(cC)local th,ti=cq.computeDistanceAndTime(cM,tg/3.6,ck,0,0,bu-kw.gravity*9.8*ck)th=th==-1 and 5000 or th;local r3=cj-(kw.noAtmosphericDensityAltitude+th)local tj=cj>kw.noAtmosphericDensityAltitude+th*1.35;if tj then sT=R;if cM<=tg/3.6 and cM>tg/3.6-10 and e_(cL:normalize():dot(cI))>0.9 and not cS then bW=false;q7=1 end elseif(cS or iz:getTargetSpeed(axisCommandId.longitudinal)~=tg)and not tj and not ch then q8=tg;q9=true end;if cS then if cM>tg/3.6 and not tj then b2="Reentry Limit"if bS>0 then q7=0 end else b2=false end else b2=false end;if cO>0 then b2="Reentry vSpd"end;if not pY then sT=-80;if cj<kw.surfaceMaxAltitude+(kw.atmosphereThickness-kw.surfaceMaxAltitude)*0.25 then dj("PARACHUTE DEPLOYED at "..fM(cj,0))ba=false;b8=true;qV=true;q7=0;sT=0;cA=q end elseif kw.noAtmosphericDensityAltitude>0 and tj then cA=true elseif not tj then if not ch and(cS or iz:getTargetSpeed(axisCommandId.longitudinal)~=tg)then q8=tg end;if cM<tg/3.6+1 then b2=false;pY=false;ba=false;cA=true;q7=1 end end end;if cM>iS and not ce and not bs and not b8 and u then qK(vec3(cL))end;if cY or(bs or ce)and bn>0 and ch then local qR;if cY then if type(cY)=="table"then qR=cY elseif cY<3 and cY>0 then qR=-cN:cross(cL)*5000 elseif cY>=3 then qR=cN:cross(cL)*5000 elseif cY<0 then qR=cL*25000 end elseif fX~=nil then qR=fX.position-cP else qR=c9.center-cP end;local sS=math.deg(qs(cN:normalize(),cL,qR))*2;local mz=math.rad(e_(cU))if cM>aM and ch then local tk=1000+cM;local tl=(utils.smoothstep(sB-cO*10,-tk,tk)-0.5)*2*Q;local tm=dm(90-tl,0,180)q1=dm(sS*2,-tm,tm)local tn=sS;sS=dm(dm(sS,-N*0.80,N*0.80)*math.cos(mz)+4*(cT-sT)*math.sin(math.rad(cU)),-N*0.80,N*0.80)local to=1;if q1~=0 then to=e_(mz/q1)end;to=(90-dm(e_(q1-cU),0,90))/90;local tp=sT;if e_(cU)>90 then tp=-tp end;sT=to*dm(dm(tp*math.cos(mz),-O*0.8,O*0.8)+e_(dm(e_(tn)*math.sin(mz),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q1=0;sS=dm(sS,-N*0.80,N*0.80)end;local tq=sd-sS;if cY and e_(tq)<=0.0001 and(type(cY)=="table"or type(cY)~="table"and cY<0 and e_(cU)<1)then if cY==-2 then cu.ToggleAltitudeHold()end;cY=nil;fL("180Off","BR")return end;if not cB and cM>aM and ch then if tr==nil then tr=pid.new(2*0.01,0,2*0.1)end;tr:inject(tq)local sX=dm(tr:get(),-1,1)p_=p_+sX elseif ch and cg>-1 or cM<aM then qK(qR)elseif cB and ch then if(sd<-N or sd>N)and ch then qK(cL)end;if(se<-O or se>O)and ch then sT=dm(cT-se,cT-O*0.80,cT+O*0.80)end end;if fX~=nil and not ce then local so=kw:getAltitude(fX.position)local r3=qR:project_on_plane(cN):len()qV=true;if bc<kw.noAtmosphericDensityAltitude and not ce and not b9 and not ba and(r3<=c7 and qR:len()<kw.radius)and(cL:project_on_plane(cN):normalize():dot(qR:project_on_plane(cN):normalize())>0.99 or lr=="Finalizing Approach")then lr="Finalizing Approach"if#bH>0 then if not qi then table.remove(bH,1)end;if#bH>0 then if not qi then qi=2 end;return end end;q7=0;if b7 then cu.ToggleAltitudeHold()bs=true end;b2="AP Finalizing"elseif not b9 then b2=false end;if lr=="Finalizing Approach"and(q6<0.1 or r3<0.1 or ts~=nil and ts<r3)then fL("bklOn","BL")b8=true;dc=true;if fX.heading then dd=fX.heading else dd=nil end;bs=false;lr="Proceeding to Waypoint"c_=false end;ts=r3 end elseif bs and not ch and bc>kw.noAtmosphericDensityAltitude and not(ce or ba)then if fX~=nil and c9.name==kw.name then local qR=fX.position-cP;local so=kw:getAltitude(fX.position)local r3=dp(qR:len()^2-(cj-so)^2)local t9=bw;if t9 then c7,c8=cq.computeDistanceAndTime(cM,0,ck,0,0,t9/2)qV=true;if r3<=c7+cM*sc/2 and cL:project_on_plane(cN):normalize():dot(qR:project_on_plane(cN):normalize())>0.99 then if kw.hasAtmosphere then b2=false;b4=false;pY=true;cd=false;cf=true;b5=false;cu.BeginReentry()end end;ts=r3 end end end;if not ch and cg==-1 and(b7 and bc>kw.noAtmosphericDensityAltitude)and not(ce or bB or ba)then if not cF and not bB then cE=bc;pS=true;if bs then q3.VectorToTarget=true end;cu.ToggleIntoOrbit()bs=false;pQ=true end end;if cB and ch and cg==-1 and cM>aM and lr~="Finalizing Approach"then qK(cL)sT=dm(cT-se,cT-O*0.80,cT+O*0.80)end;pZ=tf;local qD=-1;if b8 then local tt=aZ;if not qd then rV=false;if not cS then q7=0 end;if cg==-1 then iz:setTargetGroundAltitude(500)iz:activateGroundEngineAltitudeStabilization(500)end;bD=true;if not ch then rV=true end;qd=true end;sT=0;local tu=false;local tv=math.abs(q6)if not r and cR then tu=antigrav.getBaseAltitude()if tu<kw.surfaceMaxAltitude and fX==nil or fX~=nil and kw:getAltitude(fX.position)>tu then tu=false end else tu=false end;if dd then if tv<tt then if cO>-P then b2=false else b2="BL Align BLR"end;if qK(dd,0.001)then dd=nil;cA=q else pZ=0;cA=true end else b2="BL Align Hzn"end;if tu and e_(cj-tu)<250 then b2="AGG Align"end else local tw=false;local tx=30;if tv<10 and sk~=nil and sk>0 then local ty=dm(ci,0.4,2)local t9=bw*dm(cM/100,0.1,1)*ty;local tz=sk*ty+t9-oa;local tA=t9/2-oa;local tB=cM-dp(e_(tA/2)*20/(0.5*ck))*utils.sign(tA)if tB<0 then tB=0 end;local tC;if cM>100 then local tD,dR=cq.computeDistanceAndTime(cM,100,ck,0,0,t9)local tE,dR=cq.computeDistanceAndTime(100,0,ck,0,0,dp(t9))tC=tD+tE else tC=cq.computeDistanceAndTime(cM,0,ck,0,0,dp(t9))end;if tC<20 then b2=false else local tF=0;if tB>100 then local tG,dR=cq.computeDistanceAndTime(tB,100,ck,0,0,tz)local tH,dR=cq.computeDistanceAndTime(100,0,ck,0,0,sk*ty+dp(t9)-oa)tF=tG+tH else tF,dR=cq.computeDistanceAndTime(tB,0,ck,0,0,sk*ty+dp(t9)-oa)end;tF=(tF+15+cM*sc)*1.1;local tI=dc and fX~=nil and kw:getAltitude(fX.position)>0 and fX.safe;local so=nil;if tu and tu<cj then so=tu elseif tI then so=kw:getAltitude(fX.position)+250 elseif cj>kw.surfaceMaxAltitude then so=kw.surfaceMaxAltitude end;if d0 then local tJ=kw:getAltitude(d0[1].center)if so then if tJ>so then so=tJ end else so=tJ end end;if so~=nil then local tK=cj-so;tw=true;if tK<=tF or tF==-1 or tv>tt and dc then if so==kw.surfaceMaxAltitude and cO<-P then b2="BL Stop BLR"elseif tv>tt and dc then b2="BL AP Hzn"else b2="BL Stop Dist"end else b2=false end end end end;qD=cg;if qD>-1 then b2=false;if not tu and not bo then qa=true;iz:setTargetGroundAltitude(_)end;if(cM<1 or cL:normalize():dot(cN)<0)and not dd and qD-3<_ then b8=false;b7=false;c0=0;qW(0,1)b2="BL Complete"cA=q;dc=false;qd=false else if cO<-5 or tv>tt*10 then qW(0,1)b2="BL Slowing"else b2=false;qW(-1)end end elseif not tw then if qV and cL:normalize():dot(-gi)<0.999 then b2="BL Strong"qK()elseif tv>10 or tv>tt and dc then b2="BL hSpd"elseif cO<-P then b2="BL BLR"qW(0,1)else qW(-1)b2=false end end end else qd=false end;if b9 or ce then local ln,eL,eK;if bm~=nil then ln,eL,eK=cp:getPlanetarySystem(0):castIntersections(cP,(bm-cP):normalize(),function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)end;if ln~=nil then if ln.name~=c9.name and not ch then c_="Clearing LOS between "..ln.name.." and waypoint."end end;if cR and not ce then if cj>=bc-50 and cM>iS then b9=false;if not b5 and not bs then b2="ATO Agg Arrive"q7=0 end end elseif e_(sT)<15 and cj/bc>0.75 then b9=false;if not ce then if cS and not t then d.control.cancelCurrentControlMasterMode()end elseif ce and cM<iS then b5=true;ce=false;b7=false;b9=false;q7=0 elseif ce then q7=0;b2="ATO Space"end elseif ce and not ch and c9~=nil and(ln==nil or ln.name==c9.name)then b5=true;ce=false;b7=false;b9=false;if not cS then q7=0 end;bd=true end end;local tL=cg>-1;local tM=cT;if(bs or ce or cY)and not tL and cM>aM and ch then local mz=math.rad(e_(cU))tM=cT*e_(math.cos(mz))+se*math.sin(mz)end;local tN=dm(sT-tM,-O*0.80,O*0.80)if not ch and bs then tN=dm(sT-tM,-85,Q)elseif not ch then tN=dm(sT-tM,-Q,Q)end;if e_(cU)<5 or bs or cY or b8 or tL or b7 then if t8==nil then t8=pid.new(5*0.01,0,5*0.1)end;t8:inject(tN)local sV=t8:get()pZ=pZ+sV end end;if antigrav~=nil and(antigrav and not r and cj<200000)then if bx==nil or bx<1000 then bx=1000 end;if tO~=bx then tO=bx;qh=tO end end;if(ch or ba or cf)and t and cS then if tP==nil then tP=pid.new(0.1,0,1)end;local tQ=0;if aV>0 and not ba and ci>0.005 and ci<0.1 and cO>-50 then local tR=bQ.getFrictionBurnSpeed()*aV;local tS=cC/3.6;if tR>tS then tQ=tR-tS-1 end end;tP:inject(cC/3.6+tQ-cL:dot(cI))local tT=tP:get()bV=dm(tT,-1,1)if not d8 then if bV<bS and(ci>0.005 or ba or cf)then bU=true;d8=dm(bV,0.01,1)else bU=false;d8=bS end end;if tU==nil then tU=pid.new(1*0.01,0,1*0.1)end;tU:inject(cL:len()-cC/3.6-tQ)local tV=dm(tU:get(),0,1)if ch and cO<-80 or(ci>0.005 or ba or cf)then bT=tV end;if bT>0 then if bU and bV==0.01 and not d8 then d8=0 end else bV=dm(bV,0.01,1)end;local tW=''local tX=vec3()local tY=rt(axisCommandId.vertical,c0*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tY,rR)local tZ='thrust analog longitudinal 'if bE=="All"or bE=="Longitude"then tZ=tZ..aW end;local t_=iz:getAxisCommandType(axisCommandId.longitudinal)local u0=iz:composeAxisAccelerationFromThrottle(tZ,axisCommandId.longitudinal)local u1=rG(axisCommandId.lateral,bA*1000)tW=tW..' , '.."lateral airfoil , lateral ground "tX=tX+u1;if tX:len()>constants.epsilon then d:setEngineForceCommand(tW,tX,rR,'','','',rS)end;d:setEngineForceCommand(tZ,u0,rQ)local u2='thrust analog vertical fueled 'local u3='thrust analog lateral fueled 'if bE=="All"or bE=="Lateral"then u3=u3 ..aX end;if bE=="All"or bE=="Vertical"then u2=u2 ..aY end;if c0~=0 or b8 and b2 or not bo and not bD then d:setEngineForceCommand(u2,tY,rQ)else d:setEngineForceCommand(u2,vec3(),rQ)end;if bA~=0 then d:setEngineForceCommand(u3,u1,rQ)else d:setEngineForceCommand(u3,vec3(),rQ)end;if rZ==0 then rZ=bT end;local u4=-rZ*(aR*cL+aS*s2)d:setEngineForceCommand('brake',u4)else if t then if not d8 then d8=bS end end;local rv=c.getAxisCommandValue(0)if not cS then if tU==nil then tU=pid.new(1*0.01,0,1*0.1)end;tU:inject(cL:len()-rv/3.6)local tV=dm(tU:get(),0,1)rZ=dm(rZ+tV,0,1)end;local u4=-rZ*(aR*cL+aS*s2)d:setEngineForceCommand('brake',u4)local tW=''local tX=vec3()local u5=false;local tZ='thrust analog longitudinal 'if aW~="none"and(bE=="All"or bE=="Longitude")then tZ=tZ..aW end;local t_=iz:getAxisCommandType(axisCommandId.longitudinal)if t_==axisCommandType.byThrottle then local u0=iz:composeAxisAccelerationFromThrottle(tZ,axisCommandId.longitudinal)d:setEngineForceCommand(tZ,u0,rQ)elseif t_==axisCommandType.byTargetSpeed then local u0=iz:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tW=tW..' , '..tZ;tX=tX+u0;if iz:getTargetSpeed(axisCommandId.longitudinal)==0 or iz:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iz:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u5=true end end;local u3='thrust analog lateral 'if aX~="none"and(bE=="All"or bE=="Lateral")then u3=u3 ..aX end;local u6=iz:getAxisCommandType(axisCommandId.lateral)if u6==axisCommandType.byThrottle then local u7=iz:composeAxisAccelerationFromThrottle(u3,axisCommandId.lateral)d:setEngineForceCommand(u3,u7,rQ)elseif u6==axisCommandType.byTargetSpeed then local u1=iz:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tW=tW..' , '..u3;tX=tX+u1 end;local u2='thrust analog vertical 'if aY~="none"and(bE=="All"or bE=="Vertical")then u2=u2 ..aY end;local u8=iz:getAxisCommandType(axisCommandId.vertical)if u8==axisCommandType.byThrottle then local tY=iz:composeAxisAccelerationFromThrottle(u2,axisCommandId.vertical)if c0~=0 or b8 and b2 then d:setEngineForceCommand(u2,tY,rQ,'airfoil','ground','',rS)else d:setEngineForceCommand(u2,vec3(),rQ)d:setEngineForceCommand('airfoil vertical',tY,rQ,'airfoil','','',rS)d:setEngineForceCommand('ground vertical',tY,rQ,'ground','','',rS)end elseif u8==axisCommandType.byTargetSpeed then if c0<0 then d:setEngineForceCommand('hover',vec3(),rQ)end;local u9=iz:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tW=tW..' , '..u2;tX=tX+u9 end;if tX:len()>constants.epsilon then if rZ~=0 or u5 or e_(s2:dot(cI))<0.5 then tW=tW..', brake'end;d:setEngineForceCommand(tW,tX,rR,'','','',rS)end end;local ua=aO*(s6-s5)local ub=vec3(bQ.getWorldAirFrictionAngularAcceleration())ua=ua-ub;d:setEngineTorqueCommand('torque',ua,rQ,'airfoil','','',rS)d:setBoosterCommand('rocket_engine')if c6 and not o then local kh=cK:len()local uc=0.15;if not cS then local ud=iz:getTargetSpeed(axisCommandId.longitudinal)if kh*3.6>ud*(1-uc)and ue then ue=false;d:toggleBoosters()elseif kh*3.6<ud*(1-uc)and not ue then ue=true;d:toggleBoosters()end else local rj=c.getThrottle()if t then rj=bS*100 end;local rv=rj/100;if not ch then rv=rv*a1;if kh>=rv*(1-uc)and ue then ue=false;d:toggleBoosters()elseif kh<rv*(1-uc)and not ue then ue=true;d:toggleBoosters()end else local tg=bO(cC)rv=rv*tg/3.6;if kh>=rv*(1-uc)and ue then ue=false;d:toggleBoosters()elseif kh<rv*(1-uc)and not ue then ue=true;d:toggleBoosters()end end end end end;if uf then for dM,dy in pairs(uf)do pG[dM]=dy end end;cg=qy()return pG end;local function ug(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uh,iy,iz,iA,ui,gD,fM,e5,dn,dm,fL,iC,pF,dj)local bQ=DUConstruct;local uj={}local uk=true;local ul=5;local um=5;local un=ul;local uo=um;local up=bR;function uj.landingGear(qa)bo=not bo;if bo then if b5 or bs or ce or bB then cu.ResetAutopilots(true)end;bv=nil;cu.cmdThrottle(0)if vBooster or hover then if(ch or cj<20000)and not qa and cg==-1 then fL("bklOn","BL")qV=true;ba=false;b9=false;bb=false;if b8 then dc=not dc end;cA=true;bo=false;b8=true else if bX then fL("grOut","LG",1)d.control.deployLandingGears()end;dc=false;if ch then cA=q;b2="Landing"end end;if qa or cg~=-1 and cg>_-3 then b8=true end;iz:setTargetGroundAltitude(_)b7=false;bJ=false elseif bX and not b8 then fL("grOut","LG",1)d.control.deployLandingGears()end else if b8 then b8=false end;if bX then fL("grIn","LG",1)d.control.retractLandingGears()end;iz:activateGroundEngineAltitudeStabilization(qZ)if bD then if _<iz.targetGroundAltitude then iz:setTargetGroundAltitude(iz.targetGroundAltitude)else iz:setTargetGroundAltitude(Z)end end end end;function uj.startControl(uq)local function ur(re)local rf=1;local function us(ut,re)local uu={kw.surfaceMaxAltitude+100,kw.spaceEngineMinAltitude-0.01*kw.noAtmosphericDensityAltitude,kw.noAtmosphericDensityAltitude+V,kw.radius*(U-1)+kw.noAtmosphericDensityAltitude}local uv=ut;for dR,dy in ipairs(uu)do if re and uv>dy then ut=dy elseif ut<dy and not re then ut=dy;break end end;return ut end;if re then rf=-1 end;if not r and cR then if c2 and re then bx=1000 elseif bx~=nil then bx=bx+rf*um;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end else bx=tO+rf*100 end elseif b7 or bb or bB then if bB then if c2 then cE=us(cE,re)else cE=cE+rf*ul end;if cE<kw.noAtmosphericDensityAltitude then cE=kw.noAtmosphericDensityAltitude end else if c2 and ch then bc=us(bc,re)bJ=false else bc=bc+rf*ul;if bJ then if bc>100 then bJ=false else iz:updateTargetGroundAltitudeFromActionStart(rf*1.0)bJ=d:getTargetGroundAltitude()end end end end else iz:updateTargetGroundAltitudeFromActionStart(rf*1.0)end end;local function uw(ux)if not ch then dj("Flight Assist in Atmo only")return end;local dv=type(ux)if cY==nil then if dv=="table"then if b5 or bs then cu.ToggleAutopilot()end;fL("180On","BR")elseif ux==1 then fL("bnkLft","BR")else fL("bnkRht","BR")end;if not b7 and not b5 and not bs then cu.ToggleAltitudeHold()if dv~="table"then ux=ux+1 end end;cY=ux else fL("180Off","BR")cY=nil end end;local function uy()if iA()==1 then ca=0;cb=0;ui(bk)elseif iy()==1 and y then cz=false;cy=false end;c2=false end;if uq=="gear"then cw.landingGear()elseif uq=="light"then if p5 then if iy()==1 then if DUPlayer.isFrozen()==1 then DUPlayer.freeze(0)dj("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(1)dj("Player Frozen, pitch/yaw/roll enabled")end else dj("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uq=="forward"then if p5 and not ch and not b5 then b4=not b4;b3=false else bY=bY-1 end elseif uq=="backward"then if p5 then if not ch then if not b5 then b3=not b3;b4=false else b6=not b6 end else uw(-cL*5000)end else bY=bY+1 end elseif uq=="left"then if p5 then uw(1)else bZ=bZ-1 end elseif uq=="right"then if p5 then uw(3)else bZ=bZ+1 end elseif uq=="yawright"then b_=b_-1;dd=nil elseif uq=="yawleft"then b_=b_+1;dd=nil elseif uq=="straferight"then iz:updateCommandFromActionStart(axisCommandId.lateral,1.0)bA=1 elseif uq=="strafeleft"then iz:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bA=-1 elseif uq=="up"then cu.vertical(1)if cg-3<_ and cj>0 and bo then cw.landingGear()end elseif uq=="down"then cu.vertical(-1)elseif uq=="groundaltitudeup"then ur()elseif uq=="groundaltitudedown"then ur(true)elseif uq=="option1"then uz=false;if p5 and c2 then local uA=""for M=1,#d3 do uA=uA.."| Name: "..a.getPlayerName(d3[M]).." Mass: "..fM(bQ.getBoardedPlayerMass(d3[M])/1000,1).."t "end;a.print("Onboard: "..uA)return end;ct.adjustAutopilotTargetIndex()elseif uq=="option2"then uz=false;if p5 and c2 then for M=1,#d3 do bQ.forceDeboard(d3[M])bQ.forceInterruptVRSession(d3[M])end;dj("Deboarded All Passengers")return end;ct.adjustAutopilotTargetIndex(1)elseif uq=="option3"then uz=false;if p5 and c2 then local uA=""for M=1,#d4 do uA=uA.."| ID: "..d4[M].." Mass: "..fM(bQ.getDockedConstructMass(d4[M])/1000,1).."t "end;a.print("Docked Ships: "..uA)return end;if x then if w then w=false else w=true end;if cv then cv.ToggleRadarPanel()end end elseif uq=="option4"then uz=false;if p5 and c2 then for M=1,#d4 do bQ.forceUndock(d4[M])end;dj("Undocked all ships")return end;cY=nil;cu.ToggleAutopilot()elseif uq=="option5"then uz=false;cu.ToggleLockPitch()elseif uq=="option6"then uz=false;if p5 and c2 then if shield then cx.ventShield()else dj("No shield found")end;return end;cu.ToggleAltitudeHold()elseif uq=="option7"then uz=false;if p5 and c2 then if shield then shield.toggle()return else dj("No shield found")return end end;E=not E;if E then dj("Collision System Enabled")else dj("Collision System Secured")end elseif uq=="option8"then uz=false;if p5 and c2 then if bn>0 and fX~=nil then cu.routeWP()else dj("Select a saved wp on IPH to add to or remove from route")end;return end;bD=not bD;if not bD then dj("DeCoupled Mode - Ground Stabilization off")iz:deactivateGroundEngineAltitudeStabilization()fL("gsOff","GS")else dj("Coupled Mode - Ground Stabilization on")iz:activateGroundEngineAltitudeStabilization(qZ)df=true;fL("gsOn","GS")end elseif uq=="option9"then uz=false;if p5 and c2 then iz:resetCommand(axisCommandId.longitudinal)iz:resetCommand(axisCommandId.lateral)iz:resetCommand(axisCommandId.vertical)cu.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cl=gyro.isActive()==1;if cl then fL("gyOn","GA")else fL("gyOff","GA")end else dj("No gyro found")end elseif uq=="lshift"then if p5 then c2=true end elseif uq=="brake"then if b0 or p5 then cu.BrakeToggle("Manual")elseif not b2 then cu.BrakeToggle("Manual")else b2="Manual"end elseif uq=="lalt"then uz=true;p5=true;if iy()==0 and not j and g=="keyboard"then ui(1)end elseif uq=="booster"then if o then d:toggleBoosters()elseif not c6 then if not ue then d:toggleBoosters()ue=true end;c6=true else if ue then d:toggleBoosters()ue=false end;c6=false end elseif uq=="stopengines"then local function uB()if bR-up<1.5 then fL("clear","CA")cu.clearAll()end end;uB()up=bR;if iz:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p5 then if cC>0 then cC=0 else cC=W end elseif bS~=0 then iz:resetCommand(axisCommandId.longitudinal)cu.cmdThrottle(0)else cu.cmdThrottle(100)end else if iz:getTargetSpeed(axisCommandId.longitudinal)~=0 then iz:resetCommand(axisCommandId.longitudinal)else if ch then cu.cmdCruise(cC)else cu.cmdCruise(a1*3.6)end end end elseif uq=="speedup"then cu.changeSpd()elseif uq=="speeddown"then cu.changeSpd(true)elseif uq=="antigravity"and not r then if antigrav~=nil then cu.ToggleAntigrav()else dj("No antigrav found")end elseif uq=="leftmouse"then c3=true;if c2 then uy()uz=false else c2=true;bk=iA()ui(1)end end end;function uj.stopControl(uq)local function uC()if not r and cR then uo=um end;if b7 or bb or bB then un=ul end end;if uq=="forward"then bY=0 elseif uq=="backward"then bY=0 elseif uq=="left"then if cY then if cY==2 then cY=-2 else cY=-1 end end;bZ=0 elseif uq=="right"then if cY then if cY==4 then cY=-2 else cY=-1 end end;bZ=0 elseif uq=="yawright"then b_=0 elseif uq=="yawleft"then b_=0 elseif uq=="straferight"then iz:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bA=0 elseif uq=="strafeleft"then iz:updateCommandFromActionStop(axisCommandId.lateral,1.0)bA=0 elseif uq=="up"then cu.vertical(0,-1)elseif uq=="down"then cu.vertical(0,1)elseif uq=="groundaltitudeup"then uC()uz=false elseif uq=="groundaltitudedown"then uC()uz=false elseif uq=="brake"then if not b0 and not p5 then if b2 then cu.BrakeToggle()else b2=false end end elseif uq=="lalt"then if c2 then c2=false end;if iy()==0 and j then if uz then if iA()==1 then ui(0)else ui(1)end else uz=true end elseif iy()==0 and not j and g=="keyboard"then ui(0)end;p5=false end end;function uj.loopControl(uq)local function uD(re)local rf=1;if re then rf=-1 end;if not r and cR then if bx~=nil then bx=bx+rf*uo;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end;uo=dm(uo*1.05,um,50)else bx=tO+rf*100 end elseif b7 or bb or bB then if bB then cE=cE+rf*un;if cE<kw.noAtmosphericDensityAltitude then cE=kw.noAtmosphericDensityAltitude end else bc=bc+rf*un end;un=dm(un*1.05,ul,50)else iz:updateTargetGroundAltitudeFromActionLoop(rf*1.0)end end;local function uE(re)local rf=1;if re then rf=-1 end;if not c2 then if t and not p5 then bS=dm(bS+rf*aG/100,-1,1)else iz:updateCommandFromActionLoop(axisCommandId.longitudinal,rf*aG)end end end;if uq=="groundaltitudeup"then if not c2 then uD()end elseif uq=="groundaltitudedown"then if not c2 then uD(true)end elseif uq=="speedup"then uE()elseif uq=="speeddown"then uE(true)end end;function uj.inputTextControl(rd)local function uF(uG,fn,gq)local function uH(fn)local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF='::pos{'..dE..','..dE..','..dE..','..dE..','..dE..'}'local dV,dW,e2,e3,e4=e5(fn,dF)if dV=="0"and dW=="0"then return vec3(dn(e2),dn(e3),dn(e4))end;e3=math.rad(e3)e2=math.rad(e2)local kw=e[dn(dV)][dn(dW)]local eW=math.cos(e2)local uI=vec3(eW*math.cos(e3),eW*math.sin(e3),math.sin(e2))return kw.center+(kw.radius+e4)*uI end;local fO=uH(fn)return ct.AddNewLocation(uG,fO,gq)end;local M;local uJ,im=nil,nil;local uK="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(rd," ")uJ=rd;if M~=nil and string.find(rd,"::")~=1 then uJ=string.sub(rd,0,M-1)im=string.sub(rd,M+1)end;if uJ=="/help"or uJ=="/commands"then for lm in string.gmatch(uK,"([^\n]+)")do a.print(lm)end;return elseif uJ=="/setname"then if im==nil or im==""then dj("Usage: ah-setname Newname")return end;if bn>0 and fX~=nil then ct.UpdatePosition(im)else dj("Select a saved target to rename first")end elseif shield and uJ=="/resist"then cx.setResist(im)elseif uJ=="/addlocation"or string.find(rd,"::pos")~=nil then local gq=false;local uG="0-Temp"if im==nil or im==""or uJ~="/addlocation"then im=uJ;gq=true end;M=string.find(im,"::")if not gq then uG=string.sub(im,1,M-2)end;local fn=string.sub(im,M)fn=fn:gsub("%s+","")uF(uG,fn,gq)elseif uJ=="/agg"then if im==nil or im==""then dj("Usage: /agg targetheight")return end;im=dn(im)if im<1000 then im=1000 end;bx=im;dj("AGG Target Height set to "..im)elseif uJ=="/G"then if im==nil or im==""then dj("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if im=="dump"then for dM,dy in pairs(iC())do if type(dy.get())=="boolean"then if dy.get()==true then a.print(dM.." true")else a.print(dM.." false")end elseif dy.get()==nil then a.print(dM.." nil")else a.print(dM.." "..dy.get())end end;return end;M=string.find(im," ")local uL=string.sub(im,0,M-1)local uM=string.sub(im,M+1)for dM,dy in pairs(iC())do if dM==uL then local uN=type(dy.get())if uN=="number"then uM=dn(uM)if dM=="AtmoSpeedLimit"then cC=uM end end;dj("Variable "..uL.." changed to "..uM)if dM=="MaxGameVelocity"then uM=uM/3.6;if uM>dg-0.2 then uM=dg-0.2;dj("Variable "..uL.." changed to "..fM(uM*3.6,1))end end;if uN=="boolean"then if string.lower(uM)=="true"then uM=true else uM=false end end;dy.set(uM)return end end;dj("No such global variable: "..uL)elseif uJ=="/deletewp"then if bn>0 and fX~=nil then ct.ClearCurrentPosition()else dj("Select a custom wp to delete first in IPH")end elseif uJ=="/copydatabank"then if dbHud_2 then pF(true)else dj("Spare Databank required to copy databank")end elseif uJ=="/iphWP"then if bn>0 then a.print(cu.showWayPoint(c9,bm,true))a.print(json.encode(bm))dj("::pos waypoint shown in lua chat in local and world format")else dj("No target selected in IPH")end elseif uJ=="/createPrivate"then local uO="privatelocations = {\n"local uP=""if#da>0 then for dM,dy in pairs(da)do uO=uO.."{position = {x = "..dy.position.x..", y = "..dy.position.y..", z = "..dy.position.z.."},\n ".."name = '"..dy.name.."',\n planetname = '"..dy.planetname.."',\n gravity = "..dy.gravity..",\n"if dy.heading then uO=uO.."heading = {x = "..dy.heading.x..", y = "..dy.heading.y..", z = "..dy.heading.z.."},\n"end;if dy.safe then uO=uO.."safe = true},\n"else uO=uO.."safe = false},\n"end end end;uP=#da.."-Private "if im=="all"then for dM,dy in pairs(br)do uO=uO.."{position = {x = "..dy.position.x..", y = "..dy.position.y..", z = "..dy.position.z.."},\n ".."name = '*"..dy.name.."',\n planetname = '"..dy.planetname.."',\n gravity = "..dy.gravity..",\n"if dy.heading then uO=uO.."heading = {x = "..dy.heading.x..", y = "..dy.heading.y..", z = "..dy.heading.z.."},\n"end;if dy.safe then uO=uO.." safe = true},\n"else uO=uO.."safe = false},\n"end end;uP=uP..#br.."-Public "end;uO=uO.."}\n return privatelocations"if uh then uh.setHTML(uO)end;dj(uP.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c5=7 end end;function uj.tagTick()if bE=="Off"then bE="All"elseif bE=="All"then bE="Longitude"elseif bE=="Longitude"then bE="Lateral"elseif bE=="Lateral"then bE="Vertical"else bE="Off"end;dj("Extra Engine Tags: "..bE)c.stopTimer("tagTick")end;if uQ then for dM,dy in pairs(uQ)do uj[dM]=dy end end;return uj end;local function uR(d,b,c,e,vBooster,hover,pE,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iv,uh)local a=DUSystem;local bQ=DUConstruct;local uS=DUPlayer;local uT=DULibrary;local uU={}local dl=string.format;local iw=json.decode;local uV=json.encode;local px=b.getElementMaxHitPointsById;local ix=b.getElementMassById;local iy=d.control.isRemoteControlled;local e5=string.match;local gD=a.destroyWidgetPanel;local fJ=a.updateData;local fK=a.addDataToWidget;local ui=a.lockView;local iA=a.isViewLocked;local dp=math.sqrt;local dn=tonumber;local e_=math.abs;local bO=math.floor;local bP=c.getAtmosphereDensity;local eV=math.atan;local bN=a.getArkTime;local dm=utils.clamp;local iz=d.axisCommandManager;local gF=13;local iF=b.getElementIdList()local iG=0;local function dq(eD,eE)if eD==0 then return e_(eE)<1e-09 elseif eE==0 then return e_(eD)<1e-09 else return e_(eD-eE)<math.max(e_(eD),e_(eE))*dD end end;local function fM(dE,uW)local rf=10^(uW or 0)return bO(dE*rf+0.5)/rf end;local function iB(uX,uY)for dM,dy in pairs(uY)do if type(dM)=="string"then uX[dM]=dy else uX[#uX+1]=uY[dM]end end;return uX end;local function iC(uZ)local u_={}if not uZ then iB(u_,L)iB(u_,ac)iB(u_,aE)iB(u_,a_)return u_ elseif uZ=="boolean"then return L elseif uZ=="handling"then return ac elseif uZ=="hud"then return aE elseif uZ=="physics"then return a_ end end;local function dj(sK)if c4~="empty"then if c4~=sK then c4=c4 .."\n"..sK;c5=7 end else c4=sK end end;local function pF(v0)local function v1(v2)for dM,dy in pairs(v2)do dbHud_1.setStringValue(dM,uV(dy.get()))if v0 and dbHud_2 then dbHud_2.setStringValue(dM,uV(dy.get()))end end end;if dbHud_1 then v1(bK)v1(iC())a.print("Saved Variables to Datacore")if v0 and dbHud_2 then dj("Databank copied.  Remove copy when ready.")end end end;local function fL(v3,v4,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v3 ..".mp3")end;local function gE(hy,hz,rd,jN,v5)return dl([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jN or"",hy,hz,v5 or"",rd)end;local function iD(cc,v6)v6=v6 or 1;local unit="m"if cc>100000 then cc=cc/200000;unit="su"elseif cc>1000 then cc=cc/1000;unit="km"end;return fM(cc,v6)..unit end;local function iE(v7)local v8=0;local v9=0;local va=0;if v7<60 then v7=bO(v7)elseif v7<3600 then v8=bO(v7/60)v7=bO(v7%60)elseif v7<86400 then v9=bO(v7/3600)v8=bO(v7%3600/60)else va=bO(v7/86400)v9=bO(v7%86400/3600)end;if va>365 then return">1y"elseif va>0 then return va.."d "..v9 .."h "elseif v9>0 then return v9 .."h "..v8 .."m "elseif v8>0 then return v8 .."m "..v7 .."s"elseif v7>0 then return v7 .."s"else return"0s"end end;local function vb()if radar_1 then cv=gC(b,a,c,radar_1,radar_2,warpdrive,e_,gD,dp,gE,dn,gF,fL,dj)end end;function uU.radarSetup()vb()end;function uU.onStart()local vc=false;local function vd()local function ve(vf)local vg=dbHud_1.hasKey;for dM,dy in pairs(vf)do if vg(dM)then local dH=iw(dbHud_1.getStringValue(dM))if dH~=nil then dy.set(dH)vc=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then ve(iC())coroutine.yield()ve(bK)else ve(bK)dj("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c5=5;vc=false end;coroutine.yield()if vc then dj("Loaded Saved Variables")elseif not f then dj("No Databank Saved Variables Found\nVariables will save to Databank on standing")c5=5 end;if#br>0 then db=iB(db,br)end else dj("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;b0=k;g=string.lower(g)cA=q;cC=W;if by+180<bR then bw=0 end;by=bR;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then dj("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c5=7 end;if antigrav and not r then if bx==nil then bx=cj end;antigrav.setTargetAltitude(bx)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#da>0 then db=iB(db,da)end end;lr="Proceeding to Waypoint"if not a1 or a1<0 then a1=bQ.getMaxSpeed()-0.1 end end;local function vh()local function vi(vj,vk)if vj>vk then vk=vj end;local vl,vm=0,0;if a7>0 then vl=a7*0.05 end;if a8>0 then vm=a8*0.05 end;vk=vk*(1-(vl+vm))return vk end;local vn=b.getElementNameById;local vo=au~=0 and av~=0;local vp=_G["atmofueltank_size"]local vq=_G["spacefueltank_size"]local vr=_G["rocketfueltank_size"]for dM in pairs(iF)do local type=b.getElementDisplayNameById(iF[dM])if e5(type,'^.*Atmospheric Engine$')then if e5(tostring(b.getElementTagsById(iF[dM])),'^.*vertical.*$')and b.getElementForwardById(iF[dM])[3]>0 then cQ=true end end;if e5(type,'^.*Space Engine$')then cH=true;if e5(tostring(b.getElementTagsById(iF[dM])),'^.*vertical.*$')then local vs=b.getElementForwardById(iF[dM])if vs[3]<0 then vt=true else cG=true end end end;if type=="Landing Gear"then bX=true end;if type=="Dynamic Core Unit"then local pz=px(iF[dM])if pz>10000 then gF=110 elseif pz>1000 then gF=55 elseif pz>150 then gF=27 end end;iG=iG+px(iF[dM])if vo and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pz=px(iF[dM])local f4=ix(iF[dM])local vj=0;local jF=bN()if type=="Atmospheric Fuel Tank"then local vk=400;local vu=35.03;if pz>10000 then vk=51200;vu=5480 elseif pz>1300 then vk=6400;vu=988.67 elseif pz>150 then vk=1600;vu=182.67 end;vj=f4-vu;if a4>0 then vk=vk+vk*a4*0.2 end;vk=vi(vj,vk)local gp=vn(iF[dM])local jD=0;for jE=1,vp do if gp==iw(c["atmofueltank_"..jE].getWidgetData()).name then jD=jE;break end end;local vv={iF[dM],string.sub(gp,1,12),vk,vu,vj,jF,jD}cm[#cm+1]=vv end;if type=="Rocket Fuel Tank"then local vk=320;local vu=173.42;if pz>65000 then vk=40000;vu=25740 elseif pz>6000 then vk=5120;vu=4720 elseif pz>700 then vk=640;vu=886.72 end;vj=f4-vu;if a6>0 then vk=vk+vk*a6*0.1 end;vk=vi(vj,vk)local gp=vn(iF[dM])local jD=0;for jE=1,vr do if gp==iw(c["rocketfueltank_"..jE].getWidgetData()).name then jD=jE;break end end;local vv={iF[dM],string.sub(gp,1,12),vk,vu,vj,jF,jD}co[#co+1]=vv end;if type=="Space Fuel Tank"then local vk=600;local vu=35.03;if pz>10000 then vk=76800;vu=5480 elseif pz>1300 then vk=9600;vu=988.67 elseif pz>150 then vk=2400;vu=182.67 end;vj=f4-vu;if a5>0 then vk=vk+vk*a5*0.2 end;vk=vi(vj,vk)local gp=vn(iF[dM])local jD=0;for jE=1,vq do if gp==iw(c["spacefueltank_"..jE].getWidgetData()).name then jD=jE;break end end;local vv={iF[dM],string.sub(gp,1,12),vk,vu,vj,jF,jD}cn[#cn+1]=vv end end end;if not cQ then bb,b1=false,false end end;local function vw()if gyro~=nil then cl=gyro.isActive()==1 end;if not bD then iz:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ui(1)else ui(0)end;if door and(ch or not ch and cj<10000)then for dR,dy in pairs(door)do dy.toggle()end end;if switch then for dR,dy in pairs(switch)do dy.toggle()end end;if forcefield and(ch or not ch==0 and cj<10000)then for dR,dy in pairs(forcefield)do dy.toggle()end end;if antigrav then cR=antigrav.isActive()==1;if cR and not r then antigrav.showWidget()end end;if iy()==1 and l then uS.freeze(1)else uS.freeze(0)end;if bX then if cg~=-1 and not cR then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bo=d.control.isAnyLandingGearDeployed()==1 or cg~=-1 and cg-3<_;if cg~=-1 or not ch and cK:len()<50 then b2="Startup"else b2=false end;iz:setTargetGroundAltitude(_)pl=ch end;local function vx()local vy={}local function vz()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vA={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vB,vC in pairs(e)do e[vB][0]=vz()e[vB][0].systemId=vB;vy[vB]={}for vD,kw in pairs(e[vB])do kw.gravity=kw.gravity/9.8;kw.center=vec3(kw.center)kw.name=kw.name[1]kw.noAtmosphericDensityAltitude=kw.atmosphereThickness;kw.spaceEngineMinAltitude=vA[kw.id]or 0.5353125*kw.atmosphereThickness;kw.planetarySystemId=vB;kw.bodyId=kw.id;vy[vB][vD]=kw;if mh==nil or kw.center.x<mh then mh=kw.center.x end;if mg==nil or kw.center.x>mg then mg=kw.center.x end;if mk==nil or kw.center.y<mk then mk=kw.center.y end;if mj==nil or kw.center.y>mj then mj=kw.center.y end;if kw.center and kw.name~="Space"then d5[#d5+1]=kw end end end;ef=dk(d,b,c,a,dl,dm,dn,dp,dq)cp=ef(vy)fP=cp[0]cq=eZ(d,b,c,a,dp,e_)cr=fj(d,b,c,a,dl,dm,dn,dp,dq)ct=fI(d,b,c,a,dbHud_1,e,fJ,fK,bO,dn,dp,fL,fM,dj)kw=cp[0]:closestBody(bQ.getWorldPosition())end;vE=false;vF=coroutine.create(function()iz:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vd()coroutine.yield()vh()coroutine.yield()cu=pD(d,b,c,e,vBooster,hover,pE,antigrav,dbHud_1,e_,bO,bP,iy,eV,bN,dm,iz,fJ,iA,dp,fM,fL,iB,dq,iD,iE,pF,iw,dj)vw()coroutine.yield()vx()vb()if iu then cs=iu(d,b,c,a,e,antigrav,hover,shield,warpdrive,iv,e_,bO,dl,iw,bP,ix,iy,eV,bN,dm,iz,fK,fJ,gD,iA,dp,fM,gE,fL,iB,iC,iD,iE,iF,iG,dj)end;if cs then cs.ButtonSetup()end;cw=ug(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uh,iy,iz,iA,ui,gD,fM,e5,dn,dm,fL,iC,pF,dj)if shield then cx=ic(shield,e5,bO,dj)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uh then uh.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bQ.setDockingMode(ab)if shield then c.setTimer("shieldTick",0.0166667)end;if vG then vH.ExtraOnStart()end;fL("start","SU")local function vI()if bI[1]==0 then cu.cmdThrottle(bI[2])else if ci>0 then cC=bI[2]cu.cmdThrottle(1)end end end;lj=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if lj then if cg>-1 and cM<1 and cg-3<_ then c.exit()else if J then vI()else if ci==0 then b2="ECU Braking"elseif cg==-1 then cw.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bI[3]+3>bN()then vI()end;d4=bQ.getDockedConstructs()d3=bQ.getPlayersOnBoard()local vJ;vJ=#d3>1 and"Passengers: "..#d3-1 .." "or""vJ=vJ..(#d4>0 and"Ships: "..#d4 or"")if vJ~=""then dj("NOTICE: Docked "..vJ)end end)coroutine.resume(vF)end;function uU.onUpdate()if vE then d:update()if ch and t and cS then if cS and bW then cu.cmdThrottle(0)bW=false elseif not cS and not bW then bS=0;bW=true end end;if d8 then iz:setThrottleCommand(axisCommandId.longitudinal,d8)d8=nil end;if not cy and p7~=vK then a.setScreen(p7)end;vK=p7;if lj and not J and ci>0 and cg==-1 then cw.landingGear()end;if lj and cg>-1 and cM<1 and cg-3<_ then c.exit()end;if vG then vH.ExtraOnUpdate()end else local i2=coroutine.status(vF)if i2=="suspended"then local dN,i3=coroutine.resume(vF)if i3 then a.print("ERROR STARTUP: "..i3)end elseif i2=="dead"then vE=true end end end;function uU.onFlush()if vE then cu.onFlush()if vG then vH.ExtraOnFlush()end end end;function uU.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ci>0 or ci==0 and cj<10000)then for dR,dy in pairs(door)do dy.toggle()end end;if switch then for dR,dy in pairs(switch)do dy.toggle()end end;if forcefield and(ci>0 or ci==0 and cj<10000)then for dR,dy in pairs(forcefield)do dy.toggle()end end;w=d7;local vL=0;if lj then vL=bN()end;if iz:getAxisCommandType(0)==0 then bI={0,bS,vL}else bI={1,iz:getTargetSpeed(axisCommandId.longitudinal),vL}end;pF()if nT then nT.activate()end;if z then cu.showWayPoint(kw,cP)end;if cs then a.print(cs.FuelUsed("atmofueltank")..", "..cs.FuelUsed("spacefueltank")..", "..cs.FuelUsed("rocketfueltank"))end;if vG then vH.ExtraOnStop()end;fL("stop","SU")end;function uU.controlStart(uq)if vE then cw.startControl(uq)end end;function uU.controlStop(uq)if vE then cw.stopControl(uq)end end;function uU.controlLoop(uq)if vE then cw.loopControl(uq)end end;function uU.controlInput(rd)if vE then cw.inputTextControl(rd)end end;function uU.radarEnter(dW)if cv then cv.onEnter(dW)end end;function uU.radarLeave(dW)if cv then cv.onLeave(dW)end end;function uU.onTick(vM)if vM=="tenthSecond"then if cu then cu.TenthTick()end;if cs then cs.TenthTick()end elseif vM=="oneSecond"then if cs then cs.OneSecondTick()end elseif vM=="msgTick"then if cs then cs.MsgTick()end elseif vM=="animateTick"then if cs then cs.AnimateTick()end elseif vM=="hudTick"then if cs then cs.hudtick()end elseif vM=="apTick"then if cu then cu.APTick()end elseif vM=="shieldTick"then cx.shieldTick()elseif vM=="tagTick"then cw.tagTick()elseif vM=="contact"then cv.ContactTick()end end;if vG then for dM,dy in pairs(vG)do uU[dM]=dy end end;return uU end;function script.onStart()vH.onStart()end;function script.onOnStop()vH.onStop()end;function script.onTick(vM)vH.onTick(vM)end;function script.onOnFlush()vH.onFlush()end;function script.onOnUpdate()vH.onUpdate()end;function script.onActionStart(uq)vH.controlStart(uq)end;function script.onActionStop(uq)vH.controlStop(uq)end;function script.onActionLoop(uq)vH.controlLoop(uq)end;function script.onInputText(rd)vH.controlInput(rd)end;function script.onEnter(dW)vH.radarEnter(dW)end;function script.onLeave(dW)vH.radarLeave(dW)end;bM(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vH=uR(d,core,unit,e,vBooster,hover,pE,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iv,uh)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
