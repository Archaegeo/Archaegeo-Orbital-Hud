name: ArchHud - Archaegeo v0.715 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.715;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J=true;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(L)t=L end,get=function()return t end},AtmoSpeedAssist={set=function(L)u=L end,get=function()return u end},ForceAlignment={set=function(L)v=L end,get=function()return v end},DisplayDeadZone={set=function(L)w=L end,get=function()return w end},showHud={set=function(L)x=L end,get=function()return x end},hideHudOnToggleWidgets={set=function(L)y=L end,get=function()return y end},ShiftShowsRemoteButtons={set=function(L)z=L end,get=function()return z end},SetWaypointOnExit={set=function(L)A=L end,get=function()return A end},AlwaysVSpd={set=function(L)B=L end,get=function()return B end},BarFuelDisplay={set=function(L)C=L end,get=function()return C end},voices={set=function(L)D=L end,get=function()return D end},alerts={set=function(L)E=L end,get=function()return E end},CollisionSystem={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},SaveStartingLocation={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1050;W=30000;X=1000;Y=50;Z=0;_=100000;a0=8333.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)a0=L end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(L)a1=L end,get=function()return a1 end},warmup={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingSpace={set=function(L)a4=L end,get=function()return a4 end},fuelTankHandlingRocket={set=function(L)a5=L end,get=function()return a5 end},ContainerOptimization={set=function(L)a6=L end,get=function()return a6 end},FuelTankOptimization={set=function(L)a7=L end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(L)a9=L end,get=function()return a9 end},ResolutionY={set=function(L)aa=L end,get=function()return aa end},circleRad={set=function(L)ab=L end,get=function()return ab end},SafeR={set=function(L)ac=L end,get=function()return ac end},SafeG={set=function(L)ad=L end,get=function()return ad end},SafeB={set=function(L)ae=L end,get=function()return ae end},PvPR={set=function(L)af=L end,get=function()return af end},PvPG={set=function(L)ag=L end,get=function()return ag end},PvPB={set=function(L)ah=L end,get=function()return ah end},centerX={set=function(L)ai=L end,get=function()return ai end},centerY={set=function(L)aj=L end,get=function()return aj end},throtPosX={set=function(L)ak=L end,get=function()return ak end},throtPosY={set=function(L)al=L end,get=function()return al end},vSpdMeterX={set=function(L)am=L end,get=function()return am end},vSpdMeterY={set=function(L)an=L end,get=function()return an end},altMeterX={set=function(L)ao=L end,get=function()return ao end},altMeterY={set=function(L)ap=L end,get=function()return ap end},fuelX={set=function(L)aq=L end,get=function()return aq end},fuelY={set=function(L)ar=L end,get=function()return ar end},shieldX={set=function(L)as=L end,get=function()return as end},shieldY={set=function(L)at=L end,get=function()return at end},DeadZone={set=function(L)au=L end,get=function()return au end},OrbitMapSize={set=function(L)av=L end,get=function()return av end},OrbitMapX={set=function(L)aw=L end,get=function()return aw end},OrbitMapY={set=function(L)ax=L end,get=function()return ax end},soundVolume={set=function(L)ay=L end,get=function()return ay end}}aA=5;aB=1;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0166667;aQ=0.0666667;aR=0.0;aS="none"aT="none"aU="none"aV={speedChangeLarge={set=function(L)aA=L end,get=function()return aA end},speedChangeSmall={set=function(L)aB=L end,get=function()return aB end},MouseXSensitivity={set=function(L)aC=L end,get=function()return aC end},MouseYSensitivity={set=function(L)aD=L end,get=function()return aD end},autoRollFactor={set=function(L)aE=L end,get=function()return aE end},rollSpeedFactor={set=function(L)aF=L end,get=function()return aF end},autoRollRollThreshold={set=function(L)aG=L end,get=function()return aG end},minRollVelocity={set=function(L)aH=L end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(L)aI=L end,get=function()return aI end},torqueFactor={set=function(L)aJ=L end,get=function()return aJ end},pitchSpeedFactor={set=function(L)aK=L end,get=function()return aK end},yawSpeedFactor={set=function(L)aL=L end,get=function()return aL end},brakeSpeedFactor={set=function(L)aM=L end,get=function()return aM end},brakeFlatFactor={set=function(L)aN=L end,get=function()return aN end},DampingMultiplier={set=function(L)aO=L end,get=function()return aO end},apTickRate={set=function(L)aP=L end,get=function()return aP end},hudTickRate={set=function(L)aQ=L end,get=function()return aQ end},ExtraEscapeThrust={set=function(L)aR=L end,get=function()return aR end},ExtraLongitudeTags={set=function(L)aS=L end,get=function()return aS end},ExtraLateralTags={set=function(L)aT=L end,get=function()return aT end},ExtraVerticalTags={set=function(L)aU=L end,get=function()return aU end}}aW=j;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=1000;b8=false;b9=false;ba=false;bb=false;bc=0;bd="Aligning"be=0;bf=1;bg="None"bh=nil;bi=0;bj=nil;bk=0.0;bl=0;bm={}bn=false;bo=0;bp=0;bq=nil;br=0;bs=1000;bt=0;bu=false;bv=0;bw=false;bx="All"by=true;bz="Off"bA=0.000;bB={}bC={VertTakeOff={set=function(L)b6=L end,get=function()return b6 end},VertTakeOffEngine={set=function(L)aX=L end,get=function()return aX end},SpaceTarget={set=function(L)bu=L end,get=function()return bu end},BrakeToggleStatus={set=function(L)aW=L end,get=function()return aW end},BrakeIsOn={set=function(L)aY=L end,get=function()return aY end},RetrogradeIsOn={set=function(L)aZ=L end,get=function()return aZ end},ProgradeIsOn={set=function(L)a_=L end,get=function()return a_ end},Autopilot={set=function(L)b0=L end,get=function()return b0 end},TurnBurn={set=function(L)b1=L end,get=function()return b1 end},AltitudeHold={set=function(L)b2=L end,get=function()return b2 end},BrakeLanding={set=function(L)b3=L end,get=function()return b3 end},Reentry={set=function(L)b5=L end,get=function()return b5 end},AutoTakeoff={set=function(L)b4=L end,get=function()return b4 end},HoldAltitude={set=function(L)b7=L end,get=function()return b7 end},AutopilotAccelerating={set=function(L)b8=L end,get=function()return b8 end},AutopilotBraking={set=function(L)ba=L end,get=function()return ba end},AutopilotCruising={set=function(L)bb=L end,get=function()return bb end},AutopilotRealigned={set=function(L)b9=L end,get=function()return b9 end},AutopilotEndSpeed={set=function(L)bc=L end,get=function()return bc end},AutopilotStatus={set=function(L)bd=L end,get=function()return bd end},AutopilotPlanetGravity={set=function(L)be=L end,get=function()return be end},PrevViewLock={set=function(L)bf=L end,get=function()return bf end},AutopilotTargetName={set=function(L)bg=L end,get=function()return bg end},AutopilotTargetCoords={set=function(L)bh=L end,get=function()return bh end},AutopilotTargetIndex={set=function(L)bi=L end,get=function()return bi end},TotalDistanceTravelled={set=function(L)bk=L end,get=function()return bk end},TotalFlightTime={set=function(L)bl=L end,get=function()return bl end},SavedLocations={set=function(L)bm=L end,get=function()return bm end},VectorToTarget={set=function(L)bn=L end,get=function()return bn end},LocationIndex={set=function(L)bo=L end,get=function()return bo end},LastMaxBrake={set=function(L)bp=L end,get=function()return bp end},LockPitch={set=function(L)bq=L end,get=function()return bq end},LastMaxBrakeInAtmo={set=function(L)br=L end,get=function()return br end},AntigravTargetAltitude={set=function(L)bs=L end,get=function()return bs end},LastStartTime={set=function(L)bt=L end,get=function()return bt end},iphCondition={set=function(L)bx=L end,get=function()return bx end},stablized={set=function(L)by=L end,get=function()return by end},UseExtra={set=function(L)bz=L end,get=function()return bz end},SelectedTab={set=function(L)bD=L end,get=function()return bD end},saveRoute={set=function(L)bB=L end,get=function()return bB end}}local function bE(a,b,c,bF,bG,bH)bI=bF()bJ=ac;bK=ae;bL=ad;bM=0;bN=0;bO=false;bP=0;bQ=false;bR=false;bS=false;bT=false;bU=0;bV=0;bW=0;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c0=false;c1=false;c2="empty"c3=false;c4=0;c5=0;c6=nil;c7=0;c8=0;c9=0;ca=0;cb=0;cc=3;cd=0;ce=""cf=false;cg=false;ch=false;ci=-1;cj=bH()>0;ck=bH()cl=b.getAltitude()cm=bF()cn=b.getConstructMass()co=false;cp=nil;cq=[[rgb(]]..bG(bJ+0.5)..","..bG(bL+0.5)..","..bG(bK+0.5)..[[)]]cr=[[rgb(]]..bG(bJ*0.9+0.5)..","..bG(bL*0.9+0.5)..","..bG(bK*0.9+0.5)..[[)]]cs=a9;ct=aa;cu={}cv={}cw={}cx=false;cy=nil;cz=nil;cA=nil;cB=nil;cC=nil;cD=nil;cE=nil;cF=nil;cG=nil;cH=false;cI=false;cJ=p;cK=false;cL=0;cM=V;cN=0;cO=nil;cP={VectorToTarget=false}cQ=0;cR=false;cS=false;cT=false;cU=vec3(b.getConstructWorldOrientationUp())cV=vec3(b.getConstructWorldOrientationForward())cW=vec3(b.getConstructWorldOrientationRight())cX=vec3(b.getVelocity())cY=vec3(b.getWorldVelocity())cZ=vec3(cY):len()c_=vec3(b.getWorldVertical())d0=-c_:dot(cY)d1=vec3(b.getConstructWorldPos())d2=false;d3=false;d4=nil;d5=true;d6=0;d7=0;d8={}d9=false;da=50000;db=nil;dc={}dd=c.getClosestPlanetInfluence()>0 or cl>0 and cl<200000;de=false;df=nil;dg=false;dh=0;di=nil;dj=nil;dk={}dl=90;dm=x;dn=nil;dp=nil;dq={}dr={}ds=false;dt=nil end;local function du(d,b,c,a,dv,dw,dx,dy,dz)local function dA(dB)return type(dB)=='number'end;local function dC(dB)return type(dx(dB))=='number'end;local function dD(dE)return type(dE)=='table'end;local function dF(a)return type(a)=='string'end;local function dG(dH)return dD(dH)and dA(dH.x and dH.y and dH.z)end;local function dI(dJ)return dD(dJ)and dA(dJ.latitude and dJ.longitude and dJ.altitude and dJ.id and dJ.systemId)end;local dK=math.pi/180;local dL=180/math.pi;local dM=1e-10;local dN=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dO='::pos{'..dN..','..dN..','..dN..','..dN..','..dN..'}'local utils=utils;local vec3=vec3;local function dP(dB)local dQ=string.gsub(string.reverse(dv('%.4f',dB)),'^0*%.?','')return dQ==''and'0'or string.reverse(dQ)end;local function dR(dS)if dG(dS)then return dv('{x=%.3f,y=%.3f,z=%.3f}',dS.x,dS.y,dS.z)end;if dD(dS)and not getmetatable(dS)then local dT={}local dU=next(dS)if type(dU)=='nil'or dU==1 then dT=dS else for dV,dH in pairs(dS)do local dW=dR(dH)if type(dV)=='number'then table.insert(dT,dv('[%s]=%s',dV,dW))else table.insert(dT,dv('%s=%s',dV,dW))end end end;return dv('{%s}',table.concat(dT,','))end;if dF(dS)then return dv("'%s'",dS:gsub("'",[[\']]))end;return tostring(dS)end;local dX={}dX.__index=dX;dX.__tostring=function(dS,dY)local dZ={}for dV in pairs(dS)do table.insert(dZ,dV)end;table.sort(dZ)local dT={}for d_,dV in ipairs(dZ)do local dW=dR(dS[dV])if type(dV)=='number'then table.insert(dT,dv('[%s]=%s',dV,dW))else table.insert(dT,dv('%s=%s',dV,dW))end end;if dY then return dv('%s%s',dY,table.concat(dT,',\n'..dY))end;return dv('{%s}',table.concat(dT,','))end;dX.__eq=function(e0,e1)return e0.systemId==e1.systemId and e0.id==e1.id and dz(e0.radius,e1.radius)and dz(e0.center.x,e1.center.x)and dz(e0.center.y,e1.center.y)and dz(e0.center.z,e1.center.z)and dz(e0.GM,e1.GM)end;local function e2(e3,e4,e5,e6,e7)assert(dC(e3),'Argument 1 (systemId) must be a number:'..type(e3))assert(dC(e4),'Argument 2 (id) must be a number:'..type(e4))assert(dC(e5),'Argument 3 (radius) must be a number:'..type(e5))assert(dD(e6),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e6))assert(dC(e7),'Argument 5 (GM) must be a number:'..type(e7))return setmetatable({systemId=dx(e3),id=dx(e4),radius=dx(e5),center=vec3(e6),GM=dx(e7)},dX)end;local e8={}e8.__index=e8;e8.__tostring=function(e9)return dv('::pos{%d,%d,%s,%s,%s}',e9.systemId,e9.id,dP(e9.latitude*dL),dP(e9.longitude*dL),dP(e9.altitude))end;e8.__eq=function(e0,e1)return e0.id==e1.id and e0.systemId==e1.systemId and dz(e0.latitude,e1.latitude)and dz(e0.altitude,e1.altitude)and(dz(e0.longitude,e1.longitude)or dz(e0.latitude,math.pi/2)or dz(e0.latitude,-math.pi/2))end;local function ea(eb,e4,ec,ed,ee)local e3=eb;if dF(eb)and not ed and not ee and not e4 and not ec then e3,e4,ec,ed,ee=ef(eb,dO)assert(e3,'Argument 1 (position string) is malformed.')else assert(dC(e3),'Argument 1 (systemId) must be a number:'..type(e3))assert(dC(e4),'Argument 2 (id) must be a number:'..type(e4))assert(dC(ec),'Argument 3 (latitude) must be in degrees:'..type(ec))assert(dC(ed),'Argument 4 (longitude) must be in degrees:'..type(ed))assert(dC(ee),'Argument 5 (altitude) must be in meters:'..type(ee))end;e3=dx(e3)e4=dx(e4)ec=dx(ec)ed=dx(ed)ee=dx(ee)if e4==0 then return setmetatable({latitude=ec,longitude=ed,altitude=ee,id=e4,systemId=e3},e8)end;return setmetatable({latitude=dK*dw(ec,-90,90),longitude=dK*(ed%360),altitude=ee,id=e4,systemId=e3},e8)end;local eg={}eg.__index=eg;eg.__tostring=function(dS,dY)local eh=dY and dY..'  'local ei={}local dZ={}for dV in pairs(dS)do table.insert(dZ,dV)end;table.sort(dZ)for d_,ej in ipairs(dZ)do ek=dS[ej]local el=dX.__tostring(ek,eh)if dY then table.insert(ei,dv('[%s]={\n%s\n%s}',ej,el,dY))else table.insert(ei,dv('  [%s]=%s',ej,el))end end;if dY then return dv('\n%s%s%s',dY,table.concat(ei,',\n'..dY),dY)end;return dv('{\n%s\n}',table.concat(ei,',\n'))end;local function em(en)local e={}local pid;for d_,dH in pairs(en)do local e4=dH.planetarySystemId;if type(e4)~='number'then error('Invalid planetary s ID: '..tostring(e4))elseif pid and e4~=pid then error('Mistringmatch planetary s IDs: '..e4 ..' and '..pid)end;local eo=dH.bodyId;if type(eo)~='number'then error('Invalid body ID: '..tostring(eo))elseif e[eo]then error('Duplicate body ID: '..tostring(eo))end;setmetatable(dH.center,getmetatable(vec3.unit_x))e[eo]=setmetatable(dH,dX)pid=e4 end;return setmetatable(e,eg)end;ep={}local function eq(en)return setmetatable({galaxyAtlas=en or{}},ep)end;ep.__index=function(dE,L)if type(L)=='number'then local a=dE.galaxyAtlas[L]return em(a)end;return rawget(ep,L)end;ep.__pairs=function(dS)return function(dE,dV)local er,es=next(dE,dV)return er,es and em(es)end,dS.galaxyAtlas,nil end;ep.__tostring=function(dS)local et={}for d_,eu in pairs(dS or{})do local ev=eu:getPlanetarySystemId()local ew=eg.__tostring(eu,'    ')table.insert(et,dv('  [%s]={%s\n  }',ev,ew))end;return dv('{\n%s\n}\n',table.concat(et,',\n'))end;ep.BodyParameters=e2;ep.MapPosition=ea;ep.PlanetarySystem=em;function ep.createBodyParameters(e3,e4,ex,ey,ez,eA,eB)assert(dC(e3),'Argument 1 (systemId) must be a number:'..type(e3))assert(dC(e4),'Argument 2 (id) must be a number:'..type(e4))assert(dC(ex),'Argument 3 (surfaceArea) must be a number:'..type(ex))assert(dD(ey),'Argument 4 (aPosition) must be an array or vec3:'..type(ey))assert(dD(ez),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ez))assert(dC(eA),'Argument 6 (altitude) must be in meters:'..type(eA))assert(dC(eB),'Argument 7 (gravityAtPosition) must be number:'..type(eB))local e5=dy(ex/4/math.pi)local cd=e5+eA;local eC=vec3(ey)+cd*vec3(ez)local e7=eB*cd*cd;return e2(e3,e4,e5,eC,e7)end;ep.isMapPosition=dI;function ep:getPlanetarySystem(eb)if L==nil then L=0 end;if es==nil then es=0 end;local e3=eb;if dI(eb)then e3=eb.systemId end;if type(e3)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(es)~=eg then a=em(a)end;return a end end end;function eg:sizeCalculator(eD)return 1.05*eD.radius end;function eg:castIntersections(eE,eF,eG,eH,eI,eJ)local eK={}if eI then for d_,eD in pairs(eI)do table.insert(eK,eD)end else eK=dk end;if not eJ then table.sort(eK,function(eL,eM)local eN=eL.center;local eO=eM.center;return(eN.x-eE.x)^2+(eN.y-eE.y)^2+(eN.z-eE.z)^2<(eO.x-eE.x)^2+(eO.y-eE.y)^2+(eO.z-eE.z)^2 end)end;local eP=eF:normalize()for d_,eD in ipairs(eK)do local eQ=eD.center-eE;local e5=self:sizeCalculator(eD)local eR=eQ:dot(eP)local eS=eR^2-(eQ:len2()-e5^2)if eS>=0 then local eT=dy(eS)local eU=eR+eT;local eV=eR-eT;if eV>0 then return eD,eU,eV elseif eU>0 then return eD,eU,nil end end end;return nil,nil,nil end;function eg:closestBody(eW)assert(type(eW)=='table','Invalid coordinates.')local eX,eD;local eY=vec3(eW)for d_,eZ in pairs(self)do local e_=(eZ.center-eY):len2()if(not eD or e_<eX)and eZ.name~="Space"then eD=eZ;eX=e_ end end;return eD end;function eg:convertToBodyIdAndWorldCoordinates(eb)local f0=eb;if dF(eb)then f0=ea(eb)end;if f0.id==0 then return 0,vec3(f0.latitude,f0.longitude,f0.altitude)end;local eZ=self:getBodyParameters(f0)if eZ then return f0.id,eZ:convertToWorldCoordinates(f0)end end;function eg:getBodyParameters(eb)local e4=eb;if dI(eb)then e4=eb.id end;assert(dC(e4),'Argument 1 (id) must be a number:'..type(e4))return self[e4]end;function eg:getPlanetarySystemId()local d_,dH=next(self)return dH and dH.systemId end;function dX:convertToMapPosition(e6)assert(dD(e6),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e6))local f1=vec3(e6)if self.id==0 then return setmetatable({latitude=f1.x,longitude=f1.y,altitude=f1.z,id=0,systemId=self.systemId},e8)end;local f2=f1-self.center;local cd=f2:len()local ee=cd-self.radius;local ec=0;local ed=0;if not dz(cd,0)then local f3=f4(f2.y,f2.x)ed=f3>=0 and f3 or 2*math.pi+f3;ec=math.pi/2-math.acos(f2.z/cd)end;return setmetatable({latitude=ec,longitude=ed,altitude=ee,id=self.id,systemId=self.systemId},e8)end;function dX:convertToWorldCoordinates(eb)local f0=dF(eb)and ea(eb)or eb;if f0.id==0 then return vec3(f0.latitude,f0.longitude,f0.altitude)end;assert(dI(f0),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(f0.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(f0.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local f5=math.cos(f0.latitude)return self.center+(self.radius+f0.altitude)*vec3(f5*math.cos(f0.longitude),f5*math.sin(f0.longitude),math.sin(f0.latitude))end;function dX:getAltitude(e6)return(vec3(e6)-self.center):len()-self.radius end;function dX:getDistance(e6)return(vec3(e6)-self.center):len()end;function dX:getGravity(e6)local f6=self.center-vec3(e6)local f7=f6:len2()return self.GM/f7*f6/dy(f7)end;return setmetatable(ep,{__call=function(d_,...)return eq(...)end})end;local function f8(d,b,c,a,dy,f9)local cz={}local fa=30000000/3600;local fb=fa*fa;local fc=100;function cz.computeAccelerationTime(fd,fe,ff)local fg=fa*math.asin(fd/fa)return(fa*math.asin(ff/fa)-fg)/fe end;function cz.computeDistanceAndTime(fd,ff,fh,fi,fj,fk)fj=fj or 0;fk=fk or 0;local fl=fd<=ff;local fm=fi*(fl and 1 or-1)/fh;local fn=-fk/fh;local fo=fm+fn;if fl and fo<=0 or not fl and fo>=0 then return-1,-1 end;local fp,fq=0,0;if fm~=0 and fj>0 then local fg=math.asin(fd/fa)local fr=math.pi*(fm/2+fn)local fs=fm*fj;local ft=fa*math.pi;local dH=function(dE)local fu=(fr*dE-fs*math.sin(math.pi*dE/2/fj)+ft*fg)/ft;local fv=math.tan(fu)return fa*fv/dy(fv*fv+1)end;local fw=fl and function(a)return a>=ff end or function(a)return a<=ff end;fq=2*fj;if fw(dH(fq))then local fx=0;while f9(fq-fx)>0.5 do local dE=(fq+fx)/2;if fw(dH(dE))then fq=dE else fx=dE end end end;local fy=fd;local fz=fq/fc;for fA=1,fc do local fB=dH(fA*fz)fp=fp+(fB+fy)*fz/2;fy=fB end;if fq<2*fj then return fp,fq end;fd=fy end;local fg=fa*math.asin(fd/fa)local bI=(fa*math.asin(ff/fa)-fg)/fo;local fC=fb*math.cos(fg/fa)/fo;local cd=fC-fb*math.cos((fo*bI+fg)/fa)/fo;return cd+fp,bI+fq end;function cz.computeTravelTime(fd,fe,cd)if cd==0 then return 0 end;if fe>0 then local fg=fa*math.asin(fd/fa)local fC=fb*math.cos(fg/fa)/fe;return(fa*math.acos(fe*(fC-cd)/fb)-fg)/fe end;if fd==0 then return-1 end;assert(fd>0,'Acceleration and initial speed are both zero.')return cd/fd end;return cz end;local function fD(d,b,c,a,dv,dw,dx,dy,dz)local vec3=vec3;local du=du(d,b,c,a,dv,dw,dx,dy,dz)local function dF(a)return type(a)=='string'end;local function dD(dE)return type(dE)=='table'end;fE={}fE.__index=fE;function fE:escapeAndOrbitalSpeed(ee)assert(self.body)local cd=ee+self.body.radius;if not dz(cd,0)then local fF=dy(self.body.GM/cd)return dy(2)*fF,fF end;return nil,nil end;function fE:orbitalParameters(eb,fG)assert(self.body)assert(dD(eb)or dF(eb))assert(dD(fG))local fH=(dF(eb)or du.isMapPosition(eb))and self.body:convertToWorldCoordinates(eb)or vec3(eb)local dH=vec3(fG)local fI=fH-self.body.center;local fJ=dH:len2()local fK=fI:len()local fL=self.body.GM;local fM=((fJ-fL/fK)*fI-fI:dot(dH)*dH)/fL;local eN=fL/(2*fL/fK-fJ)local fN=fM:len()local eP=fM:normalize()local fO=eN*(1-fN)local fP=eN*(1+fN)local fQ=fO*eP+self.body.center;local fR=fN<=1 and-fP*eP+self.body.center or nil;local fS=dy(eN*fL*(1-fN*fN))local fT=fR and 2*math.pi*dy(eN^3/fL)local fU=math.acos(fM:dot(fI)/(fN*fK))if fI:dot(dH)<0 then fU=-(fU-2*math.pi)end;local fV=math.acos((math.cos(fU)+fN)/(1+fN*math.cos(fU)))local fW=fV;if fW<0 then fW=fW+2*math.pi end;local fX=fW-fN*math.sin(fW)local fY=0;local fZ=0;local f_=0;if fT~=nil then fY=fX/(2*math.pi/fT)fZ=fT-fY;f_=fZ+fT/2;if fU-math.pi>0 then fZ=fY;f_=fZ+fT/2 end;if f_>fT then f_=f_-fT end end;return{periapsis={position=fQ,speed=fS/fO,circularOrbitSpeed=dy(fL/fO),altitude=fO-self.body.radius},apoapsis=fR and{position=fR,speed=fS/fP,circularOrbitSpeed=dy(fL/fP),altitude=fP-self.body.radius},currentVelocity=dH,currentPosition=fH,eccentricity=fN,period=fT,eccentricAnomaly=fV,meanAnomaly=fX,timeToPeriapsis=fZ,timeToApoapsis=f_,trueAnomaly=fU}end;local function g0(g1)local eZ=du.BodyParameters(g1.systemId,g1.id,g1.radius,g1.center,g1.GM)return setmetatable({body=eZ},fE)end;return setmetatable(fE,{__call=function(d_,...)return g0(...)end})end;local function g2(d,b,c,a,dbHud_1,e,g3,g4,bG,dx,dy,g5)local function g6(g7)local e9=g8:closestBody(g7)if(g7-e9.center):len()>e9.radius+e9.noAtmosphericDensityAltitude then e9=e[0][0]end;return e9 end;local function g9()local function ga(gb,gc)return gb.name<gc.name end;d8={}for dV,dH in pairs(e[0])do d8[#d8+1]={name=dH.name,index=dV}end;table.sort(d8,ga)end;local function gd(ge,gf)if not gf then gf=gg.name end;for dV,dH in pairs(ge)do if dH.name and dH.name==gf then return dV end end;return-1 end;local function gh()dh=bi;if bi==0 then bg="None"c6=nil;gg=nil;return true end;local gi=d8[bi].index;local gj=e[0][gi]if gj.center then bg=gj.name;c6=cy[0][gi]if gg~=nil then if ck==0 then if g3(gk,gl)~=1 then g4(gk,gl)end;if g3(gm,gn)~=1 then g4(gm,gn)end;if g3(go,gp)~=1 then g4(go,gp)end;if g3(gq,gr)~=1 then g4(gq,gr)end;if g3(gs,gt)~=1 then g4(gs,gt)end end;if g3(gu,gv)~=1 then g4(gu,gv)end;if g3(gw,gx)~=1 then g4(gw,gx)end;if g3(gy,gz)~=1 then g4(gy,gz)end end;gg=nil else gg=gj;for d_,dH in pairs(cy[0])do if dH.name==gg.planetname then c6=dH;bg=gg.name;break end end;if g3(gu,gv)~=1 then g4(gu,gv)end;if g3(gw,gx)~=1 then g4(gw,gx)end end;if gg==nil then bh=vec3(c6.center)else bh=gg.position end;if c6.planetname~="Space"then if c6.hasAtmosphere then gA=bG(c6.radius*(T-1)+c6.noAtmosphericDensityAltitude)else gA=bG(c6.radius*(T-1)+c6.surfaceMaxAltitude)end else gA=S end;if gg~=nil and gg.planetname=="Space"then bc=0 else d_,bc=cB(c6):escapeAndOrbitalSpeed(gA)end;be=0;b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"return true end;local function gB(gC)if not b0 and not bn and not cg and not bw and not b5 and not ch then if gC==nil then bi=bi+1;if bi>#d8 then bi=0 end else bi=bi-1;if bi<0 then bi=#d8 end end;if bi==0 then gh()else local gi=d8[bi].index;local gj=e[0][gi]if gj and(gj~=nil and gj.name=="Space"or bx=="Custom Only"and gj.center or bx=="No Moons"and string.find(gj.name,"Moon")~=nil)then if gC==nil then gB()else gB(1)end else gh()end end else c2="Disengage autopilot before changing Interplanetary Helper"g5("iph","AP")end end;local function gD()local function gE(gF)local gG;if gF then gG=dq else gG=bm end;local gH=-1;gH=gd(e[0])if gH>-1 then table.remove(e[0],gH)end;gH=-1;gH=gd(gG)if gH~=-1 then c2=gg.name.." saved location cleared"table.remove(gG,gH)end;gB()g9()return gG end;if string.sub(bg,1,1)=="*"then dq=gE(true)else bm=gE(false)end end;local function gI(gJ,g7,gK,gL)local function gM(gF)if gF then gG=dq else gG=bm end;if dbHud_1 or gK or gF then local e9=g6(g7)local gN=e9.gravity;if gL then gN=c.getClosestPlanetInfluence()end;local gO={position=g7,name=gJ,planetname=e9.name,gravity=gN,safe=gL}if not gK then gG[#gG+1]=gO else for dV,dH in pairs(e[0])do if dH.name and gJ==dH.name then table.remove(e[0],dV)end end end;table.insert(e[0],gO)g9()gh()c2="Location saved as "..gJ.."("..e9.name..")"return gG else c2="Databank must be installed to save permanent locations"end end;if string.sub(gJ,1,1)=="*"then dq=gM(true)else bm=gM(false)end end;local gP={}function gP.UpdateAtlasLocationsList()g9()end;function gP.UpdateAutopilotTarget()gh()end;function gP.adjustAutopilotTargetIndex(gC)gB(gC)end;function gP.findAtlasIndex(ge,gf)return gd(ge,gf)end;function gP.UpdatePosition(gQ,gR)local function gS(gF)local gG;if gF then gG=dq else gG=bm end;local gH=gd(gG)if gH~=-1 then if gQ~=nil then if gF then gQ="*"..gQ end;gG[gH].name=gQ;bi=bi-1;gB()else local gT=gG[gH]if gR then gT.heading=cW:cross(c_)*5000;c2=gG[gH].name.." heading saved ("..gG[gH].planetname..")"return elseif gR==false then gT.heading=nil;c2=gG[gH].name.." heading cleared ("..gG[gH].planetname..")"return end;gT.gravity=c.getClosestPlanetInfluence()gT.position=d1;gT.safe=true end;c2=gG[gH].name.." position updated ("..gG[gH].planetname..")"else c2="Name Not Found"end end;if string.sub(bg,1,1)=="*"then gS(true)else gS(false)end end;function gP.AddNewLocation(gJ,g7,gK,gL)gI(gJ,g7,gK,gL)end;function gP.ClearCurrentPosition()gD()end;for dV,dH in pairs(dr)do table.insert(e[0],dH)end;g9()if bi>#d8 then bi=0 end;gP.UpdateAutopilotTarget()return gP end;local function gU(b,a,c,library,radar_1,radar_2,f9,gV,dy,gW,dx,gX,g5)local gY={}local gZ={}local g_={XS=13,S=27,M=55,L=110,XL=221}local h0={}local h1;local h2;local h3;local h4;local h5;local h6={}local h7="Atmo"local h8;local h9;local ha=0;local function hb()local function hc(hd,he,hf,hg,hh,hi,hj,hk)he,hg,hi,hk=vec3(he),vec3(hg),vec3(hi),vec3(hk)local hl,hm,hn=hd*hd,hf*hf,hh*hh;local fJ=hg-he;local ho=fJ:normalize()local hp=fJ:len()local hq=hi-he;local hr=(hq-hq:project_on(ho)):normalize()local hs,ht=hq:dot(ho),hq:dot(hr)local hu=hs*hs+ht*ht;local hv=ho:cross(hr)local hw=(hl-hm+hp*hp)/(2*hp)local hx=(hl-hn+hu-2*hs*hw)/(2*ht)local dJ=hl-hw^2-hx^2;local hy=dy(dJ)local hz=he+ho*hw+hr*hx+hv*hy;local hA=he+ho*hw+hr*hx-hv*hy;if f9((hk-hz):len()-hj)<f9((hk-hA):len()-hj)then return hz else return hA end end;local function hB()local function hC()local hD=b.getConstructWorldOrientationRight()local fJ=b.getConstructWorldOrientationForward()local hq=b.getConstructWorldOrientationUp()local hE=library.systemResolution3(hD,fJ,hq,{1,0,0})local hF=library.systemResolution3(hD,fJ,hq,{0,1,0})local hG=library.systemResolution3(hD,fJ,hq,{0,0,1})return function(hH)return library.systemResolution3(hE,hF,hG,hH)end end;local hI=hC()local hJ=b.getConstructWorldPos()local fH=b.getElementPositionById(1)local hK={fH[1],fH[2],fH[3]}local hL=hI(hK)local hM={hJ[1]-hL[1],hJ[2]-hL[2],hJ[3]-hL[3]}return hM end;local function hN(hO,fK,hP)local hQ=hO.pts;local gH=#hQ;local hR=hO.ref;if gH>3 then local hS,hT,hU,hV=hQ[gH],hQ[gH-1],hQ[gH-2],hQ[gH-3]hO.ref=hP;local fH=hc(hS[1],hS[2],hT[1],hT[2],hU[1],hU[2],hV[1],hV[2])local hw,hx,hy=fH.x,fH.y,fH.z;if hw==hw and hx==hx and hy==hy then hw=hw+hR[1]hx=hx+hR[2]hy=hy+hR[3]local hW=vec3(hw,hx,hy)if not hO.lastPos then hO.center=hW elseif(hO.lastPos-hW):len()<2 then hO.center=hW;hO.skipCalc=true end;hO.lastPos=hW end;hO.pts={}else local hX={hP[1]-hR[1],hP[2]-hR[2],hP[3]-hR[3]}hQ[gH+1]={fK,hX}end end;if radar_1 or radar_2 then cF.assignRadar()end;if h6[1]then h1=#h6[1].getConstructIds()local hY=h6[1].getData()local hZ=hY:gmatch('{"constructId[^}]*}[^}]*}')if h1>0 then local hP=hB()local h_,i0=0,0;h5,h4=0,0;for dH in hZ do local e4,cd,i1=dH:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local i2=g_[i1]cd=dx(cd)if h6[1].hasMatchingTransponder(e4)==1 then table.insert(gZ,e4)end;local i3=h6[1].getConstructType(e4)if F then if i2>27 or i3=="static"or i3=="space"then h5=h5+1;local gJ=h6[1].getConstructName(e4)local hO=dc[e4]if hO==nil then i2=i2+gX;dc[e4]={pts={},ref=hP,name=gJ,i=0,radius=i2,skipCalc=false}hO=dc[e4]end;if not hO.skipCalc then hN(hO,cd,hP)i0=i0+1 end;if hO.center then table.insert(h0,hO)end end;h_=h_+1;if dd and h_>700 or i0>70 or(not dd and h_>300 or i0>30)then coroutine.yield()h_,i0=0,0 end end end;h4=#h0;if h4>0 and cZ>20 then local eD,i4,i5,i6;local i7=0;local i8=cy:getPlanetarySystem(0)i6=cY:normalize()while i7<h4 do coroutine.yield()local i9={table.unpack(h0,i7,math.min(i7+75,h4))}eD,i4,i5=i8:castIntersections(d1,i6,nil,nil,i9,true)if eD and i5 then df={eD,i4,i5}break end;i7=i7+75 end;if not eD then df=nil end else df=nil end;h0={}h2=hY:find('identifiedConstructs":%[%]')else h3=hY:find('worksInEnvironment":false')end end end;local function ia()if h6[1]then h7="Atmo"if h6[1].getData():find('worksInAtmosphere":false')then h7="Space"end end end;function gY.pickType()ia()end;function gY.assignRadar()if radar_1 and h6[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then h6[1]=radar_2 end;if h6[1]==radar_2 then ia()end elseif radar_2 and h6[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then h6[1]=radar_1 end;if h6[1]==radar_1 then ia()end end end;function gY.UpdateRadar()local ib=coroutine.status(h8)if ib=="suspended"then local dW,ic=coroutine.resume(h8)if ic then a.print("ERROR UPDATE RADAR: "..ic)end elseif ib=="dead"then h8=coroutine.create(hb)local dW,ic=coroutine.resume(h8)end end;function gY.GetRadarHud(id,ie,ig,ih)local ii=gZ;local ij,ik;gZ={}local dN=h4 or 0;if h1>0 then if F then ik=dN.."/"..h5 .." Plotted : "..h1-h5 .." Ignored"else ik="Radar Contacts: "..h1 end;ij=gW(ig,ih,ik,"pbright txtbig txtmid")if#gZ>0 then ij=ij..gW(id,ie,"Friendlies In Range","pbright txtbig txtmid")for dV,dH in pairs(gZ)do ie=ie+20;ij=ij..gW(id,ie,h6[1].getConstructName(dH),"pdim txtmid")end end;if h2==nil and h9==nil then ha=1;cF.ToggleRadarPanel()end;if h2~=nil and h9~=nil then cF.ToggleRadarPanel()end;if dp==nil then cF.ToggleRadarPanel()end else if h3 then ij=gW(ig,ih,h7 .." Radar: Jammed","pbright txtbig txtmid")else ij=gW(ig,ih,"Radar: No "..h7 .." Contacts","pbright txtbig txtmid")end;if dp~=nil then ha=0;cF.ToggleRadarPanel()end end;return ij end;function gY.GetClosestName(gJ)if h6[1]then local e4,d_=h6[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if e4~=nil and e4~=""then gJ=gJ.." "..h6[1].getConstructName(e4)end end;return gJ end;function gY.ToggleRadarPanel()if dp~=nil and ha==0 then gV(dp)dp=nil;if h9~=nil then gV(h9)h9=nil end else if ha==1 then gV(dp)dp=nil;_autoconf.displayCategoryPanel(h6,1,"Periscope","periscope")h9=_autoconf.panels[_autoconf.panels_size]end;if dp==nil then _autoconf.displayCategoryPanel(h6,1,"Radar","radar")dp=_autoconf.panels[_autoconf.panels_size]end;ha=0 end end;function gY.ContactTick()if not il then il=0 end;if bI>il+10 then c2="Radar Contact"g5("rdrCon","RC")il=bI end;c.stopTimer("contact")end;function gY.onEnter(e4)if radar_1 and not cj and not d9 then c.setTimer("contact",0.1)end end;function gY.onLeave(e4)if radar_1 and F then if#dc>650 then e4=tostring(e4)dc[e4]=nil end end end;h6[1]=nil;if radar_1 then h6[1]=radar_1;ia()end;h8=coroutine.create(hb)return gY end;local function im(d,b,c,a,e,radar_1,radar_2,antigrav,hover,io,warpdrive,ip,f9,bG,dv,iq,bH,ir,is,f4,bF,dw,it,g4,g3,gV,iu,dy,iv,gW,g5,iw,ix,iy,iz,iA,iB)local iC=9.80665;local iD={}local iE={}local iF={}local iG={}local iH=nil;local iI=nil;local iJ=nil;local iK=false;local iL="none"local iM=""local iN=55;local iO=0;local iP=0;local iQ=""local iR=nil;local iS=vec3({13771471,7435803,-128971})local iT=18000000;local iU=500000;local iV,iW=math.huge;local iX;local function iY(iZ)iV=vec3(iZ):dist(iS)if iV<iT then return true,f9(iV-iT)end;iW=vec3(iZ):dist(vec3(i_.center))if iW<iU then iX=true else iX=false end;if f9(iW-iU)<f9(iV-iT)then return iX,f9(iW-iU)else return iX,f9(iV-iT)end end;local function j0(dH)if cs==1920 then return dH else return iv(cs*dH/1920,0)end end;local function j1(dH)if ct==1080 then return dH else return iv(ct*dH/1080,0)end end;local function j2()return iu()==0 and g~="keyboard"and is()==0 end;local function j3()local j4="TRAVEL"if not d5 then j4="CRUISE"end;if b0 then j4="AUTOPILOT"end;return j4 end;local ij=""local j5=""local j6=""local j7=1;local j8=2;local j9=3;local ja=4;local jb=5;local jc=6;local jd=""local je=0;local jf=bG(1/aP)*2*aQ;local jg={}local jh={}local ji={}local jj={}local jk={}local jl={}local jm={}jm["atmofueltank"],jm["spacefueltank"],jm["rocketfueltank"]=0,0,0;local jn=0;local function jo(hw,jp,jq,jr,js,jt)local ju=jn;local jv=jn+5;if not C then jv=jv+5 end;if is()==1 and not l then ju=ju-50;jv=jv-50 end;if jq=="ATMO"then jd="atmofueltank"elseif jq=="SPACE"then jd="spacefueltank"else jd="rocketfueltank"end;je=_G[jd.."_size"]if#jr>0 then for L=1,#jr do local gJ=string.sub(jr[L][j8],1,12)local jw=0;for jx=1,je do if jr[L][j8]==iq(c[jd.."_"..jx].getData()).name then jw=jx;break end end;local jy=bF()if js[L]==nil or jt[L]==nil or jy-jr[L][jc]>jf then local jz;local jA=0;jA=ir(jr[L][j7])-jr[L][ja]jz=jr[L][jb]if jz>jA then jm[jd]=jm[jd]+jz-jA end;if jw~=0 then jt[L]=iq(c[jd.."_"..jw].getData()).percentage;js[L]=iq(c[jd.."_"..jw].getData()).timeLeft;if js[L]=="n/a"then js[L]=0 end else jt[L]=bG(0.5+jA*100/jr[L][j9])if jz<=jA then js[L]=0 else js[L]=bG(0.5+jA/((jz-jA)/(jy-jr[L][jc])))end end;jr[L][jc]=jy;jr[L][jb]=jA end;if gJ==jp then gJ=dv("%s %d",jq,L)end;if jw==0 then gJ=gJ.." *"end;local jB;if js[L]==0 then jB=""else jB=iz(js[L])end;if jt[L]~=nil then local jC=bG(jt[L]*2.55)local jD=dv("rgb(%d,%d,%d)",255-jC,jC,0)local jE=""if jB~=""and js[L]<120 or jt[L]<5 then jE="red "end;local jF=dv("rgb(%d,%d,%d)",dw(bG((255-jC)/2.55),50,100),dw(bG(jC/2.55),0,50),50)local jG="rgb(196,0,255)"if jq=="ATMO"then jG="rgb(0,188,255)"elseif jq=="SPACE"then jG="rgb(239,255,0)"end;local jH=false;if jI~=jG then jH=true end;jI=jG;if C then if jH then ju=ju-5;jv=jv-5 end;j5=j5 ..dv([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jF,jG,hw,jv,jD,bG(jt[L]*1.7+0.5)-2,hw+1,jv+1,hw+5,jv+14,gJ,jt[L],jB)ju=ju-22;jv=jv-22 else j5=j5 ..gW(hw,ju,gJ,jE.."pdim txtfuel")j5=j5 ..gW(hw,jv,dv("%d%% %s",jt[L],jB),"pdim txtfuel","fill:"..jD)ju=ju+30;jv=jv+30 end end end end;jn=ju end;local function jJ(jK,ee)if am==0 and an==0 then return end;if ee<200000 and not cj or ee and cj then local jL=0;if f9(d0)>1 then jL=45*math.log(f9(d0),10)if d0<0 then jL=-jL end end;jK[#jK+1]=dv([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bG(d0),bG(jL))end;return jK end;local function jM(jN)local gC=-c_;jN=jN-jN:project_on(gC)local jO=vec3(0,0,1)jO=jO-jO:project_on(gC)local jP=jO:cross(gC)local jL=jO:angle_between(jN)*constants.rad2deg;if jN:dot(jP)<0 then jL=360-jL end;return jL end;local function jQ(jK,ai,aj,jR,jS,dd)if ab==0 then return end;local jT=ab;local jU=20;local jV=bG(jR)if dd then for L=-45,45,5 do local jW=L;jK[#jK+1]=dv([[<g transform="rotate(%f,%d,%d)">]],jW,ai,aj)jX=5;if L%15==0 then jX=15 elseif L%10==0 then jX=10 end;jK[#jK+1]=dv([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jT+jU-jX,ai,aj+jT+jU)end;jK[#jK+1]=gW(ai,aj+jT+jU-35,jS,"pdim txt txtmid")jK[#jK+1]=gW(ai,aj+jT+jU-25,jV.." deg","pdim txt txtmid")jK[#jK+1]=dv([[<g transform="rotate(%f,%d,%d)">]],-jR,ai,aj)jK[#jK+1]=dv([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jT+jU-20,ai+5,aj+jT+jU-20,ai,aj+jT+jU-15)jK[#jK+1]="</g>"end;jK[#jK+1]=[[<g style="clip-path: url(#headingClip);">]]local jY=jV;if dd then jY=jM(cV)end;local jZ=20;local j_=bG(jY)local k0=0;local k1=aj+jT+jU+20;local k2=ai;if jS~="YAW"then k1=j1(130)k2=j0(960)end;local k3=[[<path class="txttick line" d="]]local k4=bG(j_-(jZ+10)-j_%5+0.5)for L=k4+70,k4,-5 do local hw=k2-(-L*5+jY*5)if L%10==0 then k0=10;local dN=L;if dN==360 then dN=0 elseif dN>360 then dN=dN-360 elseif dN<0 then dN=dN+360 end;jK[#jK+1]=gW(hw,k1+15,dN,"txtmid bright")elseif L%5==0 then k0=5 end;if k0==10 then k3=dv([[%s M %f %f v %d]],k3,hw,k1-5,k0)else k3=dv([[%s M %f %f v %d]],k3,hw,k1-2.5,k0)end end;jK[#jK+1]=k3 ..[["/>]]jK[#jK+1]=dv([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k2-5,k1-20,k2+5,k1-20,k2,k1-10)if I then if dd then jS="HDG"end;jK[#jK+1]=gW(j0(960),j1(100),j_.."Â°","dim txt txtmid size14","")jK[#jK+1]=gW(j0(960),j1(85),jS,"dim txt txtmid size20","")end;jK[#jK+1]=[[</g>]]end;local function k5(jK,k6,jR,ai,aj,dd,k7,fB)if ab==0 then return end;local jT=ab;local k8=bG(jT*3/5)if jT>0 then local k9=bG(k6)local jX=0;local k3=dv([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jR,ai,aj)if not cj then k3=dv([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jK[#jK+1]=dv([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jT-1,ai,aj)jK[#jK+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bG(k9-30-k9%5+0.5),bG(k9+30+k9%5+0.5),5 do if L%10==0 then jX=30 elseif L%5==0 then jX=20 end;local hx=aj+-L*5+k6*5;if jX==30 then k3=dv([[%s M %d %f h %d]],k3,ai-k8-jX,hx,jX)if cj then jK[#jK+1]=dv([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jR,ai,aj,ai-k8+10,hx+4,L)jK[#jK+1]=dv([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jR,ai,aj,ai+k8-10,hx+4,L)if L==0 or L==180 or L==-180 then jK[#jK+1]=dv([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jR,ai,aj,ai-k8+20,hx,k8*2-40)end else jK[#jK+1]=gW(ai-k8+10,hx,L,"pdim txt txtmid")jK[#jK+1]=gW(ai+k8-10,hx,L,"pdim txt txtmid")end;k3=dv([[%s M %d %f h %d]],k3,ai+k8,hx,jX)else k3=dv([[%s M %d %f h %d]],k3,ai-k8-jX,hx,jX)k3=dv([[%s M %d %f h %d]],k3,ai+k8,hx,jX)end end;jK[#jK+1]=k3 ..[["/>]]local ka="PITCH"if not dd then ka="REL PITCH"end;if k6>90 and not cj then k6=90-(k6-90)elseif k6<-90 and not cj then k6=-90-(k6+90)end;if jT>200 then if cj then if fB>iN then jK[#jK+1]=gW(ai,aj-15,"Yaw","pdim txt txtmid")jK[#jK+1]=gW(ai,aj+20,k7,"pdim txt txtmid")end;jK[#jK+1]=dv([[<g transform="rotate(%f,%d,%d)">]],-jR,ai,aj)else jK[#jK+1]=dv([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jK[#jK+1]=dv([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k8+25,aj-5,ai-k8+20,aj,ai-k8+25,aj+5,ai-k8+50,aj+4,k9)jK[#jK+1]=dv([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k8-25,aj-5,ai+k8-20,aj,ai+k8-25,aj+5,ai+k8-30,aj+4,k9)jK[#jK+1]="</g>"end;local kb=bG(jT/3)jK[#jK+1]=dv([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-kb,aj,jT-kb)if not cj and dd then jK[#jK+1]=dv([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jR,ai,aj,ai-k8+10,aj,k8*2-20)end;jK[#jK+1]="</g>"if jT<200 then if cj and fB>iN then jK[#jK+1]=gW(ai,aj-jT,ka,"pdim txt txtmid")jK[#jK+1]=gW(ai,aj-jT+10,k9,"pdim txt txtmid")jK[#jK+1]=gW(ai,aj-15,"Yaw","pdim txt txtmid")jK[#jK+1]=gW(ai,aj+20,k7,"pdim txt txtmid")else jK[#jK+1]=gW(ai,aj-jT,ka,"pdim txt txtmid")jK[#jK+1]=gW(ai,aj-jT+15,k9,"pdim txt txtmid")end end end end;local function kc(jK,ee,dd)local kd=ao;local ke=ap;if kd==0 and ke==0 then return end;local kf=78;local kg=19;local kh=ci;if ci~=-1 then jK[#jK+1]=gW(kd+kf,ke+kg+20,dv("AGL: %.1fm",ci),"pdim altsm txtend")end;if dd and(ee<200000 and not cj or ee and cj)then table.insert(jK,dv([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kd-1,ke-4,kf+2,kg+6,kd+1,ke-1,kf-4,kg))local gH=0;local ki=1;local kj=0;local kk=ee<0;local kl=ee<i_.surfaceMaxAltitude;local km=9;if kk then km=0 end;local ee=f9(ee)while gH<6 do local kn=11;local ko=16;local kp=9;local kq=14;local jE="altsm"if gH>2 then ko=ko+3;kn=kn+2;kq=kq+2;kp=kp-6;jE="altbig"end;if kk then jE=jE.." red"elseif kl then jE=jE.." orange"end;local kr=ee/ki%10;local ks=bG(kr)local kt=bG((ks+1)%10)local ku=kj;if gH==0 then ku=kr-ks;if kk then ku=1-ku end end;if kk and(gH==0 or kj~=0)then local gK=kt;kt=ks;ks=gK end;local kv=ko*(ku-1)local kw=kv+ko;local hw=kd+kp+(6-gH)*kn;local hx=ke+kq;jK[#jK+1]=gW(hw,hx+kv,kt,jE)jK[#jK+1]=gW(hw,hx+kw,ks,jE)gH=gH+1;ki=ki*10;if ks==km then kj=ku else kj=0 end end;table.insert(jK,[[</g></g>]])end end;local function kx(fG)local ky=-math.deg(f4(fG.y,fG.z))+180;ky=ky-90;if ky<0 then ky=360+ky end;if ky>180 then ky=-180+ky-180 end;return-ky end;local function kz(fG)local jY=math.deg(f4(fG.y,fG.x))-90;if jY<-180 then jY=360+jY end;return jY end;local function kA(jK,fG,fB,ai,aj)if fB>5 and not cj or fB>iN then local jT=ab;local kB=20;local kC=20;local kD=kx(fG)local kE=kz(fG)local kF=14;local kG=kF/2;local kH=-kE/kC*jT;local kI=kD/kB*jT;local hw=ai+kH;local hx=aj+kI;local cd=dy(kH^2+kI^2)local kJ=[[<circle
                            cx="]]..hw..[["
                            cy="]]..hx..[["
                            r="]]..kG/kF..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hw..[["
                            cy="]]..hx..[["
                            r="]]..kG..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hw-kF..[[,]]..hx..[[ h ]]..kG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hw+kG..[[,]]..hx..[[ h ]]..kG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hw..[[,]]..hx-kF..[[ v ]]..kG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cd<jT then jK[#jK+1]=kJ else local jL=f4(kI,kH)local kK=4;local kL=ai+jT*math.cos(jL)local kM=aj+jT*math.sin(jL)jK[#jK+1]=dv('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jL*180/math.pi,kL,kM,kL-kK,kM-kK/2,kK*2,kK,kL+kK,kM-kK,kK,kK,-kK,kK)end;if not cj then local kN=vec3(fG)kD=kx(-kN)kE=kz(-kN)kH=-kE/kC*jT;kI=kD/kB*jT;hw=ai+kH;hx=aj+kI;cd=dy(kH^2+kI^2)if cd<jT then local kO=[[<circle
                                    cx="]]..hw..[["
                                    cy="]]..hx..[["
                                    r="]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hw..[[,]]..hx-kF..[[ v ]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hw..[[,]]..hx..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hw..[[,]]..hx..[[)" />
                                <path
                                    d="M ]]..hw-kG..[[,]]..hx..[[ h ]]..kF..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hw..[[,]]..hx..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hw..[[,]]..hx..[[)"/>]]jK[#jK+1]=kO end end end end;local function kP(jK,j4,kQ,kR)if ak==0 and al==0 then return end;kQ=bG(kQ+0.5)local ju=al+10;local jv=al+20;if is()==1 and not l then ju=55;jv=65 end;local kS="CRUISE"local c="km/h"local dW=kR;if j4=="TRAVEL"or j4=="AUTOPILOT"then kS="THROT"c="%"dW=kQ;local kT="dim"if kQ<0 then kT="red"end;jK[#jK+1]=dv([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kT,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-f9(kQ),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jK[#jK+1]=gW(ak+10,ju,kS,"pbright txtstart")jK[#jK+1]=gW(ak+10,jv,dv("%.0f %s",dW,c),"pbright txtstart")if cj and u and d5 and bO then kQ=bG(bP*100+0.5)local kT="red"if kQ<0 then kT="red"end;jK[#jK+1]=dv([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kT,1-f9(kQ),ak-10,al+50,ak-15,al+53,ak-15,al+47)jK[#jK+1]=gW(ak+10,ju+40,"LIMIT","pbright txtstart")jK[#jK+1]=gW(ak+10,jv+40,kQ.."%","pbright txtstart")end;if cj and u or b5 then jK[#jK+1]=gW(ak+10,ju-40,"LIMIT: "..cM.." km/h","dim txtstart")elseif not cj and b0 then jK[#jK+1]=gW(ak+10,ju-40,"LIMIT: "..bG(a0*3.6+0.5).." km/h","dim txtstart")end end;local function kU(jK,kV)if ak==0 and al==0 then return end;local kW=al-10;local kX=ak+10;jK[#jK+1]=gW(0,0,"","pdim txt txtend")if is()==1 and not l then kW=75 end;jK[#jK+1]=gW(kX,kW,bG(kV).." km/h","pbright txtbig txtstart")end;local function kY(jK)jK[#jK+1]=gW(j0(1900),j1(1070),dv("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jK[#jK+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jK[#jK+1]=gW(j0(960),j1(550),"Warning: Invalid Control Scheme Detected","warnings")jK[#jK+1]=gW(j0(960),j1(600),"Keyboard Scheme must be selected","warnings")jK[#jK+1]=gW(j0(960),j1(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kZ=j0(960)local k_=j1(860)local l0=j1(880)local l1=j1(900)local l2=j1(960)local l3=j1(200)local l4=j1(250)local l5=j1(960)if is()==1 and not l then k_=j1(135)l0=j1(155)l1=j1(175)l3=j1(115)l4=j1(95)end;local l6="#222222"local l7="white"local l8="dimmer"local l9="pbright"local la="#110000"local lb=l6;local lc=l8;if aY then jK[#jK+1]=gW(kZ,k_,"Brake Engaged","warnings")la="#440000"lb=l7;lc=l9 elseif bN>0 then jK[#jK+1]=gW(kZ,k_,"Auto-Brake Engaged","warnings","opacity:"..bN)end;local ld="#110000"local le=l6;local lf=l8;if cj and cK and ci==-1 then if not b0 and not bn and not b3 and not d3 and not b6 and not b4 then jK[#jK+1]=gW(kZ,l3+50,"** STALL WARNING **","warnings")ld="#ff0000"le=l7;lf=l9;g5("stall","SW",2)end end;if db then jK[#jK+1]=gW(kZ,l3+90,"Flight Assist in Progress","warnings")end;if cp then jK[#jK+1]=gW(kZ,l5,"Gyro Enabled","warnings")end;local lg="#111100"local lh=l6;local li=l8;if bj then lg="#775500"lh=l7;li=l9;if bT then jK[#jK+1]=gW(kZ,l0,"Gear Extended","warn")else jK[#jK+1]=gW(kZ,l0,"Landed (G: Takeoff)","warnings")end;local lj=iy(d:getTargetGroundAltitude())jK[#jK+1]=gW(kZ,l1,"Hover Height: "..lj,"warn")end;local lk="#000011"local ll=l6;local lm=l8;if c3 then lk="#0000DD"ll=l7;lm=l9;jK[#jK+1]=gW(kZ,l2+20,"ROCKET BOOST ENABLED","warn")end;local ln="#001100"local lo=l6;local lp=l8;if antigrav and not q and d3 and bs~=nil then ln="#00DD00"lo=l7;lp=l9;if f9(cl-antigrav.getBaseAltitude())<501 then jK[#jK+1]=gW(kZ,l3+15,dv("Target Altitude: %d Singularity Altitude: %d",bG(bs),bG(antigrav.getBaseAltitude())),"warn")else jK[#jK+1]=gW(kZ,l3+15,dv("Target Altitude: %d Singluarity Altitude: %d",bG(bs),bG(antigrav.getBaseAltitude())),"warnings")end elseif b0 and bg~="None"then jK[#jK+1]=gW(kZ,l3+20,"Autopilot "..bd,"warn")elseif bq~=nil then jK[#jK+1]=gW(kZ,l3+20,dv("LockedPitch: %d",bG(bq)),"warn")elseif c0 then jK[#jK+1]=gW(kZ,l3+20,"Follow Mode Engaged","warn")elseif b5 or ch then jK[#jK+1]=gW(kZ,l3+20,"Re-entry in Progress","warn")end;if b2 or b6 then local lj=iy(b7,2)if b6 then if d3 then lj=iy(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jK[#jK+1]=gW(kZ,l3,"VTO to "..lj,"warn")elseif b4 and not bw then if cg then jK[#jK+1]=gW(kZ,l3,"Takeoff to "..bg,"warn")else jK[#jK+1]=gW(kZ,l3,"Takeoff to "..lj,"warn")end;if aY and not b6 then jK[#jK+1]=gW(kZ,l3+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jK[#jK+1]=gW(kZ,l3,"Altitude Hold: "..lj,"warn")end end;if b6 and(antigrav~=nil and antigrav)then if ck>0.1 then jK[#jK+1]=gW(kZ,l3+20,"Beginning ascent","warn")elseif ck<0.09 and ck>0.05 then jK[#jK+1]=gW(kZ,l3+20,"Aligning trajectory","warn")elseif ck<0.05 then jK[#jK+1]=gW(kZ,l3+20,"Leaving atmosphere","warn")end end;if bw then if cO~=nil then jK[#jK+1]=gW(kZ,l3,cO,"warn")end end;if b3 then if lq then jK[#jK+1]=gW(kZ,l3,"Brake-Landing","warnings")else jK[#jK+1]=gW(kZ,l3,"Coast-Landing","warnings")end end;if a_ then jK[#jK+1]=gW(kZ,l3,"Prograde Alignment","crit")end;if aZ then jK[#jK+1]=gW(kZ,l3,"Retrograde Alignment","crit")end;local lr="#110000"local ls=l6;local lt=l8;if de then lr="#FF0000"ls=l7;lt=l9;local type;if string.find(de,"COLLISION")then type="warnings"else type="crit"end;jK[#jK+1]=gW(kZ,l4+20,de,type)elseif ck==0 then local lu,lv=cE.checkLOS(cY:normalize())if lv~=nil then lt=l9;lr="#FF0000"ls=l7;local lj=iy(lv)local lw=cz.computeTravelTime(cZ,0,lv)local lx="Collision"if lu.noAtmosphericDensityAltitude>0 then lx="Atmosphere"end;jK[#jK+1]=gW(kZ,l4+20,lu.name.." "..lx.." "..iz(lw).." In "..lj,"crit")end end;if bn and not bw then jK[#jK+1]=gW(kZ,l3+35,ly,"warn")end;local lz="#111100"local lA=l6;local lB=l8;if di and#di>1 then lz="#DDDD00"lA=l7;lB=l9 end;local lC=j0;local lD=j1;local l8="topButton"local lE="topButtonActive"local lF=l8;if b0 or bn or cg or bw then lF=lE end;local lG=l8;if a_ then lG=lE end;local lH=l8;if b3 or bj then lH=lE end;local lI=l8;if b2 or bn then lI=lE end;local lJ=l8;if aZ then lJ=lE end;local lK=l8;if bw or cR and b0 then lK=lE end;if x and I then local lL=lD(30)jK[#jK+1]=dv([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lF,lC(960),lD(54),lD(-53),lC(-120),lC(25),lD(50))jK[#jK+1]=gW(lC(910),lL,"AUTOPILOT")jK[#jK+1]=dv([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lC(865),lD(51),lC(-25),lD(-50),lC(-110),lC(25),lD(46))jK[#jK+1]=gW(lC(800),lL,"PROGRADE")jK[#jK+1]=dv([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,lC(755),lD(47),lC(-25),lD(-46),lC(-98),lC(44),lD(44))jK[#jK+1]=gW(lC(700),lL,"LAND")jK[#jK+1]=dv([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lI,lC(960),lD(54),lD(-53),lC(120),lC(-25),lD(50))jK[#jK+1]=gW(lC(1010),lL,"ALT HOLD")jK[#jK+1]=dv([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lC(1055),lD(51),lC(25),lD(-50),lC(110),lC(-25),lD(46))jK[#jK+1]=gW(lC(1122),lL,"RETROGRADE")jK[#jK+1]=dv([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lK,lC(1165),lD(47),lC(25),lD(-46),lC(98),lC(-44),lD(44))jK[#jK+1]=gW(lC(1220),lL,"ORBIT")jK[#jK+1]=[[
                                    </g>
                                </g>]]jK[#jK+1]="</g>"end;return jK end;local function lM(fB)return bG(iv(fB*3.6,0)+0.5).." km/h"end;local function lN(gH)local gJ=bg;if gH~=nil and type(gH)=="number"then if gH==0 then return"None"end;gJ=d8[gH].name end;if gJ==nil then gJ=gg.name end;if gJ==nil then gJ="None"end;return gJ end;local function lO(jK)local lP=cE.routeWP(true)if not lP or#lP==0 then return end;local hw=j0(750)local hx=j1(360)if b0 or bn then jK[#jK+1]=gW(hw,hx,"REMAINING ROUTE","pdim txtstart size20")else jK[#jK+1]=gW(hw,hx,"LOADED ROUTE","pdim txtstart size20")end;for dV,L in pairs(lP)do hx=hx+20;jK[#jK+1]=gW(hw,hx,dV..". "..lP[dV],"pdim txtstart size20")end end;local function lQ(jK)local hw=aw+10;local hx=ax+20;local lR={}local lS={"Alt-4: AutoTakeoff to Target"}local lT={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lU={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lV={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lR,"--------------DYNAMIC-----------------")if cj then if ci~=-1 then iw(lR,lS)if c6 and i_ and c6.name==i_.name then table.insert(lR,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aX then if antigrav then if d3 then table.insert(lR,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lR,"Turn on AGG to takeoff to AGG Height")end end;if aX then table.insert(lR,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lR,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lR,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bj then table.insert(lR,"G: Takeoff to hover height, raise gear")else table.insert(lR,"G: Lowergear and Land")end else iw(lR,lT)table.insert(lR,"G: Begin BrakeLanding or Land")end;if b6 then table.insert(lR,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iw(lR,lU)if io then table.insert(lR,"Alt-Shift-6: Vent shields")table.insert(lR,"Alt-Shift-7: Toggle shied off/on")end end;if gg~=nil then table.insert(lR,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lR,"Alt-9: Activate Gyroscope")end;if aT~="none"or aS~="none"or aU~="none"then table.insert(lR,"Alt-Shift-9: Cycles engines with Extra tags")end;if b2 then table.insert(lR,"Alt-Spacebar/C will raise/lower target height")table.insert(lR,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not cj then table.insert(lR,"LALT+Mousewheel will lower/raise speed limit")end;iw(lR,lV)for L=1,#lR do hx=hx+12;jK[#jK+1]=gW(hw,hx,lR[L],"pdim txtbig txtstart")end end;local function lW(jK)local lX=aw;local lY=ax;local lZ=av;local l_=4;local m0=15;local hw=0;local hx=0;local m1,m2,m3,m4;local m5;local function m6(type)local m7,bI,fB,m8,jE,m9;if type=="Periapsis"then m7=m5.periapsis.altitude;bI=m5.timeToPeriapsis;fB=m5.periapsis.speed;jE="txtend"m8=12;m9=math.min(hw,lX+lZ-i_.radius/m3-l_*2)else m7=m5.apoapsis.altitude;bI=m5.timeToApoapsis;fB=m5.apoapsis.speed;m8=-12;jE="txtstart"m9=hw end;if cZ<1 then bI=0 end;jK[#jK+1]=dv([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m9+m8,hx-5,hw,hx-5)jK[#jK+1]=dv([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m9-m8*4,hx+2,hw,hx+2)jK[#jK+1]=gW(m9,hx,type,jE)hw=m9-m8*2;hx=hx+m0;local lj=iy(m7)jK[#jK+1]=gW(hw,hx,lj,jE)hx=hx+m0;jK[#jK+1]=gW(hw,hx,iz(bI),jE)hx=hx+m0;jK[#jK+1]=gW(hw,hx,lM(fB),jE)end;local ma=lZ*1.5;if bD=="INFO"then ma=25*9 end;if bD~="HIDE"then jK[#jK+1]=[[<g class="pbright txtorb txtmid">]]jK[#jK+1]=dv('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lZ*2,ma,lX,lY)jK[#jK+1]=dv([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lZ*2,ma,lX,lY)end;local mb=lZ*1.5;local mc=lZ*2;local md=mb/2;local me=lZ;local mf=lX+me;local mg=lY+md;local mh=lX+mc;local mi=lY+mb;if bD=="ORBIT"then lY=lY+l_;m1=lZ/2;m4=0;m5={}m5.periapsis={}m5.apoapsis={}if fF~=nil then if fF.periapsis~=nil then m5.periapsis.altitude=fF.periapsis.altitude;m5.periapsis.speed=fF.periapsis.speed end;if fF.apoapsis~=nil then m5.apoapsis.altitude=fF.apoapsis.altitude;m5.apoapsis.speed=fF.apoapsis.speed end;m5.period=fF.period;m5.eccentricity=fF.eccentricity;m5.timeToApoapsis=fF.timeToApoapsis;m5.timeToPeriapsis=fF.timeToPeriapsis;m5.eccentricAnomaly=fF.eccentricAnomaly;m5.trueAnomaly=fF.trueAnomaly end;if m5.periapsis==nil then m5.periapsis={}m5.periapsis.altitude=-i_.radius;m5.periapsis.speed=a0 end;if m5.eccentricity==nil then m5.eccentricity=1 end;if m5.apoapsis==nil then m5.apoapsis={}m5.apoapsis.altitude=cl;m5.apoapsis.speed=0 end;if cZ<1 then m5.apoapsis.altitude=cl;m5.apoapsis.speed=0 end;if m5.apoapsis.altitude then m3=(m5.apoapsis.altitude+m5.periapsis.altitude+i_.radius*2)/(m1*2)m2=(i_.radius+m5.apoapsis.altitude)/m3*(1-m5.eccentricity)m4=m1-m5.periapsis.altitude/m3-i_.radius/m3;local mj=math.pi;if m5.period~=nil and m5.period>0 and m5.timeToApoapsis~=nil then mj=m5.eccentricAnomaly;if m5.timeToPeriapsis<m5.timeToApoapsis then mj=2*math.pi-mj end end;if cZ<1 or mj~=mj then mj=math.pi end;local mk=-m1*math.cos(mj)+lX+me+l_;local ml=m2*math.sin(mj)+lY+md+l_;local mm=""jK[#jK+1]='<g clip-path="url(#orbitRect)">'jK[#jK+1]=dv([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mm,lX+lZ+l_,lY+lZ*1.5/2+l_,m1,m2)if m2<1 then jK[#jK+1]=dv([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lX+lZ+l_-m4,lY+lZ*1.5/2+l_,mk,ml)end;jK[#jK+1]=dv('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,(i_.radius+i_.noAtmosphericDensityAltitude)/m3)jK[#jK+1]=dv('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,(i_.radius+i_.noAtmosphericDensityAltitude)/m3)jK[#jK+1]=dv([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lX+lZ+l_,lY+lZ*1.5/2+l_,m1,m2)jK[#jK+1]=dv('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lX+lZ+l_-m4,lY+lZ*1.5/2+l_,i_.radius/m3)jK[#jK+1]='</g>'local mn=math.floor(i_.radius/m3+0.5)hw=lX+lZ+l_*4+m1;hx=lY+lZ*1.5/2+5+l_;if m5.apoapsis~=nil and m5.apoapsis.speed<a0 then m6("Apoapsis")end;hx=lY+lZ*1.5/2+5+l_;hw=lX+lZ-l_*2-m1;if m5.periapsis~=nil and m5.periapsis.speed<a0 and m5.periapsis.altitude>0 then m6("Periapsis")end;jK[#jK+1]=gW(lX+lZ+l_,lY+20+l_,i_.name,"txtorbbig")jK[#jK+1]=dv('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mk,ml)jK[#jK+1]=[[</g>]]return jK else jK[#jK+1]='<g clip-path="url(#orbitRect)">'local mo=""local mp=1.2*(mq-mr)/(lZ*2)local ms=1.4*(mt-mu)/(lZ*1.5)for dV,dH in pairs(e[0])do if dH.center then local hw=lX+lZ+dH.center.x/mp;local hx=lY+lZ*1.5/2+dH.center.y/ms;mo=mo..'<circle cx="'..hw..'" cy="'..hx..'" r="'..dH.radius/mp*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dH.name,"Moon")and not string.match(dH.name,"Sanctuary")and not string.match(dH.name,"Space")then mo=mo.."<text x='"..hw.."' y='"..hx+dH.radius/mp*30+20 .."' font-size='12' fill="..cq.." text-anchor='middle' font-family='Montserrat'>"..dH.name.."</text>"end end end;local fH=vec3(b.getConstructWorldPos())local hw=lX+lZ+fH.x/mp;local hx=lY+lZ*1.5/2+fH.y/ms;mo=mo..'<circle cx="'..hw..'" cy="'..hx..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mo=mo.."<text x='"..hw.."' y='"..hx-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iH=mp;iI=ms;local mv=fH+cY*1000000;local mw=lX+lZ+mv.x/mp;local jv=lY+lZ*1.5/2+mv.y/ms;mo=mo..'<line x1="'..hw..'" y1="'..hx..'" x2="'..mw..'" y2="'..jv..'" stroke="purple" stroke-width="1"/>'jK[#jK+1]=mo;jK[#jK+1]='</g>'end elseif bD=="INFO"then jK=cC.DrawOdometer(jK,c7,bk,c8)elseif bD=="HELP"then jK=lQ(jK)elseif bD=="SCOPE"then jK[#jK+1]='<g clip-path="url(#orbitRect)">'local mx=dl;if ck>0 then table.sort(dk,function(eL,eM)local eN,eO=eL.center,eM.center;return(eN.x-d1.x)^2+(eN.y-d1.y)^2+(eN.z-d1.z)^2<(eO.x-d1.x)^2+(eO.y-d1.y)^2+(eO.z-d1.z)^2 end)end;local h3={}local my={}local mz=120;local mA=nil;local mB=nil;for L,dH in ipairs(dk)do local h2=dH.center-d1;local mC=h2:len()local mD=h2:normalize()local mE=h2:cross(cV):normalize()local mF=math.acos(mE:dot(cW))if mF~=mF then mF=0 end;if mE:cross(cW):dot(cV)<0 then mF=-mF end;local mG=h2:project_on_plane(cV):len()local mH=math.sin(mF)*math.asin(mG/mC)*constants.rad2deg;local mI=math.cos(mF)*math.asin(mG/mC)*constants.rad2deg;if mD:dot(cV)<0 then mI=90*math.cos(mF)+90*math.cos(mF)-mI;mH=90*math.sin(mF)+90*math.sin(mF)-mH end;local hw=mf+mH/mx*mb;local hx=mg+mI/mx*mb;local mJ=(hw-mf)*(hw-mf)+(hx-mg)*(hx-mg)local mK=math.asin((dH.radius+dH.surfaceMaxAltitude)/mC)*constants.rad2deg;if mK~=mK then mK=mx end;local i1=mK/mx*mb;local mL=math.asin(dH.atmosphereRadius/mC)*constants.rad2deg;if mL~=mL then mL=mK end;local mM=mL/mx*mb;local cd=iy(mC,1)local mN=dH.name;local mO=false;if hx>lY then if hx>mi then if hx-mM<=mi then mO=true end else mO=true end else if hx+mM>=lY then mO=true end end;local mP=false;local mQ=hw;if dH.systemId==0 then mQ=hw+mz else mQ=hw-mz end;if mQ+mz>lX then if mQ+mz>mh then if mQ-mM-mz<=mh then mP=true end else mP=true end else if mQ+mM+mz>=lX then mP=true end end;local mR={}mR.x=hw;mR.y=hx;mR.planet=dH;mR.atmoSize=mM;if not mA or mJ<mA then mA=mJ;mB=mR end;if mP and mO then local mS=math.max(mM,5)if mJ<mS*mS then mN=mN.." - "..cd end;mR.size=i1;mR.i=L;mR.displayString=mN;mR.distance=cd;mR.visible=true;my[#my+1]=mR else mR.visible=false end end;local mT=false;table.sort(my,function(eN,eO)return eN.y<eO.y end)for dV,fK in ipairs(my)do local dH,i1,L,mM,hw,hx,mN,cd=fK.planet,fK.size,fK.i,fK.atmoSize,fK.x,fK.y,fK.displayString,fK.distance;local m9,mU,mV,mW;local mX=15;local jE="pdim"if dH.systemId~=0 then mV=j0(string.len(mN)*5)mX=-(15+mV)mW=j1(10)jE="pdimfill"else mV=j0(string.len(mN)*9)mW=j1(15)end;if i1*2>mV then m9=dw(hw,lX+mV/2,mh-mV/2)mU=dw(hx,lY+mW,mi-5)m9=dw(m9,hw-i1+mV/2,hw+i1-mV/2)mU=dw(mU,hx-i1+mW,hx+i1)else m9=hw+mX;mU=hx end;for mY,fK in pairs(h3)do local mZ=fK.textPositions;local m_=mZ.y-mU;if mY~=L and f9(m_)<mZ.height and mZ.x+mZ.width>m9 and mZ.x<m9+mV then if i1>mV then mU=dw(mU+mW,lY+15,mi-5)else mU=mZ.y+mZ.height+1 end end end;local n0=mN~=dH.name or m9<=mf and m9+mV>=mf and mU-mW<=mg and mU>=mg;fK.hovered=n0;local n1=1;if n0 then n1=2;if i1*2<mV then n1=10 end;if mN==dH.name then mN=mN.." - "..cd end;jE="pbright"if dH.systemId~=0 then mV=j0(string.len(mN)*5)mX=-(15+mV)else mV=j0(string.len(mN)*7)end;if i1*2>mV then m9=dw(hw,lX+mV/2,mh-mV/2)m9=dw(m9,hw-i1+mV/2,hw+i1-mV/2)else m9=hw+mX end end;h3[L]={}h3[L].textPositions={}h3[L].textPositions.y=mU;h3[L].textPositions.x=m9;h3[L].textPositions.width=mV;h3[L].textPositions.height=mW;h3[L].output=""if i1*2>mV then jE=jE.." txtmid"else jE=jE.." txtstart"end;if mM-i1>2 then h3[L].output=dv('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hw,hx,mM,cr,0.1*n1)end;h3[L].output=h3[L].output..dv('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hw,hx,i1,cr,0.2*n1)if dH.systemId==0 then h3[L].output=h3[L].output..dv([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m9,mU,cq,jE,mN)if i1*2<=mV then h3[L].output=h3[L].output..dv("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m9+mV,mU+2,m9,mU+2,hw,hx)end else h3[L].output=h3[L].output..dv([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m9,mU,cr,jE,mN)if i1*2<=mV then h3[L].output=h3[L].output..dv("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m9,mU+2,m9+mV,mU+2,hw,hx)end end end;for dV=#dk,1,-1 do if h3[dV]then jK[#jK+1]=h3[dV].output end end;if mB~=nil and dl<90 and not mB.hovered then local n2=mB.planet.atmosphereRadius/mB.atmoSize;local n3=dy(mA)*n2;local n4=iy(n3,1)local mV=j0(math.max(string.len(n4)*7,string.len(mB.planet.name)*7))local mW=j1(12)local m9=dw(mB.x+(mf-mB.x)/2,lX+mV/2,mh-mV/2)local mU=dw(mB.y+(mg-mB.y)/2,lY+mW*2,mi-5)jK[#jK+1]=dv("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mB.x,mB.y,mf,mg)jK[#jK+1]=dv([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m9,mU,"white",n4)if not mB.visible then jK[#jK+1]=dv([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m9,mU-mW,"white",mB.planet.name)end end;if cZ>1 then local h2=cY;local mD=h2:normalize()local mG=h2:project_on_plane(cV):len()local mE=h2:cross(cV):normalize()local mF=math.acos(mE:dot(cW))if mF~=mF then mF=0 end;if mE:cross(cW):dot(cV)<0 then mF=-mF end;local mH=math.sin(mF)*math.asin(mG/h2:len())*constants.rad2deg;local mI=math.cos(mF)*math.asin(mG/h2:len())*constants.rad2deg;if mD:dot(cV)<0 then mI=90*math.cos(mF)+90*math.cos(mF)-mI;mH=90*math.sin(mF)+90*math.sin(mF)-mH end;local hw=mf+mH/mx*mb;local hx=mg+mI/mx*mb;local kF=14;local kG=kF/2;local kJ=[[<circle
                                    cx="]]..hw..[["
                                    cy="]]..hx..[["
                                    r="]]..kG/kF..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hw..[["
                                    cy="]]..hx..[["
                                    r="]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hw-kF..[[,]]..hx..[[ h ]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hw+kG..[[,]]..hx..[[ h ]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hw..[[,]]..hx-kF..[[ v ]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jK[#jK+1]=kJ end;jK[#jK+1]=dv("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mf,mg-10,mf,mg+10)jK[#jK+1]=dv("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mf-10,mg,mf+10,mg)jK[#jK+1]='</g>'else return jK end end;local function n5(n6,n7)local n8;local n9=(n7-n6):normalize()local fI=(d1-n6):dot(n9)/n9:dot(n9)if fI<=0. then return(d1-n6):len()elseif fI>=(n7-n6):len()then return(d1-n7):len()end;local na=n6+fI*n9;n8=(na-d1):len()return n8 end;local function nb()local n8;local nc=nil;local nd=nil;local ne=nil;for dV,nf in pairs(e[0])do if nf.hasAtmosphere then local cd=n5(i_.center,nf.center)if nc==nil or cd<nc then nd=nf;nc=cd;ne=i_ end;if c6 and c6.hasAtmosphere and c6.name~=i_.name then local e_=n5(c6.center,nf.center)if e_<nc then nd=nf;nc=e_;ne=c6 end end end end;local ng=j0(1770)local nh=j1(330)if nc then local ni="txttick "local nj=500000;if nc<nd.radius+nj or nc<ne.radius+nj then if d9 then ni="txttick red "else ni="txttick orange "end end;n8=iy(nc,2)iM=gW(ng,nh,"Pipe ("..ne.name.."--"..nd.name.."): "..n8,ni.."pbright txtmid")end end;local function nk(hw,hx,nl,nm,kS)local nn={x=hw,y=hx,width=nl,height=nm,label=kS}iG[kS]=nn;return nn end;local function no(np,nq,nl,nm,hw,hx,nr,ns,nt,nu,jE)local nn={enableName=np,disableName=nq,width=nl,height=nm,x=hw,y=hx,toggleVar=nr,toggleFunction=ns,drawCondition=nt,hovered=false,class=jE}if nu then table.insert(iF,nn)else table.insert(iE,nn)end;return nn end;local function nv(nw)if not iK then nx=false;ny=false;nz=false;x=true;return elseif nw=="handling"then nx=not nx;ny=false;nz=false elseif nw=="hud"then ny=not ny;nx=false;nz=false elseif nw=="physics"then nz=not nz;nx=false;ny=false end;if nz or ny or nx then iL=ix(nw)x=false else iL="none"x=true end end;local function nA()iK=not iK;if iK then iD=iF;c2="Hold SHIFT to see Settings"dm=x else iD=iE;c2="Hold SHIFT to see Control Buttons"nv()x=dm end end;local function nB()local function nC(dH,dV)dH.set(not dH.get())if dH.get()then c2=dV.." set to true"else c2=dV.." set to false"end;if dV=="showHud"then dm=dH.get()elseif dV=="BrakeToggleDefault"then aW=j end end;local nD=50;local nE=340;local hw=500;local hx=ct/2-400;local nF=0;for dV,dH in pairs(ix("boolean"))do if type(dH.get())=="boolean"then no(dV,dV,nE,nD,hw,hx,function()return dH.get()end,function()nC(dH,dV)end,function()return true end,true)hx=hx+nD+20;if nF==9 then hw=hw+nE+20;hx=ct/2-400;nF=0 else nF=nF+1 end end end;no("Control View","Control View",nE,nD,10,ct/2-500,function()return true end,nA,function()return true end,true)no("View Handling Settings",'Hide Handling Settings',nE,nD,10,ct/2-(500-nD),function()return nx end,function()nv("handling")end,function()return true end,true)no("View Hud Settings",'Hide Hud Settings',nE,nD,10,ct/2-(500-nD*2),function()return ny end,function()nv("hud")end,function()return true end,true)no("View Physics Settings",'Hide Physics Settings',nE,nD,10,ct/2-(500-nD*3),function()return nz end,function()nv("physics")end,function()return true end,true)end;local function nG()local function gI()local g7=d1;local gJ=i_.name..". "..#bm;if radar_1 then gJ=cF.GetClosestName(gJ)end;return cD.AddNewLocation(gJ,g7,false,true)end;local function nH()b1=not b1 end;local function nI(nJ)if nJ==1 then a_=not a_;aZ=false else aZ=not aZ;a_=false end;b0=false;b2=false;c0=false;b3=false;bq=nil;b5=false;b4=false end;local function nK(nL)cD.UpdatePosition(nil,nL)end;local function gD()cD.ClearCurrentPosition()end;local function nM(gH)local lP=cE.routeWP(true)if lP and#lP>0 then return"Engage Route: "..lP[1]end;return"Engage Autopilot: "..lN(gH)end;local function nN(gH)local lP=cE.routeWP(true)if lP and#lP>0 then return"Next Route Point: "..lP[1]end;return"Disable Autopilot: "..lN(gH)end;local function nO()if is()==1 then c0=not c0;if c0 then b0=false;aZ=false;a_=false;b2=false;b5=false;b3=false;b4=false;nP=bj;bj=false;d.control.retractLandingGears()it:setTargetGroundAltitude(Y)g5("folOn","F")else g5("folOff","F")aY=true;cJ=p;bj=nP;if bj then d.control.extendLandingGears()it:setTargetGroundAltitude(Z)end end else c2="Follow Mode only works with Remote controller"c0=false end end;local nD=50;local nE=260;local nQ=j0(30)local nR=aw+av*2+2;local nS=ax+1;no("+","+",nQ,nQ,nR,nS+nQ+1,function()return false end,function()dl=dl/8 end,function()return bD=="SCOPE"end,nil,"ZoomButton")no("-","-",nQ,nQ,nR,nS,function()return false end,function()dl=math.min(dl*8,90)end,function()return bD=="SCOPE"end,nil,"ZoomButton")no("0","0",nQ,nQ,nR,nS+nQ*2+2,function()return false end,function()dl=90 end,function()return bD=="SCOPE"and dl~=90 end,nil,"ZoomButton")local nT=no("Enable Brake Toggle","Disable Brake Toggle",nE,nD,cs/2-nE/2,ct/2+350,function()return aW end,function()aW=not aW;if aW then c2="Brakes in Toggle Mode"else c2="Brakes in Default Mode"end end)no("Align Prograde","Disable Prograde",nE,nD,cs/2-nE/2-50-nT.width,ct/2-nD+380,function()return a_ end,function()nI(1)end)no("Align Retrograde","Disable Retrograde",nE,nD,cs/2-nE/2+nT.width+50,ct/2-nD+380,function()return aZ end,nI,function()return ck==0 end)nU=no(nM,nN,600,60,cs/2-600/2,ct/2-60/2-330,function()return b0 or bn or cg or bw end,function()end)local L;local function nV(nW)local gH=dh+nW;if gH>#d8 then gH=gH-#d8-1 end;if gH<0 then gH=#d8+gH end;return gH end;nX={}for L=0,10 do local nY=no(function(eO)local gH=nV(eO.apExtraIndex)if b0 or bn or cg or bw then return"Redirect: "..lN(gH)end;return nM(gH)end,function(eO)local gH=nV(eO.apExtraIndex)return nN(gH)end,600,60,cs/2-600/2,ct/2-60/2-330+60*L,function(eO)local gH=nV(eO.apExtraIndex)return gH==bi and(b0 or bn or cg or bw)end,function(eO)local gH=nV(eO.apExtraIndex)local nZ=bi==gH;bi=gH;cD.UpdateAutopilotTarget()cE.ToggleAutopilot()if not nZ and not(b0 or bn or cg or bw)then cE.ToggleAutopilot()end end,function()return dg and(#cE.routeWP(true)==0 or L==0)end)nY.apExtraIndex=L;nX[L]=nY end;no("Save Position","Save Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,gI,function()return bi==0 or gg==nil end)no("Update Position","Update Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,function()nK(nil)end,function()return bi>0 and gg~=nil end)no("Save Heading","Clear Heading",200,nU.height,nU.x+nU.width+30,nU.y+nU.height+20,function()return gg.heading~=nil end,function()if gg.heading~=nil then nK(false)else nK(true)end end,function()return bi>0 and gg~=nil end)no("Clear Position","Clear Position",200,nU.height,nU.x-200-30,nU.y,function()return true end,gD,function()return bi>0 and gg~=nil end)no("Save Route","Save Route",200,nU.height,nU.x-200-30,nU.y+nU.height*2+40,function()return false end,function()cE.routeWP(false,false,2)end,function()return#cE.routeWP(true)>0 end)no("Load Route","Clear Route",200,nU.height,nU.x-200-30,nU.y+nU.height+20,function()return#cE.routeWP(true)>0 end,function()if#cE.routeWP(true)>0 then cE.routeWP(false,true)elseif b0 or bn then c2="Disable Autopilot before loading route"return else cE.routeWP(false,false,1)end end,function()return true end)nD=60;nE=300;local hw=0;local hx=ct/2-150;no("Enable Check Damage","Disable Check Damage",nE,nD,hw,hx-nD-20,function()return s end,function()s=not s end)no("View Settings","View Settings",nE,nD,hw,hx,function()return true end,nA)hx=hx+nD+20;no("Enable Turn and Burn","Disable Turn and Burn",nE,nD,hw,hx,function()return b1 end,nH)hw=10;hx=ct/2-300;no("Horizontal Takeoff Mode","Vertical Takeoff Mode",nE,nD,hw+nE+20,hx,function()return aX end,function()aX=not aX;if aX then c2="Vertical Takeoff Mode"else c2="Horizontal Takeoff Mode"end end,function()return d2 end)hx=hx+nD+20;no("Engage Orbiting","Cancel Orbiting",nE,nD,hw+nE+20,hx,function()return bw end,cE.ToggleIntoOrbit,function()return ck==0 and dd end)hx=ct/2-150;no("Glide Re-Entry","Cancel Glide Re-Entry",nE,nD,hw+nE+20,hx,function()return b5 end,function()cf=1;nI(1)end,function()return i_.hasAtmosphere and not cj end)hx=hx+nD+20;no("Parachute Re-Entry","Cancel Parachute Re-Entry",nE,nD,hw+nE+20,hx,function()return b5 end,function()cf=2;nI(1)end,function()return i_.hasAtmosphere and not cj end)hx=hx+nD+20;no("Engage Follow Mode","Disable Follow Mode",nE,nD,hw,hx,function()return c0 end,nO,function()return is()==1 end)no("Enable Repair Arrows","Disable Repair Arrows",nE,nD,hw+nE+20,hx,function()return cx end,function()cx=not cx;if cx then c2="Repair Arrows Enabled"else c2="Repair Arrows Diabled"end end,function()return is()==1 end)hx=hx+nD+20;if not q then no("Enable AGG","Disable AGG",nE,nD,hw,hx,function()return d3 end,cE.ToggleAntigrav,function()return antigrav~=nil end)end;no(function()return dv("Switch IPH Mode - Current: %s",bx)end,function()return dv("IPH Mode: %s",bx)end,nE*2,nD,hw,hx,function()return false end,function()if bx=="All"then bx="Custom Only"elseif bx=="Custom Only"then bx="No Moons"else bx="All"end;c2="IPH Mode: "..bx end)hx=hx+nD+20;no(function()return dv("Toggle Control Scheme - Current: %s",g)end,function()return dv("Control Scheme: %s",g)end,nE*2,nD,hw,hx,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c2="New Control Scheme: "..g end)local n_=j1(20)local nY=nk(0,0,j0(70),n_,"HELP")nY=nk(nY.x+nY.width,nY.y,j0(80),n_,"INFO")nY=nk(nY.x+nY.width,nY.y,j0(70),n_,"ORBIT")nY=nk(nY.x+nY.width,nY.y,j0(70),n_,"SCOPE")nk(nY.x+nY.width,nY.y,j0(70),n_,"HIDE")end;local o0={}local o1=nil;function o0.HUDPrologue(jK)d9,da=iY(d1)if not d9 then bJ=af;bL=ag;bK=ah;if io and G and io.getState()==0 then io.toggle()end else bJ=ac;bL=ad;bK=ae;if io and G and io.getState()==1 then io.toggle()end end;cq=[[rgb(]]..bG(bJ+0.6)..","..bG(bL+0.6)..","..bG(bK+0.6)..[[)]]cr=[[rgb(]]..bG(bJ*0.8+0.5)..","..bG(bL*0.8+0.5)..","..bG(bK*0.8+0.5)..[[)]]local o2=cq;local o3=cr;local o4=[[rgb(]]..bG(bJ*0.4+0.5)..","..bG(bL*0.4+0.5)..","..bG(bK*0.4+0.5)..[[)]]local o5=cq;local o6=cr;local o7=o4;if j2()and not m then o2=[[rgb(]]..bG(bJ*0.5+0.5)..","..bG(bL*0.5+0.5)..","..bG(bK*0.5+0.5)..[[)]]o3=[[rgb(]]..bG(bJ*0.3+0.5)..","..bG(bL*0.3+0.5)..","..bG(bK*0.2+0.5)..[[)]]o4=[[rgb(]]..bG(bJ*0.2+0.5)..","..bG(bL*0.2+0.5)..","..bG(bK*0.2+0.5)..[[)]]end;local lC=j0;local lD=j1;jK[#jK+1]=dv([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o2,o2,o2,o5,o5,o3,o3,o6,o6,o3,o2,o4,o6,o2,o2,o4,o4,o7,o4,cs,ct,o3,o3,o3,o3,o3,o5,o3,o6,o7,o6,o6,o7)if not o1 then o1=dv([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lC(630),lD(0),lC(675),lD(45),lC(960),lD(55),lC(1245),lD(45),lC(1290),lD(0),lC(1000),lD(105),lC(1040),lD(59),lC(1250),lD(51),lC(1300),lD(0),lC(1920),lD(0),lC(1920),lD(20),lC(1400),lD(20),lC(1300),lD(105),lC(920),lD(105),lC(880),lD(59),lC(670),lD(51),lC(620),lD(0),lC(0),lD(0),lC(0),lD(20),lC(520),lD(20),lC(620),lD(105),lC(890),lD(59),lC(960),lD(62),lC(1030),lD(59),lC(985),lD(112),lC(1150),lD(112),lC(1100),lD(152),lC(820),lD(152),lC(780),lD(112),lC(935),lD(112),lC(890),lD(59),lC(960),lD(62),lC(1030),lD(59),lC(985),lD(112),lC(1150),lD(112),lC(1100),lD(152),lC(820),lD(152),lC(780),lD(112),lC(935),lD(112))end;if x and I then jK[#jK+1]=o1 end;return jK end;function o0.DrawVerticalSpeed(jK,ee)jJ(jK,ee)end;function o0.UpdateHud(jK)local ky=d6;local o8=d7;local jR=o8;local k6=ky;local kQ=bG(c.getThrottle())local kV=cZ*3.6;local kR=c.getAxisCommandValue(0)local o9=j0(1770)local oa=j1(310)if u and d5 then kR=bM;kQ=bM*100 end;local j4=j3()local jS="ROLL"if kQ==nil then kQ=0 end;if not dd then if cZ>5 then ky=kx(cX)o8=kz(cX)else ky=0;o8=0 end;jS="YAW"end;if da>50000 and not cj then local ob;ob=iy(da)jK[#jK+1]=gW(o9,oa,"PvP Boundary: "..ob,"pbright txtbig txtmid")end;jK[#jK+1]=ce;jK[#jK+1]=iQ;jK[#jK+1]=ij;if iM~=""then jK[#jK+1]=iM end;if j5~=""then jK[#jK+1]=j5 end;if j6~=""then jK[#jK+1]=j6 end;jJ(jK,cl)if is()==0 or l then if dd then jQ(jK,ai,aj,jR,jS,dd)else jQ(jK,ai,aj,o8,jS,dd)end;if not j2()or m then if dd then jQ(jK,ai,aj,jR,jS,dd)k5(jK,k6,jR,ai,aj,dd,bG(kz(cX)),cZ)else jQ(jK,ai,aj,o8,jS,dd)k5(jK,ky,o8,ai,aj,dd,bG(o8),cZ)end;kc(jK,cl,dd)kA(jK,cX,cZ,ai,aj)end end;kP(jK,j4,kQ,kR)kU(jK,kV)kY(jK)lW(jK)if not iK and c1 then lO(jK)end;return jK end;function o0.HUDEpilogue(jK)jK[#jK+1]="</svg>"return jK end;function o0.ExtraData(jK)local oc=j0(1240)local od=j1(55)local oe=od+10;local gN;local lC=j0;local lD=j1;local of=0;local j4=j3()if aX then j4=j4 .."-VERTICAL"end;if F and not b4 and not b3 and cZ>20 then j4=j4 .."-COLLISION ON"end;if bz~="Off"then j4="("..bz..")-"..j4 end;if b1 then j4="TB-"..j4 end;if not by then j4=j4 .."-DeCoupled"end;local og=lD(99)local oh=lD(80)local oi=lD(85)local oj=lD(31)local ok=0;local ol=0;local om=cn>1000000 and iv(cn/1000000,2).."kT"or iv(cn/1000,2).."T"if cj then of=br else of=bp end;local on,oo=cz.computeDistanceAndTime(cZ,0,cn,0,0,of)if on<0 then on=0 end;of=iv(of/(cn*iC),2).."g"local op=d:maxForceForward()gN=b.g()if gN>0.1 then ol=cn*gN;ol=iv(ol/(cn*iC),2).."g"ok=0.5*op/gN;ok=ok>1000000 and iv(ok/1000000,2).."kT"or iv(ok/1000,2).."T"end;op=iv(op/(cn*iC),2).."g"local oq=vec3(b.getWorldAcceleration()):len()/9.80665;gN=b.g()jK[#jK+1]=[[<g class="dim txt txtend size14">]]if is()==1 and not l then oc=j0(1120)od=j1(55)oe=od+10 elseif cj and I then local os=j0(770)jK[#jK+1]=gW(lC(895),og,"ATMO","")jK[#jK+1]=dv([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lC(895),oi,lC(-80))jK[#jK+1]=gW(lC(815),oh,dv("%.1f%%",ck*100),"txtstart size20")end;if I then jK[#jK+1]=gW(lC(1025),og,"GRAVITY","txtstart")jK[#jK+1]=dv([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(1025),oi,lC(80))jK[#jK+1]=gW(lC(1105),oh,dv("%.2fg",gN/9.80665),"size20")jK[#jK+1]=gW(lC(1125),og,"ACCEL","txtstart")jK[#jK+1]=dv([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(1125),oi,lC(80))jK[#jK+1]=gW(lC(1205),oh,dv("%.2fg",oq),"size20")jK[#jK+1]=gW(lC(695),og,"BRK TIME","")jK[#jK+1]=dv([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(695),oi,lC(-80))jK[#jK+1]=gW(lC(615),oh,dv("%s",iz(oo)),"txtstart size20")jK[#jK+1]=gW(lC(635),lD(45),"TRIP","")jK[#jK+1]=dv([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(635),lD(31),lC(-90))if lw then jK[#jK+1]=gW(lC(545),lD(26),dv("%s",iz(lw)),"txtstart size20")end;jK[#jK+1]=gW(lC(795),og,"BRK DIST","")jK[#jK+1]=dv([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(795),oi,lC(-80))jK[#jK+1]=gW(lC(715),oh,dv("%s",iy(on)),"txtstart size20")jK[#jK+1]=gW(lC(1285),lD(45),"MASS","txtstart")jK[#jK+1]=dv([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(1285),lD(31),lC(90))jK[#jK+1]=gW(lC(1375),lD(26),dv("%s",om),"size20")jK[#jK+1]=gW(lC(1220),og,"THRUST","txtstart")jK[#jK+1]=dv([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lC(1220),oi,lC(80))jK[#jK+1]=gW(lC(1300),oh,dv("%s",op),"size20")jK[#jK+1]=gW(j0(960),j1(175),j4,"pbright txtbig txtmid size20")end;jK[#jK+1]="</g>"end;local ot=1-(a6*0.05+a7*0.05)function o0.FuelUsed(ou)local ov;if ou=="atmofueltank"then ov=dv("Atmo Fuel Used: %.1f L",jm[ou]/(4*ot))elseif ou=="spacefueltank"then ov=dv("Space Fuel Used: %.1f L",jm[ou]/(6*ot))else ov=dv("Rocket Fuel Used: %.1f L",jm[ou]/(0.8*ot))end;return ov end;function o0.DrawOdometer(jK,c7,bk,c8)if bD~="INFO"then return jK end;local gN;local ok=0;local ol=0;local of=0;local om=cn>1000000 and iv(cn/1000000,2).." kTons"or iv(cn/1000,2).." Tons"if cj then of=br else of=bp end;local on,oo=cz.computeDistanceAndTime(cZ,0,cn,0,0,of)of=iv(of/(cn*iC),2).." g"local op=d:maxForceForward()gN=b.g()if gN>0.1 then ol=cn*gN;ol=iv(ol/(cn*iC),2).." g"ok=0.5*op/gN;ok=ok>1000000 and iv(ok/1000000,2).." kTons"or iv(ok/1000,2).." Tons"end;op=iv(op/(cn*iC),2).." g"if is()==0 or l then local ow=j0(aw+10)local ox=j1(ax+20)local oy=j0(aw+10+av/1.25)local nm=25;jK[#jK+1]="<g class='txtstart size14 bright'>"jK[#jK+1]=gW(ow,ox,dv("BrkTime: %s",iz(oo)))jK[#jK+1]=gW(oy,ox,dv("Trip: %.2f km",c7))jK[#jK+1]=gW(ow,ox+nm,dv("Lifetime: %.2f kSU",bk/200000))jK[#jK+1]=gW(oy,ox+nm,dv("BrkDist: %s",iy(on)))jK[#jK+1]=gW(ow,ox+nm*2,"Trip Time: "..iz(c8))jK[#jK+1]=gW(oy,ox+nm*2,"Total Time: "..iz(bl))jK[#jK+1]=gW(ow,ox+nm*3,dv("Mass: %s",om))jK[#jK+1]=gW(oy,ox+nm*3,dv("Max Brake: %s",of))jK[#jK+1]=gW(ow,ox+nm*4,dv("Max Thrust: %s",op))if gN>0.1 then jK[#jK+1]=gW(oy,ox+nm*4,dv("Max Thrust Mass: %s",ok))jK[#jK+1]=gW(ow,ox+nm*5,dv("Req Thrust: %s",ol))else jK[#jK+1]=gW(oy,ox+nm*4,"Max Mass: n/a")jK[#jK+1]=gW(ow,ox+nm*5,"Req Thrust: n/a")end;jK[#jK+1]=gW(oy,ox+nm*5,cC.FuelUsed("atmofueltank"))jK[#jK+1]=gW(ow,ox+nm*6,cC.FuelUsed("spacefueltank"))jK[#jK+1]=gW(oy,ox+nm*6,cC.FuelUsed("rocketfueltank"))if cZ>833 then local oz=cn/math.sqrt(1-(cZ/8333.33)^2)local om=oz>1000000 and iv(oz/1000000,2).." kTons"or iv(oz/1000,2).." Tons"jK[#jK+1]=gW(oy,ox+nm*7,dv("Rel. Mass: %s",om))end end;jK[#jK+1]="</g></g>"return jK end;function o0.DrawWarnings(jK)return kY(jK)end;function o0.DisplayOrbitScreen(jK)return lW(jK)end;function o0.DisplayMessage(jK,lj)if lj~="empty"then local hx=310;for oA in string.gmatch(lj,"([^\n]+)")do hx=hx+35;jK[#jK+1]=gW("50%",hx,oA,"msg")end end;if cc~=0 then c.setTimer("msgTick",cc)cc=0 end end;function o0.DrawDeadZone(jK)jK[#jK+1]=dv([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function o0.UpdatePipe()if cj then iM=""return end;nb()end;function o0.DrawSettings(jK)local hw=j0(640)local hx=j1(200)jK[#jK+1]=[[<g class="pbright txtvspd txtstart">]]local h_=0;for dV,dH in pairs(iL)do h_=h_+1;jK[#jK+1]=gW(hw,hx,dV..": "..dH.get())hx=hx+20;if h_%12==0 then hw=hw+j0(350)hx=j1(200)end end;jK[#jK+1]=gW(j0(640),j1(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jK[#jK+1]="</g>"return jK end;local ig=j0(1770)local ih=j1(350)local ie=j1(15)local id=j0(1370)local ik,oB;function o0.DrawRadarInfo()ij=cF.GetRadarHud(id,ie,ig,ih)end;function o0.DrawTanks()if aq~=0 and ar~=0 then j5=gW(aq,ar,"","txtstart pdim txtfuel")jn=ar;jo(aq,"Atmospheric ","ATMO",cu,jk,jl)jo(aq,"Space Fuel T","SPACE",cv,ji,jj)jo(aq,"Rocket Fuel ","ROCKET",cw,jg,jh)end end;function o0.DrawShield()local oC=io.getState()==1 and"Shield Active"or"Shield Disabled"local oD=b.getPvPTimer()local oE=io.getResistances()local oF="A: "..10+oE[1]*100 .."% / E: "..10+oE[2]*100 .."% / K:"..10+oE[3]*100 .."% / T: "..10+oE[4]*100 .."%"local hw,hx=as-60,at+30;local oG=bG(0.5+io.getShieldHitpoints()*100/io.getMaxShieldHitpoints())local jC=bG(oG*2.55)local jD=dv("rgb(%d,%d,%d)",255-jC,jC,0)local jE=""j6=gW(hw,hx,"","txtmid pdim txtfuel")if oG<10 and oC~="Shield Disabled"then jE="red "end;oD=oD>0 and"   PvPTime: "..iz(oD)or""j6=j6 ..dv([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hw,hx,jD,oG*2,hw,hx,hw+2,hx+10,oG,oD)j6=j6 ..gW(hw,hx-5,oC,jE.."txtstart pbright txtbig")j6=j6 ..gW(hw,hx+30,oF,jE.."txtstart pbright txtsmall")end;function o0.hudtick()if not i_ then return end;local function oH(jK)local jG=bG(dw(cd/(cs/4)*255,0,255))jK[#jK+1]=dv("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ca,cb,bG(bJ+0.5)+jG,bG(bL+0.5)-jG,bG(bK+0.5)-jG)end;local function oI()for d_,dH in pairs(iD)do if dH.hovered then if not dH.drawCondition or dH.drawCondition(dH)then dH.toggleFunction(dH)end;dH.hovered=false end end;for d_,dH in pairs(iG)do if dH.hovered then bD=dH.label;dH.hovered=false end end end;local function oJ()local function oK(oL,oM,hw,hx,nl,nm)if oL>=hw and oL<=hw+nl and oM>=hx and oM<=hx+nm then return true else return false end end;local hw=ca+cs/2;local hx=cb+ct/2;for d_,dH in pairs(iD)do dH.hovered=oK(hw,hx,dH.x,dH.y,dH.width,dH.height)end;for d_,dH in pairs(iG)do dH.hovered=oK(hw,hx,dH.x,dH.y,dH.width,dH.height)end;if dg then local n0=false;for d_,eO in ipairs(nX)do if eO.hovered then n0=true;break end end;if nU.hovered then n0=true end;dg=n0 else dg=nU.hovered;if not dg then dh=bi end end end;local function oN(jK)if not bD or bD==""then bD="HELP"end;if x then for dV,dH in pairs(iG)do local jE="dim brightstroke"local oO=0.2;if bD==dV then jE="pbright dimstroke"oO=0.6 end;local oP=""if dH.hovered then oO=0.8;oP=";stroke:white"end;jK[#jK+1]=dv([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dH.width,dH.height,dH.x,dH.y,jE,oO,oP)jK[#jK+1]=gW(dH.x+dH.width/2,dH.y+dH.height/2+5,dH.label,"txt txtmid pdim")end end end;local function oQ(jK)local function oR(jK,oS,hover,hw,hx,fu,oT,oU,oV,oW,oX,nY)if type(oW)=="function"then oW=oW(nY)end;if type(oX)=="function"then oX=oX(nY)end;jK[#jK+1]=dv("<rect x='%f' y='%f' width='%f' height='%f' fill='",hw,hx,fu,oT)if oS then jK[#jK+1]=dv("%s'",oU)else jK[#jK+1]=oV end;if hover then jK[#jK+1]=dv(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jK[#jK+1]=dv(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",iv(ac*0.5,0),iv(ad*0.5,0),iv(ae*0.5,0))end;jK[#jK+1]=" rx='5'></rect>"jK[#jK+1]=dv("<text x='%f' y='%f' font-size='24' fill='",hw+fu/2,hx+oT/2+5)if oS then jK[#jK+1]="black"else jK[#jK+1]="white"end;jK[#jK+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oS then jK[#jK+1]=dv("%s</text>",oW)else jK[#jK+1]=dv("%s</text>",oX)end end;local oY=dv("rgb(%d,%d,%d)'",iv(ac*0.1,0),iv(ad*0.1,0),iv(ae*0.1,0))local oZ=dv("rgb(%d,%d,%d)",iv(ac*0.8,0),iv(ad*0.8,0),iv(ae*0.8,0))local o_=oR;for d_,dH in pairs(iD)do local nq=dH.disableName;local np=dH.enableName;if type(nq)=="function"then nq=nq(dH)end;if type(np)=="function"then np=np(dH)end;if not dH.drawCondition or dH.drawCondition(dH)then o_(jK,dH.toggleVar(dH),dH.hovered,dH.x,dH.y,dH.width,dH.height,oZ,oY,nq,np,dH)end end end;local p0=iv(cs/2,0)local p1=iv(ct/2,0)local jK={}cC.HUDPrologue(jK)if x then cC.UpdateHud(jK)else if B then cC.DrawVerticalSpeed(jK,cl)end;cC.DrawWarnings(jK)end;if iK and iL~="none"then cC.DrawSettings(jK)end;if radar_1 then cC.DrawRadarInfo()end;cC.HUDEpilogue(jK)jK[#jK+1]=dv([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cs,ct)if c2~="empty"then cC.DisplayMessage(jK,c2)end;if is()==0 and g=="virtual joystick"then if w then cC.DrawDeadZone(jK)end end;oN(jK)if iu()==0 then if is()==1 and c1 then if not p2 then oJ()oQ(jK)end;if not cH and not cI then local p3=table.concat(jK,"")jK={}jK[#jK+1]=dv("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cs,ct)jK[#jK+1]=p3;jK[#jK+1]="</body>"cH=true;jK[#jK+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local p4=table.concat(jK,"")a.setScreen(p4)elseif cI then local p3=table.concat(jK,"")jK={}jK[#jK+1]=dv("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cs,ct)jK[#jK+1]=p3;jK[#jK+1]="</body>"end;if not cH then jK[#jK+1]=dv([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p0,p1,ca,cb)end else oI()end else if not c1 and is()==0 then oI()if cd>au then if w then oH(jK)end end elseif c1 and(not p2 or not i)then oJ()oQ(jK)end;jK[#jK+1]=dv([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p0,p1,ca,cb)end;jK[#jK+1]=[[</svg></body>]]p4=table.concat(jK,"")end;function o0.TenthTick()local function p5()local p6=a.createData;local p7=a.createWidget;p8=a.createWidgetPanel("Interplanetary Helper")p9=p7(p8,"value")pa=p6('{"label": "Target Planet", "value": "N/A", "unit":""}')g4(pa,p9)pb=p7(p8,"value")pc=p6('{"label": "distance", "value": "N/A", "unit":""}')g4(pc,pb)gx=p7(p8,"value")gw=p6('{"label": "Travel Time", "value": "N/A", "unit":""}')g4(gw,gx)gv=p7(p8,"value")gu=p6('{"label": "Maximum Mass", "value": "N/A", "unit":""}')g4(gu,gv)gz=p7(p8,"value")gy=p6('{"label": "Target Altitude", "value": "N/A", "unit":""}')g4(gy,gz)gr=p7(p8,"value")gq=p6('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gp=p7(p8,"value")go=p6('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gn=p7(p8,"value")gm=p6('{"label": "Max Brake distance", "value": "N/A", "unit":""}')gl=p7(p8,"value")gk=p6('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gt=p7(p8,"value")gs=p6('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cj then g4(gq,gr)g4(go,gp)g4(gm,gn)g4(gk,gl)g4(gs,gt)end end;local function pd()gV(p8)p8=nil end;local function pe()if not b0 then if gg==nil or gg.planetname~=i_.name then pf=(c6.center-d1):len()else pf=(gg.position-d1):len()end end;local fB=cZ;local pg=c.getThrottle()/100;if u then pg=bM end;local ph,pi=cz.computeDistanceAndTime(cZ,a0,cn,d:maxForceForward()*pg,a2,0)local c4,c5;if not b1 then c4,c5=cE.GetAutopilotBrakeDistanceAndTime(a0)else c4,c5=cE.GetAutopilotTBBrakeDistanceAndTime(a0)end;local d_,pj;if not b1 and fB>0 then d_,pj=cE.GetAutopilotBrakeDistanceAndTime(fB)else d_,pj=cE.GetAutopilotTBBrakeDistanceAndTime(fB)end;local pk=0;local pl=0;if bb or not b0 and fB>5 then pl=cz.computeTravelTime(fB,0,pf)elseif c4+ph<pf then pk=pf-(c4+ph)pl=cz.computeTravelTime(8333.0556,0,pk)else local pm=(pf-c4)/ph;ph=pf-c4;pi=pi*pm end;if gg~=nil and gg.planetname==i_.name and not b0 then return pl elseif ba then return pj elseif bb then return pl+pj else return pi+c5+pl end end;cC.DrawTanks()if io then cC.DrawShield()end;if bg~="None"then if p8==nil then p5()end;if bg~=nil then local pn=gg~=nil;local po=0.5*br/c6:getGravity(c6.center+vec3(0,0,1)*c6.radius):len()po=po>1000000 and iv(po/1000000,2).." kTons"or iv(po/1000,2).." Tons"g3(pa,'{"label": "Target", "value": "'..bg..'", "unit":""}')lw=pe()if pn and not b0 then cd=(d1-gg.position):len()else cd=(bh-d1):len()end;if not b1 then c4,c5=cE.GetAutopilotBrakeDistanceAndTime(cZ)iO,iP=cE.GetAutopilotBrakeDistanceAndTime(a0)else c4,c5=cE.GetAutopilotTBBrakeDistanceAndTime(cZ)iO,iP=cE.GetAutopilotTBBrakeDistanceAndTime(a0)end;local lj=iy(cd)g3(pc,'{"label": "distance", "value": "'..lj..'"}')g3(gw,'{"label": "Travel Time", "value": "'..iz(lw)..'", "unit":""}')lj=iy(c4)g3(gq,'{"label": "Cur Brake distance", "value": "'..lj..'"}')g3(go,'{"label": "Cur Brake Time", "value": "'..iz(c5)..'", "unit":""}')lj=iy(iO)g3(gm,'{"label": "Max Brake distance", "value": "'..lj..'"}')g3(gk,'{"label": "Max Brake Time", "value": "'..iz(iP)..'", "unit":""}')g3(gu,'{"label": "Max Brake Mass", "value": "'..dv("%s",po)..'", "unit":""}')lj=iy(gA)g3(gy,'{"label": "Target Orbit", "value": "'..lj..'"}')if ck>0 and not pp then a.removeDataFromWidget(gk,gl)a.removeDataFromWidget(gm,gn)a.removeDataFromWidget(go,gp)a.removeDataFromWidget(gq,gr)a.removeDataFromWidget(gs,gt)pp=true;if not d5 and u and(b2 or b5 or ch)then cE.cmdThrottle(1)aY=false;bQ=false end end;if ck==0 and pp then if g3(gk,gl)==1 then g4(gk,gl)end;if g3(gm,gn)==1 then g4(gm,gn)end;if g3(go,gp)==1 then g4(go,gp)end;if g3(gq,gr)==1 then g4(gq,gr)end;if g3(gs,gt)==1 then g4(gs,gt)end;pp=false end end else pd()end;if warpdrive~=nil then if iq(warpdrive.getData()).destination~="Unknown"and iq(warpdrive.getData()).distance>400000 then warpdrive.show()pq=true else warpdrive.hide()pq=false end end end;function o0.OneSecondTick()local function pr()local jy=bF()local kV=cZ;local ps=jy-cm;if kV>1.38889 then kV=kV/1000;local pt=kV*(jy-cm)bk=bk+pt;c7=c7+pt end;c8=c8+ps;bl=bl+ps;cm=jy end;local function pu(jK)local pv=0;iQ=""local pw=iB;local px=0;local py=0;local pz=0;local jC=0;local jD=""local pA=b.getElementHitPointsById;local pB=b.getElementMaxHitPointsById;local pC={}for dV in pairs(iA)do local pD=0;local pE=0;pE=pB(iA[dV])pD=pA(iA[dV])px=px+pD;if pD<pE then if pD==0 then pz=pz+1 else py=py+1 end;if cx and#pC==0 then g7=vec3(b.getElementPositionById(iA[dV]))local hw=g7.x;local hx=g7.y;local hy=g7.z;table.insert(pC,b.spawnArrowSticker(hw,hx,hy+1,"down"))table.insert(pC,b.spawnArrowSticker(hw,hx,hy+1,"down"))b.rotateSticker(pC[2],0,0,90)table.insert(pC,b.spawnArrowSticker(hw+1,hx,hy,"north"))table.insert(pC,b.spawnArrowSticker(hw+1,hx,hy,"north"))b.rotateSticker(pC[4],90,90,0)table.insert(pC,b.spawnArrowSticker(hw-1,hx,hy,"south"))table.insert(pC,b.spawnArrowSticker(hw-1,hx,hy,"south"))b.rotateSticker(pC[6],90,-90,0)table.insert(pC,b.spawnArrowSticker(hw,hx-1,hy,"east"))table.insert(pC,b.spawnArrowSticker(hw,hx-1,hy,"east"))b.rotateSticker(pC[8],90,0,90)table.insert(pC,b.spawnArrowSticker(hw,hx+1,hy,"west"))table.insert(pC,b.spawnArrowSticker(hw,hx+1,hy,"west"))b.rotateSticker(pC[10],-90,0,90)table.insert(pC,iA[dV])end elseif cx and#pC>0 and pC[11]==iA[dV]then for jx in pairs(pC)do b.deleteSticker(pC[jx])end;pC={}end end;pv=bG(px/pw*100)if pv<100 then jK[#jK+1]=gW(0,0,"","pbright txt")jC=bG(pv*2.55)jD=dv("rgb(%d,%d,%d)",255-jC,jC,0)if pv<100 then jK[#jK+1]=gW("50%",1035,"Elemental Integrity: "..pv.."%","txtbig txtmid","fill:"..jD)if pz>0 then jK[#jK+1]=gW("50%",1055,"Disabled Modules: "..pz.." Damaged Modules: "..py,"txtbig txtmid","fill:"..jD)elseif py>0 then jK[#jK+1]=gW("50%",1055,"Damaged Modules: "..py,"txtbig txtmid","fill:"..jD)end end end end;local function pF()if ip then if iR==nil and(dp~=nil or bj)then _autoconf.displayCategoryPanel(ip,weapon_size,"Weapons","weapon",true)iR=_autoconf.panels[_autoconf.panels_size]elseif iR~=nil and dp==nil and not bj then gV(iR)iR=nil end end end;di=b.getPlayersOnBoard()dj=b.getDockedConstructs()local jK={}pr()if s then pu(jK)end;pF()cC.UpdatePipe()cC.ExtraData(jK)ce=table.concat(jK,"")collectgarbage("collect")end;function o0.AnimateTick()cI=true;cH=false;ca=0;cb=0;c.stopTimer("animateTick")end;function o0.MsgTick()local jK={}cC.DisplayMessage(jK,"empty")c2="empty"c.stopTimer("msgTick")cc=3 end;function o0.ButtonSetup()nB()nG()iD=iE end;return o0 end;local function pG(d,b,c,a,e,vBooster,hover,pH,antigrav,warpdrive,dbHud_1,f9,bG,bH,is,f4,bF,dw,it,g3,iu,dy,iv,g5,iw,dz,iy,iz,pI,iq,dv,g4)local pJ={}local function pK(fB)local pL=bc;if not b0 then pL=0 end;if not cj then return cz.computeDistanceAndTime(fB,pL,cn,0,0,bp-be*cn)else if br and br>0 then return cz.computeDistanceAndTime(fB,pL,cn,0,0,br-be*cn)else return 0,0 end end end;local function pM(fB)local pL=bc;if not b0 then pL=0 end;return cz.computeDistanceAndTime(fB,pL,cn,d:maxForceForward(),a2,bp-be*cn)end;local pN=false;local pO=0;local pP=0;local pQ=0;local pR=bF()local pS=0;local pT=0;local pU=0;local pV=0;local pW=false;local pX=false;local pY=false;local pZ=nil;local p_=0;local q0={}local iN=55;local q1=nil;local q2=""function pJ.GetAutopilotBrakeDistanceAndTime(fB)return pK(fB)end;function pJ.GetAutopilotTBBrakeDistanceAndTime(fB)return pM(fB)end;local function q3(q4,q5,q6)q5=q5:project_on_plane(q4)q6=q6:project_on_plane(q4)return f4(q5:cross(q6):dot(q4),q5:dot(q6))end;local function q7()local function q8()local q9=-1;local qa=-1;if vBooster then q9=vBooster.getDistance()end;if hover then qa=hover.getDistance()end;if q9~=-1 and qa~=-1 then if q9<qa then return q9 else return qa end elseif q9~=-1 then return q9 elseif qa~=-1 then return qa else return-1 end end;local qb=q8()local qc=-1;if pH then qc=pH.getDistance()end;if qb~=-1 and qc~=-1 then if qb<qc then return qb else return qc end elseif qb~=-1 then return qb else return qc end end;local function qd(i_,eW,qe)local function qf(qg,e6)local f1=vec3(e6)if qg.id==0 then return setmetatable({latitude=f1.x,longitude=f1.y,altitude=f1.z,id=0,systemId=qg.systemId},e8)end;local f2=f1-qg.center;local cd=f2:len()local ee=cd-qg.radius;local ec=0;local ed=0;if not dz(cd,0)then local f3=f4(f2.y,f2.x)ed=f3>=0 and f3 or 2*math.pi+f3;ec=math.pi/2-math.acos(f2.z/cd)end;return setmetatable({latitude=math.deg(ec),longitude=math.deg(ed),altitude=ee,id=qg.id,systemId=qg.systemId},e8)end;local qh=qf(i_,eW)qh="::pos{"..qh.systemId..","..qh.id..","..qh.latitude..","..qh.longitude..","..qh.altitude.."}"if qe then return qh else a.setWaypoint(qh)return true end end;local qi=false;function pJ.showWayPoint(i_,eW,qe)return qd(i_,eW,qe)end;function pJ.APTick()local function qj()if df and not b3 then local eD=df[1]local i4,i5=df[2],df[3]local qk=math.min(i4,i5 or i4)local ql=qk/cZ;local qm=b4 and(cZ<42 or ci~=-1)local qn=b2 or bn or bq or b0;if qn and not qm and(c4*1.5>qk or ql<1)then aY=true;q0={}cE.cmdThrottle(0)if b2 then cE.ToggleAltitudeHold()end;if bq then cE.ToggleLockPitch()end;c2="Autopilot Cancelled due to possible collision"if bn or b0 then cE.ToggleAutopilot()end;lq=true;b3=true;cJ=true end;if ql<11 then de=eD.name.." COLLISION "..iz(ql).." / "..iy(qk,2)else de=eD.name.." collision "..iz(ql)end;if ql<6 then g5("alarm","AL",2)end else de=false end end;local function qo(qp,qq,qr)local function qs(qp,eF)qp=vec3(qp)eF=vec3(eF):normalize()local dQ=qp*eF;return dQ.x+dQ.y+dQ.z end;local qt=0.001;local qu=1;if not cj or not cK or ci~=-1 or cZ<iN then if qr==nil then qr=aO end;if qq==nil then qq=qt end;qp=vec3(qp):normalize()local qv=vec3()-qp;local qw=-qs(qv,b.getConstructWorldOrientationRight())*qu;local qx=-qs(qv,b.getConstructWorldOrientationUp())*qu;if pP==0 then pP=qw/2 end;if pQ==0 then pQ=qx/2 end;if f9(qw)<0.1 then bW=bW-qw*2 else bW=bW-(qw+(qw-pP)*qr)end;if f9(qx)<0.1 then bV=bV+qx*2 else bV=bV+qx+(qx-pQ)*qr end;pP=qw;pQ=qx;if f9(qw)<qq and f9(qx)<qq then return true end;return false elseif cK and ci==-1 then qp=cY;if qr==nil then qr=aO end;if qq==nil then qq=qt end;qp=vec3(qp):normalize()local qv=cV-qp;local qw=-qs(qv,b.getConstructWorldOrientationRight())*qu;local qx=-qs(qv,b.getConstructWorldOrientationUp())*qu;if pP==0 then pP=qw/2 end;if pQ==0 then pQ=qx/2 end;if f9(qw)<0.1 then bW=bW-qw*5 else bW=bW-(qw+(qw-pP)*qr)end;if f9(qx)<0.1 then bV=bV+qx*5 else bV=bV+qx+(qx-pQ)*qr end;pP=qw;pQ=qx;if f9(qw)<qq and f9(qx)<qq then return true end;return false end end;cj=bH()>0;ck=bH()cl=b.getAltitude()ci=q7()bI=bF()pR=bI;if F then qj()end;if antigrav then d3=antigrav.getState()==1 end;local qy=a.getMouseWheel()if qy>0 then cE.changeSpd()elseif qy<0 then cE.changeSpd(true)else co=true end;local qz=1;local qA=1;local qB=bI-pR;local qC=-math.deg(q3(cU,cY,cV))local qD=math.deg(q3(cW,cY,cV))local gC=c_*-1;cK=cj and qC<-M or qC>M or qD<-N or qD>N;local qE=a.getMouseDeltaX()local qF=a.getMouseDeltaY()if o and not c1 then qF=-qF end;bW=0;b_=0;bV=0;g8=cy[0]i_=g8:closestBody(b.getConstructWorldPos())qG=cB(i_)fF=qG:orbitalParameters(b.getConstructWorldPos(),cY)if cl==0 then cl=(d1-i_.center):len()-i_.radius end;dd=c.getClosestPlanetInfluence()>0 or cl>0 and cl<200000;local gN=i_:getGravity(b.getConstructWorldPos()):len()*cn;cL=0;cA=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if iu()==0 then if is()==1 and c1 then if not cH then ca=dw(ca+qE,-cs/2,cs/2)cb=dw(cb+qF,-ct/2,ct/2)end else ca=0;cb=0 end else ca=dw(ca+qE,-cs/2,cs/2)cb=dw(cb+qF,-ct/2,ct/2)cd=dy(ca*ca+cb*cb)if not c1 and is()==0 then local kH,kI=1,1;if bD=="SCOPE"then kH,kI=dl/90,dl/90 end;if g=="virtual joystick"then if ca>0 and ca>au then bW=bW-(ca-au)*aC*kH elseif ca<0 and ca<au*-1 then bW=bW-(ca+au)*aC*kH else bW=0 end;if cb>0 and cb>au then bV=bV-(cb-au)*aD*kI elseif cb<0 and cb<au*-1 then bV=bV-(cb+au)*aD*kI else bV=0 end else ca=0;cb=0;if g=="mouse"then bV=(-utils.smoothstep(qF,-100,100)+0.5)*2*qz;bW=(-utils.smoothstep(qE,-100,100)+0.5)*2*qA end end end end;local qH=cZ>8334;if cZ>W/3.6 and not cj and not b0 and not qH then c2="Space Speed Engine Shutoff reached"cE.cmdThrottle(0)end;if not qH and qI then if not aY then cE.BrakeToggle()end;if b0 then cE.ToggleAutopilot()end end;qI=qH;if cj and ck>0.09 then if cZ>cM/3.6 and not u and not pN then aY=true;pN=true elseif not u and pN then if cZ<cM/3.6 then aY=false;pN=false end end end;if aY then bZ=1 else bZ=0 end;if a_ then if cf then aY=false;local qJ=false;if gg and cf==true then qJ=qo(gg.position-d1,0.1)else qJ=qo(vec3(cY),0.01)end;cJ=true;if qJ then cE.cmdCruise(bG(cM))if(f9(d7)<2 or f9(d6)>85)and cZ>=cM/3.6-1 then aY=false;a_=false;if cf~=2 then bS=true end;if cf==true then ch=true end;cf=false;b0=false;cE.BeginReentry()end elseif cj and u then cE.cmdThrottle(1)end elseif cZ>iN then qo(vec3(cY),0.01)end end;if aZ then if cj then aZ=false elseif cZ>iN then qo(-vec3(cY))end end;if not a_ and cf and not bw then if ck==0 then if cf~=2 then bS=true end;cE.BeginReentry()cf=false;ch=true else cf=false;cE.ToggleAutopilot()end end;if ch and gg and(cl<b7+250 and cl>b7-250)and cZ*3.6>cM-250 and f9(d0)<25 and ck>=0.1 and(gg.position-d1):len()>2000+cl then cE.ToggleAutopilot()ch=false end;if b6 then cJ=true;local qK=b7;if d0<-30 then c2="Unable to achieve lift. Safety Landing."c9=0;cJ=p;b6=false;b3=true elseif not q and d3 or b7<i_.spaceEngineMinAltitude then if d3 then qK=antigrav.getBaseAltitude()end;if cl<qK-100 then cN=0;c9=15;aY=false elseif d0>0 then aY=true;c9=0 elseif d0<-30 then aY=true;c9=15 elseif cl>=qK then if d3 then if b0 or bn then cE.ToggleVerticalTakeoff()else aY=true;b6=false end;c2="Takeoff complete. Singularity engaged"g5("aggLk","AG")else aY=false;c2="VTO complete. Engaging Horizontal Flight"g5("vtoc","VT")cE.ToggleVerticalTakeoff()end;c9=0 end else if ck>0.08 then cN=0;aY=false;c9=20 elseif ck<0.08 and ck>0 then aY=false;if cS then cN=0;c9=20 else c9=0;cN=36;cE.cmdCruise(3500)end else cJ=p;bw=true;cR=false;qL=false;pW=false;pU=nil;pV=nil;if pZ==nil then pZ=i_ end;cQ=qK;pY=true;b6=false end end;if cN~=nil then if qM==nil then qM=pid.new(2*0.01,0,2*0.1)end;local qN=dw(cN-d6,-N*0.80,N*0.80)qM:inject(qN)local qO=dw(qM:get(),-1,1)bV=qO end end;if bw then local qv;local qP=false;local qQ=iy(cQ)if pZ==nil then pZ=i_;if bn then pZ=c6 end end;if not pY then cQ=bG(pZ.radius+pZ.surfaceMaxAltitude+U)if pZ.hasAtmosphere then cQ=bG(pZ.radius+pZ.noAtmosphericDensityAltitude+U)end;pY=true end;if cP.VectorToTarget and gg then qv=gg.position-d1 end;local qR,qS=cB(pZ):escapeAndOrbitalSpeed((d1-pZ.center):len()-pZ.radius)local qT=d7;if not pW then local qU=false;local qV=false;cE.cmdThrottle(0)pV=0;cO="Aligning to orbital path - OrbitHeight: "..qQ;if cP.VectorToTarget then qo(qv:normalize():project_on_plane(c_))qP=cV:dot(qv:project_on_plane(cU):normalize())>0.95 else qo(cY)qP=qC<0.5;if cZ<150 then qP=true end end;bV=0;pU=0;if d6<=pU+2 and d6>=pU-2 then qU=true else qU=false end;if qT<=pV+2 and qT>=pV-2 then qV=true else qV=false end;if qU and qV and qP then pU=nil;pV=nil;pW=true end else if cP.VectorToTarget then qo(qv:normalize():project_on_plane(c_))elseif cZ>150 then qo(cY)end;bV=0;if cP.VectorToTarget and gg then local c4,d_=cz.computeDistanceAndTime(cZ,cM/3.6,cn,0,0,bp)if cR and qv:len()>15000+c4+cl then cO="Orbiting to Target"if cl-100<=pZ.noAtmosphericDensityAltitude or lw>fF.timeToPeriapsis and fF.periapsis.altitude<pZ.noAtmosphericDensityAltitude then cR=false end elseif cR or qv:len()<15000+c4+cl then c2="Orbit complete, proceeding with reentry"g5("orCom","OB")bh=gg.position;bS=true;ch=true;cP.VectorToTarget,cP.AutopilotAlign=false,false;cE.ToggleIntoOrbit()cE.BeginReentry()return end end;if fF.periapsis~=nil and fF.apoapsis~=nil and fF.eccentricity<1 and cl>cQ*0.9 and cl<cQ*1.4 then if fF.apoapsis~=nil then if fF.periapsis.altitude>=cQ*0.99 and fF.apoapsis.altitude>=cQ*0.99 and fF.periapsis.altitude<fF.apoapsis.altitude and fF.periapsis.altitude*1.05>=fF.apoapsis.altitude or cR then if cR then aY=false;cE.cmdThrottle(0)pU=0;if not cP.VectorToTarget then c2="Orbit complete"g5("orCom","OB")cE.ToggleIntoOrbit()end else p_=p_+1;if p_>=2 then cR=true end end else cO="Adjusting Orbit - OrbitHeight: "..qQ;pX=true;cE.cmdCruise(qS*3.6+1)local qW=cQ-cl;if qX==nil then qX=pid.new(0.1,0,1*0.1)end;qX:inject(qW-d0*dw(utils.smoothstep(2000-qW,-2000,2000)^6*10,1,10))pU=dw(qX:get(),-60,60)end end else local qY=2.75;local qZ=f9(iv(qR*qY))local ot=qZ%50;if ot>0 then qZ=qZ-ot+50 end;aY=false;if cl<cQ*0.8 then cO="Escaping planet gravity - OrbitHeight: "..qQ;pU=utils.map(d0,200,0,-15,80)elseif cl>=cQ*0.8 and cl<cQ*1.15 then cO="Approaching orbital corridor - OrbitHeight: "..qQ;qZ=qZ*0.75;pU=utils.map(d0,100,-100,-15,65)elseif cl>=cQ*1.15 and cl<cQ*1.5 then cO="Approaching orbital corridor - OrbitHeight: "..qQ;qZ=qZ*0.75;if d0<0 or pX then pU=utils.map(cl,cQ*1.5,cQ*1.01,-30,0)else pU=utils.map(cl,cQ*0.99,cQ*1.5,0,30)end elseif cl>cQ*1.5 then cO="Reentering orbital corridor - OrbitHeight: "..qQ;pU=-65;local q_=utils.map(d0,-150,-400,1,0.55)qZ=qZ*q_ end;cE.cmdCruise(bG(qZ))end end;if pU~=nil then if r0==nil then r0=pid.new(1*0.01,0,5*0.1)end;local r1=pU-d6;r0:inject(r1)local r2=dw(r0:get(),-0.5,0.5)bV=r2 end end;if b0 and ck==0 and not cf then local function r3(ik,fF)a.print(ik)aY=false;ba=false;b0=false;r4=false;bd="Aligning"cE.cmdThrottle(0)bR=false;c2=ik;g5("apCom","AP")if fF or cf then if fF and gA~=nil and not cf then if not cl or cl==0 then return end;cQ=cl;pY=true end;cE.ToggleIntoOrbit()end end;local r5,r6=bh,false;if gg and gg.planetname~="Space"then b9=true;if not r4 then local r7=(gg.position-c6.center):normalize()local r8=r7:project_on_plane((c6.center-d1):normalize()):normalize()local r9=c6.center+r8*(c6.radius+gA)local ra=gg.position+(gg.position-c6.center):normalize()*(gA-c6:getAltitude(gg.position))if(d1-r9):len()<(d1-ra):len()then r5=r9 else r5=ra;bc=0 end;bh=r5;cE.showWayPoint(c6,bh)r6=true;r4=true end;be=0 elseif gg and gg.planetname=="Space"then if not r4 then be=0;r6=true;b9=true;r4=true;r5=gg.position+(d1-gg.position):normalize()*S;bh=r5 end elseif gg==nil then be=0;if not r4 then local r7=(d1+cY*100000-c6.center):normalize()local r8=r7:project_on_plane((c6.center-d1):normalize()):normalize()if r8:len()<1 then r7=(d1+cV*100000-c6.center):normalize()r8=r7:project_on_plane((c6.center-d1):normalize()):normalize()end;r5=c6.center+r8*(c6.radius+gA)bh=r5;r4=true;r6=true;b9=true;cE.showWayPoint(c6,bh)end end;pf=(vec3(r5)-d1):len()local lu,eU,eV=cy:getPlanetarySystem(0):castIntersections(d1,cY:normalize(),function(eD)if eD.noAtmosphericDensityAltitude>0 then return eD.radius+eD.noAtmosphericDensityAltitude else return eD.radius+eD.surfaceMaxAltitude*1.5 end end)local lv=eU;if eV~=nil and eU~=nil then lv=math.min(eV,eU)end;if lv~=nil and lv<pf and lu.name==c6.name then pf=lv end;local qJ=true;local rb=(c6.center-(d1+vec3(cY):normalize()*pf)):len()-c6.radius;local lj=iy(rb)g3(gs,'{"label": "Projected Altitude", "value": "'..lj..'"}')local c4,c5;if not b1 then c4,c5=pK(cZ)else c4,c5=pM(cZ)end;if cZ>50 and b8 then local qv=vec3(r5)-d1;local rc=dw(math.deg(q3(cU,cY:normalize(),qv:normalize()))*cZ/500,-90,90)local rd=dw(math.deg(q3(cW,cY:normalize(),qv:normalize()))*cZ/500,-90,90)if f9(rc)<20 and f9(rd)<20 then rc=rc*2;rd=rd*2 end;if f9(rc)<2 and f9(rd)<2 then rc=rc*2;rd=rd*2 end;local qC=-math.deg(q3(cU,cV,cY:normalize()))local qD=-math.deg(q3(cW,cV,cY:normalize()))if re==nil then re=pid.new(2*0.01,0,2*0.1)end;re:inject(rd-qD)local rf=dw(re:get(),-1,1)bV=bV+rf;if rg==nil then rg=pid.new(2*0.01,0,2*0.1)end;rg:inject(rc-qC)local rh=dw(rg:get(),-1,1)bW=bW+rh;r6=true;if f9(rc)>2 or f9(rd)>2 then if bd~="Adjusting Trajectory"then bd="Adjusting Trajectory"g5("apAdj","AP")end else if bd~="Accelerating"then bd="Accelerating"g5("apAcc","AP")end end elseif b8 and cZ<=50 then qo((r5-d1):normalize())end;if rb<gA*1.5 then if gg and gg.planetname=="Space"then bc=0 elseif gg==nil then d_,bc=cB(c6):escapeAndOrbitalSpeed(rb)end end;if b0 and not b8 and not bb and not ba then local lu,lv=cE.checkLOS((bh-d1):normalize())if c6.name~=i_.name then if lu~=nil and c6.name~=lu.name and lv<pf then c2="Collision with "..lu.name.." in "..iy(lv).."\nClear LOS to continue."cc=5;qi=true else qi=false;c2=""end end end;if not qi then if not bb and not ba and not r6 then qJ=qo((r5-d1):normalize())elseif b1 and(ba or bb)then qJ=qo(-vec3(cY):normalize())end end;if b8 then if not bR then aY=false;cE.cmdThrottle(a1)bM=iv(a1,2)bR=true end;local pg=c.getThrottle()if u then pg=bM end;local ri=99999;local oq=-vec3(b.getWorldAcceleration()):dot(cY:normalize())local rj=dw(cY:dot((r5-d1):normalize()),0,cZ)if rj>0 or oq>0 then ri=cz.computeTravelTime(rj,oq,pf-c4)end;if cX:len()>=a0 or pg==0 and bR or a2/4>ri then b8=false;if bd~="Cruising"then g5("apCru","AP")bd="Cruising"end;bb=true;cE.cmdThrottle(0)end;local rk=pf;if rk<=c4 or H and da<=c4+10000 and d9 then if H and da<=c4+10000 and d9 then if da<pO and da>2000 then cE.ToggleAutopilot()c2="Autopilot cancelled to prevent crossing PvP Line"aY=true;pO=da else pO=da;return end end;b8=false;if bd~="Braking"then g5("apBrk","AP")bd="Braking"end;ba=true;cE.cmdThrottle(0)bR=false end elseif ba then if bd~="Orbiting to Target"then aY=true;bZ=1 end;if b1 then cE.cmdThrottle(1,true)end;local d_,qS=cB(c6):escapeAndOrbitalSpeed((d1-i_.center):len()-i_.radius)local qv;if gg then qv=gg.position-d1 end;if gg and gg.planetname=="Space"and cZ<50 then if#q0>0 then aY=false;cE.ToggleAutopilot()cE.ToggleAutopilot()return end;r3("Autopilot complete, arrived at space location")aY=true;bZ=1 elseif gg and gg.planetname~="Space"and cZ<=qS and(fF.apoapsis==nil or fF.periapsis==nil or fF.apoapsis.altitude<=0 or fF.periapsis.altitude<=0)then r3("Autopilot complete, commencing reentry")bh=gg.position;cf=true;cE.showWayPoint(c6,bh)elseif(gg and gg.planetname~="Space"or gg==nil)and fF.periapsis~=nil and fF.periapsis.altitude>0 and fF.eccentricity<1 or bd=="Circularizing"then if bd~="Circularizing"then g5("apCir","AP")bd="Circularizing"end;if cZ<=qS then if gg then if cY:normalize():dot(qv:normalize())>0.4 then if bd~="Orbiting to Target"then g5("apOrb","OB")bd="Orbiting to Target"end;if not rl then aY=false;cE.showWayPoint(c6,gg.position)rl=true end else r3("Autopilot complete, proceeding with reentry")bh=gg.position;cf=true;cE.showWayPoint(c6,gg.position)rl=false end else r3("Autopilot completed, setting orbit",true)bZ=0 end end elseif bd=="Circularizing"then r3("Autopilot complete, fixing Orbit",true)end elseif bb then local rk=pf;if rk<=c4 or H and da<=c4+10000 and d9 then if H and da<=c4+10000 and d9 then if da<pO and da>2000 then cE.ToggleAutopilot()c2="Autopilot cancelled to prevent crossing PvP Line"aY=true;pO=da else pO=da;return end end;b8=false;if bd~="Braking"then g5("apBrk","AP")bd="Braking"end;ba=true end;local pg=c.getThrottle()if u then pg=bM end;if pg>0 then b8=true;if bd~="Accelerating"then bd="Accelerating"g5("apAcc","AP")end;bb=false end else if qJ then if not b9 and gg==nil or not b9 and gg and gg.planetname~="Space"then if not cf then bh=vec3(c6.center)+(gA+c6.radius)*cW;rm=cU;rn=cW end;b9=true elseif qJ and not qi then b8=true;if bd~="Accelerating"then bd="Accelerating"g5("apAcc","AP")end;if not bR then cE.cmdThrottle(a1,true)bM=iv(a1,2)bR=true;aY=false end end end end elseif b0 and(gg~=nil and gg.planetname~="Space"and ck>0)then c2="Autopilot complete, starting reentry"g5("apCom","AP")bh=gg.position;aY=false;ba=false;b0=false;r4=false;bd="Aligning"bZ=0;cE.cmdThrottle(0)bR=false;a_=true;cf=true;cE.showWayPoint(c6,gg.position)end;if c0 then cJ=true;local rd=0;local fH=d1+vec3(c.getMasterPlayerRelativePosition())local ro=fH-d1;local rp=vec3(ro):project_on(cV):len()local rq=vec3(ro):project_on(cW):len()local cd=dy(rp*rp+rq*rq)qo(ro:normalize())local mC=40;local rr=cd<mC;local rs=100;local rt=dw((cd-mC)/2,10,rs)bV=0;local qJ=f9(bW)<0.1;if qJ and cZ<rt and not rr then aY=false;rd=-20 else aY=true;rd=0 end;local ru=0;if f9(rd-d6)>ru then if rv==nil then rv=pid.new(2*0.01,0,2*0.1)end;rv:inject(rd-d6)local rf=rv:get()bV=rf end end;if b2 or b3 or b5 or bn or bq~=nil then local rw=br;if rw then rw=rw*dw(cZ/100,0.1,1)*ck else rw=bp end;if ck<0.01 then rw=bp end;local rx=cV:project_on_plane(c_):normalize():dot(cY)local ry=vec3(b.getWorldAirFrictionAcceleration())local rz=ry:len()*cn;if rx>100 then c4,c5=cz.computeDistanceAndTime(rx,100,cn,0,0,rw)local rA,rB=cz.computeDistanceAndTime(100,0,cn,0,0,rw*0.55)c4=c4+rA else c4,c5=cz.computeDistanceAndTime(rx,0,cn,0,0,rw*0.55)end;local qW=b7-cl-d0;local rC=200+cZ;if b5 or cf then rD=2000+cZ end;local rE=1;if b4 then rE=dw(cZ/100,0.1,1)end;local rd=(utils.smoothstep(qW,-rC,rC)-0.5)*2*P*rE;if not b5 and not cf and not bn and cV:dot(cY:normalize())<0.99 then rd=(utils.smoothstep(qW,-rC*dw(20-19*ck*10,1,20),rC*dw(20-19*ck*10,1,20))-0.5)*2*P*dw(2-ck*10,1,2)*rE end;if not b2 then rd=0 end;if bq~=nil then if dd and not bw then rd=bq else bq=nil end end;cJ=true;local rF=bV;if b5 then local rG=bG(cM)local rH,rI=cz.computeDistanceAndTime(cZ,rG/3.6,cn,0,0,bp-i_.gravity*9.8*cn)rH=rH==-1 and 5000 or rH;local rJ=cl-(i_.noAtmosphericDensityAltitude+rH)local rK=cl>i_.noAtmosphericDensityAltitude+rH*1.35;if rK then rd=Q;if cZ<=rG/3.6 and cZ>rG/3.6-10 and f9(cY:normalize():dot(cV))>0.9 and not d5 then bQ=false;cE.cmdThrottle(1)end elseif(d5 or it:getTargetSpeed(axisCommandId.longitudinal)~=rG)and not rK and not cj then cE.cmdCruise(rG,true)end;if d5 then if cZ>rG/3.6 and not rK then aY=true else aY=false end else aY=false end;if d0>0 then aY=true end;if not bS then rd=-80;if cl<i_.surfaceMaxAltitude+(i_.atmosphereThickness-i_.surfaceMaxAltitude)*0.25 then c2="PARACHUTE DEPLOYED at "..iv(cl,0)b5=false;b3=true;lq=true;cE.cmdThrottle(0)rd=0;cJ=p end elseif i_.noAtmosphericDensityAltitude>0 and rK then cJ=true elseif not rK then if not cj and(d5 or it:getTargetSpeed(axisCommandId.longitudinal)~=rG)then cE.cmdCruise(rG)end;if cZ<rG/3.6+1 then aY=false;bS=false;b5=false;cJ=true end end end;if cZ>iN and not cg and not bn and not b3 and v then qo(vec3(cY))end;if db or(bn or cg)and bi>0 and ck>0.01 then local qv;if db then if type(db)=="table"then qv=db elseif db<3 and db>0 then qv=-c_:cross(cY)*5000 elseif db>=3 then qv=c_:cross(cY)*5000 elseif db<0 then qv=cY*25000 end elseif gg~=nil then qv=gg.position-d1 else qv=c6.center-d1 end;local rc=math.deg(q3(c_:normalize(),cY,qv))*2;local mF=math.rad(f9(d7))if cZ>aH and ck>0.01 then local rL=1000+cZ;local rM=(utils.smoothstep(qW-d0*10,-rL,rL)-0.5)*2*P;local rN=dw(90-rM,0,180)cL=dw(rc*2,-rN,rN)local rO=rc;rc=dw(dw(rc,-M*0.80,M*0.80)*math.cos(mF)+4*(d6-rd)*math.sin(math.rad(d7)),-M*0.80,M*0.80)local rP=1;if cL~=0 then rP=f9(mF/cL)end;rP=(90-dw(f9(cL-d7),0,90))/90;local rQ=rd;if f9(d7)>90 then rQ=-rQ end;rd=rP*dw(dw(rQ*math.cos(mF),-N*0.8,N*0.8)+f9(dw(f9(rO)*math.sin(mF),-N*0.80,N*0.80)),-N*0.80,N*0.80)else cL=0;rc=dw(rc,-M*0.80,M*0.80)end;local rR=qC-rc;if db and f9(rR)<=0.0001 and(type(db)=="table"or type(db)~="table"and db<0 and f9(d7)<1)then if db==-2 then cE.ToggleAltitudeHold()end;db=nil;g5("180Off","BR")return end;if not cK and cZ>aH and ck>0.01 then if rS==nil then rS=pid.new(2*0.01,0,2*0.1)end;rS:inject(rR)local rh=dw(rS:get(),-1,1)bW=bW+rh elseif cj and ci>-1 or cZ<aH then qo(qv)elseif cK and ck>0.01 then if(qC<-M or qC>M)and ck>0.01 then qo(cY)end;if(qD<-N or qD>N)and ck>0.01 then rd=dw(d6-qD,d6-N*0.80,d6+N*0.80)end end;if gg~=nil and not cg then local qK=i_:getAltitude(gg.position)local rJ=qv:project_on_plane(c_):len()lq=true;if not cg and not b5 and rJ<=c4 and(cY:project_on_plane(c_):normalize():dot(qv:project_on_plane(c_):normalize())>0.99 or ly=="Finalizing Approach")then ly="Finalizing Approach"if#q0>0 then cE.ToggleAutopilot()cE.ToggleAutopilot()return end;cE.cmdThrottle(0)if b2 then cE.ToggleAltitudeHold()bn=true end;aY=true elseif not b4 then aY=false end;if ly=="Finalizing Approach"and(rx<0.1 or rJ<0.1 or rT~=nil and rT<rJ)then if not d3 then g5("bklOn","BL")b3=true;ds=true;if gg.heading then dt=gg.heading else dt=nil end end;bn=false;if bg=="STARTINGPOINT"then cD.ClearCurrentPosition()end;ly="Proceeding to Waypoint"de=false end;rT=rJ end elseif bn and ck==0 and b7>i_.noAtmosphericDensityAltitude and not(cg or b5)then if gg~=nil and c6.name==i_.name then local qv=gg.position-d1;local qK=i_:getAltitude(gg.position)local rJ=dy(qv:len()^2-(cl-qK)^2)local rw=br;if rw then c4,c5=cz.computeDistanceAndTime(cZ,0,cn,0,0,rw/2)lq=true;if rJ<=c4+cZ*qB/2 and cY:project_on_plane(c_):normalize():dot(qv:project_on_plane(c_):normalize())>0.99 then if i_.hasAtmosphere then aY=false;a_=false;bS=true;cf=false;ch=true;b0=false;cE.BeginReentry()end end;rT=rJ end end end;if ck==0 and(b2 and b7>i_.noAtmosphericDensityAltitude)and not(cg or bw or b5)then if not cR and not bw then cQ=b7;pY=true;if bn then cP.VectorToTarget=true end;cE.ToggleIntoOrbit()bn=false;pW=true end end;if cK and ck>0.01 and ci==-1 and cZ>aH and ly~="Finalizing Approach"then qo(cY)rd=dw(d6-qD,d6-N*0.80,d6+N*0.80)end;bV=rF;local qc=-1;if b3 then rd=0;if dt then if rx<0.05 and rx>-0.05 then if d0>-O then aY=false else aY=true end;if qo(dt,0.0001)then dt=nil;cJ=p else bV=0;cJ=true end else aY=true end else local rU=false;local rV=30;if cA~=nil and cA>0 then local rW=dw(ck,0.4,2)local rw=br*dw(cZ/100,0.1,1)*rW;local rX=cA*rW+rw-gN;local rY=rw/2-gN;local rZ=cZ-dy(f9(rY/2)*20/(0.5*cn))*utils.sign(rY)if rZ<0 then rZ=0 end;local r_;if cZ>100 then local s0,d_=cz.computeDistanceAndTime(cZ,100,cn,0,0,rw)local s1,d_=cz.computeDistanceAndTime(100,0,cn,0,0,dy(rw))r_=s0+s1 else r_=cz.computeDistanceAndTime(cZ,0,cn,0,0,dy(rw))end;if r_<20 then aY=false else local s2=0;if rZ>100 then local s3,d_=cz.computeDistanceAndTime(rZ,100,cn,0,0,rX)local s4,d_=cz.computeDistanceAndTime(100,0,cn,0,0,cA*rW+dy(rw)-gN)s2=s3+s4 else s2,d_=cz.computeDistanceAndTime(rZ,0,cn,0,0,cA*rW+dy(rw)-gN)end;s2=(s2+15+cZ*qB)*1.1;local s5=gg~=nil and i_:getAltitude(gg.position)>0 and gg.safe;if s5 then local qK=i_:getAltitude(gg.position)local s6=cl-qK-100;local qv=gg.position-d1;local s7=dy(qv:len()^2-(cl-qK)^2)if s7>100 then s5=false elseif s6<=s2 or s2==-1 then aY=true;rU=true else aY=false;rU=true end end;if not s5 and t then if s2>=rV then aY=true else aY=false end;rU=true end end end;if not d5 then cE.cmdThrottle(0)end;it:setTargetGroundAltitude(500)it:activateGroundEngineAltitudeStabilization(500)by=true;qc=ci;if qc>-1 then if(cZ<1 or cY:normalize():dot(c_)<0)and not dt then b3=false;b2=false;bj=true;if bT then d.control.extendLandingGears()g5("grOut","LG",1)end;it:setTargetGroundAltitude(Z)c9=0;aY=true;cJ=p;ds=false else aY=true end elseif lq and cY:normalize():dot(-gC)<0.999 then aY=true;qo()elseif d0<-O and not rU or(rx>0.05 or rx<-0.05)and ds then aY=true elseif not rU then aY=false end end end;if b4 or cg then local lu,eV,eU;if bh~=nil then lu,eV,eU=cy:getPlanetarySystem(0):castIntersections(d1,(bh-d1):normalize(),function(eD)return eD.radius+eD.noAtmosphericDensityAltitude end)end;if d3 then if cl>=b7-50 then b4=false;if not b0 and not bn then aY=true;cE.cmdThrottle(0)end else b7=antigrav.getBaseAltitude()end elseif f9(rd)<15 and cl/b7>0.75 then b4=false;if not cg then if d5 and not u then d.control.cancelCurrentControlMasterMode()end elseif cg and cZ<iN then b0=true;cg=false;b2=false;b4=false;cE.cmdThrottle(0)elseif cg then cE.cmdThrottle(0)aY=true end elseif cg and ck==0 and c6~=nil and(lu==nil or lu.name==c6.name)then b0=true;cg=false;b2=false;b4=false;if not d5 then cE.cmdThrottle(0)end;b8=true end end;local s8=ci>-1;local s9=d6;if(bn or cg or db)and not s8 and cZ>aH and ck>0.01 then local mF=math.rad(f9(d7))s9=d6*f9(math.cos(mF))+qD*math.sin(mF)end;local sa=dw(rd-s9,-N*0.80,N*0.80)if ck<0.01 and bn then sa=dw(rd-s9,-85,P)elseif ck<0.01 then sa=dw(rd-s9,-P,P)end;if f9(d7)<5 or bn or db or b3 or s8 or b2 then if rv==nil then rv=pid.new(5*0.01,0,5*0.1)end;rv:inject(sa)local rf=rv:get()bV=bV+rf end end;if antigrav~=nil and(antigrav and not q and cl<200000)then if bs==nil or bs<1000 then bs=1000 end;if sb~=bs then sb=bs;antigrav.setBaseAltitude(sb)end end end;function pJ.ToggleIntoOrbit()cR=false;pU=nil;pV=nil;p_=0;if ck==0 then if bw then g5("orOff","AP")bw=false;pW=false;pZ=nil;cJ=p;if b2 then b2=false;b4=false end;cP.VectorToTarget=false;cP.AutopilotAlign=false;pY=false elseif dd then g5("orOn","AP")bw=true;cJ=true;if pZ==nil then pZ=i_ end;if b2 then b2=false;b4=false end else c2="Unable to engage auto-orbit, not near a planet"end else bw=false;pW=false;pZ=nil;cJ=p;if b2 then b2=false end;cP.VectorToTarget=false;cP.AutopilotAlign=false;pY=false end end;function pJ.ToggleVerticalTakeoff()b2=false;if b6 then lq=true;b5=false;b4=false;b3=true;cJ=true;c9=0;if cj and ci==-1 then b3=false;b2=true;c9=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cE.cmdCruise(bG(cM))end else cR=false;bj=false;d.control.retractLandingGears()it:setTargetGroundAltitude(Y)aY=true end;b6=not b6 end;function pJ.checkLOS(qp)local lu,eU,eV=cy:getPlanetarySystem(0):castIntersections(d1,qp,function(eD)if eD.noAtmosphericDensityAltitude>0 then return eD.radius+eD.noAtmosphericDensityAltitude else return eD.radius+eD.surfaceMaxAltitude*1.5 end end)local lv=eU;if eV~=nil and eU~=nil then lv=math.min(eV,eU)end;if lv~=nil then return lu,lv else return nil,nil end end;function pJ.ToggleAutopilot()local function sc(bu)de=false;bn=not bn;if bn then b1=false;if not b2 and not bu then cE.ToggleAltitudeHold()end end;ly="Proceeding to Waypoint"end;local function sd(gJ)if gJ then for L,dV in pairs(d8)do if dV.name and dV.name==gJ then return L end end else return 0 end end;local se=false;if bI-pT<1.5 and ck>0 then if not cT then c2="No space engines detected, Orbital Hop not supported"return end;if i_.hasAtmosphere then if ck>0 then b7=i_.noAtmosphericDensityAltitude+U;g5("orH","OH")end;pT=-1;if b0 or bn or bw then return end end else pT=bI end;r4=false;if(bi>0 or#q0>0)and not b0 and not bn and not cg and not bw then if 0.5*d:maxForceForward()/b.g()<cn then c2="WARNING: Heavy Loads may affect autopilot performance."cc=5 end;if#q0>0 and not ch then bi=sd(q0[1])cD.UpdateAutopilotTarget()table.remove(q0,1)c2="Route Autopilot in Progress"local qv=gg.position-d1;local rJ=qv:project_on_plane(c_):len()if rJ>50000 and gg.planetname==i_.name then se=true end end;cD.UpdateAutopilotTarget()cE.showWayPoint(c6,bh)if J and#q0==0 and bg~="STARTINGPOINT"and cD.findAtlasIndex(bm,"STARTINGPOINT")==-1 and ci>-1 then cD.AddNewLocation("STARTINGPOINT",d1,false,false)end;if gg~=nil then bq=nil;bu=gg.planetname=="Space"if bu then g5("apSpc","AP")if ck~=0 then cg=true;cE.ToggleAltitudeHold()else b0=true end elseif i_.name==gg.planetname then lq=true;if ck>0 then if not bn then g5("vtt","AP")sc(bu)if se then b7=i_.noAtmosphericDensityAltitude+U end end else g5("apOn","AP")if not(c6.name==i_.name and cl<gA*1.5)then cR=false;b0=true elseif not cj then if bw then cE.ToggleIntoOrbit()end;cQ=i_.noAtmosphericDensityAltitude+U;pY=true;cP.AutopilotAlign=true;cP.VectorToTarget=true;pW=false;if not bw then cE.ToggleIntoOrbit()end end end else g5("apP","AP")aZ=false;a_=false;if ck~=0 then cg=true;cE.ToggleAltitudeHold()else b0=true end end elseif ck==0 then if gg==nil and(c6.name==i_.name and dd)and not bw then rl=false;cR=false;pW=false;cE.ToggleIntoOrbit()else g5("apP","AP")b0=true;aZ=false;a_=false;b9=false;c0=false;b2=false;b3=false;b5=false;b4=false;bR=false;bq=nil;rl=false end else g5("apP","AP")cg=true;cE.ToggleAltitudeHold()end else g5("apOff","AP")cE.ResetAutopilots(1)end end;function pJ.routeWP(sf,sg,sh)if sh then if sh==1 then q0={}q0=iw(q0,bB)if#q0>0 then c2="Route Loaded"else c2="No Saved Route found on Databank"end;return q0 else bB={}bB=iw(bB,q0)c2="Route Saved"pI()return end end;if sf then return q0 end;if sg then q0={}c2="Current Route Cleared"else q0[#q0+1]=gg.name;c2="Added "..gg.name.." to route. "end;return q0 end;function pJ.cmdThrottle(dW,si)if it:getAxisCommandType(0)~=axisCommandType.byThrottle and not si then d.control.cancelCurrentControlMasterMode()end;it:setThrottleCommand(axisCommandId.longitudinal,dW)bM=dw(iv(dW*100,0)/100,-1,1)d4=nil end;function pJ.cmdCruise(dW,si)if it:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not si then d.control.cancelCurrentControlMasterMode()end;it:setTargetSpeedCommand(axisCommandId.longitudinal,dW)d4=dW end;function pJ.ToggleLockPitch()if bq==nil then g5("lkPOn","LP")if not c1 then bq=d6 else bq=R end;b4=false;b2=false;b3=false else g5("lkPOff","LP")bq=nil end end;function pJ.ToggleAltitudeHold()if bI-pS<1.5 then if i_.hasAtmosphere then if ck>0 then b7=i_.spaceEngineMinAltitude-0.01*i_.noAtmosphericDensityAltitude;g5("11","EP")else if dd then b7=i_.noAtmosphericDensityAltitude+U;cQ=b7;pY=true;if not bw then cE.ToggleIntoOrbit()end;pW=true end end;pS=-1;if b2 or bw or b6 then return end end else pS=bI end;if dd and ck==0 then cQ=cl;pY=true;pW=true;cE.ToggleIntoOrbit()if bw then pS=bI else pS=0 end;return end;b2=not b2;b3=false;b5=false;if b2 then b0=false;a_=false;aZ=false;c0=false;cJ=true;bq=nil;cR=false;if ci~=-1 and cZ<20 then g5("lfs","LS")b4=true;if pS>-1 then b7=cl+X end;bj=false;d.control.retractLandingGears()aY=true;it:setTargetGroundAltitude(Y)if aX and d2 then cE.ToggleVerticalTakeoff()end else g5("altOn","AH")b4=false;if pS>-1 then if dd then b7=cl end end;if b6 then cE.ToggleVerticalTakeoff()end end;if cg then b7=100000 end else g5("altOff","AH")if bw then cE.ToggleIntoOrbit()end;if b6 then cE.ToggleVerticalTakeoff()end;cJ=p;b4=false;bn=false;pS=0 end end;function pJ.ResetAutopilots(pJ)if pJ then cg=false;b0=false;b9=false;bR=false;b7=cl;r4=false;ds=false end;bn=false;b4=false;b5=false;a_=false;b3=false;dt=nil;sj=false;db=nil;ds=false;if not d3 then b2=false;bq=nil end;if b6 then cE.ToggleVerticalTakeoff()end;if bw then cE.ToggleIntoOrbit()end;cJ=p;cf=false;ch=false;c9=0 end;function pJ.BrakeToggle()aY=not aY;if b3 then b3=false;cJ=p end;if aY then g5("bkOn","B",1)cE.ResetAutopilots()else g5("bkOff","B",1)end end;function pJ.BeginReentry()if b5 then c2="Re-Entry cancelled"g5("reOff","RE")b5=false;cJ=p;b2=false elseif not i_.hasAtmosphere then c2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"cc=5 elseif not bS then b5=true;if it:getAxisCommandType(0)~=sk.cruise then d.control.cancelCurrentControlMasterMode()end;cJ=true;aY=false;c2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cM;g5("par","RE")else b5=true;b2=true;cJ=true;aY=false;b7=i_.surfaceMaxAltitude+_;if b7>i_.spaceEngineMinAltitude then b7=i_.spaceEngineMinAltitude-0.01*i_.noAtmosphericDensityAltitude end;local sl=iy(b7)c2="Beginning Re-entry.  Target speed: "..cM.." Target Altitude: "..sl;g5("glide","RE")cE.cmdCruise(bG(cM))end;b4=false end;function pJ.ToggleAntigrav()if antigrav and not q then if d3 then g5("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bs==nil then bs=cl end;if bs<1000 then bs=1000 end;g5("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pJ.changeSpd(sm)local sn=1;if sm then sn=-1 end;if not c1 then if u and not p2 and co then local so=bM;bM=iv(dw(bM+sn*aA/100,-1,1),2)if bM>=0 and so<0 then bM=0;co=false end elseif p2 then if ck>0 or b5 then cM=dw(cM+sn*aA,0,V)elseif b0 then a0=dw(a0+sn*aA/3.6*100,0,8333.00)end else it:updateCommandFromActionStart(axisCommandId.longitudinal,sn*aA/10)end else if b0 or bn or cg or bw then dh=dh+1*sn*-1;if dh>#d8 then dh=1 end;if dh<1 then dh=#d8 end else if not sm then sn=1 else sn=nil end;cD.adjustAutopilotTargetIndex(sn)end end end;function pJ.TenthTick()local function sp(gN,sq)if gN==nil then gN=b.g()end;gN=iv(gN,5)if sq~=nil and sq or(q1==nil or q1~=gN)then local fB=cX:len()local sr=iq(c.getData()).maxBrake;if sr~=nil and sr>0 and cj then sr=sr/dw(fB/100,0.1,1)sr=sr/ck;if ck>0.10 then if br then br=(br+sr)/2 else br=sr end end end;if sr~=nil and sr>0 then bp=sr end;q1=gN end end;sp(nil,true)if d4~=nil then if it:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or it:getTargetSpeed(axisCommandId.longitudinal)~=d4 then cE.cmdCruise(d4)else d4=nil end end end;function pJ.SatNavTick()if not r then return end;q2=dbHud_1.getStringValue("SPBAutopilotTargetName")if q2~=nil and q2~=""and q2~="SatNavNotChanged"then local dQ=iq(dbHud_1.getStringValue("SavedLocations"))if dQ~=nil then bm=dQ;local gH=-1;local gO;for dV,dH in pairs(bm)do if dH.name and dH.name=="SatNav Location"then gH=dV;break end end;if gH~=-1 then gO=bm[gH]gH=-1;for dV,dH in pairs(e[0])do if dH.name and dH.name=="SatNav Location"then gH=dV;break end end;if gH>-1 then e[0][gH]=gO end;cD.UpdateAtlasLocationsList()c2=gO.name.." position updated"end end;for L=1,#d8 do if d8[L].name==q2 then bi=L;a.print("Index = "..bi.." "..d8[L].name)cD.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;ci=q7()return pJ end;local function ss(d,b,c,a,e,vBooster,hover,antigrav,io,dbHud_2,gyro,screenHud_1,is,it,iu,st,gV,iv,ef,dx,dw,g5,ix,pI)local su={}local sv=true;local sw=5;local sx=5;local sy=sw;local sz=sx;local sA=bI;function su.startControl(sB)local function sC(sm)local sn=1;local function sD(sE,sm)local sF={i_.surfaceMaxAltitude+100,i_.spaceEngineMinAltitude-0.01*i_.noAtmosphericDensityAltitude,i_.noAtmosphericDensityAltitude+U,i_.radius*(T-1)+i_.noAtmosphericDensityAltitude}local sG=sE;for d_,dH in ipairs(sF)do if sm and sG>dH then sE=dH elseif sE<dH and not sm then sE=dH;break end end;return sE end;if sm then sn=-1 end;if not q and d3 then if c1 and sm then bs=1000 elseif bs~=nil then bs=bs+sn*sx;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end else bs=sb+sn*100 end elseif b2 or b6 or bw then if bw then if c1 then cQ=sD(cQ,sm)else cQ=cQ+sn*sw end;if cQ<i_.noAtmosphericDensityAltitude then cQ=i_.noAtmosphericDensityAltitude end else if c1 and cj then b7=sD(b7,sm)else b7=b7+sn*sw end end else it:updateTargetGroundAltitudeFromActionStart(sn*1.0)end end;local function sH(sI)if not cj then c2="Flight Assist in Atmo only"return end;local dE=type(sI)if db==nil then if dE=="table"then if b0 or bn then cE.ToggleAutopilot()end;g5("180On","BR")elseif sI==1 then g5("bnkLft","BR")else g5("bnkRht","BR")end;if not b2 and not b0 and not bn then cE.ToggleAltitudeHold()if dE~="table"then sI=sI+1 end end;db=sI else g5("180Off","BR")db=nil end end;if sB=="gear"then bj=not bj;if bj then bn=false;bq=nil;cE.cmdThrottle(0)if vBooster or hover then if cj and ci==-1 then g5("bklOn","BL")lq=true;b5=false;b4=false;b6=false;b2=false;b3=true;ds=false;cJ=true;bj=false else if bT then g5("grOut","LG",1)d.control.extendLandingGears()end;it:setTargetGroundAltitude(Z)if cj then aY=true end end end;if bT and not b3 and not(vBooster or hover)then g5("grOut","LG",1)d.control.extendLandingGears()end else if bT then g5("grIn","LG",1)d.control.retractLandingGears()end;it:setTargetGroundAltitude(Y)end elseif sB=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif sB=="forward"then bU=bU-1 elseif sB=="backward"then if p2 then sH(-cY*5000)else bU=bU+1 end elseif sB=="left"then if p2 then sH(1)else bX=bX-1 end elseif sB=="right"then if p2 then sH(3)else bX=bX+1 end elseif sB=="yawright"then bY=bY-1;dt=nil elseif sB=="yawleft"then bY=bY+1;dt=nil elseif sB=="straferight"then it:updateCommandFromActionStart(axisCommandId.lateral,1.0)bv=1 elseif sB=="strafeleft"then it:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bv=-1 elseif sB=="up"then c9=c9+1;it:deactivateGroundEngineAltitudeStabilization()it:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif sB=="down"then c9=c9-1;it:deactivateGroundEngineAltitudeStabilization()it:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif sB=="groundaltitudeup"then sC()elseif sB=="groundaltitudedown"then sC(true)elseif sB=="option1"then sJ=false;if p2 and c1 then local sK=""for L=1,#di do sK=sK.."| Name: "..a.getPlayerName(di[L]).." Mass: "..iv(b.getBoardedPlayerMass(di[L])/1000,1).."t "end;a.print("Onboard: "..sK)return end;cD.adjustAutopilotTargetIndex()elseif sB=="option2"then sJ=false;if p2 and c1 then for L=1,#di do b.forceDeboard(di[L])end;c2="Deboarded All Passengers"return end;cD.adjustAutopilotTargetIndex(1)elseif sB=="option3"then local function sL()sv=not sv;if not sv then g5("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(sM,atmofueltank_size,"Atmo Fuel","fuel_container")sN=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(sO,spacefueltank_size,"Space Fuel","fuel_container")sP=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(sQ,rocketfueltank_size,"Rocket Fuel","fuel_container")sR=_autoconf.panels[_autoconf.panels_size]end;sS=a.createWidgetPanel("Docking")sT=a.createWidget(sS,"parenting")a.addDataToWidget(c.getDataId(),sT)sU=a.createWidgetPanel("Core combat stress")sV=a.createWidget(sU,"core_stress")a.addDataToWidget(b.getDataId(),sV)if io~=nil then io.show()end else g5("hud","DH")c.hide()b.hide()if sN~=nil then gV(sN)sN=nil end;if sS~=nil then gV(sS)sS=nil end;if sU~=nil then gV(sU)sU=nil end;if sP~=nil then gV(sP)sP=nil end;if sR~=nil then gV(sR)sR=nil end;if io~=nil then io.hide()end end end;sJ=false;if p2 and c1 then local sK=""for L=1,#dj do sK=sK.."| ID: "..dj[L].." Mass: "..iv(b.getDockedConstructMass(dj[L])/1000,1).."t "end;a.print("Docked Ships: "..sK)return end;if y then if x then x=false else x=true end end;sL()elseif sB=="option4"then sJ=false;if p2 and c1 then for L=1,#dj do b.forceUndock(dj[L])end;c2="Undocked all ships"return end;db=nil;cE.ToggleAutopilot()elseif sB=="option5"then sJ=false;cE.ToggleLockPitch()elseif sB=="option6"then sJ=false;if p2 and c1 then if io then local sW=io.getVentingCooldown()if sW>0 then c2="Cannot vent again for "..sW.." seconds"return end;if io.getShieldHitpoints()<io.getMaxShieldHitpoints()then io.startVenting()c2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c2="Shields already at max hitpoints"end;return else c2="No shield found"return end end;cE.ToggleAltitudeHold()elseif sB=="option7"then sJ=false;if p2 and c1 then if io then io.toggle()return else c2="No shield found"return end end;F=not F;if F then c2="Collision System Enabled"else c2="Collision System Secured"end elseif sB=="option8"then sJ=false;if p2 and c1 then if bi>0 and gg~=nil then cE.routeWP()else c2="Select a saved wp on IPH to add to or remove from route"end;return end;by=not by;if not by then c2="DeCoupled Mode - Ground Stabilization off"it:deactivateGroundEngineAltitudeStabilization()g5("gsOff","GS")else c2="Coupled Mode - Ground Stabilization on"it:activateGroundEngineAltitudeStabilization(sX)d:setEngineForceCommand('hover',vec3(),1)g5("gsOn","GS")end elseif sB=="option9"then sJ=false;if p2 and c1 then it:resetCommand(axisCommandId.longitudinal)it:resetCommand(axisCommandId.lateral)it:resetCommand(axisCommandId.vertical)cE.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cp=gyro.getState()==1;if cp then g5("gyOn","GA")else g5("gyOff","GA")end else c2="No gyro found"end elseif sB=="lshift"then dg=false;if p2 then c1=true end;if iu()==1 then c1=true;bf=iu()st(1)elseif is()==1 and z then c1=true;cI=false;cH=false end elseif sB=="brake"then if aW or p2 then cE.BrakeToggle()elseif not aY then cE.BrakeToggle()else aY=true end elseif sB=="lalt"then sJ=true;p2=true;if is()==0 and not i and g=="keyboard"then st(1)end elseif sB=="booster"then if n then d:toggleBoosters()elseif not c3 then if not sY then d:toggleBoosters()sY=true end;c3=true else if sY then d:toggleBoosters()sY=false end;c3=false end elseif sB=="stopengines"then local function sZ()if bI-sA<1.5 then g5("clear","CA")b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"aZ=false;a_=false;db=nil;b2=false;b5=false;b3=false;aY=false;b4=false;b6=false;c0=false;bR=false;cf=false;cg=false;bS=false;cJ=p;bn=false;b1=false;cp=false;bq=nil;bw=false;ds=false;dt=nil end end;sZ()sA=bI;if it:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bM~=0 then it:resetCommand(axisCommandId.longitudinal)cE.cmdThrottle(0)else cE.cmdThrottle(100)end else if it:getTargetSpeed(axisCommandId.longitudinal)~=0 then it:resetCommand(axisCommandId.longitudinal)else if cj then cE.cmdCruise(V)else cE.cmdCruise(a0*3.6)end end end elseif sB=="speedup"then cE.changeSpd()elseif sB=="speeddown"then cE.changeSpd(true)elseif sB=="antigravity"and not q then if antigrav~=nil then cE.ToggleAntigrav()else c2="No antigrav found"end end end;function su.stopControl(sB)local function s_()if not q and d3 then sz=sx end;if b2 or b6 or bw then sy=sw end end;if sB=="forward"then bU=0 elseif sB=="backward"then bU=0 elseif sB=="left"then if db then if db==2 then db=-2 else db=-1 end end;bX=0 elseif sB=="right"then if db then if db==4 then db=-2 else db=-1 end end;bX=0 elseif sB=="yawright"then bY=0 elseif sB=="yawleft"then bY=0 elseif sB=="straferight"then it:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bv=0 elseif sB=="strafeleft"then it:updateCommandFromActionStop(axisCommandId.lateral,1.0)bv=0 elseif sB=="up"then c9=0;it:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if by then it:activateGroundEngineAltitudeStabilization(sX)d:setEngineForceCommand('hover',vec3(),1)end elseif sB=="down"then c9=0;it:updateCommandFromActionStop(axisCommandId.vertical,1.0)if by then it:activateGroundEngineAltitudeStabilization(sX)d:setEngineForceCommand('hover',vec3(),1)end elseif sB=="groundaltitudeup"then s_()sJ=false elseif sB=="groundaltitudedown"then s_()sJ=false elseif sB=="lshift"then if iu()==1 then ca=0;cb=0;st(bf)elseif is()==1 and z then cI=false;cH=false end;c1=false elseif sB=="brake"then if not aW and not p2 then if aY then cE.BrakeToggle()else aY=false end end elseif sB=="lalt"then if is()==0 and i then if sJ then if iu()==1 then st(0)else st(1)end else sJ=true end elseif is()==0 and not i and g=="keyboard"then st(0)end;p2=false end end;function su.loopControl(sB)local function t0(sm)local sn=1;if sm then sn=-1 end;if not q and d3 then if bs~=nil then bs=bs+sn*sz;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end;sz=dw(sz*1.05,sx,50)else bs=sb+sn*100 end elseif b2 or b6 or bw then if bw then cQ=cQ+sn*sy;if cQ<i_.noAtmosphericDensityAltitude then cQ=i_.noAtmosphericDensityAltitude end else b7=b7+sn*sy end;sy=dw(sy*1.05,sw,50)else it:updateTargetGroundAltitudeFromActionLoop(sn*1.0)end end;local function t1(sm)local sn=1;if sm then sn=-1 end;if not c1 then if u and not p2 then bM=dw(bM+sn*aB/100,-1,1)else it:updateCommandFromActionLoop(axisCommandId.longitudinal,sn*aB)end end end;if sB=="groundaltitudeup"then if not c1 then t0()end elseif sB=="groundaltitudedown"then if not c1 then t0(true)end elseif sB=="speedup"then t1()elseif sB=="speeddown"then t1(true)end end;function su.inputTextControl(sl)local function t2(t3,fH,gK)local function t4(fH)local dN=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dO='::pos{'..dN..','..dN..','..dN..','..dN..','..dN..'}'local e3,e4,ec,ed,ee=ef(fH,dO)if e3=="0"and e4=="0"then return vec3(dx(ec),dx(ed),dx(ee))end;ed=math.rad(ed)ec=math.rad(ec)local i_=e[dx(e3)][dx(e4)]local f5=math.cos(ec)local t5=vec3(f5*math.cos(ed),f5*math.sin(ed),math.sin(ec))return i_.center+(i_.radius+ee)*t5 end;local g7=t4(fH)return cD.AddNewLocation(t3,g7,gK)end;local L;local t6,t7=nil,nil;local t8="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to logfile and screen to cut and paste to privatelocations.lua, all if present will make it include all databank locations."L=string.find(sl," ")t6=sl;if L~=nil then t6=string.sub(sl,0,L-1)t7=string.sub(sl,L+1)end;if t6=="/help"or t6=="/commands"then for oA in string.gmatch(t8,"([^\n]+)")do a.print(oA)end;return elseif t6=="/setname"then if t7==nil or t7==""then c2="Usage: ah-setname Newname"return end;if bi>0 and gg~=nil then cD.UpdatePosition(t7)else c2="Select a saved target to rename first"end elseif io and t6=="/resist"then if not io then c2="No shield found"return elseif t7==nil or io.getResistancesCooldown()>0 then c2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dN=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dO=dN..', '..dN..', '..dN..', '..dN;local t9,ta,tb,tc=ef(t7,dO)if tc==nil or t9+ta+tb+tc>0.6 then c2="Improperly formatted or total exceeds 0.6"return end;if io.setResistances(t9,ta,tb,tc)==1 then c2="Shield Resistances set"else c2="Resistance setting failed."end elseif t6=="/addlocation"or string.find(sl,"::pos")~=nil then local gK=false;local t3="0-Temp"if t7==nil or t7==""then t7=t6;gK=true end;L=string.find(t7,"::")if not gK then t3=string.sub(t7,1,L-2)end;local fH=string.sub(t7,L)t2(t3,fH,gK)elseif t6=="/agg"then if t7==nil or t7==""then c2="Usage: /agg targetheight"return end;t7=dx(t7)if t7<1000 then t7=1000 end;bs=t7;c2="AGG Target Height set to "..t7 elseif t6=="/G"then if t7==nil or t7==""then c2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if t7=="dump"then for dV,dH in pairs(ix())do if type(dH.get())=="boolean"then if dH.get()==true then a.print(dV.." true")else a.print(dV.." false")end elseif dH.get()==nil then a.print(dV.." nil")else a.print(dV.." "..dH.get())end end;return end;L=string.find(t7," ")local td=string.sub(t7,0,L-1)local te=string.sub(t7,L+1)for dV,dH in pairs(ix())do if dV==td then c2="Variable "..td.." changed to "..te;local tf=type(dH.get())if tf=="number"then te=dx(te)if dV=="AtmoSpeedLimit"then cM=te end elseif tf=="boolean"then if string.lower(te)=="true"then te=true else te=false end end;dH.set(te)return end end;c2="No such global variable: "..td elseif t6=="/deletewp"then if bi>0 and gg~=nil then cD.ClearCurrentPosition()else c2="Select a custom wp to delete first in IPH"end elseif t6=="/copydatabank"then if dbHud_2 then pI(true)else c2="Spare Databank required to copy databank"end elseif t6=="/iphWP"then if bi>0 then a.print(cE.showWayPoint(c6,bh,true))a.print(json.encode(bh))c2="::pos waypoint shown in lua chat in local and world format"else c2="No target selected in IPH"end elseif t6=="/createPrivate"then local tg="privatelocations = {\n"local th=""if#dq>0 then for dV,dH in pairs(dq)do tg=tg.."{position = {x = "..dH.position.x..", y = "..dH.position.y..", z = "..dH.position.z.."},\n ".."name = '"..dH.name.."',\n planetname = '"..dH.planetname.."',\n gravity = "..dH.gravity..",\n"if dH.heading then tg=tg.."heading = {x = "..dH.heading.x..", y = "..dH.heading.y..", z = "..dH.heading.z.."},\n"end;if dH.safe then tg=tg.."safe = true},\n"else tg=tg.."safe = false},\n"end end end;th=#dq.."-Private "if t7=="all"then for dV,dH in pairs(bm)do tg=tg.."{position = {x = "..dH.position.x..", y = "..dH.position.y..", z = "..dH.position.z.."},\n ".."name = '*"..dH.name.."',\n planetname = '"..dH.planetname.."',\n gravity = "..dH.gravity..",\n"if dH.heading then tg=tg.."heading = {x = "..dH.heading.x..", y = "..dH.heading.y..", z = "..dH.heading.z.."},\n"end;if dH.safe then tg=tg.."safe = true},\n"else tg=tg.."safe = false},\n"end end;th=th..#bm.."-Public "end;tg=tg.."}\n return privatelocations"a.logInfo("PRIVATELOCATIONS:"..tg)if screenHud_1 then screenHud_1.setHTML(tg)end;c2=th.."locations dumped to logfile and screen if present.\n Cut and paste to privatelocations.lua to use"cc=7 end end;function su.tagTick()if bz=="Off"then bz="All"elseif bz=="All"then bz="Longitude"elseif bz=="Longitude"then bz="Lateral"elseif bz=="Lateral"then bz="Vertical"else bz="Off"end;c2="Extra Engine Tags: "..bz;c.stopTimer("tagTick")end;return su end;local function ti(d,b,c,a,library,e,vBooster,hover,pH,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,io,gyro,warpdrive,ip,screenHud_1)local tj={}local dv=string.format;local iq=json.decode;local tk=json.encode;local pB=b.getElementMaxHitPointsById;local ir=b.getElementMassById;local is=d.control.isRemoteControlled;local ef=string.match;local gV=a.destroyWidgetPanel;local g3=a.updateData;local g4=a.addDataToWidget;local st=a.lockView;local iu=a.isViewLocked;local dy=math.sqrt;local dx=tonumber;local f9=math.abs;local bG=math.floor;local bH=c.getAtmosphereDensity;local f4=math.atan;local bF=a.getTime;local dw=utils.clamp;local it=d.axisCommandManager;local tl=Z;local gX=13;local iA=b.getElementIdList()local iB=0;local function dz(eN,eO)if eN==0 then return f9(eO)<1e-09 end;if eO==0 then return f9(eN)<1e-09 end;return f9(eN-eO)<math.max(f9(eN),f9(eO))*dM end;local function iv(dN,tm)local sn=10^(tm or 0)return bG(dN*sn+0.5)/sn end;local function iw(tn,to)for dV,dH in pairs(to)do if type(dV)=="string"then tn[dV]=dH else tn[#tn+1]=to[dV]end end;return tn end;local function ix(tp)local tq={}if not tp then iw(tq,K)iw(tq,a8)iw(tq,az)iw(tq,aV)return tq elseif tp=="boolean"then return K elseif tp=="handling"then return a8 elseif tp=="hud"then return az elseif tp=="physics"then return aV end end;local function pI(tr)local function ts(tt)for dV,dH in pairs(tt)do dbHud_1.setStringValue(dV,tk(dH.get()))if tr and dbHud_2 then dbHud_2.setStringValue(dV,tk(dH.get()))end end end;if dbHud_1 then ts(bC)ts(ix())a.print("Saved Variables to Datacore")if tr and dbHud_2 then c2="Databank copied.  Remove copy when ready."end end end;local function g5(tu,tv,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..tu.."|"..tv.."|"..ay)else a.logInfo("sound_notification|audiopacks/"..h.."/"..tu.."|"..tv.."|"..ay)end else a.logInfo("sound_q|audiopacks/"..h.."/"..tu.."|"..tv.."|"..ay)end end;local function gW(hw,hx,sl,jE,tw)if jE==nil then jE=""end;if tw==nil then tw=""end;return dv([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jE,hw,hx,tw,sl)end;local function iy(cd,tx)local ty=cd>100000;if tx==nil then tx=1 end;if ty then return iv(cd/1000/200,tx).."SU"elseif cd<1000 then return iv(cd,tx).."M"else return iv(cd/1000,tx).."KM"end end;local function iz(tz)local tA=0;local tB=0;local tC=0;if tz<60 then tz=bG(tz)elseif tz<3600 then tA=bG(tz/60)tz=bG(tz%60)elseif tz<86400 then tB=bG(tz/3600)tA=bG(tz%3600/60)else tC=bG(tz/86400)tB=bG(tz%86400/3600)end;if tC>0 then return tC.."d "..tB.."h "elseif tB>0 then return tB.."h "..tA.."m "elseif tA>0 then return tA.."m "..tz.."s"elseif tz>0 then return tz.."s"else return"0s"end end;function tj.onStart()local tD=false;local function tE()local function tF(tG)local tH=dbHud_1.hasKey;for dV,dH in pairs(tG)do if tH(dV)then local dQ=iq(dbHud_1.getStringValue(dV))if dQ~=nil then dH.set(dQ)tD=true end end end end;if dbHud_1 then if not f then tF(ix())coroutine.yield()tF(bC)else tF(bC)c2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"cc=5;tD=false end;coroutine.yield()if tD then c2="Loaded Saved Variables"cs=a9;ct=aa;aW=j;g=string.lower(g)cJ=p;cM=V;cq=[[rgb(]]..bG(bJ+0.5)..","..bG(bL+0.5)..","..bG(bK+0.5)..[[)]]cr=[[rgb(]]..bG(bJ*0.9+0.5)..","..bG(bL*0.9+0.5)..","..bG(bK*0.9+0.5)..[[)]]elseif not f then c2="No Saved Variables Found - Exit HUD to save settings"end;if bA<1.500 then if U<2000 then c2="Updating LowOrbitHeight to new minimum default of 2000."U=2000 end end;bA=VERSION_NUMBER;if#bm>0 then dr=iw(dr,bm)end else c2="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bt+180<bI then br=0 end;bt=bI;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"cc=7 end;if antigrav and not q then if bs==nil then bs=cl end;antigrav.setBaseAltitude(bs)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then dq=require("autoconf/custom/archhud/privatelocations")if#dq>0 then dr=iw(dr,dq)end end;ly="Proceeding to Waypoint"end;local function tI()local function tJ(tK,tL)if tK>tL then tL=tK end;local tM,tN=0,0;if a6>0 then tM=a6*0.05 end;if a7>0 then tN=a7*0.05 end;tL=tL*(1-(tM+tN))return tL end;local tO=b.getElementNameById;local tP=aq~=0 and ar~=0;for dV in pairs(iA)do local type=b.getElementTypeById(iA[dV])if ef(type,'^.*Atmospheric Engine$')then if ef(tostring(b.getElementTagsById(iA[dV])),'^.*vertical.*$')and b.getElementForwardById(iA[dV])[3]>0 then d2=true end end;if ef(type,'^.*Space Engine$')then cT=true;if ef(tostring(b.getElementTagsById(iA[dV])),'^.*vertical.*$')then local tQ=b.getElementForwardById(iA[dV])if tQ[3]<0 then tR=true else cS=true end end end;if type=="Landing Gear"then bT=true end;if type=="Dynamic Core Unit"then local pD=pB(iA[dV])if pD>10000 then gX=110 elseif pD>1000 then gX=55 elseif pD>150 then gX=27 end end;iB=iB+pB(iA[dV])if tP and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pD=pB(iA[dV])local om=ir(iA[dV])local tK=0;local jy=bF()if type=="Atmospheric Fuel Tank"then local tL=400;local tS=35.03;if pD>10000 then tL=51200;tS=5480 elseif pD>1300 then tL=6400;tS=988.67 elseif pD>150 then tL=1600;tS=182.67 end;tK=om-tS;if a3>0 then tL=tL+tL*a3*0.2 end;tL=tJ(tK,tL)cu[#cu+1]={iA[dV],tO(iA[dV]),tL,tS,tK,jy}end;if type=="Rocket Fuel Tank"then local tL=320;local tS=173.42;if pD>65000 then tL=40000;tS=25740 elseif pD>6000 then tL=5120;tS=4720 elseif pD>700 then tL=640;tS=886.72 end;tK=om-tS;if a5>0 then tL=tL+tL*a5*0.1 end;tL=tJ(tK,tL)cw[#cw+1]={iA[dV],tO(iA[dV]),tL,tS,tK,jy}end;if type=="Space Fuel Tank"then local tL=600;local tS=35.03;if pD>10000 then tL=76800;tS=5480 elseif pD>1300 then tL=9600;tS=988.67 elseif pD>150 then tL=2400;tS=182.67 end;tK=om-tS;if a4>0 then tL=tL+tL*a4*0.2 end;tL=tJ(tK,tL)cv[#cv+1]={iA[dV],tO(iA[dV]),tL,tS,tK,jy}end end end;if not d2 then b6,aX=false,false end end;local function tT()if gyro~=nil then cp=gyro.getState()==1 end;if not by then it:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then st(1)else st(0)end;if door and(cj or not cj and cl<10000)then for d_,dH in pairs(door)do dH.toggle()end end;if switch then for d_,dH in pairs(switch)do dH.toggle()end end;if forcefield and(cj or not cj==0 and cl<10000)then for d_,dH in pairs(forcefield)do dH.toggle()end end;if antigrav then d3=antigrav.getState()==1;if d3 and not q then antigrav.show()end end;if is()==1 and k then a.freeze(1)else a.freeze(0)end;if bT then bj=d.control.isAnyLandingGearExtended()==1;if bj then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if ci~=-1 or not cj and cX:len()<50 then aY=true;bj=true;if bT then d.control.extendLandingGears()end else aY=false end;it:setTargetGroundAltitude(tl)if cj and ci~=-1 then cA=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;pp=cj end;local function tU()local tV={}local function tW()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local tX={[1]=4480,[6]=4480,[7]=6270}for tY,tZ in pairs(e)do e[tY][0]=tW()e[tY][0].systemId=tY;tV[tY]={}for t_,i_ in pairs(e[tY])do i_.gravity=i_.gravity/9.8;i_.center=vec3(i_.center)i_.name=i_.name[1]i_.noAtmosphericDensityAltitude=i_.atmosphereThickness or i_.atmosphereRadius-i_.radius;if i_.name=="Lacobus"then i_.noAtmosphericDensityAltitude=12510 end;i_.spaceEngineMinAltitude=tX[i_.id]or 0.68377*i_.atmosphereThickness;i_.planetarySystemId=tY;i_.bodyId=i_.id;tV[tY][t_]=i_;if mr==nil or i_.center.x<mr then mr=i_.center.x end;if mq==nil or i_.center.x>mq then mq=i_.center.x end;if mu==nil or i_.center.y<mu then mu=i_.center.y end;if mt==nil or i_.center.y>mt then mt=i_.center.y end;if i_.center and i_.name~="Space"then dk[#dk+1]=i_ end end end;ep=du(d,b,c,a,dv,dw,dx,dy,dz)cy=ep(tV)cz=f8(d,b,c,a,dy,f9)cB=fD(d,b,c,a,dv,dw,dx,dy,dz)cD=g2(d,b,c,a,dbHud_1,e,g3,g4,bG,dx,dy,g5)end;u0=false;u1=coroutine.create(function()it:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})tE()coroutine.yield()tI()coroutine.yield()cE=pG(d,b,c,a,e,vBooster,hover,pH,antigrav,warpdrive,dbHud_1,f9,bG,bH,is,f4,bF,dw,it,g3,iu,dy,iv,g5,iw,dz,iy,iz,pI,iq,dv,g4)tT()coroutine.yield()tU()cF=gU(b,a,c,library,radar_1,radar_2,f9,gV,dy,gW,dx,gX,g5)cC=im(d,b,c,a,e,radar_1,radar_2,antigrav,hover,io,warpdrive,ip,f9,bG,dv,iq,bH,ir,is,f4,bF,dw,it,g4,g3,gV,iu,dy,iv,gW,g5,iw,ix,iy,iz,iA,iB)cC.ButtonSetup()cG=ss(d,b,c,a,e,vBooster,hover,antigrav,io,dbHud_2,gyro,screenHud_1,is,it,iu,st,gV,iv,ef,dx,dw,g5,ix,pI)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aP)c.setTimer("radarTick",aP)c.setTimer("hudTick",aQ)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)g5("start","SU")end)coroutine.resume(u1)end;function tj.onUpdate()if not u0 then local ib=coroutine.status(u1)if ib=="suspended"then local dW,ic=coroutine.resume(u1)if ic then a.print("ERROR STARTUP: "..ic)end elseif ib=="dead"then u0=true end end;if u0 then d:update()if cj and u and d5 then if d5 and bQ then cE.cmdThrottle(0)bQ=false elseif not d5 and not bQ then bM=0;bQ=true end end;if dn then it:setThrottleCommand(axisCommandId.longitudinal,dn)dn=nil end;if not cH and p4~=u2 then a.setScreen(p4)end;u2=p4 end end;function tj.onFlush()local function u3(u4,rt)local u5=vec3()local u6=vec3()if u4==axisCommandId.longitudinal then u5=vec3(b.getConstructOrientationForward())u6=cV elseif u4==axisCommandId.vertical then u5=vec3(b.getConstructOrientationUp())u6=cU elseif u4==axisCommandId.lateral then u5=vec3(b.getConstructOrientationRight())u6=cW else return vec3()end;local u7=vec3(b.getWorldGravity())local u8=u7:dot(u6)local u9=vec3(b.getWorldAirFrictionAcceleration())local ua=u9:dot(u6)local ub=cX:dot(u5)local uc=rt*constants.kph2m;if ud==nil then ud=pid.new(10,0,10.0)end;ud:inject(uc-ub)local ue=ud:get()local uf=(ue-ua-u8)*u6;return uf end;local function ug(u4,rt)local u5=vec3()local u6=vec3()if u4==axisCommandId.longitudinal then u5=vec3(b.getConstructOrientationForward())u6=cV elseif u4==axisCommandId.vertical then u5=vec3(b.getConstructOrientationUp())u6=cU elseif u4==axisCommandId.lateral then u5=vec3(b.getConstructOrientationRight())u6=cW else return vec3()end;local u7=vec3(b.getWorldGravity())local u8=u7:dot(u6)local u9=vec3(b.getWorldAirFrictionAcceleration())local ua=u9:dot(u6)local ub=cX:dot(u5)local uc=rt*constants.kph2m;if uh==nil then uh=pid.new(10,0,10.0)end;uh:inject(uc-ub)local ue=uh:get()local uf=(ue-ua-u8)*u6;return uf end;local function ui(uj,jN,gc)local uk=uj:cross(gc):normalize_inplace()local ky=math.acos(dw(uk:dot(-jN),-1,1))*constants.rad2deg;if uk:cross(-jN):dot(gc)<0 then ky=-ky end;return ky end;if antigrav and not q then if not d3 and antigrav.getBaseAltitude()~=bs then antigrav.setBaseAltitude(bs)end end;d5=it:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local ul=dw(bU+bV+a.getControlDeviceForwardInput(),-1,1)local um=dw(bX+b_+a.getControlDeviceYawInput(),-1,1)local un=dw(bY+bW-a.getControlDeviceLeftRightInput(),-1,1)local uo=bZ;c_=vec3(b.getWorldVertical())if c_==nil or c_:len()==0 then c_=(i_.center-d1):normalize()end;cU=vec3(b.getConstructWorldOrientationUp())cV=vec3(b.getConstructWorldOrientationForward())cW=vec3(b.getConstructWorldOrientationRight())cY=vec3(b.getWorldVelocity())cX=vec3(b.getVelocity())d1=vec3(b.getConstructWorldPos())cn=b.getConstructMass()cZ=vec3(cY):len()d0=-c_:dot(cY)d7=getRoll(c_,cV,cW)local up=d7/180*math.pi;local uq=math.cos(up)local ur=math.sin(up)d6=ui(c_,cV,cW*uq+cU*ur)local us=cY:normalize()local ut=f9(d7)local uu=utils.sign(d7)local uv=vec3(b.getWorldAngularVelocity())local uw=ul*aK*cW+um*aF*cV+un*aL*cU;if cJ==true and c_:len()>0.01 then local ux=f9(cL-d7)if((a_ or b5 or b3 or cf or b2 or bw)and ux>0 or ck>0.0 and ux<aG and p)and um==0 and f9(d6)<85 then local uy=cL;local uz=aE;if ck==0 then uz=uz/4;cL=0;uy=0 end;if uA==nil then uA=pid.new(uz*0.01,0,uz*0.1)end;uA:inject(uy-d7)local uB=uA:get()uw=uw+uB*cV end end;local uC=1;local uD=0;local uE=1;bN=0;if cj and u and d5 then if uF==nil then uF=pid.new(0.1,0,1)end;local uG=0;if aR>0 and not b5 and ck>0.005 and ck<0.1 and d0>-50 then uG=(0.1-ck)*cM*aR end;uF:inject(cM/3.6+uG-cY:dot(cV))local uH=uF:get()bP=dw(uH,-1,1)if not dn then if bP<bM and ck>0.005 then bO=true;dn=dw(bP,0.01,1)else bO=false;dn=bM end end;if uI==nil then uI=pid.new(1*0.01,0,1*0.1)end;uI:inject(cY:len()-cM/3.6-uG)local uJ=dw(uI:get(),0,1)if ck>0 and d0<-80 or ck>0.005 then bN=uJ end;if bN>0 then if bO and bP==0.01 and not dn then dn=0 end else bP=dw(bP,0.01,1)end;local uK=''local uL=vec3()local uM=u3(axisCommandId.vertical,c9*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",uM,uD)local uN='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then uN=uN..aS end;local uO=it:getAxisCommandType(axisCommandId.longitudinal)local uP=it:composeAxisAccelerationFromThrottle(uN,axisCommandId.longitudinal)local uQ=ug(axisCommandId.lateral,bv*1000)uK=uK..' , '.."lateral airfoil , lateral ground "uL=uL+uQ;if uL:len()>constants.epsilon then d:setEngineForceCommand(uK,uL,uD,'','','',uE)end;d:setEngineForceCommand(uN,uP,uC)local uR='thrust analog vertical fueled 'local uS='thrust analog lateral fueled 'if bz=="All"or bz=="Lateral"then uS=uS..aT end;if bz=="All"or bz=="Vertical"then uR=uR..aU end;if c9~=0 or b3 and aY or not bj and not by then d:setEngineForceCommand(uR,uM,uC)else d:setEngineForceCommand(uR,vec3(),uC)end;if bv~=0 then d:setEngineForceCommand(uS,uQ,uC)else d:setEngineForceCommand(uS,vec3(),uC)end;if uo==0 then uo=bN end;local uT=-uo*(aM*cY+aN*us)d:setEngineForceCommand('brake',uT)else if u then if not dn then dn=bM end end;local rt=c.getAxisCommandValue(0)if not d5 then if uI==nil then uI=pid.new(1*0.01,0,1*0.1)end;uI:inject(cY:len()-rt/3.6)local uJ=dw(uI:get(),0,1)uo=dw(uo+uJ,0,1)end;local uT=-uo*(aM*cY+aN*us)d:setEngineForceCommand('brake',uT)local uK=''local uL=vec3()local uU=false;local uN='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then uN=uN..aS end;local uO=it:getAxisCommandType(axisCommandId.longitudinal)if uO==axisCommandType.byThrottle then local uP=it:composeAxisAccelerationFromThrottle(uN,axisCommandId.longitudinal)d:setEngineForceCommand(uN,uP,uC)elseif uO==axisCommandType.byTargetSpeed then local uP=it:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)uK=uK..' , '..uN;uL=uL+uP;if it:getTargetSpeed(axisCommandId.longitudinal)==0 or it:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-it:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then uU=true end end;local uS='thrust analog lateral 'if bz=="All"or bz=="Lateral"then uS=uS..aT end;local uV=it:getAxisCommandType(axisCommandId.lateral)if uV==axisCommandType.byThrottle then local uW=it:composeAxisAccelerationFromThrottle(uS,axisCommandId.lateral)d:setEngineForceCommand(uS,uW,uC)elseif uV==axisCommandType.byTargetSpeed then local uQ=it:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)uK=uK..' , '..uS;uL=uL+uQ end;local uR='thrust analog vertical 'if bz=="All"or bz=="Vertical"then uR=uR..aU end;local uX=it:getAxisCommandType(axisCommandId.vertical)if uX==axisCommandType.byThrottle then local uM=it:composeAxisAccelerationFromThrottle(uR,axisCommandId.vertical)if c9~=0 or b3 and aY then d:setEngineForceCommand(uR,uM,uC,'airfoil','ground','',uE)else d:setEngineForceCommand(uR,vec3(),uC)d:setEngineForceCommand('airfoil vertical',uM,uC,'airfoil','','',uE)d:setEngineForceCommand('ground vertical',uM,uC,'ground','','',uE)end elseif uX==axisCommandType.byTargetSpeed then if c9<0 then d:setEngineForceCommand('hover',vec3(),uC)end;local uY=it:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)uK=uK..' , '..uR;uL=uL+uY end;if uL:len()>constants.epsilon then if bZ~=0 or uU or f9(us:dot(cV))<0.5 then uK=uK..', brake'end;d:setEngineForceCommand(uK,uL,uD,'','','',uE)end end;local uZ=aJ*(uw-uv)local u_=vec3(b.getWorldAirFrictionAngularAcceleration())uZ=uZ-u_;d:setEngineTorqueCommand('torque',uZ,uC,'airfoil','','',uE)d:setBoosterCommand('rocket_engine')if c3 and not n then local fB=cX:len()local v0=0.15;if not d5 then local v1=it:getTargetSpeed(axisCommandId.longitudinal)if fB*3.6>v1*(1-v0)and sY then sY=false;d:toggleBoosters()elseif fB*3.6<v1*(1-v0)and not sY then sY=true;d:toggleBoosters()end else local pg=c.getThrottle()if u then pg=bM*100 end;local rt=pg/100;if bH==0 then rt=rt*a0;if fB>=rt*(1-v0)and sY then sY=false;d:toggleBoosters()elseif fB<rt*(1-v0)and not sY then sY=true;d:toggleBoosters()end else local rG=bG(cM)rt=rt*rG/3.6;if fB>=rt*(1-v0)and sY then sY=false;d:toggleBoosters()elseif fB<rt*(1-v0)and not sY then sY=true;d:toggleBoosters()end end end end end;function tj.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ck>0 or ck==0 and cl<10000)then for d_,dH in pairs(door)do dH.toggle()end end;if switch then for d_,dH in pairs(switch)do dH.toggle()end end;if forcefield and(ck>0 or ck==0 and cl<10000)then for d_,dH in pairs(forcefield)do dH.toggle()end end;x=dm;pI()if nY then nY.activate()end;if A then cE.showWayPoint(i_,d1)end;local ot=1-(a6*0.05+a7*0.05)a.print(cC.FuelUsed("atmofueltank")..", "..cC.FuelUsed("spacefueltank")..", "..cC.FuelUsed("rocketfueltank"))g5("stop","SU")end;function tj.controlStart(sB)if u0 then cG.startControl(sB)end end;function tj.controlStop(sB)if u0 then cG.stopControl(sB)end end;function tj.controlLoop(sB)if u0 then cG.loopControl(sB)end end;function tj.controlInput(sl)if u0 then cG.inputTextControl(sl)end end;function tj.radarEnter(e4)cF.onEnter(e4)end;function tj.radarLeave(e4)cF.onLeave(e4)end;function tj.onTick(v2)if v2=="tenthSecond"then cE.TenthTick()cC.TenthTick()elseif v2=="oneSecond"then cC.OneSecondTick()elseif v2=="fiveSecond"then cE.SatNavTick()elseif v2=="msgTick"then cC.MsgTick()elseif v2=="animateTick"then cC.AnimateTick()elseif v2=="hudTick"then cC.hudtick()elseif v2=="apTick"then cE.APTick()elseif v2=="radarTick"then cF.UpdateRadar()elseif v2=="tagTick"then cG.tagTick()elseif v2=="contact"then cF.ContactTick()end end;return tj end;function script.onStart()v3.onStart()end;function script.onStop()v3.onStop()end;function script.onTick(v2)v3.onTick(v2)end;function script.onFlush()v3.onFlush()end;function script.onUpdate()v3.onUpdate()end;function script.onActionStart(sB)v3.controlStart(sB)end;function script.onActionStop(sB)v3.controlStop(sB)end;function script.onActionLoop(sB)v3.controlLoop(sB)end;function script.onInputText(sl)v3.controlInput(sl)end;function script.onEnter(e4)v3.radarEnter(e4)end;function script.onLeave(e4)v3.radarLeave(e4)end;bE(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)v3=ti(d,b,c,a,library,e,vBooster,hover,pH,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,io,gyro,warpdrive,ip,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
