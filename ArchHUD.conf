name: ArchHud - Archaegeo v0.744 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.744;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=true;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},AtmoSpeedAssist={set=function(L)t=L end,get=function()return t end},ForceAlignment={set=function(L)u=L end,get=function()return u end},DisplayDeadZone={set=function(L)v=L end,get=function()return v end},showHud={set=function(L)w=L end,get=function()return w end},hideHudOnToggleWidgets={set=function(L)x=L end,get=function()return x end},ShiftShowsRemoteButtons={set=function(L)y=L end,get=function()return y end},SetWaypointOnExit={set=function(L)z=L end,get=function()return z end},AlwaysVSpd={set=function(L)A=L end,get=function()return A end},BarFuelDisplay={set=function(L)B=L end,get=function()return B end},voices={set=function(L)C=L end,get=function()return C end},alerts={set=function(L)D=L end,get=function()return D end},CollisionSystem={set=function(L)E=L end,get=function()return E end},AbandonedRadar={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},FullRadar={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1175;W=66000;X=1000;Y=50;Z=0;_=100000;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)aa=L end,get=function()return aa end},AutopilotInterplanetaryThrottle={set=function(L)a0=L end,get=function()return a0 end},warmup={set=function(L)a1=L end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingSpace={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingRocket={set=function(L)a4=L end,get=function()return a4 end},ContainerOptimization={set=function(L)a5=L end,get=function()return a5 end},FuelTankOptimization={set=function(L)a6=L end,get=function()return a6 end},AutoShieldPercent={set=function(L)a7=L end,get=function()return a7 end},EmergencyWarp={set=function(L)a8=L end,get=function()return a8 end}}ab=1920;ac=1080;ad=400;ae=130;af=224;ag=255;ah=255;ai=0;aj=0;ak=960;al=540;am=1300;an=540;ao=1525;ap=325;aq=550;ar=540;as=30;at=700;au=1750;av=250;aw=1750;ax=350;ay=50;az=250;aA=0;aB=30;aC=100;aD={ResolutionX={set=function(L)ab=L end,get=function()return ab end},ResolutionY={set=function(L)ac=L end,get=function()return ac end},circleRad={set=function(L)ad=L end,get=function()return ad end},SafeR={set=function(L)ae=L end,get=function()return ae end},SafeG={set=function(L)af=L end,get=function()return af end},SafeB={set=function(L)ag=L end,get=function()return ag end},PvPR={set=function(L)ah=L end,get=function()return ah end},PvPG={set=function(L)ai=L end,get=function()return ai end},PvPB={set=function(L)aj=L end,get=function()return aj end},centerX={set=function(L)ak=L end,get=function()return ak end},centerY={set=function(L)al=L end,get=function()return al end},throtPosX={set=function(L)am=L end,get=function()return am end},throtPosY={set=function(L)an=L end,get=function()return an end},vSpdMeterX={set=function(L)ao=L end,get=function()return ao end},vSpdMeterY={set=function(L)ap=L end,get=function()return ap end},altMeterX={set=function(L)aq=L end,get=function()return aq end},altMeterY={set=function(L)ar=L end,get=function()return ar end},fuelX={set=function(L)as=L end,get=function()return as end},fuelY={set=function(L)at=L end,get=function()return at end},shieldX={set=function(L)au=L end,get=function()return au end},shieldY={set=function(L)av=L end,get=function()return av end},radarX={set=function(L)aw=L end,get=function()return aw end},radarY={set=function(L)ax=L end,get=function()return ax end},DeadZone={set=function(L)ay=L end,get=function()return ay end},OrbitMapSize={set=function(L)az=L end,get=function()return az end},OrbitMapX={set=function(L)aA=L end,get=function()return aA end},OrbitMapY={set=function(L)aB=L end,get=function()return aB end},soundVolume={set=function(L)aC=L end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=0.0;aV="none"aW="none"aX="none"aY={speedChangeLarge={set=function(L)aE=L end,get=function()return aE end},speedChangeSmall={set=function(L)aF=L end,get=function()return aF end},MouseXSensitivity={set=function(L)aG=L end,get=function()return aG end},MouseYSensitivity={set=function(L)aH=L end,get=function()return aH end},autoRollFactor={set=function(L)aI=L end,get=function()return aI end},rollSpeedFactor={set=function(L)aJ=L end,get=function()return aJ end},autoRollRollThreshold={set=function(L)aK=L end,get=function()return aK end},minRollVelocity={set=function(L)aL=L end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(L)aM=L end,get=function()return aM end},torqueFactor={set=function(L)aN=L end,get=function()return aN end},pitchSpeedFactor={set=function(L)aO=L end,get=function()return aO end},yawSpeedFactor={set=function(L)aP=L end,get=function()return aP end},brakeSpeedFactor={set=function(L)aQ=L end,get=function()return aQ end},brakeFlatFactor={set=function(L)aR=L end,get=function()return aR end},DampingMultiplier={set=function(L)aS=L end,get=function()return aS end},hudTickRate={set=function(L)aT=L end,get=function()return aT end},ExtraEscapeThrust={set=function(L)aU=L end,get=function()return aU end},ExtraLongitudeTags={set=function(L)aV=L end,get=function()return aV end},ExtraLateralTags={set=function(L)aW=L end,get=function()return aW end},ExtraVerticalTags={set=function(L)aX=L end,get=function()return aX end}}aZ=j;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=1000;bb=false;bc=false;bd=false;be=false;bf=0;bg="Aligning"bh=0;bi=1;bj="None"bk=nil;bl=0;bm=nil;bn=0.0;bo=0;bp={}bq=false;br=0;bs=0;bt=nil;bu=0;bv=1000;bw=0;bx=false;by=0;bz=false;bA="All"bB=true;bC="Off"bD=0.000;bE={}bF={}bG={VertTakeOff={set=function(L)b9=L end,get=function()return b9 end},VertTakeOffEngine={set=function(L)a_=L end,get=function()return a_ end},SpaceTarget={set=function(L)bx=L end,get=function()return bx end},BrakeToggleStatus={set=function(L)aZ=L end,get=function()return aZ end},BrakeIsOn={set=function(L)b0=L end,get=function()return b0 end},RetrogradeIsOn={set=function(L)b1=L end,get=function()return b1 end},ProgradeIsOn={set=function(L)b2=L end,get=function()return b2 end},Autopilot={set=function(L)b3=L end,get=function()return b3 end},TurnBurn={set=function(L)b4=L end,get=function()return b4 end},AltitudeHold={set=function(L)b5=L end,get=function()return b5 end},BrakeLanding={set=function(L)b6=L end,get=function()return b6 end},Reentry={set=function(L)b8=L end,get=function()return b8 end},AutoTakeoff={set=function(L)b7=L end,get=function()return b7 end},HoldAltitude={set=function(L)ba=L end,get=function()return ba end},AutopilotAccelerating={set=function(L)bb=L end,get=function()return bb end},AutopilotBraking={set=function(L)bd=L end,get=function()return bd end},AutopilotCruising={set=function(L)be=L end,get=function()return be end},AutopilotRealigned={set=function(L)bc=L end,get=function()return bc end},AutopilotEndSpeed={set=function(L)bf=L end,get=function()return bf end},AutopilotStatus={set=function(L)bg=L end,get=function()return bg end},AutopilotPlanetGravity={set=function(L)bh=L end,get=function()return bh end},PrevViewLock={set=function(L)bi=L end,get=function()return bi end},AutopilotTargetName={set=function(L)bj=L end,get=function()return bj end},AutopilotTargetCoords={set=function(L)bk=L end,get=function()return bk end},AutopilotTargetIndex={set=function(L)bl=L end,get=function()return bl end},TotalDistanceTravelled={set=function(L)bn=L end,get=function()return bn end},TotalFlightTime={set=function(L)bo=L end,get=function()return bo end},SavedLocations={set=function(L)bp=L end,get=function()return bp end},VectorToTarget={set=function(L)bq=L end,get=function()return bq end},LocationIndex={set=function(L)br=L end,get=function()return br end},LastMaxBrake={set=function(L)bs=L end,get=function()return bs end},LockPitch={set=function(L)bt=L end,get=function()return bt end},LastMaxBrakeInAtmo={set=function(L)bu=L end,get=function()return bu end},AntigravTargetAltitude={set=function(L)bv=L end,get=function()return bv end},LastStartTime={set=function(L)bw=L end,get=function()return bw end},iphCondition={set=function(L)bA=L end,get=function()return bA end},stablized={set=function(L)bB=L end,get=function()return bB end},UseExtra={set=function(L)bC=L end,get=function()return bC end},SelectedTab={set=function(L)bH=L end,get=function()return bH end},saveRoute={set=function(L)bE=L end,get=function()return bE end},apRoute={set=function(L)bF=L end,get=function()return bF end}}local function bI(b,c,bJ,bK,bL)local a=DUSystem;local bM=DUConstruct;bN=bJ()bO=0;bP=0;bQ=false;bR=0;bS=false;bT=false;bU=0;bV=0;bW=0;bX=0;bY=false;bZ=false;b_=false;c0="empty"c1=3;c2=false;c3=0;c4=0;c5=nil;c6=0;c7=0;c8=0;c9=false;ca=false;cb=false;cc=-1;cd=bL()>0;ce=bL()cf=b.getAltitude()cg=DUConstruct.getMass()ch=nil;ci=ab;cj=ac;ck={}cl={}cm={}cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=false;cx=false;cy=p;cz=false;cA=V;cB=nil;cC=0;cD=false;cE=false;cF=false;cG=vec3(bM.getWorldOrientationForward())cH=vec3(bM.getWorldOrientationRight())cI=vec3(bM.getVelocity())cJ=vec3(bM.getWorldVelocity())cK=vec3(cJ):len()cL=vec3(b.getWorldVertical())cM=-cL:dot(cJ)cN=vec3(bM.getWorldPosition())cO=false;cP=false;cQ=true;cR=0;cS=0;cT={}cU=false;cV=50000;cW=nil;cX=c.getClosestPlanetInfluence()>0 or cf>0 and cf<200000;cY=false;cZ=nil;c_=false;d0=0;d1=nil;d2=nil;d3={}d4=90;d5=w;d6=nil;d7=nil;d8={}d9={}da=false;db=nil;dc=0;dd=false;de=bM.getMaxSpeed()if shield then df=bK(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dg(dh)a.print(bN..": "..dh)end;local function di(d,b,c,a,dj,dk,dl,dm,dn)local function dp(dq)return type(dq)=='number'end;local function dr(dq)return type(dl(dq))=='number'end;local function ds(dt)return type(dt)=='table'end;local function du(a)return type(a)=='string'end;local function dv(dw)return ds(dw)and dp(dw.x and dw.y and dw.z)end;local function dx(dy)return ds(dy)and dp(dy.latitude and dy.longitude and dy.altitude and dy.id and dy.systemId)end;local dz=math.pi/180;local dA=180/math.pi;local dB=1e-10;local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD='::pos{'..dC..','..dC..','..dC..','..dC..','..dC..'}'local utils=utils;local vec3=vec3;local function dE(dq)local dF=string.gsub(string.reverse(dj('%.4f',dq)),'^0*%.?','')return dF==''and'0'or string.reverse(dF)end;local function dG(dH)if dv(dH)then return dj('{x=%.3f,y=%.3f,z=%.3f}',dH.x,dH.y,dH.z)end;if ds(dH)and not getmetatable(dH)then local dI={}local dJ=next(dH)if type(dJ)=='nil'or dJ==1 then dI=dH else for dK,dw in pairs(dH)do local dL=dG(dw)if type(dK)=='number'then table.insert(dI,dj('[%s]=%s',dK,dL))else table.insert(dI,dj('%s=%s',dK,dL))end end end;return dj('{%s}',table.concat(dI,','))end;if du(dH)then return dj("'%s'",dH:gsub("'",[[\']]))end;return tostring(dH)end;local dM={}dM.__index=dM;dM.__tostring=function(dH,dN)local dO={}for dK in pairs(dH)do table.insert(dO,dK)end;table.sort(dO)local dI={}for dP,dK in ipairs(dO)do local dL=dG(dH[dK])if type(dK)=='number'then table.insert(dI,dj('[%s]=%s',dK,dL))else table.insert(dI,dj('%s=%s',dK,dL))end end;if dN then return dj('%s%s',dN,table.concat(dI,',\n'..dN))end;return dj('{%s}',table.concat(dI,','))end;dM.__eq=function(dQ,dR)return dQ.systemId==dR.systemId and dQ.id==dR.id and dn(dQ.radius,dR.radius)and dn(dQ.center.x,dR.center.x)and dn(dQ.center.y,dR.center.y)and dn(dQ.center.z,dR.center.z)and dn(dQ.GM,dR.GM)end;local function dS(dT,dU,dV,dW,dX)assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(dV),'Argument 3 (radius) must be a number:'..type(dV))assert(ds(dW),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dW))assert(dr(dX),'Argument 5 (GM) must be a number:'..type(dX))return setmetatable({systemId=dl(dT),id=dl(dU),radius=dl(dV),center=vec3(dW),GM=dl(dX)},dM)end;local dY={}dY.__index=dY;dY.__tostring=function(dg)return dj('::pos{%d,%d,%s,%s,%s}',dg.systemId,dg.id,dE(dg.latitude*dA),dE(dg.longitude*dA),dE(dg.altitude))end;dY.__eq=function(dQ,dR)return dQ.id==dR.id and dQ.systemId==dR.systemId and dn(dQ.latitude,dR.latitude)and dn(dQ.altitude,dR.altitude)and(dn(dQ.longitude,dR.longitude)or dn(dQ.latitude,math.pi/2)or dn(dQ.latitude,-math.pi/2))end;local function dZ(d_,dU,e0,e1,e2)local dT=d_;if du(d_)and not e1 and not e2 and not dU and not e0 then dT,dU,e0,e1,e2=e3(d_,dD)assert(dT,'Argument 1 (position string) is malformed.')else assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(e0),'Argument 3 (latitude) must be in degrees:'..type(e0))assert(dr(e1),'Argument 4 (longitude) must be in degrees:'..type(e1))assert(dr(e2),'Argument 5 (altitude) must be in meters:'..type(e2))end;dT=dl(dT)dU=dl(dU)e0=dl(e0)e1=dl(e1)e2=dl(e2)if dU==0 then return setmetatable({latitude=e0,longitude=e1,altitude=e2,id=dU,systemId=dT},dY)end;return setmetatable({latitude=dz*dk(e0,-90,90),longitude=dz*(e1%360),altitude=e2,id=dU,systemId=dT},dY)end;local e4={}e4.__index=e4;e4.__tostring=function(dH,dN)local e5=dN and dN..'  'local e6={}local dO={}for dK in pairs(dH)do table.insert(dO,dK)end;table.sort(dO)for dP,e7 in ipairs(dO)do e8=dH[e7]local e9=dM.__tostring(e8,e5)if dN then table.insert(e6,dj('[%s]={\n%s\n%s}',e7,e9,dN))else table.insert(e6,dj('  [%s]=%s',e7,e9))end end;if dN then return dj('\n%s%s%s',dN,table.concat(e6,',\n'..dN),dN)end;return dj('{\n%s\n}',table.concat(e6,',\n'))end;local function ea(eb)local e={}local pid;for dP,dw in pairs(eb)do local dU=dw.planetarySystemId;if type(dU)~='number'then error('Invalid planetary s ID: '..tostring(dU))elseif pid and dU~=pid then error('Mistringmatch planetary s IDs: '..dU..' and '..pid)end;local ec=dw.bodyId;if type(ec)~='number'then error('Invalid body ID: '..tostring(ec))elseif e[ec]then error('Duplicate body ID: '..tostring(ec))end;setmetatable(dw.center,getmetatable(vec3.unit_x))e[ec]=setmetatable(dw,dM)pid=dU end;return setmetatable(e,e4)end;ed={}local function ee(eb)return setmetatable({galaxyAtlas=eb or{}},ed)end;ed.__index=function(dt,L)if type(L)=='number'then local a=dt.galaxyAtlas[L]return ea(a)end;return rawget(ed,L)end;ed.__pairs=function(dH)return function(dt,dK)local ef,eg=next(dt,dK)return ef,eg and ea(eg)end,dH.galaxyAtlas,nil end;ed.__tostring=function(dH)local eh={}for dP,ei in pairs(dH or{})do local ej=ei:getPlanetarySystemId()local ek=e4.__tostring(ei,'    ')table.insert(eh,dj('  [%s]={%s\n  }',ej,ek))end;return dj('{\n%s\n}\n',table.concat(eh,',\n'))end;ed.BodyParameters=dS;ed.MapPosition=dZ;ed.PlanetarySystem=ea;function ed.createBodyParameters(dT,dU,el,em,en,eo,ep)assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(el),'Argument 3 (surfaceArea) must be a number:'..type(el))assert(ds(em),'Argument 4 (aPosition) must be an array or vec3:'..type(em))assert(ds(en),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(en))assert(dr(eo),'Argument 6 (altitude) must be in meters:'..type(eo))assert(dr(ep),'Argument 7 (gravityAtPosition) must be number:'..type(ep))local dV=dm(el/4/math.pi)local c8=dV+eo;local eq=vec3(em)+c8*vec3(en)local dX=ep*c8*c8;return dS(dT,dU,dV,eq,dX)end;ed.isMapPosition=dx;function ed:getPlanetarySystem(d_)if L==nil then L=0 end;if eg==nil then eg=0 end;local dT=d_;if dx(d_)then dT=d_.systemId end;if type(dT)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(eg)~=e4 then a=ea(a)end;return a end end end;function e4:sizeCalculator(er)return 1.05*er.radius end;function e4:castIntersections(es,et,eu,ev,ew,ex)local ey={}if ew then for dP,er in pairs(ew)do table.insert(ey,er)end else ey=d3 end;if not ex then table.sort(ey,function(ez,eA)local eB=ez.center;local eC=eA.center;return(eB.x-es.x)^2+(eB.y-es.y)^2+(eB.z-es.z)^2<(eC.x-es.x)^2+(eC.y-es.y)^2+(eC.z-es.z)^2 end)end;local eD=et:normalize()for dP,er in ipairs(ey)do local eE=er.center-es;local dV;if eu then dV=eu(er)else dV=self:sizeCalculator(er)end;local eF=eE:dot(eD)local eG=eF^2-(eE:len2()-dV^2)if eG>=0 then local eH=dm(eG)local eI=eF+eH;local eJ=eF-eH;if eJ>0 then return er,eI,eJ elseif eI>0 then return er,eI,nil end end end;return nil,nil,nil end;function e4:closestBody(eK)assert(type(eK)=='table','Invalid coordinates.')local eL,er;local eM=vec3(eK)for dP,eN in pairs(self)do local eO=(eN.center-eM):len2()if(not er or eO<eL)and eN.name~="Space"then er=eN;eL=eO end end;return er end;function e4:convertToBodyIdAndWorldCoordinates(d_)local eP=d_;if du(d_)then eP=dZ(d_)end;if eP.id==0 then return 0,vec3(eP.latitude,eP.longitude,eP.altitude)end;local eN=self:getBodyParameters(eP)if eN then return eP.id,eN:convertToWorldCoordinates(eP)end end;function e4:getBodyParameters(d_)local dU=d_;if dx(d_)then dU=d_.id end;assert(dr(dU),'Argument 1 (id) must be a number:'..type(dU))return self[dU]end;function e4:getPlanetarySystemId()local dP,dw=next(self)return dw and dw.systemId end;function dM:convertToMapPosition(dW)assert(ds(dW),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dW))local eQ=vec3(dW)if self.id==0 then return setmetatable({latitude=eQ.x,longitude=eQ.y,altitude=eQ.z,id=0,systemId=self.systemId},dY)end;local eR=eQ-self.center;local c8=eR:len()local e2=c8-self.radius;local e0=0;local e1=0;if not dn(c8,0)then local eS=eT(eR.y,eR.x)e1=eS>=0 and eS or 2*math.pi+eS;e0=math.pi/2-math.acos(eR.z/c8)end;return setmetatable({latitude=e0,longitude=e1,altitude=e2,id=self.id,systemId=self.systemId},dY)end;function dM:convertToWorldCoordinates(d_)local eP=du(d_)and dZ(d_)or d_;if eP.id==0 then return vec3(eP.latitude,eP.longitude,eP.altitude)end;assert(dx(eP),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eP.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eP.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eU=math.cos(eP.latitude)return self.center+(self.radius+eP.altitude)*vec3(eU*math.cos(eP.longitude),eU*math.sin(eP.longitude),math.sin(eP.latitude))end;function dM:getAltitude(dW)return(vec3(dW)-self.center):len()-self.radius end;function dM:getDistance(dW)return(vec3(dW)-self.center):len()end;function dM:getGravity(dW)local eV=self.center-vec3(dW)local eW=eV:len2()return self.GM/eW*eV/dm(eW)end;return setmetatable(ed,{__call=function(dP,...)return ee(...)end})end;local function eX(d,b,c,a,dm,eY)local co={}local bM=100000000/3600;local eZ=bM*bM;local e_=100;function co.computeAccelerationTime(f0,f1,f2)local f3=bM*math.asin(f0/bM)return(bM*math.asin(f2/bM)-f3)/f1 end;function co.computeDistanceAndTime(f0,f2,f4,f5,f6,f7)f6=f6 or 0;f7=f7 or 0;local f8=f0<=f2;local f9=f5*(f8 and 1 or-1)/f4;local fa=-f7/f4;local fb=f9+fa;if f8 and fb<=0 or not f8 and fb>=0 then return-1,-1 end;local fc,fd=0,0;if f9~=0 and f6>0 then local f3=math.asin(f0/bM)local fe=math.pi*(f9/2+fa)local ff=f9*f6;local fg=bM*math.pi;local dw=function(dt)local fh=(fe*dt-ff*math.sin(math.pi*dt/2/f6)+fg*f3)/fg;local fi=math.tan(fh)return bM*fi/dm(fi*fi+1)end;local fj=f8 and function(a)return a>=f2 end or function(a)return a<=f2 end;fd=2*f6;if fj(dw(fd))then local fk=0;while eY(fd-fk)>0.5 do local dt=(fd+fk)/2;if fj(dw(dt))then fd=dt else fk=dt end end end;local fl=f0;local fm=fd/e_;for fn=1,e_ do local fo=dw(fn*fm)fc=fc+(fo+fl)*fm/2;fl=fo end;if fd<2*f6 then return fc,fd end;f0=fl end;local f3=bM*math.asin(f0/bM)local bN=(bM*math.asin(f2/bM)-f3)/fb;local fp=eZ*math.cos(f3/bM)/fb;local c8=fp-eZ*math.cos((fb*bN+f3)/bM)/fb;return c8+fc,bN+fd end;function co.computeTravelTime(f0,f1,c8)if c8==0 then return 0 end;if f1>0 then local f3=bM*math.asin(f0/bM)local fp=eZ*math.cos(f3/bM)/f1;return(bM*math.acos(f1*(fp-c8)/eZ)-f3)/f1 end;if f0==0 then return-1 end;assert(f0>0,'Acceleration and initial speed are both zero.')return c8/f0 end;return co end;local function fq(d,b,c,a,dj,dk,dl,dm,dn)local vec3=vec3;local di=di(d,b,c,a,dj,dk,dl,dm,dn)local function du(a)return type(a)=='string'end;local function ds(dt)return type(dt)=='table'end;fr={}fr.__index=fr;function fr:escapeAndOrbitalSpeed(e2)assert(self.body)local c8=e2+self.body.radius;if not dn(c8,0)then local fs=dm(self.body.GM/c8)return dm(2)*fs,fs end;return nil,nil end;function fr:orbitalParameters(d_,ft)assert(self.body)assert(ds(d_)or du(d_))assert(ds(ft))local fu=(du(d_)or di.isMapPosition(d_))and self.body:convertToWorldCoordinates(d_)or vec3(d_)local dw=vec3(ft)local fv=fu-self.body.center;local fw=dw:len2()local fx=fv:len()local fy=self.body.GM;local fz=((fw-fy/fx)*fv-fv:dot(dw)*dw)/fy;local eB=fy/(2*fy/fx-fw)local fA=fz:len()local eD=fz:normalize()local fB=eB*(1-fA)local fC=eB*(1+fA)local fD=fB*eD+self.body.center;local fE=fA<=1 and-fC*eD+self.body.center or nil;local fF=dm(eB*fy*(1-fA*fA))local fG=fE and 2*math.pi*dm(eB^3/fy)local fH=math.acos(fz:dot(fv)/(fA*fx))if fv:dot(dw)<0 then fH=-(fH-2*math.pi)end;local fI=math.acos((math.cos(fH)+fA)/(1+fA*math.cos(fH)))local fJ=fI;if fJ<0 then fJ=fJ+2*math.pi end;local fK=fJ-fA*math.sin(fJ)local fL=0;local fM=0;local fN=0;if fG~=nil then fL=fK/(2*math.pi/fG)fM=fG-fL;fN=fM+fG/2;if fH-math.pi>0 then fM=fL;fN=fM+fG/2 end;if fN>fG then fN=fN-fG end end;return{periapsis={position=fD,speed=fF/fB,circularOrbitSpeed=dm(fy/fB),altitude=fB-self.body.radius},apoapsis=fE and{position=fE,speed=fF/fC,circularOrbitSpeed=dm(fy/fC),altitude=fC-self.body.radius},currentVelocity=dw,currentPosition=fu,eccentricity=fA,period=fG,eccentricAnomaly=fI,meanAnomaly=fK,timeToPeriapsis=fM,timeToApoapsis=fN,trueAnomaly=fH}end;local function fO(fP)local eN=di.BodyParameters(fP.systemId,fP.id,fP.radius,fP.center,fP.GM)return setmetatable({body=eN},fr)end;return setmetatable(fr,{__call=function(dP,...)return fO(...)end})end;local function fQ(d,b,c,a,dbHud_1,e,fR,fS,bK,dl,dm,fT,fU)local function fV(fW)local dg=fX:closestBody(fW)if(fW-dg.center):len()>dg.radius+dg.noAtmosphericDensityAltitude then dg=e[0][0]end;return dg end;local function fY()local function fZ(f_,g0)return f_.name<g0.name end;cT={}for dK,dw in pairs(e[0])do cT[#cT+1]={name=dw.name,index=dK}end;table.sort(cT,fZ)end;local function g1(g2,g3)if not g3 then g3=g4.name end;for dK,dw in pairs(g2)do if dw.name and dw.name==g3 then return dK end end;return-1 end;local function g5()d0=bl;if bl==0 then bj="None"c5=nil;g4=nil;return true end;local g6=cT[bl].index;local g7=e[0][g6]if g7.center then bj=g7.name;c5=cn[0][g6]if g4~=nil then if ce==0 then if fR(g8,g9)~=1 then fS(g8,g9)end;if fR(ga,gb)~=1 then fS(ga,gb)end;if fR(gc,gd)~=1 then fS(gc,gd)end;if fR(ge,gf)~=1 then fS(ge,gf)end;if fR(gg,gh)~=1 then fS(gg,gh)end end;if fR(gi,gj)~=1 then fS(gi,gj)end;if fR(gk,gl)~=1 then fS(gk,gl)end;if fR(gm,gn)~=1 then fS(gm,gn)end end;g4=nil else g4=g7;for dP,dw in pairs(cn[0])do if dw.name==g4.planetname then c5=dw;bj=g4.name;break end end;if fR(gi,gj)~=1 then fS(gi,gj)end;if fR(gk,gl)~=1 then fS(gk,gl)end end;if g4==nil then bk=vec3(c5.center)else bk=g4.position end;if c5.planetname~="Space"then if c5.hasAtmosphere then go=bK(c5.radius*(T-1)+c5.noAtmosphericDensityAltitude)else go=bK(c5.radius*(T-1)+c5.surfaceMaxAltitude)end else go=S end;if g4~=nil and g4.planetname=="Space"then bf=0 else dP,bf=cp(c5):escapeAndOrbitalSpeed(go)end;bh=0;bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"return true end;local function gp(gq)if not b3 and not bq and not ca and not bz and not b8 and not cb then if gq==nil then bl=bl+1;if bl>#cT then bl=0 end else bl=bl-1;if bl<0 then bl=#cT end end;if bl==0 then g5()else local g6=cT[bl].index;local g7=e[0][g6]if g7 and(g7~=nil and g7.name=="Space"or bA=="Custom Only"and g7.center or bA=="No Moons"and string.find(g7.name,"Moon")~=nil)then if gq==nil then gp()else gp(1)end else g5()end end else c0="Disengage autopilot before changing Interplanetary Helper"fT("iph","AP")end end;local function gr()local function gs(gt)local gu;if gt then gu=d8 else gu=bp end;local gv=-1;gv=g1(e[0])if gv>-1 then table.remove(e[0],gv)end;gv=-1;gv=g1(gu)if gv~=-1 then c0=g4.name.." saved location cleared"table.remove(gu,gv)end;gp()fY()return gu end;if string.sub(bj,1,1)=="*"then d8=gs(true)else bp=gs(false)end end;local function gw(gx,fW,gy,gz)local function gA(gt)if gt then gu=d8 else gu=bp end;if dbHud_1 or gy or gt then local dg=fV(fW)local gB={position=fW,name=gx,planetname=dg.name,gravity=b.getGravityIntensity(),safe=gz}if not gy then gu[#gu+1]=gB else for dK,dw in pairs(e[0])do if dw.name and gx==dw.name then table.remove(e[0],dK)end end end;table.insert(e[0],gB)fY()g5()c0="Location saved as "..gx.."("..dg.name..")"return gu else c0="Databank must be installed to save permanent locations"end end;if string.sub(gx,1,1)=="*"then d8=gA(true)else bp=gA(false)end end;local gC={}function gC.UpdateAtlasLocationsList()fY()end;function gC.UpdateAutopilotTarget()g5()end;function gC.adjustAutopilotTargetIndex(gq)gp(gq)end;function gC.findAtlasIndex(g2,g3)return g1(g2,g3)end;function gC.UpdatePosition(gD,gE,gF)local function gG(gt)local gu;if gt then gu=d8 else gu=bp end;local gv=g1(gu)if gv~=-1 then if gD~=nil then if gt then gD="*"..gD end;gu[gv].name=gD;bl=bl-1;gp()elseif gF~=nil then if gF then local gH=cf;if gH<1000 then gH=1000 end;gu[gv].agg=fU(gH,0)c0=gu[gv].name.." AGG Altitude:"..gu[gv].agg.." saved ("..gu[gv].planetname..")"return elseif gF==false then gu[gv].agg=nil;c0=gu[gv].name.." AGG Altitude cleared ("..gu[gv].planetname..")"return end else local gI=gu[gv]if gE then gI.heading=cH:cross(cL)*5000;c0=gu[gv].name.." heading saved ("..gu[gv].planetname..")"return elseif gE==false then gI.heading=nil;c0=gu[gv].name.." heading cleared ("..gu[gv].planetname..")"return end;gI.gravity=b.getGravityIntensity()gI.position=cN;gI.safe=true end;c0=gu[gv].name.." position updated ("..gu[gv].planetname..")"else c0="Name Not Found"end end;if string.sub(bj,1,1)=="*"then gG(true)else gG(false)end end;function gC.AddNewLocation(gx,fW,gy,gz)gw(gx,fW,gy,gz)end;function gC.ClearCurrentPosition()gr()end;for dK,dw in pairs(d9)do table.insert(e[0],dw)end;if gJ then for dK,dw in pairs(gJ)do gC[dK]=dw end end;fY()if bl>#cT then bl=0 end;gC.UpdateAutopilotTarget()return gC end;local function gK(b,a,c,radar_1,radar_2,warpdrive,eY,gL,dm,gM,dl,gN,fT)local gO={}local gP={}local gQ={XS=13,S=27,M=55,L=110,XL=221}local gR={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gS={}local gT=0;local gU;local gV;local gW;local gX;local gY={gX}local gZ="Atmo"local g_;local h0;local h1=0;local h2={}local h3;local h4=0;local vec3=vec3;local h5=table.insert;local h6=-4;local h7={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h8,h9;local ha,hb;local function hc()if hd~=nil and h1==0 then gL(hd)a.destroyWidget(h8)a.destroyData(ha)h8,ha,hd=nil,nil,nil;if h0~=nil then gL(h0)a.destroyWidget(h9)a.destroyData(hb)h0,h9,hb=nil,nil,nil end else if h1==1 then gL(hd)hd=nil;h0=a.createWidgetPanel("PeriWinkle")h9=a.createWidget(h0,'periscope')hb=gX.getWidgetDataId()a.addDataToWidget(hb,h9)end;if hd==nil and gT>0 then hd=a.createWidgetPanel(gZ)h8=a.createWidget(hd,'radar')ha=gX.getWidgetDataId()a.addDataToWidget(ha,h8)end;h1=0 end end;local function he()local function hf(hg,hh,hi,hj,hk,hl,hm,hn)hh,hj,hl,hn=vec3(hh),vec3(hj),vec3(hl),vec3(hn)local ho,hp,hq=hg*hg,hi*hi,hk*hk;local fw=hj-hh;local hr=fw:normalize()local hs=fw:len()local ht=hl-hh;local hu=(ht-ht:project_on(hr)):normalize()local hv,hw=ht:dot(hr),ht:dot(hu)local hx=hv*hv+hw*hw;local hy=hr:cross(hu)local hz=(ho-hp+hs*hs)/(2*hs)local hA=(ho-hq+hx-2*hv*hz)/(2*hw)local dy=ho-hz^2-hA^2;local hB=dm(dy)local hC=hh+hr*hz+hu*hA+hy*hB;local hD=hh+hr*hz+hu*hA-hy*hB;if eY((hn-hC):len()-hm)<eY((hn-hD):len()-hm)then return hC else return hD end end;local function hE(hF,fx,hG)local hH=hF.pts;local gv=#hH;local hI=hF.ref;if gv>3 then local hJ,hK,hL,hM=hH[gv],hH[gv-1],hH[gv-2],hH[gv-3]hF.ref=hG;local fu=hf(hJ[1],hJ[2],hK[1],hK[2],hL[1],hL[2],hM[1],hM[2])local hz,hA,hB=fu.x,fu.y,fu.z;if hz==hz and hA==hA and hB==hB then hz=hz+hI[1]hA=hA+hI[2]hB=hB+hI[3]local hN=vec3(hz,hA,hB)hF.center=hN;if hF.lastPos then if(hF.lastPos-hN):len()<2 then local hO=(hN-vec3(hG)):len()if eY(hO-fx)<10 then hF.skipCalc=true end end end;hF.lastPos=hN end;hF.pts={}else local hP={hG[1]-hI[1],hG[2]-hI[2],hG[3]-hI[3]}hH[gv+1]={fx,hP}end end;if radar_1 or radar_2 then ct.assignRadar()end;if gX then gT=#gX.getConstructIds()if gT>0 then local hQ=h3:gmatch('{"constructId[^}]*}[^}]*}')local hR=gX.hasMatchingTransponder;local hS=gX.getConstructKind;local hT=gX.isConstructAbandoned;local hU=gX.getConstructName;local hG={cN["x"],cN["y"],cN["z"]}local hV,hW=0,0;local hX=cK*10;local cX=cX;gW,gV=0,0;gP={}for dw in hQ do local dU,c8,hY=dw:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hZ=gQ[hY]c8=dl(c8)if hR(dU)==1 then h5(gP,dU)end;if not cU and warpdrive and c8<a8 and warpdrive.getStatus()==15 then c0="INITIATING WARP"c1=7;warpdrive.initiate()end;if E then local h_=hS(dU)local i0=F and hT(dU)==1;if i0 or c8<hX and(hZ>27 or h_==4 or h_==6)then gW=gW+1;local gx=hU(dU)local hF=h2[dU]if hF==nil then hZ=hZ+gN;h2[dU]={pts={},ref=hG,name=gx,i=0,radius=hZ,skipCalc=false}hF=h2[dU]end;if not hF.skipCalc then hE(hF,c8,hG)if i0 and not hF.abandoned and hF.center then local bN=a.getArkTime()if h4+5<bN then h4=bN;fT("abRdr","RD")end;a.print("Abandoned Construct: "..gx.." ("..hY.." "..gR[h_]..") at estimated ::pos{0,0,"..hF.center.x..","..hF.center.y..","..hF.center.z.."}")c0="Abandoned Radar Contact ("..hY.." "..gR[h_]..") detected"hF.abandoned=true end;hW=hW+1 else h5(gS,hF)end end;hV=hV+1;if cX and hV>700 or hW>70 or(not cX and hV>300 or hW>30)then coroutine.yield()hV,hW=0,0 end end end;gV=#gS;if gV>0 and(cK>20 or b6)then local er,i1,i2,i3;local i4=0;local i5=cn:getPlanetarySystem(0)i3=cJ:normalize()while i4<gV do coroutine.yield()local i6={table.unpack(gS,i4,math.min(i4+75,gV))}er,i1,i2=i5:castIntersections(cN,i3,nil,nil,i6,true)if er and i2 then cZ={er,i1,i2}break end;i4=i4+75 end;if not er then cZ=nil end else cZ=nil end;gS={}gU=h3:find('identifiedConstructs":%[%]')end end end;local function i7()if gX then gZ="Atmo"if h3:find('worksInAtmosphere":false')then gZ="Space"end end end;function gO.pickType()i7()end;function gO.assignRadar()if radar_2 and h6~=1 then if h6==-1 then if gX==radar_2 then gX=radar_1 else gX=radar_2 end end;gY={gX}h3=gX.getWidgetData()i7()else h3=gX.getWidgetData()end;h6=gX.getOperationalState()end;function gO.UpdateRadar()local i8=coroutine.status(g_)if i8=="suspended"then local dL,i9=coroutine.resume(g_)if i9 then a.print("ERROR UPDATE RADAR: "..i9)end elseif i8=="dead"then g_=coroutine.create(he)local dL,i9=coroutine.resume(g_)end end;function gO.GetRadarHud(ia,ib,aw,ax)local ic,dh;local dC=gV or 0;if gT>0 then if E then dh=dC.."/"..gW.." Plotted : "..gT-gW.." Ignored"else dh="Radar Contacts: "..gT end;ic=gM(aw,ax,dh,"pbright txtbig txtmid")if#gP>0 then ic=ic..gM(ia,ib,"Friendlies In Range","pbright txtbig txtmid")for dK,dw in pairs(gP)do ib=ib+20;ic=ic..gM(ia,ib,gX.getConstructName(dw),"pdim txtmid")end end;if gU==nil and h0==nil then h1=1;ct.ToggleRadarPanel()end;if gU~=nil and h0~=nil then ct.ToggleRadarPanel()end;if hd==nil then ct.ToggleRadarPanel()end else if h6~=1 then ic=gM(aw,ax,gZ.." Radar: "..h7[h6],"pbright txtbig txtmid")else ic=gM(aw,ax,"Radar: No "..gZ.." Contacts","pbright txtbig txtmid")end;if hd~=nil then h1=0;ct.ToggleRadarPanel()end end;return ic end;function gO.GetClosestName(gx)if gX then local dU,dP=gX.getWidgetData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dU~=nil and dU~=""then gx=gx.." "..gX.getConstructName(dU)end end;return gx end;function gO.ToggleRadarPanel()hc()end;function gO.ContactTick()if not id then id=0 end;if bN>id+10 then c0="Radar Contact"fT("rdrCon","RC")id=bN end;c.stopTimer("contact")end;function gO.onEnter(dU)if gX and not cd and not cU then c.setTimer("contact",0.1)end end;function gO.onLeave(dU)if gX and E then if#h2>650 then dU=tostring(dU)h2[dU]=nil end end end;local function ie()gX=nil;if radar_2 and radar_2.getOperationalState()==1 then gX=radar_2 else gX=radar_1 end;h6=gX.getOperationalState()gY={gX}h3=gX.getWidgetData()i7()g_=coroutine.create(he)if ig then for dK,dw in pairs(ig)do gO[dK]=dw end end end;ie()return gO end;local function ih(shield,e3,bK)local ii={}local ij=shield.getResistancesCooldown()local function ik()local il=shield.isActive()if G then if not cU and il==0 and shield.isVenting()~=1 then shield.toggle()elseif cU and il==1 then shield.toggle()end end end;local function im()local io=shield.getStressRatioRaw()local ip=0.5999;if io[1]==0.0 and io[2]==0.0 and io[3]==0.0 and io[4]==0.0 then return end;local iq=shield.setResistances(ip*io[1],ip*io[2],ip*io[3],ip*io[4])if iq==1 then c0="Shield Resistances updated"else c0="Value Exceeded. Failed to update Shield Resistances"end end;function ii.shieldTick()df=bK(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ik()ij=shield.getResistancesCooldown()if ij==0 and df<a7 then im()end end;function ii.setResist(ir)if not shield then c0="No shield found"return elseif ir==nil or ij>0 then c0="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD=dC..', '..dC..', '..dC..', '..dC;local is,it,iu,iv=e3(ir,dD)if iv==nil or is+it+iu+iv>0.6 then c0="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(is,it,iu,iv)==1 then c0="Shield Resistances set"else c0="Resistance setting failed."end end;function ii.ventShield()local iw=shield.getVentingCooldown()if iw>0 then c0="Cannot vent again for "..iw.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c0="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c0="Shields already at max hitpoints"end end;if ix then for dK,dw in pairs(ix)do ii[dK]=dw end end;return ii end;local function iy(d,b,c,a,e,antigrav,hover,shield,warpdrive,iz,eY,bK,dj,iA,bL,iB,iC,eT,bJ,dk,iD,fS,fR,gL,iE,dm,fU,gM,fT,iF,iG,iH,iI,iJ,iK)local bM=DUConstruct;local iL=9.80665;local iM={}local iN={}local iO={}local iP={}local iQ=nil;local iR=nil;local iS=nil;local iT=false;local iU="none"local iV=""local iW=55;local iX=0;local iY=0;local iZ=nil;local i_=ae;local j0=af;local j1=ag;local j2=[[rgb(]]..bK(i_+0.5)..","..bK(j0+0.5)..","..bK(j1+0.5)..[[)]]local j3=[[rgb(]]..bK(i_*0.9+0.5)..","..bK(j0*0.9+0.5)..","..bK(j1*0.9+0.5)..[[)]]local j4=0;local j5=0;local j6=""local j7=bJ()local j8=false;local j9=false;local function ja(dw)if ci==1920 then return dw else return fU(ci*dw/1920,0)end end;local function jb(dw)if cj==1080 then return dw else return fU(cj*dw/1080,0)end end;local function jc()return iE()==0 and g~="keyboard"and iC()==0 end;local function jd()local je="TRAVEL"if not cQ then je="CRUISE"end;if b3 then je="AUTOPILOT"end;return je end;local ic=""local jf=""local jg=""local jh=1;local ji=2;local jj=3;local jk=4;local jl=5;local jm=6;local jn=7;local jo=""local jp=0;local jq=120.0*aT;local jr={}local js={}local jt={}local ju={}local jv={}local jw={}local jx={}jx["atmofueltank"],jx["spacefueltank"],jx["rocketfueltank"]=0,0,0;local jy=0;local function jz(hz,jA,jB,jC,jD,jE)local jF=jy;local jG=jy+5;if not B then jG=jG+5 end;if iC()==1 and not l then jF=jF-50;jG=jG-50 end;if jB=="ATMO"then jo="atmofueltank"elseif jB=="SPACE"then jo="spacefueltank"else jo="rocketfueltank"end;jp=_G[jo.."_size"]if#jC>0 then for L=1,#jC do local gx=jC[L][ji]local jH=jC[L][jn]for jI=1,jp do if jC[L][ji]==iA(c[jo.."_"..jI].getWidgetData()).name then jH=jI;break end end;local jJ=bJ()if jD[L]==nil or jE[L]==nil or jJ-jC[L][jm]>jq then local jK;local jL=0;jL=iB(jC[L][jh])-jC[L][jk]jK=jC[L][jl]if jK>jL then jx[jo]=jx[jo]+jK-jL end;if jH~=0 then local jM=iA(c[jo.."_"..jH].getWidgetData())jE[L]=jM.percentage;jD[L]=jM.timeLeft;if jD[L]=="n/a"then jD[L]=0 end else jE[L]=bK(0.5+jL*100/jC[L][jj])if jK<=jL then jD[L]=0 else jD[L]=bK(0.5+jL/((jK-jL)/(jJ-jC[L][jm])))end end;jC[L][jm]=jJ;jC[L][jl]=jL end;if gx==jA then gx=dj("%s %d",jB,L)end;if jH==0 then gx=gx.." *"end;local jN;if jD[L]==0 then jN=""else jN=iI(jD[L])end;if jE[L]~=nil then local jO=bK(jE[L]*2.55)local jP=dj("rgb(%d,%d,%d)",255-jO,jO,0)local jQ=""if jN~=""and jD[L]<120 or jE[L]<5 then jQ="red "end;local jR=dj("rgb(%d,%d,%d)",dk(bK((255-jO)/2.55),50,100),dk(bK(jO/2.55),0,50),50)local jS="rgb(196,0,255)"if jB=="ATMO"then jS="rgb(0,188,255)"elseif jB=="SPACE"then jS="rgb(239,255,0)"end;local jT=false;if jU~=jS then jT=true end;jU=jS;if B then if jT then jF=jF-5;jG=jG-5 end;jf=jf..dj([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jR,jS,hz,jG,jP,bK(jE[L]*1.7+0.5)-2,hz+1,jG+1,hz+5,jG+14,gx,jE[L],jN)jF=jF-22;jG=jG-22 else jf=jf..gM(hz,jF,gx,jQ.."pdim txtfuel")jf=jf..gM(hz,jG,dj("%d%% %s",jE[L],jN),"pdim txtfuel","fill:"..jP)jF=jF+30;jG=jG+30 end end end end;jy=jF end;local function jV(jW,e2)if ao==0 and ap==0 then return end;if e2<200000 and not cd or e2 and cd then local jX=0;if eY(cM)>1 then jX=45*math.log(eY(cM),10)if cM<0 then jX=-jX end end;jW[#jW+1]=dj([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ao,ap,bK(cM),bK(jX))end;return jW end;local function jY(jZ)local gq=-cL;jZ=jZ-jZ:project_on(gq)local j_=vec3(0,0,1)j_=j_-j_:project_on(gq)local k0=j_:cross(gq)local jX=j_:angle_between(jZ)*constants.rad2deg;if jZ:dot(k0)<0 then jX=360-jX end;return jX end;local function k1(jW,ak,al,k2,k3,cX)if ad==0 then return end;local k4=ad;local k5=20;local k6=bK(k2)if cX then for L=-45,45,5 do local k7=L;jW[#jW+1]=dj([[<g transform="rotate(%f,%d,%d)">]],k7,ak,al)k8=5;if L%15==0 then k8=15 elseif L%10==0 then k8=10 end;jW[#jW+1]=dj([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ak,al+k4+k5-k8,ak,al+k4+k5)end;jW[#jW+1]=gM(ak,al+k4+k5-35,k3,"pdim txt txtmid")jW[#jW+1]=gM(ak,al+k4+k5-25,k6 .." deg","pdim txt txtmid")jW[#jW+1]=dj([[<g transform="rotate(%f,%d,%d)">]],-k2,ak,al)jW[#jW+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ak-5,al+k4+k5-20,ak+5,al+k4+k5-20,ak,al+k4+k5-15)jW[#jW+1]="</g>"end;jW[#jW+1]=[[<g style="clip-path: url(#headingClip);">]]local k9=k6;if cX then k9=jY(cG)end;local ka=20;local kb=bK(k9)local kc=0;local kd=al+k4+k5+20;local ke=ak;if k3~="YAW"then kd=jb(130)ke=ja(960)end;local kf=[[<path class="txttick line" d="]]local kg=bK(kb-(ka+10)-kb%5+0.5)for L=kg+70,kg,-5 do local hz=ke-(-L*5+k9*5)if L%10==0 then kc=10;local dC=L;if dC==360 then dC=0 elseif dC>360 then dC=dC-360 elseif dC<0 then dC=dC+360 end;jW[#jW+1]=gM(hz,kd+15,dC,"txtmid bright")elseif L%5==0 then kc=5 end;if kc==10 then kf=dj([[%s M %f %f v %d]],kf,hz,kd-5,kc)else kf=dj([[%s M %f %f v %d]],kf,hz,kd-2.5,kc)end end;jW[#jW+1]=kf..[["/>]]jW[#jW+1]=dj([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],ke-5,kd-20,ke+5,kd-20,ke,kd-10)if I then if cX then k3="HDG"end;jW[#jW+1]=gM(ja(960),jb(100),kb.."°","dim txt txtmid size14","")jW[#jW+1]=gM(ja(960),jb(85),k3,"dim txt txtmid size20","")end;jW[#jW+1]=[[</g>]]end;local function kh(jW,ki,k2,ak,al,cX,kj,fo)if ad==0 then return end;local k4=ad;local kk=bK(k4*3/5)if k4>0 then local kl=bK(ki)local k8=0;local kf=dj([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k2,ak,al)if not cd then kf=dj([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ak,al)end;jW[#jW+1]=dj([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k4-1,ak,al)jW[#jW+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bK(kl-30-kl%5+0.5),bK(kl+30+kl%5+0.5),5 do if L%10==0 then k8=30 elseif L%5==0 then k8=20 end;local hA=al+-L*5+ki*5;if k8==30 then kf=dj([[%s M %d %f h %d]],kf,ak-kk-k8,hA,k8)if cd then jW[#jW+1]=dj([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k2,ak,al,ak-kk+10,hA+4,L)jW[#jW+1]=dj([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k2,ak,al,ak+kk-10,hA+4,L)if L==0 or L==180 or L==-180 then jW[#jW+1]=dj([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k2,ak,al,ak-kk+20,hA,kk*2-40)end else jW[#jW+1]=gM(ak-kk+10,hA,L,"pdim txt txtmid")jW[#jW+1]=gM(ak+kk-10,hA,L,"pdim txt txtmid")end;kf=dj([[%s M %d %f h %d]],kf,ak+kk,hA,k8)else kf=dj([[%s M %d %f h %d]],kf,ak-kk-k8,hA,k8)kf=dj([[%s M %d %f h %d]],kf,ak+kk,hA,k8)end end;jW[#jW+1]=kf..[["/>]]local km="PITCH"if not cX then km="REL PITCH"end;if ki>90 and not cd then ki=90-(ki-90)elseif ki<-90 and not cd then ki=-90-(ki+90)end;if k4>200 then if cd then if fo>iW then jW[#jW+1]=gM(ak,al-15,"Yaw","pdim txt txtmid")jW[#jW+1]=gM(ak,al+20,kj,"pdim txt txtmid")end;jW[#jW+1]=dj([[<g transform="rotate(%f,%d,%d)">]],-k2,ak,al)else jW[#jW+1]=dj([[<g transform="rotate(0,%d,%d)">]],ak,al)end;jW[#jW+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ak-kk+25,al-5,ak-kk+20,al,ak-kk+25,al+5,ak-kk+50,al+4,kl)jW[#jW+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ak+kk-25,al-5,ak+kk-20,al,ak+kk-25,al+5,ak+kk-30,al+4,kl)jW[#jW+1]="</g>"end;local kn=bK(k4/3)jW[#jW+1]=dj([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ak-kn,al,k4-kn)if not cd and cX then jW[#jW+1]=dj([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k2,ak,al,ak-kk+10,al,kk*2-20)end;jW[#jW+1]="</g>"if k4<200 then if cd and fo>iW then jW[#jW+1]=gM(ak,al-k4,km,"pdim txt txtmid")jW[#jW+1]=gM(ak,al-k4+10,kl,"pdim txt txtmid")jW[#jW+1]=gM(ak,al-15,"Yaw","pdim txt txtmid")jW[#jW+1]=gM(ak,al+20,kj,"pdim txt txtmid")else jW[#jW+1]=gM(ak,al-k4,km,"pdim txt txtmid")jW[#jW+1]=gM(ak,al-k4+15,kl,"pdim txt txtmid")end end end end;local function ko(jW,e2,cX)local kp=aq;local kq=ar;if kp==0 and kq==0 then return end;local kr=78;local ks=19;local kt=cc;if cc~=-1 then jW[#jW+1]=gM(kp+kr,kq+ks+20,dj("AGL: %.1fm",cc),"pdim altsm txtend")end;if cX and(e2<200000 and not cd or e2 and cd)then table.insert(jW,dj([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kp-1,kq-4,kr+2,ks+6,kp+1,kq-1,kr-4,ks))local gv=0;local ku=1;local kv=0;local kw=e2<0;local kx=e2<ky.surfaceMaxAltitude;local kz=9;if kw then kz=0 end;local e2=eY(e2)while gv<6 do local kA=11;local kB=16;local kC=9;local kD=14;local jQ="altsm"if gv>2 then kB=kB+3;kA=kA+2;kD=kD+2;kC=kC-6;jQ="altbig"end;if kw then jQ=jQ.." red"elseif kx then jQ=jQ.." orange"end;local kE=e2/ku%10;local kF=bK(kE)local kG=bK((kF+1)%10)local kH=kv;if gv==0 then kH=kE-kF;if kw then kH=1-kH end end;if kw and(gv==0 or kv~=0)then local gy=kG;kG=kF;kF=gy end;local kI=kB*(kH-1)local kJ=kI+kB;local hz=kp+kC+(6-gv)*kA;local hA=kq+kD;jW[#jW+1]=gM(hz,hA+kI,kG,jQ)jW[#jW+1]=gM(hz,hA+kJ,kF,jQ)gv=gv+1;ku=ku*10;if kF==kz then kv=kH else kv=0 end end;table.insert(jW,[[</g></g>]])end end;local function kK(ft)local kL=-math.deg(eT(ft.y,ft.z))+180;kL=kL-90;if kL<0 then kL=360+kL end;if kL>180 then kL=-180+kL-180 end;return-kL end;local function kM(ft)local k9=math.deg(eT(ft.y,ft.x))-90;if k9<-180 then k9=360+k9 end;return k9 end;local function kN(jW,ft,fo,ak,al)if fo>5 and not cd or fo>iW then local k4=ad;local kO=20;local kP=20;local kQ=kK(ft)local kR=kM(ft)local kS=14;local kT=kS/2;local kU=-kR/kP*k4;local kV=kQ/kO*k4;local hz=ak+kU;local hA=al+kV;local c8=dm(kU^2+kV^2)local kW=[[<circle
                            cx="]]..hz..[["
                            cy="]]..hA..[["
                            r="]]..kT/kS..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hz..[["
                            cy="]]..hA..[["
                            r="]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hz-kS..[[,]]..hA..[[ h ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hz+kT..[[,]]..hA..[[ h ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hz..[[,]]..hA-kS..[[ v ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c8<k4 then jW[#jW+1]=kW else local jX=eT(kV,kU)local kX=4;local kY=ak+k4*math.cos(jX)local kZ=al+k4*math.sin(jX)jW[#jW+1]=dj('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jX*180/math.pi,kY,kZ,kY-kX,kZ-kX/2,kX*2,kX,kY+kX,kZ-kX,kX,kX,-kX,kX)end;if not cd then local k_=vec3(ft)kQ=kK(-k_)kR=kM(-k_)kU=-kR/kP*k4;kV=kQ/kO*k4;hz=ak+kU;hA=al+kV;c8=dm(kU^2+kV^2)if c8<k4 then local l0=[[<circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hz..[[,]]..hA-kS..[[ v ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hz..[[,]]..hA..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hz..[[,]]..hA..[[)" />
                                <path
                                    d="M ]]..hz-kT..[[,]]..hA..[[ h ]]..kS..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hz..[[,]]..hA..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hz..[[,]]..hA..[[)"/>]]jW[#jW+1]=l0 end end end end;local function l1(jW,je,l2,l3)if am==0 and an==0 then return end;l2=bK(l2+0.5)local jF=an+10;local jG=an+20;if iC()==1 and not l then jF=55;jG=65 end;local l4="CRUISE"local c="km/h"local dL=l3;if je=="TRAVEL"or je=="AUTOPILOT"then l4="THROT"c="%"dL=l2;local l5="dim"if l2<0 then l5="red"end;jW[#jW+1]=dj([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l5,am-7,an-50,am,an-50,am,an+50,am-7,an+50,1-eY(l2),am-10,an+50,am-15,an+53,am-15,an+47)end;jW[#jW+1]=gM(am+10,jF,l4,"pbright txtstart")jW[#jW+1]=gM(am+10,jG,dj("%.0f %s",dL,c),"pbright txtstart")if cd and t and cQ and bQ then l2=bK(bR*100+0.5)local l5="red"if l2<0 then l5="red"end;jW[#jW+1]=dj([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l5,1-eY(l2),am-10,an+50,am-15,an+53,am-15,an+47)jW[#jW+1]=gM(am+10,jF+40,"LIMIT","pbright txtstart")jW[#jW+1]=gM(am+10,jG+40,l2 .."%","pbright txtstart")end;if cd and t or b8 then jW[#jW+1]=gM(am+10,jF-40,"LIMIT: "..cA.." km/h","dim txtstart")elseif not cd and b3 then jW[#jW+1]=gM(am+10,jF-40,"LIMIT: "..bK(aa*3.6+0.5).." km/h","dim txtstart")end end;local function l6(jW,l7)if am==0 and an==0 then return end;local l8=an-10;local l9=am+10;jW[#jW+1]=gM(0,0,"","pdim txt txtend")if iC()==1 and not l then l8=75 end;jW[#jW+1]=gM(l9,l8,bK(l7).." km/h","pbright txtbig txtstart")end;local function la(jW)jW[#jW+1]=gM(ja(150),jb(1070),dj("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jW[#jW+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jW[#jW+1]=gM(ja(960),jb(550),"Warning: Invalid Control Scheme Detected","warnings")jW[#jW+1]=gM(ja(960),jb(600),"Keyboard Scheme must be selected","warnings")jW[#jW+1]=gM(ja(960),jb(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lb=ja(960)local lc=jb(860)local ld=jb(880)local le=jb(900)local lf=jb(960)local lg=jb(200)local lh=jb(250)local li=jb(960)if iC()==1 and not l then lc=jb(135)ld=jb(155)le=jb(175)lg=jb(115)lh=jb(95)end;local lj="#222222"local lk="white"local ll="dimmer"local lm="pbright"local ln="#110000"local lo=lj;local lp=ll;if b0 then local lq=""if type(b0)=="string"then lq="-"..b0 end;jW[#jW+1]=gM(lb,lc,"Brake Engaged"..lq,"warnings")ln="#440000"lo=lk;lp=lm elseif bP>0 then jW[#jW+1]=gM(lb,lc,"Auto-Brake Engaged","warnings","opacity:"..bP)end;local lr="#110000"local ls=lj;local lt=ll;if cd and cz and cc==-1 then if not b3 and not bq and not b6 and not cP and not b9 and not b7 then jW[#jW+1]=gM(lb,lg+50,"** STALL WARNING **","warnings")lr="#ff0000"ls=lk;lt=lm;fT("stall","SW",2)end end;if cW then jW[#jW+1]=gM(lb,lg+90,"Flight Assist in Progress","warnings")end;if ch then jW[#jW+1]=gM(lb,li,"Gyro Enabled","warnings")end;local lu="#111100"local lv=lj;local lw=ll;if bm then lu="#775500"lv=lk;lw=lm;if bT then jW[#jW+1]=gM(lb,ld,"Gear Extended","warn")else jW[#jW+1]=gM(lb,ld,"Landed (G: Takeoff)","warnings")end end;if cc>-1 and(not cP or cf<100)then local lx=iH(d:getTargetGroundAltitude())jW[#jW+1]=gM(lb,le,"Hover Height: "..lx,"warn")end;local ly="#000011"local lz=lj;local lA=ll;if c2 then ly="#0000DD"lz=lk;lA=lm;jW[#jW+1]=gM(lb,lf+20,"ROCKET BOOST ENABLED","warn")end;local lB="#001100"local lC=lj;local lD=ll;if antigrav and not q and cP and bv~=nil then lB="#00DD00"lC=lk;lD=lm;local lE="warnings"if eY(cf-antigrav.getBaseAltitude())<501 then lE="warn"end;jW[#jW+1]=gM(lb,lg+40,dj("Target Altitude: %d Singularity Altitude: %d",bK(bv),bK(antigrav.getBaseAltitude())),lE)end;if b3 and bj~="None"then jW[#jW+1]=gM(lb,lg,"Autopilot "..bg,"warn")elseif bt~=nil then jW[#jW+1]=gM(lb,lg+20,dj("LockedPitch: %d",bK(bt)),"warn")elseif bY then jW[#jW+1]=gM(lb,lg+20,"Follow Mode Engaged","warn")elseif b8 or cb then jW[#jW+1]=gM(lb,lg+20,"Re-entry in Progress","warn")end;if b5 or b9 then local lx=iH(ba,2)if b9 then if cP then lx=iH(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jW[#jW+1]=gM(lb,lg,"VTO to "..lx,"warn")elseif b7 and not bz then if ca then jW[#jW+1]=gM(lb,lg,"Takeoff to "..bj,"warn")else jW[#jW+1]=gM(lb,lg,"Takeoff to "..lx,"warn")end;if b0 and not b9 then jW[#jW+1]=gM(lb,lg+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jW[#jW+1]=gM(lb,lg,"Altitude Hold: "..dj("%.1fm",ba),"warn")end end;if b9 and(antigrav~=nil and antigrav)then if ce>0.1 then jW[#jW+1]=gM(lb,lg+20,"Beginning ascent","warn")elseif ce<0.09 and ce>0.05 then jW[#jW+1]=gM(lb,lg+20,"Aligning trajectory","warn")elseif ce<0.05 then jW[#jW+1]=gM(lb,lg+20,"Leaving atmosphere","warn")end end;if bz then if cB~=nil then jW[#jW+1]=gM(lb,lg,cB,"warn")end end;if b6 then if lF then local lG="Brake Landing"if db then lG=lG.."-Aligning"end;if da then lG=lG.."-Drift Limited"end;jW[#jW+1]=gM(lb,lg,lG,"warnings")else jW[#jW+1]=gM(lb,lg,"Coast-Landing","warnings")end end;if b2 then jW[#jW+1]=gM(lb,lg,"Prograde Alignment","crit")end;if b1 then jW[#jW+1]=gM(lb,lg,"Retrograde Alignment","crit")end;local lH="#110000"local lI=lj;local lJ=ll;if cY then lH="#FF0000"lI=lk;lJ=lm;local type;if string.find(cY,"COLLISION")then type="warnings"else type="crit"end;jW[#jW+1]=gM(lb,lh+20,cY,type)elseif ce==0 then local lK,lL=cs.checkLOS(cJ:normalize())if lL~=nil then lJ=lm;lH="#FF0000"lI=lk;local lx=iH(lL)local lM=co.computeTravelTime(cK,0,lL)local lN="Collision"if lK.noAtmosphericDensityAltitude>0 then lN="Atmosphere"end;jW[#jW+1]=gM(lb,lh+20,lK.name.." "..lN.." "..iI(lM).." In "..lx,"crit")end end;if bq and not bz then jW[#jW+1]=gM(lb,lg+60,lO,"warn")end;local lP="#111100"local lQ=lj;local lR=ll;if d1 and#d1>1 then lP="#DDDD00"lQ=lk;lR=lm end;local lS=ja;local lT=jb;local ll="topButton"local lU="topButtonActive"local lV=ll;if b3 or bq or ca or bz then lV=lU end;local lW=ll;if b2 then lW=lU end;local lX=ll;if b6 or bm then lX=lU end;local lY=ll;if b5 or bq then lY=lU end;local lZ=ll;if b1 then lZ=lU end;local l_=ll;if bz or cD and b3 then l_=lU end;if w and I then local m0=lT(30)jW[#jW+1]=dj([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lV,lS(960),lT(54),lT(-53),lS(-120),lS(25),lT(50))jW[#jW+1]=gM(lS(910),m0,"AUTOPILOT")jW[#jW+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lW,lS(865),lT(51),lS(-25),lT(-50),lS(-110),lS(25),lT(46))jW[#jW+1]=gM(lS(800),m0,"PROGRADE")jW[#jW+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lX,lS(755),lT(47),lS(-25),lT(-46),lS(-98),lS(44),lT(44))jW[#jW+1]=gM(lS(700),m0,"LAND")jW[#jW+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lY,lS(960),lT(54),lT(-53),lS(120),lS(-25),lT(50))jW[#jW+1]=gM(lS(1010),m0,"ALT HOLD")jW[#jW+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lZ,lS(1055),lT(51),lS(25),lT(-50),lS(110),lS(-25),lT(46))jW[#jW+1]=gM(lS(1122),m0,"RETROGRADE")jW[#jW+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],l_,lS(1165),lT(47),lS(25),lT(-46),lS(98),lS(-44),lT(44))jW[#jW+1]=gM(lS(1220),m0,"ORBIT")jW[#jW+1]=[[
                                    </g>
                                </g>]]jW[#jW+1]="</g>"end;return jW end;local function m1(fo)return bK(fU(fo*3.6,0)+0.5).." km/h"end;local function m2(gv)local gx=bj;if gv~=nil and type(gv)=="number"then if gv==0 then return"None"end;gx=cT[gv].name end;if gx==nil then gx=g4.name end;if gx==nil then gx="None"end;return gx end;local function m3(jW)local m4=cs.routeWP(true)if not m4 or#m4==0 then return end;local hz=ja(750)local hA=jb(360)if b3 or bq then jW[#jW+1]=gM(hz,hA,"REMAINING ROUTE","pdim txtstart size20")else jW[#jW+1]=gM(hz,hA,"LOADED ROUTE","pdim txtstart size20")end;for dK,L in pairs(m4)do hA=hA+20;jW[#jW+1]=gM(hz,hA,dK..". "..m4[dK],"pdim txtstart size20")end end;local function m5(jW)local hz=aA+10;local hA=aB+20;local m6={}local m7={"Alt-4: AutoTakeoff to Target"}local m8={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m9={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local ma={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(m6,"--------------DYNAMIC-----------------")if cd then if cc~=-1 then iF(m6,m7)if c5 and ky and c5.name==ky.name then table.insert(m6,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or a_ then if antigrav then if cP then table.insert(m6,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(m6,"Turn on AGG to takeoff to AGG Height")end end;if a_ then table.insert(m6,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(m6,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(m6,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bm then table.insert(m6,"G: Takeoff to hover height, raise gear")else table.insert(m6,"G: Lowergear and Land")end else iF(m6,m8)table.insert(m6,"G: Begin BrakeLanding or Land")end;if b9 then table.insert(m6,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iF(m6,m9)if shield then table.insert(m6,"Alt-Shift-6: Vent shields")if not G then table.insert(m6,"Alt-Shift-7: Toggle shield off/on")end end end;if g4~=nil then table.insert(m6,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(m6,"Alt-9: Activate Gyroscope")end;if aW~="none"or aV~="none"or aX~="none"then table.insert(m6,"Alt-Shift-9: Cycles engines with Extra tags")end;if b5 then table.insert(m6,"Alt-Spacebar/C will raise/lower target height")table.insert(m6,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cd then table.insert(m6,"LALT+Mousewheel will lower/raise speed limit")end;iF(m6,ma)for L=1,#m6 do hA=hA+12;jW[#jW+1]=gM(hz,hA,m6[L],"pdim txtbig txtstart")end end;local function mb(jW)local mc=aA;local md=aB;local me=az;local mf=4;local mg=15;local hz=0;local hA=0;local mh,mi,mj,mk;local ml;local function mm(type)local gH,bN,fo,mn,jQ,mo;if type=="Periapsis"then gH=ml.periapsis.altitude;bN=ml.timeToPeriapsis;fo=ml.periapsis.speed;jQ="txtend"mn=12;mo=math.min(hz,mc+me-ky.radius/mj-mf*2)else gH=ml.apoapsis.altitude;bN=ml.timeToApoapsis;fo=ml.apoapsis.speed;mn=-12;jQ="txtstart"mo=hz end;if cK<1 then bN=0 end;jW[#jW+1]=dj([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mo+mn,hA-5,hz,hA-5)jW[#jW+1]=dj([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mo-mn*4,hA+2,hz,hA+2)jW[#jW+1]=gM(mo,hA,type,jQ)hz=mo-mn*2;hA=hA+mg;local lx=iH(gH)jW[#jW+1]=gM(hz,hA,lx,jQ)hA=hA+mg;jW[#jW+1]=gM(hz,hA,iI(bN),jQ)hA=hA+mg;jW[#jW+1]=gM(hz,hA,m1(fo),jQ)end;local mp=me*1.5;if bH=="INFO"then mp=25*10 end;if bH~="HIDE"then jW[#jW+1]=[[<g class="pbright txtorb txtmid">]]jW[#jW+1]=dj('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',me*2,mp,mc,md)jW[#jW+1]=dj([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],me*2,mp,mc,md)end;local mq=me*1.5;local mr=me*2;local ms=mq/2;local mt=me;local mu=mc+mt;local mv=md+ms;local mw=mc+mr;local mx=md+mq;if bH=="ORBIT"then md=md+mf;mh=me/2;mk=0;ml={}ml.periapsis={}ml.apoapsis={}if fs~=nil then if fs.periapsis~=nil then ml.periapsis.altitude=fs.periapsis.altitude;ml.periapsis.speed=fs.periapsis.speed end;if fs.apoapsis~=nil then ml.apoapsis.altitude=fs.apoapsis.altitude;ml.apoapsis.speed=fs.apoapsis.speed end;ml.period=fs.period;ml.eccentricity=fs.eccentricity;ml.timeToApoapsis=fs.timeToApoapsis;ml.timeToPeriapsis=fs.timeToPeriapsis;ml.eccentricAnomaly=fs.eccentricAnomaly;ml.trueAnomaly=fs.trueAnomaly end;if ml.periapsis==nil then ml.periapsis={}ml.periapsis.altitude=-ky.radius;ml.periapsis.speed=aa end;if ml.eccentricity==nil then ml.eccentricity=1 end;if ml.apoapsis==nil then ml.apoapsis={}ml.apoapsis.altitude=cf;ml.apoapsis.speed=0 end;if cK<1 then ml.apoapsis.altitude=cf;ml.apoapsis.speed=0 end;if ml.apoapsis.altitude then mj=(ml.apoapsis.altitude+ml.periapsis.altitude+ky.radius*2)/(mh*2)mi=(ky.radius+ml.apoapsis.altitude)/mj*(1-ml.eccentricity)mk=mh-ml.periapsis.altitude/mj-ky.radius/mj;local my=math.pi;if ml.period~=nil and ml.period>0 and ml.timeToApoapsis~=nil then my=ml.eccentricAnomaly;if ml.timeToPeriapsis<ml.timeToApoapsis then my=2*math.pi-my end end;if cK<1 or my~=my then my=math.pi end;local mz=-mh*math.cos(my)+mc+mt+mf;local mA=mi*math.sin(my)+md+ms+mf;local mB=""jW[#jW+1]='<g clip-path="url(#orbitRect)">'jW[#jW+1]=dj([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mB,mc+me+mf,md+me*1.5/2+mf,mh,mi)if mi<1 then jW[#jW+1]=dj([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],mc+me+mf-mk,md+me*1.5/2+mf,mz,mA)end;jW[#jW+1]=dj('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',mc+me+mf-mk,md+me*1.5/2+mf,(ky.radius+ky.noAtmosphericDensityAltitude)/mj)jW[#jW+1]=dj('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',mc+me+mf-mk,md+me*1.5/2+mf,(ky.radius+ky.noAtmosphericDensityAltitude)/mj)jW[#jW+1]=dj([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",mc+me+mf,md+me*1.5/2+mf,mh,mi)jW[#jW+1]=dj('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',mc+me+mf-mk,md+me*1.5/2+mf,ky.radius/mj)jW[#jW+1]='</g>'local mC=math.floor(ky.radius/mj+0.5)hz=mc+me+mf*4+mh;hA=md+me*1.5/2+5+mf;if ml.apoapsis~=nil and ml.apoapsis.speed<aa then mm("Apoapsis")end;hA=md+me*1.5/2+5+mf;hz=mc+me-mf*2-mh;if ml.periapsis~=nil and ml.periapsis.speed<aa and ml.periapsis.altitude>0 then mm("Periapsis")end;jW[#jW+1]=gM(mc+me+mf,md+20+mf,ky.name,"txtorbbig")jW[#jW+1]=dj('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mz,mA)jW[#jW+1]=[[</g>]]return jW else jW[#jW+1]='<g clip-path="url(#orbitRect)">'local mD=""local mE=1.2*(mF-mG)/(me*2)local mH=1.4*(mI-mJ)/(me*1.5)for dK,dw in pairs(e[0])do if dw.center then local hz=mc+me+dw.center.x/mE;local hA=md+me*1.5/2+dw.center.y/mH;mD=mD..'<circle cx="'..hz..'" cy="'..hA..'" r="'..dw.radius/mE*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dw.name,"Moon")and not string.match(dw.name,"Sanctuary")and not string.match(dw.name,"Space")then mD=mD.."<text x='"..hz.."' y='"..hA+dw.radius/mE*30+20 .."' font-size='12' fill="..j2 .." text-anchor='middle' font-family='Montserrat'>"..dw.name.."</text>"end end end;local fu=vec3(bM.getWorldPosition())local hz=mc+me+fu.x/mE;local hA=md+me*1.5/2+fu.y/mH;mD=mD..'<circle cx="'..hz..'" cy="'..hA..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mD=mD.."<text x='"..hz.."' y='"..hA-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iQ=mE;iR=mH;local mK=fu+cJ*1000000;local mL=mc+me+mK.x/mE;local jG=md+me*1.5/2+mK.y/mH;mD=mD..'<line x1="'..hz..'" y1="'..hA..'" x2="'..mL..'" y2="'..jG..'" stroke="purple" stroke-width="1"/>'jW[#jW+1]=mD;jW[#jW+1]='</g>'end elseif bH=="INFO"then jW=cq.DrawOdometer(jW,j4,bn,j5)elseif bH=="HELP"then jW=m5(jW)elseif bH=="SCOPE"then jW[#jW+1]='<g clip-path="url(#orbitRect)">'local mM=d4;if ce>0 then table.sort(d3,function(ez,eA)local eB,eC=ez.center,eA.center;return(eB.x-cN.x)^2+(eB.y-cN.y)^2+(eB.z-cN.z)^2<(eC.x-cN.x)^2+(eC.y-cN.y)^2+(eC.z-cN.z)^2 end)end;local mN={}local mO={}local mP=120;local mQ=nil;local mR=nil;for L,dw in ipairs(d3)do local gU=dw.center-cN;local mS=gU:len()local mT=gU:normalize()local mU=gU:cross(cG):normalize()local mV=math.acos(mU:dot(cH))if mV~=mV then mV=0 end;if mU:cross(cH):dot(cG)<0 then mV=-mV end;local mW=gU:project_on_plane(cG):len()local mX=math.sin(mV)*math.asin(mW/mS)*constants.rad2deg;local mY=math.cos(mV)*math.asin(mW/mS)*constants.rad2deg;if mT:dot(cG)<0 then mY=90*math.cos(mV)+90*math.cos(mV)-mY;mX=90*math.sin(mV)+90*math.sin(mV)-mX end;local hz=mu+mX/mM*mq;local hA=mv+mY/mM*mq;local mZ=(hz-mu)*(hz-mu)+(hA-mv)*(hA-mv)local m_=math.asin((dw.radius+dw.surfaceMaxAltitude)/mS)*constants.rad2deg;if m_~=m_ then m_=mM end;local hY=m_/mM*mq;local n0=math.asin(dw.atmosphereRadius/mS)*constants.rad2deg;if n0~=n0 then n0=m_ end;local n1=n0/mM*mq;local c8=iH(mS,1)local n2=dw.name;local n3=false;if hA>md then if hA>mx then if hA-n1<=mx then n3=true end else n3=true end else if hA+n1>=md then n3=true end end;local n4=false;local n5=hz;if dw.systemId==0 then n5=hz+mP else n5=hz-mP end;if n5+mP>mc then if n5+mP>mw then if n5-n1-mP<=mw then n4=true end else n4=true end else if n5+n1+mP>=mc then n4=true end end;local n6={}n6.x=hz;n6.y=hA;n6.planet=dw;n6.atmoSize=n1;if not mQ or mZ<mQ then mQ=mZ;mR=n6 end;if n4 and n3 then local n7=math.max(n1,5)if mZ<n7*n7 then n2=n2 .." - "..c8 end;n6.size=hY;n6.i=L;n6.displayString=n2;n6.distance=c8;n6.visible=true;mO[#mO+1]=n6 else n6.visible=false end end;local n8=false;table.sort(mO,function(eB,eC)return eB.y<eC.y end)for dK,fx in ipairs(mO)do local dw,hY,L,n1,hz,hA,n2,c8=fx.planet,fx.size,fx.i,fx.atmoSize,fx.x,fx.y,fx.displayString,fx.distance;local mo,n9,na,nb;local nc=15;local jQ="pdim"if dw.systemId~=0 then na=ja(string.len(n2)*5)nc=-(15+na)nb=jb(10)jQ="pdimfill"else na=ja(string.len(n2)*9)nb=jb(15)end;if hY*2>na then mo=dk(hz,mc+na/2,mw-na/2)n9=dk(hA,md+nb,mx-5)mo=dk(mo,hz-hY+na/2,hz+hY-na/2)n9=dk(n9,hA-hY+nb,hA+hY)else mo=hz+nc;n9=hA end;for nd,fx in pairs(mN)do local ne=fx.textPositions;local nf=ne.y-n9;if nd~=L and eY(nf)<ne.height and ne.x+ne.width>mo and ne.x<mo+na then if hY>na then n9=dk(n9+nb,md+15,mx-5)else n9=ne.y+ne.height+1 end end end;local ng=n2~=dw.name or mo<=mu and mo+na>=mu and n9-nb<=mv and n9>=mv;fx.hovered=ng;local nh=1;if ng then nh=2;if hY*2<na then nh=10 end;if n2==dw.name then n2=n2 .." - "..c8 end;jQ="pbright"if dw.systemId~=0 then na=ja(string.len(n2)*5)nc=-(15+na)else na=ja(string.len(n2)*7)end;if hY*2>na then mo=dk(hz,mc+na/2,mw-na/2)mo=dk(mo,hz-hY+na/2,hz+hY-na/2)else mo=hz+nc end end;mN[L]={}mN[L].textPositions={}mN[L].textPositions.y=n9;mN[L].textPositions.x=mo;mN[L].textPositions.width=na;mN[L].textPositions.height=nb;mN[L].output=""if hY*2>na then jQ=jQ.." txtmid"else jQ=jQ.." txtstart"end;if n1-hY>2 then mN[L].output=dj('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hz,hA,n1,j3,0.1*nh)end;mN[L].output=mN[L].output..dj('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hz,hA,hY,j3,0.2*nh)if dw.systemId==0 then mN[L].output=mN[L].output..dj([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mo,n9,j2,jQ,n2)if hY*2<=na then mN[L].output=mN[L].output..dj("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mo+na,n9+2,mo,n9+2,hz,hA)end else mN[L].output=mN[L].output..dj([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mo,n9,j3,jQ,n2)if hY*2<=na then mN[L].output=mN[L].output..dj("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mo,n9+2,mo+na,n9+2,hz,hA)end end end;for dK=#d3,1,-1 do if mN[dK]then jW[#jW+1]=mN[dK].output end end;if mR~=nil and d4<90 and not mR.hovered then local ni=mR.planet.atmosphereRadius/mR.atmoSize;local nj=dm(mQ)*ni;local nk=iH(nj,1)local na=ja(math.max(string.len(nk)*7,string.len(mR.planet.name)*7))local nb=jb(12)local mo=dk(mR.x+(mu-mR.x)/2,mc+na/2,mw-na/2)local n9=dk(mR.y+(mv-mR.y)/2,md+nb*2,mx-5)jW[#jW+1]=dj("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mR.x,mR.y,mu,mv)jW[#jW+1]=dj([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mo,n9,"white",nk)if not mR.visible then jW[#jW+1]=dj([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mo,n9-nb,"white",mR.planet.name)end end;if cK>1 then local gU=cJ;local mT=gU:normalize()local mW=gU:project_on_plane(cG):len()local mU=gU:cross(cG):normalize()local mV=math.acos(mU:dot(cH))if mV~=mV then mV=0 end;if mU:cross(cH):dot(cG)<0 then mV=-mV end;local mX=math.sin(mV)*math.asin(mW/gU:len())*constants.rad2deg;local mY=math.cos(mV)*math.asin(mW/gU:len())*constants.rad2deg;if mT:dot(cG)<0 then mY=90*math.cos(mV)+90*math.cos(mV)-mY;mX=90*math.sin(mV)+90*math.sin(mV)-mX end;local hz=mu+mX/mM*mq;local hA=mv+mY/mM*mq;local kS=14;local kT=kS/2;local kW=[[<circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kT/kS..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hz..[["
                                    cy="]]..hA..[["
                                    r="]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hz-kS..[[,]]..hA..[[ h ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hz+kT..[[,]]..hA..[[ h ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hz..[[,]]..hA-kS..[[ v ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jW[#jW+1]=kW end;jW[#jW+1]=dj("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mu,mv-10,mu,mv+10)jW[#jW+1]=dj("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mu-10,mv,mu+10,mv)jW[#jW+1]='</g>'else return jW end end;local function nl(nm,nn)local no;local np=(nn-nm):normalize()local fv=(cN-nm):dot(np)/np:dot(np)if fv<=0. then return(cN-nm):len()elseif fv>=(nn-nm):len()then return(cN-nn):len()end;local nq=nm+fv*np;no=(nq-cN):len()return no end;local function nr()local no;local ns=nil;local nt=nil;local nu=nil;for dK,nv in pairs(e[0])do if nv.hasAtmosphere then local c8=nl(ky.center,nv.center)if ns==nil or c8<ns then nt=nv;ns=c8;nu=ky end;if c5 and c5.hasAtmosphere and c5.name~=ky.name then local eO=nl(c5.center,nv.center)if eO<ns then nt=nv;ns=eO;nu=c5 end end end end;local nw=ja(1770)local nx=jb(330)if ns then local ny="txttick "local nz=500000;if ns<nt.radius+nz or ns<nu.radius+nz then if cU then ny="txttick red "else ny="txttick orange "end end;no=iH(ns,2)iV=gM(nw,nx,"Pipe ("..nu.name.."--"..nt.name.."): "..no,ny.."pbright txtmid")end end;local function nA(hz,hA,nB,nC,l4)local nD={x=hz,y=hA,width=nB,height=nC,label=l4}iP[l4]=nD;return nD end;local function nE(nF,nG,nB,nC,hz,hA,nH,nI,nJ,nK,jQ)local nD={enableName=nF,disableName=nG,width=nB,height=nC,x=hz,y=hA,toggleVar=nH,toggleFunction=nI,drawCondition=nJ,hovered=false,class=jQ}if nK then table.insert(iO,nD)else table.insert(iN,nD)end;return nD end;local function nL(nM)if not iT then nN=false;nO=false;nP=false;w=true;return elseif nM=="handling"then nN=not nN;nO=false;nP=false elseif nM=="hud"then nO=not nO;nN=false;nP=false elseif nM=="physics"then nP=not nP;nN=false;nO=false end;if nP or nO or nN then iU=iG(nM)w=false else iU="none"w=true end end;local function nQ()iT=not iT;if iT then iM=iO;c0="Tap SHIFT to see Settings"d5=w else iM=iN;c0="Tap SHIFT to see Control Buttons"nL()w=d5 end end;local function nR()local function nS(dw,dK)dw.set(not dw.get())if dw.get()then c0=dK.." set to true"else c0=dK.." set to false"end;if dK=="showHud"then d5=dw.get()elseif dK=="BrakeToggleDefault"then aZ=j end end;local nT=50;local nU=340;local hz=500;local hA=cj/2-400;local nV=0;for dK,dw in pairs(iG("boolean"))do if type(dw.get())=="boolean"then nE(dK,dK,nU,nT,hz,hA,function()return dw.get()end,function()nS(dw,dK)end,function()return true end,true)hA=hA+nT+20;if nV==9 then hz=hz+nU+20;hA=cj/2-400;nV=0 else nV=nV+1 end end end;nE("Control View","Control View",nU,nT,10,cj/2-500,function()return true end,nQ,function()return true end,true)nE("View Handling Settings",'Hide Handling Settings',nU,nT,10,cj/2-(500-nT),function()return nN end,function()nL("handling")end,function()return true end,true)nE("View Hud Settings",'Hide Hud Settings',nU,nT,10,cj/2-(500-nT*2),function()return nO end,function()nL("hud")end,function()return true end,true)nE("View Physics Settings",'Hide Physics Settings',nU,nT,10,cj/2-(500-nT*3),function()return nP end,function()nL("physics")end,function()return true end,true)end;local function nW()local function gw()local fW=cN;local gx=ky.name..". "..#bp;if ct then gx=ct.GetClosestName(gx)end;return cr.AddNewLocation(gx,fW,false,true)end;local function nX()b4=not b4 end;local function nY(nZ)if nZ==1 then b2=not b2;b1=false else b1=not b1;b2=false end;b3=false;b5=false;bY=false;b6=false;bt=nil;b8=false;b7=false end;local function n_(o0,o1)cr.UpdatePosition(nil,o0,o1)end;local function gr()cr.ClearCurrentPosition()end;local function o2(gv)local m4=cs.routeWP(true)if m4 and#m4>0 then return"Engage Route: "..m4[1]end;return"Engage Autopilot: "..m2(gv)end;local function o3(gv)local m4=cs.routeWP(true)if m4 and#m4>0 then return"Next Route Point: "..m4[1]end;return"Disable Autopilot: "..m2(gv)end;local function o4()if iC()==1 then bY=not bY;if bY then b3=false;b1=false;b2=false;b5=false;b8=false;b6=false;b7=false;o5=bm;bm=false;d.control.retractLandingGears()iD:setTargetGroundAltitude(Y)fT("folOn","F")else fT("folOff","F")b0="Follow Off"cy=p;bm=o5;if bm then d.control.deployLandingGears()iD:setTargetGroundAltitude(Z)end end else c0="Follow Mode only works with Remote controller"bY=false end end;local nT=50;local nU=260;local o6=ja(30)local o7=aA+az*2+2;local o8=aB+1;nE("+","+",o6,o6,o7,o8+o6+1,function()return false end,function()d4=d4/8 end,function()return bH=="SCOPE"end,nil,"ZoomButton")nE("-","-",o6,o6,o7,o8,function()return false end,function()d4=math.min(d4*8,90)end,function()return bH=="SCOPE"end,nil,"ZoomButton")nE("0","0",o6,o6,o7,o8+o6*2+2,function()return false end,function()d4=90 end,function()return bH=="SCOPE"and d4~=90 end,nil,"ZoomButton")local o9=nE("Enable Brake Toggle","Disable Brake Toggle",nU,nT,ci/2-nU/2,cj/2+350,function()return aZ end,function()aZ=not aZ;if aZ then c0="Brakes in Toggle Mode"else c0="Brakes in Default Mode"end end)nE("Align Prograde","Disable Prograde",nU,nT,ci/2-nU/2-50-o9.width,cj/2-nT+380,function()return b2 end,function()nY(1)end)nE("Align Retrograde","Disable Retrograde",nU,nT,ci/2-nU/2+o9.width+50,cj/2-nT+380,function()return b1 end,nY,function()return ce==0 end)oa=nE(o2,o3,600,60,ci/2-600/2,cj/2-60/2-330,function()return b3 or bq or ca or bz end,function()end)local L;local function ob(oc)local gv=d0+oc;if gv>#cT then gv=gv-#cT-1 end;if gv<0 then gv=#cT+gv end;return gv end;od={}for L=0,10 do local oe=nE(function(eC)local gv=ob(eC.apExtraIndex)if b3 or bq or ca or bz then return"Redirect: "..m2(gv)end;return o2(gv)end,function(eC)local gv=ob(eC.apExtraIndex)return o3(gv)end,600,60,ci/2-600/2,cj/2-60/2-330+60*L,function(eC)local gv=ob(eC.apExtraIndex)return gv==bl and(b3 or bq or ca or bz)end,function(eC)local gv=ob(eC.apExtraIndex)local of=bl==gv;bl=gv;cr.UpdateAutopilotTarget()cs.ToggleAutopilot()if not of and not(b3 or bq or ca or bz)then cs.ToggleAutopilot()end end,function()return c_ and(#cs.routeWP(true)==0 or L==0)end)oe.apExtraIndex=L;od[L]=oe end;nE("Save Position","Save Position",200,oa.height,oa.x+oa.width+30,oa.y,function()return false end,gw,function()return bl==0 or g4==nil end)nE("Update Position","Update Position",200,oa.height,oa.x+oa.width+30,oa.y,function()return false end,function()n_(nil)end,function()return bl>0 and g4~=nil end)nE("Save Heading","Clear Heading",200,oa.height,oa.x+oa.width+30,oa.y+oa.height+20,function()return g4.heading~=nil end,function()if g4.heading~=nil then n_(false)else n_(true)end end,function()return bl>0 and g4~=nil end)nE("Save AGG Alt","Clear AGG Alt",200,oa.height,oa.x+oa.width+30,oa.y+oa.height*2+40,function()return g4.agg~=nil end,function()if g4.agg~=nil then n_(nil,false)else n_(nil,true)end end,function()return bl>0 and g4~=nil and antigrav end)nE("Clear Position","Clear Position",200,oa.height,oa.x-200-30,oa.y,function()return true end,gr,function()return bl>0 and g4~=nil end)nE("Save Route","Save Route",200,oa.height,oa.x-200-30,oa.y+oa.height*2+40,function()return false end,function()cs.routeWP(false,false,2)end,function()return#cs.routeWP(true)>0 end)nE("Load Route","Clear Route",200,oa.height,oa.x-200-30,oa.y+oa.height+20,function()return#cs.routeWP(true)>0 end,function()if#cs.routeWP(true)>0 then cs.routeWP(false,true)elseif b3 or bq then c0="Disable Autopilot before loading route"return else cs.routeWP(false,false,1)end end,function()return true end)nT=60;nU=300;local hz=0;local hA=cj/2-150;nE("Enable Check Damage","Disable Check Damage",nU,nT,hz,hA-nT-20,function()return s end,function()s=not s end)nE("View Settings","View Settings",nU,nT,hz,hA,function()return true end,nQ)hA=hA+nT+20;nE("Enable Turn and Burn","Disable Turn and Burn",nU,nT,hz,hA,function()return b4 end,nX)hz=10;hA=cj/2-300;nE("Horizontal Takeoff Mode","Vertical Takeoff Mode",nU,nT,ci/2-nU/2,hA+20,function()return a_ end,function()a_=not a_;if a_ then c0="Vertical Takeoff Mode"else c0="Horizontal Takeoff Mode"end end,function()return cO end)hA=hA+nT+20;nE("Engage Orbiting","Cancel Orbiting",nU,nT,hz+nU+20,hA,function()return bz end,cs.ToggleIntoOrbit,function()return ce==0 and cX end)hA=cj/2-150;nE("Glide Re-Entry","Cancel Glide Re-Entry",nU,nT,hz+nU+20,hA,function()return b8 end,function()c9=1;nY(1)end,function()return ky.hasAtmosphere and not cd end)hA=hA+nT+20;nE("Parachute Re-Entry","Cancel Parachute Re-Entry",nU,nT,hz+nU+20,hA,function()return b8 end,function()c9=2;nY(1)end,function()return ky.hasAtmosphere and not cd end)hA=hA+nT+20;nE("Engage Follow Mode","Disable Follow Mode",nU,nT,hz,hA,function()return bY end,o4,function()return iC()==1 end)nE("Enable Repair Arrows","Disable Repair Arrows",nU,nT,hz+nU+20,hA,function()return j8 end,function()j8=not j8;if j8 then c0="Repair Arrows Enabled"else c0="Repair Arrows Diabled"end end,function()return iC()==1 end)hA=hA+nT+20;if not q then nE("Enable AGG","Disable AGG",nU,nT,hz,hA,function()return cP end,cs.ToggleAntigrav,function()return antigrav~=nil end)end;nE(function()return dj("Switch IPH Mode - Current: %s",bA)end,function()return dj("IPH Mode: %s",bA)end,nU*2,nT,hz,hA,function()return false end,function()if bA=="All"then bA="Custom Only"elseif bA=="Custom Only"then bA="No Moons"else bA="All"end;c0="IPH Mode: "..bA end)hA=hA+nT+20;nE(function()return dj("Toggle Control Scheme - Current: %s",g)end,function()return dj("Control Scheme: %s",g)end,nU*2,nT,hz,hA,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c0="New Control Scheme: "..g end)local og=jb(20)local oe=nA(0,0,ja(70),og,"HELP")oe=nA(oe.x+oe.width,oe.y,ja(80),og,"INFO")oe=nA(oe.x+oe.width,oe.y,ja(70),og,"ORBIT")oe=nA(oe.x+oe.width,oe.y,ja(70),og,"SCOPE")nA(oe.x+oe.width,oe.y,ja(70),og,"HIDE")end;local oh={}local oi=nil;function oh.HUDPrologue(jW)if not cU then i_=ah;j0=ai;j1=aj else i_=ae;j0=af;j1=ag end;j2=[[rgb(]]..bK(i_+0.6)..","..bK(j0+0.6)..","..bK(j1+0.6)..[[)]]j3=[[rgb(]]..bK(i_*0.8+0.5)..","..bK(j0*0.8+0.5)..","..bK(j1*0.8+0.5)..[[)]]local oj=j2;local ok=j3;local ol=[[rgb(]]..bK(i_*0.4+0.5)..","..bK(j0*0.4+0.5)..","..bK(j1*0.4+0.5)..[[)]]local om=j2;local on=j3;local oo=ol;if jc()and not m then oj=[[rgb(]]..bK(i_*0.5+0.5)..","..bK(j0*0.5+0.5)..","..bK(j1*0.5+0.5)..[[)]]ok=[[rgb(]]..bK(i_*0.3+0.5)..","..bK(j0*0.3+0.5)..","..bK(j1*0.2+0.5)..[[)]]ol=[[rgb(]]..bK(i_*0.2+0.5)..","..bK(j0*0.2+0.5)..","..bK(j1*0.2+0.5)..[[)]]end;local lS=ja;local lT=jb;jW[#jW+1]=dj([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],oj,oj,oj,om,om,ok,ok,on,on,ok,oj,ol,on,oj,oj,ol,ol,oo,ol,ci,cj,ok,ok,ok,ok,ok,om,ok,on,oo,on,on,oo)if not oi then oi=dj([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lS(630),lT(0),lS(675),lT(45),lS(960),lT(55),lS(1245),lT(45),lS(1290),lT(0),lS(1000),lT(105),lS(1040),lT(59),lS(1250),lT(51),lS(1300),lT(0),lS(1920),lT(0),lS(1920),lT(20),lS(1400),lT(20),lS(1300),lT(105),lS(920),lT(105),lS(880),lT(59),lS(670),lT(51),lS(620),lT(0),lS(0),lT(0),lS(0),lT(20),lS(520),lT(20),lS(620),lT(105),lS(890),lT(59),lS(960),lT(62),lS(1030),lT(59),lS(985),lT(112),lS(1150),lT(112),lS(1100),lT(152),lS(820),lT(152),lS(780),lT(112),lS(935),lT(112),lS(890),lT(59),lS(960),lT(62),lS(1030),lT(59),lS(985),lT(112),lS(1150),lT(112),lS(1100),lT(152),lS(820),lT(152),lS(780),lT(112),lS(935),lT(112))end;if w and I then jW[#jW+1]=oi end;return jW end;function oh.DrawVerticalSpeed(jW,e2)jV(jW,e2)end;function oh.UpdateHud(jW)local kL=cR;local op=cS;local k2=op;local ki=kL;local l2=bK(c.getThrottle())local l7=cK*3.6;local l3=c.getAxisCommandValue(0)local oq=ja(1770)local os=jb(310)if t and cQ then l3=bO;l2=bO*100 end;local je=jd()local k3="ROLL"if l2==nil then l2=0 end;if not cX then if cK>5 then kL=kK(cI)op=kM(cI)else kL=0;op=0 end;k3="YAW"end;if cV>50000 and not cd then local ot;ot=iH(cV)jW[#jW+1]=gM(oq,os,"PvP Boundary: "..ot,"pbright txtbig txtmid")end;jW[#jW+1]=j6;jW[#jW+1]=ic;if iV~=""then jW[#jW+1]=iV end;if jf~=""then jW[#jW+1]=jf end;if jg~=""then jW[#jW+1]=jg end;jV(jW,cf)if iC()==0 or l then if not jc()or m then if cX then k1(jW,ak,al,k2,k3,cX)kh(jW,ki,k2,ak,al,cX,bK(kM(cI)),cK)else k1(jW,ak,al,op,k3,cX)kh(jW,kL,op,ak,al,cX,bK(op),cK)end;ko(jW,cf,cX)kN(jW,cI,cK,ak,al)end end;l1(jW,je,l2,l3)l6(jW,l7)la(jW)mb(jW)if not iT and bZ then m3(jW)end;return jW end;function oh.HUDEpilogue(jW)jW[#jW+1]="</svg>"return jW end;function oh.ExtraData(jW)local ou=ja(1240)local ov=jb(55)local ow=ov+10;local ox;local lS=ja;local lT=jb;local oy=0;local je=jd()if a_ then je=je.."-VERTICAL"end;if E and not b7 and not b6 and cK>20 then je=je.."-COLLISION ON"end;if bC~="Off"then je="("..bC..")-"..je end;if b4 then je="TB-"..je end;if not bB then je=je.."-DeCoupled"end;local oz=lT(99)local oA=lT(80)local oB=lT(85)local oC=lT(31)local oD=0;local oE=0;local oF=cg>1000000 and fU(cg/1000000,2).."kT"or fU(cg/1000,2).."T"if cd then oy=bu else oy=bs end;local oG,oH=co.computeDistanceAndTime(cK,0,cg,0,0,oy)if oG<0 then oG=0 end;oy=fU(oy/(cg*iL),2).."g"local oI=d:maxForceForward()ox=b.getGravityIntensity()if ox>0.1 then oE=cg*ox;oE=fU(oE/(cg*iL),2).."g"oD=0.5*oI/ox;oD=oD>1000000 and fU(oD/1000000,2).."kT"or fU(oD/1000,2).."T"end;oI=fU(oI/(cg*iL),2).."g"local oJ=vec3(bM.getWorldAcceleration()):len()/9.80665;ox=b.getGravityIntensity()jW[#jW+1]=[[<g class="dim txt txtend size14">]]if iC()==1 and not l then ou=ja(1120)ov=jb(55)ow=ov+10 elseif cd and I then local oK=ja(770)jW[#jW+1]=gM(lS(895),oz,"ATMO","")jW[#jW+1]=dj([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lS(895),oB,lS(-80))jW[#jW+1]=gM(lS(815),oA,dj("%.1f%%",ce*100),"txtstart size20")end;if I then jW[#jW+1]=gM(lS(1025),oz,"GRAVITY","txtstart")jW[#jW+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lS(1025),oB,lS(80))jW[#jW+1]=gM(lS(1105),oA,dj("%.2fg",ox/9.80665),"size20")jW[#jW+1]=gM(lS(1125),oz,"ACCEL","txtstart")jW[#jW+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lS(1125),oB,lS(80))jW[#jW+1]=gM(lS(1205),oA,dj("%.2fg",oJ),"size20")jW[#jW+1]=gM(lS(695),oz,"BRK TIME","")jW[#jW+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lS(695),oB,lS(-80))jW[#jW+1]=gM(lS(615),oA,dj("%s",iI(oH)),"txtstart size20")jW[#jW+1]=gM(lS(635),lT(45),"TRIP","")jW[#jW+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lS(635),lT(31),lS(-90))if lM then jW[#jW+1]=gM(lS(545),lT(26),dj("%s",iI(lM)),"txtstart size20")end;jW[#jW+1]=gM(lS(795),oz,"BRK DIST","")jW[#jW+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lS(795),oB,lS(-80))jW[#jW+1]=gM(lS(715),oA,dj("%s",iH(oG)),"txtstart size20")jW[#jW+1]=gM(lS(1285),lT(45),"MASS","txtstart")jW[#jW+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lS(1285),lT(31),lS(90))jW[#jW+1]=gM(lS(1375),lT(26),dj("%s",oF),"size20")jW[#jW+1]=gM(lS(1220),oz,"THRUST","txtstart")jW[#jW+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lS(1220),oB,lS(80))jW[#jW+1]=gM(lS(1300),oA,dj("%s",oI),"size20")jW[#jW+1]=gM(ja(960),jb(175),je,"pbright txtbig txtmid size20")end;jW[#jW+1]="</g>"end;local oL=1-(a5*0.05+a6*0.05)function oh.FuelUsed(oM)local oN;if oM=="atmofueltank"then oN=dj("Atmo Fuel Used: %.1f L",jx[oM]/(4*oL))elseif oM=="spacefueltank"then oN=dj("Space Fuel Used: %.1f L",jx[oM]/(6*oL))else oN=dj("Rocket Fuel Used: %.1f L",jx[oM]/(0.8*oL))end;return oN end;local oO,oP,oQ,oR,oS=0,0,0,{},0;function oh.DrawOdometer(jW,j4,bn,j5)if bH~="INFO"then return jW end;local ox;local oD=0;local oE=0;local oy=0;local oF=cg>1000000 and fU(cg/1000000,2).." kTons"or fU(cg/1000,2).." Tons"if cd then oy=bu else oy=bs end;local oG,oH=co.computeDistanceAndTime(cK,0,cg,0,0,oy)oy=fU(oy/(cg*iL),2).." g"local oI=d:maxForceForward()ox=b.getGravityIntensity()if ox>0.1 then oE=cg*ox;oE=fU(oE/(cg*iL),2).." g"oD=0.5*oI/ox;oD=oD>1000000 and fU(oD/1000000,2).." kTons"or fU(oD/1000,2).." Tons"end;oI=fU(oI/(cg*iL),2).." g"if iC()==0 or l then local oT=ja(aA+10)local oU=jb(aB+20)local oV=ja(aA+10+az/1.25)local nC=25;local oW=bK(1/aT)if oQ<oW then oS=oS+a.getActionUpdateDeltaTime()oQ=oQ+1 else oO=1/(oS/oW)table.insert(oR,oO)oQ,oS=0,0 end;oP=0;for dK,dw in pairs(oR)do oP=oP+dw end;if#oR>0 then oP=bK(oP/#oR)end;if#oR>29 then table.remove(oR,1)end;jW[#jW+1]="<g class='txtstart size14 bright'>"jW[#jW+1]=gM(oT,oU,dj("BrkTime: %s",iI(oH)))jW[#jW+1]=gM(oV,oU,dj("Trip: %.2f km",j4))jW[#jW+1]=gM(oT,oU+nC,dj("Lifetime: %.2f kSU",bn/200000))jW[#jW+1]=gM(oV,oU+nC,dj("BrkDist: %s",iH(oG)))jW[#jW+1]=gM(oT,oU+nC*2,"Trip Time: "..iI(j5))jW[#jW+1]=gM(oV,oU+nC*2,"Total Time: "..iI(bo))jW[#jW+1]=gM(oT,oU+nC*3,dj("Mass: %s",oF))jW[#jW+1]=gM(oV,oU+nC*3,dj("Max Brake: %s",oy))jW[#jW+1]=gM(oT,oU+nC*4,dj("Max Thrust: %s",oI))if ox>0.1 then jW[#jW+1]=gM(oV,oU+nC*4,dj("Max Thrust Mass: %s",oD))jW[#jW+1]=gM(oT,oU+nC*5,dj("Req Thrust: %s",oE))else jW[#jW+1]=gM(oV,oU+nC*4,"Max Mass: n/a")jW[#jW+1]=gM(oT,oU+nC*5,"Req Thrust: n/a")end;jW[#jW+1]=gM(oV,oU+nC*5,cq.FuelUsed("atmofueltank"))jW[#jW+1]=gM(oT,oU+nC*6,cq.FuelUsed("spacefueltank"))jW[#jW+1]=gM(oV,oU+nC*6,cq.FuelUsed("rocketfueltank"))jW[#jW+1]=gM(oT,oU+nC*7,dj("Set Max Speed: %s",bK(aa*3.6+0.5)))jW[#jW+1]=gM(oV,oU+nC*7,dj("Actual Max Speed: %s",bK(de*3.6+0.5)))jW[#jW+1]=gM(oT,oU+nC*8,dj("Friction Burn Speed: %s",bK(bM.getFrictionBurnSpeed()*3.6)))jW[#jW+1]=gM(oV,oU+nC*8,dj("FPS (Avg): %s (%s)",bK(oO),oP))end;jW[#jW+1]="</g></g>"return jW end;function oh.DrawWarnings(jW)return la(jW)end;function oh.DisplayOrbitScreen(jW)return mb(jW)end;function oh.DisplayMessage(jW,lx)if lx~="empty"then local hA=310;for lG in string.gmatch(lx,"([^\n]+)")do hA=hA+35;jW[#jW+1]=gM("50%",hA,lG,"msg")end end;if c1~=0 then c.setTimer("msgTick",c1)c1=0 end end;function oh.DrawDeadZone(jW)jW[#jW+1]=dj([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],ay)end;function oh.UpdatePipe()if cd then iV=""return end;nr()end;function oh.DrawSettings(jW)local hz=ja(640)local hA=jb(200)jW[#jW+1]=[[<g class="pbright txtvspd txtstart">]]local hV=0;for dK,dw in pairs(iU)do hV=hV+1;jW[#jW+1]=gM(hz,hA,dK..": "..dw.get())hA=hA+20;if hV%12==0 then hz=hz+ja(350)hA=jb(200)end end;jW[#jW+1]=gM(ja(640),jb(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jW[#jW+1]="</g>"return jW end;local ib=jb(125)local ia=ja(1225)function oh.DrawRadarInfo()ic=ct.GetRadarHud(ia,ib,aw,ax)end;function oh.DrawTanks()if as~=0 and at~=0 then jf=gM(as,at,"","txtstart pdim txtfuel")jy=at;jz(as,"Atmospheric ","ATMO",ck,jv,jw)jz(as,"Space Fuel T","SPACE",cl,jt,ju)jz(as,"Rocket Fuel ","ROCKET",cm,jr,js)end end;function oh.DrawShield()local il=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oX=bM.getPvPTimer()local oY=shield.getResistances()local oZ="A: "..10+oY[1]*100 .."% / E: "..10+oY[2]*100 .."% / K:"..10+oY[3]*100 .."% / T: "..10+oY[4]*100 .."%"local hz,hA=au-60,av+30;local jO=bK(df*2.55)local jP=dj("rgb(%d,%d,%d)",255-jO,jO,0)local jQ=""jg=gM(hz,hA,"","txtmid pdim txtfuel")if df<10 and il~="Shield Disabled"then jQ="red "end;oX=oX>0 and"   PvPTime: "..iI(oX)or""jg=jg..dj([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hz,hA,jP,df*2,hz,hA,hz+2,hA+10,df,oX)jg=jg..gM(hz,hA-5,il,jQ.."txtstart pbright txtbig")jg=jg..gM(hz,hA+30,oZ,jQ.."txtstart pbright txtsmall")end;function oh.hudtick()if not ky then return end;local function o_(jW)local jS=bK(dk(dc/(ci/4)*255,0,255))jW[#jW+1]=dj("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c6,c7,bK(i_+0.5)+jS,bK(j0+0.5)-jS,bK(j1+0.5)-jS)end;local function p0()if b_ then for dP,dw in pairs(iM)do if dw.hovered then if not dw.drawCondition or dw.drawCondition(dw)then dw.toggleFunction(dw)end;dw.hovered=false end end;for dP,dw in pairs(iP)do if dw.hovered then bH=dw.label;dw.hovered=false end end;b_=false end end;local function p1()local function p2(p3,p4,hz,hA,nB,nC)if p3>=hz and p3<=hz+nB and p4>=hA and p4<=hA+nC then return true else return false end end;local hz=c6+ci/2;local hA=c7+cj/2;for dP,dw in pairs(iM)do dw.hovered=p2(hz,hA,dw.x,dw.y,dw.width,dw.height)end;for dP,dw in pairs(iP)do dw.hovered=p2(hz,hA,dw.x,dw.y,dw.width,dw.height)end;if c_ then local ng=false;for dP,eC in ipairs(od)do if eC.hovered then ng=true;break end end;if oa.hovered then ng=true end;c_=ng else c_=oa.hovered;if not c_ then d0=bl end end end;local function p5(jW)if not bH or bH==""then bH="HELP"end;if w then for dK,dw in pairs(iP)do local jQ="dim brightstroke"local p6=0.2;if bH==dK then jQ="pbright dimstroke"p6=0.6 end;local p7=""if dw.hovered then p6=0.8;p7=";stroke:white"end;jW[#jW+1]=dj([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dw.width,dw.height,dw.x,dw.y,jQ,p6,p7)jW[#jW+1]=gM(dw.x+dw.width/2,dw.y+dw.height/2+5,dw.label,"txt txtmid pdim")end end end;local function p8(jW)local function p9(jW,pa,hover,hz,hA,fh,pb,pc,pd,pe,pf,oe)if type(pe)=="function"then pe=pe(oe)end;if type(pf)=="function"then pf=pf(oe)end;jW[#jW+1]=dj("<rect x='%f' y='%f' width='%f' height='%f' fill='",hz,hA,fh,pb)if pa then jW[#jW+1]=dj("%s'",pc)else jW[#jW+1]=pd end;if hover then jW[#jW+1]=dj(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ae,af,ag)else jW[#jW+1]=dj(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fU(ae*0.5,0),fU(af*0.5,0),fU(ag*0.5,0))end;jW[#jW+1]=" rx='5'></rect>"jW[#jW+1]=dj("<text x='%f' y='%f' font-size='24' fill='",hz+fh/2,hA+pb/2+5)if pa then jW[#jW+1]="black"else jW[#jW+1]="white"end;jW[#jW+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if pa then jW[#jW+1]=dj("%s</text>",pe)else jW[#jW+1]=dj("%s</text>",pf)end end;local pg=dj("rgb(%d,%d,%d)'",fU(ae*0.1,0),fU(af*0.1,0),fU(ag*0.1,0))local ph=dj("rgb(%d,%d,%d)",fU(ae*0.8,0),fU(af*0.8,0),fU(ag*0.8,0))local pi=p9;for dP,dw in pairs(iM)do local nG=dw.disableName;local nF=dw.enableName;if type(nG)=="function"then nG=nG(dw)end;if type(nF)=="function"then nF=nF(dw)end;if not dw.drawCondition or dw.drawCondition(dw)then pi(jW,dw.toggleVar(dw),dw.hovered,dw.x,dw.y,dw.width,dw.height,ph,pg,nG,nF,dw)end end end;local pj=fU(ci/2,0)local pk=fU(cj/2,0)local jW={}if pl then jW[#jW+1]=pl end;cq.HUDPrologue(jW)if w then cq.UpdateHud(jW)else if A then cq.DrawVerticalSpeed(jW,cf)end;cq.DrawWarnings(jW)end;if iT and iU~="none"then cq.DrawSettings(jW)end;if ct then cq.DrawRadarInfo()else ic=""end;cq.HUDEpilogue(jW)jW[#jW+1]=dj([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ci,cj)if c0~="empty"then cq.DisplayMessage(jW,c0)end;if iC()==0 and g=="virtual joystick"then if v then cq.DrawDeadZone(jW)end end;p5(jW)if iE()==0 then if iC()==1 and bZ then if not pm then p1()p8(jW)end;if not cw and not cx then local pn=table.concat(jW,"")jW={}jW[#jW+1]=dj("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ci,cj)jW[#jW+1]=pn;jW[#jW+1]="</body>"cw=true;jW[#jW+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cx then local pn=table.concat(jW,"")jW={}jW[#jW+1]=dj("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ci,cj)jW[#jW+1]=pn;jW[#jW+1]="</body>"end;if not cw then jW[#jW+1]=dj([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],pj,pk,c6,c7)end else p0()end else if not bZ and iC()==0 then p0()if dc>ay then if v then o_(jW)end end elseif bZ and(not pm or not i)then p1()p8(jW)end;jW[#jW+1]=dj([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],pj,pk,c6,c7)end;jW[#jW+1]=[[</svg></body>]]po=table.concat(jW,"")end;function oh.TenthTick()local function pp()local pq=a.createData;local pr=a.createWidget;ps=a.createWidgetPanel("Interplanetary Helper")pt=pr(ps,"value")pu=pq('{"label": "Target Planet", "value": "N/A", "unit":""}')fS(pu,pt)pv=pr(ps,"value")pw=pq('{"label": "distance", "value": "N/A", "unit":""}')fS(pw,pv)gl=pr(ps,"value")gk=pq('{"label": "Travel Time", "value": "N/A", "unit":""}')fS(gk,gl)gj=pr(ps,"value")gi=pq('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fS(gi,gj)gn=pr(ps,"value")gm=pq('{"label": "Target Altitude", "value": "N/A", "unit":""}')fS(gm,gn)gf=pr(ps,"value")ge=pq('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gd=pr(ps,"value")gc=pq('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gb=pr(ps,"value")ga=pq('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g9=pr(ps,"value")g8=pq('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gh=pr(ps,"value")gg=pq('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cd then fS(ge,gf)fS(gc,gd)fS(ga,gb)fS(g8,g9)fS(gg,gh)end end;local function px()gL(ps)ps=nil end;cq.DrawTanks()if shield then cq.DrawShield()end;if bj~="None"then if ps==nil then pp()end;if bj~=nil then local mS;local py=g4~=nil;local pz=0.5*bu/c5:getGravity(c5.center+vec3(0,0,1)*c5.radius):len()pz=pz>1000000 and fU(pz/1000000,2).." kTons"or fU(pz/1000,2).." Tons"fR(pu,'{"label": "Target", "value": "'..bj..'", "unit":""}')if py and not b3 then mS=(cN-g4.position):len()else mS=(bk-cN):len()end;if not b4 then c3,c4=cs.GetAutopilotBrakeDistanceAndTime(cK)iX,iY=cs.GetAutopilotBrakeDistanceAndTime(aa)else c3,c4=cs.GetAutopilotTBBrakeDistanceAndTime(cK)iX,iY=cs.GetAutopilotTBBrakeDistanceAndTime(aa)end;local lx=iH(mS)fR(pw,'{"label": "distance", "value": "'..lx..'"}')fR(gk,'{"label": "Travel Time", "value": "'..iI(lM)..'", "unit":""}')lx=iH(c3)fR(ge,'{"label": "Cur Brake distance", "value": "'..lx..'"}')fR(gc,'{"label": "Cur Brake Time", "value": "'..iI(c4)..'", "unit":""}')lx=iH(iX)fR(ga,'{"label": "Max Brake distance", "value": "'..lx..'"}')fR(g8,'{"label": "Max Brake Time", "value": "'..iI(iY)..'", "unit":""}')fR(gi,'{"label": "Max Brake Mass", "value": "'..dj("%s",pz)..'", "unit":""}')lx=iH(go)fR(gm,'{"label": "Target Orbit", "value": "'..lx..'"}')if cd and not pA then a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)pA=true;if not cQ and t and(b5 or b8 or cb)then cs.cmdThrottle(1)b0=false;bS=false end end;if not cd and pA then if fR(g8,g9)==1 then fS(g8,g9)end;if fR(ga,gb)==1 then fS(ga,gb)end;if fR(gc,gd)==1 then fS(gc,gd)end;if fR(ge,gf)==1 then fS(ge,gf)end;if fR(gg,gh)==1 then fS(gg,gh)end;pA=false end end else px()end;if warpdrive~=nil then local pB=iA(warpdrive.getWidgetData())if pB.destination~="Unknown"and pB.distance>400000 then if not j9 then warpdrive.showWidget()j9=true end elseif j9 then warpdrive.hideWidget()j9=false end end end;function oh.OneSecondTick()local function pC()local jJ=bJ()local l7=cK;local pD=jJ-j7;if l7>1.38889 then l7=l7/1000;local pE=l7*(jJ-j7)bn=bn+pE;j4=j4+pE end;j5=j5+pD;bo=bo+pD;j7=jJ end;local function pF(jW)local pG=0;local pH=iK;local pI=0;local pJ=0;local pK=0;local jO=0;local jP=""local pL=b.getElementHitPointsById;local pM=b.getElementMaxHitPointsById;local pN={}for dK in pairs(iJ)do local pO=0;local pP=0;pP=pM(iJ[dK])pO=pL(iJ[dK])pI=pI+pO;if pO+1<pP then if pO==0 then pK=pK+1 else pJ=pJ+1 end;if j8 and#pN==0 then fW=vec3(b.getElementPositionById(iJ[dK]))local hz=fW.x;local hA=fW.y;local hB=fW.z;table.insert(pN,b.spawnArrowSticker(hz,hA,hB+1,"down"))table.insert(pN,b.spawnArrowSticker(hz,hA,hB+1,"down"))b.rotateSticker(pN[2],0,0,90)table.insert(pN,b.spawnArrowSticker(hz+1,hA,hB,"north"))table.insert(pN,b.spawnArrowSticker(hz+1,hA,hB,"north"))b.rotateSticker(pN[4],90,90,0)table.insert(pN,b.spawnArrowSticker(hz-1,hA,hB,"south"))table.insert(pN,b.spawnArrowSticker(hz-1,hA,hB,"south"))b.rotateSticker(pN[6],90,-90,0)table.insert(pN,b.spawnArrowSticker(hz,hA-1,hB,"east"))table.insert(pN,b.spawnArrowSticker(hz,hA-1,hB,"east"))b.rotateSticker(pN[8],90,0,90)table.insert(pN,b.spawnArrowSticker(hz,hA+1,hB,"west"))table.insert(pN,b.spawnArrowSticker(hz,hA+1,hB,"west"))b.rotateSticker(pN[10],-90,0,90)table.insert(pN,iJ[dK])end elseif j8 and#pN>0 and pN[11]==iJ[dK]then for jI in pairs(pN)do b.deleteSticker(pN[jI])end;pN={}end end;pG=fU(pI/pH*100,2)if pK>0 or pJ>0 then jW[#jW+1]=gM(0,0,"","pbright txt")jO=bK(pG*2.55)jP=dj("rgb(%d,%d,%d)",255-jO,jO,0)jW[#jW+1]=gM("50%",1035,"Elemental Integrity: "..pG.."%","txtbig txtmid","fill:"..jP)if pK>0 then jW[#jW+1]=gM("50%",1055,"Disabled Modules: "..pK.." Damaged Modules: "..pJ,"txtbig txtmid","fill:"..jP)elseif pJ>0 then jW[#jW+1]=gM("50%",1055,"Damaged Modules: "..pJ,"txtbig txtmid","fill:"..jP)end end end;local function pQ()if iz then if iZ==nil and(hd~=nil or bm)then _autoconf.displayCategoryPanel(iz,weapon_size,"Weapons","weapon",true)iZ=_autoconf.panels[_autoconf.panels_size]elseif iZ~=nil and hd==nil and not bm then gL(iZ)iZ=nil end end end;d1=bM.getPlayersOnBoard()d2=bM.getDockedConstructs()local jW={}pC()if s then pF(jW)end;pQ()cq.UpdatePipe()cq.ExtraData(jW)j6=table.concat(jW,"")end;function oh.AnimateTick()cx=true;cw=false;c6=0;c7=0;c.stopTimer("animateTick")end;function oh.MsgTick()local jW={}cq.DisplayMessage(jW,"empty")c0="empty"c.stopTimer("msgTick")c1=3 end;function oh.ButtonSetup()nR()nW()iM=iN end;if pR then for dK,dw in pairs(pR)do oh[dK]=dw end end;return oh end;local function pS(d,b,c,e,vBooster,hover,pT,antigrav,warpdrive,dbHud_1,eY,bK,bL,iC,eT,bJ,dk,iD,fR,iE,dm,fU,fT,iF,dn,iH,iI,pU,iA,dj,fS)local a=DUSystem;local bM=DUConstruct;local pV={}local pW=false;local pX=0;local pY=0;local pZ=0;local p_=bJ()local q0=0;local q1=0;local q2=0;local q3=0;local q4=false;local q5=false;local q6=false;local q7=nil;local q8=0;local iW=55;local q9=nil;local qa=false;local qb=false;local qc=false;local qd=0;local qe=0;local qf=0;local qg=0;local qh=0;local qi={VectorToTarget=false}local qj=vec3(bM.getWorldOrientationUp())local qk=nil;local ql=0;local qm=-1;local qn=-1;local qo=false;local qp=false;local qq=0;local qr=false;local qs=false;local qt=false;local qu=false;local qv=""local qw=false;local qx=false;local qy=""local qz=false;local qA=0;local function qB()return bM.isInPvPZone()~=1,eY(bM.getDistanceToSafeZone())end;local function qC(fo)local qD=bf;if not b3 then qD=0 end;local qE=bs;if cd then if bu and bu>0 then qE=bu else return 0,0 end end;return co.computeDistanceAndTime(fo,qD,cg,0,0,qE-bh*cg)end;local function qF(fo)local qD=bf;if not b3 then qD=0 end;return co.computeDistanceAndTime(fo,qD,cg,d:maxForceForward(),a1,bs-bh*cg)end;local function qG(qH,qI,qJ)qI=qI:project_on_plane(qH)qJ=qJ:project_on_plane(qH)return eT(qI:cross(qJ):dot(qH),qI:dot(qJ))end;local function qK()local function qL()local qM=-1;local qN=-1;if vBooster then qM=vBooster.getDistance()end;if hover then qN=hover.getDistance()end;if qM~=-1 and qN~=-1 then if qM<qN then return qM else return qN end elseif qM~=-1 then return qM elseif qN~=-1 then return qN else return-1 end end;local qO=qL()local qP=-1;if antigrav and antigrav.isActive()==1 and not q and cK<iW then local qQ=eY(cf-antigrav.getBaseAltitude())if qQ<50 then return qQ end end;if pT then qP=pT.raycast().distance end;if qO~=-1 and qP~=-1 then if qO<qP then return qO else return qP end elseif qO~=-1 then return qO else return qP end end;local function qR(ky,eK,qS)local function qT(qU,dW)local eQ=vec3(dW)if qU.id==0 then return setmetatable({latitude=eQ.x,longitude=eQ.y,altitude=eQ.z,id=0,systemId=qU.systemId},dY)end;local eR=eQ-qU.center;local c8=eR:len()local e2=c8-qU.radius;local e0=0;local e1=0;if not dn(c8,0)then local eS=eT(eR.y,eR.x)e1=eS>=0 and eS or 2*math.pi+eS;e0=math.pi/2-math.acos(eR.z/c8)end;return setmetatable({latitude=math.deg(e0),longitude=math.deg(e1),altitude=e2,id=qU.id,systemId=qU.systemId},dY)end;local qV=qT(ky,eK)qV="::pos{"..qV.systemId..","..qV.id..","..qV.latitude..","..qV.longitude..","..qV.altitude.."}"if qS then return qV else qt=qV;return true end end;local function qW(qX,qY,qZ)local function q_(qX,et)qX=vec3(qX)et=vec3(et):normalize()local dF=qX*et;return dF.x+dF.y+dF.z end;local r0=0.001;local r1=1;if not cd or not cz or cc~=-1 or cK<iW then if qZ==nil then qZ=aS end;if qY==nil then qY=r0 end;qX=vec3(qX):normalize()local r2=vec3()-qX;local r3=-q_(r2,bM.getWorldOrientationRight())*r1;local r4=-q_(r2,bM.getWorldOrientationUp())*r1;if pY==0 then pY=r3/2 end;if pZ==0 then pZ=r4/2 end;if eY(r3)<0.1 then qe=qe-r3*2 else qe=qe-(r3+(r3-pY)*qZ)end;if eY(r4)<0.1 then qd=qd+r4*2 else qd=qd+r4+(r4-pZ)*qZ end;pY=r3;pZ=r4;if eY(r3)<qY and eY(r4)<qY then return true end;return false elseif cz and cc==-1 then qX=cJ;if qZ==nil then qZ=aS end;if qY==nil then qY=r0 end;qX=vec3(qX):normalize()local r2=cG-qX;local r3=-q_(r2,bM.getWorldOrientationRight())*r1;local r4=-q_(r2,bM.getWorldOrientationUp())*r1;if pY==0 then pY=r3/2 end;if pZ==0 then pZ=r4/2 end;if eY(r3)<0.1 then qe=qe-r3*5 else qe=qe-(r3+(r3-pY)*qZ)end;if eY(r4)<0.1 then qd=qd+r4*5 else qd=qd+r4+(r4-pZ)*qZ end;pY=r3;pZ=r4;if eY(r3)<qY and eY(r4)<qY then return true end;return false end end;function pV.clearAll()bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"b1=false;b2=false;cW=nil;b5=false;b8=false;b6=false;b7=false;b9=false;bY=false;qb=false;c9=false;ca=false;qc=false;cy=p;bq=false;b4=false;ch=false;bt=nil;bz=false;da=false;db=nil end;function pV.GetAutopilotBrakeDistanceAndTime(fo)return qC(fo)end;function pV.GetAutopilotTBBrakeDistanceAndTime(fo)return qF(fo)end;function pV.showWayPoint(ky,eK,qS)return qR(ky,eK,qS)end;function pV.APTick()local r5=a.getMouseWheel()if r5>0 then cs.changeSpd()elseif r5<0 then cs.changeSpd(true)else qa=true end;qq=iE()if qt then a.setWaypoint(qt)qt=false end;if qw then antigrav.setTargetAltitude(qw)qw=false end;if qu then fR(qu,qv)qu=false;qv=""end;if qn~=-1 then cs.cmdCruise(qn,qo)qo=false;qn=-1 end;if qk~=nil then if iD:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iD:getTargetSpeed(axisCommandId.longitudinal)~=qk then iD:setTargetSpeedCommand(axisCommandId.longitudinal,qk)else qk=nil end end;if qm~=-1 then cs.cmdThrottle(qm,qo)qo=false;qm=-1 end;if qp then cu.landingGear()qp=false end;if qx then cs.ToggleAutopilot()end end;function pV.ToggleIntoOrbit()cD=false;q2=nil;q3=nil;q8=0;if not cd then if bz then fT("orOff","AP")bz=false;q4=false;q7=nil;cy=p;if b5 then b5=false;b7=false end;qi.VectorToTarget=false;qi.AutopilotAlign=false;q6=false elseif cX then fT("orOn","AP")bz=true;cy=true;if q7==nil then q7=ky end;if b5 then b5=false;b7=false end else c0="Unable to engage auto-orbit, not near a planet"end else bz=false;q4=false;q7=nil;cy=p;if b5 then b5=false end;qi.VectorToTarget=false;qi.AutopilotAlign=false;q6=false end end;function pV.ToggleVerticalTakeoff()b5=false;if b9 then lF=true;b8=false;b7=false;b6=true;cy=true;bX=0;if cd and cc==-1 then b6=false;b5=true;bX=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qn=bK(cA)end else cD=false;bm=false;d.control.retractLandingGears()iD:setTargetGroundAltitude(Y)b0="VTO Takeoff"end;b9=not b9 end;function pV.checkLOS(qX)local lK,eI,eJ=cn:getPlanetarySystem(0):castIntersections(cN,qX,function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)local lL=eI;if eJ~=nil and eI~=nil then lL=math.min(eJ,eI)end;if lL~=nil then return lK,lL else return nil,nil end end;function pV.ToggleAutopilot()local function r6(bx)cY=false;bq=not bq;if bq then b4=false;if not b5 and not bx then cs.ToggleAltitudeHold()end end;lO="Proceeding to Waypoint"end;local function r7(gx)if gx then for L,dK in pairs(cT)do if dK.name and dK.name==gx then return L end end else return 0 end end;local r8=false;if bN-q1<1.5 and cd then if not cF then if cd then ba=ky.spaceEngineMinAltitude-0.01*ky.noAtmosphericDensityAltitude;fT("11","EP")q1=-1;if b3 or bq or bz then return end else c0="No space engines detected, Orbital Hop not supported"return end elseif ky.hasAtmosphere then if cd then ba=ky.noAtmosphericDensityAltitude+U;fT("orH","OH")end;q1=-1;if b3 or bq or bz then return end end else q1=bN end;r9=false;if(bl>0 or#bF>0)and not b3 and not bq and not ca and not bz then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cg then c0="WARNING: Heavy Loads may affect autopilot performance."c1=5 end;if#bF>0 and not cb then bl=r7(bF[1])cr.UpdateAutopilotTarget()c0="Route Autopilot in Progress"local r2=g4.position-cN;local ra=r2:project_on_plane(cL):len()if ra>50000 and g4.planetname==ky.name then r8=true end end;cr.UpdateAutopilotTarget()cs.showWayPoint(c5,bk)if g4~=nil then if g4.agg and not q and antigrav then if not cP then cs.ToggleAntigrav()end;bv=g4.agg end;bt=nil;bx=g4.planetname=="Space"if bx then fT("apSpc","AP")if cd then ca=true;cs.ToggleAltitudeHold()else b3=true end elseif ky.name==g4.planetname then lF=true;if cd then if not bq then fT("vtt","AP")r6(bx)if r8 then ba=ky.noAtmosphericDensityAltitude+U end end else fT("apOn","AP")if not(c5.name==ky.name and cf<go*1.5)then cD=false;b3=true elseif not cd then if bz then cs.ToggleIntoOrbit()end;cC=ky.noAtmosphericDensityAltitude+U;q6=true;qi.AutopilotAlign=true;qi.VectorToTarget=true;q4=false;if not bz then cs.ToggleIntoOrbit()end end end else fT("apP","AP")b1=false;b2=false;if cd then ca=true;cs.ToggleAltitudeHold()else b3=true end end elseif not cd then if g4==nil and(c5.name==ky.name and cX)and not bz then rb=false;cD=false;q4=false;cs.ToggleIntoOrbit()else fT("apP","AP")b3=true;b1=false;b2=false;bc=false;bY=false;b5=false;b6=false;b8=false;b7=false;qb=false;bt=nil;rb=false end else fT("apP","AP")ca=true;cs.ToggleAltitudeHold()end;qx=false else fT("apOff","AP")cs.ResetAutopilots(1)if qx==2 then qx=true end end end;function pV.routeWP(rc,rd,re)if re then if re==1 then bF={}bF=iF(bF,bE)if#bF>0 then c0="Route Loaded"else c0="No Saved Route found on Databank"end;return bF else bE={}bE=iF(bE,bF)c0="Route Saved"pU()return end end;if rc then return bF end;if rd then bF={}c0="Current Route Cleared"else bF[#bF+1]=g4.name;c0="Added "..g4.name.." to route. "end;return bF end;function pV.cmdThrottle(dL,rf)if iD:getAxisCommandType(0)~=axisCommandType.byThrottle and not rf then d.control.cancelCurrentControlMasterMode()end;iD:setThrottleCommand(axisCommandId.longitudinal,dL)bO=dk(fU(dL*100,0)/100,-1,1)qk=nil end;function pV.cmdCruise(dL,rf)if iD:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rf then d.control.cancelCurrentControlMasterMode()end;iD:setTargetSpeedCommand(axisCommandId.longitudinal,dL)qk=dL end;function pV.ToggleLockPitch()if bt==nil then fT("lkPOn","LP")if not bZ then bt=cR else bt=R end;b7=false;b5=false;b6=false else fT("lkPOff","LP")bt=nil end end;function pV.ToggleAltitudeHold()if bN-q0<1.5 then if ky.hasAtmosphere then if cd then ba=ky.spaceEngineMinAltitude-0.01*ky.noAtmosphericDensityAltitude;fT("11","EP")else if cX then ba=ky.noAtmosphericDensityAltitude+U;cC=ba;q6=true;if not bz then cs.ToggleIntoOrbit()end;q4=true end end;q0=-1;if b5 or bz or b9 then return end end else q0=bN end;if cX and not cd then cC=cf;q6=true;q4=true;cs.ToggleIntoOrbit()if bz then q0=bN else q0=0 end;return end;b5=not b5;b6=false;b8=false;if b5 then b3=false;b2=false;b1=false;bY=false;cy=true;bt=nil;cD=false;if cc~=-1 and cK<20 then if bm then cu.landingGear()end;fT("lfs","LS")b7=true;if q0>-1 then ba=cf+X end;b0="ATO Hold"iD:setTargetGroundAltitude(Y)if a_ and cO then cs.ToggleVerticalTakeoff()end else fT("altOn","AH")b7=false;if q0>-1 then if cX then ba=cf end end;if b9 then cs.ToggleVerticalTakeoff()end end;if cP and not q then local rg=antigrav.getBaseAltitude()if bq and g4.agg and g4.agg>cf then ba=g4.agg elseif b7 then ba=rg end;if eY(cf-rg)<100 and cK<20 then ba=rg;b0="AGG Hold"qm=0 end end;if ca then ba=200000 end else fT("altOff","AH")if bz then cs.ToggleIntoOrbit()end;if b9 then cs.ToggleVerticalTakeoff()end;cy=p;b7=false;bq=false;q0=0 end end;function pV.ResetAutopilots(pV)if pV then ca=false;b3=false;bc=false;qb=false;ba=cf;r9=false;da=false;bg="Aligning"end;bq=false;b7=false;b8=false;b2=false;b6=false;db=nil;rh=false;cW=nil;da=false;if not cP then b5=false;bt=nil end;if b9 then cs.ToggleVerticalTakeoff()end;if bz then cs.ToggleIntoOrbit()end;cy=p;c9=false;cb=false;bX=0 end;function pV.BrakeToggle(ri)if not b0 then if ri then b0=ri else b0=true end else b0=false end;if b6 then b6=false;cy=p;da=false end;if b0 then fT("bkOn","B",1)cs.ResetAutopilots()else fT("bkOff","B",1)end end;function pV.BeginReentry()if b8 then c0="Re-Entry cancelled"fT("reOff","RE")b8=false;cy=p;b5=false elseif not ky.hasAtmosphere then c0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c1=5 elseif not qc then b8=true;if iD:getAxisCommandType(0)~=rj.cruise then d.control.cancelCurrentControlMasterMode()end;cy=true;b0=false;c0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cA;fT("par","RE")else b8=true;b5=true;cy=true;b0=false;ba=ky.surfaceMaxAltitude+_;if ba>ky.spaceEngineMinAltitude then ba=ky.spaceEngineMinAltitude-0.01*ky.noAtmosphericDensityAltitude end;local rk=iH(ba)c0="Beginning Re-entry.  Target speed: "..cA.." Target Altitude: "..rk;fT("glide","RE")qn=bK(cA)end;b7=false end;function pV.ToggleAntigrav()if antigrav and not q then if cP then fT("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bv==nil then bv=cf end;if bv<1000 then bv=1000 end;fT("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pV.changeSpd(rl)local rm=1;if rl then rm=-1 end;if not bZ then if t and not pm and qa then local rn=bO;bO=fU(dk(bO+rm*aE/100,-1,1),2)if bO>=0 and rn<0 then bO=0;qa=false end elseif pm then if cd or b8 then cA=dk(cA+rm*aE,0,V)elseif b3 then aa=dk(aa+rm*aE/3.6*100,0,de-0.2)end else iD:updateCommandFromActionStart(axisCommandId.longitudinal,rm*aE/10)end else if b3 or bq or ca or bz then d0=d0+1*rm*-1;if d0>#cT then d0=1 end;if d0<1 then d0=#cT end else if not rl then rm=1 else rm=nil end;cr.adjustAutopilotTargetIndex(rm)end end end;function pV.TenthTick()local function ro()if not b3 then if g4==nil or g4.planetname~=ky.name then rp=(c5.center-cN):len()else rp=(g4.position-cN):len()end end;local fo=cK;local rq=c.getThrottle()/100;if t then rq=bO end;local rr,rs=co.computeDistanceAndTime(cK,aa,cg,d:maxForceForward()*rq,a1,0)local c3,c4;if not b4 then c3,c4=cs.GetAutopilotBrakeDistanceAndTime(aa)else c3,c4=cs.GetAutopilotTBBrakeDistanceAndTime(aa)end;local dP,rt;if not b4 and fo>0 then dP,rt=cs.GetAutopilotBrakeDistanceAndTime(fo)else dP,rt=cs.GetAutopilotTBBrakeDistanceAndTime(fo)end;local ru=0;local rv=0;if be or not b3 and fo>5 then rv=co.computeTravelTime(fo,0,rp)elseif c3+rr<rp then ru=rp-(c3+rr)rv=co.computeTravelTime(8333.0556,0,ru)else local rw=(rp-c3)/rr;rr=rp-c3;rs=rs*rw end;if g4~=nil and g4.planetname==ky.name and not b3 then return rv elseif bd then return rt elseif be then return rv+rt else return rs+c4+rv end end;local function rx(ox,ry)if ox==nil then ox=b.getGravityIntensity()end;ox=fU(ox,5)if ry~=nil and ry or(q9==nil or q9~=ox)then local fo=cI:len()local rz=iA(c.getWidgetData()).maxBrake;if rz~=nil and rz>0 and cd then rz=rz/dk(fo/100,0.1,1)rz=rz/ce;if ce>0.10 then if bu then bu=(bu+rz)/2 else bu=rz end end end;if rz~=nil and rz>0 then bs=rz end;q9=ox end end;cU,cV=qB()de=bM.getMaxSpeed()if bj~="None"and(c5 or g4)then lM=ro()end;rx(nil,true)end;function pV.SatNavTick()if not r then return end;qy=dbHud_1.getStringValue("SPBAutopilotTargetName")if qy~=nil and qy~=""and qy~="SatNavNotChanged"then local dF=iA(dbHud_1.getStringValue("SavedLocations"))if dF~=nil then bp=dF;local gv=-1;local gB;for dK,dw in pairs(bp)do if dw.name and dw.name=="SatNav Location"then gv=dK;break end end;if gv~=-1 then gB=bp[gv]gv=-1;for dK,dw in pairs(e[0])do if dw.name and dw.name=="SatNav Location"then gv=dK;break end end;if gv>-1 then e[0][gv]=gB end;cr.UpdateAtlasLocationsList()c0=gB.name.." position updated"end end;for L=1,#cT do if cT[L].name==qy then bl=L;a.print("Index = "..bl.." "..cT[L].name)cr.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pV.onFlush()local function rA(rB,rC)local rD=vec3()local rE=vec3()if rB==axisCommandId.longitudinal then rD=vec3(bM.getOrientationForward())rE=cG elseif rB==axisCommandId.vertical then rD=vec3(bM.getOrientationUp())rE=qj elseif rB==axisCommandId.lateral then rD=vec3(bM.getOrientationRight())rE=cH else return vec3()end;local rF=vec3(b.getWorldGravity())local rG=rF:dot(rE)local rH=vec3(bM.getWorldAirFrictionAcceleration())local rI=rH:dot(rE)local rJ=cI:dot(rD)local rK=rC*constants.kph2m;if rL==nil then rL=pid.new(10,0,10.0)end;rL:inject(rK-rJ)local rM=rL:get()local rN=(rM-rI-rG)*rE;return rN end;local function rO(rB,rC)local rD=vec3()local rE=vec3()if rB==axisCommandId.longitudinal then rD=vec3(bM.getOrientationForward())rE=cG elseif rB==axisCommandId.vertical then rD=vec3(bM.getOrientationUp())rE=qj elseif rB==axisCommandId.lateral then rD=vec3(bM.getOrientationRight())rE=cH else return vec3()end;local rF=vec3(b.getWorldGravity())local rG=rF:dot(rE)local rH=vec3(bM.getWorldAirFrictionAcceleration())local rI=rH:dot(rE)local rJ=cI:dot(rD)local rK=rC*constants.kph2m;if rP==nil then rP=pid.new(10,0,10.0)end;rP:inject(rK-rJ)local rM=rP:get()local rN=(rM-rI-rG)*rE;return rN end;local function rQ(rR,jZ,g0)local rS=rR:cross(g0):normalize_inplace()local kL=math.acos(dk(rS:dot(-jZ),-1,1))*constants.rad2deg;if rS:cross(-jZ):dot(g0)<0 then kL=-kL end;return kL end;local function rT()if cZ and not b6 then local er=cZ[1]local i1,i2=cZ[2],cZ[3]local rU=math.min(i1,i2 or i1)local rV=rU/cK;local rW=b7 and(cK<42 or cc~=-1)local rX=b5 or bq or bt or b3;if rX and not rW and(c3*1.5>rU or rV<1)then b0="Collision"bF={}qm=0;if b5 then cs.ToggleAltitudeHold()end;if bt then cs.ToggleLockPitch()end;c0="Autopilot Cancelled due to possible collision"a.print(er.name.." COLLISION "..iI(rV).." / "..iH(rU,2))cs.ResetAutopilots(1)lF=true;if cd then b6=true end;cy=true end;if rV<11 then cY=er.name.." COLLISION "..iI(rV).." / "..iH(rU,2)else cY=er.name.." collision "..iI(rV)end;if rV<6 then fT("alarm","AL",2)end else cY=false end end;if antigrav and not q then if not cP and antigrav.getBaseAltitude()~=bv then qw=bv end end;if dd then d:setEngineForceCommand('hover',vec3(),1)dd=false end;cQ=iD:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local rY=dk(bU+qd+a.getControlDeviceForwardInput(),-1,1)local rZ=dk(bV+qf+a.getControlDeviceYawInput(),-1,1)local r_=dk(bW+qe-a.getControlDeviceLeftRightInput(),-1,1)local s0=b0 and 1 or 0;cL=vec3(b.getWorldVertical())if cL==nil or cL:len()==0 then cL=(ky.center-cN):normalize()end;qj=vec3(bM.getWorldOrientationUp())cG=vec3(bM.getWorldOrientationForward())cH=vec3(bM.getWorldOrientationRight())cJ=vec3(bM.getWorldVelocity())cI=vec3(bM.getVelocity())cN=vec3(bM.getWorldPosition())cg=bM.getMass()cK=vec3(cJ):len()cM=-cL:dot(cJ)cS=getRoll(cL,cG,cH)local s1=cS/180*math.pi;local s2=math.cos(s1)local s3=math.sin(s1)cR=rQ(cL,cG,cH*s2+qj*s3)local s4=cJ:normalize()local s5=eY(cS)local s6=utils.sign(cS)local s7=vec3(bM.getWorldAngularVelocity())local s8=rY*aO*cH+rZ*aJ*cG+r_*aP*qj;if cy==true and cL:len()>0.01 then local s9=eY(qg-cS)if((b2 or b8 or b6 or c9 or b5 or bz)and s9>0 or cd and s9<aK and p)and rZ==0 and eY(cR)<85 then local sa=qg;local sb=aI;if not cd then sb=sb/4;qg=0;sa=0 end;if sc==nil then sc=pid.new(sb*0.01,0,sb*0.1)end;sc:inject(sa-cS)local sd=sc:get()s8=s8+sd*cG end end;local se=1;local sf=0;local sg=1;bP=0;ce=bL()cd=false or cf<ky.noAtmosphericDensityAltitude and ce>0.00001;cf=b.getAltitude()cc=qK()bN=bJ()p_=bN;if bm and cc>-1 and cc-3<Z then if iD.targetGroundAltitudeActivated then iD:deactivateGroundEngineAltitudeStabilization()end end;if ct then qz=not qz;if qz then ct.UpdateRadar()end;if E then rT()end end;if antigrav then cP=antigrav.isActive()==1 end;local sh=1;local si=1;local sj=bN-p_;local sk=-math.deg(qG(qj,cJ,cG))local sl=math.deg(qG(cH,cJ,cG))local gq=cL*-1;cz=cd and sk<-M or sk>M or sl<-N or sl>N;local sm=a.getMouseDeltaX()local sn=a.getMouseDeltaY()if qA then local so=bJ()-qA;sm=sm*so/0.016;sn=sn*so/0.016 end;qA=bJ()if o and not bZ then sn=-sn end;qe=0;qf=0;qd=0;fX=cn[0]local sp=bM.getWorldPosition()ky=fX:closestBody(sp)sq=cp(ky)fs=sq:orbitalParameters(sp,cJ)if cf==0 then cf=(cN-ky.center):len()-ky.radius end;cX=c.getClosestPlanetInfluence()>0 or cf>0 and cf<200000;local ox=ky:getGravity(sp):len()*cg;qg=0;local sr=bM.getMaxThrustAlongAxis("ground",bM.getOrientationUp())[1]if qq==0 then if iC()==1 and bZ then if not cw then c6=dk(c6+sm/2,-ci/2,ci/2)c7=dk(c7+sn/2,-cj/2,cj/2)end else c6=0;c7=0 end else c6=dk(c6+sm/2,-ci/2,ci/2)c7=dk(c7+sn/2,-cj/2,cj/2)dc=dm(c6*c6+c7*c7)if not bZ and iC()==0 then local kU,kV=1,1;if bH=="SCOPE"then kU,kV=d4/90,d4/90 end;if g=="virtual joystick"then if dc>ay then qe=qe-dk(eY(c6)-ay,0,ci/2)*utils.sign(c6)*aG*kU;qd=qd-dk(eY(c7)-ay,0,cj/2)*utils.sign(c7)*aH*kV end else c6=0;c7=0;if g=="mouse"then qd=(-utils.smoothstep(sn,-100,100)+0.5)*2*sh;qe=(-utils.smoothstep(sm,-100,100)+0.5)*2*si end end end end;local ss=cK>27777;if cK>W/3.6 and not cd and not b3 and not ss then c0="Space Speed Engine Shutoff reached"qm=0 end;if not ss and st then if not b0 then cs.BrakeToggle()end;if b3 then cs.ResetAutopilots(1)end;qm=0 end;st=ss;if ce>0.09 then if cK>cA/3.6 and not t and not pW then b0="SpdLmt"pW=true elseif not t and pW then if cK<cA/3.6 then b0=false;pW=false end end end;if b2 then if c9 then b0=false;local su=false;if g4 and c9==true then su=qW(g4.position-cN,0.1)else su=qW(vec3(cJ),0.01)end;cy=true;if su then qn=bK(cA)if(eY(cS)<2 or eY(cR)>85)and cK>=cA/3.6-1 then b0=false;b2=false;if c9~=2 then qc=true end;if c9==true then cb=true end;c9=false;b3=false;cs.BeginReentry()end elseif cd and t then qm=1 end elseif cK>iW then qW(vec3(cJ),0.01)end end;if b1 then if cd then b1=false elseif cK>iW then qW(-vec3(cJ))end end;if not b2 and c9 and not bz then if not cd then if c9~=2 then qc=true end;cs.BeginReentry()c9=false;cb=true else c9=false;if not qx then qx=true end end end;if cb and g4 and(cf<ba+250 and cf>ba-250)and cK*3.6>cA-250 and eY(cM)<25 and ce>=0.1 and(g4.position-cN):len()>2000+cf then if not qx then qx=true end;cb=false end;if b9 then cy=true;local sv=ba;if cM<-30 then c0="Unable to achieve lift. Safety Landing."bX=0;cy=p;b9=false;b6=true elseif not q and cP or ba<ky.spaceEngineMinAltitude then if cP then sv=antigrav.getBaseAltitude()end;if cf<sv-100 then qh=0;bX=15;b0=false elseif cM>0 then b0="VTO Limit"bX=0 elseif cM<-30 then b0="VTO Fall"bX=15 elseif cf>=sv then if cP then if b3 or bq then cs.ToggleVerticalTakeoff()else b0="VTO Complete"b9=false end;c0="Takeoff complete. Singularity engaged"fT("aggLk","AG")else b0=false;c0="VTO complete. Engaging Horizontal Flight"fT("vtoc","VT")cs.ToggleVerticalTakeoff()end;bX=0 end else if ce>0.08 then qh=0;b0=false;bX=20 elseif ce<0.08 and cd then b0=false;if cE then qh=0;bX=20 else bX=0;qh=36;qn=3500 end else cy=p;bz=true;cD=false;sw=false;q4=false;q2=nil;q3=nil;if q7==nil then q7=ky end;cC=sv;q6=true;b9=false end end;if qh~=nil then if sx==nil then sx=pid.new(2*0.01,0,2*0.1)end;local sy=dk(qh-cR,-N*0.80,N*0.80)sx:inject(sy)local sz=dk(sx:get(),-1,1)qd=sz end end;if bz then local function sA()if fs.periapsis.altitude>=cC*0.99 and fs.apoapsis.altitude>=cC*0.99 and fs.periapsis.altitude<fs.apoapsis.altitude and fs.periapsis.altitude*1.05>=fs.apoapsis.altitude and eY(cC-cf)<1000 then return true else return false end end;local r2;local sB=false;local sC=iH(cC)if q7==nil then q7=ky;if bq then q7=c5 end end;if not q6 then cC=bK(q7.radius+q7.surfaceMaxAltitude+U)if q7.hasAtmosphere then cC=bK(q7.radius+q7.noAtmosphericDensityAltitude+U)end;q6=true end;if qi.VectorToTarget and g4 then r2=g4.position-cN end;local sD,sE=cp(q7):escapeAndOrbitalSpeed((cN-q7.center):len()-q7.radius)local sF=cS;if not q4 then local sG=false;local sH=false;qm=0;q3=0;cB="Aligning to orbital path - OrbitHeight: "..sC;if qi.VectorToTarget then qW(r2:normalize():project_on_plane(cL))sB=cG:dot(r2:project_on_plane(qj):normalize())>0.95 else qW(cJ)sB=sk<0.5;if cK<150 then sB=true end end;qd=0;q2=0;if cR<=q2+2 and cR>=q2-2 then sG=true else sG=false end;if sF<=q3+2 and sF>=q3-2 then sH=true else sH=false end;if sG and sH and sB then q2=nil;q3=nil;q4=true end else if qi.VectorToTarget then qW(r2:normalize():project_on_plane(cL))elseif cK>150 then qW(cJ)end;qd=0;if qi.VectorToTarget and g4 then local c3,dP=co.computeDistanceAndTime(cK,cA/3.6,cg,0,0,bs)if cD and r2:len()>15000+c3+cf then cB="Orbiting to Target"if cf-100<=q7.noAtmosphericDensityAltitude or lM>fs.timeToPeriapsis and fs.periapsis.altitude<q7.noAtmosphericDensityAltitude or not sA()and fs.eccentricity>0.1 then c0="Re-Aligning Orbit"cD=false end elseif cD or r2:len()<15000+c3+cf then c0="Orbit complete, proceeding with reentry"fT("orCom","OB")bk=g4.position;qc=true;cb=true;qi.VectorToTarget,qi.AutopilotAlign=false,false;cs.ToggleIntoOrbit()cs.BeginReentry()return end end;if fs.periapsis~=nil and fs.apoapsis~=nil and fs.eccentricity<1 and cf>cC*0.9 and cf<cC*1.4 then if fs.apoapsis~=nil then if sA()or cD then if cD then b0=false;qm=0;q2=0;if not qi.VectorToTarget then c0="Orbit complete"fT("orCom","OB")cs.ToggleIntoOrbit()end else q8=q8+1;if q8>=2 then cD=true end end else cB="Adjusting Orbit - OrbitHeight: "..sC;q5=true;qn=sE*3.6+1;local sI=cC-cf;if sJ==nil then sJ=pid.new(0.1,0,1*0.1)end;sJ:inject(sI-cM*dk(utils.smoothstep(2000-sI,-2000,2000)^6*10,1,10))q2=dk(sJ:get(),-60,60)end end else local sK=2.75;local sL=eY(fU(sD*sK))local oL=sL%50;if oL>0 then sL=sL-oL+50 end;b0=false;if cf<cC*0.8 then cB="Escaping planet gravity - OrbitHeight: "..sC;q2=utils.map(cM,200,0,-15,80)elseif cf>=cC*0.8 and cf<cC*1.15 then cB="Approaching orbital corridor - OrbitHeight: "..sC;sL=sL*0.75;q2=utils.map(cM,100,-100,-15,65)elseif cf>=cC*1.15 and cf<cC*1.5 then cB="Approaching orbital corridor - OrbitHeight: "..sC;sL=sL*0.75;if cM<0 or q5 then q2=utils.map(cf,cC*1.5,cC*1.01,-30,0)else q2=utils.map(cf,cC*0.99,cC*1.5,0,30)end elseif cf>cC*1.5 then cB="Reentering orbital corridor - OrbitHeight: "..sC;q2=-65;local sM=utils.map(cM,-150,-400,1,0.55)sL=sL*sM end;qn=bK(sL)end end;if q2~=nil then if sN==nil then sN=pid.new(1*0.01,0,5*0.1)end;local sO=q2-cR;sN:inject(sO)local sP=dk(sN:get(),-0.5,0.5)qd=sP end end;if b3 and not cd and not c9 then local function sQ(dh,fs)a.print(dh)b0=false;bd=false;b3=false;r9=false;bg="Aligning"qm=0;qb=false;c0=dh;fT("apCom","AP")if fs or c9 then if fs and go~=nil and not c9 then if not cf or cf==0 then return end;cC=cf;q6=true end;cs.ToggleIntoOrbit()end end;local sR,sS=bk,false;if g4 and g4.planetname~="Space"then bc=true;if not r9 then local sT=(g4.position-c5.center):normalize()local sU=sT:project_on_plane((c5.center-cN):normalize()):normalize()local sV=c5.center+sU*(c5.radius+go)local sW=g4.position+(g4.position-c5.center):normalize()*(go-c5:getAltitude(g4.position))if(cN-sV):len()<(cN-sW):len()then sR=sV else sR=sW;bf=0 end;bk=sR;cs.showWayPoint(c5,bk)sS=true;r9=true end;bh=0 elseif g4 and g4.planetname=="Space"then if not r9 then bh=0;sS=true;bc=true;r9=true;sR=g4.position+(cN-g4.position):normalize()*S;bk=sR end elseif g4==nil then bh=0;if not r9 then local sT=(cN+cJ*100000-c5.center):normalize()local sU=sT:project_on_plane((c5.center-cN):normalize()):normalize()if sU:len()<1 then sT=(cN+cG*100000-c5.center):normalize()sU=sT:project_on_plane((c5.center-cN):normalize()):normalize()end;sR=c5.center+sU*(c5.radius+go)bk=sR;r9=true;sS=true;bc=true;cs.showWayPoint(c5,bk)end end;rp=(vec3(sR)-cN):len()local lK,eI,eJ=cn:getPlanetarySystem(0):castIntersections(cN,cJ:normalize(),function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)local lL=eI;if eJ~=nil and eI~=nil then lL=math.min(eJ,eI)end;if lL~=nil and lL<rp and lK.name==c5.name then rp=lL end;local su=true;local sX=(c5.center-(cN+vec3(cJ):normalize()*rp)):len()-c5.radius;local lx=iH(sX)qu=gg;qv='{"label": "Projected Altitude", "value": "'..lx..'"}'if cK>50 and bb then local r2=vec3(sR)-cN;local sY=dk(math.deg(qG(qj,cJ:normalize(),r2:normalize()))*cK/500,-90,90)local sZ=dk(math.deg(qG(cH,cJ:normalize(),r2:normalize()))*cK/500,-90,90)if eY(sY)<20 and eY(sZ)<20 then sY=sY*2;sZ=sZ*2 end;if eY(sY)<2 and eY(sZ)<2 then sY=sY*2;sZ=sZ*2 end;local sk=-math.deg(qG(qj,cG,cJ:normalize()))local sl=-math.deg(qG(cH,cG,cJ:normalize()))if s_==nil then s_=pid.new(2*0.01,0,2*0.1)end;s_:inject(sZ-sl)local t0=dk(s_:get(),-1,1)qd=qd+t0;if t1==nil then t1=pid.new(2*0.01,0,2*0.1)end;t1:inject(sY-sk)local t2=dk(t1:get(),-1,1)qe=qe+t2;sS=true;if eY(sY)>2 or eY(sZ)>2 then if bg~="Adjusting Trajectory"then bg="Adjusting Trajectory"fT("apAdj","AP")end else if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end end elseif bb and cK<=50 then qW((sR-cN):normalize())end;if sX<go*1.5 then bf=cA/3.6;if g4==nil then dP,bf=cp(c5):escapeAndOrbitalSpeed(sX)end end;local c3,c4;if not b4 then c3,c4=qC(cK)else c3,c4=qF(cK)end;if b3 and not bb and not be and not bd then local lK,lL=cs.checkLOS((bk-cN):normalize())if c5.name~=ky.name then if lK~=nil and c5.name~=lK.name and lL<rp then c0="Collision with "..lK.name.." in "..iH(lL).."\nClear LOS to continue."c1=5;qr=true else qr=false;c0=""end end end;if not qr then if not be and not bd and not sS then su=qW((sR-cN):normalize())elseif b4 and(bd or be)then su=qW(-vec3(cJ):normalize())end end;if bb then if not qb then b0=false;qm=a0;bO=fU(a0,2)qb=true end;local rq=c.getThrottle()if t then rq=bO end;local t3=99999;local oJ=-vec3(bM.getWorldAcceleration()):dot(cJ:normalize())local t4=dk(cJ:dot((sR-cN):normalize()),0,cK)if t4>0 or oJ>0 then t3=co.computeTravelTime(t4,oJ,rp-c3)end;if aa>de then aa=de-0.2 end;if cI:len()>=aa or rq==0 and qb or a1/4>t3 then bb=false;if bg~="Cruising"then fT("apCru","AP")bg="Cruising"end;be=true;qm=0 end;local t5=rp;if t5<=c3 or H and cV<=c3+10000 and cU then if H and cV<=c3+10000 and cU then if cV<pX and cV>2000 then cs.ResetAutopilots(1)c0="Autopilot cancelled to prevent crossing PvP Line"b0="PvP Prevent"pX=cV else pX=cV;return end end;bb=false;if bg~="Braking"then fT("apBrk","AP")bg="Braking"end;bd=true;qm=0;qb=false end elseif bd then if bg~="Orbiting to Target"then b0="AP Brk"end;if b4 then qm=1;qo=true end;local dP,sE=cp(c5):escapeAndOrbitalSpeed((cN-ky.center):len()-ky.radius)local r2;if g4 then r2=g4.position-cN end;if g4 and g4.planetname=="Space"and cK<50 then if#bF>0 then if not qx then table.remove(bF,1)end;if#bF>0 then b0=false;if not qx then qx=2 end;return end end;sQ("Autopilot complete, arrived at space location")b0="Space Arrival"elseif g4 and g4.planetname~="Space"and cK<=sE and(fs.apoapsis==nil or fs.periapsis==nil or fs.apoapsis.altitude<=0 or fs.periapsis.altitude<=0)then sQ("Autopilot complete, commencing reentry")bk=g4.position;c9=true;cs.showWayPoint(c5,bk)elseif(g4 and g4.planetname~="Space"or g4==nil)and fs.periapsis~=nil and fs.periapsis.altitude>0 and fs.eccentricity<1 or bg=="Circularizing"then if bg~="Circularizing"then fT("apCir","AP")bg="Circularizing"end;if cK<=sE then if g4 then if cJ:normalize():dot(r2:normalize())>0.4 then if bg~="Orbiting to Target"then fT("apOrb","OB")bg="Orbiting to Target"end;if not rb then b0=false;cs.showWayPoint(c5,g4.position)rb=true end else sQ("Autopilot complete, proceeding with reentry")bk=g4.position;c9=true;cs.showWayPoint(c5,g4.position)rb=false end else sQ("Autopilot completed, setting orbit",true)b0=false end end elseif bg=="Circularizing"then sQ("Autopilot complete, fixing Orbit",true)end elseif be then local t5=rp;if t5<=c3 or H and cV<=c3+10000 and cU then if H and cV<=c3+10000 and cU then if cV<pX and cV>2000 then if not qx then qx=true end;c0="Autopilot cancelled to prevent crossing PvP Line"b0="Prevent PvP"pX=cV else pX=cV;return end end;bb=false;if bg~="Braking"then fT("apBrk","AP")bg="Braking"end;bd=true end;local rq=c.getThrottle()if t then rq=bO end;if rq>0 then bb=true;if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end;be=false end else if su then if not bc and g4==nil or not bc and g4 and g4.planetname~="Space"then if not c9 then bk=vec3(c5.center)+(go+c5.radius)*cH;t6=qj;t7=cH end;bc=true elseif su and not qr then bb=true;if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end;if not qb then qm=a0;qo=true;bO=fU(a0,2)qb=true;b0=false end end end end elseif b3 and(g4~=nil and g4.planetname~="Space"and cd)then c0="Autopilot complete, starting reentry"fT("apCom","AP")bk=g4.position;b0=false;bd=false;b3=false;r9=false;bg="Aligning"qm=0;qb=false;b2=true;c9=true;cs.showWayPoint(c5,g4.position)end;if bY then cy=true;local sZ=0;local fu=cN+vec3(c.getMasterPlayerRelativePosition())local t8=fu-cN;local t9=vec3(t8):project_on(cG):len()local ta=vec3(t8):project_on(cH):len()local c8=dm(t9*t9+ta*ta)qW(t8:normalize())local mS=40;local tb=c8<mS;local tc=100;local rC=dk((c8-mS)/2,10,tc)qd=0;local su=eY(qe)<0.1;if su and cK<rC and not tb then b0=false;sZ=-20 else b0="Follow"sZ=0 end;local td=0;if eY(sZ-cR)>td then if te==nil then te=pid.new(2*0.01,0,2*0.1)end;te:inject(sZ-cR)local t0=te:get()qd=t0 end end;if b5 or b6 or b8 or bq or bt~=nil then local tf=bu;if tf then tf=tf*dk(cK/100,0.1,1)*ce else tf=bs end;if not cd then tf=bs end;ql=cG:project_on_plane(cL):normalize():dot(cJ)if ql>100 then c3,c4=co.computeDistanceAndTime(ql,100,cg,0,0,tf)local tg,th=co.computeDistanceAndTime(100,0,cg,0,0,tf*0.55)c3=c3+tg else c3,c4=co.computeDistanceAndTime(ql,0,cg,0,0,tf*0.55)end;local sI=ba-cf-cM;local ti=200+cK;if b8 or c9 then tj=2000+cK end;local tk=1;if b7 then tk=dk(cK/100,0.1,1)end;local sZ=(utils.smoothstep(sI,-ti,ti)-0.5)*2*P*tk;if not b8 and not c9 and not bq and cG:dot(cJ:normalize())<0.99 then sZ=(utils.smoothstep(sI,-ti*dk(20-19*ce*10,1,20),ti*dk(20-19*ce*10,1,20))-0.5)*2*P*dk(2-ce*10,1,2)*tk end;if not b5 then sZ=0 end;if bt~=nil then if cX and not bz then sZ=bt else bt=nil end end;cy=true;local tl=qd;if b8 then local tm=bK(cA)local tn,to=co.computeDistanceAndTime(cK,tm/3.6,cg,0,0,bs-ky.gravity*9.8*cg)tn=tn==-1 and 5000 or tn;local ra=cf-(ky.noAtmosphericDensityAltitude+tn)local tp=cf>ky.noAtmosphericDensityAltitude+tn*1.35;if tp then sZ=Q;if cK<=tm/3.6 and cK>tm/3.6-10 and eY(cJ:normalize():dot(cG))>0.9 and not cQ then bS=false;qm=1 end elseif(cQ or iD:getTargetSpeed(axisCommandId.longitudinal)~=tm)and not tp and not cd then qn=tm;qo=true end;if cQ then if cK>tm/3.6 and not tp then b0="Reentry Limit"if bO>0 then qm=0 end else b0=false end else b0=false end;if cM>0 then b0="Reentry vSpd"end;if not qc then sZ=-80;if cf<ky.surfaceMaxAltitude+(ky.atmosphereThickness-ky.surfaceMaxAltitude)*0.25 then c0="PARACHUTE DEPLOYED at "..fU(cf,0)b8=false;b6=true;lF=true;qm=0;sZ=0;cy=p end elseif ky.noAtmosphericDensityAltitude>0 and tp then cy=true elseif not tp then if not cd and(cQ or iD:getTargetSpeed(axisCommandId.longitudinal)~=tm)then qn=tm end;if cK<tm/3.6+1 then b0=false;qc=false;b8=false;cy=true;qm=1 end end end;if cK>iW and not ca and not bq and not b6 and u then qW(vec3(cJ))end;if cW or(bq or ca)and bl>0 and cd then local r2;if cW then if type(cW)=="table"then r2=cW elseif cW<3 and cW>0 then r2=-cL:cross(cJ)*5000 elseif cW>=3 then r2=cL:cross(cJ)*5000 elseif cW<0 then r2=cJ*25000 end elseif g4~=nil then r2=g4.position-cN else r2=c5.center-cN end;local sY=math.deg(qG(cL:normalize(),cJ,r2))*2;local mV=math.rad(eY(cS))if cK>aL and cd then local tq=1000+cK;local tr=(utils.smoothstep(sI-cM*10,-tq,tq)-0.5)*2*P;local ts=dk(90-tr,0,180)qg=dk(sY*2,-ts,ts)local tt=sY;sY=dk(dk(sY,-M*0.80,M*0.80)*math.cos(mV)+4*(cR-sZ)*math.sin(math.rad(cS)),-M*0.80,M*0.80)local tu=1;if qg~=0 then tu=eY(mV/qg)end;tu=(90-dk(eY(qg-cS),0,90))/90;local tv=sZ;if eY(cS)>90 then tv=-tv end;sZ=tu*dk(dk(tv*math.cos(mV),-N*0.8,N*0.8)+eY(dk(eY(tt)*math.sin(mV),-N*0.80,N*0.80)),-N*0.80,N*0.80)else qg=0;sY=dk(sY,-M*0.80,M*0.80)end;local tw=sk-sY;if cW and eY(tw)<=0.0001 and(type(cW)=="table"or type(cW)~="table"and cW<0 and eY(cS)<1)then if cW==-2 then cs.ToggleAltitudeHold()end;cW=nil;fT("180Off","BR")return end;if not cz and cK>aL and cd then if tx==nil then tx=pid.new(2*0.01,0,2*0.1)end;tx:inject(tw)local t2=dk(tx:get(),-1,1)qe=qe+t2 elseif cd and cc>-1 or cK<aL then qW(r2)elseif cz and cd then if(sk<-M or sk>M)and cd then qW(cJ)end;if(sl<-N or sl>N)and cd then sZ=dk(cR-sl,cR-N*0.80,cR+N*0.80)end end;if g4~=nil and not ca then local sv=ky:getAltitude(g4.position)local ra=r2:project_on_plane(cL):len()lF=true;if ba<ky.noAtmosphericDensityAltitude and not ca and not b7 and not b8 and(ra<=c3 and r2:len()<ky.radius)and(cJ:project_on_plane(cL):normalize():dot(r2:project_on_plane(cL):normalize())>0.99 or lO=="Finalizing Approach")then lO="Finalizing Approach"if#bF>0 then if not qx then table.remove(bF,1)end;if#bF>0 then if not qx then qx=2 end;return end end;qm=0;if b5 then cs.ToggleAltitudeHold()bq=true end;b0="AP Finalizing"elseif not b7 then b0=false end;if lO=="Finalizing Approach"and(ql<0.1 or ra<0.1 or ty~=nil and ty<ra)then fT("bklOn","BL")b6=true;da=true;if g4.heading then db=g4.heading else db=nil end;bq=false;lO="Proceeding to Waypoint"cY=false end;ty=ra end elseif bq and not cd and ba>ky.noAtmosphericDensityAltitude and not(ca or b8)then if g4~=nil and c5.name==ky.name then local r2=g4.position-cN;local sv=ky:getAltitude(g4.position)local ra=dm(r2:len()^2-(cf-sv)^2)local tf=bu;if tf then c3,c4=co.computeDistanceAndTime(cK,0,cg,0,0,tf/2)lF=true;if ra<=c3+cK*sj/2 and cJ:project_on_plane(cL):normalize():dot(r2:project_on_plane(cL):normalize())>0.99 then if ky.hasAtmosphere then b0=false;b2=false;qc=true;c9=false;cb=true;b3=false;cs.BeginReentry()end end;ty=ra end end end;if not cd and(b5 and ba>ky.noAtmosphericDensityAltitude)and not(ca or bz or b8)then if not cD and not bz then cC=ba;q6=true;if bq then qi.VectorToTarget=true end;cs.ToggleIntoOrbit()bq=false;q4=true end end;if cz and cd and cc==-1 and cK>aL and lO~="Finalizing Approach"then qW(cJ)sZ=dk(cR-sl,cR-N*0.80,cR+N*0.80)end;qd=tl;local qP=-1;if b6 then if not qs then if not cQ then qm=0 end;iD:setTargetGroundAltitude(500)iD:activateGroundEngineAltitudeStabilization(500)bB=true;qs=true end;sZ=0;local tz=false;local tA=math.abs(ql)if not q and cP then tz=antigrav.getBaseAltitude()if tz<ky.surfaceMaxAltitude and g4==nil or g4~=nil and ky:getAltitude(g4.position)>tz then tz=false end else tz=false end;if db then if tA<0.05 then if cM>-O then b0=false else b0="BL Align BLR"end;if qW(db,0.001)then db=nil;cy=p else qd=0;cy=true end else b0="BL Align Hzn"end;if tz and eY(cf-tz)<250 then b0="AGG Align"end else local tB=false;local tC=30;if tA<10 and sr~=nil and sr>0 then local tD=dk(ce,0.4,2)local tf=bu*dk(cK/100,0.1,1)*tD;local tE=sr*tD+tf-ox;local tF=tf/2-ox;local tG=cK-dm(eY(tF/2)*20/(0.5*cg))*utils.sign(tF)if tG<0 then tG=0 end;local tH;if cK>100 then local tI,dP=co.computeDistanceAndTime(cK,100,cg,0,0,tf)local tJ,dP=co.computeDistanceAndTime(100,0,cg,0,0,dm(tf))tH=tI+tJ else tH=co.computeDistanceAndTime(cK,0,cg,0,0,dm(tf))end;if tH<20 then b0=false else local tK=0;if tG>100 then local tL,dP=co.computeDistanceAndTime(tG,100,cg,0,0,tE)local tM,dP=co.computeDistanceAndTime(100,0,cg,0,0,sr*tD+dm(tf)-ox)tK=tL+tM else tK,dP=co.computeDistanceAndTime(tG,0,cg,0,0,sr*tD+dm(tf)-ox)end;tK=(tK+15+cK*sj)*1.1;local tN=da and g4~=nil and ky:getAltitude(g4.position)>0 and g4.safe;local sv=nil;if tz and tz<cf then sv=tz elseif tN then sv=ky:getAltitude(g4.position)+250 elseif cf>ky.surfaceMaxAltitude then sv=ky.surfaceMaxAltitude end;if cZ then local tO=ky:getAltitude(cZ[1].center)if sv then if tO>sv then sv=tO end else sv=tO end end;if sv~=nil then local tP=cf-sv;tB=true;if tP<=tK or tK==-1 or tA>0.05 and da then if tA>0.05 and da then b0="BL AP Hzn"else b0="BL Stop Dist"end else b0=false end end end end;qP=cc;if qP>-1 then if(cK<1 or cJ:normalize():dot(cL)<0)and not db then b6=false;b5=false;if not tz then qp=true;iD:setTargetGroundAltitude(Z)end;bX=0;b0="BL Complete"cy=p;da=false else b0="BL Slowing"end elseif not tB then if lF and cJ:normalize():dot(-gq)<0.999 then b0="BL Strong"qW()elseif tA>10 or tA>0.05 and da then b0="BL hSpd"elseif cM<-O then b0="BL BLR"else b0=false end end end else qs=false end;if b7 or ca then local lK,eJ,eI;if bk~=nil then lK,eJ,eI=cn:getPlanetarySystem(0):castIntersections(cN,(bk-cN):normalize(),function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)end;if cP and not ca then if cf>=ba-50 and cK>iW then b7=false;if not b3 and not bq then b0="ATO Agg Arrive"qm=0 end end elseif eY(sZ)<15 and cf/ba>0.75 then b7=false;if not ca then if cQ and not t then d.control.cancelCurrentControlMasterMode()end elseif ca and cK<iW then b3=true;ca=false;b5=false;b7=false;qm=0 elseif ca then qm=0;b0="ATO Space"end elseif ca and not cd and c5~=nil and(lK==nil or lK.name==c5.name)then b3=true;ca=false;b5=false;b7=false;if not cQ then qm=0 end;bb=true end end;local tQ=cc>-1;local tR=cR;if(bq or ca or cW)and not tQ and cK>aL and cd then local mV=math.rad(eY(cS))tR=cR*eY(math.cos(mV))+sl*math.sin(mV)end;local tS=dk(sZ-tR,-N*0.80,N*0.80)if not cd and bq then tS=dk(sZ-tR,-85,P)elseif not cd then tS=dk(sZ-tR,-P,P)end;if eY(cS)<5 or bq or cW or b6 or tQ or b5 then if te==nil then te=pid.new(5*0.01,0,5*0.1)end;te:inject(tS)local t0=te:get()qd=qd+t0 end end;if antigrav~=nil and(antigrav and not q and cf<200000)then if bv==nil or bv<1000 then bv=1000 end;if tT~=bv then tT=bv;qw=tT end end;if(cd or b8 or cb)and t and cQ then if tU==nil then tU=pid.new(0.1,0,1)end;local tV=0;if aU>0 and not b8 and ce>0.005 and ce<0.1 and cM>-50 then tV=(0.1-ce)*cA*aU end;tU:inject(cA/3.6+tV-cJ:dot(cG))local tW=tU:get()bR=dk(tW,-1,1)if not d6 then if bR<bO and(ce>0.005 or b8 or cb)then bQ=true;d6=dk(bR,0.01,1)else bQ=false;d6=bO end end;if tX==nil then tX=pid.new(1*0.01,0,1*0.1)end;tX:inject(cJ:len()-cA/3.6-tV)local tY=dk(tX:get(),0,1)if cd and cM<-80 or(ce>0.005 or b8 or cb)then bP=tY end;if bP>0 then if bQ and bR==0.01 and not d6 then d6=0 end else bR=dk(bR,0.01,1)end;local tZ=''local t_=vec3()local u0=rA(axisCommandId.vertical,bX*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",u0,sf)local u1='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then u1=u1 ..aV end;local u2=iD:getAxisCommandType(axisCommandId.longitudinal)local u3=iD:composeAxisAccelerationFromThrottle(u1,axisCommandId.longitudinal)local u4=rO(axisCommandId.lateral,by*1000)tZ=tZ..' , '.."lateral airfoil , lateral ground "t_=t_+u4;if t_:len()>constants.epsilon then d:setEngineForceCommand(tZ,t_,sf,'','','',sg)end;d:setEngineForceCommand(u1,u3,se)local u5='thrust analog vertical fueled 'local u6='thrust analog lateral fueled 'if bC=="All"or bC=="Lateral"then u6=u6 ..aW end;if bC=="All"or bC=="Vertical"then u5=u5 ..aX end;if bX~=0 or b6 and b0 or not bm and not bB then d:setEngineForceCommand(u5,u0,se)else d:setEngineForceCommand(u5,vec3(),se)end;if by~=0 then d:setEngineForceCommand(u6,u4,se)else d:setEngineForceCommand(u6,vec3(),se)end;if s0==0 then s0=bP end;local u7=-s0*(aQ*cJ+aR*s4)d:setEngineForceCommand('brake',u7)else if t then if not d6 then d6=bO end end;local rC=c.getAxisCommandValue(0)if not cQ then if tX==nil then tX=pid.new(1*0.01,0,1*0.1)end;tX:inject(cJ:len()-rC/3.6)local tY=dk(tX:get(),0,1)s0=dk(s0+tY,0,1)end;local u7=-s0*(aQ*cJ+aR*s4)d:setEngineForceCommand('brake',u7)local tZ=''local t_=vec3()local u8=false;local u1='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then u1=u1 ..aV end;local u2=iD:getAxisCommandType(axisCommandId.longitudinal)if u2==axisCommandType.byThrottle then local u3=iD:composeAxisAccelerationFromThrottle(u1,axisCommandId.longitudinal)d:setEngineForceCommand(u1,u3,se)elseif u2==axisCommandType.byTargetSpeed then local u3=iD:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tZ=tZ..' , '..u1;t_=t_+u3;if iD:getTargetSpeed(axisCommandId.longitudinal)==0 or iD:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iD:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u8=true end end;local u6='thrust analog lateral 'if bC=="All"or bC=="Lateral"then u6=u6 ..aW end;local u9=iD:getAxisCommandType(axisCommandId.lateral)if u9==axisCommandType.byThrottle then local ua=iD:composeAxisAccelerationFromThrottle(u6,axisCommandId.lateral)d:setEngineForceCommand(u6,ua,se)elseif u9==axisCommandType.byTargetSpeed then local u4=iD:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tZ=tZ..' , '..u6;t_=t_+u4 end;local u5='thrust analog vertical 'if bC=="All"or bC=="Vertical"then u5=u5 ..aX end;local ub=iD:getAxisCommandType(axisCommandId.vertical)if ub==axisCommandType.byThrottle then local u0=iD:composeAxisAccelerationFromThrottle(u5,axisCommandId.vertical)if bX~=0 or b6 and b0 then d:setEngineForceCommand(u5,u0,se,'airfoil','ground','',sg)else d:setEngineForceCommand(u5,vec3(),se)d:setEngineForceCommand('airfoil vertical',u0,se,'airfoil','','',sg)d:setEngineForceCommand('ground vertical',u0,se,'ground','','',sg)end elseif ub==axisCommandType.byTargetSpeed then if bX<0 then d:setEngineForceCommand('hover',vec3(),se)end;local uc=iD:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tZ=tZ..' , '..u5;t_=t_+uc end;if t_:len()>constants.epsilon then if s0~=0 or u8 or eY(s4:dot(cG))<0.5 then tZ=tZ..', brake'end;d:setEngineForceCommand(tZ,t_,sf,'','','',sg)end end;local ud=aN*(s8-s7)local ue=vec3(bM.getWorldAirFrictionAngularAcceleration())ud=ud-ue;d:setEngineTorqueCommand('torque',ud,se,'airfoil','','',sg)d:setBoosterCommand('rocket_engine')if c2 and not n then local fo=cI:len()local uf=0.15;if not cQ then local ug=iD:getTargetSpeed(axisCommandId.longitudinal)if fo*3.6>ug*(1-uf)and uh then uh=false;d:toggleBoosters()elseif fo*3.6<ug*(1-uf)and not uh then uh=true;d:toggleBoosters()end else local rq=c.getThrottle()if t then rq=bO*100 end;local rC=rq/100;if not cd then rC=rC*aa;if fo>=rC*(1-uf)and uh then uh=false;d:toggleBoosters()elseif fo<rC*(1-uf)and not uh then uh=true;d:toggleBoosters()end else local tm=bK(cA)rC=rC*tm/3.6;if fo>=rC*(1-uf)and uh then uh=false;d:toggleBoosters()elseif fo<rC*(1-uf)and not uh then uh=true;d:toggleBoosters()end end end end end;if ui then for dK,dw in pairs(ui)do pV[dK]=dw end end;cc=qK()return pV end;local function uj(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uk,iC,iD,iE,ul,gL,fU,e3,dl,dk,fT,iG,pU)local bM=DUConstruct;local um={}local un=true;local uo=5;local up=5;local uq=uo;local ur=up;local us=bN;function um.landingGear()bm=not bm;if bm then bq=false;bt=nil;cs.cmdThrottle(0)if vBooster or hover then if cd and cc==-1 then fT("bklOn","BL")lF=true;b8=false;b7=false;b9=false;b5=false;if b6 then da=not da end;b6=true;cy=true;bm=false else if bT then fT("grOut","LG",1)d.control.deployLandingGears()end;da=false;iD:setTargetGroundAltitude(Z)if cd then b0="Landing"end end elseif bT and not b6 then fT("grOut","LG",1)d.control.deployLandingGears()end else if bT then fT("grIn","LG",1)d.control.retractLandingGears()end;iD:activateGroundEngineAltitudeStabilization(ut)if bB then if Z<iD.targetGroundAltitude then iD:setTargetGroundAltitude(iD.targetGroundAltitude)else iD:setTargetGroundAltitude(Y)end end end end;function um.startControl(uu)local function uv(rl)local rm=1;local function uw(ux,rl)local uy={ky.surfaceMaxAltitude+100,ky.spaceEngineMinAltitude-0.01*ky.noAtmosphericDensityAltitude,ky.noAtmosphericDensityAltitude+U,ky.radius*(T-1)+ky.noAtmosphericDensityAltitude}local uz=ux;for dP,dw in ipairs(uy)do if rl and uz>dw then ux=dw elseif ux<dw and not rl then ux=dw;break end end;return ux end;if rl then rm=-1 end;if not q and cP then if bZ and rl then bv=1000 elseif bv~=nil then bv=bv+rm*up;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end else bv=tT+rm*100 end elseif b5 or b9 or bz then if bz then if bZ then cC=uw(cC,rl)else cC=cC+rm*uo end;if cC<ky.noAtmosphericDensityAltitude then cC=ky.noAtmosphericDensityAltitude end else if bZ and cd then ba=uw(ba,rl)else ba=ba+rm*uo end end else iD:updateTargetGroundAltitudeFromActionStart(rm*1.0)end end;local function uA(uB)if not cd then c0="Flight Assist in Atmo only"return end;local dt=type(uB)if cW==nil then if dt=="table"then if b3 or bq then cs.ToggleAutopilot()end;fT("180On","BR")elseif uB==1 then fT("bnkLft","BR")else fT("bnkRht","BR")end;if not b5 and not b3 and not bq then cs.ToggleAltitudeHold()if dt~="table"then uB=uB+1 end end;cW=uB else fT("180Off","BR")cW=nil end end;local function uC()if iE()==1 then c6=0;c7=0;ul(bi)elseif iC()==1 and y then cx=false;cw=false end;bZ=false end;if uu=="gear"then cu.landingGear()elseif uu=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uu=="forward"then if pm and not cd and not b3 then b2=not b2;b1=false else bU=bU-1 end elseif uu=="backward"then if pm then if not cd then if not b3 then b1=not b1;b2=false else b4=not b4 end else uA(-cJ*5000)end else bU=bU+1 end elseif uu=="left"then if pm then uA(1)else bV=bV-1 end elseif uu=="right"then if pm then uA(3)else bV=bV+1 end elseif uu=="yawright"then bW=bW-1;db=nil elseif uu=="yawleft"then bW=bW+1;db=nil elseif uu=="straferight"then iD:updateCommandFromActionStart(axisCommandId.lateral,1.0)by=1 elseif uu=="strafeleft"then iD:updateCommandFromActionStart(axisCommandId.lateral,-1.0)by=-1 elseif uu=="up"then bX=bX+1;if cc-3<Z and cf>0 and bm then cu.landingGear()end;iD:deactivateGroundEngineAltitudeStabilization()iD:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif uu=="down"then bX=bX-1;iD:deactivateGroundEngineAltitudeStabilization()iD:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif uu=="groundaltitudeup"then uv()elseif uu=="groundaltitudedown"then uv(true)elseif uu=="option1"then uD=false;if pm and bZ then local uE=""for L=1,#d1 do uE=uE.."| Name: "..a.getPlayerName(d1[L]).." Mass: "..fU(bM.getBoardedPlayerMass(d1[L])/1000,1).."t "end;a.print("Onboard: "..uE)return end;cr.adjustAutopilotTargetIndex()elseif uu=="option2"then uD=false;if pm and bZ then for L=1,#d1 do bM.forceDeboard(d1[L])bM.forceInterruptVRSession(d1[L])end;c0="Deboarded All Passengers"return end;cr.adjustAutopilotTargetIndex(1)elseif uu=="option3"then local function uF()un=not un;if not un then fT("wid","DH")c.showWidget()b.showWidget()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(uG,atmofueltank_size,"Atmo Fuel","fuel_container")uH=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uI,spacefueltank_size,"Space Fuel","fuel_container")uJ=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uK,rocketfueltank_size,"Rocket Fuel","fuel_container")uL=_autoconf.panels[_autoconf.panels_size]end;uM=a.createWidgetPanel("Docking")uN=a.createWidget(uM,"parenting")a.addDataToWidget(c.getWidgetDataId(),uN)uO=a.createWidgetPanel("Core combat stress")uP=a.createWidget(uO,"core_stress")a.addDataToWidget(b.getWidgetDataId(),uP)if shield~=nil then shield.showWidget()end else fT("hud","DH")c.hideWidget()b.hideWidget()if uH~=nil then gL(uH)uH=nil end;if uM~=nil then gL(uM)uM=nil end;if uO~=nil then gL(uO)uO=nil end;if uJ~=nil then gL(uJ)uJ=nil end;if uL~=nil then gL(uL)uL=nil end;if shield~=nil then shield.hideWidget()end end end;uD=false;if pm and bZ then local uE=""for L=1,#d2 do uE=uE.."| ID: "..d2[L].." Mass: "..fU(b.getDockedConstructMass(d2[L])/1000,1).."t "end;a.print("Docked Ships: "..uE)return end;if x then if w then w=false else w=true end end;uF()elseif uu=="option4"then uD=false;if pm and bZ then for L=1,#d2 do b.forceUndock(d2[L])end;c0="Undocked all ships"return end;cW=nil;cs.ToggleAutopilot()elseif uu=="option5"then uD=false;cs.ToggleLockPitch()elseif uu=="option6"then uD=false;if pm and bZ then if shield then cv.ventShield()else c0="No shield found"end;return end;cs.ToggleAltitudeHold()elseif uu=="option7"then uD=false;if pm and bZ then if shield then shield.toggle()return else c0="No shield found"return end end;E=not E;if E then c0="Collision System Enabled"else c0="Collision System Secured"end elseif uu=="option8"then uD=false;if pm and bZ then if bl>0 and g4~=nil then cs.routeWP()else c0="Select a saved wp on IPH to add to or remove from route"end;return end;bB=not bB;if not bB then c0="DeCoupled Mode - Ground Stabilization off"iD:deactivateGroundEngineAltitudeStabilization()fT("gsOff","GS")else c0="Coupled Mode - Ground Stabilization on"iD:activateGroundEngineAltitudeStabilization(ut)dd=true;fT("gsOn","GS")end elseif uu=="option9"then uD=false;if pm and bZ then iD:resetCommand(axisCommandId.longitudinal)iD:resetCommand(axisCommandId.lateral)iD:resetCommand(axisCommandId.vertical)cs.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ch=gyro.getState()==1;if ch then fT("gyOn","GA")else fT("gyOff","GA")end else c0="No gyro found"end elseif uu=="lshift"then c_=false;if pm then bZ=true elseif bZ then uC()else if iE()==1 then bZ=true;bi=iE()ul(1)elseif iC()==1 and y then bZ=true;cx=false;cw=false end end elseif uu=="brake"then if aZ or pm then cs.BrakeToggle("Manual")elseif not b0 then cs.BrakeToggle("Manual")else b0="Manual"end elseif uu=="lalt"then uD=true;pm=true;if iC()==0 and not i and g=="keyboard"then ul(1)end elseif uu=="booster"then if n then d:toggleBoosters()elseif not c2 then if not uh then d:toggleBoosters()uh=true end;c2=true else if uh then d:toggleBoosters()uh=false end;c2=false end elseif uu=="stopengines"then local function uQ()if bN-us<1.5 then fT("clear","CA")cs.clearAll()end end;uQ()us=bN;if iD:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bO~=0 then iD:resetCommand(axisCommandId.longitudinal)cs.cmdThrottle(0)else cs.cmdThrottle(100)end else if iD:getTargetSpeed(axisCommandId.longitudinal)~=0 then iD:resetCommand(axisCommandId.longitudinal)else if cd then cs.cmdCruise(cA)else cs.cmdCruise(aa*3.6)end end end elseif uu=="speedup"then if bZ and not pm then dg("RADAR OFF")return end;cs.changeSpd()elseif uu=="speeddown"then cs.changeSpd(true)elseif uu=="antigravity"and not q then if antigrav~=nil then cs.ToggleAntigrav()else c0="No antigrav found"end elseif uu=="leftmouse"then if pm and bZ then if ct then ct.ToggleRadarPanel()ct=nil;J=false else J=true;uR.radarSetup()end;uD=false elseif bZ then b_=true;uC()end end end;function um.stopControl(uu)local function uS()if not q and cP then ur=up end;if b5 or b9 or bz then uq=uo end end;if uu=="forward"then bU=0 elseif uu=="backward"then bU=0 elseif uu=="left"then if cW then if cW==2 then cW=-2 else cW=-1 end end;bV=0 elseif uu=="right"then if cW then if cW==4 then cW=-2 else cW=-1 end end;bV=0 elseif uu=="yawright"then bW=0 elseif uu=="yawleft"then bW=0 elseif uu=="straferight"then iD:updateCommandFromActionStop(axisCommandId.lateral,-1.0)by=0 elseif uu=="strafeleft"then iD:updateCommandFromActionStop(axisCommandId.lateral,1.0)by=0 elseif uu=="up"then bX=0;iD:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bB then iD:activateGroundEngineAltitudeStabilization(ut)dd=true end elseif uu=="down"then bX=0;iD:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bB then iD:activateGroundEngineAltitudeStabilization(ut)dd=true end elseif uu=="groundaltitudeup"then uS()uD=false elseif uu=="groundaltitudedown"then uS()uD=false elseif uu=="brake"then if not aZ and not pm then if b0 then cs.BrakeToggle()else b0=false end end elseif uu=="lalt"then if bZ then bZ=false end;if iC()==0 and i then if uD then if iE()==1 then ul(0)else ul(1)end else uD=true end elseif iC()==0 and not i and g=="keyboard"then ul(0)end;pm=false end end;function um.loopControl(uu)local function uT(rl)local rm=1;if rl then rm=-1 end;if not q and cP then if bv~=nil then bv=bv+rm*ur;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end;ur=dk(ur*1.05,up,50)else bv=tT+rm*100 end elseif b5 or b9 or bz then if bz then cC=cC+rm*uq;if cC<ky.noAtmosphericDensityAltitude then cC=ky.noAtmosphericDensityAltitude end else ba=ba+rm*uq end;uq=dk(uq*1.05,uo,50)else iD:updateTargetGroundAltitudeFromActionLoop(rm*1.0)end end;local function uU(rl)local rm=1;if rl then rm=-1 end;if not bZ then if t and not pm then bO=dk(bO+rm*aF/100,-1,1)else iD:updateCommandFromActionLoop(axisCommandId.longitudinal,rm*aF)end end end;if uu=="groundaltitudeup"then if not bZ then uT()end elseif uu=="groundaltitudedown"then if not bZ then uT(true)end elseif uu=="speedup"then uU()elseif uu=="speeddown"then uU(true)end end;function um.inputTextControl(rk)local function uV(uW,fu,gy)local function uX(fu)local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD='::pos{'..dC..','..dC..','..dC..','..dC..','..dC..'}'local dT,dU,e0,e1,e2=e3(fu,dD)if dT=="0"and dU=="0"then return vec3(dl(e0),dl(e1),dl(e2))end;e1=math.rad(e1)e0=math.rad(e0)local ky=e[dl(dT)][dl(dU)]local eU=math.cos(e0)local uY=vec3(eU*math.cos(e1),eU*math.sin(e1),math.sin(e0))return ky.center+(ky.radius+e2)*uY end;local fW=uX(fu)return cr.AddNewLocation(uW,fW,gy)end;local L;local uZ,ir=nil,nil;local u_="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."L=string.find(rk," ")uZ=rk;if L~=nil then uZ=string.sub(rk,0,L-1)ir=string.sub(rk,L+1)end;if uZ=="/help"or uZ=="/commands"then for lG in string.gmatch(u_,"([^\n]+)")do a.print(lG)end;return elseif uZ=="/setname"then if ir==nil or ir==""then c0="Usage: ah-setname Newname"return end;if bl>0 and g4~=nil then cr.UpdatePosition(ir)else c0="Select a saved target to rename first"end elseif shield and uZ=="/resist"then cv.setResist(ir)elseif uZ=="/addlocation"or string.find(rk,"::pos")~=nil then local gy=false;local uW="0-Temp"if ir==nil or ir==""or uZ~="/addlocation"then ir=uZ;gy=true end;L=string.find(ir,"::")if not gy then uW=string.sub(ir,1,L-2)end;local fu=string.sub(ir,L)uV(uW,fu,gy)elseif uZ=="/agg"then if ir==nil or ir==""then c0="Usage: /agg targetheight"return end;ir=dl(ir)if ir<1000 then ir=1000 end;bv=ir;c0="AGG Target Height set to "..ir elseif uZ=="/G"then if ir==nil or ir==""then c0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ir=="dump"then for dK,dw in pairs(iG())do if type(dw.get())=="boolean"then if dw.get()==true then a.print(dK.." true")else a.print(dK.." false")end elseif dw.get()==nil then a.print(dK.." nil")else a.print(dK.." "..dw.get())end end;return end;L=string.find(ir," ")local v0=string.sub(ir,0,L-1)local v1=string.sub(ir,L+1)for dK,dw in pairs(iG())do if dK==v0 then local v2=type(dw.get())if v2=="number"then v1=dl(v1)if dK=="AtmoSpeedLimit"then cA=v1 end end;c0="Variable "..v0 .." changed to "..v1;if dK=="MaxGameVelocity"then v1=v1/3.6;if v1>de-0.2 then v1=de-0.2;c0="Variable "..v0 .." changed to "..fU(v1*3.6,1)end end;if v2=="boolean"then if string.lower(v1)=="true"then v1=true else v1=false end end;dw.set(v1)return end end;c0="No such global variable: "..v0 elseif uZ=="/deletewp"then if bl>0 and g4~=nil then cr.ClearCurrentPosition()else c0="Select a custom wp to delete first in IPH"end elseif uZ=="/copydatabank"then if dbHud_2 then pU(true)else c0="Spare Databank required to copy databank"end elseif uZ=="/iphWP"then if bl>0 then a.print(cs.showWayPoint(c5,bk,true))a.print(json.encode(bk))c0="::pos waypoint shown in lua chat in local and world format"else c0="No target selected in IPH"end elseif uZ=="/createPrivate"then local v3="privatelocations = {\n"local v4=""if#d8>0 then for dK,dw in pairs(d8)do v3=v3 .."{position = {x = "..dw.position.x..", y = "..dw.position.y..", z = "..dw.position.z.."},\n ".."name = '"..dw.name.."',\n planetname = '"..dw.planetname.."',\n gravity = "..dw.gravity..",\n"if dw.heading then v3=v3 .."heading = {x = "..dw.heading.x..", y = "..dw.heading.y..", z = "..dw.heading.z.."},\n"end;if dw.safe then v3=v3 .."safe = true},\n"else v3=v3 .."safe = false},\n"end end end;v4=#d8 .."-Private "if ir=="all"then for dK,dw in pairs(bp)do v3=v3 .."{position = {x = "..dw.position.x..", y = "..dw.position.y..", z = "..dw.position.z.."},\n ".."name = '*"..dw.name.."',\n planetname = '"..dw.planetname.."',\n gravity = "..dw.gravity..",\n"if dw.heading then v3=v3 .."heading = {x = "..dw.heading.x..", y = "..dw.heading.y..", z = "..dw.heading.z.."},\n"end;if dw.safe then v3=v3 .." safe = true},\n"else v3=v3 .."safe = false},\n"end end;v4=v4 ..#bp.."-Public "end;v3=v3 .."}\n return privatelocations"if uk then uk.setHTML(v3)end;c0=v4 .."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c1=7 end end;function um.tagTick()if bC=="Off"then bC="All"elseif bC=="All"then bC="Longitude"elseif bC=="Longitude"then bC="Lateral"elseif bC=="Lateral"then bC="Vertical"else bC="Off"end;c0="Extra Engine Tags: "..bC;c.stopTimer("tagTick")end;if v5 then for dK,dw in pairs(v5)do um[dK]=dw end end;return um end;local function v6(d,b,c,e,vBooster,hover,pT,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iz,uk)local a=DUSystem;local bM=DUConstruct;local v7=DUPlayer;local v8=DULibrary;local v9={}local dj=string.format;local iA=json.decode;local va=json.encode;local pM=b.getElementMaxHitPointsById;local iB=b.getElementMassById;local iC=d.control.isRemoteControlled;local e3=string.match;local gL=a.destroyWidgetPanel;local fR=a.updateData;local fS=a.addDataToWidget;local ul=a.lockView;local iE=a.isViewLocked;local dm=math.sqrt;local dl=tonumber;local eY=math.abs;local bK=math.floor;local bL=c.getAtmosphereDensity;local eT=math.atan;local bJ=a.getArkTime;local dk=utils.clamp;local iD=d.axisCommandManager;local vb=Z;local gN=13;local iJ=b.getElementIdList()local iK=0;local function dn(eB,eC)if eB==0 then return eY(eC)<1e-09 end;if eC==0 then return eY(eB)<1e-09 end;return eY(eB-eC)<math.max(eY(eB),eY(eC))*dB end;local function fU(dC,vc)local rm=10^(vc or 0)return bK(dC*rm+0.5)/rm end;local function iF(vd,ve)for dK,dw in pairs(ve)do if type(dK)=="string"then vd[dK]=dw else vd[#vd+1]=ve[dK]end end;return vd end;local function iG(vf)local vg={}if not vf then iF(vg,K)iF(vg,a9)iF(vg,aD)iF(vg,aY)return vg elseif vf=="boolean"then return K elseif vf=="handling"then return a9 elseif vf=="hud"then return aD elseif vf=="physics"then return aY end end;local function pU(vh)local function vi(vj)for dK,dw in pairs(vj)do dbHud_1.setStringValue(dK,va(dw.get()))if vh and dbHud_2 then dbHud_2.setStringValue(dK,va(dw.get()))end end end;if dbHud_1 then vi(bG)vi(iG())a.print("Saved Variables to Datacore")if vh and dbHud_2 then c0="Databank copied.  Remove copy when ready."end end end;local function fT(vk,vl,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..vk..".mp3")end;local function gM(hz,hA,rk,jQ,vm)if jQ==nil then jQ=""end;if vm==nil then vm=""end;return dj([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jQ,hz,hA,vm,rk)end;local function iH(c8,vn)local vo=c8>100000;if vn==nil then vn=1 end;if vo then return fU(c8/1000/200,vn).."SU"elseif c8<1000 then return fU(c8,vn).."M"else return fU(c8/1000,vn).."KM"end end;local function iI(vp)local vq=0;local vr=0;local vs=0;if vp<60 then vp=bK(vp)elseif vp<3600 then vq=bK(vp/60)vp=bK(vp%60)elseif vp<86400 then vr=bK(vp/3600)vq=bK(vp%3600/60)else vs=bK(vp/86400)vr=bK(vp%86400/3600)end;if vs>0 then return vs.."d "..vr.."h "elseif vr>0 then return vr.."h "..vq.."m "elseif vq>0 then return vq.."m "..vp.."s"elseif vp>0 then return vp.."s"else return"0s"end end;local function vt()if radar_1 and J then ct=gK(b,a,c,radar_1,radar_2,warpdrive,eY,gL,dm,gM,dl,gN,fT)end end;function v9.radarSetup()vt()end;function v9.onStart()local vu=false;local function vv()local function vw(vx)local vy=dbHud_1.hasKey;for dK,dw in pairs(vx)do if vy(dK)then local dF=iA(dbHud_1.getStringValue(dK))if dF~=nil then dw.set(dF)vu=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vw(iG())coroutine.yield()vw(bG)else vw(bG)c0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"c1=5;vu=false end;coroutine.yield()if vu then c0="Loaded Saved Variables"elseif not f then c0="No Databank Saved Variables Found\nVariables will save to Databank on standing"c1=5 end;if#bp>0 then d9=iF(d9,bp)end else c0="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;ci=ab;cj=ac;aZ=j;g=string.lower(g)cy=p;cA=V;if bw+180<bN then bu=0 end;bw=bN;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c1=7 end;if antigrav and not q then if bv==nil then bv=cf end;antigrav.setTargetAltitude(bv)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d8>0 then d9=iF(d9,d8)end end;lO="Proceeding to Waypoint"if not aa or aa<0 then aa=bM.getMaxSpeed()-0.1 end end;local function vz()local function vA(vB,vC)if vB>vC then vC=vB end;local vD,vE=0,0;if a5>0 then vD=a5*0.05 end;if a6>0 then vE=a6*0.05 end;vC=vC*(1-(vD+vE))return vC end;local vF=b.getElementNameById;local vG=as~=0 and at~=0;local vH=_G["atmofueltank_size"]local vI=_G["spacefueltank_size"]local vJ=_G["rocketfueltank_size"]for dK in pairs(iJ)do local type=b.getElementDisplayNameById(iJ[dK])if e3(type,'^.*Atmospheric Engine$')then if e3(tostring(b.getElementTagsById(iJ[dK])),'^.*vertical.*$')and b.getElementForwardById(iJ[dK])[3]>0 then cO=true end end;if e3(type,'^.*Space Engine$')then cF=true;if e3(tostring(b.getElementTagsById(iJ[dK])),'^.*vertical.*$')then local vK=b.getElementForwardById(iJ[dK])if vK[3]<0 then vL=true else cE=true end end end;if type=="Landing Gear"then bT=true end;if type=="Dynamic Core Unit"then local pO=pM(iJ[dK])if pO>10000 then gN=110 elseif pO>1000 then gN=55 elseif pO>150 then gN=27 end end;iK=iK+pM(iJ[dK])if vG and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pO=pM(iJ[dK])local oF=iB(iJ[dK])local vB=0;local jJ=bJ()if type=="Atmospheric Fuel Tank"then local vC=400;local vM=35.03;if pO>10000 then vC=51200;vM=5480 elseif pO>1300 then vC=6400;vM=988.67 elseif pO>150 then vC=1600;vM=182.67 end;vB=oF-vM;if a2>0 then vC=vC+vC*a2*0.2 end;vC=vA(vB,vC)local gx=vF(iJ[dK])local jH=0;for jI=1,vH do if gx==iA(c["atmofueltank_"..jI].getWidgetData()).name then jH=jI;break end end;local vN={iJ[dK],string.sub(gx,1,12),vC,vM,vB,jJ,jH}ck[#ck+1]=vN end;if type=="Rocket Fuel Tank"then local vC=320;local vM=173.42;if pO>65000 then vC=40000;vM=25740 elseif pO>6000 then vC=5120;vM=4720 elseif pO>700 then vC=640;vM=886.72 end;vB=oF-vM;if a4>0 then vC=vC+vC*a4*0.1 end;vC=vA(vB,vC)local gx=vF(iJ[dK])local jH=0;for jI=1,vJ do if gx==iA(c["rocketfueltank_"..jI].getWidgetData()).name then jH=jI;break end end;local vN={iJ[dK],string.sub(gx,1,12),vC,vM,vB,jJ,jH}cm[#cm+1]=vN end;if type=="Space Fuel Tank"then local vC=600;local vM=35.03;if pO>10000 then vC=76800;vM=5480 elseif pO>1300 then vC=9600;vM=988.67 elseif pO>150 then vC=2400;vM=182.67 end;vB=oF-vM;if a3>0 then vC=vC+vC*a3*0.2 end;vC=vA(vB,vC)local gx=vF(iJ[dK])local jH=0;for jI=1,vI do if gx==iA(c["spacefueltank_"..jI].getWidgetData()).name then jH=jI;break end end;local vN={iJ[dK],string.sub(gx,1,12),vC,vM,vB,jJ,jH}cl[#cl+1]=vN end end end;if not cO then b9,a_=false,false end end;local function vO()if gyro~=nil then ch=gyro.isActive()==1 end;if not bB then iD:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ul(1)else ul(0)end;if door and(cd or not cd and cf<10000)then for dP,dw in pairs(door)do dw.toggle()end end;if switch then for dP,dw in pairs(switch)do dw.toggle()end end;if forcefield and(cd or not cd==0 and cf<10000)then for dP,dw in pairs(forcefield)do dw.toggle()end end;if antigrav then cP=antigrav.isActive()==1;if cP and not q then antigrav.showWidget()end end;if iC()==1 and k then v7.freeze(1)else v7.freeze(0)end;if bT then if cc~=-1 and not cP then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bm=d.control.isAnyLandingGearDeployed()==1 or cc~=-1 and cc-3<Z;if cc~=-1 or not cd and cI:len()<50 then b0="Startup"else b0=false end;iD:setTargetGroundAltitude(vb)pA=cd end;local function vP()local vQ={}local function vR()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vS={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vT={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vU,vV in pairs(e)do e[vU][0]=vR()e[vU][0].systemId=vU;vQ[vU]={}for vW,ky in pairs(e[vU])do ky.gravity=ky.gravity/9.8;ky.center=vec3(ky.center)ky.name=ky.name[1]ky.noAtmosphericDensityAltitude=vT[ky.id]or ky.atmosphereThickness or ky.atmosphereRadius-ky.radius;ky.spaceEngineMinAltitude=vS[ky.id]or 0.68377*ky.atmosphereThickness;ky.planetarySystemId=vU;ky.bodyId=ky.id;vQ[vU][vW]=ky;if mG==nil or ky.center.x<mG then mG=ky.center.x end;if mF==nil or ky.center.x>mF then mF=ky.center.x end;if mJ==nil or ky.center.y<mJ then mJ=ky.center.y end;if mI==nil or ky.center.y>mI then mI=ky.center.y end;if ky.center and ky.name~="Space"then d3[#d3+1]=ky end end end;ed=di(d,b,c,a,dj,dk,dl,dm,dn)cn=ed(vQ)co=eX(d,b,c,a,dm,eY)cp=fq(d,b,c,a,dj,dk,dl,dm,dn)cr=fQ(d,b,c,a,dbHud_1,e,fR,fS,bK,dl,dm,fT,fU)ky=cn[0]:closestBody(bM.getWorldPosition())end;vX=false;vY=coroutine.create(function()iD:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vv()coroutine.yield()vz()coroutine.yield()cs=pS(d,b,c,e,vBooster,hover,pT,antigrav,warpdrive,dbHud_1,eY,bK,bL,iC,eT,bJ,dk,iD,fR,iE,dm,fU,fT,iF,dn,iH,iI,pU,iA,dj,fS)vO()coroutine.yield()vP()vt()if iy then cq=iy(d,b,c,a,e,antigrav,hover,shield,warpdrive,iz,eY,bK,dj,iA,bL,iB,iC,eT,bJ,dk,iD,fS,fR,gL,iE,dm,fU,gM,fT,iF,iG,iH,iI,iJ,iK)end;if cq then cq.ButtonSetup()end;cu=uj(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uk,iC,iD,iE,ul,gL,fU,e3,dl,dk,fT,iG,pU)if shield then cv=ih(shield,e3,bK)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uk then uk.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vZ then uR.ExtraOnStart()end;fT("start","SU")end)coroutine.resume(vY)end;function v9.onUpdate()if not vX then local i8=coroutine.status(vY)if i8=="suspended"then local dL,i9=coroutine.resume(vY)if i9 then a.print("ERROR STARTUP: "..i9)end elseif i8=="dead"then vX=true end end;if vX then d:update()if cd and t and cQ then if cQ and bS then cs.cmdThrottle(0)bS=false elseif not cQ and not bS then bO=0;bS=true end end;if d6 then iD:setThrottleCommand(axisCommandId.longitudinal,d6)d6=nil end;if not cw and po~=v_ then a.setScreen(po)end;v_=po;if vZ then uR.ExtraOnUpdate()end end end;function v9.onFlush()if vX then cs.onFlush()if vZ then uR.ExtraOnFlush()end end end;function v9.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ce>0 or ce==0 and cf<10000)then for dP,dw in pairs(door)do dw.toggle()end end;if switch then for dP,dw in pairs(switch)do dw.toggle()end end;if forcefield and(ce>0 or ce==0 and cf<10000)then for dP,dw in pairs(forcefield)do dw.toggle()end end;w=d5;pU()if oe then oe.activate()end;if z then cs.showWayPoint(ky,cN)end;if cq then a.print(cq.FuelUsed("atmofueltank")..", "..cq.FuelUsed("spacefueltank")..", "..cq.FuelUsed("rocketfueltank"))end;if vZ then uR.ExtraOnStop()end;fT("stop","SU")end;function v9.controlStart(uu)if vX then cu.startControl(uu)end end;function v9.controlStop(uu)if vX then cu.stopControl(uu)end end;function v9.controlLoop(uu)if vX then cu.loopControl(uu)end end;function v9.controlInput(rk)if vX then cu.inputTextControl(rk)end end;function v9.radarEnter(dU)if ct then ct.onEnter(dU)end end;function v9.radarLeave(dU)if ct then ct.onLeave(dU)end end;function v9.onTick(w0)if w0=="tenthSecond"then cs.TenthTick()if cq then cq.TenthTick()end elseif w0=="oneSecond"then if cq then cq.OneSecondTick()end elseif w0=="fiveSecond"then cs.SatNavTick()elseif w0=="msgTick"then if cq then cq.MsgTick()end elseif w0=="animateTick"then if cq then cq.AnimateTick()end elseif w0=="hudTick"then if cq then cq.hudtick()end elseif w0=="apTick"then cs.APTick()elseif w0=="shieldTick"then cv.shieldTick()elseif w0=="tagTick"then cu.tagTick()elseif w0=="contact"then ct.ContactTick()end end;if vZ then for dK,dw in pairs(vZ)do v9[dK]=dw end end;return v9 end;function script.onStart()uR.onStart()end;function script.onOnStop()uR.onStop()end;function script.onTick(w0)uR.onTick(w0)end;function script.onOnFlush()uR.onFlush()end;function script.onOnUpdate()uR.onUpdate()end;function script.onActionStart(uu)uR.controlStart(uu)end;function script.onActionStop(uu)uR.controlStop(uu)end;function script.onActionLoop(uu)uR.controlLoop(uu)end;function script.onInputText(rk)uR.controlInput(rk)end;function script.onEnter(dU)uR.radarEnter(dU)end;function script.onLeave(dU)uR.radarLeave(dU)end;bI(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)uR=v6(d,core,unit,e,vBooster,hover,pT,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iz,uk)script.onStart()
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
