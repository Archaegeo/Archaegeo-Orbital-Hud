name: ArchHud - Archaegeo v0.016 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.016;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.3;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab=1;ac={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end},DockingMode={set=function(M)ab=M end,get=function()return ab end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV=1.0;aW="none"aX="none"aY="none"aZ=0.05;a_=0.0;b0={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aV=M end,get=function()return aV end},ExtraLongitudeTags={set=function(M)aW=M end,get=function()return aW end},ExtraLateralTags={set=function(M)aX=M end,get=function()return aX end},ExtraVerticalTags={set=function(M)aY=M end,get=function()return aY end},allowedHorizontalDrift={set=function(M)aZ=M end,get=function()return aZ end},FastOrbit={set=function(M)a_=M end,get=function()return a_ end}}b1=k;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=false;bc=false;bd=1000;be=false;bf=false;bg=false;bh=false;bi=0;bj="Aligning"bk=0;bl=1;bm="None"bn=nil;bo=0;bp=nil;bq=0.0;br=0;bs={}bt=false;bu=0;bv=0;bw=nil;bx=0;by=1000;bz=0;bA=false;bB=0;bC=false;bD="All"bE=true;bF="Off"bG=0.000;bH={}bI={}bJ={}bK={VertTakeOff={set=function(M)bc=M end,get=function()return bc end},VertTakeOffEngine={set=function(M)b2=M end,get=function()return b2 end},SpaceTarget={set=function(M)bA=M end,get=function()return bA end},BrakeToggleStatus={set=function(M)b1=M end,get=function()return b1 end},BrakeIsOn={set=function(M)b3=M end,get=function()return b3 end},RetrogradeIsOn={set=function(M)b4=M end,get=function()return b4 end},ProgradeIsOn={set=function(M)b5=M end,get=function()return b5 end},Autopilot={set=function(M)b6=M end,get=function()return b6 end},TurnBurn={set=function(M)b7=M end,get=function()return b7 end},AltitudeHold={set=function(M)b8=M end,get=function()return b8 end},BrakeLanding={set=function(M)b9=M end,get=function()return b9 end},Reentry={set=function(M)bb=M end,get=function()return bb end},AutoTakeoff={set=function(M)ba=M end,get=function()return ba end},HoldAltitude={set=function(M)bd=M end,get=function()return bd end},AutopilotAccelerating={set=function(M)be=M end,get=function()return be end},AutopilotBraking={set=function(M)bg=M end,get=function()return bg end},AutopilotCruising={set=function(M)bh=M end,get=function()return bh end},AutopilotRealigned={set=function(M)bf=M end,get=function()return bf end},AutopilotEndSpeed={set=function(M)bi=M end,get=function()return bi end},AutopilotStatus={set=function(M)bj=M end,get=function()return bj end},AutopilotPlanetGravity={set=function(M)bk=M end,get=function()return bk end},PrevViewLock={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetName={set=function(M)bm=M end,get=function()return bm end},AutopilotTargetCoords={set=function(M)bn=M end,get=function()return bn end},AutopilotTargetIndex={set=function(M)bo=M end,get=function()return bo end},TotalDistanceTravelled={set=function(M)bq=M end,get=function()return bq end},TotalFlightTime={set=function(M)br=M end,get=function()return br end},SavedLocations={set=function(M)bs=M end,get=function()return bs end},VectorToTarget={set=function(M)bt=M end,get=function()return bt end},LocationIndex={set=function(M)bu=M end,get=function()return bu end},LastMaxBrake={set=function(M)bv=M end,get=function()return bv end},LockPitch={set=function(M)bw=M end,get=function()return bw end},LastMaxBrakeInAtmo={set=function(M)bx=M end,get=function()return bx end},AntigravTargetAltitude={set=function(M)by=M end,get=function()return by end},LastStartTime={set=function(M)bz=M end,get=function()return bz end},iphCondition={set=function(M)bD=M end,get=function()return bD end},stablized={set=function(M)bE=M end,get=function()return bE end},UseExtra={set=function(M)bF=M end,get=function()return bF end},SelectedTab={set=function(M)bL=M end,get=function()return bL end},saveRoute={set=function(M)bH=M end,get=function()return bH end},apRoute={set=function(M)bI=M end,get=function()return bI end},ecuThrottle={set=function(M)bJ=M end,get=function()return bJ end}}local function bM(b,c,bN,bO,bP)local a=DUSystem;local bQ=DUConstruct;bR=bN()bS=0;bT=0;bU=false;bV=0;bW=false;bX=false;bY=0;bZ=0;b_=0;c0=0;c1=false;c2=false;c3=false;c4="empty"c5=3;c6=false;c7=0;c8=0;c9=nil;ca=0;cb=0;cc=0;cd=false;ce=false;cf=false;cg=-1;ch=bP()>0;ci=bP()cj=b.getAltitude()ck=DUConstruct.getMass()cl=nil;cm={}cn={}co={}cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=nil;cy=false;cz=false;cA=q;cB=false;cC=W;cD=nil;cE=0;cF=false;cG=false;cH=false;cI=vec3(bQ.getWorldOrientationForward())cJ=vec3(bQ.getWorldOrientationRight())cK=vec3(bQ.getVelocity())cL=vec3(bQ.getWorldVelocity())cM=vec3(cL):len()cN=vec3(b.getWorldVertical())cO=-cN:dot(cL)cP=vec3(bQ.getWorldPosition())cQ=false;cR=false;cS=true;cT=0;cU=0;cV={}cW=false;cX=50000;cY=nil;cZ=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;c_=false;d0=nil;d1=false;d2=0;d3={}d4={}d5={}d6=90;d7=w;d8=nil;d9=nil;da={}db={}dc=false;dd=nil;de=0;df=false;dg=bQ.getMaxSpeed()if shield then dh=bO(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function di(dj)a.print(bR..": "..dj)end;local function dk(d,b,c,a,dl,dm,dn,dp,dq)local function dr(ds)return type(ds)=='number'end;local function dt(ds)return type(dn(ds))=='number'end;local function du(dv)return type(dv)=='table'end;local function dw(a)return type(a)=='string'end;local function dx(dy)return du(dy)and dr(dy.x and dy.y and dy.z)end;local function dz(dA)return du(dA)and dr(dA.latitude and dA.longitude and dA.altitude and dA.id and dA.systemId)end;local dB=math.pi/180;local dC=180/math.pi;local dD=1e-10;local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF='::pos{'..dE..','..dE..','..dE..','..dE..','..dE..'}'local utils=utils;local vec3=vec3;local function dG(ds)local dH=string.gsub(string.reverse(dl('%.4f',ds)),'^0*%.?','')return dH==''and'0'or string.reverse(dH)end;local function dI(dJ)if dx(dJ)then return dl('{x=%.3f,y=%.3f,z=%.3f}',dJ.x,dJ.y,dJ.z)end;if du(dJ)and not getmetatable(dJ)then local dK={}local dL=next(dJ)if type(dL)=='nil'or dL==1 then dK=dJ else for dM,dy in pairs(dJ)do local dN=dI(dy)if type(dM)=='number'then table.insert(dK,dl('[%s]=%s',dM,dN))else table.insert(dK,dl('%s=%s',dM,dN))end end end;return dl('{%s}',table.concat(dK,','))end;if dw(dJ)then return dl("'%s'",dJ:gsub("'",[[\']]))end;return tostring(dJ)end;local dO={}dO.__index=dO;dO.__tostring=function(dJ,dP)local dQ={}for dM in pairs(dJ)do table.insert(dQ,dM)end;table.sort(dQ)local dK={}for dR,dM in ipairs(dQ)do local dN=dI(dJ[dM])if type(dM)=='number'then table.insert(dK,dl('[%s]=%s',dM,dN))else table.insert(dK,dl('%s=%s',dM,dN))end end;if dP then return dl('%s%s',dP,table.concat(dK,',\n'..dP))end;return dl('{%s}',table.concat(dK,','))end;dO.__eq=function(dS,dT)return dS.systemId==dT.systemId and dS.id==dT.id and dq(dS.radius,dT.radius)and dq(dS.center.x,dT.center.x)and dq(dS.center.y,dT.center.y)and dq(dS.center.z,dT.center.z)and dq(dS.GM,dT.GM)end;local function dU(dV,dW,dX,dY,dZ)assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(dX),'Argument 3 (radius) must be a number:'..type(dX))assert(du(dY),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dY))assert(dt(dZ),'Argument 5 (GM) must be a number:'..type(dZ))return setmetatable({systemId=dn(dV),id=dn(dW),radius=dn(dX),center=vec3(dY),GM=dn(dZ)},dO)end;local d_={}d_.__index=d_;d_.__tostring=function(di)return dl('::pos{%d,%d,%s,%s,%s}',di.systemId,di.id,dG(di.latitude*dC),dG(di.longitude*dC),dG(di.altitude))end;d_.__eq=function(dS,dT)return dS.id==dT.id and dS.systemId==dT.systemId and dq(dS.latitude,dT.latitude)and dq(dS.altitude,dT.altitude)and(dq(dS.longitude,dT.longitude)or dq(dS.latitude,math.pi/2)or dq(dS.latitude,-math.pi/2))end;local function e0(e1,dW,e2,e3,e4)local dV=e1;if dw(e1)and not e3 and not e4 and not dW and not e2 then dV,dW,e2,e3,e4=e5(e1,dF)assert(dV,'Argument 1 (position string) is malformed.')else assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(e2),'Argument 3 (latitude) must be in degrees:'..type(e2))assert(dt(e3),'Argument 4 (longitude) must be in degrees:'..type(e3))assert(dt(e4),'Argument 5 (altitude) must be in meters:'..type(e4))end;dV=dn(dV)dW=dn(dW)e2=dn(e2)e3=dn(e3)e4=dn(e4)if dW==0 then return setmetatable({latitude=e2,longitude=e3,altitude=e4,id=dW,systemId=dV},d_)end;return setmetatable({latitude=dB*dm(e2,-90,90),longitude=dB*(e3%360),altitude=e4,id=dW,systemId=dV},d_)end;local e6={}e6.__index=e6;e6.__tostring=function(dJ,dP)local e7=dP and dP..'  'local e8={}local dQ={}for dM in pairs(dJ)do table.insert(dQ,dM)end;table.sort(dQ)for dR,e9 in ipairs(dQ)do ea=dJ[e9]local eb=dO.__tostring(ea,e7)if dP then table.insert(e8,dl('[%s]={\n%s\n%s}',e9,eb,dP))else table.insert(e8,dl('  [%s]=%s',e9,eb))end end;if dP then return dl('\n%s%s%s',dP,table.concat(e8,',\n'..dP),dP)end;return dl('{\n%s\n}',table.concat(e8,',\n'))end;local function ec(ed)local e={}local pid;for dR,dy in pairs(ed)do local dW=dy.planetarySystemId;if type(dW)~='number'then error('Invalid planetary s ID: '..tostring(dW))elseif pid and dW~=pid then error('Mistringmatch planetary s IDs: '..dW..' and '..pid)end;local ee=dy.bodyId;if type(ee)~='number'then error('Invalid body ID: '..tostring(ee))elseif e[ee]then error('Duplicate body ID: '..tostring(ee))end;setmetatable(dy.center,getmetatable(vec3.unit_x))e[ee]=setmetatable(dy,dO)pid=dW end;return setmetatable(e,e6)end;ef={}local function eg(ed)return setmetatable({galaxyAtlas=ed or{}},ef)end;ef.__index=function(dv,M)if type(M)=='number'then local a=dv.galaxyAtlas[M]return ec(a)end;return rawget(ef,M)end;ef.__pairs=function(dJ)return function(dv,dM)local eh,ei=next(dv,dM)return eh,ei and ec(ei)end,dJ.galaxyAtlas,nil end;ef.__tostring=function(dJ)local ej={}for dR,ek in pairs(dJ or{})do local el=ek:getPlanetarySystemId()local em=e6.__tostring(ek,'    ')table.insert(ej,dl('  [%s]={%s\n  }',el,em))end;return dl('{\n%s\n}\n',table.concat(ej,',\n'))end;ef.BodyParameters=dU;ef.MapPosition=e0;ef.PlanetarySystem=ec;function ef.createBodyParameters(dV,dW,en,eo,ep,eq,er)assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(en),'Argument 3 (surfaceArea) must be a number:'..type(en))assert(du(eo),'Argument 4 (aPosition) must be an array or vec3:'..type(eo))assert(du(ep),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ep))assert(dt(eq),'Argument 6 (altitude) must be in meters:'..type(eq))assert(dt(er),'Argument 7 (gravityAtPosition) must be number:'..type(er))local dX=dp(en/4/math.pi)local cc=dX+eq;local es=vec3(eo)+cc*vec3(ep)local dZ=er*cc*cc;return dU(dV,dW,dX,es,dZ)end;ef.isMapPosition=dz;function ef:getPlanetarySystem(e1)if M==nil then M=0 end;if ei==nil then ei=0 end;local dV=e1;if dz(e1)then dV=e1.systemId end;if type(dV)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(ei)~=e6 then a=ec(a)end;return a end end end;function e6:sizeCalculator(et)return 1.05*et.radius end;function e6:castIntersections(eu,ev,ew,ex,ey,ez)local eA={}if ey then for dR,et in pairs(ey)do table.insert(eA,et)end else eA=d5 end;if not ez then table.sort(eA,function(eB,eC)local eD=eB.center;local eE=eC.center;return(eD.x-eu.x)^2+(eD.y-eu.y)^2+(eD.z-eu.z)^2<(eE.x-eu.x)^2+(eE.y-eu.y)^2+(eE.z-eu.z)^2 end)end;local eF=ev:normalize()for dR,et in ipairs(eA)do local eG=et.center-eu;local dX;if ew then dX=ew(et)else dX=self:sizeCalculator(et)end;local eH=eG:dot(eF)local eI=eH^2-(eG:len2()-dX^2)if eI>=0 then local eJ=dp(eI)local eK=eH+eJ;local eL=eH-eJ;if eL>0 then return et,eK,eL elseif eK>0 then return et,eK,nil end end end;return nil,nil,nil end;function e6:closestBody(eM)assert(type(eM)=='table','Invalid coordinates.')local eN,et;local eO=vec3(eM)for dR,eP in pairs(self)do local eQ=(eP.center-eO):len2()if(not et or eQ<eN)and eP.name~="Space"then et=eP;eN=eQ end end;return et end;function e6:convertToBodyIdAndWorldCoordinates(e1)local eR=e1;if dw(e1)then eR=e0(e1)end;if eR.id==0 then return 0,vec3(eR.latitude,eR.longitude,eR.altitude)end;local eP=self:getBodyParameters(eR)if eP then return eR.id,eP:convertToWorldCoordinates(eR)end end;function e6:getBodyParameters(e1)local dW=e1;if dz(e1)then dW=e1.id end;assert(dt(dW),'Argument 1 (id) must be a number:'..type(dW))return self[dW]end;function e6:getPlanetarySystemId()local dR,dy=next(self)return dy and dy.systemId end;function dO:convertToMapPosition(dY)assert(du(dY),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dY))local eS=vec3(dY)if self.id==0 then return setmetatable({latitude=eS.x,longitude=eS.y,altitude=eS.z,id=0,systemId=self.systemId},d_)end;local eT=eS-self.center;local cc=eT:len()local e4=cc-self.radius;local e2=0;local e3=0;if not dq(cc,0)then local eU=eV(eT.y,eT.x)e3=eU>=0 and eU or 2*math.pi+eU;e2=math.pi/2-math.acos(eT.z/cc)end;return setmetatable({latitude=e2,longitude=e3,altitude=e4,id=self.id,systemId=self.systemId},d_)end;function dO:convertToWorldCoordinates(e1)local eR=dw(e1)and e0(e1)or e1;if eR.id==0 then return vec3(eR.latitude,eR.longitude,eR.altitude)end;assert(dz(eR),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eR.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eR.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eW=math.cos(eR.latitude)return self.center+(self.radius+eR.altitude)*vec3(eW*math.cos(eR.longitude),eW*math.sin(eR.longitude),math.sin(eR.latitude))end;function dO:getAltitude(dY)return(vec3(dY)-self.center):len()-self.radius end;function dO:getDistance(dY)return(vec3(dY)-self.center):len()end;function dO:getGravity(dY)local eX=self.center-vec3(dY)local eY=eX:len2()return self.GM/eY*eX/dp(eY)end;return setmetatable(ef,{__call=function(dR,...)return eg(...)end})end;local function eZ(d,b,c,a,dp,e_)local cq={}local f0=100;function cq.computeAccelerationTime(f1,f2,f3)return(f3-f1)/f2 end;function cq.computeDistanceAndTime(f1,f3,f4,f5,f6,f7)f6=f6 or 0;f7=f7 or 0;local f8=f1<f3;local f9=f5/(f8 and f4 or-f4)local fa=-f7/f4;local fb=f9+fa;if f1==f3 then return 0,0 elseif f8 and fb<=0 or not f8 and fb>=0 then return-1,-1 end;local fc,fd=0,0;if f9~=0 and f6>0 then local fe=math.pi/f6/2;local dy=function(dv)return f9*(dv/2-f6*math.sin(fe*dv)/math.pi)+fa*dv+f1 end;local ff=f8 and function(a)return a>=f3 end or function(a)return a<=f3 end;fd=2*f6;if ff(dy(fd))then local fg=0;while math.abs(fd-fg)>0.25 do local dv=(fd+fg)/2;if ff(dy(dv))then fd=dv else fg=dv end end end;local fh=2*f9*f6^2/math.pi^2;fc=fh*(math.cos(fe*fd)-1)+(f9+2*fa)*fd^2/4+f1*fd;if fd<2*f6 then return fc,fd end;f1=dy(fd)end;local eD=f9+fa;local dv=cq.computeAccelerationTime(f1,eD,f3)local fi=f1*dv+eD*dv*dv/2;return fc+fi,fd+dv end;function cq.computeTravelTime(f1,f2,cc)if cc==0 then return 0 end;if f2~=0 then return(math.sqrt(2*f2*cc+f1^2)-f1)/f2 end;assert(f1>0,'Acceleration and initial speed are both zero.')return cc/f1 end;return cq end;local function fj(d,b,c,a,dl,dm,dn,dp,dq)local vec3=vec3;local dk=dk(d,b,c,a,dl,dm,dn,dp,dq)local function dw(a)return type(a)=='string'end;local function du(dv)return type(dv)=='table'end;fk={}fk.__index=fk;function fk:escapeAndOrbitalSpeed(e4)assert(self.body)local cc=e4+self.body.radius;if not dq(cc,0)then local fl=dp(self.body.GM/cc)return dp(2)*fl,fl end;return nil,nil end;function fk:orbitalParameters(e1,fm)assert(self.body)assert(du(e1)or dw(e1))assert(du(fm))local fn=(dw(e1)or dk.isMapPosition(e1))and self.body:convertToWorldCoordinates(e1)or vec3(e1)local dy=vec3(fm)local fo=fn-self.body.center;local fp=dy:len2()local fi=fo:len()local fq=self.body.GM;local fr=((fp-fq/fi)*fo-fo:dot(dy)*dy)/fq;local eD=fq/(2*fq/fi-fp)local fs=fr:len()local eF=fr:normalize()local ft=eD*(1-fs)local fu=eD*(1+fs)local fv=ft*eF+self.body.center;local fw=fs<=1 and-fu*eF+self.body.center or nil;local fx=dp(eD*fq*(1-fs*fs))local fy=fw and 2*math.pi*dp(eD^3/fq)local fz=math.acos(fr:dot(fo)/(fs*fi))if fo:dot(dy)<0 then fz=-(fz-2*math.pi)end;local fA=math.acos((math.cos(fz)+fs)/(1+fs*math.cos(fz)))local fB=fA;if fB<0 then fB=fB+2*math.pi end;local fC=fB-fs*math.sin(fB)local fD=0;local fE=0;local fF=0;if fy~=nil then fD=fC/(2*math.pi/fy)fE=fy-fD;fF=fE+fy/2;if fz-math.pi>0 then fE=fD;fF=fE+fy/2 end;if fF>fy then fF=fF-fy end end;return{periapsis={position=fv,speed=fx/ft,circularOrbitSpeed=dp(fq/ft),altitude=ft-self.body.radius},apoapsis=fw and{position=fw,speed=fx/fu,circularOrbitSpeed=dp(fq/fu),altitude=fu-self.body.radius},currentVelocity=dy,currentPosition=fn,eccentricity=fs,period=fy,eccentricAnomaly=fA,meanAnomaly=fC,timeToPeriapsis=fE,timeToApoapsis=fF,trueAnomaly=fz}end;local function fG(fH)local eP=dk.BodyParameters(fH.systemId,fH.id,fH.radius,fH.center,fH.GM)return setmetatable({body=eP},fk)end;return setmetatable(fk,{__call=function(dR,...)return fG(...)end})end;local function fI(d,b,c,a,dbHud_1,e,fJ,fK,bO,dn,dp,fL,fM,dj)local function fN(fO)local di=fP:closestBody(fO)if(fO-di.center):len()>di.radius+di.noAtmosphericDensityAltitude then di=e[0][0]end;return di end;local function fQ()local function fR(fS,fT)return fS.name<fT.name end;cV={}for dM,dy in pairs(e[0])do cV[#cV+1]={name=dy.name,index=dM}end;table.sort(cV,fR)end;local function fU(fV,fW)if not fW then fW=fX.name end;for dM,dy in pairs(fV)do if dy.name and dy.name==fW then return dM end end;return-1 end;local function fY()d2=bo;if bo==0 then bm="None"c9=nil;fX=nil;return true end;local fZ=cV[bo].index;local f_=e[0][fZ]if f_.center then bm=f_.name;c9=cp[0][fZ]if fX~=nil then if ci==0 then if fJ(g0,g1)~=1 then fK(g0,g1)end;if fJ(g2,g3)~=1 then fK(g2,g3)end;if fJ(g4,g5)~=1 then fK(g4,g5)end;if fJ(g6,g7)~=1 then fK(g6,g7)end;if fJ(g8,g9)~=1 then fK(g8,g9)end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end;if fJ(ge,gf)~=1 then fK(ge,gf)end end;fX=nil else fX=f_;for dR,dy in pairs(cp[0])do if dy.name==fX.planetname then c9=dy;bm=fX.name;break end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end end;if fX==nil then bn=vec3(c9.center)else bn=fX.position end;if c9.planetname~="Space"then if c9.hasAtmosphere then gg=bO(c9.radius*(U-1)+c9.noAtmosphericDensityAltitude)else gg=bO(V+c9.surfaceMaxAltitude)end else gg=T end;if fX~=nil and fX.planetname=="Space"then bi=0 else dR,bi=cr(c9):escapeAndOrbitalSpeed(gg)end;bk=0;be=false;bg=false;bh=false;b6=false;bf=false;bj="Aligning"return true end;local function gh(gi)if not b6 and not bt and not ce and not bC and not bb and not cf then if gi==nil then bo=bo+1;if bo>#cV then bo=0 end else bo=bo-1;if bo<0 then bo=#cV end end;if bo==0 then fY()else local fZ=cV[bo].index;local f_=e[0][fZ]if f_ and(f_~=nil and f_.name=="Space"or bD=="Custom Only"and f_.center or bD=="No Moons-Asteroids"and(string.find(f_.name,"Moon")~=nil or string.find(f_.name,"Asteroid")~=nil))then if gi==nil then gh()else gh(1)end else fY()end end else dj("Disengage autopilot before changing Interplanetary Helper")fL("iph","AP")end end;local function gj()local function gk(gl)local gm;if gl then gm=da else gm=bs end;local gn=-1;gn=fU(e[0])if gn>-1 then table.remove(e[0],gn)end;gn=-1;gn=fU(gm)if gn~=-1 then dj(fX.name.." saved location cleared")table.remove(gm,gn)end;gh()fQ()return gm end;if string.sub(bm,1,1)=="*"then da=gk(true)else bs=gk(false)end end;local function go(gp,fO,gq,gr)local function gs(gl)if gl then gm=da else gm=bs end;if dbHud_1 or gq or gl then local di=fN(fO)local gt={position=fO,name=gp,planetname=di.name,gravity=b.getGravityIntensity(),safe=gr}if not gq then gm[#gm+1]=gt else for dM,dy in pairs(e[0])do if dy.name and gp==dy.name then table.remove(e[0],dM)end end end;table.insert(e[0],gt)fQ()fY()dj("Location saved as "..gp.."("..di.name..")")return gm else dj("Databank must be installed to save permanent locations")end end;if string.sub(gp,1,1)=="*"then da=gs(true)else bs=gs(false)end end;local gu={}function gu.UpdateAtlasLocationsList()fQ()end;function gu.UpdateAutopilotTarget()fY()end;function gu.adjustAutopilotTargetIndex(gi)gh(gi)end;function gu.findAtlasIndex(fV,fW)return fU(fV,fW)end;function gu.UpdatePosition(gv,gw,gx)local function gy(gl)local gm;if gl then gm=da else gm=bs end;local gn=fU(gm)if gn~=-1 then if gv~=nil then if gl then gv="*"..gv end;gm[gn].name=gv;bo=bo-1;gh()elseif gx~=nil then if gx then local gz=cj;if gz<1000 then gz=1000 end;gm[gn].agg=fM(gz,0)dj(gm[gn].name.." AGG Altitude:"..gm[gn].agg.." saved ("..gm[gn].planetname..")")return elseif gx==false then gm[gn].agg=nil;dj(gm[gn].name.." AGG Altitude cleared ("..gm[gn].planetname..")")return end else local gA=gm[gn]if gw then gA.heading=cJ:cross(cN)*5000;dj(gm[gn].name.." heading saved ("..gm[gn].planetname..")")return elseif gw==false then gA.heading=nil;dj(gm[gn].name.." heading cleared ("..gm[gn].planetname..")")return end;gA.gravity=b.getGravityIntensity()gA.position=cP;gA.safe=true end;dj(gm[gn].name.." position updated ("..gm[gn].planetname..")")else dj("Name Not Found")end end;if string.sub(bm,1,1)=="*"then gy(true)else gy(false)end end;function gu.AddNewLocation(gp,fO,gq,gr)go(gp,fO,gq,gr)end;function gu.ClearCurrentPosition()gj()end;for dM,dy in pairs(db)do table.insert(e[0],dy)end;if gB then for dM,dy in pairs(gB)do gu[dM]=dy end end;fQ()if bo>#cV then bo=0 end;gu.UpdateAutopilotTarget()return gu end;local function gC(b,a,c,radar_1,radar_2,warpdrive,e_,gD,dp,gE,dn,gF,fL,dj)local gG={}local gH={}local gI={XS=13,S=27,M=55,L=110,XL=221}local gJ={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gK={}local gL=0;local gM;local gN;local gO=0;local gP;local gQ={gP}local gR="Atmo"local gS;local gT;local gU=0;local gV={}local gW;local gX=0;local gY=table.insert;local gZ=-4;local g_={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h0,h1;local h2,h3;local h4;local h5;local h6;local h7;local h8;local h9;local ha;local function hb()if hc~=nil and gU==0 then gD(hc)a.destroyWidget(h0)a.destroyData(h2)h0,h2,hc=nil,nil,nil;if gT~=nil then gD(gT)a.destroyWidget(h1)a.destroyData(h3)gT,h1,h3=nil,nil,nil end else if gU==1 then gT=a.createWidgetPanel("PeriWinkle")h1=a.createWidget(gT,'periscope')h3=gP.getWidgetDataId()a.addDataToWidget(h3,h1)end;if hc==nil and gL>0 then hc=a.createWidgetPanel(gR)h0=a.createWidget(hc,'radar')h2=gP.getWidgetDataId()a.addDataToWidget(h2,h0)end;gU=0 end end;local function hd()local function he(hf,hg,hh,hi,hj,hk,hl,hm)hg,hi,hk,hm=vec3(hg),vec3(hi),vec3(hk),vec3(hm)local hn,ho,hp=hf*hf,hh*hh,hj*hj;local fp=hi-hg;local hq=fp:normalize()local hr=fp:len()local hs=hk-hg;local ht=(hs-hs:project_on(hq)):normalize()local hu,hv=hs:dot(hq),hs:dot(ht)local hw=hu*hu+hv*hv;local hx=hq:cross(ht)local hy=(hn-ho+hr*hr)/(2*hr)local hz=(hn-hp+hw-2*hu*hy)/(2*hv)local dA=hn-hy^2-hz^2;local hA=dp(dA)local hB=hg+hq*hy+ht*hz+hx*hA;local hC=hg+hq*hy+ht*hz-hx*hA;if e_((hm-hB):len()-hl)<e_((hm-hC):len()-hl)then return hB else return hC end end;local function hD(hE,fi,hF)local hG=hE.pts;local gn=#hG;local hH=hE.ref;if gn>3 then local hI,hJ,hK,hL=hG[gn],hG[gn-1],hG[gn-2],hG[gn-3]hE.ref=hF;local fn=he(hI[1],hI[2],hJ[1],hJ[2],hK[1],hK[2],hL[1],hL[2])local hy,hz,hA=fn.x,fn.y,fn.z;if hy==hy and hz==hz and hA==hA then hy=hy+hH[1]hz=hz+hH[2]hA=hA+hH[3]local hM=vec3(hy,hz,hA)hE.center=hM;if hE.lastPos then if(hE.lastPos-hM):len()<2 then local hN=(hM-vec3(hF)):len()if e_(hN-fi)<10 then hE.skipCalc=true end end end;hE.lastPos=hM end;hE.pts={}else local hO={hF[1]-hH[1],hF[2]-hH[2],hF[3]-hH[3]}hG[gn+1]={fi,hO}end end;if radar_1 or radar_2 then cv.assignRadar()end;if gP then if#gW>0 then local hP,hQ=0,0;local hR=cM*10;local cZ=cZ;gO,gN=0,0;gH={}for dR,dy in pairs(gW)do local cc=h8(dy)if cc>0.0 then if h4(dy)==1 then gY(gH,dy)end;if not cW and warpdrive and cc<aa and warpdrive.getStatus()==15 then dj("INITIATING WARP")c5=7;warpdrive.initiate()end;local hS=F and h6(dy)==1;if E or hS then local hT=h9(dy)local hU=gI[hT]local hV=h5(dy)if hS or cc<hR and(hU>27 or hV==4 or hV==6)then gO=gO+1;local hF={cP["x"],cP["y"],cP["z"]}local hE=gV[dy]if hE==nil then hU=hU+gF;gV[dy]={pts={},ref=hF,name=h7(dy),i=0,radius=hU,skipCalc=false}hE=gV[dy]end;if not hE.skipCalc then if hS or hV==4 or hV==6 then hE.center=vec3(ha(dy))hE.skipCalc=true else hD(hE,cc,hF)hQ=hQ+1 end;if hS and not hE.abandoned then local bR=a.getArkTime()if gX+5<bR then gX=bR;fL("abRdr","RD")end;a.print("Abandoned Construct: "..hE.name.." ("..hT.." "..gJ[hV]..") at ::pos{0,0,"..hE.center.x..","..hE.center.y..","..hE.center.z.."}")dj("Abandoned Radar Contact ("..hT.." "..gJ[hV]..") detected")hE.abandoned=true end else gY(gK,hE)end end;hP=hP+1;if hP>300 or hQ>30 then coroutine.yield()hP,hQ=0,0 end end end end;gN=#gK;if gN>0 and(cM>20 or b9)then local et,hW,hX,hY;local hZ=0;local h_=cp:getPlanetarySystem(0)hY=cL:normalize()while hZ<gN do coroutine.yield()local i0={table.unpack(gK,hZ,math.min(hZ+75,gN))}et,hW,hX=h_:castIntersections(cP,hY,nil,nil,i0,true)if et and hX then d0={et,hW,hX}break end;hZ=hZ+75 end;if not et then d0=nil end else d0=nil end;gK={}gM=gP.getTargetId()end end end;local function i1()if gP then gR="Atmo"if string.find(gP.getName(),"Space")then gR="Space"end end end;function gG.pickType()i1()end;function gG.assignRadar()if radar_2 and gZ~=1 then if gZ==-1 then if gP==radar_2 then gP=radar_1 else gP=radar_2 end end;gQ={gP}h4=gP.hasMatchingTransponder;h5=gP.getConstructKind;h6=gP.isConstructAbandoned;h7=gP.getConstructName;h8=gP.getConstructDistance;h9=gP.getConstructCoreSize;ha=gP.getConstructWorldPos;gW=gP.getConstructIds()i1()else gW=gP.getConstructIds()end;gZ=gP.getOperationalState()end;function gG.UpdateRadar()local i2=coroutine.status(gS)if i2=="suspended"then local dN,i3=coroutine.resume(gS)if i3 then a.print("ERROR UPDATE RADAR: "..i3)end elseif i2=="dead"then gS=coroutine.create(hd)local dN,i3=coroutine.resume(gS)end end;function gG.GetRadarHud(i4,i5,ay,az)local i6,dj;local dE=gN or 0;gL=#gW;if gL>0 then if E then dj=dE.."/"..gO.." Known/InRange : "..gL.." Total"else dj="Radar Contacts: "..gL end;i6=gE(ay,az,dj,"pbright txtbig txtmid")if#gH>0 then i6=i6 ..gE(i4,i5,"Friendlies In Range","pbright txtbig txtmid")for dM,dy in pairs(gH)do i5=i5+20;i6=i6 ..gE(i4,i5,gP.getConstructName(dy),"pdim txtmid")end end;local i7=#gP.getIdentifiedConstructIds()if gT==nil and i7>0 then gU=1;cv.ToggleRadarPanel()end;if gT~=nil and i7==0 then cv.ToggleRadarPanel()end;if hc==nil then if w then cv.ToggleRadarPanel()end end else if gZ~=1 then i6=gE(ay,az,gR.." Radar: "..g_[gZ],"pbright txtbig txtmid")else i6=gE(ay,az,"Radar: No "..gR.." Contacts","pbright txtbig txtmid")end;if hc~=nil then gU=0;cv.ToggleRadarPanel()end end;return i6 end;function gG.GetClosestName(gp)if gP then local i8=gP.getConstructName(gP.getConstructIds()[1])if i8 then gp=gp.." "..i8 end end;return gp end;function gG.ToggleRadarPanel()hb()end;function gG.ContactTick()if not i9 then i9=0 end;if bR>i9+10 then dj("Radar Contact")fL("rdrCon","RC")i9=bR end;c.stopTimer("contact")end;function gG.onEnter(dW)if gP and not ch and not cW then c.setTimer("contact",0.1)end end;function gG.onLeave(dW)if gP and E then if#gV>650 then dW=tostring(dW)gV[dW]=nil end end end;local function ia()gP=nil;if radar_2 and radar_2.getOperationalState()==1 then gP=radar_2 else gP=radar_1 end;gZ=gP.getOperationalState()h4=gP.hasMatchingTransponder;h5=gP.getConstructKind;h6=gP.isConstructAbandoned;h7=gP.getConstructName;h8=gP.getConstructDistance;h9=gP.getConstructCoreSize;ha=gP.getConstructWorldPos;gQ={gP}gW=gP.getConstructIds()i1()gS=coroutine.create(hd)if ib then for dM,dy in pairs(ib)do gG[dM]=dy end end end;ia()return gG end;local function ic(shield,e5,bO,dj)local id={}local ie=shield.getResistancesCooldown()local function ig()local ih=shield.isActive()if G then if not cW and ih==0 and shield.isVenting()~=1 then shield.toggle()elseif cW and ih==1 then shield.toggle()end end end;local function ii()local ij=shield.getStressRatioRaw()local ik=0.5999;if ij[1]==0.0 and ij[2]==0.0 and ij[3]==0.0 and ij[4]==0.0 then return end;local il=shield.setResistances(ik*ij[1],ik*ij[2],ik*ij[3],ik*ij[4])if il==1 then dj("Shield Resistances updated")else dj("Value Exceeded. Failed to update Shield Resistances")end end;function id.shieldTick()dh=bO(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ig()ie=shield.getResistancesCooldown()if ie==0 and dh<a9 then ii()end end;function id.setResist(im)if not shield then dj("No shield found")return elseif im==nil or ie>0 then dj("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF=dE..', '..dE..', '..dE..', '..dE;local io,ip,iq,ir=e5(im,dF)if ir==nil or io+ip+iq+ir>0.6 then dj("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(io,ip,iq,ir)==1 then dj("Shield Resistances set")else dj("Resistance setting failed.")end end;function id.ventShield()local is=shield.getVentingCooldown()if is>0 then dj("Cannot vent again for "..is.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()dj("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else dj("Shields already at max hitpoints")end end;if it then for dM,dy in pairs(it)do id[dM]=dy end end;return id end;local function iu(d,b,c,a,e,antigrav,hover,shield,warpdrive,iv,e_,bO,dl,iw,bP,ix,iy,eV,bN,dm,iz,fK,fJ,gD,iA,dp,fM,gE,fL,iB,iC,iD,iE,iF,iG,dj)local bQ=DUConstruct;local iH=9.80665;local iI={}local iJ={}local iK={}local iL={}local iM=nil;local iN=nil;local iO=nil;local iP=false;local iQ="none"local iR=""local iS=55;local iT=0;local iU=0;local iV=nil;local iW=ag;local iX=ah;local iY=ai;local iZ=[[rgb(]]..bO(iW+0.5)..","..bO(iX+0.5)..","..bO(iY+0.5)..[[)]]local i_=[[rgb(]]..bO(iW*0.9+0.5)..","..bO(iX*0.9+0.5)..","..bO(iY*0.9+0.5)..[[)]]local j0=0;local j1=0;local j2=""local j3=bN()local j4=false;local j5=false;local gP=false;local function j6(dy)if ad==1920 then return dy else return fM(ad*dy/1920,0)end end;local function j7(dy)if ae==1080 then return dy else return fM(ae*dy/1080,0)end end;local function j8()return iA()==0 and g~="keyboard"and iy()==0 end;local function j9()local ja="TRAVEL"if not cS then ja="CRUISE"end;if b6 then ja="AUTOPILOT"end;return ja end;local i6=""local jb=""local jc=""local jd=1;local je=2;local jf=3;local jg=4;local jh=5;local ji=6;local jj=7;local jk=""local jl=0;local jm=90.0*aU;local jn={}local jo={}local jp={}local jq={}local jr={}local js={}local jt={}jt["atmofueltank"],jt["spacefueltank"],jt["rocketfueltank"]=0,0,0;local ju=0;local function jv(hy,jw,jx,jy,jz,jA)local jB=ju;local jC=ju+5;if not B then jC=jC+5 end;if iy()==1 and not m then jB=jB-50;jC=jC-50 end;if jx=="ATMO"then jk="atmofueltank"elseif jx=="SPACE"then jk="spacefueltank"else jk="rocketfueltank"end;jl=_G[jk.."_size"]if#jy>0 then for M=1,#jy do local gp=jy[M][je]local jD=jy[M][jj]for jE=1,jl do if jy[M][je]==iw(c[jk.."_"..jE].getWidgetData()).name then jD=jE;break end end;local jF=bN()if jz[M]==nil or jA[M]==nil or jF-jy[M][ji]>jm then local jG;local jH=0;jH=ix(jy[M][jd])-jy[M][jg]jG=jy[M][jh]local jI=jG>jH or false;if jI then jt[jk]=jt[jk]+jG-jH end;if jD~=0 then local jJ=iw(c[jk.."_"..jD].getWidgetData())jA[M]=jJ.percentage;jz[M]=jJ.timeLeft;if jz[M]=="n/a"then jz[M]=0 end else jA[M]=bO(0.5+jH*100/jy[M][jf])if jI then jz[M]=bO(0.5+jH/((jG-jH)/(jF-jy[M][ji])))else jz[M]=0 end end;jy[M][ji]=jF;jy[M][jh]=jH end;if gp==jw then gp=dl("%s %d",jx,M)end;if jD==0 then gp=gp.." *"end;local jK;jK=iE(jz[M])if jz[M]==0 or jK==">1y"then jK=""end;if jA[M]~=nil then local jL=bO(jA[M]*2.55)local jM=dl("rgb(%d,%d,%d)",255-jL,jL,0)local jN=""if jK~=""and jz[M]<120 or jA[M]<5 then jN="red "end;local jO=dl("rgb(%d,%d,%d)",dm(bO((255-jL)/2.55),50,100),dm(bO(jL/2.55),0,50),50)local jP="rgb(196,0,255)"if jx=="ATMO"then jP="rgb(0,188,255)"elseif jx=="SPACE"then jP="rgb(239,255,0)"end;local jQ=false;if jR~=jP then jQ=true end;jR=jP;if B then if jQ then jB=jB-5;jC=jC-5 end;jb=jb..dl([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jO,jP,hy,jC,jM,bO(jA[M]*1.7+0.5)-2,hy+1,jC+1,hy+5,jC+14,gp,jA[M],jK)jB=jB-22;jC=jC-22 else jb=jb..gE(hy,jB,gp,jN.."pdim txtfuel")jb=jb..gE(hy,jC,dl("%d%% %s",jA[M],jK),"pdim txtfuel","fill:"..jM)jB=jB+30;jC=jC+30 end end end end;ju=jB end;local function jS(jT,e4)if aq==0 and ar==0 then return end;if e4<200000 and not ch or e4 and ch then local jU=0;if e_(cO)>1 then jU=45*math.log(e_(cO),10)if cO<0 then jU=-jU end end;jT[#jT+1]=dl([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bO(cO),bO(jU))end;return jT end;local function jV(jW)local gi=-cN;jW=jW-jW:project_on(gi)local jX=vec3(0,0,1)jX=jX-jX:project_on(gi)local jY=jX:cross(gi)local jU=jX:angle_between(jW)*constants.rad2deg;if jW:dot(jY)<0 then jU=360-jU end;return jU end;local function jZ(jT,am,an,j_,k0,cZ)if af==0 then return end;local k1=af;local k2=20;local k3=bO(j_)if cZ then for M=-45,45,5 do local k4=M;jT[#jT+1]=dl([[<g transform="rotate(%f,%d,%d)">]],k4,am,an)k5=5;if M%15==0 then k5=15 elseif M%10==0 then k5=10 end;jT[#jT+1]=dl([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+k1+k2-k5,am,an+k1+k2)end;jT[#jT+1]=gE(am,an+k1+k2-35,k0,"pdim txt txtmid")jT[#jT+1]=gE(am,an+k1+k2-25,k3 .." deg","pdim txt txtmid")jT[#jT+1]=dl([[<g transform="rotate(%f,%d,%d)">]],-j_,am,an)jT[#jT+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+k1+k2-20,am+5,an+k1+k2-20,am,an+k1+k2-15)jT[#jT+1]="</g>"end;jT[#jT+1]=[[<g style="clip-path: url(#headingClip);">]]local k6=k3;if cZ then k6=jV(cI)end;local k7=20;local k8=bO(k6)local k9=0;local ka=an+k1+k2+20;local kb=am;if k0~="YAW"then ka=j7(130)kb=j6(960)end;local kc=[[<path class="txttick line" d="]]local kd=bO(k8-(k7+10)-k8%5+0.5)for M=kd+70,kd,-5 do local hy=kb-(-M*5+k6*5)if M%10==0 then k9=10;local dE=M;if dE==360 then dE=0 elseif dE>360 then dE=dE-360 elseif dE<0 then dE=dE+360 end;jT[#jT+1]=gE(hy,ka+15,dE,"txtmid bright")elseif M%5==0 then k9=5 end;if k9==10 then kc=dl([[%s M %f %f v %d]],kc,hy,ka-5,k9)else kc=dl([[%s M %f %f v %d]],kc,hy,ka-2.5,k9)end end;jT[#jT+1]=kc..[["/>]]jT[#jT+1]=dl([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kb-5,ka-20,kb+5,ka-20,kb,ka-10)if cZ then k0="HDG"end;jT[#jT+1]=gE(j6(960),j7(100),k8 .."°","dim txt txtmid size14","")jT[#jT+1]=gE(j6(960),j7(85),k0,"dim txt txtmid size20","")jT[#jT+1]=[[</g>]]end;local function ke(jT,kf,j_,am,an,cZ,kg,kh)if af==0 then return end;local k1=af;local ki=bO(k1*3/5)if k1>0 then local kj=bO(kf)local k5=0;local kc=dl([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*j_,am,an)if not ch then kc=dl([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;jT[#jT+1]=dl([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k1-1,am,an)jT[#jT+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bO(kj-30-kj%5+0.5),bO(kj+30+kj%5+0.5),5 do if M%10==0 then k5=30 elseif M%5==0 then k5=20 end;local hz=an+-M*5+kf*5;if k5==30 then kc=dl([[%s M %d %f h %d]],kc,am-ki-k5,hz,k5)if ch then jT[#jT+1]=dl([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*j_,am,an,am-ki+10,hz+4,M)jT[#jT+1]=dl([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*j_,am,an,am+ki-10,hz+4,M)if M==0 or M==180 or M==-180 then jT[#jT+1]=dl([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*j_,am,an,am-ki+20,hz,ki*2-40)end else jT[#jT+1]=gE(am-ki+10,hz,M,"pdim txt txtmid")jT[#jT+1]=gE(am+ki-10,hz,M,"pdim txt txtmid")end;kc=dl([[%s M %d %f h %d]],kc,am+ki,hz,k5)else kc=dl([[%s M %d %f h %d]],kc,am-ki-k5,hz,k5)kc=dl([[%s M %d %f h %d]],kc,am+ki,hz,k5)end end;jT[#jT+1]=kc..[["/>]]local kk="PITCH"if not cZ then kk="REL PITCH"end;if kf>90 and not ch then kf=90-(kf-90)elseif kf<-90 and not ch then kf=-90-(kf+90)end;if k1>200 then if ch then if kh>iS then jT[#jT+1]=gE(am,an-15,"Yaw","pdim txt txtmid")jT[#jT+1]=gE(am,an+20,kg,"pdim txt txtmid")end;jT[#jT+1]=dl([[<g transform="rotate(%f,%d,%d)">]],-j_,am,an)else jT[#jT+1]=dl([[<g transform="rotate(0,%d,%d)">]],am,an)end;jT[#jT+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-ki+25,an-5,am-ki+20,an,am-ki+25,an+5,am-ki+50,an+4,kj)jT[#jT+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+ki-25,an-5,am+ki-20,an,am+ki-25,an+5,am+ki-30,an+4,kj)jT[#jT+1]="</g>"end;local kl=bO(k1/3)jT[#jT+1]=dl([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-kl,an,k1-kl)if not ch and cZ then jT[#jT+1]=dl([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*j_,am,an,am-ki+10,an,ki*2-20)end;jT[#jT+1]="</g>"if k1<200 then if ch and kh>iS then jT[#jT+1]=gE(am,an-k1,kk,"pdim txt txtmid")jT[#jT+1]=gE(am,an-k1+10,kj,"pdim txt txtmid")jT[#jT+1]=gE(am,an-15,"Yaw","pdim txt txtmid")jT[#jT+1]=gE(am,an+20,kg,"pdim txt txtmid")else jT[#jT+1]=gE(am,an-k1,kk,"pdim txt txtmid")jT[#jT+1]=gE(am,an-k1+15,kj,"pdim txt txtmid")end end end end;local function km(jT,e4,cZ)local kn=as;local ko=at;if kn==0 and ko==0 then return end;local kp=78;local kq=19;local kr=cg;if cg~=-1 then jT[#jT+1]=gE(kn+kp,ko+kq+20,dl("AGL: %.1fm",cg),"pdim altsm txtend")end;if cZ and(e4<200000 and not ch or e4 and ch)then jT[#jT+1]=gE(kn+kp,ko-10,dl("%s",ks.name),"pdim altsm txtend")table.insert(jT,dl([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kn-1,ko-4,kp+2,kq+6,kn+1,ko-1,kp-4,kq))local gn=0;local kt=1;local ku=0;local kv=e4<0;local kw=e4<ks.surfaceMaxAltitude;local kx=9;if kv then kx=0 end;local e4=e_(e4)while gn<6 do local ky=11;local kz=16;local kA=9;local kB=14;local jN="altsm"if gn>2 then kz=kz+3;ky=ky+2;kB=kB+2;kA=kA-6;jN="altbig"end;if kv then jN=jN.." red"elseif kw then jN=jN.." orange"end;local kC=e4/kt%10;local kD=bO(kC)local kE=bO((kD+1)%10)local kF=ku;if gn==0 then kF=kC-kD;if kv then kF=1-kF end end;if kv and(gn==0 or ku~=0)then local gq=kE;kE=kD;kD=gq end;local kG=kz*(kF-1)local kH=kG+kz;local hy=kn+kA+(6-gn)*ky;local hz=ko+kB;jT[#jT+1]=gE(hy,hz+kG,kE,jN)jT[#jT+1]=gE(hy,hz+kH,kD,jN)gn=gn+1;kt=kt*10;if kD==kx then ku=kF else ku=0 end end;table.insert(jT,[[</g></g>]])end end;local function kI(fm)local kJ=-math.deg(eV(fm.y,fm.z))+180;kJ=kJ-90;if kJ<0 then kJ=360+kJ end;if kJ>180 then kJ=-180+kJ-180 end;return-kJ end;local function kK(fm)local k6=math.deg(eV(fm.y,fm.x))-90;if k6<-180 then k6=360+k6 end;return k6 end;local function kL(jT,fm,kh,am,an)if kh>5 and not ch or kh>iS then local k1=af;local kM=20;local kN=20;local kO=kI(fm)local kP=kK(fm)local kQ=14;local kR=kQ/2;local kS=-kP/kN*k1;local kT=kO/kM*k1;local hy=am+kS;local hz=an+kT;local cc=dp(kS^2+kT^2)local kU=[[<circle
                            cx="]]..hy..[["
                            cy="]]..hz..[["
                            r="]]..kR/kQ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hy..[["
                            cy="]]..hz..[["
                            r="]]..kR..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hy-kQ..[[,]]..hz..[[ h ]]..kR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hy+kR..[[,]]..hz..[[ h ]]..kR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hy..[[,]]..hz-kQ..[[ v ]]..kR..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cc<k1 then jT[#jT+1]=kU else local jU=eV(kT,kS)local kV=4;local kW=am+k1*math.cos(jU)local kX=an+k1*math.sin(jU)jT[#jT+1]=dl('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jU*180/math.pi,kW,kX,kW-kV,kX-kV/2,kV*2,kV,kW+kV,kX-kV,kV,kV,-kV,kV)end;if not ch then local kY=vec3(fm)kO=kI(-kY)kP=kK(-kY)kS=-kP/kN*k1;kT=kO/kM*k1;hy=am+kS;hz=an+kT;cc=dp(kS^2+kT^2)if cc<k1 then local kZ=[[<circle
                                    cx="]]..hy..[["
                                    cy="]]..hz..[["
                                    r="]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hy..[[,]]..hz-kQ..[[ v ]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hy..[[,]]..hz..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hy..[[,]]..hz..[[)" />
                                <path
                                    d="M ]]..hy-kR..[[,]]..hz..[[ h ]]..kQ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hy..[[,]]..hz..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hy..[[,]]..hz..[[)"/>]]jT[#jT+1]=kZ end end end end;local function k_(jT,ja,l0,l1)if ao==0 and ap==0 then return end;l0=bO(l0+0.5)local jB=ap+10;local jC=ap+20;if iy()==1 and not m then jB=55;jC=65 end;local l2="CRUISE"local c="km/h"local dN=l1;if ja=="TRAVEL"or ja=="AUTOPILOT"then l2="THROT"c="%"dN=l0;local l3="dim"if l0<0 then l3="red"end;jT[#jT+1]=dl([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l3,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-e_(l0),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;jT[#jT+1]=gE(ao+10,jB,l2,"pbright txtstart")jT[#jT+1]=gE(ao+10,jC,dl("%.0f %s",dN,c),"pbright txtstart")if ch and t and cS and bU then l0=bO(bV*100+0.5)local l3="red"if l0<0 then l3="red"end;jT[#jT+1]=dl([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l3,1-e_(l0),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)jT[#jT+1]=gE(ao+10,jB+40,"LIMIT","pbright txtstart")jT[#jT+1]=gE(ao+10,jC+40,l0 .."%","pbright txtstart")end;if ch and t or bb then jT[#jT+1]=gE(ao+10,jB-40,"LIMIT: "..cC.." km/h","dim txtstart")elseif not ch and b6 then jT[#jT+1]=gE(ao+10,jB-40,"LIMIT: "..bO(a1*3.6+0.5).." km/h","dim txtstart")end end;local function l4(jT,l5)if ao==0 and ap==0 then return end;local l6=ap-10;local l7=ao+10;jT[#jT+1]=gE(0,0,"","pdim txt txtend")if iy()==1 and not m then l6=75 end;jT[#jT+1]=gE(l7,l6,bO(l5).." km/h","pbright txtbig txtstart")end;local l8=40;local function l9(jT)jT[#jT+1]=gE(j6(150),j7(1070),dl("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jT[#jT+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jT[#jT+1]=gE(j6(960),j7(550),"Warning: Invalid Control Scheme Detected","warnings")jT[#jT+1]=gE(j6(960),j7(600),"Keyboard Scheme must be selected","warnings")jT[#jT+1]=gE(j6(960),j7(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local la=j6(960)local lb=j7(860)local lc=j7(880)local ld=j7(900)local le=j7(960)local lf=j7(200)local lg=j7(250)local lh=j7(960)if iy()==1 and not m then lb=j7(135)lc=j7(155)ld=j7(175)lf=j7(115)lg=j7(95)end;if b3 then local li=""if type(b3)=="string"then li="-"..b3 end;jT[#jT+1]=gE(la,lb,"Brake Engaged"..li,"warnings")elseif bT>0 then jT[#jT+1]=gE(la,lb,"Auto-Brake Engaged","warnings","opacity:"..bT)end;if ch and cB and cg==-1 then if not b6 and not bt and not b9 and not cR and not bc and not ba then jT[#jT+1]=gE(la,lf+50,"** STALL WARNING **","warnings")fL("stall","SW",2)end end;if cY then jT[#jT+1]=gE(la,lf+90,"Flight Assist in Progress","warnings")end;if cl then jT[#jT+1]=gE(la,lh,"Gyro Enabled","warnings")end;if lj then l8=l8-1;if l8>20 then jT[#jT+1]=gE(la,lh-20,"ECU Enabled","warnings")elseif l8<0 then l8=40 end end;if bp then if bX then jT[#jT+1]=gE(la,lc,"Gear Extended","warn")else jT[#jT+1]=gE(la,lc,"Landed (G: Takeoff)","warnings")end end;if cg>-1 and(not cR or cj<100)then local lk=iD(d:getTargetGroundAltitude())jT[#jT+1]=gE(la,ld,"Hover Height: "..lk,"warn")end;if c6 then jT[#jT+1]=gE(la,le+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cR and by~=nil then local ll="warnings"if e_(cj-antigrav.getBaseAltitude())<501 then ll="warn"end;jT[#jT+1]=gE(la,lf+40,dl("Target Altitude: %d Singularity Altitude: %d",bO(by),bO(antigrav.getBaseAltitude())),ll)end;if b6 and bm~="None"then jT[#jT+1]=gE(la,lf,"Autopilot "..bj,"warn")elseif bw~=nil then jT[#jT+1]=gE(la,lf+20,dl("LockedPitch: %d",bO(bw)),"warn")elseif c1 then jT[#jT+1]=gE(la,lf+20,"Follow Mode Engaged","warn")elseif bb or cf then jT[#jT+1]=gE(la,lf+20,"Re-entry in Progress","warn")end;if b8 or bc then local lk=iD(bd,2)if bc then if cR then lk=iD(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jT[#jT+1]=gE(la,lf,"VTO to "..lk,"warn")elseif(ba or ce)and not bC then if ce then jT[#jT+1]=gE(la,lf,"Takeoff to "..bm,"warn")else jT[#jT+1]=gE(la,lf,"Takeoff to "..lk,"warn")end;if b3 and not bc then jT[#jT+1]=gE(la,lf+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jT[#jT+1]=gE(la,lf,"Altitude Hold: "..dl("%.1fm",bd),"warn")end end;if bc and(antigrav~=nil and antigrav)then if ci>0.1 then jT[#jT+1]=gE(la,lf+20,"Beginning ascent","warn")elseif ci<0.09 and ci>0.05 then jT[#jT+1]=gE(la,lf+20,"Aligning trajectory","warn")elseif ci<0.05 then jT[#jT+1]=gE(la,lf+20,"Leaving atmosphere","warn")end end;if bC then if cD~=nil then jT[#jT+1]=gE(la,lf,cD,"warn")end end;if b9 then local lm="Brake Landing"if dd then lm=lm.."-Aligning"end;if dc then lm=lm.."-Drift Limited"end;jT[#jT+1]=gE(la,lf,lm,"warnings")end;if b5 then jT[#jT+1]=gE(la,lf+20,"Prograde Alignment","crit")end;if b4 then jT[#jT+1]=gE(la,lf,"Retrograde Alignment","crit")end;if c_ then local type;if string.find(c_,"COLLISION")then type="warnings"else type="crit"end;jT[#jT+1]=gE(la,lg+20,c_,type)elseif ci==0 then local ln,lo=cu.checkLOS(cL:normalize())if lo~=nil and cM>0 then local lk=iD(lo)local lp=cq.computeTravelTime(cM,0,lo)local lq="Collision"if ln.noAtmosphericDensityAltitude>0 then lq="Atmosphere"end;jT[#jT+1]=gE(la,lg+20,ln.name.." "..lq.." "..iE(lp).." In "..lk,"crit")end end;if bt and not bC then jT[#jT+1]=gE(la,lf+60,lr,"warn")end;if d3 and#d3>1 then end;local ls=j6;local lt=j7;local lu="topButton"local lv="topButtonActive"local lw=lu;if b6 or bt or ce or bC then lw=lv end;local lx=lu;if b5 then lx=lv end;local ly=lu;if b9 or bp then ly=lv end;local lz=lu;if b8 or bt then lz=lv end;local lA=lu;if b4 then lA=lv end;local lB=lu;if bC or cF and b6 then lB=lv end;if w and I then local lC=lt(30)jT[#jT+1]=dl([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lw,ls(960),lt(54),lt(-53),ls(-120),ls(25),lt(50))jT[#jT+1]=gE(ls(910),lC,"AUTOPILOT")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lx,ls(865),lt(51),ls(-25),lt(-50),ls(-110),ls(25),lt(46))jT[#jT+1]=gE(ls(800),lC,"PROGRADE")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ly,ls(755),lt(47),ls(-25),lt(-46),ls(-98),ls(44),lt(44))jT[#jT+1]=gE(ls(700),lC,"LAND")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lz,ls(960),lt(54),lt(-53),ls(120),ls(-25),lt(50))jT[#jT+1]=gE(ls(1010),lC,"ALT HOLD")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lA,ls(1055),lt(51),ls(25),lt(-50),ls(110),ls(-25),lt(46))jT[#jT+1]=gE(ls(1122),lC,"RETROGRADE")jT[#jT+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lB,ls(1165),lt(47),ls(25),lt(-46),ls(98),ls(-44),lt(44))jT[#jT+1]=gE(ls(1220),lC,"ORBIT")jT[#jT+1]=[[
                                    </g>
                                </g>]]jT[#jT+1]="</g>"end;return jT end;local function lD(kh)return bO(fM(kh*3.6,0)+0.5).." km/h"end;local function lE(gn)local gp=bm;if gn~=nil and type(gn)=="number"then if gn==0 then return"None"end;gp=cV[gn].name end;if gp==nil then gp=fX.name end;if gp==nil then gp="None"end;return gp end;local function lF(jT)local lG=cu.routeWP(true)if not lG or#lG==0 then return end;local hy=j6(750)local hz=j7(360)if b6 or bt then jT[#jT+1]=gE(hy,hz,"REMAINING ROUTE","pdim txtstart size20")else jT[#jT+1]=gE(hy,hz,"LOADED ROUTE","pdim txtstart size20")end;for dM,M in pairs(lG)do hz=hz+20;jT[#jT+1]=gE(hy,hz,dM..". "..lG[dM],"pdim txtstart size20")end end;local function lH(jT)local hy=aC+10;local hz=aD+20;local lI={}local lJ={"Alt-4: AutoTakeoff to Target"}local lK={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lL={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lM={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lI,"--------------DYNAMIC-----------------")if ch then if cg~=-1 then iB(lI,lJ)if c9 and ks and c9.name==ks.name then table.insert(lI,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b2 then if antigrav then if cR then table.insert(lI,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lI,"Turn on AGG to takeoff to AGG Height")end end;if b2 then table.insert(lI,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lI,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lI,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bp then table.insert(lI,"G: Takeoff to hover height, raise gear")else table.insert(lI,"G: Lowergear and Land")end else iB(lI,lK)table.insert(lI,"G: Begin BrakeLanding or Land")end;if bc then table.insert(lI,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iB(lI,lL)if shield then table.insert(lI,"Alt-Shift-6: Vent shields")if not G then table.insert(lI,"Alt-Shift-7: Toggle shield off/on")end end end;if fX~=nil then table.insert(lI,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lI,"Alt-9: Activate Gyroscope")end;if aX~="none"or aW~="none"or aY~="none"then table.insert(lI,"Alt-Shift-9: Cycles engines with Extra tags")end;if b8 then table.insert(lI,"Alt-Spacebar/C will raise/lower target height")table.insert(lI,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not ch then table.insert(lI,"LALT+Mousewheel will lower/raise speed limit")end;iB(lI,lM)for M=1,#lI do hz=hz+12;jT[#jT+1]=gE(hy,hz,lI[M],"pdim txtbig txtstart")end end;local function lN(jT)local lO=aC;local lP=aD;local lQ=aB;local lR=4;local lS=15;local hy=0;local hz=0;local lT,lU,lV,lW;local lX;local function lY(type)local gz,bR,kh,lZ,jN,l_;if type=="Periapsis"then gz=lX.periapsis.altitude;bR=lX.timeToPeriapsis;kh=lX.periapsis.speed;jN="txtend"lZ=12;l_=math.min(hy,lO+lQ-ks.radius/lV-lR*2)else gz=lX.apoapsis.altitude;bR=lX.timeToApoapsis;kh=lX.apoapsis.speed;lZ=-12;jN="txtstart"l_=hy end;if cM<1 then bR=0 end;jT[#jT+1]=dl([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],l_+lZ,hz-5,hy,hz-5)jT[#jT+1]=dl([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],l_-lZ*4,hz+2,hy,hz+2)jT[#jT+1]=gE(l_,hz,type,jN)hy=l_-lZ*2;hz=hz+lS;local lk=iD(gz)jT[#jT+1]=gE(hy,hz,lk,jN)hz=hz+lS;jT[#jT+1]=gE(hy,hz,iE(bR),jN)hz=hz+lS;jT[#jT+1]=gE(hy,hz,lD(kh),jN)end;local m0=lQ*1.5;if bL=="INFO"then m0=25*10 end;if bL=="ORBIT"and cj<ks.spaceEngineMinAltitude then return jT end;if bL~="HIDE"then jT[#jT+1]=[[<g class="pbright txtorb txtmid">]]jT[#jT+1]=dl('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lQ*2,m0,lO,lP)jT[#jT+1]=dl([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lQ*2,m0,lO,lP)end;local m1=lQ*1.5;local m2=lQ*2;local m3=m1/2;local m4=lQ;local m5=lO+m4;local m6=lP+m3;local m7=lO+m2;local m8=lP+m1;if bL=="ORBIT"then lP=lP+lR;lT=lQ/2;lW=0;lX={}lX.periapsis={}lX.apoapsis={}if fl~=nil then if fl.periapsis~=nil then lX.periapsis.altitude=fl.periapsis.altitude;lX.periapsis.speed=fl.periapsis.speed end;if fl.apoapsis~=nil then lX.apoapsis.altitude=fl.apoapsis.altitude;lX.apoapsis.speed=fl.apoapsis.speed end;lX.period=fl.period;lX.eccentricity=fl.eccentricity;lX.timeToApoapsis=fl.timeToApoapsis;lX.timeToPeriapsis=fl.timeToPeriapsis;lX.eccentricAnomaly=fl.eccentricAnomaly;lX.trueAnomaly=fl.trueAnomaly end;if lX.periapsis==nil then lX.periapsis={}lX.periapsis.altitude=-ks.radius;lX.periapsis.speed=a1 end;if lX.eccentricity==nil then lX.eccentricity=1 end;if lX.apoapsis==nil then lX.apoapsis={}lX.apoapsis.altitude=cj;lX.apoapsis.speed=0 end;if cM<1 then lX.apoapsis.altitude=cj;lX.apoapsis.speed=0 end;if lX.apoapsis.altitude then lV=(lX.apoapsis.altitude+lX.periapsis.altitude+ks.radius*2)/(lT*2)lU=(ks.radius+lX.apoapsis.altitude)/lV*(1-lX.eccentricity)lW=lT-lX.periapsis.altitude/lV-ks.radius/lV;local m9=math.pi;if lX.period~=nil and lX.period>0 and lX.timeToApoapsis~=nil then m9=lX.eccentricAnomaly;if lX.timeToPeriapsis<lX.timeToApoapsis then m9=2*math.pi-m9 end end;if cM<1 or m9~=m9 then m9=math.pi end;local ma=-lT*math.cos(m9)+lO+m4+lR;local mb=lU*math.sin(m9)+lP+m3+lR;local mc=""jT[#jT+1]='<g clip-path="url(#orbitRect)">'jT[#jT+1]=dl([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mc,lO+lQ+lR,lP+lQ*1.5/2+lR,lT,lU)if lU<1 then jT[#jT+1]=dl([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lO+lQ+lR-lW,lP+lQ*1.5/2+lR,ma,mb)end;jT[#jT+1]=dl('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lO+lQ+lR-lW,lP+lQ*1.5/2+lR,(ks.radius+ks.noAtmosphericDensityAltitude)/lV)jT[#jT+1]=dl('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lO+lQ+lR-lW,lP+lQ*1.5/2+lR,(ks.radius+ks.noAtmosphericDensityAltitude)/lV)jT[#jT+1]=dl([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lO+lQ+lR,lP+lQ*1.5/2+lR,lT,lU)jT[#jT+1]=dl('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lO+lQ+lR-lW,lP+lQ*1.5/2+lR,ks.radius/lV)jT[#jT+1]='</g>'local md=math.floor(ks.radius/lV+0.5)hy=lO+lQ+lR*4+lT;hz=lP+lQ*1.5/2+5+lR;if lX.apoapsis~=nil and lX.apoapsis.speed<a1 then lY("Apoapsis")end;hz=lP+lQ*1.5/2+5+lR;hy=lO+lQ-lR*2-lT;if lX.periapsis~=nil and lX.periapsis.speed<a1 and lX.periapsis.altitude>0 then lY("Periapsis")end;jT[#jT+1]=gE(lO+lQ+lR,lP+20+lR,ks.name,"txtorbbig")jT[#jT+1]=dl('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',ma,mb)jT[#jT+1]=[[</g>]]return jT else jT[#jT+1]='<g clip-path="url(#orbitRect)">'local me=""local mf=1.2*(mg-mh)/(lQ*2)local mi=1.4*(mj-mk)/(lQ*1.5)for dM,dy in pairs(e[0])do if dy.center then local hy=lO+lQ+dy.center.x/mf;local hz=lP+lQ*1.5/2+dy.center.y/mi;me=me..'<circle cx="'..hy..'" cy="'..hz..'" r="'..dy.radius/mf*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dy.name,"Moon")and not string.match(dy.name,"Sanctuary")and not string.match(dy.name,"Space")then me=me.."<text x='"..hy.."' y='"..hz+dy.radius/mf*30+20 .."' font-size='12' fill="..iZ.." text-anchor='middle' font-family='Montserrat'>"..dy.name.."</text>"end end end;local fn=vec3(bQ.getWorldPosition())local hy=lO+lQ+fn.x/mf;local hz=lP+lQ*1.5/2+fn.y/mi;me=me..'<circle cx="'..hy..'" cy="'..hz..'" r="2" stroke="white" stroke-width="1" fill="red"/>'me=me.."<text x='"..hy.."' y='"..hz-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iM=mf;iN=mi;local ml=fn+cL*1000000;local mm=lO+lQ+ml.x/mf;local jC=lP+lQ*1.5/2+ml.y/mi;me=me..'<line x1="'..hy..'" y1="'..hz..'" x2="'..mm..'" y2="'..jC..'" stroke="purple" stroke-width="1"/>'jT[#jT+1]=me;jT[#jT+1]='</g>'end elseif bL=="INFO"then jT=cs.DrawOdometer(jT,j0,bq,j1)elseif bL=="HELP"then jT=lH(jT)elseif bL=="SCOPE"then jT[#jT+1]='<g clip-path="url(#orbitRect)">'local mn=d6;local mo=vec3(DUSystem.getCameraWorldPos())local mp=vec3(DUSystem.getCameraWorldRight())local mq=vec3(DUSystem.getCameraWorldForward())if iA()==1 then mo=cP;mp=cJ;mq=cI end;if ci>0 then table.sort(d5,function(eB,eC)local eD,eE=eB.center,eC.center;return(eD.x-mo.x)^2+(eD.y-mo.y)^2+(eD.z-mo.z)^2<(eE.x-mo.x)^2+(eE.y-mo.y)^2+(eE.z-mo.z)^2 end)end;local mr={}local ms={}local mt=120;local mu=nil;local mv=nil;for M,dy in ipairs(d5)do local gM=dy.center-mo;local mw=gM:len()local mx=gM:normalize()local my=gM:cross(mq):normalize()local mz=math.acos(my:dot(mp))if mz~=mz then mz=0 end;if my:cross(mp):dot(mq)<0 then mz=-mz end;local mA=gM:project_on_plane(mq):len()local mB=math.sin(mz)*math.asin(mA/mw)*constants.rad2deg;local mC=math.cos(mz)*math.asin(mA/mw)*constants.rad2deg;if mx:dot(mq)<0 then mC=90*math.cos(mz)+90*math.cos(mz)-mC;mB=90*math.sin(mz)+90*math.sin(mz)-mB end;local hy=m5+mB/mn*m1;local hz=m6+mC/mn*m1;local mD=(hy-m5)*(hy-m5)+(hz-m6)*(hz-m6)local mE=math.asin((dy.radius+dy.surfaceMaxAltitude)/mw)*constants.rad2deg;if mE~=mE then mE=mn end;local hT=mE/mn*m1;local mF=math.asin(dy.atmosphereRadius/mw)*constants.rad2deg;if mF~=mF then mF=mE end;local mG=mF/mn*m1;local cc=iD(mw,1)local mH=dy.name;local mI=false;if hz>lP then if hz>m8 then if hz-mG<=m8 then mI=true end else mI=true end else if hz+mG>=lP then mI=true end end;local mJ=false;local mK=hy;if dy.systemId==0 then mK=hy+mt else mK=hy-mt end;if mK+mt>lO then if mK+mt>m7 then if mK-mG-mt<=m7 then mJ=true end else mJ=true end else if mK+mG+mt>=lO then mJ=true end end;local mL={}mL.x=hy;mL.y=hz;mL.planet=dy;mL.atmoSize=mG;if not mu or mD<mu then mu=mD;mv=mL end;if mJ and mI then local mM=math.max(mG,5)if mD<mM*mM then mH=mH.." - "..cc end;mL.size=hT;mL.i=M;mL.displayString=mH;mL.distance=cc;mL.visible=true;ms[#ms+1]=mL else mL.visible=false end end;local mN=false;table.sort(ms,function(eD,eE)return eD.y<eE.y end)for dM,fi in ipairs(ms)do local dy,hT,M,mG,hy,hz,mH,cc=fi.planet,fi.size,fi.i,fi.atmoSize,fi.x,fi.y,fi.displayString,fi.distance;local l_,mO,mP,mQ;local mR=15;local jN="pdim"if dy.systemId~=0 then mP=j6(string.len(mH)*5)mR=-(15+mP)mQ=j7(10)jN="pdimfill"else mP=j6(string.len(mH)*9)mQ=j7(15)end;if hT*2>mP then l_=dm(hy,lO+mP/2,m7-mP/2)mO=dm(hz,lP+mQ,m8-5)l_=dm(l_,hy-hT+mP/2,hy+hT-mP/2)mO=dm(mO,hz-hT+mQ,hz+hT)else l_=hy+mR;mO=hz end;for mS,fi in pairs(mr)do local mT=fi.textPositions;local mU=mT.y-mO;if mS~=M and e_(mU)<mT.height and mT.x+mT.width>l_ and mT.x<l_+mP then if hT>mP then mO=dm(mO+mQ,lP+15,m8-5)else mO=mT.y+mT.height+1 end end end;local mV=mH~=dy.name or l_<=m5 and l_+mP>=m5 and mO-mQ<=m6 and mO>=m6;fi.hovered=mV;local mW=1;if mV then mW=2;if hT*2<mP then mW=10 end;if mH==dy.name then mH=mH.." - "..cc end;jN="pbright"if dy.systemId~=0 then mP=j6(string.len(mH)*5)mR=-(15+mP)else mP=j6(string.len(mH)*7)end;if hT*2>mP then l_=dm(hy,lO+mP/2,m7-mP/2)l_=dm(l_,hy-hT+mP/2,hy+hT-mP/2)else l_=hy+mR end end;mr[M]={}mr[M].textPositions={}mr[M].textPositions.y=mO;mr[M].textPositions.x=l_;mr[M].textPositions.width=mP;mr[M].textPositions.height=mQ;mr[M].output=""if hT*2>mP then jN=jN.." txtmid"else jN=jN.." txtstart"end;if mG-hT>2 then mr[M].output=dl('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hy,hz,mG,i_,0.1*mW)end;mr[M].output=mr[M].output..dl('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hy,hz,hT,i_,0.2*mW)if dy.systemId==0 then mr[M].output=mr[M].output..dl([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],l_,mO,iZ,jN,mH)if hT*2<=mP then mr[M].output=mr[M].output..dl("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",l_+mP,mO+2,l_,mO+2,hy,hz)end else mr[M].output=mr[M].output..dl([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],l_,mO,i_,jN,mH)if hT*2<=mP then mr[M].output=mr[M].output..dl("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",l_,mO+2,l_+mP,mO+2,hy,hz)end end end;for dM=#d5,1,-1 do if mr[dM]then jT[#jT+1]=mr[dM].output end end;if mv~=nil and d6<90 and not mv.hovered then local mX=mv.planet.atmosphereRadius/mv.atmoSize;local mY=dp(mu)*mX;local mZ=iD(mY,1)local mP=j6(math.max(string.len(mZ)*7,string.len(mv.planet.name)*7))local mQ=j7(12)local l_=dm(mv.x+(m5-mv.x)/2,lO+mP/2,m7-mP/2)local mO=dm(mv.y+(m6-mv.y)/2,lP+mQ*2,m8-5)jT[#jT+1]=dl("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mv.x,mv.y,m5,m6)jT[#jT+1]=dl([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],l_,mO,"white",mZ)if not mv.visible then jT[#jT+1]=dl([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],l_,mO-mQ,"white",mv.planet.name)end end;if cM>1 then local gM=cL;local mx=gM:normalize()local mA=gM:project_on_plane(mq):len()local my=gM:cross(mq):normalize()local mz=math.acos(my:dot(mp))if mz~=mz then mz=0 end;if my:cross(mp):dot(mq)<0 then mz=-mz end;local mB=math.sin(mz)*math.asin(mA/gM:len())*constants.rad2deg;local mC=math.cos(mz)*math.asin(mA/gM:len())*constants.rad2deg;if mx:dot(mq)<0 then mC=90*math.cos(mz)+90*math.cos(mz)-mC;mB=90*math.sin(mz)+90*math.sin(mz)-mB end;local hy=m5+mB/mn*m1;local hz=m6+mC/mn*m1;local kQ=14;local kR=kQ/2;local kU=[[<circle
                                    cx="]]..hy..[["
                                    cy="]]..hz..[["
                                    r="]]..kR/kQ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hy..[["
                                    cy="]]..hz..[["
                                    r="]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hy-kQ..[[,]]..hz..[[ h ]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hy+kR..[[,]]..hz..[[ h ]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hy..[[,]]..hz-kQ..[[ v ]]..kR..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jT[#jT+1]=kU end;jT[#jT+1]=dl("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m5,m6-10,m5,m6+10)jT[#jT+1]=dl("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m5-10,m6,m5+10,m6)jT[#jT+1]='</g>'else return jT end end;local function m_(n0,n1)local n2;local n3=(n1-n0):normalize()local fo=(cP-n0):dot(n3)/n3:dot(n3)if fo<=0. then return(cP-n0):len()elseif fo>=(n1-n0):len()then return(cP-n1):len()end;local n4=n0+fo*n3;n2=(n4-cP):len()return n2 end;local function n5()local n2;local n6=nil;local n7=nil;local n8=nil;for dM,n9 in pairs(e[0])do if n9.hasAtmosphere then local cc=m_(ks.center,n9.center)if n6==nil or cc<n6 then n7=n9;n6=cc;n8=ks end;if c9 and c9.hasAtmosphere and c9.name~=ks.name then local eQ=m_(c9.center,n9.center)if eQ<n6 then n7=n9;n6=eQ;n8=c9 end end end end;local na=j6(1770)local nb=j7(330)if n6 then local nc="txttick "local nd=500000;if n6<n7.radius+nd or n6<n8.radius+nd then if cW then nc="txttick red "else nc="txttick orange "end end;n2=iD(n6,2)iR=gE(na,nb,"Pipe ("..n8.name.."--"..n7.name.."): "..n2,nc.."pbright txtmid")end end;local function ne(hy,hz,nf,ng,l2)local nh={x=hy,y=hz,width=nf,height=ng,label=l2}iL[l2]=nh;return nh end;local function ni(nj,nk,nf,ng,hy,hz,nl,nm,nn,no,jN)local nh={enableName=nj,disableName=nk,width=nf,height=ng,x=hy,y=hz,toggleVar=nl,toggleFunction=nm,drawCondition=nn,hovered=false,class=jN}if no then table.insert(iK,nh)else table.insert(iJ,nh)end;return nh end;local function np(nq)if not iP then nr=false;ns=false;nt=false;w=true;return elseif nq=="handling"then nr=not nr;ns=false;nt=false elseif nq=="hud"then ns=not ns;nr=false;nt=false elseif nq=="physics"then nt=not nt;nr=false;ns=false end;if nt or ns or nr then iQ=iC(nq)w=false else iQ="none"w=true end end;local function nu()iP=not iP;if iP then iI=iK;dj("Tap LMB to see Settings")d7=w else iI=iJ;dj("Tap LMB to see Control Buttons")np()w=d7 end end;local function nv()local function nw(dy,dM)dy.set(not dy.get())if dy.get()then dj(dM.." set to true")else dj(dM.." set to false")end;if dM=="showHud"then d7=dy.get()elseif dM=="BrakeToggleDefault"then b1=k end end;local nx=50;local ny=340;local hy=ad/2-530;local hz=ae/2-330+nx/2;local nz=0;for dM,dy in pairs(iC("boolean"))do if type(dy.get())=="boolean"then ni(dM,dM,ny,nx,hy,hz,function()return dy.get()end,function()nw(dy,dM)end,function()return true end,true)hz=hz+nx+20;if nz==9 then hy=hy+ny+20;hz=ae/2-330+nx/2;nz=0 else if hy>ad/2-ny and hy<ad/2+ny/2 and hz>ae/2-nx and hz<ae/2+nx then hz=hz+nx+20;nz=nz+1 end;nz=nz+1 end end end;ni("Control View","Control View",ny,nx,10,ae/2-500,function()return true end,nu,function()return true end,true)ni("View Handling Settings",'Hide Handling Settings',ny,nx,10,ae/2-(500-nx),function()return nr end,function()np("handling")end,function()return true end,true)ni("View Hud Settings",'Hide Hud Settings',ny,nx,10,ae/2-(500-nx*2),function()return ns end,function()np("hud")end,function()return true end,true)ni("View Physics Settings",'Hide Physics Settings',ny,nx,10,ae/2-(500-nx*3),function()return nt end,function()np("physics")end,function()return true end,true)end;local function nA()local function go()local fO=cP;local gp=ks.name..". "..#bs;if cv then gp=cv.GetClosestName(gp)end;return ct.AddNewLocation(gp,fO,false,true)end;local function nB()b7=not b7 end;local function nC(nD)if nD==1 then b5=not b5;b4=false else b4=not b4;b5=false end;b6=false;b8=false;c1=false;b9=false;bw=nil;bb=false;ba=false end;local function nE(nF,nG)ct.UpdatePosition(nil,nF,nG)end;local function gj()ct.ClearCurrentPosition()end;local function nH(gn)local lG=cu.routeWP(true)if lG and#lG>0 then return"Engage Route: "..lG[1]end;return"Engage Autopilot: "..lE(gn)end;local function nI(gn)local lG=cu.routeWP(true)if lG and#lG>0 then return"Next Route Point: "..lG[1]end;return"Disable Autopilot: "..lE(gn)end;local function nJ()if iy()==1 then c1=not c1;if c1 then b6=false;b4=false;b5=false;b8=false;bb=false;b9=false;ba=false;nK=bp;bp=false;d.control.retractLandingGears()iz:setTargetGroundAltitude(Z)fL("folOn","F")else fL("folOff","F")b3="Follow Off"cA=q;bp=nK;if bp then d.control.deployLandingGears()iz:setTargetGroundAltitude(_)end end else dj("Follow Mode only works with Remote controller")c1=false end end;local nx=50;local ny=260;local nL=j6(30)local nM=aC+aB*2+2;local nN=aD+1;ni("+","+",nL,nL,nM,nN+nL+1,function()return false end,function()d6=d6/8 end,function()return bL=="SCOPE"end,nil,"ZoomButton")ni("-","-",nL,nL,nM,nN,function()return false end,function()d6=math.min(d6*8,90)end,function()return bL=="SCOPE"end,nil,"ZoomButton")ni("0","0",nL,nL,nM,nN+nL*2+2,function()return false end,function()d6=90 end,function()return bL=="SCOPE"and d6~=90 end,nil,"ZoomButton")local nO=ni("Enable Brake Toggle","Disable Brake Toggle",ny,nx,ad/2-ny/2,ae/2+350,function()return b1 end,function()b1=not b1;if b1 then dj("Brakes in Toggle Mode")else dj("Brakes in Default Mode")end end)ni("Align Prograde","Disable Prograde",ny,nx,ad/2-ny/2-50-nO.width,ae/2-nx+380,function()return b5 end,function()nC(1)end)ni("Align Retrograde","Disable Retrograde",ny,nx,ad/2-ny/2+nO.width+50,ae/2-nx+380,function()return b4 end,nC,function()return ci==0 end)nP=ni(nH,nI,600,60,ad/2-600/2,ae/2-60/2-330,function()return b6 or bt or ce or bC end,function()end)local M;local function nQ(nR)local gn=d2+nR;if gn>#cV then gn=gn-#cV-1 end;if gn<0 then gn=#cV+gn end;return gn end;nS={}for M=0,10 do local nT=ni(function(eE)local gn=nQ(eE.apExtraIndex)if b6 or bt or ce or bC then return"Redirect: "..lE(gn)end;return nH(gn)end,function(eE)local gn=nQ(eE.apExtraIndex)return nI(gn)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eE)local gn=nQ(eE.apExtraIndex)return gn==bo and(b6 or bt or ce or bC)end,function(eE)local gn=nQ(eE.apExtraIndex)local nU=bo==gn;bo=gn;ct.UpdateAutopilotTarget()cu.ToggleAutopilot()if not nU and not(b6 or bt or ce or bC)then cu.ToggleAutopilot()end end,function()return d1 and(#cu.routeWP(true)==0 or M==0)end)nT.apExtraIndex=M;nS[M]=nT end;ni("Save Position","Save Position",200,nP.height,nP.x+nP.width+30,nP.y,function()return false end,go,function()return bo==0 or fX==nil end)ni("Update Position","Update Position",200,nP.height,nP.x+nP.width+30,nP.y,function()return false end,function()nE(nil)end,function()return bo>0 and fX~=nil end)ni("Save Heading","Clear Heading",200,nP.height,nP.x+nP.width+30,nP.y+nP.height+20,function()return fX.heading~=nil end,function()if fX.heading~=nil then nE(false)else nE(true)end end,function()return bo>0 and fX~=nil end)ni("Save AGG Alt","Clear AGG Alt",200,nP.height,nP.x+nP.width+30,nP.y+nP.height*2+40,function()return fX.agg~=nil end,function()if fX.agg~=nil then nE(nil,false)else nE(nil,true)end end,function()return bo>0 and fX~=nil and antigrav end)ni("Clear Position","Clear Position",200,nP.height,nP.x-200-30,nP.y,function()return true end,gj,function()return bo>0 and fX~=nil end)ni("Save Route","Save Route",200,nP.height,nP.x-200-30,nP.y+nP.height*2+40,function()return false end,function()cu.routeWP(false,false,2)end,function()return#cu.routeWP(true)>0 end)ni("Load Route","Clear Route",200,nP.height,nP.x-200-30,nP.y+nP.height+20,function()return#cu.routeWP(true)>0 end,function()if#cu.routeWP(true)>0 then cu.routeWP(false,true)elseif b6 or bt then dj("Disable Autopilot before loading route")return else cu.routeWP(false,false,1)end end,function()return true end)nx=60;ny=300;local hy=0;local hz=ae/2-150;ni("Enable Check Damage","Disable Check Damage",ny,nx,hy,hz-nx-20,function()return s end,function()s=not s end)ni("View Settings","View Settings",ny,nx,hy,hz,function()return true end,nu)hz=hz+nx+20;ni("Enable Turn and Burn","Disable Turn and Burn",ny,nx,hy,hz,function()return b7 end,nB)hy=10;hz=ae/2-300;ni("Horizontal Takeoff Mode","Vertical Takeoff Mode",ny,nx,ad/2-ny/2,hz+20,function()return b2 end,function()b2=not b2;if b2 then dj("Vertical Takeoff Mode")else dj("Horizontal Takeoff Mode")end end,function()return cQ end)hz=hz+nx+20;ni("Engage Orbiting","Cancel Orbiting",ny,nx,hy+ny+20,hz,function()return bC end,cu.ToggleIntoOrbit,function()return ci==0 and cZ end)hz=ae/2-150;ni("Glide Re-Entry","Cancel Glide Re-Entry",ny,nx,hy+ny+20,hz,function()return bb end,function()cd=1;nC(1)end,function()return ks.hasAtmosphere and not ch end)hz=hz+nx+20;ni("Parachute Re-Entry","Cancel Parachute Re-Entry",ny,nx,hy+ny+20,hz,function()return bb end,function()cd=2;nC(1)end,function()return ks.hasAtmosphere and not ch end)hz=hz+nx+20;ni("Engage Follow Mode","Disable Follow Mode",ny,nx,hy,hz,function()return c1 end,nJ,function()return iy()==1 end)ni("Enable Repair Arrows","Disable Repair Arrows",ny,nx,hy+ny+20,hz,function()return j4 end,function()j4=not j4;if j4 then dj("Repair Arrows Enabled")else dj("Repair Arrows Diabled")end end,function()return iy()==1 end)hz=hz+nx+20;if not r then ni("Enable AGG","Disable AGG",ny,nx,hy,hz,function()return cR end,cu.ToggleAntigrav,function()return antigrav~=nil end)end;ni(function()return dl("Switch IPH Mode - Current: %s",bD)end,function()return dl("IPH Mode: %s",bD)end,ny*2,nx,hy,hz,function()return false end,function()if bD=="All"then bD="Custom Only"elseif bD=="Custom Only"then bD="No Moons-Asteroids"else bD="All"end;dj("IPH Mode: "..bD)end)hz=hz+nx+20;ni(function()return dl("Toggle Control Scheme - Current: %s",g)end,function()return dl("Control Scheme: %s",g)end,ny*2,nx,hy,hz,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;dj("New Control Scheme: "..g)end)local nV=j7(20)local nT=ne(0,0,j6(70),nV,"HELP")nT=ne(nT.x+nT.width,nT.y,j6(80),nV,"INFO")nT=ne(nT.x+nT.width,nT.y,j6(70),nV,"ORBIT")nT=ne(nT.x+nT.width,nT.y,j6(70),nV,"SCOPE")ne(nT.x+nT.width,nT.y,j6(70),nV,"HIDE")end;local nW={}local nX=nil;function nW.HUDPrologue(jT)if not cW then iW=aj;iX=ak;iY=al else iW=ag;iX=ah;iY=ai end;iZ=[[rgb(]]..bO(iW+0.6)..","..bO(iX+0.6)..","..bO(iY+0.6)..[[)]]i_=[[rgb(]]..bO(iW*0.8+0.5)..","..bO(iX*0.8+0.5)..","..bO(iY*0.8+0.5)..[[)]]local nY=iZ;local nZ=i_;local n_=[[rgb(]]..bO(iW*0.4+0.5)..","..bO(iX*0.4+0.5)..","..bO(iY*0.4+0.5)..[[)]]local o0=iZ;local o1=i_;local o2=n_;if j8()and not n then nY=[[rgb(]]..bO(iW*0.5+0.5)..","..bO(iX*0.5+0.5)..","..bO(iY*0.5+0.5)..[[)]]nZ=[[rgb(]]..bO(iW*0.3+0.5)..","..bO(iX*0.3+0.5)..","..bO(iY*0.2+0.5)..[[)]]n_=[[rgb(]]..bO(iW*0.2+0.5)..","..bO(iX*0.2+0.5)..","..bO(iY*0.2+0.5)..[[)]]end;local ls=j6;local lt=j7;jT[#jT+1]=dl([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nY,nY,nY,o0,o0,nZ,nZ,o1,o1,nZ,nY,n_,o1,nY,nY,n_,n_,o2,n_,ad,ae,nZ,nZ,nZ,nZ,nZ,o0,nZ,o1,o2,o1,o1,o2)if not nX then nX=dl([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],ls(630),lt(0),ls(675),lt(45),ls(960),lt(55),ls(1245),lt(45),ls(1290),lt(0),ls(1000),lt(105),ls(1040),lt(59),ls(1250),lt(51),ls(1300),lt(0),ls(1920),lt(0),ls(1920),lt(20),ls(1400),lt(20),ls(1300),lt(105),ls(920),lt(105),ls(880),lt(59),ls(670),lt(51),ls(620),lt(0),ls(0),lt(0),ls(0),lt(20),ls(520),lt(20),ls(620),lt(105),ls(890),lt(59),ls(960),lt(62),ls(1030),lt(59),ls(985),lt(112),ls(1150),lt(112),ls(1100),lt(152),ls(820),lt(152),ls(780),lt(112),ls(935),lt(112),ls(890),lt(59),ls(960),lt(62),ls(1030),lt(59),ls(985),lt(112),ls(1150),lt(112),ls(1100),lt(152),ls(820),lt(152),ls(780),lt(112),ls(935),lt(112))end;if w and I then jT[#jT+1]=nX end;return jT end;function nW.DrawVerticalSpeed(jT,e4)jS(jT,e4)end;function nW.UpdateHud(jT)local kJ=cT;local o3=cU;local j_=o3;local kf=kJ;local l0=bO(c.getThrottle())local l5=cM*3.6;local l1=c.getAxisCommandValue(0)local o4=j6(1770)local o5=j7(310)if t and cS then l1=bS;l0=bS*100 end;local ja=j9()local k0="ROLL"if l0==nil then l0=0 end;if not cZ then if cM>5 then kJ=kI(cK)o3=kK(cK)else kJ=0;o3=0 end;k0="YAW"end;if cX>50000 and not ch then local o6;o6=iD(cX)jT[#jT+1]=gE(o4,o5,"PvP Boundary: "..o6,"pbright txtbig txtmid")end;jT[#jT+1]=j2;jT[#jT+1]=i6;if iR~=""then jT[#jT+1]=iR end;if jb~=""then jT[#jT+1]=jb end;if jc~=""then jT[#jT+1]=jc end;jS(jT,cj)if iy()==0 or m then if not j8()or n then if cZ then jZ(jT,am,an,j_,k0,cZ)ke(jT,kf,j_,am,an,cZ,bO(kK(cK)),cM)else jZ(jT,am,an,o3,k0,cZ)ke(jT,kJ,o3,am,an,cZ,bO(o3),cM)end;km(jT,cj,cZ)kL(jT,cK,cM,am,an)end end;k_(jT,ja,l0,l1)l4(jT,l5)l9(jT)lN(jT)if not iP and c2 then lF(jT)end;return jT end;function nW.HUDEpilogue(jT)jT[#jT+1]="</svg>"return jT end;function nW.ExtraData(jT)local o7=j6(1240)local o8=j7(55)local o9=o8+10;local oa;local ls=j6;local lt=j7;local ob=0;local ja=j9()if b2 then ja=ja.."-VERTICAL"end;if E and gP and not ba and not b9 and cM>20 then ja=ja.."-COLLISION ON"end;if bF~="Off"then ja="("..bF..")-"..ja end;if b7 then ja="TB-"..ja end;if not bE then ja=ja.."-DeCoupled"end;local oc=lt(99)local od=lt(80)local oe=lt(85)local of=lt(31)local og=0;local oh=0;local f4=ck>1000000 and fM(ck/1000000,2).."kT"or fM(ck/1000,2).."T"if ch then ob=bx else ob=bv end;local oi,oj=cq.computeDistanceAndTime(cM,0,ck,0,0,ob)if oi<0 then oi=0 end;ob=fM(ob/(ck*iH),2).."g"local ok=d:maxForceForward()oa=b.getGravityIntensity()if oa>0.1 then oh=ck*oa;oh=fM(oh/(ck*iH),2).."g"og=0.5*ok/oa;og=og>1000000 and fM(og/1000000,2).."kT"or fM(og/1000,2).."T"end;ok=fM(ok/(ck*iH),2).."g"local ol=vec3(bQ.getWorldAcceleration()):len()/9.80665;oa=b.getGravityIntensity()jT[#jT+1]=[[<g class="dim txt txtend size14">]]if iy()==1 and not m then o7=j6(1120)o8=j7(55)o9=o8+10 elseif ch and I then local om=j6(770)jT[#jT+1]=gE(ls(895),oc,"ATMO","")jT[#jT+1]=dl([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],ls(895),oe,ls(-80))jT[#jT+1]=gE(ls(815),od,dl("%.1f%%",ci*100),"txtstart size20")end;if I then jT[#jT+1]=gE(ls(1025),oc,"GRAVITY","txtstart")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(1025),oe,ls(80))jT[#jT+1]=gE(ls(1105),od,dl("%.2fg",oa/9.80665),"size20")jT[#jT+1]=gE(ls(1125),oc,"ACCEL","txtstart")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(1125),oe,ls(80))jT[#jT+1]=gE(ls(1205),od,dl("%.2fg",ol),"size20")jT[#jT+1]=gE(ls(695),oc,"BRK TIME","")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(695),oe,ls(-80))jT[#jT+1]=gE(ls(615),od,dl("%s",iE(oj)),"txtstart size20")jT[#jT+1]=gE(ls(635),lt(45),"TRIP","")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(635),lt(31),ls(-90))if lp then jT[#jT+1]=gE(ls(545),lt(26),dl("%s",iE(lp)),"txtstart size20")end;jT[#jT+1]=gE(ls(795),oc,"BRK DIST","")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(795),oe,ls(-80))jT[#jT+1]=gE(ls(715),od,dl("%s",iD(oi)),"txtstart size20")jT[#jT+1]=gE(ls(1285),lt(45),"MASS","txtstart")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(1285),lt(31),ls(90))jT[#jT+1]=gE(ls(1375),lt(26),dl("%s",f4),"size20")jT[#jT+1]=gE(ls(1220),oc,"THRUST","txtstart")jT[#jT+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ls(1220),oe,ls(80))jT[#jT+1]=gE(ls(1300),od,dl("%s",ok),"size20")jT[#jT+1]=gE(j6(960),j7(175),ja,"pbright txtbig txtmid size20")end;jT[#jT+1]="</g>"end;local on=1-(a7*0.05+a8*0.05)function nW.FuelUsed(oo)local op;if oo=="atmofueltank"then op=dl("Atmo Fuel Used: %.1f L",jt[oo]/(4*on))elseif oo=="spacefueltank"then op=dl("Space Fuel Used: %.1f L",jt[oo]/(6*on))else op=dl("Rocket Fuel Used: %.1f L",jt[oo]/(0.8*on))end;return op end;local oq,os,ot,ou,ov=0,0,0,{},0;local ow=0;local ox=0;local oy=0;local oz=0;function nW.DrawOdometer(jT,j0,bq,j1)if bL~="INFO"then return jT end;local oa;local ob=0;local oh=0;local f4=ck>1000000 and fM(ck/1000000,2).." kTons"or fM(ck/1000,2).." Tons"if ch then ob=bx else ob=bv end;local oi,oj=cq.computeDistanceAndTime(cM,0,ck,0,0,ob)local ok=d:maxForceForward()oa=b.getGravityIntensity()if cM<5 and cg~=-1 then local oA=vec3(bQ.getOrientationForward())local oB=bQ.getMaxThrustAlongAxis('thrust analog longitudinal ',{oA:unpack()})ow=0.5*oB[1]/oa;ow=ow>1000000 and fM(ow/1000000,1).." kTons"or fM(ow/1000,1).." Tons"ox=0.5*oB[3]/oa;ox=ox>1000000 and fM(ox/1000000,1).." kTons"or fM(ox/1000,1).." Tons"oA=vec3(bQ.getOrientationUp())oB=bQ.getMaxThrustAlongAxis('hover_engine, booster_engine',{oA:unpack()})oy=0.5*oB[1]/oa;oy=oy>1000000 and fM(oy/1000000,1).." kTons"or fM(oy/1000,1).." Tons"oz=0.5*ob/oa;oz=oz>1000000 and fM(oz/1000000,1).." kTons"or fM(oz/1000,1).." Tons"end;ob=fM(ob/(ck*iH),2).." g"if oa>0.1 then oh=ck*oa;oh=fM(oh/(ck*iH),2).." g"else oh="n/a"end;ok=fM(ok/(ck*iH),2).." g"if iy()==0 or m then local oC=j6(aC+10)local oD=j7(aD+20)local oE=j6(aC+10+aB/1.25)local ng=25;local oF=bO(1/aU)if ot<oF then ov=ov+a.getActionUpdateDeltaTime()ot=ot+1 else oq=1/(ov/oF)table.insert(ou,oq)ot,ov=0,0 end;os=0;for dM,dy in pairs(ou)do os=os+dy end;if#ou>0 then os=bO(os/#ou)end;if#ou>29 then table.remove(ou,1)end;jT[#jT+1]="<g class='txtstart size14 bright'>"jT[#jT+1]=gE(oC,oD,dl("BrkTime: %s",iE(oj)))jT[#jT+1]=gE(oE,oD,dl("Trip: %.2f km",j0))jT[#jT+1]=gE(oC,oD+ng,dl("Lifetime: %.2f kSU",bq/200000))jT[#jT+1]=gE(oE,oD+ng,dl("BrkDist: %s",iD(oi)))jT[#jT+1]=gE(oC,oD+ng*2,"Trip Time: "..iE(j1))jT[#jT+1]=gE(oE,oD+ng*2,"Total Time: "..iE(br))jT[#jT+1]=gE(oC,oD+ng*3,dl("Mass: %s",f4))jT[#jT+1]=gE(oE,oD+ng*3,dl("Safe Brake Mass: %s",oz))jT[#jT+1]=gE(oC,oD+ng*4,dl("Max Thrust: %s",ok))jT[#jT+1]=gE(oE,oD+ng*4,dl("Safe Atmo Mass: %s",ow))jT[#jT+1]=gE(oC,oD+ng*5,dl("Max Brake: %s",ob))jT[#jT+1]=gE(oE,oD+ng*5,dl("Safe Space Mass: %s",ox))jT[#jT+1]=gE(oE,oD+ng*6,dl("Safe Hover Mass: %s",oy))jT[#jT+1]=gE(oC,oD+ng*6,dl("Influence: %s",ks.name))jT[#jT+1]=gE(oC,oD+ng*7,dl("Set Max Speed: %s",bO(a1*3.6+0.5)))jT[#jT+1]=gE(oE,oD+ng*7,dl("Actual Max Speed: %s",bO(dg*3.6+0.5)))jT[#jT+1]=gE(oC,oD+ng*8,dl("Friction Burn Speed: %s",bO(bQ.getFrictionBurnSpeed()*3.6)))jT[#jT+1]=gE(oE,oD+ng*8,dl("FPS (Avg): %s (%s)",bO(oq),os))end;jT[#jT+1]="</g></g>"return jT end;function nW.DrawWarnings(jT)return l9(jT)end;function nW.DisplayOrbitScreen(jT)return lN(jT)end;function nW.DisplayMessage(jT,lk)if lk~="empty"then local hz=310;for lm in string.gmatch(lk,"([^\n]+)")do hz=hz+35;jT[#jT+1]=gE("50%",hz,lm,"msg")end end;if c5~=0 then c.setTimer("msgTick",c5)c5=0 end end;function nW.DrawDeadZone(jT)jT[#jT+1]=dl([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function nW.UpdatePipe()if ch then iR=""return end;n5()end;function nW.DrawSettings(jT)local hy=j6(640)local hz=j7(200)jT[#jT+1]=[[<g class="pbright txtvspd txtstart">]]local hP=0;for dM,dy in pairs(iQ)do hP=hP+1;jT[#jT+1]=gE(hy,hz,dM..": "..dy.get())hz=hz+20;if hP%12==0 then hy=hy+j6(350)hz=j7(200)end end;jT[#jT+1]=gE(j6(640),j7(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jT[#jT+1]="</g>"return jT end;local i5=j7(125)local i4=j6(1225)function nW.DrawRadarInfo()i6=cv.GetRadarHud(i4,i5,ay,az)if i6 then gP=true end end;function nW.DrawTanks()if au~=0 and av~=0 then jb=gE(au,av,"","txtstart pdim txtfuel")ju=av;jv(au,"Atmospheric ","ATMO",cm,jr,js)jv(au,"Space Fuel T","SPACE",cn,jp,jq)jv(au,"Rocket Fuel ","ROCKET",co,jn,jo)end end;function nW.DrawShield()local ih=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oG=bQ.getPvPTimer()local oH=shield.getResistances()local oI="A: "..10+oH[1]*100 .."% / E: "..10+oH[2]*100 .."% / K:"..10+oH[3]*100 .."% / T: "..10+oH[4]*100 .."%"local hy,hz=aw-60,ax+30;local jL=bO(dh*2.55)local jM=dl("rgb(%d,%d,%d)",255-jL,jL,0)local jN=""jc=gE(hy,hz,"","txtmid pdim txtfuel")if dh<10 and ih~="Shield Disabled"then jN="red "end;oG=oG>0 and"   PvPTime: "..iE(oG)or""jc=jc..dl([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hy,hz,jM,dh*2,hy,hz,hy+2,hz+10,dh,oG)jc=jc..gE(hy,hz-5,ih,jN.."txtstart pbright txtbig")jc=jc..gE(hy,hz+30,oI,jN.."txtstart pbright txtsmall")end;function nW.hudtick()if not ks then return end;local function oJ(jT)local jP=bO(dm(de/(ad/4)*255,0,255))jT[#jT+1]=dl("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ca,cb,bO(iW+0.5)+jP,bO(iX+0.5)-jP,bO(iY+0.5)-jP)end;local function oK()if c3 then for dR,dy in pairs(iI)do if dy.hovered then if not dy.drawCondition or dy.drawCondition(dy)then dy.toggleFunction(dy)end;dy.hovered=false end end;for dR,dy in pairs(iL)do if dy.hovered then bL=dy.label;dy.hovered=false end end;c3=false end end;local function oL()local function oM(oN,oO,hy,hz,nf,ng)if oN>=hy and oN<=hy+nf and oO>=hz and oO<=hz+ng then return true else return false end end;local hy=ca+ad/2;local hz=cb+ae/2;for dR,dy in pairs(iI)do dy.hovered=oM(hy,hz,dy.x,dy.y,dy.width,dy.height)end;for dR,dy in pairs(iL)do dy.hovered=oM(hy,hz,dy.x,dy.y,dy.width,dy.height)end;if d1 then local mV=false;for dR,eE in ipairs(nS)do if eE.hovered then mV=true;break end end;if nP.hovered then mV=true end;d1=mV else d1=nP.hovered;if not d1 then d2=bo end end end;local function oP(jT)if not bL or bL==""then bL="HELP"end;if w then for dM,dy in pairs(iL)do local jN="dim brightstroke"local oQ=0.2;if bL==dM then jN="pbright dimstroke"oQ=0.6 end;local oR=""if dy.hovered then oQ=0.8;oR=";stroke:white"end;jT[#jT+1]=dl([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dy.width,dy.height,dy.x,dy.y,jN,oQ,oR)jT[#jT+1]=gE(dy.x+dy.width/2,dy.y+dy.height/2+5,dy.label,"txt txtmid pdim")end end end;local function oS(jT)local function oT(jT,oU,hover,hy,hz,oV,oW,oX,oY,oZ,o_,nT)if type(oZ)=="function"then oZ=oZ(nT)end;if type(o_)=="function"then o_=o_(nT)end;jT[#jT+1]=dl("<rect x='%f' y='%f' width='%f' height='%f' fill='",hy,hz,oV,oW)if oU then jT[#jT+1]=dl("%s'",oX)else jT[#jT+1]=oY end;if hover then jT[#jT+1]=dl(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else jT[#jT+1]=dl(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fM(ag*0.5,0),fM(ah*0.5,0),fM(ai*0.5,0))end;jT[#jT+1]=" rx='5'></rect>"jT[#jT+1]=dl("<text x='%f' y='%f' font-size='24' fill='",hy+oV/2,hz+oW/2+5)if oU then jT[#jT+1]="black"else jT[#jT+1]="white"end;jT[#jT+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oU then jT[#jT+1]=dl("%s</text>",oZ)else jT[#jT+1]=dl("%s</text>",o_)end end;local p0=dl("rgb(%d,%d,%d)'",fM(ag*0.1,0),fM(ah*0.1,0),fM(ai*0.1,0))local p1=dl("rgb(%d,%d,%d)",fM(ag*0.8,0),fM(ah*0.8,0),fM(ai*0.8,0))local p2=oT;for dR,dy in pairs(iI)do local nk=dy.disableName;local nj=dy.enableName;if type(nk)=="function"then nk=nk(dy)end;if type(nj)=="function"then nj=nj(dy)end;if not dy.drawCondition or dy.drawCondition(dy)then p2(jT,dy.toggleVar(dy),dy.hovered,dy.x,dy.y,dy.width,dy.height,p1,p0,nk,nj,dy)end end end;local p3=fM(ad/2,0)local p4=fM(ae/2,0)local jT={}if p5 then jT[#jT+1]=p5 end;cs.HUDPrologue(jT)if w then cs.UpdateHud(jT)else if A then cs.DrawVerticalSpeed(jT,cj)end;cs.DrawWarnings(jT)end;if iP and iQ~="none"then cs.DrawSettings(jT)end;if cv then cs.DrawRadarInfo()else i6=""end;cs.HUDEpilogue(jT)jT[#jT+1]=dl([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c4~="empty"then cs.DisplayMessage(jT,c4)end;if iy()==0 and g=="virtual joystick"then if v then cs.DrawDeadZone(jT)end end;oP(jT)if iA()==0 then if iy()==1 and c2 then if not p6 then oL()oS(jT)end;if not cy and not cz then local p7=table.concat(jT,"")jT={}jT[#jT+1]=dl("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jT[#jT+1]=p7;jT[#jT+1]="</body>"cy=true;jT[#jT+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cz then local p7=table.concat(jT,"")jT={}jT[#jT+1]=dl("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jT[#jT+1]=p7;jT[#jT+1]="</body>"end;if not cy then jT[#jT+1]=dl([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p3,p4,ca,cb)end else oK()end else if not c2 and iy()==0 then oK()if de>aA then if v then oJ(jT)end end elseif c2 and(not p6 or not j)then oL()oS(jT)end;jT[#jT+1]=dl([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p3,p4,ca,cb)end;jT[#jT+1]=[[</svg></body>]]p8=table.concat(jT,"")end;function nW.TenthTick()local function p9()local pa=a.createData;local pb=a.createWidget;pc=a.createWidgetPanel("Interplanetary Helper")pd=pb(pc,"value")pe=pa('{"label": "Target Planet", "value": "N/A", "unit":""}')fK(pe,pd)pf=pb(pc,"value")pg=pa('{"label": "distance", "value": "N/A", "unit":""}')fK(pg,pf)gd=pb(pc,"value")gc=pa('{"label": "Travel Time", "value": "N/A", "unit":""}')fK(gc,gd)gf=pb(pc,"value")ge=pa('{"label": "Target Altitude", "value": "N/A", "unit":""}')fK(ge,gf)ph=pb(pc,"value")pi=pa('{"label": "End Speed", "value": "N/A", "unit":""}')g7=pb(pc,"value")g6=pa('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g5=pb(pc,"value")g4=pa('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g3=pb(pc,"value")g2=pa('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g1=pb(pc,"value")g0=pa('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g9=pb(pc,"value")g8=pa('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ch then fK(pi,ph)fK(g6,g7)fK(g4,g5)fK(g2,g3)fK(g0,g1)fK(g8,g9)end end;local function pj()gD(pc)pc=nil end;cs.DrawTanks()if shield then cs.DrawShield()end;if bm~="None"then if pc==nil then p9()end;if bm~=nil then local mw;local pk=fX~=nil;local pl=b6 and bi*3.6 or 0;fJ(pe,'{"label": "Target", "value": "'..bm..'", "unit":""}')if pk and not b6 then mw=(cP-fX.position):len()else mw=(bn-cP):len()end;if not b7 then c7,c8=cu.GetAutopilotBrakeDistanceAndTime(cM)iT,iU=cu.GetAutopilotBrakeDistanceAndTime(a1)else c7,c8=cu.GetAutopilotTBBrakeDistanceAndTime(cM)iT,iU=cu.GetAutopilotTBBrakeDistanceAndTime(a1)end;local lk=iD(mw)fJ(pg,'{"label": "distance", "value": "'..lk..'"}')fJ(gc,'{"label": "Travel Time", "value": "'..iE(lp)..'", "unit":""}')lk=iD(c7)fJ(g6,'{"label": "Cur Brake distance", "value": "'..lk..'"}')fJ(g4,'{"label": "Cur Brake Time", "value": "'..iE(c8)..'", "unit":""}')lk=iD(iT)fJ(g2,'{"label": "Max Brake distance", "value": "'..lk..'"}')fJ(g0,'{"label": "Max Brake Time", "value": "'..iE(iU)..'", "unit":""}')fJ(pi,'{"label": "End Speed", "value": "'..dl("%.0fkph",pl)..'", "unit":""}')lk=iD(gg)fJ(ge,'{"label": "Target Orbit", "value": "'..lk..'"}')if ch and not pm then a.removeDataFromWidget(g0,g1)a.removeDataFromWidget(pi,ph)a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)pm=true;if not cS and t and(b8 or bb or cf)then cu.cmdThrottle(1)b3=false;bW=false end end;if not ch and pm then if fJ(g0,g1)==1 then fK(g0,g1)end;if fJ(g0,ph)==1 then fK(pi,ph)end;if fJ(g2,g3)==1 then fK(g2,g3)end;if fJ(g4,g5)==1 then fK(g4,g5)end;if fJ(g6,g7)==1 then fK(g6,g7)end;if fJ(g8,g9)==1 then fK(g8,g9)end;pm=false end end else pj()end;if warpdrive~=nil then local pn=iw(warpdrive.getWidgetData())if pn.destination~="Unknown"and pn.distance>400000 then if not j5 then warpdrive.showWidget()j5=true end elseif j5 then warpdrive.hideWidget()j5=false end end end;function nW.OneSecondTick()local function po()local jF=bN()local l5=cM;local pp=jF-j3;if l5>1.38889 then l5=l5/1000;local pq=l5*(jF-j3)bq=bq+pq;j0=j0+pq end;j1=j1+pp;br=br+pp;j3=jF end;local function pr(jT)local ps=0;local pt=iG;local pu=0;local pv=0;local pw=0;local jL=0;local jM=""local px=b.getElementHitPointsById;local py=b.getElementMaxHitPointsById;local pz={}for dM in pairs(iF)do local pA=0;local pB=0;pB=py(iF[dM])pA=px(iF[dM])pu=pu+pA;if pA+1<pB then if pA==0 then pw=pw+1 else pv=pv+1 end;if j4 and#pz==0 then fO=vec3(b.getElementPositionById(iF[dM]))local hy=fO.x;local hz=fO.y;local hA=fO.z;table.insert(pz,b.spawnArrowSticker(hy,hz,hA+1,"down"))table.insert(pz,b.spawnArrowSticker(hy,hz,hA+1,"down"))b.rotateSticker(pz[2],0,0,90)table.insert(pz,b.spawnArrowSticker(hy+1,hz,hA,"north"))table.insert(pz,b.spawnArrowSticker(hy+1,hz,hA,"north"))b.rotateSticker(pz[4],90,90,0)table.insert(pz,b.spawnArrowSticker(hy-1,hz,hA,"south"))table.insert(pz,b.spawnArrowSticker(hy-1,hz,hA,"south"))b.rotateSticker(pz[6],90,-90,0)table.insert(pz,b.spawnArrowSticker(hy,hz-1,hA,"east"))table.insert(pz,b.spawnArrowSticker(hy,hz-1,hA,"east"))b.rotateSticker(pz[8],90,0,90)table.insert(pz,b.spawnArrowSticker(hy,hz+1,hA,"west"))table.insert(pz,b.spawnArrowSticker(hy,hz+1,hA,"west"))b.rotateSticker(pz[10],-90,0,90)table.insert(pz,iF[dM])end elseif j4 and#pz>0 and pz[11]==iF[dM]then for jE in pairs(pz)do b.deleteSticker(pz[jE])end;pz={}end end;ps=fM(pu/pt*100,2)if pw>0 or pv>0 then jT[#jT+1]=gE(0,0,"","pbright txt")jL=bO(ps*2.55)jM=dl("rgb(%d,%d,%d)",255-jL,jL,0)jT[#jT+1]=gE("50%",1035,"Elemental Integrity: "..ps.."%","txtbig txtmid","fill:"..jM)if pw>0 then jT[#jT+1]=gE("50%",1055,"Disabled Modules: "..pw.." Damaged Modules: "..pv,"txtbig txtmid","fill:"..jM)elseif pv>0 then jT[#jT+1]=gE("50%",1055,"Damaged Modules: "..pv,"txtbig txtmid","fill:"..jM)end end end;local function pC()if iv then if iV==nil and(hc~=nil or bp)then _autoconf.displayCategoryPanel(iv,weapon_size,"Weapons","weapon",true)iV=_autoconf.panels[_autoconf.panels_size]elseif iV~=nil and hc==nil and not bp then gD(iV)iV=nil end end end;local jT={}po()if s then pr(jT)end;pC()cs.UpdatePipe()cs.ExtraData(jT)j2=table.concat(jT,"")end;function nW.AnimateTick()cz=true;cy=false;ca=0;cb=0;c.stopTimer("animateTick")end;function nW.MsgTick()local jT={}cs.DisplayMessage(jT,"empty")c4="empty"c.stopTimer("msgTick")c5=3 end;function nW.ButtonSetup()nv()nA()iI=iJ end;if pD then for dM,dy in pairs(pD)do nW[dM]=dy end end;return nW end;local function pE(d,b,c,e,vBooster,hover,pF,antigrav,dbHud_1,e_,bO,bP,iy,eV,bN,dm,iz,fJ,iA,dp,fM,fL,iB,dq,iD,iE,pG,iw,dj)local a=DUSystem;local bQ=DUConstruct;local pH={}local pI=false;local pJ=0;local pK=0;local pL=0;local pM=bN()local pN=0;local pO=0;local pP=0;local pQ=0;local pR=false;local pS=false;local pT=false;local pU=nil;local pV=0;local iS=55;local pW=nil;local pX=false;local pY=false;local pZ=false;local p_=0;local q0=0;local q1=0;local q2=0;local q3=0;local q4={VectorToTarget=false}local q5=vec3(bQ.getWorldOrientationUp())local q6=nil;local q7=0;local q8=-1;local q9=-1;local qa=false;local qb=false;local qc=0;local qd=false;local qe=false;local qf=false;local qg=false;local qh=""local qi=false;local qj=false;local qk=""local ql=false;local qm=0;local qn=0;local function qo()return bQ.isInPvPZone()~=1,e_(bQ.getDistanceToSafeZone())end;local function qp(kh)local qq=bi;if not b6 then qq=0 end;local qr=bv;if ch then if bx and bx>0 then qr=bx else return 0,0 end end;return cq.computeDistanceAndTime(kh,qq,ck,0,0,qr-bk*ck)end;local function qs(kh)local qq=bi;if not b6 then qq=0 end;return cq.computeDistanceAndTime(kh,qq,ck,d:maxForceForward(),a3,bv-bk*ck)end;local function qt(qu,qv,qw)qv=qv:project_on_plane(qu)qw=qw:project_on_plane(qu)return eV(qv:cross(qw):dot(qu),qv:dot(qw))end;local qx=-1;local qy=-1;local function qz()local function qA()local qB=-1;local qC=-1;if vBooster then qB=vBooster.getDistance()if qB>-1 and qB<0.01 then qB=qx else qx=qB end end;if hover then qC=hover.getDistance()if qC>-1 and qC<0.01 then qC=qy else qy=qC end end;if qB~=-1 and qC~=-1 then if qB<qC then return qB else return qC end elseif qB~=-1 then return qB elseif qC~=-1 then return qC else return-1 end end;local qD=qA()local qE=-1;if antigrav and antigrav.isActive()==1 and not r and cM<iS then local qF=e_(cj-antigrav.getBaseAltitude())if qF<50 then return qF end end;if pF then qE=pF.raycast().distance;if qE==0 then qE=-1 end end;if qD~=-1 and qE~=-1 then if qD<qE then return qD else return qE end elseif qD~=-1 then return qD else return qE end end;local function qG(ks,eM,qH)local function qI(qJ,dY)local eS=vec3(dY)if qJ.id==0 then return setmetatable({latitude=eS.x,longitude=eS.y,altitude=eS.z,id=0,systemId=qJ.systemId},d_)end;local eT=eS-qJ.center;local cc=eT:len()local e4=cc-qJ.radius;local e2=0;local e3=0;if not dq(cc,0)then local eU=eV(eT.y,eT.x)e3=eU>=0 and eU or 2*math.pi+eU;e2=math.pi/2-math.acos(eT.z/cc)end;return setmetatable({latitude=math.deg(e2),longitude=math.deg(e3),altitude=e4,id=qJ.id,systemId=qJ.systemId},d_)end;local qK=qI(ks,eM)qK="::pos{"..qK.systemId..","..qK.id..","..qK.latitude..","..qK.longitude..","..qK.altitude.."}"if qH then return qK else qf=qK;return true end end;local function qL(qM,qN,qO)local function qP(qM,ev)qM=vec3(qM)ev=vec3(ev):normalize()local dH=qM*ev;return dH.x+dH.y+dH.z end;local qQ=0.001;local qR=1;if not ch or not cB or cg~=-1 or cM<iS then if qO==nil then qO=aT end;if qN==nil then qN=qQ end;qM=vec3(qM):normalize()local qS=vec3()-qM;local qT=-qP(qS,bQ.getWorldOrientationRight())*qR;local qU=-qP(qS,bQ.getWorldOrientationUp())*qR;if pK==0 then pK=qT/2 end;if pL==0 then pL=qU/2 end;if e_(qT)<0.1 then q0=q0-qT*2 else q0=q0-(qT+(qT-pK)*qO)end;if e_(qU)<0.1 then p_=p_+qU*2 else p_=p_+qU+(qU-pL)*qO end;pK=qT;pL=qU;if e_(qT)<qN and e_(qU)<qN then return true end;return false elseif cB and cg==-1 then qM=cL;if qO==nil then qO=aT end;if qN==nil then qN=qQ end;qM=vec3(qM):normalize()local qS=cI-qM;local qT=-qP(qS,bQ.getWorldOrientationRight())*qR;local qU=-qP(qS,bQ.getWorldOrientationUp())*qR;if pK==0 then pK=qT/2 end;if pL==0 then pL=qU/2 end;if e_(qT)<0.1 then q0=q0-qT*5 else q0=q0-(qT+(qT-pK)*qO)end;if e_(qU)<0.1 then p_=p_+qU*5 else p_=p_+qU+(qU-pL)*qO end;pK=qT;pL=qU;if e_(qT)<qN and e_(qU)<qN then return true end;return false end end;function pH.clearAll()be=false;bg=false;bh=false;b6=false;bf=false;bj="Aligning"b4=false;b5=false;cY=nil;b8=false;bb=false;b9=false;ba=false;bc=false;c1=false;pY=false;cd=false;ce=false;pZ=false;cA=q;bt=false;b7=false;cl=false;bw=nil;bC=false;dc=false;dd=nil;cf=false end;function pH.GetAutopilotBrakeDistanceAndTime(kh)return qp(kh)end;function pH.GetAutopilotTBBrakeDistanceAndTime(kh)return qs(kh)end;function pH.showWayPoint(ks,eM,qH)return qG(ks,eM,qH)end;function pH.APTick()local qV=a.getMouseWheel()if qV>0 then cu.changeSpd()elseif qV<0 then cu.changeSpd(true)else pX=true end;qc=iA()if qf then a.setWaypoint(qf)qf=false end;if qi then antigrav.setTargetAltitude(qi)qi=false end;if qg then fJ(qg,qh)qg=false;qh=""end;if q9~=-1 then cu.cmdCruise(q9,qa)qa=false;q9=-1 end;if q6~=nil then if iz:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iz:getTargetSpeed(axisCommandId.longitudinal)~=q6 then iz:setTargetSpeedCommand(axisCommandId.longitudinal,q6)else q6=nil end end;if q8~=-1 then cu.cmdThrottle(q8,qa)qa=false;q8=-1 end;if qb then cw.landingGear(qb)qb=false end;if qj then cu.ToggleAutopilot()end end;function pH.ToggleIntoOrbit()cF=false;pP=nil;pQ=nil;pV=0;pS=false;if not ch then if bC then fL("orOff","AP")bC=false;pR=false;pU=nil;cA=q;if b8 then b8=false;ba=false end;q4.VectorToTarget=false;q4.AutopilotAlign=false;pT=false elseif cZ then fL("orOn","AP")bC=true;cA=true;if pU==nil then pU=ks end;if b8 then b8=false;ba=false end else dj("Unable to engage auto-orbit, not near a planet")end else bC=false;pR=false;pU=nil;cA=q;if b8 then b8=false end;q4.VectorToTarget=false;q4.AutopilotAlign=false;pT=false end end;function pH.ToggleVerticalTakeoff()b8=false;if bc then qW=true;bb=false;ba=false;b9=true;cA=true;c0=0;if ch and cg==-1 then b9=false;b8=true;c0=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q9=bO(cC)end else cF=false;bp=false;d.control.retractLandingGears()iz:setTargetGroundAltitude(Z)b3="VTO Takeoff"end;bc=not bc end;function pH.checkLOS(qM)local ln,eK,eL=cp:getPlanetarySystem(0):castIntersections(cP,qM,function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)local lo=eK;if eL~=nil and eK~=nil then lo=math.min(eL,eK)end;if lo~=nil then return ln,lo else return nil,nil end end;local function qX(qY,qZ)if qZ then c0=0;iz:updateCommandFromActionStop(axisCommandId.vertical,qZ)if bE then iz:activateGroundEngineAltitudeStabilization(q_)df=true end else c0=c0+qY;iz:deactivateGroundEngineAltitudeStabilization()iz:updateCommandFromActionStart(axisCommandId.vertical,qY)end end;function pH.vertical(qY,qZ)qX(qY,qZ)end;function pH.ToggleAutopilot()local function r0(bA)c_=false;bt=not bt;if bt then b7=false;if not b8 and not bA then cu.ToggleAltitudeHold()end end;lr="Proceeding to Waypoint"end;local function r1(gp)if gp then for M,dM in pairs(cV)do if dM.name and dM.name==gp then return M end end else return 0 end end;local r2=false;if bR-pO<1.5 and ch then if not cH then if ch then bd=ks.spaceEngineMinAltitude-0.01*ks.noAtmosphericDensityAltitude;fL("11","EP")pO=-1;if b6 or bt or bC then return end else dj("No space engines detected, Orbital Hop not supported")return end elseif ks.hasAtmosphere then if ch then bd=ks.noAtmosphericDensityAltitude+V;fL("orH","OH")end;pO=-1;if b6 or bt or bC then return end end else pO=bR end;r3=false;if(bo>0 or#bI>0)and not b6 and not bt and not ce and not bC then if 0.5*d:maxForceForward()/b.getGravityIntensity()<ck then dj("WARNING: Heavy Loads may affect autopilot performance.")end;if#bI>0 and not cf then bo=r1(bI[1])ct.UpdateAutopilotTarget()dj("Route Autopilot in Progress")local qS=fX.position-cP;local r4=qS:project_on_plane(cN):len()if r4>50000 and fX.planetname==ks.name then r2=true end end;ct.UpdateAutopilotTarget()cu.showWayPoint(c9,bn)if fX~=nil then if fX.agg and not r and antigrav then if not cR then cu.ToggleAntigrav()end;by=fX.agg end;bw=nil;bA=fX.planetname=="Space"if bA then fL("apSpc","AP")if ch then ce=true;cu.ToggleAltitudeHold()else b6=true end elseif ks.name==fX.planetname then qW=true;if ch then if not bt then fL("vtt","AP")r0(bA)if r2 then bd=ks.noAtmosphericDensityAltitude+V end end else fL("apOn","AP")if not(c9.name==ks.name and cj<gg*1.5)then cF=false;b6=true elseif not ch then if bC then cu.ToggleIntoOrbit()end;cE=(ks.noAtmosphericDensityAltitude>0 and ks.noAtmosphericDensityAltitude or ks.surfaceMaxAltitude)+V;pT=true;q4.AutopilotAlign=true;q4.VectorToTarget=true;pR=false;if not bC then cu.ToggleIntoOrbit()end end end else fL("apP","AP")b4=false;b5=false;if ch then ce=true;cu.ToggleAltitudeHold()else b6=true end end elseif not ch then if fX==nil and(c9.name==ks.name and cZ)and not bC then r5=false;cF=false;pR=false;cE=(ks.noAtmosphericDensityAltitude>0 and ks.noAtmosphericDensityAltitude or ks.surfaceMaxAltitude)+V;pT=true;cu.ToggleIntoOrbit()else fL("apP","AP")b6=true;b4=false;b5=false;bf=false;c1=false;b8=false;b9=false;bb=false;ba=false;pY=false;bw=nil;r5=false end else fL("apP","AP")ce=true;cu.ToggleAltitudeHold()end;qj=false else fL("apOff","AP")cu.ResetAutopilots(1)if qj==2 then qj=true end end end;function pH.routeWP(r6,r7,r8)if r8 then if r8==1 then bI={}bI=iB(bI,bH)if#bI>0 then dj("Route Loaded")else dj("No Saved Route found on Databank")end;return bI else bH={}bH=iB(bH,bI)dj("Route Saved")pG()return end end;if r6 then return bI end;if r7 then bI={}dj("Current Route Cleared")else bI[#bI+1]=fX.name;dj("Added "..fX.name.." to route. ")end;return bI end;function pH.cmdThrottle(dN,r9)if iz:getAxisCommandType(0)~=axisCommandType.byThrottle and not r9 then d.control.cancelCurrentControlMasterMode()end;iz:setThrottleCommand(axisCommandId.longitudinal,dN)bS=dm(fM(dN*100,0)/100,-1,1)q6=nil end;function pH.cmdCruise(dN,r9)if iz:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r9 then d.control.cancelCurrentControlMasterMode()end;iz:setTargetSpeedCommand(axisCommandId.longitudinal,dN)q6=dN end;function pH.ToggleLockPitch()if bw==nil then fL("lkPOn","LP")if not c2 then bw=cT else bw=S end;ba=false;b8=false;b9=false else fL("lkPOff","LP")bw=nil end end;function pH.ToggleAltitudeHold()if bR-pN<1.5 then if ks.hasAtmosphere then if ch then bd=ks.spaceEngineMinAltitude-0.01*ks.noAtmosphericDensityAltitude;fL("11","EP")else if cZ then bd=ks.noAtmosphericDensityAltitude+V;cE=bd;pT=true;if not bC then cu.ToggleIntoOrbit()end;pR=true end end;pN=-1;if b8 or bC or bc then return end end else pN=bR end;if cZ and not ch and cg==-1 then cE=cj;pT=true;pR=true;cu.ToggleIntoOrbit()if bC then pN=bR else pN=0 end;return end;b8=not b8;b9=false;bb=false;if b8 then b6=false;b5=false;b4=false;c1=false;cA=true;bw=nil;cF=false;if cg~=-1 then if cM<20 then if bp then cw.landingGear()end;fL("lfs","LS")ba=true;if ch then bd=cj+Y else bd=ks.surfaceMaxAltitude+100 end;b3="ATO Hold"iz:setTargetGroundAltitude(Z)if b2 and cQ then cu.ToggleVerticalTakeoff()end end else fL("altOn","AH")ba=false;if pN>-1 then if cZ then bd=cj end end;if bc then cu.ToggleVerticalTakeoff()end end;if cR and not r then local ra=antigrav.getBaseAltitude()if bt and fX.agg and fX.agg>cj then bd=fX.agg elseif ba then bd=ra end;if e_(cj-ra)<100 and cM<20 then bd=ra;b3="AGG Hold"q8=0 end end;if ce then bd=200000 end else fL("altOff","AH")if bC then cu.ToggleIntoOrbit()end;if bc then cu.ToggleVerticalTakeoff()end;cA=q;ba=false;bt=false;pN=0 end end;function pH.ResetAutopilots(pH)if pH then ce=false;b6=false;bf=false;pY=false;bd=cj;r3=false;dc=false;bj="Aligning"end;bt=false;ba=false;bb=false;b5=false;b9=false;dd=nil;rb=false;cY=nil;dc=false;if not cR then b8=false;bw=nil end;if bc then cu.ToggleVerticalTakeoff()end;if bC then cu.ToggleIntoOrbit()end;cA=q;cd=false;cf=false;c0=0 end;function pH.BrakeToggle(rc)if not b3 then if rc then b3=rc else b3=true end else b3=false end;if b9 then b9=false;cA=q;dc=false end;if b3 then fL("bkOn","B",1)cu.ResetAutopilots()else fL("bkOff","B",1)end end;function pH.BeginReentry()if bb then dj("Re-Entry cancelled")fL("reOff","RE")bb=false;cA=q;b8=false elseif not ks.hasAtmosphere then dj("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c5=5 elseif not pZ then bb=true;if iz:getAxisCommandType(0)~=rd.cruise then d.control.cancelCurrentControlMasterMode()end;cA=true;b3=false;dj("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cC)fL("par","RE")else bb=true;b8=true;cA=true;b3=false;bd=ks.surfaceMaxAltitude+a0;if bd>ks.spaceEngineMinAltitude then bd=ks.spaceEngineMinAltitude-0.01*ks.noAtmosphericDensityAltitude end;local re=iD(bd)dj("Beginning Re-entry.  Target speed: "..cC.." Target Altitude: "..re)fL("glide","RE")q9=bO(cC)end;ba=false end;function pH.ToggleAntigrav()if antigrav and not r then if cR then fL("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if by==nil then by=cj end;if by<1000 then by=1000 end;fL("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pH.changeSpd(rf)local rg=1;if rf then rg=-1 end;if not c2 then if t and not p6 and pX then local rh=bS;bS=fM(dm(bS+rg*aF/100,-1,1),2)if bS>=0 and rh<0 then bS=0;pX=false end elseif p6 then if ch or bb then cC=dm(cC+rg*aF,0,W)elseif b6 then a1=dm(a1+rg*aF/3.6*100,0,dg-0.2)end else iz:updateCommandFromActionStart(axisCommandId.longitudinal,rg*aF/10)end else if b6 or bt or ce or bC then d2=d2+1*rg*-1;if d2>#cV then d2=1 end;if d2<1 then d2=#cV end else if not rf then rg=1 else rg=nil end;ct.adjustAutopilotTargetIndex(rg)end end end;function pH.TenthTick()local function ri()if not b6 then if fX==nil or fX.planetname~=ks.name then rj=(c9.center-cP):len()else rj=(fX.position-cP):len()end end;local kh=cM;local rk=c.getThrottle()/100;if t then rk=bS end;local rl,rm=cq.computeDistanceAndTime(cM,a1,ck,d:maxForceForward()*rk,a3,0)local c7,c8;if not b7 then c7,c8=cu.GetAutopilotBrakeDistanceAndTime(a1)else c7,c8=cu.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dR,rn;if not b7 and kh>0 then dR,rn=cu.GetAutopilotBrakeDistanceAndTime(kh)else dR,rn=cu.GetAutopilotTBBrakeDistanceAndTime(kh)end;local ro=0;local rp=0;if bh or not b6 and kh>5 then rp=cq.computeTravelTime(kh,0,rj)elseif c7+rl<rj then ro=rj-(c7+rl)rp=cq.computeTravelTime(a1,0,ro)else local rq=(rj-c7)/rl;rl=rj-c7;rm=rm*rq end;if fX~=nil and fX.planetname==ks.name and not b6 then return rp elseif bg then return rn elseif bh then return rp+rn else return rm+c8+rp end end;local function rr()local oa=b.getGravityIntensity()oa=fM(oa,5)if pW==nil or pW~=oa then local kh=cK:len()local rs=bQ.getMaxBrake()if rs~=nil and rs>0 and ch then rs=rs/dm(kh/100,0.1,1)rs=rs/ci;if ci>0.10 then bx=rs end end;if rs~=nil and rs>0 then bv=rs end;pW=oa end end;d4=bQ.getDockedConstructs()d3=bQ.getPlayersOnBoard()qn=0;for M=1,#d4 do qn=qn+bQ.getDockedConstructMass(d4[M])end;local rt=0;for M=1,#d3 do rt=rt+bQ.getBoardedPlayerMass(d3[M])end;if rt>20000 then qn=qn+rt-20000 end;cW,cX=qo()dg=bQ.getMaxSpeed()if bm~="None"and(c9 or fX)then lp=ri()end;rr()end;local ru=pid.new(10,0,10.0)local function rv(rw,rx)local oA=vec3()local ry=vec3()if rw==axisCommandId.longitudinal then oA=vec3(bQ.getOrientationForward())ry=cI elseif rw==axisCommandId.vertical then oA=vec3(bQ.getOrientationUp())ry=q5 elseif rw==axisCommandId.lateral then oA=vec3(bQ.getOrientationRight())ry=cJ else return vec3()end;local rz=vec3(b.getWorldGravity())local rA=rz:dot(ry)local rB=vec3(bQ.getWorldAirFrictionAcceleration())local rC=rB:dot(ry)local rD=cK:dot(oA)local rE=rx*constants.kph2m;ru:inject(rE-rD)local rF=ru:get()local rG=(rF-rC-rA)*ry;return rG end;local rH=pid.new(10,0,10.0)local function rI(rw,rx)local oA=vec3()local ry=vec3()if rw==axisCommandId.longitudinal then oA=vec3(bQ.getOrientationForward())ry=cI elseif rw==axisCommandId.vertical then oA=vec3(bQ.getOrientationUp())ry=q5 elseif rw==axisCommandId.lateral then oA=vec3(bQ.getOrientationRight())ry=cJ else return vec3()end;local rz=vec3(b.getWorldGravity())local rA=rz:dot(ry)local rB=vec3(bQ.getWorldAirFrictionAcceleration())local rC=rB:dot(ry)local rD=cK:dot(oA)local rE=rx*constants.kph2m;rH:inject(rE-rD)local rF=rH:get()local rG=(rF-rC-rA)*ry;return rG end;local function rJ(rK,jW,fT)local rL=rK:cross(fT):normalize_inplace()local kJ=math.acos(dm(rL:dot(-jW),-1,1))*constants.rad2deg;if rL:cross(-jW):dot(fT)<0 then kJ=-kJ end;return kJ end;local function rM()if d0 and not b9 then local et=d0[1]local hW,hX=d0[2],d0[3]local rN=math.min(hW,hX or hW)local rO=rN/cM;local rP=ba and(cM<42 or cg~=-1)local rQ=b8 or bt or bw or b6;if rQ and not rP and(c7*1.5>rN or rO<1)then b3="Collision"bI={}q8=0;if b8 then cu.ToggleAltitudeHold()end;if bw then cu.ToggleLockPitch()end;dj("Autopilot Cancelled due to possible collision")a.print(et.name.." COLLISION "..iE(rO).." / "..iD(rN,2))cu.ResetAutopilots(1)qW=true;if ch then b9=true end;cA=true end;if rO<11 then c_=et.name.." COLLISION "..iE(rO).." / "..iD(rN,2)else c_=et.name.." collision "..iE(rO)end;if rO<6 then fL("alarm","AL",2)end else c_=false end end;local rR=1;local rS=0;local rT=1;local rU=1;local rV=1;local rW=false;local rX=pid.new(0.1,0,1*0.1)local rY=pid.new(1*0.01,0,5*0.1)local rZ=pid.new(aJ*0.01,0,aJ*0.1)local r_=pid.new(2*0.01,0,2*0.1)local rY=pid.new(1*0.01,0,5*0.1)local s0=pid.new(2*0.01,0,2*0.1)local s1=pid.new(2*0.01,0,2*0.1)local s2=pid.new(2*0.01,0,2*0.1)local s3=pid.new(2*0.01,0,2*0.1)local s4=pid.new(0.1,0,1)local s5=pid.new(1*0.01,0,1*0.1)function pH.onFlush()if antigrav and not r and not cR and antigrav.getBaseAltitude()~=by then qi=by end;if df then d:setEngineForceCommand('hover',vec3(),1)df=false end;cS=iz:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local s6=dm(bY+p_+a.getControlDeviceForwardInput(),-1,1)local s7=dm(bZ+q1+a.getControlDeviceYawInput(),-1,1)local s8=dm(b_+q0-a.getControlDeviceLeftRightInput(),-1,1)local s9=b3 and 1 or 0;if ch then cN=vec3(b.getWorldVertical())if cN==nil or cN:len()==0 then cN=(ks.center-cP):normalize()end else cN=(ks.center-cP):normalize()end;q5=vec3(bQ.getWorldOrientationUp())cI=vec3(bQ.getWorldOrientationForward())cJ=vec3(bQ.getWorldOrientationRight())cL=vec3(bQ.getWorldVelocity())cK=vec3(bQ.getVelocity())cP=vec3(bQ.getWorldPosition())ck=bQ.getMass()+qn;cM=vec3(cL):len()cO=-cN:dot(cL)cU=getRoll(cN,cI,cJ)local sa=cU/180*math.pi;local sb=math.cos(sa)local sc=math.sin(sa)cT=rJ(cN,cI,cJ*sb+q5*sc)local sd=cL:normalize()local se=e_(cU)local sf=utils.sign(cU)local sg=vec3(bQ.getWorldAngularVelocity())local sh=s6*aP*cJ+s7*aK*cI+s8*aQ*q5;if cA==true and cN:len()>0.01 then local si=e_(q2-cU)if((b5 or bb or b9 or cd or b8 or bC)and si>0 or ch and si<aL and q)and s7==0 and e_(cT)<85 then local sj=q2;if not ch then q2=0;sj=0 end;rZ:inject(sj-cU)local sk=rZ:get()sh=sh+sk*cI end end;bT=0;ci=bP()ch=false or cj<ks.noAtmosphericDensityAltitude and ci>0.00001;cj=(cP-ks.center):len()-ks.radius;cg=qz()bR=bN()pM=bR;if bp and cg>-1 and cg-3<_ then if iz.targetGroundAltitudeActivated then iz:deactivateGroundEngineAltitudeStabilization()end;iz:updateCommandFromActionStart(axisCommandId.vertical,-1)end;if cv then ql=not ql;if ql then cv.UpdateRadar()end;if E then rM()end end;if antigrav then cR=antigrav.isActive()==1 end;local sl=bR-pM;local sm=-math.deg(qt(q5,cL,cI))local sn=math.deg(qt(cJ,cL,cI))local gi=cN*-1;cB=ch and sm<-N or sm>N or sn<-O or sn>O;local so=a.getMouseDeltaX()local sp=a.getMouseDeltaY()if qm then local sq=bN()-qm;so=so*sq/0.016;sp=sp*sq/0.016 end;qm=bN()if p and not c2 then sp=-sp end;q0=0;q1=0;p_=0;local sr=bQ.getWorldPosition()ks=fP:closestBody(sr)ss=cr(ks)fl=ss:orbitalParameters(sr,cL)cZ=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;local oa=ks:getGravity(sr):len()*ck;q2=0;local st=bQ.getMaxThrustAlongAxis("ground",bQ.getOrientationUp())[1]if qc==0 then if iy()==1 and c2 then if not cy then ca=dm(ca+so/2,-ad/2,ad/2)cb=dm(cb+sp/2,-ae/2,ae/2)end else ca=0;cb=0 end else ca=dm(ca+so/2,-ad/2,ad/2)cb=dm(cb+sp/2,-ae/2,ae/2)de=dp(ca*ca+cb*cb)if not c2 and iy()==0 then local kS,kT=1,1;if bL=="SCOPE"then kS,kT=d6/90,d6/90 end;if g=="virtual joystick"then if de>aA then q0=q0-dm(e_(ca)-aA,0,ad/2)*utils.sign(ca)*aH*kS;p_=p_-dm(e_(cb)-aA,0,ae/2)*utils.sign(cb)*aI*kT end else ca=0;cb=0;if g=="mouse"then p_=(-utils.smoothstep(sp,-100,100)+0.5)*2*rU;q0=(-utils.smoothstep(so,-100,100)+0.5)*2*rV end end end end;local su=cM>27777;if cM>X/3.6 and not ch and not b6 and not su then dj("Space Speed Engine Shutoff reached")q8=0 end;if not su and sv then if not b3 then cu.BrakeToggle()end;if b6 then cu.ResetAutopilots(1)end;q8=0 end;sv=su;if ci>0.09 then if cM>cC/3.6 and not t and not pI then b3="SpdLmt"pI=true elseif not t and pI then if cM<cC/3.6 then b3=false;pI=false end end end;if b5 then if cd then b3=false;local sw=false;sw=qL(fX.position-cP,0.1)cA=true;if sw then q9=bO(cC)if(e_(cU)<2 or e_(cT)>85)and cM>=cC/3.6-1 then b3=false;b5=false;if cd~=2 then pZ=true end;if cd==true then cf=true end;cd=false;b6=false;cu.BeginReentry()end elseif ch and t then q8=1 end elseif cM>iS then qL(vec3(cL),0.01)end end;if b4 then if ch then b4=false elseif cM>iS then qL(-vec3(cL))end end;if not b5 and cd and not bC then if not ch then if cd~=2 then pZ=true end;cu.BeginReentry()cd=false;cf=true else cd=false;if not qj then qj=true end end end;if cf and fX and(cj<bd+250 and cj>bd-250)and e_(cO)<25 and ci>=0.1 and(fX.position-cP):len()>2000+cj then if not qj then qj=true end;cf=false end;if bc then cA=true;local sx=bd;if cO<-30 then dj("Unable to achieve lift. Safety Landing.")c0=0;cA=q;bc=false;b9=true elseif not r and cR or bd<ks.spaceEngineMinAltitude then if cR then sx=antigrav.getBaseAltitude()end;if cj<sx-100 then q3=0;c0=15;b3=false elseif cO>0 then b3="VTO Limit"c0=0 elseif cO<-30 then b3="VTO Fall"c0=15 elseif cj>=sx then if cR then if b6 or bt then cu.ToggleVerticalTakeoff()else b3="VTO Complete"bc=false end;dj("Takeoff complete. Singularity engaged")fL("aggLk","AG")else b3=false;dj("VTO complete. Engaging Horizontal Flight")fL("vtoc","VT")cu.ToggleVerticalTakeoff()end;c0=0 end else if ci>0.08 then q3=0;b3=false;c0=20 elseif ci<0.08 and ch then b3=false;if cG then q3=0;c0=20 else c0=0;q3=36;q9=3500 end else cA=q;bC=true;cF=false;sy=false;pR=false;pP=nil;pQ=nil;if pU==nil then pU=ks end;cE=sx;pT=true;bc=false end end;if q3~=nil then local sz=dm(q3-cT,-O*0.80,O*0.80)r_:inject(sz)local sA=dm(r_:get(),-1,1)p_=sA end end;if bC then local function sB()if not fl.apoapsis or not fl.periapsis then return false end;if fl.periapsis.altitude>=cE*0.99 and fl.apoapsis.altitude>=cE*0.99 and fl.periapsis.altitude<fl.apoapsis.altitude and fl.periapsis.altitude*1.05>=fl.apoapsis.altitude and e_(cE-cj)<1000 then return true else return false end end;local qS;local sC=false;local sD=iD(cE,4)if pU==nil then pU=ks;if bt then pU=c9 end end;if not pT then cE=bO(pU.radius+pU.surfaceMaxAltitude+V)if pU.hasAtmosphere then cE=bO(pU.radius+pU.noAtmosphericDensityAltitude+V)end;pT=true end;if q4.VectorToTarget and fX then qS=fX.position-cP end;local sE,sF=cr(pU):escapeAndOrbitalSpeed((cP-pU.center):len()-pU.radius)sF=sF*3.6+1+(K and a_*sF*3.6 or 0)local sG=cU;if not pR then local sH=false;local sI=false;q8=0;pQ=0;cD="Aligning to orbital path - OrbitHeight: "..sD;if q4.VectorToTarget then qL(qS:normalize():project_on_plane(cN))sC=cI:dot(qS:project_on_plane(q5):normalize())>0.95 else qL(cL)sC=sm<0.5;if cM<150 then sC=true end end;p_=0;pP=0;if cT<=pP+2 and cT>=pP-2 then sH=true else sH=false end;if sG<=pQ+2 and sG>=pQ-2 then sI=true else sI=false end;if sH and sI and sC then pP=nil;pQ=nil;pR=true end else if q4.VectorToTarget then qL(qS:normalize():project_on_plane(cN))elseif cM>150 then qL(cL)end;p_=0;if q4.VectorToTarget and fX then local c7,dR=cq.computeDistanceAndTime(cM,cC/3.6,ck,0,0,bv)if cF and qS:len()>15000+c7+cj then cD="Orbiting to Target"if cj-100<=pU.noAtmosphericDensityAltitude or lp>fl.timeToPeriapsis and fl.periapsis.altitude<pU.noAtmosphericDensityAltitude or not sB()and fl.eccentricity>0.1 then dj("Re-Aligning Orbit")cF=false end elseif cF or qS:len()<15000+c7+cj then dj("Orbit complete, proceeding with reentry")fL("orCom","OB")bn=fX.position;pZ=true;cf=true;q4.VectorToTarget,q4.AutopilotAlign=false,false;cu.ToggleIntoOrbit()cu.BeginReentry()return end end;if pS or fl.periapsis~=nil and fl.apoapsis~=nil and fl.eccentricity<1 and cj>cE*0.9 and cj<cE*1.4 then if fl.apoapsis~=nil or pS then if(sB()or cF)and not K then if cF then b3=false;q8=0;pP=0;if not q4.VectorToTarget then dj("Orbit complete")fL("orCom","OB")cu.ToggleIntoOrbit()end else pV=pV+1;if pV>=2 then cF=true end end else if sB()then cD="Maintaining "else cD="Adjusting "pS=true;q9=sF;local sJ=cE-cj;rX:inject(sJ-cO*dm(utils.smoothstep(2000-sJ,-2000,2000)^6*10,1,10))pP=dm(rX:get(),-75,75)end;cD=cD.." - OrbitHeight: "..sD end end else local sK=2.75;local sL=e_(fM(sE*sK))local on=sL%50;if on>0 then sL=sL-on+50 end;b3=false;if cj<cE*0.8 then cD="Escaping planet gravity - OrbitHeight: "..sD;pP=utils.map(cO,200,0,-15,80)elseif cj>=cE*0.8 and cj<cE*1.15 then cD="Approaching orbital corridor - OrbitHeight: "..sD;sL=sL*0.75;pP=utils.map(cO,100,-100,-15,65)elseif cj>=cE*1.15 and cj<cE*1.5 then cD="Approaching orbital corridor - OrbitHeight: "..sD;sL=sL*0.75;if cO<0 or pS then pP=utils.map(cj,cE*1.5,cE*1.01,-30,0)else pP=utils.map(cj,cE*0.99,cE*1.5,0,30)end elseif cj>cE*1.5 then cD="Reentering orbital corridor - OrbitHeight: "..sD;pP=-65;local sM=utils.map(cO,-150,-400,1,0.55)sL=sL*sM end;q9=bO(sL)end end;if pP~=nil then local sN=pP-cT;rY:inject(sN)local sO=dm(rY:get(),-0.5,0.5)p_=sO end end;if b6 and not ch and not cd then local function sP(sQ,fl)a.print(sQ)b5=false;b3=false;bg=false;b6=false;r3=false;bj="Aligning"q8=0;pY=false;dj(sQ)fL("apCom","AP")if fl or cd then if fl and gg~=nil and not cd then if not cj or cj==0 then return end;cE=cj;pT=true end;cu.ToggleIntoOrbit()end end;local sR,sS=bn,false;if fX and fX.planetname~="Space"then bf=true;if not r3 then local sT=(fX.position-c9.center):normalize()local sU=sT:project_on_plane((c9.center-cP):normalize()):normalize()local sV=c9.center+sU*(c9.radius+gg)local sW=fX.position+(fX.position-c9.center):normalize()*(gg-c9:getAltitude(fX.position))if(cP-sV):len()<(cP-sW):len()then sR=sV else sR=sW;bi=0 end;bn=sR;cu.showWayPoint(c9,bn)sS=true;r3=true end;bk=0 elseif fX and fX.planetname=="Space"then if not r3 then bk=0;sS=true;bf=true;r3=true;sR=fX.position+(cP-fX.position):normalize()*T;bn=sR end elseif fX==nil then bk=0;if not r3 then local sT=(cP+cL*100000-c9.center):normalize()local sU=sT:project_on_plane((c9.center-cP):normalize()):normalize()if sU:len()<1 then sT=(cP+cI*100000-c9.center):normalize()sU=sT:project_on_plane((c9.center-cP):normalize()):normalize()end;sR=c9.center+sU*(c9.radius+gg)bn=sR;r3=true;sS=true;bf=true;cu.showWayPoint(c9,bn)end end;rj=(vec3(sR)-cP):len()local ln,eK,eL=cp:getPlanetarySystem(0):castIntersections(cP,cL:normalize(),function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)local lo=eK;if eL~=nil and eK~=nil then lo=math.min(eL,eK)end;if lo~=nil and lo<rj and ln.name==c9.name then rj=lo end;local sw=true;local sX=(c9.center-(cP+vec3(cL):normalize()*rj)):len()-c9.radius;local lk=iD(sX)qg=g8;qh='{"label": "Projected Altitude", "value": "'..lk..'"}'if cM>50 and be then local qS=vec3(sR)-cP;local sY=dm(math.deg(qt(q5,cL:normalize(),qS:normalize()))*cM/500,-90,90)local sZ=dm(math.deg(qt(cJ,cL:normalize(),qS:normalize()))*cM/500,-90,90)if e_(sY)<20 and e_(sZ)<20 then sY=sY*2;sZ=sZ*2 end;if e_(sY)<2 and e_(sZ)<2 then sY=sY*2;sZ=sZ*2 end;local sm=-math.deg(qt(q5,cI,cL:normalize()))local sn=-math.deg(qt(cJ,cI,cL:normalize()))s0:inject(sZ-sn)local s_=dm(s0:get(),-1,1)p_=p_+s_;s1:inject(sY-sm)local t0=dm(s1:get(),-1,1)q0=q0+t0;sS=true;if e_(sY)>2 or e_(sZ)>2 then if bj~="Adjusting Trajectory"then bj="Adjusting Trajectory"fL("apAdj","AP")end else if bj~="Accelerating"then bj="Accelerating"fL("apAcc","AP")end end elseif be and cM<=50 then qL((sR-cP):normalize())end;if sX<gg*1.5 then bi=cC/3.6;if fX==nil then dR,bi=cr(c9):escapeAndOrbitalSpeed(sX)end end;local c7,c8;if not b7 then c7,c8=qp(cM)else c7,c8=qs(cM)end;if b6 and not be and not bh and not bg then local ln,lo=cu.checkLOS((bn-cP):normalize())if c9.name~=ks.name then if ln~=nil and c9.name~=ln.name and lo<rj then c_="Attempting to clear LOS between "..ln.name.." and waypoint."qd=true else qd=false;c_=false end end end;if not qd then if not bh and not bg and not sS then sw=qL((sR-cP):normalize())elseif b7 and(bg or bh)then sw=qL(-vec3(cL):normalize())end end;if be then if not pY then b3=false;q8=a2;bS=fM(a2,2)pY=true end;local rk=c.getThrottle()if t then rk=bS end;local t1=99999;local ol=-vec3(bQ.getWorldAcceleration()):dot(cL:normalize())local t2=dm(cL:dot((sR-cP):normalize()),0,cM)if t2>0 or ol>0 then t1=cq.computeTravelTime(t2,ol,rj-c7)end;if a1>dg then a1=dg-0.2 end;if cK:len()>=a1 or rk==0 and pY or a3/4>t1 then be=false;if bj~="Cruising"then fL("apCru","AP")bj="Cruising"end;bh=true;q8=0 end;local t3=rj;if t3<=c7 or H and cX<=c7+10000 and cW then if H and cX<=c7+10000 and cW and not su then if cX<pJ and cX>2000 then cu.ResetAutopilots(1)dj("Autopilot cancelled to prevent crossing PvP Line")b3="PvP Prevent"pJ=cX else pJ=cX;return end end;be=false;if bj~="Braking"then fL("apBrk","AP")bj="Braking"end;bg=true;if not b7 then b5=true;cA=true end;q8=0;pY=false end elseif bg then if bj~="Orbiting to Target"then b3="AP Brk"end;if b7 then q8=1;qa=true end;local dR,sF=cr(c9):escapeAndOrbitalSpeed((cP-ks.center):len()-ks.radius)local qS;if fX then qS=fX.position-cP end;if fX and fX.planetname=="Space"and cM<50 then if#bI>0 then if not qj then table.remove(bI,1)end;if#bI>0 then b3=false;if not qj then qj=2 end;return end end;sP("Autopilot complete, arrived at space location")b3="Space Arrival"elseif fX and fX.planetname~="Space"and cM<=sF and(fl.apoapsis==nil or fl.periapsis==nil or fl.apoapsis.altitude<=0 or fl.periapsis.altitude<=0)then sP("Autopilot complete, commencing reentry")bn=fX.position;cd=true;cu.showWayPoint(c9,bn)elseif(fX and fX.planetname~="Space"or fX==nil)and fl.periapsis~=nil and fl.periapsis.altitude>0 and fl.eccentricity<1 or bj=="Circularizing"then if bj~="Circularizing"then fL("apCir","AP")bj="Circularizing"end;if cM<=sF then if fX then if cL:normalize():dot(qS:normalize())>0.4 then if bj~="Orbiting to Target"then fL("apOrb","OB")bj="Orbiting to Target"end;if not r5 then b3=false;cu.showWayPoint(c9,fX.position)r5=true end else sP("Autopilot complete, proceeding with reentry")bn=fX.position;cd=true;cu.showWayPoint(c9,fX.position)r5=false end else sP("Autopilot completed, setting orbit",true)b3=false end end elseif bj=="Circularizing"then sP("Autopilot complete, fixing Orbit",true)end elseif bh then local t3=rj;if t3<=c7 or H and cX<=c7+10000 and cW then if H and cX<=c7+10000 and cW then if cX<pJ and cX>2000 then if not qj then qj=true end;dj("Autopilot cancelled to prevent crossing PvP Line")b3="Prevent PvP"pJ=cX else pJ=cX;return end end;be=false;if bj~="Braking"then fL("apBrk","AP")bj="Braking"end;bg=true;if not b7 then b5=true;cA=true end end;local rk=c.getThrottle()if t then rk=bS end;if rk>0 then be=true;if bj~="Accelerating"then bj="Accelerating"fL("apAcc","AP")end;bh=false end else if sw then if not bf and fX==nil or not bf and fX and fX.planetname~="Space"then if not cd then bn=vec3(c9.center)+(gg+c9.radius)*cJ;t4=q5;t5=cJ end;bf=true elseif sw and not qd then be=true;if bj~="Accelerating"then bj="Accelerating"fL("apAcc","AP")end;if not pY then q8=a2;qa=true;bS=fM(a2,2)pY=true;b3=false end end end end elseif b6 and(fX~=nil and fX.planetname~="Space"and ch)then dj("Autopilot complete, starting reentry")fL("apCom","AP")bn=fX.position;b3=false;bg=false;b6=false;r3=false;bj="Aligning"q8=0;pY=false;b5=true;cd=true;cu.showWayPoint(c9,fX.position)end;if c1 then cA=true;local sZ=0;local fn=vec3(DUPlayer.getWorldPosition())local t6=fn-cP;local t7=vec3(t6):project_on(cI):len()local t8=vec3(t6):project_on(cJ):len()local cc=dp(t7*t7+t8*t8)qL(t6:normalize())local mw=40;local t9=cc<mw;local ta=100;local rx=dm((cc-mw)/2,10,ta)p_=0;local sw=e_(q0)<0.1;if sw and cM<rx and not t9 then b3=false;sZ=-20 else b3="Follow"sZ=0 end;local tb=0;if e_(sZ-cT)>tb then s2:inject(sZ-cT)local s_=s2:get()p_=s_ end end;if b8 or b9 or bb or bt or bw~=nil then local tc=bx;if tc then tc=tc*dm(cM/100,0.1,1)*ci else tc=bv end;if not ch then tc=bv end;q7=cI:project_on_plane(cN):normalize():dot(cL)if q7>100 then c7,c8=cq.computeDistanceAndTime(q7,100,ck,0,0,tc)local td,dR=cq.computeDistanceAndTime(100,0,ck,0,0,tc*0.55)c7=c7+td else c7,c8=cq.computeDistanceAndTime(q7,0,ck,0,0,tc*0.55)end;local sJ=bd-cj-cO;local te=200+cM;if bb or cd then tf=2000+cM end;local tg=1;if ba then tg=dm(cM/100,0.1,1)end;local sZ=(utils.smoothstep(sJ,-te,te)-0.5)*2*Q*tg;if not bb and not cd and not bt and cI:dot(cL:normalize())<0.99 then sZ=(utils.smoothstep(sJ,-te*dm(20-19*ci*10,1,20),te*dm(20-19*ci*10,1,20))-0.5)*2*Q*dm(2-ci*10,1,2)*tg end;if not b8 then sZ=0 end;if bw~=nil then if cZ and not bC then sZ=bw else bw=nil end end;cA=true;local th=p_;if bb then local ti=bO(cC)local tj,tk=cq.computeDistanceAndTime(cM,ti/3.6,ck,0,0,bv-ks.gravity*9.8*ck)tj=tj==-1 and 5000 or tj;local r4=cj-(ks.noAtmosphericDensityAltitude+tj)local tl=cj>ks.noAtmosphericDensityAltitude+tj*1.35;if tl then sZ=R;if cM<=ti/3.6 and cM>ti/3.6-10 and e_(cL:normalize():dot(cI))>0.9 and not cS then bW=false;q8=1 end elseif(cS or iz:getTargetSpeed(axisCommandId.longitudinal)~=ti)and not tl and not ch then q9=ti;qa=true end;if cS then if cM>ti/3.6 and not tl then b3="Reentry Limit"if bS>0 then q8=0 end else b3=false end else b3=false end;if cO>0 then b3="Reentry vSpd"end;if not pZ then sZ=-80;if cj<ks.surfaceMaxAltitude+(ks.atmosphereThickness-ks.surfaceMaxAltitude)*0.25 then dj("PARACHUTE DEPLOYED at "..fM(cj,0))bb=false;b9=true;qW=true;q8=0;sZ=0;cA=q end elseif ks.noAtmosphericDensityAltitude>0 and tl then cA=true elseif not tl then if not ch and(cS or iz:getTargetSpeed(axisCommandId.longitudinal)~=ti)then q9=ti end;if cM<ti/3.6+1 then b3=false;pZ=false;bb=false;cA=true;q8=1 end end end;if cM>iS and not ce and not bt and not b9 and u then qL(vec3(cL))end;if cY or(bt or ce)and bo>0 and ch then local qS;if cY then if type(cY)=="table"then qS=cY elseif cY<3 and cY>0 then qS=-cN:cross(cL)*5000 elseif cY>=3 then qS=cN:cross(cL)*5000 elseif cY<0 then qS=cL*25000 end elseif fX~=nil then qS=fX.position-cP else qS=c9.center-cP end;local sY=math.deg(qt(cN:normalize(),cL,qS))*2;local mz=math.rad(e_(cU))if cM>aM and ch then local tm=1000+cM;local tn=(utils.smoothstep(sJ-cO*10,-tm,tm)-0.5)*2*Q;local to=dm(90-tn,0,180)q2=dm(sY*2,-to,to)local tp=sY;sY=dm(dm(sY,-N*0.80,N*0.80)*math.cos(mz)+4*(cT-sZ)*math.sin(math.rad(cU)),-N*0.80,N*0.80)local tq=1;if q2~=0 then tq=e_(mz/q2)end;tq=(90-dm(e_(q2-cU),0,90))/90;local tr=sZ;if e_(cU)>90 then tr=-tr end;sZ=tq*dm(dm(tr*math.cos(mz),-O*0.8,O*0.8)+e_(dm(e_(tp)*math.sin(mz),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q2=0;sY=dm(sY,-N*0.80,N*0.80)end;local ts=sm-sY;if cY and e_(ts)<=0.0001 and(type(cY)=="table"or type(cY)~="table"and cY<0 and e_(cU)<1)then if cY==-2 then cu.ToggleAltitudeHold()end;cY=nil;fL("180Off","BR")return end;if not cB and cM>aM and ch then s3:inject(ts)local t0=dm(s3:get(),-1,1)q0=q0+t0 elseif ch and cg>-1 or cM<aM then qL(qS)elseif cB and ch then if(sm<-N or sm>N)and ch then qL(cL)end;if(sn<-O or sn>O)and ch then sZ=dm(cT-sn,cT-O*0.80,cT+O*0.80)end end;if fX~=nil and not ce then local sx=ks:getAltitude(fX.position)local r4=qS:project_on_plane(cN):len()qW=true;if bd<ks.noAtmosphericDensityAltitude and not ce and not ba and not bb and(r4<=c7 and qS:len()<ks.radius)and(cL:project_on_plane(cN):normalize():dot(qS:project_on_plane(cN):normalize())>0.99 or lr=="Finalizing Approach")then lr="Finalizing Approach"if#bI>0 then if not qj then table.remove(bI,1)end;if#bI>0 then if not qj then qj=2 end;return end end;q8=0;if b8 then cu.ToggleAltitudeHold()bt=true end;b3="AP Finalizing"elseif not ba then b3=false end;if lr=="Finalizing Approach"and(q7<0.1 or r4<0.1 or tt~=nil and tt<r4)then fL("bklOn","BL")b9=true;dc=true;if fX.heading then dd=fX.heading else dd=nil end;bt=false;lr="Proceeding to Waypoint"c_=false end;tt=r4 end elseif bt and not ch and bd>ks.noAtmosphericDensityAltitude and not(ce or bb)then if fX~=nil and c9.name==ks.name then local qS=fX.position-cP;local sx=ks:getAltitude(fX.position)local r4=dp(qS:len()^2-(cj-sx)^2)local tc=bx;if tc then c7,c8=cq.computeDistanceAndTime(cM,0,ck,0,0,tc/2)qW=true;if r4<=c7+cM*sl/2 and cL:project_on_plane(cN):normalize():dot(qS:project_on_plane(cN):normalize())>0.99 then if ks.hasAtmosphere then b3=false;b5=false;pZ=true;cd=false;cf=true;b6=false;cu.BeginReentry()end end;tt=r4 end end end;if not ch and cg==-1 and(b8 and bd>ks.noAtmosphericDensityAltitude)and not(ce or bC or bb)then if not cF and not bC then cE=bd;pT=true;if bt then q4.VectorToTarget=true end;cu.ToggleIntoOrbit()bt=false;pR=true end end;if cB and ch and cg==-1 and cM>aM and lr~="Finalizing Approach"then qL(cL)sZ=dm(cT-sn,cT-O*0.80,cT+O*0.80)end;p_=th;local qE=-1;if b9 then local tu=aZ or 0.05;if not qe then rW=false;if not cS then q8=0 end;if cg==-1 then iz:setTargetGroundAltitude(500)iz:activateGroundEngineAltitudeStabilization(500)end;if not ch then rW=true end;qe=true end;sZ=0;local tv=false;local tw=math.abs(q7)if not r and cR then tv=antigrav.getBaseAltitude()if tv<ks.surfaceMaxAltitude and fX==nil or fX~=nil and ks:getAltitude(fX.position)>tv then tv=false end else tv=false end;if dd then if tw<tu then if cO>-P then b3=false else b3="BL Align BLR"end;if qL(dd,0.001)then dd=nil;cA=q else p_=0;cA=true end else b3="BL Align Hzn"end;if tv and e_(cj-tv)<250 then b3="AGG Align"end else local tx=false;local ty=30;if tw<10 and st~=nil and st>0 then local tz=dm(ci,0.4,2)local tc=bx*dm(cM/100,0.1,1)*tz;local tA=st*tz+tc-oa;local tB=tc/2-oa;local tC=cM-dp(e_(tB/2)*20/(0.5*ck))*utils.sign(tB)if tC<0 then tC=0 end;local tD;if cM>100 then local tE,dR=cq.computeDistanceAndTime(cM,100,ck,0,0,tc)local tF,dR=cq.computeDistanceAndTime(100,0,ck,0,0,dp(tc))tD=tE+tF else tD=cq.computeDistanceAndTime(cM,0,ck,0,0,dp(tc))end;if tD<20 then b3=false else local tG=0;if tC>100 then local tH,dR=cq.computeDistanceAndTime(tC,100,ck,0,0,tA)local tI,dR=cq.computeDistanceAndTime(100,0,ck,0,0,st*tz+dp(tc)-oa)tG=tH+tI else tG,dR=cq.computeDistanceAndTime(tC,0,ck,0,0,st*tz+dp(tc)-oa)end;tG=(tG+15+cM*sl)*1.1;local tJ=dc and fX~=nil and ks:getAltitude(fX.position)>0 and fX.safe;local sx=nil;if tv and tv<cj then sx=tv elseif tJ then sx=ks:getAltitude(fX.position)+250 elseif cj>ks.surfaceMaxAltitude then sx=ks.surfaceMaxAltitude end;if d0 then local tK=ks:getAltitude(d0[1].center)if sx then if tK>sx then sx=tK end else sx=tK end end;if sx~=nil then local tL=cj-sx;tx=true;if tL<=tG or tG==-1 or tw>tu and dc then if sx==ks.surfaceMaxAltitude and cO<-P then b3="BL Stop BLR"elseif tw>tu and dc then b3="BL AP Hzn"else b3="BL Stop Dist"end else b3=false end end end end;qE=cg;if qE>-1 then b3=false;if not tv and not bp then qb=true;iz:setTargetGroundAltitude(_)end;if(cM<1 or cL:normalize():dot(cN)<0)and not dd and qE-3<_ and(bE or cM==0)then b9=false;b8=false;c0=0;qX(0,1)b3="BL Complete"cA=q;dc=false;qe=false else if cO<-5 or tw>tu*10 then qX(0,1)b3="BL Slowing"else b3=false;qX(-1)end end elseif not tx then if qW and cL:normalize():dot(-gi)<0.999 then b3="BL Strong"qL()elseif tw>10 or tw>tu and dc then b3="BL hSpd"elseif cO<-P then b3="BL BLR"qX(0,1)else qX(-1)b3=false end end end else qe=false end;if ba or ce then local ln,eL,eK;if bn~=nil then ln,eL,eK=cp:getPlanetarySystem(0):castIntersections(cP,(bn-cP):normalize(),function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)end;if ln~=nil then if ln.name~=c9.name and not ch then c_="Clearing LOS between "..ln.name.." and waypoint."end end;if cR and not ce then if cj>=bd-50 and cM>iS then ba=false;if not b6 and not bt then b3="ATO Agg Arrive"q8=0 end end elseif e_(sZ)<15 and cj/bd>0.75 then ba=false;if not ce then if cS and not t then d.control.cancelCurrentControlMasterMode()end elseif ce and cM<iS then b6=true;ce=false;b8=false;ba=false;q8=0 elseif ce then q8=0;b3="ATO Space"end elseif ce and not ch and c9~=nil and(ln==nil or ln.name==c9.name)then b6=true;c_=false;ce=false;b8=false;ba=false;if not cS then q8=0 end;be=true end end;local tM=cg>-1;local tN=cT;if(bt or ce or cY)and not tM and cM>aM and ch then local mz=math.rad(e_(cU))tN=cT*e_(math.cos(mz))+sn*math.sin(mz)end;local tO=dm(sZ-tN,-O*0.80,O*0.80)if not ch and bt then tO=dm(sZ-tN,-85,Q)elseif not ch then tO=dm(sZ-tN,-Q,Q)end;if e_(cU)<5 or bt or cY or b9 or tM or b8 then s2:inject(tO)local s_=s2:get()p_=p_+s_ end end;if antigrav~=nil and(antigrav and not r and cj<200000)then if by==nil or by<1000 then by=1000 end;if tP~=by then tP=by;qi=tP end end;if(ch or bb or cf)and t and cS then local tQ=0;if aV>0 and not bb and ci>0.005 and ci<0.1 and cO>-50 then local tR=bQ.getFrictionBurnSpeed()*aV;local tS=cC/3.6;if tR>tS then tQ=tR-tS-1 end end;s4:inject(cC/3.6+tQ-cL:dot(cI))local tT=s4:get()bV=dm(tT,-1,1)if not d8 then if bV<bS and(ci>0.005 or bb or cf)then bU=true;d8=dm(bV,0.01,1)else bU=false;d8=bS end end;s5:inject(cL:len()-cC/3.6-tQ)local tU=dm(s5:get(),0,1)if ch and cO<-80 or(ci>0.005 or bb or cf)then bT=tU end;if bT>0 then if bU and bV==0.01 and not d8 then d8=0 end else bV=dm(bV,0.01,1)end;local tV=''local tW=vec3()local tX=rv(axisCommandId.vertical,c0*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tX,rS)local tY='thrust analog longitudinal 'if bF=="All"or bF=="Longitude"then tY=tY..aW end;local tZ=iz:getAxisCommandType(axisCommandId.longitudinal)local t_=iz:composeAxisAccelerationFromThrottle(tY,axisCommandId.longitudinal)local u0=rI(axisCommandId.lateral,bB*1000)tV=tV..' , '.."lateral airfoil , lateral ground "tW=tW+u0;if tW:len()>constants.epsilon then d:setEngineForceCommand(tV,tW,rS,'','','',rT)end;d:setEngineForceCommand(tY,t_,rR)local u1='thrust analog vertical fueled 'local u2='thrust analog lateral fueled 'if bF=="All"or bF=="Lateral"then u2=u2 ..aX end;if bF=="All"or bF=="Vertical"then u1=u1 ..aY end;if c0~=0 or b9 and b3 or not bp and not bE then d:setEngineForceCommand(u1,tX,rR)else d:setEngineForceCommand(u1,vec3(),rR)end;if bB~=0 then d:setEngineForceCommand(u2,u0,rR)else d:setEngineForceCommand(u2,vec3(),rR)end;if s9==0 then s9=bT end;local u3=-s9*(aR*cL+aS*sd)d:setEngineForceCommand('brake',u3)else if t then if not d8 then d8=bS end end;local rx=c.getAxisCommandValue(0)if not cS then s5:inject(cL:len()-rx/3.6)local tU=dm(s5:get(),0,1)s9=dm(s9+tU,0,1)end;local u3=-s9*(aR*cL+aS*sd)d:setEngineForceCommand('brake',u3)local tV=''local tW=vec3()local u4=false;local tY='thrust analog longitudinal 'if aW~="none"and(bF=="All"or bF=="Longitude")then tY=tY..aW end;local tZ=iz:getAxisCommandType(axisCommandId.longitudinal)if tZ==axisCommandType.byThrottle then local t_=iz:composeAxisAccelerationFromThrottle(tY,axisCommandId.longitudinal)d:setEngineForceCommand(tY,t_,rR)elseif tZ==axisCommandType.byTargetSpeed then local t_=iz:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tV=tV..' , '..tY;tW=tW+t_;if iz:getTargetSpeed(axisCommandId.longitudinal)==0 or iz:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iz:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u4=true end end;local u2='thrust analog lateral 'if aX~="none"and(bF=="All"or bF=="Lateral")then u2=u2 ..aX end;local u5=iz:getAxisCommandType(axisCommandId.lateral)if u5==axisCommandType.byThrottle then local u6=iz:composeAxisAccelerationFromThrottle(u2,axisCommandId.lateral)d:setEngineForceCommand(u2,u6,rR)elseif u5==axisCommandType.byTargetSpeed then local u0=iz:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tV=tV..' , '..u2;tW=tW+u0 end;local u1='thrust analog vertical 'if aY~="none"and(bF=="All"or bF=="Vertical")then u1=u1 ..aY end;local u7=iz:getAxisCommandType(axisCommandId.vertical)if u7==axisCommandType.byThrottle then local tX=iz:composeAxisAccelerationFromThrottle(u1,axisCommandId.vertical)if c0~=0 or b9 and b3 then d:setEngineForceCommand(u1,tX,rR,'airfoil','ground','',rT)else d:setEngineForceCommand(u1,vec3(),rR)d:setEngineForceCommand('airfoil vertical',tX,rR,'airfoil','','',rT)d:setEngineForceCommand('ground vertical',tX,rR,'ground','','',rT)end elseif u7==axisCommandType.byTargetSpeed then if c0<0 then d:setEngineForceCommand('hover',vec3(),rR)end;local u8=iz:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tV=tV..' , '..u1;tW=tW+u8 end;if tW:len()>constants.epsilon then if s9~=0 or u4 or e_(sd:dot(cI))<0.5 then tV=tV..', brake'end;d:setEngineForceCommand(tV,tW,rS,'','','',rT)end end;local u9=aO*(sh-sg)local ua=vec3(bQ.getWorldAirFrictionAngularAcceleration())u9=u9-ua;d:setEngineTorqueCommand('torque',u9,rR,'airfoil','','',rT)d:setBoosterCommand('rocket_engine')if c6 and not o then local kh=cK:len()local ub=0.15;if not cS then local uc=iz:getTargetSpeed(axisCommandId.longitudinal)if kh*3.6>uc*(1-ub)and ud then ud=false;d:toggleBoosters()elseif kh*3.6<uc*(1-ub)and not ud then ud=true;d:toggleBoosters()end else local rk=c.getThrottle()if t then rk=bS*100 end;local rx=rk/100;if not ch then rx=rx*a1;if kh>=rx*(1-ub)and ud then ud=false;d:toggleBoosters()elseif kh<rx*(1-ub)and not ud then ud=true;d:toggleBoosters()end else local ti=bO(cC)rx=rx*ti/3.6;if kh>=rx*(1-ub)and ud then ud=false;d:toggleBoosters()elseif kh<rx*(1-ub)and not ud then ud=true;d:toggleBoosters()end end end end end;if ue then for dM,dy in pairs(ue)do pH[dM]=dy end end;cg=qz()return pH end;local function uf(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ug,iy,iz,iA,uh,gD,fM,e5,dn,dm,fL,iC,pG,dj)local bQ=DUConstruct;local ui={}local uj=true;local uk=5;local ul=5;local um=uk;local un=ul;local uo=bR;function ui.landingGear(qb)bp=not bp;if bp then if b6 or bt or ce or bC then cu.ResetAutopilots(true)end;bw=nil;cu.cmdThrottle(0)if vBooster or hover then if(ch or cj<20000)and not qb and cg==-1 then fL("bklOn","BL")qW=true;bb=false;ba=false;bc=false;if b9 then dc=not dc end;cA=true;bp=false;b9=true else if bX then fL("grOut","LG",1)d.control.deployLandingGears()end;dc=false;if ch then cA=q;b3="Landing"end end;if qb or cg~=-1 and cg>_-3 or not bE then b9=true end;iz:activateGroundEngineAltitudeStabilization(q_)iz:setTargetGroundAltitude(_)b8=false elseif bX and not b9 then fL("grOut","LG",1)d.control.deployLandingGears()end else if b9 then b9=false end;if bX then fL("grIn","LG",1)d.control.retractLandingGears()end;iz:activateGroundEngineAltitudeStabilization(q_)if bE then if _<iz.targetGroundAltitude then iz:setTargetGroundAltitude(iz.targetGroundAltitude)else iz:setTargetGroundAltitude(Z)end else iz:setTargetGroundAltitude(Z)end end end;function ui.startControl(up)local function uq(rf)local rg=1;local function ur(us,rf)local ut={ks.surfaceMaxAltitude+100,ks.spaceEngineMinAltitude-0.01*ks.noAtmosphericDensityAltitude,ks.noAtmosphericDensityAltitude+V,ks.radius*(U-1)+ks.noAtmosphericDensityAltitude}local uu=us;for dR,dy in ipairs(ut)do if rf and uu>dy then us=dy elseif us<dy and not rf then us=dy;break end end;return us end;if rf then rg=-1 end;if not r and cR then if c2 and rf then by=1000 elseif by~=nil then by=by+rg*ul;if by<1000 then by=1000 end;if b8 and by<bd+10 and by>bd-10 then bd=by end else by=tP+rg*100 end elseif b8 or bc or bC then if bC then if c2 then cE=ur(cE,rf)else cE=cE+rg*uk end;if cE<ks.noAtmosphericDensityAltitude then cE=ks.noAtmosphericDensityAltitude end else if c2 and ch then bd=ur(bd,rf)else bd=bd+rg*uk end end else iz:updateTargetGroundAltitudeFromActionStart(rg*1.0)end end;local function uv(uw)if not ch then dj("Flight Assist in Atmo only")return end;local dv=type(uw)if cY==nil then if dv=="table"then if b6 or bt then cu.ToggleAutopilot()end;fL("180On","BR")elseif uw==1 then fL("bnkLft","BR")else fL("bnkRht","BR")end;if not b8 and not b6 and not bt then cu.ToggleAltitudeHold()if dv~="table"then uw=uw+1 end end;cY=uw else fL("180Off","BR")cY=nil end end;local function ux()if iA()==1 then ca=0;cb=0;uh(bl)elseif iy()==1 and y then cz=false;cy=false end;c2=false end;if up=="gear"then cw.landingGear()elseif up=="light"then if p6 then if iy()==1 then if DUPlayer.isFrozen()==1 then DUPlayer.freeze(0)dj("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(1)dj("Player Frozen, pitch/yaw/roll enabled")end else dj("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif up=="forward"then if p6 and not ch and not b6 then b5=not b5;b4=false else bY=bY-1 end elseif up=="backward"then if p6 then if not ch then if not b6 then b4=not b4;b5=false else b7=not b7 end else uv(-cL*5000)end else bY=bY+1 end elseif up=="left"then if p6 then uv(1)else bZ=bZ-1 end elseif up=="right"then if p6 then uv(3)else bZ=bZ+1 end elseif up=="yawright"then b_=b_-1;dd=nil elseif up=="yawleft"then b_=b_+1;dd=nil elseif up=="straferight"then iz:updateCommandFromActionStart(axisCommandId.lateral,1.0)bB=1 elseif up=="strafeleft"then iz:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bB=-1 elseif up=="up"then cu.vertical(1)if cg-3<_ and cj>0 and bp then cw.landingGear()end elseif up=="down"then cu.vertical(-1)elseif up=="groundaltitudeup"then uq()elseif up=="groundaltitudedown"then uq(true)elseif up=="option1"then uy=false;if p6 and c2 then local uz=""for M=1,#d3 do uz=uz.."| Name: "..a.getPlayerName(d3[M]).." Mass: "..fM(bQ.getBoardedPlayerMass(d3[M])/1000,1).."t "end;a.print("Onboard: "..uz)return end;ct.adjustAutopilotTargetIndex()elseif up=="option2"then uy=false;if p6 and c2 then for M=1,#d3 do bQ.forceDeboard(d3[M])bQ.forceInterruptVRSession(d3[M])end;dj("Deboarded All Passengers")return end;ct.adjustAutopilotTargetIndex(1)elseif up=="option3"then uy=false;if p6 and c2 then local uz=""for M=1,#d4 do uz=uz.."| ID: "..d4[M].." Mass: "..fM(bQ.getDockedConstructMass(d4[M])/1000,1).."t "end;a.print("Docked Ships: "..uz)return end;if x then if w then w=false else w=true end;if cv then cv.ToggleRadarPanel()end end elseif up=="option4"then uy=false;if p6 and c2 then for M=1,#d4 do bQ.forceUndock(d4[M])end;dj("Undocked all ships")return end;cY=nil;cu.ToggleAutopilot()elseif up=="option5"then uy=false;cu.ToggleLockPitch()elseif up=="option6"then uy=false;if p6 and c2 then if shield then cx.ventShield()else dj("No shield found")end;return end;cu.ToggleAltitudeHold()elseif up=="option7"then uy=false;if p6 and c2 then if shield then shield.toggle()return else dj("No shield found")return end end;E=not E;if E then dj("Collision System Enabled")else dj("Collision System Secured")end elseif up=="option8"then uy=false;if p6 and c2 then if bo>0 and fX~=nil then cu.routeWP()else dj("Select a saved wp on IPH to add to or remove from route")end;return end;bE=not bE;if not bE then dj("DeCoupled Mode - Ground Stabilization off")iz:deactivateGroundEngineAltitudeStabilization()fL("gsOff","GS")else dj("Coupled Mode - Ground Stabilization on")iz:activateGroundEngineAltitudeStabilization(q_)df=true;fL("gsOn","GS")end elseif up=="option9"then uy=false;if p6 and c2 then iz:resetCommand(axisCommandId.longitudinal)iz:resetCommand(axisCommandId.lateral)iz:resetCommand(axisCommandId.vertical)cu.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cl=gyro.isActive()==1;if cl then fL("gyOn","GA")else fL("gyOff","GA")end else dj("No gyro found")end elseif up=="lshift"then if p6 then c2=true end elseif up=="brake"then if b1 or p6 then cu.BrakeToggle("Manual")elseif not b3 then cu.BrakeToggle("Manual")else b3="Manual"end elseif up=="lalt"then uy=true;p6=true;if iy()==0 and not j and g=="keyboard"then uh(1)end elseif up=="booster"then if o then d:toggleBoosters()elseif not c6 then if not ud then d:toggleBoosters()ud=true end;c6=true else if ud then d:toggleBoosters()ud=false end;c6=false end elseif up=="stopengines"then local function uA()if bR-uo<1.5 then fL("clear","CA")cu.clearAll()end end;uA()uo=bR;if iz:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p6 then if cC>0 then cC=0 else cC=W end elseif bS~=0 then iz:resetCommand(axisCommandId.longitudinal)cu.cmdThrottle(0)else cu.cmdThrottle(100)end else if iz:getTargetSpeed(axisCommandId.longitudinal)~=0 then iz:resetCommand(axisCommandId.longitudinal)else if ch then cu.cmdCruise(cC)else cu.cmdCruise(a1*3.6)end end end elseif up=="speedup"then cu.changeSpd()elseif up=="speeddown"then cu.changeSpd(true)elseif up=="antigravity"and not r then if antigrav~=nil then cu.ToggleAntigrav()else dj("No antigrav found")end elseif up=="leftmouse"then c3=true;if c2 then ux()uy=false else c2=true;bl=iA()uh(1)end end end;function ui.stopControl(up)local function uB()if not r and cR then un=ul end;if b8 or bc or bC then um=uk end end;if up=="forward"then bY=0 elseif up=="backward"then bY=0 elseif up=="left"then if cY then if cY==2 then cY=-2 else cY=-1 end end;bZ=0 elseif up=="right"then if cY then if cY==4 then cY=-2 else cY=-1 end end;bZ=0 elseif up=="yawright"then b_=0 elseif up=="yawleft"then b_=0 elseif up=="straferight"then iz:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bB=0 elseif up=="strafeleft"then iz:updateCommandFromActionStop(axisCommandId.lateral,1.0)bB=0 elseif up=="up"then cu.vertical(0,-1)elseif up=="down"then cu.vertical(0,1)elseif up=="groundaltitudeup"then uB()uy=false elseif up=="groundaltitudedown"then uB()uy=false elseif up=="brake"then if not b1 and not p6 then if b3 then cu.BrakeToggle()else b3=false end end elseif up=="lalt"then if c2 then c2=false end;if iy()==0 and j then if uy then if iA()==1 then uh(0)else uh(1)end else uy=true end elseif iy()==0 and not j and g=="keyboard"then uh(0)end;p6=false end end;function ui.loopControl(up)local function uC(rf)local rg=1;if rf then rg=-1 end;if not r and cR then if by~=nil then by=by+rg*un;if by<1000 then by=1000 end;if b8 and by<bd+10 and by>bd-10 then bd=by end;un=dm(un*1.05,ul,50)else by=tP+rg*100 end elseif b8 or bc or bC then if bC then cE=cE+rg*um;if cE<ks.noAtmosphericDensityAltitude then cE=ks.noAtmosphericDensityAltitude end else bd=bd+rg*um end;um=dm(um*1.05,uk,50)else iz:updateTargetGroundAltitudeFromActionLoop(rg*1.0)end end;local function uD(rf)local rg=1;if rf then rg=-1 end;if not c2 then if t and not p6 then bS=dm(bS+rg*aG/100,-1,1)else iz:updateCommandFromActionLoop(axisCommandId.longitudinal,rg*aG)end end end;if up=="groundaltitudeup"then if not c2 then uC()end elseif up=="groundaltitudedown"then if not c2 then uC(true)end elseif up=="speedup"then uD()elseif up=="speeddown"then uD(true)end end;function ui.inputTextControl(re)local function uE(uF,fn,gq)local function uG(fn)local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF='::pos{'..dE..','..dE..','..dE..','..dE..','..dE..'}'local dV,dW,e2,e3,e4=e5(fn,dF)if dV=="0"and dW=="0"then return vec3(dn(e2),dn(e3),dn(e4))end;e3=math.rad(e3)e2=math.rad(e2)local ks=e[dn(dV)][dn(dW)]local eW=math.cos(e2)local uH=vec3(eW*math.cos(e3),eW*math.sin(e3),math.sin(e2))return ks.center+(ks.radius+e4)*uH end;local fO=uG(fn)return ct.AddNewLocation(uF,fO,gq)end;local M;local uI,im=nil,nil;local uJ="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(re," ")uI=re;if M~=nil and string.find(re,"::")~=1 then uI=string.sub(re,0,M-1)im=string.sub(re,M+1)end;if uI=="/help"or uI=="/commands"then for lm in string.gmatch(uJ,"([^\n]+)")do a.print(lm)end;return elseif uI=="/setname"then if im==nil or im==""then dj("Usage: ah-setname Newname")return end;if bo>0 and fX~=nil then ct.UpdatePosition(im)else dj("Select a saved target to rename first")end elseif shield and uI=="/resist"then cx.setResist(im)elseif uI=="/addlocation"or string.find(re,"::pos")~=nil then local gq=false;local uF="0-Temp"if im==nil or im==""or uI~="/addlocation"then im=uI;gq=true end;M=string.find(im,"::")if not gq then uF=string.sub(im,1,M-2)end;local fn=string.sub(im,M)fn=fn:gsub("%s+","")uE(uF,fn,gq)elseif uI=="/agg"then if im==nil or im==""then dj("Usage: /agg targetheight")return end;im=dn(im)if im<1000 then im=1000 end;by=im;dj("AGG Target Height set to "..im)elseif uI=="/G"then if im==nil or im==""then dj("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if im=="dump"then for dM,dy in pairs(iC())do if type(dy.get())=="boolean"then if dy.get()==true then a.print(dM.." true")else a.print(dM.." false")end elseif dy.get()==nil then a.print(dM.." nil")else a.print(dM.." "..dy.get())end end;return end;M=string.find(im," ")local uK=string.sub(im,0,M-1)local uL=string.sub(im,M+1)for dM,dy in pairs(iC())do if dM==uK then local uM=type(dy.get())if uM=="number"then uL=dn(uL)if dM=="AtmoSpeedLimit"then cC=uL end end;dj("Variable "..uK.." changed to "..uL)if dM=="MaxGameVelocity"then uL=uL/3.6;if uL>dg-0.2 then uL=dg-0.2;dj("Variable "..uK.." changed to "..fM(uL*3.6,1))end end;if uM=="boolean"then if string.lower(uL)=="true"then uL=true else uL=false end end;dy.set(uL)return end end;dj("No such global variable: "..uK)elseif uI=="/deletewp"then if bo>0 and fX~=nil then ct.ClearCurrentPosition()else dj("Select a custom wp to delete first in IPH")end elseif uI=="/copydatabank"then if dbHud_2 then pG(true)else dj("Spare Databank required to copy databank")end elseif uI=="/iphWP"then if bo>0 then a.print(cu.showWayPoint(c9,bn,true))a.print(json.encode(bn))dj("::pos waypoint shown in lua chat in local and world format")else dj("No target selected in IPH")end elseif uI=="/createPrivate"then local uN="privatelocations = {\n"local uO=""if#da>0 then for dM,dy in pairs(da)do uN=uN.."{position = {x = "..dy.position.x..", y = "..dy.position.y..", z = "..dy.position.z.."},\n ".."name = '"..dy.name.."',\n planetname = '"..dy.planetname.."',\n gravity = "..dy.gravity..",\n"if dy.heading then uN=uN.."heading = {x = "..dy.heading.x..", y = "..dy.heading.y..", z = "..dy.heading.z.."},\n"end;if dy.safe then uN=uN.."safe = true},\n"else uN=uN.."safe = false},\n"end end end;uO=#da.."-Private "if im=="all"then for dM,dy in pairs(bs)do uN=uN.."{position = {x = "..dy.position.x..", y = "..dy.position.y..", z = "..dy.position.z.."},\n ".."name = '*"..dy.name.."',\n planetname = '"..dy.planetname.."',\n gravity = "..dy.gravity..",\n"if dy.heading then uN=uN.."heading = {x = "..dy.heading.x..", y = "..dy.heading.y..", z = "..dy.heading.z.."},\n"end;if dy.safe then uN=uN.." safe = true},\n"else uN=uN.."safe = false},\n"end end;uO=uO..#bs.."-Public "end;uN=uN.."}\n return privatelocations"if ug then ug.setHTML(uN)end;dj(uO.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c5=7 end end;function ui.tagTick()if bF=="Off"then bF="All"elseif bF=="All"then bF="Longitude"elseif bF=="Longitude"then bF="Lateral"elseif bF=="Lateral"then bF="Vertical"else bF="Off"end;dj("Extra Engine Tags: "..bF)c.stopTimer("tagTick")end;if uP then for dM,dy in pairs(uP)do ui[dM]=dy end end;return ui end;local function uQ(d,b,c,e,vBooster,hover,pF,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iv,ug)local a=DUSystem;local bQ=DUConstruct;local uR=DUPlayer;local uS=DULibrary;local uT={}local dl=string.format;local iw=json.decode;local uU=json.encode;local py=b.getElementMaxHitPointsById;local ix=b.getElementMassById;local iy=d.control.isRemoteControlled;local e5=string.match;local gD=a.destroyWidgetPanel;local fJ=a.updateData;local fK=a.addDataToWidget;local uh=a.lockView;local iA=a.isViewLocked;local dp=math.sqrt;local dn=tonumber;local e_=math.abs;local bO=math.floor;local bP=c.getAtmosphereDensity;local eV=math.atan;local bN=a.getArkTime;local dm=utils.clamp;local iz=d.axisCommandManager;local gF=13;local iF=b.getElementIdList()local iG=0;local function dq(eD,eE)if eD==0 then return e_(eE)<1e-09 elseif eE==0 then return e_(eD)<1e-09 else return e_(eD-eE)<math.max(e_(eD),e_(eE))*dD end end;local function fM(dE,uV)local rg=10^(uV or 0)return bO(dE*rg+0.5)/rg end;local function iB(uW,uX)for dM,dy in pairs(uX)do if type(dM)=="string"then uW[dM]=dy else uW[#uW+1]=uX[dM]end end;return uW end;local function iC(uY)local uZ={}if not uY then iB(uZ,L)iB(uZ,ac)iB(uZ,aE)iB(uZ,b0)return uZ elseif uY=="boolean"then return L elseif uY=="handling"then return ac elseif uY=="hud"then return aE elseif uY=="physics"then return b0 end end;local function dj(sQ)if not sQ then return end;if c4~="empty"then if not string.find(c4,sQ)then c4=c4 .."\n"..sQ;c5=7 end else c4=sQ end end;local function pG(u_)local function v0(v1)for dM,dy in pairs(v1)do dbHud_1.setStringValue(dM,uU(dy.get()))if u_ and dbHud_2 then dbHud_2.setStringValue(dM,uU(dy.get()))end end end;if dbHud_1 then v0(bK)v0(iC())a.print("Saved Variables to Datacore")if u_ and dbHud_2 then dj("Databank copied.  Remove copy when ready.")end end end;local function fL(v2,v3,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v2 ..".mp3")end;local function gE(hy,hz,re,jN,v4)return dl([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jN or"",hy,hz,v4 or"",re)end;local function iD(cc,v5)v5=v5 or 1;local unit="m"if cc>100000 then cc=cc/200000;unit="su"elseif cc>1000 then cc=cc/1000;unit="km"end;return fM(cc,v5)..unit end;local function iE(v6)local v7=0;local v8=0;local v9=0;if v6<60 then v6=bO(v6)elseif v6<3600 then v7=bO(v6/60)v6=bO(v6%60)elseif v6<86400 then v8=bO(v6/3600)v7=bO(v6%3600/60)else v9=bO(v6/86400)v8=bO(v6%86400/3600)end;if v9>365 then return">1y"elseif v9>0 then return v9 .."d "..v8 .."h "elseif v8>0 then return v8 .."h "..v7 .."m "elseif v7>0 then return v7 .."m "..v6 .."s"elseif v6>0 then return v6 .."s"else return"0s"end end;local function va()if radar_1 then cv=gC(b,a,c,radar_1,radar_2,warpdrive,e_,gD,dp,gE,dn,gF,fL,dj)end end;function uT.radarSetup()va()end;function uT.onStart()local vb=false;local function vc()local function vd(ve)local vf=dbHud_1.hasKey;for dM,dy in pairs(ve)do if vf(dM)then local dH=iw(dbHud_1.getStringValue(dM))if dH~=nil then dy.set(dH)vb=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vd(iC())coroutine.yield()vd(bK)else vd(bK)dj("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c5=5;vb=false end;coroutine.yield()if vb then dj("Loaded Saved Variables")elseif not f then dj("No Databank Saved Variables Found\nVariables will save to Databank on standing")c5=5 end;if#bs>0 then db=iB(db,bs)end else dj("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;b1=k;g=string.lower(g)cA=q;cC=W;if bz+180<bR then bx=0 end;bz=bR;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then dj("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c5=7 end;if antigrav and not r then if by==nil then by=cj end;antigrav.setTargetAltitude(by)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#da>0 then db=iB(db,da)end end;lr="Proceeding to Waypoint"if not a1 or a1<0 then a1=bQ.getMaxSpeed()-0.1 end end;local function vg()local function vh(vi,vj)if vi>vj then vj=vi end;local vk,vl=0,0;if a7>0 then vk=a7*0.05 end;if a8>0 then vl=a8*0.05 end;vj=vj*(1-(vk+vl))return vj end;local vm=b.getElementNameById;local vn=au~=0 and av~=0;local vo=_G["atmofueltank_size"]local vp=_G["spacefueltank_size"]local vq=_G["rocketfueltank_size"]for dM in pairs(iF)do local type=b.getElementDisplayNameById(iF[dM])if e5(type,'^.*Atmospheric Engine$')then if e5(tostring(b.getElementTagsById(iF[dM])),'^.*vertical.*$')and b.getElementForwardById(iF[dM])[3]>0 then cQ=true end end;if e5(type,'^.*Space Engine$')then cH=true;if e5(tostring(b.getElementTagsById(iF[dM])),'^.*vertical.*$')then local vr=b.getElementForwardById(iF[dM])if vr[3]<0 then vs=true else cG=true end end end;if type=="Landing Gear"then bX=true end;if type=="Dynamic Core Unit"then local pA=py(iF[dM])if pA>10000 then gF=110 elseif pA>1000 then gF=55 elseif pA>150 then gF=27 end end;iG=iG+py(iF[dM])if vn and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pA=py(iF[dM])local f4=ix(iF[dM])local vi=0;local jF=bN()if type=="Atmospheric Fuel Tank"then local vj=400;local vt=35.03;if pA>10000 then vj=51200;vt=5480 elseif pA>1300 then vj=6400;vt=988.67 elseif pA>150 then vj=1600;vt=182.67 end;vi=f4-vt;if a4>0 then vj=vj+vj*a4*0.2 end;vj=vh(vi,vj)local gp=vm(iF[dM])local jD=0;for jE=1,vo do if gp==iw(c["atmofueltank_"..jE].getWidgetData()).name then jD=jE;break end end;local vu={iF[dM],string.sub(gp,1,12),vj,vt,vi,jF,jD}cm[#cm+1]=vu end;if type=="Rocket Fuel Tank"then local vj=320;local vt=173.42;if pA>65000 then vj=40000;vt=25740 elseif pA>6000 then vj=5120;vt=4720 elseif pA>700 then vj=640;vt=886.72 end;vi=f4-vt;if a6>0 then vj=vj+vj*a6*0.1 end;vj=vh(vi,vj)local gp=vm(iF[dM])local jD=0;for jE=1,vq do if gp==iw(c["rocketfueltank_"..jE].getWidgetData()).name then jD=jE;break end end;local vu={iF[dM],string.sub(gp,1,12),vj,vt,vi,jF,jD}co[#co+1]=vu end;if type=="Space Fuel Tank"then local vj=600;local vt=35.03;if pA>10000 then vj=76800;vt=5480 elseif pA>1300 then vj=9600;vt=988.67 elseif pA>150 then vj=2400;vt=182.67 end;vi=f4-vt;if a5>0 then vj=vj+vj*a5*0.2 end;vj=vh(vi,vj)local gp=vm(iF[dM])local jD=0;for jE=1,vp do if gp==iw(c["spacefueltank_"..jE].getWidgetData()).name then jD=jE;break end end;local vu={iF[dM],string.sub(gp,1,12),vj,vt,vi,jF,jD}cn[#cn+1]=vu end end end;if not cQ then bc,b2=false,false end end;local function vv()if gyro~=nil then cl=gyro.isActive()==1 end;if not bE then iz:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then uh(1)else uh(0)end;if door and(ch or not ch and cj<10000)then for dR,dy in pairs(door)do dy.toggle()end end;if switch then for dR,dy in pairs(switch)do dy.toggle()end end;if forcefield and(ch or not ch==0 and cj<10000)then for dR,dy in pairs(forcefield)do dy.toggle()end end;if antigrav then cR=antigrav.isActive()==1;if cR and not r then antigrav.showWidget()end end;if iy()==1 and l then uR.freeze(1)else uR.freeze(0)end;if bX then if cg~=-1 and not cR then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bp=d.control.isAnyLandingGearDeployed()==1 or not bE or cg~=-1 and cg-3<_;local vw=cK:len()<30;if cg~=-1 and vx or(not ch or not vx)and vw then b3="Startup"else b3=false end;iz:setTargetGroundAltitude(_)pm=ch end;local function vy()local vz={}local function vA()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vB={[1]=6637,[2]=3426,[4]=7580,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vC,vD in pairs(e)do e[vC][0]=vA()e[vC][0].systemId=vC;vz[vC]={}for vE,ks in pairs(e[vC])do ks.gravity=ks.gravity/9.8;ks.center=vec3(ks.center)ks.name=ks.name[1]ks.noAtmosphericDensityAltitude=ks.atmosphereThickness;ks.spaceEngineMinAltitude=vB[ks.id]or 0.5353125*ks.atmosphereThickness;ks.planetarySystemId=vC;ks.bodyId=ks.id;vz[vC][vE]=ks;if mh==nil or ks.center.x<mh then mh=ks.center.x end;if mg==nil or ks.center.x>mg then mg=ks.center.x end;if mk==nil or ks.center.y<mk then mk=ks.center.y end;if mj==nil or ks.center.y>mj then mj=ks.center.y end;if ks.center and ks.name~="Space"then d5[#d5+1]=ks end end end;ef=dk(d,b,c,a,dl,dm,dn,dp,dq)cp=ef(vz)fP=cp[0]cq=eZ(d,b,c,a,dp,e_)cr=fj(d,b,c,a,dl,dm,dn,dp,dq)ct=fI(d,b,c,a,dbHud_1,e,fJ,fK,bO,dn,dp,fL,fM,dj)ks=cp[0]:closestBody(bQ.getWorldPosition())end;vF=false;vG=coroutine.create(function()iz:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vc()coroutine.yield()vg()coroutine.yield()cu=pE(d,b,c,e,vBooster,hover,pF,antigrav,dbHud_1,e_,bO,bP,iy,eV,bN,dm,iz,fJ,iA,dp,fM,fL,iB,dq,iD,iE,pG,iw,dj)vv()coroutine.yield()vy()va()if iu then cs=iu(d,b,c,a,e,antigrav,hover,shield,warpdrive,iv,e_,bO,dl,iw,bP,ix,iy,eV,bN,dm,iz,fK,fJ,gD,iA,dp,fM,gE,fL,iB,iC,iD,iE,iF,iG,dj)end;if cs then cs.ButtonSetup()end;cw=uf(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ug,iy,iz,iA,uh,gD,fM,e5,dn,dm,fL,iC,pG,dj)if shield then cx=ic(shield,e5,bO,dj)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if ug then ug.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bQ.setDockingMode(ab)if shield then c.setTimer("shieldTick",0.0166667)end;if vH then vI.ExtraOnStart()end;local function vJ()if bJ[1]==0 then cu.cmdThrottle(bJ[2])else if ci>0 then cC=bJ[2]cu.cmdThrottle(1)end end end;lj=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if lj then if cg>-1 and cM<1 and cg-3<_ then c.exit()else if J then vJ()else if ci==0 then b3="ECU Braking"elseif cg==-1 then cw.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bJ[3]+3>bN()then vJ()end;d4=bQ.getDockedConstructs()d3=bQ.getPlayersOnBoard()local vK;vK=#d3>1 and"Passengers: "..#d3-1 .." "or""vK=vK..(#d4>0 and"Ships: "..#d4 or"")if vK~=""then dj("NOTICE: Docked "..vK)end;fL("start","SU")end)coroutine.resume(vG)end;function uT.onUpdate()if vF then d:update()if ch and t and cS then if cS and bW then cu.cmdThrottle(0)bW=false elseif not cS and not bW then bS=0;bW=true end end;if d8 then iz:setThrottleCommand(axisCommandId.longitudinal,d8)d8=nil end;if not cy and p8~=vL then a.setScreen(p8)end;vL=p8;if lj and not J and ci>0 and cg==-1 then cw.landingGear()end;if lj and cg>-1 and cM<1 and cg-3<_ then c.exit()end;if vH then vI.ExtraOnUpdate()end else local i2=coroutine.status(vG)if i2=="suspended"then local dN,i3=coroutine.resume(vG)if i3 then a.print("ERROR STARTUP: "..i3)end elseif i2=="dead"then vF=true end end end;function uT.onFlush()if vF then cu.onFlush()if vH then vI.ExtraOnFlush()end end end;function uT.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ci>0 or ci==0 and cj<10000)then for dR,dy in pairs(door)do dy.toggle()end end;if switch then for dR,dy in pairs(switch)do dy.toggle()end end;if forcefield and(ci>0 or ci==0 and cj<10000)then for dR,dy in pairs(forcefield)do dy.toggle()end end;w=d7;local vM=0;if lj then vM=bN()end;if iz:getAxisCommandType(0)==0 then bJ={0,bS,vM}else bJ={1,iz:getTargetSpeed(axisCommandId.longitudinal),vM}end;pG()if nT then nT.activate()end;if z then cu.showWayPoint(ks,cP)end;if cs then a.print(cs.FuelUsed("atmofueltank")..", "..cs.FuelUsed("spacefueltank")..", "..cs.FuelUsed("rocketfueltank"))end;if vH then vI.ExtraOnStop()end;fL("stop","SU")end;function uT.controlStart(up)if vF then cw.startControl(up)end end;function uT.controlStop(up)if vF then cw.stopControl(up)end end;function uT.controlLoop(up)if vF then cw.loopControl(up)end end;function uT.controlInput(re)if vF then cw.inputTextControl(re)end end;function uT.radarEnter(dW)if cv then cv.onEnter(dW)end end;function uT.radarLeave(dW)if cv then cv.onLeave(dW)end end;function uT.onTick(vN)if vN=="tenthSecond"then if cu then cu.TenthTick()end;if cs then cs.TenthTick()end elseif vN=="oneSecond"then if cs then cs.OneSecondTick()end elseif vN=="msgTick"then if cs then cs.MsgTick()end elseif vN=="animateTick"then if cs then cs.AnimateTick()end elseif vN=="hudTick"then if cs then cs.hudtick()end elseif vN=="apTick"then if cu then cu.APTick()end elseif vN=="shieldTick"then cx.shieldTick()elseif vN=="tagTick"then cw.tagTick()elseif vN=="contact"then cv.ContactTick()end end;if vH then for dM,dy in pairs(vH)do uT[dM]=dy end end;return uT end;function script.onStart()vI.onStart()end;function script.onOnStop()vI.onStop()end;function script.onTick(vN)vI.onTick(vN)end;function script.onOnFlush()vI.onFlush()end;function script.onOnUpdate()vI.onUpdate()end;function script.onActionStart(up)vI.controlStart(up)end;function script.onActionStop(up)vI.controlStop(up)end;function script.onActionLoop(up)vI.controlLoop(up)end;function script.onInputText(re)vI.controlInput(re)end;function script.onEnter(dW)vI.radarEnter(dW)end;function script.onLeave(dW)vI.radarLeave(dW)end;bM(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vI=uQ(d,core,unit,e,vBooster,hover,pF,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iv,ug)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
