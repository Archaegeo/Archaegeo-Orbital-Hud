name: ArchHud - Archaegeo v0.800 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaintainOrbit = true --export: (Default: true) If true, ship will attempt to maintain orbit if it decays (when not autopiloting to a landing point) till fuel runs out.
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        ExtraEscapeThrust = 1.0 --export: (Default: 1.0) Set this to 1 to use friction burn speed as your max speed when escaping atmosphere. Setting other than 1 will be a the value multiplied by your friction burn speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.800;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=true;K=false;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},freeLookToggle={set=function(M)i=M end,get=function()return i end},BrakeToggleDefault={set=function(M)j=M end,get=function()return j end},RemoteFreeze={set=function(M)k=M end,get=function()return k end},brightHud={set=function(M)m=M end,get=function()return m end},RemoteHud={set=function(M)l=M end,get=function()return l end},VanillaRockets={set=function(M)n=M end,get=function()return n end},InvertMouse={set=function(M)o=M end,get=function()return o end},autoRollPreference={set=function(M)p=M end,get=function()return p end},ExternalAGG={set=function(M)q=M end,get=function()return q end},UseSatNav={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},FullRadar={set=function(M)J=M end,get=function()return J end},ECUHud={set=function(M)K=M end,get=function()return K end},MaintainOrbit={set=function(M)N=M end,get=function()return N end}}O=35;P=35;Q=30;R=30;S=-30;T=0;U=5000;V=1.2;W=2000;X=1175;Y=66000;Z=1000;_=50;a0=0;a1=100000;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab={YawStallAngle={set=function(M)O=M end,get=function()return O end},PitchStallAngle={set=function(M)P=M end,get=function()return P end},brakeLandingRate={set=function(M)Q=M end,get=function()return Q end},MaxPitch={set=function(M)R=M end,get=function()return R end},ReEntryPitch={set=function(M)S=M end,get=function()return S end},LockPitchTarget={set=function(M)T=M end,get=function()return T end},AutopilotSpaceDistance={set=function(M)U=M end,get=function()return U end},TargetOrbitRadius={set=function(M)V=M end,get=function()return V end},LowOrbitHeight={set=function(M)W=M end,get=function()return W end},AtmoSpeedLimit={set=function(M)X=M end,get=function()return X end},SpaceSpeedLimit={set=function(M)Y=M end,get=function()return Y end},AutoTakeoffAltitude={set=function(M)Z=M end,get=function()return Z end},TargetHoverHeight={set=function(M)_=M end,get=function()return _ end},LandingGearGroundHeight={set=function(M)a0=M end,get=function()return a0 end},ReEntryHeight={set=function(M)a1=M end,get=function()return a1 end},MaxGameVelocity={set=function(M)ac=M end,get=function()return ac end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end}}ad=1920;ae=1080;af=400;ag=130;ah=224;ai=255;aj=255;ak=0;al=0;am=960;an=540;ao=1300;ap=540;aq=1525;ar=325;as=550;at=540;au=30;av=700;aw=1750;ax=250;ay=1750;az=350;aA=50;aB=250;aC=0;aD=30;aE={ResolutionX={set=function(M)ad=M end,get=function()return ad end},ResolutionY={set=function(M)ae=M end,get=function()return ae end},circleRad={set=function(M)af=M end,get=function()return af end},SafeR={set=function(M)ag=M end,get=function()return ag end},SafeG={set=function(M)ah=M end,get=function()return ah end},SafeB={set=function(M)ai=M end,get=function()return ai end},PvPR={set=function(M)aj=M end,get=function()return aj end},PvPG={set=function(M)ak=M end,get=function()return ak end},PvPB={set=function(M)al=M end,get=function()return al end},centerX={set=function(M)am=M end,get=function()return am end},centerY={set=function(M)an=M end,get=function()return an end},throtPosX={set=function(M)ao=M end,get=function()return ao end},throtPosY={set=function(M)ap=M end,get=function()return ap end},vSpdMeterX={set=function(M)aq=M end,get=function()return aq end},vSpdMeterY={set=function(M)ar=M end,get=function()return ar end},altMeterX={set=function(M)as=M end,get=function()return as end},altMeterY={set=function(M)at=M end,get=function()return at end},fuelX={set=function(M)au=M end,get=function()return au end},fuelY={set=function(M)av=M end,get=function()return av end},shieldX={set=function(M)aw=M end,get=function()return aw end},shieldY={set=function(M)ax=M end,get=function()return ax end},radarX={set=function(M)ay=M end,get=function()return ay end},radarY={set=function(M)az=M end,get=function()return az end},DeadZone={set=function(M)aA=M end,get=function()return aA end},OrbitMapSize={set=function(M)aB=M end,get=function()return aB end},OrbitMapX={set=function(M)aC=M end,get=function()return aC end},OrbitMapY={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV="none"aW="none"aX="none"aY={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aZ=M end,get=function()return aZ end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end}}a_=j;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=1000;bc=false;bd=false;be=false;bf=false;bg=0;bh="Aligning"bi=0;bj=1;bk="None"bl=nil;bm=0;bn=nil;bo=0.0;bp=0;bq={}br=false;bs=0;bt=0;bu=nil;bv=0;bw=1000;bx=0;by=false;bz=0;bA=false;bB="All"bC=true;bD="Off"bE=0.000;bF={}bG={}bH={}bI=false;bJ={VertTakeOff={set=function(M)ba=M end,get=function()return ba end},VertTakeOffEngine={set=function(M)b0=M end,get=function()return b0 end},SpaceTarget={set=function(M)by=M end,get=function()return by end},BrakeToggleStatus={set=function(M)a_=M end,get=function()return a_ end},BrakeIsOn={set=function(M)b1=M end,get=function()return b1 end},RetrogradeIsOn={set=function(M)b2=M end,get=function()return b2 end},ProgradeIsOn={set=function(M)b3=M end,get=function()return b3 end},Autopilot={set=function(M)b4=M end,get=function()return b4 end},TurnBurn={set=function(M)b5=M end,get=function()return b5 end},AltitudeHold={set=function(M)b6=M end,get=function()return b6 end},BrakeLanding={set=function(M)b7=M end,get=function()return b7 end},Reentry={set=function(M)b9=M end,get=function()return b9 end},AutoTakeoff={set=function(M)b8=M end,get=function()return b8 end},HoldAltitude={set=function(M)bb=M end,get=function()return bb end},AutopilotAccelerating={set=function(M)bc=M end,get=function()return bc end},AutopilotBraking={set=function(M)be=M end,get=function()return be end},AutopilotCruising={set=function(M)bf=M end,get=function()return bf end},AutopilotRealigned={set=function(M)bd=M end,get=function()return bd end},AutopilotEndSpeed={set=function(M)bg=M end,get=function()return bg end},AutopilotStatus={set=function(M)bh=M end,get=function()return bh end},AutopilotPlanetGravity={set=function(M)bi=M end,get=function()return bi end},PrevViewLock={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetName={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetCoords={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetIndex={set=function(M)bm=M end,get=function()return bm end},TotalDistanceTravelled={set=function(M)bo=M end,get=function()return bo end},TotalFlightTime={set=function(M)bp=M end,get=function()return bp end},SavedLocations={set=function(M)bq=M end,get=function()return bq end},VectorToTarget={set=function(M)br=M end,get=function()return br end},LocationIndex={set=function(M)bs=M end,get=function()return bs end},LastMaxBrake={set=function(M)bt=M end,get=function()return bt end},LockPitch={set=function(M)bu=M end,get=function()return bu end},LastMaxBrakeInAtmo={set=function(M)bv=M end,get=function()return bv end},AntigravTargetAltitude={set=function(M)bw=M end,get=function()return bw end},LastStartTime={set=function(M)bx=M end,get=function()return bx end},iphCondition={set=function(M)bB=M end,get=function()return bB end},stablized={set=function(M)bC=M end,get=function()return bC end},UseExtra={set=function(M)bD=M end,get=function()return bD end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bF=M end,get=function()return bF end},apRoute={set=function(M)bG=M end,get=function()return bG end},ecuThrottle={set=function(M)bH=M end,get=function()return bH end},HoverMode={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=p;cA=false;cB=X;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2=nil;d3=nil;d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()if shield then dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dh(di)a.print(bQ..": "..di)end;local function dj(d,b,c,a,dk,dl,dm,dn,dp)local function dq(dr)return type(dr)=='number'end;local function ds(dr)return type(dm(dr))=='number'end;local function dt(du)return type(du)=='table'end;local function dv(a)return type(a)=='string'end;local function dw(dx)return dt(dx)and dq(dx.x and dx.y and dx.z)end;local function dy(dz)return dt(dz)and dq(dz.latitude and dz.longitude and dz.altitude and dz.id and dz.systemId)end;local dA=math.pi/180;local dB=180/math.pi;local dC=1e-10;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local utils=utils;local vec3=vec3;local function dF(dr)local dG=string.gsub(string.reverse(dk('%.4f',dr)),'^0*%.?','')return dG==''and'0'or string.reverse(dG)end;local function dH(dI)if dw(dI)then return dk('{x=%.3f,y=%.3f,z=%.3f}',dI.x,dI.y,dI.z)end;if dt(dI)and not getmetatable(dI)then local dJ={}local dK=next(dI)if type(dK)=='nil'or dK==1 then dJ=dI else for dL,dx in pairs(dI)do local dM=dH(dx)if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end end;return dk('{%s}',table.concat(dJ,','))end;if dv(dI)then return dk("'%s'",dI:gsub("'",[[\']]))end;return tostring(dI)end;local dN={}dN.__index=dN;dN.__tostring=function(dI,dO)local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)local dJ={}for dQ,dL in ipairs(dP)do local dM=dH(dI[dL])if type(dL)=='number'then table.insert(dJ,dk('[%s]=%s',dL,dM))else table.insert(dJ,dk('%s=%s',dL,dM))end end;if dO then return dk('%s%s',dO,table.concat(dJ,',\n'..dO))end;return dk('{%s}',table.concat(dJ,','))end;dN.__eq=function(dR,dS)return dR.systemId==dS.systemId and dR.id==dS.id and dp(dR.radius,dS.radius)and dp(dR.center.x,dS.center.x)and dp(dR.center.y,dS.center.y)and dp(dR.center.z,dS.center.z)and dp(dR.GM,dS.GM)end;local function dT(dU,dV,dW,dX,dY)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(dW),'Argument 3 (radius) must be a number:'..type(dW))assert(dt(dX),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dX))assert(ds(dY),'Argument 5 (GM) must be a number:'..type(dY))return setmetatable({systemId=dm(dU),id=dm(dV),radius=dm(dW),center=vec3(dX),GM=dm(dY)},dN)end;local dZ={}dZ.__index=dZ;dZ.__tostring=function(dh)return dk('::pos{%d,%d,%s,%s,%s}',dh.systemId,dh.id,dF(dh.latitude*dB),dF(dh.longitude*dB),dF(dh.altitude))end;dZ.__eq=function(dR,dS)return dR.id==dS.id and dR.systemId==dS.systemId and dp(dR.latitude,dS.latitude)and dp(dR.altitude,dS.altitude)and(dp(dR.longitude,dS.longitude)or dp(dR.latitude,math.pi/2)or dp(dR.latitude,-math.pi/2))end;local function d_(e0,dV,e1,e2,e3)local dU=e0;if dv(e0)and not e2 and not e3 and not dV and not e1 then dU,dV,e1,e2,e3=e4(e0,dE)assert(dU,'Argument 1 (position string) is malformed.')else assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(e1),'Argument 3 (latitude) must be in degrees:'..type(e1))assert(ds(e2),'Argument 4 (longitude) must be in degrees:'..type(e2))assert(ds(e3),'Argument 5 (altitude) must be in meters:'..type(e3))end;dU=dm(dU)dV=dm(dV)e1=dm(e1)e2=dm(e2)e3=dm(e3)if dV==0 then return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=dV,systemId=dU},dZ)end;return setmetatable({latitude=dA*dl(e1,-90,90),longitude=dA*(e2%360),altitude=e3,id=dV,systemId=dU},dZ)end;local e5={}e5.__index=e5;e5.__tostring=function(dI,dO)local e6=dO and dO..'  'local e7={}local dP={}for dL in pairs(dI)do table.insert(dP,dL)end;table.sort(dP)for dQ,e8 in ipairs(dP)do e9=dI[e8]local ea=dN.__tostring(e9,e6)if dO then table.insert(e7,dk('[%s]={\n%s\n%s}',e8,ea,dO))else table.insert(e7,dk('  [%s]=%s',e8,ea))end end;if dO then return dk('\n%s%s%s',dO,table.concat(e7,',\n'..dO),dO)end;return dk('{\n%s\n}',table.concat(e7,',\n'))end;local function eb(ec)local e={}local pid;for dQ,dx in pairs(ec)do local dV=dx.planetarySystemId;if type(dV)~='number'then error('Invalid planetary s ID: '..tostring(dV))elseif pid and dV~=pid then error('Mistringmatch planetary s IDs: '..dV..' and '..pid)end;local ed=dx.bodyId;if type(ed)~='number'then error('Invalid body ID: '..tostring(ed))elseif e[ed]then error('Duplicate body ID: '..tostring(ed))end;setmetatable(dx.center,getmetatable(vec3.unit_x))e[ed]=setmetatable(dx,dN)pid=dV end;return setmetatable(e,e5)end;ee={}local function ef(ec)return setmetatable({galaxyAtlas=ec or{}},ee)end;ee.__index=function(du,M)if type(M)=='number'then local a=du.galaxyAtlas[M]return eb(a)end;return rawget(ee,M)end;ee.__pairs=function(dI)return function(du,dL)local eg,eh=next(du,dL)return eg,eh and eb(eh)end,dI.galaxyAtlas,nil end;ee.__tostring=function(dI)local ei={}for dQ,ej in pairs(dI or{})do local ek=ej:getPlanetarySystemId()local el=e5.__tostring(ej,'    ')table.insert(ei,dk('  [%s]={%s\n  }',ek,el))end;return dk('{\n%s\n}\n',table.concat(ei,',\n'))end;ee.BodyParameters=dT;ee.MapPosition=d_;ee.PlanetarySystem=eb;function ee.createBodyParameters(dU,dV,em,en,eo,ep,eq)assert(ds(dU),'Argument 1 (systemId) must be a number:'..type(dU))assert(ds(dV),'Argument 2 (id) must be a number:'..type(dV))assert(ds(em),'Argument 3 (surfaceArea) must be a number:'..type(em))assert(dt(en),'Argument 4 (aPosition) must be an array or vec3:'..type(en))assert(dt(eo),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eo))assert(ds(ep),'Argument 6 (altitude) must be in meters:'..type(ep))assert(ds(eq),'Argument 7 (gravityAtPosition) must be number:'..type(eq))local dW=dn(em/4/math.pi)local cb=dW+ep;local er=vec3(en)+cb*vec3(eo)local dY=eq*cb*cb;return dT(dU,dV,dW,er,dY)end;ee.isMapPosition=dy;function ee:getPlanetarySystem(e0)if M==nil then M=0 end;if eh==nil then eh=0 end;local dU=e0;if dy(e0)then dU=e0.systemId end;if type(dU)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eh)~=e5 then a=eb(a)end;return a end end end;function e5:sizeCalculator(es)return 1.05*es.radius end;function e5:castIntersections(et,eu,ev,ew,ex,ey)local ez={}if ex then for dQ,es in pairs(ex)do table.insert(ez,es)end else ez=d4 end;if not ey then table.sort(ez,function(eA,eB)local eC=eA.center;local eD=eB.center;return(eC.x-et.x)^2+(eC.y-et.y)^2+(eC.z-et.z)^2<(eD.x-et.x)^2+(eD.y-et.y)^2+(eD.z-et.z)^2 end)end;local eE=eu:normalize()for dQ,es in ipairs(ez)do local eF=es.center-et;local dW;if ev then dW=ev(es)else dW=self:sizeCalculator(es)end;local eG=eF:dot(eE)local eH=eG^2-(eF:len2()-dW^2)if eH>=0 then local eI=dn(eH)local eJ=eG+eI;local eK=eG-eI;if eK>0 then return es,eJ,eK elseif eJ>0 then return es,eJ,nil end end end;return nil,nil,nil end;function e5:closestBody(eL)assert(type(eL)=='table','Invalid coordinates.')local eM,es;local eN=vec3(eL)for dQ,eO in pairs(self)do local eP=(eO.center-eN):len2()if(not es or eP<eM)and eO.name~="Space"then es=eO;eM=eP end end;return es end;function e5:convertToBodyIdAndWorldCoordinates(e0)local eQ=e0;if dv(e0)then eQ=d_(e0)end;if eQ.id==0 then return 0,vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;local eO=self:getBodyParameters(eQ)if eO then return eQ.id,eO:convertToWorldCoordinates(eQ)end end;function e5:getBodyParameters(e0)local dV=e0;if dy(e0)then dV=e0.id end;assert(ds(dV),'Argument 1 (id) must be a number:'..type(dV))return self[dV]end;function e5:getPlanetarySystemId()local dQ,dx=next(self)return dx and dx.systemId end;function dN:convertToMapPosition(dX)assert(dt(dX),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dX))local eR=vec3(dX)if self.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=self.systemId},dZ)end;local eS=eR-self.center;local cb=eS:len()local e3=cb-self.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=e1,longitude=e2,altitude=e3,id=self.id,systemId=self.systemId},dZ)end;function dN:convertToWorldCoordinates(e0)local eQ=dv(e0)and d_(e0)or e0;if eQ.id==0 then return vec3(eQ.latitude,eQ.longitude,eQ.altitude)end;assert(dy(eQ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eQ.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eQ.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eV=math.cos(eQ.latitude)return self.center+(self.radius+eQ.altitude)*vec3(eV*math.cos(eQ.longitude),eV*math.sin(eQ.longitude),math.sin(eQ.latitude))end;function dN:getAltitude(dX)return(vec3(dX)-self.center):len()-self.radius end;function dN:getDistance(dX)return(vec3(dX)-self.center):len()end;function dN:getGravity(dX)local eW=self.center-vec3(dX)local eX=eW:len2()return self.GM/eX*eW/dn(eX)end;return setmetatable(ee,{__call=function(dQ,...)return ef(...)end})end;local function eY(d,b,c,a,dn,eZ)local cp={}local bP=100000000/3600;local e_=bP*bP;local f0=100;function cp.computeAccelerationTime(f1,f2,f3)local f4=bP*math.asin(f1/bP)return(bP*math.asin(f3/bP)-f4)/f2 end;function cp.computeDistanceAndTime(f1,f3,f5,f6,f7,f8)f7=f7 or 0;f8=f8 or 0;local f9=f1<=f3;local fa=f6*(f9 and 1 or-1)/f5;local fb=-f8/f5;local fc=fa+fb;if f9 and fc<=0 or not f9 and fc>=0 then return-1,-1 end;local fd,fe=0,0;if fa~=0 and f7>0 then local f4=math.asin(f1/bP)local ff=math.pi*(fa/2+fb)local fg=fa*f7;local fh=bP*math.pi;local dx=function(du)local fi=(ff*du-fg*math.sin(math.pi*du/2/f7)+fh*f4)/fh;local fj=math.tan(fi)return bP*fj/dn(fj*fj+1)end;local fk=f9 and function(a)return a>=f3 end or function(a)return a<=f3 end;fe=2*f7;if fk(dx(fe))then local fl=0;while eZ(fe-fl)>0.5 do local du=(fe+fl)/2;if fk(dx(du))then fe=du else fl=du end end end;local fm=f1;local fn=fe/f0;for fo=1,f0 do local fp=dx(fo*fn)fd=fd+(fp+fm)*fn/2;fm=fp end;if fe<2*f7 then return fd,fe end;f1=fm end;local f4=bP*math.asin(f1/bP)local bQ=(bP*math.asin(f3/bP)-f4)/fc;local fq=e_*math.cos(f4/bP)/fc;local cb=fq-e_*math.cos((fc*bQ+f4)/bP)/fc;return cb+fd,bQ+fe end;function cp.computeTravelTime(f1,f2,cb)if cb==0 then return 0 end;if f2>0 then local f4=bP*math.asin(f1/bP)local fq=e_*math.cos(f4/bP)/f2;return(bP*math.acos(f2*(fq-cb)/e_)-f4)/f2 end;if f1==0 then return-1 end;assert(f1>0,'Acceleration and initial speed are both zero.')return cb/f1 end;return cp end;local function fr(d,b,c,a,dk,dl,dm,dn,dp)local vec3=vec3;local dj=dj(d,b,c,a,dk,dl,dm,dn,dp)local function dv(a)return type(a)=='string'end;local function dt(du)return type(du)=='table'end;fs={}fs.__index=fs;function fs:escapeAndOrbitalSpeed(e3)assert(self.body)local cb=e3+self.body.radius;if not dp(cb,0)then local ft=dn(self.body.GM/cb)return dn(2)*ft,ft end;return nil,nil end;function fs:orbitalParameters(e0,fu)assert(self.body)assert(dt(e0)or dv(e0))assert(dt(fu))local fv=(dv(e0)or dj.isMapPosition(e0))and self.body:convertToWorldCoordinates(e0)or vec3(e0)local dx=vec3(fu)local fw=fv-self.body.center;local fx=dx:len2()local fy=fw:len()local fz=self.body.GM;local fA=((fx-fz/fy)*fw-fw:dot(dx)*dx)/fz;local eC=fz/(2*fz/fy-fx)local fB=fA:len()local eE=fA:normalize()local fC=eC*(1-fB)local fD=eC*(1+fB)local fE=fC*eE+self.body.center;local fF=fB<=1 and-fD*eE+self.body.center or nil;local fG=dn(eC*fz*(1-fB*fB))local fH=fF and 2*math.pi*dn(eC^3/fz)local fI=math.acos(fA:dot(fw)/(fB*fy))if fw:dot(dx)<0 then fI=-(fI-2*math.pi)end;local fJ=math.acos((math.cos(fI)+fB)/(1+fB*math.cos(fI)))local fK=fJ;if fK<0 then fK=fK+2*math.pi end;local fL=fK-fB*math.sin(fK)local fM=0;local fN=0;local fO=0;if fH~=nil then fM=fL/(2*math.pi/fH)fN=fH-fM;fO=fN+fH/2;if fI-math.pi>0 then fN=fM;fO=fN+fH/2 end;if fO>fH then fO=fO-fH end end;return{periapsis={position=fE,speed=fG/fC,circularOrbitSpeed=dn(fz/fC),altitude=fC-self.body.radius},apoapsis=fF and{position=fF,speed=fG/fD,circularOrbitSpeed=dn(fz/fD),altitude=fD-self.body.radius},currentVelocity=dx,currentPosition=fv,eccentricity=fB,period=fH,eccentricAnomaly=fJ,meanAnomaly=fL,timeToPeriapsis=fN,timeToApoapsis=fO,trueAnomaly=fI}end;local function fP(fQ)local eO=dj.BodyParameters(fQ.systemId,fQ.id,fQ.radius,fQ.center,fQ.GM)return setmetatable({body=eO},fs)end;return setmetatable(fs,{__call=function(dQ,...)return fP(...)end})end;local function fR(d,b,c,a,dbHud_1,e,fS,fT,bN,dm,dn,fU,fV)local function fW(fX)local dh=fY:closestBody(fX)if(fX-dh.center):len()>dh.radius+dh.noAtmosphericDensityAltitude then dh=e[0][0]end;return dh end;local function fZ()local function f_(g0,g1)return g0.name<g1.name end;cU={}for dL,dx in pairs(e[0])do cU[#cU+1]={name=dx.name,index=dL}end;table.sort(cU,f_)end;local function g2(g3,g4)if not g4 then g4=g5.name end;for dL,dx in pairs(g3)do if dx.name and dx.name==g4 then return dL end end;return-1 end;local function g6()d1=bm;if bm==0 then bk="None"c8=nil;g5=nil;return true end;local g7=cU[bm].index;local g8=e[0][g7]if g8.center then bk=g8.name;c8=co[0][g7]if g5~=nil then if ch==0 then if fS(g9,ga)~=1 then fT(g9,ga)end;if fS(gb,gc)~=1 then fT(gb,gc)end;if fS(gd,ge)~=1 then fT(gd,ge)end;if fS(gf,gg)~=1 then fT(gf,gg)end;if fS(gh,gi)~=1 then fT(gh,gi)end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end;if fS(gn,go)~=1 then fT(gn,go)end end;g5=nil else g5=g8;for dQ,dx in pairs(co[0])do if dx.name==g5.planetname then c8=dx;bk=g5.name;break end end;if fS(gj,gk)~=1 then fT(gj,gk)end;if fS(gl,gm)~=1 then fT(gl,gm)end end;if g5==nil then bl=vec3(c8.center)else bl=g5.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gp=bN(c8.radius*(V-1)+c8.noAtmosphericDensityAltitude)else gp=bN(c8.radius*(V-1)+c8.surfaceMaxAltitude)end else gp=U end;if g5~=nil and g5.planetname=="Space"then bg=0 else dQ,bg=cq(c8):escapeAndOrbitalSpeed(gp)end;bi=0;bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"return true end;local function gq(gr)if not b4 and not br and not cd and not bA and not b9 and not ce then if gr==nil then bm=bm+1;if bm>#cU then bm=0 end else bm=bm-1;if bm<0 then bm=#cU end end;if bm==0 then g6()else local g7=cU[bm].index;local g8=e[0][g7]if g8 and(g8~=nil and g8.name=="Space"or bB=="Custom Only"and g8.center or bB=="No Moons-Asteroids"and(string.find(g8.name,"Moon")~=nil or string.find(g8.name,"Asteroid")~=nil))then if gr==nil then gq()else gq(1)end else g6()end end else c3="Disengage autopilot before changing Interplanetary Helper"fU("iph","AP")end end;local function gs()local function gt(gu)local gv;if gu then gv=d9 else gv=bq end;local gw=-1;gw=g2(e[0])if gw>-1 then table.remove(e[0],gw)end;gw=-1;gw=g2(gv)if gw~=-1 then c3=g5.name.." saved location cleared"table.remove(gv,gw)end;gq()fZ()return gv end;if string.sub(bk,1,1)=="*"then d9=gt(true)else bq=gt(false)end end;local function gx(gy,fX,gz,gA)local function gB(gu)if gu then gv=d9 else gv=bq end;if dbHud_1 or gz or gu then local dh=fW(fX)local gC={position=fX,name=gy,planetname=dh.name,gravity=b.getGravityIntensity(),safe=gA}if not gz then gv[#gv+1]=gC else for dL,dx in pairs(e[0])do if dx.name and gy==dx.name then table.remove(e[0],dL)end end end;table.insert(e[0],gC)fZ()g6()c3="Location saved as "..gy.."("..dh.name..")"return gv else c3="Databank must be installed to save permanent locations"end end;if string.sub(gy,1,1)=="*"then d9=gB(true)else bq=gB(false)end end;local gD={}function gD.UpdateAtlasLocationsList()fZ()end;function gD.UpdateAutopilotTarget()g6()end;function gD.adjustAutopilotTargetIndex(gr)gq(gr)end;function gD.findAtlasIndex(g3,g4)return g2(g3,g4)end;function gD.UpdatePosition(gE,gF,gG)local function gH(gu)local gv;if gu then gv=d9 else gv=bq end;local gw=g2(gv)if gw~=-1 then if gE~=nil then if gu then gE="*"..gE end;gv[gw].name=gE;bm=bm-1;gq()elseif gG~=nil then if gG then local gI=ci;if gI<1000 then gI=1000 end;gv[gw].agg=fV(gI,0)c3=gv[gw].name.." AGG Altitude:"..gv[gw].agg.." saved ("..gv[gw].planetname..")"return elseif gG==false then gv[gw].agg=nil;c3=gv[gw].name.." AGG Altitude cleared ("..gv[gw].planetname..")"return end else local gJ=gv[gw]if gF then gJ.heading=cI:cross(cM)*5000;c3=gv[gw].name.." heading saved ("..gv[gw].planetname..")"return elseif gF==false then gJ.heading=nil;c3=gv[gw].name.." heading cleared ("..gv[gw].planetname..")"return end;gJ.gravity=b.getGravityIntensity()gJ.position=cO;gJ.safe=true end;c3=gv[gw].name.." position updated ("..gv[gw].planetname..")"else c3="Name Not Found"end end;if string.sub(bk,1,1)=="*"then gH(true)else gH(false)end end;function gD.AddNewLocation(gy,fX,gz,gA)gx(gy,fX,gz,gA)end;function gD.ClearCurrentPosition()gs()end;for dL,dx in pairs(da)do table.insert(e[0],dx)end;if gK then for dL,dx in pairs(gK)do gD[dL]=dx end end;fZ()if bm>#cU then bm=0 end;gD.UpdateAutopilotTarget()return gD end;local function gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU)local gP={}local gQ={}local gR={XS=13,S=27,M=55,L=110,XL=221}local gS={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gT={}local gU=0;local gV;local gW;local gX;local gY;local gZ={gY}local g_="Atmo"local h0;local h1;local h2=0;local h3={}local h4;local h5=0;local vec3=vec3;local h6=table.insert;local h7=-4;local h8={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h9,ha;local hb,hc;local function hd()if he~=nil and h2==0 then gM(he)a.destroyWidget(h9)a.destroyData(hb)h9,hb,he=nil,nil,nil;if h1~=nil then gM(h1)a.destroyWidget(ha)a.destroyData(hc)h1,ha,hc=nil,nil,nil end elseif J then if h2==1 then gM(he)he=nil;h1=a.createWidgetPanel("PeriWinkle")ha=a.createWidget(h1,'periscope')hc=gY.getWidgetDataId()a.addDataToWidget(hc,ha)end;if he==nil and gU>0 then he=a.createWidgetPanel(g_)h9=a.createWidget(he,'radar')hb=gY.getWidgetDataId()a.addDataToWidget(hb,h9)end;h2=0 end end;local function hf()local function hg(hh,hi,hj,hk,hl,hm,hn,ho)hi,hk,hm,ho=vec3(hi),vec3(hk),vec3(hm),vec3(ho)local hp,hq,hr=hh*hh,hj*hj,hl*hl;local fx=hk-hi;local hs=fx:normalize()local ht=fx:len()local hu=hm-hi;local hv=(hu-hu:project_on(hs)):normalize()local hw,hx=hu:dot(hs),hu:dot(hv)local hy=hw*hw+hx*hx;local hz=hs:cross(hv)local hA=(hp-hq+ht*ht)/(2*ht)local hB=(hp-hr+hy-2*hw*hA)/(2*hx)local dz=hp-hA^2-hB^2;local hC=dn(dz)local hD=hi+hs*hA+hv*hB+hz*hC;local hE=hi+hs*hA+hv*hB-hz*hC;if eZ((ho-hD):len()-hn)<eZ((ho-hE):len()-hn)then return hD else return hE end end;local function hF(hG,fy,hH)local hI=hG.pts;local gw=#hI;local hJ=hG.ref;if gw>3 then local hK,hL,hM,hN=hI[gw],hI[gw-1],hI[gw-2],hI[gw-3]hG.ref=hH;local fv=hg(hK[1],hK[2],hL[1],hL[2],hM[1],hM[2],hN[1],hN[2])local hA,hB,hC=fv.x,fv.y,fv.z;if hA==hA and hB==hB and hC==hC then hA=hA+hJ[1]hB=hB+hJ[2]hC=hC+hJ[3]local hO=vec3(hA,hB,hC)hG.center=hO;if hG.lastPos then if(hG.lastPos-hO):len()<2 then local hP=(hO-vec3(hH)):len()if eZ(hP-fy)<10 then hG.skipCalc=true end end end;hG.lastPos=hO end;hG.pts={}else local hQ={hH[1]-hJ[1],hH[2]-hJ[2],hH[3]-hJ[3]}hI[gw+1]={fy,hQ}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gY then gU=#h4;if#h4>0 then local hR=gY.hasMatchingTransponder;local hS=gY.getConstructKind;local hT=gY.isConstructAbandoned;local hU=gY.getConstructName;local hV=gY.getConstructDistance;local hW=gY.getConstructCoreSize;local hH={cO["x"],cO["y"],cO["z"]}local hX,hY=0,0;local hZ=cL*10;local cY=cY;gX,gW=0,0;gQ={}for dQ,dx in pairs(h4)do local cb=hV(dx)if cb>0.0 then local h_=hW(dx)local i0=gR[h_]cb=dm(cb)if hR(dx)==1 then h6(gQ,dx)end;if not cV and warpdrive and cb<aa and warpdrive.getStatus()==15 then c3="INITIATING WARP"c4=7;warpdrive.initiate()end;if E then local i1=hS(dx)local i2=F and hT(dx)==1;local gy=hU(dx)if i0==nil then dh("ID: "..dx.."* Name: "..gy.."* Size:"..h_.."* Dist:"..cb)end;if i2 or cb<hZ and(i0>27 or i1==4 or i1==6)then gX=gX+1;local gy=hU(dx)local hG=h3[dx]if hG==nil then i0=i0+gO;h3[dx]={pts={},ref=hH,name=gy,i=0,radius=i0,skipCalc=false}hG=h3[dx]end;if not hG.skipCalc then hF(hG,cb,hH)if i2 and not hG.abandoned and hG.center then local bQ=a.getArkTime()if h5+5<bQ then h5=bQ;fU("abRdr","RD")end;a.print("Abandoned Construct: "..gy.." ("..h_.." "..gS[i1]..") at estimated ::pos{0,0,"..hG.center.x..","..hG.center.y..","..hG.center.z.."}")c3="Abandoned Radar Contact ("..h_.." "..gS[i1]..") detected"hG.abandoned=true end;hY=hY+1 else h6(gT,hG)end end;hX=hX+1;if cY and hX>300 or hY>30 or(not cY and hX>300 or hY>30)then coroutine.yield()hX,hY=0,0 end end end end;gW=#gT;if gW>0 and(cL>20 or b7)then local es,i3,i4,i5;local i6=0;local i7=co:getPlanetarySystem(0)i5=cK:normalize()while i6<gW do coroutine.yield()local i8={table.unpack(gT,i6,math.min(i6+75,gW))}es,i3,i4=i7:castIntersections(cO,i5,nil,nil,i8,true)if es and i4 then c_={es,i3,i4}break end;i6=i6+75 end;if not es then c_=nil end else c_=nil end;gT={}gV=gY.getTargetId()end end end;local function i9()if gY then g_="Atmo"if gY.getRange()>10000 then g_="Space"end end end;function gP.pickType()i9()end;function gP.assignRadar()if radar_2 and h7~=1 then if h7==-1 then if gY==radar_2 then gY=radar_1 else gY=radar_2 end end;gZ={gY}h4=gY.getConstructIds()i9()else h4=gY.getConstructIds()end;h7=gY.getOperationalState()end;function gP.UpdateRadar()local ia=coroutine.status(h0)if ia=="suspended"then local dM,ib=coroutine.resume(h0)if ib then a.print("ERROR UPDATE RADAR: "..ib)end elseif ia=="dead"then h0=coroutine.create(hf)local dM,ib=coroutine.resume(h0)end end;function gP.GetRadarHud(ic,id,ay,az)local ie,di;local dD=gW or 0;if gU>0 then if E then di=dD.."/"..gX.." Plotted : "..gU-gX.." Ignored"else di="Radar Contacts: "..gU end;ie=gN(ay,az,di,"pbright txtbig txtmid")if#gQ>0 then ie=ie..gN(ic,id,"Friendlies In Range","pbright txtbig txtmid")for dL,dx in pairs(gQ)do id=id+20;ie=ie..gN(ic,id,gY.getConstructName(dx),"pdim txtmid")end end;if gV==nil and h1==nil then h2=1;cu.ToggleRadarPanel()end;if gV~=nil and h1~=nil then cu.ToggleRadarPanel()end;if he==nil then if w then cu.ToggleRadarPanel()end end else if h7~=1 then ie=gN(ay,az,g_.." Radar: "..h8[h7],"pbright txtbig txtmid")else ie=gN(ay,az,"Radar: No "..g_.." Contacts","pbright txtbig txtmid")end;if he~=nil then h2=0;cu.ToggleRadarPanel()end end;return ie end;function gP.GetClosestName(gy)if gY then local ig=gY.getConstructName(gY.getConstructIds()[1])if ig then gy=gy.." "..ig end end;return gy end;function gP.ToggleRadarPanel()hd()end;function gP.ContactTick()if not ih then ih=0 end;if bQ>ih+10 then c3="Radar Contact"fU("rdrCon","RC")ih=bQ end;c.stopTimer("contact")end;function gP.onEnter(dV)if gY and not cg and not cV then c.setTimer("contact",0.1)end end;function gP.onLeave(dV)if gY and E then if#h3>650 then dV=tostring(dV)h3[dV]=nil end end end;local function ii()gY=nil;if radar_2 and radar_2.getOperationalState()==1 then gY=radar_2 else gY=radar_1 end;h7=gY.getOperationalState()gZ={gY}h4=gY.getConstructIds()i9()h0=coroutine.create(hf)if ij then for dL,dx in pairs(ij)do gP[dL]=dx end end end;ii()return gP end;local function ik(shield,e4,bN)local il={}local im=shield.getResistancesCooldown()local function io()local ip=shield.isActive()if G then if not cV and ip==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and ip==1 then shield.toggle()end end end;local function iq()local ir=shield.getStressRatioRaw()local is=0.5999;if ir[1]==0.0 and ir[2]==0.0 and ir[3]==0.0 and ir[4]==0.0 then return end;local it=shield.setResistances(is*ir[1],is*ir[2],is*ir[3],is*ir[4])if it==1 then c3="Shield Resistances updated"else c3="Value Exceeded. Failed to update Shield Resistances"end end;function il.shieldTick()dg=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())io()im=shield.getResistancesCooldown()if im==0 and dg<a9 then iq()end end;function il.setResist(iu)if not shield then c3="No shield found"return elseif iu==nil or im>0 then c3="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE=dD..', '..dD..', '..dD..', '..dD;local iv,iw,ix,iy=e4(iu,dE)if iy==nil or iv+iw+ix+iy>0.6 then c3="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(iv,iw,ix,iy)==1 then c3="Shield Resistances set"else c3="Resistance setting failed."end end;function il.ventShield()local iz=shield.getVentingCooldown()if iz>0 then c3="Cannot vent again for "..iz.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c3="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c3="Shields already at max hitpoints"end end;if iA then for dL,dx in pairs(iA)do il[dL]=dx end end;return il end;local function iB(d,b,c,a,e,antigrav,hover,shield,warpdrive,iC,eZ,bN,dk,iD,bO,iE,iF,eU,bM,dl,iG,fT,fS,gM,iH,dn,fV,gN,fU,iI,iJ,iK,iL,iM,iN)local bP=DUConstruct;local iO=9.80665;local iP={}local iQ={}local iR={}local iS={}local iT=nil;local iU=nil;local iV=nil;local iW=false;local iX="none"local iY=""local iZ=55;local i_=0;local j0=0;local j1=nil;local j2=ag;local j3=ah;local j4=ai;local j5=[[rgb(]]..bN(j2+0.5)..","..bN(j3+0.5)..","..bN(j4+0.5)..[[)]]local j6=[[rgb(]]..bN(j2*0.9+0.5)..","..bN(j3*0.9+0.5)..","..bN(j4*0.9+0.5)..[[)]]local j7=0;local j8=0;local j9=""local ja=bM()local jb=false;local jc=false;local function jd(dx)if ad==1920 then return dx else return fV(ad*dx/1920,0)end end;local function je(dx)if ae==1080 then return dx else return fV(ae*dx/1080,0)end end;local function jf()return iH()==0 and g~="keyboard"and iF()==0 end;local function jg()local jh="TRAVEL"if not cR then jh="CRUISE"end;if b4 then jh="AUTOPILOT"end;return jh end;local ie=""local ji=""local jj=""local jk=1;local jl=2;local jm=3;local jn=4;local jo=5;local jp=6;local jq=7;local jr=""local js=0;local jt=120.0*aU;local ju={}local jv={}local jw={}local jx={}local jy={}local jz={}local jA={}jA["atmofueltank"],jA["spacefueltank"],jA["rocketfueltank"]=0,0,0;local jB=0;local function jC(hA,jD,jE,jF,jG,jH)local jI=jB;local jJ=jB+5;if not B then jJ=jJ+5 end;if iF()==1 and not l then jI=jI-50;jJ=jJ-50 end;if jE=="ATMO"then jr="atmofueltank"elseif jE=="SPACE"then jr="spacefueltank"else jr="rocketfueltank"end;js=_G[jr.."_size"]if#jF>0 then for M=1,#jF do local gy=jF[M][jl]local jK=jF[M][jq]for jL=1,js do if jF[M][jl]==iD(c[jr.."_"..jL].getWidgetData()).name then jK=jL;break end end;local jM=bM()if jG[M]==nil or jH[M]==nil or jM-jF[M][jp]>jt then local jN;local jO=0;jO=iE(jF[M][jk])-jF[M][jn]jN=jF[M][jo]if jN>jO then jA[jr]=jA[jr]+jN-jO end;if jK~=0 then local jP=iD(c[jr.."_"..jK].getWidgetData())jH[M]=jP.percentage;jG[M]=jP.timeLeft;if jG[M]=="n/a"then jG[M]=0 end else jH[M]=bN(0.5+jO*100/jF[M][jm])if jN<=jO then jG[M]=0 else jG[M]=bN(0.5+jO/((jN-jO)/(jM-jF[M][jp])))end end;jF[M][jp]=jM;jF[M][jo]=jO end;if gy==jD then gy=dk("%s %d",jE,M)end;if jK==0 then gy=gy.." *"end;local jQ;if jG[M]==0 then jQ=""else jQ=iL(jG[M])end;if jH[M]~=nil then local jR=bN(jH[M]*2.55)local jS=dk("rgb(%d,%d,%d)",255-jR,jR,0)local jT=""if jQ~=""and jG[M]<120 or jH[M]<5 then jT="red "end;local jU=dk("rgb(%d,%d,%d)",dl(bN((255-jR)/2.55),50,100),dl(bN(jR/2.55),0,50),50)local jV="rgb(196,0,255)"if jE=="ATMO"then jV="rgb(0,188,255)"elseif jE=="SPACE"then jV="rgb(239,255,0)"end;local jW=false;if jX~=jV then jW=true end;jX=jV;if B then if jW then jI=jI-5;jJ=jJ-5 end;ji=ji..dk([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jU,jV,hA,jJ,jS,bN(jH[M]*1.7+0.5)-2,hA+1,jJ+1,hA+5,jJ+14,gy,jH[M],jQ)jI=jI-22;jJ=jJ-22 else ji=ji..gN(hA,jI,gy,jT.."pdim txtfuel")ji=ji..gN(hA,jJ,dk("%d%% %s",jH[M],jQ),"pdim txtfuel","fill:"..jS)jI=jI+30;jJ=jJ+30 end end end end;jB=jI end;local function jY(jZ,e3)if aq==0 and ar==0 then return end;if e3<200000 and not cg or e3 and cg then local j_=0;if eZ(cN)>1 then j_=45*math.log(eZ(cN),10)if cN<0 then j_=-j_ end end;jZ[#jZ+1]=dk([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],aq,ar,bN(cN),bN(j_))end;return jZ end;local function k0(k1)local gr=-cM;k1=k1-k1:project_on(gr)local k2=vec3(0,0,1)k2=k2-k2:project_on(gr)local k3=k2:cross(gr)local j_=k2:angle_between(k1)*constants.rad2deg;if k1:dot(k3)<0 then j_=360-j_ end;return j_ end;local function k4(jZ,am,an,k5,k6,cY)if af==0 then return end;local k7=af;local k8=20;local k9=bN(k5)if cY then for M=-45,45,5 do local ka=M;jZ[#jZ+1]=dk([[<g transform="rotate(%f,%d,%d)">]],ka,am,an)kb=5;if M%15==0 then kb=15 elseif M%10==0 then kb=10 end;jZ[#jZ+1]=dk([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],am,an+k7+k8-kb,am,an+k7+k8)end;jZ[#jZ+1]=gN(am,an+k7+k8-35,k6,"pdim txt txtmid")jZ[#jZ+1]=gN(am,an+k7+k8-25,k9 .." deg","pdim txt txtmid")jZ[#jZ+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k5,am,an)jZ[#jZ+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/>]],am-5,an+k7+k8-20,am+5,an+k7+k8-20,am,an+k7+k8-15)jZ[#jZ+1]="</g>"end;jZ[#jZ+1]=[[<g style="clip-path: url(#headingClip);">]]local kc=k9;if cY then kc=k0(cH)end;local kd=20;local ke=bN(kc)local kf=0;local kg=an+k7+k8+20;local kh=am;if k6~="YAW"then kg=je(130)kh=jd(960)end;local ki=[[<path class="txttick line" d="]]local kj=bN(ke-(kd+10)-ke%5+0.5)for M=kj+70,kj,-5 do local hA=kh-(-M*5+kc*5)if M%10==0 then kf=10;local dD=M;if dD==360 then dD=0 elseif dD>360 then dD=dD-360 elseif dD<0 then dD=dD+360 end;jZ[#jZ+1]=gN(hA,kg+15,dD,"txtmid bright")elseif M%5==0 then kf=5 end;if kf==10 then ki=dk([[%s M %f %f v %d]],ki,hA,kg-5,kf)else ki=dk([[%s M %f %f v %d]],ki,hA,kg-2.5,kf)end end;jZ[#jZ+1]=ki..[["/>]]jZ[#jZ+1]=dk([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kh-5,kg-20,kh+5,kg-20,kh,kg-10)if cY then k6="HDG"end;jZ[#jZ+1]=gN(jd(960),je(100),ke.."Â°","dim txt txtmid size14","")jZ[#jZ+1]=gN(jd(960),je(85),k6,"dim txt txtmid size20","")jZ[#jZ+1]=[[</g>]]end;local function kk(jZ,kl,k5,am,an,cY,km,fp)if af==0 then return end;local k7=af;local kn=bN(k7*3/5)if k7>0 then local ko=bN(kl)local kb=0;local ki=dk([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k5,am,an)if not cg then ki=dk([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],am,an)end;jZ[#jZ+1]=dk([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k7-1,am,an)jZ[#jZ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(ko-30-ko%5+0.5),bN(ko+30+ko%5+0.5),5 do if M%10==0 then kb=30 elseif M%5==0 then kb=20 end;local hB=an+-M*5+kl*5;if kb==30 then ki=dk([[%s M %d %f h %d]],ki,am-kn-kb,hB,kb)if cg then jZ[#jZ+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k5,am,an,am-kn+10,hB+4,M)jZ[#jZ+1]=dk([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k5,am,an,am+kn-10,hB+4,M)if M==0 or M==180 or M==-180 then jZ[#jZ+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k5,am,an,am-kn+20,hB,kn*2-40)end else jZ[#jZ+1]=gN(am-kn+10,hB,M,"pdim txt txtmid")jZ[#jZ+1]=gN(am+kn-10,hB,M,"pdim txt txtmid")end;ki=dk([[%s M %d %f h %d]],ki,am+kn,hB,kb)else ki=dk([[%s M %d %f h %d]],ki,am-kn-kb,hB,kb)ki=dk([[%s M %d %f h %d]],ki,am+kn,hB,kb)end end;jZ[#jZ+1]=ki..[["/>]]local kp="PITCH"if not cY then kp="REL PITCH"end;if kl>90 and not cg then kl=90-(kl-90)elseif kl<-90 and not cg then kl=-90-(kl+90)end;if k7>200 then if cg then if fp>iZ then jZ[#jZ+1]=gN(am,an-15,"Yaw","pdim txt txtmid")jZ[#jZ+1]=gN(am,an+20,km,"pdim txt txtmid")end;jZ[#jZ+1]=dk([[<g transform="rotate(%f,%d,%d)">]],-k5,am,an)else jZ[#jZ+1]=dk([[<g transform="rotate(0,%d,%d)">]],am,an)end;jZ[#jZ+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am-kn+25,an-5,am-kn+20,an,am-kn+25,an+5,am-kn+50,an+4,ko)jZ[#jZ+1]=dk([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],am+kn-25,an-5,am+kn-20,an,am+kn-25,an+5,am+kn-30,an+4,ko)jZ[#jZ+1]="</g>"end;local kq=bN(k7/3)jZ[#jZ+1]=dk([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],am-kq,an,k7-kq)if not cg and cY then jZ[#jZ+1]=dk([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k5,am,an,am-kn+10,an,kn*2-20)end;jZ[#jZ+1]="</g>"if k7<200 then if cg and fp>iZ then jZ[#jZ+1]=gN(am,an-k7,kp,"pdim txt txtmid")jZ[#jZ+1]=gN(am,an-k7+10,ko,"pdim txt txtmid")jZ[#jZ+1]=gN(am,an-15,"Yaw","pdim txt txtmid")jZ[#jZ+1]=gN(am,an+20,km,"pdim txt txtmid")else jZ[#jZ+1]=gN(am,an-k7,kp,"pdim txt txtmid")jZ[#jZ+1]=gN(am,an-k7+15,ko,"pdim txt txtmid")end end end end;local function kr(jZ,e3,cY)local ks=as;local kt=at;if ks==0 and kt==0 then return end;local ku=78;local kv=19;local kw=cf;if cf~=-1 then jZ[#jZ+1]=gN(ks+ku,kt+kv+20,dk("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(e3<200000 and not cg or e3 and cg)then table.insert(jZ,dk([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ks-1,kt-4,ku+2,kv+6,ks+1,kt-1,ku-4,kv))local gw=0;local kx=1;local ky=0;local kz=e3<0;local kA=e3<kB.surfaceMaxAltitude;local kC=9;if kz then kC=0 end;local e3=eZ(e3)while gw<6 do local kD=11;local kE=16;local kF=9;local kG=14;local jT="altsm"if gw>2 then kE=kE+3;kD=kD+2;kG=kG+2;kF=kF-6;jT="altbig"end;if kz then jT=jT.." red"elseif kA then jT=jT.." orange"end;local kH=e3/kx%10;local kI=bN(kH)local kJ=bN((kI+1)%10)local kK=ky;if gw==0 then kK=kH-kI;if kz then kK=1-kK end end;if kz and(gw==0 or ky~=0)then local gz=kJ;kJ=kI;kI=gz end;local kL=kE*(kK-1)local kM=kL+kE;local hA=ks+kF+(6-gw)*kD;local hB=kt+kG;jZ[#jZ+1]=gN(hA,hB+kL,kJ,jT)jZ[#jZ+1]=gN(hA,hB+kM,kI,jT)gw=gw+1;kx=kx*10;if kI==kC then ky=kK else ky=0 end end;table.insert(jZ,[[</g></g>]])end end;local function kN(fu)local kO=-math.deg(eU(fu.y,fu.z))+180;kO=kO-90;if kO<0 then kO=360+kO end;if kO>180 then kO=-180+kO-180 end;return-kO end;local function kP(fu)local kc=math.deg(eU(fu.y,fu.x))-90;if kc<-180 then kc=360+kc end;return kc end;local function kQ(jZ,fu,fp,am,an)if fp>5 and not cg or fp>iZ then local k7=af;local kR=20;local kS=20;local kT=kN(fu)local kU=kP(fu)local kV=14;local kW=kV/2;local kX=-kU/kS*k7;local kY=kT/kR*k7;local hA=am+kX;local hB=an+kY;local cb=dn(kX^2+kY^2)local kZ=[[<circle
                            cx="]]..hA..[["
                            cy="]]..hB..[["
                            r="]]..kW/kV..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hA..[["
                            cy="]]..hB..[["
                            r="]]..kW..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hA-kV..[[,]]..hB..[[ h ]]..kW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hA+kW..[[,]]..hB..[[ h ]]..kW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hA..[[,]]..hB-kV..[[ v ]]..kW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<k7 then jZ[#jZ+1]=kZ else local j_=eU(kY,kX)local k_=4;local l0=am+k7*math.cos(j_)local l1=an+k7*math.sin(j_)jZ[#jZ+1]=dk('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',j_*180/math.pi,l0,l1,l0-k_,l1-k_/2,k_*2,k_,l0+k_,l1-k_,k_,k_,-k_,k_)end;if not cg then local l2=vec3(fu)kT=kN(-l2)kU=kP(-l2)kX=-kU/kS*k7;kY=kT/kR*k7;hA=am+kX;hB=an+kY;cb=dn(kX^2+kY^2)if cb<k7 then local l3=[[<circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hA..[[,]]..hB-kV..[[ v ]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hA..[[,]]..hB..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hA..[[,]]..hB..[[)" />
                                <path
                                    d="M ]]..hA-kW..[[,]]..hB..[[ h ]]..kV..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hA..[[,]]..hB..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hA..[[,]]..hB..[[)"/>]]jZ[#jZ+1]=l3 end end end end;local function l4(jZ,jh,l5,l6)if ao==0 and ap==0 then return end;l5=bN(l5+0.5)local jI=ap+10;local jJ=ap+20;if iF()==1 and not l then jI=55;jJ=65 end;local l7="CRUISE"local c="km/h"local dM=l6;if jh=="TRAVEL"or jh=="AUTOPILOT"then l7="THROT"c="%"dM=l5;local l8="dim"if l5<0 then l8="red"end;jZ[#jZ+1]=dk([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l8,ao-7,ap-50,ao,ap-50,ao,ap+50,ao-7,ap+50,1-eZ(l5),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)end;jZ[#jZ+1]=gN(ao+10,jI,l7,"pbright txtstart")jZ[#jZ+1]=gN(ao+10,jJ,dk("%.0f %s",dM,c),"pbright txtstart")if cg and t and cR and bT then l5=bN(bU*100+0.5)local l8="red"if l5<0 then l8="red"end;jZ[#jZ+1]=dk([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l8,1-eZ(l5),ao-10,ap+50,ao-15,ap+53,ao-15,ap+47)jZ[#jZ+1]=gN(ao+10,jI+40,"LIMIT","pbright txtstart")jZ[#jZ+1]=gN(ao+10,jJ+40,l5 .."%","pbright txtstart")end;if cg and t or b9 then jZ[#jZ+1]=gN(ao+10,jI-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b4 then jZ[#jZ+1]=gN(ao+10,jI-40,"LIMIT: "..bN(ac*3.6+0.5).." km/h","dim txtstart")end end;local function l9(jZ,la)if ao==0 and ap==0 then return end;local lb=ap-10;local lc=ao+10;jZ[#jZ+1]=gN(0,0,"","pdim txt txtend")if iF()==1 and not l then lb=75 end;jZ[#jZ+1]=gN(lc,lb,bN(la).." km/h","pbright txtbig txtstart")end;local ld=40;local function le(jZ)jZ[#jZ+1]=gN(jd(150),je(1070),dk("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jZ[#jZ+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jZ[#jZ+1]=gN(jd(960),je(550),"Warning: Invalid Control Scheme Detected","warnings")jZ[#jZ+1]=gN(jd(960),je(600),"Keyboard Scheme must be selected","warnings")jZ[#jZ+1]=gN(jd(960),je(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lf=jd(960)local lg=je(860)local lh=je(880)local li=je(900)local lj=je(960)local lk=je(200)local ll=je(250)local lm=je(960)if iF()==1 and not l then lg=je(135)lh=je(155)li=je(175)lk=je(115)ll=je(95)end;if b1 then local ln=""if type(b1)=="string"then ln="-"..b1 end;jZ[#jZ+1]=gN(lf,lg,"Brake Engaged"..ln,"warnings")elseif bS>0 then jZ[#jZ+1]=gN(lf,lg,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b4 and not br and not b7 and not cQ and not ba and not b8 then jZ[#jZ+1]=gN(lf,lk+50,"** STALL WARNING **","warnings")fU("stall","SW",2)end end;if cX then jZ[#jZ+1]=gN(lf,lk+90,"Flight Assist in Progress","warnings")end;if ck then jZ[#jZ+1]=gN(lf,lm,"Gyro Enabled","warnings")end;if lo then ld=ld-1;if ld>20 then jZ[#jZ+1]=gN(lf,lm-20,"ECU Enabled","warnings")elseif ld<0 then ld=40 end end;if bn then if bW then jZ[#jZ+1]=gN(lf,lh,"Gear Extended","warn")else jZ[#jZ+1]=gN(lf,lh,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local lp=iK(d:getTargetGroundAltitude())jZ[#jZ+1]=gN(lf,li,"Hover Height: "..lp,"warn")end;if c5 then jZ[#jZ+1]=gN(lf,lj+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not q and cQ and bw~=nil then local lq="warnings"if eZ(ci-antigrav.getBaseAltitude())<501 then lq="warn"end;jZ[#jZ+1]=gN(lf,lk+40,dk("Target Altitude: %d Singularity Altitude: %d",bN(bw),bN(antigrav.getBaseAltitude())),lq)end;if b4 and bk~="None"then jZ[#jZ+1]=gN(lf,lk,"Autopilot "..bh,"warn")elseif bu~=nil then jZ[#jZ+1]=gN(lf,lk+20,dk("LockedPitch: %d",bN(bu)),"warn")elseif c0 then jZ[#jZ+1]=gN(lf,lk+20,"Follow Mode Engaged","warn")elseif b9 or ce then jZ[#jZ+1]=gN(lf,lk+20,"Re-entry in Progress","warn")end;if b6 or ba then local lp=iK(bb,2)if ba then if cQ then lp=iK(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jZ[#jZ+1]=gN(lf,lk,"VTO to "..lp,"warn")elseif b8 and not bA then if cd then jZ[#jZ+1]=gN(lf,lk,"Takeoff to "..bk,"warn")else jZ[#jZ+1]=gN(lf,lk,"Takeoff to "..lp,"warn")end;if b1 and not ba then jZ[#jZ+1]=gN(lf,lk+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jZ[#jZ+1]=gN(lf,lk,"Altitude Hold: "..dk("%.1fm",bb),"warn")end end;if ba and(antigrav~=nil and antigrav)then if ch>0.1 then jZ[#jZ+1]=gN(lf,lk+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then jZ[#jZ+1]=gN(lf,lk+20,"Aligning trajectory","warn")elseif ch<0.05 then jZ[#jZ+1]=gN(lf,lk+20,"Leaving atmosphere","warn")end end;if bA then if cC~=nil then jZ[#jZ+1]=gN(lf,lk,cC,"warn")end end;if b7 then if lr then local ls="Brake Landing"if dc then ls=ls.."-Aligning"end;if db then ls=ls.."-Drift Limited"end;jZ[#jZ+1]=gN(lf,lk,ls,"warnings")else jZ[#jZ+1]=gN(lf,lk,"Coast-Landing","warnings")end end;if b3 then jZ[#jZ+1]=gN(lf,lk,"Prograde Alignment","crit")end;if b2 then jZ[#jZ+1]=gN(lf,lk,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;jZ[#jZ+1]=gN(lf,ll+20,cZ,type)elseif ch==0 then local lt,lu=ct.checkLOS(cK:normalize())if lu~=nil then local lp=iK(lu)local lv=cp.computeTravelTime(cL,0,lu)local lw="Collision"if lt.noAtmosphericDensityAltitude>0 then lw="Atmosphere"end;jZ[#jZ+1]=gN(lf,ll+20,lt.name.." "..lw.." "..iL(lv).." In "..lp,"crit")end end;if br and not bA then jZ[#jZ+1]=gN(lf,lk+60,lx,"warn")end;if d2 and#d2>1 then end;local ly=jd;local lz=je;local lA="topButton"local lB="topButtonActive"local lC=lA;if b4 or br or cd or bA then lC=lB end;local lD=lA;if b3 then lD=lB end;local lE=lA;if b7 or bn then lE=lB end;local lF=lA;if b6 or br then lF=lB end;local lG=lA;if b2 then lG=lB end;local lH=lA;if bA or cE and b4 then lH=lB end;if w and I then local lI=lz(30)jZ[#jZ+1]=dk([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lC,ly(960),lz(54),lz(-53),ly(-120),ly(25),lz(50))jZ[#jZ+1]=gN(ly(910),lI,"AUTOPILOT")jZ[#jZ+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,ly(865),lz(51),ly(-25),lz(-50),ly(-110),ly(25),lz(46))jZ[#jZ+1]=gN(ly(800),lI,"PROGRADE")jZ[#jZ+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,ly(755),lz(47),ly(-25),lz(-46),ly(-98),ly(44),lz(44))jZ[#jZ+1]=gN(ly(700),lI,"LAND")jZ[#jZ+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lF,ly(960),lz(54),lz(-53),ly(120),ly(-25),lz(50))jZ[#jZ+1]=gN(ly(1010),lI,"ALT HOLD")jZ[#jZ+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,ly(1055),lz(51),ly(25),lz(-50),ly(110),ly(-25),lz(46))jZ[#jZ+1]=gN(ly(1122),lI,"RETROGRADE")jZ[#jZ+1]=dk([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,ly(1165),lz(47),ly(25),lz(-46),ly(98),ly(-44),lz(44))jZ[#jZ+1]=gN(ly(1220),lI,"ORBIT")jZ[#jZ+1]=[[
                                    </g>
                                </g>]]jZ[#jZ+1]="</g>"end;return jZ end;local function lJ(fp)return bN(fV(fp*3.6,0)+0.5).." km/h"end;local function lK(gw)local gy=bk;if gw~=nil and type(gw)=="number"then if gw==0 then return"None"end;gy=cU[gw].name end;if gy==nil then gy=g5.name end;if gy==nil then gy="None"end;return gy end;local function lL(jZ)local lM=ct.routeWP(true)if not lM or#lM==0 then return end;local hA=jd(750)local hB=je(360)if b4 or br then jZ[#jZ+1]=gN(hA,hB,"REMAINING ROUTE","pdim txtstart size20")else jZ[#jZ+1]=gN(hA,hB,"LOADED ROUTE","pdim txtstart size20")end;for dL,M in pairs(lM)do hB=hB+20;jZ[#jZ+1]=gN(hA,hB,dL..". "..lM[dL],"pdim txtstart size20")end end;local function lN(jZ)local hA=aC+10;local hB=aD+20;local lO={}local lP={"Alt-4: AutoTakeoff to Target"}local lQ={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lR={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lS={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lO,"--------------DYNAMIC-----------------")if cg then if cf~=-1 then iI(lO,lP)if c8 and kB and c8.name==kB.name then table.insert(lO,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b0 then if antigrav then if cQ then table.insert(lO,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lO,"Turn on AGG to takeoff to AGG Height")end end;if b0 then table.insert(lO,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lO,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lO,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bn then table.insert(lO,"G: Takeoff to hover height, raise gear")else table.insert(lO,"G: Lowergear and Land")end else iI(lO,lQ)table.insert(lO,"G: Begin BrakeLanding or Land")end;if ba then table.insert(lO,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iI(lO,lR)if shield then table.insert(lO,"Alt-Shift-6: Vent shields")if not G then table.insert(lO,"Alt-Shift-7: Toggle shield off/on")end end end;if g5~=nil then table.insert(lO,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lO,"Alt-9: Activate Gyroscope")end;if aW~="none"or aV~="none"or aX~="none"then table.insert(lO,"Alt-Shift-9: Cycles engines with Extra tags")end;if b6 then table.insert(lO,"Alt-Spacebar/C will raise/lower target height")table.insert(lO,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cg then table.insert(lO,"LALT+Mousewheel will lower/raise speed limit")end;iI(lO,lS)for M=1,#lO do hB=hB+12;jZ[#jZ+1]=gN(hA,hB,lO[M],"pdim txtbig txtstart")end end;local function lT(jZ)local lU=aC;local lV=aD;local lW=aB;local lX=4;local lY=15;local hA=0;local hB=0;local lZ,l_,m0,m1;local m2;local function m3(type)local gI,bQ,fp,m4,jT,m5;if type=="Periapsis"then gI=m2.periapsis.altitude;bQ=m2.timeToPeriapsis;fp=m2.periapsis.speed;jT="txtend"m4=12;m5=math.min(hA,lU+lW-kB.radius/m0-lX*2)else gI=m2.apoapsis.altitude;bQ=m2.timeToApoapsis;fp=m2.apoapsis.speed;m4=-12;jT="txtstart"m5=hA end;if cL<1 then bQ=0 end;jZ[#jZ+1]=dk([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m5+m4,hB-5,hA,hB-5)jZ[#jZ+1]=dk([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m5-m4*4,hB+2,hA,hB+2)jZ[#jZ+1]=gN(m5,hB,type,jT)hA=m5-m4*2;hB=hB+lY;local lp=iK(gI)jZ[#jZ+1]=gN(hA,hB,lp,jT)hB=hB+lY;jZ[#jZ+1]=gN(hA,hB,iL(bQ),jT)hB=hB+lY;jZ[#jZ+1]=gN(hA,hB,lJ(fp),jT)end;local m6=lW*1.5;if bK=="INFO"then m6=25*10 end;if bK=="ORBIT"and ci<kB.spaceEngineMinAltitude then return jZ end;if bK~="HIDE"then jZ[#jZ+1]=[[<g class="pbright txtorb txtmid">]]jZ[#jZ+1]=dk('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lW*2,m6,lU,lV)jZ[#jZ+1]=dk([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lW*2,m6,lU,lV)end;local m7=lW*1.5;local m8=lW*2;local m9=m7/2;local ma=lW;local mb=lU+ma;local mc=lV+m9;local md=lU+m8;local me=lV+m7;if bK=="ORBIT"then lV=lV+lX;lZ=lW/2;m1=0;m2={}m2.periapsis={}m2.apoapsis={}if ft~=nil then if ft.periapsis~=nil then m2.periapsis.altitude=ft.periapsis.altitude;m2.periapsis.speed=ft.periapsis.speed end;if ft.apoapsis~=nil then m2.apoapsis.altitude=ft.apoapsis.altitude;m2.apoapsis.speed=ft.apoapsis.speed end;m2.period=ft.period;m2.eccentricity=ft.eccentricity;m2.timeToApoapsis=ft.timeToApoapsis;m2.timeToPeriapsis=ft.timeToPeriapsis;m2.eccentricAnomaly=ft.eccentricAnomaly;m2.trueAnomaly=ft.trueAnomaly end;if m2.periapsis==nil then m2.periapsis={}m2.periapsis.altitude=-kB.radius;m2.periapsis.speed=ac end;if m2.eccentricity==nil then m2.eccentricity=1 end;if m2.apoapsis==nil then m2.apoapsis={}m2.apoapsis.altitude=ci;m2.apoapsis.speed=0 end;if cL<1 then m2.apoapsis.altitude=ci;m2.apoapsis.speed=0 end;if m2.apoapsis.altitude then m0=(m2.apoapsis.altitude+m2.periapsis.altitude+kB.radius*2)/(lZ*2)l_=(kB.radius+m2.apoapsis.altitude)/m0*(1-m2.eccentricity)m1=lZ-m2.periapsis.altitude/m0-kB.radius/m0;local mf=math.pi;if m2.period~=nil and m2.period>0 and m2.timeToApoapsis~=nil then mf=m2.eccentricAnomaly;if m2.timeToPeriapsis<m2.timeToApoapsis then mf=2*math.pi-mf end end;if cL<1 or mf~=mf then mf=math.pi end;local mg=-lZ*math.cos(mf)+lU+ma+lX;local mh=l_*math.sin(mf)+lV+m9+lX;local mi=""jZ[#jZ+1]='<g clip-path="url(#orbitRect)">'jZ[#jZ+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mi,lU+lW+lX,lV+lW*1.5/2+lX,lZ,l_)if l_<1 then jZ[#jZ+1]=dk([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lU+lW+lX-m1,lV+lW*1.5/2+lX,mg,mh)end;jZ[#jZ+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lU+lW+lX-m1,lV+lW*1.5/2+lX,(kB.radius+kB.noAtmosphericDensityAltitude)/m0)jZ[#jZ+1]=dk('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lU+lW+lX-m1,lV+lW*1.5/2+lX,(kB.radius+kB.noAtmosphericDensityAltitude)/m0)jZ[#jZ+1]=dk([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lU+lW+lX,lV+lW*1.5/2+lX,lZ,l_)jZ[#jZ+1]=dk('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lU+lW+lX-m1,lV+lW*1.5/2+lX,kB.radius/m0)jZ[#jZ+1]='</g>'local mj=math.floor(kB.radius/m0+0.5)hA=lU+lW+lX*4+lZ;hB=lV+lW*1.5/2+5+lX;if m2.apoapsis~=nil and m2.apoapsis.speed<ac then m3("Apoapsis")end;hB=lV+lW*1.5/2+5+lX;hA=lU+lW-lX*2-lZ;if m2.periapsis~=nil and m2.periapsis.speed<ac and m2.periapsis.altitude>0 then m3("Periapsis")end;jZ[#jZ+1]=gN(lU+lW+lX,lV+20+lX,kB.name,"txtorbbig")jZ[#jZ+1]=dk('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mg,mh)jZ[#jZ+1]=[[</g>]]return jZ else jZ[#jZ+1]='<g clip-path="url(#orbitRect)">'local mk=""local ml=1.2*(mm-mn)/(lW*2)local mo=1.4*(mp-mq)/(lW*1.5)for dL,dx in pairs(e[0])do if dx.center then local hA=lU+lW+dx.center.x/ml;local hB=lV+lW*1.5/2+dx.center.y/mo;mk=mk..'<circle cx="'..hA..'" cy="'..hB..'" r="'..dx.radius/ml*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dx.name,"Moon")and not string.match(dx.name,"Sanctuary")and not string.match(dx.name,"Space")then mk=mk.."<text x='"..hA.."' y='"..hB+dx.radius/ml*30+20 .."' font-size='12' fill="..j5 .." text-anchor='middle' font-family='Montserrat'>"..dx.name.."</text>"end end end;local fv=vec3(bP.getWorldPosition())local hA=lU+lW+fv.x/ml;local hB=lV+lW*1.5/2+fv.y/mo;mk=mk..'<circle cx="'..hA..'" cy="'..hB..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mk=mk.."<text x='"..hA.."' y='"..hB-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iT=ml;iU=mo;local mr=fv+cK*1000000;local ms=lU+lW+mr.x/ml;local jJ=lV+lW*1.5/2+mr.y/mo;mk=mk..'<line x1="'..hA..'" y1="'..hB..'" x2="'..ms..'" y2="'..jJ..'" stroke="purple" stroke-width="1"/>'jZ[#jZ+1]=mk;jZ[#jZ+1]='</g>'end elseif bK=="INFO"then jZ=cr.DrawOdometer(jZ,j7,bo,j8)elseif bK=="HELP"then jZ=lN(jZ)elseif bK=="SCOPE"then jZ[#jZ+1]='<g clip-path="url(#orbitRect)">'local mt=d5;if ch>0 then table.sort(d4,function(eA,eB)local eC,eD=eA.center,eB.center;return(eC.x-cO.x)^2+(eC.y-cO.y)^2+(eC.z-cO.z)^2<(eD.x-cO.x)^2+(eD.y-cO.y)^2+(eD.z-cO.z)^2 end)end;local mu={}local mv={}local mw=120;local mx=nil;local my=nil;for M,dx in ipairs(d4)do local gV=dx.center-cO;local mz=gV:len()local mA=gV:normalize()local mB=gV:cross(cH):normalize()local mC=math.acos(mB:dot(cI))if mC~=mC then mC=0 end;if mB:cross(cI):dot(cH)<0 then mC=-mC end;local mD=gV:project_on_plane(cH):len()local mE=math.sin(mC)*math.asin(mD/mz)*constants.rad2deg;local mF=math.cos(mC)*math.asin(mD/mz)*constants.rad2deg;if mA:dot(cH)<0 then mF=90*math.cos(mC)+90*math.cos(mC)-mF;mE=90*math.sin(mC)+90*math.sin(mC)-mE end;local hA=mb+mE/mt*m7;local hB=mc+mF/mt*m7;local mG=(hA-mb)*(hA-mb)+(hB-mc)*(hB-mc)local mH=math.asin((dx.radius+dx.surfaceMaxAltitude)/mz)*constants.rad2deg;if mH~=mH then mH=mt end;local h_=mH/mt*m7;local mI=math.asin(dx.atmosphereRadius/mz)*constants.rad2deg;if mI~=mI then mI=mH end;local mJ=mI/mt*m7;local cb=iK(mz,1)local mK=dx.name;local mL=false;if hB>lV then if hB>me then if hB-mJ<=me then mL=true end else mL=true end else if hB+mJ>=lV then mL=true end end;local mM=false;local mN=hA;if dx.systemId==0 then mN=hA+mw else mN=hA-mw end;if mN+mw>lU then if mN+mw>md then if mN-mJ-mw<=md then mM=true end else mM=true end else if mN+mJ+mw>=lU then mM=true end end;local mO={}mO.x=hA;mO.y=hB;mO.planet=dx;mO.atmoSize=mJ;if not mx or mG<mx then mx=mG;my=mO end;if mM and mL then local mP=math.max(mJ,5)if mG<mP*mP then mK=mK.." - "..cb end;mO.size=h_;mO.i=M;mO.displayString=mK;mO.distance=cb;mO.visible=true;mv[#mv+1]=mO else mO.visible=false end end;local mQ=false;table.sort(mv,function(eC,eD)return eC.y<eD.y end)for dL,fy in ipairs(mv)do local dx,h_,M,mJ,hA,hB,mK,cb=fy.planet,fy.size,fy.i,fy.atmoSize,fy.x,fy.y,fy.displayString,fy.distance;local m5,mR,mS,mT;local mU=15;local jT="pdim"if dx.systemId~=0 then mS=jd(string.len(mK)*5)mU=-(15+mS)mT=je(10)jT="pdimfill"else mS=jd(string.len(mK)*9)mT=je(15)end;if h_*2>mS then m5=dl(hA,lU+mS/2,md-mS/2)mR=dl(hB,lV+mT,me-5)m5=dl(m5,hA-h_+mS/2,hA+h_-mS/2)mR=dl(mR,hB-h_+mT,hB+h_)else m5=hA+mU;mR=hB end;for mV,fy in pairs(mu)do local mW=fy.textPositions;local mX=mW.y-mR;if mV~=M and eZ(mX)<mW.height and mW.x+mW.width>m5 and mW.x<m5+mS then if h_>mS then mR=dl(mR+mT,lV+15,me-5)else mR=mW.y+mW.height+1 end end end;local mY=mK~=dx.name or m5<=mb and m5+mS>=mb and mR-mT<=mc and mR>=mc;fy.hovered=mY;local mZ=1;if mY then mZ=2;if h_*2<mS then mZ=10 end;if mK==dx.name then mK=mK.." - "..cb end;jT="pbright"if dx.systemId~=0 then mS=jd(string.len(mK)*5)mU=-(15+mS)else mS=jd(string.len(mK)*7)end;if h_*2>mS then m5=dl(hA,lU+mS/2,md-mS/2)m5=dl(m5,hA-h_+mS/2,hA+h_-mS/2)else m5=hA+mU end end;mu[M]={}mu[M].textPositions={}mu[M].textPositions.y=mR;mu[M].textPositions.x=m5;mu[M].textPositions.width=mS;mu[M].textPositions.height=mT;mu[M].output=""if h_*2>mS then jT=jT.." txtmid"else jT=jT.." txtstart"end;if mJ-h_>2 then mu[M].output=dk('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hA,hB,mJ,j6,0.1*mZ)end;mu[M].output=mu[M].output..dk('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hA,hB,h_,j6,0.2*mZ)if dx.systemId==0 then mu[M].output=mu[M].output..dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m5,mR,j5,jT,mK)if h_*2<=mS then mu[M].output=mu[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m5+mS,mR+2,m5,mR+2,hA,hB)end else mu[M].output=mu[M].output..dk([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m5,mR,j6,jT,mK)if h_*2<=mS then mu[M].output=mu[M].output..dk("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m5,mR+2,m5+mS,mR+2,hA,hB)end end end;for dL=#d4,1,-1 do if mu[dL]then jZ[#jZ+1]=mu[dL].output end end;if my~=nil and d5<90 and not my.hovered then local m_=my.planet.atmosphereRadius/my.atmoSize;local n0=dn(mx)*m_;local n1=iK(n0,1)local mS=jd(math.max(string.len(n1)*7,string.len(my.planet.name)*7))local mT=je(12)local m5=dl(my.x+(mb-my.x)/2,lU+mS/2,md-mS/2)local mR=dl(my.y+(mc-my.y)/2,lV+mT*2,me-5)jZ[#jZ+1]=dk("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",my.x,my.y,mb,mc)jZ[#jZ+1]=dk([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m5,mR,"white",n1)if not my.visible then jZ[#jZ+1]=dk([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m5,mR-mT,"white",my.planet.name)end end;if cL>1 then local gV=cK;local mA=gV:normalize()local mD=gV:project_on_plane(cH):len()local mB=gV:cross(cH):normalize()local mC=math.acos(mB:dot(cI))if mC~=mC then mC=0 end;if mB:cross(cI):dot(cH)<0 then mC=-mC end;local mE=math.sin(mC)*math.asin(mD/gV:len())*constants.rad2deg;local mF=math.cos(mC)*math.asin(mD/gV:len())*constants.rad2deg;if mA:dot(cH)<0 then mF=90*math.cos(mC)+90*math.cos(mC)-mF;mE=90*math.sin(mC)+90*math.sin(mC)-mE end;local hA=mb+mE/mt*m7;local hB=mc+mF/mt*m7;local kV=14;local kW=kV/2;local kZ=[[<circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kW/kV..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hA-kV..[[,]]..hB..[[ h ]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hA+kW..[[,]]..hB..[[ h ]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hA..[[,]]..hB-kV..[[ v ]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jZ[#jZ+1]=kZ end;jZ[#jZ+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mb,mc-10,mb,mc+10)jZ[#jZ+1]=dk("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mb-10,mc,mb+10,mc)jZ[#jZ+1]='</g>'else return jZ end end;local function n2(n3,n4)local n5;local n6=(n4-n3):normalize()local fw=(cO-n3):dot(n6)/n6:dot(n6)if fw<=0. then return(cO-n3):len()elseif fw>=(n4-n3):len()then return(cO-n4):len()end;local n7=n3+fw*n6;n5=(n7-cO):len()return n5 end;local function n8()local n5;local n9=nil;local na=nil;local nb=nil;for dL,nc in pairs(e[0])do if nc.hasAtmosphere then local cb=n2(kB.center,nc.center)if n9==nil or cb<n9 then na=nc;n9=cb;nb=kB end;if c8 and c8.hasAtmosphere and c8.name~=kB.name then local eP=n2(c8.center,nc.center)if eP<n9 then na=nc;n9=eP;nb=c8 end end end end;local nd=jd(1770)local ne=je(330)if n9 then local nf="txttick "local ng=500000;if n9<na.radius+ng or n9<nb.radius+ng then if cV then nf="txttick red "else nf="txttick orange "end end;n5=iK(n9,2)iY=gN(nd,ne,"Pipe ("..nb.name.."--"..na.name.."): "..n5,nf.."pbright txtmid")end end;local function nh(hA,hB,ni,nj,l7)local nk={x=hA,y=hB,width=ni,height=nj,label=l7}iS[l7]=nk;return nk end;local function nl(nm,nn,ni,nj,hA,hB,no,np,nq,nr,jT)local nk={enableName=nm,disableName=nn,width=ni,height=nj,x=hA,y=hB,toggleVar=no,toggleFunction=np,drawCondition=nq,hovered=false,class=jT}if nr then table.insert(iR,nk)else table.insert(iQ,nk)end;return nk end;local function ns(nt)if not iW then nu=false;nv=false;nw=false;w=true;return elseif nt=="handling"then nu=not nu;nv=false;nw=false elseif nt=="hud"then nv=not nv;nu=false;nw=false elseif nt=="physics"then nw=not nw;nu=false;nv=false end;if nw or nv or nu then iX=iJ(nt)w=false else iX="none"w=true end end;local function nx()iW=not iW;if iW then iP=iR;c3="Tap SHIFT to see Settings"d6=w else iP=iQ;c3="Tap SHIFT to see Control Buttons"ns()w=d6 end end;local function ny()local function nz(dx,dL)dx.set(not dx.get())if dx.get()then c3=dL.." set to true"else c3=dL.." set to false"end;if dL=="showHud"then d6=dx.get()elseif dL=="BrakeToggleDefault"then a_=j elseif dL=="FullRadar"then if not J then dh("HERE1")cu.ToggleRadarPanel()J=false;dh("HERE2")else dh("HERE3")J=true;nA.radarSetup()dh("HERE4")end end end;local nB=50;local nC=340;local hA=500;local hB=ae/2-400;local nD=0;for dL,dx in pairs(iJ("boolean"))do if type(dx.get())=="boolean"then nl(dL,dL,nC,nB,hA,hB,function()return dx.get()end,function()nz(dx,dL)end,function()return true end,true)hB=hB+nB+20;if nD==9 then hA=hA+nC+20;hB=ae/2-400;nD=0 else nD=nD+1 end end end;nl("Control View","Control View",nC,nB,10,ae/2-500,function()return true end,nx,function()return true end,true)nl("View Handling Settings",'Hide Handling Settings',nC,nB,10,ae/2-(500-nB),function()return nu end,function()ns("handling")end,function()return true end,true)nl("View Hud Settings",'Hide Hud Settings',nC,nB,10,ae/2-(500-nB*2),function()return nv end,function()ns("hud")end,function()return true end,true)nl("View Physics Settings",'Hide Physics Settings',nC,nB,10,ae/2-(500-nB*3),function()return nw end,function()ns("physics")end,function()return true end,true)end;local function nE()local function gx()local fX=cO;local gy=kB.name..". "..#bq;if cu then gy=cu.GetClosestName(gy)end;return cs.AddNewLocation(gy,fX,false,true)end;local function nF()b5=not b5 end;local function nG(nH)if nH==1 then b3=not b3;b2=false else b2=not b2;b3=false end;b4=false;b6=false;c0=false;b7=false;bu=nil;b9=false;b8=false end;local function nI(nJ,nK)cs.UpdatePosition(nil,nJ,nK)end;local function gs()cs.ClearCurrentPosition()end;local function nL(gw)local lM=ct.routeWP(true)if lM and#lM>0 then return"Engage Route: "..lM[1]end;return"Engage Autopilot: "..lK(gw)end;local function nM(gw)local lM=ct.routeWP(true)if lM and#lM>0 then return"Next Route Point: "..lM[1]end;return"Disable Autopilot: "..lK(gw)end;local function nN()if iF()==1 then c0=not c0;if c0 then b4=false;b2=false;b3=false;b6=false;b9=false;b7=false;b8=false;nO=bn;bn=false;d.control.retractLandingGears()iG:setTargetGroundAltitude(_)fU("folOn","F")else fU("folOff","F")b1="Follow Off"cz=p;bn=nO;if bn then d.control.deployLandingGears()iG:setTargetGroundAltitude(a0)end end else c3="Follow Mode only works with Remote controller"c0=false end end;local nB=50;local nC=260;local nP=jd(30)local nQ=aC+aB*2+2;local nR=aD+1;nl("+","+",nP,nP,nQ,nR+nP+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")nl("-","-",nP,nP,nQ,nR,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")nl("0","0",nP,nP,nQ,nR+nP*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nS=nl("Enable Brake Toggle","Disable Brake Toggle",nC,nB,ad/2-nC/2,ae/2+350,function()return a_ end,function()a_=not a_;if a_ then c3="Brakes in Toggle Mode"else c3="Brakes in Default Mode"end end)nl("Align Prograde","Disable Prograde",nC,nB,ad/2-nC/2-50-nS.width,ae/2-nB+380,function()return b3 end,function()nG(1)end)nl("Align Retrograde","Disable Retrograde",nC,nB,ad/2-nC/2+nS.width+50,ae/2-nB+380,function()return b2 end,nG,function()return ch==0 end)nT=nl(nL,nM,600,60,ad/2-600/2,ae/2-60/2-330,function()return b4 or br or cd or bA end,function()end)local M;local function nU(nV)local gw=d1+nV;if gw>#cU then gw=gw-#cU-1 end;if gw<0 then gw=#cU+gw end;return gw end;nW={}for M=0,10 do local nX=nl(function(eD)local gw=nU(eD.apExtraIndex)if b4 or br or cd or bA then return"Redirect: "..lK(gw)end;return nL(gw)end,function(eD)local gw=nU(eD.apExtraIndex)return nM(gw)end,600,60,ad/2-600/2,ae/2-60/2-330+60*M,function(eD)local gw=nU(eD.apExtraIndex)return gw==bm and(b4 or br or cd or bA)end,function(eD)local gw=nU(eD.apExtraIndex)local nY=bm==gw;bm=gw;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not nY and not(b4 or br or cd or bA)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nX.apExtraIndex=M;nW[M]=nX end;nl("Save Position","Save Position",200,nT.height,nT.x+nT.width+30,nT.y,function()return false end,gx,function()return bm==0 or g5==nil end)nl("Update Position","Update Position",200,nT.height,nT.x+nT.width+30,nT.y,function()return false end,function()nI(nil)end,function()return bm>0 and g5~=nil end)nl("Save Heading","Clear Heading",200,nT.height,nT.x+nT.width+30,nT.y+nT.height+20,function()return g5.heading~=nil end,function()if g5.heading~=nil then nI(false)else nI(true)end end,function()return bm>0 and g5~=nil end)nl("Save AGG Alt","Clear AGG Alt",200,nT.height,nT.x+nT.width+30,nT.y+nT.height*2+40,function()return g5.agg~=nil end,function()if g5.agg~=nil then nI(nil,false)else nI(nil,true)end end,function()return bm>0 and g5~=nil and antigrav end)nl("Clear Position","Clear Position",200,nT.height,nT.x-200-30,nT.y,function()return true end,gs,function()return bm>0 and g5~=nil end)nl("Save Route","Save Route",200,nT.height,nT.x-200-30,nT.y+nT.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)nl("Load Route","Clear Route",200,nT.height,nT.x-200-30,nT.y+nT.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b4 or br then c3="Disable Autopilot before loading route"return else ct.routeWP(false,false,1)end end,function()return true end)nB=60;nC=300;local hA=0;local hB=ae/2-150;nl("Enable Check Damage","Disable Check Damage",nC,nB,hA,hB-nB-20,function()return s end,function()s=not s end)nl("View Settings","View Settings",nC,nB,hA,hB,function()return true end,nx)hB=hB+nB+20;nl("Enable Turn and Burn","Disable Turn and Burn",nC,nB,hA,hB,function()return b5 end,nF)hA=10;hB=ae/2-300;nl("Horizontal Takeoff Mode","Vertical Takeoff Mode",nC,nB,ad/2-nC/2,hB+20,function()return b0 end,function()b0=not b0;if b0 then c3="Vertical Takeoff Mode"else c3="Horizontal Takeoff Mode"end end,function()return cP end)hB=hB+nB+20;nl("Engage Orbiting","Cancel Orbiting",nC,nB,hA+nC+20,hB,function()return bA end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hB=ae/2-150;nl("Glide Re-Entry","Cancel Glide Re-Entry",nC,nB,hA+nC+20,hB,function()return b9 end,function()cc=1;nG(1)end,function()return kB.hasAtmosphere and not cg end)hB=hB+nB+20;nl("Parachute Re-Entry","Cancel Parachute Re-Entry",nC,nB,hA+nC+20,hB,function()return b9 end,function()cc=2;nG(1)end,function()return kB.hasAtmosphere and not cg end)hB=hB+nB+20;nl("Engage Follow Mode","Disable Follow Mode",nC,nB,hA,hB,function()return c0 end,nN,function()return iF()==1 end)nl("Enable Repair Arrows","Disable Repair Arrows",nC,nB,hA+nC+20,hB,function()return jb end,function()jb=not jb;if jb then c3="Repair Arrows Enabled"else c3="Repair Arrows Diabled"end end,function()return iF()==1 end)hB=hB+nB+20;if not q then nl("Enable AGG","Disable AGG",nC,nB,hA,hB,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;nl(function()return dk("Switch IPH Mode - Current: %s",bB)end,function()return dk("IPH Mode: %s",bB)end,nC*2,nB,hA,hB,function()return false end,function()if bB=="All"then bB="Custom Only"elseif bB=="Custom Only"then bB="No Moons-Asteroids"else bB="All"end;c3="IPH Mode: "..bB end)hB=hB+nB+20;nl(function()return dk("Toggle Control Scheme - Current: %s",g)end,function()return dk("Control Scheme: %s",g)end,nC*2,nB,hA,hB,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c3="New Control Scheme: "..g end)local nZ=je(20)local nX=nh(0,0,jd(70),nZ,"HELP")nX=nh(nX.x+nX.width,nX.y,jd(80),nZ,"INFO")nX=nh(nX.x+nX.width,nX.y,jd(70),nZ,"ORBIT")nX=nh(nX.x+nX.width,nX.y,jd(70),nZ,"SCOPE")nh(nX.x+nX.width,nX.y,jd(70),nZ,"HIDE")end;local n_={}local o0=nil;function n_.HUDPrologue(jZ)if not cV then j2=aj;j3=ak;j4=al else j2=ag;j3=ah;j4=ai end;j5=[[rgb(]]..bN(j2+0.6)..","..bN(j3+0.6)..","..bN(j4+0.6)..[[)]]j6=[[rgb(]]..bN(j2*0.8+0.5)..","..bN(j3*0.8+0.5)..","..bN(j4*0.8+0.5)..[[)]]local o1=j5;local o2=j6;local o3=[[rgb(]]..bN(j2*0.4+0.5)..","..bN(j3*0.4+0.5)..","..bN(j4*0.4+0.5)..[[)]]local o4=j5;local o5=j6;local o6=o3;if jf()and not m then o1=[[rgb(]]..bN(j2*0.5+0.5)..","..bN(j3*0.5+0.5)..","..bN(j4*0.5+0.5)..[[)]]o2=[[rgb(]]..bN(j2*0.3+0.5)..","..bN(j3*0.3+0.5)..","..bN(j4*0.2+0.5)..[[)]]o3=[[rgb(]]..bN(j2*0.2+0.5)..","..bN(j3*0.2+0.5)..","..bN(j4*0.2+0.5)..[[)]]end;local ly=jd;local lz=je;jZ[#jZ+1]=dk([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o1,o1,o1,o4,o4,o2,o2,o5,o5,o2,o1,o3,o5,o1,o1,o3,o3,o6,o3,ad,ae,o2,o2,o2,o2,o2,o4,o2,o5,o6,o5,o5,o6)if not o0 then o0=dk([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],ly(630),lz(0),ly(675),lz(45),ly(960),lz(55),ly(1245),lz(45),ly(1290),lz(0),ly(1000),lz(105),ly(1040),lz(59),ly(1250),lz(51),ly(1300),lz(0),ly(1920),lz(0),ly(1920),lz(20),ly(1400),lz(20),ly(1300),lz(105),ly(920),lz(105),ly(880),lz(59),ly(670),lz(51),ly(620),lz(0),ly(0),lz(0),ly(0),lz(20),ly(520),lz(20),ly(620),lz(105),ly(890),lz(59),ly(960),lz(62),ly(1030),lz(59),ly(985),lz(112),ly(1150),lz(112),ly(1100),lz(152),ly(820),lz(152),ly(780),lz(112),ly(935),lz(112),ly(890),lz(59),ly(960),lz(62),ly(1030),lz(59),ly(985),lz(112),ly(1150),lz(112),ly(1100),lz(152),ly(820),lz(152),ly(780),lz(112),ly(935),lz(112))end;if w and I then jZ[#jZ+1]=o0 end;return jZ end;function n_.DrawVerticalSpeed(jZ,e3)jY(jZ,e3)end;function n_.UpdateHud(jZ)local kO=cS;local o7=cT;local k5=o7;local kl=kO;local l5=bN(c.getThrottle())local la=cL*3.6;local l6=c.getAxisCommandValue(0)local o8=jd(1770)local o9=je(310)if t and cR then l6=bR;l5=bR*100 end;local jh=jg()local k6="ROLL"if l5==nil then l5=0 end;if not cY then if cL>5 then kO=kN(cJ)o7=kP(cJ)else kO=0;o7=0 end;k6="YAW"end;if cW>50000 and not cg then local oa;oa=iK(cW)jZ[#jZ+1]=gN(o8,o9,"PvP Boundary: "..oa,"pbright txtbig txtmid")end;jZ[#jZ+1]=j9;jZ[#jZ+1]=ie;if iY~=""then jZ[#jZ+1]=iY end;if ji~=""then jZ[#jZ+1]=ji end;if jj~=""then jZ[#jZ+1]=jj end;jY(jZ,ci)if iF()==0 or l then if not jf()or m then if cY then k4(jZ,am,an,k5,k6,cY)kk(jZ,kl,k5,am,an,cY,bN(kP(cJ)),cL)else k4(jZ,am,an,o7,k6,cY)kk(jZ,kO,o7,am,an,cY,bN(o7),cL)end;kr(jZ,ci,cY)kQ(jZ,cJ,cL,am,an)end end;l4(jZ,jh,l5,l6)l9(jZ,la)le(jZ)lT(jZ)if not iW and c1 then lL(jZ)end;return jZ end;function n_.HUDEpilogue(jZ)jZ[#jZ+1]="</svg>"return jZ end;function n_.ExtraData(jZ)local ob=jd(1240)local oc=je(55)local od=oc+10;local oe;local ly=jd;local lz=je;local of=0;local jh=jg()if b0 then jh=jh.."-VERTICAL"end;if E and not b8 and not b7 and cL>20 then jh=jh.."-COLLISION ON"end;if bD~="Off"then jh="("..bD..")-"..jh end;if b5 then jh="TB-"..jh end;if bI then jh="HOVERMODE-"..jh end;if not bC then jh=jh.."-DeCoupled"end;local og=lz(99)local oh=lz(80)local oi=lz(85)local oj=lz(31)local ok=0;local ol=0;local om=cj>1000000 and fV(cj/1000000,2).."kT"or fV(cj/1000,2).."T"if cg then of=bv else of=bt end;local on,oo=cp.computeDistanceAndTime(cL,0,cj,0,0,of)if on<0 then on=0 end;of=fV(of/(cj*iO),2).."g"local op=d:maxForceForward()oe=b.getGravityIntensity()if oe>0.1 then ol=cj*oe;ol=fV(ol/(cj*iO),2).."g"ok=0.5*op/oe;ok=ok>1000000 and fV(ok/1000000,2).."kT"or fV(ok/1000,2).."T"end;op=fV(op/(cj*iO),2).."g"local oq=vec3(bP.getWorldAcceleration()):len()/9.80665;oe=b.getGravityIntensity()jZ[#jZ+1]=[[<g class="dim txt txtend size14">]]if iF()==1 and not l then ob=jd(1120)oc=je(55)od=oc+10 elseif cg and I then local os=jd(770)jZ[#jZ+1]=gN(ly(895),og,"ATMO","")jZ[#jZ+1]=dk([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],ly(895),oi,ly(-80))jZ[#jZ+1]=gN(ly(815),oh,dk("%.1f%%",ch*100),"txtstart size20")end;if I then jZ[#jZ+1]=gN(ly(1025),og,"GRAVITY","txtstart")jZ[#jZ+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(1025),oi,ly(80))jZ[#jZ+1]=gN(ly(1105),oh,dk("%.2fg",oe/9.80665),"size20")jZ[#jZ+1]=gN(ly(1125),og,"ACCEL","txtstart")jZ[#jZ+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(1125),oi,ly(80))jZ[#jZ+1]=gN(ly(1205),oh,dk("%.2fg",oq),"size20")jZ[#jZ+1]=gN(ly(695),og,"BRK TIME","")jZ[#jZ+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(695),oi,ly(-80))jZ[#jZ+1]=gN(ly(615),oh,dk("%s",iL(oo)),"txtstart size20")jZ[#jZ+1]=gN(ly(635),lz(45),"TRIP","")jZ[#jZ+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(635),lz(31),ly(-90))if lv then jZ[#jZ+1]=gN(ly(545),lz(26),dk("%s",iL(lv)),"txtstart size20")end;jZ[#jZ+1]=gN(ly(795),og,"BRK DIST","")jZ[#jZ+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(795),oi,ly(-80))jZ[#jZ+1]=gN(ly(715),oh,dk("%s",iK(on)),"txtstart size20")jZ[#jZ+1]=gN(ly(1285),lz(45),"MASS","txtstart")jZ[#jZ+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(1285),lz(31),ly(90))jZ[#jZ+1]=gN(ly(1375),lz(26),dk("%s",om),"size20")jZ[#jZ+1]=gN(ly(1220),og,"THRUST","txtstart")jZ[#jZ+1]=dk([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(1220),oi,ly(80))jZ[#jZ+1]=gN(ly(1300),oh,dk("%s",op),"size20")jZ[#jZ+1]=gN(jd(960),je(175),jh,"pbright txtbig txtmid size20")end;jZ[#jZ+1]="</g>"end;local ot=1-(a7*0.05+a8*0.05)function n_.FuelUsed(ou)local ov;if ou=="atmofueltank"then ov=dk("Atmo Fuel Used: %.1f L",jA[ou]/(4*ot))elseif ou=="spacefueltank"then ov=dk("Space Fuel Used: %.1f L",jA[ou]/(6*ot))else ov=dk("Rocket Fuel Used: %.1f L",jA[ou]/(0.8*ot))end;return ov end;local ow,ox,oy,oz,oA=0,0,0,{},0;function n_.DrawOdometer(jZ,j7,bo,j8)if bK~="INFO"then return jZ end;local oe;local ok=0;local ol=0;local of=0;local om=cj>1000000 and fV(cj/1000000,2).." kTons"or fV(cj/1000,2).." Tons"if cg then of=bv else of=bt end;local on,oo=cp.computeDistanceAndTime(cL,0,cj,0,0,of)of=fV(of/(cj*iO),2).." g"local op=d:maxForceForward()oe=b.getGravityIntensity()if oe>0.1 then ol=cj*oe;ol=fV(ol/(cj*iO),2).." g"ok=0.5*op/oe;ok=ok>1000000 and fV(ok/1000000,2).." kTons"or fV(ok/1000,2).." Tons"end;op=fV(op/(cj*iO),2).." g"if iF()==0 or l then local oB=jd(aC+10)local oC=je(aD+20)local oD=jd(aC+10+aB/1.25)local nj=25;local oE=bN(1/aU)if oy<oE then oA=oA+a.getActionUpdateDeltaTime()oy=oy+1 else ow=1/(oA/oE)table.insert(oz,ow)oy,oA=0,0 end;ox=0;for dL,dx in pairs(oz)do ox=ox+dx end;if#oz>0 then ox=bN(ox/#oz)end;if#oz>29 then table.remove(oz,1)end;jZ[#jZ+1]="<g class='txtstart size14 bright'>"jZ[#jZ+1]=gN(oB,oC,dk("BrkTime: %s",iL(oo)))jZ[#jZ+1]=gN(oD,oC,dk("Trip: %.2f km",j7))jZ[#jZ+1]=gN(oB,oC+nj,dk("Lifetime: %.2f kSU",bo/200000))jZ[#jZ+1]=gN(oD,oC+nj,dk("BrkDist: %s",iK(on)))jZ[#jZ+1]=gN(oB,oC+nj*2,"Trip Time: "..iL(j8))jZ[#jZ+1]=gN(oD,oC+nj*2,"Total Time: "..iL(bp))jZ[#jZ+1]=gN(oB,oC+nj*3,dk("Mass: %s",om))jZ[#jZ+1]=gN(oD,oC+nj*3,dk("Max Brake: %s",of))jZ[#jZ+1]=gN(oB,oC+nj*4,dk("Max Thrust: %s",op))if oe>0.1 then jZ[#jZ+1]=gN(oD,oC+nj*4,dk("Max Thrust Mass: %s",ok))jZ[#jZ+1]=gN(oB,oC+nj*5,dk("Req Thrust: %s",ol))else jZ[#jZ+1]=gN(oD,oC+nj*4,"Max Mass: n/a")jZ[#jZ+1]=gN(oB,oC+nj*5,"Req Thrust: n/a")end;jZ[#jZ+1]=gN(oD,oC+nj*5,cr.FuelUsed("atmofueltank"))jZ[#jZ+1]=gN(oB,oC+nj*6,cr.FuelUsed("spacefueltank"))jZ[#jZ+1]=gN(oD,oC+nj*6,cr.FuelUsed("rocketfueltank"))jZ[#jZ+1]=gN(oB,oC+nj*7,dk("Set Max Speed: %s",bN(ac*3.6+0.5)))jZ[#jZ+1]=gN(oD,oC+nj*7,dk("Actual Max Speed: %s",bN(df*3.6+0.5)))jZ[#jZ+1]=gN(oB,oC+nj*8,dk("Friction Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))jZ[#jZ+1]=gN(oD,oC+nj*8,dk("FPS (Avg): %s (%s)",bN(ow),ox))end;jZ[#jZ+1]="</g></g>"return jZ end;function n_.DrawWarnings(jZ)return le(jZ)end;function n_.DisplayOrbitScreen(jZ)return lT(jZ)end;function n_.DisplayMessage(jZ,lp)if lp~="empty"then local hB=310;for ls in string.gmatch(lp,"([^\n]+)")do hB=hB+35;jZ[#jZ+1]=gN("50%",hB,ls,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;function n_.DrawDeadZone(jZ)jZ[#jZ+1]=dk([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aA)end;function n_.UpdatePipe()if cg then iY=""return end;n8()end;function n_.DrawSettings(jZ)local hA=jd(640)local hB=je(200)jZ[#jZ+1]=[[<g class="pbright txtvspd txtstart">]]local hX=0;for dL,dx in pairs(iX)do hX=hX+1;jZ[#jZ+1]=gN(hA,hB,dL..": "..dx.get())hB=hB+20;if hX%12==0 then hA=hA+jd(350)hB=je(200)end end;jZ[#jZ+1]=gN(jd(640),je(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jZ[#jZ+1]="</g>"return jZ end;local id=je(125)local ic=jd(1225)function n_.DrawRadarInfo()ie=cu.GetRadarHud(ic,id,ay,az)end;function n_.DrawTanks()if au~=0 and av~=0 then ji=gN(au,av,"","txtstart pdim txtfuel")jB=av;jC(au,"Atmospheric ","ATMO",cl,jy,jz)jC(au,"Space Fuel T","SPACE",cm,jw,jx)jC(au,"Rocket Fuel ","ROCKET",cn,ju,jv)end end;function n_.DrawShield()local ip=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oF=bP.getPvPTimer()local oG=shield.getResistances()local oH="A: "..10+oG[1]*100 .."% / E: "..10+oG[2]*100 .."% / K:"..10+oG[3]*100 .."% / T: "..10+oG[4]*100 .."%"local hA,hB=aw-60,ax+30;local jR=bN(dg*2.55)local jS=dk("rgb(%d,%d,%d)",255-jR,jR,0)local jT=""jj=gN(hA,hB,"","txtmid pdim txtfuel")if dg<10 and ip~="Shield Disabled"then jT="red "end;oF=oF>0 and"   PvPTime: "..iL(oF)or""jj=jj..dk([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hA,hB,jS,dg*2,hA,hB,hA+2,hB+10,dg,oF)jj=jj..gN(hA,hB-5,ip,jT.."txtstart pbright txtbig")jj=jj..gN(hA,hB+30,oH,jT.."txtstart pbright txtsmall")end;function n_.hudtick()if not kB then return end;local function oI(jZ)local jV=bN(dl(dd/(ad/4)*255,0,255))jZ[#jZ+1]=dk("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(j2+0.5)+jV,bN(j3+0.5)-jV,bN(j4+0.5)-jV)end;local function oJ()if c2 then for dQ,dx in pairs(iP)do if dx.hovered then if not dx.drawCondition or dx.drawCondition(dx)then dx.toggleFunction(dx)end;dx.hovered=false end end;for dQ,dx in pairs(iS)do if dx.hovered then bK=dx.label;dx.hovered=false end end;c2=false end end;local function oK()local function oL(oM,oN,hA,hB,ni,nj)if oM>=hA and oM<=hA+ni and oN>=hB and oN<=hB+nj then return true else return false end end;local hA=c9+ad/2;local hB=ca+ae/2;for dQ,dx in pairs(iP)do dx.hovered=oL(hA,hB,dx.x,dx.y,dx.width,dx.height)end;for dQ,dx in pairs(iS)do dx.hovered=oL(hA,hB,dx.x,dx.y,dx.width,dx.height)end;if d0 then local mY=false;for dQ,eD in ipairs(nW)do if eD.hovered then mY=true;break end end;if nT.hovered then mY=true end;d0=mY else d0=nT.hovered;if not d0 then d1=bm end end end;local function oO(jZ)if not bK or bK==""then bK="HELP"end;if w then for dL,dx in pairs(iS)do local jT="dim brightstroke"local oP=0.2;if bK==dL then jT="pbright dimstroke"oP=0.6 end;local oQ=""if dx.hovered then oP=0.8;oQ=";stroke:white"end;jZ[#jZ+1]=dk([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dx.width,dx.height,dx.x,dx.y,jT,oP,oQ)jZ[#jZ+1]=gN(dx.x+dx.width/2,dx.y+dx.height/2+5,dx.label,"txt txtmid pdim")end end end;local function oR(jZ)local function oS(jZ,oT,hover,hA,hB,fi,oU,oV,oW,oX,oY,nX)if type(oX)=="function"then oX=oX(nX)end;if type(oY)=="function"then oY=oY(nX)end;jZ[#jZ+1]=dk("<rect x='%f' y='%f' width='%f' height='%f' fill='",hA,hB,fi,oU)if oT then jZ[#jZ+1]=dk("%s'",oV)else jZ[#jZ+1]=oW end;if hover then jZ[#jZ+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ag,ah,ai)else jZ[#jZ+1]=dk(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fV(ag*0.5,0),fV(ah*0.5,0),fV(ai*0.5,0))end;jZ[#jZ+1]=" rx='5'></rect>"jZ[#jZ+1]=dk("<text x='%f' y='%f' font-size='24' fill='",hA+fi/2,hB+oU/2+5)if oT then jZ[#jZ+1]="black"else jZ[#jZ+1]="white"end;jZ[#jZ+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oT then jZ[#jZ+1]=dk("%s</text>",oX)else jZ[#jZ+1]=dk("%s</text>",oY)end end;local oZ=dk("rgb(%d,%d,%d)'",fV(ag*0.1,0),fV(ah*0.1,0),fV(ai*0.1,0))local o_=dk("rgb(%d,%d,%d)",fV(ag*0.8,0),fV(ah*0.8,0),fV(ai*0.8,0))local p0=oS;for dQ,dx in pairs(iP)do local nn=dx.disableName;local nm=dx.enableName;if type(nn)=="function"then nn=nn(dx)end;if type(nm)=="function"then nm=nm(dx)end;if not dx.drawCondition or dx.drawCondition(dx)then p0(jZ,dx.toggleVar(dx),dx.hovered,dx.x,dx.y,dx.width,dx.height,o_,oZ,nn,nm,dx)end end end;local p1=fV(ad/2,0)local p2=fV(ae/2,0)local jZ={}if p3 then jZ[#jZ+1]=p3 end;cr.HUDPrologue(jZ)if w then cr.UpdateHud(jZ)else if A then cr.DrawVerticalSpeed(jZ,ci)end;cr.DrawWarnings(jZ)end;if iW and iX~="none"then cr.DrawSettings(jZ)end;if cu then cr.DrawRadarInfo()else ie=""end;cr.HUDEpilogue(jZ)jZ[#jZ+1]=dk([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ad,ae)if c3~="empty"then cr.DisplayMessage(jZ,c3)end;if iF()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(jZ)end end;oO(jZ)if iH()==0 then if iF()==1 and c1 then if not p4 then oK()oR(jZ)end;if not cx and not cy then local p5=table.concat(jZ,"")jZ={}jZ[#jZ+1]=dk("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jZ[#jZ+1]=p5;jZ[#jZ+1]="</body>"cx=true;jZ[#jZ+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local p5=table.concat(jZ,"")jZ={}jZ[#jZ+1]=dk("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ad,ae)jZ[#jZ+1]=p5;jZ[#jZ+1]="</body>"end;if not cx then jZ[#jZ+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p1,p2,c9,ca)end else oJ()end else if not c1 and iF()==0 then oJ()if dd>aA then if v then oI(jZ)end end elseif c1 and(not p4 or not i)then oK()oR(jZ)end;jZ[#jZ+1]=dk([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p1,p2,c9,ca)end;jZ[#jZ+1]=[[</svg></body>]]p6=table.concat(jZ,"")end;function n_.TenthTick()local function p7()local p8=a.createData;local p9=a.createWidget;pa=a.createWidgetPanel("Interplanetary Helper")pb=p9(pa,"value")pc=p8('{"label": "Target Planet", "value": "N/A", "unit":""}')fT(pc,pb)pd=p9(pa,"value")pe=p8('{"label": "distance", "value": "N/A", "unit":""}')fT(pe,pd)gm=p9(pa,"value")gl=p8('{"label": "Travel Time", "value": "N/A", "unit":""}')fT(gl,gm)gk=p9(pa,"value")gj=p8('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fT(gj,gk)go=p9(pa,"value")gn=p8('{"label": "Target Altitude", "value": "N/A", "unit":""}')fT(gn,go)gg=p9(pa,"value")gf=p8('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ge=p9(pa,"value")gd=p8('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gc=p9(pa,"value")gb=p8('{"label": "Max Brake distance", "value": "N/A", "unit":""}')ga=p9(pa,"value")g9=p8('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gi=p9(pa,"value")gh=p8('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fT(gf,gg)fT(gd,ge)fT(gb,gc)fT(g9,ga)fT(gh,gi)end end;local function pf()gM(pa)pa=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bk~="None"then if pa==nil then p7()end;if bk~=nil then local mz;local pg=g5~=nil;local ph=0.5*bv/c8:getGravity(c8.center+vec3(0,0,1)*c8.radius):len()ph=ph>1000000 and fV(ph/1000000,2).." kTons"or fV(ph/1000,2).." Tons"fS(pc,'{"label": "Target", "value": "'..bk..'", "unit":""}')if pg and not b4 then mz=(cO-g5.position):len()else mz=(bl-cO):len()end;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)i_,j0=ct.GetAutopilotBrakeDistanceAndTime(ac)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)i_,j0=ct.GetAutopilotTBBrakeDistanceAndTime(ac)end;local lp=iK(mz)fS(pe,'{"label": "distance", "value": "'..lp..'"}')fS(gl,'{"label": "Travel Time", "value": "'..iL(lv)..'", "unit":""}')lp=iK(c6)fS(gf,'{"label": "Cur Brake distance", "value": "'..lp..'"}')fS(gd,'{"label": "Cur Brake Time", "value": "'..iL(c7)..'", "unit":""}')lp=iK(i_)fS(gb,'{"label": "Max Brake distance", "value": "'..lp..'"}')fS(g9,'{"label": "Max Brake Time", "value": "'..iL(j0)..'", "unit":""}')fS(gj,'{"label": "Max Brake Mass", "value": "'..dk("%s",ph)..'", "unit":""}')lp=iK(gp)fS(gn,'{"label": "Target Orbit", "value": "'..lp..'"}')if cg and not pi then a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)a.removeDataFromWidget(gf,gg)a.removeDataFromWidget(gh,gi)pi=true;if not cR and t and(b6 or b9 or ce)then ct.cmdThrottle(1)b1=false;bV=false end end;if not cg and pi then if fS(g9,ga)==1 then fT(g9,ga)end;if fS(gb,gc)==1 then fT(gb,gc)end;if fS(gd,ge)==1 then fT(gd,ge)end;if fS(gf,gg)==1 then fT(gf,gg)end;if fS(gh,gi)==1 then fT(gh,gi)end;pi=false end end else pf()end;if warpdrive~=nil then local pj=iD(warpdrive.getWidgetData())if pj.destination~="Unknown"and pj.distance>400000 then if not jc then warpdrive.showWidget()jc=true end elseif jc then warpdrive.hideWidget()jc=false end end end;function n_.OneSecondTick()local function pk()local jM=bM()local la=cL;local pl=jM-ja;if la>1.38889 then la=la/1000;local pm=la*(jM-ja)bo=bo+pm;j7=j7+pm end;j8=j8+pl;bp=bp+pl;ja=jM end;local function pn(jZ)local po=0;local pp=iN;local pq=0;local pr=0;local ps=0;local jR=0;local jS=""local pt=b.getElementHitPointsById;local pu=b.getElementMaxHitPointsById;local pv={}for dL in pairs(iM)do local pw=0;local px=0;px=pu(iM[dL])pw=pt(iM[dL])pq=pq+pw;if pw+1<px then if pw==0 then ps=ps+1 else pr=pr+1 end;if jb and#pv==0 then fX=vec3(b.getElementPositionById(iM[dL]))local hA=fX.x;local hB=fX.y;local hC=fX.z;table.insert(pv,b.spawnArrowSticker(hA,hB,hC+1,"down"))table.insert(pv,b.spawnArrowSticker(hA,hB,hC+1,"down"))b.rotateSticker(pv[2],0,0,90)table.insert(pv,b.spawnArrowSticker(hA+1,hB,hC,"north"))table.insert(pv,b.spawnArrowSticker(hA+1,hB,hC,"north"))b.rotateSticker(pv[4],90,90,0)table.insert(pv,b.spawnArrowSticker(hA-1,hB,hC,"south"))table.insert(pv,b.spawnArrowSticker(hA-1,hB,hC,"south"))b.rotateSticker(pv[6],90,-90,0)table.insert(pv,b.spawnArrowSticker(hA,hB-1,hC,"east"))table.insert(pv,b.spawnArrowSticker(hA,hB-1,hC,"east"))b.rotateSticker(pv[8],90,0,90)table.insert(pv,b.spawnArrowSticker(hA,hB+1,hC,"west"))table.insert(pv,b.spawnArrowSticker(hA,hB+1,hC,"west"))b.rotateSticker(pv[10],-90,0,90)table.insert(pv,iM[dL])end elseif jb and#pv>0 and pv[11]==iM[dL]then for jL in pairs(pv)do b.deleteSticker(pv[jL])end;pv={}end end;po=fV(pq/pp*100,2)if ps>0 or pr>0 then jZ[#jZ+1]=gN(0,0,"","pbright txt")jR=bN(po*2.55)jS=dk("rgb(%d,%d,%d)",255-jR,jR,0)jZ[#jZ+1]=gN("50%",1035,"Elemental Integrity: "..po.."%","txtbig txtmid","fill:"..jS)if ps>0 then jZ[#jZ+1]=gN("50%",1055,"Disabled Modules: "..ps.." Damaged Modules: "..pr,"txtbig txtmid","fill:"..jS)elseif pr>0 then jZ[#jZ+1]=gN("50%",1055,"Damaged Modules: "..pr,"txtbig txtmid","fill:"..jS)end end end;local function py()if iC then if j1==nil and(he~=nil or bn)then _autoconf.displayCategoryPanel(iC,weapon_size,"Weapons","weapon",true)j1=_autoconf.panels[_autoconf.panels_size]elseif j1~=nil and he==nil and not bn then gM(j1)j1=nil end end end;d2=bP.getPlayersOnBoard()d3=bP.getDockedConstructs()local jZ={}pk()if s then pn(jZ)end;py()cr.UpdatePipe()cr.ExtraData(jZ)j9=table.concat(jZ,"")end;function n_.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function n_.MsgTick()local jZ={}cr.DisplayMessage(jZ,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function n_.ButtonSetup()ny()nE()iP=iQ end;if pz then for dL,dx in pairs(pz)do n_[dL]=dx end end;return n_ end;local function pA(d,b,c,e,vBooster,hover,pB,antigrav,dbHud_1,eZ,bN,bO,iF,eU,bM,dl,iG,fS,iH,dn,fV,fU,iI,dp,iK,iL,pC,iD)local a=DUSystem;local bP=DUConstruct;local pD={}local pE=false;local pF=0;local pG=0;local pH=0;local pI=bM()local pJ=0;local pK=0;local pL=0;local pM=0;local pN=false;local pO=false;local pP=false;local pQ=nil;local pR=0;local iZ=55;local pS=nil;local pT=false;local pU=false;local pV=false;local pW=0;local pX=0;local pY=0;local pZ=0;local p_=0;local q0={VectorToTarget=false}local q1=vec3(bP.getWorldOrientationUp())local q2=nil;local q3=0;local q4=-1;local q5=-1;local q6=false;local q7=false;local q8=0;local q9=false;local qa=false;local qb=false;local qc=false;local qd=""local qe=false;local qf=false;local qg=""local qh=false;local qi=0;local function qj()return bP.isInPvPZone()~=1,eZ(bP.getDistanceToSafeZone())end;local function qk(fp)local ql=bg;if not b4 then ql=0 end;local qm=bt;if cg then if bv and bv>0 then qm=bv else return 0,0 end end;return cp.computeDistanceAndTime(fp,ql,cj,0,0,qm-bi*cj)end;local function qn(fp)local ql=bg;if not b4 then ql=0 end;return cp.computeDistanceAndTime(fp,ql,cj,d:maxForceForward(),a3,bt-bi*cj)end;local function qo(qp,qq,qr)qq=qq:project_on_plane(qp)qr=qr:project_on_plane(qp)return eU(qq:cross(qr):dot(qp),qq:dot(qr))end;local function qs()local function qt()local qu=-1;local qv=-1;if vBooster then qu=vBooster.getDistance()end;if hover then qv=hover.getDistance()end;if qu~=-1 and qv~=-1 then if qu<qv then return qu else return qv end elseif qu~=-1 then return qu elseif qv~=-1 then return qv else return-1 end end;local qw=qt()local qx=-1;if antigrav and antigrav.isActive()==1 and not q and cL<iZ then local qy=eZ(ci-antigrav.getBaseAltitude())if qy<50 then return qy end end;if pB then qx=pB.raycast().distance end;if qw~=-1 and qx~=-1 then if qw<qx then return qw else return qx end elseif qw~=-1 then return qw else return qx end end;local function qz(kB,eL,qA)local function qB(qC,dX)local eR=vec3(dX)if qC.id==0 then return setmetatable({latitude=eR.x,longitude=eR.y,altitude=eR.z,id=0,systemId=qC.systemId},dZ)end;local eS=eR-qC.center;local cb=eS:len()local e3=cb-qC.radius;local e1=0;local e2=0;if not dp(cb,0)then local eT=eU(eS.y,eS.x)e2=eT>=0 and eT or 2*math.pi+eT;e1=math.pi/2-math.acos(eS.z/cb)end;return setmetatable({latitude=math.deg(e1),longitude=math.deg(e2),altitude=e3,id=qC.id,systemId=qC.systemId},dZ)end;local qD=qB(kB,eL)qD="::pos{"..qD.systemId..","..qD.id..","..qD.latitude..","..qD.longitude..","..qD.altitude.."}"if qA then return qD else qb=qD;return true end end;local function qE(qF,qG,qH)local function qI(qF,eu)qF=vec3(qF)eu=vec3(eu):normalize()local dG=qF*eu;return dG.x+dG.y+dG.z end;local qJ=0.001;local qK=1;if not cg or not cA or cf~=-1 or cL<iZ then if qH==nil then qH=aT end;if qG==nil then qG=qJ end;qF=vec3(qF):normalize()local qL=vec3()-qF;local qM=-qI(qL,bP.getWorldOrientationRight())*qK;local qN=-qI(qL,bP.getWorldOrientationUp())*qK;if pG==0 then pG=qM/2 end;if pH==0 then pH=qN/2 end;if eZ(qM)<0.1 then pX=pX-qM*2 else pX=pX-(qM+(qM-pG)*qH)end;if eZ(qN)<0.1 then pW=pW+qN*2 else pW=pW+qN+(qN-pH)*qH end;pG=qM;pH=qN;if eZ(qM)<qG and eZ(qN)<qG then return true end;return false elseif cA and cf==-1 then qF=cK;if qH==nil then qH=aT end;if qG==nil then qG=qJ end;qF=vec3(qF):normalize()local qL=cH-qF;local qM=-qI(qL,bP.getWorldOrientationRight())*qK;local qN=-qI(qL,bP.getWorldOrientationUp())*qK;if pG==0 then pG=qM/2 end;if pH==0 then pH=qN/2 end;if eZ(qM)<0.1 then pX=pX-qM*5 else pX=pX-(qM+(qM-pG)*qH)end;if eZ(qN)<0.1 then pW=pW+qN*5 else pW=pW+qN+(qN-pH)*qH end;pG=qM;pH=qN;if eZ(qM)<qG and eZ(qN)<qG then return true end;return false end end;function pD.clearAll()bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"b2=false;b3=false;cX=nil;b6=false;b9=false;b7=false;b8=false;ba=false;c0=false;pU=false;cc=false;cd=false;pV=false;cz=p;br=false;b5=false;ck=false;bu=nil;bA=false;db=false;dc=nil end;function pD.GetAutopilotBrakeDistanceAndTime(fp)return qk(fp)end;function pD.GetAutopilotTBBrakeDistanceAndTime(fp)return qn(fp)end;function pD.showWayPoint(kB,eL,qA)return qz(kB,eL,qA)end;function pD.APTick()local qO=a.getMouseWheel()if qO>0 then ct.changeSpd()elseif qO<0 then ct.changeSpd(true)else pT=true end;q8=iH()if qb then a.setWaypoint(qb)qb=false end;if qe then antigrav.setTargetAltitude(qe)qe=false end;if qc then fS(qc,qd)qc=false;qd=""end;if q5~=-1 then ct.cmdCruise(q5,q6)q6=false;q5=-1 end;if q2~=nil then if iG:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iG:getTargetSpeed(axisCommandId.longitudinal)~=q2 then iG:setTargetSpeedCommand(axisCommandId.longitudinal,q2)else q2=nil end end;if q4~=-1 then ct.cmdThrottle(q4,q6)q6=false;q4=-1 end;if q7 then cv.landingGear(q7)q7=false end;if qf then ct.ToggleAutopilot()end end;function pD.ToggleIntoOrbit()cE=false;pL=nil;pM=nil;pR=0;if not cg then if bA then fU("orOff","AP")bA=false;pN=false;pQ=nil;cz=p;if b6 then b6=false;b8=false end;q0.VectorToTarget=false;q0.AutopilotAlign=false;pP=false elseif cY then fU("orOn","AP")bA=true;cz=true;if pQ==nil then pQ=kB end;if b6 then b6=false;b8=false end else c3="Unable to engage auto-orbit, not near a planet"end else bA=false;pN=false;pQ=nil;cz=p;if b6 then b6=false end;q0.VectorToTarget=false;q0.AutopilotAlign=false;pP=false end end;function pD.ToggleVerticalTakeoff()b6=false;if ba then lr=true;b9=false;b8=false;b7=true;cz=true;b_=0;if cg and cf==-1 then b7=false;b6=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q5=bN(cB)end else cE=false;bn=false;d.control.retractLandingGears()iG:setTargetGroundAltitude(_)b1="VTO Takeoff"end;ba=not ba end;function pD.checkLOS(qF)local lt,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,qF,function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local lu=eJ;if eK~=nil and eJ~=nil then lu=math.min(eK,eJ)end;if lu~=nil then return lt,lu else return nil,nil end end;local function qP(qQ,qR)if qR then b_=0;iG:updateCommandFromActionStop(axisCommandId.vertical,qR)if bC then iG:activateGroundEngineAltitudeStabilization(qS)de=true end else b_=b_+qQ;iG:deactivateGroundEngineAltitudeStabilization()iG:updateCommandFromActionStart(axisCommandId.vertical,qQ)end end;function pD.vertical(qQ,qR)qP(qQ,qR)end;function pD.ToggleAutopilot()local function qT(by)cZ=false;br=not br;if br then b5=false;if not b6 and not by then ct.ToggleAltitudeHold()end end;lx="Proceeding to Waypoint"end;local function qU(gy)if gy then for M,dL in pairs(cU)do if dL.name and dL.name==gy then return M end end else return 0 end end;local qV=false;bI=false;if bQ-pK<1.5 and cg then if not cG then if cg then bb=kB.spaceEngineMinAltitude-0.01*kB.noAtmosphericDensityAltitude;fU("11","EP")pK=-1;if b4 or br or bA then return end else c3="No space engines detected, Orbital Hop not supported"return end elseif kB.hasAtmosphere then if cg then bb=kB.noAtmosphericDensityAltitude+W;fU("orH","OH")end;pK=-1;if b4 or br or bA then return end end else pK=bQ end;qW=false;if(bm>0 or#bG>0)and not b4 and not br and not cd and not bA then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then c3="WARNING: Heavy Loads may affect autopilot performance."c4=5 end;if#bG>0 and not ce then bm=qU(bG[1])cs.UpdateAutopilotTarget()c3="Route Autopilot in Progress"local qL=g5.position-cO;local qX=qL:project_on_plane(cM):len()if qX>50000 and g5.planetname==kB.name then qV=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c8,bl)if g5~=nil then if g5.agg and not q and antigrav then if not cQ then ct.ToggleAntigrav()end;bw=g5.agg end;bu=nil;by=g5.planetname=="Space"if by then fU("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end elseif kB.name==g5.planetname then lr=true;if cg then if not br then fU("vtt","AP")qT(by)if qV then bb=kB.noAtmosphericDensityAltitude+W end end else fU("apOn","AP")if not(c8.name==kB.name and ci<gp*1.5)then cE=false;b4=true elseif not cg then if bA then ct.ToggleIntoOrbit()end;cD=kB.noAtmosphericDensityAltitude+W;pP=true;q0.AutopilotAlign=true;q0.VectorToTarget=true;pN=false;if not bA then ct.ToggleIntoOrbit()end end end else fU("apP","AP")b2=false;b3=false;if cg then cd=true;ct.ToggleAltitudeHold()else b4=true end end elseif not cg then if g5==nil and(c8.name==kB.name and cY)and not bA then qY=false;cE=false;pN=false;ct.ToggleIntoOrbit()else fU("apP","AP")b4=true;b2=false;b3=false;bd=false;c0=false;b6=false;b7=false;b9=false;b8=false;pU=false;bu=nil;qY=false end else fU("apP","AP")cd=true;ct.ToggleAltitudeHold()end;qf=false else fU("apOff","AP")ct.ResetAutopilots(1)if qf==2 then qf=true end end end;function pD.routeWP(qZ,q_,r0)if r0 then if r0==1 then bG={}bG=iI(bG,bF)if#bG>0 then c3="Route Loaded"else c3="No Saved Route found on Databank"end;return bG else bF={}bF=iI(bF,bG)c3="Route Saved"pC()return end end;if qZ then return bG end;if q_ then bG={}c3="Current Route Cleared"else bG[#bG+1]=g5.name;c3="Added "..g5.name.." to route. "end;return bG end;function pD.cmdThrottle(dM,r1)if iG:getAxisCommandType(0)~=axisCommandType.byThrottle and not r1 then d.control.cancelCurrentControlMasterMode()end;iG:setThrottleCommand(axisCommandId.longitudinal,dM)bR=dl(fV(dM*100,0)/100,-1,1)q2=nil end;function pD.cmdCruise(dM,r1)if iG:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r1 then d.control.cancelCurrentControlMasterMode()end;iG:setTargetSpeedCommand(axisCommandId.longitudinal,dM)q2=dM end;function pD.ToggleLockPitch()if bu==nil then fU("lkPOn","LP")if not c1 then bu=cS else bu=T end;b8=false;b6=false;b7=false else fU("lkPOff","LP")bu=nil end end;function pD.ToggleAltitudeHold()if bQ-pJ<1.5 then bI=false;if kB.hasAtmosphere then if cg then bb=kB.spaceEngineMinAltitude-0.01*kB.noAtmosphericDensityAltitude;fU("11","EP")else if cY then bb=kB.noAtmosphericDensityAltitude+W;cD=bb;pP=true;if not bA then ct.ToggleIntoOrbit()end;pN=true end end;pJ=-1;if b6 or bA or ba then return end end else pJ=bQ end;if cY and not cg and cf==-1 then cD=ci;pP=true;pN=true;ct.ToggleIntoOrbit()if bA then pJ=bQ else pJ=0 end;return end;b6=not b6;b7=false;b9=false;if b6 then b4=false;b3=false;b2=false;c0=false;cz=true;bu=nil;cE=false;if cf~=-1 then if not bn and not br then bb=ci;bI=cf;iG:setTargetGroundAltitude(bI)elseif cL<20 then if bn then cv.landingGear()end;fU("lfs","LS")b8=true;if cg then bb=ci+Z else bb=kB.surfaceMaxAltitude+100 end;b1="ATO Hold"iG:setTargetGroundAltitude(_)if b0 and cP then ct.ToggleVerticalTakeoff()end end else fU("altOn","AH")b8=false;if pJ>-1 then if cY then bb=ci end end;if ba then ct.ToggleVerticalTakeoff()end end;if cQ and not q then local r2=antigrav.getBaseAltitude()if br and g5.agg and g5.agg>ci then bb=g5.agg elseif b8 then bb=r2 end;if eZ(ci-r2)<100 and cL<20 then bb=r2;b1="AGG Hold"q4=0 end end;if cd then bb=200000 end else fU("altOff","AH")if bA then ct.ToggleIntoOrbit()end;if ba then ct.ToggleVerticalTakeoff()end;cz=p;b8=false;br=false;pJ=0;bI=false end end;function pD.ResetAutopilots(pD)if pD then cd=false;b4=false;bd=false;pU=false;bb=ci;qW=false;db=false;bh="Aligning"end;br=false;b8=false;b9=false;b3=false;b7=false;dc=nil;r3=false;cX=nil;db=false;if not cQ then b6=false;bu=nil end;if ba then ct.ToggleVerticalTakeoff()end;if bA then ct.ToggleIntoOrbit()end;cz=p;cc=false;ce=false;b_=0 end;function pD.BrakeToggle(r4)if not b1 then if r4 then b1=r4 else b1=true end else b1=false end;if b7 then b7=false;cz=p;db=false end;if b1 then fU("bkOn","B",1)ct.ResetAutopilots()else fU("bkOff","B",1)end end;function pD.BeginReentry()if b9 then c3="Re-Entry cancelled"fU("reOff","RE")b9=false;cz=p;b6=false elseif not kB.hasAtmosphere then c3="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c4=5 elseif not pV then b9=true;if iG:getAxisCommandType(0)~=r5.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b1=false;c3="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB;fU("par","RE")else b9=true;b6=true;cz=true;b1=false;bb=kB.surfaceMaxAltitude+a1;if bb>kB.spaceEngineMinAltitude then bb=kB.spaceEngineMinAltitude-0.01*kB.noAtmosphericDensityAltitude end;local r6=iK(bb)c3="Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..r6;fU("glide","RE")q5=bN(cB)end;b8=false end;function pD.ToggleAntigrav()if antigrav and not q then if cQ then fU("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bw==nil then bw=ci end;if bw<1000 then bw=1000 end;fU("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pD.changeSpd(r7)local r8=1;if r7 then r8=-1 end;if not c1 then if t and not p4 and pT then local r9=bR;bR=fV(dl(bR+r8*aF/100,-1,1),2)if bR>=0 and r9<0 then bR=0;pT=false end elseif p4 then if cg or b9 then cB=dl(cB+r8*aF,0,X)elseif b4 then ac=dl(ac+r8*aF/3.6*100,0,df-0.2)end else iG:updateCommandFromActionStart(axisCommandId.longitudinal,r8*aF/10)end else if b4 or br or cd or bA then d1=d1+1*r8*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not r7 then r8=1 else r8=nil end;cs.adjustAutopilotTargetIndex(r8)end end end;function pD.TenthTick()local function ra()if not b4 then if g5==nil or g5.planetname~=kB.name then rb=(c8.center-cO):len()else rb=(g5.position-cO):len()end end;local fp=cL;local rc=c.getThrottle()/100;if t then rc=bR end;local rd,re=cp.computeDistanceAndTime(cL,ac,cj,d:maxForceForward()*rc,a3,0)local c6,c7;if not b5 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(ac)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(ac)end;local dQ,rf;if not b5 and fp>0 then dQ,rf=ct.GetAutopilotBrakeDistanceAndTime(fp)else dQ,rf=ct.GetAutopilotTBBrakeDistanceAndTime(fp)end;local rg=0;local rh=0;if bf or not b4 and fp>5 then rh=cp.computeTravelTime(fp,0,rb)elseif c6+rd<rb then rg=rb-(c6+rd)rh=cp.computeTravelTime(8333.0556,0,rg)else local ri=(rb-c6)/rd;rd=rb-c6;re=re*ri end;if g5~=nil and g5.planetname==kB.name and not b4 then return rh elseif be then return rf elseif bf then return rh+rf else return re+c7+rh end end;local function rj(oe,rk)if oe==nil then oe=b.getGravityIntensity()end;oe=fV(oe,5)if rk~=nil and rk or(pS==nil or pS~=oe)then local fp=cJ:len()local rl=iD(c.getWidgetData()).maxBrake;if rl~=nil and rl>0 and cg then rl=rl/dl(fp/100,0.1,1)rl=rl/ch;if ch>0.10 then if bv then bv=(bv+rl)/2 else bv=rl end end end;if rl~=nil and rl>0 then bt=rl end;pS=oe end end;cV,cW=qj()df=bP.getMaxSpeed()if bk~="None"and(c8 or g5)then lv=ra()end;rj(nil,true)end;function pD.SatNavTick()if not r then return end;qg=dbHud_1.getStringValue("SPBAutopilotTargetName")if qg~=nil and qg~=""and qg~="SatNavNotChanged"then local dG=iD(dbHud_1.getStringValue("SavedLocations"))if dG~=nil then bq=dG;local gw=-1;local gC;for dL,dx in pairs(bq)do if dx.name and dx.name=="SatNav Location"then gw=dL;break end end;if gw~=-1 then gC=bq[gw]gw=-1;for dL,dx in pairs(e[0])do if dx.name and dx.name=="SatNav Location"then gw=dL;break end end;if gw>-1 then e[0][gw]=gC end;cs.UpdateAtlasLocationsList()c3=gC.name.." position updated"end end;for M=1,#cU do if cU[M].name==qg then bm=M;a.print("Index = "..bm.." "..cU[M].name)cs.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;local function rm(rn,ro)local rp=vec3()local rq=vec3()if rn==axisCommandId.longitudinal then rp=vec3(bP.getOrientationForward())rq=cH elseif rn==axisCommandId.vertical then rp=vec3(bP.getOrientationUp())rq=q1 elseif rn==axisCommandId.lateral then rp=vec3(bP.getOrientationRight())rq=cI else return vec3()end;local rr=vec3(b.getWorldGravity())local rs=rr:dot(rq)local rt=vec3(bP.getWorldAirFrictionAcceleration())local ru=rt:dot(rq)local rv=cJ:dot(rp)local rw=ro*constants.kph2m;if rx==nil then rx=pid.new(10,0,10.0)end;rx:inject(rw-rv)local ry=rx:get()local rz=(ry-ru-rs)*rq;return rz end;local function rA(rn,ro)local rp=vec3()local rq=vec3()if rn==axisCommandId.longitudinal then rp=vec3(bP.getOrientationForward())rq=cH elseif rn==axisCommandId.vertical then rp=vec3(bP.getOrientationUp())rq=q1 elseif rn==axisCommandId.lateral then rp=vec3(bP.getOrientationRight())rq=cI else return vec3()end;local rr=vec3(b.getWorldGravity())local rs=rr:dot(rq)local rt=vec3(bP.getWorldAirFrictionAcceleration())local ru=rt:dot(rq)local rv=cJ:dot(rp)local rw=ro*constants.kph2m;if rB==nil then rB=pid.new(10,0,10.0)end;rB:inject(rw-rv)local ry=rB:get()local rz=(ry-ru-rs)*rq;return rz end;local function rC(rD,k1,g1)local rE=rD:cross(g1):normalize_inplace()local kO=math.acos(dl(rE:dot(-k1),-1,1))*constants.rad2deg;if rE:cross(-k1):dot(g1)<0 then kO=-kO end;return kO end;local function rF()if c_ and not b7 then local es=c_[1]local i3,i4=c_[2],c_[3]local rG=math.min(i3,i4 or i3)local rH=rG/cL;local rI=b8 and(cL<42 or cf~=-1)local rJ=b6 or br or bu or b4;if rJ and not rI and(c6*1.5>rG or rH<1)then b1="Collision"bG={}q4=0;if b6 then ct.ToggleAltitudeHold()end;if bu then ct.ToggleLockPitch()end;c3="Autopilot Cancelled due to possible collision"a.print(es.name.." COLLISION "..iL(rH).." / "..iK(rG,2))ct.ResetAutopilots(1)lr=true;if cg then b7=true end;cz=true end;if rH<11 then cZ=es.name.." COLLISION "..iL(rH).." / "..iK(rG,2)else cZ=es.name.." collision "..iL(rH)end;if rH<6 then fU("alarm","AL",2)end else cZ=false end end;local rK=1;local rL=0;local rM=1;local rN=1;local rO=1;local rP=false;function pD.onFlush()if antigrav and not q and not cQ and antigrav.getBaseAltitude()~=bw then qe=bw end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iG:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local rQ=dl(bX+pW+a.getControlDeviceForwardInput(),-1,1)local rR=dl(bY+pY+a.getControlDeviceYawInput(),-1,1)local rS=dl(bZ+pX-a.getControlDeviceLeftRightInput(),-1,1)local rT=b1 and 1 or 0;cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(kB.center-cO):normalize()end;q1=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local rU=cT/180*math.pi;local rV=math.cos(rU)local rW=math.sin(rU)cS=rC(cM,cH,cI*rV+q1*rW)local rX=cK:normalize()local rY=eZ(cT)local rZ=utils.sign(cT)local r_=vec3(bP.getWorldAngularVelocity())local s0=rQ*aP*cI+rR*aK*cH+rS*aQ*q1;if cz==true and cM:len()>0.01 then local s1=eZ(pZ-cT)if((b3 or b9 or b7 or cc or b6 or bA)and s1>0 or cg and s1<aL and p)and rR==0 and eZ(cS)<85 then local s2=pZ;local s3=aJ;if not cg then s3=s3/4;pZ=0;s2=0 end;if s4==nil then s4=pid.new(s3*0.01,0,s3*0.1)end;s4:inject(s2-cT)local s5=s4:get()s0=s0+s5*cH end end;bS=0;ch=bO()cg=false or ci<kB.noAtmosphericDensityAltitude and ch>0.00001;ci=b.getAltitude()cf=qs()bQ=bM()pI=bQ;if bn and cf>-1 and cf-3<a0 then if iG.targetGroundAltitudeActivated then iG:deactivateGroundEngineAltitudeStabilization()end end;if cu then qh=not qh;if qh then cu.UpdateRadar()end;if E then rF()end end;if antigrav then cQ=antigrav.isActive()==1 end;local s6=bQ-pI;local s7=-math.deg(qo(q1,cK,cH))local s8=math.deg(qo(cI,cK,cH))local gr=cM*-1;cA=cg and s7<-O or s7>O or s8<-P or s8>P;local s9=a.getMouseDeltaX()local sa=a.getMouseDeltaY()if qi then local sb=bM()-qi;s9=s9*sb/0.016;sa=sa*sb/0.016 end;qi=bM()if o and not c1 then sa=-sa end;pX=0;pY=0;pW=0;local sc=bP.getWorldPosition()kB=fY:closestBody(sc)sd=cq(kB)ft=sd:orbitalParameters(sc,cK)if ci==0 then ci=(cO-kB.center):len()-kB.radius end;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local oe=kB:getGravity(sc):len()*cj;pZ=0;local se=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if q8==0 then if iF()==1 and c1 then if not cx then c9=dl(c9+s9/2,-ad/2,ad/2)ca=dl(ca+sa/2,-ae/2,ae/2)end else c9=0;ca=0 end else c9=dl(c9+s9/2,-ad/2,ad/2)ca=dl(ca+sa/2,-ae/2,ae/2)dd=dn(c9*c9+ca*ca)if not c1 and iF()==0 then local kX,kY=1,1;if bK=="SCOPE"then kX,kY=d5/90,d5/90 end;if g=="virtual joystick"then if dd>aA then pX=pX-dl(eZ(c9)-aA,0,ad/2)*utils.sign(c9)*aH*kX;pW=pW-dl(eZ(ca)-aA,0,ae/2)*utils.sign(ca)*aI*kY end else c9=0;ca=0;if g=="mouse"then pW=(-utils.smoothstep(sa,-100,100)+0.5)*2*rN;pX=(-utils.smoothstep(s9,-100,100)+0.5)*2*rO end end end end;local sf=cL>27777;if cL>Y/3.6 and not cg and not b4 and not sf then c3="Space Speed Engine Shutoff reached"q4=0 end;if not sf and sg then if not b1 then ct.BrakeToggle()end;if b4 then ct.ResetAutopilots(1)end;q4=0 end;sg=sf;if ch>0.09 then if cL>cB/3.6 and not t and not pE then b1="SpdLmt"pE=true elseif not t and pE then if cL<cB/3.6 then b1=false;pE=false end end end;if b3 then if cc then b1=false;local sh=false;if g5 and cc==true then sh=qE(g5.position-cO,0.1)else sh=qE(vec3(cK),0.01)end;cz=true;if sh then q5=bN(cB)if(eZ(cT)<2 or eZ(cS)>85)and cL>=cB/3.6-1 then b1=false;b3=false;if cc~=2 then pV=true end;if cc==true then ce=true end;cc=false;b4=false;ct.BeginReentry()end elseif cg and t then q4=1 end elseif cL>iZ then qE(vec3(cK),0.01)end end;if b2 then if cg then b2=false elseif cL>iZ then qE(-vec3(cK))end end;if not b3 and cc and not bA then if not cg then if cc~=2 then pV=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not qf then qf=true end end end;if ce and g5 and(ci<bb+250 and ci>bb-250)and cL*3.6>cB-250 and eZ(cN)<25 and ch>=0.1 and(g5.position-cO):len()>2000+ci then if not qf then qf=true end;ce=false end;if ba then cz=true;local si=bb;if cN<-30 then c3="Unable to achieve lift. Safety Landing."b_=0;cz=p;ba=false;b7=true elseif not q and cQ or bb<kB.spaceEngineMinAltitude then if cQ then si=antigrav.getBaseAltitude()end;if ci<si-100 then p_=0;b_=15;b1=false elseif cN>0 then b1="VTO Limit"b_=0 elseif cN<-30 then b1="VTO Fall"b_=15 elseif ci>=si then if cQ then if b4 or br then ct.ToggleVerticalTakeoff()else b1="VTO Complete"ba=false end;c3="Takeoff complete. Singularity engaged"fU("aggLk","AG")else b1=false;c3="VTO complete. Engaging Horizontal Flight"fU("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then p_=0;b1=false;b_=20 elseif ch<0.08 and cg then b1=false;if cF then p_=0;b_=20 else b_=0;p_=36;q5=3500 end else cz=p;bA=true;cE=false;sj=false;pN=false;pL=nil;pM=nil;if pQ==nil then pQ=kB end;cD=si;pP=true;ba=false end end;if p_~=nil then if sk==nil then sk=pid.new(2*0.01,0,2*0.1)end;local sl=dl(p_-cS,-P*0.80,P*0.80)sk:inject(sl)local sm=dl(sk:get(),-1,1)pW=sm end end;if bA then local function sn()if ft.periapsis.altitude>=cD*0.99 and ft.apoapsis.altitude>=cD*0.99 and ft.periapsis.altitude<ft.apoapsis.altitude and ft.periapsis.altitude*1.05>=ft.apoapsis.altitude and eZ(cD-ci)<1000 then return true else return false end end;local qL;local so=false;local sp=iK(cD,3)if pQ==nil then pQ=kB;if br then pQ=c8 end end;if not pP then cD=bN(pQ.radius+pQ.surfaceMaxAltitude+W)if pQ.hasAtmosphere then cD=bN(pQ.radius+pQ.noAtmosphericDensityAltitude+W)end;pP=true end;if q0.VectorToTarget and g5 then qL=g5.position-cO end;local sq,sr=cq(pQ):escapeAndOrbitalSpeed((cO-pQ.center):len()-pQ.radius)local ss=cT;if not pN then local st=false;local su=false;q4=0;pM=0;cC="Aligning to orbital path - OrbitHeight: "..sp;if q0.VectorToTarget then qE(qL:normalize():project_on_plane(cM))so=cH:dot(qL:project_on_plane(q1):normalize())>0.95 else qE(cK)so=s7<0.5;if cL<150 then so=true end end;pW=0;pL=0;if cS<=pL+2 and cS>=pL-2 then st=true else st=false end;if ss<=pM+2 and ss>=pM-2 then su=true else su=false end;if st and su and so then pL=nil;pM=nil;pN=true end else if q0.VectorToTarget then qE(qL:normalize():project_on_plane(cM))elseif cL>150 then qE(cK)end;pW=0;if q0.VectorToTarget and g5 then local c6,dQ=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bt)if cE and qL:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pQ.noAtmosphericDensityAltitude or lv>ft.timeToPeriapsis and ft.periapsis.altitude<pQ.noAtmosphericDensityAltitude or not sn()and ft.eccentricity>0.1 then c3="Re-Aligning Orbit"cE=false end elseif cE or qL:len()<15000+c6+ci then c3="Orbit complete, proceeding with reentry"fU("orCom","OB")bl=g5.position;pV=true;ce=true;q0.VectorToTarget,q0.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if ft.periapsis~=nil and ft.apoapsis~=nil and ft.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if ft.apoapsis~=nil then if(sn()or cE)and not N then if cE then b1=false;q4=0;pL=0;if not q0.VectorToTarget then c3="Orbit complete"fU("orCom","OB")ct.ToggleIntoOrbit()end else pR=pR+1;if pR>=2 then cE=true end end else if sn()then cC="Maintaining "else cC="Adjusting "pO=true;q5=sr*3.6+1;local sv=cD-ci;if sw==nil then sw=pid.new(0.1,0,1*0.1)end;sw:inject(sv-cN*dl(utils.smoothstep(2000-sv,-2000,2000)^6*10,1,10))pL=dl(sw:get(),-60,60)end;cC=cC.." - OrbitHeight: "..sp end end else local sx=2.75;local sy=eZ(fV(sq*sx))local ot=sy%50;if ot>0 then sy=sy-ot+50 end;b1=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sp;pL=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sp;sy=sy*0.75;pL=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sp;sy=sy*0.75;if cN<0 or pO then pL=utils.map(ci,cD*1.5,cD*1.01,-30,0)else pL=utils.map(ci,cD*0.99,cD*1.5,0,30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sp;pL=-65;local sz=utils.map(cN,-150,-400,1,0.55)sy=sy*sz end;q5=bN(sy)end end;if pL~=nil then if sA==nil then sA=pid.new(1*0.01,0,5*0.1)end;local sB=pL-cS;sA:inject(sB)local sC=dl(sA:get(),-0.5,0.5)pW=sC end end;if b4 and not cg and not cc then local function sD(di,ft)a.print(di)b1=false;be=false;b4=false;qW=false;bh="Aligning"q4=0;pU=false;c3=di;fU("apCom","AP")if ft or cc then if ft and gp~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pP=true end;ct.ToggleIntoOrbit()end end;local sE,sF=bl,false;if g5 and g5.planetname~="Space"then bd=true;if not qW then local sG=(g5.position-c8.center):normalize()local sH=sG:project_on_plane((c8.center-cO):normalize()):normalize()local sI=c8.center+sH*(c8.radius+gp)local sJ=g5.position+(g5.position-c8.center):normalize()*(gp-c8:getAltitude(g5.position))if(cO-sI):len()<(cO-sJ):len()then sE=sI else sE=sJ;bg=0 end;bl=sE;ct.showWayPoint(c8,bl)sF=true;qW=true end;bi=0 elseif g5 and g5.planetname=="Space"then if not qW then bi=0;sF=true;bd=true;qW=true;sE=g5.position+(cO-g5.position):normalize()*U;bl=sE end elseif g5==nil then bi=0;if not qW then local sG=(cO+cK*100000-c8.center):normalize()local sH=sG:project_on_plane((c8.center-cO):normalize()):normalize()if sH:len()<1 then sG=(cO+cH*100000-c8.center):normalize()sH=sG:project_on_plane((c8.center-cO):normalize()):normalize()end;sE=c8.center+sH*(c8.radius+gp)bl=sE;qW=true;sF=true;bd=true;ct.showWayPoint(c8,bl)end end;rb=(vec3(sE)-cO):len()local lt,eJ,eK=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)local lu=eJ;if eK~=nil and eJ~=nil then lu=math.min(eK,eJ)end;if lu~=nil and lu<rb and lt.name==c8.name then rb=lu end;local sh=true;local sK=(c8.center-(cO+vec3(cK):normalize()*rb)):len()-c8.radius;local lp=iK(sK)qc=gh;qd='{"label": "Projected Altitude", "value": "'..lp..'"}'if cL>50 and bc then local qL=vec3(sE)-cO;local sL=dl(math.deg(qo(q1,cK:normalize(),qL:normalize()))*cL/500,-90,90)local sM=dl(math.deg(qo(cI,cK:normalize(),qL:normalize()))*cL/500,-90,90)if eZ(sL)<20 and eZ(sM)<20 then sL=sL*2;sM=sM*2 end;if eZ(sL)<2 and eZ(sM)<2 then sL=sL*2;sM=sM*2 end;local s7=-math.deg(qo(q1,cH,cK:normalize()))local s8=-math.deg(qo(cI,cH,cK:normalize()))if sN==nil then sN=pid.new(2*0.01,0,2*0.1)end;sN:inject(sM-s8)local sO=dl(sN:get(),-1,1)pW=pW+sO;if sP==nil then sP=pid.new(2*0.01,0,2*0.1)end;sP:inject(sL-s7)local sQ=dl(sP:get(),-1,1)pX=pX+sQ;sF=true;if eZ(sL)>2 or eZ(sM)>2 then if bh~="Adjusting Trajectory"then bh="Adjusting Trajectory"fU("apAdj","AP")end else if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end end elseif bc and cL<=50 then qE((sE-cO):normalize())end;if sK<gp*1.5 then bg=cB/3.6;if g5==nil then dQ,bg=cq(c8):escapeAndOrbitalSpeed(sK)end end;local c6,c7;if not b5 then c6,c7=qk(cL)else c6,c7=qn(cL)end;if b4 and not bc and not bf and not be then local lt,lu=ct.checkLOS((bl-cO):normalize())if c8.name~=kB.name then if lt~=nil and c8.name~=lt.name and lu<rb then c3="Collision with "..lt.name.." in "..iK(lu).."\nClear LOS to continue."c4=5;q9=true else q9=false;c3=""end end end;if not q9 then if not bf and not be and not sF then sh=qE((sE-cO):normalize())elseif b5 and(be or bf)then sh=qE(-vec3(cK):normalize())end end;if bc then if not pU then b1=false;q4=a2;bR=fV(a2,2)pU=true end;local rc=c.getThrottle()if t then rc=bR end;local sR=99999;local oq=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local sS=dl(cK:dot((sE-cO):normalize()),0,cL)if sS>0 or oq>0 then sR=cp.computeTravelTime(sS,oq,rb-c6)end;if ac>df then ac=df-0.2 end;if cJ:len()>=ac or rc==0 and pU or a3/4>sR then bc=false;if bh~="Cruising"then fU("apCru","AP")bh="Cruising"end;bf=true;q4=0 end;local sT=rb;if sT<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pF and cW>2000 then ct.ResetAutopilots(1)c3="Autopilot cancelled to prevent crossing PvP Line"b1="PvP Prevent"pF=cW else pF=cW;return end end;bc=false;if bh~="Braking"then fU("apBrk","AP")bh="Braking"end;be=true;q4=0;pU=false end elseif be then if bh~="Orbiting to Target"then b1="AP Brk"end;if b5 then q4=1;q6=true end;local dQ,sr=cq(c8):escapeAndOrbitalSpeed((cO-kB.center):len()-kB.radius)local qL;if g5 then qL=g5.position-cO end;if g5 and g5.planetname=="Space"and cL<50 then if#bG>0 then if not qf then table.remove(bG,1)end;if#bG>0 then b1=false;if not qf then qf=2 end;return end end;sD("Autopilot complete, arrived at space location")b1="Space Arrival"elseif g5 and g5.planetname~="Space"and cL<=sr and(ft.apoapsis==nil or ft.periapsis==nil or ft.apoapsis.altitude<=0 or ft.periapsis.altitude<=0)then sD("Autopilot complete, commencing reentry")bl=g5.position;cc=true;ct.showWayPoint(c8,bl)elseif(g5 and g5.planetname~="Space"or g5==nil)and ft.periapsis~=nil and ft.periapsis.altitude>0 and ft.eccentricity<1 or bh=="Circularizing"then if bh~="Circularizing"then fU("apCir","AP")bh="Circularizing"end;if cL<=sr then if g5 then if cK:normalize():dot(qL:normalize())>0.4 then if bh~="Orbiting to Target"then fU("apOrb","OB")bh="Orbiting to Target"end;if not qY then b1=false;ct.showWayPoint(c8,g5.position)qY=true end else sD("Autopilot complete, proceeding with reentry")bl=g5.position;cc=true;ct.showWayPoint(c8,g5.position)qY=false end else sD("Autopilot completed, setting orbit",true)b1=false end end elseif bh=="Circularizing"then sD("Autopilot complete, fixing Orbit",true)end elseif bf then local sT=rb;if sT<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pF and cW>2000 then if not qf then qf=true end;c3="Autopilot cancelled to prevent crossing PvP Line"b1="Prevent PvP"pF=cW else pF=cW;return end end;bc=false;if bh~="Braking"then fU("apBrk","AP")bh="Braking"end;be=true end;local rc=c.getThrottle()if t then rc=bR end;if rc>0 then bc=true;if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end;bf=false end else if sh then if not bd and g5==nil or not bd and g5 and g5.planetname~="Space"then if not cc then bl=vec3(c8.center)+(gp+c8.radius)*cI;sU=q1;sV=cI end;bd=true elseif sh and not q9 then bc=true;if bh~="Accelerating"then bh="Accelerating"fU("apAcc","AP")end;if not pU then q4=a2;q6=true;bR=fV(a2,2)pU=true;b1=false end end end end elseif b4 and(g5~=nil and g5.planetname~="Space"and cg)then c3="Autopilot complete, starting reentry"fU("apCom","AP")bl=g5.position;b1=false;be=false;b4=false;qW=false;bh="Aligning"q4=0;pU=false;b3=true;cc=true;ct.showWayPoint(c8,g5.position)end;if c0 then cz=true;local sM=0;local fv=vec3(DUPlayer.getWorldPosition())local sW=fv-cO;local sX=vec3(sW):project_on(cH):len()local sY=vec3(sW):project_on(cI):len()local cb=dn(sX*sX+sY*sY)qE(sW:normalize())local mz=40;local sZ=cb<mz;local s_=100;local ro=dl((cb-mz)/2,10,s_)pW=0;local sh=eZ(pX)<0.1;if sh and cL<ro and not sZ then b1=false;sM=-20 else b1="Follow"sM=0 end;local t0=0;if eZ(sM-cS)>t0 then if t1==nil then t1=pid.new(2*0.01,0,2*0.1)end;t1:inject(sM-cS)local sO=t1:get()pW=sO end end;if b6 or b7 or b9 or br or bu~=nil then if bI then if cf==-1 then bb=bb-0.2 else bb=ci+bI-cf end end;local t2=bv;if t2 then t2=t2*dl(cL/100,0.1,1)*ch else t2=bt end;if not cg then t2=bt end;q3=cH:project_on_plane(cM):normalize():dot(cK)if q3>100 then c6,c7=cp.computeDistanceAndTime(q3,100,cj,0,0,t2)local t3,t4=cp.computeDistanceAndTime(100,0,cj,0,0,t2*0.55)c6=c6+t3 else c6,c7=cp.computeDistanceAndTime(q3,0,cj,0,0,t2*0.55)end;local sv=bb-ci-cN;local t5=200+cL;if b9 or cc then t6=2000+cL end;local t7=1;if b8 then t7=dl(cL/100,0.1,1)end;local sM=(utils.smoothstep(sv,-t5,t5)-0.5)*2*R*t7;if not b9 and not cc and not br and cH:dot(cK:normalize())<0.99 then sM=(utils.smoothstep(sv,-t5*dl(20-19*ch*10,1,20),t5*dl(20-19*ch*10,1,20))-0.5)*2*R*dl(2-ch*10,1,2)*t7 end;if not b6 then sM=0 end;if bu~=nil then if cY and not bA then sM=bu else bu=nil end end;cz=true;local t8=pW;if b9 then local t9=bN(cB)local ta,tb=cp.computeDistanceAndTime(cL,t9/3.6,cj,0,0,bt-kB.gravity*9.8*cj)ta=ta==-1 and 5000 or ta;local qX=ci-(kB.noAtmosphericDensityAltitude+ta)local tc=ci>kB.noAtmosphericDensityAltitude+ta*1.35;if tc then sM=S;if cL<=t9/3.6 and cL>t9/3.6-10 and eZ(cK:normalize():dot(cH))>0.9 and not cR then bV=false;q4=1 end elseif(cR or iG:getTargetSpeed(axisCommandId.longitudinal)~=t9)and not tc and not cg then q5=t9;q6=true end;if cR then if cL>t9/3.6 and not tc then b1="Reentry Limit"if bR>0 then q4=0 end else b1=false end else b1=false end;if cN>0 then b1="Reentry vSpd"end;if not pV then sM=-80;if ci<kB.surfaceMaxAltitude+(kB.atmosphereThickness-kB.surfaceMaxAltitude)*0.25 then c3="PARACHUTE DEPLOYED at "..fV(ci,0)b9=false;b7=true;lr=true;q4=0;sM=0;cz=p end elseif kB.noAtmosphericDensityAltitude>0 and tc then cz=true elseif not tc then if not cg and(cR or iG:getTargetSpeed(axisCommandId.longitudinal)~=t9)then q5=t9 end;if cL<t9/3.6+1 then b1=false;pV=false;b9=false;cz=true;q4=1 end end end;if cL>iZ and not cd and not br and not b7 and u then qE(vec3(cK))end;if cX or(br or cd)and bm>0 and cg then local qL;if cX then if type(cX)=="table"then qL=cX elseif cX<3 and cX>0 then qL=-cM:cross(cK)*5000 elseif cX>=3 then qL=cM:cross(cK)*5000 elseif cX<0 then qL=cK*25000 end elseif g5~=nil then qL=g5.position-cO else qL=c8.center-cO end;local sL=math.deg(qo(cM:normalize(),cK,qL))*2;local mC=math.rad(eZ(cT))if cL>aM and cg then local td=1000+cL;local te=(utils.smoothstep(sv-cN*10,-td,td)-0.5)*2*R;local tf=dl(90-te,0,180)pZ=dl(sL*2,-tf,tf)local tg=sL;sL=dl(dl(sL,-O*0.80,O*0.80)*math.cos(mC)+4*(cS-sM)*math.sin(math.rad(cT)),-O*0.80,O*0.80)local th=1;if pZ~=0 then th=eZ(mC/pZ)end;th=(90-dl(eZ(pZ-cT),0,90))/90;local ti=sM;if eZ(cT)>90 then ti=-ti end;sM=th*dl(dl(ti*math.cos(mC),-P*0.8,P*0.8)+eZ(dl(eZ(tg)*math.sin(mC),-P*0.80,P*0.80)),-P*0.80,P*0.80)else pZ=0;sL=dl(sL,-O*0.80,O*0.80)end;local tj=s7-sL;if cX and eZ(tj)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and eZ(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fU("180Off","BR")return end;if not cA and cL>aM and cg then if tk==nil then tk=pid.new(2*0.01,0,2*0.1)end;tk:inject(tj)local sQ=dl(tk:get(),-1,1)pX=pX+sQ elseif cg and cf>-1 or cL<aM then qE(qL)elseif cA and cg then if(s7<-O or s7>O)and cg then qE(cK)end;if(s8<-P or s8>P)and cg then sM=dl(cS-s8,cS-P*0.80,cS+P*0.80)end end;if g5~=nil and not cd then local si=kB:getAltitude(g5.position)local qX=qL:project_on_plane(cM):len()lr=true;if bb<kB.noAtmosphericDensityAltitude and not cd and not b8 and not b9 and(qX<=c6 and qL:len()<kB.radius)and(cK:project_on_plane(cM):normalize():dot(qL:project_on_plane(cM):normalize())>0.99 or lx=="Finalizing Approach")then lx="Finalizing Approach"if#bG>0 then if not qf then table.remove(bG,1)end;if#bG>0 then if not qf then qf=2 end;return end end;q4=0;if b6 then ct.ToggleAltitudeHold()br=true end;b1="AP Finalizing"elseif not b8 then b1=false end;if lx=="Finalizing Approach"and(q3<0.1 or qX<0.1 or tl~=nil and tl<qX)then fU("bklOn","BL")b7=true;db=true;if g5.heading then dc=g5.heading else dc=nil end;br=false;lx="Proceeding to Waypoint"cZ=false end;tl=qX end elseif br and not cg and bb>kB.noAtmosphericDensityAltitude and not(cd or b9)then if g5~=nil and c8.name==kB.name then local qL=g5.position-cO;local si=kB:getAltitude(g5.position)local qX=dn(qL:len()^2-(ci-si)^2)local t2=bv;if t2 then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,t2/2)lr=true;if qX<=c6+cL*s6/2 and cK:project_on_plane(cM):normalize():dot(qL:project_on_plane(cM):normalize())>0.99 then if kB.hasAtmosphere then b1=false;b3=false;pV=true;cc=false;ce=true;b4=false;ct.BeginReentry()end end;tl=qX end end end;if not cg and cf==-1 and(b6 and bb>kB.noAtmosphericDensityAltitude)and not(cd or bA or b9)then if not cE and not bA then cD=bb;pP=true;if br then q0.VectorToTarget=true end;ct.ToggleIntoOrbit()br=false;pN=true end end;if cA and cg and cf==-1 and cL>aM and lx~="Finalizing Approach"then qE(cK)sM=dl(cS-s8,cS-P*0.80,cS+P*0.80)end;pW=t8;local qx=-1;if b7 then if not qa then rP=false;if not cR then q4=0 end;iG:setTargetGroundAltitude(500)iG:activateGroundEngineAltitudeStabilization(500)bC=true;if not cg then rP=true end;qa=true end;sM=0;local tm=false;local tn=math.abs(q3)if not q and cQ then tm=antigrav.getBaseAltitude()if tm<kB.surfaceMaxAltitude and g5==nil or g5~=nil and kB:getAltitude(g5.position)>tm then tm=false end else tm=false end;if dc then if tn<0.05 then if cN>-Q then b1=false else b1="BL Align BLR"end;if qE(dc,0.001)then dc=nil;cz=p else pW=0;cz=true end else b1="BL Align Hzn"end;if tm and eZ(ci-tm)<250 then b1="AGG Align"end else local to=false;local tp=30;if tn<10 and se~=nil and se>0 then local tq=dl(ch,0.4,2)local t2=bv*dl(cL/100,0.1,1)*tq;local tr=se*tq+t2-oe;local ts=t2/2-oe;local tt=cL-dn(eZ(ts/2)*20/(0.5*cj))*utils.sign(ts)if tt<0 then tt=0 end;local tu;if cL>100 then local tv,dQ=cp.computeDistanceAndTime(cL,100,cj,0,0,t2)local tw,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,dn(t2))tu=tv+tw else tu=cp.computeDistanceAndTime(cL,0,cj,0,0,dn(t2))end;if tu<20 then b1=false else local tx=0;if tt>100 then local ty,dQ=cp.computeDistanceAndTime(tt,100,cj,0,0,tr)local tz,dQ=cp.computeDistanceAndTime(100,0,cj,0,0,se*tq+dn(t2)-oe)tx=ty+tz else tx,dQ=cp.computeDistanceAndTime(tt,0,cj,0,0,se*tq+dn(t2)-oe)end;tx=(tx+15+cL*s6)*1.1;local tA=db and g5~=nil and kB:getAltitude(g5.position)>0 and g5.safe;local si=nil;if tm and tm<ci then si=tm elseif tA then si=kB:getAltitude(g5.position)+250 elseif ci>kB.surfaceMaxAltitude then si=kB.surfaceMaxAltitude end;if c_ then local tB=kB:getAltitude(c_[1].center)if si then if tB>si then si=tB end else si=tB end end;if si~=nil then local tC=ci-si;to=true;if tC<=tx or tx==-1 or tn>0.05 and db then if tn>0.05 and db then b1="BL AP Hzn"else b1="BL Stop Dist"end else b1=false end end end end;qx=cf;if qx>-1 then if not tm and not bn then q7=true;iG:setTargetGroundAltitude(a0)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qx-5<a0 then b7=false;b6=false;b_=0;if rP then qP(0,1)end;b1="BL Complete"cz=p;db=false;qa=false else if cN<-5 then b1="BL Slowing"else b1=false end end elseif not to then if lr and cK:normalize():dot(-gr)<0.999 then b1="BL Strong"qE()elseif tn>10 or tn>0.05 and db then b1="BL hSpd"elseif cN<-Q then b1="BL BLR"if rP then qP(0,1)end else if rP then qP(-1)end;b1=false end end end else qa=false end;if b8 or cd then local lt,eK,eJ;if bl~=nil then lt,eK,eJ=co:getPlanetarySystem(0):castIntersections(cO,(bl-cO):normalize(),function(es)if es.noAtmosphericDensityAltitude>0 then return es.radius+es.noAtmosphericDensityAltitude else return es.radius+es.surfaceMaxAltitude*1.5 end end)end;if cQ and not cd then if ci>=bb-50 and cL>iZ then b8=false;if not b4 and not br then b1="ATO Agg Arrive"q4=0 end end elseif eZ(sM)<15 and ci/bb>0.75 then b8=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<iZ then b4=true;cd=false;b6=false;b8=false;q4=0 elseif cd then q4=0;b1="ATO Space"end elseif cd and not cg and c8~=nil and(lt==nil or lt.name==c8.name)then b4=true;cd=false;b6=false;b8=false;if not cR then q4=0 end;bc=true end end;local tD=cf>-1;local tE=cS;if(br or cd or cX)and not tD and cL>aM and cg then local mC=math.rad(eZ(cT))tE=cS*eZ(math.cos(mC))+s8*math.sin(mC)end;local tF=dl(sM-tE,-P*0.80,P*0.80)if not cg and br then tF=dl(sM-tE,-85,R)elseif not cg then tF=dl(sM-tE,-R,R)end;if eZ(cT)<5 or br or cX or b7 or tD or b6 then if t1==nil then t1=pid.new(5*0.01,0,5*0.1)end;t1:inject(tF)local sO=t1:get()pW=pW+sO end end;if antigrav~=nil and(antigrav and not q and ci<200000)then if bw==nil or bw<1000 then bw=1000 end;if tG~=bw then tG=bw;qe=tG end end;if(cg or b9 or ce)and t and cR then if tH==nil then tH=pid.new(0.1,0,1)end;local tI=0;if aZ>0 and not b9 and ch>0.005 and ch<0.1 and cN>-10 then local tJ=bP.getFrictionBurnSpeed()*aZ;local tK=cB/3.6;if tJ>tK then tI=tJ-tK-1 end end;tH:inject(cB/3.6+tI-cK:dot(cH))local tL=tH:get()bU=dl(tL,-1,1)if not d7 then if bU<bR and(ch>0.005 or b9 or ce)then bT=true;d7=dl(bU,0.01,1)else bT=false;d7=bR end end;if tM==nil then tM=pid.new(1*0.01,0,1*0.1)end;tM:inject(cK:len()-cB/3.6-tI)local tN=dl(tM:get(),0,1)if cg and cN<-80 or(ch>0.005 or b9 or ce)then bS=tN end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dl(bU,0.01,1)end;local tO=''local tP=vec3()local tQ=rm(axisCommandId.vertical,b_*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tQ,rL)local tR='thrust analog longitudinal 'if bD=="All"or bD=="Longitude"then tR=tR..aV end;local tS=iG:getAxisCommandType(axisCommandId.longitudinal)local tT=iG:composeAxisAccelerationFromThrottle(tR,axisCommandId.longitudinal)local tU=rA(axisCommandId.lateral,bz*1000)tO=tO..' , '.."lateral airfoil , lateral ground "tP=tP+tU;if tP:len()>constants.epsilon then d:setEngineForceCommand(tO,tP,rL,'','','',rM)end;d:setEngineForceCommand(tR,tT,rK)local tV='thrust analog vertical fueled 'local tW='thrust analog lateral fueled 'if bD=="All"or bD=="Lateral"then tW=tW..aW end;if bD=="All"or bD=="Vertical"then tV=tV..aX end;if b_~=0 or b7 and b1 or not bn and not bC then d:setEngineForceCommand(tV,tQ,rK)else d:setEngineForceCommand(tV,vec3(),rK)end;if bz~=0 then d:setEngineForceCommand(tW,tU,rK)else d:setEngineForceCommand(tW,vec3(),rK)end;if rT==0 then rT=bS end;local tX=-rT*(aR*cK+aS*rX)d:setEngineForceCommand('brake',tX)else if t then if not d7 then d7=bR end end;local ro=c.getAxisCommandValue(0)if not cR then if tM==nil then tM=pid.new(1*0.01,0,1*0.1)end;tM:inject(cK:len()-ro/3.6)local tN=dl(tM:get(),0,1)rT=dl(rT+tN,0,1)end;local tX=-rT*(aR*cK+aS*rX)d:setEngineForceCommand('brake',tX)local tO=''local tP=vec3()local tY=false;local tR='thrust analog longitudinal 'if aV~="none"and(bD=="All"or bD=="Longitude")then tR=tR..aV end;local tS=iG:getAxisCommandType(axisCommandId.longitudinal)if tS==axisCommandType.byThrottle then local tT=iG:composeAxisAccelerationFromThrottle(tR,axisCommandId.longitudinal)d:setEngineForceCommand(tR,tT,rK)elseif tS==axisCommandType.byTargetSpeed then local tT=iG:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tO=tO..' , '..tR;tP=tP+tT;if iG:getTargetSpeed(axisCommandId.longitudinal)==0 or iG:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iG:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tY=true end end;local tW='thrust analog lateral 'if aW~="none"and(bD=="All"or bD=="Lateral")then tW=tW..aW end;local tZ=iG:getAxisCommandType(axisCommandId.lateral)if tZ==axisCommandType.byThrottle then local t_=iG:composeAxisAccelerationFromThrottle(tW,axisCommandId.lateral)d:setEngineForceCommand(tW,t_,rK)elseif tZ==axisCommandType.byTargetSpeed then local tU=iG:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tO=tO..' , '..tW;tP=tP+tU end;local tV='thrust analog vertical 'if aX~="none"and(bD=="All"or bD=="Vertical")then tV=tV..aX end;local u0=iG:getAxisCommandType(axisCommandId.vertical)if u0==axisCommandType.byThrottle then local tQ=iG:composeAxisAccelerationFromThrottle(tV,axisCommandId.vertical)if b_~=0 or b7 and b1 then d:setEngineForceCommand(tV,tQ,rK,'airfoil','ground','',rM)else d:setEngineForceCommand(tV,vec3(),rK)d:setEngineForceCommand('airfoil vertical',tQ,rK,'airfoil','','',rM)d:setEngineForceCommand('ground vertical',tQ,rK,'ground','','',rM)end elseif u0==axisCommandType.byTargetSpeed then if b_<0 then d:setEngineForceCommand('hover',vec3(),rK)end;local u1=iG:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tO=tO..' , '..tV;tP=tP+u1 end;if tP:len()>constants.epsilon then if rT~=0 or tY or eZ(rX:dot(cH))<0.5 then tO=tO..', brake'end;d:setEngineForceCommand(tO,tP,rL,'','','',rM)end end;local u2=aO*(s0-r_)local u3=vec3(bP.getWorldAirFrictionAngularAcceleration())u2=u2-u3;d:setEngineTorqueCommand('torque',u2,rK,'airfoil','','',rM)d:setBoosterCommand('rocket_engine')if c5 and not n then local fp=cJ:len()local u4=0.15;if not cR then local u5=iG:getTargetSpeed(axisCommandId.longitudinal)if fp*3.6>u5*(1-u4)and u6 then u6=false;d:toggleBoosters()elseif fp*3.6<u5*(1-u4)and not u6 then u6=true;d:toggleBoosters()end else local rc=c.getThrottle()if t then rc=bR*100 end;local ro=rc/100;if not cg then ro=ro*ac;if fp>=ro*(1-u4)and u6 then u6=false;d:toggleBoosters()elseif fp<ro*(1-u4)and not u6 then u6=true;d:toggleBoosters()end else local t9=bN(cB)ro=ro*t9/3.6;if fp>=ro*(1-u4)and u6 then u6=false;d:toggleBoosters()elseif fp<ro*(1-u4)and not u6 then u6=true;d:toggleBoosters()end end end end end;if u7 then for dL,dx in pairs(u7)do pD[dL]=dx end end;cf=qs()return pD end;local function u8(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u9,iF,iG,iH,ua,gM,fV,e4,dm,dl,fU,iJ,pC)local bP=DUConstruct;local ub={}local uc=true;local ud=5;local ue=5;local uf=ud;local ug=ue;local uh=bQ;function ub.landingGear(q7)bn=not bn;if bn then br=false;bu=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not q7 then fU("bklOn","BL")lr=true;b9=false;b8=false;ba=false;if bA then ct.ToggleIntoOrbit()end;if b7 then db=not db end;b7=true;cz=true;bn=false else if bW then fU("grOut","LG",1)d.control.deployLandingGears()end;db=false;iG:setTargetGroundAltitude(a0)if cg then b1="Landing"end end;b6=false;bI=false elseif bW and not b7 then fU("grOut","LG",1)d.control.deployLandingGears()end else if bW then fU("grIn","LG",1)d.control.retractLandingGears()end;iG:activateGroundEngineAltitudeStabilization(qS)if bC then if a0<iG.targetGroundAltitude then iG:setTargetGroundAltitude(iG.targetGroundAltitude)else iG:setTargetGroundAltitude(_)end end end end;function ub.startControl(ui)local function uj(r7)local r8=1;local function uk(ul,r7)local um={kB.surfaceMaxAltitude+100,kB.spaceEngineMinAltitude-0.01*kB.noAtmosphericDensityAltitude,kB.noAtmosphericDensityAltitude+W,kB.radius*(V-1)+kB.noAtmosphericDensityAltitude}local un=ul;for dQ,dx in ipairs(um)do if r7 and un>dx then ul=dx elseif ul<dx and not r7 then ul=dx;break end end;return ul end;if r7 then r8=-1 end;if not q and cQ then if c1 and r7 then bw=1000 elseif bw~=nil then bw=bw+r8*ue;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end else bw=tG+r8*100 end elseif b6 or ba or bA then if bA then if c1 then cD=uk(cD,r7)else cD=cD+r8*ud end;if cD<kB.noAtmosphericDensityAltitude then cD=kB.noAtmosphericDensityAltitude end else if c1 and cg then bb=uk(bb,r7)bI=false else bb=bb+r8*ud;if bI then if bb>100 then bI=false else iG:updateTargetGroundAltitudeFromActionStart(r8*1.0)bI=d:getTargetGroundAltitude()end end end end else iG:updateTargetGroundAltitudeFromActionStart(r8*1.0)end end;local function uo(up)if not cg then c3="Flight Assist in Atmo only"return end;local du=type(up)if cX==nil then if du=="table"then if b4 or br then ct.ToggleAutopilot()end;fU("180On","BR")elseif up==1 then fU("bnkLft","BR")else fU("bnkRht","BR")end;if not b6 and not b4 and not br then ct.ToggleAltitudeHold()if du~="table"then up=up+1 end end;cX=up else fU("180Off","BR")cX=nil end end;local function uq()if iH()==1 then c9=0;ca=0;ua(bj)elseif iF()==1 and y then cy=false;cx=false end;c1=false end;if ui=="gear"then cv.landingGear()elseif ui=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ui=="forward"then if p4 and not cg and not b4 then b3=not b3;b2=false else bX=bX-1 end elseif ui=="backward"then if p4 then if not cg then if not b4 then b2=not b2;b3=false else b5=not b5 end else uo(-cK*5000)end else bX=bX+1 end elseif ui=="left"then if p4 then uo(1)else bY=bY-1 end elseif ui=="right"then if p4 then uo(3)else bY=bY+1 end elseif ui=="yawright"then bZ=bZ-1;dc=nil elseif ui=="yawleft"then bZ=bZ+1;dc=nil elseif ui=="straferight"then iG:updateCommandFromActionStart(axisCommandId.lateral,1.0)bz=1 elseif ui=="strafeleft"then iG:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bz=-1 elseif ui=="up"then ct.vertical(1)if cf-3<a0 and ci>0 and bn then cv.landingGear()end elseif ui=="down"then ct.vertical(-1)elseif ui=="groundaltitudeup"then uj()elseif ui=="groundaltitudedown"then uj(true)elseif ui=="option1"then ur=false;if p4 and c1 then local us=""for M=1,#d2 do us=us.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fV(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..us)return end;cs.adjustAutopilotTargetIndex()elseif ui=="option2"then ur=false;if p4 and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;c3="Deboarded All Passengers"return end;cs.adjustAutopilotTargetIndex(1)elseif ui=="option3"then ur=false;if p4 and c1 then local us=""for M=1,#d3 do us=us.."| ID: "..d3[M].." Mass: "..fV(b.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..us)return end;if x then if w then w=false else w=true end;if cu then cu.ToggleRadarPanel()end end elseif ui=="option4"then ur=false;if p4 and c1 then for M=1,#d3 do b.forceUndock(d3[M])end;c3="Undocked all ships"return end;cX=nil;ct.ToggleAutopilot()elseif ui=="option5"then ur=false;ct.ToggleLockPitch()elseif ui=="option6"then ur=false;if p4 and c1 then if shield then cw.ventShield()else c3="No shield found"end;return end;ct.ToggleAltitudeHold()elseif ui=="option7"then ur=false;if p4 and c1 then if shield then shield.toggle()return else c3="No shield found"return end end;E=not E;if E then c3="Collision System Enabled"else c3="Collision System Secured"end elseif ui=="option8"then ur=false;if p4 and c1 then if bm>0 and g5~=nil then ct.routeWP()else c3="Select a saved wp on IPH to add to or remove from route"end;return end;bC=not bC;if not bC then c3="DeCoupled Mode - Ground Stabilization off"iG:deactivateGroundEngineAltitudeStabilization()fU("gsOff","GS")else c3="Coupled Mode - Ground Stabilization on"iG:activateGroundEngineAltitudeStabilization(qS)de=true;fU("gsOn","GS")end elseif ui=="option9"then ur=false;if p4 and c1 then iG:resetCommand(axisCommandId.longitudinal)iG:resetCommand(axisCommandId.lateral)iG:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()==1;if ck then fU("gyOn","GA")else fU("gyOff","GA")end else c3="No gyro found"end elseif ui=="lshift"then d0=false;if p4 then c1=true elseif c1 then uq()else if iH()==1 then c1=true;bj=iH()ua(1)elseif iF()==1 and y then c1=true;cy=false;cx=false end end elseif ui=="brake"then if a_ or p4 then ct.BrakeToggle("Manual")elseif not b1 then ct.BrakeToggle("Manual")else b1="Manual"end elseif ui=="lalt"then ur=true;p4=true;if iF()==0 and not i and g=="keyboard"then ua(1)end elseif ui=="booster"then if n then d:toggleBoosters()elseif not c5 then if not u6 then d:toggleBoosters()u6=true end;c5=true else if u6 then d:toggleBoosters()u6=false end;c5=false end elseif ui=="stopengines"then local function ut()if bQ-uh<1.5 then fU("clear","CA")ct.clearAll()end end;ut()uh=bQ;if iG:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p4 then if cB>0 then cB=0 else cB=X end elseif bR~=0 then iG:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iG:getTargetSpeed(axisCommandId.longitudinal)~=0 then iG:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(ac*3.6)end end end elseif ui=="speedup"then ct.changeSpd()elseif ui=="speeddown"then ct.changeSpd(true)elseif ui=="antigravity"and not q then if antigrav~=nil then ct.ToggleAntigrav()else c3="No antigrav found"end elseif ui=="leftmouse"then c2=true;uq()ur=false end end;function ub.stopControl(ui)local function uu()if not q and cQ then ug=ue end;if b6 or ba or bA then uf=ud end end;if ui=="forward"then bX=0 elseif ui=="backward"then bX=0 elseif ui=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif ui=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif ui=="yawright"then bZ=0 elseif ui=="yawleft"then bZ=0 elseif ui=="straferight"then iG:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bz=0 elseif ui=="strafeleft"then iG:updateCommandFromActionStop(axisCommandId.lateral,1.0)bz=0 elseif ui=="up"then ct.vertical(0,-1)elseif ui=="down"then ct.vertical(0,1)elseif ui=="groundaltitudeup"then uu()ur=false elseif ui=="groundaltitudedown"then uu()ur=false elseif ui=="brake"then if not a_ and not p4 then if b1 then ct.BrakeToggle()else b1=false end end elseif ui=="lalt"then if c1 then c1=false end;if iF()==0 and i then if ur then if iH()==1 then ua(0)else ua(1)end else ur=true end elseif iF()==0 and not i and g=="keyboard"then ua(0)end;p4=false end end;function ub.loopControl(ui)local function uv(r7)local r8=1;if r7 then r8=-1 end;if not q and cQ then if bw~=nil then bw=bw+r8*ug;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end;ug=dl(ug*1.05,ue,50)else bw=tG+r8*100 end elseif b6 or ba or bA then if bA then cD=cD+r8*uf;if cD<kB.noAtmosphericDensityAltitude then cD=kB.noAtmosphericDensityAltitude end else bb=bb+r8*uf end;uf=dl(uf*1.05,ud,50)else iG:updateTargetGroundAltitudeFromActionLoop(r8*1.0)end end;local function uw(r7)local r8=1;if r7 then r8=-1 end;if not c1 then if t and not p4 then bR=dl(bR+r8*aG/100,-1,1)else iG:updateCommandFromActionLoop(axisCommandId.longitudinal,r8*aG)end end end;if ui=="groundaltitudeup"then if not c1 then uv()end elseif ui=="groundaltitudedown"then if not c1 then uv(true)end elseif ui=="speedup"then uw()elseif ui=="speeddown"then uw(true)end end;function ub.inputTextControl(r6)local function ux(uy,fv,gz)local function uz(fv)local dD=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dE='::pos{'..dD..','..dD..','..dD..','..dD..','..dD..'}'local dU,dV,e1,e2,e3=e4(fv,dE)if dU=="0"and dV=="0"then return vec3(dm(e1),dm(e2),dm(e3))end;e2=math.rad(e2)e1=math.rad(e1)local kB=e[dm(dU)][dm(dV)]local eV=math.cos(e1)local uA=vec3(eV*math.cos(e2),eV*math.sin(e2),math.sin(e1))return kB.center+(kB.radius+e3)*uA end;local fX=uz(fv)return cs.AddNewLocation(uy,fX,gz)end;local M;local uB,iu=nil,nil;local uC="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(r6," ")uB=r6;if M~=nil then uB=string.sub(r6,0,M-1)iu=string.sub(r6,M+1)end;if uB=="/help"or uB=="/commands"then for ls in string.gmatch(uC,"([^\n]+)")do a.print(ls)end;return elseif uB=="/setname"then if iu==nil or iu==""then c3="Usage: ah-setname Newname"return end;if bm>0 and g5~=nil then cs.UpdatePosition(iu)else c3="Select a saved target to rename first"end elseif shield and uB=="/resist"then cw.setResist(iu)elseif uB=="/addlocation"or string.find(r6,"::pos")~=nil then local gz=false;local uy="0-Temp"if iu==nil or iu==""or uB~="/addlocation"then iu=uB;gz=true end;M=string.find(iu,"::")if not gz then uy=string.sub(iu,1,M-2)end;local fv=string.sub(iu,M)ux(uy,fv,gz)elseif uB=="/agg"then if iu==nil or iu==""then c3="Usage: /agg targetheight"return end;iu=dm(iu)if iu<1000 then iu=1000 end;bw=iu;c3="AGG Target Height set to "..iu elseif uB=="/G"then if iu==nil or iu==""then c3="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if iu=="dump"then for dL,dx in pairs(iJ())do if type(dx.get())=="boolean"then if dx.get()==true then a.print(dL.." true")else a.print(dL.." false")end elseif dx.get()==nil then a.print(dL.." nil")else a.print(dL.." "..dx.get())end end;return end;M=string.find(iu," ")local uD=string.sub(iu,0,M-1)local uE=string.sub(iu,M+1)for dL,dx in pairs(iJ())do if dL==uD then local uF=type(dx.get())if uF=="number"then uE=dm(uE)if dL=="AtmoSpeedLimit"then cB=uE end end;c3="Variable "..uD.." changed to "..uE;if dL=="MaxGameVelocity"then uE=uE/3.6;if uE>df-0.2 then uE=df-0.2;c3="Variable "..uD.." changed to "..fV(uE*3.6,1)end end;if uF=="boolean"then if string.lower(uE)=="true"then uE=true else uE=false end end;dx.set(uE)return end end;c3="No such global variable: "..uD elseif uB=="/deletewp"then if bm>0 and g5~=nil then cs.ClearCurrentPosition()else c3="Select a custom wp to delete first in IPH"end elseif uB=="/copydatabank"then if dbHud_2 then pC(true)else c3="Spare Databank required to copy databank"end elseif uB=="/iphWP"then if bm>0 then a.print(ct.showWayPoint(c8,bl,true))a.print(json.encode(bl))c3="::pos waypoint shown in lua chat in local and world format"else c3="No target selected in IPH"end elseif uB=="/createPrivate"then local uG="privatelocations = {\n"local uH=""if#d9>0 then for dL,dx in pairs(d9)do uG=uG.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uG=uG.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uG=uG.."safe = true},\n"else uG=uG.."safe = false},\n"end end end;uH=#d9 .."-Private "if iu=="all"then for dL,dx in pairs(bq)do uG=uG.."{position = {x = "..dx.position.x..", y = "..dx.position.y..", z = "..dx.position.z.."},\n ".."name = '*"..dx.name.."',\n planetname = '"..dx.planetname.."',\n gravity = "..dx.gravity..",\n"if dx.heading then uG=uG.."heading = {x = "..dx.heading.x..", y = "..dx.heading.y..", z = "..dx.heading.z.."},\n"end;if dx.safe then uG=uG.." safe = true},\n"else uG=uG.."safe = false},\n"end end;uH=uH..#bq.."-Public "end;uG=uG.."}\n return privatelocations"if u9 then u9.setHTML(uG)end;c3=uH.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c4=7 end end;function ub.tagTick()if bD=="Off"then bD="All"elseif bD=="All"then bD="Longitude"elseif bD=="Longitude"then bD="Lateral"elseif bD=="Lateral"then bD="Vertical"else bD="Off"end;c3="Extra Engine Tags: "..bD;c.stopTimer("tagTick")end;if uI then for dL,dx in pairs(uI)do ub[dL]=dx end end;return ub end;local function uJ(d,b,c,e,vBooster,hover,pB,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iC,u9)local a=DUSystem;local bP=DUConstruct;local uK=DUPlayer;local uL=DULibrary;local uM={}local dk=string.format;local iD=json.decode;local uN=json.encode;local pu=b.getElementMaxHitPointsById;local iE=b.getElementMassById;local iF=d.control.isRemoteControlled;local e4=string.match;local gM=a.destroyWidgetPanel;local fS=a.updateData;local fT=a.addDataToWidget;local ua=a.lockView;local iH=a.isViewLocked;local dn=math.sqrt;local dm=tonumber;local eZ=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local eU=math.atan;local bM=a.getArkTime;local dl=utils.clamp;local iG=d.axisCommandManager;local gO=13;local iM=b.getElementIdList()local iN=0;local function dp(eC,eD)if eC==0 then return eZ(eD)<1e-09 elseif eD==0 then return eZ(eC)<1e-09 else return eZ(eC-eD)<math.max(eZ(eC),eZ(eD))*dC end end;local function fV(dD,uO)local r8=10^(uO or 0)return bN(dD*r8+0.5)/r8 end;local function iI(uP,uQ)for dL,dx in pairs(uQ)do if type(dL)=="string"then uP[dL]=dx else uP[#uP+1]=uQ[dL]end end;return uP end;local function iJ(uR)local uS={}if not uR then iI(uS,L)iI(uS,ab)iI(uS,aE)iI(uS,aY)return uS elseif uR=="boolean"then return L elseif uR=="handling"then return ab elseif uR=="hud"then return aE elseif uR=="physics"then return aY end end;local function pC(uT)local function uU(uV)for dL,dx in pairs(uV)do dbHud_1.setStringValue(dL,uN(dx.get()))if uT and dbHud_2 then dbHud_2.setStringValue(dL,uN(dx.get()))end end end;if dbHud_1 then uU(bJ)uU(iJ())a.print("Saved Variables to Datacore")if uT and dbHud_2 then c3="Databank copied.  Remove copy when ready."end end end;local function fU(uW,uX,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uW..".mp3")end;local function gN(hA,hB,r6,jT,uY)return dk([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jT or"",hA,hB,uY or"",r6)end;local function iK(cb,uZ)uZ=uZ or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fV(cb,uZ)..unit end;local function iL(u_)local v0=0;local v1=0;local v2=0;if u_<60 then u_=bN(u_)elseif u_<3600 then v0=bN(u_/60)u_=bN(u_%60)elseif u_<86400 then v1=bN(u_/3600)v0=bN(u_%3600/60)else v2=bN(u_/86400)v1=bN(u_%86400/3600)end;if v2>0 then return v2 .."d "..v1 .."h "elseif v1>0 then return v1 .."h "..v0 .."m "elseif v0>0 then return v0 .."m "..u_.."s"elseif u_>0 then return u_.."s"else return"0s"end end;local function v3()if radar_1 then cu=gL(b,a,c,radar_1,radar_2,warpdrive,eZ,gM,dn,gN,dm,gO,fU)end end;function uM.radarSetup()v3()end;function uM.onStart()local v4=false;local function v5()local function v6(v7)local v8=dbHud_1.hasKey;for dL,dx in pairs(v7)do if v8(dL)then local dG=iD(dbHud_1.getStringValue(dL))if dG~=nil then dx.set(dG)v4=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then v6(iJ())coroutine.yield()v6(bJ)else v6(bJ)c3="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values"c4=5;v4=false end;coroutine.yield()if v4 then c3="Loaded Saved Variables"elseif not f then c3="No Databank Saved Variables Found\nVariables will save to Databank on standing"c4=5 end;if#bq>0 then da=iI(da,bq)end else c3="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;a_=j;g=string.lower(g)cz=p;cB=X;if bx+180<bQ then bv=0 end;bx=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c3="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c4=7 end;if antigrav and not q then if bw==nil then bw=ci end;antigrav.setTargetAltitude(bw)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d9>0 then da=iI(da,d9)end end;lx="Proceeding to Waypoint"if not ac or ac<0 then ac=bP.getMaxSpeed()-0.1 end end;local function v9()local function va(vb,vc)if vb>vc then vc=vb end;local vd,ve=0,0;if a7>0 then vd=a7*0.05 end;if a8>0 then ve=a8*0.05 end;vc=vc*(1-(vd+ve))return vc end;local vf=b.getElementNameById;local vg=au~=0 and av~=0;local vh=_G["atmofueltank_size"]local vi=_G["spacefueltank_size"]local vj=_G["rocketfueltank_size"]for dL in pairs(iM)do local type=b.getElementDisplayNameById(iM[dL])if e4(type,'^.*Atmospheric Engine$')then if e4(tostring(b.getElementTagsById(iM[dL])),'^.*vertical.*$')and b.getElementForwardById(iM[dL])[3]>0 then cP=true end end;if e4(type,'^.*Space Engine$')then cG=true;if e4(tostring(b.getElementTagsById(iM[dL])),'^.*vertical.*$')then local vk=b.getElementForwardById(iM[dL])if vk[3]<0 then vl=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local pw=pu(iM[dL])if pw>10000 then gO=110 elseif pw>1000 then gO=55 elseif pw>150 then gO=27 end end;iN=iN+pu(iM[dL])if vg and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pw=pu(iM[dL])local om=iE(iM[dL])local vb=0;local jM=bM()if type=="Atmospheric Fuel Tank"then local vc=400;local vm=35.03;if pw>10000 then vc=51200;vm=5480 elseif pw>1300 then vc=6400;vm=988.67 elseif pw>150 then vc=1600;vm=182.67 end;vb=om-vm;if a4>0 then vc=vc+vc*a4*0.2 end;vc=va(vb,vc)local gy=vf(iM[dL])local jK=0;for jL=1,vh do if gy==iD(c["atmofueltank_"..jL].getWidgetData()).name then jK=jL;break end end;local vn={iM[dL],string.sub(gy,1,12),vc,vm,vb,jM,jK}cl[#cl+1]=vn end;if type=="Rocket Fuel Tank"then local vc=320;local vm=173.42;if pw>65000 then vc=40000;vm=25740 elseif pw>6000 then vc=5120;vm=4720 elseif pw>700 then vc=640;vm=886.72 end;vb=om-vm;if a6>0 then vc=vc+vc*a6*0.1 end;vc=va(vb,vc)local gy=vf(iM[dL])local jK=0;for jL=1,vj do if gy==iD(c["rocketfueltank_"..jL].getWidgetData()).name then jK=jL;break end end;local vn={iM[dL],string.sub(gy,1,12),vc,vm,vb,jM,jK}cn[#cn+1]=vn end;if type=="Space Fuel Tank"then local vc=600;local vm=35.03;if pw>10000 then vc=76800;vm=5480 elseif pw>1300 then vc=9600;vm=988.67 elseif pw>150 then vc=2400;vm=182.67 end;vb=om-vm;if a5>0 then vc=vc+vc*a5*0.2 end;vc=va(vb,vc)local gy=vf(iM[dL])local jK=0;for jL=1,vi do if gy==iD(c["spacefueltank_"..jL].getWidgetData()).name then jK=jL;break end end;local vn={iM[dL],string.sub(gy,1,12),vc,vm,vb,jM,jK}cm[#cm+1]=vn end end end;if not cP then ba,b0=false,false end end;local function vo()if gyro~=nil then ck=gyro.isActive()==1 end;if not bC then iG:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ua(1)else ua(0)end;if door and(cg or not cg and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not q then antigrav.showWidget()end end;if iF()==1 and k then uK.freeze(1)else uK.freeze(0)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bn=d.control.isAnyLandingGearDeployed()==1 or cf~=-1 and cf-3<a0;if cf~=-1 or not cg and cJ:len()<50 then b1="Startup"else b1=false end;iG:setTargetGroundAltitude(a0)pi=cg end;local function vp()local vq={}local function vr()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vs={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}local vt={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=7700,[100]=12511,[110]=7792,[120]=11766}for vu,vv in pairs(e)do e[vu][0]=vr()e[vu][0].systemId=vu;vq[vu]={}for vw,kB in pairs(e[vu])do kB.gravity=kB.gravity/9.8;kB.center=vec3(kB.center)kB.name=kB.name[1]kB.noAtmosphericDensityAltitude=vt[kB.id]or kB.atmosphereThickness;kB.spaceEngineMinAltitude=vs[kB.id]or 0.5353125*kB.atmosphereThickness;kB.planetarySystemId=vu;kB.bodyId=kB.id;vq[vu][vw]=kB;if mn==nil or kB.center.x<mn then mn=kB.center.x end;if mm==nil or kB.center.x>mm then mm=kB.center.x end;if mq==nil or kB.center.y<mq then mq=kB.center.y end;if mp==nil or kB.center.y>mp then mp=kB.center.y end;if kB.center and kB.name~="Space"then d4[#d4+1]=kB end end end;ee=dj(d,b,c,a,dk,dl,dm,dn,dp)co=ee(vq)fY=co[0]cp=eY(d,b,c,a,dn,eZ)cq=fr(d,b,c,a,dk,dl,dm,dn,dp)cs=fR(d,b,c,a,dbHud_1,e,fS,fT,bN,dm,dn,fU,fV)kB=co[0]:closestBody(bP.getWorldPosition())end;vx=false;vy=coroutine.create(function()iG:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v5()coroutine.yield()v9()coroutine.yield()ct=pA(d,b,c,e,vBooster,hover,pB,antigrav,dbHud_1,eZ,bN,bO,iF,eU,bM,dl,iG,fS,iH,dn,fV,fU,iI,dp,iK,iL,pC,iD)vo()coroutine.yield()vp()v3()if iB then cr=iB(d,b,c,a,e,antigrav,hover,shield,warpdrive,iC,eZ,bN,dk,iD,bO,iE,iF,eU,bM,dl,iG,fT,fS,gM,iH,dn,fV,gN,fU,iI,iJ,iK,iL,iM,iN)end;if cr then cr.ButtonSetup()end;cv=u8(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u9,iF,iG,iH,ua,gM,fV,e4,dm,dl,fU,iJ,pC)if shield then cw=ik(shield,e4,bN)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if u9 then u9.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vz then nA.ExtraOnStart()end;fU("start","SU")local function vA()if bH[1]==0 then ct.cmdThrottle(bH[2])else if ch>0 then cB=bH[2]ct.cmdThrottle(1)end end end;lo=string.find(c.getName(),"Emergency")or false;if lo then if cf>-1 and cL<1 and cf-3<a0 then c.exit()else if K then vA()else if ch==0 then b1="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif K and bH[3]+3>bM()then vA()end end)coroutine.resume(vy)end;function uM.onUpdate()if vx then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iG:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and p6~=vB then a.setScreen(p6)end;vB=p6;if lo and not K and ch>0 and cf==-1 then cv.landingGear()end;if lo and cf>-1 and cL<1 and cf-3<a0 then c.exit()end;if vz then nA.ExtraOnUpdate()end else local ia=coroutine.status(vy)if ia=="suspended"then local dM,ib=coroutine.resume(vy)if ib then a.print("ERROR STARTUP: "..ib)end elseif ia=="dead"then vx=true end end end;function uM.onFlush()if vx then ct.onFlush()if vz then nA.ExtraOnFlush()end end end;function uM.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(door)do dx.toggle()end end;if switch then for dQ,dx in pairs(switch)do dx.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dQ,dx in pairs(forcefield)do dx.toggle()end end;w=d6;local vC=0;if lo then vC=bM()end;if iG:getAxisCommandType(0)==0 then bH={0,bR,vC}else bH={1,iG:getTargetSpeed(axisCommandId.longitudinal),vC}end;pC()if nX then nX.activate()end;if z then ct.showWayPoint(kB,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vz then nA.ExtraOnStop()end;fU("stop","SU")end;function uM.controlStart(ui)if vx then cv.startControl(ui)end end;function uM.controlStop(ui)if vx then cv.stopControl(ui)end end;function uM.controlLoop(ui)if vx then cv.loopControl(ui)end end;function uM.controlInput(r6)if vx then cv.inputTextControl(r6)end end;function uM.radarEnter(dV)if cu then cu.onEnter(dV)end end;function uM.radarLeave(dV)if cu then cu.onLeave(dV)end end;function uM.onTick(vD)if vD=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vD=="oneSecond"then if cr then cr.OneSecondTick()end elseif vD=="fiveSecond"then ct.SatNavTick()elseif vD=="msgTick"then if cr then cr.MsgTick()end elseif vD=="animateTick"then if cr then cr.AnimateTick()end elseif vD=="hudTick"then if cr then cr.hudtick()end elseif vD=="apTick"then if ct then ct.APTick()end elseif vD=="shieldTick"then cw.shieldTick()elseif vD=="tagTick"then cv.tagTick()elseif vD=="contact"then cu.ContactTick()end end;if vz then for dL,dx in pairs(vz)do uM[dL]=dx end end;return uM end;function script.onStart()nA.onStart()end;function script.onOnStop()nA.onStop()end;function script.onTick(vD)nA.onTick(vD)end;function script.onOnFlush()nA.onFlush()end;function script.onOnUpdate()nA.onUpdate()end;function script.onActionStart(ui)nA.controlStart(ui)end;function script.onActionStop(ui)nA.controlStop(ui)end;function script.onActionLoop(ui)nA.controlLoop(ui)end;function script.onInputText(r6)nA.controlInput(r6)end;function script.onEnter(dV)nA.radarEnter(dV)end;function script.onLeave(dV)nA.radarLeave(dV)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)nA=uJ(d,core,unit,e,vBooster,hover,pB,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iC,u9)script.onStart()
        MaintainOrbit = true --export: (Default: true) If true, ship will attempt to maintain orbit if it decays (when not autopiloting to a landing point) till fuel runs out.
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        ExtraEscapeThrust = 1.0 --export: (Default: 1.0) Set this to 1 to use friction burn speed as your max speed when escaping atmosphere. Setting other than 1 will be a the value multiplied by your friction burn speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
