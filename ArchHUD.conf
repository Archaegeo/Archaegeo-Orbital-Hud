name: ArchHud - Archaegeo v0.019 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
  transponder:
    class: TransponderUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.019;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=5000;T=1.3;U=2000;V=1175;W=66000;X=1000;Y=50;Z=0;_=100000;a0=-1.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=1;ab={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},AutopilotSpaceDistance={set=function(M)S=M end,get=function()return S end},TargetOrbitRadius={set=function(M)T=M end,get=function()return T end},LowOrbitHeight={set=function(M)U=M end,get=function()return U end},AtmoSpeedLimit={set=function(M)V=M end,get=function()return V end},SpaceSpeedLimit={set=function(M)W=M end,get=function()return W end},AutoTakeoffAltitude={set=function(M)X=M end,get=function()return X end},TargetHoverHeight={set=function(M)Y=M end,get=function()return Y end},LandingGearGroundHeight={set=function(M)Z=M end,get=function()return Z end},ReEntryHeight={set=function(M)_=M end,get=function()return _ end},MaxGameVelocity={set=function(M)a0=M end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(M)a1=M end,get=function()return a1 end},warmup={set=function(M)a2=M end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingSpace={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingRocket={set=function(M)a5=M end,get=function()return a5 end},ContainerOptimization={set=function(M)a6=M end,get=function()return a6 end},FuelTankOptimization={set=function(M)a7=M end,get=function()return a7 end},AutoShieldPercent={set=function(M)a8=M end,get=function()return a8 end},EmergencyWarp={set=function(M)a9=M end,get=function()return a9 end},DockingMode={set=function(M)aa=M end,get=function()return aa end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=1.0;aV="none"aW="none"aX="none"aY=0.05;aZ=0.0;a_={speedChangeLarge={set=function(M)aE=M end,get=function()return aE end},speedChangeSmall={set=function(M)aF=M end,get=function()return aF end},MouseXSensitivity={set=function(M)aG=M end,get=function()return aG end},MouseYSensitivity={set=function(M)aH=M end,get=function()return aH end},autoRollFactor={set=function(M)aI=M end,get=function()return aI end},rollSpeedFactor={set=function(M)aJ=M end,get=function()return aJ end},autoRollRollThreshold={set=function(M)aK=M end,get=function()return aK end},minRollVelocity={set=function(M)aL=M end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(M)aM=M end,get=function()return aM end},torqueFactor={set=function(M)aN=M end,get=function()return aN end},pitchSpeedFactor={set=function(M)aO=M end,get=function()return aO end},yawSpeedFactor={set=function(M)aP=M end,get=function()return aP end},brakeSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeFlatFactor={set=function(M)aR=M end,get=function()return aR end},DampingMultiplier={set=function(M)aS=M end,get=function()return aS end},hudTickRate={set=function(M)aT=M end,get=function()return aT end},ExtraEscapeThrust={set=function(M)aU=M end,get=function()return aU end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end},allowedHorizontalDrift={set=function(M)aY=M end,get=function()return aY end},FastOrbit={set=function(M)aZ=M end,get=function()return aZ end}}b0=k;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=false;bc=1000;bd=false;be=false;bf=false;bg=false;bh=0;bi="Aligning"bj=0;bk=1;bl="None"bm=nil;bn=0;bo=nil;bp=0.0;bq=0;br={}bs=false;bt=0;bu=0;bv=nil;bw=0;bx=1000;by=0;bz=false;bA=0;bB=false;bC="All"bD=true;bE="Off"bF=0.000;bG={}bH={}bI={}bJ={VertTakeOff={set=function(M)bb=M end,get=function()return bb end},VertTakeOffEngine={set=function(M)b1=M end,get=function()return b1 end},SpaceTarget={set=function(M)bz=M end,get=function()return bz end},BrakeToggleStatus={set=function(M)b0=M end,get=function()return b0 end},BrakeIsOn={set=function(M)b2=M end,get=function()return b2 end},RetrogradeIsOn={set=function(M)b3=M end,get=function()return b3 end},ProgradeIsOn={set=function(M)b4=M end,get=function()return b4 end},Autopilot={set=function(M)b5=M end,get=function()return b5 end},TurnBurn={set=function(M)b6=M end,get=function()return b6 end},AltitudeHold={set=function(M)b7=M end,get=function()return b7 end},BrakeLanding={set=function(M)b8=M end,get=function()return b8 end},Reentry={set=function(M)ba=M end,get=function()return ba end},AutoTakeoff={set=function(M)b9=M end,get=function()return b9 end},HoldAltitude={set=function(M)bc=M end,get=function()return bc end},AutopilotAccelerating={set=function(M)bd=M end,get=function()return bd end},AutopilotBraking={set=function(M)bf=M end,get=function()return bf end},AutopilotCruising={set=function(M)bg=M end,get=function()return bg end},AutopilotRealigned={set=function(M)be=M end,get=function()return be end},AutopilotEndSpeed={set=function(M)bh=M end,get=function()return bh end},AutopilotStatus={set=function(M)bi=M end,get=function()return bi end},AutopilotPlanetGravity={set=function(M)bj=M end,get=function()return bj end},PrevViewLock={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetName={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetCoords={set=function(M)bm=M end,get=function()return bm end},AutopilotTargetIndex={set=function(M)bn=M end,get=function()return bn end},TotalDistanceTravelled={set=function(M)bp=M end,get=function()return bp end},TotalFlightTime={set=function(M)bq=M end,get=function()return bq end},SavedLocations={set=function(M)br=M end,get=function()return br end},VectorToTarget={set=function(M)bs=M end,get=function()return bs end},LocationIndex={set=function(M)bt=M end,get=function()return bt end},LastMaxBrake={set=function(M)bu=M end,get=function()return bu end},LockPitch={set=function(M)bv=M end,get=function()return bv end},LastMaxBrakeInAtmo={set=function(M)bw=M end,get=function()return bw end},AntigravTargetAltitude={set=function(M)bx=M end,get=function()return bx end},LastStartTime={set=function(M)by=M end,get=function()return by end},iphCondition={set=function(M)bC=M end,get=function()return bC end},stablized={set=function(M)bD=M end,get=function()return bD end},UseExtra={set=function(M)bE=M end,get=function()return bE end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bG=M end,get=function()return bG end},apRoute={set=function(M)bH=M end,get=function()return bH end},ecuThrottle={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=q;cA=false;cB=V;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2={}d3={}d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()dg=nil;dh=nil;di=nil;dj=false;if shield then dk=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dl(dm)a.print(bQ..": "..dm)end;local function dn(d,b,c,a,dp,dq,dr,ds,dt)local function du(dv)return type(dv)=='number'end;local function dw(dv)return type(dr(dv))=='number'end;local function dx(dy)return type(dy)=='table'end;local function dz(a)return type(a)=='string'end;local function dA(dB)return dx(dB)and du(dB.x and dB.y and dB.z)end;local function dC(dD)return dx(dD)and du(dD.latitude and dD.longitude and dD.altitude and dD.id and dD.systemId)end;local dE=math.pi/180;local dF=180/math.pi;local dG=1e-10;local dH=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dI='::pos{'..dH..','..dH..','..dH..','..dH..','..dH..'}'local utils=utils;local vec3=vec3;local function dJ(dv)local dK=string.gsub(string.reverse(dp('%.4f',dv)),'^0*%.?','')return dK==''and'0'or string.reverse(dK)end;local function dL(dM)if dA(dM)then return dp('{x=%.3f,y=%.3f,z=%.3f}',dM.x,dM.y,dM.z)end;if dx(dM)and not getmetatable(dM)then local dN={}local dO=next(dM)if type(dO)=='nil'or dO==1 then dN=dM else for dP,dB in pairs(dM)do local dQ=dL(dB)if type(dP)=='number'then table.insert(dN,dp('[%s]=%s',dP,dQ))else table.insert(dN,dp('%s=%s',dP,dQ))end end end;return dp('{%s}',table.concat(dN,','))end;if dz(dM)then return dp("'%s'",dM:gsub("'",[[\']]))end;return tostring(dM)end;local dR={}dR.__index=dR;dR.__tostring=function(dM,dS)local dT={}for dP in pairs(dM)do table.insert(dT,dP)end;table.sort(dT)local dN={}for dU,dP in ipairs(dT)do local dQ=dL(dM[dP])if type(dP)=='number'then table.insert(dN,dp('[%s]=%s',dP,dQ))else table.insert(dN,dp('%s=%s',dP,dQ))end end;if dS then return dp('%s%s',dS,table.concat(dN,',\n'..dS))end;return dp('{%s}',table.concat(dN,','))end;dR.__eq=function(dV,dW)return dV.systemId==dW.systemId and dV.id==dW.id and dt(dV.radius,dW.radius)and dt(dV.center.x,dW.center.x)and dt(dV.center.y,dW.center.y)and dt(dV.center.z,dW.center.z)and dt(dV.GM,dW.GM)end;local function dX(dY,dZ,d_,e0,e1)assert(dw(dY),'Argument 1 (systemId) must be a number:'..type(dY))assert(dw(dZ),'Argument 2 (id) must be a number:'..type(dZ))assert(dw(d_),'Argument 3 (radius) must be a number:'..type(d_))assert(dx(e0),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e0))assert(dw(e1),'Argument 5 (GM) must be a number:'..type(e1))return setmetatable({systemId=dr(dY),id=dr(dZ),radius=dr(d_),center=vec3(e0),GM=dr(e1)},dR)end;local e2={}e2.__index=e2;e2.__tostring=function(dl)return dp('::pos{%d,%d,%s,%s,%s}',dl.systemId,dl.id,dJ(dl.latitude*dF),dJ(dl.longitude*dF),dJ(dl.altitude))end;e2.__eq=function(dV,dW)return dV.id==dW.id and dV.systemId==dW.systemId and dt(dV.latitude,dW.latitude)and dt(dV.altitude,dW.altitude)and(dt(dV.longitude,dW.longitude)or dt(dV.latitude,math.pi/2)or dt(dV.latitude,-math.pi/2))end;local function e3(e4,dZ,e5,e6,e7)local dY=e4;if dz(e4)and not e6 and not e7 and not dZ and not e5 then dY,dZ,e5,e6,e7=e8(e4,dI)assert(dY,'Argument 1 (position string) is malformed.')else assert(dw(dY),'Argument 1 (systemId) must be a number:'..type(dY))assert(dw(dZ),'Argument 2 (id) must be a number:'..type(dZ))assert(dw(e5),'Argument 3 (latitude) must be in degrees:'..type(e5))assert(dw(e6),'Argument 4 (longitude) must be in degrees:'..type(e6))assert(dw(e7),'Argument 5 (altitude) must be in meters:'..type(e7))end;dY=dr(dY)dZ=dr(dZ)e5=dr(e5)e6=dr(e6)e7=dr(e7)if dZ==0 then return setmetatable({latitude=e5,longitude=e6,altitude=e7,id=dZ,systemId=dY},e2)end;return setmetatable({latitude=dE*dq(e5,-90,90),longitude=dE*(e6%360),altitude=e7,id=dZ,systemId=dY},e2)end;local e9={}e9.__index=e9;e9.__tostring=function(dM,dS)local ea=dS and dS..'  'local eb={}local dT={}for dP in pairs(dM)do table.insert(dT,dP)end;table.sort(dT)for dU,ec in ipairs(dT)do ed=dM[ec]local ee=dR.__tostring(ed,ea)if dS then table.insert(eb,dp('[%s]={\n%s\n%s}',ec,ee,dS))else table.insert(eb,dp('  [%s]=%s',ec,ee))end end;if dS then return dp('\n%s%s%s',dS,table.concat(eb,',\n'..dS),dS)end;return dp('{\n%s\n}',table.concat(eb,',\n'))end;local function ef(eg)local e={}local pid;for dU,dB in pairs(eg)do local dZ=dB.planetarySystemId;if type(dZ)~='number'then error('Invalid planetary s ID: '..tostring(dZ))elseif pid and dZ~=pid then error('Mistringmatch planetary s IDs: '..dZ..' and '..pid)end;local eh=dB.bodyId;if type(eh)~='number'then error('Invalid body ID: '..tostring(eh))elseif e[eh]then error('Duplicate body ID: '..tostring(eh))end;setmetatable(dB.center,getmetatable(vec3.unit_x))e[eh]=setmetatable(dB,dR)pid=dZ end;return setmetatable(e,e9)end;ei={}local function ej(eg)return setmetatable({galaxyAtlas=eg or{}},ei)end;ei.__index=function(dy,M)if type(M)=='number'then local a=dy.galaxyAtlas[M]return ef(a)end;return rawget(ei,M)end;ei.__pairs=function(dM)return function(dy,dP)local ek,el=next(dy,dP)return ek,el and ef(el)end,dM.galaxyAtlas,nil end;ei.__tostring=function(dM)local em={}for dU,en in pairs(dM or{})do local eo=en:getPlanetarySystemId()local ep=e9.__tostring(en,'    ')table.insert(em,dp('  [%s]={%s\n  }',eo,ep))end;return dp('{\n%s\n}\n',table.concat(em,',\n'))end;ei.BodyParameters=dX;ei.MapPosition=e3;ei.PlanetarySystem=ef;function ei.createBodyParameters(dY,dZ,eq,er,es,et,eu)assert(dw(dY),'Argument 1 (systemId) must be a number:'..type(dY))assert(dw(dZ),'Argument 2 (id) must be a number:'..type(dZ))assert(dw(eq),'Argument 3 (surfaceArea) must be a number:'..type(eq))assert(dx(er),'Argument 4 (aPosition) must be an array or vec3:'..type(er))assert(dx(es),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(es))assert(dw(et),'Argument 6 (altitude) must be in meters:'..type(et))assert(dw(eu),'Argument 7 (gravityAtPosition) must be number:'..type(eu))local d_=ds(eq/4/math.pi)local cb=d_+et;local ev=vec3(er)+cb*vec3(es)local e1=eu*cb*cb;return dX(dY,dZ,d_,ev,e1)end;ei.isMapPosition=dC;function ei:getPlanetarySystem(e4)if M==nil then M=0 end;if el==nil then el=0 end;local dY=e4;if dC(e4)then dY=e4.systemId end;if type(dY)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(el)~=e9 then a=ef(a)end;return a end end end;function e9:sizeCalculator(ew)return 1.05*ew.radius end;function e9:castIntersections(ex,ey,ez,eA,eB,eC)local eD={}if eB then for dU,ew in pairs(eB)do table.insert(eD,ew)end else eD=d4 end;if not eC then table.sort(eD,function(eE,eF)local eG=eE.center;local eH=eF.center;return(eG.x-ex.x)^2+(eG.y-ex.y)^2+(eG.z-ex.z)^2<(eH.x-ex.x)^2+(eH.y-ex.y)^2+(eH.z-ex.z)^2 end)end;local eI=ey:normalize()for dU,ew in ipairs(eD)do local eJ=ew.center-ex;local d_;if ez then d_=ez(ew)else d_=self:sizeCalculator(ew)end;local eK=eJ:dot(eI)local eL=eK^2-(eJ:len2()-d_^2)if eL>=0 then local eM=ds(eL)local eN=eK+eM;local eO=eK-eM;if eO>0 then return ew,eN,eO elseif eN>0 then return ew,eN,nil end end end;return nil,nil,nil end;function e9:closestBody(eP)assert(type(eP)=='table','Invalid coordinates.')local eQ,ew;local eR=vec3(eP)for dU,eS in pairs(self)do local eT=(eS.center-eR):len2()if(not ew or eT<eQ)and eS.name~="Space"then ew=eS;eQ=eT end end;return ew end;function e9:convertToBodyIdAndWorldCoordinates(e4)local eU=e4;if dz(e4)then eU=e3(e4)end;if eU.id==0 then return 0,vec3(eU.latitude,eU.longitude,eU.altitude)end;local eS=self:getBodyParameters(eU)if eS then return eU.id,eS:convertToWorldCoordinates(eU)end end;function e9:getBodyParameters(e4)local dZ=e4;if dC(e4)then dZ=e4.id end;assert(dw(dZ),'Argument 1 (id) must be a number:'..type(dZ))return self[dZ]end;function e9:getPlanetarySystemId()local dU,dB=next(self)return dB and dB.systemId end;function dR:convertToMapPosition(e0)assert(dx(e0),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e0))local eV=vec3(e0)if self.id==0 then return setmetatable({latitude=eV.x,longitude=eV.y,altitude=eV.z,id=0,systemId=self.systemId},e2)end;local eW=eV-self.center;local cb=eW:len()local e7=cb-self.radius;local e5=0;local e6=0;if not dt(cb,0)then local eX=eY(eW.y,eW.x)e6=eX>=0 and eX or 2*math.pi+eX;e5=math.pi/2-math.acos(eW.z/cb)end;return setmetatable({latitude=e5,longitude=e6,altitude=e7,id=self.id,systemId=self.systemId},e2)end;function dR:convertToWorldCoordinates(e4)local eU=dz(e4)and e3(e4)or e4;if eU.id==0 then return vec3(eU.latitude,eU.longitude,eU.altitude)end;assert(dC(eU),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eU.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eU.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eZ=math.cos(eU.latitude)return self.center+(self.radius+eU.altitude)*vec3(eZ*math.cos(eU.longitude),eZ*math.sin(eU.longitude),math.sin(eU.latitude))end;function dR:getAltitude(e0)return(vec3(e0)-self.center):len()-self.radius end;function dR:getDistance(e0)return(vec3(e0)-self.center):len()end;function dR:getGravity(e0)local e_=self.center-vec3(e0)local f0=e_:len2()return self.GM/f0*e_/ds(f0)end;return setmetatable(ei,{__call=function(dU,...)return ej(...)end})end;local function f1(d,b,c,a,ds,f2)local cp={}local f3=100;function cp.computeAccelerationTime(f4,f5,f6)return(f6-f4)/f5 end;function cp.computeDistanceAndTime(f4,f6,f7,f8,f9,fa)f9=f9 or 0;fa=fa or 0;local fb=f4<f6;local fc=f8/(fb and f7 or-f7)local fd=-fa/f7;local fe=fc+fd;if f4==f6 then return 0,0 elseif fb and fe<=0 or not fb and fe>=0 then return-1,-1 end;local ff,fg=0,0;if fc~=0 and f9>0 then local fh=math.pi/f9/2;local dB=function(dy)return fc*(dy/2-f9*math.sin(fh*dy)/math.pi)+fd*dy+f4 end;local fi=fb and function(a)return a>=f6 end or function(a)return a<=f6 end;fg=2*f9;if fi(dB(fg))then local fj=0;while math.abs(fg-fj)>0.25 do local dy=(fg+fj)/2;if fi(dB(dy))then fg=dy else fj=dy end end end;local fk=2*fc*f9^2/math.pi^2;ff=fk*(math.cos(fh*fg)-1)+(fc+2*fd)*fg^2/4+f4*fg;if fg<2*f9 then return ff,fg end;f4=dB(fg)end;local eG=fc+fd;local dy=cp.computeAccelerationTime(f4,eG,f6)local fl=f4*dy+eG*dy*dy/2;return ff+fl,fg+dy end;function cp.computeTravelTime(f4,f5,cb)if cb==0 then return 0 end;if f5~=0 then return(math.sqrt(2*f5*cb+f4^2)-f4)/f5 end;assert(f4>0,'Acceleration and initial speed are both zero.')return cb/f4 end;return cp end;local function fm(d,b,c,a,dp,dq,dr,ds,dt)local vec3=vec3;local dn=dn(d,b,c,a,dp,dq,dr,ds,dt)local function dz(a)return type(a)=='string'end;local function dx(dy)return type(dy)=='table'end;fn={}fn.__index=fn;function fn:escapeAndOrbitalSpeed(e7)assert(self.body)local cb=e7+self.body.radius;if not dt(cb,0)then local fo=ds(self.body.GM/cb)return ds(2)*fo,fo end;return nil,nil end;function fn:orbitalParameters(e4,fp)assert(self.body)assert(dx(e4)or dz(e4))assert(dx(fp))local fq=(dz(e4)or dn.isMapPosition(e4))and self.body:convertToWorldCoordinates(e4)or vec3(e4)local dB=vec3(fp)local fr=fq-self.body.center;local fs=dB:len2()local fl=fr:len()local ft=self.body.GM;local fu=((fs-ft/fl)*fr-fr:dot(dB)*dB)/ft;local eG=ft/(2*ft/fl-fs)local fv=fu:len()local eI=fu:normalize()local fw=eG*(1-fv)local fx=eG*(1+fv)local fy=fw*eI+self.body.center;local fz=fv<=1 and-fx*eI+self.body.center or nil;local fA=ds(eG*ft*(1-fv*fv))local fB=fz and 2*math.pi*ds(eG^3/ft)local fC=math.acos(fu:dot(fr)/(fv*fl))if fr:dot(dB)<0 then fC=-(fC-2*math.pi)end;local fD=math.acos((math.cos(fC)+fv)/(1+fv*math.cos(fC)))local fE=fD;if fE<0 then fE=fE+2*math.pi end;local fF=fE-fv*math.sin(fE)local fG=0;local fH=0;local fI=0;if fB~=nil then fG=fF/(2*math.pi/fB)fH=fB-fG;fI=fH+fB/2;if fC-math.pi>0 then fH=fG;fI=fH+fB/2 end;if fI>fB then fI=fI-fB end end;return{periapsis={position=fy,speed=fA/fw,circularOrbitSpeed=ds(ft/fw),altitude=fw-self.body.radius},apoapsis=fz and{position=fz,speed=fA/fx,circularOrbitSpeed=ds(ft/fx),altitude=fx-self.body.radius},currentVelocity=dB,currentPosition=fq,eccentricity=fv,period=fB,eccentricAnomaly=fD,meanAnomaly=fF,timeToPeriapsis=fH,timeToApoapsis=fI,trueAnomaly=fC}end;local function fJ(fK)local eS=dn.BodyParameters(fK.systemId,fK.id,fK.radius,fK.center,fK.GM)return setmetatable({body=eS},fn)end;return setmetatable(fn,{__call=function(dU,...)return fJ(...)end})end;local function fL(d,b,c,a,dbHud_1,e,fM,fN,bN,dr,ds,fO,fP,dm)local function fQ(fR)local dl=fS:closestBody(fR)if(fR-dl.center):len()>dl.radius+dl.noAtmosphericDensityAltitude then dl=e[0][0]end;return dl end;local function fT()local function fU(fV,fW)return fV.name<fW.name end;cU={}for dP,dB in pairs(e[0])do cU[#cU+1]={name=dB.name,index=dP}end;table.sort(cU,fU)end;local function fX(fY,fZ)if not fZ then fZ=f_.name end;for dP,dB in pairs(fY)do if dB.name and dB.name==fZ then return dP end end;return-1 end;local function g0()d1=bn;if bn==0 then bl="None"c8=nil;f_=nil;return true end;local g1=cU[bn].index;local g2=e[0][g1]if g2.center then bl=g2.name;c8=co[0][g1]if f_~=nil then if ch==0 then if fM(g3,g4)~=1 then fN(g3,g4)end;if fM(g5,g6)~=1 then fN(g5,g6)end;if fM(g7,g8)~=1 then fN(g7,g8)end;if fM(g9,ga)~=1 then fN(g9,ga)end;if fM(gb,gc)~=1 then fN(gb,gc)end end;if fM(gd,ge)~=1 then fN(gd,ge)end;if fM(gf,gg)~=1 then fN(gf,gg)end;if fM(gh,gi)~=1 then fN(gh,gi)end end;f_=nil else f_=g2;for dU,dB in pairs(co[0])do if dB.name==f_.planetname then c8=dB;bl=f_.name;break end end;if fM(gd,ge)~=1 then fN(gd,ge)end;if fM(gf,gg)~=1 then fN(gf,gg)end end;if f_==nil then bm=vec3(c8.center)else bm=f_.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gj=bN(c8.radius*(T-1)+c8.noAtmosphericDensityAltitude)else gj=bN(U+c8.surfaceMaxAltitude)end else gj=S end;if f_~=nil and f_.planetname=="Space"then bh=0 else dU,bh=cq(c8):escapeAndOrbitalSpeed(gj)end;bj=0;bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"return true end;local function gk(gl)if not dj and not b5 and not bs and not cd and not bB and not ba and not ce then if gl==nil then bn=bn+1;if bn>#cU then bn=0 end else bn=bn-1;if bn<0 then bn=#cU end end;if bn==0 then g0()else local g1=cU[bn].index;local g2=e[0][g1]if g2 and(g2~=nil and g2.name=="Space"or bC=="Custom Only"and g2.center or bC=="No Moons-Asteroids"and(string.find(g2.name,"Moon")~=nil or string.find(g2.name,"Asteroid")~=nil))then if gl==nil then gk()else gk(1)end else g0()end end else dm("Disengage autopilot before changing Interplanetary Helper")fO("iph","AP")end end;local function gm()local function gn(go)local gp;if go then gp=d9 else gp=br end;local gq=-1;gq=fX(e[0])if gq>-1 then table.remove(e[0],gq)end;gq=-1;gq=fX(gp)if gq~=-1 then dm(f_.name.." saved location cleared")table.remove(gp,gq)end;gk()fT()return gp end;if string.sub(bl,1,1)=="*"then d9=gn(true)else br=gn(false)end end;local function gr(gs,fR,gt,gu)local function gv(go)if go then gp=d9 else gp=br end;if dbHud_1 or gt or go then local dl=fQ(fR)local gw={position=fR,name=gs,planetname=dl.name,gravity=b.getGravityIntensity(),safe=gu}if not gt then gp[#gp+1]=gw else for dP,dB in pairs(e[0])do if dB.name and gs==dB.name then table.remove(e[0],dP)end end end;table.insert(e[0],gw)fT()g0()dm("Location saved as "..gs.."("..dl.name..")")return gp else dm("Databank must be installed to save permanent locations")end end;if string.sub(gs,1,1)=="*"then d9=gv(true)else br=gv(false)end end;local gx={}function gx.UpdateAtlasLocationsList()fT()end;function gx.UpdateAutopilotTarget()g0()end;function gx.adjustAutopilotTargetIndex(gl)gk(gl)end;function gx.findAtlasIndex(fY,fZ)return fX(fY,fZ)end;function gx.UpdatePosition(gy,gz,gA)local function gB(go)local gp;if go then gp=d9 else gp=br end;local gq=fX(gp)if gq~=-1 then if gy~=nil then if go then gy="*"..gy end;gp[gq].name=gy;bn=bn-1;gk()elseif gA~=nil then if gA then local gC=ci;if gC<1000 then gC=1000 end;gp[gq].agg=fP(gC,0)dm(gp[gq].name.." AGG Altitude:"..gp[gq].agg.." saved ("..gp[gq].planetname..")")return elseif gA==false then gp[gq].agg=nil;dm(gp[gq].name.." AGG Altitude cleared ("..gp[gq].planetname..")")return end else local gD=gp[gq]if gz then gD.heading=cI:cross(cM)*5000;dm(gp[gq].name.." heading saved ("..gp[gq].planetname..")")return elseif gz==false then gD.heading=nil;dm(gp[gq].name.." heading cleared ("..gp[gq].planetname..")")return end;gD.gravity=b.getGravityIntensity()gD.position=cO;gD.safe=true end;dm(gp[gq].name.." position updated ("..gp[gq].planetname..")")else dm("Name Not Found")end end;if string.sub(bl,1,1)=="*"then gB(true)else gB(false)end end;function gx.AddNewLocation(gs,fR,gt,gu)gr(gs,fR,gt,gu)end;function gx.ClearCurrentPosition()gm()end;for dP,dB in pairs(da)do table.insert(e[0],dB)end;if gE then for dP,dB in pairs(gE)do gx[dP]=dB end end;fT()if bn>#cU then bn=0 end;gx.UpdateAutopilotTarget()return gx end;local function gF(b,a,c,radar_1,radar_2,warpdrive,f2,gG,ds,gH,dr,gI,fO,dm)local gJ={}local gK={}local gL={XS=13,S=27,M=55,L=110,XL=221}local gM={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gN={}local gO=0;local gP;local gQ;local gR=0;local gS;local gT={gS}local gU="Atmo"local gV;local gW;local gX=0;local gY={}local gZ;local g_=0;local h0=table.insert;local h1=-4;local h2={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h3,h4;local h5,h6;local h7;local h8;local h9;local ha;local hb;local hc;local hd;local function he()if hf~=nil and gX==0 then gG(hf)a.destroyWidget(h3)a.destroyData(h5)h3,h5,hf=nil,nil,nil;if gW~=nil then gG(gW)a.destroyWidget(h4)a.destroyData(h6)gW,h4,h6=nil,nil,nil end else if gX==1 then gW=a.createWidgetPanel("PeriWinkle")h4=a.createWidget(gW,'periscope')h6=gS.getWidgetDataId()a.addDataToWidget(h6,h4)end;if hf==nil and gO>0 then hf=a.createWidgetPanel(gU)h3=a.createWidget(hf,'radar')h5=gS.getWidgetDataId()a.addDataToWidget(h5,h3)end;gX=0 end end;local function hg()local function hh(hi,hj,hk,hl,hm,hn,ho,hp)hj,hl,hn,hp=vec3(hj),vec3(hl),vec3(hn),vec3(hp)local hq,hr,hs=hi*hi,hk*hk,hm*hm;local fs=hl-hj;local ht=fs:normalize()local hu=fs:len()local hv=hn-hj;local hw=(hv-hv:project_on(ht)):normalize()local hx,hy=hv:dot(ht),hv:dot(hw)local hz=hx*hx+hy*hy;local hA=ht:cross(hw)local hB=(hq-hr+hu*hu)/(2*hu)local hC=(hq-hs+hz-2*hx*hB)/(2*hy)local dD=hq-hB^2-hC^2;local hD=ds(dD)local hE=hj+ht*hB+hw*hC+hA*hD;local hF=hj+ht*hB+hw*hC-hA*hD;if f2((hp-hE):len()-ho)<f2((hp-hF):len()-ho)then return hE else return hF end end;local function hG(hH,fl,hI)local hJ=hH.pts;local gq=#hJ;local hK=hH.ref;if gq>3 then local hL,hM,hN,hO=hJ[gq],hJ[gq-1],hJ[gq-2],hJ[gq-3]hH.ref=hI;local fq=hh(hL[1],hL[2],hM[1],hM[2],hN[1],hN[2],hO[1],hO[2])local hB,hC,hD=fq.x,fq.y,fq.z;if hB==hB and hC==hC and hD==hD then hB=hB+hK[1]hC=hC+hK[2]hD=hD+hK[3]local hP=vec3(hB,hC,hD)hH.center=hP;if hH.lastPos then if(hH.lastPos-hP):len()<2 then local hQ=(hP-vec3(hI)):len()if f2(hQ-fl)<10 then hH.skipCalc=true end end end;hH.lastPos=hP end;hH.pts={}else local hR={hI[1]-hK[1],hI[2]-hK[2],hI[3]-hK[3]}hJ[gq+1]={fl,hR}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gS then if#gZ>0 then local hS,hT=0,0;local hU=cL*10;local cY=cY;gR,gQ=0,0;gK={}for dU,dB in pairs(gZ)do local cb=hb(dB)if cb>0.0 then if h7(dB)==1 then h0(gK,dB)end;if not cV and warpdrive and cb<a9 and warpdrive.getStatus()==15 then dm("INITIATING WARP")c4=7;warpdrive.initiate()end;local hV=F and h9(dB)==1;if E or hV then local hW=hc(dB)local hX=gL[hW]local hY=h8(dB)if hV or cb<hU and(hX>27 or hY==4 or hY==6)then gR=gR+1;local hI={cO["x"],cO["y"],cO["z"]}local hH=gY[dB]if hH==nil then hX=hX+gI;gY[dB]={pts={},ref=hI,name=ha(dB),i=0,radius=hX,skipCalc=false}hH=gY[dB]end;if not hH.skipCalc then if hV or hY==4 or hY==6 then hH.center=vec3(hd(dB))hH.skipCalc=true else hG(hH,cb,hI)hT=hT+1 end;if hV and not hH.abandoned then local bQ=a.getArkTime()if g_+5<bQ then g_=bQ;fO("abRdr","RD")end;a.print("Abandoned Construct: "..hH.name.." ("..hW.." "..gM[hY]..") at ::pos{0,0,"..hH.center.x..","..hH.center.y..","..hH.center.z.."}")dm("Abandoned Radar Contact ("..hW.." "..gM[hY]..") detected")hH.abandoned=true end else h0(gN,hH)end end;hS=hS+1;if hS>300 or hT>30 then coroutine.yield()hS,hT=0,0 end end end end;gQ=#gN;if gQ>0 and(cL>20 or b8)then local ew,hZ,h_,i0;local i1=0;local i2=co:getPlanetarySystem(0)i0=cK:normalize()while i1<gQ do coroutine.yield()local i3={table.unpack(gN,i1,math.min(i1+75,gQ))}ew,hZ,h_=i2:castIntersections(cO,i0,nil,nil,i3,true)if ew and h_ then c_={ew,hZ,h_}break end;i1=i1+75 end;if not ew then c_=nil end else c_=nil end;gN={}gP=gS.getTargetId()end end end;local function i4()if gS then gU="Atmo"if string.find(gS.getName(),"Space")then gU="Space"end end end;function gJ.pickType()i4()end;function gJ.assignRadar()if radar_2 and h1~=1 then if h1==-1 then if gS==radar_2 then gS=radar_1 else gS=radar_2 end end;gT={gS}h7=gS.hasMatchingTransponder;h8=gS.getConstructKind;h9=gS.isConstructAbandoned;ha=gS.getConstructName;hb=gS.getConstructDistance;hc=gS.getConstructCoreSize;hd=gS.getConstructWorldPos;gZ=gS.getConstructIds()i4()else gZ=gS.getConstructIds()end;h1=gS.getOperationalState()end;function gJ.UpdateRadar()local i5=coroutine.status(gV)if i5=="suspended"then local dQ,i6=coroutine.resume(gV)if i6 then a.print("ERROR UPDATE RADAR: "..i6)end elseif i5=="dead"then gV=coroutine.create(hg)local dQ,i6=coroutine.resume(gV)end end;function gJ.GetRadarHud(i7,i8,ax,ay)local i9,dm;local dH=gQ or 0;gO=#gZ;if gO>0 then if E then dm=dH.."/"..gR.." Known/InRange : "..gO.." Total"else dm="Radar Contacts: "..gO end;i9=gH(ax,ay,dm,"pbright txtbig txtmid")if#gK>0 then i9=i9 ..gH(i7,i8,"Friendlies In Range","pbright txtbig txtmid")for dP,dB in pairs(gK)do i8=i8+20;i9=i9 ..gH(i7,i8,gS.getConstructName(dB),"pdim txtmid")end end;local ia=#gS.getIdentifiedConstructIds()if gW==nil and ia>0 then gX=1;cu.ToggleRadarPanel()end;if gW~=nil and ia==0 then cu.ToggleRadarPanel()end;if hf==nil then if w then cu.ToggleRadarPanel()end end else if h1~=1 then i9=gH(ax,ay,gU.." Radar: "..h2[h1],"pbright txtbig txtmid")else i9=gH(ax,ay,"Radar: No "..gU.." Contacts","pbright txtbig txtmid")end;if hf~=nil then gX=0;cu.ToggleRadarPanel()end end;return i9 end;function gJ.GetClosestName(gs)if gS then local ib=gS.getConstructName(gS.getConstructIds()[1])if ib then gs=gs.." "..ib end end;return gs end;function gJ.ToggleRadarPanel()he()end;function gJ.ContactTick()if not ic then ic=0 end;if bQ>ic+10 then dm("Radar Contact")fO("rdrCon","RC")ic=bQ end;c.stopTimer("contact")end;function gJ.onEnter(dZ)if gS and not cg and not cV then c.setTimer("contact",0.1)end end;function gJ.onLeave(dZ)if gS and E then if#gY>650 then dZ=tostring(dZ)gY[dZ]=nil end end end;local function id()gS=nil;if radar_2 and radar_2.getOperationalState()==1 then gS=radar_2 else gS=radar_1 end;h1=gS.getOperationalState()h7=gS.hasMatchingTransponder;h8=gS.getConstructKind;h9=gS.isConstructAbandoned;ha=gS.getConstructName;hb=gS.getConstructDistance;hc=gS.getConstructCoreSize;hd=gS.getConstructWorldPos;gT={gS}gZ=gS.getConstructIds()i4()gV=coroutine.create(hg)if ie then for dP,dB in pairs(ie)do gJ[dP]=dB end end end;id()return gJ end;local function ig(shield,e8,bN,dm)local ih={}local ii=shield.getResistancesCooldown()local function ij()local ik=shield.isActive()if G then if not cV and ik==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and ik==1 then shield.toggle()end end end;local function il()local im=shield.getStressRatioRaw()local io=0.5999;if im[1]==0.0 and im[2]==0.0 and im[3]==0.0 and im[4]==0.0 then return end;local ip=shield.setResistances(io*im[1],io*im[2],io*im[3],io*im[4])if ip==1 then dm("Shield Resistances updated")else dm("Value Exceeded. Failed to update Shield Resistances")end end;function ih.shieldTick()dk=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ij()ii=shield.getResistancesCooldown()if ii==0 and dk<a8 then il()end end;function ih.setResist(iq)if not shield then dm("No shield found")return elseif iq==nil or ii>0 then dm("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dH=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dI=dH..', '..dH..', '..dH..', '..dH;local ir,is,it,iu=e8(iq,dI)if iu==nil or ir+is+it+iu>0.6 then dm("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(ir,is,it,iu)==1 then dm("Shield Resistances set")else dm("Resistance setting failed.")end end;function ih.ventShield()local iv=shield.getVentingCooldown()if iv>0 then dm("Cannot vent again for "..iv.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()dm("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else dm("Shields already at max hitpoints")end end;if iw then for dP,dB in pairs(iw)do ih[dP]=dB end end;return ih end;local function ix(d,b,c,a,e,antigrav,hover,shield,warpdrive,iy,f2,bN,dp,iz,bO,iA,iB,eY,bM,dq,iC,fN,fM,gG,iD,ds,fP,gH,fO,iE,iF,iG,iH,iI,iJ,dm)local bP=DUConstruct;local iK=9.80665;local iL={}local iM={}local iN={}local iO={}local iP=nil;local iQ=nil;local iR=nil;local iS=false;local iT="none"local iU=""local iV=55;local iW=0;local iX=0;local iY=nil;local iZ=af;local i_=ag;local j0=ah;local j1=[[rgb(]]..bN(iZ+0.5)..","..bN(i_+0.5)..","..bN(j0+0.5)..[[)]]local j2=[[rgb(]]..bN(iZ*0.9+0.5)..","..bN(i_*0.9+0.5)..","..bN(j0*0.9+0.5)..[[)]]local j3=0;local j4=0;local j5=""local j6=bM()local j7=false;local j8=false;local gS=false;local function j9(dB)if ac==1920 then return dB else return fP(ac*dB/1920,0)end end;local function ja(dB)if ad==1080 then return dB else return fP(ad*dB/1080,0)end end;local function jb()return iD()==0 and g~="keyboard"and iB()==0 end;local function jc()local jd="TRAVEL"if not cR then jd="CRUISE"end;if b5 then jd="AUTOPILOT"end;return jd end;local i9=""local je=""local jf=""local jg=1;local jh=2;local ji=3;local jj=4;local jk=5;local jl=6;local jm=7;local jn=""local jo=0;local jp=90.0*aT;local jq={}local jr={}local js={}local jt={}local ju={}local jv={}local jw={}jw["atmofueltank"],jw["spacefueltank"],jw["rocketfueltank"]=0,0,0;local jx=0;local function jy(hB,jz,jA,jB,jC,jD)local jE=jx;local jF=jx+5;if not B then jF=jF+5 end;if iB()==1 and not m then jE=jE-50;jF=jF-50 end;if jA=="ATMO"then jn="atmofueltank"elseif jA=="SPACE"then jn="spacefueltank"else jn="rocketfueltank"end;jo=_G[jn.."_size"]if#jB>0 then for M=1,#jB do local gs=jB[M][jh]local jG=jB[M][jm]for jH=1,jo do if jB[M][jh]==iz(c[jn.."_"..jH].getWidgetData()).name then jG=jH;break end end;local jI=bM()if jC[M]==nil or jD[M]==nil or jI-jB[M][jl]>jp then local jJ;local jK=0;jK=iA(jB[M][jg])-jB[M][jj]jJ=jB[M][jk]local jL=jJ>jK or false;if jL then jw[jn]=jw[jn]+jJ-jK end;if jG~=0 then local jM=iz(c[jn.."_"..jG].getWidgetData())jD[M]=jM.percentage;jC[M]=jM.timeLeft;if jC[M]=="n/a"then jC[M]=0 end else jD[M]=bN(0.5+jK*100/jB[M][ji])if jL then jC[M]=bN(0.5+jK/((jJ-jK)/(jI-jB[M][jl])))else jC[M]=0 end end;jB[M][jl]=jI;jB[M][jk]=jK end;if gs==jz then gs=dp("%s %d",jA,M)end;if jG==0 then gs=gs.." *"end;local jN;jN=iH(jC[M])if jC[M]==0 or jN==">1y"then jN=""end;if jD[M]~=nil then local jO=bN(jD[M]*2.55)local jP=dp("rgb(%d,%d,%d)",255-jO,jO,0)local jQ=""if jN~=""and jC[M]<120 or jD[M]<5 then jQ="red "end;local jR=dp("rgb(%d,%d,%d)",dq(bN((255-jO)/2.55),50,100),dq(bN(jO/2.55),0,50),50)local jS="rgb(196,0,255)"if jA=="ATMO"then jS="rgb(0,188,255)"elseif jA=="SPACE"then jS="rgb(239,255,0)"end;local jT=false;if jU~=jS then jT=true end;jU=jS;if B then if jT then jE=jE-5;jF=jF-5 end;je=je..dp([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jR,jS,hB,jF,jP,bN(jD[M]*1.7+0.5)-2,hB+1,jF+1,hB+5,jF+14,gs,jD[M],jN)jE=jE-22;jF=jF-22 else je=je..gH(hB,jE,gs,jQ.."pdim txtfuel")je=je..gH(hB,jF,dp("%d%% %s",jD[M],jN),"pdim txtfuel","fill:"..jP)jE=jE+30;jF=jF+30 end end end end;jx=jE end;local function jV(jW,e7)if ap==0 and aq==0 then return end;if e7<200000 and not cg or e7 and cg then local jX=0;if f2(cN)>1 then jX=45*math.log(f2(cN),10)if cN<0 then jX=-jX end end;jW[#jW+1]=dp([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bN(cN),bN(jX))end;return jW end;local function jY(jZ)local gl=-cM;jZ=jZ-jZ:project_on(gl)local j_=vec3(0,0,1)j_=j_-j_:project_on(gl)local k0=j_:cross(gl)local jX=j_:angle_between(jZ)*constants.rad2deg;if jZ:dot(k0)<0 then jX=360-jX end;return jX end;local function k1(jW,al,am,k2,k3,cY)if ae==0 then return end;local k4=ae;local k5=20;local k6=bN(k2)if cY then for M=-45,45,5 do local k7=M;jW[#jW+1]=dp([[<g transform="rotate(%f,%d,%d)">]],k7,al,am)k8=5;if M%15==0 then k8=15 elseif M%10==0 then k8=10 end;jW[#jW+1]=dp([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+k4+k5-k8,al,am+k4+k5)end;jW[#jW+1]=gH(al,am+k4+k5-35,k3,"pdim txt txtmid")jW[#jW+1]=gH(al,am+k4+k5-25,k6 .." deg","pdim txt txtmid")jW[#jW+1]=dp([[<g transform="rotate(%f,%d,%d)">]],-k2,al,am)jW[#jW+1]=dp([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+k4+k5-20,al+5,am+k4+k5-20,al,am+k4+k5-15)jW[#jW+1]="</g>"end;jW[#jW+1]=[[<g style="clip-path: url(#headingClip);">]]local k9=k6;if cY then k9=jY(cH)end;local ka=20;local kb=bN(k9)local kc=0;local kd=am+k4+k5+20;local ke=al;if k3~="YAW"then kd=ja(130)ke=j9(960)end;local kf=[[<path class="txttick line" d="]]local kg=bN(kb-(ka+10)-kb%5+0.5)for M=kg+70,kg,-5 do local hB=ke-(-M*5+k9*5)if M%10==0 then kc=10;local dH=M;if dH==360 then dH=0 elseif dH>360 then dH=dH-360 elseif dH<0 then dH=dH+360 end;jW[#jW+1]=gH(hB,kd+15,dH,"txtmid bright")elseif M%5==0 then kc=5 end;if kc==10 then kf=dp([[%s M %f %f v %d]],kf,hB,kd-5,kc)else kf=dp([[%s M %f %f v %d]],kf,hB,kd-2.5,kc)end end;jW[#jW+1]=kf..[["/>]]jW[#jW+1]=dp([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],ke-5,kd-20,ke+5,kd-20,ke,kd-10)if cY then k3="HDG"end;jW[#jW+1]=gH(j9(960),ja(100),kb.."°","dim txt txtmid size14","")jW[#jW+1]=gH(j9(960),ja(85),k3,"dim txt txtmid size20","")jW[#jW+1]=[[</g>]]end;local function kh(jW,ki,k2,al,am,cY,kj,kk)if ae==0 then return end;local k4=ae;local kl=bN(k4*3/5)if k4>0 then local km=bN(ki)local k8=0;local kf=dp([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k2,al,am)if not cg then kf=dp([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;jW[#jW+1]=dp([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k4-1,al,am)jW[#jW+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(km-30-km%5+0.5),bN(km+30+km%5+0.5),5 do if M%10==0 then k8=30 elseif M%5==0 then k8=20 end;local hC=am+-M*5+ki*5;if k8==30 then kf=dp([[%s M %d %f h %d]],kf,al-kl-k8,hC,k8)if cg then jW[#jW+1]=dp([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k2,al,am,al-kl+10,hC+4,M)jW[#jW+1]=dp([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k2,al,am,al+kl-10,hC+4,M)if M==0 or M==180 or M==-180 then jW[#jW+1]=dp([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k2,al,am,al-kl+20,hC,kl*2-40)end else jW[#jW+1]=gH(al-kl+10,hC,M,"pdim txt txtmid")jW[#jW+1]=gH(al+kl-10,hC,M,"pdim txt txtmid")end;kf=dp([[%s M %d %f h %d]],kf,al+kl,hC,k8)else kf=dp([[%s M %d %f h %d]],kf,al-kl-k8,hC,k8)kf=dp([[%s M %d %f h %d]],kf,al+kl,hC,k8)end end;jW[#jW+1]=kf..[["/>]]local kn="PITCH"if not cY then kn="REL PITCH"end;if ki>90 and not cg then ki=90-(ki-90)elseif ki<-90 and not cg then ki=-90-(ki+90)end;if k4>200 then if cg then if kk>iV then jW[#jW+1]=gH(al,am-15,"Yaw","pdim txt txtmid")jW[#jW+1]=gH(al,am+20,kj,"pdim txt txtmid")end;jW[#jW+1]=dp([[<g transform="rotate(%f,%d,%d)">]],-k2,al,am)else jW[#jW+1]=dp([[<g transform="rotate(0,%d,%d)">]],al,am)end;jW[#jW+1]=dp([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-kl+25,am-5,al-kl+20,am,al-kl+25,am+5,al-kl+50,am+4,km)jW[#jW+1]=dp([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+kl-25,am-5,al+kl-20,am,al+kl-25,am+5,al+kl-30,am+4,km)jW[#jW+1]="</g>"end;local ko=bN(k4/3)jW[#jW+1]=dp([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-ko,am,k4-ko)if not cg and cY then jW[#jW+1]=dp([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k2,al,am,al-kl+10,am,kl*2-20)end;jW[#jW+1]="</g>"if k4<200 then if cg and kk>iV then jW[#jW+1]=gH(al,am-k4,kn,"pdim txt txtmid")jW[#jW+1]=gH(al,am-k4+10,km,"pdim txt txtmid")jW[#jW+1]=gH(al,am-15,"Yaw","pdim txt txtmid")jW[#jW+1]=gH(al,am+20,kj,"pdim txt txtmid")else jW[#jW+1]=gH(al,am-k4,kn,"pdim txt txtmid")jW[#jW+1]=gH(al,am-k4+15,km,"pdim txt txtmid")end end end end;local function kp(jW,e7,cY)local kq=ar;local kr=as;if kq==0 and kr==0 then return end;local ks=78;local kt=19;local ku=cf;if cf~=-1 then jW[#jW+1]=gH(kq+ks,kr+kt+20,dp("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(e7<200000 and not cg or e7 and cg)then jW[#jW+1]=gH(kq+ks,kr-10,dp("%s",kv.name),"pdim altsm txtend")table.insert(jW,dp([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kq-1,kr-4,ks+2,kt+6,kq+1,kr-1,ks-4,kt))local gq=0;local kw=1;local kx=0;local ky=e7<0;local kz=e7<kv.surfaceMaxAltitude;local kA=9;if ky then kA=0 end;local e7=f2(e7)while gq<6 do local kB=11;local kC=16;local kD=9;local kE=14;local jQ="altsm"if gq>2 then kC=kC+3;kB=kB+2;kE=kE+2;kD=kD-6;jQ="altbig"end;if ky then jQ=jQ.." red"elseif kz then jQ=jQ.." orange"end;local kF=e7/kw%10;local kG=bN(kF)local kH=bN((kG+1)%10)local kI=kx;if gq==0 then kI=kF-kG;if ky then kI=1-kI end end;if ky and(gq==0 or kx~=0)then local gt=kH;kH=kG;kG=gt end;local kJ=kC*(kI-1)local kK=kJ+kC;local hB=kq+kD+(6-gq)*kB;local hC=kr+kE;jW[#jW+1]=gH(hB,hC+kJ,kH,jQ)jW[#jW+1]=gH(hB,hC+kK,kG,jQ)gq=gq+1;kw=kw*10;if kG==kA then kx=kI else kx=0 end end;table.insert(jW,[[</g></g>]])end end;local function kL(fp)local kM=-math.deg(eY(fp.y,fp.z))+180;kM=kM-90;if kM<0 then kM=360+kM end;if kM>180 then kM=-180+kM-180 end;return-kM end;local function kN(fp)local k9=math.deg(eY(fp.y,fp.x))-90;if k9<-180 then k9=360+k9 end;return k9 end;local function kO(jW,fp,kk,al,am)if kk>5 and not cg or kk>iV then local k4=ae;local kP=20;local kQ=20;local kR=kL(fp)local kS=kN(fp)local kT=14;local kU=kT/2;local kV=-kS/kQ*k4;local kW=kR/kP*k4;local hB=al+kV;local hC=am+kW;local cb=ds(kV^2+kW^2)local kX=[[<circle
                            cx="]]..hB..[["
                            cy="]]..hC..[["
                            r="]]..kU/kT..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hB..[["
                            cy="]]..hC..[["
                            r="]]..kU..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hB-kT..[[,]]..hC..[[ h ]]..kU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hB+kU..[[,]]..hC..[[ h ]]..kU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hB..[[,]]..hC-kT..[[ v ]]..kU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<k4 then jW[#jW+1]=kX else local jX=eY(kW,kV)local kY=4;local kZ=al+k4*math.cos(jX)local k_=am+k4*math.sin(jX)jW[#jW+1]=dp('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jX*180/math.pi,kZ,k_,kZ-kY,k_-kY/2,kY*2,kY,kZ+kY,k_-kY,kY,kY,-kY,kY)end;if not cg then local l0=vec3(fp)kR=kL(-l0)kS=kN(-l0)kV=-kS/kQ*k4;kW=kR/kP*k4;hB=al+kV;hC=am+kW;cb=ds(kV^2+kW^2)if cb<k4 then local l1=[[<circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hB..[[,]]..hC-kT..[[ v ]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hB..[[,]]..hC..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hB..[[,]]..hC..[[)" />
                                <path
                                    d="M ]]..hB-kU..[[,]]..hC..[[ h ]]..kT..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hB..[[,]]..hC..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hB..[[,]]..hC..[[)"/>]]jW[#jW+1]=l1 end end end end;local function l2(jW,jd,l3,l4)if an==0 and ao==0 then return end;l3=bN(l3+0.5)local jE=ao+10;local jF=ao+20;if iB()==1 and not m then jE=55;jF=65 end;local l5="CRUISE"local c="km/h"local dQ=l4;if jd=="TRAVEL"or jd=="AUTOPILOT"then l5="THROT"c="%"dQ=l3;local l6="dim"if l3<0 then l6="red"end;jW[#jW+1]=dp([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l6,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-f2(l3),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;jW[#jW+1]=gH(an+10,jE,l5,"pbright txtstart")jW[#jW+1]=gH(an+10,jF,dp("%.0f %s",dQ,c),"pbright txtstart")if cg and t and cR and bT then l3=bN(bU*100+0.5)local l6="red"if l3<0 then l6="red"end;jW[#jW+1]=dp([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l6,1-f2(l3),an-10,ao+50,an-15,ao+53,an-15,ao+47)jW[#jW+1]=gH(an+10,jE+40,"LIMIT","pbright txtstart")jW[#jW+1]=gH(an+10,jF+40,l3 .."%","pbright txtstart")end;if cg and t or ba then jW[#jW+1]=gH(an+10,jE-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b5 then jW[#jW+1]=gH(an+10,jE-40,"LIMIT: "..bN(a0*3.6+0.5).." km/h","dim txtstart")end end;local function l7(jW,l8)if an==0 and ao==0 then return end;local l9=ao-10;local la=an+10;jW[#jW+1]=gH(0,0,"","pdim txt txtend")if iB()==1 and not m then l9=75 end;jW[#jW+1]=gH(la,l9,bN(l8).." km/h","pbright txtbig txtstart")end;local lb=40;local function lc(jW)jW[#jW+1]=gH(j9(150),ja(1070),dp("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jW[#jW+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jW[#jW+1]=gH(j9(960),ja(550),"Warning: Invalid Control Scheme Detected","warnings")jW[#jW+1]=gH(j9(960),ja(600),"Keyboard Scheme must be selected","warnings")jW[#jW+1]=gH(j9(960),ja(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ld=j9(960)local le=ja(860)local lf=ja(880)local lg=ja(900)local lh=ja(960)local li=ja(200)local lj=ja(250)local lk=ja(960)if iB()==1 and not m then le=ja(135)lf=ja(155)lg=ja(175)li=ja(115)lj=ja(95)end;if b2 then local ll=""if type(b2)=="string"then ll="-"..b2 end;jW[#jW+1]=gH(ld,le,"Brake Engaged"..ll,"warnings")elseif bS>0 then jW[#jW+1]=gH(ld,le,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b5 and not bs and not b8 and not cQ and not bb and not b9 then jW[#jW+1]=gH(ld,li+50,"** STALL WARNING **","warnings")fO("stall","SW",2)end end;if cX then jW[#jW+1]=gH(ld,li+90,"Flight Assist in Progress","warnings")end;if ck then jW[#jW+1]=gH(ld,lk,"Gyro Enabled","warnings")end;if lm then lb=lb-1;if lb>20 then jW[#jW+1]=gH(ld,lk-20,"ECU Enabled","warnings")elseif lb<0 then lb=40 end end;if bo then if bW then jW[#jW+1]=gH(ld,lf,"Gear Extended","warn")else jW[#jW+1]=gH(ld,lf,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local ln=iG(d:getTargetGroundAltitude())jW[#jW+1]=gH(ld,lg,"Hover Height: "..ln,"warn")end;if c5 then jW[#jW+1]=gH(ld,lh+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cQ and bx~=nil then local lo="warnings"if f2(ci-antigrav.getBaseAltitude())<501 then lo="warn"end;jW[#jW+1]=gH(ld,li+40,dp("Target Altitude: %d Singularity Altitude: %d",bN(bx),bN(antigrav.getBaseAltitude())),lo)end;if b5 and bl~="None"then jW[#jW+1]=gH(ld,li,"Autopilot "..bi,"warn")elseif bv~=nil then jW[#jW+1]=gH(ld,li+20,dp("LockedPitch: %d",bN(bv)),"warn")elseif c0 then jW[#jW+1]=gH(ld,li+20,"Follow Mode Engaged","warn")elseif ba or ce then jW[#jW+1]=gH(ld,li+20,"Re-entry in Progress","warn")end;if b7 or bb then local ln=iG(bc,2)if bb then if cQ then ln=iG(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jW[#jW+1]=gH(ld,li,"VTO to "..ln,"warn")elseif(b9 or cd)and not bB then if cd then jW[#jW+1]=gH(ld,li,"Takeoff to "..bl,"warn")else jW[#jW+1]=gH(ld,li,"Takeoff to "..ln,"warn")end;if b2 and not bb then jW[#jW+1]=gH(ld,li+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jW[#jW+1]=gH(ld,li,"Altitude Hold: "..dp("%.1fm",bc),"warn")end end;if bb and(antigrav~=nil and antigrav)then if ch>0.1 then jW[#jW+1]=gH(ld,li+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then jW[#jW+1]=gH(ld,li+20,"Aligning trajectory","warn")elseif ch<0.05 then jW[#jW+1]=gH(ld,li+20,"Leaving atmosphere","warn")end end;if bB then if cC~=nil then jW[#jW+1]=gH(ld,li,cC,"warn")end end;if b8 then local lp="Brake Landing"if dc then lp=lp.."-Aligning"end;if db then lp=lp.."-Drift Limited"end;jW[#jW+1]=gH(ld,li,lp,"warnings")end;if b4 then jW[#jW+1]=gH(ld,li+20,"Prograde Alignment","crit")end;if b3 then jW[#jW+1]=gH(ld,li,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;jW[#jW+1]=gH(ld,lj+20,cZ,type)elseif ch==0 then local lq,lr=ct.checkLOS(cK:normalize())if lr~=nil and cL>0 then local ln=iG(lr)local ls=cp.computeTravelTime(cL,0,lr)local lt="Collision"if lq.noAtmosphericDensityAltitude>0 then lt="Atmosphere"end;jW[#jW+1]=gH(ld,lj+20,lq.name.." "..lt.." "..iH(ls).." In "..ln,"crit")end end;if bs and not bB then jW[#jW+1]=gH(ld,li+60,lu,"warn")end;if d2 and#d2>1 then end;local lv=j9;local lw=ja;local lx="topButton"local ly="topButtonActive"local lz=lx;if b5 or bs or cd or bB then lz=ly end;local lA=lx;if b4 then lA=ly end;local lB=lx;if b8 or bo then lB=ly end;local lC=lx;if b7 or bs then lC=ly end;local lD=lx;if b3 then lD=ly end;local lE=lx;if bB or cE and b5 then lE=ly end;if w and I then local lF=lw(30)jW[#jW+1]=dp([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lz,lv(960),lw(54),lw(-53),lv(-120),lv(25),lw(50))jW[#jW+1]=gH(lv(910),lF,"AUTOPILOT")jW[#jW+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lA,lv(865),lw(51),lv(-25),lw(-50),lv(-110),lv(25),lw(46))jW[#jW+1]=gH(lv(800),lF,"PROGRADE")jW[#jW+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lB,lv(755),lw(47),lv(-25),lw(-46),lv(-98),lv(44),lw(44))jW[#jW+1]=gH(lv(700),lF,"LAND")jW[#jW+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lC,lv(960),lw(54),lw(-53),lv(120),lv(-25),lw(50))jW[#jW+1]=gH(lv(1010),lF,"ALT HOLD")jW[#jW+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,lv(1055),lw(51),lv(25),lw(-50),lv(110),lv(-25),lw(46))jW[#jW+1]=gH(lv(1122),lF,"RETROGRADE")jW[#jW+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,lv(1165),lw(47),lv(25),lw(-46),lv(98),lv(-44),lw(44))jW[#jW+1]=gH(lv(1220),lF,"ORBIT")jW[#jW+1]=[[
                                    </g>
                                </g>]]jW[#jW+1]="</g>"end;return jW end;local function lG(kk)return bN(fP(kk*3.6,0)+0.5).." km/h"end;local function lH(gq)local gs=bl;if gq~=nil and type(gq)=="number"then if gq==0 then return"None"end;gs=cU[gq].name end;if gs==nil then gs=f_.name end;if gs==nil then gs="None"end;return gs end;local function lI(jW)local lJ=ct.routeWP(true)if not lJ or#lJ==0 then return end;local hB=j9(750)local hC=ja(360)if b5 or bs then jW[#jW+1]=gH(hB,hC,"REMAINING ROUTE","pdim txtstart size20")else jW[#jW+1]=gH(hB,hC,"LOADED ROUTE","pdim txtstart size20")end;for dP,M in pairs(lJ)do hC=hC+20;jW[#jW+1]=gH(hB,hC,dP..". "..lJ[dP],"pdim txtstart size20")end end;local function lK(jW)local lL=aB;local lM=aC;local lN=aA;local lO=4;local lP=15;local hB=0;local hC=0;local lQ,lR,lS,lT;local lU;local function lV(type)local gC,bQ,kk,lW,jQ,lX;if type=="Periapsis"then gC=lU.periapsis.altitude;bQ=lU.timeToPeriapsis;kk=lU.periapsis.speed;jQ="txtend"lW=12;lX=math.min(hB,lL+lN-kv.radius/lS-lO*2)else gC=lU.apoapsis.altitude;bQ=lU.timeToApoapsis;kk=lU.apoapsis.speed;lW=-12;jQ="txtstart"lX=hB end;if cL<1 then bQ=0 end;jW[#jW+1]=dp([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lX+lW,hC-5,hB,hC-5)jW[#jW+1]=dp([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lX-lW*4,hC+2,hB,hC+2)jW[#jW+1]=gH(lX,hC,type,jQ)hB=lX-lW*2;hC=hC+lP;local ln=iG(gC)jW[#jW+1]=gH(hB,hC,ln,jQ)hC=hC+lP;jW[#jW+1]=gH(hB,hC,iH(bQ),jQ)hC=hC+lP;jW[#jW+1]=gH(hB,hC,lG(kk),jQ)end;local lY=lN*1.5;if bK=="INFO"then lY=25*10 end;if bK=="ORBIT"and ci<kv.spaceEngineMinAltitude then return jW end;if bK~="HIDE"then jW[#jW+1]=[[<g class="pbright txtorb txtmid">]]jW[#jW+1]=dp('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lN*2,lY,lL,lM)jW[#jW+1]=dp([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lN*2,lY,lL,lM)end;local lZ=lN*1.5;local l_=lN*2;local m0=lZ/2;local m1=lN;local m2=lL+m1;local m3=lM+m0;local m4=lL+l_;local m5=lM+lZ;if bK=="ORBIT"then lM=lM+lO;lQ=lN/2;lT=0;lU={}lU.periapsis={}lU.apoapsis={}if fo~=nil then if fo.periapsis~=nil then lU.periapsis.altitude=fo.periapsis.altitude;lU.periapsis.speed=fo.periapsis.speed end;if fo.apoapsis~=nil then lU.apoapsis.altitude=fo.apoapsis.altitude;lU.apoapsis.speed=fo.apoapsis.speed end;lU.period=fo.period;lU.eccentricity=fo.eccentricity;lU.timeToApoapsis=fo.timeToApoapsis;lU.timeToPeriapsis=fo.timeToPeriapsis;lU.eccentricAnomaly=fo.eccentricAnomaly;lU.trueAnomaly=fo.trueAnomaly end;if lU.periapsis==nil then lU.periapsis={}lU.periapsis.altitude=-kv.radius;lU.periapsis.speed=a0 end;if lU.eccentricity==nil then lU.eccentricity=1 end;if lU.apoapsis==nil then lU.apoapsis={}lU.apoapsis.altitude=ci;lU.apoapsis.speed=0 end;if cL<1 then lU.apoapsis.altitude=ci;lU.apoapsis.speed=0 end;if lU.apoapsis.altitude then lS=(lU.apoapsis.altitude+lU.periapsis.altitude+kv.radius*2)/(lQ*2)lR=(kv.radius+lU.apoapsis.altitude)/lS*(1-lU.eccentricity)lT=lQ-lU.periapsis.altitude/lS-kv.radius/lS;local m6=math.pi;if lU.period~=nil and lU.period>0 and lU.timeToApoapsis~=nil then m6=lU.eccentricAnomaly;if lU.timeToPeriapsis<lU.timeToApoapsis then m6=2*math.pi-m6 end end;if cL<1 or m6~=m6 then m6=math.pi end;local m7=-lQ*math.cos(m6)+lL+m1+lO;local m8=lR*math.sin(m6)+lM+m0+lO;local m9=""jW[#jW+1]='<g clip-path="url(#orbitRect)">'jW[#jW+1]=dp([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],m9,lL+lN+lO,lM+lN*1.5/2+lO,lQ,lR)if lR<1 then jW[#jW+1]=dp([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lL+lN+lO-lT,lM+lN*1.5/2+lO,m7,m8)end;jW[#jW+1]=dp('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lL+lN+lO-lT,lM+lN*1.5/2+lO,(kv.radius+kv.noAtmosphericDensityAltitude)/lS)jW[#jW+1]=dp('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lL+lN+lO-lT,lM+lN*1.5/2+lO,(kv.radius+kv.noAtmosphericDensityAltitude)/lS)jW[#jW+1]=dp([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lL+lN+lO,lM+lN*1.5/2+lO,lQ,lR)jW[#jW+1]=dp('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lL+lN+lO-lT,lM+lN*1.5/2+lO,kv.radius/lS)jW[#jW+1]='</g>'local ma=math.floor(kv.radius/lS+0.5)hB=lL+lN+lO*4+lQ;hC=lM+lN*1.5/2+5+lO;if lU.apoapsis~=nil and lU.apoapsis.speed<a0 then lV("Apoapsis")end;hC=lM+lN*1.5/2+5+lO;hB=lL+lN-lO*2-lQ;if lU.periapsis~=nil and lU.periapsis.speed<a0 and lU.periapsis.altitude>0 then lV("Periapsis")end;jW[#jW+1]=gH(lL+lN+lO,lM+20+lO,kv.name,"txtorbbig")jW[#jW+1]=dp('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m7,m8)jW[#jW+1]=[[</g>]]return jW else jW[#jW+1]='<g clip-path="url(#orbitRect)">'local mb=""local mc=1.2*(md-me)/(lN*2)local mf=1.4*(mg-mh)/(lN*1.5)for dP,dB in pairs(e[0])do if dB.center then local hB=lL+lN+dB.center.x/mc;local hC=lM+lN*1.5/2+dB.center.y/mf;mb=mb..'<circle cx="'..hB..'" cy="'..hC..'" r="'..dB.radius/mc*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dB.name,"Moon")and not string.match(dB.name,"Sanctuary")and not string.match(dB.name,"Space")then mb=mb.."<text x='"..hB.."' y='"..hC+dB.radius/mc*30+20 .."' font-size='12' fill="..j1 .." text-anchor='middle' font-family='Montserrat'>"..dB.name.."</text>"end end end;local fq=vec3(bP.getWorldPosition())local hB=lL+lN+fq.x/mc;local hC=lM+lN*1.5/2+fq.y/mf;mb=mb..'<circle cx="'..hB..'" cy="'..hC..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mb=mb.."<text x='"..hB.."' y='"..hC-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iP=mc;iQ=mf;local mi=fq+cK*1000000;local mj=lL+lN+mi.x/mc;local jF=lM+lN*1.5/2+mi.y/mf;mb=mb..'<line x1="'..hB..'" y1="'..hC..'" x2="'..mj..'" y2="'..jF..'" stroke="purple" stroke-width="1"/>'jW[#jW+1]=mb;jW[#jW+1]='</g>'end elseif bK=="INFO"then jW=cr.DrawOdometer(jW,j3,bp,j4)elseif bK=="SCOPE"then jW[#jW+1]='<g clip-path="url(#orbitRect)">'local mk=d5;local ml=vec3(DUSystem.getCameraWorldPos())local mm=vec3(DUSystem.getCameraWorldRight())local mn=vec3(DUSystem.getCameraWorldForward())if iD()==1 then ml=cO;mm=cI;mn=cH end;if ch>0 then table.sort(d4,function(eE,eF)local eG,eH=eE.center,eF.center;return(eG.x-ml.x)^2+(eG.y-ml.y)^2+(eG.z-ml.z)^2<(eH.x-ml.x)^2+(eH.y-ml.y)^2+(eH.z-ml.z)^2 end)end;local mo={}local mp={}local mq=120;local mr=nil;local ms=nil;for M,dB in ipairs(d4)do local gP=dB.center-ml;local mt=gP:len()local mu=gP:normalize()local mv=gP:cross(mn):normalize()local mw=math.acos(mv:dot(mm))if mw~=mw then mw=0 end;if mv:cross(mm):dot(mn)<0 then mw=-mw end;local mx=gP:project_on_plane(mn):len()local my=math.sin(mw)*math.asin(mx/mt)*constants.rad2deg;local mz=math.cos(mw)*math.asin(mx/mt)*constants.rad2deg;if mu:dot(mn)<0 then mz=90*math.cos(mw)+90*math.cos(mw)-mz;my=90*math.sin(mw)+90*math.sin(mw)-my end;local hB=m2+my/mk*lZ;local hC=m3+mz/mk*lZ;local mA=(hB-m2)*(hB-m2)+(hC-m3)*(hC-m3)local mB=math.asin((dB.radius+dB.surfaceMaxAltitude)/mt)*constants.rad2deg;if mB~=mB then mB=mk end;local hW=mB/mk*lZ;local mC=math.asin(dB.atmosphereRadius/mt)*constants.rad2deg;if mC~=mC then mC=mB end;local mD=mC/mk*lZ;local cb=iG(mt,1)local mE=dB.name;local mF=false;if hC>lM then if hC>m5 then if hC-mD<=m5 then mF=true end else mF=true end else if hC+mD>=lM then mF=true end end;local mG=false;local mH=hB;if dB.systemId==0 then mH=hB+mq else mH=hB-mq end;if mH+mq>lL then if mH+mq>m4 then if mH-mD-mq<=m4 then mG=true end else mG=true end else if mH+mD+mq>=lL then mG=true end end;local mI={}mI.x=hB;mI.y=hC;mI.planet=dB;mI.atmoSize=mD;if not mr or mA<mr then mr=mA;ms=mI end;if mG and mF then local mJ=math.max(mD,5)if mA<mJ*mJ then mE=mE.." - "..cb end;mI.size=hW;mI.i=M;mI.displayString=mE;mI.distance=cb;mI.visible=true;mp[#mp+1]=mI else mI.visible=false end end;local mK=false;table.sort(mp,function(eG,eH)return eG.y<eH.y end)for dP,fl in ipairs(mp)do local dB,hW,M,mD,hB,hC,mE,cb=fl.planet,fl.size,fl.i,fl.atmoSize,fl.x,fl.y,fl.displayString,fl.distance;local lX,mL,mM,mN;local mO=15;local jQ="pdim"if dB.systemId~=0 then mM=j9(string.len(mE)*5)mO=-(15+mM)mN=ja(10)jQ="pdimfill"else mM=j9(string.len(mE)*9)mN=ja(15)end;if hW*2>mM then lX=dq(hB,lL+mM/2,m4-mM/2)mL=dq(hC,lM+mN,m5-5)lX=dq(lX,hB-hW+mM/2,hB+hW-mM/2)mL=dq(mL,hC-hW+mN,hC+hW)else lX=hB+mO;mL=hC end;for mP,fl in pairs(mo)do local mQ=fl.textPositions;local mR=mQ.y-mL;if mP~=M and f2(mR)<mQ.height and mQ.x+mQ.width>lX and mQ.x<lX+mM then if hW>mM then mL=dq(mL+mN,lM+15,m5-5)else mL=mQ.y+mQ.height+1 end end end;local mS=mE~=dB.name or lX<=m2 and lX+mM>=m2 and mL-mN<=m3 and mL>=m3;fl.hovered=mS;local mT=1;if mS then mT=2;if hW*2<mM then mT=10 end;if mE==dB.name then mE=mE.." - "..cb end;jQ="pbright"if dB.systemId~=0 then mM=j9(string.len(mE)*5)mO=-(15+mM)else mM=j9(string.len(mE)*7)end;if hW*2>mM then lX=dq(hB,lL+mM/2,m4-mM/2)lX=dq(lX,hB-hW+mM/2,hB+hW-mM/2)else lX=hB+mO end end;mo[M]={}mo[M].textPositions={}mo[M].textPositions.y=mL;mo[M].textPositions.x=lX;mo[M].textPositions.width=mM;mo[M].textPositions.height=mN;mo[M].output=""if hW*2>mM then jQ=jQ.." txtmid"else jQ=jQ.." txtstart"end;if mD-hW>2 then mo[M].output=dp('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hB,hC,mD,j2,0.1*mT)end;mo[M].output=mo[M].output..dp('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hB,hC,hW,j2,0.2*mT)if dB.systemId==0 then mo[M].output=mo[M].output..dp([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lX,mL,j1,jQ,mE)if hW*2<=mM then mo[M].output=mo[M].output..dp("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lX+mM,mL+2,lX,mL+2,hB,hC)end else mo[M].output=mo[M].output..dp([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lX,mL,j2,jQ,mE)if hW*2<=mM then mo[M].output=mo[M].output..dp("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lX,mL+2,lX+mM,mL+2,hB,hC)end end end;for dP=#d4,1,-1 do if mo[dP]then jW[#jW+1]=mo[dP].output end end;if ms~=nil and d5<90 and not ms.hovered then local mU=ms.planet.atmosphereRadius/ms.atmoSize;local mV=ds(mr)*mU;local mW=iG(mV,1)local mM=j9(math.max(string.len(mW)*7,string.len(ms.planet.name)*7))local mN=ja(12)local lX=dq(ms.x+(m2-ms.x)/2,lL+mM/2,m4-mM/2)local mL=dq(ms.y+(m3-ms.y)/2,lM+mN*2,m5-5)jW[#jW+1]=dp("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",ms.x,ms.y,m2,m3)jW[#jW+1]=dp([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lX,mL,"white",mW)if not ms.visible then jW[#jW+1]=dp([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lX,mL-mN,"white",ms.planet.name)end end;if cL>1 then local gP=cK;local mu=gP:normalize()local mx=gP:project_on_plane(mn):len()local mv=gP:cross(mn):normalize()local mw=math.acos(mv:dot(mm))if mw~=mw then mw=0 end;if mv:cross(mm):dot(mn)<0 then mw=-mw end;local my=math.sin(mw)*math.asin(mx/gP:len())*constants.rad2deg;local mz=math.cos(mw)*math.asin(mx/gP:len())*constants.rad2deg;if mu:dot(mn)<0 then mz=90*math.cos(mw)+90*math.cos(mw)-mz;my=90*math.sin(mw)+90*math.sin(mw)-my end;local hB=m2+my/mk*lZ;local hC=m3+mz/mk*lZ;local kT=14;local kU=kT/2;local kX=[[<circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kU/kT..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hB-kT..[[,]]..hC..[[ h ]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hB+kU..[[,]]..hC..[[ h ]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hB..[[,]]..hC-kT..[[ v ]]..kU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jW[#jW+1]=kX end;jW[#jW+1]=dp("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m2,m3-10,m2,m3+10)jW[#jW+1]=dp("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m2-10,m3,m2+10,m3)jW[#jW+1]='</g>'else return jW end end;local function mX(mY,mZ)local m_;local n0=(mZ-mY):normalize()local fr=(cO-mY):dot(n0)/n0:dot(n0)if fr<=0. then return(cO-mY):len(),nil elseif fr>=(mZ-mY):len()then return(cO-mZ):len(),nil end;local n1=mY+fr*n0;m_=(n1-cO):len()return m_,n1 end;local function n2()local m_;local n3,n4=nil,nil;local n5=nil;local n6=nil;local n7=nil;local n8,n9=kv.center,nil;for dP,na in pairs(e[0])do n9=na.center;if n9 then local cb,n3=mX(n8,n9)if n5==nil or cb<n5 then n6=na;n5=cb;n4=n3;n7=kv end end end;if n4 then dg=n4;di=n6 end;local nb=j9(1770)local nc=ja(330)if n5 then local nd="txttick "local ne=500000;if n5<n6.radius+ne or n5<n7.radius+ne then if cV then nd="txttick red "else nd="txttick orange "end end;m_=iG(n5,2)iU=gH(nb,nc,"Closest Pipe ("..n7.name.."--"..n6.name.."): "..m_,nd.."pbright txtmid")if c8 and c8.name~=kv.name and c8.name~="Space"then n5,dh=mX(n8,c8.center)m_=iG(n5,2)iU=iU..gH(nb,nc+15,"Target Pipe ("..n7.name.."--"..c8.name.."): "..m_,nd.."pbright txtmid")di=c8 else dh=nil end end end;local function nf(hB,hC,ng,nh,l5)local ni={x=hB,y=hC,width=ng,height=nh,label=l5}iO[l5]=ni;return ni end;local function nj(nk,nl,ng,nh,hB,hC,nm,nn,no,np,jQ)local ni={enableName=nk,disableName=nl,width=ng,height=nh,x=hB,y=hC,toggleVar=nm,toggleFunction=nn,drawCondition=no,hovered=false,class=jQ}if np then table.insert(iN,ni)else table.insert(iM,ni)end;return ni end;local function nq(nr)if not iS then ns=false;nt=false;nu=false;w=true;return elseif nr=="handling"then ns=not ns;nt=false;nu=false elseif nr=="hud"then nt=not nt;ns=false;nu=false elseif nr=="physics"then nu=not nu;ns=false;nt=false end;if nu or nt or ns then iT=iF(nr)w=false else iT="none"w=true end end;local function nv()iS=not iS;if iS then iL=iN;dm("Tap LMB to see Settings")d6=w else iL=iM;dm("Tap LMB to see Control Buttons")nq()w=d6 end end;local function nw()local function nx(dB,dP)dB.set(not dB.get())if dB.get()then dm(dP.." set to true")else dm(dP.." set to false")end;if dP=="showHud"then d6=dB.get()elseif dP=="BrakeToggleDefault"then b0=k end end;local ny=50;local nz=340;local hB=ac/2-530;local hC=ad/2-330+ny/2;local nA=0;for dP,dB in pairs(iF("boolean"))do if type(dB.get())=="boolean"then nj(dP,dP,nz,ny,hB,hC,function()return dB.get()end,function()nx(dB,dP)end,function()return true end,true)hC=hC+ny+20;if nA==9 then hB=hB+nz+20;hC=ad/2-330+ny/2;nA=0 else if hB>ac/2-nz and hB<ac/2+nz/2 and hC>ad/2-ny and hC<ad/2+ny then hC=hC+ny+20;nA=nA+1 end;nA=nA+1 end end end;nj("Control View","Control View",nz,ny,10,ad/2-500,function()return true end,nv,function()return true end,true)nj("View Handling Settings",'Hide Handling Settings',nz,ny,10,ad/2-(500-ny),function()return ns end,function()nq("handling")end,function()return true end,true)nj("View Hud Settings",'Hide Hud Settings',nz,ny,10,ad/2-(500-ny*2),function()return nt end,function()nq("hud")end,function()return true end,true)nj("View Physics Settings",'Hide Physics Settings',nz,ny,10,ad/2-(500-ny*3),function()return nu end,function()nq("physics")end,function()return true end,true)end;local function nB()local function gr()local fR=cO;local gs=kv.name..". "..#br;if cu then gs=cu.GetClosestName(gs)end;return cs.AddNewLocation(gs,fR,false,true)end;local function nC()b6=not b6 end;local function nD(nE)if nE==1 then b4=not b4;b3=false else b3=not b3;b4=false end;b5=false;b7=false;c0=false;b8=false;bv=nil;ba=false;b9=false end;local function nF(nG,nH)cs.UpdatePosition(nil,nG,nH)end;local function gm()cs.ClearCurrentPosition()end;local function nI(gq)local lJ=ct.routeWP(true)if lJ and#lJ>0 then return"Engage Route: "..lJ[1]end;return"Engage Autopilot: "..lH(gq)end;local function nJ(gq)local lJ=ct.routeWP(true)if lJ and#lJ>0 then return"Next Route Point: "..lJ[1]end;return"Disable Autopilot: "..lH(gq)end;local function nK()if iB()==1 then c0=not c0;if c0 then b5=false;b3=false;b4=false;b7=false;ba=false;b8=false;b9=false;nL=bo;bo=false;d.control.retractLandingGears()iC:setTargetGroundAltitude(Y)fO("folOn","F")else fO("folOff","F")b2="Follow Off"cz=q;bo=nL;if bo then d.control.deployLandingGears()iC:setTargetGroundAltitude(Z)end end else dm("Follow Mode only works with Remote controller")c0=false end end;local ny=50;local nz=260;local nM=j9(30)local nN=aB+aA*2+2;local nO=aC+1;nj("+","+",nM,nM,nN,nO+nM+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")nj("-","-",nM,nM,nN,nO,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")nj("0","0",nM,nM,nN,nO+nM*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nP=nj("Enable Brake Toggle","Disable Brake Toggle",nz,ny,ac/2-nz/2,ad/2+350,function()return b0 end,function()b0=not b0;if b0 then dm("Brakes in Toggle Mode")else dm("Brakes in Default Mode")end end)nj("Align Prograde","Disable Prograde",nz,ny,ac/2-nz/2-50-nP.width,ad/2-ny+380,function()return b4 end,function()nD(1)end)nj("Align Retrograde","Disable Retrograde",nz,ny,ac/2-nz/2+nP.width+50,ad/2-ny+380,function()return b3 end,nD,function()return ch==0 end)nQ=nj(nI,nJ,600,60,ac/2-600/2,ad/2-60/2-330,function()return b5 or bs or cd or bB end,function()end)local M;local function nR(nS)local gq=d1+nS;if gq>#cU then gq=gq-#cU-1 end;if gq<0 then gq=#cU+gq end;return gq end;nT={}for M=0,10 do local nU=nj(function(eH)local gq=nR(eH.apExtraIndex)if b5 or bs or cd or bB then return"Redirect: "..lH(gq)end;return nI(gq)end,function(eH)local gq=nR(eH.apExtraIndex)return nJ(gq)end,600,60,ac/2-600/2,ad/2-60/2-330+60*M,function(eH)local gq=nR(eH.apExtraIndex)return gq==bn and(b5 or bs or cd or bB)end,function(eH)local gq=nR(eH.apExtraIndex)local nV=bn==gq;bn=gq;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not nV and not(b5 or bs or cd or bB)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nU.apExtraIndex=M;nT[M]=nU end;nj("Save Position","Save Position",200,nQ.height,nQ.x+nQ.width+30,nQ.y,function()return false end,gr,function()return bn==0 or f_==nil end)nj("Update Position","Update Position",200,nQ.height,nQ.x+nQ.width+30,nQ.y,function()return false end,function()nF(nil)end,function()return bn>0 and f_~=nil end)nj("Save Heading","Clear Heading",200,nQ.height,nQ.x+nQ.width+30,nQ.y+nQ.height+20,function()return f_.heading~=nil end,function()if f_.heading~=nil then nF(false)else nF(true)end end,function()return bn>0 and f_~=nil end)nj("Save AGG Alt","Clear AGG Alt",200,nQ.height,nQ.x+nQ.width+30,nQ.y+nQ.height*2+40,function()return f_.agg~=nil end,function()if f_.agg~=nil then nF(nil,false)else nF(nil,true)end end,function()return bn>0 and f_~=nil and antigrav end)nj("Clear Position","Clear Position",200,nQ.height,nQ.x-200-30,nQ.y,function()return true end,gm,function()return bn>0 and f_~=nil end)nj("Save Route","Save Route",200,nQ.height,nQ.x-200-30,nQ.y+nQ.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)nj("Load Route","Clear Route",200,nQ.height,nQ.x-200-30,nQ.y+nQ.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b5 or bs then dm("Disable Autopilot before loading route")return else ct.routeWP(false,false,1)end end,function()return true end)ny=60;nz=300;local hB=0;local hC=ad/2-150;nj("Enable Check Damage","Disable Check Damage",nz,ny,hB,hC-ny-20,function()return s end,function()s=not s end)nj("View Settings","View Settings",nz,ny,hB,hC,function()return true end,nv)hC=hC+ny+20;nj("Enable Turn and Burn","Disable Turn and Burn",nz,ny,hB,hC,function()return b6 end,nC)hB=10;hC=ad/2-300;nj("Horizontal Takeoff Mode","Vertical Takeoff Mode",nz,ny,ac/2-nz/2,hC+20,function()return b1 end,function()b1=not b1;if b1 then dm("Vertical Takeoff Mode")else dm("Horizontal Takeoff Mode")end end,function()return cP end)hC=hC+ny+20;nj("Engage Orbiting","Cancel Orbiting",nz,ny,hB+nz+20,hC,function()return bB end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hC=ad/2-150;nj("Glide Re-Entry","Cancel Glide Re-Entry",nz,ny,hB+nz+20,hC,function()return ba end,function()cc=1;nD(1)end,function()return kv.hasAtmosphere and not cg end)hC=hC+ny+20;nj("Parachute Re-Entry","Cancel Parachute Re-Entry",nz,ny,hB+nz+20,hC,function()return ba end,function()cc=2;nD(1)end,function()return kv.hasAtmosphere and not cg end)hC=hC+ny+20;nj("Engage Follow Mode","Disable Follow Mode",nz,ny,hB,hC,function()return c0 end,nK,function()return iB()==1 end)nj("Enable Repair Arrows","Disable Repair Arrows",nz,ny,hB+nz+20,hC,function()return j7 end,function()j7=not j7;if j7 then dm("Repair Arrows Enabled")else dm("Repair Arrows Diabled")end end,function()return iB()==1 end)hC=hC+ny+20;if not r then nj("Enable AGG","Disable AGG",nz,ny,hB,hC,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;nj(function()return dp("Switch IPH Mode - Current: %s",bC)end,function()return dp("IPH Mode: %s",bC)end,nz*2,ny,hB,hC,function()return false end,function()if bC=="All"then bC="Custom Only"elseif bC=="Custom Only"then bC="No Moons-Asteroids"else bC="All"end;dm("IPH Mode: "..bC)end)hC=hC+ny+20;nj(function()return dp("Toggle Control Scheme - Current: %s",g)end,function()return dp("Control Scheme: %s",g)end,nz*2,ny,hB,hC,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;dm("New Control Scheme: "..g)end)local nW=ja(20)local nU=nf(0,0,j9(80),nW,"INFO")nU=nf(nU.x+nU.width,nU.y,j9(70),nW,"ORBIT")nU=nf(nU.x+nU.width,nU.y,j9(70),nW,"SCOPE")nf(nU.x+nU.width,nU.y,j9(70),nW,"HIDE")end;local nX={}local nY=nil;function nX.HUDPrologue(jW)if not cV then iZ=ai;i_=aj;j0=ak else iZ=af;i_=ag;j0=ah end;j1=[[rgb(]]..bN(iZ+0.6)..","..bN(i_+0.6)..","..bN(j0+0.6)..[[)]]j2=[[rgb(]]..bN(iZ*0.8+0.5)..","..bN(i_*0.8+0.5)..","..bN(j0*0.8+0.5)..[[)]]local nZ=j1;local n_=j2;local o0=[[rgb(]]..bN(iZ*0.4+0.5)..","..bN(i_*0.4+0.5)..","..bN(j0*0.4+0.5)..[[)]]local o1=j1;local o2=j2;local o3=o0;if jb()and not n then nZ=[[rgb(]]..bN(iZ*0.5+0.5)..","..bN(i_*0.5+0.5)..","..bN(j0*0.5+0.5)..[[)]]n_=[[rgb(]]..bN(iZ*0.3+0.5)..","..bN(i_*0.3+0.5)..","..bN(j0*0.2+0.5)..[[)]]o0=[[rgb(]]..bN(iZ*0.2+0.5)..","..bN(i_*0.2+0.5)..","..bN(j0*0.2+0.5)..[[)]]end;local lv=j9;local lw=ja;jW[#jW+1]=dp([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nZ,nZ,nZ,o1,o1,n_,n_,o2,o2,n_,nZ,o0,o2,nZ,nZ,o0,o0,o3,o0,ac,ad,n_,n_,n_,n_,n_,o1,n_,o2,o3,o2,o2,o3)if not nY then nY=dp([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lv(630),lw(0),lv(675),lw(45),lv(960),lw(55),lv(1245),lw(45),lv(1290),lw(0),lv(1000),lw(105),lv(1040),lw(59),lv(1250),lw(51),lv(1300),lw(0),lv(1920),lw(0),lv(1920),lw(20),lv(1400),lw(20),lv(1300),lw(105),lv(920),lw(105),lv(880),lw(59),lv(670),lw(51),lv(620),lw(0),lv(0),lw(0),lv(0),lw(20),lv(520),lw(20),lv(620),lw(105),lv(890),lw(59),lv(960),lw(62),lv(1030),lw(59),lv(985),lw(112),lv(1150),lw(112),lv(1100),lw(152),lv(820),lw(152),lv(780),lw(112),lv(935),lw(112),lv(890),lw(59),lv(960),lw(62),lv(1030),lw(59),lv(985),lw(112),lv(1150),lw(112),lv(1100),lw(152),lv(820),lw(152),lv(780),lw(112),lv(935),lw(112))end;if w and I then jW[#jW+1]=nY end;return jW end;function nX.DrawVerticalSpeed(jW,e7)jV(jW,e7)end;function nX.UpdateHud(jW)local kM=cS;local o4=cT;local k2=o4;local ki=kM;local l3=bN(c.getThrottle())local l8=cL*3.6;local l4=c.getAxisCommandValue(0)local o5=j9(1770)local o6=ja(310)if t and cR then l4=bR;l3=bR*100 end;local jd=jc()local k3="ROLL"if l3==nil then l3=0 end;if not cY then if cL>5 then kM=kL(cJ)o4=kN(cJ)else kM=0;o4=0 end;k3="YAW"end;if cW>50000 and not cg then local o7;o7=iG(cW)jW[#jW+1]=gH(o5,o6,"PvP Boundary: "..o7,"pbright txtbig txtmid")end;jW[#jW+1]=j5;jW[#jW+1]=i9;if iU~=""then jW[#jW+1]=iU end;if je~=""then jW[#jW+1]=je end;if jf~=""then jW[#jW+1]=jf end;jV(jW,ci)if iB()==0 or m then if not jb()or n then if cY then k1(jW,al,am,k2,k3,cY)kh(jW,ki,k2,al,am,cY,bN(kN(cJ)),cL)else k1(jW,al,am,o4,k3,cY)kh(jW,kM,o4,al,am,cY,bN(o4),cL)end;kp(jW,ci,cY)kO(jW,cJ,cL,al,am)end end;l2(jW,jd,l3,l4)l7(jW,l8)lc(jW)lK(jW)if not iS and c1 then lI(jW)end;return jW end;function nX.HUDEpilogue(jW)jW[#jW+1]="</svg>"return jW end;function nX.ExtraData(jW)local o8=j9(1240)local o9=ja(55)local oa=o9+10;local ob;local lv=j9;local lw=ja;local oc=0;local jd=jc()if b1 then jd=jd.."-VERTICAL"end;if E and gS and not b9 and not b8 and cL>20 then jd=jd.."-COLLISION ON"end;if bE~="Off"then jd="("..bE..")-"..jd end;if b6 then jd="TB-"..jd end;if not bD then jd=jd.."-DeCoupled"end;if dj then jd="Alignment Lock-"..jd end;local od=lw(99)local oe=lw(80)local of=lw(85)local og=lw(31)local oh=0;local oi=0;local f7=cj>1000000 and fP(cj/1000000,2).."kT"or fP(cj/1000,2).."T"if cg then oc=bw else oc=bu end;local oj,ok=cp.computeDistanceAndTime(cL,0,cj,0,0,oc)if oj<0 then oj=0 end;oc=fP(oc/(cj*iK),2).."g"local ol=d:maxForceForward()ob=b.getGravityIntensity()if ob>0.1 then oi=cj*ob;oi=fP(oi/(cj*iK),2).."g"oh=0.5*ol/ob;oh=oh>1000000 and fP(oh/1000000,2).."kT"or fP(oh/1000,2).."T"end;ol=fP(ol/(cj*iK),2).."g"local om=vec3(bP.getWorldAcceleration()):len()/9.80665;ob=b.getGravityIntensity()jW[#jW+1]=[[<g class="dim txt txtend size14">]]if iB()==1 and not m then o8=j9(1120)o9=ja(55)oa=o9+10 elseif cg and I then local on=j9(770)jW[#jW+1]=gH(lv(895),od,"ATMO","")jW[#jW+1]=dp([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lv(895),of,lv(-80))jW[#jW+1]=gH(lv(815),oe,dp("%.1f%%",ch*100),"txtstart size20")end;if I then jW[#jW+1]=gH(lv(1025),od,"GRAVITY","txtstart")jW[#jW+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lv(1025),of,lv(80))jW[#jW+1]=gH(lv(1105),oe,dp("%.2fg",ob/9.80665),"size20")jW[#jW+1]=gH(lv(1125),od,"ACCEL","txtstart")jW[#jW+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lv(1125),of,lv(80))jW[#jW+1]=gH(lv(1205),oe,dp("%.2fg",om),"size20")jW[#jW+1]=gH(lv(695),od,"BRK TIME","")jW[#jW+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lv(695),of,lv(-80))jW[#jW+1]=gH(lv(615),oe,dp("%s",iH(ok)),"txtstart size20")jW[#jW+1]=gH(lv(635),lw(45),"TRIP","")jW[#jW+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lv(635),lw(31),lv(-90))if ls then jW[#jW+1]=gH(lv(545),lw(26),dp("%s",iH(ls)),"txtstart size20")end;jW[#jW+1]=gH(lv(795),od,"BRK DIST","")jW[#jW+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lv(795),of,lv(-80))jW[#jW+1]=gH(lv(715),oe,dp("%s",iG(oj)),"txtstart size20")jW[#jW+1]=gH(lv(1285),lw(45),"MASS","txtstart")jW[#jW+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lv(1285),lw(31),lv(90))jW[#jW+1]=gH(lv(1375),lw(26),dp("%s",f7),"size20")jW[#jW+1]=gH(lv(1220),od,"THRUST","txtstart")jW[#jW+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lv(1220),of,lv(80))jW[#jW+1]=gH(lv(1300),oe,dp("%s",ol),"size20")jW[#jW+1]=gH(j9(960),ja(175),jd,"pbright txtbig txtmid size20")end;jW[#jW+1]="</g>"end;local oo=1-(a6*0.05+a7*0.05)function nX.FuelUsed(op)local oq;if op=="atmofueltank"then oq=dp("Atmo Fuel Used: %.1f L",jw[op]/(4*oo))elseif op=="spacefueltank"then oq=dp("Space Fuel Used: %.1f L",jw[op]/(6*oo))else oq=dp("Rocket Fuel Used: %.1f L",jw[op]/(0.8*oo))end;return oq end;local os,ot,ou,ov,ow=0,0,0,{},0;local ox=0;local oy=0;local oz=0;local oA=0;function nX.DrawOdometer(jW,j3,bp,j4)if bK~="INFO"then return jW end;local ob;local oc=0;local oi=0;local f7=cj>1000000 and fP(cj/1000000,2).." kTons"or fP(cj/1000,2).." Tons"if cg then oc=bw else oc=bu end;local oj,ok=cp.computeDistanceAndTime(cL,0,cj,0,0,oc)local ol=d:maxForceForward()ob=b.getGravityIntensity()if cL<5 and cf~=-1 then local oB=vec3(bP.getOrientationForward())local oC=bP.getMaxThrustAlongAxis('thrust analog longitudinal ',{oB:unpack()})ox=0.5*oC[1]/ob;ox=ox>1000000 and fP(ox/1000000,1).." kTons"or fP(ox/1000,1).." Tons"oy=0.5*oC[3]/ob;oy=oy>1000000 and fP(oy/1000000,1).." kTons"or fP(oy/1000,1).." Tons"oB=vec3(bP.getOrientationUp())oC=bP.getMaxThrustAlongAxis('hover_engine, booster_engine',{oB:unpack()})oz=0.5*oC[1]/ob;oz=oz>1000000 and fP(oz/1000000,1).." kTons"or fP(oz/1000,1).." Tons"oA=0.5*oc/ob;oA=oA>1000000 and fP(oA/1000000,1).." kTons"or fP(oA/1000,1).." Tons"end;oc=fP(oc/(cj*iK),2).." g"if ob>0.1 then oi=cj*ob;oi=fP(oi/(cj*iK),2).." g"else oi="n/a"end;ol=fP(ol/(cj*iK),2).." g"if iB()==0 or m then local oD=j9(aB+10)local oE=ja(aC+20)local oF=j9(aB+10+aA/1.25)local nh=25;local oG=bN(1/aT)if ou<oG then ow=ow+a.getActionUpdateDeltaTime()ou=ou+1 else os=1/(ow/oG)table.insert(ov,os)ou,ow=0,0 end;ot=0;for dP,dB in pairs(ov)do ot=ot+dB end;if#ov>0 then ot=bN(ot/#ov)end;if#ov>29 then table.remove(ov,1)end;jW[#jW+1]="<g class='txtstart size14 bright'>"jW[#jW+1]=gH(oD,oE,dp("BrkTime: %s",iH(ok)))jW[#jW+1]=gH(oF,oE,dp("Trip: %.2f km",j3))jW[#jW+1]=gH(oD,oE+nh,dp("Lifetime: %.2f kSU",bp/200000))jW[#jW+1]=gH(oF,oE+nh,dp("BrkDist: %s",iG(oj)))jW[#jW+1]=gH(oD,oE+nh*2,"Trip Time: "..iH(j4))jW[#jW+1]=gH(oF,oE+nh*2,"Total Time: "..iH(bq))jW[#jW+1]=gH(oD,oE+nh*3,dp("Mass: %s",f7))jW[#jW+1]=gH(oF,oE+nh*3,dp("Safe Brake Mass: %s",oA))jW[#jW+1]=gH(oD,oE+nh*4,dp("Max Thrust: %s",ol))jW[#jW+1]=gH(oF,oE+nh*4,dp("Safe Atmo Mass: %s",ox))jW[#jW+1]=gH(oD,oE+nh*5,dp("Max Brake: %s",oc))jW[#jW+1]=gH(oF,oE+nh*5,dp("Safe Space Mass: %s",oy))jW[#jW+1]=gH(oF,oE+nh*6,dp("Safe Hover Mass: %s",oz))jW[#jW+1]=gH(oD,oE+nh*6,dp("Influence: %s",kv.name))jW[#jW+1]=gH(oD,oE+nh*7,dp("Set Max Speed: %s",bN(a0*3.6+0.5)))jW[#jW+1]=gH(oF,oE+nh*7,dp("Actual Max Speed: %s",bN(df*3.6+0.5)))jW[#jW+1]=gH(oD,oE+nh*8,dp("Friction Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))jW[#jW+1]=gH(oF,oE+nh*8,dp("FPS (Avg): %s (%s)",bN(os),ot))end;jW[#jW+1]="</g></g>"return jW end;function nX.DrawWarnings(jW)return lc(jW)end;function nX.DisplayOrbitScreen(jW)return lK(jW)end;function nX.DisplayMessage(jW,ln)if ln~="empty"then local hC=310;for lp in string.gmatch(ln,"([^\n]+)")do hC=hC+35;jW[#jW+1]=gH("50%",hC,lp,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;function nX.DrawDeadZone(jW)jW[#jW+1]=dp([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;function nX.UpdatePipe()if cg then iU=""return end;n2()end;function nX.DrawSettings(jW)local hB=j9(640)local hC=ja(200)jW[#jW+1]=[[<g class="pbright txtvspd txtstart">]]local hS=0;for dP,dB in pairs(iT)do hS=hS+1;jW[#jW+1]=gH(hB,hC,dP..": "..dB.get())hC=hC+20;if hS%12==0 then hB=hB+j9(350)hC=ja(200)end end;jW[#jW+1]=gH(j9(640),ja(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jW[#jW+1]="</g>"return jW end;local i8=ja(125)local i7=j9(1225)function nX.DrawRadarInfo()i9=cu.GetRadarHud(i7,i8,ax,ay)if i9 then gS=true end end;function nX.DrawTanks()if at~=0 and au~=0 then je=gH(at,au,"","txtstart pdim txtfuel")jx=au;jy(at,"Atmospheric ","ATMO",cl,ju,jv)jy(at,"Space Fuel T","SPACE",cm,js,jt)jy(at,"Rocket Fuel ","ROCKET",cn,jq,jr)end end;function nX.DrawShield()local ik=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oH=bP.getPvPTimer()local oI=shield.getResistances()local oJ="A: "..10+oI[1]*100 .."% / E: "..10+oI[2]*100 .."% / K:"..10+oI[3]*100 .."% / T: "..10+oI[4]*100 .."%"local hB,hC=av-60,aw+30;local jO=bN(dk*2.55)local jP=dp("rgb(%d,%d,%d)",255-jO,jO,0)local jQ=""jf=gH(hB,hC,"","txtmid pdim txtfuel")if dk<10 and ik~="Shield Disabled"then jQ="red "end;oH=oH>0 and"   PvPTime: "..iH(oH)or""jf=jf..dp([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hB,hC,jP,dk*2,hB,hC,hB+2,hC+10,dk,oH)jf=jf..gH(hB,hC-5,ik,jQ.."txtstart pbright txtbig")jf=jf..gH(hB,hC+30,oJ,jQ.."txtstart pbright txtsmall")end;function nX.hudtick()if not kv then return end;local function oK(jW)local jS=bN(dq(dd/(ac/4)*255,0,255))jW[#jW+1]=dp("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(iZ+0.5)+jS,bN(i_+0.5)-jS,bN(j0+0.5)-jS)end;local function oL()if c2 then for dU,dB in pairs(iL)do if dB.hovered then if not dB.drawCondition or dB.drawCondition(dB)then dB.toggleFunction(dB)end;dB.hovered=false end end;for dU,dB in pairs(iO)do if dB.hovered then bK=dB.label;dB.hovered=false end end;c2=false end end;local function oM()local function oN(oO,oP,hB,hC,ng,nh)if oO>=hB and oO<=hB+ng and oP>=hC and oP<=hC+nh then return true else return false end end;local hB=c9+ac/2;local hC=ca+ad/2;for dU,dB in pairs(iL)do dB.hovered=oN(hB,hC,dB.x,dB.y,dB.width,dB.height)end;for dU,dB in pairs(iO)do dB.hovered=oN(hB,hC,dB.x,dB.y,dB.width,dB.height)end;if d0 then local mS=false;for dU,eH in ipairs(nT)do if eH.hovered then mS=true;break end end;if nQ.hovered then mS=true end;d0=mS else d0=nQ.hovered;if not d0 then d1=bn end end end;local function oQ(jW)if not bK or bK==""then bK="INFO"end;if w then for dP,dB in pairs(iO)do local jQ="dim brightstroke"local oR=0.2;if bK==dP then jQ="pbright dimstroke"oR=0.6 end;local oS=""if dB.hovered then oR=0.8;oS=";stroke:white"end;jW[#jW+1]=dp([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dB.width,dB.height,dB.x,dB.y,jQ,oR,oS)jW[#jW+1]=gH(dB.x+dB.width/2,dB.y+dB.height/2+5,dB.label,"txt txtmid pdim")end end end;local function oT(jW)local function oU(jW,oV,hover,hB,hC,oW,oX,oY,oZ,o_,p0,nU)if type(o_)=="function"then o_=o_(nU)end;if type(p0)=="function"then p0=p0(nU)end;jW[#jW+1]=dp("<rect x='%f' y='%f' width='%f' height='%f' fill='",hB,hC,oW,oX)if oV then jW[#jW+1]=dp("%s'",oY)else jW[#jW+1]=oZ end;if hover then jW[#jW+1]=dp(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else jW[#jW+1]=dp(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fP(af*0.5,0),fP(ag*0.5,0),fP(ah*0.5,0))end;jW[#jW+1]=" rx='5'></rect>"jW[#jW+1]=dp("<text x='%f' y='%f' font-size='24' fill='",hB+oW/2,hC+oX/2+5)if oV then jW[#jW+1]="black"else jW[#jW+1]="white"end;jW[#jW+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oV then jW[#jW+1]=dp("%s</text>",o_)else jW[#jW+1]=dp("%s</text>",p0)end end;local p1=dp("rgb(%d,%d,%d)'",fP(af*0.1,0),fP(ag*0.1,0),fP(ah*0.1,0))local p2=dp("rgb(%d,%d,%d)",fP(af*0.8,0),fP(ag*0.8,0),fP(ah*0.8,0))local p3=oU;for dU,dB in pairs(iL)do local nl=dB.disableName;local nk=dB.enableName;if type(nl)=="function"then nl=nl(dB)end;if type(nk)=="function"then nk=nk(dB)end;if not dB.drawCondition or dB.drawCondition(dB)then p3(jW,dB.toggleVar(dB),dB.hovered,dB.x,dB.y,dB.width,dB.height,p2,p1,nl,nk,dB)end end end;local p4=fP(ac/2,0)local p5=fP(ad/2,0)local jW={}if p6 then jW[#jW+1]=p6 end;cr.HUDPrologue(jW)if w then cr.UpdateHud(jW)else if A then cr.DrawVerticalSpeed(jW,ci)end;cr.DrawWarnings(jW)end;if iS and iT~="none"then cr.DrawSettings(jW)end;if cu then cr.DrawRadarInfo()else i9=""end;cr.HUDEpilogue(jW)jW[#jW+1]=dp([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ac,ad)if c3~="empty"then cr.DisplayMessage(jW,c3)end;if iB()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(jW)end end;oQ(jW)if iD()==0 then if iB()==1 and c1 then if not p7 then oM()oT(jW)end;if not cx and not cy then local p8=table.concat(jW,"")jW={}jW[#jW+1]=dp("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jW[#jW+1]=p8;jW[#jW+1]="</body>"cx=true;jW[#jW+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local p8=table.concat(jW,"")jW={}jW[#jW+1]=dp("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jW[#jW+1]=p8;jW[#jW+1]="</body>"end;if not cx then jW[#jW+1]=dp([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p4,p5,c9,ca)end else oL()end else if not c1 and iB()==0 then oL()if dd>az then if v then oK(jW)end end elseif c1 and(not p7 or not j)then oM()oT(jW)end;jW[#jW+1]=dp([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p4,p5,c9,ca)end;jW[#jW+1]=[[</svg></body>]]p9=table.concat(jW,"")end;function nX.TenthTick()local function pa()local pb=a.createData;local pc=a.createWidget;pd=a.createWidgetPanel("Interplanetary Helper")pe=pc(pd,"value")pf=pb('{"label": "Target Planet", "value": "N/A", "unit":""}')fN(pf,pe)pg=pc(pd,"value")ph=pb('{"label": "distance", "value": "N/A", "unit":""}')fN(ph,pg)gg=pc(pd,"value")gf=pb('{"label": "Travel Time", "value": "N/A", "unit":""}')fN(gf,gg)gi=pc(pd,"value")gh=pb('{"label": "Target Altitude", "value": "N/A", "unit":""}')fN(gh,gi)pi=pc(pd,"value")pj=pb('{"label": "Space Engine", "value": "N/A", "unit":""}')fN(pj,pi)pk=pc(pd,"value")pl=pb('{"label": "End Speed", "value": "N/A", "unit":""}')ga=pc(pd,"value")g9=pb('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g8=pc(pd,"value")g7=pb('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g6=pc(pd,"value")g5=pb('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g4=pc(pd,"value")g3=pb('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gc=pc(pd,"value")gb=pb('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fN(pl,pk)fN(g9,ga)fN(g7,g8)fN(g5,g6)fN(g3,g4)fN(gb,gc)end end;local function pm()gG(pd)pd=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bl~="None"then if pd==nil then pa()end;if bl~=nil then local mt;local pn=f_~=nil;local po=b5 and bh*3.6 or 0;fM(pf,'{"label": "Target", "value": "'..bl..'", "unit":""}')if pn and not b5 then mt=(cO-f_.position):len()else mt=(bm-cO):len()end;if not b6 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)iW,iX=ct.GetAutopilotBrakeDistanceAndTime(a0)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)iW,iX=ct.GetAutopilotTBBrakeDistanceAndTime(a0)end;local ln=iG(mt)fM(ph,'{"label": "distance", "value": "'..ln..'"}')fM(gf,'{"label": "Travel Time", "value": "'..iH(ls)..'", "unit":""}')ln=iG(c6)fM(g9,'{"label": "Cur Brake distance", "value": "'..ln..'"}')fM(g7,'{"label": "Cur Brake Time", "value": "'..iH(c7)..'", "unit":""}')ln=iG(iW)fM(g5,'{"label": "Max Brake distance", "value": "'..ln..'"}')fM(g3,'{"label": "Max Brake Time", "value": "'..iH(iX)..'", "unit":""}')fM(pl,'{"label": "End Speed", "value": "'..dp("%.0fkph",po)..'", "unit":""}')ln=iG(gj)fM(gh,'{"label": "High Orbit", "value": "'..ln..'"}')fM(pj,'{"label": "Space Engine Alt", "value": "'..c8.spaceEngineMinAltitude..'m"}')if cg and not pp then a.removeDataFromWidget(g3,g4)a.removeDataFromWidget(pl,pk)a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)pp=true;if not cR and t and(b7 or ba or ce)then ct.cmdThrottle(1)b2=false;bV=false end end;if not cg and pp then if fM(g3,g4)==1 then fN(g3,g4)end;if fM(g3,pk)==1 then fN(pl,pk)end;if fM(g5,g6)==1 then fN(g5,g6)end;if fM(g7,g8)==1 then fN(g7,g8)end;if fM(g9,ga)==1 then fN(g9,ga)end;if fM(gb,gc)==1 then fN(gb,gc)end;pp=false end end else pm()end;if warpdrive~=nil then local pq=iz(warpdrive.getWidgetData())if pq.destination~="Unknown"and pq.distance>400000 then if not j8 then warpdrive.showWidget()j8=true end elseif j8 then warpdrive.hideWidget()j8=false end end end;function nX.OneSecondTick()local function pr()local jI=bM()local l8=cL;local ps=jI-j6;if l8>1.38889 then l8=l8/1000;local pt=l8*(jI-j6)bp=bp+pt;j3=j3+pt end;j4=j4+ps;bq=bq+ps;j6=jI end;local function pu(jW)local pv=0;local pw=iJ;local px=0;local py=0;local pz=0;local jO=0;local jP=""local pA=b.getElementHitPointsById;local pB=b.getElementMaxHitPointsById;local pC={}for dP in pairs(iI)do local pD=0;local pE=0;pE=pB(iI[dP])pD=pA(iI[dP])px=px+pD;if pD+1<pE then if pD==0 then pz=pz+1 else py=py+1 end;if j7 and#pC==0 then fR=vec3(b.getElementPositionById(iI[dP]))local hB=fR.x;local hC=fR.y;local hD=fR.z;table.insert(pC,b.spawnArrowSticker(hB,hC,hD+1,"down"))table.insert(pC,b.spawnArrowSticker(hB,hC,hD+1,"down"))b.rotateSticker(pC[2],0,0,90)table.insert(pC,b.spawnArrowSticker(hB+1,hC,hD,"north"))table.insert(pC,b.spawnArrowSticker(hB+1,hC,hD,"north"))b.rotateSticker(pC[4],90,90,0)table.insert(pC,b.spawnArrowSticker(hB-1,hC,hD,"south"))table.insert(pC,b.spawnArrowSticker(hB-1,hC,hD,"south"))b.rotateSticker(pC[6],90,-90,0)table.insert(pC,b.spawnArrowSticker(hB,hC-1,hD,"east"))table.insert(pC,b.spawnArrowSticker(hB,hC-1,hD,"east"))b.rotateSticker(pC[8],90,0,90)table.insert(pC,b.spawnArrowSticker(hB,hC+1,hD,"west"))table.insert(pC,b.spawnArrowSticker(hB,hC+1,hD,"west"))b.rotateSticker(pC[10],-90,0,90)table.insert(pC,iI[dP])end elseif j7 and#pC>0 and pC[11]==iI[dP]then for jH in pairs(pC)do b.deleteSticker(pC[jH])end;pC={}end end;pv=fP(px/pw*100,2)if pz>0 or py>0 then jW[#jW+1]=gH(0,0,"","pbright txt")jO=bN(pv*2.55)jP=dp("rgb(%d,%d,%d)",255-jO,jO,0)jW[#jW+1]=gH("50%",1035,"Elemental Integrity: "..pv.."%","txtbig txtmid","fill:"..jP)if pz>0 then jW[#jW+1]=gH("50%",1055,"Disabled Modules: "..pz.." Damaged Modules: "..py,"txtbig txtmid","fill:"..jP)elseif py>0 then jW[#jW+1]=gH("50%",1055,"Damaged Modules: "..py,"txtbig txtmid","fill:"..jP)end end end;local function pF()if iy then if iY==nil and(hf~=nil or bo)then _autoconf.displayCategoryPanel(iy,weapon_size,"Weapons","weapon",true)iY=_autoconf.panels[_autoconf.panels_size]elseif iY~=nil and hf==nil and not bo then gG(iY)iY=nil end end end;local jW={}pr()if s then pu(jW)end;pF()cr.UpdatePipe()cr.ExtraData(jW)j5=table.concat(jW,"")end;function nX.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function nX.MsgTick()local jW={}cr.DisplayMessage(jW,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function nX.ButtonSetup()nw()nB()iL=iM end;if pG then for dP,dB in pairs(pG)do nX[dP]=dB end end;return nX end;local function pH(d,b,c,e,vBooster,hover,pI,antigrav,dbHud_1,f2,bN,bO,iB,eY,bM,dq,iC,fM,iD,ds,fP,fO,iE,dt,iG,iH,pJ,iz,dm)local a=DUSystem;local bP=DUConstruct;local pK={}local pL=false;local pM=0;local pN=0;local pO=0;local pP=bM()local pQ=0;local pR=0;local pS=0;local pT=0;local pU=false;local pV=false;local pW=false;local pX=nil;local pY=0;local iV=55;local pZ=nil;local p_=false;local q0=false;local q1=false;local q2=0;local q3=0;local q4=0;local q5=0;local q6=0;local q7={VectorToTarget=false}local q8=vec3(bP.getWorldOrientationUp())local q9=nil;local qa=0;local qb=-1;local qc=-1;local qd=false;local qe=false;local qf=0;local qg=false;local qh=false;local qi=false;local qj=false;local qk=""local ql=false;local qm=false;local qn=""local qo=false;local qp=0;local qq=0;local function qr()return bP.isInPvPZone()~=1,f2(bP.getDistanceToSafeZone())end;local function qs(kk)local qt=bh;if not b5 then qt=0 end;local qu=bu;if cg then if bw and bw>0 then qu=bw else return 0,0 end end;return cp.computeDistanceAndTime(kk,qt,cj,0,0,qu-bj*cj)end;local function qv(kk)local qt=bh;if not b5 then qt=0 end;return cp.computeDistanceAndTime(kk,qt,cj,d:maxForceForward(),a2,bu-bj*cj)end;local function qw(qx,qy,qz)qy=qy:project_on_plane(qx)qz=qz:project_on_plane(qx)return eY(qy:cross(qz):dot(qx),qy:dot(qz))end;local qA=-1;local qB=-1;local function qC()local function qD()local qE=-1;local qF=-1;if vBooster then qE=vBooster.getDistance()if qE>-1 and qE<0.01 then qE=qA else qA=qE end end;if hover then qF=hover.getDistance()if qF>-1 and qF<0.01 then qF=qB else qB=qF end end;if qE~=-1 and qF~=-1 then if qE<qF then return qE else return qF end elseif qE~=-1 then return qE elseif qF~=-1 then return qF else return-1 end end;local qG=qD()local qH=-1;if antigrav and antigrav.isActive()==1 and not r and cL<iV then local qI=f2(ci-antigrav.getBaseAltitude())if qI<50 then return qI end end;if pI then qH=pI.raycast().distance;if qH==0 then qH=-1 end end;if qG~=-1 and qH~=-1 then if qG<qH then return qG else return qH end elseif qG~=-1 then return qG else return qH end end;local function qJ(kv,eP,qK)local function qL(qM,e0)local eV=vec3(e0)if qM.id==0 then return setmetatable({latitude=eV.x,longitude=eV.y,altitude=eV.z,id=0,systemId=qM.systemId},e2)end;local eW=eV-qM.center;local cb=eW:len()local e7=cb-qM.radius;local e5=0;local e6=0;if not dt(cb,0)then local eX=eY(eW.y,eW.x)e6=eX>=0 and eX or 2*math.pi+eX;e5=math.pi/2-math.acos(eW.z/cb)end;return setmetatable({latitude=math.deg(e5),longitude=math.deg(e6),altitude=e7,id=qM.id,systemId=qM.systemId},e2)end;local qN=qL(kv,eP)qN="::pos{"..qN.systemId..","..qN.id..","..qN.latitude..","..qN.longitude..","..qN.altitude.."}"if qK then return qN else qi=qN;return true end end;local function qO(qP,qQ,qR)local function qS(qP,ey)qP=vec3(qP)ey=vec3(ey):normalize()local dK=qP*ey;return dK.x+dK.y+dK.z end;local qT=0.001;local qU=1;if not cg or not cA or cf~=-1 or cL<iV then if qR==nil then qR=aS end;if qQ==nil then qQ=qT end;qP=vec3(qP):normalize()local qV=vec3()-qP;local qW=-qS(qV,bP.getWorldOrientationRight())*qU;local qX=-qS(qV,bP.getWorldOrientationUp())*qU;if pN==0 then pN=qW/2 end;if pO==0 then pO=qX/2 end;if f2(qW)<0.1 then q3=q3-qW*2 else q3=q3-(qW+(qW-pN)*qR)end;if f2(qX)<0.1 then q2=q2+qX*2 else q2=q2+qX+(qX-pO)*qR end;pN=qW;pO=qX;if f2(qW)<qQ and f2(qX)<qQ then return true end;return false elseif cA and cf==-1 then qP=cK;if qR==nil then qR=aS end;if qQ==nil then qQ=qT end;qP=vec3(qP):normalize()local qV=cH-qP;local qW=-qS(qV,bP.getWorldOrientationRight())*qU;local qX=-qS(qV,bP.getWorldOrientationUp())*qU;if pN==0 then pN=qW/2 end;if pO==0 then pO=qX/2 end;if f2(qW)<0.1 then q3=q3-qW*5 else q3=q3-(qW+(qW-pN)*qR)end;if f2(qX)<0.1 then q2=q2+qX*5 else q2=q2+qX+(qX-pO)*qR end;pN=qW;pO=qX;if f2(qW)<qQ and f2(qX)<qQ then return true end;return false end end;function pK.clearAll()bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"b3=false;b4=false;cX=nil;b7=false;ba=false;b8=false;b9=false;bb=false;c0=false;q0=false;cc=false;cd=false;q1=false;cz=q;bs=false;b6=false;ck=false;bv=nil;bB=false;db=false;dc=nil;ce=false end;function pK.GetAutopilotBrakeDistanceAndTime(kk)return qs(kk)end;function pK.GetAutopilotTBBrakeDistanceAndTime(kk)return qv(kk)end;function pK.showWayPoint(kv,eP,qK)return qJ(kv,eP,qK)end;function pK.APTick()local qY=a.getMouseWheel()if qY>0 then ct.changeSpd()elseif qY<0 then ct.changeSpd(true)else p_=true end;qf=iD()if qi then a.setWaypoint(qi)qi=false end;if ql then antigrav.setTargetAltitude(ql)ql=false end;if qj then fM(qj,qk)qj=false;qk=""end;if qc~=-1 then ct.cmdCruise(qc,qd)qd=false;qc=-1 end;if q9~=nil then if iC:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iC:getTargetSpeed(axisCommandId.longitudinal)~=q9 then iC:setTargetSpeedCommand(axisCommandId.longitudinal,q9)else q9=nil end end;if qb~=-1 then ct.cmdThrottle(qb,qd)qd=false;qb=-1 end;if qe then cv.landingGear(qe)qe=false end;if qm then ct.ToggleAutopilot()end end;function pK.ToggleIntoOrbit()cE=false;pS=nil;pT=nil;pY=0;pV=false;if not cg then if bB then fO("orOff","AP")bB=false;pU=false;pX=nil;cz=q;if b7 then b7=false;b9=false end;q7.VectorToTarget=false;q7.AutopilotAlign=false;pW=false elseif cY then fO("orOn","AP")bB=true;cz=true;if pX==nil then pX=kv end;if b7 then b7=false;b9=false end else dm("Unable to engage auto-orbit, not near a planet")end else bB=false;pU=false;pX=nil;cz=q;if b7 then b7=false end;q7.VectorToTarget=false;q7.AutopilotAlign=false;pW=false end end;function pK.ToggleVerticalTakeoff()b7=false;if bb then qZ=true;ba=false;b9=false;b8=true;cz=true;b_=0;if cg and cf==-1 then b8=false;b7=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qc=bN(cB)end else cE=false;bo=false;d.control.retractLandingGears()iC:setTargetGroundAltitude(Y)b2="VTO Takeoff"end;bb=not bb end;function pK.checkLOS(qP)local lq,eN,eO=co:getPlanetarySystem(0):castIntersections(cO,qP,function(ew)if ew.noAtmosphericDensityAltitude>0 then return ew.radius+ew.noAtmosphericDensityAltitude else return ew.radius+ew.surfaceMaxAltitude*1.5 end end)local lr=eN;if eO~=nil and eN~=nil then lr=math.min(eO,eN)end;if lr~=nil then return lq,lr else return nil,nil end end;local function q_(r0,r1)if r1 then b_=0;iC:updateCommandFromActionStop(axisCommandId.vertical,r1)if bD then iC:activateGroundEngineAltitudeStabilization(r2)de=true end else b_=b_+r0;iC:deactivateGroundEngineAltitudeStabilization()iC:updateCommandFromActionStart(axisCommandId.vertical,r0)end end;function pK.vertical(r0,r1)q_(r0,r1)end;function pK.ToggleAutopilot()local function r3(bz)cZ=false;bs=not bs;if bs then b6=false;if not b7 and not bz then ct.ToggleAltitudeHold()end end;lu="Proceeding to Waypoint"end;local function r4(gs)if gs then for M,dP in pairs(cU)do if dP.name and dP.name==gs then return M end end else return 0 end end;local r5=false;if bQ-pR<1.5 and cg then if not cG then if cg then bc=kv.spaceEngineMinAltitude-0.01*kv.noAtmosphericDensityAltitude;fO("11","EP")pR=-1;if b5 or bs or bB then return end else dm("No space engines detected, Orbital Hop not supported")return end elseif kv.hasAtmosphere then if cg then bc=kv.noAtmosphericDensityAltitude+U;fO("orH","OH")end;pR=-1;if b5 or bs or bB then return end end else pR=bQ end;r6=false;dj=false;if(bn>0 or#bH>0)and not b5 and not bs and not cd and not bB then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then dm("WARNING: Heavy Loads may affect autopilot performance.")end;if#bH>0 and not ce then bn=r4(bH[1])cs.UpdateAutopilotTarget()dm("Route Autopilot in Progress")local qV=f_.position-cO;local r7=qV:project_on_plane(cM):len()if r7>50000 and f_.planetname==kv.name then r5=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c8,bm)if f_~=nil then if f_.agg and not r and antigrav then if not cQ then ct.ToggleAntigrav()end;bx=f_.agg end;bv=nil;bz=f_.planetname=="Space"if bz then fO("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b5=true end elseif kv.name==f_.planetname then qZ=true;if cg then if not bs then fO("vtt","AP")r3(bz)if r5 then bc=kv.noAtmosphericDensityAltitude+U end end else fO("apOn","AP")if not(c8.name==kv.name and ci<gj*1.5)then cE=false;b5=true elseif not cg then if bB then ct.ToggleIntoOrbit()end;cD=(kv.noAtmosphericDensityAltitude>0 and kv.noAtmosphericDensityAltitude or kv.surfaceMaxAltitude)+U;pW=true;q7.AutopilotAlign=true;q7.VectorToTarget=true;pU=false;if not bB then ct.ToggleIntoOrbit()end end end else fO("apP","AP")b3=false;b4=false;if cg then cd=true;ct.ToggleAltitudeHold()else b5=true end end elseif not cg then if f_==nil and(c8.name==kv.name and cY)and not bB then r8=false;cE=false;pU=false;cD=(kv.noAtmosphericDensityAltitude>0 and kv.noAtmosphericDensityAltitude or kv.surfaceMaxAltitude)+U;pW=true;ct.ToggleIntoOrbit()else fO("apP","AP")b5=true;b3=false;b4=false;be=false;c0=false;b7=false;b8=false;ba=false;b9=false;q0=false;bv=nil;r8=false end else fO("apP","AP")cd=true;ct.ToggleAltitudeHold()end;qm=false else fO("apOff","AP")ct.ResetAutopilots(1)if qm==2 then qm=true end end end;function pK.routeWP(r9,ra,rb)if rb then if rb==1 then bH={}bH=iE(bH,bG)if#bH>0 then dm("Route Loaded")else dm("No Saved Route found on Databank")end;return bH else bG={}bG=iE(bG,bH)dm("Route Saved")pJ()return end end;if r9 then return bH end;if ra then bH={}dm("Current Route Cleared")else bH[#bH+1]=f_.name;dm("Added "..f_.name.." to route. ")end;return bH end;function pK.cmdThrottle(dQ,rc)if iC:getAxisCommandType(0)~=axisCommandType.byThrottle and not rc then d.control.cancelCurrentControlMasterMode()end;iC:setThrottleCommand(axisCommandId.longitudinal,dQ)bR=dq(fP(dQ*100,0)/100,-1,1)q9=nil end;function pK.cmdCruise(dQ,rc)if iC:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rc then d.control.cancelCurrentControlMasterMode()end;iC:setTargetSpeedCommand(axisCommandId.longitudinal,dQ)q9=dQ end;function pK.ToggleLockPitch()if bv==nil then fO("lkPOn","LP")if not c1 then bv=cS else bv=rd end;b9=false;b7=false;b8=false else fO("lkPOff","LP")bv=nil end end;function pK.ToggleAltitudeHold()if bQ-pQ<1.5 then if kv.hasAtmosphere then if cg then bc=kv.spaceEngineMinAltitude-0.01*kv.noAtmosphericDensityAltitude;fO("11","EP")else if cY then bc=kv.noAtmosphericDensityAltitude+U;cD=bc;pW=true;if not bB then ct.ToggleIntoOrbit()end;pU=true end end;pQ=-1;if b7 or bB or bb then return end end else pQ=bQ end;if cY and not cg and cf==-1 then cD=ci;pW=true;pU=true;ct.ToggleIntoOrbit()if bB then pQ=bQ else pQ=0 end;return end;b7=not b7;b8=false;ba=false;dj=false;if b7 then b5=false;b4=false;b3=false;c0=false;cz=true;bv=nil;cE=false;if cf~=-1 then if cL<20 then if bo then cv.landingGear()end;fO("lfs","LS")b9=true;if cg then bc=ci+X else bc=kv.surfaceMaxAltitude+100 end;b2="ATO Hold"iC:setTargetGroundAltitude(Y)if b1 and cP then ct.ToggleVerticalTakeoff()end end else fO("altOn","AH")b9=false;if pQ>-1 then if cY then bc=ci end end;if bb then ct.ToggleVerticalTakeoff()end end;if cQ and not r then local re=antigrav.getBaseAltitude()if bs and f_.agg and f_.agg>ci then bc=f_.agg elseif b9 then bc=re end;if f2(ci-re)<100 and cL<20 then bc=re;b2="AGG Hold"qb=0 end end;if cd then bc=200000 end else fO("altOff","AH")if bB then ct.ToggleIntoOrbit()end;if bb then ct.ToggleVerticalTakeoff()end;cz=q;b9=false;bs=false;pQ=0 end end;function pK.ResetAutopilots(pK)if pK then cd=false;b5=false;be=false;q0=false;bc=ci;r6=false;db=false;bi="Aligning"end;bs=false;b9=false;ba=false;dj=false;b4=false;b8=false;dc=nil;rf=false;cX=nil;db=false;if not cQ then b7=false;bv=nil end;if bb then ct.ToggleVerticalTakeoff()end;if bB then ct.ToggleIntoOrbit()end;cz=q;cc=false;ce=false;b_=0 end;function pK.BrakeToggle(rg)if not b2 then if rg then b2=rg else b2=true end else b2=false end;if b8 then b8=false;cz=q;db=false end;if b2 then fO("bkOn","B",1)ct.ResetAutopilots()else fO("bkOff","B",1)end end;function pK.BeginReentry()if ba then dm("Re-Entry cancelled")fO("reOff","RE")ba=false;cz=q;b7=false elseif not kv.hasAtmosphere then dm("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c4=5 elseif not q1 then ba=true;if iC:getAxisCommandType(0)~=rh.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b2=false;dm("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB)fO("par","RE")else ba=true;b7=true;cz=true;b2=false;bc=kv.surfaceMaxAltitude+_;if bc>kv.spaceEngineMinAltitude then bc=kv.spaceEngineMinAltitude-0.01*kv.noAtmosphericDensityAltitude end;local ri=iG(bc)dm("Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..ri)fO("glide","RE")qc=bN(cB)end;b9=false end;function pK.ToggleAntigrav()if antigrav and not r then if cQ then fO("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bx==nil then bx=ci end;if bx<1000 then bx=1000 end;fO("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pK.changeSpd(rj)local rk=1;if rj then rk=-1 end;if not c1 then if t and not p7 and p_ then local rl=bR;bR=fP(dq(bR+rk*aE/100,-1,1),2)if bR>=0 and rl<0 then bR=0;p_=false end elseif p7 then if cg or ba then cB=dq(cB+rk*aE,0,V)elseif b5 then a0=dq(a0+rk*aE/3.6*100,0,df-0.2)end else iC:updateCommandFromActionStart(axisCommandId.longitudinal,rk*aE/10)end else if b5 or bs or cd or bB then d1=d1+1*rk*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not rj then rk=1 else rk=nil end;cs.adjustAutopilotTargetIndex(rk)end end end;function pK.TenthTick()local function rm()if not b5 then if f_==nil or f_.planetname~=kv.name then rn=(c8.center-cO):len()else rn=(f_.position-cO):len()end end;local kk=cL;local ro=c.getThrottle()/100;if t then ro=bR end;local rp,rq=cp.computeDistanceAndTime(cL,a0,cj,d:maxForceForward()*ro,a2,0)local c6,c7;if not b6 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(a0)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dU,rr;if not b6 and kk>0 then dU,rr=ct.GetAutopilotBrakeDistanceAndTime(kk)else dU,rr=ct.GetAutopilotTBBrakeDistanceAndTime(kk)end;local rs=0;local rt=0;if bg or not b5 and kk>5 then rt=cp.computeTravelTime(kk,0,rn)elseif c6+rp<rn then rs=rn-(c6+rp)rt=cp.computeTravelTime(a0,0,rs)else local ru=(rn-c6)/rp;rp=rn-c6;rq=rq*ru end;if f_~=nil and f_.planetname==kv.name and not b5 then return rt elseif bf then return rr elseif bg then return rt+rr else return rq+c7+rt end end;local function rv()local ob=b.getGravityIntensity()ob=fP(ob,5)if pZ==nil or pZ~=ob then local kk=cJ:len()local rw=bP.getMaxBrake()if rw~=nil and rw>0 and cg then rw=rw/dq(kk/100,0.1,1)rw=rw/ch;if ch>0.10 then bw=rw end end;if rw~=nil and rw>0 then bu=rw end;pZ=ob end end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()qq=0;for M=1,#d3 do qq=qq+bP.getDockedConstructMass(d3[M])end;local rx=0;for M=1,#d2 do rx=rx+bP.getBoardedPlayerMass(d2[M])end;if rx>20000 then qq=qq+rx-20000 end;cV,cW=qr()df=bP.getMaxSpeed()if bl~="None"and(c8 or f_)then ls=rm()end;rv()end;local ry=pid.new(10,0,10.0)local function rz(rA,rB)local oB=vec3()local rC=vec3()if rA==axisCommandId.longitudinal then oB=vec3(bP.getOrientationForward())rC=cH elseif rA==axisCommandId.vertical then oB=vec3(bP.getOrientationUp())rC=q8 elseif rA==axisCommandId.lateral then oB=vec3(bP.getOrientationRight())rC=cI else return vec3()end;local rD=vec3(b.getWorldGravity())local rE=rD:dot(rC)local rF=vec3(bP.getWorldAirFrictionAcceleration())local rG=rF:dot(rC)local rH=cJ:dot(oB)local rI=rB*constants.kph2m;ry:inject(rI-rH)local rJ=ry:get()local rK=(rJ-rG-rE)*rC;return rK end;local rL=pid.new(10,0,10.0)local function rM(rA,rB)local oB=vec3()local rC=vec3()if rA==axisCommandId.longitudinal then oB=vec3(bP.getOrientationForward())rC=cH elseif rA==axisCommandId.vertical then oB=vec3(bP.getOrientationUp())rC=q8 elseif rA==axisCommandId.lateral then oB=vec3(bP.getOrientationRight())rC=cI else return vec3()end;local rD=vec3(b.getWorldGravity())local rE=rD:dot(rC)local rF=vec3(bP.getWorldAirFrictionAcceleration())local rG=rF:dot(rC)local rH=cJ:dot(oB)local rI=rB*constants.kph2m;rL:inject(rI-rH)local rJ=rL:get()local rK=(rJ-rG-rE)*rC;return rK end;local function rN(rO,jZ,fW)local rP=rO:cross(fW):normalize_inplace()local kM=math.acos(dq(rP:dot(-jZ),-1,1))*constants.rad2deg;if rP:cross(-jZ):dot(fW)<0 then kM=-kM end;return kM end;local function rQ()if c_ and not b8 then local ew=c_[1]local hZ,h_=c_[2],c_[3]local rR=math.min(hZ,h_ or hZ)local rS=rR/cL;local rT=b9 and(cL<42 or cf~=-1)local rU=b7 or bs or bv or b5;if rU and not rT and(c6*1.5>rR or rS<1)then b2="Collision"bH={}qb=0;if b7 then ct.ToggleAltitudeHold()end;if bv then ct.ToggleLockPitch()end;dm("Autopilot Cancelled due to possible collision")a.print(ew.name.." COLLISION "..iH(rS).." / "..iG(rR,2))ct.ResetAutopilots(1)qZ=true;if cg then b8=true end;cz=true end;if rS<11 then cZ=ew.name.." COLLISION "..iH(rS).." / "..iG(rR,2)else cZ=ew.name.." collision "..iH(rS)end;if rS<6 then fO("alarm","AL",2)end else cZ=false end end;local rV=1;local rW=0;local rX=1;local rY=1;local rZ=1;local r_=false;local s0=pid.new(0.1,0,1*0.1)local s1=pid.new(1*0.01,0,5*0.1)local s2=pid.new(aI*0.01,0,aI*0.1)local s3=pid.new(2*0.01,0,2*0.1)local s1=pid.new(1*0.01,0,5*0.1)local s4=pid.new(2*0.01,0,2*0.1)local s5=pid.new(2*0.01,0,2*0.1)local s6=pid.new(2*0.01,0,2*0.1)local s7=pid.new(2*0.01,0,2*0.1)local s8=pid.new(0.1,0,1)local s9=pid.new(1*0.01,0,1*0.1)function pK.onFlush()if antigrav and not r and not cQ and antigrav.getBaseAltitude()~=bx then ql=bx end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iC:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local sa=dq(bX+q2+a.getControlDeviceForwardInput(),-1,1)local sb=dq(bY+q4+a.getControlDeviceYawInput(),-1,1)local sc=dq(bZ+q3-a.getControlDeviceLeftRightInput(),-1,1)local sd=b2 and 1 or 0;if cg then cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(kv.center-cO):normalize()end else cM=(kv.center-cO):normalize()end;q8=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()+qq;cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local se=cT/180*math.pi;local sf=math.cos(se)local sg=math.sin(se)cS=rN(cM,cH,cI*sf+q8*sg)local sh=cK:normalize()local si=f2(cT)local sj=utils.sign(cT)local sk=vec3(bP.getWorldAngularVelocity())local sl=sa*aO*cI+sb*aJ*cH+sc*aP*q8;if cz==true and cM:len()>0.01 then local sm=f2(q5-cT)if((b4 or ba or b8 or cc or b7 or bB)and sm>0 or cg and sm<aK and q)and sb==0 and f2(cS)<85 then local sn=q5;if not cg then q5=0;sn=0 end;s2:inject(sn-cT)local so=s2:get()sl=sl+so*cH end end;bS=0;ch=bO()cg=false or ci<kv.noAtmosphericDensityAltitude and ch>0.00001;ci=(cO-kv.center):len()-kv.radius;cf=qC()bQ=bM()pP=bQ;if bo and cf>-1 and cf-3<Z then if iC.targetGroundAltitudeActivated then iC:deactivateGroundEngineAltitudeStabilization()end;iC:updateCommandFromActionStart(axisCommandId.vertical,-1)end;if cu then qo=not qo;if qo then cu.UpdateRadar()end;if E then rQ()end end;if antigrav then cQ=antigrav.isActive()==1 end;local sp=bQ-pP;local sq=-math.deg(qw(q8,cK,cH))local sr=math.deg(qw(cI,cK,cH))local gl=cM*-1;cA=cg and sq<-N or sq>N or sr<-O or sr>O;local ss=a.getMouseDeltaX()local st=a.getMouseDeltaY()if qp then local su=bM()-qp;ss=ss*su/0.016;st=st*su/0.016 end;qp=bM()if p and not c1 then st=-st end;q3=0;q4=0;q2=0;local sv=bP.getWorldPosition()kv=fS:closestBody(sv)sw=cq(kv)fo=sw:orbitalParameters(sv,cK)cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local ob=kv:getGravity(sv):len()*cj;q5=0;local sx=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if qf==0 then if iB()==1 and c1 then if not cx then c9=dq(c9+ss/2,-ac/2,ac/2)ca=dq(ca+st/2,-ad/2,ad/2)end else c9=0;ca=0 end else c9=dq(c9+ss/2,-ac/2,ac/2)ca=dq(ca+st/2,-ad/2,ad/2)dd=ds(c9*c9+ca*ca)if not c1 and iB()==0 then local kV,kW=1,1;if bK=="SCOPE"then kV,kW=d5/90,d5/90 end;if g=="virtual joystick"then if dd>az then q3=q3-dq(f2(c9)-az,0,ac/2)*utils.sign(c9)*aG*kV;q2=q2-dq(f2(ca)-az,0,ad/2)*utils.sign(ca)*aH*kW end else c9=0;ca=0;if g=="mouse"then q2=(-utils.smoothstep(st,-100,100)+0.5)*2*rY;q3=(-utils.smoothstep(ss,-100,100)+0.5)*2*rZ end end end end;local sy=cL>27777;if cL>W/3.6 and not cg and not b5 and not sy then dm("Space Speed Engine Shutoff reached")qb=0 end;if not sy and sz then if not b2 then ct.BrakeToggle()end;if b5 then ct.ResetAutopilots(1)end;qb=0 end;sz=sy;if ch>0.09 then if cL>cB/3.6 and not t and not pL then b2="SpdLmt"pL=true elseif not t and pL then if cL<cB/3.6 then b2=false;pL=false end end end;if b4 then if cc then b2=false;local sA=false;sA=qO(f_.position-cO,0.1)cz=true;if sA then qc=bN(cB)if(f2(cT)<2 or f2(cS)>85)and cL>=cB/3.6-1 then b2=false;b4=false;if cc~=2 then q1=true end;if cc==true then ce=true end;cc=false;b5=false;ct.BeginReentry()end elseif cg and t then qb=1 end elseif cL>iV then qO(vec3(cK),0.01)end end;if b3 then if cg then b3=false elseif cL>iV then qO(-vec3(cK))end end;if not b4 and cc and not bB then if not cg then if cc~=2 then q1=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not qm then qm=true end end end;if ce and f_ and(ci<bc+250 and ci>bc-250)and f2(cN)<25 and ch>=0.1 and(f_.position-cO):len()>2000+ci then if not qm then qm=true end;ce=false end;if bb then cz=true;local sB=bc;if cN<-30 then dm("Unable to achieve lift. Safety Landing.")b_=0;cz=q;bb=false;b8=true elseif not r and cQ or bc<kv.spaceEngineMinAltitude then if cQ then sB=antigrav.getBaseAltitude()end;if ci<sB-100 then q6=0;b_=15;b2=false elseif cN>0 then b2="VTO Limit"b_=0 elseif cN<-30 then b2="VTO Fall"b_=15 elseif ci>=sB then if cQ then if b5 or bs then ct.ToggleVerticalTakeoff()else b2="VTO Complete"bb=false end;dm("Takeoff complete. Singularity engaged")fO("aggLk","AG")else b2=false;dm("VTO complete. Engaging Horizontal Flight")fO("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then q6=0;b2=false;b_=20 elseif ch<0.08 and cg then b2=false;if cF then q6=0;b_=20 else b_=0;q6=36;qc=3500 end else cz=q;bB=true;cE=false;sC=false;pU=false;pS=nil;pT=nil;if pX==nil then pX=kv end;cD=sB;pW=true;bb=false end end;if q6~=nil then local sD=dq(q6-cS,-O*0.80,O*0.80)s3:inject(sD)local sE=dq(s3:get(),-1,1)q2=sE end end;if dj then local gP=dj*(bm-cO)qO(gP,0.1)end;if bB then local function sF()if not fo.apoapsis or not fo.periapsis then return false end;if fo.periapsis.altitude>=cD*0.99 and fo.apoapsis.altitude>=cD*0.99 and fo.periapsis.altitude<fo.apoapsis.altitude and fo.periapsis.altitude*1.05>=fo.apoapsis.altitude and f2(cD-ci)<1000 then return true else return false end end;local qV;local sG=false;local sH=iG(cD,4)if pX==nil then pX=kv;if bs then pX=c8 end end;if not pW then cD=bN(pX.radius+pX.surfaceMaxAltitude+U)if pX.hasAtmosphere then cD=bN(pX.radius+pX.noAtmosphericDensityAltitude+U)end;pW=true end;if q7.VectorToTarget and f_ then qV=f_.position-cO end;local sI,sJ=cq(pX):escapeAndOrbitalSpeed((cO-pX.center):len()-pX.radius)sJ=sJ*3.6+1+(K and aZ*sJ*3.6 or 0)local sK=cT;if not pU then local sL=false;local sM=false;qb=0;pT=0;cC="Aligning to orbital path - OrbitHeight: "..sH;if q7.VectorToTarget then qO(qV:normalize():project_on_plane(cM))sG=cH:dot(qV:project_on_plane(q8):normalize())>0.95 else qO(cK)sG=sq<0.5;if cL<150 then sG=true end end;q2=0;pS=0;if cS<=pS+2 and cS>=pS-2 then sL=true else sL=false end;if sK<=pT+2 and sK>=pT-2 then sM=true else sM=false end;if sL and sM and sG then pS=nil;pT=nil;pU=true end else if q7.VectorToTarget then qO(qV:normalize():project_on_plane(cM))elseif cL>150 then qO(cK)end;q2=0;if q7.VectorToTarget and f_ then local c6,dU=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bu)if cE and qV:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pX.noAtmosphericDensityAltitude or ls>fo.timeToPeriapsis and fo.periapsis.altitude<pX.noAtmosphericDensityAltitude or not sF()and fo.eccentricity>0.1 then dm("Re-Aligning Orbit")cE=false end elseif cE or qV:len()<15000+c6+ci then dm("Orbit complete, proceeding with reentry")fO("orCom","OB")bm=f_.position;q1=true;ce=true;q7.VectorToTarget,q7.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if pV or fo.periapsis~=nil and fo.apoapsis~=nil and fo.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if fo.apoapsis~=nil or pV then if(sF()or cE)and not K then if cE then b2=false;qb=0;pS=0;if not q7.VectorToTarget then dm("Orbit complete")fO("orCom","OB")ct.ToggleIntoOrbit()end else pY=pY+1;if pY>=2 then cE=true end end else if sF()then cC="Maintaining "else cC="Adjusting "pV=true;qc=sJ;local sN=cD-ci;s0:inject(sN-cN*dq(utils.smoothstep(2000-sN,-2000,2000)^6*10,1,10))pS=dq(s0:get(),-75,75)end;cC=cC.." - OrbitHeight: "..sH end end else local sO=2.75;local sP=f2(fP(sI*sO))local oo=sP%50;if oo>0 then sP=sP-oo+50 end;b2=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sH;pS=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sH;sP=sP*0.75;pS=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sH;sP=sP*0.75;if cN<0 or pV then pS=utils.map(ci,cD*1.5,cD*1.01,-30,0)else pS=utils.map(ci,cD*0.99,cD*1.5,0,30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sH;pS=-65;local sQ=utils.map(cN,-150,-400,1,0.55)sP=sP*sQ end;qc=bN(sP)end end;if pS~=nil then local sR=pS-cS;s1:inject(sR)local sS=dq(s1:get(),-0.5,0.5)q2=sS end end;if b5 and not cg and not cc then local function sT(sU,fo)a.print(sU)b4=false;b2=false;bf=false;b5=false;r6=false;bi="Aligning"qb=0;q0=false;dm(sU)fO("apCom","AP")if fo or cc then if fo and gj~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pW=true end;ct.ToggleIntoOrbit()end end;local sV,sW=bm,false;if f_ and f_.planetname~="Space"then be=true;if not r6 then local sX=(f_.position-c8.center):normalize()local sY=sX:project_on_plane((c8.center-cO):normalize()):normalize()local sZ=c8.center+sY*(c8.radius+gj)local s_=f_.position+(f_.position-c8.center):normalize()*(gj-c8:getAltitude(f_.position))if(cO-sZ):len()<(cO-s_):len()then sV=sZ else sV=s_;bh=0 end;bm=sV;ct.showWayPoint(c8,bm)sW=true;r6=true end;bj=0 elseif f_ and f_.planetname=="Space"then if not r6 then bj=0;sW=true;be=true;r6=true;sV=f_.position+(cO-f_.position):normalize()*S;bm=sV end elseif f_==nil then bj=0;if not r6 then local sX=(cO+cK*100000-c8.center):normalize()local sY=sX:project_on_plane((c8.center-cO):normalize()):normalize()if sY:len()<1 then sX=(cO+cH*100000-c8.center):normalize()sY=sX:project_on_plane((c8.center-cO):normalize()):normalize()end;sV=c8.center+sY*(c8.radius+gj)bm=sV;r6=true;sW=true;be=true;ct.showWayPoint(c8,bm)end end;rn=(vec3(sV)-cO):len()local lq,eN,eO=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(ew)if ew.noAtmosphericDensityAltitude>0 then return ew.radius+ew.noAtmosphericDensityAltitude else return ew.radius+ew.surfaceMaxAltitude*1.5 end end)local lr=eN;if eO~=nil and eN~=nil then lr=math.min(eO,eN)end;if lr~=nil and lr<rn and lq.name==c8.name then rn=lr end;local sA=true;local t0=(c8.center-(cO+vec3(cK):normalize()*rn)):len()-c8.radius;local ln=iG(t0)qj=gb;qk='{"label": "Projected Altitude", "value": "'..ln..'"}'if cL>50 and bd then local qV=vec3(sV)-cO;local t1=dq(math.deg(qw(q8,cK:normalize(),qV:normalize()))*cL/500,-90,90)local t2=dq(math.deg(qw(cI,cK:normalize(),qV:normalize()))*cL/500,-90,90)if f2(t1)<20 and f2(t2)<20 then t1=t1*2;t2=t2*2 end;if f2(t1)<2 and f2(t2)<2 then t1=t1*2;t2=t2*2 end;local sq=-math.deg(qw(q8,cH,cK:normalize()))local sr=-math.deg(qw(cI,cH,cK:normalize()))s4:inject(t2-sr)local t3=dq(s4:get(),-1,1)q2=q2+t3;s5:inject(t1-sq)local t4=dq(s5:get(),-1,1)q3=q3+t4;sW=true;if f2(t1)>2 or f2(t2)>2 then if bi~="Adjusting Trajectory"then bi="Adjusting Trajectory"fO("apAdj","AP")end else if bi~="Accelerating"then bi="Accelerating"fO("apAcc","AP")end end elseif bd and cL<=50 then qO((sV-cO):normalize())end;if t0<gj*1.5 then bh=cB/3.6;if f_==nil then dU,bh=cq(c8):escapeAndOrbitalSpeed(t0)end end;local c6,c7;if not b6 then c6,c7=qs(cL)else c6,c7=qv(cL)end;if b5 and not bd and not bg and not bf then local lq,lr=ct.checkLOS((bm-cO):normalize())if c8.name~=kv.name then if lq~=nil and c8.name~=lq.name and lr<rn then cZ="Attempting to clear LOS between "..lq.name.." and waypoint."qg=true else qg=false;cZ=false end end end;if not qg then if not bg and not bf and not sW then sA=qO((sV-cO):normalize())elseif b6 and(bf or bg)then sA=qO(-vec3(cK):normalize())end end;if bd then if not q0 then b2=false;qb=a1;bR=fP(a1,2)q0=true end;local ro=c.getThrottle()if t then ro=bR end;local t5=99999;local om=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local t6=dq(cK:dot((sV-cO):normalize()),0,cL)if t6>0 or om>0 then t5=cp.computeTravelTime(t6,om,rn-c6)end;if a0>df then a0=df-0.2 end;if cJ:len()>=a0 or ro==0 and q0 or a2/4>t5 then bd=false;if bi~="Cruising"then fO("apCru","AP")bi="Cruising"end;bg=true;qb=0 end;local t7=rn;if t7<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV and not sy then if cW<pM and cW>2000 then ct.ResetAutopilots(1)dm("Autopilot cancelled to prevent crossing PvP Line")b2="PvP Prevent"pM=cW else pM=cW;return end end;bd=false;if bi~="Braking"then fO("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cz=true end;qb=0;q0=false end elseif bf then if bi~="Orbiting to Target"then b2="AP Brk"end;if b6 then qb=1;qd=true end;local dU,sJ=cq(c8):escapeAndOrbitalSpeed((cO-kv.center):len()-kv.radius)local qV;if f_ then qV=f_.position-cO end;if f_ and f_.planetname=="Space"and cL<50 then if#bH>0 then if not qm then table.remove(bH,1)end;if#bH>0 then b2=false;if not qm then qm=2 end;return end end;sT("Autopilot complete, arrived at space location")b2="Space Arrival"elseif f_ and f_.planetname~="Space"and cL<=sJ and(fo.apoapsis==nil or fo.periapsis==nil or fo.apoapsis.altitude<=0 or fo.periapsis.altitude<=0)then sT("Autopilot complete, commencing reentry")bm=f_.position;cc=true;ct.showWayPoint(c8,bm)elseif(f_ and f_.planetname~="Space"or f_==nil)and fo.periapsis~=nil and fo.periapsis.altitude>0 and fo.eccentricity<1 or bi=="Circularizing"then if bi~="Circularizing"then fO("apCir","AP")bi="Circularizing"end;if cL<=sJ then if f_ then if cK:normalize():dot(qV:normalize())>0.4 then if bi~="Orbiting to Target"then fO("apOrb","OB")bi="Orbiting to Target"end;if not r8 then b2=false;ct.showWayPoint(c8,f_.position)r8=true end else sT("Autopilot complete, proceeding with reentry")bm=f_.position;cc=true;ct.showWayPoint(c8,f_.position)r8=false end else sT("Autopilot completed, setting orbit",true)b2=false end end elseif bi=="Circularizing"then sT("Autopilot complete, fixing Orbit",true)end elseif bg then local t7=rn;if t7<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pM and cW>2000 then if not qm then qm=true end;dm("Autopilot cancelled to prevent crossing PvP Line")b2="Prevent PvP"pM=cW else pM=cW;return end end;bd=false;if bi~="Braking"then fO("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cz=true end end;local ro=c.getThrottle()if t then ro=bR end;if ro>0 then bd=true;if bi~="Accelerating"then bi="Accelerating"fO("apAcc","AP")end;bg=false end else if sA then if not be and f_==nil or not be and f_ and f_.planetname~="Space"then if not cc then bm=vec3(c8.center)+(gj+c8.radius)*cI;t8=q8;t9=cI end;be=true elseif sA and not qg then bd=true;if bi~="Accelerating"then bi="Accelerating"fO("apAcc","AP")end;if not q0 then qb=a1;qd=true;bR=fP(a1,2)q0=true;b2=false end end end end elseif b5 and(f_~=nil and f_.planetname~="Space"and cg)then dm("Autopilot complete, starting reentry")fO("apCom","AP")bm=f_.position;b2=false;bf=false;b5=false;r6=false;bi="Aligning"qb=0;q0=false;b4=true;cc=true;ct.showWayPoint(c8,f_.position)end;if c0 then cz=true;local t2=0;local fq=vec3(DUPlayer.getWorldPosition())local ta=fq-cO;local tb=vec3(ta):project_on(cH):len()local tc=vec3(ta):project_on(cI):len()local cb=ds(tb*tb+tc*tc)qO(ta:normalize())local mt=40;local td=cb<mt;local te=100;local rB=dq((cb-mt)/2,10,te)q2=0;local sA=f2(q3)<0.1;if sA and cL<rB and not td then b2=false;t2=-20 else b2="Follow"t2=0 end;local tf=0;if f2(t2-cS)>tf then s6:inject(t2-cS)local t3=s6:get()q2=t3 end end;if b7 or b8 or ba or bs or bv~=nil then local tg=bw;if tg then tg=tg*dq(cL/100,0.1,1)*ch else tg=bu end;if not cg then tg=bu end;qa=cH:project_on_plane(cM):normalize():dot(cK)if qa>100 then c6,c7=cp.computeDistanceAndTime(qa,100,cj,0,0,tg)local th,dU=cp.computeDistanceAndTime(100,0,cj,0,0,tg*0.55)c6=c6+th else c6,c7=cp.computeDistanceAndTime(qa,0,cj,0,0,tg*0.55)end;local sN=bc-ci-cN;local ti=200+cL;if ba or cc then tj=2000+cL end;local tk=1;if b9 then tk=dq(cL/100,0.1,1)end;local t2=(utils.smoothstep(sN,-ti,ti)-0.5)*2*Q*tk;if not ba and not cc and not bs and cH:dot(cK:normalize())<0.99 then t2=(utils.smoothstep(sN,-ti*dq(20-19*ch*10,1,20),ti*dq(20-19*ch*10,1,20))-0.5)*2*Q*dq(2-ch*10,1,2)*tk end;if not b7 then t2=0 end;if bv~=nil then if cY and not bB then t2=bv else bv=nil end end;cz=true;local tl=q2;if ba then local tm=bN(cB)local tn,to=cp.computeDistanceAndTime(cL,tm/3.6,cj,0,0,bu-kv.gravity*9.8*cj)tn=tn==-1 and 5000 or tn;local r7=ci-(kv.noAtmosphericDensityAltitude+tn)local tp=ci>kv.noAtmosphericDensityAltitude+tn*1.35;if tp then t2=R;if cL<=tm/3.6 and cL>tm/3.6-10 and f2(cK:normalize():dot(cH))>0.9 and not cR then bV=false;qb=1 end elseif(cR or iC:getTargetSpeed(axisCommandId.longitudinal)~=tm)and not tp and not cg then qc=tm;qd=true end;if cR then if cL>tm/3.6 and not tp then b2="Reentry Limit"if bR>0 then qb=0 end else b2=false end else b2=false end;if cN>0 then b2="Reentry vSpd"end;if not q1 then t2=-80;if ci<kv.surfaceMaxAltitude+(kv.atmosphereThickness-kv.surfaceMaxAltitude)*0.25 then dm("PARACHUTE DEPLOYED at "..fP(ci,0))ba=false;b8=true;qZ=true;qb=0;t2=0;cz=q end elseif kv.noAtmosphericDensityAltitude>0 and tp then cz=true elseif not tp then if not cg and(cR or iC:getTargetSpeed(axisCommandId.longitudinal)~=tm)then qc=tm end;if cL<tm/3.6+1 then b2=false;q1=false;ba=false;cz=true;qb=1 end end end;if cL>iV and not cd and not bs and not b8 and u then qO(vec3(cK))end;if cX or(bs or cd)and bn>0 and cg then local qV;if cX then if type(cX)=="table"then qV=cX elseif cX<3 and cX>0 then qV=-cM:cross(cK)*5000 elseif cX>=3 then qV=cM:cross(cK)*5000 elseif cX<0 then qV=cK*25000 end elseif f_~=nil then qV=f_.position-cO else qV=c8.center-cO end;local t1=math.deg(qw(cM:normalize(),cK,qV))*2;local mw=math.rad(f2(cT))if cL>aL and cg then local tq=1000+cL;local tr=(utils.smoothstep(sN-cN*10,-tq,tq)-0.5)*2*Q;local ts=dq(90-tr,0,180)q5=dq(t1*2,-ts,ts)local tt=t1;t1=dq(dq(t1,-N*0.80,N*0.80)*math.cos(mw)+4*(cS-t2)*math.sin(math.rad(cT)),-N*0.80,N*0.80)local tu=1;if q5~=0 then tu=f2(mw/q5)end;tu=(90-dq(f2(q5-cT),0,90))/90;local tv=t2;if f2(cT)>90 then tv=-tv end;t2=tu*dq(dq(tv*math.cos(mw),-O*0.8,O*0.8)+f2(dq(f2(tt)*math.sin(mw),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q5=0;t1=dq(t1,-N*0.80,N*0.80)end;local tw=sq-t1;if cX and f2(tw)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and f2(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fO("180Off","BR")return end;if not cA and cL>aL and cg then s7:inject(tw)local t4=dq(s7:get(),-1,1)q3=q3+t4 elseif cg and cf>-1 or cL<aL then qO(qV)elseif cA and cg then if(sq<-N or sq>N)and cg then qO(cK)end;if(sr<-O or sr>O)and cg then t2=dq(cS-sr,cS-O*0.80,cS+O*0.80)end end;if f_~=nil and not cd then local sB=kv:getAltitude(f_.position)local r7=qV:project_on_plane(cM):len()qZ=true;if bc<kv.noAtmosphericDensityAltitude and not cd and not b9 and not ba and(r7<=c6 and qV:len()<kv.radius)and(cK:project_on_plane(cM):normalize():dot(qV:project_on_plane(cM):normalize())>0.99 or lu=="Finalizing Approach")then lu="Finalizing Approach"if#bH>0 then if not qm then table.remove(bH,1)end;if#bH>0 then if not qm then qm=2 end;return end end;qb=0;if b7 then ct.ToggleAltitudeHold()bs=true end;b2="AP Finalizing"elseif not b9 then b2=false end;if lu=="Finalizing Approach"and(qa<0.1 or r7<0.1 or tx~=nil and tx<r7)then fO("bklOn","BL")b8=true;db=true;if f_.heading then dc=f_.heading else dc=nil end;bs=false;lu="Proceeding to Waypoint"cZ=false end;tx=r7 end elseif bs and not cg and bc>kv.noAtmosphericDensityAltitude and not(cd or ba)then if f_~=nil and c8.name==kv.name then local qV=f_.position-cO;local sB=kv:getAltitude(f_.position)local r7=ds(qV:len()^2-(ci-sB)^2)local tg=bw;if tg then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,tg/2)qZ=true;if r7<=c6+cL*sp/2 and cK:project_on_plane(cM):normalize():dot(qV:project_on_plane(cM):normalize())>0.99 then if kv.hasAtmosphere then b2=false;b4=false;q1=true;cc=false;ce=true;b5=false;ct.BeginReentry()end end;tx=r7 end end end;if not cg and cf==-1 and(b7 and bc>kv.noAtmosphericDensityAltitude)and not(cd or bB or ba)then if not cE and not bB then cD=bc;pW=true;if bs then q7.VectorToTarget=true end;ct.ToggleIntoOrbit()bs=false;pU=true end end;if cA and cg and cf==-1 and cL>aL and lu~="Finalizing Approach"then qO(cK)t2=dq(cS-sr,cS-O*0.80,cS+O*0.80)end;q2=tl;local qH=-1;if b8 then local ty=aY or 0.05;if not qh then r_=false;if not cR then qb=0 end;if cf==-1 then iC:setTargetGroundAltitude(500)iC:activateGroundEngineAltitudeStabilization(500)end;if not cg then r_=true end;qh=true end;t2=0;local tz=false;local tA=math.abs(qa)if not r and cQ then tz=antigrav.getBaseAltitude()if tz<kv.surfaceMaxAltitude and f_==nil or f_~=nil and kv:getAltitude(f_.position)>tz then tz=false end else tz=false end;if dc then if tA<ty then if cN>-P then b2=false else b2="BL Align BLR"end;if qO(dc,0.001)then dc=nil;cz=q else q2=0;cz=true end else b2="BL Align Hzn"end;if tz and f2(ci-tz)<250 then b2="AGG Align"end else local tB=false;local tC=30;if tA<10 and sx~=nil and sx>0 then local tD=dq(ch,0.4,2)local tg=bw*dq(cL/100,0.1,1)*tD;local tE=sx*tD+tg-ob;local tF=tg/2-ob;local tG=cL-ds(f2(tF/2)*20/(0.5*cj))*utils.sign(tF)if tG<0 then tG=0 end;local tH;if cL>100 then local tI,dU=cp.computeDistanceAndTime(cL,100,cj,0,0,tg)local tJ,dU=cp.computeDistanceAndTime(100,0,cj,0,0,ds(tg))tH=tI+tJ else tH=cp.computeDistanceAndTime(cL,0,cj,0,0,ds(tg))end;if tH<20 then b2=false else local tK=0;if tG>100 then local tL,dU=cp.computeDistanceAndTime(tG,100,cj,0,0,tE)local tM,dU=cp.computeDistanceAndTime(100,0,cj,0,0,sx*tD+ds(tg)-ob)tK=tL+tM else tK,dU=cp.computeDistanceAndTime(tG,0,cj,0,0,sx*tD+ds(tg)-ob)end;tK=(tK+15+cL*sp)*1.1;local tN=db and f_~=nil and kv:getAltitude(f_.position)>0 and f_.safe;local sB=nil;if tz and tz<ci then sB=tz elseif tN then sB=kv:getAltitude(f_.position)+250 elseif ci>kv.surfaceMaxAltitude then sB=kv.surfaceMaxAltitude end;if c_ then local tO=kv:getAltitude(c_[1].center)if sB then if tO>sB then sB=tO end else sB=tO end end;if sB~=nil then local tP=ci-sB;tB=true;if tP<=tK or tK==-1 or tA>ty and db then if sB==kv.surfaceMaxAltitude and cN<-P then b2="BL Stop BLR"elseif tA>ty and db then b2="BL AP Hzn"else b2="BL Stop Dist"end else b2=false end end end end;qH=cf;if qH>-1 then b2=false;if not tz and not bo then qe=true;iC:setTargetGroundAltitude(Z)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qH-3<Z and(bD or cL==0)then b8=false;b7=false;b_=0;q_(0,1)b2="BL Complete"cz=q;db=false;qh=false else if cN<-5 or tA>ty*10 then q_(0,1)b2="BL Slowing"else b2=false;q_(-1)end end elseif not tB then if qZ and cK:normalize():dot(-gl)<0.999 then b2="BL Strong"qO()elseif tA>10 or tA>ty and db then b2="BL hSpd"elseif cN<-P then b2="BL BLR"q_(0,1)else q_(-1)b2=false end end end else qh=false end;if b9 or cd then local lq,eO,eN;if bm~=nil then lq,eO,eN=co:getPlanetarySystem(0):castIntersections(cO,(bm-cO):normalize(),function(ew)if ew.noAtmosphericDensityAltitude>0 then return ew.radius+ew.noAtmosphericDensityAltitude else return ew.radius+ew.surfaceMaxAltitude*1.5 end end)end;if lq~=nil then if lq.name~=c8.name and not cg then cZ="Clearing LOS between "..lq.name.." and waypoint."end end;if cQ and not cd then if ci>=bc-50 and cL>iV then b9=false;if not b5 and not bs then b2="ATO Agg Arrive"qb=0 end end elseif f2(t2)<15 and ci/bc>0.75 then b9=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<iV then b5=true;cd=false;b7=false;b9=false;qb=0 elseif cd then qb=0;b2="ATO Space"end elseif cd and not cg and c8~=nil and(lq==nil or lq.name==c8.name)then b5=true;cZ=false;cd=false;b7=false;b9=false;if not cR then qb=0 end;bd=true end end;local tQ=cf>-1;local tR=cS;if(bs or cd or cX)and not tQ and cL>aL and cg then local mw=math.rad(f2(cT))tR=cS*f2(math.cos(mw))+sr*math.sin(mw)end;local tS=dq(t2-tR,-O*0.80,O*0.80)if not cg and bs then tS=dq(t2-tR,-85,Q)elseif not cg then tS=dq(t2-tR,-Q,Q)end;if f2(cT)<5 or bs or cX or b8 or tQ or b7 then s6:inject(tS)local t3=s6:get()q2=q2+t3 end end;if antigrav~=nil and(antigrav and not r and ci<200000)then if bx==nil or bx<1000 then bx=1000 end;if tT~=bx then tT=bx;ql=tT end end;if(cg or ba or ce)and t and cR then local tU=0;if aU>0 and not ba and ch>0.005 and ch<0.1 and cN>-50 then local tV=bP.getFrictionBurnSpeed()*aU;local tW=cB/3.6;if tV>tW then tU=tV-tW-1 end end;s8:inject(cB/3.6+tU-cK:dot(cH))local tX=s8:get()bU=dq(tX,-1,1)if not d7 then if bU<bR and(ch>0.005 or ba or ce)then bT=true;d7=dq(bU,0.01,1)else bT=false;d7=bR end end;s9:inject(cK:len()-cB/3.6-tU)local tY=dq(s9:get(),0,1)if cg and cN<-80 or(ch>0.005 or ba or ce)then bS=tY end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dq(bU,0.01,1)end;local tZ=''local t_=vec3()local u0=rz(axisCommandId.vertical,b_*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",u0,rW)local u1='thrust analog longitudinal 'if bE=="All"or bE=="Longitude"then u1=u1 ..aV end;local u2=iC:getAxisCommandType(axisCommandId.longitudinal)local u3=iC:composeAxisAccelerationFromThrottle(u1,axisCommandId.longitudinal)local u4=rM(axisCommandId.lateral,bA*1000)tZ=tZ..' , '.."lateral airfoil , lateral ground "t_=t_+u4;if t_:len()>constants.epsilon then d:setEngineForceCommand(tZ,t_,rW,'','','',rX)end;d:setEngineForceCommand(u1,u3,rV)local u5='thrust analog vertical fueled 'local u6='thrust analog lateral fueled 'if bE=="All"or bE=="Lateral"then u6=u6 ..aW end;if bE=="All"or bE=="Vertical"then u5=u5 ..aX end;if b_~=0 or b8 and b2 or not bo and not bD then d:setEngineForceCommand(u5,u0,rV)else d:setEngineForceCommand(u5,vec3(),rV)end;if bA~=0 then d:setEngineForceCommand(u6,u4,rV)else d:setEngineForceCommand(u6,vec3(),rV)end;if sd==0 then sd=bS end;local u7=-sd*(aQ*cK+aR*sh)d:setEngineForceCommand('brake',u7)else if t then if not d7 then d7=bR end end;local rB=c.getAxisCommandValue(0)if not cR then s9:inject(cK:len()-rB/3.6)local tY=dq(s9:get(),0,1)sd=dq(sd+tY,0,1)end;local u7=-sd*(aQ*cK+aR*sh)d:setEngineForceCommand('brake',u7)local tZ=''local t_=vec3()local u8=false;local u1='thrust analog longitudinal 'if aV~="none"and(bE=="All"or bE=="Longitude")then u1=u1 ..aV end;local u2=iC:getAxisCommandType(axisCommandId.longitudinal)if u2==axisCommandType.byThrottle then local u3=iC:composeAxisAccelerationFromThrottle(u1,axisCommandId.longitudinal)d:setEngineForceCommand(u1,u3,rV)elseif u2==axisCommandType.byTargetSpeed then local u3=iC:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tZ=tZ..' , '..u1;t_=t_+u3;if iC:getTargetSpeed(axisCommandId.longitudinal)==0 or iC:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iC:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u8=true end end;local u6='thrust analog lateral 'if aW~="none"and(bE=="All"or bE=="Lateral")then u6=u6 ..aW end;local u9=iC:getAxisCommandType(axisCommandId.lateral)if u9==axisCommandType.byThrottle then local ua=iC:composeAxisAccelerationFromThrottle(u6,axisCommandId.lateral)d:setEngineForceCommand(u6,ua,rV)elseif u9==axisCommandType.byTargetSpeed then local u4=iC:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tZ=tZ..' , '..u6;t_=t_+u4 end;local u5='thrust analog vertical 'if aX~="none"and(bE=="All"or bE=="Vertical")then u5=u5 ..aX end;local ub=iC:getAxisCommandType(axisCommandId.vertical)if ub==axisCommandType.byThrottle then local u0=iC:composeAxisAccelerationFromThrottle(u5,axisCommandId.vertical)if b_~=0 or b8 and b2 then d:setEngineForceCommand(u5,u0,rV,'airfoil','ground','',rX)else d:setEngineForceCommand(u5,vec3(),rV)d:setEngineForceCommand('airfoil vertical',u0,rV,'airfoil','','',rX)d:setEngineForceCommand('ground vertical',u0,rV,'ground','','',rX)end elseif ub==axisCommandType.byTargetSpeed then if b_<0 then d:setEngineForceCommand('hover',vec3(),rV)end;local uc=iC:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tZ=tZ..' , '..u5;t_=t_+uc end;if t_:len()>constants.epsilon then if sd~=0 or u8 or f2(sh:dot(cH))<0.5 then tZ=tZ..', brake'end;d:setEngineForceCommand(tZ,t_,rW,'','','',rX)end end;local ud=aN*(sl-sk)local ue=vec3(bP.getWorldAirFrictionAngularAcceleration())ud=ud-ue;d:setEngineTorqueCommand('torque',ud,rV,'airfoil','','',rX)d:setBoosterCommand('rocket_engine')if c5 and not o then local kk=cJ:len()local uf=0.15;if not cR then local ug=iC:getTargetSpeed(axisCommandId.longitudinal)if kk*3.6>ug*(1-uf)and uh then uh=false;d:toggleBoosters()elseif kk*3.6<ug*(1-uf)and not uh then uh=true;d:toggleBoosters()end else local ro=c.getThrottle()if t then ro=bR*100 end;local rB=ro/100;if not cg then rB=rB*a0;if kk>=rB*(1-uf)and uh then uh=false;d:toggleBoosters()elseif kk<rB*(1-uf)and not uh then uh=true;d:toggleBoosters()end else local tm=bN(cB)rB=rB*tm/3.6;if kk>=rB*(1-uf)and uh then uh=false;d:toggleBoosters()elseif kk<rB*(1-uf)and not uh then uh=true;d:toggleBoosters()end end end end end;if ui then for dP,dB in pairs(ui)do pK[dP]=dB end end;cf=qC()return pK end;local function uj(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uk,iB,iC,iD,ul,gG,fP,e8,dr,dq,fO,iF,pJ,dm,um,un)local bP=DUConstruct;local uo={}local up=true;local uq=5;local ur=5;local us=uq;local ut=ur;local uu=bQ;local uv=bQ;function uo.landingGear(qe)bo=not bo;if bo then if b5 or bs or cd or bB then ct.ResetAutopilots(true)end;bv=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not qe and cf==-1 then fO("bklOn","BL")qZ=true;ba=false;b9=false;bb=false;if b8 then db=not db end;cz=true;bo=false;b8=true else if bW then fO("grOut","LG",1)d.control.deployLandingGears()end;db=false;if cg then cz=q;b2="Landing"end end;if qe or cf~=-1 and cf>Z-3 or not bD then b8=true end;iC:activateGroundEngineAltitudeStabilization(r2)iC:setTargetGroundAltitude(Z)b7=false elseif bW and not b8 then fO("grOut","LG",1)d.control.deployLandingGears()end else if b8 then b8=false end;if bW then fO("grIn","LG",1)d.control.retractLandingGears()end;iC:activateGroundEngineAltitudeStabilization(r2)if bD then if Z<iC.targetGroundAltitude then iC:setTargetGroundAltitude(iC.targetGroundAltitude)else iC:setTargetGroundAltitude(Y)end else iC:setTargetGroundAltitude(Y)end end end;function uo.startControl(uw)local function ux(rj)local rk=1;local function uy(uz,rj)local uA={kv.surfaceMaxAltitude+100,kv.spaceEngineMinAltitude-0.01*kv.noAtmosphericDensityAltitude,kv.noAtmosphericDensityAltitude+U,kv.radius*(T-1)+kv.noAtmosphericDensityAltitude}local uB=uz;for dU,dB in ipairs(uA)do if rj and uB>dB then uz=dB elseif uz<dB and not rj then uz=dB;break end end;return uz end;if rj then rk=-1 end;if not r and cQ then if c1 and rj then bx=1000 elseif bx~=nil then bx=bx+rk*ur;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end else bx=tT+rk*100 end elseif b7 or bb or bB then if bB then if c1 then cD=uy(cD,rj)else cD=cD+rk*uq end;if cD<kv.noAtmosphericDensityAltitude then cD=kv.noAtmosphericDensityAltitude end else if c1 and cg then bc=uy(bc,rj)else bc=bc+rk*uq end end else iC:updateTargetGroundAltitudeFromActionStart(rk*1.0)end end;local function uC(uD)if not cg then dm("Flight Assist in Atmo only")return end;local dy=type(uD)if cX==nil then if dy=="table"then if b5 or bs then ct.ToggleAutopilot()end;fO("180On","BR")elseif uD==1 then fO("bnkLft","BR")else fO("bnkRht","BR")end;if not b7 and not b5 and not bs then ct.ToggleAltitudeHold()if dy~="table"then uD=uD+1 end end;cX=uD else fO("180Off","BR")cX=nil end end;local function uE()if iD()==1 then c9=0;ca=0;ul(bk)elseif iB()==1 and y then cy=false;cx=false end;c1=false end;if uw=="gear"then cv.landingGear()elseif uw=="light"then if p7 then if iB()==1 then if DUPlayer.isFrozen()==1 then DUPlayer.freeze(0)dm("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(1)dm("Player Frozen, pitch/yaw/roll enabled")end else dm("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uw=="forward"then if p7 and not cg and not b5 then b4=not b4;b3=false else bX=bX-1 end elseif uw=="backward"then if p7 then if not cg then if not b5 then b3=not b3;b4=false else b6=not b6 end else uC(-cK*5000)end else bX=bX+1 end elseif uw=="left"then if p7 then uC(1)else bY=bY-1 end elseif uw=="right"then if p7 then uC(3)else bY=bY+1 end elseif uw=="yawright"then bZ=bZ-1;dc=nil elseif uw=="yawleft"then bZ=bZ+1;dc=nil elseif uw=="straferight"then iC:updateCommandFromActionStart(axisCommandId.lateral,1.0)bA=1 elseif uw=="strafeleft"then iC:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bA=-1 elseif uw=="up"then ct.vertical(1)if cf-3<Z and ci>0 and bo then cv.landingGear()end elseif uw=="down"then ct.vertical(-1)elseif uw=="groundaltitudeup"then ux()elseif uw=="groundaltitudedown"then ux(true)elseif uw=="option1"then uF=false;if p7 and c1 then local uG=""for M=1,#d2 do uG=uG.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fP(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..uG)return end;cs.adjustAutopilotTargetIndex()elseif uw=="option2"then uF=false;if p7 and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;dm("Deboarded All Passengers")return end;cs.adjustAutopilotTargetIndex(1)elseif uw=="option3"then uF=false;if p7 and c1 then local uG=""for M=1,#d3 do uG=uG.."| ID: "..d3[M].." Mass: "..fP(bP.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..uG)return end;if x then if w then w=false else w=true end;if cu then cu.ToggleRadarPanel()end end elseif uw=="option4"then uF=false;if p7 and c1 then for M=1,#d3 do bP.forceUndock(d3[M])end;dm("Undocked all ships")return end;cX=nil;ct.ToggleAutopilot()elseif uw=="option5"then uF=false;if p7 and c1 then dj=false;ct.ToggleLockPitch()return end;if bQ-uv<1.5 then if dj then dj=-1;dm("Retrograde Alignment lock to "..bl)return end end;uv=bQ;if dj then dj=false;dm("Alignment cancelled")elseif not b5 and not bs and not cd and not bB and not ba and not ce and not b7 then dj=1;dm("Alignment lock to "..bl)else dm("Disengage autopilot before using Alignment Lock")end elseif uw=="option6"then uF=false;if p7 and c1 then if shield then cw.ventShield()else dm("No shield found")end;return end;ct.ToggleAltitudeHold()elseif uw=="option7"then uF=false;if p7 and c1 then if shield then shield.toggle()return else dm("No shield found")return end end;E=not E;if E then dm("Collision System Enabled")else dm("Collision System Secured")end elseif uw=="option8"then uF=false;if p7 and c1 then if bn>0 and f_~=nil then ct.routeWP()else dm("Select a saved wp on IPH to add to or remove from route")end;return end;bD=not bD;if not bD then dm("DeCoupled Mode - Ground Stabilization off")iC:deactivateGroundEngineAltitudeStabilization()fO("gsOff","GS")else dm("Coupled Mode - Ground Stabilization on")iC:activateGroundEngineAltitudeStabilization(r2)de=true;fO("gsOn","GS")end elseif uw=="option9"then uF=false;if p7 and c1 then iC:resetCommand(axisCommandId.longitudinal)iC:resetCommand(axisCommandId.lateral)iC:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()==1;if ck then fO("gyOn","GA")else fO("gyOff","GA")end else dm("No gyro found")end elseif uw=="lshift"then if p7 then c1=true end elseif uw=="brake"then if b0 or p7 then ct.BrakeToggle("Manual")elseif not b2 then ct.BrakeToggle("Manual")else b2="Manual"end elseif uw=="lalt"then uF=true;p7=true;if iB()==0 and not j and g=="keyboard"then ul(1)end elseif uw=="booster"then if p7 then if um then um.toggle()if um.isActive()==1 then dm("Transponder On")else dm("Transponder Off")end else dm("No transponder found")end else if o then d:toggleBoosters()elseif not c5 then if not uh then d:toggleBoosters()uh=true end;c5=true else if uh then d:toggleBoosters()uh=false end;c5=false end end elseif uw=="stopengines"then local function uH()if bQ-uu<1.5 then fO("clear","CA")ct.clearAll()end end;uH()uu=bQ;if iC:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p7 then if cB>0 then cB=0 else cB=V end elseif bR~=0 then iC:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iC:getTargetSpeed(axisCommandId.longitudinal)~=0 then iC:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(a0*3.6)end end end elseif uw=="speedup"then ct.changeSpd()elseif uw=="speeddown"then ct.changeSpd(true)elseif uw=="antigravity"and not r then if antigrav~=nil then ct.ToggleAntigrav()else dm("No antigrav found")end elseif uw=="leftmouse"then c2=true;if c1 then uE()uF=false else c1=true;bk=iD()ul(1)end end end;function uo.stopControl(uw)local function uI()if not r and cQ then ut=ur end;if b7 or bb or bB then us=uq end end;if uw=="forward"then bX=0 elseif uw=="backward"then bX=0 elseif uw=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif uw=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif uw=="yawright"then bZ=0 elseif uw=="yawleft"then bZ=0 elseif uw=="straferight"then iC:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bA=0 elseif uw=="strafeleft"then iC:updateCommandFromActionStop(axisCommandId.lateral,1.0)bA=0 elseif uw=="up"then ct.vertical(0,-1)elseif uw=="down"then ct.vertical(0,1)elseif uw=="groundaltitudeup"then uI()uF=false elseif uw=="groundaltitudedown"then uI()uF=false elseif uw=="brake"then if not b0 and not p7 then if b2 then ct.BrakeToggle()else b2=false end end elseif uw=="lalt"then if c1 then c1=false end;if iB()==0 and j then if uF then if iD()==1 then ul(0)else ul(1)end else uF=true end elseif iB()==0 and not j and g=="keyboard"then ul(0)end;p7=false end end;function uo.loopControl(uw)local function uJ(rj)local rk=1;if rj then rk=-1 end;if not r and cQ then if bx~=nil then bx=bx+rk*ut;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end;ut=dq(ut*1.05,ur,50)else bx=tT+rk*100 end elseif b7 or bb or bB then if bB then cD=cD+rk*us;if cD<kv.noAtmosphericDensityAltitude then cD=kv.noAtmosphericDensityAltitude end else bc=bc+rk*us end;us=dq(us*1.05,uq,50)else iC:updateTargetGroundAltitudeFromActionLoop(rk*1.0)end end;local function uK(rj)local rk=1;if rj then rk=-1 end;if not c1 then if t and not p7 then bR=dq(bR+rk*aF/100,-1,1)else iC:updateCommandFromActionLoop(axisCommandId.longitudinal,rk*aF)end end end;if uw=="groundaltitudeup"then if not c1 then uJ()end elseif uw=="groundaltitudedown"then if not c1 then uJ(true)end elseif uw=="speedup"then uK()elseif uw=="speeddown"then uK(true)end end;function uo.inputTextControl(ri)local function uL(uM,fq,gt)local function uN(fq)local dH=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dI='::pos{'..dH..','..dH..','..dH..','..dH..','..dH..'}'local dY,dZ,e5,e6,e7=e8(fq,dI)if dY=="0"and dZ=="0"then return vec3(dr(e5),dr(e6),dr(e7))end;e6=math.rad(e6)e5=math.rad(e5)local kv=e[dr(dY)][dr(dZ)]local eZ=math.cos(e5)local uO=vec3(eZ*math.cos(e6),eZ*math.sin(e6),math.sin(e5))return kv.center+(kv.radius+e7)*uO end;local fR=uN(fq)return cs.AddNewLocation(uM,fR,gt)end;local M;local uP,iq=nil,nil;local uQ="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations.\n".."/trans (whatever) - shows the current transponder setting, whatever, if present, is the new tag that is set.\n".."/pipecenter - Shows a waypoint to closest pipe center and prints loc in lua chat and sets it to 1-Temp in IPH for use with autopilot"M=string.find(ri," ")uP=ri;if M~=nil and string.find(ri,"::")~=1 then uP=string.sub(ri,0,M-1)iq=string.sub(ri,M+1)end;if uP=="/help"or uP=="/commands"then for lp in string.gmatch(uQ,"([^\n]+)")do a.print(lp)end;return elseif uP=="/setname"then if iq==nil or iq==""then dm("Usage: ah-setname Newname")return end;if bn>0 and f_~=nil then cs.UpdatePosition(iq)else dm("Select a saved target to rename first")end elseif shield and uP=="/resist"then cw.setResist(iq)elseif uP=="/addlocation"or string.find(ri,"::pos")~=nil then local gt=false;local uM="0-Temp"if iq==nil or iq==""or uP~="/addlocation"then iq=uP;gt=true end;M=string.find(iq,"::")if not gt then uM=string.sub(iq,1,M-2)end;local fq=string.sub(iq,M)fq=fq:gsub("%s+","")uL(uM,fq,gt)elseif uP=="/agg"then if iq==nil or iq==""then dm("Usage: /agg targetheight")return end;iq=dr(iq)if iq<1000 then iq=1000 end;bx=iq;dm("AGG Target Height set to "..iq)elseif uP=="/G"then if iq==nil or iq==""then dm("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if iq=="dump"then for dP,dB in pairs(iF())do if type(dB.get())=="boolean"then if dB.get()==true then a.print(dP.." true")else a.print(dP.." false")end elseif dB.get()==nil then a.print(dP.." nil")else a.print(dP.." "..dB.get())end end;return end;M=string.find(iq," ")local uR=string.sub(iq,0,M-1)local uS=string.sub(iq,M+1)for dP,dB in pairs(iF())do if dP==uR then local uT=type(dB.get())if uT=="number"then uS=dr(uS)if dP=="AtmoSpeedLimit"then cB=uS end end;dm("Variable "..uR.." changed to "..uS)if dP=="MaxGameVelocity"then uS=uS/3.6;if uS>df-0.2 then uS=df-0.2;dm("Variable "..uR.." changed to "..fP(uS*3.6,1))end end;if uT=="boolean"then if string.lower(uS)=="true"then uS=true else uS=false end end;dB.set(uS)return end end;dm("No such global variable: "..uR)elseif uP=="/deletewp"then if bn>0 and f_~=nil then cs.ClearCurrentPosition()else dm("Select a custom wp to delete first in IPH")end elseif uP=="/copydatabank"then if dbHud_2 then pJ(true)else dm("Spare Databank required to copy databank")end elseif uP=="/iphWP"then if bn>0 then a.print(ct.showWayPoint(c8,bm,true))a.print(json.encode(bm))dm("::pos waypoint shown in lua chat in local and world format")else dm("No target selected in IPH")end elseif uP=="/trans"then if um then if iq==nil or iq==""then dm("Current tag: "..un(um.getTags()))return else um.setTags({iq})dm("Transponder tag set to: "..iq)end else dm("No transponder found.")end elseif uP=="/createPrivate"then local uU="privatelocations = {\n"local uV=""if#d9>0 then for dP,dB in pairs(d9)do uU=uU.."{position = {x = "..dB.position.x..", y = "..dB.position.y..", z = "..dB.position.z.."},\n ".."name = '"..dB.name.."',\n planetname = '"..dB.planetname.."',\n gravity = "..dB.gravity..",\n"if dB.heading then uU=uU.."heading = {x = "..dB.heading.x..", y = "..dB.heading.y..", z = "..dB.heading.z.."},\n"end;if dB.safe then uU=uU.."safe = true},\n"else uU=uU.."safe = false},\n"end end end;uV=#d9 .."-Private "if iq=="all"then for dP,dB in pairs(br)do uU=uU.."{position = {x = "..dB.position.x..", y = "..dB.position.y..", z = "..dB.position.z.."},\n ".."name = '*"..dB.name.."',\n planetname = '"..dB.planetname.."',\n gravity = "..dB.gravity..",\n"if dB.heading then uU=uU.."heading = {x = "..dB.heading.x..", y = "..dB.heading.y..", z = "..dB.heading.z.."},\n"end;if dB.safe then uU=uU.." safe = true},\n"else uU=uU.."safe = false},\n"end end;uV=uV..#br.."-Public "end;uU=uU.."}\n return privatelocations"if uk then uk.setHTML(uU)end;dm(uV.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c4=7 elseif uP=="/pipecenter"then if dg~=nil then local uW=dg;local fq="::pos{0,0,"..uW["x"]..","..uW["y"]..","..uW["z"].."}"uL("1-ClosestPipeCenter",fq,true)if dh then fq="::pos{0,0,"..dh["x"]..","..dh["y"]..","..dh["z"].."}"uL("2-"..di.name.."PipeCenter",fq,true)uW=dh end;fq=cO+di.center-uW;fq="::pos{0,0,"..fq["x"]..","..fq["y"]..","..fq["z"].."}"uL("3-"..di.name.."PipeParallel",fq,true)else dm("No Pipe Center known")end end end;function uo.tagTick()if bE=="Off"then bE="All"elseif bE=="All"then bE="Longitude"elseif bE=="Longitude"then bE="Lateral"elseif bE=="Lateral"then bE="Vertical"else bE="Off"end;dm("Extra Engine Tags: "..bE)c.stopTimer("tagTick")end;if uX then for dP,dB in pairs(uX)do uo[dP]=dB end end;return uo end;local function uY(d,b,c,e,vBooster,hover,pI,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iy,uk,um)local a=DUSystem;local bP=DUConstruct;local uZ=DUPlayer;local u_=DULibrary;local v0={}local dp=string.format;local iz=json.decode;local un=json.encode;local pB=b.getElementMaxHitPointsById;local iA=b.getElementMassById;local iB=d.control.isRemoteControlled;local e8=string.match;local gG=a.destroyWidgetPanel;local fM=a.updateData;local fN=a.addDataToWidget;local ul=a.lockView;local iD=a.isViewLocked;local ds=math.sqrt;local dr=tonumber;local f2=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local eY=math.atan;local bM=a.getArkTime;local dq=utils.clamp;local iC=d.axisCommandManager;local gI=13;local iI=b.getElementIdList()local iJ=0;local function dt(eG,eH)if eG==0 then return f2(eH)<1e-09 elseif eH==0 then return f2(eG)<1e-09 else return f2(eG-eH)<math.max(f2(eG),f2(eH))*dG end end;local function fP(dH,v1)local rk=10^(v1 or 0)return bN(dH*rk+0.5)/rk end;local function iE(v2,v3)for dP,dB in pairs(v3)do if type(dP)=="string"then v2[dP]=dB else v2[#v2+1]=v3[dP]end end;return v2 end;local function iF(v4)local v5={}if not v4 then iE(v5,L)iE(v5,ab)iE(v5,aD)iE(v5,a_)return v5 elseif v4=="boolean"then return L elseif v4=="handling"then return ab elseif v4=="hud"then return aD elseif v4=="physics"then return a_ end end;local function dm(sU)if not sU then return end;if c3~="empty"then if not string.find(c3,sU)then c3=c3 .."\n"..sU;c4=7 end else c3=sU end end;local function pJ(v6)local function v7(v8)for dP,dB in pairs(v8)do dbHud_1.setStringValue(dP,un(dB.get()))if v6 and dbHud_2 then dbHud_2.setStringValue(dP,un(dB.get()))end end end;if dbHud_1 then v7(bJ)v7(iF())a.print("Saved Variables to Datacore")if v6 and dbHud_2 then dm("Databank copied.  Remove copy when ready.")end end end;local function fO(v9,va,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v9 ..".mp3")end;local function gH(hB,hC,ri,jQ,vb)return dp([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jQ or"",hB,hC,vb or"",ri)end;local function iG(cb,vc)vc=vc or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fP(cb,vc)..unit end;local function iH(vd)local ve=0;local vf=0;local vg=0;if vd<60 then vd=bN(vd)elseif vd<3600 then ve=bN(vd/60)vd=bN(vd%60)elseif vd<86400 then vf=bN(vd/3600)ve=bN(vd%3600/60)else vg=bN(vd/86400)vf=bN(vd%86400/3600)end;if vg>365 then return">1y"elseif vg>0 then return vg.."d "..vf.."h "elseif vf>0 then return vf.."h "..ve.."m "elseif ve>0 then return ve.."m "..vd.."s"elseif vd>0 then return vd.."s"else return"0s"end end;local function vh()if radar_1 then cu=gF(b,a,c,radar_1,radar_2,warpdrive,f2,gG,ds,gH,dr,gI,fO,dm)end end;function v0.radarSetup()vh()end;function v0.onStart()local vi=false;local function vj()local function vk(vl)local vm=dbHud_1.hasKey;for dP,dB in pairs(vl)do if vm(dP)then local dK=iz(dbHud_1.getStringValue(dP))if dK~=nil then dB.set(dK)vi=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vk(iF())coroutine.yield()vk(bJ)else vk(bJ)dm("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c4=5;vi=false end;coroutine.yield()if vi then dm("Loaded Saved Variables")elseif not f then dm("No Databank Saved Variables Found\nVariables will save to Databank on standing")c4=5 end;if#br>0 then da=iE(da,br)end else dm("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;b0=k;g=string.lower(g)cz=q;cB=V;if by+180<bQ then bw=0 end;by=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then dm("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c4=7 end;if antigrav and not r then if bx==nil then bx=ci end;antigrav.setTargetAltitude(bx)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d9>0 then da=iE(da,d9)end end;lu="Proceeding to Waypoint"if not a0 or a0<0 then a0=bP.getMaxSpeed()-0.1 end end;local function vn()local function vo(vp,vq)if vp>vq then vq=vp end;local vr,vs=0,0;if a6>0 then vr=a6*0.05 end;if a7>0 then vs=a7*0.05 end;vq=vq*(1-(vr+vs))return vq end;local vt=b.getElementNameById;local vu=at~=0 and au~=0;local vv=_G["atmofueltank_size"]local vw=_G["spacefueltank_size"]local vx=_G["rocketfueltank_size"]for dP in pairs(iI)do local type=b.getElementDisplayNameById(iI[dP])if e8(type,'^.*Atmospheric Engine$')then if e8(tostring(b.getElementTagsById(iI[dP])),'^.*vertical.*$')and b.getElementForwardById(iI[dP])[3]>0 then cP=true end end;if e8(type,'^.*Space Engine$')then cG=true;if e8(tostring(b.getElementTagsById(iI[dP])),'^.*vertical.*$')then local vy=b.getElementForwardById(iI[dP])if vy[3]<0 then vz=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local pD=pB(iI[dP])if pD>10000 then gI=110 elseif pD>1000 then gI=55 elseif pD>150 then gI=27 end end;iJ=iJ+pB(iI[dP])if vu and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pD=pB(iI[dP])local f7=iA(iI[dP])local vp=0;local jI=bM()if type=="Atmospheric Fuel Tank"then local vq=400;local vA=35.03;if pD>10000 then vq=51200;vA=5480 elseif pD>1300 then vq=6400;vA=988.67 elseif pD>150 then vq=1600;vA=182.67 end;vp=f7-vA;if a3>0 then vq=vq+vq*a3*0.2 end;vq=vo(vp,vq)local gs=vt(iI[dP])local jG=0;for jH=1,vv do if gs==iz(c["atmofueltank_"..jH].getWidgetData()).name then jG=jH;break end end;local vB={iI[dP],string.sub(gs,1,12),vq,vA,vp,jI,jG}cl[#cl+1]=vB end;if type=="Rocket Fuel Tank"then local vq=320;local vA=173.42;if pD>65000 then vq=40000;vA=25740 elseif pD>6000 then vq=5120;vA=4720 elseif pD>700 then vq=640;vA=886.72 end;vp=f7-vA;if a5>0 then vq=vq+vq*a5*0.1 end;vq=vo(vp,vq)local gs=vt(iI[dP])local jG=0;for jH=1,vx do if gs==iz(c["rocketfueltank_"..jH].getWidgetData()).name then jG=jH;break end end;local vB={iI[dP],string.sub(gs,1,12),vq,vA,vp,jI,jG}cn[#cn+1]=vB end;if type=="Space Fuel Tank"then local vq=600;local vA=35.03;if pD>10000 then vq=76800;vA=5480 elseif pD>1300 then vq=9600;vA=988.67 elseif pD>150 then vq=2400;vA=182.67 end;vp=f7-vA;if a4>0 then vq=vq+vq*a4*0.2 end;vq=vo(vp,vq)local gs=vt(iI[dP])local jG=0;for jH=1,vw do if gs==iz(c["spacefueltank_"..jH].getWidgetData()).name then jG=jH;break end end;local vB={iI[dP],string.sub(gs,1,12),vq,vA,vp,jI,jG}cm[#cm+1]=vB end end end;if not cP then bb,b1=false,false end end;local function vC()if gyro~=nil then ck=gyro.isActive()==1 end;if not bD then iC:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ul(1)else ul(0)end;if door and(cg or not cg and ci<10000)then for dU,dB in pairs(door)do dB.toggle()end end;if switch then for dU,dB in pairs(switch)do dB.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dU,dB in pairs(forcefield)do dB.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not r then antigrav.showWidget()end end;if iB()==1 and l then uZ.freeze(1)else uZ.freeze(0)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bo=d.control.isAnyLandingGearDeployed()==1 or not bD or cf~=-1 and cf-3<Z;local vD=cJ:len()<30;if cf~=-1 and vE or(not cg or not vE)and vD then b2="Startup"else b2=false end;iC:setTargetGroundAltitude(Z)pp=cg end;local function vF()local vG={}local function vH()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local function vI()return{id=1000,name={"Aegis","Aegis","Aegis"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=1000,satellites={},center={13856549.3576,7386341.6738,-258459.8925},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vJ={[1]=6637,[2]=3426,[4]=7580,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vK,vL in pairs(e)do e[vK][0]=vH()e[vK][0].systemId=vK;e[vK][1000]=vI()vG[vK]={}for vM,kv in pairs(e[vK])do kv.gravity=kv.gravity/9.8;kv.center=vec3(kv.center)kv.name=kv.name[1]kv.noAtmosphericDensityAltitude=kv.atmosphereThickness;kv.spaceEngineMinAltitude=vJ[kv.id]or 0.5353125*kv.atmosphereThickness;kv.planetarySystemId=vK;kv.bodyId=kv.id;vG[vK][vM]=kv;if me==nil or kv.center.x<me then me=kv.center.x end;if md==nil or kv.center.x>md then md=kv.center.x end;if mh==nil or kv.center.y<mh then mh=kv.center.y end;if mg==nil or kv.center.y>mg then mg=kv.center.y end;if kv.center and kv.name~="Space"then d4[#d4+1]=kv end end end;ei=dn(d,b,c,a,dp,dq,dr,ds,dt)co=ei(vG)fS=co[0]cp=f1(d,b,c,a,ds,f2)cq=fm(d,b,c,a,dp,dq,dr,ds,dt)cs=fL(d,b,c,a,dbHud_1,e,fM,fN,bN,dr,ds,fO,fP,dm)kv=co[0]:closestBody(bP.getWorldPosition())end;vN=false;vO=coroutine.create(function()iC:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vj()coroutine.yield()vn()coroutine.yield()ct=pH(d,b,c,e,vBooster,hover,pI,antigrav,dbHud_1,f2,bN,bO,iB,eY,bM,dq,iC,fM,iD,ds,fP,fO,iE,dt,iG,iH,pJ,iz,dm)vC()coroutine.yield()vF()vh()if ix then cr=ix(d,b,c,a,e,antigrav,hover,shield,warpdrive,iy,f2,bN,dp,iz,bO,iA,iB,eY,bM,dq,iC,fN,fM,gG,iD,ds,fP,gH,fO,iE,iF,iG,iH,iI,iJ,dm)end;if cr then cr.ButtonSetup()end;cv=uj(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uk,iB,iC,iD,ul,gG,fP,e8,dr,dq,fO,iF,pJ,dm,um,un)if shield then cw=ig(shield,e8,bN,dm)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uk then uk.setCenteredText("")end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bP.setDockingMode(aa)if shield then c.setTimer("shieldTick",0.0166667)end;if vP then vQ.ExtraOnStart()end;local function vR()if bI[1]==0 then ct.cmdThrottle(bI[2])else if ch>0 then cB=bI[2]ct.cmdThrottle(1)end end end;lm=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if lm then if cf>-1 and cL<1 and cf-3<Z then c.exit()else if J then vR()else if ch==0 then b2="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bI[3]+3>bM()then vR()end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()local vS;vS=#d2>1 and"Passengers: "..#d2-1 .." "or""vS=vS..(#d3>0 and"Ships: "..#d3 or"")if vS~=""then dm("NOTICE: Docked "..vS)end;fO("start","SU")end)coroutine.resume(vO)end;function v0.onUpdate()if vN then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iC:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and p9~=vT then a.setScreen(p9)end;vT=p9;if lm and not J and ch>0 and cf==-1 then cv.landingGear()end;if lm and cf>-1 and cL<1 and cf-3<Z then c.exit()end;if vP then vQ.ExtraOnUpdate()end else local i5=coroutine.status(vO)if i5=="suspended"then local dQ,i6=coroutine.resume(vO)if i6 then a.print("ERROR STARTUP: "..i6)end elseif i5=="dead"then vN=true end end end;function v0.onFlush()if vN then ct.onFlush()if vP then vQ.ExtraOnFlush()end end end;function v0.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dU,dB in pairs(door)do dB.toggle()end end;if switch then for dU,dB in pairs(switch)do dB.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dU,dB in pairs(forcefield)do dB.toggle()end end;w=d6;local vU=0;if lm then vU=bM()end;if iC:getAxisCommandType(0)==0 then bI={0,bR,vU}else bI={1,iC:getTargetSpeed(axisCommandId.longitudinal),vU}end;pJ()if nU then nU.activate()end;if z then ct.showWayPoint(kv,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vP then vQ.ExtraOnStop()end;fO("stop","SU")end;function v0.controlStart(uw)if vN then cv.startControl(uw)end end;function v0.controlStop(uw)if vN then cv.stopControl(uw)end end;function v0.controlLoop(uw)if vN then cv.loopControl(uw)end end;function v0.controlInput(ri)if vN then cv.inputTextControl(ri)end end;function v0.radarEnter(dZ)if cu then cu.onEnter(dZ)end end;function v0.radarLeave(dZ)if cu then cu.onLeave(dZ)end end;function v0.onTick(vV)if vV=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vV=="oneSecond"then if cr then cr.OneSecondTick()end elseif vV=="msgTick"then if cr then cr.MsgTick()end elseif vV=="animateTick"then if cr then cr.AnimateTick()end elseif vV=="hudTick"then if cr then cr.hudtick()end elseif vV=="apTick"then if ct then ct.APTick()end elseif vV=="shieldTick"then cw.shieldTick()elseif vV=="tagTick"then cv.tagTick()elseif vV=="contact"then cu.ContactTick()end end;if vP then for dP,dB in pairs(vP)do v0[dP]=dB end end;return v0 end;function script.onStart()vQ.onStart()end;function script.onOnStop()vQ.onStop()end;function script.onTick(vV)vQ.onTick(vV)end;function script.onOnFlush()vQ.onFlush()end;function script.onOnUpdate()vQ.onUpdate()end;function script.onActionStart(uw)vQ.controlStart(uw)end;function script.onActionStop(uw)vQ.controlStop(uw)end;function script.onActionLoop(uw)vQ.controlLoop(uw)end;function script.onInputText(ri)vQ.controlInput(ri)end;function script.onEnter(dZ)vQ.radarEnter(dZ)end;function script.onLeave(dZ)vQ.radarLeave(dZ)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vQ=uY(d,core,unit,e,vBooster,hover,pI,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iy,uk,vW)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
