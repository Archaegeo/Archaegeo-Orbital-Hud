name: ArchHud - Archaegeo v0.746 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.746;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=true;K=false;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},freeLookToggle={set=function(M)i=M end,get=function()return i end},BrakeToggleDefault={set=function(M)j=M end,get=function()return j end},RemoteFreeze={set=function(M)k=M end,get=function()return k end},brightHud={set=function(M)m=M end,get=function()return m end},RemoteHud={set=function(M)l=M end,get=function()return l end},VanillaRockets={set=function(M)n=M end,get=function()return n end},InvertMouse={set=function(M)o=M end,get=function()return o end},autoRollPreference={set=function(M)p=M end,get=function()return p end},ExternalAGG={set=function(M)q=M end,get=function()return q end},UseSatNav={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},FullRadar={set=function(M)J=M end,get=function()return J end},ECUHud={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.2;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)ab=M end,get=function()return ab end},AutopilotInterplanetaryThrottle={set=function(M)a1=M end,get=function()return a1 end},warmup={set=function(M)a2=M end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingSpace={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingRocket={set=function(M)a5=M end,get=function()return a5 end},ContainerOptimization={set=function(M)a6=M end,get=function()return a6 end},FuelTankOptimization={set=function(M)a7=M end,get=function()return a7 end},AutoShieldPercent={set=function(M)a8=M end,get=function()return a8 end},EmergencyWarp={set=function(M)a9=M end,get=function()return a9 end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD=100;aE={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end},soundVolume={set=function(M)aD=M end,get=function()return aD end}}aF=5.0;aG=1.0;aH=0.003;aI=0.003;aJ=2;aK=1.5;aL=180;aM=150;aN=0.002;aO=2;aP=0.8;aQ=1;aR=3;aS=1;aT=40;aU=0.0666667;aV=0.0;aW="none"aX="none"aY="none"aZ={speedChangeLarge={set=function(M)aF=M end,get=function()return aF end},speedChangeSmall={set=function(M)aG=M end,get=function()return aG end},MouseXSensitivity={set=function(M)aH=M end,get=function()return aH end},MouseYSensitivity={set=function(M)aI=M end,get=function()return aI end},autoRollFactor={set=function(M)aJ=M end,get=function()return aJ end},rollSpeedFactor={set=function(M)aK=M end,get=function()return aK end},autoRollRollThreshold={set=function(M)aL=M end,get=function()return aL end},minRollVelocity={set=function(M)aM=M end,get=function()return aM end},TrajectoryAlignmentStrength={set=function(M)aN=M end,get=function()return aN end},torqueFactor={set=function(M)aO=M end,get=function()return aO end},pitchSpeedFactor={set=function(M)aP=M end,get=function()return aP end},yawSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeSpeedFactor={set=function(M)aR=M end,get=function()return aR end},brakeFlatFactor={set=function(M)aS=M end,get=function()return aS end},DampingMultiplier={set=function(M)aT=M end,get=function()return aT end},hudTickRate={set=function(M)aU=M end,get=function()return aU end},ExtraEscapeThrust={set=function(M)aV=M end,get=function()return aV end},ExtraLongitudeTags={set=function(M)aW=M end,get=function()return aW end},ExtraLateralTags={set=function(M)aX=M end,get=function()return aX end},ExtraVerticalTags={set=function(M)aY=M end,get=function()return aY end}}a_=j;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=1000;bc=false;bd=false;be=false;bf=false;bg=0;bh="Aligning"bi=0;bj=1;bk="None"bl=nil;bm=0;bn=nil;bo=0.0;bp=0;bq={}br=false;bs=0;bt=0;bu=nil;bv=0;bw=1000;bx=0;by=false;bz=0;bA=false;bB="All"bC=true;bD="Off"bE=0.000;bF={}bG={}bH={}bI={VertTakeOff={set=function(M)ba=M end,get=function()return ba end},VertTakeOffEngine={set=function(M)b0=M end,get=function()return b0 end},SpaceTarget={set=function(M)by=M end,get=function()return by end},BrakeToggleStatus={set=function(M)a_=M end,get=function()return a_ end},BrakeIsOn={set=function(M)b1=M end,get=function()return b1 end},RetrogradeIsOn={set=function(M)b2=M end,get=function()return b2 end},ProgradeIsOn={set=function(M)b3=M end,get=function()return b3 end},Autopilot={set=function(M)b4=M end,get=function()return b4 end},TurnBurn={set=function(M)b5=M end,get=function()return b5 end},AltitudeHold={set=function(M)b6=M end,get=function()return b6 end},BrakeLanding={set=function(M)b7=M end,get=function()return b7 end},Reentry={set=function(M)b9=M end,get=function()return b9 end},AutoTakeoff={set=function(M)b8=M end,get=function()return b8 end},HoldAltitude={set=function(M)bb=M end,get=function()return bb end},AutopilotAccelerating={set=function(M)bc=M end,get=function()return bc end},AutopilotBraking={set=function(M)be=M end,get=function()return be end},AutopilotCruising={set=function(M)bf=M end,get=function()return bf end},AutopilotRealigned={set=function(M)bd=M end,get=function()return bd end},AutopilotEndSpeed={set=function(M)bg=M end,get=function()return bg end},AutopilotStatus={set=function(M)bh=M end,get=function()return bh end},AutopilotPlanetGravity={set=function(M)bi=M end,get=function()return bi end},PrevViewLock={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetName={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetCoords={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetIndex={set=function(M)bm=M end,get=function()return bm end},TotalDistanceTravelled={set=function(M)bo=M end,get=function()return bo end},TotalFlightTime={set=function(M)bp=M end,get=function()return bp end},SavedLocations={set=function(M)bq=M end,get=function()return bq end},VectorToTarget={set=function(M)br=M end,get=function()return br end},LocationIndex={set=function(M)bs=M end,get=function()return bs end},LastMaxBrake={set=function(M)bt=M end,get=function()return bt end},LockPitch={set=function(M)bu=M end,get=function()return bu end},LastMaxBrakeInAtmo={set=function(M)bv=M end,get=function()return bv end},AntigravTargetAltitude={set=function(M)bw=M end,get=function()return bw end},LastStartTime={set=function(M)bx=M end,get=function()return bx end},iphCondition={set=function(M)bB=M end,get=function()return bB end},stablized={set=function(M)bC=M end,get=function()return bC end},UseExtra={set=function(M)bD=M end,get=function()return bD end},SelectedTab={set=function(M)bJ=M end,get=function()return bJ end},saveRoute={set=function(M)bF=M end,get=function()return bF end},apRoute={set=function(M)bG=M end,get=function()return bG end},ecuThrottle={set=function(M)bH=M end,get=function()return bH end}}local function bK(b,c,bL,bM,bN)local a=DUSystem;local bO=DUConstruct;bP=bL()bQ=0;bR=0;bS=false;bT=0;bU=false;bV=false;bW=0;bX=0;bY=0;bZ=0;b_=false;c0=false;c1=false;c2="empty"c3=3;c4=false;c5=0;c6=0;c7=nil;c8=0;c9=0;ca=0;cb=false;cc=false;cd=false;ce=-1;cf=bN()>0;cg=bN()ch=b.getAltitude()ci=DUConstruct.getMass()cj=nil;ck=ac;cl=ad;cm={}cn={}co={}cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=nil;cy=false;cz=false;cA=p;cB=false;cC=W;cD=nil;cE=0;cF=false;cG=false;cH=false;cI=vec3(bO.getWorldOrientationForward())cJ=vec3(bO.getWorldOrientationRight())cK=vec3(bO.getVelocity())cL=vec3(bO.getWorldVelocity())cM=vec3(cL):len()cN=vec3(b.getWorldVertical())cO=-cN:dot(cL)cP=vec3(bO.getWorldPosition())cQ=false;cR=false;cS=true;cT=0;cU=0;cV={}cW=false;cX=50000;cY=nil;cZ=c.getClosestPlanetInfluence()>0 or ch>0 and ch<200000;c_=false;d0=nil;d1=false;d2=0;d3=nil;d4=nil;d5={}d6=90;d7=w;d8=nil;d9=nil;da={}db={}dc=false;dd=nil;de=0;df=false;dg=bO.getMaxSpeed()if shield then dh=bM(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function di(dj)a.print(bP..": "..dj)end;local function dk(d,b,c,a,dl,dm,dn,dp,dq)local function dr(ds)return type(ds)=='number'end;local function dt(ds)return type(dn(ds))=='number'end;local function du(dv)return type(dv)=='table'end;local function dw(a)return type(a)=='string'end;local function dx(dy)return du(dy)and dr(dy.x and dy.y and dy.z)end;local function dz(dA)return du(dA)and dr(dA.latitude and dA.longitude and dA.altitude and dA.id and dA.systemId)end;local dB=math.pi/180;local dC=180/math.pi;local dD=1e-10;local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF='::pos{'..dE..','..dE..','..dE..','..dE..','..dE..'}'local utils=utils;local vec3=vec3;local function dG(ds)local dH=string.gsub(string.reverse(dl('%.4f',ds)),'^0*%.?','')return dH==''and'0'or string.reverse(dH)end;local function dI(dJ)if dx(dJ)then return dl('{x=%.3f,y=%.3f,z=%.3f}',dJ.x,dJ.y,dJ.z)end;if du(dJ)and not getmetatable(dJ)then local dK={}local dL=next(dJ)if type(dL)=='nil'or dL==1 then dK=dJ else for dM,dy in pairs(dJ)do local dN=dI(dy)if type(dM)=='number'then table.insert(dK,dl('[%s]=%s',dM,dN))else table.insert(dK,dl('%s=%s',dM,dN))end end end;return dl('{%s}',table.concat(dK,','))end;if dw(dJ)then return dl("'%s'",dJ:gsub("'",[[\']]))end;return tostring(dJ)end;local dO={}dO.__index=dO;dO.__tostring=function(dJ,dP)local dQ={}for dM in pairs(dJ)do table.insert(dQ,dM)end;table.sort(dQ)local dK={}for dR,dM in ipairs(dQ)do local dN=dI(dJ[dM])if type(dM)=='number'then table.insert(dK,dl('[%s]=%s',dM,dN))else table.insert(dK,dl('%s=%s',dM,dN))end end;if dP then return dl('%s%s',dP,table.concat(dK,',\n'..dP))end;return dl('{%s}',table.concat(dK,','))end;dO.__eq=function(dS,dT)return dS.systemId==dT.systemId and dS.id==dT.id and dq(dS.radius,dT.radius)and dq(dS.center.x,dT.center.x)and dq(dS.center.y,dT.center.y)and dq(dS.center.z,dT.center.z)and dq(dS.GM,dT.GM)end;local function dU(dV,dW,dX,dY,dZ)assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(dX),'Argument 3 (radius) must be a number:'..type(dX))assert(du(dY),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dY))assert(dt(dZ),'Argument 5 (GM) must be a number:'..type(dZ))return setmetatable({systemId=dn(dV),id=dn(dW),radius=dn(dX),center=vec3(dY),GM=dn(dZ)},dO)end;local d_={}d_.__index=d_;d_.__tostring=function(di)return dl('::pos{%d,%d,%s,%s,%s}',di.systemId,di.id,dG(di.latitude*dC),dG(di.longitude*dC),dG(di.altitude))end;d_.__eq=function(dS,dT)return dS.id==dT.id and dS.systemId==dT.systemId and dq(dS.latitude,dT.latitude)and dq(dS.altitude,dT.altitude)and(dq(dS.longitude,dT.longitude)or dq(dS.latitude,math.pi/2)or dq(dS.latitude,-math.pi/2))end;local function e0(e1,dW,e2,e3,e4)local dV=e1;if dw(e1)and not e3 and not e4 and not dW and not e2 then dV,dW,e2,e3,e4=e5(e1,dF)assert(dV,'Argument 1 (position string) is malformed.')else assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(e2),'Argument 3 (latitude) must be in degrees:'..type(e2))assert(dt(e3),'Argument 4 (longitude) must be in degrees:'..type(e3))assert(dt(e4),'Argument 5 (altitude) must be in meters:'..type(e4))end;dV=dn(dV)dW=dn(dW)e2=dn(e2)e3=dn(e3)e4=dn(e4)if dW==0 then return setmetatable({latitude=e2,longitude=e3,altitude=e4,id=dW,systemId=dV},d_)end;return setmetatable({latitude=dB*dm(e2,-90,90),longitude=dB*(e3%360),altitude=e4,id=dW,systemId=dV},d_)end;local e6={}e6.__index=e6;e6.__tostring=function(dJ,dP)local e7=dP and dP..'  'local e8={}local dQ={}for dM in pairs(dJ)do table.insert(dQ,dM)end;table.sort(dQ)for dR,e9 in ipairs(dQ)do ea=dJ[e9]local eb=dO.__tostring(ea,e7)if dP then table.insert(e8,dl('[%s]={\n%s\n%s}',e9,eb,dP))else table.insert(e8,dl('  [%s]=%s',e9,eb))end end;if dP then return dl('\n%s%s%s',dP,table.concat(e8,',\n'..dP),dP)end;return dl('{\n%s\n}',table.concat(e8,',\n'))end;local function ec(ed)local e={}local pid;for dR,dy in pairs(ed)do local dW=dy.planetarySystemId;if type(dW)~='number'then error('Invalid planetary s ID: '..tostring(dW))elseif pid and dW~=pid then error('Mistringmatch planetary s IDs: '..dW..' and '..pid)end;local ee=dy.bodyId;if type(ee)~='number'then error('Invalid body ID: '..tostring(ee))elseif e[ee]then error('Duplicate body ID: '..tostring(ee))end;setmetatable(dy.center,getmetatable(vec3.unit_x))e[ee]=setmetatable(dy,dO)pid=dW end;return setmetatable(e,e6)end;ef={}local function eg(ed)return setmetatable({galaxyAtlas=ed or{}},ef)end;ef.__index=function(dv,M)if type(M)=='number'then local a=dv.galaxyAtlas[M]return ec(a)end;return rawget(ef,M)end;ef.__pairs=function(dJ)return function(dv,dM)local eh,ei=next(dv,dM)return eh,ei and ec(ei)end,dJ.galaxyAtlas,nil end;ef.__tostring=function(dJ)local ej={}for dR,ek in pairs(dJ or{})do local el=ek:getPlanetarySystemId()local em=e6.__tostring(ek,'    ')table.insert(ej,dl('  [%s]={%s\n  }',el,em))end;return dl('{\n%s\n}\n',table.concat(ej,',\n'))end;ef.BodyParameters=dU;ef.MapPosition=e0;ef.PlanetarySystem=ec;function ef.createBodyParameters(dV,dW,en,eo,ep,eq,er)assert(dt(dV),'Argument 1 (systemId) must be a number:'..type(dV))assert(dt(dW),'Argument 2 (id) must be a number:'..type(dW))assert(dt(en),'Argument 3 (surfaceArea) must be a number:'..type(en))assert(du(eo),'Argument 4 (aPosition) must be an array or vec3:'..type(eo))assert(du(ep),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ep))assert(dt(eq),'Argument 6 (altitude) must be in meters:'..type(eq))assert(dt(er),'Argument 7 (gravityAtPosition) must be number:'..type(er))local dX=dp(en/4/math.pi)local ca=dX+eq;local es=vec3(eo)+ca*vec3(ep)local dZ=er*ca*ca;return dU(dV,dW,dX,es,dZ)end;ef.isMapPosition=dz;function ef:getPlanetarySystem(e1)if M==nil then M=0 end;if ei==nil then ei=0 end;local dV=e1;if dz(e1)then dV=e1.systemId end;if type(dV)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(ei)~=e6 then a=ec(a)end;return a end end end;function e6:sizeCalculator(et)return 1.05*et.radius end;function e6:castIntersections(eu,ev,ew,ex,ey,ez)local eA={}if ey then for dR,et in pairs(ey)do table.insert(eA,et)end else eA=d5 end;if not ez then table.sort(eA,function(eB,eC)local eD=eB.center;local eE=eC.center;return(eD.x-eu.x)^2+(eD.y-eu.y)^2+(eD.z-eu.z)^2<(eE.x-eu.x)^2+(eE.y-eu.y)^2+(eE.z-eu.z)^2 end)end;local eF=ev:normalize()for dR,et in ipairs(eA)do local eG=et.center-eu;local dX;if ew then dX=ew(et)else dX=self:sizeCalculator(et)end;local eH=eG:dot(eF)local eI=eH^2-(eG:len2()-dX^2)if eI>=0 then local eJ=dp(eI)local eK=eH+eJ;local eL=eH-eJ;if eL>0 then return et,eK,eL elseif eK>0 then return et,eK,nil end end end;return nil,nil,nil end;function e6:closestBody(eM)assert(type(eM)=='table','Invalid coordinates.')local eN,et;local eO=vec3(eM)for dR,eP in pairs(self)do local eQ=(eP.center-eO):len2()if(not et or eQ<eN)and eP.name~="Space"then et=eP;eN=eQ end end;return et end;function e6:convertToBodyIdAndWorldCoordinates(e1)local eR=e1;if dw(e1)then eR=e0(e1)end;if eR.id==0 then return 0,vec3(eR.latitude,eR.longitude,eR.altitude)end;local eP=self:getBodyParameters(eR)if eP then return eR.id,eP:convertToWorldCoordinates(eR)end end;function e6:getBodyParameters(e1)local dW=e1;if dz(e1)then dW=e1.id end;assert(dt(dW),'Argument 1 (id) must be a number:'..type(dW))return self[dW]end;function e6:getPlanetarySystemId()local dR,dy=next(self)return dy and dy.systemId end;function dO:convertToMapPosition(dY)assert(du(dY),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dY))local eS=vec3(dY)if self.id==0 then return setmetatable({latitude=eS.x,longitude=eS.y,altitude=eS.z,id=0,systemId=self.systemId},d_)end;local eT=eS-self.center;local ca=eT:len()local e4=ca-self.radius;local e2=0;local e3=0;if not dq(ca,0)then local eU=eV(eT.y,eT.x)e3=eU>=0 and eU or 2*math.pi+eU;e2=math.pi/2-math.acos(eT.z/ca)end;return setmetatable({latitude=e2,longitude=e3,altitude=e4,id=self.id,systemId=self.systemId},d_)end;function dO:convertToWorldCoordinates(e1)local eR=dw(e1)and e0(e1)or e1;if eR.id==0 then return vec3(eR.latitude,eR.longitude,eR.altitude)end;assert(dz(eR),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eR.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eR.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eW=math.cos(eR.latitude)return self.center+(self.radius+eR.altitude)*vec3(eW*math.cos(eR.longitude),eW*math.sin(eR.longitude),math.sin(eR.latitude))end;function dO:getAltitude(dY)return(vec3(dY)-self.center):len()-self.radius end;function dO:getDistance(dY)return(vec3(dY)-self.center):len()end;function dO:getGravity(dY)local eX=self.center-vec3(dY)local eY=eX:len2()return self.GM/eY*eX/dp(eY)end;return setmetatable(ef,{__call=function(dR,...)return eg(...)end})end;local function eZ(d,b,c,a,dp,e_)local cq={}local bO=100000000/3600;local f0=bO*bO;local f1=100;function cq.computeAccelerationTime(f2,f3,f4)local f5=bO*math.asin(f2/bO)return(bO*math.asin(f4/bO)-f5)/f3 end;function cq.computeDistanceAndTime(f2,f4,f6,f7,f8,f9)f8=f8 or 0;f9=f9 or 0;local fa=f2<=f4;local fb=f7*(fa and 1 or-1)/f6;local fc=-f9/f6;local fd=fb+fc;if fa and fd<=0 or not fa and fd>=0 then return-1,-1 end;local fe,ff=0,0;if fb~=0 and f8>0 then local f5=math.asin(f2/bO)local fg=math.pi*(fb/2+fc)local fh=fb*f8;local fi=bO*math.pi;local dy=function(dv)local fj=(fg*dv-fh*math.sin(math.pi*dv/2/f8)+fi*f5)/fi;local fk=math.tan(fj)return bO*fk/dp(fk*fk+1)end;local fl=fa and function(a)return a>=f4 end or function(a)return a<=f4 end;ff=2*f8;if fl(dy(ff))then local fm=0;while e_(ff-fm)>0.5 do local dv=(ff+fm)/2;if fl(dy(dv))then ff=dv else fm=dv end end end;local fn=f2;local fo=ff/f1;for fp=1,f1 do local fq=dy(fp*fo)fe=fe+(fq+fn)*fo/2;fn=fq end;if ff<2*f8 then return fe,ff end;f2=fn end;local f5=bO*math.asin(f2/bO)local bP=(bO*math.asin(f4/bO)-f5)/fd;local fr=f0*math.cos(f5/bO)/fd;local ca=fr-f0*math.cos((fd*bP+f5)/bO)/fd;return ca+fe,bP+ff end;function cq.computeTravelTime(f2,f3,ca)if ca==0 then return 0 end;if f3>0 then local f5=bO*math.asin(f2/bO)local fr=f0*math.cos(f5/bO)/f3;return(bO*math.acos(f3*(fr-ca)/f0)-f5)/f3 end;if f2==0 then return-1 end;assert(f2>0,'Acceleration and initial speed are both zero.')return ca/f2 end;return cq end;local function fs(d,b,c,a,dl,dm,dn,dp,dq)local vec3=vec3;local dk=dk(d,b,c,a,dl,dm,dn,dp,dq)local function dw(a)return type(a)=='string'end;local function du(dv)return type(dv)=='table'end;ft={}ft.__index=ft;function ft:escapeAndOrbitalSpeed(e4)assert(self.body)local ca=e4+self.body.radius;if not dq(ca,0)then local fu=dp(self.body.GM/ca)return dp(2)*fu,fu end;return nil,nil end;function ft:orbitalParameters(e1,fv)assert(self.body)assert(du(e1)or dw(e1))assert(du(fv))local fw=(dw(e1)or dk.isMapPosition(e1))and self.body:convertToWorldCoordinates(e1)or vec3(e1)local dy=vec3(fv)local fx=fw-self.body.center;local fy=dy:len2()local fz=fx:len()local fA=self.body.GM;local fB=((fy-fA/fz)*fx-fx:dot(dy)*dy)/fA;local eD=fA/(2*fA/fz-fy)local fC=fB:len()local eF=fB:normalize()local fD=eD*(1-fC)local fE=eD*(1+fC)local fF=fD*eF+self.body.center;local fG=fC<=1 and-fE*eF+self.body.center or nil;local fH=dp(eD*fA*(1-fC*fC))local fI=fG and 2*math.pi*dp(eD^3/fA)local fJ=math.acos(fB:dot(fx)/(fC*fz))if fx:dot(dy)<0 then fJ=-(fJ-2*math.pi)end;local fK=math.acos((math.cos(fJ)+fC)/(1+fC*math.cos(fJ)))local fL=fK;if fL<0 then fL=fL+2*math.pi end;local fM=fL-fC*math.sin(fL)local fN=0;local fO=0;local fP=0;if fI~=nil then fN=fM/(2*math.pi/fI)fO=fI-fN;fP=fO+fI/2;if fJ-math.pi>0 then fO=fN;fP=fO+fI/2 end;if fP>fI then fP=fP-fI end end;return{periapsis={position=fF,speed=fH/fD,circularOrbitSpeed=dp(fA/fD),altitude=fD-self.body.radius},apoapsis=fG and{position=fG,speed=fH/fE,circularOrbitSpeed=dp(fA/fE),altitude=fE-self.body.radius},currentVelocity=dy,currentPosition=fw,eccentricity=fC,period=fI,eccentricAnomaly=fK,meanAnomaly=fM,timeToPeriapsis=fO,timeToApoapsis=fP,trueAnomaly=fJ}end;local function fQ(fR)local eP=dk.BodyParameters(fR.systemId,fR.id,fR.radius,fR.center,fR.GM)return setmetatable({body=eP},ft)end;return setmetatable(ft,{__call=function(dR,...)return fQ(...)end})end;local function fS(d,b,c,a,dbHud_1,e,fT,fU,bM,dn,dp,fV,fW)local function fX(fY)local di=fZ:closestBody(fY)if(fY-di.center):len()>di.radius+di.noAtmosphericDensityAltitude then di=e[0][0]end;return di end;local function f_()local function g0(g1,g2)return g1.name<g2.name end;cV={}for dM,dy in pairs(e[0])do cV[#cV+1]={name=dy.name,index=dM}end;table.sort(cV,g0)end;local function g3(g4,g5)if not g5 then g5=g6.name end;for dM,dy in pairs(g4)do if dy.name and dy.name==g5 then return dM end end;return-1 end;local function g7()d2=bm;if bm==0 then bk="None"c7=nil;g6=nil;return true end;local g8=cV[bm].index;local g9=e[0][g8]if g9.center then bk=g9.name;c7=cp[0][g8]if g6~=nil then if cg==0 then if fT(ga,gb)~=1 then fU(ga,gb)end;if fT(gc,gd)~=1 then fU(gc,gd)end;if fT(ge,gf)~=1 then fU(ge,gf)end;if fT(gg,gh)~=1 then fU(gg,gh)end;if fT(gi,gj)~=1 then fU(gi,gj)end end;if fT(gk,gl)~=1 then fU(gk,gl)end;if fT(gm,gn)~=1 then fU(gm,gn)end;if fT(go,gp)~=1 then fU(go,gp)end end;g6=nil else g6=g9;for dR,dy in pairs(cp[0])do if dy.name==g6.planetname then c7=dy;bk=g6.name;break end end;if fT(gk,gl)~=1 then fU(gk,gl)end;if fT(gm,gn)~=1 then fU(gm,gn)end end;if g6==nil then bl=vec3(c7.center)else bl=g6.position end;if c7.planetname~="Space"then if c7.hasAtmosphere then gq=bM(c7.radius*(U-1)+c7.noAtmosphericDensityAltitude)else gq=bM(c7.radius*(U-1)+c7.surfaceMaxAltitude)end else gq=T end;if g6~=nil and g6.planetname=="Space"then bg=0 else dR,bg=cr(c7):escapeAndOrbitalSpeed(gq)end;bi=0;bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"return true end;local function gr(gs)if not b4 and not br and not cc and not bA and not b9 and not cd then if gs==nil then bm=bm+1;if bm>#cV then bm=0 end else bm=bm-1;if bm<0 then bm=#cV end end;if bm==0 then g7()else local g8=cV[bm].index;local g9=e[0][g8]if g9 and(g9~=nil and g9.name=="Space"or bB=="Custom Only"and g9.center or bB=="No Moons"and string.find(g9.name,"Moon")~=nil)then if gs==nil then gr()else gr(1)end else g7()end end else c2="Disengage autopilot before changing Interplanetary Helper"fV("iph","AP")end end;local function gt()local function gu(gv)local gw;if gv then gw=da else gw=bq end;local gx=-1;gx=g3(e[0])if gx>-1 then table.remove(e[0],gx)end;gx=-1;gx=g3(gw)if gx~=-1 then c2=g6.name.." saved location cleared"table.remove(gw,gx)end;gr()f_()return gw end;if string.sub(bk,1,1)=="*"then da=gu(true)else bq=gu(false)end end;local function gy(gz,fY,gA,gB)local function gC(gv)if gv then gw=da else gw=bq end;if dbHud_1 or gA or gv then local di=fX(fY)local gD={position=fY,name=gz,planetname=di.name,gravity=b.getGravityIntensity(),safe=gB}if not gA then gw[#gw+1]=gD else for dM,dy in pairs(e[0])do if dy.name and gz==dy.name then table.remove(e[0],dM)end end end;table.insert(e[0],gD)f_()g7()c2="Location saved as "..gz.."("..di.name..")"return gw else c2="Databank must be installed to save permanent locations"end end;if string.sub(gz,1,1)=="*"then da=gC(true)else bq=gC(false)end end;local gE={}function gE.UpdateAtlasLocationsList()f_()end;function gE.UpdateAutopilotTarget()g7()end;function gE.adjustAutopilotTargetIndex(gs)gr(gs)end;function gE.findAtlasIndex(g4,g5)return g3(g4,g5)end;function gE.UpdatePosition(gF,gG,gH)local function gI(gv)local gw;if gv then gw=da else gw=bq end;local gx=g3(gw)if gx~=-1 then if gF~=nil then if gv then gF="*"..gF end;gw[gx].name=gF;bm=bm-1;gr()elseif gH~=nil then if gH then local gJ=ch;if gJ<1000 then gJ=1000 end;gw[gx].agg=fW(gJ,0)c2=gw[gx].name.." AGG Altitude:"..gw[gx].agg.." saved ("..gw[gx].planetname..")"return elseif gH==false then gw[gx].agg=nil;c2=gw[gx].name.." AGG Altitude cleared ("..gw[gx].planetname..")"return end else local gK=gw[gx]if gG then gK.heading=cJ:cross(cN)*5000;c2=gw[gx].name.." heading saved ("..gw[gx].planetname..")"return elseif gG==false then gK.heading=nil;c2=gw[gx].name.." heading cleared ("..gw[gx].planetname..")"return end;gK.gravity=b.getGravityIntensity()gK.position=cP;gK.safe=true end;c2=gw[gx].name.." position updated ("..gw[gx].planetname..")"else c2="Name Not Found"end end;if string.sub(bk,1,1)=="*"then gI(true)else gI(false)end end;function gE.AddNewLocation(gz,fY,gA,gB)gy(gz,fY,gA,gB)end;function gE.ClearCurrentPosition()gt()end;for dM,dy in pairs(db)do table.insert(e[0],dy)end;if gL then for dM,dy in pairs(gL)do gE[dM]=dy end end;f_()if bm>#cV then bm=0 end;gE.UpdateAutopilotTarget()return gE end;local function gM(b,a,c,radar_1,radar_2,warpdrive,e_,gN,dp,gO,dn,gP,fV)local gQ={}local gR={}local gS={XS=13,S=27,M=55,L=110,XL=221}local gT={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gU={}local gV=0;local gW;local gX;local gY;local gZ;local g_={gZ}local h0="Atmo"local h1;local h2;local h3=0;local h4={}local h5;local h6=0;local vec3=vec3;local h7=table.insert;local h8=-4;local h9={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local ha,hb;local hc,hd;local function he()if hf~=nil and h3==0 then gN(hf)a.destroyWidget(ha)a.destroyData(hc)ha,hc,hf=nil,nil,nil;if h2~=nil then gN(h2)a.destroyWidget(hb)a.destroyData(hd)h2,hb,hd=nil,nil,nil end else if h3==1 then gN(hf)hf=nil;h2=a.createWidgetPanel("PeriWinkle")hb=a.createWidget(h2,'periscope')hd=gZ.getWidgetDataId()a.addDataToWidget(hd,hb)end;if hf==nil and gV>0 then hf=a.createWidgetPanel(h0)ha=a.createWidget(hf,'radar')hc=gZ.getWidgetDataId()a.addDataToWidget(hc,ha)end;h3=0 end end;local function hg()local function hh(hi,hj,hk,hl,hm,hn,ho,hp)hj,hl,hn,hp=vec3(hj),vec3(hl),vec3(hn),vec3(hp)local hq,hr,hs=hi*hi,hk*hk,hm*hm;local fy=hl-hj;local ht=fy:normalize()local hu=fy:len()local hv=hn-hj;local hw=(hv-hv:project_on(ht)):normalize()local hx,hy=hv:dot(ht),hv:dot(hw)local hz=hx*hx+hy*hy;local hA=ht:cross(hw)local hB=(hq-hr+hu*hu)/(2*hu)local hC=(hq-hs+hz-2*hx*hB)/(2*hy)local dA=hq-hB^2-hC^2;local hD=dp(dA)local hE=hj+ht*hB+hw*hC+hA*hD;local hF=hj+ht*hB+hw*hC-hA*hD;if e_((hp-hE):len()-ho)<e_((hp-hF):len()-ho)then return hE else return hF end end;local function hG(hH,fz,hI)local hJ=hH.pts;local gx=#hJ;local hK=hH.ref;if gx>3 then local hL,hM,hN,hO=hJ[gx],hJ[gx-1],hJ[gx-2],hJ[gx-3]hH.ref=hI;local fw=hh(hL[1],hL[2],hM[1],hM[2],hN[1],hN[2],hO[1],hO[2])local hB,hC,hD=fw.x,fw.y,fw.z;if hB==hB and hC==hC and hD==hD then hB=hB+hK[1]hC=hC+hK[2]hD=hD+hK[3]local hP=vec3(hB,hC,hD)hH.center=hP;if hH.lastPos then if(hH.lastPos-hP):len()<2 then local hQ=(hP-vec3(hI)):len()if e_(hQ-fz)<10 then hH.skipCalc=true end end end;hH.lastPos=hP end;hH.pts={}else local hR={hI[1]-hK[1],hI[2]-hK[2],hI[3]-hK[3]}hJ[gx+1]={fz,hR}end end;if radar_1 or radar_2 then cv.assignRadar()end;if gZ then gV=#gZ.getConstructIds()if gV>0 then local hS=h5:gmatch('{"constructId[^}]*}[^}]*}')local hT=gZ.hasMatchingTransponder;local hU=gZ.getConstructKind;local hV=gZ.isConstructAbandoned;local hW=gZ.getConstructName;local hI={cP["x"],cP["y"],cP["z"]}local hX,hY=0,0;local hZ=cM*10;local cZ=cZ;gY,gX=0,0;gR={}for dy in hS do local dW,ca,h_=dy:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local i0=gS[h_]ca=dn(ca)if hT(dW)==1 then h7(gR,dW)end;if not cW and warpdrive and ca<a9 and warpdrive.getStatus()==15 then c2="INITIATING WARP"c3=7;warpdrive.initiate()end;if E then local i1=hU(dW)local i2=F and hV(dW)==1;if i2 or ca<hZ and(i0>27 or i1==4 or i1==6)then gY=gY+1;local gz=hW(dW)local hH=h4[dW]if hH==nil then i0=i0+gP;h4[dW]={pts={},ref=hI,name=gz,i=0,radius=i0,skipCalc=false}hH=h4[dW]end;if not hH.skipCalc then hG(hH,ca,hI)if i2 and not hH.abandoned and hH.center then local bP=a.getArkTime()if h6+5<bP then h6=bP;fV("abRdr","RD")end;a.print("Abandoned Construct: "..gz.." ("..h_.." "..gT[i1]..") at estimated ::pos{0,0,"..hH.center.x..","..hH.center.y..","..hH.center.z.."}")c2="Abandoned Radar Contact ("..h_.." "..gT[i1]..") detected"hH.abandoned=true end;hY=hY+1 else h7(gU,hH)end end;hX=hX+1;if cZ and hX>700 or hY>70 or(not cZ and hX>300 or hY>30)then coroutine.yield()hX,hY=0,0 end end end;gX=#gU;if gX>0 and(cM>20 or b7)then local et,i3,i4,i5;local i6=0;local i7=cp:getPlanetarySystem(0)i5=cL:normalize()while i6<gX do coroutine.yield()local i8={table.unpack(gU,i6,math.min(i6+75,gX))}et,i3,i4=i7:castIntersections(cP,i5,nil,nil,i8,true)if et and i4 then d0={et,i3,i4}break end;i6=i6+75 end;if not et then d0=nil end else d0=nil end;gU={}gW=h5:find('identifiedConstructs":%[%]')end end end;local function i9()if gZ then h0="Atmo"if h5:find('worksInAtmosphere":false')then h0="Space"end end end;function gQ.pickType()i9()end;function gQ.assignRadar()if radar_2 and h8~=1 then if h8==-1 then if gZ==radar_2 then gZ=radar_1 else gZ=radar_2 end end;g_={gZ}h5=gZ.getWidgetData()i9()else h5=gZ.getWidgetData()end;h8=gZ.getOperationalState()end;function gQ.UpdateRadar()local ia=coroutine.status(h1)if ia=="suspended"then local dN,ib=coroutine.resume(h1)if ib then a.print("ERROR UPDATE RADAR: "..ib)end elseif ia=="dead"then h1=coroutine.create(hg)local dN,ib=coroutine.resume(h1)end end;function gQ.GetRadarHud(ic,id,ax,ay)local ie,dj;local dE=gX or 0;if gV>0 then if E then dj=dE.."/"..gY.." Plotted : "..gV-gY.." Ignored"else dj="Radar Contacts: "..gV end;ie=gO(ax,ay,dj,"pbright txtbig txtmid")if#gR>0 then ie=ie..gO(ic,id,"Friendlies In Range","pbright txtbig txtmid")for dM,dy in pairs(gR)do id=id+20;ie=ie..gO(ic,id,gZ.getConstructName(dy),"pdim txtmid")end end;if gW==nil and h2==nil then h3=1;cv.ToggleRadarPanel()end;if gW~=nil and h2~=nil then cv.ToggleRadarPanel()end;if hf==nil then cv.ToggleRadarPanel()end else if h8~=1 then ie=gO(ax,ay,h0 .." Radar: "..h9[h8],"pbright txtbig txtmid")else ie=gO(ax,ay,"Radar: No "..h0 .." Contacts","pbright txtbig txtmid")end;if hf~=nil then h3=0;cv.ToggleRadarPanel()end end;return ie end;function gQ.GetClosestName(gz)if gZ then local dW,dR=gZ.getWidgetData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dW~=nil and dW~=""then gz=gz.." "..gZ.getConstructName(dW)end end;return gz end;function gQ.ToggleRadarPanel()he()end;function gQ.ContactTick()if not ig then ig=0 end;if bP>ig+10 then c2="Radar Contact"fV("rdrCon","RC")ig=bP end;c.stopTimer("contact")end;function gQ.onEnter(dW)if gZ and not cf and not cW then c.setTimer("contact",0.1)end end;function gQ.onLeave(dW)if gZ and E then if#h4>650 then dW=tostring(dW)h4[dW]=nil end end end;local function ih()gZ=nil;if radar_2 and radar_2.getOperationalState()==1 then gZ=radar_2 else gZ=radar_1 end;h8=gZ.getOperationalState()g_={gZ}h5=gZ.getWidgetData()i9()h1=coroutine.create(hg)if ii then for dM,dy in pairs(ii)do gQ[dM]=dy end end end;ih()return gQ end;local function ij(shield,e5,bM)local ik={}local il=shield.getResistancesCooldown()local function im()local io=shield.isActive()if G then if not cW and io==0 and shield.isVenting()~=1 then shield.toggle()elseif cW and io==1 then shield.toggle()end end end;local function ip()local iq=shield.getStressRatioRaw()local ir=0.5999;if iq[1]==0.0 and iq[2]==0.0 and iq[3]==0.0 and iq[4]==0.0 then return end;local is=shield.setResistances(ir*iq[1],ir*iq[2],ir*iq[3],ir*iq[4])if is==1 then c2="Shield Resistances updated"else c2="Value Exceeded. Failed to update Shield Resistances"end end;function ik.shieldTick()dh=bM(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())im()il=shield.getResistancesCooldown()if il==0 and dh<a8 then ip()end end;function ik.setResist(it)if not shield then c2="No shield found"return elseif it==nil or il>0 then c2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF=dE..', '..dE..', '..dE..', '..dE;local iu,iv,iw,ix=e5(it,dF)if ix==nil or iu+iv+iw+ix>0.6 then c2="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(iu,iv,iw,ix)==1 then c2="Shield Resistances set"else c2="Resistance setting failed."end end;function ik.ventShield()local iy=shield.getVentingCooldown()if iy>0 then c2="Cannot vent again for "..iy.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c2="Shields already at max hitpoints"end end;if iz then for dM,dy in pairs(iz)do ik[dM]=dy end end;return ik end;local function iA(d,b,c,a,e,antigrav,hover,shield,warpdrive,iB,e_,bM,dl,iC,bN,iD,iE,eV,bL,dm,iF,fU,fT,gN,iG,dp,fW,gO,fV,iH,iI,iJ,iK,iL,iM)local bO=DUConstruct;local iN=9.80665;local iO={}local iP={}local iQ={}local iR={}local iS=nil;local iT=nil;local iU=nil;local iV=false;local iW="none"local iX=""local iY=55;local iZ=0;local i_=0;local j0=nil;local j1=af;local j2=ag;local j3=ah;local j4=[[rgb(]]..bM(j1+0.5)..","..bM(j2+0.5)..","..bM(j3+0.5)..[[)]]local j5=[[rgb(]]..bM(j1*0.9+0.5)..","..bM(j2*0.9+0.5)..","..bM(j3*0.9+0.5)..[[)]]local j6=0;local j7=0;local j8=""local j9=bL()local ja=false;local jb=false;local function jc(dy)if ck==1920 then return dy else return fW(ck*dy/1920,0)end end;local function jd(dy)if cl==1080 then return dy else return fW(cl*dy/1080,0)end end;local function je()return iG()==0 and g~="keyboard"and iE()==0 end;local function jf()local jg="TRAVEL"if not cS then jg="CRUISE"end;if b4 then jg="AUTOPILOT"end;return jg end;local ie=""local jh=""local ji=""local jj=1;local jk=2;local jl=3;local jm=4;local jn=5;local jo=6;local jp=7;local jq=""local jr=0;local js=120.0*aU;local jt={}local ju={}local jv={}local jw={}local jx={}local jy={}local jz={}jz["atmofueltank"],jz["spacefueltank"],jz["rocketfueltank"]=0,0,0;local jA=0;local function jB(hB,jC,jD,jE,jF,jG)local jH=jA;local jI=jA+5;if not B then jI=jI+5 end;if iE()==1 and not l then jH=jH-50;jI=jI-50 end;if jD=="ATMO"then jq="atmofueltank"elseif jD=="SPACE"then jq="spacefueltank"else jq="rocketfueltank"end;jr=_G[jq.."_size"]if#jE>0 then for M=1,#jE do local gz=jE[M][jk]local jJ=jE[M][jp]for jK=1,jr do if jE[M][jk]==iC(c[jq.."_"..jK].getWidgetData()).name then jJ=jK;break end end;local jL=bL()if jF[M]==nil or jG[M]==nil or jL-jE[M][jo]>js then local jM;local jN=0;jN=iD(jE[M][jj])-jE[M][jm]jM=jE[M][jn]if jM>jN then jz[jq]=jz[jq]+jM-jN end;if jJ~=0 then local jO=iC(c[jq.."_"..jJ].getWidgetData())jG[M]=jO.percentage;jF[M]=jO.timeLeft;if jF[M]=="n/a"then jF[M]=0 end else jG[M]=bM(0.5+jN*100/jE[M][jl])if jM<=jN then jF[M]=0 else jF[M]=bM(0.5+jN/((jM-jN)/(jL-jE[M][jo])))end end;jE[M][jo]=jL;jE[M][jn]=jN end;if gz==jC then gz=dl("%s %d",jD,M)end;if jJ==0 then gz=gz.." *"end;local jP;if jF[M]==0 then jP=""else jP=iK(jF[M])end;if jG[M]~=nil then local jQ=bM(jG[M]*2.55)local jR=dl("rgb(%d,%d,%d)",255-jQ,jQ,0)local jS=""if jP~=""and jF[M]<120 or jG[M]<5 then jS="red "end;local jT=dl("rgb(%d,%d,%d)",dm(bM((255-jQ)/2.55),50,100),dm(bM(jQ/2.55),0,50),50)local jU="rgb(196,0,255)"if jD=="ATMO"then jU="rgb(0,188,255)"elseif jD=="SPACE"then jU="rgb(239,255,0)"end;local jV=false;if jW~=jU then jV=true end;jW=jU;if B then if jV then jH=jH-5;jI=jI-5 end;jh=jh..dl([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jT,jU,hB,jI,jR,bM(jG[M]*1.7+0.5)-2,hB+1,jI+1,hB+5,jI+14,gz,jG[M],jP)jH=jH-22;jI=jI-22 else jh=jh..gO(hB,jH,gz,jS.."pdim txtfuel")jh=jh..gO(hB,jI,dl("%d%% %s",jG[M],jP),"pdim txtfuel","fill:"..jR)jH=jH+30;jI=jI+30 end end end end;jA=jH end;local function jX(jY,e4)if ap==0 and aq==0 then return end;if e4<200000 and not cf or e4 and cf then local jZ=0;if e_(cO)>1 then jZ=45*math.log(e_(cO),10)if cO<0 then jZ=-jZ end end;jY[#jY+1]=dl([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bM(cO),bM(jZ))end;return jY end;local function j_(k0)local gs=-cN;k0=k0-k0:project_on(gs)local k1=vec3(0,0,1)k1=k1-k1:project_on(gs)local k2=k1:cross(gs)local jZ=k1:angle_between(k0)*constants.rad2deg;if k0:dot(k2)<0 then jZ=360-jZ end;return jZ end;local function k3(jY,al,am,k4,k5,cZ)if ae==0 then return end;local k6=ae;local k7=20;local k8=bM(k4)if cZ then for M=-45,45,5 do local k9=M;jY[#jY+1]=dl([[<g transform="rotate(%f,%d,%d)">]],k9,al,am)ka=5;if M%15==0 then ka=15 elseif M%10==0 then ka=10 end;jY[#jY+1]=dl([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+k6+k7-ka,al,am+k6+k7)end;jY[#jY+1]=gO(al,am+k6+k7-35,k5,"pdim txt txtmid")jY[#jY+1]=gO(al,am+k6+k7-25,k8 .." deg","pdim txt txtmid")jY[#jY+1]=dl([[<g transform="rotate(%f,%d,%d)">]],-k4,al,am)jY[#jY+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+k6+k7-20,al+5,am+k6+k7-20,al,am+k6+k7-15)jY[#jY+1]="</g>"end;jY[#jY+1]=[[<g style="clip-path: url(#headingClip);">]]local kb=k8;if cZ then kb=j_(cI)end;local kc=20;local kd=bM(kb)local ke=0;local kf=am+k6+k7+20;local kg=al;if k5~="YAW"then kf=jd(130)kg=jc(960)end;local kh=[[<path class="txttick line" d="]]local ki=bM(kd-(kc+10)-kd%5+0.5)for M=ki+70,ki,-5 do local hB=kg-(-M*5+kb*5)if M%10==0 then ke=10;local dE=M;if dE==360 then dE=0 elseif dE>360 then dE=dE-360 elseif dE<0 then dE=dE+360 end;jY[#jY+1]=gO(hB,kf+15,dE,"txtmid bright")elseif M%5==0 then ke=5 end;if ke==10 then kh=dl([[%s M %f %f v %d]],kh,hB,kf-5,ke)else kh=dl([[%s M %f %f v %d]],kh,hB,kf-2.5,ke)end end;jY[#jY+1]=kh..[["/>]]jY[#jY+1]=dl([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kg-5,kf-20,kg+5,kf-20,kg,kf-10)if cZ then k5="HDG"end;jY[#jY+1]=gO(jc(960),jd(100),kd.."Â°","dim txt txtmid size14","")jY[#jY+1]=gO(jc(960),jd(85),k5,"dim txt txtmid size20","")jY[#jY+1]=[[</g>]]end;local function kj(jY,kk,k4,al,am,cZ,kl,fq)if ae==0 then return end;local k6=ae;local km=bM(k6*3/5)if k6>0 then local kn=bM(kk)local ka=0;local kh=dl([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k4,al,am)if not cf then kh=dl([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;jY[#jY+1]=dl([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k6-1,al,am)jY[#jY+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bM(kn-30-kn%5+0.5),bM(kn+30+kn%5+0.5),5 do if M%10==0 then ka=30 elseif M%5==0 then ka=20 end;local hC=am+-M*5+kk*5;if ka==30 then kh=dl([[%s M %d %f h %d]],kh,al-km-ka,hC,ka)if cf then jY[#jY+1]=dl([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k4,al,am,al-km+10,hC+4,M)jY[#jY+1]=dl([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k4,al,am,al+km-10,hC+4,M)if M==0 or M==180 or M==-180 then jY[#jY+1]=dl([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k4,al,am,al-km+20,hC,km*2-40)end else jY[#jY+1]=gO(al-km+10,hC,M,"pdim txt txtmid")jY[#jY+1]=gO(al+km-10,hC,M,"pdim txt txtmid")end;kh=dl([[%s M %d %f h %d]],kh,al+km,hC,ka)else kh=dl([[%s M %d %f h %d]],kh,al-km-ka,hC,ka)kh=dl([[%s M %d %f h %d]],kh,al+km,hC,ka)end end;jY[#jY+1]=kh..[["/>]]local ko="PITCH"if not cZ then ko="REL PITCH"end;if kk>90 and not cf then kk=90-(kk-90)elseif kk<-90 and not cf then kk=-90-(kk+90)end;if k6>200 then if cf then if fq>iY then jY[#jY+1]=gO(al,am-15,"Yaw","pdim txt txtmid")jY[#jY+1]=gO(al,am+20,kl,"pdim txt txtmid")end;jY[#jY+1]=dl([[<g transform="rotate(%f,%d,%d)">]],-k4,al,am)else jY[#jY+1]=dl([[<g transform="rotate(0,%d,%d)">]],al,am)end;jY[#jY+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-km+25,am-5,al-km+20,am,al-km+25,am+5,al-km+50,am+4,kn)jY[#jY+1]=dl([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+km-25,am-5,al+km-20,am,al+km-25,am+5,al+km-30,am+4,kn)jY[#jY+1]="</g>"end;local kp=bM(k6/3)jY[#jY+1]=dl([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-kp,am,k6-kp)if not cf and cZ then jY[#jY+1]=dl([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k4,al,am,al-km+10,am,km*2-20)end;jY[#jY+1]="</g>"if k6<200 then if cf and fq>iY then jY[#jY+1]=gO(al,am-k6,ko,"pdim txt txtmid")jY[#jY+1]=gO(al,am-k6+10,kn,"pdim txt txtmid")jY[#jY+1]=gO(al,am-15,"Yaw","pdim txt txtmid")jY[#jY+1]=gO(al,am+20,kl,"pdim txt txtmid")else jY[#jY+1]=gO(al,am-k6,ko,"pdim txt txtmid")jY[#jY+1]=gO(al,am-k6+15,kn,"pdim txt txtmid")end end end end;local function kq(jY,e4,cZ)local kr=ar;local ks=as;if kr==0 and ks==0 then return end;local kt=78;local ku=19;local kv=ce;if ce~=-1 then jY[#jY+1]=gO(kr+kt,ks+ku+20,dl("AGL: %.1fm",ce),"pdim altsm txtend")end;if cZ and(e4<200000 and not cf or e4 and cf)then table.insert(jY,dl([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kr-1,ks-4,kt+2,ku+6,kr+1,ks-1,kt-4,ku))local gx=0;local kw=1;local kx=0;local ky=e4<0;local kz=e4<kA.surfaceMaxAltitude;local kB=9;if ky then kB=0 end;local e4=e_(e4)while gx<6 do local kC=11;local kD=16;local kE=9;local kF=14;local jS="altsm"if gx>2 then kD=kD+3;kC=kC+2;kF=kF+2;kE=kE-6;jS="altbig"end;if ky then jS=jS.." red"elseif kz then jS=jS.." orange"end;local kG=e4/kw%10;local kH=bM(kG)local kI=bM((kH+1)%10)local kJ=kx;if gx==0 then kJ=kG-kH;if ky then kJ=1-kJ end end;if ky and(gx==0 or kx~=0)then local gA=kI;kI=kH;kH=gA end;local kK=kD*(kJ-1)local kL=kK+kD;local hB=kr+kE+(6-gx)*kC;local hC=ks+kF;jY[#jY+1]=gO(hB,hC+kK,kI,jS)jY[#jY+1]=gO(hB,hC+kL,kH,jS)gx=gx+1;kw=kw*10;if kH==kB then kx=kJ else kx=0 end end;table.insert(jY,[[</g></g>]])end end;local function kM(fv)local kN=-math.deg(eV(fv.y,fv.z))+180;kN=kN-90;if kN<0 then kN=360+kN end;if kN>180 then kN=-180+kN-180 end;return-kN end;local function kO(fv)local kb=math.deg(eV(fv.y,fv.x))-90;if kb<-180 then kb=360+kb end;return kb end;local function kP(jY,fv,fq,al,am)if fq>5 and not cf or fq>iY then local k6=ae;local kQ=20;local kR=20;local kS=kM(fv)local kT=kO(fv)local kU=14;local kV=kU/2;local kW=-kT/kR*k6;local kX=kS/kQ*k6;local hB=al+kW;local hC=am+kX;local ca=dp(kW^2+kX^2)local kY=[[<circle
                            cx="]]..hB..[["
                            cy="]]..hC..[["
                            r="]]..kV/kU..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hB..[["
                            cy="]]..hC..[["
                            r="]]..kV..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hB-kU..[[,]]..hC..[[ h ]]..kV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hB+kV..[[,]]..hC..[[ h ]]..kV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hB..[[,]]..hC-kU..[[ v ]]..kV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ca<k6 then jY[#jY+1]=kY else local jZ=eV(kX,kW)local kZ=4;local k_=al+k6*math.cos(jZ)local l0=am+k6*math.sin(jZ)jY[#jY+1]=dl('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jZ*180/math.pi,k_,l0,k_-kZ,l0-kZ/2,kZ*2,kZ,k_+kZ,l0-kZ,kZ,kZ,-kZ,kZ)end;if not cf then local l1=vec3(fv)kS=kM(-l1)kT=kO(-l1)kW=-kT/kR*k6;kX=kS/kQ*k6;hB=al+kW;hC=am+kX;ca=dp(kW^2+kX^2)if ca<k6 then local l2=[[<circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hB..[[,]]..hC-kU..[[ v ]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hB..[[,]]..hC..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hB..[[,]]..hC..[[)" />
                                <path
                                    d="M ]]..hB-kV..[[,]]..hC..[[ h ]]..kU..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hB..[[,]]..hC..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hB..[[,]]..hC..[[)"/>]]jY[#jY+1]=l2 end end end end;local function l3(jY,jg,l4,l5)if an==0 and ao==0 then return end;l4=bM(l4+0.5)local jH=ao+10;local jI=ao+20;if iE()==1 and not l then jH=55;jI=65 end;local l6="CRUISE"local c="km/h"local dN=l5;if jg=="TRAVEL"or jg=="AUTOPILOT"then l6="THROT"c="%"dN=l4;local l7="dim"if l4<0 then l7="red"end;jY[#jY+1]=dl([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l7,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-e_(l4),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;jY[#jY+1]=gO(an+10,jH,l6,"pbright txtstart")jY[#jY+1]=gO(an+10,jI,dl("%.0f %s",dN,c),"pbright txtstart")if cf and t and cS and bS then l4=bM(bT*100+0.5)local l7="red"if l4<0 then l7="red"end;jY[#jY+1]=dl([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l7,1-e_(l4),an-10,ao+50,an-15,ao+53,an-15,ao+47)jY[#jY+1]=gO(an+10,jH+40,"LIMIT","pbright txtstart")jY[#jY+1]=gO(an+10,jI+40,l4 .."%","pbright txtstart")end;if cf and t or b9 then jY[#jY+1]=gO(an+10,jH-40,"LIMIT: "..cC.." km/h","dim txtstart")elseif not cf and b4 then jY[#jY+1]=gO(an+10,jH-40,"LIMIT: "..bM(ab*3.6+0.5).." km/h","dim txtstart")end end;local function l8(jY,l9)if an==0 and ao==0 then return end;local la=ao-10;local lb=an+10;jY[#jY+1]=gO(0,0,"","pdim txt txtend")if iE()==1 and not l then la=75 end;jY[#jY+1]=gO(lb,la,bM(l9).." km/h","pbright txtbig txtstart")end;local lc=40;local function ld(jY)jY[#jY+1]=gO(jc(150),jd(1070),dl("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jY[#jY+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jY[#jY+1]=gO(jc(960),jd(550),"Warning: Invalid Control Scheme Detected","warnings")jY[#jY+1]=gO(jc(960),jd(600),"Keyboard Scheme must be selected","warnings")jY[#jY+1]=gO(jc(960),jd(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local le=jc(960)local lf=jd(860)local lg=jd(880)local lh=jd(900)local li=jd(960)local lj=jd(200)local lk=jd(250)local ll=jd(960)if iE()==1 and not l then lf=jd(135)lg=jd(155)lh=jd(175)lj=jd(115)lk=jd(95)end;if b1 then local lm=""if type(b1)=="string"then lm="-"..b1 end;jY[#jY+1]=gO(le,lf,"Brake Engaged"..lm,"warnings")elseif bR>0 then jY[#jY+1]=gO(le,lf,"Auto-Brake Engaged","warnings","opacity:"..bR)end;if cf and cB and ce==-1 then if not b4 and not br and not b7 and not cR and not ba and not b8 then jY[#jY+1]=gO(le,lj+50,"** STALL WARNING **","warnings")fV("stall","SW",2)end end;if cY then jY[#jY+1]=gO(le,lj+90,"Flight Assist in Progress","warnings")end;if cj then jY[#jY+1]=gO(le,ll,"Gyro Enabled","warnings")end;if ln then lc=lc-1;if lc>20 then jY[#jY+1]=gO(le,ll-20,"ECU Enabled","warnings")elseif lc<0 then lc=40 end end;if bn then if bV then jY[#jY+1]=gO(le,lg,"Gear Extended","warn")else jY[#jY+1]=gO(le,lg,"Landed (G: Takeoff)","warnings")end end;if ce>-1 and(not cR or ch<100)then local lo=iJ(d:getTargetGroundAltitude())jY[#jY+1]=gO(le,lh,"Hover Height: "..lo,"warn")end;if c4 then jY[#jY+1]=gO(le,li+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not q and cR and bw~=nil then local lp="warnings"if e_(ch-antigrav.getBaseAltitude())<501 then lp="warn"end;jY[#jY+1]=gO(le,lj+40,dl("Target Altitude: %d Singularity Altitude: %d",bM(bw),bM(antigrav.getBaseAltitude())),lp)end;if b4 and bk~="None"then jY[#jY+1]=gO(le,lj,"Autopilot "..bh,"warn")elseif bu~=nil then jY[#jY+1]=gO(le,lj+20,dl("LockedPitch: %d",bM(bu)),"warn")elseif b_ then jY[#jY+1]=gO(le,lj+20,"Follow Mode Engaged","warn")elseif b9 or cd then jY[#jY+1]=gO(le,lj+20,"Re-entry in Progress","warn")end;if b6 or ba then local lo=iJ(bb,2)if ba then if cR then lo=iJ(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jY[#jY+1]=gO(le,lj,"VTO to "..lo,"warn")elseif b8 and not bA then if cc then jY[#jY+1]=gO(le,lj,"Takeoff to "..bk,"warn")else jY[#jY+1]=gO(le,lj,"Takeoff to "..lo,"warn")end;if b1 and not ba then jY[#jY+1]=gO(le,lj+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jY[#jY+1]=gO(le,lj,"Altitude Hold: "..dl("%.1fm",bb),"warn")end end;if ba and(antigrav~=nil and antigrav)then if cg>0.1 then jY[#jY+1]=gO(le,lj+20,"Beginning ascent","warn")elseif cg<0.09 and cg>0.05 then jY[#jY+1]=gO(le,lj+20,"Aligning trajectory","warn")elseif cg<0.05 then jY[#jY+1]=gO(le,lj+20,"Leaving atmosphere","warn")end end;if bA then if cD~=nil then jY[#jY+1]=gO(le,lj,cD,"warn")end end;if b7 then if lq then local lr="Brake Landing"if dd then lr=lr.."-Aligning"end;if dc then lr=lr.."-Drift Limited"end;jY[#jY+1]=gO(le,lj,lr,"warnings")else jY[#jY+1]=gO(le,lj,"Coast-Landing","warnings")end end;if b3 then jY[#jY+1]=gO(le,lj,"Prograde Alignment","crit")end;if b2 then jY[#jY+1]=gO(le,lj,"Retrograde Alignment","crit")end;if c_ then local type;if string.find(c_,"COLLISION")then type="warnings"else type="crit"end;jY[#jY+1]=gO(le,lk+20,c_,type)elseif cg==0 then local ls,lt=cu.checkLOS(cL:normalize())if lt~=nil then local lo=iJ(lt)local lu=cq.computeTravelTime(cM,0,lt)local lv="Collision"if ls.noAtmosphericDensityAltitude>0 then lv="Atmosphere"end;jY[#jY+1]=gO(le,lk+20,ls.name.." "..lv.." "..iK(lu).." In "..lo,"crit")end end;if br and not bA then jY[#jY+1]=gO(le,lj+60,lw,"warn")end;if d3 and#d3>1 then end;local lx=jc;local ly=jd;local lz="topButton"local lA="topButtonActive"local lB=lz;if b4 or br or cc or bA then lB=lA end;local lC=lz;if b3 then lC=lA end;local lD=lz;if b7 or bn then lD=lA end;local lE=lz;if b6 or br then lE=lA end;local lF=lz;if b2 then lF=lA end;local lG=lz;if bA or cF and b4 then lG=lA end;if w and I then local lH=ly(30)jY[#jY+1]=dl([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lB,lx(960),ly(54),ly(-53),lx(-120),lx(25),ly(50))jY[#jY+1]=gO(lx(910),lH,"AUTOPILOT")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lC,lx(865),ly(51),lx(-25),ly(-50),lx(-110),lx(25),ly(46))jY[#jY+1]=gO(lx(800),lH,"PROGRADE")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,lx(755),ly(47),lx(-25),ly(-46),lx(-98),lx(44),ly(44))jY[#jY+1]=gO(lx(700),lH,"LAND")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lE,lx(960),ly(54),ly(-53),lx(120),lx(-25),ly(50))jY[#jY+1]=gO(lx(1010),lH,"ALT HOLD")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lx(1055),ly(51),lx(25),ly(-50),lx(110),lx(-25),ly(46))jY[#jY+1]=gO(lx(1122),lH,"RETROGRADE")jY[#jY+1]=dl([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lx(1165),ly(47),lx(25),ly(-46),lx(98),lx(-44),ly(44))jY[#jY+1]=gO(lx(1220),lH,"ORBIT")jY[#jY+1]=[[
                                    </g>
                                </g>]]jY[#jY+1]="</g>"end;return jY end;local function lI(fq)return bM(fW(fq*3.6,0)+0.5).." km/h"end;local function lJ(gx)local gz=bk;if gx~=nil and type(gx)=="number"then if gx==0 then return"None"end;gz=cV[gx].name end;if gz==nil then gz=g6.name end;if gz==nil then gz="None"end;return gz end;local function lK(jY)local lL=cu.routeWP(true)if not lL or#lL==0 then return end;local hB=jc(750)local hC=jd(360)if b4 or br then jY[#jY+1]=gO(hB,hC,"REMAINING ROUTE","pdim txtstart size20")else jY[#jY+1]=gO(hB,hC,"LOADED ROUTE","pdim txtstart size20")end;for dM,M in pairs(lL)do hC=hC+20;jY[#jY+1]=gO(hB,hC,dM..". "..lL[dM],"pdim txtstart size20")end end;local function lM(jY)local hB=aB+10;local hC=aC+20;local lN={}local lO={"Alt-4: AutoTakeoff to Target"}local lP={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lQ={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lR={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lN,"--------------DYNAMIC-----------------")if cf then if ce~=-1 then iH(lN,lO)if c7 and kA and c7.name==kA.name then table.insert(lN,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or b0 then if antigrav then if cR then table.insert(lN,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lN,"Turn on AGG to takeoff to AGG Height")end end;if b0 then table.insert(lN,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lN,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lN,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bn then table.insert(lN,"G: Takeoff to hover height, raise gear")else table.insert(lN,"G: Lowergear and Land")end else iH(lN,lP)table.insert(lN,"G: Begin BrakeLanding or Land")end;if ba then table.insert(lN,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iH(lN,lQ)if shield then table.insert(lN,"Alt-Shift-6: Vent shields")if not G then table.insert(lN,"Alt-Shift-7: Toggle shield off/on")end end end;if g6~=nil then table.insert(lN,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lN,"Alt-9: Activate Gyroscope")end;if aX~="none"or aW~="none"or aY~="none"then table.insert(lN,"Alt-Shift-9: Cycles engines with Extra tags")end;if b6 then table.insert(lN,"Alt-Spacebar/C will raise/lower target height")table.insert(lN,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cf then table.insert(lN,"LALT+Mousewheel will lower/raise speed limit")end;iH(lN,lR)for M=1,#lN do hC=hC+12;jY[#jY+1]=gO(hB,hC,lN[M],"pdim txtbig txtstart")end end;local function lS(jY)local lT=aB;local lU=aC;local lV=aA;local lW=4;local lX=15;local hB=0;local hC=0;local lY,lZ,l_,m0;local m1;local function m2(type)local gJ,bP,fq,m3,jS,m4;if type=="Periapsis"then gJ=m1.periapsis.altitude;bP=m1.timeToPeriapsis;fq=m1.periapsis.speed;jS="txtend"m3=12;m4=math.min(hB,lT+lV-kA.radius/l_-lW*2)else gJ=m1.apoapsis.altitude;bP=m1.timeToApoapsis;fq=m1.apoapsis.speed;m3=-12;jS="txtstart"m4=hB end;if cM<1 then bP=0 end;jY[#jY+1]=dl([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m4+m3,hC-5,hB,hC-5)jY[#jY+1]=dl([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m4-m3*4,hC+2,hB,hC+2)jY[#jY+1]=gO(m4,hC,type,jS)hB=m4-m3*2;hC=hC+lX;local lo=iJ(gJ)jY[#jY+1]=gO(hB,hC,lo,jS)hC=hC+lX;jY[#jY+1]=gO(hB,hC,iK(bP),jS)hC=hC+lX;jY[#jY+1]=gO(hB,hC,lI(fq),jS)end;local m5=lV*1.5;if bJ=="INFO"then m5=25*10 end;if bJ=="ORBIT"and ch<kA.spaceEngineMinAltitude then return jY end;if bJ~="HIDE"then jY[#jY+1]=[[<g class="pbright txtorb txtmid">]]jY[#jY+1]=dl('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lV*2,m5,lT,lU)jY[#jY+1]=dl([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lV*2,m5,lT,lU)end;local m6=lV*1.5;local m7=lV*2;local m8=m6/2;local m9=lV;local ma=lT+m9;local mb=lU+m8;local mc=lT+m7;local md=lU+m6;if bJ=="ORBIT"then lU=lU+lW;lY=lV/2;m0=0;m1={}m1.periapsis={}m1.apoapsis={}if fu~=nil then if fu.periapsis~=nil then m1.periapsis.altitude=fu.periapsis.altitude;m1.periapsis.speed=fu.periapsis.speed end;if fu.apoapsis~=nil then m1.apoapsis.altitude=fu.apoapsis.altitude;m1.apoapsis.speed=fu.apoapsis.speed end;m1.period=fu.period;m1.eccentricity=fu.eccentricity;m1.timeToApoapsis=fu.timeToApoapsis;m1.timeToPeriapsis=fu.timeToPeriapsis;m1.eccentricAnomaly=fu.eccentricAnomaly;m1.trueAnomaly=fu.trueAnomaly end;if m1.periapsis==nil then m1.periapsis={}m1.periapsis.altitude=-kA.radius;m1.periapsis.speed=ab end;if m1.eccentricity==nil then m1.eccentricity=1 end;if m1.apoapsis==nil then m1.apoapsis={}m1.apoapsis.altitude=ch;m1.apoapsis.speed=0 end;if cM<1 then m1.apoapsis.altitude=ch;m1.apoapsis.speed=0 end;if m1.apoapsis.altitude then l_=(m1.apoapsis.altitude+m1.periapsis.altitude+kA.radius*2)/(lY*2)lZ=(kA.radius+m1.apoapsis.altitude)/l_*(1-m1.eccentricity)m0=lY-m1.periapsis.altitude/l_-kA.radius/l_;local me=math.pi;if m1.period~=nil and m1.period>0 and m1.timeToApoapsis~=nil then me=m1.eccentricAnomaly;if m1.timeToPeriapsis<m1.timeToApoapsis then me=2*math.pi-me end end;if cM<1 or me~=me then me=math.pi end;local mf=-lY*math.cos(me)+lT+m9+lW;local mg=lZ*math.sin(me)+lU+m8+lW;local mh=""jY[#jY+1]='<g clip-path="url(#orbitRect)">'jY[#jY+1]=dl([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mh,lT+lV+lW,lU+lV*1.5/2+lW,lY,lZ)if lZ<1 then jY[#jY+1]=dl([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lT+lV+lW-m0,lU+lV*1.5/2+lW,mf,mg)end;jY[#jY+1]=dl('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lT+lV+lW-m0,lU+lV*1.5/2+lW,(kA.radius+kA.noAtmosphericDensityAltitude)/l_)jY[#jY+1]=dl('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lT+lV+lW-m0,lU+lV*1.5/2+lW,(kA.radius+kA.noAtmosphericDensityAltitude)/l_)jY[#jY+1]=dl([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lT+lV+lW,lU+lV*1.5/2+lW,lY,lZ)jY[#jY+1]=dl('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lT+lV+lW-m0,lU+lV*1.5/2+lW,kA.radius/l_)jY[#jY+1]='</g>'local mi=math.floor(kA.radius/l_+0.5)hB=lT+lV+lW*4+lY;hC=lU+lV*1.5/2+5+lW;if m1.apoapsis~=nil and m1.apoapsis.speed<ab then m2("Apoapsis")end;hC=lU+lV*1.5/2+5+lW;hB=lT+lV-lW*2-lY;if m1.periapsis~=nil and m1.periapsis.speed<ab and m1.periapsis.altitude>0 then m2("Periapsis")end;jY[#jY+1]=gO(lT+lV+lW,lU+20+lW,kA.name,"txtorbbig")jY[#jY+1]=dl('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mf,mg)jY[#jY+1]=[[</g>]]return jY else jY[#jY+1]='<g clip-path="url(#orbitRect)">'local mj=""local mk=1.2*(ml-mm)/(lV*2)local mn=1.4*(mo-mp)/(lV*1.5)for dM,dy in pairs(e[0])do if dy.center then local hB=lT+lV+dy.center.x/mk;local hC=lU+lV*1.5/2+dy.center.y/mn;mj=mj..'<circle cx="'..hB..'" cy="'..hC..'" r="'..dy.radius/mk*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dy.name,"Moon")and not string.match(dy.name,"Sanctuary")and not string.match(dy.name,"Space")then mj=mj.."<text x='"..hB.."' y='"..hC+dy.radius/mk*30+20 .."' font-size='12' fill="..j4 .." text-anchor='middle' font-family='Montserrat'>"..dy.name.."</text>"end end end;local fw=vec3(bO.getWorldPosition())local hB=lT+lV+fw.x/mk;local hC=lU+lV*1.5/2+fw.y/mn;mj=mj..'<circle cx="'..hB..'" cy="'..hC..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mj=mj.."<text x='"..hB.."' y='"..hC-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iS=mk;iT=mn;local mq=fw+cL*1000000;local mr=lT+lV+mq.x/mk;local jI=lU+lV*1.5/2+mq.y/mn;mj=mj..'<line x1="'..hB..'" y1="'..hC..'" x2="'..mr..'" y2="'..jI..'" stroke="purple" stroke-width="1"/>'jY[#jY+1]=mj;jY[#jY+1]='</g>'end elseif bJ=="INFO"then jY=cs.DrawOdometer(jY,j6,bo,j7)elseif bJ=="HELP"then jY=lM(jY)elseif bJ=="SCOPE"then jY[#jY+1]='<g clip-path="url(#orbitRect)">'local ms=d6;if cg>0 then table.sort(d5,function(eB,eC)local eD,eE=eB.center,eC.center;return(eD.x-cP.x)^2+(eD.y-cP.y)^2+(eD.z-cP.z)^2<(eE.x-cP.x)^2+(eE.y-cP.y)^2+(eE.z-cP.z)^2 end)end;local mt={}local mu={}local mv=120;local mw=nil;local mx=nil;for M,dy in ipairs(d5)do local gW=dy.center-cP;local my=gW:len()local mz=gW:normalize()local mA=gW:cross(cI):normalize()local mB=math.acos(mA:dot(cJ))if mB~=mB then mB=0 end;if mA:cross(cJ):dot(cI)<0 then mB=-mB end;local mC=gW:project_on_plane(cI):len()local mD=math.sin(mB)*math.asin(mC/my)*constants.rad2deg;local mE=math.cos(mB)*math.asin(mC/my)*constants.rad2deg;if mz:dot(cI)<0 then mE=90*math.cos(mB)+90*math.cos(mB)-mE;mD=90*math.sin(mB)+90*math.sin(mB)-mD end;local hB=ma+mD/ms*m6;local hC=mb+mE/ms*m6;local mF=(hB-ma)*(hB-ma)+(hC-mb)*(hC-mb)local mG=math.asin((dy.radius+dy.surfaceMaxAltitude)/my)*constants.rad2deg;if mG~=mG then mG=ms end;local h_=mG/ms*m6;local mH=math.asin(dy.atmosphereRadius/my)*constants.rad2deg;if mH~=mH then mH=mG end;local mI=mH/ms*m6;local ca=iJ(my,1)local mJ=dy.name;local mK=false;if hC>lU then if hC>md then if hC-mI<=md then mK=true end else mK=true end else if hC+mI>=lU then mK=true end end;local mL=false;local mM=hB;if dy.systemId==0 then mM=hB+mv else mM=hB-mv end;if mM+mv>lT then if mM+mv>mc then if mM-mI-mv<=mc then mL=true end else mL=true end else if mM+mI+mv>=lT then mL=true end end;local mN={}mN.x=hB;mN.y=hC;mN.planet=dy;mN.atmoSize=mI;if not mw or mF<mw then mw=mF;mx=mN end;if mL and mK then local mO=math.max(mI,5)if mF<mO*mO then mJ=mJ.." - "..ca end;mN.size=h_;mN.i=M;mN.displayString=mJ;mN.distance=ca;mN.visible=true;mu[#mu+1]=mN else mN.visible=false end end;local mP=false;table.sort(mu,function(eD,eE)return eD.y<eE.y end)for dM,fz in ipairs(mu)do local dy,h_,M,mI,hB,hC,mJ,ca=fz.planet,fz.size,fz.i,fz.atmoSize,fz.x,fz.y,fz.displayString,fz.distance;local m4,mQ,mR,mS;local mT=15;local jS="pdim"if dy.systemId~=0 then mR=jc(string.len(mJ)*5)mT=-(15+mR)mS=jd(10)jS="pdimfill"else mR=jc(string.len(mJ)*9)mS=jd(15)end;if h_*2>mR then m4=dm(hB,lT+mR/2,mc-mR/2)mQ=dm(hC,lU+mS,md-5)m4=dm(m4,hB-h_+mR/2,hB+h_-mR/2)mQ=dm(mQ,hC-h_+mS,hC+h_)else m4=hB+mT;mQ=hC end;for mU,fz in pairs(mt)do local mV=fz.textPositions;local mW=mV.y-mQ;if mU~=M and e_(mW)<mV.height and mV.x+mV.width>m4 and mV.x<m4+mR then if h_>mR then mQ=dm(mQ+mS,lU+15,md-5)else mQ=mV.y+mV.height+1 end end end;local mX=mJ~=dy.name or m4<=ma and m4+mR>=ma and mQ-mS<=mb and mQ>=mb;fz.hovered=mX;local mY=1;if mX then mY=2;if h_*2<mR then mY=10 end;if mJ==dy.name then mJ=mJ.." - "..ca end;jS="pbright"if dy.systemId~=0 then mR=jc(string.len(mJ)*5)mT=-(15+mR)else mR=jc(string.len(mJ)*7)end;if h_*2>mR then m4=dm(hB,lT+mR/2,mc-mR/2)m4=dm(m4,hB-h_+mR/2,hB+h_-mR/2)else m4=hB+mT end end;mt[M]={}mt[M].textPositions={}mt[M].textPositions.y=mQ;mt[M].textPositions.x=m4;mt[M].textPositions.width=mR;mt[M].textPositions.height=mS;mt[M].output=""if h_*2>mR then jS=jS.." txtmid"else jS=jS.." txtstart"end;if mI-h_>2 then mt[M].output=dl('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hB,hC,mI,j5,0.1*mY)end;mt[M].output=mt[M].output..dl('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hB,hC,h_,j5,0.2*mY)if dy.systemId==0 then mt[M].output=mt[M].output..dl([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m4,mQ,j4,jS,mJ)if h_*2<=mR then mt[M].output=mt[M].output..dl("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m4+mR,mQ+2,m4,mQ+2,hB,hC)end else mt[M].output=mt[M].output..dl([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m4,mQ,j5,jS,mJ)if h_*2<=mR then mt[M].output=mt[M].output..dl("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m4,mQ+2,m4+mR,mQ+2,hB,hC)end end end;for dM=#d5,1,-1 do if mt[dM]then jY[#jY+1]=mt[dM].output end end;if mx~=nil and d6<90 and not mx.hovered then local mZ=mx.planet.atmosphereRadius/mx.atmoSize;local m_=dp(mw)*mZ;local n0=iJ(m_,1)local mR=jc(math.max(string.len(n0)*7,string.len(mx.planet.name)*7))local mS=jd(12)local m4=dm(mx.x+(ma-mx.x)/2,lT+mR/2,mc-mR/2)local mQ=dm(mx.y+(mb-mx.y)/2,lU+mS*2,md-5)jY[#jY+1]=dl("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mx.x,mx.y,ma,mb)jY[#jY+1]=dl([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m4,mQ,"white",n0)if not mx.visible then jY[#jY+1]=dl([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m4,mQ-mS,"white",mx.planet.name)end end;if cM>1 then local gW=cL;local mz=gW:normalize()local mC=gW:project_on_plane(cI):len()local mA=gW:cross(cI):normalize()local mB=math.acos(mA:dot(cJ))if mB~=mB then mB=0 end;if mA:cross(cJ):dot(cI)<0 then mB=-mB end;local mD=math.sin(mB)*math.asin(mC/gW:len())*constants.rad2deg;local mE=math.cos(mB)*math.asin(mC/gW:len())*constants.rad2deg;if mz:dot(cI)<0 then mE=90*math.cos(mB)+90*math.cos(mB)-mE;mD=90*math.sin(mB)+90*math.sin(mB)-mD end;local hB=ma+mD/ms*m6;local hC=mb+mE/ms*m6;local kU=14;local kV=kU/2;local kY=[[<circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kV/kU..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hB..[["
                                    cy="]]..hC..[["
                                    r="]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hB-kU..[[,]]..hC..[[ h ]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hB+kV..[[,]]..hC..[[ h ]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hB..[[,]]..hC-kU..[[ v ]]..kV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jY[#jY+1]=kY end;jY[#jY+1]=dl("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",ma,mb-10,ma,mb+10)jY[#jY+1]=dl("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",ma-10,mb,ma+10,mb)jY[#jY+1]='</g>'else return jY end end;local function n1(n2,n3)local n4;local n5=(n3-n2):normalize()local fx=(cP-n2):dot(n5)/n5:dot(n5)if fx<=0. then return(cP-n2):len()elseif fx>=(n3-n2):len()then return(cP-n3):len()end;local n6=n2+fx*n5;n4=(n6-cP):len()return n4 end;local function n7()local n4;local n8=nil;local n9=nil;local na=nil;for dM,nb in pairs(e[0])do if nb.hasAtmosphere then local ca=n1(kA.center,nb.center)if n8==nil or ca<n8 then n9=nb;n8=ca;na=kA end;if c7 and c7.hasAtmosphere and c7.name~=kA.name then local eQ=n1(c7.center,nb.center)if eQ<n8 then n9=nb;n8=eQ;na=c7 end end end end;local nc=jc(1770)local nd=jd(330)if n8 then local ne="txttick "local nf=500000;if n8<n9.radius+nf or n8<na.radius+nf then if cW then ne="txttick red "else ne="txttick orange "end end;n4=iJ(n8,2)iX=gO(nc,nd,"Pipe ("..na.name.."--"..n9.name.."): "..n4,ne.."pbright txtmid")end end;local function ng(hB,hC,nh,ni,l6)local nj={x=hB,y=hC,width=nh,height=ni,label=l6}iR[l6]=nj;return nj end;local function nk(nl,nm,nh,ni,hB,hC,nn,no,np,nq,jS)local nj={enableName=nl,disableName=nm,width=nh,height=ni,x=hB,y=hC,toggleVar=nn,toggleFunction=no,drawCondition=np,hovered=false,class=jS}if nq then table.insert(iQ,nj)else table.insert(iP,nj)end;return nj end;local function nr(ns)if not iV then nt=false;nu=false;nv=false;w=true;return elseif ns=="handling"then nt=not nt;nu=false;nv=false elseif ns=="hud"then nu=not nu;nt=false;nv=false elseif ns=="physics"then nv=not nv;nt=false;nu=false end;if nv or nu or nt then iW=iI(ns)w=false else iW="none"w=true end end;local function nw()iV=not iV;if iV then iO=iQ;c2="Tap SHIFT to see Settings"d7=w else iO=iP;c2="Tap SHIFT to see Control Buttons"nr()w=d7 end end;local function nx()local function ny(dy,dM)dy.set(not dy.get())if dy.get()then c2=dM.." set to true"else c2=dM.." set to false"end;if dM=="showHud"then d7=dy.get()elseif dM=="BrakeToggleDefault"then a_=j end end;local nz=50;local nA=340;local hB=500;local hC=cl/2-400;local nB=0;for dM,dy in pairs(iI("boolean"))do if type(dy.get())=="boolean"then nk(dM,dM,nA,nz,hB,hC,function()return dy.get()end,function()ny(dy,dM)end,function()return true end,true)hC=hC+nz+20;if nB==9 then hB=hB+nA+20;hC=cl/2-400;nB=0 else nB=nB+1 end end end;nk("Control View","Control View",nA,nz,10,cl/2-500,function()return true end,nw,function()return true end,true)nk("View Handling Settings",'Hide Handling Settings',nA,nz,10,cl/2-(500-nz),function()return nt end,function()nr("handling")end,function()return true end,true)nk("View Hud Settings",'Hide Hud Settings',nA,nz,10,cl/2-(500-nz*2),function()return nu end,function()nr("hud")end,function()return true end,true)nk("View Physics Settings",'Hide Physics Settings',nA,nz,10,cl/2-(500-nz*3),function()return nv end,function()nr("physics")end,function()return true end,true)end;local function nC()local function gy()local fY=cP;local gz=kA.name..". "..#bq;if cv then gz=cv.GetClosestName(gz)end;return ct.AddNewLocation(gz,fY,false,true)end;local function nD()b5=not b5 end;local function nE(nF)if nF==1 then b3=not b3;b2=false else b2=not b2;b3=false end;b4=false;b6=false;b_=false;b7=false;bu=nil;b9=false;b8=false end;local function nG(nH,nI)ct.UpdatePosition(nil,nH,nI)end;local function gt()ct.ClearCurrentPosition()end;local function nJ(gx)local lL=cu.routeWP(true)if lL and#lL>0 then return"Engage Route: "..lL[1]end;return"Engage Autopilot: "..lJ(gx)end;local function nK(gx)local lL=cu.routeWP(true)if lL and#lL>0 then return"Next Route Point: "..lL[1]end;return"Disable Autopilot: "..lJ(gx)end;local function nL()if iE()==1 then b_=not b_;if b_ then b4=false;b2=false;b3=false;b6=false;b9=false;b7=false;b8=false;nM=bn;bn=false;d.control.retractLandingGears()iF:setTargetGroundAltitude(Z)fV("folOn","F")else fV("folOff","F")b1="Follow Off"cA=p;bn=nM;if bn then d.control.deployLandingGears()iF:setTargetGroundAltitude(_)end end else c2="Follow Mode only works with Remote controller"b_=false end end;local nz=50;local nA=260;local nN=jc(30)local nO=aB+aA*2+2;local nP=aC+1;nk("+","+",nN,nN,nO,nP+nN+1,function()return false end,function()d6=d6/8 end,function()return bJ=="SCOPE"end,nil,"ZoomButton")nk("-","-",nN,nN,nO,nP,function()return false end,function()d6=math.min(d6*8,90)end,function()return bJ=="SCOPE"end,nil,"ZoomButton")nk("0","0",nN,nN,nO,nP+nN*2+2,function()return false end,function()d6=90 end,function()return bJ=="SCOPE"and d6~=90 end,nil,"ZoomButton")local nQ=nk("Enable Brake Toggle","Disable Brake Toggle",nA,nz,ck/2-nA/2,cl/2+350,function()return a_ end,function()a_=not a_;if a_ then c2="Brakes in Toggle Mode"else c2="Brakes in Default Mode"end end)nk("Align Prograde","Disable Prograde",nA,nz,ck/2-nA/2-50-nQ.width,cl/2-nz+380,function()return b3 end,function()nE(1)end)nk("Align Retrograde","Disable Retrograde",nA,nz,ck/2-nA/2+nQ.width+50,cl/2-nz+380,function()return b2 end,nE,function()return cg==0 end)nR=nk(nJ,nK,600,60,ck/2-600/2,cl/2-60/2-330,function()return b4 or br or cc or bA end,function()end)local M;local function nS(nT)local gx=d2+nT;if gx>#cV then gx=gx-#cV-1 end;if gx<0 then gx=#cV+gx end;return gx end;nU={}for M=0,10 do local nV=nk(function(eE)local gx=nS(eE.apExtraIndex)if b4 or br or cc or bA then return"Redirect: "..lJ(gx)end;return nJ(gx)end,function(eE)local gx=nS(eE.apExtraIndex)return nK(gx)end,600,60,ck/2-600/2,cl/2-60/2-330+60*M,function(eE)local gx=nS(eE.apExtraIndex)return gx==bm and(b4 or br or cc or bA)end,function(eE)local gx=nS(eE.apExtraIndex)local nW=bm==gx;bm=gx;ct.UpdateAutopilotTarget()cu.ToggleAutopilot()if not nW and not(b4 or br or cc or bA)then cu.ToggleAutopilot()end end,function()return d1 and(#cu.routeWP(true)==0 or M==0)end)nV.apExtraIndex=M;nU[M]=nV end;nk("Save Position","Save Position",200,nR.height,nR.x+nR.width+30,nR.y,function()return false end,gy,function()return bm==0 or g6==nil end)nk("Update Position","Update Position",200,nR.height,nR.x+nR.width+30,nR.y,function()return false end,function()nG(nil)end,function()return bm>0 and g6~=nil end)nk("Save Heading","Clear Heading",200,nR.height,nR.x+nR.width+30,nR.y+nR.height+20,function()return g6.heading~=nil end,function()if g6.heading~=nil then nG(false)else nG(true)end end,function()return bm>0 and g6~=nil end)nk("Save AGG Alt","Clear AGG Alt",200,nR.height,nR.x+nR.width+30,nR.y+nR.height*2+40,function()return g6.agg~=nil end,function()if g6.agg~=nil then nG(nil,false)else nG(nil,true)end end,function()return bm>0 and g6~=nil and antigrav end)nk("Clear Position","Clear Position",200,nR.height,nR.x-200-30,nR.y,function()return true end,gt,function()return bm>0 and g6~=nil end)nk("Save Route","Save Route",200,nR.height,nR.x-200-30,nR.y+nR.height*2+40,function()return false end,function()cu.routeWP(false,false,2)end,function()return#cu.routeWP(true)>0 end)nk("Load Route","Clear Route",200,nR.height,nR.x-200-30,nR.y+nR.height+20,function()return#cu.routeWP(true)>0 end,function()if#cu.routeWP(true)>0 then cu.routeWP(false,true)elseif b4 or br then c2="Disable Autopilot before loading route"return else cu.routeWP(false,false,1)end end,function()return true end)nz=60;nA=300;local hB=0;local hC=cl/2-150;nk("Enable Check Damage","Disable Check Damage",nA,nz,hB,hC-nz-20,function()return s end,function()s=not s end)nk("View Settings","View Settings",nA,nz,hB,hC,function()return true end,nw)hC=hC+nz+20;nk("Enable Turn and Burn","Disable Turn and Burn",nA,nz,hB,hC,function()return b5 end,nD)hB=10;hC=cl/2-300;nk("Horizontal Takeoff Mode","Vertical Takeoff Mode",nA,nz,ck/2-nA/2,hC+20,function()return b0 end,function()b0=not b0;if b0 then c2="Vertical Takeoff Mode"else c2="Horizontal Takeoff Mode"end end,function()return cQ end)hC=hC+nz+20;nk("Engage Orbiting","Cancel Orbiting",nA,nz,hB+nA+20,hC,function()return bA end,cu.ToggleIntoOrbit,function()return cg==0 and cZ end)hC=cl/2-150;nk("Glide Re-Entry","Cancel Glide Re-Entry",nA,nz,hB+nA+20,hC,function()return b9 end,function()cb=1;nE(1)end,function()return kA.hasAtmosphere and not cf end)hC=hC+nz+20;nk("Parachute Re-Entry","Cancel Parachute Re-Entry",nA,nz,hB+nA+20,hC,function()return b9 end,function()cb=2;nE(1)end,function()return kA.hasAtmosphere and not cf end)hC=hC+nz+20;nk("Engage Follow Mode","Disable Follow Mode",nA,nz,hB,hC,function()return b_ end,nL,function()return iE()==1 end)nk("Enable Repair Arrows","Disable Repair Arrows",nA,nz,hB+nA+20,hC,function()return ja end,function()ja=not ja;if ja then c2="Repair Arrows Enabled"else c2="Repair Arrows Diabled"end end,function()return iE()==1 end)hC=hC+nz+20;if not q then nk("Enable AGG","Disable AGG",nA,nz,hB,hC,function()return cR end,cu.ToggleAntigrav,function()return antigrav~=nil end)end;nk(function()return dl("Switch IPH Mode - Current: %s",bB)end,function()return dl("IPH Mode: %s",bB)end,nA*2,nz,hB,hC,function()return false end,function()if bB=="All"then bB="Custom Only"elseif bB=="Custom Only"then bB="No Moons"else bB="All"end;c2="IPH Mode: "..bB end)hC=hC+nz+20;nk(function()return dl("Toggle Control Scheme - Current: %s",g)end,function()return dl("Control Scheme: %s",g)end,nA*2,nz,hB,hC,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c2="New Control Scheme: "..g end)local nX=jd(20)local nV=ng(0,0,jc(70),nX,"HELP")nV=ng(nV.x+nV.width,nV.y,jc(80),nX,"INFO")nV=ng(nV.x+nV.width,nV.y,jc(70),nX,"ORBIT")nV=ng(nV.x+nV.width,nV.y,jc(70),nX,"SCOPE")ng(nV.x+nV.width,nV.y,jc(70),nX,"HIDE")end;local nY={}local nZ=nil;function nY.HUDPrologue(jY)if not cW then j1=ai;j2=aj;j3=ak else j1=af;j2=ag;j3=ah end;j4=[[rgb(]]..bM(j1+0.6)..","..bM(j2+0.6)..","..bM(j3+0.6)..[[)]]j5=[[rgb(]]..bM(j1*0.8+0.5)..","..bM(j2*0.8+0.5)..","..bM(j3*0.8+0.5)..[[)]]local n_=j4;local o0=j5;local o1=[[rgb(]]..bM(j1*0.4+0.5)..","..bM(j2*0.4+0.5)..","..bM(j3*0.4+0.5)..[[)]]local o2=j4;local o3=j5;local o4=o1;if je()and not m then n_=[[rgb(]]..bM(j1*0.5+0.5)..","..bM(j2*0.5+0.5)..","..bM(j3*0.5+0.5)..[[)]]o0=[[rgb(]]..bM(j1*0.3+0.5)..","..bM(j2*0.3+0.5)..","..bM(j3*0.2+0.5)..[[)]]o1=[[rgb(]]..bM(j1*0.2+0.5)..","..bM(j2*0.2+0.5)..","..bM(j3*0.2+0.5)..[[)]]end;local lx=jc;local ly=jd;jY[#jY+1]=dl([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],n_,n_,n_,o2,o2,o0,o0,o3,o3,o0,n_,o1,o3,n_,n_,o1,o1,o4,o1,ck,cl,o0,o0,o0,o0,o0,o2,o0,o3,o4,o3,o3,o4)if not nZ then nZ=dl([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lx(630),ly(0),lx(675),ly(45),lx(960),ly(55),lx(1245),ly(45),lx(1290),ly(0),lx(1000),ly(105),lx(1040),ly(59),lx(1250),ly(51),lx(1300),ly(0),lx(1920),ly(0),lx(1920),ly(20),lx(1400),ly(20),lx(1300),ly(105),lx(920),ly(105),lx(880),ly(59),lx(670),ly(51),lx(620),ly(0),lx(0),ly(0),lx(0),ly(20),lx(520),ly(20),lx(620),ly(105),lx(890),ly(59),lx(960),ly(62),lx(1030),ly(59),lx(985),ly(112),lx(1150),ly(112),lx(1100),ly(152),lx(820),ly(152),lx(780),ly(112),lx(935),ly(112),lx(890),ly(59),lx(960),ly(62),lx(1030),ly(59),lx(985),ly(112),lx(1150),ly(112),lx(1100),ly(152),lx(820),ly(152),lx(780),ly(112),lx(935),ly(112))end;if w and I then jY[#jY+1]=nZ end;return jY end;function nY.DrawVerticalSpeed(jY,e4)jX(jY,e4)end;function nY.UpdateHud(jY)local kN=cT;local o5=cU;local k4=o5;local kk=kN;local l4=bM(c.getThrottle())local l9=cM*3.6;local l5=c.getAxisCommandValue(0)local o6=jc(1770)local o7=jd(310)if t and cS then l5=bQ;l4=bQ*100 end;local jg=jf()local k5="ROLL"if l4==nil then l4=0 end;if not cZ then if cM>5 then kN=kM(cK)o5=kO(cK)else kN=0;o5=0 end;k5="YAW"end;if cX>50000 and not cf then local o8;o8=iJ(cX)jY[#jY+1]=gO(o6,o7,"PvP Boundary: "..o8,"pbright txtbig txtmid")end;jY[#jY+1]=j8;jY[#jY+1]=ie;if iX~=""then jY[#jY+1]=iX end;if jh~=""then jY[#jY+1]=jh end;if ji~=""then jY[#jY+1]=ji end;jX(jY,ch)if iE()==0 or l then if not je()or m then if cZ then k3(jY,al,am,k4,k5,cZ)kj(jY,kk,k4,al,am,cZ,bM(kO(cK)),cM)else k3(jY,al,am,o5,k5,cZ)kj(jY,kN,o5,al,am,cZ,bM(o5),cM)end;kq(jY,ch,cZ)kP(jY,cK,cM,al,am)end end;l3(jY,jg,l4,l5)l8(jY,l9)ld(jY)lS(jY)if not iV and c0 then lK(jY)end;return jY end;function nY.HUDEpilogue(jY)jY[#jY+1]="</svg>"return jY end;function nY.ExtraData(jY)local o9=jc(1240)local oa=jd(55)local ob=oa+10;local oc;local lx=jc;local ly=jd;local od=0;local jg=jf()if b0 then jg=jg.."-VERTICAL"end;if E and not b8 and not b7 and cM>20 then jg=jg.."-COLLISION ON"end;if bD~="Off"then jg="("..bD..")-"..jg end;if b5 then jg="TB-"..jg end;if not bC then jg=jg.."-DeCoupled"end;local oe=ly(99)local of=ly(80)local og=ly(85)local oh=ly(31)local oi=0;local oj=0;local ok=ci>1000000 and fW(ci/1000000,2).."kT"or fW(ci/1000,2).."T"if cf then od=bv else od=bt end;local ol,om=cq.computeDistanceAndTime(cM,0,ci,0,0,od)if ol<0 then ol=0 end;od=fW(od/(ci*iN),2).."g"local on=d:maxForceForward()oc=b.getGravityIntensity()if oc>0.1 then oj=ci*oc;oj=fW(oj/(ci*iN),2).."g"oi=0.5*on/oc;oi=oi>1000000 and fW(oi/1000000,2).."kT"or fW(oi/1000,2).."T"end;on=fW(on/(ci*iN),2).."g"local oo=vec3(bO.getWorldAcceleration()):len()/9.80665;oc=b.getGravityIntensity()jY[#jY+1]=[[<g class="dim txt txtend size14">]]if iE()==1 and not l then o9=jc(1120)oa=jd(55)ob=oa+10 elseif cf and I then local op=jc(770)jY[#jY+1]=gO(lx(895),oe,"ATMO","")jY[#jY+1]=dl([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lx(895),og,lx(-80))jY[#jY+1]=gO(lx(815),of,dl("%.1f%%",cg*100),"txtstart size20")end;if I then jY[#jY+1]=gO(lx(1025),oe,"GRAVITY","txtstart")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(1025),og,lx(80))jY[#jY+1]=gO(lx(1105),of,dl("%.2fg",oc/9.80665),"size20")jY[#jY+1]=gO(lx(1125),oe,"ACCEL","txtstart")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(1125),og,lx(80))jY[#jY+1]=gO(lx(1205),of,dl("%.2fg",oo),"size20")jY[#jY+1]=gO(lx(695),oe,"BRK TIME","")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(695),og,lx(-80))jY[#jY+1]=gO(lx(615),of,dl("%s",iK(om)),"txtstart size20")jY[#jY+1]=gO(lx(635),ly(45),"TRIP","")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(635),ly(31),lx(-90))if lu then jY[#jY+1]=gO(lx(545),ly(26),dl("%s",iK(lu)),"txtstart size20")end;jY[#jY+1]=gO(lx(795),oe,"BRK DIST","")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(795),og,lx(-80))jY[#jY+1]=gO(lx(715),of,dl("%s",iJ(ol)),"txtstart size20")jY[#jY+1]=gO(lx(1285),ly(45),"MASS","txtstart")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(1285),ly(31),lx(90))jY[#jY+1]=gO(lx(1375),ly(26),dl("%s",ok),"size20")jY[#jY+1]=gO(lx(1220),oe,"THRUST","txtstart")jY[#jY+1]=dl([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lx(1220),og,lx(80))jY[#jY+1]=gO(lx(1300),of,dl("%s",on),"size20")jY[#jY+1]=gO(jc(960),jd(175),jg,"pbright txtbig txtmid size20")end;jY[#jY+1]="</g>"end;local oq=1-(a6*0.05+a7*0.05)function nY.FuelUsed(os)local ot;if os=="atmofueltank"then ot=dl("Atmo Fuel Used: %.1f L",jz[os]/(4*oq))elseif os=="spacefueltank"then ot=dl("Space Fuel Used: %.1f L",jz[os]/(6*oq))else ot=dl("Rocket Fuel Used: %.1f L",jz[os]/(0.8*oq))end;return ot end;local ou,ov,ow,ox,oy=0,0,0,{},0;function nY.DrawOdometer(jY,j6,bo,j7)if bJ~="INFO"then return jY end;local oc;local oi=0;local oj=0;local od=0;local ok=ci>1000000 and fW(ci/1000000,2).." kTons"or fW(ci/1000,2).." Tons"if cf then od=bv else od=bt end;local ol,om=cq.computeDistanceAndTime(cM,0,ci,0,0,od)od=fW(od/(ci*iN),2).." g"local on=d:maxForceForward()oc=b.getGravityIntensity()if oc>0.1 then oj=ci*oc;oj=fW(oj/(ci*iN),2).." g"oi=0.5*on/oc;oi=oi>1000000 and fW(oi/1000000,2).." kTons"or fW(oi/1000,2).." Tons"end;on=fW(on/(ci*iN),2).." g"if iE()==0 or l then local oz=jc(aB+10)local oA=jd(aC+20)local oB=jc(aB+10+aA/1.25)local ni=25;local oC=bM(1/aU)if ow<oC then oy=oy+a.getActionUpdateDeltaTime()ow=ow+1 else ou=1/(oy/oC)table.insert(ox,ou)ow,oy=0,0 end;ov=0;for dM,dy in pairs(ox)do ov=ov+dy end;if#ox>0 then ov=bM(ov/#ox)end;if#ox>29 then table.remove(ox,1)end;jY[#jY+1]="<g class='txtstart size14 bright'>"jY[#jY+1]=gO(oz,oA,dl("BrkTime: %s",iK(om)))jY[#jY+1]=gO(oB,oA,dl("Trip: %.2f km",j6))jY[#jY+1]=gO(oz,oA+ni,dl("Lifetime: %.2f kSU",bo/200000))jY[#jY+1]=gO(oB,oA+ni,dl("BrkDist: %s",iJ(ol)))jY[#jY+1]=gO(oz,oA+ni*2,"Trip Time: "..iK(j7))jY[#jY+1]=gO(oB,oA+ni*2,"Total Time: "..iK(bp))jY[#jY+1]=gO(oz,oA+ni*3,dl("Mass: %s",ok))jY[#jY+1]=gO(oB,oA+ni*3,dl("Max Brake: %s",od))jY[#jY+1]=gO(oz,oA+ni*4,dl("Max Thrust: %s",on))if oc>0.1 then jY[#jY+1]=gO(oB,oA+ni*4,dl("Max Thrust Mass: %s",oi))jY[#jY+1]=gO(oz,oA+ni*5,dl("Req Thrust: %s",oj))else jY[#jY+1]=gO(oB,oA+ni*4,"Max Mass: n/a")jY[#jY+1]=gO(oz,oA+ni*5,"Req Thrust: n/a")end;jY[#jY+1]=gO(oB,oA+ni*5,cs.FuelUsed("atmofueltank"))jY[#jY+1]=gO(oz,oA+ni*6,cs.FuelUsed("spacefueltank"))jY[#jY+1]=gO(oB,oA+ni*6,cs.FuelUsed("rocketfueltank"))jY[#jY+1]=gO(oz,oA+ni*7,dl("Set Max Speed: %s",bM(ab*3.6+0.5)))jY[#jY+1]=gO(oB,oA+ni*7,dl("Actual Max Speed: %s",bM(dg*3.6+0.5)))jY[#jY+1]=gO(oz,oA+ni*8,dl("Friction Burn Speed: %s",bM(bO.getFrictionBurnSpeed()*3.6)))jY[#jY+1]=gO(oB,oA+ni*8,dl("FPS (Avg): %s (%s)",bM(ou),ov))end;jY[#jY+1]="</g></g>"return jY end;function nY.DrawWarnings(jY)return ld(jY)end;function nY.DisplayOrbitScreen(jY)return lS(jY)end;function nY.DisplayMessage(jY,lo)if lo~="empty"then local hC=310;for lr in string.gmatch(lo,"([^\n]+)")do hC=hC+35;jY[#jY+1]=gO("50%",hC,lr,"msg")end end;if c3~=0 then c.setTimer("msgTick",c3)c3=0 end end;function nY.DrawDeadZone(jY)jY[#jY+1]=dl([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;function nY.UpdatePipe()if cf then iX=""return end;n7()end;function nY.DrawSettings(jY)local hB=jc(640)local hC=jd(200)jY[#jY+1]=[[<g class="pbright txtvspd txtstart">]]local hX=0;for dM,dy in pairs(iW)do hX=hX+1;jY[#jY+1]=gO(hB,hC,dM..": "..dy.get())hC=hC+20;if hX%12==0 then hB=hB+jc(350)hC=jd(200)end end;jY[#jY+1]=gO(jc(640),jd(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jY[#jY+1]="</g>"return jY end;local id=jd(125)local ic=jc(1225)function nY.DrawRadarInfo()ie=cv.GetRadarHud(ic,id,ax,ay)end;function nY.DrawTanks()if at~=0 and au~=0 then jh=gO(at,au,"","txtstart pdim txtfuel")jA=au;jB(at,"Atmospheric ","ATMO",cm,jx,jy)jB(at,"Space Fuel T","SPACE",cn,jv,jw)jB(at,"Rocket Fuel ","ROCKET",co,jt,ju)end end;function nY.DrawShield()local io=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oD=bO.getPvPTimer()local oE=shield.getResistances()local oF="A: "..10+oE[1]*100 .."% / E: "..10+oE[2]*100 .."% / K:"..10+oE[3]*100 .."% / T: "..10+oE[4]*100 .."%"local hB,hC=av-60,aw+30;local jQ=bM(dh*2.55)local jR=dl("rgb(%d,%d,%d)",255-jQ,jQ,0)local jS=""ji=gO(hB,hC,"","txtmid pdim txtfuel")if dh<10 and io~="Shield Disabled"then jS="red "end;oD=oD>0 and"   PvPTime: "..iK(oD)or""ji=ji..dl([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hB,hC,jR,dh*2,hB,hC,hB+2,hC+10,dh,oD)ji=ji..gO(hB,hC-5,io,jS.."txtstart pbright txtbig")ji=ji..gO(hB,hC+30,oF,jS.."txtstart pbright txtsmall")end;function nY.hudtick()if not kA then return end;local function oG(jY)local jU=bM(dm(de/(ck/4)*255,0,255))jY[#jY+1]=dl("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c8,c9,bM(j1+0.5)+jU,bM(j2+0.5)-jU,bM(j3+0.5)-jU)end;local function oH()if c1 then for dR,dy in pairs(iO)do if dy.hovered then if not dy.drawCondition or dy.drawCondition(dy)then dy.toggleFunction(dy)end;dy.hovered=false end end;for dR,dy in pairs(iR)do if dy.hovered then bJ=dy.label;dy.hovered=false end end;c1=false end end;local function oI()local function oJ(oK,oL,hB,hC,nh,ni)if oK>=hB and oK<=hB+nh and oL>=hC and oL<=hC+ni then return true else return false end end;local hB=c8+ck/2;local hC=c9+cl/2;for dR,dy in pairs(iO)do dy.hovered=oJ(hB,hC,dy.x,dy.y,dy.width,dy.height)end;for dR,dy in pairs(iR)do dy.hovered=oJ(hB,hC,dy.x,dy.y,dy.width,dy.height)end;if d1 then local mX=false;for dR,eE in ipairs(nU)do if eE.hovered then mX=true;break end end;if nR.hovered then mX=true end;d1=mX else d1=nR.hovered;if not d1 then d2=bm end end end;local function oM(jY)if not bJ or bJ==""then bJ="HELP"end;if w then for dM,dy in pairs(iR)do local jS="dim brightstroke"local oN=0.2;if bJ==dM then jS="pbright dimstroke"oN=0.6 end;local oO=""if dy.hovered then oN=0.8;oO=";stroke:white"end;jY[#jY+1]=dl([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dy.width,dy.height,dy.x,dy.y,jS,oN,oO)jY[#jY+1]=gO(dy.x+dy.width/2,dy.y+dy.height/2+5,dy.label,"txt txtmid pdim")end end end;local function oP(jY)local function oQ(jY,oR,hover,hB,hC,fj,oS,oT,oU,oV,oW,nV)if type(oV)=="function"then oV=oV(nV)end;if type(oW)=="function"then oW=oW(nV)end;jY[#jY+1]=dl("<rect x='%f' y='%f' width='%f' height='%f' fill='",hB,hC,fj,oS)if oR then jY[#jY+1]=dl("%s'",oT)else jY[#jY+1]=oU end;if hover then jY[#jY+1]=dl(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else jY[#jY+1]=dl(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fW(af*0.5,0),fW(ag*0.5,0),fW(ah*0.5,0))end;jY[#jY+1]=" rx='5'></rect>"jY[#jY+1]=dl("<text x='%f' y='%f' font-size='24' fill='",hB+fj/2,hC+oS/2+5)if oR then jY[#jY+1]="black"else jY[#jY+1]="white"end;jY[#jY+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oR then jY[#jY+1]=dl("%s</text>",oV)else jY[#jY+1]=dl("%s</text>",oW)end end;local oX=dl("rgb(%d,%d,%d)'",fW(af*0.1,0),fW(ag*0.1,0),fW(ah*0.1,0))local oY=dl("rgb(%d,%d,%d)",fW(af*0.8,0),fW(ag*0.8,0),fW(ah*0.8,0))local oZ=oQ;for dR,dy in pairs(iO)do local nm=dy.disableName;local nl=dy.enableName;if type(nm)=="function"then nm=nm(dy)end;if type(nl)=="function"then nl=nl(dy)end;if not dy.drawCondition or dy.drawCondition(dy)then oZ(jY,dy.toggleVar(dy),dy.hovered,dy.x,dy.y,dy.width,dy.height,oY,oX,nm,nl,dy)end end end;local o_=fW(ck/2,0)local p0=fW(cl/2,0)local jY={}if p1 then jY[#jY+1]=p1 end;cs.HUDPrologue(jY)if w then cs.UpdateHud(jY)else if A then cs.DrawVerticalSpeed(jY,ch)end;cs.DrawWarnings(jY)end;if iV and iW~="none"then cs.DrawSettings(jY)end;if cv then cs.DrawRadarInfo()else ie=""end;cs.HUDEpilogue(jY)jY[#jY+1]=dl([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ck,cl)if c2~="empty"then cs.DisplayMessage(jY,c2)end;if iE()==0 and g=="virtual joystick"then if v then cs.DrawDeadZone(jY)end end;oM(jY)if iG()==0 then if iE()==1 and c0 then if not p2 then oI()oP(jY)end;if not cy and not cz then local p3=table.concat(jY,"")jY={}jY[#jY+1]=dl("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ck,cl)jY[#jY+1]=p3;jY[#jY+1]="</body>"cy=true;jY[#jY+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cz then local p3=table.concat(jY,"")jY={}jY[#jY+1]=dl("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ck,cl)jY[#jY+1]=p3;jY[#jY+1]="</body>"end;if not cy then jY[#jY+1]=dl([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],o_,p0,c8,c9)end else oH()end else if not c0 and iE()==0 then oH()if de>az then if v then oG(jY)end end elseif c0 and(not p2 or not i)then oI()oP(jY)end;jY[#jY+1]=dl([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],o_,p0,c8,c9)end;jY[#jY+1]=[[</svg></body>]]p4=table.concat(jY,"")end;function nY.TenthTick()local function p5()local p6=a.createData;local p7=a.createWidget;p8=a.createWidgetPanel("Interplanetary Helper")p9=p7(p8,"value")pa=p6('{"label": "Target Planet", "value": "N/A", "unit":""}')fU(pa,p9)pb=p7(p8,"value")pc=p6('{"label": "distance", "value": "N/A", "unit":""}')fU(pc,pb)gn=p7(p8,"value")gm=p6('{"label": "Travel Time", "value": "N/A", "unit":""}')fU(gm,gn)gl=p7(p8,"value")gk=p6('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fU(gk,gl)gp=p7(p8,"value")go=p6('{"label": "Target Altitude", "value": "N/A", "unit":""}')fU(go,gp)gh=p7(p8,"value")gg=p6('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gf=p7(p8,"value")ge=p6('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gd=p7(p8,"value")gc=p6('{"label": "Max Brake distance", "value": "N/A", "unit":""}')gb=p7(p8,"value")ga=p6('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gj=p7(p8,"value")gi=p6('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cf then fU(gg,gh)fU(ge,gf)fU(gc,gd)fU(ga,gb)fU(gi,gj)end end;local function pd()gN(p8)p8=nil end;cs.DrawTanks()if shield then cs.DrawShield()end;if bk~="None"then if p8==nil then p5()end;if bk~=nil then local my;local pe=g6~=nil;local pf=0.5*bv/c7:getGravity(c7.center+vec3(0,0,1)*c7.radius):len()pf=pf>1000000 and fW(pf/1000000,2).." kTons"or fW(pf/1000,2).." Tons"fT(pa,'{"label": "Target", "value": "'..bk..'", "unit":""}')if pe and not b4 then my=(cP-g6.position):len()else my=(bl-cP):len()end;if not b5 then c5,c6=cu.GetAutopilotBrakeDistanceAndTime(cM)iZ,i_=cu.GetAutopilotBrakeDistanceAndTime(ab)else c5,c6=cu.GetAutopilotTBBrakeDistanceAndTime(cM)iZ,i_=cu.GetAutopilotTBBrakeDistanceAndTime(ab)end;local lo=iJ(my)fT(pc,'{"label": "distance", "value": "'..lo..'"}')fT(gm,'{"label": "Travel Time", "value": "'..iK(lu)..'", "unit":""}')lo=iJ(c5)fT(gg,'{"label": "Cur Brake distance", "value": "'..lo..'"}')fT(ge,'{"label": "Cur Brake Time", "value": "'..iK(c6)..'", "unit":""}')lo=iJ(iZ)fT(gc,'{"label": "Max Brake distance", "value": "'..lo..'"}')fT(ga,'{"label": "Max Brake Time", "value": "'..iK(i_)..'", "unit":""}')fT(gk,'{"label": "Max Brake Mass", "value": "'..dl("%s",pf)..'", "unit":""}')lo=iJ(gq)fT(go,'{"label": "Target Orbit", "value": "'..lo..'"}')if cf and not pg then a.removeDataFromWidget(ga,gb)a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)a.removeDataFromWidget(gi,gj)pg=true;if not cS and t and(b6 or b9 or cd)then cu.cmdThrottle(1)b1=false;bU=false end end;if not cf and pg then if fT(ga,gb)==1 then fU(ga,gb)end;if fT(gc,gd)==1 then fU(gc,gd)end;if fT(ge,gf)==1 then fU(ge,gf)end;if fT(gg,gh)==1 then fU(gg,gh)end;if fT(gi,gj)==1 then fU(gi,gj)end;pg=false end end else pd()end;if warpdrive~=nil then local ph=iC(warpdrive.getWidgetData())if ph.destination~="Unknown"and ph.distance>400000 then if not jb then warpdrive.showWidget()jb=true end elseif jb then warpdrive.hideWidget()jb=false end end end;function nY.OneSecondTick()local function pi()local jL=bL()local l9=cM;local pj=jL-j9;if l9>1.38889 then l9=l9/1000;local pk=l9*(jL-j9)bo=bo+pk;j6=j6+pk end;j7=j7+pj;bp=bp+pj;j9=jL end;local function pl(jY)local pm=0;local pn=iM;local po=0;local pp=0;local pq=0;local jQ=0;local jR=""local pr=b.getElementHitPointsById;local ps=b.getElementMaxHitPointsById;local pt={}for dM in pairs(iL)do local pu=0;local pv=0;pv=ps(iL[dM])pu=pr(iL[dM])po=po+pu;if pu+1<pv then if pu==0 then pq=pq+1 else pp=pp+1 end;if ja and#pt==0 then fY=vec3(b.getElementPositionById(iL[dM]))local hB=fY.x;local hC=fY.y;local hD=fY.z;table.insert(pt,b.spawnArrowSticker(hB,hC,hD+1,"down"))table.insert(pt,b.spawnArrowSticker(hB,hC,hD+1,"down"))b.rotateSticker(pt[2],0,0,90)table.insert(pt,b.spawnArrowSticker(hB+1,hC,hD,"north"))table.insert(pt,b.spawnArrowSticker(hB+1,hC,hD,"north"))b.rotateSticker(pt[4],90,90,0)table.insert(pt,b.spawnArrowSticker(hB-1,hC,hD,"south"))table.insert(pt,b.spawnArrowSticker(hB-1,hC,hD,"south"))b.rotateSticker(pt[6],90,-90,0)table.insert(pt,b.spawnArrowSticker(hB,hC-1,hD,"east"))table.insert(pt,b.spawnArrowSticker(hB,hC-1,hD,"east"))b.rotateSticker(pt[8],90,0,90)table.insert(pt,b.spawnArrowSticker(hB,hC+1,hD,"west"))table.insert(pt,b.spawnArrowSticker(hB,hC+1,hD,"west"))b.rotateSticker(pt[10],-90,0,90)table.insert(pt,iL[dM])end elseif ja and#pt>0 and pt[11]==iL[dM]then for jK in pairs(pt)do b.deleteSticker(pt[jK])end;pt={}end end;pm=fW(po/pn*100,2)if pq>0 or pp>0 then jY[#jY+1]=gO(0,0,"","pbright txt")jQ=bM(pm*2.55)jR=dl("rgb(%d,%d,%d)",255-jQ,jQ,0)jY[#jY+1]=gO("50%",1035,"Elemental Integrity: "..pm.."%","txtbig txtmid","fill:"..jR)if pq>0 then jY[#jY+1]=gO("50%",1055,"Disabled Modules: "..pq.." Damaged Modules: "..pp,"txtbig txtmid","fill:"..jR)elseif pp>0 then jY[#jY+1]=gO("50%",1055,"Damaged Modules: "..pp,"txtbig txtmid","fill:"..jR)end end end;local function pw()if iB then if j0==nil and(hf~=nil or bn)then _autoconf.displayCategoryPanel(iB,weapon_size,"Weapons","weapon",true)j0=_autoconf.panels[_autoconf.panels_size]elseif j0~=nil and hf==nil and not bn then gN(j0)j0=nil end end end;d3=bO.getPlayersOnBoard()d4=bO.getDockedConstructs()local jY={}pi()if s then pl(jY)end;pw()cs.UpdatePipe()cs.ExtraData(jY)j8=table.concat(jY,"")end;function nY.AnimateTick()cz=true;cy=false;c8=0;c9=0;c.stopTimer("animateTick")end;function nY.MsgTick()local jY={}cs.DisplayMessage(jY,"empty")c2="empty"c.stopTimer("msgTick")c3=3 end;function nY.ButtonSetup()nx()nC()iO=iP end;if px then for dM,dy in pairs(px)do nY[dM]=dy end end;return nY end;local function py(d,b,c,e,vBooster,hover,pz,antigrav,warpdrive,dbHud_1,e_,bM,bN,iE,eV,bL,dm,iF,fT,iG,dp,fW,fV,iH,dq,iJ,iK,pA,iC,dl,fU)local a=DUSystem;local bO=DUConstruct;local pB={}local pC=false;local pD=0;local pE=0;local pF=0;local pG=bL()local pH=0;local pI=0;local pJ=0;local pK=0;local pL=false;local pM=false;local pN=false;local pO=nil;local pP=0;local iY=55;local pQ=nil;local pR=false;local pS=false;local pT=false;local pU=0;local pV=0;local pW=0;local pX=0;local pY=0;local pZ={VectorToTarget=false}local p_=vec3(bO.getWorldOrientationUp())local q0=nil;local q1=0;local q2=-1;local q3=-1;local q4=false;local q5=false;local q6=0;local q7=false;local q8=false;local q9=false;local qa=false;local qb=""local qc=false;local qd=false;local qe=""local qf=false;local qg=0;local function qh()return bO.isInPvPZone()~=1,e_(bO.getDistanceToSafeZone())end;local function qi(fq)local qj=bg;if not b4 then qj=0 end;local qk=bt;if cf then if bv and bv>0 then qk=bv else return 0,0 end end;return cq.computeDistanceAndTime(fq,qj,ci,0,0,qk-bi*ci)end;local function ql(fq)local qj=bg;if not b4 then qj=0 end;return cq.computeDistanceAndTime(fq,qj,ci,d:maxForceForward(),a2,bt-bi*ci)end;local function qm(qn,qo,qp)qo=qo:project_on_plane(qn)qp=qp:project_on_plane(qn)return eV(qo:cross(qp):dot(qn),qo:dot(qp))end;local function qq()local function qr()local qs=-1;local qt=-1;if vBooster then qs=vBooster.getDistance()end;if hover then qt=hover.getDistance()end;if qs~=-1 and qt~=-1 then if qs<qt then return qs else return qt end elseif qs~=-1 then return qs elseif qt~=-1 then return qt else return-1 end end;local qu=qr()local qv=-1;if antigrav and antigrav.isActive()==1 and not q and cM<iY then local qw=e_(ch-antigrav.getBaseAltitude())if qw<50 then return qw end end;if pz then qv=pz.raycast().distance end;if qu~=-1 and qv~=-1 then if qu<qv then return qu else return qv end elseif qu~=-1 then return qu else return qv end end;local function qx(kA,eM,qy)local function qz(qA,dY)local eS=vec3(dY)if qA.id==0 then return setmetatable({latitude=eS.x,longitude=eS.y,altitude=eS.z,id=0,systemId=qA.systemId},d_)end;local eT=eS-qA.center;local ca=eT:len()local e4=ca-qA.radius;local e2=0;local e3=0;if not dq(ca,0)then local eU=eV(eT.y,eT.x)e3=eU>=0 and eU or 2*math.pi+eU;e2=math.pi/2-math.acos(eT.z/ca)end;return setmetatable({latitude=math.deg(e2),longitude=math.deg(e3),altitude=e4,id=qA.id,systemId=qA.systemId},d_)end;local qB=qz(kA,eM)qB="::pos{"..qB.systemId..","..qB.id..","..qB.latitude..","..qB.longitude..","..qB.altitude.."}"if qy then return qB else q9=qB;return true end end;local function qC(qD,qE,qF)local function qG(qD,ev)qD=vec3(qD)ev=vec3(ev):normalize()local dH=qD*ev;return dH.x+dH.y+dH.z end;local qH=0.001;local qI=1;if not cf or not cB or ce~=-1 or cM<iY then if qF==nil then qF=aT end;if qE==nil then qE=qH end;qD=vec3(qD):normalize()local qJ=vec3()-qD;local qK=-qG(qJ,bO.getWorldOrientationRight())*qI;local qL=-qG(qJ,bO.getWorldOrientationUp())*qI;if pE==0 then pE=qK/2 end;if pF==0 then pF=qL/2 end;if e_(qK)<0.1 then pV=pV-qK*2 else pV=pV-(qK+(qK-pE)*qF)end;if e_(qL)<0.1 then pU=pU+qL*2 else pU=pU+qL+(qL-pF)*qF end;pE=qK;pF=qL;if e_(qK)<qE and e_(qL)<qE then return true end;return false elseif cB and ce==-1 then qD=cL;if qF==nil then qF=aT end;if qE==nil then qE=qH end;qD=vec3(qD):normalize()local qJ=cI-qD;local qK=-qG(qJ,bO.getWorldOrientationRight())*qI;local qL=-qG(qJ,bO.getWorldOrientationUp())*qI;if pE==0 then pE=qK/2 end;if pF==0 then pF=qL/2 end;if e_(qK)<0.1 then pV=pV-qK*5 else pV=pV-(qK+(qK-pE)*qF)end;if e_(qL)<0.1 then pU=pU+qL*5 else pU=pU+qL+(qL-pF)*qF end;pE=qK;pF=qL;if e_(qK)<qE and e_(qL)<qE then return true end;return false end end;function pB.clearAll()bc=false;be=false;bf=false;b4=false;bd=false;bh="Aligning"b2=false;b3=false;cY=nil;b6=false;b9=false;b7=false;b8=false;ba=false;b_=false;pS=false;cb=false;cc=false;pT=false;cA=p;br=false;b5=false;cj=false;bu=nil;bA=false;dc=false;dd=nil end;function pB.GetAutopilotBrakeDistanceAndTime(fq)return qi(fq)end;function pB.GetAutopilotTBBrakeDistanceAndTime(fq)return ql(fq)end;function pB.showWayPoint(kA,eM,qy)return qx(kA,eM,qy)end;function pB.APTick()local qM=a.getMouseWheel()if qM>0 then cu.changeSpd()elseif qM<0 then cu.changeSpd(true)else pR=true end;q6=iG()if q9 then a.setWaypoint(q9)q9=false end;if qc then antigrav.setTargetAltitude(qc)qc=false end;if qa then fT(qa,qb)qa=false;qb=""end;if q3~=-1 then cu.cmdCruise(q3,q4)q4=false;q3=-1 end;if q0~=nil then if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iF:getTargetSpeed(axisCommandId.longitudinal)~=q0 then iF:setTargetSpeedCommand(axisCommandId.longitudinal,q0)else q0=nil end end;if q2~=-1 then cu.cmdThrottle(q2,q4)q4=false;q2=-1 end;if q5 then cw.landingGear()q5=false end;if qd then cu.ToggleAutopilot()end end;function pB.ToggleIntoOrbit()cF=false;pJ=nil;pK=nil;pP=0;if not cf then if bA then fV("orOff","AP")bA=false;pL=false;pO=nil;cA=p;if b6 then b6=false;b8=false end;pZ.VectorToTarget=false;pZ.AutopilotAlign=false;pN=false elseif cZ then fV("orOn","AP")bA=true;cA=true;if pO==nil then pO=kA end;if b6 then b6=false;b8=false end else c2="Unable to engage auto-orbit, not near a planet"end else bA=false;pL=false;pO=nil;cA=p;if b6 then b6=false end;pZ.VectorToTarget=false;pZ.AutopilotAlign=false;pN=false end end;function pB.ToggleVerticalTakeoff()b6=false;if ba then lq=true;b9=false;b8=false;b7=true;cA=true;bZ=0;if cf and ce==-1 then b7=false;b6=true;bZ=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q3=bM(cC)end else cF=false;bn=false;d.control.retractLandingGears()iF:setTargetGroundAltitude(Z)b1="VTO Takeoff"end;ba=not ba end;function pB.checkLOS(qD)local ls,eK,eL=cp:getPlanetarySystem(0):castIntersections(cP,qD,function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)local lt=eK;if eL~=nil and eK~=nil then lt=math.min(eL,eK)end;if lt~=nil then return ls,lt else return nil,nil end end;function pB.ToggleAutopilot()local function qN(by)c_=false;br=not br;if br then b5=false;if not b6 and not by then cu.ToggleAltitudeHold()end end;lw="Proceeding to Waypoint"end;local function qO(gz)if gz then for M,dM in pairs(cV)do if dM.name and dM.name==gz then return M end end else return 0 end end;local qP=false;if bP-pI<1.5 and cf then if not cH then if cf then bb=kA.spaceEngineMinAltitude-0.01*kA.noAtmosphericDensityAltitude;fV("11","EP")pI=-1;if b4 or br or bA then return end else c2="No space engines detected, Orbital Hop not supported"return end elseif kA.hasAtmosphere then if cf then bb=kA.noAtmosphericDensityAltitude+V;fV("orH","OH")end;pI=-1;if b4 or br or bA then return end end else pI=bP end;qQ=false;if(bm>0 or#bG>0)and not b4 and not br and not cc and not bA then if 0.5*d:maxForceForward()/b.getGravityIntensity()<ci then c2="WARNING: Heavy Loads may affect autopilot performance."c3=5 end;if#bG>0 and not cd then bm=qO(bG[1])ct.UpdateAutopilotTarget()c2="Route Autopilot in Progress"local qJ=g6.position-cP;local qR=qJ:project_on_plane(cN):len()if qR>50000 and g6.planetname==kA.name then qP=true end end;ct.UpdateAutopilotTarget()cu.showWayPoint(c7,bl)if g6~=nil then if g6.agg and not q and antigrav then if not cR then cu.ToggleAntigrav()end;bw=g6.agg end;bu=nil;by=g6.planetname=="Space"if by then fV("apSpc","AP")if cf then cc=true;cu.ToggleAltitudeHold()else b4=true end elseif kA.name==g6.planetname then lq=true;if cf then if not br then fV("vtt","AP")qN(by)if qP then bb=kA.noAtmosphericDensityAltitude+V end end else fV("apOn","AP")if not(c7.name==kA.name and ch<gq*1.5)then cF=false;b4=true elseif not cf then if bA then cu.ToggleIntoOrbit()end;cE=kA.noAtmosphericDensityAltitude+V;pN=true;pZ.AutopilotAlign=true;pZ.VectorToTarget=true;pL=false;if not bA then cu.ToggleIntoOrbit()end end end else fV("apP","AP")b2=false;b3=false;if cf then cc=true;cu.ToggleAltitudeHold()else b4=true end end elseif not cf then if g6==nil and(c7.name==kA.name and cZ)and not bA then qS=false;cF=false;pL=false;cu.ToggleIntoOrbit()else fV("apP","AP")b4=true;b2=false;b3=false;bd=false;b_=false;b6=false;b7=false;b9=false;b8=false;pS=false;bu=nil;qS=false end else fV("apP","AP")cc=true;cu.ToggleAltitudeHold()end;qd=false else fV("apOff","AP")cu.ResetAutopilots(1)if qd==2 then qd=true end end end;function pB.routeWP(qT,qU,qV)if qV then if qV==1 then bG={}bG=iH(bG,bF)if#bG>0 then c2="Route Loaded"else c2="No Saved Route found on Databank"end;return bG else bF={}bF=iH(bF,bG)c2="Route Saved"pA()return end end;if qT then return bG end;if qU then bG={}c2="Current Route Cleared"else bG[#bG+1]=g6.name;c2="Added "..g6.name.." to route. "end;return bG end;function pB.cmdThrottle(dN,qW)if iF:getAxisCommandType(0)~=axisCommandType.byThrottle and not qW then d.control.cancelCurrentControlMasterMode()end;iF:setThrottleCommand(axisCommandId.longitudinal,dN)bQ=dm(fW(dN*100,0)/100,-1,1)q0=nil end;function pB.cmdCruise(dN,qW)if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not qW then d.control.cancelCurrentControlMasterMode()end;iF:setTargetSpeedCommand(axisCommandId.longitudinal,dN)q0=dN end;function pB.ToggleLockPitch()if bu==nil then fV("lkPOn","LP")if not c0 then bu=cT else bu=S end;b8=false;b6=false;b7=false else fV("lkPOff","LP")bu=nil end end;function pB.ToggleAltitudeHold()if bP-pH<1.5 then if kA.hasAtmosphere then if cf then bb=kA.spaceEngineMinAltitude-0.01*kA.noAtmosphericDensityAltitude;fV("11","EP")else if cZ then bb=kA.noAtmosphericDensityAltitude+V;cE=bb;pN=true;if not bA then cu.ToggleIntoOrbit()end;pL=true end end;pH=-1;if b6 or bA or ba then return end end else pH=bP end;if cZ and not cf then cE=ch;pN=true;pL=true;cu.ToggleIntoOrbit()if bA then pH=bP else pH=0 end;return end;b6=not b6;b7=false;b9=false;if b6 then b4=false;b3=false;b2=false;b_=false;cA=true;bu=nil;cF=false;if ce~=-1 and cM<20 then if bn then cw.landingGear()end;fV("lfs","LS")b8=true;if pH>-1 then bb=ch+Y end;b1="ATO Hold"iF:setTargetGroundAltitude(Z)if b0 and cQ then cu.ToggleVerticalTakeoff()end else fV("altOn","AH")b8=false;if pH>-1 then if cZ then bb=ch end end;if ba then cu.ToggleVerticalTakeoff()end end;if cR and not q then local qX=antigrav.getBaseAltitude()if br and g6.agg and g6.agg>ch then bb=g6.agg elseif b8 then bb=qX end;if e_(ch-qX)<100 and cM<20 then bb=qX;b1="AGG Hold"q2=0 end end;if cc then bb=200000 end else fV("altOff","AH")if bA then cu.ToggleIntoOrbit()end;if ba then cu.ToggleVerticalTakeoff()end;cA=p;b8=false;br=false;pH=0 end end;function pB.ResetAutopilots(pB)if pB then cc=false;b4=false;bd=false;pS=false;bb=ch;qQ=false;dc=false;bh="Aligning"end;br=false;b8=false;b9=false;b3=false;b7=false;dd=nil;qY=false;cY=nil;dc=false;if not cR then b6=false;bu=nil end;if ba then cu.ToggleVerticalTakeoff()end;if bA then cu.ToggleIntoOrbit()end;cA=p;cb=false;cd=false;bZ=0 end;function pB.BrakeToggle(qZ)if not b1 then if qZ then b1=qZ else b1=true end else b1=false end;if b7 then b7=false;cA=p;dc=false end;if b1 then fV("bkOn","B",1)cu.ResetAutopilots()else fV("bkOff","B",1)end end;function pB.BeginReentry()if b9 then c2="Re-Entry cancelled"fV("reOff","RE")b9=false;cA=p;b6=false elseif not kA.hasAtmosphere then c2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c3=5 elseif not pT then b9=true;if iF:getAxisCommandType(0)~=q_.cruise then d.control.cancelCurrentControlMasterMode()end;cA=true;b1=false;c2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cC;fV("par","RE")else b9=true;b6=true;cA=true;b1=false;bb=kA.surfaceMaxAltitude+a0;if bb>kA.spaceEngineMinAltitude then bb=kA.spaceEngineMinAltitude-0.01*kA.noAtmosphericDensityAltitude end;local r0=iJ(bb)c2="Beginning Re-entry.  Target speed: "..cC.." Target Altitude: "..r0;fV("glide","RE")q3=bM(cC)end;b8=false end;function pB.ToggleAntigrav()if antigrav and not q then if cR then fV("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bw==nil then bw=ch end;if bw<1000 then bw=1000 end;fV("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pB.changeSpd(r1)local r2=1;if r1 then r2=-1 end;if not c0 then if t and not p2 and pR then local r3=bQ;bQ=fW(dm(bQ+r2*aF/100,-1,1),2)if bQ>=0 and r3<0 then bQ=0;pR=false end elseif p2 then if cf or b9 then cC=dm(cC+r2*aF,0,W)elseif b4 then ab=dm(ab+r2*aF/3.6*100,0,dg-0.2)end else iF:updateCommandFromActionStart(axisCommandId.longitudinal,r2*aF/10)end else if b4 or br or cc or bA then d2=d2+1*r2*-1;if d2>#cV then d2=1 end;if d2<1 then d2=#cV end else if not r1 then r2=1 else r2=nil end;ct.adjustAutopilotTargetIndex(r2)end end end;function pB.TenthTick()local function r4()if not b4 then if g6==nil or g6.planetname~=kA.name then r5=(c7.center-cP):len()else r5=(g6.position-cP):len()end end;local fq=cM;local r6=c.getThrottle()/100;if t then r6=bQ end;local r7,r8=cq.computeDistanceAndTime(cM,ab,ci,d:maxForceForward()*r6,a2,0)local c5,c6;if not b5 then c5,c6=cu.GetAutopilotBrakeDistanceAndTime(ab)else c5,c6=cu.GetAutopilotTBBrakeDistanceAndTime(ab)end;local dR,r9;if not b5 and fq>0 then dR,r9=cu.GetAutopilotBrakeDistanceAndTime(fq)else dR,r9=cu.GetAutopilotTBBrakeDistanceAndTime(fq)end;local ra=0;local rb=0;if bf or not b4 and fq>5 then rb=cq.computeTravelTime(fq,0,r5)elseif c5+r7<r5 then ra=r5-(c5+r7)rb=cq.computeTravelTime(8333.0556,0,ra)else local rc=(r5-c5)/r7;r7=r5-c5;r8=r8*rc end;if g6~=nil and g6.planetname==kA.name and not b4 then return rb elseif be then return r9 elseif bf then return rb+r9 else return r8+c6+rb end end;local function rd(oc,re)if oc==nil then oc=b.getGravityIntensity()end;oc=fW(oc,5)if re~=nil and re or(pQ==nil or pQ~=oc)then local fq=cK:len()local rf=iC(c.getWidgetData()).maxBrake;if rf~=nil and rf>0 and cf then rf=rf/dm(fq/100,0.1,1)rf=rf/cg;if cg>0.10 then if bv then bv=(bv+rf)/2 else bv=rf end end end;if rf~=nil and rf>0 then bt=rf end;pQ=oc end end;cW,cX=qh()dg=bO.getMaxSpeed()if bk~="None"and(c7 or g6)then lu=r4()end;rd(nil,true)end;function pB.SatNavTick()if not r then return end;qe=dbHud_1.getStringValue("SPBAutopilotTargetName")if qe~=nil and qe~=""and qe~="SatNavNotChanged"then local dH=iC(dbHud_1.getStringValue("SavedLocations"))if dH~=nil then bq=dH;local gx=-1;local gD;for dM,dy in pairs(bq)do if dy.name and dy.name=="SatNav Location"then gx=dM;break end end;if gx~=-1 then gD=bq[gx]gx=-1;for dM,dy in pairs(e[0])do if dy.name and dy.name=="SatNav Location"then gx=dM;break end end;if gx>-1 then e[0][gx]=gD end;ct.UpdateAtlasLocationsList()c2=gD.name.." position updated"end end;for M=1,#cV do if cV[M].name==qe then bm=M;a.print("Index = "..bm.." "..cV[M].name)ct.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pB.onFlush()local function rg(rh,ri)local rj=vec3()local rk=vec3()if rh==axisCommandId.longitudinal then rj=vec3(bO.getOrientationForward())rk=cI elseif rh==axisCommandId.vertical then rj=vec3(bO.getOrientationUp())rk=p_ elseif rh==axisCommandId.lateral then rj=vec3(bO.getOrientationRight())rk=cJ else return vec3()end;local rl=vec3(b.getWorldGravity())local rm=rl:dot(rk)local rn=vec3(bO.getWorldAirFrictionAcceleration())local ro=rn:dot(rk)local rp=cK:dot(rj)local rq=ri*constants.kph2m;if rr==nil then rr=pid.new(10,0,10.0)end;rr:inject(rq-rp)local rs=rr:get()local rt=(rs-ro-rm)*rk;return rt end;local function ru(rh,ri)local rj=vec3()local rk=vec3()if rh==axisCommandId.longitudinal then rj=vec3(bO.getOrientationForward())rk=cI elseif rh==axisCommandId.vertical then rj=vec3(bO.getOrientationUp())rk=p_ elseif rh==axisCommandId.lateral then rj=vec3(bO.getOrientationRight())rk=cJ else return vec3()end;local rl=vec3(b.getWorldGravity())local rm=rl:dot(rk)local rn=vec3(bO.getWorldAirFrictionAcceleration())local ro=rn:dot(rk)local rp=cK:dot(rj)local rq=ri*constants.kph2m;if rv==nil then rv=pid.new(10,0,10.0)end;rv:inject(rq-rp)local rs=rv:get()local rt=(rs-ro-rm)*rk;return rt end;local function rw(rx,k0,g2)local ry=rx:cross(g2):normalize_inplace()local kN=math.acos(dm(ry:dot(-k0),-1,1))*constants.rad2deg;if ry:cross(-k0):dot(g2)<0 then kN=-kN end;return kN end;local function rz()if d0 and not b7 then local et=d0[1]local i3,i4=d0[2],d0[3]local rA=math.min(i3,i4 or i3)local rB=rA/cM;local rC=b8 and(cM<42 or ce~=-1)local rD=b6 or br or bu or b4;if rD and not rC and(c5*1.5>rA or rB<1)then b1="Collision"bG={}q2=0;if b6 then cu.ToggleAltitudeHold()end;if bu then cu.ToggleLockPitch()end;c2="Autopilot Cancelled due to possible collision"a.print(et.name.." COLLISION "..iK(rB).." / "..iJ(rA,2))cu.ResetAutopilots(1)lq=true;if cf then b7=true end;cA=true end;if rB<11 then c_=et.name.." COLLISION "..iK(rB).." / "..iJ(rA,2)else c_=et.name.." collision "..iK(rB)end;if rB<6 then fV("alarm","AL",2)end else c_=false end end;if antigrav and not q then if not cR and antigrav.getBaseAltitude()~=bw then qc=bw end end;if df then d:setEngineForceCommand('hover',vec3(),1)df=false end;cS=iF:getAxisCommandType(0)==axisCommandType.byThrottle;aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aK=math.max(aK,0.01)aO=math.max(aO,0.01)aR=math.max(aR,0.01)aS=math.max(aS,0.01)aJ=math.max(aJ,0.01)local rE=dm(bW+pU+a.getControlDeviceForwardInput(),-1,1)local rF=dm(bX+pW+a.getControlDeviceYawInput(),-1,1)local rG=dm(bY+pV-a.getControlDeviceLeftRightInput(),-1,1)local rH=b1 and 1 or 0;cN=vec3(b.getWorldVertical())if cN==nil or cN:len()==0 then cN=(kA.center-cP):normalize()end;p_=vec3(bO.getWorldOrientationUp())cI=vec3(bO.getWorldOrientationForward())cJ=vec3(bO.getWorldOrientationRight())cL=vec3(bO.getWorldVelocity())cK=vec3(bO.getVelocity())cP=vec3(bO.getWorldPosition())ci=bO.getMass()cM=vec3(cL):len()cO=-cN:dot(cL)cU=getRoll(cN,cI,cJ)local rI=cU/180*math.pi;local rJ=math.cos(rI)local rK=math.sin(rI)cT=rw(cN,cI,cJ*rJ+p_*rK)local rL=cL:normalize()local rM=e_(cU)local rN=utils.sign(cU)local rO=vec3(bO.getWorldAngularVelocity())local rP=rE*aP*cJ+rF*aK*cI+rG*aQ*p_;if cA==true and cN:len()>0.01 then local rQ=e_(pX-cU)if((b3 or b9 or b7 or cb or b6 or bA)and rQ>0 or cf and rQ<aL and p)and rF==0 and e_(cT)<85 then local rR=pX;local rS=aJ;if not cf then rS=rS/4;pX=0;rR=0 end;if rT==nil then rT=pid.new(rS*0.01,0,rS*0.1)end;rT:inject(rR-cU)local rU=rT:get()rP=rP+rU*cI end end;local rV=1;local rW=0;local rX=1;bR=0;cg=bN()cf=false or ch<kA.noAtmosphericDensityAltitude and cg>0.00001;ch=b.getAltitude()ce=qq()bP=bL()pG=bP;if bn and ce>-1 and ce-3<_ then if iF.targetGroundAltitudeActivated then iF:deactivateGroundEngineAltitudeStabilization()end end;if cv then qf=not qf;if qf then cv.UpdateRadar()end;if E then rz()end end;if antigrav then cR=antigrav.isActive()==1 end;local rY=1;local rZ=1;local r_=bP-pG;local s0=-math.deg(qm(p_,cL,cI))local s1=math.deg(qm(cJ,cL,cI))local gs=cN*-1;cB=cf and s0<-N or s0>N or s1<-O or s1>O;local s2=a.getMouseDeltaX()local s3=a.getMouseDeltaY()if qg then local s4=bL()-qg;s2=s2*s4/0.016;s3=s3*s4/0.016 end;qg=bL()if o and not c0 then s3=-s3 end;pV=0;pW=0;pU=0;fZ=cp[0]local s5=bO.getWorldPosition()kA=fZ:closestBody(s5)s6=cr(kA)fu=s6:orbitalParameters(s5,cL)if ch==0 then ch=(cP-kA.center):len()-kA.radius end;cZ=c.getClosestPlanetInfluence()>0 or ch>0 and ch<200000;local oc=kA:getGravity(s5):len()*ci;pX=0;local s7=bO.getMaxThrustAlongAxis("ground",bO.getOrientationUp())[1]if q6==0 then if iE()==1 and c0 then if not cy then c8=dm(c8+s2/2,-ck/2,ck/2)c9=dm(c9+s3/2,-cl/2,cl/2)end else c8=0;c9=0 end else c8=dm(c8+s2/2,-ck/2,ck/2)c9=dm(c9+s3/2,-cl/2,cl/2)de=dp(c8*c8+c9*c9)if not c0 and iE()==0 then local kW,kX=1,1;if bJ=="SCOPE"then kW,kX=d6/90,d6/90 end;if g=="virtual joystick"then if de>az then pV=pV-dm(e_(c8)-az,0,ck/2)*utils.sign(c8)*aH*kW;pU=pU-dm(e_(c9)-az,0,cl/2)*utils.sign(c9)*aI*kX end else c8=0;c9=0;if g=="mouse"then pU=(-utils.smoothstep(s3,-100,100)+0.5)*2*rY;pV=(-utils.smoothstep(s2,-100,100)+0.5)*2*rZ end end end end;local s8=cM>27777;if cM>X/3.6 and not cf and not b4 and not s8 then c2="Space Speed Engine Shutoff reached"q2=0 end;if not s8 and s9 then if not b1 then cu.BrakeToggle()end;if b4 then cu.ResetAutopilots(1)end;q2=0 end;s9=s8;if cg>0.09 then if cM>cC/3.6 and not t and not pC then b1="SpdLmt"pC=true elseif not t and pC then if cM<cC/3.6 then b1=false;pC=false end end end;if b3 then if cb then b1=false;local sa=false;if g6 and cb==true then sa=qC(g6.position-cP,0.1)else sa=qC(vec3(cL),0.01)end;cA=true;if sa then q3=bM(cC)if(e_(cU)<2 or e_(cT)>85)and cM>=cC/3.6-1 then b1=false;b3=false;if cb~=2 then pT=true end;if cb==true then cd=true end;cb=false;b4=false;cu.BeginReentry()end elseif cf and t then q2=1 end elseif cM>iY then qC(vec3(cL),0.01)end end;if b2 then if cf then b2=false elseif cM>iY then qC(-vec3(cL))end end;if not b3 and cb and not bA then if not cf then if cb~=2 then pT=true end;cu.BeginReentry()cb=false;cd=true else cb=false;if not qd then qd=true end end end;if cd and g6 and(ch<bb+250 and ch>bb-250)and cM*3.6>cC-250 and e_(cO)<25 and cg>=0.1 and(g6.position-cP):len()>2000+ch then if not qd then qd=true end;cd=false end;if ba then cA=true;local sb=bb;if cO<-30 then c2="Unable to achieve lift. Safety Landing."bZ=0;cA=p;ba=false;b7=true elseif not q and cR or bb<kA.spaceEngineMinAltitude then if cR then sb=antigrav.getBaseAltitude()end;if ch<sb-100 then pY=0;bZ=15;b1=false elseif cO>0 then b1="VTO Limit"bZ=0 elseif cO<-30 then b1="VTO Fall"bZ=15 elseif ch>=sb then if cR then if b4 or br then cu.ToggleVerticalTakeoff()else b1="VTO Complete"ba=false end;c2="Takeoff complete. Singularity engaged"fV("aggLk","AG")else b1=false;c2="VTO complete. Engaging Horizontal Flight"fV("vtoc","VT")cu.ToggleVerticalTakeoff()end;bZ=0 end else if cg>0.08 then pY=0;b1=false;bZ=20 elseif cg<0.08 and cf then b1=false;if cG then pY=0;bZ=20 else bZ=0;pY=36;q3=3500 end else cA=p;bA=true;cF=false;sc=false;pL=false;pJ=nil;pK=nil;if pO==nil then pO=kA end;cE=sb;pN=true;ba=false end end;if pY~=nil then if sd==nil then sd=pid.new(2*0.01,0,2*0.1)end;local se=dm(pY-cT,-O*0.80,O*0.80)sd:inject(se)local sf=dm(sd:get(),-1,1)pU=sf end end;if bA then local function sg()if fu.periapsis.altitude>=cE*0.99 and fu.apoapsis.altitude>=cE*0.99 and fu.periapsis.altitude<fu.apoapsis.altitude and fu.periapsis.altitude*1.05>=fu.apoapsis.altitude and e_(cE-ch)<1000 then return true else return false end end;local qJ;local sh=false;local si=iJ(cE)if pO==nil then pO=kA;if br then pO=c7 end end;if not pN then cE=bM(pO.radius+pO.surfaceMaxAltitude+V)if pO.hasAtmosphere then cE=bM(pO.radius+pO.noAtmosphericDensityAltitude+V)end;pN=true end;if pZ.VectorToTarget and g6 then qJ=g6.position-cP end;local sj,sk=cr(pO):escapeAndOrbitalSpeed((cP-pO.center):len()-pO.radius)local sl=cU;if not pL then local sm=false;local sn=false;q2=0;pK=0;cD="Aligning to orbital path - OrbitHeight: "..si;if pZ.VectorToTarget then qC(qJ:normalize():project_on_plane(cN))sh=cI:dot(qJ:project_on_plane(p_):normalize())>0.95 else qC(cL)sh=s0<0.5;if cM<150 then sh=true end end;pU=0;pJ=0;if cT<=pJ+2 and cT>=pJ-2 then sm=true else sm=false end;if sl<=pK+2 and sl>=pK-2 then sn=true else sn=false end;if sm and sn and sh then pJ=nil;pK=nil;pL=true end else if pZ.VectorToTarget then qC(qJ:normalize():project_on_plane(cN))elseif cM>150 then qC(cL)end;pU=0;if pZ.VectorToTarget and g6 then local c5,dR=cq.computeDistanceAndTime(cM,cC/3.6,ci,0,0,bt)if cF and qJ:len()>15000+c5+ch then cD="Orbiting to Target"if ch-100<=pO.noAtmosphericDensityAltitude or lu>fu.timeToPeriapsis and fu.periapsis.altitude<pO.noAtmosphericDensityAltitude or not sg()and fu.eccentricity>0.1 then c2="Re-Aligning Orbit"cF=false end elseif cF or qJ:len()<15000+c5+ch then c2="Orbit complete, proceeding with reentry"fV("orCom","OB")bl=g6.position;pT=true;cd=true;pZ.VectorToTarget,pZ.AutopilotAlign=false,false;cu.ToggleIntoOrbit()cu.BeginReentry()return end end;if fu.periapsis~=nil and fu.apoapsis~=nil and fu.eccentricity<1 and ch>cE*0.9 and ch<cE*1.4 then if fu.apoapsis~=nil then if sg()or cF then if cF then b1=false;q2=0;pJ=0;if not pZ.VectorToTarget then c2="Orbit complete"fV("orCom","OB")cu.ToggleIntoOrbit()end else pP=pP+1;if pP>=2 then cF=true end end else cD="Adjusting Orbit - OrbitHeight: "..si;pM=true;q3=sk*3.6+1;local so=cE-ch;if sp==nil then sp=pid.new(0.1,0,1*0.1)end;sp:inject(so-cO*dm(utils.smoothstep(2000-so,-2000,2000)^6*10,1,10))pJ=dm(sp:get(),-60,60)end end else local sq=2.75;local sr=e_(fW(sj*sq))local oq=sr%50;if oq>0 then sr=sr-oq+50 end;b1=false;if ch<cE*0.8 then cD="Escaping planet gravity - OrbitHeight: "..si;pJ=utils.map(cO,200,0,-15,80)elseif ch>=cE*0.8 and ch<cE*1.15 then cD="Approaching orbital corridor - OrbitHeight: "..si;sr=sr*0.75;pJ=utils.map(cO,100,-100,-15,65)elseif ch>=cE*1.15 and ch<cE*1.5 then cD="Approaching orbital corridor - OrbitHeight: "..si;sr=sr*0.75;if cO<0 or pM then pJ=utils.map(ch,cE*1.5,cE*1.01,-30,0)else pJ=utils.map(ch,cE*0.99,cE*1.5,0,30)end elseif ch>cE*1.5 then cD="Reentering orbital corridor - OrbitHeight: "..si;pJ=-65;local ss=utils.map(cO,-150,-400,1,0.55)sr=sr*ss end;q3=bM(sr)end end;if pJ~=nil then if st==nil then st=pid.new(1*0.01,0,5*0.1)end;local su=pJ-cT;st:inject(su)local sv=dm(st:get(),-0.5,0.5)pU=sv end end;if b4 and not cf and not cb then local function sw(dj,fu)a.print(dj)b1=false;be=false;b4=false;qQ=false;bh="Aligning"q2=0;pS=false;c2=dj;fV("apCom","AP")if fu or cb then if fu and gq~=nil and not cb then if not ch or ch==0 then return end;cE=ch;pN=true end;cu.ToggleIntoOrbit()end end;local sx,sy=bl,false;if g6 and g6.planetname~="Space"then bd=true;if not qQ then local sz=(g6.position-c7.center):normalize()local sA=sz:project_on_plane((c7.center-cP):normalize()):normalize()local sB=c7.center+sA*(c7.radius+gq)local sC=g6.position+(g6.position-c7.center):normalize()*(gq-c7:getAltitude(g6.position))if(cP-sB):len()<(cP-sC):len()then sx=sB else sx=sC;bg=0 end;bl=sx;cu.showWayPoint(c7,bl)sy=true;qQ=true end;bi=0 elseif g6 and g6.planetname=="Space"then if not qQ then bi=0;sy=true;bd=true;qQ=true;sx=g6.position+(cP-g6.position):normalize()*T;bl=sx end elseif g6==nil then bi=0;if not qQ then local sz=(cP+cL*100000-c7.center):normalize()local sA=sz:project_on_plane((c7.center-cP):normalize()):normalize()if sA:len()<1 then sz=(cP+cI*100000-c7.center):normalize()sA=sz:project_on_plane((c7.center-cP):normalize()):normalize()end;sx=c7.center+sA*(c7.radius+gq)bl=sx;qQ=true;sy=true;bd=true;cu.showWayPoint(c7,bl)end end;r5=(vec3(sx)-cP):len()local ls,eK,eL=cp:getPlanetarySystem(0):castIntersections(cP,cL:normalize(),function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)local lt=eK;if eL~=nil and eK~=nil then lt=math.min(eL,eK)end;if lt~=nil and lt<r5 and ls.name==c7.name then r5=lt end;local sa=true;local sD=(c7.center-(cP+vec3(cL):normalize()*r5)):len()-c7.radius;local lo=iJ(sD)qa=gi;qb='{"label": "Projected Altitude", "value": "'..lo..'"}'if cM>50 and bc then local qJ=vec3(sx)-cP;local sE=dm(math.deg(qm(p_,cL:normalize(),qJ:normalize()))*cM/500,-90,90)local sF=dm(math.deg(qm(cJ,cL:normalize(),qJ:normalize()))*cM/500,-90,90)if e_(sE)<20 and e_(sF)<20 then sE=sE*2;sF=sF*2 end;if e_(sE)<2 and e_(sF)<2 then sE=sE*2;sF=sF*2 end;local s0=-math.deg(qm(p_,cI,cL:normalize()))local s1=-math.deg(qm(cJ,cI,cL:normalize()))if sG==nil then sG=pid.new(2*0.01,0,2*0.1)end;sG:inject(sF-s1)local sH=dm(sG:get(),-1,1)pU=pU+sH;if sI==nil then sI=pid.new(2*0.01,0,2*0.1)end;sI:inject(sE-s0)local sJ=dm(sI:get(),-1,1)pV=pV+sJ;sy=true;if e_(sE)>2 or e_(sF)>2 then if bh~="Adjusting Trajectory"then bh="Adjusting Trajectory"fV("apAdj","AP")end else if bh~="Accelerating"then bh="Accelerating"fV("apAcc","AP")end end elseif bc and cM<=50 then qC((sx-cP):normalize())end;if sD<gq*1.5 then bg=cC/3.6;if g6==nil then dR,bg=cr(c7):escapeAndOrbitalSpeed(sD)end end;local c5,c6;if not b5 then c5,c6=qi(cM)else c5,c6=ql(cM)end;if b4 and not bc and not bf and not be then local ls,lt=cu.checkLOS((bl-cP):normalize())if c7.name~=kA.name then if ls~=nil and c7.name~=ls.name and lt<r5 then c2="Collision with "..ls.name.." in "..iJ(lt).."\nClear LOS to continue."c3=5;q7=true else q7=false;c2=""end end end;if not q7 then if not bf and not be and not sy then sa=qC((sx-cP):normalize())elseif b5 and(be or bf)then sa=qC(-vec3(cL):normalize())end end;if bc then if not pS then b1=false;q2=a1;bQ=fW(a1,2)pS=true end;local r6=c.getThrottle()if t then r6=bQ end;local sK=99999;local oo=-vec3(bO.getWorldAcceleration()):dot(cL:normalize())local sL=dm(cL:dot((sx-cP):normalize()),0,cM)if sL>0 or oo>0 then sK=cq.computeTravelTime(sL,oo,r5-c5)end;if ab>dg then ab=dg-0.2 end;if cK:len()>=ab or r6==0 and pS or a2/4>sK then bc=false;if bh~="Cruising"then fV("apCru","AP")bh="Cruising"end;bf=true;q2=0 end;local sM=r5;if sM<=c5 or H and cX<=c5+10000 and cW then if H and cX<=c5+10000 and cW then if cX<pD and cX>2000 then cu.ResetAutopilots(1)c2="Autopilot cancelled to prevent crossing PvP Line"b1="PvP Prevent"pD=cX else pD=cX;return end end;bc=false;if bh~="Braking"then fV("apBrk","AP")bh="Braking"end;be=true;q2=0;pS=false end elseif be then if bh~="Orbiting to Target"then b1="AP Brk"end;if b5 then q2=1;q4=true end;local dR,sk=cr(c7):escapeAndOrbitalSpeed((cP-kA.center):len()-kA.radius)local qJ;if g6 then qJ=g6.position-cP end;if g6 and g6.planetname=="Space"and cM<50 then if#bG>0 then if not qd then table.remove(bG,1)end;if#bG>0 then b1=false;if not qd then qd=2 end;return end end;sw("Autopilot complete, arrived at space location")b1="Space Arrival"elseif g6 and g6.planetname~="Space"and cM<=sk and(fu.apoapsis==nil or fu.periapsis==nil or fu.apoapsis.altitude<=0 or fu.periapsis.altitude<=0)then sw("Autopilot complete, commencing reentry")bl=g6.position;cb=true;cu.showWayPoint(c7,bl)elseif(g6 and g6.planetname~="Space"or g6==nil)and fu.periapsis~=nil and fu.periapsis.altitude>0 and fu.eccentricity<1 or bh=="Circularizing"then if bh~="Circularizing"then fV("apCir","AP")bh="Circularizing"end;if cM<=sk then if g6 then if cL:normalize():dot(qJ:normalize())>0.4 then if bh~="Orbiting to Target"then fV("apOrb","OB")bh="Orbiting to Target"end;if not qS then b1=false;cu.showWayPoint(c7,g6.position)qS=true end else sw("Autopilot complete, proceeding with reentry")bl=g6.position;cb=true;cu.showWayPoint(c7,g6.position)qS=false end else sw("Autopilot completed, setting orbit",true)b1=false end end elseif bh=="Circularizing"then sw("Autopilot complete, fixing Orbit",true)end elseif bf then local sM=r5;if sM<=c5 or H and cX<=c5+10000 and cW then if H and cX<=c5+10000 and cW then if cX<pD and cX>2000 then if not qd then qd=true end;c2="Autopilot cancelled to prevent crossing PvP Line"b1="Prevent PvP"pD=cX else pD=cX;return end end;bc=false;if bh~="Braking"then fV("apBrk","AP")bh="Braking"end;be=true end;local r6=c.getThrottle()if t then r6=bQ end;if r6>0 then bc=true;if bh~="Accelerating"then bh="Accelerating"fV("apAcc","AP")end;bf=false end else if sa then if not bd and g6==nil or not bd and g6 and g6.planetname~="Space"then if not cb then bl=vec3(c7.center)+(gq+c7.radius)*cJ;sN=p_;sO=cJ end;bd=true elseif sa and not q7 then bc=true;if bh~="Accelerating"then bh="Accelerating"fV("apAcc","AP")end;if not pS then q2=a1;q4=true;bQ=fW(a1,2)pS=true;b1=false end end end end elseif b4 and(g6~=nil and g6.planetname~="Space"and cf)then c2="Autopilot complete, starting reentry"fV("apCom","AP")bl=g6.position;b1=false;be=false;b4=false;qQ=false;bh="Aligning"q2=0;pS=false;b3=true;cb=true;cu.showWayPoint(c7,g6.position)end;if b_ then cA=true;local sF=0;local fw=cP+vec3(c.getMasterPlayerRelativePosition())local sP=fw-cP;local sQ=vec3(sP):project_on(cI):len()local sR=vec3(sP):project_on(cJ):len()local ca=dp(sQ*sQ+sR*sR)qC(sP:normalize())local my=40;local sS=ca<my;local sT=100;local ri=dm((ca-my)/2,10,sT)pU=0;local sa=e_(pV)<0.1;if sa and cM<ri and not sS then b1=false;sF=-20 else b1="Follow"sF=0 end;local sU=0;if e_(sF-cT)>sU then if sV==nil then sV=pid.new(2*0.01,0,2*0.1)end;sV:inject(sF-cT)local sH=sV:get()pU=sH end end;if b6 or b7 or b9 or br or bu~=nil then local sW=bv;if sW then sW=sW*dm(cM/100,0.1,1)*cg else sW=bt end;if not cf then sW=bt end;q1=cI:project_on_plane(cN):normalize():dot(cL)if q1>100 then c5,c6=cq.computeDistanceAndTime(q1,100,ci,0,0,sW)local sX,sY=cq.computeDistanceAndTime(100,0,ci,0,0,sW*0.55)c5=c5+sX else c5,c6=cq.computeDistanceAndTime(q1,0,ci,0,0,sW*0.55)end;local so=bb-ch-cO;local sZ=200+cM;if b9 or cb then s_=2000+cM end;local t0=1;if b8 then t0=dm(cM/100,0.1,1)end;local sF=(utils.smoothstep(so,-sZ,sZ)-0.5)*2*Q*t0;if not b9 and not cb and not br and cI:dot(cL:normalize())<0.99 then sF=(utils.smoothstep(so,-sZ*dm(20-19*cg*10,1,20),sZ*dm(20-19*cg*10,1,20))-0.5)*2*Q*dm(2-cg*10,1,2)*t0 end;if not b6 then sF=0 end;if bu~=nil then if cZ and not bA then sF=bu else bu=nil end end;cA=true;local t1=pU;if b9 then local t2=bM(cC)local t3,t4=cq.computeDistanceAndTime(cM,t2/3.6,ci,0,0,bt-kA.gravity*9.8*ci)t3=t3==-1 and 5000 or t3;local qR=ch-(kA.noAtmosphericDensityAltitude+t3)local t5=ch>kA.noAtmosphericDensityAltitude+t3*1.35;if t5 then sF=R;if cM<=t2/3.6 and cM>t2/3.6-10 and e_(cL:normalize():dot(cI))>0.9 and not cS then bU=false;q2=1 end elseif(cS or iF:getTargetSpeed(axisCommandId.longitudinal)~=t2)and not t5 and not cf then q3=t2;q4=true end;if cS then if cM>t2/3.6 and not t5 then b1="Reentry Limit"if bQ>0 then q2=0 end else b1=false end else b1=false end;if cO>0 then b1="Reentry vSpd"end;if not pT then sF=-80;if ch<kA.surfaceMaxAltitude+(kA.atmosphereThickness-kA.surfaceMaxAltitude)*0.25 then c2="PARACHUTE DEPLOYED at "..fW(ch,0)b9=false;b7=true;lq=true;q2=0;sF=0;cA=p end elseif kA.noAtmosphericDensityAltitude>0 and t5 then cA=true elseif not t5 then if not cf and(cS or iF:getTargetSpeed(axisCommandId.longitudinal)~=t2)then q3=t2 end;if cM<t2/3.6+1 then b1=false;pT=false;b9=false;cA=true;q2=1 end end end;if cM>iY and not cc and not br and not b7 and u then qC(vec3(cL))end;if cY or(br or cc)and bm>0 and cf then local qJ;if cY then if type(cY)=="table"then qJ=cY elseif cY<3 and cY>0 then qJ=-cN:cross(cL)*5000 elseif cY>=3 then qJ=cN:cross(cL)*5000 elseif cY<0 then qJ=cL*25000 end elseif g6~=nil then qJ=g6.position-cP else qJ=c7.center-cP end;local sE=math.deg(qm(cN:normalize(),cL,qJ))*2;local mB=math.rad(e_(cU))if cM>aM and cf then local t6=1000+cM;local t7=(utils.smoothstep(so-cO*10,-t6,t6)-0.5)*2*Q;local t8=dm(90-t7,0,180)pX=dm(sE*2,-t8,t8)local t9=sE;sE=dm(dm(sE,-N*0.80,N*0.80)*math.cos(mB)+4*(cT-sF)*math.sin(math.rad(cU)),-N*0.80,N*0.80)local ta=1;if pX~=0 then ta=e_(mB/pX)end;ta=(90-dm(e_(pX-cU),0,90))/90;local tb=sF;if e_(cU)>90 then tb=-tb end;sF=ta*dm(dm(tb*math.cos(mB),-O*0.8,O*0.8)+e_(dm(e_(t9)*math.sin(mB),-O*0.80,O*0.80)),-O*0.80,O*0.80)else pX=0;sE=dm(sE,-N*0.80,N*0.80)end;local tc=s0-sE;if cY and e_(tc)<=0.0001 and(type(cY)=="table"or type(cY)~="table"and cY<0 and e_(cU)<1)then if cY==-2 then cu.ToggleAltitudeHold()end;cY=nil;fV("180Off","BR")return end;if not cB and cM>aM and cf then if td==nil then td=pid.new(2*0.01,0,2*0.1)end;td:inject(tc)local sJ=dm(td:get(),-1,1)pV=pV+sJ elseif cf and ce>-1 or cM<aM then qC(qJ)elseif cB and cf then if(s0<-N or s0>N)and cf then qC(cL)end;if(s1<-O or s1>O)and cf then sF=dm(cT-s1,cT-O*0.80,cT+O*0.80)end end;if g6~=nil and not cc then local sb=kA:getAltitude(g6.position)local qR=qJ:project_on_plane(cN):len()lq=true;if bb<kA.noAtmosphericDensityAltitude and not cc and not b8 and not b9 and(qR<=c5 and qJ:len()<kA.radius)and(cL:project_on_plane(cN):normalize():dot(qJ:project_on_plane(cN):normalize())>0.99 or lw=="Finalizing Approach")then lw="Finalizing Approach"if#bG>0 then if not qd then table.remove(bG,1)end;if#bG>0 then if not qd then qd=2 end;return end end;q2=0;if b6 then cu.ToggleAltitudeHold()br=true end;b1="AP Finalizing"elseif not b8 then b1=false end;if lw=="Finalizing Approach"and(q1<0.1 or qR<0.1 or te~=nil and te<qR)then fV("bklOn","BL")b7=true;dc=true;if g6.heading then dd=g6.heading else dd=nil end;br=false;lw="Proceeding to Waypoint"c_=false end;te=qR end elseif br and not cf and bb>kA.noAtmosphericDensityAltitude and not(cc or b9)then if g6~=nil and c7.name==kA.name then local qJ=g6.position-cP;local sb=kA:getAltitude(g6.position)local qR=dp(qJ:len()^2-(ch-sb)^2)local sW=bv;if sW then c5,c6=cq.computeDistanceAndTime(cM,0,ci,0,0,sW/2)lq=true;if qR<=c5+cM*r_/2 and cL:project_on_plane(cN):normalize():dot(qJ:project_on_plane(cN):normalize())>0.99 then if kA.hasAtmosphere then b1=false;b3=false;pT=true;cb=false;cd=true;b4=false;cu.BeginReentry()end end;te=qR end end end;if not cf and(b6 and bb>kA.noAtmosphericDensityAltitude)and not(cc or bA or b9)then if not cF and not bA then cE=bb;pN=true;if br then pZ.VectorToTarget=true end;cu.ToggleIntoOrbit()br=false;pL=true end end;if cB and cf and ce==-1 and cM>aM and lw~="Finalizing Approach"then qC(cL)sF=dm(cT-s1,cT-O*0.80,cT+O*0.80)end;pU=t1;local qv=-1;if b7 then if not q8 then if not cS then q2=0 end;iF:setTargetGroundAltitude(500)iF:activateGroundEngineAltitudeStabilization(500)bC=true;q8=true end;sF=0;local tf=false;local tg=math.abs(q1)if not q and cR then tf=antigrav.getBaseAltitude()if tf<kA.surfaceMaxAltitude and g6==nil or g6~=nil and kA:getAltitude(g6.position)>tf then tf=false end else tf=false end;if dd then if tg<0.05 then if cO>-P then b1=false else b1="BL Align BLR"end;if qC(dd,0.001)then dd=nil;cA=p else pU=0;cA=true end else b1="BL Align Hzn"end;if tf and e_(ch-tf)<250 then b1="AGG Align"end else local th=false;local ti=30;if tg<10 and s7~=nil and s7>0 then local tj=dm(cg,0.4,2)local sW=bv*dm(cM/100,0.1,1)*tj;local tk=s7*tj+sW-oc;local tl=sW/2-oc;local tm=cM-dp(e_(tl/2)*20/(0.5*ci))*utils.sign(tl)if tm<0 then tm=0 end;local tn;if cM>100 then local to,dR=cq.computeDistanceAndTime(cM,100,ci,0,0,sW)local tp,dR=cq.computeDistanceAndTime(100,0,ci,0,0,dp(sW))tn=to+tp else tn=cq.computeDistanceAndTime(cM,0,ci,0,0,dp(sW))end;if tn<20 then b1=false else local tq=0;if tm>100 then local tr,dR=cq.computeDistanceAndTime(tm,100,ci,0,0,tk)local ts,dR=cq.computeDistanceAndTime(100,0,ci,0,0,s7*tj+dp(sW)-oc)tq=tr+ts else tq,dR=cq.computeDistanceAndTime(tm,0,ci,0,0,s7*tj+dp(sW)-oc)end;tq=(tq+15+cM*r_)*1.1;local tt=dc and g6~=nil and kA:getAltitude(g6.position)>0 and g6.safe;local sb=nil;if tf and tf<ch then sb=tf elseif tt then sb=kA:getAltitude(g6.position)+250 elseif ch>kA.surfaceMaxAltitude then sb=kA.surfaceMaxAltitude end;if d0 then local tu=kA:getAltitude(d0[1].center)if sb then if tu>sb then sb=tu end else sb=tu end end;if sb~=nil then local tv=ch-sb;th=true;if tv<=tq or tq==-1 or tg>0.05 and dc then if tg>0.05 and dc then b1="BL AP Hzn"else b1="BL Stop Dist"end else b1=false end end end end;qv=ce;if qv>-1 then if(cM<1 or cL:normalize():dot(cN)<0)and not dd then b7=false;b6=false;if not tf then q5=true;iF:setTargetGroundAltitude(_)end;bZ=0;b1="BL Complete"cA=p;dc=false else b1="BL Slowing"end elseif not th then if lq and cL:normalize():dot(-gs)<0.999 then b1="BL Strong"qC()elseif tg>10 or tg>0.05 and dc then b1="BL hSpd"elseif cO<-P then b1="BL BLR"else b1=false end end end else q8=false end;if b8 or cc then local ls,eL,eK;if bl~=nil then ls,eL,eK=cp:getPlanetarySystem(0):castIntersections(cP,(bl-cP):normalize(),function(et)if et.noAtmosphericDensityAltitude>0 then return et.radius+et.noAtmosphericDensityAltitude else return et.radius+et.surfaceMaxAltitude*1.5 end end)end;if cR and not cc then if ch>=bb-50 and cM>iY then b8=false;if not b4 and not br then b1="ATO Agg Arrive"q2=0 end end elseif e_(sF)<15 and ch/bb>0.75 then b8=false;if not cc then if cS and not t then d.control.cancelCurrentControlMasterMode()end elseif cc and cM<iY then b4=true;cc=false;b6=false;b8=false;q2=0 elseif cc then q2=0;b1="ATO Space"end elseif cc and not cf and c7~=nil and(ls==nil or ls.name==c7.name)then b4=true;cc=false;b6=false;b8=false;if not cS then q2=0 end;bc=true end end;local tw=ce>-1;local tx=cT;if(br or cc or cY)and not tw and cM>aM and cf then local mB=math.rad(e_(cU))tx=cT*e_(math.cos(mB))+s1*math.sin(mB)end;local ty=dm(sF-tx,-O*0.80,O*0.80)if not cf and br then ty=dm(sF-tx,-85,Q)elseif not cf then ty=dm(sF-tx,-Q,Q)end;if e_(cU)<5 or br or cY or b7 or tw or b6 then if sV==nil then sV=pid.new(5*0.01,0,5*0.1)end;sV:inject(ty)local sH=sV:get()pU=pU+sH end end;if antigrav~=nil and(antigrav and not q and ch<200000)then if bw==nil or bw<1000 then bw=1000 end;if tz~=bw then tz=bw;qc=tz end end;if(cf or b9 or cd)and t and cS then if tA==nil then tA=pid.new(0.1,0,1)end;local tB=0;if aV>0 and not b9 and cg>0.005 and cg<0.1 and cO>-50 then tB=(0.1-cg)*cC*aV end;tA:inject(cC/3.6+tB-cL:dot(cI))local tC=tA:get()bT=dm(tC,-1,1)if not d8 then if bT<bQ and(cg>0.005 or b9 or cd)then bS=true;d8=dm(bT,0.01,1)else bS=false;d8=bQ end end;if tD==nil then tD=pid.new(1*0.01,0,1*0.1)end;tD:inject(cL:len()-cC/3.6-tB)local tE=dm(tD:get(),0,1)if cf and cO<-80 or(cg>0.005 or b9 or cd)then bR=tE end;if bR>0 then if bS and bT==0.01 and not d8 then d8=0 end else bT=dm(bT,0.01,1)end;local tF=''local tG=vec3()local tH=rg(axisCommandId.vertical,bZ*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tH,rW)local tI='thrust analog longitudinal 'if bD=="All"or bD=="Longitude"then tI=tI..aW end;local tJ=iF:getAxisCommandType(axisCommandId.longitudinal)local tK=iF:composeAxisAccelerationFromThrottle(tI,axisCommandId.longitudinal)local tL=ru(axisCommandId.lateral,bz*1000)tF=tF..' , '.."lateral airfoil , lateral ground "tG=tG+tL;if tG:len()>constants.epsilon then d:setEngineForceCommand(tF,tG,rW,'','','',rX)end;d:setEngineForceCommand(tI,tK,rV)local tM='thrust analog vertical fueled 'local tN='thrust analog lateral fueled 'if bD=="All"or bD=="Lateral"then tN=tN..aX end;if bD=="All"or bD=="Vertical"then tM=tM..aY end;if bZ~=0 or b7 and b1 or not bn and not bC then d:setEngineForceCommand(tM,tH,rV)else d:setEngineForceCommand(tM,vec3(),rV)end;if bz~=0 then d:setEngineForceCommand(tN,tL,rV)else d:setEngineForceCommand(tN,vec3(),rV)end;if rH==0 then rH=bR end;local tO=-rH*(aR*cL+aS*rL)d:setEngineForceCommand('brake',tO)else if t then if not d8 then d8=bQ end end;local ri=c.getAxisCommandValue(0)if not cS then if tD==nil then tD=pid.new(1*0.01,0,1*0.1)end;tD:inject(cL:len()-ri/3.6)local tE=dm(tD:get(),0,1)rH=dm(rH+tE,0,1)end;local tO=-rH*(aR*cL+aS*rL)d:setEngineForceCommand('brake',tO)local tF=''local tG=vec3()local tP=false;local tI='thrust analog longitudinal 'if bD=="All"or bD=="Longitude"then tI=tI..aW end;local tJ=iF:getAxisCommandType(axisCommandId.longitudinal)if tJ==axisCommandType.byThrottle then local tK=iF:composeAxisAccelerationFromThrottle(tI,axisCommandId.longitudinal)d:setEngineForceCommand(tI,tK,rV)elseif tJ==axisCommandType.byTargetSpeed then local tK=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tF=tF..' , '..tI;tG=tG+tK;if iF:getTargetSpeed(axisCommandId.longitudinal)==0 or iF:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iF:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tP=true end end;local tN='thrust analog lateral 'if bD=="All"or bD=="Lateral"then tN=tN..aX end;local tQ=iF:getAxisCommandType(axisCommandId.lateral)if tQ==axisCommandType.byThrottle then local tR=iF:composeAxisAccelerationFromThrottle(tN,axisCommandId.lateral)d:setEngineForceCommand(tN,tR,rV)elseif tQ==axisCommandType.byTargetSpeed then local tL=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tF=tF..' , '..tN;tG=tG+tL end;local tM='thrust analog vertical 'if bD=="All"or bD=="Vertical"then tM=tM..aY end;local tS=iF:getAxisCommandType(axisCommandId.vertical)if tS==axisCommandType.byThrottle then local tH=iF:composeAxisAccelerationFromThrottle(tM,axisCommandId.vertical)if bZ~=0 or b7 and b1 then d:setEngineForceCommand(tM,tH,rV,'airfoil','ground','',rX)else d:setEngineForceCommand(tM,vec3(),rV)d:setEngineForceCommand('airfoil vertical',tH,rV,'airfoil','','',rX)d:setEngineForceCommand('ground vertical',tH,rV,'ground','','',rX)end elseif tS==axisCommandType.byTargetSpeed then if bZ<0 then d:setEngineForceCommand('hover',vec3(),rV)end;local tT=iF:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tF=tF..' , '..tM;tG=tG+tT end;if tG:len()>constants.epsilon then if rH~=0 or tP or e_(rL:dot(cI))<0.5 then tF=tF..', brake'end;d:setEngineForceCommand(tF,tG,rW,'','','',rX)end end;local tU=aO*(rP-rO)local tV=vec3(bO.getWorldAirFrictionAngularAcceleration())tU=tU-tV;d:setEngineTorqueCommand('torque',tU,rV,'airfoil','','',rX)d:setBoosterCommand('rocket_engine')if c4 and not n then local fq=cK:len()local tW=0.15;if not cS then local tX=iF:getTargetSpeed(axisCommandId.longitudinal)if fq*3.6>tX*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fq*3.6<tX*(1-tW)and not tY then tY=true;d:toggleBoosters()end else local r6=c.getThrottle()if t then r6=bQ*100 end;local ri=r6/100;if not cf then ri=ri*ab;if fq>=ri*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fq<ri*(1-tW)and not tY then tY=true;d:toggleBoosters()end else local t2=bM(cC)ri=ri*t2/3.6;if fq>=ri*(1-tW)and tY then tY=false;d:toggleBoosters()elseif fq<ri*(1-tW)and not tY then tY=true;d:toggleBoosters()end end end end end;if tZ then for dM,dy in pairs(tZ)do pB[dM]=dy end end;ce=qq()return pB end;local function t_(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u0,iE,iF,iG,u1,gN,fW,e5,dn,dm,fV,iI,pA)local bO=DUConstruct;local u2={}local u3=true;local u4=5;local u5=5;local u6=u4;local u7=u5;local u8=bP;function u2.landingGear()bn=not bn;if bn then br=false;bu=nil;cu.cmdThrottle(0)if vBooster or hover then if cf and ce==-1 then fV("bklOn","BL")lq=true;b9=false;b8=false;ba=false;b6=false;if b7 then dc=not dc end;b7=true;cA=true;bn=false else if bV then fV("grOut","LG",1)d.control.deployLandingGears()end;dc=false;iF:setTargetGroundAltitude(_)if cf then b1="Landing"end end elseif bV and not b7 then fV("grOut","LG",1)d.control.deployLandingGears()end else if bV then fV("grIn","LG",1)d.control.retractLandingGears()end;iF:activateGroundEngineAltitudeStabilization(u9)if bC then if _<iF.targetGroundAltitude then iF:setTargetGroundAltitude(iF.targetGroundAltitude)else iF:setTargetGroundAltitude(Z)end end end end;function u2.startControl(ua)local function ub(r1)local r2=1;local function uc(ud,r1)local ue={kA.surfaceMaxAltitude+100,kA.spaceEngineMinAltitude-0.01*kA.noAtmosphericDensityAltitude,kA.noAtmosphericDensityAltitude+V,kA.radius*(U-1)+kA.noAtmosphericDensityAltitude}local uf=ud;for dR,dy in ipairs(ue)do if r1 and uf>dy then ud=dy elseif ud<dy and not r1 then ud=dy;break end end;return ud end;if r1 then r2=-1 end;if not q and cR then if c0 and r1 then bw=1000 elseif bw~=nil then bw=bw+r2*u5;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end else bw=tz+r2*100 end elseif b6 or ba or bA then if bA then if c0 then cE=uc(cE,r1)else cE=cE+r2*u4 end;if cE<kA.noAtmosphericDensityAltitude then cE=kA.noAtmosphericDensityAltitude end else if c0 and cf then bb=uc(bb,r1)else bb=bb+r2*u4 end end else iF:updateTargetGroundAltitudeFromActionStart(r2*1.0)end end;local function ug(uh)if not cf then c2="Flight Assist in Atmo only"return end;local dv=type(uh)if cY==nil then if dv=="table"then if b4 or br then cu.ToggleAutopilot()end;fV("180On","BR")elseif uh==1 then fV("bnkLft","BR")else fV("bnkRht","BR")end;if not b6 and not b4 and not br then cu.ToggleAltitudeHold()if dv~="table"then uh=uh+1 end end;cY=uh else fV("180Off","BR")cY=nil end end;local function ui()if iG()==1 then c8=0;c9=0;u1(bj)elseif iE()==1 and y then cz=false;cy=false end;c0=false end;if ua=="gear"then cw.landingGear()elseif ua=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ua=="forward"then if p2 and not cf and not b4 then b3=not b3;b2=false else bW=bW-1 end elseif ua=="backward"then if p2 then if not cf then if not b4 then b2=not b2;b3=false else b5=not b5 end else ug(-cL*5000)end else bW=bW+1 end elseif ua=="left"then if p2 then ug(1)else bX=bX-1 end elseif ua=="right"then if p2 then ug(3)else bX=bX+1 end elseif ua=="yawright"then bY=bY-1;dd=nil elseif ua=="yawleft"then bY=bY+1;dd=nil elseif ua=="straferight"then iF:updateCommandFromActionStart(axisCommandId.lateral,1.0)bz=1 elseif ua=="strafeleft"then iF:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bz=-1 elseif ua=="up"then bZ=bZ+1;if ce-3<_ and ch>0 and bn then cw.landingGear()end;iF:deactivateGroundEngineAltitudeStabilization()iF:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ua=="down"then bZ=bZ-1;iF:deactivateGroundEngineAltitudeStabilization()iF:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ua=="groundaltitudeup"then ub()elseif ua=="groundaltitudedown"then ub(true)elseif ua=="option1"then uj=false;if p2 and c0 then local uk=""for M=1,#d3 do uk=uk.."| Name: "..a.getPlayerName(d3[M]).." Mass: "..fW(bO.getBoardedPlayerMass(d3[M])/1000,1).."t "end;a.print("Onboard: "..uk)return end;ct.adjustAutopilotTargetIndex()elseif ua=="option2"then uj=false;if p2 and c0 then for M=1,#d3 do bO.forceDeboard(d3[M])bO.forceInterruptVRSession(d3[M])end;c2="Deboarded All Passengers"return end;ct.adjustAutopilotTargetIndex(1)elseif ua=="option3"then local function ul()u3=not u3;if not u3 then fV("wid","DH")c.showWidget()b.showWidget()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(um,atmofueltank_size,"Atmo Fuel","fuel_container")un=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uo,spacefueltank_size,"Space Fuel","fuel_container")up=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uq,rocketfueltank_size,"Rocket Fuel","fuel_container")ur=_autoconf.panels[_autoconf.panels_size]end;us=a.createWidgetPanel("Docking")ut=a.createWidget(us,"parenting")a.addDataToWidget(c.getWidgetDataId(),ut)uu=a.createWidgetPanel("Core combat stress")uv=a.createWidget(uu,"core_stress")a.addDataToWidget(b.getWidgetDataId(),uv)if shield~=nil then shield.showWidget()end else fV("hud","DH")c.hideWidget()b.hideWidget()if un~=nil then gN(un)un=nil end;if us~=nil then gN(us)us=nil end;if uu~=nil then gN(uu)uu=nil end;if up~=nil then gN(up)up=nil end;if ur~=nil then gN(ur)ur=nil end;if shield~=nil then shield.hideWidget()end end end;uj=false;if p2 and c0 then local uk=""for M=1,#d4 do uk=uk.."| ID: "..d4[M].." Mass: "..fW(b.getDockedConstructMass(d4[M])/1000,1).."t "end;a.print("Docked Ships: "..uk)return end;if x then if w then w=false else w=true end end;ul()elseif ua=="option4"then uj=false;if p2 and c0 then for M=1,#d4 do b.forceUndock(d4[M])end;c2="Undocked all ships"return end;cY=nil;cu.ToggleAutopilot()elseif ua=="option5"then uj=false;cu.ToggleLockPitch()elseif ua=="option6"then uj=false;if p2 and c0 then if shield then cx.ventShield()else c2="No shield found"end;return end;cu.ToggleAltitudeHold()elseif ua=="option7"then uj=false;if p2 and c0 then if shield then shield.toggle()return else c2="No shield found"return end end;E=not E;if E then c2="Collision System Enabled"else c2="Collision System Secured"end elseif ua=="option8"then uj=false;if p2 and c0 then if bm>0 and g6~=nil then cu.routeWP()else c2="Select a saved wp on IPH to add to or remove from route"end;return end;bC=not bC;if not bC then c2="DeCoupled Mode - Ground Stabilization off"iF:deactivateGroundEngineAltitudeStabilization()fV("gsOff","GS")else c2="Coupled Mode - Ground Stabilization on"iF:activateGroundEngineAltitudeStabilization(u9)df=true;fV("gsOn","GS")end elseif ua=="option9"then uj=false;if p2 and c0 then iF:resetCommand(axisCommandId.longitudinal)iF:resetCommand(axisCommandId.lateral)iF:resetCommand(axisCommandId.vertical)cu.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cj=gyro.getState()==1;if cj then fV("gyOn","GA")else fV("gyOff","GA")end else c2="No gyro found"end elseif ua=="lshift"then d1=false;if p2 then c0=true elseif c0 then ui()else if iG()==1 then c0=true;bj=iG()u1(1)elseif iE()==1 and y then c0=true;cz=false;cy=false end end elseif ua=="brake"then if a_ or p2 then cu.BrakeToggle("Manual")elseif not b1 then cu.BrakeToggle("Manual")else b1="Manual"end elseif ua=="lalt"then uj=true;p2=true;if iE()==0 and not i and g=="keyboard"then u1(1)end elseif ua=="booster"then if n then d:toggleBoosters()elseif not c4 then if not tY then d:toggleBoosters()tY=true end;c4=true else if tY then d:toggleBoosters()tY=false end;c4=false end elseif ua=="stopengines"then local function uw()if bP-u8<1.5 then fV("clear","CA")cu.clearAll()end end;uw()u8=bP;if iF:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bQ~=0 then iF:resetCommand(axisCommandId.longitudinal)cu.cmdThrottle(0)else cu.cmdThrottle(100)end else if iF:getTargetSpeed(axisCommandId.longitudinal)~=0 then iF:resetCommand(axisCommandId.longitudinal)else if cf then cu.cmdCruise(cC)else cu.cmdCruise(ab*3.6)end end end elseif ua=="speedup"then if c0 and not p2 then di("RADAR OFF")return end;cu.changeSpd()elseif ua=="speeddown"then cu.changeSpd(true)elseif ua=="antigravity"and not q then if antigrav~=nil then cu.ToggleAntigrav()else c2="No antigrav found"end elseif ua=="leftmouse"then if p2 and c0 then if cv then cv.ToggleRadarPanel()cv=nil;J=false else J=true;ux.radarSetup()end;uj=false elseif c0 then c1=true;ui()end end end;function u2.stopControl(ua)local function uy()if not q and cR then u7=u5 end;if b6 or ba or bA then u6=u4 end end;if ua=="forward"then bW=0 elseif ua=="backward"then bW=0 elseif ua=="left"then if cY then if cY==2 then cY=-2 else cY=-1 end end;bX=0 elseif ua=="right"then if cY then if cY==4 then cY=-2 else cY=-1 end end;bX=0 elseif ua=="yawright"then bY=0 elseif ua=="yawleft"then bY=0 elseif ua=="straferight"then iF:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bz=0 elseif ua=="strafeleft"then iF:updateCommandFromActionStop(axisCommandId.lateral,1.0)bz=0 elseif ua=="up"then bZ=0;iF:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bC then iF:activateGroundEngineAltitudeStabilization(u9)df=true end elseif ua=="down"then bZ=0;iF:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bC then iF:activateGroundEngineAltitudeStabilization(u9)df=true end elseif ua=="groundaltitudeup"then uy()uj=false elseif ua=="groundaltitudedown"then uy()uj=false elseif ua=="brake"then if not a_ and not p2 then if b1 then cu.BrakeToggle()else b1=false end end elseif ua=="lalt"then if c0 then c0=false end;if iE()==0 and i then if uj then if iG()==1 then u1(0)else u1(1)end else uj=true end elseif iE()==0 and not i and g=="keyboard"then u1(0)end;p2=false end end;function u2.loopControl(ua)local function uz(r1)local r2=1;if r1 then r2=-1 end;if not q and cR then if bw~=nil then bw=bw+r2*u7;if bw<1000 then bw=1000 end;if b6 and bw<bb+10 and bw>bb-10 then bb=bw end;u7=dm(u7*1.05,u5,50)else bw=tz+r2*100 end elseif b6 or ba or bA then if bA then cE=cE+r2*u6;if cE<kA.noAtmosphericDensityAltitude then cE=kA.noAtmosphericDensityAltitude end else bb=bb+r2*u6 end;u6=dm(u6*1.05,u4,50)else iF:updateTargetGroundAltitudeFromActionLoop(r2*1.0)end end;local function uA(r1)local r2=1;if r1 then r2=-1 end;if not c0 then if t and not p2 then bQ=dm(bQ+r2*aG/100,-1,1)else iF:updateCommandFromActionLoop(axisCommandId.longitudinal,r2*aG)end end end;if ua=="groundaltitudeup"then if not c0 then uz()end elseif ua=="groundaltitudedown"then if not c0 then uz(true)end elseif ua=="speedup"then uA()elseif ua=="speeddown"then uA(true)end end;function u2.inputTextControl(r0)local function uB(uC,fw,gA)local function uD(fw)local dE=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dF='::pos{'..dE..','..dE..','..dE..','..dE..','..dE..'}'local dV,dW,e2,e3,e4=e5(fw,dF)if dV=="0"and dW=="0"then return vec3(dn(e2),dn(e3),dn(e4))end;e3=math.rad(e3)e2=math.rad(e2)local kA=e[dn(dV)][dn(dW)]local eW=math.cos(e2)local uE=vec3(eW*math.cos(e3),eW*math.sin(e3),math.sin(e2))return kA.center+(kA.radius+e4)*uE end;local fY=uD(fw)return ct.AddNewLocation(uC,fY,gA)end;local M;local uF,it=nil,nil;local uG="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(r0," ")uF=r0;if M~=nil then uF=string.sub(r0,0,M-1)it=string.sub(r0,M+1)end;if uF=="/help"or uF=="/commands"then for lr in string.gmatch(uG,"([^\n]+)")do a.print(lr)end;return elseif uF=="/setname"then if it==nil or it==""then c2="Usage: ah-setname Newname"return end;if bm>0 and g6~=nil then ct.UpdatePosition(it)else c2="Select a saved target to rename first"end elseif shield and uF=="/resist"then cx.setResist(it)elseif uF=="/addlocation"or string.find(r0,"::pos")~=nil then local gA=false;local uC="0-Temp"if it==nil or it==""or uF~="/addlocation"then it=uF;gA=true end;M=string.find(it,"::")if not gA then uC=string.sub(it,1,M-2)end;local fw=string.sub(it,M)uB(uC,fw,gA)elseif uF=="/agg"then if it==nil or it==""then c2="Usage: /agg targetheight"return end;it=dn(it)if it<1000 then it=1000 end;bw=it;c2="AGG Target Height set to "..it elseif uF=="/G"then if it==nil or it==""then c2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if it=="dump"then for dM,dy in pairs(iI())do if type(dy.get())=="boolean"then if dy.get()==true then a.print(dM.." true")else a.print(dM.." false")end elseif dy.get()==nil then a.print(dM.." nil")else a.print(dM.." "..dy.get())end end;return end;M=string.find(it," ")local uH=string.sub(it,0,M-1)local uI=string.sub(it,M+1)for dM,dy in pairs(iI())do if dM==uH then local uJ=type(dy.get())if uJ=="number"then uI=dn(uI)if dM=="AtmoSpeedLimit"then cC=uI end end;c2="Variable "..uH.." changed to "..uI;if dM=="MaxGameVelocity"then uI=uI/3.6;if uI>dg-0.2 then uI=dg-0.2;c2="Variable "..uH.." changed to "..fW(uI*3.6,1)end end;if uJ=="boolean"then if string.lower(uI)=="true"then uI=true else uI=false end end;dy.set(uI)return end end;c2="No such global variable: "..uH elseif uF=="/deletewp"then if bm>0 and g6~=nil then ct.ClearCurrentPosition()else c2="Select a custom wp to delete first in IPH"end elseif uF=="/copydatabank"then if dbHud_2 then pA(true)else c2="Spare Databank required to copy databank"end elseif uF=="/iphWP"then if bm>0 then a.print(cu.showWayPoint(c7,bl,true))a.print(json.encode(bl))c2="::pos waypoint shown in lua chat in local and world format"else c2="No target selected in IPH"end elseif uF=="/createPrivate"then local uK="privatelocations = {\n"local uL=""if#da>0 then for dM,dy in pairs(da)do uK=uK.."{position = {x = "..dy.position.x..", y = "..dy.position.y..", z = "..dy.position.z.."},\n ".."name = '"..dy.name.."',\n planetname = '"..dy.planetname.."',\n gravity = "..dy.gravity..",\n"if dy.heading then uK=uK.."heading = {x = "..dy.heading.x..", y = "..dy.heading.y..", z = "..dy.heading.z.."},\n"end;if dy.safe then uK=uK.."safe = true},\n"else uK=uK.."safe = false},\n"end end end;uL=#da.."-Private "if it=="all"then for dM,dy in pairs(bq)do uK=uK.."{position = {x = "..dy.position.x..", y = "..dy.position.y..", z = "..dy.position.z.."},\n ".."name = '*"..dy.name.."',\n planetname = '"..dy.planetname.."',\n gravity = "..dy.gravity..",\n"if dy.heading then uK=uK.."heading = {x = "..dy.heading.x..", y = "..dy.heading.y..", z = "..dy.heading.z.."},\n"end;if dy.safe then uK=uK.." safe = true},\n"else uK=uK.."safe = false},\n"end end;uL=uL..#bq.."-Public "end;uK=uK.."}\n return privatelocations"if u0 then u0.setHTML(uK)end;c2=uL.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c3=7 end end;function u2.tagTick()if bD=="Off"then bD="All"elseif bD=="All"then bD="Longitude"elseif bD=="Longitude"then bD="Lateral"elseif bD=="Lateral"then bD="Vertical"else bD="Off"end;c2="Extra Engine Tags: "..bD;c.stopTimer("tagTick")end;if uM then for dM,dy in pairs(uM)do u2[dM]=dy end end;return u2 end;local function uN(d,b,c,e,vBooster,hover,pz,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iB,u0)local a=DUSystem;local bO=DUConstruct;local uO=DUPlayer;local uP=DULibrary;local uQ={}local dl=string.format;local iC=json.decode;local uR=json.encode;local ps=b.getElementMaxHitPointsById;local iD=b.getElementMassById;local iE=d.control.isRemoteControlled;local e5=string.match;local gN=a.destroyWidgetPanel;local fT=a.updateData;local fU=a.addDataToWidget;local u1=a.lockView;local iG=a.isViewLocked;local dp=math.sqrt;local dn=tonumber;local e_=math.abs;local bM=math.floor;local bN=c.getAtmosphereDensity;local eV=math.atan;local bL=a.getArkTime;local dm=utils.clamp;local iF=d.axisCommandManager;local uS=_;local gP=13;local iL=b.getElementIdList()local iM=0;local function dq(eD,eE)if eD==0 then return e_(eE)<1e-09 end;if eE==0 then return e_(eD)<1e-09 end;return e_(eD-eE)<math.max(e_(eD),e_(eE))*dD end;local function fW(dE,uT)local r2=10^(uT or 0)return bM(dE*r2+0.5)/r2 end;local function iH(uU,uV)for dM,dy in pairs(uV)do if type(dM)=="string"then uU[dM]=dy else uU[#uU+1]=uV[dM]end end;return uU end;local function iI(uW)local uX={}if not uW then iH(uX,L)iH(uX,aa)iH(uX,aE)iH(uX,aZ)return uX elseif uW=="boolean"then return L elseif uW=="handling"then return aa elseif uW=="hud"then return aE elseif uW=="physics"then return aZ end end;local function pA(uY)local function uZ(u_)for dM,dy in pairs(u_)do dbHud_1.setStringValue(dM,uR(dy.get()))if uY and dbHud_2 then dbHud_2.setStringValue(dM,uR(dy.get()))end end end;if dbHud_1 then uZ(bI)uZ(iI())a.print("Saved Variables to Datacore")if uY and dbHud_2 then c2="Databank copied.  Remove copy when ready."end end end;local function fV(v0,v1,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v0 ..".mp3")end;local function gO(hB,hC,r0,jS,v2)if jS==nil then jS=""end;if v2==nil then v2=""end;return dl([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jS,hB,hC,v2,r0)end;local function iJ(ca,v3)local v4=ca>100000;if v3==nil then v3=1 end;if v4 then return fW(ca/1000/200,v3).."SU"elseif ca<1000 then return fW(ca,v3).."M"else return fW(ca/1000,v3).."KM"end end;local function iK(v5)local v6=0;local v7=0;local v8=0;if v5<60 then v5=bM(v5)elseif v5<3600 then v6=bM(v5/60)v5=bM(v5%60)elseif v5<86400 then v7=bM(v5/3600)v6=bM(v5%3600/60)else v8=bM(v5/86400)v7=bM(v5%86400/3600)end;if v8>0 then return v8 .."d "..v7 .."h "elseif v7>0 then return v7 .."h "..v6 .."m "elseif v6>0 then return v6 .."m "..v5 .."s"elseif v5>0 then return v5 .."s"else return"0s"end end;local function v9()if radar_1 and J then cv=gM(b,a,c,radar_1,radar_2,warpdrive,e_,gN,dp,gO,dn,gP,fV)end end;function uQ.radarSetup()v9()end;function uQ.onStart()local va=false;local function vb()local function vc(vd)local ve=dbHud_1.hasKey;for dM,dy in pairs(vd)do if ve(dM)then local dH=iC(dbHud_1.getStringValue(dM))if dH~=nil then dy.set(dH)va=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vc(iI())coroutine.yield()vc(bI)else vc(bI)c2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"c3=5;va=false end;coroutine.yield()if va then c2="Loaded Saved Variables"elseif not f then c2="No Databank Saved Variables Found\nVariables will save to Databank on standing"c3=5 end;if#bq>0 then db=iH(db,bq)end else c2="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;ck=ac;cl=ad;a_=j;g=string.lower(g)cA=p;cC=W;if bx+180<bP then bv=0 end;bx=bP;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c3=7 end;if antigrav and not q then if bw==nil then bw=ch end;antigrav.setTargetAltitude(bw)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#da>0 then db=iH(db,da)end end;lw="Proceeding to Waypoint"if not ab or ab<0 then ab=bO.getMaxSpeed()-0.1 end end;local function vf()local function vg(vh,vi)if vh>vi then vi=vh end;local vj,vk=0,0;if a6>0 then vj=a6*0.05 end;if a7>0 then vk=a7*0.05 end;vi=vi*(1-(vj+vk))return vi end;local vl=b.getElementNameById;local vm=at~=0 and au~=0;local vn=_G["atmofueltank_size"]local vo=_G["spacefueltank_size"]local vp=_G["rocketfueltank_size"]for dM in pairs(iL)do local type=b.getElementDisplayNameById(iL[dM])if e5(type,'^.*Atmospheric Engine$')then if e5(tostring(b.getElementTagsById(iL[dM])),'^.*vertical.*$')and b.getElementForwardById(iL[dM])[3]>0 then cQ=true end end;if e5(type,'^.*Space Engine$')then cH=true;if e5(tostring(b.getElementTagsById(iL[dM])),'^.*vertical.*$')then local vq=b.getElementForwardById(iL[dM])if vq[3]<0 then vr=true else cG=true end end end;if type=="Landing Gear"then bV=true end;if type=="Dynamic Core Unit"then local pu=ps(iL[dM])if pu>10000 then gP=110 elseif pu>1000 then gP=55 elseif pu>150 then gP=27 end end;iM=iM+ps(iL[dM])if vm and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pu=ps(iL[dM])local ok=iD(iL[dM])local vh=0;local jL=bL()if type=="Atmospheric Fuel Tank"then local vi=400;local vs=35.03;if pu>10000 then vi=51200;vs=5480 elseif pu>1300 then vi=6400;vs=988.67 elseif pu>150 then vi=1600;vs=182.67 end;vh=ok-vs;if a3>0 then vi=vi+vi*a3*0.2 end;vi=vg(vh,vi)local gz=vl(iL[dM])local jJ=0;for jK=1,vn do if gz==iC(c["atmofueltank_"..jK].getWidgetData()).name then jJ=jK;break end end;local vt={iL[dM],string.sub(gz,1,12),vi,vs,vh,jL,jJ}cm[#cm+1]=vt end;if type=="Rocket Fuel Tank"then local vi=320;local vs=173.42;if pu>65000 then vi=40000;vs=25740 elseif pu>6000 then vi=5120;vs=4720 elseif pu>700 then vi=640;vs=886.72 end;vh=ok-vs;if a5>0 then vi=vi+vi*a5*0.1 end;vi=vg(vh,vi)local gz=vl(iL[dM])local jJ=0;for jK=1,vp do if gz==iC(c["rocketfueltank_"..jK].getWidgetData()).name then jJ=jK;break end end;local vt={iL[dM],string.sub(gz,1,12),vi,vs,vh,jL,jJ}co[#co+1]=vt end;if type=="Space Fuel Tank"then local vi=600;local vs=35.03;if pu>10000 then vi=76800;vs=5480 elseif pu>1300 then vi=9600;vs=988.67 elseif pu>150 then vi=2400;vs=182.67 end;vh=ok-vs;if a4>0 then vi=vi+vi*a4*0.2 end;vi=vg(vh,vi)local gz=vl(iL[dM])local jJ=0;for jK=1,vo do if gz==iC(c["spacefueltank_"..jK].getWidgetData()).name then jJ=jK;break end end;local vt={iL[dM],string.sub(gz,1,12),vi,vs,vh,jL,jJ}cn[#cn+1]=vt end end end;if not cQ then ba,b0=false,false end end;local function vu()if gyro~=nil then cj=gyro.isActive()==1 end;if not bC then iF:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u1(1)else u1(0)end;if door and(cf or not cf and ch<10000)then for dR,dy in pairs(door)do dy.toggle()end end;if switch then for dR,dy in pairs(switch)do dy.toggle()end end;if forcefield and(cf or not cf==0 and ch<10000)then for dR,dy in pairs(forcefield)do dy.toggle()end end;if antigrav then cR=antigrav.isActive()==1;if cR and not q then antigrav.showWidget()end end;if iE()==1 and k then uO.freeze(1)else uO.freeze(0)end;if bV then if ce~=-1 and not cR then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bn=d.control.isAnyLandingGearDeployed()==1 or ce~=-1 and ce-3<_;if ce~=-1 or not cf and cK:len()<50 then b1="Startup"else b1=false end;iF:setTargetGroundAltitude(uS)pg=cf end;local function vv()local vw={}local function vx()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vy={[1]=4480,[6]=4480,[7]=6270,[27]=4150}local vz={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=7700,[100]=12511,[110]=7792,[120]=11766}for vA,vB in pairs(e)do e[vA][0]=vx()e[vA][0].systemId=vA;vw[vA]={}for vC,kA in pairs(e[vA])do kA.gravity=kA.gravity/9.8;kA.center=vec3(kA.center)kA.name=kA.name[1]kA.noAtmosphericDensityAltitude=vz[kA.id]or kA.atmosphereThickness or kA.atmosphereRadius-kA.radius;kA.spaceEngineMinAltitude=vy[kA.id]or 0.68377*kA.atmosphereThickness;kA.planetarySystemId=vA;kA.bodyId=kA.id;vw[vA][vC]=kA;if mm==nil or kA.center.x<mm then mm=kA.center.x end;if ml==nil or kA.center.x>ml then ml=kA.center.x end;if mp==nil or kA.center.y<mp then mp=kA.center.y end;if mo==nil or kA.center.y>mo then mo=kA.center.y end;if kA.center and kA.name~="Space"then d5[#d5+1]=kA end end end;ef=dk(d,b,c,a,dl,dm,dn,dp,dq)cp=ef(vw)cq=eZ(d,b,c,a,dp,e_)cr=fs(d,b,c,a,dl,dm,dn,dp,dq)ct=fS(d,b,c,a,dbHud_1,e,fT,fU,bM,dn,dp,fV,fW)kA=cp[0]:closestBody(bO.getWorldPosition())end;vD=false;vE=coroutine.create(function()iF:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vb()coroutine.yield()vf()coroutine.yield()cu=py(d,b,c,e,vBooster,hover,pz,antigrav,warpdrive,dbHud_1,e_,bM,bN,iE,eV,bL,dm,iF,fT,iG,dp,fW,fV,iH,dq,iJ,iK,pA,iC,dl,fU)vu()coroutine.yield()vv()v9()if iA then cs=iA(d,b,c,a,e,antigrav,hover,shield,warpdrive,iB,e_,bM,dl,iC,bN,iD,iE,eV,bL,dm,iF,fU,fT,gN,iG,dp,fW,gO,fV,iH,iI,iJ,iK,iL,iM)end;if cs then cs.ButtonSetup()end;cw=t_(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u0,iE,iF,iG,u1,gN,fW,e5,dn,dm,fV,iI,pA)if shield then cx=ij(shield,e5,bM)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if u0 then u0.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aU)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vF then ux.ExtraOnStart()end;fV("start","SU")local function vG()if bH[1]==0 then cu.cmdThrottle(bH[2])else if cg>0 then cC=bH[2]cu.cmdThrottle(1)end end end;ln=string.find(c.getName(),"Emergency")or false;if ln then if ce>-1 and cM<1 and ce-3<_ then c.exit()else if K then vG()else if cg==0 then b1="ECU Braking"elseif ce==-1 then cw.landingGear()end end end elseif K and bH[3]+3>bL()then vG()end end)coroutine.resume(vE)end;function uQ.onUpdate()if not vD then local ia=coroutine.status(vE)if ia=="suspended"then local dN,ib=coroutine.resume(vE)if ib then a.print("ERROR STARTUP: "..ib)end elseif ia=="dead"then vD=true end end;if vD then d:update()if cf and t and cS then if cS and bU then cu.cmdThrottle(0)bU=false elseif not cS and not bU then bQ=0;bU=true end end;if d8 then iF:setThrottleCommand(axisCommandId.longitudinal,d8)d8=nil end;if not cy and p4~=vH then a.setScreen(p4)end;vH=p4;if ln and not K and cg>0 and ce==-1 then cw.landingGear()end;if ln and ce>-1 and cM<1 and ce-3<_ then c.exit()end;if vF then ux.ExtraOnUpdate()end end end;function uQ.onFlush()if vD then cu.onFlush()if vF then ux.ExtraOnFlush()end end end;function uQ.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cg>0 or cg==0 and ch<10000)then for dR,dy in pairs(door)do dy.toggle()end end;if switch then for dR,dy in pairs(switch)do dy.toggle()end end;if forcefield and(cg>0 or cg==0 and ch<10000)then for dR,dy in pairs(forcefield)do dy.toggle()end end;w=d7;local vI=0;if ln then vI=bL()end;if iF:getAxisCommandType(0)==0 then bH={0,bQ,vI}else bH={1,iF:getTargetSpeed(axisCommandId.longitudinal),vI}end;pA()if nV then nV.activate()end;if z then cu.showWayPoint(kA,cP)end;if cs then a.print(cs.FuelUsed("atmofueltank")..", "..cs.FuelUsed("spacefueltank")..", "..cs.FuelUsed("rocketfueltank"))end;if vF then ux.ExtraOnStop()end;fV("stop","SU")end;function uQ.controlStart(ua)if vD then cw.startControl(ua)end end;function uQ.controlStop(ua)if vD then cw.stopControl(ua)end end;function uQ.controlLoop(ua)if vD then cw.loopControl(ua)end end;function uQ.controlInput(r0)if vD then cw.inputTextControl(r0)end end;function uQ.radarEnter(dW)if cv then cv.onEnter(dW)end end;function uQ.radarLeave(dW)if cv then cv.onLeave(dW)end end;function uQ.onTick(vJ)if vJ=="tenthSecond"then if cu then cu.TenthTick()end;if cs then cs.TenthTick()end elseif vJ=="oneSecond"then if cs then cs.OneSecondTick()end elseif vJ=="fiveSecond"then cu.SatNavTick()elseif vJ=="msgTick"then if cs then cs.MsgTick()end elseif vJ=="animateTick"then if cs then cs.AnimateTick()end elseif vJ=="hudTick"then if cs then cs.hudtick()end elseif vJ=="apTick"then if cu then cu.APTick()end elseif vJ=="shieldTick"then cx.shieldTick()elseif vJ=="tagTick"then cw.tagTick()elseif vJ=="contact"then cv.ContactTick()end end;if vF then for dM,dy in pairs(vF)do uQ[dM]=dy end end;return uQ end;function script.onStart()ux.onStart()end;function script.onOnStop()ux.onStop()end;function script.onTick(vJ)ux.onTick(vJ)end;function script.onOnFlush()ux.onFlush()end;function script.onOnUpdate()ux.onUpdate()end;function script.onActionStart(ua)ux.controlStart(ua)end;function script.onActionStop(ua)ux.controlStop(ua)end;function script.onActionLoop(ua)ux.controlLoop(ua)end;function script.onInputText(r0)ux.controlInput(r0)end;function script.onEnter(dW)ux.radarEnter(dW)end;function script.onLeave(dW)ux.radarLeave(dW)end;bK(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)ux=uN(d,core,unit,e,vBooster,hover,pz,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iB,u0)script.onStart()
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
